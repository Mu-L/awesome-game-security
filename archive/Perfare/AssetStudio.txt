Project Path: arc_Perfare_AssetStudio_xzi210gw

Source Tree:

```txt
arc_Perfare_AssetStudio_xzi210gw
├── AssetStudio
│   ├── 7zip
│   │   ├── Common
│   │   │   ├── CRC.cs
│   │   │   ├── CommandLineParser.cs
│   │   │   ├── InBuffer.cs
│   │   │   └── OutBuffer.cs
│   │   ├── Compress
│   │   │   ├── LZ
│   │   │   │   ├── IMatchFinder.cs
│   │   │   │   ├── LzBinTree.cs
│   │   │   │   ├── LzInWindow.cs
│   │   │   │   └── LzOutWindow.cs
│   │   │   ├── LZMA
│   │   │   │   ├── LzmaBase.cs
│   │   │   │   ├── LzmaDecoder.cs
│   │   │   │   └── LzmaEncoder.cs
│   │   │   └── RangeCoder
│   │   │       ├── RangeCoder.cs
│   │   │       ├── RangeCoderBit.cs
│   │   │       └── RangeCoderBitTree.cs
│   │   └── ICoder.cs
│   ├── AssetStudio.csproj
│   ├── AssetsManager.cs
│   ├── BigArrayPool.cs
│   ├── Brotli
│   │   ├── BitReader.cs
│   │   ├── BrotliInputStream.cs
│   │   ├── BrotliRuntimeException.cs
│   │   ├── Context.cs
│   │   ├── Decode.cs
│   │   ├── Dictionary.cs
│   │   ├── Huffman.cs
│   │   ├── HuffmanTreeGroup.cs
│   │   ├── IntReader.cs
│   │   ├── Prefix.cs
│   │   ├── RunningState.cs
│   │   ├── State.cs
│   │   ├── Transform.cs
│   │   ├── Utils.cs
│   │   └── WordTransformType.cs
│   ├── BuildTarget.cs
│   ├── BuildType.cs
│   ├── BundleFile.cs
│   ├── ClassIDType.cs
│   ├── Classes
│   │   ├── Animation.cs
│   │   ├── AnimationClip.cs
│   │   ├── Animator.cs
│   │   ├── AnimatorController.cs
│   │   ├── AnimatorOverrideController.cs
│   │   ├── AssetBundle.cs
│   │   ├── AudioClip.cs
│   │   ├── Avatar.cs
│   │   ├── Behaviour.cs
│   │   ├── BuildSettings.cs
│   │   ├── Component.cs
│   │   ├── EditorExtension.cs
│   │   ├── Font.cs
│   │   ├── GameObject.cs
│   │   ├── Material.cs
│   │   ├── Mesh.cs
│   │   ├── MeshFilter.cs
│   │   ├── MeshRenderer.cs
│   │   ├── MonoBehaviour.cs
│   │   ├── MonoScript.cs
│   │   ├── MovieTexture.cs
│   │   ├── NamedObject.cs
│   │   ├── Object.cs
│   │   ├── PPtr.cs
│   │   ├── PlayerSettings.cs
│   │   ├── RectTransform.cs
│   │   ├── Renderer.cs
│   │   ├── ResourceManager.cs
│   │   ├── RuntimeAnimatorController.cs
│   │   ├── Shader.cs
│   │   ├── SkinnedMeshRenderer.cs
│   │   ├── Sprite.cs
│   │   ├── SpriteAtlas.cs
│   │   ├── TextAsset.cs
│   │   ├── Texture.cs
│   │   ├── Texture2D.cs
│   │   ├── Transform.cs
│   │   └── VideoClip.cs
│   ├── CommonString.cs
│   ├── EndianBinaryReader.cs
│   ├── EndianType.cs
│   ├── Extensions
│   │   ├── BinaryReaderExtensions.cs
│   │   ├── BinaryWriterExtensions.cs
│   │   └── StreamExtensions.cs
│   ├── FileIdentifier.cs
│   ├── FileReader.cs
│   ├── FileType.cs
│   ├── IImported.cs
│   ├── ILogger.cs
│   ├── ImportHelper.cs
│   ├── LocalSerializedObjectIdentifier.cs
│   ├── Logger.cs
│   ├── Math
│   │   ├── Color.cs
│   │   ├── Half.cs
│   │   ├── HalfHelper.cs
│   │   ├── Matrix4x4.cs
│   │   ├── Quaternion.cs
│   │   ├── Vector2.cs
│   │   ├── Vector3.cs
│   │   └── Vector4.cs
│   ├── ObjectInfo.cs
│   ├── ObjectReader.cs
│   ├── Progress.cs
│   ├── ResourceReader.cs
│   ├── SerializedFile.cs
│   ├── SerializedFileFormatVersion.cs
│   ├── SerializedFileHeader.cs
│   ├── SerializedType.cs
│   ├── SevenZipHelper.cs
│   ├── StreamFile.cs
│   ├── TypeTree.cs
│   ├── TypeTreeHelper.cs
│   ├── TypeTreeNode.cs
│   └── WebFile.cs
├── AssetStudio.PInvoke
│   ├── AssetStudio.PInvoke.csproj
│   ├── DllLoader.cs
│   └── Utf8StringHandle.cs
├── AssetStudio.sln
├── AssetStudioFBXNative
│   ├── AssetStudioFBXNative.rc
│   ├── AssetStudioFBXNative.vcxproj
│   ├── AssetStudioFBXNative.vcxproj.filters
│   ├── api.cpp
│   ├── api.h
│   ├── asfbx_anim_context.cpp
│   ├── asfbx_anim_context.h
│   ├── asfbx_context.cpp
│   ├── asfbx_context.h
│   ├── asfbx_morph_context.cpp
│   ├── asfbx_morph_context.h
│   ├── asfbx_skin_context.cpp
│   ├── asfbx_skin_context.h
│   ├── bool32_t.h
│   ├── cpp.hint
│   ├── dllexport.h
│   ├── resource.h
│   ├── utils.cpp
│   └── utils.h
├── AssetStudioFBXWrapper
│   ├── AssetStudioFBXWrapper.csproj
│   ├── Fbx.PInvoke.cs
│   ├── Fbx.cs
│   ├── FbxDll.cs
│   ├── FbxExporter.cs
│   ├── FbxExporterContext.PInvoke.cs
│   └── FbxExporterContext.cs
├── AssetStudioGUI
│   ├── AssetStudioGUI.csproj
│   ├── AssetStudioGUIForm.Designer.cs
│   ├── AssetStudioGUIForm.cs
│   ├── AssetStudioGUIForm.resx
│   ├── Components
│   │   ├── AssetItem.cs
│   │   ├── GOHierarchy.cs
│   │   ├── GameObjectTreeNode.cs
│   │   ├── OpenFolderDialog.cs
│   │   └── TypeTreeItem.cs
│   ├── DirectBitmap.cs
│   ├── ExportOptions.Designer.cs
│   ├── ExportOptions.cs
│   ├── ExportOptions.resx
│   ├── Exporter.cs
│   ├── GUILogger.cs
│   ├── Libraries
│   │   └── OpenTK.WinForms.dll
│   ├── Program.cs
│   ├── Properties
│   │   ├── Resources.Designer.cs
│   │   ├── Resources.resx
│   │   ├── Settings.Designer.cs
│   │   └── Settings.settings
│   ├── Resources
│   │   ├── as.ico
│   │   └── preview.png
│   └── Studio.cs
├── AssetStudioUtility
│   ├── AssemblyLoader.cs
│   ├── AssetStudioUtility.csproj
│   ├── AudioClipConverter.cs
│   ├── CSspv
│   │   ├── Disassembler.cs
│   │   ├── EnumValuesExtensions.cs
│   │   ├── Instruction.cs
│   │   ├── LICENSE
│   │   ├── Module.cs
│   │   ├── OperandType.cs
│   │   ├── ParsedInstruction.cs
│   │   ├── Reader.cs
│   │   ├── SpirV.Core.Grammar.cs
│   │   ├── SpirV.Meta.cs
│   │   └── Types.cs
│   ├── FMOD Studio API
│   │   ├── fmod.cs
│   │   ├── fmod_dsp.cs
│   │   └── fmod_errors.cs
│   ├── ImageExtensions.cs
│   ├── ImageFormat.cs
│   ├── ModelConverter.cs
│   ├── ModelExporter.cs
│   ├── MonoBehaviourConverter.cs
│   ├── MyAssemblyResolver.cs
│   ├── SerializedTypeHelper.cs
│   ├── ShaderConverter.cs
│   ├── Smolv
│   │   ├── OpData.cs
│   │   ├── SmolvDecoder.cs
│   │   └── SpvOp.cs
│   ├── SpirVShaderConverter.cs
│   ├── SpriteHelper.cs
│   ├── Texture2DConverter.cs
│   ├── Texture2DExtensions.cs
│   ├── TypeDefinitionConverter.cs
│   ├── Unity.CecilTools
│   │   ├── CecilUtils.cs
│   │   ├── ElementType.cs
│   │   └── Extensions
│   │       ├── MethodDefinitionExtensions.cs
│   │       ├── ResolutionExtensions.cs
│   │       ├── TypeDefinitionExtensions.cs
│   │       └── TypeReferenceExtensions.cs
│   └── Unity.SerializationLogic
│       ├── UnityEngineTypePredicates.cs
│       └── UnitySerializationLogic.cs
├── LICENSE
├── README.md
├── Texture2DDecoderNative
│   ├── Texture2DDecoderNative.rc
│   ├── Texture2DDecoderNative.vcxproj
│   ├── Texture2DDecoderNative.vcxproj.filters
│   ├── astc.cpp
│   ├── astc.h
│   ├── atc.cpp
│   ├── atc.h
│   ├── bcn.cpp
│   ├── bcn.h
│   ├── bool32_t.h
│   ├── color.h
│   ├── cpp.hint
│   ├── crunch
│   │   ├── crn_decomp.h
│   │   └── crnlib.h
│   ├── crunch.cpp
│   ├── crunch.h
│   ├── dllexport.h
│   ├── dllmain.cpp
│   ├── endianness.h
│   ├── etc.cpp
│   ├── etc.h
│   ├── fp16
│   │   ├── bitcasts.h
│   │   └── fp16.h
│   ├── fp16.h
│   ├── pvrtc.cpp
│   ├── pvrtc.h
│   ├── resource.h
│   ├── unitycrunch
│   │   ├── crn_decomp.h
│   │   ├── crn_defs.h
│   │   └── crnlib.h
│   ├── unitycrunch.cpp
│   └── unitycrunch.h
└── Texture2DDecoderWrapper
    ├── T2DDll.cs
    ├── Texture2DDecoderWrapper.csproj
    ├── TextureDecoder.PInvoke.cs
    └── TextureDecoder.cs

```

`AssetStudio.PInvoke/AssetStudio.PInvoke.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net472;netstandard2.0;net5.0;net6.0</TargetFrameworks>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Version>0.16.0.0</Version>
    <AssemblyVersion>0.16.0.0</AssemblyVersion>
    <FileVersion>0.16.0.0</FileVersion>
    <Copyright>Copyright © Perfare 2020-2022; Copyright © hozuki 2020</Copyright>
    <DebugType>embedded</DebugType>
  </PropertyGroup>

</Project>

```

`AssetStudio.PInvoke/DllLoader.cs`:

```cs
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;

namespace AssetStudio.PInvoke
{
    public static class DllLoader
    {

        public static void PreloadDll(string dllName)
        {
            var dllDir = GetDirectedDllDirectory();

            // Not using OperatingSystem.Platform.
            // See: https://www.mono-project.com/docs/faq/technical/#how-to-detect-the-execution-platform
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                Win32.LoadDll(dllDir, dllName);
            }
            else
            {
                Posix.LoadDll(dllDir, dllName);
            }
        }

        private static string GetDirectedDllDirectory()
        {
            var localPath = Process.GetCurrentProcess().MainModule.FileName;
            var localDir = Path.GetDirectoryName(localPath);

            var subDir = Environment.Is64BitProcess ? "x64" : "x86";

            var directedDllDir = Path.Combine(localDir, subDir);

            return directedDllDir;
        }

        private static class Win32
        {

            internal static void LoadDll(string dllDir, string dllName)
            {
                var dllFileName = $"{dllName}.dll";
                var directedDllPath = Path.Combine(dllDir, dllFileName);

                // Specify SEARCH_DLL_LOAD_DIR to load dependent libraries located in the same platform-specific directory.
                var hLibrary = LoadLibraryEx(directedDllPath, IntPtr.Zero, LOAD_LIBRARY_SEARCH_DEFAULT_DIRS | LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR);

                if (hLibrary == IntPtr.Zero)
                {
                    var errorCode = Marshal.GetLastWin32Error();
                    var exception = new Win32Exception(errorCode);

                    throw new DllNotFoundException(exception.Message, exception);
                }
            }

            // HMODULE LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
            // HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern IntPtr LoadLibraryEx(string lpLibFileName, IntPtr hFile, uint dwFlags);

            private const uint LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 0x1000;
            private const uint LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 0x100;

        }

        private static class Posix
        {

            internal static void LoadDll(string dllDir, string dllName)
            {
                string dllExtension;

                if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                {
                    dllExtension = ".so";
                }
                else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                {
                    dllExtension = ".dylib";
                }
                else
                {
                    throw new NotSupportedException();
                }

                var dllFileName = $"lib{dllName}{dllExtension}";
                var directedDllPath = Path.Combine(dllDir, dllFileName);

                const int ldFlags = RTLD_NOW | RTLD_GLOBAL;
                var hLibrary = DlOpen(directedDllPath, ldFlags);

                if (hLibrary == IntPtr.Zero)
                {
                    var pErrStr = DlError();
                    // `PtrToStringAnsi` always uses the specific constructor of `String` (see dotnet/core#2325),
                    // which in turn interprets the byte sequence with system default codepage. On OSX and Linux
                    // the codepage is UTF-8 so the error message should be handled correctly.
                    var errorMessage = Marshal.PtrToStringAnsi(pErrStr);

                    throw new DllNotFoundException(errorMessage);
                }
            }

            // OSX and most Linux OS use LP64 so `int` is still 32-bit even on 64-bit platforms.
            // void *dlopen(const char *filename, int flag);
            [DllImport("libdl", EntryPoint = "dlopen")]
            private static extern IntPtr DlOpen([MarshalAs(UnmanagedType.LPStr)] string fileName, int flags);

            // char *dlerror(void);
            [DllImport("libdl", EntryPoint = "dlerror")]
            private static extern IntPtr DlError();

            private const int RTLD_LAZY = 0x1;
            private const int RTLD_NOW = 0x2;
            private const int RTLD_GLOBAL = 0x100;

        }

    }
}

```

`AssetStudio.PInvoke/Utf8StringHandle.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using System.Text;
using Microsoft.Win32.SafeHandles;

namespace AssetStudio.PInvoke
{
    // Generally the technique from Steamworks.NET
    public class Utf8StringHandle : SafeHandleZeroOrMinusOneIsInvalid
    {

        static Utf8StringHandle()
        {
            Utf8 = new UTF8Encoding(false);
        }

        public Utf8StringHandle(string str)
            : base(true)
        {
            IntPtr buffer;

            if (str == null)
            {
                buffer = IntPtr.Zero;
            }
            else
            {
                if (str.Length == 0)
                {
                    buffer = Marshal.AllocHGlobal(1);

                    unsafe
                    {
                        *(byte*)buffer = 0;
                    }
                }
                else
                {
                    var strlen = Utf8.GetByteCount(str);
                    var strBuffer = new byte[strlen + 1];

                    Utf8.GetBytes(str, 0, str.Length, strBuffer, 0);

                    buffer = Marshal.AllocHGlobal(strBuffer.Length);

                    Marshal.Copy(strBuffer, 0, buffer, strBuffer.Length);
                }
            }

            SetHandle(buffer);
        }

        public static string ReadUtf8StringFromPointer(IntPtr lpstr)
        {
            if (lpstr == IntPtr.Zero || lpstr == new IntPtr(-1))
            {
                return null;
            }

            var byteCount = 0;

            unsafe
            {
                var p = (byte*)lpstr.ToPointer();

                while (*p != 0)
                {
                    byteCount += 1;
                    p += 1;
                }
            }

            if (byteCount == 0)
            {
                return string.Empty;
            }

            var strBuffer = new byte[byteCount];

            Marshal.Copy(lpstr, strBuffer, 0, byteCount);

            var str = Utf8.GetString(strBuffer);

            return str;
        }

        protected override bool ReleaseHandle()
        {
            if (!IsInvalid)
            {
                Marshal.FreeHGlobal(handle);
            }

            return true;
        }

        private static readonly UTF8Encoding Utf8;

    }
}

```

`AssetStudio.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31410.357
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetStudio", "AssetStudio\AssetStudio.csproj", "{422FEC21-EF60-4F29-AA56-95DFDA23C913}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetStudio.PInvoke", "AssetStudio.PInvoke\AssetStudio.PInvoke.csproj", "{0B2BE613-3049-4021-85D1-21C325F729F4}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetStudioFBXWrapper", "AssetStudioFBXWrapper\AssetStudioFBXWrapper.csproj", "{E301AFEA-84E7-4BCE-8D65-A2576D8D105B}"
	ProjectSection(ProjectDependencies) = postProject
		{11EA25A3-ED68-40EE-A9D0-7FDE3B583027} = {11EA25A3-ED68-40EE-A9D0-7FDE3B583027}
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetStudioGUI", "AssetStudioGUI\AssetStudioGUI.csproj", "{29EAD018-1C67-497A-AB8E-727D595AD756}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetStudioUtility", "AssetStudioUtility\AssetStudioUtility.csproj", "{65EAFFA3-01D3-4EF5-B092-8B4647E9A1FF}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Texture2DDecoderWrapper", "Texture2DDecoderWrapper\Texture2DDecoderWrapper.csproj", "{6438FEC1-56B0-488C-A5E2-FBDB23E9574B}"
	ProjectSection(ProjectDependencies) = postProject
		{29356642-C46E-4144-83D8-22DC09D0D7FD} = {29356642-C46E-4144-83D8-22DC09D0D7FD}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AssetStudioFBXNative", "AssetStudioFBXNative\AssetStudioFBXNative.vcxproj", "{11EA25A3-ED68-40EE-A9D0-7FDE3B583027}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Texture2DDecoderNative", "Texture2DDecoderNative\Texture2DDecoderNative.vcxproj", "{29356642-C46E-4144-83D8-22DC09D0D7FD}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{422FEC21-EF60-4F29-AA56-95DFDA23C913}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{422FEC21-EF60-4F29-AA56-95DFDA23C913}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{422FEC21-EF60-4F29-AA56-95DFDA23C913}.Debug|x64.ActiveCfg = Debug|Any CPU
		{422FEC21-EF60-4F29-AA56-95DFDA23C913}.Debug|x64.Build.0 = Debug|Any CPU
		{422FEC21-EF60-4F29-AA56-95DFDA23C913}.Debug|x86.ActiveCfg = Debug|Any CPU
		{422FEC21-EF60-4F29-AA56-95DFDA23C913}.Debug|x86.Build.0 = Debug|Any CPU
		{422FEC21-EF60-4F29-AA56-95DFDA23C913}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{422FEC21-EF60-4F29-AA56-95DFDA23C913}.Release|Any CPU.Build.0 = Release|Any CPU
		{422FEC21-EF60-4F29-AA56-95DFDA23C913}.Release|x64.ActiveCfg = Release|Any CPU
		{422FEC21-EF60-4F29-AA56-95DFDA23C913}.Release|x64.Build.0 = Release|Any CPU
		{422FEC21-EF60-4F29-AA56-95DFDA23C913}.Release|x86.ActiveCfg = Release|Any CPU
		{422FEC21-EF60-4F29-AA56-95DFDA23C913}.Release|x86.Build.0 = Release|Any CPU
		{0B2BE613-3049-4021-85D1-21C325F729F4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0B2BE613-3049-4021-85D1-21C325F729F4}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0B2BE613-3049-4021-85D1-21C325F729F4}.Debug|x64.ActiveCfg = Debug|Any CPU
		{0B2BE613-3049-4021-85D1-21C325F729F4}.Debug|x64.Build.0 = Debug|Any CPU
		{0B2BE613-3049-4021-85D1-21C325F729F4}.Debug|x86.ActiveCfg = Debug|Any CPU
		{0B2BE613-3049-4021-85D1-21C325F729F4}.Debug|x86.Build.0 = Debug|Any CPU
		{0B2BE613-3049-4021-85D1-21C325F729F4}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0B2BE613-3049-4021-85D1-21C325F729F4}.Release|Any CPU.Build.0 = Release|Any CPU
		{0B2BE613-3049-4021-85D1-21C325F729F4}.Release|x64.ActiveCfg = Release|Any CPU
		{0B2BE613-3049-4021-85D1-21C325F729F4}.Release|x64.Build.0 = Release|Any CPU
		{0B2BE613-3049-4021-85D1-21C325F729F4}.Release|x86.ActiveCfg = Release|Any CPU
		{0B2BE613-3049-4021-85D1-21C325F729F4}.Release|x86.Build.0 = Release|Any CPU
		{E301AFEA-84E7-4BCE-8D65-A2576D8D105B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E301AFEA-84E7-4BCE-8D65-A2576D8D105B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E301AFEA-84E7-4BCE-8D65-A2576D8D105B}.Debug|x64.ActiveCfg = Debug|Any CPU
		{E301AFEA-84E7-4BCE-8D65-A2576D8D105B}.Debug|x64.Build.0 = Debug|Any CPU
		{E301AFEA-84E7-4BCE-8D65-A2576D8D105B}.Debug|x86.ActiveCfg = Debug|Any CPU
		{E301AFEA-84E7-4BCE-8D65-A2576D8D105B}.Debug|x86.Build.0 = Debug|Any CPU
		{E301AFEA-84E7-4BCE-8D65-A2576D8D105B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E301AFEA-84E7-4BCE-8D65-A2576D8D105B}.Release|Any CPU.Build.0 = Release|Any CPU
		{E301AFEA-84E7-4BCE-8D65-A2576D8D105B}.Release|x64.ActiveCfg = Release|Any CPU
		{E301AFEA-84E7-4BCE-8D65-A2576D8D105B}.Release|x64.Build.0 = Release|Any CPU
		{E301AFEA-84E7-4BCE-8D65-A2576D8D105B}.Release|x86.ActiveCfg = Release|Any CPU
		{E301AFEA-84E7-4BCE-8D65-A2576D8D105B}.Release|x86.Build.0 = Release|Any CPU
		{29EAD018-1C67-497A-AB8E-727D595AD756}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{29EAD018-1C67-497A-AB8E-727D595AD756}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{29EAD018-1C67-497A-AB8E-727D595AD756}.Debug|x64.ActiveCfg = Debug|Any CPU
		{29EAD018-1C67-497A-AB8E-727D595AD756}.Debug|x64.Build.0 = Debug|Any CPU
		{29EAD018-1C67-497A-AB8E-727D595AD756}.Debug|x86.ActiveCfg = Debug|Any CPU
		{29EAD018-1C67-497A-AB8E-727D595AD756}.Debug|x86.Build.0 = Debug|Any CPU
		{29EAD018-1C67-497A-AB8E-727D595AD756}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{29EAD018-1C67-497A-AB8E-727D595AD756}.Release|Any CPU.Build.0 = Release|Any CPU
		{29EAD018-1C67-497A-AB8E-727D595AD756}.Release|x64.ActiveCfg = Release|Any CPU
		{29EAD018-1C67-497A-AB8E-727D595AD756}.Release|x64.Build.0 = Release|Any CPU
		{29EAD018-1C67-497A-AB8E-727D595AD756}.Release|x86.ActiveCfg = Release|Any CPU
		{29EAD018-1C67-497A-AB8E-727D595AD756}.Release|x86.Build.0 = Release|Any CPU
		{65EAFFA3-01D3-4EF5-B092-8B4647E9A1FF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{65EAFFA3-01D3-4EF5-B092-8B4647E9A1FF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{65EAFFA3-01D3-4EF5-B092-8B4647E9A1FF}.Debug|x64.ActiveCfg = Debug|Any CPU
		{65EAFFA3-01D3-4EF5-B092-8B4647E9A1FF}.Debug|x64.Build.0 = Debug|Any CPU
		{65EAFFA3-01D3-4EF5-B092-8B4647E9A1FF}.Debug|x86.ActiveCfg = Debug|Any CPU
		{65EAFFA3-01D3-4EF5-B092-8B4647E9A1FF}.Debug|x86.Build.0 = Debug|Any CPU
		{65EAFFA3-01D3-4EF5-B092-8B4647E9A1FF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{65EAFFA3-01D3-4EF5-B092-8B4647E9A1FF}.Release|Any CPU.Build.0 = Release|Any CPU
		{65EAFFA3-01D3-4EF5-B092-8B4647E9A1FF}.Release|x64.ActiveCfg = Release|Any CPU
		{65EAFFA3-01D3-4EF5-B092-8B4647E9A1FF}.Release|x64.Build.0 = Release|Any CPU
		{65EAFFA3-01D3-4EF5-B092-8B4647E9A1FF}.Release|x86.ActiveCfg = Release|Any CPU
		{65EAFFA3-01D3-4EF5-B092-8B4647E9A1FF}.Release|x86.Build.0 = Release|Any CPU
		{6438FEC1-56B0-488C-A5E2-FBDB23E9574B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6438FEC1-56B0-488C-A5E2-FBDB23E9574B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6438FEC1-56B0-488C-A5E2-FBDB23E9574B}.Debug|x64.ActiveCfg = Debug|Any CPU
		{6438FEC1-56B0-488C-A5E2-FBDB23E9574B}.Debug|x64.Build.0 = Debug|Any CPU
		{6438FEC1-56B0-488C-A5E2-FBDB23E9574B}.Debug|x86.ActiveCfg = Debug|Any CPU
		{6438FEC1-56B0-488C-A5E2-FBDB23E9574B}.Debug|x86.Build.0 = Debug|Any CPU
		{6438FEC1-56B0-488C-A5E2-FBDB23E9574B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6438FEC1-56B0-488C-A5E2-FBDB23E9574B}.Release|Any CPU.Build.0 = Release|Any CPU
		{6438FEC1-56B0-488C-A5E2-FBDB23E9574B}.Release|x64.ActiveCfg = Release|Any CPU
		{6438FEC1-56B0-488C-A5E2-FBDB23E9574B}.Release|x64.Build.0 = Release|Any CPU
		{6438FEC1-56B0-488C-A5E2-FBDB23E9574B}.Release|x86.ActiveCfg = Release|Any CPU
		{6438FEC1-56B0-488C-A5E2-FBDB23E9574B}.Release|x86.Build.0 = Release|Any CPU
		{11EA25A3-ED68-40EE-A9D0-7FDE3B583027}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{11EA25A3-ED68-40EE-A9D0-7FDE3B583027}.Debug|Any CPU.Build.0 = Debug|Win32
		{11EA25A3-ED68-40EE-A9D0-7FDE3B583027}.Debug|x64.ActiveCfg = Debug|x64
		{11EA25A3-ED68-40EE-A9D0-7FDE3B583027}.Debug|x64.Build.0 = Debug|x64
		{11EA25A3-ED68-40EE-A9D0-7FDE3B583027}.Debug|x86.ActiveCfg = Debug|Win32
		{11EA25A3-ED68-40EE-A9D0-7FDE3B583027}.Debug|x86.Build.0 = Debug|Win32
		{11EA25A3-ED68-40EE-A9D0-7FDE3B583027}.Release|Any CPU.ActiveCfg = Release|Win32
		{11EA25A3-ED68-40EE-A9D0-7FDE3B583027}.Release|Any CPU.Build.0 = Release|Win32
		{11EA25A3-ED68-40EE-A9D0-7FDE3B583027}.Release|x64.ActiveCfg = Release|x64
		{11EA25A3-ED68-40EE-A9D0-7FDE3B583027}.Release|x64.Build.0 = Release|x64
		{11EA25A3-ED68-40EE-A9D0-7FDE3B583027}.Release|x86.ActiveCfg = Release|Win32
		{11EA25A3-ED68-40EE-A9D0-7FDE3B583027}.Release|x86.Build.0 = Release|Win32
		{29356642-C46E-4144-83D8-22DC09D0D7FD}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{29356642-C46E-4144-83D8-22DC09D0D7FD}.Debug|Any CPU.Build.0 = Debug|Win32
		{29356642-C46E-4144-83D8-22DC09D0D7FD}.Debug|x64.ActiveCfg = Debug|x64
		{29356642-C46E-4144-83D8-22DC09D0D7FD}.Debug|x64.Build.0 = Debug|x64
		{29356642-C46E-4144-83D8-22DC09D0D7FD}.Debug|x86.ActiveCfg = Debug|Win32
		{29356642-C46E-4144-83D8-22DC09D0D7FD}.Debug|x86.Build.0 = Debug|Win32
		{29356642-C46E-4144-83D8-22DC09D0D7FD}.Release|Any CPU.ActiveCfg = Release|Win32
		{29356642-C46E-4144-83D8-22DC09D0D7FD}.Release|Any CPU.Build.0 = Release|Win32
		{29356642-C46E-4144-83D8-22DC09D0D7FD}.Release|x64.ActiveCfg = Release|x64
		{29356642-C46E-4144-83D8-22DC09D0D7FD}.Release|x64.Build.0 = Release|x64
		{29356642-C46E-4144-83D8-22DC09D0D7FD}.Release|x86.ActiveCfg = Release|Win32
		{29356642-C46E-4144-83D8-22DC09D0D7FD}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {3C074481-9CDD-4780-B9F6-57BBC5092EA2}
	EndGlobalSection
EndGlobal

```

`AssetStudio/7zip/Common/CRC.cs`:

```cs
// Common/CRC.cs

namespace SevenZip
{
	public class CRC
	{
		public static readonly uint[] Table;

		static CRC()
		{
			Table = new uint[256];
			const uint kPoly = 0xEDB88320;
			for (uint i = 0; i < 256; i++)
			{
				uint r = i;
				for (int j = 0; j < 8; j++)
					if ((r & 1) != 0)
						r = (r >> 1) ^ kPoly;
					else
						r >>= 1;
				Table[i] = r;
			}
		}

		uint _value = 0xFFFFFFFF;

		public void Init() { _value = 0xFFFFFFFF; }

		public void UpdateByte(byte b)
		{
			_value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
		}

		public void Update(byte[] data, uint offset, uint size)
		{
			for (uint i = 0; i < size; i++)
				_value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
		}

		public uint GetDigest() { return _value ^ 0xFFFFFFFF; }

		static uint CalculateDigest(byte[] data, uint offset, uint size)
		{
			CRC crc = new CRC();
			// crc.Init();
			crc.Update(data, offset, size);
			return crc.GetDigest();
		}

		static bool VerifyDigest(uint digest, byte[] data, uint offset, uint size)
		{
			return (CalculateDigest(data, offset, size) == digest);
		}
	}
}

```

`AssetStudio/7zip/Common/CommandLineParser.cs`:

```cs
// CommandLineParser.cs

using System;
using System.Collections;

namespace SevenZip.CommandLineParser
{
	public enum SwitchType
	{
		Simple,
		PostMinus,
		LimitedPostString,
		UnLimitedPostString,
		PostChar
	}

	public class SwitchForm
	{
		public string IDString;
		public SwitchType Type;
		public bool Multi;
		public int MinLen;
		public int MaxLen;
		public string PostCharSet;

		public SwitchForm(string idString, SwitchType type, bool multi,
			int minLen, int maxLen, string postCharSet)
		{
			IDString = idString;
			Type = type;
			Multi = multi;
			MinLen = minLen;
			MaxLen = maxLen;
			PostCharSet = postCharSet;
		}
		public SwitchForm(string idString, SwitchType type, bool multi, int minLen):
			this(idString, type, multi, minLen, 0, "")
		{
		}
		public SwitchForm(string idString, SwitchType type, bool multi):
			this(idString, type, multi, 0)
		{
		}
	}

	public class SwitchResult
	{
		public bool ThereIs;
		public bool WithMinus;
		public ArrayList PostStrings = new ArrayList();
		public int PostCharIndex;
		public SwitchResult()
		{
			ThereIs = false;
		}
	}

	public class Parser
	{
		public ArrayList NonSwitchStrings = new ArrayList();
		SwitchResult[] _switches;

		public Parser(int numSwitches)
		{
			_switches = new SwitchResult[numSwitches];
			for (int i = 0; i < numSwitches; i++)
				_switches[i] = new SwitchResult();
		}

		bool ParseString(string srcString, SwitchForm[] switchForms)
		{
			int len = srcString.Length;
			if (len == 0)
				return false;
			int pos = 0;
			if (!IsItSwitchChar(srcString[pos]))
				return false;
			while (pos < len)
			{
				if (IsItSwitchChar(srcString[pos]))
					pos++;
				const int kNoLen = -1;
				int matchedSwitchIndex = 0;
				int maxLen = kNoLen;
				for (int switchIndex = 0; switchIndex < _switches.Length; switchIndex++)
				{
					int switchLen = switchForms[switchIndex].IDString.Length;
					if (switchLen <= maxLen || pos + switchLen > len)
						continue;
					if (String.Compare(switchForms[switchIndex].IDString, 0,
							srcString, pos, switchLen, true) == 0)
					{
						matchedSwitchIndex = switchIndex;
						maxLen = switchLen;
					}
				}
				if (maxLen == kNoLen)
					throw new Exception("maxLen == kNoLen");
				SwitchResult matchedSwitch = _switches[matchedSwitchIndex];
				SwitchForm switchForm = switchForms[matchedSwitchIndex];
				if ((!switchForm.Multi) && matchedSwitch.ThereIs)
					throw new Exception("switch must be single");
				matchedSwitch.ThereIs = true;
				pos += maxLen;
				int tailSize = len - pos;
				SwitchType type = switchForm.Type;
				switch (type)
				{
					case SwitchType.PostMinus:
						{
							if (tailSize == 0)
								matchedSwitch.WithMinus = false;
							else
							{
								matchedSwitch.WithMinus = (srcString[pos] == kSwitchMinus);
								if (matchedSwitch.WithMinus)
									pos++;
							}
							break;
						}
					case SwitchType.PostChar:
						{
							if (tailSize < switchForm.MinLen)
								throw new Exception("switch is not full");
							string charSet = switchForm.PostCharSet;
							const int kEmptyCharValue = -1;
							if (tailSize == 0)
								matchedSwitch.PostCharIndex = kEmptyCharValue;
							else
							{
								int index = charSet.IndexOf(srcString[pos]);
								if (index < 0)
									matchedSwitch.PostCharIndex = kEmptyCharValue;
								else
								{
									matchedSwitch.PostCharIndex = index;
									pos++;
								}
							}
							break;
						}
					case SwitchType.LimitedPostString:
					case SwitchType.UnLimitedPostString:
						{
							int minLen = switchForm.MinLen;
							if (tailSize < minLen)
								throw new Exception("switch is not full");
							if (type == SwitchType.UnLimitedPostString)
							{
								matchedSwitch.PostStrings.Add(srcString.Substring(pos));
								return true;
							}
							String stringSwitch = srcString.Substring(pos, minLen);
							pos += minLen;
							for (int i = minLen; i < switchForm.MaxLen && pos < len; i++, pos++)
							{
								char c = srcString[pos];
								if (IsItSwitchChar(c))
									break;
								stringSwitch += c;
							}
							matchedSwitch.PostStrings.Add(stringSwitch);
							break;
						}
				}
			}
			return true;

		}

		public void ParseStrings(SwitchForm[] switchForms, string[] commandStrings)
		{
			int numCommandStrings = commandStrings.Length;
			bool stopSwitch = false;
			for (int i = 0; i < numCommandStrings; i++)
			{
				string s = commandStrings[i];
				if (stopSwitch)
					NonSwitchStrings.Add(s);
				else
					if (s == kStopSwitchParsing)
					stopSwitch = true;
				else
					if (!ParseString(s, switchForms))
					NonSwitchStrings.Add(s);
			}
		}

		public SwitchResult this[int index] { get { return _switches[index]; } }

		public static int ParseCommand(CommandForm[] commandForms, string commandString,
			out string postString)
		{
			for (int i = 0; i < commandForms.Length; i++)
			{
				string id = commandForms[i].IDString;
				if (commandForms[i].PostStringMode)
				{
					if (commandString.IndexOf(id) == 0)
					{
						postString = commandString.Substring(id.Length);
						return i;
					}
				}
				else
					if (commandString == id)
				{
					postString = "";
					return i;
				}
			}
			postString = "";
			return -1;
		}

		static bool ParseSubCharsCommand(int numForms, CommandSubCharsSet[] forms,
			string commandString, ArrayList indices)
		{
			indices.Clear();
			int numUsedChars = 0;
			for (int i = 0; i < numForms; i++)
			{
				CommandSubCharsSet charsSet = forms[i];
				int currentIndex = -1;
				int len = charsSet.Chars.Length;
				for (int j = 0; j < len; j++)
				{
					char c = charsSet.Chars[j];
					int newIndex = commandString.IndexOf(c);
					if (newIndex >= 0)
					{
						if (currentIndex >= 0)
							return false;
						if (commandString.IndexOf(c, newIndex + 1) >= 0)
							return false;
						currentIndex = j;
						numUsedChars++;
					}
				}
				if (currentIndex == -1 && !charsSet.EmptyAllowed)
					return false;
				indices.Add(currentIndex);
			}
			return (numUsedChars == commandString.Length);
		}
		const char kSwitchID1 = '-';
		const char kSwitchID2 = '/';

		const char kSwitchMinus = '-';
		const string kStopSwitchParsing = "--";

		static bool IsItSwitchChar(char c)
		{
			return (c == kSwitchID1 || c == kSwitchID2);
		}
	}

	public class CommandForm
	{
		public string IDString = "";
		public bool PostStringMode = false;
		public CommandForm(string idString, bool postStringMode)
		{
			IDString = idString;
			PostStringMode = postStringMode;
		}
	}

	class CommandSubCharsSet
	{
		public string Chars = "";
		public bool EmptyAllowed = false;
	}
}

```

`AssetStudio/7zip/Common/InBuffer.cs`:

```cs
// InBuffer.cs

namespace SevenZip.Buffer
{
	public class InBuffer
	{
		byte[] m_Buffer;
		uint m_Pos;
		uint m_Limit;
		uint m_BufferSize;
		System.IO.Stream m_Stream;
		bool m_StreamWasExhausted;
		ulong m_ProcessedSize;

		public InBuffer(uint bufferSize)
		{
			m_Buffer = new byte[bufferSize];
			m_BufferSize = bufferSize;
		}

		public void Init(System.IO.Stream stream)
		{
			m_Stream = stream;
			m_ProcessedSize = 0;
			m_Limit = 0;
			m_Pos = 0;
			m_StreamWasExhausted = false;
		}

		public bool ReadBlock()
		{
			if (m_StreamWasExhausted)
				return false;
			m_ProcessedSize += m_Pos;
			int aNumProcessedBytes = m_Stream.Read(m_Buffer, 0, (int)m_BufferSize);
			m_Pos = 0;
			m_Limit = (uint)aNumProcessedBytes;
			m_StreamWasExhausted = (aNumProcessedBytes == 0);
			return (!m_StreamWasExhausted);
		}


		public void ReleaseStream()
		{
			// m_Stream.Close(); 
			m_Stream = null;
		}

		public bool ReadByte(byte b) // check it
		{
			if (m_Pos >= m_Limit)
				if (!ReadBlock())
					return false;
			b = m_Buffer[m_Pos++];
			return true;
		}

		public byte ReadByte()
		{
			// return (byte)m_Stream.ReadByte();
			if (m_Pos >= m_Limit)
				if (!ReadBlock())
					return 0xFF;
			return m_Buffer[m_Pos++];
		}

		public ulong GetProcessedSize()
		{
			return m_ProcessedSize + m_Pos;
		}
	}
}

```

`AssetStudio/7zip/Common/OutBuffer.cs`:

```cs
// OutBuffer.cs

namespace SevenZip.Buffer
{
	public class OutBuffer
	{
		byte[] m_Buffer;
		uint m_Pos;
		uint m_BufferSize;
		System.IO.Stream m_Stream;
		ulong m_ProcessedSize;

		public OutBuffer(uint bufferSize)
		{
			m_Buffer = new byte[bufferSize];
			m_BufferSize = bufferSize;
		}

		public void SetStream(System.IO.Stream stream) { m_Stream = stream; }
		public void FlushStream() { m_Stream.Flush(); }
		public void CloseStream() { m_Stream.Close(); }
		public void ReleaseStream() { m_Stream = null; }

		public void Init()
		{
			m_ProcessedSize = 0;
			m_Pos = 0;
		}

		public void WriteByte(byte b)
		{
			m_Buffer[m_Pos++] = b;
			if (m_Pos >= m_BufferSize)
				FlushData();
		}

		public void FlushData()
		{
			if (m_Pos == 0)
				return;
			m_Stream.Write(m_Buffer, 0, (int)m_Pos);
			m_Pos = 0;
		}

		public ulong GetProcessedSize() { return m_ProcessedSize + m_Pos; }
	}
}

```

`AssetStudio/7zip/Compress/LZ/IMatchFinder.cs`:

```cs
// IMatchFinder.cs

using System;

namespace SevenZip.Compression.LZ
{
	interface IInWindowStream
	{
		void SetStream(System.IO.Stream inStream);
		void Init();
		void ReleaseStream();
		Byte GetIndexByte(Int32 index);
		UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit);
		UInt32 GetNumAvailableBytes();
	}

	interface IMatchFinder : IInWindowStream
	{
		void Create(UInt32 historySize, UInt32 keepAddBufferBefore,
				UInt32 matchMaxLen, UInt32 keepAddBufferAfter);
		UInt32 GetMatches(UInt32[] distances);
		void Skip(UInt32 num);
	}
}

```

`AssetStudio/7zip/Compress/LZ/LzBinTree.cs`:

```cs
// LzBinTree.cs

using System;

namespace SevenZip.Compression.LZ
{
	public class BinTree : InWindow, IMatchFinder
	{
		UInt32 _cyclicBufferPos;
		UInt32 _cyclicBufferSize = 0;
		UInt32 _matchMaxLen;

		UInt32[] _son;
		UInt32[] _hash;

		UInt32 _cutValue = 0xFF;
		UInt32 _hashMask;
		UInt32 _hashSizeSum = 0;

		bool HASH_ARRAY = true;

		const UInt32 kHash2Size = 1 << 10;
		const UInt32 kHash3Size = 1 << 16;
		const UInt32 kBT2HashSize = 1 << 16;
		const UInt32 kStartMaxLen = 1;
		const UInt32 kHash3Offset = kHash2Size;
		const UInt32 kEmptyHashValue = 0;
		const UInt32 kMaxValForNormalize = ((UInt32)1 << 31) - 1;
	
		UInt32 kNumHashDirectBytes = 0;
		UInt32 kMinMatchCheck = 4;
		UInt32 kFixHashSize = kHash2Size + kHash3Size;
		
		public void SetType(int numHashBytes)
		{
			HASH_ARRAY = (numHashBytes > 2);
			if (HASH_ARRAY)
			{
				kNumHashDirectBytes = 0;
				kMinMatchCheck = 4;
				kFixHashSize = kHash2Size + kHash3Size;
			}
			else
			{
				kNumHashDirectBytes = 2;
				kMinMatchCheck = 2 + 1;
				kFixHashSize = 0;
			}
		}

		public new void SetStream(System.IO.Stream stream) { base.SetStream(stream); }
		public new void ReleaseStream() { base.ReleaseStream(); }
		
		public new void Init()
		{
			base.Init();
			for (UInt32 i = 0; i < _hashSizeSum; i++)
				_hash[i] = kEmptyHashValue;
			_cyclicBufferPos = 0;
			ReduceOffsets(-1);
		}

		public new void MovePos()
		{
			if (++_cyclicBufferPos >= _cyclicBufferSize)
				_cyclicBufferPos = 0;
			base.MovePos();
			if (_pos == kMaxValForNormalize)
				Normalize();
		}

		public new Byte GetIndexByte(Int32 index) { return base.GetIndexByte(index); }

		public new UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit)
		{ return base.GetMatchLen(index, distance, limit); }

		public new UInt32 GetNumAvailableBytes() { return base.GetNumAvailableBytes(); }

		public void Create(UInt32 historySize, UInt32 keepAddBufferBefore,
				UInt32 matchMaxLen, UInt32 keepAddBufferAfter)
		{
			if (historySize > kMaxValForNormalize - 256)
				throw new Exception();
			_cutValue = 16 + (matchMaxLen >> 1);
				
			UInt32 windowReservSize = (historySize + keepAddBufferBefore +
					matchMaxLen + keepAddBufferAfter) / 2 + 256;

			base.Create(historySize + keepAddBufferBefore, matchMaxLen + keepAddBufferAfter, windowReservSize);

			_matchMaxLen = matchMaxLen;

			UInt32 cyclicBufferSize = historySize + 1;
			if (_cyclicBufferSize != cyclicBufferSize)
				_son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];

			UInt32 hs = kBT2HashSize;

			if (HASH_ARRAY)
			{
				hs = historySize - 1;
				hs |= (hs >> 1);
				hs |= (hs >> 2);
				hs |= (hs >> 4);
				hs |= (hs >> 8);
				hs >>= 1;
				hs |= 0xFFFF;
				if (hs > (1 << 24))
					hs >>= 1;
				_hashMask = hs;
				hs++;
				hs += kFixHashSize;
			}
			if (hs != _hashSizeSum)
				_hash = new UInt32[_hashSizeSum = hs];
		}

		public UInt32 GetMatches(UInt32[] distances)
		{
			UInt32 lenLimit;
			if (_pos + _matchMaxLen <= _streamPos)
				lenLimit = _matchMaxLen;
			else
			{
				lenLimit = _streamPos - _pos;
				if (lenLimit < kMinMatchCheck)
				{
					MovePos();
					return 0;
				}
			}

			UInt32 offset = 0;
			UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
			UInt32 cur = _bufferOffset + _pos;
			UInt32 maxLen = kStartMaxLen; // to avoid items for len < hashSize;
			UInt32 hashValue, hash2Value = 0, hash3Value = 0;

			if (HASH_ARRAY)
			{
				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];
				hash2Value = temp & (kHash2Size - 1);
				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
				hash3Value = temp & (kHash3Size - 1);
				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
			}
			else
				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);

			UInt32 curMatch = _hash[kFixHashSize + hashValue];
			if (HASH_ARRAY)
			{
				UInt32 curMatch2 = _hash[hash2Value];
				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];
				_hash[hash2Value] = _pos;
				_hash[kHash3Offset + hash3Value] = _pos;
				if (curMatch2 > matchMinPos)
					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])
					{
						distances[offset++] = maxLen = 2;
						distances[offset++] = _pos - curMatch2 - 1;
					}
				if (curMatch3 > matchMinPos)
					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])
					{
						if (curMatch3 == curMatch2)
							offset -= 2;
						distances[offset++] = maxLen = 3;
						distances[offset++] = _pos - curMatch3 - 1;
						curMatch2 = curMatch3;
					}
				if (offset != 0 && curMatch2 == curMatch)
				{
					offset -= 2;
					maxLen = kStartMaxLen;
				}
			}

			_hash[kFixHashSize + hashValue] = _pos;

			UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;
			UInt32 ptr1 = (_cyclicBufferPos << 1);

			UInt32 len0, len1;
			len0 = len1 = kNumHashDirectBytes;
			
			if (kNumHashDirectBytes != 0)
			{
				if (curMatch > matchMinPos)
				{
					if (_bufferBase[_bufferOffset + curMatch + kNumHashDirectBytes] !=
							_bufferBase[cur + kNumHashDirectBytes])
					{
						distances[offset++] = maxLen = kNumHashDirectBytes;
						distances[offset++] = _pos - curMatch - 1;
					}
				}
			}
			
			UInt32 count = _cutValue;
			
			while(true)
			{
				if(curMatch <= matchMinPos || count-- == 0)
				{
					_son[ptr0] = _son[ptr1] = kEmptyHashValue;
					break;
				}
				UInt32 delta = _pos - curMatch;
				UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?
							(_cyclicBufferPos - delta) :
							(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;

				UInt32 pby1 = _bufferOffset + curMatch;
				UInt32 len = Math.Min(len0, len1);
				if (_bufferBase[pby1 + len] == _bufferBase[cur + len])
				{
					while(++len != lenLimit)
						if (_bufferBase[pby1 + len] != _bufferBase[cur + len])
							break;
					if (maxLen < len)
					{
						distances[offset++] = maxLen = len;
						distances[offset++] = delta - 1;
						if (len == lenLimit)
						{
							_son[ptr1] = _son[cyclicPos];
							_son[ptr0] = _son[cyclicPos + 1];
							break;
						}
					}
				}
				if (_bufferBase[pby1 + len] < _bufferBase[cur + len])
				{
					_son[ptr1] = curMatch;
					ptr1 = cyclicPos + 1;
					curMatch = _son[ptr1];
					len1 = len;
				}
				else
				{
					_son[ptr0] = curMatch;
					ptr0 = cyclicPos;
					curMatch = _son[ptr0];
					len0 = len;
				}
			}
			MovePos();
			return offset;
		}

		public void Skip(UInt32 num)
		{
			do
			{
				UInt32 lenLimit;
				if (_pos + _matchMaxLen <= _streamPos)
					lenLimit = _matchMaxLen;
				else
				{
					lenLimit = _streamPos - _pos;
					if (lenLimit < kMinMatchCheck)
					{
						MovePos();
						continue;
					}
				}

				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
				UInt32 cur = _bufferOffset + _pos;

				UInt32 hashValue;

				if (HASH_ARRAY)
				{
					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];
					UInt32 hash2Value = temp & (kHash2Size - 1);
					_hash[hash2Value] = _pos;
					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
					UInt32 hash3Value = temp & (kHash3Size - 1);
					_hash[kHash3Offset + hash3Value] = _pos;
					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
				}
				else
					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);

				UInt32 curMatch = _hash[kFixHashSize + hashValue];
				_hash[kFixHashSize + hashValue] = _pos;

				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;
				UInt32 ptr1 = (_cyclicBufferPos << 1);

				UInt32 len0, len1;
				len0 = len1 = kNumHashDirectBytes;

				UInt32 count = _cutValue;
				while (true)
				{
					if (curMatch <= matchMinPos || count-- == 0)
					{
						_son[ptr0] = _son[ptr1] = kEmptyHashValue;
						break;
					}

					UInt32 delta = _pos - curMatch;
					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?
								(_cyclicBufferPos - delta) :
								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;

					UInt32 pby1 = _bufferOffset + curMatch;
					UInt32 len = Math.Min(len0, len1);
					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])
					{
						while (++len != lenLimit)
							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])
								break;
						if (len == lenLimit)
						{
							_son[ptr1] = _son[cyclicPos];
							_son[ptr0] = _son[cyclicPos + 1];
							break;
						}
					}
					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])
					{
						_son[ptr1] = curMatch;
						ptr1 = cyclicPos + 1;
						curMatch = _son[ptr1];
						len1 = len;
					}
					else
					{
						_son[ptr0] = curMatch;
						ptr0 = cyclicPos;
						curMatch = _son[ptr0];
						len0 = len;
					}
				}
				MovePos();
			}
			while (--num != 0);
		}

		void NormalizeLinks(UInt32[] items, UInt32 numItems, UInt32 subValue)
		{
			for (UInt32 i = 0; i < numItems; i++)
			{
				UInt32 value = items[i];
				if (value <= subValue)
					value = kEmptyHashValue;
				else
					value -= subValue;
				items[i] = value;
			}
		}

		void Normalize()
		{
			UInt32 subValue = _pos - _cyclicBufferSize;
			NormalizeLinks(_son, _cyclicBufferSize * 2, subValue);
			NormalizeLinks(_hash, _hashSizeSum, subValue);
			ReduceOffsets((Int32)subValue);
		}

		public void SetCutValue(UInt32 cutValue) { _cutValue = cutValue; }
	}
}

```

`AssetStudio/7zip/Compress/LZ/LzInWindow.cs`:

```cs
// LzInWindow.cs

using System;

namespace SevenZip.Compression.LZ
{
	public class InWindow
	{
		public Byte[] _bufferBase = null; // pointer to buffer with data
		System.IO.Stream _stream;
		UInt32 _posLimit; // offset (from _buffer) of first byte when new block reading must be done
		bool _streamEndWasReached; // if (true) then _streamPos shows real end of stream

		UInt32 _pointerToLastSafePosition;

		public UInt32 _bufferOffset;

		public UInt32 _blockSize; // Size of Allocated memory block
		public UInt32 _pos; // offset (from _buffer) of curent byte
		UInt32 _keepSizeBefore; // how many BYTEs must be kept in buffer before _pos
		UInt32 _keepSizeAfter; // how many BYTEs must be kept buffer after _pos
		public UInt32 _streamPos; // offset (from _buffer) of first not read byte from Stream

		public void MoveBlock()
		{
			UInt32 offset = (UInt32)(_bufferOffset) + _pos - _keepSizeBefore;
			// we need one additional byte, since MovePos moves on 1 byte.
			if (offset > 0)
				offset--;
			
			UInt32 numBytes = (UInt32)(_bufferOffset) + _streamPos - offset;

			// check negative offset ????
			for (UInt32 i = 0; i < numBytes; i++)
				_bufferBase[i] = _bufferBase[offset + i];
			_bufferOffset -= offset;
		}

		public virtual void ReadBlock()
		{
			if (_streamEndWasReached)
				return;
			while (true)
			{
				int size = (int)((0 - _bufferOffset) + _blockSize - _streamPos);
				if (size == 0)
					return;
				int numReadBytes = _stream.Read(_bufferBase, (int)(_bufferOffset + _streamPos), size);
				if (numReadBytes == 0)
				{
					_posLimit = _streamPos;
					UInt32 pointerToPostion = _bufferOffset + _posLimit;
					if (pointerToPostion > _pointerToLastSafePosition)
						_posLimit = (UInt32)(_pointerToLastSafePosition - _bufferOffset);

					_streamEndWasReached = true;
					return;
				}
				_streamPos += (UInt32)numReadBytes;
				if (_streamPos >= _pos + _keepSizeAfter)
					_posLimit = _streamPos - _keepSizeAfter;
			}
		}

		void Free() { _bufferBase = null; }

		public void Create(UInt32 keepSizeBefore, UInt32 keepSizeAfter, UInt32 keepSizeReserv)
		{
			_keepSizeBefore = keepSizeBefore;
			_keepSizeAfter = keepSizeAfter;
			UInt32 blockSize = keepSizeBefore + keepSizeAfter + keepSizeReserv;
			if (_bufferBase == null || _blockSize != blockSize)
			{
				Free();
				_blockSize = blockSize;
				_bufferBase = new Byte[_blockSize];
			}
			_pointerToLastSafePosition = _blockSize - keepSizeAfter;
		}

		public void SetStream(System.IO.Stream stream) { _stream = stream; }
		public void ReleaseStream() { _stream = null; }

		public void Init()
		{
			_bufferOffset = 0;
			_pos = 0;
			_streamPos = 0;
			_streamEndWasReached = false;
			ReadBlock();
		}

		public void MovePos()
		{
			_pos++;
			if (_pos > _posLimit)
			{
				UInt32 pointerToPostion = _bufferOffset + _pos;
				if (pointerToPostion > _pointerToLastSafePosition)
					MoveBlock();
				ReadBlock();
			}
		}

		public Byte GetIndexByte(Int32 index) { return _bufferBase[_bufferOffset + _pos + index]; }

		// index + limit have not to exceed _keepSizeAfter;
		public UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit)
		{
			if (_streamEndWasReached)
				if ((_pos + index) + limit > _streamPos)
					limit = _streamPos - (UInt32)(_pos + index);
			distance++;
			// Byte *pby = _buffer + (size_t)_pos + index;
			UInt32 pby = _bufferOffset + _pos + (UInt32)index;

			UInt32 i;
			for (i = 0; i < limit && _bufferBase[pby + i] == _bufferBase[pby + i - distance]; i++);
			return i;
		}

		public UInt32 GetNumAvailableBytes() { return _streamPos - _pos; }

		public void ReduceOffsets(Int32 subValue)
		{
			_bufferOffset += (UInt32)subValue;
			_posLimit -= (UInt32)subValue;
			_pos -= (UInt32)subValue;
			_streamPos -= (UInt32)subValue;
		}
	}
}

```

`AssetStudio/7zip/Compress/LZ/LzOutWindow.cs`:

```cs
// LzOutWindow.cs

namespace SevenZip.Compression.LZ
{
	public class OutWindow
	{
		byte[] _buffer = null;
		uint _pos;
		uint _windowSize = 0;
		uint _streamPos;
		System.IO.Stream _stream;

		public uint TrainSize = 0;

		public void Create(uint windowSize)
		{
			if (_windowSize != windowSize)
			{
				// System.GC.Collect();
				_buffer = new byte[windowSize];
			}
			_windowSize = windowSize;
			_pos = 0;
			_streamPos = 0;
		}

		public void Init(System.IO.Stream stream, bool solid)
		{
			ReleaseStream();
			_stream = stream;
			if (!solid)
			{
				_streamPos = 0;
				_pos = 0;
				TrainSize = 0;
			}
		}
	
		public bool Train(System.IO.Stream stream)
		{
			long len = stream.Length;
			uint size = (len < _windowSize) ? (uint)len : _windowSize;
			TrainSize = size;
			stream.Position = len - size;
			_streamPos = _pos = 0;
			while (size > 0)
			{
				uint curSize = _windowSize - _pos;
				if (size < curSize)
					curSize = size;
				int numReadBytes = stream.Read(_buffer, (int)_pos, (int)curSize);
				if (numReadBytes == 0)
					return false;
				size -= (uint)numReadBytes;
				_pos += (uint)numReadBytes;
				_streamPos += (uint)numReadBytes;
				if (_pos == _windowSize)
					_streamPos = _pos = 0;
			}
			return true;
		}

		public void ReleaseStream()
		{
			Flush();
			_stream = null;
		}

		public void Flush()
		{
			uint size = _pos - _streamPos;
			if (size == 0)
				return;
			_stream.Write(_buffer, (int)_streamPos, (int)size);
			if (_pos >= _windowSize)
				_pos = 0;
			_streamPos = _pos;
		}

		public void CopyBlock(uint distance, uint len)
		{
			uint pos = _pos - distance - 1;
			if (pos >= _windowSize)
				pos += _windowSize;
			for (; len > 0; len--)
			{
				if (pos >= _windowSize)
					pos = 0;
				_buffer[_pos++] = _buffer[pos++];
				if (_pos >= _windowSize)
					Flush();
			}
		}

		public void PutByte(byte b)
		{
			_buffer[_pos++] = b;
			if (_pos >= _windowSize)
				Flush();
		}

		public byte GetByte(uint distance)
		{
			uint pos = _pos - distance - 1;
			if (pos >= _windowSize)
				pos += _windowSize;
			return _buffer[pos];
		}
	}
}

```

`AssetStudio/7zip/Compress/LZMA/LzmaBase.cs`:

```cs
// LzmaBase.cs

namespace SevenZip.Compression.LZMA
{
	internal abstract class Base
	{
		public const uint kNumRepDistances = 4;
		public const uint kNumStates = 12;

		// static byte []kLiteralNextStates  = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
		// static byte []kMatchNextStates    = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
		// static byte []kRepNextStates      = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
		// static byte []kShortRepNextStates = {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};

		public struct State
		{
			public uint Index;
			public void Init() { Index = 0; }
			public void UpdateChar()
			{
				if (Index < 4) Index = 0;
				else if (Index < 10) Index -= 3;
				else Index -= 6;
			}
			public void UpdateMatch() { Index = (uint)(Index < 7 ? 7 : 10); }
			public void UpdateRep() { Index = (uint)(Index < 7 ? 8 : 11); }
			public void UpdateShortRep() { Index = (uint)(Index < 7 ? 9 : 11); }
			public bool IsCharState() { return Index < 7; }
		}

		public const int kNumPosSlotBits = 6;
		public const int kDicLogSizeMin = 0;
		// public const int kDicLogSizeMax = 30;
		// public const uint kDistTableSizeMax = kDicLogSizeMax * 2;

		public const int kNumLenToPosStatesBits = 2; // it's for speed optimization
		public const uint kNumLenToPosStates = 1 << kNumLenToPosStatesBits;

		public const uint kMatchMinLen = 2;

		public static uint GetLenToPosState(uint len)
		{
			len -= kMatchMinLen;
			if (len < kNumLenToPosStates)
				return len;
			return (uint)(kNumLenToPosStates - 1);
		}

		public const int kNumAlignBits = 4;
		public const uint kAlignTableSize = 1 << kNumAlignBits;
		public const uint kAlignMask = (kAlignTableSize - 1);

		public const uint kStartPosModelIndex = 4;
		public const uint kEndPosModelIndex = 14;
		public const uint kNumPosModels = kEndPosModelIndex - kStartPosModelIndex;

		public const uint kNumFullDistances = 1 << ((int)kEndPosModelIndex / 2);

		public const uint kNumLitPosStatesBitsEncodingMax = 4;
		public const uint kNumLitContextBitsMax = 8;

		public const int kNumPosStatesBitsMax = 4;
		public const uint kNumPosStatesMax = (1 << kNumPosStatesBitsMax);
		public const int kNumPosStatesBitsEncodingMax = 4;
		public const uint kNumPosStatesEncodingMax = (1 << kNumPosStatesBitsEncodingMax);

		public const int kNumLowLenBits = 3;
		public const int kNumMidLenBits = 3;
		public const int kNumHighLenBits = 8;
		public const uint kNumLowLenSymbols = 1 << kNumLowLenBits;
		public const uint kNumMidLenSymbols = 1 << kNumMidLenBits;
		public const uint kNumLenSymbols = kNumLowLenSymbols + kNumMidLenSymbols +
				(1 << kNumHighLenBits);
		public const uint kMatchMaxLen = kMatchMinLen + kNumLenSymbols - 1;
	}
}

```

`AssetStudio/7zip/Compress/LZMA/LzmaDecoder.cs`:

```cs
// LzmaDecoder.cs

using System;

namespace SevenZip.Compression.LZMA
{
	using RangeCoder;

	public class Decoder : ICoder, ISetDecoderProperties // ,System.IO.Stream
	{
		class LenDecoder
		{
			BitDecoder m_Choice = new BitDecoder();
			BitDecoder m_Choice2 = new BitDecoder();
			BitTreeDecoder[] m_LowCoder = new BitTreeDecoder[Base.kNumPosStatesMax];
			BitTreeDecoder[] m_MidCoder = new BitTreeDecoder[Base.kNumPosStatesMax];
			BitTreeDecoder m_HighCoder = new BitTreeDecoder(Base.kNumHighLenBits);
			uint m_NumPosStates = 0;

			public void Create(uint numPosStates)
			{
				for (uint posState = m_NumPosStates; posState < numPosStates; posState++)
				{
					m_LowCoder[posState] = new BitTreeDecoder(Base.kNumLowLenBits);
					m_MidCoder[posState] = new BitTreeDecoder(Base.kNumMidLenBits);
				}
				m_NumPosStates = numPosStates;
			}

			public void Init()
			{
				m_Choice.Init();
				for (uint posState = 0; posState < m_NumPosStates; posState++)
				{
					m_LowCoder[posState].Init();
					m_MidCoder[posState].Init();
				}
				m_Choice2.Init();
				m_HighCoder.Init();
			}

			public uint Decode(RangeCoder.Decoder rangeDecoder, uint posState)
			{
				if (m_Choice.Decode(rangeDecoder) == 0)
					return m_LowCoder[posState].Decode(rangeDecoder);
				else
				{
					uint symbol = Base.kNumLowLenSymbols;
					if (m_Choice2.Decode(rangeDecoder) == 0)
						symbol += m_MidCoder[posState].Decode(rangeDecoder);
					else
					{
						symbol += Base.kNumMidLenSymbols;
						symbol += m_HighCoder.Decode(rangeDecoder);
					}
					return symbol;
				}
			}
		}

		class LiteralDecoder
		{
			struct Decoder2
			{
				BitDecoder[] m_Decoders;
				public void Create() { m_Decoders = new BitDecoder[0x300]; }
				public void Init() { for (int i = 0; i < 0x300; i++) m_Decoders[i].Init(); }

				public byte DecodeNormal(RangeCoder.Decoder rangeDecoder)
				{
					uint symbol = 1;
					do
						symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);
					while (symbol < 0x100);
					return (byte)symbol;
				}

				public byte DecodeWithMatchByte(RangeCoder.Decoder rangeDecoder, byte matchByte)
				{
					uint symbol = 1;
					do
					{
						uint matchBit = (uint)(matchByte >> 7) & 1;
						matchByte <<= 1;
						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);
						symbol = (symbol << 1) | bit;
						if (matchBit != bit)
						{
							while (symbol < 0x100)
								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);
							break;
						}
					}
					while (symbol < 0x100);
					return (byte)symbol;
				}
			}

			Decoder2[] m_Coders;
			int m_NumPrevBits;
			int m_NumPosBits;
			uint m_PosMask;

			public void Create(int numPosBits, int numPrevBits)
			{
				if (m_Coders != null && m_NumPrevBits == numPrevBits &&
					m_NumPosBits == numPosBits)
					return;
				m_NumPosBits = numPosBits;
				m_PosMask = ((uint)1 << numPosBits) - 1;
				m_NumPrevBits = numPrevBits;
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				m_Coders = new Decoder2[numStates];
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Create();
			}

			public void Init()
			{
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Init();
			}

			uint GetState(uint pos, byte prevByte)
			{ return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits)); }

			public byte DecodeNormal(RangeCoder.Decoder rangeDecoder, uint pos, byte prevByte)
			{ return m_Coders[GetState(pos, prevByte)].DecodeNormal(rangeDecoder); }

			public byte DecodeWithMatchByte(RangeCoder.Decoder rangeDecoder, uint pos, byte prevByte, byte matchByte)
			{ return m_Coders[GetState(pos, prevByte)].DecodeWithMatchByte(rangeDecoder, matchByte); }
		};

		LZ.OutWindow m_OutWindow = new LZ.OutWindow();
		RangeCoder.Decoder m_RangeDecoder = new RangeCoder.Decoder();

		BitDecoder[] m_IsMatchDecoders = new BitDecoder[Base.kNumStates << Base.kNumPosStatesBitsMax];
		BitDecoder[] m_IsRepDecoders = new BitDecoder[Base.kNumStates];
		BitDecoder[] m_IsRepG0Decoders = new BitDecoder[Base.kNumStates];
		BitDecoder[] m_IsRepG1Decoders = new BitDecoder[Base.kNumStates];
		BitDecoder[] m_IsRepG2Decoders = new BitDecoder[Base.kNumStates];
		BitDecoder[] m_IsRep0LongDecoders = new BitDecoder[Base.kNumStates << Base.kNumPosStatesBitsMax];

		BitTreeDecoder[] m_PosSlotDecoder = new BitTreeDecoder[Base.kNumLenToPosStates];
		BitDecoder[] m_PosDecoders = new BitDecoder[Base.kNumFullDistances - Base.kEndPosModelIndex];

		BitTreeDecoder m_PosAlignDecoder = new BitTreeDecoder(Base.kNumAlignBits);

		LenDecoder m_LenDecoder = new LenDecoder();
		LenDecoder m_RepLenDecoder = new LenDecoder();

		LiteralDecoder m_LiteralDecoder = new LiteralDecoder();

		uint m_DictionarySize;
		uint m_DictionarySizeCheck;

		uint m_PosStateMask;

		public Decoder()
		{
			m_DictionarySize = 0xFFFFFFFF;
			for (int i = 0; i < Base.kNumLenToPosStates; i++)
				m_PosSlotDecoder[i] = new BitTreeDecoder(Base.kNumPosSlotBits);
		}

		void SetDictionarySize(uint dictionarySize)
		{
			if (m_DictionarySize != dictionarySize)
			{
				m_DictionarySize = dictionarySize;
				m_DictionarySizeCheck = Math.Max(m_DictionarySize, 1);
				uint blockSize = Math.Max(m_DictionarySizeCheck, (1 << 12));
				m_OutWindow.Create(blockSize);
			}
		}

		void SetLiteralProperties(int lp, int lc)
		{
			if (lp > 8)
				throw new InvalidParamException();
			if (lc > 8)
				throw new InvalidParamException();
			m_LiteralDecoder.Create(lp, lc);
		}

		void SetPosBitsProperties(int pb)
		{
			if (pb > Base.kNumPosStatesBitsMax)
				throw new InvalidParamException();
			uint numPosStates = (uint)1 << pb;
			m_LenDecoder.Create(numPosStates);
			m_RepLenDecoder.Create(numPosStates);
			m_PosStateMask = numPosStates - 1;
		}

		bool _solid = false;
		void Init(System.IO.Stream inStream, System.IO.Stream outStream)
		{
			m_RangeDecoder.Init(inStream);
			m_OutWindow.Init(outStream, _solid);

			uint i;
			for (i = 0; i < Base.kNumStates; i++)
			{
				for (uint j = 0; j <= m_PosStateMask; j++)
				{
					uint index = (i << Base.kNumPosStatesBitsMax) + j;
					m_IsMatchDecoders[index].Init();
					m_IsRep0LongDecoders[index].Init();
				}
				m_IsRepDecoders[i].Init();
				m_IsRepG0Decoders[i].Init();
				m_IsRepG1Decoders[i].Init();
				m_IsRepG2Decoders[i].Init();
			}

			m_LiteralDecoder.Init();
			for (i = 0; i < Base.kNumLenToPosStates; i++)
				m_PosSlotDecoder[i].Init();
			// m_PosSpecDecoder.Init();
			for (i = 0; i < Base.kNumFullDistances - Base.kEndPosModelIndex; i++)
				m_PosDecoders[i].Init();

			m_LenDecoder.Init();
			m_RepLenDecoder.Init();
			m_PosAlignDecoder.Init();
		}

		public void Code(System.IO.Stream inStream, System.IO.Stream outStream,
			Int64 inSize, Int64 outSize, ICodeProgress progress)
		{
			Init(inStream, outStream);

			Base.State state = new Base.State();
			state.Init();
			uint rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0;

			UInt64 nowPos64 = 0;
			UInt64 outSize64 = (UInt64)outSize;
			if (nowPos64 < outSize64)
			{
				if (m_IsMatchDecoders[state.Index << Base.kNumPosStatesBitsMax].Decode(m_RangeDecoder) != 0)
					throw new DataErrorException();
				state.UpdateChar();
				byte b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, 0, 0);
				m_OutWindow.PutByte(b);
				nowPos64++;
			}
			while (nowPos64 < outSize64)
			{
				// UInt64 next = Math.Min(nowPos64 + (1 << 18), outSize64);
					// while(nowPos64 < next)
				{
					uint posState = (uint)nowPos64 & m_PosStateMask;
					if (m_IsMatchDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)
					{
						byte b;
						byte prevByte = m_OutWindow.GetByte(0);
						if (!state.IsCharState())
							b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder,
								(uint)nowPos64, prevByte, m_OutWindow.GetByte(rep0));
						else
							b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder, (uint)nowPos64, prevByte);
						m_OutWindow.PutByte(b);
						state.UpdateChar();
						nowPos64++;
					}
					else
					{
						uint len;
						if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1)
						{
							if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0)
							{
								if (m_IsRep0LongDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)
								{
									state.UpdateShortRep();
									m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));
									nowPos64++;
									continue;
								}
							}
							else
							{
								UInt32 distance;
								if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0)
								{
									distance = rep1;
								}
								else
								{
									if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)
										distance = rep2;
									else
									{
										distance = rep3;
										rep3 = rep2;
									}
									rep2 = rep1;
								}
								rep1 = rep0;
								rep0 = distance;
							}
							len = m_RepLenDecoder.Decode(m_RangeDecoder, posState) + Base.kMatchMinLen;
							state.UpdateRep();
						}
						else
						{
							rep3 = rep2;
							rep2 = rep1;
							rep1 = rep0;
							len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder, posState);
							state.UpdateMatch();
							uint posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);
							if (posSlot >= Base.kStartPosModelIndex)
							{
								int numDirectBits = (int)((posSlot >> 1) - 1);
								rep0 = ((2 | (posSlot & 1)) << numDirectBits);
								if (posSlot < Base.kEndPosModelIndex)
									rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders,
											rep0 - posSlot - 1, m_RangeDecoder, numDirectBits);
								else
								{
									rep0 += (m_RangeDecoder.DecodeDirectBits(
										numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);
									rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);
								}
							}
							else
								rep0 = posSlot;
						}
						if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck)
						{
							if (rep0 == 0xFFFFFFFF)
								break;
							throw new DataErrorException();
						}
						m_OutWindow.CopyBlock(rep0, len);
						nowPos64 += len;
					}
				}
			}
			m_OutWindow.Flush();
			m_OutWindow.ReleaseStream();
			m_RangeDecoder.ReleaseStream();
		}

		public void SetDecoderProperties(byte[] properties)
		{
			if (properties.Length < 5)
				throw new InvalidParamException();
			int lc = properties[0] % 9;
			int remainder = properties[0] / 9;
			int lp = remainder % 5;
			int pb = remainder / 5;
			if (pb > Base.kNumPosStatesBitsMax)
				throw new InvalidParamException();
			UInt32 dictionarySize = 0;
			for (int i = 0; i < 4; i++)
				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
			SetDictionarySize(dictionarySize);
			SetLiteralProperties(lp, lc);
			SetPosBitsProperties(pb);
		}

		public bool Train(System.IO.Stream stream)
		{
			_solid = true;
			return m_OutWindow.Train(stream);
		}

		/*
		public override bool CanRead { get { return true; }}
		public override bool CanWrite { get { return true; }}
		public override bool CanSeek { get { return true; }}
		public override long Length { get { return 0; }}
		public override long Position
		{
			get { return 0;	}
			set { }
		}
		public override void Flush() { }
		public override int Read(byte[] buffer, int offset, int count) 
		{
			return 0;
		}
		public override void Write(byte[] buffer, int offset, int count)
		{
		}
		public override long Seek(long offset, System.IO.SeekOrigin origin)
		{
			return 0;
		}
		public override void SetLength(long value) {}
		*/
	}
}

```

`AssetStudio/7zip/Compress/LZMA/LzmaEncoder.cs`:

```cs
// LzmaEncoder.cs

using System;

namespace SevenZip.Compression.LZMA
{
	using RangeCoder;

	public class Encoder : ICoder, ISetCoderProperties, IWriteCoderProperties
	{
		enum EMatchFinderType
		{
			BT2,
			BT4,
		};

		const UInt32 kIfinityPrice = 0xFFFFFFF;

		static Byte[] g_FastPos = new Byte[1 << 11];

		static Encoder()
		{
			const Byte kFastSlots = 22;
			int c = 2;
			g_FastPos[0] = 0;
			g_FastPos[1] = 1;
			for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++)
			{
				UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));
				for (UInt32 j = 0; j < k; j++, c++)
					g_FastPos[c] = slotFast;
			}
		}

		static UInt32 GetPosSlot(UInt32 pos)
		{
			if (pos < (1 << 11))
				return g_FastPos[pos];
			if (pos < (1 << 21))
				return (UInt32)(g_FastPos[pos >> 10] + 20);
			return (UInt32)(g_FastPos[pos >> 20] + 40);
		}

		static UInt32 GetPosSlot2(UInt32 pos)
		{
			if (pos < (1 << 17))
				return (UInt32)(g_FastPos[pos >> 6] + 12);
			if (pos < (1 << 27))
				return (UInt32)(g_FastPos[pos >> 16] + 32);
			return (UInt32)(g_FastPos[pos >> 26] + 52);
		}

		Base.State _state = new Base.State();
		Byte _previousByte;
		UInt32[] _repDistances = new UInt32[Base.kNumRepDistances];

		void BaseInit()
		{
			_state.Init();
			_previousByte = 0;
			for (UInt32 i = 0; i < Base.kNumRepDistances; i++)
				_repDistances[i] = 0;
		}

		const int kDefaultDictionaryLogSize = 22;
		const UInt32 kNumFastBytesDefault = 0x20;

		class LiteralEncoder
		{
			public struct Encoder2
			{
				BitEncoder[] m_Encoders;

				public void Create() { m_Encoders = new BitEncoder[0x300]; }

				public void Init() { for (int i = 0; i < 0x300; i++) m_Encoders[i].Init(); }

				public void Encode(RangeCoder.Encoder rangeEncoder, byte symbol)
				{
					uint context = 1;
					for (int i = 7; i >= 0; i--)
					{
						uint bit = (uint)((symbol >> i) & 1);
						m_Encoders[context].Encode(rangeEncoder, bit);
						context = (context << 1) | bit;
					}
				}

				public void EncodeMatched(RangeCoder.Encoder rangeEncoder, byte matchByte, byte symbol)
				{
					uint context = 1;
					bool same = true;
					for (int i = 7; i >= 0; i--)
					{
						uint bit = (uint)((symbol >> i) & 1);
						uint state = context;
						if (same)
						{
							uint matchBit = (uint)((matchByte >> i) & 1);
							state += ((1 + matchBit) << 8);
							same = (matchBit == bit);
						}
						m_Encoders[state].Encode(rangeEncoder, bit);
						context = (context << 1) | bit;
					}
				}

				public uint GetPrice(bool matchMode, byte matchByte, byte symbol)
				{
					uint price = 0;
					uint context = 1;
					int i = 7;
					if (matchMode)
					{
						for (; i >= 0; i--)
						{
							uint matchBit = (uint)(matchByte >> i) & 1;
							uint bit = (uint)(symbol >> i) & 1;
							price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);
							context = (context << 1) | bit;
							if (matchBit != bit)
							{
								i--;
								break;
							}
						}
					}
					for (; i >= 0; i--)
					{
						uint bit = (uint)(symbol >> i) & 1;
						price += m_Encoders[context].GetPrice(bit);
						context = (context << 1) | bit;
					}
					return price;
				}
			}

			Encoder2[] m_Coders;
			int m_NumPrevBits;
			int m_NumPosBits;
			uint m_PosMask;

			public void Create(int numPosBits, int numPrevBits)
			{
				if (m_Coders != null && m_NumPrevBits == numPrevBits && m_NumPosBits == numPosBits)
					return;
				m_NumPosBits = numPosBits;
				m_PosMask = ((uint)1 << numPosBits) - 1;
				m_NumPrevBits = numPrevBits;
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				m_Coders = new Encoder2[numStates];
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Create();
			}

			public void Init()
			{
				uint numStates = (uint)1 << (m_NumPrevBits + m_NumPosBits);
				for (uint i = 0; i < numStates; i++)
					m_Coders[i].Init();
			}

			public Encoder2 GetSubCoder(UInt32 pos, Byte prevByte)
			{ return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))]; }
		}

		class LenEncoder
		{
			RangeCoder.BitEncoder _choice = new RangeCoder.BitEncoder();
			RangeCoder.BitEncoder _choice2 = new RangeCoder.BitEncoder();
			RangeCoder.BitTreeEncoder[] _lowCoder = new RangeCoder.BitTreeEncoder[Base.kNumPosStatesEncodingMax];
			RangeCoder.BitTreeEncoder[] _midCoder = new RangeCoder.BitTreeEncoder[Base.kNumPosStatesEncodingMax];
			RangeCoder.BitTreeEncoder _highCoder = new RangeCoder.BitTreeEncoder(Base.kNumHighLenBits);

			public LenEncoder()
			{
				for (UInt32 posState = 0; posState < Base.kNumPosStatesEncodingMax; posState++)
				{
					_lowCoder[posState] = new RangeCoder.BitTreeEncoder(Base.kNumLowLenBits);
					_midCoder[posState] = new RangeCoder.BitTreeEncoder(Base.kNumMidLenBits);
				}
			}

			public void Init(UInt32 numPosStates)
			{
				_choice.Init();
				_choice2.Init();
				for (UInt32 posState = 0; posState < numPosStates; posState++)
				{
					_lowCoder[posState].Init();
					_midCoder[posState].Init();
				}
				_highCoder.Init();
			}

			public void Encode(RangeCoder.Encoder rangeEncoder, UInt32 symbol, UInt32 posState)
			{
				if (symbol < Base.kNumLowLenSymbols)
				{
					_choice.Encode(rangeEncoder, 0);
					_lowCoder[posState].Encode(rangeEncoder, symbol);
				}
				else
				{
					symbol -= Base.kNumLowLenSymbols;
					_choice.Encode(rangeEncoder, 1);
					if (symbol < Base.kNumMidLenSymbols)
					{
						_choice2.Encode(rangeEncoder, 0);
						_midCoder[posState].Encode(rangeEncoder, symbol);
					}
					else
					{
						_choice2.Encode(rangeEncoder, 1);
						_highCoder.Encode(rangeEncoder, symbol - Base.kNumMidLenSymbols);
					}
				}
			}

			public void SetPrices(UInt32 posState, UInt32 numSymbols, UInt32[] prices, UInt32 st)
			{
				UInt32 a0 = _choice.GetPrice0();
				UInt32 a1 = _choice.GetPrice1();
				UInt32 b0 = a1 + _choice2.GetPrice0();
				UInt32 b1 = a1 + _choice2.GetPrice1();
				UInt32 i = 0;
				for (i = 0; i < Base.kNumLowLenSymbols; i++)
				{
					if (i >= numSymbols)
						return;
					prices[st + i] = a0 + _lowCoder[posState].GetPrice(i);
				}
				for (; i < Base.kNumLowLenSymbols + Base.kNumMidLenSymbols; i++)
				{
					if (i >= numSymbols)
						return;
					prices[st + i] = b0 + _midCoder[posState].GetPrice(i - Base.kNumLowLenSymbols);
				}
				for (; i < numSymbols; i++)
					prices[st + i] = b1 + _highCoder.GetPrice(i - Base.kNumLowLenSymbols - Base.kNumMidLenSymbols);
			}
		};

		const UInt32 kNumLenSpecSymbols = Base.kNumLowLenSymbols + Base.kNumMidLenSymbols;

		class LenPriceTableEncoder : LenEncoder
		{
			UInt32[] _prices = new UInt32[Base.kNumLenSymbols << Base.kNumPosStatesBitsEncodingMax];
			UInt32 _tableSize;
			UInt32[] _counters = new UInt32[Base.kNumPosStatesEncodingMax];

			public void SetTableSize(UInt32 tableSize) { _tableSize = tableSize; }

			public UInt32 GetPrice(UInt32 symbol, UInt32 posState)
			{
				return _prices[posState * Base.kNumLenSymbols + symbol];
			}

			void UpdateTable(UInt32 posState)
			{
				SetPrices(posState, _tableSize, _prices, posState * Base.kNumLenSymbols);
				_counters[posState] = _tableSize;
			}

			public void UpdateTables(UInt32 numPosStates)
			{
				for (UInt32 posState = 0; posState < numPosStates; posState++)
					UpdateTable(posState);
			}

			public new void Encode(RangeCoder.Encoder rangeEncoder, UInt32 symbol, UInt32 posState)
			{
				base.Encode(rangeEncoder, symbol, posState);
				if (--_counters[posState] == 0)
					UpdateTable(posState);
			}
		}

		const UInt32 kNumOpts = 1 << 12;
		class Optimal
		{
			public Base.State State;

			public bool Prev1IsChar;
			public bool Prev2;

			public UInt32 PosPrev2;
			public UInt32 BackPrev2;

			public UInt32 Price;
			public UInt32 PosPrev;
			public UInt32 BackPrev;

			public UInt32 Backs0;
			public UInt32 Backs1;
			public UInt32 Backs2;
			public UInt32 Backs3;

			public void MakeAsChar() { BackPrev = 0xFFFFFFFF; Prev1IsChar = false; }
			public void MakeAsShortRep() { BackPrev = 0; ; Prev1IsChar = false; }
			public bool IsShortRep() { return (BackPrev == 0); }
		};
		Optimal[] _optimum = new Optimal[kNumOpts];
		LZ.IMatchFinder _matchFinder = null;
		RangeCoder.Encoder _rangeEncoder = new RangeCoder.Encoder();

		RangeCoder.BitEncoder[] _isMatch = new RangeCoder.BitEncoder[Base.kNumStates << Base.kNumPosStatesBitsMax];
		RangeCoder.BitEncoder[] _isRep = new RangeCoder.BitEncoder[Base.kNumStates];
		RangeCoder.BitEncoder[] _isRepG0 = new RangeCoder.BitEncoder[Base.kNumStates];
		RangeCoder.BitEncoder[] _isRepG1 = new RangeCoder.BitEncoder[Base.kNumStates];
		RangeCoder.BitEncoder[] _isRepG2 = new RangeCoder.BitEncoder[Base.kNumStates];
		RangeCoder.BitEncoder[] _isRep0Long = new RangeCoder.BitEncoder[Base.kNumStates << Base.kNumPosStatesBitsMax];

		RangeCoder.BitTreeEncoder[] _posSlotEncoder = new RangeCoder.BitTreeEncoder[Base.kNumLenToPosStates];
		
		RangeCoder.BitEncoder[] _posEncoders = new RangeCoder.BitEncoder[Base.kNumFullDistances - Base.kEndPosModelIndex];
		RangeCoder.BitTreeEncoder _posAlignEncoder = new RangeCoder.BitTreeEncoder(Base.kNumAlignBits);

		LenPriceTableEncoder _lenEncoder = new LenPriceTableEncoder();
		LenPriceTableEncoder _repMatchLenEncoder = new LenPriceTableEncoder();

		LiteralEncoder _literalEncoder = new LiteralEncoder();

		UInt32[] _matchDistances = new UInt32[Base.kMatchMaxLen * 2 + 2];
		
		UInt32 _numFastBytes = kNumFastBytesDefault;
		UInt32 _longestMatchLength;
		UInt32 _numDistancePairs;

		UInt32 _additionalOffset;

		UInt32 _optimumEndIndex;
		UInt32 _optimumCurrentIndex;

		bool _longestMatchWasFound;

		UInt32[] _posSlotPrices = new UInt32[1 << (Base.kNumPosSlotBits + Base.kNumLenToPosStatesBits)];
		UInt32[] _distancesPrices = new UInt32[Base.kNumFullDistances << Base.kNumLenToPosStatesBits];
		UInt32[] _alignPrices = new UInt32[Base.kAlignTableSize];
		UInt32 _alignPriceCount;

		UInt32 _distTableSize = (kDefaultDictionaryLogSize * 2);

		int _posStateBits = 2;
		UInt32 _posStateMask = (4 - 1);
		int _numLiteralPosStateBits = 0;
		int _numLiteralContextBits = 3;

		UInt32 _dictionarySize = (1 << kDefaultDictionaryLogSize);
		UInt32 _dictionarySizePrev = 0xFFFFFFFF;
		UInt32 _numFastBytesPrev = 0xFFFFFFFF;

		Int64 nowPos64;
		bool _finished;
		System.IO.Stream _inStream;

		EMatchFinderType _matchFinderType = EMatchFinderType.BT4;
		bool _writeEndMark = false;
		
		bool _needReleaseMFStream;

		void Create()
		{
			if (_matchFinder == null)
			{
				LZ.BinTree bt = new LZ.BinTree();
				int numHashBytes = 4;
				if (_matchFinderType == EMatchFinderType.BT2)
					numHashBytes = 2;
				bt.SetType(numHashBytes);
				_matchFinder = bt;
			}
			_literalEncoder.Create(_numLiteralPosStateBits, _numLiteralContextBits);

			if (_dictionarySize == _dictionarySizePrev && _numFastBytesPrev == _numFastBytes)
				return;
			_matchFinder.Create(_dictionarySize, kNumOpts, _numFastBytes, Base.kMatchMaxLen + 1);
			_dictionarySizePrev = _dictionarySize;
			_numFastBytesPrev = _numFastBytes;
		}

		public Encoder()
		{
			for (int i = 0; i < kNumOpts; i++)
				_optimum[i] = new Optimal();
			for (int i = 0; i < Base.kNumLenToPosStates; i++)
				_posSlotEncoder[i] = new RangeCoder.BitTreeEncoder(Base.kNumPosSlotBits);
		}

		void SetWriteEndMarkerMode(bool writeEndMarker)
		{
			_writeEndMark = writeEndMarker;
		}

		void Init()
		{
			BaseInit();
			_rangeEncoder.Init();

			uint i;
			for (i = 0; i < Base.kNumStates; i++)
			{
				for (uint j = 0; j <= _posStateMask; j++)
				{
					uint complexState = (i << Base.kNumPosStatesBitsMax) + j;
					_isMatch[complexState].Init();
					_isRep0Long[complexState].Init();
				}
				_isRep[i].Init();
				_isRepG0[i].Init();
				_isRepG1[i].Init();
				_isRepG2[i].Init();
			}
			_literalEncoder.Init();
			for (i = 0; i < Base.kNumLenToPosStates; i++)
				_posSlotEncoder[i].Init();
			for (i = 0; i < Base.kNumFullDistances - Base.kEndPosModelIndex; i++)
				_posEncoders[i].Init();

			_lenEncoder.Init((UInt32)1 << _posStateBits);
			_repMatchLenEncoder.Init((UInt32)1 << _posStateBits);

			_posAlignEncoder.Init();

			_longestMatchWasFound = false;
			_optimumEndIndex = 0;
			_optimumCurrentIndex = 0;
			_additionalOffset = 0;
		}

		void ReadMatchDistances(out UInt32 lenRes, out UInt32 numDistancePairs)
		{
			lenRes = 0;
			numDistancePairs = _matchFinder.GetMatches(_matchDistances);
			if (numDistancePairs > 0)
			{
				lenRes = _matchDistances[numDistancePairs - 2];
				if (lenRes == _numFastBytes)
					lenRes += _matchFinder.GetMatchLen((int)lenRes - 1, _matchDistances[numDistancePairs - 1],
						Base.kMatchMaxLen - lenRes);
			}
			_additionalOffset++;
		}


		void MovePos(UInt32 num)
		{
			if (num > 0)
			{
				_matchFinder.Skip(num);
				_additionalOffset += num;
			}
		}

		UInt32 GetRepLen1Price(Base.State state, UInt32 posState)
		{
			return _isRepG0[state.Index].GetPrice0() +
					_isRep0Long[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0();
		}

		UInt32 GetPureRepPrice(UInt32 repIndex, Base.State state, UInt32 posState)
		{
			UInt32 price;
			if (repIndex == 0)
			{
				price = _isRepG0[state.Index].GetPrice0();
				price += _isRep0Long[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();
			}
			else
			{
				price = _isRepG0[state.Index].GetPrice1();
				if (repIndex == 1)
					price += _isRepG1[state.Index].GetPrice0();
				else
				{
					price += _isRepG1[state.Index].GetPrice1();
					price += _isRepG2[state.Index].GetPrice(repIndex - 2);
				}
			}
			return price;
		}

		UInt32 GetRepPrice(UInt32 repIndex, UInt32 len, Base.State state, UInt32 posState)
		{
			UInt32 price = _repMatchLenEncoder.GetPrice(len - Base.kMatchMinLen, posState);
			return price + GetPureRepPrice(repIndex, state, posState);
		}
	
		UInt32 GetPosLenPrice(UInt32 pos, UInt32 len, UInt32 posState)
		{
			UInt32 price;
			UInt32 lenToPosState = Base.GetLenToPosState(len);
			if (pos < Base.kNumFullDistances)
				price = _distancesPrices[(lenToPosState * Base.kNumFullDistances) + pos];
			else
				price = _posSlotPrices[(lenToPosState << Base.kNumPosSlotBits) + GetPosSlot2(pos)] +
					_alignPrices[pos & Base.kAlignMask];
			return price + _lenEncoder.GetPrice(len - Base.kMatchMinLen, posState);
		}

		UInt32 Backward(out UInt32 backRes, UInt32 cur)
		{
			_optimumEndIndex = cur;
			UInt32 posMem = _optimum[cur].PosPrev;
			UInt32 backMem = _optimum[cur].BackPrev;
			do
			{
				if (_optimum[cur].Prev1IsChar)
				{
					_optimum[posMem].MakeAsChar();
					_optimum[posMem].PosPrev = posMem - 1;
					if (_optimum[cur].Prev2)
					{
						_optimum[posMem - 1].Prev1IsChar = false;
						_optimum[posMem - 1].PosPrev = _optimum[cur].PosPrev2;
						_optimum[posMem - 1].BackPrev = _optimum[cur].BackPrev2;
					}
				}
				UInt32 posPrev = posMem;
				UInt32 backCur = backMem;

				backMem = _optimum[posPrev].BackPrev;
				posMem = _optimum[posPrev].PosPrev;

				_optimum[posPrev].BackPrev = backCur;
				_optimum[posPrev].PosPrev = cur;
				cur = posPrev;
			}
			while (cur > 0);
			backRes = _optimum[0].BackPrev;
			_optimumCurrentIndex = _optimum[0].PosPrev;
			return _optimumCurrentIndex;
		}

		UInt32[] reps = new UInt32[Base.kNumRepDistances];
		UInt32[] repLens = new UInt32[Base.kNumRepDistances];


		UInt32 GetOptimum(UInt32 position, out UInt32 backRes)
		{
			if (_optimumEndIndex != _optimumCurrentIndex)
			{
				UInt32 lenRes = _optimum[_optimumCurrentIndex].PosPrev - _optimumCurrentIndex;
				backRes = _optimum[_optimumCurrentIndex].BackPrev;
				_optimumCurrentIndex = _optimum[_optimumCurrentIndex].PosPrev;
				return lenRes;
			}
			_optimumCurrentIndex = _optimumEndIndex = 0;

			UInt32 lenMain, numDistancePairs;
			if (!_longestMatchWasFound)
			{
				ReadMatchDistances(out lenMain, out numDistancePairs);
			}
			else
			{
				lenMain = _longestMatchLength;
				numDistancePairs = _numDistancePairs;
				_longestMatchWasFound = false;
			}

			UInt32 numAvailableBytes = _matchFinder.GetNumAvailableBytes() + 1;
			if (numAvailableBytes < 2)
			{
				backRes = 0xFFFFFFFF;
				return 1;
			}
			if (numAvailableBytes > Base.kMatchMaxLen)
				numAvailableBytes = Base.kMatchMaxLen;

			UInt32 repMaxIndex = 0;
			UInt32 i;			
			for (i = 0; i < Base.kNumRepDistances; i++)
			{
				reps[i] = _repDistances[i];
				repLens[i] = _matchFinder.GetMatchLen(0 - 1, reps[i], Base.kMatchMaxLen);
				if (repLens[i] > repLens[repMaxIndex])
					repMaxIndex = i;
			}
			if (repLens[repMaxIndex] >= _numFastBytes)
			{
				backRes = repMaxIndex;
				UInt32 lenRes = repLens[repMaxIndex];
				MovePos(lenRes - 1);
				return lenRes;
			}

			if (lenMain >= _numFastBytes)
			{
				backRes = _matchDistances[numDistancePairs - 1] + Base.kNumRepDistances;
				MovePos(lenMain - 1);
				return lenMain;
			}
			
			Byte currentByte = _matchFinder.GetIndexByte(0 - 1);
			Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - 1));

			if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)
			{
				backRes = (UInt32)0xFFFFFFFF;
				return 1;
			}

			_optimum[0].State = _state;

			UInt32 posState = (position & _posStateMask);

			_optimum[1].Price = _isMatch[(_state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +
					_literalEncoder.GetSubCoder(position, _previousByte).GetPrice(!_state.IsCharState(), matchByte, currentByte);
			_optimum[1].MakeAsChar();

			UInt32 matchPrice = _isMatch[(_state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();
			UInt32 repMatchPrice = matchPrice + _isRep[_state.Index].GetPrice1();

			if (matchByte == currentByte)
			{
				UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(_state, posState);
				if (shortRepPrice < _optimum[1].Price)
				{
					_optimum[1].Price = shortRepPrice;
					_optimum[1].MakeAsShortRep();
				}
			}

			UInt32 lenEnd = ((lenMain >= repLens[repMaxIndex]) ? lenMain : repLens[repMaxIndex]);

			if(lenEnd < 2)
			{
				backRes = _optimum[1].BackPrev;
				return 1;
			}
			
			_optimum[1].PosPrev = 0;

			_optimum[0].Backs0 = reps[0];
			_optimum[0].Backs1 = reps[1];
			_optimum[0].Backs2 = reps[2];
			_optimum[0].Backs3 = reps[3];

			UInt32 len = lenEnd;
			do
				_optimum[len--].Price = kIfinityPrice;
			while (len >= 2);

			for (i = 0; i < Base.kNumRepDistances; i++)
			{
				UInt32 repLen = repLens[i];
				if (repLen < 2)
					continue;
				UInt32 price = repMatchPrice + GetPureRepPrice(i, _state, posState);
				do
				{
					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2, posState);
					Optimal optimum = _optimum[repLen];
					if (curAndLenPrice < optimum.Price)
					{
						optimum.Price = curAndLenPrice;
						optimum.PosPrev = 0;
						optimum.BackPrev = i;
						optimum.Prev1IsChar = false;
					}
				}
				while (--repLen >= 2);
			}

			UInt32 normalMatchPrice = matchPrice + _isRep[_state.Index].GetPrice0();
			
			len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
			if (len <= lenMain)
			{
				UInt32 offs = 0;
				while (len > _matchDistances[offs])
					offs += 2;
				for (; ; len++)
				{
					UInt32 distance = _matchDistances[offs + 1];
					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance, len, posState);
					Optimal optimum = _optimum[len];
					if (curAndLenPrice < optimum.Price)
					{
						optimum.Price = curAndLenPrice;
						optimum.PosPrev = 0;
						optimum.BackPrev = distance + Base.kNumRepDistances;
						optimum.Prev1IsChar = false;
					}
					if (len == _matchDistances[offs])
					{
						offs += 2;
						if (offs == numDistancePairs)
							break;
					}
				}
			}

			UInt32 cur = 0;

			while (true)
			{
				cur++;
				if (cur == lenEnd)
					return Backward(out backRes, cur);
				UInt32 newLen;
				ReadMatchDistances(out newLen, out numDistancePairs);
				if (newLen >= _numFastBytes)
				{
					_numDistancePairs = numDistancePairs;
					_longestMatchLength = newLen;
					_longestMatchWasFound = true;
					return Backward(out backRes, cur);
				}
				position++;
				UInt32 posPrev = _optimum[cur].PosPrev;
				Base.State state;
				if (_optimum[cur].Prev1IsChar)
				{
					posPrev--;
					if (_optimum[cur].Prev2)
					{
						state = _optimum[_optimum[cur].PosPrev2].State;
						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)
							state.UpdateRep();
						else
							state.UpdateMatch();
					}
					else
						state = _optimum[posPrev].State;
					state.UpdateChar();
				}
				else
					state = _optimum[posPrev].State;
				if (posPrev == cur - 1)
				{
					if (_optimum[cur].IsShortRep())
						state.UpdateShortRep();
					else
						state.UpdateChar();
				}
				else
				{
					UInt32 pos;
					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)
					{
						posPrev = _optimum[cur].PosPrev2;
						pos = _optimum[cur].BackPrev2;
						state.UpdateRep();
					}
					else
					{
						pos = _optimum[cur].BackPrev;
						if (pos < Base.kNumRepDistances)
							state.UpdateRep();
						else
							state.UpdateMatch();
					}
					Optimal opt = _optimum[posPrev];
					if (pos < Base.kNumRepDistances)
					{
						if (pos == 0)
						{
							reps[0] = opt.Backs0;
							reps[1] = opt.Backs1;
							reps[2] = opt.Backs2;
							reps[3] = opt.Backs3;
						}
						else if (pos == 1)
						{
							reps[0] = opt.Backs1;
							reps[1] = opt.Backs0;
							reps[2] = opt.Backs2;
							reps[3] = opt.Backs3;
						}
						else if (pos == 2)
						{
							reps[0] = opt.Backs2;
							reps[1] = opt.Backs0;
							reps[2] = opt.Backs1;
							reps[3] = opt.Backs3;
						}
						else
						{
							reps[0] = opt.Backs3;
							reps[1] = opt.Backs0;
							reps[2] = opt.Backs1;
							reps[3] = opt.Backs2;
						}
					}
					else
					{
						reps[0] = (pos - Base.kNumRepDistances);
						reps[1] = opt.Backs0;
						reps[2] = opt.Backs1;
						reps[3] = opt.Backs2;
					}
				}
				_optimum[cur].State = state;
				_optimum[cur].Backs0 = reps[0];
				_optimum[cur].Backs1 = reps[1];
				_optimum[cur].Backs2 = reps[2];
				_optimum[cur].Backs3 = reps[3];
				UInt32 curPrice = _optimum[cur].Price;

				currentByte = _matchFinder.GetIndexByte(0 - 1);
				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));

				posState = (position & _posStateMask);

				UInt32 curAnd1Price = curPrice +
					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +
					_literalEncoder.GetSubCoder(position, _matchFinder.GetIndexByte(0 - 2)).
					GetPrice(!state.IsCharState(), matchByte, currentByte);

				Optimal nextOptimum = _optimum[cur + 1];

				bool nextIsChar = false;
				if (curAnd1Price < nextOptimum.Price)
				{
					nextOptimum.Price = curAnd1Price;
					nextOptimum.PosPrev = cur;
					nextOptimum.MakeAsChar();
					nextIsChar = true;
				}

				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();
				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();

				if (matchByte == currentByte &&
					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))
				{
					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state, posState);
					if (shortRepPrice <= nextOptimum.Price)
					{
						nextOptimum.Price = shortRepPrice;
						nextOptimum.PosPrev = cur;
						nextOptimum.MakeAsShortRep();
						nextIsChar = true;
					}
				}

				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;
				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur, numAvailableBytesFull);
				numAvailableBytes = numAvailableBytesFull;

				if (numAvailableBytes < 2)
					continue;
				if (numAvailableBytes > _numFastBytes)
					numAvailableBytes = _numFastBytes;
				if (!nextIsChar && matchByte != currentByte)
				{
					// try Literal + rep0
					UInt32 t = Math.Min(numAvailableBytesFull - 1, _numFastBytes);
					UInt32 lenTest2 = _matchFinder.GetMatchLen(0, reps[0], t);
					if (lenTest2 >= 2)
					{
						Base.State state2 = state;
						state2.UpdateChar();
						UInt32 posStateNext = (position + 1) & _posStateMask;
						UInt32 nextRepMatchPrice = curAnd1Price +
							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +
							_isRep[state2.Index].GetPrice1();
						{
							UInt32 offset = cur + 1 + lenTest2;
							while (lenEnd < offset)
								_optimum[++lenEnd].Price = kIfinityPrice;
							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(
								0, lenTest2, state2, posStateNext);
							Optimal optimum = _optimum[offset];
							if (curAndLenPrice < optimum.Price)
							{
								optimum.Price = curAndLenPrice;
								optimum.PosPrev = cur + 1;
								optimum.BackPrev = 0;
								optimum.Prev1IsChar = true;
								optimum.Prev2 = false;
							}
						}
					}
				}

				UInt32 startLen = 2; // speed optimization 

				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)
				{
					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1, reps[repIndex], numAvailableBytes);
					if (lenTest < 2)
						continue;
					UInt32 lenTestTemp = lenTest;
					do
					{
						while (lenEnd < cur + lenTest)
							_optimum[++lenEnd].Price = kIfinityPrice;
						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex, lenTest, state, posState);
						Optimal optimum = _optimum[cur + lenTest];
						if (curAndLenPrice < optimum.Price)
						{
							optimum.Price = curAndLenPrice;
							optimum.PosPrev = cur;
							optimum.BackPrev = repIndex;
							optimum.Prev1IsChar = false;
						}
					}
					while(--lenTest >= 2);
					lenTest = lenTestTemp;

					if (repIndex == 0)
						startLen = lenTest + 1;

					// if (_maxMode)
					if (lenTest < numAvailableBytesFull)
					{
						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest, _numFastBytes);
						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest, reps[repIndex], t);
						if (lenTest2 >= 2)
						{
							Base.State state2 = state;
							state2.UpdateRep();
							UInt32 posStateNext = (position + lenTest) & _posStateMask;
							UInt32 curAndLenCharPrice = 
									repMatchPrice + GetRepPrice(repIndex, lenTest, state, posState) + 
									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +
									_literalEncoder.GetSubCoder(position + lenTest, 
									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true,
									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1))), 
									_matchFinder.GetIndexByte((Int32)lenTest - 1));
							state2.UpdateChar();
							posStateNext = (position + lenTest + 1) & _posStateMask;
							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();
							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();
							
							// for(; lenTest2 >= 2; lenTest2--)
							{
								UInt32 offset = lenTest + 1 + lenTest2;
								while(lenEnd < cur + offset)
									_optimum[++lenEnd].Price = kIfinityPrice;
								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);
								Optimal optimum = _optimum[cur + offset];
								if (curAndLenPrice < optimum.Price) 
								{
									optimum.Price = curAndLenPrice;
									optimum.PosPrev = cur + lenTest + 1;
									optimum.BackPrev = 0;
									optimum.Prev1IsChar = true;
									optimum.Prev2 = true;
									optimum.PosPrev2 = cur;
									optimum.BackPrev2 = repIndex;
								}
							}
						}
					}
				}

				if (newLen > numAvailableBytes)
				{
					newLen = numAvailableBytes;
					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;
					_matchDistances[numDistancePairs] = newLen;
					numDistancePairs += 2;
				}
				if (newLen >= startLen)
				{
					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();
					while (lenEnd < cur + newLen)
						_optimum[++lenEnd].Price = kIfinityPrice;

					UInt32 offs = 0;
					while (startLen > _matchDistances[offs])
						offs += 2;

					for (UInt32 lenTest = startLen; ; lenTest++)
					{
						UInt32 curBack = _matchDistances[offs + 1];
						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack, lenTest, posState);
						Optimal optimum = _optimum[cur + lenTest];
						if (curAndLenPrice < optimum.Price)
						{
							optimum.Price = curAndLenPrice;
							optimum.PosPrev = cur;
							optimum.BackPrev = curBack + Base.kNumRepDistances;
							optimum.Prev1IsChar = false;
						}

						if (lenTest == _matchDistances[offs])
						{
							if (lenTest < numAvailableBytesFull)
							{
								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest, _numFastBytes);
								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest, curBack, t);
								if (lenTest2 >= 2)
								{
									Base.State state2 = state;
									state2.UpdateMatch();
									UInt32 posStateNext = (position + lenTest) & _posStateMask;
									UInt32 curAndLenCharPrice = curAndLenPrice +
										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +
										_literalEncoder.GetSubCoder(position + lenTest,
										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).
										GetPrice(true,
										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1),
										_matchFinder.GetIndexByte((Int32)lenTest - 1));
									state2.UpdateChar();
									posStateNext = (position + lenTest + 1) & _posStateMask;
									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();
									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();

									UInt32 offset = lenTest + 1 + lenTest2;
									while (lenEnd < cur + offset)
										_optimum[++lenEnd].Price = kIfinityPrice;
									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);
									optimum = _optimum[cur + offset];
									if (curAndLenPrice < optimum.Price)
									{
										optimum.Price = curAndLenPrice;
										optimum.PosPrev = cur + lenTest + 1;
										optimum.BackPrev = 0;
										optimum.Prev1IsChar = true;
										optimum.Prev2 = true;
										optimum.PosPrev2 = cur;
										optimum.BackPrev2 = curBack + Base.kNumRepDistances;
									}
								}
							}
							offs += 2;
							if (offs == numDistancePairs)
								break;
						}
					}
				}
			}
		}

		bool ChangePair(UInt32 smallDist, UInt32 bigDist)
		{
			const int kDif = 7;
			return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
		}

		void WriteEndMarker(UInt32 posState)
		{
			if (!_writeEndMark)
				return;

			_isMatch[(_state.Index << Base.kNumPosStatesBitsMax) + posState].Encode(_rangeEncoder, 1);
			_isRep[_state.Index].Encode(_rangeEncoder, 0);
			_state.UpdateMatch();
			UInt32 len = Base.kMatchMinLen;
			_lenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
			UInt32 posSlot = (1 << Base.kNumPosSlotBits) - 1;
			UInt32 lenToPosState = Base.GetLenToPosState(len);
			_posSlotEncoder[lenToPosState].Encode(_rangeEncoder, posSlot);
			int footerBits = 30;
			UInt32 posReduced = (((UInt32)1) << footerBits) - 1;
			_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits, footerBits - Base.kNumAlignBits);
			_posAlignEncoder.ReverseEncode(_rangeEncoder, posReduced & Base.kAlignMask);
		}

		void Flush(UInt32 nowPos)
		{
			ReleaseMFStream();
			WriteEndMarker(nowPos & _posStateMask);
			_rangeEncoder.FlushData();
			_rangeEncoder.FlushStream();
		}

		public void CodeOneBlock(out Int64 inSize, out Int64 outSize, out bool finished)
		{
			inSize = 0;
			outSize = 0;
			finished = true;

			if (_inStream != null)
			{
				_matchFinder.SetStream(_inStream);
				_matchFinder.Init();
				_needReleaseMFStream = true;
				_inStream = null;
				if (_trainSize > 0)
					_matchFinder.Skip(_trainSize);
			}

			if (_finished)
				return;
			_finished = true;


			Int64 progressPosValuePrev = nowPos64;
			if (nowPos64 == 0)
			{
				if (_matchFinder.GetNumAvailableBytes() == 0)
				{
					Flush((UInt32)nowPos64);
					return;
				}
				UInt32 len, numDistancePairs; // it's not used
				ReadMatchDistances(out len, out numDistancePairs);
				UInt32 posState = (UInt32)(nowPos64) & _posStateMask;
				_isMatch[(_state.Index << Base.kNumPosStatesBitsMax) + posState].Encode(_rangeEncoder, 0);
				_state.UpdateChar();
				Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));
				_literalEncoder.GetSubCoder((UInt32)(nowPos64), _previousByte).Encode(_rangeEncoder, curByte);
				_previousByte = curByte;
				_additionalOffset--;
				nowPos64++;
			}
			if (_matchFinder.GetNumAvailableBytes() == 0)
			{
				Flush((UInt32)nowPos64);
				return;
			}
			while (true)
			{
				UInt32 pos;
				UInt32 len = GetOptimum((UInt32)nowPos64, out pos);
				
				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;
				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;
				if (len == 1 && pos == 0xFFFFFFFF)
				{
					_isMatch[complexState].Encode(_rangeEncoder, 0);
					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));
					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64, _previousByte);
					if (!_state.IsCharState())
					{
						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));
						subCoder.EncodeMatched(_rangeEncoder, matchByte, curByte);
					}
					else
						subCoder.Encode(_rangeEncoder, curByte);
					_previousByte = curByte;
					_state.UpdateChar();
				}
				else
				{
					_isMatch[complexState].Encode(_rangeEncoder, 1);
					if (pos < Base.kNumRepDistances)
					{
						_isRep[_state.Index].Encode(_rangeEncoder, 1);
						if (pos == 0)
						{
							_isRepG0[_state.Index].Encode(_rangeEncoder, 0);
							if (len == 1)
								_isRep0Long[complexState].Encode(_rangeEncoder, 0);
							else
								_isRep0Long[complexState].Encode(_rangeEncoder, 1);
						}
						else
						{
							_isRepG0[_state.Index].Encode(_rangeEncoder, 1);
							if (pos == 1)
								_isRepG1[_state.Index].Encode(_rangeEncoder, 0);
							else
							{
								_isRepG1[_state.Index].Encode(_rangeEncoder, 1);
								_isRepG2[_state.Index].Encode(_rangeEncoder, pos - 2);
							}
						}
						if (len == 1)
							_state.UpdateShortRep();
						else
						{
							_repMatchLenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
							_state.UpdateRep();
						}
						UInt32 distance = _repDistances[pos];
						if (pos != 0)
						{
							for (UInt32 i = pos; i >= 1; i--)
								_repDistances[i] = _repDistances[i - 1];
							_repDistances[0] = distance;
						}
					}
					else
					{
						_isRep[_state.Index].Encode(_rangeEncoder, 0);
						_state.UpdateMatch();
						_lenEncoder.Encode(_rangeEncoder, len - Base.kMatchMinLen, posState);
						pos -= Base.kNumRepDistances;
						UInt32 posSlot = GetPosSlot(pos);
						UInt32 lenToPosState = Base.GetLenToPosState(len);
						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder, posSlot);

						if (posSlot >= Base.kStartPosModelIndex)
						{
							int footerBits = (int)((posSlot >> 1) - 1);
							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);
							UInt32 posReduced = pos - baseVal;

							if (posSlot < Base.kEndPosModelIndex)
								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders,
										baseVal - posSlot - 1, _rangeEncoder, footerBits, posReduced);
							else
							{
								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits, footerBits - Base.kNumAlignBits);
								_posAlignEncoder.ReverseEncode(_rangeEncoder, posReduced & Base.kAlignMask);
								_alignPriceCount++;
							}
						}
						UInt32 distance = pos;
						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)
							_repDistances[i] = _repDistances[i - 1];
						_repDistances[0] = distance;
						_matchPriceCount++;
					}
					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));
				}
				_additionalOffset -= len;
				nowPos64 += len;
				if (_additionalOffset == 0)
				{
					// if (!_fastMode)
					if (_matchPriceCount >= (1 << 7))
						FillDistancesPrices();
					if (_alignPriceCount >= Base.kAlignTableSize)
						FillAlignPrices();
					inSize = nowPos64;
					outSize = _rangeEncoder.GetProcessedSizeAdd();
					if (_matchFinder.GetNumAvailableBytes() == 0)
					{
						Flush((UInt32)nowPos64);
						return;
					}

					if (nowPos64 - progressPosValuePrev >= (1 << 12))
					{
						_finished = false;
						finished = false;
						return;
					}
				}
			}
		}

		void ReleaseMFStream()
		{
			if (_matchFinder != null && _needReleaseMFStream)
			{
				_matchFinder.ReleaseStream();
				_needReleaseMFStream = false;
			}
		}

		void SetOutStream(System.IO.Stream outStream) { _rangeEncoder.SetStream(outStream); }
		void ReleaseOutStream() { _rangeEncoder.ReleaseStream(); }

		void ReleaseStreams()
		{
			ReleaseMFStream();
			ReleaseOutStream();
		}

		void SetStreams(System.IO.Stream inStream, System.IO.Stream outStream,
				Int64 inSize, Int64 outSize)
		{
			_inStream = inStream;
			_finished = false;
			Create();
			SetOutStream(outStream);
			Init();

			// if (!_fastMode)
			{
				FillDistancesPrices();
				FillAlignPrices();
			}

			_lenEncoder.SetTableSize(_numFastBytes + 1 - Base.kMatchMinLen);
			_lenEncoder.UpdateTables((UInt32)1 << _posStateBits);
			_repMatchLenEncoder.SetTableSize(_numFastBytes + 1 - Base.kMatchMinLen);
			_repMatchLenEncoder.UpdateTables((UInt32)1 << _posStateBits);

			nowPos64 = 0;
		}


		public void Code(System.IO.Stream inStream, System.IO.Stream outStream,
			Int64 inSize, Int64 outSize, ICodeProgress progress)
		{
			_needReleaseMFStream = false;
			try
			{
				SetStreams(inStream, outStream, inSize, outSize);
				while (true)
				{
					Int64 processedInSize;
					Int64 processedOutSize;
					bool finished;
					CodeOneBlock(out processedInSize, out processedOutSize, out finished);
					if (finished)
						return;
					if (progress != null)
					{
						progress.SetProgress(processedInSize, processedOutSize);
					}
				}
			}
			finally
			{
				ReleaseStreams();
			}
		}

		const int kPropSize = 5;
		Byte[] properties = new Byte[kPropSize];

		public void WriteCoderProperties(System.IO.Stream outStream)
		{
			properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
			for (int i = 0; i < 4; i++)
				properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
			outStream.Write(properties, 0, kPropSize);
		}
		
		UInt32[] tempPrices = new UInt32[Base.kNumFullDistances];
		UInt32 _matchPriceCount;

		void FillDistancesPrices()
		{
			for (UInt32 i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++)
			{ 
				UInt32 posSlot = GetPosSlot(i);
				int footerBits = (int)((posSlot >> 1) - 1);
				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);
				tempPrices[i] = BitTreeEncoder.ReverseGetPrice(_posEncoders, 
					baseVal - posSlot - 1, footerBits, i - baseVal);
			}

			for (UInt32 lenToPosState = 0; lenToPosState < Base.kNumLenToPosStates; lenToPosState++)
			{
				UInt32 posSlot;
				RangeCoder.BitTreeEncoder encoder = _posSlotEncoder[lenToPosState];
			
				UInt32 st = (lenToPosState << Base.kNumPosSlotBits);
				for (posSlot = 0; posSlot < _distTableSize; posSlot++)
					_posSlotPrices[st + posSlot] = encoder.GetPrice(posSlot);
				for (posSlot = Base.kEndPosModelIndex; posSlot < _distTableSize; posSlot++)
					_posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << RangeCoder.BitEncoder.kNumBitPriceShiftBits);

				UInt32 st2 = lenToPosState * Base.kNumFullDistances;
				UInt32 i;
				for (i = 0; i < Base.kStartPosModelIndex; i++)
					_distancesPrices[st2 + i] = _posSlotPrices[st + i];
				for (; i < Base.kNumFullDistances; i++)
					_distancesPrices[st2 + i] = _posSlotPrices[st + GetPosSlot(i)] + tempPrices[i];
			}
			_matchPriceCount = 0;
		}

		void FillAlignPrices()
		{
			for (UInt32 i = 0; i < Base.kAlignTableSize; i++)
				_alignPrices[i] = _posAlignEncoder.ReverseGetPrice(i);
			_alignPriceCount = 0;
		}


		static string[] kMatchFinderIDs = 
		{
			"BT2",
			"BT4",
		};

		static int FindMatchFinder(string s)
		{
			for (int m = 0; m < kMatchFinderIDs.Length; m++)
				if (s == kMatchFinderIDs[m])
					return m;
			return -1;
		}
	
		public void SetCoderProperties(CoderPropID[] propIDs, object[] properties)
		{
			for (UInt32 i = 0; i < properties.Length; i++)
			{
				object prop = properties[i];
				switch (propIDs[i])
				{
					case CoderPropID.NumFastBytes:
					{
						if (!(prop is Int32))
							throw new InvalidParamException();
						Int32 numFastBytes = (Int32)prop;
						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)
							throw new InvalidParamException();
						_numFastBytes = (UInt32)numFastBytes;
						break;
					}
					case CoderPropID.Algorithm:
					{
						/*
						if (!(prop is Int32))
							throw new InvalidParamException();
						Int32 maximize = (Int32)prop;
						_fastMode = (maximize == 0);
						_maxMode = (maximize >= 2);
						*/
						break;
					}
					case CoderPropID.MatchFinder:
					{
						if (!(prop is String))
							throw new InvalidParamException();
						EMatchFinderType matchFinderIndexPrev = _matchFinderType;
						int m = FindMatchFinder(((string)prop).ToUpper());
						if (m < 0)
							throw new InvalidParamException();
						_matchFinderType = (EMatchFinderType)m;
						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)
							{
							_dictionarySizePrev = 0xFFFFFFFF;
							_matchFinder = null;
							}
						break;
					}
					case CoderPropID.DictionarySize:
					{
						const int kDicLogSizeMaxCompress = 30;
						if (!(prop is Int32))
							throw new InvalidParamException(); ;
						Int32 dictionarySize = (Int32)prop;
						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||
							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))
							throw new InvalidParamException();
						_dictionarySize = (UInt32)dictionarySize;
						int dicLogSize;
						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)
							if (dictionarySize <= ((UInt32)(1) << dicLogSize))
								break;
						_distTableSize = (UInt32)dicLogSize * 2;
						break;
					}
					case CoderPropID.PosStateBits:
					{
						if (!(prop is Int32))
							throw new InvalidParamException();
						Int32 v = (Int32)prop;
						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)
							throw new InvalidParamException();
						_posStateBits = (int)v;
						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;
						break;
					}
					case CoderPropID.LitPosBits:
					{
						if (!(prop is Int32))
							throw new InvalidParamException();
						Int32 v = (Int32)prop;
						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)
							throw new InvalidParamException();
						_numLiteralPosStateBits = (int)v;
						break;
					}
					case CoderPropID.LitContextBits:
					{
						if (!(prop is Int32))
							throw new InvalidParamException();
						Int32 v = (Int32)prop;
						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)
							throw new InvalidParamException(); ;
						_numLiteralContextBits = (int)v;
						break;
					}
					case CoderPropID.EndMarker:
					{
						if (!(prop is Boolean))
							throw new InvalidParamException();
						SetWriteEndMarkerMode((Boolean)prop);
						break;
					}
					default:
						throw new InvalidParamException();
				}
			}
		}

		uint _trainSize = 0;
		public void SetTrainSize(uint trainSize)
		{
			_trainSize = trainSize;
		}
		
	}
}

```

`AssetStudio/7zip/Compress/RangeCoder/RangeCoder.cs`:

```cs
using System;

namespace SevenZip.Compression.RangeCoder
{
	class Encoder
	{
		public const uint kTopValue = (1 << 24);

		System.IO.Stream Stream;

		public UInt64 Low;
		public uint Range;
		uint _cacheSize;
		byte _cache;

		long StartPosition;

		public void SetStream(System.IO.Stream stream)
		{
			Stream = stream;
		}

		public void ReleaseStream()
		{
			Stream = null;
		}

		public void Init()
		{
			StartPosition = Stream.Position;

			Low = 0;
			Range = 0xFFFFFFFF;
			_cacheSize = 1;
			_cache = 0;
		}

		public void FlushData()
		{
			for (int i = 0; i < 5; i++)
				ShiftLow();
		}

		public void FlushStream()
		{
			Stream.Flush();
		}

		public void CloseStream()
		{
			Stream.Close();
		}

		public void Encode(uint start, uint size, uint total)
		{
			Low += start * (Range /= total);
			Range *= size;
			while (Range < kTopValue)
			{
				Range <<= 8;
				ShiftLow();
			}
		}

		public void ShiftLow()
		{
			if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)
			{
				byte temp = _cache;
				do
				{
					Stream.WriteByte((byte)(temp + (Low >> 32)));
					temp = 0xFF;
				}
				while (--_cacheSize != 0);
				_cache = (byte)(((uint)Low) >> 24);
			}
			_cacheSize++;
			Low = ((uint)Low) << 8;
		}

		public void EncodeDirectBits(uint v, int numTotalBits)
		{
			for (int i = numTotalBits - 1; i >= 0; i--)
			{
				Range >>= 1;
				if (((v >> i) & 1) == 1)
					Low += Range;
				if (Range < kTopValue)
				{
					Range <<= 8;
					ShiftLow();
				}
			}
		}

		public void EncodeBit(uint size0, int numTotalBits, uint symbol)
		{
			uint newBound = (Range >> numTotalBits) * size0;
			if (symbol == 0)
				Range = newBound;
			else
			{
				Low += newBound;
				Range -= newBound;
			}
			while (Range < kTopValue)
			{
				Range <<= 8;
				ShiftLow();
			}
		}

		public long GetProcessedSizeAdd()
		{
			return _cacheSize +
				Stream.Position - StartPosition + 4;
			// (long)Stream.GetProcessedSize();
		}
	}

	class Decoder
	{
		public const uint kTopValue = (1 << 24);
		public uint Range;
		public uint Code;
		// public Buffer.InBuffer Stream = new Buffer.InBuffer(1 << 16);
		public System.IO.Stream Stream;

		public void Init(System.IO.Stream stream)
		{
			// Stream.Init(stream);
			Stream = stream;

			Code = 0;
			Range = 0xFFFFFFFF;
			for (int i = 0; i < 5; i++)
				Code = (Code << 8) | (byte)Stream.ReadByte();
		}

		public void ReleaseStream()
		{
			// Stream.ReleaseStream();
			Stream = null;
		}

		public void CloseStream()
		{
			Stream.Close();
		}

		public void Normalize()
		{
			while (Range < kTopValue)
			{
				Code = (Code << 8) | (byte)Stream.ReadByte();
				Range <<= 8;
			}
		}

		public void Normalize2()
		{
			if (Range < kTopValue)
			{
				Code = (Code << 8) | (byte)Stream.ReadByte();
				Range <<= 8;
			}
		}

		public uint GetThreshold(uint total)
		{
			return Code / (Range /= total);
		}

		public void Decode(uint start, uint size, uint total)
		{
			Code -= start * Range;
			Range *= size;
			Normalize();
		}

		public uint DecodeDirectBits(int numTotalBits)
		{
			uint range = Range;
			uint code = Code;
			uint result = 0;
			for (int i = numTotalBits; i > 0; i--)
			{
				range >>= 1;
				/*
				result <<= 1;
				if (code >= range)
				{
					code -= range;
					result |= 1;
				}
				*/
				uint t = (code - range) >> 31;
				code -= range & (t - 1);
				result = (result << 1) | (1 - t);

				if (range < kTopValue)
				{
					code = (code << 8) | (byte)Stream.ReadByte();
					range <<= 8;
				}
			}
			Range = range;
			Code = code;
			return result;
		}

		public uint DecodeBit(uint size0, int numTotalBits)
		{
			uint newBound = (Range >> numTotalBits) * size0;
			uint symbol;
			if (Code < newBound)
			{
				symbol = 0;
				Range = newBound;
			}
			else
			{
				symbol = 1;
				Code -= newBound;
				Range -= newBound;
			}
			Normalize();
			return symbol;
		}

		// ulong GetProcessedSize() {return Stream.GetProcessedSize(); }
	}
}

```

`AssetStudio/7zip/Compress/RangeCoder/RangeCoderBit.cs`:

```cs
using System;

namespace SevenZip.Compression.RangeCoder
{
	struct BitEncoder
	{
		public const int kNumBitModelTotalBits = 11;
		public const uint kBitModelTotal = (1 << kNumBitModelTotalBits);
		const int kNumMoveBits = 5;
		const int kNumMoveReducingBits = 2;
		public const int kNumBitPriceShiftBits = 6;

		uint Prob;

		public void Init() { Prob = kBitModelTotal >> 1; }

		public void UpdateModel(uint symbol)
		{
			if (symbol == 0)
				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;
			else
				Prob -= (Prob) >> kNumMoveBits;
		}

		public void Encode(Encoder encoder, uint symbol)
		{
			// encoder.EncodeBit(Prob, kNumBitModelTotalBits, symbol);
			// UpdateModel(symbol);
			uint newBound = (encoder.Range >> kNumBitModelTotalBits) * Prob;
			if (symbol == 0)
			{
				encoder.Range = newBound;
				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;
			}
			else
			{
				encoder.Low += newBound;
				encoder.Range -= newBound;
				Prob -= (Prob) >> kNumMoveBits;
			}
			if (encoder.Range < Encoder.kTopValue)
			{
				encoder.Range <<= 8;
				encoder.ShiftLow();
			}
		}

		private static UInt32[] ProbPrices = new UInt32[kBitModelTotal >> kNumMoveReducingBits];

		static BitEncoder()
		{
			const int kNumBits = (kNumBitModelTotalBits - kNumMoveReducingBits);
			for (int i = kNumBits - 1; i >= 0; i--)
			{
				UInt32 start = (UInt32)1 << (kNumBits - i - 1);
				UInt32 end = (UInt32)1 << (kNumBits - i);
				for (UInt32 j = start; j < end; j++)
					ProbPrices[j] = ((UInt32)i << kNumBitPriceShiftBits) +
						(((end - j) << kNumBitPriceShiftBits) >> (kNumBits - i - 1));
			}
		}

		public uint GetPrice(uint symbol)
		{
			return ProbPrices[(((Prob - symbol) ^ ((-(int)symbol))) & (kBitModelTotal - 1)) >> kNumMoveReducingBits];
		}
	  public uint GetPrice0() { return ProbPrices[Prob >> kNumMoveReducingBits]; }
		public uint GetPrice1() { return ProbPrices[(kBitModelTotal - Prob) >> kNumMoveReducingBits]; }
	}

	struct BitDecoder
	{
		public const int kNumBitModelTotalBits = 11;
		public const uint kBitModelTotal = (1 << kNumBitModelTotalBits);
		const int kNumMoveBits = 5;

		uint Prob;

		public void UpdateModel(int numMoveBits, uint symbol)
		{
			if (symbol == 0)
				Prob += (kBitModelTotal - Prob) >> numMoveBits;
			else
				Prob -= (Prob) >> numMoveBits;
		}

		public void Init() { Prob = kBitModelTotal >> 1; }

		public uint Decode(RangeCoder.Decoder rangeDecoder)
		{
			uint newBound = (uint)(rangeDecoder.Range >> kNumBitModelTotalBits) * (uint)Prob;
			if (rangeDecoder.Code < newBound)
			{
				rangeDecoder.Range = newBound;
				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;
				if (rangeDecoder.Range < Decoder.kTopValue)
				{
					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
					rangeDecoder.Range <<= 8;
				}
				return 0;
			}
			else
			{
				rangeDecoder.Range -= newBound;
				rangeDecoder.Code -= newBound;
				Prob -= (Prob) >> kNumMoveBits;
				if (rangeDecoder.Range < Decoder.kTopValue)
				{
					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
					rangeDecoder.Range <<= 8;
				}
				return 1;
			}
		}
	}
}

```

`AssetStudio/7zip/Compress/RangeCoder/RangeCoderBitTree.cs`:

```cs
using System;

namespace SevenZip.Compression.RangeCoder
{
	struct BitTreeEncoder
	{
		BitEncoder[] Models;
		int NumBitLevels;

		public BitTreeEncoder(int numBitLevels)
		{
			NumBitLevels = numBitLevels;
			Models = new BitEncoder[1 << numBitLevels];
		}

		public void Init()
		{
			for (uint i = 1; i < (1 << NumBitLevels); i++)
				Models[i].Init();
		}

		public void Encode(Encoder rangeEncoder, UInt32 symbol)
		{
			UInt32 m = 1;
			for (int bitIndex = NumBitLevels; bitIndex > 0; )
			{
				bitIndex--;
				UInt32 bit = (symbol >> bitIndex) & 1;
				Models[m].Encode(rangeEncoder, bit);
				m = (m << 1) | bit;
			}
		}

		public void ReverseEncode(Encoder rangeEncoder, UInt32 symbol)
		{
			UInt32 m = 1;
			for (UInt32 i = 0; i < NumBitLevels; i++)
			{
				UInt32 bit = symbol & 1;
				Models[m].Encode(rangeEncoder, bit);
				m = (m << 1) | bit;
				symbol >>= 1;
			}
		}

		public UInt32 GetPrice(UInt32 symbol)
		{
			UInt32 price = 0;
			UInt32 m = 1;
			for (int bitIndex = NumBitLevels; bitIndex > 0; )
			{
				bitIndex--;
				UInt32 bit = (symbol >> bitIndex) & 1;
				price += Models[m].GetPrice(bit);
				m = (m << 1) + bit;
			}
			return price;
		}

		public UInt32 ReverseGetPrice(UInt32 symbol)
		{
			UInt32 price = 0;
			UInt32 m = 1;
			for (int i = NumBitLevels; i > 0; i--)
			{
				UInt32 bit = symbol & 1;
				symbol >>= 1;
				price += Models[m].GetPrice(bit);
				m = (m << 1) | bit;
			}
			return price;
		}

		public static UInt32 ReverseGetPrice(BitEncoder[] Models, UInt32 startIndex,
			int NumBitLevels, UInt32 symbol)
		{
			UInt32 price = 0;
			UInt32 m = 1;
			for (int i = NumBitLevels; i > 0; i--)
			{
				UInt32 bit = symbol & 1;
				symbol >>= 1;
				price += Models[startIndex + m].GetPrice(bit);
				m = (m << 1) | bit;
			}
			return price;
		}

		public static void ReverseEncode(BitEncoder[] Models, UInt32 startIndex,
			Encoder rangeEncoder, int NumBitLevels, UInt32 symbol)
		{
			UInt32 m = 1;
			for (int i = 0; i < NumBitLevels; i++)
			{
				UInt32 bit = symbol & 1;
				Models[startIndex + m].Encode(rangeEncoder, bit);
				m = (m << 1) | bit;
				symbol >>= 1;
			}
		}
	}

	struct BitTreeDecoder
	{
		BitDecoder[] Models;
		int NumBitLevels;

		public BitTreeDecoder(int numBitLevels)
		{
			NumBitLevels = numBitLevels;
			Models = new BitDecoder[1 << numBitLevels];
		}

		public void Init()
		{
			for (uint i = 1; i < (1 << NumBitLevels); i++)
				Models[i].Init();
		}

		public uint Decode(RangeCoder.Decoder rangeDecoder)
		{
			uint m = 1;
			for (int bitIndex = NumBitLevels; bitIndex > 0; bitIndex--)
				m = (m << 1) + Models[m].Decode(rangeDecoder);
			return m - ((uint)1 << NumBitLevels);
		}

		public uint ReverseDecode(RangeCoder.Decoder rangeDecoder)
		{
			uint m = 1;
			uint symbol = 0;
			for (int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++)
			{
				uint bit = Models[m].Decode(rangeDecoder);
				m <<= 1;
				m += bit;
				symbol |= (bit << bitIndex);
			}
			return symbol;
		}

		public static uint ReverseDecode(BitDecoder[] Models, UInt32 startIndex,
			RangeCoder.Decoder rangeDecoder, int NumBitLevels)
		{
			uint m = 1;
			uint symbol = 0;
			for (int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++)
			{
				uint bit = Models[startIndex + m].Decode(rangeDecoder);
				m <<= 1;
				m += bit;
				symbol |= (bit << bitIndex);
			}
			return symbol;
		}
	}
}

```

`AssetStudio/7zip/ICoder.cs`:

```cs
// ICoder.h

using System;

namespace SevenZip
{
	/// <summary>
	/// The exception that is thrown when an error in input stream occurs during decoding.
	/// </summary>
	class DataErrorException : ApplicationException
	{
		public DataErrorException(): base("Data Error") { }
	}

	/// <summary>
	/// The exception that is thrown when the value of an argument is outside the allowable range.
	/// </summary>
	class InvalidParamException : ApplicationException
	{
		public InvalidParamException(): base("Invalid Parameter") { }
	}

	public interface ICodeProgress
	{
		/// <summary>
		/// Callback progress.
		/// </summary>
		/// <param name="inSize">
		/// input size. -1 if unknown.
		/// </param>
		/// <param name="outSize">
		/// output size. -1 if unknown.
		/// </param>
		void SetProgress(Int64 inSize, Int64 outSize);
	};

	public interface ICoder
	{
		/// <summary>
		/// Codes streams.
		/// </summary>
		/// <param name="inStream">
		/// input Stream.
		/// </param>
		/// <param name="outStream">
		/// output Stream.
		/// </param>
		/// <param name="inSize">
		/// input Size. -1 if unknown.
		/// </param>
		/// <param name="outSize">
		/// output Size. -1 if unknown.
		/// </param>
		/// <param name="progress">
		/// callback progress reference.
		/// </param>
		/// <exception cref="SevenZip.DataErrorException">
		/// if input stream is not valid
		/// </exception>
		void Code(System.IO.Stream inStream, System.IO.Stream outStream,
			Int64 inSize, Int64 outSize, ICodeProgress progress);
	};

	/*
	public interface ICoder2
	{
		 void Code(ISequentialInStream []inStreams,
				const UInt64 []inSizes, 
				ISequentialOutStream []outStreams, 
				UInt64 []outSizes,
				ICodeProgress progress);
	};
  */

	/// <summary>
	/// Provides the fields that represent properties idenitifiers for compressing.
	/// </summary>
	public enum CoderPropID
	{
		/// <summary>
		/// Specifies default property.
		/// </summary>
		DefaultProp = 0,
		/// <summary>
		/// Specifies size of dictionary.
		/// </summary>
		DictionarySize,
		/// <summary>
		/// Specifies size of memory for PPM*.
		/// </summary>
		UsedMemorySize,
		/// <summary>
		/// Specifies order for PPM methods.
		/// </summary>
		Order,
		/// <summary>
		/// Specifies Block Size.
		/// </summary>
		BlockSize,
		/// <summary>
		/// Specifies number of postion state bits for LZMA (0 <= x <= 4).
		/// </summary>
		PosStateBits,
		/// <summary>
		/// Specifies number of literal context bits for LZMA (0 <= x <= 8).
		/// </summary>
		LitContextBits,
		/// <summary>
		/// Specifies number of literal position bits for LZMA (0 <= x <= 4).
		/// </summary>
		LitPosBits,
		/// <summary>
		/// Specifies number of fast bytes for LZ*.
		/// </summary>
		NumFastBytes,
		/// <summary>
		/// Specifies match finder. LZMA: "BT2", "BT4" or "BT4B".
		/// </summary>
		MatchFinder,
		/// <summary>
		/// Specifies the number of match finder cyckes.
		/// </summary>
		MatchFinderCycles,
		/// <summary>
		/// Specifies number of passes.
		/// </summary>
		NumPasses,
		/// <summary>
		/// Specifies number of algorithm.
		/// </summary>
		Algorithm,
		/// <summary>
		/// Specifies the number of threads.
		/// </summary>
		NumThreads,
		/// <summary>
		/// Specifies mode with end marker.
		/// </summary>
		EndMarker
	};


	public interface ISetCoderProperties
	{
		void SetCoderProperties(CoderPropID[] propIDs, object[] properties);
	};

	public interface IWriteCoderProperties
	{
		void WriteCoderProperties(System.IO.Stream outStream);
	}

	public interface ISetDecoderProperties
	{
		void SetDecoderProperties(byte[] properties);
	}
}

```

`AssetStudio/AssetStudio.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net472;netstandard2.0;net5.0;net6.0</TargetFrameworks>
    <Version>0.16.0.0</Version>
    <AssemblyVersion>0.16.0.0</AssemblyVersion>
    <FileVersion>0.16.0.0</FileVersion>
    <Copyright>Copyright © Perfare 2018-2022</Copyright>
    <DebugType>embedded</DebugType>
  </PropertyGroup>

  <ItemGroup Condition=" '$(TargetFramework)' != 'net472' ">
    <PackageReference Include="K4os.Compression.LZ4" Version="1.2.16" />
  </ItemGroup>

  <ItemGroup Condition=" '$(TargetFramework)' == 'net472' ">
    <PackageReference Include="System.Memory" Version="4.5.4" />
    <PackageReference Include="System.IO.Compression" Version="4.0.0" />
    <PackageReference Include="K4os.Compression.LZ4" Version="1.1.11" />
  </ItemGroup>

</Project>

```

`AssetStudio/AssetsManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using static AssetStudio.ImportHelper;

namespace AssetStudio
{
    public class AssetsManager
    {
        public string SpecifyUnityVersion;
        public List<SerializedFile> assetsFileList = new List<SerializedFile>();

        internal Dictionary<string, int> assetsFileIndexCache = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        internal Dictionary<string, BinaryReader> resourceFileReaders = new Dictionary<string, BinaryReader>(StringComparer.OrdinalIgnoreCase);

        private List<string> importFiles = new List<string>();
        private HashSet<string> importFilesHash = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        private HashSet<string> noexistFiles = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        private HashSet<string> assetsFileListHash = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        public void LoadFiles(params string[] files)
        {
            var path = Path.GetDirectoryName(Path.GetFullPath(files[0]));
            MergeSplitAssets(path);
            var toReadFile = ProcessingSplitFiles(files.ToList());
            Load(toReadFile);
        }

        public void LoadFolder(string path)
        {
            MergeSplitAssets(path, true);
            var files = Directory.GetFiles(path, "*.*", SearchOption.AllDirectories).ToList();
            var toReadFile = ProcessingSplitFiles(files);
            Load(toReadFile);
        }

        private void Load(string[] files)
        {
            foreach (var file in files)
            {
                importFiles.Add(file);
                importFilesHash.Add(Path.GetFileName(file));
            }

            Progress.Reset();
            //use a for loop because list size can change
            for (var i = 0; i < importFiles.Count; i++)
            {
                LoadFile(importFiles[i]);
                Progress.Report(i + 1, importFiles.Count);
            }

            importFiles.Clear();
            importFilesHash.Clear();
            noexistFiles.Clear();
            assetsFileListHash.Clear();

            ReadAssets();
            ProcessAssets();
        }

        private void LoadFile(string fullName)
        {
            var reader = new FileReader(fullName);
            LoadFile(reader);
        }

        private void LoadFile(FileReader reader)
        {
            switch (reader.FileType)
            {
                case FileType.AssetsFile:
                    LoadAssetsFile(reader);
                    break;
                case FileType.BundleFile:
                    LoadBundleFile(reader);
                    break;
                case FileType.WebFile:
                    LoadWebFile(reader);
                    break;
                case FileType.GZipFile:
                    LoadFile(DecompressGZip(reader));
                    break;
                case FileType.BrotliFile:
                    LoadFile(DecompressBrotli(reader));
                    break;
                case FileType.ZipFile:
                    LoadZipFile(reader);
                    break;
            }
        }

        private void LoadAssetsFile(FileReader reader)
        {
            if (!assetsFileListHash.Contains(reader.FileName))
            {
                Logger.Info($"Loading {reader.FullPath}");
                try
                {
                    var assetsFile = new SerializedFile(reader, this);
                    CheckStrippedVersion(assetsFile);
                    assetsFileList.Add(assetsFile);
                    assetsFileListHash.Add(assetsFile.fileName);

                    foreach (var sharedFile in assetsFile.m_Externals)
                    {
                        var sharedFileName = sharedFile.fileName;

                        if (!importFilesHash.Contains(sharedFileName))
                        {
                            var sharedFilePath = Path.Combine(Path.GetDirectoryName(reader.FullPath), sharedFileName);
                            if (!noexistFiles.Contains(sharedFilePath))
                            {
                                if (!File.Exists(sharedFilePath))
                                {
                                    var findFiles = Directory.GetFiles(Path.GetDirectoryName(reader.FullPath), sharedFileName, SearchOption.AllDirectories);
                                    if (findFiles.Length > 0)
                                    {
                                        sharedFilePath = findFiles[0];
                                    }
                                }
                                if (File.Exists(sharedFilePath))
                                {
                                    importFiles.Add(sharedFilePath);
                                    importFilesHash.Add(sharedFileName);
                                }
                                else
                                {
                                    noexistFiles.Add(sharedFilePath);
                                }
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    Logger.Error($"Error while reading assets file {reader.FullPath}", e);
                    reader.Dispose();
                }
            }
            else
            {
                Logger.Info($"Skipping {reader.FullPath}");
                reader.Dispose();
            }
        }

        private void LoadAssetsFromMemory(FileReader reader, string originalPath, string unityVersion = null)
        {
            if (!assetsFileListHash.Contains(reader.FileName))
            {
                try
                {
                    var assetsFile = new SerializedFile(reader, this);
                    assetsFile.originalPath = originalPath;
                    if (!string.IsNullOrEmpty(unityVersion) && assetsFile.header.m_Version < SerializedFileFormatVersion.Unknown_7)
                    {
                        assetsFile.SetVersion(unityVersion);
                    }
                    CheckStrippedVersion(assetsFile);
                    assetsFileList.Add(assetsFile);
                    assetsFileListHash.Add(assetsFile.fileName);
                }
                catch (Exception e)
                {
                    Logger.Error($"Error while reading assets file {reader.FullPath} from {Path.GetFileName(originalPath)}", e);
                    resourceFileReaders.Add(reader.FileName, reader);
                }
            }
            else
                Logger.Info($"Skipping {originalPath} ({reader.FileName})");
        }

        private void LoadBundleFile(FileReader reader, string originalPath = null)
        {
            Logger.Info("Loading " + reader.FullPath);
            try
            {
                var bundleFile = new BundleFile(reader);
                foreach (var file in bundleFile.fileList)
                {
                    var dummyPath = Path.Combine(Path.GetDirectoryName(reader.FullPath), file.fileName);
                    var subReader = new FileReader(dummyPath, file.stream);
                    if (subReader.FileType == FileType.AssetsFile)
                    {
                        LoadAssetsFromMemory(subReader, originalPath ?? reader.FullPath, bundleFile.m_Header.unityRevision);
                    }
                    else
                    {
                        resourceFileReaders[file.fileName] = subReader; //TODO
                    }
                }
            }
            catch (Exception e)
            {
                var str = $"Error while reading bundle file {reader.FullPath}";
                if (originalPath != null)
                {
                    str += $" from {Path.GetFileName(originalPath)}";
                }
                Logger.Error(str, e);
            }
            finally
            {
                reader.Dispose();
            }
        }

        private void LoadWebFile(FileReader reader)
        {
            Logger.Info("Loading " + reader.FullPath);
            try
            {
                var webFile = new WebFile(reader);
                foreach (var file in webFile.fileList)
                {
                    var dummyPath = Path.Combine(Path.GetDirectoryName(reader.FullPath), file.fileName);
                    var subReader = new FileReader(dummyPath, file.stream);
                    switch (subReader.FileType)
                    {
                        case FileType.AssetsFile:
                            LoadAssetsFromMemory(subReader, reader.FullPath);
                            break;
                        case FileType.BundleFile:
                            LoadBundleFile(subReader, reader.FullPath);
                            break;
                        case FileType.WebFile:
                            LoadWebFile(subReader);
                            break;
                        case FileType.ResourceFile:
                            resourceFileReaders[file.fileName] = subReader; //TODO
                            break;
                    }
                }
            }
            catch (Exception e)
            {
                Logger.Error($"Error while reading web file {reader.FullPath}", e);
            }
            finally
            {
                reader.Dispose();
            }
        }

        private void LoadZipFile(FileReader reader)
        {
            Logger.Info("Loading " + reader.FileName);
            try
            {
                using (ZipArchive archive = new ZipArchive(reader.BaseStream, ZipArchiveMode.Read))
                {
                    List<string> splitFiles = new List<string>();
                    // register all files before parsing the assets so that the external references can be found
                    // and find split files
                    foreach (ZipArchiveEntry entry in archive.Entries)
                    {
                        if (entry.Name.Contains(".split"))
                        {
                            string baseName = Path.GetFileNameWithoutExtension(entry.Name);
                            string basePath = Path.Combine(Path.GetDirectoryName(entry.FullName), baseName);
                            if (!splitFiles.Contains(basePath))
                            {
                                splitFiles.Add(basePath);
                                importFilesHash.Add(baseName);
                            }
                        }
                        else
                        {
                            importFilesHash.Add(entry.Name);
                        }
                    }

                    // merge split files and load the result
                    foreach (string basePath in splitFiles)
                    {
                        try
                        {
                            Stream splitStream = new MemoryStream();
                            int i = 0;
                            while (true)
                            {
                                string path = $"{basePath}.split{i++}";
                                ZipArchiveEntry entry = archive.GetEntry(path);
                                if (entry == null)
                                    break;
                                using (Stream entryStream = entry.Open())
                                {
                                    entryStream.CopyTo(splitStream);
                                }
                            }
                            splitStream.Seek(0, SeekOrigin.Begin);
                            FileReader entryReader = new FileReader(basePath, splitStream);
                            LoadFile(entryReader);
                        }
                        catch (Exception e)
                        {
                            Logger.Error($"Error while reading zip split file {basePath}", e);
                        }
                    }

                    // load all entries
                    foreach (ZipArchiveEntry entry in archive.Entries)
                    {
                        try
                        {
                            string dummyPath = Path.Combine(Path.GetDirectoryName(reader.FullPath), reader.FileName, entry.FullName);
                            // create a new stream
                            // - to store the deflated stream in
                            // - to keep the data for later extraction
                            Stream streamReader = new MemoryStream();
                            using (Stream entryStream = entry.Open())
                            {
                                entryStream.CopyTo(streamReader);
                            }
                            streamReader.Position = 0;

                            FileReader entryReader = new FileReader(dummyPath, streamReader);
                            LoadFile(entryReader);
                            if (entryReader.FileType == FileType.ResourceFile)
                            {
                                entryReader.Position = 0;
                                if (!resourceFileReaders.ContainsKey(entry.Name))
                                {
                                    resourceFileReaders.Add(entry.Name, entryReader);
                                }
                            }
                        }
                        catch (Exception e)
                        {
                            Logger.Error($"Error while reading zip entry {entry.FullName}", e);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Logger.Error($"Error while reading zip file {reader.FileName}", e);
            }
            finally
            {
                reader.Dispose();
            }
        }

        public void CheckStrippedVersion(SerializedFile assetsFile)
        {
            if (assetsFile.IsVersionStripped && string.IsNullOrEmpty(SpecifyUnityVersion))
            {
                throw new Exception("The Unity version has been stripped, please set the version in the options");
            }
            if (!string.IsNullOrEmpty(SpecifyUnityVersion))
            {
                assetsFile.SetVersion(SpecifyUnityVersion);
            }
        }

        public void Clear()
        {
            foreach (var assetsFile in assetsFileList)
            {
                assetsFile.Objects.Clear();
                assetsFile.reader.Close();
            }
            assetsFileList.Clear();

            foreach (var resourceFileReader in resourceFileReaders)
            {
                resourceFileReader.Value.Close();
            }
            resourceFileReaders.Clear();

            assetsFileIndexCache.Clear();
        }

        private void ReadAssets()
        {
            Logger.Info("Read assets...");

            var progressCount = assetsFileList.Sum(x => x.m_Objects.Count);
            int i = 0;
            Progress.Reset();
            foreach (var assetsFile in assetsFileList)
            {
                foreach (var objectInfo in assetsFile.m_Objects)
                {
                    var objectReader = new ObjectReader(assetsFile.reader, assetsFile, objectInfo);
                    try
                    {
                        Object obj;
                        switch (objectReader.type)
                        {
                            case ClassIDType.Animation:
                                obj = new Animation(objectReader);
                                break;
                            case ClassIDType.AnimationClip:
                                obj = new AnimationClip(objectReader);
                                break;
                            case ClassIDType.Animator:
                                obj = new Animator(objectReader);
                                break;
                            case ClassIDType.AnimatorController:
                                obj = new AnimatorController(objectReader);
                                break;
                            case ClassIDType.AnimatorOverrideController:
                                obj = new AnimatorOverrideController(objectReader);
                                break;
                            case ClassIDType.AssetBundle:
                                obj = new AssetBundle(objectReader);
                                break;
                            case ClassIDType.AudioClip:
                                obj = new AudioClip(objectReader);
                                break;
                            case ClassIDType.Avatar:
                                obj = new Avatar(objectReader);
                                break;
                            case ClassIDType.Font:
                                obj = new Font(objectReader);
                                break;
                            case ClassIDType.GameObject:
                                obj = new GameObject(objectReader);
                                break;
                            case ClassIDType.Material:
                                obj = new Material(objectReader);
                                break;
                            case ClassIDType.Mesh:
                                obj = new Mesh(objectReader);
                                break;
                            case ClassIDType.MeshFilter:
                                obj = new MeshFilter(objectReader);
                                break;
                            case ClassIDType.MeshRenderer:
                                obj = new MeshRenderer(objectReader);
                                break;
                            case ClassIDType.MonoBehaviour:
                                obj = new MonoBehaviour(objectReader);
                                break;
                            case ClassIDType.MonoScript:
                                obj = new MonoScript(objectReader);
                                break;
                            case ClassIDType.MovieTexture:
                                obj = new MovieTexture(objectReader);
                                break;
                            case ClassIDType.PlayerSettings:
                                obj = new PlayerSettings(objectReader);
                                break;
                            case ClassIDType.RectTransform:
                                obj = new RectTransform(objectReader);
                                break;
                            case ClassIDType.Shader:
                                obj = new Shader(objectReader);
                                break;
                            case ClassIDType.SkinnedMeshRenderer:
                                obj = new SkinnedMeshRenderer(objectReader);
                                break;
                            case ClassIDType.Sprite:
                                obj = new Sprite(objectReader);
                                break;
                            case ClassIDType.SpriteAtlas:
                                obj = new SpriteAtlas(objectReader);
                                break;
                            case ClassIDType.TextAsset:
                                obj = new TextAsset(objectReader);
                                break;
                            case ClassIDType.Texture2D:
                                obj = new Texture2D(objectReader);
                                break;
                            case ClassIDType.Transform:
                                obj = new Transform(objectReader);
                                break;
                            case ClassIDType.VideoClip:
                                obj = new VideoClip(objectReader);
                                break;
                            case ClassIDType.ResourceManager:
                                obj = new ResourceManager(objectReader);
                                break;
                            default:
                                obj = new Object(objectReader);
                                break;
                        }
                        assetsFile.AddObject(obj);
                    }
                    catch (Exception e)
                    {
                        var sb = new StringBuilder();
                        sb.AppendLine("Unable to load object")
                            .AppendLine($"Assets {assetsFile.fileName}")
                            .AppendLine($"Path {assetsFile.originalPath}")
                            .AppendLine($"Type {objectReader.type}")
                            .AppendLine($"PathID {objectInfo.m_PathID}")
                            .Append(e);
                        Logger.Error(sb.ToString());
                    }

                    Progress.Report(++i, progressCount);
                }
            }
        }

        private void ProcessAssets()
        {
            Logger.Info("Process Assets...");

            foreach (var assetsFile in assetsFileList)
            {
                foreach (var obj in assetsFile.Objects)
                {
                    if (obj is GameObject m_GameObject)
                    {
                        foreach (var pptr in m_GameObject.m_Components)
                        {
                            if (pptr.TryGet(out var m_Component))
                            {
                                switch (m_Component)
                                {
                                    case Transform m_Transform:
                                        m_GameObject.m_Transform = m_Transform;
                                        break;
                                    case MeshRenderer m_MeshRenderer:
                                        m_GameObject.m_MeshRenderer = m_MeshRenderer;
                                        break;
                                    case MeshFilter m_MeshFilter:
                                        m_GameObject.m_MeshFilter = m_MeshFilter;
                                        break;
                                    case SkinnedMeshRenderer m_SkinnedMeshRenderer:
                                        m_GameObject.m_SkinnedMeshRenderer = m_SkinnedMeshRenderer;
                                        break;
                                    case Animator m_Animator:
                                        m_GameObject.m_Animator = m_Animator;
                                        break;
                                    case Animation m_Animation:
                                        m_GameObject.m_Animation = m_Animation;
                                        break;
                                }
                            }
                        }
                    }
                    else if (obj is SpriteAtlas m_SpriteAtlas)
                    {
                        foreach (var m_PackedSprite in m_SpriteAtlas.m_PackedSprites)
                        {
                            if (m_PackedSprite.TryGet(out var m_Sprite))
                            {
                                if (m_Sprite.m_SpriteAtlas.IsNull)
                                {
                                    m_Sprite.m_SpriteAtlas.Set(m_SpriteAtlas);
                                }
                                else
                                {
                                    m_Sprite.m_SpriteAtlas.TryGet(out var m_SpriteAtlaOld);
                                    if (m_SpriteAtlaOld.m_IsVariant)
                                    {
                                        m_Sprite.m_SpriteAtlas.Set(m_SpriteAtlas);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

```

`AssetStudio/BigArrayPool.cs`:

```cs
using System.Buffers;

namespace AssetStudio
{
    public static class BigArrayPool<T>
    {
        private static readonly ArrayPool<T> s_shared = ArrayPool<T>.Create(64 * 1024 * 1024, 3);
        public static ArrayPool<T> Shared => s_shared;
    }
}

```

`AssetStudio/Brotli/BitReader.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>Bit reading helpers.</summary>
	internal sealed class BitReader
	{
		/// <summary>
		/// Input byte buffer, consist of a ring-buffer and a "slack" region where bytes from the start of
		/// the ring-buffer are copied.
		/// </summary>
		private const int Capacity = 1024;

		private const int Slack = 16;

		private const int IntBufferSize = Capacity + Slack;

		private const int ByteReadSize = Capacity << 2;

		private const int ByteBufferSize = IntBufferSize << 2;

		private readonly byte[] byteBuffer = new byte[ByteBufferSize];

		private readonly int[] intBuffer = new int[IntBufferSize];

		private readonly Org.Brotli.Dec.IntReader intReader = new Org.Brotli.Dec.IntReader();

		private System.IO.Stream input;

		/// <summary>Input stream is finished.</summary>
		private bool endOfStreamReached;

		/// <summary>Pre-fetched bits.</summary>
		internal long accumulator;

		/// <summary>Current bit-reading position in accumulator.</summary>
		internal int bitOffset;

		/// <summary>Offset of next item in intBuffer.</summary>
		private int intOffset;

		private int tailBytes = 0;

		/* Number of bytes in unfinished "int" item. */
		/// <summary>Fills up the input buffer.</summary>
		/// <remarks>
		/// Fills up the input buffer.
		/// <p> No-op if there are at least 36 bytes present after current position.
		/// <p> After encountering the end of the input stream, 64 additional zero bytes are copied to the
		/// buffer.
		/// </remarks>
		internal static void ReadMoreInput(Org.Brotli.Dec.BitReader br)
		{
			// TODO: Split to check and read; move read outside of decoding loop.
			if (br.intOffset <= Capacity - 9)
			{
				return;
			}
			if (br.endOfStreamReached)
			{
				if (IntAvailable(br) >= -2)
				{
					return;
				}
				throw new Org.Brotli.Dec.BrotliRuntimeException("No more input");
			}
			int readOffset = br.intOffset << 2;
			int bytesRead = ByteReadSize - readOffset;
			System.Array.Copy(br.byteBuffer, readOffset, br.byteBuffer, 0, bytesRead);
			br.intOffset = 0;
			try
			{
				while (bytesRead < ByteReadSize)
				{
					int len = br.input.Read(br.byteBuffer, bytesRead, ByteReadSize - bytesRead);
					// EOF is -1 in Java, but 0 in C#.
					if (len <= 0)
					{
						br.endOfStreamReached = true;
						br.tailBytes = bytesRead;
						bytesRead += 3;
						break;
					}
					bytesRead += len;
				}
			}
			catch (System.IO.IOException e)
			{
				throw new Org.Brotli.Dec.BrotliRuntimeException("Failed to read input", e);
			}
			Org.Brotli.Dec.IntReader.Convert(br.intReader, bytesRead >> 2);
		}

		internal static void CheckHealth(Org.Brotli.Dec.BitReader br, bool endOfStream)
		{
			if (!br.endOfStreamReached)
			{
				return;
			}
			int byteOffset = (br.intOffset << 2) + ((br.bitOffset + 7) >> 3) - 8;
			if (byteOffset > br.tailBytes)
			{
				throw new Org.Brotli.Dec.BrotliRuntimeException("Read after end");
			}
			if (endOfStream && (byteOffset != br.tailBytes))
			{
				throw new Org.Brotli.Dec.BrotliRuntimeException("Unused bytes after end");
			}
		}

		/// <summary>Advances the Read buffer by 5 bytes to make room for reading next 24 bits.</summary>
		internal static void FillBitWindow(Org.Brotli.Dec.BitReader br)
		{
			if (br.bitOffset >= 32)
			{
				br.accumulator = ((long)br.intBuffer[br.intOffset++] << 32) | ((long)(((ulong)br.accumulator) >> 32));
				br.bitOffset -= 32;
			}
		}

		/// <summary>Reads the specified number of bits from Read Buffer.</summary>
		internal static int ReadBits(Org.Brotli.Dec.BitReader br, int n)
		{
			FillBitWindow(br);
			int val = (int)((long)(((ulong)br.accumulator) >> br.bitOffset)) & ((1 << n) - 1);
			br.bitOffset += n;
			return val;
		}

		/// <summary>Initialize bit reader.</summary>
		/// <remarks>
		/// Initialize bit reader.
		/// <p> Initialisation turns bit reader to a ready state. Also a number of bytes is prefetched to
		/// accumulator. Because of that this method may block until enough data could be read from input.
		/// </remarks>
		/// <param name="br">BitReader POJO</param>
		/// <param name="input">data source</param>
		internal static void Init(Org.Brotli.Dec.BitReader br, System.IO.Stream input)
		{
			if (br.input != null)
			{
				throw new System.InvalidOperationException("Bit reader already has associated input stream");
			}
			Org.Brotli.Dec.IntReader.Init(br.intReader, br.byteBuffer, br.intBuffer);
			br.input = input;
			br.accumulator = 0;
			br.bitOffset = 64;
			br.intOffset = Capacity;
			br.endOfStreamReached = false;
			Prepare(br);
		}

		private static void Prepare(Org.Brotli.Dec.BitReader br)
		{
			ReadMoreInput(br);
			CheckHealth(br, false);
			FillBitWindow(br);
			FillBitWindow(br);
		}

		internal static void Reload(Org.Brotli.Dec.BitReader br)
		{
			if (br.bitOffset == 64)
			{
				Prepare(br);
			}
		}

		/// <exception cref="System.IO.IOException"/>
		internal static void Close(Org.Brotli.Dec.BitReader br)
		{
			System.IO.Stream @is = br.input;
			br.input = null;
			if (@is != null)
			{
				@is.Close();
			}
		}

		internal static void JumpToByteBoundary(Org.Brotli.Dec.BitReader br)
		{
			int padding = (64 - br.bitOffset) & 7;
			if (padding != 0)
			{
				int paddingBits = Org.Brotli.Dec.BitReader.ReadBits(br, padding);
				if (paddingBits != 0)
				{
					throw new Org.Brotli.Dec.BrotliRuntimeException("Corrupted padding bits");
				}
			}
		}

		internal static int IntAvailable(Org.Brotli.Dec.BitReader br)
		{
			int limit = Capacity;
			if (br.endOfStreamReached)
			{
				limit = (br.tailBytes + 3) >> 2;
			}
			return limit - br.intOffset;
		}

		internal static void CopyBytes(Org.Brotli.Dec.BitReader br, byte[] data, int offset, int length)
		{
			if ((br.bitOffset & 7) != 0)
			{
				throw new Org.Brotli.Dec.BrotliRuntimeException("Unaligned copyBytes");
			}
			// Drain accumulator.
			while ((br.bitOffset != 64) && (length != 0))
			{
				data[offset++] = unchecked((byte)((long)(((ulong)br.accumulator) >> br.bitOffset)));
				br.bitOffset += 8;
				length--;
			}
			if (length == 0)
			{
				return;
			}
			// Get data from shadow buffer with "sizeof(int)" granularity.
			int copyInts = System.Math.Min(IntAvailable(br), length >> 2);
			if (copyInts > 0)
			{
				int readOffset = br.intOffset << 2;
				System.Array.Copy(br.byteBuffer, readOffset, data, offset, copyInts << 2);
				offset += copyInts << 2;
				length -= copyInts << 2;
				br.intOffset += copyInts;
			}
			if (length == 0)
			{
				return;
			}
			// Read tail bytes.
			if (IntAvailable(br) > 0)
			{
				// length = 1..3
				FillBitWindow(br);
				while (length != 0)
				{
					data[offset++] = unchecked((byte)((long)(((ulong)br.accumulator) >> br.bitOffset)));
					br.bitOffset += 8;
					length--;
				}
				CheckHealth(br, false);
				return;
			}
			// Now it is possible to copy bytes directly.
			try
			{
				while (length > 0)
				{
					int len = br.input.Read(data, offset, length);
					if (len == -1)
					{
						throw new Org.Brotli.Dec.BrotliRuntimeException("Unexpected end of input");
					}
					offset += len;
					length -= len;
				}
			}
			catch (System.IO.IOException e)
			{
				throw new Org.Brotli.Dec.BrotliRuntimeException("Failed to read input", e);
			}
		}
	}
}

```

`AssetStudio/Brotli/BrotliInputStream.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>
	/// <see cref="System.IO.Stream"/>
	/// decorator that decompresses brotli data.
	/// <p> Not thread-safe.
	/// </summary>
	public class BrotliInputStream : System.IO.Stream
	{
		public const int DefaultInternalBufferSize = 16384;

		/// <summary>Internal buffer used for efficient byte-by-byte reading.</summary>
		private byte[] buffer;

		/// <summary>Number of decoded but still unused bytes in internal buffer.</summary>
		private int remainingBufferBytes;

		/// <summary>Next unused byte offset.</summary>
		private int bufferOffset;

		/// <summary>Decoder state.</summary>
		private readonly Org.Brotli.Dec.State state = new Org.Brotli.Dec.State();

		/// <summary>
		/// Creates a
		/// <see cref="System.IO.Stream"/>
		/// wrapper that decompresses brotli data.
		/// <p> For byte-by-byte reading (
		/// <see cref="ReadByte()"/>
		/// ) internal buffer with
		/// <see cref="DefaultInternalBufferSize"/>
		/// size is allocated and used.
		/// <p> Will block the thread until first kilobyte of data of source is available.
		/// </summary>
		/// <param name="source">underlying data source</param>
		/// <exception cref="System.IO.IOException">in case of corrupted data or source stream problems</exception>
		public BrotliInputStream(System.IO.Stream source)
			: this(source, DefaultInternalBufferSize, null)
		{
		}

		/// <summary>
		/// Creates a
		/// <see cref="System.IO.Stream"/>
		/// wrapper that decompresses brotli data.
		/// <p> For byte-by-byte reading (
		/// <see cref="ReadByte()"/>
		/// ) internal buffer of specified size is
		/// allocated and used.
		/// <p> Will block the thread until first kilobyte of data of source is available.
		/// </summary>
		/// <param name="source">compressed data source</param>
		/// <param name="byteReadBufferSize">
		/// size of internal buffer used in case of
		/// byte-by-byte reading
		/// </param>
		/// <exception cref="System.IO.IOException">in case of corrupted data or source stream problems</exception>
		public BrotliInputStream(System.IO.Stream source, int byteReadBufferSize)
			: this(source, byteReadBufferSize, null)
		{
		}

		/// <summary>
		/// Creates a
		/// <see cref="System.IO.Stream"/>
		/// wrapper that decompresses brotli data.
		/// <p> For byte-by-byte reading (
		/// <see cref="ReadByte()"/>
		/// ) internal buffer of specified size is
		/// allocated and used.
		/// <p> Will block the thread until first kilobyte of data of source is available.
		/// </summary>
		/// <param name="source">compressed data source</param>
		/// <param name="byteReadBufferSize">
		/// size of internal buffer used in case of
		/// byte-by-byte reading
		/// </param>
		/// <param name="customDictionary">
		/// custom dictionary data;
		/// <see langword="null"/>
		/// if not used
		/// </param>
		/// <exception cref="System.IO.IOException">in case of corrupted data or source stream problems</exception>
		public BrotliInputStream(System.IO.Stream source, int byteReadBufferSize, byte[] customDictionary)
		{
			if (byteReadBufferSize <= 0)
			{
				throw new System.ArgumentException("Bad buffer size:" + byteReadBufferSize);
			}
			else if (source == null)
			{
				throw new System.ArgumentException("source is null");
			}
			this.buffer = new byte[byteReadBufferSize];
			this.remainingBufferBytes = 0;
			this.bufferOffset = 0;
			try
			{
				Org.Brotli.Dec.State.SetInput(state, source);
			}
			catch (Org.Brotli.Dec.BrotliRuntimeException ex)
			{
				throw new System.IO.IOException("Brotli decoder initialization failed", ex);
			}
			if (customDictionary != null)
			{
				Org.Brotli.Dec.Decode.SetCustomDictionary(state, customDictionary);
			}
		}

		/// <summary><inheritDoc/></summary>
		/// <exception cref="System.IO.IOException"/>
		public override void Close()
		{
			Org.Brotli.Dec.State.Close(state);
		}

		/// <summary><inheritDoc/></summary>
		/// <exception cref="System.IO.IOException"/>
		public override int ReadByte()
		{
			if (bufferOffset >= remainingBufferBytes)
			{
				remainingBufferBytes = Read(buffer, 0, buffer.Length);
				bufferOffset = 0;
				if (remainingBufferBytes == -1)
				{
					return -1;
				}
			}
			return buffer[bufferOffset++] & unchecked((int)(0xFF));
		}

		/// <summary><inheritDoc/></summary>
		/// <exception cref="System.IO.IOException"/>
		public override int Read(byte[] destBuffer, int destOffset, int destLen)
		{
			if (destOffset < 0)
			{
				throw new System.ArgumentException("Bad offset: " + destOffset);
			}
			else if (destLen < 0)
			{
				throw new System.ArgumentException("Bad length: " + destLen);
			}
			else if (destOffset + destLen > destBuffer.Length)
			{
				throw new System.ArgumentException("Buffer overflow: " + (destOffset + destLen) + " > " + destBuffer.Length);
			}
			else if (destLen == 0)
			{
				return 0;
			}
			int copyLen = System.Math.Max(remainingBufferBytes - bufferOffset, 0);
			if (copyLen != 0)
			{
				copyLen = System.Math.Min(copyLen, destLen);
				System.Array.Copy(buffer, bufferOffset, destBuffer, destOffset, copyLen);
				bufferOffset += copyLen;
				destOffset += copyLen;
				destLen -= copyLen;
				if (destLen == 0)
				{
					return copyLen;
				}
			}
			try
			{
				state.output = destBuffer;
				state.outputOffset = destOffset;
				state.outputLength = destLen;
				state.outputUsed = 0;
				Org.Brotli.Dec.Decode.Decompress(state);
				if (state.outputUsed == 0)
				{
					return 0;
				}
				return state.outputUsed + copyLen;
			}
			catch (Org.Brotli.Dec.BrotliRuntimeException ex)
			{
				throw new System.IO.IOException("Brotli stream decoding failed", ex);
			}
		}
		// <{[INJECTED CODE]}>
		public override bool CanRead {
			get {return true;}
		}

		public override bool CanSeek {
			get {return false;}
		}
		public override long Length {
			get {throw new System.NotSupportedException();}
		}
		public override long Position {
			get {throw new System.NotSupportedException();}
			set {throw new System.NotSupportedException();}
		}
		public override long Seek(long offset, System.IO.SeekOrigin origin) {
			throw new System.NotSupportedException();
		}
		public override void SetLength(long value){
			throw new System.NotSupportedException();
		}

		public override bool CanWrite{get{return false;}}
		public override System.IAsyncResult BeginWrite(byte[] buffer, int offset,
				int count, System.AsyncCallback callback, object state) {
			throw new System.NotSupportedException();
		}
		public override void Write(byte[] buffer, int offset, int count) {
			throw new System.NotSupportedException();
		}

		public override void Flush() {}
	}
}

```

`AssetStudio/Brotli/BrotliRuntimeException.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>Unchecked exception used internally.</summary>
	[System.Serializable]
	internal class BrotliRuntimeException : System.Exception
	{
		internal BrotliRuntimeException(string message)
			: base(message)
		{
		}

		internal BrotliRuntimeException(string message, System.Exception cause)
			: base(message, cause)
		{
		}
	}
}

```

`AssetStudio/Brotli/Context.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>Common context lookup table for all context modes.</summary>
	internal sealed class Context
	{
		internal static readonly int[] Lookup = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 12, 16, 12, 12, 20, 12, 16, 24, 28, 12, 12, 32, 12, 36, 12, 44, 44, 44, 44, 44, 44, 44, 44
			, 44, 44, 32, 32, 24, 40, 28, 12, 12, 48, 52, 52, 52, 48, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 24, 12, 28, 12, 12, 12, 56, 60, 60, 60, 56, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60
			, 60, 56, 60, 60, 60, 60, 60, 24, 12, 28, 12, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 
			2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 
			1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
			0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
			3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
			4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 
			6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
			16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
			32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
			40, 40, 40, 40, 40, 40, 40, 40, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 56, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38
			, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 
			37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35
			, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 
			34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 
			10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 
			25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 
			40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 
			55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59, 60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

		internal static readonly int[] LookupOffsets = new int[] { 1024, 1536, 1280, 1536, 0, 256, 768, 512 };
		// CONTEXT_UTF8, last byte.
		// ASCII range.
		// UTF8 continuation byte range.
		// UTF8 lead byte range.
		// CONTEXT_UTF8 second last byte.
		// ASCII range.
		// UTF8 continuation byte range.
		// UTF8 lead byte range.
		// CONTEXT_SIGNED, second last byte.
		// CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits.
		// CONTEXT_LSB6, last byte.
		// CONTEXT_MSB6, last byte.
		// CONTEXT_{M,L}SB6, second last byte,
		// CONTEXT_LSB6
		// CONTEXT_MSB6
		// CONTEXT_UTF8
		// CONTEXT_SIGNED
	}
}

```

`AssetStudio/Brotli/Decode.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>API for Brotli decompression.</summary>
	internal sealed class Decode
	{
		private const int DefaultCodeLength = 8;

		private const int CodeLengthRepeatCode = 16;

		private const int NumLiteralCodes = 256;

		private const int NumInsertAndCopyCodes = 704;

		private const int NumBlockLengthCodes = 26;

		private const int LiteralContextBits = 6;

		private const int DistanceContextBits = 2;

		private const int HuffmanTableBits = 8;

		private const int HuffmanTableMask = unchecked((int)(0xFF));

		private const int CodeLengthCodes = 18;

		private static readonly int[] CodeLengthCodeOrder = new int[] { 1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15 };

		private const int NumDistanceShortCodes = 16;

		private static readonly int[] DistanceShortCodeIndexOffset = new int[] { 3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2 };

		private static readonly int[] DistanceShortCodeValueOffset = new int[] { 0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3 };

		/// <summary>Static Huffman code for the code length code lengths.</summary>
		private static readonly int[] FixedTable = new int[] { unchecked((int)(0x020000)), unchecked((int)(0x020004)), unchecked((int)(0x020003)), unchecked((int)(0x030002)), unchecked((int)(0x020000)), unchecked((int)(0x020004)), unchecked((int)(0x020003
			)), unchecked((int)(0x040001)), unchecked((int)(0x020000)), unchecked((int)(0x020004)), unchecked((int)(0x020003)), unchecked((int)(0x030002)), unchecked((int)(0x020000)), unchecked((int)(0x020004)), unchecked((int)(0x020003)), unchecked((int
			)(0x040005)) };

		/// <summary>Decodes a number in the range [0..255], by reading 1 - 11 bits.</summary>
		private static int DecodeVarLenUnsignedByte(Org.Brotli.Dec.BitReader br)
		{
			if (Org.Brotli.Dec.BitReader.ReadBits(br, 1) != 0)
			{
				int n = Org.Brotli.Dec.BitReader.ReadBits(br, 3);
				if (n == 0)
				{
					return 1;
				}
				else
				{
					return Org.Brotli.Dec.BitReader.ReadBits(br, n) + (1 << n);
				}
			}
			return 0;
		}

		private static void DecodeMetaBlockLength(Org.Brotli.Dec.BitReader br, Org.Brotli.Dec.State state)
		{
			state.inputEnd = Org.Brotli.Dec.BitReader.ReadBits(br, 1) == 1;
			state.metaBlockLength = 0;
			state.isUncompressed = false;
			state.isMetadata = false;
			if (state.inputEnd && Org.Brotli.Dec.BitReader.ReadBits(br, 1) != 0)
			{
				return;
			}
			int sizeNibbles = Org.Brotli.Dec.BitReader.ReadBits(br, 2) + 4;
			if (sizeNibbles == 7)
			{
				state.isMetadata = true;
				if (Org.Brotli.Dec.BitReader.ReadBits(br, 1) != 0)
				{
					throw new Org.Brotli.Dec.BrotliRuntimeException("Corrupted reserved bit");
				}
				int sizeBytes = Org.Brotli.Dec.BitReader.ReadBits(br, 2);
				if (sizeBytes == 0)
				{
					return;
				}
				for (int i = 0; i < sizeBytes; i++)
				{
					int bits = Org.Brotli.Dec.BitReader.ReadBits(br, 8);
					if (bits == 0 && i + 1 == sizeBytes && sizeBytes > 1)
					{
						throw new Org.Brotli.Dec.BrotliRuntimeException("Exuberant nibble");
					}
					state.metaBlockLength |= bits << (i * 8);
				}
			}
			else
			{
				for (int i = 0; i < sizeNibbles; i++)
				{
					int bits = Org.Brotli.Dec.BitReader.ReadBits(br, 4);
					if (bits == 0 && i + 1 == sizeNibbles && sizeNibbles > 4)
					{
						throw new Org.Brotli.Dec.BrotliRuntimeException("Exuberant nibble");
					}
					state.metaBlockLength |= bits << (i * 4);
				}
			}
			state.metaBlockLength++;
			if (!state.inputEnd)
			{
				state.isUncompressed = Org.Brotli.Dec.BitReader.ReadBits(br, 1) == 1;
			}
		}

		/// <summary>Decodes the next Huffman code from bit-stream.</summary>
		private static int ReadSymbol(int[] table, int offset, Org.Brotli.Dec.BitReader br)
		{
			int val = (int)((long)(((ulong)br.accumulator) >> br.bitOffset));
			offset += val & HuffmanTableMask;
			int bits = table[offset] >> 16;
			int sym = table[offset] & unchecked((int)(0xFFFF));
			if (bits <= HuffmanTableBits)
			{
				br.bitOffset += bits;
				return sym;
			}
			offset += sym;
			int mask = (1 << bits) - 1;
			offset += (int)(((uint)(val & mask)) >> HuffmanTableBits);
			br.bitOffset += ((table[offset] >> 16) + HuffmanTableBits);
			return table[offset] & unchecked((int)(0xFFFF));
		}

		private static int ReadBlockLength(int[] table, int offset, Org.Brotli.Dec.BitReader br)
		{
			Org.Brotli.Dec.BitReader.FillBitWindow(br);
			int code = ReadSymbol(table, offset, br);
			int n = Org.Brotli.Dec.Prefix.BlockLengthNBits[code];
			return Org.Brotli.Dec.Prefix.BlockLengthOffset[code] + Org.Brotli.Dec.BitReader.ReadBits(br, n);
		}

		private static int TranslateShortCodes(int code, int[] ringBuffer, int index)
		{
			if (code < NumDistanceShortCodes)
			{
				index += DistanceShortCodeIndexOffset[code];
				index &= 3;
				return ringBuffer[index] + DistanceShortCodeValueOffset[code];
			}
			return code - NumDistanceShortCodes + 1;
		}

		private static void MoveToFront(int[] v, int index)
		{
			int value = v[index];
			for (; index > 0; index--)
			{
				v[index] = v[index - 1];
			}
			v[0] = value;
		}

		private static void InverseMoveToFrontTransform(byte[] v, int vLen)
		{
			int[] mtf = new int[256];
			for (int i = 0; i < 256; i++)
			{
				mtf[i] = i;
			}
			for (int i = 0; i < vLen; i++)
			{
				int index = v[i] & unchecked((int)(0xFF));
				v[i] = unchecked((byte)mtf[index]);
				if (index != 0)
				{
					MoveToFront(mtf, index);
				}
			}
		}

		private static void ReadHuffmanCodeLengths(int[] codeLengthCodeLengths, int numSymbols, int[] codeLengths, Org.Brotli.Dec.BitReader br)
		{
			int symbol = 0;
			int prevCodeLen = DefaultCodeLength;
			int repeat = 0;
			int repeatCodeLen = 0;
			int space = 32768;
			int[] table = new int[32];
			Org.Brotli.Dec.Huffman.BuildHuffmanTable(table, 0, 5, codeLengthCodeLengths, CodeLengthCodes);
			while (symbol < numSymbols && space > 0)
			{
				Org.Brotli.Dec.BitReader.ReadMoreInput(br);
				Org.Brotli.Dec.BitReader.FillBitWindow(br);
				int p = (int)(((long)(((ulong)br.accumulator) >> br.bitOffset))) & 31;
				br.bitOffset += table[p] >> 16;
				int codeLen = table[p] & unchecked((int)(0xFFFF));
				if (codeLen < CodeLengthRepeatCode)
				{
					repeat = 0;
					codeLengths[symbol++] = codeLen;
					if (codeLen != 0)
					{
						prevCodeLen = codeLen;
						space -= 32768 >> codeLen;
					}
				}
				else
				{
					int extraBits = codeLen - 14;
					int newLen = 0;
					if (codeLen == CodeLengthRepeatCode)
					{
						newLen = prevCodeLen;
					}
					if (repeatCodeLen != newLen)
					{
						repeat = 0;
						repeatCodeLen = newLen;
					}
					int oldRepeat = repeat;
					if (repeat > 0)
					{
						repeat -= 2;
						repeat <<= extraBits;
					}
					repeat += Org.Brotli.Dec.BitReader.ReadBits(br, extraBits) + 3;
					int repeatDelta = repeat - oldRepeat;
					if (symbol + repeatDelta > numSymbols)
					{
						throw new Org.Brotli.Dec.BrotliRuntimeException("symbol + repeatDelta > numSymbols");
					}
					// COV_NF_LINE
					for (int i = 0; i < repeatDelta; i++)
					{
						codeLengths[symbol++] = repeatCodeLen;
					}
					if (repeatCodeLen != 0)
					{
						space -= repeatDelta << (15 - repeatCodeLen);
					}
				}
			}
			if (space != 0)
			{
				throw new Org.Brotli.Dec.BrotliRuntimeException("Unused space");
			}
			// COV_NF_LINE
			// TODO: Pass max_symbol to Huffman table builder instead?
			Org.Brotli.Dec.Utils.FillWithZeroes(codeLengths, symbol, numSymbols - symbol);
		}

		// TODO: Use specialized versions for smaller tables.
		internal static void ReadHuffmanCode(int alphabetSize, int[] table, int offset, Org.Brotli.Dec.BitReader br)
		{
			bool ok = true;
			int simpleCodeOrSkip;
			Org.Brotli.Dec.BitReader.ReadMoreInput(br);
			// TODO: Avoid allocation.
			int[] codeLengths = new int[alphabetSize];
			simpleCodeOrSkip = Org.Brotli.Dec.BitReader.ReadBits(br, 2);
			if (simpleCodeOrSkip == 1)
			{
				// Read symbols, codes & code lengths directly.
				int maxBitsCounter = alphabetSize - 1;
				int maxBits = 0;
				int[] symbols = new int[4];
				int numSymbols = Org.Brotli.Dec.BitReader.ReadBits(br, 2) + 1;
				while (maxBitsCounter != 0)
				{
					maxBitsCounter >>= 1;
					maxBits++;
				}
				// TODO: uncomment when codeLengths is reused.
				// Utils.fillWithZeroes(codeLengths, 0, alphabetSize);
				for (int i = 0; i < numSymbols; i++)
				{
					symbols[i] = Org.Brotli.Dec.BitReader.ReadBits(br, maxBits) % alphabetSize;
					codeLengths[symbols[i]] = 2;
				}
				codeLengths[symbols[0]] = 1;
				switch (numSymbols)
				{
					case 1:
					{
						break;
					}

					case 2:
					{
						ok = symbols[0] != symbols[1];
						codeLengths[symbols[1]] = 1;
						break;
					}

					case 3:
					{
						ok = symbols[0] != symbols[1] && symbols[0] != symbols[2] && symbols[1] != symbols[2];
						break;
					}

					case 4:
					default:
					{
						ok = symbols[0] != symbols[1] && symbols[0] != symbols[2] && symbols[0] != symbols[3] && symbols[1] != symbols[2] && symbols[1] != symbols[3] && symbols[2] != symbols[3];
						if (Org.Brotli.Dec.BitReader.ReadBits(br, 1) == 1)
						{
							codeLengths[symbols[2]] = 3;
							codeLengths[symbols[3]] = 3;
						}
						else
						{
							codeLengths[symbols[0]] = 2;
						}
						break;
					}
				}
			}
			else
			{
				// Decode Huffman-coded code lengths.
				int[] codeLengthCodeLengths = new int[CodeLengthCodes];
				int space = 32;
				int numCodes = 0;
				for (int i = simpleCodeOrSkip; i < CodeLengthCodes && space > 0; i++)
				{
					int codeLenIdx = CodeLengthCodeOrder[i];
					Org.Brotli.Dec.BitReader.FillBitWindow(br);
					int p = (int)((long)(((ulong)br.accumulator) >> br.bitOffset)) & 15;
					// TODO: Demultiplex FIXED_TABLE.
					br.bitOffset += FixedTable[p] >> 16;
					int v = FixedTable[p] & unchecked((int)(0xFFFF));
					codeLengthCodeLengths[codeLenIdx] = v;
					if (v != 0)
					{
						space -= (32 >> v);
						numCodes++;
					}
				}
				ok = (numCodes == 1 || space == 0);
				ReadHuffmanCodeLengths(codeLengthCodeLengths, alphabetSize, codeLengths, br);
			}
			if (!ok)
			{
				throw new Org.Brotli.Dec.BrotliRuntimeException("Can't readHuffmanCode");
			}
			// COV_NF_LINE
			Org.Brotli.Dec.Huffman.BuildHuffmanTable(table, offset, HuffmanTableBits, codeLengths, alphabetSize);
		}

		private static int DecodeContextMap(int contextMapSize, byte[] contextMap, Org.Brotli.Dec.BitReader br)
		{
			Org.Brotli.Dec.BitReader.ReadMoreInput(br);
			int numTrees = DecodeVarLenUnsignedByte(br) + 1;
			if (numTrees == 1)
			{
				Org.Brotli.Dec.Utils.FillWithZeroes(contextMap, 0, contextMapSize);
				return numTrees;
			}
			bool useRleForZeros = Org.Brotli.Dec.BitReader.ReadBits(br, 1) == 1;
			int maxRunLengthPrefix = 0;
			if (useRleForZeros)
			{
				maxRunLengthPrefix = Org.Brotli.Dec.BitReader.ReadBits(br, 4) + 1;
			}
			int[] table = new int[Org.Brotli.Dec.Huffman.HuffmanMaxTableSize];
			ReadHuffmanCode(numTrees + maxRunLengthPrefix, table, 0, br);
			for (int i = 0; i < contextMapSize; )
			{
				Org.Brotli.Dec.BitReader.ReadMoreInput(br);
				Org.Brotli.Dec.BitReader.FillBitWindow(br);
				int code = ReadSymbol(table, 0, br);
				if (code == 0)
				{
					contextMap[i] = 0;
					i++;
				}
				else if (code <= maxRunLengthPrefix)
				{
					int reps = (1 << code) + Org.Brotli.Dec.BitReader.ReadBits(br, code);
					while (reps != 0)
					{
						if (i >= contextMapSize)
						{
							throw new Org.Brotli.Dec.BrotliRuntimeException("Corrupted context map");
						}
						// COV_NF_LINE
						contextMap[i] = 0;
						i++;
						reps--;
					}
				}
				else
				{
					contextMap[i] = unchecked((byte)(code - maxRunLengthPrefix));
					i++;
				}
			}
			if (Org.Brotli.Dec.BitReader.ReadBits(br, 1) == 1)
			{
				InverseMoveToFrontTransform(contextMap, contextMapSize);
			}
			return numTrees;
		}

		private static void DecodeBlockTypeAndLength(Org.Brotli.Dec.State state, int treeType)
		{
			Org.Brotli.Dec.BitReader br = state.br;
			int[] ringBuffers = state.blockTypeRb;
			int offset = treeType * 2;
			Org.Brotli.Dec.BitReader.FillBitWindow(br);
			int blockType = ReadSymbol(state.blockTypeTrees, treeType * Org.Brotli.Dec.Huffman.HuffmanMaxTableSize, br);
			state.blockLength[treeType] = ReadBlockLength(state.blockLenTrees, treeType * Org.Brotli.Dec.Huffman.HuffmanMaxTableSize, br);
			if (blockType == 1)
			{
				blockType = ringBuffers[offset + 1] + 1;
			}
			else if (blockType == 0)
			{
				blockType = ringBuffers[offset];
			}
			else
			{
				blockType -= 2;
			}
			if (blockType >= state.numBlockTypes[treeType])
			{
				blockType -= state.numBlockTypes[treeType];
			}
			ringBuffers[offset] = ringBuffers[offset + 1];
			ringBuffers[offset + 1] = blockType;
		}

		private static void DecodeLiteralBlockSwitch(Org.Brotli.Dec.State state)
		{
			DecodeBlockTypeAndLength(state, 0);
			int literalBlockType = state.blockTypeRb[1];
			state.contextMapSlice = literalBlockType << LiteralContextBits;
			state.literalTreeIndex = state.contextMap[state.contextMapSlice] & unchecked((int)(0xFF));
			state.literalTree = state.hGroup0.trees[state.literalTreeIndex];
			int contextMode = state.contextModes[literalBlockType];
			state.contextLookupOffset1 = Org.Brotli.Dec.Context.LookupOffsets[contextMode];
			state.contextLookupOffset2 = Org.Brotli.Dec.Context.LookupOffsets[contextMode + 1];
		}

		private static void DecodeCommandBlockSwitch(Org.Brotli.Dec.State state)
		{
			DecodeBlockTypeAndLength(state, 1);
			state.treeCommandOffset = state.hGroup1.trees[state.blockTypeRb[3]];
		}

		private static void DecodeDistanceBlockSwitch(Org.Brotli.Dec.State state)
		{
			DecodeBlockTypeAndLength(state, 2);
			state.distContextMapSlice = state.blockTypeRb[5] << DistanceContextBits;
		}

		private static void MaybeReallocateRingBuffer(Org.Brotli.Dec.State state)
		{
			int newSize = state.maxRingBufferSize;
			if ((long)newSize > state.expectedTotalSize)
			{
				/* TODO: Handle 2GB+ cases more gracefully. */
				int minimalNewSize = (int)state.expectedTotalSize + state.customDictionary.Length;
				while ((newSize >> 1) > minimalNewSize)
				{
					newSize >>= 1;
				}
				if (!state.inputEnd && newSize < 16384 && state.maxRingBufferSize >= 16384)
				{
					newSize = 16384;
				}
			}
			if (newSize <= state.ringBufferSize)
			{
				return;
			}
			int ringBufferSizeWithSlack = newSize + Org.Brotli.Dec.Dictionary.MaxTransformedWordLength;
			byte[] newBuffer = new byte[ringBufferSizeWithSlack];
			if (state.ringBuffer != null)
			{
				System.Array.Copy(state.ringBuffer, 0, newBuffer, 0, state.ringBufferSize);
			}
			else if (state.customDictionary.Length != 0)
			{
				/* Prepend custom dictionary, if any. */
				int length = state.customDictionary.Length;
				int offset = 0;
				if (length > state.maxBackwardDistance)
				{
					offset = length - state.maxBackwardDistance;
					length = state.maxBackwardDistance;
				}
				System.Array.Copy(state.customDictionary, offset, newBuffer, 0, length);
				state.pos = length;
				state.bytesToIgnore = length;
			}
			state.ringBuffer = newBuffer;
			state.ringBufferSize = newSize;
		}

		/// <summary>Reads next metablock header.</summary>
		/// <param name="state">decoding state</param>
		private static void ReadMetablockInfo(Org.Brotli.Dec.State state)
		{
			Org.Brotli.Dec.BitReader br = state.br;
			if (state.inputEnd)
			{
				state.nextRunningState = Org.Brotli.Dec.RunningState.Finished;
				state.bytesToWrite = state.pos;
				state.bytesWritten = 0;
				state.runningState = Org.Brotli.Dec.RunningState.Write;
				return;
			}
			// TODO: Reset? Do we need this?
			state.hGroup0.codes = null;
			state.hGroup0.trees = null;
			state.hGroup1.codes = null;
			state.hGroup1.trees = null;
			state.hGroup2.codes = null;
			state.hGroup2.trees = null;
			Org.Brotli.Dec.BitReader.ReadMoreInput(br);
			DecodeMetaBlockLength(br, state);
			if (state.metaBlockLength == 0 && !state.isMetadata)
			{
				return;
			}
			if (state.isUncompressed || state.isMetadata)
			{
				Org.Brotli.Dec.BitReader.JumpToByteBoundary(br);
				state.runningState = state.isMetadata ? Org.Brotli.Dec.RunningState.ReadMetadata : Org.Brotli.Dec.RunningState.CopyUncompressed;
			}
			else
			{
				state.runningState = Org.Brotli.Dec.RunningState.CompressedBlockStart;
			}
			if (state.isMetadata)
			{
				return;
			}
			state.expectedTotalSize += state.metaBlockLength;
			if (state.ringBufferSize < state.maxRingBufferSize)
			{
				MaybeReallocateRingBuffer(state);
			}
		}

		private static void ReadMetablockHuffmanCodesAndContextMaps(Org.Brotli.Dec.State state)
		{
			Org.Brotli.Dec.BitReader br = state.br;
			for (int i = 0; i < 3; i++)
			{
				state.numBlockTypes[i] = DecodeVarLenUnsignedByte(br) + 1;
				state.blockLength[i] = 1 << 28;
				if (state.numBlockTypes[i] > 1)
				{
					ReadHuffmanCode(state.numBlockTypes[i] + 2, state.blockTypeTrees, i * Org.Brotli.Dec.Huffman.HuffmanMaxTableSize, br);
					ReadHuffmanCode(NumBlockLengthCodes, state.blockLenTrees, i * Org.Brotli.Dec.Huffman.HuffmanMaxTableSize, br);
					state.blockLength[i] = ReadBlockLength(state.blockLenTrees, i * Org.Brotli.Dec.Huffman.HuffmanMaxTableSize, br);
				}
			}
			Org.Brotli.Dec.BitReader.ReadMoreInput(br);
			state.distancePostfixBits = Org.Brotli.Dec.BitReader.ReadBits(br, 2);
			state.numDirectDistanceCodes = NumDistanceShortCodes + (Org.Brotli.Dec.BitReader.ReadBits(br, 4) << state.distancePostfixBits);
			state.distancePostfixMask = (1 << state.distancePostfixBits) - 1;
			int numDistanceCodes = state.numDirectDistanceCodes + (48 << state.distancePostfixBits);
			// TODO: Reuse?
			state.contextModes = new byte[state.numBlockTypes[0]];
			for (int i = 0; i < state.numBlockTypes[0]; )
			{
				/* Ensure that less than 256 bits read between readMoreInput. */
				int limit = System.Math.Min(i + 96, state.numBlockTypes[0]);
				for (; i < limit; ++i)
				{
					state.contextModes[i] = unchecked((byte)(Org.Brotli.Dec.BitReader.ReadBits(br, 2) << 1));
				}
				Org.Brotli.Dec.BitReader.ReadMoreInput(br);
			}
			// TODO: Reuse?
			state.contextMap = new byte[state.numBlockTypes[0] << LiteralContextBits];
			int numLiteralTrees = DecodeContextMap(state.numBlockTypes[0] << LiteralContextBits, state.contextMap, br);
			state.trivialLiteralContext = true;
			for (int j = 0; j < state.numBlockTypes[0] << LiteralContextBits; j++)
			{
				if (state.contextMap[j] != j >> LiteralContextBits)
				{
					state.trivialLiteralContext = false;
					break;
				}
			}
			// TODO: Reuse?
			state.distContextMap = new byte[state.numBlockTypes[2] << DistanceContextBits];
			int numDistTrees = DecodeContextMap(state.numBlockTypes[2] << DistanceContextBits, state.distContextMap, br);
			Org.Brotli.Dec.HuffmanTreeGroup.Init(state.hGroup0, NumLiteralCodes, numLiteralTrees);
			Org.Brotli.Dec.HuffmanTreeGroup.Init(state.hGroup1, NumInsertAndCopyCodes, state.numBlockTypes[1]);
			Org.Brotli.Dec.HuffmanTreeGroup.Init(state.hGroup2, numDistanceCodes, numDistTrees);
			Org.Brotli.Dec.HuffmanTreeGroup.Decode(state.hGroup0, br);
			Org.Brotli.Dec.HuffmanTreeGroup.Decode(state.hGroup1, br);
			Org.Brotli.Dec.HuffmanTreeGroup.Decode(state.hGroup2, br);
			state.contextMapSlice = 0;
			state.distContextMapSlice = 0;
			state.contextLookupOffset1 = Org.Brotli.Dec.Context.LookupOffsets[state.contextModes[0]];
			state.contextLookupOffset2 = Org.Brotli.Dec.Context.LookupOffsets[state.contextModes[0] + 1];
			state.literalTreeIndex = 0;
			state.literalTree = state.hGroup0.trees[0];
			state.treeCommandOffset = state.hGroup1.trees[0];
			// TODO: == 0?
			state.blockTypeRb[0] = state.blockTypeRb[2] = state.blockTypeRb[4] = 1;
			state.blockTypeRb[1] = state.blockTypeRb[3] = state.blockTypeRb[5] = 0;
		}

		private static void CopyUncompressedData(Org.Brotli.Dec.State state)
		{
			Org.Brotli.Dec.BitReader br = state.br;
			byte[] ringBuffer = state.ringBuffer;
			// Could happen if block ends at ring buffer end.
			if (state.metaBlockLength <= 0)
			{
				Org.Brotli.Dec.BitReader.Reload(br);
				state.runningState = Org.Brotli.Dec.RunningState.BlockStart;
				return;
			}
			int chunkLength = System.Math.Min(state.ringBufferSize - state.pos, state.metaBlockLength);
			Org.Brotli.Dec.BitReader.CopyBytes(br, ringBuffer, state.pos, chunkLength);
			state.metaBlockLength -= chunkLength;
			state.pos += chunkLength;
			if (state.pos == state.ringBufferSize)
			{
				state.nextRunningState = Org.Brotli.Dec.RunningState.CopyUncompressed;
				state.bytesToWrite = state.ringBufferSize;
				state.bytesWritten = 0;
				state.runningState = Org.Brotli.Dec.RunningState.Write;
				return;
			}
			Org.Brotli.Dec.BitReader.Reload(br);
			state.runningState = Org.Brotli.Dec.RunningState.BlockStart;
		}

		private static bool WriteRingBuffer(Org.Brotli.Dec.State state)
		{
			/* Ignore custom dictionary bytes. */
			if (state.bytesToIgnore != 0)
			{
				state.bytesWritten += state.bytesToIgnore;
				state.bytesToIgnore = 0;
			}
			int toWrite = System.Math.Min(state.outputLength - state.outputUsed, state.bytesToWrite - state.bytesWritten);
			if (toWrite != 0)
			{
				System.Array.Copy(state.ringBuffer, state.bytesWritten, state.output, state.outputOffset + state.outputUsed, toWrite);
				state.outputUsed += toWrite;
				state.bytesWritten += toWrite;
			}
			return state.outputUsed < state.outputLength;
		}

		internal static void SetCustomDictionary(Org.Brotli.Dec.State state, byte[] data)
		{
			state.customDictionary = (data == null) ? new byte[0] : data;
		}

		/// <summary>Actual decompress implementation.</summary>
		internal static void Decompress(Org.Brotli.Dec.State state)
		{
			if (state.runningState == Org.Brotli.Dec.RunningState.Uninitialized)
			{
				throw new System.InvalidOperationException("Can't decompress until initialized");
			}
			if (state.runningState == Org.Brotli.Dec.RunningState.Closed)
			{
				throw new System.InvalidOperationException("Can't decompress after close");
			}
			Org.Brotli.Dec.BitReader br = state.br;
			int ringBufferMask = state.ringBufferSize - 1;
			byte[] ringBuffer = state.ringBuffer;
			while (state.runningState != Org.Brotli.Dec.RunningState.Finished)
			{
				switch (state.runningState)
				{
					case Org.Brotli.Dec.RunningState.BlockStart:
					{
						// TODO: extract cases to methods for the better readability.
						if (state.metaBlockLength < 0)
						{
							throw new Org.Brotli.Dec.BrotliRuntimeException("Invalid metablock length");
						}
						ReadMetablockInfo(state);
						/* Ring-buffer would be reallocated here. */
						ringBufferMask = state.ringBufferSize - 1;
						ringBuffer = state.ringBuffer;
						continue;
					}

					case Org.Brotli.Dec.RunningState.CompressedBlockStart:
					{
						ReadMetablockHuffmanCodesAndContextMaps(state);
						state.runningState = Org.Brotli.Dec.RunningState.MainLoop;
						goto case Org.Brotli.Dec.RunningState.MainLoop;
					}

					case Org.Brotli.Dec.RunningState.MainLoop:
					{
						// Fall through
						if (state.metaBlockLength <= 0)
						{
							state.runningState = Org.Brotli.Dec.RunningState.BlockStart;
							continue;
						}
						Org.Brotli.Dec.BitReader.ReadMoreInput(br);
						if (state.blockLength[1] == 0)
						{
							DecodeCommandBlockSwitch(state);
						}
						state.blockLength[1]--;
						Org.Brotli.Dec.BitReader.FillBitWindow(br);
						int cmdCode = ReadSymbol(state.hGroup1.codes, state.treeCommandOffset, br);
						int rangeIdx = (int)(((uint)cmdCode) >> 6);
						state.distanceCode = 0;
						if (rangeIdx >= 2)
						{
							rangeIdx -= 2;
							state.distanceCode = -1;
						}
						int insertCode = Org.Brotli.Dec.Prefix.InsertRangeLut[rangeIdx] + (((int)(((uint)cmdCode) >> 3)) & 7);
						int copyCode = Org.Brotli.Dec.Prefix.CopyRangeLut[rangeIdx] + (cmdCode & 7);
						state.insertLength = Org.Brotli.Dec.Prefix.InsertLengthOffset[insertCode] + Org.Brotli.Dec.BitReader.ReadBits(br, Org.Brotli.Dec.Prefix.InsertLengthNBits[insertCode]);
						state.copyLength = Org.Brotli.Dec.Prefix.CopyLengthOffset[copyCode] + Org.Brotli.Dec.BitReader.ReadBits(br, Org.Brotli.Dec.Prefix.CopyLengthNBits[copyCode]);
						state.j = 0;
						state.runningState = Org.Brotli.Dec.RunningState.InsertLoop;
						goto case Org.Brotli.Dec.RunningState.InsertLoop;
					}

					case Org.Brotli.Dec.RunningState.InsertLoop:
					{
						// Fall through
						if (state.trivialLiteralContext)
						{
							while (state.j < state.insertLength)
							{
								Org.Brotli.Dec.BitReader.ReadMoreInput(br);
								if (state.blockLength[0] == 0)
								{
									DecodeLiteralBlockSwitch(state);
								}
								state.blockLength[0]--;
								Org.Brotli.Dec.BitReader.FillBitWindow(br);
								ringBuffer[state.pos] = unchecked((byte)ReadSymbol(state.hGroup0.codes, state.literalTree, br));
								state.j++;
								if (state.pos++ == ringBufferMask)
								{
									state.nextRunningState = Org.Brotli.Dec.RunningState.InsertLoop;
									state.bytesToWrite = state.ringBufferSize;
									state.bytesWritten = 0;
									state.runningState = Org.Brotli.Dec.RunningState.Write;
									break;
								}
							}
						}
						else
						{
							int prevByte1 = ringBuffer[(state.pos - 1) & ringBufferMask] & unchecked((int)(0xFF));
							int prevByte2 = ringBuffer[(state.pos - 2) & ringBufferMask] & unchecked((int)(0xFF));
							while (state.j < state.insertLength)
							{
								Org.Brotli.Dec.BitReader.ReadMoreInput(br);
								if (state.blockLength[0] == 0)
								{
									DecodeLiteralBlockSwitch(state);
								}
								int literalTreeIndex = state.contextMap[state.contextMapSlice + (Org.Brotli.Dec.Context.Lookup[state.contextLookupOffset1 + prevByte1] | Org.Brotli.Dec.Context.Lookup[state.contextLookupOffset2 + prevByte2])] & unchecked((int)(0xFF));
								state.blockLength[0]--;
								prevByte2 = prevByte1;
								Org.Brotli.Dec.BitReader.FillBitWindow(br);
								prevByte1 = ReadSymbol(state.hGroup0.codes, state.hGroup0.trees[literalTreeIndex], br);
								ringBuffer[state.pos] = unchecked((byte)prevByte1);
								state.j++;
								if (state.pos++ == ringBufferMask)
								{
									state.nextRunningState = Org.Brotli.Dec.RunningState.InsertLoop;
									state.bytesToWrite = state.ringBufferSize;
									state.bytesWritten = 0;
									state.runningState = Org.Brotli.Dec.RunningState.Write;
									break;
								}
							}
						}
						if (state.runningState != Org.Brotli.Dec.RunningState.InsertLoop)
						{
							continue;
						}
						state.metaBlockLength -= state.insertLength;
						if (state.metaBlockLength <= 0)
						{
							state.runningState = Org.Brotli.Dec.RunningState.MainLoop;
							continue;
						}
						if (state.distanceCode < 0)
						{
							Org.Brotli.Dec.BitReader.ReadMoreInput(br);
							if (state.blockLength[2] == 0)
							{
								DecodeDistanceBlockSwitch(state);
							}
							state.blockLength[2]--;
							Org.Brotli.Dec.BitReader.FillBitWindow(br);
							state.distanceCode = ReadSymbol(state.hGroup2.codes, state.hGroup2.trees[state.distContextMap[state.distContextMapSlice + (state.copyLength > 4 ? 3 : state.copyLength - 2)] & unchecked((int)(0xFF))], br);
							if (state.distanceCode >= state.numDirectDistanceCodes)
							{
								state.distanceCode -= state.numDirectDistanceCodes;
								int postfix = state.distanceCode & state.distancePostfixMask;
								state.distanceCode = (int)(((uint)state.distanceCode) >> state.distancePostfixBits);
								int n = ((int)(((uint)state.distanceCode) >> 1)) + 1;
								int offset = ((2 + (state.distanceCode & 1)) << n) - 4;
								state.distanceCode = state.numDirectDistanceCodes + postfix + ((offset + Org.Brotli.Dec.BitReader.ReadBits(br, n)) << state.distancePostfixBits);
							}
						}
						// Convert the distance code to the actual distance by possibly looking up past distances
						// from the ringBuffer.
						state.distance = TranslateShortCodes(state.distanceCode, state.distRb, state.distRbIdx);
						if (state.distance < 0)
						{
							throw new Org.Brotli.Dec.BrotliRuntimeException("Negative distance");
						}
						// COV_NF_LINE
						if (state.maxDistance != state.maxBackwardDistance && state.pos < state.maxBackwardDistance)
						{
							state.maxDistance = state.pos;
						}
						else
						{
							state.maxDistance = state.maxBackwardDistance;
						}
						state.copyDst = state.pos;
						if (state.distance > state.maxDistance)
						{
							state.runningState = Org.Brotli.Dec.RunningState.Transform;
							continue;
						}
						if (state.distanceCode > 0)
						{
							state.distRb[state.distRbIdx & 3] = state.distance;
							state.distRbIdx++;
						}
						if (state.copyLength > state.metaBlockLength)
						{
							throw new Org.Brotli.Dec.BrotliRuntimeException("Invalid backward reference");
						}
						// COV_NF_LINE
						state.j = 0;
						state.runningState = Org.Brotli.Dec.RunningState.CopyLoop;
						goto case Org.Brotli.Dec.RunningState.CopyLoop;
					}

					case Org.Brotli.Dec.RunningState.CopyLoop:
					{
						// fall through
						int src = (state.pos - state.distance) & ringBufferMask;
						int dst = state.pos;
						int copyLength = state.copyLength - state.j;
						if ((src + copyLength < ringBufferMask) && (dst + copyLength < ringBufferMask))
						{
							for (int k = 0; k < copyLength; ++k)
							{
								ringBuffer[dst++] = ringBuffer[src++];
							}
							state.j += copyLength;
							state.metaBlockLength -= copyLength;
							state.pos += copyLength;
						}
						else
						{
							for (; state.j < state.copyLength; )
							{
								ringBuffer[state.pos] = ringBuffer[(state.pos - state.distance) & ringBufferMask];
								state.metaBlockLength--;
								state.j++;
								if (state.pos++ == ringBufferMask)
								{
									state.nextRunningState = Org.Brotli.Dec.RunningState.CopyLoop;
									state.bytesToWrite = state.ringBufferSize;
									state.bytesWritten = 0;
									state.runningState = Org.Brotli.Dec.RunningState.Write;
									break;
								}
							}
						}
						if (state.runningState == Org.Brotli.Dec.RunningState.CopyLoop)
						{
							state.runningState = Org.Brotli.Dec.RunningState.MainLoop;
						}
						continue;
					}

					case Org.Brotli.Dec.RunningState.Transform:
					{
						if (state.copyLength >= Org.Brotli.Dec.Dictionary.MinWordLength && state.copyLength <= Org.Brotli.Dec.Dictionary.MaxWordLength)
						{
							int offset = Org.Brotli.Dec.Dictionary.OffsetsByLength[state.copyLength];
							int wordId = state.distance - state.maxDistance - 1;
							int shift = Org.Brotli.Dec.Dictionary.SizeBitsByLength[state.copyLength];
							int mask = (1 << shift) - 1;
							int wordIdx = wordId & mask;
							int transformIdx = (int)(((uint)wordId) >> shift);
							offset += wordIdx * state.copyLength;
							if (transformIdx < Org.Brotli.Dec.Transform.Transforms.Length)
							{
								int len = Org.Brotli.Dec.Transform.TransformDictionaryWord(ringBuffer, state.copyDst, Org.Brotli.Dec.Dictionary.GetData(), offset, state.copyLength, Org.Brotli.Dec.Transform.Transforms[transformIdx]);
								state.copyDst += len;
								state.pos += len;
								state.metaBlockLength -= len;
								if (state.copyDst >= state.ringBufferSize)
								{
									state.nextRunningState = Org.Brotli.Dec.RunningState.CopyWrapBuffer;
									state.bytesToWrite = state.ringBufferSize;
									state.bytesWritten = 0;
									state.runningState = Org.Brotli.Dec.RunningState.Write;
									continue;
								}
							}
							else
							{
								throw new Org.Brotli.Dec.BrotliRuntimeException("Invalid backward reference");
							}
						}
						else
						{
							// COV_NF_LINE
							throw new Org.Brotli.Dec.BrotliRuntimeException("Invalid backward reference");
						}
						// COV_NF_LINE
						state.runningState = Org.Brotli.Dec.RunningState.MainLoop;
						continue;
					}

					case Org.Brotli.Dec.RunningState.CopyWrapBuffer:
					{
						System.Array.Copy(ringBuffer, state.ringBufferSize, ringBuffer, 0, state.copyDst - state.ringBufferSize);
						state.runningState = Org.Brotli.Dec.RunningState.MainLoop;
						continue;
					}

					case Org.Brotli.Dec.RunningState.ReadMetadata:
					{
						while (state.metaBlockLength > 0)
						{
							Org.Brotli.Dec.BitReader.ReadMoreInput(br);
							// Optimize
							Org.Brotli.Dec.BitReader.ReadBits(br, 8);
							state.metaBlockLength--;
						}
						state.runningState = Org.Brotli.Dec.RunningState.BlockStart;
						continue;
					}

					case Org.Brotli.Dec.RunningState.CopyUncompressed:
					{
						CopyUncompressedData(state);
						continue;
					}

					case Org.Brotli.Dec.RunningState.Write:
					{
						if (!WriteRingBuffer(state))
						{
							// Output buffer is full.
							return;
						}
						if (state.pos >= state.maxBackwardDistance)
						{
							state.maxDistance = state.maxBackwardDistance;
						}
						state.pos &= ringBufferMask;
						state.runningState = state.nextRunningState;
						continue;
					}

					default:
					{
						throw new Org.Brotli.Dec.BrotliRuntimeException("Unexpected state " + state.runningState);
					}
				}
			}
			if (state.runningState == Org.Brotli.Dec.RunningState.Finished)
			{
				if (state.metaBlockLength < 0)
				{
					throw new Org.Brotli.Dec.BrotliRuntimeException("Invalid metablock length");
				}
				Org.Brotli.Dec.BitReader.JumpToByteBoundary(br);
				Org.Brotli.Dec.BitReader.CheckHealth(state.br, true);
			}
		}
	}
}

```

`AssetStudio/Brotli/Dictionary.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>Collection of static dictionary words.</summary>
	/// <remarks>
	/// Collection of static dictionary words.
	/// <p>Dictionary content is loaded from binary resource when
	/// <see cref="GetData()"/>
	/// is executed for the
	/// first time. Consequently, it saves memory and CPU in case dictionary is not required.
	/// <p>One possible drawback is that multiple threads that need dictionary data may be blocked (only
	/// once in each classworld). To avoid this, it is enough to call
	/// <see cref="GetData()"/>
	/// proactively.
	/// </remarks>
	internal sealed class Dictionary
	{
		/// <summary>"Initialization-on-demand holder idiom" implementation.</summary>
		/// <remarks>
		/// "Initialization-on-demand holder idiom" implementation.
		/// <p>This static class definition is not initialized until the JVM determines that it must be
		/// executed (when the static method
		/// <see cref="GetData()"/>
		/// is invoked).
		/// </remarks>
		private class DataHolder0
		{
			internal static string GetData()
			{
				return "timedownlifeleftbackcodedatashowonlysitecityopenjustlikefreeworktextyearoverbodyloveformbookplaylivelinehelphomesidemorewordlongthemviewfindpagedaysfullheadtermeachareafromtruemarkableuponhighdatelandnewsevennextcasebothpostusedmadehandherewhatnameLinkblogsizebaseheldmakemainuser') +holdendswithNewsreadweresigntakehavegameseencallpathwellplusmenufilmpartjointhislistgoodneedwayswestjobsmindalsologorichuseslastteamarmyfoodkingwilleastwardbestfirePageknowaway.pngmovethanloadgiveselfnotemuchfeedmanyrockicononcelookhidediedHomerulehostajaxinfoclublawslesshalfsomesuchzone100%onescareTimeracebluefourweekfacehopegavehardlostwhenparkkeptpassshiproomHTMLplanTypedonesavekeepflaglinksoldfivetookratetownjumpthusdarkcardfilefearstaykillthatfallautoever.comtalkshopvotedeepmoderestturnbornbandfellroseurl(skinrolecomeactsagesmeetgold.jpgitemvaryfeltthensenddropViewcopy1.0\"</a>stopelseliestourpack.gifpastcss?graymean&gt;rideshotlatesaidroadvar feeljohnrickportfast'UA-dead</b>poorbilltypeU.S.woodmust2px;Inforankwidewantwalllead[0];paulwavesure$('#waitmassarmsgoesgainlangpaid!-- lockunitrootwalkfirmwifexml\"songtest20pxkindrowstoolfontmailsafestarmapscorerainflowbabyspansays4px;6px;artsfootrealwikiheatsteptriporg/lakeweaktoldFormcastfansbankveryrunsjulytask1px;goalgrewslowedgeid=\"sets5px;.js?40pxif (soonseatnonetubezerosentreedfactintogiftharm18pxcamehillboldzoomvoideasyringfillpeakinitcost3px;jacktagsbitsrolleditknewnear<!--growJSONdutyNamesaleyou lotspainjazzcoldeyesfishwww.risktabsprev10pxrise25pxBlueding300,ballfordearnwildbox.fairlackverspairjunetechif(!pickevil$(\"#warmlorddoespull,000ideadrawhugespotfundburnhrefcellkeystickhourlossfuel12pxsuitdealRSS\"agedgreyGET\"easeaimsgirlaids8px;navygridtips#999warsladycars); }php?helltallwhomzh:\u00E5*/\r\n 100hall.\n\nA7px;pushchat0px;crew*/</hash75pxflatrare && tellcampontolaidmissskiptentfinemalegetsplot400,\r\n\r\ncoolfeet.php<br>ericmostguidbelldeschairmathatom/img&#82luckcent000;tinygonehtmlselldrugFREEnodenick?id=losenullvastwindRSS wearrelybeensamedukenasacapewishgulfT23:hitsslotgatekickblurthey15px''););\">msiewinsbirdsortbetaseekT18:ordstreemall60pxfarm\u00E2\u0080\u0099sboys[0].');\"POSTbearkids);}}marytend(UK)quadzh:\u00E6-siz----prop');\rliftT19:viceandydebt>RSSpoolneckblowT16:doorevalT17:letsfailoralpollnovacolsgene \u00E2\u0080\u0094softrometillross<h3>pourfadepink<tr>mini)|!(minezh:\u00E8barshear00);milk -->ironfreddiskwentsoilputs/js/holyT22:ISBNT20:adamsees<h2>json', 'contT21: RSSloopasiamoon</p>soulLINEfortcartT14:<h1>80px!--<9px;T04:mike:46ZniceinchYorkricezh:\u00E4'));puremageparatonebond:37Z_of_']);000,zh:\u00E7tankyardbowlbush:56ZJava30px\n|}\n%C3%:34ZjeffEXPIcashvisagolfsnowzh:\u00E9quer.csssickmeatmin.binddellhirepicsrent:36ZHTTP-201fotowolfEND xbox:54ZBODYdick;\n}\nexit:35Zvarsbeat'});diet999;anne}}</[i].Langkm\u00C2\u00B2wiretoysaddssealalex;\n\t}echonine.org005)tonyjewssandlegsroof000) 200winegeardogsbootgarycutstyletemption.xmlcockgang$('.50pxPh.Dmiscalanloandeskmileryanunixdisc);}\ndustclip).\n\n70px-200DVDs7]><tapedemoi++)wageeurophiloptsholeFAQsasin-26TlabspetsURL bulkcook;}\r\nHEAD[0])abbrjuan(198leshtwin</i>sonyguysfuckpipe|-\n!002)ndow[1];[];\nLog salt\r\n\t\tbangtrimbath){\r\n00px\n});ko:\u00ECfeesad>\rs:// [];tollplug(){\n{\r\n .js'200pdualboat.JPG);\n}quot);\n\n');\n\r\n}\r201420152016201720182019202020212022202320242025202620272028202920302031203220332034203520362037201320122011201020092008200720062005200420032002200120001999199819971996199519941993199219911990198919881987198619851984198319821981198019791978197719761975197419731972197119701969196819671966196519641963196219611960195919581957195619551954195319521951195010001024139400009999comom\u00C3\u00A1sesteestaperotodohacecadaa\u00C3\u00B1obiend\u00C3\u00ADaas\u00C3\u00ADvidacasootroforosolootracualdijosidograntipotemadebealgoqu\u00C3\u00A9estonadatrespococasabajotodasinoaguapuesunosantediceluisellamayozonaamorpisoobraclicellodioshoracasi\u00D0\u00B7\u00D0\u00B0\u00D0\u00BD\u00D0\u00B0\u00D0\u00BE\u00D0\u00BC\u00D1\u0080\u00D0\u00B0\u00D1\u0080\u00D1\u0083\u00D1\u0082\u00D0\u00B0\u00D0\u00BD\u00D0\u00B5\u00D0\u00BF\u00D0\u00BE\u00D0\u00BE\u00D1\u0082\u00D0\u00B8\u00D0\u00B7\u00D0\u00BD\u00D0\u00BE\u00D0\u00B4\u00D0\u00BE\u00D1\u0082\u00D0\u00BE\u00D0\u00B6\u00D0\u00B5\u00D0\u00BE\u00D0\u00BD\u00D0\u00B8\u00D1\u0085\u00D0\u009D\u00D0\u00B0\u00D0\u00B5\u00D0\u00B5\u00D0\u00B1\u00D1\u008B\u00D0\u00BC\u00D1\u008B\u00D0\u0092\u00D1\u008B\u00D1\u0081\u00D0\u00BE\u00D0\u00B2\u00D1\u008B\u00D0\u00B2\u00D0\u00BE\u00D0\u009D\u00D0\u00BE\u00D0\u00BE\u00D0\u00B1\u00D0\u009F\u00D0\u00BE\u00D0\u00BB\u00D0\u00B8\u00D0\u00BD\u00D0\u00B8\u00D0\u00A0\u00D0\u00A4\u00D0\u009D\u00D0\u00B5\u00D0\u009C\u00D1\u008B\u00D1\u0082\u00D1\u008B\u00D0\u009E\u00D0\u00BD\u00D0\u00B8\u00D0\u00BC\u00D0\u00B4\u00D0\u00B0\u00D0\u0097\u00D0\u00B0\u00D0\u0094\u00D0\u00B0\u00D0\u009D\u00D1\u0083\u00D0\u009E\u00D0\u00B1\u00D1\u0082\u00D0\u00B5\u00D0\u0098\u00D0\u00B7\u00D0\u00B5\u00D0\u00B9\u00D0\u00BD\u00D1\u0083\u00D0\u00BC\u00D0\u00BC\u00D0\u00A2\u00D1\u008B\u00D1\u0083\u00D0\u00B6\u00D9\u0081\u00D9\u008A\u00D8\u00A3\u00D9\u0086\u00D9\u0085\u00D8\u00A7\u00D9\u0085\u00D8\u00B9\u00D9\u0083\u00D9\u0084\u00D8\u00A3\u00D9\u0088\u00D8\u00B1\u00D8\u00AF\u00D9\u008A\u00D8\u00A7\u00D9\u0081\u00D9\u0089\u00D9\u0087\u00D9\u0088\u00D9\u0084\u00D9\u0085\u00D9\u0084\u00D9\u0083\u00D8\u00A7\u00D9\u0088\u00D9\u0084\u00D9\u0087\u00D8\u00A8\u00D8\u00B3\u00D8\u00A7\u00D9\u0084\u00D8\u00A5\u00D9\u0086\u00D9\u0087\u00D9\u008A\u00D8\u00A3\u00D9\u008A\u00D9\u0082\u00D8\u00AF\u00D9\u0087\u00D9\u0084\u00D8\u00AB\u00D9\u0085\u00D8\u00A8\u00D9\u0087\u00D9\u0084\u00D9\u0088\u00D9\u0084\u00D9\u008A\u00D8\u00A8\u00D9\u0084\u00D8\u00A7\u00D9\u008A\u00D8\u00A8\u00D9\u0083\u00D8\u00B4\u00D9\u008A\u00D8\u00A7\u00D9\u0085\u00D8\u00A3\u00D9\u0085\u00D9\u0086\u00D8\u00AA\u00D8\u00A8\u00D9\u008A\u00D9\u0084\u00D9\u0086\u00D8\u00AD\u00D8\u00A8\u00D9\u0087\u00D9\u0085\u00D9\u0085\u00D8\u00B4\u00D9\u0088\u00D8\u00B4firstvideolightworldmediawhitecloseblackrightsmallbooksplacemusicfieldorderpointvalueleveltableboardhousegroupworksyearsstatetodaywaterstartstyledeathpowerphonenighterrorinputabouttermstitletoolseventlocaltimeslargewordsgamesshortspacefocusclearmodelblockguideradiosharewomenagainmoneyimagenamesyounglineslatercolorgreenfront&amp;watchforcepricerulesbeginaftervisitissueareasbelowindextotalhourslabelprintpressbuiltlinksspeedstudytradefoundsenseundershownformsrangeaddedstillmovedtakenaboveflashfixedoftenotherviewschecklegalriveritemsquickshapehumanexistgoingmoviethirdbasicpeacestagewidthloginideaswrotepagesusersdrivestorebreaksouthvoicesitesmonthwherebuildwhichearthforumthreesportpartyClicklowerlivesclasslayerentrystoryusagesoundcourtyour birthpopuptypesapplyImagebeinguppernoteseveryshowsmeansextramatchtrackknownearlybegansuperpapernorthlearngivennamedendedTermspartsGroupbrandusingwomanfalsereadyaudiotakeswhile.com/livedcasesdailychildgreatjudgethoseunitsneverbroadcoastcoverapplefilescyclesceneplansclickwritequeenpieceemailframeolderphotolimitcachecivilscaleenterthemetheretouchboundroyalaskedwholesincestock namefaithheartemptyofferscopeownedmightalbumthinkbloodarraymajortrustcanonunioncountvalidstoneStyleLoginhappyoccurleft:freshquitefilmsgradeneedsurbanfightbasishoverauto;route.htmlmixedfinalYour slidetopicbrownalonedrawnsplitreachRightdatesmarchquotegoodsLinksdoubtasyncthumballowchiefyouthnovel10px;serveuntilhandsCheckSpacequeryjamesequaltwice0,000Startpanelsongsroundeightshiftworthpostsleadsweeksavoidthesemilesplanesmartalphaplantmarksratesplaysclaimsalestextsstarswrong</h3>thing.org/multiheardPowerstandtokensolid(thisbringshipsstafftriedcallsfullyfactsagentThis //-->adminegyptEvent15px;Emailtrue\"crossspentblogsbox\">notedleavechinasizesguest</h4>robotheavytrue,sevengrandcrimesignsawaredancephase><!--en_US&#39;200px_namelatinenjoyajax.ationsmithU.S. holdspeterindianav\">chainscorecomesdoingpriorShare1990sromanlistsjapanfallstrialowneragree</h2>abusealertopera\"-//WcardshillsteamsPhototruthclean.php?saintmetallouismeantproofbriefrow\">genretrucklooksValueFrame.net/-->\n<try {\nvar makescostsplainadultquesttrainlaborhelpscausemagicmotortheir250pxleaststepsCountcouldglasssidesfundshotelawardmouthmovesparisgivesdutchtexasfruitnull,||[];top\">\n<!--POST\"ocean<br/>floorspeakdepth sizebankscatchchart20px;aligndealswould50px;url=\"parksmouseMost ...</amongbrainbody none;basedcarrydraftreferpage_home.meterdelaydreamprovejoint</tr>drugs<!-- aprilidealallenexactforthcodeslogicView seemsblankports (200saved_linkgoalsgrantgreekhomesringsrated30px;whoseparse();\" Blocklinuxjonespixel');\">);if(-leftdavidhorseFocusraiseboxesTrackement</em>bar\">.src=toweralt=\"cablehenry24px;setupitalysharpminortastewantsthis.resetwheelgirls/css/100%;clubsstuffbiblevotes 1000korea});\r\nbandsqueue= {};80px;cking{\r\n\t\taheadclockirishlike ratiostatsForm\"yahoo)[0];Aboutfinds</h1>debugtasksURL =cells})();12px;primetellsturns0x600.jpg\"spainbeachtaxesmicroangel--></giftssteve-linkbody.});\n\tmount (199FAQ</rogerfrankClass28px;feeds<h1><scotttests22px;drink) || lewisshall#039; for lovedwaste00px;ja:\u00E3\u0082simon<fontreplymeetsuntercheaptightBrand) != dressclipsroomsonkeymobilmain.Name platefunnytreescom/\"1.jpgwmodeparamSTARTleft idden, 201);\n}\nform.viruschairtransworstPagesitionpatch<!--\no-cacfirmstours,000 asiani++){adobe')[0]id=10both;menu .2.mi.png\"kevincoachChildbruce2.jpgURL)+.jpg|suitesliceharry120\" sweettr>\r\nname=diegopage swiss-->\n\n#fff;\">Log.com\"treatsheet) && 14px;sleepntentfiledja:\u00E3\u0083id=\"cName\"worseshots-box-delta\n&lt;bears:48Z<data-rural</a> spendbakershops= \"\";php\">ction13px;brianhellosize=o=%2F joinmaybe<img img\">, fjsimg\" \")[0]MTopBType\"newlyDanskczechtrailknows</h5>faq\">zh-cn10);\n-1\");type=bluestrulydavis.js';>\r\n<!steel you h2>\r\nform jesus100% menu.\r\n\t\r\nwalesrisksumentddingb-likteachgif\" vegasdanskeestishqipsuomisobredesdeentretodospuedea\u00C3\u00B1osest\u00C3\u00A1tienehastaotrospartedondenuevohacerformamismomejormundoaqu\u00C3\u00ADd\u00C3\u00ADass\u00C3\u00B3loayudafechatodastantomenosdatosotrassitiomuchoahoralugarmayorestoshorastenerantesfotosestaspa\u00C3\u00ADsnuevasaludforosmedioquienmesespoderchileser\u00C3\u00A1vecesdecirjos\u00C3\u00A9estarventagrupohechoellostengoamigocosasnivelgentemismaairesjuliotemashaciafavorjuniolibrepuntobuenoautorabrilbuenatextomarzosaberlistaluegoc\u00C3\u00B3moenerojuegoper\u00C3\u00BAhaberestoynuncamujervalorfueralibrogustaigualvotoscasosgu\u00C3\u00ADapuedosomosavisousteddebennochebuscafaltaeurosseriedichocursoclavecasasle\u00C3\u00B3nplazolargoobrasvistaapoyojuntotratavistocrearcampohemoscincocargopisosordenhacen\u00C3\u00A1readiscopedrocercapuedapapelmenor\u00C3\u00BAtilclarojorgecalleponertardenadiemarcasigueellassiglocochemotosmadreclaserestoni\u00C3\u00B1oquedapasarbancohijosviajepablo\u00C3\u00A9stevienereinodejarfondocanalnorteletracausatomarmanoslunesautosvillavendopesartipostengamarcollevapadreunidovamoszonasambosbandamariaabusomuchasubirriojavivirgradochicaall\u00C3\u00ADjovendichaestantalessalirsuelopesosfinesllamabusco\u00C3\u00A9stalleganegroplazahumorpagarjuntadobleislasbolsaba\u00C3\u00B1ohablalucha\u00C3\u0081readicenjugarnotasvalleall\u00C3\u00A1cargadolorabajoest\u00C3\u00A9gustomentemariofirmacostofichaplatahogarartesleyesaquelmuseobasespocosmitadcielochicomiedoganarsantoetapadebesplayaredessietecortecoreadudasdeseoviejodeseaaguas&quot;domaincommonstatuseventsmastersystemactionbannerremovescrollupdateglobalmediumfilternumberchangeresultpublicscreenchoosenormaltravelissuessourcetargetspringmodulemobileswitchphotosborderregionitselfsocialactivecolumnrecordfollowtitle>eitherlengthfamilyfriendlayoutauthorcreatereviewsummerserverplayedplayerexpandpolicyformatdoublepointsseriespersonlivingdesignmonthsforcesuniqueweightpeopleenergynaturesearchfigurehavingcustomoffsetletterwindowsubmitrendergroupsuploadhealthmethodvideosschoolfutureshadowdebatevaluesObjectothersrightsleaguechromesimplenoticesharedendingseasonreportonlinesquarebuttonimagesenablemovinglatestwinterFranceperiodstrongrepeatLondondetailformeddemandsecurepassedtoggleplacesdevicestaticcitiesstreamyellowattackstreetflighthiddeninfo\">openedusefulvalleycausesleadersecretseconddamagesportsexceptratingsignedthingseffectfieldsstatesofficevisualeditorvolumeReportmuseummoviesparentaccessmostlymother\" id=\"marketgroundchancesurveybeforesymbolmomentspeechmotioninsidematterCenterobjectexistsmiddleEuropegrowthlegacymannerenoughcareeransweroriginportalclientselectrandomclosedtopicscomingfatheroptionsimplyraisedescapechosenchurchdefinereasoncorneroutputmemoryiframepolicemodelsNumberduringoffersstyleskilledlistedcalledsilvermargindeletebetterbrowselimitsGlobalsinglewidgetcenterbudgetnowrapcreditclaimsenginesafetychoicespirit-stylespreadmakingneededrussiapleaseextentScriptbrokenallowschargedividefactormember-basedtheoryconfigaroundworkedhelpedChurchimpactshouldalwayslogo\" bottomlist\">){var prefixorangeHeader.push(couplegardenbridgelaunchReviewtakingvisionlittledatingButtonbeautythemesforgotSearchanchoralmostloadedChangereturnstringreloadMobileincomesupplySourceordersviewed&nbsp;courseAbout island<html cookiename=\"amazonmodernadvicein</a>: The dialoghousesBEGIN MexicostartscentreheightaddingIslandassetsEmpireSchooleffortdirectnearlymanualSelect.\n\nOnejoinedmenu\">PhilipawardshandleimportOfficeregardskillsnationSportsdegreeweekly (e.g.behinddoctorloggedunited</b></beginsplantsassistartistissued300px|canadaagencyschemeremainBrazilsamplelogo\">beyond-scaleacceptservedmarineFootercamera</h1>\n_form\"leavesstress\" />\r\n.gif\" onloadloaderOxfordsistersurvivlistenfemaleDesignsize=\"appealtext\">levelsthankshigherforcedanimalanyoneAfricaagreedrecentPeople<br />wonderpricesturned|| {};main\">inlinesundaywrap\">failedcensusminutebeaconquotes150px|estateremoteemail\"linkedright;signalformal1.htmlsignupprincefloat:.png\" forum.AccesspaperssoundsextendHeightsliderUTF-8\"&amp; Before. WithstudioownersmanageprofitjQueryannualparamsboughtfamousgooglelongeri++) {israelsayingdecidehome\">headerensurebranchpiecesblock;statedtop\"><racingresize--&gt;pacitysexualbureau.jpg\" 10,000obtaintitlesamount, Inc.comedymenu\" lyricstoday.indeedcounty_logo.FamilylookedMarketlse ifPlayerturkey);var forestgivingerrorsDomain}else{insertBlog</footerlogin.fasteragents<body 10px 0pragmafridayjuniordollarplacedcoversplugin5,000 page\">boston.test(avatartested_countforumsschemaindex,filledsharesreaderalert(appearSubmitline\">body\">\n* TheThoughseeingjerseyNews</verifyexpertinjurywidth=CookieSTART across_imagethreadnativepocketbox\">\nSystem DavidcancertablesprovedApril reallydriveritem\">more\">boardscolorscampusfirst || [];media.guitarfinishwidth:showedOther .php\" assumelayerswilsonstoresreliefswedenCustomeasily your String\n\nWhiltaylorclear:resortfrenchthough\") + \"<body>buyingbrandsMembername\">oppingsector5px;\">vspacepostermajor coffeemartinmaturehappen</nav>kansaslink\">Images=falsewhile hspace0&amp; \n\nIn  powerPolski-colorjordanBottomStart -count2.htmlnews\">01.jpgOnline-rightmillerseniorISBN 00,000 guidesvalue)ectionrepair.xml\"  rights.html-blockregExp:hoverwithinvirginphones</tr>\rusing \n\tvar >');\n\t</td>\n</tr>\nbahasabrasilgalegomagyarpolskisrpski\u00D8\u00B1\u00D8\u00AF\u00D9\u0088\u00E4\u00B8\u00AD\u00E6\u0096\u0087\u00E7\u00AE\u0080\u00E4\u00BD\u0093\u00E7\u00B9\u0081\u00E9\u00AB\u0094\u00E4\u00BF\u00A1\u00E6\u0081\u00AF\u00E4\u00B8\u00AD\u00E5\u009B\u00BD\u00E6\u0088\u0091\u00E4\u00BB\u00AC\u00E4\u00B8\u0080\u00E4\u00B8\u00AA\u00E5\u0085\u00AC\u00E5\u008F\u00B8\u00E7\u00AE\u00A1\u00E7\u0090\u0086\u00E8\u00AE\u00BA\u00E5\u009D\u009B\u00E5\u008F\u00AF\u00E4\u00BB\u00A5\u00E6\u009C\u008D\u00E5\u008A\u00A1\u00E6\u0097\u00B6\u00E9\u0097\u00B4\u00E4\u00B8\u00AA\u00E4\u00BA\u00BA\u00E4\u00BA\u00A7\u00E5\u0093\u0081\u00E8\u0087\u00AA\u00E5\u00B7\u00B1\u00E4\u00BC\u0081\u00E4\u00B8\u009A\u00E6\u009F\u00A5\u00E7\u009C\u008B\u00E5\u00B7\u00A5\u00E4\u00BD\u009C\u00E8\u0081\u0094\u00E7\u00B3\u00BB\u00E6\u00B2\u00A1\u00E6\u009C\u0089\u00E7\u00BD\u0091\u00E7\u00AB\u0099\u00E6\u0089\u0080\u00E6\u009C\u0089\u00E8\u00AF\u0084\u00E8\u00AE\u00BA\u00E4\u00B8\u00AD\u00E5\u00BF\u0083\u00E6\u0096\u0087\u00E7\u00AB\u00A0\u00E7\u0094\u00A8\u00E6\u0088\u00B7\u00E9\u00A6\u0096\u00E9\u00A1\u00B5\u00E4\u00BD\u009C\u00E8\u0080\u0085\u00E6\u008A\u0080\u00E6\u009C\u00AF\u00E9\u0097\u00AE\u00E9\u00A2\u0098\u00E7\u009B\u00B8\u00E5\u0085\u00B3\u00E4\u00B8\u008B\u00E8\u00BD\u00BD\u00E6\u0090\u009C\u00E7\u00B4\u00A2\u00E4\u00BD\u00BF\u00E7\u0094\u00A8\u00E8\u00BD\u00AF\u00E4\u00BB\u00B6\u00E5\u009C\u00A8\u00E7\u00BA\u00BF\u00E4\u00B8\u00BB\u00E9\u00A2\u0098\u00E8\u00B5\u0084\u00E6\u0096\u0099\u00E8\u00A7\u0086\u00E9\u00A2\u0091\u00E5\u009B\u009E\u00E5\u00A4\u008D\u00E6\u00B3\u00A8\u00E5\u0086\u008C\u00E7\u00BD\u0091\u00E7\u00BB\u009C\u00E6\u0094\u00B6\u00E8\u0097\u008F\u00E5\u0086\u0085\u00E5\u00AE\u00B9\u00E6\u008E\u00A8\u00E8\u008D\u0090\u00E5\u00B8\u0082\u00E5\u009C\u00BA\u00E6\u00B6\u0088\u00E6\u0081\u00AF\u00E7\u00A9\u00BA\u00E9\u0097\u00B4\u00E5\u008F\u0091\u00E5\u00B8\u0083\u00E4\u00BB\u0080\u00E4\u00B9\u0088\u00E5\u00A5\u00BD\u00E5\u008F\u008B\u00E7\u0094\u009F\u00E6\u00B4\u00BB\u00E5\u009B\u00BE\u00E7\u0089\u0087\u00E5\u008F\u0091\u00E5\u00B1\u0095\u00E5\u00A6\u0082\u00E6\u009E\u009C\u00E6\u0089\u008B\u00E6\u009C\u00BA\u00E6\u0096\u00B0\u00E9\u0097\u00BB\u00E6\u009C\u0080\u00E6\u0096\u00B0\u00E6\u0096\u00B9\u00E5\u00BC\u008F\u00E5\u008C\u0097\u00E4\u00BA\u00AC\u00E6\u008F\u0090\u00E4\u00BE\u009B\u00E5\u0085\u00B3\u00E4\u00BA\u008E\u00E6\u009B\u00B4\u00E5\u00A4\u009A\u00E8\u00BF\u0099\u00E4\u00B8\u00AA\u00E7\u00B3\u00BB\u00E7\u00BB\u009F\u00E7\u009F\u00A5\u00E9\u0081\u0093\u00E6\u00B8\u00B8\u00E6\u0088\u008F\u00E5\u00B9\u00BF\u00E5\u0091\u008A\u00E5\u0085\u00B6\u00E4\u00BB\u0096\u00E5\u008F\u0091\u00E8\u00A1\u00A8\u00E5\u00AE\u0089\u00E5\u0085\u00A8\u00E7\u00AC\u00AC\u00E4\u00B8\u0080\u00E4\u00BC\u009A\u00E5\u0091\u0098\u00E8\u00BF\u009B\u00E8\u00A1\u008C\u00E7\u0082\u00B9\u00E5\u0087\u00BB\u00E7\u0089\u0088\u00E6\u009D\u0083\u00E7\u0094\u00B5\u00E5\u00AD\u0090\u00E4\u00B8\u0096\u00E7\u0095\u008C\u00E8\u00AE\u00BE\u00E8\u00AE\u00A1\u00E5\u0085\u008D\u00E8\u00B4\u00B9\u00E6\u0095\u0099\u00E8\u0082\u00B2\u00E5\u008A\u00A0\u00E5\u0085\u00A5\u00E6\u00B4\u00BB\u00E5\u008A\u00A8\u00E4\u00BB\u0096\u00E4\u00BB\u00AC\u00E5\u0095\u0086\u00E5\u0093\u0081\u00E5\u008D\u009A\u00E5\u00AE\u00A2\u00E7\u008E\u00B0\u00E5\u009C\u00A8\u00E4\u00B8\u008A\u00E6\u00B5\u00B7\u00E5\u00A6\u0082\u00E4\u00BD\u0095\u00E5\u00B7\u00B2\u00E7\u00BB\u008F\u00E7\u0095\u0099\u00E8\u00A8\u0080\u00E8\u00AF\u00A6\u00E7\u00BB\u0086\u00E7\u00A4\u00BE\u00E5\u008C\u00BA\u00E7\u0099\u00BB\u00E5\u00BD\u0095\u00E6\u009C\u00AC\u00E7\u00AB\u0099\u00E9\u009C\u0080\u00E8\u00A6\u0081\u00E4\u00BB\u00B7\u00E6\u00A0\u00BC\u00E6\u0094\u00AF\u00E6\u008C\u0081\u00E5\u009B\u00BD\u00E9\u0099\u0085\u00E9\u0093\u00BE\u00E6\u008E\u00A5\u00E5\u009B\u00BD\u00E5\u00AE\u00B6\u00E5\u00BB\u00BA\u00E8\u00AE\u00BE\u00E6\u009C\u008B\u00E5\u008F\u008B\u00E9\u0098\u0085\u00E8\u00AF\u00BB\u00E6\u00B3\u0095\u00E5\u00BE\u008B\u00E4\u00BD\u008D\u00E7\u00BD\u00AE\u00E7\u00BB\u008F\u00E6\u00B5\u008E\u00E9\u0080\u0089\u00E6\u008B\u00A9\u00E8\u00BF\u0099\u00E6\u00A0\u00B7\u00E5\u00BD\u0093\u00E5\u0089\u008D\u00E5\u0088\u0086\u00E7\u00B1\u00BB\u00E6\u008E\u0092\u00E8\u00A1\u008C\u00E5\u009B\u00A0\u00E4\u00B8\u00BA\u00E4\u00BA\u00A4\u00E6\u0098\u0093\u00E6\u009C\u0080\u00E5\u0090\u008E\u00E9\u009F\u00B3\u00E4\u00B9\u0090\u00E4\u00B8\u008D\u00E8\u0083\u00BD\u00E9\u0080\u009A\u00E8\u00BF\u0087\u00E8\u00A1\u008C\u00E4\u00B8\u009A\u00E7\u00A7\u0091\u00E6\u008A\u0080\u00E5\u008F\u00AF\u00E8\u0083\u00BD\u00E8\u00AE\u00BE\u00E5\u00A4\u0087\u00E5\u0090\u0088\u00E4\u00BD\u009C\u00E5\u00A4\u00A7\u00E5\u00AE\u00B6\u00E7\u00A4\u00BE\u00E4\u00BC\u009A\u00E7\u00A0\u0094\u00E7\u00A9\u00B6\u00E4\u00B8\u0093\u00E4\u00B8\u009A\u00E5\u0085\u00A8\u00E9\u0083\u00A8\u00E9\u00A1\u00B9\u00E7\u009B\u00AE\u00E8\u00BF\u0099\u00E9\u0087\u008C\u00E8\u00BF\u0098\u00E6\u0098\u00AF\u00E5\u00BC\u0080\u00E5\u00A7\u008B\u00E6\u0083\u0085\u00E5\u0086\u00B5\u00E7\u0094\u00B5\u00E8\u0084\u0091\u00E6\u0096\u0087\u00E4\u00BB\u00B6\u00E5\u0093\u0081\u00E7\u0089\u008C\u00E5\u00B8\u00AE\u00E5\u008A\u00A9\u00E6\u0096\u0087\u00E5\u008C\u0096\u00E8\u00B5\u0084\u00E6\u00BA\u0090\u00E5\u00A4\u00A7\u00E5\u00AD\u00A6\u00E5\u00AD\u00A6\u00E4\u00B9\u00A0\u00E5\u009C\u00B0\u00E5\u009D\u0080\u00E6\u00B5\u008F\u00E8\u00A7\u0088\u00E6\u008A\u0095\u00E8\u00B5\u0084\u00E5\u00B7\u00A5\u00E7\u00A8\u008B\u00E8\u00A6\u0081\u00E6\u00B1\u0082\u00E6\u0080\u008E\u00E4\u00B9\u0088\u00E6\u0097\u00B6\u00E5\u0080\u0099\u00E5\u008A\u009F\u00E8\u0083\u00BD\u00E4\u00B8\u00BB\u00E8\u00A6\u0081\u00E7\u009B\u00AE\u00E5\u0089\u008D\u00E8\u00B5\u0084\u00E8\u00AE\u00AF\u00E5\u009F\u008E\u00E5\u00B8\u0082\u00E6\u0096\u00B9\u00E6\u00B3\u0095\u00E7\u0094\u00B5\u00E5\u00BD\u00B1\u00E6\u008B\u009B\u00E8\u0081\u0098\u00E5\u00A3\u00B0\u00E6\u0098\u008E\u00E4\u00BB\u00BB\u00E4\u00BD\u0095\u00E5\u0081\u00A5\u00E5\u00BA\u00B7\u00E6\u0095\u00B0\u00E6\u008D\u00AE\u00E7\u00BE\u008E\u00E5\u009B\u00BD\u00E6\u00B1\u00BD\u00E8\u00BD\u00A6\u00E4\u00BB\u008B\u00E7\u00BB\u008D\u00E4\u00BD\u0086\u00E6\u0098\u00AF\u00E4\u00BA\u00A4\u00E6\u00B5\u0081\u00E7\u0094\u009F\u00E4\u00BA\u00A7\u00E6\u0089\u0080\u00E4\u00BB\u00A5\u00E7\u0094\u00B5\u00E8\u00AF\u009D\u00E6\u0098\u00BE\u00E7\u00A4\u00BA\u00E4\u00B8\u0080\u00E4\u00BA\u009B\u00E5\u008D\u0095\u00E4\u00BD\u008D\u00E4\u00BA\u00BA\u00E5\u0091\u0098\u00E5\u0088\u0086\u00E6\u009E\u0090\u00E5\u009C\u00B0\u00E5\u009B\u00BE\u00E6\u0097\u0085\u00E6\u00B8\u00B8\u00E5\u00B7\u00A5\u00E5\u0085\u00B7\u00E5\u00AD\u00A6\u00E7\u0094\u009F\u00E7\u00B3\u00BB\u00E5\u0088\u0097\u00E7\u00BD\u0091\u00E5\u008F\u008B\u00E5\u00B8\u0096\u00E5\u00AD\u0090\u00E5\u00AF\u0086\u00E7\u00A0\u0081\u00E9\u00A2\u0091\u00E9\u0081\u0093\u00E6\u008E\u00A7\u00E5\u0088\u00B6\u00E5\u009C\u00B0\u00E5\u008C\u00BA\u00E5\u009F\u00BA\u00E6\u009C\u00AC\u00E5\u0085\u00A8\u00E5\u009B\u00BD\u00E7\u00BD\u0091\u00E4\u00B8\u008A\u00E9\u0087\u008D\u00E8\u00A6\u0081\u00E7\u00AC\u00AC\u00E4\u00BA\u008C\u00E5\u0096\u009C\u00E6\u00AC\u00A2\u00E8\u00BF\u009B\u00E5\u0085\u00A5\u00E5\u008F\u008B\u00E6\u0083\u0085\u00E8\u00BF\u0099\u00E4\u00BA\u009B\u00E8\u0080\u0083\u00E8\u00AF\u0095\u00E5\u008F\u0091\u00E7\u008E\u00B0\u00E5\u009F\u00B9\u00E8\u00AE\u00AD\u00E4\u00BB\u00A5\u00E4\u00B8\u008A\u00E6\u0094\u00BF\u00E5\u00BA\u009C\u00E6\u0088\u0090\u00E4\u00B8\u00BA\u00E7\u008E\u00AF\u00E5\u00A2\u0083\u00E9\u00A6\u0099\u00E6\u00B8\u00AF\u00E5\u0090\u008C\u00E6\u0097\u00B6\u00E5\u00A8\u00B1\u00E4\u00B9\u0090\u00E5\u008F\u0091\u00E9\u0080\u0081\u00E4\u00B8\u0080\u00E5\u00AE\u009A\u00E5\u00BC\u0080\u00E5\u008F\u0091\u00E4\u00BD\u009C\u00E5\u0093\u0081\u00E6\u00A0\u0087\u00E5\u0087\u0086\u00E6\u00AC\u00A2\u00E8\u00BF\u008E\u00E8\u00A7\u00A3\u00E5\u0086\u00B3\u00E5\u009C\u00B0\u00E6\u0096\u00B9\u00E4\u00B8\u0080\u00E4\u00B8\u008B\u00E4\u00BB\u00A5\u00E5\u008F\u008A\u00E8\u00B4\u00A3\u00E4\u00BB\u00BB\u00E6\u0088\u0096\u00E8\u0080\u0085\u00E5\u00AE\u00A2\u00E6\u0088\u00B7\u00E4\u00BB\u00A3\u00E8\u00A1\u00A8\u00E7\u00A7\u00AF\u00E5\u0088\u0086\u00E5\u00A5\u00B3\u00E4\u00BA\u00BA\u00E6\u0095\u00B0\u00E7\u00A0\u0081\u00E9\u0094\u0080\u00E5\u0094\u00AE\u00E5\u0087\u00BA\u00E7\u008E\u00B0\u00E7\u00A6\u00BB\u00E7\u00BA\u00BF\u00E5\u00BA\u0094\u00E7\u0094\u00A8\u00E5\u0088\u0097\u00E8\u00A1\u00A8\u00E4\u00B8\u008D\u00E5\u0090\u008C\u00E7\u00BC\u0096\u00E8\u00BE\u0091\u00E7\u00BB\u009F\u00E8\u00AE\u00A1\u00E6\u009F\u00A5\u00E8\u00AF\u00A2\u00E4\u00B8\u008D\u00E8\u00A6\u0081\u00E6\u009C\u0089\u00E5\u0085\u00B3\u00E6\u009C\u00BA\u00E6\u009E\u0084\u00E5\u00BE\u0088\u00E5\u00A4\u009A\u00E6\u0092\u00AD\u00E6\u0094\u00BE\u00E7\u00BB\u0084\u00E7\u00BB\u0087\u00E6\u0094\u00BF\u00E7\u00AD\u0096\u00E7\u009B\u00B4\u00E6\u008E\u00A5\u00E8\u0083\u00BD\u00E5\u008A\u009B\u00E6\u009D\u00A5\u00E6\u00BA\u0090\u00E6\u0099\u0082\u00E9\u0096\u0093\u00E7\u009C\u008B\u00E5\u0088\u00B0\u00E7\u0083\u00AD\u00E9\u0097\u00A8\u00E5\u0085\u00B3\u00E9\u0094\u00AE\u00E4\u00B8\u0093\u00E5\u008C\u00BA\u00E9\u009D\u009E\u00E5\u00B8\u00B8\u00E8\u008B\u00B1\u00E8\u00AF\u00AD\u00E7\u0099\u00BE\u00E5\u00BA\u00A6\u00E5\u00B8\u008C\u00E6\u009C\u009B\u00E7\u00BE\u008E\u00E5\u00A5\u00B3\u00E6\u00AF\u0094\u00E8\u00BE\u0083\u00E7\u009F\u00A5\u00E8\u00AF\u0086\u00E8\u00A7\u0084\u00E5\u00AE\u009A\u00E5\u00BB\u00BA\u00E8\u00AE\u00AE\u00E9\u0083\u00A8\u00E9\u0097\u00A8\u00E6\u0084\u008F\u00E8\u00A7\u0081\u00E7\u00B2\u00BE\u00E5\u00BD\u00A9\u00E6\u0097\u00A5\u00E6\u009C\u00AC\u00E6\u008F\u0090\u00E9\u00AB\u0098\u00E5\u008F\u0091\u00E8\u00A8\u0080\u00E6\u0096\u00B9\u00E9\u009D\u00A2\u00E5\u009F\u00BA\u00E9\u0087\u0091\u00E5\u00A4\u0084\u00E7\u0090\u0086\u00E6\u009D\u0083\u00E9\u0099\u0090\u00E5\u00BD\u00B1\u00E7\u0089\u0087\u00E9\u0093\u00B6\u00E8\u00A1\u008C\u00E8\u00BF\u0098\u00E6\u009C\u0089\u00E5\u0088\u0086\u00E4\u00BA\u00AB\u00E7\u0089\u00A9\u00E5\u0093\u0081\u00E7\u00BB\u008F\u00E8\u0090\u00A5\u00E6\u00B7\u00BB\u00E5\u008A\u00A0\u00E4\u00B8\u0093\u00E5\u00AE\u00B6\u00E8\u00BF\u0099\u00E7\u00A7\u008D\u00E8\u00AF\u009D\u00E9\u00A2\u0098\u00E8\u00B5\u00B7\u00E6\u009D\u00A5\u00E4\u00B8\u009A\u00E5\u008A\u00A1\u00E5\u0085\u00AC\u00E5\u0091\u008A\u00E8\u00AE\u00B0\u00E5\u00BD\u0095\u00E7\u00AE\u0080\u00E4\u00BB\u008B\u00E8\u00B4\u00A8\u00E9\u0087\u008F\u00E7\u0094\u00B7\u00E4\u00BA\u00BA\u00E5\u00BD\u00B1\u00E5\u0093\u008D\u00E5\u00BC\u0095\u00E7\u0094\u00A8\u00E6\u008A\u00A5\u00E5\u0091\u008A\u00E9\u0083\u00A8\u00E5\u0088\u0086\u00E5\u00BF\u00AB\u00E9\u0080\u009F\u00E5\u0092\u00A8\u00E8\u00AF\u00A2\u00E6\u0097\u00B6\u00E5\u00B0\u009A\u00E6\u00B3\u00A8\u00E6\u0084\u008F\u00E7\u0094\u00B3\u00E8\u00AF\u00B7\u00E5\u00AD\u00A6\u00E6\u00A0\u00A1\u00E5\u00BA\u0094\u00E8\u00AF\u00A5\u00E5\u008E\u0086\u00E5\u008F\u00B2\u00E5\u008F\u00AA\u00E6\u0098\u00AF\u00E8\u00BF\u0094\u00E5\u009B\u009E\u00E8\u00B4\u00AD\u00E4\u00B9\u00B0\u00E5\u0090\u008D\u00E7\u00A7\u00B0\u00E4\u00B8\u00BA\u00E4\u00BA\u0086\u00E6\u0088\u0090\u00E5\u008A\u009F\u00E8\u00AF\u00B4\u00E6\u0098\u008E\u00E4\u00BE\u009B\u00E5\u00BA\u0094\u00E5\u00AD\u00A9\u00E5\u00AD\u0090\u00E4\u00B8\u0093\u00E9\u00A2\u0098\u00E7\u00A8\u008B\u00E5\u00BA\u008F\u00E4\u00B8\u0080\u00E8\u0088\u00AC\u00E6\u009C\u0083\u00E5\u0093\u00A1\u00E5\u008F\u00AA\u00E6\u009C\u0089\u00E5\u0085\u00B6\u00E5\u00AE\u0083\u00E4\u00BF\u009D\u00E6\u008A\u00A4\u00E8\u0080\u008C\u00E4\u00B8\u0094\u00E4\u00BB\u008A\u00E5\u00A4\u00A9\u00E7\u00AA\u0097\u00E5\u008F\u00A3\u00E5\u008A\u00A8\u00E6\u0080\u0081\u00E7\u008A\u00B6\u00E6\u0080\u0081\u00E7\u0089\u00B9\u00E5\u0088\u00AB\u00E8\u00AE\u00A4\u00E4\u00B8\u00BA\u00E5\u00BF\u0085\u00E9\u00A1\u00BB\u00E6\u009B\u00B4\u00E6\u0096\u00B0\u00E5\u00B0\u008F\u00E8\u00AF\u00B4\u00E6\u0088\u0091\u00E5\u0080\u0091\u00E4\u00BD\u009C\u00E4\u00B8\u00BA\u00E5\u00AA\u0092\u00E4\u00BD\u0093\u00E5\u008C\u0085\u00E6\u008B\u00AC\u00E9\u0082\u00A3\u00E4\u00B9\u0088\u00E4\u00B8\u0080\u00E6\u00A0\u00B7\u00E5\u009B\u00BD\u00E5\u0086\u0085\u00E6\u0098\u00AF\u00E5\u0090\u00A6\u00E6\u00A0\u00B9\u00E6\u008D\u00AE\u00E7\u0094\u00B5\u00E8\u00A7\u0086\u00E5\u00AD\u00A6\u00E9\u0099\u00A2\u00E5\u0085\u00B7\u00E6\u009C\u0089\u00E8\u00BF\u0087\u00E7\u00A8\u008B\u00E7\u0094\u00B1\u00E4\u00BA\u008E\u00E4\u00BA\u00BA\u00E6\u0089\u008D\u00E5\u0087\u00BA\u00E6\u009D\u00A5\u00E4\u00B8\u008D\u00E8\u00BF\u0087\u00E6\u00AD\u00A3\u00E5\u009C\u00A8\u00E6\u0098\u008E\u00E6\u0098\u009F\u00E6\u0095\u0085\u00E4\u00BA\u008B\u00E5\u0085\u00B3\u00E7\u00B3\u00BB\u00E6\u00A0\u0087\u00E9\u00A2\u0098\u00E5\u0095\u0086\u00E5\u008A\u00A1\u00E8\u00BE\u0093\u00E5\u0085\u00A5\u00E4\u00B8\u0080\u00E7\u009B\u00B4\u00E5\u009F\u00BA\u00E7\u00A1\u0080\u00E6\u0095\u0099\u00E5\u00AD\u00A6\u00E4\u00BA\u0086\u00E8\u00A7\u00A3\u00E5\u00BB\u00BA\u00E7\u00AD\u0091\u00E7\u00BB\u0093\u00E6\u009E\u009C\u00E5\u0085\u00A8\u00E7\u0090\u0083\u00E9\u0080\u009A\u00E7\u009F\u00A5\u00E8\u00AE\u00A1\u00E5\u0088\u0092\u00E5\u00AF\u00B9\u00E4\u00BA\u008E\u00E8\u0089\u00BA\u00E6\u009C\u00AF\u00E7\u009B\u00B8\u00E5\u0086\u008C\u00E5\u008F\u0091\u00E7\u0094\u009F\u00E7\u009C\u009F\u00E7\u009A\u0084\u00E5\u00BB\u00BA\u00E7\u00AB\u008B\u00E7\u00AD\u0089\u00E7\u00BA\u00A7\u00E7\u00B1\u00BB\u00E5\u009E\u008B\u00E7\u00BB\u008F\u00E9\u00AA\u008C\u00E5\u00AE\u009E\u00E7\u008E\u00B0\u00E5\u0088\u00B6\u00E4\u00BD\u009C\u00E6\u009D\u00A5\u00E8\u0087\u00AA\u00E6\u00A0\u0087\u00E7\u00AD\u00BE\u00E4\u00BB\u00A5\u00E4\u00B8\u008B\u00E5\u008E\u009F\u00E5\u0088\u009B\u00E6\u0097\u00A0\u00E6\u00B3\u0095\u00E5\u0085\u00B6\u00E4\u00B8\u00AD\u00E5\u0080\u008B\u00E4\u00BA\u00BA\u00E4\u00B8\u0080\u00E5\u0088\u0087\u00E6\u008C\u0087\u00E5\u008D\u0097\u00E5\u0085\u00B3\u00E9\u0097\u00AD\u00E9\u009B\u0086\u00E5\u009B\u00A2\u00E7\u00AC\u00AC\u00E4\u00B8\u0089\u00E5\u0085\u00B3\u00E6\u00B3\u00A8\u00E5\u009B\u00A0\u00E6\u00AD\u00A4\u00E7\u0085\u00A7\u00E7\u0089\u0087\u00E6\u00B7\u00B1\u00E5\u009C\u00B3\u00E5\u0095\u0086\u00E4\u00B8\u009A\u00E5\u00B9\u00BF\u00E5\u00B7\u009E\u00E6\u0097\u00A5\u00E6\u009C\u009F\u00E9\u00AB\u0098\u00E7\u00BA\u00A7\u00E6\u009C\u0080\u00E8\u00BF\u0091\u00E7\u00BB\u00BC\u00E5\u0090\u0088\u00E8\u00A1\u00A8\u00E7\u00A4\u00BA\u00E4\u00B8\u0093\u00E8\u00BE\u0091\u00E8\u00A1\u008C\u00E4\u00B8\u00BA\u00E4\u00BA\u00A4\u00E9\u0080\u009A\u00E8\u00AF\u0084\u00E4\u00BB\u00B7\u00E8\u00A7\u0089\u00E5\u00BE\u0097\u00E7\u00B2\u00BE\u00E5\u008D\u008E\u00E5\u00AE\u00B6\u00E5\u00BA\u00AD\u00E5\u00AE\u008C\u00E6\u0088\u0090\u00E6\u0084\u009F\u00E8\u00A7\u0089\u00E5\u00AE\u0089\u00E8\u00A3\u0085\u00E5\u00BE\u0097\u00E5\u0088\u00B0\u00E9\u0082\u00AE\u00E4\u00BB\u00B6\u00E5\u0088\u00B6\u00E5\u00BA\u00A6\u00E9\u00A3\u009F\u00E5\u0093\u0081\u00E8\u0099\u00BD\u00E7\u0084\u00B6\u00E8\u00BD\u00AC\u00E8\u00BD\u00BD\u00E6\u008A\u00A5\u00E4\u00BB\u00B7\u00E8\u00AE\u00B0\u00E8\u0080\u0085\u00E6\u0096\u00B9\u00E6\u00A1\u0088\u00E8\u00A1\u008C\u00E6\u0094\u00BF\u00E4\u00BA\u00BA\u00E6\u00B0\u0091\u00E7\u0094\u00A8\u00E5\u0093\u0081\u00E4\u00B8\u009C\u00E8\u00A5\u00BF\u00E6\u008F\u0090\u00E5\u0087\u00BA\u00E9\u0085\u0092\u00E5\u00BA\u0097\u00E7\u0084\u00B6\u00E5\u0090\u008E\u00E4\u00BB\u0098\u00E6\u00AC\u00BE\u00E7\u0083\u00AD\u00E7\u0082\u00B9\u00E4\u00BB\u00A5\u00E5\u0089\u008D\u00E5\u00AE\u008C\u00E5\u0085\u00A8\u00E5\u008F\u0091\u00E5\u00B8\u0096\u00E8\u00AE\u00BE\u00E7\u00BD\u00AE\u00E9\u00A2\u0086\u00E5\u00AF\u00BC\u00E5\u00B7\u00A5\u00E4\u00B8\u009A\u00E5\u008C\u00BB\u00E9\u0099\u00A2\u00E7\u009C\u008B\u00E7\u009C\u008B\u00E7\u00BB\u008F\u00E5\u0085\u00B8\u00E5\u008E\u009F\u00E5\u009B\u00A0\u00E5\u00B9\u00B3\u00E5\u008F\u00B0\u00E5\u0090\u0084\u00E7\u00A7\u008D\u00E5\u00A2\u009E\u00E5\u008A\u00A0\u00E6\u009D\u0090\u00E6\u0096\u0099\u00E6\u0096\u00B0\u00E5\u00A2\u009E\u00E4\u00B9\u008B\u00E5\u0090\u008E\u00E8\u0081\u008C\u00E4\u00B8\u009A\u00E6\u0095\u0088\u00E6\u009E\u009C\u00E4\u00BB\u008A\u00E5\u00B9\u00B4\u00E8\u00AE\u00BA\u00E6\u0096\u0087\u00E6\u0088\u0091\u00E5\u009B\u00BD\u00E5\u0091\u008A\u00E8\u00AF\u0089\u00E7\u0089\u0088\u00E4\u00B8\u00BB\u00E4\u00BF\u00AE\u00E6\u0094\u00B9\u00E5\u008F\u0082\u00E4\u00B8\u008E\u00E6\u0089\u0093\u00E5\u008D\u00B0\u00E5\u00BF\u00AB\u00E4\u00B9\u0090\u00E6\u009C\u00BA\u00E6\u00A2\u00B0\u00E8\u00A7\u0082\u00E7\u0082\u00B9\u00E5\u00AD\u0098\u00E5\u009C\u00A8\u00E7\u00B2\u00BE\u00E7\u00A5\u009E\u00E8\u008E\u00B7\u00E5\u00BE\u0097\u00E5\u0088\u00A9\u00E7\u0094\u00A8\u00E7\u00BB\u00A7\u00E7\u00BB\u00AD\u00E4\u00BD\u00A0\u00E4\u00BB\u00AC\u00E8\u00BF\u0099\u00E4\u00B9\u0088\u00E6\u00A8\u00A1\u00E5\u00BC\u008F\u00E8\u00AF\u00AD\u00E8\u00A8\u0080\u00E8\u0083\u00BD\u00E5\u00A4\u009F\u00E9\u009B\u0085\u00E8\u0099\u008E\u00E6\u0093\u008D\u00E4\u00BD\u009C\u00E9\u00A3\u008E\u00E6\u00A0\u00BC\u00E4\u00B8\u0080\u00E8\u00B5\u00B7\u00E7\u00A7\u0091\u00E5\u00AD\u00A6\u00E4\u00BD\u0093\u00E8\u0082\u00B2\u00E7\u009F\u00AD\u00E4\u00BF\u00A1\u00E6\u009D\u00A1\u00E4\u00BB\u00B6\u00E6\u00B2\u00BB\u00E7\u0096\u0097\u00E8\u00BF\u0090\u00E5\u008A\u00A8\u00E4\u00BA\u00A7\u00E4\u00B8\u009A\u00E4\u00BC\u009A\u00E8\u00AE\u00AE\u00E5\u00AF\u00BC\u00E8\u0088\u00AA\u00E5\u0085\u0088\u00E7\u0094\u009F\u00E8\u0081\u0094\u00E7\u009B\u009F\u00E5\u008F\u00AF\u00E6\u0098\u00AF\u00E5\u0095\u008F\u00E9\u00A1\u008C\u00E7\u00BB\u0093\u00E6\u009E\u0084\u00E4\u00BD\u009C\u00E7\u0094\u00A8\u00E8\u00B0\u0083\u00E6\u009F\u00A5\u00E8\u00B3\u0087\u00E6\u0096\u0099\u00E8\u0087\u00AA\u00E5\u008A\u00A8\u00E8\u00B4\u009F\u00E8\u00B4\u00A3\u00E5\u0086\u009C\u00E4\u00B8\u009A\u00E8\u00AE\u00BF\u00E9\u0097\u00AE\u00E5\u00AE\u009E\u00E6\u0096\u00BD\u00E6\u008E\u00A5\u00E5\u008F\u0097\u00E8\u00AE\u00A8\u00E8\u00AE\u00BA\u00E9\u0082\u00A3\u00E4\u00B8\u00AA\u00E5\u008F\u008D\u00E9\u00A6\u0088\u00E5\u008A\u00A0\u00E5\u00BC\u00BA\u00E5\u00A5\u00B3\u00E6\u0080\u00A7\u00E8\u008C\u0083\u00E5\u009B\u00B4\u00E6\u009C\u008D\u00E5\u008B\u0099\u00E4\u00BC\u0091\u00E9\u0097\u00B2\u00E4\u00BB\u008A\u00E6\u0097\u00A5\u00E5\u00AE\u00A2\u00E6\u009C\u008D\u00E8\u00A7\u0080\u00E7\u009C\u008B\u00E5\u008F\u0082\u00E5\u008A\u00A0\u00E7\u009A\u0084\u00E8\u00AF\u009D\u00E4\u00B8\u0080\u00E7\u0082\u00B9\u00E4\u00BF\u009D\u00E8\u00AF\u0081\u00E5\u009B\u00BE\u00E4\u00B9\u00A6\u00E6\u009C\u0089\u00E6\u0095\u0088\u00E6\u00B5\u008B\u00E8\u00AF\u0095\u00E7\u00A7\u00BB\u00E5\u008A\u00A8\u00E6\u0089\u008D\u00E8\u0083\u00BD\u00E5\u0086\u00B3\u00E5\u00AE\u009A\u00E8\u0082\u00A1\u00E7\u00A5\u00A8\u00E4\u00B8\u008D\u00E6\u0096\u00AD\u00E9\u009C\u0080\u00E6\u00B1\u0082\u00E4\u00B8\u008D\u00E5\u00BE\u0097\u00E5\u008A\u009E\u00E6\u00B3\u0095\u00E4\u00B9\u008B\u00E9\u0097\u00B4\u00E9\u0087\u0087\u00E7\u0094\u00A8\u00E8\u0090\u00A5\u00E9\u0094\u0080\u00E6\u008A\u0095\u00E8\u00AF\u0089\u00E7\u009B\u00AE\u00E6\u00A0\u0087\u00E7\u0088\u00B1\u00E6\u0083\u0085\u00E6\u0091\u0084\u00E5\u00BD\u00B1\u00E6\u009C\u0089\u00E4\u00BA\u009B\u00E8\u00A4\u0087\u00E8\u00A3\u00BD\u00E6\u0096\u0087\u00E5\u00AD\u00A6\u00E6\u009C\u00BA\u00E4\u00BC\u009A\u00E6\u0095\u00B0\u00E5\u00AD\u0097\u00E8\u00A3\u0085\u00E4\u00BF\u00AE\u00E8\u00B4\u00AD\u00E7\u0089\u00A9\u00E5\u0086\u009C\u00E6\u009D\u0091\u00E5\u0085\u00A8\u00E9\u009D\u00A2\u00E7\u00B2\u00BE\u00E5\u0093\u0081\u00E5\u0085\u00B6\u00E5\u00AE\u009E\u00E4\u00BA\u008B\u00E6\u0083\u0085\u00E6\u00B0\u00B4\u00E5\u00B9\u00B3\u00E6\u008F\u0090\u00E7\u00A4\u00BA\u00E4\u00B8\u008A\u00E5\u00B8\u0082\u00E8\u00B0\u00A2\u00E8\u00B0\u00A2\u00E6\u0099\u00AE\u00E9\u0080\u009A\u00E6\u0095\u0099\u00E5\u00B8\u0088\u00E4\u00B8\u008A\u00E4\u00BC\u00A0\u00E7\u00B1\u00BB\u00E5\u0088\u00AB\u00E6\u00AD\u008C\u00E6\u009B\u00B2\u00E6\u008B\u00A5\u00E6\u009C\u0089\u00E5\u0088\u009B\u00E6\u0096\u00B0\u00E9\u0085\u008D\u00E4\u00BB\u00B6\u00E5\u008F\u00AA\u00E8\u00A6\u0081\u00E6\u0097\u00B6\u00E4\u00BB\u00A3\u00E8\u00B3\u0087\u00E8\u00A8\u008A\u00E8\u00BE\u00BE\u00E5\u0088\u00B0\u00E4\u00BA\u00BA\u00E7\u0094\u009F\u00E8\u00AE\u00A2\u00E9\u0098\u0085\u00E8\u0080\u0081\u00E5\u00B8\u0088\u00E5\u00B1\u0095\u00E7\u00A4\u00BA\u00E5\u00BF\u0083\u00E7\u0090\u0086\u00E8\u00B4\u00B4\u00E5\u00AD\u0090\u00E7\u00B6\u00B2\u00E7\u00AB\u0099\u00E4\u00B8\u00BB\u00E9\u00A1\u008C\u00E8\u0087\u00AA\u00E7\u0084\u00B6\u00E7\u00BA\u00A7\u00E5\u0088\u00AB\u00E7\u00AE\u0080\u00E5\u008D\u0095\u00E6\u0094\u00B9\u00E9\u009D\u00A9\u00E9\u0082\u00A3\u00E4\u00BA\u009B\u00E6\u009D\u00A5\u00E8\u00AF\u00B4\u00E6\u0089\u0093\u00E5\u00BC\u0080\u00E4\u00BB\u00A3\u00E7\u00A0\u0081\u00E5\u0088\u00A0\u00E9\u0099\u00A4\u00E8\u00AF\u0081\u00E5\u0088\u00B8\u00E8\u008A\u0082\u00E7\u009B\u00AE\u00E9\u0087\u008D\u00E7\u0082\u00B9\u00E6\u00AC\u00A1\u00E6\u0095\u00B8\u00E5\u00A4\u009A\u00E5\u00B0\u0091\u00E8\u00A7\u0084\u00E5\u0088\u0092\u00E8\u00B5\u0084\u00E9\u0087\u0091\u00E6\u0089\u00BE\u00E5\u0088\u00B0\u00E4\u00BB\u00A5\u00E5\u0090\u008E\u00E5\u00A4\u00A7\u00E5\u0085\u00A8\u00E4\u00B8\u00BB\u00E9\u00A1\u00B5\u00E6\u009C\u0080\u00E4\u00BD\u00B3\u00E5\u009B\u009E\u00E7\u00AD\u0094\u00E5\u00A4\u00A9\u00E4\u00B8\u008B\u00E4\u00BF\u009D\u00E9\u009A\u009C\u00E7\u008E\u00B0\u00E4\u00BB\u00A3\u00E6\u00A3\u0080\u00E6\u009F\u00A5\u00E6\u008A\u0095\u00E7\u00A5\u00A8\u00E5\u00B0\u008F\u00E6\u0097\u00B6\u00E6\u00B2\u0092\u00E6\u009C\u0089\u00E6\u00AD\u00A3\u00E5\u00B8\u00B8\u00E7\u0094\u009A\u00E8\u0087\u00B3\u00E4\u00BB\u00A3\u00E7\u0090\u0086\u00E7\u009B\u00AE\u00E5\u00BD\u0095\u00E5\u0085\u00AC\u00E5\u00BC\u0080\u00E5\u00A4\u008D\u00E5\u0088\u00B6\u00E9\u0087\u0091\u00E8\u009E\u008D\u00E5\u00B9\u00B8\u00E7\u00A6\u008F\u00E7\u0089\u0088\u00E6\u009C\u00AC\u00E5\u00BD\u00A2\u00E6\u0088\u0090\u00E5\u0087\u0086\u00E5\u00A4\u0087\u00E8\u00A1\u008C\u00E6\u0083\u0085\u00E5\u009B\u009E\u00E5\u0088\u00B0\u00E6\u0080\u009D\u00E6\u0083\u00B3\u00E6\u0080\u008E\u00E6\u00A0\u00B7\u00E5\u008D\u008F\u00E8\u00AE\u00AE\u00E8\u00AE\u00A4\u00E8\u00AF\u0081\u00E6\u009C\u0080\u00E5\u00A5\u00BD\u00E4\u00BA\u00A7\u00E7\u0094\u009F\u00E6\u008C\u0089\u00E7\u0085\u00A7\u00E6\u009C\u008D\u00E8\u00A3\u0085\u00E5\u00B9\u00BF\u00E4\u00B8\u009C\u00E5\u008A\u00A8\u00E6\u00BC\u00AB\u00E9\u0087\u0087\u00E8\u00B4\u00AD\u00E6\u0096\u00B0\u00E6\u0089\u008B\u00E7\u00BB\u0084\u00E5\u009B\u00BE\u00E9\u009D\u00A2\u00E6\u009D\u00BF\u00E5\u008F\u0082\u00E8\u0080\u0083\u00E6\u0094\u00BF\u00E6\u00B2\u00BB\u00E5\u00AE\u00B9\u00E6\u0098\u0093\u00E5\u00A4\u00A9\u00E5\u009C\u00B0\u00E5\u008A\u00AA\u00E5\u008A\u009B\u00E4\u00BA\u00BA\u00E4\u00BB\u00AC\u00E5\u008D\u0087\u00E7\u00BA\u00A7\u00E9\u0080\u009F\u00E5\u00BA\u00A6\u00E4\u00BA\u00BA\u00E7\u0089\u00A9\u00E8\u00B0\u0083\u00E6\u0095\u00B4\u00E6\u00B5\u0081\u00E8\u00A1\u008C\u00E9\u0080\u00A0\u00E6\u0088\u0090\u00E6\u0096\u0087\u00E5\u00AD\u0097\u00E9\u009F\u00A9\u00E5\u009B\u00BD\u00E8\u00B4\u00B8\u00E6\u0098\u0093\u00E5\u00BC\u0080\u00E5\u00B1\u0095\u00E7\u009B\u00B8\u00E9\u0097\u009C\u00E8\u00A1\u00A8\u00E7\u008E\u00B0\u00E5\u00BD\u00B1\u00E8\u00A7\u0086\u00E5\u00A6\u0082\u00E6\u00AD\u00A4\u00E7\u00BE\u008E\u00E5\u00AE\u00B9\u00E5\u00A4\u00A7\u00E5\u00B0\u008F\u00E6\u008A\u00A5\u00E9\u0081\u0093\u00E6\u009D\u00A1\u00E6\u00AC\u00BE\u00E5\u00BF\u0083\u00E6\u0083\u0085\u00E8\u00AE\u00B8\u00E5\u00A4\u009A\u00E6\u00B3\u0095\u00E8\u00A7\u0084\u00E5\u00AE\u00B6\u00E5\u00B1\u0085\u00E4\u00B9\u00A6\u00E5\u00BA\u0097\u00E8\u00BF\u009E\u00E6\u008E\u00A5\u00E7\u00AB\u008B\u00E5\u008D\u00B3\u00E4\u00B8\u00BE\u00E6\u008A\u00A5\u00E6\u008A\u0080\u00E5\u00B7\u00A7\u00E5\u00A5\u00A5\u00E8\u00BF\u0090\u00E7\u0099\u00BB\u00E5\u0085\u00A5\u00E4\u00BB\u00A5\u00E6\u009D\u00A5\u00E7\u0090\u0086\u00E8\u00AE\u00BA\u00E4\u00BA\u008B\u00E4\u00BB\u00B6\u00E8\u0087\u00AA\u00E7\u0094\u00B1\u00E4\u00B8\u00AD\u00E5\u008D\u008E\u00E5\u008A\u009E\u00E5\u0085\u00AC\u00E5\u00A6\u0088\u00E5\u00A6\u0088\u00E7\u009C\u009F\u00E6\u00AD\u00A3\u00E4\u00B8\u008D\u00E9\u0094\u0099\u00E5\u0085\u00A8\u00E6\u0096\u0087\u00E5\u0090\u0088\u00E5\u0090\u008C\u00E4\u00BB\u00B7\u00E5\u0080\u00BC\u00E5\u0088\u00AB\u00E4\u00BA\u00BA\u00E7\u009B\u0091\u00E7\u009D\u00A3\u00E5\u0085\u00B7\u00E4\u00BD\u0093\u00E4\u00B8\u0096\u00E7\u00BA\u00AA\u00E5\u009B\u00A2\u00E9\u0098\u009F\u00E5\u0088\u009B\u00E4\u00B8\u009A\u00E6\u0089\u00BF\u00E6\u008B\u0085\u00E5\u00A2\u009E\u00E9\u0095\u00BF\u00E6\u009C\u0089\u00E4\u00BA\u00BA\u00E4\u00BF\u009D\u00E6\u008C\u0081\u00E5\u0095\u0086\u00E5\u00AE\u00B6\u00E7\u00BB\u00B4\u00E4\u00BF\u00AE\u00E5\u008F\u00B0\u00E6\u00B9\u00BE\u00E5\u00B7\u00A6\u00E5\u008F\u00B3\u00E8\u0082\u00A1\u00E4\u00BB\u00BD\u00E7\u00AD\u0094\u00E6\u00A1\u0088\u00E5\u00AE\u009E\u00E9\u0099\u0085\u00E7\u0094\u00B5\u00E4\u00BF\u00A1\u00E7\u00BB\u008F\u00E7\u0090\u0086\u00E7\u0094\u009F\u00E5\u0091\u00BD\u00E5\u00AE\u00A3\u00E4\u00BC\u00A0\u00E4\u00BB\u00BB\u00E5\u008A\u00A1\u00E6\u00AD\u00A3\u00E5\u00BC\u008F\u00E7\u0089\u00B9\u00E8\u0089\u00B2\u00E4\u00B8\u008B\u00E6\u009D\u00A5\u00E5\u008D\u008F\u00E4\u00BC\u009A\u00E5\u008F\u00AA\u00E8\u0083\u00BD\u00E5\u00BD\u0093\u00E7\u0084\u00B6\u00E9\u0087\u008D\u00E6\u0096\u00B0\u00E5\u0085\u00A7\u00E5\u00AE\u00B9\u00E6\u008C\u0087\u00E5\u00AF\u00BC\u00E8\u00BF\u0090\u00E8\u00A1\u008C\u00E6\u0097\u00A5\u00E5\u00BF\u0097\u00E8\u00B3\u00A3\u00E5\u00AE\u00B6\u00E8\u00B6\u0085\u00E8\u00BF\u0087\u00E5\u009C\u009F\u00E5\u009C\u00B0\u00E6\u00B5\u0099\u00E6\u00B1\u009F\u00E6\u0094\u00AF\u00E4\u00BB\u0098\u00E6\u008E\u00A8\u00E5\u0087\u00BA\u00E7\u00AB\u0099\u00E9\u0095\u00BF\u00E6\u009D\u00AD\u00E5\u00B7\u009E\u00E6\u0089\u00A7\u00E8\u00A1\u008C\u00E5\u0088\u00B6\u00E9\u0080\u00A0\u00E4\u00B9\u008B\u00E4\u00B8\u0080\u00E6\u008E\u00A8\u00E5\u00B9\u00BF\u00E7\u008E\u00B0\u00E5\u009C\u00BA\u00E6\u008F\u008F\u00E8\u00BF\u00B0\u00E5\u008F\u0098\u00E5\u008C\u0096\u00E4\u00BC\u00A0\u00E7\u00BB\u009F\u00E6\u00AD\u008C\u00E6\u0089\u008B\u00E4\u00BF\u009D\u00E9\u0099\u00A9\u00E8\u00AF\u00BE\u00E7\u00A8\u008B\u00E5\u008C\u00BB\u00E7\u0096\u0097\u00E7\u00BB\u008F\u00E8\u00BF\u0087\u00E8\u00BF\u0087\u00E5\u008E\u00BB\u00E4\u00B9\u008B\u00E5\u0089\u008D\u00E6\u0094\u00B6\u00E5\u0085\u00A5\u00E5\u00B9\u00B4\u00E5\u00BA\u00A6\u00E6\u009D\u0082\u00E5\u00BF\u0097\u00E7\u00BE\u008E\u00E4\u00B8\u00BD\u00E6\u009C\u0080\u00E9\u00AB\u0098\u00E7\u0099\u00BB\u00E9\u0099\u0086\u00E6\u009C\u00AA\u00E6\u009D\u00A5\u00E5\u008A\u00A0\u00E5\u00B7\u00A5\u00E5\u0085\u008D\u00E8\u00B4\u00A3\u00E6\u0095\u0099\u00E7\u00A8\u008B\u00E7\u0089\u0088\u00E5\u009D\u0097\u00E8\u00BA\u00AB\u00E4\u00BD\u0093\u00E9\u0087\u008D\u00E5\u00BA\u0086\u00E5\u0087\u00BA\u00E5\u0094\u00AE\u00E6\u0088\u0090\u00E6\u009C\u00AC\u00E5\u00BD\u00A2\u00E5\u00BC\u008F\u00E5\u009C\u009F\u00E8\u00B1\u0086\u00E5\u0087\u00BA\u00E5\u0083\u00B9\u00E4\u00B8\u009C\u00E6\u0096\u00B9\u00E9\u0082\u00AE\u00E7\u00AE\u00B1\u00E5\u008D\u0097\u00E4\u00BA\u00AC\u00E6\u00B1\u0082\u00E8\u0081\u008C\u00E5\u008F\u0096\u00E5\u00BE\u0097\u00E8\u0081\u008C\u00E4\u00BD\u008D\u00E7\u009B\u00B8\u00E4\u00BF\u00A1\u00E9\u00A1\u00B5\u00E9\u009D\u00A2\u00E5\u0088\u0086\u00E9\u0092\u009F\u00E7\u00BD\u0091\u00E9\u00A1\u00B5\u00E7\u00A1\u00AE\u00E5\u00AE\u009A\u00E5\u009B\u00BE\u00E4\u00BE\u008B\u00E7\u00BD\u0091\u00E5\u009D\u0080\u00E7\u00A7\u00AF\u00E6\u009E\u0081\u00E9\u0094\u0099\u00E8\u00AF\u00AF\u00E7\u009B\u00AE\u00E7\u009A\u0084\u00E5\u00AE\u009D\u00E8\u00B4\u009D\u00E6\u009C\u00BA\u00E5\u0085\u00B3\u00E9\u00A3\u008E\u00E9\u0099\u00A9\u00E6\u008E\u0088\u00E6\u009D\u0083\u00E7\u0097\u0085\u00E6\u00AF\u0092\u00E5\u00AE\u00A0\u00E7\u0089\u00A9\u00E9\u0099\u00A4\u00E4\u00BA\u0086\u00E8\u00A9\u0095\u00E8\u00AB\u0096\u00E7\u0096\u00BE\u00E7\u0097\u0085\u00E5\u008F\u008A\u00E6\u0097\u00B6\u00E6\u00B1\u0082\u00E8\u00B4\u00AD\u00E7\u00AB\u0099\u00E7\u0082\u00B9\u00E5\u0084\u00BF\u00E7\u00AB\u00A5\u00E6\u00AF\u008F\u00E5\u00A4\u00A9\u00E4\u00B8\u00AD\u00E5\u00A4\u00AE\u00E8\u00AE\u00A4\u00E8\u00AF\u0086\u00E6\u00AF\u008F\u00E4\u00B8\u00AA\u00E5\u00A4\u00A9\u00E6\u00B4\u00A5\u00E5\u00AD\u0097\u00E4\u00BD\u0093\u00E5\u008F\u00B0\u00E7\u0081\u00A3\u00E7\u00BB\u00B4\u00E6\u008A\u00A4\u00E6\u009C\u00AC\u00E9\u00A1\u00B5\u00E4\u00B8\u00AA\u00E6\u0080\u00A7\u00E5\u00AE\u0098\u00E6\u0096\u00B9\u00E5\u00B8\u00B8\u00E8\u00A7\u0081\u00E7\u009B\u00B8\u00E6\u009C\u00BA\u00E6\u0088\u0098\u00E7\u0095\u00A5\u00E5\u00BA\u0094\u00E5\u00BD\u0093\u00E5\u00BE\u008B\u00E5\u00B8\u0088\u00E6\u0096\u00B9\u00E4\u00BE\u00BF\u00E6\u00A0\u00A1\u00E5\u009B\u00AD\u00E8\u0082\u00A1\u00E5\u00B8\u0082\u00E6\u0088\u00BF\u00E5\u00B1\u008B\u00E6\u00A0\u008F\u00E7\u009B\u00AE\u00E5\u0091\u0098\u00E5\u00B7\u00A5\u00E5\u00AF\u00BC\u00E8\u0087\u00B4\u00E7\u00AA\u0081\u00E7\u0084\u00B6\u00E9\u0081\u0093\u00E5\u0085\u00B7\u00E6\u009C\u00AC\u00E7\u00BD\u0091\u00E7\u00BB\u0093\u00E5\u0090\u0088\u00E6\u00A1\u00A3\u00E6\u00A1\u0088\u00E5\u008A\u00B3\u00E5\u008A\u00A8\u00E5\u008F\u00A6\u00E5\u00A4\u0096\u00E7\u00BE\u008E\u00E5\u0085\u0083\u00E5\u00BC\u0095\u00E8\u00B5\u00B7\u00E6\u0094\u00B9\u00E5\u008F\u0098\u00E7\u00AC\u00AC\u00E5\u009B\u009B\u00E4\u00BC\u009A\u00E8\u00AE\u00A1\u00E8\u00AA\u00AA\u00E6\u0098\u008E\u00E9\u009A\u0090\u00E7\u00A7\u0081\u00E5\u00AE\u009D\u00E5\u00AE\u009D\u00E8\u00A7\u0084\u00E8\u008C\u0083\u00E6\u00B6\u0088\u00E8\u00B4\u00B9\u00E5\u0085\u00B1\u00E5\u0090\u008C\u00E5\u00BF\u0098\u00E8\u00AE\u00B0\u00E4\u00BD\u0093\u00E7\u00B3\u00BB\u00E5\u00B8\u00A6\u00E6\u009D\u00A5\u00E5\u0090\u008D\u00E5\u00AD\u0097\u00E7\u0099\u00BC\u00E8\u00A1\u00A8\u00E5\u00BC\u0080\u00E6\u0094\u00BE\u00E5\u008A\u00A0\u00E7\u009B\u009F\u00E5\u008F\u0097\u00E5\u0088\u00B0\u00E4\u00BA\u008C\u00E6\u0089\u008B\u00E5\u00A4\u00A7\u00E9\u0087\u008F\u00E6\u0088\u0090\u00E4\u00BA\u00BA\u00E6\u0095\u00B0\u00E9\u0087\u008F\u00E5\u0085\u00B1\u00E4\u00BA\u00AB\u00E5\u008C\u00BA\u00E5\u009F\u009F\u00E5\u00A5\u00B3\u00E5\u00AD\u00A9\u00E5\u008E\u009F\u00E5\u0088\u0099\u00E6\u0089\u0080\u00E5\u009C\u00A8\u00E7\u00BB\u0093\u00E6\u009D\u009F\u00E9\u0080\u009A\u00E4\u00BF\u00A1\u00E8\u00B6\u0085\u00E7\u00BA\u00A7\u00E9\u0085\u008D\u00E7\u00BD\u00AE\u00E5\u00BD\u0093\u00E6\u0097\u00B6\u00E4\u00BC\u0098\u00E7\u00A7\u0080\u00E6\u0080\u00A7\u00E6\u0084\u009F\u00E6\u0088\u00BF\u00E4\u00BA\u00A7\u00E9\u0081\u008A\u00E6\u0088\u00B2\u00E5\u0087\u00BA\u00E5\u008F\u00A3\u00E6\u008F\u0090\u00E4\u00BA\u00A4\u00E5\u00B0\u00B1\u00E4\u00B8\u009A\u00E4\u00BF\u009D\u00E5\u0081\u00A5\u00E7\u00A8\u008B\u00E5\u00BA\u00A6\u00E5\u008F\u0082\u00E6\u0095\u00B0\u00E4\u00BA\u008B\u00E4\u00B8\u009A\u00E6\u0095\u00B4\u00E4\u00B8\u00AA\u00E5\u00B1\u00B1\u00E4\u00B8\u009C\u00E6\u0083\u0085\u00E6\u0084\u009F\u00E7\u0089\u00B9\u00E6\u00AE\u008A\u00E5\u0088\u0086\u00E9\u00A1\u009E\u00E6\u0090\u009C\u00E5\u00B0\u008B\u00E5\u00B1\u009E\u00E4\u00BA\u008E\u00E9\u0097\u00A8\u00E6\u0088\u00B7\u00E8\u00B4\u00A2\u00E5\u008A\u00A1\u00E5\u00A3\u00B0\u00E9\u009F\u00B3\u00E5\u008F\u008A\u00E5\u0085\u00B6\u00E8\u00B4\u00A2\u00E7\u00BB\u008F\u00E5\u009D\u009A\u00E6\u008C\u0081\u00E5\u00B9\u00B2\u00E9\u0083\u00A8\u00E6\u0088\u0090\u00E7\u00AB\u008B\u00E5\u0088\u00A9\u00E7\u009B\u008A\u00E8\u0080\u0083\u00E8\u0099\u0091\u00E6\u0088\u0090\u00E9\u0083\u00BD\u00E5\u008C\u0085\u00E8\u00A3\u0085\u00E7\u0094\u00A8\u00E6\u0088\u00B6\u00E6\u00AF\u0094\u00E8\u00B5\u009B\u00E6\u0096\u0087\u00E6\u0098\u008E\u00E6\u008B\u009B\u00E5\u0095\u0086\u00E5\u00AE\u008C\u00E6\u0095\u00B4\u00E7\u009C\u009F\u00E6\u0098\u00AF\u00E7\u009C\u00BC\u00E7\u009D\u009B\u00E4\u00BC\u0099\u00E4\u00BC\u00B4\u00E5\u00A8\u0081\u00E6\u009C\u009B\u00E9\u00A2\u0086\u00E5\u009F\u009F\u00E5\u008D\u00AB\u00E7\u0094\u009F\u00E4\u00BC\u0098\u00E6\u0083\u00A0\u00E8\u00AB\u0096\u00E5\u00A3\u0087\u00E5\u0085\u00AC\u00E5\u0085\u00B1\u00E8\u0089\u00AF\u00E5\u00A5\u00BD\u00E5\u0085\u0085\u00E5\u0088\u0086\u00E7\u00AC\u00A6\u00E5\u0090\u0088\u00E9\u0099\u0084\u00E4\u00BB\u00B6\u00E7\u0089\u00B9\u00E7\u0082\u00B9\u00E4\u00B8\u008D\u00E5\u008F\u00AF\u00E8\u008B\u00B1\u00E6\u0096\u0087\u00E8\u00B5\u0084\u00E4\u00BA\u00A7\u00E6\u00A0\u00B9\u00E6\u009C\u00AC\u00E6\u0098\u008E\u00E6\u0098\u00BE\u00E5\u00AF\u0086\u00E7\u00A2\u00BC\u00E5\u0085\u00AC\u00E4\u00BC\u0097\u00E6\u00B0\u0091\u00E6\u0097\u008F\u00E6\u009B\u00B4\u00E5\u008A\u00A0\u00E4\u00BA\u00AB\u00E5\u008F\u0097\u00E5\u0090\u008C\u00E5\u00AD\u00A6\u00E5\u0090\u00AF\u00E5\u008A\u00A8\u00E9\u0080\u0082\u00E5\u0090\u0088\u00E5\u008E\u009F\u00E6\u009D\u00A5\u00E9\u0097\u00AE\u00E7\u00AD\u0094\u00E6\u009C\u00AC\u00E6\u0096\u0087\u00E7\u00BE\u008E\u00E9\u00A3\u009F\u00E7\u00BB\u00BF\u00E8\u0089\u00B2\u00E7\u00A8\u00B3\u00E5\u00AE\u009A\u00E7\u00BB\u0088\u00E4\u00BA\u008E\u00E7\u0094\u009F\u00E7\u0089\u00A9\u00E4\u00BE\u009B\u00E6\u00B1\u0082\u00E6\u0090\u009C\u00E7\u008B\u0090\u00E5\u008A\u009B\u00E9\u0087\u008F\u00E4\u00B8\u00A5\u00E9\u0087\u008D\u00E6\u00B0\u00B8\u00E8\u00BF\u009C\u00E5\u0086\u0099\u00E7\u009C\u009F\u00E6\u009C\u0089\u00E9\u0099\u0090\u00E7\u00AB\u009E\u00E4\u00BA\u0089\u00E5\u00AF\u00B9\u00E8\u00B1\u00A1\u00E8\u00B4\u00B9\u00E7\u0094\u00A8\u00E4\u00B8\u008D\u00E5\u00A5\u00BD\u00E7\u00BB\u009D\u00E5\u00AF\u00B9\u00E5\u008D\u0081\u00E5\u0088\u0086\u00E4\u00BF\u0083\u00E8\u00BF\u009B\u00E7\u0082\u00B9\u00E8\u00AF\u0084\u00E5\u00BD\u00B1\u00E9\u009F\u00B3\u00E4\u00BC\u0098\u00E5\u008A\u00BF\u00E4\u00B8\u008D\u00E5\u00B0\u0091\u00E6\u00AC\u00A3\u00E8\u00B5\u008F\u00E5\u00B9\u00B6\u00E4\u00B8\u0094\u00E6\u009C\u0089\u00E7\u0082\u00B9\u00E6\u0096\u00B9\u00E5\u0090\u0091\u00E5\u0085\u00A8\u00E6\u0096\u00B0\u00E4\u00BF\u00A1\u00E7\u0094\u00A8\u00E8\u00AE\u00BE\u00E6\u0096\u00BD\u00E5\u00BD\u00A2\u00E8\u00B1\u00A1\u00E8\u00B5\u0084\u00E6\u00A0\u00BC\u00E7\u00AA\u0081\u00E7\u00A0\u00B4\u00E9\u009A\u008F\u00E7\u009D\u0080\u00E9\u0087\u008D\u00E5\u00A4\u00A7\u00E4\u00BA\u008E\u00E6\u0098\u00AF\u00E6\u00AF\u0095\u00E4\u00B8\u009A\u00E6\u0099\u00BA\u00E8\u0083\u00BD\u00E5\u008C\u0096\u00E5\u00B7\u00A5\u00E5\u00AE\u008C\u00E7\u00BE\u008E\u00E5\u0095\u0086\u00E5\u009F\u008E\u00E7\u00BB\u009F\u00E4\u00B8\u0080\u00E5\u0087\u00BA\u00E7\u0089\u0088\u00E6\u0089\u0093\u00E9\u0080\u00A0\u00E7\u0094\u00A2\u00E5\u0093\u0081\u00E6\u00A6\u0082\u00E5\u0086\u00B5\u00E7\u0094\u00A8\u00E4\u00BA\u008E\u00E4\u00BF\u009D\u00E7\u0095\u0099\u00E5\u009B\u00A0\u00E7\u00B4\u00A0\u00E4\u00B8\u00AD\u00E5\u009C\u008B\u00E5\u00AD\u0098\u00E5\u0082\u00A8\u00E8\u00B4\u00B4\u00E5\u009B\u00BE\u00E6\u009C\u0080\u00E6\u0084\u009B\u00E9\u0095\u00BF\u00E6\u009C\u009F\u00E5\u008F\u00A3\u00E4\u00BB\u00B7\u00E7\u0090\u0086\u00E8\u00B4\u00A2\u00E5\u009F\u00BA\u00E5\u009C\u00B0\u00E5\u00AE\u0089\u00E6\u008E\u0092\u00E6\u00AD\u00A6\u00E6\u00B1\u0089\u00E9\u0087\u008C\u00E9\u009D\u00A2\u00E5\u0088\u009B\u00E5\u00BB\u00BA\u00E5\u00A4\u00A9\u00E7\u00A9\u00BA\u00E9\u00A6\u0096\u00E5\u0085\u0088\u00E5\u00AE\u008C\u00E5\u0096\u0084\u00E9\u00A9\u00B1\u00E5\u008A\u00A8\u00E4\u00B8\u008B\u00E9\u009D\u00A2\u00E4\u00B8\u008D\u00E5\u0086\u008D\u00E8\u00AF\u009A\u00E4\u00BF\u00A1\u00E6\u0084\u008F\u00E4\u00B9\u0089\u00E9\u0098\u00B3\u00E5\u0085\u0089\u00E8\u008B\u00B1\u00E5\u009B\u00BD\u00E6\u00BC\u0082\u00E4\u00BA\u00AE\u00E5\u0086\u009B\u00E4\u00BA\u008B\u00E7\u008E\u00A9\u00E5\u00AE\u00B6\u00E7\u00BE\u00A4\u00E4\u00BC\u0097\u00E5\u0086\u009C\u00E6\u00B0\u0091\u00E5\u008D\u00B3\u00E5\u008F\u00AF\u00E5\u0090\u008D\u00E7\u00A8\u00B1\u00E5\u00AE\u00B6\u00E5\u0085\u00B7\u00E5\u008A\u00A8\u00E7\u0094\u00BB\u00E6\u0083\u00B3\u00E5\u0088\u00B0\u00E6\u00B3\u00A8\u00E6\u0098\u008E\u00E5\u00B0\u008F\u00E5\u00AD\u00A6\u00E6\u0080\u00A7\u00E8\u0083\u00BD\u00E8\u0080\u0083\u00E7\u00A0\u0094\u00E7\u00A1\u00AC\u00E4\u00BB\u00B6\u00E8\u00A7\u0082\u00E7\u009C\u008B\u00E6\u00B8\u0085\u00E6\u00A5\u009A\u00E6\u0090\u009E\u00E7\u00AC\u0091\u00E9\u00A6\u0096\u00E9\u00A0\u0081\u00E9\u00BB\u0084\u00E9\u0087\u0091\u00E9\u0080\u0082\u00E7\u0094\u00A8\u00E6\u00B1\u009F\u00E8\u008B\u008F\u00E7\u009C\u009F\u00E5\u00AE\u009E\u00E4\u00B8\u00BB\u00E7\u00AE\u00A1\u00E9\u0098\u00B6\u00E6\u00AE\u00B5\u00E8\u00A8\u00BB\u00E5\u0086\u008A\u00E7\u00BF\u00BB\u00E8\u00AF\u0091\u00E6\u009D\u0083\u00E5\u0088\u00A9\u00E5\u0081\u009A\u00E5\u00A5\u00BD\u00E4\u00BC\u00BC\u00E4\u00B9\u008E\u00E9\u0080\u009A\u00E8\u00AE\u00AF\u00E6\u0096\u00BD\u00E5\u00B7\u00A5\u00E7\u008B\u0080\u00E6\u0085\u008B\u00E4\u00B9\u009F\u00E8\u00AE\u00B8\u00E7\u008E\u00AF\u00E4\u00BF\u009D\u00E5\u009F\u00B9\u00E5\u0085\u00BB\u00E6\u00A6\u0082\u00E5\u00BF\u00B5\u00E5\u00A4\u00A7\u00E5\u009E\u008B\u00E6\u009C\u00BA\u00E7\u00A5\u00A8\u00E7\u0090\u0086\u00E8\u00A7\u00A3\u00E5\u008C\u00BF\u00E5\u0090\u008Dcuandoenviarmadridbuscariniciotiempoporquecuentaestadopuedenjuegoscontraest\u00C3\u00A1nnombretienenperfilmaneraamigosciudadcentroaunquepuedesdentroprimerprecioseg\u00C3\u00BAnbuenosvolverpuntossemanahab\u00C3\u00ADaagostonuevosunidoscarlosequiponi\u00C3\u00B1osmuchosalgunacorreoimagenpartirarribamar\u00C3\u00ADahombreempleoverdadcambiomuchasfueronpasadol\u00C3\u00ADneaparecenuevascursosestabaquierolibroscuantoaccesomiguelvarioscuatrotienesgruposser\u00C3\u00A1neuropamediosfrenteacercadem\u00C3\u00A1sofertacochesmodeloitalialetrasalg\u00C3\u00BAncompracualesexistecuerposiendoprensallegarviajesdineromurciapodr\u00C3\u00A1puestodiariopuebloquieremanuelpropiocrisisciertoseguromuertefuentecerrargrandeefectopartesmedidapropiaofrecetierrae-mailvariasformasfuturoobjetoseguirriesgonormasmismos\u00C3\u00BAnicocaminositiosraz\u00C3\u00B3ndebidopruebatoledoten\u00C3\u00ADajes\u00C3\u00BAsesperococinaorigentiendacientoc\u00C3\u00A1dizhablarser\u00C3\u00ADalatinafuerzaestiloguerraentrar\u00C3\u00A9xitol\u00C3\u00B3pezagendav\u00C3\u00ADdeoevitarpaginametrosjavierpadresf\u00C3\u00A1cilcabeza\u00C3\u00A1reassalidaenv\u00C3\u00ADojap\u00C3\u00B3nabusosbienestextosllevarpuedanfuertecom\u00C3\u00BAnclaseshumanotenidobilbaounidadest\u00C3\u00A1seditarcreado\u00D0\u00B4\u00D0\u00BB\u00D1\u008F\u00D1\u0087\u00D1\u0082\u00D0\u00BE\u00D0\u00BA\u00D0\u00B0\u00D0\u00BA\u00D0\u00B8\u00D0\u00BB\u00D0\u00B8\u00D1\u008D\u00D1\u0082\u00D0\u00BE\u00D0\u00B2\u00D1\u0081\u00D0\u00B5\u00D0\u00B5\u00D0\u00B3\u00D0\u00BE\u00D0\u00BF\u00D1\u0080\u00D0\u00B8\u00D1\u0082\u00D0\u00B0\u00D0\u00BA\u00D0\u00B5\u00D1\u0089\u00D0\u00B5\u00D1\u0083\u00D0\u00B6\u00D0\u00B5\u00D0\u009A\u00D0\u00B0\u00D0\u00BA\u00D0\u00B1\u00D0\u00B5\u00D0\u00B7\u00D0\u00B1\u00D1\u008B\u00D0\u00BB\u00D0\u00BE\u00D0\u00BD\u00D0\u00B8\u00D0\u0092\u00D1\u0081\u00D0\u00B5\u00D0\u00BF\u00D0\u00BE\u00D0\u00B4\u00D0\u00AD\u00D1\u0082\u00D0\u00BE\u00D1\u0082\u00D0\u00BE\u00D0\u00BC\u00D1\u0087\u00D0\u00B5\u00D0\u00BC\u00D0\u00BD\u00D0\u00B5\u00D1\u0082\u00D0\u00BB\u00D0\u00B5\u00D1\u0082\u00D1\u0080\u00D0\u00B0\u00D0\u00B7\u00D0\u00BE\u00D0\u00BD\u00D0\u00B0\u00D0\u00B3\u00D0\u00B4\u00D0\u00B5\u00D0\u00BC\u00D0\u00BD\u00D0\u00B5\u00D0\u0094\u00D0\u00BB\u00D1\u008F\u00D0\u009F\u00D1\u0080\u00D0\u00B8\u00D0\u00BD\u00D0\u00B0\u00D1\u0081\u00D0\u00BD\u00D0\u00B8\u00D1\u0085\u00D1\u0082\u00D0\u00B5\u00D0\u00BC\u00D0\u00BA\u00D1\u0082\u00D0\u00BE\u00D0\u00B3\u00D0\u00BE\u00D0\u00B4\u00D0\u00B2\u00D0\u00BE\u00D1\u0082\u00D1\u0082\u00D0\u00B0\u00D0\u00BC\u00D0\u00A1\u00D0\u00A8\u00D0\u0090\u00D0\u00BC\u00D0\u00B0\u00D1\u008F\u00D0\u00A7\u00D1\u0082\u00D0\u00BE\u00D0\u00B2\u00D0\u00B0\u00D1\u0081\u00D0\u00B2\u00D0\u00B0\u00D0\u00BC\u00D0\u00B5\u00D0\u00BC\u00D1\u0083\u00D0\u00A2\u00D0\u00B0\u00D0\u00BA\u00D0\u00B4\u00D0\u00B2\u00D0\u00B0\u00D0\u00BD\u00D0\u00B0\u00D0\u00BC\u00D1\u008D\u00D1\u0082\u00D0\u00B8\u00D1\u008D\u00D1\u0082\u00D1\u0083\u00D0\u0092\u00D0\u00B0\u00D0\u00BC\u00D1\u0082\u00D0\u00B5\u00D1\u0085\u00D0\u00BF\u00D1\u0080\u00D0\u00BE\u00D1\u0082\u00D1\u0083\u00D1\u0082\u00D0\u00BD\u00D0\u00B0\u00D0\u00B4\u00D0\u00B4\u00D0\u00BD\u00D1\u008F\u00D0\u0092\u00D0\u00BE\u00D1\u0082\u00D1\u0082\u00D1\u0080\u00D0\u00B8\u00D0\u00BD\u00D0\u00B5\u00D0\u00B9\u00D0\u0092\u00D0\u00B0\u00D1\u0081\u00D0\u00BD\u00D0\u00B8\u00D0\u00BC\u00D1\u0081\u00D0\u00B0\u00D0\u00BC\u00D1\u0082\u00D0\u00BE\u00D1\u0082\u00D1\u0080\u00D1\u0083\u00D0\u00B1\u00D0\u009E\u00D0\u00BD\u00D0\u00B8\u00D0\u00BC\u00D0\u00B8\u00D1\u0080\u00D0\u00BD\u00D0\u00B5\u00D0\u00B5\u00D0\u009E\u00D0\u009E\u00D0\u009E\u00D0\u00BB\u00D0\u00B8\u00D1\u0086\u00D1\u008D\u00D1\u0082\u00D0\u00B0\u00D0\u009E\u00D0\u00BD\u00D0\u00B0\u00D0\u00BD\u00D0\u00B5\u00D0\u00BC\u00D0\u00B4\u00D0\u00BE\u00D0\u00BC\u00D0\u00BC\u00D0\u00BE\u00D0\u00B9\u00D0\u00B4\u00D0\u00B2\u00D0\u00B5\u00D0\u00BE\u00D0\u00BD\u00D0\u00BE\u00D1\u0081\u00D1\u0083\u00D0\u00B4\u00E0\u00A4\u0095\u00E0\u00A5\u0087\u00E0\u00A4\u00B9\u00E0\u00A5\u0088\u00E0\u00A4\u0095\u00E0\u00A5\u0080\u00E0\u00A4\u00B8\u00E0\u00A5\u0087\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u0095\u00E0\u00A5\u008B\u00E0\u00A4\u0094\u00E0\u00A4\u00B0\u00E0\u00A4\u00AA\u00E0\u00A4\u00B0\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u008F\u00E0\u00A4\u0095\u00E0\u00A4\u0095\u00E0\u00A4\u00BF\u00E0\u00A4\u00AD\u00E0\u00A5\u0080\u00E0\u00A4\u0087\u00E0\u00A4\u00B8\u00E0\u00A4\u0095\u00E0\u00A4\u00B0\u00E0\u00A4\u00A4\u00E0\u00A5\u008B\u00E0\u00A4\u00B9\u00E0\u00A5\u008B\u00E0\u00A4\u0086\u00E0\u00A4\u00AA\u00E0\u00A4\u00B9\u00E0\u00A5\u0080\u00E0\u00A4\u00AF\u00E0\u00A4\u00B9\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00A4\u00E0\u00A4\u0095\u00E0\u00A4\u00A5\u00E0\u00A4\u00BEjagran\u00E0\u00A4\u0086\u00E0\u00A4\u009C\u00E0\u00A4\u009C\u00E0\u00A5\u008B\u00E0\u00A4\u0085\u00E0\u00A4\u00AC\u00E0\u00A4\u00A6\u00E0\u00A5\u008B\u00E0\u00A4\u0097\u00E0\u00A4\u0088\u00E0\u00A4\u009C\u00E0\u00A4\u00BE\u00E0\u00A4\u0097\u00E0\u00A4\u008F\u00E0\u00A4\u00B9\u00E0\u00A4\u00AE\u00E0\u00A4\u0087\u00E0\u00A4\u00A8\u00E0\u00A4\u00B5\u00E0\u00A4\u00B9\u00E0\u00A4\u00AF\u00E0\u00A5\u0087\u00E0\u00A4\u00A5\u00E0\u00A5\u0087\u00E0\u00A4\u00A5\u00E0\u00A5\u0080\u00E0\u00A4\u0098\u00E0\u00A4\u00B0\u00E0\u00A4\u009C\u00E0\u00A4\u00AC\u00E0\u00A4\u00A6\u00E0\u00A5\u0080\u00E0\u00A4\u0095\u00E0\u00A4\u0088\u00E0\u00A4\u009C\u00E0\u00A5\u0080\u00E0\u00A4\u00B5\u00E0\u00A5\u0087\u00E0\u00A4\u00A8\u00E0\u00A4\u0088\u00E0\u00A4\u00A8\u00E0\u00A4\u008F\u00E0\u00A4\u00B9\u00E0\u00A4\u00B0\u00E0\u00A4\u0089\u00E0\u00A4\u00B8\u00E0\u00A4\u00AE\u00E0\u00A5\u0087\u00E0\u00A4\u0095\u00E0\u00A4\u00AE\u00E0\u00A4\u00B5\u00E0\u00A5\u008B\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u00B8\u00E0\u00A4\u00AC\u00E0\u00A4\u00AE\u00E0\u00A4\u0088\u00E0\u00A4\u00A6\u00E0\u00A5\u0087\u00E0\u00A4\u0093\u00E0\u00A4\u00B0\u00E0\u00A4\u0086\u00E0\u00A4\u00AE\u00E0\u00A4\u00AC\u00E0\u00A4\u00B8\u00E0\u00A4\u00AD\u00E0\u00A4\u00B0\u00E0\u00A4\u00AC\u00E0\u00A4\u00A8\u00E0\u00A4\u009A\u00E0\u00A4\u00B2\u00E0\u00A4\u00AE\u00E0\u00A4\u00A8\u00E0\u00A4\u0086\u00E0\u00A4\u0097\u00E0\u00A4\u00B8\u00E0\u00A5\u0080\u00E0\u00A4\u00B2\u00E0\u00A5\u0080\u00D8\u00B9\u00D9\u0084\u00D9\u0089\u00D8\u00A5\u00D9\u0084\u00D9\u0089\u00D9\u0087\u00D8\u00B0\u00D8\u00A7\u00D8\u00A2\u00D8\u00AE\u00D8\u00B1\u00D8\u00B9\u00D8\u00AF\u00D8\u00AF\u00D8\u00A7\u00D9\u0084\u00D9\u0089\u00D9\u0087\u00D8\u00B0\u00D9\u0087\u00D8\u00B5\u00D9\u0088\u00D8\u00B1\u00D8\u00BA\u00D9\u008A\u00D8\u00B1\u00D9\u0083\u00D8\u00A7\u00D9\u0086\u00D9\u0088\u00D9\u0084\u00D8\u00A7\u00D8\u00A8\u00D9\u008A\u00D9\u0086\u00D8\u00B9\u00D8\u00B1\u00D8\u00B6\u00D8\u00B0\u00D9\u0084\u00D9\u0083\u00D9\u0087\u00D9\u0086\u00D8\u00A7\u00D9\u008A\u00D9\u0088\u00D9\u0085\u00D9\u0082\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D9\u0084\u00D9\u008A\u00D8\u00A7\u00D9\u0086\u00D8\u00A7\u00D9\u0084\u00D9\u0083\u00D9\u0086\u00D8\u00AD\u00D8\u00AA\u00D9\u0089\u00D9\u0082\u00D8\u00A8\u00D9\u0084\u00D9\u0088\u00D8\u00AD\u00D8\u00A9\u00D8\u00A7\u00D8\u00AE\u00D8\u00B1\u00D9\u0081\u00D9\u0082\u00D8\u00B7\u00D8\u00B9\u00D8\u00A8\u00D8\u00AF\u00D8\u00B1\u00D9\u0083\u00D9\u0086\u00D8\u00A5\u00D8\u00B0\u00D8\u00A7\u00D9\u0083\u00D9\u0085\u00D8\u00A7\u00D8\u00A7\u00D8\u00AD\u00D8\u00AF\u00D8\u00A5\u00D9\u0084\u00D8\u00A7\u00D9\u0081\u00D9\u008A\u00D9\u0087\u00D8\u00A8\u00D8\u00B9\u00D8\u00B6\u00D9\u0083\u00D9\u008A\u00D9\u0081\u00D8\u00A8\u00D8\u00AD\u00D8\u00AB\u00D9\u0088\u00D9\u0085\u00D9\u0086\u00D9\u0088\u00D9\u0087\u00D9\u0088\u00D8\u00A3\u00D9\u0086\u00D8\u00A7\u00D8\u00AC\u00D8\u00AF\u00D8\u00A7\u00D9\u0084\u00D9\u0087\u00D8\u00A7\u00D8\u00B3\u00D9\u0084\u00D9\u0085\u00D8\u00B9\u00D9\u0086\u00D8\u00AF\u00D9\u0084\u00D9\u008A\u00D8\u00B3\u00D8\u00B9\u00D8\u00A8\u00D8\u00B1\u00D8\u00B5\u00D9\u0084\u00D9\u0089\u00D9\u0085\u00D9\u0086\u00D8\u00B0\u00D8\u00A8\u00D9\u0087\u00D8\u00A7\u00D8\u00A3\u00D9\u0086\u00D9\u0087\u00D9\u0085\u00D8\u00AB\u00D9\u0084\u00D9\u0083\u00D9\u0086\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D8\u00AD\u00D9\u008A\u00D8\u00AB\u00D9\u0085\u00D8\u00B5\u00D8\u00B1\u00D8\u00B4\u00D8\u00B1\u00D8\u00AD\u00D8\u00AD\u00D9\u0088\u00D9\u0084\u00D9\u0088\u00D9\u0081\u00D9\u008A\u00D8\u00A7\u00D8\u00B0\u00D8\u00A7\u00D9\u0084\u00D9\u0083\u00D9\u0084\u00D9\u0085\u00D8\u00B1\u00D8\u00A9\u00D8\u00A7\u00D9\u0086\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D9\u0081\u00D8\u00A3\u00D8\u00A8\u00D9\u0088\u00D8\u00AE\u00D8\u00A7\u00D8\u00B5\u00D8\u00A3\u00D9\u0086\u00D8\u00AA\u00D8\u00A7\u00D9\u0086\u00D9\u0087\u00D8\u00A7\u00D9\u0084\u00D9\u008A\u00D8\u00B9\u00D8\u00B6\u00D9\u0088\u00D9\u0088\u00D9\u0082\u00D8\u00AF\u00D8\u00A7\u00D8\u00A8\u00D9\u0086\u00D8\u00AE\u00D9\u008A\u00D8\u00B1\u00D8\u00A8\u00D9\u0086\u00D8\u00AA\u00D9\u0084\u00D9\u0083\u00D9\u0085\u00D8\u00B4\u00D8\u00A7\u00D8\u00A1\u00D9\u0088\u00D9\u0087\u00D9\u008A\u00D8\u00A7\u00D8\u00A8\u00D9\u0088\u00D9\u0082\u00D8\u00B5\u00D8\u00B5\u00D9\u0088\u00D9\u0085\u00D8\u00A7\u00D8\u00B1\u00D9\u0082\u00D9\u0085\u00D8\u00A3\u00D8\u00AD\u00D8\u00AF\u00D9\u0086\u00D8\u00AD\u00D9\u0086\u00D8\u00B9\u00D8\u00AF\u00D9\u0085\u00D8\u00B1\u00D8\u00A3\u00D9\u008A\u00D8\u00A7\u00D8\u00AD\u00D8\u00A9\u00D9\u0083\u00D8\u00AA\u00D8\u00A8\u00D8\u00AF\u00D9\u0088\u00D9\u0086\u00D9\u008A\u00D8\u00AC\u00D8\u00A8\u00D9\u0085\u00D9\u0086\u00D9\u0087\u00D8\u00AA\u00D8\u00AD\u00D8\u00AA\u00D8\u00AC\u00D9\u0087\u00D8\u00A9\u00D8\u00B3\u00D9\u0086\u00D8\u00A9\u00D9\u008A\u00D8\u00AA\u00D9\u0085\u00D9\u0083\u00D8\u00B1\u00D8\u00A9\u00D8\u00BA\u00D8\u00B2\u00D8\u00A9\u00D9\u0086\u00D9\u0081\u00D8\u00B3\u00D8\u00A8\u00D9\u008A\u00D8\u00AA\u00D9\u0084\u00D9\u0084\u00D9\u0087\u00D9\u0084\u00D9\u0086\u00D8\u00A7\u00D8\u00AA\u00D9\u0084\u00D9\u0083\u00D9\u0082\u00D9\u0084\u00D8\u00A8\u00D9\u0084\u00D9\u0085\u00D8\u00A7\u00D8\u00B9\u00D9\u0086\u00D9\u0087\u00D8\u00A3\u00D9\u0088\u00D9\u0084\u00D8\u00B4\u00D9\u008A\u00D8\u00A1\u00D9\u0086\u00D9\u0088\u00D8\u00B1\u00D8\u00A3\u00D9\u0085\u00D8\u00A7\u00D9\u0081\u00D9\u008A\u00D9\u0083\u00D8\u00A8\u00D9\u0083\u00D9\u0084\u00D8\u00B0\u00D8\u00A7\u00D8\u00AA\u00D8\u00B1\u00D8\u00AA\u00D8\u00A8\u00D8\u00A8\u00D8\u00A3\u00D9\u0086\u00D9\u0087\u00D9\u0085\u00D8\u00B3\u00D8\u00A7\u00D9\u0086\u00D9\u0083\u00D8\u00A8\u00D9\u008A\u00D8\u00B9\u00D9\u0081\u00D9\u0082\u00D8\u00AF\u00D8\u00AD\u00D8\u00B3\u00D9\u0086\u00D9\u0084\u00D9\u0087\u00D9\u0085\u00D8\u00B4\u00D8\u00B9\u00D8\u00B1\u00D8\u00A3\u00D9\u0087\u00D9\u0084\u00D8\u00B4\u00D9\u0087\u00D8\u00B1\u00D9\u0082\u00D8\u00B7\u00D8\u00B1\u00D8\u00B7\u00D9\u0084\u00D8\u00A8profileservicedefaulthimselfdetailscontentsupportstartedmessagesuccessfashion<title>countryaccountcreatedstoriesresultsrunningprocesswritingobjectsvisiblewelcomearticleunknownnetworkcompanydynamicbrowserprivacyproblemServicerespectdisplayrequestreservewebsitehistoryfriendsoptionsworkingversionmillionchannelwindow.addressvisitedweathercorrectproductedirectforwardyou canremovedsubjectcontrolarchivecurrentreadinglibrarylimitedmanagerfurthersummarymachineminutesprivatecontextprogramsocietynumberswrittenenabledtriggersourcesloadingelementpartnerfinallyperfectmeaningsystemskeepingculture&quot;,journalprojectsurfaces&quot;expiresreviewsbalanceEnglishContentthroughPlease opinioncontactaverageprimaryvillageSpanishgallerydeclinemeetingmissionpopularqualitymeasuregeneralspeciessessionsectionwriterscounterinitialreportsfiguresmembersholdingdisputeearlierexpressdigitalpictureAnothermarriedtrafficleadingchangedcentralvictoryimages/reasonsstudiesfeaturelistingmust beschoolsVersionusuallyepisodeplayinggrowingobviousoverlaypresentactions</ul>\r\nwrapperalreadycertainrealitystorageanotherdesktopofferedpatternunusualDigitalcapitalWebsitefailureconnectreducedAndroiddecadesregular &amp; animalsreleaseAutomatgettingmethodsnothingPopularcaptionletterscapturesciencelicensechangesEngland=1&amp;History = new CentralupdatedSpecialNetworkrequirecommentwarningCollegetoolbarremainsbecauseelectedDeutschfinanceworkersquicklybetweenexactlysettingdiseaseSocietyweaponsexhibit&lt;!--Controlclassescoveredoutlineattacksdevices(windowpurposetitle=\"Mobile killingshowingItaliandroppedheavilyeffects-1']);\nconfirmCurrentadvancesharingopeningdrawingbillionorderedGermanyrelated</form>includewhetherdefinedSciencecatalogArticlebuttonslargestuniformjourneysidebarChicagoholidayGeneralpassage,&quot;animatefeelingarrivedpassingnaturalroughly.\n\nThe but notdensityBritainChineselack oftributeIreland\" data-factorsreceivethat isLibraryhusbandin factaffairsCharlesradicalbroughtfindinglanding:lang=\"return leadersplannedpremiumpackageAmericaEdition]&quot;Messageneed tovalue=\"complexlookingstationbelievesmaller-mobilerecordswant tokind ofFirefoxyou aresimilarstudiedmaximumheadingrapidlyclimatekingdomemergedamountsfoundedpioneerformuladynastyhow to SupportrevenueeconomyResultsbrothersoldierlargelycalling.&quot;AccountEdward segmentRobert effortsPacificlearnedup withheight:we haveAngelesnations_searchappliedacquiremassivegranted: falsetreatedbiggestbenefitdrivingStudiesminimumperhapsmorningsellingis usedreversevariant role=\"missingachievepromotestudentsomeoneextremerestorebottom:evolvedall thesitemapenglishway to  AugustsymbolsCompanymattersmusicalagainstserving})();\r\npaymenttroubleconceptcompareparentsplayersregionsmonitor ''The winningexploreadaptedGalleryproduceabilityenhancecareers). The collectSearch ancientexistedfooter handlerprintedconsoleEasternexportswindowsChannelillegalneutralsuggest_headersigning.html\">settledwesterncausing-webkitclaimedJusticechaptervictimsThomas mozillapromisepartieseditionoutside:false,hundredOlympic_buttonauthorsreachedchronicdemandssecondsprotectadoptedprepareneithergreatlygreateroverallimprovecommandspecialsearch.worshipfundingthoughthighestinsteadutilityquarterCulturetestingclearlyexposedBrowserliberal} catchProjectexamplehide();FloridaanswersallowedEmperordefenseseriousfreedomSeveral-buttonFurtherout of != nulltrainedDenmarkvoid(0)/all.jspreventRequestStephen\n\nWhen observe</h2>\r\nModern provide\" alt=\"borders.\n\nFor \n\nMany artistspoweredperformfictiontype ofmedicalticketsopposedCouncilwitnessjusticeGeorge Belgium...</a>twitternotablywaitingwarfare Other rankingphrasesmentionsurvivescholar</p>\r\n Countryignoredloss ofjust asGeorgiastrange<head><stopped1']);\r\nislandsnotableborder:list ofcarried100,000</h3>\n severalbecomesselect wedding00.htmlmonarchoff theteacherhighly biologylife ofor evenrise of&raquo;plusonehunting(thoughDouglasjoiningcirclesFor theAncientVietnamvehiclesuch ascrystalvalue =Windowsenjoyeda smallassumed<a id=\"foreign All rihow theDisplayretiredhoweverhidden;battlesseekingcabinetwas notlook atconductget theJanuaryhappensturninga:hoverOnline French lackingtypicalextractenemieseven ifgeneratdecidedare not/searchbeliefs-image:locatedstatic.login\">convertviolententeredfirst\">circuitFinlandchemistshe was10px;\">as suchdivided</span>will beline ofa greatmystery/index.fallingdue to railwaycollegemonsterdescentit withnuclearJewish protestBritishflowerspredictreformsbutton who waslectureinstantsuicidegenericperiodsmarketsSocial fishingcombinegraphicwinners<br /><by the NaturalPrivacycookiesoutcomeresolveSwedishbrieflyPersianso muchCenturydepictscolumnshousingscriptsnext tobearingmappingrevisedjQuery(-width:title\">tooltipSectiondesignsTurkishyounger.match(})();\n\nburningoperatedegreessource=Richardcloselyplasticentries</tr>\r\ncolor:#ul id=\"possessrollingphysicsfailingexecutecontestlink toDefault<br />\n: true,chartertourismclassicproceedexplain</h1>\r\nonline.?xml vehelpingdiamonduse theairlineend -->).attr(readershosting#ffffffrealizeVincentsignals src=\"/ProductdespitediversetellingPublic held inJoseph theatreaffects<style>a largedoesn'tlater, ElementfaviconcreatorHungaryAirportsee theso thatMichaelSystemsPrograms, and  width=e&quot;tradingleft\">\npersonsGolden Affairsgrammarformingdestroyidea ofcase ofoldest this is.src = cartoonregistrCommonsMuslimsWhat isin manymarkingrevealsIndeed,equally/show_aoutdoorescape(Austriageneticsystem,In the sittingHe alsoIslandsAcademy\n\t\t<!--Daniel bindingblock\">imposedutilizeAbraham(except{width:putting).html(|| [];\nDATA[ *kitchenmountedactual dialectmainly _blank'installexpertsif(typeIt also&copy; \">Termsborn inOptionseasterntalkingconcerngained ongoingjustifycriticsfactoryits ownassaultinvitedlastinghis ownhref=\"/\" rel=\"developconcertdiagramdollarsclusterphp?id=alcohol);})();using a><span>vesselsrevivalAddressamateurandroidallegedillnesswalkingcentersqualifymatchesunifiedextinctDefensedied in\n\t<!-- customslinkingLittle Book ofeveningmin.js?are thekontakttoday's.html\" target=wearingAll Rig;\n})();raising Also, crucialabout\">declare-->\n<scfirefoxas muchappliesindex, s, but type = \n\r\n<!--towardsRecordsPrivateForeignPremierchoicesVirtualreturnsCommentPoweredinline;povertychamberLiving volumesAnthonylogin\" RelatedEconomyreachescuttinggravitylife inChapter-shadowNotable</td>\r\n returnstadiumwidgetsvaryingtravelsheld bywho arework infacultyangularwho hadairporttown of\n\nSome 'click'chargeskeywordit willcity of(this);Andrew unique checkedor more300px; return;rsion=\"pluginswithin herselfStationFederalventurepublishsent totensionactresscome tofingersDuke ofpeople,exploitwhat isharmonya major\":\"httpin his menu\">\nmonthlyofficercouncilgainingeven inSummarydate ofloyaltyfitnessand wasemperorsupremeSecond hearingRussianlongestAlbertalateralset of small\">.appenddo withfederalbank ofbeneathDespiteCapitalgrounds), and percentit fromclosingcontainInsteadfifteenas well.yahoo.respondfighterobscurereflectorganic= Math.editingonline paddinga wholeonerroryear ofend of barrierwhen itheader home ofresumedrenamedstrong>heatingretainscloudfrway of March 1knowingin partBetweenlessonsclosestvirtuallinks\">crossedEND -->famous awardedLicenseHealth fairly wealthyminimalAfricancompetelabel\">singingfarmersBrasil)discussreplaceGregoryfont copursuedappearsmake uproundedboth ofblockedsaw theofficescoloursif(docuwhen heenforcepush(fuAugust UTF-8\">Fantasyin mostinjuredUsuallyfarmingclosureobject defenceuse of Medical<body>\nevidentbe usedkeyCodesixteenIslamic#000000entire widely active (typeofone cancolor =speakerextendsPhysicsterrain<tbody>funeralviewingmiddle cricketprophetshifteddoctorsRussell targetcompactalgebrasocial-bulk ofman and</td>\n he left).val()false);logicalbankinghome tonaming Arizonacredits);\n});\nfounderin turnCollinsbefore But thechargedTitle\">CaptainspelledgoddessTag -->Adding:but wasRecent patientback in=false&Lincolnwe knowCounterJudaismscript altered']);\n  has theunclearEvent',both innot all\n\n<!-- placinghard to centersort ofclientsstreetsBernardassertstend tofantasydown inharbourFreedomjewelry/about..searchlegendsis mademodern only ononly toimage\" linear painterand notrarely acronymdelivershorter00&amp;as manywidth=\"/* <![Ctitle =of the lowest picked escapeduses ofpeoples PublicMatthewtacticsdamagedway forlaws ofeasy to windowstrong  simple}catch(seventhinfoboxwent topaintedcitizenI don'tretreat. Some ww.\");\nbombingmailto:made in. Many carries||{};wiwork ofsynonymdefeatsfavoredopticalpageTraunless sendingleft\"><comScorAll thejQuery.touristClassicfalse\" Wilhelmsuburbsgenuinebishops.split(global followsbody ofnominalContactsecularleft tochiefly-hidden-banner</li>\n\n. When in bothdismissExplorealways via thespa\u00C3\u00B1olwelfareruling arrangecaptainhis sonrule ofhe tookitself,=0&amp;(calledsamplesto makecom/pagMartin Kennedyacceptsfull ofhandledBesides//--></able totargetsessencehim to its by common.mineralto takeways tos.org/ladvisedpenaltysimple:if theyLettersa shortHerbertstrikes groups.lengthflightsoverlapslowly lesser social </p>\n\t\tit intoranked rate oful>\r\n  attemptpair ofmake itKontaktAntoniohaving ratings activestreamstrapped\").css(hostilelead tolittle groups,Picture-->\r\n\r\n rows=\" objectinverse<footerCustomV><\\/scrsolvingChamberslaverywoundedwhereas!= 'undfor allpartly -right:Arabianbacked centuryunit ofmobile-Europe,is homerisk ofdesiredClintoncost ofage of become none ofp&quot;Middle ead')[0Criticsstudios>&copy;group\">assemblmaking pressedwidget.ps:\" ? rebuiltby someFormer editorsdelayedCanonichad thepushingclass=\"but arepartialBabylonbottom carrierCommandits useAs withcoursesa thirddenotesalso inHouston20px;\">accuseddouble goal ofFamous ).bind(priests Onlinein Julyst + \"gconsultdecimalhelpfulrevivedis veryr'+'iptlosing femalesis alsostringsdays ofarrivalfuture <objectforcingString(\" />\n\t\there isencoded.  The balloondone by/commonbgcolorlaw of Indianaavoidedbut the2px 3pxjquery.after apolicy.men andfooter-= true;for usescreen.Indian image =family,http:// &nbsp;driverseternalsame asnoticedviewers})();\n is moreseasonsformer the newis justconsent Searchwas thewhy theshippedbr><br>width: height=made ofcuisineis thata very Admiral fixed;normal MissionPress, ontariocharsettry to invaded=\"true\"spacingis mosta more totallyfall of});\r\n  immensetime inset outsatisfyto finddown tolot of Playersin Junequantumnot thetime todistantFinnishsrc = (single help ofGerman law andlabeledforestscookingspace\">header-well asStanleybridges/globalCroatia About [0];\n  it, andgroupedbeing a){throwhe madelighterethicalFFFFFF\"bottom\"like a employslive inas seenprintermost ofub-linkrejectsand useimage\">succeedfeedingNuclearinformato helpWomen'sNeitherMexicanprotein<table by manyhealthylawsuitdevised.push({sellerssimply Through.cookie Image(older\">us.js\"> Since universlarger open to!-- endlies in']);\r\n  marketwho is (\"DOMComanagedone fortypeof Kingdomprofitsproposeto showcenter;made itdressedwere inmixtureprecisearisingsrc = 'make a securedBaptistvoting \n\t\tvar March 2grew upClimate.removeskilledway the</head>face ofacting right\">to workreduceshas haderectedshow();action=book ofan area== \"htt<header\n<html>conformfacing cookie.rely onhosted .customhe wentbut forspread Family a meansout theforums.footage\">MobilClements\" id=\"as highintense--><!--female is seenimpliedset thea stateand hisfastestbesidesbutton_bounded\"><img Infoboxevents,a youngand areNative cheaperTimeoutand hasengineswon the(mostlyright: find a -bottomPrince area ofmore ofsearch_nature,legallyperiod,land ofor withinducedprovingmissilelocallyAgainstthe wayk&quot;px;\">\r\npushed abandonnumeralCertainIn thismore inor somename isand, incrownedISBN 0-createsOctobermay notcenter late inDefenceenactedwish tobroadlycoolingonload=it. TherecoverMembersheight assumes<html>\npeople.in one =windowfooter_a good reklamaothers,to this_cookiepanel\">London,definescrushedbaptismcoastalstatus title\" move tolost inbetter impliesrivalryservers SystemPerhapses and contendflowinglasted rise inGenesisview ofrising seem tobut in backinghe willgiven agiving cities.flow of Later all butHighwayonly bysign ofhe doesdiffersbattery&amp;lasinglesthreatsintegertake onrefusedcalled =US&ampSee thenativesby thissystem.head of:hover,lesbiansurnameand allcommon/header__paramsHarvard/pixel.removalso longrole ofjointlyskyscraUnicodebr />\r\nAtlantanucleusCounty,purely count\">easily build aonclicka givenpointerh&quot;events else {\nditionsnow the, with man whoorg/Webone andcavalryHe diedseattle00,000 {windowhave toif(windand itssolely m&quot;renewedDetroitamongsteither them inSenatorUs</a><King ofFrancis-produche usedart andhim andused byscoringat hometo haverelatesibilityfactionBuffalolink\"><what hefree toCity ofcome insectorscountedone daynervoussquare };if(goin whatimg\" alis onlysearch/tuesdaylooselySolomonsexual - <a hrmedium\"DO NOT France,with a war andsecond take a >\r\n\r\n\r\nmarket.highwaydone inctivity\"last\">obligedrise to\"undefimade to Early praisedin its for hisathleteJupiterYahoo! termed so manyreally s. The a woman?value=direct right\" bicycleacing=\"day andstatingRather,higher Office are nowtimes, when a pay foron this-link\">;borderaround annual the Newput the.com\" takin toa brief(in thegroups.; widthenzymessimple in late{returntherapya pointbanninginks\">\n();\" rea place\\u003Caabout atr>\r\n\t\tccount gives a<SCRIPTRailwaythemes/toolboxById(\"xhumans,watchesin some if (wicoming formats Under but hashanded made bythan infear ofdenoted/iframeleft involtagein eacha&quot;base ofIn manyundergoregimesaction </p>\r\n<ustomVa;&gt;</importsor thatmostly &amp;re size=\"</a></ha classpassiveHost = WhetherfertileVarious=[];(fucameras/></td>acts asIn some>\r\n\r\n<!organis <br />Beijingcatal\u00C3\u00A0deutscheuropeueuskaragaeilgesvenskaespa\u00C3\u00B1amensajeusuariotrabajom\u00C3\u00A9xicop\u00C3\u00A1ginasiempresistemaoctubredurantea\u00C3\u00B1adirempresamomentonuestroprimeratrav\u00C3\u00A9sgraciasnuestraprocesoestadoscalidadpersonan\u00C3\u00BAmeroacuerdom\u00C3\u00BAsicamiembroofertasalgunospa\u00C3\u00ADsesejemploderechoadem\u00C3\u00A1sprivadoagregarenlacesposiblehotelessevillaprimero\u00C3\u00BAltimoeventosarchivoculturamujeresentradaanuncioembargomercadograndesestudiomejoresfebrerodise\u00C3\u00B1oturismoc\u00C3\u00B3digoportadaespaciofamiliaantoniopermiteguardaralgunaspreciosalguiensentidovisitast\u00C3\u00ADtuloconocersegundoconsejofranciaminutossegundatenemosefectosm\u00C3\u00A1lagasesi\u00C3\u00B3nrevistagranadacompraringresogarc\u00C3\u00ADaacci\u00C3\u00B3necuadorquienesinclusodeber\u00C3\u00A1materiahombresmuestrapodr\u00C3\u00ADama\u00C3\u00B1ana\u00C3\u00BAltimaestamosoficialtambienning\u00C3\u00BAnsaludospodemosmejorarpositionbusinesshomepagesecuritylanguagestandardcampaignfeaturescategoryexternalchildrenreservedresearchexchangefavoritetemplatemilitaryindustryservicesmaterialproductsz-index:commentssoftwarecompletecalendarplatformarticlesrequiredmovementquestionbuildingpoliticspossiblereligionphysicalfeedbackregisterpicturesdisabledprotocolaudiencesettingsactivityelementslearninganythingabstractprogressoverviewmagazineeconomictrainingpressurevarious <strong>propertyshoppingtogetheradvancedbehaviordownloadfeaturedfootballselectedLanguagedistanceremembertrackingpasswordmodifiedstudentsdirectlyfightingnortherndatabasefestivalbreakinglocationinternetdropdownpracticeevidencefunctionmarriageresponseproblemsnegativeprogramsanalysisreleasedbanner\">purchasepoliciesregionalcreativeargumentbookmarkreferrerchemicaldivisioncallbackseparateprojectsconflicthardwareinterestdeliverymountainobtained= false;for(var acceptedcapacitycomputeridentityaircraftemployedproposeddomesticincludesprovidedhospitalverticalcollapseapproachpartnerslogo\"><adaughterauthor\" culturalfamilies/images/assemblypowerfulteachingfinisheddistrictcriticalcgi-bin/purposesrequireselectionbecomingprovidesacademicexerciseactuallymedicineconstantaccidentMagazinedocumentstartingbottom\">observed: &quot;extendedpreviousSoftwarecustomerdecisionstrengthdetailedslightlyplanningtextareacurrencyeveryonestraighttransferpositiveproducedheritageshippingabsolutereceivedrelevantbutton\" violenceanywherebenefitslaunchedrecentlyalliancefollowedmultiplebulletinincludedoccurredinternal$(this).republic><tr><tdcongressrecordedultimatesolution<ul id=\"discoverHome</a>websitesnetworksalthoughentirelymemorialmessagescontinueactive\">somewhatvictoriaWestern  title=\"LocationcontractvisitorsDownloadwithout right\">\nmeasureswidth = variableinvolvedvirginianormallyhappenedaccountsstandingnationalRegisterpreparedcontrolsaccuratebirthdaystrategyofficialgraphicscriminalpossiblyconsumerPersonalspeakingvalidateachieved.jpg\" />machines</h2>\n  keywordsfriendlybrotherscombinedoriginalcomposedexpectedadequatepakistanfollow\" valuable</label>relativebringingincreasegovernorplugins/List of Header\">\" name=\" (&quot;graduate</head>\ncommercemalaysiadirectormaintain;height:schedulechangingback to catholicpatternscolor: #greatestsuppliesreliable</ul>\n\t\t<select citizensclothingwatching<li id=\"specificcarryingsentence<center>contrastthinkingcatch(e)southernMichael merchantcarouselpadding:interior.split(\"lizationOctober ){returnimproved--&gt;\n\ncoveragechairman.png\" />subjectsRichard whateverprobablyrecoverybaseballjudgmentconnect..css\" /> websitereporteddefault\"/></a>\r\nelectricscotlandcreationquantity. ISBN 0did not instance-search-\" lang=\"speakersComputercontainsarchivesministerreactiondiscountItalianocriteriastrongly: 'http:'script'coveringofferingappearedBritish identifyFacebooknumerousvehiclesconcernsAmericanhandlingdiv id=\"William provider_contentaccuracysection andersonflexibleCategorylawrence<script>layout=\"approved maximumheader\"></table>Serviceshamiltoncurrent canadianchannels/themes//articleoptionalportugalvalue=\"\"intervalwirelessentitledagenciesSearch\" measuredthousandspending&hellip;new Date\" size=\"pageNamemiddle\" \" /></a>hidden\">sequencepersonaloverflowopinionsillinoislinks\">\n\t<title>versionssaturdayterminalitempropengineersectionsdesignerproposal=\"false\"Espa\u00C3\u00B1olreleasessubmit\" er&quot;additionsymptomsorientedresourceright\"><pleasurestationshistory.leaving  border=contentscenter\">.\n\nSome directedsuitablebulgaria.show();designedGeneral conceptsExampleswilliamsOriginal\"><span>search\">operatorrequestsa &quot;allowingDocumentrevision. \n\nThe yourselfContact michiganEnglish columbiapriorityprintingdrinkingfacilityreturnedContent officersRussian generate-8859-1\"indicatefamiliar qualitymargin:0 contentviewportcontacts-title\">portable.length eligibleinvolvesatlanticonload=\"default.suppliedpaymentsglossary\n\nAfter guidance</td><tdencodingmiddle\">came to displaysscottishjonathanmajoritywidgets.clinicalthailandteachers<head>\n\taffectedsupportspointer;toString</small>oklahomawill be investor0\" alt=\"holidaysResourcelicensed (which . After considervisitingexplorerprimary search\" android\"quickly meetingsestimate;return ;color:# height=approval, &quot; checked.min.js\"magnetic></a></hforecast. While thursdaydvertise&eacute;hasClassevaluateorderingexistingpatients Online coloradoOptions\"campbell<!-- end</span><<br />\r\n_popups|sciences,&quot; quality Windows assignedheight: <b classle&quot; value=\" Companyexamples<iframe believespresentsmarshallpart of properly).\n\nThe taxonomymuch of </span>\n\" data-srtugu\u00C3\u00AAsscrollTo project<head>\r\nattorneyemphasissponsorsfancyboxworld's wildlifechecked=sessionsprogrammpx;font- Projectjournalsbelievedvacationthompsonlightingand the special border=0checking</tbody><button Completeclearfix\n<head>\narticle <sectionfindingsrole in popular  Octoberwebsite exposureused to  changesoperatedclickingenteringcommandsinformed numbers  </div>creatingonSubmitmarylandcollegesanalyticlistingscontact.loggedInadvisorysiblingscontent\"s&quot;)s. This packagescheckboxsuggestspregnanttomorrowspacing=icon.png";
			}
		}

		private class DataHolder1
		{
			internal static string GetData()
			{
				return "japanesecodebasebutton\">gamblingsuch as , while </span> missourisportingtop:1px .</span>tensionswidth=\"2lazyloadnovemberused in height=\"cript\">\n&nbsp;</<tr><td height:2/productcountry include footer\" &lt;!-- title\"></jquery.</form>\n(\u00E7\u00AE\u0080\u00E4\u00BD\u0093)(\u00E7\u00B9\u0081\u00E9\u00AB\u0094)hrvatskiitalianorom\u00C3\u00A2n\u00C4\u0083t\u00C3\u00BCrk\u00C3\u00A7e\u00D8\u00A7\u00D8\u00B1\u00D8\u00AF\u00D9\u0088tambi\u00C3\u00A9nnoticiasmensajespersonasderechosnacionalserviciocontactousuariosprogramagobiernoempresasanunciosvalenciacolombiadespu\u00C3\u00A9sdeportesproyectoproductop\u00C3\u00BAbliconosotroshistoriapresentemillonesmediantepreguntaanteriorrecursosproblemasantiagonuestrosopini\u00C3\u00B3nimprimirmientrasam\u00C3\u00A9ricavendedorsociedadrespectorealizarregistropalabrasinter\u00C3\u00A9sentoncesespecialmiembrosrealidadc\u00C3\u00B3rdobazaragozap\u00C3\u00A1ginassocialesbloqueargesti\u00C3\u00B3nalquilersistemascienciascompletoversi\u00C3\u00B3ncompletaestudiosp\u00C3\u00BAblicaobjetivoalicantebuscadorcantidadentradasaccionesarchivossuperiormayor\u00C3\u00ADaalemaniafunci\u00C3\u00B3n\u00C3\u00BAltimoshaciendoaquellosedici\u00C3\u00B3nfernandoambientefacebooknuestrasclientesprocesosbastantepresentareportarcongresopublicarcomerciocontratoj\u00C3\u00B3venesdistritot\u00C3\u00A9cnicaconjuntoenerg\u00C3\u00ADatrabajarasturiasrecienteutilizarbolet\u00C3\u00ADnsalvadorcorrectatrabajosprimerosnegocioslibertaddetallespantallapr\u00C3\u00B3ximoalmer\u00C3\u00ADaanimalesqui\u00C3\u00A9nescoraz\u00C3\u00B3nsecci\u00C3\u00B3nbuscandoopcionesexteriorconceptotodav\u00C3\u00ADagaler\u00C3\u00ADaescribirmedicinalicenciaconsultaaspectoscr\u00C3\u00ADticad\u00C3\u00B3laresjusticiadeber\u00C3\u00A1nper\u00C3\u00ADodonecesitamantenerpeque\u00C3\u00B1orecibidatribunaltenerifecanci\u00C3\u00B3ncanariasdescargadiversosmallorcarequieret\u00C3\u00A9cnicodeber\u00C3\u00ADaviviendafinanzasadelantefuncionaconsejosdif\u00C3\u00ADcilciudadesantiguasavanzadat\u00C3\u00A9rminounidadess\u00C3\u00A1nchezcampa\u00C3\u00B1asoftonicrevistascontienesectoresmomentosfacultadcr\u00C3\u00A9ditodiversassupuestofactoressegundospeque\u00C3\u00B1a\u00D0\u00B3\u00D0\u00BE\u00D0\u00B4\u00D0\u00B0\u00D0\u00B5\u00D1\u0081\u00D0\u00BB\u00D0\u00B8\u00D0\u00B5\u00D1\u0081\u00D1\u0082\u00D1\u008C\u00D0\u00B1\u00D1\u008B\u00D0\u00BB\u00D0\u00BE\u00D0\u00B1\u00D1\u008B\u00D1\u0082\u00D1\u008C\u00D1\u008D\u00D1\u0082\u00D0\u00BE\u00D0\u00BC\u00D0\u0095\u00D1\u0081\u00D0\u00BB\u00D0\u00B8\u00D1\u0082\u00D0\u00BE\u00D0\u00B3\u00D0\u00BE\u00D0\u00BC\u00D0\u00B5\u00D0\u00BD\u00D1\u008F\u00D0\u00B2\u00D1\u0081\u00D0\u00B5\u00D1\u0085\u00D1\u008D\u00D1\u0082\u00D0\u00BE\u00D0\u00B9\u00D0\u00B4\u00D0\u00B0\u00D0\u00B6\u00D0\u00B5\u00D0\u00B1\u00D1\u008B\u00D0\u00BB\u00D0\u00B8\u00D0\u00B3\u00D0\u00BE\u00D0\u00B4\u00D1\u0083\u00D0\u00B4\u00D0\u00B5\u00D0\u00BD\u00D1\u008C\u00D1\u008D\u00D1\u0082\u00D0\u00BE\u00D1\u0082\u00D0\u00B1\u00D1\u008B\u00D0\u00BB\u00D0\u00B0\u00D1\u0081\u00D0\u00B5\u00D0\u00B1\u00D1\u008F\u00D0\u00BE\u00D0\u00B4\u00D0\u00B8\u00D0\u00BD\u00D1\u0081\u00D0\u00B5\u00D0\u00B1\u00D0\u00B5\u00D0\u00BD\u00D0\u00B0\u00D0\u00B4\u00D0\u00BE\u00D1\u0081\u00D0\u00B0\u00D0\u00B9\u00D1\u0082\u00D1\u0084\u00D0\u00BE\u00D1\u0082\u00D0\u00BE\u00D0\u00BD\u00D0\u00B5\u00D0\u00B3\u00D0\u00BE\u00D1\u0081\u00D0\u00B2\u00D0\u00BE\u00D0\u00B8\u00D1\u0081\u00D0\u00B2\u00D0\u00BE\u00D0\u00B9\u00D0\u00B8\u00D0\u00B3\u00D1\u0080\u00D1\u008B\u00D1\u0082\u00D0\u00BE\u00D0\u00B6\u00D0\u00B5\u00D0\u00B2\u00D1\u0081\u00D0\u00B5\u00D0\u00BC\u00D1\u0081\u00D0\u00B2\u00D0\u00BE\u00D1\u008E\u00D0\u00BB\u00D0\u00B8\u00D1\u0088\u00D1\u008C\u00D1\u008D\u00D1\u0082\u00D0\u00B8\u00D1\u0085\u00D0\u00BF\u00D0\u00BE\u00D0\u00BA\u00D0\u00B0\u00D0\u00B4\u00D0\u00BD\u00D0\u00B5\u00D0\u00B9\u00D0\u00B4\u00D0\u00BE\u00D0\u00BC\u00D0\u00B0\u00D0\u00BC\u00D0\u00B8\u00D1\u0080\u00D0\u00B0\u00D0\u00BB\u00D0\u00B8\u00D0\u00B1\u00D0\u00BE\u00D1\u0082\u00D0\u00B5\u00D0\u00BC\u00D1\u0083\u00D1\u0085\u00D0\u00BE\u00D1\u0082\u00D1\u008F\u00D0\u00B4\u00D0\u00B2\u00D1\u0083\u00D1\u0085\u00D1\u0081\u00D0\u00B5\u00D1\u0082\u00D0\u00B8\u00D0\u00BB\u00D1\u008E\u00D0\u00B4\u00D0\u00B8\u00D0\u00B4\u00D0\u00B5\u00D0\u00BB\u00D0\u00BE\u00D0\u00BC\u00D0\u00B8\u00D1\u0080\u00D0\u00B5\u00D1\u0082\u00D0\u00B5\u00D0\u00B1\u00D1\u008F\u00D1\u0081\u00D0\u00B2\u00D0\u00BE\u00D0\u00B5\u00D0\u00B2\u00D0\u00B8\u00D0\u00B4\u00D0\u00B5\u00D1\u0087\u00D0\u00B5\u00D0\u00B3\u00D0\u00BE\u00D1\u008D\u00D1\u0082\u00D0\u00B8\u00D0\u00BC\u00D1\u0081\u00D1\u0087\u00D0\u00B5\u00D1\u0082\u00D1\u0082\u00D0\u00B5\u00D0\u00BC\u00D1\u008B\u00D1\u0086\u00D0\u00B5\u00D0\u00BD\u00D1\u008B\u00D1\u0081\u00D1\u0082\u00D0\u00B0\u00D0\u00BB\u00D0\u00B2\u00D0\u00B5\u00D0\u00B4\u00D1\u008C\u00D1\u0082\u00D0\u00B5\u00D0\u00BC\u00D0\u00B5\u00D0\u00B2\u00D0\u00BE\u00D0\u00B4\u00D1\u008B\u00D1\u0082\u00D0\u00B5\u00D0\u00B1\u00D0\u00B5\u00D0\u00B2\u00D1\u008B\u00D1\u0088\u00D0\u00B5\u00D0\u00BD\u00D0\u00B0\u00D0\u00BC\u00D0\u00B8\u00D1\u0082\u00D0\u00B8\u00D0\u00BF\u00D0\u00B0\u00D1\u0082\u00D0\u00BE\u00D0\u00BC\u00D1\u0083\u00D0\u00BF\u00D1\u0080\u00D0\u00B0\u00D0\u00B2\u00D0\u00BB\u00D0\u00B8\u00D1\u0086\u00D0\u00B0\u00D0\u00BE\u00D0\u00B4\u00D0\u00BD\u00D0\u00B0\u00D0\u00B3\u00D0\u00BE\u00D0\u00B4\u00D1\u008B\u00D0\u00B7\u00D0\u00BD\u00D0\u00B0\u00D1\u008E\u00D0\u00BC\u00D0\u00BE\u00D0\u00B3\u00D1\u0083\u00D0\u00B4\u00D1\u0080\u00D1\u0083\u00D0\u00B3\u00D0\u00B2\u00D1\u0081\u00D0\u00B5\u00D0\u00B9\u00D0\u00B8\u00D0\u00B4\u00D0\u00B5\u00D1\u0082\u00D0\u00BA\u00D0\u00B8\u00D0\u00BD\u00D0\u00BE\u00D0\u00BE\u00D0\u00B4\u00D0\u00BD\u00D0\u00BE\u00D0\u00B4\u00D0\u00B5\u00D0\u00BB\u00D0\u00B0\u00D0\u00B4\u00D0\u00B5\u00D0\u00BB\u00D0\u00B5\u00D1\u0081\u00D1\u0080\u00D0\u00BE\u00D0\u00BA\u00D0\u00B8\u00D1\u008E\u00D0\u00BD\u00D1\u008F\u00D0\u00B2\u00D0\u00B5\u00D1\u0081\u00D1\u008C\u00D0\u0095\u00D1\u0081\u00D1\u0082\u00D1\u008C\u00D1\u0080\u00D0\u00B0\u00D0\u00B7\u00D0\u00B0\u00D0\u00BD\u00D0\u00B0\u00D1\u0088\u00D0\u00B8\u00D8\u00A7\u00D9\u0084\u00D9\u0084\u00D9\u0087\u00D8\u00A7\u00D9\u0084\u00D8\u00AA\u00D9\u008A\u00D8\u00AC\u00D9\u0085\u00D9\u008A\u00D8\u00B9\u00D8\u00AE\u00D8\u00A7\u00D8\u00B5\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00B0\u00D9\u008A\u00D8\u00B9\u00D9\u0084\u00D9\u008A\u00D9\u0087\u00D8\u00AC\u00D8\u00AF\u00D9\u008A\u00D8\u00AF\u00D8\u00A7\u00D9\u0084\u00D8\u00A2\u00D9\u0086\u00D8\u00A7\u00D9\u0084\u00D8\u00B1\u00D8\u00AF\u00D8\u00AA\u00D8\u00AD\u00D9\u0083\u00D9\u0085\u00D8\u00B5\u00D9\u0081\u00D8\u00AD\u00D8\u00A9\u00D9\u0083\u00D8\u00A7\u00D9\u0086\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D9\u0084\u00D9\u008A\u00D9\u008A\u00D9\u0083\u00D9\u0088\u00D9\u0086\u00D8\u00B4\u00D8\u00A8\u00D9\u0083\u00D8\u00A9\u00D9\u0081\u00D9\u008A\u00D9\u0087\u00D8\u00A7\u00D8\u00A8\u00D9\u0086\u00D8\u00A7\u00D8\u00AA\u00D8\u00AD\u00D9\u0088\u00D8\u00A7\u00D8\u00A1\u00D8\u00A3\u00D9\u0083\u00D8\u00AB\u00D8\u00B1\u00D8\u00AE\u00D9\u0084\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D9\u0084\u00D8\u00AD\u00D8\u00A8\u00D8\u00AF\u00D9\u0084\u00D9\u008A\u00D9\u0084\u00D8\u00AF\u00D8\u00B1\u00D9\u0088\u00D8\u00B3\u00D8\u00A7\u00D8\u00B6\u00D8\u00BA\u00D8\u00B7\u00D8\u00AA\u00D9\u0083\u00D9\u0088\u00D9\u0086\u00D9\u0087\u00D9\u0086\u00D8\u00A7\u00D9\u0083\u00D8\u00B3\u00D8\u00A7\u00D8\u00AD\u00D8\u00A9\u00D9\u0086\u00D8\u00A7\u00D8\u00AF\u00D9\u008A\u00D8\u00A7\u00D9\u0084\u00D8\u00B7\u00D8\u00A8\u00D8\u00B9\u00D9\u0084\u00D9\u008A\u00D9\u0083\u00D8\u00B4\u00D9\u0083\u00D8\u00B1\u00D8\u00A7\u00D9\u008A\u00D9\u0085\u00D9\u0083\u00D9\u0086\u00D9\u0085\u00D9\u0086\u00D9\u0087\u00D8\u00A7\u00D8\u00B4\u00D8\u00B1\u00D9\u0083\u00D8\u00A9\u00D8\u00B1\u00D8\u00A6\u00D9\u008A\u00D8\u00B3\u00D9\u0086\u00D8\u00B4\u00D9\u008A\u00D8\u00B7\u00D9\u0085\u00D8\u00A7\u00D8\u00B0\u00D8\u00A7\u00D8\u00A7\u00D9\u0084\u00D9\u0081\u00D9\u0086\u00D8\u00B4\u00D8\u00A8\u00D8\u00A7\u00D8\u00A8\u00D8\u00AA\u00D8\u00B9\u00D8\u00A8\u00D8\u00B1\u00D8\u00B1\u00D8\u00AD\u00D9\u0085\u00D8\u00A9\u00D9\u0083\u00D8\u00A7\u00D9\u0081\u00D8\u00A9\u00D9\u008A\u00D9\u0082\u00D9\u0088\u00D9\u0084\u00D9\u0085\u00D8\u00B1\u00D9\u0083\u00D8\u00B2\u00D9\u0083\u00D9\u0084\u00D9\u0085\u00D8\u00A9\u00D8\u00A3\u00D8\u00AD\u00D9\u0085\u00D8\u00AF\u00D9\u0082\u00D9\u0084\u00D8\u00A8\u00D9\u008A\u00D9\u008A\u00D8\u00B9\u00D9\u0086\u00D9\u008A\u00D8\u00B5\u00D9\u0088\u00D8\u00B1\u00D8\u00A9\u00D8\u00B7\u00D8\u00B1\u00D9\u008A\u00D9\u0082\u00D8\u00B4\u00D8\u00A7\u00D8\u00B1\u00D9\u0083\u00D8\u00AC\u00D9\u0088\u00D8\u00A7\u00D9\u0084\u00D8\u00A3\u00D8\u00AE\u00D8\u00B1\u00D9\u0089\u00D9\u0085\u00D8\u00B9\u00D9\u0086\u00D8\u00A7\u00D8\u00A7\u00D8\u00A8\u00D8\u00AD\u00D8\u00AB\u00D8\u00B9\u00D8\u00B1\u00D9\u0088\u00D8\u00B6\u00D8\u00A8\u00D8\u00B4\u00D9\u0083\u00D9\u0084\u00D9\u0085\u00D8\u00B3\u00D8\u00AC\u00D9\u0084\u00D8\u00A8\u00D9\u0086\u00D8\u00A7\u00D9\u0086\u00D8\u00AE\u00D8\u00A7\u00D9\u0084\u00D8\u00AF\u00D9\u0083\u00D8\u00AA\u00D8\u00A7\u00D8\u00A8\u00D9\u0083\u00D9\u0084\u00D9\u008A\u00D8\u00A9\u00D8\u00A8\u00D8\u00AF\u00D9\u0088\u00D9\u0086\u00D8\u00A3\u00D9\u008A\u00D8\u00B6\u00D8\u00A7\u00D9\u008A\u00D9\u0088\u00D8\u00AC\u00D8\u00AF\u00D9\u0081\u00D8\u00B1\u00D9\u008A\u00D9\u0082\u00D9\u0083\u00D8\u00AA\u00D8\u00A8\u00D8\u00AA\u00D8\u00A3\u00D9\u0081\u00D8\u00B6\u00D9\u0084\u00D9\u0085\u00D8\u00B7\u00D8\u00A8\u00D8\u00AE\u00D8\u00A7\u00D9\u0083\u00D8\u00AB\u00D8\u00B1\u00D8\u00A8\u00D8\u00A7\u00D8\u00B1\u00D9\u0083\u00D8\u00A7\u00D9\u0081\u00D8\u00B6\u00D9\u0084\u00D8\u00A7\u00D8\u00AD\u00D9\u0084\u00D9\u0089\u00D9\u0086\u00D9\u0081\u00D8\u00B3\u00D9\u0087\u00D8\u00A3\u00D9\u008A\u00D8\u00A7\u00D9\u0085\u00D8\u00B1\u00D8\u00AF\u00D9\u0088\u00D8\u00AF\u00D8\u00A3\u00D9\u0086\u00D9\u0087\u00D8\u00A7\u00D8\u00AF\u00D9\u008A\u00D9\u0086\u00D8\u00A7\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D9\u0086\u00D9\u0085\u00D8\u00B9\u00D8\u00B1\u00D8\u00B6\u00D8\u00AA\u00D8\u00B9\u00D9\u0084\u00D9\u0085\u00D8\u00AF\u00D8\u00A7\u00D8\u00AE\u00D9\u0084\u00D9\u0085\u00D9\u0085\u00D9\u0083\u00D9\u0086\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0002\u0000\u0002\u0000\u0002\u0000\u0002\u0000\u0004\u0000\u0004\u0000\u0004\u0000\u0004\u0000\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\u0007\u0006\u0005\u0004\u0003\u0002\u0001\u0000\u0008\t\n\u000B\u000C\r\u000E\u000F\u000F\u000E\r\u000C\u000B\n\t\u0008\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0017\u0016\u0015\u0014\u0013\u0012\u0011\u0010\u0018\u0019\u001A\u001B\u001C\u001D\u001E\u001F\u001F\u001E\u001D\u001C\u001B\u001A\u0019\u0018\u00FF\u00FF\u00FF\u00FF\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u00FF\u00FF\u00FF\u00FF\u0001\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u00FF\u00FF\u0000\u0001\u0000\u0000\u0000\u0001\u0000\u0000\u00FF\u00FF\u0000\u0001\u0000\u0000\u0000\u0008\u0000\u0008\u0000\u0008\u0000\u0008\u0000\u0000\u0000\u0001\u0000\u0002\u0000\u0003\u0000\u0004\u0000\u0005\u0000\u0006\u0000\u0007resourcescountriesquestionsequipmentcommunityavailablehighlightDTD/xhtmlmarketingknowledgesomethingcontainerdirectionsubscribeadvertisecharacter\" value=\"</select>Australia\" class=\"situationauthorityfollowingprimarilyoperationchallengedevelopedanonymousfunction functionscompaniesstructureagreement\" title=\"potentialeducationargumentssecondarycopyrightlanguagesexclusivecondition</form>\r\nstatementattentionBiography} else {\nsolutionswhen the Analyticstemplatesdangeroussatellitedocumentspublisherimportantprototypeinfluence&raquo;</effectivegenerallytransformbeautifultransportorganizedpublishedprominentuntil thethumbnailNational .focus();over the migrationannouncedfooter\">\nexceptionless thanexpensiveformationframeworkterritoryndicationcurrentlyclassNamecriticismtraditionelsewhereAlexanderappointedmaterialsbroadcastmentionedaffiliate</option>treatmentdifferent/default.Presidentonclick=\"biographyotherwisepermanentFran\u00C3\u00A7aisHollywoodexpansionstandards</style>\nreductionDecember preferredCambridgeopponentsBusiness confusion>\n<title>presentedexplaineddoes not worldwideinterfacepositionsnewspaper</table>\nmountainslike the essentialfinancialselectionaction=\"/abandonedEducationparseInt(stabilityunable to</title>\nrelationsNote thatefficientperformedtwo yearsSince thethereforewrapper\">alternateincreasedBattle ofperceivedtrying tonecessaryportrayedelectionsElizabeth</iframe>discoveryinsurances.length;legendaryGeographycandidatecorporatesometimesservices.inherited</strong>CommunityreligiouslocationsCommitteebuildingsthe worldno longerbeginningreferencecannot befrequencytypicallyinto the relative;recordingpresidentinitiallytechniquethe otherit can beexistenceunderlinethis timetelephoneitemscopepracticesadvantage);return For otherprovidingdemocracyboth the extensivesufferingsupportedcomputers functionpracticalsaid thatit may beEnglish</from the scheduleddownloads</label>\nsuspectedmargin: 0spiritual</head>\n\nmicrosoftgraduallydiscussedhe becameexecutivejquery.jshouseholdconfirmedpurchasedliterallydestroyedup to thevariationremainingit is notcenturiesJapanese among thecompletedalgorithminterestsrebellionundefinedencourageresizableinvolvingsensitiveuniversalprovision(althoughfeaturingconducted), which continued-header\">February numerous overflow:componentfragmentsexcellentcolspan=\"technicalnear the Advanced source ofexpressedHong Kong Facebookmultiple mechanismelevationoffensive</form>\n\tsponsoreddocument.or &quot;there arethose whomovementsprocessesdifficultsubmittedrecommendconvincedpromoting\" width=\".replace(classicalcoalitionhis firstdecisionsassistantindicatedevolution-wrapper\"enough toalong thedelivered-->\r\n<!--American protectedNovember </style><furnitureInternet  onblur=\"suspendedrecipientbased on Moreover,abolishedcollectedwere madeemotionalemergencynarrativeadvocatespx;bordercommitteddir=\"ltr\"employeesresearch. selectedsuccessorcustomersdisplayedSeptemberaddClass(Facebook suggestedand lateroperatingelaborateSometimesInstitutecertainlyinstalledfollowersJerusalemthey havecomputinggeneratedprovincesguaranteearbitraryrecognizewanted topx;width:theory ofbehaviourWhile theestimatedbegan to it becamemagnitudemust havemore thanDirectoryextensionsecretarynaturallyoccurringvariablesgiven theplatform.</label><failed tocompoundskinds of societiesalongside --&gt;\n\nsouthwestthe rightradiationmay have unescape(spoken in\" href=\"/programmeonly the come fromdirectoryburied ina similarthey were</font></Norwegianspecifiedproducingpassenger(new DatetemporaryfictionalAfter theequationsdownload.regularlydeveloperabove thelinked tophenomenaperiod oftooltip\">substanceautomaticaspect ofAmong theconnectedestimatesAir Forcesystem ofobjectiveimmediatemaking itpaintingsconqueredare stillproceduregrowth ofheaded byEuropean divisionsmoleculesfranchiseintentionattractedchildhoodalso useddedicatedsingaporedegree offather ofconflicts</a></p>\ncame fromwere usednote thatreceivingExecutiveeven moreaccess tocommanderPoliticalmusiciansdeliciousprisonersadvent ofUTF-8\" /><![CDATA[\">ContactSouthern bgcolor=\"series of. It was in Europepermittedvalidate.appearingofficialsseriously-languageinitiatedextendinglong-terminflationsuch thatgetCookiemarked by</button>implementbut it isincreasesdown the requiringdependent-->\n<!-- interviewWith the copies ofconsensuswas builtVenezuela(formerlythe statepersonnelstrategicfavour ofinventionWikipediacontinentvirtuallywhich wasprincipleComplete identicalshow thatprimitiveaway frommolecularpreciselydissolvedUnder theversion=\">&nbsp;</It is the This is will haveorganismssome timeFriedrichwas firstthe only fact thatform id=\"precedingTechnicalphysicistoccurs innavigatorsection\">span id=\"sought tobelow thesurviving}</style>his deathas in thecaused bypartiallyexisting using thewas givena list oflevels ofnotion ofOfficial dismissedscientistresemblesduplicateexplosiverecoveredall othergalleries{padding:people ofregion ofaddressesassociateimg alt=\"in modernshould bemethod ofreportingtimestampneeded tothe Greatregardingseemed toviewed asimpact onidea thatthe Worldheight ofexpandingThese arecurrent\">carefullymaintainscharge ofClassicaladdressedpredictedownership<div id=\"right\">\r\nresidenceleave thecontent\">are often  })();\r\nprobably Professor-button\" respondedsays thathad to beplaced inHungarianstatus ofserves asUniversalexecutionaggregatefor whichinfectionagreed tohowever, popular\">placed onconstructelectoralsymbol ofincludingreturn toarchitectChristianprevious living ineasier toprofessor\n&lt;!-- effect ofanalyticswas takenwhere thetook overbelief inAfrikaansas far aspreventedwork witha special<fieldsetChristmasRetrieved\n\nIn the back intonortheastmagazines><strong>committeegoverninggroups ofstored inestablisha generalits firsttheir ownpopulatedan objectCaribbeanallow thedistrictswisconsinlocation.; width: inhabitedSocialistJanuary 1</footer>similarlychoice ofthe same specific business The first.length; desire todeal withsince theuserAgentconceivedindex.phpas &quot;engage inrecently,few yearswere also\n<head>\n<edited byare knowncities inaccesskeycondemnedalso haveservices,family ofSchool ofconvertednature of languageministers</object>there is a popularsequencesadvocatedThey wereany otherlocation=enter themuch morereflectedwas namedoriginal a typicalwhen theyengineerscould notresidentswednesdaythe third productsJanuary 2what theya certainreactionsprocessorafter histhe last contained\"></div>\n</a></td>depend onsearch\">\npieces ofcompetingReferencetennesseewhich has version=</span> <</header>gives thehistorianvalue=\"\">padding:0view thattogether,the most was foundsubset ofattack onchildren,points ofpersonal position:allegedlyClevelandwas laterand afterare givenwas stillscrollingdesign ofmakes themuch lessAmericans.\n\nAfter , but theMuseum oflouisiana(from theminnesotaparticlesa processDominicanvolume ofreturningdefensive00px|righmade frommouseover\" style=\"states of(which iscontinuesFranciscobuilding without awith somewho woulda form ofa part ofbefore itknown as  Serviceslocation and oftenmeasuringand it ispaperbackvalues of\r\n<title>= window.determineer&quot; played byand early</center>from thisthe threepower andof &quot;innerHTML<a href=\"y:inline;Church ofthe eventvery highofficial -height: content=\"/cgi-bin/to createafrikaansesperantofran\u00C3\u00A7aislatvie\u00C5\u00A1ulietuvi\u00C5\u00B3\u00C4\u008Ce\u00C5\u00A1tina\u00C4\u008De\u00C5\u00A1tina\u00E0\u00B9\u0084\u00E0\u00B8\u0097\u00E0\u00B8\u00A2\u00E6\u0097\u00A5\u00E6\u009C\u00AC\u00E8\u00AA\u009E\u00E7\u00AE\u0080\u00E4\u00BD\u0093\u00E5\u00AD\u0097\u00E7\u00B9\u0081\u00E9\u00AB\u0094\u00E5\u00AD\u0097\u00ED\u0095\u009C\u00EA\u00B5\u00AD\u00EC\u0096\u00B4\u00E4\u00B8\u00BA\u00E4\u00BB\u0080\u00E4\u00B9\u0088\u00E8\u00AE\u00A1\u00E7\u00AE\u0097\u00E6\u009C\u00BA\u00E7\u00AC\u0094\u00E8\u00AE\u00B0\u00E6\u009C\u00AC\u00E8\u00A8\u008E\u00E8\u00AB\u0096\u00E5\u008D\u0080\u00E6\u009C\u008D\u00E5\u008A\u00A1\u00E5\u0099\u00A8\u00E4\u00BA\u0092\u00E8\u0081\u0094\u00E7\u00BD\u0091\u00E6\u0088\u00BF\u00E5\u009C\u00B0\u00E4\u00BA\u00A7\u00E4\u00BF\u00B1\u00E4\u00B9\u0090\u00E9\u0083\u00A8\u00E5\u0087\u00BA\u00E7\u0089\u0088\u00E7\u00A4\u00BE\u00E6\u008E\u0092\u00E8\u00A1\u008C\u00E6\u00A6\u009C\u00E9\u0083\u00A8\u00E8\u0090\u00BD\u00E6\u00A0\u00BC\u00E8\u00BF\u009B\u00E4\u00B8\u0080\u00E6\u00AD\u00A5\u00E6\u0094\u00AF\u00E4\u00BB\u0098\u00E5\u00AE\u009D\u00E9\u00AA\u008C\u00E8\u00AF\u0081\u00E7\u00A0\u0081\u00E5\u00A7\u0094\u00E5\u0091\u0098\u00E4\u00BC\u009A\u00E6\u0095\u00B0\u00E6\u008D\u00AE\u00E5\u00BA\u0093\u00E6\u00B6\u0088\u00E8\u00B4\u00B9\u00E8\u0080\u0085\u00E5\u008A\u009E\u00E5\u0085\u00AC\u00E5\u00AE\u00A4\u00E8\u00AE\u00A8\u00E8\u00AE\u00BA\u00E5\u008C\u00BA\u00E6\u00B7\u00B1\u00E5\u009C\u00B3\u00E5\u00B8\u0082\u00E6\u0092\u00AD\u00E6\u0094\u00BE\u00E5\u0099\u00A8\u00E5\u008C\u0097\u00E4\u00BA\u00AC\u00E5\u00B8\u0082\u00E5\u00A4\u00A7\u00E5\u00AD\u00A6\u00E7\u0094\u009F\u00E8\u00B6\u008A\u00E6\u009D\u00A5\u00E8\u00B6\u008A\u00E7\u00AE\u00A1\u00E7\u0090\u0086\u00E5\u0091\u0098\u00E4\u00BF\u00A1\u00E6\u0081\u00AF\u00E7\u00BD\u0091serviciosart\u00C3\u00ADculoargentinabarcelonacualquierpublicadoproductospol\u00C3\u00ADticarespuestawikipediasiguienteb\u00C3\u00BAsquedacomunidadseguridadprincipalpreguntascontenidorespondervenezuelaproblemasdiciembrerelaci\u00C3\u00B3nnoviembresimilaresproyectosprogramasinstitutoactividadencuentraeconom\u00C3\u00ADaim\u00C3\u00A1genescontactardescargarnecesarioatenci\u00C3\u00B3ntel\u00C3\u00A9fonocomisi\u00C3\u00B3ncancionescapacidadencontraran\u00C3\u00A1lisisfavoritost\u00C3\u00A9rminosprovinciaetiquetaselementosfuncionesresultadocar\u00C3\u00A1cterpropiedadprincipionecesidadmunicipalcreaci\u00C3\u00B3ndescargaspresenciacomercialopinionesejercicioeditorialsalamancagonz\u00C3\u00A1lezdocumentopel\u00C3\u00ADcularecientesgeneralestarragonapr\u00C3\u00A1cticanovedadespropuestapacientest\u00C3\u00A9cnicasobjetivoscontactos\u00E0\u00A4\u00AE\u00E0\u00A5\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u00B2\u00E0\u00A4\u00BF\u00E0\u00A4\u008F\u00E0\u00A4\u00B9\u00E0\u00A5\u0088\u00E0\u00A4\u0082\u00E0\u00A4\u0097\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A4\u00BE\u00E0\u00A4\u00A5\u00E0\u00A4\u008F\u00E0\u00A4\u00B5\u00E0\u00A4\u0082\u00E0\u00A4\u00B0\u00E0\u00A4\u00B9\u00E0\u00A5\u0087\u00E0\u00A4\u0095\u00E0\u00A5\u008B\u00E0\u00A4\u0088\u00E0\u00A4\u0095\u00E0\u00A5\u0081\u00E0\u00A4\u009B\u00E0\u00A4\u00B0\u00E0\u00A4\u00B9\u00E0\u00A4\u00BE\u00E0\u00A4\u00AC\u00E0\u00A4\u00BE\u00E0\u00A4\u00A6\u00E0\u00A4\u0095\u00E0\u00A4\u00B9\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A4\u00AD\u00E0\u00A5\u0080\u00E0\u00A4\u00B9\u00E0\u00A5\u0081\u00E0\u00A4\u008F\u00E0\u00A4\u00B0\u00E0\u00A4\u00B9\u00E0\u00A5\u0080\u00E0\u00A4\u00AE\u00E0\u00A5\u0088\u00E0\u00A4\u0082\u00E0\u00A4\u00A6\u00E0\u00A4\u00BF\u00E0\u00A4\u00A8\u00E0\u00A4\u00AC\u00E0\u00A4\u00BE\u00E0\u00A4\u00A4diplodocs\u00E0\u00A4\u00B8\u00E0\u00A4\u00AE\u00E0\u00A4\u00AF\u00E0\u00A4\u00B0\u00E0\u00A5\u0082\u00E0\u00A4\u00AA\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00AE\u00E0\u00A4\u00AA\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u00AB\u00E0\u00A4\u00BF\u00E0\u00A4\u00B0\u00E0\u00A4\u0094\u00E0\u00A4\u00B8\u00E0\u00A4\u00A4\u00E0\u00A4\u00A4\u00E0\u00A4\u00B0\u00E0\u00A4\u00B9\u00E0\u00A4\u00B2\u00E0\u00A5\u008B\u00E0\u00A4\u0097\u00E0\u00A4\u00B9\u00E0\u00A5\u0081\u00E0\u00A4\u0086\u00E0\u00A4\u00AC\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00A6\u00E0\u00A5\u0087\u00E0\u00A4\u00B6\u00E0\u00A4\u00B9\u00E0\u00A5\u0081\u00E0\u00A4\u0088\u00E0\u00A4\u0096\u00E0\u00A5\u0087\u00E0\u00A4\u00B2\u00E0\u00A4\u00AF\u00E0\u00A4\u00A6\u00E0\u00A4\u00BF\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00AE\u00E0\u00A4\u00B5\u00E0\u00A5\u0087\u00E0\u00A4\u00AC\u00E0\u00A4\u00A4\u00E0\u00A5\u0080\u00E0\u00A4\u00A8\u00E0\u00A4\u00AC\u00E0\u00A5\u0080\u00E0\u00A4\u009A\u00E0\u00A4\u00AE\u00E0\u00A5\u008C\u00E0\u00A4\u00A4\u00E0\u00A4\u00B8\u00E0\u00A4\u00BE\u00E0\u00A4\u00B2\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u0096\u00E0\u00A4\u009C\u00E0\u00A5\u0089\u00E0\u00A4\u00AC\u00E0\u00A4\u00AE\u00E0\u00A4\u00A6\u00E0\u00A4\u00A6\u00E0\u00A4\u00A4\u00E0\u00A4\u00A5\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A4\u00B9\u00E0\u00A5\u0080\u00E0\u00A4\u00B6\u00E0\u00A4\u00B9\u00E0\u00A4\u00B0\u00E0\u00A4\u0085\u00E0\u00A4\u00B2\u00E0\u00A4\u0097\u00E0\u00A4\u0095\u00E0\u00A4\u00AD\u00E0\u00A5\u0080\u00E0\u00A4\u00A8\u00E0\u00A4\u0097\u00E0\u00A4\u00B0\u00E0\u00A4\u00AA\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u00A4\u00E0\u00A4\u0095\u00E0\u00A4\u00BF\u00E0\u00A4\u008F\u00E0\u00A4\u0089\u00E0\u00A4\u00B8\u00E0\u00A5\u0087\u00E0\u00A4\u0097\u00E0\u00A4\u00AF\u00E0\u00A5\u0080\u00E0\u00A4\u00B9\u00E0\u00A5\u0082\u00E0\u00A4\u0081\u00E0\u00A4\u0086\u00E0\u00A4\u0097\u00E0\u00A5\u0087\u00E0\u00A4\u009F\u00E0\u00A5\u0080\u00E0\u00A4\u00AE\u00E0\u00A4\u0096\u00E0\u00A5\u008B\u00E0\u00A4\u009C\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u0085\u00E0\u00A4\u00AD\u00E0\u00A5\u0080\u00E0\u00A4\u0097\u00E0\u00A4\u00AF\u00E0\u00A5\u0087\u00E0\u00A4\u00A4\u00E0\u00A5\u0081\u00E0\u00A4\u00AE\u00E0\u00A4\u00B5\u00E0\u00A5\u008B\u00E0\u00A4\u009F\u00E0\u00A4\u00A6\u00E0\u00A5\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u0085\u00E0\u00A4\u0097\u00E0\u00A4\u00B0\u00E0\u00A4\u0090\u00E0\u00A4\u00B8\u00E0\u00A5\u0087\u00E0\u00A4\u00AE\u00E0\u00A5\u0087\u00E0\u00A4\u00B2\u00E0\u00A4\u00B2\u00E0\u00A4\u0097\u00E0\u00A4\u00BE\u00E0\u00A4\u00B9\u00E0\u00A4\u00BE\u00E0\u00A4\u00B2\u00E0\u00A4\u008A\u00E0\u00A4\u00AA\u00E0\u00A4\u00B0\u00E0\u00A4\u009A\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u0090\u00E0\u00A4\u00B8\u00E0\u00A4\u00BE\u00E0\u00A4\u00A6\u00E0\u00A5\u0087\u00E0\u00A4\u00B0\u00E0\u00A4\u009C\u00E0\u00A4\u00BF\u00E0\u00A4\u00B8\u00E0\u00A4\u00A6\u00E0\u00A4\u00BF\u00E0\u00A4\u00B2\u00E0\u00A4\u00AC\u00E0\u00A4\u0082\u00E0\u00A4\u00A6\u00E0\u00A4\u00AC\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00B9\u00E0\u00A5\u0082\u00E0\u00A4\u0082\u00E0\u00A4\u00B2\u00E0\u00A4\u00BE\u00E0\u00A4\u0096\u00E0\u00A4\u009C\u00E0\u00A5\u0080\u00E0\u00A4\u00A4\u00E0\u00A4\u00AC\u00E0\u00A4\u009F\u00E0\u00A4\u00A8\u00E0\u00A4\u00AE\u00E0\u00A4\u00BF\u00E0\u00A4\u00B2\u00E0\u00A4\u0087\u00E0\u00A4\u00B8\u00E0\u00A5\u0087\u00E0\u00A4\u0086\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u00A8\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u0095\u00E0\u00A5\u0081\u00E0\u00A4\u00B2\u00E0\u00A4\u00B2\u00E0\u00A5\u0089\u00E0\u00A4\u0097\u00E0\u00A4\u00AD\u00E0\u00A4\u00BE\u00E0\u00A4\u0097\u00E0\u00A4\u00B0\u00E0\u00A5\u0087\u00E0\u00A4\u00B2\u00E0\u00A4\u009C\u00E0\u00A4\u0097\u00E0\u00A4\u00B9\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u00AE\u00E0\u00A4\u00B2\u00E0\u00A4\u0097\u00E0\u00A5\u0087\u00E0\u00A4\u00AA\u00E0\u00A5\u0087\u00E0\u00A4\u009C\u00E0\u00A4\u00B9\u00E0\u00A4\u00BE\u00E0\u00A4\u00A5\u00E0\u00A4\u0087\u00E0\u00A4\u00B8\u00E0\u00A5\u0080\u00E0\u00A4\u00B8\u00E0\u00A4\u00B9\u00E0\u00A5\u0080\u00E0\u00A4\u0095\u00E0\u00A4\u00B2\u00E0\u00A4\u00BE\u00E0\u00A4\u00A0\u00E0\u00A5\u0080\u00E0\u00A4\u0095\u00E0\u00A4\u00B9\u00E0\u00A4\u00BE\u00E0\u00A4\u0081\u00E0\u00A4\u00A6\u00E0\u00A5\u0082\u00E0\u00A4\u00B0\u00E0\u00A4\u00A4\u00E0\u00A4\u00B9\u00E0\u00A4\u00A4\u00E0\u00A4\u00B8\u00E0\u00A4\u00BE\u00E0\u00A4\u00A4\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00A6\u00E0\u00A4\u0086\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00AA\u00E0\u00A4\u00BE\u00E0\u00A4\u0095\u00E0\u00A4\u0095\u00E0\u00A5\u008C\u00E0\u00A4\u00A8\u00E0\u00A4\u00B6\u00E0\u00A4\u00BE\u00E0\u00A4\u00AE\u00E0\u00A4\u00A6\u00E0\u00A5\u0087\u00E0\u00A4\u0096\u00E0\u00A4\u00AF\u00E0\u00A4\u00B9\u00E0\u00A5\u0080\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u00AF\u00E0\u00A4\u0096\u00E0\u00A5\u0081\u00E0\u00A4\u00A6\u00E0\u00A4\u00B2\u00E0\u00A4\u0097\u00E0\u00A5\u0080categoriesexperience</title>\r\nCopyright javascriptconditionseverything<p class=\"technologybackground<a class=\"management&copy; 201javaScriptcharactersbreadcrumbthemselveshorizontalgovernmentCaliforniaactivitiesdiscoveredNavigationtransitionconnectionnavigationappearance</title><mcheckbox\" techniquesprotectionapparentlyas well asunt', 'UA-resolutionoperationstelevisiontranslatedWashingtonnavigator. = window.impression&lt;br&gt;literaturepopulationbgcolor=\"#especially content=\"productionnewsletterpropertiesdefinitionleadershipTechnologyParliamentcomparisonul class=\".indexOf(\"conclusiondiscussioncomponentsbiologicalRevolution_containerunderstoodnoscript><permissioneach otheratmosphere onfocus=\"<form id=\"processingthis.valuegenerationConferencesubsequentwell-knownvariationsreputationphenomenondisciplinelogo.png\" (document,boundariesexpressionsettlementBackgroundout of theenterprise(\"https:\" unescape(\"password\" democratic<a href=\"/wrapper\">\nmembershiplinguisticpx;paddingphilosophyassistanceuniversityfacilitiesrecognizedpreferenceif (typeofmaintainedvocabularyhypothesis.submit();&amp;nbsp;annotationbehind theFoundationpublisher\"assumptionintroducedcorruptionscientistsexplicitlyinstead ofdimensions onClick=\"considereddepartmentoccupationsoon afterinvestmentpronouncedidentifiedexperimentManagementgeographic\" height=\"link rel=\".replace(/depressionconferencepunishmenteliminatedresistanceadaptationoppositionwell knownsupplementdeterminedh1 class=\"0px;marginmechanicalstatisticscelebratedGovernment\n\nDuring tdevelopersartificialequivalentoriginatedCommissionattachment<span id=\"there wereNederlandsbeyond theregisteredjournalistfrequentlyall of thelang=\"en\" </style>\r\nabsolute; supportingextremely mainstream</strong> popularityemployment</table>\r\n colspan=\"</form>\n  conversionabout the </p></div>integrated\" lang=\"enPortuguesesubstituteindividualimpossiblemultimediaalmost allpx solid #apart fromsubject toin Englishcriticizedexcept forguidelinesoriginallyremarkablethe secondh2 class=\"<a title=\"(includingparametersprohibited= \"http://dictionaryperceptionrevolutionfoundationpx;height:successfulsupportersmillenniumhis fatherthe &quot;no-repeat;commercialindustrialencouragedamount of unofficialefficiencyReferencescoordinatedisclaimerexpeditiondevelopingcalculatedsimplifiedlegitimatesubstring(0\" class=\"completelyillustratefive yearsinstrumentPublishing1\" class=\"psychologyconfidencenumber of absence offocused onjoined thestructurespreviously></iframe>once againbut ratherimmigrantsof course,a group ofLiteratureUnlike the</a>&nbsp;\nfunction it was theConventionautomobileProtestantaggressiveafter the Similarly,\" /></div>collection\r\nfunctionvisibilitythe use ofvolunteersattractionunder the threatened*<![CDATA[importancein generalthe latter</form>\n</.indexOf('i = 0; i <differencedevoted totraditionssearch forultimatelytournamentattributesso-called }\n</style>evaluationemphasizedaccessible</section>successionalong withMeanwhile,industries</a><br />has becomeaspects ofTelevisionsufficientbasketballboth sidescontinuingan article<img alt=\"adventureshis mothermanchesterprinciplesparticularcommentaryeffects ofdecided to\"><strong>publishersJournal ofdifficultyfacilitateacceptablestyle.css\"\tfunction innovation>Copyrightsituationswould havebusinessesDictionarystatementsoften usedpersistentin Januarycomprising</title>\n\tdiplomaticcontainingperformingextensionsmay not beconcept of onclick=\"It is alsofinancial making theLuxembourgadditionalare calledengaged in\"script\");but it waselectroniconsubmit=\"\n<!-- End electricalofficiallysuggestiontop of theunlike theAustralianOriginallyreferences\n</head>\r\nrecognisedinitializelimited toAlexandriaretirementAdventuresfour years\n\n&lt;!-- increasingdecorationh3 class=\"origins ofobligationregulationclassified(function(advantagesbeing the historians<base hrefrepeatedlywilling tocomparabledesignatednominationfunctionalinside therevelationend of thes for the authorizedrefused totake placeautonomouscompromisepolitical restauranttwo of theFebruary 2quality ofswfobject.understandnearly allwritten byinterviews\" width=\"1withdrawalfloat:leftis usuallycandidatesnewspapersmysteriousDepartmentbest knownparliamentsuppressedconvenientremembereddifferent systematichas led topropagandacontrolledinfluencesceremonialproclaimedProtectionli class=\"Scientificclass=\"no-trademarksmore than widespreadLiberationtook placeday of theas long asimprisonedAdditional\n<head>\n<mLaboratoryNovember 2exceptionsIndustrialvariety offloat: lefDuring theassessmenthave been deals withStatisticsoccurrence/ul></div>clearfix\">the publicmany yearswhich wereover time,synonymouscontent\">\npresumablyhis familyuserAgent.unexpectedincluding challengeda minorityundefined\"belongs totaken fromin Octoberposition: said to bereligious Federation rowspan=\"only a fewmeant thatled to the-->\r\n<div <fieldset>Archbishop class=\"nobeing usedapproachesprivilegesnoscript>\nresults inmay be theEaster eggmechanismsreasonablePopulationCollectionselected\">noscript>\r/index.phparrival of-jssdk'));managed toincompletecasualtiescompletionChristiansSeptember arithmeticproceduresmight haveProductionit appearsPhilosophyfriendshipleading togiving thetoward theguaranteeddocumentedcolor:#000video gamecommissionreflectingchange theassociatedsans-serifonkeypress; padding:He was theunderlyingtypically , and the srcElementsuccessivesince the should be networkingaccountinguse of thelower thanshows that</span>\n\t\tcomplaintscontinuousquantitiesastronomerhe did notdue to itsapplied toan averageefforts tothe futureattempt toTherefore,capabilityRepublicanwas formedElectronickilometerschallengespublishingthe formerindigenousdirectionssubsidiaryconspiracydetails ofand in theaffordablesubstancesreason forconventionitemtype=\"absolutelysupposedlyremained aattractivetravellingseparatelyfocuses onelementaryapplicablefound thatstylesheetmanuscriptstands for no-repeat(sometimesCommercialin Americaundertakenquarter ofan examplepersonallyindex.php?</button>\npercentagebest-knowncreating a\" dir=\"ltrLieutenant\n<div id=\"they wouldability ofmade up ofnoted thatclear thatargue thatto anotherchildren'spurpose offormulatedbased uponthe regionsubject ofpassengerspossession.\n\nIn the Before theafterwardscurrently across thescientificcommunity.capitalismin Germanyright-wingthe systemSociety ofpoliticiandirection:went on toremoval of New York apartmentsindicationduring theunless thehistoricalhad been adefinitiveingredientattendanceCenter forprominencereadyStatestrategiesbut in theas part ofconstituteclaim thatlaboratorycompatiblefailure of, such as began withusing the to providefeature offrom which/\" class=\"geologicalseveral ofdeliberateimportant holds thating&quot; valign=topthe Germanoutside ofnegotiatedhis careerseparationid=\"searchwas calledthe fourthrecreationother thanpreventionwhile the education,connectingaccuratelywere builtwas killedagreementsmuch more Due to thewidth: 100some otherKingdom ofthe entirefamous forto connectobjectivesthe Frenchpeople andfeatured\">is said tostructuralreferendummost oftena separate->\n<div id Official worldwide.aria-labelthe planetand it wasd\" value=\"looking atbeneficialare in themonitoringreportedlythe modernworking onallowed towhere the innovative</a></div>soundtracksearchFormtend to beinput id=\"opening ofrestrictedadopted byaddressingtheologianmethods ofvariant ofChristian very largeautomotiveby far therange frompursuit offollow thebrought toin Englandagree thataccused ofcomes frompreventingdiv style=his or hertremendousfreedom ofconcerning0 1em 1em;Basketball/style.cssan earliereven after/\" title=\".com/indextaking thepittsburghcontent\">\r<script>(fturned outhaving the</span>\r\n occasionalbecause itstarted tophysically></div>\n  created byCurrently, bgcolor=\"tabindex=\"disastrousAnalytics also has a><div id=\"</style>\n<called forsinger and.src = \"//violationsthis pointconstantlyis locatedrecordingsd from thenederlandsportugu\u00C3\u00AAs\u00D7\u00A2\u00D7\u0091\u00D7\u00A8\u00D7\u0099\u00D7\u00AA\u00D9\u0081\u00D8\u00A7\u00D8\u00B1\u00D8\u00B3\u00DB\u008Cdesarrollocomentarioeducaci\u00C3\u00B3nseptiembreregistradodirecci\u00C3\u00B3nubicaci\u00C3\u00B3npublicidadrespuestasresultadosimportantereservadosart\u00C3\u00ADculosdiferentessiguientesrep\u00C3\u00BAblicasituaci\u00C3\u00B3nministerioprivacidaddirectorioformaci\u00C3\u00B3npoblaci\u00C3\u00B3npresidentecontenidosaccesoriostechnoratipersonalescategor\u00C3\u00ADaespecialesdisponibleactualidadreferenciavalladolidbibliotecarelacionescalendariopol\u00C3\u00ADticasanterioresdocumentosnaturalezamaterialesdiferenciaecon\u00C3\u00B3micatransporterodr\u00C3\u00ADguezparticiparencuentrandiscusi\u00C3\u00B3nestructurafundaci\u00C3\u00B3nfrecuentespermanentetotalmente\u00D0\u00BC\u00D0\u00BE\u00D0\u00B6\u00D0\u00BD\u00D0\u00BE\u00D0\u00B1\u00D1\u0083\u00D0\u00B4\u00D0\u00B5\u00D1\u0082\u00D0\u00BC\u00D0\u00BE\u00D0\u00B6\u00D0\u00B5\u00D1\u0082\u00D0\u00B2\u00D1\u0080\u00D0\u00B5\u00D0\u00BC\u00D1\u008F\u00D1\u0082\u00D0\u00B0\u00D0\u00BA\u00D0\u00B6\u00D0\u00B5\u00D1\u0087\u00D1\u0082\u00D0\u00BE\u00D0\u00B1\u00D1\u008B\u00D0\u00B1\u00D0\u00BE\u00D0\u00BB\u00D0\u00B5\u00D0\u00B5\u00D0\u00BE\u00D1\u0087\u00D0\u00B5\u00D0\u00BD\u00D1\u008C\u00D1\u008D\u00D1\u0082\u00D0\u00BE\u00D0\u00B3\u00D0\u00BE\u00D0\u00BA\u00D0\u00BE\u00D0\u00B3\u00D0\u00B4\u00D0\u00B0\u00D0\u00BF\u00D0\u00BE\u00D1\u0081\u00D0\u00BB\u00D0\u00B5\u00D0\u00B2\u00D1\u0081\u00D0\u00B5\u00D0\u00B3\u00D0\u00BE\u00D1\u0081\u00D0\u00B0\u00D0\u00B9\u00D1\u0082\u00D0\u00B5\u00D1\u0087\u00D0\u00B5\u00D1\u0080\u00D0\u00B5\u00D0\u00B7\u00D0\u00BC\u00D0\u00BE\u00D0\u00B3\u00D1\u0083\u00D1\u0082\u00D1\u0081\u00D0\u00B0\u00D0\u00B9\u00D1\u0082\u00D0\u00B0\u00D0\u00B6\u00D0\u00B8\u00D0\u00B7\u00D0\u00BD\u00D0\u00B8\u00D0\u00BC\u00D0\u00B5\u00D0\u00B6\u00D0\u00B4\u00D1\u0083\u00D0\u00B1\u00D1\u0083\u00D0\u00B4\u00D1\u0083\u00D1\u0082\u00D0\u009F\u00D0\u00BE\u00D0\u00B8\u00D1\u0081\u00D0\u00BA\u00D0\u00B7\u00D0\u00B4\u00D0\u00B5\u00D1\u0081\u00D1\u008C\u00D0\u00B2\u00D0\u00B8\u00D0\u00B4\u00D0\u00B5\u00D0\u00BE\u00D1\u0081\u00D0\u00B2\u00D1\u008F\u00D0\u00B7\u00D0\u00B8\u00D0\u00BD\u00D1\u0083\u00D0\u00B6\u00D0\u00BD\u00D0\u00BE\u00D1\u0081\u00D0\u00B2\u00D0\u00BE\u00D0\u00B5\u00D0\u00B9\u00D0\u00BB\u00D1\u008E\u00D0\u00B4\u00D0\u00B5\u00D0\u00B9\u00D0\u00BF\u00D0\u00BE\u00D1\u0080\u00D0\u00BD\u00D0\u00BE\u00D0\u00BC\u00D0\u00BD\u00D0\u00BE\u00D0\u00B3\u00D0\u00BE\u00D0\u00B4\u00D0\u00B5\u00D1\u0082\u00D0\u00B5\u00D0\u00B9\u00D1\u0081\u00D0\u00B2\u00D0\u00BE\u00D0\u00B8\u00D1\u0085\u00D0\u00BF\u00D1\u0080\u00D0\u00B0\u00D0\u00B2\u00D0\u00B0\u00D1\u0082\u00D0\u00B0\u00D0\u00BA\u00D0\u00BE\u00D0\u00B9\u00D0\u00BC\u00D0\u00B5\u00D1\u0081\u00D1\u0082\u00D0\u00BE\u00D0\u00B8\u00D0\u00BC\u00D0\u00B5\u00D0\u00B5\u00D1\u0082\u00D0\u00B6\u00D0\u00B8\u00D0\u00B7\u00D0\u00BD\u00D1\u008C\u00D0\u00BE\u00D0\u00B4\u00D0\u00BD\u00D0\u00BE\u00D0\u00B9\u00D0\u00BB\u00D1\u0083\u00D1\u0087\u00D1\u0088\u00D0\u00B5\u00D0\u00BF\u00D0\u00B5\u00D1\u0080\u00D0\u00B5\u00D0\u00B4\u00D1\u0087\u00D0\u00B0\u00D1\u0081\u00D1\u0082\u00D0\u00B8\u00D1\u0087\u00D0\u00B0\u00D1\u0081\u00D1\u0082\u00D1\u008C\u00D1\u0080\u00D0\u00B0\u00D0\u00B1\u00D0\u00BE\u00D1\u0082\u00D0\u00BD\u00D0\u00BE\u00D0\u00B2\u00D1\u008B\u00D1\u0085\u00D0\u00BF\u00D1\u0080\u00D0\u00B0\u00D0\u00B2\u00D0\u00BE\u00D1\u0081\u00D0\u00BE\u00D0\u00B1\u00D0\u00BE\u00D0\u00B9\u00D0\u00BF\u00D0\u00BE\u00D1\u0082\u00D0\u00BE\u00D0\u00BC\u00D0\u00BC\u00D0\u00B5\u00D0\u00BD\u00D0\u00B5\u00D0\u00B5\u00D1\u0087\u00D0\u00B8\u00D1\u0081\u00D0\u00BB\u00D0\u00B5\u00D0\u00BD\u00D0\u00BE\u00D0\u00B2\u00D1\u008B\u00D0\u00B5\u00D1\u0083\u00D1\u0081\u00D0\u00BB\u00D1\u0083\u00D0\u00B3\u00D0\u00BE\u00D0\u00BA\u00D0\u00BE\u00D0\u00BB\u00D0\u00BE\u00D0\u00BD\u00D0\u00B0\u00D0\u00B7\u00D0\u00B0\u00D0\u00B4\u00D1\u0082\u00D0\u00B0\u00D0\u00BA\u00D0\u00BE\u00D0\u00B5\u00D1\u0082\u00D0\u00BE\u00D0\u00B3\u00D0\u00B4\u00D0\u00B0\u00D0\u00BF\u00D0\u00BE\u00D1\u0087\u00D1\u0082\u00D0\u00B8\u00D0\u009F\u00D0\u00BE\u00D1\u0081\u00D0\u00BB\u00D0\u00B5\u00D1\u0082\u00D0\u00B0\u00D0\u00BA\u00D0\u00B8\u00D0\u00B5\u00D0\u00BD\u00D0\u00BE\u00D0\u00B2\u00D1\u008B\u00D0\u00B9\u00D1\u0081\u00D1\u0082\u00D0\u00BE\u00D0\u00B8\u00D1\u0082\u00D1\u0082\u00D0\u00B0\u00D0\u00BA\u00D0\u00B8\u00D1\u0085\u00D1\u0081\u00D1\u0080\u00D0\u00B0\u00D0\u00B7\u00D1\u0083\u00D0\u00A1\u00D0\u00B0\u00D0\u00BD\u00D0\u00BA\u00D1\u0082\u00D1\u0084\u00D0\u00BE\u00D1\u0080\u00D1\u0083\u00D0\u00BC\u00D0\u009A\u00D0\u00BE\u00D0\u00B3\u00D0\u00B4\u00D0\u00B0\u00D0\u00BA\u00D0\u00BD\u00D0\u00B8\u00D0\u00B3\u00D0\u00B8\u00D1\u0081\u00D0\u00BB\u00D0\u00BE\u00D0\u00B2\u00D0\u00B0\u00D0\u00BD\u00D0\u00B0\u00D1\u0088\u00D0\u00B5\u00D0\u00B9\u00D0\u00BD\u00D0\u00B0\u00D0\u00B9\u00D1\u0082\u00D0\u00B8\u00D1\u0081\u00D0\u00B2\u00D0\u00BE\u00D0\u00B8\u00D0\u00BC\u00D1\u0081\u00D0\u00B2\u00D1\u008F\u00D0\u00B7\u00D1\u008C\u00D0\u00BB\u00D1\u008E\u00D0\u00B1\u00D0\u00BE\u00D0\u00B9\u00D1\u0087\u00D0\u00B0\u00D1\u0081\u00D1\u0082\u00D0\u00BE\u00D1\u0081\u00D1\u0080\u00D0\u00B5\u00D0\u00B4\u00D0\u00B8\u00D0\u009A\u00D1\u0080\u00D0\u00BE\u00D0\u00BC\u00D0\u00B5\u00D0\u00A4\u00D0\u00BE\u00D1\u0080\u00D1\u0083\u00D0\u00BC\u00D1\u0080\u00D1\u008B\u00D0\u00BD\u00D0\u00BA\u00D0\u00B5\u00D1\u0081\u00D1\u0082\u00D0\u00B0\u00D0\u00BB\u00D0\u00B8\u00D0\u00BF\u00D0\u00BE\u00D0\u00B8\u00D1\u0081\u00D0\u00BA\u00D1\u0082\u00D1\u008B\u00D1\u0081\u00D1\u008F\u00D1\u0087\u00D0\u00BC\u00D0\u00B5\u00D1\u0081\u00D1\u008F\u00D1\u0086\u00D1\u0086\u00D0\u00B5\u00D0\u00BD\u00D1\u0082\u00D1\u0080\u00D1\u0082\u00D1\u0080\u00D1\u0083\u00D0\u00B4\u00D0\u00B0\u00D1\u0081\u00D0\u00B0\u00D0\u00BC\u00D1\u008B\u00D1\u0085\u00D1\u0080\u00D1\u008B\u00D0\u00BD\u00D0\u00BA\u00D0\u00B0\u00D0\u009D\u00D0\u00BE\u00D0\u00B2\u00D1\u008B\u00D0\u00B9\u00D1\u0087\u00D0\u00B0\u00D1\u0081\u00D0\u00BE\u00D0\u00B2\u00D0\u00BC\u00D0\u00B5\u00D1\u0081\u00D1\u0082\u00D0\u00B0\u00D1\u0084\u00D0\u00B8\u00D0\u00BB\u00D1\u008C\u00D0\u00BC\u00D0\u00BC\u00D0\u00B0\u00D1\u0080\u00D1\u0082\u00D0\u00B0\u00D1\u0081\u00D1\u0082\u00D1\u0080\u00D0\u00B0\u00D0\u00BD\u00D0\u00BC\u00D0\u00B5\u00D1\u0081\u00D1\u0082\u00D0\u00B5\u00D1\u0082\u00D0\u00B5\u00D0\u00BA\u00D1\u0081\u00D1\u0082\u00D0\u00BD\u00D0\u00B0\u00D1\u0088\u00D0\u00B8\u00D1\u0085\u00D0\u00BC\u00D0\u00B8\u00D0\u00BD\u00D1\u0083\u00D1\u0082\u00D0\u00B8\u00D0\u00BC\u00D0\u00B5\u00D0\u00BD\u00D0\u00B8\u00D0\u00B8\u00D0\u00BC\u00D0\u00B5\u00D1\u008E\u00D1\u0082\u00D0\u00BD\u00D0\u00BE\u00D0\u00BC\u00D0\u00B5\u00D1\u0080\u00D0\u00B3\u00D0\u00BE\u00D1\u0080\u00D0\u00BE\u00D0\u00B4\u00D1\u0081\u00D0\u00B0\u00D0\u00BC\u00D0\u00BE\u00D0\u00BC\u00D1\u008D\u00D1\u0082\u00D0\u00BE\u00D0\u00BC\u00D1\u0083\u00D0\u00BA\u00D0\u00BE\u00D0\u00BD\u00D1\u0086\u00D0\u00B5\u00D1\u0081\u00D0\u00B2\u00D0\u00BE\u00D0\u00B5\u00D0\u00BC\u00D0\u00BA\u00D0\u00B0\u00D0\u00BA\u00D0\u00BE\u00D0\u00B9\u00D0\u0090\u00D1\u0080\u00D1\u0085\u00D0\u00B8\u00D0\u00B2\u00D9\u0085\u00D9\u0086\u00D8\u00AA\u00D8\u00AF\u00D9\u0089\u00D8\u00A5\u00D8\u00B1\u00D8\u00B3\u00D8\u00A7\u00D9\u0084\u00D8\u00B1\u00D8\u00B3\u00D8\u00A7\u00D9\u0084\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D8\u00A7\u00D9\u0085\u00D9\u0083\u00D8\u00AA\u00D8\u00A8\u00D9\u0087\u00D8\u00A7\u00D8\u00A8\u00D8\u00B1\u00D8\u00A7\u00D9\u0085\u00D8\u00AC\u00D8\u00A7\u00D9\u0084\u00D9\u008A\u00D9\u0088\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D8\u00B5\u00D9\u0088\u00D8\u00B1\u00D8\u00AC\u00D8\u00AF\u00D9\u008A\u00D8\u00AF\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D8\u00B6\u00D9\u0088\u00D8\u00A5\u00D8\u00B6\u00D8\u00A7\u00D9\u0081\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D9\u0082\u00D8\u00B3\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D8\u00A7\u00D8\u00A8\u00D8\u00AA\u00D8\u00AD\u00D9\u0085\u00D9\u008A\u00D9\u0084\u00D9\u0085\u00D9\u0084\u00D9\u0081\u00D8\u00A7\u00D8\u00AA\u00D9\u0085\u00D9\u0084\u00D8\u00AA\u00D9\u0082\u00D9\u0089\u00D8\u00AA\u00D8\u00B9\u00D8\u00AF\u00D9\u008A\u00D9\u0084\u00D8\u00A7\u00D9\u0084\u00D8\u00B4\u00D8\u00B9\u00D8\u00B1\u00D8\u00A3\u00D8\u00AE\u00D8\u00A8\u00D8\u00A7\u00D8\u00B1\u00D8\u00AA\u00D8\u00B7\u00D9\u0088\u00D9\u008A\u00D8\u00B1\u00D8\u00B9\u00D9\u0084\u00D9\u008A\u00D9\u0083\u00D9\u0085\u00D8\u00A5\u00D8\u00B1\u00D9\u0081\u00D8\u00A7\u00D9\u0082\u00D8\u00B7\u00D9\u0084\u00D8\u00A8\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D9\u0084\u00D8\u00BA\u00D8\u00A9\u00D8\u00AA\u00D8\u00B1\u00D8\u00AA\u00D9\u008A\u00D8\u00A8\u00D8\u00A7\u00D9\u0084\u00D9\u0086\u00D8\u00A7\u00D8\u00B3\u00D8\u00A7\u00D9\u0084\u00D8\u00B4\u00D9\u008A\u00D8\u00AE\u00D9\u0085\u00D9\u0086\u00D8\u00AA\u00D8\u00AF\u00D9\u008A\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D8\u00B1\u00D8\u00A8\u00D8\u00A7\u00D9\u0084\u00D9\u0082\u00D8\u00B5\u00D8\u00B5\u00D8\u00A7\u00D9\u0081\u00D9\u0084\u00D8\u00A7\u00D9\u0085\u00D8\u00B9\u00D9\u0084\u00D9\u008A\u00D9\u0087\u00D8\u00A7\u00D8\u00AA\u00D8\u00AD\u00D8\u00AF\u00D9\u008A\u00D8\u00AB\u00D8\u00A7\u00D9\u0084\u00D9\u0084\u00D9\u0087\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D9\u0085\u00D9\u0084\u00D9\u0085\u00D9\u0083\u00D8\u00AA\u00D8\u00A8\u00D8\u00A9\u00D9\u008A\u00D9\u0085\u00D9\u0083\u00D9\u0086\u00D9\u0083\u00D8\u00A7\u00D9\u0084\u00D8\u00B7\u00D9\u0081\u00D9\u0084\u00D9\u0081\u00D9\u008A\u00D8\u00AF\u00D9\u008A\u00D9\u0088\u00D8\u00A5\u00D8\u00AF\u00D8\u00A7\u00D8\u00B1\u00D8\u00A9\u00D8\u00AA\u00D8\u00A7\u00D8\u00B1\u00D9\u008A\u00D8\u00AE\u00D8\u00A7\u00D9\u0084\u00D8\u00B5\u00D8\u00AD\u00D8\u00A9\u00D8\u00AA\u00D8\u00B3\u00D8\u00AC\u00D9\u008A\u00D9\u0084\u00D8\u00A7\u00D9\u0084\u00D9\u0088\u00D9\u0082\u00D8\u00AA\u00D8\u00B9\u00D9\u0086\u00D8\u00AF\u00D9\u0085\u00D8\u00A7\u00D9\u0085\u00D8\u00AF\u00D9\u008A\u00D9\u0086\u00D8\u00A9\u00D8\u00AA\u00D8\u00B5\u00D9\u0085\u00D9\u008A\u00D9\u0085\u00D8\u00A3\u00D8\u00B1\u00D8\u00B4\u00D9\u008A\u00D9\u0081\u00D8\u00A7\u00D9\u0084\u00D8\u00B0\u00D9\u008A\u00D9\u0086\u00D8\u00B9\u00D8\u00B1\u00D8\u00A8\u00D9\u008A\u00D8\u00A9\u00D8\u00A8\u00D9\u0088\u00D8\u00A7\u00D8\u00A8\u00D8\u00A9\u00D8\u00A3\u00D9\u0084\u00D8\u00B9\u00D8\u00A7\u00D8\u00A8\u00D8\u00A7\u00D9\u0084\u00D8\u00B3\u00D9\u0081\u00D8\u00B1\u00D9\u0085\u00D8\u00B4\u00D8\u00A7\u00D9\u0083\u00D9\u0084\u00D8\u00AA\u00D8\u00B9\u00D8\u00A7\u00D9\u0084\u00D9\u0089\u00D8\u00A7\u00D9\u0084\u00D8\u00A3\u00D9\u0088\u00D9\u0084\u00D8\u00A7\u00D9\u0084\u00D8\u00B3\u00D9\u0086\u00D8\u00A9\u00D8\u00AC\u00D8\u00A7\u00D9\u0085\u00D8\u00B9\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00B5\u00D8\u00AD\u00D9\u0081\u00D8\u00A7\u00D9\u0084\u00D8\u00AF\u00D9\u008A\u00D9\u0086\u00D9\u0083\u00D9\u0084\u00D9\u0085\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D8\u00AE\u00D8\u00A7\u00D8\u00B5\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D9\u0084\u00D9\u0081\u00D8\u00A3\u00D8\u00B9\u00D8\u00B6\u00D8\u00A7\u00D8\u00A1\u00D9\u0083\u00D8\u00AA\u00D8\u00A7\u00D8\u00A8\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00AE\u00D9\u008A\u00D8\u00B1\u00D8\u00B1\u00D8\u00B3\u00D8\u00A7\u00D8\u00A6\u00D9\u0084\u00D8\u00A7\u00D9\u0084\u00D9\u0082\u00D9\u0084\u00D8\u00A8\u00D8\u00A7\u00D9\u0084\u00D8\u00A3\u00D8\u00AF\u00D8\u00A8\u00D9\u0085\u00D9\u0082\u00D8\u00A7\u00D8\u00B7\u00D8\u00B9\u00D9\u0085\u00D8\u00B1\u00D8\u00A7\u00D8\u00B3\u00D9\u0084\u00D9\u0085\u00D9\u0086\u00D8\u00B7\u00D9\u0082\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D9\u0083\u00D8\u00AA\u00D8\u00A8\u00D8\u00A7\u00D9\u0084\u00D8\u00B1\u00D8\u00AC\u00D9\u0084\u00D8\u00A7\u00D8\u00B4\u00D8\u00AA\u00D8\u00B1\u00D9\u0083\u00D8\u00A7\u00D9\u0084\u00D9\u0082\u00D8\u00AF\u00D9\u0085\u00D9\u008A\u00D8\u00B9\u00D8\u00B7\u00D9\u008A\u00D9\u0083sByTagName(.jpg\" alt=\"1px solid #.gif\" alt=\"transparentinformationapplication\" onclick=\"establishedadvertising.png\" alt=\"environmentperformanceappropriate&amp;mdash;immediately</strong></rather thantemperaturedevelopmentcompetitionplaceholdervisibility:copyright\">0\" height=\"even thoughreplacementdestinationCorporation<ul class=\"AssociationindividualsperspectivesetTimeout(url(http://mathematicsmargin-top:eventually description) no-repeatcollections.JPG|thumb|participate/head><bodyfloat:left;<li class=\"hundreds of\n\nHowever, compositionclear:both;cooperationwithin the label for=\"border-top:New Zealandrecommendedphotographyinteresting&lt;sup&gt;controversyNetherlandsalternativemaxlength=\"switzerlandDevelopmentessentially\n\nAlthough </textarea>thunderbirdrepresented&amp;ndash;speculationcommunitieslegislationelectronics\n\t<div id=\"illustratedengineeringterritoriesauthoritiesdistributed6\" height=\"sans-serif;capable of disappearedinteractivelooking forit would beAfghanistanwas createdMath.floor(surroundingcan also beobservationmaintenanceencountered<h2 class=\"more recentit has beeninvasion of).getTime()fundamentalDespite the\"><div id=\"inspirationexaminationpreparationexplanation<input id=\"</a></span>versions ofinstrumentsbefore the  = 'http://Descriptionrelatively .substring(each of theexperimentsinfluentialintegrationmany peopledue to the combinationdo not haveMiddle East<noscript><copyright\" perhaps theinstitutionin Decemberarrangementmost famouspersonalitycreation oflimitationsexclusivelysovereignty-content\">\n<td class=\"undergroundparallel todoctrine ofoccupied byterminologyRenaissancea number ofsupport forexplorationrecognitionpredecessor<img src=\"/<h1 class=\"publicationmay also bespecialized</fieldset>progressivemillions ofstates thatenforcementaround the one another.parentNodeagricultureAlternativeresearcherstowards theMost of themany other (especially<td width=\";width:100%independent<h3 class=\" onchange=\").addClass(interactionOne of the daughter ofaccessoriesbranches of\r\n<div id=\"the largestdeclarationregulationsInformationtranslationdocumentaryin order to\">\n<head>\n<\" height=\"1across the orientation);</script>implementedcan be seenthere was ademonstratecontainer\">connectionsthe Britishwas written!important;px; margin-followed byability to complicatedduring the immigrationalso called<h4 class=\"distinctionreplaced bygovernmentslocation ofin Novemberwhether the</p>\n</div>acquisitioncalled the persecutiondesignation{font-size:appeared ininvestigateexperiencedmost likelywidely useddiscussionspresence of (document.extensivelyIt has beenit does notcontrary toinhabitantsimprovementscholarshipconsumptioninstructionfor exampleone or morepx; paddingthe currenta series ofare usuallyrole in thepreviously derivativesevidence ofexperiencescolorschemestated thatcertificate</a></div>\n selected=\"high schoolresponse tocomfortableadoption ofthree yearsthe countryin Februaryso that thepeople who provided by<param nameaffected byin terms ofappointmentISO-8859-1\"was born inhistorical regarded asmeasurementis based on and other : function(significantcelebrationtransmitted/js/jquery.is known astheoretical tabindex=\"it could be<noscript>\nhaving been\r\n<head>\r\n< &quot;The compilationhe had beenproduced byphilosopherconstructedintended toamong othercompared toto say thatEngineeringa differentreferred todifferencesbelief thatphotographsidentifyingHistory of Republic ofnecessarilyprobabilitytechnicallyleaving thespectacularfraction ofelectricityhead of therestaurantspartnershipemphasis onmost recentshare with saying thatfilled withdesigned toit is often\"></iframe>as follows:merged withthrough thecommercial pointed outopportunityview of therequirementdivision ofprogramminghe receivedsetInterval\"></span></in New Yorkadditional compression\n\n<div id=\"incorporate;</script><attachEventbecame the \" target=\"_carried outSome of thescience andthe time ofContainer\">maintainingChristopherMuch of thewritings of\" height=\"2size of theversion of mixture of between theExamples ofeducationalcompetitive onsubmit=\"director ofdistinctive/DTD XHTML relating totendency toprovince ofwhich woulddespite thescientific legislature.innerHTML allegationsAgriculturewas used inapproach tointelligentyears later,sans-serifdeterminingPerformanceappearances, which is foundationsabbreviatedhigher thans from the individual composed ofsupposed toclaims thatattributionfont-size:1elements ofHistorical his brotherat the timeanniversarygoverned byrelated to ultimately innovationsit is stillcan only bedefinitionstoGMTStringA number ofimg class=\"Eventually,was changedoccurred inneighboringdistinguishwhen he wasintroducingterrestrialMany of theargues thatan Americanconquest ofwidespread were killedscreen and In order toexpected todescendantsare locatedlegislativegenerations backgroundmost peopleyears afterthere is nothe highestfrequently they do notargued thatshowed thatpredominanttheologicalby the timeconsideringshort-lived</span></a>can be usedvery littleone of the had alreadyinterpretedcommunicatefeatures ofgovernment,</noscript>entered the\" height=\"3Independentpopulationslarge-scale. Although used in thedestructionpossibilitystarting intwo or moreexpressionssubordinatelarger thanhistory and</option>\r\nContinentaleliminatingwill not bepractice ofin front ofsite of theensure thatto create amississippipotentiallyoutstandingbetter thanwhat is nowsituated inmeta name=\"TraditionalsuggestionsTranslationthe form ofatmosphericideologicalenterprisescalculatingeast of theremnants ofpluginspage/index.php?remained intransformedHe was alsowas alreadystatisticalin favor ofMinistry ofmovement offormulationis required<link rel=\"This is the <a href=\"/popularizedinvolved inare used toand severalmade by theseems to belikely thatPalestiniannamed afterit had beenmost commonto refer tobut this isconsecutivetemporarilyIn general,conventionstakes placesubdivisionterritorialoperationalpermanentlywas largelyoutbreak ofin the pastfollowing a xmlns:og=\"><a class=\"class=\"textConversion may be usedmanufactureafter beingclearfix\">\nquestion ofwas electedto become abecause of some peopleinspired bysuccessful a time whenmore commonamongst thean officialwidth:100%;technology,was adoptedto keep thesettlementslive birthsindex.html\"Connecticutassigned to&amp;times;account foralign=rightthe companyalways beenreturned toinvolvementBecause thethis period\" name=\"q\" confined toa result ofvalue=\"\" />is actuallyEnvironment\r\n</head>\r\nConversely,>\n<div id=\"0\" width=\"1is probablyhave becomecontrollingthe problemcitizens ofpoliticiansreached theas early as:none; over<table cellvalidity ofdirectly toonmousedownwhere it iswhen it wasmembers of relation toaccommodatealong with In the latethe Englishdelicious\">this is notthe presentif they areand finallya matter of\r\n\t</div>\r\n\r\n</script>faster thanmajority ofafter whichcomparativeto maintainimprove theawarded theer\" class=\"frameborderrestorationin the sameanalysis oftheir firstDuring the continentalsequence offunction(){font-size: work on the</script>\n<begins withjavascript:constituentwas foundedequilibriumassume thatis given byneeds to becoordinatesthe variousare part ofonly in thesections ofis a commontheories ofdiscoveriesassociationedge of thestrength ofposition inpresent-dayuniversallyto form thebut insteadcorporationattached tois commonlyreasons for &quot;the can be madewas able towhich meansbut did notonMouseOveras possibleoperated bycoming fromthe primaryaddition offor severaltransferreda period ofare able tohowever, itshould havemuch larger\n\t</script>adopted theproperty ofdirected byeffectivelywas broughtchildren ofProgramminglonger thanmanuscriptswar againstby means ofand most ofsimilar to proprietaryoriginatingprestigiousgrammaticalexperience.to make theIt was alsois found incompetitorsin the U.S.replace thebrought thecalculationfall of thethe generalpracticallyin honor ofreleased inresidentialand some ofking of thereaction to1st Earl ofculture andprincipally</title>\n  they can beback to thesome of hisexposure toare similarform of theaddFavoritecitizenshippart in thepeople within practiceto continue&amp;minus;approved by the first allowed theand for thefunctioningplaying thesolution toheight=\"0\" in his bookmore than afollows thecreated thepresence in&nbsp;</td>nationalistthe idea ofa characterwere forced class=\"btndays of thefeatured inshowing theinterest inin place ofturn of thethe head ofLord of thepoliticallyhas its ownEducationalapproval ofsome of theeach other,behavior ofand becauseand anotherappeared onrecorded inblack&quot;may includethe world'scan lead torefers to aborder=\"0\" government winning theresulted in while the Washington,the subjectcity in the></div>\r\n\t\treflect theto completebecame moreradioactiverejected bywithout anyhis father,which couldcopy of theto indicatea politicalaccounts ofconstitutesworked wither</a></li>of his lifeaccompaniedclientWidthprevent theLegislativedifferentlytogether inhas severalfor anothertext of thefounded thee with the is used forchanged theusually theplace wherewhereas the> <a href=\"\"><a href=\"themselves,although hethat can betraditionalrole of theas a resultremoveChilddesigned bywest of theSome peopleproduction,side of thenewslettersused by thedown to theaccepted bylive in theattempts tooutside thefrequenciesHowever, inprogrammersat least inapproximatealthough itwas part ofand variousGovernor ofthe articleturned into><a href=\"/the economyis the mostmost widelywould laterand perhapsrise to theoccurs whenunder whichconditions.the westerntheory thatis producedthe city ofin which heseen in thethe centralbuilding ofmany of hisarea of theis the onlymost of themany of thethe WesternThere is noextended toStatisticalcolspan=2 |short storypossible totopologicalcritical ofreported toa Christiandecision tois equal toproblems ofThis can bemerchandisefor most ofno evidenceeditions ofelements in&quot;. Thecom/images/which makesthe processremains theliterature,is a memberthe popularthe ancientproblems intime of thedefeated bybody of thea few yearsmuch of thethe work ofCalifornia,served as agovernment.concepts ofmovement in\t\t<div id=\"it\" value=\"language ofas they areproduced inis that theexplain thediv></div>\nHowever thelead to the\t<a href=\"/was grantedpeople havecontinuallywas seen asand relatedthe role ofproposed byof the besteach other.Constantinepeople fromdialects ofto revisionwas renameda source ofthe initiallaunched inprovide theto the westwhere thereand similarbetween twois also theEnglish andconditions,that it wasentitled tothemselves.quantity ofransparencythe same asto join thecountry andthis is theThis led toa statementcontrast tolastIndexOfthrough hisis designedthe term isis providedprotect theng</a></li>The currentthe site ofsubstantialexperience,in the Westthey shouldsloven\u00C4\u008Dinacomentariosuniversidadcondicionesactividadesexperienciatecnolog\u00C3\u00ADaproducci\u00C3\u00B3npuntuaci\u00C3\u00B3naplicaci\u00C3\u00B3ncontrase\u00C3\u00B1acategor\u00C3\u00ADasregistrarseprofesionaltratamientoreg\u00C3\u00ADstratesecretar\u00C3\u00ADaprincipalesprotecci\u00C3\u00B3nimportantesimportanciaposibilidadinteresantecrecimientonecesidadessuscribirseasociaci\u00C3\u00B3ndisponiblesevaluaci\u00C3\u00B3nestudiantesresponsableresoluci\u00C3\u00B3nguadalajararegistradosoportunidadcomercialesfotograf\u00C3\u00ADaautoridadesingenier\u00C3\u00ADatelevisi\u00C3\u00B3ncompetenciaoperacionesestablecidosimplementeactualmentenavegaci\u00C3\u00B3nconformidadline-height:font-family:\" : \"http://applicationslink\" href=\"specifically//<![CDATA[\nOrganizationdistribution0px; height:relationshipdevice-width<div class=\"<label for=\"registration</noscript>\n/index.html\"window.open( !important;application/independence//www.googleorganizationautocompleterequirementsconservative<form name=\"intellectualmargin-left:18th centuryan importantinstitutionsabbreviation<img class=\"organisationcivilization19th centuryarchitectureincorporated20th century-container\">most notably/></a></div>notification'undefined')Furthermore,believe thatinnerHTML = prior to thedramaticallyreferring tonegotiationsheadquartersSouth AfricaunsuccessfulPennsylvaniaAs a result,<html lang=\"&lt;/sup&gt;dealing withphiladelphiahistorically);</script>\npadding-top:experimentalgetAttributeinstructionstechnologiespart of the =function(){subscriptionl.dtd\">\r\n<htgeographicalConstitution', function(supported byagriculturalconstructionpublicationsfont-size: 1a variety of<div style=\"Encyclopediaiframe src=\"demonstratedaccomplisheduniversitiesDemographics);</script><dedicated toknowledge ofsatisfactionparticularly</div></div>English (US)appendChild(transmissions. However, intelligence\" tabindex=\"float:right;Commonwealthranging fromin which theat least onereproductionencyclopedia;font-size:1jurisdictionat that time\"><a class=\"In addition,description+conversationcontact withis generallyr\" content=\"representing&lt;math&gt;presentationoccasionally<img width=\"navigation\">compensationchampionshipmedia=\"all\" violation ofreference toreturn true;Strict//EN\" transactionsinterventionverificationInformation difficultiesChampionshipcapabilities<![endif]-->}\n</script>\nChristianityfor example,Professionalrestrictionssuggest thatwas released(such as theremoveClass(unemploymentthe Americanstructure of/index.html published inspan class=\"\"><a href=\"/introductionbelonging toclaimed thatconsequences<meta name=\"Guide to theoverwhelmingagainst the concentrated,\n.nontouch observations</a>\n</div>\nf (document.border: 1px {font-size:1treatment of0\" height=\"1modificationIndependencedivided intogreater thanachievementsestablishingJavaScript\" neverthelesssignificanceBroadcasting>&nbsp;</td>container\">\nsuch as the influence ofa particularsrc='http://navigation\" half of the substantial &nbsp;</div>advantage ofdiscovery offundamental metropolitanthe opposite\" xml:lang=\"deliberatelyalign=centerevolution ofpreservationimprovementsbeginning inJesus ChristPublicationsdisagreementtext-align:r, function()similaritiesbody></html>is currentlyalphabeticalis sometimestype=\"image/many of the flow:hidden;available indescribe theexistence ofall over thethe Internet\t<ul class=\"installationneighborhoodarmed forcesreducing thecontinues toNonetheless,temperatures\n\t\t<a href=\"close to theexamples of is about the(see below).\" id=\"searchprofessionalis availablethe official\t\t</script>\n\n\t\t<div id=\"accelerationthrough the Hall of Famedescriptionstranslationsinterference type='text/recent yearsin the worldvery popular{background:traditional some of the connected toexploitationemergence ofconstitutionA History ofsignificant manufacturedexpectations><noscript><can be foundbecause the has not beenneighbouringwithout the added to the\t<li class=\"instrumentalSoviet Unionacknowledgedwhich can bename for theattention toattempts to developmentsIn fact, the<li class=\"aimplicationssuitable formuch of the colonizationpresidentialcancelBubble Informationmost of the is describedrest of the more or lessin SeptemberIntelligencesrc=\"http://px; height: available tomanufacturerhuman rightslink href=\"/availabilityproportionaloutside the astronomicalhuman beingsname of the are found inare based onsmaller thana person whoexpansion ofarguing thatnow known asIn the earlyintermediatederived fromScandinavian</a></div>\r\nconsider thean estimatedthe National<div id=\"pagresulting incommissionedanalogous toare required/ul>\n</div>\nwas based onand became a&nbsp;&nbsp;t\" value=\"\" was capturedno more thanrespectivelycontinue to >\r\n<head>\r\n<were createdmore generalinformation used for theindependent the Imperialcomponent ofto the northinclude the Constructionside of the would not befor instanceinvention ofmore complexcollectivelybackground: text-align: its originalinto accountthis processan extensivehowever, thethey are notrejected thecriticism ofduring whichprobably thethis article(function(){It should bean agreementaccidentallydiffers fromArchitecturebetter knownarrangementsinfluence onattended theidentical tosouth of thepass throughxml\" title=\"weight:bold;creating thedisplay:nonereplaced the<img src=\"/ihttps://www.World War IItestimonialsfound in therequired to and that thebetween the was designedconsists of considerablypublished bythe languageConservationconsisted ofrefer to theback to the css\" media=\"People from available onproved to besuggestions\"was known asvarieties oflikely to becomprised ofsupport the hands of thecoupled withconnect and border:none;performancesbefore beinglater becamecalculationsoften calledresidents ofmeaning that><li class=\"evidence forexplanationsenvironments\"></a></div>which allowsIntroductiondeveloped bya wide rangeon behalf ofvalign=\"top\"principle ofat the time,</noscript>\rsaid to havein the firstwhile othershypotheticalphilosopherspower of thecontained inperformed byinability towere writtenspan style=\"input name=\"the questionintended forrejection ofimplies thatinvented thethe standardwas probablylink betweenprofessor ofinteractionschanging theIndian Ocean class=\"lastworking with'http://www.years beforeThis was therecreationalentering themeasurementsan extremelyvalue of thestart of the\n</script>\n\nan effort toincrease theto the southspacing=\"0\">sufficientlythe Europeanconverted toclearTimeoutdid not haveconsequentlyfor the nextextension ofeconomic andalthough theare producedand with theinsufficientgiven by thestating thatexpenditures</span></a>\nthought thaton the basiscellpadding=image of thereturning toinformation,separated byassassinateds\" content=\"authority ofnorthwestern</div>\n<div \"></div>\r\n  consultationcommunity ofthe nationalit should beparticipants align=\"leftthe greatestselection ofsupernaturaldependent onis mentionedallowing thewas inventedaccompanyinghis personalavailable atstudy of theon the otherexecution ofHuman Rightsterms of theassociationsresearch andsucceeded bydefeated theand from thebut they arecommander ofstate of theyears of agethe study of<ul class=\"splace in thewhere he was<li class=\"fthere are nowhich becamehe publishedexpressed into which thecommissionerfont-weight:territory ofextensions\">Roman Empireequal to theIn contrast,however, andis typicallyand his wife(also called><ul class=\"effectively evolved intoseem to havewhich is thethere was noan excellentall of thesedescribed byIn practice,broadcastingcharged withreflected insubjected tomilitary andto the pointeconomicallysetTargetingare actuallyvictory over();</script>continuouslyrequired forevolutionaryan effectivenorth of the, which was front of theor otherwisesome form ofhad not beengenerated byinformation.permitted toincludes thedevelopment,entered intothe previous";
			}
		}

		private class DataHolder2
		{
			internal static string GetData()
			{
				return "consistentlyare known asthe field ofthis type ofgiven to thethe title ofcontains theinstances ofin the northdue to theirare designedcorporationswas that theone of thesemore popularsucceeded insupport fromin differentdominated bydesigned forownership ofand possiblystandardizedresponseTextwas intendedreceived theassumed thatareas of theprimarily inthe basis ofin the senseaccounts fordestroyed byat least twowas declaredcould not beSecretary ofappear to bemargin-top:1/^\\s+|\\s+$/ge){throw e};the start oftwo separatelanguage andwho had beenoperation ofdeath of thereal numbers\t<link rel=\"provided thethe story ofcompetitionsenglish (UK)english (US)\u00D0\u009C\u00D0\u00BE\u00D0\u00BD\u00D0\u00B3\u00D0\u00BE\u00D0\u00BB\u00D0\u00A1\u00D1\u0080\u00D0\u00BF\u00D1\u0081\u00D0\u00BA\u00D0\u00B8\u00D1\u0081\u00D1\u0080\u00D0\u00BF\u00D1\u0081\u00D0\u00BA\u00D0\u00B8\u00D1\u0081\u00D1\u0080\u00D0\u00BF\u00D1\u0081\u00D0\u00BA\u00D0\u00BE\u00D9\u0084\u00D8\u00B9\u00D8\u00B1\u00D8\u00A8\u00D9\u008A\u00D8\u00A9\u00E6\u00AD\u00A3\u00E9\u00AB\u0094\u00E4\u00B8\u00AD\u00E6\u0096\u0087\u00E7\u00AE\u0080\u00E4\u00BD\u0093\u00E4\u00B8\u00AD\u00E6\u0096\u0087\u00E7\u00B9\u0081\u00E4\u00BD\u0093\u00E4\u00B8\u00AD\u00E6\u0096\u0087\u00E6\u009C\u0089\u00E9\u0099\u0090\u00E5\u0085\u00AC\u00E5\u008F\u00B8\u00E4\u00BA\u00BA\u00E6\u00B0\u0091\u00E6\u0094\u00BF\u00E5\u00BA\u009C\u00E9\u0098\u00BF\u00E9\u0087\u008C\u00E5\u00B7\u00B4\u00E5\u00B7\u00B4\u00E7\u00A4\u00BE\u00E4\u00BC\u009A\u00E4\u00B8\u00BB\u00E4\u00B9\u0089\u00E6\u0093\u008D\u00E4\u00BD\u009C\u00E7\u00B3\u00BB\u00E7\u00BB\u009F\u00E6\u0094\u00BF\u00E7\u00AD\u0096\u00E6\u00B3\u0095\u00E8\u00A7\u0084informaci\u00C3\u00B3nherramientaselectr\u00C3\u00B3nicodescripci\u00C3\u00B3nclasificadosconocimientopublicaci\u00C3\u00B3nrelacionadasinform\u00C3\u00A1ticarelacionadosdepartamentotrabajadoresdirectamenteayuntamientomercadoLibrecont\u00C3\u00A1ctenoshabitacionescumplimientorestaurantesdisposici\u00C3\u00B3nconsecuenciaelectr\u00C3\u00B3nicaaplicacionesdesconectadoinstalaci\u00C3\u00B3nrealizaci\u00C3\u00B3nutilizaci\u00C3\u00B3nenciclopediaenfermedadesinstrumentosexperienciasinstituci\u00C3\u00B3nparticularessubcategoria\u00D1\u0082\u00D0\u00BE\u00D0\u00BB\u00D1\u008C\u00D0\u00BA\u00D0\u00BE\u00D0\u00A0\u00D0\u00BE\u00D1\u0081\u00D1\u0081\u00D0\u00B8\u00D0\u00B8\u00D1\u0080\u00D0\u00B0\u00D0\u00B1\u00D0\u00BE\u00D1\u0082\u00D1\u008B\u00D0\u00B1\u00D0\u00BE\u00D0\u00BB\u00D1\u008C\u00D1\u0088\u00D0\u00B5\u00D0\u00BF\u00D1\u0080\u00D0\u00BE\u00D1\u0081\u00D1\u0082\u00D0\u00BE\u00D0\u00BC\u00D0\u00BE\u00D0\u00B6\u00D0\u00B5\u00D1\u0082\u00D0\u00B5\u00D0\u00B4\u00D1\u0080\u00D1\u0083\u00D0\u00B3\u00D0\u00B8\u00D1\u0085\u00D1\u0081\u00D0\u00BB\u00D1\u0083\u00D1\u0087\u00D0\u00B0\u00D0\u00B5\u00D1\u0081\u00D0\u00B5\u00D0\u00B9\u00D1\u0087\u00D0\u00B0\u00D1\u0081\u00D0\u00B2\u00D1\u0081\u00D0\u00B5\u00D0\u00B3\u00D0\u00B4\u00D0\u00B0\u00D0\u00A0\u00D0\u00BE\u00D1\u0081\u00D1\u0081\u00D0\u00B8\u00D1\u008F\u00D0\u009C\u00D0\u00BE\u00D1\u0081\u00D0\u00BA\u00D0\u00B2\u00D0\u00B5\u00D0\u00B4\u00D1\u0080\u00D1\u0083\u00D0\u00B3\u00D0\u00B8\u00D0\u00B5\u00D0\u00B3\u00D0\u00BE\u00D1\u0080\u00D0\u00BE\u00D0\u00B4\u00D0\u00B0\u00D0\u00B2\u00D0\u00BE\u00D0\u00BF\u00D1\u0080\u00D0\u00BE\u00D1\u0081\u00D0\u00B4\u00D0\u00B0\u00D0\u00BD\u00D0\u00BD\u00D1\u008B\u00D1\u0085\u00D0\u00B4\u00D0\u00BE\u00D0\u00BB\u00D0\u00B6\u00D0\u00BD\u00D1\u008B\u00D0\u00B8\u00D0\u00BC\u00D0\u00B5\u00D0\u00BD\u00D0\u00BD\u00D0\u00BE\u00D0\u009C\u00D0\u00BE\u00D1\u0081\u00D0\u00BA\u00D0\u00B2\u00D1\u008B\u00D1\u0080\u00D1\u0083\u00D0\u00B1\u00D0\u00BB\u00D0\u00B5\u00D0\u00B9\u00D0\u009C\u00D0\u00BE\u00D1\u0081\u00D0\u00BA\u00D0\u00B2\u00D0\u00B0\u00D1\u0081\u00D1\u0082\u00D1\u0080\u00D0\u00B0\u00D0\u00BD\u00D1\u008B\u00D0\u00BD\u00D0\u00B8\u00D1\u0087\u00D0\u00B5\u00D0\u00B3\u00D0\u00BE\u00D1\u0080\u00D0\u00B0\u00D0\u00B1\u00D0\u00BE\u00D1\u0082\u00D0\u00B5\u00D0\u00B4\u00D0\u00BE\u00D0\u00BB\u00D0\u00B6\u00D0\u00B5\u00D0\u00BD\u00D1\u0083\u00D1\u0081\u00D0\u00BB\u00D1\u0083\u00D0\u00B3\u00D0\u00B8\u00D1\u0082\u00D0\u00B5\u00D0\u00BF\u00D0\u00B5\u00D1\u0080\u00D1\u008C\u00D0\u009E\u00D0\u00B4\u00D0\u00BD\u00D0\u00B0\u00D0\u00BA\u00D0\u00BE\u00D0\u00BF\u00D0\u00BE\u00D1\u0082\u00D0\u00BE\u00D0\u00BC\u00D1\u0083\u00D1\u0080\u00D0\u00B0\u00D0\u00B1\u00D0\u00BE\u00D1\u0082\u00D1\u0083\u00D0\u00B0\u00D0\u00BF\u00D1\u0080\u00D0\u00B5\u00D0\u00BB\u00D1\u008F\u00D0\u00B2\u00D0\u00BE\u00D0\u00BE\u00D0\u00B1\u00D1\u0089\u00D0\u00B5\u00D0\u00BE\u00D0\u00B4\u00D0\u00BD\u00D0\u00BE\u00D0\u00B3\u00D0\u00BE\u00D1\u0081\u00D0\u00B2\u00D0\u00BE\u00D0\u00B5\u00D0\u00B3\u00D0\u00BE\u00D1\u0081\u00D1\u0082\u00D0\u00B0\u00D1\u0082\u00D1\u008C\u00D0\u00B8\u00D0\u00B4\u00D1\u0080\u00D1\u0083\u00D0\u00B3\u00D0\u00BE\u00D0\u00B9\u00D1\u0084\u00D0\u00BE\u00D1\u0080\u00D1\u0083\u00D0\u00BC\u00D0\u00B5\u00D1\u0085\u00D0\u00BE\u00D1\u0080\u00D0\u00BE\u00D1\u0088\u00D0\u00BE\u00D0\u00BF\u00D1\u0080\u00D0\u00BE\u00D1\u0082\u00D0\u00B8\u00D0\u00B2\u00D1\u0081\u00D1\u0081\u00D1\u008B\u00D0\u00BB\u00D0\u00BA\u00D0\u00B0\u00D0\u00BA\u00D0\u00B0\u00D0\u00B6\u00D0\u00B4\u00D1\u008B\u00D0\u00B9\u00D0\u00B2\u00D0\u00BB\u00D0\u00B0\u00D1\u0081\u00D1\u0082\u00D0\u00B8\u00D0\u00B3\u00D1\u0080\u00D1\u0083\u00D0\u00BF\u00D0\u00BF\u00D1\u008B\u00D0\u00B2\u00D0\u00BC\u00D0\u00B5\u00D1\u0081\u00D1\u0082\u00D0\u00B5\u00D1\u0080\u00D0\u00B0\u00D0\u00B1\u00D0\u00BE\u00D1\u0082\u00D0\u00B0\u00D1\u0081\u00D0\u00BA\u00D0\u00B0\u00D0\u00B7\u00D0\u00B0\u00D0\u00BB\u00D0\u00BF\u00D0\u00B5\u00D1\u0080\u00D0\u00B2\u00D1\u008B\u00D0\u00B9\u00D0\u00B4\u00D0\u00B5\u00D0\u00BB\u00D0\u00B0\u00D1\u0082\u00D1\u008C\u00D0\u00B4\u00D0\u00B5\u00D0\u00BD\u00D1\u008C\u00D0\u00B3\u00D0\u00B8\u00D0\u00BF\u00D0\u00B5\u00D1\u0080\u00D0\u00B8\u00D0\u00BE\u00D0\u00B4\u00D0\u00B1\u00D0\u00B8\u00D0\u00B7\u00D0\u00BD\u00D0\u00B5\u00D1\u0081\u00D0\u00BE\u00D1\u0081\u00D0\u00BD\u00D0\u00BE\u00D0\u00B2\u00D0\u00B5\u00D0\u00BC\u00D0\u00BE\u00D0\u00BC\u00D0\u00B5\u00D0\u00BD\u00D1\u0082\u00D0\u00BA\u00D1\u0083\u00D0\u00BF\u00D0\u00B8\u00D1\u0082\u00D1\u008C\u00D0\u00B4\u00D0\u00BE\u00D0\u00BB\u00D0\u00B6\u00D0\u00BD\u00D0\u00B0\u00D1\u0080\u00D0\u00B0\u00D0\u00BC\u00D0\u00BA\u00D0\u00B0\u00D1\u0085\u00D0\u00BD\u00D0\u00B0\u00D1\u0087\u00D0\u00B0\u00D0\u00BB\u00D0\u00BE\u00D0\u00A0\u00D0\u00B0\u00D0\u00B1\u00D0\u00BE\u00D1\u0082\u00D0\u00B0\u00D0\u00A2\u00D0\u00BE\u00D0\u00BB\u00D1\u008C\u00D0\u00BA\u00D0\u00BE\u00D1\u0081\u00D0\u00BE\u00D0\u00B2\u00D1\u0081\u00D0\u00B5\u00D0\u00BC\u00D0\u00B2\u00D1\u0082\u00D0\u00BE\u00D1\u0080\u00D0\u00BE\u00D0\u00B9\u00D0\u00BD\u00D0\u00B0\u00D1\u0087\u00D0\u00B0\u00D0\u00BB\u00D0\u00B0\u00D1\u0081\u00D0\u00BF\u00D0\u00B8\u00D1\u0081\u00D0\u00BE\u00D0\u00BA\u00D1\u0081\u00D0\u00BB\u00D1\u0083\u00D0\u00B6\u00D0\u00B1\u00D1\u008B\u00D1\u0081\u00D0\u00B8\u00D1\u0081\u00D1\u0082\u00D0\u00B5\u00D0\u00BC\u00D0\u00BF\u00D0\u00B5\u00D1\u0087\u00D0\u00B0\u00D1\u0082\u00D0\u00B8\u00D0\u00BD\u00D0\u00BE\u00D0\u00B2\u00D0\u00BE\u00D0\u00B3\u00D0\u00BE\u00D0\u00BF\u00D0\u00BE\u00D0\u00BC\u00D0\u00BE\u00D1\u0089\u00D0\u00B8\u00D1\u0081\u00D0\u00B0\u00D0\u00B9\u00D1\u0082\u00D0\u00BE\u00D0\u00B2\u00D0\u00BF\u00D0\u00BE\u00D1\u0087\u00D0\u00B5\u00D0\u00BC\u00D1\u0083\u00D0\u00BF\u00D0\u00BE\u00D0\u00BC\u00D0\u00BE\u00D1\u0089\u00D1\u008C\u00D0\u00B4\u00D0\u00BE\u00D0\u00BB\u00D0\u00B6\u00D0\u00BD\u00D0\u00BE\u00D1\u0081\u00D1\u0081\u00D1\u008B\u00D0\u00BB\u00D0\u00BA\u00D0\u00B8\u00D0\u00B1\u00D1\u008B\u00D1\u0081\u00D1\u0082\u00D1\u0080\u00D0\u00BE\u00D0\u00B4\u00D0\u00B0\u00D0\u00BD\u00D0\u00BD\u00D1\u008B\u00D0\u00B5\u00D0\u00BC\u00D0\u00BD\u00D0\u00BE\u00D0\u00B3\u00D0\u00B8\u00D0\u00B5\u00D0\u00BF\u00D1\u0080\u00D0\u00BE\u00D0\u00B5\u00D0\u00BA\u00D1\u0082\u00D0\u00A1\u00D0\u00B5\u00D0\u00B9\u00D1\u0087\u00D0\u00B0\u00D1\u0081\u00D0\u00BC\u00D0\u00BE\u00D0\u00B4\u00D0\u00B5\u00D0\u00BB\u00D0\u00B8\u00D1\u0082\u00D0\u00B0\u00D0\u00BA\u00D0\u00BE\u00D0\u00B3\u00D0\u00BE\u00D0\u00BE\u00D0\u00BD\u00D0\u00BB\u00D0\u00B0\u00D0\u00B9\u00D0\u00BD\u00D0\u00B3\u00D0\u00BE\u00D1\u0080\u00D0\u00BE\u00D0\u00B4\u00D0\u00B5\u00D0\u00B2\u00D0\u00B5\u00D1\u0080\u00D1\u0081\u00D0\u00B8\u00D1\u008F\u00D1\u0081\u00D1\u0082\u00D1\u0080\u00D0\u00B0\u00D0\u00BD\u00D0\u00B5\u00D1\u0084\u00D0\u00B8\u00D0\u00BB\u00D1\u008C\u00D0\u00BC\u00D1\u008B\u00D1\u0083\u00D1\u0080\u00D0\u00BE\u00D0\u00B2\u00D0\u00BD\u00D1\u008F\u00D1\u0080\u00D0\u00B0\u00D0\u00B7\u00D0\u00BD\u00D1\u008B\u00D1\u0085\u00D0\u00B8\u00D1\u0081\u00D0\u00BA\u00D0\u00B0\u00D1\u0082\u00D1\u008C\u00D0\u00BD\u00D0\u00B5\u00D0\u00B4\u00D0\u00B5\u00D0\u00BB\u00D1\u008E\u00D1\u008F\u00D0\u00BD\u00D0\u00B2\u00D0\u00B0\u00D1\u0080\u00D1\u008F\u00D0\u00BC\u00D0\u00B5\u00D0\u00BD\u00D1\u008C\u00D1\u0088\u00D0\u00B5\u00D0\u00BC\u00D0\u00BD\u00D0\u00BE\u00D0\u00B3\u00D0\u00B8\u00D1\u0085\u00D0\u00B4\u00D0\u00B0\u00D0\u00BD\u00D0\u00BD\u00D0\u00BE\u00D0\u00B9\u00D0\u00B7\u00D0\u00BD\u00D0\u00B0\u00D1\u0087\u00D0\u00B8\u00D1\u0082\u00D0\u00BD\u00D0\u00B5\u00D0\u00BB\u00D1\u008C\u00D0\u00B7\u00D1\u008F\u00D1\u0084\u00D0\u00BE\u00D1\u0080\u00D1\u0083\u00D0\u00BC\u00D0\u00B0\u00D0\u00A2\u00D0\u00B5\u00D0\u00BF\u00D0\u00B5\u00D1\u0080\u00D1\u008C\u00D0\u00BC\u00D0\u00B5\u00D1\u0081\u00D1\u008F\u00D1\u0086\u00D0\u00B0\u00D0\u00B7\u00D0\u00B0\u00D1\u0089\u00D0\u00B8\u00D1\u0082\u00D1\u008B\u00D0\u009B\u00D1\u0083\u00D1\u0087\u00D1\u0088\u00D0\u00B8\u00D0\u00B5\u00E0\u00A4\u00A8\u00E0\u00A4\u00B9\u00E0\u00A5\u0080\u00E0\u00A4\u0082\u00E0\u00A4\u0095\u00E0\u00A4\u00B0\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u0085\u00E0\u00A4\u00AA\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u0095\u00E0\u00A4\u00BF\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u0095\u00E0\u00A4\u00B0\u00E0\u00A5\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u0085\u00E0\u00A4\u00A8\u00E0\u00A5\u008D\u00E0\u00A4\u00AF\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u0097\u00E0\u00A4\u00BE\u00E0\u00A4\u0087\u00E0\u00A4\u00A1\u00E0\u00A4\u00AC\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A5\u0087\u00E0\u00A4\u0095\u00E0\u00A4\u00BF\u00E0\u00A4\u00B8\u00E0\u00A5\u0080\u00E0\u00A4\u00A6\u00E0\u00A4\u00BF\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00AA\u00E0\u00A4\u00B9\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u00B8\u00E0\u00A4\u00BF\u00E0\u00A4\u0082\u00E0\u00A4\u00B9\u00E0\u00A4\u00AD\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00A4\u00E0\u00A4\u0085\u00E0\u00A4\u00AA\u00E0\u00A4\u00A8\u00E0\u00A5\u0080\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u00B8\u00E0\u00A5\u0087\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u0095\u00E0\u00A4\u00B0\u00E0\u00A4\u00A4\u00E0\u00A5\u0087\u00E0\u00A4\u00AE\u00E0\u00A5\u0087\u00E0\u00A4\u00B0\u00E0\u00A5\u0087\u00E0\u00A4\u00B9\u00E0\u00A5\u008B\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u00B8\u00E0\u00A4\u0095\u00E0\u00A4\u00A4\u00E0\u00A5\u0087\u00E0\u00A4\u00AC\u00E0\u00A4\u00B9\u00E0\u00A5\u0081\u00E0\u00A4\u00A4\u00E0\u00A4\u00B8\u00E0\u00A4\u00BE\u00E0\u00A4\u0087\u00E0\u00A4\u009F\u00E0\u00A4\u00B9\u00E0\u00A5\u008B\u00E0\u00A4\u0097\u00E0\u00A4\u00BE\u00E0\u00A4\u009C\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u00AE\u00E0\u00A4\u00BF\u00E0\u00A4\u00A8\u00E0\u00A4\u009F\u00E0\u00A4\u0095\u00E0\u00A4\u00B0\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u0095\u00E0\u00A4\u00B0\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u0089\u00E0\u00A4\u00A8\u00E0\u00A4\u0095\u00E0\u00A5\u0087\u00E0\u00A4\u00AF\u00E0\u00A4\u00B9\u00E0\u00A4\u00BE\u00E0\u00A4\u0081\u00E0\u00A4\u00B8\u00E0\u00A4\u00AC\u00E0\u00A4\u00B8\u00E0\u00A5\u0087\u00E0\u00A4\u00AD\u00E0\u00A4\u00BE\u00E0\u00A4\u00B7\u00E0\u00A4\u00BE\u00E0\u00A4\u0086\u00E0\u00A4\u00AA\u00E0\u00A4\u0095\u00E0\u00A5\u0087\u00E0\u00A4\u00B2\u00E0\u00A4\u00BF\u00E0\u00A4\u00AF\u00E0\u00A5\u0087\u00E0\u00A4\u00B6\u00E0\u00A5\u0081\u00E0\u00A4\u00B0\u00E0\u00A5\u0082\u00E0\u00A4\u0087\u00E0\u00A4\u00B8\u00E0\u00A4\u0095\u00E0\u00A5\u0087\u00E0\u00A4\u0098\u00E0\u00A4\u0082\u00E0\u00A4\u009F\u00E0\u00A5\u0087\u00E0\u00A4\u00AE\u00E0\u00A5\u0087\u00E0\u00A4\u00B0\u00E0\u00A5\u0080\u00E0\u00A4\u00B8\u00E0\u00A4\u0095\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u00AE\u00E0\u00A5\u0087\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u0095\u00E0\u00A4\u00B0\u00E0\u00A4\u0085\u00E0\u00A4\u00A7\u00E0\u00A4\u00BF\u00E0\u00A4\u0095\u00E0\u00A4\u0085\u00E0\u00A4\u00AA\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A4\u00AE\u00E0\u00A4\u00BE\u00E0\u00A4\u009C\u00E0\u00A4\u00AE\u00E0\u00A5\u0081\u00E0\u00A4\u009D\u00E0\u00A5\u0087\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00A3\u00E0\u00A4\u00B9\u00E0\u00A5\u008B\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u0095\u00E0\u00A4\u00A1\u00E0\u00A4\u00BC\u00E0\u00A5\u0080\u00E0\u00A4\u00AF\u00E0\u00A4\u00B9\u00E0\u00A4\u00BE\u00E0\u00A4\u0082\u00E0\u00A4\u00B9\u00E0\u00A5\u008B\u00E0\u00A4\u009F\u00E0\u00A4\u00B2\u00E0\u00A4\u00B6\u00E0\u00A4\u00AC\u00E0\u00A5\u008D\u00E0\u00A4\u00A6\u00E0\u00A4\u00B2\u00E0\u00A4\u00BF\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u009C\u00E0\u00A5\u0080\u00E0\u00A4\u00B5\u00E0\u00A4\u00A8\u00E0\u00A4\u009C\u00E0\u00A4\u00BE\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u0095\u00E0\u00A5\u0088\u00E0\u00A4\u00B8\u00E0\u00A5\u0087\u00E0\u00A4\u0086\u00E0\u00A4\u00AA\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u00B2\u00E0\u00A5\u0080\u00E0\u00A4\u00A6\u00E0\u00A5\u0087\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u00AA\u00E0\u00A5\u0082\u00E0\u00A4\u00B0\u00E0\u00A5\u0080\u00E0\u00A4\u00AA\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A5\u0080\u00E0\u00A4\u0089\u00E0\u00A4\u00B8\u00E0\u00A4\u0095\u00E0\u00A5\u0087\u00E0\u00A4\u00B9\u00E0\u00A5\u008B\u00E0\u00A4\u0097\u00E0\u00A5\u0080\u00E0\u00A4\u00AC\u00E0\u00A5\u0088\u00E0\u00A4\u00A0\u00E0\u00A4\u0095\u00E0\u00A4\u0086\u00E0\u00A4\u00AA\u00E0\u00A4\u0095\u00E0\u00A5\u0080\u00E0\u00A4\u00B5\u00E0\u00A4\u00B0\u00E0\u00A5\u008D\u00E0\u00A4\u00B7\u00E0\u00A4\u0097\u00E0\u00A4\u00BE\u00E0\u00A4\u0082\u00E0\u00A4\u00B5\u00E0\u00A4\u0086\u00E0\u00A4\u00AA\u00E0\u00A4\u0095\u00E0\u00A5\u008B\u00E0\u00A4\u009C\u00E0\u00A4\u00BF\u00E0\u00A4\u00B2\u00E0\u00A4\u00BE\u00E0\u00A4\u009C\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A4\u00B9\u00E0\u00A4\u00AE\u00E0\u00A4\u00A4\u00E0\u00A4\u00B9\u00E0\u00A4\u00AE\u00E0\u00A5\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u0089\u00E0\u00A4\u00A8\u00E0\u00A4\u0095\u00E0\u00A5\u0080\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00B9\u00E0\u00A5\u0082\u00E0\u00A4\u00A6\u00E0\u00A4\u00B0\u00E0\u00A5\u008D\u00E0\u00A4\u009C\u00E0\u00A4\u00B8\u00E0\u00A5\u0082\u00E0\u00A4\u009A\u00E0\u00A5\u0080\u00E0\u00A4\u00AA\u00E0\u00A4\u00B8\u00E0\u00A4\u0082\u00E0\u00A4\u00A6\u00E0\u00A4\u00B8\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u00B2\u00E0\u00A4\u00B9\u00E0\u00A5\u008B\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00B9\u00E0\u00A5\u008B\u00E0\u00A4\u00A4\u00E0\u00A5\u0080\u00E0\u00A4\u009C\u00E0\u00A5\u0088\u00E0\u00A4\u00B8\u00E0\u00A5\u0087\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u00AA\u00E0\u00A4\u00B8\u00E0\u00A4\u009C\u00E0\u00A4\u00A8\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u009C\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A5\u0080\u00E0\u00A4\u0098\u00E0\u00A4\u00BE\u00E0\u00A4\u00AF\u00E0\u00A4\u00B2\u00E0\u00A4\u009C\u00E0\u00A4\u00BF\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u00A8\u00E0\u00A5\u0080\u00E0\u00A4\u009A\u00E0\u00A5\u0087\u00E0\u00A4\u009C\u00E0\u00A4\u00BE\u00E0\u00A4\u0082\u00E0\u00A4\u009A\u00E0\u00A4\u00AA\u00E0\u00A4\u00A4\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u0097\u00E0\u00A5\u0082\u00E0\u00A4\u0097\u00E0\u00A4\u00B2\u00E0\u00A4\u009C\u00E0\u00A4\u00BE\u00E0\u00A4\u00A4\u00E0\u00A5\u0087\u00E0\u00A4\u00AC\u00E0\u00A4\u00BE\u00E0\u00A4\u00B9\u00E0\u00A4\u00B0\u00E0\u00A4\u0086\u00E0\u00A4\u00AA\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u00B9\u00E0\u00A4\u00A8\u00E0\u00A4\u0087\u00E0\u00A4\u00B8\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A5\u0081\u00E0\u00A4\u00AC\u00E0\u00A4\u00B9\u00E0\u00A4\u00B0\u00E0\u00A4\u00B9\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u0087\u00E0\u00A4\u00B8\u00E0\u00A4\u00B8\u00E0\u00A5\u0087\u00E0\u00A4\u00B8\u00E0\u00A4\u00B9\u00E0\u00A4\u00BF\u00E0\u00A4\u00A4\u00E0\u00A4\u00AC\u00E0\u00A4\u00A1\u00E0\u00A4\u00BC\u00E0\u00A5\u0087\u00E0\u00A4\u0098\u00E0\u00A4\u009F\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00A4\u00E0\u00A4\u00B2\u00E0\u00A4\u00BE\u00E0\u00A4\u00B6\u00E0\u00A4\u00AA\u00E0\u00A4\u00BE\u00E0\u00A4\u0082\u00E0\u00A4\u009A\u00E0\u00A4\u00B6\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A5\u0080\u00E0\u00A4\u00AC\u00E0\u00A4\u00A1\u00E0\u00A4\u00BC\u00E0\u00A5\u0080\u00E0\u00A4\u00B9\u00E0\u00A5\u008B\u00E0\u00A4\u00A4\u00E0\u00A5\u0087\u00E0\u00A4\u00B8\u00E0\u00A4\u00BE\u00E0\u00A4\u0088\u00E0\u00A4\u009F\u00E0\u00A4\u00B6\u00E0\u00A4\u00BE\u00E0\u00A4\u00AF\u00E0\u00A4\u00A6\u00E0\u00A4\u00B8\u00E0\u00A4\u0095\u00E0\u00A4\u00A4\u00E0\u00A5\u0080\u00E0\u00A4\u009C\u00E0\u00A4\u00BE\u00E0\u00A4\u00A4\u00E0\u00A5\u0080\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u00B2\u00E0\u00A4\u00BE\u00E0\u00A4\u00B9\u00E0\u00A4\u009C\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00AA\u00E0\u00A4\u009F\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u0096\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u00B8\u00E0\u00A4\u00A1\u00E0\u00A4\u00BC\u00E0\u00A4\u0095\u00E0\u00A4\u00AE\u00E0\u00A4\u00BF\u00E0\u00A4\u00B2\u00E0\u00A4\u00BE\u00E0\u00A4\u0089\u00E0\u00A4\u00B8\u00E0\u00A4\u0095\u00E0\u00A5\u0080\u00E0\u00A4\u0095\u00E0\u00A5\u0087\u00E0\u00A4\u00B5\u00E0\u00A4\u00B2\u00E0\u00A4\u00B2\u00E0\u00A4\u0097\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u0096\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u0085\u00E0\u00A4\u00B0\u00E0\u00A5\u008D\u00E0\u00A4\u00A5\u00E0\u00A4\u009C\u00E0\u00A4\u00B9\u00E0\u00A4\u00BE\u00E0\u00A4\u0082\u00E0\u00A4\u00A6\u00E0\u00A5\u0087\u00E0\u00A4\u0096\u00E0\u00A4\u00BE\u00E0\u00A4\u00AA\u00E0\u00A4\u00B9\u00E0\u00A4\u00B2\u00E0\u00A5\u0080\u00E0\u00A4\u00A8\u00E0\u00A4\u00BF\u00E0\u00A4\u00AF\u00E0\u00A4\u00AE\u00E0\u00A4\u00AC\u00E0\u00A4\u00BF\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00AC\u00E0\u00A5\u0088\u00E0\u00A4\u0082\u00E0\u00A4\u0095\u00E0\u00A4\u0095\u00E0\u00A4\u00B9\u00E0\u00A5\u0080\u00E0\u00A4\u0082\u00E0\u00A4\u0095\u00E0\u00A4\u00B9\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00A6\u00E0\u00A5\u0087\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u00B9\u00E0\u00A4\u00AE\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00AB\u00E0\u00A5\u0080\u00E0\u00A4\u009C\u00E0\u00A4\u00AC\u00E0\u00A4\u0095\u00E0\u00A4\u00BF\u00E0\u00A4\u00A4\u00E0\u00A5\u0081\u00E0\u00A4\u00B0\u00E0\u00A4\u00A4\u00E0\u00A4\u00AE\u00E0\u00A4\u00BE\u00E0\u00A4\u0082\u00E0\u00A4\u0097\u00E0\u00A4\u00B5\u00E0\u00A4\u00B9\u00E0\u00A5\u0080\u00E0\u00A4\u0082\u00E0\u00A4\u00B0\u00E0\u00A5\u008B\u00E0\u00A4\u009C\u00E0\u00A4\u00BC\u00E0\u00A4\u00AE\u00E0\u00A4\u00BF\u00E0\u00A4\u00B2\u00E0\u00A5\u0080\u00E0\u00A4\u0086\u00E0\u00A4\u00B0\u00E0\u00A5\u008B\u00E0\u00A4\u00AA\u00E0\u00A4\u00B8\u00E0\u00A5\u0087\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00A6\u00E0\u00A4\u00B5\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u0096\u00E0\u00A4\u00BE\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u0095\u00E0\u00A4\u00B0\u00E0\u00A5\u0080\u00E0\u00A4\u00AC\u00E0\u00A4\u0089\u00E0\u00A4\u00A8\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u009C\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u00AC\u00E0\u00A4\u00AA\u00E0\u00A5\u0082\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u00AC\u00E0\u00A4\u00A1\u00E0\u00A4\u00BC\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A5\u008C\u00E0\u00A4\u00A6\u00E0\u00A4\u00BE\u00E0\u00A4\u00B6\u00E0\u00A5\u0087\u00E0\u00A4\u00AF\u00E0\u00A4\u00B0\u00E0\u00A4\u0095\u00E0\u00A4\u00BF\u00E0\u00A4\u00AF\u00E0\u00A5\u0087\u00E0\u00A4\u0095\u00E0\u00A4\u00B9\u00E0\u00A4\u00BE\u00E0\u00A4\u0082\u00E0\u00A4\u0085\u00E0\u00A4\u0095\u00E0\u00A4\u00B8\u00E0\u00A4\u00B0\u00E0\u00A4\u00AC\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u008F\u00E0\u00A4\u00B5\u00E0\u00A4\u00B9\u00E0\u00A4\u00BE\u00E0\u00A4\u0082\u00E0\u00A4\u00B8\u00E0\u00A5\u008D\u00E0\u00A4\u00A5\u00E0\u00A4\u00B2\u00E0\u00A4\u00AE\u00E0\u00A4\u00BF\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u0096\u00E0\u00A4\u0095\u00E0\u00A4\u00B5\u00E0\u00A4\u00BF\u00E0\u00A4\u00B7\u00E0\u00A4\u00AF\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u0082\u00E0\u00A4\u00B8\u00E0\u00A4\u00AE\u00E0\u00A5\u0082\u00E0\u00A4\u00B9\u00E0\u00A4\u00A5\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00D8\u00AA\u00D8\u00B3\u00D8\u00AA\u00D8\u00B7\u00D9\u008A\u00D8\u00B9\u00D9\u0085\u00D8\u00B4\u00D8\u00A7\u00D8\u00B1\u00D9\u0083\u00D8\u00A9\u00D8\u00A8\u00D9\u0088\u00D8\u00A7\u00D8\u00B3\u00D8\u00B7\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00B5\u00D9\u0081\u00D8\u00AD\u00D8\u00A9\u00D9\u0085\u00D9\u0088\u00D8\u00A7\u00D8\u00B6\u00D9\u008A\u00D8\u00B9\u00D8\u00A7\u00D9\u0084\u00D8\u00AE\u00D8\u00A7\u00D8\u00B5\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00B2\u00D9\u008A\u00D8\u00AF\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D8\u00A7\u00D9\u0085\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D9\u0083\u00D8\u00A7\u00D8\u00AA\u00D8\u00A8\u00D8\u00A7\u00D9\u0084\u00D8\u00B1\u00D8\u00AF\u00D9\u0088\u00D8\u00AF\u00D8\u00A8\u00D8\u00B1\u00D9\u0086\u00D8\u00A7\u00D9\u0085\u00D8\u00AC\u00D8\u00A7\u00D9\u0084\u00D8\u00AF\u00D9\u0088\u00D9\u0084\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D9\u0088\u00D9\u0082\u00D8\u00B9\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D8\u00B1\u00D8\u00A8\u00D9\u008A\u00D8\u00A7\u00D9\u0084\u00D8\u00B3\u00D8\u00B1\u00D9\u008A\u00D8\u00B9\u00D8\u00A7\u00D9\u0084\u00D8\u00AC\u00D9\u0088\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D9\u0084\u00D8\u00B0\u00D9\u0087\u00D8\u00A7\u00D8\u00A8\u00D8\u00A7\u00D9\u0084\u00D8\u00AD\u00D9\u008A\u00D8\u00A7\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00AD\u00D9\u0082\u00D9\u0088\u00D9\u0082\u00D8\u00A7\u00D9\u0084\u00D9\u0083\u00D8\u00B1\u00D9\u008A\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D8\u00B1\u00D8\u00A7\u00D9\u0082\u00D9\u0085\u00D8\u00AD\u00D9\u0081\u00D9\u0088\u00D8\u00B8\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00AB\u00D8\u00A7\u00D9\u0086\u00D9\u008A\u00D9\u0085\u00D8\u00B4\u00D8\u00A7\u00D9\u0087\u00D8\u00AF\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00B1\u00D8\u00A3\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D9\u0082\u00D8\u00B1\u00D8\u00A2\u00D9\u0086\u00D8\u00A7\u00D9\u0084\u00D8\u00B4\u00D8\u00A8\u00D8\u00A7\u00D8\u00A8\u00D8\u00A7\u00D9\u0084\u00D8\u00AD\u00D9\u0088\u00D8\u00A7\u00D8\u00B1\u00D8\u00A7\u00D9\u0084\u00D8\u00AC\u00D8\u00AF\u00D9\u008A\u00D8\u00AF\u00D8\u00A7\u00D9\u0084\u00D8\u00A3\u00D8\u00B3\u00D8\u00B1\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D9\u0084\u00D9\u0088\u00D9\u0085\u00D9\u0085\u00D8\u00AC\u00D9\u0085\u00D9\u0088\u00D8\u00B9\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00B1\u00D8\u00AD\u00D9\u0085\u00D9\u0086\u00D8\u00A7\u00D9\u0084\u00D9\u0086\u00D9\u0082\u00D8\u00A7\u00D8\u00B7\u00D9\u0081\u00D9\u0084\u00D8\u00B3\u00D8\u00B7\u00D9\u008A\u00D9\u0086\u00D8\u00A7\u00D9\u0084\u00D9\u0083\u00D9\u0088\u00D9\u008A\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D8\u00AF\u00D9\u0086\u00D9\u008A\u00D8\u00A7\u00D8\u00A8\u00D8\u00B1\u00D9\u0083\u00D8\u00A7\u00D8\u00AA\u00D9\u0087\u00D8\u00A7\u00D9\u0084\u00D8\u00B1\u00D9\u008A\u00D8\u00A7\u00D8\u00B6\u00D8\u00AA\u00D8\u00AD\u00D9\u008A\u00D8\u00A7\u00D8\u00AA\u00D9\u008A\u00D8\u00A8\u00D8\u00AA\u00D9\u0088\u00D9\u0082\u00D9\u008A\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D8\u00A3\u00D9\u0088\u00D9\u0084\u00D9\u0089\u00D8\u00A7\u00D9\u0084\u00D8\u00A8\u00D8\u00B1\u00D9\u008A\u00D8\u00AF\u00D8\u00A7\u00D9\u0084\u00D9\u0083\u00D9\u0084\u00D8\u00A7\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D8\u00B1\u00D8\u00A7\u00D8\u00A8\u00D8\u00B7\u00D8\u00A7\u00D9\u0084\u00D8\u00B4\u00D8\u00AE\u00D8\u00B5\u00D9\u008A\u00D8\u00B3\u00D9\u008A\u00D8\u00A7\u00D8\u00B1\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D8\u00AB\u00D8\u00A7\u00D9\u0084\u00D8\u00AB\u00D8\u00A7\u00D9\u0084\u00D8\u00B5\u00D9\u0084\u00D8\u00A7\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00AD\u00D8\u00AF\u00D9\u008A\u00D8\u00AB\u00D8\u00A7\u00D9\u0084\u00D8\u00B2\u00D9\u0088\u00D8\u00A7\u00D8\u00B1\u00D8\u00A7\u00D9\u0084\u00D8\u00AE\u00D9\u0084\u00D9\u008A\u00D8\u00AC\u00D8\u00A7\u00D9\u0084\u00D8\u00AC\u00D9\u0085\u00D9\u008A\u00D8\u00B9\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D8\u00A7\u00D9\u0085\u00D9\u0087\u00D8\u00A7\u00D9\u0084\u00D8\u00AC\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D9\u0084\u00D8\u00B3\u00D8\u00A7\u00D8\u00B9\u00D8\u00A9\u00D9\u0085\u00D8\u00B4\u00D8\u00A7\u00D9\u0087\u00D8\u00AF\u00D9\u0087\u00D8\u00A7\u00D9\u0084\u00D8\u00B1\u00D8\u00A6\u00D9\u008A\u00D8\u00B3\u00D8\u00A7\u00D9\u0084\u00D8\u00AF\u00D8\u00AE\u00D9\u0088\u00D9\u0084\u00D8\u00A7\u00D9\u0084\u00D9\u0081\u00D9\u0086\u00D9\u008A\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D9\u0083\u00D8\u00AA\u00D8\u00A7\u00D8\u00A8\u00D8\u00A7\u00D9\u0084\u00D8\u00AF\u00D9\u0088\u00D8\u00B1\u00D9\u008A\u00D8\u00A7\u00D9\u0084\u00D8\u00AF\u00D8\u00B1\u00D9\u0088\u00D8\u00B3\u00D8\u00A7\u00D8\u00B3\u00D8\u00AA\u00D8\u00BA\u00D8\u00B1\u00D9\u0082\u00D8\u00AA\u00D8\u00B5\u00D8\u00A7\u00D9\u0085\u00D9\u008A\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D8\u00A8\u00D9\u0086\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D8\u00B8\u00D9\u008A\u00D9\u0085entertainmentunderstanding = function().jpg\" width=\"configuration.png\" width=\"<body class=\"Math.random()contemporary United Statescircumstances.appendChild(organizations<span class=\"\"><img src=\"/distinguishedthousands of communicationclear\"></div>investigationfavicon.ico\" margin-right:based on the Massachusettstable border=internationalalso known aspronunciationbackground:#fpadding-left:For example, miscellaneous&lt;/math&gt;psychologicalin particularearch\" type=\"form method=\"as opposed toSupreme Courtoccasionally Additionally,North Americapx;backgroundopportunitiesEntertainment.toLowerCase(manufacturingprofessional combined withFor instance,consisting of\" maxlength=\"return false;consciousnessMediterraneanextraordinaryassassinationsubsequently button type=\"the number ofthe original comprehensiverefers to the</ul>\n</div>\nphilosophicallocation.hrefwas publishedSan Francisco(function(){\n<div id=\"mainsophisticatedmathematical /head>\r\n<bodysuggests thatdocumentationconcentrationrelationshipsmay have been(for example,This article in some casesparts of the definition ofGreat Britain cellpadding=equivalent toplaceholder=\"; font-size: justificationbelieved thatsuffered fromattempted to leader of thecript\" src=\"/(function() {are available\n\t<link rel=\" src='http://interested inconventional \" alt=\"\" /></are generallyhas also beenmost popular correspondingcredited withtyle=\"border:</a></span></.gif\" width=\"<iframe src=\"table class=\"inline-block;according to together withapproximatelyparliamentarymore and moredisplay:none;traditionallypredominantly&nbsp;|&nbsp;&nbsp;</span> cellspacing=<input name=\"or\" content=\"controversialproperty=\"og:/x-shockwave-demonstrationsurrounded byNevertheless,was the firstconsiderable Although the collaborationshould not beproportion of<span style=\"known as the shortly afterfor instance,described as /head>\n<body starting withincreasingly the fact thatdiscussion ofmiddle of thean individualdifficult to point of viewhomosexualityacceptance of</span></div>manufacturersorigin of thecommonly usedimportance ofdenominationsbackground: #length of thedeterminationa significant\" border=\"0\">revolutionaryprinciples ofis consideredwas developedIndo-Europeanvulnerable toproponents ofare sometimescloser to theNew York City name=\"searchattributed tocourse of themathematicianby the end ofat the end of\" border=\"0\" technological.removeClass(branch of theevidence that![endif]-->\r\nInstitute of into a singlerespectively.and thereforeproperties ofis located insome of whichThere is alsocontinued to appearance of &amp;ndash; describes theconsiderationauthor of theindependentlyequipped withdoes not have</a><a href=\"confused with<link href=\"/at the age ofappear in theThese includeregardless ofcould be used style=&quot;several timesrepresent thebody>\n</html>thought to bepopulation ofpossibilitiespercentage ofaccess to thean attempt toproduction ofjquery/jquerytwo differentbelong to theestablishmentreplacing thedescription\" determine theavailable forAccording to wide range of\t<div class=\"more commonlyorganisationsfunctionalitywas completed &amp;mdash; participationthe characteran additionalappears to befact that thean example ofsignificantlyonmouseover=\"because they async = true;problems withseems to havethe result of src=\"http://familiar withpossession offunction () {took place inand sometimessubstantially<span></span>is often usedin an attemptgreat deal ofEnvironmentalsuccessfully virtually all20th century,professionalsnecessary to determined bycompatibilitybecause it isDictionary ofmodificationsThe followingmay refer to:Consequently,Internationalalthough somethat would beworld's firstclassified asbottom of the(particularlyalign=\"left\" most commonlybasis for thefoundation ofcontributionspopularity ofcenter of theto reduce thejurisdictionsapproximation onmouseout=\"New Testamentcollection of</span></a></in the Unitedfilm director-strict.dtd\">has been usedreturn to thealthough thischange in theseveral otherbut there areunprecedentedis similar toespecially inweight: bold;is called thecomputationalindicate thatrestricted to\t<meta name=\"are typicallyconflict withHowever, the An example ofcompared withquantities ofrather than aconstellationnecessary forreported thatspecificationpolitical and&nbsp;&nbsp;<references tothe same yearGovernment ofgeneration ofhave not beenseveral yearscommitment to\t\t<ul class=\"visualization19th century,practitionersthat he wouldand continuedoccupation ofis defined ascentre of thethe amount of><div style=\"equivalent ofdifferentiatebrought aboutmargin-left: automaticallythought of asSome of these\n<div class=\"input class=\"replaced withis one of theeducation andinfluenced byreputation as\n<meta name=\"accommodation</div>\n</div>large part ofInstitute forthe so-called against the In this case,was appointedclaimed to beHowever, thisDepartment ofthe remainingeffect on theparticularly deal with the\n<div style=\"almost alwaysare currentlyexpression ofphilosophy offor more thancivilizationson the islandselectedIndexcan result in\" value=\"\" />the structure /></a></div>Many of thesecaused by theof the Unitedspan class=\"mcan be tracedis related tobecame one ofis frequentlyliving in thetheoreticallyFollowing theRevolutionarygovernment inis determinedthe politicalintroduced insufficient todescription\">short storiesseparation ofas to whetherknown for itswas initiallydisplay:blockis an examplethe principalconsists of arecognized as/body></html>a substantialreconstructedhead of stateresistance toundergraduateThere are twogravitationalare describedintentionallyserved as theclass=\"headeropposition tofundamentallydominated theand the otheralliance withwas forced torespectively,and politicalin support ofpeople in the20th century.and publishedloadChartbeatto understandmember statesenvironmentalfirst half ofcountries andarchitecturalbe consideredcharacterizedclearIntervalauthoritativeFederation ofwas succeededand there area consequencethe Presidentalso includedfree softwaresuccession ofdeveloped thewas destroyedaway from the;\n</script>\n<although theyfollowed by amore powerfulresulted in aUniversity ofHowever, manythe presidentHowever, someis thought tountil the endwas announcedare importantalso includes><input type=the center of DO NOT ALTERused to referthemes/?sort=that had beenthe basis forhas developedin the summercomparativelydescribed thesuch as thosethe resultingis impossiblevarious otherSouth Africanhave the sameeffectivenessin which case; text-align:structure and; background:regarding thesupported theis also knownstyle=\"marginincluding thebahasa Melayunorsk bokm\u00C3\u00A5lnorsk nynorsksloven\u00C5\u00A1\u00C4\u008Dinainternacionalcalificaci\u00C3\u00B3ncomunicaci\u00C3\u00B3nconstrucci\u00C3\u00B3n\"><div class=\"disambiguationDomainName', 'administrationsimultaneouslytransportationInternational margin-bottom:responsibility<![endif]-->\n</><meta name=\"implementationinfrastructurerepresentationborder-bottom:</head>\n<body>=http%3A%2F%2F<form method=\"method=\"post\" /favicon.ico\" });\n</script>\n.setAttribute(Administration= new Array();<![endif]-->\r\ndisplay:block;Unfortunately,\">&nbsp;</div>/favicon.ico\">='stylesheet' identification, for example,<li><a href=\"/an alternativeas a result ofpt\"></script>\ntype=\"submit\" \n(function() {recommendationform action=\"/transformationreconstruction.style.display According to hidden\" name=\"along with thedocument.body.approximately Communicationspost\" action=\"meaning &quot;--<![endif]-->Prime Ministercharacteristic</a> <a class=the history of onmouseover=\"the governmenthref=\"https://was originallywas introducedclassificationrepresentativeare considered<![endif]-->\n\ndepends on theUniversity of in contrast to placeholder=\"in the case ofinternational constitutionalstyle=\"border-: function() {Because of the-strict.dtd\">\n<table class=\"accompanied byaccount of the<script src=\"/nature of the the people in in addition tos); js.id = id\" width=\"100%\"regarding the Roman Catholican independentfollowing the .gif\" width=\"1the following discriminationarchaeologicalprime minister.js\"></script>combination of marginwidth=\"createElement(w.attachEvent(</a></td></tr>src=\"https://aIn particular, align=\"left\" Czech RepublicUnited Kingdomcorrespondenceconcluded that.html\" title=\"(function () {comes from theapplication of<span class=\"sbelieved to beement('script'</a>\n</li>\n<livery different><span class=\"option value=\"(also known as\t<li><a href=\"><input name=\"separated fromreferred to as valign=\"top\">founder of theattempting to carbon dioxide\n\n<div class=\"class=\"search-/body>\n</html>opportunity tocommunications</head>\r\n<body style=\"width:Ti\u00E1\u00BA\u00BFng Vi\u00E1\u00BB\u0087tchanges in theborder-color:#0\" border=\"0\" </span></div><was discovered\" type=\"text\" );\n</script>\n\nDepartment of ecclesiasticalthere has beenresulting from</body></html>has never beenthe first timein response toautomatically </div>\n\n<div iwas consideredpercent of the\" /></a></div>collection of descended fromsection of theaccept-charsetto be confusedmember of the padding-right:translation ofinterpretation href='http://whether or notThere are alsothere are manya small numberother parts ofimpossible to  class=\"buttonlocated in the. However, theand eventuallyAt the end of because of itsrepresents the<form action=\" method=\"post\"it is possiblemore likely toan increase inhave also beencorresponds toannounced thatalign=\"right\">many countriesfor many yearsearliest knownbecause it waspt\"></script>\r valign=\"top\" inhabitants offollowing year\r\n<div class=\"million peoplecontroversial concerning theargue that thegovernment anda reference totransferred todescribing the style=\"color:although therebest known forsubmit\" name=\"multiplicationmore than one recognition ofCouncil of theedition of the  <meta name=\"Entertainment away from the ;margin-right:at the time ofinvestigationsconnected withand many otheralthough it isbeginning with <span class=\"descendants of<span class=\"i align=\"right\"</head>\n<body aspects of thehas since beenEuropean Unionreminiscent ofmore difficultVice Presidentcomposition ofpassed throughmore importantfont-size:11pxexplanation ofthe concept ofwritten in the\t<span class=\"is one of the resemblance toon the groundswhich containsincluding the defined by thepublication ofmeans that theoutside of thesupport of the<input class=\"<span class=\"t(Math.random()most prominentdescription ofConstantinoplewere published<div class=\"seappears in the1\" height=\"1\" most importantwhich includeswhich had beendestruction ofthe population\n\t<div class=\"possibility ofsometimes usedappear to havesuccess of theintended to bepresent in thestyle=\"clear:b\r\n</script>\r\n<was founded ininterview with_id\" content=\"capital of the\r\n<link rel=\"srelease of thepoint out thatxMLHttpRequestand subsequentsecond largestvery importantspecificationssurface of theapplied to theforeign policy_setDomainNameestablished inis believed toIn addition tomeaning of theis named afterto protect theis representedDeclaration ofmore efficientClassificationother forms ofhe returned to<span class=\"cperformance of(function() {\rif and only ifregions of theleading to therelations withUnited Nationsstyle=\"height:other than theype\" content=\"Association of\n</head>\n<bodylocated on theis referred to(including theconcentrationsthe individualamong the mostthan any other/>\n<link rel=\" return false;the purpose ofthe ability to;color:#fff}\n.\n<span class=\"the subject ofdefinitions of>\r\n<link rel=\"claim that thehave developed<table width=\"celebration ofFollowing the to distinguish<span class=\"btakes place inunder the namenoted that the><![endif]-->\nstyle=\"margin-instead of theintroduced thethe process ofincreasing thedifferences inestimated thatespecially the/div><div id=\"was eventuallythroughout histhe differencesomething thatspan></span></significantly ></script>\r\n\r\nenvironmental to prevent thehave been usedespecially forunderstand theis essentiallywere the firstis the largesthave been made\" src=\"http://interpreted assecond half ofcrolling=\"no\" is composed ofII, Holy Romanis expected tohave their owndefined as thetraditionally have differentare often usedto ensure thatagreement withcontaining theare frequentlyinformation onexample is theresulting in a</a></li></ul> class=\"footerand especiallytype=\"button\" </span></span>which included>\n<meta name=\"considered thecarried out byHowever, it isbecame part ofin relation topopular in thethe capital ofwas officiallywhich has beenthe History ofalternative todifferent fromto support thesuggested thatin the process  <div class=\"the foundationbecause of hisconcerned withthe universityopposed to thethe context of<span class=\"ptext\" name=\"q\"\t\t<div class=\"the scientificrepresented bymathematicianselected by thethat have been><div class=\"cdiv id=\"headerin particular,converted into);\n</script>\n<philosophical srpskohrvatskiti\u00E1\u00BA\u00BFng Vi\u00E1\u00BB\u0087t\u00D0\u00A0\u00D1\u0083\u00D1\u0081\u00D1\u0081\u00D0\u00BA\u00D0\u00B8\u00D0\u00B9\u00D1\u0080\u00D1\u0083\u00D1\u0081\u00D1\u0081\u00D0\u00BA\u00D0\u00B8\u00D0\u00B9investigaci\u00C3\u00B3nparticipaci\u00C3\u00B3n\u00D0\u00BA\u00D0\u00BE\u00D1\u0082\u00D0\u00BE\u00D1\u0080\u00D1\u008B\u00D0\u00B5\u00D0\u00BE\u00D0\u00B1\u00D0\u00BB\u00D0\u00B0\u00D1\u0081\u00D1\u0082\u00D0\u00B8\u00D0\u00BA\u00D0\u00BE\u00D1\u0082\u00D0\u00BE\u00D1\u0080\u00D1\u008B\u00D0\u00B9\u00D1\u0087\u00D0\u00B5\u00D0\u00BB\u00D0\u00BE\u00D0\u00B2\u00D0\u00B5\u00D0\u00BA\u00D1\u0081\u00D0\u00B8\u00D1\u0081\u00D1\u0082\u00D0\u00B5\u00D0\u00BC\u00D1\u008B\u00D0\u009D\u00D0\u00BE\u00D0\u00B2\u00D0\u00BE\u00D1\u0081\u00D1\u0082\u00D0\u00B8\u00D0\u00BA\u00D0\u00BE\u00D1\u0082\u00D0\u00BE\u00D1\u0080\u00D1\u008B\u00D1\u0085\u00D0\u00BE\u00D0\u00B1\u00D0\u00BB\u00D0\u00B0\u00D1\u0081\u00D1\u0082\u00D1\u008C\u00D0\u00B2\u00D1\u0080\u00D0\u00B5\u00D0\u00BC\u00D0\u00B5\u00D0\u00BD\u00D0\u00B8\u00D0\u00BA\u00D0\u00BE\u00D1\u0082\u00D0\u00BE\u00D1\u0080\u00D0\u00B0\u00D1\u008F\u00D1\u0081\u00D0\u00B5\u00D0\u00B3\u00D0\u00BE\u00D0\u00B4\u00D0\u00BD\u00D1\u008F\u00D1\u0081\u00D0\u00BA\u00D0\u00B0\u00D1\u0087\u00D0\u00B0\u00D1\u0082\u00D1\u008C\u00D0\u00BD\u00D0\u00BE\u00D0\u00B2\u00D0\u00BE\u00D1\u0081\u00D1\u0082\u00D0\u00B8\u00D0\u00A3\u00D0\u00BA\u00D1\u0080\u00D0\u00B0\u00D0\u00B8\u00D0\u00BD\u00D1\u008B\u00D0\u00B2\u00D0\u00BE\u00D0\u00BF\u00D1\u0080\u00D0\u00BE\u00D1\u0081\u00D1\u008B\u00D0\u00BA\u00D0\u00BE\u00D1\u0082\u00D0\u00BE\u00D1\u0080\u00D0\u00BE\u00D0\u00B9\u00D1\u0081\u00D0\u00B4\u00D0\u00B5\u00D0\u00BB\u00D0\u00B0\u00D1\u0082\u00D1\u008C\u00D0\u00BF\u00D0\u00BE\u00D0\u00BC\u00D0\u00BE\u00D1\u0089\u00D1\u008C\u00D1\u008E\u00D1\u0081\u00D1\u0080\u00D0\u00B5\u00D0\u00B4\u00D1\u0081\u00D1\u0082\u00D0\u00B2\u00D0\u00BE\u00D0\u00B1\u00D1\u0080\u00D0\u00B0\u00D0\u00B7\u00D0\u00BE\u00D0\u00BC\u00D1\u0081\u00D1\u0082\u00D0\u00BE\u00D1\u0080\u00D0\u00BE\u00D0\u00BD\u00D1\u008B\u00D1\u0083\u00D1\u0087\u00D0\u00B0\u00D1\u0081\u00D1\u0082\u00D0\u00B8\u00D0\u00B5\u00D1\u0082\u00D0\u00B5\u00D1\u0087\u00D0\u00B5\u00D0\u00BD\u00D0\u00B8\u00D0\u00B5\u00D0\u0093\u00D0\u00BB\u00D0\u00B0\u00D0\u00B2\u00D0\u00BD\u00D0\u00B0\u00D1\u008F\u00D0\u00B8\u00D1\u0081\u00D1\u0082\u00D0\u00BE\u00D1\u0080\u00D0\u00B8\u00D0\u00B8\u00D1\u0081\u00D0\u00B8\u00D1\u0081\u00D1\u0082\u00D0\u00B5\u00D0\u00BC\u00D0\u00B0\u00D1\u0080\u00D0\u00B5\u00D1\u0088\u00D0\u00B5\u00D0\u00BD\u00D0\u00B8\u00D1\u008F\u00D0\u00A1\u00D0\u00BA\u00D0\u00B0\u00D1\u0087\u00D0\u00B0\u00D1\u0082\u00D1\u008C\u00D0\u00BF\u00D0\u00BE\u00D1\u008D\u00D1\u0082\u00D0\u00BE\u00D0\u00BC\u00D1\u0083\u00D1\u0081\u00D0\u00BB\u00D0\u00B5\u00D0\u00B4\u00D1\u0083\u00D0\u00B5\u00D1\u0082\u00D1\u0081\u00D0\u00BA\u00D0\u00B0\u00D0\u00B7\u00D0\u00B0\u00D1\u0082\u00D1\u008C\u00D1\u0082\u00D0\u00BE\u00D0\u00B2\u00D0\u00B0\u00D1\u0080\u00D0\u00BE\u00D0\u00B2\u00D0\u00BA\u00D0\u00BE\u00D0\u00BD\u00D0\u00B5\u00D1\u0087\u00D0\u00BD\u00D0\u00BE\u00D1\u0080\u00D0\u00B5\u00D1\u0088\u00D0\u00B5\u00D0\u00BD\u00D0\u00B8\u00D0\u00B5\u00D0\u00BA\u00D0\u00BE\u00D1\u0082\u00D0\u00BE\u00D1\u0080\u00D0\u00BE\u00D0\u00B5\u00D0\u00BE\u00D1\u0080\u00D0\u00B3\u00D0\u00B0\u00D0\u00BD\u00D0\u00BE\u00D0\u00B2\u00D0\u00BA\u00D0\u00BE\u00D1\u0082\u00D0\u00BE\u00D1\u0080\u00D0\u00BE\u00D0\u00BC\u00D0\u00A0\u00D0\u00B5\u00D0\u00BA\u00D0\u00BB\u00D0\u00B0\u00D0\u00BC\u00D0\u00B0\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D9\u0086\u00D8\u00AA\u00D8\u00AF\u00D9\u0089\u00D9\u0085\u00D9\u0086\u00D8\u00AA\u00D8\u00AF\u00D9\u008A\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D9\u0088\u00D8\u00B6\u00D9\u0088\u00D8\u00B9\u00D8\u00A7\u00D9\u0084\u00D8\u00A8\u00D8\u00B1\u00D8\u00A7\u00D9\u0085\u00D8\u00AC\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D9\u0088\u00D8\u00A7\u00D9\u0082\u00D8\u00B9\u00D8\u00A7\u00D9\u0084\u00D8\u00B1\u00D8\u00B3\u00D8\u00A7\u00D8\u00A6\u00D9\u0084\u00D9\u0085\u00D8\u00B4\u00D8\u00A7\u00D8\u00B1\u00D9\u0083\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D8\u00A3\u00D8\u00B9\u00D8\u00B6\u00D8\u00A7\u00D8\u00A1\u00D8\u00A7\u00D9\u0084\u00D8\u00B1\u00D9\u008A\u00D8\u00A7\u00D8\u00B6\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00AA\u00D8\u00B5\u00D9\u0085\u00D9\u008A\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D8\u00B9\u00D8\u00B6\u00D8\u00A7\u00D8\u00A1\u00D8\u00A7\u00D9\u0084\u00D9\u0086\u00D8\u00AA\u00D8\u00A7\u00D8\u00A6\u00D8\u00AC\u00D8\u00A7\u00D9\u0084\u00D8\u00A3\u00D9\u0084\u00D8\u00B9\u00D8\u00A7\u00D8\u00A8\u00D8\u00A7\u00D9\u0084\u00D8\u00AA\u00D8\u00B3\u00D8\u00AC\u00D9\u008A\u00D9\u0084\u00D8\u00A7\u00D9\u0084\u00D8\u00A3\u00D9\u0082\u00D8\u00B3\u00D8\u00A7\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D8\u00B6\u00D8\u00BA\u00D8\u00B7\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D9\u0081\u00D9\u008A\u00D8\u00AF\u00D9\u008A\u00D9\u0088\u00D8\u00A7\u00D9\u0084\u00D8\u00AA\u00D8\u00B1\u00D8\u00AD\u00D9\u008A\u00D8\u00A8\u00D8\u00A7\u00D9\u0084\u00D8\u00AC\u00D8\u00AF\u00D9\u008A\u00D8\u00AF\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00AA\u00D8\u00B9\u00D9\u0084\u00D9\u008A\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D8\u00A3\u00D8\u00AE\u00D8\u00A8\u00D8\u00A7\u00D8\u00B1\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D9\u0081\u00D9\u0084\u00D8\u00A7\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D8\u00A3\u00D9\u0081\u00D9\u0084\u00D8\u00A7\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D8\u00AA\u00D8\u00A7\u00D8\u00B1\u00D9\u008A\u00D8\u00AE\u00D8\u00A7\u00D9\u0084\u00D8\u00AA\u00D9\u0082\u00D9\u0086\u00D9\u008A\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D8\u00A7\u00D8\u00A8\u00D8\u00A7\u00D9\u0084\u00D8\u00AE\u00D9\u0088\u00D8\u00A7\u00D8\u00B7\u00D8\u00B1\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00AC\u00D8\u00AA\u00D9\u0085\u00D8\u00B9\u00D8\u00A7\u00D9\u0084\u00D8\u00AF\u00D9\u008A\u00D9\u0083\u00D9\u0088\u00D8\u00B1\u00D8\u00A7\u00D9\u0084\u00D8\u00B3\u00D9\u008A\u00D8\u00A7\u00D8\u00AD\u00D8\u00A9\u00D8\u00B9\u00D8\u00A8\u00D8\u00AF\u00D8\u00A7\u00D9\u0084\u00D9\u0084\u00D9\u0087\u00D8\u00A7\u00D9\u0084\u00D8\u00AA\u00D8\u00B1\u00D8\u00A8\u00D9\u008A\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00B1\u00D9\u0088\u00D8\u00A7\u00D8\u00A8\u00D8\u00B7\u00D8\u00A7\u00D9\u0084\u00D8\u00A3\u00D8\u00AF\u00D8\u00A8\u00D9\u008A\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D8\u00AE\u00D8\u00A8\u00D8\u00A7\u00D8\u00B1\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00AA\u00D8\u00AD\u00D8\u00AF\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D8\u00BA\u00D8\u00A7\u00D9\u0086\u00D9\u008Acursor:pointer;</title>\n<meta \" href=\"http://\"><span class=\"members of the window.locationvertical-align:/a> | <a href=\"<!doctype html>media=\"screen\" <option value=\"favicon.ico\" />\n\t\t<div class=\"characteristics\" method=\"get\" /body>\n</html>\nshortcut icon\" document.write(padding-bottom:representativessubmit\" value=\"align=\"center\" throughout the science fiction\n  <div class=\"submit\" class=\"one of the most valign=\"top\"><was established);\r\n</script>\r\nreturn false;\">).style.displaybecause of the document.cookie<form action=\"/}body{margin:0;Encyclopedia ofversion of the .createElement(name\" content=\"</div>\n</div>\n\nadministrative </body>\n</html>history of the \"><input type=\"portion of the as part of the &nbsp;<a href=\"other countries\">\n<div class=\"</span></span><In other words,display: block;control of the introduction of/>\n<meta name=\"as well as the in recent years\r\n\t<div class=\"</div>\n\t</div>\ninspired by thethe end of the compatible withbecame known as style=\"margin:.js\"></script>< International there have beenGerman language style=\"color:#Communist Partyconsistent withborder=\"0\" cell marginheight=\"the majority of\" align=\"centerrelated to the many different Orthodox Churchsimilar to the />\n<link rel=\"swas one of the until his death})();\n</script>other languagescompared to theportions of thethe Netherlandsthe most commonbackground:url(argued that thescrolling=\"no\" included in theNorth American the name of theinterpretationsthe traditionaldevelopment of frequently useda collection ofvery similar tosurrounding theexample of thisalign=\"center\">would have beenimage_caption =attached to thesuggesting thatin the form of involved in theis derived fromnamed after theIntroduction torestrictions on style=\"width: can be used to the creation ofmost important information andresulted in thecollapse of theThis means thatelements of thewas replaced byanalysis of theinspiration forregarded as themost successfulknown as &quot;a comprehensiveHistory of the were consideredreturned to theare referred toUnsourced image>\n\t<div class=\"consists of thestopPropagationinterest in theavailability ofappears to haveelectromagneticenableServices(function of theIt is important</script></div>function(){var relative to theas a result of the position ofFor example, in method=\"post\" was followed by&amp;mdash; thethe applicationjs\"></script>\r\nul></div></div>after the deathwith respect tostyle=\"padding:is particularlydisplay:inline; type=\"submit\" is divided into\u00E4\u00B8\u00AD\u00E6\u0096\u0087 (\u00E7\u00AE\u0080\u00E4\u00BD\u0093)responsabilidadadministraci\u00C3\u00B3ninternacionalescorrespondiente\u00E0\u00A4\u0089\u00E0\u00A4\u00AA\u00E0\u00A4\u00AF\u00E0\u00A5\u008B\u00E0\u00A4\u0097\u00E0\u00A4\u00AA\u00E0\u00A5\u0082\u00E0\u00A4\u00B0\u00E0\u00A5\u008D\u00E0\u00A4\u00B5\u00E0\u00A4\u00B9\u00E0\u00A4\u00AE\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A5\u0087\u00E0\u00A4\u00B2\u00E0\u00A5\u008B\u00E0\u00A4\u0097\u00E0\u00A5\u008B\u00E0\u00A4\u0082\u00E0\u00A4\u009A\u00E0\u00A5\u0081\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00B5\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u0095\u00E0\u00A4\u00BF\u00E0\u00A4\u00A8\u00E0\u00A4\u00B8\u00E0\u00A4\u00B0\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00AA\u00E0\u00A5\u0081\u00E0\u00A4\u00B2\u00E0\u00A4\u00BF\u00E0\u00A4\u00B8\u00E0\u00A4\u0096\u00E0\u00A5\u008B\u00E0\u00A4\u009C\u00E0\u00A5\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u009A\u00E0\u00A4\u00BE\u00E0\u00A4\u00B9\u00E0\u00A4\u00BF\u00E0\u00A4\u008F\u00E0\u00A4\u00AD\u00E0\u00A5\u0087\u00E0\u00A4\u009C\u00E0\u00A5\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u00B6\u00E0\u00A4\u00BE\u00E0\u00A4\u00AE\u00E0\u00A4\u00BF\u00E0\u00A4\u00B2\u00E0\u00A4\u00B9\u00E0\u00A4\u00AE\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A5\u0080\u00E0\u00A4\u009C\u00E0\u00A4\u00BE\u00E0\u00A4\u0097\u00E0\u00A4\u00B0\u00E0\u00A4\u00A3\u00E0\u00A4\u00AC\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u0095\u00E0\u00A5\u0081\u00E0\u00A4\u00AE\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00AC\u00E0\u00A5\u008D\u00E0\u00A4\u00B2\u00E0\u00A5\u0089\u00E0\u00A4\u0097\u00E0\u00A4\u00AE\u00E0\u00A4\u00BE\u00E0\u00A4\u00B2\u00E0\u00A4\u00BF\u00E0\u00A4\u0095\u00E0\u00A4\u00AE\u00E0\u00A4\u00B9\u00E0\u00A4\u00BF\u00E0\u00A4\u00B2\u00E0\u00A4\u00BE\u00E0\u00A4\u00AA\u00E0\u00A5\u0083\u00E0\u00A4\u00B7\u00E0\u00A5\u008D\u00E0\u00A4\u00A0\u00E0\u00A4\u00AC\u00E0\u00A4\u00A2\u00E0\u00A4\u00BC\u00E0\u00A4\u00A4\u00E0\u00A5\u0087\u00E0\u00A4\u00AD\u00E0\u00A4\u00BE\u00E0\u00A4\u009C\u00E0\u00A4\u00AA\u00E0\u00A4\u00BE\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00B2\u00E0\u00A4\u00BF\u00E0\u00A4\u0095\u00E0\u00A4\u009F\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A5\u0087\u00E0\u00A4\u00A8\u00E0\u00A4\u0096\u00E0\u00A4\u00BF\u00E0\u00A4\u00B2\u00E0\u00A4\u00BE\u00E0\u00A4\u00AB\u00E0\u00A4\u00A6\u00E0\u00A5\u008C\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A4\u00AE\u00E0\u00A4\u00BE\u00E0\u00A4\u00AE\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u00AE\u00E0\u00A4\u00A4\u00E0\u00A4\u00A6\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A4\u00AC\u00E0\u00A4\u00BE\u00E0\u00A4\u009C\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00B5\u00E0\u00A4\u00BF\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00AF\u00E0\u00A5\u008B\u00E0\u00A4\u0082\u00E0\u00A4\u009A\u00E0\u00A4\u00BE\u00E0\u00A4\u00B9\u00E0\u00A4\u00A4\u00E0\u00A5\u0087\u00E0\u00A4\u00AA\u00E0\u00A4\u00B9\u00E0\u00A5\u0081\u00E0\u00A4\u0081\u00E0\u00A4\u009A\u00E0\u00A4\u00AC\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A4\u0082\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u00A6\u00E0\u00A4\u00A6\u00E0\u00A5\u0087\u00E0\u00A4\u0096\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u00AA\u00E0\u00A4\u00BF\u00E0\u00A4\u009B\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u00B5\u00E0\u00A4\u00BF\u00E0\u00A4\u00B6\u00E0\u00A5\u0087\u00E0\u00A4\u00B7\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u009C\u00E0\u00A5\u008D\u00E0\u00A4\u00AF\u00E0\u00A4\u0089\u00E0\u00A4\u00A4\u00E0\u00A5\u008D\u00E0\u00A4\u00A4\u00E0\u00A4\u00B0\u00E0\u00A4\u00AE\u00E0\u00A5\u0081\u00E0\u00A4\u0082\u00E0\u00A4\u00AC\u00E0\u00A4\u0088\u00E0\u00A4\u00A6\u00E0\u00A5\u008B\u00E0\u00A4\u00A8\u00E0\u00A5\u008B\u00E0\u00A4\u0082\u00E0\u00A4\u0089\u00E0\u00A4\u00AA\u00E0\u00A4\u0095\u00E0\u00A4\u00B0\u00E0\u00A4\u00A3\u00E0\u00A4\u00AA\u00E0\u00A4\u00A2\u00E0\u00A4\u00BC\u00E0\u00A5\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u00B8\u00E0\u00A5\u008D\u00E0\u00A4\u00A5\u00E0\u00A4\u00BF\u00E0\u00A4\u00A4\u00E0\u00A4\u00AB\u00E0\u00A4\u00BF\u00E0\u00A4\u00B2\u00E0\u00A5\u008D\u00E0\u00A4\u00AE\u00E0\u00A4\u00AE\u00E0\u00A5\u0081\u00E0\u00A4\u0096\u00E0\u00A5\u008D\u00E0\u00A4\u00AF\u00E0\u00A4\u0085\u00E0\u00A4\u009A\u00E0\u00A5\u008D\u00E0\u00A4\u009B\u00E0\u00A4\u00BE\u00E0\u00A4\u009B\u00E0\u00A5\u0082\u00E0\u00A4\u009F\u00E0\u00A4\u00A4\u00E0\u00A5\u0080\u00E0\u00A4\u00B8\u00E0\u00A4\u0082\u00E0\u00A4\u0097\u00E0\u00A5\u0080\u00E0\u00A4\u00A4\u00E0\u00A4\u009C\u00E0\u00A4\u00BE\u00E0\u00A4\u008F\u00E0\u00A4\u0097\u00E0\u00A4\u00BE\u00E0\u00A4\u00B5\u00E0\u00A4\u00BF\u00E0\u00A4\u00AD\u00E0\u00A4\u00BE\u00E0\u00A4\u0097\u00E0\u00A4\u0098\u00E0\u00A4\u00A3\u00E0\u00A5\u008D\u00E0\u00A4\u009F\u00E0\u00A5\u0087\u00E0\u00A4\u00A6\u00E0\u00A5\u0082\u00E0\u00A4\u00B8\u00E0\u00A4\u00B0\u00E0\u00A5\u0087\u00E0\u00A4\u00A6\u00E0\u00A4\u00BF\u00E0\u00A4\u00A8\u00E0\u00A5\u008B\u00E0\u00A4\u0082\u00E0\u00A4\u00B9\u00E0\u00A4\u00A4\u00E0\u00A5\u008D\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A5\u0087\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00B8\u00E0\u00A4\u0097\u00E0\u00A4\u00BE\u00E0\u00A4\u0082\u00E0\u00A4\u00A7\u00E0\u00A5\u0080\u00E0\u00A4\u00B5\u00E0\u00A4\u00BF\u00E0\u00A4\u00B6\u00E0\u00A5\u008D\u00E0\u00A4\u00B5\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u00A4\u00E0\u00A5\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u00A6\u00E0\u00A5\u0088\u00E0\u00A4\u009F\u00E0\u00A5\u008D\u00E0\u00A4\u00B8\u00E0\u00A4\u00A8\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00B6\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A4\u00BE\u00E0\u00A4\u00AE\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u0085\u00E0\u00A4\u00A6\u00E0\u00A4\u00BE\u00E0\u00A4\u00B2\u00E0\u00A4\u00A4\u00E0\u00A4\u00AC\u00E0\u00A4\u00BF\u00E0\u00A4\u009C\u00E0\u00A4\u00B2\u00E0\u00A5\u0080\u00E0\u00A4\u00AA\u00E0\u00A5\u0081\u00E0\u00A4\u00B0\u00E0\u00A5\u0082\u00E0\u00A4\u00B7\u00E0\u00A4\u00B9\u00E0\u00A4\u00BF\u00E0\u00A4\u0082\u00E0\u00A4\u00A6\u00E0\u00A5\u0080\u00E0\u00A4\u00AE\u00E0\u00A4\u00BF\u00E0\u00A4\u00A4\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u0095\u00E0\u00A4\u00B5\u00E0\u00A4\u00BF\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A5\u0081\u00E0\u00A4\u00AA\u00E0\u00A4\u00AF\u00E0\u00A5\u0087\u00E0\u00A4\u00B8\u00E0\u00A5\u008D\u00E0\u00A4\u00A5\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A4\u0095\u00E0\u00A4\u00B0\u00E0\u00A5\u008B\u00E0\u00A4\u00A1\u00E0\u00A4\u00BC\u00E0\u00A4\u00AE\u00E0\u00A5\u0081\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00A4\u00E0\u00A4\u00AF\u00E0\u00A5\u008B\u00E0\u00A4\u009C\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u0095\u00E0\u00A5\u0083\u00E0\u00A4\u00AA\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00AA\u00E0\u00A5\u008B\u00E0\u00A4\u00B8\u00E0\u00A5\u008D\u00E0\u00A4\u009F\u00E0\u00A4\u0098\u00E0\u00A4\u00B0\u00E0\u00A5\u0087\u00E0\u00A4\u00B2\u00E0\u00A5\u0082\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A5\u008D\u00E0\u00A4\u00AF\u00E0\u00A4\u00B5\u00E0\u00A4\u00BF\u00E0\u00A4\u009A\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00B8\u00E0\u00A5\u0082\u00E0\u00A4\u009A\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00AE\u00E0\u00A5\u0082\u00E0\u00A4\u00B2\u00E0\u00A5\u008D\u00E0\u00A4\u00AF\u00E0\u00A4\u00A6\u00E0\u00A5\u0087\u00E0\u00A4\u0096\u00E0\u00A5\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u00B9\u00E0\u00A4\u00AE\u00E0\u00A5\u0087\u00E0\u00A4\u00B6\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A5\u008D\u00E0\u00A4\u0095\u00E0\u00A5\u0082\u00E0\u00A4\u00B2\u00E0\u00A4\u00AE\u00E0\u00A5\u0088\u00E0\u00A4\u0082\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u00A4\u00E0\u00A5\u0088\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u009C\u00E0\u00A4\u00BF\u00E0\u00A4\u00B8\u00E0\u00A4\u0095\u00E0\u00A5\u0087rss+xml\" title=\"-type\" content=\"title\" content=\"at the same time.js\"></script>\n<\" method=\"post\" </span></a></li>vertical-align:t/jquery.min.js\">.click(function( style=\"padding-})();\n</script>\n</span><a href=\"<a href=\"http://); return false;text-decoration: scrolling=\"no\" border-collapse:associated with Bahasa IndonesiaEnglish language<text xml:space=.gif\" border=\"0\"</body>\n</html>\noverflow:hidden;img src=\"http://addEventListenerresponsible for s.js\"></script>\n/favicon.ico\" />operating system\" style=\"width:1target=\"_blank\">State Universitytext-align:left;\ndocument.write(, including the around the world);\r\n</script>\r\n<\" style=\"height:;overflow:hiddenmore informationan internationala member of the one of the firstcan be found in </div>\n\t\t</div>\ndisplay: none;\">\" />\n<link rel=\"\n  (function() {the 15th century.preventDefault(large number of Byzantine Empire.jpg|thumb|left|vast majority ofmajority of the  align=\"center\">University Pressdominated by theSecond World Wardistribution of style=\"position:the rest of the characterized by rel=\"nofollow\">derives from therather than the a combination ofstyle=\"width:100English-speakingcomputer scienceborder=\"0\" alt=\"the existence ofDemocratic Party\" style=\"margin-For this reason,.js\"></script>\n\tsByTagName(s)[0]js\"></script>\r\n<.js\"></script>\r\nlink rel=\"icon\" ' alt='' class='formation of theversions of the </a></div></div>/page>\n  <page>\n<div class=\"contbecame the firstbahasa Indonesiaenglish (simple)\u00CE\u0095\u00CE\u00BB\u00CE\u00BB\u00CE\u00B7\u00CE\u00BD\u00CE\u00B9\u00CE\u00BA\u00CE\u00AC\u00D1\u0085\u00D1\u0080\u00D0\u00B2\u00D0\u00B0\u00D1\u0082\u00D1\u0081\u00D0\u00BA\u00D0\u00B8\u00D0\u00BA\u00D0\u00BE\u00D0\u00BC\u00D0\u00BF\u00D0\u00B0\u00D0\u00BD\u00D0\u00B8\u00D0\u00B8\u00D1\u008F\u00D0\u00B2\u00D0\u00BB\u00D1\u008F\u00D0\u00B5\u00D1\u0082\u00D1\u0081\u00D1\u008F\u00D0\u0094\u00D0\u00BE\u00D0\u00B1\u00D0\u00B0\u00D0\u00B2\u00D0\u00B8\u00D1\u0082\u00D1\u008C\u00D1\u0087\u00D0\u00B5\u00D0\u00BB\u00D0\u00BE\u00D0\u00B2\u00D0\u00B5\u00D0\u00BA\u00D0\u00B0\u00D1\u0080\u00D0\u00B0\u00D0\u00B7\u00D0\u00B2\u00D0\u00B8\u00D1\u0082\u00D0\u00B8\u00D1\u008F\u00D0\u0098\u00D0\u00BD\u00D1\u0082\u00D0\u00B5\u00D1\u0080\u00D0\u00BD\u00D0\u00B5\u00D1\u0082\u00D0\u009E\u00D1\u0082\u00D0\u00B2\u00D0\u00B5\u00D1\u0082\u00D0\u00B8\u00D1\u0082\u00D1\u008C\u00D0\u00BD\u00D0\u00B0\u00D0\u00BF\u00D1\u0080\u00D0\u00B8\u00D0\u00BC\u00D0\u00B5\u00D1\u0080\u00D0\u00B8\u00D0\u00BD\u00D1\u0082\u00D0\u00B5\u00D1\u0080\u00D0\u00BD\u00D0\u00B5\u00D1\u0082\u00D0\u00BA\u00D0\u00BE\u00D1\u0082\u00D0\u00BE\u00D1\u0080\u00D0\u00BE\u00D0\u00B3\u00D0\u00BE\u00D1\u0081\u00D1\u0082\u00D1\u0080\u00D0\u00B0\u00D0\u00BD\u00D0\u00B8\u00D1\u0086\u00D1\u008B\u00D0\u00BA\u00D0\u00B0\u00D1\u0087\u00D0\u00B5\u00D1\u0081\u00D1\u0082\u00D0\u00B2\u00D0\u00B5\u00D1\u0083\u00D1\u0081\u00D0\u00BB\u00D0\u00BE\u00D0\u00B2\u00D0\u00B8\u00D1\u008F\u00D1\u0085\u00D0\u00BF\u00D1\u0080\u00D0\u00BE\u00D0\u00B1\u00D0\u00BB\u00D0\u00B5\u00D0\u00BC\u00D1\u008B\u00D0\u00BF\u00D0\u00BE\u00D0\u00BB\u00D1\u0083\u00D1\u0087\u00D0\u00B8\u00D1\u0082\u00D1\u008C\u00D1\u008F\u00D0\u00B2\u00D0\u00BB\u00D1\u008F\u00D1\u008E\u00D1\u0082\u00D1\u0081\u00D1\u008F\u00D0\u00BD\u00D0\u00B0\u00D0\u00B8\u00D0\u00B1\u00D0\u00BE\u00D0\u00BB\u00D0\u00B5\u00D0\u00B5\u00D0\u00BA\u00D0\u00BE\u00D0\u00BC\u00D0\u00BF\u00D0\u00B0\u00D0\u00BD\u00D0\u00B8\u00D1\u008F\u00D0\u00B2\u00D0\u00BD\u00D0\u00B8\u00D0\u00BC\u00D0\u00B0\u00D0\u00BD\u00D0\u00B8\u00D0\u00B5\u00D1\u0081\u00D1\u0080\u00D0\u00B5\u00D0\u00B4\u00D1\u0081\u00D1\u0082\u00D0\u00B2\u00D0\u00B0\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D9\u0088\u00D8\u00A7\u00D8\u00B6\u00D9\u008A\u00D8\u00B9\u00D8\u00A7\u00D9\u0084\u00D8\u00B1\u00D8\u00A6\u00D9\u008A\u00D8\u00B3\u00D9\u008A\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D9\u0086\u00D8\u00AA\u00D9\u0082\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00B4\u00D8\u00A7\u00D8\u00B1\u00D9\u0083\u00D8\u00A7\u00D8\u00AA\u00D9\u0083\u00D8\u00A7\u00D9\u0084\u00D8\u00B3\u00D9\u008A\u00D8\u00A7\u00D8\u00B1\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D9\u0083\u00D8\u00AA\u00D9\u0088\u00D8\u00A8\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00B3\u00D8\u00B9\u00D9\u0088\u00D8\u00AF\u00D9\u008A\u00D8\u00A9\u00D8\u00A7\u00D8\u00AD\u00D8\u00B5\u00D8\u00A7\u00D8\u00A6\u00D9\u008A\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D8\u00B9\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D9\u008A\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00B5\u00D9\u0088\u00D8\u00AA\u00D9\u008A\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D9\u0086\u00D8\u00AA\u00D8\u00B1\u00D9\u0086\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D8\u00AA\u00D8\u00B5\u00D8\u00A7\u00D9\u0085\u00D9\u008A\u00D9\u0085\u00D8\u00A7\u00D9\u0084\u00D8\u00A5\u00D8\u00B3\u00D9\u0084\u00D8\u00A7\u00D9\u0085\u00D9\u008A\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00B4\u00D8\u00A7\u00D8\u00B1\u00D9\u0083\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00B1\u00D8\u00A6\u00D9\u008A\u00D8\u00A7\u00D8\u00AArobots\" content=\"<div id=\"footer\">the United States<img src=\"http://.jpg|right|thumb|.js\"></script>\r\n<location.protocolframeborder=\"0\" s\" />\n<meta name=\"</a></div></div><font-weight:bold;&quot; and &quot;depending on the margin:0;padding:\" rel=\"nofollow\" President of the twentieth centuryevision>\n  </pageInternet Explorera.async = true;\r\ninformation about<div id=\"header\">\" action=\"http://<a href=\"https://<div id=\"content\"</div>\r\n</div>\r\n<derived from the <img src='http://according to the \n</body>\n</html>\nstyle=\"font-size:script language=\"Arial, Helvetica,</a><span class=\"</script><script political partiestd></tr></table><href=\"http://www.interpretation ofrel=\"stylesheet\" document.write('<charset=\"utf-8\">\nbeginning of the revealed that thetelevision series\" rel=\"nofollow\"> target=\"_blank\">claiming that thehttp%3A%2F%2Fwww.manifestations ofPrime Minister ofinfluenced by theclass=\"clearfix\">/div>\r\n</div>\r\n\r\nthree-dimensionalChurch of Englandof North Carolinasquare kilometres.addEventListenerdistinct from thecommonly known asPhonetic Alphabetdeclared that thecontrolled by theBenjamin Franklinrole-playing gamethe University ofin Western Europepersonal computerProject Gutenbergregardless of thehas been proposedtogether with the></li><li class=\"in some countriesmin.js\"></script>of the populationofficial language<img src=\"images/identified by thenatural resourcesclassification ofcan be consideredquantum mechanicsNevertheless, themillion years ago</body>\r\n</html>\r\u00CE\u0095\u00CE\u00BB\u00CE\u00BB\u00CE\u00B7\u00CE\u00BD\u00CE\u00B9\u00CE\u00BA\u00CE\u00AC\ntake advantage ofand, according toattributed to theMicrosoft Windowsthe first centuryunder the controldiv class=\"headershortly after thenotable exceptiontens of thousandsseveral differentaround the world.reaching militaryisolated from theopposition to thethe Old TestamentAfrican Americansinserted into theseparate from themetropolitan areamakes it possibleacknowledged thatarguably the mosttype=\"text/css\">\nthe InternationalAccording to the pe=\"text/css\" />\ncoincide with thetwo-thirds of theDuring this time,during the periodannounced that hethe internationaland more recentlybelieved that theconsciousness andformerly known assurrounded by thefirst appeared inoccasionally usedposition:absolute;\" target=\"_blank\" position:relative;text-align:center;jax/libs/jquery/1.background-color:#type=\"application/anguage\" content=\"<meta http-equiv=\"Privacy Policy</a>e(\"%3Cscript src='\" target=\"_blank\">On the other hand,.jpg|thumb|right|2</div><div class=\"<div style=\"float:nineteenth century</body>\r\n</html>\r\n<img src=\"http://s;text-align:centerfont-weight: bold; According to the difference between\" frameborder=\"0\" \" style=\"position:link href=\"http://html4/loose.dtd\">\nduring this period</td></tr></table>closely related tofor the first time;font-weight:bold;input type=\"text\" <span style=\"font-onreadystatechange\t<div class=\"cleardocument.location. For example, the a wide variety of <!DOCTYPE html>\r\n<&nbsp;&nbsp;&nbsp;\"><a href=\"http://style=\"float:left;concerned with the=http%3A%2F%2Fwww.in popular culturetype=\"text/css\" />it is possible to Harvard Universitytylesheet\" href=\"/the main characterOxford University  name=\"keywords\" cstyle=\"text-align:the United Kingdomfederal government<div style=\"margin depending on the description of the<div class=\"header.min.js\"></script>destruction of theslightly differentin accordance withtelecommunicationsindicates that theshortly thereafterespecially in the European countriesHowever, there aresrc=\"http://staticsuggested that the\" src=\"http://www.a large number of Telecommunications\" rel=\"nofollow\" tHoly Roman Emperoralmost exclusively\" border=\"0\" alt=\"Secretary of Stateculminating in theCIA World Factbookthe most importantanniversary of thestyle=\"background-<li><em><a href=\"/the Atlantic Oceanstrictly speaking,shortly before thedifferent types ofthe Ottoman Empire><img src=\"http://An Introduction toconsequence of thedeparture from theConfederate Statesindigenous peoplesProceedings of theinformation on thetheories have beeninvolvement in thedivided into threeadjacent countriesis responsible fordissolution of thecollaboration withwidely regarded ashis contemporariesfounding member ofDominican Republicgenerally acceptedthe possibility ofare also availableunder constructionrestoration of thethe general publicis almost entirelypasses through thehas been suggestedcomputer and videoGermanic languages according to the different from theshortly afterwardshref=\"https://www.recent developmentBoard of Directors<div class=\"search| <a href=\"http://In particular, theMultiple footnotesor other substancethousands of yearstranslation of the</div>\r\n</div>\r\n\r\n<a href=\"index.phpwas established inmin.js\"></script>\nparticipate in thea strong influencestyle=\"margin-top:represented by thegraduated from theTraditionally, theElement(\"script\");However, since the/div>\n</div>\n<div left; margin-left:protection against0; vertical-align:Unfortunately, thetype=\"image/x-icon/div>\n<div class=\" class=\"clearfix\"><div class=\"footer\t\t</div>\n\t\t</div>\nthe motion picture\u00D0\u0091\u00D1\u008A\u00D0\u00BB\u00D0\u00B3\u00D0\u00B0\u00D1\u0080\u00D1\u0081\u00D0\u00BA\u00D0\u00B8\u00D0\u00B1\u00D1\u008A\u00D0\u00BB\u00D0\u00B3\u00D0\u00B0\u00D1\u0080\u00D1\u0081\u00D0\u00BA\u00D0\u00B8\u00D0\u00A4\u00D0\u00B5\u00D0\u00B4\u00D0\u00B5\u00D1\u0080\u00D0\u00B0\u00D1\u0086\u00D0\u00B8\u00D0\u00B8\u00D0\u00BD\u00D0\u00B5\u00D1\u0081\u00D0\u00BA\u00D0\u00BE\u00D0\u00BB\u00D1\u008C\u00D0\u00BA\u00D0\u00BE\u00D1\u0081\u00D0\u00BE\u00D0\u00BE\u00D0\u00B1\u00D1\u0089\u00D0\u00B5\u00D0\u00BD\u00D0\u00B8\u00D0\u00B5\u00D1\u0081\u00D0\u00BE\u00D0\u00BE\u00D0\u00B1\u00D1\u0089\u00D0\u00B5\u00D0\u00BD\u00D0\u00B8\u00D1\u008F\u00D0\u00BF\u00D1\u0080\u00D0\u00BE\u00D0\u00B3\u00D1\u0080\u00D0\u00B0\u00D0\u00BC\u00D0\u00BC\u00D1\u008B\u00D0\u009E\u00D1\u0082\u00D0\u00BF\u00D1\u0080\u00D0\u00B0\u00D0\u00B2\u00D0\u00B8\u00D1\u0082\u00D1\u008C\u00D0\u00B1\u00D0\u00B5\u00D1\u0081\u00D0\u00BF\u00D0\u00BB\u00D0\u00B0\u00D1\u0082\u00D0\u00BD\u00D0\u00BE\u00D0\u00BC\u00D0\u00B0\u00D1\u0082\u00D0\u00B5\u00D1\u0080\u00D0\u00B8\u00D0\u00B0\u00D0\u00BB\u00D1\u008B\u00D0\u00BF\u00D0\u00BE\u00D0\u00B7\u00D0\u00B2\u00D0\u00BE\u00D0\u00BB\u00D1\u008F\u00D0\u00B5\u00D1\u0082\u00D0\u00BF\u00D0\u00BE\u00D1\u0081\u00D0\u00BB\u00D0\u00B5\u00D0\u00B4\u00D0\u00BD\u00D0\u00B8\u00D0\u00B5\u00D1\u0080\u00D0\u00B0\u00D0\u00B7\u00D0\u00BB\u00D0\u00B8\u00D1\u0087\u00D0\u00BD\u00D1\u008B\u00D1\u0085\u00D0\u00BF\u00D1\u0080\u00D0\u00BE\u00D0\u00B4\u00D1\u0083\u00D0\u00BA\u00D1\u0086\u00D0\u00B8\u00D0\u00B8\u00D0\u00BF\u00D1\u0080\u00D0\u00BE\u00D0\u00B3\u00D1\u0080\u00D0\u00B0\u00D0\u00BC\u00D0\u00BC\u00D0\u00B0\u00D0\u00BF\u00D0\u00BE\u00D0\u00BB\u00D0\u00BD\u00D0\u00BE\u00D1\u0081\u00D1\u0082\u00D1\u008C\u00D1\u008E\u00D0\u00BD\u00D0\u00B0\u00D1\u0085\u00D0\u00BE\u00D0\u00B4\u00D0\u00B8\u00D1\u0082\u00D1\u0081\u00D1\u008F\u00D0\u00B8\u00D0\u00B7\u00D0\u00B1\u00D1\u0080\u00D0\u00B0\u00D0\u00BD\u00D0\u00BD\u00D0\u00BE\u00D0\u00B5\u00D0\u00BD\u00D0\u00B0\u00D1\u0081\u00D0\u00B5\u00D0\u00BB\u00D0\u00B5\u00D0\u00BD\u00D0\u00B8\u00D1\u008F\u00D0\u00B8\u00D0\u00B7\u00D0\u00BC\u00D0\u00B5\u00D0\u00BD\u00D0\u00B5\u00D0\u00BD\u00D0\u00B8\u00D1\u008F\u00D0\u00BA\u00D0\u00B0\u00D1\u0082\u00D0\u00B5\u00D0\u00B3\u00D0\u00BE\u00D1\u0080\u00D0\u00B8\u00D0\u00B8\u00D0\u0090\u00D0\u00BB\u00D0\u00B5\u00D0\u00BA\u00D1\u0081\u00D0\u00B0\u00D0\u00BD\u00D0\u00B4\u00D1\u0080\u00E0\u00A4\u00A6\u00E0\u00A5\u008D\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u00AE\u00E0\u00A5\u0088\u00E0\u00A4\u00A8\u00E0\u00A5\u0081\u00E0\u00A4\u0085\u00E0\u00A4\u00B2\u00E0\u00A4\u00AA\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00A6\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A4\u00AD\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00A4\u00E0\u00A5\u0080\u00E0\u00A4\u00AF\u00E0\u00A4\u0085\u00E0\u00A4\u00A8\u00E0\u00A5\u0081\u00E0\u00A4\u00A6\u00E0\u00A5\u0087\u00E0\u00A4\u00B6\u00E0\u00A4\u00B9\u00E0\u00A4\u00BF\u00E0\u00A4\u00A8\u00E0\u00A5\u008D\u00E0\u00A4\u00A6\u00E0\u00A5\u0080\u00E0\u00A4\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u00A1\u00E0\u00A4\u00BF\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00A6\u00E0\u00A4\u00BF\u00E0\u00A4\u00B2\u00E0\u00A5\u008D\u00E0\u00A4\u00B2\u00E0\u00A5\u0080\u00E0\u00A4\u0085\u00E0\u00A4\u00A7\u00E0\u00A4\u00BF\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00B5\u00E0\u00A5\u0080\u00E0\u00A4\u00A1\u00E0\u00A4\u00BF\u00E0\u00A4\u00AF\u00E0\u00A5\u008B\u00E0\u00A4\u009A\u00E0\u00A4\u00BF\u00E0\u00A4\u009F\u00E0\u00A5\u008D\u00E0\u00A4\u00A0\u00E0\u00A5\u0087\u00E0\u00A4\u00B8\u00E0\u00A4\u00AE\u00E0\u00A4\u00BE\u00E0\u00A4\u009A\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u009C\u00E0\u00A4\u0082\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00B6\u00E0\u00A4\u00A8\u00E0\u00A4\u00A6\u00E0\u00A5\u0081\u00E0\u00A4\u00A8\u00E0\u00A4\u00BF\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00AA\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00AF\u00E0\u00A5\u008B\u00E0\u00A4\u0097\u00E0\u00A4\u0085\u00E0\u00A4\u00A8\u00E0\u00A5\u0081\u00E0\u00A4\u00B8\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u0091\u00E0\u00A4\u00A8\u00E0\u00A4\u00B2\u00E0\u00A4\u00BE\u00E0\u00A4\u0087\u00E0\u00A4\u00A8\u00E0\u00A4\u00AA\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A5\u008D\u00E0\u00A4\u009F\u00E0\u00A5\u0080\u00E0\u00A4\u00B6\u00E0\u00A4\u00B0\u00E0\u00A5\u008D\u00E0\u00A4\u00A4\u00E0\u00A5\u008B\u00E0\u00A4\u0082\u00E0\u00A4\u00B2\u00E0\u00A5\u008B\u00E0\u00A4\u0095\u00E0\u00A4\u00B8\u00E0\u00A4\u00AD\u00E0\u00A4\u00BE\u00E0\u00A4\u00AB\u00E0\u00A4\u00BC\u00E0\u00A5\u008D\u00E0\u00A4\u00B2\u00E0\u00A5\u0088\u00E0\u00A4\u00B6\u00E0\u00A4\u00B6\u00E0\u00A4\u00B0\u00E0\u00A5\u008D\u00E0\u00A4\u00A4\u00E0\u00A5\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u00AA\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00A6\u00E0\u00A5\u0087\u00E0\u00A4\u00B6\u00E0\u00A4\u00AA\u00E0\u00A5\u008D\u00E0\u00A4\u00B2\u00E0\u00A5\u0087\u00E0\u00A4\u00AF\u00E0\u00A4\u00B0\u00E0\u00A4\u0095\u00E0\u00A5\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u00A6\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00B8\u00E0\u00A5\u008D\u00E0\u00A4\u00A5\u00E0\u00A4\u00BF\u00E0\u00A4\u00A4\u00E0\u00A4\u00BF\u00E0\u00A4\u0089\u00E0\u00A4\u00A4\u00E0\u00A5\u008D\u00E0\u00A4\u00AA\u00E0\u00A4\u00BE\u00E0\u00A4\u00A6\u00E0\u00A4\u0089\u00E0\u00A4\u00A8\u00E0\u00A5\u008D\u00E0\u00A4\u00B9\u00E0\u00A5\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u009A\u00E0\u00A4\u00BF\u00E0\u00A4\u009F\u00E0\u00A5\u008D\u00E0\u00A4\u00A0\u00E0\u00A4\u00BE\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00A4\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u009C\u00E0\u00A5\u008D\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u00A6\u00E0\u00A4\u00BE\u00E0\u00A4\u00AA\u00E0\u00A5\u0081\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u009C\u00E0\u00A5\u008B\u00E0\u00A4\u00A1\u00E0\u00A4\u00BC\u00E0\u00A5\u0087\u00E0\u00A4\u0082\u00E0\u00A4\u0085\u00E0\u00A4\u00A8\u00E0\u00A5\u0081\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u00A6\u00E0\u00A4\u00B6\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A5\u0087\u00E0\u00A4\u00A3\u00E0\u00A5\u0080\u00E0\u00A4\u00B6\u00E0\u00A4\u00BF\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00B7\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A4\u00B0\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A5\u0080\u00E0\u00A4\u00B8\u00E0\u00A4\u0082\u00E0\u00A4\u0097\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00B9\u00E0\u00A4\u00AA\u00E0\u00A4\u00B0\u00E0\u00A4\u00BF\u00E0\u00A4\u00A3\u00E0\u00A4\u00BE\u00E0\u00A4\u00AE\u00E0\u00A4\u00AC\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u0082\u00E0\u00A4\u00A1\u00E0\u00A4\u00AC\u00E0\u00A4\u009A\u00E0\u00A5\u008D\u00E0\u00A4\u009A\u00E0\u00A5\u008B\u00E0\u00A4\u0082\u00E0\u00A4\u0089\u00E0\u00A4\u00AA\u00E0\u00A4\u00B2\u00E0\u00A4\u00AC\u00E0\u00A5\u008D\u00E0\u00A4\u00A7\u00E0\u00A4\u00AE\u00E0\u00A4\u0082\u00E0\u00A4\u00A4\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A5\u0080\u00E0\u00A4\u00B8\u00E0\u00A4\u0082\u00E0\u00A4\u00AA\u00E0\u00A4\u00B0\u00E0\u00A5\u008D\u00E0\u00A4\u0095\u00E0\u00A4\u0089\u00E0\u00A4\u00AE\u00E0\u00A5\u008D\u00E0\u00A4\u00AE\u00E0\u00A5\u0080\u00E0\u00A4\u00A6\u00E0\u00A4\u00AE\u00E0\u00A4\u00BE\u00E0\u00A4\u00A7\u00E0\u00A5\u008D\u00E0\u00A4\u00AF\u00E0\u00A4\u00AE\u00E0\u00A4\u00B8\u00E0\u00A4\u00B9\u00E0\u00A4\u00BE\u00E0\u00A4\u00AF\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u00B6\u00E0\u00A4\u00AC\u00E0\u00A5\u008D\u00E0\u00A4\u00A6\u00E0\u00A5\u008B\u00E0\u00A4\u0082\u00E0\u00A4\u00AE\u00E0\u00A5\u0080\u00E0\u00A4\u00A1\u00E0\u00A4\u00BF\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u0086\u00E0\u00A4\u0088\u00E0\u00A4\u00AA\u00E0\u00A5\u0080\u00E0\u00A4\u008F\u00E0\u00A4\u00B2\u00E0\u00A4\u00AE\u00E0\u00A5\u008B\u00E0\u00A4\u00AC\u00E0\u00A4\u00BE\u00E0\u00A4\u0087\u00E0\u00A4\u00B2\u00E0\u00A4\u00B8\u00E0\u00A4\u0082\u00E0\u00A4\u0096\u00E0\u00A5\u008D\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u0086\u00E0\u00A4\u00AA\u00E0\u00A4\u00B0\u00E0\u00A5\u0087\u00E0\u00A4\u00B6\u00E0\u00A4\u00A8\u00E0\u00A4\u0085\u00E0\u00A4\u00A8\u00E0\u00A5\u0081\u00E0\u00A4\u00AC\u00E0\u00A4\u0082\u00E0\u00A4\u00A7\u00E0\u00A4\u00AC\u00E0\u00A4\u00BE\u00E0\u00A4\u009C\u00E0\u00A4\u00BC\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00A8\u00E0\u00A4\u00B5\u00E0\u00A5\u0080\u00E0\u00A4\u00A8\u00E0\u00A4\u00A4\u00E0\u00A4\u00AE\u00E0\u00A4\u00AA\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00AE\u00E0\u00A5\u0081\u00E0\u00A4\u0096\u00E0\u00A4\u00AA\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00B6\u00E0\u00A5\u008D\u00E0\u00A4\u00A8\u00E0\u00A4\u00AA\u00E0\u00A4\u00B0\u00E0\u00A4\u00BF\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00A8\u00E0\u00A5\u0081\u00E0\u00A4\u0095\u00E0\u00A4\u00B8\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A4\u00B8\u00E0\u00A4\u00AE\u00E0\u00A4\u00B0\u00E0\u00A5\u008D\u00E0\u00A4\u00A5\u00E0\u00A4\u00A8\u00E0\u00A4\u0086\u00E0\u00A4\u00AF\u00E0\u00A5\u008B\u00E0\u00A4\u009C\u00E0\u00A4\u00BF\u00E0\u00A4\u00A4\u00E0\u00A4\u00B8\u00E0\u00A5\u008B\u00E0\u00A4\u00AE\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00B4\u00D8\u00A7\u00D8\u00B1\u00D9\u0083\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D9\u0086\u00D8\u00AA\u00D8\u00AF\u00D9\u008A\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D9\u0083\u00D9\u0085\u00D8\u00A8\u00D9\u008A\u00D9\u0088\u00D8\u00AA\u00D8\u00B1\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00B4\u00D8\u00A7\u00D9\u0087\u00D8\u00AF\u00D8\u00A7\u00D8\u00AA\u00D8\u00B9\u00D8\u00AF\u00D8\u00AF\u00D8\u00A7\u00D9\u0084\u00D8\u00B2\u00D9\u0088\u00D8\u00A7\u00D8\u00B1\u00D8\u00B9\u00D8\u00AF\u00D8\u00AF\u00D8\u00A7\u00D9\u0084\u00D8\u00B1\u00D8\u00AF\u00D9\u0088\u00D8\u00AF\u00D8\u00A7\u00D9\u0084\u00D8\u00A5\u00D8\u00B3\u00D9\u0084\u00D8\u00A7\u00D9\u0085\u00D9\u008A\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D9\u0081\u00D9\u0088\u00D8\u00AA\u00D9\u0088\u00D8\u00B4\u00D9\u0088\u00D8\u00A8\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00B3\u00D8\u00A7\u00D8\u00A8\u00D9\u0082\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00B9\u00D9\u0084\u00D9\u0088\u00D9\u0085\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00B3\u00D9\u0084\u00D8\u00B3\u00D9\u0084\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D8\u00AC\u00D8\u00B1\u00D8\u00A7\u00D9\u0081\u00D9\u008A\u00D9\u0083\u00D8\u00B3\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D8\u00B3\u00D9\u0084\u00D8\u00A7\u00D9\u0085\u00D9\u008A\u00D8\u00A9\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D8\u00AA\u00D8\u00B5\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D8\u00AAkeywords\" content=\"w3.org/1999/xhtml\"><a target=\"_blank\" text/html; charset=\" target=\"_blank\"><table cellpadding=\"autocomplete=\"off\" text-align: center;to last version by background-color: #\" href=\"http://www./div></div><div id=<a href=\"#\" class=\"\"><img src=\"http://cript\" src=\"http://\n<script language=\"//EN\" \"http://www.wencodeURIComponent(\" href=\"javascript:<div class=\"contentdocument.write('<scposition: absolute;script src=\"http:// style=\"margin-top:.min.js\"></script>\n</div>\n<div class=\"w3.org/1999/xhtml\" \n\r\n</body>\r\n</html>distinction between/\" target=\"_blank\"><link href=\"http://encoding=\"utf-8\"?>\nw.addEventListener?action=\"http://www.icon\" href=\"http:// style=\"background:type=\"text/css\" />\nmeta property=\"og:t<input type=\"text\"  style=\"text-align:the development of tylesheet\" type=\"tehtml; charset=utf-8is considered to betable width=\"100%\" In addition to the contributed to the differences betweendevelopment of the It is important to </script>\n\n<script  style=\"font-size:1></span><span id=gbLibrary of Congress<img src=\"http://imEnglish translationAcademy of Sciencesdiv style=\"display:construction of the.getElementById(id)in conjunction withElement('script'); <meta property=\"og:\u00D0\u0091\u00D1\u008A\u00D0\u00BB\u00D0\u00B3\u00D0\u00B0\u00D1\u0080\u00D1\u0081\u00D0\u00BA\u00D0\u00B8\n type=\"text\" name=\">Privacy Policy</a>administered by theenableSingleRequeststyle=&quot;margin:</div></div></div><><img src=\"http://i style=&quot;float:referred to as the total population ofin Washington, D.C. style=\"background-among other things,organization of theparticipated in thethe introduction ofidentified with thefictional character Oxford University misunderstanding ofThere are, however,stylesheet\" href=\"/Columbia Universityexpanded to includeusually referred toindicating that thehave suggested thataffiliated with thecorrelation betweennumber of different></td></tr></table>Republic of Ireland\n</script>\n<script under the influencecontribution to theOfficial website ofheadquarters of thecentered around theimplications of thehave been developedFederal Republic ofbecame increasinglycontinuation of theNote, however, thatsimilar to that of capabilities of theaccordance with theparticipants in thefurther developmentunder the directionis often consideredhis younger brother</td></tr></table><a http-equiv=\"X-UA-physical propertiesof British Columbiahas been criticized(with the exceptionquestions about thepassing through the0\" cellpadding=\"0\" thousands of peopleredirects here. Forhave children under%3E%3C/script%3E\"));<a href=\"http://www.<li><a href=\"http://site_name\" content=\"text-decoration:nonestyle=\"display: none<meta http-equiv=\"X-new Date().getTime() type=\"image/x-icon\"</span><span class=\"language=\"javascriptwindow.location.href<a href=\"javascript:-->\r\n<script type=\"t<a href='http://www.hortcut icon\" href=\"</div>\r\n<div class=\"<script src=\"http://\" rel=\"stylesheet\" t</div>\n<script type=/a> <a href=\"http:// allowTransparency=\"X-UA-Compatible\" conrelationship between\n</script>\r\n<script </a></li></ul></div>associated with the programming language</a><a href=\"http://</a></li><li class=\"form action=\"http://<div style=\"display:type=\"text\" name=\"q\"<table width=\"100%\" background-position:\" border=\"0\" width=\"rel=\"shortcut icon\" h6><ul><li><a href=\"  <meta http-equiv=\"css\" media=\"screen\" responsible for the \" type=\"application/\" style=\"background-html; charset=utf-8\" allowtransparency=\"stylesheet\" type=\"te\r\n<meta http-equiv=\"></span><span class=\"0\" cellspacing=\"0\">;\n</script>\n<script sometimes called thedoes not necessarilyFor more informationat the beginning of <!DOCTYPE html><htmlparticularly in the type=\"hidden\" name=\"javascript:void(0);\"effectiveness of the autocomplete=\"off\" generally considered><input type=\"text\" \"></script>\r\n<scriptthroughout the worldcommon misconceptionassociation with the</div>\n</div>\n<div cduring his lifetime,corresponding to thetype=\"image/x-icon\" an increasing numberdiplomatic relationsare often consideredmeta charset=\"utf-8\" <input type=\"text\" examples include the\"><img src=\"http://iparticipation in thethe establishment of\n</div>\n<div class=\"&amp;nbsp;&amp;nbsp;to determine whetherquite different frommarked the beginningdistance between thecontributions to theconflict between thewidely considered towas one of the firstwith varying degreeshave speculated that(document.getElementparticipating in theoriginally developedeta charset=\"utf-8\"> type=\"text/css\" />\ninterchangeably withmore closely relatedsocial and politicalthat would otherwiseperpendicular to thestyle type=\"text/csstype=\"submit\" name=\"families residing indeveloping countriescomputer programmingeconomic developmentdetermination of thefor more informationon several occasionsportugu\u00C3\u00AAs (Europeu)\u00D0\u00A3\u00D0\u00BA\u00D1\u0080\u00D0\u00B0\u00D1\u0097\u00D0\u00BD\u00D1\u0081\u00D1\u008C\u00D0\u00BA\u00D0\u00B0\u00D1\u0083\u00D0\u00BA\u00D1\u0080\u00D0\u00B0\u00D1\u0097\u00D0\u00BD\u00D1\u0081\u00D1\u008C\u00D0\u00BA\u00D0\u00B0\u00D0\u00A0\u00D0\u00BE\u00D1\u0081\u00D1\u0081\u00D0\u00B8\u00D0\u00B9\u00D1\u0081\u00D0\u00BA\u00D0\u00BE\u00D0\u00B9\u00D0\u00BC\u00D0\u00B0\u00D1\u0082\u00D0\u00B5\u00D1\u0080\u00D0\u00B8\u00D0\u00B0\u00D0\u00BB\u00D0\u00BE\u00D0\u00B2\u00D0\u00B8\u00D0\u00BD\u00D1\u0084\u00D0\u00BE\u00D1\u0080\u00D0\u00BC\u00D0\u00B0\u00D1\u0086\u00D0\u00B8\u00D0\u00B8\u00D1\u0083\u00D0\u00BF\u00D1\u0080\u00D0\u00B0\u00D0\u00B2\u00D0\u00BB\u00D0\u00B5\u00D0\u00BD\u00D0\u00B8\u00D1\u008F\u00D0\u00BD\u00D0\u00B5\u00D0\u00BE\u00D0\u00B1\u00D1\u0085\u00D0\u00BE\u00D0\u00B4\u00D0\u00B8\u00D0\u00BC\u00D0\u00BE\u00D0\u00B8\u00D0\u00BD\u00D1\u0084\u00D0\u00BE\u00D1\u0080\u00D0\u00BC\u00D0\u00B0\u00D1\u0086\u00D0\u00B8\u00D1\u008F\u00D0\u0098\u00D0\u00BD\u00D1\u0084\u00D0\u00BE\u00D1\u0080\u00D0\u00BC\u00D0\u00B0\u00D1\u0086\u00D0\u00B8\u00D1\u008F\u00D0\u00A0\u00D0\u00B5\u00D1\u0081\u00D0\u00BF\u00D1\u0083\u00D0\u00B1\u00D0\u00BB\u00D0\u00B8\u00D0\u00BA\u00D0\u00B8\u00D0\u00BA\u00D0\u00BE\u00D0\u00BB\u00D0\u00B8\u00D1\u0087\u00D0\u00B5\u00D1\u0081\u00D1\u0082\u00D0\u00B2\u00D0\u00BE\u00D0\u00B8\u00D0\u00BD\u00D1\u0084\u00D0\u00BE\u00D1\u0080\u00D0\u00BC\u00D0\u00B0\u00D1\u0086\u00D0\u00B8\u00D1\u008E\u00D1\u0082\u00D0\u00B5\u00D1\u0080\u00D1\u0080\u00D0\u00B8\u00D1\u0082\u00D0\u00BE\u00D1\u0080\u00D0\u00B8\u00D0\u00B8\u00D0\u00B4\u00D0\u00BE\u00D1\u0081\u00D1\u0082\u00D0\u00B0\u00D1\u0082\u00D0\u00BE\u00D1\u0087\u00D0\u00BD\u00D0\u00BE\u00D8\u00A7\u00D9\u0084\u00D9\u0085\u00D8\u00AA\u00D9\u0088\u00D8\u00A7\u00D8\u00AC\u00D8\u00AF\u00D9\u0088\u00D9\u0086\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D8\u00B4\u00D8\u00AA\u00D8\u00B1\u00D8\u00A7\u00D9\u0083\u00D8\u00A7\u00D8\u00AA\u00D8\u00A7\u00D9\u0084\u00D8\u00A7\u00D9\u0082\u00D8\u00AA\u00D8\u00B1\u00D8\u00A7\u00D8\u00AD\u00D8\u00A7\u00D8\u00AAhtml; charset=UTF-8\" setTimeout(function()display:inline-block;<input type=\"submit\" type = 'text/javascri<img src=\"http://www.\" \"http://www.w3.org/shortcut icon\" href=\"\" autocomplete=\"off\" </a></div><div class=</a></li>\n<li class=\"css\" type=\"text/css\" <form action=\"http://xt/css\" href=\"http://link rel=\"alternate\" \r\n<script type=\"text/ onclick=\"javascript:(new Date).getTime()}height=\"1\" width=\"1\" People's Republic of  <a href=\"http://www.text-decoration:underthe beginning of the </div>\n</div>\n</div>\nestablishment of the </div></div></div></d#viewport{min-height:\n<script src=\"http://option><option value=often referred to as /option>\n<option valu<!DOCTYPE html>\n<!--[International Airport>\n<a href=\"http://www</a><a href=\"http://w\u00E0\u00B8\u00A0\u00E0\u00B8\u00B2\u00E0\u00B8\u00A9\u00E0\u00B8\u00B2\u00E0\u00B9\u0084\u00E0\u00B8\u0097\u00E0\u00B8\u00A2\u00E1\u0083\u00A5\u00E1\u0083\u0090\u00E1\u0083\u00A0\u00E1\u0083\u0097\u00E1\u0083\u00A3\u00E1\u0083\u009A\u00E1\u0083\u0098\u00E6\u00AD\u00A3\u00E9\u00AB\u0094\u00E4\u00B8\u00AD\u00E6\u0096\u0087 (\u00E7\u00B9\u0081\u00E9\u00AB\u0094)\u00E0\u00A4\u00A8\u00E0\u00A4\u00BF\u00E0\u00A4\u00B0\u00E0\u00A5\u008D\u00E0\u00A4\u00A6\u00E0\u00A5\u0087\u00E0\u00A4\u00B6\u00E0\u00A4\u00A1\u00E0\u00A4\u00BE\u00E0\u00A4\u0089\u00E0\u00A4\u00A8\u00E0\u00A4\u00B2\u00E0\u00A5\u008B\u00E0\u00A4\u00A1\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00B7\u00E0\u00A5\u0087\u00E0\u00A4\u00A4\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u009C\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A5\u0080\u00E0\u00A4\u00B8\u00E0\u00A4\u0082\u00E0\u00A4\u00AC\u00E0\u00A4\u0082\u00E0\u00A4\u00A7\u00E0\u00A4\u00BF\u00E0\u00A4\u00A4\u00E0\u00A4\u00B8\u00E0\u00A5\u008D\u00E0\u00A4\u00A5\u00E0\u00A4\u00BE\u00E0\u00A4\u00AA\u00E0\u00A4\u00A8\u00E0\u00A4\u00BE\u00E0\u00A4\u00B8\u00E0\u00A5\u008D\u00E0\u00A4\u00B5\u00E0\u00A5\u0080\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00B8\u00E0\u00A4\u0082\u00E0\u00A4\u00B8\u00E0\u00A5\u008D\u00E0\u00A4\u0095\u00E0\u00A4\u00B0\u00E0\u00A4\u00A3\u00E0\u00A4\u00B8\u00E0\u00A4\u00BE\u00E0\u00A4\u00AE\u00E0\u00A4\u0097\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A5\u0080\u00E0\u00A4\u009A\u00E0\u00A4\u00BF\u00E0\u00A4\u009F\u00E0\u00A5\u008D\u00E0\u00A4\u00A0\u00E0\u00A5\u008B\u00E0\u00A4\u0082\u00E0\u00A4\u00B5\u00E0\u00A4\u00BF\u00E0\u00A4\u009C\u00E0\u00A5\u008D\u00E0\u00A4\u009E\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A4\u0085\u00E0\u00A4\u00AE\u00E0\u00A5\u0087\u00E0\u00A4\u00B0\u00E0\u00A4\u00BF\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00B5\u00E0\u00A4\u00BF\u00E0\u00A4\u00AD\u00E0\u00A4\u00BF\u00E0\u00A4\u00A8\u00E0\u00A5\u008D\u00E0\u00A4\u00A8\u00E0\u00A4\u0097\u00E0\u00A4\u00BE\u00E0\u00A4\u00A1\u00E0\u00A4\u00BF\u00E0\u00A4\u00AF\u00E0\u00A4\u00BE\u00E0\u00A4\u0081\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00AF\u00E0\u00A5\u008B\u00E0\u00A4\u0082\u00E0\u00A4\u0095\u00E0\u00A4\u00BF\u00E0\u00A4\u00B8\u00E0\u00A5\u0081\u00E0\u00A4\u00B0\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00B7\u00E0\u00A4\u00BE\u00E0\u00A4\u00AA\u00E0\u00A4\u00B9\u00E0\u00A5\u0081\u00E0\u00A4\u0081\u00E0\u00A4\u009A\u00E0\u00A4\u00A4\u00E0\u00A5\u0080\u00E0\u00A4\u00AA\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00AC\u00E0\u00A4\u0082\u00E0\u00A4\u00A7\u00E0\u00A4\u00A8\u00E0\u00A4\u009F\u00E0\u00A4\u00BF\u00E0\u00A4\u00AA\u00E0\u00A5\u008D\u00E0\u00A4\u00AA\u00E0\u00A4\u00A3\u00E0\u00A5\u0080\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00BF\u00E0\u00A4\u0095\u00E0\u00A5\u0087\u00E0\u00A4\u009F\u00E0\u00A4\u00AA\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u0082\u00E0\u00A4\u00AD\u00E0\u00A4\u00AA\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u00AA\u00E0\u00A5\u008D\u00E0\u00A4\u00A4\u00E0\u00A4\u00AE\u00E0\u00A4\u00BE\u00E0\u00A4\u00B2\u00E0\u00A4\u00BF\u00E0\u00A4\u0095\u00E0\u00A5\u008B\u00E0\u00A4\u0082\u00E0\u00A4\u00B0\u00E0\u00A4\u00AB\u00E0\u00A4\u00BC\u00E0\u00A5\u008D\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A4\u00A8\u00E0\u00A4\u00BF\u00E0\u00A4\u00B0\u00E0\u00A5\u008D\u00E0\u00A4\u00AE\u00E0\u00A4\u00BE\u00E0\u00A4\u00A3\u00E0\u00A4\u00B2\u00E0\u00A4\u00BF\u00E0\u00A4\u00AE\u00E0\u00A4\u00BF\u00E0\u00A4\u009F\u00E0\u00A5\u0087\u00E0\u00A4\u00A1description\" content=\"document.location.prot.getElementsByTagName(<!DOCTYPE html>\n<html <meta charset=\"utf-8\">:url\" content=\"http://.css\" rel=\"stylesheet\"style type=\"text/css\">type=\"text/css\" href=\"w3.org/1999/xhtml\" xmltype=\"text/javascript\" method=\"get\" action=\"link rel=\"stylesheet\"  = document.getElementtype=\"image/x-icon\" />cellpadding=\"0\" cellsp.css\" type=\"text/css\" </a></li><li><a href=\"\" width=\"1\" height=\"1\"\"><a href=\"http://www.style=\"display:none;\">alternate\" type=\"appli-//W3C//DTD XHTML 1.0 ellspacing=\"0\" cellpad type=\"hidden\" value=\"/a>&nbsp;<span role=\"s\n<input type=\"hidden\" language=\"JavaScript\"  document.getElementsBg=\"0\" cellspacing=\"0\" ype=\"text/css\" media=\"type='text/javascript'with the exception of ype=\"text/css\" rel=\"st height=\"1\" width=\"1\" ='+encodeURIComponent(<link rel=\"alternate\" \nbody, tr, input, textmeta name=\"robots\" conmethod=\"post\" action=\">\n<a href=\"http://www.css\" rel=\"stylesheet\" </div></div><div classlanguage=\"javascript\">aria-hidden=\"true\">\u00C2\u00B7<ript\" type=\"text/javasl=0;})();\n(function(){background-image: url(/a></li><li><a href=\"h\t\t<li><a href=\"http://ator\" aria-hidden=\"tru> <a href=\"http://www.language=\"javascript\" /option>\n<option value/div></div><div class=rator\" aria-hidden=\"tre=(new Date).getTime()portugu\u00C3\u00AAs (do Brasil)\u00D0\u00BE\u00D1\u0080\u00D0\u00B3\u00D0\u00B0\u00D0\u00BD\u00D0\u00B8\u00D0\u00B7\u00D0\u00B0\u00D1\u0086\u00D0\u00B8\u00D0\u00B8\u00D0\u00B2\u00D0\u00BE\u00D0\u00B7\u00D0\u00BC\u00D0\u00BE\u00D0\u00B6\u00D0\u00BD\u00D0\u00BE\u00D1\u0081\u00D1\u0082\u00D1\u008C\u00D0\u00BE\u00D0\u00B1\u00D1\u0080\u00D0\u00B0\u00D0\u00B7\u00D0\u00BE\u00D0\u00B2\u00D0\u00B0\u00D0\u00BD\u00D0\u00B8\u00D1\u008F\u00D1\u0080\u00D0\u00B5\u00D0\u00B3\u00D0\u00B8\u00D1\u0081\u00D1\u0082\u00D1\u0080\u00D0\u00B0\u00D1\u0086\u00D0\u00B8\u00D0\u00B8\u00D0\u00B2\u00D0\u00BE\u00D0\u00B7\u00D0\u00BC\u00D0\u00BE\u00D0\u00B6\u00D0\u00BD\u00D0\u00BE\u00D1\u0081\u00D1\u0082\u00D0\u00B8\u00D0\u00BE\u00D0\u00B1\u00D1\u008F\u00D0\u00B7\u00D0\u00B0\u00D1\u0082\u00D0\u00B5\u00D0\u00BB\u00D1\u008C\u00D0\u00BD\u00D0\u00B0<!DOCTYPE html PUBLIC \"nt-Type\" content=\"text/<meta http-equiv=\"Conteransitional//EN\" \"http:<html xmlns=\"http://www-//W3C//DTD XHTML 1.0 TDTD/xhtml1-transitional//www.w3.org/TR/xhtml1/pe = 'text/javascript';<meta name=\"descriptionparentNode.insertBefore<input type=\"hidden\" najs\" type=\"text/javascri(document).ready(functiscript type=\"text/javasimage\" content=\"http://UA-Compatible\" content=tml; charset=utf-8\" />\nlink rel=\"shortcut icon<link rel=\"stylesheet\" </script>\n<script type== document.createElemen<a target=\"_blank\" href= document.getElementsBinput type=\"text\" name=a.type = 'text/javascrinput type=\"hidden\" namehtml; charset=utf-8\" />dtd\">\n<html xmlns=\"http-//W3C//DTD HTML 4.01 TentsByTagName('script')input type=\"hidden\" nam<script type=\"text/javas\" style=\"display:none;\">document.getElementById(=document.createElement(' type='text/javascript'input type=\"text\" name=\"d.getElementsByTagName(snical\" href=\"http://www.C//DTD HTML 4.01 Transit<style type=\"text/css\">\n\n<style type=\"text/css\">ional.dtd\">\n<html xmlns=http-equiv=\"Content-Typeding=\"0\" cellspacing=\"0\"html; charset=utf-8\" />\n style=\"display:none;\"><<li><a href=\"http://www. type='text/javascript'>\u00D0\u00B4\u00D0\u00B5\u00D1\u008F\u00D1\u0082\u00D0\u00B5\u00D0\u00BB\u00D1\u008C\u00D0\u00BD\u00D0\u00BE\u00D1\u0081\u00D1\u0082\u00D0\u00B8\u00D1\u0081\u00D0\u00BE\u00D0\u00BE\u00D1\u0082\u00D0\u00B2\u00D0\u00B5\u00D1\u0082\u00D1\u0081\u00D1\u0082\u00D0\u00B2\u00D0\u00B8\u00D0\u00B8\u00D0\u00BF\u00D1\u0080\u00D0\u00BE\u00D0\u00B8\u00D0\u00B7\u00D0\u00B2\u00D0\u00BE\u00D0\u00B4\u00D1\u0081\u00D1\u0082\u00D0\u00B2\u00D0\u00B0\u00D0\u00B1\u00D0\u00B5\u00D0\u00B7\u00D0\u00BE\u00D0\u00BF\u00D0\u00B0\u00D1\u0081\u00D0\u00BD\u00D0\u00BE\u00D1\u0081\u00D1\u0082\u00D0\u00B8\u00E0\u00A4\u00AA\u00E0\u00A5\u0081\u00E0\u00A4\u00B8\u00E0\u00A5\u008D\u00E0\u00A4\u00A4\u00E0\u00A4\u00BF\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u0082\u00E0\u00A4\u0097\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A5\u0087\u00E0\u00A4\u00B8\u00E0\u00A4\u0089\u00E0\u00A4\u00A8\u00E0\u00A5\u008D\u00E0\u00A4\u00B9\u00E0\u00A5\u008B\u00E0\u00A4\u0082\u00E0\u00A4\u00A8\u00E0\u00A5\u0087\u00E0\u00A4\u00B5\u00E0\u00A4\u00BF\u00E0\u00A4\u00A7\u00E0\u00A4\u00BE\u00E0\u00A4\u00A8\u00E0\u00A4\u00B8\u00E0\u00A4\u00AD\u00E0\u00A4\u00BE\u00E0\u00A4\u00AB\u00E0\u00A4\u00BF\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00B8\u00E0\u00A4\u00BF\u00E0\u00A4\u0082\u00E0\u00A4\u0097\u00E0\u00A4\u00B8\u00E0\u00A5\u0081\u00E0\u00A4\u00B0\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00B7\u00E0\u00A4\u00BF\u00E0\u00A4\u00A4\u00E0\u00A4\u0095\u00E0\u00A5\u0089\u00E0\u00A4\u00AA\u00E0\u00A5\u0080\u00E0\u00A4\u00B0\u00E0\u00A4\u00BE\u00E0\u00A4\u0087\u00E0\u00A4\u009F\u00E0\u00A4\u00B5\u00E0\u00A4\u00BF\u00E0\u00A4\u009C\u00E0\u00A5\u008D\u00E0\u00A4\u009E\u00E0\u00A4\u00BE\u00E0\u00A4\u00AA\u00E0\u00A4\u00A8\u00E0\u00A4\u0095\u00E0\u00A4\u00BE\u00E0\u00A4\u00B0\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00B5\u00E0\u00A4\u00BE\u00E0\u00A4\u0088\u00E0\u00A4\u00B8\u00E0\u00A4\u0095\u00E0\u00A5\u008D\u00E0\u00A4\u00B0\u00E0\u00A4\u00BF\u00E0\u00A4\u00AF\u00E0\u00A4\u00A4\u00E0\u00A4\u00BE";
			}
		}

		private class DataHolder
		{
			internal static readonly byte[] Data;

			static DataHolder()
			{
				Data = new byte[122784];
				string[] chunks = new string[] { Org.Brotli.Dec.Dictionary.DataHolder0.GetData(), Org.Brotli.Dec.Dictionary.DataHolder1.GetData(), Org.Brotli.Dec.Dictionary.DataHolder2.GetData() };
				int sum = 0;
				foreach (string chunk in chunks)
				{
					sum += chunk.Length;
				}
				if (sum != Data.Length)
				{
					throw new System.Exception("Corrupted brotli dictionary");
				}
				sum = 0;
				foreach (string chunk in chunks)
				{
					for (int j = 0; j < chunk.Length; ++j)
					{
						Data[sum++] = unchecked((byte)chunk[j]);
					}
				}
			}
		}

		internal static byte[] GetData()
		{
			return Org.Brotli.Dec.Dictionary.DataHolder.Data;
		}

		internal static readonly int[] OffsetsByLength = new int[] { 0, 0, 0, 0, 0, 4096, 9216, 21504, 35840, 44032, 53248, 63488, 74752, 87040, 93696, 100864, 104704, 106752, 108928, 113536, 115968, 118528, 119872, 121280, 122016 };

		internal static readonly int[] SizeBitsByLength = new int[] { 0, 0, 0, 0, 10, 10, 11, 11, 10, 10, 10, 10, 10, 9, 9, 8, 7, 7, 8, 7, 7, 6, 6, 5, 5 };

		internal const int MinWordLength = 4;

		internal const int MaxWordLength = 24;

		internal const int MaxTransformedWordLength = 5 + MaxWordLength + 8;
	}
}

```

`AssetStudio/Brotli/Huffman.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>Utilities for building Huffman decoding tables.</summary>
	internal sealed class Huffman
	{
		/// <summary>
		/// Maximum possible Huffman table size for an alphabet size of 704, max code length 15 and root
		/// table bits 8.
		/// </summary>
		internal const int HuffmanMaxTableSize = 1080;

		private const int MaxLength = 15;

		/// <summary>Returns reverse(reverse(key, len) + 1, len).</summary>
		/// <remarks>
		/// Returns reverse(reverse(key, len) + 1, len).
		/// <p> reverse(key, len) is the bit-wise reversal of the len least significant bits of key.
		/// </remarks>
		private static int GetNextKey(int key, int len)
		{
			int step = 1 << (len - 1);
			while ((key & step) != 0)
			{
				step >>= 1;
			}
			return (key & (step - 1)) + step;
		}

		/// <summary>
		/// Stores
		/// <paramref name="item"/>
		/// in
		/// <c>table[0], table[step], table[2 * step] .., table[end]</c>
		/// .
		/// <p> Assumes that end is an integer multiple of step.
		/// </summary>
		private static void ReplicateValue(int[] table, int offset, int step, int end, int item)
		{
			do
			{
				end -= step;
				table[offset + end] = item;
			}
			while (end > 0);
		}

		/// <param name="count">histogram of bit lengths for the remaining symbols,</param>
		/// <param name="len">code length of the next processed symbol.</param>
		/// <returns>table width of the next 2nd level table.</returns>
		private static int NextTableBitSize(int[] count, int len, int rootBits)
		{
			int left = 1 << (len - rootBits);
			while (len < MaxLength)
			{
				left -= count[len];
				if (left <= 0)
				{
					break;
				}
				len++;
				left <<= 1;
			}
			return len - rootBits;
		}

		/// <summary>Builds Huffman lookup table assuming code lengths are in symbol order.</summary>
		internal static void BuildHuffmanTable(int[] rootTable, int tableOffset, int rootBits, int[] codeLengths, int codeLengthsSize)
		{
			int key;
			// Reversed prefix code.
			int[] sorted = new int[codeLengthsSize];
			// Symbols sorted by code length.
			// TODO: fill with zeroes?
			int[] count = new int[MaxLength + 1];
			// Number of codes of each length.
			int[] offset = new int[MaxLength + 1];
			// Offsets in sorted table for each length.
			int symbol;
			// Build histogram of code lengths.
			for (symbol = 0; symbol < codeLengthsSize; symbol++)
			{
				count[codeLengths[symbol]]++;
			}
			// Generate offsets into sorted symbol table by code length.
			offset[1] = 0;
			for (int len = 1; len < MaxLength; len++)
			{
				offset[len + 1] = offset[len] + count[len];
			}
			// Sort symbols by length, by symbol order within each length.
			for (symbol = 0; symbol < codeLengthsSize; symbol++)
			{
				if (codeLengths[symbol] != 0)
				{
					sorted[offset[codeLengths[symbol]]++] = symbol;
				}
			}
			int tableBits = rootBits;
			int tableSize = 1 << tableBits;
			int totalSize = tableSize;
			// Special case code with only one value.
			if (offset[MaxLength] == 1)
			{
				for (key = 0; key < totalSize; key++)
				{
					rootTable[tableOffset + key] = sorted[0];
				}
				return;
			}
			// Fill in root table.
			key = 0;
			symbol = 0;
			for (int len = 1, step = 2; len <= rootBits; len++, step <<= 1)
			{
				for (; count[len] > 0; count[len]--)
				{
					ReplicateValue(rootTable, tableOffset + key, step, tableSize, len << 16 | sorted[symbol++]);
					key = GetNextKey(key, len);
				}
			}
			// Fill in 2nd level tables and add pointers to root table.
			int mask = totalSize - 1;
			int low = -1;
			int currentOffset = tableOffset;
			for (int len = rootBits + 1, step = 2; len <= MaxLength; len++, step <<= 1)
			{
				for (; count[len] > 0; count[len]--)
				{
					if ((key & mask) != low)
					{
						currentOffset += tableSize;
						tableBits = NextTableBitSize(count, len, rootBits);
						tableSize = 1 << tableBits;
						totalSize += tableSize;
						low = key & mask;
						rootTable[tableOffset + low] = (tableBits + rootBits) << 16 | (currentOffset - tableOffset - low);
					}
					ReplicateValue(rootTable, currentOffset + (key >> rootBits), step, tableSize, (len - rootBits) << 16 | sorted[symbol++]);
					key = GetNextKey(key, len);
				}
			}
		}
	}
}

```

`AssetStudio/Brotli/HuffmanTreeGroup.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>Contains a collection of huffman trees with the same alphabet size.</summary>
	internal sealed class HuffmanTreeGroup
	{
		/// <summary>The maximal alphabet size in this group.</summary>
		private int alphabetSize;

		/// <summary>Storage for Huffman lookup tables.</summary>
		internal int[] codes;

		/// <summary>
		/// Offsets of distinct lookup tables in
		/// <see cref="codes"/>
		/// storage.
		/// </summary>
		internal int[] trees;

		/// <summary>Initializes the Huffman tree group.</summary>
		/// <param name="group">POJO to be initialised</param>
		/// <param name="alphabetSize">the maximal alphabet size in this group</param>
		/// <param name="n">number of Huffman codes</param>
		internal static void Init(Org.Brotli.Dec.HuffmanTreeGroup group, int alphabetSize, int n)
		{
			group.alphabetSize = alphabetSize;
			group.codes = new int[n * Org.Brotli.Dec.Huffman.HuffmanMaxTableSize];
			group.trees = new int[n];
		}

		/// <summary>Decodes Huffman trees from input stream and constructs lookup tables.</summary>
		/// <param name="group">target POJO</param>
		/// <param name="br">data source</param>
		internal static void Decode(Org.Brotli.Dec.HuffmanTreeGroup group, Org.Brotli.Dec.BitReader br)
		{
			int next = 0;
			int n = group.trees.Length;
			for (int i = 0; i < n; i++)
			{
				group.trees[i] = next;
				Org.Brotli.Dec.Decode.ReadHuffmanCode(group.alphabetSize, group.codes, next, br);
				next += Org.Brotli.Dec.Huffman.HuffmanMaxTableSize;
			}
		}
	}
}

```

`AssetStudio/Brotli/IntReader.cs`:

```cs
/* Copyright 2017 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>Byte-to-int conversion magic.</summary>
	internal sealed class IntReader
	{
		private byte[] byteBuffer;

		private int[] intBuffer;

		internal static void Init(Org.Brotli.Dec.IntReader ir, byte[] byteBuffer, int[] intBuffer)
		{
			ir.byteBuffer = byteBuffer;
			ir.intBuffer = intBuffer;
		}

		/// <summary>Translates bytes to ints.</summary>
		/// <remarks>
		/// Translates bytes to ints.
		/// NB: intLen == 4 * byteSize!
		/// NB: intLen should be less or equal to intBuffer length.
		/// </remarks>
		internal static void Convert(Org.Brotli.Dec.IntReader ir, int intLen)
		{
			for (int i = 0; i < intLen; ++i)
			{
				ir.intBuffer[i] = ((ir.byteBuffer[i * 4] & unchecked((int)(0xFF)))) | ((ir.byteBuffer[(i * 4) + 1] & unchecked((int)(0xFF))) << 8) | ((ir.byteBuffer[(i * 4) + 2] & unchecked((int)(0xFF))) << 16) | ((ir.byteBuffer[(i * 4) + 3] & unchecked((int
					)(0xFF))) << 24);
			}
		}
	}
}

```

`AssetStudio/Brotli/Prefix.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>Lookup tables to map prefix codes to value ranges.</summary>
	/// <remarks>
	/// Lookup tables to map prefix codes to value ranges.
	/// <p> This is used during decoding of the block lengths, literal insertion lengths and copy
	/// lengths.
	/// <p> Range represents values: [offset, offset + 2 ^ n_bits)
	/// </remarks>
	internal sealed class Prefix
	{
		internal static readonly int[] BlockLengthOffset = new int[] { 1, 5, 9, 13, 17, 25, 33, 41, 49, 65, 81, 97, 113, 145, 177, 209, 241, 305, 369, 497, 753, 1265, 2289, 4337, 8433, 16625 };

		internal static readonly int[] BlockLengthNBits = new int[] { 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 24 };

		internal static readonly int[] InsertLengthOffset = new int[] { 0, 1, 2, 3, 4, 5, 6, 8, 10, 14, 18, 26, 34, 50, 66, 98, 130, 194, 322, 578, 1090, 2114, 6210, 22594 };

		internal static readonly int[] InsertLengthNBits = new int[] { 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 9, 10, 12, 14, 24 };

		internal static readonly int[] CopyLengthOffset = new int[] { 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 18, 22, 30, 38, 54, 70, 102, 134, 198, 326, 582, 1094, 2118 };

		internal static readonly int[] CopyLengthNBits = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 9, 10, 24 };

		internal static readonly int[] InsertRangeLut = new int[] { 0, 0, 8, 8, 0, 16, 8, 16, 16 };

		internal static readonly int[] CopyRangeLut = new int[] { 0, 8, 0, 8, 16, 0, 16, 8, 16 };
	}
}

```

`AssetStudio/Brotli/RunningState.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>Enumeration of decoding state-machine.</summary>
	internal sealed class RunningState
	{
		internal const int Uninitialized = 0;

		internal const int BlockStart = 1;

		internal const int CompressedBlockStart = 2;

		internal const int MainLoop = 3;

		internal const int ReadMetadata = 4;

		internal const int CopyUncompressed = 5;

		internal const int InsertLoop = 6;

		internal const int CopyLoop = 7;

		internal const int CopyWrapBuffer = 8;

		internal const int Transform = 9;

		internal const int Finished = 10;

		internal const int Closed = 11;

		internal const int Write = 12;
	}
}

```

`AssetStudio/Brotli/State.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	internal sealed class State
	{
		internal int runningState = Org.Brotli.Dec.RunningState.Uninitialized;

		internal int nextRunningState;

		internal readonly Org.Brotli.Dec.BitReader br = new Org.Brotli.Dec.BitReader();

		internal byte[] ringBuffer;

		internal readonly int[] blockTypeTrees = new int[3 * Org.Brotli.Dec.Huffman.HuffmanMaxTableSize];

		internal readonly int[] blockLenTrees = new int[3 * Org.Brotli.Dec.Huffman.HuffmanMaxTableSize];

		internal int metaBlockLength;

		internal bool inputEnd;

		internal bool isUncompressed;

		internal bool isMetadata;

		internal readonly Org.Brotli.Dec.HuffmanTreeGroup hGroup0 = new Org.Brotli.Dec.HuffmanTreeGroup();

		internal readonly Org.Brotli.Dec.HuffmanTreeGroup hGroup1 = new Org.Brotli.Dec.HuffmanTreeGroup();

		internal readonly Org.Brotli.Dec.HuffmanTreeGroup hGroup2 = new Org.Brotli.Dec.HuffmanTreeGroup();

		internal readonly int[] blockLength = new int[3];

		internal readonly int[] numBlockTypes = new int[3];

		internal readonly int[] blockTypeRb = new int[6];

		internal readonly int[] distRb = new int[] { 16, 15, 11, 4 };

		internal int pos = 0;

		internal int maxDistance = 0;

		internal int distRbIdx = 0;

		internal bool trivialLiteralContext = false;

		internal int literalTreeIndex = 0;

		internal int literalTree;

		internal int j;

		internal int insertLength;

		internal byte[] contextModes;

		internal byte[] contextMap;

		internal int contextMapSlice;

		internal int distContextMapSlice;

		internal int contextLookupOffset1;

		internal int contextLookupOffset2;

		internal int treeCommandOffset;

		internal int distanceCode;

		internal byte[] distContextMap;

		internal int numDirectDistanceCodes;

		internal int distancePostfixMask;

		internal int distancePostfixBits;

		internal int distance;

		internal int copyLength;

		internal int copyDst;

		internal int maxBackwardDistance;

		internal int maxRingBufferSize;

		internal int ringBufferSize = 0;

		internal long expectedTotalSize = 0;

		internal byte[] customDictionary = new byte[0];

		internal int bytesToIgnore = 0;

		internal int outputOffset;

		internal int outputLength;

		internal int outputUsed;

		internal int bytesWritten;

		internal int bytesToWrite;

		internal byte[] output;

		// Current meta-block header information.
		// TODO: Update to current spec.
		private static int DecodeWindowBits(Org.Brotli.Dec.BitReader br)
		{
			if (Org.Brotli.Dec.BitReader.ReadBits(br, 1) == 0)
			{
				return 16;
			}
			int n = Org.Brotli.Dec.BitReader.ReadBits(br, 3);
			if (n != 0)
			{
				return 17 + n;
			}
			n = Org.Brotli.Dec.BitReader.ReadBits(br, 3);
			if (n != 0)
			{
				return 8 + n;
			}
			return 17;
		}

		/// <summary>Associate input with decoder state.</summary>
		/// <param name="state">uninitialized state without associated input</param>
		/// <param name="input">compressed data source</param>
		internal static void SetInput(Org.Brotli.Dec.State state, System.IO.Stream input)
		{
			if (state.runningState != Org.Brotli.Dec.RunningState.Uninitialized)
			{
				throw new System.InvalidOperationException("State MUST be uninitialized");
			}
			Org.Brotli.Dec.BitReader.Init(state.br, input);
			int windowBits = DecodeWindowBits(state.br);
			if (windowBits == 9)
			{
				/* Reserved case for future expansion. */
				throw new Org.Brotli.Dec.BrotliRuntimeException("Invalid 'windowBits' code");
			}
			state.maxRingBufferSize = 1 << windowBits;
			state.maxBackwardDistance = state.maxRingBufferSize - 16;
			state.runningState = Org.Brotli.Dec.RunningState.BlockStart;
		}

		/// <exception cref="System.IO.IOException"/>
		internal static void Close(Org.Brotli.Dec.State state)
		{
			if (state.runningState == Org.Brotli.Dec.RunningState.Uninitialized)
			{
				throw new System.InvalidOperationException("State MUST be initialized");
			}
			if (state.runningState == Org.Brotli.Dec.RunningState.Closed)
			{
				return;
			}
			state.runningState = Org.Brotli.Dec.RunningState.Closed;
			Org.Brotli.Dec.BitReader.Close(state.br);
		}
	}
}

```

`AssetStudio/Brotli/Transform.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>Transformations on dictionary words.</summary>
	internal sealed class Transform
	{
		private readonly byte[] prefix;

		private readonly int type;

		private readonly byte[] suffix;

		internal Transform(string prefix, int type, string suffix)
		{
			this.prefix = ReadUniBytes(prefix);
			this.type = type;
			this.suffix = ReadUniBytes(suffix);
		}

		internal static byte[] ReadUniBytes(string uniBytes)
		{
			byte[] result = new byte[uniBytes.Length];
			for (int i = 0; i < result.Length; ++i)
			{
				result[i] = unchecked((byte)uniBytes[i]);
			}
			return result;
		}

		internal static readonly Org.Brotli.Dec.Transform[] Transforms = new Org.Brotli.Dec.Transform[] { new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, 
			Org.Brotli.Dec.WordTransformType.Identity, " "), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.Identity, " "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.OmitFirst1, string.Empty), new Org.Brotli.Dec.Transform
			(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseFirst, " "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, " the "), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.Identity
			, string.Empty), new Org.Brotli.Dec.Transform("s ", Org.Brotli.Dec.WordTransformType.Identity, " "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, " of "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType
			.UppercaseFirst, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, " and "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.OmitFirst2, string.Empty), new Org.Brotli.Dec.Transform
			(string.Empty, Org.Brotli.Dec.WordTransformType.OmitLast1, string.Empty), new Org.Brotli.Dec.Transform(", ", Org.Brotli.Dec.WordTransformType.Identity, " "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity
			, ", "), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.UppercaseFirst, " "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, " in "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType
			.Identity, " to "), new Org.Brotli.Dec.Transform("e ", Org.Brotli.Dec.WordTransformType.Identity, " "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "\""), new Org.Brotli.Dec.Transform(string.Empty, 
			Org.Brotli.Dec.WordTransformType.Identity, "."), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "\">"), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "\n"), new 
			Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.OmitLast3, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "]"), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType
			.Identity, " for "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.OmitFirst3, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.OmitLast2, string.Empty), new Org.Brotli.Dec.Transform
			(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, " a "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, " that "), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.UppercaseFirst
			, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, ". "), new Org.Brotli.Dec.Transform(".", Org.Brotli.Dec.WordTransformType.Identity, string.Empty), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType
			.Identity, ", "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.OmitFirst4, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, " with "), new Org.Brotli.Dec.Transform
			(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "'"), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, " from "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity
			, " by "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.OmitFirst5, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.OmitFirst6, string.Empty), new Org.Brotli.Dec.Transform
			(" the ", Org.Brotli.Dec.WordTransformType.Identity, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.OmitLast4, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType
			.Identity, ". The "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseAll, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, " on "), new Org.Brotli.Dec.Transform
			(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, " as "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, " is "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.OmitLast7
			, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.OmitLast1, "ing "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "\n\t"), new Org.Brotli.Dec.Transform(string.Empty
			, Org.Brotli.Dec.WordTransformType.Identity, ":"), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.Identity, ". "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "ed "), new Org.Brotli.Dec.Transform
			(string.Empty, Org.Brotli.Dec.WordTransformType.OmitFirst9, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.OmitFirst7, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType
			.OmitLast6, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "("), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseFirst, ", "), new Org.Brotli.Dec.Transform
			(string.Empty, Org.Brotli.Dec.WordTransformType.OmitLast8, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, " at "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType
			.Identity, "ly "), new Org.Brotli.Dec.Transform(" the ", Org.Brotli.Dec.WordTransformType.Identity, " of "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.OmitLast5, string.Empty), new Org.Brotli.Dec.Transform(
			string.Empty, Org.Brotli.Dec.WordTransformType.OmitLast9, string.Empty), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.UppercaseFirst, ", "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseFirst
			, "\""), new Org.Brotli.Dec.Transform(".", Org.Brotli.Dec.WordTransformType.Identity, "("), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseAll, " "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType
			.UppercaseFirst, "\">"), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "=\""), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.Identity, "."), new Org.Brotli.Dec.Transform(".com/", 
			Org.Brotli.Dec.WordTransformType.Identity, string.Empty), new Org.Brotli.Dec.Transform(" the ", Org.Brotli.Dec.WordTransformType.Identity, " of the "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseFirst
			, "'"), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, ". This "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, ","), new Org.Brotli.Dec.Transform(".", Org.Brotli.Dec.WordTransformType
			.Identity, " "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseFirst, "("), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseFirst, "."), new Org.Brotli.Dec.Transform
			(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, " not "), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.Identity, "=\""), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "er "
			), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.UppercaseAll, " "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "al "), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType
			.UppercaseAll, string.Empty), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "='"), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseAll, "\""), new Org.Brotli.Dec.Transform
			(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseFirst, ". "), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.Identity, "("), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, 
			"ful "), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.UppercaseFirst, ". "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "ive "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType
			.Identity, "less "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseAll, "'"), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "est "), new Org.Brotli.Dec.Transform
			(" ", Org.Brotli.Dec.WordTransformType.UppercaseFirst, "."), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseAll, "\">"), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.Identity, "='"
			), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseFirst, ","), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity, "ize "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType
			.UppercaseAll, "."), new Org.Brotli.Dec.Transform("\u00c2\u00a0", Org.Brotli.Dec.WordTransformType.Identity, string.Empty), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.Identity, ","), new Org.Brotli.Dec.Transform(string.Empty
			, Org.Brotli.Dec.WordTransformType.UppercaseFirst, "=\""), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseAll, "=\""), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.Identity
			, "ous "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseAll, ", "), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseFirst, "='"), new Org.Brotli.Dec.Transform(" ", 
			Org.Brotli.Dec.WordTransformType.UppercaseFirst, ","), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.UppercaseAll, "=\""), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.UppercaseAll, ", "), new Org.Brotli.Dec.Transform
			(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseAll, ","), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseAll, "("), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.
			UppercaseAll, ". "), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.UppercaseAll, "."), new Org.Brotli.Dec.Transform(string.Empty, Org.Brotli.Dec.WordTransformType.UppercaseAll, "='"), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType
			.UppercaseAll, ". "), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.UppercaseFirst, "=\""), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType.UppercaseAll, "='"), new Org.Brotli.Dec.Transform(" ", Org.Brotli.Dec.WordTransformType
			.UppercaseFirst, "='") };

		internal static int TransformDictionaryWord(byte[] dst, int dstOffset, byte[] word, int wordOffset, int len, Org.Brotli.Dec.Transform transform)
		{
			int offset = dstOffset;
			// Copy prefix.
			byte[] @string = transform.prefix;
			int tmp = @string.Length;
			int i = 0;
			// In most cases tmp < 10 -> no benefits from System.arrayCopy
			while (i < tmp)
			{
				dst[offset++] = @string[i++];
			}
			// Copy trimmed word.
			int op = transform.type;
			tmp = Org.Brotli.Dec.WordTransformType.GetOmitFirst(op);
			if (tmp > len)
			{
				tmp = len;
			}
			wordOffset += tmp;
			len -= tmp;
			len -= Org.Brotli.Dec.WordTransformType.GetOmitLast(op);
			i = len;
			while (i > 0)
			{
				dst[offset++] = word[wordOffset++];
				i--;
			}
			if (op == Org.Brotli.Dec.WordTransformType.UppercaseAll || op == Org.Brotli.Dec.WordTransformType.UppercaseFirst)
			{
				int uppercaseOffset = offset - len;
				if (op == Org.Brotli.Dec.WordTransformType.UppercaseFirst)
				{
					len = 1;
				}
				while (len > 0)
				{
					tmp = dst[uppercaseOffset] & unchecked((int)(0xFF));
					if (tmp < unchecked((int)(0xc0)))
					{
						if (tmp >= 'a' && tmp <= 'z')
						{
							dst[uppercaseOffset] ^= unchecked((byte)32);
						}
						uppercaseOffset += 1;
						len -= 1;
					}
					else if (tmp < unchecked((int)(0xe0)))
					{
						dst[uppercaseOffset + 1] ^= unchecked((byte)32);
						uppercaseOffset += 2;
						len -= 2;
					}
					else
					{
						dst[uppercaseOffset + 2] ^= unchecked((byte)5);
						uppercaseOffset += 3;
						len -= 3;
					}
				}
			}
			// Copy suffix.
			@string = transform.suffix;
			tmp = @string.Length;
			i = 0;
			while (i < tmp)
			{
				dst[offset++] = @string[i++];
			}
			return offset - dstOffset;
		}
	}
}

```

`AssetStudio/Brotli/Utils.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>A set of utility methods.</summary>
	internal sealed class Utils
	{
		private static readonly byte[] ByteZeroes = new byte[1024];

		private static readonly int[] IntZeroes = new int[1024];

		/// <summary>Fills byte array with zeroes.</summary>
		/// <remarks>
		/// Fills byte array with zeroes.
		/// <p> Current implementation uses
		/// <see cref="System.Array.Copy(object, int, object, int, int)"/>
		/// , so it should be used for length not
		/// less than 16.
		/// </remarks>
		/// <param name="dest">array to fill with zeroes</param>
		/// <param name="offset">the first byte to fill</param>
		/// <param name="length">number of bytes to change</param>
		internal static void FillWithZeroes(byte[] dest, int offset, int length)
		{
			int cursor = 0;
			while (cursor < length)
			{
				int step = System.Math.Min(cursor + 1024, length) - cursor;
				System.Array.Copy(ByteZeroes, 0, dest, offset + cursor, step);
				cursor += step;
			}
		}

		/// <summary>Fills int array with zeroes.</summary>
		/// <remarks>
		/// Fills int array with zeroes.
		/// <p> Current implementation uses
		/// <see cref="System.Array.Copy(object, int, object, int, int)"/>
		/// , so it should be used for length not
		/// less than 16.
		/// </remarks>
		/// <param name="dest">array to fill with zeroes</param>
		/// <param name="offset">the first item to fill</param>
		/// <param name="length">number of item to change</param>
		internal static void FillWithZeroes(int[] dest, int offset, int length)
		{
			int cursor = 0;
			while (cursor < length)
			{
				int step = System.Math.Min(cursor + 1024, length) - cursor;
				System.Array.Copy(IntZeroes, 0, dest, offset + cursor, step);
				cursor += step;
			}
		}
	}
}

```

`AssetStudio/Brotli/WordTransformType.cs`:

```cs
/* Copyright 2015 Google Inc. All Rights Reserved.

Distributed under MIT license.
See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
*/
namespace Org.Brotli.Dec
{
	/// <summary>Enumeration of all possible word transformations.</summary>
	/// <remarks>
	/// Enumeration of all possible word transformations.
	/// <p>There are two simple types of transforms: omit X first/last symbols, two character-case
	/// transforms and the identity transform.
	/// </remarks>
	internal sealed class WordTransformType
	{
		internal const int Identity = 0;

		internal const int OmitLast1 = 1;

		internal const int OmitLast2 = 2;

		internal const int OmitLast3 = 3;

		internal const int OmitLast4 = 4;

		internal const int OmitLast5 = 5;

		internal const int OmitLast6 = 6;

		internal const int OmitLast7 = 7;

		internal const int OmitLast8 = 8;

		internal const int OmitLast9 = 9;

		internal const int UppercaseFirst = 10;

		internal const int UppercaseAll = 11;

		internal const int OmitFirst1 = 12;

		internal const int OmitFirst2 = 13;

		internal const int OmitFirst3 = 14;

		internal const int OmitFirst4 = 15;

		internal const int OmitFirst5 = 16;

		internal const int OmitFirst6 = 17;

		internal const int OmitFirst7 = 18;

		internal const int OmitFirst8 = 19;

		internal const int OmitFirst9 = 20;

		internal static int GetOmitFirst(int type)
		{
			return type >= OmitFirst1 ? (type - OmitFirst1 + 1) : 0;
		}

		internal static int GetOmitLast(int type)
		{
			return type <= OmitLast9 ? (type - OmitLast1 + 1) : 0;
		}
	}
}

```

`AssetStudio/BuildTarget.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public enum BuildTarget
    {
        NoTarget = -2,
        AnyPlayer = -1,
        ValidPlayer = 1,
        StandaloneOSX = 2,
        StandaloneOSXPPC = 3,
        StandaloneOSXIntel = 4,
        StandaloneWindows,
        WebPlayer,
        WebPlayerStreamed,
        Wii = 8,
        iOS = 9,
        PS3,
        XBOX360,
        Broadcom = 12,
        Android = 13,
        StandaloneGLESEmu = 14,
        StandaloneGLES20Emu = 15,
        NaCl = 16,
        StandaloneLinux = 17,
        FlashPlayer = 18,
        StandaloneWindows64 = 19,
        WebGL,
        WSAPlayer,
        StandaloneLinux64 = 24,
        StandaloneLinuxUniversal,
        WP8Player,
        StandaloneOSXIntel64,
        BlackBerry,
        Tizen,
        PSP2,
        PS4,
        PSM,
        XboxOne,
        SamsungTV,
        N3DS,
        WiiU,
        tvOS,
        Switch,
        Lumin,
        Stadia,
        CloudRendering,
        GameCoreXboxSeries,
        GameCoreXboxOne,
        PS5,
        EmbeddedLinux,
        QNX,
        UnknownPlatform = 9999
    }
}

```

`AssetStudio/BuildType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class BuildType
    {
        private string buildType;

        public BuildType(string type)
        {
            buildType = type;
        }

        public bool IsAlpha => buildType == "a";
        public bool IsPatch => buildType == "p";
    }
}

```

`AssetStudio/BundleFile.cs`:

```cs
using K4os.Compression.LZ4;
using System;
using System.IO;
using System.Linq;

namespace AssetStudio
{
    [Flags]
    public enum ArchiveFlags
    {
        CompressionTypeMask = 0x3f,
        BlocksAndDirectoryInfoCombined = 0x40,
        BlocksInfoAtTheEnd = 0x80,
        OldWebPluginCompatibility = 0x100,
        BlockInfoNeedPaddingAtStart = 0x200
    }

    [Flags]
    public enum StorageBlockFlags
    {
        CompressionTypeMask = 0x3f,
        Streamed = 0x40
    }

    public enum CompressionType
    {
        None,
        Lzma,
        Lz4,
        Lz4HC,
        Lzham
    }

    public class BundleFile
    {
        public class Header
        {
            public string signature;
            public uint version;
            public string unityVersion;
            public string unityRevision;
            public long size;
            public uint compressedBlocksInfoSize;
            public uint uncompressedBlocksInfoSize;
            public ArchiveFlags flags;
        }

        public class StorageBlock
        {
            public uint compressedSize;
            public uint uncompressedSize;
            public StorageBlockFlags flags;
        }

        public class Node
        {
            public long offset;
            public long size;
            public uint flags;
            public string path;
        }

        public Header m_Header;
        private StorageBlock[] m_BlocksInfo;
        private Node[] m_DirectoryInfo;

        public StreamFile[] fileList;

        public BundleFile(FileReader reader)
        {
            m_Header = new Header();
            m_Header.signature = reader.ReadStringToNull();
            m_Header.version = reader.ReadUInt32();
            m_Header.unityVersion = reader.ReadStringToNull();
            m_Header.unityRevision = reader.ReadStringToNull();
            switch (m_Header.signature)
            {
                case "UnityArchive":
                    break; //TODO
                case "UnityWeb":
                case "UnityRaw":
                    if (m_Header.version == 6)
                    {
                        goto case "UnityFS";
                    }
                    ReadHeaderAndBlocksInfo(reader);
                    using (var blocksStream = CreateBlocksStream(reader.FullPath))
                    {
                        ReadBlocksAndDirectory(reader, blocksStream);
                        ReadFiles(blocksStream, reader.FullPath);
                    }
                    break;
                case "UnityFS":
                    ReadHeader(reader);
                    ReadBlocksInfoAndDirectory(reader);
                    using (var blocksStream = CreateBlocksStream(reader.FullPath))
                    {
                        ReadBlocks(reader, blocksStream);
                        ReadFiles(blocksStream, reader.FullPath);
                    }
                    break;
            }
        }

        private void ReadHeaderAndBlocksInfo(EndianBinaryReader reader)
        {
            if (m_Header.version >= 4)
            {
                var hash = reader.ReadBytes(16);
                var crc = reader.ReadUInt32();
            }
            var minimumStreamedBytes = reader.ReadUInt32();
            m_Header.size = reader.ReadUInt32();
            var numberOfLevelsToDownloadBeforeStreaming = reader.ReadUInt32();
            var levelCount = reader.ReadInt32();
            m_BlocksInfo = new StorageBlock[1];
            for (int i = 0; i < levelCount; i++)
            {
                var storageBlock = new StorageBlock()
                {
                    compressedSize = reader.ReadUInt32(),
                    uncompressedSize = reader.ReadUInt32(),
                };
                if (i == levelCount - 1)
                {
                    m_BlocksInfo[0] = storageBlock;
                }
            }
            if (m_Header.version >= 2)
            {
                var completeFileSize = reader.ReadUInt32();
            }
            if (m_Header.version >= 3)
            {
                var fileInfoHeaderSize = reader.ReadUInt32();
            }
            reader.Position = m_Header.size;
        }

        private Stream CreateBlocksStream(string path)
        {
            Stream blocksStream;
            var uncompressedSizeSum = m_BlocksInfo.Sum(x => x.uncompressedSize);
            if (uncompressedSizeSum >= int.MaxValue)
            {
                /*var memoryMappedFile = MemoryMappedFile.CreateNew(null, uncompressedSizeSum);
                assetsDataStream = memoryMappedFile.CreateViewStream();*/
                blocksStream = new FileStream(path + ".temp", FileMode.Create, FileAccess.ReadWrite, FileShare.None, 4096, FileOptions.DeleteOnClose);
            }
            else
            {
                blocksStream = new MemoryStream((int)uncompressedSizeSum);
            }
            return blocksStream;
        }

        private void ReadBlocksAndDirectory(EndianBinaryReader reader, Stream blocksStream)
        {
            var isCompressed = m_Header.signature == "UnityWeb";
            foreach (var blockInfo in m_BlocksInfo)
            {
                var uncompressedBytes = reader.ReadBytes((int)blockInfo.compressedSize);
                if (isCompressed)
                {
                    using (var memoryStream = new MemoryStream(uncompressedBytes))
                    {
                        using (var decompressStream = SevenZipHelper.StreamDecompress(memoryStream))
                        {
                            uncompressedBytes = decompressStream.ToArray();
                        }
                    }
                }
                blocksStream.Write(uncompressedBytes, 0, uncompressedBytes.Length);
            }
            blocksStream.Position = 0;
            var blocksReader = new EndianBinaryReader(blocksStream);
            var nodesCount = blocksReader.ReadInt32();
            m_DirectoryInfo = new Node[nodesCount];
            for (int i = 0; i < nodesCount; i++)
            {
                m_DirectoryInfo[i] = new Node
                {
                    path = blocksReader.ReadStringToNull(),
                    offset = blocksReader.ReadUInt32(),
                    size = blocksReader.ReadUInt32()
                };
            }
        }

        public void ReadFiles(Stream blocksStream, string path)
        {
            fileList = new StreamFile[m_DirectoryInfo.Length];
            for (int i = 0; i < m_DirectoryInfo.Length; i++)
            {
                var node = m_DirectoryInfo[i];
                var file = new StreamFile();
                fileList[i] = file;
                file.path = node.path;
                file.fileName = Path.GetFileName(node.path);
                if (node.size >= int.MaxValue)
                {
                    /*var memoryMappedFile = MemoryMappedFile.CreateNew(null, entryinfo_size);
                    file.stream = memoryMappedFile.CreateViewStream();*/
                    var extractPath = path + "_unpacked" + Path.DirectorySeparatorChar;
                    Directory.CreateDirectory(extractPath);
                    file.stream = new FileStream(extractPath + file.fileName, FileMode.Create, FileAccess.ReadWrite, FileShare.ReadWrite);
                }
                else
                {
                    file.stream = new MemoryStream((int)node.size);
                }
                blocksStream.Position = node.offset;
                blocksStream.CopyTo(file.stream, node.size);
                file.stream.Position = 0;
            }
        }

        private void ReadHeader(EndianBinaryReader reader)
        {
            m_Header.size = reader.ReadInt64();
            m_Header.compressedBlocksInfoSize = reader.ReadUInt32();
            m_Header.uncompressedBlocksInfoSize = reader.ReadUInt32();
            m_Header.flags = (ArchiveFlags)reader.ReadUInt32();
            if (m_Header.signature != "UnityFS")
            {
                reader.ReadByte();
            }
        }

        private void ReadBlocksInfoAndDirectory(EndianBinaryReader reader)
        {
            byte[] blocksInfoBytes;
            if (m_Header.version >= 7)
            {
                reader.AlignStream(16);
            }
            if ((m_Header.flags & ArchiveFlags.BlocksInfoAtTheEnd) != 0)
            {
                var position = reader.Position;
                reader.Position = reader.BaseStream.Length - m_Header.compressedBlocksInfoSize;
                blocksInfoBytes = reader.ReadBytes((int)m_Header.compressedBlocksInfoSize);
                reader.Position = position;
            }
            else //0x40 BlocksAndDirectoryInfoCombined
            {
                blocksInfoBytes = reader.ReadBytes((int)m_Header.compressedBlocksInfoSize);
            }
            MemoryStream blocksInfoUncompresseddStream;
            var uncompressedSize = m_Header.uncompressedBlocksInfoSize;
            var compressionType = (CompressionType)(m_Header.flags & ArchiveFlags.CompressionTypeMask);
            switch (compressionType)
            {
                case CompressionType.None:
                    {
                        blocksInfoUncompresseddStream = new MemoryStream(blocksInfoBytes);
                        break;
                    }
                case CompressionType.Lzma:
                    {
                        blocksInfoUncompresseddStream = new MemoryStream((int)(uncompressedSize));
                        using (var blocksInfoCompressedStream = new MemoryStream(blocksInfoBytes))
                        {
                            SevenZipHelper.StreamDecompress(blocksInfoCompressedStream, blocksInfoUncompresseddStream, m_Header.compressedBlocksInfoSize, m_Header.uncompressedBlocksInfoSize);
                        }
                        blocksInfoUncompresseddStream.Position = 0;
                        break;
                    }
                case CompressionType.Lz4:
                case CompressionType.Lz4HC:
                    {
                        var uncompressedBytes = new byte[uncompressedSize];
                        var numWrite = LZ4Codec.Decode(blocksInfoBytes, uncompressedBytes);
                        if (numWrite != uncompressedSize)
                        {
                            throw new IOException($"Lz4 decompression error, write {numWrite} bytes but expected {uncompressedSize} bytes");
                        }
                        blocksInfoUncompresseddStream = new MemoryStream(uncompressedBytes);
                        break;
                    }
                default:
                    throw new IOException($"Unsupported compression type {compressionType}");
            }
            using (var blocksInfoReader = new EndianBinaryReader(blocksInfoUncompresseddStream))
            {
                var uncompressedDataHash = blocksInfoReader.ReadBytes(16);
                var blocksInfoCount = blocksInfoReader.ReadInt32();
                m_BlocksInfo = new StorageBlock[blocksInfoCount];
                for (int i = 0; i < blocksInfoCount; i++)
                {
                    m_BlocksInfo[i] = new StorageBlock
                    {
                        uncompressedSize = blocksInfoReader.ReadUInt32(),
                        compressedSize = blocksInfoReader.ReadUInt32(),
                        flags = (StorageBlockFlags)blocksInfoReader.ReadUInt16()
                    };
                }

                var nodesCount = blocksInfoReader.ReadInt32();
                m_DirectoryInfo = new Node[nodesCount];
                for (int i = 0; i < nodesCount; i++)
                {
                    m_DirectoryInfo[i] = new Node
                    {
                        offset = blocksInfoReader.ReadInt64(),
                        size = blocksInfoReader.ReadInt64(),
                        flags = blocksInfoReader.ReadUInt32(),
                        path = blocksInfoReader.ReadStringToNull(),
                    };
                }
            }
            if ((m_Header.flags & ArchiveFlags.BlockInfoNeedPaddingAtStart) != 0)
            {
                reader.AlignStream(16);
            }
        }

        private void ReadBlocks(EndianBinaryReader reader, Stream blocksStream)
        {
            foreach (var blockInfo in m_BlocksInfo)
            {
                var compressionType = (CompressionType)(blockInfo.flags & StorageBlockFlags.CompressionTypeMask);
                switch (compressionType)
                {
                    case CompressionType.None:
                        {
                            reader.BaseStream.CopyTo(blocksStream, blockInfo.compressedSize);
                            break;
                        }
                    case CompressionType.Lzma:
                        {
                            SevenZipHelper.StreamDecompress(reader.BaseStream, blocksStream, blockInfo.compressedSize, blockInfo.uncompressedSize);
                            break;
                        }
                    case CompressionType.Lz4:
                    case CompressionType.Lz4HC:
                        {
                            var compressedSize = (int)blockInfo.compressedSize;
                            var compressedBytes = BigArrayPool<byte>.Shared.Rent(compressedSize);
                            reader.Read(compressedBytes, 0, compressedSize);
                            var uncompressedSize = (int)blockInfo.uncompressedSize;
                            var uncompressedBytes = BigArrayPool<byte>.Shared.Rent(uncompressedSize);
                            var numWrite = LZ4Codec.Decode(compressedBytes, 0, compressedSize, uncompressedBytes, 0, uncompressedSize);
                            if (numWrite != uncompressedSize)
                            {
                                throw new IOException($"Lz4 decompression error, write {numWrite} bytes but expected {uncompressedSize} bytes");
                            }
                            blocksStream.Write(uncompressedBytes, 0, uncompressedSize);
                            BigArrayPool<byte>.Shared.Return(compressedBytes);
                            BigArrayPool<byte>.Shared.Return(uncompressedBytes);
                            break;
                        }
                    default:
                        throw new IOException($"Unsupported compression type {compressionType}");
                }
            }
            blocksStream.Position = 0;
        }
    }
}

```

`AssetStudio/ClassIDType.cs`:

```cs
// official Class ID Reference: https://docs.unity3d.com/Manual/ClassIDReference.html
namespace AssetStudio
{
    public enum ClassIDType
    {
        UnknownType = -1,
        Object = 0,
        GameObject = 1,
        Component = 2,
        LevelGameManager = 3,
        Transform = 4,
        TimeManager = 5,
        GlobalGameManager = 6,
        Behaviour = 8,
        GameManager = 9,
        AudioManager = 11,
        ParticleAnimator = 12,
        InputManager = 13,
        EllipsoidParticleEmitter = 15,
        Pipeline = 17,
        EditorExtension = 18,
        Physics2DSettings = 19,
        Camera = 20,
        Material = 21,
        MeshRenderer = 23,
        Renderer = 25,
        ParticleRenderer = 26,
        Texture = 27,
        Texture2D = 28,
        OcclusionCullingSettings = 29,
        GraphicsSettings = 30,
        MeshFilter = 33,
        OcclusionPortal = 41,
        Mesh = 43,
        Skybox = 45,
        QualitySettings = 47,
        Shader = 48,
        TextAsset = 49,
        Rigidbody2D = 50,
        Physics2DManager = 51,
        Collider2D = 53,
        Rigidbody = 54,
        PhysicsManager = 55,
        Collider = 56,
        Joint = 57,
        CircleCollider2D = 58,
        HingeJoint = 59,
        PolygonCollider2D = 60,
        BoxCollider2D = 61,
        PhysicsMaterial2D = 62,
        MeshCollider = 64,
        BoxCollider = 65,
        CompositeCollider2D = 66,
        EdgeCollider2D = 68,
        CapsuleCollider2D = 70,
        ComputeShader = 72,
        AnimationClip = 74,
        ConstantForce = 75,
        WorldParticleCollider = 76,
        TagManager = 78,
        AudioListener = 81,
        AudioSource = 82,
        AudioClip = 83,
        RenderTexture = 84,
        CustomRenderTexture = 86,
        MeshParticleEmitter = 87,
        ParticleEmitter = 88,
        Cubemap = 89,
        Avatar = 90,
        AnimatorController = 91,
        GUILayer = 92,
        RuntimeAnimatorController = 93,
        ScriptMapper = 94,
        Animator = 95,
        TrailRenderer = 96,
        DelayedCallManager = 98,
        TextMesh = 102,
        RenderSettings = 104,
        Light = 108,
        CGProgram = 109,
        BaseAnimationTrack = 110,
        Animation = 111,
        MonoBehaviour = 114,
        MonoScript = 115,
        MonoManager = 116,
        Texture3D = 117,
        NewAnimationTrack = 118,
        Projector = 119,
        LineRenderer = 120,
        Flare = 121,
        Halo = 122,
        LensFlare = 123,
        FlareLayer = 124,
        HaloLayer = 125,
        NavMeshAreas = 126,
        NavMeshProjectSettings = 126,
        HaloManager = 127,
        Font = 128,
        PlayerSettings = 129,
        NamedObject = 130,
        GUITexture = 131,
        GUIText = 132,
        GUIElement = 133,
        PhysicMaterial = 134,
        SphereCollider = 135,
        CapsuleCollider = 136,
        SkinnedMeshRenderer = 137,
        FixedJoint = 138,
        RaycastCollider = 140,
        BuildSettings = 141,
        AssetBundle = 142,
        CharacterController = 143,
        CharacterJoint = 144,
        SpringJoint = 145,
        WheelCollider = 146,
        ResourceManager = 147,
        NetworkView = 148,
        NetworkManager = 149,
        PreloadData = 150,
        MovieTexture = 152,
        ConfigurableJoint = 153,
        TerrainCollider = 154,
        MasterServerInterface = 155,
        TerrainData = 156,
        LightmapSettings = 157,
        WebCamTexture = 158,
        EditorSettings = 159,
        InteractiveCloth = 160,
        ClothRenderer = 161,
        EditorUserSettings = 162,
        SkinnedCloth = 163,
        AudioReverbFilter = 164,
        AudioHighPassFilter = 165,
        AudioChorusFilter = 166,
        AudioReverbZone = 167,
        AudioEchoFilter = 168,
        AudioLowPassFilter = 169,
        AudioDistortionFilter = 170,
        SparseTexture = 171,
        AudioBehaviour = 180,
        AudioFilter = 181,
        WindZone = 182,
        Cloth = 183,
        SubstanceArchive = 184,
        ProceduralMaterial = 185,
        ProceduralTexture = 186,
        Texture2DArray = 187,
        CubemapArray = 188,
        OffMeshLink = 191,
        OcclusionArea = 192,
        Tree = 193,
        NavMeshObsolete = 194,
        NavMeshAgent = 195,
        NavMeshSettings = 196,
        LightProbesLegacy = 197,
        ParticleSystem = 198,
        ParticleSystemRenderer = 199,
        ShaderVariantCollection = 200,
        LODGroup = 205,
        BlendTree = 206,
        Motion = 207,
        NavMeshObstacle = 208,
        SortingGroup = 210,
        SpriteRenderer = 212,
        Sprite = 213,
        CachedSpriteAtlas = 214,
        ReflectionProbe = 215,
        ReflectionProbes = 216,
        Terrain = 218,
        LightProbeGroup = 220,
        AnimatorOverrideController = 221,
        CanvasRenderer = 222,
        Canvas = 223,
        RectTransform = 224,
        CanvasGroup = 225,
        BillboardAsset = 226,
        BillboardRenderer = 227,
        SpeedTreeWindAsset = 228,
        AnchoredJoint2D = 229,
        Joint2D = 230,
        SpringJoint2D = 231,
        DistanceJoint2D = 232,
        HingeJoint2D = 233,
        SliderJoint2D = 234,
        WheelJoint2D = 235,
        ClusterInputManager = 236,
        BaseVideoTexture = 237,
        NavMeshData = 238,
        AudioMixer = 240,
        AudioMixerController = 241,
        AudioMixerGroupController = 243,
        AudioMixerEffectController = 244,
        AudioMixerSnapshotController = 245,
        PhysicsUpdateBehaviour2D = 246,
        ConstantForce2D = 247,
        Effector2D = 248,
        AreaEffector2D = 249,
        PointEffector2D = 250,
        PlatformEffector2D = 251,
        SurfaceEffector2D = 252,
        BuoyancyEffector2D = 253,
        RelativeJoint2D = 254,
        FixedJoint2D = 255,
        FrictionJoint2D = 256,
        TargetJoint2D = 257,
        LightProbes = 258,
        LightProbeProxyVolume = 259,
        SampleClip = 271,
        AudioMixerSnapshot = 272,
        AudioMixerGroup = 273,
        NScreenBridge = 280,
        AssetBundleManifest = 290,
        UnityAdsManager = 292,
        RuntimeInitializeOnLoadManager = 300,
        CloudWebServicesManager = 301,
        UnityAnalyticsManager = 303,
        CrashReportManager = 304,
        PerformanceReportingManager = 305,
        UnityConnectSettings = 310,
        AvatarMask = 319,
        PlayableDirector = 320,
        VideoPlayer = 328,
        VideoClip = 329,
        ParticleSystemForceField = 330,
        SpriteMask = 331,
        WorldAnchor = 362,
        OcclusionCullingData = 363,
        //kLargestRuntimeClassID = 364
        SmallestEditorClassID = 1000,
        PrefabInstance = 1001,
        EditorExtensionImpl = 1002,
        AssetImporter = 1003,
        AssetDatabaseV1 = 1004,
        Mesh3DSImporter = 1005,
        TextureImporter = 1006,
        ShaderImporter = 1007,
        ComputeShaderImporter = 1008,
        AudioImporter = 1020,
        HierarchyState = 1026,
        GUIDSerializer = 1027,
        AssetMetaData = 1028,
        DefaultAsset = 1029,
        DefaultImporter = 1030,
        TextScriptImporter = 1031,
        SceneAsset = 1032,
        NativeFormatImporter = 1034,
        MonoImporter = 1035,
        AssetServerCache = 1037,
        LibraryAssetImporter = 1038,
        ModelImporter = 1040,
        FBXImporter = 1041,
        TrueTypeFontImporter = 1042,
        MovieImporter = 1044,
        EditorBuildSettings = 1045,
        DDSImporter = 1046,
        InspectorExpandedState = 1048,
        AnnotationManager = 1049,
        PluginImporter = 1050,
        EditorUserBuildSettings = 1051,
        PVRImporter = 1052,
        ASTCImporter = 1053,
        KTXImporter = 1054,
        IHVImageFormatImporter = 1055,
        AnimatorStateTransition = 1101,
        AnimatorState = 1102,
        HumanTemplate = 1105,
        AnimatorStateMachine = 1107,
        PreviewAnimationClip = 1108,
        AnimatorTransition = 1109,
        SpeedTreeImporter = 1110,
        AnimatorTransitionBase = 1111,
        SubstanceImporter = 1112,
        LightmapParameters = 1113,
        LightingDataAsset = 1120,
        GISRaster = 1121,
        GISRasterImporter = 1122,
        CadImporter = 1123,
        SketchUpImporter = 1124,
        BuildReport = 1125,
        PackedAssets = 1126,
        VideoClipImporter = 1127,
        ActivationLogComponent = 2000,
        //kLargestEditorClassID = 2001
        //kClassIdOutOfHierarchy = 100000
        //int = 100000,
        //bool = 100001,
        //float = 100002,
        MonoObject = 100003,
        Collision = 100004,
        Vector3f = 100005,
        RootMotionData = 100006,
        Collision2D = 100007,
        AudioMixerLiveUpdateFloat = 100008,
        AudioMixerLiveUpdateBool = 100009,
        Polygon2D = 100010,
        //void = 100011,
        TilemapCollider2D = 19719996,
        AssetImporterLog = 41386430,
        VFXRenderer = 73398921,
        SerializableManagedRefTestClass = 76251197,
        Grid = 156049354,
        ScenesUsingAssets = 156483287,
        ArticulationBody = 171741748,
        Preset = 181963792,
        EmptyObject = 277625683,
        IConstraint = 285090594,
        TestObjectWithSpecialLayoutOne = 293259124,
        AssemblyDefinitionReferenceImporter = 294290339,
        SiblingDerived = 334799969,
        TestObjectWithSerializedMapStringNonAlignedStruct = 342846651,
        SubDerived = 367388927,
        AssetImportInProgressProxy = 369655926,
        PluginBuildInfo = 382020655,
        EditorProjectAccess = 426301858,
        PrefabImporter = 468431735,
        TestObjectWithSerializedArray = 478637458,
        TestObjectWithSerializedAnimationCurve = 478637459,
        TilemapRenderer = 483693784,
        ScriptableCamera = 488575907,
        SpriteAtlasAsset = 612988286,
        SpriteAtlasDatabase = 638013454,
        AudioBuildInfo = 641289076,
        CachedSpriteAtlasRuntimeData = 644342135,
        RendererFake = 646504946,
        AssemblyDefinitionReferenceAsset = 662584278,
        BuiltAssetBundleInfoSet = 668709126,
        SpriteAtlas = 687078895,
        RayTracingShaderImporter = 747330370,
        RayTracingShader = 825902497,
        LightingSettings = 850595691,
        PlatformModuleSetup = 877146078,
        VersionControlSettings = 890905787,
        AimConstraint = 895512359,
        VFXManager = 937362698,
        VisualEffectSubgraph = 994735392,
        VisualEffectSubgraphOperator = 994735403,
        VisualEffectSubgraphBlock = 994735404,
        LocalizationImporter = 1027052791,
        Derived = 1091556383,
        PropertyModificationsTargetTestObject = 1111377672,
        ReferencesArtifactGenerator = 1114811875,
        AssemblyDefinitionAsset = 1152215463,
        SceneVisibilityState = 1154873562,
        LookAtConstraint = 1183024399,
        SpriteAtlasImporter = 1210832254,
        MultiArtifactTestImporter = 1223240404,
        GameObjectRecorder = 1268269756,
        LightingDataAssetParent = 1325145578,
        PresetManager = 1386491679,
        TestObjectWithSpecialLayoutTwo = 1392443030,
        StreamingManager = 1403656975,
        LowerResBlitTexture = 1480428607,
        StreamingController = 1542919678,
        RenderPassAttachment = 1571458007,
        TestObjectVectorPairStringBool = 1628831178,
        GridLayout = 1742807556,
        AssemblyDefinitionImporter = 1766753193,
        ParentConstraint = 1773428102,
        FakeComponent = 1803986026,
        PositionConstraint = 1818360608,
        RotationConstraint = 1818360609,
        ScaleConstraint = 1818360610,
        Tilemap = 1839735485,
        PackageManifest = 1896753125,
        PackageManifestImporter = 1896753126,
        TerrainLayer = 1953259897,
        SpriteShapeRenderer = 1971053207,
        NativeObjectType = 1977754360,
        TestObjectWithSerializedMapStringBool = 1981279845,
        SerializableManagedHost = 1995898324,
        VisualEffectAsset = 2058629509,
        VisualEffectImporter = 2058629510,
        VisualEffectResource = 2058629511,
        VisualEffectObject = 2059678085,
        VisualEffect = 2083052967,
        LocalizationAsset = 2083778819,
        ScriptedImporter = 2089858483
    }
}

```

`AssetStudio/Classes/Animation.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class Animation : Behaviour
    {
        public PPtr<AnimationClip>[] m_Animations;

        public Animation(ObjectReader reader) : base(reader)
        {
            var m_Animation = new PPtr<AnimationClip>(reader);
            int numAnimations = reader.ReadInt32();
            m_Animations = new PPtr<AnimationClip>[numAnimations];
            for (int i = 0; i < numAnimations; i++)
            {
                m_Animations[i] = new PPtr<AnimationClip>(reader);
            }
        }
    }
}

```

`AssetStudio/Classes/AnimationClip.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace AssetStudio
{
    public class Keyframe<T>
    {
        public float time;
        public T value;
        public T inSlope;
        public T outSlope;
        public int weightedMode;
        public T inWeight;
        public T outWeight;


        public Keyframe(ObjectReader reader, Func<T> readerFunc)
        {
            time = reader.ReadSingle();
            value = readerFunc();
            inSlope = readerFunc();
            outSlope = readerFunc();
            if (reader.version[0] >= 2018) //2018 and up
            {
                weightedMode = reader.ReadInt32();
                inWeight = readerFunc();
                outWeight = readerFunc();
            }
        }
    }

    public class AnimationCurve<T>
    {
        public Keyframe<T>[] m_Curve;
        public int m_PreInfinity;
        public int m_PostInfinity;
        public int m_RotationOrder;

        public AnimationCurve(ObjectReader reader, Func<T> readerFunc)
        {
            var version = reader.version;
            int numCurves = reader.ReadInt32();
            m_Curve = new Keyframe<T>[numCurves];
            for (int i = 0; i < numCurves; i++)
            {
                m_Curve[i] = new Keyframe<T>(reader, readerFunc);
            }

            m_PreInfinity = reader.ReadInt32();
            m_PostInfinity = reader.ReadInt32();
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 3))//5.3 and up
            {
                m_RotationOrder = reader.ReadInt32();
            }
        }
    }

    public class QuaternionCurve
    {
        public AnimationCurve<Quaternion> curve;
        public string path;

        public QuaternionCurve(ObjectReader reader)
        {
            curve = new AnimationCurve<Quaternion>(reader, reader.ReadQuaternion);
            path = reader.ReadAlignedString();
        }
    }

    public class PackedFloatVector
    {
        public uint m_NumItems;
        public float m_Range;
        public float m_Start;
        public byte[] m_Data;
        public byte m_BitSize;

        public PackedFloatVector(ObjectReader reader)
        {
            m_NumItems = reader.ReadUInt32();
            m_Range = reader.ReadSingle();
            m_Start = reader.ReadSingle();

            int numData = reader.ReadInt32();
            m_Data = reader.ReadBytes(numData);
            reader.AlignStream();

            m_BitSize = reader.ReadByte();
            reader.AlignStream();
        }

        public float[] UnpackFloats(int itemCountInChunk, int chunkStride, int start = 0, int numChunks = -1)
        {
            int bitPos = m_BitSize * start;
            int indexPos = bitPos / 8;
            bitPos %= 8;

            float scale = 1.0f / m_Range;
            if (numChunks == -1)
                numChunks = (int)m_NumItems / itemCountInChunk;
            var end = chunkStride * numChunks / 4;
            var data = new List<float>();
            for (var index = 0; index != end; index += chunkStride / 4)
            {
                for (int i = 0; i < itemCountInChunk; ++i)
                {
                    uint x = 0;

                    int bits = 0;
                    while (bits < m_BitSize)
                    {
                        x |= (uint)((m_Data[indexPos] >> bitPos) << bits);
                        int num = Math.Min(m_BitSize - bits, 8 - bitPos);
                        bitPos += num;
                        bits += num;
                        if (bitPos == 8)
                        {
                            indexPos++;
                            bitPos = 0;
                        }
                    }
                    x &= (uint)(1 << m_BitSize) - 1u;
                    data.Add(x / (scale * ((1 << m_BitSize) - 1)) + m_Start);
                }
            }

            return data.ToArray();
        }
    }

    public class PackedIntVector
    {
        public uint m_NumItems;
        public byte[] m_Data;
        public byte m_BitSize;

        public PackedIntVector(ObjectReader reader)
        {
            m_NumItems = reader.ReadUInt32();

            int numData = reader.ReadInt32();
            m_Data = reader.ReadBytes(numData);
            reader.AlignStream();

            m_BitSize = reader.ReadByte();
            reader.AlignStream();
        }

        public int[] UnpackInts()
        {
            var data = new int[m_NumItems];
            int indexPos = 0;
            int bitPos = 0;
            for (int i = 0; i < m_NumItems; i++)
            {
                int bits = 0;
                data[i] = 0;
                while (bits < m_BitSize)
                {
                    data[i] |= (m_Data[indexPos] >> bitPos) << bits;
                    int num = Math.Min(m_BitSize - bits, 8 - bitPos);
                    bitPos += num;
                    bits += num;
                    if (bitPos == 8)
                    {
                        indexPos++;
                        bitPos = 0;
                    }
                }
                data[i] &= (1 << m_BitSize) - 1;
            }
            return data;
        }
    }

    public class PackedQuatVector
    {
        public uint m_NumItems;
        public byte[] m_Data;

        public PackedQuatVector(ObjectReader reader)
        {
            m_NumItems = reader.ReadUInt32();

            int numData = reader.ReadInt32();
            m_Data = reader.ReadBytes(numData);

            reader.AlignStream();
        }

        public Quaternion[] UnpackQuats()
        {
            var data = new Quaternion[m_NumItems];
            int indexPos = 0;
            int bitPos = 0;

            for (int i = 0; i < m_NumItems; i++)
            {
                uint flags = 0;

                int bits = 0;
                while (bits < 3)
                {
                    flags |= (uint)((m_Data[indexPos] >> bitPos) << bits);
                    int num = Math.Min(3 - bits, 8 - bitPos);
                    bitPos += num;
                    bits += num;
                    if (bitPos == 8)
                    {
                        indexPos++;
                        bitPos = 0;
                    }
                }
                flags &= 7;


                var q = new Quaternion();
                float sum = 0;
                for (int j = 0; j < 4; j++)
                {
                    if ((flags & 3) != j)
                    {
                        int bitSize = ((flags & 3) + 1) % 4 == j ? 9 : 10;
                        uint x = 0;

                        bits = 0;
                        while (bits < bitSize)
                        {
                            x |= (uint)((m_Data[indexPos] >> bitPos) << bits);
                            int num = Math.Min(bitSize - bits, 8 - bitPos);
                            bitPos += num;
                            bits += num;
                            if (bitPos == 8)
                            {
                                indexPos++;
                                bitPos = 0;
                            }
                        }
                        x &= (uint)((1 << bitSize) - 1);
                        q[j] = x / (0.5f * ((1 << bitSize) - 1)) - 1;
                        sum += q[j] * q[j];
                    }
                }

                int lastComponent = (int)(flags & 3);
                q[lastComponent] = (float)Math.Sqrt(1 - sum);
                if ((flags & 4) != 0u)
                    q[lastComponent] = -q[lastComponent];
                data[i] = q;
            }

            return data;
        }
    }

    public class CompressedAnimationCurve
    {
        public string m_Path;
        public PackedIntVector m_Times;
        public PackedQuatVector m_Values;
        public PackedFloatVector m_Slopes;
        public int m_PreInfinity;
        public int m_PostInfinity;

        public CompressedAnimationCurve(ObjectReader reader)
        {
            m_Path = reader.ReadAlignedString();
            m_Times = new PackedIntVector(reader);
            m_Values = new PackedQuatVector(reader);
            m_Slopes = new PackedFloatVector(reader);
            m_PreInfinity = reader.ReadInt32();
            m_PostInfinity = reader.ReadInt32();
        }
    }

    public class Vector3Curve
    {
        public AnimationCurve<Vector3> curve;
        public string path;

        public Vector3Curve(ObjectReader reader)
        {
            curve = new AnimationCurve<Vector3>(reader, reader.ReadVector3);
            path = reader.ReadAlignedString();
        }
    }

    public class FloatCurve
    {
        public AnimationCurve<float> curve;
        public string attribute;
        public string path;
        public ClassIDType classID;
        public PPtr<MonoScript> script;


        public FloatCurve(ObjectReader reader)
        {
            curve = new AnimationCurve<float>(reader, reader.ReadSingle);
            attribute = reader.ReadAlignedString();
            path = reader.ReadAlignedString();
            classID = (ClassIDType)reader.ReadInt32();
            script = new PPtr<MonoScript>(reader);
        }
    }

    public class PPtrKeyframe
    {
        public float time;
        public PPtr<Object> value;


        public PPtrKeyframe(ObjectReader reader)
        {
            time = reader.ReadSingle();
            value = new PPtr<Object>(reader);
        }
    }

    public class PPtrCurve
    {
        public PPtrKeyframe[] curve;
        public string attribute;
        public string path;
        public int classID;
        public PPtr<MonoScript> script;


        public PPtrCurve(ObjectReader reader)
        {
            int numCurves = reader.ReadInt32();
            curve = new PPtrKeyframe[numCurves];
            for (int i = 0; i < numCurves; i++)
            {
                curve[i] = new PPtrKeyframe(reader);
            }

            attribute = reader.ReadAlignedString();
            path = reader.ReadAlignedString();
            classID = reader.ReadInt32();
            script = new PPtr<MonoScript>(reader);
        }
    }

    public class AABB
    {
        public Vector3 m_Center;
        public Vector3 m_Extent;

        public AABB(ObjectReader reader)
        {
            m_Center = reader.ReadVector3();
            m_Extent = reader.ReadVector3();
        }
    }

    public class xform
    {
        public Vector3 t;
        public Quaternion q;
        public Vector3 s;

        public xform(ObjectReader reader)
        {
            var version = reader.version;
            t = version[0] > 5 || (version[0] == 5 && version[1] >= 4) ? reader.ReadVector3() : (Vector3)reader.ReadVector4();//5.4 and up
            q = reader.ReadQuaternion();
            s = version[0] > 5 || (version[0] == 5 && version[1] >= 4) ? reader.ReadVector3() : (Vector3)reader.ReadVector4();//5.4 and up
        }
    }

    public class HandPose
    {
        public xform m_GrabX;
        public float[] m_DoFArray;
        public float m_Override;
        public float m_CloseOpen;
        public float m_InOut;
        public float m_Grab;

        public HandPose(ObjectReader reader)
        {
            m_GrabX = new xform(reader);
            m_DoFArray = reader.ReadSingleArray();
            m_Override = reader.ReadSingle();
            m_CloseOpen = reader.ReadSingle();
            m_InOut = reader.ReadSingle();
            m_Grab = reader.ReadSingle();
        }
    }

    public class HumanGoal
    {
        public xform m_X;
        public float m_WeightT;
        public float m_WeightR;
        public Vector3 m_HintT;
        public float m_HintWeightT;

        public HumanGoal(ObjectReader reader)
        {
            var version = reader.version;
            m_X = new xform(reader);
            m_WeightT = reader.ReadSingle();
            m_WeightR = reader.ReadSingle();
            if (version[0] >= 5)//5.0 and up
            {
                m_HintT = version[0] > 5 || (version[0] == 5 && version[1] >= 4) ? reader.ReadVector3() : (Vector3)reader.ReadVector4();//5.4 and up
                m_HintWeightT = reader.ReadSingle();
            }
        }
    }

    public class HumanPose
    {
        public xform m_RootX;
        public Vector3 m_LookAtPosition;
        public Vector4 m_LookAtWeight;
        public HumanGoal[] m_GoalArray;
        public HandPose m_LeftHandPose;
        public HandPose m_RightHandPose;
        public float[] m_DoFArray;
        public Vector3[] m_TDoFArray;

        public HumanPose(ObjectReader reader)
        {
            var version = reader.version;
            m_RootX = new xform(reader);
            m_LookAtPosition = version[0] > 5 || (version[0] == 5 && version[1] >= 4) ? reader.ReadVector3() : (Vector3)reader.ReadVector4();//5.4 and up
            m_LookAtWeight = reader.ReadVector4();

            int numGoals = reader.ReadInt32();
            m_GoalArray = new HumanGoal[numGoals];
            for (int i = 0; i < numGoals; i++)
            {
                m_GoalArray[i] = new HumanGoal(reader);
            }

            m_LeftHandPose = new HandPose(reader);
            m_RightHandPose = new HandPose(reader);

            m_DoFArray = reader.ReadSingleArray();

            if (version[0] > 5 || (version[0] == 5 && version[1] >= 2))//5.2 and up
            {
                int numTDof = reader.ReadInt32();
                m_TDoFArray = new Vector3[numTDof];
                for (int i = 0; i < numTDof; i++)
                {
                    m_TDoFArray[i] = version[0] > 5 || (version[0] == 5 && version[1] >= 4) ? reader.ReadVector3() : (Vector3)reader.ReadVector4();//5.4 and up
                }
            }
        }
    }

    public class StreamedClip
    {
        public uint[] data;
        public uint curveCount;

        public StreamedClip(ObjectReader reader)
        {
            data = reader.ReadUInt32Array();
            curveCount = reader.ReadUInt32();
        }

        public class StreamedCurveKey
        {
            public int index;
            public float[] coeff;

            public float value;
            public float outSlope;
            public float inSlope;

            public StreamedCurveKey(BinaryReader reader)
            {
                index = reader.ReadInt32();
                coeff = reader.ReadSingleArray(4);

                outSlope = coeff[2];
                value = coeff[3];
            }

            public float CalculateNextInSlope(float dx, StreamedCurveKey rhs)
            {
                //Stepped
                if (coeff[0] == 0f && coeff[1] == 0f && coeff[2] == 0f)
                {
                    return float.PositiveInfinity;
                }

                dx = Math.Max(dx, 0.0001f);
                var dy = rhs.value - value;
                var length = 1.0f / (dx * dx);
                var d1 = outSlope * dx;
                var d2 = dy + dy + dy - d1 - d1 - coeff[1] / length;
                return d2 / dx;
            }
        }

        public class StreamedFrame
        {
            public float time;
            public StreamedCurveKey[] keyList;

            public StreamedFrame(BinaryReader reader)
            {
                time = reader.ReadSingle();

                int numKeys = reader.ReadInt32();
                keyList = new StreamedCurveKey[numKeys];
                for (int i = 0; i < numKeys; i++)
                {
                    keyList[i] = new StreamedCurveKey(reader);
                }
            }
        }

        public List<StreamedFrame> ReadData()
        {
            var frameList = new List<StreamedFrame>();
            var buffer = new byte[data.Length * 4];
            Buffer.BlockCopy(data, 0, buffer, 0, buffer.Length);
            using (var reader = new BinaryReader(new MemoryStream(buffer)))
            {
                while (reader.BaseStream.Position < reader.BaseStream.Length)
                {
                    frameList.Add(new StreamedFrame(reader));
                }
            }

            for (int frameIndex = 2; frameIndex < frameList.Count - 1; frameIndex++)
            {
                var frame = frameList[frameIndex];
                foreach (var curveKey in frame.keyList)
                {
                    for (int i = frameIndex - 1; i >= 0; i--)
                    {
                        var preFrame = frameList[i];
                        var preCurveKey = preFrame.keyList.FirstOrDefault(x => x.index == curveKey.index);
                        if (preCurveKey != null)
                        {
                            curveKey.inSlope = preCurveKey.CalculateNextInSlope(frame.time - preFrame.time, curveKey);
                            break;
                        }
                    }
                }
            }
            return frameList;
        }
    }

    public class DenseClip
    {
        public int m_FrameCount;
        public uint m_CurveCount;
        public float m_SampleRate;
        public float m_BeginTime;
        public float[] m_SampleArray;

        public DenseClip(ObjectReader reader)
        {
            m_FrameCount = reader.ReadInt32();
            m_CurveCount = reader.ReadUInt32();
            m_SampleRate = reader.ReadSingle();
            m_BeginTime = reader.ReadSingle();
            m_SampleArray = reader.ReadSingleArray();
        }
    }

    public class ConstantClip
    {
        public float[] data;

        public ConstantClip(ObjectReader reader)
        {
            data = reader.ReadSingleArray();
        }
    }

    public class ValueConstant
    {
        public uint m_ID;
        public uint m_TypeID;
        public uint m_Type;
        public uint m_Index;

        public ValueConstant(ObjectReader reader)
        {
            var version = reader.version;
            m_ID = reader.ReadUInt32();
            if (version[0] < 5 || (version[0] == 5 && version[1] < 5))//5.5 down
            {
                m_TypeID = reader.ReadUInt32();
            }
            m_Type = reader.ReadUInt32();
            m_Index = reader.ReadUInt32();
        }
    }

    public class ValueArrayConstant
    {
        public ValueConstant[] m_ValueArray;

        public ValueArrayConstant(ObjectReader reader)
        {
            int numVals = reader.ReadInt32();
            m_ValueArray = new ValueConstant[numVals];
            for (int i = 0; i < numVals; i++)
            {
                m_ValueArray[i] = new ValueConstant(reader);
            }
        }
    }

    public class Clip
    {
        public StreamedClip m_StreamedClip;
        public DenseClip m_DenseClip;
        public ConstantClip m_ConstantClip;
        public ValueArrayConstant m_Binding;

        public Clip(ObjectReader reader)
        {
            var version = reader.version;
            m_StreamedClip = new StreamedClip(reader);
            m_DenseClip = new DenseClip(reader);
            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                m_ConstantClip = new ConstantClip(reader);
            }
            if (version[0] < 2018 || (version[0] == 2018 && version[1] < 3)) //2018.3 down
            {
                m_Binding = new ValueArrayConstant(reader);
            }
        }

        public AnimationClipBindingConstant ConvertValueArrayToGenericBinding()
        {
            var bindings = new AnimationClipBindingConstant();
            var genericBindings = new List<GenericBinding>();
            var values = m_Binding;
            for (int i = 0; i < values.m_ValueArray.Length;)
            {
                var curveID = values.m_ValueArray[i].m_ID;
                var curveTypeID = values.m_ValueArray[i].m_TypeID;
                var binding = new GenericBinding();
                genericBindings.Add(binding);
                if (curveTypeID == 4174552735) //CRC(PositionX))
                {
                    binding.path = curveID;
                    binding.attribute = 1; //kBindTransformPosition
                    binding.typeID = ClassIDType.Transform;
                    i += 3;
                }
                else if (curveTypeID == 2211994246) //CRC(QuaternionX))
                {
                    binding.path = curveID;
                    binding.attribute = 2; //kBindTransformRotation
                    binding.typeID = ClassIDType.Transform;
                    i += 4;
                }
                else if (curveTypeID == 1512518241) //CRC(ScaleX))
                {
                    binding.path = curveID;
                    binding.attribute = 3; //kBindTransformScale
                    binding.typeID = ClassIDType.Transform;
                    i += 3;
                }
                else
                {
                    binding.typeID = ClassIDType.Animator;
                    binding.path = 0;
                    binding.attribute = curveID;
                    i++;
                }
            }
            bindings.genericBindings = genericBindings.ToArray();
            return bindings;
        }
    }

    public class ValueDelta
    {
        public float m_Start;
        public float m_Stop;

        public ValueDelta(ObjectReader reader)
        {
            m_Start = reader.ReadSingle();
            m_Stop = reader.ReadSingle();
        }
    }

    public class ClipMuscleConstant
    {
        public HumanPose m_DeltaPose;
        public xform m_StartX;
        public xform m_StopX;
        public xform m_LeftFootStartX;
        public xform m_RightFootStartX;
        public xform m_MotionStartX;
        public xform m_MotionStopX;
        public Vector3 m_AverageSpeed;
        public Clip m_Clip;
        public float m_StartTime;
        public float m_StopTime;
        public float m_OrientationOffsetY;
        public float m_Level;
        public float m_CycleOffset;
        public float m_AverageAngularSpeed;
        public int[] m_IndexArray;
        public ValueDelta[] m_ValueArrayDelta;
        public float[] m_ValueArrayReferencePose;
        public bool m_Mirror;
        public bool m_LoopTime;
        public bool m_LoopBlend;
        public bool m_LoopBlendOrientation;
        public bool m_LoopBlendPositionY;
        public bool m_LoopBlendPositionXZ;
        public bool m_StartAtOrigin;
        public bool m_KeepOriginalOrientation;
        public bool m_KeepOriginalPositionY;
        public bool m_KeepOriginalPositionXZ;
        public bool m_HeightFromFeet;

        public ClipMuscleConstant(ObjectReader reader)
        {
            var version = reader.version;
            m_DeltaPose = new HumanPose(reader);
            m_StartX = new xform(reader);
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 5))//5.5 and up
            {
                m_StopX = new xform(reader);
            }
            m_LeftFootStartX = new xform(reader);
            m_RightFootStartX = new xform(reader);
            if (version[0] < 5)//5.0 down
            {
                m_MotionStartX = new xform(reader);
                m_MotionStopX = new xform(reader);
            }
            m_AverageSpeed = version[0] > 5 || (version[0] == 5 && version[1] >= 4) ? reader.ReadVector3() : (Vector3)reader.ReadVector4();//5.4 and up
            m_Clip = new Clip(reader);
            m_StartTime = reader.ReadSingle();
            m_StopTime = reader.ReadSingle();
            m_OrientationOffsetY = reader.ReadSingle();
            m_Level = reader.ReadSingle();
            m_CycleOffset = reader.ReadSingle();
            m_AverageAngularSpeed = reader.ReadSingle();

            m_IndexArray = reader.ReadInt32Array();
            if (version[0] < 4 || (version[0] == 4 && version[1] < 3)) //4.3 down
            {
                var m_AdditionalCurveIndexArray = reader.ReadInt32Array();
            }
            int numDeltas = reader.ReadInt32();
            m_ValueArrayDelta = new ValueDelta[numDeltas];
            for (int i = 0; i < numDeltas; i++)
            {
                m_ValueArrayDelta[i] = new ValueDelta(reader);
            }
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 3))//5.3 and up
            {
                m_ValueArrayReferencePose = reader.ReadSingleArray();
            }

            m_Mirror = reader.ReadBoolean();
            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                m_LoopTime = reader.ReadBoolean();
            }
            m_LoopBlend = reader.ReadBoolean();
            m_LoopBlendOrientation = reader.ReadBoolean();
            m_LoopBlendPositionY = reader.ReadBoolean();
            m_LoopBlendPositionXZ = reader.ReadBoolean();
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 5))//5.5 and up
            {
                m_StartAtOrigin = reader.ReadBoolean();
            }
            m_KeepOriginalOrientation = reader.ReadBoolean();
            m_KeepOriginalPositionY = reader.ReadBoolean();
            m_KeepOriginalPositionXZ = reader.ReadBoolean();
            m_HeightFromFeet = reader.ReadBoolean();
            reader.AlignStream();
        }
    }

    public class GenericBinding
    {
        public uint path;
        public uint attribute;
        public PPtr<Object> script;
        public ClassIDType typeID;
        public byte customType;
        public byte isPPtrCurve;
        public byte isIntCurve;

        public GenericBinding() { }

        public GenericBinding(ObjectReader reader)
        {
            var version = reader.version;
            path = reader.ReadUInt32();
            attribute = reader.ReadUInt32();
            script = new PPtr<Object>(reader);
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 6)) //5.6 and up
            {
                typeID = (ClassIDType)reader.ReadInt32();
            }
            else
            {
                typeID = (ClassIDType)reader.ReadUInt16();
            }
            customType = reader.ReadByte();
            isPPtrCurve = reader.ReadByte();
            if (version[0] > 2022 || (version[0] == 2022 && version[1] >= 1)) //2022.1 and up
            {
                isIntCurve = reader.ReadByte();
            }
            reader.AlignStream();
        }
    }

    public class AnimationClipBindingConstant
    {
        public GenericBinding[] genericBindings;
        public PPtr<Object>[] pptrCurveMapping;

        public AnimationClipBindingConstant() { }

        public AnimationClipBindingConstant(ObjectReader reader)
        {
            int numBindings = reader.ReadInt32();
            genericBindings = new GenericBinding[numBindings];
            for (int i = 0; i < numBindings; i++)
            {
                genericBindings[i] = new GenericBinding(reader);
            }

            int numMappings = reader.ReadInt32();
            pptrCurveMapping = new PPtr<Object>[numMappings];
            for (int i = 0; i < numMappings; i++)
            {
                pptrCurveMapping[i] = new PPtr<Object>(reader);
            }
        }

        public GenericBinding FindBinding(int index)
        {
            int curves = 0;
            foreach (var b in genericBindings)
            {
                if (b.typeID == ClassIDType.Transform)
                {
                    switch (b.attribute)
                    {
                        case 1: //kBindTransformPosition
                        case 3: //kBindTransformScale
                        case 4: //kBindTransformEuler
                            curves += 3;
                            break;
                        case 2: //kBindTransformRotation
                            curves += 4;
                            break;
                        default:
                            curves += 1;
                            break;
                    }
                }
                else
                {
                    curves += 1;
                }
                if (curves > index)
                {
                    return b;
                }
            }

            return null;
        }
    }

    public class AnimationEvent
    {
        public float time;
        public string functionName;
        public string data;
        public PPtr<Object> objectReferenceParameter;
        public float floatParameter;
        public int intParameter;
        public int messageOptions;

        public AnimationEvent(ObjectReader reader)
        {
            var version = reader.version;

            time = reader.ReadSingle();
            functionName = reader.ReadAlignedString();
            data = reader.ReadAlignedString();
            objectReferenceParameter = new PPtr<Object>(reader);
            floatParameter = reader.ReadSingle();
            if (version[0] >= 3) //3 and up
            {
                intParameter = reader.ReadInt32();
            }
            messageOptions = reader.ReadInt32();
        }
    }

    public enum AnimationType
    {
        Legacy = 1,
        Generic = 2,
        Humanoid = 3
    };

    public sealed class AnimationClip : NamedObject
    {
        public AnimationType m_AnimationType;
        public bool m_Legacy;
        public bool m_Compressed;
        public bool m_UseHighQualityCurve;
        public QuaternionCurve[] m_RotationCurves;
        public CompressedAnimationCurve[] m_CompressedRotationCurves;
        public Vector3Curve[] m_EulerCurves;
        public Vector3Curve[] m_PositionCurves;
        public Vector3Curve[] m_ScaleCurves;
        public FloatCurve[] m_FloatCurves;
        public PPtrCurve[] m_PPtrCurves;
        public float m_SampleRate;
        public int m_WrapMode;
        public AABB m_Bounds;
        public uint m_MuscleClipSize;
        public ClipMuscleConstant m_MuscleClip;
        public AnimationClipBindingConstant m_ClipBindingConstant;
        public AnimationEvent[] m_Events;


        public AnimationClip(ObjectReader reader) : base(reader)
        {
            if (version[0] >= 5)//5.0 and up
            {
                m_Legacy = reader.ReadBoolean();
            }
            else if (version[0] >= 4)//4.0 and up
            {
                m_AnimationType = (AnimationType)reader.ReadInt32();
                if (m_AnimationType == AnimationType.Legacy)
                    m_Legacy = true;
            }
            else
            {
                m_Legacy = true;
            }
            m_Compressed = reader.ReadBoolean();
            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3))//4.3 and up
            {
                m_UseHighQualityCurve = reader.ReadBoolean();
            }
            reader.AlignStream();
            int numRCurves = reader.ReadInt32();
            m_RotationCurves = new QuaternionCurve[numRCurves];
            for (int i = 0; i < numRCurves; i++)
            {
                m_RotationCurves[i] = new QuaternionCurve(reader);
            }

            int numCRCurves = reader.ReadInt32();
            m_CompressedRotationCurves = new CompressedAnimationCurve[numCRCurves];
            for (int i = 0; i < numCRCurves; i++)
            {
                m_CompressedRotationCurves[i] = new CompressedAnimationCurve(reader);
            }

            if (version[0] > 5 || (version[0] == 5 && version[1] >= 3))//5.3 and up
            {
                int numEulerCurves = reader.ReadInt32();
                m_EulerCurves = new Vector3Curve[numEulerCurves];
                for (int i = 0; i < numEulerCurves; i++)
                {
                    m_EulerCurves[i] = new Vector3Curve(reader);
                }
            }

            int numPCurves = reader.ReadInt32();
            m_PositionCurves = new Vector3Curve[numPCurves];
            for (int i = 0; i < numPCurves; i++)
            {
                m_PositionCurves[i] = new Vector3Curve(reader);
            }

            int numSCurves = reader.ReadInt32();
            m_ScaleCurves = new Vector3Curve[numSCurves];
            for (int i = 0; i < numSCurves; i++)
            {
                m_ScaleCurves[i] = new Vector3Curve(reader);
            }

            int numFCurves = reader.ReadInt32();
            m_FloatCurves = new FloatCurve[numFCurves];
            for (int i = 0; i < numFCurves; i++)
            {
                m_FloatCurves[i] = new FloatCurve(reader);
            }

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                int numPtrCurves = reader.ReadInt32();
                m_PPtrCurves = new PPtrCurve[numPtrCurves];
                for (int i = 0; i < numPtrCurves; i++)
                {
                    m_PPtrCurves[i] = new PPtrCurve(reader);
                }
            }

            m_SampleRate = reader.ReadSingle();
            m_WrapMode = reader.ReadInt32();
            if (version[0] > 3 || (version[0] == 3 && version[1] >= 4)) //3.4 and up
            {
                m_Bounds = new AABB(reader);
            }
            if (version[0] >= 4)//4.0 and up
            {
                m_MuscleClipSize = reader.ReadUInt32();
                m_MuscleClip = new ClipMuscleConstant(reader);
            }
            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                m_ClipBindingConstant = new AnimationClipBindingConstant(reader);
            }
            if (version[0] > 2018 || (version[0] == 2018 && version[1] >= 3)) //2018.3 and up
            {
                var m_HasGenericRootTransform = reader.ReadBoolean();
                var m_HasMotionFloatCurves = reader.ReadBoolean();
                reader.AlignStream();
            }
            int numEvents = reader.ReadInt32();
            m_Events = new AnimationEvent[numEvents];
            for (int i = 0; i < numEvents; i++)
            {
                m_Events[i] = new AnimationEvent(reader);
            }
            if (version[0] >= 2017) //2017 and up
            {
                reader.AlignStream();
            }
        }
    }
}

```

`AssetStudio/Classes/Animator.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class Animator : Behaviour
    {
        public PPtr<Avatar> m_Avatar;
        public PPtr<RuntimeAnimatorController> m_Controller;
        public bool m_HasTransformHierarchy = true;

        public Animator(ObjectReader reader) : base(reader)
        {
            m_Avatar = new PPtr<Avatar>(reader);
            m_Controller = new PPtr<RuntimeAnimatorController>(reader);
            var m_CullingMode = reader.ReadInt32();

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 5)) //4.5 and up
            {
                var m_UpdateMode = reader.ReadInt32();
            }

            var m_ApplyRootMotion = reader.ReadBoolean();
            if (version[0] == 4 && version[1] >= 5) //4.5 and up - 5.0 down
            {
                reader.AlignStream();
            }

            if (version[0] >= 5) //5.0 and up
            {
                var m_LinearVelocityBlending = reader.ReadBoolean();
                if (version[0] > 2021 || (version[0] == 2021 && version[1] >= 2)) //2021.2 and up
                {
                    var m_StabilizeFeet = reader.ReadBoolean();
                }
                reader.AlignStream();
            }

            if (version[0] < 4 || (version[0] == 4 && version[1] < 5)) //4.5 down
            {
                var m_AnimatePhysics = reader.ReadBoolean();
            }

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                m_HasTransformHierarchy = reader.ReadBoolean();
            }

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 5)) //4.5 and up
            {
                var m_AllowConstantClipSamplingOptimization = reader.ReadBoolean();
            }
            if (version[0] >= 5 && version[0] < 2018) //5.0 and up - 2018 down
            {
                reader.AlignStream();
            }

            if (version[0] >= 2018) //2018 and up
            {
                var m_KeepAnimatorControllerStateOnDisable = reader.ReadBoolean();
                reader.AlignStream();
            }
        }
    }
}

```

`AssetStudio/Classes/AnimatorController.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class HumanPoseMask
    {
        public uint word0;
        public uint word1;
        public uint word2;

        public HumanPoseMask(ObjectReader reader)
        {
            var version = reader.version;

            word0 = reader.ReadUInt32();
            word1 = reader.ReadUInt32();
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 2)) //5.2 and up
            {
                word2 = reader.ReadUInt32();
            }
        }
    }

    public class SkeletonMaskElement
    {
        public uint m_PathHash;
        public float m_Weight;

        public SkeletonMaskElement(ObjectReader reader)
        {
            m_PathHash = reader.ReadUInt32();
            m_Weight = reader.ReadSingle();
        }
    }

    public class SkeletonMask
    {
        public SkeletonMaskElement[] m_Data;

        public SkeletonMask(ObjectReader reader)
        {
            int numElements = reader.ReadInt32();
            m_Data = new SkeletonMaskElement[numElements];
            for (int i = 0; i < numElements; i++)
            {
                m_Data[i] = new SkeletonMaskElement(reader);
            }
        }
    }

    public class LayerConstant
    {
        public uint m_StateMachineIndex;
        public uint m_StateMachineMotionSetIndex;
        public HumanPoseMask m_BodyMask;
        public SkeletonMask m_SkeletonMask;
        public uint m_Binding;
        public int m_LayerBlendingMode;
        public float m_DefaultWeight;
        public bool m_IKPass;
        public bool m_SyncedLayerAffectsTiming;

        public LayerConstant(ObjectReader reader)
        {
            var version = reader.version;

            m_StateMachineIndex = reader.ReadUInt32();
            m_StateMachineMotionSetIndex = reader.ReadUInt32();
            m_BodyMask = new HumanPoseMask(reader);
            m_SkeletonMask = new SkeletonMask(reader);
            m_Binding = reader.ReadUInt32();
            m_LayerBlendingMode = reader.ReadInt32();
            if (version[0] > 4 || (version[0] == 4 && version[1] >= 2)) //4.2 and up
            {
                m_DefaultWeight = reader.ReadSingle();
            }
            m_IKPass = reader.ReadBoolean();
            if (version[0] > 4 || (version[0] == 4 && version[1] >= 2)) //4.2 and up
            {
                m_SyncedLayerAffectsTiming = reader.ReadBoolean();
            }
            reader.AlignStream();
        }
    }

    public class ConditionConstant
    {
        public uint m_ConditionMode;
        public uint m_EventID;
        public float m_EventThreshold;
        public float m_ExitTime;

        public ConditionConstant(ObjectReader reader)
        {
            m_ConditionMode = reader.ReadUInt32();
            m_EventID = reader.ReadUInt32();
            m_EventThreshold = reader.ReadSingle();
            m_ExitTime = reader.ReadSingle();
        }
    }

    public class TransitionConstant
    {
        public ConditionConstant[] m_ConditionConstantArray;
        public uint m_DestinationState;
        public uint m_FullPathID;
        public uint m_ID;
        public uint m_UserID;
        public float m_TransitionDuration;
        public float m_TransitionOffset;
        public float m_ExitTime;
        public bool m_HasExitTime;
        public bool m_HasFixedDuration;
        public int m_InterruptionSource;
        public bool m_OrderedInterruption;
        public bool m_Atomic;
        public bool m_CanTransitionToSelf;

        public TransitionConstant(ObjectReader reader)
        {
            var version = reader.version;

            int numConditions = reader.ReadInt32();
            m_ConditionConstantArray = new ConditionConstant[numConditions];
            for (int i = 0; i < numConditions; i++)
            {
                m_ConditionConstantArray[i] = new ConditionConstant(reader);
            }

            m_DestinationState = reader.ReadUInt32();
            if (version[0] >= 5) //5.0 and up
            {
                m_FullPathID = reader.ReadUInt32();
            }

            m_ID = reader.ReadUInt32();
            m_UserID = reader.ReadUInt32();
            m_TransitionDuration = reader.ReadSingle();
            m_TransitionOffset = reader.ReadSingle();
            if (version[0] >= 5) //5.0 and up
            {
                m_ExitTime = reader.ReadSingle();
                m_HasExitTime = reader.ReadBoolean();
                m_HasFixedDuration = reader.ReadBoolean();
                reader.AlignStream();
                m_InterruptionSource = reader.ReadInt32();
                m_OrderedInterruption = reader.ReadBoolean();
            }
            else
            {
                m_Atomic = reader.ReadBoolean();
            }

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 5)) //4.5 and up
            {
                m_CanTransitionToSelf = reader.ReadBoolean();
            }

            reader.AlignStream();
        }
    }

    public class LeafInfoConstant
    {
        public uint[] m_IDArray;
        public uint m_IndexOffset;

        public LeafInfoConstant(ObjectReader reader)
        {
            m_IDArray = reader.ReadUInt32Array();
            m_IndexOffset = reader.ReadUInt32();
        }
    }

    public class MotionNeighborList
    {
        public uint[] m_NeighborArray;

        public MotionNeighborList(ObjectReader reader)
        {
            m_NeighborArray = reader.ReadUInt32Array();
        }
    }

    public class Blend2dDataConstant
    {
        public Vector2[] m_ChildPositionArray;
        public float[] m_ChildMagnitudeArray;
        public Vector2[] m_ChildPairVectorArray;
        public float[] m_ChildPairAvgMagInvArray;
        public MotionNeighborList[] m_ChildNeighborListArray;

        public Blend2dDataConstant(ObjectReader reader)
        {
            m_ChildPositionArray = reader.ReadVector2Array();
            m_ChildMagnitudeArray = reader.ReadSingleArray();
            m_ChildPairVectorArray = reader.ReadVector2Array();
            m_ChildPairAvgMagInvArray = reader.ReadSingleArray();

            int numNeighbours = reader.ReadInt32();
            m_ChildNeighborListArray = new MotionNeighborList[numNeighbours];
            for (int i = 0; i < numNeighbours; i++)
            {
                m_ChildNeighborListArray[i] = new MotionNeighborList(reader);
            }
        }
    }

    public class Blend1dDataConstant // wrong labeled
    {
        public float[] m_ChildThresholdArray;

        public Blend1dDataConstant(ObjectReader reader)
        {
            m_ChildThresholdArray = reader.ReadSingleArray();
        }
    }

    public class BlendDirectDataConstant
    {
        public uint[] m_ChildBlendEventIDArray;
        public bool m_NormalizedBlendValues;

        public BlendDirectDataConstant(ObjectReader reader)
        {
            m_ChildBlendEventIDArray = reader.ReadUInt32Array();
            m_NormalizedBlendValues = reader.ReadBoolean();
            reader.AlignStream();
        }
    }

    public class BlendTreeNodeConstant
    {
        public uint m_BlendType;
        public uint m_BlendEventID;
        public uint m_BlendEventYID;
        public uint[] m_ChildIndices;
        public float[] m_ChildThresholdArray;
        public Blend1dDataConstant m_Blend1dData;
        public Blend2dDataConstant m_Blend2dData;
        public BlendDirectDataConstant m_BlendDirectData;
        public uint m_ClipID;
        public uint m_ClipIndex;
        public float m_Duration;
        public float m_CycleOffset;
        public bool m_Mirror;

        public BlendTreeNodeConstant(ObjectReader reader)
        {
            var version = reader.version;

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 1)) //4.1 and up
            {
                m_BlendType = reader.ReadUInt32();
            }
            m_BlendEventID = reader.ReadUInt32();
            if (version[0] > 4 || (version[0] == 4 && version[1] >= 1)) //4.1 and up
            {
                m_BlendEventYID = reader.ReadUInt32();
            }
            m_ChildIndices = reader.ReadUInt32Array();
            if (version[0] < 4 || (version[0] == 4 && version[1] < 1)) //4.1 down
            {
                m_ChildThresholdArray = reader.ReadSingleArray();
            }

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 1)) //4.1 and up
            {
                m_Blend1dData = new Blend1dDataConstant(reader);
                m_Blend2dData = new Blend2dDataConstant(reader);
            }

            if (version[0] >= 5) //5.0 and up
            {
                m_BlendDirectData = new BlendDirectDataConstant(reader);
            }

            m_ClipID = reader.ReadUInt32();
            if (version[0] == 4 && version[1] >= 5) //4.5 - 5.0
            {
                m_ClipIndex = reader.ReadUInt32();
            }

            m_Duration = reader.ReadSingle();

            if (version[0] > 4
                || (version[0] == 4 && version[1] > 1)
                || (version[0] == 4 && version[1] == 1 && version[2] >= 3)) //4.1.3 and up
            {
                m_CycleOffset = reader.ReadSingle();
                m_Mirror = reader.ReadBoolean();
                reader.AlignStream();
            }
        }
    }

    public class BlendTreeConstant
    {
        public BlendTreeNodeConstant[] m_NodeArray;
        public ValueArrayConstant m_BlendEventArrayConstant;

        public BlendTreeConstant(ObjectReader reader)
        {
            var version = reader.version;

            int numNodes = reader.ReadInt32();
            m_NodeArray = new BlendTreeNodeConstant[numNodes];
            for (int i = 0; i < numNodes; i++)
            {
                m_NodeArray[i] = new BlendTreeNodeConstant(reader);
            }

            if (version[0] < 4 || (version[0] == 4 && version[1] < 5)) //4.5 down
            {
                m_BlendEventArrayConstant = new ValueArrayConstant(reader);
            }
        }
    }


    public class StateConstant
    {
        public TransitionConstant[] m_TransitionConstantArray;
        public int[] m_BlendTreeConstantIndexArray;
        public LeafInfoConstant[] m_LeafInfoArray;
        public BlendTreeConstant[] m_BlendTreeConstantArray;
        public uint m_NameID;
        public uint m_PathID;
        public uint m_FullPathID;
        public uint m_TagID;
        public uint m_SpeedParamID;
        public uint m_MirrorParamID;
        public uint m_CycleOffsetParamID;
        public float m_Speed;
        public float m_CycleOffset;
        public bool m_IKOnFeet;
        public bool m_WriteDefaultValues;
        public bool m_Loop;
        public bool m_Mirror;

        public StateConstant(ObjectReader reader)
        {
            var version = reader.version;

            int numTransistions = reader.ReadInt32();
            m_TransitionConstantArray = new TransitionConstant[numTransistions];
            for (int i = 0; i < numTransistions; i++)
            {
                m_TransitionConstantArray[i] = new TransitionConstant(reader);
            }

            m_BlendTreeConstantIndexArray = reader.ReadInt32Array();

            if (version[0] < 5 || (version[0] == 5 && version[1] < 2)) //5.2 down
            {
                int numInfos = reader.ReadInt32();
                m_LeafInfoArray = new LeafInfoConstant[numInfos];
                for (int i = 0; i < numInfos; i++)
                {
                    m_LeafInfoArray[i] = new LeafInfoConstant(reader);
                }
            }

            int numBlends = reader.ReadInt32();
            m_BlendTreeConstantArray = new BlendTreeConstant[numBlends];
            for (int i = 0; i < numBlends; i++)
            {
                m_BlendTreeConstantArray[i] = new BlendTreeConstant(reader);
            }

            m_NameID = reader.ReadUInt32();
            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                m_PathID = reader.ReadUInt32();
            }
            if (version[0] >= 5) //5.0 and up
            {
                m_FullPathID = reader.ReadUInt32();
            }

            m_TagID = reader.ReadUInt32();
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 1)) //5.1 and up
            {
                m_SpeedParamID = reader.ReadUInt32();
                m_MirrorParamID = reader.ReadUInt32();
                m_CycleOffsetParamID = reader.ReadUInt32();
            }

            if (version[0] > 2017 || (version[0] == 2017 && version[1] >= 2)) //2017.2 and up
            {
                var m_TimeParamID = reader.ReadUInt32();
            }

            m_Speed = reader.ReadSingle();
            if (version[0] > 4 || (version[0] == 4 && version[1] >= 1)) //4.1 and up
            {
                m_CycleOffset = reader.ReadSingle();
            }
            m_IKOnFeet = reader.ReadBoolean();
            if (version[0] >= 5) //5.0 and up
            {
                m_WriteDefaultValues = reader.ReadBoolean();
            }

            m_Loop = reader.ReadBoolean();
            if (version[0] > 4 || (version[0] == 4 && version[1] >= 1)) //4.1 and up
            {
                m_Mirror = reader.ReadBoolean();
            }

            reader.AlignStream();
        }
    }

    public class SelectorTransitionConstant
    {
        public uint m_Destination;
        public ConditionConstant[] m_ConditionConstantArray;

        public SelectorTransitionConstant(ObjectReader reader)
        {
            m_Destination = reader.ReadUInt32();

            int numConditions = reader.ReadInt32();
            m_ConditionConstantArray = new ConditionConstant[numConditions];
            for (int i = 0; i < numConditions; i++)
            {
                m_ConditionConstantArray[i] = new ConditionConstant(reader);
            }
        }
    }

    public class SelectorStateConstant
    {
        public SelectorTransitionConstant[] m_TransitionConstantArray;
        public uint m_FullPathID;
        public bool m_isEntry;

        public SelectorStateConstant(ObjectReader reader)
        {
            int numTransitions = reader.ReadInt32();
            m_TransitionConstantArray = new SelectorTransitionConstant[numTransitions];
            for (int i = 0; i < numTransitions; i++)
            {
                m_TransitionConstantArray[i] = new SelectorTransitionConstant(reader);
            }

            m_FullPathID = reader.ReadUInt32();
            m_isEntry = reader.ReadBoolean();
            reader.AlignStream();
        }
    }

    public class StateMachineConstant
    {
        public StateConstant[] m_StateConstantArray;
        public TransitionConstant[] m_AnyStateTransitionConstantArray;
        public SelectorStateConstant[] m_SelectorStateConstantArray;
        public uint m_DefaultState;
        public uint m_MotionSetCount;

        public StateMachineConstant(ObjectReader reader)
        {
            var version = reader.version;

            int numStates = reader.ReadInt32();
            m_StateConstantArray = new StateConstant[numStates];
            for (int i = 0; i < numStates; i++)
            {
                m_StateConstantArray[i] = new StateConstant(reader);
            }

            int numAnyStates = reader.ReadInt32();
            m_AnyStateTransitionConstantArray = new TransitionConstant[numAnyStates];
            for (int i = 0; i < numAnyStates; i++)
            {
                m_AnyStateTransitionConstantArray[i] = new TransitionConstant(reader);
            }

            if (version[0] >= 5) //5.0 and up
            {
                int numSelectors = reader.ReadInt32();
                m_SelectorStateConstantArray = new SelectorStateConstant[numSelectors];
                for (int i = 0; i < numSelectors; i++)
                {
                    m_SelectorStateConstantArray[i] = new SelectorStateConstant(reader);
                }
            }

            m_DefaultState = reader.ReadUInt32();
            m_MotionSetCount = reader.ReadUInt32();
        }
    }

    public class ValueArray
    {
        public bool[] m_BoolValues;
        public int[] m_IntValues;
        public float[] m_FloatValues;
        public Vector4[] m_VectorValues;
        public Vector3[] m_PositionValues;
        public Vector4[] m_QuaternionValues;
        public Vector3[] m_ScaleValues;

        public ValueArray(ObjectReader reader)
        {
            var version = reader.version;

            if (version[0] < 5 || (version[0] == 5 && version[1] < 5)) //5.5 down
            {
                m_BoolValues = reader.ReadBooleanArray();
                reader.AlignStream();
                m_IntValues = reader.ReadInt32Array();
                m_FloatValues = reader.ReadSingleArray();
            }

            if (version[0] < 4 || (version[0] == 4 && version[1] < 3)) //4.3 down
            {
                m_VectorValues = reader.ReadVector4Array();
            }
            else
            {
                int numPosValues = reader.ReadInt32();
                m_PositionValues = new Vector3[numPosValues];
                for (int i = 0; i < numPosValues; i++)
                {
                    m_PositionValues[i] = version[0] > 5 || (version[0] == 5 && version[1] >= 4) ? reader.ReadVector3() : (Vector3)reader.ReadVector4(); //5.4 and up
                }

                m_QuaternionValues = reader.ReadVector4Array();

                int numScaleValues = reader.ReadInt32();
                m_ScaleValues = new Vector3[numScaleValues];
                for (int i = 0; i < numScaleValues; i++)
                {
                    m_ScaleValues[i] = version[0] > 5 || (version[0] == 5 && version[1] >= 4) ? reader.ReadVector3() : (Vector3)reader.ReadVector4(); //5.4 and up
                }

                if (version[0] > 5 || (version[0] == 5 && version[1] >= 5)) //5.5 and up
                {
                    m_FloatValues = reader.ReadSingleArray();
                    m_IntValues = reader.ReadInt32Array();
                    m_BoolValues = reader.ReadBooleanArray();
                    reader.AlignStream();
                }
            }
        }
    }

    public class ControllerConstant
    {
        public LayerConstant[] m_LayerArray;
        public StateMachineConstant[] m_StateMachineArray;
        public ValueArrayConstant m_Values;
        public ValueArray m_DefaultValues;

        public ControllerConstant(ObjectReader reader)
        {
            int numLayers = reader.ReadInt32();
            m_LayerArray = new LayerConstant[numLayers];
            for (int i = 0; i < numLayers; i++)
            {
                m_LayerArray[i] = new LayerConstant(reader);
            }

            int numStates = reader.ReadInt32();
            m_StateMachineArray = new StateMachineConstant[numStates];
            for (int i = 0; i < numStates; i++)
            {
                m_StateMachineArray[i] = new StateMachineConstant(reader);
            }

            m_Values = new ValueArrayConstant(reader);
            m_DefaultValues = new ValueArray(reader);
        }
    }

    public sealed class AnimatorController : RuntimeAnimatorController
    {
        public PPtr<AnimationClip>[] m_AnimationClips;

        public AnimatorController(ObjectReader reader) : base(reader)
        {
            var m_ControllerSize = reader.ReadUInt32();
            var m_Controller = new ControllerConstant(reader);

            int tosSize = reader.ReadInt32();
            var m_TOS = new KeyValuePair<uint, string>[tosSize];
            for (int i = 0; i < tosSize; i++)
            {
                m_TOS[i] = new KeyValuePair<uint, string>(reader.ReadUInt32(), reader.ReadAlignedString());
            }

            int numClips = reader.ReadInt32();
            m_AnimationClips = new PPtr<AnimationClip>[numClips];
            for (int i = 0; i < numClips; i++)
            {
                m_AnimationClips[i] = new PPtr<AnimationClip>(reader);
            }
        }
    }
}

```

`AssetStudio/Classes/AnimatorOverrideController.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class AnimationClipOverride
    {
        public PPtr<AnimationClip> m_OriginalClip;
        public PPtr<AnimationClip> m_OverrideClip;

        public AnimationClipOverride(ObjectReader reader)
        {
            m_OriginalClip = new PPtr<AnimationClip>(reader);
            m_OverrideClip = new PPtr<AnimationClip>(reader);
        }
    }

    public sealed class AnimatorOverrideController : RuntimeAnimatorController
    {
        public PPtr<RuntimeAnimatorController> m_Controller;
        public AnimationClipOverride[] m_Clips;

        public AnimatorOverrideController(ObjectReader reader) : base(reader)
        {
            m_Controller = new PPtr<RuntimeAnimatorController>(reader);

            int numOverrides = reader.ReadInt32();
            m_Clips = new AnimationClipOverride[numOverrides];
            for (int i = 0; i < numOverrides; i++)
            {
                m_Clips[i] = new AnimationClipOverride(reader);
            }
        }
    }
}

```

`AssetStudio/Classes/AssetBundle.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class AssetInfo
    {
        public int preloadIndex;
        public int preloadSize;
        public PPtr<Object> asset;

        public AssetInfo(ObjectReader reader)
        {
            preloadIndex = reader.ReadInt32();
            preloadSize = reader.ReadInt32();
            asset = new PPtr<Object>(reader);
        }
    }

    public sealed class AssetBundle : NamedObject
    {
        public PPtr<Object>[] m_PreloadTable;
        public KeyValuePair<string, AssetInfo>[] m_Container;

        public AssetBundle(ObjectReader reader) : base(reader)
        {
            var m_PreloadTableSize = reader.ReadInt32();
            m_PreloadTable = new PPtr<Object>[m_PreloadTableSize];
            for (int i = 0; i < m_PreloadTableSize; i++)
            {
                m_PreloadTable[i] = new PPtr<Object>(reader);
            }

            var m_ContainerSize = reader.ReadInt32();
            m_Container = new KeyValuePair<string, AssetInfo>[m_ContainerSize];
            for (int i = 0; i < m_ContainerSize; i++)
            {
                m_Container[i] = new KeyValuePair<string, AssetInfo>(reader.ReadAlignedString(), new AssetInfo(reader));
            }
        }
    }
}

```

`AssetStudio/Classes/AudioClip.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class AudioClip : NamedObject
    {
        public int m_Format;
        public FMODSoundType m_Type;
        public bool m_3D;
        public bool m_UseHardware;

        //version 5
        public int m_LoadType;
        public int m_Channels;
        public int m_Frequency;
        public int m_BitsPerSample;
        public float m_Length;
        public bool m_IsTrackerFormat;
        public int m_SubsoundIndex;
        public bool m_PreloadAudioData;
        public bool m_LoadInBackground;
        public bool m_Legacy3D;
        public AudioCompressionFormat m_CompressionFormat;

        public string m_Source;
        public long m_Offset; //ulong
        public long m_Size; //ulong
        public ResourceReader m_AudioData;

        public AudioClip(ObjectReader reader) : base(reader)
        {
            if (version[0] < 5)
            {
                m_Format = reader.ReadInt32();
                m_Type = (FMODSoundType)reader.ReadInt32();
                m_3D = reader.ReadBoolean();
                m_UseHardware = reader.ReadBoolean();
                reader.AlignStream();

                if (version[0] >= 4 || (version[0] == 3 && version[1] >= 2)) //3.2.0 to 5
                {
                    int m_Stream = reader.ReadInt32();
                    m_Size = reader.ReadInt32();
                    var tsize = m_Size % 4 != 0 ? m_Size + 4 - m_Size % 4 : m_Size;
                    if (reader.byteSize + reader.byteStart - reader.Position != tsize)
                    {
                        m_Offset = reader.ReadUInt32();
                        m_Source = assetsFile.fullName + ".resS";
                    }
                }
                else
                {
                    m_Size = reader.ReadInt32();
                }
            }
            else
            {
                m_LoadType = reader.ReadInt32();
                m_Channels = reader.ReadInt32();
                m_Frequency = reader.ReadInt32();
                m_BitsPerSample = reader.ReadInt32();
                m_Length = reader.ReadSingle();
                m_IsTrackerFormat = reader.ReadBoolean();
                reader.AlignStream();
                m_SubsoundIndex = reader.ReadInt32();
                m_PreloadAudioData = reader.ReadBoolean();
                m_LoadInBackground = reader.ReadBoolean();
                m_Legacy3D = reader.ReadBoolean();
                reader.AlignStream();

                //StreamedResource m_Resource
                m_Source = reader.ReadAlignedString();
                m_Offset = reader.ReadInt64();
                m_Size = reader.ReadInt64();
                m_CompressionFormat = (AudioCompressionFormat)reader.ReadInt32();
            }

            ResourceReader resourceReader;
            if (!string.IsNullOrEmpty(m_Source))
            {
                resourceReader = new ResourceReader(m_Source, assetsFile, m_Offset, m_Size);
            }
            else
            {
                resourceReader = new ResourceReader(reader, reader.BaseStream.Position, m_Size);
            }
            m_AudioData = resourceReader;
        }
    }

    public enum FMODSoundType
    {
        UNKNOWN = 0,
        ACC = 1,
        AIFF = 2,
        ASF = 3,
        AT3 = 4,
        CDDA = 5,
        DLS = 6,
        FLAC = 7,
        FSB = 8,
        GCADPCM = 9,
        IT = 10,
        MIDI = 11,
        MOD = 12,
        MPEG = 13,
        OGGVORBIS = 14,
        PLAYLIST = 15,
        RAW = 16,
        S3M = 17,
        SF2 = 18,
        USER = 19,
        WAV = 20,
        XM = 21,
        XMA = 22,
        VAG = 23,
        AUDIOQUEUE = 24,
        XWMA = 25,
        BCWAV = 26,
        AT9 = 27,
        VORBIS = 28,
        MEDIA_FOUNDATION = 29
    }

    public enum AudioCompressionFormat
    {
        PCM = 0,
        Vorbis = 1,
        ADPCM = 2,
        MP3 = 3,
        PSMVAG = 4,
        HEVAG = 5,
        XMA = 6,
        AAC = 7,
        GCADPCM = 8,
        ATRAC9 = 9
    }
}

```

`AssetStudio/Classes/Avatar.cs`:

```cs
using System.Collections.Generic;
using System.Linq;

namespace AssetStudio
{
    public class Node
    {
        public int m_ParentId;
        public int m_AxesId;

        public Node(ObjectReader reader)
        {
            m_ParentId = reader.ReadInt32();
            m_AxesId = reader.ReadInt32();
        }
    }

    public class Limit
    {
        public object m_Min;
        public object m_Max;

        public Limit(ObjectReader reader)
        {
            var version = reader.version;
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 4))//5.4 and up
            {
                m_Min = reader.ReadVector3();
                m_Max = reader.ReadVector3();
            }
            else
            {
                m_Min = reader.ReadVector4();
                m_Max = reader.ReadVector4();
            }
        }
    }

    public class Axes
    {
        public Vector4 m_PreQ;
        public Vector4 m_PostQ;
        public object m_Sgn;
        public Limit m_Limit;
        public float m_Length;
        public uint m_Type;

        public Axes(ObjectReader reader)
        {
            var version = reader.version;
            m_PreQ = reader.ReadVector4();
            m_PostQ = reader.ReadVector4();
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 4)) //5.4 and up
            {
                m_Sgn = reader.ReadVector3();
            }
            else
            {
                m_Sgn = reader.ReadVector4();
            }
            m_Limit = new Limit(reader);
            m_Length = reader.ReadSingle();
            m_Type = reader.ReadUInt32();
        }
    }

    public class Skeleton
    {
        public Node[] m_Node;
        public uint[] m_ID;
        public Axes[] m_AxesArray;


        public Skeleton(ObjectReader reader)
        {
            int numNodes = reader.ReadInt32();
            m_Node = new Node[numNodes];
            for (int i = 0; i < numNodes; i++)
            {
                m_Node[i] = new Node(reader);
            }

            m_ID = reader.ReadUInt32Array();

            int numAxes = reader.ReadInt32();
            m_AxesArray = new Axes[numAxes];
            for (int i = 0; i < numAxes; i++)
            {
                m_AxesArray[i] = new Axes(reader);
            }
        }
    }

    public class SkeletonPose
    {
        public xform[] m_X;

        public SkeletonPose(ObjectReader reader)
        {
            int numXforms = reader.ReadInt32();
            m_X = new xform[numXforms];
            for (int i = 0; i < numXforms; i++)
            {
                m_X[i] = new xform(reader);
            }
        }
    }

    public class Hand
    {
        public int[] m_HandBoneIndex;

        public Hand(ObjectReader reader)
        {
            m_HandBoneIndex = reader.ReadInt32Array();
        }
    }

    public class Handle
    {
        public xform m_X;
        public uint m_ParentHumanIndex;
        public uint m_ID;

        public Handle(ObjectReader reader)
        {
            m_X = new xform(reader);
            m_ParentHumanIndex = reader.ReadUInt32();
            m_ID = reader.ReadUInt32();
        }
    }

    public class Collider
    {
        public xform m_X;
        public uint m_Type;
        public uint m_XMotionType;
        public uint m_YMotionType;
        public uint m_ZMotionType;
        public float m_MinLimitX;
        public float m_MaxLimitX;
        public float m_MaxLimitY;
        public float m_MaxLimitZ;

        public Collider(ObjectReader reader)
        {
            m_X = new xform(reader);
            m_Type = reader.ReadUInt32();
            m_XMotionType = reader.ReadUInt32();
            m_YMotionType = reader.ReadUInt32();
            m_ZMotionType = reader.ReadUInt32();
            m_MinLimitX = reader.ReadSingle();
            m_MaxLimitX = reader.ReadSingle();
            m_MaxLimitY = reader.ReadSingle();
            m_MaxLimitZ = reader.ReadSingle();
        }
    }

    public class Human
    {
        public xform m_RootX;
        public Skeleton m_Skeleton;
        public SkeletonPose m_SkeletonPose;
        public Hand m_LeftHand;
        public Hand m_RightHand;
        public Handle[] m_Handles;
        public Collider[] m_ColliderArray;
        public int[] m_HumanBoneIndex;
        public float[] m_HumanBoneMass;
        public int[] m_ColliderIndex;
        public float m_Scale;
        public float m_ArmTwist;
        public float m_ForeArmTwist;
        public float m_UpperLegTwist;
        public float m_LegTwist;
        public float m_ArmStretch;
        public float m_LegStretch;
        public float m_FeetSpacing;
        public bool m_HasLeftHand;
        public bool m_HasRightHand;
        public bool m_HasTDoF;

        public Human(ObjectReader reader)
        {
            var version = reader.version;
            m_RootX = new xform(reader);
            m_Skeleton = new Skeleton(reader);
            m_SkeletonPose = new SkeletonPose(reader);
            m_LeftHand = new Hand(reader);
            m_RightHand = new Hand(reader);

            if (version[0] < 2018 || (version[0] == 2018 && version[1] < 2)) //2018.2 down
            {
                int numHandles = reader.ReadInt32();
                m_Handles = new Handle[numHandles];
                for (int i = 0; i < numHandles; i++)
                {
                    m_Handles[i] = new Handle(reader);
                }

                int numColliders = reader.ReadInt32();
                m_ColliderArray = new Collider[numColliders];
                for (int i = 0; i < numColliders; i++)
                {
                    m_ColliderArray[i] = new Collider(reader);
                }
            }

            m_HumanBoneIndex = reader.ReadInt32Array();

            m_HumanBoneMass = reader.ReadSingleArray();

            if (version[0] < 2018 || (version[0] == 2018 && version[1] < 2)) //2018.2 down
            {
                m_ColliderIndex = reader.ReadInt32Array();
            }

            m_Scale = reader.ReadSingle();
            m_ArmTwist = reader.ReadSingle();
            m_ForeArmTwist = reader.ReadSingle();
            m_UpperLegTwist = reader.ReadSingle();
            m_LegTwist = reader.ReadSingle();
            m_ArmStretch = reader.ReadSingle();
            m_LegStretch = reader.ReadSingle();
            m_FeetSpacing = reader.ReadSingle();
            m_HasLeftHand = reader.ReadBoolean();
            m_HasRightHand = reader.ReadBoolean();
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 2)) //5.2 and up
            {
                m_HasTDoF = reader.ReadBoolean();
            }
            reader.AlignStream();
        }
    }

    public class AvatarConstant
    {
        public Skeleton m_AvatarSkeleton;
        public SkeletonPose m_AvatarSkeletonPose;
        public SkeletonPose m_DefaultPose;
        public uint[] m_SkeletonNameIDArray;
        public Human m_Human;
        public int[] m_HumanSkeletonIndexArray;
        public int[] m_HumanSkeletonReverseIndexArray;
        public int m_RootMotionBoneIndex;
        public xform m_RootMotionBoneX;
        public Skeleton m_RootMotionSkeleton;
        public SkeletonPose m_RootMotionSkeletonPose;
        public int[] m_RootMotionSkeletonIndexArray;

        public AvatarConstant(ObjectReader reader)
        {
            var version = reader.version;
            m_AvatarSkeleton = new Skeleton(reader);
            m_AvatarSkeletonPose = new SkeletonPose(reader);

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                m_DefaultPose = new SkeletonPose(reader);

                m_SkeletonNameIDArray = reader.ReadUInt32Array();
            }

            m_Human = new Human(reader);

            m_HumanSkeletonIndexArray = reader.ReadInt32Array();

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                m_HumanSkeletonReverseIndexArray = reader.ReadInt32Array();
            }

            m_RootMotionBoneIndex = reader.ReadInt32();
            m_RootMotionBoneX = new xform(reader);

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                m_RootMotionSkeleton = new Skeleton(reader);
                m_RootMotionSkeletonPose = new SkeletonPose(reader);

                m_RootMotionSkeletonIndexArray = reader.ReadInt32Array();
            }
        }
    }

    public sealed class Avatar : NamedObject
    {
        public uint m_AvatarSize;
        public AvatarConstant m_Avatar;
        public KeyValuePair<uint, string>[] m_TOS;

        public Avatar(ObjectReader reader) : base(reader)
        {
            m_AvatarSize = reader.ReadUInt32();
            m_Avatar = new AvatarConstant(reader);

            int numTOS = reader.ReadInt32();
            m_TOS = new KeyValuePair<uint, string>[numTOS];
            for (int i = 0; i < numTOS; i++)
            {
                m_TOS[i] = new KeyValuePair<uint, string>(reader.ReadUInt32(), reader.ReadAlignedString());
            }

            //HumanDescription m_HumanDescription 2019 and up
        }

        public string FindBonePath(uint hash)
        {
            return m_TOS.FirstOrDefault(pair => pair.Key == hash).Value;
        }
    }
}

```

`AssetStudio/Classes/Behaviour.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public abstract class Behaviour : Component
    {
        public byte m_Enabled;

        protected Behaviour(ObjectReader reader) : base(reader)
        {
            m_Enabled = reader.ReadByte();
            reader.AlignStream();
        }
    }
}

```

`AssetStudio/Classes/BuildSettings.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class BuildSettings : Object
    {
        public string m_Version;

        public BuildSettings(ObjectReader reader) : base(reader)
        {
            var levels = reader.ReadStringArray();

            var hasRenderTexture = reader.ReadBoolean();
            var hasPROVersion = reader.ReadBoolean();
            var hasPublishingRights = reader.ReadBoolean();
            var hasShadows = reader.ReadBoolean();

            m_Version = reader.ReadAlignedString();
        }
    }
}

```

`AssetStudio/Classes/Component.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public abstract class Component : EditorExtension
    {
        public PPtr<GameObject> m_GameObject;

        protected Component(ObjectReader reader) : base(reader)
        {
            m_GameObject = new PPtr<GameObject>(reader);
        }
    }
}

```

`AssetStudio/Classes/EditorExtension.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public abstract class EditorExtension : Object
    {
        protected EditorExtension(ObjectReader reader) : base(reader)
        {
            if (platform == BuildTarget.NoTarget)
            {
                var m_PrefabParentObject = new PPtr<EditorExtension>(reader);
                var m_PrefabInternal = new PPtr<Object>(reader); //PPtr<Prefab>
            }
        }
    }
}

```

`AssetStudio/Classes/Font.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class Font : NamedObject
    {
        public byte[] m_FontData;

        public Font(ObjectReader reader) : base(reader)
        {
            if ((version[0] == 5 && version[1] >= 5) || version[0] > 5)//5.5 and up
            {
                var m_LineSpacing = reader.ReadSingle();
                var m_DefaultMaterial = new PPtr<Material>(reader);
                var m_FontSize = reader.ReadSingle();
                var m_Texture = new PPtr<Texture>(reader);
                int m_AsciiStartOffset = reader.ReadInt32();
                var m_Tracking = reader.ReadSingle();
                var m_CharacterSpacing = reader.ReadInt32();
                var m_CharacterPadding = reader.ReadInt32();
                var m_ConvertCase = reader.ReadInt32();
                int m_CharacterRects_size = reader.ReadInt32();
                for (int i = 0; i < m_CharacterRects_size; i++)
                {
                    reader.Position += 44;//CharacterInfo data 41
                }
                int m_KerningValues_size = reader.ReadInt32();
                for (int i = 0; i < m_KerningValues_size; i++)
                {
                    reader.Position += 8;
                }
                var m_PixelScale = reader.ReadSingle();
                int m_FontData_size = reader.ReadInt32();
                if (m_FontData_size > 0)
                {
                    m_FontData = reader.ReadBytes(m_FontData_size);
                }
            }
            else
            {
                int m_AsciiStartOffset = reader.ReadInt32();

                if (version[0] <= 3)
                {
                    int m_FontCountX = reader.ReadInt32();
                    int m_FontCountY = reader.ReadInt32();
                }

                float m_Kerning = reader.ReadSingle();
                float m_LineSpacing = reader.ReadSingle();

                if (version[0] <= 3)
                {
                    int m_PerCharacterKerning_size = reader.ReadInt32();
                    for (int i = 0; i < m_PerCharacterKerning_size; i++)
                    {
                        int first = reader.ReadInt32();
                        float second = reader.ReadSingle();
                    }
                }
                else
                {
                    int m_CharacterSpacing = reader.ReadInt32();
                    int m_CharacterPadding = reader.ReadInt32();
                }

                int m_ConvertCase = reader.ReadInt32();
                var m_DefaultMaterial = new PPtr<Material>(reader);

                int m_CharacterRects_size = reader.ReadInt32();
                for (int i = 0; i < m_CharacterRects_size; i++)
                {
                    int index = reader.ReadInt32();
                    //Rectf uv
                    float uvx = reader.ReadSingle();
                    float uvy = reader.ReadSingle();
                    float uvwidth = reader.ReadSingle();
                    float uvheight = reader.ReadSingle();
                    //Rectf vert
                    float vertx = reader.ReadSingle();
                    float verty = reader.ReadSingle();
                    float vertwidth = reader.ReadSingle();
                    float vertheight = reader.ReadSingle();
                    float width = reader.ReadSingle();

                    if (version[0] >= 4)
                    {
                        var flipped = reader.ReadBoolean();
                        reader.AlignStream();
                    }
                }

                var m_Texture = new PPtr<Texture>(reader);

                int m_KerningValues_size = reader.ReadInt32();
                for (int i = 0; i < m_KerningValues_size; i++)
                {
                    int pairfirst = reader.ReadInt16();
                    int pairsecond = reader.ReadInt16();
                    float second = reader.ReadSingle();
                }

                if (version[0] <= 3)
                {
                    var m_GridFont = reader.ReadBoolean();
                    reader.AlignStream();
                }
                else { float m_PixelScale = reader.ReadSingle(); }

                int m_FontData_size = reader.ReadInt32();
                if (m_FontData_size > 0)
                {
                    m_FontData = reader.ReadBytes(m_FontData_size);
                }
            }
        }
    }
}

```

`AssetStudio/Classes/GameObject.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class GameObject : EditorExtension
    {
        public PPtr<Component>[] m_Components;
        public string m_Name;

        public Transform m_Transform;
        public MeshRenderer m_MeshRenderer;
        public MeshFilter m_MeshFilter;
        public SkinnedMeshRenderer m_SkinnedMeshRenderer;
        public Animator m_Animator;
        public Animation m_Animation;

        public GameObject(ObjectReader reader) : base(reader)
        {
            int m_Component_size = reader.ReadInt32();
            m_Components = new PPtr<Component>[m_Component_size];
            for (int i = 0; i < m_Component_size; i++)
            {
                if ((version[0] == 5 && version[1] < 5) || version[0] < 5) //5.5 down
                {
                    int first = reader.ReadInt32();
                }
                m_Components[i] = new PPtr<Component>(reader);
            }

            var m_Layer = reader.ReadInt32();
            m_Name = reader.ReadAlignedString();
        }
    }
}

```

`AssetStudio/Classes/Material.cs`:

```cs
using System.Collections.Generic;

namespace AssetStudio
{
    public class UnityTexEnv
    {
        public PPtr<Texture> m_Texture;
        public Vector2 m_Scale;
        public Vector2 m_Offset;

        public UnityTexEnv(ObjectReader reader)
        {
            m_Texture = new PPtr<Texture>(reader);
            m_Scale = reader.ReadVector2();
            m_Offset = reader.ReadVector2();
        }
    }

    public class UnityPropertySheet
    {
        public KeyValuePair<string, UnityTexEnv>[] m_TexEnvs;
        public KeyValuePair<string, int>[] m_Ints;
        public KeyValuePair<string, float>[] m_Floats;
        public KeyValuePair<string, Color>[] m_Colors;

        public UnityPropertySheet(ObjectReader reader)
        {
            var version = reader.version;

            int m_TexEnvsSize = reader.ReadInt32();
            m_TexEnvs = new KeyValuePair<string, UnityTexEnv>[m_TexEnvsSize];
            for (int i = 0; i < m_TexEnvsSize; i++)
            {
                m_TexEnvs[i] = new KeyValuePair<string, UnityTexEnv>(reader.ReadAlignedString(), new UnityTexEnv(reader));
            }

            if (version[0] >= 2021) //2021.1 and up
            {
                int m_IntsSize = reader.ReadInt32();
                m_Ints = new KeyValuePair<string, int>[m_IntsSize];
                for (int i = 0; i < m_IntsSize; i++)
                {
                    m_Ints[i] = new KeyValuePair<string, int>(reader.ReadAlignedString(), reader.ReadInt32());
                }
            }

            int m_FloatsSize = reader.ReadInt32();
            m_Floats = new KeyValuePair<string, float>[m_FloatsSize];
            for (int i = 0; i < m_FloatsSize; i++)
            {
                m_Floats[i] = new KeyValuePair<string, float>(reader.ReadAlignedString(), reader.ReadSingle());
            }

            int m_ColorsSize = reader.ReadInt32();
            m_Colors = new KeyValuePair<string, Color>[m_ColorsSize];
            for (int i = 0; i < m_ColorsSize; i++)
            {
                m_Colors[i] = new KeyValuePair<string, Color>(reader.ReadAlignedString(), reader.ReadColor4());
            }
        }
    }

    public sealed class Material : NamedObject
    {
        public PPtr<Shader> m_Shader;
        public UnityPropertySheet m_SavedProperties;

        public Material(ObjectReader reader) : base(reader)
        {
            m_Shader = new PPtr<Shader>(reader);

            if (version[0] == 4 && version[1] >= 1) //4.x
            {
                var m_ShaderKeywords = reader.ReadStringArray();
            }

            if (version[0] > 2021 || (version[0] == 2021 && version[1] >= 3)) //2021.3 and up
            {
                var m_ValidKeywords = reader.ReadStringArray();
                var m_InvalidKeywords = reader.ReadStringArray();
            }
            else if (version[0] >= 5) //5.0 ~ 2021.2
            {
                var m_ShaderKeywords = reader.ReadAlignedString();
            }

            if (version[0] >= 5) //5.0 and up
            {
                var m_LightmapFlags = reader.ReadUInt32();
            }

            if (version[0] > 5 || (version[0] == 5 && version[1] >= 6)) //5.6 and up
            {
                var m_EnableInstancingVariants = reader.ReadBoolean();
                //var m_DoubleSidedGI = a_Stream.ReadBoolean(); //2017 and up
                reader.AlignStream();
            }

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                var m_CustomRenderQueue = reader.ReadInt32();
            }

            if (version[0] > 5 || (version[0] == 5 && version[1] >= 1)) //5.1 and up
            {
                var stringTagMapSize = reader.ReadInt32();
                for (int i = 0; i < stringTagMapSize; i++)
                {
                    var first = reader.ReadAlignedString();
                    var second = reader.ReadAlignedString();
                }
            }

            if (version[0] > 5 || (version[0] == 5 && version[1] >= 6)) //5.6 and up
            {
                var disabledShaderPasses = reader.ReadStringArray();
            }

            m_SavedProperties = new UnityPropertySheet(reader);

            //vector m_BuildTextureStacks 2020 and up
        }
    }
}

```

`AssetStudio/Classes/Mesh.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace AssetStudio
{
    public class MinMaxAABB
    {
        public Vector3 m_Min;
        public Vector3 m_Max;

        public MinMaxAABB(BinaryReader reader)
        {
            m_Min = reader.ReadVector3();
            m_Max = reader.ReadVector3();
        }
    }

    public class CompressedMesh
    {
        public PackedFloatVector m_Vertices;
        public PackedFloatVector m_UV;
        public PackedFloatVector m_BindPoses;
        public PackedFloatVector m_Normals;
        public PackedFloatVector m_Tangents;
        public PackedIntVector m_Weights;
        public PackedIntVector m_NormalSigns;
        public PackedIntVector m_TangentSigns;
        public PackedFloatVector m_FloatColors;
        public PackedIntVector m_BoneIndices;
        public PackedIntVector m_Triangles;
        public PackedIntVector m_Colors;
        public uint m_UVInfo;

        public CompressedMesh(ObjectReader reader)
        {
            var version = reader.version;

            m_Vertices = new PackedFloatVector(reader);
            m_UV = new PackedFloatVector(reader);
            if (version[0] < 5)
            {
                m_BindPoses = new PackedFloatVector(reader);
            }
            m_Normals = new PackedFloatVector(reader);
            m_Tangents = new PackedFloatVector(reader);
            m_Weights = new PackedIntVector(reader);
            m_NormalSigns = new PackedIntVector(reader);
            m_TangentSigns = new PackedIntVector(reader);
            if (version[0] >= 5)
            {
                m_FloatColors = new PackedFloatVector(reader);
            }
            m_BoneIndices = new PackedIntVector(reader);
            m_Triangles = new PackedIntVector(reader);
            if (version[0] > 3 || (version[0] == 3 && version[1] >= 5)) //3.5 and up
            {
                if (version[0] < 5)
                {
                    m_Colors = new PackedIntVector(reader);
                }
                else
                {
                    m_UVInfo = reader.ReadUInt32();
                }
            }
        }
    }

    public class StreamInfo
    {
        public uint channelMask;
        public uint offset;
        public uint stride;
        public uint align;
        public byte dividerOp;
        public ushort frequency;

        public StreamInfo() { }

        public StreamInfo(ObjectReader reader)
        {
            var version = reader.version;

            channelMask = reader.ReadUInt32();
            offset = reader.ReadUInt32();

            if (version[0] < 4) //4.0 down
            {
                stride = reader.ReadUInt32();
                align = reader.ReadUInt32();
            }
            else
            {
                stride = reader.ReadByte();
                dividerOp = reader.ReadByte();
                frequency = reader.ReadUInt16();
            }
        }
    }

    public class ChannelInfo
    {
        public byte stream;
        public byte offset;
        public byte format;
        public byte dimension;

        public ChannelInfo() { }

        public ChannelInfo(ObjectReader reader)
        {
            stream = reader.ReadByte();
            offset = reader.ReadByte();
            format = reader.ReadByte();
            dimension = (byte)(reader.ReadByte() & 0xF);
        }
    }

    public class VertexData
    {
        public uint m_CurrentChannels;
        public uint m_VertexCount;
        public ChannelInfo[] m_Channels;
        public StreamInfo[] m_Streams;
        public byte[] m_DataSize;

        public VertexData(ObjectReader reader)
        {
            var version = reader.version;

            if (version[0] < 2018)//2018 down
            {
                m_CurrentChannels = reader.ReadUInt32();
            }

            m_VertexCount = reader.ReadUInt32();

            if (version[0] >= 4) //4.0 and up
            {
                var m_ChannelsSize = reader.ReadInt32();
                m_Channels = new ChannelInfo[m_ChannelsSize];
                for (int i = 0; i < m_ChannelsSize; i++)
                {
                    m_Channels[i] = new ChannelInfo(reader);
                }
            }

            if (version[0] < 5) //5.0 down
            {
                if (version[0] < 4)
                {
                    m_Streams = new StreamInfo[4];
                }
                else
                {
                    m_Streams = new StreamInfo[reader.ReadInt32()];
                }

                for (int i = 0; i < m_Streams.Length; i++)
                {
                    m_Streams[i] = new StreamInfo(reader);
                }

                if (version[0] < 4) //4.0 down
                {
                    GetChannels(version);
                }
            }
            else //5.0 and up
            {
                GetStreams(version);
            }

            m_DataSize = reader.ReadUInt8Array();
            reader.AlignStream();
        }

        private void GetStreams(int[] version)
        {
            var streamCount = m_Channels.Max(x => x.stream) + 1;
            m_Streams = new StreamInfo[streamCount];
            uint offset = 0;
            for (int s = 0; s < streamCount; s++)
            {
                uint chnMask = 0;
                uint stride = 0;
                for (int chn = 0; chn < m_Channels.Length; chn++)
                {
                    var m_Channel = m_Channels[chn];
                    if (m_Channel.stream == s)
                    {
                        if (m_Channel.dimension > 0)
                        {
                            chnMask |= 1u << chn;
                            stride += m_Channel.dimension * MeshHelper.GetFormatSize(MeshHelper.ToVertexFormat(m_Channel.format, version));
                        }
                    }
                }
                m_Streams[s] = new StreamInfo
                {
                    channelMask = chnMask,
                    offset = offset,
                    stride = stride,
                    dividerOp = 0,
                    frequency = 0
                };
                offset += m_VertexCount * stride;
                //static size_t AlignStreamSize (size_t size) { return (size + (kVertexStreamAlign-1)) & ~(kVertexStreamAlign-1); }
                offset = (offset + (16u - 1u)) & ~(16u - 1u);
            }
        }

        private void GetChannels(int[] version)
        {
            m_Channels = new ChannelInfo[6];
            for (int i = 0; i < 6; i++)
            {
                m_Channels[i] = new ChannelInfo();
            }
            for (var s = 0; s < m_Streams.Length; s++)
            {
                var m_Stream = m_Streams[s];
                var channelMask = new BitArray(new[] { (int)m_Stream.channelMask });
                byte offset = 0;
                for (int i = 0; i < 6; i++)
                {
                    if (channelMask.Get(i))
                    {
                        var m_Channel = m_Channels[i];
                        m_Channel.stream = (byte)s;
                        m_Channel.offset = offset;
                        switch (i)
                        {
                            case 0: //kShaderChannelVertex
                            case 1: //kShaderChannelNormal
                                m_Channel.format = 0; //kChannelFormatFloat
                                m_Channel.dimension = 3;
                                break;
                            case 2: //kShaderChannelColor
                                m_Channel.format = 2; //kChannelFormatColor
                                m_Channel.dimension = 4;
                                break;
                            case 3: //kShaderChannelTexCoord0
                            case 4: //kShaderChannelTexCoord1
                                m_Channel.format = 0; //kChannelFormatFloat
                                m_Channel.dimension = 2;
                                break;
                            case 5: //kShaderChannelTangent
                                m_Channel.format = 0; //kChannelFormatFloat
                                m_Channel.dimension = 4;
                                break;
                        }
                        offset += (byte)(m_Channel.dimension * MeshHelper.GetFormatSize(MeshHelper.ToVertexFormat(m_Channel.format, version)));
                    }
                }
            }
        }
    }

    public class BoneWeights4
    {
        public float[] weight;
        public int[] boneIndex;

        public BoneWeights4()
        {
            weight = new float[4];
            boneIndex = new int[4];
        }

        public BoneWeights4(ObjectReader reader)
        {
            weight = reader.ReadSingleArray(4);
            boneIndex = reader.ReadInt32Array(4);
        }
    }

    public class BlendShapeVertex
    {
        public Vector3 vertex;
        public Vector3 normal;
        public Vector3 tangent;
        public uint index;

        public BlendShapeVertex(ObjectReader reader)
        {
            vertex = reader.ReadVector3();
            normal = reader.ReadVector3();
            tangent = reader.ReadVector3();
            index = reader.ReadUInt32();
        }
    }

    public class MeshBlendShape
    {
        public uint firstVertex;
        public uint vertexCount;
        public bool hasNormals;
        public bool hasTangents;

        public MeshBlendShape(ObjectReader reader)
        {
            var version = reader.version;

            if (version[0] == 4 && version[1] < 3) //4.3 down
            {
                var name = reader.ReadAlignedString();
            }
            firstVertex = reader.ReadUInt32();
            vertexCount = reader.ReadUInt32();
            if (version[0] == 4 && version[1] < 3) //4.3 down
            {
                var aabbMinDelta = reader.ReadVector3();
                var aabbMaxDelta = reader.ReadVector3();
            }
            hasNormals = reader.ReadBoolean();
            hasTangents = reader.ReadBoolean();
            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                reader.AlignStream();
            }
        }
    }

    public class MeshBlendShapeChannel
    {
        public string name;
        public uint nameHash;
        public int frameIndex;
        public int frameCount;

        public MeshBlendShapeChannel(ObjectReader reader)
        {
            name = reader.ReadAlignedString();
            nameHash = reader.ReadUInt32();
            frameIndex = reader.ReadInt32();
            frameCount = reader.ReadInt32();
        }
    }

    public class BlendShapeData
    {
        public BlendShapeVertex[] vertices;
        public MeshBlendShape[] shapes;
        public MeshBlendShapeChannel[] channels;
        public float[] fullWeights;

        public BlendShapeData(ObjectReader reader)
        {
            var version = reader.version;

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                int numVerts = reader.ReadInt32();
                vertices = new BlendShapeVertex[numVerts];
                for (int i = 0; i < numVerts; i++)
                {
                    vertices[i] = new BlendShapeVertex(reader);
                }

                int numShapes = reader.ReadInt32();
                shapes = new MeshBlendShape[numShapes];
                for (int i = 0; i < numShapes; i++)
                {
                    shapes[i] = new MeshBlendShape(reader);
                }

                int numChannels = reader.ReadInt32();
                channels = new MeshBlendShapeChannel[numChannels];
                for (int i = 0; i < numChannels; i++)
                {
                    channels[i] = new MeshBlendShapeChannel(reader);
                }

                fullWeights = reader.ReadSingleArray();
            }
            else
            {
                var m_ShapesSize = reader.ReadInt32();
                var m_Shapes = new MeshBlendShape[m_ShapesSize];
                for (int i = 0; i < m_ShapesSize; i++)
                {
                    m_Shapes[i] = new MeshBlendShape(reader);
                }
                reader.AlignStream();
                var m_ShapeVerticesSize = reader.ReadInt32();
                var m_ShapeVertices = new BlendShapeVertex[m_ShapeVerticesSize]; //MeshBlendShapeVertex
                for (int i = 0; i < m_ShapeVerticesSize; i++)
                {
                    m_ShapeVertices[i] = new BlendShapeVertex(reader);
                }
            }
        }
    }

    public enum GfxPrimitiveType
    {
        Triangles = 0,
        TriangleStrip = 1,
        Quads = 2,
        Lines = 3,
        LineStrip = 4,
        Points = 5
    };

    public class SubMesh
    {
        public uint firstByte;
        public uint indexCount;
        public GfxPrimitiveType topology;
        public uint triangleCount;
        public uint baseVertex;
        public uint firstVertex;
        public uint vertexCount;
        public AABB localAABB;

        public SubMesh(ObjectReader reader)
        {
            var version = reader.version;

            firstByte = reader.ReadUInt32();
            indexCount = reader.ReadUInt32();
            topology = (GfxPrimitiveType)reader.ReadInt32();

            if (version[0] < 4) //4.0 down
            {
                triangleCount = reader.ReadUInt32();
            }

            if (version[0] > 2017 || (version[0] == 2017 && version[1] >= 3)) //2017.3 and up
            {
                baseVertex = reader.ReadUInt32();
            }

            if (version[0] >= 3) //3.0 and up
            {
                firstVertex = reader.ReadUInt32();
                vertexCount = reader.ReadUInt32();
                localAABB = new AABB(reader);
            }
        }
    }

    public sealed class Mesh : NamedObject
    {
        private bool m_Use16BitIndices = true;
        public SubMesh[] m_SubMeshes;
        private uint[] m_IndexBuffer;
        public BlendShapeData m_Shapes;
        public Matrix4x4[] m_BindPose;
        public uint[] m_BoneNameHashes;
        public int m_VertexCount;
        public float[] m_Vertices;
        public BoneWeights4[] m_Skin;
        public float[] m_Normals;
        public float[] m_Colors;
        public float[] m_UV0;
        public float[] m_UV1;
        public float[] m_UV2;
        public float[] m_UV3;
        public float[] m_UV4;
        public float[] m_UV5;
        public float[] m_UV6;
        public float[] m_UV7;
        public float[] m_Tangents;
        private VertexData m_VertexData;
        private CompressedMesh m_CompressedMesh;
        private StreamingInfo m_StreamData;

        public List<uint> m_Indices = new List<uint>();

        public Mesh(ObjectReader reader) : base(reader)
        {
            if (version[0] < 3 || (version[0] == 3 && version[1] < 5)) //3.5 down
            {
                m_Use16BitIndices = reader.ReadInt32() > 0;
            }

            if (version[0] == 2 && version[1] <= 5) //2.5 and down
            {
                int m_IndexBuffer_size = reader.ReadInt32();

                if (m_Use16BitIndices)
                {
                    m_IndexBuffer = new uint[m_IndexBuffer_size / 2];
                    for (int i = 0; i < m_IndexBuffer_size / 2; i++)
                    {
                        m_IndexBuffer[i] = reader.ReadUInt16();
                    }
                    reader.AlignStream();
                }
                else
                {
                    m_IndexBuffer = reader.ReadUInt32Array(m_IndexBuffer_size / 4);
                }
            }

            int m_SubMeshesSize = reader.ReadInt32();
            m_SubMeshes = new SubMesh[m_SubMeshesSize];
            for (int i = 0; i < m_SubMeshesSize; i++)
            {
                m_SubMeshes[i] = new SubMesh(reader);
            }

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 1)) //4.1 and up
            {
                m_Shapes = new BlendShapeData(reader);
            }

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                m_BindPose = reader.ReadMatrixArray();
                m_BoneNameHashes = reader.ReadUInt32Array();
                var m_RootBoneNameHash = reader.ReadUInt32();
            }

            if (version[0] > 2 || (version[0] == 2 && version[1] >= 6)) //2.6.0 and up
            {
                if (version[0] >= 2019) //2019 and up
                {
                    var m_BonesAABBSize = reader.ReadInt32();
                    var m_BonesAABB = new MinMaxAABB[m_BonesAABBSize];
                    for (int i = 0; i < m_BonesAABBSize; i++)
                    {
                        m_BonesAABB[i] = new MinMaxAABB(reader);
                    }

                    var m_VariableBoneCountWeights = reader.ReadUInt32Array();
                }

                var m_MeshCompression = reader.ReadByte();
                if (version[0] >= 4)
                {
                    if (version[0] < 5)
                    {
                        var m_StreamCompression = reader.ReadByte();
                    }
                    var m_IsReadable = reader.ReadBoolean();
                    var m_KeepVertices = reader.ReadBoolean();
                    var m_KeepIndices = reader.ReadBoolean();
                }
                reader.AlignStream();

                //Unity fixed it in 2017.3.1p1 and later versions
                if ((version[0] > 2017 || (version[0] == 2017 && version[1] >= 4)) || //2017.4
                    ((version[0] == 2017 && version[1] == 3 && version[2] == 1) && buildType.IsPatch) || //fixed after 2017.3.1px
                    ((version[0] == 2017 && version[1] == 3) && m_MeshCompression == 0))//2017.3.xfx with no compression
                {
                    var m_IndexFormat = reader.ReadInt32();
                    m_Use16BitIndices = m_IndexFormat == 0;
                }

                int m_IndexBuffer_size = reader.ReadInt32();
                if (m_Use16BitIndices)
                {
                    m_IndexBuffer = new uint[m_IndexBuffer_size / 2];
                    for (int i = 0; i < m_IndexBuffer_size / 2; i++)
                    {
                        m_IndexBuffer[i] = reader.ReadUInt16();
                    }
                    reader.AlignStream();
                }
                else
                {
                    m_IndexBuffer = reader.ReadUInt32Array(m_IndexBuffer_size / 4);
                }
            }

            if (version[0] < 3 || (version[0] == 3 && version[1] < 5)) //3.4.2 and earlier
            {
                m_VertexCount = reader.ReadInt32();
                m_Vertices = reader.ReadSingleArray(m_VertexCount * 3); //Vector3

                m_Skin = new BoneWeights4[reader.ReadInt32()];
                for (int s = 0; s < m_Skin.Length; s++)
                {
                    m_Skin[s] = new BoneWeights4(reader);
                }

                m_BindPose = reader.ReadMatrixArray();

                m_UV0 = reader.ReadSingleArray(reader.ReadInt32() * 2); //Vector2

                m_UV1 = reader.ReadSingleArray(reader.ReadInt32() * 2); //Vector2

                if (version[0] == 2 && version[1] <= 5) //2.5 and down
                {
                    int m_TangentSpace_size = reader.ReadInt32();
                    m_Normals = new float[m_TangentSpace_size * 3];
                    m_Tangents = new float[m_TangentSpace_size * 4];
                    for (int v = 0; v < m_TangentSpace_size; v++)
                    {
                        m_Normals[v * 3] = reader.ReadSingle();
                        m_Normals[v * 3 + 1] = reader.ReadSingle();
                        m_Normals[v * 3 + 2] = reader.ReadSingle();
                        m_Tangents[v * 3] = reader.ReadSingle();
                        m_Tangents[v * 3 + 1] = reader.ReadSingle();
                        m_Tangents[v * 3 + 2] = reader.ReadSingle();
                        m_Tangents[v * 3 + 3] = reader.ReadSingle(); //handedness
                    }
                }
                else //2.6.0 and later
                {
                    m_Tangents = reader.ReadSingleArray(reader.ReadInt32() * 4); //Vector4

                    m_Normals = reader.ReadSingleArray(reader.ReadInt32() * 3); //Vector3
                }
            }
            else
            {
                if (version[0] < 2018 || (version[0] == 2018 && version[1] < 2)) //2018.2 down
                {
                    m_Skin = new BoneWeights4[reader.ReadInt32()];
                    for (int s = 0; s < m_Skin.Length; s++)
                    {
                        m_Skin[s] = new BoneWeights4(reader);
                    }
                }

                if (version[0] == 3 || (version[0] == 4 && version[1] <= 2)) //4.2 and down
                {
                    m_BindPose = reader.ReadMatrixArray();
                }

                m_VertexData = new VertexData(reader);
            }

            if (version[0] > 2 || (version[0] == 2 && version[1] >= 6)) //2.6.0 and later
            {
                m_CompressedMesh = new CompressedMesh(reader);
            }

            reader.Position += 24; //AABB m_LocalAABB

            if (version[0] < 3 || (version[0] == 3 && version[1] <= 4)) //3.4.2 and earlier
            {
                int m_Colors_size = reader.ReadInt32();
                m_Colors = new float[m_Colors_size * 4];
                for (int v = 0; v < m_Colors_size * 4; v++)
                {
                    m_Colors[v] = (float)reader.ReadByte() / 0xFF;
                }

                int m_CollisionTriangles_size = reader.ReadInt32();
                reader.Position += m_CollisionTriangles_size * 4; //UInt32 indices
                int m_CollisionVertexCount = reader.ReadInt32();
            }

            int m_MeshUsageFlags = reader.ReadInt32();

            if (version[0] > 2022 || (version[0] == 2022 && version[1] >= 1)) //2022.1 and up
            {
                int m_CookingOptions = reader.ReadInt32();
            }

            if (version[0] >= 5) //5.0 and up
            {
                var m_BakedConvexCollisionMesh = reader.ReadUInt8Array();
                reader.AlignStream();
                var m_BakedTriangleCollisionMesh = reader.ReadUInt8Array();
                reader.AlignStream();
            }

            if (version[0] > 2018 || (version[0] == 2018 && version[1] >= 2)) //2018.2 and up
            {
                var m_MeshMetrics = new float[2];
                m_MeshMetrics[0] = reader.ReadSingle();
                m_MeshMetrics[1] = reader.ReadSingle();
            }

            if (version[0] > 2018 || (version[0] == 2018 && version[1] >= 3)) //2018.3 and up
            {
                reader.AlignStream();
                m_StreamData = new StreamingInfo(reader);
            }

            ProcessData();
        }

        private void ProcessData()
        {
            if (!string.IsNullOrEmpty(m_StreamData?.path))
            {
                if (m_VertexData.m_VertexCount > 0)
                {
                    var resourceReader = new ResourceReader(m_StreamData.path, assetsFile, m_StreamData.offset, m_StreamData.size);
                    m_VertexData.m_DataSize = resourceReader.GetData();
                }
            }
            if (version[0] > 3 || (version[0] == 3 && version[1] >= 5)) //3.5 and up
            {
                ReadVertexData();
            }

            if (version[0] > 2 || (version[0] == 2 && version[1] >= 6)) //2.6.0 and later
            {
                DecompressCompressedMesh();
            }

            GetTriangles();
        }

        private void ReadVertexData()
        {
            m_VertexCount = (int)m_VertexData.m_VertexCount;

            for (var chn = 0; chn < m_VertexData.m_Channels.Length; chn++)
            {
                var m_Channel = m_VertexData.m_Channels[chn];
                if (m_Channel.dimension > 0)
                {
                    var m_Stream = m_VertexData.m_Streams[m_Channel.stream];
                    var channelMask = new BitArray(new[] { (int)m_Stream.channelMask });
                    if (channelMask.Get(chn))
                    {
                        if (version[0] < 2018 && chn == 2 && m_Channel.format == 2) //kShaderChannelColor && kChannelFormatColor
                        {
                            m_Channel.dimension = 4;
                        }

                        var vertexFormat = MeshHelper.ToVertexFormat(m_Channel.format, version);
                        var componentByteSize = (int)MeshHelper.GetFormatSize(vertexFormat);
                        var componentBytes = new byte[m_VertexCount * m_Channel.dimension * componentByteSize];
                        for (int v = 0; v < m_VertexCount; v++)
                        {
                            var vertexOffset = (int)m_Stream.offset + m_Channel.offset + (int)m_Stream.stride * v;
                            for (int d = 0; d < m_Channel.dimension; d++)
                            {
                                var componentOffset = vertexOffset + componentByteSize * d;
                                Buffer.BlockCopy(m_VertexData.m_DataSize, componentOffset, componentBytes, componentByteSize * (v * m_Channel.dimension + d), componentByteSize);
                            }
                        }

                        if (reader.Endian == EndianType.BigEndian && componentByteSize > 1) //swap bytes
                        {
                            for (var i = 0; i < componentBytes.Length / componentByteSize; i++)
                            {
                                var buff = new byte[componentByteSize];
                                Buffer.BlockCopy(componentBytes, i * componentByteSize, buff, 0, componentByteSize);
                                buff = buff.Reverse().ToArray();
                                Buffer.BlockCopy(buff, 0, componentBytes, i * componentByteSize, componentByteSize);
                            }
                        }

                        int[] componentsIntArray = null;
                        float[] componentsFloatArray = null;
                        if (MeshHelper.IsIntFormat(vertexFormat))
                            componentsIntArray = MeshHelper.BytesToIntArray(componentBytes, vertexFormat);
                        else
                            componentsFloatArray = MeshHelper.BytesToFloatArray(componentBytes, vertexFormat);

                        if (version[0] >= 2018)
                        {
                            switch (chn)
                            {
                                case 0: //kShaderChannelVertex
                                    m_Vertices = componentsFloatArray;
                                    break;
                                case 1: //kShaderChannelNormal
                                    m_Normals = componentsFloatArray;
                                    break;
                                case 2: //kShaderChannelTangent
                                    m_Tangents = componentsFloatArray;
                                    break;
                                case 3: //kShaderChannelColor
                                    m_Colors = componentsFloatArray;
                                    break;
                                case 4: //kShaderChannelTexCoord0
                                    m_UV0 = componentsFloatArray;
                                    break;
                                case 5: //kShaderChannelTexCoord1
                                    m_UV1 = componentsFloatArray;
                                    break;
                                case 6: //kShaderChannelTexCoord2
                                    m_UV2 = componentsFloatArray;
                                    break;
                                case 7: //kShaderChannelTexCoord3
                                    m_UV3 = componentsFloatArray;
                                    break;
                                case 8: //kShaderChannelTexCoord4
                                    m_UV4 = componentsFloatArray;
                                    break;
                                case 9: //kShaderChannelTexCoord5
                                    m_UV5 = componentsFloatArray;
                                    break;
                                case 10: //kShaderChannelTexCoord6
                                    m_UV6 = componentsFloatArray;
                                    break;
                                case 11: //kShaderChannelTexCoord7
                                    m_UV7 = componentsFloatArray;
                                    break;
                                //2018.2 and up
                                case 12: //kShaderChannelBlendWeight
                                    if (m_Skin == null)
                                    {
                                        InitMSkin();
                                    }
                                    for (int i = 0; i < m_VertexCount; i++)
                                    {
                                        for (int j = 0; j < m_Channel.dimension; j++)
                                        {
                                            m_Skin[i].weight[j] = componentsFloatArray[i * m_Channel.dimension + j];
                                        }
                                    }
                                    break;
                                case 13: //kShaderChannelBlendIndices
                                    if (m_Skin == null)
                                    {
                                        InitMSkin();
                                    }
                                    for (int i = 0; i < m_VertexCount; i++)
                                    {
                                        for (int j = 0; j < m_Channel.dimension; j++)
                                        {
                                            m_Skin[i].boneIndex[j] = componentsIntArray[i * m_Channel.dimension + j];
                                        }
                                    }
                                    break;
                            }
                        }
                        else
                        {
                            switch (chn)
                            {
                                case 0: //kShaderChannelVertex
                                    m_Vertices = componentsFloatArray;
                                    break;
                                case 1: //kShaderChannelNormal
                                    m_Normals = componentsFloatArray;
                                    break;
                                case 2: //kShaderChannelColor
                                    m_Colors = componentsFloatArray;
                                    break;
                                case 3: //kShaderChannelTexCoord0
                                    m_UV0 = componentsFloatArray;
                                    break;
                                case 4: //kShaderChannelTexCoord1
                                    m_UV1 = componentsFloatArray;
                                    break;
                                case 5:
                                    if (version[0] >= 5) //kShaderChannelTexCoord2
                                    {
                                        m_UV2 = componentsFloatArray;
                                    }
                                    else //kShaderChannelTangent
                                    {
                                        m_Tangents = componentsFloatArray;
                                    }
                                    break;
                                case 6: //kShaderChannelTexCoord3
                                    m_UV3 = componentsFloatArray;
                                    break;
                                case 7: //kShaderChannelTangent
                                    m_Tangents = componentsFloatArray;
                                    break;
                            }
                        }
                    }
                }
            }
        }

        private void DecompressCompressedMesh()
        {
            //Vertex
            if (m_CompressedMesh.m_Vertices.m_NumItems > 0)
            {
                m_VertexCount = (int)m_CompressedMesh.m_Vertices.m_NumItems / 3;
                m_Vertices = m_CompressedMesh.m_Vertices.UnpackFloats(3, 3 * 4);
            }
            //UV
            if (m_CompressedMesh.m_UV.m_NumItems > 0)
            {
                var m_UVInfo = m_CompressedMesh.m_UVInfo;
                if (m_UVInfo != 0)
                {
                    const int kInfoBitsPerUV = 4;
                    const int kUVDimensionMask = 3;
                    const int kUVChannelExists = 4;
                    const int kMaxTexCoordShaderChannels = 8;

                    int uvSrcOffset = 0;
                    for (int uv = 0; uv < kMaxTexCoordShaderChannels; uv++)
                    {
                        var texCoordBits = m_UVInfo >> (uv * kInfoBitsPerUV);
                        texCoordBits &= (1u << kInfoBitsPerUV) - 1u;
                        if ((texCoordBits & kUVChannelExists) != 0)
                        {
                            var uvDim = 1 + (int)(texCoordBits & kUVDimensionMask);
                            var m_UV = m_CompressedMesh.m_UV.UnpackFloats(uvDim, uvDim * 4, uvSrcOffset, m_VertexCount);
                            SetUV(uv, m_UV);
                            uvSrcOffset += uvDim * m_VertexCount;
                        }
                    }
                }
                else
                {
                    m_UV0 = m_CompressedMesh.m_UV.UnpackFloats(2, 2 * 4, 0, m_VertexCount);
                    if (m_CompressedMesh.m_UV.m_NumItems >= m_VertexCount * 4)
                    {
                        m_UV1 = m_CompressedMesh.m_UV.UnpackFloats(2, 2 * 4, m_VertexCount * 2, m_VertexCount);
                    }
                }
            }
            //BindPose
            if (version[0] < 5)
            {
                if (m_CompressedMesh.m_BindPoses.m_NumItems > 0)
                {
                    m_BindPose = new Matrix4x4[m_CompressedMesh.m_BindPoses.m_NumItems / 16];
                    var m_BindPoses_Unpacked = m_CompressedMesh.m_BindPoses.UnpackFloats(16, 4 * 16);
                    var buffer = new float[16];
                    for (int i = 0; i < m_BindPose.Length; i++)
                    {
                        Array.Copy(m_BindPoses_Unpacked, i * 16, buffer, 0, 16);
                        m_BindPose[i] = new Matrix4x4(buffer);
                    }
                }
            }
            //Normal
            if (m_CompressedMesh.m_Normals.m_NumItems > 0)
            {
                var normalData = m_CompressedMesh.m_Normals.UnpackFloats(2, 4 * 2);
                var signs = m_CompressedMesh.m_NormalSigns.UnpackInts();
                m_Normals = new float[m_CompressedMesh.m_Normals.m_NumItems / 2 * 3];
                for (int i = 0; i < m_CompressedMesh.m_Normals.m_NumItems / 2; ++i)
                {
                    var x = normalData[i * 2 + 0];
                    var y = normalData[i * 2 + 1];
                    var zsqr = 1 - x * x - y * y;
                    float z;
                    if (zsqr >= 0f)
                        z = (float)Math.Sqrt(zsqr);
                    else
                    {
                        z = 0;
                        var normal = new Vector3(x, y, z);
                        normal.Normalize();
                        x = normal.X;
                        y = normal.Y;
                        z = normal.Z;
                    }
                    if (signs[i] == 0)
                        z = -z;
                    m_Normals[i * 3] = x;
                    m_Normals[i * 3 + 1] = y;
                    m_Normals[i * 3 + 2] = z;
                }
            }
            //Tangent
            if (m_CompressedMesh.m_Tangents.m_NumItems > 0)
            {
                var tangentData = m_CompressedMesh.m_Tangents.UnpackFloats(2, 4 * 2);
                var signs = m_CompressedMesh.m_TangentSigns.UnpackInts();
                m_Tangents = new float[m_CompressedMesh.m_Tangents.m_NumItems / 2 * 4];
                for (int i = 0; i < m_CompressedMesh.m_Tangents.m_NumItems / 2; ++i)
                {
                    var x = tangentData[i * 2 + 0];
                    var y = tangentData[i * 2 + 1];
                    var zsqr = 1 - x * x - y * y;
                    float z;
                    if (zsqr >= 0f)
                        z = (float)Math.Sqrt(zsqr);
                    else
                    {
                        z = 0;
                        var vector3f = new Vector3(x, y, z);
                        vector3f.Normalize();
                        x = vector3f.X;
                        y = vector3f.Y;
                        z = vector3f.Z;
                    }
                    if (signs[i * 2 + 0] == 0)
                        z = -z;
                    var w = signs[i * 2 + 1] > 0 ? 1.0f : -1.0f;
                    m_Tangents[i * 4] = x;
                    m_Tangents[i * 4 + 1] = y;
                    m_Tangents[i * 4 + 2] = z;
                    m_Tangents[i * 4 + 3] = w;
                }
            }
            //FloatColor
            if (version[0] >= 5)
            {
                if (m_CompressedMesh.m_FloatColors.m_NumItems > 0)
                {
                    m_Colors = m_CompressedMesh.m_FloatColors.UnpackFloats(1, 4);
                }
            }
            //Skin
            if (m_CompressedMesh.m_Weights.m_NumItems > 0)
            {
                var weights = m_CompressedMesh.m_Weights.UnpackInts();
                var boneIndices = m_CompressedMesh.m_BoneIndices.UnpackInts();

                InitMSkin();

                int bonePos = 0;
                int boneIndexPos = 0;
                int j = 0;
                int sum = 0;

                for (int i = 0; i < m_CompressedMesh.m_Weights.m_NumItems; i++)
                {
                    //read bone index and weight.
                    m_Skin[bonePos].weight[j] = weights[i] / 31.0f;
                    m_Skin[bonePos].boneIndex[j] = boneIndices[boneIndexPos++];
                    j++;
                    sum += weights[i];

                    //the weights add up to one. fill the rest for this vertex with zero, and continue with next one.
                    if (sum >= 31)
                    {
                        for (; j < 4; j++)
                        {
                            m_Skin[bonePos].weight[j] = 0;
                            m_Skin[bonePos].boneIndex[j] = 0;
                        }
                        bonePos++;
                        j = 0;
                        sum = 0;
                    }
                    //we read three weights, but they don't add up to one. calculate the fourth one, and read
                    //missing bone index. continue with next vertex.
                    else if (j == 3)
                    {
                        m_Skin[bonePos].weight[j] = (31 - sum) / 31.0f;
                        m_Skin[bonePos].boneIndex[j] = boneIndices[boneIndexPos++];
                        bonePos++;
                        j = 0;
                        sum = 0;
                    }
                }
            }
            //IndexBuffer
            if (m_CompressedMesh.m_Triangles.m_NumItems > 0)
            {
                m_IndexBuffer = Array.ConvertAll(m_CompressedMesh.m_Triangles.UnpackInts(), x => (uint)x);
            }
            //Color
            if (m_CompressedMesh.m_Colors?.m_NumItems > 0)
            {
                m_CompressedMesh.m_Colors.m_NumItems *= 4;
                m_CompressedMesh.m_Colors.m_BitSize /= 4;
                var tempColors = m_CompressedMesh.m_Colors.UnpackInts();
                m_Colors = new float[m_CompressedMesh.m_Colors.m_NumItems];
                for (int v = 0; v < m_CompressedMesh.m_Colors.m_NumItems; v++)
                {
                    m_Colors[v] = tempColors[v] / 255f;
                }
            }
        }

        private void GetTriangles()
        {
            foreach (var m_SubMesh in m_SubMeshes)
            {
                var firstIndex = m_SubMesh.firstByte / 2;
                if (!m_Use16BitIndices)
                {
                    firstIndex /= 2;
                }
                var indexCount = m_SubMesh.indexCount;
                var topology = m_SubMesh.topology;
                if (topology == GfxPrimitiveType.Triangles)
                {
                    for (int i = 0; i < indexCount; i += 3)
                    {
                        m_Indices.Add(m_IndexBuffer[firstIndex + i]);
                        m_Indices.Add(m_IndexBuffer[firstIndex + i + 1]);
                        m_Indices.Add(m_IndexBuffer[firstIndex + i + 2]);
                    }
                }
                else if (version[0] < 4 || topology == GfxPrimitiveType.TriangleStrip)
                {
                    // de-stripify :
                    uint triIndex = 0;
                    for (int i = 0; i < indexCount - 2; i++)
                    {
                        var a = m_IndexBuffer[firstIndex + i];
                        var b = m_IndexBuffer[firstIndex + i + 1];
                        var c = m_IndexBuffer[firstIndex + i + 2];

                        // skip degenerates
                        if (a == b || a == c || b == c)
                            continue;

                        // do the winding flip-flop of strips :
                        if ((i & 1) == 1)
                        {
                            m_Indices.Add(b);
                            m_Indices.Add(a);
                        }
                        else
                        {
                            m_Indices.Add(a);
                            m_Indices.Add(b);
                        }
                        m_Indices.Add(c);
                        triIndex += 3;
                    }
                    //fix indexCount
                    m_SubMesh.indexCount = triIndex;
                }
                else if (topology == GfxPrimitiveType.Quads)
                {
                    for (int q = 0; q < indexCount; q += 4)
                    {
                        m_Indices.Add(m_IndexBuffer[firstIndex + q]);
                        m_Indices.Add(m_IndexBuffer[firstIndex + q + 1]);
                        m_Indices.Add(m_IndexBuffer[firstIndex + q + 2]);
                        m_Indices.Add(m_IndexBuffer[firstIndex + q]);
                        m_Indices.Add(m_IndexBuffer[firstIndex + q + 2]);
                        m_Indices.Add(m_IndexBuffer[firstIndex + q + 3]);
                    }
                    //fix indexCount
                    m_SubMesh.indexCount = indexCount / 2 * 3;
                }
                else
                {
                    throw new NotSupportedException("Failed getting triangles. Submesh topology is lines or points.");
                }
            }
        }

        private void InitMSkin()
        {
            m_Skin = new BoneWeights4[m_VertexCount];
            for (int i = 0; i < m_VertexCount; i++)
            {
                m_Skin[i] = new BoneWeights4();
            }
        }

        private void SetUV(int uv, float[] m_UV)
        {
            switch (uv)
            {
                case 0:
                    m_UV0 = m_UV;
                    break;
                case 1:
                    m_UV1 = m_UV;
                    break;
                case 2:
                    m_UV2 = m_UV;
                    break;
                case 3:
                    m_UV3 = m_UV;
                    break;
                case 4:
                    m_UV4 = m_UV;
                    break;
                case 5:
                    m_UV5 = m_UV;
                    break;
                case 6:
                    m_UV6 = m_UV;
                    break;
                case 7:
                    m_UV7 = m_UV;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        public float[] GetUV(int uv)
        {
            switch (uv)
            {
                case 0:
                    return m_UV0;
                case 1:
                    return m_UV1;
                case 2:
                    return m_UV2;
                case 3:
                    return m_UV3;
                case 4:
                    return m_UV4;
                case 5:
                    return m_UV5;
                case 6:
                    return m_UV6;
                case 7:
                    return m_UV7;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }

    public static class MeshHelper
    {
        public enum VertexChannelFormat
        {
            Float,
            Float16,
            Color,
            Byte,
            UInt32
        }

        public enum VertexFormat2017
        {
            Float,
            Float16,
            Color,
            UNorm8,
            SNorm8,
            UNorm16,
            SNorm16,
            UInt8,
            SInt8,
            UInt16,
            SInt16,
            UInt32,
            SInt32
        }

        public enum VertexFormat
        {
            Float,
            Float16,
            UNorm8,
            SNorm8,
            UNorm16,
            SNorm16,
            UInt8,
            SInt8,
            UInt16,
            SInt16,
            UInt32,
            SInt32
        }

        public static VertexFormat ToVertexFormat(int format, int[] version)
        {
            if (version[0] < 2017)
            {
                switch ((VertexChannelFormat)format)
                {
                    case VertexChannelFormat.Float:
                        return VertexFormat.Float;
                    case VertexChannelFormat.Float16:
                        return VertexFormat.Float16;
                    case VertexChannelFormat.Color: //in 4.x is size 4
                        return VertexFormat.UNorm8;
                    case VertexChannelFormat.Byte:
                        return VertexFormat.UInt8;
                    case VertexChannelFormat.UInt32: //in 5.x
                        return VertexFormat.UInt32;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(format), format, null);
                }
            }
            else if (version[0] < 2019)
            {
                switch ((VertexFormat2017)format)
                {
                    case VertexFormat2017.Float:
                        return VertexFormat.Float;
                    case VertexFormat2017.Float16:
                        return VertexFormat.Float16;
                    case VertexFormat2017.Color:
                    case VertexFormat2017.UNorm8:
                        return VertexFormat.UNorm8;
                    case VertexFormat2017.SNorm8:
                        return VertexFormat.SNorm8;
                    case VertexFormat2017.UNorm16:
                        return VertexFormat.UNorm16;
                    case VertexFormat2017.SNorm16:
                        return VertexFormat.SNorm16;
                    case VertexFormat2017.UInt8:
                        return VertexFormat.UInt8;
                    case VertexFormat2017.SInt8:
                        return VertexFormat.SInt8;
                    case VertexFormat2017.UInt16:
                        return VertexFormat.UInt16;
                    case VertexFormat2017.SInt16:
                        return VertexFormat.SInt16;
                    case VertexFormat2017.UInt32:
                        return VertexFormat.UInt32;
                    case VertexFormat2017.SInt32:
                        return VertexFormat.SInt32;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(format), format, null);
                }
            }
            else
            {
                return (VertexFormat)format;
            }
        }


        public static uint GetFormatSize(VertexFormat format)
        {
            switch (format)
            {
                case VertexFormat.Float:
                case VertexFormat.UInt32:
                case VertexFormat.SInt32:
                    return 4u;
                case VertexFormat.Float16:
                case VertexFormat.UNorm16:
                case VertexFormat.SNorm16:
                case VertexFormat.UInt16:
                case VertexFormat.SInt16:
                    return 2u;
                case VertexFormat.UNorm8:
                case VertexFormat.SNorm8:
                case VertexFormat.UInt8:
                case VertexFormat.SInt8:
                    return 1u;
                default:
                    throw new ArgumentOutOfRangeException(nameof(format), format, null);
            }
        }

        public static bool IsIntFormat(VertexFormat format)
        {
            return format >= VertexFormat.UInt8;
        }

        public static float[] BytesToFloatArray(byte[] inputBytes, VertexFormat format)
        {
            var size = GetFormatSize(format);
            var len = inputBytes.Length / size;
            var result = new float[len];
            for (int i = 0; i < len; i++)
            {
                switch (format)
                {
                    case VertexFormat.Float:
                        result[i] = BitConverter.ToSingle(inputBytes, i * 4);
                        break;
                    case VertexFormat.Float16:
                        result[i] = Half.ToHalf(inputBytes, i * 2);
                        break;
                    case VertexFormat.UNorm8:
                        result[i] = inputBytes[i] / 255f;
                        break;
                    case VertexFormat.SNorm8:
                        result[i] = Math.Max((sbyte)inputBytes[i] / 127f, -1f);
                        break;
                    case VertexFormat.UNorm16:
                        result[i] = BitConverter.ToUInt16(inputBytes, i * 2) / 65535f;
                        break;
                    case VertexFormat.SNorm16:
                        result[i] = Math.Max(BitConverter.ToInt16(inputBytes, i * 2) / 32767f, -1f);
                        break;
                }
            }
            return result;
        }

        public static int[] BytesToIntArray(byte[] inputBytes, VertexFormat format)
        {
            var size = GetFormatSize(format);
            var len = inputBytes.Length / size;
            var result = new int[len];
            for (int i = 0; i < len; i++)
            {
                switch (format)
                {
                    case VertexFormat.UInt8:
                    case VertexFormat.SInt8:
                        result[i] = inputBytes[i];
                        break;
                    case VertexFormat.UInt16:
                    case VertexFormat.SInt16:
                        result[i] = BitConverter.ToInt16(inputBytes, i * 2);
                        break;
                    case VertexFormat.UInt32:
                    case VertexFormat.SInt32:
                        result[i] = BitConverter.ToInt32(inputBytes, i * 4);
                        break;
                }
            }
            return result;
        }
    }
}

```

`AssetStudio/Classes/MeshFilter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class MeshFilter : Component
    {
        public PPtr<Mesh> m_Mesh;

        public MeshFilter(ObjectReader reader) : base(reader)
        {
            m_Mesh = new PPtr<Mesh>(reader);
        }
    }
}

```

`AssetStudio/Classes/MeshRenderer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class MeshRenderer : Renderer
    {
        public MeshRenderer(ObjectReader reader) : base(reader)
        {

        }
    }
}

```

`AssetStudio/Classes/MonoBehaviour.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class MonoBehaviour : Behaviour
    {
        public PPtr<MonoScript> m_Script;
        public string m_Name;

        public MonoBehaviour(ObjectReader reader) : base(reader)
        {
            m_Script = new PPtr<MonoScript>(reader);
            m_Name = reader.ReadAlignedString();
        }
    }
}

```

`AssetStudio/Classes/MonoScript.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class MonoScript : NamedObject
    {
        public string m_ClassName;
        public string m_Namespace;
        public string m_AssemblyName;

        public MonoScript(ObjectReader reader) : base(reader)
        {
            if (version[0] > 3 || (version[0] == 3 && version[1] >= 4)) //3.4 and up
            {
                var m_ExecutionOrder = reader.ReadInt32();
            }
            if (version[0] < 5) //5.0 down
            {
                var m_PropertiesHash = reader.ReadUInt32();
            }
            else
            {
                var m_PropertiesHash = reader.ReadBytes(16);
            }
            if (version[0] < 3) //3.0 down
            {
                var m_PathName = reader.ReadAlignedString();
            }
            m_ClassName = reader.ReadAlignedString();
            if (version[0] >= 3) //3.0 and up
            {
                m_Namespace = reader.ReadAlignedString();
            }
            m_AssemblyName = reader.ReadAlignedString();
            if (version[0] < 2018 || (version[0] == 2018 && version[1] < 2)) //2018.2 down
            {
                var m_IsEditorScript = reader.ReadBoolean();
            }
        }
    }
}

```

`AssetStudio/Classes/MovieTexture.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class MovieTexture : Texture
    {
        public byte[] m_MovieData;
        public PPtr<AudioClip> m_AudioClip;

        public MovieTexture(ObjectReader reader) : base(reader)
        {
            var m_Loop = reader.ReadBoolean();
            reader.AlignStream();
            m_AudioClip = new PPtr<AudioClip>(reader);
            m_MovieData = reader.ReadUInt8Array();
        }
    }
}

```

`AssetStudio/Classes/NamedObject.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class NamedObject : EditorExtension
    {
        public string m_Name;

        protected NamedObject(ObjectReader reader) : base(reader)
        {
            m_Name = reader.ReadAlignedString();
        }
    }
}

```

`AssetStudio/Classes/Object.cs`:

```cs
using System.Collections.Specialized;

namespace AssetStudio
{
    public class Object
    {
        public SerializedFile assetsFile;
        public ObjectReader reader;
        public long m_PathID;
        public int[] version;
        protected BuildType buildType;
        public BuildTarget platform;
        public ClassIDType type;
        public SerializedType serializedType;
        public uint byteSize;

        public Object(ObjectReader reader)
        {
            this.reader = reader;
            reader.Reset();
            assetsFile = reader.assetsFile;
            type = reader.type;
            m_PathID = reader.m_PathID;
            version = reader.version;
            buildType = reader.buildType;
            platform = reader.platform;
            serializedType = reader.serializedType;
            byteSize = reader.byteSize;

            if (platform == BuildTarget.NoTarget)
            {
                var m_ObjectHideFlags = reader.ReadUInt32();
            }
        }

        public string Dump()
        {
            if (serializedType?.m_Type != null)
            {
                return TypeTreeHelper.ReadTypeString(serializedType.m_Type, reader);
            }
            return null;
        }

        public string Dump(TypeTree m_Type)
        {
            if (m_Type != null)
            {
                return TypeTreeHelper.ReadTypeString(m_Type, reader);
            }
            return null;
        }

        public OrderedDictionary ToType()
        {
            if (serializedType?.m_Type != null)
            {
                return TypeTreeHelper.ReadType(serializedType.m_Type, reader);
            }
            return null;
        }

        public OrderedDictionary ToType(TypeTree m_Type)
        {
            if (m_Type != null)
            {
                return TypeTreeHelper.ReadType(m_Type, reader);
            }
            return null;
        }

        public byte[] GetRawData()
        {
            reader.Reset();
            return reader.ReadBytes((int)byteSize);
        }
    }
}

```

`AssetStudio/Classes/PPtr.cs`:

```cs
using System;

namespace AssetStudio
{
    public sealed class PPtr<T> where T : Object
    {
        public int m_FileID;
        public long m_PathID;

        private SerializedFile assetsFile;
        private int index = -2; //-2 - Prepare, -1 - Missing

        public PPtr(ObjectReader reader)
        {
            m_FileID = reader.ReadInt32();
            m_PathID = reader.m_Version < SerializedFileFormatVersion.Unknown_14 ? reader.ReadInt32() : reader.ReadInt64();
            assetsFile = reader.assetsFile;
        }

        private bool TryGetAssetsFile(out SerializedFile result)
        {
            result = null;
            if (m_FileID == 0)
            {
                result = assetsFile;
                return true;
            }

            if (m_FileID > 0 && m_FileID - 1 < assetsFile.m_Externals.Count)
            {
                var assetsManager = assetsFile.assetsManager;
                var assetsFileList = assetsManager.assetsFileList;
                var assetsFileIndexCache = assetsManager.assetsFileIndexCache;

                if (index == -2)
                {
                    var m_External = assetsFile.m_Externals[m_FileID - 1];
                    var name = m_External.fileName;
                    if (!assetsFileIndexCache.TryGetValue(name, out index))
                    {
                        index = assetsFileList.FindIndex(x => x.fileName.Equals(name, StringComparison.OrdinalIgnoreCase));
                        assetsFileIndexCache.Add(name, index);
                    }
                }

                if (index >= 0)
                {
                    result = assetsFileList[index];
                    return true;
                }
            }

            return false;
        }

        public bool TryGet(out T result)
        {
            if (TryGetAssetsFile(out var sourceFile))
            {
                if (sourceFile.ObjectsDic.TryGetValue(m_PathID, out var obj))
                {
                    if (obj is T variable)
                    {
                        result = variable;
                        return true;
                    }
                }
            }

            result = null;
            return false;
        }

        public bool TryGet<T2>(out T2 result) where T2 : Object
        {
            if (TryGetAssetsFile(out var sourceFile))
            {
                if (sourceFile.ObjectsDic.TryGetValue(m_PathID, out var obj))
                {
                    if (obj is T2 variable)
                    {
                        result = variable;
                        return true;
                    }
                }
            }

            result = null;
            return false;
        }

        public void Set(T m_Object)
        {
            var name = m_Object.assetsFile.fileName;
            if (string.Equals(assetsFile.fileName, name, StringComparison.OrdinalIgnoreCase))
            {
                m_FileID = 0;
            }
            else
            {
                m_FileID = assetsFile.m_Externals.FindIndex(x => string.Equals(x.fileName, name, StringComparison.OrdinalIgnoreCase));
                if (m_FileID == -1)
                {
                    assetsFile.m_Externals.Add(new FileIdentifier
                    {
                        fileName = m_Object.assetsFile.fileName
                    });
                    m_FileID = assetsFile.m_Externals.Count;
                }
                else
                {
                    m_FileID += 1;
                }
            }

            var assetsManager = assetsFile.assetsManager;
            var assetsFileList = assetsManager.assetsFileList;
            var assetsFileIndexCache = assetsManager.assetsFileIndexCache;

            if (!assetsFileIndexCache.TryGetValue(name, out index))
            {
                index = assetsFileList.FindIndex(x => x.fileName.Equals(name, StringComparison.OrdinalIgnoreCase));
                assetsFileIndexCache.Add(name, index);
            }

            m_PathID = m_Object.m_PathID;
        }

        public bool IsNull => m_PathID == 0 || m_FileID < 0;
    }
}

```

`AssetStudio/Classes/PlayerSettings.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class PlayerSettings : Object
    {
        public string companyName;
        public string productName;

        public PlayerSettings(ObjectReader reader) : base(reader)
        {
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 4)) //5.4.0 nad up
            {
                var productGUID = reader.ReadBytes(16);
            }

            var AndroidProfiler = reader.ReadBoolean();
            //bool AndroidFilterTouchesWhenObscured 2017.2 and up
            //bool AndroidEnableSustainedPerformanceMode 2018 and up
            reader.AlignStream();
            int defaultScreenOrientation = reader.ReadInt32();
            int targetDevice = reader.ReadInt32();
            if (version[0] < 5 || (version[0] == 5 && version[1] < 3)) //5.3 down
            {
                if (version[0] < 5) //5.0 down
                {
                    int targetPlatform = reader.ReadInt32(); //4.0 and up targetGlesGraphics
                    if (version[0] > 4 || (version[0] == 4 && version[1] >= 6)) //4.6 and up
                    {
                        var targetIOSGraphics = reader.ReadInt32();
                    }
                }
                int targetResolution = reader.ReadInt32();
            }
            else
            {
                var useOnDemandResources = reader.ReadBoolean();
                reader.AlignStream();
            }
            if (version[0] > 3 || (version[0] == 3 && version[1] >= 5)) //3.5 and up
            {
                var accelerometerFrequency = reader.ReadInt32();
            }
            companyName = reader.ReadAlignedString();
            productName = reader.ReadAlignedString();
        }
    }
}

```

`AssetStudio/Classes/RectTransform.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class RectTransform : Transform
    {
        public RectTransform(ObjectReader reader) : base(reader)
        {
        }
    }
}

```

`AssetStudio/Classes/Renderer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class StaticBatchInfo
    {
        public ushort firstSubMesh;
        public ushort subMeshCount;

        public StaticBatchInfo(ObjectReader reader)
        {
            firstSubMesh = reader.ReadUInt16();
            subMeshCount = reader.ReadUInt16();
        }
    }

    public abstract class Renderer : Component
    {
        public PPtr<Material>[] m_Materials;
        public StaticBatchInfo m_StaticBatchInfo;
        public uint[] m_SubsetIndices;

        protected Renderer(ObjectReader reader) : base(reader)
        {
            if (version[0] < 5) //5.0 down
            {
                var m_Enabled = reader.ReadBoolean();
                var m_CastShadows = reader.ReadBoolean();
                var m_ReceiveShadows = reader.ReadBoolean();
                var m_LightmapIndex = reader.ReadByte();
            }
            else //5.0 and up
            {
                if (version[0] > 5 || (version[0] == 5 && version[1] >= 4)) //5.4 and up
                {
                    var m_Enabled = reader.ReadBoolean();
                    var m_CastShadows = reader.ReadByte();
                    var m_ReceiveShadows = reader.ReadByte();
                    if (version[0] > 2017 || (version[0] == 2017 && version[1] >= 2)) //2017.2 and up
                    {
                        var m_DynamicOccludee = reader.ReadByte();
                    }
                    if (version[0] >= 2021) //2021.1 and up
                    {
                        var m_StaticShadowCaster = reader.ReadByte();
                    }
                    var m_MotionVectors = reader.ReadByte();
                    var m_LightProbeUsage = reader.ReadByte();
                    var m_ReflectionProbeUsage = reader.ReadByte();
                    if (version[0] > 2019 || (version[0] == 2019 && version[1] >= 3)) //2019.3 and up
                    {
                        var m_RayTracingMode = reader.ReadByte();
                    }
                    if (version[0] >= 2020) //2020.1 and up
                    {
                        var m_RayTraceProcedural = reader.ReadByte();
                    }
                    reader.AlignStream();
                }
                else
                {
                    var m_Enabled = reader.ReadBoolean();
                    reader.AlignStream();
                    var m_CastShadows = reader.ReadByte();
                    var m_ReceiveShadows = reader.ReadBoolean();
                    reader.AlignStream();
                }

                if (version[0] >= 2018) //2018 and up
                {
                    var m_RenderingLayerMask = reader.ReadUInt32();
                }

                if (version[0] > 2018 || (version[0] == 2018 && version[1] >= 3)) //2018.3 and up
                {
                    var m_RendererPriority = reader.ReadInt32();
                }

                var m_LightmapIndex = reader.ReadUInt16();
                var m_LightmapIndexDynamic = reader.ReadUInt16();
            }

            if (version[0] >= 3) //3.0 and up
            {
                var m_LightmapTilingOffset = reader.ReadVector4();
            }

            if (version[0] >= 5) //5.0 and up
            {
                var m_LightmapTilingOffsetDynamic = reader.ReadVector4();
            }

            var m_MaterialsSize = reader.ReadInt32();
            m_Materials = new PPtr<Material>[m_MaterialsSize];
            for (int i = 0; i < m_MaterialsSize; i++)
            {
                m_Materials[i] = new PPtr<Material>(reader);
            }

            if (version[0] < 3) //3.0 down
            {
                var m_LightmapTilingOffset = reader.ReadVector4();
            }
            else //3.0 and up
            {
                if (version[0] > 5 || (version[0] == 5 && version[1] >= 5)) //5.5 and up
                {
                    m_StaticBatchInfo = new StaticBatchInfo(reader);
                }
                else
                {
                    m_SubsetIndices = reader.ReadUInt32Array();
                }

                var m_StaticBatchRoot = new PPtr<Transform>(reader);
            }

            if (version[0] > 5 || (version[0] == 5 && version[1] >= 4)) //5.4 and up
            {
                var m_ProbeAnchor = new PPtr<Transform>(reader);
                var m_LightProbeVolumeOverride = new PPtr<GameObject>(reader);
            }
            else if (version[0] > 3 || (version[0] == 3 && version[1] >= 5)) //3.5 - 5.3
            {
                var m_UseLightProbes = reader.ReadBoolean();
                reader.AlignStream();

                if (version[0] >= 5)//5.0 and up
                {
                    var m_ReflectionProbeUsage = reader.ReadInt32();
                }

                var m_LightProbeAnchor = new PPtr<Transform>(reader); //5.0 and up m_ProbeAnchor
            }

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                if (version[0] == 4 && version[1] == 3) //4.3
                {
                    var m_SortingLayer = reader.ReadInt16();
                }
                else
                {
                    var m_SortingLayerID = reader.ReadUInt32();
                }

                //SInt16 m_SortingLayer 5.6 and up
                var m_SortingOrder = reader.ReadInt16();
                reader.AlignStream();
            }
        }
    }
}

```

`AssetStudio/Classes/ResourceManager.cs`:

```cs
using System.Collections.Generic;

namespace AssetStudio
{
    public class ResourceManager : Object
    {
        public KeyValuePair<string, PPtr<Object>>[] m_Container;

        public ResourceManager(ObjectReader reader) : base(reader)
        {
            var m_ContainerSize = reader.ReadInt32();
            m_Container = new KeyValuePair<string, PPtr<Object>>[m_ContainerSize];
            for (int i = 0; i < m_ContainerSize; i++)
            {
                m_Container[i] = new KeyValuePair<string, PPtr<Object>>(reader.ReadAlignedString(), new PPtr<Object>(reader));
            }
        }
    }
}

```

`AssetStudio/Classes/RuntimeAnimatorController.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public abstract class RuntimeAnimatorController : NamedObject
    {
        protected RuntimeAnimatorController(ObjectReader reader) : base(reader)
        {

        }
    }
}

```

`AssetStudio/Classes/Shader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace AssetStudio
{
    public class Hash128
    {
        public byte[] bytes;

        public Hash128(BinaryReader reader)
        {
            bytes = reader.ReadBytes(16);
        }
    }

    public class StructParameter
    {
        public MatrixParameter[] m_MatrixParams;
        public VectorParameter[] m_VectorParams;

        public StructParameter(BinaryReader reader)
        {
            var m_NameIndex = reader.ReadInt32();
            var m_Index = reader.ReadInt32();
            var m_ArraySize = reader.ReadInt32();
            var m_StructSize = reader.ReadInt32();

            int numVectorParams = reader.ReadInt32();
            m_VectorParams = new VectorParameter[numVectorParams];
            for (int i = 0; i < numVectorParams; i++)
            {
                m_VectorParams[i] = new VectorParameter(reader);
            }

            int numMatrixParams = reader.ReadInt32();
            m_MatrixParams = new MatrixParameter[numMatrixParams];
            for (int i = 0; i < numMatrixParams; i++)
            {
                m_MatrixParams[i] = new MatrixParameter(reader);
            }
        }
    }

    public class SamplerParameter
    {
        public uint sampler;
        public int bindPoint;

        public SamplerParameter(BinaryReader reader)
        {
            sampler = reader.ReadUInt32();
            bindPoint = reader.ReadInt32();
        }
    }
    public enum TextureDimension
    {
        Unknown = -1,
        None = 0,
        Any = 1,
        Tex2D = 2,
        Tex3D = 3,
        Cube = 4,
        Tex2DArray = 5,
        CubeArray = 6
    };

    public class SerializedTextureProperty
    {
        public string m_DefaultName;
        public TextureDimension m_TexDim;

        public SerializedTextureProperty(BinaryReader reader)
        {
            m_DefaultName = reader.ReadAlignedString();
            m_TexDim = (TextureDimension)reader.ReadInt32();
        }
    }

    public enum SerializedPropertyType
    {
        Color = 0,
        Vector = 1,
        Float = 2,
        Range = 3,
        Texture = 4,
        Int = 5
    };

    public class SerializedProperty
    {
        public string m_Name;
        public string m_Description;
        public string[] m_Attributes;
        public SerializedPropertyType m_Type;
        public uint m_Flags;
        public float[] m_DefValue;
        public SerializedTextureProperty m_DefTexture;

        public SerializedProperty(BinaryReader reader)
        {
            m_Name = reader.ReadAlignedString();
            m_Description = reader.ReadAlignedString();
            m_Attributes = reader.ReadStringArray();
            m_Type = (SerializedPropertyType)reader.ReadInt32();
            m_Flags = reader.ReadUInt32();
            m_DefValue = reader.ReadSingleArray(4);
            m_DefTexture = new SerializedTextureProperty(reader);
        }
    }

    public class SerializedProperties
    {
        public SerializedProperty[] m_Props;

        public SerializedProperties(BinaryReader reader)
        {
            int numProps = reader.ReadInt32();
            m_Props = new SerializedProperty[numProps];
            for (int i = 0; i < numProps; i++)
            {
                m_Props[i] = new SerializedProperty(reader);
            }
        }
    }

    public class SerializedShaderFloatValue
    {
        public float val;
        public string name;

        public SerializedShaderFloatValue(BinaryReader reader)
        {
            val = reader.ReadSingle();
            name = reader.ReadAlignedString();
        }
    }

    public class SerializedShaderRTBlendState
    {
        public SerializedShaderFloatValue srcBlend;
        public SerializedShaderFloatValue destBlend;
        public SerializedShaderFloatValue srcBlendAlpha;
        public SerializedShaderFloatValue destBlendAlpha;
        public SerializedShaderFloatValue blendOp;
        public SerializedShaderFloatValue blendOpAlpha;
        public SerializedShaderFloatValue colMask;

        public SerializedShaderRTBlendState(BinaryReader reader)
        {
            srcBlend = new SerializedShaderFloatValue(reader);
            destBlend = new SerializedShaderFloatValue(reader);
            srcBlendAlpha = new SerializedShaderFloatValue(reader);
            destBlendAlpha = new SerializedShaderFloatValue(reader);
            blendOp = new SerializedShaderFloatValue(reader);
            blendOpAlpha = new SerializedShaderFloatValue(reader);
            colMask = new SerializedShaderFloatValue(reader);
        }
    }

    public class SerializedStencilOp
    {
        public SerializedShaderFloatValue pass;
        public SerializedShaderFloatValue fail;
        public SerializedShaderFloatValue zFail;
        public SerializedShaderFloatValue comp;

        public SerializedStencilOp(BinaryReader reader)
        {
            pass = new SerializedShaderFloatValue(reader);
            fail = new SerializedShaderFloatValue(reader);
            zFail = new SerializedShaderFloatValue(reader);
            comp = new SerializedShaderFloatValue(reader);
        }
    }

    public class SerializedShaderVectorValue
    {
        public SerializedShaderFloatValue x;
        public SerializedShaderFloatValue y;
        public SerializedShaderFloatValue z;
        public SerializedShaderFloatValue w;
        public string name;

        public SerializedShaderVectorValue(BinaryReader reader)
        {
            x = new SerializedShaderFloatValue(reader);
            y = new SerializedShaderFloatValue(reader);
            z = new SerializedShaderFloatValue(reader);
            w = new SerializedShaderFloatValue(reader);
            name = reader.ReadAlignedString();
        }
    }

    public enum FogMode
    {
        Unknown = -1,
        Disabled = 0,
        Linear = 1,
        Exp = 2,
        Exp2 = 3
    };

    public class SerializedShaderState
    {
        public string m_Name;
        public SerializedShaderRTBlendState[] rtBlend;
        public bool rtSeparateBlend;
        public SerializedShaderFloatValue zClip;
        public SerializedShaderFloatValue zTest;
        public SerializedShaderFloatValue zWrite;
        public SerializedShaderFloatValue culling;
        public SerializedShaderFloatValue conservative;
        public SerializedShaderFloatValue offsetFactor;
        public SerializedShaderFloatValue offsetUnits;
        public SerializedShaderFloatValue alphaToMask;
        public SerializedStencilOp stencilOp;
        public SerializedStencilOp stencilOpFront;
        public SerializedStencilOp stencilOpBack;
        public SerializedShaderFloatValue stencilReadMask;
        public SerializedShaderFloatValue stencilWriteMask;
        public SerializedShaderFloatValue stencilRef;
        public SerializedShaderFloatValue fogStart;
        public SerializedShaderFloatValue fogEnd;
        public SerializedShaderFloatValue fogDensity;
        public SerializedShaderVectorValue fogColor;
        public FogMode fogMode;
        public int gpuProgramID;
        public SerializedTagMap m_Tags;
        public int m_LOD;
        public bool lighting;

        public SerializedShaderState(ObjectReader reader)
        {
            var version = reader.version;

            m_Name = reader.ReadAlignedString();
            rtBlend = new SerializedShaderRTBlendState[8];
            for (int i = 0; i < 8; i++)
            {
                rtBlend[i] = new SerializedShaderRTBlendState(reader);
            }
            rtSeparateBlend = reader.ReadBoolean();
            reader.AlignStream();
            if (version[0] > 2017 || (version[0] == 2017 && version[1] >= 2)) //2017.2 and up
            {
                zClip = new SerializedShaderFloatValue(reader);
            }
            zTest = new SerializedShaderFloatValue(reader);
            zWrite = new SerializedShaderFloatValue(reader);
            culling = new SerializedShaderFloatValue(reader);
            if (version[0] >= 2020) //2020.1 and up
            {
                conservative = new SerializedShaderFloatValue(reader);
            }
            offsetFactor = new SerializedShaderFloatValue(reader);
            offsetUnits = new SerializedShaderFloatValue(reader);
            alphaToMask = new SerializedShaderFloatValue(reader);
            stencilOp = new SerializedStencilOp(reader);
            stencilOpFront = new SerializedStencilOp(reader);
            stencilOpBack = new SerializedStencilOp(reader);
            stencilReadMask = new SerializedShaderFloatValue(reader);
            stencilWriteMask = new SerializedShaderFloatValue(reader);
            stencilRef = new SerializedShaderFloatValue(reader);
            fogStart = new SerializedShaderFloatValue(reader);
            fogEnd = new SerializedShaderFloatValue(reader);
            fogDensity = new SerializedShaderFloatValue(reader);
            fogColor = new SerializedShaderVectorValue(reader);
            fogMode = (FogMode)reader.ReadInt32();
            gpuProgramID = reader.ReadInt32();
            m_Tags = new SerializedTagMap(reader);
            m_LOD = reader.ReadInt32();
            lighting = reader.ReadBoolean();
            reader.AlignStream();
        }
    }

    public class ShaderBindChannel
    {
        public sbyte source;
        public sbyte target;

        public ShaderBindChannel(BinaryReader reader)
        {
            source = reader.ReadSByte();
            target = reader.ReadSByte();
        }
    }

    public class ParserBindChannels
    {
        public ShaderBindChannel[] m_Channels;
        public uint m_SourceMap;

        public ParserBindChannels(BinaryReader reader)
        {
            int numChannels = reader.ReadInt32();
            m_Channels = new ShaderBindChannel[numChannels];
            for (int i = 0; i < numChannels; i++)
            {
                m_Channels[i] = new ShaderBindChannel(reader);
            }
            reader.AlignStream();

            m_SourceMap = reader.ReadUInt32();
        }
    }

    public class VectorParameter
    {
        public int m_NameIndex;
        public int m_Index;
        public int m_ArraySize;
        public sbyte m_Type;
        public sbyte m_Dim;

        public VectorParameter(BinaryReader reader)
        {
            m_NameIndex = reader.ReadInt32();
            m_Index = reader.ReadInt32();
            m_ArraySize = reader.ReadInt32();
            m_Type = reader.ReadSByte();
            m_Dim = reader.ReadSByte();
            reader.AlignStream();
        }
    }

    public class MatrixParameter
    {
        public int m_NameIndex;
        public int m_Index;
        public int m_ArraySize;
        public sbyte m_Type;
        public sbyte m_RowCount;

        public MatrixParameter(BinaryReader reader)
        {
            m_NameIndex = reader.ReadInt32();
            m_Index = reader.ReadInt32();
            m_ArraySize = reader.ReadInt32();
            m_Type = reader.ReadSByte();
            m_RowCount = reader.ReadSByte();
            reader.AlignStream();
        }
    }

    public class TextureParameter
    {
        public int m_NameIndex;
        public int m_Index;
        public int m_SamplerIndex;
        public sbyte m_Dim;

        public TextureParameter(ObjectReader reader)
        {
            var version = reader.version;

            m_NameIndex = reader.ReadInt32();
            m_Index = reader.ReadInt32();
            m_SamplerIndex = reader.ReadInt32();
            if (version[0] > 2017 || (version[0] == 2017 && version[1] >= 3)) //2017.3 and up
            {
                var m_MultiSampled = reader.ReadBoolean();
            }
            m_Dim = reader.ReadSByte();
            reader.AlignStream();
        }
    }

    public class BufferBinding
    {
        public int m_NameIndex;
        public int m_Index;
        public int m_ArraySize;

        public BufferBinding(ObjectReader reader)
        {
            var version = reader.version;

            m_NameIndex = reader.ReadInt32();
            m_Index = reader.ReadInt32();
            if (version[0] >= 2020) //2020.1 and up
            {
                m_ArraySize = reader.ReadInt32();
            }
        }
    }

    public class ConstantBuffer
    {
        public int m_NameIndex;
        public MatrixParameter[] m_MatrixParams;
        public VectorParameter[] m_VectorParams;
        public StructParameter[] m_StructParams;
        public int m_Size;
        public bool m_IsPartialCB;

        public ConstantBuffer(ObjectReader reader)
        {
            var version = reader.version;

            m_NameIndex = reader.ReadInt32();

            int numMatrixParams = reader.ReadInt32();
            m_MatrixParams = new MatrixParameter[numMatrixParams];
            for (int i = 0; i < numMatrixParams; i++)
            {
                m_MatrixParams[i] = new MatrixParameter(reader);
            }

            int numVectorParams = reader.ReadInt32();
            m_VectorParams = new VectorParameter[numVectorParams];
            for (int i = 0; i < numVectorParams; i++)
            {
                m_VectorParams[i] = new VectorParameter(reader);
            }
            if (version[0] > 2017 || (version[0] == 2017 && version[1] >= 3)) //2017.3 and up
            {
                int numStructParams = reader.ReadInt32();
                m_StructParams = new StructParameter[numStructParams];
                for (int i = 0; i < numStructParams; i++)
                {
                    m_StructParams[i] = new StructParameter(reader);
                }
            }
            m_Size = reader.ReadInt32();

            if ((version[0] == 2020 && version[1] > 3) ||
               (version[0] == 2020 && version[1] == 3 && version[2] >= 2) || //2020.3.2f1 and up
               (version[0] > 2021) ||
               (version[0] == 2021 && version[1] > 1) ||
               (version[0] == 2021 && version[1] == 1 && version[2] >= 4)) //2021.1.4f1 and up
            {
                m_IsPartialCB = reader.ReadBoolean();
                reader.AlignStream();
            }
        }
    }

    public class UAVParameter
    {
        public int m_NameIndex;
        public int m_Index;
        public int m_OriginalIndex;

        public UAVParameter(BinaryReader reader)
        {
            m_NameIndex = reader.ReadInt32();
            m_Index = reader.ReadInt32();
            m_OriginalIndex = reader.ReadInt32();
        }
    }

    public enum ShaderGpuProgramType
    {
        Unknown = 0,
        GLLegacy = 1,
        GLES31AEP = 2,
        GLES31 = 3,
        GLES3 = 4,
        GLES = 5,
        GLCore32 = 6,
        GLCore41 = 7,
        GLCore43 = 8,
        DX9VertexSM20 = 9,
        DX9VertexSM30 = 10,
        DX9PixelSM20 = 11,
        DX9PixelSM30 = 12,
        DX10Level9Vertex = 13,
        DX10Level9Pixel = 14,
        DX11VertexSM40 = 15,
        DX11VertexSM50 = 16,
        DX11PixelSM40 = 17,
        DX11PixelSM50 = 18,
        DX11GeometrySM40 = 19,
        DX11GeometrySM50 = 20,
        DX11HullSM50 = 21,
        DX11DomainSM50 = 22,
        MetalVS = 23,
        MetalFS = 24,
        SPIRV = 25,
        ConsoleVS = 26,
        ConsoleFS = 27,
        ConsoleHS = 28,
        ConsoleDS = 29,
        ConsoleGS = 30,
        RayTracing = 31,
        PS5NGGC = 32
    };

    public class SerializedProgramParameters
    {
        public VectorParameter[] m_VectorParams;
        public MatrixParameter[] m_MatrixParams;
        public TextureParameter[] m_TextureParams;
        public BufferBinding[] m_BufferParams;
        public ConstantBuffer[] m_ConstantBuffers;
        public BufferBinding[] m_ConstantBufferBindings;
        public UAVParameter[] m_UAVParams;
        public SamplerParameter[] m_Samplers;

        public SerializedProgramParameters(ObjectReader reader)
        {
            int numVectorParams = reader.ReadInt32();
            m_VectorParams = new VectorParameter[numVectorParams];
            for (int i = 0; i < numVectorParams; i++)
            {
                m_VectorParams[i] = new VectorParameter(reader);
            }

            int numMatrixParams = reader.ReadInt32();
            m_MatrixParams = new MatrixParameter[numMatrixParams];
            for (int i = 0; i < numMatrixParams; i++)
            {
                m_MatrixParams[i] = new MatrixParameter(reader);
            }

            int numTextureParams = reader.ReadInt32();
            m_TextureParams = new TextureParameter[numTextureParams];
            for (int i = 0; i < numTextureParams; i++)
            {
                m_TextureParams[i] = new TextureParameter(reader);
            }

            int numBufferParams = reader.ReadInt32();
            m_BufferParams = new BufferBinding[numBufferParams];
            for (int i = 0; i < numBufferParams; i++)
            {
                m_BufferParams[i] = new BufferBinding(reader);
            }

            int numConstantBuffers = reader.ReadInt32();
            m_ConstantBuffers = new ConstantBuffer[numConstantBuffers];
            for (int i = 0; i < numConstantBuffers; i++)
            {
                m_ConstantBuffers[i] = new ConstantBuffer(reader);
            }

            int numConstantBufferBindings = reader.ReadInt32();
            m_ConstantBufferBindings = new BufferBinding[numConstantBufferBindings];
            for (int i = 0; i < numConstantBufferBindings; i++)
            {
                m_ConstantBufferBindings[i] = new BufferBinding(reader);
            }

            int numUAVParams = reader.ReadInt32();
            m_UAVParams = new UAVParameter[numUAVParams];
            for (int i = 0; i < numUAVParams; i++)
            {
                m_UAVParams[i] = new UAVParameter(reader);
            }

            int numSamplers = reader.ReadInt32();
            m_Samplers = new SamplerParameter[numSamplers];
            for (int i = 0; i < numSamplers; i++)
            {
                m_Samplers[i] = new SamplerParameter(reader);
            }
        }
    }

    public class SerializedSubProgram
    {
        public uint m_BlobIndex;
        public ParserBindChannels m_Channels;
        public ushort[] m_KeywordIndices;
        public sbyte m_ShaderHardwareTier;
        public ShaderGpuProgramType m_GpuProgramType;
        public SerializedProgramParameters m_Parameters;
        public VectorParameter[] m_VectorParams;
        public MatrixParameter[] m_MatrixParams;
        public TextureParameter[] m_TextureParams;
        public BufferBinding[] m_BufferParams;
        public ConstantBuffer[] m_ConstantBuffers;
        public BufferBinding[] m_ConstantBufferBindings;
        public UAVParameter[] m_UAVParams;
        public SamplerParameter[] m_Samplers;

        public SerializedSubProgram(ObjectReader reader)
        {
            var version = reader.version;

            m_BlobIndex = reader.ReadUInt32();
            m_Channels = new ParserBindChannels(reader);

            if ((version[0] >= 2019 && version[0] < 2021) || (version[0] == 2021 && version[1] < 2)) //2019 ~2021.1
            {
                var m_GlobalKeywordIndices = reader.ReadUInt16Array();
                reader.AlignStream();
                var m_LocalKeywordIndices = reader.ReadUInt16Array();
                reader.AlignStream();
            }
            else
            {
                m_KeywordIndices = reader.ReadUInt16Array();
                if (version[0] >= 2017) //2017 and up
                {
                    reader.AlignStream();
                }
            }

            m_ShaderHardwareTier = reader.ReadSByte();
            m_GpuProgramType = (ShaderGpuProgramType)reader.ReadSByte();
            reader.AlignStream();

            if ((version[0] == 2020 && version[1] > 3) ||
               (version[0] == 2020 && version[1] == 3 && version[2] >= 2) || //2020.3.2f1 and up
               (version[0] > 2021) ||
               (version[0] == 2021 && version[1] > 1) ||
               (version[0] == 2021 && version[1] == 1 && version[2] >= 1)) //2021.1.1f1 and up
            {
                m_Parameters = new SerializedProgramParameters(reader);
            }
            else
            {
                int numVectorParams = reader.ReadInt32();
                m_VectorParams = new VectorParameter[numVectorParams];
                for (int i = 0; i < numVectorParams; i++)
                {
                    m_VectorParams[i] = new VectorParameter(reader);
                }

                int numMatrixParams = reader.ReadInt32();
                m_MatrixParams = new MatrixParameter[numMatrixParams];
                for (int i = 0; i < numMatrixParams; i++)
                {
                    m_MatrixParams[i] = new MatrixParameter(reader);
                }

                int numTextureParams = reader.ReadInt32();
                m_TextureParams = new TextureParameter[numTextureParams];
                for (int i = 0; i < numTextureParams; i++)
                {
                    m_TextureParams[i] = new TextureParameter(reader);
                }

                int numBufferParams = reader.ReadInt32();
                m_BufferParams = new BufferBinding[numBufferParams];
                for (int i = 0; i < numBufferParams; i++)
                {
                    m_BufferParams[i] = new BufferBinding(reader);
                }

                int numConstantBuffers = reader.ReadInt32();
                m_ConstantBuffers = new ConstantBuffer[numConstantBuffers];
                for (int i = 0; i < numConstantBuffers; i++)
                {
                    m_ConstantBuffers[i] = new ConstantBuffer(reader);
                }

                int numConstantBufferBindings = reader.ReadInt32();
                m_ConstantBufferBindings = new BufferBinding[numConstantBufferBindings];
                for (int i = 0; i < numConstantBufferBindings; i++)
                {
                    m_ConstantBufferBindings[i] = new BufferBinding(reader);
                }

                int numUAVParams = reader.ReadInt32();
                m_UAVParams = new UAVParameter[numUAVParams];
                for (int i = 0; i < numUAVParams; i++)
                {
                    m_UAVParams[i] = new UAVParameter(reader);
                }

                if (version[0] >= 2017) //2017 and up
                {
                    int numSamplers = reader.ReadInt32();
                    m_Samplers = new SamplerParameter[numSamplers];
                    for (int i = 0; i < numSamplers; i++)
                    {
                        m_Samplers[i] = new SamplerParameter(reader);
                    }
                }
            }

            if (version[0] > 2017 || (version[0] == 2017 && version[1] >= 2)) //2017.2 and up
            {
                if (version[0] >= 2021) //2021.1 and up
                {
                    var m_ShaderRequirements = reader.ReadInt64();
                }
                else
                {
                    var m_ShaderRequirements = reader.ReadInt32();
                }
            }
        }
    }

    public class SerializedProgram
    {
        public SerializedSubProgram[] m_SubPrograms;
        public SerializedProgramParameters m_CommonParameters;
        public ushort[] m_SerializedKeywordStateMask;

        public SerializedProgram(ObjectReader reader)
        {
            var version = reader.version;

            int numSubPrograms = reader.ReadInt32();
            m_SubPrograms = new SerializedSubProgram[numSubPrograms];
            for (int i = 0; i < numSubPrograms; i++)
            {
                m_SubPrograms[i] = new SerializedSubProgram(reader);
            }

            if ((version[0] == 2020 && version[1] > 3) ||
               (version[0] == 2020 && version[1] == 3 && version[2] >= 2) || //2020.3.2f1 and up
               (version[0] > 2021) ||
               (version[0] == 2021 && version[1] > 1) ||
               (version[0] == 2021 && version[1] == 1 && version[2] >= 1)) //2021.1.1f1 and up
            {
                m_CommonParameters = new SerializedProgramParameters(reader);
            }

            if (version[0] > 2022 || (version[0] == 2022 && version[1] >= 1)) //2022.1 and up
            {
                m_SerializedKeywordStateMask = reader.ReadUInt16Array();
                reader.AlignStream();
            }
        }
    }

    public enum PassType
    {
        Normal = 0,
        Use = 1,
        Grab = 2
    };

    public class SerializedPass
    {
        public Hash128[] m_EditorDataHash;
        public byte[] m_Platforms;
        public ushort[] m_LocalKeywordMask;
        public ushort[] m_GlobalKeywordMask;
        public KeyValuePair<string, int>[] m_NameIndices;
        public PassType m_Type;
        public SerializedShaderState m_State;
        public uint m_ProgramMask;
        public SerializedProgram progVertex;
        public SerializedProgram progFragment;
        public SerializedProgram progGeometry;
        public SerializedProgram progHull;
        public SerializedProgram progDomain;
        public SerializedProgram progRayTracing;
        public bool m_HasInstancingVariant;
        public string m_UseName;
        public string m_Name;
        public string m_TextureName;
        public SerializedTagMap m_Tags;
        public ushort[] m_SerializedKeywordStateMask;

        public SerializedPass(ObjectReader reader)
        {
            var version = reader.version;

            if (version[0] > 2020 || (version[0] == 2020 && version[1] >= 2)) //2020.2 and up
            {
                int numEditorDataHash = reader.ReadInt32();
                m_EditorDataHash = new Hash128[numEditorDataHash];
                for (int i = 0; i < numEditorDataHash; i++)
                {
                    m_EditorDataHash[i] = new Hash128(reader);
                }
                reader.AlignStream();
                m_Platforms = reader.ReadUInt8Array();
                reader.AlignStream();
                if (version[0] < 2021 || (version[0] == 2021 && version[1] < 2)) //2021.1 and down
                {
                    m_LocalKeywordMask = reader.ReadUInt16Array();
                    reader.AlignStream();
                    m_GlobalKeywordMask = reader.ReadUInt16Array();
                    reader.AlignStream();
                }
            }

            int numIndices = reader.ReadInt32();
            m_NameIndices = new KeyValuePair<string, int>[numIndices];
            for (int i = 0; i < numIndices; i++)
            {
                m_NameIndices[i] = new KeyValuePair<string, int>(reader.ReadAlignedString(), reader.ReadInt32());
            }

            m_Type = (PassType)reader.ReadInt32();
            m_State = new SerializedShaderState(reader);
            m_ProgramMask = reader.ReadUInt32();
            progVertex = new SerializedProgram(reader);
            progFragment = new SerializedProgram(reader);
            progGeometry = new SerializedProgram(reader);
            progHull = new SerializedProgram(reader);
            progDomain = new SerializedProgram(reader);
            if (version[0] > 2019 || (version[0] == 2019 && version[1] >= 3)) //2019.3 and up
            {
                progRayTracing = new SerializedProgram(reader);
            }
            m_HasInstancingVariant = reader.ReadBoolean();
            if (version[0] >= 2018) //2018 and up
            {
                var m_HasProceduralInstancingVariant = reader.ReadBoolean();
            }
            reader.AlignStream();
            m_UseName = reader.ReadAlignedString();
            m_Name = reader.ReadAlignedString();
            m_TextureName = reader.ReadAlignedString();
            m_Tags = new SerializedTagMap(reader);
            if (version[0] == 2021 && version[1] >= 2) //2021.2 ~2021.x
            {
                m_SerializedKeywordStateMask = reader.ReadUInt16Array();
                reader.AlignStream();
            }
        }
    }

    public class SerializedTagMap
    {
        public KeyValuePair<string, string>[] tags;

        public SerializedTagMap(BinaryReader reader)
        {
            int numTags = reader.ReadInt32();
            tags = new KeyValuePair<string, string>[numTags];
            for (int i = 0; i < numTags; i++)
            {
                tags[i] = new KeyValuePair<string, string>(reader.ReadAlignedString(), reader.ReadAlignedString());
            }
        }
    }

    public class SerializedSubShader
    {
        public SerializedPass[] m_Passes;
        public SerializedTagMap m_Tags;
        public int m_LOD;

        public SerializedSubShader(ObjectReader reader)
        {
            int numPasses = reader.ReadInt32();
            m_Passes = new SerializedPass[numPasses];
            for (int i = 0; i < numPasses; i++)
            {
                m_Passes[i] = new SerializedPass(reader);
            }

            m_Tags = new SerializedTagMap(reader);
            m_LOD = reader.ReadInt32();
        }
    }

    public class SerializedShaderDependency
    {
        public string from;
        public string to;

        public SerializedShaderDependency(BinaryReader reader)
        {
            from = reader.ReadAlignedString();
            to = reader.ReadAlignedString();
        }
    }

    public class SerializedCustomEditorForRenderPipeline
    {
        public string customEditorName;
        public string renderPipelineType;

        public SerializedCustomEditorForRenderPipeline(BinaryReader reader)
        {
            customEditorName = reader.ReadAlignedString();
            renderPipelineType = reader.ReadAlignedString();
        }
    }

    public class SerializedShader
    {
        public SerializedProperties m_PropInfo;
        public SerializedSubShader[] m_SubShaders;
        public string[] m_KeywordNames;
        public byte[] m_KeywordFlags;
        public string m_Name;
        public string m_CustomEditorName;
        public string m_FallbackName;
        public SerializedShaderDependency[] m_Dependencies;
        public SerializedCustomEditorForRenderPipeline[] m_CustomEditorForRenderPipelines;
        public bool m_DisableNoSubshadersMessage;

        public SerializedShader(ObjectReader reader)
        {
            var version = reader.version;

            m_PropInfo = new SerializedProperties(reader);

            int numSubShaders = reader.ReadInt32();
            m_SubShaders = new SerializedSubShader[numSubShaders];
            for (int i = 0; i < numSubShaders; i++)
            {
                m_SubShaders[i] = new SerializedSubShader(reader);
            }

            if (version[0] > 2021 || (version[0] == 2021 && version[1] >= 2)) //2021.2 and up
            {
                m_KeywordNames = reader.ReadStringArray();
                m_KeywordFlags = reader.ReadUInt8Array();
                reader.AlignStream();
            }

            m_Name = reader.ReadAlignedString();
            m_CustomEditorName = reader.ReadAlignedString();
            m_FallbackName = reader.ReadAlignedString();

            int numDependencies = reader.ReadInt32();
            m_Dependencies = new SerializedShaderDependency[numDependencies];
            for (int i = 0; i < numDependencies; i++)
            {
                m_Dependencies[i] = new SerializedShaderDependency(reader);
            }

            if (version[0] >= 2021) //2021.1 and up
            {
                int m_CustomEditorForRenderPipelinesSize = reader.ReadInt32();
                m_CustomEditorForRenderPipelines = new SerializedCustomEditorForRenderPipeline[m_CustomEditorForRenderPipelinesSize];
                for (int i = 0; i < m_CustomEditorForRenderPipelinesSize; i++)
                {
                    m_CustomEditorForRenderPipelines[i] = new SerializedCustomEditorForRenderPipeline(reader);
                }
            }

            m_DisableNoSubshadersMessage = reader.ReadBoolean();
            reader.AlignStream();
        }
    }

    public enum ShaderCompilerPlatform
    {
        None = -1,
        GL = 0,
        D3D9 = 1,
        Xbox360 = 2,
        PS3 = 3,
        D3D11 = 4,
        GLES20 = 5,
        NaCl = 6,
        Flash = 7,
        D3D11_9x = 8,
        GLES3Plus = 9,
        PSP2 = 10,
        PS4 = 11,
        XboxOne = 12,
        PSM = 13,
        Metal = 14,
        OpenGLCore = 15,
        N3DS = 16,
        WiiU = 17,
        Vulkan = 18,
        Switch = 19,
        XboxOneD3D12 = 20,
        GameCoreXboxOne = 21,
        GameCoreScarlett = 22,
        PS5 = 23,
        PS5NGGC = 24
    };

    public class Shader : NamedObject
    {
        public byte[] m_Script;
        //5.3 - 5.4
        public uint decompressedSize;
        public byte[] m_SubProgramBlob;
        //5.5 and up
        public SerializedShader m_ParsedForm;
        public ShaderCompilerPlatform[] platforms;
        public uint[][] offsets;
        public uint[][] compressedLengths;
        public uint[][] decompressedLengths;
        public byte[] compressedBlob;

        public Shader(ObjectReader reader) : base(reader)
        {
            if (version[0] == 5 && version[1] >= 5 || version[0] > 5) //5.5 and up
            {
                m_ParsedForm = new SerializedShader(reader);
                platforms = reader.ReadUInt32Array().Select(x => (ShaderCompilerPlatform)x).ToArray();
                if (version[0] > 2019 || (version[0] == 2019 && version[1] >= 3)) //2019.3 and up
                {
                    offsets = reader.ReadUInt32ArrayArray();
                    compressedLengths = reader.ReadUInt32ArrayArray();
                    decompressedLengths = reader.ReadUInt32ArrayArray();
                }
                else
                {
                    offsets = reader.ReadUInt32Array().Select(x => new[] { x }).ToArray();
                    compressedLengths = reader.ReadUInt32Array().Select(x => new[] { x }).ToArray();
                    decompressedLengths = reader.ReadUInt32Array().Select(x => new[] { x }).ToArray();
                }
                compressedBlob = reader.ReadUInt8Array();
                reader.AlignStream();

                var m_DependenciesCount = reader.ReadInt32();
                for (int i = 0; i < m_DependenciesCount; i++)
                {
                    new PPtr<Shader>(reader);
                }

                if (version[0] >= 2018)
                {
                    var m_NonModifiableTexturesCount = reader.ReadInt32();
                    for (int i = 0; i < m_NonModifiableTexturesCount; i++)
                    {
                        var first = reader.ReadAlignedString();
                        new PPtr<Texture>(reader);
                    }
                }

                var m_ShaderIsBaked = reader.ReadBoolean();
                reader.AlignStream();
            }
            else
            {
                m_Script = reader.ReadUInt8Array();
                reader.AlignStream();
                var m_PathName = reader.ReadAlignedString();
                if (version[0] == 5 && version[1] >= 3) //5.3 - 5.4
                {
                    decompressedSize = reader.ReadUInt32();
                    m_SubProgramBlob = reader.ReadUInt8Array();
                }
            }
        }
    }
}

```

`AssetStudio/Classes/SkinnedMeshRenderer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public sealed class SkinnedMeshRenderer : Renderer
    {
        public PPtr<Mesh> m_Mesh;
        public PPtr<Transform>[] m_Bones;
        public float[] m_BlendShapeWeights;

        public SkinnedMeshRenderer(ObjectReader reader) : base(reader)
        {
            int m_Quality = reader.ReadInt32();
            var m_UpdateWhenOffscreen = reader.ReadBoolean();
            var m_SkinNormals = reader.ReadBoolean(); //3.1.0 and below
            reader.AlignStream();

            if (version[0] == 2 && version[1] < 6) //2.6 down
            {
                var m_DisableAnimationWhenOffscreen = new PPtr<Animation>(reader);
            }

            m_Mesh = new PPtr<Mesh>(reader);

            m_Bones = new PPtr<Transform>[reader.ReadInt32()];
            for (int b = 0; b < m_Bones.Length; b++)
            {
                m_Bones[b] = new PPtr<Transform>(reader);
            }

            if (version[0] > 4 || (version[0] == 4 && version[1] >= 3)) //4.3 and up
            {
                m_BlendShapeWeights = reader.ReadSingleArray();
            }
        }
    }
}

```

`AssetStudio/Classes/Sprite.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;

namespace AssetStudio
{
    public class SecondarySpriteTexture
    {
        public PPtr<Texture2D> texture;
        public string name;

        public SecondarySpriteTexture(ObjectReader reader)
        {
            texture = new PPtr<Texture2D>(reader);
            name = reader.ReadStringToNull();
        }
    }

    public enum SpritePackingRotation
    {
        None = 0,
        FlipHorizontal = 1,
        FlipVertical = 2,
        Rotate180 = 3,
        Rotate90 = 4
    };

    public enum SpritePackingMode
    {
        Tight = 0,
        Rectangle
    };

    public enum SpriteMeshType
    {
        FullRect,
        Tight
    };

    public class SpriteSettings
    {
        public uint settingsRaw;

        public uint packed;
        public SpritePackingMode packingMode;
        public SpritePackingRotation packingRotation;
        public SpriteMeshType meshType;

        public SpriteSettings(BinaryReader reader)
        {
            settingsRaw = reader.ReadUInt32();

            packed = settingsRaw & 1; //1
            packingMode = (SpritePackingMode)((settingsRaw >> 1) & 1); //1
            packingRotation = (SpritePackingRotation)((settingsRaw >> 2) & 0xf); //4
            meshType = (SpriteMeshType)((settingsRaw >> 6) & 1); //1
            //reserved
        }
    }

    public class SpriteVertex
    {
        public Vector3 pos;
        public Vector2 uv;

        public SpriteVertex(ObjectReader reader)
        {
            var version = reader.version;

            pos = reader.ReadVector3();
            if (version[0] < 4 || (version[0] == 4 && version[1] <= 3)) //4.3 and down
            {
                uv = reader.ReadVector2();
            }
        }
    }

    public class SpriteRenderData
    {
        public PPtr<Texture2D> texture;
        public PPtr<Texture2D> alphaTexture;
        public SecondarySpriteTexture[] secondaryTextures;
        public SubMesh[] m_SubMeshes;
        public byte[] m_IndexBuffer;
        public VertexData m_VertexData;
        public SpriteVertex[] vertices;
        public ushort[] indices;
        public Matrix4x4[] m_Bindpose;
        public BoneWeights4[] m_SourceSkin;
        public Rectf textureRect;
        public Vector2 textureRectOffset;
        public Vector2 atlasRectOffset;
        public SpriteSettings settingsRaw;
        public Vector4 uvTransform;
        public float downscaleMultiplier;

        public SpriteRenderData(ObjectReader reader)
        {
            var version = reader.version;

            texture = new PPtr<Texture2D>(reader);
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 2)) //5.2 and up
            {
                alphaTexture = new PPtr<Texture2D>(reader);
            }

            if (version[0] >= 2019) //2019 and up
            {
                var secondaryTexturesSize = reader.ReadInt32();
                secondaryTextures = new SecondarySpriteTexture[secondaryTexturesSize];
                for (int i = 0; i < secondaryTexturesSize; i++)
                {
                    secondaryTextures[i] = new SecondarySpriteTexture(reader);
                }
            }

            if (version[0] > 5 || (version[0] == 5 && version[1] >= 6)) //5.6 and up
            {
                var m_SubMeshesSize = reader.ReadInt32();
                m_SubMeshes = new SubMesh[m_SubMeshesSize];
                for (int i = 0; i < m_SubMeshesSize; i++)
                {
                    m_SubMeshes[i] = new SubMesh(reader);
                }

                m_IndexBuffer = reader.ReadUInt8Array();
                reader.AlignStream();

                m_VertexData = new VertexData(reader);
            }
            else
            {
                var verticesSize = reader.ReadInt32();
                vertices = new SpriteVertex[verticesSize];
                for (int i = 0; i < verticesSize; i++)
                {
                    vertices[i] = new SpriteVertex(reader);
                }

                indices = reader.ReadUInt16Array();
                reader.AlignStream();
            }

            if (version[0] >= 2018) //2018 and up
            {
                m_Bindpose = reader.ReadMatrixArray();

                if (version[0] == 2018 && version[1] < 2) //2018.2 down
                {
                    var m_SourceSkinSize = reader.ReadInt32();
                    for (int i = 0; i < m_SourceSkinSize; i++)
                    {
                        m_SourceSkin[i] = new BoneWeights4(reader);
                    }
                }
            }

            textureRect = new Rectf(reader);
            textureRectOffset = reader.ReadVector2();
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 6)) //5.6 and up
            {
                atlasRectOffset = reader.ReadVector2();
            }

            settingsRaw = new SpriteSettings(reader);
            if (version[0] > 4 || (version[0] == 4 && version[1] >= 5)) //4.5 and up
            {
                uvTransform = reader.ReadVector4();
            }

            if (version[0] >= 2017) //2017 and up
            {
                downscaleMultiplier = reader.ReadSingle();
            }
        }
    }

    public class Rectf
    {
        public float x;
        public float y;
        public float width;
        public float height;

        public Rectf(BinaryReader reader)
        {
            x = reader.ReadSingle();
            y = reader.ReadSingle();
            width = reader.ReadSingle();
            height = reader.ReadSingle();
        }
    }

    public sealed class Sprite : NamedObject
    {
        public Rectf m_Rect;
        public Vector2 m_Offset;
        public Vector4 m_Border;
        public float m_PixelsToUnits;
        public Vector2 m_Pivot = new Vector2(0.5f, 0.5f);
        public uint m_Extrude;
        public bool m_IsPolygon;
        public KeyValuePair<Guid, long> m_RenderDataKey;
        public string[] m_AtlasTags;
        public PPtr<SpriteAtlas> m_SpriteAtlas;
        public SpriteRenderData m_RD;
        public Vector2[][] m_PhysicsShape;

        public Sprite(ObjectReader reader) : base(reader)
        {
            m_Rect = new Rectf(reader);
            m_Offset = reader.ReadVector2();
            if (version[0] > 4 || (version[0] == 4 && version[1] >= 5)) //4.5 and up
            {
                m_Border = reader.ReadVector4();
            }

            m_PixelsToUnits = reader.ReadSingle();
            if (version[0] > 5
                || (version[0] == 5 && version[1] > 4)
                || (version[0] == 5 && version[1] == 4 && version[2] >= 2)
                || (version[0] == 5 && version[1] == 4 && version[2] == 1 && buildType.IsPatch && version[3] >= 3)) //5.4.1p3 and up
            {
                m_Pivot = reader.ReadVector2();
            }

            m_Extrude = reader.ReadUInt32();
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 3)) //5.3 and up
            {
                m_IsPolygon = reader.ReadBoolean();
                reader.AlignStream();
            }

            if (version[0] >= 2017) //2017 and up
            {
                var first = new Guid(reader.ReadBytes(16));
                var second = reader.ReadInt64();
                m_RenderDataKey = new KeyValuePair<Guid, long>(first, second);

                m_AtlasTags = reader.ReadStringArray();

                m_SpriteAtlas = new PPtr<SpriteAtlas>(reader);
            }

            m_RD = new SpriteRenderData(reader);

            if (version[0] >= 2017) //2017 and up
            {
                var m_PhysicsShapeSize = reader.ReadInt32();
                m_PhysicsShape = new Vector2[m_PhysicsShapeSize][];
                for (int i = 0; i < m_PhysicsShapeSize; i++)
                {
                    m_PhysicsShape[i] = reader.ReadVector2Array();
                }
            }

            //vector m_Bones 2018 and up
        }
    }
}

```

`AssetStudio/Classes/SpriteAtlas.cs`:

```cs
using System;
using System.Collections.Generic;

namespace AssetStudio
{
    public class SpriteAtlasData
    {
        public PPtr<Texture2D> texture;
        public PPtr<Texture2D> alphaTexture;
        public Rectf textureRect;
        public Vector2 textureRectOffset;
        public Vector2 atlasRectOffset;
        public Vector4 uvTransform;
        public float downscaleMultiplier;
        public SpriteSettings settingsRaw;
        public SecondarySpriteTexture[] secondaryTextures;

        public SpriteAtlasData(ObjectReader reader)
        {
            var version = reader.version;
            texture = new PPtr<Texture2D>(reader);
            alphaTexture = new PPtr<Texture2D>(reader);
            textureRect = new Rectf(reader);
            textureRectOffset = reader.ReadVector2();
            if (version[0] > 2017 || (version[0] == 2017 && version[1] >= 2)) //2017.2 and up
            {
                atlasRectOffset = reader.ReadVector2();
            }
            uvTransform = reader.ReadVector4();
            downscaleMultiplier = reader.ReadSingle();
            settingsRaw = new SpriteSettings(reader);
            if (version[0] > 2020 || (version[0] == 2020 && version[1] >= 2)) //2020.2 and up
            {
                var secondaryTexturesSize = reader.ReadInt32();
                secondaryTextures = new SecondarySpriteTexture[secondaryTexturesSize];
                for (int i = 0; i < secondaryTexturesSize; i++)
                {
                    secondaryTextures[i] = new SecondarySpriteTexture(reader);
                }
                reader.AlignStream();
            }
        }
    }

    public sealed class SpriteAtlas : NamedObject
    {
        public PPtr<Sprite>[] m_PackedSprites;
        public Dictionary<KeyValuePair<Guid, long>, SpriteAtlasData> m_RenderDataMap;
        public bool m_IsVariant;

        public SpriteAtlas(ObjectReader reader) : base(reader)
        {
            var m_PackedSpritesSize = reader.ReadInt32();
            m_PackedSprites = new PPtr<Sprite>[m_PackedSpritesSize];
            for (int i = 0; i < m_PackedSpritesSize; i++)
            {
                m_PackedSprites[i] = new PPtr<Sprite>(reader);
            }

            var m_PackedSpriteNamesToIndex = reader.ReadStringArray();

            var m_RenderDataMapSize = reader.ReadInt32();
            m_RenderDataMap = new Dictionary<KeyValuePair<Guid, long>, SpriteAtlasData>(m_RenderDataMapSize);
            for (int i = 0; i < m_RenderDataMapSize; i++)
            {
                var first = new Guid(reader.ReadBytes(16));
                var second = reader.ReadInt64();
                var value = new SpriteAtlasData(reader);
                m_RenderDataMap.Add(new KeyValuePair<Guid, long>(first, second), value);
            }
            var m_Tag = reader.ReadAlignedString();
            m_IsVariant = reader.ReadBoolean();
            reader.AlignStream();
        }
    }
}

```

`AssetStudio/Classes/TextAsset.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;

namespace AssetStudio
{
    public sealed class TextAsset : NamedObject
    {
        public byte[] m_Script;

        public TextAsset(ObjectReader reader) : base(reader)
        {
            m_Script = reader.ReadUInt8Array();
        }
    }
}

```

`AssetStudio/Classes/Texture.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public abstract class Texture : NamedObject
    {
        protected Texture(ObjectReader reader) : base(reader)
        {
            if (version[0] > 2017 || (version[0] == 2017 && version[1] >= 3)) //2017.3 and up
            {
                var m_ForcedFallbackFormat = reader.ReadInt32();
                var m_DownscaleFallback = reader.ReadBoolean();
                if (version[0] > 2020 || (version[0] == 2020 && version[1] >= 2)) //2020.2 and up
                {
                    var m_IsAlphaChannelOptional = reader.ReadBoolean();
                }
                reader.AlignStream();
            }
        }
    }
}

```

`AssetStudio/Classes/Texture2D.cs`:

```cs
using System;

namespace AssetStudio
{
    public class StreamingInfo
    {
        public long offset; //ulong
        public uint size;
        public string path;

        public StreamingInfo(ObjectReader reader)
        {
            var version = reader.version;

            if (version[0] >= 2020) //2020.1 and up
            {
                offset = reader.ReadInt64();
            }
            else
            {
                offset = reader.ReadUInt32();
            }
            size = reader.ReadUInt32();
            path = reader.ReadAlignedString();
        }
    }

    public class GLTextureSettings
    {
        public int m_FilterMode;
        public int m_Aniso;
        public float m_MipBias;
        public int m_WrapMode;

        public GLTextureSettings(ObjectReader reader)
        {
            var version = reader.version;

            m_FilterMode = reader.ReadInt32();
            m_Aniso = reader.ReadInt32();
            m_MipBias = reader.ReadSingle();
            if (version[0] >= 2017)//2017.x and up
            {
                m_WrapMode = reader.ReadInt32(); //m_WrapU
                int m_WrapV = reader.ReadInt32();
                int m_WrapW = reader.ReadInt32();
            }
            else
            {
                m_WrapMode = reader.ReadInt32();
            }
        }
    }

    public sealed class Texture2D : Texture
    {
        public int m_Width;
        public int m_Height;
        public TextureFormat m_TextureFormat;
        public bool m_MipMap;
        public int m_MipCount;
        public GLTextureSettings m_TextureSettings;
        public ResourceReader image_data;
        public StreamingInfo m_StreamData;

        public Texture2D(ObjectReader reader) : base(reader)
        {
            m_Width = reader.ReadInt32();
            m_Height = reader.ReadInt32();
            var m_CompleteImageSize = reader.ReadInt32();
            if (version[0] >= 2020) //2020.1 and up
            {
                var m_MipsStripped = reader.ReadInt32();
            }
            m_TextureFormat = (TextureFormat)reader.ReadInt32();
            if (version[0] < 5 || (version[0] == 5 && version[1] < 2)) //5.2 down
            {
                m_MipMap = reader.ReadBoolean();
            }
            else
            {
                m_MipCount = reader.ReadInt32();
            }
            if (version[0] > 2 || (version[0] == 2 && version[1] >= 6)) //2.6.0 and up
            {
                var m_IsReadable = reader.ReadBoolean();
            }
            if (version[0] >= 2020) //2020.1 and up
            {
                var m_IsPreProcessed = reader.ReadBoolean();
            }
            if (version[0] > 2019 || (version[0] == 2019 && version[1] >= 3)) //2019.3 and up
            {
                var m_IgnoreMasterTextureLimit = reader.ReadBoolean();
            }
            if (version[0] >= 3) //3.0.0 - 5.4
            {
                if (version[0] < 5 || (version[0] == 5 && version[1] <= 4))
                {
                    var m_ReadAllowed = reader.ReadBoolean();
                }
            }
            if (version[0] > 2018 || (version[0] == 2018 && version[1] >= 2)) //2018.2 and up
            {
                var m_StreamingMipmaps = reader.ReadBoolean();
            }
            reader.AlignStream();
            if (version[0] > 2018 || (version[0] == 2018 && version[1] >= 2)) //2018.2 and up
            {
                var m_StreamingMipmapsPriority = reader.ReadInt32();
            }
            var m_ImageCount = reader.ReadInt32();
            var m_TextureDimension = reader.ReadInt32();
            m_TextureSettings = new GLTextureSettings(reader);
            if (version[0] >= 3) //3.0 and up
            {
                var m_LightmapFormat = reader.ReadInt32();
            }
            if (version[0] > 3 || (version[0] == 3 && version[1] >= 5)) //3.5.0 and up
            {
                var m_ColorSpace = reader.ReadInt32();
            }
            if (version[0] > 2020 || (version[0] == 2020 && version[1] >= 2)) //2020.2 and up
            {
                var m_PlatformBlob = reader.ReadUInt8Array();
                reader.AlignStream();
            }
            var image_data_size = reader.ReadInt32();
            if (image_data_size == 0 && ((version[0] == 5 && version[1] >= 3) || version[0] > 5))//5.3.0 and up
            {
                m_StreamData = new StreamingInfo(reader);
            }

            ResourceReader resourceReader;
            if (!string.IsNullOrEmpty(m_StreamData?.path))
            {
                resourceReader = new ResourceReader(m_StreamData.path, assetsFile, m_StreamData.offset, m_StreamData.size);
            }
            else
            {
                resourceReader = new ResourceReader(reader, reader.BaseStream.Position, image_data_size);
            }
            image_data = resourceReader;
        }
    }

    public enum TextureFormat
    {
        Alpha8 = 1,
        ARGB4444,
        RGB24,
        RGBA32,
        ARGB32,
        ARGBFloat,
        RGB565,
        BGR24,
        R16,
        DXT1,
        DXT3,
        DXT5,
        RGBA4444,
        BGRA32,
        RHalf,
        RGHalf,
        RGBAHalf,
        RFloat,
        RGFloat,
        RGBAFloat,
        YUY2,
        RGB9e5Float,
        RGBFloat,
        BC6H,
        BC7,
        BC4,
        BC5,
        DXT1Crunched,
        DXT5Crunched,
        PVRTC_RGB2,
        PVRTC_RGBA2,
        PVRTC_RGB4,
        PVRTC_RGBA4,
        ETC_RGB4,
        ATC_RGB4,
        ATC_RGBA8,
        EAC_R = 41,
        EAC_R_SIGNED,
        EAC_RG,
        EAC_RG_SIGNED,
        ETC2_RGB,
        ETC2_RGBA1,
        ETC2_RGBA8,
        ASTC_RGB_4x4,
        ASTC_RGB_5x5,
        ASTC_RGB_6x6,
        ASTC_RGB_8x8,
        ASTC_RGB_10x10,
        ASTC_RGB_12x12,
        ASTC_RGBA_4x4,
        ASTC_RGBA_5x5,
        ASTC_RGBA_6x6,
        ASTC_RGBA_8x8,
        ASTC_RGBA_10x10,
        ASTC_RGBA_12x12,
        ETC_RGB4_3DS,
        ETC_RGBA8_3DS,
        RG16,
        R8,
        ETC_RGB4Crunched,
        ETC2_RGBA8Crunched,
        ASTC_HDR_4x4,
        ASTC_HDR_5x5,
        ASTC_HDR_6x6,
        ASTC_HDR_8x8,
        ASTC_HDR_10x10,
        ASTC_HDR_12x12,
        RG32,
        RGB48,
        RGBA64
    }
}
```

`AssetStudio/Classes/Transform.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class Transform : Component
    {
        public Quaternion m_LocalRotation;
        public Vector3 m_LocalPosition;
        public Vector3 m_LocalScale;
        public PPtr<Transform>[] m_Children;
        public PPtr<Transform> m_Father;

        public Transform(ObjectReader reader) : base(reader)
        {
            m_LocalRotation = reader.ReadQuaternion();
            m_LocalPosition = reader.ReadVector3();
            m_LocalScale = reader.ReadVector3();

            int m_ChildrenCount = reader.ReadInt32();
            m_Children = new PPtr<Transform>[m_ChildrenCount];
            for (int i = 0; i < m_ChildrenCount; i++)
            {
                m_Children[i] = new PPtr<Transform>(reader);
            }
            m_Father = new PPtr<Transform>(reader);
        }
    }
}

```

`AssetStudio/Classes/VideoClip.cs`:

```cs
using System.IO;

namespace AssetStudio
{
    public class StreamedResource
    {
        public string m_Source;
        public long m_Offset; //ulong
        public long m_Size; //ulong

        public StreamedResource(BinaryReader reader)
        {
            m_Source = reader.ReadAlignedString();
            m_Offset = reader.ReadInt64();
            m_Size = reader.ReadInt64();
        }
    }

    public sealed class VideoClip : NamedObject
    {
        public ResourceReader m_VideoData;
        public string m_OriginalPath;
        public StreamedResource m_ExternalResources;

        public VideoClip(ObjectReader reader) : base(reader)
        {
            m_OriginalPath = reader.ReadAlignedString();
            var m_ProxyWidth = reader.ReadUInt32();
            var m_ProxyHeight = reader.ReadUInt32();
            var Width = reader.ReadUInt32();
            var Height = reader.ReadUInt32();
            if (version[0] > 2017 || (version[0] == 2017 && version[1] >= 2)) //2017.2 and up
            {
                var m_PixelAspecRatioNum = reader.ReadUInt32();
                var m_PixelAspecRatioDen = reader.ReadUInt32();
            }
            var m_FrameRate = reader.ReadDouble();
            var m_FrameCount = reader.ReadUInt64();
            var m_Format = reader.ReadInt32();
            var m_AudioChannelCount = reader.ReadUInt16Array();
            reader.AlignStream();
            var m_AudioSampleRate = reader.ReadUInt32Array();
            var m_AudioLanguage = reader.ReadStringArray();
            if (version[0] >= 2020) //2020.1 and up
            {
                var m_VideoShadersSize = reader.ReadInt32();
                var m_VideoShaders = new PPtr<Shader>[m_VideoShadersSize];
                for (int i = 0; i < m_VideoShadersSize; i++)
                {
                    m_VideoShaders[i] = new PPtr<Shader>(reader);
                }
            }
            m_ExternalResources = new StreamedResource(reader);
            var m_HasSplitAlpha = reader.ReadBoolean();
            if (version[0] >= 2020) //2020.1 and up
            {
                var m_sRGB = reader.ReadBoolean();
            }

            ResourceReader resourceReader;
            if (!string.IsNullOrEmpty(m_ExternalResources.m_Source))
            {
                resourceReader = new ResourceReader(m_ExternalResources.m_Source, assetsFile, m_ExternalResources.m_Offset, m_ExternalResources.m_Size);
            }
            else
            {
                resourceReader = new ResourceReader(reader, reader.BaseStream.Position, m_ExternalResources.m_Size);
            }
            m_VideoData = resourceReader;
        }
    }
}

```

`AssetStudio/CommonString.cs`:

```cs
using System.Collections.Generic;

namespace AssetStudio
{
    public static class CommonString
    {
        public static readonly Dictionary<uint, string> StringBuffer = new Dictionary<uint, string>
        {
            {0, "AABB"},
            {5, "AnimationClip"},
            {19, "AnimationCurve"},
            {34, "AnimationState"},
            {49, "Array"},
            {55, "Base"},
            {60, "BitField"},
            {69, "bitset"},
            {76, "bool"},
            {81, "char"},
            {86, "ColorRGBA"},
            {96, "Component"},
            {106, "data"},
            {111, "deque"},
            {117, "double"},
            {124, "dynamic_array"},
            {138, "FastPropertyName"},
            {155, "first"},
            {161, "float"},
            {167, "Font"},
            {172, "GameObject"},
            {183, "Generic Mono"},
            {196, "GradientNEW"},
            {208, "GUID"},
            {213, "GUIStyle"},
            {222, "int"},
            {226, "list"},
            {231, "long long"},
            {241, "map"},
            {245, "Matrix4x4f"},
            {256, "MdFour"},
            {263, "MonoBehaviour"},
            {277, "MonoScript"},
            {288, "m_ByteSize"},
            {299, "m_Curve"},
            {307, "m_EditorClassIdentifier"},
            {331, "m_EditorHideFlags"},
            {349, "m_Enabled"},
            {359, "m_ExtensionPtr"},
            {374, "m_GameObject"},
            {387, "m_Index"},
            {395, "m_IsArray"},
            {405, "m_IsStatic"},
            {416, "m_MetaFlag"},
            {427, "m_Name"},
            {434, "m_ObjectHideFlags"},
            {452, "m_PrefabInternal"},
            {469, "m_PrefabParentObject"},
            {490, "m_Script"},
            {499, "m_StaticEditorFlags"},
            {519, "m_Type"},
            {526, "m_Version"},
            {536, "Object"},
            {543, "pair"},
            {548, "PPtr<Component>"},
            {564, "PPtr<GameObject>"},
            {581, "PPtr<Material>"},
            {596, "PPtr<MonoBehaviour>"},
            {616, "PPtr<MonoScript>"},
            {633, "PPtr<Object>"},
            {646, "PPtr<Prefab>"},
            {659, "PPtr<Sprite>"},
            {672, "PPtr<TextAsset>"},
            {688, "PPtr<Texture>"},
            {702, "PPtr<Texture2D>"},
            {718, "PPtr<Transform>"},
            {734, "Prefab"},
            {741, "Quaternionf"},
            {753, "Rectf"},
            {759, "RectInt"},
            {767, "RectOffset"},
            {778, "second"},
            {785, "set"},
            {789, "short"},
            {795, "size"},
            {800, "SInt16"},
            {807, "SInt32"},
            {814, "SInt64"},
            {821, "SInt8"},
            {827, "staticvector"},
            {840, "string"},
            {847, "TextAsset"},
            {857, "TextMesh"},
            {866, "Texture"},
            {874, "Texture2D"},
            {884, "Transform"},
            {894, "TypelessData"},
            {907, "UInt16"},
            {914, "UInt32"},
            {921, "UInt64"},
            {928, "UInt8"},
            {934, "unsigned int"},
            {947, "unsigned long long"},
            {966, "unsigned short"},
            {981, "vector"},
            {988, "Vector2f"},
            {997, "Vector3f"},
            {1006, "Vector4f"},
            {1015, "m_ScriptingClassIdentifier"},
            {1042, "Gradient"},
            {1051, "Type*"},
            {1057, "int2_storage"},
            {1070, "int3_storage"},
            {1083, "BoundsInt"},
            {1093, "m_CorrespondingSourceObject"},
            {1121, "m_PrefabInstance"},
            {1138, "m_PrefabAsset"},
            {1152, "FileSize"},
            {1161, "Hash128"}
        };
    }
}

```

`AssetStudio/EndianBinaryReader.cs`:

```cs
using System;
using System.Buffers.Binary;
using System.IO;

namespace AssetStudio
{
    public class EndianBinaryReader : BinaryReader
    {
        private readonly byte[] buffer;

        public EndianType Endian;

        public EndianBinaryReader(Stream stream, EndianType endian = EndianType.BigEndian) : base(stream)
        {
            Endian = endian;
            buffer = new byte[8];
        }

        public long Position
        {
            get => BaseStream.Position;
            set => BaseStream.Position = value;
        }

        public override short ReadInt16()
        {
            if (Endian == EndianType.BigEndian)
            {
                Read(buffer, 0, 2);
                return BinaryPrimitives.ReadInt16BigEndian(buffer);
            }
            return base.ReadInt16();
        }

        public override int ReadInt32()
        {
            if (Endian == EndianType.BigEndian)
            {
                Read(buffer, 0, 4);
                return BinaryPrimitives.ReadInt32BigEndian(buffer);
            }
            return base.ReadInt32();
        }

        public override long ReadInt64()
        {
            if (Endian == EndianType.BigEndian)
            {
                Read(buffer, 0, 8);
                return BinaryPrimitives.ReadInt64BigEndian(buffer);
            }
            return base.ReadInt64();
        }

        public override ushort ReadUInt16()
        {
            if (Endian == EndianType.BigEndian)
            {
                Read(buffer, 0, 2);
                return BinaryPrimitives.ReadUInt16BigEndian(buffer);
            }
            return base.ReadUInt16();
        }

        public override uint ReadUInt32()
        {
            if (Endian == EndianType.BigEndian)
            {
                Read(buffer, 0, 4);
                return BinaryPrimitives.ReadUInt32BigEndian(buffer);
            }
            return base.ReadUInt32();
        }

        public override ulong ReadUInt64()
        {
            if (Endian == EndianType.BigEndian)
            {
                Read(buffer, 0, 8);
                return BinaryPrimitives.ReadUInt64BigEndian(buffer);
            }
            return base.ReadUInt64();
        }

        public override float ReadSingle()
        {
            if (Endian == EndianType.BigEndian)
            {
                Read(buffer, 0, 4);
                Array.Reverse(buffer, 0, 4);
                return BitConverter.ToSingle(buffer, 0);
            }
            return base.ReadSingle();
        }

        public override double ReadDouble()
        {
            if (Endian == EndianType.BigEndian)
            {
                Read(buffer, 0, 8);
                Array.Reverse(buffer);
                return BitConverter.ToDouble(buffer, 0);
            }
            return base.ReadDouble();
        }
    }
}

```

`AssetStudio/EndianType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AssetStudio
{
    public enum EndianType
    {
        LittleEndian,
        BigEndian
    }
}

```

`AssetStudio/Extensions/BinaryReaderExtensions.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace AssetStudio
{
    public static class BinaryReaderExtensions
    {
        public static void AlignStream(this BinaryReader reader)
        {
            reader.AlignStream(4);
        }

        public static void AlignStream(this BinaryReader reader, int alignment)
        {
            var pos = reader.BaseStream.Position;
            var mod = pos % alignment;
            if (mod != 0)
            {
                reader.BaseStream.Position += alignment - mod;
            }
        }

        public static string ReadAlignedString(this BinaryReader reader)
        {
            var length = reader.ReadInt32();
            if (length > 0 && length <= reader.BaseStream.Length - reader.BaseStream.Position)
            {
                var stringData = reader.ReadBytes(length);
                var result = Encoding.UTF8.GetString(stringData);
                reader.AlignStream(4);
                return result;
            }
            return "";
        }

        public static string ReadStringToNull(this BinaryReader reader, int maxLength = 32767)
        {
            var bytes = new List<byte>();
            int count = 0;
            while (reader.BaseStream.Position != reader.BaseStream.Length && count < maxLength)
            {
                var b = reader.ReadByte();
                if (b == 0)
                {
                    break;
                }
                bytes.Add(b);
                count++;
            }
            return Encoding.UTF8.GetString(bytes.ToArray());
        }

        public static Quaternion ReadQuaternion(this BinaryReader reader)
        {
            return new Quaternion(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
        }

        public static Vector2 ReadVector2(this BinaryReader reader)
        {
            return new Vector2(reader.ReadSingle(), reader.ReadSingle());
        }

        public static Vector3 ReadVector3(this BinaryReader reader)
        {
            return new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
        }

        public static Vector4 ReadVector4(this BinaryReader reader)
        {
            return new Vector4(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
        }

        public static Color ReadColor4(this BinaryReader reader)
        {
            return new Color(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
        }

        public static Matrix4x4 ReadMatrix(this BinaryReader reader)
        {
            return new Matrix4x4(reader.ReadSingleArray(16));
        }

        private static T[] ReadArray<T>(Func<T> del, int length)
        {
            var array = new T[length];
            for (int i = 0; i < length; i++)
            {
                array[i] = del();
            }
            return array;
        }

        public static bool[] ReadBooleanArray(this BinaryReader reader)
        {
            return ReadArray(reader.ReadBoolean, reader.ReadInt32());
        }

        public static byte[] ReadUInt8Array(this BinaryReader reader)
        {
            return reader.ReadBytes(reader.ReadInt32());
        }

        public static ushort[] ReadUInt16Array(this BinaryReader reader)
        {
            return ReadArray(reader.ReadUInt16, reader.ReadInt32());
        }

        public static int[] ReadInt32Array(this BinaryReader reader)
        {
            return ReadArray(reader.ReadInt32, reader.ReadInt32());
        }

        public static int[] ReadInt32Array(this BinaryReader reader, int length)
        {
            return ReadArray(reader.ReadInt32, length);
        }

        public static uint[] ReadUInt32Array(this BinaryReader reader)
        {
            return ReadArray(reader.ReadUInt32, reader.ReadInt32());
        }

        public static uint[][] ReadUInt32ArrayArray(this BinaryReader reader)
        {
            return ReadArray(reader.ReadUInt32Array, reader.ReadInt32());
        }

        public static uint[] ReadUInt32Array(this BinaryReader reader, int length)
        {
            return ReadArray(reader.ReadUInt32, length);
        }

        public static float[] ReadSingleArray(this BinaryReader reader)
        {
            return ReadArray(reader.ReadSingle, reader.ReadInt32());
        }

        public static float[] ReadSingleArray(this BinaryReader reader, int length)
        {
            return ReadArray(reader.ReadSingle, length);
        }

        public static string[] ReadStringArray(this BinaryReader reader)
        {
            return ReadArray(reader.ReadAlignedString, reader.ReadInt32());
        }

        public static Vector2[] ReadVector2Array(this BinaryReader reader)
        {
            return ReadArray(reader.ReadVector2, reader.ReadInt32());
        }

        public static Vector4[] ReadVector4Array(this BinaryReader reader)
        {
            return ReadArray(reader.ReadVector4, reader.ReadInt32());
        }

        public static Matrix4x4[] ReadMatrixArray(this BinaryReader reader)
        {
            return ReadArray(reader.ReadMatrix, reader.ReadInt32());
        }
    }
}

```

`AssetStudio/Extensions/BinaryWriterExtensions.cs`:

```cs
using System;
using System.IO;
using System.Text;

namespace AssetStudio
{
    public static class BinaryWriterExtensions
    {
        public static void AlignStream(this BinaryWriter writer, int alignment)
        {
            var pos = writer.BaseStream.Position;
            var mod = pos % alignment;
            if (mod != 0)
            {
                writer.Write(new byte[alignment - mod]);
            }
        }

        public static void WriteAlignedString(this BinaryWriter writer, string str)
        {
            var bytes = Encoding.UTF8.GetBytes(str);
            writer.Write(bytes.Length);
            writer.Write(bytes);
            writer.AlignStream(4);
        }
    }
}

```

`AssetStudio/Extensions/StreamExtensions.cs`:

```cs
using System.IO;

namespace AssetStudio
{
    public static class StreamExtensions
    {
        private const int BufferSize = 81920;

        public static void CopyTo(this Stream source, Stream destination, long size)
        {
            var buffer = new byte[BufferSize];
            for (var left = size; left > 0; left -= BufferSize)
            {
                int toRead = BufferSize < left ? BufferSize : (int)left;
                int read = source.Read(buffer, 0, toRead);
                destination.Write(buffer, 0, read);
                if (read != toRead)
                {
                    return;
                }
            }
        }
    }
}

```

`AssetStudio/FileIdentifier.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class FileIdentifier
    {
        public Guid guid;
        public int type; //enum { kNonAssetType = 0, kDeprecatedCachedAssetType = 1, kSerializedAssetType = 2, kMetaAssetType = 3 };
        public string pathName;

        //custom
        public string fileName;
    }
}

```

`AssetStudio/FileReader.cs`:

```cs
using System.IO;
using System.Linq;

namespace AssetStudio
{
    public class FileReader : EndianBinaryReader
    {
        public string FullPath;
        public string FileName;
        public FileType FileType;

        private static readonly byte[] gzipMagic = { 0x1f, 0x8b };
        private static readonly byte[] brotliMagic = { 0x62, 0x72, 0x6F, 0x74, 0x6C, 0x69 };
        private static readonly byte[] zipMagic = { 0x50, 0x4B, 0x03, 0x04 };
        private static readonly byte[] zipSpannedMagic = { 0x50, 0x4B, 0x07, 0x08 };

        public FileReader(string path) : this(path, File.Open(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)) { }

        public FileReader(string path, Stream stream) : base(stream, EndianType.BigEndian)
        {
            FullPath = Path.GetFullPath(path);
            FileName = Path.GetFileName(path);
            FileType = CheckFileType();
        }

        private FileType CheckFileType()
        {
            var signature = this.ReadStringToNull(20);
            Position = 0;
            switch (signature)
            {
                case "UnityWeb":
                case "UnityRaw":
                case "UnityArchive":
                case "UnityFS":
                    return FileType.BundleFile;
                case "UnityWebData1.0":
                    return FileType.WebFile;
                default:
                    {
                        byte[] magic = ReadBytes(2);
                        Position = 0;
                        if (gzipMagic.SequenceEqual(magic))
                        {
                            return FileType.GZipFile;
                        }
                        Position = 0x20;
                        magic = ReadBytes(6);
                        Position = 0;
                        if (brotliMagic.SequenceEqual(magic))
                        {
                            return FileType.BrotliFile;
                        }
                        if (IsSerializedFile())
                        {
                            return FileType.AssetsFile;
                        }
                        magic = ReadBytes(4);
                        Position = 0;
                        if (zipMagic.SequenceEqual(magic) || zipSpannedMagic.SequenceEqual(magic))
                            return FileType.ZipFile;
                        return FileType.ResourceFile;
                    }
            }
        }

        private bool IsSerializedFile()
        {
            var fileSize = BaseStream.Length;
            if (fileSize < 20)
            {
                return false;
            }
            var m_MetadataSize = ReadUInt32();
            long m_FileSize = ReadUInt32();
            var m_Version = ReadUInt32();
            long m_DataOffset = ReadUInt32();
            var m_Endianess = ReadByte();
            var m_Reserved = ReadBytes(3);
            if (m_Version >= 22)
            {
                if (fileSize < 48)
                {
                    Position = 0;
                    return false;
                }
                m_MetadataSize = ReadUInt32();
                m_FileSize = ReadInt64();
                m_DataOffset = ReadInt64();
            }
            Position = 0;
            if (m_FileSize != fileSize)
            {
                return false;
            }
            if (m_DataOffset > fileSize)
            {
                return false;
            }
            return true;
        }
    }
}

```

`AssetStudio/FileType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AssetStudio
{
    public enum FileType
    {
        AssetsFile,
        BundleFile,
        WebFile,
        ResourceFile,
        GZipFile,
        BrotliFile,
        ZipFile
    }
}

```

`AssetStudio/IImported.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;

namespace AssetStudio
{
    public interface IImported
    {
        ImportedFrame RootFrame { get; }
        List<ImportedMesh> MeshList { get; }
        List<ImportedMaterial> MaterialList { get; }
        List<ImportedTexture> TextureList { get; }
        List<ImportedKeyframedAnimation> AnimationList { get; }
        List<ImportedMorph> MorphList { get; }
    }

    public class ImportedFrame
    {
        public string Name { get; set; }
        public Vector3 LocalRotation { get; set; }
        public Vector3 LocalPosition { get; set; }
        public Vector3 LocalScale { get; set; }
        public ImportedFrame Parent { get; set; }

        private List<ImportedFrame> children;

        public ImportedFrame this[int i] => children[i];

        public int Count => children.Count;

        public string Path
        {
            get
            {
                var frame = this;
                var path = frame.Name;
                while (frame.Parent != null)
                {
                    frame = frame.Parent;
                    path = frame.Name + "/" + path;
                }
                return path;
            }
        }

        public ImportedFrame(int childrenCount = 0)
        {
            children = new List<ImportedFrame>(childrenCount);
        }

        public void AddChild(ImportedFrame obj)
        {
            children.Add(obj);
            obj.Parent?.Remove(obj);
            obj.Parent = this;
        }

        public void Remove(ImportedFrame frame)
        {
            children.Remove(frame);
        }

        public ImportedFrame FindFrameByPath(string path)
        {
            var name = path.Substring(path.LastIndexOf('/') + 1);
            foreach (var frame in FindChilds(name))
            {
                if (frame.Path.EndsWith(path, StringComparison.Ordinal))
                {
                    return frame;
                }
            }
            return null;
        }

        public ImportedFrame FindRelativeFrameWithPath(string path)
        {
            var subs = path.Split(new[] { '/' }, 2);
            foreach (var child in children)
            {
                if (child.Name == subs[0])
                {
                    if (subs.Length == 1)
                    {
                        return child;
                    }
                    else
                    {
                        var result = child.FindRelativeFrameWithPath(subs[1]);
                        if (result != null)
                            return result;
                    }
                }
            }
            return null;
        }

        public ImportedFrame FindFrame(string name)
        {
            if (Name == name)
            {
                return this;
            }
            foreach (var child in children)
            {
                var frame = child.FindFrame(name);
                if (frame != null)
                {
                    return frame;
                }
            }
            return null;
        }

        public ImportedFrame FindChild(string name, bool recursive = true)
        {
            foreach (var child in children)
            {
                if (recursive)
                {
                    var frame = child.FindFrame(name);
                    if (frame != null)
                    {
                        return frame;
                    }
                }
                else
                {
                    if (child.Name == name)
                    {
                        return child;
                    }
                }
            }
            return null;
        }

        public IEnumerable<ImportedFrame> FindChilds(string name)
        {
            if (Name == name)
            {
                yield return this;
            }
            foreach (var child in children)
            {
                foreach (var item in child.FindChilds(name))
                {
                    yield return item;
                }
            }
        }
    }

    public class ImportedMesh
    {
        public string Path { get; set; }
        public List<ImportedVertex> VertexList { get; set; }
        public List<ImportedSubmesh> SubmeshList { get; set; }
        public List<ImportedBone> BoneList { get; set; }
        public bool hasNormal { get; set; }
        public bool[] hasUV { get; set; }
        public bool hasTangent { get; set; }
        public bool hasColor { get; set; }
    }

    public class ImportedSubmesh
    {
        public List<ImportedFace> FaceList { get; set; }
        public string Material { get; set; }
        public int BaseVertex { get; set; }
    }

    public class ImportedVertex
    {
        public Vector3 Vertex { get; set; }
        public Vector3 Normal { get; set; }
        public float[][] UV { get; set; }
        public Vector4 Tangent { get; set; }
        public Color Color { get; set; }
        public float[] Weights { get; set; }
        public int[] BoneIndices { get; set; }
    }

    public class ImportedFace
    {
        public int[] VertexIndices { get; set; }
    }

    public class ImportedBone
    {
        public string Path { get; set; }
        public Matrix4x4 Matrix { get; set; }
    }

    public class ImportedMaterial
    {
        public string Name { get; set; }
        public Color Diffuse { get; set; }
        public Color Ambient { get; set; }
        public Color Specular { get; set; }
        public Color Emissive { get; set; }
        public Color Reflection { get; set; }
        public float Shininess { get; set; }
        public float Transparency { get; set; }
        public List<ImportedMaterialTexture> Textures { get; set; }
    }

    public class ImportedMaterialTexture
    {
        public string Name { get; set; }
        public int Dest { get; set; }
        public Vector2 Offset { get; set; }
        public Vector2 Scale { get; set; }
    }

    public class ImportedTexture
    {
        public string Name { get; set; }
        public byte[] Data { get; set; }

        public ImportedTexture(MemoryStream stream, string name)
        {
            Name = name;
            Data = stream.ToArray();
        }
    }

    public class ImportedKeyframedAnimation
    {
        public string Name { get; set; }
        public float SampleRate { get; set; }
        public List<ImportedAnimationKeyframedTrack> TrackList { get; set; }

        public ImportedAnimationKeyframedTrack FindTrack(string path)
        {
            var track = TrackList.Find(x => x.Path == path);
            if (track == null)
            {
                track = new ImportedAnimationKeyframedTrack { Path = path };
                TrackList.Add(track);
            }

            return track;
        }
    }

    public class ImportedAnimationKeyframedTrack
    {
        public string Path { get; set; }
        public List<ImportedKeyframe<Vector3>> Scalings = new List<ImportedKeyframe<Vector3>>();
        public List<ImportedKeyframe<Vector3>> Rotations = new List<ImportedKeyframe<Vector3>>();
        public List<ImportedKeyframe<Vector3>> Translations = new List<ImportedKeyframe<Vector3>>();
        public ImportedBlendShape BlendShape;
    }

    public class ImportedKeyframe<T>
    {
        public float time { get; set; }
        public T value { get; set; }

        public ImportedKeyframe(float time, T value)
        {
            this.time = time;
            this.value = value;
        }
    }

    public class ImportedBlendShape
    {
        public string ChannelName;
        public List<ImportedKeyframe<float>> Keyframes = new List<ImportedKeyframe<float>>();
    }

    public class ImportedMorph
    {
        public string Path { get; set; }
        public List<ImportedMorphChannel> Channels { get; set; }
    }

    public class ImportedMorphChannel
    {
        public string Name { get; set; }
        public List<ImportedMorphKeyframe> KeyframeList { get; set; }
    }

    public class ImportedMorphKeyframe
    {
        public bool hasNormals { get; set; }
        public bool hasTangents { get; set; }
        public float Weight { get; set; }
        public List<ImportedMorphVertex> VertexList { get; set; }
    }

    public class ImportedMorphVertex
    {
        public uint Index { get; set; }
        public ImportedVertex Vertex { get; set; }
    }

    public static class ImportedHelpers
    {
        public static ImportedMesh FindMesh(string path, List<ImportedMesh> importedMeshList)
        {
            foreach (var mesh in importedMeshList)
            {
                if (mesh.Path == path)
                {
                    return mesh;
                }
            }

            return null;
        }

        public static ImportedMaterial FindMaterial(string name, List<ImportedMaterial> importedMats)
        {
            foreach (var mat in importedMats)
            {
                if (mat.Name == name)
                {
                    return mat;
                }
            }

            return null;
        }

        public static ImportedTexture FindTexture(string name, List<ImportedTexture> importedTextureList)
        {
            if (string.IsNullOrEmpty(name))
            {
                return null;
            }

            foreach (var tex in importedTextureList)
            {
                if (tex.Name == name)
                {
                    return tex;
                }
            }

            return null;
        }
    }
}

```

`AssetStudio/ILogger.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public enum LoggerEvent
    {
        Verbose,
        Debug,
        Info,
        Warning,
        Error,
    }

    public interface ILogger
    {
        void Log(LoggerEvent loggerEvent, string message);
    }

    public sealed class DummyLogger : ILogger
    {
        public void Log(LoggerEvent loggerEvent, string message) { }
    }
}

```

`AssetStudio/ImportHelper.cs`:

```cs
using Org.Brotli.Dec;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;

namespace AssetStudio
{
    public static class ImportHelper
    {
        public static void MergeSplitAssets(string path, bool allDirectories = false)
        {
            var splitFiles = Directory.GetFiles(path, "*.split0", allDirectories ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly);
            foreach (var splitFile in splitFiles)
            {
                var destFile = Path.GetFileNameWithoutExtension(splitFile);
                var destPath = Path.GetDirectoryName(splitFile);
                var destFull = Path.Combine(destPath, destFile);
                if (!File.Exists(destFull))
                {
                    var splitParts = Directory.GetFiles(destPath, destFile + ".split*");
                    using (var destStream = File.Create(destFull))
                    {
                        for (int i = 0; i < splitParts.Length; i++)
                        {
                            var splitPart = destFull + ".split" + i;
                            using (var sourceStream = File.OpenRead(splitPart))
                            {
                                sourceStream.CopyTo(destStream);
                            }
                        }
                    }
                }
            }
        }

        public static string[] ProcessingSplitFiles(List<string> selectFile)
        {
            var splitFiles = selectFile.Where(x => x.Contains(".split"))
                .Select(x => Path.Combine(Path.GetDirectoryName(x), Path.GetFileNameWithoutExtension(x)))
                .Distinct()
                .ToList();
            selectFile.RemoveAll(x => x.Contains(".split"));
            foreach (var file in splitFiles)
            {
                if (File.Exists(file))
                {
                    selectFile.Add(file);
                }
            }
            return selectFile.Distinct().ToArray();
        }

        public static FileReader DecompressGZip(FileReader reader)
        {
            using (reader)
            {
                var stream = new MemoryStream();
                using (var gs = new GZipStream(reader.BaseStream, CompressionMode.Decompress))
                {
                    gs.CopyTo(stream);
                }
                stream.Position = 0;
                return new FileReader(reader.FullPath, stream);
            }
        }

        public static FileReader DecompressBrotli(FileReader reader)
        {
            using (reader)
            {
                var stream = new MemoryStream();
                using (var brotliStream = new BrotliInputStream(reader.BaseStream))
                {
                    brotliStream.CopyTo(stream);
                }
                stream.Position = 0;
                return new FileReader(reader.FullPath, stream);
            }
        }
    }
}

```

`AssetStudio/LocalSerializedObjectIdentifier.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class LocalSerializedObjectIdentifier
    {
        public int localSerializedFileIndex;
        public long localIdentifierInFile;
    }
}

```

`AssetStudio/Logger.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public static class Logger
    {
        public static ILogger Default = new DummyLogger();

        public static void Verbose(string message) => Default.Log(LoggerEvent.Verbose, message);
        public static void Debug(string message) => Default.Log(LoggerEvent.Debug, message);
        public static void Info(string message) => Default.Log(LoggerEvent.Info, message);
        public static void Warning(string message) => Default.Log(LoggerEvent.Warning, message);
        public static void Error(string message) => Default.Log(LoggerEvent.Error, message);

        public static void Error(string message, Exception e)
        {
            var sb = new StringBuilder();
            sb.AppendLine(message);
            sb.AppendLine(e.ToString());
            Default.Log(LoggerEvent.Error, sb.ToString());
        }
    }
}

```

`AssetStudio/Math/Color.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace AssetStudio
{
    [StructLayout(LayoutKind.Sequential, Pack = 4)]
    public struct Color : IEquatable<Color>
    {
        public float R;
        public float G;
        public float B;
        public float A;

        public Color(float r, float g, float b, float a)
        {
            R = r;
            G = g;
            B = b;
            A = a;
        }

        public override int GetHashCode()
        {
            return ((Vector4)this).GetHashCode();
        }

        public override bool Equals(object other)
        {
            if (!(other is Color))
                return false;
            return Equals((Color)other);
        }

        public bool Equals(Color other)
        {
            return R.Equals(other.R) && G.Equals(other.G) && B.Equals(other.B) && A.Equals(other.A);
        }

        public static Color operator +(Color a, Color b)
        {
            return new Color(a.R + b.R, a.G + b.G, a.B + b.B, a.A + b.A);
        }

        public static Color operator -(Color a, Color b)
        {
            return new Color(a.R - b.R, a.G - b.G, a.B - b.B, a.A - b.A);
        }

        public static Color operator *(Color a, Color b)
        {
            return new Color(a.R * b.R, a.G * b.G, a.B * b.B, a.A * b.A);
        }

        public static Color operator *(Color a, float b)
        {
            return new Color(a.R * b, a.G * b, a.B * b, a.A * b);
        }

        public static Color operator *(float b, Color a)
        {
            return new Color(a.R * b, a.G * b, a.B * b, a.A * b);
        }

        public static Color operator /(Color a, float b)
        {
            return new Color(a.R / b, a.G / b, a.B / b, a.A / b);
        }

        public static bool operator ==(Color lhs, Color rhs)
        {
            return (Vector4)lhs == (Vector4)rhs;
        }

        public static bool operator !=(Color lhs, Color rhs)
        {
            return !(lhs == rhs);
        }

        public static implicit operator Vector4(Color c)
        {
            return new Vector4(c.R, c.G, c.B, c.A);
        }
    }
}

```

`AssetStudio/Math/Half.cs`:

```cs
using System;
using System.Diagnostics;
using System.Globalization;

namespace AssetStudio
{
    /// <summary>
    /// Represents a half-precision floating point number. 
    /// </summary>
    /// <remarks>
    /// Note:
    ///     Half is not fast enought and precision is also very bad, 
    ///     so is should not be used for matemathical computation (use Single instead).
    ///     The main advantage of Half type is lower memory cost: two bytes per number. 
    ///     Half is typically used in graphical applications.
    ///     
    /// Note: 
    ///     All functions, where is used conversion half->float/float->half, 
    ///     are approx. ten times slower than float->double/double->float, i.e. ~3ns on 2GHz CPU.
    ///
    /// References:
    ///     - Fast Half Float Conversions, Jeroen van der Zijp, link: http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
    ///     - IEEE 754 revision, link: http://grouper.ieee.org/groups/754/
    /// </remarks>
    [Serializable]
    public struct Half : IComparable, IFormattable, IConvertible, IComparable<Half>, IEquatable<Half>
    {
        /// <summary>
        /// Internal representation of the half-precision floating-point number.
        /// </summary>
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        internal ushort value;

        #region Constants
        /// <summary>
        /// Represents the smallest positive System.Half value greater than zero. This field is constant.
        /// </summary>
        public static readonly Half Epsilon = Half.ToHalf(0x0001);
        /// <summary>
        /// Represents the largest possible value of System.Half. This field is constant.
        /// </summary>
        public static readonly Half MaxValue = Half.ToHalf(0x7bff);
        /// <summary>
        /// Represents the smallest possible value of System.Half. This field is constant.
        /// </summary>
        public static readonly Half MinValue = Half.ToHalf(0xfbff);
        /// <summary>
        /// Represents not a number (NaN). This field is constant.
        /// </summary>
        public static readonly Half NaN = Half.ToHalf(0xfe00);
        /// <summary>
        /// Represents negative infinity. This field is constant.
        /// </summary>
        public static readonly Half NegativeInfinity = Half.ToHalf(0xfc00);
        /// <summary>
        /// Represents positive infinity. This field is constant.
        /// </summary>
        public static readonly Half PositiveInfinity = Half.ToHalf(0x7c00);
        #endregion

        #region Constructors
        /// <summary>
        /// Initializes a new instance of System.Half to the value of the specified single-precision floating-point number.
        /// </summary>
        /// <param name="value">The value to represent as a System.Half.</param>
        public Half(float value) { this = HalfHelper.SingleToHalf(value); }
        /// <summary>
        /// Initializes a new instance of System.Half to the value of the specified 32-bit signed integer.
        /// </summary>
        /// <param name="value">The value to represent as a System.Half.</param>
        public Half(int value) : this((float)value) { }
        /// <summary>
        /// Initializes a new instance of System.Half to the value of the specified 64-bit signed integer.
        /// </summary>
        /// <param name="value">The value to represent as a System.Half.</param>
        public Half(long value) : this((float)value) { }
        /// <summary>
        /// Initializes a new instance of System.Half to the value of the specified double-precision floating-point number.
        /// </summary>
        /// <param name="value">The value to represent as a System.Half.</param>
        public Half(double value) : this((float)value) { }
        /// <summary>
        /// Initializes a new instance of System.Half to the value of the specified decimal number.
        /// </summary>
        /// <param name="value">The value to represent as a System.Half.</param>
        public Half(decimal value) : this((float)value) { }
        /// <summary>
        /// Initializes a new instance of System.Half to the value of the specified 32-bit unsigned integer.
        /// </summary>
        /// <param name="value">The value to represent as a System.Half.</param>
        public Half(uint value) : this((float)value) { }
        /// <summary>
        /// Initializes a new instance of System.Half to the value of the specified 64-bit unsigned integer.
        /// </summary>
        /// <param name="value">The value to represent as a System.Half.</param>
        public Half(ulong value) : this((float)value) { }
        #endregion

        #region Numeric operators

        /// <summary>
        /// Returns the result of multiplying the specified System.Half value by negative one.
        /// </summary>
        /// <param name="half">A System.Half.</param>
        /// <returns>A System.Half with the value of half, but the opposite sign. -or- Zero, if half is zero.</returns>
        public static Half Negate(Half half) { return -half; }
        /// <summary>
        /// Adds two specified System.Half values.
        /// </summary>
        /// <param name="half1">A System.Half.</param>
        /// <param name="half2">A System.Half.</param>
        /// <returns>A System.Half value that is the sum of half1 and half2.</returns>
        public static Half Add(Half half1, Half half2) { return half1 + half2; }
        /// <summary>
        /// Subtracts one specified System.Half value from another.
        /// </summary>
        /// <param name="half1">A System.Half (the minuend).</param>
        /// <param name="half2">A System.Half (the subtrahend).</param>
        /// <returns>The System.Half result of subtracting half2 from half1.</returns>
        public static Half Subtract(Half half1, Half half2) { return half1 - half2; }
        /// <summary>
        /// Multiplies two specified System.Half values.
        /// </summary>
        /// <param name="half1">A System.Half (the multiplicand).</param>
        /// <param name="half2">A System.Half (the multiplier).</param>
        /// <returns>A System.Half that is the result of multiplying half1 and half2.</returns>
        public static Half Multiply(Half half1, Half half2) { return half1 * half2; }
        /// <summary>
        /// Divides two specified System.Half values.
        /// </summary>
        /// <param name="half1">A System.Half (the dividend).</param>
        /// <param name="half2">A System.Half (the divisor).</param>
        /// <returns>The System.Half that is the result of dividing half1 by half2.</returns>
        /// <exception cref="System.DivideByZeroException">half2 is zero.</exception>
        public static Half Divide(Half half1, Half half2) { return half1 / half2; }

        /// <summary>
        /// Returns the value of the System.Half operand (the sign of the operand is unchanged).
        /// </summary>
        /// <param name="half">The System.Half operand.</param>
        /// <returns>The value of the operand, half.</returns>
        public static Half operator +(Half half) { return half; }
        /// <summary>
        /// Negates the value of the specified System.Half operand.
        /// </summary>
        /// <param name="half">The System.Half operand.</param>
        /// <returns>The result of half multiplied by negative one (-1).</returns>
        public static Half operator -(Half half) { return HalfHelper.Negate(half); }
        /// <summary>
        /// Increments the System.Half operand by 1.
        /// </summary>
        /// <param name="half">The System.Half operand.</param>
        /// <returns>The value of half incremented by 1.</returns>
        public static Half operator ++(Half half) { return (Half)(half + 1f); }
        /// <summary>
        /// Decrements the System.Half operand by one.
        /// </summary>
        /// <param name="half">The System.Half operand.</param>
        /// <returns>The value of half decremented by 1.</returns>
        public static Half operator --(Half half) { return (Half)(half - 1f); }
        /// <summary>
        /// Adds two specified System.Half values.
        /// </summary>
        /// <param name="half1">A System.Half.</param>
        /// <param name="half2">A System.Half.</param>
        /// <returns>The System.Half result of adding half1 and half2.</returns>
        public static Half operator +(Half half1, Half half2) { return (Half)((float)half1 + (float)half2); }
        /// <summary>
        /// Subtracts two specified System.Half values.
        /// </summary>
        /// <param name="half1">A System.Half.</param>
        /// <param name="half2">A System.Half.</param>
        /// <returns>The System.Half result of subtracting half1 and half2.</returns>        
        public static Half operator -(Half half1, Half half2) { return (Half)((float)half1 - (float)half2); }
        /// <summary>
        /// Multiplies two specified System.Half values.
        /// </summary>
        /// <param name="half1">A System.Half.</param>
        /// <param name="half2">A System.Half.</param>
        /// <returns>The System.Half result of multiplying half1 by half2.</returns>
        public static Half operator *(Half half1, Half half2) { return (Half)((float)half1 * (float)half2); }
        /// <summary>
        /// Divides two specified System.Half values.
        /// </summary>
        /// <param name="half1">A System.Half (the dividend).</param>
        /// <param name="half2">A System.Half (the divisor).</param>
        /// <returns>The System.Half result of half1 by half2.</returns>
        public static Half operator /(Half half1, Half half2) { return (Half)((float)half1 / (float)half2); }
        /// <summary>
        /// Returns a value indicating whether two instances of System.Half are equal.
        /// </summary>
        /// <param name="half1">A System.Half.</param>
        /// <param name="half2">A System.Half.</param>
        /// <returns>true if half1 and half2 are equal; otherwise, false.</returns>
        public static bool operator ==(Half half1, Half half2) { return (!IsNaN(half1) && (half1.value == half2.value)); }
        /// <summary>
        /// Returns a value indicating whether two instances of System.Half are not equal.
        /// </summary>
        /// <param name="half1">A System.Half.</param>
        /// <param name="half2">A System.Half.</param>
        /// <returns>true if half1 and half2 are not equal; otherwise, false.</returns>
        public static bool operator !=(Half half1, Half half2) { return !(half1.value == half2.value); }
        /// <summary>
        /// Returns a value indicating whether a specified System.Half is less than another specified System.Half.
        /// </summary>
        /// <param name="half1">A System.Half.</param>
        /// <param name="half2">A System.Half.</param>
        /// <returns>true if half1 is less than half1; otherwise, false.</returns>
        public static bool operator <(Half half1, Half half2) { return (float)half1 < (float)half2; }
        /// <summary>
        /// Returns a value indicating whether a specified System.Half is greater than another specified System.Half.
        /// </summary>
        /// <param name="half1">A System.Half.</param>
        /// <param name="half2">A System.Half.</param>
        /// <returns>true if half1 is greater than half2; otherwise, false.</returns>
        public static bool operator >(Half half1, Half half2) { return (float)half1 > (float)half2; }
        /// <summary>
        /// Returns a value indicating whether a specified System.Half is less than or equal to another specified System.Half.
        /// </summary>
        /// <param name="half1">A System.Half.</param>
        /// <param name="half2">A System.Half.</param>
        /// <returns>true if half1 is less than or equal to half2; otherwise, false.</returns>
        public static bool operator <=(Half half1, Half half2) { return (half1 == half2) || (half1 < half2); }
        /// <summary>
        /// Returns a value indicating whether a specified System.Half is greater than or equal to another specified System.Half.
        /// </summary>
        /// <param name="half1">A System.Half.</param>
        /// <param name="half2">A System.Half.</param>
        /// <returns>true if half1 is greater than or equal to half2; otherwise, false.</returns>
        public static bool operator >=(Half half1, Half half2) { return (half1 == half2) || (half1 > half2); }
        #endregion

        #region Type casting operators
        /// <summary>
        /// Converts an 8-bit unsigned integer to a System.Half.
        /// </summary>
        /// <param name="value">An 8-bit unsigned integer.</param>
        /// <returns>A System.Half that represents the converted 8-bit unsigned integer.</returns>
        public static implicit operator Half(byte value) { return new Half((float)value); }
        /// <summary>
        /// Converts a 16-bit signed integer to a System.Half.
        /// </summary>
        /// <param name="value">A 16-bit signed integer.</param>
        /// <returns>A System.Half that represents the converted 16-bit signed integer.</returns>
        public static implicit operator Half(short value) { return new Half((float)value); }
        /// <summary>
        /// Converts a Unicode character to a System.Half.
        /// </summary>
        /// <param name="value">A Unicode character.</param>
        /// <returns>A System.Half that represents the converted Unicode character.</returns>
        public static implicit operator Half(char value) { return new Half((float)value); }
        /// <summary>
        /// Converts a 32-bit signed integer to a System.Half.
        /// </summary>
        /// <param name="value">A 32-bit signed integer.</param>
        /// <returns>A System.Half that represents the converted 32-bit signed integer.</returns>
        public static implicit operator Half(int value) { return new Half((float)value); }
        /// <summary>
        /// Converts a 64-bit signed integer to a System.Half.
        /// </summary>
        /// <param name="value">A 64-bit signed integer.</param>
        /// <returns>A System.Half that represents the converted 64-bit signed integer.</returns>
        public static implicit operator Half(long value) { return new Half((float)value); }
        /// <summary>
        /// Converts a single-precision floating-point number to a System.Half.
        /// </summary>
        /// <param name="value">A single-precision floating-point number.</param>
        /// <returns>A System.Half that represents the converted single-precision floating point number.</returns>
        public static explicit operator Half(float value) { return new Half((float)value); }
        /// <summary>
        /// Converts a double-precision floating-point number to a System.Half.
        /// </summary>
        /// <param name="value">A double-precision floating-point number.</param>
        /// <returns>A System.Half that represents the converted double-precision floating point number.</returns>
        public static explicit operator Half(double value) { return new Half((float)value); }
        /// <summary>
        /// Converts a decimal number to a System.Half.
        /// </summary>
        /// <param name="value">decimal number</param>
        /// <returns>A System.Half that represents the converted decimal number.</returns>
        public static explicit operator Half(decimal value) { return new Half((float)value); }
        /// <summary>
        /// Converts a System.Half to an 8-bit unsigned integer.
        /// </summary>
        /// <param name="value">A System.Half to convert.</param>
        /// <returns>An 8-bit unsigned integer that represents the converted System.Half.</returns>
        public static explicit operator byte(Half value) { return (byte)(float)value; }
        /// <summary>
        /// Converts a System.Half to a Unicode character.
        /// </summary>
        /// <param name="value">A System.Half to convert.</param>
        /// <returns>A Unicode character that represents the converted System.Half.</returns>
        public static explicit operator char(Half value) { return (char)(float)value; }
        /// <summary>
        /// Converts a System.Half to a 16-bit signed integer.
        /// </summary>
        /// <param name="value">A System.Half to convert.</param>
        /// <returns>A 16-bit signed integer that represents the converted System.Half.</returns>
        public static explicit operator short(Half value) { return (short)(float)value; }
        /// <summary>
        /// Converts a System.Half to a 32-bit signed integer.
        /// </summary>
        /// <param name="value">A System.Half to convert.</param>
        /// <returns>A 32-bit signed integer that represents the converted System.Half.</returns>
        public static explicit operator int(Half value) { return (int)(float)value; }
        /// <summary>
        /// Converts a System.Half to a 64-bit signed integer.
        /// </summary>
        /// <param name="value">A System.Half to convert.</param>
        /// <returns>A 64-bit signed integer that represents the converted System.Half.</returns>
        public static explicit operator long(Half value) { return (long)(float)value; }
        /// <summary>
        /// Converts a System.Half to a single-precision floating-point number.
        /// </summary>
        /// <param name="value">A System.Half to convert.</param>
        /// <returns>A single-precision floating-point number that represents the converted System.Half.</returns>
        public static implicit operator float(Half value) { return (float)HalfHelper.HalfToSingle(value); }
        /// <summary>
        /// Converts a System.Half to a double-precision floating-point number.
        /// </summary>
        /// <param name="value">A System.Half to convert.</param>
        /// <returns>A double-precision floating-point number that represents the converted System.Half.</returns>
        public static implicit operator double(Half value) { return (double)(float)value; }
        /// <summary>
        /// Converts a System.Half to a decimal number.
        /// </summary>
        /// <param name="value">A System.Half to convert.</param>
        /// <returns>A decimal number that represents the converted System.Half.</returns>
        public static explicit operator decimal(Half value) { return (decimal)(float)value; }
        /// <summary>
        /// Converts an 8-bit signed integer to a System.Half.
        /// </summary>
        /// <param name="value">An 8-bit signed integer.</param>
        /// <returns>A System.Half that represents the converted 8-bit signed integer.</returns>
        public static implicit operator Half(sbyte value) { return new Half((float)value); }
        /// <summary>
        /// Converts a 16-bit unsigned integer to a System.Half.
        /// </summary>
        /// <param name="value">A 16-bit unsigned integer.</param>
        /// <returns>A System.Half that represents the converted 16-bit unsigned integer.</returns>
        public static implicit operator Half(ushort value) { return new Half((float)value); }
        /// <summary>
        /// Converts a 32-bit unsigned integer to a System.Half.
        /// </summary>
        /// <param name="value">A 32-bit unsigned integer.</param>
        /// <returns>A System.Half that represents the converted 32-bit unsigned integer.</returns>
        public static implicit operator Half(uint value) { return new Half((float)value); }
        /// <summary>
        /// Converts a 64-bit unsigned integer to a System.Half.
        /// </summary>
        /// <param name="value">A 64-bit unsigned integer.</param>
        /// <returns>A System.Half that represents the converted 64-bit unsigned integer.</returns>
        public static implicit operator Half(ulong value) { return new Half((float)value); }
        /// <summary>
        /// Converts a System.Half to an 8-bit signed integer.
        /// </summary>
        /// <param name="value">A System.Half to convert.</param>
        /// <returns>An 8-bit signed integer that represents the converted System.Half.</returns>
        public static explicit operator sbyte(Half value) { return (sbyte)(float)value; }
        /// <summary>
        /// Converts a System.Half to a 16-bit unsigned integer.
        /// </summary>
        /// <param name="value">A System.Half to convert.</param>
        /// <returns>A 16-bit unsigned integer that represents the converted System.Half.</returns>
        public static explicit operator ushort(Half value) { return (ushort)(float)value; }
        /// <summary>
        /// Converts a System.Half to a 32-bit unsigned integer.
        /// </summary>
        /// <param name="value">A System.Half to convert.</param>
        /// <returns>A 32-bit unsigned integer that represents the converted System.Half.</returns>
        public static explicit operator uint(Half value) { return (uint)(float)value; }
        /// <summary>
        /// Converts a System.Half to a 64-bit unsigned integer.
        /// </summary>
        /// <param name="value">A System.Half to convert.</param>
        /// <returns>A 64-bit unsigned integer that represents the converted System.Half.</returns>
        public static explicit operator ulong(Half value) { return (ulong)(float)value; }
        #endregion

        /// <summary>
        /// Compares this instance to a specified System.Half object.
        /// </summary>
        /// <param name="other">A System.Half object.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and value.
        /// Return Value Meaning Less than zero This instance is less than value. Zero
        /// This instance is equal to value. Greater than zero This instance is greater than value.
        /// </returns>
        public int CompareTo(Half other)
        {
            int result = 0;
            if (this < other)
            {
                result = -1;
            }
            else if (this > other)
            {
                result = 1;
            }
            else if (this != other)
            {
                if (!IsNaN(this))
                {
                    result = 1;
                }
                else if (!IsNaN(other))
                {
                    result = -1;
                }
            }

            return result;
        }
        /// <summary>
        /// Compares this instance to a specified System.Object.
        /// </summary>
        /// <param name="obj">An System.Object or null.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and value.
        /// Return Value Meaning Less than zero This instance is less than value. Zero
        /// This instance is equal to value. Greater than zero This instance is greater
        /// than value. -or- value is null.
        /// </returns>
        /// <exception cref="System.ArgumentException">value is not a System.Half</exception>
        public int CompareTo(object obj)
        {
            int result = 0;
            if (obj == null)
            {
                result = 1;
            }
            else
            {
                if (obj is Half)
                {
                    result = CompareTo((Half)obj);
                }
                else
                {
                    throw new ArgumentException("Object must be of type Half.");
                }
            }

            return result;
        }
        /// <summary>
        /// Returns a value indicating whether this instance and a specified System.Half object represent the same value.
        /// </summary>
        /// <param name="other">A System.Half object to compare to this instance.</param>
        /// <returns>true if value is equal to this instance; otherwise, false.</returns>
        public bool Equals(Half other)
        {
            return ((other == this) || (IsNaN(other) && IsNaN(this)));
        }
        /// <summary>
        /// Returns a value indicating whether this instance and a specified System.Object
        /// represent the same type and value.
        /// </summary>
        /// <param name="obj">An System.Object.</param>
        /// <returns>true if value is a System.Half and equal to this instance; otherwise, false.</returns>
        public override bool Equals(object obj)
        {
            bool result = false;
            if (obj is Half)
            {
                Half half = (Half)obj;
                if ((half == this) || (IsNaN(half) && IsNaN(this)))
                {
                    result = true;
                }
            }

            return result;
        }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>A 32-bit signed integer hash code.</returns>
        public override int GetHashCode()
        {
            return value.GetHashCode();
        }
        /// <summary>
        /// Returns the System.TypeCode for value type System.Half.
        /// </summary>
        /// <returns>The enumerated constant (TypeCode)255.</returns>
        public TypeCode GetTypeCode()
        {
            return (TypeCode)255;
        }

        #region BitConverter & Math methods for Half
        /// <summary>
        /// Returns the specified half-precision floating point value as an array of bytes.
        /// </summary>
        /// <param name="value">The number to convert.</param>
        /// <returns>An array of bytes with length 2.</returns>
        public static byte[] GetBytes(Half value)
        {
            return BitConverter.GetBytes(value.value);
        }
        /// <summary>
        /// Converts the value of a specified instance of System.Half to its equivalent binary representation.
        /// </summary>
        /// <param name="value">A System.Half value.</param>
        /// <returns>A 16-bit unsigned integer that contain the binary representation of value.</returns>        
        public static ushort GetBits(Half value)
        {
            return value.value;
        }
        /// <summary>
        /// Returns a half-precision floating point number converted from two bytes
        /// at a specified position in a byte array.
        /// </summary>
        /// <param name="value">An array of bytes.</param>
        /// <param name="startIndex">The starting position within value.</param>
        /// <returns>A half-precision floating point number formed by two bytes beginning at startIndex.</returns>
        /// <exception cref="System.ArgumentException">
        /// startIndex is greater than or equal to the length of value minus 1, and is
        /// less than or equal to the length of value minus 1.
        /// </exception>
        /// <exception cref="System.ArgumentNullException">value is null.</exception>
        /// <exception cref="System.ArgumentOutOfRangeException">startIndex is less than zero or greater than the length of value minus 1.</exception>
        public static Half ToHalf(byte[] value, int startIndex)
        {
            return Half.ToHalf((ushort)BitConverter.ToInt16(value, startIndex));
        }
        /// <summary>
        /// Returns a half-precision floating point number converted from its binary representation.
        /// </summary>
        /// <param name="bits">Binary representation of System.Half value</param>
        /// <returns>A half-precision floating point number formed by its binary representation.</returns>
        public static Half ToHalf(ushort bits)
        {
            return new Half { value = bits };
        }

        /// <summary>
        /// Returns a value indicating the sign of a half-precision floating-point number.
        /// </summary>
        /// <param name="value">A signed number.</param>
        /// <returns>
        /// A number indicating the sign of value. Number Description -1 value is less
        /// than zero. 0 value is equal to zero. 1 value is greater than zero.
        /// </returns>
        /// <exception cref="System.ArithmeticException">value is equal to System.Half.NaN.</exception>
        public static int Sign(Half value)
        {
            if (value < 0)
            {
                return -1;
            }
            else if (value > 0)
            {
                return 1;
            }
            else
            {
                if (value != 0)
                {
                    throw new ArithmeticException("Function does not accept floating point Not-a-Number values.");
                }
            }

            return 0;
        }
        /// <summary>
        /// Returns the absolute value of a half-precision floating-point number.
        /// </summary>
        /// <param name="value">A number in the range System.Half.MinValue ≤ value ≤ System.Half.MaxValue.</param>
        /// <returns>A half-precision floating-point number, x, such that 0 ≤ x ≤System.Half.MaxValue.</returns>
        public static Half Abs(Half value)
        {
            return HalfHelper.Abs(value);
        }
        /// <summary>
        /// Returns the larger of two half-precision floating-point numbers.
        /// </summary>
        /// <param name="value1">The first of two half-precision floating-point numbers to compare.</param>
        /// <param name="value2">The second of two half-precision floating-point numbers to compare.</param>
        /// <returns>
        /// Parameter value1 or value2, whichever is larger. If value1, or value2, or both val1
        /// and value2 are equal to System.Half.NaN, System.Half.NaN is returned.
        /// </returns>
        public static Half Max(Half value1, Half value2)
        {
            return (value1 < value2) ? value2 : value1;
        }
        /// <summary>
        /// Returns the smaller of two half-precision floating-point numbers.
        /// </summary>
        /// <param name="value1">The first of two half-precision floating-point numbers to compare.</param>
        /// <param name="value2">The second of two half-precision floating-point numbers to compare.</param>
        /// <returns>
        /// Parameter value1 or value2, whichever is smaller. If value1, or value2, or both val1
        /// and value2 are equal to System.Half.NaN, System.Half.NaN is returned.
        /// </returns>
        public static Half Min(Half value1, Half value2)
        {
            return (value1 < value2) ? value1 : value2;
        }
        #endregion

        /// <summary>
        /// Returns a value indicating whether the specified number evaluates to not a number (System.Half.NaN).
        /// </summary>
        /// <param name="half">A half-precision floating-point number.</param>
        /// <returns>true if value evaluates to not a number (System.Half.NaN); otherwise, false.</returns>
        public static bool IsNaN(Half half)
        {
            return HalfHelper.IsNaN(half);
        }
        /// <summary>
        /// Returns a value indicating whether the specified number evaluates to negative or positive infinity.
        /// </summary>
        /// <param name="half">A half-precision floating-point number.</param>
        /// <returns>true if half evaluates to System.Half.PositiveInfinity or System.Half.NegativeInfinity; otherwise, false.</returns>
        public static bool IsInfinity(Half half)
        {
            return HalfHelper.IsInfinity(half);
        }
        /// <summary>
        /// Returns a value indicating whether the specified number evaluates to negative infinity.
        /// </summary>
        /// <param name="half">A half-precision floating-point number.</param>
        /// <returns>true if half evaluates to System.Half.NegativeInfinity; otherwise, false.</returns>
        public static bool IsNegativeInfinity(Half half)
        {
            return HalfHelper.IsNegativeInfinity(half);
        }
        /// <summary>
        /// Returns a value indicating whether the specified number evaluates to positive infinity.
        /// </summary>
        /// <param name="half">A half-precision floating-point number.</param>
        /// <returns>true if half evaluates to System.Half.PositiveInfinity; otherwise, false.</returns>
        public static bool IsPositiveInfinity(Half half)
        {
            return HalfHelper.IsPositiveInfinity(half);
        }

        #region String operations (Parse and ToString)
        /// <summary>
        /// Converts the string representation of a number to its System.Half equivalent.
        /// </summary>
        /// <param name="value">The string representation of the number to convert.</param>
        /// <returns>The System.Half number equivalent to the number contained in value.</returns>
        /// <exception cref="System.ArgumentNullException">value is null.</exception>
        /// <exception cref="System.FormatException">value is not in the correct format.</exception>
        /// <exception cref="System.OverflowException">value represents a number less than System.Half.MinValue or greater than System.Half.MaxValue.</exception>
        public static Half Parse(string value)
        {
            return (Half)float.Parse(value, CultureInfo.InvariantCulture);
        }
        /// <summary>
        /// Converts the string representation of a number to its System.Half equivalent 
        /// using the specified culture-specific format information.
        /// </summary>
        /// <param name="value">The string representation of the number to convert.</param>
        /// <param name="provider">An System.IFormatProvider that supplies culture-specific parsing information about value.</param>
        /// <returns>The System.Half number equivalent to the number contained in s as specified by provider.</returns>
        /// <exception cref="System.ArgumentNullException">value is null.</exception>
        /// <exception cref="System.FormatException">value is not in the correct format.</exception>
        /// <exception cref="System.OverflowException">value represents a number less than System.Half.MinValue or greater than System.Half.MaxValue.</exception>
        public static Half Parse(string value, IFormatProvider provider)
        {
            return (Half)float.Parse(value, provider);
        }
        /// <summary>
        /// Converts the string representation of a number in a specified style to its System.Half equivalent.
        /// </summary>
        /// <param name="value">The string representation of the number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of System.Globalization.NumberStyles values that indicates
        /// the style elements that can be present in value. A typical value to specify is
        /// System.Globalization.NumberStyles.Number.
        /// </param>
        /// <returns>The System.Half number equivalent to the number contained in s as specified by style.</returns>
        /// <exception cref="System.ArgumentNullException">value is null.</exception>
        /// <exception cref="System.ArgumentException">
        /// style is not a System.Globalization.NumberStyles value. -or- style is the
        /// System.Globalization.NumberStyles.AllowHexSpecifier value.
        /// </exception>
        /// <exception cref="System.FormatException">value is not in the correct format.</exception>
        /// <exception cref="System.OverflowException">value represents a number less than System.Half.MinValue or greater than System.Half.MaxValue.</exception>
        public static Half Parse(string value, NumberStyles style)
        {
            return (Half)float.Parse(value, style, CultureInfo.InvariantCulture);
        }
        /// <summary>
        /// Converts the string representation of a number to its System.Half equivalent 
        /// using the specified style and culture-specific format.
        /// </summary>
        /// <param name="value">The string representation of the number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of System.Globalization.NumberStyles values that indicates
        /// the style elements that can be present in value. A typical value to specify is 
        /// System.Globalization.NumberStyles.Number.
        /// </param>
        /// <param name="provider">An System.IFormatProvider object that supplies culture-specific information about the format of value.</param>
        /// <returns>The System.Half number equivalent to the number contained in s as specified by style and provider.</returns>
        /// <exception cref="System.ArgumentNullException">value is null.</exception>
        /// <exception cref="System.ArgumentException">
        /// style is not a System.Globalization.NumberStyles value. -or- style is the
        /// System.Globalization.NumberStyles.AllowHexSpecifier value.
        /// </exception>
        /// <exception cref="System.FormatException">value is not in the correct format.</exception>
        /// <exception cref="System.OverflowException">value represents a number less than System.Half.MinValue or greater than System.Half.MaxValue.</exception>
        public static Half Parse(string value, NumberStyles style, IFormatProvider provider)
        {
            return (Half)float.Parse(value, style, provider);
        }
        /// <summary>
        /// Converts the string representation of a number to its System.Half equivalent.
        /// A return value indicates whether the conversion succeeded or failed.
        /// </summary>
        /// <param name="value">The string representation of the number to convert.</param>
        /// <param name="result">
        /// When this method returns, contains the System.Half number that is equivalent
        /// to the numeric value contained in value, if the conversion succeeded, or is zero
        /// if the conversion failed. The conversion fails if the s parameter is null,
        /// is not a number in a valid format, or represents a number less than System.Half.MinValue
        /// or greater than System.Half.MaxValue. This parameter is passed uninitialized.
        /// </param>
        /// <returns>true if s was converted successfully; otherwise, false.</returns>
        public static bool TryParse(string value, out Half result)
        {
            float f;
            if (float.TryParse(value, out f))
            {
                result = (Half)f;
                return true;
            }

            result = new Half();
            return false;
        }
        /// <summary>
        /// Converts the string representation of a number to its System.Half equivalent
        /// using the specified style and culture-specific format. A return value indicates
        /// whether the conversion succeeded or failed.
        /// </summary>
        /// <param name="value">The string representation of the number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of System.Globalization.NumberStyles values that indicates
        /// the permitted format of value. A typical value to specify is System.Globalization.NumberStyles.Number.
        /// </param>
        /// <param name="provider">An System.IFormatProvider object that supplies culture-specific parsing information about value.</param>
        /// <param name="result">
        /// When this method returns, contains the System.Half number that is equivalent
        /// to the numeric value contained in value, if the conversion succeeded, or is zero
        /// if the conversion failed. The conversion fails if the s parameter is null,
        /// is not in a format compliant with style, or represents a number less than
        /// System.Half.MinValue or greater than System.Half.MaxValue. This parameter is passed uninitialized.
        /// </param>
        /// <returns>true if s was converted successfully; otherwise, false.</returns>
        /// <exception cref="System.ArgumentException">
        /// style is not a System.Globalization.NumberStyles value. -or- style 
        /// is the System.Globalization.NumberStyles.AllowHexSpecifier value.
        /// </exception>
        public static bool TryParse(string value, NumberStyles style, IFormatProvider provider, out Half result)
        {
            bool parseResult = false;
            float f;
            if (float.TryParse(value, style, provider, out f))
            {
                result = (Half)f;
                parseResult = true;
            }
            else
            {
                result = new Half();
            }

            return parseResult;
        }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>A string that represents the value of this instance.</returns>
        public override string ToString()
        {
            return ((float)this).ToString(CultureInfo.InvariantCulture);
        }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation
        /// using the specified culture-specific format information.
        /// </summary>
        /// <param name="formatProvider">An System.IFormatProvider that supplies culture-specific formatting information.</param>
        /// <returns>The string representation of the value of this instance as specified by provider.</returns>
        public string ToString(IFormatProvider formatProvider)
        {
            return ((float)this).ToString(formatProvider);
        }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation, using the specified format.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <returns>The string representation of the value of this instance as specified by format.</returns>
        public string ToString(string format)
        {
            return ((float)this).ToString(format, CultureInfo.InvariantCulture);
        }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation 
        /// using the specified format and culture-specific format information.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <param name="formatProvider">An System.IFormatProvider that supplies culture-specific formatting information.</param>
        /// <returns>The string representation of the value of this instance as specified by format and provider.</returns>
        /// <exception cref="System.FormatException">format is invalid.</exception>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            return ((float)this).ToString(format, formatProvider);
        }
        #endregion

        #region IConvertible Members
        float IConvertible.ToSingle(IFormatProvider provider)
        {
            return (float)this;
        }
        TypeCode IConvertible.GetTypeCode()
        {
            return GetTypeCode();
        }
        bool IConvertible.ToBoolean(IFormatProvider provider)
        {
            return Convert.ToBoolean((float)this);
        }
        byte IConvertible.ToByte(IFormatProvider provider)
        {
            return Convert.ToByte((float)this);
        }
        char IConvertible.ToChar(IFormatProvider provider)
        {
            throw new InvalidCastException(string.Format(CultureInfo.CurrentCulture, "Invalid cast from '{0}' to '{1}'.", "Half", "Char"));
        }
        DateTime IConvertible.ToDateTime(IFormatProvider provider)
        {
            throw new InvalidCastException(string.Format(CultureInfo.CurrentCulture, "Invalid cast from '{0}' to '{1}'.", "Half", "DateTime"));
        }
        decimal IConvertible.ToDecimal(IFormatProvider provider)
        {
            return Convert.ToDecimal((float)this);
        }
        double IConvertible.ToDouble(IFormatProvider provider)
        {
            return Convert.ToDouble((float)this);
        }
        short IConvertible.ToInt16(IFormatProvider provider)
        {
            return Convert.ToInt16((float)this);
        }
        int IConvertible.ToInt32(IFormatProvider provider)
        {
            return Convert.ToInt32((float)this);
        }
        long IConvertible.ToInt64(IFormatProvider provider)
        {
            return Convert.ToInt64((float)this);
        }
        sbyte IConvertible.ToSByte(IFormatProvider provider)
        {
            return Convert.ToSByte((float)this);
        }
        string IConvertible.ToString(IFormatProvider provider)
        {
            return Convert.ToString((float)this, CultureInfo.InvariantCulture);
        }
        object IConvertible.ToType(Type conversionType, IFormatProvider provider)
        {
            return (((float)this) as IConvertible).ToType(conversionType, provider);
        }
        ushort IConvertible.ToUInt16(IFormatProvider provider)
        {
            return Convert.ToUInt16((float)this);
        }
        uint IConvertible.ToUInt32(IFormatProvider provider)
        {
            return Convert.ToUInt32((float)this);
        }
        ulong IConvertible.ToUInt64(IFormatProvider provider)
        {
            return Convert.ToUInt64((float)this);
        }
        #endregion
    }
}

```

`AssetStudio/Math/HalfHelper.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace AssetStudio
{
    /// <summary>
    /// Helper class for Half conversions and some low level operations.
    /// This class is internally used in the Half class.
    /// </summary>
    /// <remarks>
    /// References:
    ///     - Fast Half Float Conversions, Jeroen van der Zijp, link: http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
    /// </remarks>
    [ComVisible(false)]
    internal static class HalfHelper
    {
        private static uint[] mantissaTable = GenerateMantissaTable();
        private static uint[] exponentTable = GenerateExponentTable();
        private static ushort[] offsetTable = GenerateOffsetTable();
        private static ushort[] baseTable = GenerateBaseTable();
        private static sbyte[] shiftTable = GenerateShiftTable();

        // Transforms the subnormal representation to a normalized one. 
        private static uint ConvertMantissa(int i)
        {
            uint m = (uint)(i << 13); // Zero pad mantissa bits
            uint e = 0; // Zero exponent

            // While not normalized
            while ((m & 0x00800000) == 0)
            {
                e -= 0x00800000; // Decrement exponent (1<<23)
                m <<= 1; // Shift mantissa                
            }
            m &= unchecked((uint)~0x00800000); // Clear leading 1 bit
            e += 0x38800000; // Adjust bias ((127-14)<<23)
            return m | e; // Return combined number
        }

        private static uint[] GenerateMantissaTable()
        {
            uint[] mantissaTable = new uint[2048];
            mantissaTable[0] = 0;
            for (int i = 1; i < 1024; i++)
            {
                mantissaTable[i] = ConvertMantissa(i);
            }
            for (int i = 1024; i < 2048; i++)
            {
                mantissaTable[i] = (uint)(0x38000000 + ((i - 1024) << 13));
            }

            return mantissaTable;
        }
        private static uint[] GenerateExponentTable()
        {
            uint[] exponentTable = new uint[64];
            exponentTable[0] = 0;
            for (int i = 1; i < 31; i++)
            {
                exponentTable[i] = (uint)(i << 23);
            }
            exponentTable[31] = 0x47800000;
            exponentTable[32] = 0x80000000;
            for (int i = 33; i < 63; i++)
            {
                exponentTable[i] = (uint)(0x80000000 + ((i - 32) << 23));
            }
            exponentTable[63] = 0xc7800000;

            return exponentTable;
        }
        private static ushort[] GenerateOffsetTable()
        {
            ushort[] offsetTable = new ushort[64];
            offsetTable[0] = 0;
            for (int i = 1; i < 32; i++)
            {
                offsetTable[i] = 1024;
            }
            offsetTable[32] = 0;
            for (int i = 33; i < 64; i++)
            {
                offsetTable[i] = 1024;
            }

            return offsetTable;
        }
        private static ushort[] GenerateBaseTable()
        {
            ushort[] baseTable = new ushort[512];
            for (int i = 0; i < 256; ++i)
            {
                sbyte e = (sbyte)(127 - i);
                if (e > 24)
                { // Very small numbers map to zero
                    baseTable[i | 0x000] = 0x0000;
                    baseTable[i | 0x100] = 0x8000;
                }
                else if (e > 14)
                { // Small numbers map to denorms
                    baseTable[i | 0x000] = (ushort)(0x0400 >> (18 + e));
                    baseTable[i | 0x100] = (ushort)((0x0400 >> (18 + e)) | 0x8000);
                }
                else if (e >= -15)
                { // Normal numbers just lose precision
                    baseTable[i | 0x000] = (ushort)((15 - e) << 10);
                    baseTable[i | 0x100] = (ushort)(((15 - e) << 10) | 0x8000);
                }
                else if (e > -128)
                { // Large numbers map to Infinity
                    baseTable[i | 0x000] = 0x7c00;
                    baseTable[i | 0x100] = 0xfc00;
                }
                else
                { // Infinity and NaN's stay Infinity and NaN's
                    baseTable[i | 0x000] = 0x7c00;
                    baseTable[i | 0x100] = 0xfc00;
                }
            }

            return baseTable;
        }
        private static sbyte[] GenerateShiftTable()
        {
            sbyte[] shiftTable = new sbyte[512];
            for (int i = 0; i < 256; ++i)
            {
                sbyte e = (sbyte)(127 - i);
                if (e > 24)
                { // Very small numbers map to zero
                    shiftTable[i | 0x000] = 24;
                    shiftTable[i | 0x100] = 24;
                }
                else if (e > 14)
                { // Small numbers map to denorms
                    shiftTable[i | 0x000] = (sbyte)(e - 1);
                    shiftTable[i | 0x100] = (sbyte)(e - 1);
                }
                else if (e >= -15)
                { // Normal numbers just lose precision
                    shiftTable[i | 0x000] = 13;
                    shiftTable[i | 0x100] = 13;
                }
                else if (e > -128)
                { // Large numbers map to Infinity
                    shiftTable[i | 0x000] = 24;
                    shiftTable[i | 0x100] = 24;
                }
                else
                { // Infinity and NaN's stay Infinity and NaN's
                    shiftTable[i | 0x000] = 13;
                    shiftTable[i | 0x100] = 13;
                }
            }

            return shiftTable;
        }

        /*public static unsafe float HalfToSingle(Half half)
        {
            uint result = mantissaTable[offsetTable[half.value >> 10] + (half.value & 0x3ff)] + exponentTable[half.value >> 10];
            return *((float*)&result);
        }
        public static unsafe Half SingleToHalf(float single)
        {
            uint value = *((uint*)&single);

            ushort result = (ushort)(baseTable[(value >> 23) & 0x1ff] + ((value & 0x007fffff) >> shiftTable[value >> 23]));
            return Half.ToHalf(result);
        }*/
        public static float HalfToSingle(Half half)
        {
            uint result = mantissaTable[offsetTable[half.value >> 10] + (half.value & 0x3ff)] + exponentTable[half.value >> 10];
            byte[] uintBytes = BitConverter.GetBytes(result);
            return BitConverter.ToSingle(uintBytes, 0);
        }
        public static Half SingleToHalf(float single)
        {
            byte[] singleBytes = BitConverter.GetBytes(single);
            uint value = BitConverter.ToUInt32(singleBytes, 0);
            ushort result = (ushort)(baseTable[(value >> 23) & 0x1ff] + ((value & 0x007fffff) >> shiftTable[value >> 23]));
            return Half.ToHalf(result);
        }

        public static Half Negate(Half half)
        {
            return Half.ToHalf((ushort)(half.value ^ 0x8000));
        }
        public static Half Abs(Half half)
        {
            return Half.ToHalf((ushort)(half.value & 0x7fff));
        }

        public static bool IsNaN(Half half)
        {
            return ((half.value & 0x7fff) > 0x7c00);
        }
        public static bool IsInfinity(Half half)
        {
            return ((half.value & 0x7fff) == 0x7c00);
        }
        public static bool IsPositiveInfinity(Half half)
        {
            return (half.value == 0x7c00);
        }
        public static bool IsNegativeInfinity(Half half)
        {
            return (half.value == 0xfc00);
        }
    }
}

```

`AssetStudio/Math/Matrix4x4.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace AssetStudio
{
    [StructLayout(LayoutKind.Sequential, Pack = 4)]
    public struct Matrix4x4 : IEquatable<Matrix4x4>
    {
        public float M00;
        public float M10;
        public float M20;
        public float M30;

        public float M01;
        public float M11;
        public float M21;
        public float M31;

        public float M02;
        public float M12;
        public float M22;
        public float M32;

        public float M03;
        public float M13;
        public float M23;
        public float M33;

        public Matrix4x4(float[] values)
        {
            if (values == null)
                throw new ArgumentNullException(nameof(values));
            if (values.Length != 16)
                throw new ArgumentOutOfRangeException(nameof(values), "There must be sixteen and only sixteen input values for Matrix.");

            M00 = values[0];
            M10 = values[1];
            M20 = values[2];
            M30 = values[3];

            M01 = values[4];
            M11 = values[5];
            M21 = values[6];
            M31 = values[7];

            M02 = values[8];
            M12 = values[9];
            M22 = values[10];
            M32 = values[11];

            M03 = values[12];
            M13 = values[13];
            M23 = values[14];
            M33 = values[15];
        }

        public float this[int row, int column]
        {
            get => this[row + column * 4];

            set => this[row + column * 4] = value;
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M10;
                    case 2: return M20;
                    case 3: return M30;
                    case 4: return M01;
                    case 5: return M11;
                    case 6: return M21;
                    case 7: return M31;
                    case 8: return M02;
                    case 9: return M12;
                    case 10: return M22;
                    case 11: return M32;
                    case 12: return M03;
                    case 13: return M13;
                    case 14: return M23;
                    case 15: return M33;
                    default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Matrix4x4 index!");
                }
            }

            set
            {
                switch (index)
                {
                    case 0: M00 = value; break;
                    case 1: M10 = value; break;
                    case 2: M20 = value; break;
                    case 3: M30 = value; break;
                    case 4: M01 = value; break;
                    case 5: M11 = value; break;
                    case 6: M21 = value; break;
                    case 7: M31 = value; break;
                    case 8: M02 = value; break;
                    case 9: M12 = value; break;
                    case 10: M22 = value; break;
                    case 11: M32 = value; break;
                    case 12: M03 = value; break;
                    case 13: M13 = value; break;
                    case 14: M23 = value; break;
                    case 15: M33 = value; break;
                    default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Matrix4x4 index!");
                }
            }
        }

        public override int GetHashCode()
        {
            return GetColumn(0).GetHashCode() ^ (GetColumn(1).GetHashCode() << 2) ^ (GetColumn(2).GetHashCode() >> 2) ^ (GetColumn(3).GetHashCode() >> 1);
        }

        public override bool Equals(object other)
        {
            if (!(other is Matrix4x4))
                return false;
            return Equals((Matrix4x4)other);
        }

        public bool Equals(Matrix4x4 other)
        {
            return GetColumn(0).Equals(other.GetColumn(0))
                   && GetColumn(1).Equals(other.GetColumn(1))
                   && GetColumn(2).Equals(other.GetColumn(2))
                   && GetColumn(3).Equals(other.GetColumn(3));
        }

        public Vector4 GetColumn(int index)
        {
            switch (index)
            {
                case 0: return new Vector4(M00, M10, M20, M30);
                case 1: return new Vector4(M01, M11, M21, M31);
                case 2: return new Vector4(M02, M12, M22, M32);
                case 3: return new Vector4(M03, M13, M23, M33);
                default: throw new IndexOutOfRangeException("Invalid column index!");
            }
        }

        public Vector4 GetRow(int index)
        {
            switch (index)
            {
                case 0: return new Vector4(M00, M01, M02, M03);
                case 1: return new Vector4(M10, M11, M12, M13);
                case 2: return new Vector4(M20, M21, M22, M23);
                case 3: return new Vector4(M30, M31, M32, M33);
                default: throw new IndexOutOfRangeException("Invalid row index!");
            }
        }

        public static Matrix4x4 operator *(Matrix4x4 lhs, Matrix4x4 rhs)
        {
            Matrix4x4 res;
            res.M00 = lhs.M00 * rhs.M00 + lhs.M01 * rhs.M10 + lhs.M02 * rhs.M20 + lhs.M03 * rhs.M30;
            res.M01 = lhs.M00 * rhs.M01 + lhs.M01 * rhs.M11 + lhs.M02 * rhs.M21 + lhs.M03 * rhs.M31;
            res.M02 = lhs.M00 * rhs.M02 + lhs.M01 * rhs.M12 + lhs.M02 * rhs.M22 + lhs.M03 * rhs.M32;
            res.M03 = lhs.M00 * rhs.M03 + lhs.M01 * rhs.M13 + lhs.M02 * rhs.M23 + lhs.M03 * rhs.M33;

            res.M10 = lhs.M10 * rhs.M00 + lhs.M11 * rhs.M10 + lhs.M12 * rhs.M20 + lhs.M13 * rhs.M30;
            res.M11 = lhs.M10 * rhs.M01 + lhs.M11 * rhs.M11 + lhs.M12 * rhs.M21 + lhs.M13 * rhs.M31;
            res.M12 = lhs.M10 * rhs.M02 + lhs.M11 * rhs.M12 + lhs.M12 * rhs.M22 + lhs.M13 * rhs.M32;
            res.M13 = lhs.M10 * rhs.M03 + lhs.M11 * rhs.M13 + lhs.M12 * rhs.M23 + lhs.M13 * rhs.M33;

            res.M20 = lhs.M20 * rhs.M00 + lhs.M21 * rhs.M10 + lhs.M22 * rhs.M20 + lhs.M23 * rhs.M30;
            res.M21 = lhs.M20 * rhs.M01 + lhs.M21 * rhs.M11 + lhs.M22 * rhs.M21 + lhs.M23 * rhs.M31;
            res.M22 = lhs.M20 * rhs.M02 + lhs.M21 * rhs.M12 + lhs.M22 * rhs.M22 + lhs.M23 * rhs.M32;
            res.M23 = lhs.M20 * rhs.M03 + lhs.M21 * rhs.M13 + lhs.M22 * rhs.M23 + lhs.M23 * rhs.M33;

            res.M30 = lhs.M30 * rhs.M00 + lhs.M31 * rhs.M10 + lhs.M32 * rhs.M20 + lhs.M33 * rhs.M30;
            res.M31 = lhs.M30 * rhs.M01 + lhs.M31 * rhs.M11 + lhs.M32 * rhs.M21 + lhs.M33 * rhs.M31;
            res.M32 = lhs.M30 * rhs.M02 + lhs.M31 * rhs.M12 + lhs.M32 * rhs.M22 + lhs.M33 * rhs.M32;
            res.M33 = lhs.M30 * rhs.M03 + lhs.M31 * rhs.M13 + lhs.M32 * rhs.M23 + lhs.M33 * rhs.M33;

            return res;
        }

        public static bool operator ==(Matrix4x4 lhs, Matrix4x4 rhs)
        {
            return lhs.GetColumn(0) == rhs.GetColumn(0)
                && lhs.GetColumn(1) == rhs.GetColumn(1)
                && lhs.GetColumn(2) == rhs.GetColumn(2)
                && lhs.GetColumn(3) == rhs.GetColumn(3);
        }

        public static bool operator !=(Matrix4x4 lhs, Matrix4x4 rhs)
        {
            return !(lhs == rhs);
        }

        public static Matrix4x4 Scale(Vector3 vector)
        {
            Matrix4x4 m;
            m.M00 = vector.X; m.M01 = 0F; m.M02 = 0F; m.M03 = 0F;
            m.M10 = 0F; m.M11 = vector.Y; m.M12 = 0F; m.M13 = 0F;
            m.M20 = 0F; m.M21 = 0F; m.M22 = vector.Z; m.M23 = 0F;
            m.M30 = 0F; m.M31 = 0F; m.M32 = 0F; m.M33 = 1F;
            return m;
        }

        public static Matrix4x4 Translate(Vector3 vector)
        {
            Matrix4x4 m;
            m.M00 = 1F; m.M01 = 0F; m.M02 = 0F; m.M03 = vector.X;
            m.M10 = 0F; m.M11 = 1F; m.M12 = 0F; m.M13 = vector.Y;
            m.M20 = 0F; m.M21 = 0F; m.M22 = 1F; m.M23 = vector.Z;
            m.M30 = 0F; m.M31 = 0F; m.M32 = 0F; m.M33 = 1F;
            return m;
        }

        public static Matrix4x4 Rotate(Quaternion q)
        {
            float x = q.X * 2.0F;
            float y = q.Y * 2.0F;
            float z = q.Z * 2.0F;
            float xx = q.X * x;
            float yy = q.Y * y;
            float zz = q.Z * z;
            float xy = q.X * y;
            float xz = q.X * z;
            float yz = q.Y * z;
            float wx = q.W * x;
            float wy = q.W * y;
            float wz = q.W * z;

            Matrix4x4 m;
            m.M00 = 1.0f - (yy + zz); m.M10 = xy + wz; m.M20 = xz - wy; m.M30 = 0.0F;
            m.M01 = xy - wz; m.M11 = 1.0f - (xx + zz); m.M21 = yz + wx; m.M31 = 0.0F;
            m.M02 = xz + wy; m.M12 = yz - wx; m.M22 = 1.0f - (xx + yy); m.M32 = 0.0F;
            m.M03 = 0.0F; m.M13 = 0.0F; m.M23 = 0.0F; m.M33 = 1.0F;
            return m;
        }
    }
}

```

`AssetStudio/Math/Quaternion.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace AssetStudio
{
    [StructLayout(LayoutKind.Sequential, Pack = 4)]
    public struct Quaternion : IEquatable<Quaternion>
    {
        public float X;
        public float Y;
        public float Z;
        public float W;

        public Quaternion(float x, float y, float z, float w)
        {
            X = x;
            Y = y;
            Z = z;
            W = w;
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return X;
                    case 1: return Y;
                    case 2: return Z;
                    case 3: return W;
                    default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Quaternion index!");
                }
            }

            set
            {
                switch (index)
                {
                    case 0: X = value; break;
                    case 1: Y = value; break;
                    case 2: Z = value; break;
                    case 3: W = value; break;
                    default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Quaternion index!");
                }
            }
        }

        public override int GetHashCode()
        {
            return X.GetHashCode() ^ (Y.GetHashCode() << 2) ^ (Z.GetHashCode() >> 2) ^ (W.GetHashCode() >> 1);
        }

        public override bool Equals(object other)
        {
            if (!(other is Quaternion))
                return false;
            return Equals((Quaternion)other);
        }

        public bool Equals(Quaternion other)
        {
            return X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z) && W.Equals(other.W);
        }

        public static float Dot(Quaternion a, Quaternion b)
        {
            return a.X * b.X + a.Y * b.Y + a.Z * b.Z + a.W * b.W;
        }

        private static bool IsEqualUsingDot(float dot)
        {
            return dot > 1.0f - kEpsilon;
        }

        public static bool operator ==(Quaternion lhs, Quaternion rhs)
        {
            return IsEqualUsingDot(Dot(lhs, rhs));
        }

        public static bool operator !=(Quaternion lhs, Quaternion rhs)
        {
            return !(lhs == rhs);
        }

        private const float kEpsilon = 0.000001F;
    }
}

```

`AssetStudio/Math/Vector2.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace AssetStudio
{
    [StructLayout(LayoutKind.Sequential, Pack = 4)]
    public struct Vector2 : IEquatable<Vector2>
    {
        public float X;
        public float Y;

        public Vector2(float x, float y)
        {
            X = x;
            Y = y;
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return X;
                    case 1: return Y;
                    default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Vector2 index!");
                }
            }

            set
            {
                switch (index)
                {
                    case 0: X = value; break;
                    case 1: Y = value; break;
                    default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Vector2 index!");
                }
            }
        }

        public override int GetHashCode()
        {
            return X.GetHashCode() ^ (Y.GetHashCode() << 2);
        }

        public override bool Equals(object other)
        {
            if (!(other is Vector2))
                return false;
            return Equals((Vector2)other);
        }

        public bool Equals(Vector2 other)
        {
            return X.Equals(other.X) && Y.Equals(other.Y);
        }

        public void Normalize()
        {
            var length = Length();
            if (length > kEpsilon)
            {
                var invNorm = 1.0f / length;
                X *= invNorm;
                Y *= invNorm;
            }
            else
            {
                X = 0;
                Y = 0;
            }
        }

        public float Length()
        {
            return (float)Math.Sqrt(LengthSquared());
        }

        public float LengthSquared()
        {
            return X * X + Y * Y;
        }

        public static Vector2 Zero => new Vector2();

        public static Vector2 operator +(Vector2 a, Vector2 b)
        {
            return new Vector2(a.X + b.X, a.Y + b.Y);
        }

        public static Vector2 operator -(Vector2 a, Vector2 b)
        {
            return new Vector2(a.X - b.X, a.Y - b.Y);
        }

        public static Vector2 operator *(Vector2 a, Vector2 b)
        {
            return new Vector2(a.X * b.X, a.Y * b.Y);
        }

        public static Vector2 operator /(Vector2 a, Vector2 b)
        {
            return new Vector2(a.X / b.X, a.Y / b.Y);
        }

        public static Vector2 operator -(Vector2 a)
        {
            return new Vector2(-a.X, -a.Y);
        }

        public static Vector2 operator *(Vector2 a, float d)
        {
            return new Vector2(a.X * d, a.Y * d);
        }

        public static Vector2 operator *(float d, Vector2 a)
        {
            return new Vector2(a.X * d, a.Y * d);
        }

        public static Vector2 operator /(Vector2 a, float d)
        {
            return new Vector2(a.X / d, a.Y / d);
        }

        public static bool operator ==(Vector2 lhs, Vector2 rhs)
        {
            return (lhs - rhs).LengthSquared() < kEpsilon * kEpsilon;
        }

        public static bool operator !=(Vector2 lhs, Vector2 rhs)
        {
            return !(lhs == rhs);
        }

        public static implicit operator Vector3(Vector2 v)
        {
            return new Vector3(v.X, v.Y, 0);
        }

        public static implicit operator Vector4(Vector2 v)
        {
            return new Vector4(v.X, v.Y, 0.0F, 0.0F);
        }

        private const float kEpsilon = 0.00001F;
    }
}

```

`AssetStudio/Math/Vector3.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace AssetStudio
{
    [StructLayout(LayoutKind.Sequential, Pack = 4)]
    public struct Vector3 : IEquatable<Vector3>
    {
        public float X;
        public float Y;
        public float Z;

        public Vector3(float x, float y, float z)
        {
            X = x;
            Y = y;
            Z = z;
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return X;
                    case 1: return Y;
                    case 2: return Z;
                    default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Vector3 index!");
                }
            }

            set
            {
                switch (index)
                {
                    case 0: X = value; break;
                    case 1: Y = value; break;
                    case 2: Z = value; break;
                    default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Vector3 index!");
                }
            }
        }

        public override int GetHashCode()
        {
            return X.GetHashCode() ^ (Y.GetHashCode() << 2) ^ (Z.GetHashCode() >> 2);
        }

        public override bool Equals(object other)
        {
            if (!(other is Vector3))
                return false;
            return Equals((Vector3)other);
        }

        public bool Equals(Vector3 other)
        {
            return X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z);
        }

        public void Normalize()
        {
            var length = Length();
            if (length > kEpsilon)
            {
                var invNorm = 1.0f / length;
                X *= invNorm;
                Y *= invNorm;
                Z *= invNorm;
            }
            else
            {
                X = 0;
                Y = 0;
                Z = 0;
            }
        }

        public float Length()
        {
            return (float)Math.Sqrt(LengthSquared());
        }

        public float LengthSquared()
        {
            return X * X + Y * Y + Z * Z;
        }

        public static Vector3 Zero => new Vector3();

        public static Vector3 One => new Vector3(1.0f, 1.0f, 1.0f);

        public static Vector3 operator +(Vector3 a, Vector3 b)
        {
            return new Vector3(a.X + b.X, a.Y + b.Y, a.Z + b.Z);
        }

        public static Vector3 operator -(Vector3 a, Vector3 b)
        {
            return new Vector3(a.X - b.X, a.Y - b.Y, a.Z - b.Z);
        }

        public static Vector3 operator -(Vector3 a)
        {
            return new Vector3(-a.X, -a.Y, -a.Z);
        }

        public static Vector3 operator *(Vector3 a, float d)
        {
            return new Vector3(a.X * d, a.Y * d, a.Z * d);
        }

        public static Vector3 operator *(float d, Vector3 a)
        {
            return new Vector3(a.X * d, a.Y * d, a.Z * d);
        }

        public static Vector3 operator /(Vector3 a, float d)
        {
            return new Vector3(a.X / d, a.Y / d, a.Z / d);
        }

        public static bool operator ==(Vector3 lhs, Vector3 rhs)
        {
            return (lhs - rhs).LengthSquared() < kEpsilon * kEpsilon;
        }

        public static bool operator !=(Vector3 lhs, Vector3 rhs)
        {
            return !(lhs == rhs);
        }

        public static implicit operator Vector2(Vector3 v)
        {
            return new Vector2(v.X, v.Y);
        }

        public static implicit operator Vector4(Vector3 v)
        {
            return new Vector4(v.X, v.Y, v.Z, 0.0F);
        }

        private const float kEpsilon = 0.00001F;
    }
}

```

`AssetStudio/Math/Vector4.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace AssetStudio
{
    [StructLayout(LayoutKind.Sequential, Pack = 4)]
    public struct Vector4 : IEquatable<Vector4>
    {
        public float X;
        public float Y;
        public float Z;
        public float W;

        public Vector4(float x, float y, float z, float w)
        {
            X = x;
            Y = y;
            Z = z;
            W = w;
        }

        public Vector4(Vector3 value, float w)
        {
            X = value.X;
            Y = value.Y;
            Z = value.Z;
            W = w;
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return X;
                    case 1: return Y;
                    case 2: return Z;
                    case 3: return W;
                    default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Vector4 index!");
                }
            }

            set
            {
                switch (index)
                {
                    case 0: X = value; break;
                    case 1: Y = value; break;
                    case 2: Z = value; break;
                    case 3: W = value; break;
                    default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Vector4 index!");
                }
            }
        }

        public override int GetHashCode()
        {
            return X.GetHashCode() ^ (Y.GetHashCode() << 2) ^ (Z.GetHashCode() >> 2) ^ (W.GetHashCode() >> 1);
        }

        public override bool Equals(object other)
        {
            if (!(other is Vector4))
                return false;
            return Equals((Vector4)other);
        }

        public bool Equals(Vector4 other)
        {
            return X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z) && W.Equals(other.W);
        }

        public void Normalize()
        {
            var length = Length();
            if (length > kEpsilon)
            {
                var invNorm = 1.0f / length;
                X *= invNorm;
                Y *= invNorm;
                Z *= invNorm;
                W *= invNorm;
            }
            else
            {
                X = 0;
                Y = 0;
                Z = 0;
                W = 0;
            }
        }

        public float Length()
        {
            return (float)Math.Sqrt(LengthSquared());
        }

        public float LengthSquared()
        {
            return X * X + Y * Y + Z * Z + W * W;
        }

        public static Vector4 Zero => new Vector4();

        public static Vector4 operator +(Vector4 a, Vector4 b)
        {
            return new Vector4(a.X + b.X, a.Y + b.Y, a.Z + b.Z, a.W + b.W);
        }

        public static Vector4 operator -(Vector4 a, Vector4 b)
        {
            return new Vector4(a.X - b.X, a.Y - b.Y, a.Z - b.Z, a.W - b.W);
        }

        public static Vector4 operator -(Vector4 a)
        {
            return new Vector4(-a.X, -a.Y, -a.Z, -a.W);
        }

        public static Vector4 operator *(Vector4 a, float d)
        {
            return new Vector4(a.X * d, a.Y * d, a.Z * d, a.W * d);
        }

        public static Vector4 operator *(float d, Vector4 a)
        {
            return new Vector4(a.X * d, a.Y * d, a.Z * d, a.W * d);
        }

        public static Vector4 operator /(Vector4 a, float d)
        {
            return new Vector4(a.X / d, a.Y / d, a.Z / d, a.W / d);
        }

        public static bool operator ==(Vector4 lhs, Vector4 rhs)
        {
            return (lhs - rhs).LengthSquared() < kEpsilon * kEpsilon;
        }

        public static bool operator !=(Vector4 lhs, Vector4 rhs)
        {
            return !(lhs == rhs);
        }

        public static implicit operator Vector2(Vector4 v)
        {
            return new Vector2(v.X, v.Y);
        }

        public static implicit operator Vector3(Vector4 v)
        {
            return new Vector3(v.X, v.Y, v.Z);
        }

        public static implicit operator Color(Vector4 v)
        {
            return new Color(v.X, v.Y, v.Z, v.W);
        }

        private const float kEpsilon = 0.00001F;
    }
}

```

`AssetStudio/ObjectInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class ObjectInfo
    {
        public long byteStart;
        public uint byteSize;
        public int typeID;
        public int classID;
        public ushort isDestroyed;
        public byte stripped;

        public long m_PathID;
        public SerializedType serializedType;
    }
}

```

`AssetStudio/ObjectReader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class ObjectReader : EndianBinaryReader
    {
        public SerializedFile assetsFile;
        public long m_PathID;
        public long byteStart;
        public uint byteSize;
        public ClassIDType type;
        public SerializedType serializedType;
        public BuildTarget platform;
        public SerializedFileFormatVersion m_Version;

        public int[] version => assetsFile.version;
        public BuildType buildType => assetsFile.buildType;

        public ObjectReader(EndianBinaryReader reader, SerializedFile assetsFile, ObjectInfo objectInfo) : base(reader.BaseStream, reader.Endian)
        {
            this.assetsFile = assetsFile;
            m_PathID = objectInfo.m_PathID;
            byteStart = objectInfo.byteStart;
            byteSize = objectInfo.byteSize;
            if (Enum.IsDefined(typeof(ClassIDType), objectInfo.classID))
            {
                type = (ClassIDType)objectInfo.classID;
            }
            else
            {
                type = ClassIDType.UnknownType;
            }
            serializedType = objectInfo.serializedType;
            platform = assetsFile.m_TargetPlatform;
            m_Version = assetsFile.header.m_Version;
        }

        public void Reset()
        {
            Position = byteStart;
        }
    }
}

```

`AssetStudio/Progress.cs`:

```cs
using System;

namespace AssetStudio
{
    public static class Progress
    {
        public static IProgress<int> Default = new Progress<int>();
        private static int preValue;

        public static void Reset()
        {
            preValue = 0;
            Default.Report(0);
        }

        public static void Report(int current, int total)
        {
            var value = (int)(current * 100f / total);
            Report(value);
        }

        private static void Report(int value)
        {
            if (value > preValue)
            {
                preValue = value;
                Default.Report(value);
            }
        }
    }
}

```

`AssetStudio/ResourceReader.cs`:

```cs
using System.IO;

namespace AssetStudio
{
    public class ResourceReader
    {
        private bool needSearch;
        private string path;
        private SerializedFile assetsFile;
        private long offset;
        private long size;
        private BinaryReader reader;

        public int Size { get => (int)size; }

        public ResourceReader(string path, SerializedFile assetsFile, long offset, long size)
        {
            needSearch = true;
            this.path = path;
            this.assetsFile = assetsFile;
            this.offset = offset;
            this.size = size;
        }

        public ResourceReader(BinaryReader reader, long offset, long size)
        {
            this.reader = reader;
            this.offset = offset;
            this.size = size;
        }

        private BinaryReader GetReader()
        {
            if (needSearch)
            {
                var resourceFileName = Path.GetFileName(path);
                if (assetsFile.assetsManager.resourceFileReaders.TryGetValue(resourceFileName, out reader))
                {
                    needSearch = false;
                    return reader;
                }
                var assetsFileDirectory = Path.GetDirectoryName(assetsFile.fullName);
                var resourceFilePath = Path.Combine(assetsFileDirectory, resourceFileName);
                if (!File.Exists(resourceFilePath))
                {
                    var findFiles = Directory.GetFiles(assetsFileDirectory, resourceFileName, SearchOption.AllDirectories);
                    if (findFiles.Length > 0)
                    {
                        resourceFilePath = findFiles[0];
                    }
                }
                if (File.Exists(resourceFilePath))
                {
                    needSearch = false;
                    reader = new BinaryReader(File.OpenRead(resourceFilePath));
                    assetsFile.assetsManager.resourceFileReaders.Add(resourceFileName, reader);
                    return reader;
                }
                throw new FileNotFoundException($"Can't find the resource file {resourceFileName}");
            }
            else
            {
                return reader;
            }
        }

        public byte[] GetData()
        {
            var binaryReader = GetReader();
            binaryReader.BaseStream.Position = offset;
            return binaryReader.ReadBytes((int)size);
        }

        public void GetData(byte[] buff)
        {
            var binaryReader = GetReader();
            binaryReader.BaseStream.Position = offset;
            binaryReader.Read(buff, 0, (int)size);
        }

        public void WriteData(string path)
        {
            var binaryReader = GetReader();
            binaryReader.BaseStream.Position = offset;
            using (var writer = File.OpenWrite(path))
            {
                binaryReader.BaseStream.CopyTo(writer, size);
            }
        }
    }
}

```

`AssetStudio/SerializedFile.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace AssetStudio
{
    public class SerializedFile
    {
        public AssetsManager assetsManager;
        public FileReader reader;
        public string fullName;
        public string originalPath;
        public string fileName;
        public int[] version = { 0, 0, 0, 0 };
        public BuildType buildType;
        public List<Object> Objects;
        public Dictionary<long, Object> ObjectsDic;

        public SerializedFileHeader header;
        private byte m_FileEndianess;
        public string unityVersion = "2.5.0f5";
        public BuildTarget m_TargetPlatform = BuildTarget.UnknownPlatform;
        private bool m_EnableTypeTree = true;
        public List<SerializedType> m_Types;
        public int bigIDEnabled = 0;
        public List<ObjectInfo> m_Objects;
        private List<LocalSerializedObjectIdentifier> m_ScriptTypes;
        public List<FileIdentifier> m_Externals;
        public List<SerializedType> m_RefTypes;
        public string userInformation;

        public SerializedFile(FileReader reader, AssetsManager assetsManager)
        {
            this.assetsManager = assetsManager;
            this.reader = reader;
            fullName = reader.FullPath;
            fileName = reader.FileName;

            // ReadHeader
            header = new SerializedFileHeader();
            header.m_MetadataSize = reader.ReadUInt32();
            header.m_FileSize = reader.ReadUInt32();
            header.m_Version = (SerializedFileFormatVersion)reader.ReadUInt32();
            header.m_DataOffset = reader.ReadUInt32();

            if (header.m_Version >= SerializedFileFormatVersion.Unknown_9)
            {
                header.m_Endianess = reader.ReadByte();
                header.m_Reserved = reader.ReadBytes(3);
                m_FileEndianess = header.m_Endianess;
            }
            else
            {
                reader.Position = header.m_FileSize - header.m_MetadataSize;
                m_FileEndianess = reader.ReadByte();
            }

            if (header.m_Version >= SerializedFileFormatVersion.LargeFilesSupport)
            {
                header.m_MetadataSize = reader.ReadUInt32();
                header.m_FileSize = reader.ReadInt64();
                header.m_DataOffset = reader.ReadInt64();
                reader.ReadInt64(); // unknown
            }

            // ReadMetadata
            if (m_FileEndianess == 0)
            {
                reader.Endian = EndianType.LittleEndian;
            }
            if (header.m_Version >= SerializedFileFormatVersion.Unknown_7)
            {
                unityVersion = reader.ReadStringToNull();
                SetVersion(unityVersion);
            }
            if (header.m_Version >= SerializedFileFormatVersion.Unknown_8)
            {
                m_TargetPlatform = (BuildTarget)reader.ReadInt32();
                if (!Enum.IsDefined(typeof(BuildTarget), m_TargetPlatform))
                {
                    m_TargetPlatform = BuildTarget.UnknownPlatform;
                }
            }
            if (header.m_Version >= SerializedFileFormatVersion.HasTypeTreeHashes)
            {
                m_EnableTypeTree = reader.ReadBoolean();
            }

            // Read Types
            int typeCount = reader.ReadInt32();
            m_Types = new List<SerializedType>(typeCount);
            for (int i = 0; i < typeCount; i++)
            {
                m_Types.Add(ReadSerializedType(false));
            }

            if (header.m_Version >= SerializedFileFormatVersion.Unknown_7 && header.m_Version < SerializedFileFormatVersion.Unknown_14)
            {
                bigIDEnabled = reader.ReadInt32();
            }

            // Read Objects
            int objectCount = reader.ReadInt32();
            m_Objects = new List<ObjectInfo>(objectCount);
            Objects = new List<Object>(objectCount);
            ObjectsDic = new Dictionary<long, Object>(objectCount);
            for (int i = 0; i < objectCount; i++)
            {
                var objectInfo = new ObjectInfo();
                if (bigIDEnabled != 0)
                {
                    objectInfo.m_PathID = reader.ReadInt64();
                }
                else if (header.m_Version < SerializedFileFormatVersion.Unknown_14)
                {
                    objectInfo.m_PathID = reader.ReadInt32();
                }
                else
                {
                    reader.AlignStream();
                    objectInfo.m_PathID = reader.ReadInt64();
                }

                if (header.m_Version >= SerializedFileFormatVersion.LargeFilesSupport)
                    objectInfo.byteStart = reader.ReadInt64();
                else
                    objectInfo.byteStart = reader.ReadUInt32();

                objectInfo.byteStart += header.m_DataOffset;
                objectInfo.byteSize = reader.ReadUInt32();
                objectInfo.typeID = reader.ReadInt32();
                if (header.m_Version < SerializedFileFormatVersion.RefactoredClassId)
                {
                    objectInfo.classID = reader.ReadUInt16();
                    objectInfo.serializedType = m_Types.Find(x => x.classID == objectInfo.typeID);
                }
                else
                {
                    var type = m_Types[objectInfo.typeID];
                    objectInfo.serializedType = type;
                    objectInfo.classID = type.classID;
                }
                if (header.m_Version < SerializedFileFormatVersion.HasScriptTypeIndex)
                {
                    objectInfo.isDestroyed = reader.ReadUInt16();
                }
                if (header.m_Version >= SerializedFileFormatVersion.HasScriptTypeIndex && header.m_Version < SerializedFileFormatVersion.RefactorTypeData)
                {
                    var m_ScriptTypeIndex = reader.ReadInt16();
                    if (objectInfo.serializedType != null)
                        objectInfo.serializedType.m_ScriptTypeIndex = m_ScriptTypeIndex;
                }
                if (header.m_Version == SerializedFileFormatVersion.SupportsStrippedObject || header.m_Version == SerializedFileFormatVersion.RefactoredClassId)
                {
                    objectInfo.stripped = reader.ReadByte();
                }
                m_Objects.Add(objectInfo);
            }

            if (header.m_Version >= SerializedFileFormatVersion.HasScriptTypeIndex)
            {
                int scriptCount = reader.ReadInt32();
                m_ScriptTypes = new List<LocalSerializedObjectIdentifier>(scriptCount);
                for (int i = 0; i < scriptCount; i++)
                {
                    var m_ScriptType = new LocalSerializedObjectIdentifier();
                    m_ScriptType.localSerializedFileIndex = reader.ReadInt32();
                    if (header.m_Version < SerializedFileFormatVersion.Unknown_14)
                    {
                        m_ScriptType.localIdentifierInFile = reader.ReadInt32();
                    }
                    else
                    {
                        reader.AlignStream();
                        m_ScriptType.localIdentifierInFile = reader.ReadInt64();
                    }
                    m_ScriptTypes.Add(m_ScriptType);
                }
            }

            int externalsCount = reader.ReadInt32();
            m_Externals = new List<FileIdentifier>(externalsCount);
            for (int i = 0; i < externalsCount; i++)
            {
                var m_External = new FileIdentifier();
                if (header.m_Version >= SerializedFileFormatVersion.Unknown_6)
                {
                    var tempEmpty = reader.ReadStringToNull();
                }
                if (header.m_Version >= SerializedFileFormatVersion.Unknown_5)
                {
                    m_External.guid = new Guid(reader.ReadBytes(16));
                    m_External.type = reader.ReadInt32();
                }
                m_External.pathName = reader.ReadStringToNull();
                m_External.fileName = Path.GetFileName(m_External.pathName);
                m_Externals.Add(m_External);
            }

            if (header.m_Version >= SerializedFileFormatVersion.SupportsRefObject)
            {
                int refTypesCount = reader.ReadInt32();
                m_RefTypes = new List<SerializedType>(refTypesCount);
                for (int i = 0; i < refTypesCount; i++)
                {
                    m_RefTypes.Add(ReadSerializedType(true));
                }
            }

            if (header.m_Version >= SerializedFileFormatVersion.Unknown_5)
            {
                userInformation = reader.ReadStringToNull();
            }

            //reader.AlignStream(16);
        }

        public void SetVersion(string stringVersion)
        {
            if (stringVersion != strippedVersion)
            {
                unityVersion = stringVersion;
                var buildSplit = Regex.Replace(stringVersion, @"\d", "").Split(new[] { "." }, StringSplitOptions.RemoveEmptyEntries);
                buildType = new BuildType(buildSplit[0]);
                var versionSplit = Regex.Replace(stringVersion, @"\D", ".").Split(new[] { "." }, StringSplitOptions.RemoveEmptyEntries);
                version = versionSplit.Select(int.Parse).ToArray();
            }
        }

        private SerializedType ReadSerializedType(bool isRefType)
        {
            var type = new SerializedType();

            type.classID = reader.ReadInt32();

            if (header.m_Version >= SerializedFileFormatVersion.RefactoredClassId)
            {
                type.m_IsStrippedType = reader.ReadBoolean();
            }

            if (header.m_Version >= SerializedFileFormatVersion.RefactorTypeData)
            {
                type.m_ScriptTypeIndex = reader.ReadInt16();
            }

            if (header.m_Version >= SerializedFileFormatVersion.HasTypeTreeHashes)
            {
                if (isRefType && type.m_ScriptTypeIndex >= 0)
                {
                    type.m_ScriptID = reader.ReadBytes(16);
                }
                else if ((header.m_Version < SerializedFileFormatVersion.RefactoredClassId && type.classID < 0) || (header.m_Version >= SerializedFileFormatVersion.RefactoredClassId && type.classID == 114))
                {
                    type.m_ScriptID = reader.ReadBytes(16);
                }
                type.m_OldTypeHash = reader.ReadBytes(16);
            }

            if (m_EnableTypeTree)
            {
                type.m_Type = new TypeTree();
                type.m_Type.m_Nodes = new List<TypeTreeNode>();
                if (header.m_Version >= SerializedFileFormatVersion.Unknown_12 || header.m_Version == SerializedFileFormatVersion.Unknown_10)
                {
                    TypeTreeBlobRead(type.m_Type);
                }
                else
                {
                    ReadTypeTree(type.m_Type);
                }
                if (header.m_Version >= SerializedFileFormatVersion.StoresTypeDependencies)
                {
                    if (isRefType)
                    {
                        type.m_KlassName = reader.ReadStringToNull();
                        type.m_NameSpace = reader.ReadStringToNull();
                        type.m_AsmName = reader.ReadStringToNull();
                    }
                    else
                    {
                        type.m_TypeDependencies = reader.ReadInt32Array();
                    }
                }
            }

            return type;
        }

        private void ReadTypeTree(TypeTree m_Type, int level = 0)
        {
            var typeTreeNode = new TypeTreeNode();
            m_Type.m_Nodes.Add(typeTreeNode);
            typeTreeNode.m_Level = level;
            typeTreeNode.m_Type = reader.ReadStringToNull();
            typeTreeNode.m_Name = reader.ReadStringToNull();
            typeTreeNode.m_ByteSize = reader.ReadInt32();
            if (header.m_Version == SerializedFileFormatVersion.Unknown_2)
            {
                var variableCount = reader.ReadInt32();
            }
            if (header.m_Version != SerializedFileFormatVersion.Unknown_3)
            {
                typeTreeNode.m_Index = reader.ReadInt32();
            }
            typeTreeNode.m_TypeFlags = reader.ReadInt32();
            typeTreeNode.m_Version = reader.ReadInt32();
            if (header.m_Version != SerializedFileFormatVersion.Unknown_3)
            {
                typeTreeNode.m_MetaFlag = reader.ReadInt32();
            }

            int childrenCount = reader.ReadInt32();
            for (int i = 0; i < childrenCount; i++)
            {
                ReadTypeTree(m_Type, level + 1);
            }
        }

        private void TypeTreeBlobRead(TypeTree m_Type)
        {
            int numberOfNodes = reader.ReadInt32();
            int stringBufferSize = reader.ReadInt32();
            for (int i = 0; i < numberOfNodes; i++)
            {
                var typeTreeNode = new TypeTreeNode();
                m_Type.m_Nodes.Add(typeTreeNode);
                typeTreeNode.m_Version = reader.ReadUInt16();
                typeTreeNode.m_Level = reader.ReadByte();
                typeTreeNode.m_TypeFlags = reader.ReadByte();
                typeTreeNode.m_TypeStrOffset = reader.ReadUInt32();
                typeTreeNode.m_NameStrOffset = reader.ReadUInt32();
                typeTreeNode.m_ByteSize = reader.ReadInt32();
                typeTreeNode.m_Index = reader.ReadInt32();
                typeTreeNode.m_MetaFlag = reader.ReadInt32();
                if (header.m_Version >= SerializedFileFormatVersion.TypeTreeNodeWithTypeFlags)
                {
                    typeTreeNode.m_RefTypeHash = reader.ReadUInt64();
                }
            }
            m_Type.m_StringBuffer = reader.ReadBytes(stringBufferSize);

            using (var stringBufferReader = new BinaryReader(new MemoryStream(m_Type.m_StringBuffer)))
            {
                for (int i = 0; i < numberOfNodes; i++)
                {
                    var m_Node = m_Type.m_Nodes[i];
                    m_Node.m_Type = ReadString(stringBufferReader, m_Node.m_TypeStrOffset);
                    m_Node.m_Name = ReadString(stringBufferReader, m_Node.m_NameStrOffset);
                }
            }

            string ReadString(BinaryReader stringBufferReader, uint value)
            {
                var isOffset = (value & 0x80000000) == 0;
                if (isOffset)
                {
                    stringBufferReader.BaseStream.Position = value;
                    return stringBufferReader.ReadStringToNull();
                }
                var offset = value & 0x7FFFFFFF;
                if (CommonString.StringBuffer.TryGetValue(offset, out var str))
                {
                    return str;
                }
                return offset.ToString();
            }
        }

        public void AddObject(Object obj)
        {
            Objects.Add(obj);
            ObjectsDic.Add(obj.m_PathID, obj);
        }

        public bool IsVersionStripped => unityVersion == strippedVersion;

        private const string strippedVersion = "0.0.0";
    }
}

```

`AssetStudio/SerializedFileFormatVersion.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AssetStudio
{
    public enum SerializedFileFormatVersion
    {
        Unsupported = 1,
        Unknown_2 = 2,
        Unknown_3 = 3,
        /// <summary>
        /// 1.2.0 to 2.0.0
        /// </summary>
        Unknown_5 = 5,
        /// <summary>
        /// 2.1.0 to 2.6.1
        /// </summary>
        Unknown_6 = 6,
        /// <summary>
        /// 3.0.0b
        /// </summary>
        Unknown_7 = 7,
        /// <summary>
        /// 3.0.0 to 3.4.2
        /// </summary>
        Unknown_8 = 8,
        /// <summary>
        /// 3.5.0 to 4.7.2
        /// </summary>
        Unknown_9 = 9,
        /// <summary>
        /// 5.0.0aunk1
        /// </summary>
        Unknown_10 = 10,
        /// <summary>
        /// 5.0.0aunk2
        /// </summary>
        HasScriptTypeIndex = 11,
        /// <summary>
        /// 5.0.0aunk3
        /// </summary>
        Unknown_12 = 12,
        /// <summary>
        /// 5.0.0aunk4
        /// </summary>
        HasTypeTreeHashes = 13,
        /// <summary>
        /// 5.0.0unk
        /// </summary>
        Unknown_14 = 14,
        /// <summary>
        /// 5.0.1 to 5.4.0
        /// </summary>
        SupportsStrippedObject = 15,
        /// <summary>
        /// 5.5.0a
        /// </summary>
        RefactoredClassId = 16,
        /// <summary>
        /// 5.5.0unk to 2018.4
        /// </summary>
        RefactorTypeData = 17,
        /// <summary>
        /// 2019.1a
        /// </summary>
        RefactorShareableTypeTreeData = 18,
        /// <summary>
        /// 2019.1unk
        /// </summary>
        TypeTreeNodeWithTypeFlags = 19,
        /// <summary>
        /// 2019.2
        /// </summary>
        SupportsRefObject = 20,
        /// <summary>
        /// 2019.3 to 2019.4
        /// </summary>
        StoresTypeDependencies = 21,
        /// <summary>
        /// 2020.1 to x
        /// </summary>
        LargeFilesSupport = 22
    }
}

```

`AssetStudio/SerializedFileHeader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class SerializedFileHeader
    {
        public uint m_MetadataSize;
        public long m_FileSize;
        public SerializedFileFormatVersion m_Version;
        public long m_DataOffset;
        public byte m_Endianess;
        public byte[] m_Reserved;
    }
}

```

`AssetStudio/SerializedType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class SerializedType
    {
        public int classID;
        public bool m_IsStrippedType;
        public short m_ScriptTypeIndex = -1;
        public TypeTree m_Type;
        public byte[] m_ScriptID; //Hash128
        public byte[] m_OldTypeHash; //Hash128
        public int[] m_TypeDependencies;
        public string m_KlassName;
        public string m_NameSpace;
        public string m_AsmName;
    }
}

```

`AssetStudio/SevenZipHelper.cs`:

```cs
using System;
using System.IO;
using SevenZip.Compression.LZMA;


namespace AssetStudio
{
    public static class SevenZipHelper
    {
        public static MemoryStream StreamDecompress(MemoryStream inStream)
        {
            var decoder = new Decoder();

            inStream.Seek(0, SeekOrigin.Begin);
            var newOutStream = new MemoryStream();

            var properties = new byte[5];
            if (inStream.Read(properties, 0, 5) != 5)
                throw new Exception("input .lzma is too short");
            long outSize = 0;
            for (var i = 0; i < 8; i++)
            {
                var v = inStream.ReadByte();
                if (v < 0)
                    throw new Exception("Can't Read 1");
                outSize |= ((long)(byte)v) << (8 * i);
            }
            decoder.SetDecoderProperties(properties);

            var compressedSize = inStream.Length - inStream.Position;
            decoder.Code(inStream, newOutStream, compressedSize, outSize, null);

            newOutStream.Position = 0;
            return newOutStream;
        }

        public static void StreamDecompress(Stream compressedStream, Stream decompressedStream, long compressedSize, long decompressedSize)
        {
            var basePosition = compressedStream.Position;
            var decoder = new Decoder();
            var properties = new byte[5];
            if (compressedStream.Read(properties, 0, 5) != 5)
                throw new Exception("input .lzma is too short");
            decoder.SetDecoderProperties(properties);
            decoder.Code(compressedStream, decompressedStream, compressedSize - 5, decompressedSize, null);
            compressedStream.Position = basePosition + compressedSize;
        }
    }
}

```

`AssetStudio/StreamFile.cs`:

```cs
using System.IO;

namespace AssetStudio
{
    public class StreamFile
    {
        public string path;
        public string fileName;
        public Stream stream;
    }
}

```

`AssetStudio/TypeTree.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AssetStudio
{
    public class TypeTree
    {
        public List<TypeTreeNode> m_Nodes;
        public byte[] m_StringBuffer;
    }
}

```

`AssetStudio/TypeTreeHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Text;

namespace AssetStudio
{
    public static class TypeTreeHelper
    {
        public static string ReadTypeString(TypeTree m_Type, ObjectReader reader)
        {
            reader.Reset();
            var sb = new StringBuilder();
            var m_Nodes = m_Type.m_Nodes;
            for (int i = 0; i < m_Nodes.Count; i++)
            {
                ReadStringValue(sb, m_Nodes, reader, ref i);
            }
            var readed = reader.Position - reader.byteStart;
            if (readed != reader.byteSize)
            {
                Logger.Info($"Error while read type, read {readed} bytes but expected {reader.byteSize} bytes");
            }
            return sb.ToString();
        }

        private static void ReadStringValue(StringBuilder sb, List<TypeTreeNode> m_Nodes, BinaryReader reader, ref int i)
        {
            var m_Node = m_Nodes[i];
            var level = m_Node.m_Level;
            var varTypeStr = m_Node.m_Type;
            var varNameStr = m_Node.m_Name;
            object value = null;
            var append = true;
            var align = (m_Node.m_MetaFlag & 0x4000) != 0;
            switch (varTypeStr)
            {
                case "SInt8":
                    value = reader.ReadSByte();
                    break;
                case "UInt8":
                    value = reader.ReadByte();
                    break;
                case "char":
                    value = BitConverter.ToChar(reader.ReadBytes(2), 0);
                    break;
                case "short":
                case "SInt16":
                    value = reader.ReadInt16();
                    break;
                case "UInt16":
                case "unsigned short":
                    value = reader.ReadUInt16();
                    break;
                case "int":
                case "SInt32":
                    value = reader.ReadInt32();
                    break;
                case "UInt32":
                case "unsigned int":
                case "Type*":
                    value = reader.ReadUInt32();
                    break;
                case "long long":
                case "SInt64":
                    value = reader.ReadInt64();
                    break;
                case "UInt64":
                case "unsigned long long":
                case "FileSize":
                    value = reader.ReadUInt64();
                    break;
                case "float":
                    value = reader.ReadSingle();
                    break;
                case "double":
                    value = reader.ReadDouble();
                    break;
                case "bool":
                    value = reader.ReadBoolean();
                    break;
                case "string":
                    append = false;
                    var str = reader.ReadAlignedString();
                    sb.AppendFormat("{0}{1} {2} = \"{3}\"\r\n", (new string('\t', level)), varTypeStr, varNameStr, str);
                    var toSkip = GetNodes(m_Nodes, i);
                    i += toSkip.Count - 1;
                    break;
                case "map":
                    {
                        if ((m_Nodes[i + 1].m_MetaFlag & 0x4000) != 0)
                            align = true;
                        append = false;
                        sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level)), varTypeStr, varNameStr);
                        sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level + 1)), "Array", "Array");
                        var size = reader.ReadInt32();
                        sb.AppendFormat("{0}{1} {2} = {3}\r\n", (new string('\t', level + 1)), "int", "size", size);
                        var map = GetNodes(m_Nodes, i);
                        i += map.Count - 1;
                        var first = GetNodes(map, 4);
                        var next = 4 + first.Count;
                        var second = GetNodes(map, next);
                        for (int j = 0; j < size; j++)
                        {
                            sb.AppendFormat("{0}[{1}]\r\n", (new string('\t', level + 2)), j);
                            sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level + 2)), "pair", "data");
                            int tmp1 = 0;
                            int tmp2 = 0;
                            ReadStringValue(sb, first, reader, ref tmp1);
                            ReadStringValue(sb, second, reader, ref tmp2);
                        }
                        break;
                    }
                case "TypelessData":
                    {
                        append = false;
                        var size = reader.ReadInt32();
                        reader.ReadBytes(size);
                        i += 2;
                        sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level)), varTypeStr, varNameStr);
                        sb.AppendFormat("{0}{1} {2} = {3}\r\n", (new string('\t', level)), "int", "size", size);
                        break;
                    }
                default:
                    {
                        if (i < m_Nodes.Count - 1 && m_Nodes[i + 1].m_Type == "Array") //Array
                        {
                            if ((m_Nodes[i + 1].m_MetaFlag & 0x4000) != 0)
                                align = true;
                            append = false;
                            sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level)), varTypeStr, varNameStr);
                            sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level + 1)), "Array", "Array");
                            var size = reader.ReadInt32();
                            sb.AppendFormat("{0}{1} {2} = {3}\r\n", (new string('\t', level + 1)), "int", "size", size);
                            var vector = GetNodes(m_Nodes, i);
                            i += vector.Count - 1;
                            for (int j = 0; j < size; j++)
                            {
                                sb.AppendFormat("{0}[{1}]\r\n", (new string('\t', level + 2)), j);
                                int tmp = 3;
                                ReadStringValue(sb, vector, reader, ref tmp);
                            }
                            break;
                        }
                        else //Class
                        {
                            append = false;
                            sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level)), varTypeStr, varNameStr);
                            var @class = GetNodes(m_Nodes, i);
                            i += @class.Count - 1;
                            for (int j = 1; j < @class.Count; j++)
                            {
                                ReadStringValue(sb, @class, reader, ref j);
                            }
                            break;
                        }
                    }
            }
            if (append)
                sb.AppendFormat("{0}{1} {2} = {3}\r\n", (new string('\t', level)), varTypeStr, varNameStr, value);
            if (align)
                reader.AlignStream();
        }

        public static OrderedDictionary ReadType(TypeTree m_Types, ObjectReader reader)
        {
            reader.Reset();
            var obj = new OrderedDictionary();
            var m_Nodes = m_Types.m_Nodes;
            for (int i = 1; i < m_Nodes.Count; i++)
            {
                var m_Node = m_Nodes[i];
                var varNameStr = m_Node.m_Name;
                obj[varNameStr] = ReadValue(m_Nodes, reader, ref i);
            }
            var readed = reader.Position - reader.byteStart;
            if (readed != reader.byteSize)
            {
                Logger.Info($"Error while read type, read {readed} bytes but expected {reader.byteSize} bytes");
            }
            return obj;
        }

        private static object ReadValue(List<TypeTreeNode> m_Nodes, BinaryReader reader, ref int i)
        {
            var m_Node = m_Nodes[i];
            var varTypeStr = m_Node.m_Type;
            object value;
            var align = (m_Node.m_MetaFlag & 0x4000) != 0;
            switch (varTypeStr)
            {
                case "SInt8":
                    value = reader.ReadSByte();
                    break;
                case "UInt8":
                    value = reader.ReadByte();
                    break;
                case "char":
                    value = BitConverter.ToChar(reader.ReadBytes(2), 0);
                    break;
                case "short":
                case "SInt16":
                    value = reader.ReadInt16();
                    break;
                case "UInt16":
                case "unsigned short":
                    value = reader.ReadUInt16();
                    break;
                case "int":
                case "SInt32":
                    value = reader.ReadInt32();
                    break;
                case "UInt32":
                case "unsigned int":
                case "Type*":
                    value = reader.ReadUInt32();
                    break;
                case "long long":
                case "SInt64":
                    value = reader.ReadInt64();
                    break;
                case "UInt64":
                case "unsigned long long":
                case "FileSize":
                    value = reader.ReadUInt64();
                    break;
                case "float":
                    value = reader.ReadSingle();
                    break;
                case "double":
                    value = reader.ReadDouble();
                    break;
                case "bool":
                    value = reader.ReadBoolean();
                    break;
                case "string":
                    value = reader.ReadAlignedString();
                    var toSkip = GetNodes(m_Nodes, i);
                    i += toSkip.Count - 1;
                    break;
                case "map":
                    {
                        if ((m_Nodes[i + 1].m_MetaFlag & 0x4000) != 0)
                            align = true;
                        var map = GetNodes(m_Nodes, i);
                        i += map.Count - 1;
                        var first = GetNodes(map, 4);
                        var next = 4 + first.Count;
                        var second = GetNodes(map, next);
                        var size = reader.ReadInt32();
                        var dic = new List<KeyValuePair<object, object>>(size);
                        for (int j = 0; j < size; j++)
                        {
                            int tmp1 = 0;
                            int tmp2 = 0;
                            dic.Add(new KeyValuePair<object, object>(ReadValue(first, reader, ref tmp1), ReadValue(second, reader, ref tmp2)));
                        }
                        value = dic;
                        break;
                    }
                case "TypelessData":
                    {
                        var size = reader.ReadInt32();
                        value = reader.ReadBytes(size);
                        i += 2;
                        break;
                    }
                default:
                    {
                        if (i < m_Nodes.Count - 1 && m_Nodes[i + 1].m_Type == "Array") //Array
                        {
                            if ((m_Nodes[i + 1].m_MetaFlag & 0x4000) != 0)
                                align = true;
                            var vector = GetNodes(m_Nodes, i);
                            i += vector.Count - 1;
                            var size = reader.ReadInt32();
                            var list = new List<object>(size);
                            for (int j = 0; j < size; j++)
                            {
                                int tmp = 3;
                                list.Add(ReadValue(vector, reader, ref tmp));
                            }
                            value = list;
                            break;
                        }
                        else //Class
                        {
                            var @class = GetNodes(m_Nodes, i);
                            i += @class.Count - 1;
                            var obj = new OrderedDictionary();
                            for (int j = 1; j < @class.Count; j++)
                            {
                                var classmember = @class[j];
                                var name = classmember.m_Name;
                                obj[name] = ReadValue(@class, reader, ref j);
                            }
                            value = obj;
                            break;
                        }
                    }
            }
            if (align)
                reader.AlignStream();
            return value;
        }

        private static List<TypeTreeNode> GetNodes(List<TypeTreeNode> m_Nodes, int index)
        {
            var nodes = new List<TypeTreeNode>();
            nodes.Add(m_Nodes[index]);
            var level = m_Nodes[index].m_Level;
            for (int i = index + 1; i < m_Nodes.Count; i++)
            {
                var member = m_Nodes[i];
                var level2 = member.m_Level;
                if (level2 <= level)
                {
                    return nodes;
                }
                nodes.Add(member);
            }
            return nodes;
        }
    }
}

```

`AssetStudio/TypeTreeNode.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class TypeTreeNode
    {
        public string m_Type;
        public string m_Name;
        public int m_ByteSize;
        public int m_Index;
        public int m_TypeFlags; //m_IsArray
        public int m_Version;
        public int m_MetaFlag;
        public int m_Level;
        public uint m_TypeStrOffset;
        public uint m_NameStrOffset;
        public ulong m_RefTypeHash;

        public TypeTreeNode() { }

        public TypeTreeNode(string type, string name, int level, bool align)
        {
            m_Type = type;
            m_Name = name;
            m_Level = level;
            m_MetaFlag = align ? 0x4000 : 0;
        }
    }
}

```

`AssetStudio/WebFile.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace AssetStudio
{
    public class WebFile
    {
        public StreamFile[] fileList;

        private class WebData
        {
            public int dataOffset;
            public int dataLength;
            public string path;
        }

        public WebFile(EndianBinaryReader reader)
        {
            reader.Endian = EndianType.LittleEndian;
            var signature = reader.ReadStringToNull();
            var headLength = reader.ReadInt32();
            var dataList = new List<WebData>();
            while (reader.BaseStream.Position < headLength)
            {
                var data = new WebData();
                data.dataOffset = reader.ReadInt32();
                data.dataLength = reader.ReadInt32();
                var pathLength = reader.ReadInt32();
                data.path = Encoding.UTF8.GetString(reader.ReadBytes(pathLength));
                dataList.Add(data);
            }
            fileList = new StreamFile[dataList.Count];
            for (int i = 0; i < dataList.Count; i++)
            {
                var data = dataList[i];
                var file = new StreamFile();
                file.path = data.path;
                file.fileName = Path.GetFileName(data.path);
                reader.BaseStream.Position = data.dataOffset;
                file.stream = new MemoryStream(reader.ReadBytes(data.dataLength));
                fileList[i] = file;
            }
        }
    }
}

```

`AssetStudioFBXNative/AssetStudioFBXNative.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Language neutral resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEU)
LANGUAGE LANG_ENGLISH, SUBLANG_NEUTRAL
#pragma code_page(65001)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
            VALUE "FileDescription", "AssetStudioFBXNative"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "InternalName", "AssetStudioFBXNative.dll"
            VALUE "LegalCopyright", "Copyright (C) Perfare 2018-2020; Copyright (C) hozuki 2020"
            VALUE "OriginalFilename", "AssetStudioFBXNative.dll"
            VALUE "ProductName", "AssetStudioFBXNative"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END

#endif    // Language neutral resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`AssetStudioFBXNative/AssetStudioFBXNative.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{11ea25a3-ed68-40ee-a9d0-7fde3b583027}</ProjectGuid>
    <RootNamespace>AssetStudioFBXNative</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <TargetExt>.dll</TargetExt>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dll</TargetExt>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetExt>.dll</TargetExt>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dll</TargetExt>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_AS_DLL;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>C:\Program Files\Autodesk\FBX\FBX SDK\2020.2.1\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>libfbxsdk-mt.lib;libxml2-mt.lib;zlib-mt.lib;wininet.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>C:\Program Files\Autodesk\FBX\FBX SDK\2020.2.1\lib\vs2019\x86\debug;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>LIBCMT;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_AS_DLL;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>C:\Program Files\Autodesk\FBX\FBX SDK\2020.2.1\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>libfbxsdk-mt.lib;libxml2-mt.lib;zlib-mt.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>C:\Program Files\Autodesk\FBX\FBX SDK\2020.2.1\lib\vs2019\x86\release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_AS_DLL;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>C:\Program Files\Autodesk\FBX\FBX SDK\2020.2.1\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>libfbxsdk-mt.lib;libxml2-mt.lib;zlib-mt.lib;wininet.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>C:\Program Files\Autodesk\FBX\FBX SDK\2020.2.1\lib\vs2019\x64\debug;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <IgnoreSpecificDefaultLibraries>LIBCMT;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_AS_DLL;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>C:\Program Files\Autodesk\FBX\FBX SDK\2020.2.1\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>libfbxsdk-mt.lib;libxml2-mt.lib;zlib-mt.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>C:\Program Files\Autodesk\FBX\FBX SDK\2020.2.1\lib\vs2019\x64\release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="asfbx_anim_context.cpp" />
    <ClCompile Include="asfbx_context.cpp" />
    <ClCompile Include="api.cpp" />
    <ClCompile Include="asfbx_morph_context.cpp" />
    <ClCompile Include="asfbx_skin_context.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="api.h" />
    <ClInclude Include="asfbx_anim_context.h" />
    <ClInclude Include="asfbx_context.h" />
    <ClInclude Include="asfbx_morph_context.h" />
    <ClInclude Include="asfbx_skin_context.h" />
    <ClInclude Include="bool32_t.h" />
    <ClInclude Include="dllexport.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="cpp.hint" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="AssetStudioFBXNative.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
  <Target Name="AfterBuild">
    <MSBuild Condition=" '$(Platform)' == 'Win32' " Projects="$(MSBuildProjectFile)" Properties="Platform=x64;PlatFormTarget=x64" RunEachTargetSeparately="true" />
  </Target>
</Project>
```

`AssetStudioFBXNative/AssetStudioFBXNative.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="utils.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="api.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="asfbx_context.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="asfbx_skin_context.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="asfbx_anim_context.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="asfbx_morph_context.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="dllexport.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="api.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="bool32_t.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="asfbx_context.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="asfbx_skin_context.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="asfbx_anim_context.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="asfbx_morph_context.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="cpp.hint" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="AssetStudioFBXNative.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`AssetStudioFBXNative/api.cpp`:

```cpp
#include <fbxsdk.h>

#include "dllexport.h"
#include "bool32_t.h"
#include "asfbx_context.h"
#include "asfbx_skin_context.h"
#include "asfbx_anim_context.h"
#include "asfbx_morph_context.h"
#include "utils.h"

using namespace fbxsdk;

AS_API(void) AsUtilQuaternionToEuler(float qx, float qy, float qz, float qw, float* vx, float* vy, float* vz)
{
	Quaternion q(qx, qy, qz, qw);

	auto v = QuaternionToEuler(q);

	if (vx)
	{
		*vx = v.X;
	}

	if (vy)
	{
		*vy = v.Y;
	}

	if (vz)
	{
		*vz = v.Z;
	}
}

AS_API(void) AsUtilEulerToQuaternion(float vx, float vy, float vz, float* qx, float* qy, float* qz, float* qw)
{
	Vector3 v(vx, vy, vz);

	auto q = EulerToQuaternion(v);

	if (qx)
	{
		*qx = q.X;
	}

	if (qy)
	{
		*qy = q.Y;
	}

	if (qz)
	{
		*qz = q.Z;
	}

	if (qw)
	{
		*qw = q.W;
	}
}

#define MGR_IOS_REF (*(pSdkManager->GetIOSettings()))

static const char* FBXVersion[] =
{
	FBX_2010_00_COMPATIBLE,
	FBX_2011_00_COMPATIBLE,
	FBX_2012_00_COMPATIBLE,
	FBX_2013_00_COMPATIBLE,
	FBX_2014_00_COMPATIBLE,
	FBX_2016_00_COMPATIBLE
};

AS_API(AsFbxContext*) AsFbxCreateContext()
{
	return new AsFbxContext();
}

AS_API(bool32_t) AsFbxInitializeContext(AsFbxContext* pContext, const char* pFileName, float scaleFactor, int32_t versionIndex, bool32_t isAscii, bool32_t is60Fps, const char** pErrMsg) {
	if (pContext == nullptr)
	{
		if (pErrMsg != nullptr)
		{
			*pErrMsg = "null pointer for pContext";
		}

		return false;
	}

	auto pSdkManager = FbxManager::Create();
	pContext->pSdkManager = pSdkManager;

	FbxIOSettings* ios = FbxIOSettings::Create(pSdkManager, IOSROOT);
	pSdkManager->SetIOSettings(ios);

	auto pScene = FbxScene::Create(pSdkManager, "");
	pContext->pScene = pScene;

	MGR_IOS_REF.SetBoolProp(EXP_FBX_MATERIAL, true);
	MGR_IOS_REF.SetBoolProp(EXP_FBX_TEXTURE, true);
	MGR_IOS_REF.SetBoolProp(EXP_FBX_EMBEDDED, false);
	MGR_IOS_REF.SetBoolProp(EXP_FBX_SHAPE, true);
	MGR_IOS_REF.SetBoolProp(EXP_FBX_GOBO, true);
	MGR_IOS_REF.SetBoolProp(EXP_FBX_ANIMATION, true);
	MGR_IOS_REF.SetBoolProp(EXP_FBX_GLOBAL_SETTINGS, true);

	FbxGlobalSettings& globalSettings = pScene->GetGlobalSettings();
	globalSettings.SetSystemUnit(FbxSystemUnit(scaleFactor));

	if (is60Fps)
	{
		globalSettings.SetTimeMode(FbxTime::eFrames60);
	}

	auto pExporter = FbxExporter::Create(pScene, "");
	pContext->pExporter = pExporter;

	int pFileFormat = 0;

	if (versionIndex == 0)
	{
		pFileFormat = 3;

		if (isAscii)
		{
			pFileFormat = 4;
		}
	}
	else
	{
		pExporter->SetFileExportVersion(FBXVersion[versionIndex]);

		if (isAscii)
		{
			pFileFormat = 1;
		}
	}

	if (!pExporter->Initialize(pFileName, pFileFormat, pSdkManager->GetIOSettings()))
	{
		if (pErrMsg != nullptr)
		{
			auto errStr = pExporter->GetStatus().GetErrorString();
			*pErrMsg = errStr;
		}

		return false;
	}

	auto pBindPose = FbxPose::Create(pScene, "BindPose");
	pContext->pBindPose = pBindPose;

	pScene->AddPose(pBindPose);

	return true;
}

AS_API(void) AsFbxDisposeContext(AsFbxContext** ppContext)
{
	if (ppContext == nullptr) {
		return;
	}

	delete (*ppContext);
	*ppContext = nullptr;
}

AS_API(void) AsFbxSetFramePaths(AsFbxContext* pContext, const char* ppPaths[], int32_t count)
{
	if (pContext == nullptr) {
		return;
	}

	auto& framePaths = pContext->framePaths;

	for (auto i = 0; i < count; i += 1)
	{
		const char* path = ppPaths[i];
		framePaths.insert(std::string(path));
	}
}

AS_API(void) AsFbxExportScene(AsFbxContext* pContext)
{
	if (pContext == nullptr)
	{
		return;
	}

	auto pScene = pContext->pScene;
	auto pExporter = pContext->pExporter;

	if (pExporter != nullptr && pScene != nullptr)
	{
		pExporter->Export(pScene);
	}
}

AS_API(FbxNode*) AsFbxGetSceneRootNode(AsFbxContext* pContext)
{
	if (pContext == nullptr)
	{
		return nullptr;
	}

	if (pContext->pScene == nullptr)
	{
		return nullptr;
	}

	return pContext->pScene->GetRootNode();
}

AS_API(FbxNode*) AsFbxExportSingleFrame(AsFbxContext* pContext, FbxNode* pParentNode, const char* pFramePath, const char* pFrameName, float localPositionX, float localPositionY, float localPositionZ, float localRotationX, float localRotationY, float localRotationZ, float localScaleX, float localScaleY, float localScaleZ)
{
	if (pContext == nullptr || pContext->pScene == nullptr)
	{
		return nullptr;
	}

	const auto& framePaths = pContext->framePaths;

	if (!(framePaths.empty() || framePaths.find(pFramePath) != framePaths.end()))
	{
		return nullptr;
	}

	auto pFrameNode = FbxNode::Create(pContext->pScene, pFrameName);

	pFrameNode->LclScaling.Set(FbxDouble3(localScaleX, localScaleY, localScaleZ));
	pFrameNode->LclRotation.Set(FbxDouble3(localRotationX, localRotationY, localRotationZ));
	pFrameNode->LclTranslation.Set(FbxDouble3(localPositionX, localPositionY, localPositionZ));
	pFrameNode->SetPreferedAngle(pFrameNode->LclRotation.Get());

	pParentNode->AddChild(pFrameNode);

	if (pContext->pBindPose != nullptr)
	{
		pContext->pBindPose->Add(pFrameNode, pFrameNode->EvaluateGlobalTransform());
	}

	return pFrameNode;
}

AS_API(void) AsFbxSetJointsNode_CastToBone(AsFbxContext* pContext, FbxNode* pNode, float boneSize)
{
	if (pContext == nullptr || pContext->pScene == nullptr)
	{
		return;
	}

	if (pNode == nullptr)
	{
		return;
	}

	FbxSkeleton* pJoint = FbxSkeleton::Create(pContext->pScene, "");
	pJoint->Size.Set(FbxDouble(boneSize));
	pJoint->SetSkeletonType(FbxSkeleton::eLimbNode);
	pNode->SetNodeAttribute(pJoint);
}

AS_API(void) AsFbxSetJointsNode_BoneInPath(AsFbxContext* pContext, FbxNode* pNode, float boneSize)
{
	if (pContext == nullptr || pContext->pScene == nullptr)
	{
		return;
	}

	if (pNode == nullptr)
	{
		return;
	}

	FbxSkeleton* pJoint = FbxSkeleton::Create(pContext->pScene, "");
	pJoint->Size.Set(FbxDouble(boneSize));
	pJoint->SetSkeletonType(FbxSkeleton::eLimbNode);
	pNode->SetNodeAttribute(pJoint);

	pJoint = FbxSkeleton::Create(pContext->pScene, "");
	pJoint->Size.Set(FbxDouble(boneSize));
	pJoint->SetSkeletonType(FbxSkeleton::eLimbNode);
	pNode->GetParent()->SetNodeAttribute(pJoint);
}

AS_API(void) AsFbxSetJointsNode_Generic(AsFbxContext* pContext, FbxNode* pNode)
{
	if (pContext == nullptr || pContext->pScene == nullptr)
	{
		return;
	}

	if (pNode == nullptr)
	{
		return;
	}

	FbxNull* pNull = FbxNull::Create(pContext->pScene, "");

	if (pNode->GetChildCount() > 0)
	{
		pNull->Look.Set(FbxNull::eNone);
	}

	pNode->SetNodeAttribute(pNull);
}

AS_API(void) AsFbxPrepareMaterials(AsFbxContext* pContext, int32_t materialCount, int32_t textureCount)
{
	if (pContext == nullptr)
	{
		return;
	}

	pContext->pMaterials = new FbxArray<FbxSurfacePhong*>();
	pContext->pTextures = new FbxArray<FbxFileTexture*>();

	pContext->pMaterials->Reserve(materialCount);
	pContext->pTextures->Reserve(textureCount);
}

AS_API(FbxFileTexture*) AsFbxCreateTexture(AsFbxContext* pContext, const char* pMatTexName)
{
	if (pContext == nullptr || pContext->pScene == nullptr)
	{
		return nullptr;
	}

	auto pTex = FbxFileTexture::Create(pContext->pScene, pMatTexName);
	pTex->SetFileName(pMatTexName);
	pTex->SetTextureUse(FbxTexture::eStandard);
	pTex->SetMappingType(FbxTexture::eUV);
	pTex->SetMaterialUse(FbxFileTexture::eModelMaterial);
	pTex->SetSwapUV(false);
	pTex->SetTranslation(0.0, 0.0);
	pTex->SetScale(1.0, 1.0);
	pTex->SetRotation(0.0, 0.0);

	if (pContext->pTextures != nullptr)
	{
		pContext->pTextures->Add(pTex);
	}

	return pTex;
}

AS_API(void) AsFbxLinkTexture(int32_t dest, FbxFileTexture* pTexture, FbxSurfacePhong* pMaterial, float offsetX, float offsetY, float scaleX, float scaleY)
{
	if (pTexture == nullptr || pMaterial == nullptr)
	{
		return;
	}

	pTexture->SetTranslation(offsetX, offsetY);
	pTexture->SetScale(scaleX, scaleY);

	FbxProperty* pProp;

	switch (dest)
	{
	case 0:
		pProp = &pMaterial->Diffuse;
		break;
	case 1:
		pProp = &pMaterial->NormalMap;
		break;
	case 2:
		pProp = &pMaterial->Specular;
		break;
	case 3:
		pProp = &pMaterial->Bump;
		break;
	default:
		pProp = nullptr;
		break;
	}

	if (pProp != nullptr) {
		pProp->ConnectSrcObject(pTexture);
	}
}

AS_API(FbxArray<FbxCluster*>*) AsFbxMeshCreateClusterArray(int32_t boneCount)
{
	return new FbxArray<FbxCluster*>(boneCount);
}

AS_API(void) AsFbxMeshDisposeClusterArray(FbxArray<FbxCluster*>** ppArray)
{
	if (ppArray == nullptr) {
		return;
	}

	delete (*ppArray);
	*ppArray = nullptr;
}

AS_API(FbxCluster*) AsFbxMeshCreateCluster(AsFbxContext* pContext, FbxNode* pBoneNode)
{
	if (pContext == nullptr || pContext->pScene == nullptr) {
		return nullptr;
	}

	if (pBoneNode == nullptr) {
		return nullptr;
	}

	FbxString lClusterName = pBoneNode->GetNameOnly() + FbxString("Cluster");
	FbxCluster* pCluster = FbxCluster::Create(pContext->pScene, lClusterName.Buffer());
	pCluster->SetLink(pBoneNode);
	pCluster->SetLinkMode(FbxCluster::eTotalOne);

	return pCluster;
}

AS_API(void) AsFbxMeshAddCluster(FbxArray<FbxCluster*>* pArray, FbxCluster* pCluster)
{
	if (pArray == nullptr) {
		return;
	}

	pArray->Add(pCluster);
}

AS_API(FbxMesh*) AsFbxMeshCreateMesh(AsFbxContext* pContext, FbxNode* pFrameNode)
{
	if (pContext == nullptr || pContext->pScene == nullptr)
	{
		return nullptr;
	}

	if (pFrameNode == nullptr)
	{
		return nullptr;
	}

	FbxMesh* pMesh = FbxMesh::Create(pContext->pScene, pFrameNode->GetName());
	pFrameNode->SetNodeAttribute(pMesh);

	return pMesh;
}

AS_API(void) AsFbxMeshInitControlPoints(FbxMesh* pMesh, int32_t vertexCount)
{
	if (pMesh == nullptr)
	{
		return;
	}

	pMesh->InitControlPoints(vertexCount);
}

AS_API(void) AsFbxMeshCreateElementNormal(FbxMesh* pMesh)
{
	if (pMesh == nullptr)
	{
		return;
	}

	auto pNormal = pMesh->CreateElementNormal();
	pNormal->SetMappingMode(FbxGeometryElement::eByControlPoint);
	pNormal->SetReferenceMode(FbxGeometryElement::eDirect);
}

AS_API(void) AsFbxMeshCreateDiffuseUV(FbxMesh* pMesh, int32_t uv)
{
	if (pMesh == nullptr)
	{
		return;
	}

	auto pUV = pMesh->CreateElementUV(FbxString("UV") + FbxString(uv), FbxLayerElement::eTextureDiffuse);
	pUV->SetMappingMode(FbxGeometryElement::eByControlPoint);
	pUV->SetReferenceMode(FbxGeometryElement::eDirect);
}

AS_API(void) AsFbxMeshCreateNormalMapUV(FbxMesh* pMesh, int32_t uv)
{
	if (pMesh == nullptr)
	{
		return;
	}

	auto pUV = pMesh->CreateElementUV(FbxString("UV") + FbxString(uv), FbxLayerElement::eTextureNormalMap);
	pUV->SetMappingMode(FbxGeometryElement::eByControlPoint);
	pUV->SetReferenceMode(FbxGeometryElement::eDirect);
}

AS_API(void) AsFbxMeshCreateElementTangent(FbxMesh* pMesh)
{
	if (pMesh == nullptr)
	{
		return;
	}

	auto pTangent = pMesh->CreateElementTangent();
	pTangent->SetMappingMode(FbxGeometryElement::eByControlPoint);
	pTangent->SetReferenceMode(FbxGeometryElement::eDirect);
}

AS_API(void) AsFbxMeshCreateElementVertexColor(FbxMesh* pMesh)
{
	if (pMesh == nullptr)
	{
		return;
	}

	auto pVertexColor = pMesh->CreateElementVertexColor();
	pVertexColor->SetMappingMode(FbxGeometryElement::eByControlPoint);
	pVertexColor->SetReferenceMode(FbxGeometryElement::eDirect);
}

AS_API(void) AsFbxMeshCreateElementMaterial(FbxMesh* pMesh)
{
	if (pMesh == nullptr)
	{
		return;
	}

	auto pMaterial = pMesh->CreateElementMaterial();
	pMaterial->SetMappingMode(FbxGeometryElement::eByPolygon);
	pMaterial->SetReferenceMode(FbxGeometryElement::eIndexToDirect);
}

AS_API(FbxSurfacePhong*) AsFbxCreateMaterial(AsFbxContext* pContext, const char* pMatName,
	float diffuseR, float diffuseG, float diffuseB,
	float ambientR, float ambientG, float ambientB,
	float emissiveR, float emissiveG, float emissiveB,
	float specularR, float specularG, float specularB,
	float reflectR, float reflectG, float reflectB,
	float shininess, float transparency)
{
	if (pContext == nullptr || pContext->pScene == nullptr)
	{
		return nullptr;
	}

	if (pMatName == nullptr)
	{
		return nullptr;
	}

	auto pMat = FbxSurfacePhong::Create(pContext->pScene, pMatName);

	pMat->Diffuse.Set(FbxDouble3(diffuseR, diffuseG, diffuseB));
	pMat->Ambient.Set(FbxDouble3(ambientR, ambientG, ambientB));
	pMat->Emissive.Set(FbxDouble3(emissiveR, emissiveG, emissiveB));
	pMat->Specular.Set(FbxDouble3(specularR, specularG, specularB));
	pMat->Reflection.Set(FbxDouble3(reflectR, reflectG, reflectB));
	pMat->Shininess.Set(FbxDouble(shininess));
	pMat->TransparencyFactor.Set(FbxDouble(transparency));
	pMat->ShadingModel.Set("Phong");

	if (pContext->pMaterials)
	{
		pContext->pMaterials->Add(pMat);
	}

	return pMat;
}

AS_API(int32_t) AsFbxAddMaterialToFrame(FbxNode* pFrameNode, FbxSurfacePhong* pMaterial)
{
	if (pFrameNode == nullptr || pMaterial == nullptr)
	{
		return 0;
	}

	return pFrameNode->AddMaterial(pMaterial);
}

AS_API(void) AsFbxSetFrameShadingModeToTextureShading(FbxNode* pFrameNode)
{
	if (pFrameNode == nullptr)
	{
		return;
	}

	pFrameNode->SetShadingMode(FbxNode::eTextureShading);
}

AS_API(void) AsFbxMeshSetControlPoint(FbxMesh* pMesh, int32_t index, float x, float y, float z)
{
	if (pMesh == nullptr)
	{
		return;
	}

	auto pControlPoints = pMesh->GetControlPoints();

	pControlPoints[index] = FbxVector4(x, y, z, 0);
}

AS_API(void) AsFbxMeshAddPolygon(FbxMesh* pMesh, int32_t materialIndex, int32_t index0, int32_t index1, int32_t index2)
{
	if (pMesh == nullptr)
	{
		return;
	}

	pMesh->BeginPolygon(materialIndex);
	pMesh->AddPolygon(index0);
	pMesh->AddPolygon(index1);
	pMesh->AddPolygon(index2);
	pMesh->EndPolygon();
}

AS_API(void) AsFbxMeshElementNormalAdd(FbxMesh* pMesh, int32_t elementIndex, float x, float y, float z)
{
	if (pMesh == nullptr)
	{
		return;
	}

	auto pElem = pMesh->GetElementNormal(elementIndex);
	auto& array = pElem->GetDirectArray();

	array.Add(FbxVector4(x, y, z, 0));
}

AS_API(void) AsFbxMeshElementUVAdd(FbxMesh* pMesh, int32_t elementIndex, float u, float v)
{
	if (pMesh == nullptr)
	{
		return;
	}

	auto pElem = pMesh->GetElementUV(FbxString("UV") + FbxString(elementIndex));
	auto& array = pElem->GetDirectArray();

	array.Add(FbxVector2(u, v));
}

AS_API(void) AsFbxMeshElementTangentAdd(FbxMesh* pMesh, int32_t elementIndex, float x, float y, float z, float w)
{
	if (pMesh == nullptr)
	{
		return;
	}

	auto pElem = pMesh->GetElementTangent(elementIndex);
	auto& array = pElem->GetDirectArray();

	array.Add(FbxVector4(x, y, z, w));
}

AS_API(void) AsFbxMeshElementVertexColorAdd(FbxMesh* pMesh, int32_t elementIndex, float r, float g, float b, float a)
{
	if (pMesh == nullptr)
	{
		return;
	}

	auto pElem = pMesh->GetElementVertexColor(elementIndex);
	auto& array = pElem->GetDirectArray();

	array.Add(FbxVector4(r, g, b, a));
}

AS_API(void) AsFbxMeshSetBoneWeight(FbxArray<FbxCluster*>* pClusterArray, int32_t boneIndex, int32_t vertexIndex, float weight)
{
	if (pClusterArray == nullptr)
	{
		return;
	}

	auto pCluster = pClusterArray->GetAt(boneIndex);

	if (pCluster != nullptr)
	{
		pCluster->AddControlPointIndex(vertexIndex, weight);
	}
}

AS_API(AsFbxSkinContext*) AsFbxMeshCreateSkinContext(AsFbxContext* pContext, FbxNode* pFrameNode)
{
	return new AsFbxSkinContext(pContext, pFrameNode);
}

AS_API(void) AsFbxMeshDisposeSkinContext(AsFbxSkinContext** ppSkinContext)
{
	if (ppSkinContext == nullptr)
	{
		return;
	}

	delete (*ppSkinContext);
	*ppSkinContext = nullptr;
}

AS_API(bool32_t) FbxClusterArray_HasItemAt(FbxArray<FbxCluster*>* pClusterArray, int32_t index)
{
	if (pClusterArray == nullptr)
	{
		return false;
	}

	auto pCluster = pClusterArray->GetAt(index);

	return pCluster != nullptr;
}

static inline int32_t IndexFrom4x4(int32_t m, int32_t n)
{
	return m * 4 + n;
}

AS_API(void) AsFbxMeshSkinAddCluster(AsFbxSkinContext* pSkinContext, FbxArray<FbxCluster*>* pClusterArray, int32_t index, float pBoneMatrix[16])
{
	if (pSkinContext == nullptr)
	{
		return;
	}

	if (pClusterArray == nullptr)
	{
		return;
	}

	if (pBoneMatrix == nullptr)
	{
		return;
	}

	auto pCluster = pClusterArray->GetAt(index);

	if (pCluster == nullptr)
	{
		return;
	}

	FbxAMatrix boneMatrix;

	for (int m = 0; m < 4; m += 1)
	{
		for (int n = 0; n < 4; n += 1)
		{
			auto index = IndexFrom4x4(m, n);
			boneMatrix.mData[m][n] = pBoneMatrix[index];
		}
	}

	pCluster->SetTransformMatrix(pSkinContext->lMeshMatrix);
	pCluster->SetTransformLinkMatrix(pSkinContext->lMeshMatrix * boneMatrix.Inverse());

	if (pSkinContext->pSkin)
	{
		pSkinContext->pSkin->AddCluster(pCluster);
	}
}

AS_API(void) AsFbxMeshAddDeformer(AsFbxSkinContext* pSkinContext, FbxMesh* pMesh)
{
	if (pSkinContext == nullptr || pSkinContext->pSkin == nullptr)
	{
		return;
	}

	if (pMesh == nullptr)
	{
		return;
	}

	if (pSkinContext->pSkin->GetClusterCount() > 0)
	{
		pMesh->AddDeformer(pSkinContext->pSkin);
	}
}

AS_API(AsFbxAnimContext*) AsFbxAnimCreateContext(bool32_t eulerFilter)
{
	return new AsFbxAnimContext(eulerFilter);
}

AS_API(void) AsFbxAnimDisposeContext(AsFbxAnimContext** ppAnimContext)
{
	if (ppAnimContext == nullptr)
	{
		return;
	}

	delete (*ppAnimContext);
	*ppAnimContext = nullptr;
}

AS_API(void) AsFbxAnimPrepareStackAndLayer(AsFbxContext* pContext, AsFbxAnimContext* pAnimContext, const char* pTakeName)
{
	if (pContext == nullptr || pContext->pScene == nullptr)
	{
		return;
	}

	if (pAnimContext == nullptr)
	{
		return;
	}

	if (pTakeName == nullptr)
	{
		return;
	}

	pAnimContext->lAnimStack = FbxAnimStack::Create(pContext->pScene, pTakeName);
	pAnimContext->lAnimLayer = FbxAnimLayer::Create(pContext->pScene, "Base Layer");

	pAnimContext->lAnimStack->AddMember(pAnimContext->lAnimLayer);
}

AS_API(void) AsFbxAnimLoadCurves(FbxNode* pNode, AsFbxAnimContext* pAnimContext)
{
	if (pNode == nullptr)
	{
		return;
	}

	if (pAnimContext == nullptr)
	{
		return;
	}

	pAnimContext->lCurveSX = pNode->LclScaling.GetCurve(pAnimContext->lAnimLayer, FBXSDK_CURVENODE_COMPONENT_X, true);
	pAnimContext->lCurveSY = pNode->LclScaling.GetCurve(pAnimContext->lAnimLayer, FBXSDK_CURVENODE_COMPONENT_Y, true);
	pAnimContext->lCurveSZ = pNode->LclScaling.GetCurve(pAnimContext->lAnimLayer, FBXSDK_CURVENODE_COMPONENT_Z, true);
	pAnimContext->lCurveRX = pNode->LclRotation.GetCurve(pAnimContext->lAnimLayer, FBXSDK_CURVENODE_COMPONENT_X, true);
	pAnimContext->lCurveRY = pNode->LclRotation.GetCurve(pAnimContext->lAnimLayer, FBXSDK_CURVENODE_COMPONENT_Y, true);
	pAnimContext->lCurveRZ = pNode->LclRotation.GetCurve(pAnimContext->lAnimLayer, FBXSDK_CURVENODE_COMPONENT_Z, true);
	pAnimContext->lCurveTX = pNode->LclTranslation.GetCurve(pAnimContext->lAnimLayer, FBXSDK_CURVENODE_COMPONENT_X, true);
	pAnimContext->lCurveTY = pNode->LclTranslation.GetCurve(pAnimContext->lAnimLayer, FBXSDK_CURVENODE_COMPONENT_Y, true);
	pAnimContext->lCurveTZ = pNode->LclTranslation.GetCurve(pAnimContext->lAnimLayer, FBXSDK_CURVENODE_COMPONENT_Z, true);
}

AS_API(void) AsFbxAnimBeginKeyModify(AsFbxAnimContext* pAnimContext)
{
	if (pAnimContext == nullptr)
	{
		return;
	}

	pAnimContext->lCurveSX->KeyModifyBegin();
	pAnimContext->lCurveSY->KeyModifyBegin();
	pAnimContext->lCurveSZ->KeyModifyBegin();
	pAnimContext->lCurveRX->KeyModifyBegin();
	pAnimContext->lCurveRY->KeyModifyBegin();
	pAnimContext->lCurveRZ->KeyModifyBegin();
	pAnimContext->lCurveTX->KeyModifyBegin();
	pAnimContext->lCurveTY->KeyModifyBegin();
	pAnimContext->lCurveTZ->KeyModifyBegin();
}

AS_API(void) AsFbxAnimEndKeyModify(AsFbxAnimContext* pAnimContext)
{
	if (pAnimContext == nullptr)
	{
		return;
	}

	pAnimContext->lCurveSX->KeyModifyEnd();
	pAnimContext->lCurveSY->KeyModifyEnd();
	pAnimContext->lCurveSZ->KeyModifyEnd();
	pAnimContext->lCurveRX->KeyModifyEnd();
	pAnimContext->lCurveRY->KeyModifyEnd();
	pAnimContext->lCurveRZ->KeyModifyEnd();
	pAnimContext->lCurveTX->KeyModifyEnd();
	pAnimContext->lCurveTY->KeyModifyEnd();
	pAnimContext->lCurveTZ->KeyModifyEnd();
}

AS_API(void) AsFbxAnimAddScalingKey(AsFbxAnimContext* pAnimContext, float time, float x, float y, float z)
{
	if (pAnimContext == nullptr)
	{
		return;
	}

	FbxTime lTime;
	lTime.SetSecondDouble(time);

	pAnimContext->lCurveSX->KeySet(pAnimContext->lCurveSX->KeyAdd(lTime), lTime, x);
	pAnimContext->lCurveSY->KeySet(pAnimContext->lCurveSY->KeyAdd(lTime), lTime, y);
	pAnimContext->lCurveSZ->KeySet(pAnimContext->lCurveSZ->KeyAdd(lTime), lTime, z);
}

AS_API(void) AsFbxAnimAddRotationKey(AsFbxAnimContext* pAnimContext, float time, float x, float y, float z)
{
	if (pAnimContext == nullptr)
	{
		return;
	}

	FbxTime lTime;
	lTime.SetSecondDouble(time);

	pAnimContext->lCurveRX->KeySet(pAnimContext->lCurveRX->KeyAdd(lTime), lTime, x);
	pAnimContext->lCurveRY->KeySet(pAnimContext->lCurveRY->KeyAdd(lTime), lTime, y);
	pAnimContext->lCurveRZ->KeySet(pAnimContext->lCurveRZ->KeyAdd(lTime), lTime, z);
}

AS_API(void) AsFbxAnimAddTranslationKey(AsFbxAnimContext* pAnimContext, float time, float x, float y, float z)
{
	if (pAnimContext == nullptr)
	{
		return;
	}

	FbxTime lTime;
	lTime.SetSecondDouble(time);

	pAnimContext->lCurveTX->KeySet(pAnimContext->lCurveTX->KeyAdd(lTime), lTime, x);
	pAnimContext->lCurveTY->KeySet(pAnimContext->lCurveTY->KeyAdd(lTime), lTime, y);
	pAnimContext->lCurveTZ->KeySet(pAnimContext->lCurveTZ->KeyAdd(lTime), lTime, z);
}

AS_API(void) AsFbxAnimApplyEulerFilter(AsFbxAnimContext* pAnimContext, float filterPrecision)
{
	if (pAnimContext == nullptr || pAnimContext->lFilter == nullptr)
	{
		return;
	}

	FbxAnimCurve* lCurve[3];
	lCurve[0] = pAnimContext->lCurveRX;
	lCurve[1] = pAnimContext->lCurveRY;
	lCurve[2] = pAnimContext->lCurveRZ;

	auto eulerFilter = pAnimContext->lFilter;

	eulerFilter->Reset();
	eulerFilter->SetQualityTolerance(filterPrecision);
	eulerFilter->Apply(lCurve, 3);
}

AS_API(int32_t) AsFbxAnimGetCurrentBlendShapeChannelCount(AsFbxAnimContext* pAnimContext, fbxsdk::FbxNode* pNode)
{
	if (pAnimContext == nullptr)
	{
		return 0;
	}

	if (pNode == nullptr)
	{
		return 0;
	}

	auto pMesh = pNode->GetMesh();
	pAnimContext->pMesh = pMesh;

	if (pMesh == nullptr)
	{
		return 0;
	}

	auto blendShapeDeformerCount = pMesh->GetDeformerCount(FbxDeformer::eBlendShape);

	if (blendShapeDeformerCount <= 0)
	{
		return 0;
	}

	auto lBlendShape = (FbxBlendShape*)pMesh->GetDeformer(0, FbxDeformer::eBlendShape);
	pAnimContext->lBlendShape = lBlendShape;

	if (lBlendShape == nullptr)
	{
		return 0;
	}

	auto lBlendShapeChannelCount = lBlendShape->GetBlendShapeChannelCount();

	return lBlendShapeChannelCount;
}

AS_API(bool32_t) AsFbxAnimIsBlendShapeChannelMatch(AsFbxAnimContext* pAnimContext, int32_t channelIndex, const char* channelName)
{
	if (pAnimContext == nullptr || pAnimContext->lBlendShape == nullptr)
	{
		return false;
	}

	if (channelName == nullptr)
	{
		return false;
	}

	FbxBlendShapeChannel* lChannel = pAnimContext->lBlendShape->GetBlendShapeChannel(channelIndex);
	auto lChannelName = lChannel->GetNameOnly();

	FbxString chanName(channelName);

	return lChannelName == chanName;
}

AS_API(void) AsFbxAnimBeginBlendShapeAnimCurve(AsFbxAnimContext* pAnimContext, int32_t channelIndex)
{
	if (pAnimContext == nullptr || pAnimContext->pMesh == nullptr || pAnimContext->lAnimLayer == nullptr)
	{
		return;
	}

	pAnimContext->lAnimCurve = pAnimContext->pMesh->GetShapeChannel(0, channelIndex, pAnimContext->lAnimLayer, true);
	pAnimContext->lAnimCurve->KeyModifyBegin();
}

AS_API(void) AsFbxAnimEndBlendShapeAnimCurve(AsFbxAnimContext* pAnimContext)
{
	if (pAnimContext == nullptr || pAnimContext->lAnimCurve == nullptr)
	{
		return;
	}

	pAnimContext->lAnimCurve->KeyModifyEnd();
}

AS_API(void) AsFbxAnimAddBlendShapeKeyframe(AsFbxAnimContext* pAnimContext, float time, float value)
{
	if (pAnimContext == nullptr || pAnimContext->lAnimCurve == nullptr)
	{
		return;
	}

	FbxTime lTime;
	lTime.SetSecondDouble(time);

	auto keyIndex = pAnimContext->lAnimCurve->KeyAdd(lTime);
	pAnimContext->lAnimCurve->KeySetValue(keyIndex, value);
	pAnimContext->lAnimCurve->KeySetInterpolation(keyIndex, FbxAnimCurveDef::eInterpolationCubic);
}

AS_API(AsFbxMorphContext*) AsFbxMorphCreateContext()
{
	return new AsFbxMorphContext();
}

AS_API(void) AsFbxMorphInitializeContext(AsFbxContext* pContext, AsFbxMorphContext* pMorphContext, fbxsdk::FbxNode* pNode)
{
	if (pContext == nullptr || pContext->pScene == nullptr)
	{
		return;
	}

	if (pMorphContext == nullptr)
	{
		return;
	}

	if (pNode == nullptr)
	{
		return;
	}

	auto pMesh = pNode->GetMesh();
	pMorphContext->pMesh = pMesh;

	auto lBlendShape = FbxBlendShape::Create(pContext->pScene, pMesh->GetNameOnly() + FbxString("BlendShape"));
	pMorphContext->lBlendShape = lBlendShape;

	pMesh->AddDeformer(lBlendShape);
}

AS_API(void) AsFbxMorphDisposeContext(AsFbxMorphContext** ppMorphContext)
{
	if (ppMorphContext == nullptr)
	{
		return;
	}

	delete (*ppMorphContext);
	*ppMorphContext = nullptr;
}

AS_API(void) AsFbxMorphAddBlendShapeChannel(AsFbxContext* pContext, AsFbxMorphContext* pMorphContext, const char* channelName)
{
	if (pContext == nullptr || pContext->pScene == nullptr)
	{
		return;
	}

	if (pMorphContext == nullptr)
	{
		return;
	}

	if (channelName == nullptr)
	{
		return;
	}

	auto lBlendShapeChannel = FbxBlendShapeChannel::Create(pContext->pScene, channelName);
	pMorphContext->lBlendShapeChannel = lBlendShapeChannel;

	if (pMorphContext->lBlendShape != nullptr)
	{
		pMorphContext->lBlendShape->AddBlendShapeChannel(lBlendShapeChannel);
	}
}

AS_API(void) AsFbxMorphAddBlendShapeChannelShape(AsFbxContext* pContext, AsFbxMorphContext* pMorphContext, float weight, const char* shapeName)
{
	if (pContext == nullptr || pContext->pScene == nullptr)
	{
		return;
	}

	if (pMorphContext == nullptr)
	{
		return;
	}

	auto lShape = FbxShape::Create(pContext->pScene, shapeName);
	pMorphContext->lShape = lShape;

	if (pMorphContext->lBlendShapeChannel != nullptr) {
		pMorphContext->lBlendShapeChannel->AddTargetShape(lShape, weight);
	}
}

AS_API(void) AsFbxMorphCopyBlendShapeControlPoints(AsFbxMorphContext* pMorphContext)
{
	if (pMorphContext == nullptr || pMorphContext->pMesh == nullptr || pMorphContext->lShape == nullptr)
	{
		return;
	}

	auto vectorCount = pMorphContext->pMesh->GetControlPointsCount();

	auto srcControlPoints = pMorphContext->pMesh->GetControlPoints();

	pMorphContext->lShape->InitControlPoints(vectorCount);

	for (int j = 0; j < vectorCount; j++)
	{
		pMorphContext->lShape->SetControlPointAt(FbxVector4(srcControlPoints[j]), j);;
	}
}

AS_API(void) AsFbxMorphSetBlendShapeVertex(AsFbxMorphContext* pMorphContext, uint32_t index, float x, float y, float z)
{
	if (pMorphContext == nullptr || pMorphContext->lShape == nullptr)
	{
		return;
	}

	pMorphContext->lShape->SetControlPointAt(FbxVector4(x, y, z, 0), index);
}

AS_API(void) AsFbxMorphCopyBlendShapeControlPointsNormal(AsFbxMorphContext* pMorphContext)
{
	if (pMorphContext == nullptr || pMorphContext->pMesh == nullptr || pMorphContext->lShape == nullptr)
	{
		return;
	}

	pMorphContext->lShape->InitNormals(pMorphContext->pMesh);
}

AS_API(void) AsFbxMorphSetBlendShapeVertexNormal(AsFbxMorphContext* pMorphContext, uint32_t index, float x, float y, float z)
{
	if (pMorphContext == nullptr || pMorphContext->lShape == nullptr)
	{
		return;
	}

	pMorphContext->lShape->SetControlPointNormalAt(FbxVector4(x, y, z, 0), index);
}

```

`AssetStudioFBXNative/api.h`:

```h
#pragma once

#include "dllexport.h"
#include "bool32_t.h"

namespace fbxsdk
{
	class FbxNode;
	class FbxFileTexture;
	template<typename T, const int Alignment = 16>
	class FbxArray;
	class FbxCluster;
	class FbxMesh;
	class FbxSurfacePhong;
}

struct AsFbxContext;
struct AsFbxSkinContext;
struct AsFbxAnimContext;
struct AsFbxMorphContext;

AS_API(void) AsUtilQuaternionToEuler(float qx, float qy, float qz, float qw, float* vx, float* vy, float* vz);

AS_API(void) AsUtilEulerToQuaternion(float vx, float vy, float vz, float* qx, float* qy, float* qz, float* qw);

// All strings ([const] char *) in this header are UTF-8 strings.

AS_API(AsFbxContext*) AsFbxCreateContext();

// Do not free pErrMsg
AS_API(bool32_t) AsFbxInitializeContext(AsFbxContext* pContext, const char* pFileName, float scaleFactor, int32_t versionIndex, bool32_t isAscii, bool32_t is60Fps, const char** pErrMsg);

AS_API(void) AsFbxDisposeContext(AsFbxContext** ppContext);

AS_API(void) AsFbxSetFramePaths(AsFbxContext* pContext, const char* ppPaths[], int32_t count);

AS_API(void) AsFbxExportScene(AsFbxContext* pContext);

AS_API(fbxsdk::FbxNode*) AsFbxGetSceneRootNode(AsFbxContext* pContext);

AS_API(fbxsdk::FbxNode*) AsFbxExportSingleFrame(AsFbxContext* pContext, fbxsdk::FbxNode* pParentNode, const char* pFramePath, const char* pFrameName, float localPositionX, float localPositionY, float localPositionZ, float localRotationX, float localRotationY, float localRotationZ, float localScaleX, float localScaleY, float localScaleZ);

AS_API(void) AsFbxSetJointsNode_CastToBone(AsFbxContext* pContext, fbxsdk::FbxNode* pNode, float boneSize);

AS_API(void) AsFbxSetJointsNode_BoneInPath(AsFbxContext* pContext, fbxsdk::FbxNode* pNode, float boneSize);

AS_API(void) AsFbxSetJointsNode_Generic(AsFbxContext* pContext, fbxsdk::FbxNode* pNode);

AS_API(void) AsFbxPrepareMaterials(AsFbxContext* pContext, int32_t materialCount, int32_t textureCount);

AS_API(fbxsdk::FbxFileTexture*) AsFbxCreateTexture(AsFbxContext* pContext, const char* pMatTexName);

AS_API(void) AsFbxLinkTexture(int32_t dest, fbxsdk::FbxFileTexture* pTexture, fbxsdk::FbxSurfacePhong* pMaterial, float offsetX, float offsetY, float scaleX, float scaleY);

AS_API(fbxsdk::FbxArray<fbxsdk::FbxCluster*>*) AsFbxMeshCreateClusterArray(int32_t boneCount);

AS_API(void) AsFbxMeshDisposeClusterArray(fbxsdk::FbxArray<fbxsdk::FbxCluster*>** ppArray);

AS_API(fbxsdk::FbxCluster*) AsFbxMeshCreateCluster(AsFbxContext* pContext, fbxsdk::FbxNode* pBoneNode);

AS_API(void) AsFbxMeshAddCluster(fbxsdk::FbxArray<fbxsdk::FbxCluster*>* pArray, /* CanBeNull */ fbxsdk::FbxCluster* pCluster);

AS_API(fbxsdk::FbxMesh*) AsFbxMeshCreateMesh(AsFbxContext* pContext, fbxsdk::FbxNode* pFrameNode);

AS_API(void) AsFbxMeshInitControlPoints(fbxsdk::FbxMesh* pMesh, int32_t vertexCount);

AS_API(void) AsFbxMeshCreateElementNormal(fbxsdk::FbxMesh* pMesh);

AS_API(void) AsFbxMeshCreateDiffuseUV(fbxsdk::FbxMesh* pMesh, int32_t uv);

AS_API(void) AsFbxMeshCreateNormalMapUV(fbxsdk::FbxMesh* pMesh, int32_t uv);

AS_API(void) AsFbxMeshCreateElementTangent(fbxsdk::FbxMesh* pMesh);

AS_API(void) AsFbxMeshCreateElementVertexColor(fbxsdk::FbxMesh* pMesh);

AS_API(void) AsFbxMeshCreateElementMaterial(fbxsdk::FbxMesh* pMesh);

AS_API(fbxsdk::FbxSurfacePhong*) AsFbxCreateMaterial(AsFbxContext* pContext, const char* pMatName,
	float diffuseR, float diffuseG, float diffuseB,
	float ambientR, float ambientG, float ambientB,
	float emissiveR, float emissiveG, float emissiveB,
	float specularR, float specularG, float specularB,
	float reflectR, float reflectG, float reflectB,
	float shininess, float transparency);

AS_API(int32_t) AsFbxAddMaterialToFrame(fbxsdk::FbxNode* pFrameNode, fbxsdk::FbxSurfacePhong* pMaterial);

AS_API(void) AsFbxSetFrameShadingModeToTextureShading(fbxsdk::FbxNode* pFrameNode);

AS_API(void) AsFbxMeshSetControlPoint(fbxsdk::FbxMesh* pMesh, int32_t index, float x, float y, float z);

AS_API(void) AsFbxMeshAddPolygon(fbxsdk::FbxMesh* pMesh, int32_t materialIndex, int32_t index0, int32_t index1, int32_t index2);

AS_API(void) AsFbxMeshElementNormalAdd(fbxsdk::FbxMesh* pMesh, int32_t elementIndex, float x, float y, float z);

AS_API(void) AsFbxMeshElementUVAdd(fbxsdk::FbxMesh* pMesh, int32_t elementIndex, float u, float v);

AS_API(void) AsFbxMeshElementTangentAdd(fbxsdk::FbxMesh* pMesh, int32_t elementIndex, float x, float y, float z, float w);

AS_API(void) AsFbxMeshElementVertexColorAdd(fbxsdk::FbxMesh* pMesh, int32_t elementIndex, float r, float g, float b, float a);

AS_API(void) AsFbxMeshSetBoneWeight(fbxsdk::FbxArray<fbxsdk::FbxCluster*>* pClusterArray, int32_t boneIndex, int32_t vertexIndex, float weight);

AS_API(AsFbxSkinContext*) AsFbxMeshCreateSkinContext(AsFbxContext* pContext, fbxsdk::FbxNode* pFrameNode);

AS_API(void) AsFbxMeshDisposeSkinContext(AsFbxSkinContext** ppSkinContext);

AS_API(bool32_t) FbxClusterArray_HasItemAt(fbxsdk::FbxArray<fbxsdk::FbxCluster*>* pClusterArray, int32_t index);

AS_API(void) AsFbxMeshSkinAddCluster(AsFbxSkinContext* pSkinContext, fbxsdk::FbxArray<fbxsdk::FbxCluster*>* pClusterArray, int32_t index, float pBoneMatrix[16]);

AS_API(void) AsFbxMeshAddDeformer(AsFbxSkinContext* pSkinContext, fbxsdk::FbxMesh* pMesh);

AS_API(AsFbxAnimContext*) AsFbxAnimCreateContext(bool32_t eulerFilter);

AS_API(void) AsFbxAnimDisposeContext(AsFbxAnimContext** ppAnimContext);

AS_API(void) AsFbxAnimPrepareStackAndLayer(AsFbxContext* pContext, AsFbxAnimContext* pAnimContext, const char* pTakeName);

AS_API(void) AsFbxAnimLoadCurves(fbxsdk::FbxNode* pNode, AsFbxAnimContext* pAnimContext);

AS_API(void) AsFbxAnimBeginKeyModify(AsFbxAnimContext* pAnimContext);

AS_API(void) AsFbxAnimEndKeyModify(AsFbxAnimContext* pAnimContext);

AS_API(void) AsFbxAnimAddScalingKey(AsFbxAnimContext* pAnimContext, float time, float x, float y, float z);

AS_API(void) AsFbxAnimAddRotationKey(AsFbxAnimContext* pAnimContext, float time, float x, float y, float z);

AS_API(void) AsFbxAnimAddTranslationKey(AsFbxAnimContext* pAnimContext, float time, float x, float y, float z);

AS_API(void) AsFbxAnimApplyEulerFilter(AsFbxAnimContext* pAnimContext, float filterPrecision);

AS_API(int32_t) AsFbxAnimGetCurrentBlendShapeChannelCount(AsFbxAnimContext* pAnimContext, fbxsdk::FbxNode* pNode);

AS_API(bool32_t) AsFbxAnimIsBlendShapeChannelMatch(AsFbxAnimContext* pAnimContext, int32_t channelIndex, const char* channelName);

AS_API(void) AsFbxAnimBeginBlendShapeAnimCurve(AsFbxAnimContext* pAnimContext, int32_t channelIndex);

AS_API(void) AsFbxAnimEndBlendShapeAnimCurve(AsFbxAnimContext* pAnimContext);

AS_API(void) AsFbxAnimAddBlendShapeKeyframe(AsFbxAnimContext* pAnimContext, float time, float value);

AS_API(AsFbxMorphContext*) AsFbxMorphCreateContext();

AS_API(void) AsFbxMorphInitializeContext(AsFbxContext* pContext, AsFbxMorphContext* pMorphContext, fbxsdk::FbxNode* pNode);

AS_API(void) AsFbxMorphDisposeContext(AsFbxMorphContext** ppMorphContext);

AS_API(void) AsFbxMorphAddBlendShapeChannel(AsFbxContext* pContext, AsFbxMorphContext* pMorphContext, const char* channelName);

AS_API(void) AsFbxMorphAddBlendShapeChannelShape(AsFbxContext* pContext, AsFbxMorphContext* pMorphContext, float weight, const char* shapeName);

AS_API(void) AsFbxMorphCopyBlendShapeControlPoints(AsFbxMorphContext* pMorphContext);

AS_API(void) AsFbxMorphSetBlendShapeVertex(AsFbxMorphContext* pMorphContext, uint32_t index, float x, float y, float z);

AS_API(void) AsFbxMorphCopyBlendShapeControlPointsNormal(AsFbxMorphContext* pMorphContext);

AS_API(void) AsFbxMorphSetBlendShapeVertexNormal(AsFbxMorphContext* pMorphContext, uint32_t index, float x, float y, float z);

```

`AssetStudioFBXNative/asfbx_anim_context.cpp`:

```cpp
#include "asfbx_anim_context.h"

AsFbxAnimContext::AsFbxAnimContext(bool32_t eulerFilter)
	: lFilter(nullptr)
{
	if (eulerFilter)
	{
		lFilter = new FbxAnimCurveFilterUnroll();
	}

	lAnimStack = nullptr;
	lAnimLayer = nullptr;

	lCurveSX = nullptr;
	lCurveSY = nullptr;
	lCurveSZ = nullptr;
	lCurveRX = nullptr;
	lCurveRY = nullptr;
	lCurveRZ = nullptr;
	lCurveTX = nullptr;
	lCurveTY = nullptr;
	lCurveTZ = nullptr;

	pMesh = nullptr;
	lBlendShape = nullptr;
	lAnimCurve = nullptr;
}

```

`AssetStudioFBXNative/asfbx_anim_context.h`:

```h
#pragma once

#include <fbxsdk.h>

#include "bool32_t.h"

struct AsFbxAnimContext
{

	FbxAnimCurveFilterUnroll* lFilter;

	FbxAnimStack* lAnimStack;
	FbxAnimLayer* lAnimLayer;

	FbxAnimCurve* lCurveSX;
	FbxAnimCurve* lCurveSY;
	FbxAnimCurve* lCurveSZ;
	FbxAnimCurve* lCurveRX;
	FbxAnimCurve* lCurveRY;
	FbxAnimCurve* lCurveRZ;
	FbxAnimCurve* lCurveTX;
	FbxAnimCurve* lCurveTY;
	FbxAnimCurve* lCurveTZ;

	FbxMesh* pMesh;
	FbxBlendShape* lBlendShape;
	FbxAnimCurve* lAnimCurve;

	AsFbxAnimContext(bool32_t eulerFilter);
	~AsFbxAnimContext() = default;

};

```

`AssetStudioFBXNative/asfbx_context.cpp`:

```cpp
#include <fbxsdk.h>

#include "asfbx_context.h"

AsFbxContext::AsFbxContext()
{
	pSdkManager = nullptr;
	pScene = nullptr;
	pTextures = nullptr;
	pMaterials = nullptr;
	pExporter = nullptr;
	pBindPose = nullptr;
}

AsFbxContext::~AsFbxContext()
{
	framePaths.clear();

	delete pMaterials;
	delete pTextures;

	if (pExporter != nullptr) {
		pExporter->Destroy();
	}

	if (pScene != nullptr) {
		pScene->Destroy();
	}

	if (pSdkManager != nullptr) {
		pSdkManager->Destroy();
	}
}

```

`AssetStudioFBXNative/asfbx_context.h`:

```h
#pragma once

#include <cstdint>
#include <string>
#include <unordered_set>

struct AsFbxContext
{

	fbxsdk::FbxManager* pSdkManager;
	fbxsdk::FbxScene* pScene;
	fbxsdk::FbxArray<fbxsdk::FbxFileTexture*>* pTextures;
	fbxsdk::FbxArray<fbxsdk::FbxSurfacePhong*>* pMaterials;
	fbxsdk::FbxExporter* pExporter;
	fbxsdk::FbxPose* pBindPose;

	std::unordered_set<std::string> framePaths;

	AsFbxContext();
	~AsFbxContext();
};

```

`AssetStudioFBXNative/asfbx_morph_context.cpp`:

```cpp
#include "asfbx_morph_context.h"

AsFbxMorphContext::AsFbxMorphContext()
{
	pMesh = nullptr;
	lBlendShape = nullptr;
	lBlendShapeChannel = nullptr;
	lShape = nullptr;
}

```

`AssetStudioFBXNative/asfbx_morph_context.h`:

```h
#pragma once

#include <fbxsdk.h>

struct AsFbxMorphContext
{

	FbxMesh* pMesh;
	FbxBlendShape* lBlendShape;
	FbxBlendShapeChannel* lBlendShapeChannel;
	FbxShape* lShape;

	AsFbxMorphContext();
	~AsFbxMorphContext() = default;

};

```

`AssetStudioFBXNative/asfbx_skin_context.cpp`:

```cpp
#include "asfbx_skin_context.h"
#include "asfbx_context.h"

AsFbxSkinContext::AsFbxSkinContext(AsFbxContext* pContext, FbxNode* pFrameNode)
	: pSkin(nullptr)
{
	if (pContext != nullptr && pContext->pScene != nullptr)
	{
		pSkin = FbxSkin::Create(pContext->pScene, "");
	}

	if (pFrameNode != nullptr) 
	{
		lMeshMatrix = pFrameNode->EvaluateGlobalTransform();
	}
}

```

`AssetStudioFBXNative/asfbx_skin_context.h`:

```h
#pragma once

#include <fbxsdk.h>

struct AsFbxContext;

struct AsFbxSkinContext
{
	
	FbxSkin* pSkin;
	FbxAMatrix lMeshMatrix;

	AsFbxSkinContext(AsFbxContext* pContext, FbxNode* pFrameNode);
	~AsFbxSkinContext() = default;

};

```

`AssetStudioFBXNative/bool32_t.h`:

```h
#pragma once

#include <cstdint>

typedef uint32_t bool32_t;

```

`AssetStudioFBXNative/cpp.hint`:

```hint
#define AS_API(ret_type)

```

`AssetStudioFBXNative/dllexport.h`:

```h
#pragma once

#if defined(_MSC_VER)
#if _MSC_VER < 1910 // MSVC 2017-
#error MSVC 2017 or later is required.
#endif
#endif

#if defined(WIN32) || defined(_WIN32) || defined(__CYGWIN__) || defined(__MINGW__)
#ifdef _AS_DLL
#ifdef __GNUC__
#define _AS_EXPORT __attribute__ ((dllexport))
#else
#define _AS_EXPORT __declspec(dllexport)
#endif
#else
#ifdef __GNUC__
#define _AS_EXPORT __attribute__ ((dllimport))
#else
#define _AS_EXPORT __declspec(dllimport)
#endif
#endif
#define _AS_LOCAL
#else
#if __GNUC__ >= 4
#define _AS_EXPORT __attribute__ ((visibility ("default")))
#define _AS_LOCAL  __attribute__ ((visibility ("hidden")))
#else
#define _AS_EXPORT
#define _AS_LOCAL
#endif
#endif

#ifdef __cplusplus
#ifndef _EXTERN_C_STMT
#define _EXTERN_C_STMT extern "C"
#endif
#else
#ifndef _EXTERN_C_STMT
#define _EXTERN_C_STMT
#endif
#endif

#ifndef _AS_CALL
#if defined(WIN32) || defined(_WIN32)
#define _AS_CALL __stdcall
#else
#define _AS_CALL /* __cdecl */
#endif
#endif

#if defined(_MSC_VER)
#define AS_API(ret_type) _EXTERN_C_STMT _AS_EXPORT ret_type _AS_CALL
#else
#define AS_API(ret_type) _EXTERN_C_STMT _AS_EXPORT _AS_CALL ret_type
#endif

```

`AssetStudioFBXNative/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by AssetStudioFBXNative.rc

// 新对象的下一组默认值
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`AssetStudioFBXNative/utils.cpp`:

```cpp
#include <fbxsdk.h>
#include <cassert>

#include "utils.h"

Vector3::Vector3()
	: X(0), Y(0), Z(0)
{
}

Vector3::Vector3(float x, float y, float z)
	: X(x), Y(y), Z(z)
{
}

Quaternion::Quaternion()
	: X(0), Y(0), Z(0), W(1)
{
}

Quaternion::Quaternion(float x, float y, float z)
	: X(x), Y(y), Z(z), W(1)
{
}

Quaternion::Quaternion(float x, float y, float z, float w)
	: X(x), Y(y), Z(z), W(w)
{
}

Vector3 QuaternionToEuler(Quaternion q) {
	FbxAMatrix lMatrixRot;
	lMatrixRot.SetQ(FbxQuaternion(q.X, q.Y, q.Z, q.W));
	FbxVector4 lEuler = lMatrixRot.GetR();
	return Vector3((float)lEuler[0], (float)lEuler[1], (float)lEuler[2]);
}

Quaternion EulerToQuaternion(Vector3 v) {
	FbxAMatrix lMatrixRot;
	lMatrixRot.SetR(FbxVector4(v.X, v.Y, v.Z));
	FbxQuaternion lQuaternion = lMatrixRot.GetQ();
	return Quaternion((float)lQuaternion[0], (float)lQuaternion[1], (float)lQuaternion[2], (float)lQuaternion[3]);
}

```

`AssetStudioFBXNative/utils.h`:

```h
#pragma once

struct Vector3 {

	float X;
	float Y;
	float Z;

	Vector3();
	Vector3(float x, float y, float z);

};

struct Quaternion {

	float X;
	float Y;
	float Z;
	float W;

	Quaternion();
	Quaternion(float x, float y, float z);
	Quaternion(float x, float y, float z, float w);

};

Vector3 QuaternionToEuler(Quaternion q);

Quaternion EulerToQuaternion(Vector3 v);

```

`AssetStudioFBXWrapper/AssetStudioFBXWrapper.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net472;netstandard2.0;net5.0;net6.0</TargetFrameworks>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Version>0.16.0.0</Version>
    <AssemblyVersion>0.16.0.0</AssemblyVersion>
    <FileVersion>0.16.0.0</FileVersion>
    <Copyright>Copyright © Perfare 2018-2022; Copyright © hozuki 2020</Copyright>
    <DebugType>embedded</DebugType>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\AssetStudio.PInvoke\AssetStudio.PInvoke.csproj" />
    <ProjectReference Include="..\AssetStudio\AssetStudio.csproj" />
  </ItemGroup>

</Project>

```

`AssetStudioFBXWrapper/Fbx.PInvoke.cs`:

```cs
using System.Runtime.InteropServices;
using AssetStudio.FbxInterop;

namespace AssetStudio
{
    partial class Fbx
    {

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsUtilQuaternionToEuler(float qx, float qy, float qz, float qw, out float vx, out float vy, out float vz);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsUtilEulerToQuaternion(float vx, float vy, float vz, out float qx, out float qy, out float qz, out float qw);

    }
}

```

`AssetStudioFBXWrapper/Fbx.cs`:

```cs
using AssetStudio.FbxInterop;
using AssetStudio.PInvoke;
using System.IO;

namespace AssetStudio
{
    public static partial class Fbx
    {

        static Fbx()
        {
            DllLoader.PreloadDll(FbxDll.DllName);
        }

        public static Vector3 QuaternionToEuler(Quaternion q)
        {
            AsUtilQuaternionToEuler(q.X, q.Y, q.Z, q.W, out var x, out var y, out var z);
            return new Vector3(x, y, z);
        }

        public static Quaternion EulerToQuaternion(Vector3 v)
        {
            AsUtilEulerToQuaternion(v.X, v.Y, v.Z, out var x, out var y, out var z, out var w);
            return new Quaternion(x, y, z, w);
        }

        public static class Exporter
        {

            public static void Export(string path, IImported imported, bool eulerFilter, float filterPrecision,
                bool allNodes, bool skins, bool animation, bool blendShape, bool castToBone, float boneSize, bool exportAllUvsAsDiffuseMaps, float scaleFactor, int versionIndex, bool isAscii)
            {
                var file = new FileInfo(path);
                var dir = file.Directory;

                if (!dir.Exists)
                {
                    dir.Create();
                }

                var currentDir = Directory.GetCurrentDirectory();
                Directory.SetCurrentDirectory(dir.FullName);

                var name = Path.GetFileName(path);

                using (var exporter = new FbxExporter(name, imported, allNodes, skins, castToBone, boneSize, exportAllUvsAsDiffuseMaps, scaleFactor, versionIndex, isAscii))
                {
                    exporter.Initialize();
                    exporter.ExportAll(blendShape, animation, eulerFilter, filterPrecision);
                }

                Directory.SetCurrentDirectory(currentDir);
            }

        }

    }
}

```

`AssetStudioFBXWrapper/FbxDll.cs`:

```cs
namespace AssetStudio.FbxInterop
{
    internal static class FbxDll
    {

        internal const string DllName = "AssetStudioFBXNative";
        internal const string FbxsdkDllName = "libfbxsdk";

    }
}

```

`AssetStudioFBXWrapper/FbxExporter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace AssetStudio.FbxInterop
{
    internal sealed class FbxExporter : IDisposable
    {

        private FbxExporterContext _context;

        private readonly string _fileName;
        private readonly IImported _imported;
        private readonly bool _allNodes;
        private readonly bool _exportSkins;
        private readonly bool _castToBone;
        private readonly float _boneSize;
        private readonly bool _exportAllUvsAsDiffuseMaps;
        private readonly float _scaleFactor;
        private readonly int _versionIndex;
        private readonly bool _isAscii;

        internal FbxExporter(string fileName, IImported imported, bool allNodes, bool exportSkins, bool castToBone, float boneSize, bool exportAllUvsAsDiffuseMaps, float scaleFactor, int versionIndex, bool isAscii)
        {
            _context = new FbxExporterContext();

            _fileName = fileName;
            _imported = imported;
            _allNodes = allNodes;
            _exportSkins = exportSkins;
            _castToBone = castToBone;
            _boneSize = boneSize;
            _exportAllUvsAsDiffuseMaps = exportAllUvsAsDiffuseMaps;
            _scaleFactor = scaleFactor;
            _versionIndex = versionIndex;
            _isAscii = isAscii;
        }

        ~FbxExporter()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            if (IsDisposed)
            {
                return;
            }

            Dispose(true);
            GC.SuppressFinalize(this);
        }

        public bool IsDisposed { get; private set; }

        private void Dispose(bool disposing)
        {
            if (disposing)
            {
                _context.Dispose();
            }

            IsDisposed = true;
        }

        internal void Initialize()
        {
            var is60Fps = _imported.AnimationList.Count > 0 && _imported.AnimationList[0].SampleRate.Equals(60.0f);

            _context.Initialize(_fileName, _scaleFactor, _versionIndex, _isAscii, is60Fps);

            if (!_allNodes)
            {
                var framePaths = SearchHierarchy();

                _context.SetFramePaths(framePaths);
            }
        }

        internal void ExportAll(bool blendShape, bool animation, bool eulerFilter, float filterPrecision)
        {
            var meshFrames = new List<ImportedFrame>();

            ExportRootFrame(meshFrames);

            if (_imported.MeshList != null)
            {
                SetJointsFromImportedMeshes();

                PrepareMaterials();

                ExportMeshFrames(_imported.RootFrame, meshFrames);
            }
            else
            {
                SetJointsNode(_imported.RootFrame, null, true);
            }



            if (blendShape)
            {
                ExportMorphs();
            }

            if (animation)
            {
                ExportAnimations(eulerFilter, filterPrecision);
            }

            ExportScene();
        }

        private void ExportMorphs()
        {
            _context.ExportMorphs(_imported.RootFrame, _imported.MorphList);
        }

        private void ExportAnimations(bool eulerFilter, float filterPrecision)
        {
            _context.ExportAnimations(_imported.RootFrame, _imported.AnimationList, eulerFilter, filterPrecision);
        }

        private void ExportRootFrame(List<ImportedFrame> meshFrames)
        {
            _context.ExportFrame(_imported.MeshList, meshFrames, _imported.RootFrame);
        }

        private void ExportScene()
        {
            _context.ExportScene();
        }

        private void SetJointsFromImportedMeshes()
        {
            if (!_exportSkins)
            {
                return;
            }

            Debug.Assert(_imported.MeshList != null);

            var bonePaths = new HashSet<string>();

            foreach (var mesh in _imported.MeshList)
            {
                var boneList = mesh.BoneList;

                if (boneList != null)
                {
                    foreach (var bone in boneList)
                    {
                        bonePaths.Add(bone.Path);
                    }
                }
            }

            SetJointsNode(_imported.RootFrame, bonePaths, _castToBone);
        }

        private void SetJointsNode(ImportedFrame rootFrame, HashSet<string> bonePaths, bool castToBone)
        {
            _context.SetJointsNode(rootFrame, bonePaths, castToBone, _boneSize);
        }

        private void PrepareMaterials()
        {
            _context.PrepareMaterials(_imported.MaterialList.Count, _imported.TextureList.Count);
        }

        private void ExportMeshFrames(ImportedFrame rootFrame, List<ImportedFrame> meshFrames)
        {
            foreach (var meshFrame in meshFrames)
            {
                _context.ExportMeshFromFrame(rootFrame, meshFrame, _imported.MeshList, _imported.MaterialList, _imported.TextureList, _exportSkins, _exportAllUvsAsDiffuseMaps);
            }
        }

        private HashSet<string> SearchHierarchy()
        {
            if (_imported.MeshList == null || _imported.MeshList.Count == 0)
            {
                return null;
            }

            var exportFrames = new HashSet<string>();

            SearchHierarchy(_imported.RootFrame, _imported.MeshList, exportFrames);

            return exportFrames;
        }

        private static void SearchHierarchy(ImportedFrame rootFrame, List<ImportedMesh> meshList, HashSet<string> exportFrames)
        {
            var frameStack = new Stack<ImportedFrame>();

            frameStack.Push(rootFrame);

            while (frameStack.Count > 0)
            {
                var frame = frameStack.Pop();

                var meshListSome = ImportedHelpers.FindMesh(frame.Path, meshList);

                if (meshListSome != null)
                {
                    var parent = frame;

                    while (parent != null)
                    {
                        exportFrames.Add(parent.Path);
                        parent = parent.Parent;
                    }

                    var boneList = meshListSome.BoneList;

                    if (boneList != null)
                    {
                        foreach (var bone in boneList)
                        {
                            if (!exportFrames.Contains(bone.Path))
                            {
                                var boneParent = rootFrame.FindFrameByPath(bone.Path);

                                while (boneParent != null)
                                {
                                    exportFrames.Add(boneParent.Path);
                                    boneParent = boneParent.Parent;
                                }
                            }
                        }
                    }
                }

                for (var i = frame.Count - 1; i >= 0; i -= 1)
                {
                    frameStack.Push(frame[i]);
                }
            }
        }

    }
}

```

`AssetStudioFBXWrapper/FbxExporterContext.PInvoke.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using AssetStudio.PInvoke;

namespace AssetStudio.FbxInterop
{
    partial class FbxExporterContext
    {

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr AsFbxCreateContext();

        private static bool AsFbxInitializeContext(IntPtr context, string fileName, float scaleFactor, int versionIndex, bool isAscii, bool is60Fps, out string errorMessage)
        {
            bool b;
            IntPtr pErrMsg;

            using (var fileNameUtf8 = new Utf8StringHandle(fileName))
            {
                b = AsFbxInitializeContext(context, fileNameUtf8.DangerousGetHandle(), scaleFactor, versionIndex, isAscii, is60Fps, out pErrMsg);
            }

            errorMessage = Utf8StringHandle.ReadUtf8StringFromPointer(pErrMsg);

            return b;
        }

        // Do not free the pointer strErrorMessage
        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool AsFbxInitializeContext(IntPtr context, IntPtr strFileName, float scaleFactor, int versionIndex, [MarshalAs(UnmanagedType.Bool)] bool isAscii, [MarshalAs(UnmanagedType.Bool)] bool is60Fps, out IntPtr strErrorMessage);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxDisposeContext(ref IntPtr ppContext);

        private static void AsFbxSetFramePaths(IntPtr context, string[] framePaths)
        {
            var framePathCount = framePaths.Length;

            if (framePathCount == 0)
            {
                AsFbxSetFramePaths(context, Array.Empty<IntPtr>(), 0);
            }
            else
            {
                var utf8Paths = new Utf8StringHandle[framePathCount];

                try
                {
                    for (var i = 0; i < framePathCount; i += 1)
                    {
                        utf8Paths[i] = new Utf8StringHandle(framePaths[i]);
                    }

                    var pathPointers = new IntPtr[framePathCount];

                    for (var i = 0; i < framePathCount; i += 1)
                    {
                        pathPointers[i] = utf8Paths[i].DangerousGetHandle();
                    }

                    AsFbxSetFramePaths(context, pathPointers, framePathCount);
                }
                finally
                {
                    foreach (var path in utf8Paths)
                    {
                        path?.Dispose();
                    }
                }
            }
        }

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxSetFramePaths(IntPtr context, [MarshalAs(UnmanagedType.LPArray)] IntPtr[] strFramePaths, int count);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxExportScene(IntPtr context);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr AsFbxGetSceneRootNode(IntPtr context);

        private static IntPtr AsFbxExportSingleFrame(IntPtr context, IntPtr parentNode, string framePath, string frameName, in Vector3 localPosition, in Vector3 localRotation, in Vector3 localScale)
        {
            using (var framePathUtf8 = new Utf8StringHandle(framePath))
            {
                using (var frameNameUtf8 = new Utf8StringHandle(frameName))
                {
                    return AsFbxExportSingleFrame(context, parentNode, framePathUtf8.DangerousGetHandle(), frameNameUtf8.DangerousGetHandle(), localPosition.X, localPosition.Y, localPosition.Z, localRotation.X, localRotation.Y, localRotation.Z, localScale.X, localScale.Y, localScale.Z);
                }
            }
        }

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr AsFbxExportSingleFrame(IntPtr context, IntPtr parentNode, IntPtr strFramePath, IntPtr strFrameName, float localPositionX, float localPositionY, float localPositionZ, float localRotationX, float localRotationY, float localRotationZ, float localScaleX, float localScaleY, float localScaleZ);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxSetJointsNode_CastToBone(IntPtr context, IntPtr node, float boneSize);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxSetJointsNode_BoneInPath(IntPtr context, IntPtr node, float boneSize);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxSetJointsNode_Generic(IntPtr context, IntPtr node);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxPrepareMaterials(IntPtr context, int materialCount, int textureCount);

        private static IntPtr AsFbxCreateTexture(IntPtr context, string matTexName)
        {
            using (var matTexNameUtf8 = new Utf8StringHandle(matTexName))
            {
                return AsFbxCreateTexture(context, matTexNameUtf8.DangerousGetHandle());
            }
        }

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr AsFbxCreateTexture(IntPtr context, IntPtr strMatTexName);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxLinkTexture(int dest, IntPtr texture, IntPtr material, float offsetX, float offsetY, float scaleX, float scaleY);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr AsFbxMeshCreateClusterArray(int boneCount);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshDisposeClusterArray(ref IntPtr ppArray);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr AsFbxMeshCreateCluster(IntPtr context, IntPtr boneNode);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshAddCluster(IntPtr array, IntPtr cluster);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr AsFbxMeshCreateMesh(IntPtr context, IntPtr frameNode);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshInitControlPoints(IntPtr mesh, int vertexCount);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshCreateElementNormal(IntPtr mesh);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshCreateDiffuseUV(IntPtr mesh, int uv);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshCreateNormalMapUV(IntPtr mesh, int uv);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshCreateElementTangent(IntPtr mesh);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshCreateElementVertexColor(IntPtr mesh);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshCreateElementMaterial(IntPtr mesh);

        private static IntPtr AsFbxCreateMaterial(IntPtr pContext, string matName, in Color diffuse, in Color ambient, in Color emissive, in Color specular, in Color reflection, float shininess, float transparency)
        {
            using (var matNameUtf8 = new Utf8StringHandle(matName))
            {
                return AsFbxCreateMaterial(pContext, matNameUtf8.DangerousGetHandle(), diffuse.R, diffuse.G, diffuse.B, ambient.R, ambient.G, ambient.B, emissive.R, emissive.G, emissive.B, specular.R, specular.G, specular.B, reflection.R, reflection.G, reflection.B, shininess, transparency);
            }
        }

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr AsFbxCreateMaterial(IntPtr pContext, IntPtr pMatName,
            float diffuseR, float diffuseG, float diffuseB,
            float ambientR, float ambientG, float ambientB,
            float emissiveR, float emissiveG, float emissiveB,
            float specularR, float specularG, float specularB,
            float reflectR, float reflectG, float reflectB,
            float shininess, float transparency);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern int AsFbxAddMaterialToFrame(IntPtr frameNode, IntPtr material);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxSetFrameShadingModeToTextureShading(IntPtr frameNode);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshSetControlPoint(IntPtr mesh, int index, float x, float y, float z);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshAddPolygon(IntPtr mesh, int materialIndex, int index0, int index1, int index2);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshElementNormalAdd(IntPtr mesh, int elementIndex, float x, float y, float z);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshElementUVAdd(IntPtr mesh, int elementIndex, float u, float v);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshElementTangentAdd(IntPtr mesh, int elementIndex, float x, float y, float z, float w);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshElementVertexColorAdd(IntPtr mesh, int elementIndex, float r, float g, float b, float a);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshSetBoneWeight(IntPtr pClusterArray, int boneIndex, int vertexIndex, float weight);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr AsFbxMeshCreateSkinContext(IntPtr context, IntPtr frameNode);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshDisposeSkinContext(ref IntPtr ppSkinContext);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool FbxClusterArray_HasItemAt(IntPtr pClusterArray, int index);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private unsafe static extern void AsFbxMeshSkinAddCluster(IntPtr pSkinContext, IntPtr pClusterArray, int index, float* pBoneMatrix);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMeshAddDeformer(IntPtr pSkinContext, IntPtr pMesh);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr AsFbxAnimCreateContext([MarshalAs(UnmanagedType.Bool)] bool eulerFilter);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxAnimDisposeContext(ref IntPtr ppAnimContext);

        private static void AsFbxAnimPrepareStackAndLayer(IntPtr pContext, IntPtr pAnimContext, string takeName)
        {
            using (var takeNameUtf8 = new Utf8StringHandle(takeName))
            {
                AsFbxAnimPrepareStackAndLayer(pContext, pAnimContext, takeNameUtf8.DangerousGetHandle());
            }
        }

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxAnimPrepareStackAndLayer(IntPtr pContext, IntPtr pAnimContext, IntPtr strTakeName);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxAnimLoadCurves(IntPtr pNode, IntPtr pAnimContext);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxAnimBeginKeyModify(IntPtr pAnimContext);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxAnimEndKeyModify(IntPtr pAnimContext);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxAnimAddScalingKey(IntPtr pAnimContext, float time, float x, float y, float z);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxAnimAddRotationKey(IntPtr pAnimContext, float time, float x, float y, float z);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxAnimAddTranslationKey(IntPtr pAnimContext, float time, float x, float y, float z);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxAnimApplyEulerFilter(IntPtr pAnimContext, float filterPrecision);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern int AsFbxAnimGetCurrentBlendShapeChannelCount(IntPtr pAnimContext, IntPtr pNode);

        private static bool AsFbxAnimIsBlendShapeChannelMatch(IntPtr pAnimContext, int channelIndex, string channelName)
        {
            using (var channelNameUtf8 = new Utf8StringHandle(channelName))
            {
                return AsFbxAnimIsBlendShapeChannelMatch(pAnimContext, channelIndex, channelNameUtf8.DangerousGetHandle());
            }
        }

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool AsFbxAnimIsBlendShapeChannelMatch(IntPtr pAnimContext, int channelIndex, IntPtr strChannelName);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxAnimBeginBlendShapeAnimCurve(IntPtr pAnimContext, int channelIndex);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxAnimEndBlendShapeAnimCurve(IntPtr pAnimContext);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxAnimAddBlendShapeKeyframe(IntPtr pAnimContext, float time, float value);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern IntPtr AsFbxMorphCreateContext();

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMorphInitializeContext(IntPtr pContext, IntPtr pMorphContext, IntPtr pNode);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMorphDisposeContext(ref IntPtr ppMorphContext);

        private static void AsFbxMorphAddBlendShapeChannel(IntPtr pContext, IntPtr pMorphContext, string channelName)
        {
            using (var channelNameUtf8 = new Utf8StringHandle(channelName))
            {
                AsFbxMorphAddBlendShapeChannel(pContext, pMorphContext, channelNameUtf8.DangerousGetHandle());
            }
        }

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMorphAddBlendShapeChannel(IntPtr pContext, IntPtr pMorphContext, IntPtr strChannelName);

        private static void AsFbxMorphAddBlendShapeChannelShape(IntPtr pContext, IntPtr pMorphContext, float weight, string shapeName)
        {
            using (var shapeNameUtf8 = new Utf8StringHandle(shapeName))
            {
                AsFbxMorphAddBlendShapeChannelShape(pContext, pMorphContext, weight, shapeNameUtf8.DangerousGetHandle());
            }
        }

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMorphAddBlendShapeChannelShape(IntPtr pContext, IntPtr pMorphContext, float weight, IntPtr strShapeName);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMorphCopyBlendShapeControlPoints(IntPtr pMorphContext);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMorphSetBlendShapeVertex(IntPtr pMorphContext, uint index, float x, float y, float z);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMorphCopyBlendShapeControlPointsNormal(IntPtr pMorphContext);

        [DllImport(FbxDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void AsFbxMorphSetBlendShapeVertexNormal(IntPtr pMorphContext, uint index, float x, float y, float z);

    }
}

```

`AssetStudioFBXWrapper/FbxExporterContext.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;

namespace AssetStudio.FbxInterop
{
    internal sealed partial class FbxExporterContext : IDisposable
    {

        private IntPtr _pContext;
        private readonly Dictionary<ImportedFrame, IntPtr> _frameToNode;
        private readonly List<KeyValuePair<string, IntPtr>> _createdMaterials;
        private readonly Dictionary<string, IntPtr> _createdTextures;

        public FbxExporterContext()
        {
            _pContext = AsFbxCreateContext();
            _frameToNode = new Dictionary<ImportedFrame, IntPtr>();
            _createdMaterials = new List<KeyValuePair<string, IntPtr>>();
            _createdTextures = new Dictionary<string, IntPtr>();
        }

        ~FbxExporterContext()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            if (IsDisposed)
            {
                return;
            }

            Dispose(true);
            GC.SuppressFinalize(this);
        }

        public bool IsDisposed { get; private set; }

        private void Dispose(bool disposing)
        {
            IsDisposed = true;

            _frameToNode.Clear();
            _createdMaterials.Clear();
            _createdTextures.Clear();

            AsFbxDisposeContext(ref _pContext);
        }

        private void EnsureNotDisposed()
        {
            if (IsDisposed)
            {
                throw new ObjectDisposedException(nameof(FbxExporterContext));
            }
        }

        internal void Initialize(string fileName, float scaleFactor, int versionIndex, bool isAscii, bool is60Fps)
        {
            EnsureNotDisposed();

            var b = AsFbxInitializeContext(_pContext, fileName, scaleFactor, versionIndex, isAscii, is60Fps, out var errorMessage);

            if (!b)
            {
                var fullMessage = $"Failed to initialize FbxExporter: {errorMessage}";
                throw new ApplicationException(fullMessage);
            }
        }

        internal void SetFramePaths(HashSet<string> framePaths)
        {
            EnsureNotDisposed();

            if (framePaths == null || framePaths.Count == 0)
            {
                return;
            }

            var framePathList = new List<string>(framePaths);
            var framePathArray = framePathList.ToArray();

            AsFbxSetFramePaths(_pContext, framePathArray);
        }

        internal void ExportScene()
        {
            EnsureNotDisposed();

            AsFbxExportScene(_pContext);
        }

        internal void ExportFrame(List<ImportedMesh> meshList, List<ImportedFrame> meshFrames, ImportedFrame rootFrame)
        {
            var rootNode = AsFbxGetSceneRootNode(_pContext);

            Debug.Assert(rootNode != IntPtr.Zero);

            var nodeStack = new Stack<IntPtr>();
            var frameStack = new Stack<ImportedFrame>();

            nodeStack.Push(rootNode);
            frameStack.Push(rootFrame);

            while (nodeStack.Count > 0)
            {
                var parentNode = nodeStack.Pop();
                var frame = frameStack.Pop();

                var childNode = AsFbxExportSingleFrame(_pContext, parentNode, frame.Path, frame.Name, frame.LocalPosition, frame.LocalRotation, frame.LocalScale);

                if (meshList != null && ImportedHelpers.FindMesh(frame.Path, meshList) != null)
                {
                    meshFrames.Add(frame);
                }

                _frameToNode.Add(frame, childNode);

                for (var i = frame.Count - 1; i >= 0; i -= 1)
                {
                    nodeStack.Push(childNode);
                    frameStack.Push(frame[i]);
                }
            }
        }

        internal void SetJointsNode(ImportedFrame rootFrame, HashSet<string> bonePaths, bool castToBone, float boneSize)
        {
            var frameStack = new Stack<ImportedFrame>();

            frameStack.Push(rootFrame);

            while (frameStack.Count > 0)
            {
                var frame = frameStack.Pop();

                if (_frameToNode.TryGetValue(frame, out var node))
                {
                    Debug.Assert(node != IntPtr.Zero);

                    if (castToBone)
                    {
                        AsFbxSetJointsNode_CastToBone(_pContext, node, boneSize);
                    }
                    else
                    {
                        Debug.Assert(bonePaths != null);

                        if (bonePaths.Contains(frame.Path))
                        {
                            AsFbxSetJointsNode_BoneInPath(_pContext, node, boneSize);
                        }
                        else
                        {
                            AsFbxSetJointsNode_Generic(_pContext, node);
                        }
                    }
                }

                for (var i = frame.Count - 1; i >= 0; i -= 1)
                {
                    frameStack.Push(frame[i]);
                }
            }
        }

        internal void PrepareMaterials(int materialCount, int textureCount)
        {
            AsFbxPrepareMaterials(_pContext, materialCount, textureCount);
        }

        internal void ExportMeshFromFrame(ImportedFrame rootFrame, ImportedFrame meshFrame, List<ImportedMesh> meshList, List<ImportedMaterial> materialList, List<ImportedTexture> textureList, bool exportSkins, bool exportAllUvsAsDiffuseMaps)
        {
            var meshNode = _frameToNode[meshFrame];
            var mesh = ImportedHelpers.FindMesh(meshFrame.Path, meshList);

            ExportMesh(rootFrame, materialList, textureList, meshNode, mesh, exportSkins, exportAllUvsAsDiffuseMaps);
        }

        private IntPtr ExportTexture(ImportedTexture texture)
        {
            if (texture == null)
            {
                return IntPtr.Zero;
            }

            if (_createdTextures.ContainsKey(texture.Name))
            {
                return _createdTextures[texture.Name];
            }

            var pTex = AsFbxCreateTexture(_pContext, texture.Name);

            _createdTextures.Add(texture.Name, pTex);

            var file = new FileInfo(texture.Name);

            using (var writer = new BinaryWriter(file.Create()))
            {
                writer.Write(texture.Data);
            }

            return pTex;
        }

        private void ExportMesh(ImportedFrame rootFrame, List<ImportedMaterial> materialList, List<ImportedTexture> textureList, IntPtr frameNode, ImportedMesh importedMesh, bool exportSkins, bool exportAllUvsAsDiffuseMaps)
        {
            var boneList = importedMesh.BoneList;
            var totalBoneCount = 0;
            var hasBones = false;
            if (exportSkins && boneList?.Count > 0)
            {
                totalBoneCount = boneList.Count;
                hasBones = true;
            }

            var pClusterArray = IntPtr.Zero;

            try
            {
                if (hasBones)
                {
                    pClusterArray = AsFbxMeshCreateClusterArray(totalBoneCount);

                    foreach (var bone in boneList)
                    {
                        if (bone.Path != null)
                        {
                            var frame = rootFrame.FindFrameByPath(bone.Path);
                            var boneNode = _frameToNode[frame];

                            var cluster = AsFbxMeshCreateCluster(_pContext, boneNode);

                            AsFbxMeshAddCluster(pClusterArray, cluster);
                        }
                        else
                        {
                            AsFbxMeshAddCluster(pClusterArray, IntPtr.Zero);
                        }
                    }
                }

                var mesh = AsFbxMeshCreateMesh(_pContext, frameNode);

                AsFbxMeshInitControlPoints(mesh, importedMesh.VertexList.Count);

                if (importedMesh.hasNormal)
                {
                    AsFbxMeshCreateElementNormal(mesh);
                }

                for (int i = 0; i < importedMesh.hasUV.Length; i++)
                {
                    if (!importedMesh.hasUV[i]) { continue; }

                    if (i == 1 && !exportAllUvsAsDiffuseMaps)
                    {
                        AsFbxMeshCreateNormalMapUV(mesh, 1);
                    }
                    else
                    {
                        AsFbxMeshCreateDiffuseUV(mesh, i);
                    }
                }

                if (importedMesh.hasTangent)
                {
                    AsFbxMeshCreateElementTangent(mesh);
                }

                if (importedMesh.hasColor)
                {
                    AsFbxMeshCreateElementVertexColor(mesh);
                }

                AsFbxMeshCreateElementMaterial(mesh);

                foreach (var meshObj in importedMesh.SubmeshList)
                {
                    var materialIndex = 0;
                    var mat = ImportedHelpers.FindMaterial(meshObj.Material, materialList);

                    if (mat != null)
                    {
                        var foundMat = _createdMaterials.FindIndex(kv => kv.Key == mat.Name);
                        IntPtr pMat;

                        if (foundMat >= 0)
                        {
                            pMat = _createdMaterials[foundMat].Value;
                        }
                        else
                        {
                            var diffuse = mat.Diffuse;
                            var ambient = mat.Ambient;
                            var emissive = mat.Emissive;
                            var specular = mat.Specular;
                            var reflection = mat.Reflection;

                            pMat = AsFbxCreateMaterial(_pContext, mat.Name, in diffuse, in ambient, in emissive, in specular, in reflection, mat.Shininess, mat.Transparency);

                            _createdMaterials.Add(new KeyValuePair<string, IntPtr>(mat.Name, pMat));
                        }

                        materialIndex = AsFbxAddMaterialToFrame(frameNode, pMat);

                        var hasTexture = false;

                        foreach (var texture in mat.Textures)
                        {
                            var tex = ImportedHelpers.FindTexture(texture.Name, textureList);
                            var pTexture = ExportTexture(tex);

                            if (pTexture != IntPtr.Zero)
                            {
                                switch (texture.Dest)
                                {
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                        {
                                            AsFbxLinkTexture(texture.Dest, pTexture, pMat, texture.Offset.X, texture.Offset.Y, texture.Scale.X, texture.Scale.Y);
                                            hasTexture = true;
                                            break;
                                        }
                                    default:
                                        break;
                                }
                            }
                        }

                        if (hasTexture)
                        {
                            AsFbxSetFrameShadingModeToTextureShading(frameNode);
                        }
                    }

                    foreach (var face in meshObj.FaceList)
                    {
                        var index0 = face.VertexIndices[0] + meshObj.BaseVertex;
                        var index1 = face.VertexIndices[1] + meshObj.BaseVertex;
                        var index2 = face.VertexIndices[2] + meshObj.BaseVertex;

                        AsFbxMeshAddPolygon(mesh, materialIndex, index0, index1, index2);
                    }
                }

                var vertexList = importedMesh.VertexList;

                var vertexCount = vertexList.Count;

                for (var j = 0; j < vertexCount; j += 1)
                {
                    var importedVertex = vertexList[j];

                    var vertex = importedVertex.Vertex;
                    AsFbxMeshSetControlPoint(mesh, j, vertex.X, vertex.Y, vertex.Z);

                    if (importedMesh.hasNormal)
                    {
                        var normal = importedVertex.Normal;
                        AsFbxMeshElementNormalAdd(mesh, 0, normal.X, normal.Y, normal.Z);
                    }

                    for (var uvIndex = 0; uvIndex < importedMesh.hasUV.Length; uvIndex += 1)
                    {
                        if (importedMesh.hasUV[uvIndex])
                        {
                            var uv = importedVertex.UV[uvIndex];
                            AsFbxMeshElementUVAdd(mesh, uvIndex, uv[0], uv[1]);
                        }
                    }

                    if (importedMesh.hasTangent)
                    {
                        var tangent = importedVertex.Tangent;
                        AsFbxMeshElementTangentAdd(mesh, 0, tangent.X, tangent.Y, tangent.Z, tangent.W);
                    }

                    if (importedMesh.hasColor)
                    {
                        var color = importedVertex.Color;
                        AsFbxMeshElementVertexColorAdd(mesh, 0, color.R, color.G, color.B, color.A);
                    }

                    if (hasBones && importedVertex.BoneIndices != null)
                    {
                        var boneIndices = importedVertex.BoneIndices;
                        var boneWeights = importedVertex.Weights;

                        for (var k = 0; k < 4; k += 1)
                        {
                            if (boneIndices[k] < totalBoneCount && boneWeights[k] > 0)
                            {
                                AsFbxMeshSetBoneWeight(pClusterArray, boneIndices[k], j, boneWeights[k]);
                            }
                        }
                    }
                }


                if (hasBones)
                {
                    IntPtr pSkinContext = IntPtr.Zero;

                    try
                    {
                        pSkinContext = AsFbxMeshCreateSkinContext(_pContext, frameNode);

                        unsafe
                        {
                            var boneMatrix = stackalloc float[16];

                            for (var j = 0; j < totalBoneCount; j += 1)
                            {
                                if (!FbxClusterArray_HasItemAt(pClusterArray, j))
                                {
                                    continue;
                                }

                                var m = boneList[j].Matrix;

                                CopyMatrix4x4(in m, boneMatrix);

                                AsFbxMeshSkinAddCluster(pSkinContext, pClusterArray, j, boneMatrix);
                            }
                        }

                        AsFbxMeshAddDeformer(pSkinContext, mesh);
                    }
                    finally
                    {
                        AsFbxMeshDisposeSkinContext(ref pSkinContext);
                    }
                }
            }
            finally
            {
                AsFbxMeshDisposeClusterArray(ref pClusterArray);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static unsafe void CopyMatrix4x4(in Matrix4x4 matrix, float* buffer)
        {
            for (var m = 0; m < 4; m += 1)
            {
                for (var n = 0; n < 4; n += 1)
                {
                    var index = IndexFrom4x4(m, n);
                    buffer[index] = matrix[m, n];
                }
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int IndexFrom4x4(int m, int n)
        {
            return 4 * m + n;
        }

        internal void ExportAnimations(ImportedFrame rootFrame, List<ImportedKeyframedAnimation> animationList, bool eulerFilter, float filterPrecision)
        {
            if (animationList == null || animationList.Count == 0)
            {
                return;
            }

            var pAnimContext = IntPtr.Zero;

            try
            {
                pAnimContext = AsFbxAnimCreateContext(eulerFilter);

                for (int i = 0; i < animationList.Count; i++)
                {
                    var importedAnimation = animationList[i];
                    string takeName;

                    if (importedAnimation.Name != null)
                    {
                        takeName = importedAnimation.Name;
                    }
                    else
                    {
                        takeName = $"Take{i.ToString()}";
                    }

                    AsFbxAnimPrepareStackAndLayer(_pContext, pAnimContext, takeName);

                    ExportKeyframedAnimation(rootFrame, importedAnimation, pAnimContext, filterPrecision);
                }
            }
            finally
            {
                AsFbxAnimDisposeContext(ref pAnimContext);
            }
        }

        private void ExportKeyframedAnimation(ImportedFrame rootFrame, ImportedKeyframedAnimation parser, IntPtr pAnimContext, float filterPrecision)
        {
            foreach (var track in parser.TrackList)
            {
                if (track.Path == null)
                {
                    continue;
                }

                var frame = rootFrame.FindFrameByPath(track.Path);

                if (frame == null)
                {
                    continue;
                }

                var pNode = _frameToNode[frame];

                AsFbxAnimLoadCurves(pNode, pAnimContext);

                AsFbxAnimBeginKeyModify(pAnimContext);

                foreach (var scaling in track.Scalings)
                {
                    var value = scaling.value;
                    AsFbxAnimAddScalingKey(pAnimContext, scaling.time, value.X, value.Y, value.Z);
                }

                foreach (var rotation in track.Rotations)
                {
                    var value = rotation.value;
                    AsFbxAnimAddRotationKey(pAnimContext, rotation.time, value.X, value.Y, value.Z);
                }

                foreach (var translation in track.Translations)
                {
                    var value = translation.value;
                    AsFbxAnimAddTranslationKey(pAnimContext, translation.time, value.X, value.Y, value.Z);
                }

                AsFbxAnimEndKeyModify(pAnimContext);

                AsFbxAnimApplyEulerFilter(pAnimContext, filterPrecision);

                var blendShape = track.BlendShape;

                if (blendShape != null)
                {
                    var channelCount = AsFbxAnimGetCurrentBlendShapeChannelCount(pAnimContext, pNode);

                    if (channelCount > 0)
                    {
                        for (var channelIndex = 0; channelIndex < channelCount; channelIndex += 1)
                        {
                            if (!AsFbxAnimIsBlendShapeChannelMatch(pAnimContext, channelIndex, blendShape.ChannelName))
                            {
                                continue;
                            }

                            AsFbxAnimBeginBlendShapeAnimCurve(pAnimContext, channelIndex);

                            foreach (var keyframe in blendShape.Keyframes)
                            {
                                AsFbxAnimAddBlendShapeKeyframe(pAnimContext, keyframe.time, keyframe.value);
                            }

                            AsFbxAnimEndBlendShapeAnimCurve(pAnimContext);
                        }
                    }
                }
            }
        }

        internal void ExportMorphs(ImportedFrame rootFrame, List<ImportedMorph> morphList)
        {
            if (morphList == null || morphList.Count == 0)
            {
                return;
            }

            foreach (var morph in morphList)
            {
                var frame = rootFrame.FindFrameByPath(morph.Path);

                if (frame == null)
                {
                    continue;
                }

                var pNode = _frameToNode[frame];

                var pMorphContext = IntPtr.Zero;

                try
                {
                    pMorphContext = AsFbxMorphCreateContext();

                    AsFbxMorphInitializeContext(_pContext, pMorphContext, pNode);

                    foreach (var channel in morph.Channels)
                    {
                        AsFbxMorphAddBlendShapeChannel(_pContext, pMorphContext, channel.Name);

                        for (var i = 0; i < channel.KeyframeList.Count; i++)
                        {
                            var keyframe = channel.KeyframeList[i];

                            AsFbxMorphAddBlendShapeChannelShape(_pContext, pMorphContext, keyframe.Weight, i == 0 ? channel.Name : $"{channel.Name}_{i + 1}");

                            AsFbxMorphCopyBlendShapeControlPoints(pMorphContext);

                            foreach (var vertex in keyframe.VertexList)
                            {
                                var v = vertex.Vertex.Vertex;
                                AsFbxMorphSetBlendShapeVertex(pMorphContext, vertex.Index, v.X, v.Y, v.Z);
                            }

                            if (keyframe.hasNormals)
                            {
                                AsFbxMorphCopyBlendShapeControlPointsNormal(pMorphContext);

                                foreach (var vertex in keyframe.VertexList)
                                {
                                    var v = vertex.Vertex.Normal;
                                    AsFbxMorphSetBlendShapeVertexNormal(pMorphContext, vertex.Index, v.X, v.Y, v.Z);
                                }
                            }
                        }
                    }
                }
                finally
                {
                    AsFbxMorphDisposeContext(ref pMorphContext);
                }
            }
        }

    }
}

```

`AssetStudioGUI/AssetStudioGUI.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>WinExe</OutputType>
		<TargetFrameworks>net472;net5.0-windows;net6.0-windows</TargetFrameworks>
		<UseWindowsForms>true</UseWindowsForms>
		<ApplicationIcon>Resources\as.ico</ApplicationIcon>
		<Version>0.16.0.0</Version>
		<AssemblyVersion>0.16.0.0</AssemblyVersion>
		<FileVersion>0.16.0.0</FileVersion>
		<Copyright>Copyright © Perfare 2018-2022</Copyright>
		<DebugType>embedded</DebugType>
	</PropertyGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetStudioUtility\AssetStudioUtility.csproj" />
		<ProjectReference Include="..\AssetStudio\AssetStudio.csproj" />
	</ItemGroup>

	<ItemGroup>
		<None Include="Properties\Settings.settings">
			<Generator>SettingsSingleFileGenerator</Generator>
			<LastGenOutput>Settings.Designer.cs</LastGenOutput>
		</None>
		<Compile Update="Properties\Settings.Designer.cs">
			<AutoGen>True</AutoGen>
			<DependentUpon>Settings.settings</DependentUpon>
			<DesignTimeSharedInput>True</DesignTimeSharedInput>
		</Compile>
	</ItemGroup>

	<ItemGroup>
		<EmbeddedResource Update="Properties\Resources.resx">
			<Generator>ResXFileCodeGenerator</Generator>
			<LastGenOutput>Resources.Designer.cs</LastGenOutput>
		</EmbeddedResource>
		<Compile Update="Properties\Resources.Designer.cs">
			<AutoGen>True</AutoGen>
			<DependentUpon>Resources.resx</DependentUpon>
			<DesignTime>True</DesignTime>
		</Compile>
	</ItemGroup>

	<ItemGroup>
		<ContentWithTargetPath Include="Libraries\x86\fmod.dll">
			<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
			<TargetPath>x86\fmod.dll</TargetPath>
		</ContentWithTargetPath>
		<ContentWithTargetPath Include="Libraries\x64\fmod.dll">
			<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
			<TargetPath>x64\fmod.dll</TargetPath>
		</ContentWithTargetPath>
	</ItemGroup>

	<ItemGroup Condition=" '$(TargetFramework)' != 'net472' ">
		<PackageReference Include="OpenTK" Version="4.6.7" />
		<Reference Include="OpenTK.WinForms">
			<HintPath>Libraries\OpenTK.WinForms.dll</HintPath>
		</Reference>
	</ItemGroup>

	<ItemGroup Condition=" '$(TargetFramework)' == 'net472' ">
		<PackageReference Include="OpenTK" Version="3.1.0" />
		<PackageReference Include="OpenTK.GLControl" Version="3.1.0" />
	</ItemGroup>

	<ItemGroup>
		<PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
	</ItemGroup>

	<Target Name="CopyExtraFiles" AfterTargets="AfterBuild">
		<Copy SourceFiles="$(SolutionDir)AssetStudioFBXNative\bin\Win32\$(Configuration)\AssetStudioFBXNative.dll" DestinationFolder="$(TargetDir)x86" ContinueOnError="true" />
		<Copy SourceFiles="$(SolutionDir)AssetStudioFBXNative\bin\x64\$(Configuration)\AssetStudioFBXNative.dll" DestinationFolder="$(TargetDir)x64" ContinueOnError="true" />
		<Copy SourceFiles="$(SolutionDir)Texture2DDecoderNative\bin\Win32\$(Configuration)\Texture2DDecoderNative.dll" DestinationFolder="$(TargetDir)x86" ContinueOnError="true" />
		<Copy SourceFiles="$(SolutionDir)Texture2DDecoderNative\bin\x64\$(Configuration)\Texture2DDecoderNative.dll" DestinationFolder="$(TargetDir)x64" ContinueOnError="true" />
	</Target>

	<Target Name="PublishExtraFiles" AfterTargets="Publish">
		<Copy SourceFiles="$(TargetDir)x86\AssetStudioFBXNative.dll" DestinationFolder="$(PublishDir)x86" ContinueOnError="true" />
		<Copy SourceFiles="$(TargetDir)x64\AssetStudioFBXNative.dll" DestinationFolder="$(PublishDir)x64" ContinueOnError="true" />
		<Copy SourceFiles="$(TargetDir)x86\Texture2DDecoderNative.dll" DestinationFolder="$(PublishDir)x86" ContinueOnError="true" />
		<Copy SourceFiles="$(TargetDir)x64\Texture2DDecoderNative.dll" DestinationFolder="$(PublishDir)x64" ContinueOnError="true" />
	</Target>
</Project>
```

`AssetStudioGUI/AssetStudioGUIForm.Designer.cs`:

```cs
namespace AssetStudioGUI
{
    partial class AssetStudioGUIForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AssetStudioGUIForm));
            this.menuStrip1 = new System.Windows.Forms.MenuStrip();
            this.fileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.loadFileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.loadFolderToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem1 = new System.Windows.Forms.ToolStripSeparator();
            this.extractFileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.extractFolderToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.optionsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.displayAll = new System.Windows.Forms.ToolStripMenuItem();
            this.enablePreview = new System.Windows.Forms.ToolStripMenuItem();
            this.displayInfo = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem14 = new System.Windows.Forms.ToolStripMenuItem();
            this.specifyUnityVersion = new System.Windows.Forms.ToolStripTextBox();
            this.showExpOpt = new System.Windows.Forms.ToolStripMenuItem();
            this.modelToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.exportAllObjectssplitToolStripMenuItem1 = new System.Windows.Forms.ToolStripMenuItem();
            this.exportSelectedObjectsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.exportSelectedObjectsWithAnimationClipToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
            this.exportSelectedObjectsmergeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.exportSelectedObjectsmergeWithAnimationClipToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.exportToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.exportAllAssetsMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.exportSelectedAssetsMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.exportFilteredAssetsMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator3 = new System.Windows.Forms.ToolStripSeparator();
            this.exportAnimatorWithSelectedAnimationClipToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator4 = new System.Windows.Forms.ToolStripSeparator();
            this.toolStripMenuItem2 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem4 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem5 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem6 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem3 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem7 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem8 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem9 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
            this.toolStripMenuItem10 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem11 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem12 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem13 = new System.Windows.Forms.ToolStripMenuItem();
            this.filterTypeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.allToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.debugMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripMenuItem15 = new System.Windows.Forms.ToolStripMenuItem();
            this.exportClassStructuresMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.splitContainer1 = new System.Windows.Forms.SplitContainer();
            this.tabControl1 = new System.Windows.Forms.TabControl();
            this.tabPage1 = new System.Windows.Forms.TabPage();
            this.sceneTreeView = new AssetStudioGUI.GOHierarchy();
            this.treeSearch = new System.Windows.Forms.TextBox();
            this.tabPage2 = new System.Windows.Forms.TabPage();
            this.assetListView = new System.Windows.Forms.ListView();
            this.columnHeaderName = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.columnHeaderContainer = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.columnHeaderType = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.columnHeaderPathID = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.columnHeaderSize = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.listSearch = new System.Windows.Forms.TextBox();
            this.tabPage3 = new System.Windows.Forms.TabPage();
            this.classesListView = new System.Windows.Forms.ListView();
            this.columnHeader1 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.columnHeader2 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.progressbarPanel = new System.Windows.Forms.Panel();
            this.progressBar1 = new System.Windows.Forms.ProgressBar();
            this.tabControl2 = new System.Windows.Forms.TabControl();
            this.tabPage4 = new System.Windows.Forms.TabPage();
            this.previewPanel = new System.Windows.Forms.Panel();
            this.assetInfoLabel = new System.Windows.Forms.Label();
            this.FMODpanel = new System.Windows.Forms.Panel();
            this.FMODcopyright = new System.Windows.Forms.Label();
            this.FMODinfoLabel = new System.Windows.Forms.Label();
            this.FMODtimerLabel = new System.Windows.Forms.Label();
            this.FMODstatusLabel = new System.Windows.Forms.Label();
            this.FMODprogressBar = new System.Windows.Forms.TrackBar();
            this.FMODvolumeBar = new System.Windows.Forms.TrackBar();
            this.FMODloopButton = new System.Windows.Forms.CheckBox();
            this.FMODstopButton = new System.Windows.Forms.Button();
            this.FMODpauseButton = new System.Windows.Forms.Button();
            this.FMODplayButton = new System.Windows.Forms.Button();
            this.fontPreviewBox = new System.Windows.Forms.RichTextBox();
            this.glControl1 = new OpenTK.GLControl();
            this.textPreviewBox = new System.Windows.Forms.TextBox();
            this.classTextBox = new System.Windows.Forms.TextBox();
            this.tabPage5 = new System.Windows.Forms.TabPage();
            this.dumpTextBox = new System.Windows.Forms.TextBox();
            this.statusStrip1 = new System.Windows.Forms.StatusStrip();
            this.toolStripStatusLabel1 = new System.Windows.Forms.ToolStripStatusLabel();
            this.timer = new System.Windows.Forms.Timer(this.components);
            this.openFileDialog1 = new System.Windows.Forms.OpenFileDialog();
            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.copyToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.exportSelectedAssetsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.exportAnimatorwithselectedAnimationClipMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.goToSceneHierarchyToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.showOriginalFileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.menuStrip1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();
            this.splitContainer1.Panel1.SuspendLayout();
            this.splitContainer1.Panel2.SuspendLayout();
            this.splitContainer1.SuspendLayout();
            this.tabControl1.SuspendLayout();
            this.tabPage1.SuspendLayout();
            this.tabPage2.SuspendLayout();
            this.tabPage3.SuspendLayout();
            this.progressbarPanel.SuspendLayout();
            this.tabControl2.SuspendLayout();
            this.tabPage4.SuspendLayout();
            this.previewPanel.SuspendLayout();
            this.FMODpanel.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.FMODprogressBar)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.FMODvolumeBar)).BeginInit();
            this.tabPage5.SuspendLayout();
            this.statusStrip1.SuspendLayout();
            this.contextMenuStrip1.SuspendLayout();
            this.SuspendLayout();
            // 
            // menuStrip1
            // 
            this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fileToolStripMenuItem,
            this.optionsToolStripMenuItem,
            this.modelToolStripMenuItem,
            this.exportToolStripMenuItem,
            this.filterTypeToolStripMenuItem,
            this.debugMenuItem});
            this.menuStrip1.Location = new System.Drawing.Point(0, 0);
            this.menuStrip1.Name = "menuStrip1";
            this.menuStrip1.Size = new System.Drawing.Size(1264, 25);
            this.menuStrip1.TabIndex = 0;
            this.menuStrip1.Text = "menuStrip1";
            // 
            // fileToolStripMenuItem
            // 
            this.fileToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.loadFileToolStripMenuItem,
            this.loadFolderToolStripMenuItem,
            this.toolStripMenuItem1,
            this.extractFileToolStripMenuItem,
            this.extractFolderToolStripMenuItem});
            this.fileToolStripMenuItem.Name = "fileToolStripMenuItem";
            this.fileToolStripMenuItem.Size = new System.Drawing.Size(39, 21);
            this.fileToolStripMenuItem.Text = "File";
            // 
            // loadFileToolStripMenuItem
            // 
            this.loadFileToolStripMenuItem.Name = "loadFileToolStripMenuItem";
            this.loadFileToolStripMenuItem.Size = new System.Drawing.Size(154, 22);
            this.loadFileToolStripMenuItem.Text = "Load file";
            this.loadFileToolStripMenuItem.Click += new System.EventHandler(this.loadFile_Click);
            // 
            // loadFolderToolStripMenuItem
            // 
            this.loadFolderToolStripMenuItem.Name = "loadFolderToolStripMenuItem";
            this.loadFolderToolStripMenuItem.Size = new System.Drawing.Size(154, 22);
            this.loadFolderToolStripMenuItem.Text = "Load folder";
            this.loadFolderToolStripMenuItem.Click += new System.EventHandler(this.loadFolder_Click);
            // 
            // toolStripMenuItem1
            // 
            this.toolStripMenuItem1.Name = "toolStripMenuItem1";
            this.toolStripMenuItem1.Size = new System.Drawing.Size(151, 6);
            // 
            // extractFileToolStripMenuItem
            // 
            this.extractFileToolStripMenuItem.Name = "extractFileToolStripMenuItem";
            this.extractFileToolStripMenuItem.Size = new System.Drawing.Size(154, 22);
            this.extractFileToolStripMenuItem.Text = "Extract file";
            this.extractFileToolStripMenuItem.Click += new System.EventHandler(this.extractFileToolStripMenuItem_Click);
            // 
            // extractFolderToolStripMenuItem
            // 
            this.extractFolderToolStripMenuItem.Name = "extractFolderToolStripMenuItem";
            this.extractFolderToolStripMenuItem.Size = new System.Drawing.Size(154, 22);
            this.extractFolderToolStripMenuItem.Text = "Extract folder";
            this.extractFolderToolStripMenuItem.Click += new System.EventHandler(this.extractFolderToolStripMenuItem_Click);
            // 
            // optionsToolStripMenuItem
            // 
            this.optionsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.displayAll,
            this.enablePreview,
            this.displayInfo,
            this.toolStripMenuItem14,
            this.showExpOpt});
            this.optionsToolStripMenuItem.Name = "optionsToolStripMenuItem";
            this.optionsToolStripMenuItem.Size = new System.Drawing.Size(66, 21);
            this.optionsToolStripMenuItem.Text = "Options";
            // 
            // displayAll
            // 
            this.displayAll.CheckOnClick = true;
            this.displayAll.Name = "displayAll";
            this.displayAll.Size = new System.Drawing.Size(223, 22);
            this.displayAll.Text = "Display all assets";
            this.displayAll.ToolTipText = "Check this option will display all types assets. Not extractable assets can expor" +
    "t the RAW file.";
            this.displayAll.CheckedChanged += new System.EventHandler(this.displayAll_CheckedChanged);
            // 
            // enablePreview
            // 
            this.enablePreview.Checked = true;
            this.enablePreview.CheckOnClick = true;
            this.enablePreview.CheckState = System.Windows.Forms.CheckState.Checked;
            this.enablePreview.Name = "enablePreview";
            this.enablePreview.Size = new System.Drawing.Size(223, 22);
            this.enablePreview.Text = "Enable preview";
            this.enablePreview.ToolTipText = "Toggle the loading and preview of readable assets, such as images, sounds, text, " +
    "etc.\r\nDisable preview if you have performance or compatibility issues.";
            this.enablePreview.CheckedChanged += new System.EventHandler(this.enablePreview_Check);
            // 
            // displayInfo
            // 
            this.displayInfo.Checked = true;
            this.displayInfo.CheckOnClick = true;
            this.displayInfo.CheckState = System.Windows.Forms.CheckState.Checked;
            this.displayInfo.Name = "displayInfo";
            this.displayInfo.Size = new System.Drawing.Size(223, 22);
            this.displayInfo.Text = "Display asset infromation";
            this.displayInfo.ToolTipText = "Toggle the overlay that shows information about each asset, eg. image size, forma" +
    "t, audio bitrate, etc.";
            this.displayInfo.CheckedChanged += new System.EventHandler(this.displayAssetInfo_Check);
            // 
            // toolStripMenuItem14
            // 
            this.toolStripMenuItem14.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.specifyUnityVersion});
            this.toolStripMenuItem14.Name = "toolStripMenuItem14";
            this.toolStripMenuItem14.Size = new System.Drawing.Size(223, 22);
            this.toolStripMenuItem14.Text = "Specify Unity version";
            // 
            // specifyUnityVersion
            // 
            this.specifyUnityVersion.Font = new System.Drawing.Font("Microsoft YaHei UI", 9F);
            this.specifyUnityVersion.Name = "specifyUnityVersion";
            this.specifyUnityVersion.Size = new System.Drawing.Size(100, 23);
            // 
            // showExpOpt
            // 
            this.showExpOpt.Name = "showExpOpt";
            this.showExpOpt.Size = new System.Drawing.Size(223, 22);
            this.showExpOpt.Text = "Export options";
            this.showExpOpt.Click += new System.EventHandler(this.showExpOpt_Click);
            // 
            // modelToolStripMenuItem
            // 
            this.modelToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.exportAllObjectssplitToolStripMenuItem1,
            this.exportSelectedObjectsToolStripMenuItem,
            this.exportSelectedObjectsWithAnimationClipToolStripMenuItem,
            this.toolStripSeparator1,
            this.exportSelectedObjectsmergeToolStripMenuItem,
            this.exportSelectedObjectsmergeWithAnimationClipToolStripMenuItem});
            this.modelToolStripMenuItem.Name = "modelToolStripMenuItem";
            this.modelToolStripMenuItem.Size = new System.Drawing.Size(58, 21);
            this.modelToolStripMenuItem.Text = "Model";
            // 
            // exportAllObjectssplitToolStripMenuItem1
            // 
            this.exportAllObjectssplitToolStripMenuItem1.Name = "exportAllObjectssplitToolStripMenuItem1";
            this.exportAllObjectssplitToolStripMenuItem1.Size = new System.Drawing.Size(417, 22);
            this.exportAllObjectssplitToolStripMenuItem1.Text = "Export all objects (split)";
            this.exportAllObjectssplitToolStripMenuItem1.Click += new System.EventHandler(this.exportAllObjectssplitToolStripMenuItem1_Click);
            // 
            // exportSelectedObjectsToolStripMenuItem
            // 
            this.exportSelectedObjectsToolStripMenuItem.Name = "exportSelectedObjectsToolStripMenuItem";
            this.exportSelectedObjectsToolStripMenuItem.Size = new System.Drawing.Size(417, 22);
            this.exportSelectedObjectsToolStripMenuItem.Text = "Export selected objects (split)";
            this.exportSelectedObjectsToolStripMenuItem.Click += new System.EventHandler(this.exportSelectedObjectsToolStripMenuItem_Click);
            // 
            // exportSelectedObjectsWithAnimationClipToolStripMenuItem
            // 
            this.exportSelectedObjectsWithAnimationClipToolStripMenuItem.Name = "exportSelectedObjectsWithAnimationClipToolStripMenuItem";
            this.exportSelectedObjectsWithAnimationClipToolStripMenuItem.Size = new System.Drawing.Size(417, 22);
            this.exportSelectedObjectsWithAnimationClipToolStripMenuItem.Text = "Export selected objects (split) + selected AnimationClips";
            this.exportSelectedObjectsWithAnimationClipToolStripMenuItem.Click += new System.EventHandler(this.exportObjectswithAnimationClipMenuItem_Click);
            // 
            // toolStripSeparator1
            // 
            this.toolStripSeparator1.Name = "toolStripSeparator1";
            this.toolStripSeparator1.Size = new System.Drawing.Size(414, 6);
            // 
            // exportSelectedObjectsmergeToolStripMenuItem
            // 
            this.exportSelectedObjectsmergeToolStripMenuItem.Name = "exportSelectedObjectsmergeToolStripMenuItem";
            this.exportSelectedObjectsmergeToolStripMenuItem.Size = new System.Drawing.Size(417, 22);
            this.exportSelectedObjectsmergeToolStripMenuItem.Text = "Export selected objects (merge)";
            this.exportSelectedObjectsmergeToolStripMenuItem.Click += new System.EventHandler(this.exportSelectedObjectsmergeToolStripMenuItem_Click);
            // 
            // exportSelectedObjectsmergeWithAnimationClipToolStripMenuItem
            // 
            this.exportSelectedObjectsmergeWithAnimationClipToolStripMenuItem.Name = "exportSelectedObjectsmergeWithAnimationClipToolStripMenuItem";
            this.exportSelectedObjectsmergeWithAnimationClipToolStripMenuItem.Size = new System.Drawing.Size(417, 22);
            this.exportSelectedObjectsmergeWithAnimationClipToolStripMenuItem.Text = "Export selected objects (merge) + selected AnimationClips";
            this.exportSelectedObjectsmergeWithAnimationClipToolStripMenuItem.Click += new System.EventHandler(this.exportSelectedObjectsmergeWithAnimationClipToolStripMenuItem_Click);
            // 
            // exportToolStripMenuItem
            // 
            this.exportToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.exportAllAssetsMenuItem,
            this.exportSelectedAssetsMenuItem,
            this.exportFilteredAssetsMenuItem,
            this.toolStripSeparator3,
            this.exportAnimatorWithSelectedAnimationClipToolStripMenuItem,
            this.toolStripSeparator4,
            this.toolStripMenuItem2,
            this.toolStripMenuItem3,
            this.toolStripSeparator2,
            this.toolStripMenuItem10});
            this.exportToolStripMenuItem.Name = "exportToolStripMenuItem";
            this.exportToolStripMenuItem.Size = new System.Drawing.Size(58, 21);
            this.exportToolStripMenuItem.Text = "Export";
            // 
            // exportAllAssetsMenuItem
            // 
            this.exportAllAssetsMenuItem.Name = "exportAllAssetsMenuItem";
            this.exportAllAssetsMenuItem.Size = new System.Drawing.Size(284, 22);
            this.exportAllAssetsMenuItem.Text = "All assets";
            this.exportAllAssetsMenuItem.Click += new System.EventHandler(this.exportAllAssetsMenuItem_Click);
            // 
            // exportSelectedAssetsMenuItem
            // 
            this.exportSelectedAssetsMenuItem.Name = "exportSelectedAssetsMenuItem";
            this.exportSelectedAssetsMenuItem.Size = new System.Drawing.Size(284, 22);
            this.exportSelectedAssetsMenuItem.Text = "Selected assets";
            this.exportSelectedAssetsMenuItem.Click += new System.EventHandler(this.exportSelectedAssetsMenuItem_Click);
            // 
            // exportFilteredAssetsMenuItem
            // 
            this.exportFilteredAssetsMenuItem.Name = "exportFilteredAssetsMenuItem";
            this.exportFilteredAssetsMenuItem.Size = new System.Drawing.Size(284, 22);
            this.exportFilteredAssetsMenuItem.Text = "Filtered assets";
            this.exportFilteredAssetsMenuItem.Click += new System.EventHandler(this.exportFilteredAssetsMenuItem_Click);
            // 
            // toolStripSeparator3
            // 
            this.toolStripSeparator3.Name = "toolStripSeparator3";
            this.toolStripSeparator3.Size = new System.Drawing.Size(281, 6);
            // 
            // exportAnimatorWithSelectedAnimationClipToolStripMenuItem
            // 
            this.exportAnimatorWithSelectedAnimationClipToolStripMenuItem.Name = "exportAnimatorWithSelectedAnimationClipToolStripMenuItem";
            this.exportAnimatorWithSelectedAnimationClipToolStripMenuItem.Size = new System.Drawing.Size(284, 22);
            this.exportAnimatorWithSelectedAnimationClipToolStripMenuItem.Text = "Animator + selected AnimationClips";
            this.exportAnimatorWithSelectedAnimationClipToolStripMenuItem.Click += new System.EventHandler(this.exportAnimatorwithAnimationClipMenuItem_Click);
            // 
            // toolStripSeparator4
            // 
            this.toolStripSeparator4.Name = "toolStripSeparator4";
            this.toolStripSeparator4.Size = new System.Drawing.Size(281, 6);
            // 
            // toolStripMenuItem2
            // 
            this.toolStripMenuItem2.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolStripMenuItem4,
            this.toolStripMenuItem5,
            this.toolStripMenuItem6});
            this.toolStripMenuItem2.Name = "toolStripMenuItem2";
            this.toolStripMenuItem2.Size = new System.Drawing.Size(284, 22);
            this.toolStripMenuItem2.Text = "Raw";
            // 
            // toolStripMenuItem4
            // 
            this.toolStripMenuItem4.Name = "toolStripMenuItem4";
            this.toolStripMenuItem4.Size = new System.Drawing.Size(165, 22);
            this.toolStripMenuItem4.Text = "All assets";
            this.toolStripMenuItem4.Click += new System.EventHandler(this.toolStripMenuItem4_Click);
            // 
            // toolStripMenuItem5
            // 
            this.toolStripMenuItem5.Name = "toolStripMenuItem5";
            this.toolStripMenuItem5.Size = new System.Drawing.Size(165, 22);
            this.toolStripMenuItem5.Text = "Selected assets";
            this.toolStripMenuItem5.Click += new System.EventHandler(this.toolStripMenuItem5_Click);
            // 
            // toolStripMenuItem6
            // 
            this.toolStripMenuItem6.Name = "toolStripMenuItem6";
            this.toolStripMenuItem6.Size = new System.Drawing.Size(165, 22);
            this.toolStripMenuItem6.Text = "Filtered assets";
            this.toolStripMenuItem6.Click += new System.EventHandler(this.toolStripMenuItem6_Click);
            // 
            // toolStripMenuItem3
            // 
            this.toolStripMenuItem3.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolStripMenuItem7,
            this.toolStripMenuItem8,
            this.toolStripMenuItem9});
            this.toolStripMenuItem3.Name = "toolStripMenuItem3";
            this.toolStripMenuItem3.Size = new System.Drawing.Size(284, 22);
            this.toolStripMenuItem3.Text = "Dump";
            // 
            // toolStripMenuItem7
            // 
            this.toolStripMenuItem7.Name = "toolStripMenuItem7";
            this.toolStripMenuItem7.Size = new System.Drawing.Size(165, 22);
            this.toolStripMenuItem7.Text = "All assets";
            this.toolStripMenuItem7.Click += new System.EventHandler(this.toolStripMenuItem7_Click);
            // 
            // toolStripMenuItem8
            // 
            this.toolStripMenuItem8.Name = "toolStripMenuItem8";
            this.toolStripMenuItem8.Size = new System.Drawing.Size(165, 22);
            this.toolStripMenuItem8.Text = "Selected assets";
            this.toolStripMenuItem8.Click += new System.EventHandler(this.toolStripMenuItem8_Click);
            // 
            // toolStripMenuItem9
            // 
            this.toolStripMenuItem9.Name = "toolStripMenuItem9";
            this.toolStripMenuItem9.Size = new System.Drawing.Size(165, 22);
            this.toolStripMenuItem9.Text = "Filtered assets";
            this.toolStripMenuItem9.Click += new System.EventHandler(this.toolStripMenuItem9_Click);
            // 
            // toolStripSeparator2
            // 
            this.toolStripSeparator2.Name = "toolStripSeparator2";
            this.toolStripSeparator2.Size = new System.Drawing.Size(281, 6);
            // 
            // toolStripMenuItem10
            // 
            this.toolStripMenuItem10.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolStripMenuItem11,
            this.toolStripMenuItem12,
            this.toolStripMenuItem13});
            this.toolStripMenuItem10.Name = "toolStripMenuItem10";
            this.toolStripMenuItem10.Size = new System.Drawing.Size(284, 22);
            this.toolStripMenuItem10.Text = "Asset list to XML";
            // 
            // toolStripMenuItem11
            // 
            this.toolStripMenuItem11.Name = "toolStripMenuItem11";
            this.toolStripMenuItem11.Size = new System.Drawing.Size(165, 22);
            this.toolStripMenuItem11.Text = "All assets";
            this.toolStripMenuItem11.Click += new System.EventHandler(this.toolStripMenuItem11_Click);
            // 
            // toolStripMenuItem12
            // 
            this.toolStripMenuItem12.Name = "toolStripMenuItem12";
            this.toolStripMenuItem12.Size = new System.Drawing.Size(165, 22);
            this.toolStripMenuItem12.Text = "Selected assets";
            this.toolStripMenuItem12.Click += new System.EventHandler(this.toolStripMenuItem12_Click);
            // 
            // toolStripMenuItem13
            // 
            this.toolStripMenuItem13.Name = "toolStripMenuItem13";
            this.toolStripMenuItem13.Size = new System.Drawing.Size(165, 22);
            this.toolStripMenuItem13.Text = "Filtered assets";
            this.toolStripMenuItem13.Click += new System.EventHandler(this.toolStripMenuItem13_Click);
            // 
            // filterTypeToolStripMenuItem
            // 
            this.filterTypeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.allToolStripMenuItem});
            this.filterTypeToolStripMenuItem.Name = "filterTypeToolStripMenuItem";
            this.filterTypeToolStripMenuItem.Size = new System.Drawing.Size(80, 21);
            this.filterTypeToolStripMenuItem.Text = "Filter Type";
            // 
            // allToolStripMenuItem
            // 
            this.allToolStripMenuItem.Checked = true;
            this.allToolStripMenuItem.CheckOnClick = true;
            this.allToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
            this.allToolStripMenuItem.Name = "allToolStripMenuItem";
            this.allToolStripMenuItem.Size = new System.Drawing.Size(90, 22);
            this.allToolStripMenuItem.Text = "All";
            this.allToolStripMenuItem.Click += new System.EventHandler(this.typeToolStripMenuItem_Click);
            // 
            // debugMenuItem
            // 
            this.debugMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolStripMenuItem15,
            this.exportClassStructuresMenuItem});
            this.debugMenuItem.Name = "debugMenuItem";
            this.debugMenuItem.Size = new System.Drawing.Size(59, 21);
            this.debugMenuItem.Text = "Debug";
            // 
            // toolStripMenuItem15
            // 
            this.toolStripMenuItem15.Checked = true;
            this.toolStripMenuItem15.CheckOnClick = true;
            this.toolStripMenuItem15.CheckState = System.Windows.Forms.CheckState.Checked;
            this.toolStripMenuItem15.Name = "toolStripMenuItem15";
            this.toolStripMenuItem15.Size = new System.Drawing.Size(207, 22);
            this.toolStripMenuItem15.Text = "Show error message";
            this.toolStripMenuItem15.Click += new System.EventHandler(this.toolStripMenuItem15_Click);
            // 
            // exportClassStructuresMenuItem
            // 
            this.exportClassStructuresMenuItem.Name = "exportClassStructuresMenuItem";
            this.exportClassStructuresMenuItem.Size = new System.Drawing.Size(207, 22);
            this.exportClassStructuresMenuItem.Text = "Export class structures";
            this.exportClassStructuresMenuItem.Click += new System.EventHandler(this.exportClassStructuresMenuItem_Click);
            // 
            // splitContainer1
            // 
            this.splitContainer1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.splitContainer1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.splitContainer1.Location = new System.Drawing.Point(0, 25);
            this.splitContainer1.Name = "splitContainer1";
            // 
            // splitContainer1.Panel1
            // 
            this.splitContainer1.Panel1.Controls.Add(this.tabControl1);
            this.splitContainer1.Panel1.Controls.Add(this.progressbarPanel);
            this.splitContainer1.Panel1MinSize = 200;
            // 
            // splitContainer1.Panel2
            // 
            this.splitContainer1.Panel2.Controls.Add(this.tabControl2);
            this.splitContainer1.Panel2.Controls.Add(this.statusStrip1);
            this.splitContainer1.Panel2MinSize = 400;
            this.splitContainer1.Size = new System.Drawing.Size(1264, 656);
            this.splitContainer1.SplitterDistance = 482;
            this.splitContainer1.TabIndex = 2;
            this.splitContainer1.TabStop = false;
            // 
            // tabControl1
            // 
            this.tabControl1.Controls.Add(this.tabPage1);
            this.tabControl1.Controls.Add(this.tabPage2);
            this.tabControl1.Controls.Add(this.tabPage3);
            this.tabControl1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tabControl1.Location = new System.Drawing.Point(0, 0);
            this.tabControl1.Name = "tabControl1";
            this.tabControl1.Padding = new System.Drawing.Point(17, 3);
            this.tabControl1.SelectedIndex = 0;
            this.tabControl1.Size = new System.Drawing.Size(480, 634);
            this.tabControl1.SizeMode = System.Windows.Forms.TabSizeMode.Fixed;
            this.tabControl1.TabIndex = 0;
            this.tabControl1.Selected += new System.Windows.Forms.TabControlEventHandler(this.tabPageSelected);
            // 
            // tabPage1
            // 
            this.tabPage1.Controls.Add(this.sceneTreeView);
            this.tabPage1.Controls.Add(this.treeSearch);
            this.tabPage1.Location = new System.Drawing.Point(4, 22);
            this.tabPage1.Name = "tabPage1";
            this.tabPage1.Size = new System.Drawing.Size(472, 608);
            this.tabPage1.TabIndex = 0;
            this.tabPage1.Text = "Scene Hierarchy";
            this.tabPage1.UseVisualStyleBackColor = true;
            // 
            // sceneTreeView
            // 
            this.sceneTreeView.CheckBoxes = true;
            this.sceneTreeView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.sceneTreeView.HideSelection = false;
            this.sceneTreeView.Location = new System.Drawing.Point(0, 21);
            this.sceneTreeView.Name = "sceneTreeView";
            this.sceneTreeView.Size = new System.Drawing.Size(472, 587);
            this.sceneTreeView.TabIndex = 1;
            this.sceneTreeView.AfterCheck += new System.Windows.Forms.TreeViewEventHandler(this.sceneTreeView_AfterCheck);
            // 
            // treeSearch
            // 
            this.treeSearch.Dock = System.Windows.Forms.DockStyle.Top;
            this.treeSearch.ForeColor = System.Drawing.SystemColors.GrayText;
            this.treeSearch.Location = new System.Drawing.Point(0, 0);
            this.treeSearch.Name = "treeSearch";
            this.treeSearch.Size = new System.Drawing.Size(472, 21);
            this.treeSearch.TabIndex = 0;
            this.treeSearch.Text = " Search ";
            this.treeSearch.TextChanged += new System.EventHandler(this.treeSearch_TextChanged);
            this.treeSearch.Enter += new System.EventHandler(this.treeSearch_Enter);
            this.treeSearch.KeyDown += new System.Windows.Forms.KeyEventHandler(this.treeSearch_KeyDown);
            this.treeSearch.Leave += new System.EventHandler(this.treeSearch_Leave);
            // 
            // tabPage2
            // 
            this.tabPage2.Controls.Add(this.assetListView);
            this.tabPage2.Controls.Add(this.listSearch);
            this.tabPage2.Location = new System.Drawing.Point(4, 22);
            this.tabPage2.Name = "tabPage2";
            this.tabPage2.Size = new System.Drawing.Size(472, 608);
            this.tabPage2.TabIndex = 1;
            this.tabPage2.Text = "Asset List";
            this.tabPage2.UseVisualStyleBackColor = true;
            // 
            // assetListView
            // 
            this.assetListView.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.columnHeaderName,
            this.columnHeaderContainer,
            this.columnHeaderType,
            this.columnHeaderPathID,
            this.columnHeaderSize});
            this.assetListView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.assetListView.FullRowSelect = true;
            this.assetListView.GridLines = true;
            this.assetListView.HideSelection = false;
            this.assetListView.Location = new System.Drawing.Point(0, 21);
            this.assetListView.Name = "assetListView";
            this.assetListView.Size = new System.Drawing.Size(472, 587);
            this.assetListView.TabIndex = 1;
            this.assetListView.UseCompatibleStateImageBehavior = false;
            this.assetListView.View = System.Windows.Forms.View.Details;
            this.assetListView.VirtualMode = true;
            this.assetListView.ColumnClick += new System.Windows.Forms.ColumnClickEventHandler(this.assetListView_ColumnClick);
            this.assetListView.ItemSelectionChanged += new System.Windows.Forms.ListViewItemSelectionChangedEventHandler(this.selectAsset);
            this.assetListView.RetrieveVirtualItem += new System.Windows.Forms.RetrieveVirtualItemEventHandler(this.assetListView_RetrieveVirtualItem);
            this.assetListView.MouseClick += new System.Windows.Forms.MouseEventHandler(this.assetListView_MouseClick);
            // 
            // columnHeaderName
            // 
            this.columnHeaderName.Text = "Name";
            this.columnHeaderName.Width = 170;
            // 
            // columnHeaderContainer
            // 
            this.columnHeaderContainer.Text = "Container";
            this.columnHeaderContainer.Width = 80;
            // 
            // columnHeaderType
            // 
            this.columnHeaderType.Text = "Type";
            this.columnHeaderType.Width = 90;
            // 
            // columnHeaderPathID
            // 
            this.columnHeaderPathID.Text = "PathID";
            // 
            // columnHeaderSize
            // 
            this.columnHeaderSize.Text = "Size";
            this.columnHeaderSize.Width = 50;
            // 
            // listSearch
            // 
            this.listSearch.Dock = System.Windows.Forms.DockStyle.Top;
            this.listSearch.ForeColor = System.Drawing.SystemColors.GrayText;
            this.listSearch.Location = new System.Drawing.Point(0, 0);
            this.listSearch.Name = "listSearch";
            this.listSearch.Size = new System.Drawing.Size(472, 21);
            this.listSearch.TabIndex = 0;
            this.listSearch.Text = " Filter ";
            this.listSearch.TextChanged += new System.EventHandler(this.ListSearchTextChanged);
            this.listSearch.Enter += new System.EventHandler(this.listSearch_Enter);
            this.listSearch.Leave += new System.EventHandler(this.listSearch_Leave);
            // 
            // tabPage3
            // 
            this.tabPage3.Controls.Add(this.classesListView);
            this.tabPage3.Location = new System.Drawing.Point(4, 22);
            this.tabPage3.Name = "tabPage3";
            this.tabPage3.Size = new System.Drawing.Size(472, 608);
            this.tabPage3.TabIndex = 2;
            this.tabPage3.Text = "Asset Classes";
            this.tabPage3.UseVisualStyleBackColor = true;
            // 
            // classesListView
            // 
            this.classesListView.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.columnHeader1,
            this.columnHeader2});
            this.classesListView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.classesListView.FullRowSelect = true;
            this.classesListView.HideSelection = false;
            this.classesListView.Location = new System.Drawing.Point(0, 0);
            this.classesListView.MultiSelect = false;
            this.classesListView.Name = "classesListView";
            this.classesListView.Size = new System.Drawing.Size(472, 608);
            this.classesListView.TabIndex = 0;
            this.classesListView.UseCompatibleStateImageBehavior = false;
            this.classesListView.View = System.Windows.Forms.View.Details;
            this.classesListView.ItemSelectionChanged += new System.Windows.Forms.ListViewItemSelectionChangedEventHandler(this.classesListView_ItemSelectionChanged);
            // 
            // columnHeader1
            // 
            this.columnHeader1.DisplayIndex = 1;
            this.columnHeader1.Text = "Name";
            this.columnHeader1.Width = 300;
            // 
            // columnHeader2
            // 
            this.columnHeader2.DisplayIndex = 0;
            this.columnHeader2.Text = "ID";
            this.columnHeader2.Width = 70;
            // 
            // progressbarPanel
            // 
            this.progressbarPanel.Controls.Add(this.progressBar1);
            this.progressbarPanel.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.progressbarPanel.Location = new System.Drawing.Point(0, 634);
            this.progressbarPanel.Name = "progressbarPanel";
            this.progressbarPanel.Padding = new System.Windows.Forms.Padding(1, 3, 1, 1);
            this.progressbarPanel.Size = new System.Drawing.Size(480, 20);
            this.progressbarPanel.TabIndex = 2;
            // 
            // progressBar1
            // 
            this.progressBar1.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.progressBar1.Location = new System.Drawing.Point(1, 2);
            this.progressBar1.Name = "progressBar1";
            this.progressBar1.Size = new System.Drawing.Size(478, 17);
            this.progressBar1.Step = 1;
            this.progressBar1.TabIndex = 1;
            // 
            // tabControl2
            // 
            this.tabControl2.Controls.Add(this.tabPage4);
            this.tabControl2.Controls.Add(this.tabPage5);
            this.tabControl2.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tabControl2.Location = new System.Drawing.Point(0, 0);
            this.tabControl2.Name = "tabControl2";
            this.tabControl2.SelectedIndex = 0;
            this.tabControl2.Size = new System.Drawing.Size(776, 632);
            this.tabControl2.TabIndex = 4;
            this.tabControl2.SelectedIndexChanged += new System.EventHandler(this.tabControl2_SelectedIndexChanged);
            // 
            // tabPage4
            // 
            this.tabPage4.Controls.Add(this.previewPanel);
            this.tabPage4.Location = new System.Drawing.Point(4, 22);
            this.tabPage4.Name = "tabPage4";
            this.tabPage4.Size = new System.Drawing.Size(768, 606);
            this.tabPage4.TabIndex = 0;
            this.tabPage4.Text = "Preview";
            this.tabPage4.UseVisualStyleBackColor = true;
            // 
            // previewPanel
            // 
            this.previewPanel.BackColor = System.Drawing.SystemColors.ControlDark;
            this.previewPanel.BackgroundImage = global::AssetStudioGUI.Properties.Resources.preview;
            this.previewPanel.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Center;
            this.previewPanel.Controls.Add(this.assetInfoLabel);
            this.previewPanel.Controls.Add(this.FMODpanel);
            this.previewPanel.Controls.Add(this.fontPreviewBox);
            this.previewPanel.Controls.Add(this.glControl1);
            this.previewPanel.Controls.Add(this.textPreviewBox);
            this.previewPanel.Controls.Add(this.classTextBox);
            this.previewPanel.Dock = System.Windows.Forms.DockStyle.Fill;
            this.previewPanel.Location = new System.Drawing.Point(0, 0);
            this.previewPanel.Name = "previewPanel";
            this.previewPanel.Size = new System.Drawing.Size(768, 606);
            this.previewPanel.TabIndex = 1;
            this.previewPanel.Resize += new System.EventHandler(this.preview_Resize);
            // 
            // assetInfoLabel
            // 
            this.assetInfoLabel.AutoSize = true;
            this.assetInfoLabel.BackColor = System.Drawing.Color.Transparent;
            this.assetInfoLabel.ForeColor = System.Drawing.SystemColors.ControlLightLight;
            this.assetInfoLabel.Location = new System.Drawing.Point(4, 7);
            this.assetInfoLabel.Name = "assetInfoLabel";
            this.assetInfoLabel.Size = new System.Drawing.Size(0, 12);
            this.assetInfoLabel.TabIndex = 0;
            // 
            // FMODpanel
            // 
            this.FMODpanel.BackColor = System.Drawing.SystemColors.ControlDark;
            this.FMODpanel.Controls.Add(this.FMODcopyright);
            this.FMODpanel.Controls.Add(this.FMODinfoLabel);
            this.FMODpanel.Controls.Add(this.FMODtimerLabel);
            this.FMODpanel.Controls.Add(this.FMODstatusLabel);
            this.FMODpanel.Controls.Add(this.FMODprogressBar);
            this.FMODpanel.Controls.Add(this.FMODvolumeBar);
            this.FMODpanel.Controls.Add(this.FMODloopButton);
            this.FMODpanel.Controls.Add(this.FMODstopButton);
            this.FMODpanel.Controls.Add(this.FMODpauseButton);
            this.FMODpanel.Controls.Add(this.FMODplayButton);
            this.FMODpanel.Dock = System.Windows.Forms.DockStyle.Fill;
            this.FMODpanel.Location = new System.Drawing.Point(0, 0);
            this.FMODpanel.Name = "FMODpanel";
            this.FMODpanel.Size = new System.Drawing.Size(768, 606);
            this.FMODpanel.TabIndex = 2;
            this.FMODpanel.Visible = false;
            // 
            // FMODcopyright
            // 
            this.FMODcopyright.AutoSize = true;
            this.FMODcopyright.ForeColor = System.Drawing.SystemColors.ControlLight;
            this.FMODcopyright.Location = new System.Drawing.Point(214, 337);
            this.FMODcopyright.Name = "FMODcopyright";
            this.FMODcopyright.Size = new System.Drawing.Size(341, 12);
            this.FMODcopyright.TabIndex = 9;
            this.FMODcopyright.Text = "Audio Engine supplied by FMOD by Firelight Technologies.";
            // 
            // FMODinfoLabel
            // 
            this.FMODinfoLabel.AutoSize = true;
            this.FMODinfoLabel.ForeColor = System.Drawing.SystemColors.ControlLightLight;
            this.FMODinfoLabel.Location = new System.Drawing.Point(269, 235);
            this.FMODinfoLabel.Name = "FMODinfoLabel";
            this.FMODinfoLabel.Size = new System.Drawing.Size(0, 12);
            this.FMODinfoLabel.TabIndex = 8;
            // 
            // FMODtimerLabel
            // 
            this.FMODtimerLabel.AutoSize = true;
            this.FMODtimerLabel.ForeColor = System.Drawing.SystemColors.ControlLightLight;
            this.FMODtimerLabel.Location = new System.Drawing.Point(460, 235);
            this.FMODtimerLabel.Name = "FMODtimerLabel";
            this.FMODtimerLabel.Size = new System.Drawing.Size(95, 12);
            this.FMODtimerLabel.TabIndex = 7;
            this.FMODtimerLabel.Text = "0:00.0 / 0:00.0";
            // 
            // FMODstatusLabel
            // 
            this.FMODstatusLabel.AutoSize = true;
            this.FMODstatusLabel.ForeColor = System.Drawing.SystemColors.ControlLightLight;
            this.FMODstatusLabel.Location = new System.Drawing.Point(213, 235);
            this.FMODstatusLabel.Name = "FMODstatusLabel";
            this.FMODstatusLabel.Size = new System.Drawing.Size(47, 12);
            this.FMODstatusLabel.TabIndex = 6;
            this.FMODstatusLabel.Text = "Stopped";
            // 
            // FMODprogressBar
            // 
            this.FMODprogressBar.AutoSize = false;
            this.FMODprogressBar.Location = new System.Drawing.Point(213, 253);
            this.FMODprogressBar.Maximum = 1000;
            this.FMODprogressBar.Name = "FMODprogressBar";
            this.FMODprogressBar.Size = new System.Drawing.Size(350, 22);
            this.FMODprogressBar.TabIndex = 5;
            this.FMODprogressBar.TickStyle = System.Windows.Forms.TickStyle.None;
            this.FMODprogressBar.Scroll += new System.EventHandler(this.FMODprogressBar_Scroll);
            this.FMODprogressBar.MouseDown += new System.Windows.Forms.MouseEventHandler(this.FMODprogressBar_MouseDown);
            this.FMODprogressBar.MouseUp += new System.Windows.Forms.MouseEventHandler(this.FMODprogressBar_MouseUp);
            // 
            // FMODvolumeBar
            // 
            this.FMODvolumeBar.LargeChange = 2;
            this.FMODvolumeBar.Location = new System.Drawing.Point(460, 280);
            this.FMODvolumeBar.Name = "FMODvolumeBar";
            this.FMODvolumeBar.Size = new System.Drawing.Size(104, 45);
            this.FMODvolumeBar.TabIndex = 4;
            this.FMODvolumeBar.TickStyle = System.Windows.Forms.TickStyle.Both;
            this.FMODvolumeBar.Value = 8;
            this.FMODvolumeBar.ValueChanged += new System.EventHandler(this.FMODvolumeBar_ValueChanged);
            // 
            // FMODloopButton
            // 
            this.FMODloopButton.Appearance = System.Windows.Forms.Appearance.Button;
            this.FMODloopButton.Location = new System.Drawing.Point(399, 280);
            this.FMODloopButton.Name = "FMODloopButton";
            this.FMODloopButton.Size = new System.Drawing.Size(55, 42);
            this.FMODloopButton.TabIndex = 3;
            this.FMODloopButton.Text = "Loop";
            this.FMODloopButton.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            this.FMODloopButton.UseVisualStyleBackColor = true;
            this.FMODloopButton.CheckedChanged += new System.EventHandler(this.FMODloopButton_CheckedChanged);
            // 
            // FMODstopButton
            // 
            this.FMODstopButton.Location = new System.Drawing.Point(338, 280);
            this.FMODstopButton.Name = "FMODstopButton";
            this.FMODstopButton.Size = new System.Drawing.Size(55, 42);
            this.FMODstopButton.TabIndex = 2;
            this.FMODstopButton.Text = "Stop";
            this.FMODstopButton.UseVisualStyleBackColor = true;
            this.FMODstopButton.Click += new System.EventHandler(this.FMODstopButton_Click);
            // 
            // FMODpauseButton
            // 
            this.FMODpauseButton.Location = new System.Drawing.Point(277, 280);
            this.FMODpauseButton.Name = "FMODpauseButton";
            this.FMODpauseButton.Size = new System.Drawing.Size(55, 42);
            this.FMODpauseButton.TabIndex = 1;
            this.FMODpauseButton.Text = "Pause";
            this.FMODpauseButton.UseVisualStyleBackColor = true;
            this.FMODpauseButton.Click += new System.EventHandler(this.FMODpauseButton_Click);
            // 
            // FMODplayButton
            // 
            this.FMODplayButton.Location = new System.Drawing.Point(216, 280);
            this.FMODplayButton.Name = "FMODplayButton";
            this.FMODplayButton.Size = new System.Drawing.Size(55, 42);
            this.FMODplayButton.TabIndex = 0;
            this.FMODplayButton.Text = "Play";
            this.FMODplayButton.UseVisualStyleBackColor = true;
            this.FMODplayButton.Click += new System.EventHandler(this.FMODplayButton_Click);
            // 
            // fontPreviewBox
            // 
            this.fontPreviewBox.BackColor = System.Drawing.SystemColors.ControlLightLight;
            this.fontPreviewBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.fontPreviewBox.Location = new System.Drawing.Point(0, 0);
            this.fontPreviewBox.Name = "fontPreviewBox";
            this.fontPreviewBox.ReadOnly = true;
            this.fontPreviewBox.Size = new System.Drawing.Size(768, 606);
            this.fontPreviewBox.TabIndex = 0;
            this.fontPreviewBox.Text = resources.GetString("fontPreviewBox.Text");
            this.fontPreviewBox.Visible = false;
            this.fontPreviewBox.WordWrap = false;
            // 
            // glControl1
            // 
            this.glControl1.BackColor = System.Drawing.SystemColors.ControlDarkDark;
            this.glControl1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.glControl1.Location = new System.Drawing.Point(0, 0);
            this.glControl1.Name = "glControl1";
            this.glControl1.Size = new System.Drawing.Size(768, 606);
            this.glControl1.TabIndex = 4;
            this.glControl1.Visible = false;
            this.glControl1.VSync = false;
            this.glControl1.Load += new System.EventHandler(this.glControl1_Load);
            this.glControl1.Paint += new System.Windows.Forms.PaintEventHandler(this.glControl1_Paint);
            this.glControl1.MouseDown += new System.Windows.Forms.MouseEventHandler(this.glControl1_MouseDown);
            this.glControl1.MouseMove += new System.Windows.Forms.MouseEventHandler(this.glControl1_MouseMove);
            this.glControl1.MouseUp += new System.Windows.Forms.MouseEventHandler(this.glControl1_MouseUp);
            this.glControl1.MouseWheel += new System.Windows.Forms.MouseEventHandler(this.glControl1_MouseWheel);
            // 
            // textPreviewBox
            // 
            this.textPreviewBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.textPreviewBox.Font = new System.Drawing.Font("Consolas", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.textPreviewBox.Location = new System.Drawing.Point(0, 0);
            this.textPreviewBox.Multiline = true;
            this.textPreviewBox.Name = "textPreviewBox";
            this.textPreviewBox.ReadOnly = true;
            this.textPreviewBox.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.textPreviewBox.Size = new System.Drawing.Size(768, 606);
            this.textPreviewBox.TabIndex = 2;
            this.textPreviewBox.Visible = false;
            this.textPreviewBox.WordWrap = false;
            // 
            // classTextBox
            // 
            this.classTextBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.classTextBox.Location = new System.Drawing.Point(0, 0);
            this.classTextBox.Multiline = true;
            this.classTextBox.Name = "classTextBox";
            this.classTextBox.ReadOnly = true;
            this.classTextBox.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.classTextBox.Size = new System.Drawing.Size(768, 606);
            this.classTextBox.TabIndex = 3;
            this.classTextBox.Visible = false;
            this.classTextBox.WordWrap = false;
            // 
            // tabPage5
            // 
            this.tabPage5.Controls.Add(this.dumpTextBox);
            this.tabPage5.Location = new System.Drawing.Point(4, 22);
            this.tabPage5.Name = "tabPage5";
            this.tabPage5.Size = new System.Drawing.Size(768, 606);
            this.tabPage5.TabIndex = 1;
            this.tabPage5.Text = "Dump";
            this.tabPage5.UseVisualStyleBackColor = true;
            // 
            // dumpTextBox
            // 
            this.dumpTextBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.dumpTextBox.Location = new System.Drawing.Point(0, 0);
            this.dumpTextBox.Multiline = true;
            this.dumpTextBox.Name = "dumpTextBox";
            this.dumpTextBox.ReadOnly = true;
            this.dumpTextBox.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.dumpTextBox.Size = new System.Drawing.Size(768, 606);
            this.dumpTextBox.TabIndex = 0;
            this.dumpTextBox.WordWrap = false;
            // 
            // statusStrip1
            // 
            this.statusStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.toolStripStatusLabel1});
            this.statusStrip1.Location = new System.Drawing.Point(0, 632);
            this.statusStrip1.Name = "statusStrip1";
            this.statusStrip1.Size = new System.Drawing.Size(776, 22);
            this.statusStrip1.TabIndex = 2;
            this.statusStrip1.Text = "statusStrip1";
            // 
            // toolStripStatusLabel1
            // 
            this.toolStripStatusLabel1.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Text;
            this.toolStripStatusLabel1.Name = "toolStripStatusLabel1";
            this.toolStripStatusLabel1.Size = new System.Drawing.Size(761, 17);
            this.toolStripStatusLabel1.Spring = true;
            this.toolStripStatusLabel1.Text = "Ready to go";
            this.toolStripStatusLabel1.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // timer
            // 
            this.timer.Interval = 10;
            this.timer.Tick += new System.EventHandler(this.timer_Tick);
            // 
            // openFileDialog1
            // 
            this.openFileDialog1.AddExtension = false;
            this.openFileDialog1.Filter = "All types|*.*";
            this.openFileDialog1.Multiselect = true;
            this.openFileDialog1.RestoreDirectory = true;
            // 
            // contextMenuStrip1
            // 
            this.contextMenuStrip1.ImageScalingSize = new System.Drawing.Size(20, 20);
            this.contextMenuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.copyToolStripMenuItem,
            this.exportSelectedAssetsToolStripMenuItem,
            this.exportAnimatorwithselectedAnimationClipMenuItem,
            this.goToSceneHierarchyToolStripMenuItem,
            this.showOriginalFileToolStripMenuItem});
            this.contextMenuStrip1.Name = "contextMenuStrip1";
            this.contextMenuStrip1.Size = new System.Drawing.Size(327, 114);
            // 
            // copyToolStripMenuItem
            // 
            this.copyToolStripMenuItem.Name = "copyToolStripMenuItem";
            this.copyToolStripMenuItem.Size = new System.Drawing.Size(326, 22);
            this.copyToolStripMenuItem.Text = "Copy text";
            this.copyToolStripMenuItem.Click += new System.EventHandler(this.copyToolStripMenuItem_Click);
            // 
            // exportSelectedAssetsToolStripMenuItem
            // 
            this.exportSelectedAssetsToolStripMenuItem.Name = "exportSelectedAssetsToolStripMenuItem";
            this.exportSelectedAssetsToolStripMenuItem.Size = new System.Drawing.Size(326, 22);
            this.exportSelectedAssetsToolStripMenuItem.Text = "Export selected assets";
            this.exportSelectedAssetsToolStripMenuItem.Click += new System.EventHandler(this.exportSelectedAssetsToolStripMenuItem_Click);
            // 
            // exportAnimatorwithselectedAnimationClipMenuItem
            // 
            this.exportAnimatorwithselectedAnimationClipMenuItem.Name = "exportAnimatorwithselectedAnimationClipMenuItem";
            this.exportAnimatorwithselectedAnimationClipMenuItem.Size = new System.Drawing.Size(326, 22);
            this.exportAnimatorwithselectedAnimationClipMenuItem.Text = "Export Animator + selected AnimationClips";
            this.exportAnimatorwithselectedAnimationClipMenuItem.Visible = false;
            this.exportAnimatorwithselectedAnimationClipMenuItem.Click += new System.EventHandler(this.exportAnimatorwithAnimationClipMenuItem_Click);
            // 
            // goToSceneHierarchyToolStripMenuItem
            // 
            this.goToSceneHierarchyToolStripMenuItem.Name = "goToSceneHierarchyToolStripMenuItem";
            this.goToSceneHierarchyToolStripMenuItem.Size = new System.Drawing.Size(326, 22);
            this.goToSceneHierarchyToolStripMenuItem.Text = "Go to scene hierarchy";
            this.goToSceneHierarchyToolStripMenuItem.Visible = false;
            this.goToSceneHierarchyToolStripMenuItem.Click += new System.EventHandler(this.goToSceneHierarchyToolStripMenuItem_Click);
            // 
            // showOriginalFileToolStripMenuItem
            // 
            this.showOriginalFileToolStripMenuItem.Name = "showOriginalFileToolStripMenuItem";
            this.showOriginalFileToolStripMenuItem.Size = new System.Drawing.Size(326, 22);
            this.showOriginalFileToolStripMenuItem.Text = "Show original file";
            this.showOriginalFileToolStripMenuItem.Visible = false;
            this.showOriginalFileToolStripMenuItem.Click += new System.EventHandler(this.showOriginalFileToolStripMenuItem_Click);
            // 
            // AssetStudioGUIForm
            // 
            this.AllowDrop = true;
            this.ClientSize = new System.Drawing.Size(1264, 681);
            this.Controls.Add(this.splitContainer1);
            this.Controls.Add(this.menuStrip1);
            this.Icon = global::AssetStudioGUI.Properties.Resources._as;
            this.KeyPreview = true;
            this.MainMenuStrip = this.menuStrip1;
            this.MinimumSize = new System.Drawing.Size(620, 372);
            this.Name = "AssetStudioGUIForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "AssetStudioGUI";
            this.DragDrop += new System.Windows.Forms.DragEventHandler(this.AssetStudioGUIForm_DragDrop);
            this.DragEnter += new System.Windows.Forms.DragEventHandler(this.AssetStudioGUIForm_DragEnter);
            this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.AssetStudioForm_KeyDown);
            this.menuStrip1.ResumeLayout(false);
            this.menuStrip1.PerformLayout();
            this.splitContainer1.Panel1.ResumeLayout(false);
            this.splitContainer1.Panel2.ResumeLayout(false);
            this.splitContainer1.Panel2.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).EndInit();
            this.splitContainer1.ResumeLayout(false);
            this.tabControl1.ResumeLayout(false);
            this.tabPage1.ResumeLayout(false);
            this.tabPage1.PerformLayout();
            this.tabPage2.ResumeLayout(false);
            this.tabPage2.PerformLayout();
            this.tabPage3.ResumeLayout(false);
            this.progressbarPanel.ResumeLayout(false);
            this.tabControl2.ResumeLayout(false);
            this.tabPage4.ResumeLayout(false);
            this.previewPanel.ResumeLayout(false);
            this.previewPanel.PerformLayout();
            this.FMODpanel.ResumeLayout(false);
            this.FMODpanel.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.FMODprogressBar)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.FMODvolumeBar)).EndInit();
            this.tabPage5.ResumeLayout(false);
            this.tabPage5.PerformLayout();
            this.statusStrip1.ResumeLayout(false);
            this.statusStrip1.PerformLayout();
            this.contextMenuStrip1.ResumeLayout(false);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.MenuStrip menuStrip1;
        private System.Windows.Forms.ToolStripMenuItem fileToolStripMenuItem;
        private System.Windows.Forms.SplitContainer splitContainer1;
        private System.Windows.Forms.TabControl tabControl1;
        private System.Windows.Forms.TabPage tabPage1;
        private System.Windows.Forms.TabPage tabPage2;
        private System.Windows.Forms.TextBox treeSearch;
        private System.Windows.Forms.TextBox listSearch;
        private System.Windows.Forms.ToolStripMenuItem loadFileToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem loadFolderToolStripMenuItem;
        private System.Windows.Forms.ListView assetListView;
        private System.Windows.Forms.ColumnHeader columnHeaderName;
        private System.Windows.Forms.ColumnHeader columnHeaderSize;
        private System.Windows.Forms.ColumnHeader columnHeaderType;
        private System.Windows.Forms.ToolStripMenuItem exportToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exportAllAssetsMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exportSelectedAssetsMenuItem;
        private System.Windows.Forms.Panel previewPanel;
        private System.Windows.Forms.ProgressBar progressBar1;
        private System.Windows.Forms.StatusStrip statusStrip1;
        private System.Windows.Forms.ToolStripStatusLabel toolStripStatusLabel1;
        private System.Windows.Forms.Panel progressbarPanel;
        private System.Windows.Forms.ToolStripMenuItem exportFilteredAssetsMenuItem;
        private System.Windows.Forms.ToolStripMenuItem modelToolStripMenuItem;
        private System.Windows.Forms.Label assetInfoLabel;
        private System.Windows.Forms.TextBox textPreviewBox;
        private System.Windows.Forms.RichTextBox fontPreviewBox;
        private System.Windows.Forms.Panel FMODpanel;
        private System.Windows.Forms.TrackBar FMODvolumeBar;
        private System.Windows.Forms.CheckBox FMODloopButton;
        private System.Windows.Forms.Button FMODstopButton;
        private System.Windows.Forms.Button FMODpauseButton;
        private System.Windows.Forms.Button FMODplayButton;
        private System.Windows.Forms.TrackBar FMODprogressBar;
        private System.Windows.Forms.Label FMODstatusLabel;
        private System.Windows.Forms.Label FMODtimerLabel;
        private System.Windows.Forms.Label FMODinfoLabel;
        private System.Windows.Forms.Timer timer;
        private System.Windows.Forms.ToolStripMenuItem optionsToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem displayAll;
        private System.Windows.Forms.ToolStripMenuItem enablePreview;
        private System.Windows.Forms.ToolStripMenuItem displayInfo;
        private System.Windows.Forms.ToolStripSeparator toolStripMenuItem1;
        private System.Windows.Forms.ToolStripMenuItem extractFileToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem extractFolderToolStripMenuItem;
        private System.Windows.Forms.OpenFileDialog openFileDialog1;
        private System.Windows.Forms.ToolStripMenuItem showExpOpt;
        private GOHierarchy sceneTreeView;
        private System.Windows.Forms.ToolStripMenuItem debugMenuItem;
        private System.Windows.Forms.TabPage tabPage3;
        private System.Windows.Forms.ListView classesListView;
        private System.Windows.Forms.ColumnHeader columnHeader2;
        private System.Windows.Forms.ColumnHeader columnHeader1;
        private System.Windows.Forms.TextBox classTextBox;
        private System.Windows.Forms.ToolStripMenuItem exportClassStructuresMenuItem;
        private System.Windows.Forms.Label FMODcopyright;
        private OpenTK.GLControl glControl1;
        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;
        private System.Windows.Forms.ToolStripMenuItem showOriginalFileToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exportAnimatorwithselectedAnimationClipMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exportSelectedAssetsToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem filterTypeToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem allToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exportSelectedObjectsToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exportSelectedObjectsWithAnimationClipToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator3;
        private System.Windows.Forms.ToolStripMenuItem exportAnimatorWithSelectedAnimationClipToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exportAllObjectssplitToolStripMenuItem1;
        private System.Windows.Forms.ToolStripMenuItem goToSceneHierarchyToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exportSelectedObjectsmergeToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exportSelectedObjectsmergeWithAnimationClipToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator4;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem2;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem4;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem5;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem6;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem3;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem7;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem8;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem9;
        private System.Windows.Forms.ColumnHeader columnHeaderContainer;
        private System.Windows.Forms.ColumnHeader columnHeaderPathID;
        private System.Windows.Forms.ToolStripMenuItem copyToolStripMenuItem;
        private System.Windows.Forms.TabControl tabControl2;
        private System.Windows.Forms.TabPage tabPage4;
        private System.Windows.Forms.TabPage tabPage5;
        private System.Windows.Forms.TextBox dumpTextBox;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem10;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem11;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem12;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem13;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem14;
        private System.Windows.Forms.ToolStripTextBox specifyUnityVersion;
        private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem15;
    }
}


```

`AssetStudioGUI/AssetStudioGUIForm.cs`:

```cs
using AssetStudio;
using Newtonsoft.Json;
using OpenTK;
using OpenTK.Graphics.OpenGL;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Text;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Timers;
using System.Windows.Forms;
using static AssetStudioGUI.Studio;
using Font = AssetStudio.Font;
#if NET472
using Vector3 = OpenTK.Vector3;
using Vector4 = OpenTK.Vector4;
#else
using Vector3 = OpenTK.Mathematics.Vector3;
using Vector4 = OpenTK.Mathematics.Vector4;
using Matrix4 = OpenTK.Mathematics.Matrix4;
#endif

namespace AssetStudioGUI
{
    partial class AssetStudioGUIForm : Form
    {
        private AssetItem lastSelectedItem;
        private DirectBitmap imageTexture;
        private string tempClipboard;

        private FMOD.System system;
        private FMOD.Sound sound;
        private FMOD.Channel channel;
        private FMOD.SoundGroup masterSoundGroup;
        private FMOD.MODE loopMode = FMOD.MODE.LOOP_OFF;
        private uint FMODlenms;
        private float FMODVolume = 0.8f;

        #region TexControl
        private static char[] textureChannelNames = new[] { 'B', 'G', 'R', 'A' };
        private bool[] textureChannels = new[] { true, true, true, true };
        #endregion

        #region GLControl
        private bool glControlLoaded;
        private int mdx, mdy;
        private bool lmdown, rmdown;
        private int pgmID, pgmColorID, pgmBlackID;
        private int attributeVertexPosition;
        private int attributeNormalDirection;
        private int attributeVertexColor;
        private int uniformModelMatrix;
        private int uniformViewMatrix;
        private int uniformProjMatrix;
        private int vao;
        private Vector3[] vertexData;
        private Vector3[] normalData;
        private Vector3[] normal2Data;
        private Vector4[] colorData;
        private Matrix4 modelMatrixData;
        private Matrix4 viewMatrixData;
        private Matrix4 projMatrixData;
        private int[] indiceData;
        private int wireFrameMode;
        private int shadeMode;
        private int normalMode;
        #endregion

        //asset list sorting
        private int sortColumn = -1;
        private bool reverseSort;

        //asset list filter
        private System.Timers.Timer delayTimer;
        private bool enableFiltering;

        //tree search
        private int nextGObject;
        private List<TreeNode> treeSrcResults = new List<TreeNode>();

        private string openDirectoryBackup = string.Empty;
        private string saveDirectoryBackup = string.Empty;

        private GUILogger logger;

        [DllImport("gdi32.dll")]
        private static extern IntPtr AddFontMemResourceEx(IntPtr pbFont, uint cbFont, IntPtr pdv, [In] ref uint pcFonts);

        public AssetStudioGUIForm()
        {
            Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");
            InitializeComponent();
            Text = $"AssetStudioGUI v{Application.ProductVersion}";
            delayTimer = new System.Timers.Timer(800);
            delayTimer.Elapsed += new ElapsedEventHandler(delayTimer_Elapsed);
            displayAll.Checked = Properties.Settings.Default.displayAll;
            displayInfo.Checked = Properties.Settings.Default.displayInfo;
            enablePreview.Checked = Properties.Settings.Default.enablePreview;
            FMODinit();

            logger = new GUILogger(StatusStripUpdate);
            Logger.Default = logger;
            Progress.Default = new Progress<int>(SetProgressBarValue);
            Studio.StatusStripUpdate = StatusStripUpdate;
        }

        private void AssetStudioGUIForm_DragEnter(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                e.Effect = DragDropEffects.Move;
            }
        }

        private async void AssetStudioGUIForm_DragDrop(object sender, DragEventArgs e)
        {
            var paths = (string[])e.Data.GetData(DataFormats.FileDrop);
            if (paths.Length > 0)
            {
                ResetForm();
                assetsManager.SpecifyUnityVersion = specifyUnityVersion.Text;
                if (paths.Length == 1 && Directory.Exists(paths[0]))
                {
                    await Task.Run(() => assetsManager.LoadFolder(paths[0]));
                }
                else
                {
                    await Task.Run(() => assetsManager.LoadFiles(paths));
                }
                BuildAssetStructures();
            }
        }

        private async void loadFile_Click(object sender, EventArgs e)
        {
            openFileDialog1.InitialDirectory = openDirectoryBackup;
            if (openFileDialog1.ShowDialog(this) == DialogResult.OK)
            {
                ResetForm();
                openDirectoryBackup = Path.GetDirectoryName(openFileDialog1.FileNames[0]);
                assetsManager.SpecifyUnityVersion = specifyUnityVersion.Text;
                await Task.Run(() => assetsManager.LoadFiles(openFileDialog1.FileNames));
                BuildAssetStructures();
            }
        }

        private async void loadFolder_Click(object sender, EventArgs e)
        {
            var openFolderDialog = new OpenFolderDialog();
            openFolderDialog.InitialFolder = openDirectoryBackup;
            if (openFolderDialog.ShowDialog(this) == DialogResult.OK)
            {
                ResetForm();
                openDirectoryBackup = openFolderDialog.Folder;
                assetsManager.SpecifyUnityVersion = specifyUnityVersion.Text;
                await Task.Run(() => assetsManager.LoadFolder(openFolderDialog.Folder));
                BuildAssetStructures();
            }
        }

        private async void extractFileToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (openFileDialog1.ShowDialog(this) == DialogResult.OK)
            {
                var saveFolderDialog = new OpenFolderDialog();
                saveFolderDialog.Title = "Select the save folder";
                if (saveFolderDialog.ShowDialog(this) == DialogResult.OK)
                {
                    var fileNames = openFileDialog1.FileNames;
                    var savePath = saveFolderDialog.Folder;
                    var extractedCount = await Task.Run(() => ExtractFile(fileNames, savePath));
                    StatusStripUpdate($"Finished extracting {extractedCount} files.");
                }
            }
        }

        private async void extractFolderToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var openFolderDialog = new OpenFolderDialog();
            if (openFolderDialog.ShowDialog(this) == DialogResult.OK)
            {
                var saveFolderDialog = new OpenFolderDialog();
                saveFolderDialog.Title = "Select the save folder";
                if (saveFolderDialog.ShowDialog(this) == DialogResult.OK)
                {
                    var path = openFolderDialog.Folder;
                    var savePath = saveFolderDialog.Folder;
                    var extractedCount = await Task.Run(() => ExtractFolder(path, savePath));
                    StatusStripUpdate($"Finished extracting {extractedCount} files.");
                }
            }
        }

        private async void BuildAssetStructures()
        {
            if (assetsManager.assetsFileList.Count == 0)
            {
                StatusStripUpdate("No Unity file can be loaded.");
                return;
            }

            (var productName, var treeNodeCollection) = await Task.Run(() => BuildAssetData());
            var typeMap = await Task.Run(() => BuildClassStructure());

            if (!string.IsNullOrEmpty(productName))
            {
                Text = $"AssetStudioGUI v{Application.ProductVersion} - {productName} - {assetsManager.assetsFileList[0].unityVersion} - {assetsManager.assetsFileList[0].m_TargetPlatform}";
            }
            else
            {
                Text = $"AssetStudioGUI v{Application.ProductVersion} - no productName - {assetsManager.assetsFileList[0].unityVersion} - {assetsManager.assetsFileList[0].m_TargetPlatform}";
            }

            assetListView.VirtualListSize = visibleAssets.Count;

            sceneTreeView.BeginUpdate();
            sceneTreeView.Nodes.AddRange(treeNodeCollection.ToArray());
            sceneTreeView.EndUpdate();
            treeNodeCollection.Clear();

            classesListView.BeginUpdate();
            foreach (var version in typeMap)
            {
                var versionGroup = new ListViewGroup(version.Key);
                classesListView.Groups.Add(versionGroup);

                foreach (var uclass in version.Value)
                {
                    uclass.Value.Group = versionGroup;
                    classesListView.Items.Add(uclass.Value);
                }
            }
            typeMap.Clear();
            classesListView.EndUpdate();

            var types = exportableAssets.Select(x => x.Type).Distinct().OrderBy(x => x.ToString()).ToArray();
            foreach (var type in types)
            {
                var typeItem = new ToolStripMenuItem
                {
                    CheckOnClick = true,
                    Name = type.ToString(),
                    Size = new Size(180, 22),
                    Text = type.ToString()
                };
                typeItem.Click += typeToolStripMenuItem_Click;
                filterTypeToolStripMenuItem.DropDownItems.Add(typeItem);
            }
            allToolStripMenuItem.Checked = true;
            var log = $"Finished loading {assetsManager.assetsFileList.Count} files with {assetListView.Items.Count} exportable assets";
            var m_ObjectsCount = assetsManager.assetsFileList.Sum(x => x.m_Objects.Count);
            var objectsCount = assetsManager.assetsFileList.Sum(x => x.Objects.Count);
            if (m_ObjectsCount != objectsCount)
            {
                log += $" and {m_ObjectsCount - objectsCount} assets failed to read";
            }
            StatusStripUpdate(log);
        }

        private void typeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var typeItem = (ToolStripMenuItem)sender;
            if (typeItem != allToolStripMenuItem)
            {
                allToolStripMenuItem.Checked = false;
            }
            else if (allToolStripMenuItem.Checked)
            {
                for (var i = 1; i < filterTypeToolStripMenuItem.DropDownItems.Count; i++)
                {
                    var item = (ToolStripMenuItem)filterTypeToolStripMenuItem.DropDownItems[i];
                    item.Checked = false;
                }
            }
            FilterAssetList();
        }

        private void AssetStudioForm_KeyDown(object sender, KeyEventArgs e)
        {
            if (glControl1.Visible)
            {
                if (e.Control)
                {
                    switch (e.KeyCode)
                    {
                        case Keys.W:
                            //Toggle WireFrame
                            wireFrameMode = (wireFrameMode + 1) % 3;
                            glControl1.Invalidate();
                            break;
                        case Keys.S:
                            //Toggle Shade
                            shadeMode = (shadeMode + 1) % 2;
                            glControl1.Invalidate();
                            break;
                        case Keys.N:
                            //Normal mode
                            normalMode = (normalMode + 1) % 2;
                            CreateVAO();
                            glControl1.Invalidate();
                            break;
                    }
                }
            }
            else if (previewPanel.Visible)
            {
                if (e.Control)
                {
                    var need = false;
                    switch (e.KeyCode)
                    {
                        case Keys.B:
                            textureChannels[0] = !textureChannels[0];
                            need = true;
                            break;
                        case Keys.G:
                            textureChannels[1] = !textureChannels[1];
                            need = true;
                            break;
                        case Keys.R:
                            textureChannels[2] = !textureChannels[2];
                            need = true;
                            break;
                        case Keys.A:
                            textureChannels[3] = !textureChannels[3];
                            need = true;
                            break;
                    }
                    if (need)
                    {
                        if (lastSelectedItem != null)
                        {
                            PreviewAsset(lastSelectedItem);
                            assetInfoLabel.Text = lastSelectedItem.InfoText;
                        }
                    }
                }
            }
        }

        private void exportClassStructuresMenuItem_Click(object sender, EventArgs e)
        {
            if (classesListView.Items.Count > 0)
            {
                var saveFolderDialog = new OpenFolderDialog();
                if (saveFolderDialog.ShowDialog(this) == DialogResult.OK)
                {
                    var savePath = saveFolderDialog.Folder;
                    var count = classesListView.Items.Count;
                    int i = 0;
                    Progress.Reset();
                    foreach (TypeTreeItem item in classesListView.Items)
                    {
                        var versionPath = Path.Combine(savePath, item.Group.Header);
                        Directory.CreateDirectory(versionPath);

                        var saveFile = $"{versionPath}{Path.DirectorySeparatorChar}{item.SubItems[1].Text} {item.Text}.txt";
                        File.WriteAllText(saveFile, item.ToString());

                        Progress.Report(++i, count);
                    }

                    StatusStripUpdate("Finished exporting class structures");
                }
            }
        }

        private void displayAll_CheckedChanged(object sender, EventArgs e)
        {
            Properties.Settings.Default.displayAll = displayAll.Checked;
            Properties.Settings.Default.Save();
        }

        private void enablePreview_Check(object sender, EventArgs e)
        {
            if (lastSelectedItem != null)
            {
                switch (lastSelectedItem.Type)
                {
                    case ClassIDType.Texture2D:
                    case ClassIDType.Sprite:
                        {
                            if (enablePreview.Checked && imageTexture != null)
                            {
                                previewPanel.BackgroundImage = imageTexture.Bitmap;
                            }
                            else
                            {
                                previewPanel.BackgroundImage = Properties.Resources.preview;
                                previewPanel.BackgroundImageLayout = ImageLayout.Center;
                            }
                        }
                        break;
                    case ClassIDType.Shader:
                    case ClassIDType.TextAsset:
                    case ClassIDType.MonoBehaviour:
                        textPreviewBox.Visible = !textPreviewBox.Visible;
                        break;
                    case ClassIDType.Font:
                        fontPreviewBox.Visible = !fontPreviewBox.Visible;
                        break;
                    case ClassIDType.AudioClip:
                        {
                            FMODpanel.Visible = !FMODpanel.Visible;

                            if (sound != null && channel != null)
                            {
                                var result = channel.isPlaying(out var playing);
                                if (result == FMOD.RESULT.OK && playing)
                                {
                                    channel.stop();
                                    FMODreset();
                                }
                            }
                            else if (FMODpanel.Visible)
                            {
                                PreviewAsset(lastSelectedItem);
                            }

                            break;
                        }

                }

            }
            else if (lastSelectedItem != null && enablePreview.Checked)
            {
                PreviewAsset(lastSelectedItem);
            }

            Properties.Settings.Default.enablePreview = enablePreview.Checked;
            Properties.Settings.Default.Save();
        }

        private void displayAssetInfo_Check(object sender, EventArgs e)
        {
            if (displayInfo.Checked && assetInfoLabel.Text != null)
            {
                assetInfoLabel.Visible = true;
            }
            else
            {
                assetInfoLabel.Visible = false;
            }

            Properties.Settings.Default.displayInfo = displayInfo.Checked;
            Properties.Settings.Default.Save();
        }

        private void showExpOpt_Click(object sender, EventArgs e)
        {
            var exportOpt = new ExportOptions();
            exportOpt.ShowDialog(this);
        }

        private void assetListView_RetrieveVirtualItem(object sender, RetrieveVirtualItemEventArgs e)
        {
            e.Item = visibleAssets[e.ItemIndex];
        }

        private void tabPageSelected(object sender, TabControlEventArgs e)
        {
            switch (e.TabPageIndex)
            {
                case 0:
                    treeSearch.Select();
                    break;
                case 1:
                    listSearch.Select();
                    break;
            }
        }

        private void treeSearch_Enter(object sender, EventArgs e)
        {
            if (treeSearch.Text == " Search ")
            {
                treeSearch.Text = "";
                treeSearch.ForeColor = SystemColors.WindowText;
            }
        }

        private void treeSearch_Leave(object sender, EventArgs e)
        {
            if (treeSearch.Text == "")
            {
                treeSearch.Text = " Search ";
                treeSearch.ForeColor = SystemColors.GrayText;
            }
        }

        private void treeSearch_TextChanged(object sender, EventArgs e)
        {
            treeSrcResults.Clear();
            nextGObject = 0;
        }

        private void treeSearch_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Enter)
            {
                if (treeSrcResults.Count == 0)
                {
                    foreach (TreeNode node in sceneTreeView.Nodes)
                    {
                        TreeNodeSearch(node);
                    }
                }
                if (treeSrcResults.Count > 0)
                {
                    if (nextGObject >= treeSrcResults.Count)
                    {
                        nextGObject = 0;
                    }
                    treeSrcResults[nextGObject].EnsureVisible();
                    sceneTreeView.SelectedNode = treeSrcResults[nextGObject];
                    nextGObject++;
                }
            }
        }

        private void TreeNodeSearch(TreeNode treeNode)
        {
            if (treeNode.Text.IndexOf(treeSearch.Text, StringComparison.OrdinalIgnoreCase) >= 0)
            {
                treeSrcResults.Add(treeNode);
            }

            foreach (TreeNode node in treeNode.Nodes)
            {
                TreeNodeSearch(node);
            }
        }

        private void sceneTreeView_AfterCheck(object sender, TreeViewEventArgs e)
        {
            foreach (TreeNode childNode in e.Node.Nodes)
            {
                childNode.Checked = e.Node.Checked;
            }
        }

        private void listSearch_Enter(object sender, EventArgs e)
        {
            if (listSearch.Text == " Filter ")
            {
                listSearch.Text = "";
                listSearch.ForeColor = SystemColors.WindowText;
                enableFiltering = true;
            }
        }

        private void listSearch_Leave(object sender, EventArgs e)
        {
            if (listSearch.Text == "")
            {
                enableFiltering = false;
                listSearch.Text = " Filter ";
                listSearch.ForeColor = SystemColors.GrayText;
            }
        }

        private void ListSearchTextChanged(object sender, EventArgs e)
        {
            if (enableFiltering)
            {
                if (delayTimer.Enabled)
                {
                    delayTimer.Stop();
                    delayTimer.Start();
                }
                else
                {
                    delayTimer.Start();
                }
            }
        }

        private void delayTimer_Elapsed(object sender, ElapsedEventArgs e)
        {
            delayTimer.Stop();
            Invoke(new Action(FilterAssetList));
        }

        private void assetListView_ColumnClick(object sender, ColumnClickEventArgs e)
        {
            if (sortColumn != e.Column)
            {
                reverseSort = false;
            }
            else
            {
                reverseSort = !reverseSort;
            }
            sortColumn = e.Column;
            assetListView.BeginUpdate();
            assetListView.SelectedIndices.Clear();
            if (sortColumn == 4) //FullSize
            {
                visibleAssets.Sort((a, b) =>
                {
                    var asf = a.FullSize;
                    var bsf = b.FullSize;
                    return reverseSort ? bsf.CompareTo(asf) : asf.CompareTo(bsf);
                });
            }
            else if (sortColumn == 3) // PathID
            {
                visibleAssets.Sort((x, y) =>
                {
                    long pathID_X = x.m_PathID;
                    long pathID_Y = y.m_PathID;
                    return reverseSort ? pathID_Y.CompareTo(pathID_X) : pathID_X.CompareTo(pathID_Y);
                });
            }
            else
            {
                visibleAssets.Sort((a, b) =>
                {
                    var at = a.SubItems[sortColumn].Text;
                    var bt = b.SubItems[sortColumn].Text;
                    return reverseSort ? bt.CompareTo(at) : at.CompareTo(bt);
                });
            }
            assetListView.EndUpdate();
        }

        private void selectAsset(object sender, ListViewItemSelectionChangedEventArgs e)
        {
            previewPanel.BackgroundImage = Properties.Resources.preview;
            previewPanel.BackgroundImageLayout = ImageLayout.Center;
            classTextBox.Visible = false;
            assetInfoLabel.Visible = false;
            assetInfoLabel.Text = null;
            textPreviewBox.Visible = false;
            fontPreviewBox.Visible = false;
            FMODpanel.Visible = false;
            glControl1.Visible = false;
            StatusStripUpdate("");

            FMODreset();

            lastSelectedItem = (AssetItem)e.Item;

            if (e.IsSelected)
            {
                if (tabControl2.SelectedIndex == 1)
                {
                    dumpTextBox.Text = DumpAsset(lastSelectedItem.Asset);
                }
                if (enablePreview.Checked)
                {
                    PreviewAsset(lastSelectedItem);
                    if (displayInfo.Checked && lastSelectedItem.InfoText != null)
                    {
                        assetInfoLabel.Text = lastSelectedItem.InfoText;
                        assetInfoLabel.Visible = true;
                    }
                }
            }
        }

        private void classesListView_ItemSelectionChanged(object sender, ListViewItemSelectionChangedEventArgs e)
        {
            classTextBox.Visible = true;
            assetInfoLabel.Visible = false;
            assetInfoLabel.Text = null;
            textPreviewBox.Visible = false;
            fontPreviewBox.Visible = false;
            FMODpanel.Visible = false;
            glControl1.Visible = false;
            StatusStripUpdate("");
            if (e.IsSelected)
            {
                classTextBox.Text = ((TypeTreeItem)classesListView.SelectedItems[0]).ToString();
            }
        }

        private void preview_Resize(object sender, EventArgs e)
        {
            if (glControlLoaded && glControl1.Visible)
            {
                ChangeGLSize(glControl1.Size);
                glControl1.Invalidate();
            }
        }

        private void PreviewAsset(AssetItem assetItem)
        {
            if (assetItem == null)
                return;
            try
            {
                switch (assetItem.Asset)
                {
                    case Texture2D m_Texture2D:
                        PreviewTexture2D(assetItem, m_Texture2D);
                        break;
                    case AudioClip m_AudioClip:
                        PreviewAudioClip(assetItem, m_AudioClip);
                        break;
                    case Shader m_Shader:
                        PreviewShader(m_Shader);
                        break;
                    case TextAsset m_TextAsset:
                        PreviewTextAsset(m_TextAsset);
                        break;
                    case MonoBehaviour m_MonoBehaviour:
                        PreviewMonoBehaviour(m_MonoBehaviour);
                        break;
                    case Font m_Font:
                        PreviewFont(m_Font);
                        break;
                    case Mesh m_Mesh:
                        PreviewMesh(m_Mesh);
                        break;
                    case VideoClip _:
                    case MovieTexture _:
                        StatusStripUpdate("Only supported export.");
                        break;
                    case Sprite m_Sprite:
                        PreviewSprite(assetItem, m_Sprite);
                        break;
                    case Animator _:
                        StatusStripUpdate("Can be exported to FBX file.");
                        break;
                    case AnimationClip _:
                        StatusStripUpdate("Can be exported with Animator or Objects");
                        break;
                    default:
                        var str = assetItem.Asset.Dump();
                        if (str != null)
                        {
                            textPreviewBox.Text = str;
                            textPreviewBox.Visible = true;
                        }
                        break;
                }
            }
            catch (Exception e)
            {
                MessageBox.Show($"Preview {assetItem.Type}:{assetItem.Text} error\r\n{e.Message}\r\n{e.StackTrace}");
            }
        }

        private void PreviewTexture2D(AssetItem assetItem, Texture2D m_Texture2D)
        {
            var image = m_Texture2D.ConvertToImage(true);
            if (image != null)
            {
                var bitmap = new DirectBitmap(image.ConvertToBytes(), m_Texture2D.m_Width, m_Texture2D.m_Height);
                image.Dispose();
                assetItem.InfoText = $"Width: {m_Texture2D.m_Width}\nHeight: {m_Texture2D.m_Height}\nFormat: {m_Texture2D.m_TextureFormat}";
                switch (m_Texture2D.m_TextureSettings.m_FilterMode)
                {
                    case 0: assetItem.InfoText += "\nFilter Mode: Point "; break;
                    case 1: assetItem.InfoText += "\nFilter Mode: Bilinear "; break;
                    case 2: assetItem.InfoText += "\nFilter Mode: Trilinear "; break;
                }
                assetItem.InfoText += $"\nAnisotropic level: {m_Texture2D.m_TextureSettings.m_Aniso}\nMip map bias: {m_Texture2D.m_TextureSettings.m_MipBias}";
                switch (m_Texture2D.m_TextureSettings.m_WrapMode)
                {
                    case 0: assetItem.InfoText += "\nWrap mode: Repeat"; break;
                    case 1: assetItem.InfoText += "\nWrap mode: Clamp"; break;
                }
                assetItem.InfoText += "\nChannels: ";
                int validChannel = 0;
                for (int i = 0; i < 4; i++)
                {
                    if (textureChannels[i])
                    {
                        assetItem.InfoText += textureChannelNames[i];
                        validChannel++;
                    }
                }
                if (validChannel == 0)
                    assetItem.InfoText += "None";
                if (validChannel != 4)
                {
                    var bytes = bitmap.Bits;
                    for (int i = 0; i < bitmap.Height; i++)
                    {
                        int offset = Math.Abs(bitmap.Stride) * i;
                        for (int j = 0; j < bitmap.Width; j++)
                        {
                            bytes[offset] = textureChannels[0] ? bytes[offset] : validChannel == 1 && textureChannels[3] ? byte.MaxValue : byte.MinValue;
                            bytes[offset + 1] = textureChannels[1] ? bytes[offset + 1] : validChannel == 1 && textureChannels[3] ? byte.MaxValue : byte.MinValue;
                            bytes[offset + 2] = textureChannels[2] ? bytes[offset + 2] : validChannel == 1 && textureChannels[3] ? byte.MaxValue : byte.MinValue;
                            bytes[offset + 3] = textureChannels[3] ? bytes[offset + 3] : byte.MaxValue;
                            offset += 4;
                        }
                    }
                }
                PreviewTexture(bitmap);

                StatusStripUpdate("'Ctrl'+'R'/'G'/'B'/'A' for Channel Toggle");
            }
            else
            {
                StatusStripUpdate("Unsupported image for preview");
            }
        }

        private void PreviewAudioClip(AssetItem assetItem, AudioClip m_AudioClip)
        {
            //Info
            assetItem.InfoText = "Compression format: ";
            if (m_AudioClip.version[0] < 5)
            {
                switch (m_AudioClip.m_Type)
                {
                    case FMODSoundType.ACC:
                        assetItem.InfoText += "Acc";
                        break;
                    case FMODSoundType.AIFF:
                        assetItem.InfoText += "AIFF";
                        break;
                    case FMODSoundType.IT:
                        assetItem.InfoText += "Impulse tracker";
                        break;
                    case FMODSoundType.MOD:
                        assetItem.InfoText += "Protracker / Fasttracker MOD";
                        break;
                    case FMODSoundType.MPEG:
                        assetItem.InfoText += "MP2/MP3 MPEG";
                        break;
                    case FMODSoundType.OGGVORBIS:
                        assetItem.InfoText += "Ogg vorbis";
                        break;
                    case FMODSoundType.S3M:
                        assetItem.InfoText += "ScreamTracker 3";
                        break;
                    case FMODSoundType.WAV:
                        assetItem.InfoText += "Microsoft WAV";
                        break;
                    case FMODSoundType.XM:
                        assetItem.InfoText += "FastTracker 2 XM";
                        break;
                    case FMODSoundType.XMA:
                        assetItem.InfoText += "Xbox360 XMA";
                        break;
                    case FMODSoundType.VAG:
                        assetItem.InfoText += "PlayStation Portable ADPCM";
                        break;
                    case FMODSoundType.AUDIOQUEUE:
                        assetItem.InfoText += "iPhone";
                        break;
                    default:
                        assetItem.InfoText += "Unknown";
                        break;
                }
            }
            else
            {
                switch (m_AudioClip.m_CompressionFormat)
                {
                    case AudioCompressionFormat.PCM:
                        assetItem.InfoText += "PCM";
                        break;
                    case AudioCompressionFormat.Vorbis:
                        assetItem.InfoText += "Vorbis";
                        break;
                    case AudioCompressionFormat.ADPCM:
                        assetItem.InfoText += "ADPCM";
                        break;
                    case AudioCompressionFormat.MP3:
                        assetItem.InfoText += "MP3";
                        break;
                    case AudioCompressionFormat.PSMVAG:
                        assetItem.InfoText += "PlayStation Portable ADPCM";
                        break;
                    case AudioCompressionFormat.HEVAG:
                        assetItem.InfoText += "PSVita ADPCM";
                        break;
                    case AudioCompressionFormat.XMA:
                        assetItem.InfoText += "Xbox360 XMA";
                        break;
                    case AudioCompressionFormat.AAC:
                        assetItem.InfoText += "AAC";
                        break;
                    case AudioCompressionFormat.GCADPCM:
                        assetItem.InfoText += "Nintendo 3DS/Wii DSP";
                        break;
                    case AudioCompressionFormat.ATRAC9:
                        assetItem.InfoText += "PSVita ATRAC9";
                        break;
                    default:
                        assetItem.InfoText += "Unknown";
                        break;
                }
            }

            var m_AudioData = m_AudioClip.m_AudioData.GetData();
            if (m_AudioData == null || m_AudioData.Length == 0)
                return;
            var exinfo = new FMOD.CREATESOUNDEXINFO();

            exinfo.cbsize = Marshal.SizeOf(exinfo);
            exinfo.length = (uint)m_AudioClip.m_Size;

            var result = system.createSound(m_AudioData, FMOD.MODE.OPENMEMORY | loopMode, ref exinfo, out sound);
            if (ERRCHECK(result)) return;

            sound.getNumSubSounds(out var numsubsounds);

            if (numsubsounds > 0)
            {
                result = sound.getSubSound(0, out var subsound);
                if (result == FMOD.RESULT.OK)
                {
                    sound = subsound;
                }
            }

            result = sound.getLength(out FMODlenms, FMOD.TIMEUNIT.MS);
            if (ERRCHECK(result)) return;

            result = system.playSound(sound, null, true, out channel);
            if (ERRCHECK(result)) return;

            FMODpanel.Visible = true;

            result = channel.getFrequency(out var frequency);
            if (ERRCHECK(result)) return;

            FMODinfoLabel.Text = frequency + " Hz";
            FMODtimerLabel.Text = $"0:0.0 / {FMODlenms / 1000 / 60}:{FMODlenms / 1000 % 60}.{FMODlenms / 10 % 100}";
        }

        private void PreviewShader(Shader m_Shader)
        {
            var str = ShaderConverter.Convert(m_Shader);
            PreviewText(str == null ? "Serialized Shader can't be read" : str.Replace("\n", "\r\n"));
        }

        private void PreviewTextAsset(TextAsset m_TextAsset)
        {
            var text = Encoding.UTF8.GetString(m_TextAsset.m_Script);
            text = text.Replace("\n", "\r\n").Replace("\0", "");
            PreviewText(text);
        }

        private void PreviewMonoBehaviour(MonoBehaviour m_MonoBehaviour)
        {
            var obj = m_MonoBehaviour.ToType();
            if (obj == null)
            {
                var type = MonoBehaviourToTypeTree(m_MonoBehaviour);
                obj = m_MonoBehaviour.ToType(type);
            }
            var str = JsonConvert.SerializeObject(obj, Formatting.Indented);
            PreviewText(str);
        }

        private void PreviewFont(Font m_Font)
        {
            if (m_Font.m_FontData != null)
            {
                var data = Marshal.AllocCoTaskMem(m_Font.m_FontData.Length);
                Marshal.Copy(m_Font.m_FontData, 0, data, m_Font.m_FontData.Length);

                uint cFonts = 0;
                var re = AddFontMemResourceEx(data, (uint)m_Font.m_FontData.Length, IntPtr.Zero, ref cFonts);
                if (re != IntPtr.Zero)
                {
                    using (var pfc = new PrivateFontCollection())
                    {
                        pfc.AddMemoryFont(data, m_Font.m_FontData.Length);
                        Marshal.FreeCoTaskMem(data);
                        if (pfc.Families.Length > 0)
                        {
                            fontPreviewBox.SelectionStart = 0;
                            fontPreviewBox.SelectionLength = 80;
                            fontPreviewBox.SelectionFont = new System.Drawing.Font(pfc.Families[0], 16, FontStyle.Regular);
                            fontPreviewBox.SelectionStart = 81;
                            fontPreviewBox.SelectionLength = 56;
                            fontPreviewBox.SelectionFont = new System.Drawing.Font(pfc.Families[0], 12, FontStyle.Regular);
                            fontPreviewBox.SelectionStart = 138;
                            fontPreviewBox.SelectionLength = 56;
                            fontPreviewBox.SelectionFont = new System.Drawing.Font(pfc.Families[0], 18, FontStyle.Regular);
                            fontPreviewBox.SelectionStart = 195;
                            fontPreviewBox.SelectionLength = 56;
                            fontPreviewBox.SelectionFont = new System.Drawing.Font(pfc.Families[0], 24, FontStyle.Regular);
                            fontPreviewBox.SelectionStart = 252;
                            fontPreviewBox.SelectionLength = 56;
                            fontPreviewBox.SelectionFont = new System.Drawing.Font(pfc.Families[0], 36, FontStyle.Regular);
                            fontPreviewBox.SelectionStart = 309;
                            fontPreviewBox.SelectionLength = 56;
                            fontPreviewBox.SelectionFont = new System.Drawing.Font(pfc.Families[0], 48, FontStyle.Regular);
                            fontPreviewBox.SelectionStart = 366;
                            fontPreviewBox.SelectionLength = 56;
                            fontPreviewBox.SelectionFont = new System.Drawing.Font(pfc.Families[0], 60, FontStyle.Regular);
                            fontPreviewBox.SelectionStart = 423;
                            fontPreviewBox.SelectionLength = 55;
                            fontPreviewBox.SelectionFont = new System.Drawing.Font(pfc.Families[0], 72, FontStyle.Regular);
                            fontPreviewBox.Visible = true;
                        }
                    }
                    return;
                }
            }
            StatusStripUpdate("Unsupported font for preview. Try to export.");
        }

        private void PreviewMesh(Mesh m_Mesh)
        {
            if (m_Mesh.m_VertexCount > 0)
            {
                viewMatrixData = Matrix4.CreateRotationY(-(float)Math.PI / 4) * Matrix4.CreateRotationX(-(float)Math.PI / 6);
                #region Vertices
                if (m_Mesh.m_Vertices == null || m_Mesh.m_Vertices.Length == 0)
                {
                    StatusStripUpdate("Mesh can't be previewed.");
                    return;
                }
                int count = 3;
                if (m_Mesh.m_Vertices.Length == m_Mesh.m_VertexCount * 4)
                {
                    count = 4;
                }
                vertexData = new Vector3[m_Mesh.m_VertexCount];
                // Calculate Bounding
                float[] min = new float[3];
                float[] max = new float[3];
                for (int i = 0; i < 3; i++)
                {
                    min[i] = m_Mesh.m_Vertices[i];
                    max[i] = m_Mesh.m_Vertices[i];
                }
                for (int v = 0; v < m_Mesh.m_VertexCount; v++)
                {
                    for (int i = 0; i < 3; i++)
                    {
                        min[i] = Math.Min(min[i], m_Mesh.m_Vertices[v * count + i]);
                        max[i] = Math.Max(max[i], m_Mesh.m_Vertices[v * count + i]);
                    }
                    vertexData[v] = new Vector3(
                        m_Mesh.m_Vertices[v * count],
                        m_Mesh.m_Vertices[v * count + 1],
                        m_Mesh.m_Vertices[v * count + 2]);
                }

                // Calculate modelMatrix
                Vector3 dist = Vector3.One, offset = Vector3.Zero;
                for (int i = 0; i < 3; i++)
                {
                    dist[i] = max[i] - min[i];
                    offset[i] = (max[i] + min[i]) / 2;
                }
                float d = Math.Max(1e-5f, dist.Length);
                modelMatrixData = Matrix4.CreateTranslation(-offset) * Matrix4.CreateScale(2f / d);
                #endregion
                #region Indicies
                indiceData = new int[m_Mesh.m_Indices.Count];
                for (int i = 0; i < m_Mesh.m_Indices.Count; i = i + 3)
                {
                    indiceData[i] = (int)m_Mesh.m_Indices[i];
                    indiceData[i + 1] = (int)m_Mesh.m_Indices[i + 1];
                    indiceData[i + 2] = (int)m_Mesh.m_Indices[i + 2];
                }
                #endregion
                #region Normals
                if (m_Mesh.m_Normals != null && m_Mesh.m_Normals.Length > 0)
                {
                    if (m_Mesh.m_Normals.Length == m_Mesh.m_VertexCount * 3)
                        count = 3;
                    else if (m_Mesh.m_Normals.Length == m_Mesh.m_VertexCount * 4)
                        count = 4;
                    normalData = new Vector3[m_Mesh.m_VertexCount];
                    for (int n = 0; n < m_Mesh.m_VertexCount; n++)
                    {
                        normalData[n] = new Vector3(
                            m_Mesh.m_Normals[n * count],
                            m_Mesh.m_Normals[n * count + 1],
                            m_Mesh.m_Normals[n * count + 2]);
                    }
                }
                else
                    normalData = null;
                // calculate normal by ourself
                normal2Data = new Vector3[m_Mesh.m_VertexCount];
                int[] normalCalculatedCount = new int[m_Mesh.m_VertexCount];
                for (int i = 0; i < m_Mesh.m_VertexCount; i++)
                {
                    normal2Data[i] = Vector3.Zero;
                    normalCalculatedCount[i] = 0;
                }
                for (int i = 0; i < m_Mesh.m_Indices.Count; i = i + 3)
                {
                    Vector3 dir1 = vertexData[indiceData[i + 1]] - vertexData[indiceData[i]];
                    Vector3 dir2 = vertexData[indiceData[i + 2]] - vertexData[indiceData[i]];
                    Vector3 normal = Vector3.Cross(dir1, dir2);
                    normal.Normalize();
                    for (int j = 0; j < 3; j++)
                    {
                        normal2Data[indiceData[i + j]] += normal;
                        normalCalculatedCount[indiceData[i + j]]++;
                    }
                }
                for (int i = 0; i < m_Mesh.m_VertexCount; i++)
                {
                    if (normalCalculatedCount[i] == 0)
                        normal2Data[i] = new Vector3(0, 1, 0);
                    else
                        normal2Data[i] /= normalCalculatedCount[i];
                }
                #endregion
                #region Colors
                if (m_Mesh.m_Colors != null && m_Mesh.m_Colors.Length == m_Mesh.m_VertexCount * 3)
                {
                    colorData = new Vector4[m_Mesh.m_VertexCount];
                    for (int c = 0; c < m_Mesh.m_VertexCount; c++)
                    {
                        colorData[c] = new Vector4(
                            m_Mesh.m_Colors[c * 3],
                            m_Mesh.m_Colors[c * 3 + 1],
                            m_Mesh.m_Colors[c * 3 + 2],
                            1.0f);
                    }
                }
                else if (m_Mesh.m_Colors != null && m_Mesh.m_Colors.Length == m_Mesh.m_VertexCount * 4)
                {
                    colorData = new Vector4[m_Mesh.m_VertexCount];
                    for (int c = 0; c < m_Mesh.m_VertexCount; c++)
                    {
                        colorData[c] = new Vector4(
                        m_Mesh.m_Colors[c * 4],
                        m_Mesh.m_Colors[c * 4 + 1],
                        m_Mesh.m_Colors[c * 4 + 2],
                        m_Mesh.m_Colors[c * 4 + 3]);
                    }
                }
                else
                {
                    colorData = new Vector4[m_Mesh.m_VertexCount];
                    for (int c = 0; c < m_Mesh.m_VertexCount; c++)
                    {
                        colorData[c] = new Vector4(0.5f, 0.5f, 0.5f, 1.0f);
                    }
                }
                #endregion
                glControl1.Visible = true;
                CreateVAO();
                StatusStripUpdate("Using OpenGL Version: " + GL.GetString(StringName.Version) + "\n"
                                  + "'Mouse Left'=Rotate | 'Mouse Right'=Move | 'Mouse Wheel'=Zoom \n"
                                  + "'Ctrl W'=Wireframe | 'Ctrl S'=Shade | 'Ctrl N'=ReNormal ");
            }
            else
            {
                StatusStripUpdate("Unable to preview this mesh");
            }
        }

        private void PreviewSprite(AssetItem assetItem, Sprite m_Sprite)
        {
            var image = m_Sprite.GetImage();
            if (image != null)
            {
                var bitmap = new DirectBitmap(image.ConvertToBytes(), image.Width, image.Height);
                image.Dispose();
                assetItem.InfoText = $"Width: {bitmap.Width}\nHeight: {bitmap.Height}\n";
                PreviewTexture(bitmap);
            }
            else
            {
                StatusStripUpdate("Unsupported sprite for preview.");
            }
        }

        private void PreviewTexture(DirectBitmap bitmap)
        {
            imageTexture?.Dispose();
            imageTexture = bitmap;
            previewPanel.BackgroundImage = imageTexture.Bitmap;
            if (imageTexture.Width > previewPanel.Width || imageTexture.Height > previewPanel.Height)
                previewPanel.BackgroundImageLayout = ImageLayout.Zoom;
            else
                previewPanel.BackgroundImageLayout = ImageLayout.Center;
        }

        private void PreviewText(string text)
        {
            textPreviewBox.Text = text;
            textPreviewBox.Visible = true;
        }

        private void SetProgressBarValue(int value)
        {
            if (InvokeRequired)
            {
                BeginInvoke(new Action(() => { progressBar1.Value = value; }));
            }
            else
            {
                progressBar1.Value = value;
            }
        }

        private void StatusStripUpdate(string statusText)
        {
            if (InvokeRequired)
            {
                BeginInvoke(new Action(() => { toolStripStatusLabel1.Text = statusText; }));
            }
            else
            {
                toolStripStatusLabel1.Text = statusText;
            }
        }

        private void ResetForm()
        {
            Text = $"AssetStudioGUI v{Application.ProductVersion}";
            assetsManager.Clear();
            assemblyLoader.Clear();
            exportableAssets.Clear();
            visibleAssets.Clear();
            sceneTreeView.Nodes.Clear();
            assetListView.VirtualListSize = 0;
            assetListView.Items.Clear();
            classesListView.Items.Clear();
            classesListView.Groups.Clear();
            previewPanel.BackgroundImage = Properties.Resources.preview;
            imageTexture?.Dispose();
            imageTexture = null;
            previewPanel.BackgroundImageLayout = ImageLayout.Center;
            assetInfoLabel.Visible = false;
            assetInfoLabel.Text = null;
            textPreviewBox.Visible = false;
            fontPreviewBox.Visible = false;
            glControl1.Visible = false;
            lastSelectedItem = null;
            sortColumn = -1;
            reverseSort = false;
            enableFiltering = false;
            listSearch.Text = " Filter ";

            var count = filterTypeToolStripMenuItem.DropDownItems.Count;
            for (var i = 1; i < count; i++)
            {
                filterTypeToolStripMenuItem.DropDownItems.RemoveAt(1);
            }

            FMODreset();
        }

        private void assetListView_MouseClick(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right && assetListView.SelectedIndices.Count > 0)
            {
                goToSceneHierarchyToolStripMenuItem.Visible = false;
                showOriginalFileToolStripMenuItem.Visible = false;
                exportAnimatorwithselectedAnimationClipMenuItem.Visible = false;

                if (assetListView.SelectedIndices.Count == 1)
                {
                    goToSceneHierarchyToolStripMenuItem.Visible = true;
                    showOriginalFileToolStripMenuItem.Visible = true;
                }
                if (assetListView.SelectedIndices.Count >= 1)
                {
                    var selectedAssets = GetSelectedAssets();
                    if (selectedAssets.Any(x => x.Type == ClassIDType.Animator) && selectedAssets.Any(x => x.Type == ClassIDType.AnimationClip))
                    {
                        exportAnimatorwithselectedAnimationClipMenuItem.Visible = true;
                    }
                }

                tempClipboard = assetListView.HitTest(new Point(e.X, e.Y)).SubItem.Text;
                contextMenuStrip1.Show(assetListView, e.X, e.Y);
            }
        }

        private void copyToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Clipboard.SetDataObject(tempClipboard);
        }

        private void exportSelectedAssetsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ExportAssets(ExportFilter.Selected, ExportType.Convert);
        }

        private void showOriginalFileToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var selectasset = (AssetItem)assetListView.Items[assetListView.SelectedIndices[0]];
            var args = $"/select, \"{selectasset.SourceFile.originalPath ?? selectasset.SourceFile.fullName}\"";
            var pfi = new ProcessStartInfo("explorer.exe", args);
            Process.Start(pfi);
        }

        private void exportAnimatorwithAnimationClipMenuItem_Click(object sender, EventArgs e)
        {
            AssetItem animator = null;
            List<AssetItem> animationList = new List<AssetItem>();
            var selectedAssets = GetSelectedAssets();
            foreach (var assetPreloadData in selectedAssets)
            {
                if (assetPreloadData.Type == ClassIDType.Animator)
                {
                    animator = assetPreloadData;
                }
                else if (assetPreloadData.Type == ClassIDType.AnimationClip)
                {
                    animationList.Add(assetPreloadData);
                }
            }

            if (animator != null)
            {
                var saveFolderDialog = new OpenFolderDialog();
                saveFolderDialog.InitialFolder = saveDirectoryBackup;
                if (saveFolderDialog.ShowDialog(this) == DialogResult.OK)
                {
                    saveDirectoryBackup = saveFolderDialog.Folder;
                    var exportPath = Path.Combine(saveFolderDialog.Folder, "Animator") + Path.DirectorySeparatorChar;
                    ExportAnimatorWithAnimationClip(animator, animationList, exportPath);
                }
            }
        }

        private void exportSelectedObjectsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ExportObjects(false);
        }

        private void exportObjectswithAnimationClipMenuItem_Click(object sender, EventArgs e)
        {
            ExportObjects(true);
        }

        private void ExportObjects(bool animation)
        {
            if (sceneTreeView.Nodes.Count > 0)
            {
                var saveFolderDialog = new OpenFolderDialog();
                saveFolderDialog.InitialFolder = saveDirectoryBackup;
                if (saveFolderDialog.ShowDialog(this) == DialogResult.OK)
                {
                    saveDirectoryBackup = saveFolderDialog.Folder;
                    var exportPath = Path.Combine(saveFolderDialog.Folder, "GameObject") + Path.DirectorySeparatorChar;
                    List<AssetItem> animationList = null;
                    if (animation)
                    {
                        animationList = GetSelectedAssets().Where(x => x.Type == ClassIDType.AnimationClip).ToList();
                        if (animationList.Count == 0)
                        {
                            animationList = null;
                        }
                    }
                    ExportObjectsWithAnimationClip(exportPath, sceneTreeView.Nodes, animationList);
                }
            }
            else
            {
                StatusStripUpdate("No Objects available for export");
            }
        }

        private void exportSelectedObjectsmergeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ExportMergeObjects(false);
        }

        private void exportSelectedObjectsmergeWithAnimationClipToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ExportMergeObjects(true);
        }

        private void ExportMergeObjects(bool animation)
        {
            if (sceneTreeView.Nodes.Count > 0)
            {
                var gameObjects = new List<GameObject>();
                GetSelectedParentNode(sceneTreeView.Nodes, gameObjects);
                if (gameObjects.Count > 0)
                {
                    var saveFileDialog = new SaveFileDialog();
                    saveFileDialog.FileName = gameObjects[0].m_Name + " (merge).fbx";
                    saveFileDialog.AddExtension = false;
                    saveFileDialog.Filter = "Fbx file (*.fbx)|*.fbx";
                    saveFileDialog.InitialDirectory = saveDirectoryBackup;
                    if (saveFileDialog.ShowDialog(this) == DialogResult.OK)
                    {
                        saveDirectoryBackup = Path.GetDirectoryName(saveFileDialog.FileName);
                        var exportPath = saveFileDialog.FileName;
                        List<AssetItem> animationList = null;
                        if (animation)
                        {
                            animationList = GetSelectedAssets().Where(x => x.Type == ClassIDType.AnimationClip).ToList();
                            if (animationList.Count == 0)
                            {
                                animationList = null;
                            }
                        }
                        ExportObjectsMergeWithAnimationClip(exportPath, gameObjects, animationList);
                    }
                }
                else
                {
                    StatusStripUpdate("No Object selected for export.");
                }
            }
        }

        private void goToSceneHierarchyToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var selectasset = (AssetItem)assetListView.Items[assetListView.SelectedIndices[0]];
            if (selectasset.TreeNode != null)
            {
                sceneTreeView.SelectedNode = selectasset.TreeNode;
                tabControl1.SelectedTab = tabPage1;
            }
        }

        private void exportAllAssetsMenuItem_Click(object sender, EventArgs e)
        {
            ExportAssets(ExportFilter.All, ExportType.Convert);
        }

        private void exportSelectedAssetsMenuItem_Click(object sender, EventArgs e)
        {
            ExportAssets(ExportFilter.Selected, ExportType.Convert);
        }

        private void exportFilteredAssetsMenuItem_Click(object sender, EventArgs e)
        {
            ExportAssets(ExportFilter.Filtered, ExportType.Convert);
        }

        private void toolStripMenuItem4_Click(object sender, EventArgs e)
        {
            ExportAssets(ExportFilter.All, ExportType.Raw);
        }

        private void toolStripMenuItem5_Click(object sender, EventArgs e)
        {
            ExportAssets(ExportFilter.Selected, ExportType.Raw);
        }

        private void toolStripMenuItem6_Click(object sender, EventArgs e)
        {
            ExportAssets(ExportFilter.Filtered, ExportType.Raw);
        }

        private void toolStripMenuItem7_Click(object sender, EventArgs e)
        {
            ExportAssets(ExportFilter.All, ExportType.Dump);
        }

        private void toolStripMenuItem8_Click(object sender, EventArgs e)
        {
            ExportAssets(ExportFilter.Selected, ExportType.Dump);
        }

        private void toolStripMenuItem9_Click(object sender, EventArgs e)
        {
            ExportAssets(ExportFilter.Filtered, ExportType.Dump);
        }

        private void toolStripMenuItem11_Click(object sender, EventArgs e)
        {
            ExportAssetsList(ExportFilter.All);
        }

        private void toolStripMenuItem12_Click(object sender, EventArgs e)
        {
            ExportAssetsList(ExportFilter.Selected);
        }

        private void toolStripMenuItem13_Click(object sender, EventArgs e)
        {
            ExportAssetsList(ExportFilter.Filtered);
        }

        private void exportAllObjectssplitToolStripMenuItem1_Click(object sender, EventArgs e)
        {
            if (sceneTreeView.Nodes.Count > 0)
            {
                var saveFolderDialog = new OpenFolderDialog();
                saveFolderDialog.InitialFolder = saveDirectoryBackup;
                if (saveFolderDialog.ShowDialog(this) == DialogResult.OK)
                {
                    saveDirectoryBackup = saveFolderDialog.Folder;
                    var savePath = saveFolderDialog.Folder + Path.DirectorySeparatorChar;
                    ExportSplitObjects(savePath, sceneTreeView.Nodes);
                }
            }
            else
            {
                StatusStripUpdate("No Objects available for export");
            }
        }

        private List<AssetItem> GetSelectedAssets()
        {
            var selectedAssets = new List<AssetItem>(assetListView.SelectedIndices.Count);
            foreach (int index in assetListView.SelectedIndices)
            {
                selectedAssets.Add((AssetItem)assetListView.Items[index]);
            }

            return selectedAssets;
        }

        private void FilterAssetList()
        {
            assetListView.BeginUpdate();
            assetListView.SelectedIndices.Clear();
            var show = new List<ClassIDType>();
            if (!allToolStripMenuItem.Checked)
            {
                for (var i = 1; i < filterTypeToolStripMenuItem.DropDownItems.Count; i++)
                {
                    var item = (ToolStripMenuItem)filterTypeToolStripMenuItem.DropDownItems[i];
                    if (item.Checked)
                    {
                        show.Add((ClassIDType)Enum.Parse(typeof(ClassIDType), item.Text));
                    }
                }
                visibleAssets = exportableAssets.FindAll(x => show.Contains(x.Type));
            }
            else
            {
                visibleAssets = exportableAssets;
            }
            if (listSearch.Text != " Filter ")
            {
                visibleAssets = visibleAssets.FindAll(
                    x => x.Text.IndexOf(listSearch.Text, StringComparison.OrdinalIgnoreCase) >= 0 ||
                    x.SubItems[1].Text.IndexOf(listSearch.Text, StringComparison.OrdinalIgnoreCase) >= 0 ||
                    x.SubItems[3].Text.IndexOf(listSearch.Text, StringComparison.OrdinalIgnoreCase) >= 0);
            }
            assetListView.VirtualListSize = visibleAssets.Count;
            assetListView.EndUpdate();
        }

        private void ExportAssets(ExportFilter type, ExportType exportType)
        {
            if (exportableAssets.Count > 0)
            {
                var saveFolderDialog = new OpenFolderDialog();
                saveFolderDialog.InitialFolder = saveDirectoryBackup;
                if (saveFolderDialog.ShowDialog(this) == DialogResult.OK)
                {
                    timer.Stop();
                    saveDirectoryBackup = saveFolderDialog.Folder;
                    List<AssetItem> toExportAssets = null;
                    switch (type)
                    {
                        case ExportFilter.All:
                            toExportAssets = exportableAssets;
                            break;
                        case ExportFilter.Selected:
                            toExportAssets = GetSelectedAssets();
                            break;
                        case ExportFilter.Filtered:
                            toExportAssets = visibleAssets;
                            break;
                    }
                    Studio.ExportAssets(saveFolderDialog.Folder, toExportAssets, exportType);
                }
            }
            else
            {
                StatusStripUpdate("No exportable assets loaded");
            }
        }

        private void ExportAssetsList(ExportFilter type)
        {
            // XXX: Only exporting as XML for now, but would JSON(/CSV/other) be useful too?

            if (exportableAssets.Count > 0)
            {
                var saveFolderDialog = new OpenFolderDialog();
                saveFolderDialog.InitialFolder = saveDirectoryBackup;
                if (saveFolderDialog.ShowDialog(this) == DialogResult.OK)
                {
                    timer.Stop();
                    saveDirectoryBackup = saveFolderDialog.Folder;
                    List<AssetItem> toExportAssets = null;
                    switch (type)
                    {
                        case ExportFilter.All:
                            toExportAssets = exportableAssets;
                            break;
                        case ExportFilter.Selected:
                            toExportAssets = GetSelectedAssets();
                            break;
                        case ExportFilter.Filtered:
                            toExportAssets = visibleAssets;
                            break;
                    }
                    Studio.ExportAssetsList(saveFolderDialog.Folder, toExportAssets, ExportListType.XML);
                }
            }
            else
            {
                StatusStripUpdate("No exportable assets loaded");
            }
        }

        #region FMOD
        private void FMODinit()
        {
            FMODreset();

            var result = FMOD.Factory.System_Create(out system);
            if (ERRCHECK(result)) { return; }

            result = system.getVersion(out var version);
            ERRCHECK(result);
            if (version < FMOD.VERSION.number)
            {
                MessageBox.Show($"Error!  You are using an old version of FMOD {version:X}.  This program requires {FMOD.VERSION.number:X}.");
                Application.Exit();
            }

            result = system.init(2, FMOD.INITFLAGS.NORMAL, IntPtr.Zero);
            if (ERRCHECK(result)) { return; }

            result = system.getMasterSoundGroup(out masterSoundGroup);
            if (ERRCHECK(result)) { return; }

            result = masterSoundGroup.setVolume(FMODVolume);
            if (ERRCHECK(result)) { return; }
        }

        private void FMODreset()
        {
            timer.Stop();
            FMODprogressBar.Value = 0;
            FMODtimerLabel.Text = "0:00.0 / 0:00.0";
            FMODstatusLabel.Text = "Stopped";
            FMODinfoLabel.Text = "";

            if (sound != null && sound.isValid())
            {
                var result = sound.release();
                ERRCHECK(result);
                sound = null;
            }
        }

        private void FMODplayButton_Click(object sender, EventArgs e)
        {
            if (sound != null && channel != null)
            {
                timer.Start();
                var result = channel.isPlaying(out var playing);
                if ((result != FMOD.RESULT.OK) && (result != FMOD.RESULT.ERR_INVALID_HANDLE))
                {
                    if (ERRCHECK(result)) { return; }
                }

                if (playing)
                {
                    result = channel.stop();
                    if (ERRCHECK(result)) { return; }

                    result = system.playSound(sound, null, false, out channel);
                    if (ERRCHECK(result)) { return; }

                    FMODpauseButton.Text = "Pause";
                }
                else
                {
                    result = system.playSound(sound, null, false, out channel);
                    if (ERRCHECK(result)) { return; }
                    FMODstatusLabel.Text = "Playing";

                    if (FMODprogressBar.Value > 0)
                    {
                        uint newms = FMODlenms / 1000 * (uint)FMODprogressBar.Value;

                        result = channel.setPosition(newms, FMOD.TIMEUNIT.MS);
                        if ((result != FMOD.RESULT.OK) && (result != FMOD.RESULT.ERR_INVALID_HANDLE))
                        {
                            if (ERRCHECK(result)) { return; }
                        }

                    }
                }
            }
        }

        private void FMODpauseButton_Click(object sender, EventArgs e)
        {
            if (sound != null && channel != null)
            {
                var result = channel.isPlaying(out var playing);
                if ((result != FMOD.RESULT.OK) && (result != FMOD.RESULT.ERR_INVALID_HANDLE))
                {
                    if (ERRCHECK(result)) { return; }
                }

                if (playing)
                {
                    result = channel.getPaused(out var paused);
                    if (ERRCHECK(result)) { return; }
                    result = channel.setPaused(!paused);
                    if (ERRCHECK(result)) { return; }

                    if (paused)
                    {
                        FMODstatusLabel.Text = "Playing";
                        FMODpauseButton.Text = "Pause";
                        timer.Start();
                    }
                    else
                    {
                        FMODstatusLabel.Text = "Paused";
                        FMODpauseButton.Text = "Resume";
                        timer.Stop();
                    }
                }
            }
        }

        private void FMODstopButton_Click(object sender, EventArgs e)
        {
            if (channel != null)
            {
                var result = channel.isPlaying(out var playing);
                if ((result != FMOD.RESULT.OK) && (result != FMOD.RESULT.ERR_INVALID_HANDLE))
                {
                    if (ERRCHECK(result)) { return; }
                }

                if (playing)
                {
                    result = channel.stop();
                    if (ERRCHECK(result)) { return; }
                    //channel = null;
                    //don't FMODreset, it will nullify the sound
                    timer.Stop();
                    FMODprogressBar.Value = 0;
                    FMODtimerLabel.Text = "0:00.0 / 0:00.0";
                    FMODstatusLabel.Text = "Stopped";
                    FMODpauseButton.Text = "Pause";
                }
            }
        }

        private void FMODloopButton_CheckedChanged(object sender, EventArgs e)
        {
            FMOD.RESULT result;

            loopMode = FMODloopButton.Checked ? FMOD.MODE.LOOP_NORMAL : FMOD.MODE.LOOP_OFF;

            if (sound != null)
            {
                result = sound.setMode(loopMode);
                if (ERRCHECK(result)) { return; }
            }

            if (channel != null)
            {
                result = channel.isPlaying(out var playing);
                if ((result != FMOD.RESULT.OK) && (result != FMOD.RESULT.ERR_INVALID_HANDLE))
                {
                    if (ERRCHECK(result)) { return; }
                }

                result = channel.getPaused(out var paused);
                if ((result != FMOD.RESULT.OK) && (result != FMOD.RESULT.ERR_INVALID_HANDLE))
                {
                    if (ERRCHECK(result)) { return; }
                }

                if (playing || paused)
                {
                    result = channel.setMode(loopMode);
                    if (ERRCHECK(result)) { return; }
                }
            }
        }

        private void FMODvolumeBar_ValueChanged(object sender, EventArgs e)
        {
            FMODVolume = Convert.ToSingle(FMODvolumeBar.Value) / 10;

            var result = masterSoundGroup.setVolume(FMODVolume);
            if (ERRCHECK(result)) { return; }
        }

        private void FMODprogressBar_Scroll(object sender, EventArgs e)
        {
            if (channel != null)
            {
                uint newms = FMODlenms / 1000 * (uint)FMODprogressBar.Value;
                FMODtimerLabel.Text = $"{newms / 1000 / 60}:{newms / 1000 % 60}.{newms / 10 % 100}/{FMODlenms / 1000 / 60}:{FMODlenms / 1000 % 60}.{FMODlenms / 10 % 100}";
            }
        }

        private void FMODprogressBar_MouseDown(object sender, MouseEventArgs e)
        {
            timer.Stop();
        }

        private void FMODprogressBar_MouseUp(object sender, MouseEventArgs e)
        {
            if (channel != null)
            {
                uint newms = FMODlenms / 1000 * (uint)FMODprogressBar.Value;

                var result = channel.setPosition(newms, FMOD.TIMEUNIT.MS);
                if ((result != FMOD.RESULT.OK) && (result != FMOD.RESULT.ERR_INVALID_HANDLE))
                {
                    if (ERRCHECK(result)) { return; }
                }


                result = channel.isPlaying(out var playing);
                if ((result != FMOD.RESULT.OK) && (result != FMOD.RESULT.ERR_INVALID_HANDLE))
                {
                    if (ERRCHECK(result)) { return; }
                }

                if (playing) { timer.Start(); }
            }
        }

        private void timer_Tick(object sender, EventArgs e)
        {
            uint ms = 0;
            bool playing = false;
            bool paused = false;

            if (channel != null)
            {
                var result = channel.getPosition(out ms, FMOD.TIMEUNIT.MS);
                if ((result != FMOD.RESULT.OK) && (result != FMOD.RESULT.ERR_INVALID_HANDLE))
                {
                    ERRCHECK(result);
                }

                result = channel.isPlaying(out playing);
                if ((result != FMOD.RESULT.OK) && (result != FMOD.RESULT.ERR_INVALID_HANDLE))
                {
                    ERRCHECK(result);
                }

                result = channel.getPaused(out paused);
                if ((result != FMOD.RESULT.OK) && (result != FMOD.RESULT.ERR_INVALID_HANDLE))
                {
                    ERRCHECK(result);
                }
            }

            FMODtimerLabel.Text = $"{ms / 1000 / 60}:{ms / 1000 % 60}.{ms / 10 % 100} / {FMODlenms / 1000 / 60}:{FMODlenms / 1000 % 60}.{FMODlenms / 10 % 100}";
            FMODprogressBar.Value = (int)(ms * 1000 / FMODlenms);
            FMODstatusLabel.Text = paused ? "Paused " : playing ? "Playing" : "Stopped";

            if (system != null && channel != null)
            {
                system.update();
            }
        }

        private bool ERRCHECK(FMOD.RESULT result)
        {
            if (result != FMOD.RESULT.OK)
            {
                FMODreset();
                StatusStripUpdate($"FMOD error! {result} - {FMOD.Error.String(result)}");
                return true;
            }
            return false;
        }
        #endregion

        #region GLControl
        private void InitOpenTK()
        {
            ChangeGLSize(glControl1.Size);
            GL.ClearColor(System.Drawing.Color.CadetBlue);
            pgmID = GL.CreateProgram();
            LoadShader("vs", ShaderType.VertexShader, pgmID, out int vsID);
            LoadShader("fs", ShaderType.FragmentShader, pgmID, out int fsID);
            GL.LinkProgram(pgmID);

            pgmColorID = GL.CreateProgram();
            LoadShader("vs", ShaderType.VertexShader, pgmColorID, out vsID);
            LoadShader("fsColor", ShaderType.FragmentShader, pgmColorID, out fsID);
            GL.LinkProgram(pgmColorID);

            pgmBlackID = GL.CreateProgram();
            LoadShader("vs", ShaderType.VertexShader, pgmBlackID, out vsID);
            LoadShader("fsBlack", ShaderType.FragmentShader, pgmBlackID, out fsID);
            GL.LinkProgram(pgmBlackID);

            attributeVertexPosition = GL.GetAttribLocation(pgmID, "vertexPosition");
            attributeNormalDirection = GL.GetAttribLocation(pgmID, "normalDirection");
            attributeVertexColor = GL.GetAttribLocation(pgmColorID, "vertexColor");
            uniformModelMatrix = GL.GetUniformLocation(pgmID, "modelMatrix");
            uniformViewMatrix = GL.GetUniformLocation(pgmID, "viewMatrix");
            uniformProjMatrix = GL.GetUniformLocation(pgmID, "projMatrix");
        }

        private static void LoadShader(string filename, ShaderType type, int program, out int address)
        {
            address = GL.CreateShader(type);
            var str = (string)Properties.Resources.ResourceManager.GetObject(filename);
            GL.ShaderSource(address, str);
            GL.CompileShader(address);
            GL.AttachShader(program, address);
            GL.DeleteShader(address);
        }

        private static void CreateVBO(out int vboAddress, Vector3[] data, int address)
        {
            GL.GenBuffers(1, out vboAddress);
            GL.BindBuffer(BufferTarget.ArrayBuffer, vboAddress);
            GL.BufferData(BufferTarget.ArrayBuffer,
                                    (IntPtr)(data.Length * Vector3.SizeInBytes),
                                    data,
                                    BufferUsageHint.StaticDraw);
            GL.VertexAttribPointer(address, 3, VertexAttribPointerType.Float, false, 0, 0);
            GL.EnableVertexAttribArray(address);
        }

        private static void CreateVBO(out int vboAddress, Vector4[] data, int address)
        {
            GL.GenBuffers(1, out vboAddress);
            GL.BindBuffer(BufferTarget.ArrayBuffer, vboAddress);
            GL.BufferData(BufferTarget.ArrayBuffer,
                                    (IntPtr)(data.Length * Vector4.SizeInBytes),
                                    data,
                                    BufferUsageHint.StaticDraw);
            GL.VertexAttribPointer(address, 4, VertexAttribPointerType.Float, false, 0, 0);
            GL.EnableVertexAttribArray(address);
        }

        private static void CreateVBO(out int vboAddress, Matrix4 data, int address)
        {
            GL.GenBuffers(1, out vboAddress);
            GL.UniformMatrix4(address, false, ref data);
        }

        private static void CreateEBO(out int address, int[] data)
        {
            GL.GenBuffers(1, out address);
            GL.BindBuffer(BufferTarget.ElementArrayBuffer, address);
            GL.BufferData(BufferTarget.ElementArrayBuffer,
                            (IntPtr)(data.Length * sizeof(int)),
                            data,
                            BufferUsageHint.StaticDraw);
        }

        private void CreateVAO()
        {
            GL.DeleteVertexArray(vao);
            GL.GenVertexArrays(1, out vao);
            GL.BindVertexArray(vao);
            CreateVBO(out var vboPositions, vertexData, attributeVertexPosition);
            if (normalMode == 0)
            {
                CreateVBO(out var vboNormals, normal2Data, attributeNormalDirection);
            }
            else
            {
                if (normalData != null)
                    CreateVBO(out var vboNormals, normalData, attributeNormalDirection);
            }
            CreateVBO(out var vboColors, colorData, attributeVertexColor);
            CreateVBO(out var vboModelMatrix, modelMatrixData, uniformModelMatrix);
            CreateVBO(out var vboViewMatrix, viewMatrixData, uniformViewMatrix);
            CreateVBO(out var vboProjMatrix, projMatrixData, uniformProjMatrix);
            CreateEBO(out var eboElements, indiceData);
            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
            GL.BindVertexArray(0);
        }

        private void ChangeGLSize(Size size)
        {
            GL.Viewport(0, 0, size.Width, size.Height);

            if (size.Width <= size.Height)
            {
                float k = 1.0f * size.Width / size.Height;
                projMatrixData = Matrix4.CreateScale(1, k, 1);
            }
            else
            {
                float k = 1.0f * size.Height / size.Width;
                projMatrixData = Matrix4.CreateScale(k, 1, 1);
            }
        }

        private void glControl1_Load(object sender, EventArgs e)
        {
            InitOpenTK();
            glControlLoaded = true;
        }

        private void glControl1_Paint(object sender, PaintEventArgs e)
        {
            glControl1.MakeCurrent();
            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
            GL.Enable(EnableCap.DepthTest);
            GL.DepthFunc(DepthFunction.Lequal);
            GL.BindVertexArray(vao);
            if (wireFrameMode == 0 || wireFrameMode == 2)
            {
                GL.UseProgram(shadeMode == 0 ? pgmID : pgmColorID);
                GL.UniformMatrix4(uniformModelMatrix, false, ref modelMatrixData);
                GL.UniformMatrix4(uniformViewMatrix, false, ref viewMatrixData);
                GL.UniformMatrix4(uniformProjMatrix, false, ref projMatrixData);
                GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Fill);
                GL.DrawElements(BeginMode.Triangles, indiceData.Length, DrawElementsType.UnsignedInt, 0);
            }
            //Wireframe
            if (wireFrameMode == 1 || wireFrameMode == 2)
            {
                GL.Enable(EnableCap.PolygonOffsetLine);
                GL.PolygonOffset(-1, -1);
                GL.UseProgram(pgmBlackID);
                GL.UniformMatrix4(uniformModelMatrix, false, ref modelMatrixData);
                GL.UniformMatrix4(uniformViewMatrix, false, ref viewMatrixData);
                GL.UniformMatrix4(uniformProjMatrix, false, ref projMatrixData);
                GL.PolygonMode(MaterialFace.FrontAndBack, PolygonMode.Line);
                GL.DrawElements(BeginMode.Triangles, indiceData.Length, DrawElementsType.UnsignedInt, 0);
                GL.Disable(EnableCap.PolygonOffsetLine);
            }
            GL.BindVertexArray(0);
            GL.Flush();
            glControl1.SwapBuffers();
        }

        private void tabControl2_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (tabControl2.SelectedIndex == 1 && lastSelectedItem != null)
            {
                dumpTextBox.Text = DumpAsset(lastSelectedItem.Asset);
            }
        }

        private void toolStripMenuItem15_Click(object sender, EventArgs e)
        {
            logger.ShowErrorMessage = toolStripMenuItem15.Checked;
        }

        private void glControl1_MouseWheel(object sender, MouseEventArgs e)
        {
            if (glControl1.Visible)
            {
                viewMatrixData *= Matrix4.CreateScale(1 + e.Delta / 1000f);
                glControl1.Invalidate();
            }
        }

        private void glControl1_MouseDown(object sender, MouseEventArgs e)
        {
            mdx = e.X;
            mdy = e.Y;
            if (e.Button == MouseButtons.Left)
            {
                lmdown = true;
            }
            if (e.Button == MouseButtons.Right)
            {
                rmdown = true;
            }
        }

        private void glControl1_MouseMove(object sender, MouseEventArgs e)
        {
            if (lmdown || rmdown)
            {
                float dx = mdx - e.X;
                float dy = mdy - e.Y;
                mdx = e.X;
                mdy = e.Y;
                if (lmdown)
                {
                    dx *= 0.01f;
                    dy *= 0.01f;
                    viewMatrixData *= Matrix4.CreateRotationX(dy);
                    viewMatrixData *= Matrix4.CreateRotationY(dx);
                }
                if (rmdown)
                {
                    dx *= 0.003f;
                    dy *= 0.003f;
                    viewMatrixData *= Matrix4.CreateTranslation(-dx, dy, 0);
                }
                glControl1.Invalidate();
            }
        }

        private void glControl1_MouseUp(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                lmdown = false;
            }
            if (e.Button == MouseButtons.Right)
            {
                rmdown = false;
            }
        }
        #endregion
    }
}

```

`AssetStudioGUI/AssetStudioGUIForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="menuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>312, 17</value>
  </metadata>
  <data name="fontPreviewBox.Text" xml:space="preserve">
    <value>abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWYZ
1234567890.:,;'\"(!?)+-*/=

The quick brown fox jumps over the lazy dog. 1234567890

The quick brown fox jumps over the lazy dog. 1234567890

The quick brown fox jumps over the lazy dog. 1234567890

The quick brown fox jumps over the lazy dog. 1234567890

The quick brown fox jumps over the lazy dog. 1234567890

The quick brown fox jumps over the lazy dog. 1234567890

The quick brown fox jumps over the lazy dog. 1234567890</value>
  </data>
  <metadata name="statusStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>432, 17</value>
  </metadata>
  <metadata name="timer.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>553, 17</value>
  </metadata>
  <metadata name="openFileDialog1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>636, 17</value>
  </metadata>
  <metadata name="contextMenuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>147, 17</value>
  </metadata>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>67</value>
  </metadata>
</root>
```

`AssetStudioGUI/Components/AssetItem.cs`:

```cs
using System.Windows.Forms;
using AssetStudio;

namespace AssetStudioGUI
{
    internal class AssetItem : ListViewItem
    {
        public Object Asset;
        public SerializedFile SourceFile;
        public string Container = string.Empty;
        public string TypeString;
        public long m_PathID;
        public long FullSize;
        public ClassIDType Type;
        public string InfoText;
        public string UniqueID;
        public GameObjectTreeNode TreeNode;

        public AssetItem(Object asset)
        {
            Asset = asset;
            SourceFile = asset.assetsFile;
            Type = asset.type;
            TypeString = Type.ToString();
            m_PathID = asset.m_PathID;
            FullSize = asset.byteSize;
        }

        public void SetSubItems()
        {
            SubItems.AddRange(new[]
            {
                Container, //Container
                TypeString, //Type
                m_PathID.ToString(), //PathID
                FullSize.ToString(), //Size
            });
        }
    }
}

```

`AssetStudioGUI/Components/GOHierarchy.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace AssetStudioGUI
{
    internal class GOHierarchy : TreeView
    {
        protected override void WndProc(ref Message m)
        {
            // Filter WM_LBUTTONDBLCLK
            if (m.Msg != 0x203) base.WndProc(ref m);
        }
    }
}

```

`AssetStudioGUI/Components/GameObjectTreeNode.cs`:

```cs
using System.Windows.Forms;
using AssetStudio;

namespace AssetStudioGUI
{
    internal class GameObjectTreeNode : TreeNode
    {
        public GameObject gameObject;

        public GameObjectTreeNode(GameObject gameObject)
        {
            this.gameObject = gameObject;
            Text = gameObject.m_Name;
        }
    }
}

```

`AssetStudioGUI/Components/OpenFolderDialog.cs`:

```cs
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace AssetStudioGUI
{
    internal class OpenFolderDialog
    {
        public string InitialFolder { get; set; }
        public string DefaultFolder { get; set; }
        public string Folder { get; private set; }
        public string Title { get; set; }

        internal DialogResult ShowDialog(IWin32Window owner = null)
        {
//#if NETFRAMEWORK
            if (Environment.OSVersion.Version.Major >= 6)
            {
                return ShowVistaDialog(owner);
            }
//#endif
            return ShowFolderBrowserDialog(owner);
        }

        private DialogResult ShowVistaDialog(IWin32Window owner)
        {
            var frm = (NativeMethods.IFileDialog)(new NativeMethods.FileOpenDialogRCW());
            frm.GetOptions(out var options);
            options |= NativeMethods.FOS_PICKFOLDERS | NativeMethods.FOS_FORCEFILESYSTEM | NativeMethods.FOS_NOVALIDATE | NativeMethods.FOS_NOTESTFILECREATE | NativeMethods.FOS_DONTADDTORECENT;
            frm.SetOptions(options);
            if (!string.IsNullOrEmpty(Title))
            {
                frm.SetTitle(Title);
            }
            if (!string.IsNullOrEmpty(InitialFolder))
            {
                var riid = new Guid("43826D1E-E718-42EE-BC55-A1E261C37BFE"); //IShellItem  
                if (NativeMethods.SHCreateItemFromParsingName(InitialFolder, IntPtr.Zero, ref riid, out var directoryShellItem) == NativeMethods.S_OK)
                {
                    frm.SetFolder(directoryShellItem);
                }
            }
            if (!string.IsNullOrEmpty(DefaultFolder))
            {
                var riid = new Guid("43826D1E-E718-42EE-BC55-A1E261C37BFE"); //IShellItem  
                if (NativeMethods.SHCreateItemFromParsingName(DefaultFolder, IntPtr.Zero, ref riid, out var directoryShellItem) == NativeMethods.S_OK)
                {
                    frm.SetDefaultFolder(directoryShellItem);
                }
            }

            if ((owner == null ? frm.Show() : frm.Show(owner.Handle)) == NativeMethods.S_OK)
            {
                if (frm.GetResult(out var shellItem) == NativeMethods.S_OK)
                {
                    if (shellItem.GetDisplayName(NativeMethods.SIGDN_FILESYSPATH, out var pszString) == NativeMethods.S_OK)
                    {
                        if (pszString != IntPtr.Zero)
                        {
                            try
                            {
                                Folder = Marshal.PtrToStringAuto(pszString);
                                return DialogResult.OK;
                            }
                            finally
                            {
                                Marshal.FreeCoTaskMem(pszString);
                            }
                        }
                    }
                }
            }
            return DialogResult.Cancel;
        }

        private DialogResult ShowFolderBrowserDialog(IWin32Window owner)
        {
            using (var frm = new FolderBrowserDialog())
            {
                if (InitialFolder != null)
                {
                    frm.SelectedPath = InitialFolder;
                }
#if !NETFRAMEWORK
                if (Title != null)
                {
                    frm.Description = Title;
                    frm.UseDescriptionForTitle = true;
                }
#endif
                var result = owner == null ? frm.ShowDialog() : frm.ShowDialog(owner);
                if (result == DialogResult.OK)
                {
                    Folder = frm.SelectedPath;
                    return result;
                }
                return result;
            }
        }
    }

    internal static class NativeMethods
    {

        #region Constants  

        public const uint FOS_PICKFOLDERS = 0x00000020;
        public const uint FOS_FORCEFILESYSTEM = 0x00000040;
        public const uint FOS_NOVALIDATE = 0x00000100;
        public const uint FOS_NOTESTFILECREATE = 0x00010000;
        public const uint FOS_DONTADDTORECENT = 0x02000000;

        public const uint S_OK = 0x0000;

        public const uint SIGDN_FILESYSPATH = 0x80058000;

        #endregion


        #region COM  

        [ComImport, ClassInterface(ClassInterfaceType.None), TypeLibType(TypeLibTypeFlags.FCanCreate), Guid("DC1C5A9C-E88A-4DDE-A5A1-60F82A20AEF7")]
        internal class FileOpenDialogRCW { }


        [ComImport(), Guid("42F85136-DB7E-439C-85F1-E4075D135FC8"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IFileDialog
        {
            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            [PreserveSig()]
            uint Show([In, Optional] IntPtr hwndOwner); //IModalWindow   


            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint SetFileTypes([In] uint cFileTypes, [In, MarshalAs(UnmanagedType.LPArray)] IntPtr rgFilterSpec);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint SetFileTypeIndex([In] uint iFileType);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint GetFileTypeIndex(out uint piFileType);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint Advise([In, MarshalAs(UnmanagedType.Interface)] IntPtr pfde, out uint pdwCookie);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint Unadvise([In] uint dwCookie);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint SetOptions([In] uint fos);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint GetOptions(out uint fos);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            void SetDefaultFolder([In, MarshalAs(UnmanagedType.Interface)] IShellItem psi);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint SetFolder([In, MarshalAs(UnmanagedType.Interface)] IShellItem psi);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint GetFolder([MarshalAs(UnmanagedType.Interface)] out IShellItem ppsi);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint GetCurrentSelection([MarshalAs(UnmanagedType.Interface)] out IShellItem ppsi);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint SetFileName([In, MarshalAs(UnmanagedType.LPWStr)] string pszName);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint GetFileName([MarshalAs(UnmanagedType.LPWStr)] out string pszName);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint SetTitle([In, MarshalAs(UnmanagedType.LPWStr)] string pszTitle);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint SetOkButtonLabel([In, MarshalAs(UnmanagedType.LPWStr)] string pszText);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint SetFileNameLabel([In, MarshalAs(UnmanagedType.LPWStr)] string pszLabel);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint GetResult([MarshalAs(UnmanagedType.Interface)] out IShellItem ppsi);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint AddPlace([In, MarshalAs(UnmanagedType.Interface)] IShellItem psi, uint fdap);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint SetDefaultExtension([In, MarshalAs(UnmanagedType.LPWStr)] string pszDefaultExtension);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint Close([MarshalAs(UnmanagedType.Error)] uint hr);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint SetClientGuid([In] ref Guid guid);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint ClearClientData();

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint SetFilter([MarshalAs(UnmanagedType.Interface)] IntPtr pFilter);
        }


        [ComImport, Guid("43826D1E-E718-42EE-BC55-A1E261C37BFE"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
        internal interface IShellItem
        {
            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint BindToHandler([In] IntPtr pbc, [In] ref Guid rbhid, [In] ref Guid riid, [Out, MarshalAs(UnmanagedType.Interface)] out IntPtr ppvOut);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint GetParent([MarshalAs(UnmanagedType.Interface)] out IShellItem ppsi);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint GetDisplayName([In] uint sigdnName, out IntPtr ppszName);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint GetAttributes([In] uint sfgaoMask, out uint psfgaoAttribs);

            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
            uint Compare([In, MarshalAs(UnmanagedType.Interface)] IShellItem psi, [In] uint hint, out int piOrder);
        }

        #endregion


        [DllImport("shell32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        internal static extern int SHCreateItemFromParsingName([MarshalAs(UnmanagedType.LPWStr)] string pszPath, IntPtr pbc, ref Guid riid, [MarshalAs(UnmanagedType.Interface)] out IShellItem ppv);
    }
}
```

`AssetStudioGUI/Components/TypeTreeItem.cs`:

```cs
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using AssetStudio;

namespace AssetStudioGUI
{
    internal class TypeTreeItem : ListViewItem
    {
        private TypeTree m_Type;

        public TypeTreeItem(int typeID, TypeTree m_Type)
        {
            this.m_Type = m_Type;
            Text = m_Type.m_Nodes[0].m_Type + " " + m_Type.m_Nodes[0].m_Name;
            SubItems.Add(typeID.ToString());
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            foreach (var i in m_Type.m_Nodes)
            {
                sb.AppendFormat("{0}{1} {2} {3} {4}\r\n", new string('\t', i.m_Level), i.m_Type, i.m_Name, i.m_ByteSize, (i.m_MetaFlag & 0x4000) != 0);
            }
            return sb.ToString();
        }
    }
}

```

`AssetStudioGUI/DirectBitmap.cs`:

```cs
using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;

namespace AssetStudioGUI
{
    public sealed class DirectBitmap : IDisposable
    {
        public DirectBitmap(byte[] buff, int width, int height)
        {
            Width = width;
            Height = height;
            Bits = buff;
            m_handle = GCHandle.Alloc(Bits, GCHandleType.Pinned);
            m_bitmap = new Bitmap(Width, Height, Stride, PixelFormat.Format32bppArgb, m_handle.AddrOfPinnedObject());
        }

        private void Dispose(bool disposing)
        {
            if (disposing)
            {
                m_bitmap.Dispose();
                m_handle.Free();
            }
            m_bitmap = null;
        }

        public void Dispose()
        {
            Dispose(true);
        }

        public int Height { get; }
        public int Width { get; }
        public int Stride => Width * 4;
        public byte[] Bits { get; }
        public Bitmap Bitmap => m_bitmap;

        private Bitmap m_bitmap;
        private readonly GCHandle m_handle;
    }
}

```

`AssetStudioGUI/ExportOptions.Designer.cs`:

```cs
namespace AssetStudioGUI
{
    partial class ExportOptions
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.OKbutton = new System.Windows.Forms.Button();
            this.Cancel = new System.Windows.Forms.Button();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.openAfterExport = new System.Windows.Forms.CheckBox();
            this.restoreExtensionName = new System.Windows.Forms.CheckBox();
            this.assetGroupOptions = new System.Windows.Forms.ComboBox();
            this.label6 = new System.Windows.Forms.Label();
            this.convertAudio = new System.Windows.Forms.CheckBox();
            this.panel1 = new System.Windows.Forms.Panel();
            this.totga = new System.Windows.Forms.RadioButton();
            this.tojpg = new System.Windows.Forms.RadioButton();
            this.topng = new System.Windows.Forms.RadioButton();
            this.tobmp = new System.Windows.Forms.RadioButton();
            this.converttexture = new System.Windows.Forms.CheckBox();
            this.groupBox2 = new System.Windows.Forms.GroupBox();
            this.exportAllUvsAsDiffuseMaps = new System.Windows.Forms.CheckBox();
            this.exportBlendShape = new System.Windows.Forms.CheckBox();
            this.exportAnimations = new System.Windows.Forms.CheckBox();
            this.scaleFactor = new System.Windows.Forms.NumericUpDown();
            this.label5 = new System.Windows.Forms.Label();
            this.fbxFormat = new System.Windows.Forms.ComboBox();
            this.label4 = new System.Windows.Forms.Label();
            this.fbxVersion = new System.Windows.Forms.ComboBox();
            this.label3 = new System.Windows.Forms.Label();
            this.boneSize = new System.Windows.Forms.NumericUpDown();
            this.label2 = new System.Windows.Forms.Label();
            this.exportSkins = new System.Windows.Forms.CheckBox();
            this.label1 = new System.Windows.Forms.Label();
            this.filterPrecision = new System.Windows.Forms.NumericUpDown();
            this.castToBone = new System.Windows.Forms.CheckBox();
            this.exportAllNodes = new System.Windows.Forms.CheckBox();
            this.eulerFilter = new System.Windows.Forms.CheckBox();
            this.exportUvsTooltip = new System.Windows.Forms.ToolTip(this.components);
            this.groupBox1.SuspendLayout();
            this.panel1.SuspendLayout();
            this.groupBox2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.scaleFactor)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.boneSize)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.filterPrecision)).BeginInit();
            this.SuspendLayout();
            // 
            // OKbutton
            // 
            this.OKbutton.Location = new System.Drawing.Point(318, 351);
            this.OKbutton.Name = "OKbutton";
            this.OKbutton.Size = new System.Drawing.Size(75, 21);
            this.OKbutton.TabIndex = 6;
            this.OKbutton.Text = "OK";
            this.OKbutton.UseVisualStyleBackColor = true;
            this.OKbutton.Click += new System.EventHandler(this.OKbutton_Click);
            // 
            // Cancel
            // 
            this.Cancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.Cancel.Location = new System.Drawing.Point(399, 351);
            this.Cancel.Name = "Cancel";
            this.Cancel.Size = new System.Drawing.Size(75, 21);
            this.Cancel.TabIndex = 7;
            this.Cancel.Text = "Cancel";
            this.Cancel.UseVisualStyleBackColor = true;
            this.Cancel.Click += new System.EventHandler(this.Cancel_Click);
            // 
            // groupBox1
            // 
            this.groupBox1.AutoSize = true;
            this.groupBox1.Controls.Add(this.openAfterExport);
            this.groupBox1.Controls.Add(this.restoreExtensionName);
            this.groupBox1.Controls.Add(this.assetGroupOptions);
            this.groupBox1.Controls.Add(this.label6);
            this.groupBox1.Controls.Add(this.convertAudio);
            this.groupBox1.Controls.Add(this.panel1);
            this.groupBox1.Controls.Add(this.converttexture);
            this.groupBox1.Location = new System.Drawing.Point(12, 12);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(232, 334);
            this.groupBox1.TabIndex = 9;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Export";
            // 
            // openAfterExport
            // 
            this.openAfterExport.AutoSize = true;
            this.openAfterExport.Checked = true;
            this.openAfterExport.CheckState = System.Windows.Forms.CheckState.Checked;
            this.openAfterExport.Location = new System.Drawing.Point(6, 160);
            this.openAfterExport.Name = "openAfterExport";
            this.openAfterExport.Size = new System.Drawing.Size(168, 16);
            this.openAfterExport.TabIndex = 10;
            this.openAfterExport.Text = "Open folder after export";
            this.openAfterExport.UseVisualStyleBackColor = true;
            // 
            // restoreExtensionName
            // 
            this.restoreExtensionName.AutoSize = true;
            this.restoreExtensionName.Checked = true;
            this.restoreExtensionName.CheckState = System.Windows.Forms.CheckState.Checked;
            this.restoreExtensionName.Location = new System.Drawing.Point(6, 58);
            this.restoreExtensionName.Name = "restoreExtensionName";
            this.restoreExtensionName.Size = new System.Drawing.Size(216, 16);
            this.restoreExtensionName.TabIndex = 9;
            this.restoreExtensionName.Text = "Restore TextAsset extension name";
            this.restoreExtensionName.UseVisualStyleBackColor = true;
            // 
            // assetGroupOptions
            // 
            this.assetGroupOptions.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.assetGroupOptions.FormattingEnabled = true;
            this.assetGroupOptions.Items.AddRange(new object[] {
            "type name",
            "container path",
            "source file name",
            "do not group"});
            this.assetGroupOptions.Location = new System.Drawing.Point(6, 32);
            this.assetGroupOptions.Name = "assetGroupOptions";
            this.assetGroupOptions.Size = new System.Drawing.Size(149, 20);
            this.assetGroupOptions.TabIndex = 8;
            // 
            // label6
            // 
            this.label6.AutoSize = true;
            this.label6.Location = new System.Drawing.Point(6, 17);
            this.label6.Name = "label6";
            this.label6.Size = new System.Drawing.Size(149, 12);
            this.label6.TabIndex = 7;
            this.label6.Text = "Group exported assets by";
            // 
            // convertAudio
            // 
            this.convertAudio.AutoSize = true;
            this.convertAudio.Checked = true;
            this.convertAudio.CheckState = System.Windows.Forms.CheckState.Checked;
            this.convertAudio.Location = new System.Drawing.Point(6, 138);
            this.convertAudio.Name = "convertAudio";
            this.convertAudio.Size = new System.Drawing.Size(198, 16);
            this.convertAudio.TabIndex = 6;
            this.convertAudio.Text = "Convert AudioClip to WAV(PCM)";
            this.convertAudio.UseVisualStyleBackColor = true;
            // 
            // panel1
            // 
            this.panel1.Controls.Add(this.totga);
            this.panel1.Controls.Add(this.tojpg);
            this.panel1.Controls.Add(this.topng);
            this.panel1.Controls.Add(this.tobmp);
            this.panel1.Location = new System.Drawing.Point(20, 102);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(202, 30);
            this.panel1.TabIndex = 5;
            // 
            // totga
            // 
            this.totga.AutoSize = true;
            this.totga.Location = new System.Drawing.Point(150, 6);
            this.totga.Name = "totga";
            this.totga.Size = new System.Drawing.Size(41, 16);
            this.totga.TabIndex = 2;
            this.totga.Text = "Tga";
            this.totga.UseVisualStyleBackColor = true;
            // 
            // tojpg
            // 
            this.tojpg.AutoSize = true;
            this.tojpg.Location = new System.Drawing.Point(97, 6);
            this.tojpg.Name = "tojpg";
            this.tojpg.Size = new System.Drawing.Size(47, 16);
            this.tojpg.TabIndex = 4;
            this.tojpg.Text = "Jpeg";
            this.tojpg.UseVisualStyleBackColor = true;
            // 
            // topng
            // 
            this.topng.AutoSize = true;
            this.topng.Checked = true;
            this.topng.Location = new System.Drawing.Point(50, 6);
            this.topng.Name = "topng";
            this.topng.Size = new System.Drawing.Size(41, 16);
            this.topng.TabIndex = 3;
            this.topng.TabStop = true;
            this.topng.Text = "Png";
            this.topng.UseVisualStyleBackColor = true;
            // 
            // tobmp
            // 
            this.tobmp.AutoSize = true;
            this.tobmp.Location = new System.Drawing.Point(3, 6);
            this.tobmp.Name = "tobmp";
            this.tobmp.Size = new System.Drawing.Size(41, 16);
            this.tobmp.TabIndex = 2;
            this.tobmp.Text = "Bmp";
            this.tobmp.UseVisualStyleBackColor = true;
            // 
            // converttexture
            // 
            this.converttexture.AutoSize = true;
            this.converttexture.Checked = true;
            this.converttexture.CheckState = System.Windows.Forms.CheckState.Checked;
            this.converttexture.Location = new System.Drawing.Point(6, 80);
            this.converttexture.Name = "converttexture";
            this.converttexture.Size = new System.Drawing.Size(126, 16);
            this.converttexture.TabIndex = 1;
            this.converttexture.Text = "Convert Texture2D";
            this.converttexture.UseVisualStyleBackColor = true;
            // 
            // groupBox2
            // 
            this.groupBox2.AutoSize = true;
            this.groupBox2.Controls.Add(this.exportAllUvsAsDiffuseMaps);
            this.groupBox2.Controls.Add(this.exportBlendShape);
            this.groupBox2.Controls.Add(this.exportAnimations);
            this.groupBox2.Controls.Add(this.scaleFactor);
            this.groupBox2.Controls.Add(this.label5);
            this.groupBox2.Controls.Add(this.fbxFormat);
            this.groupBox2.Controls.Add(this.label4);
            this.groupBox2.Controls.Add(this.fbxVersion);
            this.groupBox2.Controls.Add(this.label3);
            this.groupBox2.Controls.Add(this.boneSize);
            this.groupBox2.Controls.Add(this.label2);
            this.groupBox2.Controls.Add(this.exportSkins);
            this.groupBox2.Controls.Add(this.label1);
            this.groupBox2.Controls.Add(this.filterPrecision);
            this.groupBox2.Controls.Add(this.castToBone);
            this.groupBox2.Controls.Add(this.exportAllNodes);
            this.groupBox2.Controls.Add(this.eulerFilter);
            this.groupBox2.Location = new System.Drawing.Point(250, 12);
            this.groupBox2.Name = "groupBox2";
            this.groupBox2.Size = new System.Drawing.Size(224, 334);
            this.groupBox2.TabIndex = 11;
            this.groupBox2.TabStop = false;
            this.groupBox2.Text = "Fbx";
            // 
            // exportAllUvsAsDiffuseMaps
            // 
            this.exportAllUvsAsDiffuseMaps.AccessibleDescription = "";
            this.exportAllUvsAsDiffuseMaps.AutoSize = true;
            this.exportAllUvsAsDiffuseMaps.Location = new System.Drawing.Point(6, 171);
            this.exportAllUvsAsDiffuseMaps.Name = "exportAllUvsAsDiffuseMaps";
            this.exportAllUvsAsDiffuseMaps.Size = new System.Drawing.Size(204, 16);
            this.exportAllUvsAsDiffuseMaps.TabIndex = 23;
            this.exportAllUvsAsDiffuseMaps.Text = "Export all UVs as diffuse maps";
            this.exportUvsTooltip.SetToolTip(this.exportAllUvsAsDiffuseMaps, "Unchecked: UV1 exported as normal map. Check this if your export is missing a UV " +
        "map.");
            this.exportAllUvsAsDiffuseMaps.UseVisualStyleBackColor = true;
            // 
            // exportBlendShape
            // 
            this.exportBlendShape.AutoSize = true;
            this.exportBlendShape.Checked = true;
            this.exportBlendShape.CheckState = System.Windows.Forms.CheckState.Checked;
            this.exportBlendShape.Location = new System.Drawing.Point(6, 127);
            this.exportBlendShape.Name = "exportBlendShape";
            this.exportBlendShape.Size = new System.Drawing.Size(126, 16);
            this.exportBlendShape.TabIndex = 22;
            this.exportBlendShape.Text = "Export blendshape";
            this.exportBlendShape.UseVisualStyleBackColor = true;
            // 
            // exportAnimations
            // 
            this.exportAnimations.AutoSize = true;
            this.exportAnimations.Checked = true;
            this.exportAnimations.CheckState = System.Windows.Forms.CheckState.Checked;
            this.exportAnimations.Location = new System.Drawing.Point(6, 105);
            this.exportAnimations.Name = "exportAnimations";
            this.exportAnimations.Size = new System.Drawing.Size(126, 16);
            this.exportAnimations.TabIndex = 21;
            this.exportAnimations.Text = "Export animations";
            this.exportAnimations.UseVisualStyleBackColor = true;
            // 
            // scaleFactor
            // 
            this.scaleFactor.DecimalPlaces = 2;
            this.scaleFactor.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.scaleFactor.Location = new System.Drawing.Point(83, 224);
            this.scaleFactor.Name = "scaleFactor";
            this.scaleFactor.Size = new System.Drawing.Size(60, 21);
            this.scaleFactor.TabIndex = 20;
            this.scaleFactor.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
            this.scaleFactor.Value = new decimal(new int[] {
            1,
            0,
            0,
            0});
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(6, 226);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(71, 12);
            this.label5.TabIndex = 19;
            this.label5.Text = "ScaleFactor";
            // 
            // fbxFormat
            // 
            this.fbxFormat.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.fbxFormat.FormattingEnabled = true;
            this.fbxFormat.Items.AddRange(new object[] {
            "Binary",
            "Ascii"});
            this.fbxFormat.Location = new System.Drawing.Point(77, 254);
            this.fbxFormat.Name = "fbxFormat";
            this.fbxFormat.Size = new System.Drawing.Size(61, 20);
            this.fbxFormat.TabIndex = 18;
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(6, 258);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(59, 12);
            this.label4.TabIndex = 17;
            this.label4.Text = "FBXFormat";
            // 
            // fbxVersion
            // 
            this.fbxVersion.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.fbxVersion.FormattingEnabled = true;
            this.fbxVersion.Items.AddRange(new object[] {
            "6.1",
            "7.1",
            "7.2",
            "7.3",
            "7.4",
            "7.5"});
            this.fbxVersion.Location = new System.Drawing.Point(77, 284);
            this.fbxVersion.Name = "fbxVersion";
            this.fbxVersion.Size = new System.Drawing.Size(47, 20);
            this.fbxVersion.TabIndex = 16;
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(6, 287);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(65, 12);
            this.label3.TabIndex = 15;
            this.label3.Text = "FBXVersion";
            // 
            // boneSize
            // 
            this.boneSize.Location = new System.Drawing.Point(65, 197);
            this.boneSize.Name = "boneSize";
            this.boneSize.Size = new System.Drawing.Size(46, 21);
            this.boneSize.TabIndex = 11;
            this.boneSize.Value = new decimal(new int[] {
            10,
            0,
            0,
            0});
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(6, 199);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(53, 12);
            this.label2.TabIndex = 10;
            this.label2.Text = "BoneSize";
            // 
            // exportSkins
            // 
            this.exportSkins.AutoSize = true;
            this.exportSkins.Checked = true;
            this.exportSkins.CheckState = System.Windows.Forms.CheckState.Checked;
            this.exportSkins.Location = new System.Drawing.Point(6, 83);
            this.exportSkins.Name = "exportSkins";
            this.exportSkins.Size = new System.Drawing.Size(96, 16);
            this.exportSkins.TabIndex = 8;
            this.exportSkins.Text = "Export skins";
            this.exportSkins.UseVisualStyleBackColor = true;
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(26, 39);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(95, 12);
            this.label1.TabIndex = 7;
            this.label1.Text = "FilterPrecision";
            // 
            // filterPrecision
            // 
            this.filterPrecision.DecimalPlaces = 2;
            this.filterPrecision.Increment = new decimal(new int[] {
            1,
            0,
            0,
            131072});
            this.filterPrecision.Location = new System.Drawing.Point(127, 37);
            this.filterPrecision.Name = "filterPrecision";
            this.filterPrecision.Size = new System.Drawing.Size(51, 21);
            this.filterPrecision.TabIndex = 6;
            this.filterPrecision.Value = new decimal(new int[] {
            25,
            0,
            0,
            131072});
            // 
            // castToBone
            // 
            this.castToBone.AutoSize = true;
            this.castToBone.Location = new System.Drawing.Point(6, 149);
            this.castToBone.Name = "castToBone";
            this.castToBone.Size = new System.Drawing.Size(156, 16);
            this.castToBone.TabIndex = 5;
            this.castToBone.Text = "All nodes cast to bone";
            this.castToBone.UseVisualStyleBackColor = true;
            // 
            // exportAllNodes
            // 
            this.exportAllNodes.AutoSize = true;
            this.exportAllNodes.Checked = true;
            this.exportAllNodes.CheckState = System.Windows.Forms.CheckState.Checked;
            this.exportAllNodes.Location = new System.Drawing.Point(6, 61);
            this.exportAllNodes.Name = "exportAllNodes";
            this.exportAllNodes.Size = new System.Drawing.Size(120, 16);
            this.exportAllNodes.TabIndex = 4;
            this.exportAllNodes.Text = "Export all nodes";
            this.exportAllNodes.UseVisualStyleBackColor = true;
            // 
            // eulerFilter
            // 
            this.eulerFilter.AutoSize = true;
            this.eulerFilter.Checked = true;
            this.eulerFilter.CheckState = System.Windows.Forms.CheckState.Checked;
            this.eulerFilter.Location = new System.Drawing.Point(6, 20);
            this.eulerFilter.Name = "eulerFilter";
            this.eulerFilter.Size = new System.Drawing.Size(90, 16);
            this.eulerFilter.TabIndex = 3;
            this.eulerFilter.Text = "EulerFilter";
            this.eulerFilter.UseVisualStyleBackColor = true;
            // 
            // ExportOptions
            // 
            this.AcceptButton = this.OKbutton;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 12F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.Cancel;
            this.ClientSize = new System.Drawing.Size(486, 384);
            this.Controls.Add(this.groupBox2);
            this.Controls.Add(this.groupBox1);
            this.Controls.Add(this.Cancel);
            this.Controls.Add(this.OKbutton);
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "ExportOptions";
            this.ShowIcon = false;
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "Export options";
            this.TopMost = true;
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            this.panel1.ResumeLayout(false);
            this.panel1.PerformLayout();
            this.groupBox2.ResumeLayout(false);
            this.groupBox2.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.scaleFactor)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.boneSize)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.filterPrecision)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion
        private System.Windows.Forms.Button OKbutton;
        private System.Windows.Forms.Button Cancel;
        private System.Windows.Forms.GroupBox groupBox1;
        private System.Windows.Forms.CheckBox converttexture;
        private System.Windows.Forms.RadioButton tojpg;
        private System.Windows.Forms.RadioButton topng;
        private System.Windows.Forms.RadioButton tobmp;
        private System.Windows.Forms.RadioButton totga;
        private System.Windows.Forms.CheckBox convertAudio;
        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.GroupBox groupBox2;
        private System.Windows.Forms.NumericUpDown boneSize;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.CheckBox exportSkins;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.NumericUpDown filterPrecision;
        private System.Windows.Forms.CheckBox castToBone;
        private System.Windows.Forms.CheckBox exportAllNodes;
        private System.Windows.Forms.CheckBox eulerFilter;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.ComboBox fbxVersion;
        private System.Windows.Forms.ComboBox fbxFormat;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.NumericUpDown scaleFactor;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.CheckBox exportBlendShape;
        private System.Windows.Forms.CheckBox exportAnimations;
        private System.Windows.Forms.ComboBox assetGroupOptions;
        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.CheckBox restoreExtensionName;
        private System.Windows.Forms.CheckBox openAfterExport;
        private System.Windows.Forms.CheckBox exportAllUvsAsDiffuseMaps;
        private System.Windows.Forms.ToolTip exportUvsTooltip;
    }
}
```

`AssetStudioGUI/ExportOptions.cs`:

```cs
using AssetStudio;
using System;
using System.Windows.Forms;

namespace AssetStudioGUI
{
    public partial class ExportOptions : Form
    {
        public ExportOptions()
        {
            InitializeComponent();
            assetGroupOptions.SelectedIndex = Properties.Settings.Default.assetGroupOption;
            restoreExtensionName.Checked = Properties.Settings.Default.restoreExtensionName;
            converttexture.Checked = Properties.Settings.Default.convertTexture;
            convertAudio.Checked = Properties.Settings.Default.convertAudio;
            var str = Properties.Settings.Default.convertType.ToString();
            foreach (Control c in panel1.Controls)
            {
                if (c.Text == str)
                {
                    ((RadioButton)c).Checked = true;
                    break;
                }
            }
            openAfterExport.Checked = Properties.Settings.Default.openAfterExport;
            eulerFilter.Checked = Properties.Settings.Default.eulerFilter;
            filterPrecision.Value = Properties.Settings.Default.filterPrecision;
            exportAllNodes.Checked = Properties.Settings.Default.exportAllNodes;
            exportSkins.Checked = Properties.Settings.Default.exportSkins;
            exportAnimations.Checked = Properties.Settings.Default.exportAnimations;
            exportBlendShape.Checked = Properties.Settings.Default.exportBlendShape;
            castToBone.Checked = Properties.Settings.Default.castToBone;
            exportAllUvsAsDiffuseMaps.Checked = Properties.Settings.Default.exportAllUvsAsDiffuseMaps;
            boneSize.Value = Properties.Settings.Default.boneSize;
            scaleFactor.Value = Properties.Settings.Default.scaleFactor;
            fbxVersion.SelectedIndex = Properties.Settings.Default.fbxVersion;
            fbxFormat.SelectedIndex = Properties.Settings.Default.fbxFormat;

        }

        private void OKbutton_Click(object sender, EventArgs e)
        {
            Properties.Settings.Default.assetGroupOption = assetGroupOptions.SelectedIndex;
            Properties.Settings.Default.restoreExtensionName = restoreExtensionName.Checked;
            Properties.Settings.Default.convertTexture = converttexture.Checked;
            Properties.Settings.Default.convertAudio = convertAudio.Checked;
            foreach (Control c in panel1.Controls)
            {
                if (((RadioButton)c).Checked)
                {
                    Properties.Settings.Default.convertType = (ImageFormat)Enum.Parse(typeof(ImageFormat), c.Text);
                    break;
                }
            }
            Properties.Settings.Default.openAfterExport = openAfterExport.Checked;
            Properties.Settings.Default.eulerFilter = eulerFilter.Checked;
            Properties.Settings.Default.filterPrecision = filterPrecision.Value;
            Properties.Settings.Default.exportAllNodes = exportAllNodes.Checked;
            Properties.Settings.Default.exportSkins = exportSkins.Checked;
            Properties.Settings.Default.exportAnimations = exportAnimations.Checked;
            Properties.Settings.Default.exportBlendShape = exportBlendShape.Checked;
            Properties.Settings.Default.castToBone = castToBone.Checked;
            Properties.Settings.Default.exportAllUvsAsDiffuseMaps = exportAllUvsAsDiffuseMaps.Checked;
            Properties.Settings.Default.boneSize = boneSize.Value;
            Properties.Settings.Default.scaleFactor = scaleFactor.Value;
            Properties.Settings.Default.fbxVersion = fbxVersion.SelectedIndex;
            Properties.Settings.Default.fbxFormat = fbxFormat.SelectedIndex;
            Properties.Settings.Default.Save();
            DialogResult = DialogResult.OK;
            Close();
        }

        private void Cancel_Click(object sender, EventArgs e)
        {
            DialogResult = DialogResult.Cancel;
            Close();
        }

    }
}

```

`AssetStudioGUI/ExportOptions.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="exportUvsTooltip.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>
```

`AssetStudioGUI/Exporter.cs`:

```cs
using AssetStudio;
using Newtonsoft.Json;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace AssetStudioGUI
{
    internal static class Exporter
    {
        public static bool ExportTexture2D(AssetItem item, string exportPath)
        {
            var m_Texture2D = (Texture2D)item.Asset;
            if (Properties.Settings.Default.convertTexture)
            {
                var type = Properties.Settings.Default.convertType;
                if (!TryExportFile(exportPath, item, "." + type.ToString().ToLower(), out var exportFullPath))
                    return false;
                var image = m_Texture2D.ConvertToImage(true);
                if (image == null)
                    return false;
                using (image)
                {
                    using (var file = File.OpenWrite(exportFullPath))
                    {
                        image.WriteToStream(file, type);
                    }
                    return true;
                }
            }
            else
            {
                if (!TryExportFile(exportPath, item, ".tex", out var exportFullPath))
                    return false;
                File.WriteAllBytes(exportFullPath, m_Texture2D.image_data.GetData());
                return true;
            }
        }

        public static bool ExportAudioClip(AssetItem item, string exportPath)
        {
            var m_AudioClip = (AudioClip)item.Asset;
            var m_AudioData = m_AudioClip.m_AudioData.GetData();
            if (m_AudioData == null || m_AudioData.Length == 0)
                return false;
            var converter = new AudioClipConverter(m_AudioClip);
            if (Properties.Settings.Default.convertAudio && converter.IsSupport)
            {
                if (!TryExportFile(exportPath, item, ".wav", out var exportFullPath))
                    return false;
                var buffer = converter.ConvertToWav();
                if (buffer == null)
                    return false;
                File.WriteAllBytes(exportFullPath, buffer);
            }
            else
            {
                if (!TryExportFile(exportPath, item, converter.GetExtensionName(), out var exportFullPath))
                    return false;
                File.WriteAllBytes(exportFullPath, m_AudioData);
            }
            return true;
        }

        public static bool ExportShader(AssetItem item, string exportPath)
        {
            if (!TryExportFile(exportPath, item, ".shader", out var exportFullPath))
                return false;
            var m_Shader = (Shader)item.Asset;
            var str = m_Shader.Convert();
            File.WriteAllText(exportFullPath, str);
            return true;
        }

        public static bool ExportTextAsset(AssetItem item, string exportPath)
        {
            var m_TextAsset = (TextAsset)(item.Asset);
            var extension = ".txt";
            if (Properties.Settings.Default.restoreExtensionName)
            {
                if (!string.IsNullOrEmpty(item.Container))
                {
                    extension = Path.GetExtension(item.Container);
                }
            }
            if (!TryExportFile(exportPath, item, extension, out var exportFullPath))
                return false;
            File.WriteAllBytes(exportFullPath, m_TextAsset.m_Script);
            return true;
        }

        public static bool ExportMonoBehaviour(AssetItem item, string exportPath)
        {
            if (!TryExportFile(exportPath, item, ".json", out var exportFullPath))
                return false;
            var m_MonoBehaviour = (MonoBehaviour)item.Asset;
            var type = m_MonoBehaviour.ToType();
            if (type == null)
            {
                var m_Type = Studio.MonoBehaviourToTypeTree(m_MonoBehaviour);
                type = m_MonoBehaviour.ToType(m_Type);
            }
            var str = JsonConvert.SerializeObject(type, Formatting.Indented);
            File.WriteAllText(exportFullPath, str);
            return true;
        }

        public static bool ExportFont(AssetItem item, string exportPath)
        {
            var m_Font = (Font)item.Asset;
            if (m_Font.m_FontData != null)
            {
                var extension = ".ttf";
                if (m_Font.m_FontData[0] == 79 && m_Font.m_FontData[1] == 84 && m_Font.m_FontData[2] == 84 && m_Font.m_FontData[3] == 79)
                {
                    extension = ".otf";
                }
                if (!TryExportFile(exportPath, item, extension, out var exportFullPath))
                    return false;
                File.WriteAllBytes(exportFullPath, m_Font.m_FontData);
                return true;
            }
            return false;
        }

        public static bool ExportMesh(AssetItem item, string exportPath)
        {
            var m_Mesh = (Mesh)item.Asset;
            if (m_Mesh.m_VertexCount <= 0)
                return false;
            if (!TryExportFile(exportPath, item, ".obj", out var exportFullPath))
                return false;
            var sb = new StringBuilder();
            sb.AppendLine("g " + m_Mesh.m_Name);
            #region Vertices
            if (m_Mesh.m_Vertices == null || m_Mesh.m_Vertices.Length == 0)
            {
                return false;
            }
            int c = 3;
            if (m_Mesh.m_Vertices.Length == m_Mesh.m_VertexCount * 4)
            {
                c = 4;
            }
            for (int v = 0; v < m_Mesh.m_VertexCount; v++)
            {
                sb.AppendFormat("v {0} {1} {2}\r\n", -m_Mesh.m_Vertices[v * c], m_Mesh.m_Vertices[v * c + 1], m_Mesh.m_Vertices[v * c + 2]);
            }
            #endregion

            #region UV
            if (m_Mesh.m_UV0?.Length > 0)
            {
                c = 4;
                if (m_Mesh.m_UV0.Length == m_Mesh.m_VertexCount * 2)
                {
                    c = 2;
                }
                else if (m_Mesh.m_UV0.Length == m_Mesh.m_VertexCount * 3)
                {
                    c = 3;
                }
                for (int v = 0; v < m_Mesh.m_VertexCount; v++)
                {
                    sb.AppendFormat("vt {0} {1}\r\n", m_Mesh.m_UV0[v * c], m_Mesh.m_UV0[v * c + 1]);
                }
            }
            #endregion

            #region Normals
            if (m_Mesh.m_Normals?.Length > 0)
            {
                if (m_Mesh.m_Normals.Length == m_Mesh.m_VertexCount * 3)
                {
                    c = 3;
                }
                else if (m_Mesh.m_Normals.Length == m_Mesh.m_VertexCount * 4)
                {
                    c = 4;
                }
                for (int v = 0; v < m_Mesh.m_VertexCount; v++)
                {
                    sb.AppendFormat("vn {0} {1} {2}\r\n", -m_Mesh.m_Normals[v * c], m_Mesh.m_Normals[v * c + 1], m_Mesh.m_Normals[v * c + 2]);
                }
            }
            #endregion

            #region Face
            int sum = 0;
            for (var i = 0; i < m_Mesh.m_SubMeshes.Length; i++)
            {
                sb.AppendLine($"g {m_Mesh.m_Name}_{i}");
                int indexCount = (int)m_Mesh.m_SubMeshes[i].indexCount;
                var end = sum + indexCount / 3;
                for (int f = sum; f < end; f++)
                {
                    sb.AppendFormat("f {0}/{0}/{0} {1}/{1}/{1} {2}/{2}/{2}\r\n", m_Mesh.m_Indices[f * 3 + 2] + 1, m_Mesh.m_Indices[f * 3 + 1] + 1, m_Mesh.m_Indices[f * 3] + 1);
                }
                sum = end;
            }
            #endregion

            sb.Replace("NaN", "0");
            File.WriteAllText(exportFullPath, sb.ToString());
            return true;
        }

        public static bool ExportVideoClip(AssetItem item, string exportPath)
        {
            var m_VideoClip = (VideoClip)item.Asset;
            if (m_VideoClip.m_ExternalResources.m_Size > 0)
            {
                if (!TryExportFile(exportPath, item, Path.GetExtension(m_VideoClip.m_OriginalPath), out var exportFullPath))
                    return false;
                m_VideoClip.m_VideoData.WriteData(exportFullPath);
                return true;
            }
            return false;
        }

        public static bool ExportMovieTexture(AssetItem item, string exportPath)
        {
            var m_MovieTexture = (MovieTexture)item.Asset;
            if (!TryExportFile(exportPath, item, ".ogv", out var exportFullPath))
                return false;
            File.WriteAllBytes(exportFullPath, m_MovieTexture.m_MovieData);
            return true;
        }

        public static bool ExportSprite(AssetItem item, string exportPath)
        {
            var type = Properties.Settings.Default.convertType;
            if (!TryExportFile(exportPath, item, "." + type.ToString().ToLower(), out var exportFullPath))
                return false;
            var image = ((Sprite)item.Asset).GetImage();
            if (image != null)
            {
                using (image)
                {
                    using (var file = File.OpenWrite(exportFullPath))
                    {
                        image.WriteToStream(file, type);
                    }
                    return true;
                }
            }
            return false;
        }

        public static bool ExportRawFile(AssetItem item, string exportPath)
        {
            if (!TryExportFile(exportPath, item, ".dat", out var exportFullPath))
                return false;
            File.WriteAllBytes(exportFullPath, item.Asset.GetRawData());
            return true;
        }

        private static bool TryExportFile(string dir, AssetItem item, string extension, out string fullPath)
        {
            var fileName = FixFileName(item.Text);
            fullPath = Path.Combine(dir, fileName + extension);
            if (!File.Exists(fullPath))
            {
                Directory.CreateDirectory(dir);
                return true;
            }
            fullPath = Path.Combine(dir, fileName + item.UniqueID + extension);
            if (!File.Exists(fullPath))
            {
                Directory.CreateDirectory(dir);
                return true;
            }
            return false;
        }

        public static bool ExportAnimator(AssetItem item, string exportPath, List<AssetItem> animationList = null)
        {
            var exportFullPath = Path.Combine(exportPath, item.Text, item.Text + ".fbx");
            if (File.Exists(exportFullPath))
            {
                exportFullPath = Path.Combine(exportPath, item.Text + item.UniqueID, item.Text + ".fbx");
            }
            var m_Animator = (Animator)item.Asset;
            var convert = animationList != null
                ? new ModelConverter(m_Animator, Properties.Settings.Default.convertType, animationList.Select(x => (AnimationClip)x.Asset).ToArray())
                : new ModelConverter(m_Animator, Properties.Settings.Default.convertType);
            ExportFbx(convert, exportFullPath);
            return true;
        }

        public static void ExportGameObject(GameObject gameObject, string exportPath, List<AssetItem> animationList = null)
        {
            var convert = animationList != null
                ? new ModelConverter(gameObject, Properties.Settings.Default.convertType, animationList.Select(x => (AnimationClip)x.Asset).ToArray())
                : new ModelConverter(gameObject, Properties.Settings.Default.convertType);
            exportPath = exportPath + FixFileName(gameObject.m_Name) + ".fbx";
            ExportFbx(convert, exportPath);
        }

        public static void ExportGameObjectMerge(List<GameObject> gameObject, string exportPath, List<AssetItem> animationList = null)
        {
            var rootName = Path.GetFileNameWithoutExtension(exportPath);
            var convert = animationList != null
                ? new ModelConverter(rootName, gameObject, Properties.Settings.Default.convertType, animationList.Select(x => (AnimationClip)x.Asset).ToArray())
                : new ModelConverter(rootName, gameObject, Properties.Settings.Default.convertType);
            ExportFbx(convert, exportPath);
        }

        private static void ExportFbx(IImported convert, string exportPath)
        {
            var eulerFilter = Properties.Settings.Default.eulerFilter;
            var filterPrecision = (float)Properties.Settings.Default.filterPrecision;
            var exportAllNodes = Properties.Settings.Default.exportAllNodes;
            var exportSkins = Properties.Settings.Default.exportSkins;
            var exportAnimations = Properties.Settings.Default.exportAnimations;
            var exportBlendShape = Properties.Settings.Default.exportBlendShape;
            var castToBone = Properties.Settings.Default.castToBone;
            var boneSize = (int)Properties.Settings.Default.boneSize;
            var exportAllUvsAsDiffuseMaps = Properties.Settings.Default.exportAllUvsAsDiffuseMaps;
            var scaleFactor = (float)Properties.Settings.Default.scaleFactor;
            var fbxVersion = Properties.Settings.Default.fbxVersion;
            var fbxFormat = Properties.Settings.Default.fbxFormat;
            ModelExporter.ExportFbx(exportPath, convert, eulerFilter, filterPrecision,
                exportAllNodes, exportSkins, exportAnimations, exportBlendShape, castToBone, boneSize, exportAllUvsAsDiffuseMaps, scaleFactor, fbxVersion, fbxFormat == 1);
        }

        public static bool ExportDumpFile(AssetItem item, string exportPath)
        {
            if (!TryExportFile(exportPath, item, ".txt", out var exportFullPath))
                return false;
            var str = item.Asset.Dump();
            if (str == null && item.Asset is MonoBehaviour m_MonoBehaviour)
            {
                var m_Type = Studio.MonoBehaviourToTypeTree(m_MonoBehaviour);
                str = m_MonoBehaviour.Dump(m_Type);
            }
            if (str != null)
            {
                File.WriteAllText(exportFullPath, str);
                return true;
            }
            return false;
        }

        public static bool ExportConvertFile(AssetItem item, string exportPath)
        {
            switch (item.Type)
            {
                case ClassIDType.Texture2D:
                    return ExportTexture2D(item, exportPath);
                case ClassIDType.AudioClip:
                    return ExportAudioClip(item, exportPath);
                case ClassIDType.Shader:
                    return ExportShader(item, exportPath);
                case ClassIDType.TextAsset:
                    return ExportTextAsset(item, exportPath);
                case ClassIDType.MonoBehaviour:
                    return ExportMonoBehaviour(item, exportPath);
                case ClassIDType.Font:
                    return ExportFont(item, exportPath);
                case ClassIDType.Mesh:
                    return ExportMesh(item, exportPath);
                case ClassIDType.VideoClip:
                    return ExportVideoClip(item, exportPath);
                case ClassIDType.MovieTexture:
                    return ExportMovieTexture(item, exportPath);
                case ClassIDType.Sprite:
                    return ExportSprite(item, exportPath);
                case ClassIDType.Animator:
                    return ExportAnimator(item, exportPath);
                case ClassIDType.AnimationClip:
                    return false;
                default:
                    return ExportRawFile(item, exportPath);
            }
        }

        public static string FixFileName(string str)
        {
            if (str.Length >= 260) return Path.GetRandomFileName();
            return Path.GetInvalidFileNameChars().Aggregate(str, (current, c) => current.Replace(c, '_'));
        }
    }
}

```

`AssetStudioGUI/GUILogger.cs`:

```cs
using AssetStudio;
using System;
using System.Windows.Forms;

namespace AssetStudioGUI
{
    class GUILogger : ILogger
    {
        public bool ShowErrorMessage = true;
        private Action<string> action;

        public GUILogger(Action<string> action)
        {
            this.action = action;
        }

        public void Log(LoggerEvent loggerEvent, string message)
        {
            switch (loggerEvent)
            {
                case LoggerEvent.Error:
                    if (ShowErrorMessage)
                    {
                        MessageBox.Show(message);
                    }
                    break;
                default:
                    action(message);
                    break;
            }

        }
    }
}

```

`AssetStudioGUI/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace AssetStudioGUI
{
    static class Program
    {
        /// <summary>
        ///  The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
#if !NETFRAMEWORK
            Application.SetHighDpiMode(HighDpiMode.SystemAware);
#endif
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new AssetStudioGUIForm());
        }
    }
}

```

`AssetStudioGUI/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

namespace AssetStudioGUI.Properties {
    using System;
    
    
    /// <summary>
    ///   一个强类型的资源类，用于查找本地化的字符串等。
    /// </summary>
    // 此类是由 StronglyTypedResourceBuilder
    // 类通过类似于 ResGen 或 Visual Studio 的工具自动生成的。
    // 若要添加或移除成员，请编辑 .ResX 文件，然后重新运行 ResGen
    // (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   返回此类使用的缓存的 ResourceManager 实例。
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("AssetStudioGUI.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   重写当前线程的 CurrentUICulture 属性，对
        ///   使用此强类型资源类的所有资源查找执行重写。
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   查找类似于 (图标) 的 System.Drawing.Icon 类型的本地化资源。
        /// </summary>
        internal static System.Drawing.Icon _as {
            get {
                object obj = ResourceManager.GetObject("_as", resourceCulture);
                return ((System.Drawing.Icon)(obj));
            }
        }
        
        /// <summary>
        ///   查找类似 #version 140
        ///
        ///in vec3 normal;
        ///
        ///out vec4 outputColor;
        ///
        ///void main()
        ///{
        ///	vec3 unitNormal = normalize(normal);
        ///	float nDotProduct = clamp(dot(unitNormal, vec3(0.707, 0, 0.707)), 0, 1);
        ///	vec2 ContributionWeightsSqrt = vec2(0.5, 0.5f) + vec2(0.5f, -0.5f) * unitNormal.y;
        ///	vec2 ContributionWeights = ContributionWeightsSqrt * ContributionWeightsSqrt;
        ///
        ///	vec3 color = nDotProduct * vec3(1, 0.957, 0.839) / 3.14159;
        ///	color += vec3(0.779, 0.716, 0.453) * ContributionWeights.y;
        ///	color += vec3(0.368, 0.477, 0. [字符串的其余部分被截断]&quot;; 的本地化字符串。
        /// </summary>
        internal static string fs {
            get {
                return ResourceManager.GetString("fs", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 #version 140
        ///
        ///out vec4 outputColor;
        ///
        ///void main()
        ///{
        ///	outputColor = vec4(0, 0, 0, 1);
        ///} 的本地化字符串。
        /// </summary>
        internal static string fsBlack {
            get {
                return ResourceManager.GetString("fsBlack", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 #version 140
        ///
        ///out vec4 outputColor;
        ///in vec4 color;
        ///
        ///void main()
        ///{
        ///	outputColor = color;
        ///} 的本地化字符串。
        /// </summary>
        internal static string fsColor {
            get {
                return ResourceManager.GetString("fsColor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找 System.Drawing.Bitmap 类型的本地化资源。
        /// </summary>
        internal static System.Drawing.Bitmap preview {
            get {
                object obj = ResourceManager.GetObject("preview", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   查找类似 #version 140
        ///
        ///in vec3 vertexPosition;
        ///in vec3 normalDirection;
        ///in vec4 vertexColor;
        ///uniform mat4 modelMatrix;
        ///uniform mat4 viewMatrix;
        ///uniform mat4 projMatrix;
        ///
        ///out vec3 normal;
        ///out vec4 color;
        ///
        ///void main()
        ///{
        ///	gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);
        ///	normal = normalDirection;
        ///	color = vertexColor; 
        ///} 的本地化字符串。
        /// </summary>
        internal static string vs {
            get {
                return ResourceManager.GetString("vs", resourceCulture);
            }
        }
    }
}

```

`AssetStudioGUI/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="fs" xml:space="preserve">
    <value>#version 140

in vec3 normal;

out vec4 outputColor;

void main()
{
	vec3 unitNormal = normalize(normal);
	float nDotProduct = clamp(dot(unitNormal, vec3(0.707, 0, 0.707)), 0, 1);
	vec2 ContributionWeightsSqrt = vec2(0.5, 0.5f) + vec2(0.5f, -0.5f) * unitNormal.y;
	vec2 ContributionWeights = ContributionWeightsSqrt * ContributionWeightsSqrt;

	vec3 color = nDotProduct * vec3(1, 0.957, 0.839) / 3.14159;
	color += vec3(0.779, 0.716, 0.453) * ContributionWeights.y;
	color += vec3(0.368, 0.477, 0.735) * ContributionWeights.x;
	outputColor = vec4(sqrt(color), 1);
}</value>
  </data>
  <data name="fsBlack" xml:space="preserve">
    <value>#version 140

out vec4 outputColor;

void main()
{
	outputColor = vec4(0, 0, 0, 1);
}</value>
  </data>
  <data name="fsColor" xml:space="preserve">
    <value>#version 140

out vec4 outputColor;
in vec4 color;

void main()
{
	outputColor = color;
}</value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="preview" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\preview.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="vs" xml:space="preserve">
    <value>#version 140

in vec3 vertexPosition;
in vec3 normalDirection;
in vec4 vertexColor;
uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projMatrix;

out vec3 normal;
out vec4 color;

void main()
{
	gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);
	normal = normalDirection;
	color = vertexColor; 
}</value>
  </data>
  <data name="_as" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\as.ico;System.Drawing.Icon, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
</root>
```

`AssetStudioGUI/Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

namespace AssetStudioGUI.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "16.10.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("False")]
        public bool displayAll {
            get {
                return ((bool)(this["displayAll"]));
            }
            set {
                this["displayAll"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool enablePreview {
            get {
                return ((bool)(this["enablePreview"]));
            }
            set {
                this["enablePreview"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool displayInfo {
            get {
                return ((bool)(this["displayInfo"]));
            }
            set {
                this["displayInfo"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool openAfterExport {
            get {
                return ((bool)(this["openAfterExport"]));
            }
            set {
                this["openAfterExport"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("0")]
        public int assetGroupOption {
            get {
                return ((int)(this["assetGroupOption"]));
            }
            set {
                this["assetGroupOption"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool convertTexture {
            get {
                return ((bool)(this["convertTexture"]));
            }
            set {
                this["convertTexture"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool convertAudio {
            get {
                return ((bool)(this["convertAudio"]));
            }
            set {
                this["convertAudio"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("Png")]
        public global::AssetStudio.ImageFormat convertType {
            get {
                return ((global::AssetStudio.ImageFormat)(this["convertType"]));
            }
            set {
                this["convertType"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool eulerFilter {
            get {
                return ((bool)(this["eulerFilter"]));
            }
            set {
                this["eulerFilter"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("0.25")]
        public decimal filterPrecision {
            get {
                return ((decimal)(this["filterPrecision"]));
            }
            set {
                this["filterPrecision"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool exportAllNodes {
            get {
                return ((bool)(this["exportAllNodes"]));
            }
            set {
                this["exportAllNodes"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool exportSkins {
            get {
                return ((bool)(this["exportSkins"]));
            }
            set {
                this["exportSkins"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool exportAnimations {
            get {
                return ((bool)(this["exportAnimations"]));
            }
            set {
                this["exportAnimations"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("10")]
        public decimal boneSize {
            get {
                return ((decimal)(this["boneSize"]));
            }
            set {
                this["boneSize"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("3")]
        public int fbxVersion {
            get {
                return ((int)(this["fbxVersion"]));
            }
            set {
                this["fbxVersion"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("0")]
        public int fbxFormat {
            get {
                return ((int)(this["fbxFormat"]));
            }
            set {
                this["fbxFormat"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("1")]
        public decimal scaleFactor {
            get {
                return ((decimal)(this["scaleFactor"]));
            }
            set {
                this["scaleFactor"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool exportBlendShape {
            get {
                return ((bool)(this["exportBlendShape"]));
            }
            set {
                this["exportBlendShape"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("False")]
        public bool castToBone {
            get {
                return ((bool)(this["castToBone"]));
            }
            set {
                this["castToBone"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("True")]
        public bool restoreExtensionName {
            get {
                return ((bool)(this["restoreExtensionName"]));
            }
            set {
                this["restoreExtensionName"] = value;
            }
        }
        
        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("False")]
        public bool exportAllUvsAsDiffuseMaps {
            get {
                return ((bool)(this["exportAllUvsAsDiffuseMaps"]));
            }
            set {
                this["exportAllUvsAsDiffuseMaps"] = value;
            }
        }
    }
}

```

`AssetStudioGUI/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)" GeneratedClassNamespace="AssetStudioGUI.Properties" GeneratedClassName="Settings">
  <Profiles />
  <Settings>
    <Setting Name="displayAll" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">False</Value>
    </Setting>
    <Setting Name="enablePreview" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">True</Value>
    </Setting>
    <Setting Name="displayInfo" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">True</Value>
    </Setting>
    <Setting Name="openAfterExport" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">True</Value>
    </Setting>
    <Setting Name="assetGroupOption" Type="System.Int32" Scope="User">
      <Value Profile="(Default)">0</Value>
    </Setting>
    <Setting Name="convertTexture" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">True</Value>
    </Setting>
    <Setting Name="convertAudio" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">True</Value>
    </Setting>
    <Setting Name="convertType" Type="AssetStudio.ImageFormat" Scope="User">
      <Value Profile="(Default)">Png</Value>
    </Setting>
    <Setting Name="eulerFilter" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">True</Value>
    </Setting>
    <Setting Name="filterPrecision" Type="System.Decimal" Scope="User">
      <Value Profile="(Default)">0.25</Value>
    </Setting>
    <Setting Name="exportAllNodes" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">True</Value>
    </Setting>
    <Setting Name="exportSkins" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">True</Value>
    </Setting>
    <Setting Name="exportAnimations" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">True</Value>
    </Setting>
    <Setting Name="boneSize" Type="System.Decimal" Scope="User">
      <Value Profile="(Default)">10</Value>
    </Setting>
    <Setting Name="fbxVersion" Type="System.Int32" Scope="User">
      <Value Profile="(Default)">3</Value>
    </Setting>
    <Setting Name="fbxFormat" Type="System.Int32" Scope="User">
      <Value Profile="(Default)">0</Value>
    </Setting>
    <Setting Name="scaleFactor" Type="System.Decimal" Scope="User">
      <Value Profile="(Default)">1</Value>
    </Setting>
    <Setting Name="exportBlendShape" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">True</Value>
    </Setting>
    <Setting Name="castToBone" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">False</Value>
    </Setting>
    <Setting Name="restoreExtensionName" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">True</Value>
    </Setting>
    <Setting Name="exportAllUvsAsDiffuseMaps" Type="System.Boolean" Scope="User">
      <Value Profile="(Default)">False</Value>
    </Setting>
  </Settings>
</SettingsFile>
```

`AssetStudioGUI/Studio.cs`:

```cs
using AssetStudio;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;
using System.Windows.Forms;
using System.Xml.Linq;
using static AssetStudioGUI.Exporter;
using Object = AssetStudio.Object;

namespace AssetStudioGUI
{
    internal enum ExportType
    {
        Convert,
        Raw,
        Dump
    }

    internal enum ExportFilter
    {
        All,
        Selected,
        Filtered
    }

    internal enum ExportListType
    {
        XML
    }

    internal static class Studio
    {
        public static AssetsManager assetsManager = new AssetsManager();
        public static AssemblyLoader assemblyLoader = new AssemblyLoader();
        public static List<AssetItem> exportableAssets = new List<AssetItem>();
        public static List<AssetItem> visibleAssets = new List<AssetItem>();
        internal static Action<string> StatusStripUpdate = x => { };

        public static int ExtractFolder(string path, string savePath)
        {
            int extractedCount = 0;
            Progress.Reset();
            var files = Directory.GetFiles(path, "*.*", SearchOption.AllDirectories);
            for (int i = 0; i < files.Length; i++)
            {
                var file = files[i];
                var fileOriPath = Path.GetDirectoryName(file);
                var fileSavePath = fileOriPath.Replace(path, savePath);
                extractedCount += ExtractFile(file, fileSavePath);
                Progress.Report(i + 1, files.Length);
            }
            return extractedCount;
        }

        public static int ExtractFile(string[] fileNames, string savePath)
        {
            int extractedCount = 0;
            Progress.Reset();
            for (var i = 0; i < fileNames.Length; i++)
            {
                var fileName = fileNames[i];
                extractedCount += ExtractFile(fileName, savePath);
                Progress.Report(i + 1, fileNames.Length);
            }
            return extractedCount;
        }

        public static int ExtractFile(string fileName, string savePath)
        {
            int extractedCount = 0;
            var reader = new FileReader(fileName);
            if (reader.FileType == FileType.BundleFile)
                extractedCount += ExtractBundleFile(reader, savePath);
            else if (reader.FileType == FileType.WebFile)
                extractedCount += ExtractWebDataFile(reader, savePath);
            else
                reader.Dispose();
            return extractedCount;
        }

        private static int ExtractBundleFile(FileReader reader, string savePath)
        {
            StatusStripUpdate($"Decompressing {reader.FileName} ...");
            var bundleFile = new BundleFile(reader);
            reader.Dispose();
            if (bundleFile.fileList.Length > 0)
            {
                var extractPath = Path.Combine(savePath, reader.FileName + "_unpacked");
                return ExtractStreamFile(extractPath, bundleFile.fileList);
            }
            return 0;
        }

        private static int ExtractWebDataFile(FileReader reader, string savePath)
        {
            StatusStripUpdate($"Decompressing {reader.FileName} ...");
            var webFile = new WebFile(reader);
            reader.Dispose();
            if (webFile.fileList.Length > 0)
            {
                var extractPath = Path.Combine(savePath, reader.FileName + "_unpacked");
                return ExtractStreamFile(extractPath, webFile.fileList);
            }
            return 0;
        }

        private static int ExtractStreamFile(string extractPath, StreamFile[] fileList)
        {
            int extractedCount = 0;
            foreach (var file in fileList)
            {
                var filePath = Path.Combine(extractPath, file.path);
                var fileDirectory = Path.GetDirectoryName(filePath);
                if (!Directory.Exists(fileDirectory))
                {
                    Directory.CreateDirectory(fileDirectory);
                }
                if (!File.Exists(filePath))
                {
                    using (var fileStream = File.Create(filePath))
                    {
                        file.stream.CopyTo(fileStream);
                    }
                    extractedCount += 1;
                }
                file.stream.Dispose();
            }
            return extractedCount;
        }

        public static (string, List<TreeNode>) BuildAssetData()
        {
            StatusStripUpdate("Building asset list...");

            string productName = null;
            var objectCount = assetsManager.assetsFileList.Sum(x => x.Objects.Count);
            var objectAssetItemDic = new Dictionary<Object, AssetItem>(objectCount);
            var containers = new List<(PPtr<Object>, string)>();
            int i = 0;
            Progress.Reset();
            foreach (var assetsFile in assetsManager.assetsFileList)
            {
                foreach (var asset in assetsFile.Objects)
                {
                    var assetItem = new AssetItem(asset);
                    objectAssetItemDic.Add(asset, assetItem);
                    assetItem.UniqueID = " #" + i;
                    var exportable = false;
                    switch (asset)
                    {
                        case GameObject m_GameObject:
                            assetItem.Text = m_GameObject.m_Name;
                            break;
                        case Texture2D m_Texture2D:
                            if (!string.IsNullOrEmpty(m_Texture2D.m_StreamData?.path))
                                assetItem.FullSize = asset.byteSize + m_Texture2D.m_StreamData.size;
                            assetItem.Text = m_Texture2D.m_Name;
                            exportable = true;
                            break;
                        case AudioClip m_AudioClip:
                            if (!string.IsNullOrEmpty(m_AudioClip.m_Source))
                                assetItem.FullSize = asset.byteSize + m_AudioClip.m_Size;
                            assetItem.Text = m_AudioClip.m_Name;
                            exportable = true;
                            break;
                        case VideoClip m_VideoClip:
                            if (!string.IsNullOrEmpty(m_VideoClip.m_OriginalPath))
                                assetItem.FullSize = asset.byteSize + (long)m_VideoClip.m_ExternalResources.m_Size;
                            assetItem.Text = m_VideoClip.m_Name;
                            exportable = true;
                            break;
                        case Shader m_Shader:
                            assetItem.Text = m_Shader.m_ParsedForm?.m_Name ?? m_Shader.m_Name;
                            exportable = true;
                            break;
                        case Mesh _:
                        case TextAsset _:
                        case AnimationClip _:
                        case Font _:
                        case MovieTexture _:
                        case Sprite _:
                            assetItem.Text = ((NamedObject)asset).m_Name;
                            exportable = true;
                            break;
                        case Animator m_Animator:
                            if (m_Animator.m_GameObject.TryGet(out var gameObject))
                            {
                                assetItem.Text = gameObject.m_Name;
                            }
                            exportable = true;
                            break;
                        case MonoBehaviour m_MonoBehaviour:
                            if (m_MonoBehaviour.m_Name == "" && m_MonoBehaviour.m_Script.TryGet(out var m_Script))
                            {
                                assetItem.Text = m_Script.m_ClassName;
                            }
                            else
                            {
                                assetItem.Text = m_MonoBehaviour.m_Name;
                            }
                            exportable = true;
                            break;
                        case PlayerSettings m_PlayerSettings:
                            productName = m_PlayerSettings.productName;
                            break;
                        case AssetBundle m_AssetBundle:
                            foreach (var m_Container in m_AssetBundle.m_Container)
                            {
                                var preloadIndex = m_Container.Value.preloadIndex;
                                var preloadSize = m_Container.Value.preloadSize;
                                var preloadEnd = preloadIndex + preloadSize;
                                for (int k = preloadIndex; k < preloadEnd; k++)
                                {
                                    containers.Add((m_AssetBundle.m_PreloadTable[k], m_Container.Key));
                                }
                            }
                            assetItem.Text = m_AssetBundle.m_Name;
                            break;
                        case ResourceManager m_ResourceManager:
                            foreach (var m_Container in m_ResourceManager.m_Container)
                            {
                                containers.Add((m_Container.Value, m_Container.Key));
                            }
                            break;
                        case NamedObject m_NamedObject:
                            assetItem.Text = m_NamedObject.m_Name;
                            break;
                    }
                    if (assetItem.Text == "")
                    {
                        assetItem.Text = assetItem.TypeString + assetItem.UniqueID;
                    }
                    if (Properties.Settings.Default.displayAll || exportable)
                    {
                        exportableAssets.Add(assetItem);
                    }
                    Progress.Report(++i, objectCount);
                }
            }
            foreach ((var pptr, var container) in containers)
            {
                if (pptr.TryGet(out var obj))
                {
                    objectAssetItemDic[obj].Container = container;
                }
            }
            foreach (var tmp in exportableAssets)
            {
                tmp.SetSubItems();
            }
            containers.Clear();

            visibleAssets = exportableAssets;

            StatusStripUpdate("Building tree structure...");

            var treeNodeCollection = new List<TreeNode>();
            var treeNodeDictionary = new Dictionary<GameObject, GameObjectTreeNode>();
            var assetsFileCount = assetsManager.assetsFileList.Count;
            int j = 0;
            Progress.Reset();
            foreach (var assetsFile in assetsManager.assetsFileList)
            {
                var fileNode = new TreeNode(assetsFile.fileName); //RootNode

                foreach (var obj in assetsFile.Objects)
                {
                    if (obj is GameObject m_GameObject)
                    {
                        if (!treeNodeDictionary.TryGetValue(m_GameObject, out var currentNode))
                        {
                            currentNode = new GameObjectTreeNode(m_GameObject);
                            treeNodeDictionary.Add(m_GameObject, currentNode);
                        }

                        foreach (var pptr in m_GameObject.m_Components)
                        {
                            if (pptr.TryGet(out var m_Component))
                            {
                                objectAssetItemDic[m_Component].TreeNode = currentNode;
                                if (m_Component is MeshFilter m_MeshFilter)
                                {
                                    if (m_MeshFilter.m_Mesh.TryGet(out var m_Mesh))
                                    {
                                        objectAssetItemDic[m_Mesh].TreeNode = currentNode;
                                    }
                                }
                                else if (m_Component is SkinnedMeshRenderer m_SkinnedMeshRenderer)
                                {
                                    if (m_SkinnedMeshRenderer.m_Mesh.TryGet(out var m_Mesh))
                                    {
                                        objectAssetItemDic[m_Mesh].TreeNode = currentNode;
                                    }
                                }
                            }
                        }

                        var parentNode = fileNode;

                        if (m_GameObject.m_Transform != null)
                        {
                            if (m_GameObject.m_Transform.m_Father.TryGet(out var m_Father))
                            {
                                if (m_Father.m_GameObject.TryGet(out var parentGameObject))
                                {
                                    if (!treeNodeDictionary.TryGetValue(parentGameObject, out var parentGameObjectNode))
                                    {
                                        parentGameObjectNode = new GameObjectTreeNode(parentGameObject);
                                        treeNodeDictionary.Add(parentGameObject, parentGameObjectNode);
                                    }
                                    parentNode = parentGameObjectNode;
                                }
                            }
                        }

                        parentNode.Nodes.Add(currentNode);
                    }
                }

                if (fileNode.Nodes.Count > 0)
                {
                    treeNodeCollection.Add(fileNode);
                }

                Progress.Report(++j, assetsFileCount);
            }
            treeNodeDictionary.Clear();

            objectAssetItemDic.Clear();

            return (productName, treeNodeCollection);
        }

        public static Dictionary<string, SortedDictionary<int, TypeTreeItem>> BuildClassStructure()
        {
            var typeMap = new Dictionary<string, SortedDictionary<int, TypeTreeItem>>();
            foreach (var assetsFile in assetsManager.assetsFileList)
            {
                if (typeMap.TryGetValue(assetsFile.unityVersion, out var curVer))
                {
                    foreach (var type in assetsFile.m_Types.Where(x => x.m_Type != null))
                    {
                        var key = type.classID;
                        if (type.m_ScriptTypeIndex >= 0)
                        {
                            key = -1 - type.m_ScriptTypeIndex;
                        }
                        curVer[key] = new TypeTreeItem(key, type.m_Type);
                    }
                }
                else
                {
                    var items = new SortedDictionary<int, TypeTreeItem>();
                    foreach (var type in assetsFile.m_Types.Where(x => x.m_Type != null))
                    {
                        var key = type.classID;
                        if (type.m_ScriptTypeIndex >= 0)
                        {
                            key = -1 - type.m_ScriptTypeIndex;
                        }
                        items[key] = new TypeTreeItem(key, type.m_Type);
                    }
                    typeMap.Add(assetsFile.unityVersion, items);
                }
            }

            return typeMap;
        }

        public static void ExportAssets(string savePath, List<AssetItem> toExportAssets, ExportType exportType)
        {
            ThreadPool.QueueUserWorkItem(state =>
            {
                Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");

                int toExportCount = toExportAssets.Count;
                int exportedCount = 0;
                int i = 0;
                Progress.Reset();
                foreach (var asset in toExportAssets)
                {
                    string exportPath;
                    switch (Properties.Settings.Default.assetGroupOption)
                    {
                        case 0: //type name
                            exportPath = Path.Combine(savePath, asset.TypeString);
                            break;
                        case 1: //container path
                            if (!string.IsNullOrEmpty(asset.Container))
                            {
                                exportPath = Path.Combine(savePath, Path.GetDirectoryName(asset.Container));
                            }
                            else
                            {
                                exportPath = savePath;
                            }
                            break;
                        case 2: //source file
                            if (string.IsNullOrEmpty(asset.SourceFile.originalPath))
                            {
                                exportPath = Path.Combine(savePath, asset.SourceFile.fileName + "_export");
                            }
                            else
                            {
                                exportPath = Path.Combine(savePath, Path.GetFileName(asset.SourceFile.originalPath) + "_export", asset.SourceFile.fileName);
                            }
                            break;
                        default:
                            exportPath = savePath;
                            break;
                    }
                    exportPath += Path.DirectorySeparatorChar;
                    StatusStripUpdate($"[{exportedCount}/{toExportCount}] Exporting {asset.TypeString}: {asset.Text}");
                    try
                    {
                        switch (exportType)
                        {
                            case ExportType.Raw:
                                if (ExportRawFile(asset, exportPath))
                                {
                                    exportedCount++;
                                }
                                break;
                            case ExportType.Dump:
                                if (ExportDumpFile(asset, exportPath))
                                {
                                    exportedCount++;
                                }
                                break;
                            case ExportType.Convert:
                                if (ExportConvertFile(asset, exportPath))
                                {
                                    exportedCount++;
                                }
                                break;
                        }
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show($"Export {asset.Type}:{asset.Text} error\r\n{ex.Message}\r\n{ex.StackTrace}");
                    }

                    Progress.Report(++i, toExportCount);
                }

                var statusText = exportedCount == 0 ? "Nothing exported." : $"Finished exporting {exportedCount} assets.";

                if (toExportCount > exportedCount)
                {
                    statusText += $" {toExportCount - exportedCount} assets skipped (not extractable or files already exist)";
                }

                StatusStripUpdate(statusText);

                if (Properties.Settings.Default.openAfterExport && exportedCount > 0)
                {
                    OpenFolderInExplorer(savePath);
                }
            });
        }

        public static void ExportAssetsList(string savePath, List<AssetItem> toExportAssets, ExportListType exportListType)
        {
            ThreadPool.QueueUserWorkItem(state =>
            {
                Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");

                Progress.Reset();

                switch (exportListType)
                {
                    case ExportListType.XML:
                        var filename = Path.Combine(savePath, "assets.xml");
                        var doc = new XDocument(
                            new XElement("Assets",
                                new XAttribute("filename", filename),
                                new XAttribute("createdAt", DateTime.UtcNow.ToString("s")),
                                toExportAssets.Select(
                                    asset => new XElement("Asset",
                                        new XElement("Name", asset.Text),
                                        new XElement("Container", asset.Container),
                                        new XElement("Type", new XAttribute("id", (int)asset.Type), asset.TypeString),
                                        new XElement("PathID", asset.m_PathID),
                                        new XElement("Source", asset.SourceFile.fullName),
                                        new XElement("Size", asset.FullSize)
                                    )
                                )
                            )
                        );

                        doc.Save(filename);

                        break;
                }

                var statusText = $"Finished exporting asset list with {toExportAssets.Count()} items.";

                StatusStripUpdate(statusText);

                if (Properties.Settings.Default.openAfterExport && toExportAssets.Count() > 0)
                {
                    OpenFolderInExplorer(savePath);
                }
            });
        }

        public static void ExportSplitObjects(string savePath, TreeNodeCollection nodes)
        {
            ThreadPool.QueueUserWorkItem(state =>
            {
                var count = nodes.Cast<TreeNode>().Sum(x => x.Nodes.Count);
                int k = 0;
                Progress.Reset();
                foreach (TreeNode node in nodes)
                {
                    //遍历一级子节点
                    foreach (GameObjectTreeNode j in node.Nodes)
                    {
                        //收集所有子节点
                        var gameObjects = new List<GameObject>();
                        CollectNode(j, gameObjects);
                        //跳过一些不需要导出的object
                        if (gameObjects.All(x => x.m_SkinnedMeshRenderer == null && x.m_MeshFilter == null))
                        {
                            Progress.Report(++k, count);
                            continue;
                        }
                        //处理非法文件名
                        var filename = FixFileName(j.Text);
                        //每个文件存放在单独的文件夹
                        var targetPath = $"{savePath}{filename}{Path.DirectorySeparatorChar}";
                        //重名文件处理
                        for (int i = 1; ; i++)
                        {
                            if (Directory.Exists(targetPath))
                            {
                                targetPath = $"{savePath}{filename} ({i}){Path.DirectorySeparatorChar}";
                            }
                            else
                            {
                                break;
                            }
                        }
                        Directory.CreateDirectory(targetPath);
                        //导出FBX
                        StatusStripUpdate($"Exporting {filename}.fbx");
                        try
                        {
                            ExportGameObject(j.gameObject, targetPath);
                        }
                        catch (Exception ex)
                        {
                            MessageBox.Show($"Export GameObject:{j.Text} error\r\n{ex.Message}\r\n{ex.StackTrace}");
                        }

                        Progress.Report(++k, count);
                        StatusStripUpdate($"Finished exporting {filename}.fbx");
                    }
                }
                if (Properties.Settings.Default.openAfterExport)
                {
                    OpenFolderInExplorer(savePath);
                }
                StatusStripUpdate("Finished");
            });
        }

        private static void CollectNode(GameObjectTreeNode node, List<GameObject> gameObjects)
        {
            gameObjects.Add(node.gameObject);
            foreach (GameObjectTreeNode i in node.Nodes)
            {
                CollectNode(i, gameObjects);
            }
        }

        public static void ExportAnimatorWithAnimationClip(AssetItem animator, List<AssetItem> animationList, string exportPath)
        {
            ThreadPool.QueueUserWorkItem(state =>
            {
                Progress.Reset();
                StatusStripUpdate($"Exporting {animator.Text}");
                try
                {
                    ExportAnimator(animator, exportPath, animationList);
                    if (Properties.Settings.Default.openAfterExport)
                    {
                        OpenFolderInExplorer(exportPath);
                    }
                    Progress.Report(1, 1);
                    StatusStripUpdate($"Finished exporting {animator.Text}");
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Export Animator:{animator.Text} error\r\n{ex.Message}\r\n{ex.StackTrace}");
                    StatusStripUpdate("Error in export");
                }
            });
        }

        public static void ExportObjectsWithAnimationClip(string exportPath, TreeNodeCollection nodes, List<AssetItem> animationList = null)
        {
            ThreadPool.QueueUserWorkItem(state =>
            {
                var gameObjects = new List<GameObject>();
                GetSelectedParentNode(nodes, gameObjects);
                if (gameObjects.Count > 0)
                {
                    var count = gameObjects.Count;
                    int i = 0;
                    Progress.Reset();
                    foreach (var gameObject in gameObjects)
                    {
                        StatusStripUpdate($"Exporting {gameObject.m_Name}");
                        try
                        {
                            ExportGameObject(gameObject, exportPath, animationList);
                            StatusStripUpdate($"Finished exporting {gameObject.m_Name}");
                        }
                        catch (Exception ex)
                        {
                            MessageBox.Show($"Export GameObject:{gameObject.m_Name} error\r\n{ex.Message}\r\n{ex.StackTrace}");
                            StatusStripUpdate("Error in export");
                        }

                        Progress.Report(++i, count);
                    }
                    if (Properties.Settings.Default.openAfterExport)
                    {
                        OpenFolderInExplorer(exportPath);
                    }
                }
                else
                {
                    StatusStripUpdate("No Object selected for export.");
                }
            });
        }

        public static void ExportObjectsMergeWithAnimationClip(string exportPath, List<GameObject> gameObjects, List<AssetItem> animationList = null)
        {
            ThreadPool.QueueUserWorkItem(state =>
            {
                var name = Path.GetFileName(exportPath);
                Progress.Reset();
                StatusStripUpdate($"Exporting {name}");
                try
                {
                    ExportGameObjectMerge(gameObjects, exportPath, animationList);
                    Progress.Report(1, 1);
                    StatusStripUpdate($"Finished exporting {name}");
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Export Model:{name} error\r\n{ex.Message}\r\n{ex.StackTrace}");
                    StatusStripUpdate("Error in export");
                }
                if (Properties.Settings.Default.openAfterExport)
                {
                    OpenFolderInExplorer(Path.GetDirectoryName(exportPath));
                }
            });
        }

        public static void GetSelectedParentNode(TreeNodeCollection nodes, List<GameObject> gameObjects)
        {
            foreach (TreeNode i in nodes)
            {
                if (i is GameObjectTreeNode gameObjectTreeNode && i.Checked)
                {
                    gameObjects.Add(gameObjectTreeNode.gameObject);
                }
                else
                {
                    GetSelectedParentNode(i.Nodes, gameObjects);
                }
            }
        }

        public static TypeTree MonoBehaviourToTypeTree(MonoBehaviour m_MonoBehaviour)
        {
            if (!assemblyLoader.Loaded)
            {
                var openFolderDialog = new OpenFolderDialog();
                openFolderDialog.Title = "Select Assembly Folder";
                if (openFolderDialog.ShowDialog() == DialogResult.OK)
                {
                    assemblyLoader.Load(openFolderDialog.Folder);
                }
                else
                {
                    assemblyLoader.Loaded = true;
                }
            }
            return m_MonoBehaviour.ConvertToTypeTree(assemblyLoader);
        }

        public static string DumpAsset(Object obj)
        {
            var str = obj.Dump();
            if (str == null && obj is MonoBehaviour m_MonoBehaviour)
            {
                var type = MonoBehaviourToTypeTree(m_MonoBehaviour);
                str = m_MonoBehaviour.Dump(type);
            }
            return str;
        }

        public static void OpenFolderInExplorer(string path)
        {
            var info = new ProcessStartInfo(path);
            info.UseShellExecute = true;
            Process.Start(info);
        }
    }
}

```

`AssetStudioUtility/AssemblyLoader.cs`:

```cs
using Mono.Cecil;
using System.Collections.Generic;
using System.IO;

namespace AssetStudio
{
    public class AssemblyLoader
    {
        public bool Loaded;
        private Dictionary<string, ModuleDefinition> moduleDic = new Dictionary<string, ModuleDefinition>();

        public void Load(string path)
        {
            var files = Directory.GetFiles(path, "*.dll");
            var resolver = new MyAssemblyResolver();
            var readerParameters = new ReaderParameters();
            readerParameters.AssemblyResolver = resolver;
            foreach (var file in files)
            {
                try
                {
                    var assembly = AssemblyDefinition.ReadAssembly(file, readerParameters);
                    resolver.Register(assembly);
                    moduleDic.Add(assembly.MainModule.Name, assembly.MainModule);
                }
                catch
                {
                    // ignored
                }
            }
            Loaded = true;
        }

        public TypeDefinition GetTypeDefinition(string assemblyName, string fullName)
        {
            if (moduleDic.TryGetValue(assemblyName, out var module))
            {
                var typeDef = module.GetType(fullName);
                if (typeDef == null && assemblyName == "UnityEngine.dll")
                {
                    foreach (var pair in moduleDic)
                    {
                        typeDef = pair.Value.GetType(fullName);
                        if (typeDef != null)
                        {
                            break;
                        }
                    }
                }
                return typeDef;
            }
            return null;
        }

        public void Clear()
        {
            foreach (var pair in moduleDic)
            {
                pair.Value.Dispose();
            }
            moduleDic.Clear();
            Loaded = false;
        }
    }
}

```

`AssetStudioUtility/AssetStudioUtility.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net472;netstandard2.0;net5.0;net6.0</TargetFrameworks>
    <Version>0.16.0.0</Version>
    <AssemblyVersion>0.16.0.0</AssemblyVersion>
    <FileVersion>0.16.0.0</FileVersion>
    <Copyright>Copyright © Perfare 2018-2022</Copyright>
    <DebugType>embedded</DebugType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Mono.Cecil" Version="0.11.3" />
    <PackageReference Include="SixLabors.ImageSharp.Drawing" Version="1.0.0-beta13" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AssetStudio.PInvoke\AssetStudio.PInvoke.csproj" />
    <ProjectReference Include="..\AssetStudioFBXWrapper\AssetStudioFBXWrapper.csproj" />
    <ProjectReference Include="..\AssetStudio\AssetStudio.csproj" />
    <ProjectReference Include="..\Texture2DDecoderWrapper\Texture2DDecoderWrapper.csproj" />
  </ItemGroup>

</Project>

```

`AssetStudioUtility/AudioClipConverter.cs`:

```cs
using FMOD;
using System;
using System.Runtime.InteropServices;
using System.Text;

namespace AssetStudio
{
    public class AudioClipConverter
    {
        private AudioClip m_AudioClip;

        public AudioClipConverter(AudioClip audioClip)
        {
            m_AudioClip = audioClip;
        }

        public byte[] ConvertToWav()
        {
            var m_AudioData = m_AudioClip.m_AudioData.GetData();
            if (m_AudioData == null || m_AudioData.Length == 0)
                return null;
            var exinfo = new CREATESOUNDEXINFO();
            var result = Factory.System_Create(out var system);
            if (result != RESULT.OK)
                return null;
            result = system.init(1, INITFLAGS.NORMAL, IntPtr.Zero);
            if (result != RESULT.OK)
                return null;
            exinfo.cbsize = Marshal.SizeOf(exinfo);
            exinfo.length = (uint)m_AudioClip.m_Size;
            result = system.createSound(m_AudioData, MODE.OPENMEMORY, ref exinfo, out var sound);
            if (result != RESULT.OK)
                return null;
            result = sound.getNumSubSounds(out var numsubsounds);
            if (result != RESULT.OK)
                return null;
            byte[] buff;
            if (numsubsounds > 0)
            {
                result = sound.getSubSound(0, out var subsound);
                if (result != RESULT.OK)
                    return null;
                buff = SoundToWav(subsound);
                subsound.release();
            }
            else
            {
                buff = SoundToWav(sound);
            }
            sound.release();
            system.release();
            return buff;
        }

        public byte[] SoundToWav(Sound sound)
        {
            var result = sound.getFormat(out _, out _, out int channels, out int bits);
            if (result != RESULT.OK)
                return null;
            result = sound.getDefaults(out var frequency, out _);
            if (result != RESULT.OK)
                return null;
            var sampleRate = (int)frequency;
            result = sound.getLength(out var length, TIMEUNIT.PCMBYTES);
            if (result != RESULT.OK)
                return null;
            result = sound.@lock(0, length, out var ptr1, out var ptr2, out var len1, out var len2);
            if (result != RESULT.OK)
                return null;
            byte[] buffer = new byte[len1 + 44];
            //添加wav头
            Encoding.UTF8.GetBytes("RIFF").CopyTo(buffer, 0);
            BitConverter.GetBytes(len1 + 36).CopyTo(buffer, 4);
            Encoding.UTF8.GetBytes("WAVEfmt ").CopyTo(buffer, 8);
            BitConverter.GetBytes(16).CopyTo(buffer, 16);
            BitConverter.GetBytes((short)1).CopyTo(buffer, 20);
            BitConverter.GetBytes((short)channels).CopyTo(buffer, 22);
            BitConverter.GetBytes(sampleRate).CopyTo(buffer, 24);
            BitConverter.GetBytes(sampleRate * channels * bits / 8).CopyTo(buffer, 28);
            BitConverter.GetBytes((short)(channels * bits / 8)).CopyTo(buffer, 32);
            BitConverter.GetBytes((short)bits).CopyTo(buffer, 34);
            Encoding.UTF8.GetBytes("data").CopyTo(buffer, 36);
            BitConverter.GetBytes(len1).CopyTo(buffer, 40);
            Marshal.Copy(ptr1, buffer, 44, (int)len1);
            result = sound.unlock(ptr1, ptr2, len1, len2);
            if (result != RESULT.OK)
                return null;
            return buffer;
        }

        public string GetExtensionName()
        {
            if (m_AudioClip.version[0] < 5)
            {
                switch (m_AudioClip.m_Type)
                {
                    case FMODSoundType.ACC:
                        return ".m4a";
                    case FMODSoundType.AIFF:
                        return ".aif";
                    case FMODSoundType.IT:
                        return ".it";
                    case FMODSoundType.MOD:
                        return ".mod";
                    case FMODSoundType.MPEG:
                        return ".mp3";
                    case FMODSoundType.OGGVORBIS:
                        return ".ogg";
                    case FMODSoundType.S3M:
                        return ".s3m";
                    case FMODSoundType.WAV:
                        return ".wav";
                    case FMODSoundType.XM:
                        return ".xm";
                    case FMODSoundType.XMA:
                        return ".wav";
                    case FMODSoundType.VAG:
                        return ".vag";
                    case FMODSoundType.AUDIOQUEUE:
                        return ".fsb";
                }

            }
            else
            {
                switch (m_AudioClip.m_CompressionFormat)
                {
                    case AudioCompressionFormat.PCM:
                        return ".fsb";
                    case AudioCompressionFormat.Vorbis:
                        return ".fsb";
                    case AudioCompressionFormat.ADPCM:
                        return ".fsb";
                    case AudioCompressionFormat.MP3:
                        return ".fsb";
                    case AudioCompressionFormat.PSMVAG:
                        return ".fsb";
                    case AudioCompressionFormat.HEVAG:
                        return ".fsb";
                    case AudioCompressionFormat.XMA:
                        return ".fsb";
                    case AudioCompressionFormat.AAC:
                        return ".m4a";
                    case AudioCompressionFormat.GCADPCM:
                        return ".fsb";
                    case AudioCompressionFormat.ATRAC9:
                        return ".fsb";
                }
            }

            return ".AudioClip";
        }

        public bool IsSupport
        {
            get
            {
                if (m_AudioClip.version[0] < 5)
                {
                    switch (m_AudioClip.m_Type)
                    {
                        case FMODSoundType.AIFF:
                        case FMODSoundType.IT:
                        case FMODSoundType.MOD:
                        case FMODSoundType.S3M:
                        case FMODSoundType.XM:
                        case FMODSoundType.XMA:
                        case FMODSoundType.AUDIOQUEUE:
                            return true;
                        default:
                            return false;
                    }
                }
                else
                {
                    switch (m_AudioClip.m_CompressionFormat)
                    {
                        case AudioCompressionFormat.PCM:
                        case AudioCompressionFormat.Vorbis:
                        case AudioCompressionFormat.ADPCM:
                        case AudioCompressionFormat.MP3:
                        case AudioCompressionFormat.XMA:
                            return true;
                        default:
                            return false;
                    }
                }
            }
        }
    }
}

```

`AssetStudioUtility/CSspv/Disassembler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace SpirV
{
	public struct ModuleHeader
	{
		public Version Version { get; set; }
		public string GeneratorVendor { get; set; }
		public string GeneratorName { get; set; }
		public int GeneratorVersion { get; set; }
		public uint Bound { get; set; }
		public uint Reserved { get; set; }
	}

	[Flags]
	public enum DisassemblyOptions
	{
		None,
		ShowTypes,
		ShowNames,
		Default = ShowTypes | ShowNames
	}

	public class Disassembler
	{
		public string Disassemble (Module module)
		{
			return Disassemble(module, DisassemblyOptions.Default);
		}

		public string Disassemble(Module module, DisassemblyOptions options)
		{
			m_sb.AppendLine("; SPIR-V");
			m_sb.Append("; Version: ").Append(module.Header.Version).AppendLine();
			if (module.Header.GeneratorName == null)
			{
				m_sb.Append("; Generator: unknown; ").Append(module.Header.GeneratorVersion).AppendLine();
			}
			else
			{
				m_sb.Append("; Generator: ").Append(module.Header.GeneratorVendor).Append(' ').
					Append(module.Header.GeneratorName).Append("; ").Append(module.Header.GeneratorVersion).AppendLine();
			}
			m_sb.Append("; Bound: ").Append(module.Header.Bound).AppendLine();
			m_sb.Append("; Schema: ").Append(module.Header.Reserved).AppendLine();

			string[] lines = new string[module.Instructions.Count + 1];
			lines[0] = m_sb.ToString();
			m_sb.Clear();

			for (int i = 0; i < module.Instructions.Count; i++)
			{
				ParsedInstruction instruction = module.Instructions[i];
				PrintInstruction(m_sb, instruction, options);
				lines[i + 1] = m_sb.ToString();
				m_sb.Clear();
			}

			int longestPrefix = 0;
			for (int i = 0; i < lines.Length; i++)
			{
				string line = lines[i];
				longestPrefix = Math.Max(longestPrefix, line.IndexOf('='));
				if (longestPrefix > 50)
				{
					longestPrefix = 50;
					break;
				}
			}

			m_sb.Append(lines[0]);
			for (int i = 1; i < lines.Length; i++)
			{
				string line = lines[i];
				int index = line.IndexOf('=');
				if (index == -1)
				{
					m_sb.Append(' ', longestPrefix + 4);
					m_sb.Append(line);
				}
				else
				{
					int pad = Math.Max(0, longestPrefix - index);
					m_sb.Append(' ', pad);
					m_sb.Append(line, 0, index);
					m_sb.Append('=');
					m_sb.Append(line, index + 1, line.Length - index - 1);
				}
				m_sb.AppendLine();
			}

			string result = m_sb.ToString();
			m_sb.Clear();
			return result;
		}

		private static void PrintInstruction(StringBuilder sb, ParsedInstruction instruction, DisassemblyOptions options)
		{
			if (instruction.Operands.Count == 0)
			{
				sb.Append(instruction.Instruction.Name);
				return;
			}

			int currentOperand = 0;
			if (instruction.Instruction.Operands[currentOperand].Type is IdResultType)
			{
				if (options.HasFlag(DisassemblyOptions.ShowTypes))
				{
					instruction.ResultType.ToString(sb).Append(' ');
				}
				++currentOperand;
			}

			if (currentOperand < instruction.Operands.Count && instruction.Instruction.Operands[currentOperand].Type is IdResult)
			{
				if (!options.HasFlag(DisassemblyOptions.ShowNames) || string.IsNullOrWhiteSpace(instruction.Name))
				{
					PrintOperandValue(sb, instruction.Operands[currentOperand].Value, options);
				}
				else
				{
					sb.Append(instruction.Name);
				}
				sb.Append(" = ");

				++currentOperand;
			}

			sb.Append(instruction.Instruction.Name);
			sb.Append(' ');

			for (; currentOperand < instruction.Operands.Count; ++currentOperand)
			{
				PrintOperandValue(sb, instruction.Operands[currentOperand].Value, options);
				sb.Append(' ');
			}
		}

		private static void PrintOperandValue(StringBuilder sb, object value, DisassemblyOptions options)
		{
			switch (value)
			{
				case System.Type t:
					sb.Append(t.Name);
					break;

				case string s:
					{
						sb.Append('"');
						sb.Append(s);
						sb.Append('"');
					}
					break;

				case ObjectReference or:
					{
						if (options.HasFlag(DisassemblyOptions.ShowNames) && or.Reference != null && !string.IsNullOrWhiteSpace(or.Reference.Name))
						{
							sb.Append(or.Reference.Name);
						}
						else
						{
							or.ToString(sb);
						}
					}
					break;

				case IBitEnumOperandValue beov:
					PrintBitEnumValue(sb, beov, options);
					break;

				case IValueEnumOperandValue veov:
					PrintValueEnumValue(sb, veov, options);
					break;

				case VaryingOperandValue varOpVal:
					varOpVal.ToString(sb);
					break;

				default:
					sb.Append(value);
					break;
			}
		}

		private static void PrintBitEnumValue(StringBuilder sb, IBitEnumOperandValue enumOperandValue, DisassemblyOptions options)
		{
			foreach (uint key in enumOperandValue.Values.Keys)
			{
				sb.Append(enumOperandValue.EnumerationType.GetEnumName(key));
				IReadOnlyList<object> value = enumOperandValue.Values[key];
				if (value.Count != 0)
				{
					sb.Append(' ');
					foreach (object v in value)
					{
						PrintOperandValue(sb, v, options);
					}
				}
			}
		}

		private static void PrintValueEnumValue(StringBuilder sb, IValueEnumOperandValue valueOperandValue, DisassemblyOptions options)
		{
			sb.Append(valueOperandValue.Key);
			if (valueOperandValue.Value is IList<object> valueList && valueList.Count > 0)
			{
				sb.Append(' ');
				foreach (object v in valueList)
				{
					PrintOperandValue(sb, v, options);
				}
			}
		}

		private readonly StringBuilder m_sb = new StringBuilder();
	}
}

```

`AssetStudioUtility/CSspv/EnumValuesExtensions.cs`:

```cs
#if NETSTANDARD1_0 || NETSTANDARD1_1 || NETSTANDARD1_2 || NETSTANDARD1_3 || NETSTANDARD1_4 || NETSTANDARD1_5 || NETSTANDARD1_6
using System;
using System.Linq;
using System.Reflection;

namespace SpirV
{
	public static class EnumValuesExtensions
	{
		public static Array GetEnumValues(this System.Type _this)
		{
			TypeInfo typeInfo = _this.GetTypeInfo ();
			if (!typeInfo.IsEnum) {
				throw new ArgumentException ("GetEnumValues: Type '" + _this.Name + "' is not an enum");
			}

			return
				(
				  from field in typeInfo.DeclaredFields
				  where field.IsLiteral
				  select field.GetValue (null)
				)
				.ToArray();
		}

		public static string GetEnumName(this System.Type _this, object value)
		{
			TypeInfo typeInfo = _this.GetTypeInfo ();
			if (!typeInfo.IsEnum) {
				throw new ArgumentException ("GetEnumName: Type '" + _this.Name + "' is not an enum");
			}
			return
				(
				  from field in typeInfo.DeclaredFields
				  where field.IsLiteral && (uint)field.GetValue(null) == (uint)value
				  select field.Name
				)
				.First();
		}
	}
}
#endif
```

`AssetStudioUtility/CSspv/Instruction.cs`:

```cs
using System.Collections.Generic;

namespace SpirV
{
	public enum OperandQuantifier
	{
		/// <summary>
		/// 1
		/// </summary>
		Default,
		/// <summary>
		/// 0 or 1
		/// </summary>
		Optional,
		/// <summary>
		/// 0+
		/// </summary>
		Varying
	}

	public class Operand
	{
		public Operand(OperandType kind, string name, OperandQuantifier quantifier)
		{
			Name = name;
			Type = kind;
			Quantifier = quantifier;
		}

		public string Name { get; }
		public OperandType Type { get; }
		public OperandQuantifier Quantifier { get; }
	}

	public class Instruction
	{
		public Instruction (string name)
			: this (name, new List<Operand> ())
		{
		}

		public Instruction (string name, IReadOnlyList<Operand> operands)
		{
			Operands = operands;
			Name = name;
		}

		public string Name { get; }
		public IReadOnlyList<Operand> Operands { get; }
	}
}

```

`AssetStudioUtility/CSspv/LICENSE`:

```
BSD 2-Clause License

Copyright (c) 2017, Matthäus G. Chajdas
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`AssetStudioUtility/CSspv/Module.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;

namespace SpirV
{
	public class Module
	{
		[StructLayout(LayoutKind.Explicit)]
		private struct FloatUIntUnion
		{
			[FieldOffset(0)]
			public uint Int;
			[FieldOffset(0)]
			public float Float;
		}

		[StructLayout(LayoutKind.Explicit)]
		private struct DoubleULongUnion
		{
			[FieldOffset(0)]
			public ulong Long;
			[FieldOffset(0)]
			public double Double;
		}

		public Module(ModuleHeader header, IReadOnlyList<ParsedInstruction> instructions)
		{
			Header = header;
			Instructions = instructions;

			Read(Instructions, objects_);
		}

		public static bool IsDebugInstruction(ParsedInstruction instruction)
		{
			return debugInstructions_.Contains(instruction.Instruction.Name);
		}

		private static void Read(IReadOnlyList<ParsedInstruction> instructions, Dictionary<uint, ParsedInstruction> objects)
		{
			// Debug instructions can be only processed after everything
			// else has been parsed, as they may reference types which haven't
			// been seen in the file yet
			List<ParsedInstruction> debugInstructions = new List<ParsedInstruction>();
			// Entry points contain forward references
			// Those need to be resolved afterwards
			List<ParsedInstruction> entryPoints = new List<ParsedInstruction>();
			
			foreach (var instruction in instructions)
			{
				if (IsDebugInstruction(instruction))
				{
					debugInstructions.Add(instruction);
					continue;
				}
				if (instruction.Instruction is OpEntryPoint)
				{
					entryPoints.Add(instruction);
					continue;
				}

				if (instruction.Instruction.Name.StartsWith("OpType", StringComparison.Ordinal))
				{
					ProcessTypeInstruction(instruction, objects);
				}

				instruction.ResolveResultType(objects);
				if (instruction.HasResult)
				{
					objects[instruction.ResultId] = instruction;
				}

				switch (instruction.Instruction)
				{
					// Constants require that the result type has been resolved
					case OpSpecConstant sc:
					case OpConstant oc:
						{
							Type t = instruction.ResultType;
							Debug.Assert (t != null);
							Debug.Assert (t is ScalarType);
							
							object constant = ConvertConstant(instruction.ResultType as ScalarType, instruction.Words, 3);
							instruction.Operands[2].Value = constant;
							instruction.Value = constant;
						}
						break;
				}
			}

			foreach (ParsedInstruction instruction in debugInstructions)
			{
				switch (instruction.Instruction)
				{
					case OpMemberName mn:
						{
							StructType t = (StructType)objects[instruction.Words[1]].ResultType;
							t.SetMemberName((uint)instruction.Operands[1].Value, (string)instruction.Operands[2].Value);
						}
						break;

					case OpName n:
						{
							// We skip naming objects we don't know about
							ParsedInstruction t = objects[instruction.Words[1]];
							t.Name = (string)instruction.Operands[1].Value;
						}
						break;
				}
			}

			foreach (ParsedInstruction instruction in instructions)
			{
				instruction.ResolveReferences(objects);
			}
		}

		public static Module ReadFrom(Stream stream)
		{
			BinaryReader br = new BinaryReader(stream);
			Reader reader = new Reader(br);

			uint versionNumber = reader.ReadDWord();
			int majorVersion = (int)(versionNumber >> 16);
			int minorVersion = (int)((versionNumber >> 8) & 0xFF);
			Version version = new Version(majorVersion, minorVersion);

			uint generatorMagicNumber = reader.ReadDWord();
			int generatorToolId = (int)(generatorMagicNumber >> 16);
			string generatorVendor = "unknown";
			string generatorName = null;

			if (Meta.Tools.ContainsKey(generatorToolId))
			{
				Meta.ToolInfo toolInfo = Meta.Tools[generatorToolId];
				generatorVendor = toolInfo.Vendor;
				if (toolInfo.Name != null)
				{
					generatorName = toolInfo.Name;
				}
			}

			// Read header
			ModuleHeader header = new ModuleHeader();
			header.Version = version;
			header.GeneratorName = generatorName;
			header.GeneratorVendor = generatorVendor;
			header.GeneratorVersion = (int)(generatorMagicNumber & 0xFFFF);
			header.Bound = reader.ReadDWord();
			header.Reserved = reader.ReadDWord();

			List<ParsedInstruction> instructions = new List<ParsedInstruction>();
			while (!reader.EndOfStream)
			{
				uint instructionStart = reader.ReadDWord ();
				ushort wordCount = (ushort)(instructionStart >> 16);
				int opCode = (int)(instructionStart & 0xFFFF);

				uint[] words = new uint[wordCount];
				words[0] = instructionStart;
				for (ushort i = 1; i < wordCount; ++i)
				{
					words[i] = reader.ReadDWord();
				}

				ParsedInstruction instruction = new ParsedInstruction(opCode, words);
				instructions.Add(instruction);
			}

			return new Module(header, instructions);
		}

		/// <summary>
		/// Collect types from OpType* instructions
		/// </summary>
		private static void ProcessTypeInstruction(ParsedInstruction i, IReadOnlyDictionary<uint, ParsedInstruction> objects)
		{
			switch (i.Instruction)
			{
				case OpTypeInt t:
					{
						i.ResultType = new IntegerType((int)i.Words[2], i.Words[3] == 1u);
					}
					break;

				case OpTypeFloat t:
					{
						i.ResultType = new FloatingPointType((int)i.Words[2]);
					}
					break;

				case OpTypeVector t:
					{
						i.ResultType = new VectorType((ScalarType)objects[i.Words[2]].ResultType, (int)i.Words[3]);
					}
					break;

				case OpTypeMatrix t:
					{
						i.ResultType = new MatrixType((VectorType)objects[i.Words[2]].ResultType, (int)i.Words[3]);
					}
					break;

				case OpTypeArray t:
					{
						object constant = objects[i.Words[3]].Value;
						int size = 0;

						switch (constant)
						{
							case ushort u16:
								size = u16;
								break;

							case uint u32:
								size = (int)u32;
								break;

							case ulong u64:
								size = (int)u64;
								break;

							case short i16:
								size = i16;
								break;

							case int i32:
								size = i32;
								break;

							case long i64:
								size = (int)i64;
								break;
						}

						i.ResultType = new ArrayType(objects[i.Words[2]].ResultType, size);
					}
					break;

				case OpTypeRuntimeArray t:
					{
						i.ResultType = new RuntimeArrayType((Type)objects[i.Words[2]].ResultType);
					}
					break;

				case OpTypeBool t:
					{
						i.ResultType = new BoolType();
					}
					break;

				case OpTypeOpaque t:
					{
						i.ResultType = new OpaqueType();
					}
					break;

				case OpTypeVoid t:
					{
						i.ResultType = new VoidType();
					}
					break;

				case OpTypeImage t:
					{
						Type sampledType = objects[i.Operands[1].GetId ()].ResultType;
						Dim dim = i.Operands[2].GetSingleEnumValue<Dim>();
						uint depth = (uint)i.Operands[3].Value;
						bool isArray = (uint)i.Operands[4].Value != 0;
						bool isMultiSampled = (uint)i.Operands[5].Value != 0;
						uint sampled = (uint)i.Operands[6].Value;
						ImageFormat imageFormat = i.Operands[7].GetSingleEnumValue<ImageFormat>();

						i.ResultType = new ImageType(sampledType,
							dim,
							(int)depth, isArray, isMultiSampled,
							(int)sampled, imageFormat,
							i.Operands.Count > 8 ? i.Operands[8].GetSingleEnumValue<AccessQualifier>() : AccessQualifier.ReadOnly);
					}
					break;

				case OpTypeSampler st:
					{
						i.ResultType = new SamplerType();
						break;
					}

				case OpTypeSampledImage t:
					{
						i.ResultType = new SampledImageType((ImageType)objects[i.Words[2]].ResultType);
					}
					break;

				case OpTypeFunction t:
					{
						List<Type> parameterTypes = new List<Type>();
						for (int j = 3; j < i.Words.Count; ++j)
						{
							parameterTypes.Add(objects[i.Words[j]].ResultType);
						}
						i.ResultType = new FunctionType(objects[i.Words[2]].ResultType, parameterTypes);
					}
					break;

				case OpTypeForwardPointer t:
					{
						// We create a normal pointer, but with unspecified type
						// This will get resolved later on
						i.ResultType = new PointerType((StorageClass)i.Words[2]);
					}
					break;

				case OpTypePointer t:
					{
						if (objects.ContainsKey(i.Words[1]))
						{
							// If there is something present, it must have been
							// a forward reference. The storage type must
							// match
							PointerType pt = (PointerType)i.ResultType;
							Debug.Assert (pt != null);
							Debug.Assert (pt.StorageClass == (StorageClass)i.Words[2]);
							pt.ResolveForwardReference (objects[i.Words[3]].ResultType);
						}
						else
						{
							i.ResultType = new PointerType((StorageClass)i.Words[2], objects[i.Words[3]].ResultType);
						}
					}
					break;

				case OpTypeStruct t:
					{
						List<Type> memberTypes = new List<Type>();
						for (int j = 2; j < i.Words.Count; ++j)
						{
							memberTypes.Add(objects[i.Words[j]].ResultType);
						}
						i.ResultType = new StructType(memberTypes);
					}
					break;
			}
		}

		private static object ConvertConstant(ScalarType type, IReadOnlyList<uint> words, int index)
		{
			switch (type)
			{
				case IntegerType i:
					{
						if (i.Signed)
						{
							if (i.Width == 16)
							{
								return unchecked((short)(words[index]));
							}
							else if (i.Width == 32)
							{
								return unchecked((int)(words[index]));
							}
							else if (i.Width == 64)
							{
								return unchecked((long)(words[index] | (ulong)(words[index + 1]) << 32));
							}
						}
						else
						{
							if (i.Width == 16)
							{
								return unchecked((ushort)(words[index]));
							}
							else if (i.Width == 32)
							{
								return words[index];
							}
							else if (i.Width == 64)
							{
								return words[index] | (ulong)(words[index + 1]) << 32;
							}
						}

						throw new Exception ("Cannot construct integer literal.");
					}

				case FloatingPointType f:
					{
						if (f.Width == 32)
						{
							return new FloatUIntUnion { Int = words[0] }.Float;
						}
						else if (f.Width == 64)
						{
							return new DoubleULongUnion { Long = (words[index] | (ulong)(words[index + 1]) << 32) }.Double;
						}
						else
						{
							throw new Exception("Cannot construct floating point literal.");
						}
					}
			}

			return null;
		}

		public ModuleHeader Header { get; }
		public IReadOnlyList<ParsedInstruction> Instructions { get; }

		private static HashSet<string> debugInstructions_ = new HashSet<string>
		{
			"OpSourceContinued",
			"OpSource",
			"OpSourceExtension",
			"OpName",
			"OpMemberName",
			"OpString",
			"OpLine",
			"OpNoLine",
			"OpModuleProcessed"
		};

		private readonly Dictionary<uint, ParsedInstruction> objects_ = new Dictionary<uint, ParsedInstruction>();
	}
}

```

`AssetStudioUtility/CSspv/OperandType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using System.Reflection;

namespace SpirV
{
	public class OperandType
	{
		public virtual bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			// This returns the dynamic type
			value = GetType();
			wordsUsed = 1;
			return true;
		}
	}

	public class Literal : OperandType
	{
	}

	public class LiteralNumber : Literal
	{
	}

	// The SPIR-V JSON file uses only literal integers
	public class LiteralInteger : LiteralNumber
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = words[index];
			wordsUsed = 1;
			return true;
		}
	}

	public class LiteralString : Literal
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			// This is just a fail-safe -- the loop below must terminate
			wordsUsed = 1;
			int bytesUsed = 0;
			byte[] bytes = new byte[(words.Count - index) * 4];
			for (int i = index; i < words.Count; ++i)
			{
				uint word = words[i];
				byte b0 = (byte)(word & 0xFF);
				if (b0 == 0)
				{
					break;
				}
				else
				{
					bytes[bytesUsed++] = b0;
				}

				byte b1 = (byte)((word >> 8) & 0xFF);
				if (b1 == 0)
				{
					break;
				}
				else
				{
					bytes[bytesUsed++] = b1;
				}

				byte b2 = (byte)((word >> 16) & 0xFF);
				if (b2 == 0)
				{
					break;
				}
				else
				{
					bytes[bytesUsed++] = b2;
				}

				byte b3 = (byte)(word >> 24);
				if (b3 == 0)
				{
					break;
				}
				else
				{
					bytes[bytesUsed++] = b3;
				}
				wordsUsed++;
			}

			value = Encoding.UTF8.GetString(bytes, 0, bytesUsed);
			return true;
		}
	}

	public class LiteralContextDependentNumber : Literal
	{
		// This is handled during parsing by ConvertConstant
	}

	public class LiteralExtInstInteger : Literal
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = words[index];
			wordsUsed = 1;
			return true;
		}
	}

	public class LiteralSpecConstantOpInteger : Literal
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			List<ObjectReference> result = new List<ObjectReference>();
			for (int i = index; i < words.Count; i++)
			{
				ObjectReference objRef = new ObjectReference(words[i]);
				result.Add(objRef);
			}

			value = result;
			wordsUsed = words.Count - index;
			return true;
		}
	}

	public class Parameter
	{
		public virtual IReadOnlyList<OperandType> OperandTypes { get; }
	}

	public class ParameterFactory
	{
		public virtual Parameter CreateParameter(object value)
		{
			return null;
		}
	}

	public class EnumType<T> : EnumType<T, ParameterFactory>
		where T : Enum
	{
	};

	public class EnumType<T, U> : OperandType
		where T : Enum
		where U : ParameterFactory, new ()
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			int wordsUsedForParameters = 0;
			if (typeof(T).GetTypeInfo().GetCustomAttributes<FlagsAttribute>().Any())
			{
				Dictionary<uint, IReadOnlyList<object>> result = new Dictionary<uint, IReadOnlyList<object>>();
				foreach (object enumValue in EnumerationType.GetEnumValues())
				{
					uint bit = (uint)enumValue;
					// bit == 0 and words[0] == 0 handles the 0x0 = None cases
					if ((words[index] & bit) != 0 || (bit == 0 && words[index] == 0))
					{
						Parameter p = parameterFactory_.CreateParameter(bit);
						if (p == null)
						{
							result.Add(bit, Array.Empty<object>());
						}
						else
						{
							object[] resultItems = new object[p.OperandTypes.Count];
							for (int j = 0; j < p.OperandTypes.Count; ++j)
							{
								p.OperandTypes[j].ReadValue(words, 1 + wordsUsedForParameters, out object pValue, out int pWordsUsed);
								wordsUsedForParameters += pWordsUsed;
								resultItems[j] = pValue;
							}
							result.Add(bit, resultItems);
						}
					}
				}
				value = new BitEnumOperandValue<T>(result);
			}
			else
			{
				object[] resultItems;
				Parameter p = parameterFactory_.CreateParameter(words[index]);
				if (p == null)
				{
					resultItems = Array.Empty<object>();
				}
				else
				{
					resultItems = new object[p.OperandTypes.Count];
					for (int j = 0; j < p.OperandTypes.Count; ++j)
					{
						p.OperandTypes[j].ReadValue(words, 1 + wordsUsedForParameters, out object pValue, out int pWordsUsed);
						wordsUsedForParameters += pWordsUsed;
						resultItems[j] = pValue;
					}
				}
				value = new ValueEnumOperandValue<T>((T)(object)words[index], resultItems);
			}

			wordsUsed = wordsUsedForParameters + 1;
			return true;
		}

		public System.Type EnumerationType => typeof(T);

		private U parameterFactory_ = new U();
	}

	public class IdScope : OperandType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = (Scope)words[index];
			wordsUsed = 1;
			return true;
		}
	}

	public class IdMemorySemantics : OperandType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = (MemorySemantics)words[index];
			wordsUsed = 1;
			return true;
		}
	}

	public class IdType : OperandType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = words[index];
			wordsUsed = 1;
			return true;
		}
	}

	public class IdResult : IdType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = new ObjectReference(words[index]);
			wordsUsed = 1;
			return true;
		}
	}

	public class IdResultType : IdType
	{
	}

	public class IdRef : IdType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = new ObjectReference(words[index]);
			wordsUsed = 1;
			return true;
		}
	}

	public class PairIdRefIdRef : OperandType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			ObjectReference variable = new ObjectReference(words[index]);
			ObjectReference parent = new ObjectReference(words[index + 1]);
			value = new { Variable = variable, Parent = parent };
			wordsUsed = 2;
			return true;
		}
	}

	public class PairIdRefLiteralInteger : OperandType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			ObjectReference type = new ObjectReference(words[index]);
			uint word = words[index + 1];
			value = new { Type = type, Member = word };
			wordsUsed = 2;
			return true;
		}
	}

	public class PairLiteralIntegerIdRef : OperandType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			uint selector = words[index];
			ObjectReference label = new ObjectReference(words[index + 1]);
			value = new { Selector = selector, Label = label };
			wordsUsed = 2;
			return true;
		}
	}
}
```

`AssetStudioUtility/CSspv/ParsedInstruction.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace SpirV
{
	public class ParsedOperand
	{
		public ParsedOperand(IReadOnlyList<uint> words, int index, int count, object value, Operand operand)
		{
			uint[] array = new uint[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = words[index + i];
			}

			Words = array;
			Value = value;
			Operand = operand;
		}

		public T GetSingleEnumValue<T>()
			where T : Enum
		{
			IValueEnumOperandValue v = (IValueEnumOperandValue)Value;
			if (v.Value.Count == 0)
			{
				// If there's no value at all, the enum is probably something like ImageFormat.
				// In which case we just return the enum value
				return (T)v.Key;
			}
			else
			{
				// This means the enum has a value attached to it, so we return the attached value
				return (T)((IValueEnumOperandValue)Value).Value[0];
			}
		}

		public uint GetId()
		{
			return ((ObjectReference)Value).Id;
		}

		public T GetBitEnumValue<T>()
			where T : Enum
		{
			var v = Value as IBitEnumOperandValue;

			uint result = 0;
			foreach (var k in v.Values.Keys)
			{
				result |= k;
			}

			return (T)(object)result;
		}

		public IReadOnlyList<uint> Words { get; }
		public object Value { get; set; }
		public Operand Operand { get; }
	}

	public class VaryingOperandValue
	{
		public VaryingOperandValue(IReadOnlyList<object> values)
		{
			Values = values;
		}

		public override string ToString()
		{
			StringBuilder sb = new StringBuilder();
			ToString(sb);
			return sb.ToString();
		}

		public StringBuilder ToString(StringBuilder sb)
		{
			for (int i = 0; i < Values.Count; ++i)
			{
				if (Values[i] is ObjectReference objRef)
				{
					objRef.ToString(sb);
				}
				else
				{
					sb.Append(Values[i]);
				}
				if (i < (Values.Count - 1))
				{
					sb.Append(' ');
				}
			}
			return sb;
		}

		public IReadOnlyList<object> Values { get; }
	}

	public interface IEnumOperandValue
	{
		System.Type EnumerationType { get; }
	}

	public interface IBitEnumOperandValue : IEnumOperandValue
	{
		IReadOnlyDictionary<uint, IReadOnlyList<object>> Values { get; }
	}

	public interface IValueEnumOperandValue : IEnumOperandValue
	{
		object Key { get; }
		IReadOnlyList<object> Value { get; }
	}

	public class ValueEnumOperandValue<T> : IValueEnumOperandValue
		where T : Enum
	{
		public ValueEnumOperandValue(T key, IReadOnlyList<object> value)
		{
			Key = key;
			Value = value;
		}

		public System.Type EnumerationType => typeof(T);
		public object Key { get; }
		public IReadOnlyList<object> Value { get; }
	}

	public class BitEnumOperandValue<T> : IBitEnumOperandValue
		where T : Enum
	{
		public BitEnumOperandValue(Dictionary<uint, IReadOnlyList<object>> values)
		{
			Values = values;
		}

		public IReadOnlyDictionary<uint, IReadOnlyList<object>> Values { get; }
		public System.Type EnumerationType => typeof(T);
	}

	public class ObjectReference
	{
		public ObjectReference(uint id)
		{
			Id = id;
		}

		public void Resolve(IReadOnlyDictionary<uint, ParsedInstruction> objects)
		{
			Reference = objects[Id];
		}

		public override string ToString()
		{
			return $"%{Id}";
		}

		public StringBuilder ToString(StringBuilder sb)
		{
			return sb.Append('%').Append(Id);
		}

		public uint Id { get; }
		public ParsedInstruction Reference { get; private set; }
	}

	public class ParsedInstruction
	{
		public ParsedInstruction(int opCode, IReadOnlyList<uint> words)
		{
			Words = words;
			Instruction = Instructions.OpcodeToInstruction[opCode];
			ParseOperands();
		}

		private void ParseOperands()
		{
			if (Instruction.Operands.Count == 0)
			{
				return;
			}

			// Word 0 describes this instruction so we can ignore it
			int currentWord = 1;
			int currentOperand = 0;
			List<object> varyingOperandValues = new List<object>();
			int varyingWordStart = 0;
			Operand varyingOperand = null;

			while (currentWord < Words.Count)
			{
				Operand operand = Instruction.Operands[currentOperand];
				operand.Type.ReadValue(Words, currentWord, out object value, out int wordsUsed);
				if (operand.Quantifier == OperandQuantifier.Varying)
				{
					varyingOperandValues.Add(value);
					varyingWordStart = currentWord;
					varyingOperand = operand;
				}
				else
				{
					int wordCount = Math.Min(Words.Count - currentWord, wordsUsed);
					ParsedOperand parsedOperand = new ParsedOperand(Words, currentWord, wordCount, value, operand);
					Operands.Add(parsedOperand);
				}

				currentWord += wordsUsed;
				if (operand.Quantifier != OperandQuantifier.Varying)
				{
					++currentOperand;
				}
			}

			if (varyingOperand != null)
			{
				VaryingOperandValue varOperantValue = new VaryingOperandValue(varyingOperandValues);
				ParsedOperand parsedOperand = new ParsedOperand(Words, currentWord, Words.Count - currentWord, varOperantValue, varyingOperand);
				Operands.Add(parsedOperand);
			}
		}

		public void ResolveResultType(IReadOnlyDictionary<uint, ParsedInstruction> objects)
		{
			if (Instruction.Operands.Count > 0 && Instruction.Operands[0].Type is IdResultType)
			{
				ResultType = objects[(uint)Operands[0].Value].ResultType;
			}
		}

		public void ResolveReferences (IReadOnlyDictionary<uint, ParsedInstruction> objects)
		{
			foreach (var operand in Operands)
			{
				if (operand.Value is ObjectReference objectReference)
				{
					objectReference.Resolve (objects);
				}
			}
		}

		public Type ResultType { get; set; }
		public uint ResultId
		{
			get
			{
				for (int i = 0; i < Instruction.Operands.Count; ++i)
				{
					if (Instruction.Operands[i].Type is IdResult)
					{
						return Operands[i].GetId();
					}
				}
				return 0;
			}
		}
		public bool HasResult => ResultId != 0;

		public IReadOnlyList<uint> Words { get; }
		public Instruction Instruction { get; }
		public IList<ParsedOperand> Operands { get; } = new List<ParsedOperand>();
		public string Name { get; set; }
		public object Value { get; set; }
	}
}

```

`AssetStudioUtility/CSspv/Reader.cs`:

```cs
using System;
using System.IO;
using System.Runtime.CompilerServices;

namespace SpirV
{
	internal sealed class Reader
	{
		public Reader(BinaryReader reader)
		{
			reader_ = reader;
			uint magicNumber = reader_.ReadUInt32();
			if (magicNumber == Meta.MagicNumber)
			{
				littleEndian_ = true;
			}
			else if (Reverse(magicNumber) == Meta.MagicNumber)
			{
				littleEndian_ = false;
			}
			else
			{
				throw new Exception("Invalid magic number");
			}
		}

		public uint ReadDWord()
		{
			if (littleEndian_)
			{
				return reader_.ReadUInt32 ();
			}
			else
			{
				return Reverse(reader_.ReadUInt32());
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static uint Reverse(uint u)
		{
			return (u << 24) | (u & 0xFF00U) << 8 | (u >> 8) & 0xFF00U | (u >> 24);
		}

		public bool EndOfStream => reader_.BaseStream.Position == reader_.BaseStream.Length;

		private readonly BinaryReader reader_;
		private readonly bool littleEndian_;
	}
}

```

`AssetStudioUtility/CSspv/SpirV.Core.Grammar.cs`:

```cs
using System;
using System.Collections.Generic;

namespace SpirV
{
    [Flags]
    public enum ImageOperands : uint
    {
        None = 0,
        Bias = 1,
        Lod = 2,
        Grad = 4,
        ConstOffset = 8,
        Offset = 16,
        ConstOffsets = 32,
        Sample = 64,
        MinLod = 128,
    }
    public class ImageOperandsParameterFactory : ParameterFactory
    {
        public class BiasParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new IdRef(), };
        }

        public class LodParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new IdRef(), };
        }

        public class GradParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new IdRef(), new IdRef(), };
        }

        public class ConstOffsetParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new IdRef(), };
        }

        public class OffsetParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new IdRef(), };
        }

        public class ConstOffsetsParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new IdRef(), };
        }

        public class SampleParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new IdRef(), };
        }

        public class MinLodParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new IdRef(), };
        }

        public override Parameter CreateParameter(object value)
        {
            switch ((ImageOperands)value)
            {
                case ImageOperands.Bias:
                    return new BiasParameter();
                case ImageOperands.Lod:
                    return new LodParameter();
                case ImageOperands.Grad:
                    return new GradParameter();
                case ImageOperands.ConstOffset:
                    return new ConstOffsetParameter();
                case ImageOperands.Offset:
                    return new OffsetParameter();
                case ImageOperands.ConstOffsets:
                    return new ConstOffsetsParameter();
                case ImageOperands.Sample:
                    return new SampleParameter();
                case ImageOperands.MinLod:
                    return new MinLodParameter();
            }

            return null;
        }
    }
    [Flags]
    public enum FPFastMathMode : uint
    {
        None = 0,
        NotNaN = 1,
        NotInf = 2,
        NSZ = 4,
        AllowRecip = 8,
        Fast = 16,
    }
    public class FPFastMathModeParameterFactory : ParameterFactory
    {
    }
    [Flags]
    public enum SelectionControl : uint
    {
        None = 0,
        Flatten = 1,
        DontFlatten = 2,
    }
    public class SelectionControlParameterFactory : ParameterFactory
    {
    }
    [Flags]
    public enum LoopControl : uint
    {
        None = 0,
        Unroll = 1,
        DontUnroll = 2,
        DependencyInfinite = 4,
        DependencyLength = 8,
    }
    public class LoopControlParameterFactory : ParameterFactory
    {
        public class DependencyLengthParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public override Parameter CreateParameter(object value)
        {
            switch ((LoopControl)value)
            {
                case LoopControl.DependencyLength:
                    return new DependencyLengthParameter();
            }

            return null;
        }
    }
    [Flags]
    public enum FunctionControl : uint
    {
        None = 0,
        Inline = 1,
        DontInline = 2,
        Pure = 4,
        Const = 8,
    }
    public class FunctionControlParameterFactory : ParameterFactory
    {
    }
    [Flags]
    public enum MemorySemantics : uint
    {
        Relaxed = 0,
        None = 0,
        Acquire = 2,
        Release = 4,
        AcquireRelease = 8,
        SequentiallyConsistent = 16,
        UniformMemory = 64,
        SubgroupMemory = 128,
        WorkgroupMemory = 256,
        CrossWorkgroupMemory = 512,
        AtomicCounterMemory = 1024,
        ImageMemory = 2048,
    }
    public class MemorySemanticsParameterFactory : ParameterFactory
    {
    }
    [Flags]
    public enum MemoryAccess : uint
    {
        None = 0,
        Volatile = 1,
        Aligned = 2,
        Nontemporal = 4,
    }
    public class MemoryAccessParameterFactory : ParameterFactory
    {
        public class AlignedParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public override Parameter CreateParameter(object value)
        {
            switch ((MemoryAccess)value)
            {
                case MemoryAccess.Aligned:
                    return new AlignedParameter();
            }

            return null;
        }
    }
    [Flags]
    public enum KernelProfilingInfo : uint
    {
        None = 0,
        CmdExecTime = 1,
    }
    public class KernelProfilingInfoParameterFactory : ParameterFactory
    {
    }
    public enum SourceLanguage : uint
    {
        Unknown = 0,
        ESSL = 1,
        GLSL = 2,
        OpenCL_C = 3,
        OpenCL_CPP = 4,
        HLSL = 5,
    }
    public class SourceLanguageParameterFactory : ParameterFactory
    {
    }
    public enum ExecutionModel : uint
    {
        Vertex = 0,
        TessellationControl = 1,
        TessellationEvaluation = 2,
        Geometry = 3,
        Fragment = 4,
        GLCompute = 5,
        Kernel = 6,
    }
    public class ExecutionModelParameterFactory : ParameterFactory
    {
    }
    public enum AddressingModel : uint
    {
        Logical = 0,
        Physical32 = 1,
        Physical64 = 2,
    }
    public class AddressingModelParameterFactory : ParameterFactory
    {
    }
    public enum MemoryModel : uint
    {
        Simple = 0,
        GLSL450 = 1,
        OpenCL = 2,
    }
    public class MemoryModelParameterFactory : ParameterFactory
    {
    }
    public enum ExecutionMode : uint
    {
        Invocations = 0,
        SpacingEqual = 1,
        SpacingFractionalEven = 2,
        SpacingFractionalOdd = 3,
        VertexOrderCw = 4,
        VertexOrderCcw = 5,
        PixelCenterInteger = 6,
        OriginUpperLeft = 7,
        OriginLowerLeft = 8,
        EarlyFragmentTests = 9,
        PointMode = 10,
        Xfb = 11,
        DepthReplacing = 12,
        DepthGreater = 14,
        DepthLess = 15,
        DepthUnchanged = 16,
        LocalSize = 17,
        LocalSizeHint = 18,
        InputPoints = 19,
        InputLines = 20,
        InputLinesAdjacency = 21,
        Triangles = 22,
        InputTrianglesAdjacency = 23,
        Quads = 24,
        Isolines = 25,
        OutputVertices = 26,
        OutputPoints = 27,
        OutputLineStrip = 28,
        OutputTriangleStrip = 29,
        VecTypeHint = 30,
        ContractionOff = 31,
        Initializer = 33,
        Finalizer = 34,
        SubgroupSize = 35,
        SubgroupsPerWorkgroup = 36,
        SubgroupsPerWorkgroupId = 37,
        LocalSizeId = 38,
        LocalSizeHintId = 39,
        PostDepthCoverage = 4446,
        StencilRefReplacingEXT = 5027,
    }
    public class ExecutionModeParameterFactory : ParameterFactory
    {
        public class InvocationsParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class LocalSizeParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), new LiteralInteger(), new LiteralInteger(), };
        }

        public class LocalSizeHintParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), new LiteralInteger(), new LiteralInteger(), };
        }

        public class OutputVerticesParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class VecTypeHintParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class SubgroupSizeParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class SubgroupsPerWorkgroupParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class SubgroupsPerWorkgroupIdParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new IdRef(), };
        }

        public class LocalSizeIdParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new IdRef(), new IdRef(), new IdRef(), };
        }

        public class LocalSizeHintIdParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new IdRef(), };
        }

        public override Parameter CreateParameter(object value)
        {
            switch ((ExecutionMode)value)
            {
                case ExecutionMode.Invocations:
                    return new InvocationsParameter();
                case ExecutionMode.LocalSize:
                    return new LocalSizeParameter();
                case ExecutionMode.LocalSizeHint:
                    return new LocalSizeHintParameter();
                case ExecutionMode.OutputVertices:
                    return new OutputVerticesParameter();
                case ExecutionMode.VecTypeHint:
                    return new VecTypeHintParameter();
                case ExecutionMode.SubgroupSize:
                    return new SubgroupSizeParameter();
                case ExecutionMode.SubgroupsPerWorkgroup:
                    return new SubgroupsPerWorkgroupParameter();
                case ExecutionMode.SubgroupsPerWorkgroupId:
                    return new SubgroupsPerWorkgroupIdParameter();
                case ExecutionMode.LocalSizeId:
                    return new LocalSizeIdParameter();
                case ExecutionMode.LocalSizeHintId:
                    return new LocalSizeHintIdParameter();
            }

            return null;
        }
    }
    public enum StorageClass : uint
    {
        UniformConstant = 0,
        Input = 1,
        Uniform = 2,
        Output = 3,
        Workgroup = 4,
        CrossWorkgroup = 5,
        Private = 6,
        Function = 7,
        Generic = 8,
        PushConstant = 9,
        AtomicCounter = 10,
        Image = 11,
        StorageBuffer = 12,
    }
    public class StorageClassParameterFactory : ParameterFactory
    {
    }
    public enum Dim : uint
    {
        Dim1D = 0,
        Dim2D = 1,
        Dim3D = 2,
        Cube = 3,
        Rect = 4,
        Buffer = 5,
        SubpassData = 6,
    }
    public class DimParameterFactory : ParameterFactory
    {
    }
    public enum SamplerAddressingMode : uint
    {
        None = 0,
        ClampToEdge = 1,
        Clamp = 2,
        Repeat = 3,
        RepeatMirrored = 4,
    }
    public class SamplerAddressingModeParameterFactory : ParameterFactory
    {
    }
    public enum SamplerFilterMode : uint
    {
        Nearest = 0,
        Linear = 1,
    }
    public class SamplerFilterModeParameterFactory : ParameterFactory
    {
    }
    public enum ImageFormat : uint
    {
        Unknown = 0,
        Rgba32f = 1,
        Rgba16f = 2,
        R32f = 3,
        Rgba8 = 4,
        Rgba8Snorm = 5,
        Rg32f = 6,
        Rg16f = 7,
        R11fG11fB10f = 8,
        R16f = 9,
        Rgba16 = 10,
        Rgb10A2 = 11,
        Rg16 = 12,
        Rg8 = 13,
        R16 = 14,
        R8 = 15,
        Rgba16Snorm = 16,
        Rg16Snorm = 17,
        Rg8Snorm = 18,
        R16Snorm = 19,
        R8Snorm = 20,
        Rgba32i = 21,
        Rgba16i = 22,
        Rgba8i = 23,
        R32i = 24,
        Rg32i = 25,
        Rg16i = 26,
        Rg8i = 27,
        R16i = 28,
        R8i = 29,
        Rgba32ui = 30,
        Rgba16ui = 31,
        Rgba8ui = 32,
        R32ui = 33,
        Rgb10a2ui = 34,
        Rg32ui = 35,
        Rg16ui = 36,
        Rg8ui = 37,
        R16ui = 38,
        R8ui = 39,
    }
    public class ImageFormatParameterFactory : ParameterFactory
    {
    }
    public enum ImageChannelOrder : uint
    {
        R = 0,
        A = 1,
        RG = 2,
        RA = 3,
        RGB = 4,
        RGBA = 5,
        BGRA = 6,
        ARGB = 7,
        Intensity = 8,
        Luminance = 9,
        Rx = 10,
        RGx = 11,
        RGBx = 12,
        Depth = 13,
        DepthStencil = 14,
        sRGB = 15,
        sRGBx = 16,
        sRGBA = 17,
        sBGRA = 18,
        ABGR = 19,
    }
    public class ImageChannelOrderParameterFactory : ParameterFactory
    {
    }
    public enum ImageChannelDataType : uint
    {
        SnormInt8 = 0,
        SnormInt16 = 1,
        UnormInt8 = 2,
        UnormInt16 = 3,
        UnormShort565 = 4,
        UnormShort555 = 5,
        UnormInt101010 = 6,
        SignedInt8 = 7,
        SignedInt16 = 8,
        SignedInt32 = 9,
        UnsignedInt8 = 10,
        UnsignedInt16 = 11,
        UnsignedInt32 = 12,
        HalfFloat = 13,
        Float = 14,
        UnormInt24 = 15,
        UnormInt101010_2 = 16,
    }
    public class ImageChannelDataTypeParameterFactory : ParameterFactory
    {
    }
    public enum FPRoundingMode : uint
    {
        RTE = 0,
        RTZ = 1,
        RTP = 2,
        RTN = 3,
    }
    public class FPRoundingModeParameterFactory : ParameterFactory
    {
    }
    public enum LinkageType : uint
    {
        Export = 0,
        Import = 1,
    }
    public class LinkageTypeParameterFactory : ParameterFactory
    {
    }
    public enum AccessQualifier : uint
    {
        ReadOnly = 0,
        WriteOnly = 1,
        ReadWrite = 2,
    }
    public class AccessQualifierParameterFactory : ParameterFactory
    {
    }
    public enum FunctionParameterAttribute : uint
    {
        Zext = 0,
        Sext = 1,
        ByVal = 2,
        Sret = 3,
        NoAlias = 4,
        NoCapture = 5,
        NoWrite = 6,
        NoReadWrite = 7,
    }
    public class FunctionParameterAttributeParameterFactory : ParameterFactory
    {
    }
    public enum Decoration : uint
    {
        RelaxedPrecision = 0,
        SpecId = 1,
        Block = 2,
        BufferBlock = 3,
        RowMajor = 4,
        ColMajor = 5,
        ArrayStride = 6,
        MatrixStride = 7,
        GLSLShared = 8,
        GLSLPacked = 9,
        CPacked = 10,
        BuiltIn = 11,
        NoPerspective = 13,
        Flat = 14,
        Patch = 15,
        Centroid = 16,
        Sample = 17,
        Invariant = 18,
        Restrict = 19,
        Aliased = 20,
        Volatile = 21,
        Constant = 22,
        Coherent = 23,
        NonWritable = 24,
        NonReadable = 25,
        Uniform = 26,
        SaturatedConversion = 28,
        Stream = 29,
        Location = 30,
        Component = 31,
        Index = 32,
        Binding = 33,
        DescriptorSet = 34,
        Offset = 35,
        XfbBuffer = 36,
        XfbStride = 37,
        FuncParamAttr = 38,
        FPRoundingMode = 39,
        FPFastMathMode = 40,
        LinkageAttributes = 41,
        NoContraction = 42,
        InputAttachmentIndex = 43,
        Alignment = 44,
        MaxByteOffset = 45,
        AlignmentId = 46,
        MaxByteOffsetId = 47,
        ExplicitInterpAMD = 4999,
        OverrideCoverageNV = 5248,
        PassthroughNV = 5250,
        ViewportRelativeNV = 5252,
        SecondaryViewportRelativeNV = 5256,
    }
    public class DecorationParameterFactory : ParameterFactory
    {
        public class SpecIdParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class ArrayStrideParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class MatrixStrideParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class BuiltInParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new EnumType<BuiltIn>(), };
        }

        public class StreamParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class LocationParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class ComponentParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class IndexParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class BindingParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class DescriptorSetParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class OffsetParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class XfbBufferParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class XfbStrideParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class FuncParamAttrParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new EnumType<FunctionParameterAttribute>(), };
        }

        public class FPRoundingModeParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new EnumType<FPRoundingMode>(), };
        }

        public class FPFastMathModeParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new EnumType<FPFastMathMode>(), };
        }

        public class LinkageAttributesParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralString(), new EnumType<LinkageType>(), };
        }

        public class InputAttachmentIndexParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class AlignmentParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class MaxByteOffsetParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public class AlignmentIdParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new IdRef(), };
        }

        public class MaxByteOffsetIdParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new IdRef(), };
        }

        public class SecondaryViewportRelativeNVParameter : Parameter
        {
            public override IReadOnlyList<OperandType> OperandTypes
            {
                get => operandTypes_;
            }

            private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
        {new LiteralInteger(), };
        }

        public override Parameter CreateParameter(object value)
        {
            switch ((Decoration)value)
            {
                case Decoration.SpecId:
                    return new SpecIdParameter();
                case Decoration.ArrayStride:
                    return new ArrayStrideParameter();
                case Decoration.MatrixStride:
                    return new MatrixStrideParameter();
                case Decoration.BuiltIn:
                    return new BuiltInParameter();
                case Decoration.Stream:
                    return new StreamParameter();
                case Decoration.Location:
                    return new LocationParameter();
                case Decoration.Component:
                    return new ComponentParameter();
                case Decoration.Index:
                    return new IndexParameter();
                case Decoration.Binding:
                    return new BindingParameter();
                case Decoration.DescriptorSet:
                    return new DescriptorSetParameter();
                case Decoration.Offset:
                    return new OffsetParameter();
                case Decoration.XfbBuffer:
                    return new XfbBufferParameter();
                case Decoration.XfbStride:
                    return new XfbStrideParameter();
                case Decoration.FuncParamAttr:
                    return new FuncParamAttrParameter();
                case Decoration.FPRoundingMode:
                    return new FPRoundingModeParameter();
                case Decoration.FPFastMathMode:
                    return new FPFastMathModeParameter();
                case Decoration.LinkageAttributes:
                    return new LinkageAttributesParameter();
                case Decoration.InputAttachmentIndex:
                    return new InputAttachmentIndexParameter();
                case Decoration.Alignment:
                    return new AlignmentParameter();
                case Decoration.MaxByteOffset:
                    return new MaxByteOffsetParameter();
                case Decoration.AlignmentId:
                    return new AlignmentIdParameter();
                case Decoration.MaxByteOffsetId:
                    return new MaxByteOffsetIdParameter();
                case Decoration.SecondaryViewportRelativeNV:
                    return new SecondaryViewportRelativeNVParameter();
            }

            return null;
        }
    }
    public enum BuiltIn : uint
    {
        Position = 0,
        PointSize = 1,
        ClipDistance = 3,
        CullDistance = 4,
        VertexId = 5,
        InstanceId = 6,
        PrimitiveId = 7,
        InvocationId = 8,
        Layer = 9,
        ViewportIndex = 10,
        TessLevelOuter = 11,
        TessLevelInner = 12,
        TessCoord = 13,
        PatchVertices = 14,
        FragCoord = 15,
        PointCoord = 16,
        FrontFacing = 17,
        SampleId = 18,
        SamplePosition = 19,
        SampleMask = 20,
        FragDepth = 22,
        HelperInvocation = 23,
        NumWorkgroups = 24,
        WorkgroupSize = 25,
        WorkgroupId = 26,
        LocalInvocationId = 27,
        GlobalInvocationId = 28,
        LocalInvocationIndex = 29,
        WorkDim = 30,
        GlobalSize = 31,
        EnqueuedWorkgroupSize = 32,
        GlobalOffset = 33,
        GlobalLinearId = 34,
        SubgroupSize = 36,
        SubgroupMaxSize = 37,
        NumSubgroups = 38,
        NumEnqueuedSubgroups = 39,
        SubgroupId = 40,
        SubgroupLocalInvocationId = 41,
        VertexIndex = 42,
        InstanceIndex = 43,
        SubgroupEqMaskKHR = 4416,
        SubgroupGeMaskKHR = 4417,
        SubgroupGtMaskKHR = 4418,
        SubgroupLeMaskKHR = 4419,
        SubgroupLtMaskKHR = 4420,
        BaseVertex = 4424,
        BaseInstance = 4425,
        DrawIndex = 4426,
        DeviceIndex = 4438,
        ViewIndex = 4440,
        BaryCoordNoPerspAMD = 4992,
        BaryCoordNoPerspCentroidAMD = 4993,
        BaryCoordNoPerspSampleAMD = 4994,
        BaryCoordSmoothAMD = 4995,
        BaryCoordSmoothCentroidAMD = 4996,
        BaryCoordSmoothSampleAMD = 4997,
        BaryCoordPullModelAMD = 4998,
        FragStencilRefEXT = 5014,
        ViewportMaskNV = 5253,
        SecondaryPositionNV = 5257,
        SecondaryViewportMaskNV = 5258,
        PositionPerViewNV = 5261,
        ViewportMaskPerViewNV = 5262,
    }
    public class BuiltInParameterFactory : ParameterFactory
    {
    }
    public enum Scope : uint
    {
        CrossDevice = 0,
        Device = 1,
        Workgroup = 2,
        Subgroup = 3,
        Invocation = 4,
    }
    public class ScopeParameterFactory : ParameterFactory
    {
    }
    public enum GroupOperation : uint
    {
        Reduce = 0,
        InclusiveScan = 1,
        ExclusiveScan = 2,
    }
    public class GroupOperationParameterFactory : ParameterFactory
    {
    }
    public enum KernelEnqueueFlags : uint
    {
        NoWait = 0,
        WaitKernel = 1,
        WaitWorkGroup = 2,
    }
    public class KernelEnqueueFlagsParameterFactory : ParameterFactory
    {
    }
    public enum Capability : uint
    {
        Matrix = 0,
        Shader = 1,
        Geometry = 2,
        Tessellation = 3,
        Addresses = 4,
        Linkage = 5,
        Kernel = 6,
        Vector16 = 7,
        Float16Buffer = 8,
        Float16 = 9,
        Float64 = 10,
        Int64 = 11,
        Int64Atomics = 12,
        ImageBasic = 13,
        ImageReadWrite = 14,
        ImageMipmap = 15,
        Pipes = 17,
        Groups = 18,
        DeviceEnqueue = 19,
        LiteralSampler = 20,
        AtomicStorage = 21,
        Int16 = 22,
        TessellationPointSize = 23,
        GeometryPointSize = 24,
        ImageGatherExtended = 25,
        StorageImageMultisample = 27,
        UniformBufferArrayDynamicIndexing = 28,
        SampledImageArrayDynamicIndexing = 29,
        StorageBufferArrayDynamicIndexing = 30,
        StorageImageArrayDynamicIndexing = 31,
        ClipDistance = 32,
        CullDistance = 33,
        ImageCubeArray = 34,
        SampleRateShading = 35,
        ImageRect = 36,
        SampledRect = 37,
        GenericPointer = 38,
        Int8 = 39,
        InputAttachment = 40,
        SparseResidency = 41,
        MinLod = 42,
        Sampled1D = 43,
        Image1D = 44,
        SampledCubeArray = 45,
        SampledBuffer = 46,
        ImageBuffer = 47,
        ImageMSArray = 48,
        StorageImageExtendedFormats = 49,
        ImageQuery = 50,
        DerivativeControl = 51,
        InterpolationFunction = 52,
        TransformFeedback = 53,
        GeometryStreams = 54,
        StorageImageReadWithoutFormat = 55,
        StorageImageWriteWithoutFormat = 56,
        MultiViewport = 57,
        SubgroupDispatch = 58,
        NamedBarrier = 59,
        PipeStorage = 60,
        SubgroupBallotKHR = 4423,
        DrawParameters = 4427,
        SubgroupVoteKHR = 4431,
        StorageBuffer16BitAccess = 4433,
        StorageUniformBufferBlock16 = 4433,
        UniformAndStorageBuffer16BitAccess = 4434,
        StorageUniform16 = 4434,
        StoragePushConstant16 = 4435,
        StorageInputOutput16 = 4436,
        DeviceGroup = 4437,
        MultiView = 4439,
        VariablePointersStorageBuffer = 4441,
        VariablePointers = 4442,
        AtomicStorageOps = 4445,
        SampleMaskPostDepthCoverage = 4447,
        ImageGatherBiasLodAMD = 5009,
        FragmentMaskAMD = 5010,
        StencilExportEXT = 5013,
        ImageReadWriteLodAMD = 5015,
        SampleMaskOverrideCoverageNV = 5249,
        GeometryShaderPassthroughNV = 5251,
        ShaderViewportIndexLayerEXT = 5254,
        ShaderViewportIndexLayerNV = 5254,
        ShaderViewportMaskNV = 5255,
        ShaderStereoViewNV = 5259,
        PerViewAttributesNV = 5260,
        SubgroupShuffleINTEL = 5568,
        SubgroupBufferBlockIOINTEL = 5569,
        SubgroupImageBlockIOINTEL = 5570,
    }
    public class CapabilityParameterFactory : ParameterFactory
    {
    }
    public class OpNop : Instruction
    {
        public OpNop() : base("OpNop")
        {
        }
    }
    public class OpUndef : Instruction
    {
        public OpUndef() : base("OpUndef", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpSourceContinued : Instruction
    {
        public OpSourceContinued() : base("OpSourceContinued", new List<Operand>()
    {new Operand(new LiteralString(), "Continued Source", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSource : Instruction
    {
        public OpSource() : base("OpSource", new List<Operand>()
    {new Operand(new EnumType<SourceLanguage, SourceLanguageParameterFactory>(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Version", OperandQuantifier.Default), new Operand(new IdRef(), "File", OperandQuantifier.Optional), new Operand(new LiteralString(), "Source", OperandQuantifier.Optional), })
        {
        }
    }
    public class OpSourceExtension : Instruction
    {
        public OpSourceExtension() : base("OpSourceExtension", new List<Operand>()
    {new Operand(new LiteralString(), "Extension", OperandQuantifier.Default), })
        {
        }
    }
    public class OpName : Instruction
    {
        public OpName() : base("OpName", new List<Operand>()
    {new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new LiteralString(), "Name", OperandQuantifier.Default), })
        {
        }
    }
    public class OpMemberName : Instruction
    {
        public OpMemberName() : base("OpMemberName", new List<Operand>()
    {new Operand(new IdRef(), "Type", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Member", OperandQuantifier.Default), new Operand(new LiteralString(), "Name", OperandQuantifier.Default), })
        {
        }
    }
    public class OpString : Instruction
    {
        public OpString() : base("OpString", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralString(), "String", OperandQuantifier.Default), })
        {
        }
    }
    public class OpLine : Instruction
    {
        public OpLine() : base("OpLine", new List<Operand>()
    {new Operand(new IdRef(), "File", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Line", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Column", OperandQuantifier.Default), })
        {
        }
    }
    public class OpExtension : Instruction
    {
        public OpExtension() : base("OpExtension", new List<Operand>()
    {new Operand(new LiteralString(), "Name", OperandQuantifier.Default), })
        {
        }
    }
    public class OpExtInstImport : Instruction
    {
        public OpExtInstImport() : base("OpExtInstImport", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralString(), "Name", OperandQuantifier.Default), })
        {
        }
    }
    public class OpExtInst : Instruction
    {
        public OpExtInst() : base("OpExtInst", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Set", OperandQuantifier.Default), new Operand(new LiteralExtInstInteger(), "Instruction", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1, +Operand 2, +...", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpMemoryModel : Instruction
    {
        public OpMemoryModel() : base("OpMemoryModel", new List<Operand>()
    {new Operand(new EnumType<AddressingModel, AddressingModelParameterFactory>(), null, OperandQuantifier.Default), new Operand(new EnumType<MemoryModel, MemoryModelParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpEntryPoint : Instruction
    {
        public OpEntryPoint() : base("OpEntryPoint", new List<Operand>()
    {new Operand(new EnumType<ExecutionModel, ExecutionModelParameterFactory>(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Entry Point", OperandQuantifier.Default), new Operand(new LiteralString(), "Name", OperandQuantifier.Default), new Operand(new IdRef(), "Interface", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpExecutionMode : Instruction
    {
        public OpExecutionMode() : base("OpExecutionMode", new List<Operand>()
    {new Operand(new IdRef(), "Entry Point", OperandQuantifier.Default), new Operand(new EnumType<ExecutionMode, ExecutionModeParameterFactory>(), "Mode", OperandQuantifier.Default), })
        {
        }
    }
    public class OpCapability : Instruction
    {
        public OpCapability() : base("OpCapability", new List<Operand>()
    {new Operand(new EnumType<Capability, CapabilityParameterFactory>(), "Capability", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeVoid : Instruction
    {
        public OpTypeVoid() : base("OpTypeVoid", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeBool : Instruction
    {
        public OpTypeBool() : base("OpTypeBool", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeInt : Instruction
    {
        public OpTypeInt() : base("OpTypeInt", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Width", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Signedness", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeFloat : Instruction
    {
        public OpTypeFloat() : base("OpTypeFloat", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Width", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeVector : Instruction
    {
        public OpTypeVector() : base("OpTypeVector", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Component Type", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Component Count", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeMatrix : Instruction
    {
        public OpTypeMatrix() : base("OpTypeMatrix", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Column Type", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Column Count", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeImage : Instruction
    {
        public OpTypeImage() : base("OpTypeImage", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Type", OperandQuantifier.Default), new Operand(new EnumType<Dim, DimParameterFactory>(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Depth", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Arrayed", OperandQuantifier.Default), new Operand(new LiteralInteger(), "MS", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Sampled", OperandQuantifier.Default), new Operand(new EnumType<ImageFormat, ImageFormatParameterFactory>(), null, OperandQuantifier.Default), new Operand(new EnumType<AccessQualifier, AccessQualifierParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpTypeSampler : Instruction
    {
        public OpTypeSampler() : base("OpTypeSampler", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeSampledImage : Instruction
    {
        public OpTypeSampledImage() : base("OpTypeSampledImage", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image Type", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeArray : Instruction
    {
        public OpTypeArray() : base("OpTypeArray", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Element Type", OperandQuantifier.Default), new Operand(new IdRef(), "Length", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeRuntimeArray : Instruction
    {
        public OpTypeRuntimeArray() : base("OpTypeRuntimeArray", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Element Type", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeStruct : Instruction
    {
        public OpTypeStruct() : base("OpTypeStruct", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Member 0 type, +member 1 type, +...", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpTypeOpaque : Instruction
    {
        public OpTypeOpaque() : base("OpTypeOpaque", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralString(), "The name of the opaque type.", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypePointer : Instruction
    {
        public OpTypePointer() : base("OpTypePointer", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<StorageClass, StorageClassParameterFactory>(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Type", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeFunction : Instruction
    {
        public OpTypeFunction() : base("OpTypeFunction", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Return Type", OperandQuantifier.Default), new Operand(new IdRef(), "Parameter 0 Type, +Parameter 1 Type, +...", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpTypeEvent : Instruction
    {
        public OpTypeEvent() : base("OpTypeEvent", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeDeviceEvent : Instruction
    {
        public OpTypeDeviceEvent() : base("OpTypeDeviceEvent", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeReserveId : Instruction
    {
        public OpTypeReserveId() : base("OpTypeReserveId", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeQueue : Instruction
    {
        public OpTypeQueue() : base("OpTypeQueue", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypePipe : Instruction
    {
        public OpTypePipe() : base("OpTypePipe", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<AccessQualifier, AccessQualifierParameterFactory>(), "Qualifier", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeForwardPointer : Instruction
    {
        public OpTypeForwardPointer() : base("OpTypeForwardPointer", new List<Operand>()
    {new Operand(new IdRef(), "Pointer Type", OperandQuantifier.Default), new Operand(new EnumType<StorageClass, StorageClassParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpConstantTrue : Instruction
    {
        public OpConstantTrue() : base("OpConstantTrue", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpConstantFalse : Instruction
    {
        public OpConstantFalse() : base("OpConstantFalse", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpConstant : Instruction
    {
        public OpConstant() : base("OpConstant", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralContextDependentNumber(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpConstantComposite : Instruction
    {
        public OpConstantComposite() : base("OpConstantComposite", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Constituents", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpConstantSampler : Instruction
    {
        public OpConstantSampler() : base("OpConstantSampler", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<SamplerAddressingMode, SamplerAddressingModeParameterFactory>(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Param", OperandQuantifier.Default), new Operand(new EnumType<SamplerFilterMode, SamplerFilterModeParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpConstantNull : Instruction
    {
        public OpConstantNull() : base("OpConstantNull", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpSpecConstantTrue : Instruction
    {
        public OpSpecConstantTrue() : base("OpSpecConstantTrue", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpSpecConstantFalse : Instruction
    {
        public OpSpecConstantFalse() : base("OpSpecConstantFalse", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpSpecConstant : Instruction
    {
        public OpSpecConstant() : base("OpSpecConstant", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralContextDependentNumber(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSpecConstantComposite : Instruction
    {
        public OpSpecConstantComposite() : base("OpSpecConstantComposite", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Constituents", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpSpecConstantOp : Instruction
    {
        public OpSpecConstantOp() : base("OpSpecConstantOp", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralSpecConstantOpInteger(), "Opcode", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFunction : Instruction
    {
        public OpFunction() : base("OpFunction", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<FunctionControl, FunctionControlParameterFactory>(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Function Type", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFunctionParameter : Instruction
    {
        public OpFunctionParameter() : base("OpFunctionParameter", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpFunctionEnd : Instruction
    {
        public OpFunctionEnd() : base("OpFunctionEnd")
        {
        }
    }
    public class OpFunctionCall : Instruction
    {
        public OpFunctionCall() : base("OpFunctionCall", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Function", OperandQuantifier.Default), new Operand(new IdRef(), "Argument 0, +Argument 1, +...", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpVariable : Instruction
    {
        public OpVariable() : base("OpVariable", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<StorageClass, StorageClassParameterFactory>(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Initializer", OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageTexelPointer : Instruction
    {
        public OpImageTexelPointer() : base("OpImageTexelPointer", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Sample", OperandQuantifier.Default), })
        {
        }
    }
    public class OpLoad : Instruction
    {
        public OpLoad() : base("OpLoad", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new EnumType<MemoryAccess, MemoryAccessParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpStore : Instruction
    {
        public OpStore() : base("OpStore", new List<Operand>()
    {new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Object", OperandQuantifier.Default), new Operand(new EnumType<MemoryAccess, MemoryAccessParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpCopyMemory : Instruction
    {
        public OpCopyMemory() : base("OpCopyMemory", new List<Operand>()
    {new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new IdRef(), "Source", OperandQuantifier.Default), new Operand(new EnumType<MemoryAccess, MemoryAccessParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpCopyMemorySized : Instruction
    {
        public OpCopyMemorySized() : base("OpCopyMemorySized", new List<Operand>()
    {new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new IdRef(), "Source", OperandQuantifier.Default), new Operand(new IdRef(), "Size", OperandQuantifier.Default), new Operand(new EnumType<MemoryAccess, MemoryAccessParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpAccessChain : Instruction
    {
        public OpAccessChain() : base("OpAccessChain", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Indexes", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpInBoundsAccessChain : Instruction
    {
        public OpInBoundsAccessChain() : base("OpInBoundsAccessChain", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Indexes", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpPtrAccessChain : Instruction
    {
        public OpPtrAccessChain() : base("OpPtrAccessChain", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Element", OperandQuantifier.Default), new Operand(new IdRef(), "Indexes", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpArrayLength : Instruction
    {
        public OpArrayLength() : base("OpArrayLength", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Structure", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Array member", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGenericPtrMemSemantics : Instruction
    {
        public OpGenericPtrMemSemantics() : base("OpGenericPtrMemSemantics", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
        {
        }
    }
    public class OpInBoundsPtrAccessChain : Instruction
    {
        public OpInBoundsPtrAccessChain() : base("OpInBoundsPtrAccessChain", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Element", OperandQuantifier.Default), new Operand(new IdRef(), "Indexes", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpDecorate : Instruction
    {
        public OpDecorate() : base("OpDecorate", new List<Operand>()
    {new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new EnumType<Decoration, DecorationParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpMemberDecorate : Instruction
    {
        public OpMemberDecorate() : base("OpMemberDecorate", new List<Operand>()
    {new Operand(new IdRef(), "Structure Type", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Member", OperandQuantifier.Default), new Operand(new EnumType<Decoration, DecorationParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpDecorationGroup : Instruction
    {
        public OpDecorationGroup() : base("OpDecorationGroup", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupDecorate : Instruction
    {
        public OpGroupDecorate() : base("OpGroupDecorate", new List<Operand>()
    {new Operand(new IdRef(), "Decoration Group", OperandQuantifier.Default), new Operand(new IdRef(), "Targets", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpGroupMemberDecorate : Instruction
    {
        public OpGroupMemberDecorate() : base("OpGroupMemberDecorate", new List<Operand>()
    {new Operand(new IdRef(), "Decoration Group", OperandQuantifier.Default), new Operand(new PairIdRefLiteralInteger(), "Targets", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpVectorExtractDynamic : Instruction
    {
        public OpVectorExtractDynamic() : base("OpVectorExtractDynamic", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), })
        {
        }
    }
    public class OpVectorInsertDynamic : Instruction
    {
        public OpVectorInsertDynamic() : base("OpVectorInsertDynamic", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), new Operand(new IdRef(), "Component", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), })
        {
        }
    }
    public class OpVectorShuffle : Instruction
    {
        public OpVectorShuffle() : base("OpVectorShuffle", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector 1", OperandQuantifier.Default), new Operand(new IdRef(), "Vector 2", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Components", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpCompositeConstruct : Instruction
    {
        public OpCompositeConstruct() : base("OpCompositeConstruct", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Constituents", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpCompositeExtract : Instruction
    {
        public OpCompositeExtract() : base("OpCompositeExtract", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Composite", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Indexes", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpCompositeInsert : Instruction
    {
        public OpCompositeInsert() : base("OpCompositeInsert", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Object", OperandQuantifier.Default), new Operand(new IdRef(), "Composite", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Indexes", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpCopyObject : Instruction
    {
        public OpCopyObject() : base("OpCopyObject", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTranspose : Instruction
    {
        public OpTranspose() : base("OpTranspose", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Matrix", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSampledImage : Instruction
    {
        public OpSampledImage() : base("OpSampledImage", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Sampler", OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageSampleImplicitLod : Instruction
    {
        public OpImageSampleImplicitLod() : base("OpImageSampleImplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageSampleExplicitLod : Instruction
    {
        public OpImageSampleExplicitLod() : base("OpImageSampleExplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageSampleDrefImplicitLod : Instruction
    {
        public OpImageSampleDrefImplicitLod() : base("OpImageSampleDrefImplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageSampleDrefExplicitLod : Instruction
    {
        public OpImageSampleDrefExplicitLod() : base("OpImageSampleDrefExplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageSampleProjImplicitLod : Instruction
    {
        public OpImageSampleProjImplicitLod() : base("OpImageSampleProjImplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageSampleProjExplicitLod : Instruction
    {
        public OpImageSampleProjExplicitLod() : base("OpImageSampleProjExplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageSampleProjDrefImplicitLod : Instruction
    {
        public OpImageSampleProjDrefImplicitLod() : base("OpImageSampleProjDrefImplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageSampleProjDrefExplicitLod : Instruction
    {
        public OpImageSampleProjDrefExplicitLod() : base("OpImageSampleProjDrefExplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageFetch : Instruction
    {
        public OpImageFetch() : base("OpImageFetch", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageGather : Instruction
    {
        public OpImageGather() : base("OpImageGather", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Component", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageDrefGather : Instruction
    {
        public OpImageDrefGather() : base("OpImageDrefGather", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageRead : Instruction
    {
        public OpImageRead() : base("OpImageRead", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageWrite : Instruction
    {
        public OpImageWrite() : base("OpImageWrite", new List<Operand>()
    {new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Texel", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImage : Instruction
    {
        public OpImage() : base("OpImage", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageQueryFormat : Instruction
    {
        public OpImageQueryFormat() : base("OpImageQueryFormat", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageQueryOrder : Instruction
    {
        public OpImageQueryOrder() : base("OpImageQueryOrder", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageQuerySizeLod : Instruction
    {
        public OpImageQuerySizeLod() : base("OpImageQuerySizeLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Level of Detail", OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageQuerySize : Instruction
    {
        public OpImageQuerySize() : base("OpImageQuerySize", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageQueryLod : Instruction
    {
        public OpImageQueryLod() : base("OpImageQueryLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageQueryLevels : Instruction
    {
        public OpImageQueryLevels() : base("OpImageQueryLevels", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageQuerySamples : Instruction
    {
        public OpImageQuerySamples() : base("OpImageQuerySamples", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
        {
        }
    }
    public class OpConvertFToU : Instruction
    {
        public OpConvertFToU() : base("OpConvertFToU", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Float Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpConvertFToS : Instruction
    {
        public OpConvertFToS() : base("OpConvertFToS", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Float Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpConvertSToF : Instruction
    {
        public OpConvertSToF() : base("OpConvertSToF", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Signed Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpConvertUToF : Instruction
    {
        public OpConvertUToF() : base("OpConvertUToF", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Unsigned Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpUConvert : Instruction
    {
        public OpUConvert() : base("OpUConvert", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Unsigned Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSConvert : Instruction
    {
        public OpSConvert() : base("OpSConvert", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Signed Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFConvert : Instruction
    {
        public OpFConvert() : base("OpFConvert", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Float Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpQuantizeToF16 : Instruction
    {
        public OpQuantizeToF16() : base("OpQuantizeToF16", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpConvertPtrToU : Instruction
    {
        public OpConvertPtrToU() : base("OpConvertPtrToU", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSatConvertSToU : Instruction
    {
        public OpSatConvertSToU() : base("OpSatConvertSToU", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Signed Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSatConvertUToS : Instruction
    {
        public OpSatConvertUToS() : base("OpSatConvertUToS", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Unsigned Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpConvertUToPtr : Instruction
    {
        public OpConvertUToPtr() : base("OpConvertUToPtr", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Integer Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpPtrCastToGeneric : Instruction
    {
        public OpPtrCastToGeneric() : base("OpPtrCastToGeneric", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGenericCastToPtr : Instruction
    {
        public OpGenericCastToPtr() : base("OpGenericCastToPtr", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGenericCastToPtrExplicit : Instruction
    {
        public OpGenericCastToPtrExplicit() : base("OpGenericCastToPtrExplicit", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new EnumType<StorageClass, StorageClassParameterFactory>(), "Storage", OperandQuantifier.Default), })
        {
        }
    }
    public class OpBitcast : Instruction
    {
        public OpBitcast() : base("OpBitcast", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSNegate : Instruction
    {
        public OpSNegate() : base("OpSNegate", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFNegate : Instruction
    {
        public OpFNegate() : base("OpFNegate", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
        {
        }
    }
    public class OpIAdd : Instruction
    {
        public OpIAdd() : base("OpIAdd", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFAdd : Instruction
    {
        public OpFAdd() : base("OpFAdd", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpISub : Instruction
    {
        public OpISub() : base("OpISub", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFSub : Instruction
    {
        public OpFSub() : base("OpFSub", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpIMul : Instruction
    {
        public OpIMul() : base("OpIMul", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFMul : Instruction
    {
        public OpFMul() : base("OpFMul", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpUDiv : Instruction
    {
        public OpUDiv() : base("OpUDiv", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSDiv : Instruction
    {
        public OpSDiv() : base("OpSDiv", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFDiv : Instruction
    {
        public OpFDiv() : base("OpFDiv", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpUMod : Instruction
    {
        public OpUMod() : base("OpUMod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSRem : Instruction
    {
        public OpSRem() : base("OpSRem", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSMod : Instruction
    {
        public OpSMod() : base("OpSMod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFRem : Instruction
    {
        public OpFRem() : base("OpFRem", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFMod : Instruction
    {
        public OpFMod() : base("OpFMod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpVectorTimesScalar : Instruction
    {
        public OpVectorTimesScalar() : base("OpVectorTimesScalar", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), new Operand(new IdRef(), "Scalar", OperandQuantifier.Default), })
        {
        }
    }
    public class OpMatrixTimesScalar : Instruction
    {
        public OpMatrixTimesScalar() : base("OpMatrixTimesScalar", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Matrix", OperandQuantifier.Default), new Operand(new IdRef(), "Scalar", OperandQuantifier.Default), })
        {
        }
    }
    public class OpVectorTimesMatrix : Instruction
    {
        public OpVectorTimesMatrix() : base("OpVectorTimesMatrix", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), new Operand(new IdRef(), "Matrix", OperandQuantifier.Default), })
        {
        }
    }
    public class OpMatrixTimesVector : Instruction
    {
        public OpMatrixTimesVector() : base("OpMatrixTimesVector", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Matrix", OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), })
        {
        }
    }
    public class OpMatrixTimesMatrix : Instruction
    {
        public OpMatrixTimesMatrix() : base("OpMatrixTimesMatrix", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "LeftMatrix", OperandQuantifier.Default), new Operand(new IdRef(), "RightMatrix", OperandQuantifier.Default), })
        {
        }
    }
    public class OpOuterProduct : Instruction
    {
        public OpOuterProduct() : base("OpOuterProduct", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector 1", OperandQuantifier.Default), new Operand(new IdRef(), "Vector 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpDot : Instruction
    {
        public OpDot() : base("OpDot", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector 1", OperandQuantifier.Default), new Operand(new IdRef(), "Vector 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpIAddCarry : Instruction
    {
        public OpIAddCarry() : base("OpIAddCarry", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpISubBorrow : Instruction
    {
        public OpISubBorrow() : base("OpISubBorrow", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpUMulExtended : Instruction
    {
        public OpUMulExtended() : base("OpUMulExtended", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSMulExtended : Instruction
    {
        public OpSMulExtended() : base("OpSMulExtended", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAny : Instruction
    {
        public OpAny() : base("OpAny", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAll : Instruction
    {
        public OpAll() : base("OpAll", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), })
        {
        }
    }
    public class OpIsNan : Instruction
    {
        public OpIsNan() : base("OpIsNan", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
        {
        }
    }
    public class OpIsInf : Instruction
    {
        public OpIsInf() : base("OpIsInf", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
        {
        }
    }
    public class OpIsFinite : Instruction
    {
        public OpIsFinite() : base("OpIsFinite", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
        {
        }
    }
    public class OpIsNormal : Instruction
    {
        public OpIsNormal() : base("OpIsNormal", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSignBitSet : Instruction
    {
        public OpSignBitSet() : base("OpSignBitSet", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
        {
        }
    }
    public class OpLessOrGreater : Instruction
    {
        public OpLessOrGreater() : base("OpLessOrGreater", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), new Operand(new IdRef(), "y", OperandQuantifier.Default), })
        {
        }
    }
    public class OpOrdered : Instruction
    {
        public OpOrdered() : base("OpOrdered", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), new Operand(new IdRef(), "y", OperandQuantifier.Default), })
        {
        }
    }
    public class OpUnordered : Instruction
    {
        public OpUnordered() : base("OpUnordered", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), new Operand(new IdRef(), "y", OperandQuantifier.Default), })
        {
        }
    }
    public class OpLogicalEqual : Instruction
    {
        public OpLogicalEqual() : base("OpLogicalEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpLogicalNotEqual : Instruction
    {
        public OpLogicalNotEqual() : base("OpLogicalNotEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpLogicalOr : Instruction
    {
        public OpLogicalOr() : base("OpLogicalOr", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpLogicalAnd : Instruction
    {
        public OpLogicalAnd() : base("OpLogicalAnd", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpLogicalNot : Instruction
    {
        public OpLogicalNot() : base("OpLogicalNot", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSelect : Instruction
    {
        public OpSelect() : base("OpSelect", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Condition", OperandQuantifier.Default), new Operand(new IdRef(), "Object 1", OperandQuantifier.Default), new Operand(new IdRef(), "Object 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpIEqual : Instruction
    {
        public OpIEqual() : base("OpIEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpINotEqual : Instruction
    {
        public OpINotEqual() : base("OpINotEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpUGreaterThan : Instruction
    {
        public OpUGreaterThan() : base("OpUGreaterThan", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSGreaterThan : Instruction
    {
        public OpSGreaterThan() : base("OpSGreaterThan", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpUGreaterThanEqual : Instruction
    {
        public OpUGreaterThanEqual() : base("OpUGreaterThanEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSGreaterThanEqual : Instruction
    {
        public OpSGreaterThanEqual() : base("OpSGreaterThanEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpULessThan : Instruction
    {
        public OpULessThan() : base("OpULessThan", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSLessThan : Instruction
    {
        public OpSLessThan() : base("OpSLessThan", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpULessThanEqual : Instruction
    {
        public OpULessThanEqual() : base("OpULessThanEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSLessThanEqual : Instruction
    {
        public OpSLessThanEqual() : base("OpSLessThanEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFOrdEqual : Instruction
    {
        public OpFOrdEqual() : base("OpFOrdEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFUnordEqual : Instruction
    {
        public OpFUnordEqual() : base("OpFUnordEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFOrdNotEqual : Instruction
    {
        public OpFOrdNotEqual() : base("OpFOrdNotEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFUnordNotEqual : Instruction
    {
        public OpFUnordNotEqual() : base("OpFUnordNotEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFOrdLessThan : Instruction
    {
        public OpFOrdLessThan() : base("OpFOrdLessThan", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFUnordLessThan : Instruction
    {
        public OpFUnordLessThan() : base("OpFUnordLessThan", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFOrdGreaterThan : Instruction
    {
        public OpFOrdGreaterThan() : base("OpFOrdGreaterThan", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFUnordGreaterThan : Instruction
    {
        public OpFUnordGreaterThan() : base("OpFUnordGreaterThan", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFOrdLessThanEqual : Instruction
    {
        public OpFOrdLessThanEqual() : base("OpFOrdLessThanEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFUnordLessThanEqual : Instruction
    {
        public OpFUnordLessThanEqual() : base("OpFUnordLessThanEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFOrdGreaterThanEqual : Instruction
    {
        public OpFOrdGreaterThanEqual() : base("OpFOrdGreaterThanEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFUnordGreaterThanEqual : Instruction
    {
        public OpFUnordGreaterThanEqual() : base("OpFUnordGreaterThanEqual", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpShiftRightLogical : Instruction
    {
        public OpShiftRightLogical() : base("OpShiftRightLogical", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Shift", OperandQuantifier.Default), })
        {
        }
    }
    public class OpShiftRightArithmetic : Instruction
    {
        public OpShiftRightArithmetic() : base("OpShiftRightArithmetic", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Shift", OperandQuantifier.Default), })
        {
        }
    }
    public class OpShiftLeftLogical : Instruction
    {
        public OpShiftLeftLogical() : base("OpShiftLeftLogical", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Shift", OperandQuantifier.Default), })
        {
        }
    }
    public class OpBitwiseOr : Instruction
    {
        public OpBitwiseOr() : base("OpBitwiseOr", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpBitwiseXor : Instruction
    {
        public OpBitwiseXor() : base("OpBitwiseXor", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpBitwiseAnd : Instruction
    {
        public OpBitwiseAnd() : base("OpBitwiseAnd", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
        {
        }
    }
    public class OpNot : Instruction
    {
        public OpNot() : base("OpNot", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
        {
        }
    }
    public class OpBitFieldInsert : Instruction
    {
        public OpBitFieldInsert() : base("OpBitFieldInsert", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Insert", OperandQuantifier.Default), new Operand(new IdRef(), "Offset", OperandQuantifier.Default), new Operand(new IdRef(), "Count", OperandQuantifier.Default), })
        {
        }
    }
    public class OpBitFieldSExtract : Instruction
    {
        public OpBitFieldSExtract() : base("OpBitFieldSExtract", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Offset", OperandQuantifier.Default), new Operand(new IdRef(), "Count", OperandQuantifier.Default), })
        {
        }
    }
    public class OpBitFieldUExtract : Instruction
    {
        public OpBitFieldUExtract() : base("OpBitFieldUExtract", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Offset", OperandQuantifier.Default), new Operand(new IdRef(), "Count", OperandQuantifier.Default), })
        {
        }
    }
    public class OpBitReverse : Instruction
    {
        public OpBitReverse() : base("OpBitReverse", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), })
        {
        }
    }
    public class OpBitCount : Instruction
    {
        public OpBitCount() : base("OpBitCount", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), })
        {
        }
    }
    public class OpDPdx : Instruction
    {
        public OpDPdx() : base("OpDPdx", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
        {
        }
    }
    public class OpDPdy : Instruction
    {
        public OpDPdy() : base("OpDPdy", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFwidth : Instruction
    {
        public OpFwidth() : base("OpFwidth", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
        {
        }
    }
    public class OpDPdxFine : Instruction
    {
        public OpDPdxFine() : base("OpDPdxFine", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
        {
        }
    }
    public class OpDPdyFine : Instruction
    {
        public OpDPdyFine() : base("OpDPdyFine", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFwidthFine : Instruction
    {
        public OpFwidthFine() : base("OpFwidthFine", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
        {
        }
    }
    public class OpDPdxCoarse : Instruction
    {
        public OpDPdxCoarse() : base("OpDPdxCoarse", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
        {
        }
    }
    public class OpDPdyCoarse : Instruction
    {
        public OpDPdyCoarse() : base("OpDPdyCoarse", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFwidthCoarse : Instruction
    {
        public OpFwidthCoarse() : base("OpFwidthCoarse", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
        {
        }
    }
    public class OpEmitVertex : Instruction
    {
        public OpEmitVertex() : base("OpEmitVertex")
        {
        }
    }
    public class OpEndPrimitive : Instruction
    {
        public OpEndPrimitive() : base("OpEndPrimitive")
        {
        }
    }
    public class OpEmitStreamVertex : Instruction
    {
        public OpEmitStreamVertex() : base("OpEmitStreamVertex", new List<Operand>()
    {new Operand(new IdRef(), "Stream", OperandQuantifier.Default), })
        {
        }
    }
    public class OpEndStreamPrimitive : Instruction
    {
        public OpEndStreamPrimitive() : base("OpEndStreamPrimitive", new List<Operand>()
    {new Operand(new IdRef(), "Stream", OperandQuantifier.Default), })
        {
        }
    }
    public class OpControlBarrier : Instruction
    {
        public OpControlBarrier() : base("OpControlBarrier", new List<Operand>()
    {new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdScope(), "Memory", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
        {
        }
    }
    public class OpMemoryBarrier : Instruction
    {
        public OpMemoryBarrier() : base("OpMemoryBarrier", new List<Operand>()
    {new Operand(new IdScope(), "Memory", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicLoad : Instruction
    {
        public OpAtomicLoad() : base("OpAtomicLoad", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicStore : Instruction
    {
        public OpAtomicStore() : base("OpAtomicStore", new List<Operand>()
    {new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicExchange : Instruction
    {
        public OpAtomicExchange() : base("OpAtomicExchange", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicCompareExchange : Instruction
    {
        public OpAtomicCompareExchange() : base("OpAtomicCompareExchange", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Equal", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Unequal", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), new Operand(new IdRef(), "Comparator", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicCompareExchangeWeak : Instruction
    {
        public OpAtomicCompareExchangeWeak() : base("OpAtomicCompareExchangeWeak", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Equal", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Unequal", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), new Operand(new IdRef(), "Comparator", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicIIncrement : Instruction
    {
        public OpAtomicIIncrement() : base("OpAtomicIIncrement", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicIDecrement : Instruction
    {
        public OpAtomicIDecrement() : base("OpAtomicIDecrement", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicIAdd : Instruction
    {
        public OpAtomicIAdd() : base("OpAtomicIAdd", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicISub : Instruction
    {
        public OpAtomicISub() : base("OpAtomicISub", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicSMin : Instruction
    {
        public OpAtomicSMin() : base("OpAtomicSMin", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicUMin : Instruction
    {
        public OpAtomicUMin() : base("OpAtomicUMin", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicSMax : Instruction
    {
        public OpAtomicSMax() : base("OpAtomicSMax", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicUMax : Instruction
    {
        public OpAtomicUMax() : base("OpAtomicUMax", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicAnd : Instruction
    {
        public OpAtomicAnd() : base("OpAtomicAnd", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicOr : Instruction
    {
        public OpAtomicOr() : base("OpAtomicOr", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicXor : Instruction
    {
        public OpAtomicXor() : base("OpAtomicXor", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpPhi : Instruction
    {
        public OpPhi() : base("OpPhi", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new PairIdRefIdRef(), "Variable, Parent, ...", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpLoopMerge : Instruction
    {
        public OpLoopMerge() : base("OpLoopMerge", new List<Operand>()
    {new Operand(new IdRef(), "Merge Block", OperandQuantifier.Default), new Operand(new IdRef(), "Continue Target", OperandQuantifier.Default), new Operand(new EnumType<LoopControl, LoopControlParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpSelectionMerge : Instruction
    {
        public OpSelectionMerge() : base("OpSelectionMerge", new List<Operand>()
    {new Operand(new IdRef(), "Merge Block", OperandQuantifier.Default), new Operand(new EnumType<SelectionControl, SelectionControlParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpLabel : Instruction
    {
        public OpLabel() : base("OpLabel", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpBranch : Instruction
    {
        public OpBranch() : base("OpBranch", new List<Operand>()
    {new Operand(new IdRef(), "Target Label", OperandQuantifier.Default), })
        {
        }
    }
    public class OpBranchConditional : Instruction
    {
        public OpBranchConditional() : base("OpBranchConditional", new List<Operand>()
    {new Operand(new IdRef(), "Condition", OperandQuantifier.Default), new Operand(new IdRef(), "True Label", OperandQuantifier.Default), new Operand(new IdRef(), "False Label", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Branch weights", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpSwitch : Instruction
    {
        public OpSwitch() : base("OpSwitch", new List<Operand>()
    {new Operand(new IdRef(), "Selector", OperandQuantifier.Default), new Operand(new IdRef(), "Default", OperandQuantifier.Default), new Operand(new PairLiteralIntegerIdRef(), "Target", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpKill : Instruction
    {
        public OpKill() : base("OpKill")
        {
        }
    }
    public class OpReturn : Instruction
    {
        public OpReturn() : base("OpReturn")
        {
        }
    }
    public class OpReturnValue : Instruction
    {
        public OpReturnValue() : base("OpReturnValue", new List<Operand>()
    {new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpUnreachable : Instruction
    {
        public OpUnreachable() : base("OpUnreachable")
        {
        }
    }
    public class OpLifetimeStart : Instruction
    {
        public OpLifetimeStart() : base("OpLifetimeStart", new List<Operand>()
    {new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Size", OperandQuantifier.Default), })
        {
        }
    }
    public class OpLifetimeStop : Instruction
    {
        public OpLifetimeStop() : base("OpLifetimeStop", new List<Operand>()
    {new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Size", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupAsyncCopy : Instruction
    {
        public OpGroupAsyncCopy() : base("OpGroupAsyncCopy", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Destination", OperandQuantifier.Default), new Operand(new IdRef(), "Source", OperandQuantifier.Default), new Operand(new IdRef(), "Num Elements", OperandQuantifier.Default), new Operand(new IdRef(), "Stride", OperandQuantifier.Default), new Operand(new IdRef(), "Event", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupWaitEvents : Instruction
    {
        public OpGroupWaitEvents() : base("OpGroupWaitEvents", new List<Operand>()
    {new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Num Events", OperandQuantifier.Default), new Operand(new IdRef(), "Events List", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupAll : Instruction
    {
        public OpGroupAll() : base("OpGroupAll", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupAny : Instruction
    {
        public OpGroupAny() : base("OpGroupAny", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupBroadcast : Instruction
    {
        public OpGroupBroadcast() : base("OpGroupBroadcast", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), new Operand(new IdRef(), "LocalId", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupIAdd : Instruction
    {
        public OpGroupIAdd() : base("OpGroupIAdd", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupFAdd : Instruction
    {
        public OpGroupFAdd() : base("OpGroupFAdd", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupFMin : Instruction
    {
        public OpGroupFMin() : base("OpGroupFMin", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupUMin : Instruction
    {
        public OpGroupUMin() : base("OpGroupUMin", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupSMin : Instruction
    {
        public OpGroupSMin() : base("OpGroupSMin", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupFMax : Instruction
    {
        public OpGroupFMax() : base("OpGroupFMax", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupUMax : Instruction
    {
        public OpGroupUMax() : base("OpGroupUMax", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupSMax : Instruction
    {
        public OpGroupSMax() : base("OpGroupSMax", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpReadPipe : Instruction
    {
        public OpReadPipe() : base("OpReadPipe", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpWritePipe : Instruction
    {
        public OpWritePipe() : base("OpWritePipe", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpReservedReadPipe : Instruction
    {
        public OpReservedReadPipe() : base("OpReservedReadPipe", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpReservedWritePipe : Instruction
    {
        public OpReservedWritePipe() : base("OpReservedWritePipe", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpReserveReadPipePackets : Instruction
    {
        public OpReserveReadPipePackets() : base("OpReserveReadPipePackets", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Num Packets", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpReserveWritePipePackets : Instruction
    {
        public OpReserveWritePipePackets() : base("OpReserveWritePipePackets", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Num Packets", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpCommitReadPipe : Instruction
    {
        public OpCommitReadPipe() : base("OpCommitReadPipe", new List<Operand>()
    {new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpCommitWritePipe : Instruction
    {
        public OpCommitWritePipe() : base("OpCommitWritePipe", new List<Operand>()
    {new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpIsValidReserveId : Instruction
    {
        public OpIsValidReserveId() : base("OpIsValidReserveId", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGetNumPipePackets : Instruction
    {
        public OpGetNumPipePackets() : base("OpGetNumPipePackets", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGetMaxPipePackets : Instruction
    {
        public OpGetMaxPipePackets() : base("OpGetMaxPipePackets", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupReserveReadPipePackets : Instruction
    {
        public OpGroupReserveReadPipePackets() : base("OpGroupReserveReadPipePackets", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Num Packets", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupReserveWritePipePackets : Instruction
    {
        public OpGroupReserveWritePipePackets() : base("OpGroupReserveWritePipePackets", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Num Packets", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupCommitReadPipe : Instruction
    {
        public OpGroupCommitReadPipe() : base("OpGroupCommitReadPipe", new List<Operand>()
    {new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupCommitWritePipe : Instruction
    {
        public OpGroupCommitWritePipe() : base("OpGroupCommitWritePipe", new List<Operand>()
    {new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
        {
        }
    }
    public class OpEnqueueMarker : Instruction
    {
        public OpEnqueueMarker() : base("OpEnqueueMarker", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Queue", OperandQuantifier.Default), new Operand(new IdRef(), "Num Events", OperandQuantifier.Default), new Operand(new IdRef(), "Wait Events", OperandQuantifier.Default), new Operand(new IdRef(), "Ret Event", OperandQuantifier.Default), })
        {
        }
    }
    public class OpEnqueueKernel : Instruction
    {
        public OpEnqueueKernel() : base("OpEnqueueKernel", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Queue", OperandQuantifier.Default), new Operand(new IdRef(), "Flags", OperandQuantifier.Default), new Operand(new IdRef(), "ND Range", OperandQuantifier.Default), new Operand(new IdRef(), "Num Events", OperandQuantifier.Default), new Operand(new IdRef(), "Wait Events", OperandQuantifier.Default), new Operand(new IdRef(), "Ret Event", OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), new Operand(new IdRef(), "Local Size", OperandQuantifier.Varying), })
        {
        }
    }
    public class OpGetKernelNDrangeSubGroupCount : Instruction
    {
        public OpGetKernelNDrangeSubGroupCount() : base("OpGetKernelNDrangeSubGroupCount", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "ND Range", OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGetKernelNDrangeMaxSubGroupSize : Instruction
    {
        public OpGetKernelNDrangeMaxSubGroupSize() : base("OpGetKernelNDrangeMaxSubGroupSize", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "ND Range", OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGetKernelWorkGroupSize : Instruction
    {
        public OpGetKernelWorkGroupSize() : base("OpGetKernelWorkGroupSize", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGetKernelPreferredWorkGroupSizeMultiple : Instruction
    {
        public OpGetKernelPreferredWorkGroupSizeMultiple() : base("OpGetKernelPreferredWorkGroupSizeMultiple", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
        {
        }
    }
    public class OpRetainEvent : Instruction
    {
        public OpRetainEvent() : base("OpRetainEvent", new List<Operand>()
    {new Operand(new IdRef(), "Event", OperandQuantifier.Default), })
        {
        }
    }
    public class OpReleaseEvent : Instruction
    {
        public OpReleaseEvent() : base("OpReleaseEvent", new List<Operand>()
    {new Operand(new IdRef(), "Event", OperandQuantifier.Default), })
        {
        }
    }
    public class OpCreateUserEvent : Instruction
    {
        public OpCreateUserEvent() : base("OpCreateUserEvent", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpIsValidEvent : Instruction
    {
        public OpIsValidEvent() : base("OpIsValidEvent", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Event", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSetUserEventStatus : Instruction
    {
        public OpSetUserEventStatus() : base("OpSetUserEventStatus", new List<Operand>()
    {new Operand(new IdRef(), "Event", OperandQuantifier.Default), new Operand(new IdRef(), "Status", OperandQuantifier.Default), })
        {
        }
    }
    public class OpCaptureEventProfilingInfo : Instruction
    {
        public OpCaptureEventProfilingInfo() : base("OpCaptureEventProfilingInfo", new List<Operand>()
    {new Operand(new IdRef(), "Event", OperandQuantifier.Default), new Operand(new IdRef(), "Profiling Info", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGetDefaultQueue : Instruction
    {
        public OpGetDefaultQueue() : base("OpGetDefaultQueue", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpBuildNDRange : Instruction
    {
        public OpBuildNDRange() : base("OpBuildNDRange", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "GlobalWorkSize", OperandQuantifier.Default), new Operand(new IdRef(), "LocalWorkSize", OperandQuantifier.Default), new Operand(new IdRef(), "GlobalWorkOffset", OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageSparseSampleImplicitLod : Instruction
    {
        public OpImageSparseSampleImplicitLod() : base("OpImageSparseSampleImplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageSparseSampleExplicitLod : Instruction
    {
        public OpImageSparseSampleExplicitLod() : base("OpImageSparseSampleExplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageSparseSampleDrefImplicitLod : Instruction
    {
        public OpImageSparseSampleDrefImplicitLod() : base("OpImageSparseSampleDrefImplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageSparseSampleDrefExplicitLod : Instruction
    {
        public OpImageSparseSampleDrefExplicitLod() : base("OpImageSparseSampleDrefExplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageSparseSampleProjImplicitLod : Instruction
    {
        public OpImageSparseSampleProjImplicitLod() : base("OpImageSparseSampleProjImplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageSparseSampleProjExplicitLod : Instruction
    {
        public OpImageSparseSampleProjExplicitLod() : base("OpImageSparseSampleProjExplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageSparseSampleProjDrefImplicitLod : Instruction
    {
        public OpImageSparseSampleProjDrefImplicitLod() : base("OpImageSparseSampleProjDrefImplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageSparseSampleProjDrefExplicitLod : Instruction
    {
        public OpImageSparseSampleProjDrefExplicitLod() : base("OpImageSparseSampleProjDrefExplicitLod", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageSparseFetch : Instruction
    {
        public OpImageSparseFetch() : base("OpImageSparseFetch", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageSparseGather : Instruction
    {
        public OpImageSparseGather() : base("OpImageSparseGather", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Component", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageSparseDrefGather : Instruction
    {
        public OpImageSparseDrefGather() : base("OpImageSparseDrefGather", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpImageSparseTexelsResident : Instruction
    {
        public OpImageSparseTexelsResident() : base("OpImageSparseTexelsResident", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Resident Code", OperandQuantifier.Default), })
        {
        }
    }
    public class OpNoLine : Instruction
    {
        public OpNoLine() : base("OpNoLine")
        {
        }
    }
    public class OpAtomicFlagTestAndSet : Instruction
    {
        public OpAtomicFlagTestAndSet() : base("OpAtomicFlagTestAndSet", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
        {
        }
    }
    public class OpAtomicFlagClear : Instruction
    {
        public OpAtomicFlagClear() : base("OpAtomicFlagClear", new List<Operand>()
    {new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
        {
        }
    }
    public class OpImageSparseRead : Instruction
    {
        public OpImageSparseRead() : base("OpImageSparseRead", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
        {
        }
    }
    public class OpSizeOf : Instruction
    {
        public OpSizeOf() : base("OpSizeOf", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypePipeStorage : Instruction
    {
        public OpTypePipeStorage() : base("OpTypePipeStorage", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpConstantPipeStorage : Instruction
    {
        public OpConstantPipeStorage() : base("OpConstantPipeStorage", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Packet Size", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Packet Alignment", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Capacity", OperandQuantifier.Default), })
        {
        }
    }
    public class OpCreatePipeFromPipeStorage : Instruction
    {
        public OpCreatePipeFromPipeStorage() : base("OpCreatePipeFromPipeStorage", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe Storage", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGetKernelLocalSizeForSubgroupCount : Instruction
    {
        public OpGetKernelLocalSizeForSubgroupCount() : base("OpGetKernelLocalSizeForSubgroupCount", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Subgroup Count", OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGetKernelMaxNumSubgroups : Instruction
    {
        public OpGetKernelMaxNumSubgroups() : base("OpGetKernelMaxNumSubgroups", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
        {
        }
    }
    public class OpTypeNamedBarrier : Instruction
    {
        public OpTypeNamedBarrier() : base("OpTypeNamedBarrier", new List<Operand>()
    {new Operand(new IdResult(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpNamedBarrierInitialize : Instruction
    {
        public OpNamedBarrierInitialize() : base("OpNamedBarrierInitialize", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Subgroup Count", OperandQuantifier.Default), })
        {
        }
    }
    public class OpMemoryNamedBarrier : Instruction
    {
        public OpMemoryNamedBarrier() : base("OpMemoryNamedBarrier", new List<Operand>()
    {new Operand(new IdRef(), "Named Barrier", OperandQuantifier.Default), new Operand(new IdScope(), "Memory", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
        {
        }
    }
    public class OpModuleProcessed : Instruction
    {
        public OpModuleProcessed() : base("OpModuleProcessed", new List<Operand>()
    {new Operand(new LiteralString(), "Process", OperandQuantifier.Default), })
        {
        }
    }
    public class OpExecutionModeId : Instruction
    {
        public OpExecutionModeId() : base("OpExecutionModeId", new List<Operand>()
    {new Operand(new IdRef(), "Entry Point", OperandQuantifier.Default), new Operand(new EnumType<ExecutionMode, ExecutionModeParameterFactory>(), "Mode", OperandQuantifier.Default), })
        {
        }
    }
    public class OpDecorateId : Instruction
    {
        public OpDecorateId() : base("OpDecorateId", new List<Operand>()
    {new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new EnumType<Decoration, DecorationParameterFactory>(), null, OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupBallotKHR : Instruction
    {
        public OpSubgroupBallotKHR() : base("OpSubgroupBallotKHR", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupFirstInvocationKHR : Instruction
    {
        public OpSubgroupFirstInvocationKHR() : base("OpSubgroupFirstInvocationKHR", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupAllKHR : Instruction
    {
        public OpSubgroupAllKHR() : base("OpSubgroupAllKHR", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupAnyKHR : Instruction
    {
        public OpSubgroupAnyKHR() : base("OpSubgroupAnyKHR", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupAllEqualKHR : Instruction
    {
        public OpSubgroupAllEqualKHR() : base("OpSubgroupAllEqualKHR", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupReadInvocationKHR : Instruction
    {
        public OpSubgroupReadInvocationKHR() : base("OpSubgroupReadInvocationKHR", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupIAddNonUniformAMD : Instruction
    {
        public OpGroupIAddNonUniformAMD() : base("OpGroupIAddNonUniformAMD", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupFAddNonUniformAMD : Instruction
    {
        public OpGroupFAddNonUniformAMD() : base("OpGroupFAddNonUniformAMD", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupFMinNonUniformAMD : Instruction
    {
        public OpGroupFMinNonUniformAMD() : base("OpGroupFMinNonUniformAMD", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupUMinNonUniformAMD : Instruction
    {
        public OpGroupUMinNonUniformAMD() : base("OpGroupUMinNonUniformAMD", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupSMinNonUniformAMD : Instruction
    {
        public OpGroupSMinNonUniformAMD() : base("OpGroupSMinNonUniformAMD", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupFMaxNonUniformAMD : Instruction
    {
        public OpGroupFMaxNonUniformAMD() : base("OpGroupFMaxNonUniformAMD", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupUMaxNonUniformAMD : Instruction
    {
        public OpGroupUMaxNonUniformAMD() : base("OpGroupUMaxNonUniformAMD", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpGroupSMaxNonUniformAMD : Instruction
    {
        public OpGroupSMaxNonUniformAMD() : base("OpGroupSMaxNonUniformAMD", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFragmentMaskFetchAMD : Instruction
    {
        public OpFragmentMaskFetchAMD() : base("OpFragmentMaskFetchAMD", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), })
        {
        }
    }
    public class OpFragmentFetchAMD : Instruction
    {
        public OpFragmentFetchAMD() : base("OpFragmentFetchAMD", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Fragment Index", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupShuffleINTEL : Instruction
    {
        public OpSubgroupShuffleINTEL() : base("OpSubgroupShuffleINTEL", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Data", OperandQuantifier.Default), new Operand(new IdRef(), "InvocationId", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupShuffleDownINTEL : Instruction
    {
        public OpSubgroupShuffleDownINTEL() : base("OpSubgroupShuffleDownINTEL", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Current", OperandQuantifier.Default), new Operand(new IdRef(), "Next", OperandQuantifier.Default), new Operand(new IdRef(), "Delta", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupShuffleUpINTEL : Instruction
    {
        public OpSubgroupShuffleUpINTEL() : base("OpSubgroupShuffleUpINTEL", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Previous", OperandQuantifier.Default), new Operand(new IdRef(), "Current", OperandQuantifier.Default), new Operand(new IdRef(), "Delta", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupShuffleXorINTEL : Instruction
    {
        public OpSubgroupShuffleXorINTEL() : base("OpSubgroupShuffleXorINTEL", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Data", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupBlockReadINTEL : Instruction
    {
        public OpSubgroupBlockReadINTEL() : base("OpSubgroupBlockReadINTEL", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Ptr", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupBlockWriteINTEL : Instruction
    {
        public OpSubgroupBlockWriteINTEL() : base("OpSubgroupBlockWriteINTEL", new List<Operand>()
    {new Operand(new IdRef(), "Ptr", OperandQuantifier.Default), new Operand(new IdRef(), "Data", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupImageBlockReadINTEL : Instruction
    {
        public OpSubgroupImageBlockReadINTEL() : base("OpSubgroupImageBlockReadINTEL", new List<Operand>()
    {new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), })
        {
        }
    }
    public class OpSubgroupImageBlockWriteINTEL : Instruction
    {
        public OpSubgroupImageBlockWriteINTEL() : base("OpSubgroupImageBlockWriteINTEL", new List<Operand>()
    {new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Data", OperandQuantifier.Default), })
        {
        }
    }
    public static class Instructions
    {
        private static readonly Dictionary<int, Instruction> instructions_ = new Dictionary<int, Instruction> { { 0, new OpNop() }, { 1, new OpUndef() }, { 2, new OpSourceContinued() }, { 3, new OpSource() }, { 4, new OpSourceExtension() }, { 5, new OpName() }, { 6, new OpMemberName() }, { 7, new OpString() }, { 8, new OpLine() }, { 10, new OpExtension() }, { 11, new OpExtInstImport() }, { 12, new OpExtInst() }, { 14, new OpMemoryModel() }, { 15, new OpEntryPoint() }, { 16, new OpExecutionMode() }, { 17, new OpCapability() }, { 19, new OpTypeVoid() }, { 20, new OpTypeBool() }, { 21, new OpTypeInt() }, { 22, new OpTypeFloat() }, { 23, new OpTypeVector() }, { 24, new OpTypeMatrix() }, { 25, new OpTypeImage() }, { 26, new OpTypeSampler() }, { 27, new OpTypeSampledImage() }, { 28, new OpTypeArray() }, { 29, new OpTypeRuntimeArray() }, { 30, new OpTypeStruct() }, { 31, new OpTypeOpaque() }, { 32, new OpTypePointer() }, { 33, new OpTypeFunction() }, { 34, new OpTypeEvent() }, { 35, new OpTypeDeviceEvent() }, { 36, new OpTypeReserveId() }, { 37, new OpTypeQueue() }, { 38, new OpTypePipe() }, { 39, new OpTypeForwardPointer() }, { 41, new OpConstantTrue() }, { 42, new OpConstantFalse() }, { 43, new OpConstant() }, { 44, new OpConstantComposite() }, { 45, new OpConstantSampler() }, { 46, new OpConstantNull() }, { 48, new OpSpecConstantTrue() }, { 49, new OpSpecConstantFalse() }, { 50, new OpSpecConstant() }, { 51, new OpSpecConstantComposite() }, { 52, new OpSpecConstantOp() }, { 54, new OpFunction() }, { 55, new OpFunctionParameter() }, { 56, new OpFunctionEnd() }, { 57, new OpFunctionCall() }, { 59, new OpVariable() }, { 60, new OpImageTexelPointer() }, { 61, new OpLoad() }, { 62, new OpStore() }, { 63, new OpCopyMemory() }, { 64, new OpCopyMemorySized() }, { 65, new OpAccessChain() }, { 66, new OpInBoundsAccessChain() }, { 67, new OpPtrAccessChain() }, { 68, new OpArrayLength() }, { 69, new OpGenericPtrMemSemantics() }, { 70, new OpInBoundsPtrAccessChain() }, { 71, new OpDecorate() }, { 72, new OpMemberDecorate() }, { 73, new OpDecorationGroup() }, { 74, new OpGroupDecorate() }, { 75, new OpGroupMemberDecorate() }, { 77, new OpVectorExtractDynamic() }, { 78, new OpVectorInsertDynamic() }, { 79, new OpVectorShuffle() }, { 80, new OpCompositeConstruct() }, { 81, new OpCompositeExtract() }, { 82, new OpCompositeInsert() }, { 83, new OpCopyObject() }, { 84, new OpTranspose() }, { 86, new OpSampledImage() }, { 87, new OpImageSampleImplicitLod() }, { 88, new OpImageSampleExplicitLod() }, { 89, new OpImageSampleDrefImplicitLod() }, { 90, new OpImageSampleDrefExplicitLod() }, { 91, new OpImageSampleProjImplicitLod() }, { 92, new OpImageSampleProjExplicitLod() }, { 93, new OpImageSampleProjDrefImplicitLod() }, { 94, new OpImageSampleProjDrefExplicitLod() }, { 95, new OpImageFetch() }, { 96, new OpImageGather() }, { 97, new OpImageDrefGather() }, { 98, new OpImageRead() }, { 99, new OpImageWrite() }, { 100, new OpImage() }, { 101, new OpImageQueryFormat() }, { 102, new OpImageQueryOrder() }, { 103, new OpImageQuerySizeLod() }, { 104, new OpImageQuerySize() }, { 105, new OpImageQueryLod() }, { 106, new OpImageQueryLevels() }, { 107, new OpImageQuerySamples() }, { 109, new OpConvertFToU() }, { 110, new OpConvertFToS() }, { 111, new OpConvertSToF() }, { 112, new OpConvertUToF() }, { 113, new OpUConvert() }, { 114, new OpSConvert() }, { 115, new OpFConvert() }, { 116, new OpQuantizeToF16() }, { 117, new OpConvertPtrToU() }, { 118, new OpSatConvertSToU() }, { 119, new OpSatConvertUToS() }, { 120, new OpConvertUToPtr() }, { 121, new OpPtrCastToGeneric() }, { 122, new OpGenericCastToPtr() }, { 123, new OpGenericCastToPtrExplicit() }, { 124, new OpBitcast() }, { 126, new OpSNegate() }, { 127, new OpFNegate() }, { 128, new OpIAdd() }, { 129, new OpFAdd() }, { 130, new OpISub() }, { 131, new OpFSub() }, { 132, new OpIMul() }, { 133, new OpFMul() }, { 134, new OpUDiv() }, { 135, new OpSDiv() }, { 136, new OpFDiv() }, { 137, new OpUMod() }, { 138, new OpSRem() }, { 139, new OpSMod() }, { 140, new OpFRem() }, { 141, new OpFMod() }, { 142, new OpVectorTimesScalar() }, { 143, new OpMatrixTimesScalar() }, { 144, new OpVectorTimesMatrix() }, { 145, new OpMatrixTimesVector() }, { 146, new OpMatrixTimesMatrix() }, { 147, new OpOuterProduct() }, { 148, new OpDot() }, { 149, new OpIAddCarry() }, { 150, new OpISubBorrow() }, { 151, new OpUMulExtended() }, { 152, new OpSMulExtended() }, { 154, new OpAny() }, { 155, new OpAll() }, { 156, new OpIsNan() }, { 157, new OpIsInf() }, { 158, new OpIsFinite() }, { 159, new OpIsNormal() }, { 160, new OpSignBitSet() }, { 161, new OpLessOrGreater() }, { 162, new OpOrdered() }, { 163, new OpUnordered() }, { 164, new OpLogicalEqual() }, { 165, new OpLogicalNotEqual() }, { 166, new OpLogicalOr() }, { 167, new OpLogicalAnd() }, { 168, new OpLogicalNot() }, { 169, new OpSelect() }, { 170, new OpIEqual() }, { 171, new OpINotEqual() }, { 172, new OpUGreaterThan() }, { 173, new OpSGreaterThan() }, { 174, new OpUGreaterThanEqual() }, { 175, new OpSGreaterThanEqual() }, { 176, new OpULessThan() }, { 177, new OpSLessThan() }, { 178, new OpULessThanEqual() }, { 179, new OpSLessThanEqual() }, { 180, new OpFOrdEqual() }, { 181, new OpFUnordEqual() }, { 182, new OpFOrdNotEqual() }, { 183, new OpFUnordNotEqual() }, { 184, new OpFOrdLessThan() }, { 185, new OpFUnordLessThan() }, { 186, new OpFOrdGreaterThan() }, { 187, new OpFUnordGreaterThan() }, { 188, new OpFOrdLessThanEqual() }, { 189, new OpFUnordLessThanEqual() }, { 190, new OpFOrdGreaterThanEqual() }, { 191, new OpFUnordGreaterThanEqual() }, { 194, new OpShiftRightLogical() }, { 195, new OpShiftRightArithmetic() }, { 196, new OpShiftLeftLogical() }, { 197, new OpBitwiseOr() }, { 198, new OpBitwiseXor() }, { 199, new OpBitwiseAnd() }, { 200, new OpNot() }, { 201, new OpBitFieldInsert() }, { 202, new OpBitFieldSExtract() }, { 203, new OpBitFieldUExtract() }, { 204, new OpBitReverse() }, { 205, new OpBitCount() }, { 207, new OpDPdx() }, { 208, new OpDPdy() }, { 209, new OpFwidth() }, { 210, new OpDPdxFine() }, { 211, new OpDPdyFine() }, { 212, new OpFwidthFine() }, { 213, new OpDPdxCoarse() }, { 214, new OpDPdyCoarse() }, { 215, new OpFwidthCoarse() }, { 218, new OpEmitVertex() }, { 219, new OpEndPrimitive() }, { 220, new OpEmitStreamVertex() }, { 221, new OpEndStreamPrimitive() }, { 224, new OpControlBarrier() }, { 225, new OpMemoryBarrier() }, { 227, new OpAtomicLoad() }, { 228, new OpAtomicStore() }, { 229, new OpAtomicExchange() }, { 230, new OpAtomicCompareExchange() }, { 231, new OpAtomicCompareExchangeWeak() }, { 232, new OpAtomicIIncrement() }, { 233, new OpAtomicIDecrement() }, { 234, new OpAtomicIAdd() }, { 235, new OpAtomicISub() }, { 236, new OpAtomicSMin() }, { 237, new OpAtomicUMin() }, { 238, new OpAtomicSMax() }, { 239, new OpAtomicUMax() }, { 240, new OpAtomicAnd() }, { 241, new OpAtomicOr() }, { 242, new OpAtomicXor() }, { 245, new OpPhi() }, { 246, new OpLoopMerge() }, { 247, new OpSelectionMerge() }, { 248, new OpLabel() }, { 249, new OpBranch() }, { 250, new OpBranchConditional() }, { 251, new OpSwitch() }, { 252, new OpKill() }, { 253, new OpReturn() }, { 254, new OpReturnValue() }, { 255, new OpUnreachable() }, { 256, new OpLifetimeStart() }, { 257, new OpLifetimeStop() }, { 259, new OpGroupAsyncCopy() }, { 260, new OpGroupWaitEvents() }, { 261, new OpGroupAll() }, { 262, new OpGroupAny() }, { 263, new OpGroupBroadcast() }, { 264, new OpGroupIAdd() }, { 265, new OpGroupFAdd() }, { 266, new OpGroupFMin() }, { 267, new OpGroupUMin() }, { 268, new OpGroupSMin() }, { 269, new OpGroupFMax() }, { 270, new OpGroupUMax() }, { 271, new OpGroupSMax() }, { 274, new OpReadPipe() }, { 275, new OpWritePipe() }, { 276, new OpReservedReadPipe() }, { 277, new OpReservedWritePipe() }, { 278, new OpReserveReadPipePackets() }, { 279, new OpReserveWritePipePackets() }, { 280, new OpCommitReadPipe() }, { 281, new OpCommitWritePipe() }, { 282, new OpIsValidReserveId() }, { 283, new OpGetNumPipePackets() }, { 284, new OpGetMaxPipePackets() }, { 285, new OpGroupReserveReadPipePackets() }, { 286, new OpGroupReserveWritePipePackets() }, { 287, new OpGroupCommitReadPipe() }, { 288, new OpGroupCommitWritePipe() }, { 291, new OpEnqueueMarker() }, { 292, new OpEnqueueKernel() }, { 293, new OpGetKernelNDrangeSubGroupCount() }, { 294, new OpGetKernelNDrangeMaxSubGroupSize() }, { 295, new OpGetKernelWorkGroupSize() }, { 296, new OpGetKernelPreferredWorkGroupSizeMultiple() }, { 297, new OpRetainEvent() }, { 298, new OpReleaseEvent() }, { 299, new OpCreateUserEvent() }, { 300, new OpIsValidEvent() }, { 301, new OpSetUserEventStatus() }, { 302, new OpCaptureEventProfilingInfo() }, { 303, new OpGetDefaultQueue() }, { 304, new OpBuildNDRange() }, { 305, new OpImageSparseSampleImplicitLod() }, { 306, new OpImageSparseSampleExplicitLod() }, { 307, new OpImageSparseSampleDrefImplicitLod() }, { 308, new OpImageSparseSampleDrefExplicitLod() }, { 309, new OpImageSparseSampleProjImplicitLod() }, { 310, new OpImageSparseSampleProjExplicitLod() }, { 311, new OpImageSparseSampleProjDrefImplicitLod() }, { 312, new OpImageSparseSampleProjDrefExplicitLod() }, { 313, new OpImageSparseFetch() }, { 314, new OpImageSparseGather() }, { 315, new OpImageSparseDrefGather() }, { 316, new OpImageSparseTexelsResident() }, { 317, new OpNoLine() }, { 318, new OpAtomicFlagTestAndSet() }, { 319, new OpAtomicFlagClear() }, { 320, new OpImageSparseRead() }, { 321, new OpSizeOf() }, { 322, new OpTypePipeStorage() }, { 323, new OpConstantPipeStorage() }, { 324, new OpCreatePipeFromPipeStorage() }, { 325, new OpGetKernelLocalSizeForSubgroupCount() }, { 326, new OpGetKernelMaxNumSubgroups() }, { 327, new OpTypeNamedBarrier() }, { 328, new OpNamedBarrierInitialize() }, { 329, new OpMemoryNamedBarrier() }, { 330, new OpModuleProcessed() }, { 331, new OpExecutionModeId() }, { 332, new OpDecorateId() }, { 4421, new OpSubgroupBallotKHR() }, { 4422, new OpSubgroupFirstInvocationKHR() }, { 4428, new OpSubgroupAllKHR() }, { 4429, new OpSubgroupAnyKHR() }, { 4430, new OpSubgroupAllEqualKHR() }, { 4432, new OpSubgroupReadInvocationKHR() }, { 5000, new OpGroupIAddNonUniformAMD() }, { 5001, new OpGroupFAddNonUniformAMD() }, { 5002, new OpGroupFMinNonUniformAMD() }, { 5003, new OpGroupUMinNonUniformAMD() }, { 5004, new OpGroupSMinNonUniformAMD() }, { 5005, new OpGroupFMaxNonUniformAMD() }, { 5006, new OpGroupUMaxNonUniformAMD() }, { 5007, new OpGroupSMaxNonUniformAMD() }, { 5011, new OpFragmentMaskFetchAMD() }, { 5012, new OpFragmentFetchAMD() }, { 5571, new OpSubgroupShuffleINTEL() }, { 5572, new OpSubgroupShuffleDownINTEL() }, { 5573, new OpSubgroupShuffleUpINTEL() }, { 5574, new OpSubgroupShuffleXorINTEL() }, { 5575, new OpSubgroupBlockReadINTEL() }, { 5576, new OpSubgroupBlockWriteINTEL() }, { 5577, new OpSubgroupImageBlockReadINTEL() }, { 5578, new OpSubgroupImageBlockWriteINTEL() }, };
        public static IReadOnlyDictionary<int, Instruction> OpcodeToInstruction
        {
            get => instructions_;
        }
    }
}
```

`AssetStudioUtility/CSspv/SpirV.Meta.cs`:

```cs
using System.Collections.Generic;

namespace SpirV
{
	internal class Meta
    {
        public class ToolInfo
        {
            public ToolInfo(string vendor)
            {
                Vendor = vendor;
            }

            public ToolInfo(string vendor, string name)
            {
                Vendor = vendor;
                Name = name;
            }

            public string Name { get; }
            public string Vendor { get; }
        }

		public static uint MagicNumber => 119734787U;
		public static uint Version => 66048U;
		public static uint Revision => 2U;
		public static uint OpCodeMask => 65535U;
		public static uint WordCountShift => 16U;

		public static IReadOnlyDictionary<int, ToolInfo> Tools => toolInfos_;

		private readonly static Dictionary<int, ToolInfo> toolInfos_ = new Dictionary<int, ToolInfo>
		{
			{ 0, new ToolInfo("Khronos") },
			{ 1, new ToolInfo("LunarG") },
			{ 2, new ToolInfo("Valve") },
			{ 3, new ToolInfo("Codeplay") },
			{ 4, new ToolInfo("NVIDIA") },
			{ 5, new ToolInfo("ARM") },
			{ 6, new ToolInfo("Khronos", "LLVM/SPIR-V Translator") },
			{ 7, new ToolInfo("Khronos", "SPIR-V Tools Assembler") },
			{ 8, new ToolInfo("Khronos", "Glslang Reference Front End") },
			{ 9, new ToolInfo("Qualcomm") },
			{ 10, new ToolInfo("AMD") },
			{ 11, new ToolInfo("Intel") },
			{ 12, new ToolInfo("Imagination") },
			{ 13, new ToolInfo("Google", "Shaderc over Glslang") },
			{ 14, new ToolInfo("Google", "spiregg") },
			{ 15, new ToolInfo("Google", "rspirv") },
			{ 16, new ToolInfo("X-LEGEND", "Mesa-IR/SPIR-V Translator") },
			{ 17, new ToolInfo("Khronos", "SPIR-V Tools Linker") },
		};
	}
}
```

`AssetStudioUtility/CSspv/Types.cs`:

```cs
using System.Collections.Generic;
using System.Text;

namespace SpirV
{
	public class Type
	{
		public virtual StringBuilder ToString(StringBuilder sb)
		{
			return sb;
		}
	}

	public class VoidType : Type
	{
		public override string ToString()
		{
			return "void";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return sb.Append("void");
		}
	}

	public class ScalarType : Type
	{
	}

	public class BoolType : ScalarType
	{
		public override string ToString()
		{
			return "bool";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return sb.Append("bool");
		}
	}

	public class IntegerType : ScalarType
	{
		public IntegerType (int width, bool signed)
		{
			Width = width;
			Signed = signed;
		}

		public override string ToString()
		{
			if (Signed)
			{
				return $"i{Width}";
			}
			else
			{
				return $"u{Width}";
			}
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			if (Signed)
			{
				sb.Append('i').Append(Width);
			}
			else
			{
				sb.Append('u').Append(Width);
			}
			return sb;
		}

		public int Width { get; }
		public bool Signed { get; }
	}

	public class FloatingPointType : ScalarType
	{
		public FloatingPointType (int width)
		{
			Width = width;
		}

		public override string ToString()
		{
			return $"f{Width}";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return sb.Append('f').Append(Width);
		}

		public int Width { get; }
	}

	public class VectorType : Type
	{
		public VectorType (ScalarType scalarType, int componentCount)
		{
			ComponentType = scalarType;
			ComponentCount = componentCount;
		}

		public override string ToString()
		{
			return $"{ComponentType}_{ComponentCount}";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return ComponentType.ToString(sb).Append('_').Append(ComponentCount);
		}

		public ScalarType ComponentType { get; }
		public int ComponentCount { get; }
	}

	public class MatrixType : Type
	{
		public MatrixType (VectorType vectorType, int columnCount)
		{
			ColumnType = vectorType;
			ColumnCount = columnCount;
		}

		public override string ToString ()
		{
			return $"{ColumnType}x{ColumnCount}";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return sb.Append(ColumnType).Append('x').Append(ColumnCount);
		}

		public VectorType ColumnType { get; }
		public int ColumnCount { get; }
		public int RowCount => ColumnType.ComponentCount;
	}

	public class ImageType : Type
	{
		public ImageType (Type sampledType, Dim dim, int depth, bool isArray, bool isMultisampled, int sampleCount,
			ImageFormat imageFormat, AccessQualifier accessQualifier)
		{
			SampledType = sampledType;
			Dim = dim;
			Depth = depth;
			IsArray = isArray;
			IsMultisampled = isMultisampled;
			SampleCount = sampleCount;
			Format = imageFormat;
			AccessQualifier = accessQualifier;
		}

		public override string ToString ()
		{
			StringBuilder sb = new StringBuilder ();
			ToString(sb);
			return sb.ToString();
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			switch (AccessQualifier)
			{
				case AccessQualifier.ReadWrite:
					sb.Append("read_write ");
					break;
				case AccessQualifier.WriteOnly:
					sb.Append("write_only ");
					break;
				case AccessQualifier.ReadOnly:
					sb.Append("read_only ");
					break;
			}

			sb.Append("Texture");
			switch (Dim)
			{
				case Dim.Dim1D:
					sb.Append("1D");
					break;
				case Dim.Dim2D:
					sb.Append("2D");
					break;
				case Dim.Dim3D:
					sb.Append("3D");
					break;
				case Dim.Cube:
					sb.Append("Cube");
					break;
			}

			if (IsMultisampled)
			{
				sb.Append("MS");
			}
			if (IsArray)
			{
				sb.Append("Array");
			}
			return sb;
		}

		public Type SampledType { get; }
		public Dim Dim { get; }
		public int Depth { get; }
		public bool IsArray { get; }
		public bool IsMultisampled { get; }
		public int SampleCount { get; }
		public ImageFormat Format { get; }
		public AccessQualifier AccessQualifier { get; }
	}

	public class SamplerType : Type
	{
		public override string ToString()
		{
			return "sampler";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return sb.Append("sampler");
		}
	}

	public class SampledImageType : Type
	{
		public SampledImageType (ImageType imageType)
		{
			ImageType = imageType;
		}

		public override string ToString()
		{
			return $"{ImageType}Sampled";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return ImageType.ToString(sb).Append("Sampled");
		}

		public ImageType ImageType { get; }
	}

	public class ArrayType : Type
	{
		public ArrayType (Type elementType, int elementCount)
		{
			ElementType = elementType;
			ElementCount = elementCount;
		}

		public override string ToString()
		{
			return $"{ElementType}[{ElementCount}]";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return ElementType.ToString(sb).Append('[').Append(ElementCount).Append(']');
		}

		public int ElementCount { get; }
		public Type ElementType { get; }
	}

	public class RuntimeArrayType : Type
	{
		public RuntimeArrayType(Type elementType)
		{
			ElementType = elementType;
		}

		public Type ElementType { get; }
	}

	public class StructType : Type
	{
		public StructType(IReadOnlyList<Type> memberTypes)
		{
			MemberTypes = memberTypes;
			memberNames_ = new List<string>();

			for (int i = 0; i < memberTypes.Count; ++i)
			{
				memberNames_.Add(string.Empty);
			}
		}

		public void SetMemberName(uint member, string name)
		{
			memberNames_[(int)member] = name;
		}

		public override string ToString()
		{
			StringBuilder sb = new StringBuilder();
			ToString(sb);
			return sb.ToString();
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			sb.Append("struct {");
			for (int i = 0; i < MemberTypes.Count; ++i)
			{
				Type memberType = MemberTypes[i];
				memberType.ToString(sb);
				if (!string.IsNullOrEmpty(memberNames_[i]))
				{
					sb.Append(' ');
					sb.Append(MemberNames[i]);
				}

				sb.Append(';');
				if (i < (MemberTypes.Count - 1))
				{
					sb.Append(' ');
				}
			}
			sb.Append('}');
			return sb;
		}

		public IReadOnlyList<Type> MemberTypes { get; }
		public IReadOnlyList<string> MemberNames => memberNames_;

		private List<string> memberNames_;
	}

	public class OpaqueType : Type
	{
	}

	public class PointerType : Type
	{
		public PointerType(StorageClass storageClass, Type type)
		{
			StorageClass = storageClass;
			Type = type;
		}

		public PointerType(StorageClass storageClass)
		{
			StorageClass = storageClass;
		}

		public void ResolveForwardReference(Type t)
		{
			Type = t;
		}

		public override string ToString()
		{
			if (Type == null)
			{
				return $"{StorageClass} *";
			}
			else
			{
				return $"{StorageClass} {Type}*";
			}
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			sb.Append(StorageClass.ToString()).Append(' ');
			if (Type != null)
			{
				Type.ToString(sb);
			}
			sb.Append('*');
			return sb;
		}

		public StorageClass StorageClass { get; }
		public Type Type { get; private set; }
	}

	public class FunctionType : Type
	{
		public FunctionType(Type returnType, IReadOnlyList<Type> parameterTypes)
		{
			ReturnType = returnType;
			ParameterTypes = parameterTypes;
		}

		public Type ReturnType { get; }
		public IReadOnlyList<Type> ParameterTypes { get; }
	}

	public class EventType : Type
	{
	}

	public class DeviceEventType : Type
	{
	}

	public class ReserveIdType : Type
	{
	}

	public class QueueType : Type
	{
	}

	public class PipeType : Type
	{
	}

	public class PipeStorage : Type
	{
	}

	public class NamedBarrier : Type
	{
	}
}

```

`AssetStudioUtility/FMOD Studio API/fmod.cs`:

```cs
/* ========================================================================================== */
/*                                                                                            */
/* FMOD Studio - C# Wrapper . Copyright (c), Firelight Technologies Pty, Ltd. 2004-2016.      */
/*                                                                                            */
/* ========================================================================================== */

using System;
using System.Text;
using System.Runtime.InteropServices;
using AssetStudio.PInvoke;

namespace FMOD
{
    /*
        FMOD version number.  Check this against FMOD::System::getVersion / System_GetVersion
        0xaaaabbcc -> aaaa = major version number.  bb = minor version number.  cc = development version number.
    */
    public class VERSION
    {
        public const int    number = 0x00010716;
#if WIN64
        public const string dll    = "fmod64";
#else
        public const string dll    = "fmod";
#endif
    }

    public class CONSTANTS
    {
        public const int MAX_CHANNEL_WIDTH = 32;
        public const int MAX_LISTENERS = 8;
    }

    /*
        FMOD types
    */

    /*
    [ENUM]
    [
        [DESCRIPTION]
        error codes.  Returned from every function.

        [REMARKS]

        [SEE_ALSO]
    ]
    */
    public enum RESULT : int
    {
        OK,                        /* No errors. */
        ERR_BADCOMMAND,            /* Tried to call a function on a data type that does not allow this type of functionality (ie calling Sound::lock on a streaming sound). */
        ERR_CHANNEL_ALLOC,         /* Error trying to allocate a channel. */
        ERR_CHANNEL_STOLEN,        /* The specified channel has been reused to play another sound. */
        ERR_DMA,                   /* DMA Failure.  See debug output for more information. */
        ERR_DSP_CONNECTION,        /* DSP connection error.  Connection possibly caused a cyclic dependency or connected dsps with incompatible buffer counts. */
        ERR_DSP_DONTPROCESS,       /* DSP return code from a DSP process query callback.  Tells mixer not to call the process callback and therefore not consume CPU.  Use this to optimize the DSP graph. */
        ERR_DSP_FORMAT,            /* DSP Format error.  A DSP unit may have attempted to connect to this network with the wrong format, or a matrix may have been set with the wrong size if the target unit has a specified channel map. */
        ERR_DSP_INUSE,             /* DSP is already in the mixer's DSP network. It must be removed before being reinserted or released. */
        ERR_DSP_NOTFOUND,          /* DSP connection error.  Couldn't find the DSP unit specified. */
        ERR_DSP_RESERVED,          /* DSP operation error.  Cannot perform operation on this DSP as it is reserved by the system. */
        ERR_DSP_SILENCE,           /* DSP return code from a DSP process query callback.  Tells mixer silence would be produced from read, so go idle and not consume CPU.  Use this to optimize the DSP graph. */
        ERR_DSP_TYPE,              /* DSP operation cannot be performed on a DSP of this type. */
        ERR_FILE_BAD,              /* Error loading file. */
        ERR_FILE_COULDNOTSEEK,     /* Couldn't perform seek operation.  This is a limitation of the medium (ie netstreams) or the file format. */
        ERR_FILE_DISKEJECTED,      /* Media was ejected while reading. */
        ERR_FILE_EOF,              /* End of file unexpectedly reached while trying to read essential data (truncated?). */
        ERR_FILE_ENDOFDATA,        /* End of current chunk reached while trying to read data. */
        ERR_FILE_NOTFOUND,         /* File not found. */
        ERR_FORMAT,                /* Unsupported file or audio format. */
        ERR_HEADER_MISMATCH,       /* There is a version mismatch between the FMOD header and either the FMOD Studio library or the FMOD Low Level library. */
        ERR_HTTP,                  /* A HTTP error occurred. This is a catch-all for HTTP errors not listed elsewhere. */
        ERR_HTTP_ACCESS,           /* The specified resource requires authentication or is forbidden. */
        ERR_HTTP_PROXY_AUTH,       /* Proxy authentication is required to access the specified resource. */
        ERR_HTTP_SERVER_ERROR,     /* A HTTP server error occurred. */
        ERR_HTTP_TIMEOUT,          /* The HTTP request timed out. */
        ERR_INITIALIZATION,        /* FMOD was not initialized correctly to support this function. */
        ERR_INITIALIZED,           /* Cannot call this command after System::init. */
        ERR_INTERNAL,              /* An error occurred that wasn't supposed to.  Contact support. */
        ERR_INVALID_FLOAT,         /* Value passed in was a NaN, Inf or denormalized float. */
        ERR_INVALID_HANDLE,        /* An invalid object handle was used. */
        ERR_INVALID_PARAM,         /* An invalid parameter was passed to this function. */
        ERR_INVALID_POSITION,      /* An invalid seek position was passed to this function. */
        ERR_INVALID_SPEAKER,       /* An invalid speaker was passed to this function based on the current speaker mode. */
        ERR_INVALID_SYNCPOINT,     /* The syncpoint did not come from this sound handle. */
        ERR_INVALID_THREAD,        /* Tried to call a function on a thread that is not supported. */
        ERR_INVALID_VECTOR,        /* The vectors passed in are not unit length, or perpendicular. */
        ERR_MAXAUDIBLE,            /* Reached maximum audible playback count for this sound's soundgroup. */
        ERR_MEMORY,                /* Not enough memory or resources. */
        ERR_MEMORY_CANTPOINT,      /* Can't use FMOD_OPENMEMORY_POINT on non PCM source data, or non mp3/xma/adpcm data if FMOD_CREATECOMPRESSEDSAMPLE was used. */
        ERR_NEEDS3D,               /* Tried to call a command on a 2d sound when the command was meant for 3d sound. */
        ERR_NEEDSHARDWARE,         /* Tried to use a feature that requires hardware support. */
        ERR_NET_CONNECT,           /* Couldn't connect to the specified host. */
        ERR_NET_SOCKET_ERROR,      /* A socket error occurred.  This is a catch-all for socket-related errors not listed elsewhere. */
        ERR_NET_URL,               /* The specified URL couldn't be resolved. */
        ERR_NET_WOULD_BLOCK,       /* Operation on a non-blocking socket could not complete immediately. */
        ERR_NOTREADY,              /* Operation could not be performed because specified sound/DSP connection is not ready. */
        ERR_OUTPUT_ALLOCATED,      /* Error initializing output device, but more specifically, the output device is already in use and cannot be reused. */
        ERR_OUTPUT_CREATEBUFFER,   /* Error creating hardware sound buffer. */
        ERR_OUTPUT_DRIVERCALL,     /* A call to a standard soundcard driver failed, which could possibly mean a bug in the driver or resources were missing or exhausted. */
        ERR_OUTPUT_FORMAT,         /* Soundcard does not support the specified format. */
        ERR_OUTPUT_INIT,           /* Error initializing output device. */
        ERR_OUTPUT_NODRIVERS,      /* The output device has no drivers installed.  If pre-init, FMOD_OUTPUT_NOSOUND is selected as the output mode.  If post-init, the function just fails. */
        ERR_PLUGIN,                /* An unspecified error has been returned from a plugin. */
        ERR_PLUGIN_MISSING,        /* A requested output, dsp unit type or codec was not available. */
        ERR_PLUGIN_RESOURCE,       /* A resource that the plugin requires cannot be found. (ie the DLS file for MIDI playback) */
        ERR_PLUGIN_VERSION,        /* A plugin was built with an unsupported SDK version. */
        ERR_RECORD,                /* An error occurred trying to initialize the recording device. */
        ERR_REVERB_CHANNELGROUP,   /* Reverb properties cannot be set on this channel because a parent channelgroup owns the reverb connection. */
        ERR_REVERB_INSTANCE,       /* Specified instance in FMOD_REVERB_PROPERTIES couldn't be set. Most likely because it is an invalid instance number or the reverb doesn't exist. */
        ERR_SUBSOUNDS,             /* The error occurred because the sound referenced contains subsounds when it shouldn't have, or it doesn't contain subsounds when it should have.  The operation may also not be able to be performed on a parent sound. */
        ERR_SUBSOUND_ALLOCATED,    /* This subsound is already being used by another sound, you cannot have more than one parent to a sound.  Null out the other parent's entry first. */
        ERR_SUBSOUND_CANTMOVE,     /* Shared subsounds cannot be replaced or moved from their parent stream, such as when the parent stream is an FSB file. */
        ERR_TAGNOTFOUND,           /* The specified tag could not be found or there are no tags. */
        ERR_TOOMANYCHANNELS,       /* The sound created exceeds the allowable input channel count.  This can be increased using the 'maxinputchannels' parameter in System::setSoftwareFormat. */
        ERR_TRUNCATED,             /* The retrieved string is too long to fit in the supplied buffer and has been truncated. */
        ERR_UNIMPLEMENTED,         /* Something in FMOD hasn't been implemented when it should be! contact support! */
        ERR_UNINITIALIZED,         /* This command failed because System::init or System::setDriver was not called. */
        ERR_UNSUPPORTED,           /* A command issued was not supported by this object.  Possibly a plugin without certain callbacks specified. */
        ERR_VERSION,               /* The version number of this file format is not supported. */
        ERR_EVENT_ALREADY_LOADED,  /* The specified bank has already been loaded. */
        ERR_EVENT_LIVEUPDATE_BUSY, /* The live update connection failed due to the game already being connected. */
        ERR_EVENT_LIVEUPDATE_MISMATCH, /* The live update connection failed due to the game data being out of sync with the tool. */
        ERR_EVENT_LIVEUPDATE_TIMEOUT, /* The live update connection timed out. */
        ERR_EVENT_NOTFOUND,        /* The requested event, bus or vca could not be found. */
        ERR_STUDIO_UNINITIALIZED,  /* The Studio::System object is not yet initialized. */
        ERR_STUDIO_NOT_LOADED,     /* The specified resource is not loaded, so it can't be unloaded. */
        ERR_INVALID_STRING,        /* An invalid string was passed to this function. */
        ERR_ALREADY_LOCKED,        /* The specified resource is already locked. */
        ERR_NOT_LOCKED,            /* The specified resource is not locked, so it can't be unlocked. */
        ERR_RECORD_DISCONNECTED,   /* The specified recording driver has been disconnected. */
        ERR_TOOMANYSAMPLES,        /* The length provided exceed the allowable limit. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Used to distinguish if a FMOD_CHANNELCONTROL parameter is actually a channel or a channelgroup.

        [REMARKS]
        Cast the FMOD_CHANNELCONTROL to an FMOD_CHANNEL/FMOD::Channel, or FMOD_CHANNELGROUP/FMOD::ChannelGroup if specific functionality is needed for either class.
        Otherwise use as FMOD_CHANNELCONTROL/FMOD::ChannelControl and use that API.

        [SEE_ALSO]
        Channel::setCallback
        ChannelGroup::setCallback
    ]
    */
    public enum CHANNELCONTROL_TYPE : int
    {
        CHANNEL,
        CHANNELGROUP
    }

    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Structure describing a point in 3D space.

        [REMARKS]
        FMOD uses a left handed co-ordinate system by default.
        To use a right handed co-ordinate system specify FMOD_INIT_3D_RIGHTHANDED from FMOD_INITFLAGS in System::init.

        [SEE_ALSO]
        System::set3DListenerAttributes
        System::get3DListenerAttributes
        Channel::set3DAttributes
        Channel::get3DAttributes
        Geometry::addPolygon
        Geometry::setPolygonVertex
        Geometry::getPolygonVertex
        Geometry::setRotation
        Geometry::getRotation
        Geometry::setPosition
        Geometry::getPosition
        Geometry::setScale
        Geometry::getScale
        FMOD_INITFLAGS
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct VECTOR
    {
        public float x;        /* X co-ordinate in 3D space. */
        public float y;        /* Y co-ordinate in 3D space. */
        public float z;        /* Z co-ordinate in 3D space. */
    }

    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Structure describing a position, velocity and orientation.

        [REMARKS]

        [SEE_ALSO]
        FMOD_VECTOR
        FMOD_DSP_PARAMETER_3DATTRIBUTES
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct _3D_ATTRIBUTES
    {
        VECTOR position;
        VECTOR velocity;
        VECTOR forward;
        VECTOR up;
    }

    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Structure that is passed into FMOD_FILE_ASYNCREAD_CALLBACK.  Use the information in this structure to perform

        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.<br>
        Members marked with [w] mean the variable can be written to.  The user can set the value.<br>
        <br>
        Instructions: write to 'buffer', and 'bytesread' <b>BEFORE</b> setting 'result'.<br>
        As soon as result is set, FMOD will asynchronously continue internally using the data provided in this structure.<br>
        <br>
        Set 'result' to the result expected from a normal file read callback.<br>
        If the read was successful, set it to FMOD_OK.<br>
        If it read some data but hit the end of the file, set it to FMOD_ERR_FILE_EOF.<br>
        If a bad error occurred, return FMOD_ERR_FILE_BAD<br>
        If a disk was ejected, return FMOD_ERR_FILE_DISKEJECTED.<br>

        [SEE_ALSO]
        FMOD_FILE_ASYNCREAD_CALLBACK
        FMOD_FILE_ASYNCCANCEL_CALLBACK
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct ASYNCREADINFO
    {
        public IntPtr   handle;                     /* [r] The file handle that was filled out in the open callback. */
        public uint     offset;                     /* [r] Seek position, make sure you read from this file offset. */
        public uint     sizebytes;                  /* [r] how many bytes requested for read. */
        public int      priority;                   /* [r] 0 = low importance.  100 = extremely important (ie 'must read now or stuttering may occur') */

        public IntPtr   userdata;                   /* [r] User data pointer. */
        public IntPtr   buffer;                     /* [w] Buffer to read file data into. */
        public uint     bytesread;                  /* [w] Fill this in before setting result code to tell FMOD how many bytes were read. */
        public ASYNCREADINFO_DONE_CALLBACK   done;  /* [r] FMOD file system wake up function.  Call this when user file read is finished.  Pass result of file read as a parameter. */

    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        These output types are used with System::setOutput / System::getOutput, to choose which output method to use.

        [REMARKS]
        To pass information to the driver when initializing fmod use the *extradriverdata* parameter in System::init for the following reasons.

        - FMOD_OUTPUTTYPE_WAVWRITER     - extradriverdata is a pointer to a char * file name that the wav writer will output to.
        - FMOD_OUTPUTTYPE_WAVWRITER_NRT - extradriverdata is a pointer to a char * file name that the wav writer will output to.
        - FMOD_OUTPUTTYPE_DSOUND        - extradriverdata is cast to a HWND type, so that FMOD can set the focus on the audio for a particular window.
        - FMOD_OUTPUTTYPE_PS3           - extradriverdata is a pointer to a FMOD_PS3_EXTRADRIVERDATA struct. This can be found in fmodps3.h.
        - FMOD_OUTPUTTYPE_XBOX360       - extradriverdata is a pointer to a FMOD_360_EXTRADRIVERDATA struct. This can be found in fmodxbox360.h.

        Currently these are the only FMOD drivers that take extra information.  Other unknown plugins may have different requirements.
    
        Note! If FMOD_OUTPUTTYPE_WAVWRITER_NRT or FMOD_OUTPUTTYPE_NOSOUND_NRT are used, and if the System::update function is being called
        very quickly (ie for a non realtime decode) it may be being called too quickly for the FMOD streamer thread to respond to.
        The result will be a skipping/stuttering output in the captured audio.
    
        To remedy this, disable the FMOD streamer thread, and use FMOD_INIT_STREAM_FROM_UPDATE to avoid skipping in the output stream,
        as it will lock the mixer and the streamer together in the same thread.
    
        [SEE_ALSO]
            System::setOutput
            System::getOutput
            System::setSoftwareFormat
            System::getSoftwareFormat
            System::init
            System::update
            FMOD_INITFLAGS
    ]
    */
    public enum OUTPUTTYPE : int
    {
        AUTODETECT,      /* Picks the best output mode for the platform. This is the default. */

        UNKNOWN,         /* All - 3rd party plugin, unknown. This is for use with System::getOutput only. */
        NOSOUND,         /* All - Perform all mixing but discard the final output. */
        WAVWRITER,       /* All - Writes output to a .wav file. */
        NOSOUND_NRT,     /* All - Non-realtime version of FMOD_OUTPUTTYPE_NOSOUND. User can drive mixer with System::update at whatever rate they want. */
        WAVWRITER_NRT,   /* All - Non-realtime version of FMOD_OUTPUTTYPE_WAVWRITER. User can drive mixer with System::update at whatever rate they want. */

        DSOUND,          /* Win                  - Direct Sound.                        (Default on Windows XP and below) */
        WINMM,           /* Win                  - Windows Multimedia. */
        WASAPI,          /* Win/WinStore/XboxOne - Windows Audio Session API.           (Default on Windows Vista and above, Xbox One and Windows Store Applications) */
        ASIO,            /* Win                  - Low latency ASIO 2.0. */
        PULSEAUDIO,      /* Linux                - Pulse Audio.                         (Default on Linux if available) */
        ALSA,            /* Linux                - Advanced Linux Sound Architecture.   (Default on Linux if PulseAudio isn't available) */
        COREAUDIO,       /* Mac/iOS              - Core Audio.                          (Default on Mac and iOS) */
        XBOX360,         /* Xbox 360             - XAudio.                              (Default on Xbox 360) */
        PS3,             /* PS3                  - Audio Out.                           (Default on PS3) */
        AUDIOTRACK,      /* Android              - Java Audio Track.                    (Default on Android 2.2 and below) */
        OPENSL,          /* Android              - OpenSL ES.                           (Default on Android 2.3 and above) */
        WIIU,            /* Wii U                - AX.                                  (Default on Wii U) */
        AUDIOOUT,        /* PS4/PSVita           - Audio Out.                           (Default on PS4 and PS Vita) */

        MAX,             /* Maximum number of output types supported. */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        Specify the destination of log output when using the logging version of FMOD.

        [REMARKS]
        TTY destination can vary depending on platform, common examples include the
        Visual Studio / Xcode output window, stderr and LogCat.

        [SEE_ALSO]
        FMOD_Debug_Initialize
    ]
    */
    public enum DEBUG_MODE : int
    {
        TTY,        /* Default log location per platform, i.e. Visual Studio output window, stderr, LogCat, etc */
        FILE,       /* Write log to specified file path */
        CALLBACK,   /* Call specified callback with log information */
    }

    /*
    [DEFINE]
    [
        [NAME]
        FMOD_DEBUG_FLAGS

        [DESCRIPTION]
        Specify the requested information to be output when using the logging version of FMOD.

        [REMARKS]

        [SEE_ALSO]
        FMOD_Debug_Initialize
    ]
    */
    [Flags]
    public enum DEBUG_FLAGS : uint
    {
        NONE                    = 0x00000000,   /* Disable all messages */
        ERROR                   = 0x00000001,   /* Enable only error messages. */
        WARNING                 = 0x00000002,   /* Enable warning and error messages. */
        LOG                     = 0x00000004,   /* Enable informational, warning and error messages (default). */

        TYPE_MEMORY             = 0x00000100,   /* Verbose logging for memory operations, only use this if you are debugging a memory related issue. */
        TYPE_FILE               = 0x00000200,   /* Verbose logging for file access, only use this if you are debugging a file related issue. */
        TYPE_CODEC              = 0x00000400,   /* Verbose logging for codec initialization, only use this if you are debugging a codec related issue. */
        TYPE_TRACE              = 0x00000800,   /* Verbose logging for internal errors, use this for tracking the origin of error codes. */

        DISPLAY_TIMESTAMPS      = 0x00010000,   /* Display the time stamp of the log message in milliseconds. */
        DISPLAY_LINENUMBERS     = 0x00020000,   /* Display the source code file and line number for where the message originated. */
        DISPLAY_THREAD          = 0x00040000,   /* Display the thread ID of the calling function that generated the message. */
    }

    /*
    [DEFINE]
    [
        [NAME]
        FMOD_MEMORY_TYPE

        [DESCRIPTION]
        Bit fields for memory allocation type being passed into FMOD memory callbacks.

        [REMARKS]
        Remember this is a bitfield.  You may get more than 1 bit set (ie physical + persistent) so do not simply switch on the types!  You must check each bit individually or clear out the bits that you do not want within the callback.<br>
        Bits can be excluded if you want during Memory_Initialize so that you never get them.

        [SEE_ALSO]
        FMOD_MEMORY_ALLOC_CALLBACK
        FMOD_MEMORY_REALLOC_CALLBACK
        FMOD_MEMORY_FREE_CALLBACK
        Memory_Initialize
    ]
    */
    [Flags]
    public enum MEMORY_TYPE : uint
    {
        NORMAL             = 0x00000000,       /* Standard memory. */
        STREAM_FILE        = 0x00000001,       /* Stream file buffer, size controllable with System::setStreamBufferSize. */
        STREAM_DECODE      = 0x00000002,       /* Stream decode buffer, size controllable with FMOD_CREATESOUNDEXINFO::decodebuffersize. */
        SAMPLEDATA         = 0x00000004,       /* Sample data buffer.  Raw audio data, usually PCM/MPEG/ADPCM/XMA data. */
        DSP_BUFFER         = 0x00000008,       /* DSP memory block allocated when more than 1 output exists on a DSP node. */
        PLUGIN             = 0x00000010,       /* Memory allocated by a third party plugin. */
        XBOX360_PHYSICAL   = 0x00100000,       /* Requires XPhysicalAlloc / XPhysicalFree. */
        PERSISTENT         = 0x00200000,       /* Persistent memory. Memory will be freed when System::release is called. */
        SECONDARY          = 0x00400000,       /* Secondary memory. Allocation should be in secondary memory. For example RSX on the PS3. */
        ALL                = 0xFFFFFFFF
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        These are speaker types defined for use with the System::setSoftwareFormat command.

        [REMARKS]
        Note below the phrase 'sound channels' is used.  These are the subchannels inside a sound, they are not related and
        have nothing to do with the FMOD class "Channel".<br>
        For example a mono sound has 1 sound channel, a stereo sound has 2 sound channels, and an AC3 or 6 channel wav file have 6 "sound channels".<br>
        <br>
        FMOD_SPEAKERMODE_RAW<br>
        ---------------------<br>
        This mode is for output devices that are not specifically mono/stereo/quad/surround/5.1 or 7.1, but are multichannel.<br>
        Use System::setSoftwareFormat to specify the number of speakers you want to address, otherwise it will default to 2 (stereo).<br>
        Sound channels map to speakers sequentially, so a mono sound maps to output speaker 0, stereo sound maps to output speaker 0 & 1.<br>
        The user assumes knowledge of the speaker order.  FMOD_SPEAKER enumerations may not apply, so raw channel indices should be used.<br>
        Multichannel sounds map input channels to output channels 1:1. <br>
        Channel::setPan and Channel::setPanLevels do not work.<br>
        Speaker levels must be manually set with Channel::setPanMatrix.<br>
        <br>
        FMOD_SPEAKERMODE_MONO<br>
        ---------------------<br>
        This mode is for a 1 speaker arrangement.<br>
        Panning does not work in this speaker mode.<br>
        Mono, stereo and multichannel sounds have each sound channel played on the one speaker unity.<br>
        Mix behavior for multichannel sounds can be set with Channel::setPanMatrix.<br>
        Channel::setPanLevels does not work.<br>
        <br>
        FMOD_SPEAKERMODE_STEREO<br>
        -----------------------<br>
        This mode is for 2 speaker arrangements that have a left and right speaker.<br>
        <li>Mono sounds default to an even distribution between left and right.  They can be panned with Channel::setPan.<br>
        <li>Stereo sounds default to the middle, or full left in the left speaker and full right in the right speaker.
        <li>They can be cross faded with Channel::setPan.<br>
        <li>Multichannel sounds have each sound channel played on each speaker at unity.<br>
        <li>Mix behavior for multichannel sounds can be set with Channel::setPanMatrix.<br>
        <li>Channel::setPanLevels works but only front left and right parameters are used, the rest are ignored.<br>
        <br>
        FMOD_SPEAKERMODE_QUAD<br>
        ------------------------<br>
        This mode is for 4 speaker arrangements that have a front left, front right, surround left and a surround right speaker.<br>
        <li>Mono sounds default to an even distribution between front left and front right.  They can be panned with Channel::setPan.<br>
        <li>Stereo sounds default to the left sound channel played on the front left, and the right sound channel played on the front right.<br>
        <li>They can be cross faded with Channel::setPan.<br>
        <li>Multichannel sounds default to all of their sound channels being played on each speaker in order of input.<br>
        <li>Mix behavior for multichannel sounds can be set with Channel::setPanMatrix.<br>
        <li>Channel::setPanLevels works but rear left, rear right, center and lfe are ignored.<br>
        <br>
        FMOD_SPEAKERMODE_SURROUND<br>
        ------------------------<br>
        This mode is for 5 speaker arrangements that have a left/right/center/surround left/surround right.<br>
        <li>Mono sounds default to the center speaker.  They can be panned with Channel::setPan.<br>
        <li>Stereo sounds default to the left sound channel played on the front left, and the right sound channel played on the front right.
        <li>They can be cross faded with Channel::setPan.<br>
        <li>Multichannel sounds default to all of their sound channels being played on each speaker in order of input.
        <li>Mix behavior for multichannel sounds can be set with Channel::setPanMatrix.<br>
        <li>Channel::setPanLevels works but rear left / rear right are ignored.<br>
        <br>
        FMOD_SPEAKERMODE_5POINT1<br>
        ---------------------------------------------------------<br>
        This mode is for 5.1 speaker arrangements that have a left/right/center/surround left/surround right and a subwoofer speaker.<br>
        <li>Mono sounds default to the center speaker.  They can be panned with Channel::setPan.<br>
        <li>Stereo sounds default to the left sound channel played on the front left, and the right sound channel played on the front right.
        <li>They can be cross faded with Channel::setPan.<br>
        <li>Multichannel sounds default to all of their sound channels being played on each speaker in order of input.
        <li>Mix behavior for multichannel sounds can be set with Channel::setPanMatrix.<br>
        <li>Channel::setPanLevels works but rear left / rear right are ignored.<br>
        <br>
        FMOD_SPEAKERMODE_7POINT1<br>
        ------------------------<br>
        This mode is for 7.1 speaker arrangements that have a left/right/center/surround left/surround right/rear left/rear right
        and a subwoofer speaker.<br>
        <li>Mono sounds default to the center speaker.  They can be panned with Channel::setPan.<br>
        <li>Stereo sounds default to the left sound channel played on the front left, and the right sound channel played on the front right.
        <li>They can be cross faded with Channel::setPan.<br>
        <li>Multichannel sounds default to all of their sound channels being played on each speaker in order of input.
        <li>Mix behavior for multichannel sounds can be set with Channel::setPanMatrix.<br>
        <li>Channel::setPanLevels works and every parameter is used to set the balance of a sound in any speaker.<br>
        <br>

        [SEE_ALSO]
        System::setSoftwareFormat
        System::getSoftwareFormat
        DSP::setChannelFormat
    ]
    */
    public enum SPEAKERMODE : int
    {
        DEFAULT,          /* Default speaker mode based on operating system/output mode.  Windows = control panel setting, Xbox = 5.1, PS3 = 7.1 etc. */
        RAW,              /* There is no specific speakermode.  Sound channels are mapped in order of input to output.  Use System::setSoftwareFormat to specify speaker count. See remarks for more information. */
        MONO,             /* The speakers are monaural. */
        STEREO,           /* The speakers are stereo. */
        QUAD,             /* 4 speaker setup.  This includes front left, front right, surround left, surround right.  */
        SURROUND,         /* 5 speaker setup.  This includes front left, front right, center, surround left, surround right. */
        _5POINT1,         /* 5.1 speaker setup.  This includes front left, front right, center, surround left, surround right and an LFE speaker. */
        _7POINT1,         /* 7.1 speaker setup.  This includes front left, front right, center, surround left, surround right, back left, back right and an LFE speaker. */

        MAX,              /* Maximum number of speaker modes supported. */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        Assigns an enumeration for a speaker index.

        [REMARKS]

        [SEE_ALSO]
        System::setSpeakerPosition
        System::getSpeakerPosition
    ]
    */
    public enum SPEAKER : int
    {
        FRONT_LEFT,
        FRONT_RIGHT,
        FRONT_CENTER,
        LOW_FREQUENCY,
        SURROUND_LEFT,
        SURROUND_RIGHT,
        BACK_LEFT,
        BACK_RIGHT,

        MAX,               /* Maximum number of speaker types supported. */
    }

    /*
    [DEFINE]
    [
        [NAME]
        FMOD_CHANNELMASK

        [DESCRIPTION]
        These are bitfields to describe for a certain number of channels in a signal, which channels are being represented.<br>
        For example, a signal could be 1 channel, but contain the LFE channel only.<br>

        [REMARKS]
        FMOD_CHANNELMASK_BACK_CENTER is not represented as an output speaker in fmod - but it is encountered in input formats and is down or upmixed appropriately to the nearest speakers.<br>

        [SEE_ALSO]
        DSP::setChannelFormat
        DSP::getChannelFormat
        FMOD_SPEAKERMODE
    ]
    */
    [Flags]
    public enum CHANNELMASK : uint
    {
        FRONT_LEFT             = 0x00000001,
        FRONT_RIGHT            = 0x00000002,
        FRONT_CENTER           = 0x00000004,
        LOW_FREQUENCY          = 0x00000008,
        SURROUND_LEFT          = 0x00000010,
        SURROUND_RIGHT         = 0x00000020,
        BACK_LEFT              = 0x00000040,
        BACK_RIGHT             = 0x00000080,
        BACK_CENTER            = 0x00000100,

        MONO                   = (FRONT_LEFT),
        STEREO                 = (FRONT_LEFT | FRONT_RIGHT),
        LRC                    = (FRONT_LEFT | FRONT_RIGHT | FRONT_CENTER),
        QUAD                   = (FRONT_LEFT | FRONT_RIGHT | SURROUND_LEFT | SURROUND_RIGHT),
        SURROUND               = (FRONT_LEFT | FRONT_RIGHT | FRONT_CENTER | SURROUND_LEFT | SURROUND_RIGHT),
        _5POINT1               = (FRONT_LEFT | FRONT_RIGHT | FRONT_CENTER | LOW_FREQUENCY | SURROUND_LEFT | SURROUND_RIGHT),
        _5POINT1_REARS         = (FRONT_LEFT | FRONT_RIGHT | FRONT_CENTER | LOW_FREQUENCY | BACK_LEFT | BACK_RIGHT),
        _7POINT0               = (FRONT_LEFT | FRONT_RIGHT | FRONT_CENTER | SURROUND_LEFT | SURROUND_RIGHT | BACK_LEFT | BACK_RIGHT),
        _7POINT1               = (FRONT_LEFT | FRONT_RIGHT | FRONT_CENTER | LOW_FREQUENCY | SURROUND_LEFT | SURROUND_RIGHT | BACK_LEFT | BACK_RIGHT)
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        When creating a multichannel sound, FMOD will pan them to their default speaker locations, for example a 6 channel sound will default to one channel per 5.1 output speaker.<br>
        Another example is a stereo sound.  It will default to left = front left, right = front right.<br>
        <br>
        This is for sounds that are not 'default'.  For example you might have a sound that is 6 channels but actually made up of 3 stereo pairs, that should all be located in front left, front right only.

        [REMARKS]

        [SEE_ALSO]
        FMOD_CREATESOUNDEXINFO
    ]
    */
    public enum CHANNELORDER : int
    {
        DEFAULT,              /* Left, Right, Center, LFE, Surround Left, Surround Right, Back Left, Back Right (see FMOD_SPEAKER enumeration)   */
        WAVEFORMAT,           /* Left, Right, Center, LFE, Back Left, Back Right, Surround Left, Surround Right (as per Microsoft .wav WAVEFORMAT structure master order) */
        PROTOOLS,             /* Left, Center, Right, Surround Left, Surround Right, LFE */
        ALLMONO,              /* Mono, Mono, Mono, Mono, Mono, Mono, ... (each channel all the way up to 32 channels are treated as if they were mono) */
        ALLSTEREO,            /* Left, Right, Left, Right, Left, Right, ... (each pair of channels is treated as stereo all the way up to 32 channels) */
        ALSA,                 /* Left, Right, Surround Left, Surround Right, Center, LFE (as per Linux ALSA channel order) */

        MAX,                  /* Maximum number of channel orderings supported. */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        These are plugin types defined for use with the System::getNumPlugins,
        System::getPluginInfo and System::unloadPlugin functions.

        [REMARKS]

        [SEE_ALSO]
        System::getNumPlugins
        System::getPluginInfo
        System::unloadPlugin
    ]
    */
    public enum PLUGINTYPE : int
    {
        OUTPUT,          /* The plugin type is an output module.  FMOD mixed audio will play through one of these devices */
        CODEC,           /* The plugin type is a file format codec.  FMOD will use these codecs to load file formats for playback. */
        DSP,             /* The plugin type is a DSP unit.  FMOD will use these plugins as part of its DSP network to apply effects to output or generate sound in realtime. */

        MAX,             /* Maximum number of plugin types supported. */
    }



    /*
    [DEFINE]
    [
        [NAME]
        FMOD_INITFLAGS

        [DESCRIPTION]
        Initialization flags.  Use them with System::init in the *flags* parameter to change various behavior.

        [REMARKS]
        Use System::setAdvancedSettings to adjust settings for some of the features that are enabled by these flags.

        [SEE_ALSO]
        System::init
        System::update
        System::setAdvancedSettings
        Channel::set3DOcclusion
    ]
    */
    [Flags]
    public enum INITFLAGS : uint
    {
        NORMAL                    = 0x00000000, /* Initialize normally */
        STREAM_FROM_UPDATE        = 0x00000001, /* No stream thread is created internally.  Streams are driven from System::update.  Mainly used with non-realtime outputs. */
        MIX_FROM_UPDATE           = 0x00000002, /* Win/Wii/PS3/Xbox/Xbox 360 Only - FMOD Mixer thread is woken up to do a mix when System::update is called rather than waking periodically on its own timer. */
        _3D_RIGHTHANDED           = 0x00000004, /* FMOD will treat +X as right, +Y as up and +Z as backwards (towards you). */
        CHANNEL_LOWPASS           = 0x00000100, /* All FMOD_3D based voices will add a software lowpass filter effect into the DSP chain which is automatically used when Channel::set3DOcclusion is used or the geometry API.   This also causes sounds to sound duller when the sound goes behind the listener, as a fake HRTF style effect.  Use System::setAdvancedSettings to disable or adjust cutoff frequency for this feature. */
        CHANNEL_DISTANCEFILTER    = 0x00000200, /* All FMOD_3D based voices will add a software lowpass and highpass filter effect into the DSP chain which will act as a distance-automated bandpass filter. Use System::setAdvancedSettings to adjust the center frequency. */
        PROFILE_ENABLE            = 0x00010000, /* Enable TCP/IP based host which allows FMOD Designer or FMOD Profiler to connect to it, and view memory, CPU and the DSP network graph in real-time. */
        VOL0_BECOMES_VIRTUAL      = 0x00020000, /* Any sounds that are 0 volume will go virtual and not be processed except for having their positions updated virtually.  Use System::setAdvancedSettings to adjust what volume besides zero to switch to virtual at. */
        GEOMETRY_USECLOSEST       = 0x00040000, /* With the geometry engine, only process the closest polygon rather than accumulating all polygons the sound to listener line intersects. */
        PREFER_DOLBY_DOWNMIX      = 0x00080000, /* When using FMOD_SPEAKERMODE_5POINT1 with a stereo output device, use the Dolby Pro Logic II downmix algorithm instead of the SRS Circle Surround algorithm. */
        THREAD_UNSAFE             = 0x00100000, /* Disables thread safety for API calls. Only use this if FMOD low level is being called from a single thread, and if Studio API is not being used! */
        PROFILE_METER_ALL         = 0x00200000  /* Slower, but adds level metering for every single DSP unit in the graph.  Use DSP::setMeteringEnabled to turn meters off individually. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        These definitions describe the type of song being played.

        [REMARKS]

        [SEE_ALSO]
        Sound::getFormat
    ]
    */
    public enum SOUND_TYPE
    {
        UNKNOWN,         /* 3rd party / unknown plugin format. */
        AIFF,            /* AIFF. */
        ASF,             /* Microsoft Advanced Systems Format (ie WMA/ASF/WMV). */
        DLS,             /* Sound font / downloadable sound bank. */
        FLAC,            /* FLAC lossless codec. */
        FSB,             /* FMOD Sample Bank. */
        IT,              /* Impulse Tracker. */
        MIDI,            /* MIDI. extracodecdata is a pointer to an FMOD_MIDI_EXTRACODECDATA structure. */
        MOD,             /* Protracker / Fasttracker MOD. */
        MPEG,            /* MP2/MP3 MPEG. */
        OGGVORBIS,       /* Ogg vorbis. */
        PLAYLIST,        /* Information only from ASX/PLS/M3U/WAX playlists */
        RAW,             /* Raw PCM data. */
        S3M,             /* ScreamTracker 3. */
        USER,            /* User created sound. */
        WAV,             /* Microsoft WAV. */
        XM,              /* FastTracker 2 XM. */
        XMA,             /* Xbox360 XMA */
        AUDIOQUEUE,      /* iPhone hardware decoder, supports AAC, ALAC and MP3. extracodecdata is a pointer to an FMOD_AUDIOQUEUE_EXTRACODECDATA structure. */
        AT9,             /* PS4 / PSVita ATRAC 9 format */
        VORBIS,          /* Vorbis */
        MEDIA_FOUNDATION,/* Windows Store Application built in system codecs */
        MEDIACODEC,      /* Android MediaCodec */
        FADPCM,          /* FMOD Adaptive Differential Pulse Code Modulation */

        MAX,             /* Maximum number of sound types supported. */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        These definitions describe the native format of the hardware or software buffer that will be used.

        [REMARKS]
        This is the format the native hardware or software buffer will be or is created in.

        [SEE_ALSO]
        System::createSoundEx
        Sound::getFormat
    ]
    */
    public enum SOUND_FORMAT : int
    {
        NONE,       /* Unitialized / unknown */
        PCM8,       /* 8bit integer PCM data */
        PCM16,      /* 16bit integer PCM data  */
        PCM24,      /* 24bit integer PCM data  */
        PCM32,      /* 32bit integer PCM data  */
        PCMFLOAT,   /* 32bit floating point PCM data  */
        BITSTREAM,  /* Sound data is in its native compressed format. */

        MAX         /* Maximum number of sound formats supported. */
    }


    /*
    [DEFINE]
    [
        [NAME]
        FMOD_MODE

        [DESCRIPTION]
        Sound description bitfields, bitwise OR them together for loading and describing sounds.

        [REMARKS]
        By default a sound will open as a static sound that is decompressed fully into memory to PCM. (ie equivalent of FMOD_CREATESAMPLE)<br>
        To have a sound stream instead, use FMOD_CREATESTREAM, or use the wrapper function System::createStream.<br>
        Some opening modes (ie FMOD_OPENUSER, FMOD_OPENMEMORY, FMOD_OPENMEMORY_POINT, FMOD_OPENRAW) will need extra information.<br>
        This can be provided using the FMOD_CREATESOUNDEXINFO structure.
        <br>
        Specifying FMOD_OPENMEMORY_POINT will POINT to your memory rather allocating its own sound buffers and duplicating it internally.<br>
        <b><u>This means you cannot free the memory while FMOD is using it, until after Sound::release is called.</b></u>
        With FMOD_OPENMEMORY_POINT, for PCM formats, only WAV, FSB, and RAW are supported.  For compressed formats, only those formats supported by FMOD_CREATECOMPRESSEDSAMPLE are supported.<br>
        With FMOD_OPENMEMORY_POINT and FMOD_OPENRAW or PCM, if using them together, note that you must pad the data on each side by 16 bytes.  This is so fmod can modify the ends of the data for looping/interpolation/mixing purposes.  If a wav file, you will need to insert silence, and then reset loop points to stop the playback from playing that silence.<br>
        <br>
        <b>Xbox 360 memory</b> On Xbox 360 Specifying FMOD_OPENMEMORY_POINT to a virtual memory address will cause FMOD_ERR_INVALID_ADDRESS
        to be returned.  Use physical memory only for this functionality.<br>
        <br>
        FMOD_LOWMEM is used on a sound if you want to minimize the memory overhead, by having FMOD not allocate memory for certain
        features that are not likely to be used in a game environment.  These are :<br>
        1. Sound::getName functionality is removed.  256 bytes per sound is saved.<br>

        [SEE_ALSO]
        System::createSound
        System::createStream
        Sound::setMode
        Sound::getMode
        Channel::setMode
        Channel::getMode
        Sound::set3DCustomRolloff
        Channel::set3DCustomRolloff
        Sound::getOpenState
    ]
    */
    [Flags]
    public enum MODE : uint
    {
        DEFAULT                = 0x00000000,  /* Default for all modes listed below. FMOD_LOOP_OFF, FMOD_2D, FMOD_3D_WORLDRELATIVE, FMOD_3D_INVERSEROLLOFF */
        LOOP_OFF               = 0x00000001,  /* For non looping sounds. (default).  Overrides FMOD_LOOP_NORMAL / FMOD_LOOP_BIDI. */
        LOOP_NORMAL            = 0x00000002,  /* For forward looping sounds. */
        LOOP_BIDI              = 0x00000004,  /* For bidirectional looping sounds. (only works on software mixed static sounds). */
        _2D                    = 0x00000008,  /* Ignores any 3d processing. (default). */
        _3D                    = 0x00000010,  /* Makes the sound positionable in 3D.  Overrides FMOD_2D. */
        CREATESTREAM           = 0x00000080,  /* Decompress at runtime, streaming from the source provided (standard stream).  Overrides FMOD_CREATESAMPLE. */
        CREATESAMPLE           = 0x00000100,  /* Decompress at loadtime, decompressing or decoding whole file into memory as the target sample format. (standard sample). */
        CREATECOMPRESSEDSAMPLE = 0x00000200,  /* Load MP2, MP3, IMAADPCM or XMA into memory and leave it compressed.  During playback the FMOD software mixer will decode it in realtime as a 'compressed sample'.  Can only be used in combination with FMOD_SOFTWARE. */
        OPENUSER               = 0x00000400,  /* Opens a user created static sample or stream. Use FMOD_CREATESOUNDEXINFO to specify format and/or read callbacks.  If a user created 'sample' is created with no read callback, the sample will be empty.  Use FMOD_Sound_Lock and FMOD_Sound_Unlock to place sound data into the sound if this is the case. */
        OPENMEMORY             = 0x00000800,  /* "name_or_data" will be interpreted as a pointer to memory instead of filename for creating sounds. */
        OPENMEMORY_POINT       = 0x10000000,  /* "name_or_data" will be interpreted as a pointer to memory instead of filename for creating sounds.  Use FMOD_CREATESOUNDEXINFO to specify length.  This differs to FMOD_OPENMEMORY in that it uses the memory as is, without duplicating the memory into its own buffers.  Cannot be freed after open, only after Sound::release.   Will not work if the data is compressed and FMOD_CREATECOMPRESSEDSAMPLE is not used. */
        OPENRAW                = 0x00001000,  /* Will ignore file format and treat as raw pcm.  User may need to declare if data is FMOD_SIGNED or FMOD_UNSIGNED */
        OPENONLY               = 0x00002000,  /* Just open the file, dont prebuffer or read.  Good for fast opens for info, or when sound::readData is to be used. */
        ACCURATETIME           = 0x00004000,  /* For FMOD_CreateSound - for accurate FMOD_Sound_GetLength / FMOD_Channel_SetPosition on VBR MP3, AAC and MOD/S3M/XM/IT/MIDI files.  Scans file first, so takes longer to open. FMOD_OPENONLY does not affect this. */
        MPEGSEARCH             = 0x00008000,  /* For corrupted / bad MP3 files.  This will search all the way through the file until it hits a valid MPEG header.  Normally only searches for 4k. */
        NONBLOCKING            = 0x00010000,  /* For opening sounds and getting streamed subsounds (seeking) asyncronously.  Use Sound::getOpenState to poll the state of the sound as it opens or retrieves the subsound in the background. */
        UNIQUE                 = 0x00020000,  /* Unique sound, can only be played one at a time */
        _3D_HEADRELATIVE       = 0x00040000,  /* Make the sound's position, velocity and orientation relative to the listener. */
        _3D_WORLDRELATIVE      = 0x00080000,  /* Make the sound's position, velocity and orientation absolute (relative to the world). (DEFAULT) */
        _3D_INVERSEROLLOFF     = 0x00100000,  /* This sound will follow the inverse rolloff model where mindistance = full volume, maxdistance = where sound stops attenuating, and rolloff is fixed according to the global rolloff factor.  (DEFAULT) */
        _3D_LINEARROLLOFF      = 0x00200000,  /* This sound will follow a linear rolloff model where mindistance = full volume, maxdistance = silence.  */
        _3D_LINEARSQUAREROLLOFF= 0x00400000,  /* This sound will follow a linear-square rolloff model where mindistance = full volume, maxdistance = silence.  Rolloffscale is ignored. */
        _3D_INVERSETAPEREDROLLOFF = 0x00800000,  /* This sound will follow the inverse rolloff model at distances close to mindistance and a linear-square rolloff close to maxdistance. */
        _3D_CUSTOMROLLOFF      = 0x04000000,  /* This sound will follow a rolloff model defined by Sound::set3DCustomRolloff / Channel::set3DCustomRolloff.  */
        _3D_IGNOREGEOMETRY     = 0x40000000,  /* Is not affect by geometry occlusion.  If not specified in Sound::setMode, or Channel::setMode, the flag is cleared and it is affected by geometry again. */
        IGNORETAGS             = 0x02000000,  /* Skips id3v2/asf/etc tag checks when opening a sound, to reduce seek/read overhead when opening files (helps with CD performance). */
        LOWMEM                 = 0x08000000,  /* Removes some features from samples to give a lower memory overhead, like Sound::getName. */
        LOADSECONDARYRAM       = 0x20000000,  /* Load sound into the secondary RAM of supported platform.  On PS3, sounds will be loaded into RSX/VRAM. */
        VIRTUAL_PLAYFROMSTART  = 0x80000000   /* For sounds that start virtual (due to being quiet or low importance), instead of swapping back to audible, and playing at the correct offset according to time, this flag makes the sound play from the start. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        These values describe what state a sound is in after FMOD_NONBLOCKING has been used to open it.

        [REMARKS]
        With streams, if you are using FMOD_NONBLOCKING, note that if the user calls Sound::getSubSound, a stream will go into FMOD_OPENSTATE_SEEKING state and sound related commands will return FMOD_ERR_NOTREADY.<br>
        With streams, if you are using FMOD_NONBLOCKING, note that if the user calls Channel::getPosition, a stream will go into FMOD_OPENSTATE_SETPOSITION state and sound related commands will return FMOD_ERR_NOTREADY.<br>

        [SEE_ALSO]
        Sound::getOpenState
        FMOD_MODE
    ]
    */
    public enum OPENSTATE : int
    {
        READY = 0,       /* Opened and ready to play */
        LOADING,         /* Initial load in progress */
        ERROR,           /* Failed to open - file not found, out of memory etc.  See return value of Sound::getOpenState for what happened. */
        CONNECTING,      /* Connecting to remote host (internet sounds only) */
        BUFFERING,       /* Buffering data */
        SEEKING,         /* Seeking to subsound and re-flushing stream buffer. */
        PLAYING,         /* Ready and playing, but not possible to release at this time without stalling the main thread. */
        SETPOSITION,     /* Seeking within a stream to a different position. */

        MAX,             /* Maximum number of open state types. */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        These flags are used with SoundGroup::setMaxAudibleBehavior to determine what happens when more sounds
        are played than are specified with SoundGroup::setMaxAudible.

        [REMARKS]
        When using FMOD_SOUNDGROUP_BEHAVIOR_MUTE, SoundGroup::setMuteFadeSpeed can be used to stop a sudden transition.
        Instead, the time specified will be used to cross fade between the sounds that go silent and the ones that become audible.

        [SEE_ALSO]
        SoundGroup::setMaxAudibleBehavior
        SoundGroup::getMaxAudibleBehavior
        SoundGroup::setMaxAudible
        SoundGroup::getMaxAudible
        SoundGroup::setMuteFadeSpeed
        SoundGroup::getMuteFadeSpeed
    ]
    */
    public enum SOUNDGROUP_BEHAVIOR : int
    {
        BEHAVIOR_FAIL,              /* Any sound played that puts the sound count over the SoundGroup::setMaxAudible setting, will simply fail during System::playSound. */
        BEHAVIOR_MUTE,              /* Any sound played that puts the sound count over the SoundGroup::setMaxAudible setting, will be silent, then if another sound in the group stops the sound that was silent before becomes audible again. */
        BEHAVIOR_STEALLOWEST,       /* Any sound played that puts the sound count over the SoundGroup::setMaxAudible setting, will steal the quietest / least important sound playing in the group. */

        MAX,               /* Maximum number of sound group behaviors. */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        These callback types are used with Channel::setCallback.

        [REMARKS]
        Each callback has commanddata parameters passed as int unique to the type of callback.<br>
        See reference to FMOD_CHANNELCONTROL_CALLBACK to determine what they might mean for each type of callback.<br>
        <br>
        <b>Note!</b>  Currently the user must call System::update for these callbacks to trigger!

        [SEE_ALSO]
        Channel::setCallback
        ChannelGroup::setCallback
        FMOD_CHANNELCONTROL_CALLBACK
        System::update
    ]
    */
    public enum CHANNELCONTROL_CALLBACK_TYPE : int
    {
        END,                  /* Called when a sound ends. */
        VIRTUALVOICE,         /* Called when a voice is swapped out or swapped in. */
        SYNCPOINT,            /* Called when a syncpoint is encountered.  Can be from wav file markers. */
        OCCLUSION,            /* Called when the channel has its geometry occlusion value calculated.  Can be used to clamp or change the value. */

        MAX,                  /* Maximum number of callback types supported. */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        These enums denote special types of node within a DSP chain.

        [REMARKS]

        [SEE_ALSO]
        Channel::getDSP
        ChannelGroup::getDSP
    ]
    */
    public struct CHANNELCONTROL_DSP_INDEX
    {
        public const int HEAD    = -1;         /* Head of the DSP chain. */
        public const int FADER   = -2;         /* Built in fader DSP. */
        public const int PANNER  = -3;         /* Built in panner DSP. */
        public const int TAIL    = -4;         /* Tail of the DSP chain. */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        Used to distinguish the instance type passed into FMOD_ERROR_CALLBACK.

        [REMARKS]
        Cast the instance of FMOD_ERROR_CALLBACK to the appropriate class indicated by this enum.

        [SEE_ALSO]
    ]
    */
    public enum ERRORCALLBACK_INSTANCETYPE
    {
        NONE,
        SYSTEM,
        CHANNEL,
        CHANNELGROUP,
        CHANNELCONTROL,
        SOUND,
        SOUNDGROUP,
        DSP,
        DSPCONNECTION,
        GEOMETRY,
        REVERB3D,
        STUDIO_SYSTEM,
        STUDIO_EVENTDESCRIPTION,
        STUDIO_EVENTINSTANCE,
        STUDIO_PARAMETERINSTANCE,
        STUDIO_CUEINSTANCE,
        STUDIO_BUS,
        STUDIO_VCA,
        STUDIO_BANK,
        STUDIO_COMMANDREPLAY
    }

    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Structure that is passed into FMOD_SYSTEM_CALLBACK for the FMOD_SYSTEM_CALLBACK_ERROR callback type.

        [REMARKS]
        The instance pointer will be a type corresponding to the instanceType enum.

        [SEE_ALSO]
        FMOD_ERRORCALLBACK_INSTANCETYPE
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct ERRORCALLBACK_INFO
    {
        public  RESULT                      result;                     /* Error code result */
        public  ERRORCALLBACK_INSTANCETYPE  instancetype;               /* Type of instance the error occurred on */
        public  IntPtr                      instance;                   /* Instance pointer */
        private IntPtr                      functionname_internal;      /* Function that the error occurred on */
        private IntPtr                      functionparams_internal;    /* Function parameters that the error ocurred on */

        public string functionname   { get { return Marshal.PtrToStringAnsi(functionname_internal); } }
        public string functionparams { get { return Marshal.PtrToStringAnsi(functionparams_internal); } }
    }

    /*
    [DEFINE]
    [
        [NAME]
        FMOD_SYSTEM_CALLBACK_TYPE

        [DESCRIPTION]
        These callback types are used with System::setCallback.

        [REMARKS]
        Each callback has commanddata parameters passed as void* unique to the type of callback.<br>
        See reference to FMOD_SYSTEM_CALLBACK to determine what they might mean for each type of callback.<br>
        <br>
        <b>Note!</b> Using FMOD_SYSTEM_CALLBACK_DEVICELISTCHANGED (on Mac only) requires the application to be running an event loop which will allow external changes to device list to be detected by FMOD.<br>
        <br>
        <b>Note!</b> The 'system' object pointer will be null for FMOD_SYSTEM_CALLBACK_THREADCREATED and FMOD_SYSTEM_CALLBACK_MEMORYALLOCATIONFAILED callbacks.

        [SEE_ALSO]
        System::setCallback
        System::update
        DSP::addInput
    ]
    */
    [Flags]
    public enum SYSTEM_CALLBACK_TYPE : uint
    {
        DEVICELISTCHANGED      = 0x00000001,  /* Called from System::update when the enumerated list of devices has changed. */
        DEVICELOST             = 0x00000002,  /* Called from System::update when an output device has been lost due to control panel parameter changes and FMOD cannot automatically recover. */
        MEMORYALLOCATIONFAILED = 0x00000004,  /* Called directly when a memory allocation fails somewhere in FMOD.  (NOTE - 'system' will be NULL in this callback type.)*/
        THREADCREATED          = 0x00000008,  /* Called directly when a thread is created. (NOTE - 'system' will be NULL in this callback type.) */
        BADDSPCONNECTION       = 0x00000010,  /* Called when a bad connection was made with DSP::addInput. Usually called from mixer thread because that is where the connections are made.  */
        PREMIX                 = 0x00000020,  /* Called each tick before a mix update happens. */
        POSTMIX                = 0x00000040,  /* Called each tick after a mix update happens. */
        ERROR                  = 0x00000080,  /* Called when each API function returns an error code, including delayed async functions. */
        MIDMIX                 = 0x00000100,  /* Called each tick in mix update after clocks have been updated before the main mix occurs. */
        THREADDESTROYED        = 0x00000200,  /* Called directly when a thread is destroyed. */
        PREUPDATE              = 0x00000400,  /* Called at start of System::update function. */
        POSTUPDATE             = 0x00000800,  /* Called at end of System::update function. */
        RECORDLISTCHANGED      = 0x00001000,  /* Called from System::update when the enumerated list of recording devices has changed. */
        ALL                    = 0xFFFFFFFF,  /* Pass this mask to System::setCallback to receive all callback types.  */
    }
	
    #region wrapperinternal
    [StructLayout(LayoutKind.Sequential)]
    public struct StringWrapper
    {
        IntPtr nativeUtf8Ptr;

        public static implicit operator string(StringWrapper fstring)
        {
            if (fstring.nativeUtf8Ptr == IntPtr.Zero)
            {
                return "";
            }

            int strlen = 0;
            while (Marshal.ReadByte(fstring.nativeUtf8Ptr, strlen) != 0)
            {
                strlen++;
            }
            if (strlen > 0)
            {
                byte[] bytes = new byte[strlen];
                Marshal.Copy(fstring.nativeUtf8Ptr, bytes, 0, strlen);
                return Encoding.UTF8.GetString(bytes, 0, strlen);
            }
            else
            {
                return "";
            }
        }
    }
    #endregion

    /*
        FMOD Callbacks
    */
    public delegate RESULT ASYNCREADINFO_DONE_CALLBACK(IntPtr info, RESULT result);

    public delegate RESULT DEBUG_CALLBACK           (DEBUG_FLAGS flags, string file, int line, string func, string message);

    public delegate RESULT SYSTEM_CALLBACK          (IntPtr systemraw, SYSTEM_CALLBACK_TYPE type, IntPtr commanddata1, IntPtr commanddata2, IntPtr userdata);

    public delegate RESULT CHANNEL_CALLBACK         (IntPtr channelraw, CHANNELCONTROL_TYPE controltype, CHANNELCONTROL_CALLBACK_TYPE type, IntPtr commanddata1, IntPtr commanddata2);

    public delegate RESULT SOUND_NONBLOCKCALLBACK   (IntPtr soundraw, RESULT result);
    public delegate RESULT SOUND_PCMREADCALLBACK    (IntPtr soundraw, IntPtr data, uint datalen);
    public delegate RESULT SOUND_PCMSETPOSCALLBACK  (IntPtr soundraw, int subsound, uint position, TIMEUNIT postype);

    public delegate RESULT FILE_OPENCALLBACK        (StringWrapper name, ref uint filesize, ref IntPtr handle, IntPtr userdata);
    public delegate RESULT FILE_CLOSECALLBACK       (IntPtr handle, IntPtr userdata);
    public delegate RESULT FILE_READCALLBACK        (IntPtr handle, IntPtr buffer, uint sizebytes, ref uint bytesread, IntPtr userdata);
    public delegate RESULT FILE_SEEKCALLBACK        (IntPtr handle, uint pos, IntPtr userdata);
    public delegate RESULT FILE_ASYNCREADCALLBACK   (IntPtr handle, IntPtr info, IntPtr userdata);
    public delegate RESULT FILE_ASYNCCANCELCALLBACK (IntPtr handle, IntPtr userdata);

    public delegate IntPtr MEMORY_ALLOC_CALLBACK    (uint size, MEMORY_TYPE type, StringWrapper sourcestr);
    public delegate IntPtr MEMORY_REALLOC_CALLBACK  (IntPtr ptr, uint size, MEMORY_TYPE type, StringWrapper sourcestr);
    public delegate void   MEMORY_FREE_CALLBACK     (IntPtr ptr, MEMORY_TYPE type, StringWrapper sourcestr);

    public delegate float  CB_3D_ROLLOFFCALLBACK    (IntPtr channelraw, float distance);

    /*
    [ENUM]
    [
        [DESCRIPTION]
        List of interpolation types that the FMOD Ex software mixer supports.

        [REMARKS]
        The default resampler type is FMOD_DSP_RESAMPLER_LINEAR.<br>
        Use System::setSoftwareFormat to tell FMOD the resampling quality you require for FMOD_SOFTWARE based sounds.

        [SEE_ALSO]
        System::setSoftwareFormat
        System::getSoftwareFormat
    ]
    */
    public enum DSP_RESAMPLER : int
    {
        DEFAULT,         /* Default interpolation method.  Currently equal to FMOD_DSP_RESAMPLER_LINEAR. */
        NOINTERP,        /* No interpolation.  High frequency aliasing hiss will be audible depending on the sample rate of the sound. */
        LINEAR,          /* Linear interpolation (default method).  Fast and good quality, causes very slight lowpass effect on low frequency sounds. */
        CUBIC,           /* Cubic interpolation.  Slower than linear interpolation but better quality. */
        SPLINE,          /* 5 point spline interpolation.  Slowest resampling method but best quality. */

        MAX,             /* Maximum number of resample methods supported. */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        List of connection types between 2 DSP nodes.

        [REMARKS]
        FMOD_DSP_CONNECTION_TYPE_STANDARD<br>
        ----------------------------------<br>
        Default DSPConnection type.  Audio is mixed from the input to the output DSP's audible buffer, meaning it will be part of the audible signal.  A standard connection will execute its input DSP if it has not been executed before.<br>
        <br>
        FMOD_DSP_CONNECTION_TYPE_SIDECHAIN<br>
        ----------------------------------<br>
        Sidechain DSPConnection type.  Audio is mixed from the input to the output DSP's sidechain buffer, meaning it will NOT be part of the audible signal.  A sidechain connection will execute its input DSP if it has not been executed before.<br>
        The purpose of the seperate sidechain buffer in a DSP, is so that the DSP effect can privately access for analysis purposes.  An example of use in this case, could be a compressor which analyzes the signal, to control its own effect parameters (ie a compression level or gain).<br>
        <br>
        For the effect developer, to accept sidechain data, the sidechain data will appear in the FMOD_DSP_STATE struct which is passed into the read callback of a DSP unit.<br>
        FMOD_DSP_STATE::sidechaindata and FMOD_DSP::sidechainchannels will hold the mixed result of any sidechain data flowing into it.<br>
        <br>
        FMOD_DSP_CONNECTION_TYPE_SEND<br>
        -----------------------------<br>
        Send DSPConnection type.  Audio is mixed from the input to the output DSP's audible buffer, meaning it will be part of the audible signal.  A send connection will NOT execute its input DSP if it has not been executed before.<br>
        A send connection will only read what exists at the input's buffer at the time of executing the output DSP unit (which can be considered the 'return')<br>
        <br>
        FMOD_DSP_CONNECTION_TYPE_SEND_SIDECHAIN<br>
        ---------------------------------------<br>
        Send sidechain DSPConnection type.  Audio is mixed from the input to the output DSP's sidechain buffer, meaning it will NOT be part of the audible signal.  A send sidechain connection will NOT execute its input DSP if it has not been executed before.<br>
        A send sidechain connection will only read what exists at the input's buffer at the time of executing the output DSP unit (which can be considered the 'sidechain return').
        <br>
        For the effect developer, to accept sidechain data, the sidechain data will appear in the FMOD_DSP_STATE struct which is passed into the read callback of a DSP unit.<br>
        FMOD_DSP_STATE::sidechaindata and FMOD_DSP::sidechainchannels will hold the mixed result of any sidechain data flowing into it.

        [SEE_ALSO]
        DSP::addInput
        DSPConnection::getType
    ]
    */
    public enum DSPCONNECTION_TYPE : int
    {
        STANDARD,          /* Default connection type.         Audio is mixed from the input to the output DSP's audible buffer.  */
        SIDECHAIN,         /* Sidechain connection type.       Audio is mixed from the input to the output DSP's sidechain buffer.  */
        SEND,              /* Send connection type.            Audio is mixed from the input to the output DSP's audible buffer, but the input is NOT executed, only copied from.  A standard connection or sidechain needs to make an input execute to generate data. */
        SEND_SIDECHAIN,    /* Send sidechain connection type.  Audio is mixed from the input to the output DSP's sidechain buffer, but the input is NOT executed, only copied from.  A standard connection or sidechain needs to make an input execute to generate data. */

        MAX,               /* Maximum number of DSP connection types supported. */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        List of tag types that could be stored within a sound.  These include id3 tags, metadata from netstreams and vorbis/asf data.

        [REMARKS]

        [SEE_ALSO]
        Sound::getTag
    ]
    */
    public enum TAGTYPE : int
    {
        UNKNOWN = 0,
        ID3V1,
        ID3V2,
        VORBISCOMMENT,
        SHOUTCAST,
        ICECAST,
        ASF,
        MIDI,
        PLAYLIST,
        FMOD,
        USER,

        MAX                /* Maximum number of tag types supported. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        List of data types that can be returned by Sound::getTag

        [REMARKS]

        [SEE_ALSO]
        Sound::getTag
    ]
    */
    public enum TAGDATATYPE : int
    {
        BINARY = 0,
        INT,
        FLOAT,
        STRING,
        STRING_UTF16,
        STRING_UTF16BE,
        STRING_UTF8,
        CDTOC,

        MAX                /* Maximum number of tag datatypes supported. */
    }

    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Structure describing a piece of tag data.

        [REMARKS]
        Members marked with [w] mean the user sets the value before passing it to the function.
        Members marked with [r] mean FMOD sets the value to be used after the function exits.

        [SEE_ALSO]
        Sound::getTag
        TAGTYPE
        TAGDATATYPE
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct TAG
    {
        public  TAGTYPE           type;         /* [r] The type of this tag. */
        public  TAGDATATYPE       datatype;     /* [r] The type of data that this tag contains */
        private IntPtr            name_internal;/* [r] The name of this tag i.e. "TITLE", "ARTIST" etc. */
        public  IntPtr            data;         /* [r] Pointer to the tag data - its format is determined by the datatype member */
        public  uint              datalen;      /* [r] Length of the data contained in this tag */
        public  bool              updated;      /* [r] True if this tag has been updated since last being accessed with Sound::getTag */

        public string name { get { return Marshal.PtrToStringAnsi(name_internal); } }
    }


    /*
    [DEFINE]
    [
        [NAME]
        FMOD_TIMEUNIT

        [DESCRIPTION]
        List of time types that can be returned by Sound::getLength and used with Channel::setPosition or Channel::getPosition.

        [REMARKS]
        Do not combine flags except FMOD_TIMEUNIT_BUFFERED.

        [SEE_ALSO]
        Sound::getLength
        Channel::setPosition
        Channel::getPosition
    ]
    */
    [Flags]
    public enum TIMEUNIT : uint
    {
        MS                = 0x00000001,  /* Milliseconds. */
        PCM               = 0x00000002,  /* PCM Samples, related to milliseconds * samplerate / 1000. */
        PCMBYTES          = 0x00000004,  /* Bytes, related to PCM samples * channels * datawidth (ie 16bit = 2 bytes). */
        RAWBYTES          = 0x00000008,  /* Raw file bytes of (compressed) sound data (does not include headers).  Only used by Sound::getLength and Channel::getPosition. */
        PCMFRACTION       = 0x00000010,  /* Fractions of 1 PCM sample.  Unsigned int range 0 to 0xFFFFFFFF.  Used for sub-sample granularity for DSP purposes. */
        MODORDER          = 0x00000100,  /* MOD/S3M/XM/IT.  Order in a sequenced module format.  Use Sound::getFormat to determine the format. */
        MODROW            = 0x00000200,  /* MOD/S3M/XM/IT.  Current row in a sequenced module format.  Sound::getLength will return the number if rows in the currently playing or seeked to pattern. */
        MODPATTERN        = 0x00000400,  /* MOD/S3M/XM/IT.  Current pattern in a sequenced module format.  Sound::getLength will return the number of patterns in the song and Channel::getPosition will return the currently playing pattern. */
        BUFFERED          = 0x10000000,  /* Time value as seen by buffered stream.  This is always ahead of audible time, and is only used for processing. */
    }

    /*
    [DEFINE]
    [
        [NAME]
        FMOD_PORT_INDEX

        [DESCRIPTION]

        [REMARKS]

        [SEE_ALSO]
        System::AttachChannelGroupToPort
    ]
    */
    public struct PORT_INDEX
    {
        public const ulong NONE = 0xFFFFFFFFFFFFFFFF;
    }

    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Use this structure with System::createSound when more control is needed over loading.
        The possible reasons to use this with System::createSound are:

        - Loading a file from memory.
        - Loading a file from within another larger (possibly wad/pak) file, by giving the loader an offset and length.
        - To create a user created / non file based sound.
        - To specify a starting subsound to seek to within a multi-sample sounds (ie FSB/DLS) when created as a stream.
        - To specify which subsounds to load for multi-sample sounds (ie FSB/DLS) so that memory is saved and only a subset is actually loaded/read from disk.
        - To specify 'piggyback' read and seek callbacks for capture of sound data as fmod reads and decodes it.  Useful for ripping decoded PCM data from sounds as they are loaded / played.
        - To specify a MIDI DLS sample set file to load when opening a MIDI file.

        See below on what members to fill for each of the above types of sound you want to create.

        [REMARKS]
        This structure is optional!  Specify 0 or NULL in System::createSound if you don't need it!

        <u>Loading a file from memory.</u>

        - Create the sound using the FMOD_OPENMEMORY flag.
        - Mandatory.  Specify 'length' for the size of the memory block in bytes.
        - Other flags are optional.

        <u>Loading a file from within another larger (possibly wad/pak) file, by giving the loader an offset and length.</u>

        - Mandatory.  Specify 'fileoffset' and 'length'.
        - Other flags are optional.

        <u>To create a user created / non file based sound.</u>

        - Create the sound using the FMOD_OPENUSER flag.
        - Mandatory.  Specify 'defaultfrequency, 'numchannels' and 'format'.
        - Other flags are optional.

        <u>To specify a starting subsound to seek to and flush with, within a multi-sample stream (ie FSB/DLS).</u>

        - Mandatory.  Specify 'initialsubsound'.

        <u>To specify which subsounds to load for multi-sample sounds (ie FSB/DLS) so that memory is saved and only a subset is actually loaded/read from disk.</u>

        - Mandatory.  Specify 'inclusionlist' and 'inclusionlistnum'.

        <u>To specify 'piggyback' read and seek callbacks for capture of sound data as fmod reads and decodes it.  Useful for ripping decoded PCM data from sounds as they are loaded / played.</u>

        - Mandatory.  Specify 'pcmreadcallback' and 'pcmseekcallback'.

        <u>To specify a MIDI DLS sample set file to load when opening a MIDI file.</u>

        - Mandatory.  Specify 'dlsname'.

        Setting the 'decodebuffersize' is for cpu intensive codecs that may be causing stuttering, not file intensive codecs (ie those from CD or netstreams) which are normally
        altered with System::setStreamBufferSize.  As an example of cpu intensive codecs, an mp3 file will take more cpu to decode than a PCM wav file.

        If you have a stuttering effect, then it is using more cpu than the decode buffer playback rate can keep up with.  Increasing the decode buffersize will most likely solve this problem.

        FSB codec.  If inclusionlist and numsubsounds are used together, this will trigger a special mode where subsounds are shuffled down to save memory.  (useful for large FSB
        files where you only want to load 1 sound).  There will be no gaps, ie no null subsounds.  As an example, if there are 10,000 subsounds and there is an inclusionlist with only 1 entry,
        and numsubsounds = 1, then subsound 0 will be that entry, and there will only be the memory allocated for 1 subsound.  Previously there would still be 10,000 subsound pointers and other
        associated codec entries allocated along with it multiplied by 10,000.

        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.<br>
        Members marked with [w] mean the variable can be written to.  The user can set the value.

        [SEE_ALSO]
        System::createSound
        System::setStreamBufferSize
        FMOD_MODE
        FMOD_SOUND_FORMAT
        FMOD_SOUND_TYPE
        FMOD_CHANNELMASK
        FMOD_CHANNELORDER
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct CREATESOUNDEXINFO
    {
        public int                         cbsize;                 /* [w] Size of this structure.  This is used so the structure can be expanded in the future and still work on older versions of FMOD Ex. */
        public uint                        length;                 /* [w] Optional. Specify 0 to ignore. Size in bytes of file to load, or sound to create (in this case only if FMOD_OPENUSER is used).  Required if loading from memory.  If 0 is specified, then it will use the size of the file (unless loading from memory then an error will be returned). */
        public uint                        fileoffset;             /* [w] Optional. Specify 0 to ignore. Offset from start of the file to start loading from.  This is useful for loading files from inside big data files. */
        public int                         numchannels;            /* [w] Optional. Specify 0 to ignore. Number of channels in a sound specified only if OPENUSER is used. */
        public int                         defaultfrequency;       /* [w] Optional. Specify 0 to ignore. Default frequency of sound in a sound specified only if OPENUSER is used.  Other formats use the frequency determined by the file format. */
        public SOUND_FORMAT                format;                 /* [w] Optional. Specify 0 or SOUND_FORMAT_NONE to ignore. Format of the sound specified only if OPENUSER is used.  Other formats use the format determined by the file format.   */
        public uint                        decodebuffersize;       /* [w] Optional. Specify 0 to ignore. For streams.  This determines the size of the double buffer (in PCM samples) that a stream uses.  Use this for user created streams if you want to determine the size of the callback buffer passed to you.  Specify 0 to use FMOD's default size which is currently equivalent to 400ms of the sound format created/loaded. */
        public int                         initialsubsound;        /* [w] Optional. Specify 0 to ignore. In a multi-sample file format such as .FSB/.DLS/.SF2, specify the initial subsound to seek to, only if CREATESTREAM is used. */
        public int                         numsubsounds;           /* [w] Optional. Specify 0 to ignore or have no subsounds.  In a user created multi-sample sound, specify the number of subsounds within the sound that are accessable with Sound::getSubSound / SoundGetSubSound. */
        public IntPtr                      inclusionlist;          /* [w] Optional. Specify 0 to ignore. In a multi-sample format such as .FSB/.DLS/.SF2 it may be desirable to specify only a subset of sounds to be loaded out of the whole file.  This is an array of subsound indicies to load into memory when created. */
        public int                         inclusionlistnum;       /* [w] Optional. Specify 0 to ignore. This is the number of integers contained within the */
        public SOUND_PCMREADCALLBACK       pcmreadcallback;        /* [w] Optional. Specify 0 to ignore. Callback to 'piggyback' on FMOD's read functions and accept or even write PCM data while FMOD is opening the sound.  Used for user sounds created with OPENUSER or for capturing decoded data as FMOD reads it. */
        public SOUND_PCMSETPOSCALLBACK     pcmsetposcallback;      /* [w] Optional. Specify 0 to ignore. Callback for when the user calls a seeking function such as Channel::setPosition within a multi-sample sound, and for when it is opened.*/
        public SOUND_NONBLOCKCALLBACK      nonblockcallback;       /* [w] Optional. Specify 0 to ignore. Callback for successful completion, or error while loading a sound that used the FMOD_NONBLOCKING flag.*/
        public IntPtr                      dlsname;                /* [w] Optional. Specify 0 to ignore. Filename for a DLS or SF2 sample set when loading a MIDI file.   If not specified, on windows it will attempt to open /windows/system32/drivers/gm.dls, otherwise the MIDI will fail to open.  */
        public IntPtr                      encryptionkey;          /* [w] Optional. Specify 0 to ignore. Key for encrypted FSB file.  Without this key an encrypted FSB file will not load. */
        public int                         maxpolyphony;           /* [w] Optional. Specify 0 to ingore. For sequenced formats with dynamic channel allocation such as .MID and .IT, this specifies the maximum voice count allowed while playing.  .IT defaults to 64.  .MID defaults to 32. */
        public IntPtr                      userdata;               /* [w] Optional. Specify 0 to ignore. This is user data to be attached to the sound during creation.  Access via Sound::getUserData. */
        public SOUND_TYPE                  suggestedsoundtype;     /* [w] Optional. Specify 0 or FMOD_SOUND_TYPE_UNKNOWN to ignore.  Instead of scanning all codec types, use this to speed up loading by making it jump straight to this codec. */
        public FILE_OPENCALLBACK           fileuseropen;           /* [w] Optional. Specify 0 to ignore. Callback for opening this file. */
        public FILE_CLOSECALLBACK          fileuserclose;          /* [w] Optional. Specify 0 to ignore. Callback for closing this file. */
        public FILE_READCALLBACK           fileuserread;           /* [w] Optional. Specify 0 to ignore. Callback for reading from this file. */
        public FILE_SEEKCALLBACK           fileuserseek;           /* [w] Optional. Specify 0 to ignore. Callback for seeking within this file. */
        public FILE_ASYNCREADCALLBACK      fileuserasyncread;      /* [w] Optional. Specify 0 to ignore. Callback for asyncronously reading from this file. */
        public FILE_ASYNCCANCELCALLBACK    fileuserasynccancel;    /* [w] Optional. Specify 0 to ignore. Callback for cancelling an asyncronous read. */
        public IntPtr                      fileuserdata;           /* [w] Optional. Specify 0 to ignore. User data to be passed into the file callbacks. */
        public CHANNELORDER                channelorder;           /* [w] Optional. Specify 0 to ignore. Use this to differ the way fmod maps multichannel sounds to speakers.  See FMOD_CHANNELORDER for more. */
        public CHANNELMASK                 channelmask;            /* [w] Optional. Specify 0 to ignore. Use this to differ the way fmod maps multichannel sounds to speakers.  See FMOD_CHANNELMASK for more. */
        public IntPtr                      initialsoundgroup;      /* [w] Optional. Specify 0 to ignore. Specify a sound group if required, to put sound in as it is created. */
        public uint                        initialseekposition;    /* [w] Optional. Specify 0 to ignore. For streams. Specify an initial position to seek the stream to. */
        public TIMEUNIT                    initialseekpostype;     /* [w] Optional. Specify 0 to ignore. For streams. Specify the time unit for the position set in initialseekposition. */
        public int                         ignoresetfilesystem;    /* [w] Optional. Specify 0 to ignore. Set to 1 to use fmod's built in file system. Ignores setFileSystem callbacks and also FMOD_CREATESOUNEXINFO file callbacks.  Useful for specific cases where you don't want to use your own file system but want to use fmod's file system (ie net streaming). */
        public uint                        audioqueuepolicy;       /* [w] Optional. Specify 0 or FMOD_AUDIOQUEUE_CODECPOLICY_DEFAULT to ignore. Policy used to determine whether hardware or software is used for decoding, see FMOD_AUDIOQUEUE_CODECPOLICY for options (iOS >= 3.0 required, otherwise only hardware is available) */
        public uint                        minmidigranularity;     /* [w] Optional. Specify 0 to ignore. Allows you to set a minimum desired MIDI mixer granularity. Values smaller than 512 give greater than default accuracy at the cost of more CPU and vise versa. Specify 0 for default (512 samples). */
        public int                         nonblockthreadid;       /* [w] Optional. Specify 0 to ignore. Specifies a thread index to execute non blocking load on.  Allows for up to 5 threads to be used for loading at once.  This is to avoid one load blocking another.  Maximum value = 4. */
    }
    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Structure defining a reverb environment for FMOD_SOFTWARE based sounds only.<br>

        [REMARKS]
        Note the default reverb properties are the same as the FMOD_PRESET_GENERIC preset.<br>
        Note that integer values that typically range from -10,000 to 1000 are represented in decibels,
        and are of a logarithmic scale, not linear, wheras float values are always linear.<br>
        <br>
        The numerical values listed below are the maximum, minimum and default values for each variable respectively.<br>
        <br>
        Hardware voice / Platform Specific reverb support.<br>
        WII   See FMODWII.H for hardware specific reverb functionality.<br>
        3DS   See FMOD3DS.H for hardware specific reverb functionality.<br>
        PSP   See FMODWII.H for hardware specific reverb functionality.<br>
        <br>
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.<br>
        Members marked with [w] mean the variable can be written to.  The user can set the value.<br>
        Members marked with [r/w] are either read or write depending on if you are using System::setReverbProperties (w) or System::getReverbProperties (r).

        [SEE_ALSO]
        System::setReverbProperties
        System::getReverbProperties
        FMOD_REVERB_PRESETS
    ]
    */
#pragma warning disable 414
    [StructLayout(LayoutKind.Sequential)]
    public struct REVERB_PROPERTIES
    {                            /*        MIN     MAX    DEFAULT   DESCRIPTION */
        public float DecayTime;         /* [r/w]  0.0    20000.0 1500.0  Reverberation decay time in ms                                        */
        public float EarlyDelay;        /* [r/w]  0.0    300.0   7.0     Initial reflection delay time                                         */
        public float LateDelay;         /* [r/w]  0.0    100     11.0    Late reverberation delay time relative to initial reflection          */
        public float HFReference;       /* [r/w]  20.0   20000.0 5000    Reference high frequency (hz)                                         */
        public float HFDecayRatio;      /* [r/w]  10.0   100.0   50.0    High-frequency to mid-frequency decay time ratio                      */
        public float Diffusion;         /* [r/w]  0.0    100.0   100.0   Value that controls the echo density in the late reverberation decay. */
        public float Density;           /* [r/w]  0.0    100.0   100.0   Value that controls the modal density in the late reverberation decay */
        public float LowShelfFrequency; /* [r/w]  20.0   1000.0  250.0   Reference low frequency (hz)                                          */
        public float LowShelfGain;      /* [r/w]  -36.0  12.0    0.0     Relative room effect level at low frequencies                         */
        public float HighCut;           /* [r/w]  20.0   20000.0 20000.0 Relative room effect level at high frequencies                        */
        public float EarlyLateMix;      /* [r/w]  0.0    100.0   50.0    Early reflections level relative to room effect                       */
        public float WetLevel;          /* [r/w]  -80.0  20.0    -6.0    Room effect level (at mid frequencies)
                                  * */
        #region wrapperinternal
        public REVERB_PROPERTIES(float decayTime, float earlyDelay, float lateDelay, float hfReference,
            float hfDecayRatio, float diffusion, float density, float lowShelfFrequency, float lowShelfGain,
            float highCut, float earlyLateMix, float wetLevel)
        {
            DecayTime = decayTime;
            EarlyDelay = earlyDelay;
            LateDelay = lateDelay;
            HFReference = hfReference;
            HFDecayRatio = hfDecayRatio;
            Diffusion = diffusion;
            Density = density;
            LowShelfFrequency = lowShelfFrequency;
            LowShelfGain = lowShelfGain;
            HighCut = highCut;
            EarlyLateMix = earlyLateMix;
            WetLevel = wetLevel;
        }
        #endregion
    }
#pragma warning restore 414

    /*
    [DEFINE]
    [
    [NAME]
    FMOD_REVERB_PRESETS

    [DESCRIPTION]
    A set of predefined environment PARAMETERS, created by Creative Labs
    These are used to initialize an FMOD_REVERB_PROPERTIES structure statically.
    ie
    FMOD_REVERB_PROPERTIES prop = FMOD_PRESET_GENERIC;

    [SEE_ALSO]
    System::setReverbProperties
    ]
    */
    public class PRESET
    {
        /*                                                                                  Instance  Env   Diffus  Room   RoomHF  RmLF DecTm   DecHF  DecLF   Refl  RefDel   Revb  RevDel  ModTm  ModDp   HFRef    LFRef   Diffus  Densty  FLAGS */
        public static REVERB_PROPERTIES OFF()                 { return new REVERB_PROPERTIES(  1000,    7,  11, 5000, 100, 100, 100, 250, 0,    20,  96, -80.0f );}
        public static REVERB_PROPERTIES GENERIC()             { return new REVERB_PROPERTIES(  1500,    7,  11, 5000,  83, 100, 100, 250, 0, 14500,  96,  -8.0f );}
        public static REVERB_PROPERTIES PADDEDCELL()          { return new REVERB_PROPERTIES(   170,    1,   2, 5000,  10, 100, 100, 250, 0,   160,  84,  -7.8f );}
        public static REVERB_PROPERTIES ROOM()                { return new REVERB_PROPERTIES(   400,    2,   3, 5000,  83, 100, 100, 250, 0,  6050,  88,  -9.4f );}
        public static REVERB_PROPERTIES BATHROOM()            { return new REVERB_PROPERTIES(  1500,    7,  11, 5000,  54, 100,  60, 250, 0,  2900,  83,   0.5f );}
        public static REVERB_PROPERTIES LIVINGROOM()          { return new REVERB_PROPERTIES(   500,    3,   4, 5000,  10, 100, 100, 250, 0,   160,  58, -19.0f );}
        public static REVERB_PROPERTIES STONEROOM()           { return new REVERB_PROPERTIES(  2300,   12,  17, 5000,  64, 100, 100, 250, 0,  7800,  71,  -8.5f );}
        public static REVERB_PROPERTIES AUDITORIUM()          { return new REVERB_PROPERTIES(  4300,   20,  30, 5000,  59, 100, 100, 250, 0,  5850,  64, -11.7f );}
        public static REVERB_PROPERTIES CONCERTHALL()         { return new REVERB_PROPERTIES(  3900,   20,  29, 5000,  70, 100, 100, 250, 0,  5650,  80,  -9.8f );}
        public static REVERB_PROPERTIES CAVE()                { return new REVERB_PROPERTIES(  2900,   15,  22, 5000, 100, 100, 100, 250, 0, 20000,  59, -11.3f );}
        public static REVERB_PROPERTIES ARENA()               { return new REVERB_PROPERTIES(  7200,   20,  30, 5000,  33, 100, 100, 250, 0,  4500,  80,  -9.6f );}
        public static REVERB_PROPERTIES HANGAR()              { return new REVERB_PROPERTIES( 10000,   20,  30, 5000,  23, 100, 100, 250, 0,  3400,  72,  -7.4f );}
        public static REVERB_PROPERTIES CARPETTEDHALLWAY()    { return new REVERB_PROPERTIES(   300,    2,  30, 5000,  10, 100, 100, 250, 0,   500,  56, -24.0f );}
        public static REVERB_PROPERTIES HALLWAY()             { return new REVERB_PROPERTIES(  1500,    7,  11, 5000,  59, 100, 100, 250, 0,  7800,  87,  -5.5f );}
        public static REVERB_PROPERTIES STONECORRIDOR()       { return new REVERB_PROPERTIES(   270,   13,  20, 5000,  79, 100, 100, 250, 0,  9000,  86,  -6.0f );}
        public static REVERB_PROPERTIES ALLEY()               { return new REVERB_PROPERTIES(  1500,    7,  11, 5000,  86, 100, 100, 250, 0,  8300,  80,  -9.8f );}
        public static REVERB_PROPERTIES FOREST()              { return new REVERB_PROPERTIES(  1500,  162,  88, 5000,  54,  79, 100, 250, 0,   760,  94, -12.3f );}
        public static REVERB_PROPERTIES CITY()                { return new REVERB_PROPERTIES(  1500,    7,  11, 5000,  67,  50, 100, 250, 0,  4050,  66, -26.0f );}
        public static REVERB_PROPERTIES MOUNTAINS()           { return new REVERB_PROPERTIES(  1500,  300, 100, 5000,  21,  27, 100, 250, 0,  1220,  82, -24.0f );}
        public static REVERB_PROPERTIES QUARRY()              { return new REVERB_PROPERTIES(  1500,   61,  25, 5000,  83, 100, 100, 250, 0,  3400, 100,  -5.0f );}
        public static REVERB_PROPERTIES PLAIN()               { return new REVERB_PROPERTIES(  1500,  179, 100, 5000,  50,  21, 100, 250, 0,  1670,  65, -28.0f );}
        public static REVERB_PROPERTIES PARKINGLOT()          { return new REVERB_PROPERTIES(  1700,    8,  12, 5000, 100, 100, 100, 250, 0, 20000,  56, -19.5f );}
        public static REVERB_PROPERTIES SEWERPIPE()           { return new REVERB_PROPERTIES(  2800,   14,  21, 5000,  14,  80,  60, 250, 0,  3400,  66,   1.2f );}
        public static REVERB_PROPERTIES UNDERWATER()          { return new REVERB_PROPERTIES(  1500,    7,  11, 5000,  10, 100, 100, 250, 0,   500,  92,   7.0f );}
    }

    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Settings for advanced features like configuring memory and cpu usage for the FMOD_CREATECOMPRESSEDSAMPLE feature.

        [REMARKS]
        maxMPEGCodecs / maxADPCMCodecs / maxXMACodecs will determine the maximum cpu usage of playing realtime samples.  Use this to lower potential excess cpu usage and also control memory usage.<br>

        [SEE_ALSO]
        System::setAdvancedSettings
        System::getAdvancedSettings
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct ADVANCEDSETTINGS
    {
        public int                 cbSize;                     /* [w]   Size of this structure.  Use sizeof(FMOD_ADVANCEDSETTINGS) */
        public int                 maxMPEGCodecs;              /* [r/w] Optional. Specify 0 to ignore. For use with FMOD_CREATECOMPRESSEDSAMPLE only.  MPEG   codecs consume 30,528 bytes per instance and this number will determine how many MPEG   channels can be played simultaneously. Default = 32. */
        public int                 maxADPCMCodecs;             /* [r/w] Optional. Specify 0 to ignore. For use with FMOD_CREATECOMPRESSEDSAMPLE only.  ADPCM  codecs consume  3,128 bytes per instance and this number will determine how many ADPCM  channels can be played simultaneously. Default = 32. */
        public int                 maxXMACodecs;               /* [r/w] Optional. Specify 0 to ignore. For use with FMOD_CREATECOMPRESSEDSAMPLE only.  XMA    codecs consume 14,836 bytes per instance and this number will determine how many XMA    channels can be played simultaneously. Default = 32. */
        public int                 maxVorbisCodecs;            /* [r/w] Optional. Specify 0 to ignore. For use with FMOD_CREATECOMPRESSEDSAMPLE only.  Vorbis codecs consume 23,256 bytes per instance and this number will determine how many Vorbis channels can be played simultaneously. Default = 32. */    
        public int                 maxAT9Codecs;               /* [r/w] Optional. Specify 0 to ignore. For use with FMOD_CREATECOMPRESSEDSAMPLE only.  AT9    codecs consume  8,720 bytes per instance and this number will determine how many AT9    channels can be played simultaneously. Default = 32. */    
        public int                 maxFADPCMCodecs;            /* [r/w] Optional. Specify 0 to ignore. For use with FMOD_CREATECOMPRESSEDSAMPLE only.  This number will determine how many FADPCM channels can be played simultaneously. Default = 32. */
        public int                 maxPCMCodecs;               /* [r/w] Optional. Specify 0 to ignore. For use with PS3 only.                          PCM    codecs consume 12,672 bytes per instance and this number will determine how many streams and PCM voices can be played simultaneously. Default = 16. */
        public int                 ASIONumChannels;            /* [r/w] Optional. Specify 0 to ignore. Number of channels available on the ASIO device. */
        public IntPtr              ASIOChannelList;            /* [r/w] Optional. Specify 0 to ignore. Pointer to an array of strings (number of entries defined by ASIONumChannels) with ASIO channel names. */
        public IntPtr              ASIOSpeakerList;            /* [r/w] Optional. Specify 0 to ignore. Pointer to a list of speakers that the ASIO channels map to.  This can be called after System::init to remap ASIO output. */
        public float               HRTFMinAngle;               /* [r/w] Optional.                      For use with FMOD_INIT_HRTF_LOWPASS.  The angle range (0-360) of a 3D sound in relation to the listener, at which the HRTF function begins to have an effect. 0 = in front of the listener. 180 = from 90 degrees to the left of the listener to 90 degrees to the right. 360 = behind the listener. Default = 180.0. */
        public float               HRTFMaxAngle;               /* [r/w] Optional.                      For use with FMOD_INIT_HRTF_LOWPASS.  The angle range (0-360) of a 3D sound in relation to the listener, at which the HRTF function has maximum effect. 0 = front of the listener. 180 = from 90 degrees to the left of the listener to 90 degrees to the right. 360 = behind the listener. Default = 360.0. */
        public float               HRTFFreq;                   /* [r/w] Optional. Specify 0 to ignore. For use with FMOD_INIT_HRTF_LOWPASS.  The cutoff frequency of the HRTF's lowpass filter function when at maximum effect. (i.e. at HRTFMaxAngle).  Default = 4000.0. */
        public float               vol0virtualvol;             /* [r/w] Optional. Specify 0 to ignore. For use with FMOD_INIT_VOL0_BECOMES_VIRTUAL.  If this flag is used, and the volume is below this, then the sound will become virtual.  Use this value to raise the threshold to a different point where a sound goes virtual. */
        public uint                defaultDecodeBufferSize;    /* [r/w] Optional. Specify 0 to ignore. For streams. This determines the default size of the double buffer (in milliseconds) that a stream uses.  Default = 400ms */
        public ushort              profilePort;                /* [r/w] Optional. Specify 0 to ignore. For use with FMOD_INIT_PROFILE_ENABLE.  Specify the port to listen on for connections by the profiler application. */
        public uint                geometryMaxFadeTime;        /* [r/w] Optional. Specify 0 to ignore. The maximum time in miliseconds it takes for a channel to fade to the new level when its occlusion changes. */
        public float               distanceFilterCenterFreq;   /* [r/w] Optional. Specify 0 to ignore. For use with FMOD_INIT_DISTANCE_FILTERING.  The default center frequency in Hz for the distance filtering effect. Default = 1500.0. */
        public int                 reverb3Dinstance;           /* [r/w] Optional. Specify 0 to ignore. Out of 0 to 3, 3d reverb spheres will create a phyical reverb unit on this instance slot.  See FMOD_REVERB_PROPERTIES. */
        public int                 DSPBufferPoolSize;          /* [r/w] Optional. Specify 0 to ignore. Number of buffers in DSP buffer pool.  Each buffer will be DSPBlockSize * sizeof(float) * SpeakerModeChannelCount.  ie 7.1 @ 1024 DSP block size = 8 * 1024 * 4 = 32kb.  Default = 8. */
        public uint                stackSizeStream;            /* [r/w] Optional. Specify 0 to ignore. Specify the stack size for the FMOD Stream thread in bytes.  Useful for custom codecs that use excess stack.  Default 49,152 (48kb) */
        public uint                stackSizeNonBlocking;       /* [r/w] Optional. Specify 0 to ignore. Specify the stack size for the FMOD_NONBLOCKING loading thread.  Useful for custom codecs that use excess stack.  Default 65,536 (64kb) */
        public uint                stackSizeMixer;             /* [r/w] Optional. Specify 0 to ignore. Specify the stack size for the FMOD mixer thread.  Useful for custom dsps that use excess stack.  Default 49,152 (48kb) */
        public DSP_RESAMPLER       resamplerMethod;            /* [r/w] Optional. Specify 0 to ignore. Resampling method used with fmod's software mixer.  See FMOD_DSP_RESAMPLER for details on methods. */
        public uint                commandQueueSize;           /* [r/w] Optional. Specify 0 to ignore. Specify the command queue size for thread safe processing.  Default 2048 (2kb) */
        public uint                randomSeed;                 /* [r/w] Optional. Specify 0 to ignore. Seed value that FMOD will use to initialize its internal random number generators. */
    }

    /*
    [DEFINE]
    [
        [NAME]
        FMOD_DRIVER_STATE

        [DESCRIPTION]
        Flags that provide additional information about a particular driver.

        [REMARKS]

        [SEE_ALSO]
        System::getRecordDriverInfo
    ]
    */
    [Flags]
    public enum DRIVER_STATE : uint
    {
        CONNECTED = 0x00000001, /* Device is currently plugged in. */
        DEFAULT   = 0x00000002, /* Device is the users preferred choice. */
    }

    /*
        FMOD System factory functions.  Use this to create an FMOD System Instance.  below you will see System init/close to get started.
    */
    public class Factory
    {

        static Factory()
        {
            DllLoader.PreloadDll(VERSION.dll);
        }

        public static RESULT System_Create(out System system)
        {
            system = null;

            RESULT result   = RESULT.OK;
            IntPtr rawPtr   = new IntPtr();

            result = FMOD_System_Create(out rawPtr);
            if (result != RESULT.OK)
            {
                return result;
            }

            system = new System(rawPtr);

            return result;
        }


        #region importfunctions

        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_Create                      (out IntPtr system);

        #endregion
    }

    public class Memory
    {
        public static RESULT Initialize(IntPtr poolmem, int poollen, MEMORY_ALLOC_CALLBACK useralloc, MEMORY_REALLOC_CALLBACK userrealloc, MEMORY_FREE_CALLBACK userfree, MEMORY_TYPE memtypeflags)
        {
            return FMOD_Memory_Initialize(poolmem, poollen, useralloc, userrealloc, userfree, memtypeflags);
        }

        public static RESULT GetStats(out int currentalloced, out int maxalloced)
        {
            return GetStats(out currentalloced, out maxalloced, false);
        }

        public static RESULT GetStats(out int currentalloced, out int maxalloced, bool blocking)
        {
            return FMOD_Memory_GetStats(out currentalloced, out maxalloced, blocking);
        }


        #region importfunctions

        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Memory_Initialize(IntPtr poolmem, int poollen, MEMORY_ALLOC_CALLBACK useralloc, MEMORY_REALLOC_CALLBACK userrealloc, MEMORY_FREE_CALLBACK userfree, MEMORY_TYPE memtypeflags);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Memory_GetStats(out int currentalloced, out int maxalloced, bool blocking);

        #endregion
    }

    public class Debug
    {
        public static RESULT Initialize(DEBUG_FLAGS flags, DEBUG_MODE mode, DEBUG_CALLBACK callback, string filename)
        {
            return FMOD_Debug_Initialize(flags, mode, callback, filename);
        }


        #region importfunctions

        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Debug_Initialize(DEBUG_FLAGS flags, DEBUG_MODE mode, DEBUG_CALLBACK callback, string filename);

        #endregion
    }

    public class HandleBase
    {
        public HandleBase(IntPtr newPtr)
        {
            rawPtr = newPtr;
        }

        public bool isValid()
        {
            return rawPtr != IntPtr.Zero;
        }

        public IntPtr getRaw()
        {
            return rawPtr;
        }

        protected IntPtr rawPtr;

        #region equality

        public override bool Equals(Object obj)
        {
            return Equals(obj as HandleBase);
        }
        public bool Equals(HandleBase p)
        {
            // Equals if p not null and handle is the same
            return ((object)p != null && rawPtr == p.rawPtr);
        }
        public override int GetHashCode()
        {
            return rawPtr.ToInt32();
        }
        public static bool operator ==(HandleBase a, HandleBase b)
        {
            // If both are null, or both are same instance, return true.
            if (Object.ReferenceEquals(a, b))
            {
                return true;
            }
            // If one is null, but not both, return false.
            if (((object)a == null) || ((object)b == null))
            {
                return false;
            }
            // Return true if the handle matches
            return (a.rawPtr == b.rawPtr);
        }
        public static bool operator !=(HandleBase a, HandleBase b)
        {
            return !(a == b);
        }
        #endregion

    }

    /*
        'System' API.
    */
    public class System : HandleBase
    {
        public RESULT release                ()
        {
            RESULT result = FMOD_System_Release(rawPtr);
            if (result == RESULT.OK)
            {
                rawPtr = IntPtr.Zero;
            }
            return result;
        }


        // Pre-init functions.
        public RESULT setOutput              (OUTPUTTYPE output)
        {
            return FMOD_System_SetOutput(rawPtr, output);
        }
        public RESULT getOutput              (out OUTPUTTYPE output)
        {
            return FMOD_System_GetOutput(rawPtr, out output);
        }
        public RESULT getNumDrivers          (out int numdrivers)
        {
            return FMOD_System_GetNumDrivers(rawPtr, out numdrivers);
        }
        public RESULT getDriverInfo          (int id, StringBuilder name, int namelen, out Guid guid, out int systemrate, out SPEAKERMODE speakermode, out int speakermodechannels)
        {
            IntPtr stringMem = Marshal.AllocHGlobal(name.Capacity);

            RESULT result = FMOD_System_GetDriverInfo(rawPtr, id, stringMem, namelen, out guid, out systemrate, out speakermode, out speakermodechannels);

            StringMarshalHelper.NativeToBuilder(name, stringMem);
            Marshal.FreeHGlobal(stringMem);

            return result;
        }
        public RESULT setDriver              (int driver)
        {
            return FMOD_System_SetDriver(rawPtr, driver);
        }
        public RESULT getDriver              (out int driver)
        {
            return FMOD_System_GetDriver(rawPtr, out driver);
        }
        public RESULT setSoftwareChannels    (int numsoftwarechannels)
        {
            return FMOD_System_SetSoftwareChannels(rawPtr, numsoftwarechannels);
        }
        public RESULT getSoftwareChannels    (out int numsoftwarechannels)
        {
            return FMOD_System_GetSoftwareChannels(rawPtr, out numsoftwarechannels);
        }
        public RESULT setSoftwareFormat      (int samplerate, SPEAKERMODE speakermode, int numrawspeakers)
        {
            return FMOD_System_SetSoftwareFormat(rawPtr, samplerate, speakermode, numrawspeakers);
        }
        public RESULT getSoftwareFormat      (out int samplerate, out SPEAKERMODE speakermode, out int numrawspeakers)
        {
            return FMOD_System_GetSoftwareFormat(rawPtr, out samplerate, out speakermode, out numrawspeakers);
        }
        public RESULT setDSPBufferSize       (uint bufferlength, int numbuffers)
        {
            return FMOD_System_SetDSPBufferSize(rawPtr, bufferlength, numbuffers);
        }
        public RESULT getDSPBufferSize       (out uint bufferlength, out int numbuffers)
        {
            return FMOD_System_GetDSPBufferSize(rawPtr, out bufferlength, out numbuffers);
        }
        public RESULT setFileSystem          (FILE_OPENCALLBACK useropen, FILE_CLOSECALLBACK userclose, FILE_READCALLBACK userread, FILE_SEEKCALLBACK userseek, FILE_ASYNCREADCALLBACK userasyncread, FILE_ASYNCCANCELCALLBACK userasynccancel, int blockalign)
        {
            return FMOD_System_SetFileSystem(rawPtr, useropen, userclose, userread, userseek, userasyncread, userasynccancel, blockalign);
        }
        public RESULT attachFileSystem       (FILE_OPENCALLBACK useropen, FILE_CLOSECALLBACK userclose, FILE_READCALLBACK userread, FILE_SEEKCALLBACK userseek)
        {
            return FMOD_System_AttachFileSystem(rawPtr, useropen, userclose, userread, userseek);
        }
        public RESULT setAdvancedSettings    (ref ADVANCEDSETTINGS settings)
        {
            settings.cbSize = Marshal.SizeOf(settings);
            return FMOD_System_SetAdvancedSettings(rawPtr, ref settings);
        }
        public RESULT getAdvancedSettings    (ref ADVANCEDSETTINGS settings)
        {
            settings.cbSize = Marshal.SizeOf(settings);
            return FMOD_System_GetAdvancedSettings(rawPtr, ref settings);
        }
        public RESULT setCallback            (SYSTEM_CALLBACK callback, SYSTEM_CALLBACK_TYPE callbackmask)
        {
            return FMOD_System_SetCallback(rawPtr, callback, callbackmask);
        }

        // Plug-in support.
        public RESULT setPluginPath          (string path)
        {
            return FMOD_System_SetPluginPath(rawPtr, Encoding.UTF8.GetBytes(path + Char.MinValue));
        }
        public RESULT loadPlugin             (string filename, out uint handle, uint priority)
        {
            return FMOD_System_LoadPlugin(rawPtr, Encoding.UTF8.GetBytes(filename + Char.MinValue), out handle, priority);
        }
        public RESULT loadPlugin             (string filename, out uint handle)
        {
            return loadPlugin(filename, out handle, 0);
        }
        public RESULT unloadPlugin           (uint handle)
        {
            return FMOD_System_UnloadPlugin(rawPtr, handle);
        }
        public RESULT getNumPlugins          (PLUGINTYPE plugintype, out int numplugins)
        {
            return FMOD_System_GetNumPlugins(rawPtr, plugintype, out numplugins);
        }
        public RESULT getPluginHandle        (PLUGINTYPE plugintype, int index, out uint handle)
        {
            return FMOD_System_GetPluginHandle(rawPtr, plugintype, index, out handle);
        }
        public RESULT getPluginInfo          (uint handle, out PLUGINTYPE plugintype, StringBuilder name, int namelen, out uint version)
        {
            IntPtr stringMem = Marshal.AllocHGlobal(name.Capacity);

            RESULT result = FMOD_System_GetPluginInfo(rawPtr, handle, out plugintype, stringMem, namelen, out version);

            StringMarshalHelper.NativeToBuilder(name, stringMem);
            Marshal.FreeHGlobal(stringMem);

            return result;
        }
        public RESULT setOutputByPlugin      (uint handle)
        {
            return FMOD_System_SetOutputByPlugin(rawPtr, handle);
        }
        public RESULT getOutputByPlugin      (out uint handle)
        {
            return FMOD_System_GetOutputByPlugin(rawPtr, out handle);
        }
        public RESULT createDSPByPlugin(uint handle, out DSP dsp)
        {
            dsp = null;

            IntPtr dspraw;
            RESULT result = FMOD_System_CreateDSPByPlugin(rawPtr, handle, out dspraw);
            dsp = new DSP(dspraw);

            return result;
        }
        public RESULT getDSPInfoByPlugin(uint handle, out IntPtr description)
        {
            return FMOD_System_GetDSPInfoByPlugin(rawPtr, handle, out description);
        }
        /*
        public RESULT registerCodec(ref CODEC_DESCRIPTION description, out uint handle, uint priority)
        {
            return FMOD_System_RegisterCodec(rawPtr, ref description, out handle, priority);
        }
        */
        public RESULT registerDSP(ref DSP_DESCRIPTION description, out uint handle)
        {
            return FMOD_System_RegisterDSP(rawPtr, ref description, out handle);
        }
        /*
        public RESULT registerOutput(ref OUTPUT_DESCRIPTION description, out uint handle)
        {
            return FMOD_System_RegisterOutput(rawPtr, ref description, out handle);
        }
        */

        // Init/Close.
        public RESULT init                   (int maxchannels, INITFLAGS flags, IntPtr extradriverdata)
        {
            return FMOD_System_Init(rawPtr, maxchannels, flags, extradriverdata);
        }
        public RESULT close                  ()
        {
            return FMOD_System_Close(rawPtr);
        }


        // General post-init system functions.
        public RESULT update                 ()
        {
            return FMOD_System_Update(rawPtr);
        }

        public RESULT setSpeakerPosition(SPEAKER speaker, float x, float y, bool active)
        {
            return FMOD_System_SetSpeakerPosition(rawPtr, speaker, x, y, active);
        }
        public RESULT getSpeakerPosition(SPEAKER speaker, out float x, out float y, out bool active)
        {
            return FMOD_System_GetSpeakerPosition(rawPtr, speaker, out x, out y, out active);
        }
        public RESULT setStreamBufferSize(uint filebuffersize, TIMEUNIT filebuffersizetype)
        {
            return FMOD_System_SetStreamBufferSize(rawPtr, filebuffersize, filebuffersizetype);
        }
        public RESULT getStreamBufferSize(out uint filebuffersize, out TIMEUNIT filebuffersizetype)
        {
            return FMOD_System_GetStreamBufferSize(rawPtr, out filebuffersize, out filebuffersizetype);
        }
        public RESULT set3DSettings          (float dopplerscale, float distancefactor, float rolloffscale)
        {
            return FMOD_System_Set3DSettings(rawPtr, dopplerscale, distancefactor, rolloffscale);
        }
        public RESULT get3DSettings          (out float dopplerscale, out float distancefactor, out float rolloffscale)
        {
            return FMOD_System_Get3DSettings(rawPtr, out dopplerscale, out distancefactor, out rolloffscale);
        }
        public RESULT set3DNumListeners      (int numlisteners)
        {
            return FMOD_System_Set3DNumListeners(rawPtr, numlisteners);
        }
        public RESULT get3DNumListeners      (out int numlisteners)
        {
            return FMOD_System_Get3DNumListeners(rawPtr, out numlisteners);
        }
        public RESULT set3DListenerAttributes(int listener, ref VECTOR pos, ref VECTOR vel, ref VECTOR forward, ref VECTOR up)
        {
            return FMOD_System_Set3DListenerAttributes(rawPtr, listener, ref pos, ref vel, ref forward, ref up);
        }
        public RESULT get3DListenerAttributes(int listener, out VECTOR pos, out VECTOR vel, out VECTOR forward, out VECTOR up)
        {
            return FMOD_System_Get3DListenerAttributes(rawPtr, listener, out pos, out vel, out forward, out up);
        }
        public RESULT set3DRolloffCallback   (CB_3D_ROLLOFFCALLBACK callback)
        {
            return FMOD_System_Set3DRolloffCallback   (rawPtr, callback);
        }
        public RESULT mixerSuspend           ()
        {
            return FMOD_System_MixerSuspend(rawPtr);
        }
        public RESULT mixerResume            ()
        {
            return FMOD_System_MixerResume(rawPtr);
        }
        public RESULT getDefaultMixMatrix    (SPEAKERMODE sourcespeakermode, SPEAKERMODE targetspeakermode, float[] matrix, int matrixhop)
        {
            return FMOD_System_GetDefaultMixMatrix(rawPtr, sourcespeakermode, targetspeakermode, matrix, matrixhop);
        }
        public RESULT getSpeakerModeChannels (SPEAKERMODE mode, out int channels)
        {
            return FMOD_System_GetSpeakerModeChannels(rawPtr, mode, out channels);
        }

        // System information functions.
        public RESULT getVersion             (out uint version)
        {
            return FMOD_System_GetVersion(rawPtr, out version);
        }
        public RESULT getOutputHandle        (out IntPtr handle)
        {
            return FMOD_System_GetOutputHandle(rawPtr, out handle);
        }
        public RESULT getChannelsPlaying     (out int channels)
        {
            return FMOD_System_GetChannelsPlaying(rawPtr, out channels);
        }
        public RESULT getChannelsReal        (out int channels)
        {
            return FMOD_System_GetChannelsReal(rawPtr, out channels);
        }
        public RESULT getCPUUsage            (out float dsp, out float stream, out float geometry, out float update, out float total)
        {
            return FMOD_System_GetCPUUsage(rawPtr, out dsp, out stream, out geometry, out update, out total);
        }
        public RESULT getSoundRAM            (out int currentalloced, out int maxalloced, out int total)
        {
            return FMOD_System_GetSoundRAM(rawPtr, out currentalloced, out maxalloced, out total);
        }

        // Sound/DSP/Channel/FX creation and retrieval.
        public RESULT createSound            (string name, MODE mode, ref CREATESOUNDEXINFO exinfo, out Sound sound)
        {
            sound = null;

            byte[] stringData;
            stringData = Encoding.UTF8.GetBytes(name + Char.MinValue);
            
            exinfo.cbsize = Marshal.SizeOf(exinfo);

            IntPtr soundraw;
            RESULT result = FMOD_System_CreateSound(rawPtr, stringData, mode, ref exinfo, out soundraw);
            sound = new Sound(soundraw);

            return result;
        }
        public RESULT createSound            (byte[] data, MODE mode, ref CREATESOUNDEXINFO exinfo, out Sound sound)
        {
            sound = null;

            exinfo.cbsize = Marshal.SizeOf(exinfo);

            IntPtr soundraw;
            RESULT result = FMOD_System_CreateSound(rawPtr, data, mode, ref exinfo, out soundraw);
            sound = new Sound(soundraw);

            return result;
        }
        public RESULT createSound            (string name, MODE mode, out Sound sound)
        {
            CREATESOUNDEXINFO exinfo = new CREATESOUNDEXINFO();
            exinfo.cbsize = Marshal.SizeOf(exinfo);

            return createSound(name, mode, ref exinfo, out sound);
        }
        public RESULT createStream            (string name, MODE mode, ref CREATESOUNDEXINFO exinfo, out Sound sound)
        {
            sound = null;

            byte[] stringData;
            stringData = Encoding.UTF8.GetBytes(name + Char.MinValue);
            
            exinfo.cbsize = Marshal.SizeOf(exinfo);

            IntPtr soundraw;
            RESULT result = FMOD_System_CreateStream(rawPtr, stringData, mode, ref exinfo, out soundraw);
            sound = new Sound(soundraw);

            return result;
        }
        public RESULT createStream            (byte[] data, MODE mode, ref CREATESOUNDEXINFO exinfo, out Sound sound)
        {
            sound = null;

            exinfo.cbsize = Marshal.SizeOf(exinfo);

            IntPtr soundraw;
            RESULT result = FMOD_System_CreateStream(rawPtr, data, mode, ref exinfo, out soundraw);
            sound = new Sound(soundraw);

            return result;
        }
        public RESULT createStream            (string name, MODE mode, out Sound sound)
        {
            CREATESOUNDEXINFO exinfo = new CREATESOUNDEXINFO();
            exinfo.cbsize = Marshal.SizeOf(exinfo);

            return createStream(name, mode, ref exinfo, out sound);
        }
        public RESULT createDSP              (ref DSP_DESCRIPTION description, out DSP dsp)
        {
            dsp = null;

            IntPtr dspraw;
            RESULT result = FMOD_System_CreateDSP(rawPtr, ref description, out dspraw);
            dsp = new DSP(dspraw);

            return result;
        }
        public RESULT createDSPByType          (DSP_TYPE type, out DSP dsp)
        {
            dsp = null;

            IntPtr dspraw;
            RESULT result = FMOD_System_CreateDSPByType(rawPtr, type, out dspraw);
            dsp = new DSP(dspraw);

            return result;
        }
        public RESULT createChannelGroup     (string name, out ChannelGroup channelgroup)
        {
            channelgroup = null;

            byte[] stringData = Encoding.UTF8.GetBytes(name + Char.MinValue);

            IntPtr channelgroupraw;
            RESULT result = FMOD_System_CreateChannelGroup(rawPtr, stringData, out channelgroupraw);
            channelgroup = new ChannelGroup(channelgroupraw);

            return result;
        }
        public RESULT createSoundGroup       (string name, out SoundGroup soundgroup)
        {
            soundgroup = null;

            byte[] stringData = Encoding.UTF8.GetBytes(name + Char.MinValue);

            IntPtr soundgroupraw;
            RESULT result = FMOD_System_CreateSoundGroup(rawPtr, stringData, out soundgroupraw);
            soundgroup = new SoundGroup(soundgroupraw);

            return result;
        }
        public RESULT createReverb3D         (out Reverb3D reverb)
        {
            IntPtr reverbraw;
            RESULT result = FMOD_System_CreateReverb3D(rawPtr, out reverbraw);
            reverb = new Reverb3D(reverbraw);

            return result;
        }
        public RESULT playSound              (Sound sound, ChannelGroup channelGroup, bool paused, out Channel channel)
        {
            channel = null;

            IntPtr channelGroupRaw = (channelGroup != null) ? channelGroup.getRaw() : IntPtr.Zero;

            IntPtr channelraw;
            RESULT result = FMOD_System_PlaySound(rawPtr, sound.getRaw(), channelGroupRaw, paused, out channelraw);
            channel = new Channel(channelraw);

            return result;
        }
        public RESULT playDSP                (DSP dsp, ChannelGroup channelGroup, bool paused, out Channel channel)
        {
            channel = null;

            IntPtr channelGroupRaw = (channelGroup != null) ? channelGroup.getRaw() : IntPtr.Zero;

            IntPtr channelraw;
            RESULT result = FMOD_System_PlayDSP(rawPtr, dsp.getRaw(), channelGroupRaw, paused, out channelraw);
            channel = new Channel(channelraw);

            return result;
        }
        public RESULT getChannel             (int channelid, out Channel channel)
        {
            channel = null;

            IntPtr channelraw;
            RESULT result = FMOD_System_GetChannel(rawPtr, channelid, out channelraw);
            channel = new Channel(channelraw);

            return result;
        }
        public RESULT getMasterChannelGroup  (out ChannelGroup channelgroup)
        {
            channelgroup = null;

            IntPtr channelgroupraw;
            RESULT result = FMOD_System_GetMasterChannelGroup(rawPtr, out channelgroupraw);
            channelgroup = new ChannelGroup(channelgroupraw);

            return result;
        }
        public RESULT getMasterSoundGroup    (out SoundGroup soundgroup)
        {
            soundgroup = null;

            IntPtr soundgroupraw;
            RESULT result = FMOD_System_GetMasterSoundGroup(rawPtr, out soundgroupraw);
            soundgroup = new SoundGroup(soundgroupraw);

            return result;
        }

        // Routing to ports.
        public RESULT attachChannelGroupToPort(uint portType, ulong portIndex, ChannelGroup channelgroup, bool passThru = false)
        {
            return FMOD_System_AttachChannelGroupToPort(rawPtr, portType, portIndex, channelgroup.getRaw(), passThru);
        }
        public RESULT detachChannelGroupFromPort(ChannelGroup channelgroup)
        {
            return FMOD_System_DetachChannelGroupFromPort(rawPtr, channelgroup.getRaw());
        }

        // Reverb api.
        public RESULT setReverbProperties    (int instance, ref REVERB_PROPERTIES prop)
        {
            return FMOD_System_SetReverbProperties(rawPtr, instance, ref prop);
        }
        public RESULT getReverbProperties    (int instance, out REVERB_PROPERTIES prop)
        {
            return FMOD_System_GetReverbProperties(rawPtr, instance, out prop);
        }

        // System level DSP functionality.
        public RESULT lockDSP            ()
        {
            return FMOD_System_LockDSP(rawPtr);
        }
        public RESULT unlockDSP          ()
        {
            return FMOD_System_UnlockDSP(rawPtr);
        }

        // Recording api
        public RESULT getRecordNumDrivers    (out int numdrivers, out int numconnected)
        {
            return FMOD_System_GetRecordNumDrivers(rawPtr, out numdrivers, out numconnected);
        }
        public RESULT getRecordDriverInfo(int id, StringBuilder name, int namelen, out Guid guid, out int systemrate, out SPEAKERMODE speakermode, out int speakermodechannels, out DRIVER_STATE state)
        {
            IntPtr stringMem = Marshal.AllocHGlobal(name.Capacity);

            RESULT result = FMOD_System_GetRecordDriverInfo(rawPtr, id, stringMem, namelen, out guid, out systemrate, out speakermode, out speakermodechannels, out state);

            StringMarshalHelper.NativeToBuilder(name, stringMem);
            Marshal.FreeHGlobal(stringMem);

            return result;
        }
        public RESULT getRecordPosition      (int id, out uint position)
        {
            return FMOD_System_GetRecordPosition(rawPtr, id, out position);
        }
        public RESULT recordStart            (int id, Sound sound, bool loop)
        {
            return FMOD_System_RecordStart(rawPtr, id, sound.getRaw(), loop);
        }
        public RESULT recordStop             (int id)
        {
            return FMOD_System_RecordStop(rawPtr, id);
        }
        public RESULT isRecording            (int id, out bool recording)
        {
            return FMOD_System_IsRecording(rawPtr, id, out recording);
        }

        // Geometry api
        public RESULT createGeometry         (int maxpolygons, int maxvertices, out Geometry geometry)
        {
            geometry = null;

            IntPtr geometryraw;
            RESULT result = FMOD_System_CreateGeometry(rawPtr, maxpolygons, maxvertices, out geometryraw);
            geometry = new Geometry(geometryraw);

            return result;
        }
        public RESULT setGeometrySettings    (float maxworldsize)
        {
            return FMOD_System_SetGeometrySettings(rawPtr, maxworldsize);
        }
        public RESULT getGeometrySettings    (out float maxworldsize)
        {
            return FMOD_System_GetGeometrySettings(rawPtr, out maxworldsize);
        }
        public RESULT loadGeometry(IntPtr data, int datasize, out Geometry geometry)
        {
            geometry = null;

            IntPtr geometryraw;
            RESULT result = FMOD_System_LoadGeometry(rawPtr, data, datasize, out geometryraw);
            geometry = new Geometry(geometryraw);

            return result;
        }
        public RESULT getGeometryOcclusion    (ref VECTOR listener, ref VECTOR source, out float direct, out float reverb)
        {
            return FMOD_System_GetGeometryOcclusion(rawPtr, ref listener, ref source, out direct, out reverb);
        }

        // Network functions
        public RESULT setNetworkProxy               (string proxy)
        {
            return FMOD_System_SetNetworkProxy(rawPtr, Encoding.UTF8.GetBytes(proxy + Char.MinValue));
        }
        public RESULT getNetworkProxy               (StringBuilder proxy, int proxylen)
        {
            IntPtr stringMem = Marshal.AllocHGlobal(proxy.Capacity);

            RESULT result = FMOD_System_GetNetworkProxy(rawPtr, stringMem, proxylen);

            StringMarshalHelper.NativeToBuilder(proxy, stringMem);
            Marshal.FreeHGlobal(stringMem);

            return result;
        }
        public RESULT setNetworkTimeout      (int timeout)
        {
            return FMOD_System_SetNetworkTimeout(rawPtr, timeout);
        }
        public RESULT getNetworkTimeout(out int timeout)
        {
            return FMOD_System_GetNetworkTimeout(rawPtr, out timeout);
        }

        // Userdata set/get
        public RESULT setUserData            (IntPtr userdata)
        {
            return FMOD_System_SetUserData(rawPtr, userdata);
        }
        public RESULT getUserData            (out IntPtr userdata)
        {
            return FMOD_System_GetUserData(rawPtr, out userdata);
        }


        #region importfunctions
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_Release                (IntPtr system);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetOutput              (IntPtr system, OUTPUTTYPE output);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetOutput              (IntPtr system, out OUTPUTTYPE output);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetNumDrivers          (IntPtr system, out int numdrivers);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetDriverInfo          (IntPtr system, int id, IntPtr name, int namelen, out Guid guid, out int systemrate, out SPEAKERMODE speakermode, out int speakermodechannels);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetDriver              (IntPtr system, int driver);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetDriver              (IntPtr system, out int driver);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetSoftwareChannels    (IntPtr system, int numsoftwarechannels);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetSoftwareChannels    (IntPtr system, out int numsoftwarechannels);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetSoftwareFormat      (IntPtr system, int samplerate, SPEAKERMODE speakermode, int numrawspeakers);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetSoftwareFormat      (IntPtr system, out int samplerate, out SPEAKERMODE speakermode, out int numrawspeakers);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetDSPBufferSize       (IntPtr system, uint bufferlength, int numbuffers);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetDSPBufferSize       (IntPtr system, out uint bufferlength, out int numbuffers);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetFileSystem          (IntPtr system, FILE_OPENCALLBACK useropen, FILE_CLOSECALLBACK userclose, FILE_READCALLBACK userread, FILE_SEEKCALLBACK userseek, FILE_ASYNCREADCALLBACK userasyncread, FILE_ASYNCCANCELCALLBACK userasynccancel, int blockalign);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_AttachFileSystem       (IntPtr system, FILE_OPENCALLBACK useropen, FILE_CLOSECALLBACK userclose, FILE_READCALLBACK userread, FILE_SEEKCALLBACK userseek);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetPluginPath          (IntPtr system, byte[] path);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_LoadPlugin             (IntPtr system, byte[] filename, out uint handle, uint priority);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_UnloadPlugin           (IntPtr system, uint handle);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetNumPlugins          (IntPtr system, PLUGINTYPE plugintype, out int numplugins);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetPluginHandle        (IntPtr system, PLUGINTYPE plugintype, int index, out uint handle);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetPluginInfo          (IntPtr system, uint handle, out PLUGINTYPE plugintype, IntPtr name, int namelen, out uint version);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_CreateDSPByPlugin      (IntPtr system, uint handle, out IntPtr dsp);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetOutputByPlugin      (IntPtr system, uint handle);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetOutputByPlugin      (IntPtr system, out uint handle);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetDSPInfoByPlugin     (IntPtr system, uint handle, out IntPtr description);
        [DllImport(VERSION.dll)]
        //private static extern RESULT FMOD_System_RegisterCodec          (IntPtr system, out CODEC_DESCRIPTION description, out uint handle, uint priority);
        //[DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_RegisterDSP            (IntPtr system, ref DSP_DESCRIPTION description, out uint handle);
        [DllImport(VERSION.dll)]
        //private static extern RESULT FMOD_System_RegisterOutput         (IntPtr system, ref OUTPUT_DESCRIPTION description, out uint handle);
        //[DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_Init                   (IntPtr system, int maxchannels, INITFLAGS flags, IntPtr extradriverdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_Close                  (IntPtr system);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_Update                 (IntPtr system);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetAdvancedSettings    (IntPtr system, ref ADVANCEDSETTINGS settings);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetAdvancedSettings    (IntPtr system, ref ADVANCEDSETTINGS settings);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_Set3DRolloffCallback   (IntPtr system, CB_3D_ROLLOFFCALLBACK callback);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_MixerSuspend           (IntPtr system);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_MixerResume            (IntPtr system);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetDefaultMixMatrix    (IntPtr system, SPEAKERMODE sourcespeakermode, SPEAKERMODE targetspeakermode, float[] matrix, int matrixhop);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetSpeakerModeChannels (IntPtr system, SPEAKERMODE mode, out int channels);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetCallback            (IntPtr system, SYSTEM_CALLBACK callback, SYSTEM_CALLBACK_TYPE callbackmask);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetSpeakerPosition     (IntPtr system, SPEAKER speaker, float x, float y, bool active);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetSpeakerPosition     (IntPtr system, SPEAKER speaker, out float x, out float y, out bool active);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_Set3DSettings          (IntPtr system, float dopplerscale, float distancefactor, float rolloffscale);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_Get3DSettings          (IntPtr system, out float dopplerscale, out float distancefactor, out float rolloffscale);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_Set3DNumListeners      (IntPtr system, int numlisteners);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_Get3DNumListeners      (IntPtr system, out int numlisteners);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_Set3DListenerAttributes(IntPtr system, int listener, ref VECTOR pos, ref VECTOR vel, ref VECTOR forward, ref VECTOR up);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_Get3DListenerAttributes(IntPtr system, int listener, out VECTOR pos, out VECTOR vel, out VECTOR forward, out VECTOR up);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetStreamBufferSize    (IntPtr system, uint filebuffersize, TIMEUNIT filebuffersizetype);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetStreamBufferSize    (IntPtr system, out uint filebuffersize, out TIMEUNIT filebuffersizetype);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetVersion             (IntPtr system, out uint version);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetOutputHandle        (IntPtr system, out IntPtr handle);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetChannelsPlaying     (IntPtr system, out int channels);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetChannelsReal        (IntPtr system, out int channels);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetCPUUsage            (IntPtr system, out float dsp, out float stream, out float geometry, out float update, out float total);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetSoundRAM            (IntPtr system, out int currentalloced, out int maxalloced, out int total);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_CreateSound            (IntPtr system, byte[] name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, out IntPtr sound);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_CreateStream           (IntPtr system, byte[] name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, out IntPtr sound);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_CreateDSP              (IntPtr system, ref DSP_DESCRIPTION description, out IntPtr dsp);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_CreateDSPByType        (IntPtr system, DSP_TYPE type, out IntPtr dsp);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_CreateChannelGroup     (IntPtr system, byte[] name, out IntPtr channelgroup);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_CreateSoundGroup       (IntPtr system, byte[] name, out IntPtr soundgroup);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_CreateReverb3D         (IntPtr system, out IntPtr reverb);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_PlaySound              (IntPtr system, IntPtr sound, IntPtr channelGroup, bool paused, out IntPtr channel);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_PlayDSP                (IntPtr system, IntPtr dsp, IntPtr channelGroup, bool paused, out IntPtr channel);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetChannel             (IntPtr system, int channelid, out IntPtr channel);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetMasterChannelGroup  (IntPtr system, out IntPtr channelgroup);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetMasterSoundGroup    (IntPtr system, out IntPtr soundgroup);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_AttachChannelGroupToPort  (IntPtr system, uint portType, ulong portIndex, IntPtr channelgroup, bool passThru);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_DetachChannelGroupFromPort(IntPtr system, IntPtr channelgroup);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetReverbProperties    (IntPtr system, int instance, ref REVERB_PROPERTIES prop);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetReverbProperties    (IntPtr system, int instance, out REVERB_PROPERTIES prop);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_LockDSP                (IntPtr system);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_UnlockDSP              (IntPtr system);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetRecordNumDrivers    (IntPtr system, out int numdrivers, out int numconnected);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetRecordDriverInfo    (IntPtr system, int id, IntPtr name, int namelen, out Guid guid, out int systemrate, out SPEAKERMODE speakermode, out int speakermodechannels, out DRIVER_STATE state);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetRecordPosition      (IntPtr system, int id, out uint position);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_RecordStart            (IntPtr system, int id, IntPtr sound, bool loop);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_RecordStop             (IntPtr system, int id);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_IsRecording            (IntPtr system, int id, out bool recording);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_CreateGeometry         (IntPtr system, int maxpolygons, int maxvertices, out IntPtr geometry);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetGeometrySettings    (IntPtr system, float maxworldsize);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetGeometrySettings    (IntPtr system, out float maxworldsize);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_LoadGeometry           (IntPtr system, IntPtr data, int datasize, out IntPtr geometry);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetGeometryOcclusion   (IntPtr system, ref VECTOR listener, ref VECTOR source, out float direct, out float reverb);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetNetworkProxy        (IntPtr system, byte[] proxy);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetNetworkProxy        (IntPtr system, IntPtr proxy, int proxylen);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetNetworkTimeout      (IntPtr system, int timeout);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetNetworkTimeout      (IntPtr system, out int timeout);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_SetUserData            (IntPtr system, IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_System_GetUserData            (IntPtr system, out IntPtr userdata);
        #endregion

        #region wrapperinternal

        public System(IntPtr raw)
            : base(raw)
        {
        }

        #endregion
    }


    /*
        'Sound' API.
    */
    public class Sound : HandleBase
    {
        public RESULT release                 ()
        {
            RESULT result = FMOD_Sound_Release(rawPtr);
            if (result == RESULT.OK)
            {
                rawPtr = IntPtr.Zero;
            }
            return result;
        }
        public RESULT getSystemObject         (out System system)
        {
            system = null;

            IntPtr systemraw;
            RESULT result = FMOD_Sound_GetSystemObject(rawPtr, out systemraw);
            system = new System(systemraw);

            return result;
        }

        // Standard sound manipulation functions.
        public RESULT @lock                   (uint offset, uint length, out IntPtr ptr1, out IntPtr ptr2, out uint len1, out uint len2)
        {
            return FMOD_Sound_Lock(rawPtr, offset, length, out ptr1, out ptr2, out len1, out len2);
        }
        public RESULT unlock                  (IntPtr ptr1,  IntPtr ptr2, uint len1, uint len2)
        {
            return FMOD_Sound_Unlock(rawPtr, ptr1, ptr2, len1, len2);
        }
        public RESULT setDefaults             (float frequency, int priority)
        {
            return FMOD_Sound_SetDefaults(rawPtr, frequency, priority);
        }
        public RESULT getDefaults             (out float frequency, out int priority)
        {
            return FMOD_Sound_GetDefaults(rawPtr, out frequency, out priority);
        }
        public RESULT set3DMinMaxDistance     (float min, float max)
        {
            return FMOD_Sound_Set3DMinMaxDistance(rawPtr, min, max);
        }
        public RESULT get3DMinMaxDistance     (out float min, out float max)
        {
            return FMOD_Sound_Get3DMinMaxDistance(rawPtr, out min, out max);
        }
        public RESULT set3DConeSettings       (float insideconeangle, float outsideconeangle, float outsidevolume)
        {
            return FMOD_Sound_Set3DConeSettings(rawPtr, insideconeangle, outsideconeangle, outsidevolume);
        }
        public RESULT get3DConeSettings       (out float insideconeangle, out float outsideconeangle, out float outsidevolume)
        {
            return FMOD_Sound_Get3DConeSettings(rawPtr, out insideconeangle, out outsideconeangle, out outsidevolume);
        }
        public RESULT set3DCustomRolloff      (ref VECTOR points, int numpoints)
        {
            return FMOD_Sound_Set3DCustomRolloff(rawPtr, ref points, numpoints);
        }
        public RESULT get3DCustomRolloff      (out IntPtr points, out int numpoints)
        {
            return FMOD_Sound_Get3DCustomRolloff(rawPtr, out points, out numpoints);
        }
        public RESULT getSubSound             (int index, out Sound subsound)
        {
            subsound = null;

            IntPtr subsoundraw;
            RESULT result = FMOD_Sound_GetSubSound(rawPtr, index, out subsoundraw);
            subsound = new Sound(subsoundraw);

            return result;
        }
        public RESULT getSubSoundParent(out Sound parentsound)
        {
            parentsound = null;

            IntPtr subsoundraw;
            RESULT result = FMOD_Sound_GetSubSoundParent(rawPtr, out subsoundraw);
            parentsound = new Sound(subsoundraw);

            return result;
        }
        public RESULT getName                 (StringBuilder name, int namelen)
        {
            IntPtr stringMem = Marshal.AllocHGlobal(name.Capacity);

            RESULT result = FMOD_Sound_GetName(rawPtr, stringMem, namelen);

            StringMarshalHelper.NativeToBuilder(name, stringMem);
            Marshal.FreeHGlobal(stringMem);

            return result;
        }
        public RESULT getLength               (out uint length, TIMEUNIT lengthtype)
        {
            return FMOD_Sound_GetLength(rawPtr, out length, lengthtype);
        }
        public RESULT getFormat               (out SOUND_TYPE type, out SOUND_FORMAT format, out int channels, out int bits)
        {
            return FMOD_Sound_GetFormat(rawPtr, out type, out format, out channels, out bits);
        }
        public RESULT getNumSubSounds         (out int numsubsounds)
        {
            return FMOD_Sound_GetNumSubSounds(rawPtr, out numsubsounds);
        }
        public RESULT getNumTags              (out int numtags, out int numtagsupdated)
        {
            return FMOD_Sound_GetNumTags(rawPtr, out numtags, out numtagsupdated);
        }
        public RESULT getTag                  (string name, int index, out TAG tag)
        {
            return FMOD_Sound_GetTag(rawPtr, name, index, out tag);
        }
        public RESULT getOpenState            (out OPENSTATE openstate, out uint percentbuffered, out bool starving, out bool diskbusy)
        {
            return FMOD_Sound_GetOpenState(rawPtr, out openstate, out percentbuffered, out starving, out diskbusy);
        }
        public RESULT readData                (IntPtr buffer, uint lenbytes, out uint read)
        {
            return FMOD_Sound_ReadData(rawPtr, buffer, lenbytes, out read);
        }
        public RESULT seekData                (uint pcm)
        {
            return FMOD_Sound_SeekData(rawPtr, pcm);
        }
        public RESULT setSoundGroup           (SoundGroup soundgroup)
        {
            return FMOD_Sound_SetSoundGroup(rawPtr, soundgroup.getRaw());
        }
        public RESULT getSoundGroup           (out SoundGroup soundgroup)
        {
            soundgroup = null;

            IntPtr soundgroupraw;
            RESULT result = FMOD_Sound_GetSoundGroup(rawPtr, out soundgroupraw);
            soundgroup = new SoundGroup(soundgroupraw);

            return result;
        }

        // Synchronization point API.  These points can come from markers embedded in wav files, and can also generate channel callbacks.
        public RESULT getNumSyncPoints        (out int numsyncpoints)
        {
            return FMOD_Sound_GetNumSyncPoints(rawPtr, out numsyncpoints);
        }
        public RESULT getSyncPoint            (int index, out IntPtr point)
        {
            return FMOD_Sound_GetSyncPoint(rawPtr, index, out point);
        }
        public RESULT getSyncPointInfo        (IntPtr point, StringBuilder name, int namelen, out uint offset, TIMEUNIT offsettype)
        {
            IntPtr stringMem = Marshal.AllocHGlobal(name.Capacity);

            RESULT result = FMOD_Sound_GetSyncPointInfo(rawPtr, point, stringMem, namelen, out offset, offsettype);

            StringMarshalHelper.NativeToBuilder(name, stringMem);
            Marshal.FreeHGlobal(stringMem);

            return result;
        }
        public RESULT addSyncPoint            (uint offset, TIMEUNIT offsettype, string name, out IntPtr point)
        {
            return FMOD_Sound_AddSyncPoint(rawPtr, offset, offsettype, name, out point);
        }
        public RESULT deleteSyncPoint         (IntPtr point)
        {
            return FMOD_Sound_DeleteSyncPoint(rawPtr, point);
        }

        // Functions also in Channel class but here they are the 'default' to save having to change it in Channel all the time.
        public RESULT setMode                 (MODE mode)
        {
            return FMOD_Sound_SetMode(rawPtr, mode);
        }
        public RESULT getMode                 (out MODE mode)
        {
            return FMOD_Sound_GetMode(rawPtr, out mode);
        }
        public RESULT setLoopCount            (int loopcount)
        {
            return FMOD_Sound_SetLoopCount(rawPtr, loopcount);
        }
        public RESULT getLoopCount            (out int loopcount)
        {
            return FMOD_Sound_GetLoopCount(rawPtr, out loopcount);
        }
        public RESULT setLoopPoints           (uint loopstart, TIMEUNIT loopstarttype, uint loopend, TIMEUNIT loopendtype)
        {
            return FMOD_Sound_SetLoopPoints(rawPtr, loopstart, loopstarttype, loopend, loopendtype);
        }
        public RESULT getLoopPoints           (out uint loopstart, TIMEUNIT loopstarttype, out uint loopend, TIMEUNIT loopendtype)
        {
            return FMOD_Sound_GetLoopPoints(rawPtr, out loopstart, loopstarttype, out loopend, loopendtype);
        }

        // For MOD/S3M/XM/IT/MID sequenced formats only.
        public RESULT getMusicNumChannels     (out int numchannels)
        {
            return FMOD_Sound_GetMusicNumChannels(rawPtr, out numchannels);
        }
        public RESULT setMusicChannelVolume   (int channel, float volume)
        {
            return FMOD_Sound_SetMusicChannelVolume(rawPtr, channel, volume);
        }
        public RESULT getMusicChannelVolume   (int channel, out float volume)
        {
            return FMOD_Sound_GetMusicChannelVolume(rawPtr, channel, out volume);
        }
        public RESULT setMusicSpeed(float speed)
        {
            return FMOD_Sound_SetMusicSpeed(rawPtr, speed);
        }
        public RESULT getMusicSpeed(out float speed)
        {
            return FMOD_Sound_GetMusicSpeed(rawPtr, out speed);
        }

        // Userdata set/get.
        public RESULT setUserData             (IntPtr userdata)
        {
            return FMOD_Sound_SetUserData(rawPtr, userdata);
        }
        public RESULT getUserData             (out IntPtr userdata)
        {
            return FMOD_Sound_GetUserData(rawPtr, out userdata);
        }


        #region importfunctions
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_Release                 (IntPtr sound);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetSystemObject         (IntPtr sound, out IntPtr system);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_Lock                   (IntPtr sound, uint offset, uint length, out IntPtr ptr1, out IntPtr ptr2, out uint len1, out uint len2);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_Unlock                  (IntPtr sound, IntPtr ptr1,  IntPtr ptr2, uint len1, uint len2);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetDefaults             (IntPtr sound, float frequency, int priority);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetDefaults             (IntPtr sound, out float frequency, out int priority);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_Set3DMinMaxDistance     (IntPtr sound, float min, float max);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_Get3DMinMaxDistance     (IntPtr sound, out float min, out float max);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_Set3DConeSettings       (IntPtr sound, float insideconeangle, float outsideconeangle, float outsidevolume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_Get3DConeSettings       (IntPtr sound, out float insideconeangle, out float outsideconeangle, out float outsidevolume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_Set3DCustomRolloff      (IntPtr sound, ref VECTOR points, int numpoints);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_Get3DCustomRolloff      (IntPtr sound, out IntPtr points, out int numpoints);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetSubSound             (IntPtr sound, int index, out IntPtr subsound);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetSubSoundParent       (IntPtr sound, out IntPtr parentsound);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetName                 (IntPtr sound, IntPtr name, int namelen);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetLength               (IntPtr sound, out uint length, TIMEUNIT lengthtype);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetFormat               (IntPtr sound, out SOUND_TYPE type, out SOUND_FORMAT format, out int channels, out int bits);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetNumSubSounds         (IntPtr sound, out int numsubsounds);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetNumTags              (IntPtr sound, out int numtags, out int numtagsupdated);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetTag                  (IntPtr sound, string name, int index, out TAG tag);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetOpenState            (IntPtr sound, out OPENSTATE openstate, out uint percentbuffered, out bool starving, out bool diskbusy);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_ReadData                (IntPtr sound, IntPtr buffer, uint lenbytes, out uint read);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_SeekData                (IntPtr sound, uint pcm);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetSoundGroup           (IntPtr sound, IntPtr soundgroup);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetSoundGroup           (IntPtr sound, out IntPtr soundgroup);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetNumSyncPoints        (IntPtr sound, out int numsyncpoints);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetSyncPoint            (IntPtr sound, int index, out IntPtr point);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetSyncPointInfo        (IntPtr sound, IntPtr point, IntPtr name, int namelen, out uint offset, TIMEUNIT offsettype);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_AddSyncPoint            (IntPtr sound, uint offset, TIMEUNIT offsettype, string name, out IntPtr point);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_DeleteSyncPoint         (IntPtr sound, IntPtr point);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetMode                 (IntPtr sound, MODE mode);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetMode                 (IntPtr sound, out MODE mode);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetLoopCount            (IntPtr sound, int loopcount);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetLoopCount            (IntPtr sound, out int loopcount);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetLoopPoints           (IntPtr sound, uint loopstart, TIMEUNIT loopstarttype, uint loopend, TIMEUNIT loopendtype);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetLoopPoints           (IntPtr sound, out uint loopstart, TIMEUNIT loopstarttype, out uint loopend, TIMEUNIT loopendtype);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetMusicNumChannels     (IntPtr sound, out int numchannels);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetMusicChannelVolume   (IntPtr sound, int channel, float volume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetMusicChannelVolume   (IntPtr sound, int channel, out float volume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetMusicSpeed           (IntPtr sound, float speed);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetMusicSpeed           (IntPtr sound, out float speed);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_SetUserData             (IntPtr sound, IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Sound_GetUserData             (IntPtr sound, out IntPtr userdata);
        #endregion

        #region wrapperinternal

        public Sound(IntPtr raw)
            : base(raw)
        {
        }

        #endregion
    }


    /*
        'ChannelControl' API
    */
    public class ChannelControl : HandleBase
    {
        public RESULT getSystemObject(out System system)
        {
            system = null;

            IntPtr systemraw;
            RESULT result = FMOD_ChannelGroup_GetSystemObject(rawPtr, out systemraw);
            system = new System(systemraw);

            return result;
        }

        // General control functionality for Channels and ChannelGroups.
        public RESULT stop()
        {
            return FMOD_ChannelGroup_Stop(rawPtr);
        }
        public RESULT setPaused(bool paused)
        {
            return FMOD_ChannelGroup_SetPaused(rawPtr, paused);
        }
        public RESULT getPaused(out bool paused)
        {
            return FMOD_ChannelGroup_GetPaused(rawPtr, out paused);
        }
        public RESULT setVolume(float volume)
        {
            return FMOD_ChannelGroup_SetVolume(rawPtr, volume);
        }
        public RESULT getVolume(out float volume)
        {
            return FMOD_ChannelGroup_GetVolume(rawPtr, out volume);
        }
        public RESULT setVolumeRamp(bool ramp)
        {
            return FMOD_ChannelGroup_SetVolumeRamp(rawPtr, ramp);
        }
        public RESULT getVolumeRamp(out bool ramp)
        {
            return FMOD_ChannelGroup_GetVolumeRamp(rawPtr, out ramp);
        }
        public RESULT getAudibility(out float audibility)
        {
            return FMOD_ChannelGroup_GetAudibility(rawPtr, out audibility);
        }
        public RESULT setPitch(float pitch)
        {
            return FMOD_ChannelGroup_SetPitch(rawPtr, pitch);
        }
        public RESULT getPitch(out float pitch)
        {
            return FMOD_ChannelGroup_GetPitch(rawPtr, out pitch);
        }
        public RESULT setMute(bool mute)
        {
            return FMOD_ChannelGroup_SetMute(rawPtr, mute);
        }
        public RESULT getMute(out bool mute)
        {
            return FMOD_ChannelGroup_GetMute(rawPtr, out mute);
        }
        public RESULT setReverbProperties(int instance, float wet)
        {
            return FMOD_ChannelGroup_SetReverbProperties(rawPtr, instance, wet);
        }
        public RESULT getReverbProperties(int instance, out float wet)
        {
            return FMOD_ChannelGroup_GetReverbProperties(rawPtr, instance, out wet);
        }
        public RESULT setLowPassGain(float gain)
        {
            return FMOD_ChannelGroup_SetLowPassGain(rawPtr, gain);
        }
        public RESULT getLowPassGain(out float gain)
        {
            return FMOD_ChannelGroup_GetLowPassGain(rawPtr, out gain);
        }
        public RESULT setMode(MODE mode)
        {
            return FMOD_ChannelGroup_SetMode(rawPtr, mode);
        }
        public RESULT getMode(out MODE mode)
        {
            return FMOD_ChannelGroup_GetMode(rawPtr, out mode);
        }
        public RESULT setCallback(CHANNEL_CALLBACK callback)
        {
            return FMOD_ChannelGroup_SetCallback(rawPtr, callback);
        }
        public RESULT isPlaying(out bool isplaying)
        {
            return FMOD_ChannelGroup_IsPlaying(rawPtr, out isplaying);
        }

        // Panning and level adjustment.
        public RESULT setPan(float pan)
        {
            return FMOD_ChannelGroup_SetPan(rawPtr, pan);
        }
        public RESULT setMixLevelsOutput(float frontleft, float frontright, float center, float lfe, float surroundleft, float surroundright, float backleft, float backright)
        {
            return FMOD_ChannelGroup_SetMixLevelsOutput(rawPtr, frontleft, frontright, center, lfe,
                surroundleft, surroundright, backleft, backright);
        }
        public RESULT setMixLevelsInput(float[] levels, int numlevels)
        {
            return FMOD_ChannelGroup_SetMixLevelsInput(rawPtr, levels, numlevels);
        }
        public RESULT setMixMatrix(float[] matrix, int outchannels, int inchannels, int inchannel_hop)
        {
            return FMOD_ChannelGroup_SetMixMatrix(rawPtr, matrix, outchannels, inchannels, inchannel_hop);
        }
        public RESULT getMixMatrix(float[] matrix, out int outchannels, out int inchannels, int inchannel_hop)
        {
            return FMOD_ChannelGroup_GetMixMatrix(rawPtr, matrix, out outchannels, out inchannels, inchannel_hop);
        }

        // Clock based functionality.
        public RESULT getDSPClock(out ulong dspclock, out ulong parentclock)
        {
            return FMOD_ChannelGroup_GetDSPClock(rawPtr, out dspclock, out parentclock);
        }
        public RESULT setDelay(ulong dspclock_start, ulong dspclock_end, bool stopchannels)
        {
            return FMOD_ChannelGroup_SetDelay(rawPtr, dspclock_start, dspclock_end, stopchannels);
        }
        public RESULT getDelay(out ulong dspclock_start, out ulong dspclock_end, out bool stopchannels)
        {
            return FMOD_ChannelGroup_GetDelay(rawPtr, out dspclock_start, out dspclock_end, out stopchannels);
        }
        public RESULT addFadePoint(ulong dspclock, float volume)
        {
            return FMOD_ChannelGroup_AddFadePoint(rawPtr, dspclock, volume);
        }
        public RESULT setFadePointRamp(ulong dspclock, float volume)
        {
            return FMOD_ChannelGroup_SetFadePointRamp(rawPtr, dspclock, volume);
        }
        public RESULT removeFadePoints(ulong dspclock_start, ulong dspclock_end)
        {
            return FMOD_ChannelGroup_RemoveFadePoints(rawPtr, dspclock_start, dspclock_end);
        }
        public RESULT getFadePoints(ref uint numpoints, ulong[] point_dspclock, float[] point_volume)
        {
            return FMOD_ChannelGroup_GetFadePoints(rawPtr, ref numpoints, point_dspclock, point_volume);
        }

        // DSP effects.
        public RESULT getDSP(int index, out DSP dsp)
        {
            dsp = null;

            IntPtr dspraw;
            RESULT result = FMOD_ChannelGroup_GetDSP(rawPtr, index, out dspraw);
            dsp = new DSP(dspraw);

            return result;
        }
        public RESULT addDSP(int index, DSP dsp)
        {
            return FMOD_ChannelGroup_AddDSP(rawPtr, index, dsp.getRaw());
        }
        public RESULT removeDSP(DSP dsp)
        {
            return FMOD_ChannelGroup_RemoveDSP(rawPtr, dsp.getRaw());
        }
        public RESULT getNumDSPs(out int numdsps)
        {
            return FMOD_ChannelGroup_GetNumDSPs(rawPtr, out numdsps);
        }
        public RESULT setDSPIndex(DSP dsp, int index)
        {
            return FMOD_ChannelGroup_SetDSPIndex(rawPtr, dsp.getRaw(), index);
        }
        public RESULT getDSPIndex(DSP dsp, out int index)
        {
            return FMOD_ChannelGroup_GetDSPIndex(rawPtr, dsp.getRaw(), out index);
        }
        public RESULT overridePanDSP(DSP pan)
        {
            return FMOD_ChannelGroup_OverridePanDSP(rawPtr, pan.getRaw());
        }

        // 3D functionality.
        public RESULT set3DAttributes(ref VECTOR pos, ref VECTOR vel, ref VECTOR alt_pan_pos)
        {
            return FMOD_ChannelGroup_Set3DAttributes(rawPtr, ref pos, ref vel, ref alt_pan_pos);
        }
        public RESULT get3DAttributes(out VECTOR pos, out VECTOR vel, out VECTOR alt_pan_pos)
        {
            return FMOD_ChannelGroup_Get3DAttributes(rawPtr, out pos, out vel, out alt_pan_pos);
        }
        public RESULT set3DMinMaxDistance(float mindistance, float maxdistance)
        {
            return FMOD_ChannelGroup_Set3DMinMaxDistance(rawPtr, mindistance, maxdistance);
        }
        public RESULT get3DMinMaxDistance(out float mindistance, out float maxdistance)
        {
            return FMOD_ChannelGroup_Get3DMinMaxDistance(rawPtr, out mindistance, out maxdistance);
        }
        public RESULT set3DConeSettings(float insideconeangle, float outsideconeangle, float outsidevolume)
        {
            return FMOD_ChannelGroup_Set3DConeSettings(rawPtr, insideconeangle, outsideconeangle, outsidevolume);
        }
        public RESULT get3DConeSettings(out float insideconeangle, out float outsideconeangle, out float outsidevolume)
        {
            return FMOD_ChannelGroup_Get3DConeSettings(rawPtr, out insideconeangle, out outsideconeangle, out outsidevolume);
        }
        public RESULT set3DConeOrientation(ref VECTOR orientation)
        {
            return FMOD_ChannelGroup_Set3DConeOrientation(rawPtr, ref orientation);
        }
        public RESULT get3DConeOrientation(out VECTOR orientation)
        {
            return FMOD_ChannelGroup_Get3DConeOrientation(rawPtr, out orientation);
        }
        public RESULT set3DCustomRolloff(ref VECTOR points, int numpoints)
        {
            return FMOD_ChannelGroup_Set3DCustomRolloff(rawPtr, ref points, numpoints);
        }
        public RESULT get3DCustomRolloff(out IntPtr points, out int numpoints)
        {
            return FMOD_ChannelGroup_Get3DCustomRolloff(rawPtr, out points, out numpoints);
        }
        public RESULT set3DOcclusion(float directocclusion, float reverbocclusion)
        {
            return FMOD_ChannelGroup_Set3DOcclusion(rawPtr, directocclusion, reverbocclusion);
        }
        public RESULT get3DOcclusion(out float directocclusion, out float reverbocclusion)
        {
            return FMOD_ChannelGroup_Get3DOcclusion(rawPtr, out directocclusion, out reverbocclusion);
        }
        public RESULT set3DSpread(float angle)
        {
            return FMOD_ChannelGroup_Set3DSpread(rawPtr, angle);
        }
        public RESULT get3DSpread(out float angle)
        {
            return FMOD_ChannelGroup_Get3DSpread(rawPtr, out angle);
        }
        public RESULT set3DLevel(float level)
        {
            return FMOD_ChannelGroup_Set3DLevel(rawPtr, level);
        }
        public RESULT get3DLevel(out float level)
        {
            return FMOD_ChannelGroup_Get3DLevel(rawPtr, out level);
        }
        public RESULT set3DDopplerLevel(float level)
        {
            return FMOD_ChannelGroup_Set3DDopplerLevel(rawPtr, level);
        }
        public RESULT get3DDopplerLevel(out float level)
        {
            return FMOD_ChannelGroup_Get3DDopplerLevel(rawPtr, out level);
        }
        public RESULT set3DDistanceFilter(bool custom, float customLevel, float centerFreq)
        {
            return FMOD_ChannelGroup_Set3DDistanceFilter(rawPtr, custom, customLevel, centerFreq);
        }
        public RESULT get3DDistanceFilter(out bool custom, out float customLevel, out float centerFreq)
        {
            return FMOD_ChannelGroup_Get3DDistanceFilter(rawPtr, out custom, out customLevel, out centerFreq);
        }

        // Userdata set/get.
        public RESULT setUserData(IntPtr userdata)
        {
            return FMOD_ChannelGroup_SetUserData(rawPtr, userdata);
        }
        public RESULT getUserData(out IntPtr userdata)
        {
            return FMOD_ChannelGroup_GetUserData(rawPtr, out userdata);
        }

        #region importfunctions

        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Stop(IntPtr channelgroup);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetPaused(IntPtr channelgroup, bool paused);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetPaused(IntPtr channelgroup, out bool paused);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetVolume(IntPtr channelgroup, out float volume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetVolumeRamp(IntPtr channelgroup, bool ramp);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetVolumeRamp(IntPtr channelgroup, out bool ramp);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetAudibility(IntPtr channelgroup, out float audibility);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetPitch(IntPtr channelgroup, float pitch);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetPitch(IntPtr channelgroup, out float pitch);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetMute(IntPtr channelgroup, bool mute);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetMute(IntPtr channelgroup, out bool mute);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetReverbProperties(IntPtr channelgroup, int instance, float wet);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetReverbProperties(IntPtr channelgroup, int instance, out float wet);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetLowPassGain(IntPtr channelgroup, float gain);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetLowPassGain(IntPtr channelgroup, out float gain);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetMode(IntPtr channelgroup, MODE mode);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetMode(IntPtr channelgroup, out MODE mode);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetCallback(IntPtr channelgroup, CHANNEL_CALLBACK callback);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_IsPlaying(IntPtr channelgroup, out bool isplaying);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetPan(IntPtr channelgroup, float pan);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetMixLevelsOutput(IntPtr channelgroup, float frontleft, float frontright, float center, float lfe, float surroundleft, float surroundright, float backleft, float backright);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetMixLevelsInput(IntPtr channelgroup, float[] levels, int numlevels);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetMixMatrix(IntPtr channelgroup, float[] matrix, int outchannels, int inchannels, int inchannel_hop);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetMixMatrix(IntPtr channelgroup, float[] matrix, out int outchannels, out int inchannels, int inchannel_hop);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetDSPClock(IntPtr channelgroup, out ulong dspclock, out ulong parentclock);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetDelay(IntPtr channelgroup, ulong dspclock_start, ulong dspclock_end, bool stopchannels);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetDelay(IntPtr channelgroup, out ulong dspclock_start, out ulong dspclock_end, out bool stopchannels);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_AddFadePoint(IntPtr channelgroup, ulong dspclock, float volume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetFadePointRamp(IntPtr channelgroup, ulong dspclock, float volume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_RemoveFadePoints(IntPtr channelgroup, ulong dspclock_start, ulong dspclock_end);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetFadePoints(IntPtr channelgroup, ref uint numpoints, ulong[] point_dspclock, float[] point_volume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Set3DAttributes(IntPtr channelgroup, ref VECTOR pos, ref VECTOR vel, ref VECTOR alt_pan_pos);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Get3DAttributes(IntPtr channelgroup, out VECTOR pos, out VECTOR vel, out VECTOR alt_pan_pos);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Set3DMinMaxDistance(IntPtr channelgroup, float mindistance, float maxdistance);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Get3DMinMaxDistance(IntPtr channelgroup, out float mindistance, out float maxdistance);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Set3DConeSettings(IntPtr channelgroup, float insideconeangle, float outsideconeangle, float outsidevolume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Get3DConeSettings(IntPtr channelgroup, out float insideconeangle, out float outsideconeangle, out float outsidevolume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Set3DConeOrientation(IntPtr channelgroup, ref VECTOR orientation);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Get3DConeOrientation(IntPtr channelgroup, out VECTOR orientation);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Set3DCustomRolloff(IntPtr channelgroup, ref VECTOR points, int numpoints);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Get3DCustomRolloff(IntPtr channelgroup, out IntPtr points, out int numpoints);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Set3DOcclusion(IntPtr channelgroup, float directocclusion, float reverbocclusion);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Get3DOcclusion(IntPtr channelgroup, out float directocclusion, out float reverbocclusion);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Set3DSpread(IntPtr channelgroup, float angle);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Get3DSpread(IntPtr channelgroup, out float angle);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Set3DLevel(IntPtr channelgroup, float level);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Get3DLevel(IntPtr channelgroup, out float level);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Set3DDopplerLevel(IntPtr channelgroup, float level);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Get3DDopplerLevel(IntPtr channelgroup, out float level);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Set3DDistanceFilter(IntPtr channelgroup, bool custom, float customLevel, float centerFreq);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Get3DDistanceFilter(IntPtr channelgroup, out bool custom, out float customLevel, out float centerFreq);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetSystemObject(IntPtr channelgroup, out IntPtr system);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetVolume(IntPtr channelgroup, float volume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetDSP(IntPtr channelgroup, int index, out IntPtr dsp);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_AddDSP(IntPtr channelgroup, int index, IntPtr dsp);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_RemoveDSP(IntPtr channelgroup, IntPtr dsp);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetNumDSPs(IntPtr channelgroup, out int numdsps);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetDSPIndex(IntPtr channelgroup, IntPtr dsp, int index);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetDSPIndex(IntPtr channelgroup, IntPtr dsp, out int index);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_OverridePanDSP(IntPtr channelgroup, IntPtr pan);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_SetUserData(IntPtr channelgroup, IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetUserData(IntPtr channelgroup, out IntPtr userdata);

        #endregion

        #region wrapperinternal

        protected ChannelControl(IntPtr raw)
            : base(raw)
        {
        }

        #endregion
    }


    /*
        'Channel' API
    */
    public class Channel : ChannelControl
    {
        // Channel specific control functionality.
        public RESULT setFrequency          (float frequency)
        {
            return FMOD_Channel_SetFrequency(getRaw(), frequency);
        }
        public RESULT getFrequency          (out float frequency)
        {
            return FMOD_Channel_GetFrequency(getRaw(), out frequency);
        }
        public RESULT setPriority           (int priority)
        {
            return FMOD_Channel_SetPriority(getRaw(), priority);
        }
        public RESULT getPriority           (out int priority)
        {
            return FMOD_Channel_GetPriority(getRaw(), out priority);
        }
        public RESULT setPosition           (uint position, TIMEUNIT postype)
        {
            return FMOD_Channel_SetPosition(getRaw(), position, postype);
        }
        public RESULT getPosition           (out uint position, TIMEUNIT postype)
        {
            return FMOD_Channel_GetPosition(getRaw(), out position, postype);
        }
        public RESULT setChannelGroup       (ChannelGroup channelgroup)
        {
            return FMOD_Channel_SetChannelGroup(getRaw(), channelgroup.getRaw());
        }
        public RESULT getChannelGroup       (out ChannelGroup channelgroup)
        {
            channelgroup = null;

            IntPtr channelgroupraw;
            RESULT result = FMOD_Channel_GetChannelGroup(getRaw(), out channelgroupraw);
            channelgroup = new ChannelGroup(channelgroupraw);

            return result;
        }
        public RESULT setLoopCount(int loopcount)
        {
            return FMOD_Channel_SetLoopCount(getRaw(), loopcount);
        }
        public RESULT getLoopCount(out int loopcount)
        {
            return FMOD_Channel_GetLoopCount(getRaw(), out loopcount);
        }
        public RESULT setLoopPoints(uint loopstart, TIMEUNIT loopstarttype, uint loopend, TIMEUNIT loopendtype)
        {
            return FMOD_Channel_SetLoopPoints(getRaw(), loopstart, loopstarttype, loopend, loopendtype);
        }
        public RESULT getLoopPoints(out uint loopstart, TIMEUNIT loopstarttype, out uint loopend, TIMEUNIT loopendtype)
        {
            return FMOD_Channel_GetLoopPoints(getRaw(), out loopstart, loopstarttype, out loopend, loopendtype);
        }

        // Information only functions.
        public RESULT isVirtual             (out bool isvirtual)
        {
            return FMOD_Channel_IsVirtual(getRaw(), out isvirtual);
        }
        public RESULT getCurrentSound       (out Sound sound)
        {
            sound = null;

            IntPtr soundraw;
            RESULT result = FMOD_Channel_GetCurrentSound(getRaw(), out soundraw);
            sound = new Sound(soundraw);

            return result;
        }
        public RESULT getIndex              (out int index)
        {
            return FMOD_Channel_GetIndex(getRaw(), out index);
        }

        #region importfunctions

        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetFrequency          (IntPtr channel, float frequency);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetFrequency          (IntPtr channel, out float frequency);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetPriority           (IntPtr channel, int priority);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetPriority           (IntPtr channel, out int priority);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetChannelGroup       (IntPtr channel, IntPtr channelgroup);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetChannelGroup       (IntPtr channel, out IntPtr channelgroup);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_IsVirtual             (IntPtr channel, out bool isvirtual);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetCurrentSound       (IntPtr channel, out IntPtr sound);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetIndex              (IntPtr channel, out int index);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetPosition           (IntPtr channel, uint position, TIMEUNIT postype);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetPosition           (IntPtr channel, out uint position, TIMEUNIT postype);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetMode               (IntPtr channel, MODE mode);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetMode               (IntPtr channel, out MODE mode);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetLoopCount          (IntPtr channel, int loopcount);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetLoopCount          (IntPtr channel, out int loopcount);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetLoopPoints         (IntPtr channel, uint  loopstart, TIMEUNIT loopstarttype, uint  loopend, TIMEUNIT loopendtype);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetLoopPoints         (IntPtr channel, out uint loopstart, TIMEUNIT loopstarttype, out uint loopend, TIMEUNIT loopendtype);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_SetUserData           (IntPtr channel, IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Channel_GetUserData           (IntPtr channel, out IntPtr userdata);
        #endregion

        #region wrapperinternal

        public Channel(IntPtr raw)
            : base(raw)
        {
        }

        #endregion
    }


    /*
        'ChannelGroup' API
    */
    public class ChannelGroup : ChannelControl
    {
        public RESULT release                ()
        {
            RESULT result = FMOD_ChannelGroup_Release(getRaw());
            if (result == RESULT.OK)
            {
                rawPtr = IntPtr.Zero;
            }
            return result;
        }

        // Nested channel groups.
        public RESULT addGroup               (ChannelGroup group, bool propagatedspclock, out DSPConnection connection)
        {
			connection = null;
			
			IntPtr connectionRaw;
            RESULT result = FMOD_ChannelGroup_AddGroup(getRaw(), group.getRaw(), propagatedspclock, out connectionRaw);
			connection = new DSPConnection(connectionRaw);
			
			return result;
        }
        public RESULT getNumGroups           (out int numgroups)
        {
            return FMOD_ChannelGroup_GetNumGroups(getRaw(), out numgroups);
        }
        public RESULT getGroup               (int index, out ChannelGroup group)
        {
            group = null;

            IntPtr groupraw;
            RESULT result = FMOD_ChannelGroup_GetGroup(getRaw(), index, out groupraw);
            group = new ChannelGroup(groupraw);

            return result;
        }
        public RESULT getParentGroup         (out ChannelGroup group)
        {
            group = null;

            IntPtr groupraw;
            RESULT result = FMOD_ChannelGroup_GetParentGroup(getRaw(), out groupraw);
            group = new ChannelGroup(groupraw);

            return result;
        }

        // Information only functions.
        public RESULT getName                (StringBuilder name, int namelen)
        {
            IntPtr stringMem = Marshal.AllocHGlobal(name.Capacity);

            RESULT result = FMOD_ChannelGroup_GetName(getRaw(), stringMem, namelen);

            StringMarshalHelper.NativeToBuilder(name, stringMem);
            Marshal.FreeHGlobal(stringMem);

            return result;
        }
        public RESULT getNumChannels         (out int numchannels)
        {
            return FMOD_ChannelGroup_GetNumChannels(getRaw(), out numchannels);
        }
        public RESULT getChannel             (int index, out Channel channel)
        {
            channel = null;

            IntPtr channelraw;
            RESULT result = FMOD_ChannelGroup_GetChannel(getRaw(), index, out channelraw);
            channel = new Channel(channelraw);

            return result;
        }

        #region importfunctions
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_Release          (IntPtr channelgroup);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_AddGroup         (IntPtr channelgroup, IntPtr group, bool propagatedspclock, out IntPtr connection);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetNumGroups     (IntPtr channelgroup, out int numgroups);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetGroup         (IntPtr channelgroup, int index, out IntPtr group);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetParentGroup   (IntPtr channelgroup, out IntPtr group);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetName          (IntPtr channelgroup, IntPtr name, int namelen);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetNumChannels   (IntPtr channelgroup, out int numchannels);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_ChannelGroup_GetChannel       (IntPtr channelgroup, int index, out IntPtr channel);
        #endregion

        #region wrapperinternal

        public ChannelGroup(IntPtr raw)
            : base(raw)
        {
        }

        #endregion
    }


    /*
        'SoundGroup' API
    */
    public class SoundGroup : HandleBase
    {
        public RESULT release                ()
        {
            RESULT result = FMOD_SoundGroup_Release(getRaw());
            if (result == RESULT.OK)
            {
                rawPtr = IntPtr.Zero;
            }
            return result;
        }

        public RESULT getSystemObject        (out System system)
        {
            system = null;

            IntPtr systemraw;
            RESULT result = FMOD_SoundGroup_GetSystemObject(rawPtr, out systemraw);
            system = new System(systemraw);

            return result;
        }

        // SoundGroup control functions.
        public RESULT setMaxAudible          (int maxaudible)
        {
            return FMOD_SoundGroup_SetMaxAudible(rawPtr, maxaudible);
        }
        public RESULT getMaxAudible          (out int maxaudible)
        {
            return FMOD_SoundGroup_GetMaxAudible(rawPtr, out maxaudible);
        }
        public RESULT setMaxAudibleBehavior  (SOUNDGROUP_BEHAVIOR behavior)
        {
            return FMOD_SoundGroup_SetMaxAudibleBehavior(rawPtr, behavior);
        }
        public RESULT getMaxAudibleBehavior  (out SOUNDGROUP_BEHAVIOR behavior)
        {
            return FMOD_SoundGroup_GetMaxAudibleBehavior(rawPtr, out behavior);
        }
        public RESULT setMuteFadeSpeed       (float speed)
        {
            return FMOD_SoundGroup_SetMuteFadeSpeed(rawPtr, speed);
        }
        public RESULT getMuteFadeSpeed       (out float speed)
        {
            return FMOD_SoundGroup_GetMuteFadeSpeed(rawPtr, out speed);
        }
        public RESULT setVolume       (float volume)
        {
            return FMOD_SoundGroup_SetVolume(rawPtr, volume);
        }
        public RESULT getVolume       (out float volume)
        {
            return FMOD_SoundGroup_GetVolume(rawPtr, out volume);
        }
        public RESULT stop       ()
        {
            return FMOD_SoundGroup_Stop(rawPtr);
        }

        // Information only functions.
        public RESULT getName                (StringBuilder name, int namelen)
        {
            IntPtr stringMem = Marshal.AllocHGlobal(name.Capacity);

            RESULT result = FMOD_SoundGroup_GetName(rawPtr, stringMem, namelen);

            StringMarshalHelper.NativeToBuilder(name, stringMem);
            Marshal.FreeHGlobal(stringMem);

            return result;
        }
        public RESULT getNumSounds           (out int numsounds)
        {
            return FMOD_SoundGroup_GetNumSounds(rawPtr, out numsounds);
        }
        public RESULT getSound               (int index, out Sound sound)
        {
            sound = null;

            IntPtr soundraw;
            RESULT result = FMOD_SoundGroup_GetSound(rawPtr, index, out soundraw);
            sound = new Sound(soundraw);

            return result;
        }
        public RESULT getNumPlaying          (out int numplaying)
        {
            return FMOD_SoundGroup_GetNumPlaying(rawPtr, out numplaying);
        }

        // Userdata set/get.
        public RESULT setUserData            (IntPtr userdata)
        {
            return FMOD_SoundGroup_SetUserData(rawPtr, userdata);
        }
        public RESULT getUserData            (out IntPtr userdata)
        {
            return FMOD_SoundGroup_GetUserData(rawPtr, out userdata);
        }

        #region importfunctions
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_Release            (IntPtr soundgroup);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetSystemObject    (IntPtr soundgroup, out IntPtr system);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_SetMaxAudible      (IntPtr soundgroup, int maxaudible);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetMaxAudible      (IntPtr soundgroup, out int maxaudible);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_SetMaxAudibleBehavior(IntPtr soundgroup, SOUNDGROUP_BEHAVIOR behavior);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetMaxAudibleBehavior(IntPtr soundgroup, out SOUNDGROUP_BEHAVIOR behavior);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_SetMuteFadeSpeed   (IntPtr soundgroup, float speed);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetMuteFadeSpeed   (IntPtr soundgroup, out float speed);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_SetVolume          (IntPtr soundgroup, float volume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetVolume          (IntPtr soundgroup, out float volume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_Stop               (IntPtr soundgroup);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetName            (IntPtr soundgroup, IntPtr name, int namelen);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetNumSounds       (IntPtr soundgroup, out int numsounds);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetSound           (IntPtr soundgroup, int index, out IntPtr sound);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetNumPlaying      (IntPtr soundgroup, out int numplaying);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_SetUserData        (IntPtr soundgroup, IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_SoundGroup_GetUserData        (IntPtr soundgroup, out IntPtr userdata);
        #endregion

        #region wrapperinternal

        public SoundGroup(IntPtr raw)
            : base(raw)
        {
        }

        #endregion
    }


    /*
        'DSP' API
    */
    public class DSP : HandleBase
    {
        public RESULT release                   ()
        {
            RESULT result = FMOD_DSP_Release(getRaw());
            if (result == RESULT.OK)
            {
                rawPtr = IntPtr.Zero;
            }
            return result;
        }
        public RESULT getSystemObject           (out System system)
        {
            system = null;

            IntPtr systemraw;
            RESULT result = FMOD_DSP_GetSystemObject(rawPtr, out systemraw);
            system = new System(systemraw);

            return result;
        }

        // Connection / disconnection / input and output enumeration.
        public RESULT addInput(DSP target, out DSPConnection connection, DSPCONNECTION_TYPE type)
        {
            connection = null;

            IntPtr dspconnectionraw;
            RESULT result = FMOD_DSP_AddInput(rawPtr, target.getRaw(), out dspconnectionraw, type);
            connection = new DSPConnection(dspconnectionraw);

            return result;
        }
        public RESULT disconnectFrom            (DSP target, DSPConnection connection)
        {
            return FMOD_DSP_DisconnectFrom(rawPtr, target.getRaw(), connection.getRaw());
        }
        public RESULT disconnectAll             (bool inputs, bool outputs)
        {
            return FMOD_DSP_DisconnectAll(rawPtr, inputs, outputs);
        }
        public RESULT getNumInputs              (out int numinputs)
        {
            return FMOD_DSP_GetNumInputs(rawPtr, out numinputs);
        }
        public RESULT getNumOutputs             (out int numoutputs)
        {
            return FMOD_DSP_GetNumOutputs(rawPtr, out numoutputs);
        }
        public RESULT getInput                  (int index, out DSP input, out DSPConnection inputconnection)
        {
            input = null;
            inputconnection = null;

            IntPtr dspinputraw;
            IntPtr dspconnectionraw;
            RESULT result = FMOD_DSP_GetInput(rawPtr, index, out dspinputraw, out dspconnectionraw);
            input = new DSP(dspinputraw);
            inputconnection = new DSPConnection(dspconnectionraw);

            return result;
        }
        public RESULT getOutput                 (int index, out DSP output, out DSPConnection outputconnection)
        {
            output = null;
            outputconnection = null;

            IntPtr dspoutputraw;
            IntPtr dspconnectionraw;
            RESULT result = FMOD_DSP_GetOutput(rawPtr, index, out dspoutputraw, out dspconnectionraw);
            output = new DSP(dspoutputraw);
            outputconnection = new DSPConnection(dspconnectionraw);

            return result;
        }

        // DSP unit control.
        public RESULT setActive                 (bool active)
        {
            return FMOD_DSP_SetActive(rawPtr, active);
        }
        public RESULT getActive                 (out bool active)
        {
            return FMOD_DSP_GetActive(rawPtr, out active);
        }
        public RESULT setBypass(bool bypass)
        {
            return FMOD_DSP_SetBypass(rawPtr, bypass);
        }
        public RESULT getBypass(out bool bypass)
        {
            return FMOD_DSP_GetBypass(rawPtr, out bypass);
        }
        public RESULT setWetDryMix(float prewet, float postwet, float dry)
        {
            return FMOD_DSP_SetWetDryMix(rawPtr, prewet, postwet, dry);
        }
        public RESULT getWetDryMix(out float prewet, out float postwet, out float dry)
        {
            return FMOD_DSP_GetWetDryMix(rawPtr, out prewet, out postwet, out dry);
        }
        public RESULT setChannelFormat(CHANNELMASK channelmask, int numchannels, SPEAKERMODE source_speakermode)
        {
            return FMOD_DSP_SetChannelFormat(rawPtr, channelmask, numchannels, source_speakermode);
        }
        public RESULT getChannelFormat(out CHANNELMASK channelmask, out int numchannels, out SPEAKERMODE source_speakermode)
        {
            return FMOD_DSP_GetChannelFormat(rawPtr, out channelmask, out numchannels, out source_speakermode);
        }
        public RESULT getOutputChannelFormat(CHANNELMASK inmask, int inchannels, SPEAKERMODE inspeakermode, out CHANNELMASK outmask, out int outchannels, out SPEAKERMODE outspeakermode)
        {
            return FMOD_DSP_GetOutputChannelFormat(rawPtr, inmask, inchannels, inspeakermode, out outmask, out outchannels, out outspeakermode);
        }
        public RESULT reset                     ()
        {
            return FMOD_DSP_Reset(rawPtr);
        }

        // DSP parameter control.
        public RESULT setParameterFloat(int index, float value)
        {
            return FMOD_DSP_SetParameterFloat(rawPtr, index, value);
        }
        public RESULT setParameterInt(int index, int value)
        {
            return FMOD_DSP_SetParameterInt(rawPtr, index, value);
        }
        public RESULT setParameterBool(int index, bool value)
        {
            return FMOD_DSP_SetParameterBool(rawPtr, index, value);
        }
        public RESULT setParameterData(int index, byte[] data)
        {
            return FMOD_DSP_SetParameterData(rawPtr, index, Marshal.UnsafeAddrOfPinnedArrayElement(data, 0), (uint)data.Length);
        }
        public RESULT getParameterFloat(int index, out float value)
        {
            IntPtr valuestr = IntPtr.Zero;
            return FMOD_DSP_GetParameterFloat(rawPtr, index, out value, valuestr, 0);
        }
        public RESULT getParameterInt(int index, out int value)
        {
            IntPtr valuestr = IntPtr.Zero;
            return FMOD_DSP_GetParameterInt(rawPtr, index, out value, valuestr, 0);
        }
        public RESULT getParameterBool(int index, out bool value)
        {
            return FMOD_DSP_GetParameterBool(rawPtr, index, out value, IntPtr.Zero, 0);
        }
        public RESULT getParameterData(int index, out IntPtr data, out uint length)
        {
            return FMOD_DSP_GetParameterData(rawPtr, index, out data, out length, IntPtr.Zero, 0);
        }
        public RESULT getNumParameters          (out int numparams)
        {
            return FMOD_DSP_GetNumParameters(rawPtr, out numparams);
        }
        public RESULT getParameterInfo          (int index, out DSP_PARAMETER_DESC desc)
        {
            IntPtr descPtr;
            RESULT result = FMOD_DSP_GetParameterInfo(rawPtr, index, out descPtr);
            if (result == RESULT.OK)
            {
                desc = (DSP_PARAMETER_DESC)Marshal.PtrToStructure(descPtr, typeof(DSP_PARAMETER_DESC));
            }
            else
            {
                desc = new DSP_PARAMETER_DESC();
            }
            return result;
        }
        public RESULT getDataParameterIndex(int datatype, out int index)
        {
            return FMOD_DSP_GetDataParameterIndex     (rawPtr, datatype, out index);
        }
        public RESULT showConfigDialog          (IntPtr hwnd, bool show)
        {
            return FMOD_DSP_ShowConfigDialog          (rawPtr, hwnd, show);
        }

        //  DSP attributes.
        public RESULT getInfo                   (StringBuilder name, out uint version, out int channels, out int configwidth, out int configheight)
        {
            IntPtr nameMem = Marshal.AllocHGlobal(32);
            RESULT result = FMOD_DSP_GetInfo(rawPtr, nameMem, out version, out channels, out configwidth, out configheight);
            StringMarshalHelper.NativeToBuilder(name, nameMem);
            Marshal.FreeHGlobal(nameMem);
            return result;
        }
        public RESULT getType                   (out DSP_TYPE type)
        {
            return FMOD_DSP_GetType(rawPtr, out type);
        }
        public RESULT getIdle                   (out bool idle)
        {
            return FMOD_DSP_GetIdle(rawPtr, out idle);
        }

        // Userdata set/get.
        public RESULT setUserData               (IntPtr userdata)
        {
            return FMOD_DSP_SetUserData(rawPtr, userdata);
        }
        public RESULT getUserData               (out IntPtr userdata)
        {
            return FMOD_DSP_GetUserData(rawPtr, out userdata);
        }

        // Metering.
        public RESULT setMeteringEnabled(bool inputEnabled, bool outputEnabled)
        {
            return FMOD_DSP_SetMeteringEnabled(rawPtr, inputEnabled, outputEnabled);
        }
        public RESULT getMeteringEnabled(out bool inputEnabled, out bool outputEnabled)
        {
            return FMOD_DSP_GetMeteringEnabled(rawPtr, out inputEnabled, out outputEnabled);
        }

        public RESULT getMeteringInfo(DSP_METERING_INFO inputInfo, DSP_METERING_INFO outputInfo)
        {
            return FMOD_DSP_GetMeteringInfo(rawPtr, inputInfo, outputInfo);
        }

        #region importfunctions

        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_Release                   (IntPtr dsp);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetSystemObject           (IntPtr dsp, out IntPtr system);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_AddInput                  (IntPtr dsp, IntPtr target, out IntPtr connection, DSPCONNECTION_TYPE type);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_DisconnectFrom            (IntPtr dsp, IntPtr target, IntPtr connection);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_DisconnectAll             (IntPtr dsp, bool inputs, bool outputs);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetNumInputs              (IntPtr dsp, out int numinputs);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetNumOutputs             (IntPtr dsp, out int numoutputs);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetInput                  (IntPtr dsp, int index, out IntPtr input, out IntPtr inputconnection);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetOutput                 (IntPtr dsp, int index, out IntPtr output, out IntPtr outputconnection);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_SetActive                 (IntPtr dsp, bool active);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetActive                 (IntPtr dsp, out bool active);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_SetBypass                 (IntPtr dsp, bool bypass);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetBypass                 (IntPtr dsp, out bool bypass);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_SetWetDryMix              (IntPtr dsp, float prewet, float postwet, float dry);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetWetDryMix              (IntPtr dsp, out float prewet, out float postwet, out float dry);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_SetChannelFormat          (IntPtr dsp, CHANNELMASK channelmask, int numchannels, SPEAKERMODE source_speakermode);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetChannelFormat          (IntPtr dsp, out CHANNELMASK channelmask, out int numchannels, out SPEAKERMODE source_speakermode);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetOutputChannelFormat    (IntPtr dsp, CHANNELMASK inmask, int inchannels, SPEAKERMODE inspeakermode, out CHANNELMASK outmask, out int outchannels, out SPEAKERMODE outspeakermode);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_Reset                     (IntPtr dsp);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_SetParameterFloat         (IntPtr dsp, int index, float value);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_SetParameterInt           (IntPtr dsp, int index, int value);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_SetParameterBool          (IntPtr dsp, int index, bool value);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_SetParameterData          (IntPtr dsp, int index, IntPtr data, uint length);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetParameterFloat         (IntPtr dsp, int index, out float value, IntPtr valuestr, int valuestrlen);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetParameterInt           (IntPtr dsp, int index, out int value, IntPtr valuestr, int valuestrlen);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetParameterBool          (IntPtr dsp, int index, out bool value, IntPtr valuestr, int valuestrlen);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetParameterData          (IntPtr dsp, int index, out IntPtr data, out uint length, IntPtr valuestr, int valuestrlen);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetNumParameters          (IntPtr dsp, out int numparams);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetParameterInfo          (IntPtr dsp, int index, out IntPtr desc);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetDataParameterIndex     (IntPtr dsp, int datatype, out int index);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_ShowConfigDialog          (IntPtr dsp, IntPtr hwnd, bool show);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetInfo                   (IntPtr dsp, IntPtr name, out uint version, out int channels, out int configwidth, out int configheight);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetType                   (IntPtr dsp, out DSP_TYPE type);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetIdle                   (IntPtr dsp, out bool idle);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_SetUserData               (IntPtr dsp, IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSP_GetUserData               (IntPtr dsp, out IntPtr userdata);
        [DllImport(VERSION.dll)]
        public static extern RESULT FMOD_DSP_SetMeteringEnabled         (IntPtr dsp, bool inputEnabled, bool outputEnabled);
        [DllImport(VERSION.dll)]
        public static extern RESULT FMOD_DSP_GetMeteringEnabled         (IntPtr dsp, out bool inputEnabled, out bool outputEnabled);
        [DllImport(VERSION.dll)]
        public static extern RESULT FMOD_DSP_GetMeteringInfo            (IntPtr dsp, [Out] DSP_METERING_INFO inputInfo, [Out] DSP_METERING_INFO outputInfo);
        #endregion

        #region wrapperinternal

        public DSP(IntPtr raw)
            : base(raw)
        {
        }

        #endregion
    }


    /*
        'DSPConnection' API
    */
    public class DSPConnection : HandleBase
    {
        public RESULT getInput              (out DSP input)
        {
            input = null;

            IntPtr dspraw;
            RESULT result = FMOD_DSPConnection_GetInput(rawPtr, out dspraw);
            input = new DSP(dspraw);

            return result;
        }
        public RESULT getOutput             (out DSP output)
        {
            output = null;

            IntPtr dspraw;
            RESULT result = FMOD_DSPConnection_GetOutput(rawPtr, out dspraw);
            output = new DSP(dspraw);

            return result;
        }
        public RESULT setMix                (float volume)
        {
            return FMOD_DSPConnection_SetMix(rawPtr, volume);
        }
        public RESULT getMix                (out float volume)
        {
            return FMOD_DSPConnection_GetMix(rawPtr, out volume);
        }
        public RESULT setMixMatrix(float[] matrix, int outchannels, int inchannels, int inchannel_hop)
        {
            return FMOD_DSPConnection_SetMixMatrix(rawPtr, matrix, outchannels, inchannels, inchannel_hop);
        }
        public RESULT getMixMatrix(float[] matrix, out int outchannels, out int inchannels, int inchannel_hop)
        {
            return FMOD_DSPConnection_GetMixMatrix(rawPtr, matrix, out outchannels, out inchannels, inchannel_hop);
        }
        public RESULT getType(out DSPCONNECTION_TYPE type)
        {
            return FMOD_DSPConnection_GetType(rawPtr, out type);
        }

        // Userdata set/get.
        public RESULT setUserData(IntPtr userdata)
        {
            return FMOD_DSPConnection_SetUserData(rawPtr, userdata);
        }
        public RESULT getUserData(out IntPtr userdata)
        {
            return FMOD_DSPConnection_GetUserData(rawPtr, out userdata);
        }

        #region importfunctions
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_GetInput        (IntPtr dspconnection, out IntPtr input);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_GetOutput       (IntPtr dspconnection, out IntPtr output);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_SetMix          (IntPtr dspconnection, float volume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_GetMix          (IntPtr dspconnection, out float volume);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_SetMixMatrix    (IntPtr dspconnection, float[] matrix, int outchannels, int inchannels, int inchannel_hop);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_GetMixMatrix    (IntPtr dspconnection, float[] matrix, out int outchannels, out int inchannels, int inchannel_hop);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_GetType         (IntPtr dspconnection, out DSPCONNECTION_TYPE type);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_SetUserData     (IntPtr dspconnection, IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_DSPConnection_GetUserData     (IntPtr dspconnection, out IntPtr userdata);
        #endregion

        #region wrapperinternal

        public DSPConnection(IntPtr raw)
            : base(raw)
        {
        }

        #endregion
    }

    /*
        'Geometry' API
    */
    public class Geometry : HandleBase
    {
        public RESULT release               ()
        {
            RESULT result = FMOD_Geometry_Release(getRaw());
            if (result == RESULT.OK)
            {
                rawPtr = IntPtr.Zero;
            }
            return result;
        }

        // Polygon manipulation.
        public RESULT addPolygon            (float directocclusion, float reverbocclusion, bool doublesided, int numvertices, VECTOR[] vertices, out int polygonindex)
        {
            return FMOD_Geometry_AddPolygon(rawPtr, directocclusion, reverbocclusion, doublesided, numvertices, vertices, out polygonindex);
        }
        public RESULT getNumPolygons        (out int numpolygons)
        {
            return FMOD_Geometry_GetNumPolygons(rawPtr, out numpolygons);
        }
        public RESULT getMaxPolygons        (out int maxpolygons, out int maxvertices)
        {
            return FMOD_Geometry_GetMaxPolygons(rawPtr, out maxpolygons, out maxvertices);
        }
        public RESULT getPolygonNumVertices (int index, out int numvertices)
        {
            return FMOD_Geometry_GetPolygonNumVertices(rawPtr, index, out numvertices);
        }
        public RESULT setPolygonVertex      (int index, int vertexindex, ref VECTOR vertex)
        {
            return FMOD_Geometry_SetPolygonVertex(rawPtr, index, vertexindex, ref vertex);
        }
        public RESULT getPolygonVertex      (int index, int vertexindex, out VECTOR vertex)
        {
            return FMOD_Geometry_GetPolygonVertex(rawPtr, index, vertexindex, out vertex);
        }
        public RESULT setPolygonAttributes  (int index, float directocclusion, float reverbocclusion, bool doublesided)
        {
            return FMOD_Geometry_SetPolygonAttributes(rawPtr, index, directocclusion, reverbocclusion, doublesided);
        }
        public RESULT getPolygonAttributes  (int index, out float directocclusion, out float reverbocclusion, out bool doublesided)
        {
            return FMOD_Geometry_GetPolygonAttributes(rawPtr, index, out directocclusion, out reverbocclusion, out doublesided);
        }

        // Object manipulation.
        public RESULT setActive             (bool active)
        {
            return FMOD_Geometry_SetActive(rawPtr, active);
        }
        public RESULT getActive             (out bool active)
        {
            return FMOD_Geometry_GetActive(rawPtr, out active);
        }
        public RESULT setRotation           (ref VECTOR forward, ref VECTOR up)
        {
            return FMOD_Geometry_SetRotation(rawPtr, ref forward, ref up);
        }
        public RESULT getRotation           (out VECTOR forward, out VECTOR up)
        {
            return FMOD_Geometry_GetRotation(rawPtr, out forward, out up);
        }
        public RESULT setPosition           (ref VECTOR position)
        {
            return FMOD_Geometry_SetPosition(rawPtr, ref position);
        }
        public RESULT getPosition           (out VECTOR position)
        {
            return FMOD_Geometry_GetPosition(rawPtr, out position);
        }
        public RESULT setScale              (ref VECTOR scale)
        {
            return FMOD_Geometry_SetScale(rawPtr, ref scale);
        }
        public RESULT getScale              (out VECTOR scale)
        {
            return FMOD_Geometry_GetScale(rawPtr, out scale);
        }
        public RESULT save                  (IntPtr data, out int datasize)
        {
            return FMOD_Geometry_Save(rawPtr, data, out datasize);
        }

        // Userdata set/get.
        public RESULT setUserData               (IntPtr userdata)
        {
            return FMOD_Geometry_SetUserData(rawPtr, userdata);
        }
        public RESULT getUserData               (out IntPtr userdata)
        {
            return FMOD_Geometry_GetUserData(rawPtr, out userdata);
        }

        #region importfunctions
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_Release              (IntPtr geometry);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_AddPolygon           (IntPtr geometry, float directocclusion, float reverbocclusion, bool doublesided, int numvertices, VECTOR[] vertices, out int polygonindex);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetNumPolygons       (IntPtr geometry, out int numpolygons);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetMaxPolygons       (IntPtr geometry, out int maxpolygons, out int maxvertices);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetPolygonNumVertices(IntPtr geometry, int index, out int numvertices);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_SetPolygonVertex     (IntPtr geometry, int index, int vertexindex, ref VECTOR vertex);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetPolygonVertex     (IntPtr geometry, int index, int vertexindex, out VECTOR vertex);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_SetPolygonAttributes (IntPtr geometry, int index, float directocclusion, float reverbocclusion, bool doublesided);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetPolygonAttributes (IntPtr geometry, int index, out float directocclusion, out float reverbocclusion, out bool doublesided);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_SetActive            (IntPtr geometry, bool active);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetActive            (IntPtr geometry, out bool active);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_SetRotation          (IntPtr geometry, ref VECTOR forward, ref VECTOR up);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetRotation          (IntPtr geometry, out VECTOR forward, out VECTOR up);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_SetPosition          (IntPtr geometry, ref VECTOR position);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetPosition          (IntPtr geometry, out VECTOR position);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_SetScale             (IntPtr geometry, ref VECTOR scale);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetScale             (IntPtr geometry, out VECTOR scale);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_Save                 (IntPtr geometry, IntPtr data, out int datasize);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_SetUserData          (IntPtr geometry, IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Geometry_GetUserData          (IntPtr geometry, out IntPtr userdata);
        #endregion

        #region wrapperinternal

        public Geometry(IntPtr raw)
            : base(raw)
        {
        }

        #endregion
    }


    /*
        'Reverb3D' API
    */
    public class Reverb3D : HandleBase
    {
        public RESULT release()
        {
            RESULT result = FMOD_Reverb3D_Release(getRaw());
            if (result == RESULT.OK)
            {
                rawPtr = IntPtr.Zero;
            }
            return result;
        }

        // Reverb manipulation.
        public RESULT set3DAttributes(ref VECTOR position, float mindistance, float maxdistance)
        {
            return FMOD_Reverb3D_Set3DAttributes(rawPtr, ref position, mindistance, maxdistance);
        }
        public RESULT get3DAttributes(ref VECTOR position, ref float mindistance, ref float maxdistance)
        {
            return FMOD_Reverb3D_Get3DAttributes(rawPtr, ref position, ref mindistance, ref maxdistance);
        }
        public RESULT setProperties(ref REVERB_PROPERTIES properties)
        {
            return FMOD_Reverb3D_SetProperties(rawPtr, ref properties);
        }
        public RESULT getProperties(ref REVERB_PROPERTIES properties)
        {
            return FMOD_Reverb3D_GetProperties(rawPtr, ref properties);
        }
        public RESULT setActive(bool active)
        {
            return FMOD_Reverb3D_SetActive(rawPtr, active);
        }
        public RESULT getActive(out bool active)
        {
            return FMOD_Reverb3D_GetActive(rawPtr, out active);
        }

        // Userdata set/get.
        public RESULT setUserData(IntPtr userdata)
        {
            return FMOD_Reverb3D_SetUserData(rawPtr, userdata);
        }
        public RESULT getUserData(out IntPtr userdata)
        {
            return FMOD_Reverb3D_GetUserData(rawPtr, out userdata);
        }

        #region importfunctions
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Reverb3D_Release(IntPtr reverb);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Reverb3D_Set3DAttributes(IntPtr reverb, ref VECTOR position, float mindistance, float maxdistance);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Reverb3D_Get3DAttributes(IntPtr reverb, ref VECTOR position, ref float mindistance, ref float maxdistance);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Reverb3D_SetProperties(IntPtr reverb, ref REVERB_PROPERTIES properties);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Reverb3D_GetProperties(IntPtr reverb, ref REVERB_PROPERTIES properties);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Reverb3D_SetActive(IntPtr reverb, bool active);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Reverb3D_GetActive(IntPtr reverb, out bool active);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Reverb3D_SetUserData(IntPtr reverb, IntPtr userdata);
        [DllImport(VERSION.dll)]
        private static extern RESULT FMOD_Reverb3D_GetUserData(IntPtr reverb, out IntPtr userdata);
        #endregion

        #region wrapperinternal

        public Reverb3D(IntPtr raw)
            : base(raw)
        {
        }

        #endregion
    }

    class StringMarshalHelper
    {
        static internal void NativeToBuilder(StringBuilder builder, IntPtr nativeMem)
        {
            byte[] bytes = new byte[builder.Capacity];
            Marshal.Copy(nativeMem, bytes, 0, builder.Capacity);
			int strlen = Array.IndexOf(bytes, (byte)0);
			if (strlen > 0)
			{
				String str = Encoding.UTF8.GetString(bytes, 0, strlen);
				builder.Append(str);
			}
        }
    }
}

```

`AssetStudioUtility/FMOD Studio API/fmod_dsp.cs`:

```cs
/*$ preserve start $*/
/* ========================================================================================== */
/* FMOD Studio - DSP header file. Copyright (c), Firelight Technologies Pty, Ltd. 2004-2016.  */
/*                                                                                            */
/* Use this header if you are interested in delving deeper into the FMOD software mixing /    */
/* DSP engine.  In this header you can find parameter structures for FMOD system registered   */
/* DSP effects and generators.                                                                */
/*                                                                                            */
/* ========================================================================================== */

using System;
using System.Text;
using System.Runtime.InteropServices;

namespace FMOD
{
/*$ preserve end $*/

    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Structure for FMOD_DSP_PROCESS_CALLBACK input and output buffers.

        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.

        [SEE_ALSO]
        FMOD_DSP_DESCRIPTION
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_BUFFER_ARRAY
    {
        public int              numbuffers;              /* [r/w] number of buffers */
        public int[]            buffernumchannels;       /* [r/w] array of number of channels for each buffer */
        public CHANNELMASK[]    bufferchannelmask;       /* [r/w] array of channel masks for each buffer */
        public IntPtr[]         buffers;                 /* [r/w] array of buffers */
        public SPEAKERMODE      speakermode;             /* [r/w] speaker mode for all buffers in the array */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Operation type for FMOD_DSP_PROCESS_CALLBACK.

        [REMARKS]

        [SEE_ALSO]
        FMOD_DSP_DESCRIPTION
    ]
    */
    public enum DSP_PROCESS_OPERATION
    {
        PROCESS_PERFORM = 0,               /* Process the incoming audio in 'inbufferarray' and output to 'outbufferarray'. */
        PROCESS_QUERY                      /* The DSP is being queried for the expected output format and whether it needs to process audio or should be bypassed.  The function should return any value other than FMOD_OK if audio can pass through unprocessed. If audio is to be processed, 'outbufferarray' must be filled with the expected output format, channel count and mask. */
    }


    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Complex number structure used for holding FFT frequency domain-data for FMOD_FFTREAL and FMOD_IFFTREAL DSP callbacks.

        [REMARKS]

        [SEE_ALSO]    
        FMOD_DSP_STATE_SYSTEMCALLBACKS
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct COMPLEX
    {
        public float real; /* Real component */
        public float imag; /* Imaginary component */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        Flags for the FMOD_DSP_PAN_SUM_SURROUND_MATRIX callback.

        [REMARKS]
        This functionality is experimental, please contact support@fmod.org for more information.

        [SEE_ALSO]
        FMOD_DSP_STATE_PAN_CALLBACKS
    ]
    */
    public enum DSP_PAN_SURROUND_FLAGS
    {
        DEFAULT = 0,
        ROTATION_NOT_BIASED = 1,
    }

    /*
        DSP callbacks
    */
    public delegate RESULT DSP_CREATECALLBACK                   (ref DSP_STATE dsp_state);
    public delegate RESULT DSP_RELEASECALLBACK                  (ref DSP_STATE dsp_state);
    public delegate RESULT DSP_RESETCALLBACK                    (ref DSP_STATE dsp_state);
    public delegate RESULT DSP_SETPOSITIONCALLBACK              (ref DSP_STATE dsp_state, uint pos);
    public delegate RESULT DSP_READCALLBACK                     (ref DSP_STATE dsp_state, IntPtr inbuffer, IntPtr outbuffer, uint length, int inchannels, ref int outchannels);
    public delegate RESULT DSP_SHOULDIPROCESS_CALLBACK          (ref DSP_STATE dsp_state, bool inputsidle, uint length, CHANNELMASK inmask, int inchannels, SPEAKERMODE speakermode);
    public delegate RESULT DSP_PROCESS_CALLBACK                 (ref DSP_STATE dsp_state, uint length, ref DSP_BUFFER_ARRAY inbufferarray, ref DSP_BUFFER_ARRAY outbufferarray, bool inputsidle, DSP_PROCESS_OPERATION op);

    public delegate RESULT DSP_SETPARAM_FLOAT_CALLBACK          (ref DSP_STATE dsp_state, int index, float value);
    public delegate RESULT DSP_SETPARAM_INT_CALLBACK            (ref DSP_STATE dsp_state, int index, int value);
    public delegate RESULT DSP_SETPARAM_BOOL_CALLBACK           (ref DSP_STATE dsp_state, int index, bool value);
    public delegate RESULT DSP_SETPARAM_DATA_CALLBACK           (ref DSP_STATE dsp_state, int index, IntPtr data, uint length);
    public delegate RESULT DSP_GETPARAM_FLOAT_CALLBACK          (ref DSP_STATE dsp_state, int index, ref float value, IntPtr valuestr);
    public delegate RESULT DSP_GETPARAM_INT_CALLBACK            (ref DSP_STATE dsp_state, int index, ref int value, IntPtr valuestr);
    public delegate RESULT DSP_GETPARAM_BOOL_CALLBACK           (ref DSP_STATE dsp_state, int index, ref bool value, IntPtr valuestr);
    public delegate RESULT DSP_GETPARAM_DATA_CALLBACK           (ref DSP_STATE dsp_state, int index, ref IntPtr data, ref uint length, IntPtr valuestr);

    public delegate RESULT DSP_SYSTEM_REGISTER_CALLBACK         (ref DSP_STATE dsp_state);
    public delegate RESULT DSP_SYSTEM_DEREGISTER_CALLBACK       (ref DSP_STATE dsp_state);
    public delegate RESULT DSP_SYSTEM_MIX_CALLBACK              (ref DSP_STATE dsp_state, int stage);

    public delegate RESULT DSP_SYSTEM_GETSAMPLERATE             (ref DSP_STATE dsp_state, ref int rate);
    public delegate RESULT DSP_SYSTEM_GETBLOCKSIZE              (ref DSP_STATE dsp_state, ref uint blocksize);
    public delegate RESULT DSP_SYSTEM_GETSPEAKERMODE            (ref DSP_STATE dsp_state, ref int speakermode_mixer, ref int speakermode_output);

    public delegate RESULT DSP_DFT_FFTREAL                      (ref DSP_STATE dsp_state, int size, IntPtr signal, IntPtr dft, IntPtr window, int signalhop);
    public delegate RESULT DSP_DFT_IFFTREAL                     (ref DSP_STATE dsp_state, int size, IntPtr dft, IntPtr signal, IntPtr window, int signalhop);

    public delegate RESULT DSP_PAN_SUM_MONO_MATRIX              (ref DSP_STATE dsp_state, int sourceSpeakerMode, float lowFrequencyGain, float overallGain, IntPtr matrix);
    public delegate RESULT DSP_PAN_SUM_STEREO_MATRIX            (ref DSP_STATE dsp_state, int sourceSpeakerMode, float pan, float lowFrequencyGain, float overallGain, int matrixHop, IntPtr matrix);
    public delegate RESULT DSP_PAN_SUM_SURROUND_MATRIX          (ref DSP_STATE dsp_state, int sourceSpeakerMode, int targetSpeakerMode, float direction, float extent, float rotation, float lowFrequencyGain, float overallGain, int matrixHop, IntPtr matrix, DSP_PAN_SURROUND_FLAGS flags);
    public delegate RESULT DSP_PAN_SUM_MONO_TO_SURROUND_MATRIX  (ref DSP_STATE dsp_state, int targetSpeakerMode, float direction, float extent, float lowFrequencyGain, float overallGain, int matrixHop, IntPtr matrix);
    public delegate RESULT DSP_PAN_SUM_STEREO_TO_SURROUND_MATRIX(ref DSP_STATE dsp_state, int targetSpeakerMode, float direction, float extent, float rotation, float lowFrequencyGain, float overallGain, int matrixHop, IntPtr matrix);
    public delegate RESULT DSP_PAN_3D_GET_ROLLOFF_GAIN          (ref DSP_STATE dsp_state, DSP_PAN_3D_ROLLOFF_TYPE rolloff, float distance, float mindistance, float maxdistance, out float gain);


    /*
    [ENUM]
    [
        [DESCRIPTION]
        These definitions can be used for creating FMOD defined special effects or DSP units.

        [REMARKS]
        To get them to be active, first create the unit, then add it somewhere into the DSP network, either at the front of the network near the soundcard unit to affect the global output (by using System::getDSPHead), or on a single channel (using Channel::getDSPHead).

        [SEE_ALSO]
        System::createDSPByType
    ]
    */
    public enum DSP_TYPE : int
    {
        UNKNOWN,            /* This unit was created via a non FMOD plugin so has an unknown purpose. */
        MIXER,              /* This unit does nothing but take inputs and mix them together then feed the result to the soundcard unit. */
        OSCILLATOR,         /* This unit generates sine/square/saw/triangle or noise tones. */
        LOWPASS,            /* This unit filters sound using a high quality, resonant lowpass filter algorithm but consumes more CPU time. */
        ITLOWPASS,          /* This unit filters sound using a resonant lowpass filter algorithm that is used in Impulse Tracker, but with limited cutoff range (0 to 8060hz). */
        HIGHPASS,           /* This unit filters sound using a resonant highpass filter algorithm. */
        ECHO,               /* This unit produces an echo on the sound and fades out at the desired rate. */
        FADER,              /* This unit pans and scales the volume of a unit. */
        FLANGE,             /* This unit produces a flange effect on the sound. */
        DISTORTION,         /* This unit distorts the sound. */
        NORMALIZE,          /* This unit normalizes or amplifies the sound to a certain level. */
        LIMITER,            /* This unit limits the sound to a certain level. */
        PARAMEQ,            /* This unit attenuates or amplifies a selected frequency range. */
        PITCHSHIFT,         /* This unit bends the pitch of a sound without changing the speed of playback. */
        CHORUS,             /* This unit produces a chorus effect on the sound. */
        VSTPLUGIN,          /* This unit allows the use of Steinberg VST plugins */
        WINAMPPLUGIN,       /* This unit allows the use of Nullsoft Winamp plugins */
        ITECHO,             /* This unit produces an echo on the sound and fades out at the desired rate as is used in Impulse Tracker. */
        COMPRESSOR,         /* This unit implements dynamic compression (linked multichannel, wideband) */
        SFXREVERB,          /* This unit implements SFX reverb */
        LOWPASS_SIMPLE,     /* This unit filters sound using a simple lowpass with no resonance, but has flexible cutoff and is fast. */
        DELAY,              /* This unit produces different delays on individual channels of the sound. */
        TREMOLO,            /* This unit produces a tremolo / chopper effect on the sound. */
        LADSPAPLUGIN,       /* This unit allows the use of LADSPA standard plugins. */
        SEND,               /* This unit sends a copy of the signal to a return DSP anywhere in the DSP tree. */
        RETURN,             /* This unit receives signals from a number of send DSPs. */
        HIGHPASS_SIMPLE,    /* This unit filters sound using a simple highpass with no resonance, but has flexible cutoff and is fast. */
        PAN,                /* This unit pans the signal, possibly upmixing or downmixing as well. */
        THREE_EQ,           /* This unit is a three-band equalizer. */
        FFT,                /* This unit simply analyzes the signal and provides spectrum information back through getParameter. */
        LOUDNESS_METER,     /* This unit analyzes the loudness and true peak of the signal. */
        ENVELOPEFOLLOWER,   /* This unit tracks the envelope of the input/sidechain signal */
        CONVOLUTIONREVERB,  /* This unit implements convolution reverb. */
        CHANNELMIX,         /* This unit provides per signal channel gain, and output channel mapping to allow 1 multichannel signal made up of many groups of signals to map to a single output signal. */
        TRANSCEIVER,        /* This unit 'sends' and 'receives' from a selection of up to 32 different slots.  It is like a send/return but it uses global slots rather than returns as the destination.  It also has other features.  Multiple transceivers can receive from a single channel, or multiple transceivers can send to a single channel, or a combination of both. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        DSP parameter types.

        [REMARKS]

        [SEE_ALSO]
        FMOD_DSP_PARAMETER_DESC
    ]
    */
    public enum DSP_PARAMETER_TYPE
    {
        FLOAT = 0,
        INT,
        BOOL,
        DATA,
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        DSP float parameter mappings. These determine how values are mapped across dials and automation curves.

        [REMARKS]
        FMOD_DSP_PARAMETER_FLOAT_MAPPING_TYPE_AUTO generates a mapping based on range and units. For example, if the units are in Hertz and the range is with-in the audio spectrum, a Bark scale will be chosen. Logarithmic scales may also be generated for ranges above zero spanning several orders of magnitude.

        [SEE_ALSO]
        FMOD_DSP_PARAMETER_FLOAT_MAPPING
    ]
    */
    public enum DSP_PARAMETER_FLOAT_MAPPING_TYPE
    {
        DSP_PARAMETER_FLOAT_MAPPING_TYPE_LINEAR = 0,          /* Values mapped linearly across range. */
        DSP_PARAMETER_FLOAT_MAPPING_TYPE_AUTO,                /* A mapping is automatically chosen based on range and units.  See remarks. */
        DSP_PARAMETER_FLOAT_MAPPING_TYPE_PIECEWISE_LINEAR,    /* Values mapped in a piecewise linear fashion defined by FMOD_DSP_PARAMETER_DESC_FLOAT::mapping.piecewiselinearmapping. */
    }

    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Structure to define a piecewise linear mapping.

        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.

        [SEE_ALSO]    
        FMOD_DSP_PARAMETER_FLOAT_MAPPING_TYPE
        FMOD_DSP_PARAMETER_FLOAT_MAPPING
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_FLOAT_MAPPING_PIECEWISE_LINEAR
    {
        public int numpoints;                       /* [w] The number of <position, value> pairs in the piecewise mapping (at least 2). */
        public IntPtr pointparamvalues;             /* [w] The values in the parameter's units for each point */
        public IntPtr pointpositions;               /* [w] The positions along the control's scale (e.g. dial angle) corresponding to each parameter value.  The range of this scale is arbitrary and all positions will be relative to the minimum and maximum values (e.g. [0,1,3] is equivalent to [1,2,4] and [2,4,8]).  If this array is zero, pointparamvalues will be distributed with equal spacing. */
    }

    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Structure to define a mapping for a DSP unit's float parameter.

        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.

        [SEE_ALSO]
        FMOD_DSP_PARAMETER_FLOAT_MAPPING_TYPE
        FMOD_DSP_PARAMETER_DESC_FLOAT
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_FLOAT_MAPPING
    {
        public DSP_PARAMETER_FLOAT_MAPPING_TYPE type;
        public DSP_PARAMETER_FLOAT_MAPPING_PIECEWISE_LINEAR piecewiselinearmapping;    /* [w] Only required for FMOD_DSP_PARAMETER_FLOAT_MAPPING_TYPE_PIECEWISE_LINEAR type mapping. */
    }


    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Structure to define a float parameter for a DSP unit.

        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.

        [SEE_ALSO]
        System::createDSP
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_PARAMETER_DESC
        FMOD_DSP_PARAMETER_FLOAT_MAPPING
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_DESC_FLOAT
    {
        public float                     min;                      /* [w] Minimum parameter value. */
        public float                     max;                      /* [w] Maximum parameter value. */
        public float                     defaultval;               /* [w] Default parameter value. */
        public DSP_PARAMETER_FLOAT_MAPPING mapping;           /* [w] How the values are distributed across dials and automation curves (e.g. linearly, exponentially etc). */
    }


    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Structure to define a int parameter for a DSP unit.

        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.

        [SEE_ALSO]
        System::createDSP
        DSP::setParameterInt
        DSP::getParameterInt
        FMOD_DSP_PARAMETER_DESC
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_DESC_INT
    {
        public int                       min;                      /* [w] Minimum parameter value. */
        public int                       max;                      /* [w] Maximum parameter value. */
        public int                       defaultval;               /* [w] Default parameter value. */
        public bool                      goestoinf;                /* [w] Whether the last value represents infiniy. */
        public IntPtr                    valuenames;               /* [w] Names for each value.  There should be as many strings as there are possible values (max - min + 1).  Optional. */
    }


    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Structure to define a boolean parameter for a DSP unit.

        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.

        [SEE_ALSO]
        System::createDSP
        DSP::setParameterBool
        DSP::getParameterBool
        FMOD_DSP_PARAMETER_DESC
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_DESC_BOOL
    {
        public bool                      defaultval;               /* [w] Default parameter value. */
        public IntPtr                    valuenames;               /* [w] Names for false and true, respectively.  There should be two strings.  Optional. */
    }


    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        Structure to define a data parameter for a DSP unit.  Use 0 or above for custom types.  This parameter will be treated specially by the system if set to one of the FMOD_DSP_PARAMETER_DATA_TYPE values.

        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.

        [SEE_ALSO]
        System::createDSP
        DSP::setParameterData
        DSP::getParameterData
        FMOD_DSP_PARAMETER_DATA_TYPE
        FMOD_DSP_PARAMETER_DESC
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_DESC_DATA
    {
        public int                       datatype;                 /* [w] The type of data for this parameter.  Use 0 or above for custom types or set to one of the FMOD_DSP_PARAMETER_DATA_TYPE values. */
    }


    /*
    [STRUCTURE]
    [
        [DESCRIPTION]

        [REMARKS]
        Members marked with [w] mean the user sets the value before passing it to the function.
        Members marked with [r] mean FMOD sets the value to be used after the function exits.
        
        The step parameter tells the gui or application that the parameter has a certain granularity.
        For example in the example of cutoff frequency with a range from 100.0 to 22050.0 you might only want the selection to be in 10hz increments.  For this you would simply use 10.0 as the step value.
        For a boolean, you can use min = 0.0, max = 1.0, step = 1.0.  This way the only possible values are 0.0 and 1.0.
        Some applications may detect min = 0.0, max = 1.0, step = 1.0 and replace a graphical slider bar with a checkbox instead.
        A step value of 1.0 would simulate integer values only.
        A step value of 0.0 would mean the full floating point range is accessable.

        [SEE_ALSO]
        System::createDSP
        System::getDSP
    ]
    */
    [StructLayout(LayoutKind.Explicit)]
    public struct DSP_PARAMETER_DESC_UNION
    {
        [FieldOffset(0)]
        public DSP_PARAMETER_DESC_FLOAT   floatdesc;  /* [w] Struct containing information about the parameter in floating point format.  Use when type is FMOD_DSP_PARAMETER_TYPE_FLOAT. */
        [FieldOffset(0)]
        public DSP_PARAMETER_DESC_INT     intdesc;    /* [w] Struct containing information about the parameter in integer format.  Use when type is FMOD_DSP_PARAMETER_TYPE_INT. */
        [FieldOffset(0)]
        public DSP_PARAMETER_DESC_BOOL    booldesc;   /* [w] Struct containing information about the parameter in boolean format.  Use when type is FMOD_DSP_PARAMETER_TYPE_BOOL. */
        [FieldOffset(0)]
        public DSP_PARAMETER_DESC_DATA    datadesc;   /* [w] Struct containing information about the parameter in data format.  Use when type is FMOD_DSP_PARAMETER_TYPE_DATA. */
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_DESC
    {
        public DSP_PARAMETER_TYPE   type;            /* [w] Type of this parameter. */
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public char[]               name;            /* [w] Name of the parameter to be displayed (ie "Cutoff frequency"). */
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public char[]               label;           /* [w] Short string to be put next to value to denote the unit type (ie "hz"). */
        public string               description;     /* [w] Description of the parameter to be displayed as a help item / tooltip for this parameter. */

        public DSP_PARAMETER_DESC_UNION desc;
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        Built-in types for the 'datatype' member of FMOD_DSP_PARAMETER_DESC_DATA.  Data parameters of type other than FMOD_DSP_PARAMETER_DATA_TYPE_USER will be treated specially by the system.

        [REMARKS]

        [SEE_ALSO]
        FMOD_DSP_PARAMETER_DESC_DATA
        FMOD_DSP_PARAMETER_OVERALLGAIN
        FMOD_DSP_PARAMETER_3DATTRIBUTES
        FMOD_DSP_PARAMETER_3DATTRIBUTES_MULTI
        FMOD_DSP_PARAMETER_SIDECHAIN
    ]
    */
    public enum DSP_PARAMETER_DATA_TYPE
    {
        DSP_PARAMETER_DATA_TYPE_USER = 0,              /* The default data type.  All user data types should be 0 or above. */
        DSP_PARAMETER_DATA_TYPE_OVERALLGAIN = -1,      /* The data type for FMOD_DSP_PARAMETER_OVERALLGAIN parameters.  There should a maximum of one per DSP. */
        DSP_PARAMETER_DATA_TYPE_3DATTRIBUTES = -2,     /* The data type for FMOD_DSP_PARAMETER_3DATTRIBUTES parameters.  There should a maximum of one per DSP. */
        DSP_PARAMETER_DATA_TYPE_SIDECHAIN = -3,        /* The data type for FMOD_DSP_PARAMETER_SIDECHAIN parameters.  There should a maximum of one per DSP. */
        DSP_PARAMETER_DATA_TYPE_FFT = -4,              /* The data type for FMOD_DSP_PARAMETER_FFT parameters.  There should a maximum of one per DSP. */
        DSP_PARAMETER_DATA_TYPE_3DATTRIBUTES_MULTI = -5, /* The data type for FMOD_DSP_PARAMETER_3DATTRIBUTES_MULTI parameters.  There should a maximum of one per DSP. */
    }


    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Structure for data parameters of type FMOD_DSP_PARAMETER_DATA_TYPE_OVERALLGAIN.
        A parameter of this type is used in effects that affect the overgain of the signal in a predictable way.
        This parameter is read by the system to determine the effect's gain for voice virtualization.
    
        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.
    
        [SEE_ALSO]    
        FMOD_DSP_PARAMETER_DATA_TYPE
        FMOD_DSP_PARAMETER_DESC
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_OVERALLGAIN
    {
        public float linear_gain;                                  /* [r] The overall linear gain of the effect on the direct signal path */
        public float linear_gain_additive;                         /* [r] Additive gain, for parallel signal paths */
    }
    
    
    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Structure for data parameters of type FMOD_DSP_PARAMETER_DATA_TYPE_3DATTRIBUTES.
        A parameter of this type is used in effects that respond to a sound's 3D position.
        The system will set this parameter automatically if a sound's position changes.
    
        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.
    
        [SEE_ALSO]    
        FMOD_DSP_PARAMETER_DATA_TYPE
        FMOD_DSP_PARAMETER_DESC
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_3DATTRIBUTES
    {
        public _3D_ATTRIBUTES relative;                        /* [w] The position of the sound relative to the listener. */
        public _3D_ATTRIBUTES absolute;                        /* [w] The position of the sound in world coordinates. */
    }
    
    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Structure for data parameters of type FMOD_DSP_PARAMETER_DATA_TYPE_3DATTRIBUTES.
        A parameter of this type is used in effects that respond to a sound's 3D position.
        The system will set this parameter automatically if a sound's position changes.
    
        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.
    
        [SEE_ALSO]    
        FMOD_DSP_PARAMETER_DATA_TYPE
        FMOD_DSP_PARAMETER_DESC
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_3DATTRIBUTES_MULTI
    {
        public int            numlisteners;                    /* [w] The number of listeners. */
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)]
        public _3D_ATTRIBUTES[] relative;                      /* [w] The position of the sound relative to the listeners. */
        public _3D_ATTRIBUTES absolute;                        /* [w] The position of the sound in world coordinates. */
    }
    
    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Structure for data parameters of type FMOD_DSP_PARAMETER_DATA_TYPE_SIDECHAIN.
        A parameter of this type is declared for effects which support sidechaining.
    
        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.
    
        [SEE_ALSO]    
        FMOD_DSP_PARAMETER_DATA_TYPE
        FMOD_DSP_PARAMETER_DESC
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_SIDECHAIN
    {
        public int sidechainenable;                               /* [r/w] Whether sidechains are enabled. */
    }
    
    
    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Structure for data parameters of type FMOD_DSP_PARAMETER_DATA_TYPE_FFT.
        A parameter of this type is declared for the FMOD_DSP_TYPE_FFT effect.
    
        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.
        
        Notes on the spectrum data member.  Values inside the float buffer are typically between 0 and 1.0.
        Each top level array represents one PCM channel of data.
        Address data as spectrum[channel][bin].  A bin is 1 fft window entry.
        Only read/display half of the buffer typically for analysis as the 2nd half is usually the same data reversed due to the nature of the way FFT works.
    
        [SEE_ALSO]    
        FMOD_DSP_PARAMETER_DATA_TYPE
        FMOD_DSP_PARAMETER_DESC
        FMOD_DSP_PARAMETER_DATA_TYPE_FFT
        FMOD_DSP_TYPE
        FMOD_DSP_FFT
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_PARAMETER_FFT
    {
        public int     length;                                    /* [r] Number of entries in this spectrum window.   Divide this by the output rate to get the hz per entry. */
        public int     numchannels;                               /* [r] Number of channels in spectrum. */
        
        [MarshalAs(UnmanagedType.ByValArray,SizeConst=32)]
        private IntPtr[] spectrum_internal;                           /* [r] Per channel spectrum arrays.  See remarks for more. */
        
        public float[][] spectrum
        {
            get
            {
                var buffer = new float[numchannels][];
                
                for (int i = 0; i < numchannels; ++i)
                {
                    buffer[i] = new float[length];
                    Marshal.Copy(spectrum_internal[i], buffer[i], 0, length);
                }
                
                return buffer;
            }
        }
    }

    /*
    [STRUCTURE]
    [
        [DESCRIPTION]
        When creating a DSP unit, declare one of these and provide the relevant callbacks and name for FMOD to use when it creates and uses a DSP unit of this type.

        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.
        
        There are 2 different ways to change a parameter in this architecture.
        One is to use DSP::setParameterFloat / DSP::setParameterInt / DSP::setParameterBool / DSP::setParameterData.  This is platform independant and is dynamic, so new unknown plugins can have their parameters enumerated and used.
        The other is to use DSP::showConfigDialog.  This is platform specific and requires a GUI, and will display a dialog box to configure the plugin.

        [SEE_ALSO]    
        System::createDSP
        DSP::setParameterFloat
        DSP::setParameterInt
        DSP::setParameterBool
        DSP::setParameterData
        FMOD_DSP_STATE
        FMOD_DSP_CREATE_CALLBACK
        FMOD_DSP_RELEASE_CALLBACK
        FMOD_DSP_RESET_CALLBACK
        FMOD_DSP_READ_CALLBACK
        FMOD_DSP_PROCESS_CALLBACK
        FMOD_DSP_SETPOSITION_CALLBACK
        FMOD_DSP_PARAMETER_DESC
        FMOD_DSP_SETPARAM_FLOAT_CALLBACK
        FMOD_DSP_SETPARAM_INT_CALLBACK
        FMOD_DSP_SETPARAM_BOOL_CALLBACK
        FMOD_DSP_SETPARAM_DATA_CALLBACK
        FMOD_DSP_GETPARAM_FLOAT_CALLBACK
        FMOD_DSP_GETPARAM_INT_CALLBACK
        FMOD_DSP_GETPARAM_BOOL_CALLBACK
        FMOD_DSP_GETPARAM_DATA_CALLBACK
        FMOD_DSP_SHOULDIPROCESS_CALLBACK
        FMOD_DSP_SYSTEM_REGISTER_CALLBACK
        FMOD_DSP_SYSTEM_DEREGISTER_CALLBACK
        FMOD_DSP_SYSTEM_MIX_CALLBACK
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_DESCRIPTION
    {
        public uint                           pluginsdkversion;   /* [w] The plugin SDK version this plugin is built for.  set to this to FMOD_PLUGIN_SDK_VERSION defined above. */
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
        public char[]                         name;               /* [w] Name of the unit to be displayed in the network. */
        public uint                           version;            /* [w] Plugin writer's version number. */
        public int                            numinputbuffers;    /* [w] Number of input buffers to process.  Use 0 for DSPs that only generate sound and 1 for effects that process incoming sound. */
        public int                            numoutputbuffers;   /* [w] Number of audio output buffers.  Only one output buffer is currently supported. */
        public DSP_CREATECALLBACK             create;             /* [w] Create callback.  This is called when DSP unit is created.  Can be null. */
        public DSP_RELEASECALLBACK            release;            /* [w] Release callback.  This is called just before the unit is freed so the user can do any cleanup needed for the unit.  Can be null. */
        public DSP_RESETCALLBACK              reset;              /* [w] Reset callback.  This is called by the user to reset any history buffers that may need resetting for a filter, when it is to be used or re-used for the first time to its initial clean state.  Use to avoid clicks or artifacts. */
        public DSP_READCALLBACK               read;               /* [w] Read callback.  Processing is done here.  Can be null. */
        public DSP_PROCESS_CALLBACK           process;            /* [w] Process callback.  Can be specified instead of the read callback if any channel format changes occur between input and output.  This also replaces shouldiprocess and should return an error if the effect is to be bypassed.  Can be null. */
        public DSP_SETPOSITIONCALLBACK        setposition;        /* [w] Setposition callback.  This is called if the unit wants to update its position info but not process data.  Can be null. */

        public int                            numparameters;      /* [w] Number of parameters used in this filter.  The user finds this with DSP::getNumParameters */
        public IntPtr                         paramdesc;          /* [w] Variable number of parameter structures. */
        public DSP_SETPARAM_FLOAT_CALLBACK    setparameterfloat;  /* [w] This is called when the user calls DSP.setParameterFloat. Can be null. */
        public DSP_SETPARAM_INT_CALLBACK      setparameterint;    /* [w] This is called when the user calls DSP.setParameterInt.   Can be null. */
        public DSP_SETPARAM_BOOL_CALLBACK     setparameterbool;   /* [w] This is called when the user calls DSP.setParameterBool.  Can be null. */
        public DSP_SETPARAM_DATA_CALLBACK     setparameterdata;   /* [w] This is called when the user calls DSP.setParameterData.  Can be null. */
        public DSP_GETPARAM_FLOAT_CALLBACK    getparameterfloat;  /* [w] This is called when the user calls DSP.getParameterFloat. Can be null. */
        public DSP_GETPARAM_INT_CALLBACK      getparameterint;    /* [w] This is called when the user calls DSP.getParameterInt.   Can be null. */
        public DSP_GETPARAM_BOOL_CALLBACK     getparameterbool;   /* [w] This is called when the user calls DSP.getParameterBool.  Can be null. */
        public DSP_GETPARAM_DATA_CALLBACK     getparameterdata;   /* [w] This is called when the user calls DSP.getParameterData.  Can be null. */
        public DSP_SHOULDIPROCESS_CALLBACK    shouldiprocess;     /* [w] This is called before processing.  You can detect if inputs are idle and return FMOD_OK to process, or any other error code to avoid processing the effect.  Use a count down timer to allow effect tails to process before idling! */
        public IntPtr                         userdata;           /* [w] Optional. Specify 0 to ignore. This is user data to be attached to the DSP unit during creation.  Access via DSP::getUserData. */

        public DSP_SYSTEM_REGISTER_CALLBACK   sys_register;       /* [w] Register callback.  This is called when DSP unit is loaded/registered.  Useful for 'global'/per system object init for plugin.  Can be null. */
        public DSP_SYSTEM_DEREGISTER_CALLBACK sys_deregister;     /* [w] Deregister callback.  This is called when DSP unit is unloaded/deregistered.  Useful as 'global'/per system object shutdown for plugin.  Can be null. */
        public DSP_SYSTEM_MIX_CALLBACK        sys_mix;            /* [w] System mix stage callback.  This is called when the mixer starts to execute or is just finishing executing.  Useful for 'global'/per system object once a mix update calls for a plugin.  Can be null. */
    }

    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Struct containing DFT callbacks for plugins, to enable a plugin to perform optimized time-frequency domain conversion.

        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.

        [SEE_ALSO]
        FMOD_DSP_STATE_SYSTEMCALLBACKS
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_STATE_DFTCALLBACKS
    {
        public DSP_DFT_FFTREAL                            fftreal;        /* [r] Callback for performing an FFT on a real signal. */
        public DSP_DFT_IFFTREAL                           inversefftreal; /* [r] Callback for performing an inverse FFT to get a real signal. */
    }

    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Struct containing panning helper callbacks for plugins.

        [REMARKS]
        These are experimental, please contact support@fmod.org for more information.

        [SEE_ALSO]
        FMOD_DSP_STATE_SYSTEMCALLBACKS
        FMOD_PAN_SURROUND_FLAGS
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_STATE_PAN_CALLBACKS
    {
        public DSP_PAN_SUM_MONO_MATRIX                summonomatrix;
        public DSP_PAN_SUM_STEREO_MATRIX              sumstereomatrix;
        public DSP_PAN_SUM_SURROUND_MATRIX            sumsurroundmatrix;
        public DSP_PAN_SUM_MONO_TO_SURROUND_MATRIX    summonotosurroundmatrix;
        public DSP_PAN_SUM_STEREO_TO_SURROUND_MATRIX  sumstereotosurroundmatrix;
        public DSP_PAN_3D_GET_ROLLOFF_GAIN            getrolloffgain;
    }

    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        Struct containing System level callbacks for plugins, to enable a plugin to query information about the system or allocate memory using FMOD's (and therefore possibly the game's) allocators.

        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.

        [SEE_ALSO]
        FMOD_DSP_STATE
        FMOD_DSP_STATE_DFTCALLBACKS  
        FMOD_DSP_STATE_PAN_CALLBACKS     
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_STATE_SYSTEMCALLBACKS
    {
        MEMORY_ALLOC_CALLBACK              alloc;          /* [r] Memory allocation callback. Use this for all dynamic memory allocation within the plugin. */
        MEMORY_REALLOC_CALLBACK            realloc;        /* [r] Memory reallocation callback. */
        MEMORY_FREE_CALLBACK               free;           /* [r] Memory free callback. */
        DSP_SYSTEM_GETSAMPLERATE           getsamplerate;  /* [r] Callback for getting the system samplerate. */
        DSP_SYSTEM_GETBLOCKSIZE            getblocksize;   /* [r] Callback for getting the system's block size.  DSPs will be requested to process blocks of varying length up to this size.*/
        IntPtr                             dft;            /* [r] Struct containing callbacks for performing FFTs and inverse FFTs. */
        IntPtr                             pancallbacks;   /* [r] Pointer to a structure of callbacks for calculating pan, up-mix and down-mix matrices. */
        DSP_SYSTEM_GETSPEAKERMODE          getspeakermode; /* [r] Callback for getting the system's speaker modes.  One is the mixer's default speaker mode, the other is the output mode the system is downmixing or upmixing to.*/
    }

    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        DSP plugin structure that is passed into each callback.

        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.
        
        'systemobject' is an integer that relates to the System object that created the DSP or registered the DSP plugin.  If only 1 System object is created then it should be 0.  A second object would be 1 and so on.
        FMOD_DSP_STATE_SYSTEMCALLBACKS::getsamplerate and FMOD_DSP_STATE_SYSTEMCALLBACKS::getblocksize could return different results so it could be relevant to plugin developers to monitor which object is being used.

        [SEE_ALSO]
        FMOD_DSP_DESCRIPTION
        FMOD_DSP_STATE_SYSTEMCALLBACKS
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public struct DSP_STATE
    {
        public IntPtr     instance;            /* [r] Handle to the DSP hand the user created.  Not to be modified.  C++ users cast to FMOD::DSP to use.  */
        public IntPtr     plugindata;          /* [r/w] Plugin writer created data the output author wants to attach to this object. */
        public uint       channelmask;         /* [r] Specifies which speakers the DSP effect is active on */
        public int        source_speakermode;  /* [r] Specifies which speaker mode the signal originated for information purposes, ie in case panning needs to be done differently. */
        public IntPtr     sidechaindata;       /* [r] The mixed result of all incoming sidechains is stored at this pointer address. */
        public int        sidechainchannels;   /* [r] The number of channels of pcm data stored within the sidechain buffer. */
        public IntPtr     callbacks;           /* [r] Struct containing callbacks for system level functionality. */
        public int        systemobject;        /* [r] FMOD::System object index, relating to the System object that created this DSP. */
    }

    /*
    [STRUCTURE] 
    [
        [DESCRIPTION]
        DSP metering info used for retrieving metering info

        [REMARKS]
        Members marked with [r] mean the variable is modified by FMOD and is for reading purposes only.  Do not change this value.
        Members marked with [w] mean the variable can be written to.  The user can set the value.

        [SEE_ALSO]
        FMOD_SPEAKER
    ]
    */
    [StructLayout(LayoutKind.Sequential)]
    public class DSP_METERING_INFO
    {
        public int   numsamples;        /* [r] The number of samples considered for this metering info. */
        [MarshalAs(UnmanagedType.ByValArray, SizeConst=32)]
        public float[] peaklevel;       /* [r] The peak level per channel. */
        [MarshalAs(UnmanagedType.ByValArray, SizeConst=32)]
        public float[] rmslevel;        /* [r] The rms level per channel. */
        public short numchannels;       /* [r] Number of channels. */
    }



    /*
        ==============================================================================================================

        FMOD built in effect parameters.
        Use DSP::setParameter with these enums for the 'index' parameter.

        ==============================================================================================================
    */

    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_OSCILLATOR filter.

        [REMARKS]

        [SEE_ALSO]
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_OSCILLATOR
    {
        TYPE,   /* Waveform type.  0 = sine.  1 = square. 2 = sawup. 3 = sawdown. 4 = triangle. 5 = noise.  */
        RATE    /* Frequency of the sinewave in hz.  1.0 to 22000.0.  Default = 220.0. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_LOWPASS filter.

        [REMARKS]

        [SEE_ALSO]
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_LOWPASS
    {
        CUTOFF,    /* Lowpass cutoff frequency in hz.   1.0 to 22000.0.  Default = 5000.0. */
        RESONANCE  /* Lowpass resonance Q value. 1.0 to 10.0.  Default = 1.0. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_ITLOWPASS filter.
        This is different to the default FMOD_DSP_TYPE_ITLOWPASS filter in that it uses a different quality algorithm and is
        the filter used to produce the correct sounding playback in .IT files.
        FMOD Ex's .IT playback uses this filter.

        [REMARKS]
        Note! This filter actually has a limited cutoff frequency below the specified maximum, due to its limited design,
        so for a more  open range filter use FMOD_DSP_LOWPASS or if you don't mind not having resonance,
        FMOD_DSP_LOWPASS_SIMPLE.
        The effective maximum cutoff is about 8060hz.

        [SEE_ALSO]
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_ITLOWPASS
    {
        CUTOFF,    /* Lowpass cutoff frequency in hz.  1.0 to 22000.0.  Default = 5000.0/ */
        RESONANCE  /* Lowpass resonance Q value.  0.0 to 127.0.  Default = 1.0. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_HIGHPASS filter.

        [REMARKS]

        [SEE_ALSO]
        DSP::setParameter
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_HIGHPASS
    {
        CUTOFF,    /* (Type:float) - Highpass cutoff frequency in hz.  1.0 to output 22000.0.  Default = 5000.0. */
        RESONANCE  /* (Type:float) - Highpass resonance Q value.  1.0 to 10.0.  Default = 1.0. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_ECHO filter.

        [REMARKS]
        Note.  Every time the delay is changed, the plugin re-allocates the echo buffer.  This means the echo will dissapear at that time while it refills its new buffer.
        Larger echo delays result in larger amounts of memory allocated.

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_ECHO
    {
        DELAY,       /* (Type:float) - Echo delay in ms.  10  to 5000.  Default = 500. */
        FEEDBACK,    /* (Type:float) - Echo decay per delay.  0 to 100.  100.0 = No decay, 0.0 = total decay (ie simple 1 line delay).  Default = 50.0. */
        DRYLEVEL,    /* (Type:float) - Original sound volume in dB.  -80.0 to 10.0.  Default = 0. */
        WETLEVEL     /* (Type:float) - Volume of echo signal to pass to output in dB.  -80.0 to 10.0.  Default = 0. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_DELAY filter.

        [REMARKS]
        Note.  Every time MaxDelay is changed, the plugin re-allocates the delay buffer.  This means the delay will dissapear at that time while it refills its new buffer.
        A larger MaxDelay results in larger amounts of memory allocated.
        Channel delays above MaxDelay will be clipped to MaxDelay and the delay buffer will not be resized.

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_DELAY
    {
        CH0,      /* Channel #0 Delay in ms.   0  to 10000.  Default = 0.  */
        CH1,      /* Channel #1 Delay in ms.   0  to 10000.  Default = 0.  */
        CH2,      /* Channel #2 Delay in ms.   0  to 10000.  Default = 0.  */
        CH3,      /* Channel #3 Delay in ms.   0  to 10000.  Default = 0.  */
        CH4,      /* Channel #4 Delay in ms.   0  to 10000.  Default = 0.  */
        CH5,      /* Channel #5 Delay in ms.   0  to 10000.  Default = 0.  */
        CH6,      /* Channel #6 Delay in ms.   0  to 10000.  Default = 0.  */
        CH7,      /* Channel #7 Delay in ms.   0  to 10000.  Default = 0.  */
        CH8,      /* Channel #8 Delay in ms.   0  to 10000.  Default = 0.  */
        CH9,      /* Channel #9 Delay in ms.   0  to 10000.  Default = 0.  */
        CH10,     /* Channel #10 Delay in ms.  0  to 10000.  Default = 0.  */
        CH11,     /* Channel #11 Delay in ms.  0  to 10000.  Default = 0.  */
        CH12,     /* Channel #12 Delay in ms.  0  to 10000.  Default = 0.  */
        CH13,     /* Channel #13 Delay in ms.  0  to 10000.  Default = 0.  */
        CH14,     /* Channel #14 Delay in ms.  0  to 10000.  Default = 0.  */
        CH15,     /* Channel #15 Delay in ms.  0  to 10000.  Default = 0.  */
        MAXDELAY, /* Maximum delay in ms.      0  to 1000.   Default = 10. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_FLANGE filter.

        [REMARKS]
        Flange is an effect where the signal is played twice at the same time, and one copy slides back and forth creating a whooshing or flanging effect.
        As there are 2 copies of the same signal, by default each signal is given 50% mix, so that the total is not louder than the original unaffected signal.
        
        Flange depth is a percentage of a 10ms shift from the original signal.  Anything above 10ms is not considered flange because to the ear it begins to 'echo' so 10ms is the highest value possible.

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_FLANGE
    {
        MIX,         /* (Type:float) - Percentage of wet signal in mix.  0 to 100. Default = 50. */
        DEPTH,       /* (Type:float) - Flange depth (percentage of 40ms delay).  0.01 to 1.0.  Default = 1.0. */
        RATE         /* (Type:float) - Flange speed in hz.  0.0 to 20.0.  Default = 0.1. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_TREMOLO filter.

        [REMARKS]
        The tremolo effect varies the amplitude of a sound. Depending on the settings, this unit can produce a tremolo, chopper or auto-pan effect.
        
        The shape of the LFO (low freq. oscillator) can morphed between sine, triangle and sawtooth waves using the FMOD_DSP_TREMOLO_SHAPE and FMOD_DSP_TREMOLO_SKEW parameters.
        FMOD_DSP_TREMOLO_DUTY and FMOD_DSP_TREMOLO_SQUARE are useful for a chopper-type effect where the first controls the on-time duration and second controls the flatness of the envelope.
        FMOD_DSP_TREMOLO_SPREAD varies the LFO phase between channels to get an auto-pan effect. This works best with a sine shape LFO.
        The LFO can be synchronized using the FMOD_DSP_TREMOLO_PHASE parameter which sets its instantaneous phase.

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_TREMOLO
    {
        FREQUENCY,     /* LFO frequency in Hz.  0.1 to 20.  Default = 4. */
        DEPTH,         /* Tremolo depth.  0 to 1.  Default = 0. */
        SHAPE,         /* LFO shape morph between triangle and sine.  0 to 1.  Default = 0. */
        SKEW,          /* Time-skewing of LFO cycle.  -1 to 1.  Default = 0. */
        DUTY,          /* LFO on-time.  0 to 1.  Default = 0.5. */
        SQUARE,        /* Flatness of the LFO shape.  0 to 1.  Default = 0. */
        PHASE,         /* Instantaneous LFO phase.  0 to 1.  Default = 0. */
        SPREAD         /* Rotation / auto-pan effect.  -1 to 1.  Default = 0. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_DISTORTION filter.

        [REMARKS]

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_DISTORTION
    {
        LEVEL    /* Distortion value.  0.0 to 1.0.  Default = 0.5. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_NORMALIZE filter.

        [REMARKS]
        Normalize amplifies the sound based on the maximum peaks within the signal.
        For example if the maximum peaks in the signal were 50% of the bandwidth, it would scale the whole sound by 2.
        The lower threshold value makes the normalizer ignores peaks below a certain point, to avoid over-amplification if a loud signal suddenly came in, and also to avoid amplifying to maximum things like background hiss.
        
        Because FMOD is a realtime audio processor, it doesn't have the luxury of knowing the peak for the whole sound (ie it can't see into the future), so it has to process data as it comes in.
        To avoid very sudden changes in volume level based on small samples of new data, fmod fades towards the desired amplification which makes for smooth gain control.  The fadetime parameter can control this.

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameter
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_NORMALIZE
    {
        FADETIME,    /* Time to ramp the silence to full in ms.  0.0 to 20000.0. Default = 5000.0. */
        THRESHHOLD,  /* Lower volume range threshold to ignore.  0.0 to 1.0.  Default = 0.1.  Raise higher to stop amplification of very quiet signals. */
        MAXAMP       /* Maximum amplification allowed.  1.0 to 100000.0.  Default = 20.0.  1.0 = no amplifaction, higher values allow more boost. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_LIMITER filter.

        [REMARKS]

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_LIMITER
    {
        RELEASETIME,   /* (Type:float) - Time to ramp the silence to full in ms.  1.0 to 1000.0. Default = 10.0. */
        CEILING,       /* (Type:float) - Maximum level of the output signal in dB.  -12.0 to 0.0.  Default = 0.0. */
        MAXIMIZERGAIN, /* (Type:float) - Maximum amplification allowed in dB.  0.0 to 12.0.  Default = 0.0. 0.0 = no amplifaction, higher values allow more boost. */
        MODE,          /* (Type:float) - Channel processing mode. 0 or 1. Default = 0. 0 = Independent (limiter per channel), 1 = Linked. */
    }
    
    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_PARAMEQ filter.

        [REMARKS]
        Parametric EQ is a bandpass filter that attenuates or amplifies a selected frequency and its neighbouring frequencies.
        
        To create a multi-band EQ create multiple FMOD_DSP_TYPE_PARAMEQ units and set each unit to different frequencies, for example 1000hz, 2000hz, 4000hz, 8000hz, 16000hz with a range of 1 octave each.
        
        When a frequency has its gain set to 1.0, the sound will be unaffected and represents the original signal exactly.

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_PARAMEQ
    {
        CENTER,     /* Frequency center.  20.0 to 22000.0.  Default = 8000.0. */
        BANDWIDTH,  /* Octave range around the center frequency to filter.  0.2 to 5.0.  Default = 1.0. */
        GAIN        /* Frequency Gain.  0.05 to 3.0.  Default = 1.0.  */
    }



    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_PITCHSHIFT filter.

        [REMARKS]
        This pitch shifting unit can be used to change the pitch of a sound without speeding it up or slowing it down.
        It can also be used for time stretching or scaling, for example if the pitch was doubled, and the frequency of the sound was halved, the pitch of the sound would sound correct but it would be twice as slow.
        
        Warning! This filter is very computationally expensive!  Similar to a vocoder, it requires several overlapping FFT and IFFT's to produce smooth output, and can require around 440mhz for 1 stereo 48khz signal using the default settings.
        Reducing the signal to mono will half the cpu usage, as will the overlap count.
        Reducing this will lower audio quality, but what settings to use are largely dependant on the sound being played.  A noisy polyphonic signal will need higher overlap and fft size compared to a speaking voice for example.
        
        This pitch shifter is based on the pitch shifter code at http://www.dspdimension.com, written by Stephan M. Bernsee.
        The original code is COPYRIGHT 1999-2003 Stephan M. Bernsee <smb@dspdimension.com>.
        
        'maxchannels' dictates the amount of memory allocated.  By default, the maxchannels value is 0.  If FMOD is set to stereo, the pitch shift unit will allocate enough memory for 2 channels.  If it is 5.1, it will allocate enough memory for a 6 channel pitch shift, etc.
        If the pitch shift effect is only ever applied to the global mix (ie it was added with System::addDSP), then 0 is the value to set as it will be enough to handle all speaker modes.
        When the pitch shift is added to a channel (ie Channel::addDSP) then the channel count that comes in could be anything from 1 to 8 possibly.  It is only in this case where you might want to increase the channel count above the output's channel count.
        If a channel pitch shift is set to a lower number than the sound's channel count that is coming in, it will not pitch shift the sound.

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_PITCHSHIFT
    {
        PITCH,       /* Pitch value.  0.5 to 2.0.  Default = 1.0. 0.5 = one octave down, 2.0 = one octave up.  1.0 does not change the pitch. */
        FFTSIZE,     /* FFT window size.  256, 512, 1024, 2048, 4096.  Default = 1024.  Increase this to reduce 'smearing'.  This effect is a warbling sound similar to when an mp3 is encoded at very low bitrates. */
        OVERLAP,     /* Window overlap.  1 to 32.  Default = 4.  Increase this to reduce 'tremolo' effect.  Increasing it by a factor of 2 doubles the CPU usage. */
        MAXCHANNELS  /* Maximum channels supported.  0 to 16.  0 = same as fmod's default output polyphony, 1 = mono, 2 = stereo etc.  See remarks for more.  Default = 0.  It is suggested to leave at 0! */
    }



    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_CHORUS filter.

        [REMARKS]
        Chorous is an effect where the sound is more 'spacious' due to 1 to 3 versions of the sound being played along side the original signal but with the pitch of each copy modulating on a sine wave.
        This is a highly configurable chorus unit.  It supports 3 taps, small and large delay times and also feedback.
        This unit also could be used to do a simple echo, or a flange effect.

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_CHORUS
    {
        MIX,      /* (Type:float) - Volume of original signal to pass to output.  0.0 to 100.0. Default = 50.0. */
        RATE,     /* (Type:float) - Chorus modulation rate in Hz.  0.0 to 20.0.  Default = 0.8 Hz. */
        DEPTH,    /* (Type:float) - Chorus modulation depth.  0.0 to 100.0.  Default = 3.0. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_ITECHO filter.
        This is effectively a software based echo filter that emulates the DirectX DMO echo effect.  Impulse tracker files can support this, and FMOD will produce the effect on ANY platform, not just those that support DirectX effects!

        [REMARKS]
        Note.  Every time the delay is changed, the plugin re-allocates the echo buffer.  This means the echo will dissapear at that time while it refills its new buffer.
        Larger echo delays result in larger amounts of memory allocated.
        
        As this is a stereo filter made mainly for IT playback, it is targeted for stereo signals.
        With mono signals only the FMOD_DSP_ITECHO_LEFTDELAY is used.
        For multichannel signals (>2) there will be no echo on those channels.

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
        System::addDSP
    ]
    */
    public enum DSP_ITECHO
    {
        WETDRYMIX,      /* (Type:float) - Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0.0 through 100.0 (all wet).  Default = 50. */
        FEEDBACK,       /* (Type:float) - Percentage of output fed back into input, in the range from 0.0 through 100.0.  Default = 50. */
        LEFTDELAY,      /* (Type:float) - Delay for left channel, in milliseconds, in the range from 1.0 through 2000.0.  Default = 500 ms. */
        RIGHTDELAY,     /* (Type:float) - Delay for right channel, in milliseconds, in the range from 1.0 through 2000.0.  Default = 500 ms. */
        PANDELAY        /* (Type:float) - Value that specifies whether to swap left and right delays with each successive echo.  Ranges from 0.0 (equivalent to FALSE) to 1.0 (equivalent to TRUE), meaning no swap.  Default = 0.  CURRENTLY NOT SUPPORTED. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_COMPRESSOR unit.
        This is a multichannel software limiter that is uniform across the whole spectrum.

        [REMARKS]
        The limiter is not guaranteed to catch every peak above the threshold level,
        because it cannot apply gain reduction instantaneously - the time delay is
        determined by the attack time. However setting the attack time too short will
        distort the sound, so it is a compromise. High level peaks can be avoided by
        using a short attack time - but not too short, and setting the threshold a few
        decibels below the critical level.
        
        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        DSP::setParameterBool
        DSP::getParameterBool
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_COMPRESSOR
    {
        THRESHOLD,   /* (Type:float) - Threshold level (dB) in the range from -80 through 0. The default value is 0. */ 
        RATIO,       /* (Type:float) - Compression Ratio (dB/dB) in the range from 1 to 50. The default value is 2.5. */ 
        ATTACK,      /* (Type:float) - Attack time (milliseconds), in the range from 0.1 through 1000. The default value is 20. */
        RELEASE,     /* (Type:float) - Release time (milliseconds), in the range from 10 through 5000. The default value is 100 */
        GAINMAKEUP,  /* (Type:float) - Make-up gain (dB) applied after limiting, in the range from 0 through 30. The default value is 0. */
        USESIDECHAIN,/* (Type:bool)  - Whether to analyse the sidechain signal instead of the input signal. The default value is false */
        LINKED       /* (Type:bool)  - FALSE = Independent (compressor per channel), TRUE = Linked.  The default value is TRUE. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_SFXREVERB unit.

        [REMARKS]
        This is a high quality I3DL2 based reverb.
        On top of the I3DL2 property set, "Dry Level" is also included to allow the dry mix to be changed.
        
        These properties can be set with presets in FMOD_REVERB_PRESETS.

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
        FMOD_REVERB_PRESETS
    ]
    */
    public enum DSP_SFXREVERB
    {
        DECAYTIME,           /* (Type:float) - Decay Time       : Reverberation decay time at low-frequencies in milliseconds.  Ranges from 100.0 to 20000.0. Default is 1500. */
        EARLYDELAY,          /* (Type:float) - Early Delay      : Delay time of first reflection in milliseconds.  Ranges from 0.0 to 300.0.  Default is 20. */
        LATEDELAY,           /* (Type:float) - Reverb Delay     : Late reverberation delay time relative to first reflection in milliseconds.  Ranges from 0.0 to 100.0.  Default is 40. */
        HFREFERENCE,         /* (Type:float) - HF Reference     : Reference frequency for high-frequency decay in Hz.  Ranges from 20.0 to 20000.0. Default is 5000. */
        HFDECAYRATIO,        /* (Type:float) - Decay HF Ratio   : High-frequency decay time relative to decay time in percent.  Ranges from 10.0 to 100.0. Default is 50. */
        DIFFUSION,           /* (Type:float) - Diffusion        : Reverberation diffusion (echo density) in percent.  Ranges from 0.0 to 100.0.  Default is 100. */
        DENSITY,             /* (Type:float) - Density          : Reverberation density (modal density) in percent.  Ranges from 0.0 to 100.0.  Default is 100. */
        LOWSHELFFREQUENCY,   /* (Type:float) - Low Shelf Frequency : Transition frequency of low-shelf filter in Hz.  Ranges from 20.0 to 1000.0. Default is 250. */
        LOWSHELFGAIN,        /* (Type:float) - Low Shelf Gain   : Gain of low-shelf filter in dB.  Ranges from -36.0 to 12.0.  Default is 0. */
        HIGHCUT,             /* (Type:float) - High Cut         : Cutoff frequency of low-pass filter in Hz.  Ranges from 20.0 to 20000.0. Default is 20000. */
        EARLYLATEMIX,        /* (Type:float) - Early/Late Mix   : Blend ratio of late reverb to early reflections in percent.  Ranges from 0.0 to 100.0.  Default is 50. */
        WETLEVEL,            /* (Type:float) - Wet Level        : Reverb signal level in dB.  Ranges from -80.0 to 20.0.  Default is -6. */
        DRYLEVEL             /* (Type:float) - Dry Level        : Dry signal level in dB.  Ranges from -80.0 to 20.0.  Default is 0. */
    }

    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_LOWPASS_SIMPLE filter.
        This is a very simple low pass filter, based on two single-pole RC time-constant modules.
        The emphasis is on speed rather than accuracy, so this should not be used for task requiring critical filtering.

        [REMARKS]

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_LOWPASS_SIMPLE
    {
        CUTOFF     /* Lowpass cutoff frequency in hz.  10.0 to 22000.0.  Default = 5000.0 */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_SEND DSP.

        [REMARKS]

        [SEE_ALSO]
        DSP::setParameterInt
        DSP::getParameterInt
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_SEND
    {
        RETURNID,     /* (Type:int) - ID of the Return DSP this send is connected to (integer values only). -1 indicates no connected Return DSP. Default = -1. */
        LEVEL,        /* (Type:float) - Send level. 0.0 to 1.0. Default = 1.0 */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_RETURN DSP.

        [REMARKS]

        [SEE_ALSO]
        DSP::setParameterInt
        DSP::getParameterInt
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_RETURN
    {
        ID,                 /* (Type:int) - ID of this Return DSP. Read-only.  Default = -1. */
        INPUT_SPEAKER_MODE  /* (Type:int) - Input speaker mode of this return.  Default = FMOD_SPEAKERMODE_DEFAULT. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_HIGHPASS_SIMPLE filter.
        This is a very simple single-order high pass filter.
        The emphasis is on speed rather than accuracy, so this should not be used for task requiring critical filtering. 

        [REMARKS]

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_HIGHPASS_SIMPLE
    {
        CUTOFF     /* (Type:float) - Highpass cutoff frequency in hz.  10.0 to 22000.0.  Default = 1000.0 */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter values for the FMOD_DSP_PAN_SURROUND_FROM_STEREO_MODE parameter of the FMOD_DSP_TYPE_PAN DSP.

        [REMARKS]

        [SEE_ALSO]
        FMOD_DSP_PAN
    ]
    */
    public enum DSP_PAN_SURROUND_FROM_STEREO_MODE_TYPE
    {
        DISTRIBUTED,
        DISCRETE
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter values for the FMOD_DSP_PAN_MODE parameter of the FMOD_DSP_TYPE_PAN DSP.

        [REMARKS]

        [SEE_ALSO]
        FMOD_DSP_PAN
    ]
    */
    public enum DSP_PAN_MODE_TYPE
    {
        MONO,
        STEREO,
        SURROUND
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter values for the FMOD_DSP_PAN_3D_ROLLOFF parameter of the FMOD_DSP_TYPE_PAN DSP.

        [REMARKS]

        [SEE_ALSO]
        FMOD_DSP_PAN
    ]
    */
    public enum DSP_PAN_3D_ROLLOFF_TYPE
    {
        LINEARSQUARED,
        LINEAR,
        INVERSE,
        INVERSETAPERED,
        CUSTOM
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter values for the FMOD_DSP_PAN_3D_EXTENT_MODE parameter of the FMOD_DSP_TYPE_PAN DSP.

        [REMARKS]

        [SEE_ALSO]
        FMOD_DSP_PAN
    ]
    */
    public enum DSP_PAN_3D_EXTENT_MODE_TYPE
    {
        AUTO,
        USER,
        OFF
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_PAN DSP.

        [REMARKS]

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        DSP::setParameterInt
        DSP::getParameterInt
        DSP::setParameterData
        DSP::getParameterData
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_PAN
    {
        MODE,                           /* (Type:int)   - Panner mode.              FMOD_DSP_PAN_MODE_MONO for mono down-mix, FMOD_DSP_PAN_MODE_STEREO for stereo panning or FMOD_DSP_PAN_MODE_SURROUND for surround panning.  Default = FMOD_DSP_PAN_MODE_SURROUND */
        STEREO_POSITION,                /* (Type:float) - Stereo pan position       STEREO_POSITION_MIN to STEREO_POSITION_MAX.  Default = 0.0. */
        SURROUND_DIRECTION,             /* (Type:float) - Surround pan direction    ROTATION_MIN to ROTATION_MAX.  Default = 0.0. */
        SURROUND_EXTENT,                /* (Type:float) - Surround pan extent       EXTENT_MIN to EXTENT_MAX.  Default = 360.0. */
        SURROUND_ROTATION,              /* (Type:float) - Surround pan rotation     ROTATION_MIN to ROTATION_MAX.  Default = 0.0. */
        SURROUND_LFE_LEVEL,             /* (Type:float) - Surround pan LFE level    SURROUND_LFE_LEVEL_MIN to SURROUND_LFE_LEVEL_MAX.  Default = 0.0. */
        SURROUND_FROM_STEREO_MODE,      /* (Type:int)   - Stereo-To-Surround Mode   FMOD_DSP_PAN_SURROUND_FROM_STEREO_MODE_DISTRIBUTED to FMOD_DSP_PAN_SURROUND_FROM_STEREO_MODE_DISCRETE.  Default = FMOD_DSP_PAN_SURROUND_FROM_STEREO_MODE_DISCRETE. */
        SURROUND_STEREO_SEPARATION,     /* (Type:float) - Stereo-To-Surround Stereo Separation. ROTATION_MIN to ROTATION_MAX.  Default = 60.0. */
        SURROUND_STEREO_AXIS,           /* (Type:float) - Stereo-To-Surround Stereo Axis. ROTATION_MIN to ROTATION_MAX.  Default = 0.0. */
        ENABLED_SURROUND_SPEAKERS,      /* (Type:int)   - Surround Speakers Enabled. 0 to 0xFFF.  Default = 0xFFF.  */
        _3D_POSITION,                   /* (Type:data)  - 3D Position               data of type FMOD_DSP_PARAMETER_DATA_TYPE_3DPOS */
        _3D_ROLLOFF,                    /* (Type:int)   - 3D Rolloff                FMOD_DSP_PAN_3D_ROLLOFF_LINEARSQUARED to FMOD_DSP_PAN_3D_ROLLOFF_CUSTOM.  Default = FMOD_DSP_PAN_3D_ROLLOFF_LINEARSQUARED. */
        _3D_MIN_DISTANCE,               /* (Type:float) - 3D Min Distance           0.0 to GAME_UNITS_MAX.  Default = 1.0. */
        _3D_MAX_DISTANCE,               /* (Type:float) - 3D Max Distance           0.0 to GAME_UNITS_MAX.  Default = 20.0. */
        _3D_EXTENT_MODE,                /* (Type:int)   - 3D Extent Mode            FMOD_DSP_PAN_3D_EXTENT_MODE_AUTO to FMOD_DSP_PAN_3D_EXTENT_MODE_OFF.  Default = FMOD_DSP_PAN_3D_EXTENT_MODE_AUTO. */
        _3D_SOUND_SIZE,                 /* (Type:float) - 3D Sound Size             0.0 to GAME_UNITS_MAX.  Default = 0.0. */
        _3D_MIN_EXTENT,                 /* (Type:float) - 3D Min Extent             EXTENT_MIN to EXTENT_MAX.  Default = 0.0. */
        _3D_PAN_BLEND,                  /* (Type:float) - 3D Pan Blend              PAN_BLEND_MIN to PAN_BLEND_MAX.  Default = 0.0. */
        LFE_UPMIX_ENABLED,              /* (Type:int)   - LFE Upmix Enabled         0 to 1.  Default = 0. */
        OVERALL_GAIN,                   /* (Type:data)  - Overall Gain              data of type FMOD_DSP_PARAMETER_DATA_TYPE_OVERALLGAIN */
        SURROUND_SPEAKER_MODE           /* (Type:int)   - Surround speaker mode.    Target speaker mode for surround panning.  Default = FMOD_SPEAKERMODE_DEFAULT. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter values for the FMOD_DSP_THREE_EQ_CROSSOVERSLOPE parameter of the FMOD_DSP_TYPE_THREE_EQ DSP.

        [REMARKS]

        [SEE_ALSO]
        FMOD_DSP_THREE_EQ
    ]
    */
    public enum DSP_THREE_EQ_CROSSOVERSLOPE_TYPE
    {
        _12DB,
        _24DB,
        _48DB
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_THREE_EQ filter.

        [REMARKS]

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        DSP::setParameterInt
        DSP::getParameterInt
        FMOD_DSP_TYPE
        FMOD_DSP_THREE_EQ_CROSSOVERSLOPE_TYPE
    ]
    */
    public enum DSP_THREE_EQ
    {
        LOWGAIN,       /* (Type:float) - Low frequency gain in dB.  -80.0 to 10.0.  Default = 0. */
        MIDGAIN,       /* (Type:float) - Mid frequency gain in dB.  -80.0 to 10.0.  Default = 0. */
        HIGHGAIN,      /* (Type:float) - High frequency gain in dB.  -80.0 to 10.0.  Default = 0. */
        LOWCROSSOVER,  /* (Type:float) - Low-to-mid crossover frequency in Hz.  10.0 to 22000.0.  Default = 400.0. */
        HIGHCROSSOVER, /* (Type:float) - Mid-to-high crossover frequency in Hz.  10.0 to 22000.0.  Default = 4000.0. */
        CROSSOVERSLOPE /* (Type:int)   - Crossover Slope.  0 = 12dB/Octave, 1 = 24dB/Octave, 2 = 48dB/Octave.  Default = 1 (24dB/Octave). */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        List of windowing methods for the FMOD_DSP_TYPE_FFT unit.  Used in spectrum analysis to reduce leakage / transient signals intefering with the analysis.
        This is a problem with analysis of continuous signals that only have a small portion of the signal sample (the fft window size).
        Windowing the signal with a curve or triangle tapers the sides of the fft window to help alleviate this problem.

        [REMARKS]
        Cyclic signals such as a sine wave that repeat their cycle in a multiple of the window size do not need windowing.
        I.e. If the sine wave repeats every 1024, 512, 256 etc samples and the FMOD fft window is 1024, then the signal would not need windowing.
        Not windowing is the same as FMOD_DSP_FFT_WINDOW_RECT, which is the default.
        If the cycle of the signal (ie the sine wave) is not a multiple of the window size, it will cause frequency abnormalities, so a different windowing method is needed.
        
        FMOD_DSP_FFT_WINDOW_RECT.
        <img src="..\static\overview\rectangle.gif"></img>
        
        FMOD_DSP_FFT_WINDOW_TRIANGLE.
        <img src="..\static\overview\triangle.gif"></img>
        
        FMOD_DSP_FFT_WINDOW_HAMMING.
        <img src="..\static\overview\hamming.gif"></img>
        
        FMOD_DSP_FFT_WINDOW_HANNING.
        <img src="..\static\overview\hanning.gif"></img>
        
        FMOD_DSP_FFT_WINDOW_BLACKMAN.
        <img src="..\static\overview\blackman.gif"></img>
        
        FMOD_DSP_FFT_WINDOW_BLACKMANHARRIS.
        <img src="..\static\overview\blackmanharris.gif"></img>
    
        [SEE_ALSO]
        FMOD_DSP_FFT
    ]
    */
    public enum DSP_FFT_WINDOW
    {
        RECT,            /* w[n] = 1.0                                                                                            */
        TRIANGLE,        /* w[n] = TRI(2n/N)                                                                                      */
        HAMMING,         /* w[n] = 0.54 - (0.46 * COS(n/N) )                                                                      */
        HANNING,         /* w[n] = 0.5 *  (1.0  - COS(n/N) )                                                                      */
        BLACKMAN,        /* w[n] = 0.42 - (0.5  * COS(n/N) ) + (0.08 * COS(2.0 * n/N) )                                           */
        BLACKMANHARRIS   /* w[n] = 0.35875 - (0.48829 * COS(1.0 * n/N)) + (0.14128 * COS(2.0 * n/N)) - (0.01168 * COS(3.0 * n/N)) */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_FFT dsp effect.

        [REMARKS]
        Set the attributes for the spectrum analysis with FMOD_DSP_FFT_WINDOWSIZE and FMOD_DSP_FFT_WINDOWTYPE, and retrieve the results with FMOD_DSP_FFT_SPECTRUM and FMOD_DSP_FFT_DOMINANT_FREQ.
        FMOD_DSP_FFT_SPECTRUM stores its data in the FMOD_DSP_PARAMETER_DATA_TYPE_FFT.  You will need to cast to this structure to get the right data.

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        DSP::setParameterInt
        DSP::getParameterInt
        DSP::setParameterData
        DSP::getParameterData
        FMOD_DSP_TYPE
        FMOD_DSP_FFT_WINDOW
    ]
    */
    public enum DSP_FFT
    {
        WINDOWSIZE,            /*  (Type:int)   - [r/w] Must be a power of 2 between 128 and 16384.  128, 256, 512, 1024, 2048, 4096, 8192, 16384 are accepted.  Default = 2048. */
        WINDOWTYPE,            /*  (Type:int)   - [r/w] Refer to FMOD_DSP_FFT_WINDOW enumeration.  Default = FMOD_DSP_FFT_WINDOW_HAMMING. */
        SPECTRUMDATA,          /*  (Type:data)  - [r]   Returns the current spectrum values between 0 and 1 for each 'fft bin'.  Cast data to FMOD_DSP_PARAMETER_DATA_TYPE_FFT.  Divide the niquist rate by the window size to get the hz value per entry. */
        DOMINANT_FREQ          /*  (Type:float) - [r]   Returns the dominant frequencies for each channel. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_ENVELOPEFOLLOWER unit.
        This is a simple envelope follower for tracking the signal level.

        [REMARKS]
        This unit does not affect the incoming signal
        
        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        DSP::setParameterBool
        DSP::getParameterBool
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_ENVELOPEFOLLOWER
    {
        ATTACK,      /* (Type:float) - Attack time (milliseconds), in the range from 0.1 through 1000. The default value is 20. */
        RELEASE,     /* (Type:float) - Release time (milliseconds), in the range from 10 through 5000. The default value is 100 */
        ENVELOPE,    /* (Type:float) - Current value of the envelope, in the range 0 to 1. Read-only. */
        USESIDECHAIN /* (Type:bool)  - Whether to analyse the sidechain signal instead of the input signal. The default value is false */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_CHORUS filter.

        [REMARKS]
        Convolution Reverb reverb IR.

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        DSP::setParameterData
        DSP::getParameterData
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_CONVOLUTION_REVERB
    {
        IR,       /* (Type:data)  - [w]   16-bit reverb IR (short*) with an extra sample prepended to the start which specifies the number of channels. */
        WET,      /* (Type:float) - [r/w] Volume of echo signal to pass to output in dB.  -80.0 to 10.0.  Default = 0. */
        DRY       /* (Type:float) - [r/w] Original sound volume in dB.  -80.0 to 10.0.  Default = 0. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_CHANNELMIX_OUTPUTGROUPING parameter for FMOD_DSP_TYPE_CHANNELMIX effect.

        [REMARKS]

        [SEE_ALSO]
        DSP::setParameterInt
        DSP::getParameterInt
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_CHANNELMIX_OUTPUT
    {
        DEFAULT,      /*  Output channel count = input channel count.  Mapping: See FMOD_SPEAKER enumeration. */
        ALLMONO,      /*  Output channel count = 1.  Mapping: Mono, Mono, Mono, Mono, Mono, Mono, ... (each channel all the way up to FMOD_MAX_CHANNEL_WIDTH channels are treated as if they were mono) */
        ALLSTEREO,    /*  Output channel count = 2.  Mapping: Left, Right, Left, Right, Left, Right, ... (each pair of channels is treated as stereo all the way up to FMOD_MAX_CHANNEL_WIDTH channels) */
        ALLQUAD,      /*  Output channel count = 4.  Mapping: Repeating pattern of Front Left, Front Right, Surround Left, Surround Right. */
        ALL5POINT1,   /*  Output channel count = 6.  Mapping: Repeating pattern of Front Left, Front Right, Center, LFE, Surround Left, Surround Right. */
        ALL7POINT1,   /*  Output channel count = 8.  Mapping: Repeating pattern of Front Left, Front Right, Center, LFE, Surround Left, Surround Right, Back Left, Back Right.  */
        ALLLFE        /*  Output channel count = 6.  Mapping: Repeating pattern of LFE in a 5.1 output signal.  */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_CHANNELMIX filter.

        [REMARKS]
        For FMOD_DSP_CHANNELMIX_OUTPUTGROUPING, this value will set the output speaker format for the DSP, and also map the incoming channels to the 
        outgoing channels in a round-robin fashion.  Use this for example play a 32 channel input signal as if it were a repeating group of output signals.
        Ie.
        FMOD_DSP_CHANNELMIX_OUTPUT_ALLMONO    = all incoming channels are mixed to a mono output.
        FMOD_DSP_CHANNELMIX_OUTPUT_ALLSTEREO  = all incoming channels are mixed to a stereo output, ie even incoming channels 0,2,4,6,etc are mixed to left, and odd incoming channels 1,3,5,7,etc are mixed to right.
        FMOD_DSP_CHANNELMIX_OUTPUT_ALL5POINT1 = all incoming channels are mixed to a 5.1 output.  If there are less than 6 coming in, it will just fill the first n channels in the 6 output channels.   
                                                 If there are more, then it will repeat the input pattern to the output like it did with the stereo case, ie 12 incoming channels are mapped as 0-5 mixed to the 
                                                 5.1 output and 6 to 11 mapped to the 5.1 output.
        FMOD_DSP_CHANNELMIX_OUTPUT_ALLLFE     = all incoming channels are mixed to a 5.1 output but via the LFE channel only.


        [SEE_ALSO]
        DSP::setParameterInt
        DSP::getParameterInt
        DSP::setParameterFloat
        DSP::getParameterFloat
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_CHANNELMIX
    {
        OUTPUTGROUPING,     /* (Type:int)   - Refer to FMOD_DSP_CHANNELMIX_OUTPUT enumeration.  Default = FMOD_DSP_CHANNELMIX_OUTPUT_DEFAULT.  See remarks. */
        GAIN_CH0,           /* (Type:float) - Channel  #0 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH1,           /* (Type:float) - Channel  #1 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH2,           /* (Type:float) - Channel  #2 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH3,           /* (Type:float) - Channel  #3 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH4,           /* (Type:float) - Channel  #4 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH5,           /* (Type:float) - Channel  #5 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH6,           /* (Type:float) - Channel  #6 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH7,           /* (Type:float) - Channel  #7 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH8,           /* (Type:float) - Channel  #8 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH9,           /* (Type:float) - Channel  #9 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH10,          /* (Type:float) - Channel #10 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH11,          /* (Type:float) - Channel #11 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH12,          /* (Type:float) - Channel #12 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH13,          /* (Type:float) - Channel #13 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH14,          /* (Type:float) - Channel #14 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH15,          /* (Type:float) - Channel #15 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH16,          /* (Type:float) - Channel #16 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH17,          /* (Type:float) - Channel #17 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH18,          /* (Type:float) - Channel #18 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH19,          /* (Type:float) - Channel #19 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH20,          /* (Type:float) - Channel #20 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH21,          /* (Type:float) - Channel #21 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH22,          /* (Type:float) - Channel #22 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH23,          /* (Type:float) - Channel #23 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH24,          /* (Type:float) - Channel #24 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH25,          /* (Type:float) - Channel #25 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH26,          /* (Type:float) - Channel #26 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH27,          /* (Type:float) - Channel #27 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH28,          /* (Type:float) - Channel #28 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH29,          /* (Type:float) - Channel #29 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH30,          /* (Type:float) - Channel #30 gain in dB.  -80.0 to 10.0.  Default = 0. */
        GAIN_CH31           /* (Type:float) - Channel #31 gain in dB.  -80.0 to 10.0.  Default = 0. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TRANSCEIVER_SPEAKERMODE parameter for FMOD_DSP_TYPE_TRANSCEIVER effect.

        [REMARKS]
        The speaker mode of a transceiver buffer (of which there are up to 32 of) is determined automatically depending on the signal flowing through the transceiver effect, or it can be forced.
        Use a smaller fixed speaker mode buffer to save memory.

        Only relevant for transmitter dsps, as they control the format of the transceiver channel's buffer.

        If multiple transceivers transmit to a single buffer in different speaker modes, it will allocate memory for each speaker mode.   This uses more memory than a single speaker mode.
        If there are multiple receivers reading from a channel with multiple speaker modes, it will read them all and mix them together.

        If the system's speaker mode is stereo or mono, it will not create a 3rd buffer, it will just use the mono/stereo speaker mode buffer.

        [SEE_ALSO]
        DSP::setParameterInt
        DSP::getParameterInt
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_TRANSCEIVER_SPEAKERMODE
    {
        AUTO = -1,     /* A transmitter will use whatever signal channel count coming in to the transmitter, to determine which speaker mode is allocated for the transceiver channel. */
        MONO = 0,      /* A transmitter will always downmix to a mono channel buffer. */
        STEREO,        /* A transmitter will always upmix or downmix to a stereo channel buffer. */
        SURROUND,      /* A transmitter will always upmix or downmix to a surround channel buffer.   Surround is the speaker mode of the system above stereo, so could be quad/surround/5.1/7.1. */
    }


    /*
    [ENUM]
    [
        [DESCRIPTION]
        Parameter types for the FMOD_DSP_TYPE_TRANSCEIVER filter.

        [REMARKS]
        The transceiver only transmits and receives to a global array of 32 channels.   The transceiver can be set to receiver mode (like a return) and can receive the signal at a variable gain (FMOD_DSP_TRANSCEIVER_GAIN).
        The transceiver can also be set to transmit to a chnnel (like a send) and can transmit the signal with a variable gain (FMOD_DSP_TRANSCEIVER_GAIN).
    
        The FMOD_DSP_TRANSCEIVER_TRANSMITSPEAKERMODE is only applicable to the transmission format, not the receive format.   This means this parameter is ignored in 'receive mode'.  This allows receivers to receive at
        the speaker mode of the user's choice.   Receiving from a mono channel, is cheaper than receiving from a surround channel for example.
        The 3 speaker modes FMOD_DSP_TRANSCEIVER_SPEAKERMODE_MONO, FMOD_DSP_TRANSCEIVER_SPEAKERMODE_STEREO, FMOD_DSP_TRANSCEIVER_SPEAKERMODE_SURROUND are stored as seperate buffers in memory for a tranmitter channel.
        To save memory, use 1 common speaker mode for a transmitter.

        The transceiver is double buffered to avoid desyncing of transmitters and receivers.   This means there will be a 1 block delay on a receiver, compared to the data sent from a transmitter.

        Multiple transmitters sending to the same channel will be mixed together.

        [SEE_ALSO]
        DSP::setParameterFloat
        DSP::getParameterFloat
        DSP::setParameterInt
        DSP::getParameterInt
        DSP::setParameterBool
        DSP::getParameterBool
        FMOD_DSP_TYPE
    ]
    */
    public enum DSP_TRANSCEIVER
    {
        TRANSMIT,            /* (Type:bool)  - [r/w] - FALSE = Transceiver is a 'receiver' (like a return) and accepts data from a channel.  TRUE = Transceiver is a 'transmitter' (like a send).  Default = FALSE. */
        GAIN,                /* (Type:float) - [r/w] - Gain to receive or transmit at in dB.  -80.0 to 10.0.  Default = 0. */
        CHANNEL,             /* (Type:int)   - [r/w] - Integer to select current global slot, shared by all Transceivers, that can be transmitted to or received from.  0 to 31.  Default = 0.*/
        TRANSMITSPEAKERMODE  /* (Type:int)   - [r/w] - Speaker mode (transmitter mode only).  Specifies either 0 (Auto) Default = 0.*/
    }


/*$ preserve start $*/
}
/*$ preserve end $*/

```

`AssetStudioUtility/FMOD Studio API/fmod_errors.cs`:

```cs
/* =================================================================================================== */
/* FMOD Studio - Error string header file. Copyright (c), Firelight Technologies Pty, Ltd. 2004-2016.  */
/*                                                                                                     */
/* Use this header if you want to store or display a string version / english explanation of           */
/* the FMOD error codes.                                                                               */
/*                                                                                                     */
/* =================================================================================================== */

namespace FMOD
{
    public class Error
    {
        public static string String(FMOD.RESULT errcode)
        {
            switch (errcode)
            {
                case FMOD.RESULT.OK:                            return "No errors.";
                case FMOD.RESULT.ERR_BADCOMMAND:                return "Tried to call a function on a data type that does not allow this type of functionality (ie calling Sound::lock on a streaming sound).";
                case FMOD.RESULT.ERR_CHANNEL_ALLOC:             return "Error trying to allocate a channel.";
                case FMOD.RESULT.ERR_CHANNEL_STOLEN:            return "The specified channel has been reused to play another sound.";
                case FMOD.RESULT.ERR_DMA:                       return "DMA Failure.  See debug output for more information.";
                case FMOD.RESULT.ERR_DSP_CONNECTION:            return "DSP connection error.  Connection possibly caused a cyclic dependency or connected dsps with incompatible buffer counts.";
                case FMOD.RESULT.ERR_DSP_DONTPROCESS:           return "DSP return code from a DSP process query callback.  Tells mixer not to call the process callback and therefore not consume CPU.  Use this to optimize the DSP graph.";
                case FMOD.RESULT.ERR_DSP_FORMAT:                return "DSP Format error.  A DSP unit may have attempted to connect to this network with the wrong format, or a matrix may have been set with the wrong size if the target unit has a specified channel map.";
                case FMOD.RESULT.ERR_DSP_INUSE:                 return "DSP is already in the mixer's DSP network. It must be removed before being reinserted or released.";
                case FMOD.RESULT.ERR_DSP_NOTFOUND:              return "DSP connection error.  Couldn't find the DSP unit specified.";
                case FMOD.RESULT.ERR_DSP_RESERVED:              return "DSP operation error.  Cannot perform operation on this DSP as it is reserved by the system.";
                case FMOD.RESULT.ERR_DSP_SILENCE:               return "DSP return code from a DSP process query callback.  Tells mixer silence would be produced from read, so go idle and not consume CPU.  Use this to optimize the DSP graph.";
                case FMOD.RESULT.ERR_DSP_TYPE:                  return "DSP operation cannot be performed on a DSP of this type.";
                case FMOD.RESULT.ERR_FILE_BAD:                  return "Error loading file.";
                case FMOD.RESULT.ERR_FILE_COULDNOTSEEK:         return "Couldn't perform seek operation.  This is a limitation of the medium (ie netstreams) or the file format.";
                case FMOD.RESULT.ERR_FILE_DISKEJECTED:          return "Media was ejected while reading.";
                case FMOD.RESULT.ERR_FILE_EOF:                  return "End of file unexpectedly reached while trying to read essential data (truncated?).";
                case FMOD.RESULT.ERR_FILE_ENDOFDATA:            return "End of current chunk reached while trying to read data.";
                case FMOD.RESULT.ERR_FILE_NOTFOUND:             return "File not found.";
                case FMOD.RESULT.ERR_FORMAT:                    return "Unsupported file or audio format.";
                case FMOD.RESULT.ERR_HEADER_MISMATCH:           return "There is a version mismatch between the FMOD header and either the FMOD Studio library or the FMOD Low Level library.";
                case FMOD.RESULT.ERR_HTTP:                      return "A HTTP error occurred. This is a catch-all for HTTP errors not listed elsewhere.";
                case FMOD.RESULT.ERR_HTTP_ACCESS:               return "The specified resource requires authentication or is forbidden.";
                case FMOD.RESULT.ERR_HTTP_PROXY_AUTH:           return "Proxy authentication is required to access the specified resource.";
                case FMOD.RESULT.ERR_HTTP_SERVER_ERROR:         return "A HTTP server error occurred.";
                case FMOD.RESULT.ERR_HTTP_TIMEOUT:              return "The HTTP request timed out.";
                case FMOD.RESULT.ERR_INITIALIZATION:            return "FMOD was not initialized correctly to support this function.";
                case FMOD.RESULT.ERR_INITIALIZED:               return "Cannot call this command after System::init.";
                case FMOD.RESULT.ERR_INTERNAL:                  return "An error occurred that wasn't supposed to.  Contact support.";
                case FMOD.RESULT.ERR_INVALID_FLOAT:             return "Value passed in was a NaN, Inf or denormalized float.";
                case FMOD.RESULT.ERR_INVALID_HANDLE:            return "An invalid object handle was used.";
                case FMOD.RESULT.ERR_INVALID_PARAM:             return "An invalid parameter was passed to this function.";
                case FMOD.RESULT.ERR_INVALID_POSITION:          return "An invalid seek position was passed to this function.";
                case FMOD.RESULT.ERR_INVALID_SPEAKER:           return "An invalid speaker was passed to this function based on the current speaker mode.";
                case FMOD.RESULT.ERR_INVALID_SYNCPOINT:         return "The syncpoint did not come from this sound handle.";
                case FMOD.RESULT.ERR_INVALID_THREAD:            return "Tried to call a function on a thread that is not supported.";
                case FMOD.RESULT.ERR_INVALID_VECTOR:            return "The vectors passed in are not unit length, or perpendicular.";
                case FMOD.RESULT.ERR_MAXAUDIBLE:                return "Reached maximum audible playback count for this sound's soundgroup.";
                case FMOD.RESULT.ERR_MEMORY:                    return "Not enough memory or resources.";
                case FMOD.RESULT.ERR_MEMORY_CANTPOINT:          return "Can't use FMOD_OPENMEMORY_POINT on non PCM source data, or non mp3/xma/adpcm data if FMOD_CREATECOMPRESSEDSAMPLE was used.";
                case FMOD.RESULT.ERR_NEEDS3D:                   return "Tried to call a command on a 2d sound when the command was meant for 3d sound.";
                case FMOD.RESULT.ERR_NEEDSHARDWARE:             return "Tried to use a feature that requires hardware support.";
                case FMOD.RESULT.ERR_NET_CONNECT:               return "Couldn't connect to the specified host.";
                case FMOD.RESULT.ERR_NET_SOCKET_ERROR:          return "A socket error occurred.  This is a catch-all for socket-related errors not listed elsewhere.";
                case FMOD.RESULT.ERR_NET_URL:                   return "The specified URL couldn't be resolved.";
                case FMOD.RESULT.ERR_NET_WOULD_BLOCK:           return "Operation on a non-blocking socket could not complete immediately.";
                case FMOD.RESULT.ERR_NOTREADY:                  return "Operation could not be performed because specified sound/DSP connection is not ready.";
                case FMOD.RESULT.ERR_OUTPUT_ALLOCATED:          return "Error initializing output device, but more specifically, the output device is already in use and cannot be reused.";
                case FMOD.RESULT.ERR_OUTPUT_CREATEBUFFER:       return "Error creating hardware sound buffer.";
                case FMOD.RESULT.ERR_OUTPUT_DRIVERCALL:         return "A call to a standard soundcard driver failed, which could possibly mean a bug in the driver or resources were missing or exhausted.";
                case FMOD.RESULT.ERR_OUTPUT_FORMAT:             return "Soundcard does not support the specified format.";
                case FMOD.RESULT.ERR_OUTPUT_INIT:               return "Error initializing output device.";
                case FMOD.RESULT.ERR_OUTPUT_NODRIVERS:          return "The output device has no drivers installed.  If pre-init, FMOD_OUTPUT_NOSOUND is selected as the output mode.  If post-init, the function just fails.";
                case FMOD.RESULT.ERR_PLUGIN:                    return "An unspecified error has been returned from a plugin.";
                case FMOD.RESULT.ERR_PLUGIN_MISSING:            return "A requested output, dsp unit type or codec was not available.";
                case FMOD.RESULT.ERR_PLUGIN_RESOURCE:           return "A resource that the plugin requires cannot be found. (ie the DLS file for MIDI playback)";
                case FMOD.RESULT.ERR_PLUGIN_VERSION:            return "A plugin was built with an unsupported SDK version.";
                case FMOD.RESULT.ERR_RECORD:                    return "An error occurred trying to initialize the recording device.";
                case FMOD.RESULT.ERR_REVERB_CHANNELGROUP:       return "Reverb properties cannot be set on this channel because a parent channelgroup owns the reverb connection.";
                case FMOD.RESULT.ERR_REVERB_INSTANCE:           return "Specified instance in FMOD_REVERB_PROPERTIES couldn't be set. Most likely because it is an invalid instance number or the reverb doesn't exist.";
                case FMOD.RESULT.ERR_SUBSOUNDS:                 return "The error occurred because the sound referenced contains subsounds when it shouldn't have, or it doesn't contain subsounds when it should have.  The operation may also not be able to be performed on a parent sound.";
                case FMOD.RESULT.ERR_SUBSOUND_ALLOCATED:        return "This subsound is already being used by another sound, you cannot have more than one parent to a sound.  Null out the other parent's entry first.";
                case FMOD.RESULT.ERR_SUBSOUND_CANTMOVE:         return "Shared subsounds cannot be replaced or moved from their parent stream, such as when the parent stream is an FSB file.";
                case FMOD.RESULT.ERR_TAGNOTFOUND:               return "The specified tag could not be found or there are no tags.";
                case FMOD.RESULT.ERR_TOOMANYCHANNELS:           return "The sound created exceeds the allowable input channel count.  This can be increased using the 'maxinputchannels' parameter in System::setSoftwareFormat.";
                case FMOD.RESULT.ERR_TRUNCATED:                 return "The retrieved string is too long to fit in the supplied buffer and has been truncated.";
                case FMOD.RESULT.ERR_UNIMPLEMENTED:             return "Something in FMOD hasn't been implemented when it should be! contact support!";
                case FMOD.RESULT.ERR_UNINITIALIZED:             return "This command failed because System::init or System::setDriver was not called.";
                case FMOD.RESULT.ERR_UNSUPPORTED:               return "A command issued was not supported by this object.  Possibly a plugin without certain callbacks specified.";
                case FMOD.RESULT.ERR_VERSION:                   return "The version number of this file format is not supported.";
                case FMOD.RESULT.ERR_EVENT_ALREADY_LOADED:      return "The specified bank has already been loaded.";
                case FMOD.RESULT.ERR_EVENT_LIVEUPDATE_BUSY:     return "The live update connection failed due to the game already being connected.";
                case FMOD.RESULT.ERR_EVENT_LIVEUPDATE_MISMATCH: return "The live update connection failed due to the game data being out of sync with the tool.";
                case FMOD.RESULT.ERR_EVENT_LIVEUPDATE_TIMEOUT:  return "The live update connection timed out.";
                case FMOD.RESULT.ERR_EVENT_NOTFOUND:            return "The requested event, bus or vca could not be found.";
                case FMOD.RESULT.ERR_STUDIO_UNINITIALIZED:      return "The Studio::System object is not yet initialized.";
                case FMOD.RESULT.ERR_STUDIO_NOT_LOADED:         return "The specified resource is not loaded, so it can't be unloaded.";
                case FMOD.RESULT.ERR_INVALID_STRING:            return "An invalid string was passed to this function.";
                case FMOD.RESULT.ERR_ALREADY_LOCKED:            return "The specified resource is already locked.";
                case FMOD.RESULT.ERR_NOT_LOCKED:                return "The specified resource is not locked, so it can't be unlocked.";
				case FMOD.RESULT.ERR_RECORD_DISCONNECTED:       return "The specified recording driver has been disconnected.";
				case FMOD.RESULT.ERR_TOOMANYSAMPLES:            return "The length provided exceed the allowable limit.";
                default:                                        return "Unknown error.";
            }
        }
    }
}

```

`AssetStudioUtility/ImageExtensions.cs`:

```cs
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Formats.Bmp;
using SixLabors.ImageSharp.Formats.Tga;
using SixLabors.ImageSharp.PixelFormats;
using System.IO;
using System.Runtime.InteropServices;

namespace AssetStudio
{
    public static class ImageExtensions
    {
        public static void WriteToStream(this Image image, Stream stream, ImageFormat imageFormat)
        {
            switch (imageFormat)
            {
                case ImageFormat.Jpeg:
                    image.SaveAsJpeg(stream);
                    break;
                case ImageFormat.Png:
                    image.SaveAsPng(stream);
                    break;
                case ImageFormat.Bmp:
                    image.Save(stream, new BmpEncoder
                    {
                        BitsPerPixel = BmpBitsPerPixel.Pixel32,
                        SupportTransparency = true
                    });
                    break;
                case ImageFormat.Tga:
                    image.Save(stream, new TgaEncoder
                    {
                        BitsPerPixel = TgaBitsPerPixel.Pixel32,
                        Compression = TgaCompression.None
                    });
                    break;
            }
        }

        public static MemoryStream ConvertToStream(this Image image, ImageFormat imageFormat)
        {
            var stream = new MemoryStream();
            image.WriteToStream(stream, imageFormat);
            return stream;
        }

        public static byte[] ConvertToBytes<TPixel>(this Image<TPixel> image) where TPixel : unmanaged, IPixel<TPixel>
        {
            if (image.TryGetSinglePixelSpan(out var pixelSpan))
            {
                return MemoryMarshal.AsBytes(pixelSpan).ToArray();
            }
            return null;
        }
    }
}

```

`AssetStudioUtility/ImageFormat.cs`:

```cs
namespace AssetStudio
{
    public enum ImageFormat
    {
        Jpeg,
        Png,
        Bmp,
        Tga
    }
}

```

`AssetStudioUtility/ModelConverter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetStudio
{
    public class ModelConverter : IImported
    {
        public ImportedFrame RootFrame { get; protected set; }
        public List<ImportedMesh> MeshList { get; protected set; } = new List<ImportedMesh>();
        public List<ImportedMaterial> MaterialList { get; protected set; } = new List<ImportedMaterial>();
        public List<ImportedTexture> TextureList { get; protected set; } = new List<ImportedTexture>();
        public List<ImportedKeyframedAnimation> AnimationList { get; protected set; } = new List<ImportedKeyframedAnimation>();
        public List<ImportedMorph> MorphList { get; protected set; } = new List<ImportedMorph>();

        private ImageFormat imageFormat;
        private Avatar avatar;
        private HashSet<AnimationClip> animationClipHashSet = new HashSet<AnimationClip>();
        private Dictionary<AnimationClip, string> boundAnimationPathDic = new Dictionary<AnimationClip, string>();
        private Dictionary<uint, string> bonePathHash = new Dictionary<uint, string>();
        private Dictionary<Texture2D, string> textureNameDictionary = new Dictionary<Texture2D, string>();
        private Dictionary<Transform, ImportedFrame> transformDictionary = new Dictionary<Transform, ImportedFrame>();
        Dictionary<uint, string> morphChannelNames = new Dictionary<uint, string>();

        public ModelConverter(GameObject m_GameObject, ImageFormat imageFormat, AnimationClip[] animationList = null)
        {
            this.imageFormat = imageFormat;
            if (m_GameObject.m_Animator != null)
            {
                InitWithAnimator(m_GameObject.m_Animator);
                if (animationList == null)
                {
                    CollectAnimationClip(m_GameObject.m_Animator);
                }
            }
            else
            {
                InitWithGameObject(m_GameObject);
            }
            if (animationList != null)
            {
                foreach (var animationClip in animationList)
                {
                    animationClipHashSet.Add(animationClip);
                }
            }
            ConvertAnimations();
        }

        public ModelConverter(string rootName, List<GameObject> m_GameObjects, ImageFormat imageFormat, AnimationClip[] animationList = null)
        {
            this.imageFormat = imageFormat;
            RootFrame = CreateFrame(rootName, Vector3.Zero, new Quaternion(0, 0, 0, 0), Vector3.One);
            foreach (var m_GameObject in m_GameObjects)
            {
                if (m_GameObject.m_Animator != null && animationList == null)
                {
                    CollectAnimationClip(m_GameObject.m_Animator);
                }

                var m_Transform = m_GameObject.m_Transform;
                ConvertTransforms(m_Transform, RootFrame);
                CreateBonePathHash(m_Transform);
            }
            foreach (var m_GameObject in m_GameObjects)
            {
                var m_Transform = m_GameObject.m_Transform;
                ConvertMeshRenderer(m_Transform);
            }
            if (animationList != null)
            {
                foreach (var animationClip in animationList)
                {
                    animationClipHashSet.Add(animationClip);
                }
            }
            ConvertAnimations();
        }

        public ModelConverter(Animator m_Animator, ImageFormat imageFormat, AnimationClip[] animationList = null)
        {
            this.imageFormat = imageFormat;
            InitWithAnimator(m_Animator);
            if (animationList == null)
            {
                CollectAnimationClip(m_Animator);
            }
            else
            {
                foreach (var animationClip in animationList)
                {
                    animationClipHashSet.Add(animationClip);
                }
            }
            ConvertAnimations();
        }

        private void InitWithAnimator(Animator m_Animator)
        {
            if (m_Animator.m_Avatar.TryGet(out var m_Avatar))
                avatar = m_Avatar;

            m_Animator.m_GameObject.TryGet(out var m_GameObject);
            InitWithGameObject(m_GameObject, m_Animator.m_HasTransformHierarchy);
        }

        private void InitWithGameObject(GameObject m_GameObject, bool hasTransformHierarchy = true)
        {
            var m_Transform = m_GameObject.m_Transform;
            if (!hasTransformHierarchy)
            {
                ConvertTransforms(m_Transform, null);
                DeoptimizeTransformHierarchy();
            }
            else
            {
                var frameList = new List<ImportedFrame>();
                var tempTransform = m_Transform;
                while (tempTransform.m_Father.TryGet(out var m_Father))
                {
                    frameList.Add(ConvertTransform(m_Father));
                    tempTransform = m_Father;
                }
                if (frameList.Count > 0)
                {
                    RootFrame = frameList[frameList.Count - 1];
                    for (var i = frameList.Count - 2; i >= 0; i--)
                    {
                        var frame = frameList[i];
                        var parent = frameList[i + 1];
                        parent.AddChild(frame);
                    }
                    ConvertTransforms(m_Transform, frameList[0]);
                }
                else
                {
                    ConvertTransforms(m_Transform, null);
                }

                CreateBonePathHash(m_Transform);
            }

            ConvertMeshRenderer(m_Transform);
        }

        private void ConvertMeshRenderer(Transform m_Transform)
        {
            m_Transform.m_GameObject.TryGet(out var m_GameObject);

            if (m_GameObject.m_MeshRenderer != null)
            {
                ConvertMeshRenderer(m_GameObject.m_MeshRenderer);
            }

            if (m_GameObject.m_SkinnedMeshRenderer != null)
            {
                ConvertMeshRenderer(m_GameObject.m_SkinnedMeshRenderer);
            }

            if (m_GameObject.m_Animation != null)
            {
                foreach (var animation in m_GameObject.m_Animation.m_Animations)
                {
                    if (animation.TryGet(out var animationClip))
                    {
                        if (!boundAnimationPathDic.ContainsKey(animationClip))
                        {
                            boundAnimationPathDic.Add(animationClip, GetTransformPath(m_Transform));
                        }
                        animationClipHashSet.Add(animationClip);
                    }
                }
            }

            foreach (var pptr in m_Transform.m_Children)
            {
                if (pptr.TryGet(out var child))
                    ConvertMeshRenderer(child);
            }
        }

        private void CollectAnimationClip(Animator m_Animator)
        {
            if (m_Animator.m_Controller.TryGet(out var m_Controller))
            {
                switch (m_Controller)
                {
                    case AnimatorOverrideController m_AnimatorOverrideController:
                        {
                            if (m_AnimatorOverrideController.m_Controller.TryGet<AnimatorController>(out var m_AnimatorController))
                            {
                                foreach (var pptr in m_AnimatorController.m_AnimationClips)
                                {
                                    if (pptr.TryGet(out var m_AnimationClip))
                                    {
                                        animationClipHashSet.Add(m_AnimationClip);
                                    }
                                }
                            }
                            break;
                        }

                    case AnimatorController m_AnimatorController:
                        {
                            foreach (var pptr in m_AnimatorController.m_AnimationClips)
                            {
                                if (pptr.TryGet(out var m_AnimationClip))
                                {
                                    animationClipHashSet.Add(m_AnimationClip);
                                }
                            }
                            break;
                        }
                }
            }
        }

        private ImportedFrame ConvertTransform(Transform trans)
        {
            var frame = new ImportedFrame(trans.m_Children.Length);
            transformDictionary.Add(trans, frame);
            trans.m_GameObject.TryGet(out var m_GameObject);
            frame.Name = m_GameObject.m_Name;
            SetFrame(frame, trans.m_LocalPosition, trans.m_LocalRotation, trans.m_LocalScale);
            return frame;
        }

        private static ImportedFrame CreateFrame(string name, Vector3 t, Quaternion q, Vector3 s)
        {
            var frame = new ImportedFrame();
            frame.Name = name;
            SetFrame(frame, t, q, s);
            return frame;
        }

        private static void SetFrame(ImportedFrame frame, Vector3 t, Quaternion q, Vector3 s)
        {
            frame.LocalPosition = new Vector3(-t.X, t.Y, t.Z);
            frame.LocalRotation = Fbx.QuaternionToEuler(new Quaternion(q.X, -q.Y, -q.Z, q.W));
            frame.LocalScale = s;
        }

        private void ConvertTransforms(Transform trans, ImportedFrame parent)
        {
            var frame = ConvertTransform(trans);
            if (parent == null)
            {
                RootFrame = frame;
            }
            else
            {
                parent.AddChild(frame);
            }
            foreach (var pptr in trans.m_Children)
            {
                if (pptr.TryGet(out var child))
                    ConvertTransforms(child, frame);
            }
        }

        private void ConvertMeshRenderer(Renderer meshR)
        {
            var mesh = GetMesh(meshR);
            if (mesh == null)
                return;
            var iMesh = new ImportedMesh();
            meshR.m_GameObject.TryGet(out var m_GameObject2);
            iMesh.Path = GetTransformPath(m_GameObject2.m_Transform);
            iMesh.SubmeshList = new List<ImportedSubmesh>();
            var subHashSet = new HashSet<int>();
            var combine = false;
            int firstSubMesh = 0;
            if (meshR.m_StaticBatchInfo?.subMeshCount > 0)
            {
                firstSubMesh = meshR.m_StaticBatchInfo.firstSubMesh;
                var finalSubMesh = meshR.m_StaticBatchInfo.firstSubMesh + meshR.m_StaticBatchInfo.subMeshCount;
                for (int i = meshR.m_StaticBatchInfo.firstSubMesh; i < finalSubMesh; i++)
                {
                    subHashSet.Add(i);
                }
                combine = true;
            }
            else if (meshR.m_SubsetIndices?.Length > 0)
            {
                firstSubMesh = (int)meshR.m_SubsetIndices.Min(x => x);
                foreach (var index in meshR.m_SubsetIndices)
                {
                    subHashSet.Add((int)index);
                }
                combine = true;
            }

            iMesh.hasNormal = mesh.m_Normals?.Length > 0;
            iMesh.hasUV = new bool[8];
            for (int uv = 0; uv < 8; uv++)
            {
                iMesh.hasUV[uv] = mesh.GetUV(uv)?.Length > 0;
            }
            iMesh.hasTangent = mesh.m_Tangents != null && mesh.m_Tangents.Length == mesh.m_VertexCount * 4;
            iMesh.hasColor = mesh.m_Colors?.Length > 0;

            int firstFace = 0;
            for (int i = 0; i < mesh.m_SubMeshes.Length; i++)
            {
                int numFaces = (int)mesh.m_SubMeshes[i].indexCount / 3;
                if (subHashSet.Count > 0 && !subHashSet.Contains(i))
                {
                    firstFace += numFaces;
                    continue;
                }
                var submesh = mesh.m_SubMeshes[i];
                var iSubmesh = new ImportedSubmesh();
                Material mat = null;
                if (i - firstSubMesh < meshR.m_Materials.Length)
                {
                    if (meshR.m_Materials[i - firstSubMesh].TryGet(out var m_Material))
                    {
                        mat = m_Material;
                    }
                }
                ImportedMaterial iMat = ConvertMaterial(mat);
                iSubmesh.Material = iMat.Name;
                iSubmesh.BaseVertex = (int)mesh.m_SubMeshes[i].firstVertex;

                //Face
                iSubmesh.FaceList = new List<ImportedFace>(numFaces);
                var end = firstFace + numFaces;
                for (int f = firstFace; f < end; f++)
                {
                    var face = new ImportedFace();
                    face.VertexIndices = new int[3];
                    face.VertexIndices[0] = (int)(mesh.m_Indices[f * 3 + 2] - submesh.firstVertex);
                    face.VertexIndices[1] = (int)(mesh.m_Indices[f * 3 + 1] - submesh.firstVertex);
                    face.VertexIndices[2] = (int)(mesh.m_Indices[f * 3] - submesh.firstVertex);
                    iSubmesh.FaceList.Add(face);
                }
                firstFace = end;

                iMesh.SubmeshList.Add(iSubmesh);
            }

            // Shared vertex list
            iMesh.VertexList = new List<ImportedVertex>((int)mesh.m_VertexCount);
            for (var j = 0; j < mesh.m_VertexCount; j++)
            {
                var iVertex = new ImportedVertex();
                //Vertices
                int c = 3;
                if (mesh.m_Vertices.Length == mesh.m_VertexCount * 4)
                {
                    c = 4;
                }
                iVertex.Vertex = new Vector3(-mesh.m_Vertices[j * c], mesh.m_Vertices[j * c + 1], mesh.m_Vertices[j * c + 2]);
                //Normals
                if (iMesh.hasNormal)
                {
                    if (mesh.m_Normals.Length == mesh.m_VertexCount * 3)
                    {
                        c = 3;
                    }
                    else if (mesh.m_Normals.Length == mesh.m_VertexCount * 4)
                    {
                        c = 4;
                    }
                    iVertex.Normal = new Vector3(-mesh.m_Normals[j * c], mesh.m_Normals[j * c + 1], mesh.m_Normals[j * c + 2]);
                }
                //UV
                iVertex.UV = new float[8][];
                for (int uv = 0; uv < 8; uv++)
                {
                    if (iMesh.hasUV[uv])
                    {
                        var m_UV = mesh.GetUV(uv);
                        if (m_UV.Length == mesh.m_VertexCount * 2)
                        {
                            c = 2;
                        }
                        else if (m_UV.Length == mesh.m_VertexCount * 3)
                        {
                            c = 3;
                        }
                        iVertex.UV[uv] = new[] { m_UV[j * c], m_UV[j * c + 1] };
                    }
                }
                //Tangent
                if (iMesh.hasTangent)
                {
                    iVertex.Tangent = new Vector4(-mesh.m_Tangents[j * 4], mesh.m_Tangents[j * 4 + 1], mesh.m_Tangents[j * 4 + 2], mesh.m_Tangents[j * 4 + 3]);
                }
                //Colors
                if (iMesh.hasColor)
                {
                    if (mesh.m_Colors.Length == mesh.m_VertexCount * 3)
                    {
                        iVertex.Color = new Color(mesh.m_Colors[j * 3], mesh.m_Colors[j * 3 + 1], mesh.m_Colors[j * 3 + 2], 1.0f);
                    }
                    else
                    {
                        iVertex.Color = new Color(mesh.m_Colors[j * 4], mesh.m_Colors[j * 4 + 1], mesh.m_Colors[j * 4 + 2], mesh.m_Colors[j * 4 + 3]);
                    }
                }
                //BoneInfluence
                if (mesh.m_Skin?.Length > 0)
                {
                    var inf = mesh.m_Skin[j];
                    iVertex.BoneIndices = new int[4];
                    iVertex.Weights = new float[4];
                    for (var k = 0; k < 4; k++)
                    {
                        iVertex.BoneIndices[k] = inf.boneIndex[k];
                        iVertex.Weights[k] = inf.weight[k];
                    }
                }
                iMesh.VertexList.Add(iVertex);
            }

            if (meshR is SkinnedMeshRenderer sMesh)
            {
                //Bone
                /*
                 * 0 - None
                 * 1 - m_Bones
                 * 2 - m_BoneNameHashes
                 */
                var boneType = 0;
                if (sMesh.m_Bones.Length > 0)
                {
                    if (sMesh.m_Bones.Length == mesh.m_BindPose.Length)
                    {
                        var verifiedBoneCount = sMesh.m_Bones.Count(x => x.TryGet(out _));
                        if (verifiedBoneCount > 0)
                        {
                            boneType = 1;
                        }
                        if (verifiedBoneCount != sMesh.m_Bones.Length)
                        {
                            //尝试使用m_BoneNameHashes 4.3 and up
                            if (mesh.m_BindPose.Length > 0 && (mesh.m_BindPose.Length == mesh.m_BoneNameHashes?.Length))
                            {
                                //有效bone数量是否大于SkinnedMeshRenderer
                                var verifiedBoneCount2 = mesh.m_BoneNameHashes.Count(x => FixBonePath(GetPathFromHash(x)) != null);
                                if (verifiedBoneCount2 > verifiedBoneCount)
                                {
                                    boneType = 2;
                                }
                            }
                        }
                    }
                }
                if (boneType == 0)
                {
                    //尝试使用m_BoneNameHashes 4.3 and up
                    if (mesh.m_BindPose.Length > 0 && (mesh.m_BindPose.Length == mesh.m_BoneNameHashes?.Length))
                    {
                        var verifiedBoneCount = mesh.m_BoneNameHashes.Count(x => FixBonePath(GetPathFromHash(x)) != null);
                        if (verifiedBoneCount > 0)
                        {
                            boneType = 2;
                        }
                    }
                }

                if (boneType == 1)
                {
                    var boneCount = sMesh.m_Bones.Length;
                    iMesh.BoneList = new List<ImportedBone>(boneCount);
                    for (int i = 0; i < boneCount; i++)
                    {
                        var bone = new ImportedBone();
                        if (sMesh.m_Bones[i].TryGet(out var m_Transform))
                        {
                            bone.Path = GetTransformPath(m_Transform);
                        }
                        var convert = Matrix4x4.Scale(new Vector3(-1, 1, 1));
                        bone.Matrix = convert * mesh.m_BindPose[i] * convert;
                        iMesh.BoneList.Add(bone);
                    }
                }
                else if (boneType == 2)
                {
                    var boneCount = mesh.m_BindPose.Length;
                    iMesh.BoneList = new List<ImportedBone>(boneCount);
                    for (int i = 0; i < boneCount; i++)
                    {
                        var bone = new ImportedBone();
                        var boneHash = mesh.m_BoneNameHashes[i];
                        var path = GetPathFromHash(boneHash);
                        bone.Path = FixBonePath(path);
                        var convert = Matrix4x4.Scale(new Vector3(-1, 1, 1));
                        bone.Matrix = convert * mesh.m_BindPose[i] * convert;
                        iMesh.BoneList.Add(bone);
                    }
                }

                //Morphs
                if (mesh.m_Shapes?.channels?.Length > 0)
                {
                    var morph = new ImportedMorph();
                    MorphList.Add(morph);
                    morph.Path = iMesh.Path;
                    morph.Channels = new List<ImportedMorphChannel>(mesh.m_Shapes.channels.Length);
                    for (int i = 0; i < mesh.m_Shapes.channels.Length; i++)
                    {
                        var channel = new ImportedMorphChannel();
                        morph.Channels.Add(channel);
                        var shapeChannel = mesh.m_Shapes.channels[i];

                        var blendShapeName = "blendShape." + shapeChannel.name;
                        var crc = new SevenZip.CRC();
                        var bytes = Encoding.UTF8.GetBytes(blendShapeName);
                        crc.Update(bytes, 0, (uint)bytes.Length);
                        morphChannelNames[crc.GetDigest()] = blendShapeName;

                        channel.Name = shapeChannel.name.Split('.').Last();
                        channel.KeyframeList = new List<ImportedMorphKeyframe>(shapeChannel.frameCount);
                        var frameEnd = shapeChannel.frameIndex + shapeChannel.frameCount;
                        for (int frameIdx = shapeChannel.frameIndex; frameIdx < frameEnd; frameIdx++)
                        {
                            var keyframe = new ImportedMorphKeyframe();
                            channel.KeyframeList.Add(keyframe);
                            keyframe.Weight = mesh.m_Shapes.fullWeights[frameIdx];
                            var shape = mesh.m_Shapes.shapes[frameIdx];
                            keyframe.hasNormals = shape.hasNormals;
                            keyframe.hasTangents = shape.hasTangents;
                            keyframe.VertexList = new List<ImportedMorphVertex>((int)shape.vertexCount);
                            var vertexEnd = shape.firstVertex + shape.vertexCount;
                            for (uint j = shape.firstVertex; j < vertexEnd; j++)
                            {
                                var destVertex = new ImportedMorphVertex();
                                keyframe.VertexList.Add(destVertex);
                                var morphVertex = mesh.m_Shapes.vertices[j];
                                destVertex.Index = morphVertex.index;
                                var sourceVertex = iMesh.VertexList[(int)morphVertex.index];
                                destVertex.Vertex = new ImportedVertex();
                                var morphPos = morphVertex.vertex;
                                destVertex.Vertex.Vertex = sourceVertex.Vertex + new Vector3(-morphPos.X, morphPos.Y, morphPos.Z);
                                if (shape.hasNormals)
                                {
                                    var morphNormal = morphVertex.normal;
                                    destVertex.Vertex.Normal = new Vector3(-morphNormal.X, morphNormal.Y, morphNormal.Z);
                                }
                                if (shape.hasTangents)
                                {
                                    var morphTangent = morphVertex.tangent;
                                    destVertex.Vertex.Tangent = new Vector4(-morphTangent.X, morphTangent.Y, morphTangent.Z, 0);
                                }
                            }
                        }
                    }
                }
            }

            //TODO combine mesh
            if (combine)
            {
                meshR.m_GameObject.TryGet(out var m_GameObject);
                var frame = RootFrame.FindChild(m_GameObject.m_Name);
                if (frame != null)
                {
                    frame.LocalPosition = RootFrame.LocalPosition;
                    frame.LocalRotation = RootFrame.LocalRotation;
                    while (frame.Parent != null)
                    {
                        frame = frame.Parent;
                        frame.LocalPosition = RootFrame.LocalPosition;
                        frame.LocalRotation = RootFrame.LocalRotation;
                    }
                }
            }

            MeshList.Add(iMesh);
        }

        private static Mesh GetMesh(Renderer meshR)
        {
            if (meshR is SkinnedMeshRenderer sMesh)
            {
                if (sMesh.m_Mesh.TryGet(out var m_Mesh))
                {
                    return m_Mesh;
                }
            }
            else
            {
                meshR.m_GameObject.TryGet(out var m_GameObject);
                if (m_GameObject.m_MeshFilter != null)
                {
                    if (m_GameObject.m_MeshFilter.m_Mesh.TryGet(out var m_Mesh))
                    {
                        return m_Mesh;
                    }
                }
            }

            return null;
        }

        private string GetTransformPath(Transform transform)
        {
            if (transformDictionary.TryGetValue(transform, out var frame))
            {
                return frame.Path;
            }
            return null;
        }

        private string FixBonePath(AnimationClip m_AnimationClip, string path)
        {
            if (boundAnimationPathDic.TryGetValue(m_AnimationClip, out var basePath))
            {
                path = basePath + "/" + path;
            }
            return FixBonePath(path);
        }

        private string FixBonePath(string path)
        {
            var frame = RootFrame.FindFrameByPath(path);
            return frame?.Path;
        }

        private static string GetTransformPathByFather(Transform transform)
        {
            transform.m_GameObject.TryGet(out var m_GameObject);
            if (transform.m_Father.TryGet(out var father))
            {
                return GetTransformPathByFather(father) + "/" + m_GameObject.m_Name;
            }

            return m_GameObject.m_Name;
        }

        private ImportedMaterial ConvertMaterial(Material mat)
        {
            ImportedMaterial iMat;
            if (mat != null)
            {
                iMat = ImportedHelpers.FindMaterial(mat.m_Name, MaterialList);
                if (iMat != null)
                {
                    return iMat;
                }
                iMat = new ImportedMaterial();
                iMat.Name = mat.m_Name;
                //default values
                iMat.Diffuse = new Color(0.8f, 0.8f, 0.8f, 1);
                iMat.Ambient = new Color(0.2f, 0.2f, 0.2f, 1);
                iMat.Emissive = new Color(0, 0, 0, 1);
                iMat.Specular = new Color(0.2f, 0.2f, 0.2f, 1);
                iMat.Reflection = new Color(0, 0, 0, 1);
                iMat.Shininess = 20f;
                iMat.Transparency = 0f;
                foreach (var col in mat.m_SavedProperties.m_Colors)
                {
                    switch (col.Key)
                    {
                        case "_Color":
                            iMat.Diffuse = col.Value;
                            break;
                        case "_SColor":
                            iMat.Ambient = col.Value;
                            break;
                        case "_EmissionColor":
                            iMat.Emissive = col.Value;
                            break;
                        case "_SpecularColor":
                            iMat.Specular = col.Value;
                            break;
                        case "_ReflectColor":
                            iMat.Reflection = col.Value;
                            break;
                    }
                }

                foreach (var flt in mat.m_SavedProperties.m_Floats)
                {
                    switch (flt.Key)
                    {
                        case "_Shininess":
                            iMat.Shininess = flt.Value;
                            break;
                        case "_Transparency":
                            iMat.Transparency = flt.Value;
                            break;
                    }
                }

                //textures
                iMat.Textures = new List<ImportedMaterialTexture>();
                foreach (var texEnv in mat.m_SavedProperties.m_TexEnvs)
                {
                    if (!texEnv.Value.m_Texture.TryGet<Texture2D>(out var m_Texture2D)) //TODO other Texture
                    {
                        continue;
                    }

                    var texture = new ImportedMaterialTexture();
                    iMat.Textures.Add(texture);

                    int dest = -1;
                    if (texEnv.Key == "_MainTex")
                        dest = 0;
                    else if (texEnv.Key == "_BumpMap")
                        dest = 3;
                    else if (texEnv.Key.Contains("Specular"))
                        dest = 2;
                    else if (texEnv.Key.Contains("Normal"))
                        dest = 1;

                    texture.Dest = dest;

                    var ext = $".{imageFormat.ToString().ToLower()}";
                    if (textureNameDictionary.TryGetValue(m_Texture2D, out var textureName))
                    {
                        texture.Name = textureName;
                    }
                    else if (ImportedHelpers.FindTexture(m_Texture2D.m_Name + ext, TextureList) != null) //已有相同名字的图片
                    {
                        for (int i = 1; ; i++)
                        {
                            var name = m_Texture2D.m_Name + $" ({i}){ext}";
                            if (ImportedHelpers.FindTexture(name, TextureList) == null)
                            {
                                texture.Name = name;
                                textureNameDictionary.Add(m_Texture2D, name);
                                break;
                            }
                        }
                    }
                    else
                    {
                        texture.Name = m_Texture2D.m_Name + ext;
                        textureNameDictionary.Add(m_Texture2D, texture.Name);
                    }

                    texture.Offset = texEnv.Value.m_Offset;
                    texture.Scale = texEnv.Value.m_Scale;
                    ConvertTexture2D(m_Texture2D, texture.Name);
                }

                MaterialList.Add(iMat);
            }
            else
            {
                iMat = new ImportedMaterial();
            }
            return iMat;
        }

        private void ConvertTexture2D(Texture2D m_Texture2D, string name)
        {
            var iTex = ImportedHelpers.FindTexture(name, TextureList);
            if (iTex != null)
            {
                return;
            }

            var stream = m_Texture2D.ConvertToStream(imageFormat, true);
            if (stream != null)
            {
                using (stream)
                {
                    iTex = new ImportedTexture(stream, name);
                    TextureList.Add(iTex);
                }
            }
        }

        private void ConvertAnimations()
        {
            foreach (var animationClip in animationClipHashSet)
            {
                var iAnim = new ImportedKeyframedAnimation();
                var name = animationClip.m_Name;
                if (AnimationList.Exists(x => x.Name == name))
                {
                    for (int i = 1; ; i++)
                    {
                        var fixName = name + $"_{i}";
                        if (!AnimationList.Exists(x => x.Name == fixName))
                        {
                            name = fixName;
                            break;
                        }
                    }
                }
                iAnim.Name = name;
                iAnim.SampleRate = animationClip.m_SampleRate;
                iAnim.TrackList = new List<ImportedAnimationKeyframedTrack>();
                AnimationList.Add(iAnim);
                if (animationClip.m_Legacy)
                {
                    foreach (var m_CompressedRotationCurve in animationClip.m_CompressedRotationCurves)
                    {
                        var track = iAnim.FindTrack(FixBonePath(animationClip, m_CompressedRotationCurve.m_Path));

                        var numKeys = m_CompressedRotationCurve.m_Times.m_NumItems;
                        var data = m_CompressedRotationCurve.m_Times.UnpackInts();
                        var times = new float[numKeys];
                        int t = 0;
                        for (int i = 0; i < numKeys; i++)
                        {
                            t += data[i];
                            times[i] = t * 0.01f;
                        }
                        var quats = m_CompressedRotationCurve.m_Values.UnpackQuats();

                        for (int i = 0; i < numKeys; i++)
                        {
                            var quat = quats[i];
                            var value = Fbx.QuaternionToEuler(new Quaternion(quat.X, -quat.Y, -quat.Z, quat.W));
                            track.Rotations.Add(new ImportedKeyframe<Vector3>(times[i], value));
                        }
                    }
                    foreach (var m_RotationCurve in animationClip.m_RotationCurves)
                    {
                        var track = iAnim.FindTrack(FixBonePath(animationClip, m_RotationCurve.path));
                        foreach (var m_Curve in m_RotationCurve.curve.m_Curve)
                        {
                            var value = Fbx.QuaternionToEuler(new Quaternion(m_Curve.value.X, -m_Curve.value.Y, -m_Curve.value.Z, m_Curve.value.W));
                            track.Rotations.Add(new ImportedKeyframe<Vector3>(m_Curve.time, value));
                        }
                    }
                    foreach (var m_PositionCurve in animationClip.m_PositionCurves)
                    {
                        var track = iAnim.FindTrack(FixBonePath(animationClip, m_PositionCurve.path));
                        foreach (var m_Curve in m_PositionCurve.curve.m_Curve)
                        {
                            track.Translations.Add(new ImportedKeyframe<Vector3>(m_Curve.time, new Vector3(-m_Curve.value.X, m_Curve.value.Y, m_Curve.value.Z)));
                        }
                    }
                    foreach (var m_ScaleCurve in animationClip.m_ScaleCurves)
                    {
                        var track = iAnim.FindTrack(FixBonePath(animationClip, m_ScaleCurve.path));
                        foreach (var m_Curve in m_ScaleCurve.curve.m_Curve)
                        {
                            track.Scalings.Add(new ImportedKeyframe<Vector3>(m_Curve.time, new Vector3(m_Curve.value.X, m_Curve.value.Y, m_Curve.value.Z)));
                        }
                    }
                    if (animationClip.m_EulerCurves != null)
                    {
                        foreach (var m_EulerCurve in animationClip.m_EulerCurves)
                        {
                            var track = iAnim.FindTrack(FixBonePath(animationClip, m_EulerCurve.path));
                            foreach (var m_Curve in m_EulerCurve.curve.m_Curve)
                            {
                                track.Rotations.Add(new ImportedKeyframe<Vector3>(m_Curve.time, new Vector3(m_Curve.value.X, -m_Curve.value.Y, -m_Curve.value.Z)));
                            }
                        }
                    }
                    foreach (var m_FloatCurve in animationClip.m_FloatCurves)
                    {
                        if (m_FloatCurve.classID == ClassIDType.SkinnedMeshRenderer) //BlendShape
                        {
                            var channelName = m_FloatCurve.attribute;
                            int dotPos = channelName.IndexOf('.');
                            if (dotPos >= 0)
                            {
                                channelName = channelName.Substring(dotPos + 1);
                            }

                            var path = FixBonePath(animationClip, m_FloatCurve.path);
                            if (string.IsNullOrEmpty(path))
                            {
                                path = GetPathByChannelName(channelName);
                            }
                            var track = iAnim.FindTrack(path);
                            track.BlendShape = new ImportedBlendShape();
                            track.BlendShape.ChannelName = channelName;
                            foreach (var m_Curve in m_FloatCurve.curve.m_Curve)
                            {
                                track.BlendShape.Keyframes.Add(new ImportedKeyframe<float>(m_Curve.time, m_Curve.value));
                            }
                        }
                    }
                }
                else
                {
                    var m_Clip = animationClip.m_MuscleClip.m_Clip;
                    var streamedFrames = m_Clip.m_StreamedClip.ReadData();
                    var m_ClipBindingConstant = animationClip.m_ClipBindingConstant ?? m_Clip.ConvertValueArrayToGenericBinding();
                    for (int frameIndex = 1; frameIndex < streamedFrames.Count - 1; frameIndex++)
                    {
                        var frame = streamedFrames[frameIndex];
                        var streamedValues = frame.keyList.Select(x => x.value).ToArray();
                        for (int curveIndex = 0; curveIndex < frame.keyList.Length;)
                        {
                            ReadCurveData(iAnim, m_ClipBindingConstant, frame.keyList[curveIndex].index, frame.time, streamedValues, 0, ref curveIndex);
                        }
                    }
                    var m_DenseClip = m_Clip.m_DenseClip;
                    var streamCount = m_Clip.m_StreamedClip.curveCount;
                    for (int frameIndex = 0; frameIndex < m_DenseClip.m_FrameCount; frameIndex++)
                    {
                        var time = m_DenseClip.m_BeginTime + frameIndex / m_DenseClip.m_SampleRate;
                        var frameOffset = frameIndex * m_DenseClip.m_CurveCount;
                        for (int curveIndex = 0; curveIndex < m_DenseClip.m_CurveCount;)
                        {
                            var index = streamCount + curveIndex;
                            ReadCurveData(iAnim, m_ClipBindingConstant, (int)index, time, m_DenseClip.m_SampleArray, (int)frameOffset, ref curveIndex);
                        }
                    }
                    if (m_Clip.m_ConstantClip != null)
                    {
                        var m_ConstantClip = m_Clip.m_ConstantClip;
                        var denseCount = m_Clip.m_DenseClip.m_CurveCount;
                        var time2 = 0.0f;
                        for (int i = 0; i < 2; i++)
                        {
                            for (int curveIndex = 0; curveIndex < m_ConstantClip.data.Length;)
                            {
                                var index = streamCount + denseCount + curveIndex;
                                ReadCurveData(iAnim, m_ClipBindingConstant, (int)index, time2, m_ConstantClip.data, 0, ref curveIndex);
                            }
                            time2 = animationClip.m_MuscleClip.m_StopTime;
                        }
                    }
                }
            }
        }

        private void ReadCurveData(ImportedKeyframedAnimation iAnim, AnimationClipBindingConstant m_ClipBindingConstant, int index, float time, float[] data, int offset, ref int curveIndex)
        {
            var binding = m_ClipBindingConstant.FindBinding(index);
            if (binding.typeID == ClassIDType.SkinnedMeshRenderer) //BlendShape
            {
                var channelName = GetChannelNameFromHash(binding.attribute);
                if (string.IsNullOrEmpty(channelName))
                {
                    curveIndex++;
                    return;
                }
                int dotPos = channelName.IndexOf('.');
                if (dotPos >= 0)
                {
                    channelName = channelName.Substring(dotPos + 1);
                }

                var bPath = FixBonePath(GetPathFromHash(binding.path));
                if (string.IsNullOrEmpty(bPath))
                {
                    bPath = GetPathByChannelName(channelName);
                }
                var bTrack = iAnim.FindTrack(bPath);
                bTrack.BlendShape = new ImportedBlendShape();
                bTrack.BlendShape.ChannelName = channelName;
                bTrack.BlendShape.Keyframes.Add(new ImportedKeyframe<float>(time, data[curveIndex++ + offset]));
            }
            else if (binding.typeID == ClassIDType.Transform)
            {
                var path = FixBonePath(GetPathFromHash(binding.path));
                var track = iAnim.FindTrack(path);

                switch (binding.attribute)
                {
                    case 1:
                        track.Translations.Add(new ImportedKeyframe<Vector3>(time, new Vector3
                        (
                            -data[curveIndex++ + offset],
                            data[curveIndex++ + offset],
                            data[curveIndex++ + offset]
                        )));
                        break;
                    case 2:
                        var value = Fbx.QuaternionToEuler(new Quaternion
                        (
                            data[curveIndex++ + offset],
                            -data[curveIndex++ + offset],
                            -data[curveIndex++ + offset],
                            data[curveIndex++ + offset]
                        ));
                        track.Rotations.Add(new ImportedKeyframe<Vector3>(time, value));
                        break;
                    case 3:
                        track.Scalings.Add(new ImportedKeyframe<Vector3>(time, new Vector3
                        (
                            data[curveIndex++ + offset],
                            data[curveIndex++ + offset],
                            data[curveIndex++ + offset]
                        )));
                        break;
                    case 4:
                        track.Rotations.Add(new ImportedKeyframe<Vector3>(time, new Vector3
                        (
                            data[curveIndex++ + offset],
                            -data[curveIndex++ + offset],
                            -data[curveIndex++ + offset]
                        )));
                        break;
                    default:
                        curveIndex++;
                        break;
                }
            }
            else
            {
                curveIndex++;
            }
        }

        private string GetPathFromHash(uint hash)
        {
            bonePathHash.TryGetValue(hash, out var boneName);
            if (string.IsNullOrEmpty(boneName))
            {
                boneName = avatar?.FindBonePath(hash);
            }
            if (string.IsNullOrEmpty(boneName))
            {
                boneName = "unknown " + hash;
            }
            return boneName;
        }

        private void CreateBonePathHash(Transform m_Transform)
        {
            var name = GetTransformPathByFather(m_Transform);
            var crc = new SevenZip.CRC();
            var bytes = Encoding.UTF8.GetBytes(name);
            crc.Update(bytes, 0, (uint)bytes.Length);
            bonePathHash[crc.GetDigest()] = name;
            int index;
            while ((index = name.IndexOf("/", StringComparison.Ordinal)) >= 0)
            {
                name = name.Substring(index + 1);
                crc = new SevenZip.CRC();
                bytes = Encoding.UTF8.GetBytes(name);
                crc.Update(bytes, 0, (uint)bytes.Length);
                bonePathHash[crc.GetDigest()] = name;
            }
            foreach (var pptr in m_Transform.m_Children)
            {
                if (pptr.TryGet(out var child))
                    CreateBonePathHash(child);
            }
        }

        private void DeoptimizeTransformHierarchy()
        {
            if (avatar == null)
                throw new Exception("Transform hierarchy has been optimized, but can't find Avatar to deoptimize.");
            // 1. Figure out the skeletonPaths from the unstripped avatar
            var skeletonPaths = new List<string>();
            foreach (var id in avatar.m_Avatar.m_AvatarSkeleton.m_ID)
            {
                var path = avatar.FindBonePath(id);
                skeletonPaths.Add(path);
            }
            // 2. Restore the original transform hierarchy
            // Prerequisite: skeletonPaths follow pre-order traversal
            for (var i = 1; i < skeletonPaths.Count; i++) // start from 1, skip the root transform because it will always be there.
            {
                var path = skeletonPaths[i];
                var strs = path.Split('/');
                string transformName;
                ImportedFrame parentFrame;
                if (strs.Length == 1)
                {
                    transformName = path;
                    parentFrame = RootFrame;
                }
                else
                {
                    transformName = strs.Last();
                    var parentFramePath = path.Substring(0, path.LastIndexOf('/'));
                    parentFrame = RootFrame.FindRelativeFrameWithPath(parentFramePath);
                }
                var skeletonPose = avatar.m_Avatar.m_DefaultPose;
                var xform = skeletonPose.m_X[i];
                var frame = RootFrame.FindChild(transformName);
                if (frame != null)
                {
                    SetFrame(frame, xform.t, xform.q, xform.s);
                }
                else
                {
                    frame = CreateFrame(transformName, xform.t, xform.q, xform.s);
                }
                parentFrame.AddChild(frame);
            }
        }

        private string GetPathByChannelName(string channelName)
        {
            foreach (var morph in MorphList)
            {
                foreach (var channel in morph.Channels)
                {
                    if (channel.Name == channelName)
                    {
                        return morph.Path;
                    }
                }
            }
            return null;
        }

        private string GetChannelNameFromHash(uint attribute)
        {
            if (morphChannelNames.TryGetValue(attribute, out var name))
            {
                return name;
            }
            else
            {
                return null;
            }
        }
    }
}

```

`AssetStudioUtility/ModelExporter.cs`:

```cs
namespace AssetStudio
{
    public static class ModelExporter
    {
        public static void ExportFbx(string path, IImported imported, bool eulerFilter, float filterPrecision,
            bool allNodes, bool skins, bool animation, bool blendShape, bool castToBone, float boneSize, bool exportAllUvsAsDiffuseMaps, float scaleFactor, int versionIndex, bool isAscii)
        {
            Fbx.Exporter.Export(path, imported, eulerFilter, filterPrecision, allNodes, skins, animation, blendShape, castToBone, boneSize, exportAllUvsAsDiffuseMaps, scaleFactor, versionIndex, isAscii);
        }
    }
}

```

`AssetStudioUtility/MonoBehaviourConverter.cs`:

```cs
using System.Collections.Generic;

namespace AssetStudio
{
    public static class MonoBehaviourConverter
    {
        public static TypeTree ConvertToTypeTree(this MonoBehaviour m_MonoBehaviour, AssemblyLoader assemblyLoader)
        {
            var m_Type = new TypeTree();
            m_Type.m_Nodes = new List<TypeTreeNode>();
            var helper = new SerializedTypeHelper(m_MonoBehaviour.version);
            helper.AddMonoBehaviour(m_Type.m_Nodes, 0);
            if (m_MonoBehaviour.m_Script.TryGet(out var m_Script))
            {
                var typeDef = assemblyLoader.GetTypeDefinition(m_Script.m_AssemblyName, string.IsNullOrEmpty(m_Script.m_Namespace) ? m_Script.m_ClassName : $"{m_Script.m_Namespace}.{m_Script.m_ClassName}");
                if (typeDef != null)
                {
                    var typeDefinitionConverter = new TypeDefinitionConverter(typeDef, helper, 1);
                    m_Type.m_Nodes.AddRange(typeDefinitionConverter.ConvertToTypeTreeNodes());
                }
            }
            return m_Type;
        }
    }
}

```

`AssetStudioUtility/MyAssemblyResolver.cs`:

```cs
using Mono.Cecil;

namespace AssetStudio
{
    public class MyAssemblyResolver : DefaultAssemblyResolver
    {
        public void Register(AssemblyDefinition assembly)
        {
            RegisterAssembly(assembly);
        }
    }
}

```

`AssetStudioUtility/SerializedTypeHelper.cs`:

```cs
using System.Collections.Generic;

namespace AssetStudio
{
    public class SerializedTypeHelper
    {
        private readonly int[] version;

        public SerializedTypeHelper(int[] version)
        {
            this.version = version;
        }

        public void AddMonoBehaviour(List<TypeTreeNode> nodes, int indent)
        {
            nodes.Add(new TypeTreeNode("MonoBehaviour", "Base", indent, false));
            AddPPtr(nodes, "GameObject", "m_GameObject", indent + 1);
            nodes.Add(new TypeTreeNode("UInt8", "m_Enabled", indent + 1, true));
            AddPPtr(nodes, "MonoScript", "m_Script", indent + 1);
            AddString(nodes, "m_Name", indent + 1);
        }

        public void AddPPtr(List<TypeTreeNode> nodes, string type, string name, int indent)
        {
            nodes.Add(new TypeTreeNode($"PPtr<{type}>", name, indent, false));
            nodes.Add(new TypeTreeNode("int", "m_FileID", indent + 1, false));
            if (version[0] >= 5) //5.0 and up
            {
                nodes.Add(new TypeTreeNode("SInt64", "m_PathID", indent + 1, false));
            }
            else
            {
                nodes.Add(new TypeTreeNode("int", "m_PathID", indent + 1, false));
            }
        }

        public void AddString(List<TypeTreeNode> nodes, string name, int indent)
        {
            nodes.Add(new TypeTreeNode("string", name, indent, false));
            nodes.Add(new TypeTreeNode("Array", "Array", indent + 1, true));
            nodes.Add(new TypeTreeNode("int", "size", indent + 2, false));
            nodes.Add(new TypeTreeNode("char", "data", indent + 2, false));
        }

        public void AddArray(List<TypeTreeNode> nodes, int indent)
        {
            nodes.Add(new TypeTreeNode("Array", "Array", indent, false));
            nodes.Add(new TypeTreeNode("int", "size", indent + 1, false));
        }

        public void AddAnimationCurve(List<TypeTreeNode> nodes, string name, int indent)
        {
            nodes.Add(new TypeTreeNode("AnimationCurve", name, indent, false));
            nodes.Add(new TypeTreeNode("vector", "m_Curve", indent + 1, false));
            AddArray(nodes, indent + 2); //TODO 2017 and up Array align but no effect 
            nodes.Add(new TypeTreeNode("Keyframe", "data", indent + 3, false));
            nodes.Add(new TypeTreeNode("float", "time", indent + 4, false));
            nodes.Add(new TypeTreeNode("float", "value", indent + 4, false));
            nodes.Add(new TypeTreeNode("float", "inSlope", indent + 4, false));
            nodes.Add(new TypeTreeNode("float", "outSlope", indent + 4, false));
            if (version[0] >= 2018) //2018 and up
            {
                nodes.Add(new TypeTreeNode("int", "weightedMode", indent + 4, false));
                nodes.Add(new TypeTreeNode("float", "inWeight", indent + 4, false));
                nodes.Add(new TypeTreeNode("float", "outWeight", indent + 4, false));
            }
            nodes.Add(new TypeTreeNode("int", "m_PreInfinity", indent + 1, false));
            nodes.Add(new TypeTreeNode("int", "m_PostInfinity", indent + 1, false));
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 3)) //5.3 and up
            {
                nodes.Add(new TypeTreeNode("int", "m_RotationOrder", indent + 1, false));
            }
        }

        public void AddGradient(List<TypeTreeNode> nodes, string name, int indent)
        {
            nodes.Add(new TypeTreeNode("Gradient", name, indent, false));
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 6)) //5.6 and up
            {
                AddColorRGBA(nodes, "key0", indent + 1);
                AddColorRGBA(nodes, "key1", indent + 1);
                AddColorRGBA(nodes, "key2", indent + 1);
                AddColorRGBA(nodes, "key3", indent + 1);
                AddColorRGBA(nodes, "key4", indent + 1);
                AddColorRGBA(nodes, "key5", indent + 1);
                AddColorRGBA(nodes, "key6", indent + 1);
                AddColorRGBA(nodes, "key7", indent + 1);
            }
            else
            {
                AddColor32(nodes, "key0", indent + 1);
                AddColor32(nodes, "key1", indent + 1);
                AddColor32(nodes, "key2", indent + 1);
                AddColor32(nodes, "key3", indent + 1);
                AddColor32(nodes, "key4", indent + 1);
                AddColor32(nodes, "key5", indent + 1);
                AddColor32(nodes, "key6", indent + 1);
                AddColor32(nodes, "key7", indent + 1);
            }
            nodes.Add(new TypeTreeNode("UInt16", "ctime0", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "ctime1", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "ctime2", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "ctime3", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "ctime4", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "ctime5", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "ctime6", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "ctime7", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "atime0", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "atime1", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "atime2", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "atime3", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "atime4", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "atime5", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "atime6", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt16", "atime7", indent + 1, false));
            if (version[0] > 5 || (version[0] == 5 && version[1] >= 5)) //5.5 and up
            {
                nodes.Add(new TypeTreeNode("int", "m_Mode", indent + 1, false));
            }
            nodes.Add(new TypeTreeNode("UInt8", "m_NumColorKeys", indent + 1, false));
            nodes.Add(new TypeTreeNode("UInt8", "m_NumAlphaKeys", indent + 1, true));
        }

        public void AddGUIStyle(List<TypeTreeNode> nodes, string name, int indent)
        {
            nodes.Add(new TypeTreeNode("GUIStyle", name, indent, false));
            AddString(nodes, "m_Name", indent + 1);
            AddGUIStyleState(nodes, "m_Normal", indent + 1);
            AddGUIStyleState(nodes, "m_Hover", indent + 1);
            AddGUIStyleState(nodes, "m_Active", indent + 1);
            AddGUIStyleState(nodes, "m_Focused", indent + 1);
            AddGUIStyleState(nodes, "m_OnNormal", indent + 1);
            AddGUIStyleState(nodes, "m_OnHover", indent + 1);
            AddGUIStyleState(nodes, "m_OnActive", indent + 1);
            AddGUIStyleState(nodes, "m_OnFocused", indent + 1);
            AddRectOffset(nodes, "m_Border", indent + 1);
            if (version[0] >= 4) //4 and up
            {
                AddRectOffset(nodes, "m_Margin", indent + 1);
                AddRectOffset(nodes, "m_Padding", indent + 1);
            }
            else
            {
                AddRectOffset(nodes, "m_Padding", indent + 1);
                AddRectOffset(nodes, "m_Margin", indent + 1);
            }
            AddRectOffset(nodes, "m_Overflow", indent + 1);
            AddPPtr(nodes, "Font", "m_Font", indent + 1);
            if (version[0] >= 4) //4 and up
            {
                nodes.Add(new TypeTreeNode("int", "m_FontSize", indent + 1, false));
                nodes.Add(new TypeTreeNode("int", "m_FontStyle", indent + 1, false));
                nodes.Add(new TypeTreeNode("int", "m_Alignment", indent + 1, false));
                nodes.Add(new TypeTreeNode("bool", "m_WordWrap", indent + 1, false));
                nodes.Add(new TypeTreeNode("bool", "m_RichText", indent + 1, true));
                nodes.Add(new TypeTreeNode("int", "m_TextClipping", indent + 1, false));
                nodes.Add(new TypeTreeNode("int", "m_ImagePosition", indent + 1, false));
                AddVector2f(nodes, "m_ContentOffset", indent + 1);
                nodes.Add(new TypeTreeNode("float", "m_FixedWidth", indent + 1, false));
                nodes.Add(new TypeTreeNode("float", "m_FixedHeight", indent + 1, false));
                nodes.Add(new TypeTreeNode("bool", "m_StretchWidth", indent + 1, false));
                nodes.Add(new TypeTreeNode("bool", "m_StretchHeight", indent + 1, true));
            }
            else
            {
                nodes.Add(new TypeTreeNode("int", "m_ImagePosition", indent + 1, false));
                nodes.Add(new TypeTreeNode("int", "m_Alignment", indent + 1, false));
                nodes.Add(new TypeTreeNode("bool", "m_WordWrap", indent + 1, true));
                nodes.Add(new TypeTreeNode("int", "m_TextClipping", indent + 1, false));
                AddVector2f(nodes, "m_ContentOffset", indent + 1);
                AddVector2f(nodes, "m_ClipOffset", indent + 1);
                nodes.Add(new TypeTreeNode("float", "m_FixedWidth", indent + 1, false));
                nodes.Add(new TypeTreeNode("float", "m_FixedHeight", indent + 1, false));
                if (version[0] >= 3) //3 and up
                {
                    nodes.Add(new TypeTreeNode("int", "m_FontSize", indent + 1, false));
                    nodes.Add(new TypeTreeNode("int", "m_FontStyle", indent + 1, false));
                }
                nodes.Add(new TypeTreeNode("bool", "m_StretchWidth", indent + 1, true));
                nodes.Add(new TypeTreeNode("bool", "m_StretchHeight", indent + 1, true));
            }
        }

        public void AddGUIStyleState(List<TypeTreeNode> nodes, string name, int indent)
        {
            nodes.Add(new TypeTreeNode("GUIStyleState", name, indent, false));
            AddPPtr(nodes, "Texture2D", "m_Background", indent + 1);
            AddColorRGBA(nodes, "m_TextColor", indent + 1);
        }

        public void AddVector2f(List<TypeTreeNode> nodes, string name, int indent)
        {
            nodes.Add(new TypeTreeNode("Vector2f", name, indent, false));
            nodes.Add(new TypeTreeNode("float", "x", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "y", indent + 1, false));
        }

        public void AddRectOffset(List<TypeTreeNode> nodes, string name, int indent)
        {
            nodes.Add(new TypeTreeNode("RectOffset", name, indent, false));
            nodes.Add(new TypeTreeNode("int", "m_Left", indent + 1, false));
            nodes.Add(new TypeTreeNode("int", "m_Right", indent + 1, false));
            nodes.Add(new TypeTreeNode("int", "m_Top", indent + 1, false));
            nodes.Add(new TypeTreeNode("int", "m_Bottom", indent + 1, false));
        }

        public void AddColorRGBA(List<TypeTreeNode> nodes, string name, int indent)
        {
            nodes.Add(new TypeTreeNode("ColorRGBA", name, indent, false));
            nodes.Add(new TypeTreeNode("float", "r", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "g", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "b", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "a", indent + 1, false));
        }

        public void AddColor32(List<TypeTreeNode> nodes, string name, int indent)
        {
            nodes.Add(new TypeTreeNode("ColorRGBA", name, indent, false));
            nodes.Add(new TypeTreeNode("unsigned int", "rgba", indent + 1, false));
        }

        public void AddMatrix4x4(List<TypeTreeNode> nodes, string name, int indent)
        {
            nodes.Add(new TypeTreeNode("Matrix4x4f", name, indent, false));
            nodes.Add(new TypeTreeNode("float", "e00", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e01", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e02", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e03", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e10", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e11", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e12", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e13", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e20", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e21", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e22", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e23", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e30", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e31", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e32", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "e33", indent + 1, false));
        }

        public void AddSphericalHarmonicsL2(List<TypeTreeNode> nodes, string name, int indent)
        {
            nodes.Add(new TypeTreeNode("SphericalHarmonicsL2", name, indent, false));
            nodes.Add(new TypeTreeNode("float", "sh[ 0]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[ 1]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[ 2]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[ 3]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[ 4]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[ 5]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[ 6]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[ 7]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[ 8]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[ 9]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[10]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[11]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[12]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[13]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[14]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[15]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[16]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[17]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[18]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[19]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[20]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[21]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[22]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[23]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[24]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[25]", indent + 1, false));
            nodes.Add(new TypeTreeNode("float", "sh[26]", indent + 1, false));
        }

        public void AddPropertyName(List<TypeTreeNode> nodes, string name, int indent)
        {
            nodes.Add(new TypeTreeNode("PropertyName", name, indent, false));
            AddString(nodes, "id", indent + 1);
        }
    }
}

```

`AssetStudioUtility/ShaderConverter.cs`:

```cs
using K4os.Compression.LZ4;
using System;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace AssetStudio
{
    public static class ShaderConverter
    {
        public static string Convert(this Shader shader)
        {
            if (shader.m_SubProgramBlob != null) //5.3 - 5.4
            {
                var decompressedBytes = new byte[shader.decompressedSize];
                LZ4Codec.Decode(shader.m_SubProgramBlob, decompressedBytes);
                using (var blobReader = new BinaryReader(new MemoryStream(decompressedBytes)))
                {
                    var program = new ShaderProgram(blobReader, shader.version);
                    program.Read(blobReader, 0);
                    return header + program.Export(Encoding.UTF8.GetString(shader.m_Script));
                }
            }

            if (shader.compressedBlob != null) //5.5 and up
            {
                return header + ConvertSerializedShader(shader);
            }

            return header + Encoding.UTF8.GetString(shader.m_Script);
        }

        private static string ConvertSerializedShader(Shader shader)
        {
            var length = shader.platforms.Length;
            var shaderPrograms = new ShaderProgram[length];
            for (var i = 0; i < length; i++)
            {
                for (var j = 0; j < shader.offsets[i].Length; j++)
                {
                    var offset = shader.offsets[i][j];
                    var compressedLength = shader.compressedLengths[i][j];
                    var decompressedLength = shader.decompressedLengths[i][j];
                    var decompressedBytes = new byte[decompressedLength];
                    LZ4Codec.Decode(shader.compressedBlob, (int)offset, (int)compressedLength, decompressedBytes, 0, (int)decompressedLength);
                    using (var blobReader = new BinaryReader(new MemoryStream(decompressedBytes)))
                    {
                        if (j == 0)
                        {
                            shaderPrograms[i] = new ShaderProgram(blobReader, shader.version);
                        }
                        shaderPrograms[i].Read(blobReader, j);
                    }
                }
            }

            return ConvertSerializedShader(shader.m_ParsedForm, shader.platforms, shaderPrograms);
        }

        private static string ConvertSerializedShader(SerializedShader m_ParsedForm, ShaderCompilerPlatform[] platforms, ShaderProgram[] shaderPrograms)
        {
            var sb = new StringBuilder();
            sb.Append($"Shader \"{m_ParsedForm.m_Name}\" {{\n");

            sb.Append(ConvertSerializedProperties(m_ParsedForm.m_PropInfo));

            foreach (var m_SubShader in m_ParsedForm.m_SubShaders)
            {
                sb.Append(ConvertSerializedSubShader(m_SubShader, platforms, shaderPrograms));
            }

            if (!string.IsNullOrEmpty(m_ParsedForm.m_FallbackName))
            {
                sb.Append($"Fallback \"{m_ParsedForm.m_FallbackName}\"\n");
            }

            if (!string.IsNullOrEmpty(m_ParsedForm.m_CustomEditorName))
            {
                sb.Append($"CustomEditor \"{m_ParsedForm.m_CustomEditorName}\"\n");
            }

            sb.Append("}");
            return sb.ToString();
        }

        private static string ConvertSerializedSubShader(SerializedSubShader m_SubShader, ShaderCompilerPlatform[] platforms, ShaderProgram[] shaderPrograms)
        {
            var sb = new StringBuilder();
            sb.Append("SubShader {\n");
            if (m_SubShader.m_LOD != 0)
            {
                sb.Append($" LOD {m_SubShader.m_LOD}\n");
            }

            sb.Append(ConvertSerializedTagMap(m_SubShader.m_Tags, 1));

            foreach (var m_Passe in m_SubShader.m_Passes)
            {
                sb.Append(ConvertSerializedPass(m_Passe, platforms, shaderPrograms));
            }
            sb.Append("}\n");
            return sb.ToString();
        }

        private static string ConvertSerializedPass(SerializedPass m_Passe, ShaderCompilerPlatform[] platforms, ShaderProgram[] shaderPrograms)
        {
            var sb = new StringBuilder();
            switch (m_Passe.m_Type)
            {
                case PassType.Normal:
                    sb.Append(" Pass ");
                    break;
                case PassType.Use:
                    sb.Append(" UsePass ");
                    break;
                case PassType.Grab:
                    sb.Append(" GrabPass ");
                    break;
            }
            if (m_Passe.m_Type == PassType.Use)
            {
                sb.Append($"\"{m_Passe.m_UseName}\"\n");
            }
            else
            {
                sb.Append("{\n");

                if (m_Passe.m_Type == PassType.Grab)
                {
                    if (!string.IsNullOrEmpty(m_Passe.m_TextureName))
                    {
                        sb.Append($"  \"{m_Passe.m_TextureName}\"\n");
                    }
                }
                else
                {
                    sb.Append(ConvertSerializedShaderState(m_Passe.m_State));

                    if (m_Passe.progVertex.m_SubPrograms.Length > 0)
                    {
                        sb.Append("Program \"vp\" {\n");
                        sb.Append(ConvertSerializedSubPrograms(m_Passe.progVertex.m_SubPrograms, platforms, shaderPrograms));
                        sb.Append("}\n");
                    }

                    if (m_Passe.progFragment.m_SubPrograms.Length > 0)
                    {
                        sb.Append("Program \"fp\" {\n");
                        sb.Append(ConvertSerializedSubPrograms(m_Passe.progFragment.m_SubPrograms, platforms, shaderPrograms));
                        sb.Append("}\n");
                    }

                    if (m_Passe.progGeometry.m_SubPrograms.Length > 0)
                    {
                        sb.Append("Program \"gp\" {\n");
                        sb.Append(ConvertSerializedSubPrograms(m_Passe.progGeometry.m_SubPrograms, platforms, shaderPrograms));
                        sb.Append("}\n");
                    }

                    if (m_Passe.progHull.m_SubPrograms.Length > 0)
                    {
                        sb.Append("Program \"hp\" {\n");
                        sb.Append(ConvertSerializedSubPrograms(m_Passe.progHull.m_SubPrograms, platforms, shaderPrograms));
                        sb.Append("}\n");
                    }

                    if (m_Passe.progDomain.m_SubPrograms.Length > 0)
                    {
                        sb.Append("Program \"dp\" {\n");
                        sb.Append(ConvertSerializedSubPrograms(m_Passe.progDomain.m_SubPrograms, platforms, shaderPrograms));
                        sb.Append("}\n");
                    }

                    if (m_Passe.progRayTracing?.m_SubPrograms.Length > 0)
                    {
                        sb.Append("Program \"rtp\" {\n");
                        sb.Append(ConvertSerializedSubPrograms(m_Passe.progRayTracing.m_SubPrograms, platforms, shaderPrograms));
                        sb.Append("}\n");
                    }
                }
                sb.Append("}\n");
            }
            return sb.ToString();
        }

        private static string ConvertSerializedSubPrograms(SerializedSubProgram[] m_SubPrograms, ShaderCompilerPlatform[] platforms, ShaderProgram[] shaderPrograms)
        {
            var sb = new StringBuilder();
            var groups = m_SubPrograms.GroupBy(x => x.m_BlobIndex);
            foreach (var group in groups)
            {
                var programs = group.GroupBy(x => x.m_GpuProgramType);
                foreach (var program in programs)
                {
                    for (int i = 0; i < platforms.Length; i++)
                    {
                        var platform = platforms[i];
                        if (CheckGpuProgramUsable(platform, program.Key))
                        {
                            var subPrograms = program.ToList();
                            var isTier = subPrograms.Count > 1;
                            foreach (var subProgram in subPrograms)
                            {
                                sb.Append($"SubProgram \"{GetPlatformString(platform)} ");
                                if (isTier)
                                {
                                    sb.Append($"hw_tier{subProgram.m_ShaderHardwareTier:00} ");
                                }
                                sb.Append("\" {\n");
                                sb.Append(shaderPrograms[i].m_SubPrograms[subProgram.m_BlobIndex].Export());
                                sb.Append("\n}\n");
                            }
                            break;
                        }
                    }
                }
            }
            return sb.ToString();
        }

        private static string ConvertSerializedShaderState(SerializedShaderState m_State)
        {
            var sb = new StringBuilder();
            if (!string.IsNullOrEmpty(m_State.m_Name))
            {
                sb.Append($"  Name \"{m_State.m_Name}\"\n");
            }
            if (m_State.m_LOD != 0)
            {
                sb.Append($"  LOD {m_State.m_LOD}\n");
            }

            sb.Append(ConvertSerializedTagMap(m_State.m_Tags, 2));

            sb.Append(ConvertSerializedShaderRTBlendState(m_State.rtBlend, m_State.rtSeparateBlend));

            if (m_State.alphaToMask.val > 0f)
            {
                sb.Append("  AlphaToMask On\n");
            }

            if (m_State.zClip?.val != 1f) //ZClip On
            {
                sb.Append("  ZClip Off\n");
            }

            if (m_State.zTest.val != 4f) //ZTest LEqual
            {
                sb.Append("  ZTest ");
                switch (m_State.zTest.val) //enum CompareFunction
                {
                    case 0f: //kFuncDisabled
                        sb.Append("Off");
                        break;
                    case 1f: //kFuncNever
                        sb.Append("Never");
                        break;
                    case 2f: //kFuncLess
                        sb.Append("Less");
                        break;
                    case 3f: //kFuncEqual
                        sb.Append("Equal");
                        break;
                    case 5f: //kFuncGreater
                        sb.Append("Greater");
                        break;
                    case 6f: //kFuncNotEqual
                        sb.Append("NotEqual");
                        break;
                    case 7f: //kFuncGEqual
                        sb.Append("GEqual");
                        break;
                    case 8f: //kFuncAlways
                        sb.Append("Always");
                        break;
                }

                sb.Append("\n");
            }

            if (m_State.zWrite.val != 1f) //ZWrite On
            {
                sb.Append("  ZWrite Off\n");
            }

            if (m_State.culling.val != 2f) //Cull Back
            {
                sb.Append("  Cull ");
                switch (m_State.culling.val) //enum CullMode
                {
                    case 0f: //kCullOff
                        sb.Append("Off");
                        break;
                    case 1f: //kCullFront
                        sb.Append("Front");
                        break;
                }
                sb.Append("\n");
            }

            if (m_State.offsetFactor.val != 0f || m_State.offsetUnits.val != 0f)
            {
                sb.Append($"  Offset {m_State.offsetFactor.val}, {m_State.offsetUnits.val}\n");
            }

            if (m_State.stencilRef.val != 0f ||
                m_State.stencilReadMask.val != 255f ||
                m_State.stencilWriteMask.val != 255f ||
                m_State.stencilOp.pass.val != 0f ||
                m_State.stencilOp.fail.val != 0f ||
                m_State.stencilOp.zFail.val != 0f ||
                m_State.stencilOp.comp.val != 8f ||
                m_State.stencilOpFront.pass.val != 0f ||
                m_State.stencilOpFront.fail.val != 0f ||
                m_State.stencilOpFront.zFail.val != 0f ||
                m_State.stencilOpFront.comp.val != 8f ||
                m_State.stencilOpBack.pass.val != 0f ||
                m_State.stencilOpBack.fail.val != 0f ||
                m_State.stencilOpBack.zFail.val != 0f ||
                m_State.stencilOpBack.comp.val != 8f)
            {
                sb.Append("  Stencil {\n");
                if (m_State.stencilRef.val != 0f)
                {
                    sb.Append($"   Ref {m_State.stencilRef.val}\n");
                }
                if (m_State.stencilReadMask.val != 255f)
                {
                    sb.Append($"   ReadMask {m_State.stencilReadMask.val}\n");
                }
                if (m_State.stencilWriteMask.val != 255f)
                {
                    sb.Append($"   WriteMask {m_State.stencilWriteMask.val}\n");
                }
                if (m_State.stencilOp.pass.val != 0f ||
                    m_State.stencilOp.fail.val != 0f ||
                    m_State.stencilOp.zFail.val != 0f ||
                    m_State.stencilOp.comp.val != 8f)
                {
                    sb.Append(ConvertSerializedStencilOp(m_State.stencilOp, ""));
                }
                if (m_State.stencilOpFront.pass.val != 0f ||
                    m_State.stencilOpFront.fail.val != 0f ||
                    m_State.stencilOpFront.zFail.val != 0f ||
                    m_State.stencilOpFront.comp.val != 8f)
                {
                    sb.Append(ConvertSerializedStencilOp(m_State.stencilOpFront, "Front"));
                }
                if (m_State.stencilOpBack.pass.val != 0f ||
                    m_State.stencilOpBack.fail.val != 0f ||
                    m_State.stencilOpBack.zFail.val != 0f ||
                    m_State.stencilOpBack.comp.val != 8f)
                {
                    sb.Append(ConvertSerializedStencilOp(m_State.stencilOpBack, "Back"));
                }
                sb.Append("  }\n");
            }

            if (m_State.fogMode != FogMode.Unknown ||
                m_State.fogColor.x.val != 0f ||
                m_State.fogColor.y.val != 0f ||
                m_State.fogColor.z.val != 0f ||
                m_State.fogColor.w.val != 0f ||
                m_State.fogDensity.val != 0f ||
                m_State.fogStart.val != 0f ||
                m_State.fogEnd.val != 0f)
            {
                sb.Append("  Fog {\n");
                if (m_State.fogMode != FogMode.Unknown)
                {
                    sb.Append("   Mode ");
                    switch (m_State.fogMode)
                    {
                        case FogMode.Disabled:
                            sb.Append("Off");
                            break;
                        case FogMode.Linear:
                            sb.Append("Linear");
                            break;
                        case FogMode.Exp:
                            sb.Append("Exp");
                            break;
                        case FogMode.Exp2:
                            sb.Append("Exp2");
                            break;
                    }
                    sb.Append("\n");
                }
                if (m_State.fogColor.x.val != 0f ||
                    m_State.fogColor.y.val != 0f ||
                    m_State.fogColor.z.val != 0f ||
                    m_State.fogColor.w.val != 0f)
                {
                    sb.AppendFormat("   Color ({0},{1},{2},{3})\n",
                        m_State.fogColor.x.val.ToString(CultureInfo.InvariantCulture),
                        m_State.fogColor.y.val.ToString(CultureInfo.InvariantCulture),
                        m_State.fogColor.z.val.ToString(CultureInfo.InvariantCulture),
                        m_State.fogColor.w.val.ToString(CultureInfo.InvariantCulture));
                }
                if (m_State.fogDensity.val != 0f)
                {
                    sb.Append($"   Density {m_State.fogDensity.val.ToString(CultureInfo.InvariantCulture)}\n");
                }
                if (m_State.fogStart.val != 0f ||
                    m_State.fogEnd.val != 0f)
                {
                    sb.Append($"   Range {m_State.fogStart.val.ToString(CultureInfo.InvariantCulture)}, {m_State.fogEnd.val.ToString(CultureInfo.InvariantCulture)}\n");
                }
                sb.Append("  }\n");
            }

            if (m_State.lighting)
            {
                sb.Append($"  Lighting {(m_State.lighting ? "On" : "Off")}\n");
            }

            sb.Append($"  GpuProgramID {m_State.gpuProgramID}\n");

            return sb.ToString();
        }

        private static string ConvertSerializedStencilOp(SerializedStencilOp stencilOp, string suffix)
        {
            var sb = new StringBuilder();
            sb.Append($"   Comp{suffix} {ConvertStencilComp(stencilOp.comp)}\n");
            sb.Append($"   Pass{suffix} {ConvertStencilOp(stencilOp.pass)}\n");
            sb.Append($"   Fail{suffix} {ConvertStencilOp(stencilOp.fail)}\n");
            sb.Append($"   ZFail{suffix} {ConvertStencilOp(stencilOp.zFail)}\n");
            return sb.ToString();
        }

        private static string ConvertStencilOp(SerializedShaderFloatValue op)
        {
            switch (op.val)
            {
                case 0f:
                default:
                    return "Keep";
                case 1f:
                    return "Zero";
                case 2f:
                    return "Replace";
                case 3f:
                    return "IncrSat";
                case 4f:
                    return "DecrSat";
                case 5f:
                    return "Invert";
                case 6f:
                    return "IncrWrap";
                case 7f:
                    return "DecrWrap";
            }
        }

        private static string ConvertStencilComp(SerializedShaderFloatValue comp)
        {
            switch (comp.val)
            {
                case 0f:
                    return "Disabled";
                case 1f:
                    return "Never";
                case 2f:
                    return "Less";
                case 3f:
                    return "Equal";
                case 4f:
                    return "LEqual";
                case 5f:
                    return "Greater";
                case 6f:
                    return "NotEqual";
                case 7f:
                    return "GEqual";
                case 8f:
                default:
                    return "Always";
            }
        }

        private static string ConvertSerializedShaderRTBlendState(SerializedShaderRTBlendState[] rtBlend, bool rtSeparateBlend)
        {
            var sb = new StringBuilder();
            for (var i = 0; i < rtBlend.Length; i++)
            {
                var blend = rtBlend[i];
                if (blend.srcBlend.val != 1f ||
                    blend.destBlend.val != 0f ||
                    blend.srcBlendAlpha.val != 1f ||
                    blend.destBlendAlpha.val != 0f)
                {
                    sb.Append("  Blend ");
                    if (i != 0 || rtSeparateBlend)
                    {
                        sb.Append($"{i} ");
                    }
                    sb.Append($"{ConvertBlendFactor(blend.srcBlend)} {ConvertBlendFactor(blend.destBlend)}");
                    if (blend.srcBlendAlpha.val != 1f ||
                        blend.destBlendAlpha.val != 0f)
                    {
                        sb.Append($", {ConvertBlendFactor(blend.srcBlendAlpha)} {ConvertBlendFactor(blend.destBlendAlpha)}");
                    }
                    sb.Append("\n");
                }

                if (blend.blendOp.val != 0f ||
                    blend.blendOpAlpha.val != 0f)
                {
                    sb.Append("  BlendOp ");
                    if (i != 0 || rtSeparateBlend)
                    {
                        sb.Append($"{i} ");
                    }
                    sb.Append(ConvertBlendOp(blend.blendOp));
                    if (blend.blendOpAlpha.val != 0f)
                    {
                        sb.Append($", {ConvertBlendOp(blend.blendOpAlpha)}");
                    }
                    sb.Append("\n");
                }

                var val = (int)blend.colMask.val;
                if (val != 0xf)
                {
                    sb.Append("  ColorMask ");
                    if (val == 0)
                    {
                        sb.Append(0);
                    }
                    else
                    {
                        if ((val & 0x2) != 0)
                        {
                            sb.Append("R");
                        }
                        if ((val & 0x4) != 0)
                        {
                            sb.Append("G");
                        }
                        if ((val & 0x8) != 0)
                        {
                            sb.Append("B");
                        }
                        if ((val & 0x1) != 0)
                        {
                            sb.Append("A");
                        }
                    }
                    sb.Append($" {i}\n");
                }
            }
            return sb.ToString();
        }

        private static string ConvertBlendOp(SerializedShaderFloatValue op)
        {
            switch (op.val)
            {
                case 0f:
                default:
                    return "Add";
                case 1f:
                    return "Sub";
                case 2f:
                    return "RevSub";
                case 3f:
                    return "Min";
                case 4f:
                    return "Max";
                case 5f:
                    return "LogicalClear";
                case 6f:
                    return "LogicalSet";
                case 7f:
                    return "LogicalCopy";
                case 8f:
                    return "LogicalCopyInverted";
                case 9f:
                    return "LogicalNoop";
                case 10f:
                    return "LogicalInvert";
                case 11f:
                    return "LogicalAnd";
                case 12f:
                    return "LogicalNand";
                case 13f:
                    return "LogicalOr";
                case 14f:
                    return "LogicalNor";
                case 15f:
                    return "LogicalXor";
                case 16f:
                    return "LogicalEquiv";
                case 17f:
                    return "LogicalAndReverse";
                case 18f:
                    return "LogicalAndInverted";
                case 19f:
                    return "LogicalOrReverse";
                case 20f:
                    return "LogicalOrInverted";
            }
        }

        private static string ConvertBlendFactor(SerializedShaderFloatValue factor)
        {
            switch (factor.val)
            {
                case 0f:
                    return "Zero";
                case 1f:
                default:
                    return "One";
                case 2f:
                    return "DstColor";
                case 3f:
                    return "SrcColor";
                case 4f:
                    return "OneMinusDstColor";
                case 5f:
                    return "SrcAlpha";
                case 6f:
                    return "OneMinusSrcColor";
                case 7f:
                    return "DstAlpha";
                case 8f:
                    return "OneMinusDstAlpha";
                case 9f:
                    return "SrcAlphaSaturate";
                case 10f:
                    return "OneMinusSrcAlpha";
            }
        }

        private static string ConvertSerializedTagMap(SerializedTagMap m_Tags, int intent)
        {
            var sb = new StringBuilder();
            if (m_Tags.tags.Length > 0)
            {
                sb.Append(new string(' ', intent));
                sb.Append("Tags { ");
                foreach (var pair in m_Tags.tags)
                {
                    sb.Append($"\"{pair.Key}\" = \"{pair.Value}\" ");
                }
                sb.Append("}\n");
            }
            return sb.ToString();
        }

        private static string ConvertSerializedProperties(SerializedProperties m_PropInfo)
        {
            var sb = new StringBuilder();
            sb.Append("Properties {\n");
            foreach (var m_Prop in m_PropInfo.m_Props)
            {
                sb.Append(ConvertSerializedProperty(m_Prop));
            }
            sb.Append("}\n");
            return sb.ToString();
        }

        private static string ConvertSerializedProperty(SerializedProperty m_Prop)
        {
            var sb = new StringBuilder();
            foreach (var m_Attribute in m_Prop.m_Attributes)
            {
                sb.Append($"[{m_Attribute}] ");
            }
            //TODO Flag
            sb.Append($"{m_Prop.m_Name} (\"{m_Prop.m_Description}\", ");
            switch (m_Prop.m_Type)
            {
                case SerializedPropertyType.Color:
                    sb.Append("Color");
                    break;
                case SerializedPropertyType.Vector:
                    sb.Append("Vector");
                    break;
                case SerializedPropertyType.Float:
                    sb.Append("Float");
                    break;
                case SerializedPropertyType.Range:
                    sb.Append($"Range({m_Prop.m_DefValue[1]}, {m_Prop.m_DefValue[2]})");
                    break;
                case SerializedPropertyType.Texture:
                    switch (m_Prop.m_DefTexture.m_TexDim)
                    {
                        case TextureDimension.Any:
                            sb.Append("any");
                            break;
                        case TextureDimension.Tex2D:
                            sb.Append("2D");
                            break;
                        case TextureDimension.Tex3D:
                            sb.Append("3D");
                            break;
                        case TextureDimension.Cube:
                            sb.Append("Cube");
                            break;
                        case TextureDimension.Tex2DArray:
                            sb.Append("2DArray");
                            break;
                        case TextureDimension.CubeArray:
                            sb.Append("CubeArray");
                            break;
                    }
                    break;
            }
            sb.Append(") = ");
            switch (m_Prop.m_Type)
            {
                case SerializedPropertyType.Color:
                case SerializedPropertyType.Vector:
                    sb.Append($"({m_Prop.m_DefValue[0]},{m_Prop.m_DefValue[1]},{m_Prop.m_DefValue[2]},{m_Prop.m_DefValue[3]})");
                    break;
                case SerializedPropertyType.Float:
                case SerializedPropertyType.Range:
                    sb.Append(m_Prop.m_DefValue[0]);
                    break;
                case SerializedPropertyType.Texture:
                    sb.Append($"\"{m_Prop.m_DefTexture.m_DefaultName}\" {{ }}");
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
            sb.Append("\n");
            return sb.ToString();
        }

        private static bool CheckGpuProgramUsable(ShaderCompilerPlatform platform, ShaderGpuProgramType programType)
        {
            switch (platform)
            {
                case ShaderCompilerPlatform.GL:
                    return programType == ShaderGpuProgramType.GLLegacy;
                case ShaderCompilerPlatform.D3D9:
                    return programType == ShaderGpuProgramType.DX9VertexSM20
                        || programType == ShaderGpuProgramType.DX9VertexSM30
                        || programType == ShaderGpuProgramType.DX9PixelSM20
                        || programType == ShaderGpuProgramType.DX9PixelSM30;
                case ShaderCompilerPlatform.Xbox360:
                case ShaderCompilerPlatform.PS3:
                case ShaderCompilerPlatform.PSP2:
                case ShaderCompilerPlatform.PS4:
                case ShaderCompilerPlatform.XboxOne:
                case ShaderCompilerPlatform.N3DS:
                case ShaderCompilerPlatform.WiiU:
                case ShaderCompilerPlatform.Switch:
                case ShaderCompilerPlatform.XboxOneD3D12:
                case ShaderCompilerPlatform.GameCoreXboxOne:
                case ShaderCompilerPlatform.GameCoreScarlett:
                case ShaderCompilerPlatform.PS5:
                    return programType == ShaderGpuProgramType.ConsoleVS
                        || programType == ShaderGpuProgramType.ConsoleFS
                        || programType == ShaderGpuProgramType.ConsoleHS
                        || programType == ShaderGpuProgramType.ConsoleDS
                        || programType == ShaderGpuProgramType.ConsoleGS;
                case ShaderCompilerPlatform.PS5NGGC:
                    return programType == ShaderGpuProgramType.PS5NGGC;
                case ShaderCompilerPlatform.D3D11:
                    return programType == ShaderGpuProgramType.DX11VertexSM40
                        || programType == ShaderGpuProgramType.DX11VertexSM50
                        || programType == ShaderGpuProgramType.DX11PixelSM40
                        || programType == ShaderGpuProgramType.DX11PixelSM50
                        || programType == ShaderGpuProgramType.DX11GeometrySM40
                        || programType == ShaderGpuProgramType.DX11GeometrySM50
                        || programType == ShaderGpuProgramType.DX11HullSM50
                        || programType == ShaderGpuProgramType.DX11DomainSM50;
                case ShaderCompilerPlatform.GLES20:
                    return programType == ShaderGpuProgramType.GLES;
                case ShaderCompilerPlatform.NaCl: //Obsolete
                    throw new NotSupportedException();
                case ShaderCompilerPlatform.Flash: //Obsolete
                    throw new NotSupportedException();
                case ShaderCompilerPlatform.D3D11_9x:
                    return programType == ShaderGpuProgramType.DX10Level9Vertex
                        || programType == ShaderGpuProgramType.DX10Level9Pixel;
                case ShaderCompilerPlatform.GLES3Plus:
                    return programType == ShaderGpuProgramType.GLES31AEP
                        || programType == ShaderGpuProgramType.GLES31
                        || programType == ShaderGpuProgramType.GLES3;
                case ShaderCompilerPlatform.PSM: //Unknown
                    throw new NotSupportedException();
                case ShaderCompilerPlatform.Metal:
                    return programType == ShaderGpuProgramType.MetalVS
                        || programType == ShaderGpuProgramType.MetalFS;
                case ShaderCompilerPlatform.OpenGLCore:
                    return programType == ShaderGpuProgramType.GLCore32
                        || programType == ShaderGpuProgramType.GLCore41
                        || programType == ShaderGpuProgramType.GLCore43;
                case ShaderCompilerPlatform.Vulkan:
                    return programType == ShaderGpuProgramType.SPIRV;
                default:
                    throw new NotSupportedException();
            }
        }

        public static string GetPlatformString(ShaderCompilerPlatform platform)
        {
            switch (platform)
            {
                case ShaderCompilerPlatform.GL:
                    return "openGL";
                case ShaderCompilerPlatform.D3D9:
                    return "d3d9";
                case ShaderCompilerPlatform.Xbox360:
                    return "xbox360";
                case ShaderCompilerPlatform.PS3:
                    return "ps3";
                case ShaderCompilerPlatform.D3D11:
                    return "d3d11";
                case ShaderCompilerPlatform.GLES20:
                    return "gles";
                case ShaderCompilerPlatform.NaCl:
                    return "glesdesktop";
                case ShaderCompilerPlatform.Flash:
                    return "flash";
                case ShaderCompilerPlatform.D3D11_9x:
                    return "d3d11_9x";
                case ShaderCompilerPlatform.GLES3Plus:
                    return "gles3";
                case ShaderCompilerPlatform.PSP2:
                    return "psp2";
                case ShaderCompilerPlatform.PS4:
                    return "ps4";
                case ShaderCompilerPlatform.XboxOne:
                    return "xboxone";
                case ShaderCompilerPlatform.PSM:
                    return "psm";
                case ShaderCompilerPlatform.Metal:
                    return "metal";
                case ShaderCompilerPlatform.OpenGLCore:
                    return "glcore";
                case ShaderCompilerPlatform.N3DS:
                    return "n3ds";
                case ShaderCompilerPlatform.WiiU:
                    return "wiiu";
                case ShaderCompilerPlatform.Vulkan:
                    return "vulkan";
                case ShaderCompilerPlatform.Switch:
                    return "switch";
                case ShaderCompilerPlatform.XboxOneD3D12:
                    return "xboxone_d3d12";
                case ShaderCompilerPlatform.GameCoreXboxOne:
                    return "xboxone";
                case ShaderCompilerPlatform.GameCoreScarlett:
                    return "xbox_scarlett";
                case ShaderCompilerPlatform.PS5:
                    return "ps5";
                case ShaderCompilerPlatform.PS5NGGC:
                    return "ps5_nggc";
                default:
                    return "unknown";
            }
        }

        private static string header = "//////////////////////////////////////////\n" +
                                      "//\n" +
                                      "// NOTE: This is *not* a valid shader file\n" +
                                      "//\n" +
                                      "///////////////////////////////////////////\n";
    }

    public class ShaderSubProgramEntry
    {
        public int Offset;
        public int Length;
        public int Segment;

        public ShaderSubProgramEntry(BinaryReader reader, int[] version)
        {
            Offset = reader.ReadInt32();
            Length = reader.ReadInt32();
            if (version[0] > 2019 || (version[0] == 2019 && version[1] >= 3)) //2019.3 and up
            {
                Segment = reader.ReadInt32();
            }
        }
    }

    public class ShaderProgram
    {
        public ShaderSubProgramEntry[] entries;
        public ShaderSubProgram[] m_SubPrograms;

        public ShaderProgram(BinaryReader reader, int[] version)
        {
            var subProgramsCapacity = reader.ReadInt32();
            entries = new ShaderSubProgramEntry[subProgramsCapacity];
            for (int i = 0; i < subProgramsCapacity; i++)
            {
                entries[i] = new ShaderSubProgramEntry(reader, version);
            }
            m_SubPrograms = new ShaderSubProgram[subProgramsCapacity];
        }

        public void Read(BinaryReader reader, int segment)
        {
            for (int i = 0; i < entries.Length; i++)
            {
                var entry = entries[i];
                if (entry.Segment == segment)
                {
                    reader.BaseStream.Position = entry.Offset;
                    m_SubPrograms[i] = new ShaderSubProgram(reader);
                }
            }
        }

        public string Export(string shader)
        {
            var evaluator = new MatchEvaluator(match =>
            {
                var index = int.Parse(match.Groups[1].Value);
                return m_SubPrograms[index].Export();
            });
            shader = Regex.Replace(shader, "GpuProgramIndex (.+)", evaluator);
            return shader;
        }
    }

    public class ShaderSubProgram
    {
        private int m_Version;
        public ShaderGpuProgramType m_ProgramType;
        public string[] m_Keywords;
        public string[] m_LocalKeywords;
        public byte[] m_ProgramCode;

        public ShaderSubProgram(BinaryReader reader)
        {
            //LoadGpuProgramFromData
            //201509030 - Unity 5.3
            //201510240 - Unity 5.4
            //201608170 - Unity 5.5
            //201609010 - Unity 5.6, 2017.1 & 2017.2
            //201708220 - Unity 2017.3, Unity 2017.4 & Unity 2018.1
            //201802150 - Unity 2018.2 & Unity 2018.3
            //201806140 - Unity 2019.1~2021.1
            //202012090 - Unity 2021.2
            m_Version = reader.ReadInt32();
            m_ProgramType = (ShaderGpuProgramType)reader.ReadInt32();
            reader.BaseStream.Position += 12;
            if (m_Version >= 201608170)
            {
                reader.BaseStream.Position += 4;
            }
            var m_KeywordsSize = reader.ReadInt32();
            m_Keywords = new string[m_KeywordsSize];
            for (int i = 0; i < m_KeywordsSize; i++)
            {
                m_Keywords[i] = reader.ReadAlignedString();
            }
            if (m_Version >= 201806140 && m_Version < 202012090)
            {
                var m_LocalKeywordsSize = reader.ReadInt32();
                m_LocalKeywords = new string[m_LocalKeywordsSize];
                for (int i = 0; i < m_LocalKeywordsSize; i++)
                {
                    m_LocalKeywords[i] = reader.ReadAlignedString();
                }
            }
            m_ProgramCode = reader.ReadUInt8Array();
            reader.AlignStream();

            //TODO
        }

        public string Export()
        {
            var sb = new StringBuilder();
            if (m_Keywords.Length > 0)
            {
                sb.Append("Keywords { ");
                foreach (string keyword in m_Keywords)
                {
                    sb.Append($"\"{keyword}\" ");
                }
                sb.Append("}\n");
            }
            if (m_LocalKeywords != null && m_LocalKeywords.Length > 0)
            {
                sb.Append("Local Keywords { ");
                foreach (string keyword in m_LocalKeywords)
                {
                    sb.Append($"\"{keyword}\" ");
                }
                sb.Append("}\n");
            }

            sb.Append("\"");
            if (m_ProgramCode.Length > 0)
            {
                switch (m_ProgramType)
                {
                    case ShaderGpuProgramType.GLLegacy:
                    case ShaderGpuProgramType.GLES31AEP:
                    case ShaderGpuProgramType.GLES31:
                    case ShaderGpuProgramType.GLES3:
                    case ShaderGpuProgramType.GLES:
                    case ShaderGpuProgramType.GLCore32:
                    case ShaderGpuProgramType.GLCore41:
                    case ShaderGpuProgramType.GLCore43:
                        sb.Append(Encoding.UTF8.GetString(m_ProgramCode));
                        break;
                    case ShaderGpuProgramType.DX9VertexSM20:
                    case ShaderGpuProgramType.DX9VertexSM30:
                    case ShaderGpuProgramType.DX9PixelSM20:
                    case ShaderGpuProgramType.DX9PixelSM30:
                        {
                            /*var shaderBytecode = new ShaderBytecode(m_ProgramCode);
                            sb.Append(shaderBytecode.Disassemble());*/
                            sb.Append("// shader disassembly not supported on DXBC");
                            break;
                        }
                    case ShaderGpuProgramType.DX10Level9Vertex:
                    case ShaderGpuProgramType.DX10Level9Pixel:
                    case ShaderGpuProgramType.DX11VertexSM40:
                    case ShaderGpuProgramType.DX11VertexSM50:
                    case ShaderGpuProgramType.DX11PixelSM40:
                    case ShaderGpuProgramType.DX11PixelSM50:
                    case ShaderGpuProgramType.DX11GeometrySM40:
                    case ShaderGpuProgramType.DX11GeometrySM50:
                    case ShaderGpuProgramType.DX11HullSM50:
                    case ShaderGpuProgramType.DX11DomainSM50:
                        {
                            /*int start = 6;
                            if (m_Version == 201509030) // 5.3
                            {
                                start = 5;
                            }
                            var buff = new byte[m_ProgramCode.Length - start];
                            Buffer.BlockCopy(m_ProgramCode, start, buff, 0, buff.Length);
                            var shaderBytecode = new ShaderBytecode(buff);
                            sb.Append(shaderBytecode.Disassemble());*/
                            sb.Append("// shader disassembly not supported on DXBC");
                            break;
                        }
                    case ShaderGpuProgramType.MetalVS:
                    case ShaderGpuProgramType.MetalFS:
                        using (var reader = new BinaryReader(new MemoryStream(m_ProgramCode)))
                        {
                            var fourCC = reader.ReadUInt32();
                            if (fourCC == 0xf00dcafe)
                            {
                                int offset = reader.ReadInt32();
                                reader.BaseStream.Position = offset;
                            }
                            var entryName = reader.ReadStringToNull();
                            var buff = reader.ReadBytes((int)(reader.BaseStream.Length - reader.BaseStream.Position));
                            sb.Append(Encoding.UTF8.GetString(buff));
                        }
                        break;
                    case ShaderGpuProgramType.SPIRV:
                        try
                        {
                            sb.Append(SpirVShaderConverter.Convert(m_ProgramCode));
                        }
                        catch (Exception e)
                        {
                            sb.Append($"// disassembly error {e.Message}\n");
                        }
                        break;
                    case ShaderGpuProgramType.ConsoleVS:
                    case ShaderGpuProgramType.ConsoleFS:
                    case ShaderGpuProgramType.ConsoleHS:
                    case ShaderGpuProgramType.ConsoleDS:
                    case ShaderGpuProgramType.ConsoleGS:
                        sb.Append(Encoding.UTF8.GetString(m_ProgramCode));
                        break;
                    default:
                        sb.Append($"//shader disassembly not supported on {m_ProgramType}");
                        break;
                }
            }
            sb.Append('"');
            return sb.ToString();
        }
    }
}

```

`AssetStudioUtility/Smolv/OpData.cs`:

```cs
namespace Smolv
{
	public struct OpData
	{
		public OpData(byte hasResult, byte hasType, sbyte deltaFromResult, byte varrest)
		{
			this.hasResult = hasResult;
			this.hasType = hasType;
			this.deltaFromResult = deltaFromResult;
			this.varrest = varrest;
		}

		/// <summary>
		/// Does it have result ID?
		/// </summary>
		public byte hasResult;
		/// <summary>
		/// Does it have type ID?
		/// </summary>
		public byte hasType;
		/// <summary>
		/// How many words after (optional) type+result to write out as deltas from result?
		/// </summary>
		public sbyte deltaFromResult;
		/// <summary>
		/// Should the rest of words be written in varint encoding?
		/// </summary>
		public byte varrest;

		public static readonly OpData[] SpirvOpData =
		{
			new OpData(0, 0, 0, 0), // Nop
			new OpData(1, 1, 0, 0), // Undef
			new OpData(0, 0, 0, 0), // SourceContinued
			new OpData(0, 0, 0, 1), // Source
			new OpData(0, 0, 0, 0), // SourceExtension
			new OpData(0, 0, 0, 0), // Name
			new OpData(0, 0, 0, 0), // MemberName
			new OpData(0, 0, 0, 0), // String
			new OpData(0, 0, 0, 1), // Line
			new OpData(1, 1, 0, 0), // #9
			new OpData(0, 0, 0, 0), // Extension
			new OpData(1, 0, 0, 0), // ExtInstImport
			new OpData(1, 1, 0, 1), // ExtInst
			new OpData(1, 1, 2, 1), // VectorShuffleCompact - new in SMOLV
			new OpData(0, 0, 0, 1), // MemoryModel
			new OpData(0, 0, 0, 1), // EntryPoint
			new OpData(0, 0, 0, 1), // ExecutionMode
			new OpData(0, 0, 0, 1), // Capability
			new OpData(1, 1, 0, 0), // #18
			new OpData(1, 0, 0, 1), // TypeVoid
			new OpData(1, 0, 0, 1), // TypeBool
			new OpData(1, 0, 0, 1), // TypeInt
			new OpData(1, 0, 0, 1), // TypeFloat
			new OpData(1, 0, 0, 1), // TypeVector
			new OpData(1, 0, 0, 1), // TypeMatrix
			new OpData(1, 0, 0, 1), // TypeImage
			new OpData(1, 0, 0, 1), // TypeSampler
			new OpData(1, 0, 0, 1), // TypeSampledImage
			new OpData(1, 0, 0, 1), // TypeArray
			new OpData(1, 0, 0, 1), // TypeRuntimeArray
			new OpData(1, 0, 0, 1), // TypeStruct
			new OpData(1, 0, 0, 1), // TypeOpaque
			new OpData(1, 0, 0, 1), // TypePointer
			new OpData(1, 0, 0, 1), // TypeFunction
			new OpData(1, 0, 0, 1), // TypeEvent
			new OpData(1, 0, 0, 1), // TypeDeviceEvent
			new OpData(1, 0, 0, 1), // TypeReserveId
			new OpData(1, 0, 0, 1), // TypeQueue
			new OpData(1, 0, 0, 1), // TypePipe
			new OpData(0, 0, 0, 1), // TypeForwardPointer
			new OpData(1, 1, 0, 0), // #40
			new OpData(1, 1, 0, 0), // ConstantTrue
			new OpData(1, 1, 0, 0), // ConstantFalse
			new OpData(1, 1, 0, 0), // Constant
			new OpData(1, 1, 9, 0), // ConstantComposite
			new OpData(1, 1, 0, 1), // ConstantSampler
			new OpData(1, 1, 0, 0), // ConstantNull
			new OpData(1, 1, 0, 0), // #47
			new OpData(1, 1, 0, 0), // SpecConstantTrue
			new OpData(1, 1, 0, 0), // SpecConstantFalse
			new OpData(1, 1, 0, 0), // SpecConstant
			new OpData(1, 1, 9, 0), // SpecConstantComposite
			new OpData(1, 1, 0, 0), // SpecConstantOp
			new OpData(1, 1, 0, 0), // #53
			new OpData(1, 1, 0, 1), // Function
			new OpData(1, 1, 0, 0), // FunctionParameter
			new OpData(0, 0, 0, 0), // FunctionEnd
			new OpData(1, 1, 9, 0), // FunctionCall
			new OpData(1, 1, 0, 0), // #58
			new OpData(1, 1, 0, 1), // Variable
			new OpData(1, 1, 0, 0), // ImageTexelPointer
			new OpData(1, 1, 1, 1), // Load
			new OpData(0, 0, 2, 1), // Store
			new OpData(0, 0, 0, 0), // CopyMemory
			new OpData(0, 0, 0, 0), // CopyMemorySized
			new OpData(1, 1, 0, 1), // AccessChain
			new OpData(1, 1, 0, 0), // InBoundsAccessChain
			new OpData(1, 1, 0, 0), // PtrAccessChain
			new OpData(1, 1, 0, 0), // ArrayLength
			new OpData(1, 1, 0, 0), // GenericPtrMemSemantics
			new OpData(1, 1, 0, 0), // InBoundsPtrAccessChain
			new OpData(0, 0, 0, 1), // Decorate
			new OpData(0, 0, 0, 1), // MemberDecorate
			new OpData(1, 0, 0, 0), // DecorationGroup
			new OpData(0, 0, 0, 0), // GroupDecorate
			new OpData(0, 0, 0, 0), // GroupMemberDecorate
			new OpData(1, 1, 0, 0), // #76
			new OpData(1, 1, 1, 1), // VectorExtractDynamic
			new OpData(1, 1, 2, 1), // VectorInsertDynamic
			new OpData(1, 1, 2, 1), // VectorShuffle
			new OpData(1, 1, 9, 0), // CompositeConstruct
			new OpData(1, 1, 1, 1), // CompositeExtract
			new OpData(1, 1, 2, 1), // CompositeInsert
			new OpData(1, 1, 1, 0), // CopyObject
			new OpData(1, 1, 0, 0), // Transpose
			new OpData(1, 1, 0, 0), // #85
			new OpData(1, 1, 0, 0), // SampledImage
			new OpData(1, 1, 2, 1), // ImageSampleImplicitLod
			new OpData(1, 1, 2, 1), // ImageSampleExplicitLod
			new OpData(1, 1, 3, 1), // ImageSampleDrefImplicitLod
			new OpData(1, 1, 3, 1), // ImageSampleDrefExplicitLod
			new OpData(1, 1, 2, 1), // ImageSampleProjImplicitLod
			new OpData(1, 1, 2, 1), // ImageSampleProjExplicitLod
			new OpData(1, 1, 3, 1), // ImageSampleProjDrefImplicitLod
			new OpData(1, 1, 3, 1), // ImageSampleProjDrefExplicitLod
			new OpData(1, 1, 2, 1), // ImageFetch
			new OpData(1, 1, 3, 1), // ImageGather
			new OpData(1, 1, 3, 1), // ImageDrefGather
			new OpData(1, 1, 2, 1), // ImageRead
			new OpData(0, 0, 3, 1), // ImageWrite
			new OpData(1, 1, 1, 0), // Image
			new OpData(1, 1, 1, 0), // ImageQueryFormat
			new OpData(1, 1, 1, 0), // ImageQueryOrder
			new OpData(1, 1, 2, 0), // ImageQuerySizeLod
			new OpData(1, 1, 1, 0), // ImageQuerySize
			new OpData(1, 1, 2, 0), // ImageQueryLod
			new OpData(1, 1, 1, 0), // ImageQueryLevels
			new OpData(1, 1, 1, 0), // ImageQuerySamples
			new OpData(1, 1, 0, 0), // #108
			new OpData(1, 1, 1, 0), // ConvertFToU
			new OpData(1, 1, 1, 0), // ConvertFToS
			new OpData(1, 1, 1, 0), // ConvertSToF
			new OpData(1, 1, 1, 0), // ConvertUToF
			new OpData(1, 1, 1, 0), // UConvert
			new OpData(1, 1, 1, 0), // SConvert
			new OpData(1, 1, 1, 0), // FConvert
			new OpData(1, 1, 1, 0), // QuantizeToF16
			new OpData(1, 1, 1, 0), // ConvertPtrToU
			new OpData(1, 1, 1, 0), // SatConvertSToU
			new OpData(1, 1, 1, 0), // SatConvertUToS
			new OpData(1, 1, 1, 0), // ConvertUToPtr
			new OpData(1, 1, 1, 0), // PtrCastToGeneric
			new OpData(1, 1, 1, 0), // GenericCastToPtr
			new OpData(1, 1, 1, 1), // GenericCastToPtrExplicit
			new OpData(1, 1, 1, 0), // Bitcast
			new OpData(1, 1, 0, 0), // #125
			new OpData(1, 1, 1, 0), // SNegate
			new OpData(1, 1, 1, 0), // FNegate
			new OpData(1, 1, 2, 0), // IAdd
			new OpData(1, 1, 2, 0), // FAdd
			new OpData(1, 1, 2, 0), // ISub
			new OpData(1, 1, 2, 0), // FSub
			new OpData(1, 1, 2, 0), // IMul
			new OpData(1, 1, 2, 0), // FMul
			new OpData(1, 1, 2, 0), // UDiv
			new OpData(1, 1, 2, 0), // SDiv
			new OpData(1, 1, 2, 0), // FDiv
			new OpData(1, 1, 2, 0), // UMod
			new OpData(1, 1, 2, 0), // SRem
			new OpData(1, 1, 2, 0), // SMod
			new OpData(1, 1, 2, 0), // FRem
			new OpData(1, 1, 2, 0), // FMod
			new OpData(1, 1, 2, 0), // VectorTimesScalar
			new OpData(1, 1, 2, 0), // MatrixTimesScalar
			new OpData(1, 1, 2, 0), // VectorTimesMatrix
			new OpData(1, 1, 2, 0), // MatrixTimesVector
			new OpData(1, 1, 2, 0), // MatrixTimesMatrix
			new OpData(1, 1, 2, 0), // OuterProduct
			new OpData(1, 1, 2, 0), // Dot
			new OpData(1, 1, 2, 0), // IAddCarry
			new OpData(1, 1, 2, 0), // ISubBorrow
			new OpData(1, 1, 2, 0), // UMulExtended
			new OpData(1, 1, 2, 0), // SMulExtended
			new OpData(1, 1, 0, 0), // #153
			new OpData(1, 1, 1, 0), // Any
			new OpData(1, 1, 1, 0), // All
			new OpData(1, 1, 1, 0), // IsNan
			new OpData(1, 1, 1, 0), // IsInf
			new OpData(1, 1, 1, 0), // IsFinite
			new OpData(1, 1, 1, 0), // IsNormal
			new OpData(1, 1, 1, 0), // SignBitSet
			new OpData(1, 1, 2, 0), // LessOrGreater
			new OpData(1, 1, 2, 0), // Ordered
			new OpData(1, 1, 2, 0), // Unordered
			new OpData(1, 1, 2, 0), // LogicalEqual
			new OpData(1, 1, 2, 0), // LogicalNotEqual
			new OpData(1, 1, 2, 0), // LogicalOr
			new OpData(1, 1, 2, 0), // LogicalAnd
			new OpData(1, 1, 1, 0), // LogicalNot
			new OpData(1, 1, 3, 0), // Select
			new OpData(1, 1, 2, 0), // IEqual
			new OpData(1, 1, 2, 0), // INotEqual
			new OpData(1, 1, 2, 0), // UGreaterThan
			new OpData(1, 1, 2, 0), // SGreaterThan
			new OpData(1, 1, 2, 0), // UGreaterThanEqual
			new OpData(1, 1, 2, 0), // SGreaterThanEqual
			new OpData(1, 1, 2, 0), // ULessThan
			new OpData(1, 1, 2, 0), // SLessThan
			new OpData(1, 1, 2, 0), // ULessThanEqual
			new OpData(1, 1, 2, 0), // SLessThanEqual
			new OpData(1, 1, 2, 0), // FOrdEqual
			new OpData(1, 1, 2, 0), // FUnordEqual
			new OpData(1, 1, 2, 0), // FOrdNotEqual
			new OpData(1, 1, 2, 0), // FUnordNotEqual
			new OpData(1, 1, 2, 0), // FOrdLessThan
			new OpData(1, 1, 2, 0), // FUnordLessThan
			new OpData(1, 1, 2, 0), // FOrdGreaterThan
			new OpData(1, 1, 2, 0), // FUnordGreaterThan
			new OpData(1, 1, 2, 0), // FOrdLessThanEqual
			new OpData(1, 1, 2, 0), // FUnordLessThanEqual
			new OpData(1, 1, 2, 0), // FOrdGreaterThanEqual
			new OpData(1, 1, 2, 0), // FUnordGreaterThanEqual
			new OpData(1, 1, 0, 0), // #192
			new OpData(1, 1, 0, 0), // #193
			new OpData(1, 1, 2, 0), // ShiftRightLogical
			new OpData(1, 1, 2, 0), // ShiftRightArithmetic
			new OpData(1, 1, 2, 0), // ShiftLeftLogical
			new OpData(1, 1, 2, 0), // BitwiseOr
			new OpData(1, 1, 2, 0), // BitwiseXor
			new OpData(1, 1, 2, 0), // BitwiseAnd
			new OpData(1, 1, 1, 0), // Not
			new OpData(1, 1, 4, 0), // BitFieldInsert
			new OpData(1, 1, 3, 0), // BitFieldSExtract
			new OpData(1, 1, 3, 0), // BitFieldUExtract
			new OpData(1, 1, 1, 0), // BitReverse
			new OpData(1, 1, 1, 0), // BitCount
			new OpData(1, 1, 0, 0), // #206
			new OpData(1, 1, 0, 0), // DPdx
			new OpData(1, 1, 0, 0), // DPdy
			new OpData(1, 1, 0, 0), // Fwidth
			new OpData(1, 1, 0, 0), // DPdxFine
			new OpData(1, 1, 0, 0), // DPdyFine
			new OpData(1, 1, 0, 0), // FwidthFine
			new OpData(1, 1, 0, 0), // DPdxCoarse
			new OpData(1, 1, 0, 0), // DPdyCoarse
			new OpData(1, 1, 0, 0), // FwidthCoarse
			new OpData(1, 1, 0, 0), // #216
			new OpData(1, 1, 0, 0), // #217
			new OpData(0, 0, 0, 0), // EmitVertex
			new OpData(0, 0, 0, 0), // EndPrimitive
			new OpData(0, 0, 0, 0), // EmitStreamVertex
			new OpData(0, 0, 0, 0), // EndStreamPrimitive
			new OpData(1, 1, 0, 0), // #222
			new OpData(1, 1, 0, 0), // #223
			new OpData(0, 0, -3, 0), // ControlBarrier
			new OpData(0, 0, -2, 0), // MemoryBarrier
			new OpData(1, 1, 0, 0), // #226
			new OpData(1, 1, 0, 0), // AtomicLoad
			new OpData(0, 0, 0, 0), // AtomicStore
			new OpData(1, 1, 0, 0), // AtomicExchange
			new OpData(1, 1, 0, 0), // AtomicCompareExchange
			new OpData(1, 1, 0, 0), // AtomicCompareExchangeWeak
			new OpData(1, 1, 0, 0), // AtomicIIncrement
			new OpData(1, 1, 0, 0), // AtomicIDecrement
			new OpData(1, 1, 0, 0), // AtomicIAdd
			new OpData(1, 1, 0, 0), // AtomicISub
			new OpData(1, 1, 0, 0), // AtomicSMin
			new OpData(1, 1, 0, 0), // AtomicUMin
			new OpData(1, 1, 0, 0), // AtomicSMax
			new OpData(1, 1, 0, 0), // AtomicUMax
			new OpData(1, 1, 0, 0), // AtomicAnd
			new OpData(1, 1, 0, 0), // AtomicOr
			new OpData(1, 1, 0, 0), // AtomicXor
			new OpData(1, 1, 0, 0), // #243
			new OpData(1, 1, 0, 0), // #244
			new OpData(1, 1, 0, 0), // Phi
			new OpData(0, 0, -2, 1), // LoopMerge
			new OpData(0, 0, -1, 1), // SelectionMerge
			new OpData(1, 0, 0, 0), // Label
			new OpData(0, 0, -1, 0), // Branch
			new OpData(0, 0, -3, 1), // BranchConditional
			new OpData(0, 0, 0, 0), // Switch
			new OpData(0, 0, 0, 0), // Kill
			new OpData(0, 0, 0, 0), // Return
			new OpData(0, 0, 0, 0), // ReturnValue
			new OpData(0, 0, 0, 0), // Unreachable
			new OpData(0, 0, 0, 0), // LifetimeStart
			new OpData(0, 0, 0, 0), // LifetimeStop
			new OpData(1, 1, 0, 0), // #258
			new OpData(1, 1, 0, 0), // GroupAsyncCopy
			new OpData(0, 0, 0, 0), // GroupWaitEvents
			new OpData(1, 1, 0, 0), // GroupAll
			new OpData(1, 1, 0, 0), // GroupAny
			new OpData(1, 1, 0, 0), // GroupBroadcast
			new OpData(1, 1, 0, 0), // GroupIAdd
			new OpData(1, 1, 0, 0), // GroupFAdd
			new OpData(1, 1, 0, 0), // GroupFMin
			new OpData(1, 1, 0, 0), // GroupUMin
			new OpData(1, 1, 0, 0), // GroupSMin
			new OpData(1, 1, 0, 0), // GroupFMax
			new OpData(1, 1, 0, 0), // GroupUMax
			new OpData(1, 1, 0, 0), // GroupSMax
			new OpData(1, 1, 0, 0), // #272
			new OpData(1, 1, 0, 0), // #273
			new OpData(1, 1, 0, 0), // ReadPipe
			new OpData(1, 1, 0, 0), // WritePipe
			new OpData(1, 1, 0, 0), // ReservedReadPipe
			new OpData(1, 1, 0, 0), // ReservedWritePipe
			new OpData(1, 1, 0, 0), // ReserveReadPipePackets
			new OpData(1, 1, 0, 0), // ReserveWritePipePackets
			new OpData(0, 0, 0, 0), // CommitReadPipe
			new OpData(0, 0, 0, 0), // CommitWritePipe
			new OpData(1, 1, 0, 0), // IsValidReserveId
			new OpData(1, 1, 0, 0), // GetNumPipePackets
			new OpData(1, 1, 0, 0), // GetMaxPipePackets
			new OpData(1, 1, 0, 0), // GroupReserveReadPipePackets
			new OpData(1, 1, 0, 0), // GroupReserveWritePipePackets
			new OpData(0, 0, 0, 0), // GroupCommitReadPipe
			new OpData(0, 0, 0, 0), // GroupCommitWritePipe
			new OpData(1, 1, 0, 0), // #289
			new OpData(1, 1, 0, 0), // #290
			new OpData(1, 1, 0, 0), // EnqueueMarker
			new OpData(1, 1, 0, 0), // EnqueueKernel
			new OpData(1, 1, 0, 0), // GetKernelNDrangeSubGroupCount
			new OpData(1, 1, 0, 0), // GetKernelNDrangeMaxSubGroupSize
			new OpData(1, 1, 0, 0), // GetKernelWorkGroupSize
			new OpData(1, 1, 0, 0), // GetKernelPreferredWorkGroupSizeMultiple
			new OpData(0, 0, 0, 0), // RetainEvent
			new OpData(0, 0, 0, 0), // ReleaseEvent
			new OpData(1, 1, 0, 0), // CreateUserEvent
			new OpData(1, 1, 0, 0), // IsValidEvent
			new OpData(0, 0, 0, 0), // SetUserEventStatus
			new OpData(0, 0, 0, 0), // CaptureEventProfilingInfo
			new OpData(1, 1, 0, 0), // GetDefaultQueue
			new OpData(1, 1, 0, 0), // BuildNDRange
			new OpData(1, 1, 2, 1), // ImageSparseSampleImplicitLod
			new OpData(1, 1, 2, 1), // ImageSparseSampleExplicitLod
			new OpData(1, 1, 3, 1), // ImageSparseSampleDrefImplicitLod
			new OpData(1, 1, 3, 1), // ImageSparseSampleDrefExplicitLod
			new OpData(1, 1, 2, 1), // ImageSparseSampleProjImplicitLod
			new OpData(1, 1, 2, 1), // ImageSparseSampleProjExplicitLod
			new OpData(1, 1, 3, 1), // ImageSparseSampleProjDrefImplicitLod
			new OpData(1, 1, 3, 1), // ImageSparseSampleProjDrefExplicitLod
			new OpData(1, 1, 2, 1), // ImageSparseFetch
			new OpData(1, 1, 3, 1), // ImageSparseGather
			new OpData(1, 1, 3, 1), // ImageSparseDrefGather
			new OpData(1, 1, 1, 0), // ImageSparseTexelsResident
			new OpData(0, 0, 0, 0), // NoLine
			new OpData(1, 1, 0, 0), // AtomicFlagTestAndSet
			new OpData(0, 0, 0, 0), // AtomicFlagClear
			new OpData(1, 1, 0, 0), // ImageSparseRead
			new OpData(1, 1, 0, 0), // SizeOf
			new OpData(1, 1, 0, 0), // TypePipeStorage
			new OpData(1, 1, 0, 0), // ConstantPipeStorage
			new OpData(1, 1, 0, 0), // CreatePipeFromPipeStorage
			new OpData(1, 1, 0, 0), // GetKernelLocalSizeForSubgroupCount
			new OpData(1, 1, 0, 0), // GetKernelMaxNumSubgroups
			new OpData(1, 1, 0, 0), // TypeNamedBarrier
			new OpData(1, 1, 0, 1), // NamedBarrierInitialize
			new OpData(0, 0, -2, 1), // MemoryNamedBarrier
			new OpData(1, 1, 0, 0), // ModuleProcessed
		};
	};
}

```

`AssetStudioUtility/Smolv/SmolvDecoder.cs`:

```cs
using System;
using System.IO;
using System.Text;

namespace Smolv
{
	public static class SmolvDecoder
	{
		public static int GetDecodedBufferSize(byte[] data)
		{
			if (data == null)
			{
				throw new ArgumentNullException(nameof(data));
			}

			if (!CheckSmolHeader(data))
			{
				return 0;
			}

			int size = BitConverter.ToInt32(data, 5 * sizeof(uint));
			return size;
		}

		public static int GetDecodedBufferSize(Stream stream)
		{
			if (stream == null)
			{
				throw new ArgumentNullException(nameof(stream));
			}
			if (!stream.CanSeek)
			{
				throw new ArgumentException(nameof(stream));
			}
			if (stream.Position + HeaderSize > stream.Length)
			{
				return 0;
			}

			long initPosition = stream.Position;
			stream.Position += HeaderSize - sizeof(uint);
			int size = stream.ReadByte() | stream.ReadByte() << 8 | stream.ReadByte() << 16 | stream.ReadByte() << 24;
			stream.Position = initPosition;
			return size;
		}

		public static byte[] Decode(byte[] data)
		{
			if (data == null)
			{
				throw new ArgumentNullException(nameof(data));
			}

			int bufferSize = GetDecodedBufferSize(data);
			if (bufferSize == 0)
			{
				// invalid SMOL-V
				return null;
			}

			byte[] output = new byte[bufferSize];
			if (Decode(data, output))
			{
				return output;
			}

			return null;
		}

		public static bool Decode(byte[] data, byte[] output)
		{
			if (data == null)
			{
				throw new ArgumentNullException(nameof(data));
			}
			if (output == null)
			{
				throw new ArgumentNullException(nameof(output));
			}

			int bufferSize = GetDecodedBufferSize(data);
			if (bufferSize > output.Length)
			{
				return false;
			}

			using (MemoryStream outputStream = new MemoryStream(output))
			{
				return Decode(data, outputStream);
			}
		}

		public static bool Decode(byte[] data, Stream outputStream)
		{
			if (data == null)
			{
				throw new ArgumentNullException(nameof(data));
			}
			using (MemoryStream inputStream = new MemoryStream(data))
			{
				return Decode(inputStream, data.Length, outputStream);
			}
		}

		public static bool Decode(Stream inputStream, int inputSize, Stream outputStream)
		{
			if (inputStream == null)
			{
				throw new ArgumentNullException(nameof(inputStream));
			}
			if (outputStream == null)
			{
				throw new ArgumentNullException(nameof(outputStream));
			}
			if (inputStream.Length < HeaderSize)
			{
				return false;
			}

			using (BinaryReader input = new BinaryReader(inputStream, Encoding.UTF8, true))
			{
				using (BinaryWriter output = new BinaryWriter(outputStream, Encoding.UTF8, true))
				{
					long inputEndPosition = input.BaseStream.Position + inputSize;
					long outputStartPosition = output.BaseStream.Position;

					// Header
					output.Write(SpirVHeaderMagic);
					input.BaseStream.Position += sizeof(uint);
					uint version = input.ReadUInt32();
					output.Write(version);
					uint generator = input.ReadUInt32();
					output.Write(generator);
					int bound = input.ReadInt32();
					output.Write(bound);
					uint schema = input.ReadUInt32();
					output.Write(schema);
					int decodedSize = input.ReadInt32();

					// Body
					int prevResult = 0;
					int prevDecorate = 0;
					while (input.BaseStream.Position < inputEndPosition)
					{
						// read length + opcode
						if (!ReadLengthOp(input, out uint instrLen, out SpvOp op))
						{
							return false;
						}

						bool wasSwizzle = op == SpvOp.VectorShuffleCompact;
						if (wasSwizzle)
						{
							op = SpvOp.VectorShuffle;
						}
						output.Write((instrLen << 16) | (uint)op);

						uint ioffs = 1;
						// read type as varint, if we have it
						if (op.OpHasType())
						{
							if (!ReadVarint(input, out uint value))
							{
								return false;
							}

							output.Write(value);
							ioffs++;
						}

						// read result as delta+varint, if we have it
						if (op.OpHasResult())
						{
							if (!ReadVarint(input, out uint value))
							{
								return false;
							}

							int zds = prevResult + ZigDecode(value);
							output.Write(zds);
							prevResult = zds;
							ioffs++;
						}

						// Decorate: IDs relative to previous decorate
						if (op == SpvOp.Decorate || op == SpvOp.MemberDecorate)
						{
							if (!ReadVarint(input, out uint value))
							{
								return false;
							}

							int zds = prevDecorate + unchecked((int)value);
							output.Write(zds);
							prevDecorate = zds;
							ioffs++;
						}

						// Read this many IDs, that are relative to result ID
						int relativeCount = op.OpDeltaFromResult();
						bool inverted = false;
						if (relativeCount < 0)
						{
							inverted = true;
							relativeCount = -relativeCount;
						}
						for (int i = 0; i < relativeCount && ioffs < instrLen; ++i, ++ioffs)
						{
							if (!ReadVarint(input, out uint value))
							{
								return false;
							}

							int zd = inverted ? ZigDecode(value) : unchecked((int)value);
							output.Write(prevResult - zd);
						}

						if (wasSwizzle && instrLen <= 9)
						{
							uint swizzle = input.ReadByte();
							if (instrLen > 5) output.Write(swizzle >> 6);
							if (instrLen > 6) output.Write((swizzle >> 4) & 3);
							if (instrLen > 7) output.Write((swizzle >> 2) & 3);
							if (instrLen > 8) output.Write(swizzle & 3);
						}
						else if (op.OpVarRest())
						{
							// read rest of words with variable encoding
							for (; ioffs < instrLen; ++ioffs)
							{
								if (!ReadVarint(input, out uint value))
								{
									return false;
								}
								output.Write(value);
							}
						}
						else
						{
							// read rest of words without any encoding
							for (; ioffs < instrLen; ++ioffs)
							{
								if (input.BaseStream.Position + 4 > input.BaseStream.Length)
								{
									return false;
								}
								uint val = input.ReadUInt32();
								output.Write(val);
							}
						}
					}

					if (output.BaseStream.Position != outputStartPosition + decodedSize)
					{
						// something went wrong during decoding? we should have decoded to exact output size
						return false;
					}

					return true;
				}
			}
		}

		private static bool CheckSmolHeader(byte[] data)
		{
			if (!CheckGenericHeader(data, SmolHeaderMagic))
			{
				return false;
			}

			return true;
		}

		private static bool CheckGenericHeader(byte[] data, uint expectedMagic)
		{
			if (data == null)
			{
				return false;
			}
			if (data.Length < HeaderSize)
			{
				return false;
			}

			uint headerMagic = BitConverter.ToUInt32(data, 0 * sizeof(uint));
			if (headerMagic != expectedMagic)
			{
				return false;
			}

			uint headerVersion = BitConverter.ToUInt32(data, 1 * sizeof(uint));
			if (headerVersion < 0x00010000 || headerVersion > 0x00010300)
			{
				// only support 1.0 through 1.3
				return false;
			}

			return true;
		}

		private static bool ReadVarint(BinaryReader input, out uint value)
		{
			uint v = 0;
			int shift = 0;
			while (input.BaseStream.Position < input.BaseStream.Length)
			{
				byte b = input.ReadByte();
				v |= unchecked((uint)(b & 127) << shift);
				shift += 7;
				if ((b & 128) == 0)
				{
					break;
				}
			}

			value = v;
			// @TODO: report failures
			return true;
		}

		private static bool ReadLengthOp(BinaryReader input, out uint len, out SpvOp op)
		{
			len = default;
			op = default;
			if (!ReadVarint(input, out uint value))
			{
				return false;
			}
			len = ((value >> 20) << 4) | ((value >> 4) & 0xF);
			op = (SpvOp) (((value >> 4) & 0xFFF0) | (value & 0xF));

			op = RemapOp(op);
			len = DecodeLen(op, len);
			return true;
		}

		/// <summary>
		/// Remap most common Op codes (Load, Store, Decorate, VectorShuffle etc.) to be in &lt; 16 range, for 
		/// more compact varint encoding. This basically swaps rarely used op values that are &lt; 16 with the
		/// ones that are common.
		/// </summary>
		private static SpvOp RemapOp(SpvOp op)
		{
			switch (op)
			{
				// 0: 24%
				case SpvOp.Decorate:
					return SpvOp.Nop;
				case SpvOp.Nop:
					return SpvOp.Decorate;

				// 1: 17%
				case SpvOp.Load:
					return SpvOp.Undef;
				case SpvOp.Undef:
					return SpvOp.Load;

				// 2: 9%
				case SpvOp.Store:
					return SpvOp.SourceContinued;
				case SpvOp.SourceContinued:
					return SpvOp.Store;

				// 3: 7.2%
				case SpvOp.AccessChain:
					return SpvOp.Source;
				case SpvOp.Source:
					return SpvOp.AccessChain;

				// 4: 5.0%
				// Name - already small enum value - 5: 4.4%
				// MemberName - already small enum value - 6: 2.9% 
				case SpvOp.VectorShuffle:
					return SpvOp.SourceExtension;
				case SpvOp.SourceExtension:
					return SpvOp.VectorShuffle;

				// 7: 4.0%
				case SpvOp.MemberDecorate:
					return SpvOp.String;
				case SpvOp.String:
					return SpvOp.MemberDecorate;

				// 8: 0.9%
				case SpvOp.Label:
					return SpvOp.Line;
				case SpvOp.Line:
					return SpvOp.Label;

				// 9: 3.9%
				case SpvOp.Variable:
					return (SpvOp)9;
				case (SpvOp)9:
					return SpvOp.Variable;

				// 10: 3.9%
				case SpvOp.FMul:
					return SpvOp.Extension;
				case SpvOp.Extension:
					return SpvOp.FMul;

				// 11: 2.5%
				// ExtInst - already small enum value - 12: 1.2%
				// VectorShuffleCompact - already small enum value - used for compact shuffle encoding
				case SpvOp.FAdd:
					return SpvOp.ExtInstImport;
				case SpvOp.ExtInstImport:
					return SpvOp.FAdd;

				// 14: 2.2%
				case SpvOp.TypePointer:
					return SpvOp.MemoryModel;
				case SpvOp.MemoryModel:
					return SpvOp.TypePointer;

				// 15: 1.1%
				case SpvOp.FNegate:
					return SpvOp.EntryPoint;
				case SpvOp.EntryPoint:
					return SpvOp.FNegate;
			}
			return op;
		}

		private static uint DecodeLen(SpvOp op, uint len)
		{
			len++;
			switch (op)
			{
				case SpvOp.VectorShuffle:
					len += 4;
					break;
				case SpvOp.VectorShuffleCompact:
					len += 4;
					break;
				case SpvOp.Decorate:
					len += 2;
					break;
				case SpvOp.Load:
					len += 3;
					break;
				case SpvOp.AccessChain:
					len += 3;
					break;
			}
			return len;
		}

		private static int DecorationExtraOps(int dec)
		{
			// RelaxedPrecision, Block..ColMajor
			if (dec == 0 || (dec >= 2 && dec <= 5))
			{
				return 0;
			}
			// Stream..XfbStride
			if (dec >= 29 && dec <= 37)
			{
				return 1;
			}

			// unknown, encode length
			return -1;
		}

		private static int ZigDecode(uint u)
		{
			return (u & 1) != 0 ? unchecked((int)(~(u >> 1))) : unchecked((int)(u >> 1));
		}

		public const uint SpirVHeaderMagic = 0x07230203;
		/// <summary>
		/// 'SMOL' ascii
		/// </summary>
		public const uint SmolHeaderMagic = 0x534D4F4C;

		private const int HeaderSize = 6 * sizeof(uint);
	}
}

```

`AssetStudioUtility/Smolv/SpvOp.cs`:

```cs
namespace Smolv
{
	public enum SpvOp
	{
		Nop = 0,
		Undef = 1,
		SourceContinued = 2,
		Source = 3,
		SourceExtension = 4,
		Name = 5,
		MemberName = 6,
		String = 7,
		Line = 8,
		Extension = 10,
		ExtInstImport = 11,
		ExtInst = 12,
		/// <summary>
		/// Not in SPIR-V, added for SMOL-V!
		/// </summary>
		VectorShuffleCompact = 13,
		MemoryModel = 14,
		EntryPoint = 15,
		ExecutionMode = 16,
		Capability = 17,
		TypeVoid = 19,
		TypeBool = 20,
		TypeInt = 21,
		TypeFloat = 22,
		TypeVector = 23,
		TypeMatrix = 24,
		TypeImage = 25,
		TypeSampler = 26,
		TypeSampledImage = 27,
		TypeArray = 28,
		TypeRuntimeArray = 29,
		TypeStruct = 30,
		TypeOpaque = 31,
		TypePointer = 32,
		TypeFunction = 33,
		TypeEvent = 34,
		TypeDeviceEvent = 35,
		TypeReserveId = 36,
		TypeQueue = 37,
		TypePipe = 38,
		TypeForwardPointer = 39,
		ConstantTrue = 41,
		ConstantFalse = 42,
		Constant = 43,
		ConstantComposite = 44,
		ConstantSampler = 45,
		ConstantNull = 46,
		SpecConstantTrue = 48,
		SpecConstantFalse = 49,
		SpecConstant = 50,
		SpecConstantComposite = 51,
		SpecConstantOp = 52,
		Function = 54,
		FunctionParameter = 55,
		FunctionEnd = 56,
		FunctionCall = 57,
		Variable = 59,
		ImageTexelPointer = 60,
		Load = 61,
		Store = 62,
		CopyMemory = 63,
		CopyMemorySized = 64,
		AccessChain = 65,
		InBoundsAccessChain = 66,
		PtrAccessChain = 67,
		ArrayLength = 68,
		GenericPtrMemSemantics = 69,
		InBoundsPtrAccessChain = 70,
		Decorate = 71,
		MemberDecorate = 72,
		DecorationGroup = 73,
		GroupDecorate = 74,
		GroupMemberDecorate = 75,
		VectorExtractDynamic = 77,
		VectorInsertDynamic = 78,
		VectorShuffle = 79,
		CompositeConstruct = 80,
		CompositeExtract = 81,
		CompositeInsert = 82,
		CopyObject = 83,
		Transpose = 84,
		SampledImage = 86,
		ImageSampleImplicitLod = 87,
		ImageSampleExplicitLod = 88,
		ImageSampleDrefImplicitLod = 89,
		ImageSampleDrefExplicitLod = 90,
		ImageSampleProjImplicitLod = 91,
		ImageSampleProjExplicitLod = 92,
		ImageSampleProjDrefImplicitLod = 93,
		ImageSampleProjDrefExplicitLod = 94,
		ImageFetch = 95,
		ImageGather = 96,
		ImageDrefGather = 97,
		ImageRead = 98,
		ImageWrite = 99,
		Image = 100,
		ImageQueryFormat = 101,
		ImageQueryOrder = 102,
		ImageQuerySizeLod = 103,
		ImageQuerySize = 104,
		ImageQueryLod = 105,
		ImageQueryLevels = 106,
		ImageQuerySamples = 107,
		ConvertFToU = 109,
		ConvertFToS = 110,
		ConvertSToF = 111,
		ConvertUToF = 112,
		UConvert = 113,
		SConvert = 114,
		FConvert = 115,
		QuantizeToF16 = 116,
		ConvertPtrToU = 117,
		SatConvertSToU = 118,
		SatConvertUToS = 119,
		ConvertUToPtr = 120,
		PtrCastToGeneric = 121,
		GenericCastToPtr = 122,
		GenericCastToPtrExplicit = 123,
		Bitcast = 124,
		SNegate = 126,
		FNegate = 127,
		IAdd = 128,
		FAdd = 129,
		ISub = 130,
		FSub = 131,
		IMul = 132,
		FMul = 133,
		UDiv = 134,
		SDiv = 135,
		FDiv = 136,
		UMod = 137,
		SRem = 138,
		SMod = 139,
		FRem = 140,
		FMod = 141,
		VectorTimesScalar = 142,
		MatrixTimesScalar = 143,
		VectorTimesMatrix = 144,
		MatrixTimesVector = 145,
		MatrixTimesMatrix = 146,
		OuterProduct = 147,
		Dot = 148,
		IAddCarry = 149,
		ISubBorrow = 150,
		UMulExtended = 151,
		SMulExtended = 152,
		Any = 154,
		All = 155,
		IsNan = 156,
		IsInf = 157,
		IsFinite = 158,
		IsNormal = 159,
		SignBitSet = 160,
		LessOrGreater = 161,
		Ordered = 162,
		Unordered = 163,
		LogicalEqual = 164,
		LogicalNotEqual = 165,
		LogicalOr = 166,
		LogicalAnd = 167,
		LogicalNot = 168,
		Select = 169,
		IEqual = 170,
		INotEqual = 171,
		UGreaterThan = 172,
		SGreaterThan = 173,
		UGreaterThanEqual = 174,
		SGreaterThanEqual = 175,
		ULessThan = 176,
		SLessThan = 177,
		ULessThanEqual = 178,
		SLessThanEqual = 179,
		FOrdEqual = 180,
		FUnordEqual = 181,
		FOrdNotEqual = 182,
		FUnordNotEqual = 183,
		FOrdLessThan = 184,
		FUnordLessThan = 185,
		FOrdGreaterThan = 186,
		FUnordGreaterThan = 187,
		FOrdLessThanEqual = 188,
		FUnordLessThanEqual = 189,
		FOrdGreaterThanEqual = 190,
		FUnordGreaterThanEqual = 191,
		ShiftRightLogical = 194,
		ShiftRightArithmetic = 195,
		ShiftLeftLogical = 196,
		BitwiseOr = 197,
		BitwiseXor = 198,
		BitwiseAnd = 199,
		Not = 200,
		BitFieldInsert = 201,
		BitFieldSExtract = 202,
		BitFieldUExtract = 203,
		BitReverse = 204,
		BitCount = 205,
		DPdx = 207,
		DPdy = 208,
		Fwidth = 209,
		DPdxFine = 210,
		DPdyFine = 211,
		FwidthFine = 212,
		DPdxCoarse = 213,
		DPdyCoarse = 214,
		FwidthCoarse = 215,
		EmitVertex = 218,
		EndPrimitive = 219,
		EmitStreamVertex = 220,
		EndStreamPrimitive = 221,
		ControlBarrier = 224,
		MemoryBarrier = 225,
		AtomicLoad = 227,
		AtomicStore = 228,
		AtomicExchange = 229,
		AtomicCompareExchange = 230,
		AtomicCompareExchangeWeak = 231,
		AtomicIIncrement = 232,
		AtomicIDecrement = 233,
		AtomicIAdd = 234,
		AtomicISub = 235,
		AtomicSMin = 236,
		AtomicUMin = 237,
		AtomicSMax = 238,
		AtomicUMax = 239,
		AtomicAnd = 240,
		AtomicOr = 241,
		AtomicXor = 242,
		Phi = 245,
		LoopMerge = 246,
		SelectionMerge = 247,
		Label = 248,
		Branch = 249,
		BranchConditional = 250,
		Switch = 251,
		Kill = 252,
		Return = 253,
		ReturnValue = 254,
		Unreachable = 255,
		LifetimeStart = 256,
		LifetimeStop = 257,
		GroupAsyncCopy = 259,
		GroupWaitEvents = 260,
		GroupAll = 261,
		GroupAny = 262,
		GroupBroadcast = 263,
		GroupIAdd = 264,
		GroupFAdd = 265,
		GroupFMin = 266,
		GroupUMin = 267,
		GroupSMin = 268,
		GroupFMax = 269,
		GroupUMax = 270,
		GroupSMax = 271,
		ReadPipe = 274,
		WritePipe = 275,
		ReservedReadPipe = 276,
		ReservedWritePipe = 277,
		ReserveReadPipePackets = 278,
		ReserveWritePipePackets = 279,
		CommitReadPipe = 280,
		CommitWritePipe = 281,
		IsValidReserveId = 282,
		GetNumPipePackets = 283,
		GetMaxPipePackets = 284,
		GroupReserveReadPipePackets = 285,
		GroupReserveWritePipePackets = 286,
		GroupCommitReadPipe = 287,
		GroupCommitWritePipe = 288,
		EnqueueMarker = 291,
		EnqueueKernel = 292,
		GetKernelNDrangeSubGroupCount = 293,
		GetKernelNDrangeMaxSubGroupSize = 294,
		GetKernelWorkGroupSize = 295,
		GetKernelPreferredWorkGroupSizeMultiple = 296,
		RetainEvent = 297,
		ReleaseEvent = 298,
		CreateUserEvent = 299,
		IsValidEvent = 300,
		SetUserEventStatus = 301,
		CaptureEventProfilingInfo = 302,
		GetDefaultQueue = 303,
		BuildNDRange = 304,
		ImageSparseSampleImplicitLod = 305,
		ImageSparseSampleExplicitLod = 306,
		ImageSparseSampleDrefImplicitLod = 307,
		ImageSparseSampleDrefExplicitLod = 308,
		ImageSparseSampleProjImplicitLod = 309,
		ImageSparseSampleProjExplicitLod = 310,
		ImageSparseSampleProjDrefImplicitLod = 311,
		ImageSparseSampleProjDrefExplicitLod = 312,
		ImageSparseFetch = 313,
		ImageSparseGather = 314,
		ImageSparseDrefGather = 315,
		ImageSparseTexelsResident = 316,
		NoLine = 317,
		AtomicFlagTestAndSet = 318,
		AtomicFlagClear = 319,
		ImageSparseRead = 320,
		SizeOf = 321,
		TypePipeStorage = 322,
		ConstantPipeStorage = 323,
		CreatePipeFromPipeStorage = 324,
		GetKernelLocalSizeForSubgroupCount = 325,
		GetKernelMaxNumSubgroups = 326,
		TypeNamedBarrier = 327,
		NamedBarrierInitialize = 328,
		MemoryNamedBarrier = 329,
		ModuleProcessed = 330,

		KnownOpsCount,
	}

	public static class SpvOpExtensions
	{
		public static bool OpHasResult(this SpvOp _this)
		{
			if (_this < 0 || _this >= SpvOp.KnownOpsCount)
			{
				return false;
			}
			return OpData.SpirvOpData[(int)_this].hasResult != 0;
		}

		public static bool OpHasType(this SpvOp _this)
		{
			if (_this < 0 || _this >= SpvOp.KnownOpsCount)
			{
				return false;
			}
			return OpData.SpirvOpData[(int)_this].hasType != 0;
		}

		public static int OpDeltaFromResult(this SpvOp _this)
		{
			if (_this < 0 || _this >= SpvOp.KnownOpsCount)
			{
				return 0;
			}
			return OpData.SpirvOpData[(int)_this].deltaFromResult;
		}

		public static bool OpVarRest(this SpvOp _this)
		{
			if (_this < 0 || _this >= SpvOp.KnownOpsCount)
			{
				return false;
			}
			return OpData.SpirvOpData[(int)_this].varrest != 0;
		}

		public static bool OpDebugInfo(this SpvOp _this)
		{
			return
				_this == SpvOp.SourceContinued ||
				_this == SpvOp.Source ||
				_this == SpvOp.SourceExtension ||
				_this == SpvOp.Name ||
				_this == SpvOp.MemberName ||
				_this == SpvOp.String ||
				_this == SpvOp.Line ||
				_this == SpvOp.NoLine ||
				_this == SpvOp.ModuleProcessed;
		}
	}
}

```

`AssetStudioUtility/SpirVShaderConverter.cs`:

```cs
using Smolv;
using SpirV;
using System;
using System.IO;
using System.Text;

namespace AssetStudio
{
    public static class SpirVShaderConverter
    {
        public static string Convert(byte[] m_ProgramCode)
        {
            var sb = new StringBuilder();
            using (var ms = new MemoryStream(m_ProgramCode))
            {
                using (var reader = new BinaryReader(ms))
                {
                    int requirements = reader.ReadInt32();
                    int minOffset = m_ProgramCode.Length;
                    int snippetCount = 5;
                    /*if (version[0] > 2019 || (version[0] == 2019 && version[1] >= 3)) //2019.3 and up
                    {
                        snippetCount = 6;
                    }*/
                    for (int i = 0; i < snippetCount; i++)
                    {
                        if (reader.BaseStream.Position >= minOffset)
                        {
                            break;
                        }

                        int offset = reader.ReadInt32();
                        int size = reader.ReadInt32();
                        if (size > 0)
                        {
                            if (offset < minOffset)
                            {
                                minOffset = offset;
                            }
                            var pos = ms.Position;
                            sb.Append(ExportSnippet(ms, offset, size));
                            ms.Position = pos;
                        }
                    }
                }
            }
            return sb.ToString();
        }

        private static string ExportSnippet(Stream stream, int offset, int size)
        {
            stream.Position = offset;
            int decodedSize = SmolvDecoder.GetDecodedBufferSize(stream);
            if (decodedSize == 0)
            {
                throw new Exception("Invalid SMOL-V shader header");
            }
            using (var decodedStream = new MemoryStream(new byte[decodedSize]))
            {
                if (SmolvDecoder.Decode(stream, size, decodedStream))
                {
                    decodedStream.Position = 0;
                    var module = Module.ReadFrom(decodedStream);
                    var disassembler = new Disassembler();
                    return disassembler.Disassemble(module, DisassemblyOptions.Default).Replace("\r\n", "\n");
                }
                else
                {
                    throw new Exception("Unable to decode SMOL-V shader");
                }
            }
        }
    }
}

```

`AssetStudioUtility/SpriteHelper.cs`:

```cs
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Drawing;
using SixLabors.ImageSharp.Drawing.Processing;
using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp.Processing;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;

namespace AssetStudio
{
    public static class SpriteHelper
    {
        public static Image<Bgra32> GetImage(this Sprite m_Sprite)
        {
            if (m_Sprite.m_SpriteAtlas != null && m_Sprite.m_SpriteAtlas.TryGet(out var m_SpriteAtlas))
            {
                if (m_SpriteAtlas.m_RenderDataMap.TryGetValue(m_Sprite.m_RenderDataKey, out var spriteAtlasData) && spriteAtlasData.texture.TryGet(out var m_Texture2D))
                {
                    return CutImage(m_Sprite, m_Texture2D, spriteAtlasData.textureRect, spriteAtlasData.textureRectOffset, spriteAtlasData.downscaleMultiplier, spriteAtlasData.settingsRaw);
                }
            }
            else
            {
                if (m_Sprite.m_RD.texture.TryGet(out var m_Texture2D))
                {
                    return CutImage(m_Sprite, m_Texture2D, m_Sprite.m_RD.textureRect, m_Sprite.m_RD.textureRectOffset, m_Sprite.m_RD.downscaleMultiplier, m_Sprite.m_RD.settingsRaw);
                }
            }
            return null;
        }

        private static Image<Bgra32> CutImage(Sprite m_Sprite, Texture2D m_Texture2D, Rectf textureRect, Vector2 textureRectOffset, float downscaleMultiplier, SpriteSettings settingsRaw)
        {
            var originalImage = m_Texture2D.ConvertToImage(false);
            if (originalImage != null)
            {
                using (originalImage)
                {
                    if (downscaleMultiplier > 0f && downscaleMultiplier != 1f)
                    {
                        var width = (int)(m_Texture2D.m_Width / downscaleMultiplier);
                        var height = (int)(m_Texture2D.m_Height / downscaleMultiplier);
                        originalImage.Mutate(x => x.Resize(width, height));
                    }
                    var rectX = (int)Math.Floor(textureRect.x);
                    var rectY = (int)Math.Floor(textureRect.y);
                    var rectRight = (int)Math.Ceiling(textureRect.x + textureRect.width);
                    var rectBottom = (int)Math.Ceiling(textureRect.y + textureRect.height);
                    rectRight = Math.Min(rectRight, originalImage.Width);
                    rectBottom = Math.Min(rectBottom, originalImage.Height);
                    var rect = new Rectangle(rectX, rectY, rectRight - rectX, rectBottom - rectY);
                    var spriteImage = originalImage.Clone(x => x.Crop(rect));
                    if (settingsRaw.packed == 1)
                    {
                        //RotateAndFlip
                        switch (settingsRaw.packingRotation)
                        {
                            case SpritePackingRotation.FlipHorizontal:
                                spriteImage.Mutate(x => x.Flip(FlipMode.Horizontal));
                                break;
                            case SpritePackingRotation.FlipVertical:
                                spriteImage.Mutate(x => x.Flip(FlipMode.Vertical));
                                break;
                            case SpritePackingRotation.Rotate180:
                                spriteImage.Mutate(x => x.Rotate(180));
                                break;
                            case SpritePackingRotation.Rotate90:
                                spriteImage.Mutate(x => x.Rotate(270));
                                break;
                        }
                    }

                    //Tight
                    if (settingsRaw.packingMode == SpritePackingMode.Tight)
                    {
                        try
                        {
                            var triangles = GetTriangles(m_Sprite.m_RD);
                            var polygons = triangles.Select(x => new Polygon(new LinearLineSegment(x.Select(y => new PointF(y.X, y.Y)).ToArray()))).ToArray();
                            IPathCollection path = new PathCollection(polygons);
                            var matrix = Matrix3x2.CreateScale(m_Sprite.m_PixelsToUnits);
                            matrix *= Matrix3x2.CreateTranslation(m_Sprite.m_Rect.width * m_Sprite.m_Pivot.X - textureRectOffset.X, m_Sprite.m_Rect.height * m_Sprite.m_Pivot.Y - textureRectOffset.Y);
                            path = path.Transform(matrix);
                            var graphicsOptions = new GraphicsOptions
                            {
                                Antialias = false,
                                AlphaCompositionMode = PixelAlphaCompositionMode.DestOut
                            };
                            var options = new DrawingOptions
                            {
                                GraphicsOptions = graphicsOptions
                            };
                            using (var mask = new Image<Bgra32>(rect.Width, rect.Height, SixLabors.ImageSharp.Color.Black))
                            {
                                mask.Mutate(x => x.Fill(options, SixLabors.ImageSharp.Color.Red, path));
                                var bursh = new ImageBrush(mask);
                                spriteImage.Mutate(x => x.Fill(graphicsOptions, bursh));
                                spriteImage.Mutate(x => x.Flip(FlipMode.Vertical));
                                return spriteImage;
                            }
                        }
                        catch
                        {
                            // ignored
                        }
                    }

                    //Rectangle
                    spriteImage.Mutate(x => x.Flip(FlipMode.Vertical));
                    return spriteImage;
                }
            }

            return null;
        }

        private static Vector2[][] GetTriangles(SpriteRenderData m_RD)
        {
            if (m_RD.vertices != null) //5.6 down
            {
                var vertices = m_RD.vertices.Select(x => (Vector2)x.pos).ToArray();
                var triangleCount = m_RD.indices.Length / 3;
                var triangles = new Vector2[triangleCount][];
                for (int i = 0; i < triangleCount; i++)
                {
                    var first = m_RD.indices[i * 3];
                    var second = m_RD.indices[i * 3 + 1];
                    var third = m_RD.indices[i * 3 + 2];
                    var triangle = new[] { vertices[first], vertices[second], vertices[third] };
                    triangles[i] = triangle;
                }
                return triangles;
            }
            else //5.6 and up
            {
                var triangles = new List<Vector2[]>();
                var m_VertexData = m_RD.m_VertexData;
                var m_Channel = m_VertexData.m_Channels[0]; //kShaderChannelVertex
                var m_Stream = m_VertexData.m_Streams[m_Channel.stream];
                using (var vertexReader = new BinaryReader(new MemoryStream(m_VertexData.m_DataSize)))
                {
                    using (var indexReader = new BinaryReader(new MemoryStream(m_RD.m_IndexBuffer)))
                    {
                        foreach (var subMesh in m_RD.m_SubMeshes)
                        {
                            vertexReader.BaseStream.Position = m_Stream.offset + subMesh.firstVertex * m_Stream.stride + m_Channel.offset;

                            var vertices = new Vector2[subMesh.vertexCount];
                            for (int v = 0; v < subMesh.vertexCount; v++)
                            {
                                vertices[v] = vertexReader.ReadVector3();
                                vertexReader.BaseStream.Position += m_Stream.stride - 12;
                            }

                            indexReader.BaseStream.Position = subMesh.firstByte;

                            var triangleCount = subMesh.indexCount / 3u;
                            for (int i = 0; i < triangleCount; i++)
                            {
                                var first = indexReader.ReadUInt16() - subMesh.firstVertex;
                                var second = indexReader.ReadUInt16() - subMesh.firstVertex;
                                var third = indexReader.ReadUInt16() - subMesh.firstVertex;
                                var triangle = new[] { vertices[first], vertices[second], vertices[third] };
                                triangles.Add(triangle);
                            }
                        }
                    }
                }
                return triangles.ToArray();
            }
        }
    }
}

```

`AssetStudioUtility/Texture2DConverter.cs`:

```cs
using System;
using System.Runtime.CompilerServices;
using Texture2DDecoder;

namespace AssetStudio
{
    public class Texture2DConverter
    {
        private ResourceReader reader;
        private int m_Width;
        private int m_Height;
        private TextureFormat m_TextureFormat;
        private int[] version;
        private BuildTarget platform;
        private int outPutSize;

        public Texture2DConverter(Texture2D m_Texture2D)
        {
            reader = m_Texture2D.image_data;
            m_Width = m_Texture2D.m_Width;
            m_Height = m_Texture2D.m_Height;
            m_TextureFormat = m_Texture2D.m_TextureFormat;
            version = m_Texture2D.version;
            platform = m_Texture2D.platform;
            outPutSize = m_Width * m_Height * 4;
        }

        public bool DecodeTexture2D(byte[] bytes)
        {
            if (reader.Size == 0 || m_Width == 0 || m_Height == 0)
            {
                return false;
            }
            var flag = false;
            var buff = BigArrayPool<byte>.Shared.Rent(reader.Size);
            reader.GetData(buff);
            switch (m_TextureFormat)
            {
                case TextureFormat.Alpha8: //test pass
                    flag = DecodeAlpha8(buff, bytes);
                    break;
                case TextureFormat.ARGB4444: //test pass
                    SwapBytesForXbox(buff);
                    flag = DecodeARGB4444(buff, bytes);
                    break;
                case TextureFormat.RGB24: //test pass
                    flag = DecodeRGB24(buff, bytes);
                    break;
                case TextureFormat.RGBA32: //test pass
                    flag = DecodeRGBA32(buff, bytes);
                    break;
                case TextureFormat.ARGB32: //test pass
                    flag = DecodeARGB32(buff, bytes);
                    break;
                case TextureFormat.RGB565: //test pass
                    SwapBytesForXbox(buff);
                    flag = DecodeRGB565(buff, bytes);
                    break;
                case TextureFormat.R16: //test pass
                    flag = DecodeR16(buff, bytes);
                    break;
                case TextureFormat.DXT1: //test pass
                    SwapBytesForXbox(buff);
                    flag = DecodeDXT1(buff, bytes);
                    break;
                case TextureFormat.DXT3:
                    break;
                case TextureFormat.DXT5: //test pass
                    SwapBytesForXbox(buff);
                    flag = DecodeDXT5(buff, bytes);
                    break;
                case TextureFormat.RGBA4444: //test pass
                    flag = DecodeRGBA4444(buff, bytes);
                    break;
                case TextureFormat.BGRA32: //test pass
                    flag = DecodeBGRA32(buff, bytes);
                    break;
                case TextureFormat.RHalf:
                    flag = DecodeRHalf(buff, bytes);
                    break;
                case TextureFormat.RGHalf:
                    flag = DecodeRGHalf(buff, bytes);
                    break;
                case TextureFormat.RGBAHalf: //test pass
                    flag = DecodeRGBAHalf(buff, bytes);
                    break;
                case TextureFormat.RFloat:
                    flag = DecodeRFloat(buff, bytes);
                    break;
                case TextureFormat.RGFloat:
                    flag = DecodeRGFloat(buff, bytes);
                    break;
                case TextureFormat.RGBAFloat:
                    flag = DecodeRGBAFloat(buff, bytes);
                    break;
                case TextureFormat.YUY2: //test pass
                    flag = DecodeYUY2(buff, bytes);
                    break;
                case TextureFormat.RGB9e5Float: //test pass
                    flag = DecodeRGB9e5Float(buff, bytes);
                    break;
                case TextureFormat.BC6H: //test pass
                    flag = DecodeBC6H(buff, bytes);
                    break;
                case TextureFormat.BC7: //test pass
                    flag = DecodeBC7(buff, bytes);
                    break;
                case TextureFormat.BC4: //test pass
                    flag = DecodeBC4(buff, bytes);
                    break;
                case TextureFormat.BC5: //test pass
                    flag = DecodeBC5(buff, bytes);
                    break;
                case TextureFormat.DXT1Crunched: //test pass
                    flag = DecodeDXT1Crunched(buff, bytes);
                    break;
                case TextureFormat.DXT5Crunched: //test pass
                    flag = DecodeDXT5Crunched(buff, bytes);
                    break;
                case TextureFormat.PVRTC_RGB2: //test pass
                case TextureFormat.PVRTC_RGBA2: //test pass
                    flag = DecodePVRTC(buff, bytes, true);
                    break;
                case TextureFormat.PVRTC_RGB4: //test pass
                case TextureFormat.PVRTC_RGBA4: //test pass
                    flag = DecodePVRTC(buff, bytes, false);
                    break;
                case TextureFormat.ETC_RGB4: //test pass
                case TextureFormat.ETC_RGB4_3DS:
                    flag = DecodeETC1(buff, bytes);
                    break;
                case TextureFormat.ATC_RGB4: //test pass
                    flag = DecodeATCRGB4(buff, bytes);
                    break;
                case TextureFormat.ATC_RGBA8: //test pass
                    flag = DecodeATCRGBA8(buff, bytes);
                    break;
                case TextureFormat.EAC_R: //test pass
                    flag = DecodeEACR(buff, bytes);
                    break;
                case TextureFormat.EAC_R_SIGNED:
                    flag = DecodeEACRSigned(buff, bytes);
                    break;
                case TextureFormat.EAC_RG: //test pass
                    flag = DecodeEACRG(buff, bytes);
                    break;
                case TextureFormat.EAC_RG_SIGNED:
                    flag = DecodeEACRGSigned(buff, bytes);
                    break;
                case TextureFormat.ETC2_RGB: //test pass
                    flag = DecodeETC2(buff, bytes);
                    break;
                case TextureFormat.ETC2_RGBA1: //test pass
                    flag = DecodeETC2A1(buff, bytes);
                    break;
                case TextureFormat.ETC2_RGBA8: //test pass
                case TextureFormat.ETC_RGBA8_3DS:
                    flag = DecodeETC2A8(buff, bytes);
                    break;
                case TextureFormat.ASTC_RGB_4x4: //test pass
                case TextureFormat.ASTC_RGBA_4x4: //test pass
                case TextureFormat.ASTC_HDR_4x4: //test pass
                    flag = DecodeASTC(buff, bytes, 4);
                    break;
                case TextureFormat.ASTC_RGB_5x5: //test pass
                case TextureFormat.ASTC_RGBA_5x5: //test pass
                case TextureFormat.ASTC_HDR_5x5: //test pass
                    flag = DecodeASTC(buff, bytes, 5);
                    break;
                case TextureFormat.ASTC_RGB_6x6: //test pass
                case TextureFormat.ASTC_RGBA_6x6: //test pass
                case TextureFormat.ASTC_HDR_6x6: //test pass
                    flag = DecodeASTC(buff, bytes, 6);
                    break;
                case TextureFormat.ASTC_RGB_8x8: //test pass
                case TextureFormat.ASTC_RGBA_8x8: //test pass
                case TextureFormat.ASTC_HDR_8x8: //test pass
                    flag = DecodeASTC(buff, bytes, 8);
                    break;
                case TextureFormat.ASTC_RGB_10x10: //test pass
                case TextureFormat.ASTC_RGBA_10x10: //test pass
                case TextureFormat.ASTC_HDR_10x10: //test pass
                    flag = DecodeASTC(buff, bytes, 10);
                    break;
                case TextureFormat.ASTC_RGB_12x12: //test pass
                case TextureFormat.ASTC_RGBA_12x12: //test pass
                case TextureFormat.ASTC_HDR_12x12: //test pass
                    flag = DecodeASTC(buff, bytes, 12);
                    break;
                case TextureFormat.RG16: //test pass
                    flag = DecodeRG16(buff, bytes);
                    break;
                case TextureFormat.R8: //test pass
                    flag = DecodeR8(buff, bytes);
                    break;
                case TextureFormat.ETC_RGB4Crunched: //test pass
                    flag = DecodeETC1Crunched(buff, bytes);
                    break;
                case TextureFormat.ETC2_RGBA8Crunched: //test pass
                    flag = DecodeETC2A8Crunched(buff, bytes);
                    break;
                case TextureFormat.RG32: //test pass
                    flag = DecodeRG32(buff, bytes);
                    break;
                case TextureFormat.RGB48: //test pass
                    flag = DecodeRGB48(buff, bytes);
                    break;
                case TextureFormat.RGBA64: //test pass
                    flag = DecodeRGBA64(buff, bytes);
                    break;
            }
            BigArrayPool<byte>.Shared.Return(buff);
            return flag;
        }

        private void SwapBytesForXbox(byte[] image_data)
        {
            if (platform == BuildTarget.XBOX360)
            {
                for (var i = 0; i < reader.Size / 2; i++)
                {
                    var b = image_data[i * 2];
                    image_data[i * 2] = image_data[i * 2 + 1];
                    image_data[i * 2 + 1] = b;
                }
            }
        }

        private bool DecodeAlpha8(byte[] image_data, byte[] buff)
        {
            var size = m_Width * m_Height;
            var span = new Span<byte>(buff);
            span.Fill(0xFF);
            for (var i = 0; i < size; i++)
            {
                buff[i * 4 + 3] = image_data[i];
            }
            return true;
        }

        private bool DecodeARGB4444(byte[] image_data, byte[] buff)
        {
            var size = m_Width * m_Height;
            var pixelNew = new byte[4];
            for (var i = 0; i < size; i++)
            {
                var pixelOldShort = BitConverter.ToUInt16(image_data, i * 2);
                pixelNew[0] = (byte)(pixelOldShort & 0x000f);
                pixelNew[1] = (byte)((pixelOldShort & 0x00f0) >> 4);
                pixelNew[2] = (byte)((pixelOldShort & 0x0f00) >> 8);
                pixelNew[3] = (byte)((pixelOldShort & 0xf000) >> 12);
                for (var j = 0; j < 4; j++)
                    pixelNew[j] = (byte)((pixelNew[j] << 4) | pixelNew[j]);
                pixelNew.CopyTo(buff, i * 4);
            }
            return true;
        }

        private bool DecodeRGB24(byte[] image_data, byte[] buff)
        {
            var size = m_Width * m_Height;
            for (var i = 0; i < size; i++)
            {
                buff[i * 4] = image_data[i * 3 + 2];
                buff[i * 4 + 1] = image_data[i * 3 + 1];
                buff[i * 4 + 2] = image_data[i * 3 + 0];
                buff[i * 4 + 3] = 255;
            }
            return true;
        }

        private bool DecodeRGBA32(byte[] image_data, byte[] buff)
        {
            for (var i = 0; i < outPutSize; i += 4)
            {
                buff[i] = image_data[i + 2];
                buff[i + 1] = image_data[i + 1];
                buff[i + 2] = image_data[i + 0];
                buff[i + 3] = image_data[i + 3];
            }
            return true;
        }

        private bool DecodeARGB32(byte[] image_data, byte[] buff)
        {
            for (var i = 0; i < outPutSize; i += 4)
            {
                buff[i] = image_data[i + 3];
                buff[i + 1] = image_data[i + 2];
                buff[i + 2] = image_data[i + 1];
                buff[i + 3] = image_data[i + 0];
            }
            return true;
        }

        private bool DecodeRGB565(byte[] image_data, byte[] buff)
        {
            var size = m_Width * m_Height;
            for (var i = 0; i < size; i++)
            {
                var p = BitConverter.ToUInt16(image_data, i * 2);
                buff[i * 4] = (byte)((p << 3) | (p >> 2 & 7));
                buff[i * 4 + 1] = (byte)((p >> 3 & 0xfc) | (p >> 9 & 3));
                buff[i * 4 + 2] = (byte)((p >> 8 & 0xf8) | (p >> 13));
                buff[i * 4 + 3] = 255;
            }
            return true;
        }

        private bool DecodeR16(byte[] image_data, byte[] buff)
        {
            var size = m_Width * m_Height;
            for (var i = 0; i < size; i++)
            {
                buff[i * 4] = 0; //b
                buff[i * 4 + 1] = 0; //g
                buff[i * 4 + 2] = DownScaleFrom16BitTo8Bit(BitConverter.ToUInt16(image_data, i * 2)); //r
                buff[i * 4 + 3] = 255; //a
            }
            return true;
        }

        private bool DecodeDXT1(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeDXT1(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeDXT5(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeDXT5(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeRGBA4444(byte[] image_data, byte[] buff)
        {
            var size = m_Width * m_Height;
            var pixelNew = new byte[4];
            for (var i = 0; i < size; i++)
            {
                var pixelOldShort = BitConverter.ToUInt16(image_data, i * 2);
                pixelNew[0] = (byte)((pixelOldShort & 0x00f0) >> 4);
                pixelNew[1] = (byte)((pixelOldShort & 0x0f00) >> 8);
                pixelNew[2] = (byte)((pixelOldShort & 0xf000) >> 12);
                pixelNew[3] = (byte)(pixelOldShort & 0x000f);
                for (var j = 0; j < 4; j++)
                    pixelNew[j] = (byte)((pixelNew[j] << 4) | pixelNew[j]);
                pixelNew.CopyTo(buff, i * 4);
            }
            return true;
        }

        private bool DecodeBGRA32(byte[] image_data, byte[] buff)
        {
            for (var i = 0; i < outPutSize; i += 4)
            {
                buff[i] = image_data[i];
                buff[i + 1] = image_data[i + 1];
                buff[i + 2] = image_data[i + 2];
                buff[i + 3] = image_data[i + 3];
            }
            return true;
        }

        private bool DecodeRHalf(byte[] image_data, byte[] buff)
        {
            for (var i = 0; i < outPutSize; i += 4)
            {
                buff[i] = 0;
                buff[i + 1] = 0;
                buff[i + 2] = (byte)Math.Round(Half.ToHalf(image_data, i / 2) * 255f);
                buff[i + 3] = 255;
            }
            return true;
        }

        private bool DecodeRGHalf(byte[] image_data, byte[] buff)
        {
            for (var i = 0; i < outPutSize; i += 4)
            {
                buff[i] = 0;
                buff[i + 1] = (byte)Math.Round(Half.ToHalf(image_data, i + 2) * 255f);
                buff[i + 2] = (byte)Math.Round(Half.ToHalf(image_data, i) * 255f);
                buff[i + 3] = 255;
            }
            return true;
        }

        private bool DecodeRGBAHalf(byte[] image_data, byte[] buff)
        {
            for (var i = 0; i < outPutSize; i += 4)
            {
                buff[i] = (byte)Math.Round(Half.ToHalf(image_data, i * 2 + 4) * 255f);
                buff[i + 1] = (byte)Math.Round(Half.ToHalf(image_data, i * 2 + 2) * 255f);
                buff[i + 2] = (byte)Math.Round(Half.ToHalf(image_data, i * 2) * 255f);
                buff[i + 3] = (byte)Math.Round(Half.ToHalf(image_data, i * 2 + 6) * 255f);
            }
            return true;
        }

        private bool DecodeRFloat(byte[] image_data, byte[] buff)
        {
            for (var i = 0; i < outPutSize; i += 4)
            {
                buff[i] = 0;
                buff[i + 1] = 0;
                buff[i + 2] = (byte)Math.Round(BitConverter.ToSingle(image_data, i) * 255f);
                buff[i + 3] = 255;
            }
            return true;
        }

        private bool DecodeRGFloat(byte[] image_data, byte[] buff)
        {
            for (var i = 0; i < outPutSize; i += 4)
            {
                buff[i] = 0;
                buff[i + 1] = (byte)Math.Round(BitConverter.ToSingle(image_data, i * 2 + 4) * 255f);
                buff[i + 2] = (byte)Math.Round(BitConverter.ToSingle(image_data, i * 2) * 255f);
                buff[i + 3] = 255;
            }
            return true;
        }

        private bool DecodeRGBAFloat(byte[] image_data, byte[] buff)
        {
            for (var i = 0; i < outPutSize; i += 4)
            {
                buff[i] = (byte)Math.Round(BitConverter.ToSingle(image_data, i * 4 + 8) * 255f);
                buff[i + 1] = (byte)Math.Round(BitConverter.ToSingle(image_data, i * 4 + 4) * 255f);
                buff[i + 2] = (byte)Math.Round(BitConverter.ToSingle(image_data, i * 4) * 255f);
                buff[i + 3] = (byte)Math.Round(BitConverter.ToSingle(image_data, i * 4 + 12) * 255f);
            }
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static byte ClampByte(int x)
        {
            return (byte)(byte.MaxValue < x ? byte.MaxValue : (x > byte.MinValue ? x : byte.MinValue));
        }

        private bool DecodeYUY2(byte[] image_data, byte[] buff)
        {
            int p = 0;
            int o = 0;
            int halfWidth = m_Width / 2;
            for (int j = 0; j < m_Height; j++)
            {
                for (int i = 0; i < halfWidth; ++i)
                {
                    int y0 = image_data[p++];
                    int u0 = image_data[p++];
                    int y1 = image_data[p++];
                    int v0 = image_data[p++];
                    int c = y0 - 16;
                    int d = u0 - 128;
                    int e = v0 - 128;
                    buff[o++] = ClampByte((298 * c + 516 * d + 128) >> 8);            // b
                    buff[o++] = ClampByte((298 * c - 100 * d - 208 * e + 128) >> 8);  // g
                    buff[o++] = ClampByte((298 * c + 409 * e + 128) >> 8);            // r
                    buff[o++] = 255;
                    c = y1 - 16;
                    buff[o++] = ClampByte((298 * c + 516 * d + 128) >> 8);            // b
                    buff[o++] = ClampByte((298 * c - 100 * d - 208 * e + 128) >> 8);  // g
                    buff[o++] = ClampByte((298 * c + 409 * e + 128) >> 8);            // r
                    buff[o++] = 255;
                }
            }
            return true;
        }

        private bool DecodeRGB9e5Float(byte[] image_data, byte[] buff)
        {
            for (var i = 0; i < outPutSize; i += 4)
            {
                var n = BitConverter.ToInt32(image_data, i);
                var scale = n >> 27 & 0x1f;
                var scalef = Math.Pow(2, scale - 24);
                var b = n >> 18 & 0x1ff;
                var g = n >> 9 & 0x1ff;
                var r = n & 0x1ff;
                buff[i] = (byte)Math.Round(b * scalef * 255f);
                buff[i + 1] = (byte)Math.Round(g * scalef * 255f);
                buff[i + 2] = (byte)Math.Round(r * scalef * 255f);
                buff[i + 3] = 255;
            }
            return true;
        }

        private bool DecodeBC4(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeBC4(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeBC5(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeBC5(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeBC6H(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeBC6(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeBC7(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeBC7(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeDXT1Crunched(byte[] image_data, byte[] buff)
        {
            if (UnpackCrunch(image_data, out var result))
            {
                if (DecodeDXT1(result, buff))
                {
                    return true;
                }
            }
            return false;
        }

        private bool DecodeDXT5Crunched(byte[] image_data, byte[] buff)
        {
            if (UnpackCrunch(image_data, out var result))
            {
                if (DecodeDXT5(result, buff))
                {
                    return true;
                }
            }
            return false;
        }

        private bool DecodePVRTC(byte[] image_data, byte[] buff, bool is2bpp)
        {
            return TextureDecoder.DecodePVRTC(image_data, m_Width, m_Height, buff, is2bpp);
        }

        private bool DecodeETC1(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeETC1(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeATCRGB4(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeATCRGB4(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeATCRGBA8(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeATCRGBA8(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeEACR(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeEACR(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeEACRSigned(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeEACRSigned(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeEACRG(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeEACRG(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeEACRGSigned(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeEACRGSigned(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeETC2(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeETC2(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeETC2A1(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeETC2A1(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeETC2A8(byte[] image_data, byte[] buff)
        {
            return TextureDecoder.DecodeETC2A8(image_data, m_Width, m_Height, buff);
        }

        private bool DecodeASTC(byte[] image_data, byte[] buff, int blocksize)
        {
            return TextureDecoder.DecodeASTC(image_data, m_Width, m_Height, blocksize, blocksize, buff);
        }

        private bool DecodeRG16(byte[] image_data, byte[] buff)
        {
            var size = m_Width * m_Height;
            for (var i = 0; i < size; i++)
            {
                buff[i * 4] = 0; //B
                buff[i * 4 + 1] = image_data[i * 2 + 1];//G
                buff[i * 4 + 2] = image_data[i * 2];//R
                buff[i * 4 + 3] = 255;//A
            }
            return true;
        }

        private bool DecodeR8(byte[] image_data, byte[] buff)
        {
            var size = m_Width * m_Height;
            for (var i = 0; i < size; i++)
            {
                buff[i * 4] = 0; //B
                buff[i * 4 + 1] = 0; //G
                buff[i * 4 + 2] = image_data[i];//R
                buff[i * 4 + 3] = 255;//A
            }
            return true;
        }

        private bool DecodeETC1Crunched(byte[] image_data, byte[] buff)
        {
            if (UnpackCrunch(image_data, out var result))
            {
                if (DecodeETC1(result, buff))
                {
                    return true;
                }
            }
            return false;
        }

        private bool DecodeETC2A8Crunched(byte[] image_data, byte[] buff)
        {
            if (UnpackCrunch(image_data, out var result))
            {
                if (DecodeETC2A8(result, buff))
                {
                    return true;
                }
            }
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte DownScaleFrom16BitTo8Bit(ushort component)
        {
            return (byte)(((component * 255) + 32895) >> 16);
        }

        private bool DecodeRG32(byte[] image_data, byte[] buff)
        {
            for (var i = 0; i < outPutSize; i += 4)
            {
                buff[i] = 0;                                                                          //b
                buff[i + 1] = DownScaleFrom16BitTo8Bit(BitConverter.ToUInt16(image_data, i + 2));     //g
                buff[i + 2] = DownScaleFrom16BitTo8Bit(BitConverter.ToUInt16(image_data, i));         //r
                buff[i + 3] = byte.MaxValue;                                                          //a
            }
            return true;
        }

        private bool DecodeRGB48(byte[] image_data, byte[] buff)
        {
            var size = m_Width * m_Height;
            for (var i = 0; i < size; i++)
            {
                buff[i * 4] = DownScaleFrom16BitTo8Bit(BitConverter.ToUInt16(image_data, i * 6 + 4));     //b
                buff[i * 4 + 1] = DownScaleFrom16BitTo8Bit(BitConverter.ToUInt16(image_data, i * 6 + 2)); //g
                buff[i * 4 + 2] = DownScaleFrom16BitTo8Bit(BitConverter.ToUInt16(image_data, i * 6));     //r
                buff[i * 4 + 3] = byte.MaxValue;                                                          //a
            }
            return true;
        }

        private bool DecodeRGBA64(byte[] image_data, byte[] buff)
        {
            for (var i = 0; i < outPutSize; i += 4)
            {
                buff[i] = DownScaleFrom16BitTo8Bit(BitConverter.ToUInt16(image_data, i * 2 + 4));     //b
                buff[i + 1] = DownScaleFrom16BitTo8Bit(BitConverter.ToUInt16(image_data, i * 2 + 2)); //g
                buff[i + 2] = DownScaleFrom16BitTo8Bit(BitConverter.ToUInt16(image_data, i * 2));     //r
                buff[i + 3] = DownScaleFrom16BitTo8Bit(BitConverter.ToUInt16(image_data, i * 2 + 6)); //a
            }
            return true;
        }

        private bool UnpackCrunch(byte[] image_data, out byte[] result)
        {
            if (version[0] > 2017 || (version[0] == 2017 && version[1] >= 3) //2017.3 and up
                || m_TextureFormat == TextureFormat.ETC_RGB4Crunched
                || m_TextureFormat == TextureFormat.ETC2_RGBA8Crunched)
            {
                result = TextureDecoder.UnpackUnityCrunch(image_data);
            }
            else
            {
                result = TextureDecoder.UnpackCrunch(image_data);
            }
            if (result != null)
            {
                return true;
            }
            return false;
        }
    }
}

```

`AssetStudioUtility/Texture2DExtensions.cs`:

```cs
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp.Processing;
using System.IO;

namespace AssetStudio
{
    public static class Texture2DExtensions
    {
        public static Image<Bgra32> ConvertToImage(this Texture2D m_Texture2D, bool flip)
        {
            var converter = new Texture2DConverter(m_Texture2D);
            var buff = BigArrayPool<byte>.Shared.Rent(m_Texture2D.m_Width * m_Texture2D.m_Height * 4);
            try
            {
                if (converter.DecodeTexture2D(buff))
                {
                    var image = Image.LoadPixelData<Bgra32>(buff, m_Texture2D.m_Width, m_Texture2D.m_Height);
                    if (flip)
                    {
                        image.Mutate(x => x.Flip(FlipMode.Vertical));
                    }
                    return image;
                }
                return null;
            }
            finally
            {
                BigArrayPool<byte>.Shared.Return(buff);
            }
        }

        public static MemoryStream ConvertToStream(this Texture2D m_Texture2D, ImageFormat imageFormat, bool flip)
        {
            var image = ConvertToImage(m_Texture2D, flip);
            if (image != null)
            {
                using (image)
                {
                    return image.ConvertToStream(imageFormat);
                }
            }
            return null;
        }
    }
}

```

`AssetStudioUtility/TypeDefinitionConverter.cs`:

```cs
using Mono.Cecil;
using System;
using System.Collections.Generic;
using System.Linq;
using Unity.CecilTools;
using Unity.SerializationLogic;

namespace AssetStudio
{
    public class TypeDefinitionConverter
    {
        private readonly TypeDefinition TypeDef;
        private readonly TypeResolver TypeResolver;
        private readonly SerializedTypeHelper Helper;
        private readonly int Indent;

        public TypeDefinitionConverter(TypeDefinition typeDef, SerializedTypeHelper helper, int indent)
        {
            TypeDef = typeDef;
            TypeResolver = new TypeResolver(null);
            Helper = helper;
            Indent = indent;
        }

        public List<TypeTreeNode> ConvertToTypeTreeNodes()
        {
            var nodes = new List<TypeTreeNode>();

            var baseTypes = new Stack<TypeReference>();
            var lastBaseType = TypeDef.BaseType;
            while (!UnitySerializationLogic.IsNonSerialized(lastBaseType))
            {
                var genericInstanceType = lastBaseType as GenericInstanceType;
                if (genericInstanceType != null)
                {
                    TypeResolver.Add(genericInstanceType);
                }
                baseTypes.Push(lastBaseType);
                lastBaseType = lastBaseType.Resolve().BaseType;
            }
            while (baseTypes.Count > 0)
            {
                var typeReference = baseTypes.Pop();
                var typeDefinition = typeReference.Resolve();
                foreach (var fieldDefinition in typeDefinition.Fields.Where(WillUnitySerialize))
                {
                    if (!IsHiddenByParentClass(baseTypes, fieldDefinition, TypeDef))
                    {
                        nodes.AddRange(ProcessingFieldRef(ResolveGenericFieldReference(fieldDefinition)));
                    }
                }

                var genericInstanceType = typeReference as GenericInstanceType;
                if (genericInstanceType != null)
                {
                    TypeResolver.Remove(genericInstanceType);
                }
            }
            foreach (var field in FilteredFields())
            {
                nodes.AddRange(ProcessingFieldRef(field));
            }

            return nodes;
        }

        private bool WillUnitySerialize(FieldDefinition fieldDefinition)
        {
            try
            {
                var resolvedFieldType = TypeResolver.Resolve(fieldDefinition.FieldType);
                if (UnitySerializationLogic.ShouldNotTryToResolve(resolvedFieldType))
                {
                    return false;
                }
                if (!UnityEngineTypePredicates.IsUnityEngineObject(resolvedFieldType))
                {
                    if (resolvedFieldType.FullName == fieldDefinition.DeclaringType.FullName)
                    {
                        return false;
                    }
                }
                return UnitySerializationLogic.WillUnitySerialize(fieldDefinition, TypeResolver);
            }
            catch (Exception ex)
            {
                throw new Exception(string.Format("Exception while processing {0} {1}, error {2}", fieldDefinition.FieldType.FullName, fieldDefinition.FullName, ex.Message));
            }
        }

        private static bool IsHiddenByParentClass(IEnumerable<TypeReference> parentTypes, FieldDefinition fieldDefinition, TypeDefinition processingType)
        {
            return processingType.Fields.Any(f => f.Name == fieldDefinition.Name) || parentTypes.Any(t => t.Resolve().Fields.Any(f => f.Name == fieldDefinition.Name));
        }

        private IEnumerable<FieldDefinition> FilteredFields()
        {
            return TypeDef.Fields.Where(WillUnitySerialize).Where(f =>
                UnitySerializationLogic.IsSupportedCollection(f.FieldType) ||
                !f.FieldType.IsGenericInstance ||
                UnitySerializationLogic.ShouldImplementIDeserializable(f.FieldType.Resolve()));
        }

        private FieldReference ResolveGenericFieldReference(FieldReference fieldRef)
        {
            var field = new FieldReference(fieldRef.Name, fieldRef.FieldType, ResolveDeclaringType(fieldRef.DeclaringType));
            return TypeDef.Module.ImportReference(field);
        }

        private TypeReference ResolveDeclaringType(TypeReference declaringType)
        {
            var typeDefinition = declaringType.Resolve();
            if (typeDefinition == null || !typeDefinition.HasGenericParameters)
            {
                return typeDefinition;
            }
            var genericInstanceType = new GenericInstanceType(typeDefinition);
            foreach (var genericParameter in typeDefinition.GenericParameters)
            {
                genericInstanceType.GenericArguments.Add(genericParameter);
            }
            return TypeResolver.Resolve(genericInstanceType);
        }

        private List<TypeTreeNode> ProcessingFieldRef(FieldReference fieldDef)
        {
            var typeRef = TypeResolver.Resolve(fieldDef.FieldType);
            return TypeRefToTypeTreeNodes(typeRef, fieldDef.Name, Indent, false);
        }

        private static bool IsStruct(TypeReference typeRef)
        {
            return typeRef.IsValueType && !IsEnum(typeRef) && !typeRef.IsPrimitive;
        }

        private static bool IsEnum(TypeReference typeRef)
        {
            return !typeRef.IsArray && typeRef.Resolve().IsEnum;
        }

        private static bool RequiresAlignment(TypeReference typeRef)
        {
            switch (typeRef.MetadataType)
            {
                case MetadataType.Boolean:
                case MetadataType.Char:
                case MetadataType.SByte:
                case MetadataType.Byte:
                case MetadataType.Int16:
                case MetadataType.UInt16:
                    return true;
                default:
                    return UnitySerializationLogic.IsSupportedCollection(typeRef) && RequiresAlignment(CecilUtils.ElementTypeOfCollection(typeRef));
            }
        }

        private static bool IsSystemString(TypeReference typeRef)
        {
            return typeRef.FullName == "System.String";
        }

        private List<TypeTreeNode> TypeRefToTypeTreeNodes(TypeReference typeRef, string name, int indent, bool isElement)
        {
            var align = false;

            if (!IsStruct(TypeDef) || !UnityEngineTypePredicates.IsUnityEngineValueType(TypeDef))
            {
                if (IsStruct(typeRef) || RequiresAlignment(typeRef))
                {
                    align = true;
                }
            }

            var nodes = new List<TypeTreeNode>();
            if (typeRef.IsPrimitive)
            {
                var primitiveName = typeRef.Name;
                switch (primitiveName)
                {
                    case "Boolean":
                        primitiveName = "bool";
                        break;
                    case "Byte":
                        primitiveName = "UInt8";
                        break;
                    case "SByte":
                        primitiveName = "SInt8";
                        break;
                    case "Int16":
                        primitiveName = "SInt16";
                        break;
                    case "UInt16":
                        primitiveName = "UInt16";
                        break;
                    case "Int32":
                        primitiveName = "SInt32";
                        break;
                    case "UInt32":
                        primitiveName = "UInt32";
                        break;
                    case "Int64":
                        primitiveName = "SInt64";
                        break;
                    case "UInt64":
                        primitiveName = "UInt64";
                        break;
                    case "Char":
                        primitiveName = "char";
                        break;
                    case "Double":
                        primitiveName = "double";
                        break;
                    case "Single":
                        primitiveName = "float";
                        break;
                    default:
                        throw new NotSupportedException();
                }
                if (isElement)
                {
                    align = false;
                }
                nodes.Add(new TypeTreeNode(primitiveName, name, indent, align));
            }
            else if (IsSystemString(typeRef))
            {
                Helper.AddString(nodes, name, indent);
            }
            else if (IsEnum(typeRef))
            {
                nodes.Add(new TypeTreeNode("SInt32", name, indent, align));
            }
            else if (CecilUtils.IsGenericList(typeRef))
            {
                var elementRef = CecilUtils.ElementTypeOfCollection(typeRef);
                nodes.Add(new TypeTreeNode(typeRef.Name, name, indent, align));
                Helper.AddArray(nodes, indent + 1);
                nodes.AddRange(TypeRefToTypeTreeNodes(elementRef, "data", indent + 2, true));
            }
            else if (typeRef.IsArray)
            {
                var elementRef = typeRef.GetElementType();
                nodes.Add(new TypeTreeNode(typeRef.Name, name, indent, align));
                Helper.AddArray(nodes, indent + 1);
                nodes.AddRange(TypeRefToTypeTreeNodes(elementRef, "data", indent + 2, true));
            }
            else if (UnityEngineTypePredicates.IsUnityEngineObject(typeRef))
            {
                Helper.AddPPtr(nodes, typeRef.Name, name, indent);
            }
            else if (UnityEngineTypePredicates.IsSerializableUnityClass(typeRef) || UnityEngineTypePredicates.IsSerializableUnityStruct(typeRef))
            {
                switch (typeRef.FullName)
                {
                    case "UnityEngine.AnimationCurve":
                        Helper.AddAnimationCurve(nodes, name, indent);
                        break;
                    case "UnityEngine.Gradient":
                        Helper.AddGradient(nodes, name, indent);
                        break;
                    case "UnityEngine.GUIStyle":
                        Helper.AddGUIStyle(nodes, name, indent);
                        break;
                    case "UnityEngine.RectOffset":
                        Helper.AddRectOffset(nodes, name, indent);
                        break;
                    case "UnityEngine.Color32":
                        Helper.AddColor32(nodes, name, indent);
                        break;
                    case "UnityEngine.Matrix4x4":
                        Helper.AddMatrix4x4(nodes, name, indent);
                        break;
                    case "UnityEngine.Rendering.SphericalHarmonicsL2":
                        Helper.AddSphericalHarmonicsL2(nodes, name, indent);
                        break;
                    case "UnityEngine.PropertyName":
                        Helper.AddPropertyName(nodes, name, indent);
                        break;
                }
            }
            else
            {
                nodes.Add(new TypeTreeNode(typeRef.Name, name, indent, align));
                var typeDef = typeRef.Resolve();
                var typeDefinitionConverter = new TypeDefinitionConverter(typeDef, Helper, indent + 1);
                nodes.AddRange(typeDefinitionConverter.ConvertToTypeTreeNodes());
            }

            return nodes;
        }
    }
}

```

`AssetStudioUtility/Unity.CecilTools/CecilUtils.cs`:

```cs
// Unity C# reference source
// Copyright (c) Unity Technologies. For terms of use, see
// https://unity3d.com/legal/licenses/Unity_Reference_Only_License

using System;
using System.Collections.Generic;
using System.Linq;
using Mono.Cecil;
using Unity.CecilTools.Extensions;

namespace Unity.CecilTools
{
    public static class CecilUtils
    {
        public static MethodDefinition FindInTypeExplicitImplementationFor(MethodDefinition interfaceMethod, TypeDefinition typeDefinition)
        {
            return typeDefinition.Methods.SingleOrDefault(m => m.Overrides.Any(o => o.CheckedResolve().SameAs(interfaceMethod)));
        }

        public static IEnumerable<TypeDefinition> AllInterfacesImplementedBy(TypeDefinition typeDefinition)
        {
            return TypeAndBaseTypesOf(typeDefinition).SelectMany(t => t.Interfaces).Select(i => i.InterfaceType.CheckedResolve()).Distinct();
        }

        public static IEnumerable<TypeDefinition> TypeAndBaseTypesOf(TypeReference typeReference)
        {
            while (typeReference != null)
            {
                var typeDefinition = typeReference.CheckedResolve();
                yield return typeDefinition;
                typeReference = typeDefinition.BaseType;
            }
        }

        public static IEnumerable<TypeDefinition> BaseTypesOf(TypeReference typeReference)
        {
            return TypeAndBaseTypesOf(typeReference).Skip(1);
        }

        public static bool IsGenericList(TypeReference type)
        {
            return type.Name == "List`1" && type.SafeNamespace() == "System.Collections.Generic";
        }

        public static bool IsGenericDictionary(TypeReference type)
        {
            if (type is GenericInstanceType)
                type = ((GenericInstanceType)type).ElementType;

            return type.Name == "Dictionary`2" && type.SafeNamespace() == "System.Collections.Generic";
        }

        public static TypeReference ElementTypeOfCollection(TypeReference type)
        {
            var at = type as ArrayType;
            if (at != null)
                return at.ElementType;

            if (IsGenericList(type))
                return ((GenericInstanceType)type).GenericArguments.Single();

            throw new ArgumentException();
        }
    }
}

```

`AssetStudioUtility/Unity.CecilTools/ElementType.cs`:

```cs
// Unity C# reference source
// Copyright (c) Unity Technologies. For terms of use, see
// https://unity3d.com/legal/licenses/Unity_Reference_Only_License

using System;
using Mono.Cecil;

namespace Unity.CecilTools
{
    static public class ElementType
    {
        public static TypeReference For(TypeReference byRefType)
        {
            var refType = byRefType as TypeSpecification;
            if (refType != null)
                return refType.ElementType;

            throw new ArgumentException(string.Format("TypeReference isn't a TypeSpecification {0} ", byRefType));
        }
    }
}

```

`AssetStudioUtility/Unity.CecilTools/Extensions/MethodDefinitionExtensions.cs`:

```cs
// Unity C# reference source
// Copyright (c) Unity Technologies. For terms of use, see
// https://unity3d.com/legal/licenses/Unity_Reference_Only_License

using Mono.Cecil;

namespace Unity.CecilTools.Extensions
{
    static class MethodDefinitionExtensions
    {
        public static bool SameAs(this MethodDefinition self, MethodDefinition other)
        {
            // FIXME: should be able to compare MethodDefinition references directly
            return self.FullName == other.FullName;
        }

        public static string PropertyName(this MethodDefinition self)
        {
            return self.Name.Substring(4);
        }

        public static bool IsConversionOperator(this MethodDefinition method)
        {
            if (!method.IsSpecialName)
                return false;

            return method.Name == "op_Implicit" || method.Name == "op_Explicit";
        }

        public static bool IsSimpleSetter(this MethodDefinition original)
        {
            return original.IsSetter && original.Parameters.Count == 1;
        }

        public static bool IsSimpleGetter(this MethodDefinition original)
        {
            return original.IsGetter && original.Parameters.Count == 0;
        }

        public static bool IsSimplePropertyAccessor(this MethodDefinition method)
        {
            return method.IsSimpleGetter() || method.IsSimpleSetter();
        }

        public static bool IsDefaultConstructor(MethodDefinition m)
        {
            return m.IsConstructor && !m.IsStatic && m.Parameters.Count == 0;
        }
    }
}

```

`AssetStudioUtility/Unity.CecilTools/Extensions/ResolutionExtensions.cs`:

```cs
// Unity C# reference source
// Copyright (c) Unity Technologies. For terms of use, see
// https://unity3d.com/legal/licenses/Unity_Reference_Only_License

using System;
using Mono.Cecil;

namespace Unity.CecilTools.Extensions
{
    public static class ResolutionExtensions
    {
        public static TypeDefinition CheckedResolve(this TypeReference type)
        {
            return Resolve(type, reference => reference.Resolve());
        }

        public static MethodDefinition CheckedResolve(this MethodReference method)
        {
            return Resolve(method, reference => reference.Resolve());
        }

        private static TDefinition Resolve<TReference, TDefinition>(TReference reference, Func<TReference, TDefinition> resolve)
            where TReference : MemberReference
            where TDefinition : class, IMemberDefinition
        {
            if (reference.Module == null)
                throw new ResolutionException(reference);

            var definition = resolve(reference);
            if (definition == null)
                throw new ResolutionException(reference);

            return definition;
        }
    }
}

```

`AssetStudioUtility/Unity.CecilTools/Extensions/TypeDefinitionExtensions.cs`:

```cs
// Unity C# reference source
// Copyright (c) Unity Technologies. For terms of use, see
// https://unity3d.com/legal/licenses/Unity_Reference_Only_License

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Mono.Cecil;

namespace Unity.CecilTools.Extensions
{
    public static class TypeDefinitionExtensions
    {
        public static bool IsSubclassOf(this TypeDefinition type, string baseTypeName)
        {
            var baseType = type.BaseType;
            if (baseType == null)
                return false;
            if (baseType.FullName == baseTypeName)
                return true;

            var baseTypeDef = baseType.Resolve();
            if (baseTypeDef == null)
                return false;

            return IsSubclassOf(baseTypeDef, baseTypeName);
        }

        public static bool IsSubclassOf(this TypeDefinition type, params string[] baseTypeNames)
        {
            var baseType = type.BaseType;
            if (baseType == null)
                return false;

            for (int i = 0; i < baseTypeNames.Length; i++)
                if (baseType.FullName == baseTypeNames[i])
                    return true;

            var baseTypeDef = baseType.Resolve();
            if (baseTypeDef == null)
                return false;

            return IsSubclassOf(baseTypeDef, baseTypeNames);
        }
    }
}

```

`AssetStudioUtility/Unity.CecilTools/Extensions/TypeReferenceExtensions.cs`:

```cs
// Unity C# reference source
// Copyright (c) Unity Technologies. For terms of use, see
// https://unity3d.com/legal/licenses/Unity_Reference_Only_License

using Mono.Cecil;

namespace Unity.CecilTools.Extensions
{
    public static class TypeReferenceExtensions
    {
        public static string SafeNamespace(this TypeReference type)
        {
            if (type.IsGenericInstance)
                return ((GenericInstanceType)type).ElementType.SafeNamespace();
            if (type.IsNested)
                return type.DeclaringType.SafeNamespace();
            return type.Namespace;
        }

        public static bool IsAssignableTo(this TypeReference typeRef, string typeName)
        {
            try
            {
                if (typeRef.IsGenericInstance)
                    return ElementType.For(typeRef).IsAssignableTo(typeName);

                if (typeRef.FullName == typeName)
                    return true;

                return typeRef.CheckedResolve().IsSubclassOf(typeName);
            }
            catch (AssemblyResolutionException) // If we can't resolve our typeref or one of its base types,
            {                                   // let's assume it is not assignable to our target type
                return false;
            }
        }

        public static bool IsEnum(this TypeReference type)
        {
            return type.IsValueType && !type.IsPrimitive && type.CheckedResolve().IsEnum;
        }

        public static bool IsStruct(this TypeReference type)
        {
            return type.IsValueType && !type.IsPrimitive && !type.IsEnum() && !IsSystemDecimal(type);
        }

        private static bool IsSystemDecimal(TypeReference type)
        {
            return type.FullName == "System.Decimal";
        }
    }
}

```

`AssetStudioUtility/Unity.SerializationLogic/UnityEngineTypePredicates.cs`:

```cs
// Unity C# reference source
// Copyright (c) Unity Technologies. For terms of use, see
// https://unity3d.com/legal/licenses/Unity_Reference_Only_License

using System.Collections.Generic;
using Unity.CecilTools.Extensions;
using Mono.Cecil;

namespace Unity.SerializationLogic
{
    public class UnityEngineTypePredicates
    {
        private static readonly HashSet<string> TypesThatShouldHaveHadSerializableAttribute = new HashSet<string>
        {
            "Vector3",
            "Vector2",
            "Vector4",
            "Rect",
            "RectInt",
            "Quaternion",
            "Matrix4x4",
            "Color",
            "Color32",
            "LayerMask",
            "Bounds",
            "BoundsInt",
            "Vector3Int",
            "Vector2Int",
        };

        private const string Gradient = "UnityEngine.Gradient";
        private const string GUIStyle = "UnityEngine.GUIStyle";
        private const string RectOffset = "UnityEngine.RectOffset";
        protected const string UnityEngineObject = "UnityEngine.Object";
        public const string MonoBehaviour = "UnityEngine.MonoBehaviour";
        public const string ScriptableObject = "UnityEngine.ScriptableObject";
        protected const string Matrix4x4 = "UnityEngine.Matrix4x4";
        protected const string Color32 = "UnityEngine.Color32";
        private const string SerializeFieldAttribute = "UnityEngine.SerializeField";
        private const string SerializeReferenceAttribute = "UnityEngine.SerializeReference";

        private static string[] serializableClasses = new[]
        {
            "UnityEngine.AnimationCurve",
            "UnityEngine.Gradient",
            "UnityEngine.GUIStyle",
            "UnityEngine.RectOffset"
        };

        private static string[] serializableStructs = new[]
        {
            // NOTE: assumes all types here are NOT interfaces
            "UnityEngine.Color32",
            "UnityEngine.Matrix4x4",
            "UnityEngine.Rendering.SphericalHarmonicsL2",
            "UnityEngine.PropertyName",
        };

        public static bool IsMonoBehaviour(TypeReference type)
        {
            return IsMonoBehaviour(type.CheckedResolve());
        }

        private static bool IsMonoBehaviour(TypeDefinition typeDefinition)
        {
            return typeDefinition.IsSubclassOf(MonoBehaviour);
        }

        public static bool IsScriptableObject(TypeReference type)
        {
            return IsScriptableObject(type.CheckedResolve());
        }

        private static bool IsScriptableObject(TypeDefinition temp)
        {
            return temp.IsSubclassOf(ScriptableObject);
        }

        public static bool IsColor32(TypeReference type)
        {
            return type.IsAssignableTo(Color32);
        }

        //Do NOT remove these, cil2as still depends on these in 4.x
        public static bool IsMatrix4x4(TypeReference type)
        {
            return type.IsAssignableTo(Matrix4x4);
        }

        public static bool IsGradient(TypeReference type)
        {
            return type.IsAssignableTo(Gradient);
        }

        public static bool IsGUIStyle(TypeReference type)
        {
            return type.IsAssignableTo(GUIStyle);
        }

        public static bool IsRectOffset(TypeReference type)
        {
            return type.IsAssignableTo(RectOffset);
        }

        public static bool IsSerializableUnityClass(TypeReference type)
        {
            foreach (var unityClasses in serializableClasses)
            {
                if (type.IsAssignableTo(unityClasses))
                    return true;
            }
            return false;
        }

        public static bool IsSerializableUnityStruct(TypeReference type)
        {
            foreach (var unityStruct in serializableStructs)
            {
                // NOTE: structs cannot inherit from structs, and can only inherit from interfaces
                //       since we know all types in serializableStructs are not interfaces,
                //       we can just do a direct comparison.
                if (type.FullName == unityStruct)
                    return true;
            }

            if (type.FullName.IndexOf("UnityEngine.LazyLoadReference`1") == 0)
                return true;

            return false;
        }

        public static bool IsUnityEngineObject(TypeReference type)
        {
            //todo: somehow solve this elegantly. CheckedResolve() drops the [] of a type.
            if (type.IsArray)
                return false;

            if (type.FullName == UnityEngineObject)
                return true;

            var typeDefinition = type.Resolve();
            if (typeDefinition == null)
                return false;

            return typeDefinition.IsSubclassOf(UnityEngineObject);
        }

        public static bool ShouldHaveHadSerializableAttribute(TypeReference type)
        {
            return IsUnityEngineValueType(type);
        }

        public static bool IsUnityEngineValueType(TypeReference type)
        {
            return type.SafeNamespace() == "UnityEngine" && TypesThatShouldHaveHadSerializableAttribute.Contains(type.Name);
        }

        public static bool IsSerializeFieldAttribute(TypeReference attributeType)
        {
            return attributeType.FullName == SerializeFieldAttribute;
        }

        public static bool IsSerializeReferenceAttribute(TypeReference attributeType)
        {
            return attributeType.FullName == SerializeReferenceAttribute;
        }
    }
}

```

`AssetStudioUtility/Unity.SerializationLogic/UnitySerializationLogic.cs`:

```cs
// Unity C# reference source
// Copyright (c) Unity Technologies. For terms of use, see
// https://unity3d.com/legal/licenses/Unity_Reference_Only_License

using System;
using System.Collections.Generic;
using System.Linq;
using Mono.Cecil;
using Mono.Collections.Generic;
using Unity.CecilTools;
using Unity.CecilTools.Extensions;

namespace Unity.SerializationLogic
{
    internal class GenericInstanceHolder
    {
        public int Count;
        public IGenericInstance GenericInstance;
    }

    public class TypeResolver
    {
        private readonly IGenericInstance _typeDefinitionContext;
        private readonly IGenericInstance _methodDefinitionContext;
        private readonly Dictionary<string, GenericInstanceHolder> _context = new Dictionary<string, GenericInstanceHolder>();

        public TypeResolver()
        {
        }

        public TypeResolver(IGenericInstance typeDefinitionContext)
        {
            _typeDefinitionContext = typeDefinitionContext;
        }

        public TypeResolver(GenericInstanceMethod methodDefinitionContext)
        {
            _methodDefinitionContext = methodDefinitionContext;
        }

        public TypeResolver(IGenericInstance typeDefinitionContext, IGenericInstance methodDefinitionContext)
        {
            _typeDefinitionContext = typeDefinitionContext;
            _methodDefinitionContext = methodDefinitionContext;
        }

        public void Add(GenericInstanceType genericInstanceType)
        {
            Add(ElementTypeFor(genericInstanceType).FullName, genericInstanceType);
        }

        public void Remove(GenericInstanceType genericInstanceType)
        {
            Remove(genericInstanceType.ElementType.FullName, genericInstanceType);
        }

        public void Add(GenericInstanceMethod genericInstanceMethod)
        {
            Add(ElementTypeFor(genericInstanceMethod).FullName, genericInstanceMethod);
        }

        private static MemberReference ElementTypeFor(TypeSpecification genericInstanceType)
        {
            return genericInstanceType.ElementType;
        }

        private static MemberReference ElementTypeFor(MethodSpecification genericInstanceMethod)
        {
            return genericInstanceMethod.ElementMethod;
        }

        public void Remove(GenericInstanceMethod genericInstanceMethod)
        {
            Remove(genericInstanceMethod.ElementMethod.FullName, genericInstanceMethod);
        }

        public TypeReference Resolve(TypeReference typeReference)
        {
            var genericParameter = typeReference as GenericParameter;
            if (genericParameter != null)
            {
                var resolved = ResolveGenericParameter(genericParameter);
                if (genericParameter == resolved) // Resolving failed, return what we have.
                    return resolved;

                return Resolve(resolved);
            }

            var arrayType = typeReference as ArrayType;
            if (arrayType != null)
                return new ArrayType(Resolve(arrayType.ElementType), arrayType.Rank);

            var pointerType = typeReference as PointerType;
            if (pointerType != null)
                return new PointerType(Resolve(pointerType.ElementType));

            var byReferenceType = typeReference as ByReferenceType;
            if (byReferenceType != null)
                return new ByReferenceType(Resolve(byReferenceType.ElementType));

            var genericInstanceType = typeReference as GenericInstanceType;
            if (genericInstanceType != null)
            {
                var newGenericInstanceType = new GenericInstanceType(Resolve(genericInstanceType.ElementType));
                foreach (var genericArgument in genericInstanceType.GenericArguments)
                    newGenericInstanceType.GenericArguments.Add(Resolve(genericArgument));
                return newGenericInstanceType;
            }

            var pinnedType = typeReference as PinnedType;
            if (pinnedType != null)
                return new PinnedType(Resolve(pinnedType.ElementType));

            var reqModifierType = typeReference as RequiredModifierType;
            if (reqModifierType != null)
                return Resolve(reqModifierType.ElementType);

            var optModifierType = typeReference as OptionalModifierType;
            if (optModifierType != null)
                return new OptionalModifierType(Resolve(optModifierType.ModifierType), Resolve(optModifierType.ElementType));

            var sentinelType = typeReference as SentinelType;
            if (sentinelType != null)
                return new SentinelType(Resolve(sentinelType.ElementType));

            var funcPtrType = typeReference as FunctionPointerType;
            if (funcPtrType != null)
                throw new NotSupportedException("Function pointer types are not supported by the SerializationWeaver");

            if (typeReference is TypeSpecification)
                throw new NotSupportedException();

            return typeReference;
        }

        private TypeReference ResolveGenericParameter(GenericParameter genericParameter)
        {
            if (genericParameter.Owner == null)
                throw new NotSupportedException();

            var memberReference = genericParameter.Owner as MemberReference;
            if (memberReference == null)
                throw new NotSupportedException();

            var key = memberReference.FullName;
            if (!_context.ContainsKey(key))
            {
                if (genericParameter.Type == GenericParameterType.Type)
                {
                    if (_typeDefinitionContext != null)
                        return _typeDefinitionContext.GenericArguments[genericParameter.Position];

                    return genericParameter;
                }

                if (_methodDefinitionContext != null)
                    return _methodDefinitionContext.GenericArguments[genericParameter.Position];

                return genericParameter;
            }

            return GenericArgumentAt(key, genericParameter.Position);
        }

        private TypeReference GenericArgumentAt(string key, int position)
        {
            return _context[key].GenericInstance.GenericArguments[position];
        }

        private void Add(string key, IGenericInstance value)
        {
            GenericInstanceHolder oldValue;

            if (_context.TryGetValue(key, out oldValue))
            {
                var memberReference = value as MemberReference;
                if (memberReference == null)
                    throw new NotSupportedException();

                var storedValue = (MemberReference)oldValue.GenericInstance;

                if (storedValue.FullName != memberReference.FullName)
                    throw new ArgumentException("Duplicate key!", "key");

                oldValue.Count++;
                return;
            }

            _context.Add(key, new GenericInstanceHolder { Count = 1, GenericInstance = value });
        }

        private void Remove(string key, IGenericInstance value)
        {
            GenericInstanceHolder oldValue;

            if (_context.TryGetValue(key, out oldValue))
            {
                var memberReference = value as MemberReference;
                if (memberReference == null)
                    throw new NotSupportedException();

                var storedValue = (MemberReference)oldValue.GenericInstance;

                if (storedValue.FullName != memberReference.FullName)
                    throw new ArgumentException("Invalid value!", "value");

                oldValue.Count--;
                if (oldValue.Count == 0)
                    _context.Remove(key);

                return;
            }

            throw new ArgumentException("Invalid key!", "key");
        }
    }

    public static class UnitySerializationLogic
    {
        public static bool WillUnitySerialize(FieldDefinition fieldDefinition)
        {
            return WillUnitySerialize(fieldDefinition, new TypeResolver(null));
        }

        public static bool WillUnitySerialize(FieldDefinition fieldDefinition, TypeResolver typeResolver)
        {
            if (fieldDefinition == null)
                return false;

            //skip static, const and NotSerialized fields before even checking the type
            if (fieldDefinition.IsStatic || IsConst(fieldDefinition) || fieldDefinition.IsNotSerialized || fieldDefinition.IsInitOnly)
                return false;

            // The field must have correct visibility/decoration to be serialized.
            if (!fieldDefinition.IsPublic &&
                !ShouldHaveHadAllFieldsPublic(fieldDefinition) &&
                !HasSerializeFieldAttribute(fieldDefinition) &&
                !HasSerializeReferenceAttribute(fieldDefinition))
                return false;

            // Don't try to resolve types that come from Windows assembly,
            // as serialization weaver will fail to resolve that (due to it being in platform specific SDKs)
            if (ShouldNotTryToResolve(fieldDefinition.FieldType))
                return false;

            if (IsFixedBuffer(fieldDefinition))
                return true;

            // Resolving types is more complex and slower than checking their names or attributes,
            // thus keep those checks below
            var typeReference = typeResolver.Resolve(fieldDefinition.FieldType);

            //the type of the field must be serializable in the first place.

            if (typeReference.MetadataType == MetadataType.String)
                return true;

            if (typeReference.IsValueType)
                return IsValueTypeSerializable(typeReference);

            if (typeReference is ArrayType || CecilUtils.IsGenericList(typeReference))
            {
                if (!HasSerializeReferenceAttribute(fieldDefinition))
                    return IsSupportedCollection(typeReference);
            }


            if (!IsReferenceTypeSerializable(typeReference) && !HasSerializeReferenceAttribute(fieldDefinition))
                return false;

            if (IsDelegate(typeReference))
                return false;

            return true;
        }

        private static bool IsDelegate(TypeReference typeReference)
        {
            return typeReference.IsAssignableTo("System.Delegate");
        }

        public static bool ShouldFieldBePPtrRemapped(FieldDefinition fieldDefinition)
        {
            return ShouldFieldBePPtrRemapped(fieldDefinition, new TypeResolver(null));
        }

        public static bool ShouldFieldBePPtrRemapped(FieldDefinition fieldDefinition, TypeResolver typeResolver)
        {
            if (!WillUnitySerialize(fieldDefinition, typeResolver))
                return false;

            return CanTypeContainUnityEngineObjectReference(typeResolver.Resolve(fieldDefinition.FieldType));
        }

        private static bool CanTypeContainUnityEngineObjectReference(TypeReference typeReference)
        {
            if (IsUnityEngineObject(typeReference))
                return true;

            if (typeReference.IsEnum())
                return false;

            if (IsSerializablePrimitive(typeReference))
                return false;

            if (IsSupportedCollection(typeReference))
                return CanTypeContainUnityEngineObjectReference(CecilUtils.ElementTypeOfCollection(typeReference));

            var definition = typeReference.Resolve();
            if (definition == null)
                return false;

            return HasFieldsThatCanContainUnityEngineObjectReferences(definition, new TypeResolver(typeReference as GenericInstanceType));
        }

        private static bool HasFieldsThatCanContainUnityEngineObjectReferences(TypeDefinition definition, TypeResolver typeResolver)
        {
            return AllFieldsFor(definition, typeResolver).Where(kv => kv.Value.Resolve(kv.Key.FieldType).Resolve() != definition).Any(kv => CanFieldContainUnityEngineObjectReference(definition, kv.Key, kv.Value));
        }

        private static IEnumerable<KeyValuePair<FieldDefinition, TypeResolver>> AllFieldsFor(TypeDefinition definition, TypeResolver typeResolver)
        {
            var baseType = definition.BaseType;

            if (baseType != null)
            {
                var genericBaseInstanceType = baseType as GenericInstanceType;
                if (genericBaseInstanceType != null)
                    typeResolver.Add(genericBaseInstanceType);
                foreach (var kv in AllFieldsFor(baseType.Resolve(), typeResolver))
                    yield return kv;
                if (genericBaseInstanceType != null)
                    typeResolver.Remove(genericBaseInstanceType);
            }

            foreach (var fieldDefinition in definition.Fields)
                yield return new KeyValuePair<FieldDefinition, TypeResolver>(fieldDefinition, typeResolver);
        }

        private static bool CanFieldContainUnityEngineObjectReference(TypeReference typeReference, FieldDefinition t, TypeResolver typeResolver)
        {
            if (typeResolver.Resolve(t.FieldType) == typeReference)
                return false;

            if (!WillUnitySerialize(t, typeResolver))
                return false;

            if (UnityEngineTypePredicates.IsUnityEngineValueType(typeReference))
                return false;

            return true;
        }

        private static bool IsConst(FieldDefinition fieldDefinition)
        {
            return fieldDefinition.IsLiteral && !fieldDefinition.IsInitOnly;
        }

        public static bool HasSerializeFieldAttribute(FieldDefinition field)
        {
            //return FieldAttributes(field).Any(UnityEngineTypePredicates.IsSerializeFieldAttribute);
            foreach (var attribute in FieldAttributes(field))
                if (UnityEngineTypePredicates.IsSerializeFieldAttribute(attribute))
                    return true;
            return false;
        }

        public static bool HasSerializeReferenceAttribute(FieldDefinition field)
        {
            foreach (var attribute in FieldAttributes(field))
                if (UnityEngineTypePredicates.IsSerializeReferenceAttribute(attribute))
                    return true;
            return false;
        }

        private static IEnumerable<TypeReference> FieldAttributes(FieldDefinition field)
        {
            return field.CustomAttributes.Select(_ => _.AttributeType);
        }

        public static bool ShouldNotTryToResolve(TypeReference typeReference)
        {
            var typeReferenceScopeName = typeReference.Scope.Name;
            if (typeReferenceScopeName == "Windows")
            {
                return true;
            }

            if (typeReferenceScopeName == "mscorlib")
            {
                var resolved = typeReference.Resolve();
                return resolved == null;
            }

            try
            {   // This will throw an exception if typereference thinks it's referencing a .dll,
                // but actually there's .winmd file in the current directory. RRW will fix this
                // at a later step, so we will not try to resolve this type. This is OK, as any
                // type defined in a winmd cannot be serialized.
                typeReference.Resolve();
            }
            catch
            {
                return true;
            }

            return false;
        }

        private static bool IsFieldTypeSerializable(TypeReference typeReference, FieldDefinition fieldDefinition)
        {
            return IsTypeSerializable(typeReference) || IsSupportedCollection(typeReference) || IsFixedBuffer(fieldDefinition);
        }

        private static bool IsValueTypeSerializable(TypeReference typeReference)
        {
            if (typeReference.IsPrimitive)
                return IsSerializablePrimitive(typeReference);
            return UnityEngineTypePredicates.IsSerializableUnityStruct(typeReference) ||
                typeReference.IsEnum() ||
                ShouldImplementIDeserializable(typeReference);
        }

        private static bool IsReferenceTypeSerializable(TypeReference typeReference)
        {
            if (typeReference.MetadataType == MetadataType.String)
                return IsSerializablePrimitive(typeReference);

            if (IsGenericDictionary(typeReference))
                return false;

            if (IsUnityEngineObject(typeReference) ||
                ShouldImplementIDeserializable(typeReference) ||
                UnityEngineTypePredicates.IsSerializableUnityClass(typeReference))
                return true;

            return false;
        }

        private static bool IsTypeSerializable(TypeReference typeReference)
        {
            if (typeReference.MetadataType == MetadataType.String)
                return true;
            if (typeReference.IsValueType)
                return IsValueTypeSerializable(typeReference);
            return IsReferenceTypeSerializable(typeReference);
        }

        private static bool IsGenericDictionary(TypeReference typeReference)
        {
            var current = typeReference;

            if (current != null)
            {
                if (CecilUtils.IsGenericDictionary(current))
                    return true;
            }

            return false;
        }

        public static bool IsFixedBuffer(FieldDefinition fieldDefinition)
        {
            return GetFixedBufferAttribute(fieldDefinition) != null;
        }

        public static CustomAttribute GetFixedBufferAttribute(FieldDefinition fieldDefinition)
        {
            if (!fieldDefinition.HasCustomAttributes)
                return null;

            return fieldDefinition.CustomAttributes.SingleOrDefault(a => a.AttributeType.FullName == "System.Runtime.CompilerServices.FixedBufferAttribute");
        }

        public static int GetFixedBufferLength(FieldDefinition fieldDefinition)
        {
            var fixedBufferAttribute = GetFixedBufferAttribute(fieldDefinition);

            if (fixedBufferAttribute == null)
                throw new ArgumentException(string.Format("Field '{0}' is not a fixed buffer field.", fieldDefinition.FullName));

            var size = (Int32)fixedBufferAttribute.ConstructorArguments[1].Value;

            return size;
        }

        public static int PrimitiveTypeSize(TypeReference type)
        {
            switch (type.MetadataType)
            {
                case MetadataType.Boolean:
                case MetadataType.Byte:
                case MetadataType.SByte:
                    return 1;

                case MetadataType.Char:
                case MetadataType.Int16:
                case MetadataType.UInt16:
                    return 2;

                case MetadataType.Int32:
                case MetadataType.UInt32:
                case MetadataType.Single:
                    return 4;

                case MetadataType.Int64:
                case MetadataType.UInt64:
                case MetadataType.Double:
                    return 8;

                default:
                    throw new ArgumentException(string.Format("Unsupported {0}", type.MetadataType));
            }
        }

        private static bool IsSerializablePrimitive(TypeReference typeReference)
        {
            switch (typeReference.MetadataType)
            {
                case MetadataType.SByte:
                case MetadataType.Byte:
                case MetadataType.Char:
                case MetadataType.Int16:
                case MetadataType.UInt16:
                case MetadataType.Int64:
                case MetadataType.UInt64:
                case MetadataType.Int32:
                case MetadataType.UInt32:
                case MetadataType.Single:
                case MetadataType.Double:
                case MetadataType.Boolean:
                case MetadataType.String:
                    return true;
            }
            return false;
        }

        public static bool IsSupportedCollection(TypeReference typeReference)
        {
            if (!(typeReference is ArrayType || CecilUtils.IsGenericList(typeReference)))
                return false;

            // We don't support arrays like byte[,] etc
            if (typeReference.IsArray && ((ArrayType)typeReference).Rank > 1)
                return false;

            return IsTypeSerializable(CecilUtils.ElementTypeOfCollection(typeReference));
        }

        private static bool ShouldHaveHadAllFieldsPublic(FieldDefinition field)
        {
            return UnityEngineTypePredicates.IsUnityEngineValueType(field.DeclaringType);
        }

        private static bool IsUnityEngineObject(TypeReference typeReference)
        {
            return UnityEngineTypePredicates.IsUnityEngineObject(typeReference);
        }

        public static bool IsNonSerialized(TypeReference typeDeclaration)
        {
            if (typeDeclaration == null)
                return true;
            if (typeDeclaration.HasGenericParameters)
                return true;
            if (typeDeclaration.MetadataType == MetadataType.Object)
                return true;
            var fullName = typeDeclaration.FullName;
            if (fullName.StartsWith("System.")) //can this be done better?
                return true;
            if (typeDeclaration.IsArray)
                return true;
            if (typeDeclaration.FullName == UnityEngineTypePredicates.MonoBehaviour)
                return true;
            if (typeDeclaration.FullName == UnityEngineTypePredicates.ScriptableObject)
                return true;
            if (typeDeclaration.IsEnum())
                return true;
            return false;
        }

        public static bool ShouldImplementIDeserializable(TypeReference typeDeclaration)
        {
            if (typeDeclaration.FullName == "UnityEngine.ExposedReference`1")
                return true;

            if (IsNonSerialized(typeDeclaration))
                return false;

            try
            {
                if (UnityEngineTypePredicates.ShouldHaveHadSerializableAttribute(typeDeclaration))
                    return true;

                var resolvedTypeDeclaration = typeDeclaration.CheckedResolve();
                if (resolvedTypeDeclaration.IsValueType)
                {
                    return resolvedTypeDeclaration.IsSerializable && !resolvedTypeDeclaration.CustomAttributes.Any(a => a.AttributeType.FullName.Contains("System.Runtime.CompilerServices.CompilerGenerated"));
                }
                else
                {
                    return (resolvedTypeDeclaration.IsSerializable && !resolvedTypeDeclaration.CustomAttributes.Any(a => a.AttributeType.FullName.Contains("System.Runtime.CompilerServices.CompilerGenerated"))) ||
                        resolvedTypeDeclaration.IsSubclassOf(UnityEngineTypePredicates.MonoBehaviour, UnityEngineTypePredicates.ScriptableObject);
                }
            }
            catch (Exception)
            {
                return false;
            }
        }
    }
}

```

`LICENSE`:

```
MIT License

Copyright (c) 2016 Radu
Copyright (c) 2016-2020 Perfare

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# AssetStudio
[![Build status](https://ci.appveyor.com/api/projects/status/rnu7l90422pdewx4?svg=true)](https://ci.appveyor.com/project/Perfare/assetstudio/branch/master/artifacts)

**None of the repo, the tool, nor the repo owner is affiliated with, or sponsored or authorized by, Unity Technologies or its affiliates.**

AssetStudio is a tool for exploring, extracting and exporting assets and assetbundles.

## Features
* Support version:
  * 3.4 - 2022.1
* Support asset types:
  * **Texture2D** : convert to png, tga, jpeg, bmp
  * **Sprite** : crop Texture2D to png, tga, jpeg, bmp
  * **AudioClip** : mp3, ogg, wav, m4a, fsb. support convert FSB file to WAV(PCM)
  * **Font** : ttf, otf
  * **Mesh** : obj
  * **TextAsset**
  * **Shader**
  * **MovieTexture**
  * **VideoClip**
  * **MonoBehaviour** : json
  * **Animator** : export to FBX file with bound AnimationClip

## Requirements

- AssetStudio.net472
   - [.NET Framework 4.7.2](https://dotnet.microsoft.com/download/dotnet-framework/net472)
- AssetStudio.net5
   - [.NET Desktop Runtime 5.0](https://dotnet.microsoft.com/download/dotnet/5.0)
- AssetStudio.net6
   - [.NET Desktop Runtime 6.0](https://dotnet.microsoft.com/download/dotnet/6.0)


## Usage

### Load Assets/AssetBundles

Use **File-Load file** or **File-Load folder**.

When AssetStudio loads AssetBundles, it decompresses and reads it directly in memory, which may cause a large amount of memory to be used. You can use **File-Extract file** or **File-Extract folder** to extract AssetBundles to another folder, and then read.

### Extract/Decompress AssetBundles

Use **File-Extract file** or **File-Extract folder**.

### Export Assets

use **Export** menu.

### Export Model

Export model from "Scene Hierarchy" using the **Model** menu.

Export Animator from "Asset List" using the **Export** menu.

#### With AnimationClip

Select model from "Scene Hierarchy" then select the AnimationClip from "Asset List", using **Model-Export selected objects with AnimationClip** to export.

Export Animator will export bound AnimationClip or use **Ctrl** to select Animator and AnimationClip from "Asset List", using **Export-Export Animator with selected AnimationClip** to export.

### Export MonoBehaviour

When you select an asset of the MonoBehaviour type for the first time, AssetStudio will ask you the directory where the assembly is located, please select the directory where the assembly is located, such as the `Managed` folder.

#### For Il2Cpp

First, use my another program [Il2CppDumper](https://github.com/Perfare/Il2CppDumper) to generate dummy dll, then when using AssetStudio to select the assembly directory, select the dummy dll folder.

## Build

* Visual Studio 2022 or newer
* **AssetStudioFBXNative** uses [FBX SDK 2020.2.1](https://www.autodesk.com/developer-network/platform-technologies/fbx-sdk-2020-2-1), before building, you need to install the FBX SDK and modify the project file, change include directory and library directory to point to the FBX SDK directory

## Open source libraries used

### Texture2DDecoder
* [Ishotihadus/mikunyan](https://github.com/Ishotihadus/mikunyan)
* [BinomialLLC/crunch](https://github.com/BinomialLLC/crunch)
* [Unity-Technologies/crunch](https://github.com/Unity-Technologies/crunch/tree/unity)

```

`Texture2DDecoderNative/Texture2DDecoderNative.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Language neutral resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEU)
LANGUAGE LANG_ENGLISH, SUBLANG_NEUTRAL
#pragma code_page(65001)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
            VALUE "FileDescription", "Texture2DDecoderNative"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "InternalName", "Texture2DDecoderNative.dll"
            VALUE "LegalCopyright", "Copyright (C) Perfare 2020; Copyright (C) hozuki 2020"
            VALUE "OriginalFilename", "Texture2DDecoderNative.dll"
            VALUE "ProductName", "Texture2DDecoderNative"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END

#endif    // Language neutral resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Texture2DDecoderNative/Texture2DDecoderNative.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="astc.h" />
    <ClInclude Include="atc.h" />
    <ClInclude Include="bcn.h" />
    <ClInclude Include="bool32_t.h" />
    <ClInclude Include="color.h" />
    <ClInclude Include="crunch.h" />
    <ClInclude Include="crunch\crnlib.h" />
    <ClInclude Include="crunch\crn_decomp.h" />
    <ClInclude Include="dllexport.h" />
    <ClInclude Include="endianness.h" />
    <ClInclude Include="etc.h" />
    <ClInclude Include="fp16.h" />
    <ClInclude Include="fp16\bitcasts.h" />
    <ClInclude Include="fp16\fp16.h" />
    <ClInclude Include="pvrtc.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="unitycrunch.h" />
    <ClInclude Include="unitycrunch\crnlib.h" />
    <ClInclude Include="unitycrunch\crn_decomp.h" />
    <ClInclude Include="unitycrunch\crn_defs.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="astc.cpp" />
    <ClCompile Include="atc.cpp" />
    <ClCompile Include="bcn.cpp" />
    <ClCompile Include="crunch.cpp" />
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="etc.cpp" />
    <ClCompile Include="pvrtc.cpp" />
    <ClCompile Include="unitycrunch.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="cpp.hint" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Texture2DDecoderNative.rc" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{29356642-c46e-4144-83d8-22dc09d0d7fd}</ProjectGuid>
    <RootNamespace>Texture2DDecoderNative</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_T2D_DLL;WIN32;_DEBUG;TEXTURE2DDECODERNATIVE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_T2D_DLL;WIN32;NDEBUG;TEXTURE2DDECODERNATIVE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_T2D_DLL;_DEBUG;TEXTURE2DDECODERNATIVE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_T2D_DLL;NDEBUG;TEXTURE2DDECODERNATIVE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
  <Target Name="AfterBuild">
    <MSBuild Condition=" '$(Platform)' == 'Win32' " Projects="$(MSBuildProjectFile)" Properties="Platform=x64;PlatFormTarget=x64" RunEachTargetSeparately="true" />
  </Target>
</Project>
```

`Texture2DDecoderNative/Texture2DDecoderNative.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pvrtc.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="unitycrunch.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="crunch\crnlib.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="crunch\crn_decomp.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="fp16\bitcasts.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="fp16\fp16.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="unitycrunch\crnlib.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="unitycrunch\crn_decomp.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="unitycrunch\crn_defs.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="astc.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="atc.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="bcn.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="color.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="crunch.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="endianness.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="etc.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="fp16.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="dllexport.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="bool32_t.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="unitycrunch.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="astc.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="atc.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="bcn.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="crunch.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="etc.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="pvrtc.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="dllmain.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="cpp.hint" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Texture2DDecoderNative.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Texture2DDecoderNative/astc.cpp`:

```cpp
#include "astc.h"
#include <math.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include "color.h"
#include "fp16.h"

static const int BitReverseTable[] = {
  0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0, 0x08, 0x88, 0x48,
  0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8, 0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4,
  0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4, 0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C,
  0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC, 0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2,
  0x32, 0xB2, 0x72, 0xF2, 0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A,
  0xFA, 0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6, 0x0E, 0x8E,
  0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE, 0x01, 0x81, 0x41, 0xC1, 0x21,
  0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1, 0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
  0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9, 0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55,
  0xD5, 0x35, 0xB5, 0x75, 0xF5, 0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD,
  0x7D, 0xFD, 0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3, 0x0B,
  0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB, 0x07, 0x87, 0x47, 0xC7,
  0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7, 0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F,
  0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF};

static const int WeightPrecTableA[] = {0, 0, 0, 3, 0, 5, 3, 0, 0, 0, 5, 3, 0, 5, 3, 0};
static const int WeightPrecTableB[] = {0, 0, 1, 0, 2, 0, 1, 3, 0, 0, 1, 2, 4, 2, 3, 5};

static const int CemTableA[] = {0, 3, 5, 0, 3, 5, 0, 3, 5, 0, 3, 5, 0, 3, 5, 0, 3, 0, 0};
static const int CemTableB[] = {8, 6, 5, 7, 5, 4, 6, 4, 3, 5, 3, 2, 4, 2, 1, 3, 1, 2, 1};

static inline uint_fast8_t bit_reverse_u8(const uint_fast8_t c, const int bits) {
    return BitReverseTable[c] >> (8 - bits);
}

static inline uint_fast64_t bit_reverse_u64(const uint_fast64_t d, const int bits) {
    uint_fast64_t ret = (uint_fast64_t)BitReverseTable[d & 0xff] << 56 |
      (uint_fast64_t)BitReverseTable[d >> 8 & 0xff] << 48 | (uint_fast64_t)BitReverseTable[d >> 16 & 0xff] << 40 |
      (uint_fast64_t)BitReverseTable[d >> 24 & 0xff] << 32 | (uint_fast32_t)BitReverseTable[d >> 32 & 0xff] << 24 |
      (uint_fast32_t)BitReverseTable[d >> 40 & 0xff] << 16 | (uint_fast16_t)BitReverseTable[d >> 48 & 0xff] << 8 |
      BitReverseTable[d >> 56 & 0xff];
    return ret >> (64 - bits);
}

static inline int getbits(const uint8_t *buf, const int bit, const int len) {
    return (*(int *)(buf + bit / 8) >> (bit % 8)) & ((1 << len) - 1);
}

static inline uint_fast64_t getbits64(const uint8_t *buf, const int bit, const int len) {
    uint_fast64_t mask = len == 64 ? 0xffffffffffffffff : (1ull << len) - 1;
    if (len < 1)
        return 0;
    else if (bit >= 64)
        return (*(uint_fast64_t *)(buf + 8)) >> (bit - 64) & mask;
    else if (bit <= 0)
        return (*(uint_fast64_t *)buf) << -bit & mask;
    else if (bit + len <= 64)
        return (*(uint_fast64_t *)buf) >> bit & mask;
    else
        return ((*(uint_fast64_t *)buf) >> bit | *(uint_fast64_t *)(buf + 8) << (64 - bit)) & mask;
}

static inline uint16_t u8ptr_to_u16(const uint8_t *ptr) {
    return lton16(*(uint16_t *)ptr);
}

static inline uint_fast8_t clamp(const int n) {
    return n < 0 ? 0 : n > 255 ? 255 : n;
}

static inline void bit_transfer_signed(int *a, int *b) {
    *b = (*b >> 1) | (*a & 0x80);
    *a = (*a >> 1) & 0x3f;
    if (*a & 0x20)
        *a -= 0x40;
}

static inline void set_endpoint(int endpoint[8], int r1, int g1, int b1, int a1, int r2, int g2, int b2, int a2) {
    endpoint[0] = r1;
    endpoint[1] = g1;
    endpoint[2] = b1;
    endpoint[3] = a1;
    endpoint[4] = r2;
    endpoint[5] = g2;
    endpoint[6] = b2;
    endpoint[7] = a2;
}

static inline void set_endpoint_clamp(int endpoint[8], int r1, int g1, int b1, int a1, int r2, int g2, int b2, int a2) {
    endpoint[0] = clamp(r1);
    endpoint[1] = clamp(g1);
    endpoint[2] = clamp(b1);
    endpoint[3] = clamp(a1);
    endpoint[4] = clamp(r2);
    endpoint[5] = clamp(g2);
    endpoint[6] = clamp(b2);
    endpoint[7] = clamp(a2);
}

static inline void set_endpoint_blue(int endpoint[8], int r1, int g1, int b1, int a1, int r2, int g2, int b2, int a2) {
    endpoint[0] = (r1 + b1) >> 1;
    endpoint[1] = (g1 + b1) >> 1;
    endpoint[2] = b1;
    endpoint[3] = a1;
    endpoint[4] = (r2 + b2) >> 1;
    endpoint[5] = (g2 + b2) >> 1;
    endpoint[6] = b2;
    endpoint[7] = a2;
}

static inline void set_endpoint_blue_clamp(int endpoint[8], int r1, int g1, int b1, int a1, int r2, int g2, int b2,
                                           int a2) {
    endpoint[0] = clamp((r1 + b1) >> 1);
    endpoint[1] = clamp((g1 + b1) >> 1);
    endpoint[2] = clamp(b1);
    endpoint[3] = clamp(a1);
    endpoint[4] = clamp((r2 + b2) >> 1);
    endpoint[5] = clamp((g2 + b2) >> 1);
    endpoint[6] = clamp(b2);
    endpoint[7] = clamp(a2);
}

static inline uint_fast16_t clamp_hdr(const int n) {
    return n < 0 ? 0 : n > 0xfff ? 0xfff : n;
}

static inline void set_endpoint_hdr(int endpoint[8], int r1, int g1, int b1, int a1, int r2, int g2, int b2, int a2) {
    endpoint[0] = r1;
    endpoint[1] = g1;
    endpoint[2] = b1;
    endpoint[3] = a1;
    endpoint[4] = r2;
    endpoint[5] = g2;
    endpoint[6] = b2;
    endpoint[7] = a2;
}

static inline void set_endpoint_hdr_clamp(int endpoint[8], int r1, int g1, int b1, int a1, int r2, int g2, int b2,
                                          int a2) {
    endpoint[0] = clamp_hdr(r1);
    endpoint[1] = clamp_hdr(g1);
    endpoint[2] = clamp_hdr(b1);
    endpoint[3] = clamp_hdr(a1);
    endpoint[4] = clamp_hdr(r2);
    endpoint[5] = clamp_hdr(g2);
    endpoint[6] = clamp_hdr(b2);
    endpoint[7] = clamp_hdr(a2);
}

typedef uint_fast8_t (*t_select_folor_func_ptr)(int, int, int);

static uint_fast8_t select_color(int v0, int v1, int weight) {
    return ((((v0 << 8 | v0) * (64 - weight) + (v1 << 8 | v1) * weight + 32) >> 6) * 255 + 32768) / 65536;
}

static uint_fast8_t select_color_hdr(int v0, int v1, int weight) {
    uint16_t c = ((v0 << 4) * (64 - weight) + (v1 << 4) * weight + 32) >> 6;
    uint16_t m = c & 0x7ff;
    if (m < 512)
        m *= 3;
    else if (m < 1536)
        m = 4 * m - 512;
    else
        m = 5 * m - 2048;
    float f = fp16_ieee_to_fp32_value((c >> 1 & 0x7c00) | m >> 3);
    return isfinite(f) ? clamp(roundf(f * 255)) : 255;
}

static inline uint8_t f32_to_u8(const float f) {
    float c = roundf(f * 255);
    if (c < 0)
        return 0;
    else if (c > 255)
        return 255;
    else
        return c;
}

static inline uint8_t f16ptr_to_u8(const uint8_t *ptr) {
    return f32_to_u8(fp16_ieee_to_fp32_value(lton16(*(uint16_t *)ptr)));
}

typedef struct {
    int bw;
    int bh;
    int width;
    int height;
    int part_num;
    int dual_plane;
    int plane_selector;
    int weight_range;
    int weight_num;
    int cem[4];
    int cem_range;
    int endpoint_value_num;
    int endpoints[4][8];
    int weights[144][2];
    int partition[144];
} BlockData;

typedef struct {
    int bits;
    int nonbits;
} IntSeqData;

void decode_intseq(const uint8_t *buf, int offset, const int a, const int b, const int count, const int reverse,
                   IntSeqData *out) {
    static int mt[] = {0, 2, 4, 5, 7};
    static int mq[] = {0, 3, 5};
    static int TritsTable[5][256] = {
      {0, 1, 2, 0, 0, 1, 2, 1, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 0, 0, 1, 2, 1, 0, 1, 2, 2, 0, 1, 2, 0, 0, 1, 2, 0, 0,
       1, 2, 1, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 0, 0, 1, 2, 1, 0, 1, 2, 2, 0, 1, 2, 1, 0, 1, 2, 0, 0, 1, 2, 1, 0, 1,
       2, 2, 0, 1, 2, 2, 0, 1, 2, 0, 0, 1, 2, 1, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 0, 0, 1, 2, 1, 0, 1, 2, 2, 0, 1, 2,
       2, 0, 1, 2, 0, 0, 1, 2, 1, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 0, 0, 1, 2, 1, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 0,
       0, 1, 2, 1, 0, 1, 2, 2, 0, 1, 2, 0, 0, 1, 2, 0, 0, 1, 2, 1, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 0, 0, 1, 2, 1, 0,
       1, 2, 2, 0, 1, 2, 1, 0, 1, 2, 0, 0, 1, 2, 1, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 0, 0, 1, 2, 1, 0, 1, 2, 2, 0, 1,
       2, 2, 0, 1, 2, 0, 0, 1, 2, 1, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 0, 0, 1, 2, 1, 0, 1, 2, 2, 0, 1, 2, 2},
      {0, 0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
       1, 1, 0, 2, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 2, 2,
       2, 0, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 1, 2, 2, 2, 0, 0, 0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 0, 2, 2, 2,
       0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 1, 2, 2, 2, 0, 0, 0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 1,
       1, 1, 1, 1, 2, 2, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2,
       2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 1, 2, 2,
       2, 1, 0, 0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 1, 2, 2, 2, 1},
      {0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0,
       0, 0, 2, 0, 0, 0, 2, 2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0,
       0, 2, 2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 2, 2,
       2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 2, 2, 2, 1, 1, 1, 2,
       1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1,
       1, 1, 2, 1, 1, 1, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1,
       1, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 2, 2, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 2, 2},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 1,
       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}};
    static int QuintsTable[3][128] = {
      {0, 1, 2, 3, 4, 0, 4, 4, 0, 1, 2, 3, 4, 1, 4, 4, 0, 1, 2, 3, 4, 2, 4, 4, 0, 1, 2, 3, 4, 3, 4, 4,
       0, 1, 2, 3, 4, 0, 4, 0, 0, 1, 2, 3, 4, 1, 4, 1, 0, 1, 2, 3, 4, 2, 4, 2, 0, 1, 2, 3, 4, 3, 4, 3,
       0, 1, 2, 3, 4, 0, 2, 3, 0, 1, 2, 3, 4, 1, 2, 3, 0, 1, 2, 3, 4, 2, 2, 3, 0, 1, 2, 3, 4, 3, 2, 3,
       0, 1, 2, 3, 4, 0, 0, 1, 0, 1, 2, 3, 4, 1, 0, 1, 0, 1, 2, 3, 4, 2, 0, 1, 0, 1, 2, 3, 4, 3, 0, 1},
      {0, 0, 0, 0, 0, 4, 4, 4, 1, 1, 1, 1, 1, 4, 4, 4, 2, 2, 2, 2, 2, 4, 4, 4, 3, 3, 3, 3, 3, 4, 4, 4,
       0, 0, 0, 0, 0, 4, 0, 4, 1, 1, 1, 1, 1, 4, 1, 4, 2, 2, 2, 2, 2, 4, 2, 4, 3, 3, 3, 3, 3, 4, 3, 4,
       0, 0, 0, 0, 0, 4, 0, 0, 1, 1, 1, 1, 1, 4, 1, 1, 2, 2, 2, 2, 2, 4, 2, 2, 3, 3, 3, 3, 3, 4, 3, 3,
       0, 0, 0, 0, 0, 4, 0, 0, 1, 1, 1, 1, 1, 4, 1, 1, 2, 2, 2, 2, 2, 4, 2, 2, 3, 3, 3, 3, 3, 4, 3, 3},
      {0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 3, 4,
       1, 1, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 4, 4,
       2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2, 2, 4, 4, 2, 2, 2, 2, 2, 2, 4, 4,
       3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4}};

    if (count <= 0)
        return;

    int n = 0;

    if (a == 3) {
        int mask = (1 << b) - 1;
        int block_count = (count + 4) / 5;
        int last_block_count = (count + 4) % 5 + 1;
        int block_size = 8 + 5 * b;
        int last_block_size = (block_size * last_block_count + 4) / 5;

        if (reverse) {
            for (int i = 0, p = offset; i < block_count; i++, p -= block_size) {
                int now_size = (i < block_count - 1) ? block_size : last_block_size;
                uint_fast64_t d = bit_reverse_u64(getbits64(buf, p - now_size, now_size), now_size);
                int x =
                  (d >> b & 3) | (d >> b * 2 & 0xc) | (d >> b * 3 & 0x10) | (d >> b * 4 & 0x60) | (d >> b * 5 & 0x80);
                for (int j = 0; j < 5 && n < count; j++, n++)
                    out[n] = { static_cast<int>(d >> (mt[j] + b * j) & mask), TritsTable[j][x]};
            }
        } else {
            for (int i = 0, p = offset; i < block_count; i++, p += block_size) {
                uint_fast64_t d = getbits64(buf, p, (i < block_count - 1) ? block_size : last_block_size);
                int x =
                  (d >> b & 3) | (d >> b * 2 & 0xc) | (d >> b * 3 & 0x10) | (d >> b * 4 & 0x60) | (d >> b * 5 & 0x80);
                for (int j = 0; j < 5 && n < count; j++, n++)
                    out[n] = { static_cast<int>(d >> (mt[j] + b * j) & mask), TritsTable[j][x]};
            }
        }
    } else if (a == 5) {
        int mask = (1 << b) - 1;
        int block_count = (count + 2) / 3;
        int last_block_count = (count + 2) % 3 + 1;
        int block_size = 7 + 3 * b;
        int last_block_size = (block_size * last_block_count + 2) / 3;

        if (reverse) {
            for (int i = 0, p = offset; i < block_count; i++, p -= block_size) {
                int now_size = (i < block_count - 1) ? block_size : last_block_size;
                uint_fast64_t d = bit_reverse_u64(getbits64(buf, p - now_size, now_size), now_size);
                int x = (d >> b & 7) | (d >> b * 2 & 0x18) | (d >> b * 3 & 0x60);
                for (int j = 0; j < 3 && n < count; j++, n++)
                    out[n] = { static_cast<int>(d >> (mq[j] + b * j) & mask), QuintsTable[j][x]};
            }
        } else {
            for (int i = 0, p = offset; i < block_count; i++, p += block_size) {
                uint_fast64_t d = getbits64(buf, p, (i < block_count - 1) ? block_size : last_block_size);
                int x = (d >> b & 7) | (d >> b * 2 & 0x18) | (d >> b * 3 & 0x60);
                for (int j = 0; j < 3 && n < count; j++, n++)
                    out[n] = { static_cast<int>(d >> (mq[j] + b * j) & mask), QuintsTable[j][x]};
            }
        }
    } else {
        if (reverse)
            for (int p = offset - b; n < count; n++, p -= b)
                out[n] = {bit_reverse_u8(getbits(buf, p, b), b), 0};
        else
            for (int p = offset; n < count; n++, p += b)
                out[n] = {getbits(buf, p, b), 0};
    }
}

void decode_block_params(const uint8_t *buf, BlockData *block_data) {
    block_data->dual_plane = !!(buf[1] & 4);
    block_data->weight_range = (buf[0] >> 4 & 1) | (buf[1] << 2 & 8);

    if (buf[0] & 3) {
        block_data->weight_range |= buf[0] << 1 & 6;
        switch (buf[0] & 0xc) {
        case 0:
            block_data->width = (u8ptr_to_u16(buf) >> 7 & 3) + 4;
            block_data->height = (buf[0] >> 5 & 3) + 2;
            break;
        case 4:
            block_data->width = (u8ptr_to_u16(buf) >> 7 & 3) + 8;
            block_data->height = (buf[0] >> 5 & 3) + 2;
            break;
        case 8:
            block_data->width = (buf[0] >> 5 & 3) + 2;
            block_data->height = (u8ptr_to_u16(buf) >> 7 & 3) + 8;
            break;
        case 12:
            if (buf[1] & 1) {
                block_data->width = (buf[0] >> 7 & 1) + 2;
                block_data->height = (buf[0] >> 5 & 3) + 2;
            } else {
                block_data->width = (buf[0] >> 5 & 3) + 2;
                block_data->height = (buf[0] >> 7 & 1) + 6;
            }
            break;
        }
    } else {
        block_data->weight_range |= buf[0] >> 1 & 6;
        switch (u8ptr_to_u16(buf) & 0x180) {
        case 0:
            block_data->width = 12;
            block_data->height = (buf[0] >> 5 & 3) + 2;
            break;
        case 0x80:
            block_data->width = (buf[0] >> 5 & 3) + 2;
            block_data->height = 12;
            break;
        case 0x100:
            block_data->width = (buf[0] >> 5 & 3) + 6;
            block_data->height = (buf[1] >> 1 & 3) + 6;
            block_data->dual_plane = 0;
            block_data->weight_range &= 7;
            break;
        case 0x180:
            block_data->width = (buf[0] & 0x20) ? 10 : 6;
            block_data->height = (buf[0] & 0x20) ? 6 : 10;
            break;
        }
    }

    block_data->part_num = (buf[1] >> 3 & 3) + 1;

    block_data->weight_num = block_data->width * block_data->height;
    if (block_data->dual_plane)
        block_data->weight_num *= 2;

    int weight_bits, config_bits, cem_base = 0;

    switch (WeightPrecTableA[block_data->weight_range]) {
    case 3:
        weight_bits =
          block_data->weight_num * WeightPrecTableB[block_data->weight_range] + (block_data->weight_num * 8 + 4) / 5;
        break;
    case 5:
        weight_bits =
          block_data->weight_num * WeightPrecTableB[block_data->weight_range] + (block_data->weight_num * 7 + 2) / 3;
        break;
    default:
        weight_bits = block_data->weight_num * WeightPrecTableB[block_data->weight_range];
    }

    if (block_data->part_num == 1) {
        block_data->cem[0] = u8ptr_to_u16(buf + 1) >> 5 & 0xf;
        config_bits = 17;
    } else {
        cem_base = u8ptr_to_u16(buf + 2) >> 7 & 3;
        if (cem_base == 0) {
            int cem = buf[3] >> 1 & 0xf;
            for (int i = 0; i < block_data->part_num; i++)
                block_data->cem[i] = cem;
            config_bits = 29;
        } else {
            for (int i = 0; i < block_data->part_num; i++)
                block_data->cem[i] = ((buf[3] >> (i + 1) & 1) + cem_base - 1) << 2;
            switch (block_data->part_num) {
            case 2:
                block_data->cem[0] |= buf[3] >> 3 & 3;
                block_data->cem[1] |= getbits(buf, 126 - weight_bits, 2);
                break;
            case 3:
                block_data->cem[0] |= buf[3] >> 4 & 1;
                block_data->cem[0] |= getbits(buf, 122 - weight_bits, 2) & 2;
                block_data->cem[1] |= getbits(buf, 124 - weight_bits, 2);
                block_data->cem[2] |= getbits(buf, 126 - weight_bits, 2);
                break;
            case 4:
                for (int i = 0; i < 4; i++)
                    block_data->cem[i] |= getbits(buf, 120 + i * 2 - weight_bits, 2);
                break;
            }
            config_bits = 25 + block_data->part_num * 3;
        }
    }

    if (block_data->dual_plane) {
        config_bits += 2;
        block_data->plane_selector =
          getbits(buf, cem_base ? 130 - weight_bits - block_data->part_num * 3 : 126 - weight_bits, 2);
    }

    int remain_bits = 128 - config_bits - weight_bits;

    block_data->endpoint_value_num = 0;
    for (int i = 0; i < block_data->part_num; i++)
        block_data->endpoint_value_num += (block_data->cem[i] >> 1 & 6) + 2;

    for (int i = 0, endpoint_bits; i < (int)(sizeof(CemTableA) / sizeof(int)); i++) {
        switch (CemTableA[i]) {
        case 3:
            endpoint_bits =
              block_data->endpoint_value_num * CemTableB[i] + (block_data->endpoint_value_num * 8 + 4) / 5;
            break;
        case 5:
            endpoint_bits =
              block_data->endpoint_value_num * CemTableB[i] + (block_data->endpoint_value_num * 7 + 2) / 3;
            break;
        default:
            endpoint_bits = block_data->endpoint_value_num * CemTableB[i];
        }

        if (endpoint_bits <= remain_bits) {
            block_data->cem_range = i;
            break;
        }
    }
}

void decode_endpoints_hdr7(int *endpoints, int *v) {
    int modeval = (v[2] >> 4 & 0x8) | (v[1] >> 5 & 0x4) | (v[0] >> 6);
    int major_component, mode;
    if ((modeval & 0xc) != 0xc) {
        major_component = modeval >> 2;
        mode = modeval & 3;
    } else if (modeval != 0xf) {
        major_component = modeval & 3;
        mode = 4;
    } else {
        major_component = 0;
        mode = 5;
    }
    int c[] = {v[0] & 0x3f, v[1] & 0x1f, v[2] & 0x1f, v[3] & 0x1f};

    switch (mode) {
    case 0:
        c[3] |= v[3] & 0x60;
        c[0] |= v[3] >> 1 & 0x40;
        c[0] |= v[2] << 1 & 0x80;
        c[0] |= v[1] << 3 & 0x300;
        c[0] |= v[2] << 5 & 0x400;
        c[0] <<= 1;
        c[1] <<= 1;
        c[2] <<= 1;
        c[3] <<= 1;
        break;
    case 1:
        c[1] |= v[1] & 0x20;
        c[2] |= v[2] & 0x20;
        c[0] |= v[3] >> 1 & 0x40;
        c[0] |= v[2] << 1 & 0x80;
        c[0] |= v[1] << 2 & 0x100;
        c[0] |= v[3] << 4 & 0x600;
        c[0] <<= 1;
        c[1] <<= 1;
        c[2] <<= 1;
        c[3] <<= 1;
        break;
    case 2:
        c[3] |= v[3] & 0xe0;
        c[0] |= v[2] << 1 & 0xc0;
        c[0] |= v[1] << 3 & 0x300;
        c[0] <<= 2;
        c[1] <<= 2;
        c[2] <<= 2;
        c[3] <<= 2;
        break;
    case 3:
        c[1] |= v[1] & 0x20;
        c[2] |= v[2] & 0x20;
        c[3] |= v[3] & 0x60;
        c[0] |= v[3] >> 1 & 0x40;
        c[0] |= v[2] << 1 & 0x80;
        c[0] |= v[1] << 2 & 0x100;
        c[0] <<= 3;
        c[1] <<= 3;
        c[2] <<= 3;
        c[3] <<= 3;
        break;
    case 4:
        c[1] |= v[1] & 0x60;
        c[2] |= v[2] & 0x60;
        c[3] |= v[3] & 0x20;
        c[0] |= v[3] >> 1 & 0x40;
        c[0] |= v[3] << 1 & 0x80;
        c[0] <<= 4;
        c[1] <<= 4;
        c[2] <<= 4;
        c[3] <<= 4;
        break;
    case 5:
        c[1] |= v[1] & 0x60;
        c[2] |= v[2] & 0x60;
        c[3] |= v[3] & 0x60;
        c[0] |= v[3] >> 1 & 0x40;
        c[0] <<= 5;
        c[1] <<= 5;
        c[2] <<= 5;
        c[3] <<= 5;
        break;
    }
    if (mode != 5) {
        c[1] = c[0] - c[1];
        c[2] = c[0] - c[2];
    }
    if (major_component == 1)
        set_endpoint_hdr_clamp(endpoints, c[1] - c[3], c[0] - c[3], c[2] - c[3], 0x780, c[1], c[0], c[2], 0x780);
    else if (major_component == 2)
        set_endpoint_hdr_clamp(endpoints, c[2] - c[3], c[1] - c[3], c[0] - c[3], 0x780, c[2], c[1], c[0], 0x780);
    else
        set_endpoint_hdr_clamp(endpoints, c[0] - c[3], c[1] - c[3], c[2] - c[3], 0x780, c[0], c[1], c[2], 0x780);
}

void decode_endpoints_hdr11(int *endpoints, int *v, int alpha1, int alpha2) {
    int major_component = (v[4] >> 7) | (v[5] >> 6 & 2);
    if (major_component == 3) {
        set_endpoint_hdr(endpoints, v[0] << 4, v[2] << 4, v[4] << 5 & 0xfe0, alpha1, v[1] << 4, v[3] << 4,
                         v[5] << 5 & 0xfe0, alpha2);
        return;
    }
    int mode = (v[1] >> 7) | (v[2] >> 6 & 2) | (v[3] >> 5 & 4);
    int va = v[0] | (v[1] << 2 & 0x100);
    int vb0 = v[2] & 0x3f, vb1 = v[3] & 0x3f;
    int vc = v[1] & 0x3f;
    int16_t vd0, vd1;

    switch (mode) {
    case 0:
    case 2:
        vd0 = v[4] & 0x7f;
        if (vd0 & 0x40)
            vd0 |= 0xff80;
        vd1 = v[5] & 0x7f;
        if (vd1 & 0x40)
            vd1 |= 0xff80;
        break;
    case 1:
    case 3:
    case 5:
    case 7:
        vd0 = v[4] & 0x3f;
        if (vd0 & 0x20)
            vd0 |= 0xffc0;
        vd1 = v[5] & 0x3f;
        if (vd1 & 0x20)
            vd1 |= 0xffc0;
        break;
    default:
        vd0 = v[4] & 0x1f;
        if (vd0 & 0x10)
            vd0 |= 0xffe0;
        vd1 = v[5] & 0x1f;
        if (vd1 & 0x10)
            vd1 |= 0xffe0;
        break;
    }

    switch (mode) {
    case 0:
        vb0 |= v[2] & 0x40;
        vb1 |= v[3] & 0x40;
        break;
    case 1:
        vb0 |= v[2] & 0x40;
        vb1 |= v[3] & 0x40;
        vb0 |= v[4] << 1 & 0x80;
        vb1 |= v[5] << 1 & 0x80;
        break;
    case 2:
        va |= v[2] << 3 & 0x200;
        vc |= v[3] & 0x40;
        break;
    case 3:
        va |= v[4] << 3 & 0x200;
        vc |= v[5] & 0x40;
        vb0 |= v[2] & 0x40;
        vb1 |= v[3] & 0x40;
        break;
    case 4:
        va |= v[4] << 4 & 0x200;
        va |= v[5] << 5 & 0x400;
        vb0 |= v[2] & 0x40;
        vb1 |= v[3] & 0x40;
        vb0 |= v[4] << 1 & 0x80;
        vb1 |= v[5] << 1 & 0x80;
        break;
    case 5:
        va |= v[2] << 3 & 0x200;
        va |= v[3] << 4 & 0x400;
        vc |= v[5] & 0x40;
        vc |= v[4] << 1 & 0x80;
        break;
    case 6:
        va |= v[4] << 4 & 0x200;
        va |= v[5] << 5 & 0x400;
        va |= v[4] << 5 & 0x800;
        vc |= v[5] & 0x40;
        vb0 |= v[2] & 0x40;
        vb1 |= v[3] & 0x40;
        break;
    case 7:
        va |= v[2] << 3 & 0x200;
        va |= v[3] << 4 & 0x400;
        va |= v[4] << 5 & 0x800;
        vc |= v[5] & 0x40;
        break;
    }

    int shamt = (mode >> 1) ^ 3;
    va <<= shamt;
    vb0 <<= shamt;
    vb1 <<= shamt;
    vc <<= shamt;
    int mult = 1 << shamt;
    vd0 *= mult;
    vd1 *= mult;

    if (major_component == 1)
        set_endpoint_hdr_clamp(endpoints, va - vb0 - vc - vd0, va - vc, va - vb1 - vc - vd1, alpha1, va - vb0, va,
                               va - vb1, alpha2);
    else if (major_component == 2)
        set_endpoint_hdr_clamp(endpoints, va - vb1 - vc - vd1, va - vb0 - vc - vd0, va - vc, alpha1, va - vb1, va - vb0,
                               va, alpha2);
    else
        set_endpoint_hdr_clamp(endpoints, va - vc, va - vb0 - vc - vd0, va - vb1 - vc - vd1, alpha1, va, va - vb0,
                               va - vb1, alpha2);
}

void decode_endpoints(const uint8_t *buf, BlockData *data) {
    static const int TritsTable[] = {0, 204, 93, 44, 22, 11, 5};
    static const int QuintsTable[] = {0, 113, 54, 26, 13, 6};
    IntSeqData seq[32];
    int ev[32];
    decode_intseq(buf, data->part_num == 1 ? 17 : 29, CemTableA[data->cem_range], CemTableB[data->cem_range],
                  data->endpoint_value_num, 0, seq);

    switch (CemTableA[data->cem_range]) {
    case 3:
        for (int i = 0, b, c = TritsTable[CemTableB[data->cem_range]]; i < data->endpoint_value_num; i++) {
            int a = (seq[i].bits & 1) * 0x1ff;
            int x = seq[i].bits >> 1;
            switch (CemTableB[data->cem_range]) {
            case 1:
                b = 0;
                break;
            case 2:
                b = 0b100010110 * x;
                break;
            case 3:
                b = x << 7 | x << 2 | x;
                break;
            case 4:
                b = x << 6 | x;
                break;
            case 5:
                b = x << 5 | x >> 2;
                break;
            case 6:
                b = x << 4 | x >> 4;
                break;
            }
            ev[i] = (a & 0x80) | ((seq[i].nonbits * c + b) ^ a) >> 2;
        }
        break;
    case 5:
        for (int i = 0, b, c = QuintsTable[CemTableB[data->cem_range]]; i < data->endpoint_value_num; i++) {
            int a = (seq[i].bits & 1) * 0x1ff;
            int x = seq[i].bits >> 1;
            switch (CemTableB[data->cem_range]) {
            case 1:
                b = 0;
                break;
            case 2:
                b = 0b100001100 * x;
                break;
            case 3:
                b = x << 7 | x << 1 | x >> 1;
                break;
            case 4:
                b = x << 6 | x >> 1;
                break;
            case 5:
                b = x << 5 | x >> 3;
                break;
            }
            ev[i] = (a & 0x80) | ((seq[i].nonbits * c + b) ^ a) >> 2;
        }
        break;
    default:
        switch (CemTableB[data->cem_range]) {
        case 1:
            for (int i = 0; i < data->endpoint_value_num; i++)
                ev[i] = seq[i].bits * 0xff;
            break;
        case 2:
            for (int i = 0; i < data->endpoint_value_num; i++)
                ev[i] = seq[i].bits * 0x55;
            break;
        case 3:
            for (int i = 0; i < data->endpoint_value_num; i++)
                ev[i] = seq[i].bits << 5 | seq[i].bits << 2 | seq[i].bits >> 1;
            break;
        case 4:
            for (int i = 0; i < data->endpoint_value_num; i++)
                ev[i] = seq[i].bits << 4 | seq[i].bits;
            break;
        case 5:
            for (int i = 0; i < data->endpoint_value_num; i++)
                ev[i] = seq[i].bits << 3 | seq[i].bits >> 2;
            break;
        case 6:
            for (int i = 0; i < data->endpoint_value_num; i++)
                ev[i] = seq[i].bits << 2 | seq[i].bits >> 4;
            break;
        case 7:
            for (int i = 0; i < data->endpoint_value_num; i++)
                ev[i] = seq[i].bits << 1 | seq[i].bits >> 6;
            break;
        case 8:
            for (int i = 0; i < data->endpoint_value_num; i++)
                ev[i] = seq[i].bits;
            break;
        }
    }

    int *v = ev;
    for (int cem = 0; cem < data->part_num; v += (data->cem[cem] / 4 + 1) * 2, cem++) {
        switch (data->cem[cem]) {
        case 0:
            set_endpoint(data->endpoints[cem], v[0], v[0], v[0], 255, v[1], v[1], v[1], 255);
            break;
        case 1: {
            int l0 = (v[0] >> 2) | (v[1] & 0xc0);
            int l1 = clamp(l0 + (v[1] & 0x3f));
            set_endpoint(data->endpoints[cem], l0, l0, l0, 255, l1, l1, l1, 255);
        } break;
        case 2: {
            int y0, y1;
            if (v[0] <= v[1]) {
                y0 = v[0] << 4;
                y1 = v[1] << 4;
            } else {
                y0 = (v[1] << 4) + 8;
                y1 = (v[0] << 4) - 8;
            }
            set_endpoint_hdr(data->endpoints[cem], y0, y0, y0, 0x780, y1, y1, y1, 0x780);
        } break;
        case 3: {
            int y0, d;
            if (v[0] & 0x80) {
                y0 = (v[1] & 0xe0) << 4 | (v[0] & 0x7f) << 2;
                d = (v[1] & 0x1f) << 2;
            } else {
                y0 = (v[1] & 0xf0) << 4 | (v[0] & 0x7f) << 1;
                d = (v[1] & 0x0f) << 1;
            }
            int y1 = clamp_hdr(y0 + d);
            set_endpoint_hdr(data->endpoints[cem], y0, y0, y0, 0x780, y1, y1, y1, 0x780);
        } break;
        case 4:
            set_endpoint(data->endpoints[cem], v[0], v[0], v[0], v[2], v[1], v[1], v[1], v[3]);
            break;
        case 5:
            bit_transfer_signed(&v[1], &v[0]);
            bit_transfer_signed(&v[3], &v[2]);
            v[1] += v[0];
            set_endpoint_clamp(data->endpoints[cem], v[0], v[0], v[0], v[2], v[1], v[1], v[1], v[2] + v[3]);
            break;
        case 6:
            set_endpoint(data->endpoints[cem], v[0] * v[3] >> 8, v[1] * v[3] >> 8, v[2] * v[3] >> 8, 255, v[0], v[1],
                         v[2], 255);
            break;
        case 7:
            decode_endpoints_hdr7(data->endpoints[cem], v);
            break;
        case 8:
            if (v[0] + v[2] + v[4] <= v[1] + v[3] + v[5])
                set_endpoint(data->endpoints[cem], v[0], v[2], v[4], 255, v[1], v[3], v[5], 255);
            else
                set_endpoint_blue(data->endpoints[cem], v[1], v[3], v[5], 255, v[0], v[2], v[4], 255);
            break;
        case 9:
            bit_transfer_signed(&v[1], &v[0]);
            bit_transfer_signed(&v[3], &v[2]);
            bit_transfer_signed(&v[5], &v[4]);
            if (v[1] + v[3] + v[5] >= 0)
                set_endpoint_clamp(data->endpoints[cem], v[0], v[2], v[4], 255, v[0] + v[1], v[2] + v[3], v[4] + v[5],
                                   255);
            else
                set_endpoint_blue_clamp(data->endpoints[cem], v[0] + v[1], v[2] + v[3], v[4] + v[5], 255, v[0], v[2],
                                        v[4], 255);
            break;
        case 10:
            set_endpoint(data->endpoints[cem], v[0] * v[3] >> 8, v[1] * v[3] >> 8, v[2] * v[3] >> 8, v[4], v[0], v[1],
                         v[2], v[5]);
            break;
        case 11:
            decode_endpoints_hdr11(data->endpoints[cem], v, 0x780, 0x780);
            break;
        case 12:
            if (v[0] + v[2] + v[4] <= v[1] + v[3] + v[5])
                set_endpoint(data->endpoints[cem], v[0], v[2], v[4], v[6], v[1], v[3], v[5], v[7]);
            else
                set_endpoint_blue(data->endpoints[cem], v[1], v[3], v[5], v[7], v[0], v[2], v[4], v[6]);
            break;
        case 13:
            bit_transfer_signed(&v[1], &v[0]);
            bit_transfer_signed(&v[3], &v[2]);
            bit_transfer_signed(&v[5], &v[4]);
            bit_transfer_signed(&v[7], &v[6]);
            if (v[1] + v[3] + v[5] >= 0)
                set_endpoint_clamp(data->endpoints[cem], v[0], v[2], v[4], v[6], v[0] + v[1], v[2] + v[3], v[4] + v[5],
                                   v[6] + v[7]);
            else
                set_endpoint_blue_clamp(data->endpoints[cem], v[0] + v[1], v[2] + v[3], v[4] + v[5], v[6] + v[7], v[0],
                                        v[2], v[4], v[6]);
            break;
        case 14:
            decode_endpoints_hdr11(data->endpoints[cem], v, v[6], v[7]);
            break;
        case 15: {
            int mode = ((v[6] >> 7) & 1) | ((v[7] >> 6) & 2);
            v[6] &= 0x7f;
            v[7] &= 0x7f;
            if (mode == 3) {
                decode_endpoints_hdr11(data->endpoints[cem], v, v[6] << 5, v[7] << 5);
            } else {
                v[6] |= (v[7] << (mode + 1)) & 0x780;
                v[7] = ((v[7] & (0x3f >> mode)) ^ (0x20 >> mode)) - (0x20 >> mode);
                v[6] <<= 4 - mode;
                v[7] <<= 4 - mode;
                decode_endpoints_hdr11(data->endpoints[cem], v, v[6], clamp_hdr(v[6] + v[7]));
            }
        } break;
        //default:
        //    rb_raise(rb_eStandardError, "Unsupported ASTC format");
        }
    }
}

void decode_weights(const uint8_t *buf, BlockData *data) {
    IntSeqData seq[128];
    int wv[128] = {};
    decode_intseq(buf, 128, WeightPrecTableA[data->weight_range], WeightPrecTableB[data->weight_range],
                  data->weight_num, 1, seq);

    if (WeightPrecTableA[data->weight_range] == 0) {
        switch (WeightPrecTableB[data->weight_range]) {
        case 1:
            for (int i = 0; i < data->weight_num; i++)
                wv[i] = seq[i].bits ? 63 : 0;
            break;
        case 2:
            for (int i = 0; i < data->weight_num; i++)
                wv[i] = seq[i].bits << 4 | seq[i].bits << 2 | seq[i].bits;
            break;
        case 3:
            for (int i = 0; i < data->weight_num; i++)
                wv[i] = seq[i].bits << 3 | seq[i].bits;
            break;
        case 4:
            for (int i = 0; i < data->weight_num; i++)
                wv[i] = seq[i].bits << 2 | seq[i].bits >> 2;
            break;
        case 5:
            for (int i = 0; i < data->weight_num; i++)
                wv[i] = seq[i].bits << 1 | seq[i].bits >> 4;
            break;
        }
        for (int i = 0; i < data->weight_num; i++)
            if (wv[i] > 32)
                ++wv[i];
    } else if (WeightPrecTableB[data->weight_range] == 0) {
        int s = WeightPrecTableA[data->weight_range] == 3 ? 32 : 16;
        for (int i = 0; i < data->weight_num; i++)
            wv[i] = seq[i].nonbits * s;
    } else {
        if (WeightPrecTableA[data->weight_range] == 3) {
            switch (WeightPrecTableB[data->weight_range]) {
            case 1:
                for (int i = 0; i < data->weight_num; i++)
                    wv[i] = seq[i].nonbits * 50;
                break;
            case 2:
                for (int i = 0; i < data->weight_num; i++) {
                    wv[i] = seq[i].nonbits * 23;
                    if (seq[i].bits & 2)
                        wv[i] += 0b1000101;
                }
                break;
            case 3:
                for (int i = 0; i < data->weight_num; i++)
                    wv[i] = seq[i].nonbits * 11 + ((seq[i].bits << 4 | seq[i].bits >> 1) & 0b1100011);
                break;
            }
        } else if (WeightPrecTableA[data->weight_range] == 5) {
            switch (WeightPrecTableB[data->weight_range]) {
            case 1:
                for (int i = 0; i < data->weight_num; i++)
                    wv[i] = seq[i].nonbits * 28;
                break;
            case 2:
                for (int i = 0; i < data->weight_num; i++) {
                    wv[i] = seq[i].nonbits * 13;
                    if (seq[i].bits & 2)
                        wv[i] += 0b1000010;
                }
                break;
            }
        }
        for (int i = 0; i < data->weight_num; i++) {
            int a = (seq[i].bits & 1) * 0x7f;
            wv[i] = (a & 0x20) | ((wv[i] ^ a) >> 2);
            if (wv[i] > 32)
                ++wv[i];
        }
    }

    int ds = (1024 + data->bw / 2) / (data->bw - 1);
    int dt = (1024 + data->bh / 2) / (data->bh - 1);
    int pn = data->dual_plane ? 2 : 1;

    for (int t = 0, i = 0; t < data->bh; t++) {
        for (int s = 0; s < data->bw; s++, i++) {
            int gs = (ds * s * (data->width - 1) + 32) >> 6;
            int gt = (dt * t * (data->height - 1) + 32) >> 6;
            int fs = gs & 0xf;
            int ft = gt & 0xf;
            int v = (gs >> 4) + (gt >> 4) * data->width;
            int w11 = (fs * ft + 8) >> 4;
            int w10 = ft - w11;
            int w01 = fs - w11;
            int w00 = 16 - fs - ft + w11;

            for (int p = 0; p < pn; p++) {
                int p00 = wv[v * pn + p];
                int p01 = wv[(v + 1) * pn + p];
                int p10 = wv[(v + data->width) * pn + p];
                int p11 = wv[(v + data->width + 1) * pn + p];
                data->weights[i][p] = (p00 * w00 + p01 * w01 + p10 * w10 + p11 * w11 + 8) >> 4;
            }
        }
    }
}

void select_partition(const uint8_t *buf, BlockData *data) {
    int small_block = data->bw * data->bh < 31;
    int seed = (*(int *)buf >> 13 & 0x3ff) | (data->part_num - 1) << 10;

    uint32_t rnum = seed;
    rnum ^= rnum >> 15;
    rnum -= rnum << 17;
    rnum += rnum << 7;
    rnum += rnum << 4;
    rnum ^= rnum >> 5;
    rnum += rnum << 16;
    rnum ^= rnum >> 7;
    rnum ^= rnum >> 3;
    rnum ^= rnum << 6;
    rnum ^= rnum >> 17;

    int seeds[8];
    for (int i = 0; i < 8; i++) {
        seeds[i] = (rnum >> (i * 4)) & 0xF;
        seeds[i] *= seeds[i];
    }

    int sh[2] = {seed & 2 ? 4 : 5, data->part_num == 3 ? 6 : 5};

    if (seed & 1)
        for (int i = 0; i < 8; i++)
            seeds[i] >>= sh[i % 2];
    else
        for (int i = 0; i < 8; i++)
            seeds[i] >>= sh[1 - i % 2];

    if (small_block) {
        for (int t = 0, i = 0; t < data->bh; t++) {
            for (int s = 0; s < data->bw; s++, i++) {
                int x = s << 1;
                int y = t << 1;
                int a = (seeds[0] * x + seeds[1] * y + (rnum >> 14)) & 0x3f;
                int b = (seeds[2] * x + seeds[3] * y + (rnum >> 10)) & 0x3f;
                int c = data->part_num < 3 ? 0 : (seeds[4] * x + seeds[5] * y + (rnum >> 6)) & 0x3f;
                int d = data->part_num < 4 ? 0 : (seeds[6] * x + seeds[7] * y + (rnum >> 2)) & 0x3f;
                data->partition[i] = (a >= b && a >= c && a >= d) ? 0 : (b >= c && b >= d) ? 1 : (c >= d) ? 2 : 3;
            }
        }
    } else {
        for (int y = 0, i = 0; y < data->bh; y++) {
            for (int x = 0; x < data->bw; x++, i++) {
                int a = (seeds[0] * x + seeds[1] * y + (rnum >> 14)) & 0x3f;
                int b = (seeds[2] * x + seeds[3] * y + (rnum >> 10)) & 0x3f;
                int c = data->part_num < 3 ? 0 : (seeds[4] * x + seeds[5] * y + (rnum >> 6)) & 0x3f;
                int d = data->part_num < 4 ? 0 : (seeds[6] * x + seeds[7] * y + (rnum >> 2)) & 0x3f;
                data->partition[i] = (a >= b && a >= c && a >= d) ? 0 : (b >= c && b >= d) ? 1 : (c >= d) ? 2 : 3;
            }
        }
    }
}

void applicate_color(const BlockData *data, uint32_t *outbuf) {
    static const t_select_folor_func_ptr FuncTableC[] = {
      select_color, select_color,     select_color_hdr, select_color_hdr, select_color, select_color,
      select_color, select_color_hdr, select_color,     select_color,     select_color, select_color_hdr,
      select_color, select_color,     select_color_hdr, select_color_hdr};
    static const t_select_folor_func_ptr FuncTableA[] = {
      select_color, select_color,     select_color_hdr, select_color_hdr, select_color, select_color,
      select_color, select_color_hdr, select_color,     select_color,     select_color, select_color_hdr,
      select_color, select_color,     select_color,     select_color_hdr};
    if (data->dual_plane) {
        int ps[] = {0, 0, 0, 0};
        ps[data->plane_selector] = 1;
        if (data->part_num > 1) {
            for (int i = 0; i < data->bw * data->bh; i++) {
                int p = data->partition[i];
                uint_fast8_t r =
                  FuncTableC[data->cem[p]](data->endpoints[p][0], data->endpoints[p][4], data->weights[i][ps[0]]);
                uint_fast8_t g =
                  FuncTableC[data->cem[p]](data->endpoints[p][1], data->endpoints[p][5], data->weights[i][ps[1]]);
                uint_fast8_t b =
                  FuncTableC[data->cem[p]](data->endpoints[p][2], data->endpoints[p][6], data->weights[i][ps[2]]);
                uint_fast8_t a =
                  FuncTableA[data->cem[p]](data->endpoints[p][3], data->endpoints[p][7], data->weights[i][ps[3]]);
                outbuf[i] = color(r, g, b, a);
            }
        } else {
            for (int i = 0; i < data->bw * data->bh; i++) {
                uint_fast8_t r =
                  FuncTableC[data->cem[0]](data->endpoints[0][0], data->endpoints[0][4], data->weights[i][ps[0]]);
                uint_fast8_t g =
                  FuncTableC[data->cem[0]](data->endpoints[0][1], data->endpoints[0][5], data->weights[i][ps[1]]);
                uint_fast8_t b =
                  FuncTableC[data->cem[0]](data->endpoints[0][2], data->endpoints[0][6], data->weights[i][ps[2]]);
                uint_fast8_t a =
                  FuncTableA[data->cem[0]](data->endpoints[0][3], data->endpoints[0][7], data->weights[i][ps[3]]);
                outbuf[i] = color(r, g, b, a);
            }
        }
    } else if (data->part_num > 1) {
        for (int i = 0; i < data->bw * data->bh; i++) {
            int p = data->partition[i];
            uint_fast8_t r =
              FuncTableC[data->cem[p]](data->endpoints[p][0], data->endpoints[p][4], data->weights[i][0]);
            uint_fast8_t g =
              FuncTableC[data->cem[p]](data->endpoints[p][1], data->endpoints[p][5], data->weights[i][0]);
            uint_fast8_t b =
              FuncTableC[data->cem[p]](data->endpoints[p][2], data->endpoints[p][6], data->weights[i][0]);
            uint_fast8_t a =
              FuncTableA[data->cem[p]](data->endpoints[p][3], data->endpoints[p][7], data->weights[i][0]);
            outbuf[i] = color(r, g, b, a);
        }
    } else {
        for (int i = 0; i < data->bw * data->bh; i++) {
            uint_fast8_t r =
              FuncTableC[data->cem[0]](data->endpoints[0][0], data->endpoints[0][4], data->weights[i][0]);
            uint_fast8_t g =
              FuncTableC[data->cem[0]](data->endpoints[0][1], data->endpoints[0][5], data->weights[i][0]);
            uint_fast8_t b =
              FuncTableC[data->cem[0]](data->endpoints[0][2], data->endpoints[0][6], data->weights[i][0]);
            uint_fast8_t a =
              FuncTableA[data->cem[0]](data->endpoints[0][3], data->endpoints[0][7], data->weights[i][0]);
            outbuf[i] = color(r, g, b, a);
        }
    }
}

void decode_block(const uint8_t *buf, const int bw, const int bh, uint32_t *outbuf) {
    if (buf[0] == 0xfc && (buf[1] & 1) == 1) {
        uint_fast32_t c;
        if (buf[1] & 2)
            c = color(f16ptr_to_u8(buf + 8), f16ptr_to_u8(buf + 10), f16ptr_to_u8(buf + 12), f16ptr_to_u8(buf + 14));
        else
            c = color(buf[9], buf[11], buf[13], buf[15]);
        for (int i = 0; i < bw * bh; i++)
            outbuf[i] = c;
    } else if (((buf[0] & 0xc3) == 0xc0 && (buf[1] & 1) == 1) || (buf[0] & 0xf) == 0) {
        uint_fast32_t c = color(255, 0, 255, 255);
        for (int i = 0; i < bw * bh; i++)
            outbuf[i] = c;
    } else {
        BlockData block_data;
        block_data.bw = bw;
        block_data.bh = bh;
        decode_block_params(buf, &block_data);
        decode_endpoints(buf, &block_data);
        decode_weights(buf, &block_data);
        if (block_data.part_num > 1)
            select_partition(buf, &block_data);
        applicate_color(&block_data, outbuf);
    }
}

int decode_astc(const uint8_t *data, const long w, const long h, const int bw, const int bh, uint32_t *image) {
    const long num_blocks_x = (w + bw - 1) / bw;
    const long num_blocks_y = (h + bh - 1) / bh;
    uint32_t buffer[144];
    const uint8_t *d = data;
    for (long by = 0; by < num_blocks_y; by++) {
        for (long bx = 0; bx < num_blocks_x; bx++, d += 16) {
            decode_block(d, bw, bh, buffer);
            copy_block_buffer(bx, by, w, h, bw, bh, buffer, image);
        }
    }
    return 1;
}

```

`Texture2DDecoderNative/astc.h`:

```h
#ifndef ASTC_H
#define ASTC_H

#include <stdint.h>

int decode_astc(const uint8_t *, const long, const long, const int, const int, uint32_t *);

#endif /* end of include guard: ASTC_H */

```

`Texture2DDecoderNative/atc.cpp`:

```cpp
#include "bcn.h"
#include "atc.h"
#include "color.h"
#include <algorithm>

static uint8_t expand_quantized(uint8_t v, int bits) {
	v = v << (8 - bits);
	return v | (v >> bits);
}

void decode_atc_block(const uint8_t* _src, uint32_t* _dst)
{
	uint8_t colors[4 * 4];

	uint32_t c0 = _src[0] | (_src[1] << 8);
	uint32_t c1 = _src[2] | (_src[3] << 8);

	if (0 == (c0 & 0x8000))
	{
		colors[0] = expand_quantized((c0 >> 0) & 0x1f, 5);
		colors[1] = expand_quantized((c0 >> 5) & 0x1f, 5);
		colors[2] = expand_quantized((c0 >> 10) & 0x1f, 5);

		colors[12] = expand_quantized((c1 >> 0) & 0x1f, 5);
		colors[13] = expand_quantized((c1 >> 5) & 0x3f, 6);
		colors[14] = expand_quantized((c1 >> 11) & 0x1f, 5);

		colors[4] = (5 * colors[0] + 3 * colors[12]) / 8;
		colors[5] = (5 * colors[1] + 3 * colors[13]) / 8;
		colors[6] = (5 * colors[2] + 3 * colors[14]) / 8;

		colors[8] = (3 * colors[0] + 5 * colors[12]) / 8;
		colors[9] = (3 * colors[1] + 5 * colors[13]) / 8;
		colors[10] = (3 * colors[2] + 5 * colors[14]) / 8;
	}
	else
	{
		colors[0] = 0;
		colors[1] = 0;
		colors[2] = 0;

		colors[8] = expand_quantized((c0 >> 0) & 0x1f, 5);
		colors[9] = expand_quantized((c0 >> 5) & 0x1f, 5);
		colors[10] = expand_quantized((c0 >> 10) & 0x1f, 5);

		colors[12] = expand_quantized((c1 >> 0) & 0x1f, 5);
		colors[13] = expand_quantized((c1 >> 5) & 0x3f, 6);
		colors[14] = expand_quantized((c1 >> 11) & 0x1f, 5);

		colors[4] = std::max(0, colors[8] - colors[12] / 4);
		colors[5] = std::max(0, colors[9] - colors[13] / 4);
		colors[6] = std::max(0, colors[10] - colors[14] / 4);
	}

	for (uint32_t i = 0, next = 8 * 4; i < 16; i += 1, next += 2)
	{
		int32_t idx = ((_src[next >> 3] >> (next & 7)) & 3) * 4;
		_dst[i] = color(colors[idx + 2], colors[idx + 1], colors[idx + 0], 255);
	}
}

int decode_atc_rgb4(const uint8_t* data, uint32_t m_width, uint32_t m_height, uint32_t* image) {
	uint32_t m_block_width = 4;
	uint32_t m_block_height = 4;
	uint32_t m_blocks_x = (m_width + m_block_width - 1) / m_block_width;
	uint32_t m_blocks_y = (m_height + m_block_height - 1) / m_block_height;
	uint32_t buffer[16];
	for (uint32_t by = 0; by < m_blocks_y; by++) {
		for (uint32_t bx = 0; bx < m_blocks_x; bx++, data += 8) {
			decode_atc_block(data, buffer);
			copy_block_buffer(bx, by, m_width, m_height, m_block_width, m_block_height, buffer, image);
		}
	}
	return 1;
}

int decode_atc_rgba8(const uint8_t* data, uint32_t m_width, uint32_t m_height, uint32_t* image) {
	uint32_t m_block_width = 4;
	uint32_t m_block_height = 4;
	uint32_t m_blocks_x = (m_width + m_block_width - 1) / m_block_width;
	uint32_t m_blocks_y = (m_height + m_block_height - 1) / m_block_height;
	uint32_t buffer[16];
	for (uint32_t by = 0; by < m_blocks_y; by++) {
		for (uint32_t bx = 0; bx < m_blocks_x; bx++, data += 16) {
			decode_atc_block(data + 8, buffer);
			decode_bc3_alpha(data, buffer, 3);
			copy_block_buffer(bx, by, m_width, m_height, m_block_width, m_block_height, buffer, image);
		}
	}
	return 1;
}
```

`Texture2DDecoderNative/atc.h`:

```h
#pragma once
#include <stdint.h>

int decode_atc_rgb4(const uint8_t* data, uint32_t m_width, uint32_t m_height, uint32_t* image);
int decode_atc_rgba8(const uint8_t* data, uint32_t m_width, uint32_t m_height, uint32_t* image);
```

`Texture2DDecoderNative/bcn.cpp`:

```cpp
#include "bcn.h"
#include <stdint.h>
#include <assert.h>
#include <algorithm>
#include "color.h"
#include "fp16.h"

static inline void decode_bc1_block(const uint8_t* data, uint32_t* outbuf) {
	uint8_t r0, g0, b0, r1, g1, b1;
	int q0 = *(uint16_t*)(data);
	int q1 = *(uint16_t*)(data + 2);
	rgb565_le(q0, &r0, &g0, &b0);
	rgb565_le(q1, &r1, &g1, &b1);
	uint_fast32_t c[4] = { color(r0, g0, b0, 255), color(r1, g1, b1, 255) };
	if (q0 > q1) {
		c[2] = color((r0 * 2 + r1) / 3, (g0 * 2 + g1) / 3, (b0 * 2 + b1) / 3, 255);
		c[3] = color((r0 + r1 * 2) / 3, (g0 + g1 * 2) / 3, (b0 + b1 * 2) / 3, 255);
	}
	else {
		c[2] = color((r0 + r1) / 2, (g0 + g1) / 2, (b0 + b1) / 2, 255);
		c[3] = color(0, 0, 0, 255);
	}
	uint_fast32_t d = lton32(*(uint32_t*)(data + 4));
	for (int i = 0; i < 16; i++, d >>= 2)
		outbuf[i] = c[d & 3];
}

int decode_bc1(const uint8_t* data, const long w, const long h, uint32_t* image) {
	long num_blocks_x = (w + 3) / 4;
	long num_blocks_y = (h + 3) / 4;
	uint32_t buffer[16];
	const uint8_t* d = data;
	for (long by = 0; by < num_blocks_y; by++) {
		for (long bx = 0; bx < num_blocks_x; bx++, d += 8) {
			decode_bc1_block(d, buffer);
			copy_block_buffer(bx, by, w, h, 4, 4, buffer, image);
		}
	}
	return 1;
}

void decode_bc3_alpha(const uint8_t* data, uint32_t* outbuf, int channel) {
	uint_fast8_t a[8] = { data[0], data[1] };
	if (a[0] > a[1]) {
		a[2] = (a[0] * 6 + a[1]) / 7;
		a[3] = (a[0] * 5 + a[1] * 2) / 7;
		a[4] = (a[0] * 4 + a[1] * 3) / 7;
		a[5] = (a[0] * 3 + a[1] * 4) / 7;
		a[6] = (a[0] * 2 + a[1] * 5) / 7;
		a[7] = (a[0] + a[1] * 6) / 7;
	}
	else {
		a[2] = (a[0] * 4 + a[1]) / 5;
		a[3] = (a[0] * 3 + a[1] * 2) / 5;
		a[4] = (a[0] * 2 + a[1] * 3) / 5;
		a[5] = (a[0] + a[1] * 4) / 5;
		a[6] = 0;
		a[7] = 255;
	}

	uint8_t* dst = (uint8_t*)outbuf;
	uint_fast64_t d = lton64(*(uint64_t*)data) >> 16;
	for (int i = 0; i < 16; i++, d >>= 3)
		dst[i * 4 + channel] = a[d & 7];
}

static inline void decode_bc3_block(const uint8_t* data, uint32_t* outbuf) {
	decode_bc1_block(data + 8, outbuf);
	decode_bc3_alpha(data, outbuf, 3);
}

int decode_bc3(const uint8_t* data, const long w, const long h, uint32_t* image) {
	long num_blocks_x = (w + 3) / 4;
	long num_blocks_y = (h + 3) / 4;
	uint32_t buffer[16];
	const uint8_t* d = data;
	for (long by = 0; by < num_blocks_y; by++) {
		for (long bx = 0; bx < num_blocks_x; bx++, d += 16) {
			decode_bc3_block(d, buffer);
			copy_block_buffer(bx, by, w, h, 4, 4, buffer, image);
		}
	}
	return 1;
}

static inline void decode_bc4_block(const uint8_t* data, uint32_t* outbuf) {
	decode_bc3_alpha(data, outbuf, 2);
}

int decode_bc4(const uint8_t* data, uint32_t m_width, uint32_t m_height, uint32_t* image) {
	uint32_t m_block_width = 4;
	uint32_t m_block_height = 4;
	uint32_t m_blocks_x = (m_width + m_block_width - 1) / m_block_width;
	uint32_t m_blocks_y = (m_height + m_block_height - 1) / m_block_height;
	uint32_t buffer[16];
	for (uint32_t i = 0; i < 16; i++)
		buffer[i] = 0xff000000;
	for (uint32_t by = 0; by < m_blocks_y; by++) {
		for (uint32_t bx = 0; bx < m_blocks_x; bx++, data += 8) {
			decode_bc4_block(data, buffer);
			copy_block_buffer(bx, by, m_width, m_height, m_block_width, m_block_height, buffer, image);
		}
	}
	return 1;
}

static inline void decode_bc5_block(const uint8_t* data, uint32_t* outbuf) {
	decode_bc3_alpha(data, outbuf, 2);
	decode_bc3_alpha(data + 8, outbuf, 1);
}

int decode_bc5(const uint8_t* data, uint32_t m_width, uint32_t m_height, uint32_t* image) {
	uint32_t m_block_width = 4;
	uint32_t m_block_height = 4;
	uint32_t m_blocks_x = (m_width + m_block_width - 1) / m_block_width;
	uint32_t m_blocks_y = (m_height + m_block_height - 1) / m_block_height;
	uint32_t buffer[16];
	for (uint32_t i = 0; i < 16; i++)
		buffer[i] = 0xff000000;
	for (uint32_t by = 0; by < m_blocks_y; by++) {
		for (uint32_t bx = 0; bx < m_blocks_x; bx++, data += 16) {
			decode_bc5_block(data, buffer);
			copy_block_buffer(bx, by, m_width, m_height, m_block_width, m_block_height, buffer, image);
		}
	}
	return 1;
}

struct BitReader
{
	BitReader(const uint8_t* _data, uint16_t _bitPos = 0)
		: m_data(_data)
		, m_bitPos(_bitPos)
	{
	}

	uint16_t read(uint8_t _numBits)
	{
		const uint16_t pos = m_bitPos / 8;
		const uint16_t shift = m_bitPos & 7;
		uint32_t data = 0;
		memcpy(&data, &m_data[pos], std::min(4, 16 - pos));
		m_bitPos += _numBits;
		return uint16_t((data >> shift) & ((1 << _numBits) - 1));
	}

	uint16_t peek(uint16_t _offset, uint8_t _numBits)
	{
		const uint16_t bitPos = m_bitPos + _offset;
		const uint16_t shift = bitPos & 7;
		uint16_t pos = bitPos / 8;
		uint32_t data = 0;
		memcpy(&data, &m_data[pos], std::min(4, 16 - pos));
		return uint8_t((data >> shift) & ((1 << _numBits) - 1));
	}

	const uint8_t* m_data;
	uint16_t m_bitPos;
};

static const uint16_t s_bptcP2[] =
{ //  3210     0000000000   1111111111   2222222222   3333333333
	0xcccc, // 0, 0, 1, 1,  0, 0, 1, 1,  0, 0, 1, 1,  0, 0, 1, 1
	0x8888, // 0, 0, 0, 1,  0, 0, 0, 1,  0, 0, 0, 1,  0, 0, 0, 1
	0xeeee, // 0, 1, 1, 1,  0, 1, 1, 1,  0, 1, 1, 1,  0, 1, 1, 1
	0xecc8, // 0, 0, 0, 1,  0, 0, 1, 1,  0, 0, 1, 1,  0, 1, 1, 1
	0xc880, // 0, 0, 0, 0,  0, 0, 0, 1,  0, 0, 0, 1,  0, 0, 1, 1
	0xfeec, // 0, 0, 1, 1,  0, 1, 1, 1,  0, 1, 1, 1,  1, 1, 1, 1
	0xfec8, // 0, 0, 0, 1,  0, 0, 1, 1,  0, 1, 1, 1,  1, 1, 1, 1
	0xec80, // 0, 0, 0, 0,  0, 0, 0, 1,  0, 0, 1, 1,  0, 1, 1, 1
	0xc800, // 0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 1,  0, 0, 1, 1
	0xffec, // 0, 0, 1, 1,  0, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1
	0xfe80, // 0, 0, 0, 0,  0, 0, 0, 1,  0, 1, 1, 1,  1, 1, 1, 1
	0xe800, // 0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 1,  0, 1, 1, 1
	0xffe8, // 0, 0, 0, 1,  0, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1
	0xff00, // 0, 0, 0, 0,  0, 0, 0, 0,  1, 1, 1, 1,  1, 1, 1, 1
	0xfff0, // 0, 0, 0, 0,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1
	0xf000, // 0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  1, 1, 1, 1
	0xf710, // 0, 0, 0, 0,  1, 0, 0, 0,  1, 1, 1, 0,  1, 1, 1, 1
	0x008e, // 0, 1, 1, 1,  0, 0, 0, 1,  0, 0, 0, 0,  0, 0, 0, 0
	0x7100, // 0, 0, 0, 0,  0, 0, 0, 0,  1, 0, 0, 0,  1, 1, 1, 0
	0x08ce, // 0, 1, 1, 1,  0, 0, 1, 1,  0, 0, 0, 1,  0, 0, 0, 0
	0x008c, // 0, 0, 1, 1,  0, 0, 0, 1,  0, 0, 0, 0,  0, 0, 0, 0
	0x7310, // 0, 0, 0, 0,  1, 0, 0, 0,  1, 1, 0, 0,  1, 1, 1, 0
	0x3100, // 0, 0, 0, 0,  0, 0, 0, 0,  1, 0, 0, 0,  1, 1, 0, 0
	0x8cce, // 0, 1, 1, 1,  0, 0, 1, 1,  0, 0, 1, 1,  0, 0, 0, 1
	0x088c, // 0, 0, 1, 1,  0, 0, 0, 1,  0, 0, 0, 1,  0, 0, 0, 0
	0x3110, // 0, 0, 0, 0,  1, 0, 0, 0,  1, 0, 0, 0,  1, 1, 0, 0
	0x6666, // 0, 1, 1, 0,  0, 1, 1, 0,  0, 1, 1, 0,  0, 1, 1, 0
	0x366c, // 0, 0, 1, 1,  0, 1, 1, 0,  0, 1, 1, 0,  1, 1, 0, 0
	0x17e8, // 0, 0, 0, 1,  0, 1, 1, 1,  1, 1, 1, 0,  1, 0, 0, 0
	0x0ff0, // 0, 0, 0, 0,  1, 1, 1, 1,  1, 1, 1, 1,  0, 0, 0, 0
	0x718e, // 0, 1, 1, 1,  0, 0, 0, 1,  1, 0, 0, 0,  1, 1, 1, 0
	0x399c, // 0, 0, 1, 1,  1, 0, 0, 1,  1, 0, 0, 1,  1, 1, 0, 0
	0xaaaa, // 0, 1, 0, 1,  0, 1, 0, 1,  0, 1, 0, 1,  0, 1, 0, 1
	0xf0f0, // 0, 0, 0, 0,  1, 1, 1, 1,  0, 0, 0, 0,  1, 1, 1, 1
	0x5a5a, // 0, 1, 0, 1,  1, 0, 1, 0,  0, 1, 0, 1,  1, 0, 1, 0
	0x33cc, // 0, 0, 1, 1,  0, 0, 1, 1,  1, 1, 0, 0,  1, 1, 0, 0
	0x3c3c, // 0, 0, 1, 1,  1, 1, 0, 0,  0, 0, 1, 1,  1, 1, 0, 0
	0x55aa, // 0, 1, 0, 1,  0, 1, 0, 1,  1, 0, 1, 0,  1, 0, 1, 0
	0x9696, // 0, 1, 1, 0,  1, 0, 0, 1,  0, 1, 1, 0,  1, 0, 0, 1
	0xa55a, // 0, 1, 0, 1,  1, 0, 1, 0,  1, 0, 1, 0,  0, 1, 0, 1
	0x73ce, // 0, 1, 1, 1,  0, 0, 1, 1,  1, 1, 0, 0,  1, 1, 1, 0
	0x13c8, // 0, 0, 0, 1,  0, 0, 1, 1,  1, 1, 0, 0,  1, 0, 0, 0
	0x324c, // 0, 0, 1, 1,  0, 0, 1, 0,  0, 1, 0, 0,  1, 1, 0, 0
	0x3bdc, // 0, 0, 1, 1,  1, 0, 1, 1,  1, 1, 0, 1,  1, 1, 0, 0
	0x6996, // 0, 1, 1, 0,  1, 0, 0, 1,  1, 0, 0, 1,  0, 1, 1, 0
	0xc33c, // 0, 0, 1, 1,  1, 1, 0, 0,  1, 1, 0, 0,  0, 0, 1, 1
	0x9966, // 0, 1, 1, 0,  0, 1, 1, 0,  1, 0, 0, 1,  1, 0, 0, 1
	0x0660, // 0, 0, 0, 0,  0, 1, 1, 0,  0, 1, 1, 0,  0, 0, 0, 0
	0x0272, // 0, 1, 0, 0,  1, 1, 1, 0,  0, 1, 0, 0,  0, 0, 0, 0
	0x04e4, // 0, 0, 1, 0,  0, 1, 1, 1,  0, 0, 1, 0,  0, 0, 0, 0
	0x4e40, // 0, 0, 0, 0,  0, 0, 1, 0,  0, 1, 1, 1,  0, 0, 1, 0
	0x2720, // 0, 0, 0, 0,  0, 1, 0, 0,  1, 1, 1, 0,  0, 1, 0, 0
	0xc936, // 0, 1, 1, 0,  1, 1, 0, 0,  1, 0, 0, 1,  0, 0, 1, 1
	0x936c, // 0, 0, 1, 1,  0, 1, 1, 0,  1, 1, 0, 0,  1, 0, 0, 1
	0x39c6, // 0, 1, 1, 0,  0, 0, 1, 1,  1, 0, 0, 1,  1, 1, 0, 0
	0x639c, // 0, 0, 1, 1,  1, 0, 0, 1,  1, 1, 0, 0,  0, 1, 1, 0
	0x9336, // 0, 1, 1, 0,  1, 1, 0, 0,  1, 1, 0, 0,  1, 0, 0, 1
	0x9cc6, // 0, 1, 1, 0,  0, 0, 1, 1,  0, 0, 1, 1,  1, 0, 0, 1
	0x817e, // 0, 1, 1, 1,  1, 1, 1, 0,  1, 0, 0, 0,  0, 0, 0, 1
	0xe718, // 0, 0, 0, 1,  1, 0, 0, 0,  1, 1, 1, 0,  0, 1, 1, 1
	0xccf0, // 0, 0, 0, 0,  1, 1, 1, 1,  0, 0, 1, 1,  0, 0, 1, 1
	0x0fcc, // 0, 0, 1, 1,  0, 0, 1, 1,  1, 1, 1, 1,  0, 0, 0, 0
	0x7744, // 0, 0, 1, 0,  0, 0, 1, 0,  1, 1, 1, 0,  1, 1, 1, 0
	0xee22, // 0, 1, 0, 0,  0, 1, 0, 0,  0, 1, 1, 1,  0, 1, 1, 1
};

static const uint8_t s_bptcA2[] =
{
	15, 15, 15, 15, 15, 15, 15, 15,
	15, 15, 15, 15, 15, 15, 15, 15,
	15,  2,  8,  2,  2,  8,  8, 15,
	 2,  8,  2,  2,  8,  8,  2,  2,
	15, 15,  6,  8,  2,  8, 15, 15,
	 2,  8,  2,  2,  2, 15, 15,  6,
	 6,  2,  6,  8, 15, 15,  2,  2,
	15, 15, 15, 15, 15,  2,  2, 15,
};

static const uint8_t s_bptcFactors[3][16] =
{
	{  0, 21, 43, 64,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
	{  0,  9, 18, 27, 37, 46, 55, 64,  0,  0,  0,  0,  0,  0,  0,  0 },
	{  0,  4,  9, 13, 17, 21, 26, 30, 34, 38, 43, 47, 51, 55, 60, 64 },
};

struct Bc6hModeInfo
{
	uint8_t transformed;
	uint8_t partitionBits;
	uint8_t endpointBits;
	uint8_t deltaBits[3];
};

static const Bc6hModeInfo s_bc6hModeInfo[] =
{ //  +--------------------------- transformed
  //  |  +------------------------ partition bits
  //  |  |  +--------------------- endpoint bits
  //  |  |  |      +-------------- delta bits
	{ 1, 5, 10, {  5,  5,  5 } }, // 00    2-bits
	{ 1, 5,  7, {  6,  6,  6 } }, // 01
	{ 1, 5, 11, {  5,  4,  4 } }, // 00010 5-bits
	{ 0, 0, 10, { 10, 10, 10 } }, // 00011
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 1, 5, 11, {  4,  5,  4 } }, // 00110
	{ 1, 0, 11, {  9,  9,  9 } }, // 00010
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 1, 5, 11, {  4,  4,  5 } }, // 00010
	{ 1, 0, 12, {  8,  8,  8 } }, // 00010
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 1, 5,  9, {  5,  5,  5 } }, // 00010
	{ 1, 0, 16, {  4,  4,  4 } }, // 00010
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 1, 5,  8, {  6,  5,  5 } }, // 00010
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 1, 5,  8, {  5,  6,  5 } }, // 00010
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 1, 5,  8, {  5,  5,  6 } }, // 00010
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 0, 0,  0, {  0,  0,  0 } }, // -
	{ 0, 5,  6, {  6,  6,  6 } }, // 00010
	{ 0, 0,  0, {  0,  0,  0 } }, // -
};

static uint16_t unquantize(uint16_t _value, bool _signed, uint8_t _endpointBits)
{
	const uint16_t maxValue = 1 << (_endpointBits - 1);

	if (_signed)
	{
		if (_endpointBits >= 16)
		{
			return _value;
		}

		const bool sign = !!(_value & 0x8000);
		_value &= 0x7fff;

		uint16_t unq;

		if (0 == _value)
		{
			unq = 0;
		}
		else if (_value >= maxValue - 1)
		{
			unq = 0x7fff;
		}
		else
		{
			unq = ((_value << 15) + 0x4000) >> (_endpointBits - 1);
		}

		return sign ? -unq : unq;
	}

	if (_endpointBits >= 15)
	{
		return _value;
	}

	if (0 == _value)
	{
		return 0;
	}

	if (_value == maxValue)
	{
		return UINT16_MAX;
	}

	return ((_value << 15) + 0x4000) >> (_endpointBits - 1);
}

static uint16_t finish_unquantize(uint16_t _value, bool _signed)
{
	if (_signed)
	{
		const uint16_t sign = _value & 0x8000;
		_value &= 0x7fff;

		return ((_value * 31) >> 5) | sign;
	}

	return (_value * 31) >> 6;
}

static uint16_t sign_extend(uint16_t _value, uint8_t _numBits)
{
	const uint16_t mask = 1 << (_numBits - 1);
	const uint16_t result = (_value ^ mask) - mask;

	return result;
}

static inline uint8_t f32_to_u8(const float f) {
	float c = roundf(f * 255);
	if (c < 0)
		return 0;
	else if (c > 255)
		return 255;
	else
		return c;
}

static uint8_t half_to_u8(uint16_t h) {
	return f32_to_u8(fp16_ieee_to_fp32_value(h));
}

static void decode_bc6_block(const uint8_t* _src, uint32_t* _dst, bool _signed)
{
	BitReader bit(_src);

	uint8_t mode = uint8_t(bit.read(2));

	uint16_t epR[4] = { /* rw, rx, ry, rz */ };
	uint16_t epG[4] = { /* gw, gx, gy, gz */ };
	uint16_t epB[4] = { /* bw, bx, by, bz */ };

	if (mode & 2)
	{
		// 5-bit mode
		mode |= bit.read(3) << 2;

		if (0 == s_bc6hModeInfo[mode].endpointBits)
		{
			memset(_dst, 0, 16 * 4);
			return;
		}

		switch (mode)
		{
		case 2:
			epR[0] |= bit.read(10) << 0;
			epG[0] |= bit.read(10) << 0;
			epB[0] |= bit.read(10) << 0;
			epR[1] |= bit.read(5) << 0;
			epR[0] |= bit.read(1) << 10;
			epG[2] |= bit.read(4) << 0;
			epG[1] |= bit.read(4) << 0;
			epG[0] |= bit.read(1) << 10;
			epB[3] |= bit.read(1) << 0;
			epG[3] |= bit.read(4) << 0;
			epB[1] |= bit.read(4) << 0;
			epB[0] |= bit.read(1) << 10;
			epB[3] |= bit.read(1) << 1;
			epB[2] |= bit.read(4) << 0;
			epR[2] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 2;
			epR[3] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 3;
			break;

		case 3:
			epR[0] |= bit.read(10) << 0;
			epG[0] |= bit.read(10) << 0;
			epB[0] |= bit.read(10) << 0;
			epR[1] |= bit.read(10) << 0;
			epG[1] |= bit.read(10) << 0;
			epB[1] |= bit.read(10) << 0;
			break;

		case 6:
			epR[0] |= bit.read(10) << 0;
			epG[0] |= bit.read(10) << 0;
			epB[0] |= bit.read(10) << 0;
			epR[1] |= bit.read(4) << 0;
			epR[0] |= bit.read(1) << 10;
			epG[3] |= bit.read(1) << 4;
			epG[2] |= bit.read(4) << 0;
			epG[1] |= bit.read(5) << 0;
			epG[0] |= bit.read(1) << 10;
			epG[3] |= bit.read(4) << 0;
			epB[1] |= bit.read(4) << 0;
			epB[0] |= bit.read(1) << 10;
			epB[3] |= bit.read(1) << 1;
			epB[2] |= bit.read(4) << 0;
			epR[2] |= bit.read(4) << 0;
			epB[3] |= bit.read(1) << 0;
			epB[3] |= bit.read(1) << 2;
			epR[3] |= bit.read(4) << 0;
			epG[2] |= bit.read(1) << 4;
			epB[3] |= bit.read(1) << 3;
			break;

		case 7:
			epR[0] |= bit.read(10) << 0;
			epG[0] |= bit.read(10) << 0;
			epB[0] |= bit.read(10) << 0;
			epR[1] |= bit.read(9) << 0;
			epR[0] |= bit.read(1) << 10;
			epG[1] |= bit.read(9) << 0;
			epG[0] |= bit.read(1) << 10;
			epB[1] |= bit.read(9) << 0;
			epB[0] |= bit.read(1) << 10;
			break;

		case 10:
			epR[0] |= bit.read(10) << 0;
			epG[0] |= bit.read(10) << 0;
			epB[0] |= bit.read(10) << 0;
			epR[1] |= bit.read(4) << 0;
			epR[0] |= bit.read(1) << 10;
			epB[2] |= bit.read(1) << 4;
			epG[2] |= bit.read(4) << 0;
			epG[1] |= bit.read(4) << 0;
			epG[0] |= bit.read(1) << 10;
			epB[3] |= bit.read(1) << 0;
			epG[3] |= bit.read(4) << 0;
			epB[1] |= bit.read(5) << 0;
			epB[0] |= bit.read(1) << 10;
			epB[2] |= bit.read(4) << 0;
			epR[2] |= bit.read(4) << 0;
			epB[3] |= bit.read(1) << 1;
			epB[3] |= bit.read(1) << 2;
			epR[3] |= bit.read(4) << 0;
			epB[3] |= bit.read(1) << 4;
			epB[3] |= bit.read(1) << 3;
			break;

		case 11:
			epR[0] |= bit.read(10) << 0;
			epG[0] |= bit.read(10) << 0;
			epB[0] |= bit.read(10) << 0;
			epR[1] |= bit.read(8) << 0;
			epR[0] |= bit.read(1) << 11;
			epR[0] |= bit.read(1) << 10;
			epG[1] |= bit.read(8) << 0;
			epG[0] |= bit.read(1) << 11;
			epG[0] |= bit.read(1) << 10;
			epB[1] |= bit.read(8) << 0;
			epB[0] |= bit.read(1) << 11;
			epB[0] |= bit.read(1) << 10;
			break;

		case 14:
			epR[0] |= bit.read(9) << 0;
			epB[2] |= bit.read(1) << 4;
			epG[0] |= bit.read(9) << 0;
			epG[2] |= bit.read(1) << 4;
			epB[0] |= bit.read(9) << 0;
			epB[3] |= bit.read(1) << 4;
			epR[1] |= bit.read(5) << 0;
			epG[3] |= bit.read(1) << 4;
			epG[2] |= bit.read(4) << 0;
			epG[1] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 0;
			epG[3] |= bit.read(4) << 0;
			epB[1] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 1;
			epB[2] |= bit.read(4) << 0;
			epR[2] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 2;
			epR[3] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 3;
			break;

		case 15:
			epR[0] |= bit.read(10) << 0;
			epG[0] |= bit.read(10) << 0;
			epB[0] |= bit.read(10) << 0;
			epR[1] |= bit.read(4) << 0;
			epR[0] |= bit.read(1) << 15;
			epR[0] |= bit.read(1) << 14;
			epR[0] |= bit.read(1) << 13;
			epR[0] |= bit.read(1) << 12;
			epR[0] |= bit.read(1) << 11;
			epR[0] |= bit.read(1) << 10;
			epG[1] |= bit.read(4) << 0;
			epG[0] |= bit.read(1) << 15;
			epG[0] |= bit.read(1) << 14;
			epG[0] |= bit.read(1) << 13;
			epG[0] |= bit.read(1) << 12;
			epG[0] |= bit.read(1) << 11;
			epG[0] |= bit.read(1) << 10;
			epB[1] |= bit.read(4) << 0;
			epB[0] |= bit.read(1) << 15;
			epB[0] |= bit.read(1) << 14;
			epB[0] |= bit.read(1) << 13;
			epB[0] |= bit.read(1) << 12;
			epB[0] |= bit.read(1) << 11;
			epB[0] |= bit.read(1) << 10;
			break;

		case 18:
			epR[0] |= bit.read(8) << 0;
			epG[3] |= bit.read(1) << 4;
			epB[2] |= bit.read(1) << 4;
			epG[0] |= bit.read(8) << 0;
			epB[3] |= bit.read(1) << 2;
			epG[2] |= bit.read(1) << 4;
			epB[0] |= bit.read(8) << 0;
			epB[3] |= bit.read(1) << 3;
			epB[3] |= bit.read(1) << 4;
			epR[1] |= bit.read(6) << 0;
			epG[2] |= bit.read(4) << 0;
			epG[1] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 0;
			epG[3] |= bit.read(4) << 0;
			epB[1] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 1;
			epB[2] |= bit.read(4) << 0;
			epR[2] |= bit.read(6) << 0;
			epR[3] |= bit.read(6) << 0;
			break;

		case 22:
			epR[0] |= bit.read(8) << 0;
			epB[3] |= bit.read(1) << 0;
			epB[2] |= bit.read(1) << 4;
			epG[0] |= bit.read(8) << 0;
			epG[2] |= bit.read(1) << 5;
			epG[2] |= bit.read(1) << 4;
			epB[0] |= bit.read(8) << 0;
			epG[3] |= bit.read(1) << 5;
			epB[3] |= bit.read(1) << 4;
			epR[1] |= bit.read(5) << 0;
			epG[3] |= bit.read(1) << 4;
			epG[2] |= bit.read(4) << 0;
			epG[1] |= bit.read(6) << 0;
			epG[3] |= bit.read(4) << 0;
			epB[1] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 1;
			epB[2] |= bit.read(4) << 0;
			epR[2] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 2;
			epR[3] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 3;
			break;

		case 26:
			epR[0] |= bit.read(8) << 0;
			epB[3] |= bit.read(1) << 1;
			epB[2] |= bit.read(1) << 4;
			epG[0] |= bit.read(8) << 0;
			epB[2] |= bit.read(1) << 5;
			epG[2] |= bit.read(1) << 4;
			epB[0] |= bit.read(8) << 0;
			epB[3] |= bit.read(1) << 5;
			epB[3] |= bit.read(1) << 4;
			epR[1] |= bit.read(5) << 0;
			epG[3] |= bit.read(1) << 4;
			epG[2] |= bit.read(4) << 0;
			epG[1] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 0;
			epG[3] |= bit.read(4) << 0;
			epB[1] |= bit.read(6) << 0;
			epB[2] |= bit.read(4) << 0;
			epR[2] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 2;
			epR[3] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 3;
			break;

		case 30:
			epR[0] |= bit.read(6) << 0;
			epG[3] |= bit.read(1) << 4;
			epB[3] |= bit.read(1) << 0;
			epB[3] |= bit.read(1) << 1;
			epB[2] |= bit.read(1) << 4;
			epG[0] |= bit.read(6) << 0;
			epG[2] |= bit.read(1) << 5;
			epB[2] |= bit.read(1) << 5;
			epB[3] |= bit.read(1) << 2;
			epG[2] |= bit.read(1) << 4;
			epB[0] |= bit.read(6) << 0;
			epG[3] |= bit.read(1) << 5;
			epB[3] |= bit.read(1) << 3;
			epB[3] |= bit.read(1) << 5;
			epB[3] |= bit.read(1) << 4;
			epR[1] |= bit.read(6) << 0;
			epG[2] |= bit.read(4) << 0;
			epG[1] |= bit.read(6) << 0;
			epG[3] |= bit.read(4) << 0;
			epB[1] |= bit.read(6) << 0;
			epB[2] |= bit.read(4) << 0;
			epR[2] |= bit.read(6) << 0;
			epR[3] |= bit.read(6) << 0;
			break;

		default:
			break;
		}
	}
	else
	{
		switch (mode)
		{
		case 0:
			epG[2] |= bit.read(1) << 4;
			epB[2] |= bit.read(1) << 4;
			epB[3] |= bit.read(1) << 4;
			epR[0] |= bit.read(10) << 0;
			epG[0] |= bit.read(10) << 0;
			epB[0] |= bit.read(10) << 0;
			epR[1] |= bit.read(5) << 0;
			epG[3] |= bit.read(1) << 4;
			epG[2] |= bit.read(4) << 0;
			epG[1] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 0;
			epG[3] |= bit.read(4) << 0;
			epB[1] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 1;
			epB[2] |= bit.read(4) << 0;
			epR[2] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 2;
			epR[3] |= bit.read(5) << 0;
			epB[3] |= bit.read(1) << 3;
			break;

		case 1:
			epG[2] |= bit.read(1) << 5;
			epG[3] |= bit.read(1) << 4;
			epG[3] |= bit.read(1) << 5;
			epR[0] |= bit.read(7) << 0;
			epB[3] |= bit.read(1) << 0;
			epB[3] |= bit.read(1) << 1;
			epB[2] |= bit.read(1) << 4;
			epG[0] |= bit.read(7) << 0;
			epB[2] |= bit.read(1) << 5;
			epB[3] |= bit.read(1) << 2;
			epG[2] |= bit.read(1) << 4;
			epB[0] |= bit.read(7) << 0;
			epB[3] |= bit.read(1) << 3;
			epB[3] |= bit.read(1) << 5;
			epB[3] |= bit.read(1) << 4;
			epR[1] |= bit.read(6) << 0;
			epG[2] |= bit.read(4) << 0;
			epG[1] |= bit.read(6) << 0;
			epG[3] |= bit.read(4) << 0;
			epB[1] |= bit.read(6) << 0;
			epB[2] |= bit.read(4) << 0;
			epR[2] |= bit.read(6) << 0;
			epR[3] |= bit.read(6) << 0;
			break;

		default:
			break;
		}
	}

	const Bc6hModeInfo mi = s_bc6hModeInfo[mode];

	if (_signed)
	{
		epR[0] = sign_extend(epR[0], mi.endpointBits);
		epG[0] = sign_extend(epG[0], mi.endpointBits);
		epB[0] = sign_extend(epB[0], mi.endpointBits);
	}

	const uint8_t numSubsets = !!mi.partitionBits + 1;

	for (uint8_t ii = 1, num = numSubsets * 2; ii < num; ++ii)
	{
		if (_signed
			|| mi.transformed)
		{
			epR[ii] = sign_extend(epR[ii], mi.deltaBits[0]);
			epG[ii] = sign_extend(epG[ii], mi.deltaBits[1]);
			epB[ii] = sign_extend(epB[ii], mi.deltaBits[2]);
		}

		if (mi.transformed)
		{
			const uint16_t mask = (1 << mi.endpointBits) - 1;

			epR[ii] = (epR[ii] + epR[0]) & mask;
			epG[ii] = (epG[ii] + epG[0]) & mask;
			epB[ii] = (epB[ii] + epB[0]) & mask;

			if (_signed)
			{
				epR[ii] = sign_extend(epR[ii], mi.endpointBits);
				epG[ii] = sign_extend(epG[ii], mi.endpointBits);
				epB[ii] = sign_extend(epB[ii], mi.endpointBits);
			}
		}
	}

	for (uint8_t ii = 0, num = numSubsets * 2; ii < num; ++ii)
	{
		epR[ii] = unquantize(epR[ii], _signed, mi.endpointBits);
		epG[ii] = unquantize(epG[ii], _signed, mi.endpointBits);
		epB[ii] = unquantize(epB[ii], _signed, mi.endpointBits);
	}

	const uint8_t partitionSetIdx = uint8_t(mi.partitionBits ? bit.read(5) : 0);
	const uint8_t indexBits = mi.partitionBits ? 3 : 4;
	const uint8_t* factors = s_bptcFactors[indexBits - 2];

	for (uint8_t yy = 0; yy < 4; ++yy)
	{
		for (uint8_t xx = 0; xx < 4; ++xx)
		{
			const uint8_t idx = yy * 4 + xx;

			uint8_t subsetIndex = 0;
			uint8_t indexAnchor = 0;

			if (0 != mi.partitionBits)
			{
				subsetIndex = (s_bptcP2[partitionSetIdx] >> idx) & 1;
				indexAnchor = subsetIndex ? s_bptcA2[partitionSetIdx] : 0;
			}

			const uint8_t anchor = idx == indexAnchor;
			const uint8_t num = indexBits - anchor;
			const uint8_t index = (uint8_t)bit.read(num);

			const uint8_t fc = factors[index];
			const uint8_t fca = 64 - fc;
			const uint8_t fcb = fc;

			subsetIndex *= 2;
			uint16_t rr = finish_unquantize((epR[subsetIndex] * fca + epR[subsetIndex + 1] * fcb + 32) >> 6, _signed);
			uint16_t gg = finish_unquantize((epG[subsetIndex] * fca + epG[subsetIndex + 1] * fcb + 32) >> 6, _signed);
			uint16_t bb = finish_unquantize((epB[subsetIndex] * fca + epB[subsetIndex + 1] * fcb + 32) >> 6, _signed);

			_dst[idx] = color(half_to_u8(rr), half_to_u8(gg), half_to_u8(bb), 255);
		}
	}
}

int decode_bc6(const uint8_t* data, uint32_t m_width, uint32_t m_height, uint32_t* image) {
	uint32_t m_block_width = 4;
	uint32_t m_block_height = 4;
	uint32_t m_blocks_x = (m_width + m_block_width - 1) / m_block_width;
	uint32_t m_blocks_y = (m_height + m_block_height - 1) / m_block_height;
	uint32_t buffer[16];
	for (uint32_t by = 0; by < m_blocks_y; by++) {
		for (uint32_t bx = 0; bx < m_blocks_x; bx++, data += 16) {
			decode_bc6_block(data, buffer, false);
			copy_block_buffer(bx, by, m_width, m_height, m_block_width, m_block_height, buffer, image);
		}
	}
	return 1;
}

static const uint32_t s_bptcP3[] =
{ //  76543210     0000   1111   2222   3333   4444   5555   6666   7777
	0xaa685050, // 0, 0,  1, 1,  0, 0,  1, 1,  0, 2,  2, 1,  2, 2,  2, 2
	0x6a5a5040, // 0, 0,  0, 1,  0, 0,  1, 1,  2, 2,  1, 1,  2, 2,  2, 1
	0x5a5a4200, // 0, 0,  0, 0,  2, 0,  0, 1,  2, 2,  1, 1,  2, 2,  1, 1
	0x5450a0a8, // 0, 2,  2, 2,  0, 0,  2, 2,  0, 0,  1, 1,  0, 1,  1, 1
	0xa5a50000, // 0, 0,  0, 0,  0, 0,  0, 0,  1, 1,  2, 2,  1, 1,  2, 2
	0xa0a05050, // 0, 0,  1, 1,  0, 0,  1, 1,  0, 0,  2, 2,  0, 0,  2, 2
	0x5555a0a0, // 0, 0,  2, 2,  0, 0,  2, 2,  1, 1,  1, 1,  1, 1,  1, 1
	0x5a5a5050, // 0, 0,  1, 1,  0, 0,  1, 1,  2, 2,  1, 1,  2, 2,  1, 1
	0xaa550000, // 0, 0,  0, 0,  0, 0,  0, 0,  1, 1,  1, 1,  2, 2,  2, 2
	0xaa555500, // 0, 0,  0, 0,  1, 1,  1, 1,  1, 1,  1, 1,  2, 2,  2, 2
	0xaaaa5500, // 0, 0,  0, 0,  1, 1,  1, 1,  2, 2,  2, 2,  2, 2,  2, 2
	0x90909090, // 0, 0,  1, 2,  0, 0,  1, 2,  0, 0,  1, 2,  0, 0,  1, 2
	0x94949494, // 0, 1,  1, 2,  0, 1,  1, 2,  0, 1,  1, 2,  0, 1,  1, 2
	0xa4a4a4a4, // 0, 1,  2, 2,  0, 1,  2, 2,  0, 1,  2, 2,  0, 1,  2, 2
	0xa9a59450, // 0, 0,  1, 1,  0, 1,  1, 2,  1, 1,  2, 2,  1, 2,  2, 2
	0x2a0a4250, // 0, 0,  1, 1,  2, 0,  0, 1,  2, 2,  0, 0,  2, 2,  2, 0
	0xa5945040, // 0, 0,  0, 1,  0, 0,  1, 1,  0, 1,  1, 2,  1, 1,  2, 2
	0x0a425054, // 0, 1,  1, 1,  0, 0,  1, 1,  2, 0,  0, 1,  2, 2,  0, 0
	0xa5a5a500, // 0, 0,  0, 0,  1, 1,  2, 2,  1, 1,  2, 2,  1, 1,  2, 2
	0x55a0a0a0, // 0, 0,  2, 2,  0, 0,  2, 2,  0, 0,  2, 2,  1, 1,  1, 1
	0xa8a85454, // 0, 1,  1, 1,  0, 1,  1, 1,  0, 2,  2, 2,  0, 2,  2, 2
	0x6a6a4040, // 0, 0,  0, 1,  0, 0,  0, 1,  2, 2,  2, 1,  2, 2,  2, 1
	0xa4a45000, // 0, 0,  0, 0,  0, 0,  1, 1,  0, 1,  2, 2,  0, 1,  2, 2
	0x1a1a0500, // 0, 0,  0, 0,  1, 1,  0, 0,  2, 2,  1, 0,  2, 2,  1, 0
	0x0050a4a4, // 0, 1,  2, 2,  0, 1,  2, 2,  0, 0,  1, 1,  0, 0,  0, 0
	0xaaa59090, // 0, 0,  1, 2,  0, 0,  1, 2,  1, 1,  2, 2,  2, 2,  2, 2
	0x14696914, // 0, 1,  1, 0,  1, 2,  2, 1,  1, 2,  2, 1,  0, 1,  1, 0
	0x69691400, // 0, 0,  0, 0,  0, 1,  1, 0,  1, 2,  2, 1,  1, 2,  2, 1
	0xa08585a0, // 0, 0,  2, 2,  1, 1,  0, 2,  1, 1,  0, 2,  0, 0,  2, 2
	0xaa821414, // 0, 1,  1, 0,  0, 1,  1, 0,  2, 0,  0, 2,  2, 2,  2, 2
	0x50a4a450, // 0, 0,  1, 1,  0, 1,  2, 2,  0, 1,  2, 2,  0, 0,  1, 1
	0x6a5a0200, // 0, 0,  0, 0,  2, 0,  0, 0,  2, 2,  1, 1,  2, 2,  2, 1
	0xa9a58000, // 0, 0,  0, 0,  0, 0,  0, 2,  1, 1,  2, 2,  1, 2,  2, 2
	0x5090a0a8, // 0, 2,  2, 2,  0, 0,  2, 2,  0, 0,  1, 2,  0, 0,  1, 1
	0xa8a09050, // 0, 0,  1, 1,  0, 0,  1, 2,  0, 0,  2, 2,  0, 2,  2, 2
	0x24242424, // 0, 1,  2, 0,  0, 1,  2, 0,  0, 1,  2, 0,  0, 1,  2, 0
	0x00aa5500, // 0, 0,  0, 0,  1, 1,  1, 1,  2, 2,  2, 2,  0, 0,  0, 0
	0x24924924, // 0, 1,  2, 0,  1, 2,  0, 1,  2, 0,  1, 2,  0, 1,  2, 0
	0x24499224, // 0, 1,  2, 0,  2, 0,  1, 2,  1, 2,  0, 1,  0, 1,  2, 0
	0x50a50a50, // 0, 0,  1, 1,  2, 2,  0, 0,  1, 1,  2, 2,  0, 0,  1, 1
	0x500aa550, // 0, 0,  1, 1,  1, 1,  2, 2,  2, 2,  0, 0,  0, 0,  1, 1
	0xaaaa4444, // 0, 1,  0, 1,  0, 1,  0, 1,  2, 2,  2, 2,  2, 2,  2, 2
	0x66660000, // 0, 0,  0, 0,  0, 0,  0, 0,  2, 1,  2, 1,  2, 1,  2, 1
	0xa5a0a5a0, // 0, 0,  2, 2,  1, 1,  2, 2,  0, 0,  2, 2,  1, 1,  2, 2
	0x50a050a0, // 0, 0,  2, 2,  0, 0,  1, 1,  0, 0,  2, 2,  0, 0,  1, 1
	0x69286928, // 0, 2,  2, 0,  1, 2,  2, 1,  0, 2,  2, 0,  1, 2,  2, 1
	0x44aaaa44, // 0, 1,  0, 1,  2, 2,  2, 2,  2, 2,  2, 2,  0, 1,  0, 1
	0x66666600, // 0, 0,  0, 0,  2, 1,  2, 1,  2, 1,  2, 1,  2, 1,  2, 1
	0xaa444444, // 0, 1,  0, 1,  0, 1,  0, 1,  0, 1,  0, 1,  2, 2,  2, 2
	0x54a854a8, // 0, 2,  2, 2,  0, 1,  1, 1,  0, 2,  2, 2,  0, 1,  1, 1
	0x95809580, // 0, 0,  0, 2,  1, 1,  1, 2,  0, 0,  0, 2,  1, 1,  1, 2
	0x96969600, // 0, 0,  0, 0,  2, 1,  1, 2,  2, 1,  1, 2,  2, 1,  1, 2
	0xa85454a8, // 0, 2,  2, 2,  0, 1,  1, 1,  0, 1,  1, 1,  0, 2,  2, 2
	0x80959580, // 0, 0,  0, 2,  1, 1,  1, 2,  1, 1,  1, 2,  0, 0,  0, 2
	0xaa141414, // 0, 1,  1, 0,  0, 1,  1, 0,  0, 1,  1, 0,  2, 2,  2, 2
	0x96960000, // 0, 0,  0, 0,  0, 0,  0, 0,  2, 1,  1, 2,  2, 1,  1, 2
	0xaaaa1414, // 0, 1,  1, 0,  0, 1,  1, 0,  2, 2,  2, 2,  2, 2,  2, 2
	0xa05050a0, // 0, 0,  2, 2,  0, 0,  1, 1,  0, 0,  1, 1,  0, 0,  2, 2
	0xa0a5a5a0, // 0, 0,  2, 2,  1, 1,  2, 2,  1, 1,  2, 2,  0, 0,  2, 2
	0x96000000, // 0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  0, 0,  2, 1,  1, 2
	0x40804080, // 0, 0,  0, 2,  0, 0,  0, 1,  0, 0,  0, 2,  0, 0,  0, 1
	0xa9a8a9a8, // 0, 2,  2, 2,  1, 2,  2, 2,  0, 2,  2, 2,  1, 2,  2, 2
	0xaaaaaa44, // 0, 1,  0, 1,  2, 2,  2, 2,  2, 2,  2, 2,  2, 2,  2, 2
	0x2a4a5254, // 0, 1,  1, 1,  2, 0,  1, 1,  2, 2,  0, 1,  2, 2,  2, 0
};

static const uint8_t s_bptcA3[2][64] =
{
	{
		 3,  3, 15, 15,  8,  3, 15, 15,
		 8,  8,  6,  6,  6,  5,  3,  3,
		 3,  3,  8, 15,  3,  3,  6, 10,
		 5,  8,  8,  6,  8,  5, 15, 15,
		 8, 15,  3,  5,  6, 10,  8, 15,
		15,  3, 15,  5, 15, 15, 15, 15,
		 3, 15,  5,  5,  5,  8,  5, 10,
		 5, 10,  8, 13, 15, 12,  3,  3,
	},
	{
		15,  8,  8,  3, 15, 15,  3,  8,
		15, 15, 15, 15, 15, 15, 15,  8,
		15,  8, 15,  3, 15,  8, 15,  8,
		 3, 15,  6, 10, 15, 15, 10,  8,
		15,  3, 15, 10, 10,  8,  9, 10,
		 6, 15,  8, 15,  3,  6,  6,  8,
		15,  3, 15, 15, 15, 15, 15, 15,
		15, 15, 15, 15,  3, 15, 15,  8,
	},
};

struct Bc7ModeInfo
{
	uint8_t numSubsets;
	uint8_t partitionBits;
	uint8_t rotationBits;
	uint8_t indexSelectionBits;
	uint8_t colorBits;
	uint8_t alphaBits;
	uint8_t endpointPBits;
	uint8_t sharedPBits;
	uint8_t indexBits[2];
};

static const Bc7ModeInfo s_bp7ModeInfo[] =
{ //  +---------------------------- num subsets
  //  |  +------------------------- partition bits
  //  |  |  +---------------------- rotation bits
  //  |  |  |  +------------------- index selection bits
  //  |  |  |  |  +---------------- color bits
  //  |  |  |  |  |  +------------- alpha bits
  //  |  |  |  |  |  |  +---------- endpoint P-bits
  //  |  |  |  |  |  |  |  +------- shared P-bits
  //  |  |  |  |  |  |  |  |    +-- 2x index bits
	{ 3, 4, 0, 0, 4, 0, 1, 0, { 3, 0 } }, // 0
	{ 2, 6, 0, 0, 6, 0, 0, 1, { 3, 0 } }, // 1
	{ 3, 6, 0, 0, 5, 0, 0, 0, { 2, 0 } }, // 2
	{ 2, 6, 0, 0, 7, 0, 1, 0, { 2, 0 } }, // 3
	{ 1, 0, 2, 1, 5, 6, 0, 0, { 2, 3 } }, // 4
	{ 1, 0, 2, 0, 7, 8, 0, 0, { 2, 2 } }, // 5
	{ 1, 0, 0, 0, 7, 7, 1, 0, { 4, 0 } }, // 6
	{ 2, 6, 0, 0, 5, 5, 1, 0, { 2, 0 } }, // 7
};

static uint8_t expand_quantized(uint8_t v, int bits) {
	v = v << (8 - bits);
	return v | (v >> bits);
}

static void decode_bc7_block(const uint8_t* _src, uint32_t* _dst)
{
	BitReader bit(_src);

	uint8_t mode = 0;
	for (; mode < 8 && 0 == bit.read(1); ++mode)
	{
	}

	if (mode == 8)
	{
		memset(_dst, 0, 16 * 4);
		return;
	}

	const Bc7ModeInfo& mi = s_bp7ModeInfo[mode];
	const uint8_t modePBits = 0 != mi.endpointPBits
		? mi.endpointPBits
		: mi.sharedPBits
		;

	const uint8_t partitionSetIdx = uint8_t(bit.read(mi.partitionBits));
	const uint8_t rotationMode = uint8_t(bit.read(mi.rotationBits));
	const uint8_t indexSelectionMode = uint8_t(bit.read(mi.indexSelectionBits));

	uint8_t epR[6];
	uint8_t epG[6];
	uint8_t epB[6];
	uint8_t epA[6];

	for (uint8_t ii = 0; ii < mi.numSubsets; ++ii)
	{
		epR[ii * 2 + 0] = uint8_t(bit.read(mi.colorBits) << modePBits);
		epR[ii * 2 + 1] = uint8_t(bit.read(mi.colorBits) << modePBits);
	}

	for (uint8_t ii = 0; ii < mi.numSubsets; ++ii)
	{
		epG[ii * 2 + 0] = uint8_t(bit.read(mi.colorBits) << modePBits);
		epG[ii * 2 + 1] = uint8_t(bit.read(mi.colorBits) << modePBits);
	}

	for (uint8_t ii = 0; ii < mi.numSubsets; ++ii)
	{
		epB[ii * 2 + 0] = uint8_t(bit.read(mi.colorBits) << modePBits);
		epB[ii * 2 + 1] = uint8_t(bit.read(mi.colorBits) << modePBits);
	}

	if (mi.alphaBits)
	{
		for (uint8_t ii = 0; ii < mi.numSubsets; ++ii)
		{
			epA[ii * 2 + 0] = uint8_t(bit.read(mi.alphaBits) << modePBits);
			epA[ii * 2 + 1] = uint8_t(bit.read(mi.alphaBits) << modePBits);
		}
	}
	else
	{
		memset(epA, 0xff, 6);
	}

	if (0 != modePBits)
	{
		for (uint8_t ii = 0; ii < mi.numSubsets; ++ii)
		{
			const uint8_t pda = uint8_t(bit.read(modePBits));
			const uint8_t pdb = uint8_t(0 == mi.sharedPBits ? bit.read(modePBits) : pda);

			epR[ii * 2 + 0] |= pda;
			epR[ii * 2 + 1] |= pdb;
			epG[ii * 2 + 0] |= pda;
			epG[ii * 2 + 1] |= pdb;
			epB[ii * 2 + 0] |= pda;
			epB[ii * 2 + 1] |= pdb;
			epA[ii * 2 + 0] |= pda;
			epA[ii * 2 + 1] |= pdb;
		}
	}

	const uint8_t colorBits = mi.colorBits + modePBits;

	for (uint8_t ii = 0; ii < mi.numSubsets; ++ii)
	{
		epR[ii * 2 + 0] = expand_quantized(epR[ii * 2 + 0], colorBits);
		epR[ii * 2 + 1] = expand_quantized(epR[ii * 2 + 1], colorBits);
		epG[ii * 2 + 0] = expand_quantized(epG[ii * 2 + 0], colorBits);
		epG[ii * 2 + 1] = expand_quantized(epG[ii * 2 + 1], colorBits);
		epB[ii * 2 + 0] = expand_quantized(epB[ii * 2 + 0], colorBits);
		epB[ii * 2 + 1] = expand_quantized(epB[ii * 2 + 1], colorBits);
	}

	if (mi.alphaBits)
	{
		const uint8_t alphaBits = mi.alphaBits + modePBits;

		for (uint8_t ii = 0; ii < mi.numSubsets; ++ii)
		{
			epA[ii * 2 + 0] = expand_quantized(epA[ii * 2 + 0], alphaBits);
			epA[ii * 2 + 1] = expand_quantized(epA[ii * 2 + 1], alphaBits);
		}
	}

	const bool hasIndexBits1 = 0 != mi.indexBits[1];

	const uint8_t* factors[] =
	{
						s_bptcFactors[mi.indexBits[0] - 2],
		hasIndexBits1 ? s_bptcFactors[mi.indexBits[1] - 2] : factors[0],
	};

	uint16_t offset[2] =
	{
		0,
		uint16_t(mi.numSubsets * (16 * mi.indexBits[0] - 1)),
	};

	for (uint8_t yy = 0; yy < 4; ++yy)
	{
		for (uint8_t xx = 0; xx < 4; ++xx)
		{
			const uint8_t idx = yy * 4 + xx;

			uint8_t subsetIndex = 0;
			uint8_t indexAnchor = 0;
			switch (mi.numSubsets)
			{
			case 2:
				subsetIndex = (s_bptcP2[partitionSetIdx] >> idx) & 1;
				indexAnchor = 0 != subsetIndex ? s_bptcA2[partitionSetIdx] : 0;
				break;

			case 3:
				subsetIndex = (s_bptcP3[partitionSetIdx] >> (2 * idx)) & 3;
				indexAnchor = 0 != subsetIndex ? s_bptcA3[subsetIndex - 1][partitionSetIdx] : 0;
				break;

			default:
				break;
			}

			const uint8_t anchor = idx == indexAnchor;
			const uint8_t num[2] =
			{
				uint8_t(mi.indexBits[0] - anchor),
				uint8_t(hasIndexBits1 ? mi.indexBits[1] - anchor : 0),
			};

			const uint8_t index[2] =
			{
								(uint8_t)bit.peek(offset[0], num[0]),
				hasIndexBits1 ? (uint8_t)bit.peek(offset[1], num[1]) : index[0],
			};

			offset[0] += num[0];
			offset[1] += num[1];

			const uint8_t fc = factors[indexSelectionMode][index[indexSelectionMode]];
			const uint8_t fa = factors[!indexSelectionMode][index[!indexSelectionMode]];

			const uint8_t fca = 64 - fc;
			const uint8_t fcb = fc;
			const uint8_t faa = 64 - fa;
			const uint8_t fab = fa;

			subsetIndex *= 2;
			uint8_t rr = uint8_t(uint16_t(epR[subsetIndex] * fca + epR[subsetIndex + 1] * fcb + 32) >> 6);
			uint8_t gg = uint8_t(uint16_t(epG[subsetIndex] * fca + epG[subsetIndex + 1] * fcb + 32) >> 6);
			uint8_t bb = uint8_t(uint16_t(epB[subsetIndex] * fca + epB[subsetIndex + 1] * fcb + 32) >> 6);
			uint8_t aa = uint8_t(uint16_t(epA[subsetIndex] * faa + epA[subsetIndex + 1] * fab + 32) >> 6);

			switch (rotationMode)
			{
			case 1: std::swap(aa, rr); break;
			case 2: std::swap(aa, gg); break;
			case 3: std::swap(aa, bb); break;
			default:                  break;
			};

			_dst[idx] = color(rr, gg, bb, aa);
		}
	}
}

int decode_bc7(const uint8_t* data, uint32_t m_width, uint32_t m_height, uint32_t* image) {
	uint32_t m_block_width = 4;
	uint32_t m_block_height = 4;
	uint32_t m_blocks_x = (m_width + m_block_width - 1) / m_block_width;
	uint32_t m_blocks_y = (m_height + m_block_height - 1) / m_block_height;
	uint32_t buffer[16];
	for (uint32_t by = 0; by < m_blocks_y; by++) {
		for (uint32_t bx = 0; bx < m_blocks_x; bx++, data += 16) {
			decode_bc7_block(data, buffer);
			copy_block_buffer(bx, by, m_width, m_height, m_block_width, m_block_height, buffer, image);
		}
	}
	return 1;
}
```

`Texture2DDecoderNative/bcn.h`:

```h
#pragma once
#include <stdint.h>

struct color_bgra
{
	uint8_t b;
	uint8_t g;
	uint8_t r;
	uint8_t a;
};

const color_bgra g_black_color{ 0, 0, 0, 255 };

int decode_bc1(const uint8_t* data, const long w, const long h, uint32_t* image);
void decode_bc3_alpha(const uint8_t* data, uint32_t* outbuf, int channel);
int decode_bc3(const uint8_t* data, const long w, const long h, uint32_t* image);
int decode_bc4(const uint8_t* data, uint32_t m_width, uint32_t m_height, uint32_t* image);
int decode_bc5(const uint8_t* data, uint32_t m_width, uint32_t m_height, uint32_t* image);
int decode_bc6(const uint8_t* data, uint32_t m_width, uint32_t m_height, uint32_t* image);
int decode_bc7(const uint8_t* data, uint32_t m_width, uint32_t m_height, uint32_t* image);
```

`Texture2DDecoderNative/bool32_t.h`:

```h
#pragma once

#include <cstdint>

typedef uint32_t bool32_t;

```

`Texture2DDecoderNative/color.h`:

```h
#ifndef COLOR_H
#define COLOR_H

#include <stdint.h>
#include <string.h>
#include "endianness.h"

#ifdef __LITTLE_ENDIAN__
static const uint_fast32_t TRANSPARENT_MASK = 0x00ffffff;
#else
static const uint_fast32_t TRANSPARENT_MASK = 0xffffff00;
#endif

static inline uint_fast32_t color(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
#ifdef __LITTLE_ENDIAN__
    return b | g << 8 | r << 16 | a << 24;
#else
    return a | r << 8 | g << 16 | b << 24;
#endif
}

static inline uint_fast32_t alpha_mask(uint8_t a) {
#ifdef __LITTLE_ENDIAN__
    return TRANSPARENT_MASK | a << 24;
#else
    return TRANSPARENT_MASK | a;
#endif
}

static inline void rgb565_le(const uint16_t d, uint8_t *r, uint8_t *g, uint8_t *b) {
#ifdef __LITTLE_ENDIAN__
    *r = (d >> 8 & 0xf8) | (d >> 13);
    *g = (d >> 3 & 0xfc) | (d >> 9 & 3);
    *b = (d << 3) | (d >> 2 & 7);
#else
    *r = (d & 0xf8) | (d >> 5 & 7);
    *g = (d << 5 & 0xe0) | (d >> 11 & 0x1c) | (d >> 1 & 3);
    *b = (d >> 5 & 0xf8) | (d >> 10 & 0x7);
#endif
}

static inline void rgb565_be(const uint16_t d, uint8_t *r, uint8_t *g, uint8_t *b) {
#ifdef __BIG_ENDIAN__
    *r = (d >> 8 & 0xf8) | (d >> 13);
    *g = (d >> 3 & 0xfc) | (d >> 9 & 3);
    *b = (d << 3) | (d >> 2 & 7);
#else
    *r = (d & 0xf8) | (d >> 5 & 7);
    *g = (d << 5 & 0xe0) | (d >> 11 & 0x1c) | (d >> 1 & 3);
    *b = (d >> 5 & 0xf8) | (d >> 10 & 0x7);
#endif
}

static inline void rgb565_lep(const uint16_t d, uint8_t *c) {
#ifdef __LITTLE_ENDIAN__
    *(c++) = (d >> 8 & 0xf8) | (d >> 13);
    *(c++) = (d >> 3 & 0xfc) | (d >> 9 & 3);
    *(c++) = (d << 3) | (d >> 2 & 7);
#else
    *(c++) = (d & 0xf8) | (d >> 5 & 7);
    *(c++) = (d << 5 & 0xe0) | (d >> 11 & 0x1c) | (d >> 1 & 3);
    *(c++) = (d >> 5 & 0xf8) | (d >> 10 & 0x7);
#endif
}

static inline void rgb565_bep(const uint16_t d, uint8_t *c) {
#ifdef __BIG_ENDIAN__
    *(c++) = (d >> 8 & 0xf8) | (d >> 13);
    *(c++) = (d >> 3 & 0xfc) | (d >> 9 & 3);
    *(c++) = (d << 3) | (d >> 2 & 7);
#else
    *(c++) = (d & 0xf8) | (d >> 5 & 7);
    *(c++) = (d << 5 & 0xe0) | (d >> 11 & 0x1c) | (d >> 1 & 3);
    *(c++) = (d >> 5 & 0xf8) | (d >> 10 & 0x7);
#endif
}

static inline void copy_block_buffer(const long bx, const long by, const long w, const long h, const long bw,
                                     const long bh, const uint32_t *buffer, uint32_t *image) {
    long x = bw * bx;
    long xl = (bw * (bx + 1) > w ? w - bw * bx : bw) * 4;
    const uint32_t *buffer_end = buffer + bw * bh;
    for (long y = by * bh; buffer < buffer_end && y < h; buffer += bw, y++)
        memcpy(image + y * w + x, buffer, xl);
}

#endif /* end of include guard: COLOR_H */

```

`Texture2DDecoderNative/cpp.hint`:

```hint
#define T2D_API(ret_type)

```

`Texture2DDecoderNative/crunch.cpp`:

```cpp
#include "crunch.h"
#include <stdint.h>
#include <algorithm>
#include "crunch/crn_decomp.h"

bool crunch_unpack_level(const uint8_t* data, uint32_t data_size, uint32_t level_index, void** ret, uint32_t* ret_size) {
	crnd::crn_texture_info tex_info;
	if (!crnd::crnd_get_texture_info(data, data_size, &tex_info))
	{
		return false;
	}

	crnd::crnd_unpack_context pContext = crnd::crnd_unpack_begin(data, data_size);
	if (!pContext)
	{
		return false;
	}

	const crn_uint32 width = std::max(1U, tex_info.m_width >> level_index);
	const crn_uint32 height = std::max(1U, tex_info.m_height >> level_index);
	const crn_uint32 blocks_x = std::max(1U, (width + 3) >> 2);
	const crn_uint32 blocks_y = std::max(1U, (height + 3) >> 2);
	const crn_uint32 row_pitch = blocks_x * crnd::crnd_get_bytes_per_dxt_block(tex_info.m_format);
	const crn_uint32 total_face_size = row_pitch * blocks_y;
	*ret = new uint8_t[total_face_size];
	*ret_size = total_face_size;
	if (!crnd::crnd_unpack_level(pContext, ret, total_face_size, row_pitch, level_index))
	{
		crnd::crnd_unpack_end(pContext);
		return false;
	}
	crnd::crnd_unpack_end(pContext);
	return true;
}
```

`Texture2DDecoderNative/crunch.h`:

```h
#pragma once

#include <stdint.h>

bool crunch_unpack_level(const uint8_t* data, uint32_t data_size, uint32_t level_index, void** ret, uint32_t* ret_size);
```

`Texture2DDecoderNative/crunch/crn_decomp.h`:

```h
// File: crn_decomp.h - Fast CRN->DXTc texture transcoder header file library
// Copyright (c) 2010-2016 Richard Geldreich, Jr. All rights reserved.
// See Copyright Notice and license at the end of this file.
//
// This single header file contains *all* of the code necessary to unpack .CRN files to raw DXTn bits.
// It does NOT depend on the crn compression library.
//
// Note: This is a single file, stand-alone C++ library which is controlled by the use of two macros:
//   If CRND_INCLUDE_CRND_H is NOT defined, the header is included.
//   If CRND_HEADER_FILE_ONLY is NOT defined, the implementation is included.
//
// Important: If compiling with gcc, be sure strict aliasing is disabled: -fno-strict-aliasing
#ifndef CRND_INCLUDE_CRND_H
#define CRND_INCLUDE_CRND_H

// Include crnlib.h (only to bring in some basic CRN-related types).
#include "crnlib.h"

#define CRND_LIB_VERSION 104
#define CRND_VERSION_STRING "01.04"

#ifdef _DEBUG
#define CRND_BUILD_DEBUG
#else
#define CRND_BUILD_RELEASE
#endif

// CRN decompression API
namespace crnd
{
   typedef unsigned char      uint8;
   typedef signed char        int8;
   typedef unsigned short     uint16;
   typedef signed short       int16;
   typedef unsigned int       uint32;
   typedef uint32             uint32;
   typedef unsigned int       uint;
   typedef signed int         int32;
   #ifdef __GNUC__
      typedef unsigned long long    uint64;
      typedef long long             int64;
   #else
      typedef unsigned __int64      uint64;
      typedef signed __int64        int64;
   #endif

   // The crnd library assumes all allocation blocks have at least CRND_MIN_ALLOC_ALIGNMENT alignment.
   const uint32 CRND_MIN_ALLOC_ALIGNMENT = sizeof(uint32) * 2U;

   // realloc callback:
   // Used to allocate, resize, or free memory blocks.
   // If p is NULL, the realloc function attempts to allocate a block of at least size bytes. Returns NULL on out of memory.
   // *pActual_size must be set to the actual size of the allocated block, which must be greater than or equal to the requested size.
   // If p is not NULL, and size is 0, the realloc function frees the specified block, and always returns NULL. *pActual_size should be set to 0.
   // If p is not NULL, and size is non-zero, the realloc function attempts to resize the specified block:
   //    If movable is false, the realloc function attempts to shrink or expand the block in-place. NULL is returned if the block cannot be resized in place, or if the
   //    underlying heap implementation doesn't support in-place resizing. Otherwise, the pointer to the original block is returned.
   //    If movable is true, it is permissible to move the block's contents if it cannot be resized in place. NULL is returned if the block cannot be resized in place, and there
   //    is not enough memory to relocate the block.
   //    In all cases, *pActual_size must be set to the actual size of the allocated block, whether it was successfully resized or not.
   typedef void*  (*crnd_realloc_func)(void* p, size_t size, size_t* pActual_size, bool movable, void* pUser_data);

   // msize callback: Returns the size of the memory block in bytes, or 0 if the pointer or block is invalid.
   typedef size_t (*crnd_msize_func)(void* p, void* pUser_data);

   // crnd_set_memory_callbacks() - Use to override the crnd library's memory allocation functions.
   // If any input parameters are NULL, the memory callback functions are reset to the default functions.
   // The default functions call malloc(), free(),  _msize(), _expand(), etc.
   void crnd_set_memory_callbacks(crnd_realloc_func pRealloc, crnd_msize_func pMSize, void* pUser_data);

   struct crn_file_info
   {
      inline crn_file_info() : m_struct_size(sizeof(crn_file_info)) { }

      uint32 m_struct_size;
      uint32 m_actual_data_size;
      uint32 m_header_size;
      uint32 m_total_palette_size;
      uint32 m_tables_size;
      uint32 m_levels;
      uint32 m_level_compressed_size[cCRNMaxLevels];
      uint32 m_color_endpoint_palette_entries;
      uint32 m_color_selector_palette_entries;
      uint32 m_alpha_endpoint_palette_entries;
      uint32 m_alpha_selector_palette_entries;
   };

   struct crn_texture_info
   {
      inline crn_texture_info() : m_struct_size(sizeof(crn_texture_info)) { }

      uint32      m_struct_size;
      uint32      m_width;
      uint32      m_height;
      uint32      m_levels;
      uint32      m_faces;
      uint32      m_bytes_per_block;
      uint32      m_userdata0;
      uint32      m_userdata1;
      crn_format  m_format;
   };

   struct crn_level_info
   {
      inline crn_level_info() : m_struct_size(sizeof(crn_level_info)) { }

      uint32      m_struct_size;
      uint32      m_width;
      uint32      m_height;
      uint32      m_faces;
      uint32      m_blocks_x;
      uint32      m_blocks_y;
      uint32      m_bytes_per_block;
      crn_format  m_format;
   };

   // Returns the FOURCC format code corresponding to the specified CRN format.
   uint32 crnd_crn_format_to_fourcc(crn_format fmt);

   // Returns the fundamental GPU format given a potentially swizzled DXT5 crn_format.
   crn_format crnd_get_fundamental_dxt_format(crn_format fmt);

   // Returns the size of the crn_format in bits/texel (either 4 or 8).
   uint32 crnd_get_crn_format_bits_per_texel(crn_format fmt);

   // Returns the number of bytes per DXTn block (8 or 16).
   uint32 crnd_get_bytes_per_dxt_block(crn_format fmt);

   // Validates the entire file by checking the header and data CRC's.
   // This is not something you want to be doing much!
   // The crn_file_info.m_struct_size field must be set before calling this function.
   bool crnd_validate_file(const void* pData, uint32 data_size, crn_file_info* pFile_info);

   // Retrieves texture information from the CRN file.
   // The crn_texture_info.m_struct_size field must be set before calling this function.
   bool crnd_get_texture_info(const void* pData, uint32 data_size, crn_texture_info* pTexture_info);

   // Retrieves mipmap level specific information from the CRN file.
   // The crn_level_info.m_struct_size field must be set before calling this function.
   bool crnd_get_level_info(const void* pData, uint32 data_size, uint32 level_index, crn_level_info* pLevel_info);

   // Transcode/unpack context handle.
   typedef void* crnd_unpack_context;

   // crnd_unpack_begin() - Decompresses the texture's decoder tables and endpoint/selector palettes.
   // Once you call this function, you may call crnd_unpack_level() to unpack one or more mip levels.
   // Don't call this once per mip level (unless you absolutely must)!
   // This function allocates enough memory to hold: Huffman decompression tables, and the endpoint/selector palettes (color and/or alpha).
   // Worst case allocation is approx. 200k, assuming all palettes contain 8192 entries.
   // pData must point to a buffer holding all of the compressed .CRN file data.
   // This buffer must be stable until crnd_unpack_end() is called.
   // Returns NULL if out of memory, or if any of the input parameters are invalid.
   crnd_unpack_context crnd_unpack_begin(const void* pData, uint32 data_size);

   // Returns a pointer to the compressed .CRN data associated with a crnd_unpack_context.
   // Returns false if any of the input parameters are invalid.
   bool crnd_get_data(crnd_unpack_context pContext, const void** ppData, uint32* pData_size);

   // crnd_unpack_level() - Transcodes the specified mipmap level to a destination buffer in cached or write combined memory.
   // pContext - Context created by a call to crnd_unpack_begin().
   // ppDst - A pointer to an array of 1 or 6 destination buffer pointers. Cubemaps require an array of 6 pointers, 2D textures require an array of 1 pointer.
   // dst_size_in_bytes - Optional size of each destination buffer. Only used for debugging - OK to set to UINT32_MAX.
   // row_pitch_in_bytes - The pitch in bytes from one row of DXT blocks to the next. Must be a multiple of 4.
   // level_index - mipmap level index, where 0 is the largest/first level.
   // Returns false if any of the input parameters, or the compressed stream, are invalid.
   // This function does not allocate any memory.
   bool crnd_unpack_level(
      crnd_unpack_context pContext,
      void** ppDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
      uint32 level_index);

   // crnd_unpack_level_segmented() - Unpacks the specified mipmap level from a "segmented" CRN file.
   // See the crnd_create_segmented_file() API below.
   // Segmented files allow the user to control where the compressed mipmap data is stored.
   bool crnd_unpack_level_segmented(
      crnd_unpack_context pContext,
      const void* pSrc, uint32 src_size_in_bytes,
      void** ppDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
      uint32 level_index);

   // crnd_unpack_end() - Frees the decompress tables and unpacked palettes associated with the specified unpack context.
   // Returns false if the context is NULL, or if it points to an invalid context.
   // This function frees all memory associated with the context.
   bool crnd_unpack_end(crnd_unpack_context pContext);

   // The following API's allow the user to create "segmented" CRN files. A segmented file contains multiple pieces:
   // - Base data: Header + compression tables
   // - Level data: Individual mipmap levels
   // This allows mipmap levels from multiple CRN files to be tightly packed together into single files.

   // Returns a pointer to the level's compressed data, and optionally returns the level's compressed data size if pSize is not NULL.
   const void* crnd_get_level_data(const void* pData, uint32 data_size, uint32 level_index, uint32* pSize);

   // Returns the compressed size of the texture's header and compression tables (but no levels).
   uint32 crnd_get_segmented_file_size(const void* pData, uint32 data_size);

   // Creates a "segmented" CRN texture from a normal CRN texture. The new texture will be created at pBase_data, and will be crnd_get_base_data_size() bytes long.
   // base_data_size must be >= crnd_get_base_data_size().
   // The base data will contain the CRN header and compression tables, but no mipmap data.
   bool crnd_create_segmented_file(const void* pData, uint32 data_size, void* pBase_data, uint base_data_size);

} // namespace crnd

// Low-level CRN file header cracking.
namespace crnd
{
   template<unsigned int N>
   struct crn_packed_uint
   {
      inline crn_packed_uint() { }

      inline crn_packed_uint(unsigned int val) { *this = val; }

      inline crn_packed_uint(const crn_packed_uint& other) { *this = other; }

      inline crn_packed_uint& operator= (const crn_packed_uint& rhs)
      {
         if (this != &rhs)
            memcpy(m_buf, rhs.m_buf, sizeof(m_buf));
         return *this;
      }

      inline crn_packed_uint& operator= (unsigned int val)
      {
         //CRND_ASSERT((N == 4U) || (val < (1U << (N * 8U))));

         val <<= (8U * (4U - N));

         for (unsigned int i = 0; i < N; i++)
         {
            m_buf[i] = static_cast<unsigned char>(val >> 24U);
            val <<= 8U;
         }

         return *this;
      }

      inline operator unsigned int() const
      {
         switch (N)
         {
         case 1:  return  m_buf[0];
         case 2:  return (m_buf[0] <<  8U) |  m_buf[1];
         case 3:  return (m_buf[0] << 16U) | (m_buf[1] <<  8U) | (m_buf[2]);
         default: return (m_buf[0] << 24U) | (m_buf[1] << 16U) | (m_buf[2] << 8U) | (m_buf[3]);
         }
      }

      unsigned char m_buf[N];
   };

#pragma pack(push)
#pragma pack(1)
   struct crn_palette
   {
      crn_packed_uint<3> m_ofs;
      crn_packed_uint<3> m_size;
      crn_packed_uint<2> m_num;
   };

   enum crn_header_flags
   {
      // If set, the compressed mipmap level data is not located after the file's base data - it will be separately managed by the user instead.
      cCRNHeaderFlagSegmented = 1
   };

   struct crn_header
   {
      enum { cCRNSigValue = ('H' << 8) | 'x' };

      crn_packed_uint<2>    m_sig;
      crn_packed_uint<2>    m_header_size;
      crn_packed_uint<2>    m_header_crc16;

      crn_packed_uint<4>    m_data_size;
      crn_packed_uint<2>    m_data_crc16;

      crn_packed_uint<2>    m_width;
      crn_packed_uint<2>    m_height;

      crn_packed_uint<1>    m_levels;
      crn_packed_uint<1>    m_faces;

      crn_packed_uint<1>    m_format;
      crn_packed_uint<2>    m_flags;

      crn_packed_uint<4>    m_reserved;
      crn_packed_uint<4>    m_userdata0;
      crn_packed_uint<4>    m_userdata1;

      crn_palette           m_color_endpoints;
      crn_palette           m_color_selectors;

      crn_palette           m_alpha_endpoints;
      crn_palette           m_alpha_selectors;

      crn_packed_uint<2>    m_tables_size;
      crn_packed_uint<3>    m_tables_ofs;

      // m_level_ofs[] is actually an array of offsets: m_level_ofs[m_levels]
      crn_packed_uint<4>    m_level_ofs[1];
   };

   const unsigned int cCRNHeaderMinSize = 62U;

#pragma pack(pop)

} // namespace crnd

#endif // CRND_INCLUDE_CRND_H

// Internal library source follows this line.

#ifndef CRND_HEADER_FILE_ONLY

#include <stdlib.h>
#include <stdio.h>
#ifdef _WIN32
#include <memory.h>
#else
#include <malloc.h>
#endif
#include <stdarg.h>
#include <new> // needed for placement new, _msize, _expand

#define CRND_RESTRICT __restrict

#ifdef _MSC_VER
#include <intrin.h>
#pragma intrinsic(_WriteBarrier)
#pragma intrinsic(_ReadWriteBarrier)
#define CRND_WRITE_BARRIER _WriteBarrier();
#define CRND_FULL_BARRIER _ReadWriteBarrier();
#else
#define CRND_WRITE_BARRIER
#define CRND_FULL_BARRIER
#endif

#ifdef _MSC_VER
#pragma warning(disable:4127) // warning C4127: conditional expression is constant
#endif

#ifdef CRND_DEVEL
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x500
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef
#define NOMINMAX
#endif
#include "windows.h" // only for IsDebuggerPresent(), DebugBreak(), and OutputDebugStringA()
#endif

// File: crnd_types.h
namespace crnd
{
   const crn_uint8 cUINT8_MIN  = 0;
   const crn_uint8 cUINT8_MAX  = 0xFFU;
   const uint16 cUINT16_MIN = 0;
   const uint16 cUINT16_MAX = 0xFFFFU;
   const uint32 cUINT32_MIN = 0;
   const uint32 cUINT32_MAX = 0xFFFFFFFFU;

   const int8  cINT8_MIN  = -128;
   const int8  cINT8_MAX  = 127;
   const int16 cINT16_MIN = -32768;
   const int16 cINT16_MAX = 32767;
   const int32 cINT32_MIN = (-2147483647 - 1);
   const int32 cINT32_MAX = 2147483647;

   enum eClear { cClear };

   const uint32 cIntBits = 32U;

#ifdef _WIN64
   typedef uint64 ptr_bits;
#else
   #ifdef __x86_64__
      typedef uint64 ptr_bits;
   #else
      typedef uint32 ptr_bits;
   #endif
#endif

   template<typename T> struct int_traits { enum { cMin = crnd::cINT32_MIN, cMax = crnd::cINT32_MAX, cSigned = true }; };

   template<> struct int_traits<int8> { enum { cMin = crnd::cINT8_MIN, cMax = crnd::cINT8_MAX, cSigned = true }; };
   template<> struct int_traits<int16> { enum { cMin = crnd::cINT16_MIN, cMax = crnd::cINT16_MAX, cSigned = true }; };
   template<> struct int_traits<int32> { enum { cMin = crnd::cINT32_MIN, cMax = crnd::cINT32_MAX, cSigned = true }; };

   template<> struct int_traits<uint8> { enum { cMin = 0, cMax = crnd::cUINT8_MAX, cSigned = false }; };
   template<> struct int_traits<uint16> { enum { cMin = 0, cMax = crnd::cUINT16_MAX, cSigned = false }; };
   template<> struct int_traits<uint32> { enum { cMin = 0, cMax = crnd::cUINT32_MAX, cSigned = false }; };

   struct empty_type { };

} // namespace crnd

// File: crnd_platform.h
namespace crnd
{
#ifdef _XBOX
   const bool c_crnd_little_endian_platform = false;
   const bool c_crnd_big_endian_platform = true;
#define CRND_BIG_ENDIAN_PLATFORM 1
#else
   const bool c_crnd_little_endian_platform = true;
   const bool c_crnd_big_endian_platform = false;
#endif

   bool crnd_is_debugger_present();
   void crnd_debug_break();
   void crnd_output_debug_string(const char* p);

   // actually in crnd_assert.cpp
   void crnd_assert(const char* pExp, const char* pFile, unsigned line);
   void crnd_fail(const char* pExp, const char* pFile, unsigned line);

} // namespace crnd

// File: crnd_assert.h
namespace crnd
{
   void crnd_assert(const char* pExp, const char* pFile, unsigned line);

#ifdef NDEBUG
#define CRND_ASSERT(x) ((void)0)
#undef  CRND_ASSERTS_ENABLED
#else
#define CRND_ASSERT(_exp) (void)( (!!(_exp)) || (crnd::crnd_assert(#_exp, __FILE__, __LINE__), 0) )
#define CRND_ASSERTS_ENABLED
#endif

   void crnd_trace(const char* pFmt, va_list args);
   void crnd_trace(const char* pFmt, ...);

} // namespace crnd

// File: crnd_helpers.h
namespace crnd
{
   namespace helpers
   {
      template<typename T> struct rel_ops
      {
         friend bool operator!= (const T& x, const T& y) { return (!(x == y)); }
         friend bool operator>  (const T& x, const T& y) { return (y < x); }
         friend bool operator<= (const T& x, const T& y) { return (!(y < x)); }
         friend bool operator>= (const T& x, const T& y) { return (!(x < y)); }
      };

      template <typename T>
      inline T* construct(T* p)
      {
         return new (static_cast<void*>(p)) T;
      }

      template <typename T, typename U>
      inline T* construct(T* p, const U& init)
      {
         return new (static_cast<void*>(p)) T(init);
      }

      template <typename T>
      void construct_array(T* p, uint32 n)
      {
         T* q = p + n;
         for ( ; p != q; ++p)
            new (static_cast<void*>(p)) T;
      }

      template <typename T, typename U>
      void construct_array(T* p, uint32 n, const U& init)
      {
         T* q = p + n;
         for ( ; p != q; ++p)
            new (static_cast<void*>(p)) T(init);
      }

      template <typename T>
      inline void destruct(T* p)
      {
         p;
         p->~T();
      }

      template <typename T> inline void destruct_array(T* p, uint32 n)
      {
         T* q = p + n;
         for ( ; p != q; ++p)
            p->~T();
      }

   }  // namespace helpers

}  // namespace crnd

// File: crnd_traits.h
namespace crnd
{
   template<typename T>
   struct scalar_type
   {
      enum { cFlag = false };
      static inline void construct(T* p) { helpers::construct(p); }
      static inline void construct(T* p, const T& init) { helpers::construct(p, init); }
      static inline void construct_array(T* p, uint32 n) { helpers::construct_array(p, n); }
      static inline void destruct(T* p) { helpers::destruct(p); }
      static inline void destruct_array(T* p, uint32 n) { helpers::destruct_array(p, n); }
   };

   template<typename T> struct scalar_type<T*>
   {
      enum { cFlag = true };
      static inline void construct(T** p) { memset(p, 0, sizeof(T*)); }
      static inline void construct(T** p, T* init) { *p = init; }
      static inline void construct_array(T** p, uint32 n) { memset(p, 0, sizeof(T*) * n); }
      static inline void destruct(T** p) { p; }
      static inline void destruct_array(T** p, uint32 n) { p, n; }
   };

#define CRND_DEFINE_BUILT_IN_TYPE(X) \
   template<> struct scalar_type<X> { \
   enum { cFlag = true }; \
   static inline void construct(X* p) { memset(p, 0, sizeof(X)); } \
   static inline void construct(X* p, const X& init) { memcpy(p, &init, sizeof(X)); } \
   static inline void construct_array(X* p, uint32 n) { memset(p, 0, sizeof(X) * n); } \
   static inline void destruct(X* p) { p; } \
   static inline void destruct_array(X* p, uint32 n) { p, n; } };

   CRND_DEFINE_BUILT_IN_TYPE(bool)
   CRND_DEFINE_BUILT_IN_TYPE(char)
   CRND_DEFINE_BUILT_IN_TYPE(unsigned char)
   CRND_DEFINE_BUILT_IN_TYPE(short)
   CRND_DEFINE_BUILT_IN_TYPE(unsigned short)
   CRND_DEFINE_BUILT_IN_TYPE(int)
   CRND_DEFINE_BUILT_IN_TYPE(unsigned int)
   CRND_DEFINE_BUILT_IN_TYPE(long)
   CRND_DEFINE_BUILT_IN_TYPE(unsigned long)
   CRND_DEFINE_BUILT_IN_TYPE(int64)
   CRND_DEFINE_BUILT_IN_TYPE(uint64)
   CRND_DEFINE_BUILT_IN_TYPE(float)
   CRND_DEFINE_BUILT_IN_TYPE(double)
   CRND_DEFINE_BUILT_IN_TYPE(long double)

#undef CRND_DEFINE_BUILT_IN_TYPE

   // See: http://erdani.org/publications/cuj-2004-06.pdf

   template<typename T>
   struct bitwise_movable { enum { cFlag = false }; };

   // Defines type Q as bitwise movable.
#define CRND_DEFINE_BITWISE_MOVABLE(Q) template<> struct bitwise_movable<Q> { enum { cFlag = true }; };

   // From yasli_traits.h:
   // Credit goes to Boost;
   // also found in the C++ Templates book by Vandevoorde and Josuttis

   typedef char (&yes_t)[1];
   typedef char (&no_t)[2];

   template <class U> yes_t class_test(int U::*);
   template <class U> no_t class_test(...);

   template <class T> struct is_class
   {
      enum { value = (sizeof(class_test<T>(0)) == sizeof(yes_t)) };
   };

   template <typename T> struct is_pointer
   {
      enum { value = false };
   };

   template <typename T> struct is_pointer<T*>
   {
      enum { value = true };
   };

#define CRND_IS_POD(T) __is_pod(T)

} // namespace crnd

// File: crnd_mem.h
namespace crnd
{
   void*    crnd_malloc(size_t size, size_t* pActual_size = NULL);
   void*    crnd_realloc(void* p, size_t size, size_t* pActual_size = NULL, bool movable = true);
   void     crnd_free(void* p);
   size_t   crnd_msize(void* p);

   template<typename T>
   inline T* crnd_new()
   {
      T* p = static_cast<T*>(crnd_malloc(sizeof(T)));
      if (!p)
         return NULL;

      return helpers::construct(p);
   }

   template<typename T>
   inline T* crnd_new(const T& init)
   {
      T* p = static_cast<T*>(crnd_malloc(sizeof(T)));
      if (!p)
         return NULL;

      return helpers::construct(p, init);
   }

   template<typename T>
   inline T* crnd_new_array(uint32 num)
   {
      if (!num) num = 1;

      uint8* q = static_cast<uint8*>(crnd_malloc(CRND_MIN_ALLOC_ALIGNMENT + sizeof(T) * num));
      if (!q)
         return NULL;

      T* p = reinterpret_cast<T*>(q + CRND_MIN_ALLOC_ALIGNMENT);

      reinterpret_cast<uint32*>(p)[-1] = num;
      reinterpret_cast<uint32*>(p)[-2] = ~num;

      helpers::construct_array(p, num);
      return p;
   }

   template<typename T>
   inline void crnd_delete(T* p)
   {
      if (p)
      {
         helpers::destruct(p);
         crnd_free(p);
      }
   }

   template<typename T>
   inline void crnd_delete_array(T* p)
   {
      if (p)
      {
         const uint32 num = reinterpret_cast<uint32*>(p)[-1];
         const uint32 num_check = reinterpret_cast<uint32*>(p)[-2];
         num_check;
         CRND_ASSERT(num && (num == ~num_check));

         helpers::destruct_array(p, num);

         crnd_free(reinterpret_cast<uint8*>(p) - CRND_MIN_ALLOC_ALIGNMENT);
      }
   }

} // namespace crnd

// File: crnd_math.h
namespace crnd
{
   namespace math
   {
      const float cNearlyInfinite = 1.0e+37f;

      const float cDegToRad = 0.01745329252f;
      const float cRadToDeg = 57.29577951f;

      extern uint32 g_bitmasks[32];

      // Yes I know these should probably be pass by ref, not val:
      // http://www.stepanovpapers.com/notes.pdf
      // Just don't use them on non-simple (non built-in) types!
      template<typename T> inline T minimum(T a, T b)
      {
         return (a < b) ? a : b;
      }

      template<typename T> inline T minimum(T a, T b, T c)
      {
         return minimum(minimum(a, b), c);
      }

      template<typename T> inline T maximum(T a, T b)
      {
         return (a > b) ? a : b;
      }

      template<typename T> inline T maximum(T a, T b, T c)
      {
         return maximum(maximum(a, b), c);
      }

      template<typename T> inline T clamp(T value, T low, T high)
      {
         return (value < low) ? low : ((value > high) ? high : value);
      }

      template<typename T> inline T square(T value)
      {
         return value * value;
      }

      inline bool is_power_of_2(uint32 x)
      {
         return x && ((x & (x - 1U)) == 0U);
      }

      // From "Hackers Delight"
      inline int next_pow2(uint32 val)
      {
         val--;
         val |= val >> 16;
         val |= val >> 8;
         val |= val >> 4;
         val |= val >> 2;
         val |= val >> 1;
         return val + 1;
      }

      // Returns the total number of bits needed to encode v.
      inline uint32 total_bits(uint32 v)
      {
         uint32 l = 0;
         while (v > 0U)
         {
            v >>= 1;
            l++;
         }
         return l;
      }

      inline uint floor_log2i(uint v)
      {
         uint l = 0;
         while (v > 1U)
         {
            v >>= 1;
            l++;
         }
         return l;
      }

      inline uint ceil_log2i(uint v)
      {
         uint l = floor_log2i(v);
         if ((l != cIntBits) && (v > (1U << l)))
            l++;
         return l;
      }
   }
}

// File: crnd_utils.h
namespace crnd
{
   namespace utils
   {
      template<typename T> inline void zero_object(T& obj)
      {
         memset(&obj, 0, sizeof(obj));
      }

      template<typename T> inline void zero_this(T* pObj)
      {
         memset(pObj, 0, sizeof(*pObj));
      }

      template <typename T>
      inline void swap(T& left, T& right)
      {
         T temp(left);
         left = right;
         right = temp;
      }

      inline void invert_buf(void* pBuf, uint32 size)
      {
         uint8* p = static_cast<uint8*>(pBuf);

         const uint32 half_size = size >> 1;
         for (uint32 i = 0; i < half_size; i++)
            swap(p[i], p[size - 1U - i]);
      }

      static inline uint16 swap16(uint16 x) { return static_cast<uint16>((x << 8) | (x >> 8)); }
      static inline uint32 swap32(uint32 x) { return ((x << 24) | ((x << 8) & 0x00FF0000) | (( x >> 8) & 0x0000FF00) | (x >> 24)); }

      uint32 compute_max_mips(uint32 width, uint32 height);

   }   // namespace utils

} // namespace crnd

// File: crnd_vector.h
namespace crnd
{
   struct elemental_vector
   {
      void* m_p;
      uint32 m_size;
      uint32 m_capacity;

      typedef void (*object_mover)(void* pDst, void* pSrc, uint32 num);

      bool increase_capacity(uint32 min_new_capacity, bool grow_hint, uint32 element_size, object_mover pRelocate);
   };

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4127) //  warning C4127: conditional expression is constant
#endif

   template<typename T>
   class vector : public helpers::rel_ops< vector<T> >
   {
   public:
      typedef T*              iterator;
      typedef const T*        const_iterator;
      typedef T               value_type;
      typedef T&              reference;
      typedef const T&        const_reference;
      typedef T*              pointer;
      typedef const T*        const_pointer;

      inline vector() :
         m_p(NULL),
         m_size(0),
         m_capacity(0),
         m_alloc_failed(false)
      {
      }

      inline vector(const vector& other) :
         m_p(NULL),
         m_size(0),
         m_capacity(0),
         m_alloc_failed(false)
      {
         *this = other;
      }

      inline vector(uint32 size) :
         m_p(NULL),
         m_size(0),
         m_capacity(0),
         m_alloc_failed(false)
      {
         resize(size);
      }

      inline ~vector()
      {
         clear();
      }

      // I don't like this. Not at all. But exceptions, or just failing suck worse.
      inline bool get_alloc_failed() const { return m_alloc_failed; }
      inline void clear_alloc_failed() { m_alloc_failed = false; }

      inline bool assign(const vector& other)
      {
         if (this == &other)
            return true;

         if (m_capacity == other.m_size)
            resize(0);
         else
         {
            clear();

            if (!increase_capacity(other.m_size, false))
               return false;
         }

         if (scalar_type<T>::cFlag)
            memcpy(m_p, other.m_p, other.m_size * sizeof(T));
         else
         {
            T* pDst = m_p;
            const T* pSrc = other.m_p;
            for (uint32 i = other.m_size; i > 0; i--)
               helpers::construct(pDst++, *pSrc++);
         }

         m_size = other.m_size;

         return true;
      }

      inline vector& operator= (const vector& other)
      {
         assign(other);
         return *this;
      }

      inline const   T* begin() const  { return m_p; }
      T* begin()        { return m_p; }

      inline const   T* end() const  { return m_p + m_size; }
      T* end()        { return m_p + m_size; }

      inline bool empty() const { return !m_size; }
      inline uint32 size() const { return m_size; }
      inline uint32 capacity() const { return m_capacity; }

      inline const T& operator[] (uint32 i) const  { CRND_ASSERT(i < m_size); return m_p[i]; }
      inline       T& operator[] (uint32 i)        { CRND_ASSERT(i < m_size); return m_p[i]; }

      inline const T& front() const  { CRND_ASSERT(m_size); return m_p[0]; }
      inline       T& front()        { CRND_ASSERT(m_size); return m_p[0]; }

      inline const T& back() const  { CRND_ASSERT(m_size); return m_p[m_size - 1]; }
      inline       T& back()        { CRND_ASSERT(m_size); return m_p[m_size - 1]; }

      inline void clear()
      {
         if (m_p)
         {
            scalar_type<T>::destruct_array(m_p, m_size);
            crnd_free(m_p);
            m_p = NULL;
            m_size = 0;
            m_capacity = 0;
         }

         m_alloc_failed = false;
      }

      inline bool reserve(uint32 new_capacity)
      {
         if (!increase_capacity(new_capacity, false))
            return false;

         return true;
      }

      inline bool resize(uint32 new_size)
      {
         if (m_size != new_size)
         {
            if (new_size < m_size)
               scalar_type<T>::destruct_array(m_p + new_size, m_size - new_size);
            else
            {
               if (new_size > m_capacity)
               {
                  if (!increase_capacity(new_size, new_size == (m_size + 1)))
                     return false;
               }

               scalar_type<T>::construct_array(m_p + m_size, new_size - m_size);
            }

            m_size = new_size;
         }

         return true;
      }

      inline bool push_back(const T& obj)
      {
         CRND_ASSERT(!m_p || (&obj < m_p) || (&obj >= (m_p + m_size)));

         if (m_size >= m_capacity)
         {
            if (!increase_capacity(m_size + 1, true))
               return false;
         }

         scalar_type<T>::construct(m_p + m_size, obj);
         m_size++;

         return true;
      }

      inline void pop_back()
      {
         CRND_ASSERT(m_size);

         if (m_size)
         {
            m_size--;
            scalar_type<T>::destruct(&m_p[m_size]);
         }
      }

      inline void insert(uint32 index, const T* p, uint32 n)
      {
         CRND_ASSERT(index <= m_size);
         if (!n)
            return;

         const uint32 orig_size = m_size;
         resize(m_size + n);

         const T* pSrc = m_p + orig_size - 1;
         T* pDst = const_cast<T*>(pSrc) + n;

         const uint32 num_to_move = orig_size - index;

         for (uint32 i = 0; i < num_to_move; i++)
         {
            CRND_ASSERT((pDst - m_p) < (int)m_size);
            *pDst-- = *pSrc--;
         }

         pSrc = p;
         pDst = m_p + index;

         for (uint32 i = 0; i < n; i++)
         {
            CRND_ASSERT((pDst - m_p) < (int)m_size);
            *pDst++ = *p++;
         }
      }

      inline void erase(uint32 start, uint32 n)
      {
         CRND_ASSERT((start + n) <= m_size);

         if (!n)
            return;

         const uint32 num_to_move = m_size - (start + n);

         T* pDst = m_p + start;
         T* pDst_end = pDst + num_to_move;
         const T* pSrc = m_p + start + n;

         while (pDst != pDst_end)
            *pDst++ = *pSrc++;

         scalar_type<T>::destruct_array(pDst_end, n);

         m_size -= n;
      }

      inline void erase(uint32 index)
      {
         erase(index, 1);
      }

      inline void erase(T* p)
      {
         CRND_ASSERT((p >= m_p) && (p < (m_p + m_size)));
         erase(p - m_p);
      }

      inline bool operator== (const vector& rhs) const
      {
         if (m_size != rhs.m_size)
            return false;
         else if (m_size)
         {
            if (scalar_type<T>::cFlag)
               return memcmp(m_p, rhs.m_p, sizeof(T) * m_size) == 0;
            else
            {
               const T* pSrc = m_p;
               const T* pDst = rhs.m_p;
               for (uint32 i = m_size; i; i--)
                  if (!(*pSrc++ == *pDst++))
                     return false;
            }
         }

         return true;
      }

      inline bool operator< (const vector& rhs) const
      {
         const uint32 min_size = math::minimum(m_size, rhs.m_size);

         const T* pSrc = m_p;
         const T* pSrc_end = m_p + min_size;
         const T* pDst = rhs.m_p;

         while ((pSrc < pSrc_end) && (*pSrc == *pDst))
         {
            pSrc++;
            pDst++;
         }

         if (pSrc < pSrc_end)
            return *pSrc < *pDst;

         return m_size < rhs.m_size;
      }

      void swap(vector& other)
      {
         utils::swap(m_p, other.m_p);
         utils::swap(m_size, other.m_size);
         utils::swap(m_capacity, other.m_capacity);
      }

   private:
      T*          m_p;
      uint32      m_size;
      uint32      m_capacity;
      bool        m_alloc_failed;

      template<typename Q> struct is_vector { enum { cFlag = false }; };
      template<typename Q> struct is_vector< vector<Q> > { enum { cFlag = true }; };

      static void object_mover(void* pDst_void, void* pSrc_void, uint32 num)
      {
         T* pSrc = static_cast<T*>(pSrc_void);
         T* const pSrc_end = pSrc + num;
         T* pDst = static_cast<T*>(pDst_void);

         while (pSrc != pSrc_end)
         {
            helpers::construct<T>(pDst, *pSrc);
            pSrc->~T();
            pSrc++;
            pDst++;
         }
      }

      inline bool increase_capacity(uint32 min_new_capacity, bool grow_hint)
      {
         if (!reinterpret_cast<elemental_vector*>(this)->increase_capacity(
            min_new_capacity, grow_hint, sizeof(T),
            ((scalar_type<T>::cFlag) || (is_vector<T>::cFlag) || (bitwise_movable<T>::cFlag) || CRND_IS_POD(T)) ? NULL : object_mover))
         {
            m_alloc_failed = true;
            return false;
         }
         return true;
      }
   };

#ifdef _MSC_VER
#pragma warning(pop)
#endif

   extern void vector_test();

} // namespace crnd

// File: crnd_private.h
namespace crnd
{
   const crn_header* crnd_get_header(crn_header& header, const void* pData, uint32 data_size);

} // namespace crnd

// File: checksum.h
namespace crnd
{
   // crc16() intended for small buffers - doesn't use an acceleration table.
   const uint16 cInitCRC16 = 0;
   uint16 crc16(const void* pBuf, uint32 len, uint16 crc = cInitCRC16);

}  // namespace crnd

// File: crnd_color.h
namespace crnd
{
   template<typename component_type> struct color_quad_component_traits
   {
      enum
      {
         cSigned = false,
         cFloat = false,
         cMin = cUINT8_MIN,
         cMax = cUINT8_MAX
      };
   };

   template<> struct color_quad_component_traits<int16>
   {
      enum
      {
         cSigned = true,
         cFloat = false,
         cMin = cINT16_MIN,
         cMax = cINT16_MAX
      };
   };

   template<> struct color_quad_component_traits<uint16>
   {
      enum
      {
         cSigned = false,
         cFloat = false,
         cMin = cUINT16_MIN,
         cMax = cUINT16_MAX
      };
   };

   template<> struct color_quad_component_traits<int32>
   {
      enum
      {
         cSigned = true,
         cFloat = false,
         cMin = cINT32_MIN,
         cMax = cINT32_MAX
      };
   };

   template<> struct color_quad_component_traits<uint32>
   {
      enum
      {
         cSigned = false,
         cFloat = false,
         cMin = cUINT32_MIN,
         cMax = cUINT32_MAX
      };
   };

   template<> struct color_quad_component_traits<float>
   {
      enum
      {
         cSigned = false,
         cFloat = true,
         cMin = cINT32_MIN,
         cMax = cINT32_MAX
      };
   };

   template<> struct color_quad_component_traits<double>
   {
      enum
      {
         cSigned = false,
         cFloat = true,
         cMin = cINT32_MIN,
         cMax = cINT32_MAX
      };
   };

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4201) //  warning C4201: nonstandard extension used : nameless struct/union
#pragma warning(disable:4127) //  warning C4127: conditional expression is constant
#endif

   template<typename component_type, typename parameter_type>
   class color_quad : public helpers::rel_ops<color_quad<component_type, parameter_type> >
   {
      static parameter_type clamp(parameter_type v)
      {
         if (component_traits::cFloat)
            return v;
         else
         {
            if (v < component_traits::cMin)
               return component_traits::cMin;
            else if (v > component_traits::cMax)
               return component_traits::cMax;
            return v;
         }
      }

   public:
      typedef component_type component_t;
      typedef parameter_type parameter_t;
      typedef color_quad_component_traits<component_type> component_traits;

      enum { cNumComps = 4 };

      union
      {
         struct
         {
            component_type r;
            component_type g;
            component_type b;
            component_type a;
         };

         component_type c[cNumComps];
      };

      inline color_quad()
      {
      }

      inline color_quad(eClear) :
         r(0), g(0), b(0), a(0)
      {
      }

      inline color_quad(const color_quad& other) :
         r(other.r), g(other.g), b(other.b), a(other.a)
      {
      }

      inline color_quad(parameter_type y, parameter_type alpha = component_traits::cMax)
      {
         set(y, alpha);
      }

      inline color_quad(parameter_type red, parameter_type green, parameter_type blue, parameter_type alpha = component_traits::cMax)
      {
         set(red, green, blue, alpha);
      }

      template<typename other_component_type, typename other_parameter_type>
      inline color_quad(const color_quad<other_component_type, other_parameter_type>& other) :
         r(clamp(other.r)), g(clamp(other.g)), b(clamp(other.b)), a(clamp(other.a))
      {
      }

      inline void clear()
      {
         r = 0;
         g = 0;
         b = 0;
         a = 0;
      }

      inline color_quad& operator= (const color_quad& other)
      {
         r = other.r;
         g = other.g;
         b = other.b;
         a = other.a;
         return *this;
      }

      template<typename other_component_type, typename other_parameter_type>
      inline color_quad& operator=(const color_quad<other_component_type, other_parameter_type>& other)
      {
         r = clamp(other.r);
         g = clamp(other.g);
         b = clamp(other.b);
         a = clamp(other.a);
         return *this;
      }

      inline color_quad& set(parameter_type y, parameter_type alpha = component_traits::cMax)
      {
         y = clamp(y);
         r = static_cast<component_type>(y);
         g = static_cast<component_type>(y);
         b = static_cast<component_type>(y);
         a = static_cast<component_type>(alpha);
         return *this;
      }

      inline color_quad& set(parameter_type red, parameter_type green, parameter_type blue, parameter_type alpha = component_traits::cMax)
      {
         r = static_cast<component_type>(clamp(red));
         g = static_cast<component_type>(clamp(green));
         b = static_cast<component_type>(clamp(blue));
         a = static_cast<component_type>(clamp(alpha));
         return *this;
      }

      inline color_quad& set_noclamp_rgba(parameter_type red, parameter_type green, parameter_type blue, parameter_type alpha)
      {
         r = static_cast<component_type>(red);
         g = static_cast<component_type>(green);
         b = static_cast<component_type>(blue);
         a = static_cast<component_type>(alpha);
         return *this;
      }

      inline color_quad& set_noclamp_rgb(parameter_type red, parameter_type green, parameter_type blue)
      {
         r = static_cast<component_type>(red);
         g = static_cast<component_type>(green);
         b = static_cast<component_type>(blue);
         return *this;
      }

      static inline parameter_type get_min_comp() { return component_traits::cMin; }
      static inline parameter_type get_max_comp() { return component_traits::cMax; }
      static inline bool get_comps_are_signed() { return component_traits::cSigned; }

      inline component_type operator[] (uint32 i) const { CRND_ASSERT(i < cNumComps); return c[i]; }
      inline component_type& operator[] (uint32 i) { CRND_ASSERT(i < cNumComps); return c[i]; }

      inline color_quad& set_component(uint32 i, parameter_type f)
      {
         CRND_ASSERT(i < cNumComps);

         c[i] = static_cast<component_type>(clamp(f));

         return *this;
      }

      inline color_quad& clamp(const color_quad& l, const color_quad& h)
      {
         for (uint32 i = 0; i < cNumComps; i++)
            c[i] = static_cast<component_type>(math::clamp<parameter_type>(c[i], l[i], h[i]));
         return *this;
      }

      inline color_quad& clamp(parameter_type l, parameter_type h)
      {
         for (uint32 i = 0; i < cNumComps; i++)
            c[i] = static_cast<component_type>(math::clamp<parameter_type>(c[i], l, h));
         return *this;
      }

      // Returns CCIR 601 luma (consistent with color_utils::RGB_To_Y).
      inline parameter_type get_luma() const
      {
         return static_cast<parameter_type>((19595U * r + 38470U * g + 7471U * b + 32768) >> 16U);
      }

      // Returns REC 709 luma.
      inline parameter_type get_luma_rec709() const
      {
         return static_cast<parameter_type>((13938U * r + 46869U * g + 4729U * b + 32768U) >> 16U);
      }

      inline uint32 squared_distance(const color_quad& c, bool alpha = true) const
      {
         return math::square(r - c.r) + math::square(g - c.g) + math::square(b - c.b) + (alpha ? math::square(a - c.a) : 0);
      }

      inline bool rgb_equals(const color_quad& rhs) const
      {
         return (r == rhs.r) && (g == rhs.g) && (b == rhs.b);
      }

      inline bool operator== (const color_quad& rhs) const
      {
         return (r == rhs.r) && (g == rhs.g) && (b == rhs.b) && (a == rhs.a);
      }

      inline bool operator< (const color_quad& rhs) const
      {
         for (uint32 i = 0; i < cNumComps; i++)
         {
            if (c[i] < rhs.c[i])
               return true;
            else if (!(c[i] == rhs.c[i]))
               return false;
         }
         return false;
      }

      inline color_quad& operator+= (const color_quad& other)
      {
         for (uint32 i = 0; i < 4; i++)
            c[i] = static_cast<component_type>(clamp(c[i] + other.c[i]));
         return *this;
      }

      inline color_quad& operator-= (const color_quad& other)
      {
         for (uint32 i = 0; i < 4; i++)
            c[i] = static_cast<component_type>(clamp(c[i] - other.c[i]));
         return *this;
      }

      inline color_quad& operator*= (parameter_type v)
      {
         for (uint32 i = 0; i < 4; i++)
            c[i] = static_cast<component_type>(clamp(c[i] * v));
         return *this;
      }

      inline color_quad& operator/= (parameter_type v)
      {
         for (uint32 i = 0; i < 4; i++)
            c[i] = static_cast<component_type>(c[i] / v);
         return *this;
      }

      inline color_quad get_swizzled(uint32 x, uint32 y, uint32 z, uint32 w) const
      {
         CRND_ASSERT((x | y | z | w) < 4);
         return color_quad(c[x], c[y], c[z], c[w]);
      }

      inline friend color_quad operator+ (const color_quad& lhs, const color_quad& rhs)
      {
         color_quad result(lhs);
         result += rhs;
         return result;
      }

      inline friend color_quad operator- (const color_quad& lhs, const color_quad& rhs)
      {
         color_quad result(lhs);
         result -= rhs;
         return result;
      }

      inline friend color_quad operator* (const color_quad& lhs, parameter_type v)
      {
         color_quad result(lhs);
         result *= v;
         return result;
      }

      friend inline color_quad operator/ (const color_quad& lhs, parameter_type v)
      {
         color_quad result(lhs);
         result /= v;
         return result;
      }

      friend inline color_quad operator* (parameter_type v, const color_quad& rhs)
      {
         color_quad result(rhs);
         result *= v;
         return result;
      }

      inline uint32 get_min_component_index(bool alpha = true) const
      {
         uint32 index = 0;
         uint32 limit = alpha ? cNumComps : (cNumComps - 1);
         for (uint32 i = 1; i < limit; i++)
            if (c[i] < c[index])
               index = i;
         return index;
      }

      inline uint32 get_max_component_index(bool alpha = true) const
      {
         uint32 index = 0;
         uint32 limit = alpha ? cNumComps : (cNumComps - 1);
         for (uint32 i = 1; i < limit; i++)
            if (c[i] > c[index])
               index = i;
         return index;
      }

      inline void get_float4(float* pDst)
      {
         for (uint32 i = 0; i < 4; i++)
            pDst[i] = ((*this)[i] - component_traits::cMin) / float(component_traits::cMax - component_traits::cMin);
      }

      inline void get_float3(float* pDst)
      {
         for (uint32 i = 0; i < 3; i++)
            pDst[i] = ((*this)[i] - component_traits::cMin) / float(component_traits::cMax - component_traits::cMin);
      }

      static inline color_quad make_black()
      {
         return color_quad(0, 0, 0, component_traits::cMax);
      }

      static inline color_quad make_white()
      {
         return color_quad(component_traits::cMax, component_traits::cMax, component_traits::cMax, component_traits::cMax);
      }
   }; // class color_quad

#ifdef _MSC_VER
#pragma warning(pop)
#endif

   template<typename c, typename q>
   struct scalar_type< color_quad<c, q> >
   {
      enum { cFlag = true };
      static inline void construct(color_quad<c, q>* p) { }
      static inline void construct(color_quad<c, q>* p, const color_quad<c, q>& init) { memcpy(p, &init, sizeof(color_quad<c, q>)); }
      static inline void construct_array(color_quad<c, q>* p, uint32 n) { p, n; }
      static inline void destruct(color_quad<c, q>* p) { p; }
      static inline void destruct_array(color_quad<c, q>* p, uint32 n) { p, n; }
   };

   typedef color_quad<uint8, int>      color_quad_u8;
   typedef color_quad<int16, int>      color_quad_i16;
   typedef color_quad<uint16, int>     color_quad_u16;
   typedef color_quad<int32, int>      color_quad_i32;
   typedef color_quad<uint32, uint32>    color_quad_u32;
   typedef color_quad<float, float>    color_quad_f;
   typedef color_quad<double, double>  color_quad_d;

} // namespace crnd

// File: crnd_dxt.h
namespace crnd
{
   enum dxt_format
   {
      cDXTInvalid = -1,

      // cDXT1/1A must appear first!
      cDXT1,
      cDXT1A,

      cDXT3,
      cDXT5,
      cDXT5A,

      cDXN_XY,    // inverted relative to standard ATI2, 360's DXN
      cDXN_YX     // standard ATI2
   };

   enum dxt_constants
   {
      cDXTBlockShift = 2U,
      cDXTBlockSize = 1U << cDXTBlockShift,

      cDXT1BytesPerBlock = 8U,
      cDXT5NBytesPerBlock = 16U,

      cDXT1SelectorBits = 2U,
      cDXT1SelectorValues = 1U << cDXT1SelectorBits,
      cDXT1SelectorMask = cDXT1SelectorValues - 1U,

      cDXT5SelectorBits = 3U,
      cDXT5SelectorValues = 1U << cDXT5SelectorBits,
      cDXT5SelectorMask = cDXT5SelectorValues - 1U
   };

   const float cDXT1MaxLinearValue = 3.0f;
   const float cDXT1InvMaxLinearValue = 1.0f/3.0f;

   const float cDXT5MaxLinearValue = 7.0f;
   const float cDXT5InvMaxLinearValue = 1.0f/7.0f;

   // Converts DXT1 raw color selector index to a linear value.
   extern const uint8 g_dxt1_to_linear[cDXT1SelectorValues];

   // Converts DXT5 raw alpha selector index to a linear value.
   extern const uint8 g_dxt5_to_linear[cDXT5SelectorValues];

   // Converts DXT1 linear color selector index to a raw value (inverse of g_dxt1_to_linear).
   extern const uint8 g_dxt1_from_linear[cDXT1SelectorValues];

   // Converts DXT5 linear alpha selector index to a raw value (inverse of g_dxt5_to_linear).
   extern const uint8 g_dxt5_from_linear[cDXT5SelectorValues];

   extern const uint8 g_six_alpha_invert_table[cDXT5SelectorValues];
   extern const uint8 g_eight_alpha_invert_table[cDXT5SelectorValues];

   struct dxt1_block
   {
      uint8 m_low_color[2];
      uint8 m_high_color[2];

      enum { cNumSelectorBytes = 4 };
      uint8 m_selectors[cNumSelectorBytes];

      inline void clear()
      {
         utils::zero_this(this);
      }

      // These methods assume the in-memory rep is in LE byte order.
      inline uint32 get_low_color() const
      {
         return m_low_color[0] | (m_low_color[1] << 8U);
      }

      inline uint32 get_high_color() const
      {
         return m_high_color[0] | (m_high_color[1] << 8U);
      }

      inline void set_low_color(uint16 c)
      {
         m_low_color[0] = static_cast<uint8>(c & 0xFF);
         m_low_color[1] = static_cast<uint8>((c >> 8) & 0xFF);
      }

      inline void set_high_color(uint16 c)
      {
         m_high_color[0] = static_cast<uint8>(c & 0xFF);
         m_high_color[1] = static_cast<uint8>((c >> 8) & 0xFF);
      }

      inline uint32 get_selector(uint32 x, uint32 y) const
      {
         CRND_ASSERT((x < 4U) && (y < 4U));
         return (m_selectors[y] >> (x * cDXT1SelectorBits)) & cDXT1SelectorMask;
      }

      inline void set_selector(uint32 x, uint32 y, uint32 val)
      {
         CRND_ASSERT((x < 4U) && (y < 4U) && (val < 4U));

         m_selectors[y] &= (~(cDXT1SelectorMask << (x * cDXT1SelectorBits)));
         m_selectors[y] |= (val << (x * cDXT1SelectorBits));
      }

      static uint16        pack_color(const color_quad_u8& color, bool scaled, uint32 bias = 127U);
      static uint16        pack_color(uint32 r, uint32 g, uint32 b, bool scaled, uint32 bias = 127U);

      static color_quad_u8 unpack_color(uint16 packed_color, bool scaled, uint32 alpha = 255U);
      static void          unpack_color(uint32& r, uint32& g, uint32& b, uint16 packed_color, bool scaled);

      static uint32        get_block_colors3(color_quad_u8* pDst, uint16 color0, uint16 color1);
      static uint32        get_block_colors4(color_quad_u8* pDst, uint16 color0, uint16 color1);
      // pDst must point to an array at least cDXT1SelectorValues long.
      static uint32        get_block_colors(color_quad_u8* pDst, uint16 color0, uint16 color1);

      static color_quad_u8 unpack_endpoint(uint32 endpoints, uint32 index, bool scaled, uint32 alpha = 255U);
      static uint32        pack_endpoints(uint32 lo, uint32 hi);
   };

   CRND_DEFINE_BITWISE_MOVABLE(dxt1_block);

   struct dxt3_block
   {
      enum { cNumAlphaBytes = 8 };
      uint8 m_alpha[cNumAlphaBytes];

      void set_alpha(uint32 x, uint32 y, uint32 value, bool scaled);
      uint32 get_alpha(uint32 x, uint32 y, bool scaled) const;
   };

   CRND_DEFINE_BITWISE_MOVABLE(dxt3_block);

   struct dxt5_block
   {
      uint8 m_endpoints[2];

      enum { cNumSelectorBytes = 6 };
      uint8 m_selectors[cNumSelectorBytes];

      inline void clear()
      {
         utils::zero_this(this);
      }

      inline uint32 get_low_alpha() const
      {
         return m_endpoints[0];
      }

      inline uint32 get_high_alpha() const
      {
         return m_endpoints[1];
      }

      inline void set_low_alpha(uint32 i)
      {
         CRND_ASSERT(i <= cUINT8_MAX);
         m_endpoints[0] = static_cast<uint8>(i);
      }

      inline void set_high_alpha(uint32 i)
      {
         CRND_ASSERT(i <= cUINT8_MAX);
         m_endpoints[1] = static_cast<uint8>(i);
      }

      uint32 get_endpoints_as_word() const { return m_endpoints[0] | (m_endpoints[1] << 8); }

      uint32 get_selectors_as_word(uint32 index) { CRND_ASSERT(index < 3); return m_selectors[index * 2] | (m_selectors[index * 2 + 1] << 8); }

      inline uint32 get_selector(uint32 x, uint32 y) const
      {
         CRND_ASSERT((x < 4U) && (y < 4U));

         uint32 selector_index = (y * 4) + x;
         uint32 bit_index = selector_index * cDXT5SelectorBits;

         uint32 byte_index = bit_index >> 3;
         uint32 bit_ofs = bit_index & 7;

         uint32 v = m_selectors[byte_index];
         if (byte_index < (cNumSelectorBytes - 1))
            v |= (m_selectors[byte_index + 1] << 8);

         return (v >> bit_ofs) & 7;
      }

      inline void set_selector(uint32 x, uint32 y, uint32 val)
      {
         CRND_ASSERT((x < 4U) && (y < 4U) && (val < 8U));

         uint32 selector_index = (y * 4) + x;
         uint32 bit_index = selector_index * cDXT5SelectorBits;

         uint32 byte_index = bit_index >> 3;
         uint32 bit_ofs = bit_index & 7;

         uint32 v = m_selectors[byte_index];
         if (byte_index < (cNumSelectorBytes - 1))
            v |= (m_selectors[byte_index + 1] << 8);

         v &= (~(7 << bit_ofs));
         v |= (val << bit_ofs);

         m_selectors[byte_index] = static_cast<uint8>(v);
         if (byte_index < (cNumSelectorBytes - 1))
            m_selectors[byte_index + 1] = static_cast<uint8>(v >> 8);
      }

      // Results written to alpha channel.
      static uint32          get_block_values6(color_quad_u8* pDst, uint32 l, uint32 h);
      static uint32          get_block_values8(color_quad_u8* pDst, uint32 l, uint32 h);
      static uint32          get_block_values(color_quad_u8* pDst, uint32 l, uint32 h);

      static uint32          get_block_values6(uint32* pDst, uint32 l, uint32 h);
      static uint32          get_block_values8(uint32* pDst, uint32 l, uint32 h);
      // pDst must point to an array at least cDXT5SelectorValues long.
      static uint32          get_block_values(uint32* pDst, uint32 l, uint32 h);

      static uint32          unpack_endpoint(uint32 packed, uint32 index);
      static uint32          pack_endpoints(uint32 lo, uint32 hi);
   };

   CRND_DEFINE_BITWISE_MOVABLE(dxt5_block);

} // namespace crnd

// File: crnd_dxt_hc_common.h
namespace crnd
{
   struct chunk_tile_desc
   {
      // These values are in pixels, and always a multiple of cBlockPixelWidth/cBlockPixelHeight.
      uint32 m_x_ofs;
      uint32 m_y_ofs;
      uint32 m_width;
      uint32 m_height;
      uint32 m_layout_index;
   };

   struct chunk_encoding_desc
   {
      uint32 m_num_tiles;
      chunk_tile_desc m_tiles[4];
   };

   const uint32 cChunkPixelWidth = 8;
   const uint32 cChunkPixelHeight = 8;
   const uint32 cChunkBlockWidth = 2;
   const uint32 cChunkBlockHeight = 2;

   const uint32 cChunkMaxTiles = 4;

   const uint32 cBlockPixelWidthShift = 2;
   const uint32 cBlockPixelHeightShift = 2;

   const uint32 cBlockPixelWidth = 4;
   const uint32 cBlockPixelHeight = 4;

   const uint32 cNumChunkEncodings = 8;
   extern chunk_encoding_desc g_chunk_encodings[cNumChunkEncodings];

   const uint32 cNumChunkTileLayouts = 9;
   const uint32 cFirst4x4ChunkTileLayout = 5;
   extern chunk_tile_desc g_chunk_tile_layouts[cNumChunkTileLayouts];

} // namespace crnd

// File: crnd_prefix_coding.h
#ifdef _XBOX
#define CRND_PREFIX_CODING_USE_FIXED_TABLE_SIZE 1
#else
#define CRND_PREFIX_CODING_USE_FIXED_TABLE_SIZE 0
#endif

namespace crnd
{
   namespace prefix_coding
   {
      const uint32 cMaxExpectedCodeSize = 16;
      const uint32 cMaxSupportedSyms = 8192;
      const uint32 cMaxTableBits = 11;

      class decoder_tables
      {
      public:
         inline decoder_tables() :
            m_cur_lookup_size(0), m_lookup(NULL), m_cur_sorted_symbol_order_size(0), m_sorted_symbol_order(NULL)
         {
         }

         inline decoder_tables(const decoder_tables& other) :
            m_cur_lookup_size(0), m_lookup(NULL), m_cur_sorted_symbol_order_size(0), m_sorted_symbol_order(NULL)
         {
            *this = other;
         }

         decoder_tables& operator= (const decoder_tables& other)
         {
            if (this == &other)
               return *this;

            clear();

            memcpy(this, &other, sizeof(*this));

            if (other.m_lookup)
            {
               m_lookup = crnd_new_array<uint32>(m_cur_lookup_size);
               if (m_lookup)
                  memcpy(m_lookup, other.m_lookup, sizeof(m_lookup[0]) * m_cur_lookup_size);
            }

            if (other.m_sorted_symbol_order)
            {
               m_sorted_symbol_order = crnd_new_array<uint16>(m_cur_sorted_symbol_order_size);
               if (m_sorted_symbol_order)
                  memcpy(m_sorted_symbol_order, other.m_sorted_symbol_order, sizeof(m_sorted_symbol_order[0]) * m_cur_sorted_symbol_order_size);
            }

            return *this;
         }

         inline void clear()
         {
            if (m_lookup)
            {
               crnd_delete_array(m_lookup);
               m_lookup = 0;
               m_cur_lookup_size = 0;
            }

            if (m_sorted_symbol_order)
            {
               crnd_delete_array(m_sorted_symbol_order);
               m_sorted_symbol_order = NULL;
               m_cur_sorted_symbol_order_size = 0;
            }
         }

         inline ~decoder_tables()
         {
            if (m_lookup)
               crnd_delete_array(m_lookup);

            if (m_sorted_symbol_order)
               crnd_delete_array(m_sorted_symbol_order);
         }

         bool init(uint32 num_syms, const uint8* pCodesizes, uint32 table_bits);

         // DO NOT use any complex classes here - it is bitwise copied.

         uint32                  m_num_syms;
         uint32                  m_total_used_syms;
         uint32                  m_table_bits;
         uint32                  m_table_shift;
         uint32                  m_table_max_code;
         uint32                  m_decode_start_code_size;

         uint8                   m_min_code_size;
         uint8                   m_max_code_size;

         uint32                  m_max_codes[cMaxExpectedCodeSize + 1];
         int32                   m_val_ptrs[cMaxExpectedCodeSize + 1];

         uint32                  m_cur_lookup_size;
         uint32*                 m_lookup;

         uint32                  m_cur_sorted_symbol_order_size;
         uint16*                 m_sorted_symbol_order;

         inline uint32 get_unshifted_max_code(uint32 len) const
         {
            CRND_ASSERT( (len >= 1) && (len <= cMaxExpectedCodeSize) );
            uint32 k = m_max_codes[len - 1];
            if (!k)
               return crnd::cUINT32_MAX;
            return (k - 1) >> (16 - len);
         }
      };

   } // namespace prefix_coding

} // namespace crnd

// File: crnd_symbol_codec.h
namespace crnd
{
   class static_huffman_data_model
   {
   public:
      static_huffman_data_model();
      static_huffman_data_model(const static_huffman_data_model& other);
      ~static_huffman_data_model();

      static_huffman_data_model& operator= (const static_huffman_data_model& rhs);

      bool init(uint32 total_syms, const uint8* pCode_sizes, uint32 code_size_limit);
      void clear();

      inline bool is_valid() const { return m_pDecode_tables != NULL; }

      inline uint32 get_total_syms() const { return m_total_syms; }

      inline uint32 get_code_size(uint32 sym) const { return m_code_sizes[sym]; }

      inline const uint8* get_code_sizes() const { return m_code_sizes.empty() ? NULL : &m_code_sizes[0]; }

   public:
      uint32                           m_total_syms;
      crnd::vector<uint8>              m_code_sizes;
      prefix_coding::decoder_tables*   m_pDecode_tables;

   private:
      bool prepare_decoder_tables();
      uint compute_decoder_table_bits() const;

      friend class symbol_codec;
   };

   class symbol_codec
   {
   public:
      symbol_codec();

      bool start_decoding(const uint8* pBuf, uint32 buf_size);
      bool decode_receive_static_data_model(static_huffman_data_model& model);

      uint32 decode_bits(uint32 num_bits);
      uint32 decode(const static_huffman_data_model& model);

      uint64 stop_decoding();

   public:
      const uint8*         m_pDecode_buf;
      const uint8*         m_pDecode_buf_next;
      const uint8*         m_pDecode_buf_end;
      uint32               m_decode_buf_size;

      typedef uint32 bit_buf_type;
      enum { cBitBufSize = 32U };
      bit_buf_type         m_bit_buf;

      int                  m_bit_count;

   private:
      void get_bits_init();
      uint32 get_bits(uint32 num_bits);
   };

} // namespace crnd

#define CRND_HUFF_DECODE_BEGIN(x)
#define CRND_HUFF_DECODE_END(x)
#define CRND_HUFF_DECODE(codec, model, symbol) symbol = codec.decode(model);

namespace crnd
{
   void crnd_assert(const char* pExp, const char* pFile, unsigned line)
   {
      char buf[512];

#if defined(_WIN32) && defined(_MSC_VER)
      sprintf_s(buf, sizeof(buf), "%s(%u): Assertion failure: \"%s\"\n", pFile, line, pExp);
#else
      sprintf(buf, "%s(%u): Assertion failure: \"%s\"\n", pFile, line, pExp);
#endif

      crnd_output_debug_string(buf);

      puts(buf);

      if (crnd_is_debugger_present())
         crnd_debug_break();
   }

   void crnd_trace(const char* pFmt, va_list args)
   {
      if (crnd_is_debugger_present())
      {
         char buf[512];
#if defined(_WIN32) && defined(_MSC_VER)
         vsprintf_s(buf, sizeof(buf), pFmt, args);
#else
         vsprintf(buf, pFmt, args);
#endif

         crnd_output_debug_string(buf);
      }
   };

   void crnd_trace(const char* pFmt, ...)
   {
      va_list args;
      va_start(args, pFmt);
      crnd_trace(pFmt, args);
      va_end(args);
   };

} // namespace crnd

// File: checksum.cpp
// From the public domain stb.h header.
namespace crnd
{
   uint16 crc16(const void* pBuf, uint32 len, uint16 crc)
   {
      crc = ~crc;

      const uint8* p = reinterpret_cast<const uint8*>(pBuf);
      while (len)
      {
         const uint16 q = *p++ ^ (crc >> 8U);
         crc <<= 8U;

         uint16 r = (q >> 4U) ^ q;
         crc ^= r;
         r <<= 5U;
         crc ^= r;
         r <<= 7U;
         crc ^= r;

         len--;
      }

      return static_cast<uint16>(~crc);
   }

} // namespace crnd


// File: crnd_vector.cpp
namespace crnd
{
   bool elemental_vector::increase_capacity(uint32 min_new_capacity, bool grow_hint, uint32 element_size, object_mover pMover)
   {
      CRND_ASSERT(m_size <= m_capacity);
      CRND_ASSERT(min_new_capacity < (0x7FFF0000U / element_size));

      if (m_capacity >= min_new_capacity)
         return true;

      uint32 new_capacity = min_new_capacity;
      if ((grow_hint) && (!math::is_power_of_2(new_capacity)))
         new_capacity = math::next_pow2(new_capacity);

      CRND_ASSERT(new_capacity && (new_capacity > m_capacity));

      const uint32 desired_size = element_size * new_capacity;
      size_t actual_size;
      if (!pMover)
      {
         void* new_p = crnd_realloc(m_p, desired_size, &actual_size, true);
         if (!new_p)
            return false;
         m_p = new_p;
      }
      else
      {
         void* new_p = crnd_malloc(desired_size, &actual_size);
         if (!new_p)
            return false;

         (*pMover)(new_p, m_p, m_size);

         if (m_p)
            crnd_free(m_p);

         m_p = new_p;
      }

      if (actual_size > desired_size)
         m_capacity = static_cast<uint32>(actual_size / element_size);
      else
         m_capacity = new_capacity;

      return true;
   }

} // namespace crnd

// File: crnd_utils.cpp
namespace crnd
{
   namespace utils
   {
      uint32 compute_max_mips(uint32 width, uint32 height)
      {
         if ((width | height) == 0)
            return 0;

         uint32 num_mips = 1;

         while ((width > 1U) || (height > 1U))
         {
            width >>= 1U;
            height >>= 1U;
            num_mips++;
         }

         return num_mips;
      }

   } // namespace utils

} // namespace crnd

// File: crnd_prefix_coding.cpp
namespace crnd
{
   namespace prefix_coding
   {
      bool decoder_tables::init(uint32 num_syms, const uint8* pCodesizes, uint32 table_bits)
      {
         uint32 min_codes[cMaxExpectedCodeSize];
         if ((!num_syms) || (table_bits > cMaxTableBits))
            return false;

         m_num_syms = num_syms;

         uint32 num_codes[cMaxExpectedCodeSize + 1];
         utils::zero_object(num_codes);

         for (uint32 i = 0; i < num_syms; i++)
         {
            uint32 c = pCodesizes[i];
            if (c)
               num_codes[c]++;
         }

         uint32 sorted_positions[cMaxExpectedCodeSize + 1];

         uint32 cur_code = 0;

         uint32 total_used_syms = 0;
         uint32 max_code_size = 0;
         uint32 min_code_size = cUINT32_MAX;
         for (uint32 i = 1; i <= cMaxExpectedCodeSize; i++)
         {
            const uint32 n = num_codes[i];

            if (!n)
               m_max_codes[i - 1] = 0;//UINT_MAX;
            else
            {
               min_code_size = math::minimum(min_code_size, i);
               max_code_size = math::maximum(max_code_size, i);

               min_codes[i - 1] = cur_code;

               m_max_codes[i - 1] = cur_code + n - 1;
               m_max_codes[i - 1] = 1 + ((m_max_codes[i - 1] << (16 - i)) | ((1 << (16 - i)) - 1));

               m_val_ptrs[i - 1] = total_used_syms;

               sorted_positions[i] = total_used_syms;

               cur_code += n;
               total_used_syms += n;
            }

            cur_code <<= 1;
         }

         m_total_used_syms = total_used_syms;

         if (total_used_syms > m_cur_sorted_symbol_order_size)
         {
            m_cur_sorted_symbol_order_size = total_used_syms;

            if (!math::is_power_of_2(total_used_syms))
               m_cur_sorted_symbol_order_size = math::minimum<uint32>(num_syms, math::next_pow2(total_used_syms));

            if (m_sorted_symbol_order)
               crnd_delete_array(m_sorted_symbol_order);

            m_sorted_symbol_order = crnd_new_array<uint16>(m_cur_sorted_symbol_order_size);
            if (!m_sorted_symbol_order)
               return false;
         }

         m_min_code_size = static_cast<uint8>(min_code_size);
         m_max_code_size = static_cast<uint8>(max_code_size);

         for (uint32 i = 0; i < num_syms; i++)
         {
            uint32 c = pCodesizes[i];
            if (c)
            {
               CRND_ASSERT(num_codes[c]);

               uint32 sorted_pos = sorted_positions[c]++;

               CRND_ASSERT(sorted_pos < total_used_syms);

               m_sorted_symbol_order[sorted_pos] = static_cast<uint16>(i);
            }
         }

         if (table_bits <= m_min_code_size)
            table_bits = 0;
         m_table_bits = table_bits;

         if (table_bits)
         {
            uint32 table_size = 1 << table_bits;
            if (table_size > m_cur_lookup_size)
            {
               m_cur_lookup_size = table_size;

               if (m_lookup)
                  crnd_delete_array(m_lookup);

               m_lookup = crnd_new_array<uint32>(table_size);
               if (!m_lookup)
                  return false;
            }

            memset(m_lookup, 0xFF, (uint)sizeof(m_lookup[0]) * (1UL << table_bits));

            for (uint32 codesize = 1; codesize <= table_bits; codesize++)
            {
               if (!num_codes[codesize])
                  continue;

               const uint32 fillsize = table_bits - codesize;
               const uint32 fillnum = 1 << fillsize;

               const uint32 min_code = min_codes[codesize - 1];
               const uint32 max_code = get_unshifted_max_code(codesize);
               const uint32 val_ptr = m_val_ptrs[codesize - 1];

               for (uint32 code = min_code; code <= max_code; code++)
               {
                  const uint32 sym_index = m_sorted_symbol_order[ val_ptr + code - min_code ];
                  CRND_ASSERT( pCodesizes[sym_index] == codesize );

                  for (uint32 j = 0; j < fillnum; j++)
                  {
                     const uint32 t = j + (code << fillsize);

                     CRND_ASSERT(t < (1U << table_bits));

                     CRND_ASSERT(m_lookup[t] == cUINT32_MAX);

                     m_lookup[t] = sym_index | (codesize << 16U);
                  }
               }
            }
         }

         for (uint32 i = 0; i < cMaxExpectedCodeSize; i++)
            m_val_ptrs[i] -= min_codes[i];

         m_table_max_code = 0;
         m_decode_start_code_size = m_min_code_size;

         if (table_bits)
         {
            uint32 i;
            for (i = table_bits; i >= 1; i--)
            {
               if (num_codes[i])
               {
                  m_table_max_code = m_max_codes[i - 1];
                  break;
               }
            }
            if (i >= 1)
            {
               m_decode_start_code_size = table_bits + 1;
               for (uint32 j = table_bits + 1; j <= max_code_size; j++)
               {
                  if (num_codes[j])
                  {
                     m_decode_start_code_size = j;
                     break;
                  }
               }
            }
         }

         // sentinels
         m_max_codes[cMaxExpectedCodeSize] = cUINT32_MAX;
         m_val_ptrs[cMaxExpectedCodeSize] = 0xFFFFF;

         m_table_shift = 32 - m_table_bits;
         return true;
      }

   } // namespace prefix_codig

} // namespace crnd

// File: crnd_platform.cpp
namespace crnd
{
   bool crnd_is_debugger_present()
   {
#ifdef CRND_DEVEL
      return IsDebuggerPresent() != 0;
#else
      return false;
#endif
   }

   void crnd_debug_break()
   {
#ifdef CRND_DEVEL
      DebugBreak();
#endif
   }

   void crnd_output_debug_string(const char* p)
   {
      p;
#ifdef CRND_DEVEL
      OutputDebugStringA(p);
#endif
   }

} // namespace crnd

// File: crnd_mem.cpp
namespace crnd
{
   const uint32 MAX_POSSIBLE_BLOCK_SIZE = 0x7FFF0000U;

   static void* crnd_default_realloc(void* p, size_t size, size_t* pActual_size, bool movable, void* pUser_data)
   {
      pUser_data;

      void* p_new;

      if (!p)
      {
         p_new = ::malloc(size);

         if (pActual_size)
         {
#ifdef _WIN32
            *pActual_size = p_new ? ::_msize(p_new) : 0;
#else
            *pActual_size = p_new ? malloc_usable_size(p_new) : 0;
#endif
         }
      }
      else if (!size)
      {
         ::free(p);
         p_new = NULL;

         if (pActual_size)
            *pActual_size = 0;
      }
      else
      {
         void* p_final_block = p;
#ifdef _WIN32
         p_new = ::_expand(p, size);
#else
         p_new = NULL;
#endif

         if (p_new)
            p_final_block = p_new;
         else if (movable)
         {
            p_new = ::realloc(p, size);

            if (p_new)
               p_final_block = p_new;
         }

         if (pActual_size)
         {
#ifdef _WIN32
            *pActual_size = ::_msize(p_final_block);
#else
            *pActual_size = ::malloc_usable_size(p_final_block);
#endif
         }
      }

      return p_new;
   }

   static size_t crnd_default_msize(void* p, void* pUser_data)
   {
      pUser_data;
#ifdef _WIN32
      return p ? _msize(p) : 0;
#else
      return p ? malloc_usable_size(p) : 0;
#endif
   }

   static crnd_realloc_func        g_pRealloc = crnd_default_realloc;
   static crnd_msize_func          g_pMSize   = crnd_default_msize;
   static void*                   g_pUser_data;

   void crnd_set_memory_callbacks(crnd_realloc_func pRealloc, crnd_msize_func pMSize, void* pUser_data)
   {
      if ((!pRealloc) || (!pMSize))
      {
         g_pRealloc = crnd_default_realloc;
         g_pMSize = crnd_default_msize;
         g_pUser_data = NULL;
      }
      else
      {
         g_pRealloc = pRealloc;
         g_pMSize = pMSize;
         g_pUser_data = pUser_data;
      }
   }

   static inline void crnd_mem_error(const char* p_msg)
   {
      crnd_assert(p_msg, __FILE__, __LINE__);
   }

   void* crnd_malloc(size_t size, size_t* pActual_size)
   {
      size = (size + sizeof(uint32) - 1U) & ~(sizeof(uint32) - 1U);
      if (!size)
         size = sizeof(uint32);

      if (size > MAX_POSSIBLE_BLOCK_SIZE)
      {
         crnd_mem_error("crnd_malloc: size too big");
         return NULL;
      }

      size_t actual_size = size;
      uint8* p_new = static_cast<uint8*>((*g_pRealloc)(NULL, size, &actual_size, true, g_pUser_data));

      if (pActual_size)
         *pActual_size = actual_size;

      if ((!p_new) || (actual_size < size))
      {
         crnd_mem_error("crnd_malloc: out of memory");
         return NULL;
      }

      CRND_ASSERT(((uint32)p_new & (CRND_MIN_ALLOC_ALIGNMENT - 1)) == 0);

      return p_new;
   }

   void* crnd_realloc(void* p, size_t size, size_t* pActual_size, bool movable)
   {
      if ((uint32)reinterpret_cast<ptr_bits>(p) & (CRND_MIN_ALLOC_ALIGNMENT - 1))
      {
         crnd_mem_error("crnd_realloc: bad ptr");
         return NULL;
      }

      if (size > MAX_POSSIBLE_BLOCK_SIZE)
      {
         crnd_mem_error("crnd_malloc: size too big");
         return NULL;
      }

      size_t actual_size = size;
      void* p_new = (*g_pRealloc)(p, size, &actual_size, movable, g_pUser_data);

      if (pActual_size)
         *pActual_size = actual_size;

      CRND_ASSERT(((uint32)p_new & (CRND_MIN_ALLOC_ALIGNMENT - 1)) == 0);

      return p_new;
   }

   void crnd_free(void* p)
   {
      if (!p)
         return;

      if ((uint32)reinterpret_cast<ptr_bits>(p) & (CRND_MIN_ALLOC_ALIGNMENT - 1))
      {
         crnd_mem_error("crnd_free: bad ptr");
         return;
      }

      (*g_pRealloc)(p, 0, NULL, true, g_pUser_data);
   }

   size_t crnd_msize(void* p)
   {
      if (!p)
         return 0;

      if ((uint32)reinterpret_cast<ptr_bits>(p) & (CRND_MIN_ALLOC_ALIGNMENT - 1))
      {
         crnd_mem_error("crnd_msize: bad ptr");
         return 0;
      }

      return (*g_pMSize)(p, g_pUser_data);
   }

} // namespace crnd

// File: crnd_math.cpp
namespace crnd
{
   namespace math
   {
      uint32 g_bitmasks[32] =
      {
         1U <<  0U,         1U <<  1U,          1U <<  2U,        1U <<  3U,
         1U <<  4U,         1U <<  5U,          1U <<  6U,        1U <<  7U,
         1U <<  8U,         1U <<  9U,          1U << 10U,        1U << 11U,
         1U << 12U,         1U << 13U,          1U << 14U,        1U << 15U,
         1U << 16U,         1U << 17U,          1U << 18U,        1U << 19U,
         1U << 20U,         1U << 21U,          1U << 22U,        1U << 23U,
         1U << 24U,         1U << 25U,          1U << 26U,        1U << 27U,
         1U << 28U,         1U << 29U,          1U << 30U,        1U << 31U
      };

   } // namespace math
} // namespace crnd

// File: crnd_info.cpp
namespace crnd
{
#define CRND_FOURCC(a, b, c, d) ((a) | ((b) << 8U) | ((c) << 16U) | ((d) << 24U))

   uint32 crnd_crn_format_to_fourcc(crn_format fmt)
   {
      switch (fmt)
      {
         case cCRNFmtDXT1:        return CRND_FOURCC('D', 'X', 'T', '1');
         case cCRNFmtDXT3:        return CRND_FOURCC('D', 'X', 'T', '3');
         case cCRNFmtDXT5:        return CRND_FOURCC('D', 'X', 'T', '5');
         case cCRNFmtDXN_XY:      return CRND_FOURCC('A', '2', 'X', 'Y');
         case cCRNFmtDXN_YX:      return CRND_FOURCC('A', 'T', 'I', '2');
         case cCRNFmtDXT5A:       return CRND_FOURCC('A', 'T', 'I', '1');
         case cCRNFmtDXT5_CCxY:   return CRND_FOURCC('C', 'C', 'x', 'Y');
         case cCRNFmtDXT5_xGxR:   return CRND_FOURCC('x', 'G', 'x', 'R');
         case cCRNFmtDXT5_xGBR:   return CRND_FOURCC('x', 'G', 'B', 'R');
         case cCRNFmtDXT5_AGBR:   return CRND_FOURCC('A', 'G', 'B', 'R');
         case cCRNFmtETC1:        return CRND_FOURCC('E', 'T', 'C', '1');
         default: break;
      }
      CRND_ASSERT(false);
      return 0;
   }

   crn_format crnd_get_fundamental_dxt_format(crn_format fmt)
   {
      switch (fmt)
      {
         case cCRNFmtDXT5_CCxY:
         case cCRNFmtDXT5_xGxR:
         case cCRNFmtDXT5_xGBR:
         case cCRNFmtDXT5_AGBR:
            return cCRNFmtDXT5;
         default: break;
      }
      return fmt;
   }

   uint32 crnd_get_crn_format_bits_per_texel(crn_format fmt)
   {
      switch (fmt)
      {
         case cCRNFmtDXT1:
         case cCRNFmtDXT5A:
         case cCRNFmtETC1:
            return 4;
         case cCRNFmtDXT3:
         case cCRNFmtDXT5:
         case cCRNFmtDXN_XY:
         case cCRNFmtDXN_YX:
         case cCRNFmtDXT5_CCxY:
         case cCRNFmtDXT5_xGxR:
         case cCRNFmtDXT5_xGBR:
         case cCRNFmtDXT5_AGBR:
            return 8;
         default: break;
      }
      CRND_ASSERT(false);
      return 0;
   }

   uint32 crnd_get_bytes_per_dxt_block(crn_format fmt)
   {
      return (crnd_get_crn_format_bits_per_texel(fmt) << 4) >> 3;
   }

   // TODO: tmp_header isn't used/This function is a helper to support old headers.
   const crn_header* crnd_get_header(crn_header& tmp_header, const void* pData, uint32 data_size)
   {
      tmp_header;

      if ((!pData) || (data_size < sizeof(crn_header)))
         return NULL;

      const crn_header& file_header = *static_cast<const crn_header*>(pData);
      if (file_header.m_sig != crn_header::cCRNSigValue)
         return NULL;

      if ((file_header.m_header_size < sizeof(crn_header)) || (data_size < file_header.m_data_size))
         return NULL;

      return &file_header;
   }

   bool crnd_validate_file(const void* pData, uint32 data_size, crn_file_info* pFile_info)
   {
      if (pFile_info)
      {
         if (pFile_info->m_struct_size != sizeof(crn_file_info))
            return false;

         memset(&pFile_info->m_struct_size + 1, 0, sizeof(crn_file_info) - sizeof(pFile_info->m_struct_size));
      }

      if ((!pData) || (data_size < cCRNHeaderMinSize))
         return false;

      crn_header tmp_header;
      const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
      if (!pHeader)
         return false;

      const uint32 header_crc = crc16(&pHeader->m_data_size, (uint32)(pHeader->m_header_size - ((const uint8*)&pHeader->m_data_size - (const uint8*)pHeader)));
      if (header_crc != pHeader->m_header_crc16)
         return false;

      const uint32 data_crc = crc16((const uint8*)pData + pHeader->m_header_size, pHeader->m_data_size - pHeader->m_header_size);
      if (data_crc != pHeader->m_data_crc16)
         return false;

      if ((pHeader->m_faces != 1) && (pHeader->m_faces != 6))
         return false;
      if ((pHeader->m_width < 1) || (pHeader->m_width > cCRNMaxLevelResolution))
         return false;
      if ((pHeader->m_height < 1) || (pHeader->m_height > cCRNMaxLevelResolution))
         return false;
      if ((pHeader->m_levels < 1) || (pHeader->m_levels > utils::compute_max_mips(pHeader->m_width, pHeader->m_height)))
         return false;
      if (((int)pHeader->m_format < cCRNFmtDXT1) || ((int)pHeader->m_format >= cCRNFmtTotal))
         return false;

      if (pFile_info)
      {
         pFile_info->m_actual_data_size = pHeader->m_data_size;
         pFile_info->m_header_size = pHeader->m_header_size;
         pFile_info->m_total_palette_size = pHeader->m_color_endpoints.m_size + pHeader->m_color_selectors.m_size + pHeader->m_alpha_endpoints.m_size + pHeader->m_alpha_selectors.m_size;
         pFile_info->m_tables_size = pHeader->m_tables_size;

         pFile_info->m_levels = pHeader->m_levels;

         for (uint32 i = 0; i < pHeader->m_levels; i++)
         {
            uint32 next_ofs = pHeader->m_data_size;

            // assumes the levels are packed together sequentially
            if ((i + 1) < pHeader->m_levels)
               next_ofs = pHeader->m_level_ofs[i + 1];

            pFile_info->m_level_compressed_size[i] = next_ofs - pHeader->m_level_ofs[i];
         }

         pFile_info->m_color_endpoint_palette_entries = pHeader->m_color_endpoints.m_num;
         pFile_info->m_color_selector_palette_entries = pHeader->m_color_selectors.m_num;;
         pFile_info->m_alpha_endpoint_palette_entries = pHeader->m_alpha_endpoints.m_num;;
         pFile_info->m_alpha_selector_palette_entries = pHeader->m_alpha_selectors.m_num;;
      }

      return true;
   }

   bool crnd_get_texture_info(const void* pData, uint32 data_size, crn_texture_info* pInfo)
   {
      if ((!pData) || (data_size < sizeof(crn_header)) || (!pInfo))
         return false;

      if (pInfo->m_struct_size != sizeof(crn_texture_info))
         return false;

      crn_header tmp_header;
      const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
      if (!pHeader)
         return false;

      pInfo->m_width = pHeader->m_width;
      pInfo->m_height = pHeader->m_height;
      pInfo->m_levels = pHeader->m_levels;
      pInfo->m_faces = pHeader->m_faces;
      pInfo->m_format = static_cast<crn_format>((uint32)pHeader->m_format);
      pInfo->m_bytes_per_block = ((pHeader->m_format == cCRNFmtDXT1) || (pHeader->m_format == cCRNFmtDXT5A)) ? 8 : 16;
      pInfo->m_userdata0 = pHeader->m_userdata0;
      pInfo->m_userdata1 = pHeader->m_userdata1;

      return true;
   }

   bool crnd_get_level_info(const void* pData, uint32 data_size, uint32 level_index, crn_level_info* pLevel_info)
   {
      if ((!pData) || (data_size < cCRNHeaderMinSize) || (!pLevel_info))
         return false;

      if (pLevel_info->m_struct_size != sizeof(crn_level_info))
         return false;

      crn_header tmp_header;
      const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
      if (!pHeader)
         return false;

      if (level_index >= pHeader->m_levels)
         return false;

      uint32 width = math::maximum<uint32>(1U, pHeader->m_width >> level_index);
      uint32 height = math::maximum<uint32>(1U, pHeader->m_height >> level_index);

      pLevel_info->m_width = width;
      pLevel_info->m_height = height;
      pLevel_info->m_faces = pHeader->m_faces;
      pLevel_info->m_blocks_x = (width + 3) >> 2;
      pLevel_info->m_blocks_y = (height + 3) >> 2;
      pLevel_info->m_bytes_per_block = ((pHeader->m_format == cCRNFmtDXT1) || (pHeader->m_format == cCRNFmtDXT5A)) ? 8 : 16;
      pLevel_info->m_format = static_cast<crn_format>((uint32)pHeader->m_format);

      return true;
   }

   const void* crnd_get_level_data(const void* pData, uint32 data_size, uint32 level_index, uint32* pSize)
   {
      if (pSize)
         *pSize = 0;

      if ((!pData) || (data_size < cCRNHeaderMinSize))
         return NULL;

      crn_header tmp_header;
      const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
      if (!pHeader)
         return NULL;

      if (level_index >= pHeader->m_levels)
         return NULL;

      uint32 cur_level_ofs = pHeader->m_level_ofs[level_index];

      if (pSize)
      {
         uint32 next_level_ofs = data_size;
         if ((level_index + 1) < (pHeader->m_levels))
            next_level_ofs = pHeader->m_level_ofs[level_index + 1];

         *pSize = next_level_ofs - cur_level_ofs;
      }

      return static_cast<const uint8*>(pData) + cur_level_ofs;
   }

   uint32 crnd_get_segmented_file_size(const void* pData, uint32 data_size)
   {
      if ((!pData) || (data_size < cCRNHeaderMinSize))
         return false;

      crn_header tmp_header;
      const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
      if (!pHeader)
         return false;

      uint32 size = pHeader->m_header_size;

      size = math::maximum(size, pHeader->m_color_endpoints.m_ofs + pHeader->m_color_endpoints.m_size);
      size = math::maximum(size, pHeader->m_color_selectors.m_ofs + pHeader->m_color_selectors.m_size);
      size = math::maximum(size, pHeader->m_alpha_endpoints.m_ofs + pHeader->m_alpha_endpoints.m_size);
      size = math::maximum(size, pHeader->m_alpha_selectors.m_ofs + pHeader->m_alpha_selectors.m_size);
      size = math::maximum(size, pHeader->m_tables_ofs + pHeader->m_tables_size);

      return size;
   }

   bool crnd_create_segmented_file(const void* pData, uint32 data_size, void* pBase_data, uint base_data_size)
   {
      if ((!pData) || (data_size < cCRNHeaderMinSize))
         return false;

      crn_header tmp_header;
      const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
      if (!pHeader)
         return false;

      if (pHeader->m_flags & cCRNHeaderFlagSegmented)
         return false;

      const uint actual_base_data_size = crnd_get_segmented_file_size(pData, data_size);
      if (base_data_size < actual_base_data_size)
         return false;

      memcpy(pBase_data, pData, actual_base_data_size);

      crn_header& new_header = *static_cast<crn_header*>(pBase_data);
      new_header.m_flags = new_header.m_flags | cCRNHeaderFlagSegmented;
      new_header.m_data_size = actual_base_data_size;

      new_header.m_data_crc16 = crc16((const uint8*)pBase_data + new_header.m_header_size, new_header.m_data_size - new_header.m_header_size);

      new_header.m_header_crc16 = crc16(&new_header.m_data_size, new_header.m_header_size - (uint32)((const uint8*)&new_header.m_data_size - (const uint8*)&new_header));

      CRND_ASSERT(crnd_validate_file(&new_header, actual_base_data_size, NULL));

      return true;
   }

} // namespace crnd

// File: symbol_codec.cpp
namespace crnd
{
   static_huffman_data_model::static_huffman_data_model() :
m_total_syms(0),
m_pDecode_tables(NULL)
{
}

static_huffman_data_model::static_huffman_data_model(const static_huffman_data_model& other) :
m_total_syms(0),
m_pDecode_tables(NULL)
{
   *this = other;
}

static_huffman_data_model::~static_huffman_data_model()
{
   if (m_pDecode_tables)
      crnd_delete(m_pDecode_tables);
}

static_huffman_data_model& static_huffman_data_model::operator=(const static_huffman_data_model& rhs)
{
   if (this == &rhs)
      return *this;

   m_total_syms = rhs.m_total_syms;
   m_code_sizes = rhs.m_code_sizes;
   if (m_code_sizes.get_alloc_failed())
   {
      clear();
      return *this;
   }

   if (rhs.m_pDecode_tables)
   {
      if (m_pDecode_tables)
         *m_pDecode_tables = *rhs.m_pDecode_tables;
      else
         m_pDecode_tables = crnd_new<prefix_coding::decoder_tables>(*rhs.m_pDecode_tables);
   }
   else
   {
      crnd_delete(m_pDecode_tables);
      m_pDecode_tables = NULL;
   }

   return *this;
}

void static_huffman_data_model::clear()
{
   m_total_syms = 0;
   m_code_sizes.clear();
   if (m_pDecode_tables)
   {
      crnd_delete(m_pDecode_tables);
      m_pDecode_tables = NULL;
   }
}

bool static_huffman_data_model::init(uint32 total_syms, const uint8* pCode_sizes, uint32 code_size_limit)
{
   CRND_ASSERT((total_syms >= 1) && (total_syms <= prefix_coding::cMaxSupportedSyms) && (code_size_limit >= 1));

   code_size_limit = math::minimum(code_size_limit, prefix_coding::cMaxExpectedCodeSize);

   if (!m_code_sizes.resize(total_syms))
      return false;

   uint32 min_code_size = cUINT32_MAX;
   uint32 max_code_size = 0;

   for (uint32 i = 0; i < total_syms; i++)
   {
      uint32 s = pCode_sizes[i];
      m_code_sizes[i] = static_cast<uint8>(s);
      min_code_size = math::minimum(min_code_size, s);
      max_code_size = math::maximum(max_code_size, s);
   }

   if ((max_code_size < 1) || (max_code_size > 32) || (min_code_size > code_size_limit))
      return false;

   if (max_code_size > code_size_limit)
      return false;

   if (!m_pDecode_tables)
      m_pDecode_tables = crnd_new<prefix_coding::decoder_tables>();

   if (!m_pDecode_tables->init(m_total_syms, &m_code_sizes[0], compute_decoder_table_bits()))
      return false;

   return true;
}

bool static_huffman_data_model::prepare_decoder_tables()
{
   uint32 total_syms = m_code_sizes.size();

   CRND_ASSERT((total_syms >= 1) && (total_syms <= prefix_coding::cMaxSupportedSyms));

   m_total_syms = total_syms;

   if (!m_pDecode_tables)
      m_pDecode_tables = crnd_new<prefix_coding::decoder_tables>();

   return m_pDecode_tables->init(m_total_syms, &m_code_sizes[0], compute_decoder_table_bits());
}

uint static_huffman_data_model::compute_decoder_table_bits() const
{
#if CRND_PREFIX_CODING_USE_FIXED_TABLE_SIZE
   return prefix_coding::cMaxTableBits;
#else
   uint32 decoder_table_bits = 0;
   if (m_total_syms > 16)
      decoder_table_bits = static_cast<uint8>(math::minimum(1 + math::ceil_log2i(m_total_syms), prefix_coding::cMaxTableBits));
   return decoder_table_bits;
#endif
}

symbol_codec::symbol_codec() :
  m_pDecode_buf(NULL),
  m_pDecode_buf_next(NULL),
  m_pDecode_buf_end(NULL),
  m_decode_buf_size(0),
  m_bit_buf(0),
  m_bit_count(0)
{
}

// Code length encoding symbols:
// 0-16 - actual code lengths
const uint32 cMaxCodelengthCodes      = 21;

const uint32 cSmallZeroRunCode        = 17;
const uint32 cLargeZeroRunCode        = 18;
const uint32 cSmallRepeatCode         = 19;
const uint32 cLargeRepeatCode         = 20;

const uint32 cMinSmallZeroRunSize     = 3;
const uint32 cMaxSmallZeroRunSize     = 10;
const uint32 cMinLargeZeroRunSize     = 11;
const uint32 cMaxLargeZeroRunSize     = 138;

const uint32 cSmallMinNonZeroRunSize  = 3;
const uint32 cSmallMaxNonZeroRunSize  = 6;
const uint32 cLargeMinNonZeroRunSize  = 7;
const uint32 cLargeMaxNonZeroRunSize  = 70;

const uint32 cSmallZeroRunExtraBits   = 3;
const uint32 cLargeZeroRunExtraBits   = 7;
const uint32 cSmallNonZeroRunExtraBits = 2;
const uint32 cLargeNonZeroRunExtraBits = 6;

static const uint8 g_most_probable_codelength_codes[] =
{
   cSmallZeroRunCode, cLargeZeroRunCode,
   cSmallRepeatCode,  cLargeRepeatCode,

   0, 8,
   7, 9,
   6, 10,
   5, 11,
   4, 12,
   3, 13,
   2, 14,
   1, 15,
   16
};
const uint32 cNumMostProbableCodelengthCodes = sizeof(g_most_probable_codelength_codes) / sizeof(g_most_probable_codelength_codes[0]);

bool symbol_codec::decode_receive_static_data_model(static_huffman_data_model& model)
{
   const uint32 total_used_syms = decode_bits(math::total_bits(prefix_coding::cMaxSupportedSyms));

   if (!total_used_syms)
   {
      model.clear();
      return true;
   }

   if (!model.m_code_sizes.resize(total_used_syms))
      return false;

   memset(&model.m_code_sizes[0], 0, sizeof(model.m_code_sizes[0]) * total_used_syms);

   const uint32 num_codelength_codes_to_send = decode_bits(5);
   if ((num_codelength_codes_to_send < 1) || (num_codelength_codes_to_send > cMaxCodelengthCodes))
      return false;

   static_huffman_data_model dm;
   if (!dm.m_code_sizes.resize(cMaxCodelengthCodes))
      return false;

   for (uint32 i = 0; i < num_codelength_codes_to_send; i++)
      dm.m_code_sizes[g_most_probable_codelength_codes[i]] = static_cast<uint8>(decode_bits(3));

   if (!dm.prepare_decoder_tables())
      return false;

   uint32 ofs = 0;
   while (ofs < total_used_syms)
   {
      const uint32 num_remaining = total_used_syms - ofs;

      uint32 code = decode(dm);
      if (code <= 16)
         model.m_code_sizes[ofs++] = static_cast<uint8>(code);
      else if (code == cSmallZeroRunCode)
      {
         uint32 len = decode_bits(cSmallZeroRunExtraBits) + cMinSmallZeroRunSize;
         if (len > num_remaining)
            return false;
         ofs += len;
      }
      else if (code == cLargeZeroRunCode)
      {
         uint32 len = decode_bits(cLargeZeroRunExtraBits) + cMinLargeZeroRunSize;
         if (len > num_remaining)
            return false;
         ofs += len;
      }
      else if ((code == cSmallRepeatCode) || (code == cLargeRepeatCode))
      {
         uint32 len;
         if (code == cSmallRepeatCode)
            len = decode_bits(cSmallNonZeroRunExtraBits) + cSmallMinNonZeroRunSize;
         else
            len = decode_bits(cLargeNonZeroRunExtraBits) + cLargeMinNonZeroRunSize;

         if ((!ofs) || (len > num_remaining))
            return false;
         const uint32 prev = model.m_code_sizes[ofs - 1];
         if (!prev)
            return false;
         const uint32 end = ofs + len;
         while (ofs < end)
            model.m_code_sizes[ofs++] = static_cast<uint8>(prev);
      }
      else
      {
         CRND_ASSERT(0);
         return false;
      }
   }

   if (ofs != total_used_syms)
      return false;

   return model.prepare_decoder_tables();
}

bool symbol_codec::start_decoding(const uint8* pBuf, uint32 buf_size)
{
   if (!buf_size)
      return false;

   m_pDecode_buf = pBuf;
   m_pDecode_buf_next = pBuf;
   m_decode_buf_size = buf_size;
   m_pDecode_buf_end = pBuf + buf_size;

   get_bits_init();

   return true;
}

void symbol_codec::get_bits_init()
{
   m_bit_buf = 0;
   m_bit_count = 0;
}

uint32 symbol_codec::decode_bits(uint32 num_bits)
{
   if (!num_bits)
      return 0;

   if (num_bits > 16)
   {
      uint32 a = get_bits(num_bits - 16);
      uint32 b = get_bits(16);

      return (a << 16) | b;
   }
   else
      return get_bits(num_bits);
}

uint32 symbol_codec::get_bits(uint32 num_bits)
{
   CRND_ASSERT(num_bits <= 32U);

   while (m_bit_count < (int)num_bits)
   {
      bit_buf_type c = 0;
      if (m_pDecode_buf_next != m_pDecode_buf_end)
         c = *m_pDecode_buf_next++;

      m_bit_count += 8;
      CRND_ASSERT(m_bit_count <= cBitBufSize);

      m_bit_buf |= (c << (cBitBufSize - m_bit_count));
   }

   uint32 result = static_cast<uint32>(m_bit_buf >> (cBitBufSize - num_bits));

   m_bit_buf <<= num_bits;
   m_bit_count -= num_bits;

   return result;
}

uint32 symbol_codec::decode(const static_huffman_data_model& model)
{
   const prefix_coding::decoder_tables* pTables = model.m_pDecode_tables;

   if (m_bit_count < 24)
   {
      if (m_bit_count < 16)
      {
         uint32 c0 = 0, c1 = 0;
         const uint8* p = m_pDecode_buf_next;
         if (p < m_pDecode_buf_end) c0 = *p++;
         if (p < m_pDecode_buf_end) c1 = *p++;
         m_pDecode_buf_next = p;
         m_bit_count += 16;
         uint32 c = (c0 << 8) | c1;
         m_bit_buf |= (c << (32 - m_bit_count));
      }
      else
      {
         uint32 c = (m_pDecode_buf_next < m_pDecode_buf_end) ? *m_pDecode_buf_next++ : 0;
         m_bit_count += 8;
         m_bit_buf |= (c << (32 - m_bit_count));
      }
   }

   uint32 k = (m_bit_buf >> 16) + 1;
   uint32 sym, len;

   if (k <= pTables->m_table_max_code)
   {
      uint32 t = pTables->m_lookup[m_bit_buf >> (32 - pTables->m_table_bits)];

      CRND_ASSERT(t != cUINT32_MAX);
      sym = t & cUINT16_MAX;
      len = t >> 16;

      CRND_ASSERT(model.m_code_sizes[sym] == len);
   }
   else
   {
      len = pTables->m_decode_start_code_size;

      for ( ; ; )
      {
         if (k <= pTables->m_max_codes[len - 1])
            break;
         len++;
      }

      int val_ptr = pTables->m_val_ptrs[len - 1] + (m_bit_buf >> (32 - len));

      if (((uint32)val_ptr >= model.m_total_syms))
      {
         // corrupted stream, or a bug
         CRND_ASSERT(0);
         return 0;
      }

      sym = pTables->m_sorted_symbol_order[val_ptr];
   }

   m_bit_buf <<= len;
   m_bit_count -= len;

   return sym;
}

   uint64 symbol_codec::stop_decoding()
   {
#if 0
      uint32 i = get_bits(4);
      uint32 k = get_bits(3);
      i, k;
      CRND_ASSERT((i == 15) && (k == 3));
#endif

      uint64 n = static_cast<uint64>(m_pDecode_buf_next - m_pDecode_buf);

      return n;
   }

} // namespace crnd

// File: crnd_dxt_hc_common.cpp
namespace crnd
{
   chunk_encoding_desc g_chunk_encodings[cNumChunkEncodings] =
   {
      { 1, { { 0, 0, 8, 8, 0 } } },

      { 2, { { 0, 0, 8, 4, 1 }, { 0, 4, 8, 4, 2 } } },
      { 2, { { 0, 0, 4, 8, 3 }, { 4, 0, 4, 8, 4 } } },

      { 3, { { 0, 0, 8, 4, 1 }, { 0, 4, 4, 4, 7 }, { 4, 4, 4, 4, 8 } } },
      { 3, { { 0, 4, 8, 4, 2 }, { 0, 0, 4, 4, 5 }, { 4, 0, 4, 4, 6 } } },

      { 3, { { 0, 0, 4, 8, 3 }, { 4, 0, 4, 4, 6 }, { 4, 4, 4, 4, 8 } } },
      { 3, { { 4, 0, 4, 8, 4 }, { 0, 0, 4, 4, 5 }, { 0, 4, 4, 4, 7 } } },

      { 4, { { 0, 0, 4, 4, 5 }, { 4, 0, 4, 4, 6 }, { 0, 4, 4, 4, 7 }, { 4, 4, 4, 4, 8 } } }
   };

   chunk_tile_desc g_chunk_tile_layouts[cNumChunkTileLayouts] =
   {
      // 2x2
      { 0, 0, 8, 8, 0 },

      // 2x1
      { 0, 0, 8, 4, 1 },
      { 0, 4, 8, 4, 2 },

      // 1x2
      { 0, 0, 4, 8, 3 },
      { 4, 0, 4, 8, 4 },

      // 1x1
      { 0, 0, 4, 4, 5 },
      { 4, 0, 4, 4, 6 },
      { 0, 4, 4, 4, 7 },
      { 4, 4, 4, 4, 8 }
   };

} // namespace crnd

// File: crnd_dxt.cpp
namespace crnd
{
   const uint8 g_dxt1_to_linear[cDXT1SelectorValues]     = { 0U, 3U, 1U, 2U };
   const uint8 g_dxt1_from_linear[cDXT1SelectorValues]   = { 0U, 2U, 3U, 1U };

   const uint8 g_dxt5_to_linear[cDXT5SelectorValues]     = { 0U, 7U, 1U, 2U, 3U, 4U, 5U, 6U };
   const uint8 g_dxt5_from_linear[cDXT5SelectorValues]   = { 0U, 2U, 3U, 4U, 5U, 6U, 7U, 1U };

   const uint8 g_six_alpha_invert_table[cDXT5SelectorValues] = { 1, 0, 5, 4, 3, 2, 6, 7 };
   const uint8 g_eight_alpha_invert_table[cDXT5SelectorValues] = { 1, 0, 7, 6, 5, 4, 3, 2 };

   uint16 dxt1_block::pack_color(const color_quad_u8& color, bool scaled, uint32 bias)
   {
      uint32 r = color.r;
      uint32 g = color.g;
      uint32 b = color.b;

      if (scaled)
      {
         r = (r * 31U + bias) / 255U;
         g = (g * 63U + bias) / 255U;
         b = (b * 31U + bias) / 255U;
      }

      r = math::minimum(r, 31U);
      g = math::minimum(g, 63U);
      b = math::minimum(b, 31U);

      return static_cast<uint16>(b | (g << 5U) | (r << 11U));
   }

   uint16 dxt1_block::pack_color(uint32 r, uint32 g, uint32 b, bool scaled, uint32 bias)
   {
      return pack_color(color_quad_u8(r, g, b, 0), scaled, bias);
   }

   color_quad_u8 dxt1_block::unpack_color(uint16 packed_color, bool scaled, uint32 alpha)
   {
      uint32 b = packed_color & 31U;
      uint32 g = (packed_color >> 5U) & 63U;
      uint32 r = (packed_color >> 11U) & 31U;

      if (scaled)
      {
         b = (b << 3U) | (b >> 2U);
         g = (g << 2U) | (g >> 4U);
         r = (r << 3U) | (r >> 2U);
      }

      return color_quad_u8(r, g, b, alpha);
   }

   void dxt1_block::unpack_color(uint32& r, uint32& g, uint32& b, uint16 packed_color, bool scaled)
   {
      color_quad_u8 c(unpack_color(packed_color, scaled, 0));
      r = c.r;
      g = c.g;
      b = c.b;
   }

   uint32 dxt1_block::get_block_colors3(color_quad_u8* pDst, uint16 color0, uint16 color1)
   {
      color_quad_u8 c0(unpack_color(color0, true));
      color_quad_u8 c1(unpack_color(color1, true));

      pDst[0] = c0;
      pDst[1] = c1;
      pDst[2].set( (c0.r + c1.r) >> 1U, (c0.g + c1.g) >> 1U, (c0.b + c1.b) >> 1U, 255U);
      pDst[3].set(0, 0, 0, 0);

      return 3;
   }

   uint32 dxt1_block::get_block_colors4(color_quad_u8* pDst, uint16 color0, uint16 color1)
   {
      color_quad_u8 c0(unpack_color(color0, true));
      color_quad_u8 c1(unpack_color(color1, true));

      pDst[0] = c0;
      pDst[1] = c1;

      // 12/14/09 - Supposed to round according to DX docs, but this conflicts with the OpenGL S3TC spec. ?
      // Turns out some GPU's round and some don't. Great.
      //pDst[2].set( (c0.r * 2 + c1.r + 1) / 3, (c0.g * 2 + c1.g + 1) / 3, (c0.b * 2 + c1.b + 1) / 3, 255U);
      //pDst[3].set( (c1.r * 2 + c0.r + 1) / 3, (c1.g * 2 + c0.g + 1) / 3, (c1.b * 2 + c0.b + 1) / 3, 255U);

      pDst[2].set( (c0.r * 2 + c1.r) / 3, (c0.g * 2 + c1.g) / 3, (c0.b * 2 + c1.b) / 3, 255U);
      pDst[3].set( (c1.r * 2 + c0.r) / 3, (c1.g * 2 + c0.g) / 3, (c1.b * 2 + c0.b) / 3, 255U);

      return 4;
   }

   uint32 dxt1_block::get_block_colors(color_quad_u8* pDst, uint16 color0, uint16 color1)
   {
      if (color0 > color1)
         return get_block_colors4(pDst, color0, color1);
      else
         return get_block_colors3(pDst, color0, color1);
   }

   color_quad_u8 dxt1_block::unpack_endpoint(uint32 endpoints, uint32 index, bool scaled, uint32 alpha)
   {
      CRND_ASSERT(index < 2);
      return unpack_color( static_cast<uint16>((endpoints >> (index * 16U)) & 0xFFFFU), scaled, alpha );
   }

   uint32 dxt1_block::pack_endpoints(uint32 lo, uint32 hi)
   {
      CRND_ASSERT((lo <= 0xFFFFU) && (hi <= 0xFFFFU));
      return lo | (hi << 16U);
   }

   void dxt3_block::set_alpha(uint32 x, uint32 y, uint32 value, bool scaled)
   {
      CRND_ASSERT((x < cDXTBlockSize) && (y < cDXTBlockSize));

      if (scaled)
      {
         CRND_ASSERT(value <= 0xFF);
         value = (value * 15U + 128U) / 255U;
      }
      else
      {
         CRND_ASSERT(value <= 0xF);
      }

      uint32 ofs = (y << 1U) + (x >> 1U);
      uint32 c = m_alpha[ofs];

      c &= ~(0xF << ((x & 1U) << 2U));
      c |= (value << ((x & 1U) << 2U));

      m_alpha[ofs] = static_cast<uint8>(c);
   }

   uint32 dxt3_block::get_alpha(uint32 x, uint32 y, bool scaled) const
   {
      CRND_ASSERT((x < cDXTBlockSize) && (y < cDXTBlockSize));

      uint32 value = m_alpha[(y << 1U) + (x >> 1U)];
      if (x & 1)
         value >>= 4;
      value &= 0xF;

      if (scaled)
         value = (value << 4U) | value;

      return value;
   }

   uint32 dxt5_block::get_block_values6(color_quad_u8* pDst, uint32 l, uint32 h)
   {
      pDst[0].a = static_cast<uint8>(l);
      pDst[1].a = static_cast<uint8>(h);
      pDst[2].a = static_cast<uint8>((l * 4 + h    ) / 5);
      pDst[3].a = static_cast<uint8>((l * 3 + h * 2) / 5);
      pDst[4].a = static_cast<uint8>((l * 2 + h * 3) / 5);
      pDst[5].a = static_cast<uint8>((l     + h * 4) / 5);
      pDst[6].a = 0;
      pDst[7].a = 255;
      return 6;
   }

   uint32 dxt5_block::get_block_values8(color_quad_u8* pDst, uint32 l, uint32 h)
   {
      pDst[0].a = static_cast<uint8>(l);
      pDst[1].a = static_cast<uint8>(h);
      pDst[2].a = static_cast<uint8>((l * 6 + h    ) / 7);
      pDst[3].a = static_cast<uint8>((l * 5 + h * 2) / 7);
      pDst[4].a = static_cast<uint8>((l * 4 + h * 3) / 7);
      pDst[5].a = static_cast<uint8>((l * 3 + h * 4) / 7);
      pDst[6].a = static_cast<uint8>((l * 2 + h * 5) / 7);
      pDst[7].a = static_cast<uint8>((l     + h * 6) / 7);
      return 8;
   }

   uint32 dxt5_block::get_block_values(color_quad_u8* pDst, uint32 l, uint32 h)
   {
      if (l > h)
         return get_block_values8(pDst, l, h);
      else
         return get_block_values6(pDst, l, h);
   }

   uint32 dxt5_block::get_block_values6(uint32* pDst, uint32 l, uint32 h)
   {
      pDst[0] = l;
      pDst[1] = h;
      pDst[2] = (l * 4 + h    ) / 5;
      pDst[3] = (l * 3 + h * 2) / 5;
      pDst[4] = (l * 2 + h * 3) / 5;
      pDst[5] = (l     + h * 4) / 5;
      pDst[6] = 0;
      pDst[7] = 255;
      return 6;
   }

   uint32 dxt5_block::get_block_values8(uint32* pDst, uint32 l, uint32 h)
   {
      pDst[0] = l;
      pDst[1] = h;
      pDst[2] = (l * 6 + h    ) / 7;
      pDst[3] = (l * 5 + h * 2) / 7;
      pDst[4] = (l * 4 + h * 3) / 7;
      pDst[5] = (l * 3 + h * 4) / 7;
      pDst[6] = (l * 2 + h * 5) / 7;
      pDst[7] = (l     + h * 6) / 7;
      return 8;
   }

   uint32 dxt5_block::unpack_endpoint(uint32 packed, uint32 index)
   {
      CRND_ASSERT(index < 2);
      return (packed >> (8 * index)) & 0xFF;
   }

   uint32 dxt5_block::pack_endpoints(uint32 lo, uint32 hi)
   {
      CRND_ASSERT((lo <= 0xFF) && (hi <= 0xFF));
      return lo | (hi << 8U);
   }

   uint32 dxt5_block::get_block_values(uint32* pDst, uint32 l, uint32 h)
   {
      if (l > h)
         return get_block_values8(pDst, l, h);
      else
         return get_block_values6(pDst, l, h);
   }

} // namespace crnd

// File: crnd_decode.cpp
#define CRND_CREATE_BYTE_STREAMS 0

namespace crnd
{
#if CRND_CREATE_BYTE_STREAMS
   static void write_array_to_file(const char* pFilename, const vector<uint8>& buf)
   {
      FILE* pFile = fopen(pFilename, "wb");
      fwrite(&buf[0], buf.size(), 1, pFile);
      fclose(pFile);
   }
#endif

   struct crnd_chunk_tile_desc
   {
      // These values are in blocks
      uint8 m_x_ofs;
      uint8 m_y_ofs;
      uint8 m_width;
      uint8 m_height;
   };

   struct crnd_chunk_encoding_desc
   {
      uint32 m_num_tiles;
      chunk_tile_desc m_tiles[4];
   };

#if 0
   static crnd_chunk_encoding_desc g_crnd_chunk_encodings[cNumChunkEncodings] =
   {
      { 1, { { 0, 0, 2, 2 } } },

      { 2, { { 0, 0, 2, 1 }, { 0, 1, 2, 1 } } },
      { 2, { { 0, 0, 1, 2 }, { 1, 0, 1, 2 } } },

      { 3, { { 0, 0, 2, 1 }, { 0, 1, 1, 1 }, { 1, 1, 1, 1 } } },
      { 3, { { 0, 1, 2, 1 }, { 0, 0, 1, 1 }, { 1, 0, 1, 1 } } },

      { 3, { { 0, 0, 1, 2 }, { 1, 0, 1, 1 }, { 1, 1, 1, 1 } } },
      { 3, { { 1, 0, 1, 2 }, { 0, 0, 1, 1 }, { 0, 1, 1, 1 } } },

      { 1, { { 0, 0, 1, 1 }, { 1, 0, 1, 1 }, { 0, 1, 1, 1 }, { 1, 1, 1, 1 } } }
   };
#endif

   struct crnd_encoding_tile_indices
   {
      uint8 m_tiles[4];
   };

   static crnd_encoding_tile_indices g_crnd_chunk_encoding_tiles[cNumChunkEncodings] =
   {
      { { 0, 0, 0, 0 } },

      { { 0, 0, 1, 1 } },
      { { 0, 1, 0, 1 } },

      { { 0, 0, 1, 2 } },
      { { 1, 2, 0, 0 } },

      { { 0, 1, 0, 2 } },
      { { 1, 0, 2, 0 } },

      { { 0, 1, 2, 3 } }
   };

   static uint8 g_crnd_chunk_encoding_num_tiles[cNumChunkEncodings] = { 1, 2, 2, 3, 3, 3, 3, 4 };

   class crn_unpacker
   {
   public:
      inline crn_unpacker() :
         m_magic(cMagicValue),
         m_pData(NULL),
         m_data_size(0),
         m_pHeader(NULL)
      {
      }

      inline ~crn_unpacker()
      {
         m_magic = 0;
      }

      inline bool is_valid() const { return m_magic == cMagicValue; }

      bool init(const void* pData, uint32 data_size)
      {
         m_pHeader = crnd_get_header(m_tmp_header, pData, data_size);
         if (!m_pHeader)
            return false;

         m_pData = static_cast<const uint8*>(pData);
         m_data_size = data_size;

         if (!init_tables())
            return false;

         if (!decode_palettes())
            return false;

         return true;
      }

      bool unpack_level(
         void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
         uint32 level_index)
      {
         uint32 cur_level_ofs = m_pHeader->m_level_ofs[level_index];

         uint32 next_level_ofs = m_data_size;
         if ((level_index + 1) < (m_pHeader->m_levels))
            next_level_ofs = m_pHeader->m_level_ofs[level_index + 1];

         CRND_ASSERT(next_level_ofs > cur_level_ofs);

         return unpack_level(m_pData + cur_level_ofs, next_level_ofs - cur_level_ofs, pDst, dst_size_in_bytes, row_pitch_in_bytes, level_index);
      }

      bool unpack_level(
         const void* pSrc, uint32 src_size_in_bytes,
         void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
         uint32 level_index)
      {
         dst_size_in_bytes;

#ifdef CRND_BUILD_DEBUG
         for (uint32 f = 0; f < m_pHeader->m_faces; f++)
            if (!pDst[f])
               return false;
#endif

         const uint32 width = math::maximum(m_pHeader->m_width >> level_index, 1U);
         const uint32 height = math::maximum(m_pHeader->m_height >> level_index, 1U);
         const uint32 blocks_x = (width + 3U) >> 2U;
         const uint32 blocks_y = (height + 3U) >> 2U;
         const uint32 block_size = ((m_pHeader->m_format == cCRNFmtDXT1) || (m_pHeader->m_format == cCRNFmtDXT5A)) ? 8 : 16;

         uint32 minimal_row_pitch = block_size * blocks_x;
         if (!row_pitch_in_bytes)
            row_pitch_in_bytes = minimal_row_pitch;
         else if ((row_pitch_in_bytes < minimal_row_pitch) || (row_pitch_in_bytes & 3))
            return false;
         if (dst_size_in_bytes < row_pitch_in_bytes * blocks_y)
            return false;

         const uint32 chunks_x = (blocks_x + 1) >> 1;
         const uint32 chunks_y = (blocks_y + 1) >> 1;

#if CRND_CREATE_BYTE_STREAMS
         crnd_trace("Index stream: %u bytes\n", src_size_in_bytes);
#endif

         if (!m_codec.start_decoding(static_cast<const crnd::uint8*>(pSrc), src_size_in_bytes))
            return false;

         bool status = false;
         switch (m_pHeader->m_format)
         {
         case cCRNFmtDXT1:
            status = unpack_dxt1((uint8**)pDst, dst_size_in_bytes, row_pitch_in_bytes, blocks_x, blocks_y, chunks_x, chunks_y);
            break;
         case cCRNFmtDXT5:
         case cCRNFmtDXT5_CCxY:
         case cCRNFmtDXT5_xGBR:
         case cCRNFmtDXT5_AGBR:
         case cCRNFmtDXT5_xGxR:
            status = unpack_dxt5((uint8**)pDst, dst_size_in_bytes, row_pitch_in_bytes, blocks_x, blocks_y, chunks_x, chunks_y);
            break;
         case cCRNFmtDXT5A:
            status = unpack_dxt5a((uint8**)pDst, dst_size_in_bytes, row_pitch_in_bytes, blocks_x, blocks_y, chunks_x, chunks_y);
            break;
         case cCRNFmtDXN_XY:
         case cCRNFmtDXN_YX:
            status = unpack_dxn((uint8**)pDst, dst_size_in_bytes, row_pitch_in_bytes, blocks_x, blocks_y, chunks_x, chunks_y);
            break;
         default:
            return false;
         }
         if (!status)
            return false;

         m_codec.stop_decoding();
         return true;
      }

      inline const void* get_data() const { return m_pData; }
      inline uint32 get_data_size() const { return m_data_size; }

   private:
      enum { cMagicValue = 0x1EF9CABD };
      uint32             m_magic;

      const uint8*       m_pData;
      uint32             m_data_size;
      crn_header         m_tmp_header;
      const crn_header*  m_pHeader;

      symbol_codec       m_codec;

      static_huffman_data_model m_chunk_encoding_dm;
      static_huffman_data_model m_endpoint_delta_dm[2];
      static_huffman_data_model m_selector_delta_dm[2];

      crnd::vector<uint32> m_color_endpoints;
      crnd::vector<uint32> m_color_selectors;

      crnd::vector<uint16> m_alpha_endpoints;
      crnd::vector<uint16> m_alpha_selectors;

      bool init_tables()
      {
         if (!m_codec.start_decoding(m_pData + m_pHeader->m_tables_ofs, m_pHeader->m_tables_size))
            return false;

         if (!m_codec.decode_receive_static_data_model(m_chunk_encoding_dm))
            return false;

         if ((!m_pHeader->m_color_endpoints.m_num) && (!m_pHeader->m_alpha_endpoints.m_num))
            return false;

         if (m_pHeader->m_color_endpoints.m_num)
         {
            if (!m_codec.decode_receive_static_data_model(m_endpoint_delta_dm[0])) return false;
            if (!m_codec.decode_receive_static_data_model(m_selector_delta_dm[0])) return false;
         }

         if (m_pHeader->m_alpha_endpoints.m_num)
         {
            if (!m_codec.decode_receive_static_data_model(m_endpoint_delta_dm[1])) return false;
            if (!m_codec.decode_receive_static_data_model(m_selector_delta_dm[1])) return false;
         }

         m_codec.stop_decoding();

         return true;
      }

      bool decode_palettes()
      {
         if (m_pHeader->m_color_endpoints.m_num)
         {
            if (!decode_color_endpoints()) return false;
            if (!decode_color_selectors()) return false;
         }

         if (m_pHeader->m_alpha_endpoints.m_num)
         {
            if (!decode_alpha_endpoints()) return false;
            if (!decode_alpha_selectors()) return false;
         }

         return true;
      }

      bool decode_color_endpoints()
      {
         const uint32 num_color_endpoints = m_pHeader->m_color_endpoints.m_num;

         if (!m_color_endpoints.resize(num_color_endpoints))
            return false;

         if (!m_codec.start_decoding(m_pData + m_pHeader->m_color_endpoints.m_ofs, m_pHeader->m_color_endpoints.m_size))
            return false;

         static_huffman_data_model dm[2];
         for (uint32 i = 0; i < 2; i++)
            if (!m_codec.decode_receive_static_data_model(dm[i]))
               return false;

         uint32 a = 0, b = 0, c = 0;
         uint32 d = 0, e = 0, f = 0;

         uint32* CRND_RESTRICT pDst = &m_color_endpoints[0];

         CRND_HUFF_DECODE_BEGIN(m_codec);

#if CRND_CREATE_BYTE_STREAMS
         vector<uint8> byte_stream;
#endif

         for (uint32 i = 0; i < num_color_endpoints; i++)
         {
            uint32 da, db, dc, dd, de, df;
            CRND_HUFF_DECODE(m_codec, dm[0], da); a = (a + da) & 31;
            CRND_HUFF_DECODE(m_codec, dm[1], db); b = (b + db) & 63;
            CRND_HUFF_DECODE(m_codec, dm[0], dc); c = (c + dc) & 31;

            CRND_HUFF_DECODE(m_codec, dm[0], dd); d = (d + dd) & 31;
            CRND_HUFF_DECODE(m_codec, dm[1], de); e = (e + de) & 63;
            CRND_HUFF_DECODE(m_codec, dm[0], df); f = (f + df) & 31;

#if CRND_CREATE_BYTE_STREAMS
            byte_stream.push_back(da);
            byte_stream.push_back(db);
            byte_stream.push_back(dc);
            byte_stream.push_back(dd);
            byte_stream.push_back(de);
            byte_stream.push_back(df);
#endif

            if (c_crnd_little_endian_platform)
               *pDst++ = c | (b << 5U) | (a << 11U) | (f << 16U) | (e << 21U) | (d << 27U);
            else
               *pDst++ = f | (e << 5U) | (d << 11U) | (c << 16U) | (b << 21U) | (a << 27U);
         }

         CRND_HUFF_DECODE_END(m_codec);

         m_codec.stop_decoding();

#if CRND_CREATE_BYTE_STREAMS
         write_array_to_file(L"colorendpoints.bin", byte_stream);
         crnd_trace("color endpoints: %u\n", (uint)m_pHeader->m_color_endpoints.m_size);
#endif

         return true;
      }

      bool decode_color_selectors()
      {
         const uint32 cMaxSelectorValue = 3U;
         const uint32 cMaxUniqueSelectorDeltas = cMaxSelectorValue * 2U + 1U;

         const uint32 num_color_selectors = m_pHeader->m_color_selectors.m_num;

         if (!m_codec.start_decoding(m_pData + m_pHeader->m_color_selectors.m_ofs, m_pHeader->m_color_selectors.m_size))
            return false;

         static_huffman_data_model dm;
         if (!m_codec.decode_receive_static_data_model(dm))
            return false;

         int32 delta0[cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas];
         int32 delta1[cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas];
         int32 l = -(int32)cMaxSelectorValue, m = -(int32)cMaxSelectorValue;
         for (uint32 i = 0; i < (cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas); i++)
         {
            delta0[i] = l;
            delta1[i] = m;

            if (++l > (int32)cMaxSelectorValue)
            {
               l = -(int32)cMaxSelectorValue;
               m++;
            }
         }

         uint32 cur[16];
         utils::zero_object(cur);

         if (!m_color_selectors.resize(num_color_selectors))
            return false;

         uint32* CRND_RESTRICT pDst = &m_color_selectors[0];

         const uint8* pFrom_linear = g_dxt1_from_linear;

         CRND_HUFF_DECODE_BEGIN(m_codec);

#if CRND_CREATE_BYTE_STREAMS
         vector<uint8> byte_stream;
#endif

         for (uint32 i = 0; i < num_color_selectors; i++)
         {
            for (uint32 j = 0; j < 8; j++)
            {
               int32 sym;
               CRND_HUFF_DECODE(m_codec, dm, sym);

#if CRND_CREATE_BYTE_STREAMS
               byte_stream.push_back(sym);
#endif

               cur[j*2+0] = (delta0[sym] + cur[j*2+0]) & 3;
               cur[j*2+1] = (delta1[sym] + cur[j*2+1]) & 3;
            }

            if (c_crnd_little_endian_platform)
            {
               *pDst++ =
                  (pFrom_linear[cur[0 ]]      ) | (pFrom_linear[cur[1 ]] <<  2) | (pFrom_linear[cur[2 ]] <<  4) | (pFrom_linear[cur[3 ]] <<  6) |
                  (pFrom_linear[cur[4 ]] <<  8) | (pFrom_linear[cur[5 ]] << 10) | (pFrom_linear[cur[6 ]] << 12) | (pFrom_linear[cur[7 ]] << 14) |
                  (pFrom_linear[cur[8 ]] << 16) | (pFrom_linear[cur[9 ]] << 18) | (pFrom_linear[cur[10]] << 20) | (pFrom_linear[cur[11]] << 22) |
                  (pFrom_linear[cur[12]] << 24) | (pFrom_linear[cur[13]] << 26) | (pFrom_linear[cur[14]] << 28) | (pFrom_linear[cur[15]] << 30);
            }
            else
            {
               *pDst++ =
                  (pFrom_linear[cur[8 ]]      ) | (pFrom_linear[cur[9 ]] <<  2) | (pFrom_linear[cur[10]] <<  4) | (pFrom_linear[cur[11]] <<  6) |
                  (pFrom_linear[cur[12]] <<  8) | (pFrom_linear[cur[13]] << 10) | (pFrom_linear[cur[14]] << 12) | (pFrom_linear[cur[15]] << 14) |
                  (pFrom_linear[cur[0 ]] << 16) | (pFrom_linear[cur[1 ]] << 18) | (pFrom_linear[cur[2 ]] << 20) | (pFrom_linear[cur[3 ]] << 22) |
                  (pFrom_linear[cur[4 ]] << 24) | (pFrom_linear[cur[5 ]] << 26) | (pFrom_linear[cur[6 ]] << 28) | (pFrom_linear[cur[7 ]] << 30);
            }
         }

         CRND_HUFF_DECODE_END(m_codec);

         m_codec.stop_decoding();

#if CRND_CREATE_BYTE_STREAMS
         write_array_to_file(L"colorselectors.bin", byte_stream);
         crnd_trace("color selectors: %u\n", (uint)m_pHeader->m_color_selectors.m_size);
#endif

         return true;
      }

      bool decode_alpha_endpoints()
      {
         const uint32 num_alpha_endpoints = m_pHeader->m_alpha_endpoints.m_num;

         if (!m_codec.start_decoding(m_pData + m_pHeader->m_alpha_endpoints.m_ofs, m_pHeader->m_alpha_endpoints.m_size))
            return false;

         static_huffman_data_model dm;
         if (!m_codec.decode_receive_static_data_model(dm))
            return false;

         if (!m_alpha_endpoints.resize(num_alpha_endpoints))
            return false;

         uint16* CRND_RESTRICT pDst = &m_alpha_endpoints[0];
         uint32 a = 0, b = 0;

         CRND_HUFF_DECODE_BEGIN(m_codec);

         for (uint32 i = 0; i < num_alpha_endpoints; i++)
         {
            uint sa; CRND_HUFF_DECODE(m_codec, dm, sa);
            uint sb; CRND_HUFF_DECODE(m_codec, dm, sb);

            a = (sa + a) & 255;
            b = (sb + b) & 255;

            *pDst++ = (uint16)(a | (b << 8));
         }

         CRND_HUFF_DECODE_END(m_codec);

         m_codec.stop_decoding();

         return true;
      }

      bool decode_alpha_selectors()
      {
         const uint32 cMaxSelectorValue = 7U;
         const uint32 cMaxUniqueSelectorDeltas = cMaxSelectorValue * 2U + 1U;

         const uint32 num_alpha_selectors = m_pHeader->m_alpha_selectors.m_num;

         if (!m_codec.start_decoding(m_pData + m_pHeader->m_alpha_selectors.m_ofs, m_pHeader->m_alpha_selectors.m_size))
            return false;

         static_huffman_data_model dm;
         if (!m_codec.decode_receive_static_data_model(dm))
            return false;

         int32 delta0[cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas];
         int32 delta1[cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas];
         int32 l = -(int32)cMaxSelectorValue, m = -(int32)cMaxSelectorValue;
         for (uint32 i = 0; i < (cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas); i++)
         {
            delta0[i] = l;
            delta1[i] = m;

            if (++l > (int32)cMaxSelectorValue)
            {
               l = -(int32)cMaxSelectorValue;
               m++;
            }
         }

         uint32 cur[16];
         utils::zero_object(cur);

         if (!m_alpha_selectors.resize(num_alpha_selectors * 3))
            return false;

         uint16* CRND_RESTRICT pDst = &m_alpha_selectors[0];

         const uint8* pFrom_linear = g_dxt5_from_linear;

         CRND_HUFF_DECODE_BEGIN(m_codec);

         for (uint32 i = 0; i < num_alpha_selectors; i++)
         {
            for (uint32 j = 0; j < 8; j++)
            {
               int32 sym;
               CRND_HUFF_DECODE(m_codec, dm, sym);

               cur[j*2+0] = (delta0[sym] + cur[j*2+0]) & 7;
               cur[j*2+1] = (delta1[sym] + cur[j*2+1]) & 7;
               //cur[j*2+0] = ((sym%15)-7 + cur[j*2+0]) & 7;
               //cur[j*2+1] = ((sym/15)-7 + cur[j*2+1]) & 7;
            }

#if 0
            dxt5_block blk;
            for (uint32 y = 0; y < 4; y++)
               for (uint32 x = 0; x < 4; x++)
                  blk.set_selector(x, y, pFrom_linear[cur[x+y*4]]);

            *pDst++ = blk.get_selectors_as_word(0);
            *pDst++ = blk.get_selectors_as_word(1);
            *pDst++ = blk.get_selectors_as_word(2);
#else
            *pDst++ = (uint16)((pFrom_linear[cur[0 ]]      ) | (pFrom_linear[cur[1 ]] <<  3) | (pFrom_linear[cur[2 ]] <<  6) | (pFrom_linear[cur[3 ]] <<  9) |
               (pFrom_linear[cur[4 ]] << 12) | (pFrom_linear[cur[5 ]] << 15));

            *pDst++ = (uint16)((pFrom_linear[cur[5 ]] >> 1) | (pFrom_linear[cur[6 ]] << 2) | (pFrom_linear[cur[7 ]] << 5) |
               (pFrom_linear[cur[8 ]] << 8) | (pFrom_linear[cur[9 ]] << 11) | (pFrom_linear[cur[10]] << 14));

            *pDst++ = (uint16)((pFrom_linear[cur[10]] >> 2) | (pFrom_linear[cur[11]] << 1) | (pFrom_linear[cur[12]] << 4) |
               (pFrom_linear[cur[13]] << 7) | (pFrom_linear[cur[14]] << 10) | (pFrom_linear[cur[15]] << 13));
#endif
         }

         CRND_HUFF_DECODE_END(m_codec);

         m_codec.stop_decoding();

         return true;
      }

      static inline uint32 tiled_offset_2d_outer(uint32 y, uint32 AlignedWidth, uint32 LogBpp)
      {
         uint32 Macro        = ((y >> 5) * (AlignedWidth >> 5)) << (LogBpp + 7);
         uint32 Micro        = ((y & 6) << 2) << LogBpp;

         return Macro +
            ((Micro & ~15) << 1) +
            (Micro & 15) +
            ((y & 8) << (3 + LogBpp)) + ((y & 1) << 4);
      }

      static inline uint32 tiled_offset_2d_inner(uint32 x, uint32 y, uint32 LogBpp, uint32 BaseOffset)
      {
         uint32 Macro = (x >> 5) << (LogBpp + 7);
         uint32 Micro = (x & 7) << LogBpp;
         uint32 Offset  = BaseOffset + Macro + ((Micro & ~15) << 1) + (Micro & 15);

         return ((Offset & ~511) << 3) + ((Offset & 448) << 2) + (Offset & 63) +
            ((y & 16) << 7) +
            (((((y & 8) >> 2) + (x >> 3)) & 3) << 6);
      }

      static inline void limit(uint& x, uint n)
      {
         int v = x - n;
         int msk = (v >> 31);
         x = (x & msk) | (v & ~msk);
      }

      bool unpack_dxt1(uint8** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes, uint32 blocks_x, uint32 blocks_y, uint32 chunks_x, uint32 chunks_y)
      {
         dst_size_in_bytes;

         uint32 chunk_encoding_bits = 1;

         const uint32 num_color_endpoints = m_color_endpoints.size();
         const uint32 num_color_selectors = m_color_selectors.size();

         uint32 prev_color_endpoint_index = 0;
         uint32 prev_color_selector_index = 0;

         const uint32 num_faces = m_pHeader->m_faces;

         const uint32 row_pitch_in_dwords = row_pitch_in_bytes >> 2U;

         const int32 cBytesPerBlock = 8;

         CRND_HUFF_DECODE_BEGIN(m_codec);

#if CRND_CREATE_BYTE_STREAMS
         vector<uint8> tile_encoding_stream;
         vector<uint8> endpoint_indices_stream;
         vector<uint8> selector_indices_stream;
#endif

         for (uint32 f = 0; f < num_faces; f++)
         {
            uint8* CRND_RESTRICT pRow = pDst[f];

            for (uint32 y = 0; y < chunks_y; y++)
            {
               int32 start_x = 0;
               int32 end_x = chunks_x;
               int32 dir_x = 1;
               int32 block_delta = cBytesPerBlock*2;
               uint8* CRND_RESTRICT pBlock = pRow;

               if (y & 1)
               {
                  start_x = chunks_x - 1;
                  end_x = -1;
                  dir_x = -1;
                  block_delta = -cBytesPerBlock*2;
                  pBlock += (chunks_x - 1) * cBytesPerBlock * 2;
               }

               const bool skip_bottom_row = (y == (chunks_y - 1)) && (blocks_y & 1);

               for (int32 x = start_x; x != end_x; x += dir_x)
               {
                  uint32 color_endpoints[4];

                  if (chunk_encoding_bits == 1)
                  {
                     CRND_HUFF_DECODE(m_codec, m_chunk_encoding_dm, chunk_encoding_bits);
#if CRND_CREATE_BYTE_STREAMS
                     tile_encoding_stream.push_back(chunk_encoding_bits & 7);
                     tile_encoding_stream.push_back((chunk_encoding_bits >> 3) & 7);
                     tile_encoding_stream.push_back((chunk_encoding_bits >> 6) & 7);
#endif
                     chunk_encoding_bits |= 512;
                  }

                  const uint32 chunk_encoding_index = chunk_encoding_bits & 7;
                  chunk_encoding_bits >>= 3;

                  const uint32 num_tiles = g_crnd_chunk_encoding_num_tiles[chunk_encoding_index];

                  for (uint32 i = 0; i < num_tiles; i++)
                  {
                     uint32 delta;
                     CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[0], delta);
#if CRND_CREATE_BYTE_STREAMS
                     endpoint_indices_stream.push_back(delta);
#endif
                     prev_color_endpoint_index += delta;
                     limit(prev_color_endpoint_index, num_color_endpoints);
                     color_endpoints[i] = m_color_endpoints[prev_color_endpoint_index];
                  }

                  const uint8* pTile_indices = g_crnd_chunk_encoding_tiles[chunk_encoding_index].m_tiles;

                  const bool skip_right_col = (blocks_x & 1) && (x == ((int32)chunks_x - 1));

                  uint32* CRND_RESTRICT pD = (uint32*)pBlock;

                  if ((!skip_bottom_row) && (!skip_right_col))
                  {
                     //CRND_ASSERT( ((uint8*)&pD[4 + row_pitch_in_dwords] - pDst) <= dst_size_in_bytes );

                     pD[0] = color_endpoints[pTile_indices[0]];
                     CRND_WRITE_BARRIER
                     uint32 delta0;
                     CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta0);
#if CRND_CREATE_BYTE_STREAMS
                     selector_indices_stream.push_back(delta0);
#endif
                     prev_color_selector_index += delta0;
                     limit(prev_color_selector_index, num_color_selectors);
                     pD[1] = m_color_selectors[prev_color_selector_index];
                     CRND_WRITE_BARRIER

                     pD[2] = color_endpoints[pTile_indices[1]];
                     CRND_WRITE_BARRIER
                     uint32 delta1;
                     CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta1);
#if CRND_CREATE_BYTE_STREAMS
                     selector_indices_stream.push_back(delta1);
#endif
                     prev_color_selector_index += delta1;
                     limit(prev_color_selector_index, num_color_selectors);
                     pD[3] = m_color_selectors[prev_color_selector_index];
                     CRND_WRITE_BARRIER

                     pD[0 + row_pitch_in_dwords] = color_endpoints[pTile_indices[2]];
                     CRND_WRITE_BARRIER
                     uint32 delta2;
                     CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta2);
#if CRND_CREATE_BYTE_STREAMS
                     selector_indices_stream.push_back(delta2);
#endif
                     prev_color_selector_index += delta2;
                     limit(prev_color_selector_index, num_color_selectors);
                     pD[1 + row_pitch_in_dwords] = m_color_selectors[prev_color_selector_index];
                     CRND_WRITE_BARRIER

                     pD[2 + row_pitch_in_dwords] = color_endpoints[pTile_indices[3]];
                     CRND_WRITE_BARRIER
                     uint32 delta3;
                     CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta3);
#if CRND_CREATE_BYTE_STREAMS
                     selector_indices_stream.push_back(delta3);
#endif
                     prev_color_selector_index += delta3;
                     limit(prev_color_selector_index, num_color_selectors);
                     pD[3 + row_pitch_in_dwords] = m_color_selectors[prev_color_selector_index];
                     CRND_WRITE_BARRIER
                  }
                  else
                  {
                     for (uint32 by = 0; by < 2; by++)
                     {
                        pD = (uint32*)((uint8*)pBlock + row_pitch_in_bytes * by);
                        for (uint32 bx = 0; bx < 2; bx++, pD += 2)
                        {
                           uint32 delta;
                           CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta);
#if CRND_CREATE_BYTE_STREAMS
                           selector_indices_stream.push_back(delta);
#endif
                           prev_color_selector_index += delta;
                           limit(prev_color_selector_index, num_color_selectors);

                           if (!((bx && skip_right_col) || (by && skip_bottom_row)))
                           {
                              pD[0] = color_endpoints[pTile_indices[bx + by * 2]];
                              CRND_WRITE_BARRIER
                              pD[1] = m_color_selectors[prev_color_selector_index];
                              CRND_WRITE_BARRIER
                           }
                        }
                     }
                  }

                  pBlock += block_delta;

               } // x

               pRow += row_pitch_in_bytes * 2;

            } // y

         } // f

         CRND_HUFF_DECODE_END(m_codec);

#if CRND_CREATE_BYTE_STREAMS
         write_array_to_file(L"tile_encodings.bin", tile_encoding_stream);
         write_array_to_file(L"endpoint_indices.bin", endpoint_indices_stream);
         write_array_to_file(L"selector_indices.bin", selector_indices_stream);
#endif

         return true;
      }

      bool unpack_dxt5(uint8** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes, uint32 blocks_x, uint32 blocks_y, uint32 chunks_x, uint32 chunks_y)
      {
         dst_size_in_bytes;

         uint32 chunk_encoding_bits = 1;

         const uint32 num_color_endpoints = m_color_endpoints.size();
         const uint32 num_color_selectors = m_color_selectors.size();
         const uint32 num_alpha_endpoints = m_alpha_endpoints.size();
         const uint32 num_alpha_selectors = m_pHeader->m_alpha_selectors.m_num;

         uint32 prev_color_endpoint_index = 0;
         uint32 prev_color_selector_index = 0;
         uint32 prev_alpha_endpoint_index = 0;
         uint32 prev_alpha_selector_index = 0;

         const uint32 num_faces = m_pHeader->m_faces;

         //const uint32 row_pitch_in_dwords = row_pitch_in_bytes >> 2U;

         const int32 cBytesPerBlock = 16;

         CRND_HUFF_DECODE_BEGIN(m_codec);

         for (uint32 f = 0; f < num_faces; f++)
         {
            uint8* CRND_RESTRICT pRow = pDst[f];

            for (uint32 y = 0; y < chunks_y; y++)
            {
               int32 start_x = 0;
               int32 end_x = chunks_x;
               int32 dir_x = 1;
               int32 block_delta = cBytesPerBlock*2;
               uint8* CRND_RESTRICT pBlock = pRow;

               if (y & 1)
               {
                  start_x = chunks_x - 1;
                  end_x = -1;
                  dir_x = -1;
                  block_delta = -cBytesPerBlock*2;
                  pBlock += (chunks_x - 1) * cBytesPerBlock * 2;
               }

               const bool skip_bottom_row = (y == (chunks_y - 1)) && (blocks_y & 1);

               for (int32 x = start_x; x != end_x; x += dir_x)
               {
                  uint32 color_endpoints[4];
                  uint32 alpha_endpoints[4];

                  if (chunk_encoding_bits == 1)
                  {
                     CRND_HUFF_DECODE(m_codec, m_chunk_encoding_dm, chunk_encoding_bits);
                     chunk_encoding_bits |= 512;
                  }

                  const uint32 chunk_encoding_index = chunk_encoding_bits & 7;
                  chunk_encoding_bits >>= 3;

                  const uint32 num_tiles = g_crnd_chunk_encoding_num_tiles[chunk_encoding_index];

                  const uint8* pTile_indices = g_crnd_chunk_encoding_tiles[chunk_encoding_index].m_tiles;

                  const bool skip_right_col = (blocks_x & 1) && (x == ((int32)chunks_x - 1));

                  uint32* CRND_RESTRICT pD = (uint32*)pBlock;

                  for (uint32 i = 0; i < num_tiles; i++)
                  {
                     uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[1], delta);
                     prev_alpha_endpoint_index += delta;
                     limit(prev_alpha_endpoint_index, num_alpha_endpoints);
                     alpha_endpoints[i] = m_alpha_endpoints[prev_alpha_endpoint_index];
                  }

                  for (uint32 i = 0; i < num_tiles; i++)
                  {
                     uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[0], delta);
                     prev_color_endpoint_index += delta;
                     limit(prev_color_endpoint_index, num_color_endpoints);
                     color_endpoints[i] = m_color_endpoints[prev_color_endpoint_index];
                  }

                  pD = (uint32*)pBlock;
                  for (uint32 by = 0; by < 2; by++)
                  {
                     for (uint32 bx = 0; bx < 2; bx++, pD += 4)
                     {
                        uint32 delta0; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[1], delta0);
                        prev_alpha_selector_index += delta0;
                        limit(prev_alpha_selector_index, num_alpha_selectors);

                        uint32 delta1; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta1);
                        prev_color_selector_index += delta1;
                        limit(prev_color_selector_index, num_color_selectors);

                        if (!((bx && skip_right_col) || (by && skip_bottom_row)))
                        {
                           const uint32 tile_index = pTile_indices[bx + by * 2];
                           const uint16* pAlpha_selectors = &m_alpha_selectors[prev_alpha_selector_index * 3];

#ifdef CRND_BIG_ENDIAN_PLATFORM
                           pD[0] = (alpha_endpoints[tile_index] << 16) | pAlpha_selectors[0];
                           CRND_WRITE_BARRIER
                           pD[1] = (pAlpha_selectors[1] << 16) | pAlpha_selectors[2];
                           CRND_WRITE_BARRIER
                           pD[2] = color_endpoints[tile_index];
                           CRND_WRITE_BARRIER
                           pD[3] = m_color_selectors[prev_color_selector_index];
                           CRND_WRITE_BARRIER
#else
                           pD[0] = alpha_endpoints[tile_index] | (pAlpha_selectors[0] << 16);
                           CRND_WRITE_BARRIER
                           pD[1] = pAlpha_selectors[1] | (pAlpha_selectors[2] << 16);
                           CRND_WRITE_BARRIER
                           pD[2] = color_endpoints[tile_index];
                           CRND_WRITE_BARRIER
                           pD[3] = m_color_selectors[prev_color_selector_index];
                           CRND_WRITE_BARRIER
#endif
                        }
                     }

                     pD = (uint32*)((uint8*)pD - cBytesPerBlock * 2 + row_pitch_in_bytes);
                  }

                  pBlock += block_delta;

               } // x

               pRow += row_pitch_in_bytes * 2;

            } // y

         } // f

         CRND_HUFF_DECODE_END(m_codec);

         return true;
      }

      bool unpack_dxn(uint8** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes, uint32 blocks_x, uint32 blocks_y, uint32 chunks_x, uint32 chunks_y)
      {
         dst_size_in_bytes;

         uint32 chunk_encoding_bits = 1;

         const uint32 num_alpha_endpoints = m_alpha_endpoints.size();
         const uint32 num_alpha_selectors = m_pHeader->m_alpha_selectors.m_num;

         uint32 prev_alpha0_endpoint_index = 0;
         uint32 prev_alpha0_selector_index = 0;
         uint32 prev_alpha1_endpoint_index = 0;
         uint32 prev_alpha1_selector_index = 0;

         const uint32 num_faces = m_pHeader->m_faces;

         //const uint32 row_pitch_in_dwords = row_pitch_in_bytes >> 2U;

         const int32 cBytesPerBlock = 16;

         CRND_HUFF_DECODE_BEGIN(m_codec);

         for (uint32 f = 0; f < num_faces; f++)
         {
            uint8* CRND_RESTRICT pRow = pDst[f];

            for (uint32 y = 0; y < chunks_y; y++)
            {
               int32 start_x = 0;
               int32 end_x = chunks_x;
               int32 dir_x = 1;
               int32 block_delta = cBytesPerBlock*2;
               uint8* CRND_RESTRICT pBlock = pRow;

               if (y & 1)
               {
                  start_x = chunks_x - 1;
                  end_x = -1;
                  dir_x = -1;
                  block_delta = -cBytesPerBlock*2;
                  pBlock += (chunks_x - 1) * cBytesPerBlock * 2;
               }

               const bool skip_bottom_row = (y == (chunks_y - 1)) && (blocks_y & 1);

               for (int32 x = start_x; x != end_x; x += dir_x)
               {
                  uint32 alpha0_endpoints[4];
                  uint32 alpha1_endpoints[4];

                  if (chunk_encoding_bits == 1)
                  {
                     CRND_HUFF_DECODE(m_codec, m_chunk_encoding_dm, chunk_encoding_bits);
                     chunk_encoding_bits |= 512;
                  }

                  const uint32 chunk_encoding_index = chunk_encoding_bits & 7;
                  chunk_encoding_bits >>= 3;

                  const uint32 num_tiles = g_crnd_chunk_encoding_num_tiles[chunk_encoding_index];

                  const uint8* pTile_indices = g_crnd_chunk_encoding_tiles[chunk_encoding_index].m_tiles;

                  const bool skip_right_col = (blocks_x & 1) && (x == ((int32)chunks_x - 1));

                  uint32* CRND_RESTRICT pD = (uint32*)pBlock;

                  for (uint32 i = 0; i < num_tiles; i++)
                  {
                     uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[1], delta);
                     prev_alpha0_endpoint_index += delta;
                     limit(prev_alpha0_endpoint_index, num_alpha_endpoints);
                     alpha0_endpoints[i] = m_alpha_endpoints[prev_alpha0_endpoint_index];
                  }

                  for (uint32 i = 0; i < num_tiles; i++)
                  {
                     uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[1], delta);
                     prev_alpha1_endpoint_index += delta;
                     limit(prev_alpha1_endpoint_index, num_alpha_endpoints);
                     alpha1_endpoints[i] = m_alpha_endpoints[prev_alpha1_endpoint_index];
                  }

                  pD = (uint32*)pBlock;
                  for (uint32 by = 0; by < 2; by++)
                  {
                     for (uint32 bx = 0; bx < 2; bx++, pD += 4)
                     {
                        uint32 delta0; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[1], delta0);
                        prev_alpha0_selector_index += delta0;
                        limit(prev_alpha0_selector_index, num_alpha_selectors);

                        uint32 delta1; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[1], delta1);
                        prev_alpha1_selector_index += delta1;
                        limit(prev_alpha1_selector_index, num_alpha_selectors);

                        if (!((bx && skip_right_col) || (by && skip_bottom_row)))
                        {
                           const uint32 tile_index = pTile_indices[bx + by * 2];
                           const uint16* pAlpha0_selectors = &m_alpha_selectors[prev_alpha0_selector_index * 3];
                           const uint16* pAlpha1_selectors = &m_alpha_selectors[prev_alpha1_selector_index * 3];

#ifdef CRND_BIG_ENDIAN_PLATFORM
                           pD[0] = (alpha0_endpoints[tile_index] << 16) | pAlpha0_selectors[0];
                           CRND_WRITE_BARRIER
                           pD[1] = (pAlpha0_selectors[1] << 16) | pAlpha0_selectors[2];
                           CRND_WRITE_BARRIER
                           pD[2] = (alpha1_endpoints[tile_index] << 16) | pAlpha1_selectors[0];
                           CRND_WRITE_BARRIER
                           pD[3] = (pAlpha1_selectors[1] << 16) | pAlpha1_selectors[2];
                           CRND_WRITE_BARRIER
#else
                           pD[0] = alpha0_endpoints[tile_index] | (pAlpha0_selectors[0] << 16);
                           CRND_WRITE_BARRIER
                           pD[1] = pAlpha0_selectors[1] | (pAlpha0_selectors[2] << 16);
                           CRND_WRITE_BARRIER
                           pD[2] = alpha1_endpoints[tile_index] | (pAlpha1_selectors[0] << 16);
                           CRND_WRITE_BARRIER
                           pD[3] = pAlpha1_selectors[1] | (pAlpha1_selectors[2] << 16);
                           CRND_WRITE_BARRIER
#endif
                        }
                     }

                     pD = (uint32*)((uint8*)pD - cBytesPerBlock * 2 + row_pitch_in_bytes);
                  }

                  pBlock += block_delta;

               } // x

               pRow += row_pitch_in_bytes * 2;

            } // y

         } // f

         CRND_HUFF_DECODE_END(m_codec);

         return true;
      }

      bool unpack_dxt5a(uint8** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes, uint32 blocks_x, uint32 blocks_y, uint32 chunks_x, uint32 chunks_y)
      {
         dst_size_in_bytes;

         uint32 chunk_encoding_bits = 1;

         const uint32 num_alpha_endpoints = m_alpha_endpoints.size();
         const uint32 num_alpha_selectors = m_pHeader->m_alpha_selectors.m_num;

         uint32 prev_alpha0_endpoint_index = 0;
         uint32 prev_alpha0_selector_index = 0;

         const uint32 num_faces = m_pHeader->m_faces;

         const int32 cBytesPerBlock = 8;

         CRND_HUFF_DECODE_BEGIN(m_codec);

         for (uint32 f = 0; f < num_faces; f++)
         {
            uint8* CRND_RESTRICT pRow = pDst[f];

            for (uint32 y = 0; y < chunks_y; y++)
            {
               int32 start_x = 0;
               int32 end_x = chunks_x;
               int32 dir_x = 1;
               int32 block_delta = cBytesPerBlock*2;
               uint8* CRND_RESTRICT pBlock = pRow;

               if (y & 1)
               {
                  start_x = chunks_x - 1;
                  end_x = -1;
                  dir_x = -1;
                  block_delta = -cBytesPerBlock*2;
                  pBlock += (chunks_x - 1) * cBytesPerBlock * 2;
               }

               const bool skip_bottom_row = (y == (chunks_y - 1)) && (blocks_y & 1);

               for (int32 x = start_x; x != end_x; x += dir_x)
               {
                  uint32 alpha0_endpoints[4];

                  if (chunk_encoding_bits == 1)
                  {
                     CRND_HUFF_DECODE(m_codec, m_chunk_encoding_dm, chunk_encoding_bits);
                     chunk_encoding_bits |= 512;
                  }

                  const uint32 chunk_encoding_index = chunk_encoding_bits & 7;
                  chunk_encoding_bits >>= 3;

                  const uint32 num_tiles = g_crnd_chunk_encoding_num_tiles[chunk_encoding_index];

                  const uint8* pTile_indices = g_crnd_chunk_encoding_tiles[chunk_encoding_index].m_tiles;

                  const bool skip_right_col = (blocks_x & 1) && (x == ((int32)chunks_x - 1));

                  uint32* CRND_RESTRICT pD = (uint32*)pBlock;

                  for (uint32 i = 0; i < num_tiles; i++)
                  {
                     uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[1], delta);
                     prev_alpha0_endpoint_index += delta;
                     limit(prev_alpha0_endpoint_index, num_alpha_endpoints);
                     alpha0_endpoints[i] = m_alpha_endpoints[prev_alpha0_endpoint_index];
                  }

                  pD = (uint32*)pBlock;
                  for (uint32 by = 0; by < 2; by++)
                  {
                     for (uint32 bx = 0; bx < 2; bx++, pD += 2)
                     {
                        uint32 delta; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[1], delta);
                        prev_alpha0_selector_index += delta;
                        limit(prev_alpha0_selector_index, num_alpha_selectors);

                        if (!((bx && skip_right_col) || (by && skip_bottom_row)))
                        {
                           const uint32 tile_index = pTile_indices[bx + by * 2];
                           const uint16* pAlpha0_selectors = &m_alpha_selectors[prev_alpha0_selector_index * 3];

#if CRND_BIG_ENDIAN_PLATFORM
                           pD[0] = (alpha0_endpoints[tile_index] << 16) | pAlpha0_selectors[0];
                           CRND_WRITE_BARRIER
                           pD[1] = (pAlpha0_selectors[1] << 16) | pAlpha0_selectors[2];
                           CRND_WRITE_BARRIER
#else
                           pD[0] = alpha0_endpoints[tile_index] | (pAlpha0_selectors[0] << 16);
                           CRND_WRITE_BARRIER
                           pD[1] = pAlpha0_selectors[1] | (pAlpha0_selectors[2] << 16);
                           CRND_WRITE_BARRIER
#endif
                        }
                     }

                     pD = (uint32*)((uint8*)pD - cBytesPerBlock * 2 + row_pitch_in_bytes);
                  }

                  pBlock += block_delta;

               } // x

               pRow += row_pitch_in_bytes * 2;

            } // y

         } // f

         CRND_HUFF_DECODE_END(m_codec);

         return true;
      }
   };

   crnd_unpack_context crnd_unpack_begin(const void* pData, uint32 data_size)
   {
      if ((!pData) || (data_size < cCRNHeaderMinSize))
         return NULL;

      crn_unpacker* p = crnd_new<crn_unpacker>();
      if (!p)
         return NULL;

      if (!p->init(pData, data_size))
      {
         crnd_delete(p);
         return NULL;
      }

      return p;
   }

   bool crnd_get_data(crnd_unpack_context pContext, const void** ppData, uint32* pData_size)
   {
      if (!pContext)
         return false;

      crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

      if (!pUnpacker->is_valid())
         return false;

      if (ppData)
         *ppData = pUnpacker->get_data();

      if (pData_size)
         *pData_size = pUnpacker->get_data_size();

      return true;
   }

   bool crnd_unpack_level(
      crnd_unpack_context pContext,
      void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
      uint32 level_index)
   {
      if ((!pContext) || (!pDst) || (dst_size_in_bytes < 8U) || (level_index >= cCRNMaxLevels))
         return false;

      crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

      if (!pUnpacker->is_valid())
         return false;

      return pUnpacker->unpack_level(pDst, dst_size_in_bytes, row_pitch_in_bytes, level_index);
   }

   bool crnd_unpack_level_segmented(
      crnd_unpack_context pContext,
      const void* pSrc, uint32 src_size_in_bytes,
      void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
      uint32 level_index)
   {
      if ((!pContext) || (!pSrc) || (!pDst) || (dst_size_in_bytes < 8U) || (level_index >= cCRNMaxLevels))
         return false;

      crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

      if (!pUnpacker->is_valid())
         return false;

      return pUnpacker->unpack_level(pSrc, src_size_in_bytes, pDst, dst_size_in_bytes, row_pitch_in_bytes, level_index);
   }

   bool crnd_unpack_end(crnd_unpack_context pContext)
   {
      if (!pContext)
         return false;

      crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

      if (!pUnpacker->is_valid())
         return false;

      crnd_delete(pUnpacker);

      return true;
   }

} // namespace crnd

#endif // CRND_HEADER_FILE_ONLY

  //------------------------------------------------------------------------------
  //
  // crunch/crnlib uses a modified ZLIB license. Specifically, it's the same as zlib except that 
  // public credits for using the library are *required*.
  // 
  // Copyright (c) 2010-2016 Richard Geldreich, Jr. All rights reserved.
  //
  // This software is provided 'as-is', without any express or implied
  // warranty.  In no event will the authors be held liable for any damages
  // arising from the use of this software.
  // 
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  // 
  // 1. The origin of this software must not be misrepresented; you must not
  // claim that you wrote the original software. 
  // 
  // 2. If you use this software in a product, this acknowledgment in the product 
  // documentation or credits is required:
  // 
  // "Crunch Library Copyright (c) 2010-2016 Richard Geldreich, Jr."
  // 
  // 3. Altered source versions must be plainly marked as such, and must not be
  // misrepresented as being the original software.
  // 
  // 4. This notice may not be removed or altered from any source distribution.
  //
  //------------------------------------------------------------------------------


```

`Texture2DDecoderNative/crunch/crnlib.h`:

```h
// File: crnlib.h - Advanced DXTn texture compression library.
// Copyright (c) 2010-2016 Richard Geldreich, Jr. All rights reserved.
// See copyright notice and license at the end of this file.
//
// This header file contains the public crnlib declarations for DXTn,
// clustered DXTn, and CRN compression/decompression.
//
// Note: This library does NOT need to be linked into your game executable if
// all you want to do is transcode .CRN files to raw DXTn bits at run-time.
// The crn_decomp.h header file library contains all the code necessary for
// decompression.
//
// Important: If compiling with gcc, be sure strict aliasing is disabled: -fno-strict-aliasing
#ifndef CRNLIB_H
#define CRNLIB_H

#ifdef _MSC_VER
#pragma warning (disable: 4127) //  conditional expression is constant
#endif

#define CRNLIB_VERSION 104

#define CRNLIB_SUPPORT_ATI_COMPRESS 0
#define CRNLIB_SUPPORT_SQUISH 0

typedef unsigned char   crn_uint8;
typedef unsigned short  crn_uint16;
typedef unsigned int    crn_uint32;
typedef signed char     crn_int8;
typedef signed short    crn_int16;
typedef signed int      crn_int32;
typedef unsigned int    crn_bool;

// crnlib can compress to these file types.
enum crn_file_type
{
   // .CRN
   cCRNFileTypeCRN = 0,

   // .DDS using regular DXT or clustered DXT
   cCRNFileTypeDDS,

   cCRNFileTypeForceDWORD = 0xFFFFFFFF
};

// Supported compressed pixel formats.
// Basically all the standard DX9 formats, with some swizzled DXT5 formats
// (most of them supported by ATI's Compressonator), along with some ATI/X360 GPU specific formats.
enum crn_format
{
   cCRNFmtInvalid = -1,

   cCRNFmtDXT1 = 0,

   cCRNFmtFirstValid = cCRNFmtDXT1,

   // cCRNFmtDXT3 is not currently supported when writing to CRN - only DDS.
   cCRNFmtDXT3,

   cCRNFmtDXT5,

   // Various DXT5 derivatives
   cCRNFmtDXT5_CCxY,    // Luma-chroma
   cCRNFmtDXT5_xGxR,    // Swizzled 2-component
   cCRNFmtDXT5_xGBR,    // Swizzled 3-component
   cCRNFmtDXT5_AGBR,    // Swizzled 4-component

   // ATI 3DC and X360 DXN
   cCRNFmtDXN_XY,
   cCRNFmtDXN_YX,

   // DXT5 alpha blocks only
   cCRNFmtDXT5A,

   cCRNFmtETC1,

   cCRNFmtTotal,

   cCRNFmtForceDWORD = 0xFFFFFFFF
};

// Various library/file format limits.
enum crn_limits
{
   // Max. mipmap level resolution on any axis.
   cCRNMaxLevelResolution     = 4096,

   cCRNMinPaletteSize         = 8,
   cCRNMaxPaletteSize         = 8192,

   cCRNMaxFaces               = 6,
   cCRNMaxLevels              = 16,

   cCRNMaxHelperThreads       = 16,

   cCRNMinQualityLevel        = 0,
   cCRNMaxQualityLevel        = 255
};

// CRN/DDS compression flags.
// See the m_flags member in the crn_comp_params struct, below.
enum crn_comp_flags
{
   // Enables perceptual colorspace distance metrics if set.
   // Important: Be sure to disable this when compressing non-sRGB colorspace images, like normal maps!
   // Default: Set
   cCRNCompFlagPerceptual = 1,

   // Enables (up to) 8x8 macroblock usage if set. If disabled, only 4x4 blocks are allowed.
   // Compression ratio will be lower when disabled, but may cut down on blocky artifacts because the process used to determine
   // where large macroblocks can be used without artifacts isn't perfect.
   // Default: Set.
   cCRNCompFlagHierarchical = 2,

   // cCRNCompFlagQuick disables several output file optimizations - intended for things like quicker previews.
   // Default: Not set.
   cCRNCompFlagQuick = 4,

   // DXT1: OK to use DXT1 alpha blocks for better quality or DXT1A transparency.
   // DXT5: OK to use both DXT5 block types.
   // Currently only used when writing to .DDS files, as .CRN uses only a subset of the possible DXTn block types.
   // Default: Set.
   cCRNCompFlagUseBothBlockTypes = 8,

   // OK to use DXT1A transparent indices to encode black (assumes pixel shader ignores fetched alpha).
   // Currently only used when writing to .DDS files, .CRN never uses alpha blocks.
   // Default: Not set.
   cCRNCompFlagUseTransparentIndicesForBlack = 16,

   // Disables endpoint caching, for more deterministic output.
   // Currently only used when writing to .DDS files.
   // Default: Not set.
   cCRNCompFlagDisableEndpointCaching = 32,

   // If enabled, use the cCRNColorEndpointPaletteSize, etc. params to control the CRN palette sizes. Only useful when writing to .CRN files.
   // Default: Not set.
   cCRNCompFlagManualPaletteSizes = 64,

   // If enabled, DXT1A alpha blocks are used to encode single bit transparency.
   // Default: Not set.
   cCRNCompFlagDXT1AForTransparency = 128,

   // If enabled, the DXT1 compressor's color distance metric assumes the pixel shader will be converting the fetched RGB results to luma (Y part of YCbCr).
   // This increases quality when compressing grayscale images, because the compressor can spread the luma error amoung all three channels (i.e. it can generate blocks
   // with some chroma present if doing so will ultimately lead to lower luma error).
   // Only enable on grayscale source images.
   // Default: Not set.
   cCRNCompFlagGrayscaleSampling = 256,

   // If enabled, debug information will be output during compression.
   // Default: Not set.
   cCRNCompFlagDebugging = 0x80000000,

   cCRNCompFlagForceDWORD = 0xFFFFFFFF
};

// Controls DXTn quality vs. speed control - only used when compressing to .DDS.
enum crn_dxt_quality
{
   cCRNDXTQualitySuperFast,
   cCRNDXTQualityFast,
   cCRNDXTQualityNormal,
   cCRNDXTQualityBetter,
   cCRNDXTQualityUber,

   cCRNDXTQualityTotal,

   cCRNDXTQualityForceDWORD = 0xFFFFFFFF
};

// Which DXTn compressor to use when compressing to plain (non-clustered) .DDS.
enum crn_dxt_compressor_type
{
   cCRNDXTCompressorCRN,      // Use crnlib's ETC1 or DXTc block compressor (default, highest quality, comparable or better than ati_compress or squish, and crnlib's ETC1 is a lot fasterw with similiar quality to Erricson's)
   cCRNDXTCompressorCRNF,     // Use crnlib's "fast" DXTc block compressor
   cCRNDXTCompressorRYG,      // Use RYG's DXTc block compressor (low quality, but very fast)

#if CRNLIB_SUPPORT_ATI_COMPRESS
   cCRNDXTCompressorATI,
#endif

#if CRNLIB_SUPPORT_SQUISH
   cCRNDXTCompressorSquish,
#endif

   cCRNTotalDXTCompressors,

   cCRNDXTCompressorForceDWORD = 0xFFFFFFFF
};

// Progress callback function.
// Processing will stop prematurely (and fail) if the callback returns false.
// phase_index, total_phases - high level progress
// subphase_index, total_subphases - progress within current phase
typedef crn_bool (*crn_progress_callback_func)(crn_uint32 phase_index, crn_uint32 total_phases, crn_uint32 subphase_index, crn_uint32 total_subphases, void* pUser_data_ptr);

// CRN/DDS compression parameters struct.
struct crn_comp_params
{
   inline crn_comp_params() { clear(); }

   // Clear struct to default parameters.
   inline void clear()
   {
      m_size_of_obj = sizeof(*this);
      m_file_type = cCRNFileTypeCRN;
      m_faces = 1;
      m_width = 0;
      m_height = 0;
      m_levels = 1;
      m_format = cCRNFmtDXT1;
      m_flags = cCRNCompFlagPerceptual | cCRNCompFlagHierarchical | cCRNCompFlagUseBothBlockTypes;

      for (crn_uint32 f = 0; f < cCRNMaxFaces; f++)
         for (crn_uint32 l = 0; l < cCRNMaxLevels; l++)
            m_pImages[f][l] = NULL;

      m_target_bitrate = 0.0f;
      m_quality_level = cCRNMaxQualityLevel;
      m_dxt1a_alpha_threshold = 128;
      m_dxt_quality = cCRNDXTQualityUber;
      m_dxt_compressor_type = cCRNDXTCompressorCRN;
      m_alpha_component = 3;

      m_crn_adaptive_tile_color_psnr_derating = 2.0f;
      m_crn_adaptive_tile_alpha_psnr_derating = 2.0f;
      m_crn_color_endpoint_palette_size = 0;
      m_crn_color_selector_palette_size = 0;
      m_crn_alpha_endpoint_palette_size = 0;
      m_crn_alpha_selector_palette_size = 0;

      m_num_helper_threads = 0;
      m_userdata0 = 0;
      m_userdata1 = 0;
      m_pProgress_func = NULL;
      m_pProgress_func_data = NULL;
   }

   inline bool operator== (const crn_comp_params& rhs) const
   {
#define CRNLIB_COMP(x) do { if ((x) != (rhs.x)) return false; } while(0)
      CRNLIB_COMP(m_size_of_obj);
      CRNLIB_COMP(m_file_type);
      CRNLIB_COMP(m_faces);
      CRNLIB_COMP(m_width);
      CRNLIB_COMP(m_height);
      CRNLIB_COMP(m_levels);
      CRNLIB_COMP(m_format);
      CRNLIB_COMP(m_flags);
      CRNLIB_COMP(m_target_bitrate);
      CRNLIB_COMP(m_quality_level);
      CRNLIB_COMP(m_dxt1a_alpha_threshold);
      CRNLIB_COMP(m_dxt_quality);
      CRNLIB_COMP(m_dxt_compressor_type);
      CRNLIB_COMP(m_alpha_component);
      CRNLIB_COMP(m_crn_adaptive_tile_color_psnr_derating);
      CRNLIB_COMP(m_crn_adaptive_tile_alpha_psnr_derating);
      CRNLIB_COMP(m_crn_color_endpoint_palette_size);
      CRNLIB_COMP(m_crn_color_selector_palette_size);
      CRNLIB_COMP(m_crn_alpha_endpoint_palette_size);
      CRNLIB_COMP(m_crn_alpha_selector_palette_size);
      CRNLIB_COMP(m_num_helper_threads);
      CRNLIB_COMP(m_userdata0);
      CRNLIB_COMP(m_userdata1);
      CRNLIB_COMP(m_pProgress_func);
      CRNLIB_COMP(m_pProgress_func_data);

      for (crn_uint32 f = 0; f < cCRNMaxFaces; f++)
         for (crn_uint32 l = 0; l < cCRNMaxLevels; l++)
            CRNLIB_COMP(m_pImages[f][l]);

#undef CRNLIB_COMP
      return true;
   }

   // Returns true if the input parameters are reasonable.
   inline bool check() const
   {
      if ( (m_file_type > cCRNFileTypeDDS) ||
         (((int)m_quality_level < (int)cCRNMinQualityLevel) || ((int)m_quality_level > (int)cCRNMaxQualityLevel)) ||
         (m_dxt1a_alpha_threshold > 255) ||
         ((m_faces != 1) && (m_faces != 6)) ||
         ((m_width < 1) || (m_width > cCRNMaxLevelResolution)) ||
         ((m_height < 1) || (m_height > cCRNMaxLevelResolution)) ||
         ((m_levels < 1) || (m_levels > cCRNMaxLevels)) ||
         ((m_format < cCRNFmtDXT1) || (m_format >= cCRNFmtTotal)) ||
         ((m_crn_color_endpoint_palette_size) && ((m_crn_color_endpoint_palette_size < cCRNMinPaletteSize) || (m_crn_color_endpoint_palette_size > cCRNMaxPaletteSize))) ||
         ((m_crn_color_selector_palette_size) && ((m_crn_color_selector_palette_size < cCRNMinPaletteSize) || (m_crn_color_selector_palette_size > cCRNMaxPaletteSize))) ||
         ((m_crn_alpha_endpoint_palette_size) && ((m_crn_alpha_endpoint_palette_size < cCRNMinPaletteSize) || (m_crn_alpha_endpoint_palette_size > cCRNMaxPaletteSize))) ||
         ((m_crn_alpha_selector_palette_size) && ((m_crn_alpha_selector_palette_size < cCRNMinPaletteSize) || (m_crn_alpha_selector_palette_size > cCRNMaxPaletteSize))) ||
         (m_alpha_component > 3) ||
         (m_num_helper_threads > cCRNMaxHelperThreads) ||
         (m_dxt_quality > cCRNDXTQualityUber) ||
         (m_dxt_compressor_type >= cCRNTotalDXTCompressors) )
      {
         return false;
      }
      return true;
   }

   // Helper to set/get flags from m_flags member.
   inline bool get_flag(crn_comp_flags flag) const { return (m_flags & flag) != 0; }
   inline void set_flag(crn_comp_flags flag, bool val) { m_flags &= ~flag; if (val) m_flags |= flag; }

   crn_uint32                 m_size_of_obj;

   crn_file_type              m_file_type;               // Output file type: cCRNFileTypeCRN or cCRNFileTypeDDS.

   crn_uint32                 m_faces;                   // 1 (2D map) or 6 (cubemap)
   crn_uint32                 m_width;                   // [1,cCRNMaxLevelResolution], non-power of 2 OK, non-square OK
   crn_uint32                 m_height;                  // [1,cCRNMaxLevelResolution], non-power of 2 OK, non-square OK
   crn_uint32                 m_levels;                  // [1,cCRNMaxLevelResolution], non-power of 2 OK, non-square OK

   crn_format                 m_format;                  // Output pixel format.

   crn_uint32                 m_flags;                   // see crn_comp_flags enum

   // Array of pointers to 32bpp input images.
   const crn_uint32*          m_pImages[cCRNMaxFaces][cCRNMaxLevels];

   // Target bitrate - if non-zero, the compressor will use an interpolative search to find the
   // highest quality level that is <= the target bitrate. If it fails to find a bitrate high enough, it'll
   // try disabling adaptive block sizes (cCRNCompFlagHierarchical flag) and redo the search. This process can be pretty slow.
   float                      m_target_bitrate;

   // Desired quality level.
   // Currently, CRN and DDS quality levels are not compatible with eachother from an image quality standpoint.
   crn_uint32                 m_quality_level;           // [cCRNMinQualityLevel, cCRNMaxQualityLevel]

   // DXTn compression parameters.
   crn_uint32                 m_dxt1a_alpha_threshold;
   crn_dxt_quality            m_dxt_quality;
   crn_dxt_compressor_type    m_dxt_compressor_type;

   // Alpha channel's component. Defaults to 3.
   crn_uint32                 m_alpha_component;

   // Various low-level CRN specific parameters.
   float                      m_crn_adaptive_tile_color_psnr_derating;
   float                      m_crn_adaptive_tile_alpha_psnr_derating;

   crn_uint32                 m_crn_color_endpoint_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]
   crn_uint32                 m_crn_color_selector_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]

   crn_uint32                 m_crn_alpha_endpoint_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]
   crn_uint32                 m_crn_alpha_selector_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]

   // Number of helper threads to create during compression. 0=no threading.
   crn_uint32                 m_num_helper_threads;

   // CRN userdata0 and userdata1 members, which are written directly to the header of the output file.
   crn_uint32                 m_userdata0;
   crn_uint32                 m_userdata1;

   // User provided progress callback.
   crn_progress_callback_func m_pProgress_func;
   void*                      m_pProgress_func_data;
};

// Mipmap generator's mode.
enum crn_mip_mode
{
   cCRNMipModeUseSourceOrGenerateMips,       // Use source texture's mipmaps if it has any, otherwise generate new mipmaps
   cCRNMipModeUseSourceMips,                 // Use source texture's mipmaps if it has any, otherwise the output has no mipmaps
   cCRNMipModeGenerateMips,                  // Always generate new mipmaps
   cCRNMipModeNoMips,                        // Output texture has no mipmaps

   cCRNMipModeTotal,

   cCRNModeForceDWORD = 0xFFFFFFFF
};

const char* crn_get_mip_mode_desc(crn_mip_mode m);
const char* crn_get_mip_mode_name(crn_mip_mode m);

// Mipmap generator's filter kernel.
enum crn_mip_filter
{
   cCRNMipFilterBox,
   cCRNMipFilterTent,
   cCRNMipFilterLanczos4,
   cCRNMipFilterMitchell,
   cCRNMipFilterKaiser,                      // Kaiser=default mipmap filter

   cCRNMipFilterTotal,

   cCRNMipFilterForceDWORD = 0xFFFFFFFF
};

const char* crn_get_mip_filter_name(crn_mip_filter f);

// Mipmap generator's scale mode.
enum crn_scale_mode
{
   cCRNSMDisabled,
   cCRNSMAbsolute,
   cCRNSMRelative,
   cCRNSMLowerPow2,
   cCRNSMNearestPow2,
   cCRNSMNextPow2,

   cCRNSMTotal,

   cCRNSMForceDWORD = 0xFFFFFFFF
};

const char* crn_get_scale_mode_desc(crn_scale_mode sm);

// Mipmap generator parameters.
struct crn_mipmap_params
{
   inline crn_mipmap_params() { clear(); }

   inline void clear()
   {
      m_size_of_obj = sizeof(*this);
      m_mode = cCRNMipModeUseSourceOrGenerateMips;
      m_filter = cCRNMipFilterKaiser;
      m_gamma_filtering = true;
      m_gamma = 2.2f;
      // Default "blurriness" factor of .9 actually sharpens the output a little.
      m_blurriness = .9f;
      m_renormalize = false;
      m_tiled = false;
      m_max_levels = cCRNMaxLevels;
      m_min_mip_size = 1;

      m_scale_mode = cCRNSMDisabled;
      m_scale_x = 1.0f;
      m_scale_y = 1.0f;

      m_window_left = 0;
      m_window_top = 0;
      m_window_right = 0;
      m_window_bottom = 0;

      m_clamp_scale = false;
      m_clamp_width = 0;
      m_clamp_height = 0;
   }

   inline bool check() const { return true; }

   inline bool operator== (const crn_mipmap_params& rhs) const
   {
#define CRNLIB_COMP(x) do { if ((x) != (rhs.x)) return false; } while(0)
      CRNLIB_COMP(m_size_of_obj);
      CRNLIB_COMP(m_mode);
      CRNLIB_COMP(m_filter);
      CRNLIB_COMP(m_gamma_filtering);
      CRNLIB_COMP(m_gamma);
      CRNLIB_COMP(m_blurriness);
      CRNLIB_COMP(m_renormalize);
      CRNLIB_COMP(m_tiled);
      CRNLIB_COMP(m_max_levels);
      CRNLIB_COMP(m_min_mip_size);
      CRNLIB_COMP(m_scale_mode);
      CRNLIB_COMP(m_scale_x);
      CRNLIB_COMP(m_scale_y);
      CRNLIB_COMP(m_window_left);
      CRNLIB_COMP(m_window_top);
      CRNLIB_COMP(m_window_right);
      CRNLIB_COMP(m_window_bottom);
      CRNLIB_COMP(m_clamp_scale);
      CRNLIB_COMP(m_clamp_width);
      CRNLIB_COMP(m_clamp_height);
      return true;
#undef CRNLIB_COMP
   }
   crn_uint32     m_size_of_obj;

   crn_mip_mode   m_mode;
   crn_mip_filter m_filter;

   crn_bool       m_gamma_filtering;
   float          m_gamma;

   float          m_blurriness;

   crn_uint32     m_max_levels;
   crn_uint32     m_min_mip_size;

   crn_bool       m_renormalize;
   crn_bool       m_tiled;

   crn_scale_mode m_scale_mode;
   float          m_scale_x;
   float          m_scale_y;

   crn_uint32     m_window_left;
   crn_uint32     m_window_top;
   crn_uint32     m_window_right;
   crn_uint32     m_window_bottom;

   crn_bool       m_clamp_scale;
   crn_uint32     m_clamp_width;
   crn_uint32     m_clamp_height;
};

// -------- High-level helper function definitions for CDN/DDS compression.

#ifndef CRNLIB_MIN_ALLOC_ALIGNMENT
#define CRNLIB_MIN_ALLOC_ALIGNMENT sizeof(size_t) * 2
#endif

// Function to set an optional user provided memory allocation/reallocation/msize routines.
// By default, crnlib just uses malloc(), free(), etc. for all allocations.
typedef void*  (*crn_realloc_func)(void* p, size_t size, size_t* pActual_size, bool movable, void* pUser_data);
typedef size_t (*crn_msize_func)(void* p, void* pUser_data);
void crn_set_memory_callbacks(crn_realloc_func pRealloc, crn_msize_func pMSize, void* pUser_data);

// Frees memory blocks allocated by crn_compress(), crn_decompress_crn_to_dds(), or crn_decompress_dds_to_images().
void crn_free_block(void *pBlock);

// Compresses a 32-bit/pixel texture to either: a regular DX9 DDS file, a "clustered" (or reduced entropy) DX9 DDS file, or a CRN file in memory.
// Input parameters:
//  comp_params is the compression parameters struct, defined above.
//  compressed_size will be set to the size of the returned memory block containing the output file.
//  The returned block must be freed by calling crn_free_block().
//  *pActual_quality_level will be set to the actual quality level used to compress the image. May be NULL.
//  *pActual_bitrate will be set to the output file's effective bitrate, possibly taking into account LZMA compression. May be NULL.
// Return value:
//  The compressed file data, or NULL on failure.
//  compressed_size will be set to the size of the returned memory buffer.
// Notes:
//  A "regular" DDS file is compressed using normal DXTn compression at the specified DXT quality level.
//  A "clustered" DDS file is compressed using clustered DXTn compression to either the target bitrate or the specified integer quality factor.
//  The output file is a standard DX9 format DDS file, except the compressor assumes you will be later losslessly compressing the DDS output file using the LZMA algorithm.
//  A texture is defined as an array of 1 or 6 "faces" (6 faces=cubemap), where each "face" consists of between [1,cCRNMaxLevels] mipmap levels.
//  Mipmap levels are simple 32-bit 2D images with a pitch of width*sizeof(uint32), arranged in the usual raster order (top scanline first).
//  The image pixels may be grayscale (YYYX bytes in memory), grayscale/alpha (YYYA in memory), 24-bit (RGBX in memory), or 32-bit (RGBA) colors (where "X"=don't care).
//  RGB color data is generally assumed to be in the sRGB colorspace. If not, be sure to clear the "cCRNCompFlagPerceptual" in the crn_comp_params struct!
void *crn_compress(const crn_comp_params &comp_params, crn_uint32 &compressed_size, crn_uint32 *pActual_quality_level = NULL, float *pActual_bitrate = NULL);

// Like the above function, except this function can also do things like generate mipmaps, and resize or crop the input texture before compression.
// The actual operations performed are controlled by the crn_mipmap_params struct members.
// Be sure to set the "m_gamma_filtering" member of crn_mipmap_params to false if the input texture is not sRGB.
void *crn_compress(const crn_comp_params &comp_params, const crn_mipmap_params &mip_params, crn_uint32 &compressed_size, crn_uint32 *pActual_quality_level = NULL, float *pActual_bitrate = NULL);

// Transcodes an entire CRN file to DDS using the crn_decomp.h header file library to do most of the heavy lifting.
// The output DDS file's format is guaranteed to be one of the DXTn formats in the crn_format enum.
// This is a fast operation, because the CRN format is explicitly designed to be efficiently transcodable to DXTn.
// For more control over decompression, see the lower-level helper functions in crn_decomp.h, which do not depend at all on crnlib.
void *crn_decompress_crn_to_dds(const void *pCRN_file_data, crn_uint32 &file_size);

// Decompresses an entire DDS file in any supported format to uncompressed 32-bit/pixel image(s).
// See the crnlib::pixel_format enum in inc/dds_defs.h for a list of the supported DDS formats.
// You are responsible for freeing each image block, either by calling crn_free_all_images() or manually calling crn_free_block() on each image pointer.
struct crn_texture_desc
{
   crn_uint32 m_faces;
   crn_uint32 m_width;
   crn_uint32 m_height;
   crn_uint32 m_levels;
   crn_uint32 m_fmt_fourcc; // Same as crnlib::pixel_format
};
bool crn_decompress_dds_to_images(const void *pDDS_file_data, crn_uint32 dds_file_size, crn_uint32 **ppImages, crn_texture_desc &tex_desc);

// Frees all images allocated by crn_decompress_dds_to_images().
void crn_free_all_images(crn_uint32 **ppImages, const crn_texture_desc &desc);

// -------- crn_format related helpers functions.

// Returns the FOURCC format equivalent to the specified crn_format.
crn_uint32 crn_get_format_fourcc(crn_format fmt);

// Returns the crn_format's bits per texel.
crn_uint32 crn_get_format_bits_per_texel(crn_format fmt);

// Returns the crn_format's number of bytes per block.
crn_uint32 crn_get_bytes_per_dxt_block(crn_format fmt);

// Returns the non-swizzled, basic DXTn version of the specified crn_format.
// This is the format you would supply D3D or OpenGL.
crn_format crn_get_fundamental_dxt_format(crn_format fmt);

// -------- String helpers.

// Converts a crn_file_type to a string.
const char* crn_get_file_type_ext(crn_file_type file_type);

// Converts a crn_format to a string.
const char* crn_get_format_string(crn_format fmt);

// Converts a crn_dxt_quality to a string.
const char* crn_get_dxt_quality_string(crn_dxt_quality q);

// -------- Low-level DXTn 4x4 block compressor API

// crnlib's DXTn endpoint optimizer actually supports any number of source pixels (i.e. from 1 to thousands, not just 16),
// but for simplicity this API only supports 4x4 texel blocks.
typedef void *crn_block_compressor_context_t;

// Create a DXTn block compressor.
// This function only supports the basic/nonswizzled "fundamental" formats: DXT1, DXT3, DXT5, DXT5A, DXN_XY and DXN_YX.
// Avoid calling this multiple times if you intend on compressing many blocks, because it allocates some memory.
crn_block_compressor_context_t crn_create_block_compressor(const crn_comp_params &params);

// Compresses a block of 16 pixels to the destination DXTn block.
// pDst_block should be 8 (for DXT1/DXT5A) or 16 bytes (all the others).
// pPixels should be an array of 16 crn_uint32's. Each crn_uint32 must be r,g,b,a (r is always first) in memory.
void crn_compress_block(crn_block_compressor_context_t pContext, const crn_uint32 *pPixels, void *pDst_block);

// Frees a DXTn block compressor.
void crn_free_block_compressor(crn_block_compressor_context_t pContext);

// Unpacks a compressed block to pDst_pixels.
// pSrc_block should be 8 (for DXT1/DXT5A) or 16 bytes (all the others).
// pDst_pixel should be an array of 16 crn_uint32's. Each uint32 will be r,g,b,a (r is always first) in memory.
// crn_fmt should be one of the "fundamental" formats: DXT1, DXT3, DXT5, DXT5A, DXN_XY and DXN_YX.
// The various swizzled DXT5 formats (such as cCRNFmtDXT5_xGBR, etc.) will be unpacked as if they where plain DXT5.
// Returns false if the crn_fmt is invalid.
bool crn_decompress_block(const void *pSrc_block, crn_uint32 *pDst_pixels, crn_format crn_fmt);

#endif // CRNLIB_H

//------------------------------------------------------------------------------
//
// crunch/crnlib uses a modified ZLIB license. Specifically, it's the same as zlib except that 
// public credits for using the library are *required*.
// 
// Copyright (c) 2010-2016 Richard Geldreich, Jr. All rights reserved.
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// 
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. 
// 
// 2. If you use this software in a product, this acknowledgment in the product 
// documentation or credits is required:
// 
// "Crunch Library Copyright (c) 2010-2016 Richard Geldreich, Jr."
// 
// 3. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
// 
// 4. This notice may not be removed or altered from any source distribution.
//
//------------------------------------------------------------------------------

```

`Texture2DDecoderNative/dllexport.h`:

```h
#pragma once

#if defined(_MSC_VER)
#if _MSC_VER < 1910 // MSVC 2017-
#error MSVC 2017 or later is required.
#endif
#endif

#if defined(WIN32) || defined(_WIN32) || defined(__CYGWIN__) || defined(__MINGW__)
#ifdef _T2D_DLL
#ifdef __GNUC__
#define _T2D_EXPORT __attribute__ ((dllexport))
#else
#define _T2D_EXPORT __declspec(dllexport)
#endif
#else
#ifdef __GNUC__
#define _T2D_EXPORT __attribute__ ((dllimport))
#else
#define _T2D_EXPORT __declspec(dllimport)
#endif
#endif
#define _T2D_LOCAL
#else
#if __GNUC__ >= 4
#define _T2D_EXPORT __attribute__ ((visibility ("default")))
#define _T2D_LOCAL  __attribute__ ((visibility ("hidden")))
#else
#define _T2D_EXPORT
#define _T2D_LOCAL
#endif
#endif

#ifdef __cplusplus
#ifndef _EXTERN_C_STMT
#define _EXTERN_C_STMT extern "C"
#endif
#else
#ifndef _EXTERN_C_STMT
#define _EXTERN_C_STMT
#endif
#endif

#ifndef _T2D_CALL
#if defined(WIN32) || defined(_WIN32)
#define _T2D_CALL __stdcall
#else
#define _T2D_CALL /* __cdecl */
#endif
#endif

#if defined(_MSC_VER)
#define T2D_API(ret_type) _EXTERN_C_STMT _T2D_EXPORT ret_type _T2D_CALL
#else
#define T2D_API(ret_type) _EXTERN_C_STMT _T2D_EXPORT _T2D_CALL ret_type
#endif

```

`Texture2DDecoderNative/dllmain.cpp`:

```cpp
#include "dllexport.h"
#include "bool32_t.h"

#include "bcn.h"
#include "pvrtc.h"
#include "etc.h"
#include "atc.h"
#include "astc.h"
#include "crunch.h"
#include "unitycrunch.h"

T2D_API(bool32_t) DecodeDXT1(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_bc1(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeDXT5(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_bc3(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodePVRTC(const void* data, int32_t width, int32_t height, void* image, bool32_t is2bpp)
{
	return decode_pvrtc(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image), is2bpp ? 1 : 0);
}

T2D_API(bool32_t) DecodeETC1(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_etc1(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeETC2(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_etc2(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeETC2A1(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_etc2a1(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeETC2A8(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_etc2a8(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeEACR(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_eacr(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeEACRSigned(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_eacr_signed(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeEACRG(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_eacrg(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeEACRGSigned(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_eacrg_signed(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeBC4(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_bc4(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeBC5(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_bc5(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeBC6(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_bc6(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeBC7(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_bc7(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeATCRGB4(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_atc_rgb4(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeATCRGBA8(const void* data, int32_t width, int32_t height, void* image)
{
	return decode_atc_rgba8(static_cast<const uint8_t*>(data), width, height, static_cast<uint32_t*>(image));
}

T2D_API(bool32_t) DecodeASTC(const void* data, int32_t width, int32_t height, int32_t blockWidth, int32_t blockHeight, void* image)
{
	return decode_astc(static_cast<const uint8_t*>(data), width, height, blockWidth, blockHeight, static_cast<uint32_t*>(image));
}

T2D_API(void) DisposeBuffer(void** ppBuffer)
{
	if (ppBuffer == nullptr)
	{
		return;
	}

	auto ppTypedBuffer = reinterpret_cast<uint8_t**>(ppBuffer);

	delete[](*ppTypedBuffer);

	*ppBuffer = nullptr;
}

T2D_API(void) UnpackCrunch(const void* data, uint32_t dataSize, void** ppResult, uint32_t* pResultSize)
{
	void* result;
	uint32_t resultSize;

	if (ppResult != nullptr)
	{
		*ppResult = nullptr;
	}

	if (pResultSize != nullptr)
	{
		*pResultSize = 0;
	}

	if (!crunch_unpack_level(static_cast<const uint8_t*>(data), dataSize, 0, &result, &resultSize)) {
		return;
	}

	if (ppResult != nullptr)
	{
		*ppResult = result;
	}

	if (pResultSize != nullptr)
	{
		*pResultSize = resultSize;
	}
}

T2D_API(void) UnpackUnityCrunch(const void* data, uint32_t dataSize, void** ppResult, uint32_t* pResultSize)
{
	void* result;
	uint32_t resultSize;

	if (ppResult != nullptr)
	{
		*ppResult = nullptr;
	}

	if (pResultSize != nullptr)
	{
		*pResultSize = 0;
	}

	if (!unity_crunch_unpack_level(static_cast<const uint8_t*>(data), dataSize, 0, &result, &resultSize)) {
		return;
	}

	if (ppResult != nullptr)
	{
		*ppResult = result;
	}

	if (pResultSize != nullptr)
	{
		*pResultSize = resultSize;
	}
}

```

`Texture2DDecoderNative/endianness.h`:

```h
/*
 *
 * License Information
 *
 * endianness.h is derived from https://gist.github.com/jtbr/7a43e6281e6cca353b33ee501421860c
 * The file is licensed under the MIT License shown below.
 *
 *
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef _ENDIANNESS_H
#define _ENDIANNESS_H

#include <stdlib.h>
#include <stdint.h>

/* Detect platform endianness at compile time */

// If boost were available on all platforms, could use this instead to detect endianness
// #include <boost/predef/endian.h>

// When available, these headers can improve platform endianness detection
#ifdef __has_include  // C++17, supported as extension to C++11 in clang, GCC 5+, vs2015
#if __has_include(<endian.h>)
#include <endian.h>  // gnu libc normally provides, linux
#elif __has_include(<machine/endian.h>)
#include <machine/endian.h>  //open bsd, macos
#elif __has_include(<sys/param.h>)
#include <sys/param.h>  // mingw, some bsd (not open/macos)
#elif __has_include(<sys/isadefs.h>)
#include <sys/isadefs.h>  // solaris
#endif
#endif

#if !defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
#if (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) ||                                            \
  (defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN) || (defined(_BYTE_ORDER) && _BYTE_ORDER == _BIG_ENDIAN) ||  \
  (defined(BYTE_ORDER) && BYTE_ORDER == BIG_ENDIAN) || (defined(__sun) && defined(__SVR4) && defined(_BIG_ENDIAN)) || \
  defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) ||    \
  defined(__MIBSEB__) || defined(_M_PPC)
#define __BIG_ENDIAN__
#elif (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || /* gcc */                           \
  (defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN) /* linux header */ ||                                  \
  (defined(_BYTE_ORDER) && _BYTE_ORDER == _LITTLE_ENDIAN) ||                                                        \
  (defined(BYTE_ORDER) && BYTE_ORDER == LITTLE_ENDIAN) /* mingw header */ ||                                        \
  (defined(__sun) && defined(__SVR4) && defined(_LITTLE_ENDIAN)) || /* solaris */                                   \
  defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) ||  \
  defined(__MIPSEL__) || defined(_M_IX86) || defined(_M_X64) || defined(_M_IA64) || /* msvc for intel processors */ \
  defined(_M_ARM) /* msvc code on arm executes in little endian mode */
#define __LITTLE_ENDIAN__
#endif
#endif

#ifdef bswap16
#undef bswap16
#endif
#ifdef bswap32
#undef bswap32
#endif
#ifdef bswap64
#undef bswap64
#endif

/* Define byte-swap functions, using fast processor-native built-ins where possible */
// needs to be first because msvc doesn't short-circuit after failing defined(__has_builtin)
#if defined(_MSC_VER)
#define bswap16(x) _byteswap_ushort((x))
#define bswap32(x) _byteswap_ulong((x))
#define bswap64(x) _byteswap_uint64((x))
#elif (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
#define bswap16(x) __builtin_bswap16((x))
#define bswap32(x) __builtin_bswap32((x))
#define bswap64(x) __builtin_bswap64((x))
#elif defined(__has_builtin) && __has_builtin(__builtin_bswap64)
/* for clang; gcc 5 fails on this and && shortcircuit fails; must be after GCC check */
#define bswap16(x) __builtin_bswap16((x))
#define bswap32(x) __builtin_bswap32((x))
#define bswap64(x) __builtin_bswap64((x))
#else
/* even in this case, compilers often optimize by using native instructions */
static inline uint16_t bswap16(uint16_t x) {
    return (((x >> 8) & 0xffu) | ((x & 0xffu) << 8));
}
static inline uint32_t bswap32(uint32_t x) {
    return (((x & 0xff000000u) >> 24) | ((x & 0x00ff0000u) >> 8) | ((x & 0x0000ff00u) << 8) |
            ((x & 0x000000ffu) << 24));
}
static inline uint64_t bswap64(uint64_t x) {
    return (((x & 0xff00000000000000ull) >> 56) | ((x & 0x00ff000000000000ull) >> 40) |
            ((x & 0x0000ff0000000000ull) >> 24) | ((x & 0x000000ff00000000ull) >> 8) |
            ((x & 0x00000000ff000000ull) << 8) | ((x & 0x0000000000ff0000ull) << 24) |
            ((x & 0x000000000000ff00ull) << 40) | ((x & 0x00000000000000ffull) << 56));
}
#endif


/* Defines network - host byte swaps as needed depending upon platform endianness */
// note that network order is big endian)

#if defined(__LITTLE_ENDIAN__)
#define ntoh16(x) bswap16((x))
#define hton16(x) bswap16((x))
#define ntoh32(x) bswap32((x))
#define hton32(x) bswap32((x))
#define ntoh64(x) bswap64((x))
#define hton64(x) bswap64((x))
#define lton16(x) (x)
#define lton32(x) (x)
#define lton64(x) (x)
#define ltonf(x) (x)
#define ltond(x) (x)
#define bton16(x) bswap16((x))
#define bton32(x) bswap32((x))
#define bton64(x) bswap64((x))
#define btonf(x) htonf((x))
#define btond(x) htond((x))
#elif defined(__BIG_ENDIAN__)
#define ntoh16(x) (x)
#define hton16(x) (x)
#define ntoh32(x) (x)
#define hton32(x) (x)
#define ntoh64(x) (x)
#define hton64(x) (x)
#define bton16(x) (x)
#define bton32(x) (x)
#define bton64(x) (x)
#define btonf(x) (x)
#define btond(x) (x)
#define lton16(x) bswap16((x))
#define lton32(x) bswap32((x))
#define lton64(x) bswap64((x))
#define ltonf(x) htonf((x))
#define ltond(x) htond((x))
#else
#warning "UNKNOWN Platform / endianness; network / host byte swaps not defined."
#endif


//! Convert 32-bit float from host to network byte order
static inline float htonf(float f) {
#ifdef __cplusplus
    static_assert(sizeof(float) == sizeof(uint32_t), "Unexpected float format");
    uint32_t val = hton32(*(reinterpret_cast<const uint32_t *>(&f)));
    return *(reinterpret_cast<float *>(&val));
#else
    uint32_t val = hton32(*(const uint32_t *)(&f));
    return *((float *)(&val));
#endif
}
#define ntohf(x) htonf((x))

//! Convert 64-bit double from host to network byte order
static inline double htond(double f) {
#ifdef __cplusplus
    static_assert(sizeof(double) == sizeof(uint64_t), "Unexpected double format");
    uint64_t val = hton64(*(reinterpret_cast<const uint64_t *>(&f)));
    return *(reinterpret_cast<double *>(&val));
#else
    uint64_t val = hton64(*(const uint64_t *)(&f));
    return *((double *)(&val));
#endif
}
#define ntohd(x) htond((x))

#endif  //_ENDIANNESS_H

```

`Texture2DDecoderNative/etc.cpp`:

```cpp
#include "etc.h"
#include <stdint.h>
#include <string.h>
#include "color.h"

const uint_fast8_t WriteOrderTable[16] = {0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15};
const uint_fast8_t WriteOrderTableRev[16] = {15, 11, 7, 3, 14, 10, 6, 2, 13, 9, 5, 1, 12, 8, 4, 0};
const uint_fast8_t Etc1ModifierTable[8][2] = {{2, 8},   {5, 17},  {9, 29},   {13, 42},
                                              {18, 60}, {24, 80}, {33, 106}, {47, 183}};
const uint_fast8_t Etc2aModifierTable[2][8][2] = {
  {{0, 8}, {0, 17}, {0, 29}, {0, 42}, {0, 60}, {0, 80}, {0, 106}, {0, 183}},
  {{2, 8}, {5, 17}, {9, 29}, {13, 42}, {18, 60}, {24, 80}, {33, 106}, {47, 183}}};
const uint_fast8_t Etc1SubblockTable[2][16] = {{0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1},
                                               {0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1}};
const uint_fast8_t Etc2DistanceTable[8] = {3, 6, 11, 16, 23, 32, 41, 64};
const int_fast8_t Etc2AlphaModTable[16][8] = {
  {-3, -6, -9, -15, 2, 5, 8, 14}, {-3, -7, -10, -13, 2, 6, 9, 12}, {-2, -5, -8, -13, 1, 4, 7, 12},
  {-2, -4, -6, -13, 1, 3, 5, 12}, {-3, -6, -8, -12, 2, 5, 7, 11},  {-3, -7, -9, -11, 2, 6, 8, 10},
  {-4, -7, -8, -11, 3, 6, 7, 10}, {-3, -5, -8, -11, 2, 4, 7, 10},  {-2, -6, -8, -10, 1, 5, 7, 9},
  {-2, -5, -8, -10, 1, 4, 7, 9},  {-2, -4, -8, -10, 1, 3, 7, 9},   {-2, -5, -7, -10, 1, 4, 6, 9},
  {-3, -4, -7, -10, 2, 3, 6, 9},  {-1, -2, -3, -10, 0, 1, 2, 9},   {-4, -6, -8, -9, 3, 5, 7, 8},
  {-3, -5, -7, -9, 2, 4, 6, 8}};

static inline uint_fast8_t clamp(const int n) {
    return n < 0 ? 0 : n > 255 ? 255 : n;
}

static inline uint32_t applicate_color(uint_fast8_t c[3], int_fast16_t m) {
    return color(clamp(c[0] + m), clamp(c[1] + m), clamp(c[2] + m), 255);
}

static inline uint32_t applicate_color_alpha(uint_fast8_t c[3], int_fast16_t m, int transparent) {
    return color(clamp(c[0] + m), clamp(c[1] + m), clamp(c[2] + m), transparent ? 0 : 255);
}

static inline uint32_t applicate_color_raw(uint_fast8_t c[3]) {
    return color(c[0], c[1], c[2], 255);
}

static void decode_etc1_block(const uint8_t *data, uint32_t *outbuf) {
    const uint_fast8_t code[2] = {data[3] >> 5, data[3] >> 2 & 7};  // Table codewords
    const uint_fast8_t *table = Etc1SubblockTable[data[3] & 1];
    uint_fast8_t c[2][3];
    if (data[3] & 2) {
        // diff bit == 1
        c[0][0] = data[0] & 0xf8;
        c[0][1] = data[1] & 0xf8;
        c[0][2] = data[2] & 0xf8;
        c[1][0] = c[0][0] + (data[0] << 3 & 0x18) - (data[0] << 3 & 0x20);
        c[1][1] = c[0][1] + (data[1] << 3 & 0x18) - (data[1] << 3 & 0x20);
        c[1][2] = c[0][2] + (data[2] << 3 & 0x18) - (data[2] << 3 & 0x20);
        c[0][0] |= c[0][0] >> 5;
        c[0][1] |= c[0][1] >> 5;
        c[0][2] |= c[0][2] >> 5;
        c[1][0] |= c[1][0] >> 5;
        c[1][1] |= c[1][1] >> 5;
        c[1][2] |= c[1][2] >> 5;
    } else {
        // diff bit == 0
        c[0][0] = (data[0] & 0xf0) | data[0] >> 4;
        c[1][0] = (data[0] & 0x0f) | data[0] << 4;
        c[0][1] = (data[1] & 0xf0) | data[1] >> 4;
        c[1][1] = (data[1] & 0x0f) | data[1] << 4;
        c[0][2] = (data[2] & 0xf0) | data[2] >> 4;
        c[1][2] = (data[2] & 0x0f) | data[2] << 4;
    }

    uint_fast16_t j = data[6] << 8 | data[7];  // less significant pixel index bits
    uint_fast16_t k = data[4] << 8 | data[5];  // more significant pixel index bits
    for (int i = 0; i < 16; i++, j >>= 1, k >>= 1) {
        uint_fast8_t s = table[i];
        uint_fast8_t m = Etc1ModifierTable[code[s]][j & 1];
        outbuf[WriteOrderTable[i]] = applicate_color(c[s], k & 1 ? -m : m);
    }
}

static void decode_etc2_block(const uint8_t *data, uint32_t *outbuf) {
    uint_fast16_t j = data[6] << 8 | data[7];  // 15 -> 0
    uint_fast32_t k = data[4] << 8 | data[5];  // 31 -> 16
    uint_fast8_t c[3][3] = {};

    if (data[3] & 2) {
        // diff bit == 1
        uint_fast8_t r = data[0] & 0xf8;
        int_fast16_t dr = (data[0] << 3 & 0x18) - (data[0] << 3 & 0x20);
        uint_fast8_t g = data[1] & 0xf8;
        int_fast16_t dg = (data[1] << 3 & 0x18) - (data[1] << 3 & 0x20);
        uint_fast8_t b = data[2] & 0xf8;
        int_fast16_t db = (data[2] << 3 & 0x18) - (data[2] << 3 & 0x20);
        if (r + dr < 0 || r + dr > 255) {
            // T
            c[0][0] = (data[0] << 3 & 0xc0) | (data[0] << 4 & 0x30) | (data[0] >> 1 & 0xc) | (data[0] & 3);
            c[0][1] = (data[1] & 0xf0) | data[1] >> 4;
            c[0][2] = (data[1] & 0x0f) | data[1] << 4;
            c[1][0] = (data[2] & 0xf0) | data[2] >> 4;
            c[1][1] = (data[2] & 0x0f) | data[2] << 4;
            c[1][2] = (data[3] & 0xf0) | data[3] >> 4;
            const uint_fast8_t d = Etc2DistanceTable[(data[3] >> 1 & 6) | (data[3] & 1)];
            uint_fast32_t color_set[4] = {applicate_color_raw(c[0]), applicate_color(c[1], d),
                                          applicate_color_raw(c[1]), applicate_color(c[1], -d)};
            k <<= 1;
            for (int i = 0; i < 16; i++, j >>= 1, k >>= 1)
                outbuf[WriteOrderTable[i]] = color_set[(k & 2) | (j & 1)];
        } else if (g + dg < 0 || g + dg > 255) {
            // H
            c[0][0] = (data[0] << 1 & 0xf0) | (data[0] >> 3 & 0xf);
            c[0][1] = (data[0] << 5 & 0xe0) | (data[1] & 0x10);
            c[0][1] |= c[0][1] >> 4;
            c[0][2] = (data[1] & 8) | (data[1] << 1 & 6) | data[2] >> 7;
            c[0][2] |= c[0][2] << 4;
            c[1][0] = (data[2] << 1 & 0xf0) | (data[2] >> 3 & 0xf);
            c[1][1] = (data[2] << 5 & 0xe0) | (data[3] >> 3 & 0x10);
            c[1][1] |= c[1][1] >> 4;
            c[1][2] = (data[3] << 1 & 0xf0) | (data[3] >> 3 & 0xf);
            uint_fast8_t d = (data[3] & 4) | (data[3] << 1 & 2);
            if (c[0][0] > c[1][0] ||
                (c[0][0] == c[1][0] && (c[0][1] > c[1][1] || (c[0][1] == c[1][1] && c[0][2] >= c[1][2]))))
                ++d;
            d = Etc2DistanceTable[d];
            uint_fast32_t color_set[4] = {applicate_color(c[0], d), applicate_color(c[0], -d), applicate_color(c[1], d),
                                          applicate_color(c[1], -d)};
            k <<= 1;
            for (int i = 0; i < 16; i++, j >>= 1, k >>= 1)
                outbuf[WriteOrderTable[i]] = color_set[(k & 2) | (j & 1)];
        } else if (b + db < 0 || b + db > 255) {
            // planar
            c[0][0] = (data[0] << 1 & 0xfc) | (data[0] >> 5 & 3);
            c[0][1] = (data[0] << 7 & 0x80) | (data[1] & 0x7e) | (data[0] & 1);
            c[0][2] = (data[1] << 7 & 0x80) | (data[2] << 2 & 0x60) | (data[2] << 3 & 0x18) | (data[3] >> 5 & 4);
            c[0][2] |= c[0][2] >> 6;
            c[1][0] = (data[3] << 1 & 0xf8) | (data[3] << 2 & 4) | (data[3] >> 5 & 3);
            c[1][1] = (data[4] & 0xfe) | data[4] >> 7;
            c[1][2] = (data[4] << 7 & 0x80) | (data[5] >> 1 & 0x7c);
            c[1][2] |= c[1][2] >> 6;
            c[2][0] = (data[5] << 5 & 0xe0) | (data[6] >> 3 & 0x1c) | (data[5] >> 1 & 3);
            c[2][1] = (data[6] << 3 & 0xf8) | (data[7] >> 5 & 0x6) | (data[6] >> 4 & 1);
            c[2][2] = data[7] << 2 | (data[7] >> 4 & 3);
            for (int y = 0, i = 0; y < 4; y++) {
                for (int x = 0; x < 4; x++, i++) {
                    uint8_t r = clamp((x * (c[1][0] - c[0][0]) + y * (c[2][0] - c[0][0]) + 4 * c[0][0] + 2) >> 2);
                    uint8_t g = clamp((x * (c[1][1] - c[0][1]) + y * (c[2][1] - c[0][1]) + 4 * c[0][1] + 2) >> 2);
                    uint8_t b = clamp((x * (c[1][2] - c[0][2]) + y * (c[2][2] - c[0][2]) + 4 * c[0][2] + 2) >> 2);
                    outbuf[i] = color(r, g, b, 255);
                }
            }
        } else {
            // differential
            const uint_fast8_t code[2] = {data[3] >> 5, data[3] >> 2 & 7};
            const uint_fast8_t *table = Etc1SubblockTable[data[3] & 1];
            c[0][0] = r | r >> 5;
            c[0][1] = g | g >> 5;
            c[0][2] = b | b >> 5;
            c[1][0] = r + dr;
            c[1][1] = g + dg;
            c[1][2] = b + db;
            c[1][0] |= c[1][0] >> 5;
            c[1][1] |= c[1][1] >> 5;
            c[1][2] |= c[1][2] >> 5;
            for (int i = 0; i < 16; i++, j >>= 1, k >>= 1) {
                uint_fast8_t s = table[i];
                uint_fast8_t m = Etc1ModifierTable[code[s]][j & 1];
                outbuf[WriteOrderTable[i]] = applicate_color(c[s], k & 1 ? -m : m);
            }
        }
    } else {
        // individual (diff bit == 0)
        const uint_fast8_t code[2] = {data[3] >> 5, data[3] >> 2 & 7};
        const uint_fast8_t *table = Etc1SubblockTable[data[3] & 1];
        c[0][0] = (data[0] & 0xf0) | data[0] >> 4;
        c[1][0] = (data[0] & 0x0f) | data[0] << 4;
        c[0][1] = (data[1] & 0xf0) | data[1] >> 4;
        c[1][1] = (data[1] & 0x0f) | data[1] << 4;
        c[0][2] = (data[2] & 0xf0) | data[2] >> 4;
        c[1][2] = (data[2] & 0x0f) | data[2] << 4;
        for (int i = 0; i < 16; i++, j >>= 1, k >>= 1) {
            uint_fast8_t s = table[i];
            uint_fast8_t m = Etc1ModifierTable[code[s]][j & 1];
            outbuf[WriteOrderTable[i]] = applicate_color(c[s], k & 1 ? -m : m);
        }
    }
}

static void decode_etc2a1_block(const uint8_t *data, uint32_t *outbuf) {
    uint_fast16_t j = data[6] << 8 | data[7];  // 15 -> 0
    uint_fast32_t k = data[4] << 8 | data[5];  // 31 -> 16
    uint_fast8_t c[3][3] = {};

    int obaq = data[3] >> 1 & 1;

    // diff bit == 1
    uint_fast8_t r = data[0] & 0xf8;
    int_fast16_t dr = (data[0] << 3 & 0x18) - (data[0] << 3 & 0x20);
    uint_fast8_t g = data[1] & 0xf8;
    int_fast16_t dg = (data[1] << 3 & 0x18) - (data[1] << 3 & 0x20);
    uint_fast8_t b = data[2] & 0xf8;
    int_fast16_t db = (data[2] << 3 & 0x18) - (data[2] << 3 & 0x20);
    if (r + dr < 0 || r + dr > 255) {
        // T
        c[0][0] = (data[0] << 3 & 0xc0) | (data[0] << 4 & 0x30) | (data[0] >> 1 & 0xc) | (data[0] & 3);
        c[0][1] = (data[1] & 0xf0) | data[1] >> 4;
        c[0][2] = (data[1] & 0x0f) | data[1] << 4;
        c[1][0] = (data[2] & 0xf0) | data[2] >> 4;
        c[1][1] = (data[2] & 0x0f) | data[2] << 4;
        c[1][2] = (data[3] & 0xf0) | data[3] >> 4;
        const uint_fast8_t d = Etc2DistanceTable[(data[3] >> 1 & 6) | (data[3] & 1)];
        uint_fast32_t color_set[4] = {applicate_color_raw(c[0]), applicate_color(c[1], d), applicate_color_raw(c[1]),
                                      applicate_color(c[1], -d)};
        k <<= 1;
        for (int i = 0; i < 16; i++, j >>= 1, k >>= 1) {
            int index = (k & 2) | (j & 1);
            outbuf[WriteOrderTable[i]] = color_set[index];
            if (!obaq && index == 2)
                outbuf[WriteOrderTable[i]] &= TRANSPARENT_MASK;
        }
    } else if (g + dg < 0 || g + dg > 255) {
        // H
        c[0][0] = (data[0] << 1 & 0xf0) | (data[0] >> 3 & 0xf);
        c[0][1] = (data[0] << 5 & 0xe0) | (data[1] & 0x10);
        c[0][1] |= c[0][1] >> 4;
        c[0][2] = (data[1] & 8) | (data[1] << 1 & 6) | data[2] >> 7;
        c[0][2] |= c[0][2] << 4;
        c[1][0] = (data[2] << 1 & 0xf0) | (data[2] >> 3 & 0xf);
        c[1][1] = (data[2] << 5 & 0xe0) | (data[3] >> 3 & 0x10);
        c[1][1] |= c[1][1] >> 4;
        c[1][2] = (data[3] << 1 & 0xf0) | (data[3] >> 3 & 0xf);
        uint_fast8_t d = (data[3] & 4) | (data[3] << 1 & 2);
        if (c[0][0] > c[1][0] ||
            (c[0][0] == c[1][0] && (c[0][1] > c[1][1] || (c[0][1] == c[1][1] && c[0][2] >= c[1][2]))))
            ++d;
        d = Etc2DistanceTable[d];
        uint_fast32_t color_set[4] = {applicate_color(c[0], d), applicate_color(c[0], -d), applicate_color(c[1], d),
                                      applicate_color(c[1], -d)};
        k <<= 1;
        for (int i = 0; i < 16; i++, j >>= 1, k >>= 1) {
            int index = (k & 2) | (j & 1);
            outbuf[WriteOrderTable[i]] = color_set[index];
            if (!obaq && index == 2)
                outbuf[WriteOrderTable[i]] &= TRANSPARENT_MASK;
        }
    } else if (b + db < 0 || b + db > 255) {
        // planar
        c[0][0] = (data[0] << 1 & 0xfc) | (data[0] >> 5 & 3);
        c[0][1] = (data[0] << 7 & 0x80) | (data[1] & 0x7e) | (data[0] & 1);
        c[0][2] = (data[1] << 7 & 0x80) | (data[2] << 2 & 0x60) | (data[2] << 3 & 0x18) | (data[3] >> 5 & 4);
        c[0][2] |= c[0][2] >> 6;
        c[1][0] = (data[3] << 1 & 0xf8) | (data[3] << 2 & 4) | (data[3] >> 5 & 3);
        c[1][1] = (data[4] & 0xfe) | data[4] >> 7;
        c[1][2] = (data[4] << 7 & 0x80) | (data[5] >> 1 & 0x7c);
        c[1][2] |= c[1][2] >> 6;
        c[2][0] = (data[5] << 5 & 0xe0) | (data[6] >> 3 & 0x1c) | (data[5] >> 1 & 3);
        c[2][1] = (data[6] << 3 & 0xf8) | (data[7] >> 5 & 0x6) | (data[6] >> 4 & 1);
        c[2][2] = data[7] << 2 | (data[7] >> 4 & 3);
        for (int y = 0, i = 0; y < 4; y++) {
            for (int x = 0; x < 4; x++, i++) {
                uint8_t r = clamp((x * (c[1][0] - c[0][0]) + y * (c[2][0] - c[0][0]) + 4 * c[0][0] + 2) >> 2);
                uint8_t g = clamp((x * (c[1][1] - c[0][1]) + y * (c[2][1] - c[0][1]) + 4 * c[0][1] + 2) >> 2);
                uint8_t b = clamp((x * (c[1][2] - c[0][2]) + y * (c[2][2] - c[0][2]) + 4 * c[0][2] + 2) >> 2);
                outbuf[i] = color(r, g, b, 255);
            }
        }
    } else {
        // differential
        const uint_fast8_t code[2] = {data[3] >> 5, data[3] >> 2 & 7};
        const uint_fast8_t *table = Etc1SubblockTable[data[3] & 1];
        c[0][0] = r | r >> 5;
        c[0][1] = g | g >> 5;
        c[0][2] = b | b >> 5;
        c[1][0] = r + dr;
        c[1][1] = g + dg;
        c[1][2] = b + db;
        c[1][0] |= c[1][0] >> 5;
        c[1][1] |= c[1][1] >> 5;
        c[1][2] |= c[1][2] >> 5;
        for (int i = 0; i < 16; i++, j >>= 1, k >>= 1) {
            uint_fast8_t s = table[i];
            uint_fast8_t m = Etc2aModifierTable[obaq][code[s]][j & 1];
            outbuf[WriteOrderTable[i]] = applicate_color_alpha(c[s], k & 1 ? -m : m, !obaq && (k & 1) && !(j & 1));
        }
    }
}

static void decode_etc2a8_block(const uint8_t *data, uint32_t *outbuf) {
    if (data[1] & 0xf0) {
        // multiplier != 0
        const uint_fast8_t multiplier = data[1] >> 4;
        const int_fast8_t *table = Etc2AlphaModTable[data[1] & 0xf];
        uint_fast64_t l = bton64(*(uint64_t*)data);
        for (int i = 0; i < 16; i++, l >>= 3)
            ((uint8_t *)(outbuf + WriteOrderTableRev[i]))[3] = clamp(data[0] + multiplier * table[l & 7]);
    } else {
        // multiplier == 0 (always same as base codeword)
        for (int i = 0; i < 16; i++, outbuf++)
            ((uint8_t *)outbuf)[3] = data[0];
    }
}

static void decode_eac_block(const uint8_t *data, int color, uint32_t *outbuf) {
    uint_fast8_t multiplier = data[1] >> 1 & 0x78;
    if (multiplier == 0)
        multiplier = 1;
    const int_fast8_t *table = Etc2AlphaModTable[data[1] & 0xf];
    uint_fast64_t l = bton64(*(uint64_t*)data);
    for (int i = 0; i < 16; i++, l >>= 3) {
        int_fast16_t val = data[0] * 8 + multiplier * table[l & 7] + 4;
        ((uint8_t *)(outbuf + WriteOrderTableRev[i]))[color] = val < 0 ? 0 : val >= 2048 ? 0xff : val >> 3;
    }
}

static void decode_eac_signed_block(const uint8_t *data, int color, uint32_t *outbuf) {
    int8_t base = (int8_t)data[0];
    uint_fast8_t multiplier = data[1] >> 1 & 0x78;
    if (multiplier == 0)
        multiplier = 1;
    const int_fast8_t *table = Etc2AlphaModTable[data[1] & 0xf];
    uint_fast64_t l = bton64(*(uint64_t*)data);
    for (int i = 0; i < 16; i++, l >>= 3) {
        int_fast16_t val = base * 8 + multiplier * table[l & 7] + 1023;
        ((uint8_t *)(outbuf + WriteOrderTableRev[i]))[color] = val < 0 ? 0 : val >= 2048 ? 0xff : val >> 3;
    }
}

int decode_etc1(const uint8_t *data, const long w, const long h, uint32_t *image) {
    long num_blocks_x = (w + 3) / 4;
    long num_blocks_y = (h + 3) / 4;
    uint32_t buffer[16];
    for (long by = 0; by < num_blocks_y; by++) {
        for (long bx = 0; bx < num_blocks_x; bx++, data += 8) {
            decode_etc1_block(data, buffer);
            copy_block_buffer(bx, by, w, h, 4, 4, buffer, image);
        }
    }
    return 1;
}

int decode_etc2(const uint8_t *data, const long w, const long h, uint32_t *image) {
    long num_blocks_x = (w + 3) / 4;
    long num_blocks_y = (h + 3) / 4;
    uint32_t buffer[16];
    for (long by = 0; by < num_blocks_y; by++) {
        for (long bx = 0; bx < num_blocks_x; bx++, data += 8) {
            decode_etc2_block(data, buffer);
            copy_block_buffer(bx, by, w, h, 4, 4, buffer, image);
        }
    }
    return 1;
}

int decode_etc2a1(const uint8_t *data, const long w, const long h, uint32_t *image) {
    long num_blocks_x = (w + 3) / 4;
    long num_blocks_y = (h + 3) / 4;
    uint32_t buffer[16];
    for (long by = 0; by < num_blocks_y; by++) {
        for (long bx = 0; bx < num_blocks_x; bx++, data += 8) {
            decode_etc2a1_block(data, buffer);
            copy_block_buffer(bx, by, w, h, 4, 4, buffer, image);
        }
    }
    return 1;
}

int decode_etc2a8(const uint8_t *data, const long w, const long h, uint32_t *image) {
    long num_blocks_x = (w + 3) / 4;
    long num_blocks_y = (h + 3) / 4;
    uint32_t buffer[16];
    for (long by = 0; by < num_blocks_y; by++) {
        for (long bx = 0; bx < num_blocks_x; bx++, data += 16) {
            decode_etc2_block(data + 8, buffer);
            decode_etc2a8_block(data, buffer);
            copy_block_buffer(bx, by, w, h, 4, 4, buffer, image);
        }
    }
    return 1;
}

int decode_eacr(const uint8_t *data, const long w, const long h, uint32_t *image) {
    long num_blocks_x = (w + 3) / 4;
    long num_blocks_y = (h + 3) / 4;
    uint32_t buffer[16];
    uint32_t base_buffer[16];
    for (int i = 0; i < 16; i++)
        base_buffer[i] = color(0, 0, 0, 255);
    for (long by = 0; by < num_blocks_y; by++) {
        for (long bx = 0; bx < num_blocks_x; bx++, data += 8) {
            memcpy(buffer, base_buffer, sizeof(buffer));
            decode_eac_block(data, 2, buffer);
            copy_block_buffer(bx, by, w, h, 4, 4, buffer, image);
        }
    }
    return 1;
}

int decode_eacr_signed(const uint8_t *data, const long w, const long h, uint32_t *image) {
    long num_blocks_x = (w + 3) / 4;
    long num_blocks_y = (h + 3) / 4;
    uint32_t buffer[16];
    uint32_t base_buffer[16];
    for (int i = 0; i < 16; i++)
        base_buffer[i] = color(0, 0, 0, 255);
    for (long by = 0; by < num_blocks_y; by++) {
        for (long bx = 0; bx < num_blocks_x; bx++, data += 8) {
            memcpy(buffer, base_buffer, sizeof(buffer));
            decode_eac_signed_block(data, 2, buffer);
            copy_block_buffer(bx, by, w, h, 4, 4, buffer, image);
        }
    }
    return 1;
}

int decode_eacrg(const uint8_t *data, const long w, const long h, uint32_t *image) {
    long num_blocks_x = (w + 3) / 4;
    long num_blocks_y = (h + 3) / 4;
    uint32_t buffer[16];
    uint32_t base_buffer[16];
    for (int i = 0; i < 16; i++)
        base_buffer[i] = color(0, 0, 0, 255);
    for (long by = 0; by < num_blocks_y; by++) {
        for (long bx = 0; bx < num_blocks_x; bx++, data += 16) {
            memcpy(buffer, base_buffer, sizeof(buffer));
            decode_eac_block(data, 2, buffer);
            decode_eac_block(data + 8, 1, buffer);
            copy_block_buffer(bx, by, w, h, 4, 4, buffer, image);
        }
    }
    return 1;
}

int decode_eacrg_signed(const uint8_t *data, const long w, const long h, uint32_t *image) {
    long num_blocks_x = (w + 3) / 4;
    long num_blocks_y = (h + 3) / 4;
    uint32_t buffer[16];
    uint32_t base_buffer[16];
    for (int i = 0; i < 16; i++)
        base_buffer[i] = color(0, 0, 0, 255);
    for (long by = 0; by < num_blocks_y; by++) {
        for (long bx = 0; bx < num_blocks_x; bx++, data += 16) {
            memcpy(buffer, base_buffer, sizeof(buffer));
            decode_eac_signed_block(data, 2, buffer);
            decode_eac_signed_block(data + 8, 1, buffer);
            copy_block_buffer(bx, by, w, h, 4, 4, buffer, image);
        }
    }
    return 1;
}

```

`Texture2DDecoderNative/etc.h`:

```h
#ifndef ETC_H
#define ETC_H

#include <stdint.h>

int decode_etc1(const uint8_t *, const long, const long, uint32_t *);
int decode_etc2(const uint8_t *, const long, const long, uint32_t *);
int decode_etc2a1(const uint8_t *, const long, const long, uint32_t *);
int decode_etc2a8(const uint8_t *, const long, const long, uint32_t *);
int decode_eacr(const uint8_t *, const long, const long, uint32_t *);
int decode_eacr_signed(const uint8_t *, const long, const long, uint32_t *);
int decode_eacrg(const uint8_t *, const long, const long, uint32_t *);
int decode_eacrg_signed(const uint8_t *, const long, const long, uint32_t *);

#endif /* end of include guard: ETC_H */

```

`Texture2DDecoderNative/fp16.h`:

```h
#pragma once
#ifndef FP16_H
#define FP16_H

#include "fp16/fp16.h"

#endif /* FP16_H */

/*
 *
 * License Information
 *
 * FP16 library is derived from https://github.com/Maratyszcza/FP16.
 * The library is licensed under the MIT License shown below.
 *
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2017 Facebook Inc.
 * Copyright (c) 2017 Georgia Institute of Technology
 * Copyright 2019 Google LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

```

`Texture2DDecoderNative/fp16/bitcasts.h`:

```h
#pragma once
#ifndef FP16_BITCASTS_H
#define FP16_BITCASTS_H

#if defined(__cplusplus) && (__cplusplus >= 201103L)
	#include <cstdint>
#elif !defined(__OPENCL_VERSION__)
	#include <stdint.h>
#endif


static inline float fp32_from_bits(uint32_t w) {
#if defined(__OPENCL_VERSION__)
	return as_float(w);
#elif defined(__CUDA_ARCH__)
	return __uint_as_float((unsigned int) w);
#elif defined(__INTEL_COMPILER)
	return _castu32_f32(w);
#else
	union {
		uint32_t as_bits;
		float as_value;
	} fp32 = { w };
	return fp32.as_value;
#endif
}

static inline uint32_t fp32_to_bits(float f) {
#if defined(__OPENCL_VERSION__)
	return as_uint(f);
#elif defined(__CUDA_ARCH__)
	return (uint32_t) __float_as_uint(f);
#elif defined(__INTEL_COMPILER)
	return _castf32_u32(f);
#else
	union {
		float as_value;
		uint32_t as_bits;
	} fp32 = { f };
	return fp32.as_bits;
#endif
}

static inline double fp64_from_bits(uint64_t w) {
#if defined(__OPENCL_VERSION__)
	return as_double(w);
#elif defined(__CUDA_ARCH__)
	return __longlong_as_double((long long) w);
#elif defined(__INTEL_COMPILER)
	return _castu64_f64(w);
#else
	union {
		uint64_t as_bits;
		double as_value;
	} fp64 = { w };
	return fp64.as_value;
#endif
}

static inline uint64_t fp64_to_bits(double f) {
#if defined(__OPENCL_VERSION__)
	return as_ulong(f);
#elif defined(__CUDA_ARCH__)
	return (uint64_t) __double_as_longlong(f);
#elif defined(__INTEL_COMPILER)
	return _castf64_u64(f);
#else
	union {
		double as_value;
		uint64_t as_bits;
	} fp64 = { f };
	return fp64.as_bits;
#endif
}

#endif /* FP16_BITCASTS_H */

```

`Texture2DDecoderNative/fp16/fp16.h`:

```h
#pragma once
#ifndef FP16_FP16_H
#define FP16_FP16_H

#if defined(__cplusplus) && (__cplusplus >= 201103L)
	#include <cstdint>
	#include <cmath>
#elif !defined(__OPENCL_VERSION__)
	#include <stdint.h>
	#include <math.h>
#endif

#ifdef _MSC_VER
	#include <intrin.h>
#endif

#include "fp16/bitcasts.h"


/*
 * Convert a 16-bit floating-point number in IEEE half-precision format, in bit representation, to
 * a 32-bit floating-point number in IEEE single-precision format, in bit representation.
 *
 * @note The implementation doesn't use any floating-point operations.
 */
static inline uint32_t fp16_ieee_to_fp32_bits(uint16_t h) {
	/*
	 * Extend the half-precision floating-point number to 32 bits and shift to the upper part of the 32-bit word:
	 *      +---+-----+------------+-------------------+
	 *      | S |EEEEE|MM MMMM MMMM|0000 0000 0000 0000|
	 *      +---+-----+------------+-------------------+
	 * Bits  31  26-30    16-25            0-15
	 *
	 * S - sign bit, E - bits of the biased exponent, M - bits of the mantissa, 0 - zero bits.
	 */
	const uint32_t w = (uint32_t) h << 16;
	/*
	 * Extract the sign of the input number into the high bit of the 32-bit word:
	 *
	 *      +---+----------------------------------+
	 *      | S |0000000 00000000 00000000 00000000|
	 *      +---+----------------------------------+
	 * Bits  31                 0-31
	 */
	const uint32_t sign = w & UINT32_C(0x80000000);
	/*
	 * Extract mantissa and biased exponent of the input number into the bits 0-30 of the 32-bit word:
	 *
	 *      +---+-----+------------+-------------------+
	 *      | 0 |EEEEE|MM MMMM MMMM|0000 0000 0000 0000|
	 *      +---+-----+------------+-------------------+
	 * Bits  30  27-31     17-26            0-16
	 */
	const uint32_t nonsign = w & UINT32_C(0x7FFFFFFF);
	/*
	 * Renorm shift is the number of bits to shift mantissa left to make the half-precision number normalized.
	 * If the initial number is normalized, some of its high 6 bits (sign == 0 and 5-bit exponent) equals one.
	 * In this case renorm_shift == 0. If the number is denormalize, renorm_shift > 0. Note that if we shift
	 * denormalized nonsign by renorm_shift, the unit bit of mantissa will shift into exponent, turning the
	 * biased exponent into 1, and making mantissa normalized (i.e. without leading 1).
	 */
#ifdef _MSC_VER
	unsigned long nonsign_bsr;
	_BitScanReverse(&nonsign_bsr, (unsigned long) nonsign);
	uint32_t renorm_shift = (uint32_t) nonsign_bsr ^ 31;
#else
	uint32_t renorm_shift = __builtin_clz(nonsign);
#endif
	renorm_shift = renorm_shift > 5 ? renorm_shift - 5 : 0;
	/*
	 * Iff half-precision number has exponent of 15, the addition overflows it into bit 31,
	 * and the subsequent shift turns the high 9 bits into 1. Thus
	 *   inf_nan_mask ==
	 *                   0x7F800000 if the half-precision number had exponent of 15 (i.e. was NaN or infinity)
	 *                   0x00000000 otherwise
	 */
	const int32_t inf_nan_mask = ((int32_t) (nonsign + 0x04000000) >> 8) & INT32_C(0x7F800000);
	/*
	 * Iff nonsign is 0, it overflows into 0xFFFFFFFF, turning bit 31 into 1. Otherwise, bit 31 remains 0.
	 * The signed shift right by 31 broadcasts bit 31 into all bits of the zero_mask. Thus
	 *   zero_mask ==
	 *                0xFFFFFFFF if the half-precision number was zero (+0.0h or -0.0h)
	 *                0x00000000 otherwise
	 */
	const int32_t zero_mask = (int32_t) (nonsign - 1) >> 31;
	/*
	 * 1. Shift nonsign left by renorm_shift to normalize it (if the input was denormal)
	 * 2. Shift nonsign right by 3 so the exponent (5 bits originally) becomes an 8-bit field and 10-bit mantissa
	 *    shifts into the 10 high bits of the 23-bit mantissa of IEEE single-precision number.
	 * 3. Add 0x70 to the exponent (starting at bit 23) to compensate the different in exponent bias
	 *    (0x7F for single-precision number less 0xF for half-precision number).
	 * 4. Subtract renorm_shift from the exponent (starting at bit 23) to account for renormalization. As renorm_shift
	 *    is less than 0x70, this can be combined with step 3.
	 * 5. Binary OR with inf_nan_mask to turn the exponent into 0xFF if the input was NaN or infinity.
	 * 6. Binary ANDNOT with zero_mask to turn the mantissa and exponent into zero if the input was zero.
	 * 7. Combine with the sign of the input number.
	 */
	return sign | ((((nonsign << renorm_shift >> 3) + ((0x70 - renorm_shift) << 23)) | inf_nan_mask) & ~zero_mask);
}

/*
 * Convert a 16-bit floating-point number in IEEE half-precision format, in bit representation, to
 * a 32-bit floating-point number in IEEE single-precision format.
 *
 * @note The implementation relies on IEEE-like (no assumption about rounding mode and no operations on denormals)
 * floating-point operations and bitcasts between integer and floating-point variables.
 */
static inline float fp16_ieee_to_fp32_value(uint16_t h) {
	/*
	 * Extend the half-precision floating-point number to 32 bits and shift to the upper part of the 32-bit word:
	 *      +---+-----+------------+-------------------+
	 *      | S |EEEEE|MM MMMM MMMM|0000 0000 0000 0000|
	 *      +---+-----+------------+-------------------+
	 * Bits  31  26-30    16-25            0-15
	 *
	 * S - sign bit, E - bits of the biased exponent, M - bits of the mantissa, 0 - zero bits.
	 */
	const uint32_t w = (uint32_t) h << 16;
	/*
	 * Extract the sign of the input number into the high bit of the 32-bit word:
	 *
	 *      +---+----------------------------------+
	 *      | S |0000000 00000000 00000000 00000000|
	 *      +---+----------------------------------+
	 * Bits  31                 0-31
	 */
	const uint32_t sign = w & UINT32_C(0x80000000);
	/*
	 * Extract mantissa and biased exponent of the input number into the high bits of the 32-bit word:
	 *
	 *      +-----+------------+---------------------+
	 *      |EEEEE|MM MMMM MMMM|0 0000 0000 0000 0000|
	 *      +-----+------------+---------------------+
	 * Bits  27-31    17-26            0-16
	 */
	const uint32_t two_w = w + w;

	/*
	 * Shift mantissa and exponent into bits 23-28 and bits 13-22 so they become mantissa and exponent
	 * of a single-precision floating-point number:
	 *
	 *       S|Exponent |          Mantissa
	 *      +-+---+-----+------------+----------------+
	 *      |0|000|EEEEE|MM MMMM MMMM|0 0000 0000 0000|
	 *      +-+---+-----+------------+----------------+
	 * Bits   | 23-31   |           0-22
	 *
	 * Next, there are some adjustments to the exponent:
	 * - The exponent needs to be corrected by the difference in exponent bias between single-precision and half-precision
	 *   formats (0x7F - 0xF = 0x70)
	 * - Inf and NaN values in the inputs should become Inf and NaN values after conversion to the single-precision number.
	 *   Therefore, if the biased exponent of the half-precision input was 0x1F (max possible value), the biased exponent
	 *   of the single-precision output must be 0xFF (max possible value). We do this correction in two steps:
	 *   - First, we adjust the exponent by (0xFF - 0x1F) = 0xE0 (see exp_offset below) rather than by 0x70 suggested
	 *     by the difference in the exponent bias (see above).
	 *   - Then we multiply the single-precision result of exponent adjustment by 2**(-112) to reverse the effect of
	 *     exponent adjustment by 0xE0 less the necessary exponent adjustment by 0x70 due to difference in exponent bias.
	 *     The floating-point multiplication hardware would ensure than Inf and NaN would retain their value on at least
	 *     partially IEEE754-compliant implementations.
	 *
	 * Note that the above operations do not handle denormal inputs (where biased exponent == 0). However, they also do not
	 * operate on denormal inputs, and do not produce denormal results.
	 */
	const uint32_t exp_offset = UINT32_C(0xE0) << 23;
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) || defined(__GNUC__) && !defined(__STRICT_ANSI__)
	const float exp_scale = 0x1.0p-112f;
#else
	const float exp_scale = fp32_from_bits(UINT32_C(0x7800000));
#endif
	const float normalized_value = fp32_from_bits((two_w >> 4) + exp_offset) * exp_scale;

	/*
	 * Convert denormalized half-precision inputs into single-precision results (always normalized).
	 * Zero inputs are also handled here.
	 *
	 * In a denormalized number the biased exponent is zero, and mantissa has on-zero bits.
	 * First, we shift mantissa into bits 0-9 of the 32-bit word.
	 *
	 *                  zeros           |  mantissa
	 *      +---------------------------+------------+
	 *      |0000 0000 0000 0000 0000 00|MM MMMM MMMM|
	 *      +---------------------------+------------+
	 * Bits             10-31                0-9
	 *
	 * Now, remember that denormalized half-precision numbers are represented as:
	 *    FP16 = mantissa * 2**(-24).
	 * The trick is to construct a normalized single-precision number with the same mantissa and thehalf-precision input
	 * and with an exponent which would scale the corresponding mantissa bits to 2**(-24).
	 * A normalized single-precision floating-point number is represented as:
	 *    FP32 = (1 + mantissa * 2**(-23)) * 2**(exponent - 127)
	 * Therefore, when the biased exponent is 126, a unit change in the mantissa of the input denormalized half-precision
	 * number causes a change of the constructud single-precision number by 2**(-24), i.e. the same ammount.
	 *
	 * The last step is to adjust the bias of the constructed single-precision number. When the input half-precision number
	 * is zero, the constructed single-precision number has the value of
	 *    FP32 = 1 * 2**(126 - 127) = 2**(-1) = 0.5
	 * Therefore, we need to subtract 0.5 from the constructed single-precision number to get the numerical equivalent of
	 * the input half-precision number.
	 */
	const uint32_t magic_mask = UINT32_C(126) << 23;
	const float magic_bias = 0.5f;
	const float denormalized_value = fp32_from_bits((two_w >> 17) | magic_mask) - magic_bias;

	/*
	 * - Choose either results of conversion of input as a normalized number, or as a denormalized number, depending on the
	 *   input exponent. The variable two_w contains input exponent in bits 27-31, therefore if its smaller than 2**27, the
	 *   input is either a denormal number, or zero.
	 * - Combine the result of conversion of exponent and mantissa with the sign of the input number.
	 */
	const uint32_t denormalized_cutoff = UINT32_C(1) << 27;
	const uint32_t result = sign |
		(two_w < denormalized_cutoff ? fp32_to_bits(denormalized_value) : fp32_to_bits(normalized_value));
	return fp32_from_bits(result);
}

/*
 * Convert a 32-bit floating-point number in IEEE single-precision format to a 16-bit floating-point number in
 * IEEE half-precision format, in bit representation.
 *
 * @note The implementation relies on IEEE-like (no assumption about rounding mode and no operations on denormals)
 * floating-point operations and bitcasts between integer and floating-point variables.
 */
static inline uint16_t fp16_ieee_from_fp32_value(float f) {
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) || defined(__GNUC__) && !defined(__STRICT_ANSI__)
	const float scale_to_inf = 0x1.0p+112f;
	const float scale_to_zero = 0x1.0p-110f;
#else
	const float scale_to_inf = fp32_from_bits(UINT32_C(0x77800000));
	const float scale_to_zero = fp32_from_bits(UINT32_C(0x08800000));
#endif
	float base = (fabsf(f) * scale_to_inf) * scale_to_zero;

	const uint32_t w = fp32_to_bits(f);
	const uint32_t shl1_w = w + w;
	const uint32_t sign = w & UINT32_C(0x80000000);
	uint32_t bias = shl1_w & UINT32_C(0xFF000000);
	if (bias < UINT32_C(0x71000000)) {
		bias = UINT32_C(0x71000000);
	}

	base = fp32_from_bits((bias >> 1) + UINT32_C(0x07800000)) + base;
	const uint32_t bits = fp32_to_bits(base);
	const uint32_t exp_bits = (bits >> 13) & UINT32_C(0x00007C00);
	const uint32_t mantissa_bits = bits & UINT32_C(0x00000FFF);
	const uint32_t nonsign = exp_bits + mantissa_bits;
	return (sign >> 16) | (shl1_w > UINT32_C(0xFF000000) ? UINT16_C(0x7E00) : nonsign);
}

/*
 * Convert a 16-bit floating-point number in ARM alternative half-precision format, in bit representation, to
 * a 32-bit floating-point number in IEEE single-precision format, in bit representation.
 *
 * @note The implementation doesn't use any floating-point operations.
 */
static inline uint32_t fp16_alt_to_fp32_bits(uint16_t h) {
	/*
	 * Extend the half-precision floating-point number to 32 bits and shift to the upper part of the 32-bit word:
	 *      +---+-----+------------+-------------------+
	 *      | S |EEEEE|MM MMMM MMMM|0000 0000 0000 0000|
	 *      +---+-----+------------+-------------------+
	 * Bits  31  26-30    16-25            0-15
	 *
	 * S - sign bit, E - bits of the biased exponent, M - bits of the mantissa, 0 - zero bits.
	 */
	const uint32_t w = (uint32_t) h << 16;
	/*
	 * Extract the sign of the input number into the high bit of the 32-bit word:
	 *
	 *      +---+----------------------------------+
	 *      | S |0000000 00000000 00000000 00000000|
	 *      +---+----------------------------------+
	 * Bits  31                 0-31
	 */
	const uint32_t sign = w & UINT32_C(0x80000000);
	/*
	 * Extract mantissa and biased exponent of the input number into the bits 0-30 of the 32-bit word:
	 *
	 *      +---+-----+------------+-------------------+
	 *      | 0 |EEEEE|MM MMMM MMMM|0000 0000 0000 0000|
	 *      +---+-----+------------+-------------------+
	 * Bits  30  27-31     17-26            0-16
	 */
	const uint32_t nonsign = w & UINT32_C(0x7FFFFFFF);
	/*
	 * Renorm shift is the number of bits to shift mantissa left to make the half-precision number normalized.
	 * If the initial number is normalized, some of its high 6 bits (sign == 0 and 5-bit exponent) equals one.
	 * In this case renorm_shift == 0. If the number is denormalize, renorm_shift > 0. Note that if we shift
	 * denormalized nonsign by renorm_shift, the unit bit of mantissa will shift into exponent, turning the
	 * biased exponent into 1, and making mantissa normalized (i.e. without leading 1).
	 */
#ifdef _MSC_VER
	unsigned long nonsign_bsr;
	_BitScanReverse(&nonsign_bsr, (unsigned long) nonsign);
	uint32_t renorm_shift = (uint32_t) nonsign_bsr ^ 31;
#else
	uint32_t renorm_shift = __builtin_clz(nonsign);
#endif
	renorm_shift = renorm_shift > 5 ? renorm_shift - 5 : 0;
	/*
	 * Iff nonsign is 0, it overflows into 0xFFFFFFFF, turning bit 31 into 1. Otherwise, bit 31 remains 0.
	 * The signed shift right by 31 broadcasts bit 31 into all bits of the zero_mask. Thus
	 *   zero_mask ==
	 *                0xFFFFFFFF if the half-precision number was zero (+0.0h or -0.0h)
	 *                0x00000000 otherwise
	 */
	const int32_t zero_mask = (int32_t) (nonsign - 1) >> 31;
	/*
	 * 1. Shift nonsign left by renorm_shift to normalize it (if the input was denormal)
	 * 2. Shift nonsign right by 3 so the exponent (5 bits originally) becomes an 8-bit field and 10-bit mantissa
	 *    shifts into the 10 high bits of the 23-bit mantissa of IEEE single-precision number.
	 * 3. Add 0x70 to the exponent (starting at bit 23) to compensate the different in exponent bias
	 *    (0x7F for single-precision number less 0xF for half-precision number).
	 * 4. Subtract renorm_shift from the exponent (starting at bit 23) to account for renormalization. As renorm_shift
	 *    is less than 0x70, this can be combined with step 3.
	 * 5. Binary ANDNOT with zero_mask to turn the mantissa and exponent into zero if the input was zero.
	 * 6. Combine with the sign of the input number.
	 */
	return sign | (((nonsign << renorm_shift >> 3) + ((0x70 - renorm_shift) << 23)) & ~zero_mask);
}

/*
 * Convert a 16-bit floating-point number in ARM alternative half-precision format, in bit representation, to
 * a 32-bit floating-point number in IEEE single-precision format.
 *
 * @note The implementation relies on IEEE-like (no assumption about rounding mode and no operations on denormals)
 * floating-point operations and bitcasts between integer and floating-point variables.
 */
static inline float fp16_alt_to_fp32_value(uint16_t h) {
	/*
	 * Extend the half-precision floating-point number to 32 bits and shift to the upper part of the 32-bit word:
	 *      +---+-----+------------+-------------------+
	 *      | S |EEEEE|MM MMMM MMMM|0000 0000 0000 0000|
	 *      +---+-----+------------+-------------------+
	 * Bits  31  26-30    16-25            0-15
	 *
	 * S - sign bit, E - bits of the biased exponent, M - bits of the mantissa, 0 - zero bits.
	 */
	const uint32_t w = (uint32_t) h << 16;
	/*
	 * Extract the sign of the input number into the high bit of the 32-bit word:
	 *
	 *      +---+----------------------------------+
	 *      | S |0000000 00000000 00000000 00000000|
	 *      +---+----------------------------------+
	 * Bits  31                 0-31
	 */
	const uint32_t sign = w & UINT32_C(0x80000000);
	/*
	 * Extract mantissa and biased exponent of the input number into the high bits of the 32-bit word:
	 *
	 *      +-----+------------+---------------------+
	 *      |EEEEE|MM MMMM MMMM|0 0000 0000 0000 0000|
	 *      +-----+------------+---------------------+
	 * Bits  27-31    17-26            0-16
	 */
	const uint32_t two_w = w + w;

	/*
	 * Shift mantissa and exponent into bits 23-28 and bits 13-22 so they become mantissa and exponent
	 * of a single-precision floating-point number:
	 *
	 *       S|Exponent |          Mantissa
	 *      +-+---+-----+------------+----------------+
	 *      |0|000|EEEEE|MM MMMM MMMM|0 0000 0000 0000|
	 *      +-+---+-----+------------+----------------+
	 * Bits   | 23-31   |           0-22
	 *
	 * Next, the exponent is adjusted for the difference in exponent bias between single-precision and half-precision
	 * formats (0x7F - 0xF = 0x70). This operation never overflows or generates non-finite values, as the largest
	 * half-precision exponent is 0x1F and after the adjustment is can not exceed 0x8F < 0xFE (largest single-precision
	 * exponent for non-finite values).
	 *
	 * Note that this operation does not handle denormal inputs (where biased exponent == 0). However, they also do not
	 * operate on denormal inputs, and do not produce denormal results.
	 */
	const float exp_offset = UINT32_C(0x70) << 23;
	const float normalized_value = fp32_from_bits((two_w >> 4) + exp_offset);

	/*
	 * Convert denormalized half-precision inputs into single-precision results (always normalized).
	 * Zero inputs are also handled here.
	 *
	 * In a denormalized number the biased exponent is zero, and mantissa has on-zero bits.
	 * First, we shift mantissa into bits 0-9 of the 32-bit word.
	 *
	 *                  zeros           |  mantissa
	 *      +---------------------------+------------+
	 *      |0000 0000 0000 0000 0000 00|MM MMMM MMMM|
	 *      +---------------------------+------------+
	 * Bits             10-31                0-9
	 *
	 * Now, remember that denormalized half-precision numbers are represented as:
	 *    FP16 = mantissa * 2**(-24).
	 * The trick is to construct a normalized single-precision number with the same mantissa and thehalf-precision input
	 * and with an exponent which would scale the corresponding mantissa bits to 2**(-24).
	 * A normalized single-precision floating-point number is represented as:
	 *    FP32 = (1 + mantissa * 2**(-23)) * 2**(exponent - 127)
	 * Therefore, when the biased exponent is 126, a unit change in the mantissa of the input denormalized half-precision
	 * number causes a change of the constructud single-precision number by 2**(-24), i.e. the same ammount.
	 *
	 * The last step is to adjust the bias of the constructed single-precision number. When the input half-precision number
	 * is zero, the constructed single-precision number has the value of
	 *    FP32 = 1 * 2**(126 - 127) = 2**(-1) = 0.5
	 * Therefore, we need to subtract 0.5 from the constructed single-precision number to get the numerical equivalent of
	 * the input half-precision number.
	 */
	const uint32_t magic_mask = UINT32_C(126) << 23;
	const float magic_bias = 0.5f;
	const float denormalized_value = fp32_from_bits((two_w >> 17) | magic_mask) - magic_bias;

	/*
	 * - Choose either results of conversion of input as a normalized number, or as a denormalized number, depending on the
	 *   input exponent. The variable two_w contains input exponent in bits 27-31, therefore if its smaller than 2**27, the
	 *   input is either a denormal number, or zero.
	 * - Combine the result of conversion of exponent and mantissa with the sign of the input number.
	 */
	const uint32_t denormalized_cutoff = UINT32_C(1) << 27;
	const uint32_t result = sign |
		(two_w < denormalized_cutoff ? fp32_to_bits(denormalized_value) : fp32_to_bits(normalized_value));
	return fp32_from_bits(result);
}

/*
 * Convert a 32-bit floating-point number in IEEE single-precision format to a 16-bit floating-point number in
 * ARM alternative half-precision format, in bit representation.
 *
 * @note The implementation relies on IEEE-like (no assumption about rounding mode and no operations on denormals)
 * floating-point operations and bitcasts between integer and floating-point variables.
 */
static inline uint16_t fp16_alt_from_fp32_value(float f) {
	const uint32_t w = fp32_to_bits(f);
	const uint32_t sign = w & UINT32_C(0x80000000);
	const uint32_t shl1_w = w + w;

	const uint32_t shl1_max_fp16_fp32 = UINT32_C(0x8FFFC000);
	const uint32_t shl1_base = shl1_w > shl1_max_fp16_fp32 ? shl1_max_fp16_fp32 : shl1_w;
	uint32_t shl1_bias = shl1_base & UINT32_C(0xFF000000);
	const uint32_t exp_difference = 23 - 10;
	const uint32_t shl1_bias_min = (127 - 1 - exp_difference) << 24;
	if (shl1_bias < shl1_bias_min) {
		shl1_bias = shl1_bias_min;
	}

	const float bias = fp32_from_bits((shl1_bias >> 1) + ((exp_difference + 2) << 23));
	const float base = fp32_from_bits((shl1_base >> 1) + (2 << 23)) + bias;

	const uint32_t exp_f = fp32_to_bits(base) >> 13;
	return (sign >> 16) | ((exp_f & UINT32_C(0x00007C00)) + (fp32_to_bits(base) & UINT32_C(0x00000FFF)));
}

#endif /* FP16_FP16_H */

```

`Texture2DDecoderNative/pvrtc.cpp`:

```cpp
#include "pvrtc.h"
#include <stdint.h>
#include <string.h>
#include "color.h"
#include "endianness.h"

static const int PVRTC1_STANDARD_WEIGHT[] = {0, 3, 5, 8};
static const int PVRTC1_PUNCHTHROUGH_WEIGHT[] = {0, 4, 4, 8};

static inline long morton_index(const long x, const long y, const long min_dim) {
    long offset = 0, shift = 0;
    for (long mask = 1; mask < min_dim; mask <<= 1, shift++)
        offset |= (((y & mask) | ((x & mask) << 1))) << shift;
    offset |= ((x | y) >> shift) << (shift * 2);
    return offset;
}

static void get_texel_colors(const uint8_t *data, PVRTCTexelInfo *info) {
    uint16_t ca = lton16(*(uint16_t *)(data + 4));
    uint16_t cb = lton16(*(uint16_t *)(data + 6));
    if (ca & 0x8000) {
        info->a.r = ca >> 10 & 0x1f;
        info->a.g = ca >> 5 & 0x1f;
        info->a.b = (ca & 0x1e) | (ca >> 4 & 1);
        info->a.a = 0xf;
    } else {
        info->a.r = (ca >> 7 & 0x1e) | (ca >> 11 & 1);
        info->a.g = (ca >> 3 & 0x1e) | (ca >> 7 & 1);
        info->a.b = (ca << 1 & 0x1c) | (ca >> 2 & 3);
        info->a.a = ca >> 11 & 0xe;
    }
    if (cb & 0x8000) {
        info->b.r = cb >> 10 & 0x1f;
        info->b.g = cb >> 5 & 0x1f;
        info->b.b = cb & 0x1f;
        info->b.a = 0xf;
    } else {
        info->b.r = (cb >> 7 & 0x1e) | (cb >> 11 & 1);
        info->b.g = (cb >> 3 & 0x1e) | (cb >> 7 & 1);
        info->b.b = (cb << 1 & 0x1e) | (cb >> 3 & 1);
        info->b.a = cb >> 11 & 0xe;
    }
}

static void get_texel_weights_4bpp(const uint8_t *data, PVRTCTexelInfo *info) {
    info->punch_through_flag = 0;

    int mod_mode = data[4] & 1;
    uint32_t mod_bits = lton32(*(uint32_t *)data);

    if (mod_mode) {
        for (int i = 0; i < 16; i++, mod_bits >>= 2) {
            info->weight[i] = PVRTC1_PUNCHTHROUGH_WEIGHT[mod_bits & 3];
            if ((mod_bits & 3) == 2)
                info->punch_through_flag |= 1 << i;
        }
    } else {
        for (int i = 0; i < 16; i++, mod_bits >>= 2)
            info->weight[i] = PVRTC1_STANDARD_WEIGHT[mod_bits & 3];
    }
}

static void get_texel_weights_2bpp(const uint8_t *data, PVRTCTexelInfo *info) {
    info->punch_through_flag = 0;

    int mod_mode = data[4] & 1;
    uint32_t mod_bits = lton32(*(uint32_t *)data);

    if (mod_mode) {
        int fillflag = data[0] & 1 ? (data[2] & 0x10 ? -1 : -2) : -3;
        for (int y = 0, i = 1; y < 4; ++y & 1 ? --i : ++i)
            for (int x = 0; x < 4; x++, i += 2)
                info->weight[i] = fillflag;
        for (int y = 0, i = 0; y < 4; ++y & 1 ? ++i : --i)
            for (int x = 0; x < 4; x++, i += 2, mod_bits >>= 2)
                info->weight[i] = PVRTC1_STANDARD_WEIGHT[mod_bits & 3];
        info->weight[0] = (info->weight[0] + 3) & 8;
        if (data[0] & 1)
            info->weight[20] = (info->weight[20] + 3) & 8;
    } else {
        for (int i = 0; i < 32; i++, mod_bits >>= 1)
            info->weight[i] = mod_bits & 1 ? 8 : 0;
    }
}

static void applicate_color_4bpp(const uint8_t *data, PVRTCTexelInfo *const info[9], uint32_t buf[32]) {
    static const int INTERP_WEIGHT[4][3] = {{2, 2, 0}, {1, 3, 0}, {0, 4, 0}, {0, 3, 1}};
    PVRTCTexelColorInt clr_a[16] = {}, clr_b[16] = {};

    for (int y = 0, i = 0; y < 4; y++) {
        for (int x = 0; x < 4; x++, i++) {
            for (int acy = 0, ac = 0; acy < 3; acy++) {
                for (int acx = 0; acx < 3; acx++, ac++) {
                    int interp_weight = INTERP_WEIGHT[x][acx] * INTERP_WEIGHT[y][acy];
                    clr_a[i].r += info[ac]->a.r * interp_weight;
                    clr_a[i].g += info[ac]->a.g * interp_weight;
                    clr_a[i].b += info[ac]->a.b * interp_weight;
                    clr_a[i].a += info[ac]->a.a * interp_weight;
                    clr_b[i].r += info[ac]->b.r * interp_weight;
                    clr_b[i].g += info[ac]->b.g * interp_weight;
                    clr_b[i].b += info[ac]->b.b * interp_weight;
                    clr_b[i].a += info[ac]->b.a * interp_weight;
                }
            }
            clr_a[i].r = (clr_a[i].r >> 1) + (clr_a[i].r >> 6);
            clr_a[i].g = (clr_a[i].g >> 1) + (clr_a[i].g >> 6);
            clr_a[i].b = (clr_a[i].b >> 1) + (clr_a[i].b >> 6);
            clr_a[i].a = (clr_a[i].a) + (clr_a[i].a >> 4);
            clr_b[i].r = (clr_b[i].r >> 1) + (clr_b[i].r >> 6);
            clr_b[i].g = (clr_b[i].g >> 1) + (clr_b[i].g >> 6);
            clr_b[i].b = (clr_b[i].b >> 1) + (clr_b[i].b >> 6);
            clr_b[i].a = (clr_b[i].a) + (clr_b[i].a >> 4);
        }
    }

    const PVRTCTexelInfo *self_info = info[4];
    uint32_t punch_through_flag = self_info->punch_through_flag;
    for (int i = 0; i < 16; i++, punch_through_flag >>= 1) {
        buf[i] = color((clr_a[i].r * (8 - self_info->weight[i]) + clr_b[i].r * self_info->weight[i]) / 8,
                       (clr_a[i].g * (8 - self_info->weight[i]) + clr_b[i].g * self_info->weight[i]) / 8,
                       (clr_a[i].b * (8 - self_info->weight[i]) + clr_b[i].b * self_info->weight[i]) / 8,
                       punch_through_flag & 1
                         ? 0
                         : (clr_a[i].a * (8 - self_info->weight[i]) + clr_b[i].a * self_info->weight[i]) / 8);
    }
}

static void applicate_color_2bpp(const uint8_t *data, PVRTCTexelInfo *const info[9], uint32_t buf[32]) {
    static const int INTERP_WEIGHT_X[8][3] = {{4, 4, 0}, {3, 5, 0}, {2, 6, 0}, {1, 7, 0},
                                              {0, 8, 0}, {0, 7, 1}, {0, 6, 2}, {0, 5, 3}};
    static const int INTERP_WEIGHT_Y[4][3] = {{2, 2, 0}, {1, 3, 0}, {0, 4, 0}, {0, 3, 1}};
    PVRTCTexelColorInt clr_a[32] = {}, clr_b[32] = {};

    for (int y = 0, i = 0; y < 4; y++) {
        for (int x = 0; x < 8; x++, i++) {
            for (int acy = 0, ac = 0; acy < 3; acy++) {
                for (int acx = 0; acx < 3; acx++, ac++) {
                    int interp_weight = INTERP_WEIGHT_X[x][acx] * INTERP_WEIGHT_Y[y][acy];
                    clr_a[i].r += info[ac]->a.r * interp_weight;
                    clr_a[i].g += info[ac]->a.g * interp_weight;
                    clr_a[i].b += info[ac]->a.b * interp_weight;
                    clr_a[i].a += info[ac]->a.a * interp_weight;
                    clr_b[i].r += info[ac]->b.r * interp_weight;
                    clr_b[i].g += info[ac]->b.g * interp_weight;
                    clr_b[i].b += info[ac]->b.b * interp_weight;
                    clr_b[i].a += info[ac]->b.a * interp_weight;
                }
            }
            clr_a[i].r = (clr_a[i].r >> 2) + (clr_a[i].r >> 7);
            clr_a[i].g = (clr_a[i].g >> 2) + (clr_a[i].g >> 7);
            clr_a[i].b = (clr_a[i].b >> 2) + (clr_a[i].b >> 7);
            clr_a[i].a = (clr_a[i].a >> 1) + (clr_a[i].a >> 5);
            clr_b[i].r = (clr_b[i].r >> 2) + (clr_b[i].r >> 7);
            clr_b[i].g = (clr_b[i].g >> 2) + (clr_b[i].g >> 7);
            clr_b[i].b = (clr_b[i].b >> 2) + (clr_b[i].b >> 7);
            clr_b[i].a = (clr_b[i].a >> 1) + (clr_b[i].a >> 5);
        }
    }

    static const int POSYA[4][2] = {{1, 24}, {4, -8}, {4, -8}, {4, -8}};
    static const int POSYB[4][2] = {{4, 8}, {4, 8}, {4, 8}, {7, -24}};
    static const int POSXL[8][2] = {{3, 7}, {4, -1}, {4, -1}, {4, -1}, {4, -1}, {4, -1}, {4, -1}, {4, -1}};
    static const int POSXR[8][2] = {{4, 1}, {4, 1}, {4, 1}, {4, 1}, {4, 1}, {4, 1}, {4, 1}, {5, -7}};

    PVRTCTexelInfo *self_info = info[4];
    uint32_t punch_through_flag = self_info->punch_through_flag;
    for (int y = 0, i = 0; y < 4; y++) {
        for (int x = 0; x < 8; x++, i++, punch_through_flag >>= 1) {
            switch (self_info->weight[i]) {
            case -1:
                self_info->weight[i] =
                  (info[POSYA[y][0]]->weight[i + POSYA[y][1]] + info[POSYB[y][0]]->weight[i + POSYB[y][1]] + 1) / 2;
                break;
            case -2:
                self_info->weight[i] =
                  (info[POSXL[x][0]]->weight[i + POSXL[x][1]] + info[POSXR[x][0]]->weight[i + POSXR[x][1]] + 1) / 2;
                break;
            case -3:
                self_info->weight[i] =
                  (info[POSYA[y][0]]->weight[i + POSYA[y][1]] + info[POSYB[y][0]]->weight[i + POSYB[y][1]] +
                   info[POSXL[x][0]]->weight[i + POSXL[x][1]] + info[POSXR[x][0]]->weight[i + POSXR[x][1]] + 2) /
                  4;
                break;
            }
            buf[i] = color((clr_a[i].r * (8 - self_info->weight[i]) + clr_b[i].r * self_info->weight[i]) / 8,
                           (clr_a[i].g * (8 - self_info->weight[i]) + clr_b[i].g * self_info->weight[i]) / 8,
                           (clr_a[i].b * (8 - self_info->weight[i]) + clr_b[i].b * self_info->weight[i]) / 8,
                           punch_through_flag & 1
                             ? 0
                             : (clr_a[i].a * (8 - self_info->weight[i]) + clr_b[i].a * self_info->weight[i]) / 8);
        }
    }
}

int decode_pvrtc(const uint8_t *data, const long w, const long h, uint32_t *image, const int is2bpp) {
    long bw = is2bpp ? 8 : 4;
    long num_blocks_x = is2bpp ? (w + 7) / 8 : (w + 3) / 4;
    long num_blocks_y = (h + 3) / 4;
    long num_blocks = num_blocks_x * num_blocks_y;
    long min_num_blocks = num_blocks_x <= num_blocks_y ? num_blocks_x : num_blocks_y;

    if ((num_blocks_x & (num_blocks_x - 1)) || (num_blocks_y & (num_blocks_y - 1))) {
        //extern const char* error_msg;
        //error_msg = "the number of blocks of each side must be a power of 2";
        return 0;
    }

    PVRTCTexelInfo *texel_info = (PVRTCTexelInfo *)malloc(sizeof(PVRTCTexelInfo) * num_blocks);
    if (texel_info == NULL) {
        //extern const char* error_msg;
        //error_msg = "memory allocation failed";
        return 0;
    }

    void (*get_texel_weights_func)(const uint8_t *, PVRTCTexelInfo *) =
      is2bpp ? get_texel_weights_2bpp : get_texel_weights_4bpp;
    void (*applicate_color_func)(const uint8_t *, PVRTCTexelInfo *const[9], uint32_t[32]) =
      is2bpp ? applicate_color_2bpp : applicate_color_4bpp;

    const uint8_t *d = data;
    for (long i = 0; i < num_blocks; i++, d += 8) {
        get_texel_colors(d, &texel_info[i]);
        get_texel_weights_func(d, &texel_info[i]);
    }

    uint32_t buffer[32];
    PVRTCTexelInfo *local_info[9];
    long pos_x[3], pos_y[3];

    for (long by = 0; by < num_blocks_y; by++) {
        pos_y[0] = by == 0 ? num_blocks_y - 1 : by - 1;
        pos_y[1] = by;
        pos_y[2] = by == num_blocks_y - 1 ? 0 : by + 1;
        for (long bx = 0, x = 0; bx < num_blocks_x; bx++, x += 4) {
            pos_x[0] = bx == 0 ? num_blocks_x - 1 : bx - 1;
            pos_x[1] = bx;
            pos_x[2] = bx == num_blocks_x - 1 ? 0 : bx + 1;
            for (long cy = 0, c = 0; cy < 3; cy++)
                for (long cx = 0; cx < 3; cx++, c++)
                    local_info[c] = &texel_info[morton_index(pos_x[cx], pos_y[cy], min_num_blocks)];
            applicate_color_func(data + morton_index(bx, by, min_num_blocks) * 8, local_info, buffer);
            copy_block_buffer(bx, by, w, h, bw, 4, buffer, image);
        }
    }

    free(texel_info);
    return 1;
}

```

`Texture2DDecoderNative/pvrtc.h`:

```h
#ifndef PVRTC_H
#define PVRTC_H

#include <stdint.h>

typedef struct {
    uint8_t r;
    uint8_t g;
    uint8_t b;
    uint8_t a;
} PVRTCTexelColor;

typedef struct {
    int r;
    int g;
    int b;
    int a;
} PVRTCTexelColorInt;

typedef struct {
    PVRTCTexelColor a;
    PVRTCTexelColor b;
    int8_t weight[32];
    uint32_t punch_through_flag;
} PVRTCTexelInfo;

int decode_pvrtc(const uint8_t *, const long, const long, uint32_t *, const int);

#endif /* end of include guard: PVRTC_H */

```

`Texture2DDecoderNative/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Texture2DDecoderNative.rc

// 新对象的下一组默认值
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Texture2DDecoderNative/unitycrunch.cpp`:

```cpp
#include "unitycrunch.h"
#include <stdint.h>
#include <algorithm>
#include "unitycrunch/crn_decomp.h"

bool unity_crunch_unpack_level(const uint8_t* data, uint32_t data_size, uint32_t level_index, void** ret, uint32_t* ret_size) {
	unitycrnd::crn_texture_info tex_info;
	if (!unitycrnd::crnd_get_texture_info(data, data_size, &tex_info))
	{
		return false;
	}

	unitycrnd::crnd_unpack_context pContext = unitycrnd::crnd_unpack_begin(data, data_size);
	if (!pContext)
	{
		return false;
	}

	const crn_uint32 width = std::max(1U, tex_info.m_width >> level_index);
	const crn_uint32 height = std::max(1U, tex_info.m_height >> level_index);
	const crn_uint32 blocks_x = std::max(1U, (width + 3) >> 2);
	const crn_uint32 blocks_y = std::max(1U, (height + 3) >> 2);
	const crn_uint32 row_pitch = blocks_x * unitycrnd::crnd_get_bytes_per_dxt_block(tex_info.m_format);
	const crn_uint32 total_face_size = row_pitch * blocks_y;
	*ret = new uint8_t[total_face_size];
	*ret_size = total_face_size;
	if (!unitycrnd::crnd_unpack_level(pContext, ret, total_face_size, row_pitch, level_index))
	{
		unitycrnd::crnd_unpack_end(pContext);
		return false;
	}
	unitycrnd::crnd_unpack_end(pContext);
	return true;
}
```

`Texture2DDecoderNative/unitycrunch.h`:

```h
#pragma once

#include <stdint.h>

bool unity_crunch_unpack_level(const uint8_t* data, uint32_t data_size, uint32_t level_index, void** ret, uint32_t* ret_size);
```

`Texture2DDecoderNative/unitycrunch/crn_decomp.h`:

```h
// File: crn_decomp.h - Fast CRN->DXTc texture transcoder header file library
// Copyright (c) 2010-2016 Richard Geldreich, Jr. and Binomial LLC
// See Copyright Notice and license at the end of this file.
//
// This single header file contains *all* of the code necessary to unpack .CRN files to raw DXTn bits.
// It does NOT depend on the crn compression library.
//
// Note: This is a single file, stand-alone C++ library which is controlled by the use of the following macro:
//   If CRND_INCLUDE_CRND_H is NOT defined, the header is included.
//
// Important: If compiling with gcc, be sure strict aliasing is disabled: -fno-strict-aliasing
#ifndef CRND_INCLUDE_CRND_H
#define CRND_INCLUDE_CRND_H

// Include crn_defs.h (only to bring in some basic CRN-related types and structures).
#include "crn_defs.h"

#include <stdlib.h>
#include <stdio.h>
#ifdef _WIN32
#include <memory.h>
#else
#include <malloc.h>
#endif
#include <stdarg.h>
#include <new>  // needed for placement new, _msize, _expand

#define CRND_RESTRICT __restrict

#ifdef _MSC_VER
#pragma warning(disable : 4127)  // warning C4127: conditional expression is constant
#endif

#ifdef CRND_DEVEL
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x500
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef
#define NOMINMAX
#endif
#include "windows.h"  // only for IsDebuggerPresent(), DebugBreak(), and OutputDebugStringA()
#endif

// File: crnd_types.h
namespace unitycrnd {
const crn_uint8 cUINT8_MIN = 0;
const crn_uint8 cUINT8_MAX = 0xFFU;
const uint16 cUINT16_MIN = 0;
const uint16 cUINT16_MAX = 0xFFFFU;
const uint32 cUINT32_MIN = 0;
const uint32 cUINT32_MAX = 0xFFFFFFFFU;

const int8 cINT8_MIN = -128;
const int8 cINT8_MAX = 127;
const int16 cINT16_MIN = -32768;
const int16 cINT16_MAX = 32767;
const int32 cINT32_MIN = (-2147483647 - 1);
const int32 cINT32_MAX = 2147483647;

enum eClear { cClear };

const uint32 cIntBits = 32U;

template <typename T>
struct int_traits {
  enum { cMin = unitycrnd::cINT32_MIN,
         cMax = unitycrnd::cINT32_MAX,
         cSigned = true };
};

template <>
struct int_traits<int8> {
  enum { cMin = unitycrnd::cINT8_MIN,
         cMax = unitycrnd::cINT8_MAX,
         cSigned = true };
};
template <>
struct int_traits<int16> {
  enum { cMin = unitycrnd::cINT16_MIN,
         cMax = unitycrnd::cINT16_MAX,
         cSigned = true };
};
template <>
struct int_traits<int32> {
  enum { cMin = unitycrnd::cINT32_MIN,
         cMax = unitycrnd::cINT32_MAX,
         cSigned = true };
};

template <>
struct int_traits<uint8> {
  enum { cMin = 0,
         cMax = unitycrnd::cUINT8_MAX,
         cSigned = false };
};
template <>
struct int_traits<uint16> {
  enum { cMin = 0,
         cMax = unitycrnd::cUINT16_MAX,
         cSigned = false };
};
template <>
struct int_traits<uint32> {
  enum { cMin = 0,
         cMax = unitycrnd::cUINT32_MAX,
         cSigned = false };
};

struct empty_type {};

}  // namespace unitycrnd

// File: crnd_platform.h
namespace unitycrnd {

bool crnd_is_debugger_present();
void crnd_debug_break();
void crnd_output_debug_string(const char* p);

// actually in crnd_assert.cpp
void crnd_assert(const char* pExp, const char* pFile, unsigned line);
void crnd_fail(const char* pExp, const char* pFile, unsigned line);

}  // namespace unitycrnd

// File: crnd_assert.h
namespace unitycrnd {
void crnd_assert(const char* pExp, const char* pFile, unsigned line);

#ifdef NDEBUG
#define CRND_ASSERT(x) ((void)0)
#undef CRND_ASSERTS_ENABLED
#else
#define CRND_ASSERT(_exp) (void)((!!(_exp)) || (unitycrnd::crnd_assert(#_exp, __FILE__, __LINE__), 0))
#define CRND_ASSERTS_ENABLED
#endif

void crnd_trace(const char* pFmt, va_list args);
void crnd_trace(const char* pFmt, ...);

}  // namespace unitycrnd

// File: crnd_helpers.h
namespace unitycrnd {
namespace helpers {
template <typename T>
struct rel_ops {
  friend bool operator!=(const T& x, const T& y) { return (!(x == y)); }
  friend bool operator>(const T& x, const T& y) { return (y < x); }
  friend bool operator<=(const T& x, const T& y) { return (!(y < x)); }
  friend bool operator>=(const T& x, const T& y) { return (!(x < y)); }
};

template <typename T>
inline T* construct(T* p) {
  return new (static_cast<void*>(p)) T;
}

template <typename T, typename U>
inline T* construct(T* p, const U& init) {
  return new (static_cast<void*>(p)) T(init);
}

template <typename T>
void construct_array(T* p, uint32 n) {
  T* q = p + n;
  for (; p != q; ++p)
    new (static_cast<void*>(p)) T;
}

template <typename T, typename U>
void construct_array(T* p, uint32 n, const U& init) {
  T* q = p + n;
  for (; p != q; ++p)
    new (static_cast<void*>(p)) T(init);
}

template <typename T>
inline void destruct(T* p) {
  p->~T();
}

template <typename T>
inline void destruct_array(T* p, uint32 n) {
  T* q = p + n;
  for (; p != q; ++p)
    p->~T();
}

}  // namespace helpers

}  // namespace unitycrnd

// File: crnd_traits.h
namespace unitycrnd {
template <typename T>
struct scalar_type {
  enum { cFlag = false };
  static inline void construct(T* p) { helpers::construct(p); }
  static inline void construct(T* p, const T& init) { helpers::construct(p, init); }
  static inline void construct_array(T* p, uint32 n) { helpers::construct_array(p, n); }
  static inline void destruct(T* p) { helpers::destruct(p); }
  static inline void destruct_array(T* p, uint32 n) { helpers::destruct_array(p, n); }
};

template <typename T>
struct scalar_type<T*> {
  enum { cFlag = true };
  static inline void construct(T** p) { memset(p, 0, sizeof(T*)); }
  static inline void construct(T** p, T* init) { *p = init; }
  static inline void construct_array(T** p, uint32 n) { memset(p, 0, sizeof(T*) * n); }
  static inline void destruct(T**) {}
  static inline void destruct_array(T**, uint32) {}
};

#define CRND_DEFINE_BUILT_IN_TYPE(X)                                                    \
  template <>                                                                           \
  struct scalar_type<X> {                                                               \
    enum { cFlag = true };                                                              \
    static inline void construct(X* p) { memset(p, 0, sizeof(X)); }                     \
    static inline void construct(X* p, const X& init) { memcpy(p, &init, sizeof(X)); }  \
    static inline void construct_array(X* p, uint32 n) { memset(p, 0, sizeof(X) * n); } \
    static inline void destruct(X*) {}                                                  \
    static inline void destruct_array(X*, uint32) {}                                    \
  };

CRND_DEFINE_BUILT_IN_TYPE(bool)
CRND_DEFINE_BUILT_IN_TYPE(char)
CRND_DEFINE_BUILT_IN_TYPE(unsigned char)
CRND_DEFINE_BUILT_IN_TYPE(short)
CRND_DEFINE_BUILT_IN_TYPE(unsigned short)
CRND_DEFINE_BUILT_IN_TYPE(int)
CRND_DEFINE_BUILT_IN_TYPE(unsigned int)
CRND_DEFINE_BUILT_IN_TYPE(long)
CRND_DEFINE_BUILT_IN_TYPE(unsigned long)
CRND_DEFINE_BUILT_IN_TYPE(int64)
CRND_DEFINE_BUILT_IN_TYPE(uint64)
CRND_DEFINE_BUILT_IN_TYPE(float)
CRND_DEFINE_BUILT_IN_TYPE(double)
CRND_DEFINE_BUILT_IN_TYPE(long double)

#undef CRND_DEFINE_BUILT_IN_TYPE

// See: http://erdani.org/publications/cuj-2004-06.pdf

template <typename T>
struct bitwise_movable {
  enum { cFlag = false };
};

// Defines type Q as bitwise movable.
#define CRND_DEFINE_BITWISE_MOVABLE(Q) \
  template <>                          \
  struct bitwise_movable<Q> {          \
    enum { cFlag = true };             \
  };

// From yasli_traits.h:
// Credit goes to Boost;
// also found in the C++ Templates book by Vandevoorde and Josuttis

typedef char (&yes_t)[1];
typedef char (&no_t)[2];

template <class U>
yes_t class_test(int U::*);
template <class U>
no_t class_test(...);

template <class T>
struct is_class {
  enum { value = (sizeof(class_test<T>(0)) == sizeof(yes_t)) };
};

template <typename T>
struct is_pointer {
  enum { value = false };
};

template <typename T>
struct is_pointer<T*> {
  enum { value = true };
};

#define CRND_IS_POD(T) __is_pod(T)

}  // namespace unitycrnd

// File: crnd_mem.h
namespace unitycrnd {
void* crnd_malloc(size_t size, size_t* pActual_size = NULL);
void* crnd_realloc(void* p, size_t size, size_t* pActual_size = NULL, bool movable = true);
void crnd_free(void* p);
size_t crnd_msize(void* p);

template <typename T>
inline T* crnd_new() {
  T* p = static_cast<T*>(crnd_malloc(sizeof(T)));
  if (!p)
    return NULL;

  return helpers::construct(p);
}

template <typename T>
inline T* crnd_new(const T& init) {
  T* p = static_cast<T*>(crnd_malloc(sizeof(T)));
  if (!p)
    return NULL;

  return helpers::construct(p, init);
}

template <typename T>
inline T* crnd_new_array(uint32 num) {
  if (!num)
    num = 1;

  uint8* q = static_cast<uint8*>(crnd_malloc(CRND_MIN_ALLOC_ALIGNMENT + sizeof(T) * num));
  if (!q)
    return NULL;

  T* p = reinterpret_cast<T*>(q + CRND_MIN_ALLOC_ALIGNMENT);

  reinterpret_cast<uint32*>(p)[-1] = num;
  reinterpret_cast<uint32*>(p)[-2] = ~num;

  helpers::construct_array(p, num);
  return p;
}

template <typename T>
inline void crnd_delete(T* p) {
  if (p) {
    helpers::destruct(p);
    crnd_free(p);
  }
}

template <typename T>
inline void crnd_delete_array(T* p) {
  if (p) {
    const uint32 num = reinterpret_cast<uint32*>(p)[-1];
    CRND_ASSERT(num && (num == ~reinterpret_cast<uint32*>(p)[-2]));

    helpers::destruct_array(p, num);

    crnd_free(reinterpret_cast<uint8*>(p) - CRND_MIN_ALLOC_ALIGNMENT);
  }
}

}  // namespace unitycrnd

// File: crnd_math.h
namespace unitycrnd {
namespace math {
const float cNearlyInfinite = 1.0e+37f;

const float cDegToRad = 0.01745329252f;
const float cRadToDeg = 57.29577951f;

extern uint32 g_bitmasks[32];

// Yes I know these should probably be pass by ref, not val:
// http://www.stepanovpapers.com/notes.pdf
// Just don't use them on non-simple (non built-in) types!
template <typename T>
inline T minimum(T a, T b) {
  return (a < b) ? a : b;
}

template <typename T>
inline T minimum(T a, T b, T c) {
  return minimum(minimum(a, b), c);
}

template <typename T>
inline T maximum(T a, T b) {
  return (a > b) ? a : b;
}

template <typename T>
inline T maximum(T a, T b, T c) {
  return maximum(maximum(a, b), c);
}

template <typename T>
inline T clamp(T value, T low, T high) {
  return (value < low) ? low : ((value > high) ? high : value);
}

template <typename T>
inline T square(T value) {
  return value * value;
}

inline bool is_power_of_2(uint32 x) {
  return x && ((x & (x - 1U)) == 0U);
}

// From "Hackers Delight"
inline int next_pow2(uint32 val) {
  val--;
  val |= val >> 16;
  val |= val >> 8;
  val |= val >> 4;
  val |= val >> 2;
  val |= val >> 1;
  return val + 1;
}

// Returns the total number of bits needed to encode v.
inline uint32 total_bits(uint32 v) {
  uint32 l = 0;
  while (v > 0U) {
    v >>= 1;
    l++;
  }
  return l;
}

inline uint floor_log2i(uint v) {
  uint l = 0;
  while (v > 1U) {
    v >>= 1;
    l++;
  }
  return l;
}

inline uint ceil_log2i(uint v) {
  uint l = floor_log2i(v);
  if ((l != cIntBits) && (v > (1U << l)))
    l++;
  return l;
}
}
}

// File: crnd_utils.h
namespace unitycrnd {
namespace utils {
template <typename T>
inline void zero_object(T& obj) {
  memset(&obj, 0, sizeof(obj));
}

template <typename T>
inline void zero_this(T* pObj) {
  memset(pObj, 0, sizeof(*pObj));
}

template <typename T>
inline void swap(T& left, T& right) {
  T temp(left);
  left = right;
  right = temp;
}

inline void invert_buf(void* pBuf, uint32 size) {
  uint8* p = static_cast<uint8*>(pBuf);

  const uint32 half_size = size >> 1;
  for (uint32 i = 0; i < half_size; i++)
    swap(p[i], p[size - 1U - i]);
}

static inline uint16 swap16(uint16 x) {
  return static_cast<uint16>((x << 8) | (x >> 8));
}
static inline uint32 swap32(uint32 x) {
  return ((x << 24) | ((x << 8) & 0x00FF0000) | ((x >> 8) & 0x0000FF00) | (x >> 24));
}

uint32 compute_max_mips(uint32 width, uint32 height);

}  // namespace utils

}  // namespace unitycrnd

// File: crnd_vector.h
namespace unitycrnd {
struct elemental_vector {
  void* m_p;
  uint32 m_size;
  uint32 m_capacity;

  typedef void (*object_mover)(void* pDst, void* pSrc, uint32 num);

  bool increase_capacity(uint32 min_new_capacity, bool grow_hint, uint32 element_size, object_mover pRelocate);
};

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4127)  //  warning C4127: conditional expression is constant
#endif

template <typename T>
class vector : public helpers::rel_ops<vector<T> > {
 public:
  typedef T* iterator;
  typedef const T* const_iterator;
  typedef T value_type;
  typedef T& reference;
  typedef const T& const_reference;
  typedef T* pointer;
  typedef const T* const_pointer;

  inline vector()
      : m_p(NULL),
        m_size(0),
        m_capacity(0),
        m_alloc_failed(false) {
  }

  inline vector(const vector& other)
      : m_p(NULL),
        m_size(0),
        m_capacity(0),
        m_alloc_failed(false) {
    *this = other;
  }

  inline vector(uint32 size)
      : m_p(NULL),
        m_size(0),
        m_capacity(0),
        m_alloc_failed(false) {
    resize(size);
  }

  inline ~vector() {
    clear();
  }

  // I don't like this. Not at all. But exceptions, or just failing suck worse.
  inline bool get_alloc_failed() const { return m_alloc_failed; }
  inline void clear_alloc_failed() { m_alloc_failed = false; }

  inline bool assign(const vector& other) {
    if (this == &other)
      return true;

    if (m_capacity == other.m_size)
      resize(0);
    else {
      clear();

      if (!increase_capacity(other.m_size, false))
        return false;
    }

    if (scalar_type<T>::cFlag)
      memcpy(m_p, other.m_p, other.m_size * sizeof(T));
    else {
      T* pDst = m_p;
      const T* pSrc = other.m_p;
      for (uint32 i = other.m_size; i > 0; i--)
        helpers::construct(pDst++, *pSrc++);
    }

    m_size = other.m_size;

    return true;
  }

  inline vector& operator=(const vector& other) {
    assign(other);
    return *this;
  }

  inline const T* begin() const { return m_p; }
  T* begin() { return m_p; }

  inline const T* end() const { return m_p + m_size; }
  T* end() { return m_p + m_size; }

  inline bool empty() const { return !m_size; }
  inline uint32 size() const { return m_size; }
  inline uint32 capacity() const { return m_capacity; }

  inline const T& operator[](uint32 i) const {
    CRND_ASSERT(i < m_size);
    return m_p[i];
  }
  inline T& operator[](uint32 i) {
    CRND_ASSERT(i < m_size);
    return m_p[i];
  }

  inline const T& front() const {
    CRND_ASSERT(m_size);
    return m_p[0];
  }
  inline T& front() {
    CRND_ASSERT(m_size);
    return m_p[0];
  }

  inline const T& back() const {
    CRND_ASSERT(m_size);
    return m_p[m_size - 1];
  }
  inline T& back() {
    CRND_ASSERT(m_size);
    return m_p[m_size - 1];
  }

  inline void clear() {
    if (m_p) {
      scalar_type<T>::destruct_array(m_p, m_size);
      crnd_free(m_p);
      m_p = NULL;
      m_size = 0;
      m_capacity = 0;
    }

    m_alloc_failed = false;
  }

  inline bool reserve(uint32 new_capacity) {
    if (!increase_capacity(new_capacity, false))
      return false;

    return true;
  }

  inline bool resize(uint32 new_size) {
    if (m_size != new_size) {
      if (new_size < m_size)
        scalar_type<T>::destruct_array(m_p + new_size, m_size - new_size);
      else {
        if (new_size > m_capacity) {
          if (!increase_capacity(new_size, new_size == (m_size + 1)))
            return false;
        }

        scalar_type<T>::construct_array(m_p + m_size, new_size - m_size);
      }

      m_size = new_size;
    }

    return true;
  }

  inline bool push_back(const T& obj) {
    CRND_ASSERT(!m_p || (&obj < m_p) || (&obj >= (m_p + m_size)));

    if (m_size >= m_capacity) {
      if (!increase_capacity(m_size + 1, true))
        return false;
    }

    scalar_type<T>::construct(m_p + m_size, obj);
    m_size++;

    return true;
  }

  inline void pop_back() {
    CRND_ASSERT(m_size);

    if (m_size) {
      m_size--;
      scalar_type<T>::destruct(&m_p[m_size]);
    }
  }

  inline void insert(uint32 index, const T* p, uint32 n) {
    CRND_ASSERT(index <= m_size);
    if (!n)
      return;

    const uint32 orig_size = m_size;
    resize(m_size + n);

    const T* pSrc = m_p + orig_size - 1;
    T* pDst = const_cast<T*>(pSrc) + n;

    const uint32 num_to_move = orig_size - index;

    for (uint32 i = 0; i < num_to_move; i++) {
      CRND_ASSERT((pDst - m_p) < (int)m_size);
      *pDst-- = *pSrc--;
    }

    pSrc = p;
    pDst = m_p + index;

    for (uint32 i = 0; i < n; i++) {
      CRND_ASSERT((pDst - m_p) < (int)m_size);
      *pDst++ = *p++;
    }
  }

  inline void erase(uint32 start, uint32 n) {
    CRND_ASSERT((start + n) <= m_size);

    if (!n)
      return;

    const uint32 num_to_move = m_size - (start + n);

    T* pDst = m_p + start;
    T* pDst_end = pDst + num_to_move;
    const T* pSrc = m_p + start + n;

    while (pDst != pDst_end)
      *pDst++ = *pSrc++;

    scalar_type<T>::destruct_array(pDst_end, n);

    m_size -= n;
  }

  inline void erase(uint32 index) {
    erase(index, 1);
  }

  inline void erase(T* p) {
    CRND_ASSERT((p >= m_p) && (p < (m_p + m_size)));
    erase(p - m_p);
  }

  inline bool operator==(const vector& rhs) const {
    if (m_size != rhs.m_size)
      return false;
    else if (m_size) {
      if (scalar_type<T>::cFlag)
        return memcmp(m_p, rhs.m_p, sizeof(T) * m_size) == 0;
      else {
        const T* pSrc = m_p;
        const T* pDst = rhs.m_p;
        for (uint32 i = m_size; i; i--)
          if (!(*pSrc++ == *pDst++))
            return false;
      }
    }

    return true;
  }

  inline bool operator<(const vector& rhs) const {
    const uint32 min_size = math::minimum(m_size, rhs.m_size);

    const T* pSrc = m_p;
    const T* pSrc_end = m_p + min_size;
    const T* pDst = rhs.m_p;

    while ((pSrc < pSrc_end) && (*pSrc == *pDst)) {
      pSrc++;
      pDst++;
    }

    if (pSrc < pSrc_end)
      return *pSrc < *pDst;

    return m_size < rhs.m_size;
  }

  void swap(vector& other) {
    utils::swap(m_p, other.m_p);
    utils::swap(m_size, other.m_size);
    utils::swap(m_capacity, other.m_capacity);
  }

 private:
  T* m_p;
  uint32 m_size;
  uint32 m_capacity;
  bool m_alloc_failed;

  template <typename Q>
  struct is_vector {
    enum { cFlag = false };
  };
  template <typename Q>
  struct is_vector<vector<Q> > {
    enum { cFlag = true };
  };

  static void object_mover(void* pDst_void, void* pSrc_void, uint32 num) {
    T* pSrc = static_cast<T*>(pSrc_void);
    T* const pSrc_end = pSrc + num;
    T* pDst = static_cast<T*>(pDst_void);

    while (pSrc != pSrc_end) {
      helpers::construct<T>(pDst, *pSrc);
      pSrc->~T();
      pSrc++;
      pDst++;
    }
  }

  inline bool increase_capacity(uint32 min_new_capacity, bool grow_hint) {
    if (!reinterpret_cast<elemental_vector*>(this)->increase_capacity(
            min_new_capacity, grow_hint, sizeof(T),
            ((scalar_type<T>::cFlag) || (is_vector<T>::cFlag) || (bitwise_movable<T>::cFlag) || CRND_IS_POD(T)) ? NULL : object_mover)) {
      m_alloc_failed = true;
      return false;
    }
    return true;
  }
};

#ifdef _MSC_VER
#pragma warning(pop)
#endif

extern void vector_test();

}  // namespace unitycrnd

// File: crnd_private.h
namespace unitycrnd {
const crn_header* crnd_get_header(const void* pData, uint32 data_size);

}  // namespace unitycrnd

// File: checksum.h
namespace unitycrnd {
// crc16() intended for small buffers - doesn't use an acceleration table.
const uint16 cInitCRC16 = 0;
uint16 crc16(const void* pBuf, uint32 len, uint16 crc = cInitCRC16);

}  // namespace unitycrnd

// File: crnd_color.h
namespace unitycrnd {
template <typename component_type>
struct color_quad_component_traits {
  enum {
    cSigned = false,
    cFloat = false,
    cMin = cUINT8_MIN,
    cMax = cUINT8_MAX
  };
};

template <>
struct color_quad_component_traits<int16> {
  enum {
    cSigned = true,
    cFloat = false,
    cMin = cINT16_MIN,
    cMax = cINT16_MAX
  };
};

template <>
struct color_quad_component_traits<uint16> {
  enum {
    cSigned = false,
    cFloat = false,
    cMin = cUINT16_MIN,
    cMax = cUINT16_MAX
  };
};

template <>
struct color_quad_component_traits<int32> {
  enum {
    cSigned = true,
    cFloat = false,
    cMin = cINT32_MIN,
    cMax = cINT32_MAX
  };
};

template <>
struct color_quad_component_traits<uint32> {
  enum {
    cSigned = false,
    cFloat = false,
    cMin = cUINT32_MIN,
    cMax = cUINT32_MAX
  };
};

template <>
struct color_quad_component_traits<float> {
  enum {
    cSigned = false,
    cFloat = true,
    cMin = cINT32_MIN,
    cMax = cINT32_MAX
  };
};

template <>
struct color_quad_component_traits<double> {
  enum {
    cSigned = false,
    cFloat = true,
    cMin = cINT32_MIN,
    cMax = cINT32_MAX
  };
};

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4201)  //  warning C4201: nonstandard extension used : nameless struct/union
#pragma warning(disable : 4127)  //  warning C4127: conditional expression is constant
#endif

template <typename component_type, typename parameter_type>
class color_quad : public helpers::rel_ops<color_quad<component_type, parameter_type> > {
  static parameter_type clamp(parameter_type v) {
    if (component_traits::cFloat)
      return v;
    else {
      if (v < component_traits::cMin)
        return component_traits::cMin;
      else if (v > component_traits::cMax)
        return component_traits::cMax;
      return v;
    }
  }

 public:
  typedef component_type component_t;
  typedef parameter_type parameter_t;
  typedef color_quad_component_traits<component_type> component_traits;

  enum { cNumComps = 4 };

  union {
    struct
    {
      component_type r;
      component_type g;
      component_type b;
      component_type a;
    };

    component_type c[cNumComps];
  };

  inline color_quad() {
  }

  inline color_quad(eClear)
      : r(0), g(0), b(0), a(0) {
  }

  inline color_quad(const color_quad& other)
      : r(other.r), g(other.g), b(other.b), a(other.a) {
  }

  inline color_quad(parameter_type y, parameter_type alpha = component_traits::cMax) {
    set(y, alpha);
  }

  inline color_quad(parameter_type red, parameter_type green, parameter_type blue, parameter_type alpha = component_traits::cMax) {
    set(red, green, blue, alpha);
  }

  template <typename other_component_type, typename other_parameter_type>
  inline color_quad(const color_quad<other_component_type, other_parameter_type>& other)
      : r(clamp(other.r)), g(clamp(other.g)), b(clamp(other.b)), a(clamp(other.a)) {
  }

  inline void clear() {
    r = 0;
    g = 0;
    b = 0;
    a = 0;
  }

  inline color_quad& operator=(const color_quad& other) {
    r = other.r;
    g = other.g;
    b = other.b;
    a = other.a;
    return *this;
  }

  template <typename other_component_type, typename other_parameter_type>
  inline color_quad& operator=(const color_quad<other_component_type, other_parameter_type>& other) {
    r = clamp(other.r);
    g = clamp(other.g);
    b = clamp(other.b);
    a = clamp(other.a);
    return *this;
  }

  inline color_quad& set(parameter_type y, parameter_type alpha = component_traits::cMax) {
    y = clamp(y);
    r = static_cast<component_type>(y);
    g = static_cast<component_type>(y);
    b = static_cast<component_type>(y);
    a = static_cast<component_type>(alpha);
    return *this;
  }

  inline color_quad& set(parameter_type red, parameter_type green, parameter_type blue, parameter_type alpha = component_traits::cMax) {
    r = static_cast<component_type>(clamp(red));
    g = static_cast<component_type>(clamp(green));
    b = static_cast<component_type>(clamp(blue));
    a = static_cast<component_type>(clamp(alpha));
    return *this;
  }

  inline color_quad& set_noclamp_rgba(parameter_type red, parameter_type green, parameter_type blue, parameter_type alpha) {
    r = static_cast<component_type>(red);
    g = static_cast<component_type>(green);
    b = static_cast<component_type>(blue);
    a = static_cast<component_type>(alpha);
    return *this;
  }

  inline color_quad& set_noclamp_rgb(parameter_type red, parameter_type green, parameter_type blue) {
    r = static_cast<component_type>(red);
    g = static_cast<component_type>(green);
    b = static_cast<component_type>(blue);
    return *this;
  }

  static inline parameter_type get_min_comp() { return component_traits::cMin; }
  static inline parameter_type get_max_comp() { return component_traits::cMax; }
  static inline bool get_comps_are_signed() { return component_traits::cSigned; }

  inline component_type operator[](uint32 i) const {
    CRND_ASSERT(i < cNumComps);
    return c[i];
  }
  inline component_type& operator[](uint32 i) {
    CRND_ASSERT(i < cNumComps);
    return c[i];
  }

  inline color_quad& set_component(uint32 i, parameter_type f) {
    CRND_ASSERT(i < cNumComps);

    c[i] = static_cast<component_type>(clamp(f));

    return *this;
  }

  inline color_quad& clamp(const color_quad& l, const color_quad& h) {
    for (uint32 i = 0; i < cNumComps; i++)
      c[i] = static_cast<component_type>(math::clamp<parameter_type>(c[i], l[i], h[i]));
    return *this;
  }

  inline color_quad& clamp(parameter_type l, parameter_type h) {
    for (uint32 i = 0; i < cNumComps; i++)
      c[i] = static_cast<component_type>(math::clamp<parameter_type>(c[i], l, h));
    return *this;
  }

  // Returns CCIR 601 luma (consistent with color_utils::RGB_To_Y).
  inline parameter_type get_luma() const {
    return static_cast<parameter_type>((19595U * r + 38470U * g + 7471U * b + 32768) >> 16U);
  }

  // Returns REC 709 luma.
  inline parameter_type get_luma_rec709() const {
    return static_cast<parameter_type>((13938U * r + 46869U * g + 4729U * b + 32768U) >> 16U);
  }

  inline uint32 squared_distance(const color_quad& c, bool alpha = true) const {
    return math::square(r - c.r) + math::square(g - c.g) + math::square(b - c.b) + (alpha ? math::square(a - c.a) : 0);
  }

  inline bool rgb_equals(const color_quad& rhs) const {
    return (r == rhs.r) && (g == rhs.g) && (b == rhs.b);
  }

  inline bool operator==(const color_quad& rhs) const {
    return (r == rhs.r) && (g == rhs.g) && (b == rhs.b) && (a == rhs.a);
  }

  inline bool operator<(const color_quad& rhs) const {
    for (uint32 i = 0; i < cNumComps; i++) {
      if (c[i] < rhs.c[i])
        return true;
      else if (!(c[i] == rhs.c[i]))
        return false;
    }
    return false;
  }

  inline color_quad& operator+=(const color_quad& other) {
    for (uint32 i = 0; i < 4; i++)
      c[i] = static_cast<component_type>(clamp(c[i] + other.c[i]));
    return *this;
  }

  inline color_quad& operator-=(const color_quad& other) {
    for (uint32 i = 0; i < 4; i++)
      c[i] = static_cast<component_type>(clamp(c[i] - other.c[i]));
    return *this;
  }

  inline color_quad& operator*=(parameter_type v) {
    for (uint32 i = 0; i < 4; i++)
      c[i] = static_cast<component_type>(clamp(c[i] * v));
    return *this;
  }

  inline color_quad& operator/=(parameter_type v) {
    for (uint32 i = 0; i < 4; i++)
      c[i] = static_cast<component_type>(c[i] / v);
    return *this;
  }

  inline color_quad get_swizzled(uint32 x, uint32 y, uint32 z, uint32 w) const {
    CRND_ASSERT((x | y | z | w) < 4);
    return color_quad(c[x], c[y], c[z], c[w]);
  }

  inline friend color_quad operator+(const color_quad& lhs, const color_quad& rhs) {
    color_quad result(lhs);
    result += rhs;
    return result;
  }

  inline friend color_quad operator-(const color_quad& lhs, const color_quad& rhs) {
    color_quad result(lhs);
    result -= rhs;
    return result;
  }

  inline friend color_quad operator*(const color_quad& lhs, parameter_type v) {
    color_quad result(lhs);
    result *= v;
    return result;
  }

  friend inline color_quad operator/(const color_quad& lhs, parameter_type v) {
    color_quad result(lhs);
    result /= v;
    return result;
  }

  friend inline color_quad operator*(parameter_type v, const color_quad& rhs) {
    color_quad result(rhs);
    result *= v;
    return result;
  }

  inline uint32 get_min_component_index(bool alpha = true) const {
    uint32 index = 0;
    uint32 limit = alpha ? cNumComps : (cNumComps - 1);
    for (uint32 i = 1; i < limit; i++)
      if (c[i] < c[index])
        index = i;
    return index;
  }

  inline uint32 get_max_component_index(bool alpha = true) const {
    uint32 index = 0;
    uint32 limit = alpha ? cNumComps : (cNumComps - 1);
    for (uint32 i = 1; i < limit; i++)
      if (c[i] > c[index])
        index = i;
    return index;
  }

  inline void get_float4(float* pDst) {
    for (uint32 i = 0; i < 4; i++)
      pDst[i] = ((*this)[i] - component_traits::cMin) / float(component_traits::cMax - component_traits::cMin);
  }

  inline void get_float3(float* pDst) {
    for (uint32 i = 0; i < 3; i++)
      pDst[i] = ((*this)[i] - component_traits::cMin) / float(component_traits::cMax - component_traits::cMin);
  }

  static inline color_quad make_black() {
    return color_quad(0, 0, 0, component_traits::cMax);
  }

  static inline color_quad make_white() {
    return color_quad(component_traits::cMax, component_traits::cMax, component_traits::cMax, component_traits::cMax);
  }
};  // class color_quad

#ifdef _MSC_VER
#pragma warning(pop)
#endif

template <typename c, typename q>
struct scalar_type<color_quad<c, q> > {
  enum { cFlag = true };
  static inline void construct(color_quad<c, q>* p) {}
  static inline void construct(color_quad<c, q>* p, const color_quad<c, q>& init) { memcpy(p, &init, sizeof(color_quad<c, q>)); }
  static inline void construct_array(color_quad<c, q>* p, uint32 n) { p, n; }
  static inline void destruct(color_quad<c, q>* p) { p; }
  static inline void destruct_array(color_quad<c, q>* p, uint32 n) { p, n; }
};

typedef color_quad<uint8, int> color_quad_u8;
typedef color_quad<int16, int> color_quad_i16;
typedef color_quad<uint16, int> color_quad_u16;
typedef color_quad<int32, int> color_quad_i32;
typedef color_quad<uint32, uint32> color_quad_u32;
typedef color_quad<float, float> color_quad_f;
typedef color_quad<double, double> color_quad_d;

}  // namespace unitycrnd

// File: crnd_dxt.h
namespace unitycrnd {
enum dxt_format {
  cDXTInvalid = -1,

  // cDXT1/1A must appear first!
  cDXT1,
  cDXT1A,

  cDXT3,
  cDXT5,
  cDXT5A,

  cDXN_XY,  // inverted relative to standard ATI2, 360's DXN
  cDXN_YX   // standard ATI2
};

enum dxt_constants {
  cDXTBlockShift = 2U,
  cDXTBlockSize = 1U << cDXTBlockShift,

  cDXT1BytesPerBlock = 8U,
  cDXT5NBytesPerBlock = 16U,

  cDXT1SelectorBits = 2U,
  cDXT1SelectorValues = 1U << cDXT1SelectorBits,
  cDXT1SelectorMask = cDXT1SelectorValues - 1U,

  cDXT5SelectorBits = 3U,
  cDXT5SelectorValues = 1U << cDXT5SelectorBits,
  cDXT5SelectorMask = cDXT5SelectorValues - 1U
};

const float cDXT1MaxLinearValue = 3.0f;
const float cDXT1InvMaxLinearValue = 1.0f / 3.0f;

const float cDXT5MaxLinearValue = 7.0f;
const float cDXT5InvMaxLinearValue = 1.0f / 7.0f;

// Converts DXT1 raw color selector index to a linear value.
extern const uint8 g_dxt1_to_linear[cDXT1SelectorValues];

// Converts DXT5 raw alpha selector index to a linear value.
extern const uint8 g_dxt5_to_linear[cDXT5SelectorValues];

// Converts DXT1 linear color selector index to a raw value (inverse of g_dxt1_to_linear).
extern const uint8 g_dxt1_from_linear[cDXT1SelectorValues];

// Converts DXT5 linear alpha selector index to a raw value (inverse of g_dxt5_to_linear).
extern const uint8 g_dxt5_from_linear[cDXT5SelectorValues];

extern const uint8 g_six_alpha_invert_table[cDXT5SelectorValues];
extern const uint8 g_eight_alpha_invert_table[cDXT5SelectorValues];

struct dxt1_block {
  uint8 m_low_color[2];
  uint8 m_high_color[2];

  enum { cNumSelectorBytes = 4 };
  uint8 m_selectors[cNumSelectorBytes];

  inline void clear() {
    utils::zero_this(this);
  }

  // These methods assume the in-memory rep is in LE byte order.
  inline uint32 get_low_color() const {
    return m_low_color[0] | (m_low_color[1] << 8U);
  }

  inline uint32 get_high_color() const {
    return m_high_color[0] | (m_high_color[1] << 8U);
  }

  inline void set_low_color(uint16 c) {
    m_low_color[0] = static_cast<uint8>(c & 0xFF);
    m_low_color[1] = static_cast<uint8>((c >> 8) & 0xFF);
  }

  inline void set_high_color(uint16 c) {
    m_high_color[0] = static_cast<uint8>(c & 0xFF);
    m_high_color[1] = static_cast<uint8>((c >> 8) & 0xFF);
  }

  inline uint32 get_selector(uint32 x, uint32 y) const {
    CRND_ASSERT((x < 4U) && (y < 4U));
    return (m_selectors[y] >> (x * cDXT1SelectorBits)) & cDXT1SelectorMask;
  }

  inline void set_selector(uint32 x, uint32 y, uint32 val) {
    CRND_ASSERT((x < 4U) && (y < 4U) && (val < 4U));

    m_selectors[y] &= (~(cDXT1SelectorMask << (x * cDXT1SelectorBits)));
    m_selectors[y] |= (val << (x * cDXT1SelectorBits));
  }

  static uint16 pack_color(const color_quad_u8& color, bool scaled, uint32 bias = 127U);
  static uint16 pack_color(uint32 r, uint32 g, uint32 b, bool scaled, uint32 bias = 127U);

  static color_quad_u8 unpack_color(uint16 packed_color, bool scaled, uint32 alpha = 255U);
  static void unpack_color(uint32& r, uint32& g, uint32& b, uint16 packed_color, bool scaled);

  static uint32 get_block_colors3(color_quad_u8* pDst, uint16 color0, uint16 color1);
  static uint32 get_block_colors4(color_quad_u8* pDst, uint16 color0, uint16 color1);
  // pDst must point to an array at least cDXT1SelectorValues long.
  static uint32 get_block_colors(color_quad_u8* pDst, uint16 color0, uint16 color1);

  static color_quad_u8 unpack_endpoint(uint32 endpoints, uint32 index, bool scaled, uint32 alpha = 255U);
  static uint32 pack_endpoints(uint32 lo, uint32 hi);
};

CRND_DEFINE_BITWISE_MOVABLE(dxt1_block);

struct dxt3_block {
  enum { cNumAlphaBytes = 8 };
  uint8 m_alpha[cNumAlphaBytes];

  void set_alpha(uint32 x, uint32 y, uint32 value, bool scaled);
  uint32 get_alpha(uint32 x, uint32 y, bool scaled) const;
};

CRND_DEFINE_BITWISE_MOVABLE(dxt3_block);

struct dxt5_block {
  uint8 m_endpoints[2];

  enum { cNumSelectorBytes = 6 };
  uint8 m_selectors[cNumSelectorBytes];

  inline void clear() {
    utils::zero_this(this);
  }

  inline uint32 get_low_alpha() const {
    return m_endpoints[0];
  }

  inline uint32 get_high_alpha() const {
    return m_endpoints[1];
  }

  inline void set_low_alpha(uint32 i) {
    CRND_ASSERT(i <= cUINT8_MAX);
    m_endpoints[0] = static_cast<uint8>(i);
  }

  inline void set_high_alpha(uint32 i) {
    CRND_ASSERT(i <= cUINT8_MAX);
    m_endpoints[1] = static_cast<uint8>(i);
  }

  uint32 get_endpoints_as_word() const { return m_endpoints[0] | (m_endpoints[1] << 8); }

  uint32 get_selectors_as_word(uint32 index) {
    CRND_ASSERT(index < 3);
    return m_selectors[index * 2] | (m_selectors[index * 2 + 1] << 8);
  }

  inline uint32 get_selector(uint32 x, uint32 y) const {
    CRND_ASSERT((x < 4U) && (y < 4U));

    uint32 selector_index = (y * 4) + x;
    uint32 bit_index = selector_index * cDXT5SelectorBits;

    uint32 byte_index = bit_index >> 3;
    uint32 bit_ofs = bit_index & 7;

    uint32 v = m_selectors[byte_index];
    if (byte_index < (cNumSelectorBytes - 1))
      v |= (m_selectors[byte_index + 1] << 8);

    return (v >> bit_ofs) & 7;
  }

  inline void set_selector(uint32 x, uint32 y, uint32 val) {
    CRND_ASSERT((x < 4U) && (y < 4U) && (val < 8U));

    uint32 selector_index = (y * 4) + x;
    uint32 bit_index = selector_index * cDXT5SelectorBits;

    uint32 byte_index = bit_index >> 3;
    uint32 bit_ofs = bit_index & 7;

    uint32 v = m_selectors[byte_index];
    if (byte_index < (cNumSelectorBytes - 1))
      v |= (m_selectors[byte_index + 1] << 8);

    v &= (~(7 << bit_ofs));
    v |= (val << bit_ofs);

    m_selectors[byte_index] = static_cast<uint8>(v);
    if (byte_index < (cNumSelectorBytes - 1))
      m_selectors[byte_index + 1] = static_cast<uint8>(v >> 8);
  }

  // Results written to alpha channel.
  static uint32 get_block_values6(color_quad_u8* pDst, uint32 l, uint32 h);
  static uint32 get_block_values8(color_quad_u8* pDst, uint32 l, uint32 h);
  static uint32 get_block_values(color_quad_u8* pDst, uint32 l, uint32 h);

  static uint32 get_block_values6(uint32* pDst, uint32 l, uint32 h);
  static uint32 get_block_values8(uint32* pDst, uint32 l, uint32 h);
  // pDst must point to an array at least cDXT5SelectorValues long.
  static uint32 get_block_values(uint32* pDst, uint32 l, uint32 h);

  static uint32 unpack_endpoint(uint32 packed, uint32 index);
  static uint32 pack_endpoints(uint32 lo, uint32 hi);
};

CRND_DEFINE_BITWISE_MOVABLE(dxt5_block);

}  // namespace unitycrnd

// File: crnd_prefix_coding.h
#ifdef _XBOX
#define CRND_PREFIX_CODING_USE_FIXED_TABLE_SIZE 1
#else
#define CRND_PREFIX_CODING_USE_FIXED_TABLE_SIZE 0
#endif

namespace unitycrnd {
namespace prefix_coding {
const uint32 cMaxExpectedCodeSize = 16;
const uint32 cMaxSupportedSyms = 8192;
const uint32 cMaxTableBits = 11;

class decoder_tables {
 public:
  inline decoder_tables()
      : m_cur_lookup_size(0), m_lookup(NULL), m_cur_sorted_symbol_order_size(0), m_sorted_symbol_order(NULL) {
  }

  inline decoder_tables(const decoder_tables& other)
      : m_cur_lookup_size(0), m_lookup(NULL), m_cur_sorted_symbol_order_size(0), m_sorted_symbol_order(NULL) {
    *this = other;
  }

  decoder_tables& operator=(const decoder_tables& other) {
    if (this == &other)
      return *this;

    clear();

    memcpy(this, &other, sizeof(*this));

    if (other.m_lookup) {
      m_lookup = crnd_new_array<uint32>(m_cur_lookup_size);
      if (m_lookup)
        memcpy(m_lookup, other.m_lookup, sizeof(m_lookup[0]) * m_cur_lookup_size);
    }

    if (other.m_sorted_symbol_order) {
      m_sorted_symbol_order = crnd_new_array<uint16>(m_cur_sorted_symbol_order_size);
      if (m_sorted_symbol_order)
        memcpy(m_sorted_symbol_order, other.m_sorted_symbol_order, sizeof(m_sorted_symbol_order[0]) * m_cur_sorted_symbol_order_size);
    }

    return *this;
  }

  inline void clear() {
    if (m_lookup) {
      crnd_delete_array(m_lookup);
      m_lookup = 0;
      m_cur_lookup_size = 0;
    }

    if (m_sorted_symbol_order) {
      crnd_delete_array(m_sorted_symbol_order);
      m_sorted_symbol_order = NULL;
      m_cur_sorted_symbol_order_size = 0;
    }
  }

  inline ~decoder_tables() {
    if (m_lookup)
      crnd_delete_array(m_lookup);

    if (m_sorted_symbol_order)
      crnd_delete_array(m_sorted_symbol_order);
  }

  bool init(uint32 num_syms, const uint8* pCodesizes, uint32 table_bits);

  // DO NOT use any complex classes here - it is bitwise copied.

  uint32 m_num_syms;
  uint32 m_total_used_syms;
  uint32 m_table_bits;
  uint32 m_table_shift;
  uint32 m_table_max_code;
  uint32 m_decode_start_code_size;

  uint8 m_min_code_size;
  uint8 m_max_code_size;

  uint32 m_max_codes[cMaxExpectedCodeSize + 1];
  int32 m_val_ptrs[cMaxExpectedCodeSize + 1];

  uint32 m_cur_lookup_size;
  uint32* m_lookup;

  uint32 m_cur_sorted_symbol_order_size;
  uint16* m_sorted_symbol_order;

  inline uint32 get_unshifted_max_code(uint32 len) const {
    CRND_ASSERT((len >= 1) && (len <= cMaxExpectedCodeSize));
    uint32 k = m_max_codes[len - 1];
    if (!k)
      return unitycrnd::cUINT32_MAX;
    return (k - 1) >> (16 - len);
  }
};

}  // namespace prefix_coding

}  // namespace unitycrnd

// File: crnd_symbol_codec.h
namespace unitycrnd {
class static_huffman_data_model {
 public:
  static_huffman_data_model();
  static_huffman_data_model(const static_huffman_data_model& other);
  ~static_huffman_data_model();

  static_huffman_data_model& operator=(const static_huffman_data_model& rhs);

  bool init(uint32 total_syms, const uint8* pCode_sizes, uint32 code_size_limit);
  void clear();

  inline bool is_valid() const { return m_pDecode_tables != NULL; }

  inline uint32 get_total_syms() const { return m_total_syms; }

  inline uint32 get_code_size(uint32 sym) const { return m_code_sizes[sym]; }

  inline const uint8* get_code_sizes() const { return m_code_sizes.empty() ? NULL : &m_code_sizes[0]; }

 public:
  uint32 m_total_syms;
  unitycrnd::vector<uint8> m_code_sizes;
  prefix_coding::decoder_tables* m_pDecode_tables;

 private:
  bool prepare_decoder_tables();
  uint compute_decoder_table_bits() const;

  friend class symbol_codec;
};

class symbol_codec {
 public:
  symbol_codec();

  bool start_decoding(const uint8* pBuf, uint32 buf_size);
  bool decode_receive_static_data_model(static_huffman_data_model& model);

  uint32 decode_bits(uint32 num_bits);
  uint32 decode(const static_huffman_data_model& model);

  uint64 stop_decoding();

 public:
  const uint8* m_pDecode_buf;
  const uint8* m_pDecode_buf_next;
  const uint8* m_pDecode_buf_end;
  uint32 m_decode_buf_size;

  typedef uint32 bit_buf_type;
  enum { cBitBufSize = 32U };
  bit_buf_type m_bit_buf;

  int m_bit_count;

 private:
  void get_bits_init();
  uint32 get_bits(uint32 num_bits);
};

}  // namespace unitycrnd

namespace unitycrnd {
void crnd_assert(const char* pExp, const char* pFile, unsigned line) {
  char buf[512];

#if defined(_WIN32) && defined(_MSC_VER)
  sprintf_s(buf, sizeof(buf), "%s(%u): Assertion failure: \"%s\"\n", pFile, line, pExp);
#else
  sprintf(buf, "%s(%u): Assertion failure: \"%s\"\n", pFile, line, pExp);
#endif

  crnd_output_debug_string(buf);

  puts(buf);

  if (crnd_is_debugger_present())
    crnd_debug_break();
}

void crnd_trace(const char* pFmt, va_list args) {
  if (crnd_is_debugger_present()) {
    char buf[512];
#if defined(_WIN32) && defined(_MSC_VER)
    vsprintf_s(buf, sizeof(buf), pFmt, args);
#else
    vsprintf(buf, pFmt, args);
#endif

    crnd_output_debug_string(buf);
  }
};

void crnd_trace(const char* pFmt, ...) {
  va_list args;
  va_start(args, pFmt);
  crnd_trace(pFmt, args);
  va_end(args);
};

}  // namespace unitycrnd

// File: checksum.cpp
// From the public domain stb.h header.
namespace unitycrnd {
uint16 crc16(const void* pBuf, uint32 len, uint16 crc) {
  crc = ~crc;

  const uint8* p = reinterpret_cast<const uint8*>(pBuf);
  while (len) {
    const uint16 q = *p++ ^ (crc >> 8U);
    crc <<= 8U;

    uint16 r = (q >> 4U) ^ q;
    crc ^= r;
    r <<= 5U;
    crc ^= r;
    r <<= 7U;
    crc ^= r;

    len--;
  }

  return static_cast<uint16>(~crc);
}

}  // namespace unitycrnd

// File: crnd_vector.cpp
namespace unitycrnd {
bool elemental_vector::increase_capacity(uint32 min_new_capacity, bool grow_hint, uint32 element_size, object_mover pMover) {
  CRND_ASSERT(m_size <= m_capacity);
  CRND_ASSERT(min_new_capacity < (0x7FFF0000U / element_size));

  if (m_capacity >= min_new_capacity)
    return true;

  uint32 new_capacity = min_new_capacity;
  if ((grow_hint) && (!math::is_power_of_2(new_capacity)))
    new_capacity = math::next_pow2(new_capacity);

  CRND_ASSERT(new_capacity && (new_capacity > m_capacity));

  const uint32 desired_size = element_size * new_capacity;
  size_t actual_size;
  if (!pMover) {
    void* new_p = crnd_realloc(m_p, desired_size, &actual_size, true);
    if (!new_p)
      return false;
    m_p = new_p;
  } else {
    void* new_p = crnd_malloc(desired_size, &actual_size);
    if (!new_p)
      return false;

    (*pMover)(new_p, m_p, m_size);

    if (m_p)
      crnd_free(m_p);

    m_p = new_p;
  }

  if (actual_size > desired_size)
    m_capacity = static_cast<uint32>(actual_size / element_size);
  else
    m_capacity = new_capacity;

  return true;
}

}  // namespace unitycrnd

// File: crnd_utils.cpp
namespace unitycrnd {
namespace utils {
uint32 compute_max_mips(uint32 width, uint32 height) {
  if ((width | height) == 0)
    return 0;

  uint32 num_mips = 1;

  while ((width > 1U) || (height > 1U)) {
    width >>= 1U;
    height >>= 1U;
    num_mips++;
  }

  return num_mips;
}

}  // namespace utils

}  // namespace unitycrnd

// File: crnd_prefix_coding.cpp
namespace unitycrnd {
namespace prefix_coding {
bool decoder_tables::init(uint32 num_syms, const uint8* pCodesizes, uint32 table_bits) {
  uint32 min_codes[cMaxExpectedCodeSize];
  if ((!num_syms) || (table_bits > cMaxTableBits))
    return false;

  m_num_syms = num_syms;

  uint32 num_codes[cMaxExpectedCodeSize + 1];
  utils::zero_object(num_codes);

  for (uint32 i = 0; i < num_syms; i++) {
    uint32 c = pCodesizes[i];
    if (c)
      num_codes[c]++;
  }

  uint32 sorted_positions[cMaxExpectedCodeSize + 1];

  uint32 cur_code = 0;

  uint32 total_used_syms = 0;
  uint32 max_code_size = 0;
  uint32 min_code_size = cUINT32_MAX;
  for (uint32 i = 1; i <= cMaxExpectedCodeSize; i++) {
    const uint32 n = num_codes[i];

    if (!n)
      m_max_codes[i - 1] = 0;  //UINT_MAX;
    else {
      min_code_size = math::minimum(min_code_size, i);
      max_code_size = math::maximum(max_code_size, i);

      min_codes[i - 1] = cur_code;

      m_max_codes[i - 1] = cur_code + n - 1;
      m_max_codes[i - 1] = 1 + ((m_max_codes[i - 1] << (16 - i)) | ((1 << (16 - i)) - 1));

      m_val_ptrs[i - 1] = total_used_syms;

      sorted_positions[i] = total_used_syms;

      cur_code += n;
      total_used_syms += n;
    }

    cur_code <<= 1;
  }

  m_total_used_syms = total_used_syms;

  if (total_used_syms > m_cur_sorted_symbol_order_size) {
    m_cur_sorted_symbol_order_size = total_used_syms;

    if (!math::is_power_of_2(total_used_syms))
      m_cur_sorted_symbol_order_size = math::minimum<uint32>(num_syms, math::next_pow2(total_used_syms));

    if (m_sorted_symbol_order)
      crnd_delete_array(m_sorted_symbol_order);

    m_sorted_symbol_order = crnd_new_array<uint16>(m_cur_sorted_symbol_order_size);
    if (!m_sorted_symbol_order)
      return false;
  }

  m_min_code_size = static_cast<uint8>(min_code_size);
  m_max_code_size = static_cast<uint8>(max_code_size);

  for (uint32 i = 0; i < num_syms; i++) {
    uint32 c = pCodesizes[i];
    if (c) {
      CRND_ASSERT(num_codes[c]);

      uint32 sorted_pos = sorted_positions[c]++;

      CRND_ASSERT(sorted_pos < total_used_syms);

      m_sorted_symbol_order[sorted_pos] = static_cast<uint16>(i);
    }
  }

  if (table_bits <= m_min_code_size)
    table_bits = 0;
  m_table_bits = table_bits;

  if (table_bits) {
    uint32 table_size = 1 << table_bits;
    if (table_size > m_cur_lookup_size) {
      m_cur_lookup_size = table_size;

      if (m_lookup)
        crnd_delete_array(m_lookup);

      m_lookup = crnd_new_array<uint32>(table_size);
      if (!m_lookup)
        return false;
    }

    memset(m_lookup, 0xFF, (uint)sizeof(m_lookup[0]) * (1UL << table_bits));

    for (uint32 codesize = 1; codesize <= table_bits; codesize++) {
      if (!num_codes[codesize])
        continue;

      const uint32 fillsize = table_bits - codesize;
      const uint32 fillnum = 1 << fillsize;

      const uint32 min_code = min_codes[codesize - 1];
      const uint32 max_code = get_unshifted_max_code(codesize);
      const uint32 val_ptr = m_val_ptrs[codesize - 1];

      for (uint32 code = min_code; code <= max_code; code++) {
        const uint32 sym_index = m_sorted_symbol_order[val_ptr + code - min_code];
        CRND_ASSERT(pCodesizes[sym_index] == codesize);

        for (uint32 j = 0; j < fillnum; j++) {
          const uint32 t = j + (code << fillsize);

          CRND_ASSERT(t < (1U << table_bits));

          CRND_ASSERT(m_lookup[t] == cUINT32_MAX);

          m_lookup[t] = sym_index | (codesize << 16U);
        }
      }
    }
  }

  for (uint32 i = 0; i < cMaxExpectedCodeSize; i++)
    m_val_ptrs[i] -= min_codes[i];

  m_table_max_code = 0;
  m_decode_start_code_size = m_min_code_size;

  if (table_bits) {
    uint32 i;
    for (i = table_bits; i >= 1; i--) {
      if (num_codes[i]) {
        m_table_max_code = m_max_codes[i - 1];
        break;
      }
    }
    if (i >= 1) {
      m_decode_start_code_size = table_bits + 1;
      for (uint32 j = table_bits + 1; j <= max_code_size; j++) {
        if (num_codes[j]) {
          m_decode_start_code_size = j;
          break;
        }
      }
    }
  }

  // sentinels
  m_max_codes[cMaxExpectedCodeSize] = cUINT32_MAX;
  m_val_ptrs[cMaxExpectedCodeSize] = 0xFFFFF;

  m_table_shift = 32 - m_table_bits;
  return true;
}

}  // namespace prefix_codig

}  // namespace unitycrnd

// File: crnd_platform.cpp
namespace unitycrnd {
bool crnd_is_debugger_present() {
#ifdef CRND_DEVEL
  return IsDebuggerPresent() != 0;
#else
  return false;
#endif
}

void crnd_debug_break() {
#ifdef CRND_DEVEL
  DebugBreak();
#endif
}

void crnd_output_debug_string(const char* p) {
  (void)p;
#ifdef CRND_DEVEL
  OutputDebugStringA(p);
#endif
}

}  // namespace unitycrnd

// File: crnd_mem.cpp
namespace unitycrnd {
const uint32 MAX_POSSIBLE_BLOCK_SIZE = 0x7FFF0000U;

static void* crnd_default_realloc(void* p, size_t size, size_t* pActual_size, bool movable, void*) {
  void* p_new;

  if (!p) {
    p_new = ::malloc(size);

    if (pActual_size) {
#ifdef _WIN32
      *pActual_size = p_new ? ::_msize(p_new) : 0;
#else
      *pActual_size = p_new ? malloc_usable_size(p_new) : 0;
#endif
    }
  } else if (!size) {
    ::free(p);
    p_new = NULL;

    if (pActual_size)
      *pActual_size = 0;
  } else {
    void* p_final_block = p;
#ifdef _WIN32
    p_new = ::_expand(p, size);
#else
    p_new = NULL;
#endif

    if (p_new)
      p_final_block = p_new;
    else if (movable) {
      p_new = ::realloc(p, size);

      if (p_new)
        p_final_block = p_new;
    }

    if (pActual_size) {
#ifdef _WIN32
      *pActual_size = ::_msize(p_final_block);
#else
      *pActual_size = ::malloc_usable_size(p_final_block);
#endif
    }
  }

  return p_new;
}

static size_t crnd_default_msize(void* p, void* pUser_data) {
  pUser_data;
#ifdef _WIN32
  return p ? _msize(p) : 0;
#else
  return p ? malloc_usable_size(p) : 0;
#endif
}

static crnd_realloc_func g_pRealloc = crnd_default_realloc;
static crnd_msize_func g_pMSize = crnd_default_msize;
static void* g_pUser_data;

void crnd_set_memory_callbacks(crnd_realloc_func pRealloc, crnd_msize_func pMSize, void* pUser_data) {
  if ((!pRealloc) || (!pMSize)) {
    g_pRealloc = crnd_default_realloc;
    g_pMSize = crnd_default_msize;
    g_pUser_data = NULL;
  } else {
    g_pRealloc = pRealloc;
    g_pMSize = pMSize;
    g_pUser_data = pUser_data;
  }
}

static inline void crnd_mem_error(const char* p_msg) {
  crnd_assert(p_msg, __FILE__, __LINE__);
}

void* crnd_malloc(size_t size, size_t* pActual_size) {
  size = (size + sizeof(uint32) - 1U) & ~(sizeof(uint32) - 1U);
  if (!size)
    size = sizeof(uint32);

  if (size > MAX_POSSIBLE_BLOCK_SIZE) {
    crnd_mem_error("crnd_malloc: size too big");
    return NULL;
  }

  size_t actual_size = size;
  uint8* p_new = static_cast<uint8*>((*g_pRealloc)(NULL, size, &actual_size, true, g_pUser_data));

  if (pActual_size)
    *pActual_size = actual_size;

  if ((!p_new) || (actual_size < size)) {
    crnd_mem_error("crnd_malloc: out of memory");
    return NULL;
  }

  CRND_ASSERT(((uint32) reinterpret_cast<uintptr_t>(p_new) & (CRND_MIN_ALLOC_ALIGNMENT - 1)) == 0);

  return p_new;
}

void* crnd_realloc(void* p, size_t size, size_t* pActual_size, bool movable) {
  if ((uint32) reinterpret_cast<uintptr_t>(p) & (CRND_MIN_ALLOC_ALIGNMENT - 1)) {
    crnd_mem_error("crnd_realloc: bad ptr");
    return NULL;
  }

  if (size > MAX_POSSIBLE_BLOCK_SIZE) {
    crnd_mem_error("crnd_malloc: size too big");
    return NULL;
  }

  size_t actual_size = size;
  void* p_new = (*g_pRealloc)(p, size, &actual_size, movable, g_pUser_data);

  if (pActual_size)
    *pActual_size = actual_size;

  CRND_ASSERT(((uint32) reinterpret_cast<uintptr_t>(p_new) & (CRND_MIN_ALLOC_ALIGNMENT - 1)) == 0);

  return p_new;
}

void crnd_free(void* p) {
  if (!p)
    return;

  if ((uint32) reinterpret_cast<uintptr_t>(p) & (CRND_MIN_ALLOC_ALIGNMENT - 1)) {
    crnd_mem_error("crnd_free: bad ptr");
    return;
  }

  (*g_pRealloc)(p, 0, NULL, true, g_pUser_data);
}

size_t crnd_msize(void* p) {
  if (!p)
    return 0;

  if ((uint32) reinterpret_cast<uintptr_t>(p) & (CRND_MIN_ALLOC_ALIGNMENT - 1)) {
    crnd_mem_error("crnd_msize: bad ptr");
    return 0;
  }

  return (*g_pMSize)(p, g_pUser_data);
}

}  // namespace unitycrnd

// File: crnd_math.cpp
namespace unitycrnd {
namespace math {
uint32 g_bitmasks[32] =
    {
        1U << 0U, 1U << 1U, 1U << 2U, 1U << 3U,
        1U << 4U, 1U << 5U, 1U << 6U, 1U << 7U,
        1U << 8U, 1U << 9U, 1U << 10U, 1U << 11U,
        1U << 12U, 1U << 13U, 1U << 14U, 1U << 15U,
        1U << 16U, 1U << 17U, 1U << 18U, 1U << 19U,
        1U << 20U, 1U << 21U, 1U << 22U, 1U << 23U,
        1U << 24U, 1U << 25U, 1U << 26U, 1U << 27U,
        1U << 28U, 1U << 29U, 1U << 30U, 1U << 31U};

}  // namespace math
}  // namespace unitycrnd

// File: crnd_info.cpp
namespace unitycrnd {
#define CRND_FOURCC(a, b, c, d) ((a) | ((b) << 8U) | ((c) << 16U) | ((d) << 24U))

uint32 crnd_crn_format_to_fourcc(crn_format fmt) {
  switch (fmt) {
    case cCRNFmtDXT1:
      return CRND_FOURCC('D', 'X', 'T', '1');
    case cCRNFmtDXT3:
      return CRND_FOURCC('D', 'X', 'T', '3');
    case cCRNFmtDXT5:
      return CRND_FOURCC('D', 'X', 'T', '5');
    case cCRNFmtDXN_XY:
      return CRND_FOURCC('A', '2', 'X', 'Y');
    case cCRNFmtDXN_YX:
      return CRND_FOURCC('A', 'T', 'I', '2');
    case cCRNFmtDXT5A:
      return CRND_FOURCC('A', 'T', 'I', '1');
    case cCRNFmtDXT5_CCxY:
      return CRND_FOURCC('C', 'C', 'x', 'Y');
    case cCRNFmtDXT5_xGxR:
      return CRND_FOURCC('x', 'G', 'x', 'R');
    case cCRNFmtDXT5_xGBR:
      return CRND_FOURCC('x', 'G', 'B', 'R');
    case cCRNFmtDXT5_AGBR:
      return CRND_FOURCC('A', 'G', 'B', 'R');
    case cCRNFmtETC1:
      return CRND_FOURCC('E', 'T', 'C', '1');
    case cCRNFmtETC2:
      return CRND_FOURCC('E', 'T', 'C', '2');
    case cCRNFmtETC2A:
      return CRND_FOURCC('E', 'T', '2', 'A');
    case cCRNFmtETC1S:
      return CRND_FOURCC('E', 'T', '1', 'S');
    case cCRNFmtETC2AS:
      return CRND_FOURCC('E', '2', 'A', 'S');
    default:
      break;
  }
  CRND_ASSERT(false);
  return 0;
}

crn_format crnd_get_fundamental_dxt_format(crn_format fmt) {
  switch (fmt) {
    case cCRNFmtDXT5_CCxY:
    case cCRNFmtDXT5_xGxR:
    case cCRNFmtDXT5_xGBR:
    case cCRNFmtDXT5_AGBR:
      return cCRNFmtDXT5;
    default:
      break;
  }
  return fmt;
}

uint32 crnd_get_crn_format_bits_per_texel(crn_format fmt) {
  switch (fmt) {
    case cCRNFmtDXT1:
    case cCRNFmtDXT5A:
    case cCRNFmtETC1:
    case cCRNFmtETC2:
    case cCRNFmtETC1S:
      return 4;
    case cCRNFmtDXT3:
    case cCRNFmtDXT5:
    case cCRNFmtDXN_XY:
    case cCRNFmtDXN_YX:
    case cCRNFmtDXT5_CCxY:
    case cCRNFmtDXT5_xGxR:
    case cCRNFmtDXT5_xGBR:
    case cCRNFmtDXT5_AGBR:
    case cCRNFmtETC2A:
    case cCRNFmtETC2AS:
      return 8;
    default:
      break;
  }
  CRND_ASSERT(false);
  return 0;
}

uint32 crnd_get_bytes_per_dxt_block(crn_format fmt) {
  return (crnd_get_crn_format_bits_per_texel(fmt) << 4) >> 3;
}

// TODO: tmp_header isn't used/This function is a helper to support old headers.
const crn_header* crnd_get_header(const void* pData, uint32 data_size) {
  if ((!pData) || (data_size < sizeof(crn_header)))
    return NULL;

  const crn_header& file_header = *static_cast<const crn_header*>(pData);
  if (file_header.m_sig != crn_header::cCRNSigValue)
    return NULL;

  if ((file_header.m_header_size < sizeof(crn_header)) || (data_size < file_header.m_data_size))
    return NULL;

  return &file_header;
}

bool crnd_validate_file(const void* pData, uint32 data_size, crn_file_info* pFile_info) {
  if (pFile_info) {
    if (pFile_info->m_struct_size != sizeof(crn_file_info))
      return false;

    memset(&pFile_info->m_struct_size + 1, 0, sizeof(crn_file_info) - sizeof(pFile_info->m_struct_size));
  }

  if ((!pData) || (data_size < cCRNHeaderMinSize))
    return false;

  const crn_header* pHeader = crnd_get_header(pData, data_size);
  if (!pHeader)
    return false;

  const uint32 header_crc = crc16(&pHeader->m_data_size, (uint32)(pHeader->m_header_size - ((const uint8*)&pHeader->m_data_size - (const uint8*)pHeader)));
  if (header_crc != pHeader->m_header_crc16)
    return false;

  const uint32 data_crc = crc16((const uint8*)pData + pHeader->m_header_size, pHeader->m_data_size - pHeader->m_header_size);
  if (data_crc != pHeader->m_data_crc16)
    return false;

  if ((pHeader->m_faces != 1) && (pHeader->m_faces != 6))
    return false;
  if ((pHeader->m_width < 1) || (pHeader->m_width > cCRNMaxLevelResolution))
    return false;
  if ((pHeader->m_height < 1) || (pHeader->m_height > cCRNMaxLevelResolution))
    return false;
  if ((pHeader->m_levels < 1) || (pHeader->m_levels > utils::compute_max_mips(pHeader->m_width, pHeader->m_height)))
    return false;
  if (((int)pHeader->m_format < cCRNFmtDXT1) || ((int)pHeader->m_format >= cCRNFmtTotal))
    return false;

  if (pFile_info) {
    pFile_info->m_actual_data_size = pHeader->m_data_size;
    pFile_info->m_header_size = pHeader->m_header_size;
    pFile_info->m_total_palette_size = pHeader->m_color_endpoints.m_size + pHeader->m_color_selectors.m_size + pHeader->m_alpha_endpoints.m_size + pHeader->m_alpha_selectors.m_size;
    pFile_info->m_tables_size = pHeader->m_tables_size;

    pFile_info->m_levels = pHeader->m_levels;

    for (uint32 i = 0; i < pHeader->m_levels; i++) {
      uint32 next_ofs = pHeader->m_data_size;

      // assumes the levels are packed together sequentially
      if ((i + 1) < pHeader->m_levels)
        next_ofs = pHeader->m_level_ofs[i + 1];

      pFile_info->m_level_compressed_size[i] = next_ofs - pHeader->m_level_ofs[i];
    }

    pFile_info->m_color_endpoint_palette_entries = pHeader->m_color_endpoints.m_num;
    pFile_info->m_color_selector_palette_entries = pHeader->m_color_selectors.m_num;
    ;
    pFile_info->m_alpha_endpoint_palette_entries = pHeader->m_alpha_endpoints.m_num;
    ;
    pFile_info->m_alpha_selector_palette_entries = pHeader->m_alpha_selectors.m_num;
    ;
  }

  return true;
}

bool crnd_get_texture_info(const void* pData, uint32 data_size, crn_texture_info* pInfo) {
  if ((!pData) || (data_size < sizeof(crn_header)) || (!pInfo))
    return false;

  if (pInfo->m_struct_size != sizeof(crn_texture_info))
    return false;

  const crn_header* pHeader = crnd_get_header(pData, data_size);
  if (!pHeader)
    return false;

  pInfo->m_width = pHeader->m_width;
  pInfo->m_height = pHeader->m_height;
  pInfo->m_levels = pHeader->m_levels;
  pInfo->m_faces = pHeader->m_faces;
  pInfo->m_format = static_cast<crn_format>((uint32)pHeader->m_format);
  pInfo->m_bytes_per_block = pHeader->m_format == cCRNFmtDXT1 || pHeader->m_format == cCRNFmtDXT5A || pHeader->m_format == cCRNFmtETC1 || pHeader->m_format == cCRNFmtETC2 || pHeader->m_format == cCRNFmtETC1S ? 8 : 16;
  pInfo->m_userdata0 = pHeader->m_userdata0;
  pInfo->m_userdata1 = pHeader->m_userdata1;

  return true;
}

bool crnd_get_level_info(const void* pData, uint32 data_size, uint32 level_index, crn_level_info* pLevel_info) {
  if ((!pData) || (data_size < cCRNHeaderMinSize) || (!pLevel_info))
    return false;

  if (pLevel_info->m_struct_size != sizeof(crn_level_info))
    return false;

  const crn_header* pHeader = crnd_get_header(pData, data_size);
  if (!pHeader)
    return false;

  if (level_index >= pHeader->m_levels)
    return false;

  uint32 width = math::maximum<uint32>(1U, pHeader->m_width >> level_index);
  uint32 height = math::maximum<uint32>(1U, pHeader->m_height >> level_index);

  pLevel_info->m_width = width;
  pLevel_info->m_height = height;
  pLevel_info->m_faces = pHeader->m_faces;
  pLevel_info->m_blocks_x = (width + 3) >> 2;
  pLevel_info->m_blocks_y = (height + 3) >> 2;
  pLevel_info->m_bytes_per_block = ((pHeader->m_format == cCRNFmtDXT1) || (pHeader->m_format == cCRNFmtDXT5A)) ? 8 : 16;
  pLevel_info->m_format = static_cast<crn_format>((uint32)pHeader->m_format);

  return true;
}

const void* crnd_get_level_data(const void* pData, uint32 data_size, uint32 level_index, uint32* pSize) {
  if (pSize)
    *pSize = 0;

  if ((!pData) || (data_size < cCRNHeaderMinSize))
    return NULL;

  const crn_header* pHeader = crnd_get_header(pData, data_size);
  if (!pHeader)
    return NULL;

  if (level_index >= pHeader->m_levels)
    return NULL;

  uint32 cur_level_ofs = pHeader->m_level_ofs[level_index];

  if (pSize) {
    uint32 next_level_ofs = data_size;
    if ((level_index + 1) < (pHeader->m_levels))
      next_level_ofs = pHeader->m_level_ofs[level_index + 1];

    *pSize = next_level_ofs - cur_level_ofs;
  }

  return static_cast<const uint8*>(pData) + cur_level_ofs;
}

uint32 crnd_get_segmented_file_size(const void* pData, uint32 data_size) {
  if ((!pData) || (data_size < cCRNHeaderMinSize))
    return false;

  const crn_header* pHeader = crnd_get_header(pData, data_size);
  if (!pHeader)
    return false;

  uint32 size = pHeader->m_header_size;

  size = math::maximum(size, pHeader->m_color_endpoints.m_ofs + pHeader->m_color_endpoints.m_size);
  size = math::maximum(size, pHeader->m_color_selectors.m_ofs + pHeader->m_color_selectors.m_size);
  size = math::maximum(size, pHeader->m_alpha_endpoints.m_ofs + pHeader->m_alpha_endpoints.m_size);
  size = math::maximum(size, pHeader->m_alpha_selectors.m_ofs + pHeader->m_alpha_selectors.m_size);
  size = math::maximum(size, pHeader->m_tables_ofs + pHeader->m_tables_size);

  return size;
}

bool crnd_create_segmented_file(const void* pData, uint32 data_size, void* pBase_data, uint base_data_size) {
  if ((!pData) || (data_size < cCRNHeaderMinSize))
    return false;

  const crn_header* pHeader = crnd_get_header(pData, data_size);
  if (!pHeader)
    return false;

  if (pHeader->m_flags & cCRNHeaderFlagSegmented)
    return false;

  const uint actual_base_data_size = crnd_get_segmented_file_size(pData, data_size);
  if (base_data_size < actual_base_data_size)
    return false;

  memcpy(pBase_data, pData, actual_base_data_size);

  crn_header& new_header = *static_cast<crn_header*>(pBase_data);
  new_header.m_flags = new_header.m_flags | cCRNHeaderFlagSegmented;
  new_header.m_data_size = actual_base_data_size;

  new_header.m_data_crc16 = crc16((const uint8*)pBase_data + new_header.m_header_size, new_header.m_data_size - new_header.m_header_size);

  new_header.m_header_crc16 = crc16(&new_header.m_data_size, new_header.m_header_size - (uint32)((const uint8*)&new_header.m_data_size - (const uint8*)&new_header));

  CRND_ASSERT(crnd_validate_file(&new_header, actual_base_data_size, NULL));

  return true;
}

}  // namespace unitycrnd

// File: symbol_codec.cpp
namespace unitycrnd {
static_huffman_data_model::static_huffman_data_model()
    : m_total_syms(0),
      m_pDecode_tables(NULL) {
}

static_huffman_data_model::static_huffman_data_model(const static_huffman_data_model& other)
    : m_total_syms(0),
      m_pDecode_tables(NULL) {
  *this = other;
}

static_huffman_data_model::~static_huffman_data_model() {
  if (m_pDecode_tables)
    crnd_delete(m_pDecode_tables);
}

static_huffman_data_model& static_huffman_data_model::operator=(const static_huffman_data_model& rhs) {
  if (this == &rhs)
    return *this;

  m_total_syms = rhs.m_total_syms;
  m_code_sizes = rhs.m_code_sizes;
  if (m_code_sizes.get_alloc_failed()) {
    clear();
    return *this;
  }

  if (rhs.m_pDecode_tables) {
    if (m_pDecode_tables)
      *m_pDecode_tables = *rhs.m_pDecode_tables;
    else
      m_pDecode_tables = crnd_new<prefix_coding::decoder_tables>(*rhs.m_pDecode_tables);
  } else {
    crnd_delete(m_pDecode_tables);
    m_pDecode_tables = NULL;
  }

  return *this;
}

void static_huffman_data_model::clear() {
  m_total_syms = 0;
  m_code_sizes.clear();
  if (m_pDecode_tables) {
    crnd_delete(m_pDecode_tables);
    m_pDecode_tables = NULL;
  }
}

bool static_huffman_data_model::init(uint32 total_syms, const uint8* pCode_sizes, uint32 code_size_limit) {
  CRND_ASSERT((total_syms >= 1) && (total_syms <= prefix_coding::cMaxSupportedSyms) && (code_size_limit >= 1));

  code_size_limit = math::minimum(code_size_limit, prefix_coding::cMaxExpectedCodeSize);

  if (!m_code_sizes.resize(total_syms))
    return false;

  uint32 min_code_size = cUINT32_MAX;
  uint32 max_code_size = 0;

  for (uint32 i = 0; i < total_syms; i++) {
    uint32 s = pCode_sizes[i];
    m_code_sizes[i] = static_cast<uint8>(s);
    min_code_size = math::minimum(min_code_size, s);
    max_code_size = math::maximum(max_code_size, s);
  }

  if ((max_code_size < 1) || (max_code_size > 32) || (min_code_size > code_size_limit))
    return false;

  if (max_code_size > code_size_limit)
    return false;

  if (!m_pDecode_tables)
    m_pDecode_tables = crnd_new<prefix_coding::decoder_tables>();

  if (!m_pDecode_tables->init(m_total_syms, &m_code_sizes[0], compute_decoder_table_bits()))
    return false;

  return true;
}

bool static_huffman_data_model::prepare_decoder_tables() {
  uint32 total_syms = m_code_sizes.size();

  CRND_ASSERT((total_syms >= 1) && (total_syms <= prefix_coding::cMaxSupportedSyms));

  m_total_syms = total_syms;

  if (!m_pDecode_tables)
    m_pDecode_tables = crnd_new<prefix_coding::decoder_tables>();

  return m_pDecode_tables->init(m_total_syms, &m_code_sizes[0], compute_decoder_table_bits());
}

uint static_huffman_data_model::compute_decoder_table_bits() const {
#if CRND_PREFIX_CODING_USE_FIXED_TABLE_SIZE
  return prefix_coding::cMaxTableBits;
#else
  uint32 decoder_table_bits = 0;
  if (m_total_syms > 16)
    decoder_table_bits = static_cast<uint8>(math::minimum(1 + math::ceil_log2i(m_total_syms), prefix_coding::cMaxTableBits));
  return decoder_table_bits;
#endif
}

symbol_codec::symbol_codec()
    : m_pDecode_buf(NULL),
      m_pDecode_buf_next(NULL),
      m_pDecode_buf_end(NULL),
      m_decode_buf_size(0),
      m_bit_buf(0),
      m_bit_count(0) {
}

// Code length encoding symbols:
// 0-16 - actual code lengths
const uint32 cMaxCodelengthCodes = 21;

const uint32 cSmallZeroRunCode = 17;
const uint32 cLargeZeroRunCode = 18;
const uint32 cSmallRepeatCode = 19;
const uint32 cLargeRepeatCode = 20;

const uint32 cMinSmallZeroRunSize = 3;
const uint32 cMaxSmallZeroRunSize = 10;
const uint32 cMinLargeZeroRunSize = 11;
const uint32 cMaxLargeZeroRunSize = 138;

const uint32 cSmallMinNonZeroRunSize = 3;
const uint32 cSmallMaxNonZeroRunSize = 6;
const uint32 cLargeMinNonZeroRunSize = 7;
const uint32 cLargeMaxNonZeroRunSize = 70;

const uint32 cSmallZeroRunExtraBits = 3;
const uint32 cLargeZeroRunExtraBits = 7;
const uint32 cSmallNonZeroRunExtraBits = 2;
const uint32 cLargeNonZeroRunExtraBits = 6;

static const uint8 g_most_probable_codelength_codes[] =
    {
        cSmallZeroRunCode, cLargeZeroRunCode,
        cSmallRepeatCode, cLargeRepeatCode,

        0, 8,
        7, 9,
        6, 10,
        5, 11,
        4, 12,
        3, 13,
        2, 14,
        1, 15,
        16};
const uint32 cNumMostProbableCodelengthCodes = sizeof(g_most_probable_codelength_codes) / sizeof(g_most_probable_codelength_codes[0]);

bool symbol_codec::decode_receive_static_data_model(static_huffman_data_model& model) {
  const uint32 total_used_syms = decode_bits(math::total_bits(prefix_coding::cMaxSupportedSyms));

  if (!total_used_syms) {
    model.clear();
    return true;
  }

  if (!model.m_code_sizes.resize(total_used_syms))
    return false;

  memset(&model.m_code_sizes[0], 0, sizeof(model.m_code_sizes[0]) * total_used_syms);

  const uint32 num_codelength_codes_to_send = decode_bits(5);
  if ((num_codelength_codes_to_send < 1) || (num_codelength_codes_to_send > cMaxCodelengthCodes))
    return false;

  static_huffman_data_model dm;
  if (!dm.m_code_sizes.resize(cMaxCodelengthCodes))
    return false;

  for (uint32 i = 0; i < num_codelength_codes_to_send; i++)
    dm.m_code_sizes[g_most_probable_codelength_codes[i]] = static_cast<uint8>(decode_bits(3));

  if (!dm.prepare_decoder_tables())
    return false;

  uint32 ofs = 0;
  while (ofs < total_used_syms) {
    const uint32 num_remaining = total_used_syms - ofs;

    uint32 code = decode(dm);
    if (code <= 16)
      model.m_code_sizes[ofs++] = static_cast<uint8>(code);
    else if (code == cSmallZeroRunCode) {
      uint32 len = decode_bits(cSmallZeroRunExtraBits) + cMinSmallZeroRunSize;
      if (len > num_remaining)
        return false;
      ofs += len;
    } else if (code == cLargeZeroRunCode) {
      uint32 len = decode_bits(cLargeZeroRunExtraBits) + cMinLargeZeroRunSize;
      if (len > num_remaining)
        return false;
      ofs += len;
    } else if ((code == cSmallRepeatCode) || (code == cLargeRepeatCode)) {
      uint32 len;
      if (code == cSmallRepeatCode)
        len = decode_bits(cSmallNonZeroRunExtraBits) + cSmallMinNonZeroRunSize;
      else
        len = decode_bits(cLargeNonZeroRunExtraBits) + cLargeMinNonZeroRunSize;

      if ((!ofs) || (len > num_remaining))
        return false;
      const uint32 prev = model.m_code_sizes[ofs - 1];
      if (!prev)
        return false;
      const uint32 end = ofs + len;
      while (ofs < end)
        model.m_code_sizes[ofs++] = static_cast<uint8>(prev);
    } else {
      CRND_ASSERT(0);
      return false;
    }
  }

  if (ofs != total_used_syms)
    return false;

  return model.prepare_decoder_tables();
}

bool symbol_codec::start_decoding(const uint8* pBuf, uint32 buf_size) {
  if (!buf_size)
    return false;

  m_pDecode_buf = pBuf;
  m_pDecode_buf_next = pBuf;
  m_decode_buf_size = buf_size;
  m_pDecode_buf_end = pBuf + buf_size;

  get_bits_init();

  return true;
}

void symbol_codec::get_bits_init() {
  m_bit_buf = 0;
  m_bit_count = 0;
}

uint32 symbol_codec::decode_bits(uint32 num_bits) {
  if (!num_bits)
    return 0;

  if (num_bits > 16) {
    uint32 a = get_bits(num_bits - 16);
    uint32 b = get_bits(16);

    return (a << 16) | b;
  } else
    return get_bits(num_bits);
}

uint32 symbol_codec::get_bits(uint32 num_bits) {
  CRND_ASSERT(num_bits <= 32U);

  while (m_bit_count < (int)num_bits) {
    bit_buf_type c = 0;
    if (m_pDecode_buf_next != m_pDecode_buf_end)
      c = *m_pDecode_buf_next++;

    m_bit_count += 8;
    CRND_ASSERT(m_bit_count <= cBitBufSize);

    m_bit_buf |= (c << (cBitBufSize - m_bit_count));
  }

  uint32 result = static_cast<uint32>(m_bit_buf >> (cBitBufSize - num_bits));

  m_bit_buf <<= num_bits;
  m_bit_count -= num_bits;

  return result;
}

uint32 symbol_codec::decode(const static_huffman_data_model& model) {
  const prefix_coding::decoder_tables* pTables = model.m_pDecode_tables;

  if (m_bit_count < 24) {
    if (m_bit_count < 16) {
      uint32 c0 = 0, c1 = 0;
      const uint8* p = m_pDecode_buf_next;
      if (p < m_pDecode_buf_end)
        c0 = *p++;
      if (p < m_pDecode_buf_end)
        c1 = *p++;
      m_pDecode_buf_next = p;
      m_bit_count += 16;
      uint32 c = (c0 << 8) | c1;
      m_bit_buf |= (c << (32 - m_bit_count));
    } else {
      uint32 c = (m_pDecode_buf_next < m_pDecode_buf_end) ? *m_pDecode_buf_next++ : 0;
      m_bit_count += 8;
      m_bit_buf |= (c << (32 - m_bit_count));
    }
  }

  uint32 k = (m_bit_buf >> 16) + 1;
  uint32 sym, len;

  if (k <= pTables->m_table_max_code) {
    uint32 t = pTables->m_lookup[m_bit_buf >> (32 - pTables->m_table_bits)];

    CRND_ASSERT(t != cUINT32_MAX);
    sym = t & cUINT16_MAX;
    len = t >> 16;

    CRND_ASSERT(model.m_code_sizes[sym] == len);
  } else {
    len = pTables->m_decode_start_code_size;

    for (;;) {
      if (k <= pTables->m_max_codes[len - 1])
        break;
      len++;
    }

    int val_ptr = pTables->m_val_ptrs[len - 1] + (m_bit_buf >> (32 - len));

    if (((uint32)val_ptr >= model.m_total_syms)) {
      // corrupted stream, or a bug
      CRND_ASSERT(0);
      return 0;
    }

    sym = pTables->m_sorted_symbol_order[val_ptr];
  }

  m_bit_buf <<= len;
  m_bit_count -= len;

  return sym;
}

uint64 symbol_codec::stop_decoding() {
  return static_cast<uint64>(m_pDecode_buf_next - m_pDecode_buf);
}

}  // namespace unitycrnd

// File: crnd_dxt.cpp
namespace unitycrnd {
const uint8 g_dxt1_to_linear[cDXT1SelectorValues] = {0U, 3U, 1U, 2U};
const uint8 g_dxt1_from_linear[cDXT1SelectorValues] = {0U, 2U, 3U, 1U};
const uint8 g_etc1_from_linear[cDXT1SelectorValues] = {3U, 2U, 0U, 1U};

const uint8 g_dxt5_to_linear[cDXT5SelectorValues] = {0U, 7U, 1U, 2U, 3U, 4U, 5U, 6U};
const uint8 g_dxt5_from_linear[cDXT5SelectorValues] = {0U, 2U, 3U, 4U, 5U, 6U, 7U, 1U};

const uint8 g_six_alpha_invert_table[cDXT5SelectorValues] = {1, 0, 5, 4, 3, 2, 6, 7};
const uint8 g_eight_alpha_invert_table[cDXT5SelectorValues] = {1, 0, 7, 6, 5, 4, 3, 2};

uint16 dxt1_block::pack_color(const color_quad_u8& color, bool scaled, uint32 bias) {
  uint32 r = color.r;
  uint32 g = color.g;
  uint32 b = color.b;

  if (scaled) {
    r = (r * 31U + bias) / 255U;
    g = (g * 63U + bias) / 255U;
    b = (b * 31U + bias) / 255U;
  }

  r = math::minimum(r, 31U);
  g = math::minimum(g, 63U);
  b = math::minimum(b, 31U);

  return static_cast<uint16>(b | (g << 5U) | (r << 11U));
}

uint16 dxt1_block::pack_color(uint32 r, uint32 g, uint32 b, bool scaled, uint32 bias) {
  return pack_color(color_quad_u8(r, g, b, 0), scaled, bias);
}

color_quad_u8 dxt1_block::unpack_color(uint16 packed_color, bool scaled, uint32 alpha) {
  uint32 b = packed_color & 31U;
  uint32 g = (packed_color >> 5U) & 63U;
  uint32 r = (packed_color >> 11U) & 31U;

  if (scaled) {
    b = (b << 3U) | (b >> 2U);
    g = (g << 2U) | (g >> 4U);
    r = (r << 3U) | (r >> 2U);
  }

  return color_quad_u8(r, g, b, alpha);
}

void dxt1_block::unpack_color(uint32& r, uint32& g, uint32& b, uint16 packed_color, bool scaled) {
  color_quad_u8 c(unpack_color(packed_color, scaled, 0));
  r = c.r;
  g = c.g;
  b = c.b;
}

uint32 dxt1_block::get_block_colors3(color_quad_u8* pDst, uint16 color0, uint16 color1) {
  color_quad_u8 c0(unpack_color(color0, true));
  color_quad_u8 c1(unpack_color(color1, true));

  pDst[0] = c0;
  pDst[1] = c1;
  pDst[2].set((c0.r + c1.r) >> 1U, (c0.g + c1.g) >> 1U, (c0.b + c1.b) >> 1U, 255U);
  pDst[3].set(0, 0, 0, 0);

  return 3;
}

uint32 dxt1_block::get_block_colors4(color_quad_u8* pDst, uint16 color0, uint16 color1) {
  color_quad_u8 c0(unpack_color(color0, true));
  color_quad_u8 c1(unpack_color(color1, true));

  pDst[0] = c0;
  pDst[1] = c1;

  // 12/14/09 - Supposed to round according to DX docs, but this conflicts with the OpenGL S3TC spec. ?
  // Turns out some GPU's round and some don't. Great.
  //pDst[2].set( (c0.r * 2 + c1.r + 1) / 3, (c0.g * 2 + c1.g + 1) / 3, (c0.b * 2 + c1.b + 1) / 3, 255U);
  //pDst[3].set( (c1.r * 2 + c0.r + 1) / 3, (c1.g * 2 + c0.g + 1) / 3, (c1.b * 2 + c0.b + 1) / 3, 255U);

  pDst[2].set((c0.r * 2 + c1.r) / 3, (c0.g * 2 + c1.g) / 3, (c0.b * 2 + c1.b) / 3, 255U);
  pDst[3].set((c1.r * 2 + c0.r) / 3, (c1.g * 2 + c0.g) / 3, (c1.b * 2 + c0.b) / 3, 255U);

  return 4;
}

uint32 dxt1_block::get_block_colors(color_quad_u8* pDst, uint16 color0, uint16 color1) {
  if (color0 > color1)
    return get_block_colors4(pDst, color0, color1);
  else
    return get_block_colors3(pDst, color0, color1);
}

color_quad_u8 dxt1_block::unpack_endpoint(uint32 endpoints, uint32 index, bool scaled, uint32 alpha) {
  CRND_ASSERT(index < 2);
  return unpack_color(static_cast<uint16>((endpoints >> (index * 16U)) & 0xFFFFU), scaled, alpha);
}

uint32 dxt1_block::pack_endpoints(uint32 lo, uint32 hi) {
  CRND_ASSERT((lo <= 0xFFFFU) && (hi <= 0xFFFFU));
  return lo | (hi << 16U);
}

void dxt3_block::set_alpha(uint32 x, uint32 y, uint32 value, bool scaled) {
  CRND_ASSERT((x < cDXTBlockSize) && (y < cDXTBlockSize));

  if (scaled) {
    CRND_ASSERT(value <= 0xFF);
    value = (value * 15U + 128U) / 255U;
  } else {
    CRND_ASSERT(value <= 0xF);
  }

  uint32 ofs = (y << 1U) + (x >> 1U);
  uint32 c = m_alpha[ofs];

  c &= ~(0xF << ((x & 1U) << 2U));
  c |= (value << ((x & 1U) << 2U));

  m_alpha[ofs] = static_cast<uint8>(c);
}

uint32 dxt3_block::get_alpha(uint32 x, uint32 y, bool scaled) const {
  CRND_ASSERT((x < cDXTBlockSize) && (y < cDXTBlockSize));

  uint32 value = m_alpha[(y << 1U) + (x >> 1U)];
  if (x & 1)
    value >>= 4;
  value &= 0xF;

  if (scaled)
    value = (value << 4U) | value;

  return value;
}

uint32 dxt5_block::get_block_values6(color_quad_u8* pDst, uint32 l, uint32 h) {
  pDst[0].a = static_cast<uint8>(l);
  pDst[1].a = static_cast<uint8>(h);
  pDst[2].a = static_cast<uint8>((l * 4 + h) / 5);
  pDst[3].a = static_cast<uint8>((l * 3 + h * 2) / 5);
  pDst[4].a = static_cast<uint8>((l * 2 + h * 3) / 5);
  pDst[5].a = static_cast<uint8>((l + h * 4) / 5);
  pDst[6].a = 0;
  pDst[7].a = 255;
  return 6;
}

uint32 dxt5_block::get_block_values8(color_quad_u8* pDst, uint32 l, uint32 h) {
  pDst[0].a = static_cast<uint8>(l);
  pDst[1].a = static_cast<uint8>(h);
  pDst[2].a = static_cast<uint8>((l * 6 + h) / 7);
  pDst[3].a = static_cast<uint8>((l * 5 + h * 2) / 7);
  pDst[4].a = static_cast<uint8>((l * 4 + h * 3) / 7);
  pDst[5].a = static_cast<uint8>((l * 3 + h * 4) / 7);
  pDst[6].a = static_cast<uint8>((l * 2 + h * 5) / 7);
  pDst[7].a = static_cast<uint8>((l + h * 6) / 7);
  return 8;
}

uint32 dxt5_block::get_block_values(color_quad_u8* pDst, uint32 l, uint32 h) {
  if (l > h)
    return get_block_values8(pDst, l, h);
  else
    return get_block_values6(pDst, l, h);
}

uint32 dxt5_block::get_block_values6(uint32* pDst, uint32 l, uint32 h) {
  pDst[0] = l;
  pDst[1] = h;
  pDst[2] = (l * 4 + h) / 5;
  pDst[3] = (l * 3 + h * 2) / 5;
  pDst[4] = (l * 2 + h * 3) / 5;
  pDst[5] = (l + h * 4) / 5;
  pDst[6] = 0;
  pDst[7] = 255;
  return 6;
}

uint32 dxt5_block::get_block_values8(uint32* pDst, uint32 l, uint32 h) {
  pDst[0] = l;
  pDst[1] = h;
  pDst[2] = (l * 6 + h) / 7;
  pDst[3] = (l * 5 + h * 2) / 7;
  pDst[4] = (l * 4 + h * 3) / 7;
  pDst[5] = (l * 3 + h * 4) / 7;
  pDst[6] = (l * 2 + h * 5) / 7;
  pDst[7] = (l + h * 6) / 7;
  return 8;
}

uint32 dxt5_block::unpack_endpoint(uint32 packed, uint32 index) {
  CRND_ASSERT(index < 2);
  return (packed >> (8 * index)) & 0xFF;
}

uint32 dxt5_block::pack_endpoints(uint32 lo, uint32 hi) {
  CRND_ASSERT((lo <= 0xFF) && (hi <= 0xFF));
  return lo | (hi << 8U);
}

uint32 dxt5_block::get_block_values(uint32* pDst, uint32 l, uint32 h) {
  if (l > h)
    return get_block_values8(pDst, l, h);
  else
    return get_block_values6(pDst, l, h);
}

}  // namespace unitycrnd

// File: crnd_decode.cpp

namespace unitycrnd {

class crn_unpacker {
 public:
  inline crn_unpacker()
      : m_magic(cMagicValue),
        m_pData(NULL),
        m_data_size(0),
        m_pHeader(NULL) {
  }

  inline ~crn_unpacker() {
    m_magic = 0;
  }

  inline bool is_valid() const { return m_magic == cMagicValue; }

  bool init(const void* pData, uint32 data_size) {
    m_pHeader = crnd_get_header(pData, data_size);
    if (!m_pHeader)
      return false;

    m_pData = static_cast<const uint8*>(pData);
    m_data_size = data_size;

    if (!init_tables())
      return false;

    if (!decode_palettes())
      return false;

    return true;
  }

  bool unpack_level(
      void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
      uint32 level_index) {
    uint32 cur_level_ofs = m_pHeader->m_level_ofs[level_index];

    uint32 next_level_ofs = m_data_size;
    if ((level_index + 1) < (m_pHeader->m_levels))
      next_level_ofs = m_pHeader->m_level_ofs[level_index + 1];

    CRND_ASSERT(next_level_ofs > cur_level_ofs);

    return unpack_level(m_pData + cur_level_ofs, next_level_ofs - cur_level_ofs, pDst, dst_size_in_bytes, row_pitch_in_bytes, level_index);
  }

  bool unpack_level(
      const void* pSrc, uint32 src_size_in_bytes,
      void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
      uint32 level_index) {

#ifdef CRND_BUILD_DEBUG
    for (uint32 f = 0; f < m_pHeader->m_faces; f++)
      if (!pDst[f])
        return false;
#endif

    const uint32 width = math::maximum(m_pHeader->m_width >> level_index, 1U);
    const uint32 height = math::maximum(m_pHeader->m_height >> level_index, 1U);
    const uint32 blocks_x = (width + 3U) >> 2U;
    const uint32 blocks_y = (height + 3U) >> 2U;
    const uint32 block_size = m_pHeader->m_format == cCRNFmtDXT1 || m_pHeader->m_format == cCRNFmtDXT5A || m_pHeader->m_format == cCRNFmtETC1 || m_pHeader->m_format == cCRNFmtETC2 || m_pHeader->m_format == cCRNFmtETC1S ? 8 : 16;

    uint32 minimal_row_pitch = block_size * blocks_x;
    if (!row_pitch_in_bytes)
      row_pitch_in_bytes = minimal_row_pitch;
    else if ((row_pitch_in_bytes < minimal_row_pitch) || (row_pitch_in_bytes & 3))
      return false;
    if (dst_size_in_bytes < row_pitch_in_bytes * blocks_y)
      return false;

    if (!m_codec.start_decoding(static_cast<const unitycrnd::uint8*>(pSrc), src_size_in_bytes))
      return false;

    bool status = false;
    switch (m_pHeader->m_format) {
      case cCRNFmtDXT1:
      case cCRNFmtETC1S:
        status = unpack_dxt1((uint8**)pDst, row_pitch_in_bytes, blocks_x, blocks_y);
        break;
      case cCRNFmtDXT5:
      case cCRNFmtDXT5_CCxY:
      case cCRNFmtDXT5_xGBR:
      case cCRNFmtDXT5_AGBR:
      case cCRNFmtDXT5_xGxR:
      case cCRNFmtETC2AS:
        status = unpack_dxt5((uint8**)pDst, row_pitch_in_bytes, blocks_x, blocks_y);
        break;
      case cCRNFmtDXT5A:
        status = unpack_dxt5a((uint8**)pDst, row_pitch_in_bytes, blocks_x, blocks_y);
        break;
      case cCRNFmtDXN_XY:
      case cCRNFmtDXN_YX:
        status = unpack_dxn((uint8**)pDst, row_pitch_in_bytes, blocks_x, blocks_y);
        break;
      case cCRNFmtETC1:
        status = unpack_etc1((uint8**)pDst, row_pitch_in_bytes, blocks_x, blocks_y);
        break;
      case cCRNFmtETC2:
        status = unpack_etc1((uint8**)pDst, row_pitch_in_bytes, blocks_x, blocks_y);
        break;
      case cCRNFmtETC2A:
        status = unpack_etc2a((uint8**)pDst, row_pitch_in_bytes, blocks_x, blocks_y);
        break;
      default:
        return false;
    }
    if (!status)
      return false;

    m_codec.stop_decoding();
    return true;
  }

  inline const void* get_data() const { return m_pData; }
  inline uint32 get_data_size() const { return m_data_size; }

 private:
  enum { cMagicValue = 0x1EF9CABD };
  uint32 m_magic;

  const uint8* m_pData;
  uint32 m_data_size;
  const crn_header* m_pHeader;

  symbol_codec m_codec;

  static_huffman_data_model m_reference_encoding_dm;
  static_huffman_data_model m_endpoint_delta_dm[2];
  static_huffman_data_model m_selector_delta_dm[2];

  unitycrnd::vector<uint32> m_color_endpoints;
  unitycrnd::vector<uint32> m_color_selectors;

  unitycrnd::vector<uint16> m_alpha_endpoints;
  unitycrnd::vector<uint16> m_alpha_selectors;
  
  struct block_buffer_element {
    uint16 endpoint_reference;
    uint16 color_endpoint_index;
    uint16 alpha0_endpoint_index;
    uint16 alpha1_endpoint_index;
  };
  unitycrnd::vector<block_buffer_element> m_block_buffer;

  bool init_tables() {
    if (!m_codec.start_decoding(m_pData + m_pHeader->m_tables_ofs, m_pHeader->m_tables_size))
      return false;

    if (!m_codec.decode_receive_static_data_model(m_reference_encoding_dm))
      return false;

    if ((!m_pHeader->m_color_endpoints.m_num) && (!m_pHeader->m_alpha_endpoints.m_num))
      return false;

    if (m_pHeader->m_color_endpoints.m_num) {
      if (!m_codec.decode_receive_static_data_model(m_endpoint_delta_dm[0]))
        return false;
      if (!m_codec.decode_receive_static_data_model(m_selector_delta_dm[0]))
        return false;
    }

    if (m_pHeader->m_alpha_endpoints.m_num) {
      if (!m_codec.decode_receive_static_data_model(m_endpoint_delta_dm[1]))
        return false;
      if (!m_codec.decode_receive_static_data_model(m_selector_delta_dm[1]))
        return false;
    }

    m_codec.stop_decoding();

    return true;
  }

  bool decode_palettes() {
    if (m_pHeader->m_color_endpoints.m_num) {
      if (!decode_color_endpoints())
        return false;
      if (!decode_color_selectors())
        return false;
    }

    if (m_pHeader->m_alpha_endpoints.m_num) {
      if (!decode_alpha_endpoints())
        return false;
      if (!(m_pHeader->m_format == cCRNFmtETC2AS ? decode_alpha_selectors_etcs() : m_pHeader->m_format == cCRNFmtETC2A ? decode_alpha_selectors_etc() : decode_alpha_selectors()))
        return false;
    }

    return true;
  }

  bool decode_color_endpoints() {
    const uint32 num_color_endpoints = m_pHeader->m_color_endpoints.m_num;
    const bool has_etc_color_blocks = m_pHeader->m_format == cCRNFmtETC1 || m_pHeader->m_format == cCRNFmtETC2 || m_pHeader->m_format == cCRNFmtETC2A || m_pHeader->m_format == cCRNFmtETC1S || m_pHeader->m_format == cCRNFmtETC2AS;
    const bool has_subblocks = m_pHeader->m_format == cCRNFmtETC1 || m_pHeader->m_format == cCRNFmtETC2 || m_pHeader->m_format == cCRNFmtETC2A;

    if (!m_color_endpoints.resize(num_color_endpoints))
      return false;

    if (!m_codec.start_decoding(m_pData + m_pHeader->m_color_endpoints.m_ofs, m_pHeader->m_color_endpoints.m_size))
      return false;

    static_huffman_data_model dm[2];
    for (uint32 i = 0; i < (has_etc_color_blocks ? 1 : 2); i++)
      if (!m_codec.decode_receive_static_data_model(dm[i]))
        return false;

    uint32 a = 0, b = 0, c = 0;
    uint32 d = 0, e = 0, f = 0;

    uint32* CRND_RESTRICT pDst = &m_color_endpoints[0];

    for (uint32 i = 0; i < num_color_endpoints; i++) {
      if (has_etc_color_blocks) {
        for (b = 0; b < 32; b += 8)
          a += m_codec.decode(dm[0]) << b;
        a &= 0x1F1F1F1F;
        *pDst++ = has_subblocks ? a : (a & 0x07000000) << 5 | (a & 0x07000000) << 2 | 0x02000000 | (a & 0x001F1F1F) << 3;
      } else {
        a = (a + m_codec.decode(dm[0])) & 31;
        b = (b + m_codec.decode(dm[1])) & 63;
        c = (c + m_codec.decode(dm[0])) & 31;
        d = (d + m_codec.decode(dm[0])) & 31;
        e = (e + m_codec.decode(dm[1])) & 63;
        f = (f + m_codec.decode(dm[0])) & 31;
        *pDst++ = c | (b << 5U) | (a << 11U) | (f << 16U) | (e << 21U) | (d << 27U);
      }
    }

    m_codec.stop_decoding();

    return true;
  }

  bool decode_color_selectors() {
    const bool has_etc_color_blocks = m_pHeader->m_format == cCRNFmtETC1 || m_pHeader->m_format == cCRNFmtETC2 || m_pHeader->m_format == cCRNFmtETC2A || m_pHeader->m_format == cCRNFmtETC1S || m_pHeader->m_format == cCRNFmtETC2AS;
    const bool has_subblocks = m_pHeader->m_format == cCRNFmtETC1 || m_pHeader->m_format == cCRNFmtETC2 || m_pHeader->m_format == cCRNFmtETC2A;
    m_codec.start_decoding(m_pData + m_pHeader->m_color_selectors.m_ofs, m_pHeader->m_color_selectors.m_size);
    static_huffman_data_model dm;
    m_codec.decode_receive_static_data_model(dm);
    m_color_selectors.resize(m_pHeader->m_color_selectors.m_num << (has_subblocks ? 1 : 0));
    for (uint32 s = 0, i = 0; i < m_pHeader->m_color_selectors.m_num; i++) {
      for (uint32 j = 0; j < 32; j += 4)
        s ^= m_codec.decode(dm) << j;
      if (has_etc_color_blocks) {
        for (uint32 selector = (~s & 0xAAAAAAAA) | (~(s ^ s >> 1) & 0x55555555), t = 8, h = 0; h < 4; h++, t -= 15) {
          for (uint32 w = 0; w < 4; w++, t += 4) {
            if (has_subblocks) {
              uint32 s0 = selector >> (w << 3 | h << 1);
              m_color_selectors[i << 1] |= ((s0 >> 1 & 1) | (s0 & 1) << 16) << (t & 15);
            }
            uint32 s1 = selector >> (h << 3 | w << 1);
            m_color_selectors[has_subblocks ? i << 1 | 1 : i] |= ((s1 >> 1 & 1) | (s1 & 1) << 16) << (t & 15);
          }
        }
      } else {
        m_color_selectors[i] = ((s ^ s << 1) & 0xAAAAAAAA) | (s >> 1 & 0x55555555);
      }
    }
    m_codec.stop_decoding();
    return true;
  }

  bool decode_alpha_endpoints() {
    const uint32 num_alpha_endpoints = m_pHeader->m_alpha_endpoints.m_num;

    if (!m_codec.start_decoding(m_pData + m_pHeader->m_alpha_endpoints.m_ofs, m_pHeader->m_alpha_endpoints.m_size))
      return false;

    static_huffman_data_model dm;
    if (!m_codec.decode_receive_static_data_model(dm))
      return false;

    if (!m_alpha_endpoints.resize(num_alpha_endpoints))
      return false;

    uint16* CRND_RESTRICT pDst = &m_alpha_endpoints[0];
    uint32 a = 0, b = 0;

    for (uint32 i = 0; i < num_alpha_endpoints; i++) {
      a = (a + m_codec.decode(dm)) & 255;
      b = (b + m_codec.decode(dm)) & 255;
      *pDst++ = (uint16)(a | (b << 8));
    }

    m_codec.stop_decoding();

    return true;
  }

  bool decode_alpha_selectors() {
    m_codec.start_decoding(m_pData + m_pHeader->m_alpha_selectors.m_ofs, m_pHeader->m_alpha_selectors.m_size);
    static_huffman_data_model dm;
    m_codec.decode_receive_static_data_model(dm);
    m_alpha_selectors.resize(m_pHeader->m_alpha_selectors.m_num * 3);
    uint8 dxt5_from_linear[64];
    for (uint32 i = 0; i < 64; i++)
      dxt5_from_linear[i] = g_dxt5_from_linear[i & 7] | g_dxt5_from_linear[i >> 3] << 3;
    for (uint32 s0_linear = 0, s1_linear = 0, i = 0; i < m_alpha_selectors.size();) {
      uint32 s0 = 0, s1 = 0;
      for (uint32 j = 0; j < 24; s0 |= dxt5_from_linear[s0_linear >> j & 0x3F] << j, j += 6)
        s0_linear ^= m_codec.decode(dm) << j;
      for (uint32 j = 0; j < 24; s1 |= dxt5_from_linear[s1_linear >> j & 0x3F] << j, j += 6)
        s1_linear ^= m_codec.decode(dm) << j;
      m_alpha_selectors[i++] = s0;
      m_alpha_selectors[i++] = s0 >> 16 | s1 << 8;
      m_alpha_selectors[i++] = s1 >> 8;
    }
    m_codec.stop_decoding();
    return true;
  }

  bool decode_alpha_selectors_etc() {
    m_codec.start_decoding(m_pData + m_pHeader->m_alpha_selectors.m_ofs, m_pHeader->m_alpha_selectors.m_size);
    static_huffman_data_model dm;
    m_codec.decode_receive_static_data_model(dm);
    m_alpha_selectors.resize(m_pHeader->m_alpha_selectors.m_num * 6);
    uint8 s_linear[8] = {};
    uint8* data = (uint8*)m_alpha_selectors.begin();
    for (uint i = 0; i < m_alpha_selectors.size(); i += 6, data += 12) {
      for (uint s_group = 0, p = 0; p < 16; p++) {
        s_group = p & 1 ? s_group >> 3 : s_linear[p >> 1] ^= m_codec.decode(dm);
        uint8 s = s_group & 7;
        if (s <= 3)
          s = 3 - s;
        uint8 d = 3 * (p + 1);
        uint8 byte_offset = d >> 3;
        uint8 bit_offset = d & 7;
        data[byte_offset] |= s << (8 - bit_offset);
        if (bit_offset < 3)
          data[byte_offset - 1] |= s >> bit_offset;
        d += 9 * ((p & 3) - (p >> 2));
        byte_offset = d >> 3;
        bit_offset = d & 7;
        data[byte_offset + 6] |= s << (8 - bit_offset);
        if (bit_offset < 3)
          data[byte_offset + 5] |= s >> bit_offset;
      }
    }
    m_codec.stop_decoding();
    return true;
  }

  bool decode_alpha_selectors_etcs() {
    m_codec.start_decoding(m_pData + m_pHeader->m_alpha_selectors.m_ofs, m_pHeader->m_alpha_selectors.m_size);
    static_huffman_data_model dm;
    m_codec.decode_receive_static_data_model(dm);
    m_alpha_selectors.resize(m_pHeader->m_alpha_selectors.m_num * 3);
    uint8 s_linear[8] = {};
    uint8* data = (uint8*)m_alpha_selectors.begin();
    for (uint i = 0; i < (m_alpha_selectors.size() << 1); i += 6) {
      for (uint s_group = 0, p = 0; p < 16; p++) {
        s_group = p & 1 ? s_group >> 3 : s_linear[p >> 1] ^= m_codec.decode(dm);
        uint8 s = s_group & 7;
        if (s <= 3)
          s = 3 - s;
        uint8 d = 3 * (p + 1) + 9 * ((p & 3) - (p >> 2));
        uint8 byte_offset = d >> 3;
        uint8 bit_offset = d & 7;
        data[i + byte_offset] |= s << (8 - bit_offset);
        if (bit_offset < 3)
          data[i + byte_offset - 1] |= s >> bit_offset;
      }
    }
    m_codec.stop_decoding();
    return true;
  }

  static inline uint32 tiled_offset_2d_outer(uint32 y, uint32 AlignedWidth, uint32 LogBpp) {
    uint32 Macro = ((y >> 5) * (AlignedWidth >> 5)) << (LogBpp + 7);
    uint32 Micro = ((y & 6) << 2) << LogBpp;

    return Macro +
           ((Micro & ~15) << 1) +
           (Micro & 15) +
           ((y & 8) << (3 + LogBpp)) + ((y & 1) << 4);
  }

  static inline uint32 tiled_offset_2d_inner(uint32 x, uint32 y, uint32 LogBpp, uint32 BaseOffset) {
    uint32 Macro = (x >> 5) << (LogBpp + 7);
    uint32 Micro = (x & 7) << LogBpp;
    uint32 Offset = BaseOffset + Macro + ((Micro & ~15) << 1) + (Micro & 15);

    return ((Offset & ~511) << 3) + ((Offset & 448) << 2) + (Offset & 63) +
           ((y & 16) << 7) +
           (((((y & 8) >> 2) + (x >> 3)) & 3) << 6);
  }

  static inline void limit(uint& x, uint n) {
    int v = x - n;
    int msk = (v >> 31);
    x = (x & msk) | (v & ~msk);
  }

  bool unpack_dxt1(uint8** pDst, uint32 output_pitch_in_bytes, uint32 output_width, uint32 output_height) {
    const uint32 num_color_endpoints = m_color_endpoints.size();
    const uint32 width = output_width + 1 & ~1;
    const uint32 height = output_height + 1 & ~1;
    const int32 delta_pitch_in_dwords = (output_pitch_in_bytes >> 2) - (width << 1);

    if (m_block_buffer.size() < width)
      m_block_buffer.resize(width);

    uint32 color_endpoint_index = 0;
    uint8 reference_group = 0;

    for (uint32 f = 0; f < m_pHeader->m_faces; f++) {
      uint32* pData = (uint32*)pDst[f];
      for (uint32 y = 0; y < height; y++, pData += delta_pitch_in_dwords) {
        bool visible = y < output_height;
        for (uint32 x = 0; x < width; x++, pData += 2) {
          visible = visible && x < output_width;
          if (!(y & 1) && !(x & 1))
            reference_group = m_codec.decode(m_reference_encoding_dm);
          block_buffer_element &buffer = m_block_buffer[x];
          uint8 endpoint_reference;
          if (y & 1) {
            endpoint_reference = buffer.endpoint_reference;
          } else {
            endpoint_reference = reference_group & 3;
            reference_group >>= 2;
            buffer.endpoint_reference = reference_group & 3;
            reference_group >>= 2;
          }
          if (!endpoint_reference) {
            color_endpoint_index += m_codec.decode(m_endpoint_delta_dm[0]);
            if (color_endpoint_index >= num_color_endpoints)
              color_endpoint_index -= num_color_endpoints;
            buffer.color_endpoint_index = color_endpoint_index;
          } else if (endpoint_reference == 1) {
            buffer.color_endpoint_index = color_endpoint_index;
          } else {
            color_endpoint_index = buffer.color_endpoint_index;
          }
          uint32 color_selector_index = m_codec.decode(m_selector_delta_dm[0]);
          if (visible) {
            pData[0] = m_color_endpoints[color_endpoint_index];
            pData[1] = m_color_selectors[color_selector_index];
          }
        }
      }
    }
    return true;
  }

  bool unpack_dxt5(uint8** pDst, uint32 row_pitch_in_bytes, uint32 output_width, uint32 output_height) {
    const uint32 num_color_endpoints = m_color_endpoints.size();
    const uint32 num_alpha_endpoints = m_alpha_endpoints.size();
    const uint32 width = output_width + 1 & ~1;
    const uint32 height = output_height + 1 & ~1;
    const int32 delta_pitch_in_dwords = (row_pitch_in_bytes >> 2) - (width << 2);

    if (m_block_buffer.size() < width)
      m_block_buffer.resize(width);

    uint32 color_endpoint_index = 0;
    uint32 alpha0_endpoint_index = 0;
    uint8 reference_group = 0;

    for (uint32 f = 0; f < m_pHeader->m_faces; f++) {
      uint32* pData = (uint32*)pDst[f];
      for (uint32 y = 0; y < height; y++, pData += delta_pitch_in_dwords) {
        bool visible = y < output_height;
        for (uint32 x = 0; x < width; x++, pData += 4) {
          visible = visible && x < output_width;
          if (!(y & 1) && !(x & 1))
            reference_group = m_codec.decode(m_reference_encoding_dm);
          block_buffer_element &buffer = m_block_buffer[x];
          uint8 endpoint_reference;
          if (y & 1) {
            endpoint_reference = buffer.endpoint_reference;
          } else {
            endpoint_reference = reference_group & 3;
            reference_group >>= 2;
            buffer.endpoint_reference = reference_group & 3;
            reference_group >>= 2;
          }
          if (!endpoint_reference) {
            color_endpoint_index += m_codec.decode(m_endpoint_delta_dm[0]);
            if (color_endpoint_index >= num_color_endpoints)
              color_endpoint_index -= num_color_endpoints;
            buffer.color_endpoint_index = color_endpoint_index;
            alpha0_endpoint_index += m_codec.decode(m_endpoint_delta_dm[1]);
            if (alpha0_endpoint_index >= num_alpha_endpoints)
              alpha0_endpoint_index -= num_alpha_endpoints;
            buffer.alpha0_endpoint_index = alpha0_endpoint_index;
          } else if (endpoint_reference == 1) {
            buffer.color_endpoint_index = color_endpoint_index;
            buffer.alpha0_endpoint_index = alpha0_endpoint_index;
          } else {
            color_endpoint_index = buffer.color_endpoint_index;
            alpha0_endpoint_index = buffer.alpha0_endpoint_index;
          }
          uint32 color_selector_index = m_codec.decode(m_selector_delta_dm[0]);
          uint32 alpha0_selector_index = m_codec.decode(m_selector_delta_dm[1]);
          if (visible) {
            const uint16* pAlpha0_selectors = &m_alpha_selectors[alpha0_selector_index * 3];
            pData[0] = m_alpha_endpoints[alpha0_endpoint_index] | (pAlpha0_selectors[0] << 16);
            pData[1] = pAlpha0_selectors[1] | (pAlpha0_selectors[2] << 16);
            pData[2] = m_color_endpoints[color_endpoint_index];
            pData[3] = m_color_selectors[color_selector_index];
          }
        }
      }
    }
    return true;
  }

  bool unpack_dxn(uint8** pDst, uint32 row_pitch_in_bytes, uint32 output_width, uint32 output_height) {
    const uint32 num_alpha_endpoints = m_alpha_endpoints.size();
    const uint32 width = output_width + 1 & ~1;
    const uint32 height = output_height + 1 & ~1;
    const int32 delta_pitch_in_dwords = (row_pitch_in_bytes >> 2) - (width << 2);

    if (m_block_buffer.size() < width)
      m_block_buffer.resize(width);

    uint32 alpha0_endpoint_index = 0;
    uint32 alpha1_endpoint_index = 0;
    uint8 reference_group = 0;

    for (uint32 f = 0; f < m_pHeader->m_faces; f++) {
      uint32* pData = (uint32*)pDst[f];
      for (uint32 y = 0; y < height; y++, pData += delta_pitch_in_dwords) {
        bool visible = y < output_height;
        for (uint32 x = 0; x < width; x++, pData += 4) {
          visible = visible && x < output_width;
          if (!(y & 1) && !(x & 1))
            reference_group = m_codec.decode(m_reference_encoding_dm);
          block_buffer_element &buffer = m_block_buffer[x];
          uint8 endpoint_reference;
          if (y & 1) {
            endpoint_reference = buffer.endpoint_reference;
          } else {
            endpoint_reference = reference_group & 3;
            reference_group >>= 2;
            buffer.endpoint_reference = reference_group & 3;
            reference_group >>= 2;
          }
          if (!endpoint_reference) {
            alpha0_endpoint_index += m_codec.decode(m_endpoint_delta_dm[1]);
            if (alpha0_endpoint_index >= num_alpha_endpoints)
              alpha0_endpoint_index -= num_alpha_endpoints;
            buffer.alpha0_endpoint_index = alpha0_endpoint_index;
            alpha1_endpoint_index += m_codec.decode(m_endpoint_delta_dm[1]);
            if (alpha1_endpoint_index >= num_alpha_endpoints)
              alpha1_endpoint_index -= num_alpha_endpoints;
            buffer.alpha1_endpoint_index = alpha1_endpoint_index;
          } else if (endpoint_reference == 1) {
            buffer.alpha0_endpoint_index = alpha0_endpoint_index;
            buffer.alpha1_endpoint_index = alpha1_endpoint_index;
          } else {
            alpha0_endpoint_index = buffer.alpha0_endpoint_index;
            alpha1_endpoint_index = buffer.alpha1_endpoint_index;
          }
          uint32 alpha0_selector_index = m_codec.decode(m_selector_delta_dm[1]);
          uint32 alpha1_selector_index = m_codec.decode(m_selector_delta_dm[1]);
          if (visible) {
            const uint16* pAlpha0_selectors = &m_alpha_selectors[alpha0_selector_index * 3];
            const uint16* pAlpha1_selectors = &m_alpha_selectors[alpha1_selector_index * 3];
            pData[0] = m_alpha_endpoints[alpha0_endpoint_index] | (pAlpha0_selectors[0] << 16);
            pData[1] = pAlpha0_selectors[1] | (pAlpha0_selectors[2] << 16);
            pData[2] = m_alpha_endpoints[alpha1_endpoint_index] | (pAlpha1_selectors[0] << 16);
            pData[3] = pAlpha1_selectors[1] | (pAlpha1_selectors[2] << 16);
          }
        }
      }
    }
    return true;
  }

  bool unpack_dxt5a(uint8** pDst, uint32 row_pitch_in_bytes, uint32 output_width, uint32 output_height) {
    const uint32 num_alpha_endpoints = m_alpha_endpoints.size();
    const uint32 width = output_width + 1 & ~1;
    const uint32 height = output_height + 1 & ~1;
    const int32 delta_pitch_in_dwords = (row_pitch_in_bytes >> 2) - (width << 1);

    if (m_block_buffer.size() < width)
      m_block_buffer.resize(width);

    uint32 alpha0_endpoint_index = 0;
    uint8 reference_group = 0;

    for (uint32 f = 0; f < m_pHeader->m_faces; f++) {
      uint32* pData = (uint32*)pDst[f];
      for (uint32 y = 0; y < height; y++, pData += delta_pitch_in_dwords) {
        bool visible = y < output_height;
        for (uint32 x = 0; x < width; x++, pData += 2) {
          visible = visible && x < output_width;
          if (!(y & 1) && !(x & 1))
            reference_group = m_codec.decode(m_reference_encoding_dm);
          block_buffer_element &buffer = m_block_buffer[x];
          uint8 endpoint_reference;
          if (y & 1) {
            endpoint_reference = buffer.endpoint_reference;
          } else {
            endpoint_reference = reference_group & 3;
            reference_group >>= 2;
            buffer.endpoint_reference = reference_group & 3;
            reference_group >>= 2;
          }
          if (!endpoint_reference) {
            alpha0_endpoint_index += m_codec.decode(m_endpoint_delta_dm[1]);
            if (alpha0_endpoint_index >= num_alpha_endpoints)
              alpha0_endpoint_index -= num_alpha_endpoints;
            buffer.alpha0_endpoint_index = alpha0_endpoint_index;
          } else if (endpoint_reference == 1) {
            buffer.alpha0_endpoint_index = alpha0_endpoint_index;
          } else {
            alpha0_endpoint_index = buffer.alpha0_endpoint_index;
          }
          uint32 alpha0_selector_index = m_codec.decode(m_selector_delta_dm[1]);
          if (visible) {
            const uint16* pAlpha0_selectors = &m_alpha_selectors[alpha0_selector_index * 3];
            pData[0] = m_alpha_endpoints[alpha0_endpoint_index] | (pAlpha0_selectors[0] << 16);
            pData[1] = pAlpha0_selectors[1] | (pAlpha0_selectors[2] << 16);
          }
        }
      }
    }
    return true;
  }

  bool unpack_etc1(uint8** pDst, uint32 output_pitch_in_bytes, uint32 output_width, uint32 output_height) {
    const uint32 num_color_endpoints = m_color_endpoints.size();
    const uint32 width = output_width + 1 & ~1;
    const uint32 height = output_height + 1 & ~1;
    const int32 delta_pitch_in_dwords = (output_pitch_in_bytes >> 2) - (width << 1);

    if (m_block_buffer.size() < width << 1)
      m_block_buffer.resize(width << 1);

    uint32 color_endpoint_index = 0, diagonal_color_endpoint_index = 0;
    uint8 reference_group = 0;

    for (uint32 f = 0; f < m_pHeader->m_faces; f++) {
      uint32* pData = (uint32*)pDst[f];
      for (uint32 y = 0; y < height; y++, pData += delta_pitch_in_dwords) {
        bool visible = y < output_height;
        for (uint32 x = 0; x < width; x++, pData += 2) {
          visible = visible && x < output_width;
          block_buffer_element &buffer = m_block_buffer[x << 1];
          uint8 endpoint_reference, block_endpoint[4], e0[4], e1[4];
          if (y & 1) {
            endpoint_reference = buffer.endpoint_reference;
          } else {
            reference_group = m_codec.decode(m_reference_encoding_dm);
            endpoint_reference = (reference_group & 3) | (reference_group >> 2 & 12);
            buffer.endpoint_reference = (reference_group >> 2 & 3) | (reference_group >> 4 & 12);
          }
          if (!(endpoint_reference & 3)) {
            color_endpoint_index += m_codec.decode(m_endpoint_delta_dm[0]);
            if (color_endpoint_index >= num_color_endpoints)
              color_endpoint_index -= num_color_endpoints;
            buffer.color_endpoint_index = color_endpoint_index;
          } else if ((endpoint_reference & 3) == 1) {
            buffer.color_endpoint_index = color_endpoint_index;
          } else if ((endpoint_reference & 3) == 3) {
            buffer.color_endpoint_index = color_endpoint_index = diagonal_color_endpoint_index;
          } else {
            color_endpoint_index = buffer.color_endpoint_index;
          }
          endpoint_reference >>= 2;
          *(uint32*)&e0 = m_color_endpoints[color_endpoint_index];
          uint32 selector_index = m_codec.decode(m_selector_delta_dm[0]);
          if (endpoint_reference) {
            color_endpoint_index += m_codec.decode(m_endpoint_delta_dm[0]);
            if (color_endpoint_index >= num_color_endpoints)
              color_endpoint_index -= num_color_endpoints;
          }
          diagonal_color_endpoint_index = m_block_buffer[x << 1 | 1].color_endpoint_index;
          m_block_buffer[x << 1 | 1].color_endpoint_index = color_endpoint_index;
          *(uint32*)&e1 = m_color_endpoints[color_endpoint_index];
          if (visible) {
            uint32 flip = endpoint_reference >> 1 ^ 1, diff = 1;
            for (uint c = 0; diff && c < 3; c++)
              diff = e0[c] + 3 >= e1[c] && e1[c] + 4 >= e0[c] ? diff : 0;
            for (uint c = 0; c < 3; c++)
              block_endpoint[c] = diff ? e0[c] << 3 | ((e1[c] - e0[c]) & 7) : (e0[c] << 3 & 0xF0) | e1[c] >> 1;
            block_endpoint[3] = e0[3] << 5 | e1[3] << 2 | diff << 1 | flip;
            pData[0] = *(uint32*)&block_endpoint;
            pData[1] = m_color_selectors[selector_index << 1 | flip];
          }
        }
      }
    }
    return true;
  }

  bool unpack_etc2a(uint8** pDst, uint32 output_pitch_in_bytes, uint32 output_width, uint32 output_height) {
    const uint32 num_color_endpoints = m_color_endpoints.size();
    const uint32 num_alpha_endpoints = m_alpha_endpoints.size();
    const uint32 width = output_width + 1 & ~1;
    const uint32 height = output_height + 1 & ~1;
    const int32 delta_pitch_in_dwords = (output_pitch_in_bytes >> 2) - (width << 2);

    if (m_block_buffer.size() < width << 1)
      m_block_buffer.resize(width << 1);

    uint32 color_endpoint_index = 0, diagonal_color_endpoint_index = 0, alpha0_endpoint_index = 0, diagonal_alpha0_endpoint_index = 0;
    uint8 reference_group = 0;

    for (uint32 f = 0; f < m_pHeader->m_faces; f++) {
      uint32* pData = (uint32*)pDst[f];
      for (uint32 y = 0; y < height; y++, pData += delta_pitch_in_dwords) {
        bool visible = y < output_height;
        for (uint32 x = 0; x < width; x++, pData += 4) {
          visible = visible && x < output_width;
          block_buffer_element &buffer = m_block_buffer[x << 1];
          uint8 endpoint_reference, block_endpoint[4], e0[4], e1[4];
          if (y & 1) {
            endpoint_reference = buffer.endpoint_reference;
          } else {
            reference_group = m_codec.decode(m_reference_encoding_dm);
            endpoint_reference = (reference_group & 3) | (reference_group >> 2 & 12);
            buffer.endpoint_reference = (reference_group >> 2 & 3) | (reference_group >> 4 & 12);
          }
          if (!(endpoint_reference & 3)) {
            color_endpoint_index += m_codec.decode(m_endpoint_delta_dm[0]);
            if (color_endpoint_index >= num_color_endpoints)
              color_endpoint_index -= num_color_endpoints;
            alpha0_endpoint_index += m_codec.decode(m_endpoint_delta_dm[1]);
            if (alpha0_endpoint_index >= num_alpha_endpoints)
              alpha0_endpoint_index -= num_alpha_endpoints;
            buffer.color_endpoint_index = color_endpoint_index;
            buffer.alpha0_endpoint_index = alpha0_endpoint_index;
          } else if ((endpoint_reference & 3) == 1) {
            buffer.color_endpoint_index = color_endpoint_index;
            buffer.alpha0_endpoint_index = alpha0_endpoint_index;
          } else if ((endpoint_reference & 3) == 3) {
            buffer.color_endpoint_index = color_endpoint_index = diagonal_color_endpoint_index;
            buffer.alpha0_endpoint_index = alpha0_endpoint_index = diagonal_alpha0_endpoint_index;
          } else {
            color_endpoint_index = buffer.color_endpoint_index;
            alpha0_endpoint_index = buffer.alpha0_endpoint_index;
          }
          endpoint_reference >>= 2;
          *(uint32*)&e0 = m_color_endpoints[color_endpoint_index];
          uint32 color_selector_index = m_codec.decode(m_selector_delta_dm[0]);
          uint32 alpha0_selector_index = m_codec.decode(m_selector_delta_dm[1]);
          if (endpoint_reference) {
            color_endpoint_index += m_codec.decode(m_endpoint_delta_dm[0]);
            if (color_endpoint_index >= num_color_endpoints)
              color_endpoint_index -= num_color_endpoints;
          }
          *(uint32*)&e1 = m_color_endpoints[color_endpoint_index];
          diagonal_color_endpoint_index = m_block_buffer[x << 1 | 1].color_endpoint_index;
          diagonal_alpha0_endpoint_index = m_block_buffer[x << 1 | 1].alpha0_endpoint_index;
          m_block_buffer[x << 1 | 1].color_endpoint_index = color_endpoint_index;
          m_block_buffer[x << 1 | 1].alpha0_endpoint_index = alpha0_endpoint_index;
          if (visible) {
            uint32 flip = endpoint_reference >> 1 ^ 1, diff = 1;
            for (uint c = 0; diff && c < 3; c++)
              diff = e0[c] + 3 >= e1[c] && e1[c] + 4 >= e0[c] ? diff : 0;
            for (uint c = 0; c < 3; c++)
              block_endpoint[c] = diff ? e0[c] << 3 | ((e1[c] - e0[c]) & 7) : (e0[c] << 3 & 0xF0) | e1[c] >> 1;
            block_endpoint[3] = e0[3] << 5 | e1[3] << 2 | diff << 1 | flip;
            const uint16* pAlpha0_selectors = &m_alpha_selectors[alpha0_selector_index * 6 + (flip ? 3 : 0)];
            pData[0] = m_alpha_endpoints[alpha0_endpoint_index] | pAlpha0_selectors[0] << 16;
            pData[1] = pAlpha0_selectors[1] | pAlpha0_selectors[2] << 16;
            pData[2] = *(uint32*)&block_endpoint;
            pData[3] = m_color_selectors[color_selector_index << 1 | flip];
          }
        }
      }
    }
    return true;
  }

};

crnd_unpack_context crnd_unpack_begin(const void* pData, uint32 data_size) {
  if ((!pData) || (data_size < cCRNHeaderMinSize))
    return NULL;

  crn_unpacker* p = crnd_new<crn_unpacker>();
  if (!p)
    return NULL;

  if (!p->init(pData, data_size)) {
    crnd_delete(p);
    return NULL;
  }

  return p;
}

bool crnd_get_data(crnd_unpack_context pContext, const void** ppData, uint32* pData_size) {
  if (!pContext)
    return false;

  crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

  if (!pUnpacker->is_valid())
    return false;

  if (ppData)
    *ppData = pUnpacker->get_data();

  if (pData_size)
    *pData_size = pUnpacker->get_data_size();

  return true;
}

bool crnd_unpack_level(
    crnd_unpack_context pContext,
    void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
    uint32 level_index) {
  if ((!pContext) || (!pDst) || (dst_size_in_bytes < 8U) || (level_index >= cCRNMaxLevels))
    return false;

  crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

  if (!pUnpacker->is_valid())
    return false;

  return pUnpacker->unpack_level(pDst, dst_size_in_bytes, row_pitch_in_bytes, level_index);
}

bool crnd_unpack_level_segmented(
    crnd_unpack_context pContext,
    const void* pSrc, uint32 src_size_in_bytes,
    void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
    uint32 level_index) {
  if ((!pContext) || (!pSrc) || (!pDst) || (dst_size_in_bytes < 8U) || (level_index >= cCRNMaxLevels))
    return false;

  crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

  if (!pUnpacker->is_valid())
    return false;

  return pUnpacker->unpack_level(pSrc, src_size_in_bytes, pDst, dst_size_in_bytes, row_pitch_in_bytes, level_index);
}

bool crnd_unpack_end(crnd_unpack_context pContext) {
  if (!pContext)
    return false;

  crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

  if (!pUnpacker->is_valid())
    return false;

  crnd_delete(pUnpacker);

  return true;
}

}  // namespace unitycrnd

#endif  // CRND_INCLUDE_CRND_H

//------------------------------------------------------------------------------
//
// crn_decomp.h uses the ZLIB license:
// http://opensource.org/licenses/Zlib
//
// Copyright (c) 2010-2016 Richard Geldreich, Jr. and Binomial LLC
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
//
//------------------------------------------------------------------------------

```

`Texture2DDecoderNative/unitycrunch/crn_defs.h`:

```h
#ifndef CRND_INCLUDE_CRN_DEFS_H
#define CRND_INCLUDE_CRN_DEFS_H

// Include crnlib.h (only to bring in some basic CRN-related types).
#include "crnlib.h"

#define CRND_LIB_VERSION 104
#define CRND_VERSION_STRING "01.04"

#ifdef _DEBUG
#define CRND_BUILD_DEBUG
#else
#define CRND_BUILD_RELEASE
#endif

// CRN decompression API
namespace unitycrnd {
typedef unsigned char uint8;
typedef signed char int8;
typedef unsigned short uint16;
typedef signed short int16;
typedef unsigned int uint32;
typedef uint32 uint32;
typedef unsigned int uint;
typedef signed int int32;
#ifdef __GNUC__
typedef unsigned long long uint64;
typedef long long int64;
#else
typedef unsigned __int64 uint64;
typedef signed __int64 int64;
#endif

// The crnd library assumes all allocation blocks have at least CRND_MIN_ALLOC_ALIGNMENT alignment.
const uint32 CRND_MIN_ALLOC_ALIGNMENT = sizeof(uint32) * 2U;

// realloc callback:
// Used to allocate, resize, or free memory blocks.
// If p is NULL, the realloc function attempts to allocate a block of at least size bytes. Returns NULL on out of memory.
// *pActual_size must be set to the actual size of the allocated block, which must be greater than or equal to the requested size.
// If p is not NULL, and size is 0, the realloc function frees the specified block, and always returns NULL. *pActual_size should be set to 0.
// If p is not NULL, and size is non-zero, the realloc function attempts to resize the specified block:
//    If movable is false, the realloc function attempts to shrink or expand the block in-place. NULL is returned if the block cannot be resized in place, or if the
//    underlying heap implementation doesn't support in-place resizing. Otherwise, the pointer to the original block is returned.
//    If movable is true, it is permissible to move the block's contents if it cannot be resized in place. NULL is returned if the block cannot be resized in place, and there
//    is not enough memory to relocate the block.
//    In all cases, *pActual_size must be set to the actual size of the allocated block, whether it was successfully resized or not.
typedef void* (*crnd_realloc_func)(void* p, size_t size, size_t* pActual_size, bool movable, void* pUser_data);

// msize callback: Returns the size of the memory block in bytes, or 0 if the pointer or block is invalid.
typedef size_t (*crnd_msize_func)(void* p, void* pUser_data);

// crnd_set_memory_callbacks() - Use to override the crnd library's memory allocation functions.
// If any input parameters are NULL, the memory callback functions are reset to the default functions.
// The default functions call malloc(), free(),  _msize(), _expand(), etc.
void crnd_set_memory_callbacks(crnd_realloc_func pRealloc, crnd_msize_func pMSize, void* pUser_data);

struct crn_file_info {
  inline crn_file_info()
      : m_struct_size(sizeof(crn_file_info)) {}

  uint32 m_struct_size;
  uint32 m_actual_data_size;
  uint32 m_header_size;
  uint32 m_total_palette_size;
  uint32 m_tables_size;
  uint32 m_levels;
  uint32 m_level_compressed_size[cCRNMaxLevels];
  uint32 m_color_endpoint_palette_entries;
  uint32 m_color_selector_palette_entries;
  uint32 m_alpha_endpoint_palette_entries;
  uint32 m_alpha_selector_palette_entries;
};

struct crn_texture_info {
  inline crn_texture_info()
      : m_struct_size(sizeof(crn_texture_info)) {}

  uint32 m_struct_size;
  uint32 m_width;
  uint32 m_height;
  uint32 m_levels;
  uint32 m_faces;
  uint32 m_bytes_per_block;
  uint32 m_userdata0;
  uint32 m_userdata1;
  crn_format m_format;
};

struct crn_level_info {
  inline crn_level_info()
      : m_struct_size(sizeof(crn_level_info)) {}

  uint32 m_struct_size;
  uint32 m_width;
  uint32 m_height;
  uint32 m_faces;
  uint32 m_blocks_x;
  uint32 m_blocks_y;
  uint32 m_bytes_per_block;
  crn_format m_format;
};

// Returns the FOURCC format code corresponding to the specified CRN format.
uint32 crnd_crn_format_to_fourcc(crn_format fmt);

// Returns the fundamental GPU format given a potentially swizzled DXT5 crn_format.
crn_format crnd_get_fundamental_dxt_format(crn_format fmt);

// Returns the size of the crn_format in bits/texel (either 4 or 8).
uint32 crnd_get_crn_format_bits_per_texel(crn_format fmt);

// Returns the number of bytes per DXTn block (8 or 16).
uint32 crnd_get_bytes_per_dxt_block(crn_format fmt);

// Validates the entire file by checking the header and data CRC's.
// This is not something you want to be doing much!
// The crn_file_info.m_struct_size field must be set before calling this function.
bool crnd_validate_file(const void* pData, uint32 data_size, crn_file_info* pFile_info);

// Retrieves texture information from the CRN file.
// The crn_texture_info.m_struct_size field must be set before calling this function.
bool crnd_get_texture_info(const void* pData, uint32 data_size, crn_texture_info* pTexture_info);

// Retrieves mipmap level specific information from the CRN file.
// The crn_level_info.m_struct_size field must be set before calling this function.
bool crnd_get_level_info(const void* pData, uint32 data_size, uint32 level_index, crn_level_info* pLevel_info);

// Transcode/unpack context handle.
typedef void* crnd_unpack_context;

// crnd_unpack_begin() - Decompresses the texture's decoder tables and endpoint/selector palettes.
// Once you call this function, you may call crnd_unpack_level() to unpack one or more mip levels.
// Don't call this once per mip level (unless you absolutely must)!
// This function allocates enough memory to hold: Huffman decompression tables, and the endpoint/selector palettes (color and/or alpha).
// Worst case allocation is approx. 200k, assuming all palettes contain 8192 entries.
// pData must point to a buffer holding all of the compressed .CRN file data.
// This buffer must be stable until crnd_unpack_end() is called.
// Returns NULL if out of memory, or if any of the input parameters are invalid.
crnd_unpack_context crnd_unpack_begin(const void* pData, uint32 data_size);

// Returns a pointer to the compressed .CRN data associated with a crnd_unpack_context.
// Returns false if any of the input parameters are invalid.
bool crnd_get_data(crnd_unpack_context pContext, const void** ppData, uint32* pData_size);

// crnd_unpack_level() - Transcodes the specified mipmap level to a destination buffer in cached or write combined memory.
// pContext - Context created by a call to crnd_unpack_begin().
// ppDst - A pointer to an array of 1 or 6 destination buffer pointers. Cubemaps require an array of 6 pointers, 2D textures require an array of 1 pointer.
// dst_size_in_bytes - Optional size of each destination buffer. Only used for debugging - OK to set to UINT32_MAX.
// row_pitch_in_bytes - The pitch in bytes from one row of DXT blocks to the next. Must be a multiple of 4.
// level_index - mipmap level index, where 0 is the largest/first level.
// Returns false if any of the input parameters, or the compressed stream, are invalid.
// This function does not allocate any memory.
bool crnd_unpack_level(
    crnd_unpack_context pContext,
    void** ppDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
    uint32 level_index);

// crnd_unpack_level_segmented() - Unpacks the specified mipmap level from a "segmented" CRN file.
// See the crnd_create_segmented_file() API below.
// Segmented files allow the user to control where the compressed mipmap data is stored.
bool crnd_unpack_level_segmented(
    crnd_unpack_context pContext,
    const void* pSrc, uint32 src_size_in_bytes,
    void** ppDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
    uint32 level_index);

// crnd_unpack_end() - Frees the decompress tables and unpacked palettes associated with the specified unpack context.
// Returns false if the context is NULL, or if it points to an invalid context.
// This function frees all memory associated with the context.
bool crnd_unpack_end(crnd_unpack_context pContext);

// The following API's allow the user to create "segmented" CRN files. A segmented file contains multiple pieces:
// - Base data: Header + compression tables
// - Level data: Individual mipmap levels
// This allows mipmap levels from multiple CRN files to be tightly packed together into single files.

// Returns a pointer to the level's compressed data, and optionally returns the level's compressed data size if pSize is not NULL.
const void* crnd_get_level_data(const void* pData, uint32 data_size, uint32 level_index, uint32* pSize);

// Returns the compressed size of the texture's header and compression tables (but no levels).
uint32 crnd_get_segmented_file_size(const void* pData, uint32 data_size);

// Creates a "segmented" CRN texture from a normal CRN texture. The new texture will be created at pBase_data, and will be crnd_get_base_data_size() bytes long.
// base_data_size must be >= crnd_get_base_data_size().
// The base data will contain the CRN header and compression tables, but no mipmap data.
bool crnd_create_segmented_file(const void* pData, uint32 data_size, void* pBase_data, uint base_data_size);

}  // namespace unitycrnd

// Low-level CRN file header cracking.
namespace unitycrnd {
template <unsigned int N>
struct crn_packed_uint {
  inline crn_packed_uint() {}

  inline crn_packed_uint(unsigned int val) { *this = val; }

  inline crn_packed_uint(const crn_packed_uint& other) { *this = other; }

  inline crn_packed_uint& operator=(const crn_packed_uint& rhs) {
    if (this != &rhs)
      memcpy(m_buf, rhs.m_buf, sizeof(m_buf));
    return *this;
  }

  inline crn_packed_uint& operator=(unsigned int val) {
    //CRND_ASSERT((N == 4U) || (val < (1U << (N * 8U))));

    val <<= (8U * (4U - N));

    for (unsigned int i = 0; i < N; i++) {
      m_buf[i] = static_cast<unsigned char>(val >> 24U);
      val <<= 8U;
    }

    return *this;
  }

  inline operator unsigned int() const {
    switch (N) {
      case 1:
        return m_buf[0];
      case 2:
        return (m_buf[0] << 8U) | m_buf[1];
      case 3:
        return (m_buf[0] << 16U) | (m_buf[1] << 8U) | (m_buf[2]);
      default:
        return (m_buf[0] << 24U) | (m_buf[1] << 16U) | (m_buf[2] << 8U) | (m_buf[3]);
    }
  }

  unsigned char m_buf[N];
};

#pragma pack(push)
#pragma pack(1)
struct crn_palette {
  crn_packed_uint<3> m_ofs;
  crn_packed_uint<3> m_size;
  crn_packed_uint<2> m_num;
};

enum crn_header_flags {
  // If set, the compressed mipmap level data is not located after the file's base data - it will be separately managed by the user instead.
  cCRNHeaderFlagSegmented = 1
};

struct crn_header {
  enum { cCRNSigValue = ('H' << 8) | 'x' };

  crn_packed_uint<2> m_sig;
  crn_packed_uint<2> m_header_size;
  crn_packed_uint<2> m_header_crc16;

  crn_packed_uint<4> m_data_size;
  crn_packed_uint<2> m_data_crc16;

  crn_packed_uint<2> m_width;
  crn_packed_uint<2> m_height;

  crn_packed_uint<1> m_levels;
  crn_packed_uint<1> m_faces;

  crn_packed_uint<1> m_format;
  crn_packed_uint<2> m_flags;

  crn_packed_uint<4> m_reserved;
  crn_packed_uint<4> m_userdata0;
  crn_packed_uint<4> m_userdata1;

  crn_palette m_color_endpoints;
  crn_palette m_color_selectors;

  crn_palette m_alpha_endpoints;
  crn_palette m_alpha_selectors;

  crn_packed_uint<2> m_tables_size;
  crn_packed_uint<3> m_tables_ofs;

  // m_level_ofs[] is actually an array of offsets: m_level_ofs[m_levels]
  crn_packed_uint<4> m_level_ofs[1];
};

const unsigned int cCRNHeaderMinSize = 62U;

#pragma pack(pop)

}  // namespace unitycrnd

#endif  // CRND_INCLUDE_CRN_DEFS_H

```

`Texture2DDecoderNative/unitycrunch/crnlib.h`:

```h
// File: crnlib.h - Advanced DXTn texture compression library.
// Copyright (c) 2010-2016 Richard Geldreich, Jr. and Binomial LLC
// See copyright notice and license at the end of this file.
//
// This header file contains the public crnlib declarations for DXTn,
// clustered DXTn, and CRN compression/decompression.
//
// Note: This library does NOT need to be linked into your game executable if
// all you want to do is transcode .CRN files to raw DXTn bits at run-time.
// The crn_decomp.h header file library contains all the code necessary for
// decompression.
//
// Important: If compiling with gcc, be sure strict aliasing is disabled: -fno-strict-aliasing
#ifndef CRNLIB_H
#define CRNLIB_H

#ifdef _MSC_VER
#pragma warning(disable : 4127)  //  conditional expression is constant
#endif

#define CRNLIB_VERSION 104

#define CRNLIB_SUPPORT_ATI_COMPRESS 0
#define CRNLIB_SUPPORT_SQUISH 0

typedef unsigned char crn_uint8;
typedef unsigned short crn_uint16;
typedef unsigned int crn_uint32;
typedef signed char crn_int8;
typedef signed short crn_int16;
typedef signed int crn_int32;
typedef unsigned int crn_bool;

// crnlib can compress to these file types.
enum crn_file_type {
  // .CRN
  cCRNFileTypeCRN = 0,

  // .DDS using regular DXT or clustered DXT
  cCRNFileTypeDDS,

  cCRNFileTypeForceDWORD = 0xFFFFFFFF
};

// Supported compressed pixel formats.
// Basically all the standard DX9 formats, with some swizzled DXT5 formats
// (most of them supported by ATI's Compressonator), along with some ATI/X360 GPU specific formats.
enum crn_format {
  cCRNFmtInvalid = -1,

  cCRNFmtDXT1 = 0,

  cCRNFmtFirstValid = cCRNFmtDXT1,

  // cCRNFmtDXT3 is not currently supported when writing to CRN - only DDS.
  cCRNFmtDXT3,

  cCRNFmtDXT5,

  // Various DXT5 derivatives
  cCRNFmtDXT5_CCxY,  // Luma-chroma
  cCRNFmtDXT5_xGxR,  // Swizzled 2-component
  cCRNFmtDXT5_xGBR,  // Swizzled 3-component
  cCRNFmtDXT5_AGBR,  // Swizzled 4-component

  // ATI 3DC and X360 DXN
  cCRNFmtDXN_XY,
  cCRNFmtDXN_YX,

  // DXT5 alpha blocks only
  cCRNFmtDXT5A,

  cCRNFmtETC1,
  cCRNFmtETC2,
  cCRNFmtETC2A,
  cCRNFmtETC1S,
  cCRNFmtETC2AS,

  cCRNFmtTotal,

  cCRNFmtForceDWORD = 0xFFFFFFFF
};

// Various library/file format limits.
enum crn_limits {
  // Max. mipmap level resolution on any axis.
  cCRNMaxLevelResolution = 4096,

  cCRNMinPaletteSize = 8,
  cCRNMaxPaletteSize = 8192,

  cCRNMaxFaces = 6,
  cCRNMaxLevels = 16,

  cCRNMaxHelperThreads = 15,

  cCRNMinQualityLevel = 0,
  cCRNMaxQualityLevel = 255
};

// CRN/DDS compression flags.
// See the m_flags member in the crn_comp_params struct, below.
enum crn_comp_flags {
  // Enables perceptual colorspace distance metrics if set.
  // Important: Be sure to disable this when compressing non-sRGB colorspace images, like normal maps!
  // Default: Set
  cCRNCompFlagPerceptual = 1,

  // Enables (up to) 8x8 macroblock usage if set. If disabled, only 4x4 blocks are allowed.
  // Compression ratio will be lower when disabled, but may cut down on blocky artifacts because the process used to determine
  // where large macroblocks can be used without artifacts isn't perfect.
  // Default: Set.
  cCRNCompFlagHierarchical = 2,

  // cCRNCompFlagQuick disables several output file optimizations - intended for things like quicker previews.
  // Default: Not set.
  cCRNCompFlagQuick = 4,

  // DXT1: OK to use DXT1 alpha blocks for better quality or DXT1A transparency.
  // DXT5: OK to use both DXT5 block types.
  // Currently only used when writing to .DDS files, as .CRN uses only a subset of the possible DXTn block types.
  // Default: Set.
  cCRNCompFlagUseBothBlockTypes = 8,

  // OK to use DXT1A transparent indices to encode black (assumes pixel shader ignores fetched alpha).
  // Currently only used when writing to .DDS files, .CRN never uses alpha blocks.
  // Default: Not set.
  cCRNCompFlagUseTransparentIndicesForBlack = 16,

  // Disables endpoint caching, for more deterministic output.
  // Currently only used when writing to .DDS files.
  // Default: Not set.
  cCRNCompFlagDisableEndpointCaching = 32,

  // If enabled, use the cCRNColorEndpointPaletteSize, etc. params to control the CRN palette sizes. Only useful when writing to .CRN files.
  // Default: Not set.
  cCRNCompFlagManualPaletteSizes = 64,

  // If enabled, DXT1A alpha blocks are used to encode single bit transparency.
  // Default: Not set.
  cCRNCompFlagDXT1AForTransparency = 128,

  // If enabled, the DXT1 compressor's color distance metric assumes the pixel shader will be converting the fetched RGB results to luma (Y part of YCbCr).
  // This increases quality when compressing grayscale images, because the compressor can spread the luma error amoung all three channels (i.e. it can generate blocks
  // with some chroma present if doing so will ultimately lead to lower luma error).
  // Only enable on grayscale source images.
  // Default: Not set.
  cCRNCompFlagGrayscaleSampling = 256,

  // If enabled, debug information will be output during compression.
  // Default: Not set.
  cCRNCompFlagDebugging = 0x80000000,

  cCRNCompFlagForceDWORD = 0xFFFFFFFF
};

// Controls DXTn quality vs. speed control - only used when compressing to .DDS.
enum crn_dxt_quality {
  cCRNDXTQualitySuperFast,
  cCRNDXTQualityFast,
  cCRNDXTQualityNormal,
  cCRNDXTQualityBetter,
  cCRNDXTQualityUber,

  cCRNDXTQualityTotal,

  cCRNDXTQualityForceDWORD = 0xFFFFFFFF
};

// Which DXTn compressor to use when compressing to plain (non-clustered) .DDS.
enum crn_dxt_compressor_type {
  cCRNDXTCompressorCRN,   // Use crnlib's ETC1 or DXTc block compressor (default, highest quality, comparable or better than ati_compress or squish, and crnlib's ETC1 is a lot fasterw with similiar quality to Erricson's)
  cCRNDXTCompressorCRNF,  // Use crnlib's "fast" DXTc block compressor
  cCRNDXTCompressorRYG,   // Use RYG's DXTc block compressor (low quality, but very fast)

#if CRNLIB_SUPPORT_ATI_COMPRESS
  cCRNDXTCompressorATI,
#endif

#if CRNLIB_SUPPORT_SQUISH
  cCRNDXTCompressorSquish,
#endif

  cCRNTotalDXTCompressors,

  cCRNDXTCompressorForceDWORD = 0xFFFFFFFF
};

// Progress callback function.
// Processing will stop prematurely (and fail) if the callback returns false.
// phase_index, total_phases - high level progress
// subphase_index, total_subphases - progress within current phase
typedef crn_bool (*crn_progress_callback_func)(crn_uint32 phase_index, crn_uint32 total_phases, crn_uint32 subphase_index, crn_uint32 total_subphases, void* pUser_data_ptr);

// CRN/DDS compression parameters struct.
struct crn_comp_params {
  inline crn_comp_params() { clear(); }

  // Clear struct to default parameters.
  inline void clear() {
    m_size_of_obj = sizeof(*this);
    m_file_type = cCRNFileTypeCRN;
    m_faces = 1;
    m_width = 0;
    m_height = 0;
    m_levels = 1;
    m_format = cCRNFmtDXT1;
    m_flags = cCRNCompFlagPerceptual | cCRNCompFlagHierarchical | cCRNCompFlagUseBothBlockTypes;

    for (crn_uint32 f = 0; f < cCRNMaxFaces; f++)
      for (crn_uint32 l = 0; l < cCRNMaxLevels; l++)
        m_pImages[f][l] = NULL;

    m_target_bitrate = 0.0f;
    m_quality_level = cCRNMaxQualityLevel;
    m_dxt1a_alpha_threshold = 128;
    m_dxt_quality = cCRNDXTQualityUber;
    m_dxt_compressor_type = cCRNDXTCompressorCRN;
    m_alpha_component = 3;

    m_crn_adaptive_tile_color_psnr_derating = 2.0f;
    m_crn_adaptive_tile_alpha_psnr_derating = 2.0f;
    m_crn_color_endpoint_palette_size = 0;
    m_crn_color_selector_palette_size = 0;
    m_crn_alpha_endpoint_palette_size = 0;
    m_crn_alpha_selector_palette_size = 0;

    m_num_helper_threads = 0;
    m_userdata0 = 0;
    m_userdata1 = 0;
    m_pProgress_func = NULL;
    m_pProgress_func_data = NULL;
  }

  inline bool operator==(const crn_comp_params& rhs) const {
#define CRNLIB_COMP(x)  \
  do {                  \
    if ((x) != (rhs.x)) \
      return false;     \
  } while (0)
    CRNLIB_COMP(m_size_of_obj);
    CRNLIB_COMP(m_file_type);
    CRNLIB_COMP(m_faces);
    CRNLIB_COMP(m_width);
    CRNLIB_COMP(m_height);
    CRNLIB_COMP(m_levels);
    CRNLIB_COMP(m_format);
    CRNLIB_COMP(m_flags);
    CRNLIB_COMP(m_target_bitrate);
    CRNLIB_COMP(m_quality_level);
    CRNLIB_COMP(m_dxt1a_alpha_threshold);
    CRNLIB_COMP(m_dxt_quality);
    CRNLIB_COMP(m_dxt_compressor_type);
    CRNLIB_COMP(m_alpha_component);
    CRNLIB_COMP(m_crn_adaptive_tile_color_psnr_derating);
    CRNLIB_COMP(m_crn_adaptive_tile_alpha_psnr_derating);
    CRNLIB_COMP(m_crn_color_endpoint_palette_size);
    CRNLIB_COMP(m_crn_color_selector_palette_size);
    CRNLIB_COMP(m_crn_alpha_endpoint_palette_size);
    CRNLIB_COMP(m_crn_alpha_selector_palette_size);
    CRNLIB_COMP(m_num_helper_threads);
    CRNLIB_COMP(m_userdata0);
    CRNLIB_COMP(m_userdata1);
    CRNLIB_COMP(m_pProgress_func);
    CRNLIB_COMP(m_pProgress_func_data);

    for (crn_uint32 f = 0; f < cCRNMaxFaces; f++)
      for (crn_uint32 l = 0; l < cCRNMaxLevels; l++)
        CRNLIB_COMP(m_pImages[f][l]);

#undef CRNLIB_COMP
    return true;
  }

  // Returns true if the input parameters are reasonable.
  inline bool check() const {
    if ((m_file_type > cCRNFileTypeDDS) ||
        (((int)m_quality_level < (int)cCRNMinQualityLevel) || ((int)m_quality_level > (int)cCRNMaxQualityLevel)) ||
        (m_dxt1a_alpha_threshold > 255) ||
        ((m_faces != 1) && (m_faces != 6)) ||
        ((m_width < 1) || (m_width > cCRNMaxLevelResolution)) ||
        ((m_height < 1) || (m_height > cCRNMaxLevelResolution)) ||
        ((m_levels < 1) || (m_levels > cCRNMaxLevels)) ||
        ((m_format < cCRNFmtDXT1) || (m_format >= cCRNFmtTotal)) ||
        ((m_crn_color_endpoint_palette_size) && ((m_crn_color_endpoint_palette_size < cCRNMinPaletteSize) || (m_crn_color_endpoint_palette_size > cCRNMaxPaletteSize))) ||
        ((m_crn_color_selector_palette_size) && ((m_crn_color_selector_palette_size < cCRNMinPaletteSize) || (m_crn_color_selector_palette_size > cCRNMaxPaletteSize))) ||
        ((m_crn_alpha_endpoint_palette_size) && ((m_crn_alpha_endpoint_palette_size < cCRNMinPaletteSize) || (m_crn_alpha_endpoint_palette_size > cCRNMaxPaletteSize))) ||
        ((m_crn_alpha_selector_palette_size) && ((m_crn_alpha_selector_palette_size < cCRNMinPaletteSize) || (m_crn_alpha_selector_palette_size > cCRNMaxPaletteSize))) ||
        (m_alpha_component > 3) ||
        (m_num_helper_threads > cCRNMaxHelperThreads) ||
        (m_dxt_quality > cCRNDXTQualityUber) ||
        (m_dxt_compressor_type >= cCRNTotalDXTCompressors)) {
      return false;
    }
    return true;
  }

  // Helper to set/get flags from m_flags member.
  inline bool get_flag(crn_comp_flags flag) const { return (m_flags & flag) != 0; }
  inline void set_flag(crn_comp_flags flag, bool val) {
    m_flags &= ~flag;
    if (val)
      m_flags |= flag;
  }

  crn_uint32 m_size_of_obj;

  crn_file_type m_file_type;  // Output file type: cCRNFileTypeCRN or cCRNFileTypeDDS.

  crn_uint32 m_faces;   // 1 (2D map) or 6 (cubemap)
  crn_uint32 m_width;   // [1,cCRNMaxLevelResolution], non-power of 2 OK, non-square OK
  crn_uint32 m_height;  // [1,cCRNMaxLevelResolution], non-power of 2 OK, non-square OK
  crn_uint32 m_levels;  // [1,cCRNMaxLevelResolution], non-power of 2 OK, non-square OK

  crn_format m_format;  // Output pixel format.

  crn_uint32 m_flags;  // see crn_comp_flags enum

  // Array of pointers to 32bpp input images.
  const crn_uint32* m_pImages[cCRNMaxFaces][cCRNMaxLevels];

  // Target bitrate - if non-zero, the compressor will use an interpolative search to find the
  // highest quality level that is <= the target bitrate. If it fails to find a bitrate high enough, it'll
  // try disabling adaptive block sizes (cCRNCompFlagHierarchical flag) and redo the search. This process can be pretty slow.
  float m_target_bitrate;

  // Desired quality level.
  // Currently, CRN and DDS quality levels are not compatible with eachother from an image quality standpoint.
  crn_uint32 m_quality_level;  // [cCRNMinQualityLevel, cCRNMaxQualityLevel]

  // DXTn compression parameters.
  crn_uint32 m_dxt1a_alpha_threshold;
  crn_dxt_quality m_dxt_quality;
  crn_dxt_compressor_type m_dxt_compressor_type;

  // Alpha channel's component. Defaults to 3.
  crn_uint32 m_alpha_component;

  // Various low-level CRN specific parameters.
  float m_crn_adaptive_tile_color_psnr_derating;
  float m_crn_adaptive_tile_alpha_psnr_derating;

  crn_uint32 m_crn_color_endpoint_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]
  crn_uint32 m_crn_color_selector_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]

  crn_uint32 m_crn_alpha_endpoint_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]
  crn_uint32 m_crn_alpha_selector_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]

  // Number of helper threads to create during compression. 0=no threading.
  crn_uint32 m_num_helper_threads;

  // CRN userdata0 and userdata1 members, which are written directly to the header of the output file.
  crn_uint32 m_userdata0;
  crn_uint32 m_userdata1;

  // User provided progress callback.
  crn_progress_callback_func m_pProgress_func;
  void* m_pProgress_func_data;
};

// Mipmap generator's mode.
enum crn_mip_mode {
  cCRNMipModeUseSourceOrGenerateMips,  // Use source texture's mipmaps if it has any, otherwise generate new mipmaps
  cCRNMipModeUseSourceMips,            // Use source texture's mipmaps if it has any, otherwise the output has no mipmaps
  cCRNMipModeGenerateMips,             // Always generate new mipmaps
  cCRNMipModeNoMips,                   // Output texture has no mipmaps

  cCRNMipModeTotal,

  cCRNModeForceDWORD = 0xFFFFFFFF
};

const char* crn_get_mip_mode_desc(crn_mip_mode m);
const char* crn_get_mip_mode_name(crn_mip_mode m);

// Mipmap generator's filter kernel.
enum crn_mip_filter {
  cCRNMipFilterBox,
  cCRNMipFilterTent,
  cCRNMipFilterLanczos4,
  cCRNMipFilterMitchell,
  cCRNMipFilterKaiser,  // Kaiser=default mipmap filter

  cCRNMipFilterTotal,

  cCRNMipFilterForceDWORD = 0xFFFFFFFF
};

const char* crn_get_mip_filter_name(crn_mip_filter f);

// Mipmap generator's scale mode.
enum crn_scale_mode {
  cCRNSMDisabled,
  cCRNSMAbsolute,
  cCRNSMRelative,
  cCRNSMLowerPow2,
  cCRNSMNearestPow2,
  cCRNSMNextPow2,

  cCRNSMTotal,

  cCRNSMForceDWORD = 0xFFFFFFFF
};

const char* crn_get_scale_mode_desc(crn_scale_mode sm);

// Mipmap generator parameters.
struct crn_mipmap_params {
  inline crn_mipmap_params() { clear(); }

  inline void clear() {
    m_size_of_obj = sizeof(*this);
    m_mode = cCRNMipModeUseSourceOrGenerateMips;
    m_filter = cCRNMipFilterKaiser;
    m_gamma_filtering = true;
    m_gamma = 2.2f;
    // Default "blurriness" factor of .9 actually sharpens the output a little.
    m_blurriness = .9f;
    m_renormalize = false;
    m_tiled = false;
    m_max_levels = cCRNMaxLevels;
    m_min_mip_size = 1;

    m_scale_mode = cCRNSMDisabled;
    m_scale_x = 1.0f;
    m_scale_y = 1.0f;

    m_window_left = 0;
    m_window_top = 0;
    m_window_right = 0;
    m_window_bottom = 0;

    m_clamp_scale = false;
    m_clamp_width = 0;
    m_clamp_height = 0;
  }

  inline bool check() const { return true; }

  inline bool operator==(const crn_mipmap_params& rhs) const {
#define CRNLIB_COMP(x)  \
  do {                  \
    if ((x) != (rhs.x)) \
      return false;     \
  } while (0)
    CRNLIB_COMP(m_size_of_obj);
    CRNLIB_COMP(m_mode);
    CRNLIB_COMP(m_filter);
    CRNLIB_COMP(m_gamma_filtering);
    CRNLIB_COMP(m_gamma);
    CRNLIB_COMP(m_blurriness);
    CRNLIB_COMP(m_renormalize);
    CRNLIB_COMP(m_tiled);
    CRNLIB_COMP(m_max_levels);
    CRNLIB_COMP(m_min_mip_size);
    CRNLIB_COMP(m_scale_mode);
    CRNLIB_COMP(m_scale_x);
    CRNLIB_COMP(m_scale_y);
    CRNLIB_COMP(m_window_left);
    CRNLIB_COMP(m_window_top);
    CRNLIB_COMP(m_window_right);
    CRNLIB_COMP(m_window_bottom);
    CRNLIB_COMP(m_clamp_scale);
    CRNLIB_COMP(m_clamp_width);
    CRNLIB_COMP(m_clamp_height);
    return true;
#undef CRNLIB_COMP
  }
  crn_uint32 m_size_of_obj;

  crn_mip_mode m_mode;
  crn_mip_filter m_filter;

  crn_bool m_gamma_filtering;
  float m_gamma;

  float m_blurriness;

  crn_uint32 m_max_levels;
  crn_uint32 m_min_mip_size;

  crn_bool m_renormalize;
  crn_bool m_tiled;

  crn_scale_mode m_scale_mode;
  float m_scale_x;
  float m_scale_y;

  crn_uint32 m_window_left;
  crn_uint32 m_window_top;
  crn_uint32 m_window_right;
  crn_uint32 m_window_bottom;

  crn_bool m_clamp_scale;
  crn_uint32 m_clamp_width;
  crn_uint32 m_clamp_height;
};

// -------- High-level helper function definitions for CDN/DDS compression.

#ifndef CRNLIB_MIN_ALLOC_ALIGNMENT
#define CRNLIB_MIN_ALLOC_ALIGNMENT sizeof(size_t) * 2
#endif

// Function to set an optional user provided memory allocation/reallocation/msize routines.
// By default, crnlib just uses malloc(), free(), etc. for all allocations.
typedef void* (*crn_realloc_func)(void* p, size_t size, size_t* pActual_size, bool movable, void* pUser_data);
typedef size_t (*crn_msize_func)(void* p, void* pUser_data);
void crn_set_memory_callbacks(crn_realloc_func pRealloc, crn_msize_func pMSize, void* pUser_data);

// Frees memory blocks allocated by crn_compress(), crn_decompress_crn_to_dds(), or crn_decompress_dds_to_images().
void crn_free_block(void* pBlock);

// Compresses a 32-bit/pixel texture to either: a regular DX9 DDS file, a "clustered" (or reduced entropy) DX9 DDS file, or a CRN file in memory.
// Input parameters:
//  comp_params is the compression parameters struct, defined above.
//  compressed_size will be set to the size of the returned memory block containing the output file.
//  The returned block must be freed by calling crn_free_block().
//  *pActual_quality_level will be set to the actual quality level used to compress the image. May be NULL.
//  *pActual_bitrate will be set to the output file's effective bitrate, possibly taking into account LZMA compression. May be NULL.
// Return value:
//  The compressed file data, or NULL on failure.
//  compressed_size will be set to the size of the returned memory buffer.
// Notes:
//  A "regular" DDS file is compressed using normal DXTn compression at the specified DXT quality level.
//  A "clustered" DDS file is compressed using clustered DXTn compression to either the target bitrate or the specified integer quality factor.
//  The output file is a standard DX9 format DDS file, except the compressor assumes you will be later losslessly compressing the DDS output file using the LZMA algorithm.
//  A texture is defined as an array of 1 or 6 "faces" (6 faces=cubemap), where each "face" consists of between [1,cCRNMaxLevels] mipmap levels.
//  Mipmap levels are simple 32-bit 2D images with a pitch of width*sizeof(uint32), arranged in the usual raster order (top scanline first).
//  The image pixels may be grayscale (YYYX bytes in memory), grayscale/alpha (YYYA in memory), 24-bit (RGBX in memory), or 32-bit (RGBA) colors (where "X"=don't care).
//  RGB color data is generally assumed to be in the sRGB colorspace. If not, be sure to clear the "cCRNCompFlagPerceptual" in the crn_comp_params struct!
void* crn_compress(const crn_comp_params& comp_params, crn_uint32& compressed_size, crn_uint32* pActual_quality_level = NULL, float* pActual_bitrate = NULL);

// Like the above function, except this function can also do things like generate mipmaps, and resize or crop the input texture before compression.
// The actual operations performed are controlled by the crn_mipmap_params struct members.
// Be sure to set the "m_gamma_filtering" member of crn_mipmap_params to false if the input texture is not sRGB.
void* crn_compress(const crn_comp_params& comp_params, const crn_mipmap_params& mip_params, crn_uint32& compressed_size, crn_uint32* pActual_quality_level = NULL, float* pActual_bitrate = NULL);

// Transcodes an entire CRN file to DDS using the crn_decomp.h header file library to do most of the heavy lifting.
// The output DDS file's format is guaranteed to be one of the DXTn formats in the crn_format enum.
// This is a fast operation, because the CRN format is explicitly designed to be efficiently transcodable to DXTn.
// For more control over decompression, see the lower-level helper functions in crn_decomp.h, which do not depend at all on crnlib.
void* crn_decompress_crn_to_dds(const void* pCRN_file_data, crn_uint32& file_size);

// Decompresses an entire DDS file in any supported format to uncompressed 32-bit/pixel image(s).
// See the crnlib::pixel_format enum in inc/dds_defs.h for a list of the supported DDS formats.
// You are responsible for freeing each image block, either by calling crn_free_all_images() or manually calling crn_free_block() on each image pointer.
struct crn_texture_desc {
  crn_uint32 m_faces;
  crn_uint32 m_width;
  crn_uint32 m_height;
  crn_uint32 m_levels;
  crn_uint32 m_fmt_fourcc;  // Same as crnlib::pixel_format
};
bool crn_decompress_dds_to_images(const void* pDDS_file_data, crn_uint32 dds_file_size, crn_uint32** ppImages, crn_texture_desc& tex_desc);

// Frees all images allocated by crn_decompress_dds_to_images().
void crn_free_all_images(crn_uint32** ppImages, const crn_texture_desc& desc);

// -------- crn_format related helpers functions.

// Returns the FOURCC format equivalent to the specified crn_format.
crn_uint32 crn_get_format_fourcc(crn_format fmt);

// Returns the crn_format's bits per texel.
crn_uint32 crn_get_format_bits_per_texel(crn_format fmt);

// Returns the crn_format's number of bytes per block.
crn_uint32 crn_get_bytes_per_dxt_block(crn_format fmt);

// Returns the non-swizzled, basic DXTn version of the specified crn_format.
// This is the format you would supply D3D or OpenGL.
crn_format crn_get_fundamental_dxt_format(crn_format fmt);

// -------- String helpers.

// Converts a crn_file_type to a string.
const char* crn_get_file_type_ext(crn_file_type file_type);

// Converts a crn_format to a string.
const char* crn_get_format_string(crn_format fmt);

// Converts a crn_dxt_quality to a string.
const char* crn_get_dxt_quality_string(crn_dxt_quality q);

// -------- Low-level DXTn 4x4 block compressor API

// crnlib's DXTn endpoint optimizer actually supports any number of source pixels (i.e. from 1 to thousands, not just 16),
// but for simplicity this API only supports 4x4 texel blocks.
typedef void* crn_block_compressor_context_t;

// Create a DXTn block compressor.
// This function only supports the basic/nonswizzled "fundamental" formats: DXT1, DXT3, DXT5, DXT5A, DXN_XY and DXN_YX.
// Avoid calling this multiple times if you intend on compressing many blocks, because it allocates some memory.
crn_block_compressor_context_t crn_create_block_compressor(const crn_comp_params& params);

// Compresses a block of 16 pixels to the destination DXTn block.
// pDst_block should be 8 (for DXT1/DXT5A) or 16 bytes (all the others).
// pPixels should be an array of 16 crn_uint32's. Each crn_uint32 must be r,g,b,a (r is always first) in memory.
void crn_compress_block(crn_block_compressor_context_t pContext, const crn_uint32* pPixels, void* pDst_block);

// Frees a DXTn block compressor.
void crn_free_block_compressor(crn_block_compressor_context_t pContext);

// Unpacks a compressed block to pDst_pixels.
// pSrc_block should be 8 (for DXT1/DXT5A) or 16 bytes (all the others).
// pDst_pixel should be an array of 16 crn_uint32's. Each uint32 will be r,g,b,a (r is always first) in memory.
// crn_fmt should be one of the "fundamental" formats: DXT1, DXT3, DXT5, DXT5A, DXN_XY and DXN_YX.
// The various swizzled DXT5 formats (such as cCRNFmtDXT5_xGBR, etc.) will be unpacked as if they where plain DXT5.
// Returns false if the crn_fmt is invalid.
bool crn_decompress_block(const void* pSrc_block, crn_uint32* pDst_pixels, crn_format crn_fmt);

#endif  // CRNLIB_H

//------------------------------------------------------------------------------
//
// crnlib uses the ZLIB license:
// http://opensource.org/licenses/Zlib
//
// Copyright (c) 2010-2016 Richard Geldreich, Jr. and Binomial LLC
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
//
//------------------------------------------------------------------------------

```

`Texture2DDecoderWrapper/T2DDll.cs`:

```cs
namespace Texture2DDecoder
{
    internal static class T2DDll
    {

        internal const string DllName = "Texture2DDecoderNative";

    }
}

```

`Texture2DDecoderWrapper/Texture2DDecoderWrapper.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net472;netstandard2.0;net5.0;net6.0</TargetFrameworks>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Version>0.16.0.0</Version>
    <AssemblyVersion>0.16.0.0</AssemblyVersion>
    <FileVersion>0.16.0.0</FileVersion>
    <Copyright>Copyright © Perfare 2020-2022; Copyright © hozuki 2020</Copyright>
    <DebugType>embedded</DebugType>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\AssetStudio.PInvoke\AssetStudio.PInvoke.csproj" />
  </ItemGroup>

</Project>

```

`Texture2DDecoderWrapper/TextureDecoder.PInvoke.cs`:

```cs
using System.Runtime.InteropServices;

namespace Texture2DDecoder
{
    unsafe partial class TextureDecoder
    {

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeDXT1(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeDXT5(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodePVRTC(void* data, int width, int height, void* image, [MarshalAs(UnmanagedType.Bool)] bool is2bpp);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeETC1(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeETC2(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeETC2A1(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeETC2A8(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeEACR(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeEACRSigned(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeEACRG(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeEACRGSigned(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeBC4(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeBC5(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeBC6(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeBC7(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeATCRGB4(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeATCRGBA8(void* data, int width, int height, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DecodeASTC(void* data, int width, int height, int blockWidth, int blockHeight, void* image);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void DisposeBuffer(ref void* ppBuffer);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void UnpackCrunch(void* data, uint dataSize, out void* result, out uint resultSize);

        [DllImport(T2DDll.DllName, CallingConvention = CallingConvention.Winapi)]
        private static extern void UnpackUnityCrunch(void* data, uint dataSize, out void* result, out uint resultSize);

    }
}

```

`Texture2DDecoderWrapper/TextureDecoder.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using AssetStudio.PInvoke;

namespace Texture2DDecoder
{
    public static unsafe partial class TextureDecoder
    {

        static TextureDecoder()
        {
            DllLoader.PreloadDll(T2DDll.DllName);
        }

        public static bool DecodeDXT1(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeDXT1(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeDXT5(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeDXT5(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodePVRTC(byte[] data, int width, int height, byte[] image, bool is2bpp)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodePVRTC(pData, width, height, pImage, is2bpp);
                }
            }
        }

        public static bool DecodeETC1(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeETC1(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeETC2(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeETC2(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeETC2A1(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeETC2A1(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeETC2A8(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeETC2A8(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeEACR(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeEACR(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeEACRSigned(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeEACRSigned(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeEACRG(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeEACRG(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeEACRGSigned(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeEACRGSigned(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeBC4(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeBC4(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeBC5(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeBC5(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeBC6(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeBC6(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeBC7(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeBC7(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeATCRGB4(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeATCRGB4(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeATCRGBA8(byte[] data, int width, int height, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeATCRGBA8(pData, width, height, pImage);
                }
            }
        }

        public static bool DecodeASTC(byte[] data, int width, int height, int blockWidth, int blockHeight, byte[] image)
        {
            fixed (byte* pData = data)
            {
                fixed (byte* pImage = image)
                {
                    return DecodeASTC(pData, width, height, blockWidth, blockHeight, pImage);
                }
            }
        }

        public static byte[] UnpackCrunch(byte[] data)
        {
            void* pBuffer;
            uint bufferSize;

            fixed (byte* pData = data)
            {
                UnpackCrunch(pData, (uint)data.Length, out pBuffer, out bufferSize);
            }

            if (pBuffer == null)
            {
                return null;
            }

            var result = new byte[bufferSize];

            Marshal.Copy(new IntPtr(pBuffer), result, 0, (int)bufferSize);

            DisposeBuffer(ref pBuffer);

            return result;
        }

        public static byte[] UnpackUnityCrunch(byte[] data)
        {
            void* pBuffer;
            uint bufferSize;

            fixed (byte* pData = data)
            {
                UnpackUnityCrunch(pData, (uint)data.Length, out pBuffer, out bufferSize);
            }

            if (pBuffer == null)
            {
                return null;
            }

            var result = new byte[bufferSize];

            Marshal.Copy(new IntPtr(pBuffer), result, 0, (int)bufferSize);

            DisposeBuffer(ref pBuffer);

            return result;
        }

    }
}

```