Project Path: arc_intel_pcm_ruxigw_m

Source Tree:

```txt
arc_intel_pcm_ruxigw_m
├── CMakeLists.txt
├── CONTRIBUTING.md
├── Dockerfile
├── Doxyfile
├── Intel-PMT
├── LICENSE
├── README.md
├── SECURITY.md
├── _codeql_detected_source_root
├── _service
├── appveyor.yml
├── cmake
│   └── CPM.cmake
├── doc
│   ├── CUSTOM-COMPILE-OPTIONS.md
│   ├── CXL_README.md
│   ├── DOCKER_README.md
│   ├── ENVVAR_README.md
│   ├── FAQ.md
│   ├── FREEBSD_HOWTO.txt
│   ├── KSysGuard HOWTO.docx
│   ├── KSysGuard HOWTO.pdf
│   ├── LATENCY-OPTIMIZED-MODE.md
│   ├── LINUX_HOWTO.txt
│   ├── MAC_HOWTO.txt
│   ├── NUMA_NODE_API.md
│   ├── PCM-EXPORTER.md
│   ├── PCM-SENSOR-SERVER-README.md
│   ├── PCM_ACCEL_README.md
│   ├── PCM_IIO_README.md
│   ├── PCM_RAW_README.md
│   ├── STARS.md
│   ├── WINDOWS_HOWTO.md
│   ├── generate_summary_readme.md
│   ├── license.txt
│   └── run-as-administrator.png
├── docker-compose.yml
├── examples
│   ├── CMakeLists.txt
│   ├── c_example.c
│   ├── numa_node_example.cpp
│   └── numa_to_socket_example.cpp
├── pcm-kubernetes.yaml.experimental
├── pcm.spec
├── perfmon
├── scripts
│   ├── bhs-power-mode.ps1
│   ├── bhs-power-mode.sh
│   ├── build.sh
│   ├── busy.sh
│   ├── convert_edp_list.sh
│   ├── cppcheck.sh
│   ├── debug-build.sh
│   ├── filter.sh
│   ├── find_field.awk
│   ├── find_field.sh
│   ├── generate_summary.py
│   ├── get_sles_bins.sh
│   ├── grafana
│   │   ├── README.md
│   │   ├── automatic_influxdb.yml
│   │   ├── automatic_prometheus.yml
│   │   ├── clean.sh
│   │   ├── prometheus.yml.template
│   │   ├── provisioning
│   │   │   └── dashboards
│   │   │       └── pcm-provider.yml
│   │   ├── start-prometheus.sh
│   │   ├── start.sh
│   │   ├── stop.sh
│   │   └── telegraf.conf.template
│   ├── pcm-background.sh
│   ├── pcm-exporter
│   ├── pcm-stop.sh
│   ├── pcm-win-power-tray.py
│   ├── pcm.plot
│   ├── pmu-query.py
│   ├── readmem.sh
│   ├── single_header.awk
│   ├── single_header.sh
│   ├── topotop
│   └── ufs-die-stat.sh
├── src
│   ├── CMakeLists.txt
│   ├── MacMSRDriver
│   │   ├── CMakeLists.txt
│   │   ├── MSRAccessor.cpp
│   │   ├── MSRAccessor.h
│   │   ├── MSRKernel.h
│   │   ├── PCIDriverInterface.cpp
│   │   ├── PCIDriverInterface.h
│   │   ├── PcmMsr
│   │   │   ├── CMakeLists.txt
│   │   │   ├── PcmMsr-Info.plist
│   │   │   ├── PcmMsr-Prefix.pch
│   │   │   ├── PcmMsr.cpp
│   │   │   ├── PcmMsr.h
│   │   │   ├── PcmMsrClient.cpp
│   │   │   ├── PcmMsrClient.h
│   │   │   ├── PcmMsrDriver_info.c
│   │   │   ├── UserKernelShared.h
│   │   │   └── en.lproj
│   │   │       └── InfoPlist.strings
│   │   ├── PcmMsr.xcodeproj
│   │   │   ├── project.pbxproj
│   │   │   ├── project.xcworkspace
│   │   │   │   ├── contents.xcworkspacedata
│   │   │   │   └── xcuserdata
│   │   │   │       ├── aiott.xcuserdatad
│   │   │   │       │   └── UserInterfaceState.xcuserstate
│   │   │   │       └── pjkerly.xcuserdatad
│   │   │   │           └── UserInterfaceState.xcuserstate
│   │   │   └── xcuserdata
│   │   │       ├── aiott.xcuserdatad
│   │   │       │   ├── xcdebugger
│   │   │       │   │   └── Breakpoints.xcbkptlist
│   │   │       │   └── xcschemes
│   │   │       │       ├── PcmMsr.xcscheme
│   │   │       │       ├── PcmMsrLibrary.xcscheme
│   │   │       │       └── xcschememanagement.plist
│   │   │       └── pjkerly.xcuserdatad
│   │   │           └── xcschemes
│   │   │               ├── PcmMsrDriver.xcscheme
│   │   │               ├── PcmMsrLibrary.xcscheme
│   │   │               └── xcschememanagement.plist
│   │   ├── kextload.sh
│   │   └── kextunload.sh
│   ├── PMURegisterDeclarations
│   │   ├── GenuineIntel-6-4F-1.json
│   │   ├── GenuineIntel-6-55-4.json
│   │   ├── GenuineIntel-6-6A-0.json
│   │   ├── GenuineIntel-6-86-5.json
│   │   ├── GenuineIntel-6-8E-C.json
│   │   ├── GenuineIntel-6-8F-6.json
│   │   ├── GenuineIntel-6-AD-0.json
│   │   ├── GenuineIntel-6-AE-0.json
│   │   ├── GenuineIntel-6-AF-0.json
│   │   ├── GenuineIntel-6-B6-0.json
│   │   └── GenuineIntel-6-CF-1.json
│   ├── WinMSRDriver
│   │   ├── MSR.inf
│   │   ├── MSR.vcxproj
│   │   ├── makefile
│   │   ├── msr.h
│   │   ├── msrmain.c
│   │   ├── msrstruct.h
│   │   └── sources
│   ├── bw.cpp
│   ├── bw.h
│   ├── client
│   │   ├── client.cpp
│   │   ├── client.h
│   │   └── main.cpp
│   ├── cpuasynchcounter.h
│   ├── cpucounters.cpp
│   ├── cpucounters.h
│   ├── daemon
│   │   ├── common.h
│   │   ├── daemon.cpp
│   │   ├── daemon.h
│   │   ├── main.cpp
│   │   └── pcm.h
│   ├── dashboard.cpp
│   ├── dashboard.h
│   ├── dashboardtest.cpp
│   ├── debug.cpp
│   ├── debug.h
│   ├── exceptions
│   │   └── unsupported_processor_exception.hpp
│   ├── favicon.ico.h
│   ├── freegetopt
│   │   ├── ChangeLog
│   │   ├── LICENSE
│   │   ├── README
│   │   ├── getopt.cpp
│   │   └── getopt.h
│   ├── lspci.cpp
│   ├── lspci.h
│   ├── memoptest.cpp
│   ├── mmio.cpp
│   ├── mmio.h
│   ├── msr.cpp
│   ├── msr.h
│   ├── msrtest.cpp
│   ├── mutex.h
│   ├── opCode-6-106.txt
│   ├── opCode-6-108.txt
│   ├── opCode-6-134.txt
│   ├── opCode-6-143-accel.txt
│   ├── opCode-6-143.txt
│   ├── opCode-6-173.txt
│   ├── opCode-6-174.txt
│   ├── opCode-6-175.txt
│   ├── opCode-6-182.txt
│   ├── opCode-6-207.txt
│   ├── opCode-6-85.txt
│   ├── pci.cpp
│   ├── pci.h
│   ├── pcm-accel-common.cpp
│   ├── pcm-accel-common.h
│   ├── pcm-accel.cpp
│   ├── pcm-bw-histogram.sh
│   ├── pcm-core.cpp
│   ├── pcm-iio-pmu.cpp
│   ├── pcm-iio-pmu.h
│   ├── pcm-iio-topology.cpp
│   ├── pcm-iio-topology.h
│   ├── pcm-iio.cpp
│   ├── pcm-latency.cpp
│   ├── pcm-memory.cpp
│   ├── pcm-mmio.cpp
│   ├── pcm-msr.cpp
│   ├── pcm-numa.cpp
│   ├── pcm-pcicfg.cpp
│   ├── pcm-pcie.cpp
│   ├── pcm-pcie.h
│   ├── pcm-power.cpp
│   ├── pcm-raw.cpp
│   ├── pcm-sensor-server.cpp
│   ├── pcm-sensor-server.service.in
│   ├── pcm-sensor.cpp
│   ├── pcm-tpmi.cpp
│   ├── pcm-tsx.cpp
│   ├── pcm.cpp
│   ├── pmt.cpp
│   ├── pmt.h
│   ├── pugixml
│   ├── readmem.cpp
│   ├── realtime.cpp
│   ├── resctrl.cpp
│   ├── resctrl.h
│   ├── threadpool.cpp
│   ├── threadpool.h
│   ├── topology.cpp
│   ├── topology.h
│   ├── topologyentry.h
│   ├── tpmi.cpp
│   ├── tpmi.h
│   ├── types.h
│   ├── uncore_pmu_discovery.cpp
│   ├── uncore_pmu_discovery.h
│   ├── utils.cpp
│   ├── utils.h
│   ├── version.h
│   ├── width_extender.h
│   ├── windows
│   │   ├── AssemblyInfo.cpp
│   │   ├── PCM-Service.exe.config
│   │   ├── PCMInstaller.cpp
│   │   ├── PCMInstaller.h
│   │   ├── PCMService.cpp
│   │   ├── PCMService.h
│   │   ├── PCM_cpp_ReadMe.txt
│   │   ├── ReadMe_PCMService.txt
│   │   ├── dllmain.cpp
│   │   ├── pcm-core-win.cpp
│   │   ├── pcm-iio-win.cpp
│   │   ├── pcm-latency-win.cpp
│   │   ├── pcm-lib.cpp
│   │   ├── pcm-lib.h
│   │   ├── pcm-memory-win.cpp
│   │   ├── pcm-mmio-win.cpp
│   │   ├── pcm-msr-win.cpp
│   │   ├── pcm-numa-win.cpp
│   │   ├── pcm-pcicfg-win.cpp
│   │   ├── pcm-pcie-win.cpp
│   │   ├── pcm-power-win.cpp
│   │   ├── pcm-raw-win.cpp
│   │   ├── pcm-tsx-win.cpp
│   │   ├── pcm.cpp
│   │   ├── pcm_lib_ReadMe.txt
│   │   ├── pcm_power_ReadMe.txt
│   │   ├── stdafx.cpp
│   │   ├── stdafx.h
│   │   └── windriver.h
│   ├── winpmem
│   │   ├── LICENSE.txt
│   │   ├── winpmem.cpp
│   │   └── winpmem.h
│   └── winring0
│       ├── COPYRIGHT.txt
│       ├── OlsApi.h
│       ├── OlsApiInit.h
│       ├── OlsApiInitDef.h
│       ├── OlsApiInitExt.h
│       └── OlsDef.h
└── tests
    ├── CMakeLists.txt
    ├── cache_verification_test.cpp
    ├── daemon_alignment_test.cpp
    ├── fuzz.sh
    ├── googletest
    ├── numa_test.cpp
    ├── numa_to_socket_test.cpp
    ├── pcm-fuzz.cpp
    ├── pcm-memory-fuzz.cpp
    ├── pcm-sensor-server-fuzz.cpp
    ├── test.sh
    ├── urltest-fuzz.cpp
    ├── urltest.cpp
    └── utests
        ├── CMakeLists.txt
        ├── lspci-utest.cpp
        ├── pcm-iio-utest.cpp
        └── read-number-utest.cpp

```

`CMakeLists.txt`:

```txt
# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2022-2025, Intel Corporation

cmake_minimum_required(VERSION 3.5)

project(PCM)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)


option(PCM_NO_ASAN "Disable address sanitizer" ON)
option(PCM_FUZZ "Enable fuzzing" OFF)
option(PCM_BUILD_EXECUTABLES "Build PCM utilities" ON)
option(PCM_NO_STATIC_LIBASAN "Disable static address sanitizer library" ON)

if(MSVC)
    option(PCM_NO_STATIC_MSVC_RUNTIME_LIBRARY "Disable using static runtime under MSVC" OFF)
endif()

foreach(opt NO_STATIC_MSVC_RUNTIME_LIBRARY;FUZZ;NO_ASAN;NO_STATIC_LIBASAN)
    if(${opt})
        message(DEPRECATION "Option \"${opt}\" is deprecated and will be removed soon. Please use \"PCM_${opt}\"")
        set(PCM_${opt} ${opt})
    endif()
endforeach()

include(GNUInstallDirs)

set(THREADS_PREFER_PTHREAD_FLAG ON)
find_package(Threads REQUIRED)

# Check for pcm*.x artifacts generated by an old build scenario using Makefiles
file(GLOB_RECURSE PCM_X_ARTIFACTS ${CMAKE_CURRENT_SOURCE_DIR}/*.x)
foreach(file ${PCM_X_ARTIFACTS})
    file(REMOVE ${file})
    message(STATUS "Removing old artifact from current source directory : ${file}")
endforeach()

if(PCM_X_ARTIFACTS)
    message(WARNING
	  " Old pcm utilities (.x) were indicated in build folder.\n"
          " Old binaries are expected to be installed in system.\n"
          " Make sure to install the new binaries(run 'cmake --install .') after building.)")
endif()

message(STATUS "System: ${CMAKE_SYSTEM}")
if(UNIX AND NOT APPLE)
    if(${CMAKE_SYSTEM_NAME} STREQUAL "FreeBSD")
        set(FREE_BSD TRUE)
    else()
        set(LINUX TRUE)
    endif()
endif()

if(UNIX)  # APPLE, LINUX, FREE_BSD
    if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
      set(CMAKE_BUILD_TYPE "Release" CACHE STRING "Build type (default Release)" FORCE)
    endif()
    message(STATUS "Build type: ${CMAKE_BUILD_TYPE}")

    message(STATUS "initial CMAKE_CXX_FLAGS: ${CMAKE_CXX_FLAGS}")
    message(STATUS "initial CMAKE_C_FLAGS: ${CMAKE_C_FLAGS}")

    # required PCM common flags
    set (PCM_COMMON_FLAGS "-Wno-unknown-pragmas -DCMAKE_INSTALL_PREFIX=\"${CMAKE_INSTALL_PREFIX}\"")

    if(LINUX)
       set (PCM_COMMON_FLAGS "${PCM_COMMON_FLAGS} -Wextra -DPCM_USE_PERF -fstack-protector-strong")
       if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU" OR "${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
         set (PCM_COMMON_FLAGS "${PCM_COMMON_FLAGS} -Wl,-z,now -Wl,-z,relro -Wl,-z,noexecstack")
       endif()

       if(NOT DEFINED LINUX_SYSTEMD)
         set(LINUX_SYSTEMD FALSE)
       endif()

       if(NOT DEFINED LINUX_SYSTEMD_UNITDIR)
         set(LINUX_SYSTEMD_UNITDIR "${CMAKE_INSTALL_LIBDIR}/systemd/system")
       endif()

       if(LINUX_SYSTEMD)
         message(STATUS "A systemd unit file will be generated")
         message(STATUS "LINUX_SYSTEMD_UNITDIR:${LINUX_SYSTEMD_UNITDIR}")
       else()
         message(STATUS "Set LINUX_SYSTEMD=TRUE for a systemd unit file.")
       endif()
    endif(LINUX)

    # adding the required PCM common flags
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${PCM_COMMON_FLAGS}")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${PCM_COMMON_FLAGS}")

    message(STATUS "CMAKE_CXX_FLAGS: ${CMAKE_CXX_FLAGS}")
    message(STATUS "CMAKE_C_FLAGS: ${CMAKE_C_FLAGS}")

    set(PCM_OPTIONAL_FLAGS "-Wall")
    if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
         set (PCM_DYNAMIC "-rdynamic")
    elseif()
         set (PCM_DYNAMIC "")
    endif()
    if(APPLE)
       set(PCM_NO_ASAN ON)
       message(STATUS "AddressSanitizer is currently disabled on MacOS")
    endif()
    if(PCM_NO_ASAN)
        message(STATUS "AddressSanitizer is disabled")
        set(PCM_ASAN "")
    else()
        message(STATUS "AddressSanitizer is enabled")
        message(STATUS "To disable AddressSanitizer, use -DPCM_NO_ASAN=1 option")
        set(PCM_ASAN "-fsanitize=address")
    endif()
    set(PCM_HARDENING_FLAGS "-fstack-protector -D_FORTIFY_SOURCE=2 -ftrapv ${PCM_ASAN} -fwrapv -fno-delete-null-pointer-checks -fno-strict-overflow -fno-omit-frame-pointer -mno-omit-leaf-frame-pointer")
    if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 5)
        message(WARNING "Old gcc compiler (version < 5), -fsanitize=undefined option is not supported.")
    elseif()
        set(PCM_HARDENING_FLAGS "${PCM_HARDENING_FLAGS} -fsanitize=undefined")
    endif()
    set(PCM_LINKER_HARDENING_FLAGS "${PCM_ASAN}")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${PCM_LINKER_HARDENING_FLAGS}")
    set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${PCM_LINKER_HARDENING_FLAGS}")
    set(CMAKE_CXX_FLAGS_RELEASE "${PCM_OPTIONAL_FLAGS} -O3 ${PCM_DYNAMIC} ${PCM_HARDENING_FLAGS}")
    set(CMAKE_CXX_FLAGS_DEBUG "${PCM_OPTIONAL_FLAGS} -O0 -g ${PCM_DYNAMIC} ${PCM_HARDENING_FLAGS}")
    set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${PCM_OPTIONAL_FLAGS} -O3 -g ${PCM_DYNAMIC} ${PCM_HARDENING_FLAGS}")
    if(FREE_BSD)
        set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -lexecinfo")
        set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -lexecinfo")
        set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -lexecinfo")
    endif(FREE_BSD)
    set(CMAKE_C_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}")
    set(CMAKE_C_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}")
    set(CMAKE_C_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO}")

    message(STATUS "CMAKE_CXX_FLAGS_RELEASE: ${CMAKE_CXX_FLAGS_RELEASE}")
    message(STATUS "CMAKE_CXX_FLAGS_DEBUG: ${CMAKE_CXX_FLAGS_DEBUG}")
    message(STATUS "CMAKE_CXX_FLAGS_RELWITHDEBINFO: ${CMAKE_CXX_FLAGS_RELWITHDEBINFO}")

    install(DIRECTORY "perfmon" DESTINATION ${CMAKE_INSTALL_DATADIR}/pcm)

endif(UNIX)

if(PCM_FUZZ)
    set(FUZZER_OPTIONS "-fsanitize=fuzzer,address -fprofile-instr-generate -fcoverage-mapping")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${FUZZER_OPTIONS}")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${FUZZER_OPTIONS}")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${FUZZER_OPTIONS}")
    message(STATUS "CMAKE_C_FLAGS: ${CMAKE_C_FLAGS}")
    message(STATUS "CMAKE_CXX_FLAGS: ${CMAKE_CXX_FLAGS}")
    message(STATUS "CMAKE_EXE_LINKER_FLAGS: ${CMAKE_EXE_LINKER_FLAGS}")
endif(PCM_FUZZ)

#######################
# pugixml dependency
#######################

add_library(PCM_PUGIXML INTERFACE) # interface library for pugixml
if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/src/pugixml/src/pugixml.cpp")
    message(STATUS "Local pugixml exists: ${CMAKE_CURRENT_SOURCE_DIR}/src/pugixml/src/pugixml.cpp")
    set(PCM_PUGIXML_CPP ${CMAKE_CURRENT_SOURCE_DIR}/src/pugixml/src/pugixml.cpp)
    add_compile_options(-DPCM_PUGIXML_AVAILABLE)
else()
    message(STATUS "Local pugixml doesn't exist")
#    message(WARNING
#        " ${CMAKE_CURRENT_SOURCE_DIR}/src/pugixml/src/pugixml.cpp doesn't exist\n"
#        " Use `git clone --recursive` flag when cloning pcm repository to clone pugixml submodule as well or\n"
#        " update submodule with command 'git submodule update --init --recursive' or\n"
#        " run 'git clone https//github.com/zeux/pugixml.git' in 'src' directory to get pugixml library")
endif()

#######################
# End of pugixml dependency section
#######################

#######################
# Install
#######################

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

add_subdirectory(src)
add_subdirectory(examples)
add_subdirectory(tests)

message(STATUS "Install directory: ${CMAKE_INSTALL_PREFIX}")

#######################
# CPack (only UNIX)
#######################
if(UNIX)
    if(EXISTS "/etc/debian_version")      # for Debian family
        set(CPACK_GENERATOR "DEB")
        message(STATUS "CPACK_GENERATOR is DEB")
    elseif(EXISTS "/etc/redhat-release")  # for RHEL, Fedora, CentOs
        set(CPACK_GENERATOR "RPM")
        message(STATUS "CPACK_GENERATOR is RPM")
    else()
        if(EXISTS "/etc/os-release")
            file(READ "/etc/os-release" OS_PARAMS)
            string(REGEX MATCH "suse" OUT ${OS_PARAMS})  # for Suse-like systems
            if(OUT STREQUAL "suse")
                 set(CPACK_GENERATOR "RPM")
                 message(STATUS "CPACK_GENERATOR is RPM")
            else()
                set(CPACK_GENERATOR "TXZ")
                set(CPACK_SET_DESTDIR ON)
                message(STATUS "CPACK_GENERATOR is TXZ")
            endif()
        else()
            set(CPACK_GENERATOR "TXZ")
            set(CPACK_SET_DESTDIR ON)
            message(STATUS "CPACK_GENERATOR is TXZ")
        endif()
    endif()

    set(CPACK_PACKAGE_CONTACT "intel <roman.dementiev@intel.com>")
    set(CPACK_PACKAGE_NAME    "pcm")
    set(CPACK_PACKAGE_VERSION "0000")

    set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "Intel(r) Performance Counter Monitor (Intel(r) PCM)")
    set(CPACK_PACKAGE_DESCRIPTION "\
    Intel(r) Performance Counter Monitor (Intel(r) PCM) is an application programming\n\
    interface (API) and a set of tools based on the API to monitor\n\
    performance and energy metrics of Intel(r) Core(tm), Xeon(r), Atom(tm)\n\
    and Xeon Phi(tm) processors. PCM works on Linux, Windows, Mac OS X,\n\
    FreeBSD and DragonFlyBSD operating systems.")
    set(CPACK_RPM_PACKAGE_DESCRIPTION ${CPACK_PACKAGE_DESCRIPTION})

    set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE")
    set(CPACK_RPM_PACKAGE_LICENSE   "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE")

    set(CPACK_PACKAGE_INSTALL_DIRECTORY             ${CMAKE_INSTALL_PREFIX})
    set(CPACK_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)

    set(CPACK_DEBIAN_PACKAGE_SHLIBDEPS ON)
    set(CPACK_RPM_PACKAGE_RELOCATABLE  TRUE)

    set(CPACK_DEB_COMPONENT_INSTALL ON)
    set(CPACK_RPM_COMPONENT_INSTALL ON)

    include (CPack)
endif(UNIX)

```

`CONTRIBUTING.md`:

```md
--------------------------------------------------------------------------------
Contributing to Intel&reg; Performance Counter Monitor (Intel&reg; PCM)
--------------------------------------------------------------------------------

We warmly welcome contributions from everyone. If you wish to submit patches, please do so using GitHub's pull request (PR) feature. When adding substantial new features, it's crucial to also include relevant tests in our test suite, located in the test/test.sh file. This step helps verify the proper functioning of the new features.

--------------------------------------------------------------------------------
License
--------------------------------------------------------------------------------

Intel&reg; PCM is licensed using a [BSD 3-clause license](https://github.com/intel/pcm/blob/master/LICENSE). All code submitted to the project is required to carry that license.

--------------------------------------------------------------------------------
Coding Style
--------------------------------------------------------------------------------

While we don't enforce stringent coding style requirements, we do encourage adherence to standard coding style practices, such as those outlined in the [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html). When submitting patches, we request that you maintain the style consistency with the surrounding code. We discourage the use of tabs; please use 4 spaces for indentation instead.

```

`Dockerfile`:

```
FROM fedora:43@sha256:6cd815d862109208adf6040ea13391fe6aeb87a9dc80735c2ab07083fdf5e03a AS builder
# Dockerfile for Intel PCM sensor server
# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2020-2024 Intel Corporation

RUN dnf -y install gcc-c++ git findutils make cmake openssl openssl-devel libasan libasan-static hwdata

COPY . /tmp/pcm
WORKDIR /tmp/pcm/build
RUN cmake -DPCM_NO_STATIC_LIBASAN=OFF .. && make -j

FROM fedora:43@sha256:6cd815d862109208adf6040ea13391fe6aeb87a9dc80735c2ab07083fdf5e03a

COPY --from=builder /tmp/pcm/build/bin/* /usr/local/bin/
COPY --from=builder /tmp/pcm/build/bin/opCode*.txt /usr/local/share/pcm/
COPY --from=builder /usr/share/hwdata/pci.ids /usr/share/hwdata/pci.ids
ENV PCM_NO_PERF=1

RUN useradd -m pcm-user

# Allow pcm-user to run the server via sudo without a password
RUN echo "pcm-user ALL=(root) NOPASSWD: /usr/local/bin/pcm-sensor-server" >> /etc/sudoers

USER pcm-user

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD sudo /usr/local/bin/pcm-sensor-server --help > /dev/null 2>&1 || exit 1

ENTRYPOINT [ "sudo", "/usr/local/bin/pcm-sensor-server", "-p", "9738", "-r" ]

```

`Doxyfile`:

```
# Doxyfile 1.4.6

# This file describes the settings to be used by the documentation system
# doxygen (www.doxygen.org) for a project
#
# All text after a hash (#) is considered a comment and will be ignored
# The format is:
#       TAG = value [value, ...]
# For lists items can also be appended using:
#       TAG += value [value, ...]
# Values that contain spaces should be placed between quotes (" ")

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------

# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
# by quotes) that should identify the project.

PROJECT_NAME           = "Intel(r) Performance Counter Monitor" 

# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
# This could be handy for archiving the generated documentation or 
# if some version control system is used.

PROJECT_NUMBER         = 

# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
# base path where the generated documentation will be put. 
# If a relative path is entered, it will be relative to the location 
# where doxygen was started. If left blank the current directory will be used.

OUTPUT_DIRECTORY       = 

# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
# 4096 sub-directories (in 2 levels) under the output directory of each output 
# format and will distribute the generated files over these directories. 
# Enabling this option can be useful when feeding doxygen a huge amount of 
# source files, where putting all generated files in the same directory would 
# otherwise cause performance problems for the file system.

CREATE_SUBDIRS         = NO

# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
# documentation generated by doxygen is written. Doxygen will use this 
# information to generate all constant output in the proper language. 
# The default language is English, other supported languages are: 
# Brazilian, Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, 
# Dutch, Finnish, French, German, Greek, Hungarian, Italian, Japanese, 
# Japanese-en (Japanese with English messages), Korean, Korean-en, Norwegian, 
# Polish, Portuguese, Romanian, Russian, Serbian, Slovak, Slovene, Spanish, 
# Swedish, and Ukrainian.

OUTPUT_LANGUAGE        = English

# This tag can be used to specify the encoding used in the generated output. 
# The encoding is not always determined by the language that is chosen, 
# but also whether or not the output is meant for Windows or non-Windows users. 
# In case there is a difference, setting the USE_WINDOWS_ENCODING tag to YES 
# forces the Windows encoding (this is the default for the Windows binary), 
# whereas setting the tag to NO uses a Unix-style encoding (the default for 
# all platforms other than Windows).

USE_WINDOWS_ENCODING   = NO

# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
# include brief member descriptions after the members that are listed in 
# the file and class documentation (similar to JavaDoc). 
# Set to NO to disable this.

BRIEF_MEMBER_DESC      = YES

# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
# the brief description of a member or function before the detailed description. 
# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
# brief descriptions will be completely suppressed.

REPEAT_BRIEF           = YES

# This tag implements a quasi-intelligent brief description abbreviator 
# that is used to form the text in various listings. Each string 
# in this list, if found as the leading text of the brief description, will be 
# stripped from the text and the result after processing the whole list, is 
# used as the annotated text. Otherwise, the brief description is used as-is. 
# If left blank, the following values are used ("$name" is automatically 
# replaced with the name of the entity): "The $name class" "The $name widget" 
# "The $name file" "is" "provides" "specifies" "contains" 
# "represents" "a" "an" "the"

ABBREVIATE_BRIEF       = 

# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
# Doxygen will generate a detailed section even if there is only a brief 
# description.

ALWAYS_DETAILED_SEC    = NO

# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
# inherited members of a class in the documentation of that class as if those 
# members were ordinary class members. Constructors, destructors and assignment 
# operators of the base classes will not be shown.

INLINE_INHERITED_MEMB  = NO

# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
# path before files name in the file list and in the header files. If set 
# to NO the shortest path that makes the file name unique will be used.

FULL_PATH_NAMES        = YES

# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
# can be used to strip a user-defined part of the path. Stripping is 
# only done if one of the specified strings matches the left-hand part of 
# the path. The tag can be used to show relative paths in the file list. 
# If left blank the directory from which doxygen is run is used as the 
# path to strip.

STRIP_FROM_PATH        = 

# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
# the path mentioned in the documentation of a class, which tells 
# the reader which header file to include in order to use a class. 
# If left blank only the name of the header file containing the class 
# definition is used. Otherwise one should specify the include paths that 
# are normally passed to the compiler using the -I flag.

STRIP_FROM_INC_PATH    = 

# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
# (but less readable) file names. This can be useful is your file systems 
# doesn't support long names like on DOS, Mac, or CD-ROM.

SHORT_NAMES            = NO

# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
# will interpret the first line (until the first dot) of a JavaDoc-style 
# comment as the brief description. If set to NO, the JavaDoc 
# comments will behave just like the Qt-style comments (thus requiring an 
# explicit @brief command for a brief description.

JAVADOC_AUTOBRIEF      = NO

# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
# comments) as a brief description. This used to be the default behaviour. 
# The new default is to treat a multi-line C++ comment block as a detailed 
# description. Set this tag to YES if you prefer the old behaviour instead.

MULTILINE_CPP_IS_BRIEF = NO

# If the DETAILS_AT_TOP tag is set to YES then Doxygen 
# will output the detailed description near the top, like JavaDoc.
# If set to NO, the detailed description appears after the member 
# documentation.

DETAILS_AT_TOP         = NO

# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
# member inherits the documentation from any documented member that it 
# re-implements.

INHERIT_DOCS           = YES

# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce 
# a new page for each member. If set to NO, the documentation of a member will 
# be part of the file/class/namespace that contains it.

SEPARATE_MEMBER_PAGES  = NO

# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
# Doxygen uses this value to replace tabs by spaces in code fragments.

TAB_SIZE               = 4 

# This tag can be used to specify a number of aliases that acts 
# as commands in the documentation. An alias has the form "name=value". 
# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
# put the command \sideeffect (or @sideeffect) in the documentation, which 
# will result in a user-defined paragraph with heading "Side Effects:". 
# You can put \n's in the value part of an alias to insert newlines.

ALIASES                = 

# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
# sources only. Doxygen will then generate output that is more tailored for C. 
# For instance, some of the names that are used will be different. The list 
# of all members will be omitted, etc.

OPTIMIZE_OUTPUT_FOR_C  = NO

# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java 
# sources only. Doxygen will then generate output that is more tailored for Java. 
# For instance, namespaces will be presented as packages, qualified scopes 
# will look different, etc.

OPTIMIZE_OUTPUT_JAVA   = NO

# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want to 
# include (a tag file for) the STL sources as input, then you should 
# set this tag to YES in order to let doxygen match functions declarations and 
# definitions whose arguments contain STL classes (e.g. func(std::string); v.s. 
# func(std::string) {}). This also make the inheritance and collaboration 
# diagrams that involve STL classes more complete and accurate.

BUILTIN_STL_SUPPORT    = NO

# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
# tag is set to YES, then doxygen will reuse the documentation of the first 
# member in the group (if any) for the other members of the group. By default 
# all members of a group must be documented explicitly.

DISTRIBUTE_GROUP_DOC   = NO

# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
# the same type (for instance a group of public functions) to be put as a 
# subgroup of that type (e.g. under the Public Functions section). Set it to 
# NO to prevent subgrouping. Alternatively, this can be done per class using 
# the \nosubgrouping command.

SUBGROUPING            = YES

#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------

# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
# documentation are documented, even if no documentation was available. 
# Private class members and static file members will be hidden unless 
# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES

EXTRACT_ALL            = NO

# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
# will be included in the documentation.

EXTRACT_PRIVATE        = NO

# If the EXTRACT_STATIC tag is set to YES all static members of a file 
# will be included in the documentation.

EXTRACT_STATIC         = NO

# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
# defined locally in source files will be included in the documentation. 
# If set to NO only classes defined in header files are included.

EXTRACT_LOCAL_CLASSES  = YES

# This flag is only useful for Objective-C code. When set to YES local 
# methods, which are defined in the implementation section but not in 
# the interface are included in the documentation. 
# If set to NO (the default) only methods in the interface are included.

EXTRACT_LOCAL_METHODS  = NO

# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
# undocumented members of documented classes, files or namespaces. 
# If set to NO (the default) these members will be included in the 
# various overviews, but no documentation section is generated. 
# This option has no effect if EXTRACT_ALL is enabled.

HIDE_UNDOC_MEMBERS     = NO

# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
# undocumented classes that are normally visible in the class hierarchy. 
# If set to NO (the default) these classes will be included in the various 
# overviews. This option has no effect if EXTRACT_ALL is enabled.

HIDE_UNDOC_CLASSES     = NO

# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
# friend (class|struct|union) declarations. 
# If set to NO (the default) these declarations will be included in the 
# documentation.

HIDE_FRIEND_COMPOUNDS  = NO

# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
# documentation blocks found inside the body of a function. 
# If set to NO (the default) these blocks will be appended to the 
# function's detailed documentation block.

HIDE_IN_BODY_DOCS      = NO

# The INTERNAL_DOCS tag determines if documentation 
# that is typed after a \internal command is included. If the tag is set 
# to NO (the default) then the documentation will be excluded. 
# Set it to YES to include the internal documentation.

INTERNAL_DOCS          = NO

# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
# file names in lower-case letters. If set to YES upper-case letters are also 
# allowed. This is useful if you have classes or files whose names only differ 
# in case and if your file system supports case sensitive file names. Windows 
# and Mac users are advised to set this option to NO.

CASE_SENSE_NAMES       = YES

# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
# will show members with their full class and namespace scopes in the 
# documentation. If set to YES the scope will be hidden.

HIDE_SCOPE_NAMES       = NO

# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
# will put a list of the files that are included by a file in the documentation 
# of that file.

SHOW_INCLUDE_FILES     = YES

# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
# is inserted in the documentation for inline members.

INLINE_INFO            = YES

# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
# will sort the (detailed) documentation of file and class members 
# alphabetically by member name. If set to NO the members will appear in 
# declaration order.

SORT_MEMBER_DOCS       = YES

# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
# brief documentation of file, namespace and class members alphabetically 
# by member name. If set to NO (the default) the members will appear in 
# declaration order.

SORT_BRIEF_DOCS        = NO

# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
# sorted by fully-qualified names, including namespaces. If set to 
# NO (the default), the class list will be sorted only by class name, 
# not including the namespace part. 
# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
# Note: This option applies only to the class list, not to the 
# alphabetical list.

SORT_BY_SCOPE_NAME     = NO

# The GENERATE_TODOLIST tag can be used to enable (YES) or 
# disable (NO) the todo list. This list is created by putting \todo 
# commands in the documentation.

GENERATE_TODOLIST      = YES

# The GENERATE_TESTLIST tag can be used to enable (YES) or 
# disable (NO) the test list. This list is created by putting \test 
# commands in the documentation.

GENERATE_TESTLIST      = YES

# The GENERATE_BUGLIST tag can be used to enable (YES) or 
# disable (NO) the bug list. This list is created by putting \bug 
# commands in the documentation.

GENERATE_BUGLIST       = YES

# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
# disable (NO) the deprecated list. This list is created by putting 
# \deprecated commands in the documentation.

GENERATE_DEPRECATEDLIST= YES

# The ENABLED_SECTIONS tag can be used to enable conditional 
# documentation sections, marked by \if sectionname ... \endif.

ENABLED_SECTIONS       = 

# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
# the initial value of a variable or define consists of for it to appear in 
# the documentation. If the initializer consists of more lines than specified 
# here it will be hidden. Use a value of 0 to hide initializers completely. 
# The appearance of the initializer of individual variables and defines in the 
# documentation can be controlled using \showinitializer or \hideinitializer 
# command in the documentation regardless of this setting.

MAX_INITIALIZER_LINES  = 30

# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
# at the bottom of the documentation of classes and structs. If set to YES the 
# list will mention the files that were used to generate the documentation.

SHOW_USED_FILES        = YES

# If the sources in your project are distributed over multiple directories 
# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
# in the documentation. The default is NO.

SHOW_DIRECTORIES       = NO

# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
# doxygen should invoke to get the current version for each file (typically from the 
# version control system). Doxygen will invoke the program by executing (via 
# popen()) the command <command> <input-file>, where <command> is the value of 
# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
# provided by doxygen. Whatever the program writes to standard output 
# is used as the file version. See the manual for examples.

FILE_VERSION_FILTER    = 

#---------------------------------------------------------------------------
# configuration options related to warning and progress messages
#---------------------------------------------------------------------------

# The QUIET tag can be used to turn on/off the messages that are generated 
# by doxygen. Possible values are YES and NO. If left blank NO is used.

QUIET                  = NO

# The WARNINGS tag can be used to turn on/off the warning messages that are 
# generated by doxygen. Possible values are YES and NO. If left blank 
# NO is used.

WARNINGS               = YES

# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
# automatically be disabled.

WARN_IF_UNDOCUMENTED   = YES

# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
# potential errors in the documentation, such as not documenting some 
# parameters in a documented function, or documenting parameters that 
# don't exist or using markup commands wrongly.

WARN_IF_DOC_ERROR      = YES

# This WARN_NO_PARAMDOC option can be abled to get warnings for 
# functions that are documented, but have no documentation for their parameters 
# or return value. If set to NO (the default) doxygen will only warn about 
# wrong or incomplete parameter documentation, but not about the absence of 
# documentation.

WARN_NO_PARAMDOC       = NO

# The WARN_FORMAT tag determines the format of the warning messages that 
# doxygen can produce. The string should contain the $file, $line, and $text 
# tags, which will be replaced by the file and line number from which the 
# warning originated and the warning text. Optionally the format may contain 
# $version, which will be replaced by the version of the file (if it could 
# be obtained via FILE_VERSION_FILTER)

WARN_FORMAT            = "$file:$line: $text"

# The WARN_LOGFILE tag can be used to specify a file to which warning 
# and error messages should be written. If left blank the output is written 
# to stderr.

WARN_LOGFILE           = 

#---------------------------------------------------------------------------
# configuration options related to the input files
#---------------------------------------------------------------------------

# The INPUT tag can be used to specify the files and/or directories that contain 
# documented source files. You may enter file names like "myfile.cpp" or 
# directories like "/usr/src/myproject". Separate the files or directories 
# with spaces.

# INPUT                  = src

# If the value of the INPUT tag contains directories, you can use the 
# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
# and *.h) to filter out the source-files in the directories. If left 
# blank the following patterns are tested: 
# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx 
# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py

FILE_PATTERNS          = *.hpp *.h *.cpp *.c

# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
# should be searched for input files as well. Possible values are YES and NO. 
# If left blank NO is used.

RECURSIVE              = YES

# The EXCLUDE tag can be used to specify files and/or directories that should 
# excluded from the INPUT source files. This way you can easily exclude a 
# subdirectory from a directory tree whose root is specified with the INPUT tag.

EXCLUDE                = 

# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
# directories that are symbolic links (a Unix filesystem feature) are excluded 
# from the input.

EXCLUDE_SYMLINKS       = NO

# If the value of the INPUT tag contains directories, you can use the 
# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
# certain files from those directories. Note that the wildcards are matched 
# against the file with absolute path, so to exclude all test directories 
# for example use the pattern */test/*

EXCLUDE_PATTERNS       = 

# The EXAMPLE_PATH tag can be used to specify one or more files or 
# directories that contain example code fragments that are included (see 
# the \include command).

EXAMPLE_PATH           = 

# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
# and *.h) to filter out the source-files in the directories. If left 
# blank all files are included.

EXAMPLE_PATTERNS       = 

# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
# searched for input files to be used with the \include or \dontinclude 
# commands irrespective of the value of the RECURSIVE tag. 
# Possible values are YES and NO. If left blank NO is used.

EXAMPLE_RECURSIVE      = NO

# The IMAGE_PATH tag can be used to specify one or more files or 
# directories that contain image that are included in the documentation (see 
# the \image command).

IMAGE_PATH             = 

# The INPUT_FILTER tag can be used to specify a program that doxygen should 
# invoke to filter for each input file. Doxygen will invoke the filter program 
# by executing (via popen()) the command <filter> <input-file>, where <filter> 
# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
# input file. Doxygen will then use the output that the filter program writes 
# to standard output.  If FILTER_PATTERNS is specified, this tag will be 
# ignored.

INPUT_FILTER           = 

# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
# basis.  Doxygen will compare the file name with each pattern and apply the 
# filter if there is a match.  The filters are a list of the form: 
# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER 
# is applied to all files.

FILTER_PATTERNS        = 

# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
# INPUT_FILTER) will be used to filter the input files when producing source 
# files to browse (i.e. when SOURCE_BROWSER is set to YES).

FILTER_SOURCE_FILES    = NO

#---------------------------------------------------------------------------
# configuration options related to source browsing
#---------------------------------------------------------------------------

# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
# be generated. Documented entities will be cross-referenced with these sources. 
# Note: To get rid of all source code in the generated output, make sure also 
# VERBATIM_HEADERS is set to NO.

SOURCE_BROWSER         = NO

# Setting the INLINE_SOURCES tag to YES will include the body 
# of functions and classes directly in the documentation.

INLINE_SOURCES         = NO

# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
# doxygen to hide any special comment blocks from generated source code 
# fragments. Normal C and C++ comments will always remain visible.

STRIP_CODE_COMMENTS    = YES

# If the REFERENCED_BY_RELATION tag is set to YES (the default) 
# then for each documented function all documented 
# functions referencing it will be listed.

REFERENCED_BY_RELATION = YES

# If the REFERENCES_RELATION tag is set to YES (the default) 
# then for each documented function all documented entities 
# called/used by that function will be listed.

REFERENCES_RELATION    = YES

# If the USE_HTAGS tag is set to YES then the references to source code 
# will point to the HTML generated by the htags(1) tool instead of doxygen 
# built-in source browser. The htags tool is part of GNU's global source 
# tagging system (see http://www.gnu.org/software/global/global.html). You 
# will need version 4.8.6 or higher.

USE_HTAGS              = NO

# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
# will generate a verbatim copy of the header file for each class for 
# which an include is specified. Set to NO to disable this.

VERBATIM_HEADERS       = YES

#---------------------------------------------------------------------------
# configuration options related to the alphabetical class index
#---------------------------------------------------------------------------

# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
# of all compounds will be generated. Enable this if the project 
# contains a lot of classes, structs, unions or interfaces.

ALPHABETICAL_INDEX     = NO

# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
# in which this list will be split (can be a number in the range [1..20])

COLS_IN_ALPHA_INDEX    = 5

# In case all classes in a project start with a common prefix, all 
# classes will be put under the same header in the alphabetical index. 
# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
# should be ignored while generating the index headers.

IGNORE_PREFIX          = 

#---------------------------------------------------------------------------
# configuration options related to the HTML output
#---------------------------------------------------------------------------

# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
# generate HTML output.

GENERATE_HTML          = YES

# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
# put in front of it. If left blank `html' will be used as the default path.

HTML_OUTPUT            = html

# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
# doxygen will generate files with .html extension.

HTML_FILE_EXTENSION    = .html

# The HTML_HEADER tag can be used to specify a personal HTML header for 
# each generated HTML page. If it is left blank doxygen will generate a 
# standard header.

HTML_HEADER            = 

# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
# each generated HTML page. If it is left blank doxygen will generate a 
# standard footer.

HTML_FOOTER            = 

# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
# style sheet that is used by each HTML page. It can be used to 
# fine-tune the look of the HTML output. If the tag is left blank doxygen 
# will generate a default style sheet. Note that doxygen will try to copy 
# the style sheet file to the HTML output directory, so don't put your own 
# stylesheet in the HTML output directory as well, or it will be erased!

HTML_STYLESHEET        = 

# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
# files or namespaces will be aligned in HTML using tables. If set to 
# NO a bullet list will be used.

HTML_ALIGN_MEMBERS     = YES

# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
# will be generated that can be used as input for tools like the 
# Microsoft HTML help workshop to generate a compressed HTML help file (.chm) 
# of the generated HTML documentation.

GENERATE_HTMLHELP      = NO

# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
# be used to specify the file name of the resulting .chm file. You 
# can add a path in front of the file if the result should not be 
# written to the html output directory.

CHM_FILE               = 

# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
# be used to specify the location (absolute path including file name) of 
# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
# the HTML help compiler on the generated index.hhp.

HHC_LOCATION           = 

# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
# controls if a separate .chi index file is generated (YES) or that 
# it should be included in the master .chm file (NO).

GENERATE_CHI           = NO

# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
# controls whether a binary table of contents is generated (YES) or a 
# normal table of contents (NO) in the .chm file.

BINARY_TOC             = NO

# The TOC_EXPAND flag can be set to YES to add extra items for group members 
# to the contents of the HTML help documentation and to the tree view.

TOC_EXPAND             = NO

# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
# top of each HTML page. The value NO (the default) enables the index and 
# the value YES disables it.

DISABLE_INDEX          = NO

# This tag can be used to set the number of enum values (range [1..20]) 
# that doxygen will group on one line in the generated HTML documentation.

ENUM_VALUES_PER_LINE   = 4

# If the GENERATE_TREEVIEW tag is set to YES, a side panel will be
# generated containing a tree-like index structure (just like the one that 
# is generated for HTML Help). For this to work a browser that supports 
# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+, 
# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are 
# probably better off using the HTML help feature.

GENERATE_TREEVIEW      = NO

# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
# used to set the initial width (in pixels) of the frame in which the tree 
# is shown.

TREEVIEW_WIDTH         = 250

#---------------------------------------------------------------------------
# configuration options related to the LaTeX output
#---------------------------------------------------------------------------

# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
# generate Latex output.

GENERATE_LATEX         = YES

# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
# put in front of it. If left blank `latex' will be used as the default path.

LATEX_OUTPUT           = latex

# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
# invoked. If left blank `latex' will be used as the default command name.

LATEX_CMD_NAME         = latex

# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
# generate index for LaTeX. If left blank `makeindex' will be used as the 
# default command name.

MAKEINDEX_CMD_NAME     = makeindex

# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
# LaTeX documents. This may be useful for small projects and may help to 
# save some trees in general.

COMPACT_LATEX          = NO

# The PAPER_TYPE tag can be used to set the paper type that is used 
# by the printer. Possible values are: a4, a4wide, letter, legal and 
# executive. If left blank a4wide will be used.

PAPER_TYPE             = a4wide

# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
# packages that should be included in the LaTeX output.

EXTRA_PACKAGES         = 

# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
# the generated latex document. The header should contain everything until 
# the first chapter. If it is left blank doxygen will generate a 
# standard header. Notice: only use this tag if you know what you are doing!

LATEX_HEADER           = 

# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
# contain links (just like the HTML output) instead of page references 
# This makes the output suitable for online browsing using a pdf viewer.

PDF_HYPERLINKS         = NO

# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
# plain latex in the generated Makefile. Set this option to YES to get a 
# higher quality PDF documentation.

USE_PDFLATEX           = NO

# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
# command to the generated LaTeX files. This will instruct LaTeX to keep 
# running if errors occur, instead of asking the user for help. 
# This option is also used when generating formulas in HTML.

LATEX_BATCHMODE        = NO

# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
# include the index chapters (such as File Index, Compound Index, etc.) 
# in the output.

LATEX_HIDE_INDICES     = NO

#---------------------------------------------------------------------------
# configuration options related to the RTF output
#---------------------------------------------------------------------------

# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
# The RTF output is optimized for Word 97 and may not look very pretty with 
# other RTF readers or editors.

GENERATE_RTF           = NO

# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
# put in front of it. If left blank `rtf' will be used as the default path.

RTF_OUTPUT             = rtf

# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
# RTF documents. This may be useful for small projects and may help to 
# save some trees in general.

COMPACT_RTF            = NO

# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
# will contain hyperlink fields. The RTF file will 
# contain links (just like the HTML output) instead of page references. 
# This makes the output suitable for online browsing using WORD or other 
# programs which support those fields. 
# Note: wordpad (write) and others do not support links.

RTF_HYPERLINKS         = NO

# Load stylesheet definitions from file. Syntax is similar to doxygen's 
# config file, i.e. a series of assignments. You only have to provide 
# replacements, missing definitions are set to their default value.

RTF_STYLESHEET_FILE    = 

# Set optional variables used in the generation of an rtf document. 
# Syntax is similar to doxygen's config file.

RTF_EXTENSIONS_FILE    = 

#---------------------------------------------------------------------------
# configuration options related to the man page output
#---------------------------------------------------------------------------

# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
# generate man pages

GENERATE_MAN           = NO

# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
# put in front of it. If left blank `man' will be used as the default path.

MAN_OUTPUT             = man

# The MAN_EXTENSION tag determines the extension that is added to 
# the generated man pages (default is the subroutine's section .3)

MAN_EXTENSION          = .3

# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
# then it will generate one additional man file for each entity 
# documented in the real man page(s). These additional files 
# only source the real man page, but without them the man command 
# would be unable to find the correct page. The default is NO.

MAN_LINKS              = NO

#---------------------------------------------------------------------------
# configuration options related to the XML output
#---------------------------------------------------------------------------

# If the GENERATE_XML tag is set to YES Doxygen will 
# generate an XML file that captures the structure of 
# the code including all documentation.

GENERATE_XML           = NO

# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
# put in front of it. If left blank `xml' will be used as the default path.

XML_OUTPUT             = xml

# The XML_SCHEMA tag can be used to specify an XML schema, 
# which can be used by a validating XML parser to check the 
# syntax of the XML files.

XML_SCHEMA             = 

# The XML_DTD tag can be used to specify an XML DTD, 
# which can be used by a validating XML parser to check the 
# syntax of the XML files.

XML_DTD                = 

# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
# dump the program listings (including syntax highlighting 
# and cross-referencing information) to the XML output. Note that 
# enabling this will significantly increase the size of the XML output.

XML_PROGRAMLISTING     = YES

#---------------------------------------------------------------------------
# configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------

# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
# generate an AutoGen Definitions (see autogen.sf.net) file 
# that captures the structure of the code including all 
# documentation. Note that this feature is still experimental 
# and incomplete at the moment.

GENERATE_AUTOGEN_DEF   = NO

#---------------------------------------------------------------------------
# configuration options related to the Perl module output
#---------------------------------------------------------------------------

# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
# generate a Perl module file that captures the structure of 
# the code including all documentation. Note that this 
# feature is still experimental and incomplete at the 
# moment.

GENERATE_PERLMOD       = NO

# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
# to generate PDF and DVI output from the Perl module output.

PERLMOD_LATEX          = NO

# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
# nicely formatted so it can be parsed by a human reader.  This is useful 
# if you want to understand what is going on.  On the other hand, if this 
# tag is set to NO the size of the Perl module output will be much smaller 
# and Perl will parse it just the same.

PERLMOD_PRETTY         = YES

# The names of the make variables in the generated doxyrules.make file 
# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
# This is useful so different doxyrules.make files included by the same 
# Makefile don't overwrite each other's variables.

PERLMOD_MAKEVAR_PREFIX = 

#---------------------------------------------------------------------------
# Configuration options related to the preprocessor   
#---------------------------------------------------------------------------

# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
# evaluate all C-preprocessor directives found in the sources and include 
# files.

ENABLE_PREPROCESSING   = YES

# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
# names in the source code. If set to NO (the default) only conditional 
# compilation will be performed. Macro expansion can be done in a controlled 
# way by setting EXPAND_ONLY_PREDEF to YES.

MACRO_EXPANSION        = NO

# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
# then the macro expansion is limited to the macros specified with the 
# PREDEFINED and EXPAND_AS_DEFINED tags.

EXPAND_ONLY_PREDEF     = NO

# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
# in the INCLUDE_PATH (see below) will be search if a #include is found.

SEARCH_INCLUDES        = YES

# The INCLUDE_PATH tag can be used to specify one or more directories that 
# contain include files that are not input files but should be processed by 
# the preprocessor.

INCLUDE_PATH           = 

# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
# patterns (like *.h and *.hpp) to filter out the header-files in the 
# directories. If left blank, the patterns specified with FILE_PATTERNS will 
# be used.

INCLUDE_FILE_PATTERNS  = 

# The PREDEFINED tag can be used to specify one or more macro names that 
# are defined before the preprocessor is started (similar to the -D option of 
# gcc). The argument of the tag is a list of macros of the form: name 
# or name=definition (no spaces). If the definition and the = are 
# omitted =1 is assumed. To prevent a macro definition from being 
# undefined via #undef or recursively expanded use the := operator 
# instead of the = operator.

PREDEFINED             = 

# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
# this tag can be used to specify a list of macro names that should be expanded. 
# The macro definition that is found in the sources will be used. 
# Use the PREDEFINED tag if you want to use a different macro definition.

EXPAND_AS_DEFINED      = 

# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
# doxygen's preprocessor will remove all function-like macros that are alone 
# on a line, have an all uppercase name, and do not end with a semicolon. Such 
# function macros are typically used for boiler-plate code, and will confuse 
# the parser if not removed.

SKIP_FUNCTION_MACROS   = YES

#---------------------------------------------------------------------------
# Configuration::additions related to external references   
#---------------------------------------------------------------------------

# The TAGFILES option can be used to specify one or more tagfiles. 
# Optionally an initial location of the external documentation 
# can be added for each tagfile. The format of a tag file without 
# this location is as follows: 
#   TAGFILES = file1 file2 ... 
# Adding location for the tag files is done as follows: 
#   TAGFILES = file1=loc1 "file2 = loc2" ... 
# where "loc1" and "loc2" can be relative or absolute paths or 
# URLs. If a location is present for each tag, the installdox tool 
# does not have to be run to correct the links.
# Note that each tag file must have a unique name
# (where the name does NOT include the path)
# If a tag file is not located in the directory in which doxygen 
# is run, you must also specify the path to the tagfile here.

TAGFILES               = 

# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
# a tag file that is based on the input files it reads.

GENERATE_TAGFILE       = 

# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
# in the class index. If set to NO only the inherited external classes 
# will be listed.

ALLEXTERNALS           = NO

# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
# in the modules index. If set to NO, only the current project's groups will 
# be listed.

EXTERNAL_GROUPS        = YES

# The PERL_PATH should be the absolute path and name of the perl script 
# interpreter (i.e. the result of `which perl').

PERL_PATH              = /usr/bin/perl

#---------------------------------------------------------------------------
# Configuration options related to the dot tool   
#---------------------------------------------------------------------------

# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
# or super classes. Setting the tag to NO turns the diagrams off. Note that 
# this option is superseded by the HAVE_DOT option below. This is only a 
# fallback. It is recommended to install and use dot, since it yields more 
# powerful graphs.

CLASS_DIAGRAMS         = YES

# If set to YES, the inheritance and collaboration graphs will hide 
# inheritance and usage relations if the target is undocumented 
# or is not a class.

HIDE_UNDOC_RELATIONS   = YES

# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
# available from the path. This tool is part of Graphviz, a graph visualization 
# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
# have no effect if this option is set to NO (the default)

HAVE_DOT               = NO

# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
# will generate a graph for each documented class showing the direct and 
# indirect inheritance relations. Setting this tag to YES will force the 
# the CLASS_DIAGRAMS tag to NO.

CLASS_GRAPH            = YES

# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
# will generate a graph for each documented class showing the direct and 
# indirect implementation dependencies (inheritance, containment, and 
# class references variables) of the class with other documented classes.

COLLABORATION_GRAPH    = YES

# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
# will generate a graph for groups, showing the direct groups dependencies

GROUP_GRAPHS           = YES

# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
# collaboration diagrams in a style similar to the OMG's Unified Modeling 
# Language.

UML_LOOK               = NO

# If set to YES, the inheritance and collaboration graphs will show the 
# relations between templates and their instances.

TEMPLATE_RELATIONS     = NO

# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
# tags are set to YES then doxygen will generate a graph for each documented 
# file showing the direct and indirect include dependencies of the file with 
# other documented files.

INCLUDE_GRAPH          = YES

# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
# documented header file showing the documented files that directly or 
# indirectly include this file.

INCLUDED_BY_GRAPH      = YES

# If the CALL_GRAPH and HAVE_DOT tags are set to YES then doxygen will 
# generate a call dependency graph for every global function or class method. 
# Note that enabling this option will significantly increase the time of a run. 
# So in most cases it will be better to enable call graphs for selected 
# functions only using the \callgraph command.

CALL_GRAPH             = NO

# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
# will graphical hierarchy of all classes instead of a textual one.

GRAPHICAL_HIERARCHY    = YES

# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
# then doxygen will show the dependencies a directory has on other directories 
# in a graphical way. The dependency relations are determined by the #include
# relations between the files in the directories.

DIRECTORY_GRAPH        = YES

# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
# generated by dot. Possible values are png, jpg, or gif
# If left blank png will be used.

DOT_IMAGE_FORMAT       = png

# The tag DOT_PATH can be used to specify the path where the dot tool can be 
# found. If left blank, it is assumed the dot tool can be found in the path.

DOT_PATH               = 

# The DOTFILE_DIRS tag can be used to specify one or more directories that 
# contain dot files that are included in the documentation (see the 
# \dotfile command).

DOTFILE_DIRS           = 

# The MAX_DOT_GRAPH_WIDTH tag can be used to set the maximum allowed width 
# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
# this value, doxygen will try to truncate the graph, so that it fits within 
# the specified constraint. Beware that most browsers cannot cope with very 
# large images.

MAX_DOT_GRAPH_WIDTH    = 1024

# The MAX_DOT_GRAPH_HEIGHT tag can be used to set the maximum allows height 
# (in pixels) of the graphs generated by dot. If a graph becomes larger than 
# this value, doxygen will try to truncate the graph, so that it fits within 
# the specified constraint. Beware that most browsers cannot cope with very 
# large images.

MAX_DOT_GRAPH_HEIGHT   = 1024

# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
# graphs generated by dot. A depth value of 3 means that only nodes reachable 
# from the root by following a path via at most 3 edges will be shown. Nodes 
# that lay further from the root node will be omitted. Note that setting this 
# option to 1 or 2 may greatly reduce the computation time needed for large 
# code bases. Also note that a graph may be further truncated if the graph's 
# image dimensions are not sufficient to fit the graph (see MAX_DOT_GRAPH_WIDTH 
# and MAX_DOT_GRAPH_HEIGHT). If 0 is used for the depth value (the default), 
# the graph is not depth-constrained.

MAX_DOT_GRAPH_DEPTH    = 0

# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
# background. This is disabled by default, which results in a white background. 
# Warning: Depending on the platform used, enabling this option may lead to 
# badly anti-aliased labels on the edges of a graph (i.e. they become hard to 
# read).

DOT_TRANSPARENT        = NO

# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
# files in one run (i.e. multiple -o and -T options on the command line). This 
# makes dot run faster, but since only newer versions of dot (>1.8.10) 
# support this, this feature is disabled by default.

DOT_MULTI_TARGETS      = NO

# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
# generate a legend page explaining the meaning of the various boxes and 
# arrows in the dot generated graphs.

GENERATE_LEGEND        = YES

# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
# remove the intermediate dot files that are used to generate 
# the various graphs.

DOT_CLEANUP            = YES

#---------------------------------------------------------------------------
# Configuration::additions related to the search engine   
#---------------------------------------------------------------------------

# The SEARCHENGINE tag specifies whether or not a search engine should be 
# used. If set to NO the values of all tags below this one will be ignored.

SEARCHENGINE           = NO

```

`LICENSE`:

```
BSD 3-Clause License

Copyright (c) 2009-2024, Intel Corporation
Copyright (c) 2016-2020, opcm
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
--------------------------------------------------------------------------------
Intel&reg; Performance Counter Monitor (Intel&reg; PCM)
--------------------------------------------------------------------------------

[![CodeQL](https://github.com/intel/pcm/actions/workflows/codeql.yml/badge.svg?branch=master)](https://github.com/intel/pcm/security/code-scanning/tools/CodeQL/status)
[![OpenSSF Scorecard](https://api.securityscorecards.dev/projects/github.com/intel/pcm/badge)](https://securityscorecards.dev/viewer/?uri=github.com/intel/pcm)
[![OpenSSF Best Practices](https://www.bestpractices.dev/projects/8652/badge)](https://www.bestpractices.dev/projects/8652)

[PCM Tools](#pcm-tools) | [Building PCM](#building-pcm-tools) | [Downloading Pre-Compiled PCM](#downloading-pre-compiled-pcm-tools) | [FAQ](#frequently-asked-questions-faq) | [API Documentation](#pcm-api-documentation) | [Environment Variables](#pcm-environment-variables) | [Compilation Options](#custom-compilation-options)

Intel&reg; Performance Counter Monitor (Intel&reg; PCM) is an application programming interface (API) and a set of tools based on the API to monitor performance and energy metrics of Intel&reg; Core&trade;, Xeon&reg;, Atom&trade; and Xeon Phi&trade; processors. PCM works on Linux, Windows, Mac OS X, FreeBSD, DragonFlyBSD and ChromeOS operating systems.

*Github repository statistics:* ![Custom badge](https://img.shields.io/endpoint?url=https%3A%2F%2Fhetthbszh0.execute-api.us-east-2.amazonaws.com%2Fdefault%2Fpcm-clones) ![Custom badge](https://img.shields.io/endpoint?url=https%3A%2F%2F5urjfrshcd.execute-api.us-east-2.amazonaws.com%2Fdefault%2Fpcm-yesterday-clones) ![Custom badge](https://img.shields.io/endpoint?url=https%3A%2F%2Fcsqqh18g3l.execute-api.us-east-2.amazonaws.com%2Fdefault%2Fpcm-today-clones)

We welcome bug reports and enhancement requests, which can be submitted via the "Issues" section on GitHub. For those interested in contributing to the code, please refer to the guidelines outlined in the CONTRIBUTING.md file.

--------------------------------------------------------------------------------
Current Build Status
--------------------------------------------------------------------------------

- Linux: [![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/intel/pcm/linux_make.yml?branch=master)](https://github.com/intel/pcm/actions/workflows/linux_make.yml?query=branch%3Amaster)
- Windows: [![Build status](https://ci.appveyor.com/api/projects/status/github/intel/pcm?branch=master&svg=true)](https://ci.appveyor.com/project/opcm/pcm)
- FreeBSD: [![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/intel/pcm/freebsd_build.yml?branch=master)](https://github.com/intel/pcm/actions/workflows/freebsd_build.yml?query=branch%3Amaster)
- OS X: [![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/intel/pcm/macosx_build.yml?branch=master)](https://github.com/intel/pcm/actions/workflows/macosx_build.yml?query=branch%3Amaster)
- Docker container: [![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/intel/pcm/docker.yml?branch=master)](doc/DOCKER_README.md)

--------------------------------------------------------------------------------
PCM Tools
--------------------------------------------------------------------------------

PCM provides a number of command-line utilities for real-time monitoring:

- **pcm** : basic processor monitoring utility (instructions per cycle, core frequency (including Intel(r) Turbo Boost Technology), memory and Intel(r) Quick Path Interconnect bandwidth, local and remote memory bandwidth, cache misses, core and CPU package sleep C-state residency, core and CPU package thermal headroom, cache utilization, CPU and memory energy consumption)

![pcm output](https://github.com/intel/pcm/assets/25432609/88485ff5-dc7c-4a1c-974f-8396f03829dc)

- **pcm-sensor-server** : pcm collector exposing metrics over http in JSON or Prometheus (exporter text based) format ([how-to](doc/PCM-EXPORTER.md)). Also available as a [docker container](doc/DOCKER_README.md). More info about Global PCM events is [here](doc/PCM-SENSOR-SERVER-README.md).
- **pcm-memory** : monitor memory bandwidth (per-channel and per-DRAM DIMM rank)
![pcm-memory output](https://raw.githubusercontent.com/wiki/intel/pcm/pcm-memory.x.JPG)
- **pcm-accel** : [monitor Intel® In-Memory Analytics Accelerator (Intel® IAA), Intel® Data Streaming Accelerator (Intel® DSA) and Intel® QuickAssist Technology (Intel® QAT)  accelerators](doc/PCM_ACCEL_README.md)
![image](https://user-images.githubusercontent.com/25432609/218480696-42ade94f-e0c3-4000-9dd8-39a0e75a210e.png)

- **pcm-latency** : monitor L1 cache miss and DDR/PMM memory latency
- **pcm-pcie** : monitor PCIe bandwidth per-socket
- **pcm-iio** : [monitor PCIe bandwidth per PCIe bus/device](doc/PCM_IIO_README.md)

![pcm-iio output](https://raw.githubusercontent.com/wiki/intel/pcm/pcm-iio.png)
- **pcm-numa** : monitor local and remote memory accesses
- **pcm-power** : monitor sleep and energy states of processor, Intel(r) Quick Path Interconnect, DRAM memory, reasons of CPU frequency throttling and other energy-related metrics
- **pcm-tsx**: monitor performance metrics for Intel(r) Transactional Synchronization Extensions
- **pcm-core** and **pmu-query**: query and monitor arbitrary processor core events
- **pcm-raw**: [program arbitrary **core** and **uncore** events by specifying raw register event ID encoding](doc/PCM_RAW_README.md)
- **pcm-bw-histogram**: collect memory bandwidth utilization histogram

Graphical front ends:
- **pcm Grafana dashboard** :  front-end for Grafana (in [scripts/grafana](scripts/grafana) directory). Full Grafana Readme is [here](scripts/grafana/README.md)
![pcm grafana output](https://raw.githubusercontent.com/wiki/intel/pcm/pcm-dashboard.png)
- **pcm-sensor** :  front-end for KDE KSysGuard
- **pcm-service** :  front-end for Windows perfmon

There are also utilities for reading/writing model specific registers (**pcm-msr**), PCI configuration registers (**pcm-pcicfg**), memory mapped registers (**pcm-mmio**) and TPMI registers (**pcm-tpmi**) supported on Linux, Windows, Mac OS X and FreeBSD.

And finally a daemon that stores core, memory and QPI counters in shared memory that can be be accessed by non-root users.

--------------------------------------------------------------------------------
Building PCM Tools
--------------------------------------------------------------------------------

Clone PCM repository with submodules:

```
git clone --recursive https://github.com/intel/pcm
cd pcm
```

or clone the repository first, and then update submodules with:

```
git submodule update --init --recursive
```

Install cmake (and libasan on Linux) then:

```
mkdir build
cd build
cmake ..
cmake --build .
```
You will get all the utilities (pcm, pcm-memory, etc) in `build/bin` directory.
'--parallel' can be used for faster building:
```
cmake --build . --parallel
```
Debug is default on Windows. Specify config to build Release:
```
cmake --build . --config Release
```
On Windows and MacOs additional drivers and steps are required. Please find instructions here: [WINDOWS_HOWTO.md](doc/WINDOWS_HOWTO.md) and [MAC_HOWTO.txt](doc/MAC_HOWTO.txt).

FreeBSD/DragonFlyBSD-specific details can be found in [FREEBSD_HOWTO.txt](doc/FREEBSD_HOWTO.txt)

![pcm-build-run-2](https://user-images.githubusercontent.com/25432609/205663554-c4fa1724-6286-495a-9dbd-0104de3f535f.gif)

--------------------------------------------------------------------------------
Downloading Pre-Compiled PCM Tools
--------------------------------------------------------------------------------

- Linux:
  * Ubuntu/Debian: `sudo apt install pcm`
  * openSUSE: `sudo zypper install pcm`
  * RHEL8.5 or later: `sudo dnf install pcm` 
  * Fedora: `sudo yum install pcm`
  * RPMs and DEBs with the *latest* PCM version for RHEL/SLE/Ubuntu/Debian/openSUSE/etc distributions (binary and source) are available [here](https://software.opensuse.org/download/package?package=pcm&project=home%3Aopcm)
- Windows: download PCM binaries as [appveyor build service](https://ci.appveyor.com/project/opcm/pcm/history) artifacts and required Visual C++ Redistributable from [www.microsoft.com](https://www.microsoft.com/en-us/download/details.aspx?id=48145). Additional steps and drivers are required, see [WINDOWS_HOWTO.md](doc/WINDOWS_HOWTO.md).
- Docker: see [instructions on how to use pcm-sensor-server pre-compiled container from docker hub](doc/DOCKER_README.md).

--------------------------------------------------------------------------------
Executing PCM tools under non-root user on Linux
--------------------------------------------------------------------------------

Executing PCM tools under an unprivileged user on a Linux operating system is feasible. However, there are certain prerequisites that need to be met, such as having Linux perf_event support for your processor in the Linux kernel version you are currently running. To successfully run the PCM tools, you need to set the `/proc/sys/kernel/perf_event_paranoid` setting to -1 as root once:

```
echo -1 > /proc/sys/kernel/perf_event_paranoid
```

and configure two specific environment variables when running the tools under a non-root user:

```
export PCM_NO_MSR=1
export PCM_KEEP_NMI_WATCHDOG=1
```

For instance, you can execute the following commands to set the environment variables and run pcm:

```
export PCM_NO_MSR=1
export PCM_KEEP_NMI_WATCHDOG=1
pcm
```

or (to run the pcm sensor server as non-root):

```
PCM_NO_MSR=1 PCM_KEEP_NMI_WATCHDOG=1 pcm-sensor-server
```

Please keep in mind that when executing PCM tools under an unprivileged user on Linux, certain PCM metrics may be unavailable. This limitation specifically affects metrics that rely solely on direct MSR (Model-Specific Register) register access. Due to the restricted privileges of the user, accessing these registers is not permitted, resulting in the absence of corresponding metrics.

--------------------------------------------------------------------------------
Frequently Asked Questions (FAQ)
--------------------------------------------------------------------------------

PCM's frequently asked questions (FAQ) are located [here](doc/FAQ.md).

--------------------------------------------------------------------------------
PCM API documentation
--------------------------------------------------------------------------------

PCM API documentation is embedded in the source code and can be generated into html format from source using Doxygen (www.doxygen.org).

--------------------------------------------------------------------------------
PCM environment variables
--------------------------------------------------------------------------------

The list of PCM environment variables is located [here](doc/ENVVAR_README.md)

--------------------------------------------------------------------------------
Custom compilation options
--------------------------------------------------------------------------------
The list of custom compilation options is located [here](doc/CUSTOM-COMPILE-OPTIONS.md)

--------------------------------------------------------------------------------
Packaging
--------------------------------------------------------------------------------
Packaging with CPack is supported on Debian and Redhat/SUSE system families.
To create DEB of RPM package need to call cpack after building in build folder:
```
cd build
cpack
```
This creates package:
- "pcm-VERSION-Linux.deb" on Debian family systems;
- "pcm-VERSION-Linux.rpm" on Redhat/SUSE-family systems.
Packages contain pcm-\* binaries and required for usage opCode-\* files.

```

`SECURITY.md`:

```md
# Security Policy
Intel is committed to rapidly addressing security vulnerabilities affecting our customers and providing clear guidance on the solution, impact, severity and mitigation. 

## Reporting a Vulnerability
Please report any security vulnerabilities in this project utilizing the guidelines [here](https://www.intel.com/content/www/us/en/security-center/vulnerability-handling-guidelines.html).
```

`_service`:

```
<services>
  <service name="download_url">
    <param name="host">github.com</param>
    <param name="protocol">https</param>
    <param name="path">/intel/pcm/archive/master.zip</param>
  </service>
  <service name="download_url">
    <param name="host">github.com</param>
    <param name="protocol">https</param>
    <param name="path">/intel/pcm/archive/master.tar.gz</param>
  </service>
<service name="download_url"><param name="host">raw.githubusercontent.com</param><param name="protocol">https</param><param name="path">/intel/pcm/master/pcm.spec</param></service></services>

```

`appveyor.yml`:

```yml
version: 1.0.{build}
image:
- Visual Studio 2019
- Visual Studio 2017
configuration: Release
platform: x64
before_build:
- cmd: >-
    nuget restore src\WinMSRDriver\MSR.vcxproj

    cmake --version

    cmake -B build


build_script:
- cmake --build build --config Release --parallel
- msbuild src\WinMSRDriver\MSR.vcxproj /m /t:Build /p:Configuration=Release /p:Platform=x64

after_build:
- cmd: 7z a pcm-all.zip %APPVEYOR_BUILD_FOLDER%\build\bin\Release\*.exe %APPVEYOR_BUILD_FOLDER%\build\bin\Release\*.dll %APPVEYOR_BUILD_FOLDER%\build\src\Release\*.lib %APPVEYOR_BUILD_FOLDER%\build\src\Release\*.exp %APPVEYOR_BUILD_FOLDER%\src\windows\PCM-Service.exe.config %APPVEYOR_BUILD_FOLDER%\src\WinMSRDriver\x64\Release\MSR\msr.*
artifacts:
- path: pcm-all.zip
  name: pcm-all


```

`cmake/CPM.cmake`:

```cmake
# SPDX-License-Identifier: MIT
#
# SPDX-FileCopyrightText: Copyright (c) 2019-2023 Lars Melchior and contributors

set(CPM_DOWNLOAD_VERSION 0.40.2)
set(CPM_HASH_SUM "c8cdc32c03816538ce22781ed72964dc864b2a34a310d3b7104812a5ca2d835d")

if(CPM_SOURCE_CACHE)
  set(CPM_DOWNLOAD_LOCATION "${CPM_SOURCE_CACHE}/cpm/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
elseif(DEFINED ENV{CPM_SOURCE_CACHE})
  set(CPM_DOWNLOAD_LOCATION "$ENV{CPM_SOURCE_CACHE}/cpm/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
else()
  set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
endif()

# Expand relative path. This is important if the provided path contains a tilde (~)
get_filename_component(CPM_DOWNLOAD_LOCATION ${CPM_DOWNLOAD_LOCATION} ABSOLUTE)

file(DOWNLOAD
     https://github.com/cpm-cmake/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake
     ${CPM_DOWNLOAD_LOCATION} EXPECTED_HASH SHA256=${CPM_HASH_SUM}
)

include(${CPM_DOWNLOAD_LOCATION})

```

`doc/CUSTOM-COMPILE-OPTIONS.md`:

```md
cpucounters.h : `#define PCM_HA_REQUESTS_READS_ONLY`
For the metric "LOCAL: number of local memory access in %“ (getLocalMemoryRequestRatio API) count only read accesses (local and all).

cpucounters.h : `#define PCM_DEBUG_TOPOLOGY`
print detailed CPU topology information

cpucounters.h : `#define PCM_UNCORE_PMON_BOX_CHECK_STATUS`
verify uncore PMU register state after programming

types.h : `#define PCM_DEBUG`
print some debug information

pci.h : `#define PCM_USE_PCI_MM_LINUX`
use /dev/mem (direct memory mapped I/O) for PCICFG register access on Linux. This might be required for accessing registers in extended configuration space (beyond 4K) in *pcm-pcicfg* utility. Recent Linux kernels also require to be booted with iomem=relaxed option to make this work.


```

`doc/CXL_README.md`:

```md
PCM can collect CLX bandwidth using the methods below.

--------------------------------------------------------------------------------
CXL.mem and CXL.cache traffic
--------------------------------------------------------------------------------

Please use pcm-memory utility for monitoring CXL.mem and CLX.cache traffic. pcm-memory will detect available CXL ports and will show traffic per CXL port and protocol (mem and cache) and per direction (read and write).

--------------------------------------------------------------------------------
CXL.io traffic
--------------------------------------------------------------------------------

pcm-iio utility should be used to monitor CXL.io traffic. pcm-iio will show traffic per CXL device and direction (inbound/outbound, read/write)



```

`doc/DOCKER_README.md`:

```md
--------------------------------------------------------------------------------
How To Run Intel(r) Performance Counter Monitor Server Container from GitHub Container Repository or Docker Hub
--------------------------------------------------------------------------------

As root user:
1. ``modprobe msr``
2. ``docker run -d --name pcm --privileged -p 9738:9738 ghcr.io/intel/pcm`` (GitHub Container repository) or ``docker run -d --name pcm --privileged -p 9738:9738 opcm/pcm`` (Dockerhub repository)
   - the container can also be run with limited capabilities without the privileged mode: ``docker run -d --name pcm --cap-add=SYS_ADMIN --cap-add=SYS_RAWIO --device=/dev/cpu --device=/dev/mem -v /sys/firmware/acpi/tables/MCFG:/pcm/sys/firmware/acpi/tables/MCFG:ro -v /proc/bus/pci/:/pcm/proc/bus/pci/ -v /proc/sys/kernel/nmi_watchdog:/pcm/proc/sys/kernel/nmi_watchdog -v /sys:/sys:rw -p 9738:9738 ghcr.io/intel/pcm`` (there is also a docker-compose file containing these options: https://raw.githubusercontent.com/intel/pcm/master/docker-compose.yml)

This will start pcm-sensor-server container exposing CPU metrics from the whole system at port 9738 

The URLs of the docker container repositories:
- https://github.com/intel/pcm/pkgs/container/pcm
- https://hub.docker.com/r/opcm/pcm

```

`doc/ENVVAR_README.md`:

```md
`PCM_NO_PERF=1` : don't use Linux perf events API to program *core* PMUs (default is to use it)

`PCM_USE_UNCORE_PERF=1` :  use Linux perf events API to program *uncore* PMUs (default is *not* to use it)

`PCM_NO_RDT=1` : don't use RDT metrics for a better interoperation with pqos utility (https://github.com/intel/intel-cmt-cat)

`PCM_USE_RESCTRL=1` : use Linux resctrl driver for RDT metrics

`PCM_PRINT_TOPOLOGY=1` : print detailed CPU topology

`PCM_KEEP_NMI_WATCHDOG=1` : don't disable NMI watchdog (reducing the core metrics set)

`PCM_NO_MAIN_EXCEPTION_HANDLER=1` :  don't catch exceptions in the main function of pcm tools (a debugging option)

`PCM_ENFORCE_MBM=1` :  force-enable Memory Bandwidth Monitoring (MBM) metrics (LocalMemoryBW = LMB) and (RemoteMemoryBW = RMB) on processors with RDT/MBM errata

`PCM_QUIET=1` :  enable quiet mode for PCM initialization. In quiet mode, only error messages are output during PCM initialization, suppressing informational output such as processor information and topology details

`PCM_DEBUG_LEVEL=x` :  x is an integer defining debug output level. level = 0 (default): minimal or no debug info, > 0 increases verbosity

```

`doc/FAQ.md`:

```md

## Q1

pcm-iio Tool outputs "Server CPU is required for this tool! Program aborted". Is there a way I can monitor my PCIe link bandwidth using one of the PCM utilities on client CPU?

Answer: The "IO" metric in *pcm* utility is the closest capability to monitor I/O PCIe traffic on client CPUs.

## Q2

PCM reports "ERROR: QPI LL monitoring device (...) is missing". How to fix it?

Answer: It is likely a BIOS issue. See details [here](https://software.intel.com/content/www/us/en/develop/articles/bios-preventing-access-to-qpi-performance-counters.html)

## Q3

Does PCM work inside a virtual machine?

Answer: PCM works inside virtual machines which support vPMU (with a limited set of metrics supported by vPMU). For example on AWS instances this is indicated by the presence of [arch_perfmon](https://instaguide.io/info.html?type=c5.18xlarge) flag: https://instaguide.io/ . Enabling vPMU in hypervisors is documented [in Hardware Event-Based Sampling section](https://software.intel.com/content/www/us/en/develop/documentation/vtune-help/top/set-up-analysis-target/on-virtual-machine.html).

## Q4

Does PCM work inside a docker container?

Answer: yes, it does. An example of how to run PCM inside a docker container is located [here](DOCKER_README.md). The recipe works also for other PCM utilities besides pcm-sensor-server.

## Q5

pcm-power reports "Unsupported processor model". Can you add support for pcm-power for my CPU?

Answer: most likely you have a client CPU which does not have required hardware performance monitoring units. PCM-power can not work without them.

## Q6

pcm-memory reports that the CPU is not supported. Can you add support for pcm-memory for my CPU?

Answer: most likely you have a client CPU which does not have required hardware performance monitoring units. PCM-memory can not work without them.

## Q7

Can PCM be used for measuring energy, CPU cycles, etc for a particular process or does it measure for the system as a whole?

Answer: PCM supports measurement for the whole system, per processor, per physical or per logical core. If you need monitoring per-process or user per-thread you can pin your process and/or thread to certain cores and read PCM data for these cores. But keep in mind that the OS can also schedule other processes or threads on this core and this may disturb your measurements. For a precise per-process or per-thread measurement the Intel VTune profiler or Linux perf profiler should be used.

## Q8

PCM reports

```
opening /dev/mem failed: errno is 1 (Operation not permitted)
Can not read memory controller counter information from PCI configuration space. Access to memory bandwidth counters is not possible.
You must be root to access these SandyBridge/IvyBridge/Haswell counters in PCM. 
Secure Boot detected. Using Linux perf for uncore PMU programming.
```

How to fix it?

Answer: Linux disables access to /dev/mem because Secure Boot is enabled in the BIOS. Disable Secure Boot in the BIOS to enable memory controller statistics (e.g. memory read and write bandwidth).

## Q9

PCM reports
```
Linux Perf: Error on programming ...
```
How to fix it?

**Answer:** It is an issue with the Linux kernel perf driver. As a workaround upgrade your Linux kernel to the latest available/possible or run PCM with its own programming logic:

```
export PCM_NO_PERF=1
pcm -r
```

## Q10

If you are getting the error `Starting MSR service failed with error 3 The system cannot find the path specified.` try to uninstall the driver by running `pcm --uninstallDriver` and optionally reboot the system.

## Q11

Is PCM supported on AWS instances

**Answer**: 

Not all AWS instances allow users to collect CPU telemetry by exposing PMU to the user. The following instances can be used:

* Bare metal instances: allow collection of CPU metrics from both core (e.g. instructions per cycle, cache misses) and uncore (e.g. memory controller, UPI)
* Full-socket (single socket, two socket, etc) virtualized instances: e.g. m5d.12xlarge, m5.24xlarge, m5.12xlarge. Only core CPU metrics are exposed, and certain CPU performance events are forbidden (e.g. offcore response events, events collecting “any_thread” information). “arch_perfmon” flag in /proc/cpuinfo indicates if the core CPU metrics are exposed (example: https://instaguide.io/info.html?type=m5.12xlarge ). The mechanism of PMU virtualization is commonly known as vPMU.

## Q12

pcm-pcie reports that the CPU is not supported: "Jaketown, Ivytown, Haswell, Broadwell-DE, Skylake, Icelake, Snowridge and Sapphirerapids Server CPU is required for this tool! Program aborted"
Can you add support for pcm-pcie for my CPU?

Answer: most likely you have a client CPU which does not have required hardware performance monitoring units. pcm-pcie can not work without them.


```

`doc/FREEBSD_HOWTO.txt`:

```txt
Building:
$ cmake -B build
$ cmake --build build

Runtime requirements:
* the cpuctl(4) driver needs to be loaded

PCM is also available as a port maintained by The FreeBSD Project (sysutils/intel-pcm).

```

`doc/LATENCY-OPTIMIZED-MODE.md`:

```md
# Latency Optimized Mode in Intel® Xeon® 6 Processors

Intel® Xeon® 6 Processors (previously codenamed Granite Rapids and Sierra Forest/Birch Stream platform) introduce a new power management mechanism called Efficiency Latency Control (ELC), designed to optimize performance per watt. This feature allows hardware power management algorithms to balance the trade-off between latency and power consumption. For latency-sensitive workloads, further tuning can be performed to achieve the desired performance.

The hardware monitors the average CPU utilization across all cores at regular intervals to determine an appropriate uncore frequency. While this approach generally results in optimal performance per watt, some workloads may achieve higher performance at the expense of increased power consumption. For instance, an application that intermittently performs memory reads on an otherwise idle system may experience delays if the hardware lowers the uncore frequency, causing a lag in ramping up to the required performance levels. To verify this, the uncore frequencies can be monitored using the pcm utility:

![Uncore Frequency Statistics DEFAULT](https://github.com/user-attachments/assets/108c7350-3fc2-4056-aeaf-ecc7c25da6bc)

The screenshot above presents real-time data on uncore frequency statistics, measured in GHz, from a dual-socket platform (represented by two rows). Each socket includes five dies (organized into five columns). The first three dies contain CORes (COR), Last Level Cache (LLC), and Memory controllers (M), collectively referred to as CORLLCM. The final two dies are IO dies.

The ELC control has parameters that can be adjusted either through BIOS or software tools. The default parameter configuration can be optimized for performance per watt, ensuring power efficiency. The alternative configuration, known as Latency Optimized Mode, prioritizes maximum performance.
Below are the PCM statistics from a system operating in Latency Optimized Mode:

![Uncore Frequency Statistics Latency Optimized Mode](https://github.com/user-attachments/assets/70310bbc-725b-4450-af7a-1db2c04291dd)

## BIOS Options for Latency Optimized Mode

The BIOS option for selecting the Optimized Power Mode or Latency Optimized Mode can typically be located in the following menus, depending on the BIOS version and OEM vendor:
- **Socket Configuration** -> **Advanced Power Management** -> **CPU – Advanced PM Tuning** -> **Latency Optimized Mode** (Disabled or Enabled)
- **System Utilities** -> **System Configuration** -> **BIOS/Platform Configuration (RBSU)** -> **Power and Performance Options** -> **Advanced Power Options** -> **Efficiency Latency Control** (Default (Optimized Power Mode) or Latency Optimized Mode)

Should this BIOS option be unavailable or if there is a preference to change the mode during runtime, the PCM repository provides scripts for changing this mode.

|Platform	         |Script Type|	URL                                                                |
|------------------|-----------|---------------------------------------------------------------------|
|Linux/FreeBSD/UNIX|bash       | https://github.com/intel/pcm/blob/master/scripts/bhs-power-mode.sh  |
|Windows	         |powershell | https://github.com/intel/pcm/blob/master/scripts/bhs-power-mode.ps1 |

The scripts require the pcm-tpmi utility. There are several methods to obtain this utility:
- **Download or install precompiled PCM binaries:** Please refer to the following link: [Downloading Pre-Compiled PCM Tools](https://github.com/intel/pcm?tab=readme-ov-file#downloading-pre-compiled-pcm-tools)
- **Compile the utility:** Follow the instructions in the "Building PCM Tools" section available at: [Building PCM Tools](https://github.com/intel/pcm?tab=readme-ov-file#building-pcm-tools)
   * For Linux/FreeBSD: Copy the pcm-tpmi utility from PCM’s source 'build/bin' directory to `/usr/local/bin/` or execute `make install` in the 'build' directory.

For Windows: Copy the pcm-tpmi utility to the current directory.

Once the pcm-tpmi binary is correctly placed, you can set the Latency Optimized Mode.

### Setting Latency Optimized Mode

Linux/FreeBSD/UNIX:
```
bash bhs-power-mode.sh --latency-optimized-mode
```
Windows:
```
.\bhs-power-mode.ps1 --latency-optimized-mode
```

### Setting Optimized Power Mode

Linux/FreeBSD/UNIX:
```
bash bhs-power-mode.sh --optimized-power-mode
```

Windows:
```
.\bhs-power-mode.ps1 --optimized-power-mode
```



```

`doc/LINUX_HOWTO.txt`:

```txt
Refer to the main README ("Building PCM Tools" or "Downloading Pre-Compiled PCM Tools") sections

Running tests:

* build PCM
* as root run "sh test/test.sh"
  - Automated CI test workflow: https://github.com/intel/pcm/blob/03ad6b0228c9e8a8eb022708b53a61875b9447bc/.github/workflows/ci-test.yml#L40

```

`doc/MAC_HOWTO.txt`:

```txt
Building and Installing

Note: xcode is required to build the driver and dynamic library.

Requirements
____________
Building and installing requires make, cmake, gcc, and xcode.
It has been tested on the following system configurations:
    OS X 12.0.1, Xcode 13.1, Apple LLVM compiler 13.0.0

Build PCM and MacMSRDriver
-----------------
  mkdir build && cd build
  cmake .. && cmake --build .

PCM utilities will be located in build/bin folder, libraries libpcm.dylib and libPcmMsr.dylib - in build/lib.

Automatic Install
-----------------
  cd build
  sudo make install

Install command loads the driver, installs the library into /usr/lib and installs the library headers into /usr/include.
Also PCM utilities are installing to /usr/local/sbin.

Manual Install
--------------
Build steps are the same.
To install do the following:
    1) load the driver by running src/MacMSRDriver/kextload.sh
    2) copy build/lib/libPcmMsr.dylib to a location on your path (auto-install uses /usr/lib)
    3) copy src/MacMSRDriver/MSRKernel.h to a location on your path (auto-install uses /usr/include)
    4) copy src/MacMSRDriver/MSRAccessorPublic.h as MSRAccessor.h to a location on your path (auto-install uses /usr/include)

kext Signatures
---------------
As of OS X El Capitan, kexts must be signed. So after building the kext, kextload.sh may fail with:

  /System/Library/Extensions/PcmMsrDriver.kext failed to load - (libkern/kext) not loadable (reason unspecified); check the system/kernel logs for errors or try kextutil(8).

In this event, you will need to either disable System Integrity Protection or sign the kext.
You can disable SIP by rebooting into Recovery (reboot, command-option-R), opening a shell, csrutil disable and reboot again.
Signing a kext is more involved. You can't self-sign and will first need to obtain a Developer ID from Apple:

  https://developer.apple.com/contact/kext/

With this ID, you can then sign your kext with codesign.

PCM Execution
----------------------
Now you can run ./pcm utility.
See description of other built utilities in LINUX_HOWTO.txt

Logging/Debugging
----------------------

Sometimes you will get errors while running utilities that may come from the kernel, and you can use something like this DTrace script to correlate it with user-land behavior:

$ sudo dtrace -n 'fbt:mach_kernel:_ZN*IOUser*:return /execname == "pcm"/ { @hgram[probefunc, arg1, ustack(20)] = count(); }' -c ./pcm

Various commands that can help diagnose errors:

$ kmutil log stream
$ kmutil inspect -b com.intel.driver.PcmMsr

```

`doc/NUMA_NODE_API.md`:

```md
# NUMA Node Location API for PCI Devices

## Overview

The `getNUMANode()` API allows you to retrieve the NUMA (Non-Uniform Memory Access) node location of a PCI device identified by its segment:bus:device:function coordinates.

## Background

- **PciHandle** and **PciHandleMM** classes are abstractions of PCI configuration space registers
- Each PCI device has a unique location: `segment:bus:device:function`
- **segment** is also known as **group number** or **domain** (synonyms: groupnr, groupnr_)

## API Usage

### Method Signature

```cpp
int32 PciHandle::getNUMANode() const;
int32 PciHandleMM::getNUMANode() const;
```

### Return Value

- **>= 0**: The NUMA node ID where the PCI device is located
- **-1**: NUMA information not available or not applicable

### Example

```cpp
#include "pci.h"

using namespace pcm;

// Open a PCI device at segment 0, bus 0, device 0, function 0
PciHandleType handle(0, 0, 0, 0);

// Get the NUMA node
int32 numa_node = handle.getNUMANode();

if (numa_node >= 0) {
    std::cout << "Device is on NUMA node: " << numa_node << "\n";
} else {
    std::cout << "NUMA information not available\n";
}
```

## Platform-Specific Implementation

### Linux

- **Method**: Reads from `/sys/bus/pci/devices/<domain>:<bus>:<device>.<function>/numa_node`
- **Fallback**: Also tries `/pcm/sys/bus/pci/devices/...` path
- **Return**: 
  - NUMA node ID (typically 0, 1, 2, ...) if available
  - -1 if the file doesn't exist or can't be read

### Windows

- **Method**: Reads SRAT (System Resource Affinity Table) from ACPI firmware using `GetSystemFirmwareTable` API
- **Implementation**: 
  - Parses SRAT table to extract PCI Device Affinity structures (type 2)
  - Builds a mapping from PCI device location (segment:bus:device:function) to NUMA node (proximity domain)
  - Caches the mapping on first call for performance
- **Return**: 
  - NUMA node ID (proximity domain) if device is found in SRAT table
  - -1 if SRAT table is not available or device is not listed
- **Requirements**: Windows Vista or later (for `GetSystemFirmwareTable` API)

### FreeBSD / DragonFly

- **Method**: Queries system via `sysctlbyname()` for NUMA domain information
- **Implementation**:
  - First checks if NUMA is enabled via `vm.ndomains` sysctl
  - Attempts to query PCI device-specific NUMA domain using multiple sysctl path formats
  - Tries: `hw.pci.X.Y.Z.W.numa_domain` and `hw.pci.X:Y:Z.W.numa_domain`
- **Return**:
  - NUMA node ID if available and system has NUMA enabled
  - -1 if NUMA is disabled, not supported, or device affinity information unavailable
- **Note**: FreeBSD doesn't have a standardized sysctl path for PCI device NUMA affinity across all versions

### macOS

- **Method**: Returns -1 (macOS typically doesn't expose NUMA for PCI devices)
- **Return**: -1 (not applicable)

## Use Cases

1. **Performance Optimization**: Place processing threads on the same NUMA node as the device
2. **Memory Allocation**: Allocate buffers on the same NUMA node for optimal DMA performance
3. **System Topology Discovery**: Map out the relationship between PCI devices and NUMA nodes
4. **Monitoring and Analytics**: Identify cross-NUMA traffic patterns

## Building the Example

```bash
cd examples
g++ -std=c++11 -I../src numa_node_example.cpp -o numa_node_example -L../build/lib -lpcm -lpthread
LD_LIBRARY_PATH=../build/lib ./numa_node_example
```

## Notes

- Requires appropriate permissions to access PCI configuration space
- On Linux, run with `sudo` or ensure `/sys/bus/pci` is accessible
- The NUMA node value is read at runtime and not cached
- A return value of -1 doesn't indicate an error; it means NUMA information is not available

## Related APIs

- `PciHandle::read32()` - Read 32-bit value from PCI configuration space
- `PciHandle::write32()` - Write 32-bit value to PCI configuration space
- `PciHandle::read64()` - Read 64-bit value from PCI configuration space
- `PciHandle::exists()` - Check if a PCI device exists

## See Also

- Linux kernel documentation: `Documentation/ABI/testing/sysfs-bus-pci`
- ACPI SRAT (System Resource Affinity Table) specification
- PCI Express Base Specification

```

`doc/PCM-EXPORTER.md`:

```md
# Intel&reg; Performance Counter Monitor (Intel&reg; PCM) Prometheus exporter


pcm-sensor-server is a collector exposing Intel processor metrics over http in JSON or Prometheus (exporter text based) format. Also [available as a docker container](DOCKER_README.md).

**NEW**: pcm-sensor-server is now supported on Windows! See [Windows-specific instructions](#windows-support) below.

Installation on target system to be analyzed:
1.  [Build](https://github.com/intel/pcm#building-pcm-tools) or [download](https://github.com/intel/pcm#downloading-pre-compiled-pcm-tools) pcm tools
2.  As root, start pcm-sensor-server: `sudo ./pcm-sensor-server` or as non-root https://github.com/intel/pcm#executing-pcm-tools-under-non-root-user-on-linux 

Alternatively one can start [pcm-sensor-server as a container from docker hub](DOCKER_README.md).

Additional options:

```
$ ./pcm-sensor-server --help
Usage: ./pcm-sensor-server [OPTION]

Valid Options:
    -d                   : Run in the background (Linux/macOS only)
    -p portnumber        : Run on port <portnumber> (default port is 9738)
    -l|--listen address  : Listen on IP address <address> (default: all interfaces)
    -r|--reset           : Reset programming of the performance counters.
    -D|--debug level     : level = 0: no debug info, > 0 increase verbosity.
    -R|--real-time       : If possible the daemon will run with real time
                           priority, could be useful under heavy load to
                           stabilize the async counter fetching. (Linux only)
    -h|--help            : This information
```

The `-l`/`--listen` option allows you to specify which IP address the server should bind to. This is useful in multi-homed servers, containerized deployments, or restricted monitoring networks:

```bash
# Bind to localhost only (accessible only from the local machine)
sudo ./pcm-sensor-server -l 127.0.0.1 -p 9738

# Bind to a specific management network interface
sudo ./pcm-sensor-server -l 192.168.1.10

# Bind to all interfaces (default behavior)
sudo ./pcm-sensor-server
```

## Windows Support

pcm-sensor-server now runs natively on Windows. Key points:

- **Requirements**: Windows 10+ or Windows Server 2016+ (earlier versions may work but are no longer officially supported), Administrator privileges, MSR driver installed
- **Build instructions**: See [WINDOWS_HOWTO.md](WINDOWS_HOWTO.md#pcm-sensor-server-httphttps-server-for-grafana-integration)
- **Limitations**: 
  - Daemon mode (`-d`) not available - runs in foreground only
  - Real-time priority (`-R`) not available
  - Use Ctrl+C to stop the server

Example on Windows:
```
# Run as Administrator
pcm-sensor-server.exe -p 9738
```

The default output of pcm-sensor-server endpoint in a browser:

![image](https://user-images.githubusercontent.com/25432609/226344012-8783e154-998e-48a7-a2ca-f2c42af9c843.png)


The PCM exporter can be used together with Grafana to obtain these Intel processor metrics (see [how-to](../scripts/grafana/README.md)):

![pcm grafana output](https://raw.githubusercontent.com/wiki/intel/pcm/pcm-dashboard-full.png)

```

`doc/PCM-SENSOR-SERVER-README.md`:

```md
# Global PCM Events

|     Event Name              |                                Description                                  |
|-----------------------------|-----------------------------------------------------------------------------|
| Measurement_Interval_in_us  |             How many us elapsed to complete the last measurement            |
| Number_of_sockets           |                     Number of CPU sockets in the system                     |


# Core Counters per socket

OS_ID is the OS assigned ID of the logical CPU core and denotes the socket id, core id and thread id.

The events below are followed by the same {socket="socket id",core="core id",thread="thread id"} as
the OS_ID of their section with source="socket/core/thread" appended that denotes what the quantity
of the event accounts for.

For example Instructions_Retired_Any{socket="0",core="1",thread="1",source="core"} refers to 
Instructions_Retired_Any for socket 0, core 1, thread 1, and accounts for the total instructions
retired of the specified core.

|          Event                                 |                   Description                                |
|------------------------------------------------|--------------------------------------------------------------|
|   Instructions_Retired_Any                     |   Total number of Retired instructions                       |
|   Clock_Unhalted_Thread                        |                                                              |
|   Clock_Unhalted_Ref                           |   Counts the number of reference cycles that the thread is   |
|                                                |   not in a halt state. The thread enters the halt state when |
|                                                |   it is running the HLT instruction. This event is not       |
|                                                |   affected by thread frequency changes but counts as if the  |
|                                                |   thread is running at the maximum frequency all the time.   |
|   L3_Cache_Misses                              |   Total number of L3 Cache misses                            |
|   L3_Cache_Hits                                |   Total number of L3 Cache hits                              |
|   L2_Cache_Misses                              |   Total number of L2 Cache misses                            |
|   L2_Cache_Hits                                |   Total number of L3 Cache hits                              |
|   L3_Cache_Occupancy                           |   Computes L3 Cache Occupancy                                |
|   SMI_Count                                    |   SMI (System Management Interrupt) count                    |
|   Invariant_TSC                                |   Calculates the invariant TSC clocks (the invariant TSC     |
|                                                |   means that the TSC continues at a fixed rate regardless of |
|                                                |   the C-state or frequency of the processor as long as the   |
|                                                |   processor remains in the ACPI S0 state.                    |
|   Thermal_Headroom                             |   Celsius degrees before reaching TjMax temperature          |
|   CStateResidency                              |   This is the percentage of time that the core (or the whole |
|                                                |   package) spends in a particular level of C-state           |                                                                                                                                            |

References:

https://software.intel.com/content/www/us/en/develop/articles/intel-performance-counter-monitor.html
https://software.intel.com/content/dam/develop/external/us/en/documents-tps/325384-sdm-vol-3abcd.pdf - Chapter 18 Performance Monitoring
```

`doc/PCM_ACCEL_README.md`:

```md
## Purpose:

Intel® Xeon® Scalable Processors, starting from the 4th Generation (codenamed Sapphire Rapids), feature accelerators, which include the Intel® In-Memory Analytics Accelerator (Intel® IAA), Intel® Data Streaming Accelerator (Intel® DSA), and Intel® QuickAssist Technology (Intel® QAT), among others. These accelerators are essential components that can enhance the performance of Intel architecture platforms.

Although these accelerators and their associated software stacks can significantly contribute to data center system performance, customers and users often find it challenging to access and understand performance data such as utilization and throughput. This difficulty arises from the complexity of low-level hardware event sets, which require a deep understanding of the accelerator's hardware and software architecture.

The pcm-accel tool addresses this challenge by sampling performance data from the accelerator hardware and presenting it to end users in an easy-to-understand format. Its goal is to enable users to quickly and accurately gain a high-level overview of performance or identify issues related to the accelerator, regardless of their level of expertise in the underlying technology.

## Command syntax:

pcm-accel [target] [options]

#### the target parameter

Notes: only 1 target is allowed to monitor.

| target | Default | Description                   |
| ------ | ------- | ----------------------------- |
| -iaa   | yes     | Monitor the IAA accelerator.  |
| -dsa   | no      | Monitor the DSA accelerator.  |
| -qat   | no      | Monitor the QAT accelerator.  |

#### the options parameter

Notes: multiple options is allowed.

| options                | Default              | Description                                                                                                                |
| ---------------------- | -------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| -numa                  | no                   | Print NUMA node mapping instead of CPU socket location.                                                                    |
| -evt=[cfg.txt]         | opCode-x-y-accel.txt | Specify the event config file name as cfg.txt.<br>- x/y is cpu family is model id, for example 6/143 for Sapphire Rapids.  |
| -silent                | no                   | Silence information output and print only measurements                                                                     |
| -csv[=file.csv]        | no                   | Output compact CSV format to screen or a file in case filename is provided                                                 |
| -csv-delimiter=[value] | no                   | Set custom csv delimiter                                                                                                   |
| -human-readable        | no                   | Use human readable format for output (for csv only)                                                                        |
| -i=[value]             | 0                    | Allow to determine number of iterations, default is 0(infinite loop) if not specified.                                     |
| [interval]             | 3                    | Time interval in seconds (floating point number is accepted) to sample performance counters, default is 3s if not specified|

#### Examples:

This example prints IAA counters every second 10 times and exits

> pcm-accel -iaa 1.0 -i=10 

This example saves IAA counters twice a second save IAA counter values to test.log in CSV format

> pcm-accel -iaa 0.5 -csv=test.log           

This example prints IAA counters every 3 second in human-readable CSV format

> pcm-accel -iaa -csv -human-readable

## Prerequisites:

Linux* OS:

FreeBSD* OS:

Windows OS:

- Install and load the required accelerator driver(iaa/dsa, qat driver, etc).

Notes:

- QAT monitoring and NUMA node display feature is supported only on Linux OS!

## Tool UI introduction:

Common indicator(Column field):

- Accelerator = Accelerator device id.
- Socket = CPU socket id where accelerator device is located.
- NUMA Node = NUMA node that accelerator device belongs to.
- Inbound_BW = Data throughput input to the accelerator device, unit is Bps(Bytes per second).
- Outbound_BW = Data throughput output from the accelerator device, unit is Bps(Bytes per second).

Specific indicators related to IAA/DSA: 

- ShareWQ_ReqNb = The number of request submitted to share work queue of accelerator.
- DedicateWQ_ReqNb = The number of request submitted to dedicate work queue of accelerator.

![image](https://user-images.githubusercontent.com/25432609/224027332-8846dff6-f71e-4daa-a189-730e68c7e1b2.png)
![image](https://user-images.githubusercontent.com/25432609/224027445-2b08e89c-4653-4f39-971b-a7dc76bd7349.png)

Specific indicators related to QAT:

- util_comp0 = The utilization of the compress engine 0, unit is %.(Sapphire Rapids platform has 1 compress and 3 decompress engine per QAT device)

- util_decomp0 = same as above for decompress engine 0.

- util_decomp1 = same as above for decompress engine 1.

- util_decomp2 = same as above for decompress engine 2.

- util_xlt0 = same as above for translation engine 0.

 
  ![image](https://user-images.githubusercontent.com/25432609/224027570-e433aeef-c2ed-418d-aa42-18eef0f1b645.png)


## Event config file:

pcm-accel tool allows the user to customized the monitored performance events with the config file as advance feature.

Customize fields of cfg file:

- ev_sel and ev_cat field for IAA/DSA monitor event.
- ev_sel field for QAT monitor event. 
- multiplier/divider is for event data display calculation.
- vname is the event name string(column) displayed in the UI.

Please refer to the spec or code to learn more about the event mapping if you want to customize it.

- IAA/DSA: https://software.intel.com/en-us/download/intel-data-streaming-accelerator-preliminary-architecture-specification

- QAT: please refer to the [mapping table in source code](https://github.com/intel/pcm/blob/f20013f7563714cf592d7a59f169c1ddee3cf8ba/src/cpucounters.cpp#L915)


Here is the content of the event cfg file(opCode-6-143-accel.txt as example)

![image](https://user-images.githubusercontent.com/25432609/224027717-1dcdae9e-6701-4b6f-90a0-8108c4ea4550.png)


```

`doc/PCM_IIO_README.md`:

```md
## Purpose:

PCM-IIO tool monitors PCIe transactions with a breakdown per PCIe bus (IIO stack) and/or PCIe devices.

## Tool UI introduction:

Inbound (PCIe device DMA into system) metrics:

* IB write (inbound write): the number of bytes per second that the PCIe device requested to write to main memory through DMA
* IB read (inbound read): the number of bytes per second that the PCIe device requested to read from main memory through DMA

Outbound (CPU MMIO to the PCIe device) metrics:

* OB read (outbound read): the number of bytes per second that the CPU requested to read from the PCIe device through MMIO (memory-mapped I/O)
* OB write (outbound write): the number of bytes per second that the CPU requested to write to the PCIe device through MMIO (memory-mapped I/O)

IOMMU metrics:

* IOTLB Lookup: IOTLB lookups per second
* IOTLB Miss: IOTLB misses per second
* Ctxt Cache Hit: Context cache hits per second
* 256T Cache Hit: Second Level Page Walk Cache Hits to a 256T page per second
* 512G Cache Hit: Second Level Page Walk Cache Hits to a 512G page per second
* 1G Cache Hit: Second Level Page Walk Cache Hits to a 1G page per second
* 2M Cache Hit: Second Level Page Walk Cache Hits to a 2M page per second
* IOMMU Mem Access: IOMMU memory accesses per second

Sample output:

![image](https://github.com/user-attachments/assets/e8cce396-b210-49d5-ac95-dc43f9ae69d3)

## Event config file:

pcm-iio tool allows the user to customize the performance events with a config file as an advanced feature. The event config files are in opCode-x-y.txt files where x/y is cpu family is model id, for example 6/143 for Sapphire Rapids.


```

`doc/PCM_RAW_README.md`:

```md
--------------------------------------------------------------------------------
PCM Raw Utility
--------------------------------------------------------------------------------

Disclaimer: in contrast to other PCM utilities this one is for expert usage only.

*pcm-raw* allows to collect arbitrary core and uncore PMU events by providing raw PMU event ID encoding. It can become handy if other low-level PMU tools (e.g. emon, Linux perf) can not be used for some reason. For example:
- emon kernel driver is not compatible with the currently used Linux kernel or operating system
- loading emon Linux kernel driver is forbidden due to system administration policies
- Linux kernel is too old to support modern processor PMU and can not be upgraded

Currently supported PMUs: core, m3upi, upi(ll)/qpi(ll), imc, m2m, pcu, cha/cbo, iio, ubox

Recommended usage (as privileged/root user):
1. Install VTune which also contains emon (emon/sep driver installation is not needed): [free download](https://software.intel.com/content/www/us/en/develop/tools/vtune-profiler.html)
2. Run emon with `--dry-run -m` options to obtain raw PMU event encodings for event of interest. For example:
```
# emon -C BR_MISP_RETIRED.ALL_BRANCHES,UNC_CHA_CLOCKTICKS,UNC_IIO_DATA_REQ_OF_CPU.MEM_WRITE.PART0,UNC_UPI_TxL_FLITS.NON_DATA --dry-run -m
Event Set 0
        BR_MISP_RETIRED.ALL_BRANCHES (PerfEvtSel0 (0x186) = 0x00000000004300c5)
          CC=ALL PC=0x0 UMASK=0x0 E=0x1 INT=0x0 INV=0x0 CMASK=0x0 AMT=0x0
cha Uncore Event Set 0
        UNC_CHA_CLOCKTICKS (CHA Counter 0 (0xe01) = 0x0000000000400000)

qpill Uncore Event Set 0
        UNC_UPI_TxL_FLITS.NON_DATA (QPILL Counter 0 (0x350) = 0x0000000000409702)

iio Uncore Event Set 0
        UNC_IIO_DATA_REQ_OF_CPU.MEM_WRITE.PART0 (IIO Counter 0 (0xa48) = 0x0000701000400183)
```
3. Run *pcm-raw* by specifying the obtained raw event encodings to collect into csv file. Example:
```
pcm-raw -e core/config=0x00000000004300c5,name=BR_MISP_RETIRED.ALL_BRANCHES -e cha/config=0x0000000000400000,name=UNC_CHA_CLOCKTICKS -e qpi/config=0x0000000000409702,name=UNC_UPI_TxL_FLITS.NON_DATA -e iio/config=0x0000701000400183,name=UNC_IIO_DATA_REQ_OF_CPU.MEM_WRITE.PART0 -csv=out.csv
```
4. View/process the csv file using your favorite method. For example just open it in Excel.

--------------------------------------------------------------------------------
Collecting Register Values
--------------------------------------------------------------------------------

pcm-raw supports collecting raw MSR and PCICFG (CSR) register values. The syntax is described below:

Model Specific Registers (MSRs):

```
package_msr/config=<msr_address>,config1=<static_or_freerun>[,name=<name>]
```

static_or_freerun encoding:
* 0 : static (last value reported in csv)
* 1 : freerun (delta to last value reported in csv)

Examples:
```
package_msr/config=0x34,config1=0,name=SMI_COUNT
thread_msr/config=0x10,config1=1,name=TSC_DELTA
thread_msr/config=0x10,config1=0,name=TSC
```

If the name is not specified the first event will show up as package_msr:0x34:static, with the name it will show up as SMI_COUNT in csv.

PCI Configuration Registers - PCICFG (CSR):

```
pcicfg/config=<dev_id>,config1=<offset>,config2=<static_or_freerun>,width=<width>[,name=<name>]
```

* dev_id: Intel PCI device id where the register is located
* offset: offset of the register
* static_or_freerun: same syntax as for MSR registers
* width: register width in bits (16,32,64) 

Example:

```
pcicfg/config=0xe20,config1=0x180,config2=0x0,width=32,name=CHANERR_INT
```
From: https://www.intel.la/content/dam/www/public/us/en/documents/datasheets/xeon-e7-v2-datasheet-vol-2.pdf

MMIO Registers:

```
mmio/config=<device_id>,config1=<offset>,config2=<static_or_freerun>,config3=<membar_bits1>[,config4=<membar_bits2>],width=<width>[,name=<NAME>]
```

The MEMBAR is computed by logically ORing the result of membar_bits1 and membar_bits1 computation described below (PCICFG read + bit extraction and shift). The final MMIO register address = MEMBAR + offset.

* width: register width in bits (16,32,64) 
* dev_id: Intel PCI device id where the membar address registers are located
* membar_bits1: mmioBase register bits to compute membar (base address)
  - bits 0-15 : PCICFG register offset to read membar1 bits
  - bits 16-23: source position of membar bits in the PCICFG register 
  - bits 24-31: number of bits
  - bits 32-39: destination bit position in the membar
* membar_bits2: mmioBase register bits to compute membar (base address), can be zero if only membar_bits1 is sufficient for locating the register.
  - bits 0-15 : PCICFG register offset to read membar2 bits
  - bits 16-23: source position of membar bits in the PCICFG register 
  - bits 24-31: number of bits
  - bits 32-39: destination bit position in the membar
* offset: offset of the MMIO register relative to the membar
* static_or_freerun: same syntax as for MSR registers

Example (Icelake server iMC PMON MMIO register read):

```
mmio/config=0x3451,config1=0x22808,config2=1,config3=0x171D0000D0,config4=0x0c0b0000d8,width=64
```

TPMI Registers:

TPMI ([Topology Aware Register and PM Capsule Interface](https://github.com/intel/tpmi_power_management)) can be read with pcm-raw as follows:

```
tpmi/config=<tpmi_id>,config1=<offset>,config2=<static_or_freerun>[,name=<name>]
```

* tpmi_id: TPMI id
* offset: offset of the register
* static_or_freerun: same syntax as for MSR registers

Example:

```
tpmi/config=0x2,config1=0x18,name=BHS_UFS_CONTROL
```

From: https://github.com/intel/tpmi_power_management/blob/main/UFS_TPMI_public_disclosure_FINAL_rev4.pdf

--------------------------------------------------------------------------------
Collecting Events By Names From Event Lists (https://github.com/intel/perfmon/)
--------------------------------------------------------------------------------

pcm-raw can also automatically lookup the events from the json event lists (https://github.com/intel/perfmon/) and translate them to raw encodings itself. To make this work you need to checkout PCM with simdjson submodule:

* use git clone --recursive flag when cloning pcm repository, or
* update submodule with command `git submodule update --init --recursive`, or
* download simdjson library in the PCM source directory and recompile PCM:

1. change to PCM 'src/' directory
2. git clone https://github.com/simdjson/simdjson.git
3. re-compile pcm

Example of usage (on Intel Xeon Scalable processor):

```
pcm-raw -tr -e INST_RETIRED.ANY -e CPU_CLK_UNHALTED.THREAD -e CPU_CLK_UNHALTED.REF_TSC -e LD_BLOCKS.STORE_FORWARD -e UNC_CHA_CLOCKTICKS -e UNC_M_CAS_COUNT.RD
```

or with event groups specified in event_file.txt (with event multiplexing):

```
pcm-raw -tr -el event_file.txt
```

where event_file.txt contains event groups separated by a semicolon:

```
# group 1
INST_RETIRED.ANY
CPU_CLK_UNHALTED.REF_TSC
CPU_CLK_UNHALTED.THREAD
DTLB_LOAD_MISSES.STLB_HIT
L1D_PEND_MISS.PENDING_CYCLES_ANY
MEM_INST_RETIRED.LOCK_LOADS
UOPS_EXECUTED.X87
UNC_CHA_DIR_LOOKUP.SNP
UNC_CHA_DIR_LOOKUP.NO_SNP
UNC_M_CAS_COUNT.RD
UNC_M_CAS_COUNT.WR
UNC_UPI_CLOCKTICKS
UNC_UPI_TxL_FLITS.ALL_DATA
UNC_UPI_TxL_FLITS.NON_DATA
UNC_UPI_L1_POWER_CYCLES
;
# group 2
INST_RETIRED.ANY
CPU_CLK_UNHALTED.REF_TSC
CPU_CLK_UNHALTED.THREAD
OFFCORE_REQUESTS_BUFFER.SQ_FULL
MEM_LOAD_L3_HIT_RETIRED.XSNP_HIT
MEM_LOAD_L3_HIT_RETIRED.XSNP_HITM
MEM_LOAD_L3_HIT_RETIRED.XSNP_MISS
UNC_CHA_DIR_UPDATE.HA
UNC_CHA_DIR_UPDATE.TOR
UNC_M2M_DIRECTORY_UPDATE.ANY
UNC_M_CAS_COUNT.RD
UNC_M_CAS_COUNT.WR
UNC_M_PRE_COUNT.PAGE_MISS
UNC_UPI_TxL0P_POWER_CYCLES
UNC_UPI_RxL0P_POWER_CYCLES
UNC_UPI_RxL_FLITS.ALL_DATA
UNC_UPI_RxL_FLITS.NON_DATA
;
```

Sample csv output (date,time,event_name,milliseconds_between_samples,TSC_cycles_between_samples,unit0_event_count,unit1_event_count,unit2_event_count,...):

```
2021-09-27,00:07:40.507,UNC_CHA_DIR_LOOKUP.SNP,1000,2102078418,76,70,56,91,88,75,76,158,74,60,77,81,75,74,71,95,99,95,125,87,68,136,54,91,65,84,69,46,75,100,92,68,67,70,68,80,72,88,80,76,130,71,102,98,79,73,71,109
2021-09-27,00:07:40.507,UNC_CHA_DIR_LOOKUP.NO_SNP,1000,2102078418,1218,1280,1187,1310,1268,1287,1282,1331,1265,1267,1300,1270,1258,1307,1289,1300,1410,1378,1312,1316,1367,1337,1332,1317,1584,1519,1569,1557,1483,1537,1545,1520,1562,1527,1575,1540,1530,1581,1476,1525,1610,1680,1581,1657,1565,1613,1596,1600
2021-09-27,00:07:40.507,INST_RETIRED.ANY,1000,2102078418,705400,44587,45923,238392,53910,69547,46644,46172,44740,44732,45692,44864,46105,45352,45057,217052,46511,46671,46893,46459,53739,47021,114133,46339,61649,59027,142096,48048,98178,48288,162122,474329,48046,49795,78239,425635,105512,69933,49827,48913,71549,48451,294858,312316,149586,540477,49115,55144,46788,61681,82964,81127,116227,85776,453369,145979,81007,82269,83580,73595,73355,73751,72599,47169,47767,48191,48131,48359,48621,67664,48227,532184,49686,48704,324264,48539,48795,48609,60275,518368,116077,163734,526815,50650,140337,666605,47935,1368049,47243,337542,47153,46882,46925,62373,70186,466927
2021-09-27,00:07:40.507,CPU_CLK_UNHALTED.REF_TSC,1000,2102078418,3618636,384720,589092,2143512,766752,724164,803124,627312,541548,538188,534324,509964,535164,527436,529284,1366176,488124,491820,533148,543900,608580,577920,1145172,602196,919632,824544,1429344,692916,1092756,700644,1298640,2487156,736344,841344,1324008,1855476,1260084,1104768,658308,5805324,851424,766080,1909740,2170392,1313592,3986892,683844,986832,659064,642432,682668,772128,1076628,710220,2514876,1085112,715344,700812,676452,594468,577668,590856,574056,597996,525336,551460,548520,561624,569352,741468,623196,3124212,592032,596400,2265312,556584,593124,546756,766752,2547216,1047396,1280160,2704884,525336,1200444,3255000,497700,13643700,481572,1601040,515592,523740,503664,854280,603120,2305128
2021-09-27,00:07:40.507,CPU_CLK_UNHALTED.THREAD,1000,2102078418,1723000,183219,280560,1020631,365140,344897,382467,298699,257868,256243,254471,242757,254794,251172,252091,650377,232442,234209,253807,259024,289817,275179,545244,286717,437888,392646,680513,329759,520244,333662,618356,1184347,350594,400648,630580,1517122,599939,525847,313441,2765951,405441,364827,909395,1033366,625655,1898427,325614,881026,312798,305884,325245,367890,512845,338440,1197524,516836,341497,334581,322975,283138,275031,281300,273347,284616,250171,262581,261182,267455,271097,353013,296757,1487751,282516,283651,1076725,265489,282845,260889,365411,1212743,498705,611118,1287439,360493,571158,1549944,236616,6499483,229820,762766,245338,248648,239640,406676,287582,1714659
2021-09-27,00:07:40.507,DTLB_LOAD_MISSES.STLB_HIT,1000,2102078418,10093,1178,1186,2593,1184,1356,1182,1201,1187,1200,1191,1179,1189,1179,1177,1444,1218,1205,1158,1183,1216,1190,1789,1184,1388,1347,2207,1384,1566,1352,1541,3221,1374,1398,1580,11223,1690,1427,1398,1356,1531,1388,3429,3567,2136,2639,1354,1393,1181,1188,1457,1456,1801,1437,4698,1697,1426,1434,1418,1452,1396,1394,1434,1164,1349,1349,1356,1318,1354,1528,1349,18546,1168,1160,8935,1166,1172,1167,1194,4432,1801,2341,3152,1190,1777,4328,1178,4396,1170,1939,1199,1150,1158,1197,1187,12441
2021-09-27,00:07:40.507,L1D_PEND_MISS.PENDING_CYCLES_ANY,1000,2102078418,682630,81530,114229,363299,169260,134931,441644,183870,89947,95379,98135,81156,75366,77990,78734,178321,52738,53883,57241,56306,65514,94824,152070,227164,87723,80980,300491,70675,148506,70130,173723,628031,142178,161405,503099,383743,255465,317627,67134,1509172,105102,242908,300344,336683,157280,555052,84017,615357,526290,88531,117674,387708,192129,157226,451213,201430,103646,106302,112452,86251,83203,82880,80239,189044,72389,73820,75135,70746,84963,106517,168907,249006,117006,109389,320326,98291,168531,100734,206075,647276,167155,154684,495947,359092,257614,322235,78189,1473756,148139,278653,308380,343576,166510,556816,90475,306546
2021-09-27,00:07:40.507,MEM_INST_RETIRED.LOCK_LOADS,1000,2102078418,3462,231,235,1159,259,277,239,237,236,238,236,239,238,237,237,1114,237,237,238,237,265,237,555,237,277,278,542,237,431,240,389,906,239,238,385,3973,435,280,238,238,401,238,847,1238,604,1948,238,238,235,275,266,267,428,277,1287,399,271,277,272,239,240,239,239,237,237,237,237,237,238,347,237,4266,238,238,1174,238,238,238,270,1361,526,697,1101,238,615,2172,238,4276,236,642,236,237,236,275,299,2842
2021-09-27,00:07:40.507,UOPS_EXECUTED.X87,1000,2102078418,1152,12,13,496,46,17,27,12,11,13,10,14,11,27,12,1591,11,10,11,13,23,11,257,12,64,52,216,31,231,31,1668,5944,31,30,85,710,101,54,34,41,100,33,1852,1561,423,2348,28,46,14,23,155,57,82,172,2776,281,19,52,107,18,36,18,19,14,11,10,10,10,26,57,10,108,31,33,151,31,32,30,63,3700,361,509,4610,31,396,1814,31,5607,33,4175,31,30,32,47,78,471
2021-09-27,00:07:40.507,UNC_M_CAS_COUNT.RD,1000,2102078418,37565,33584,0,0,0,0,40306,0,37373,0,0,0
2021-09-27,00:07:40.507,UNC_M_CAS_COUNT.WR,1000,2102078418,58994,53007,0,0,0,0,25088,0,21901,0,0,0
2021-09-27,00:07:40.507,UNC_UPI_CLOCKTICKS,1000,2102078418,1300347171,1300351441,1200328715,1300297715,1300303139,1200283803
2021-09-27,00:07:40.507,UNC_UPI_TxL_FLITS.ALL_DATA,1000,2102078418,132768,150840,0,285147,269190,0
2021-09-27,00:07:40.507,UNC_UPI_TxL_FLITS.NON_DATA,1000,2102078418,298203,319302,0,293389,264875,0
2021-09-27,00:07:40.507,UNC_UPI_L1_POWER_CYCLES,1000,2102078418,0,0,1200328715,0,0,1200283803
```
The unit can be logical core, memory channel, CHA, etc, depending on the event type.


Show events available for the processor on the system:
```
pcm-raw -?
```

--------------------------------------------------------------------------------
Low-level access to Intel PMT telemetry data
--------------------------------------------------------------------------------

pcm-raw can read raw telemetry data from Intel PMT (https://github.com/intel/Intel-PMT/).

Syntax for a PMT raw telemetry counter:

```
pmt/config=<uniqueid>,config1=<sampleID>,config2=<sampleType>,config3=<lsb,config4=<msb>[,name=<description>]

```

The fields are the values for the counter from the Intel PMT aggregator XML:

* uniqueid : Intel PMT Telemetry unique identifier
* sampleID : sample ID of the counter
* sampleType counter encoding:
  -  0        : Snapshot (last value reported in csv)
  - non-zero  : Counter (delta to last value reported in csv)
* lsb : lsb field
* msb : msb field

Example for https://github.com/intel/Intel-PMT/blob/868049006ad2770a75e5fc7526fd0c4b22438e27/xml/SPR/OOBMSM/CORE/spr_aggregator.xml#L15428:
```
pmt/config=0x87b6fef1,config1=770,config2=0,config3=32,config4=63,name="Temperature_histogram_range_5_(50.5-57.5C)_counter_for_core_0"
```

Current limitations: this feature (PMT access) is currently only available on Linux (with Intel PMT Linux driver).

```

`doc/STARS.md`:

```md
## Git Hub Star History for PCM Project

[![Star History Chart](https://api.star-history.com/svg?repos=intel/pcm&type=Date)](https://star-history.com/#intel/pcm&Date)

```

`doc/WINDOWS_HOWTO.md`:

```md
**COMPILATION AND INSTALLATION OF UTILITIES**

_For support of systems with more than _**_64_**_ logical cores you need to compile all binaries below in “_**_x64_**_” platform mode (not the default “_**_Win32_**_” mode)._

## Command-line utility

1. Follow [Compile the Windows MSR driver](#compile-the-windows-msr-driver) to compile the Windows MSR driver (msr.sys). For Windows 7 and later versions you have to [sign the msr.sys driver additionally](#sign-the-windows-msr-driver). To enable loading test-signed drivers on the system: in administrator cmd console run `bcdedit /set testsigning on` and reboot.

2. Build the *pcm.exe* utility:
   ```
   cmake -B build
   cmake --build build --config Release --parallel
   ```
   alternatively you can perform `cmake -B build`, open *PCM.sln* form *build* folder in and build required project in Visual Studio.
   .exe and .dll files will be located in *build\bin\Release* folder
3. As Administrator create PCM directory in Windows "Program Files" directory (e.g. `C:\Program Files (x86)\PCM\`)
4. As Administrator copy the msr.sys driver and pcm.exe into the PCM directory
5. Run pcm.exe utility from the PCM directory as Administrator

For Windows 7+ and Windows Server 2008+ R2 the PCM utilities need to be run as Administrator:

Alternatively you can achieve the same using the “Properties” Windows menu of the executable (“Privilege level” setting in the “Compatibility” tab): Right mouse click -&gt; Properties -&gt; Compatibility -&gt; Privilege level -&gt; Set “Run this program as an administrator”.

![Screenshot](run-as-administrator.png)

If you are getting the error `Starting MSR service failed with error 3 The system cannot find the path specified.` try to uninstall the driver by running `pcm --uninstallDriver` and optionally reboot the system.

## Graphical Perfmon front end

1. Follow [Compile the windows MSR driver](#compile-the-windows-msr-driver) to compile the windows MSR driver (msr.sys). For Windows 7 and later versions you have to sign the msr.sys driver additionally ([http://msdn.microsoft.com/en-us/library/ms537361(VS.85).aspx](http://msdn.microsoft.com/en-us/library/ms537361(VS.85).aspx)).

2. Copy msr.sys into the c:\windows\system32 directory

3. Build pcm-lib.dll using Microsoft Visual Studio or cmake

4. Build 'PCM-Service.exe' using Microsoft Visual Studio or cmake

5. Copy PCM-Service.exe, PCM-Service.exe.config, and pcm-lib.dll files into the PCM sub-directory in Windows "Program Files" directory (see above)

The config file enables support for legacy security policy. Without this configuration switch, you will get an exception like this:

Unhandled Exception: System.NotSupportedException: This method implicitly uses CAS policy, which has been obsoleted by the .NET Framework.   

6. With administrator rights execute '"PCM-Service.exe" -Install' from this directory

7. With administrator rights execute 'net start pcmservice'

8. Start perfmon and find new PCM\* counters

If you do not want or cannot compile the msr.sys driver you might use a third-party open source WinRing0 driver instead (experimental only, for testing environments only).
Instructions:

1. Download the free RealTemp utility package from [http://www.techpowerup.com/realtemp/](http://www.techpowerup.com/realtemp/) or any other free utility that uses the open-source WinRing0 driver (like OpenHardwareMonitor [http://code.google.com/p/open-hardware-monitor/downloads/list](http://code.google.com/p/open-hardware-monitor/downloads/list)).
2. Copy WinRing0.dll, WinRing0.sys, WinRing0x64.dll, WinRing0x64.sys files from there into the PCM.exe binary location, into the PCM-Service.exe location and into c:\windows\system32
3. Run the PCM.exe tool and/or go to step 6 (perfmon utility).

## Compile the Windows MSR driver

1. Download Visual Studio ([Visual Studio download](https://visualstudio.microsoft.com/downloads/)).
When you install Visual Studio, also install related packages:
   - under `Workloads`, select `Desktop development with C++` 
(select `C++ CMake tools for Windows` in this workload) and `.NET desktop development`.
   - under `Individual components`, search `Libs for Spectre` and select `MSVC v143 - VS 
2022 C++ x64/x86 Spectre-mitigated libs(Latest)`.

2. Download and install SDK ([windows-sdk](https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/))

3. Download and install WDK ([windows-wdk](https://learn.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk)). Please select `Install Windows Driver Kit Visual Studio extension` when you install WDK.

4. Open **a terminal in Visual Studio**, then go to `src\WinMSRDriver`, and run the following command to compile the driver. Then you will see `MSR.sys` in `src\WinMSRDriver\x64\Release`.
    ```
    MSBuild.exe MSR.vcxproj -property:Configuration=Release -property:Platform=x64
    ```

## Sign the Windows MSR driver

Run the following in PowerShell, in the directory where `MSR.sys` is located:

```
$cert = New-SelfSignedCertificate -Type CodeSigning -Subject "CN=TestCert" -CertStoreLocation "Cert:\CurrentUser\My" -KeyExportPolicy Exportable
$pwd = Read-Host -Prompt "Enter the password for the PFX file" -AsSecureString
Export-PfxCertificate -Cert $cert -FilePath TestCert.pfx -Password $pwd
signtool sign /fd SHA256 /f TestCert.pfx /p ([Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($pwd))) /t http://timestamp.digicert.com MSR.sys
```

Afterwards, double-click `TestCert.pfx`. Install to "Current User" and when able to pick "Place all ...", browse for "Trusted Root Certification Authorities".

## Known limitations

Running PCM.exe under Cygwin shell is possible, but due to incompatibilities of signals/events handling between Windows and Cygwin, the PCM may not cleanup PMU configuration after Ctrl+C or Ctrl+Break pressed. The subsequent run of PCM will require to do PMU configuration reset, so adding -r command line option to PCM will be required.

PCM-Service FAQ:
Q: Help my service won't start, what can I do to diagnose the problem?
A: Please check in the Windows Application "Event Viewer" under "Windows Logs" and then under "Application". PCM-Service writes its messages here, just look for errors. If you can't figure it out how to fix it, create a bug report and make sure to paste the text from the Event Viewer in the bug report so we can diagnose the issue.

Q: I see a message in the Events Viewer that PCM-Service does not start because the "custom counter file view is out of memory", how do I fix this?
A: Despite that PCM-Service is reserving more memory than the standard 512kB this error can still occur if there is another application that uses performance counters is initialized before PCM. There are two options:
1. identify the application or service that starts before PCM-Service and stop or disable it and consequently reboot and try again
2. [find your machine.config file](https://stackoverflow.com/questions/2325473/where-is-machine-config) and add
`<system.diagnostics>
<performanceCounters filemappingsize="2097152" />
</system.diagnostics>`
to that file

## pcm-sensor-server (HTTP/HTTPS server for Grafana integration)

Starting from this release, **pcm-sensor-server** is now supported on Windows. This utility exposes PCM metrics over HTTP in JSON or Prometheus format for integration with Grafana dashboards.

### Building pcm-sensor-server on Windows

1. Follow the **Compile the Windows MSR driver** and **Sign the Windows MSR driver** sections above to compile, sign, and install the MSR driver (`msr.sys`)

2. Build pcm-sensor-server:
   ```
   cmake -B build
   cmake --build build --config Release --target pcm-sensor-server
   ```
   
   The executable will be located in `build\bin\Release\pcm-sensor-server.exe`

3. (Optional) For HTTPS support, ensure OpenSSL is installed and available to CMake

### Running pcm-sensor-server on Windows

1. Create a directory for PCM in a protected location (e.g., `C:\Program Files\PCM\` or `C:\Program Files (x86)\PCM\`). Copy `msr.sys` and `pcm-sensor-server.exe` to this directory. **Important:** Do not place PCM binaries in user-writable directories (e.g., Downloads, Desktop, `C:\Users\Public\`) to prevent DLL planting attacks.

2. Run as Administrator (required for MSR access):
   ```
   pcm-sensor-server.exe
   ```
   
   The server will start on the default port 9738

3. Common command-line options:
   - `-p <port>` : Run on a specific port (default is 9738)
   - `-D <level>` : Set debug verbosity level (0 = no debug, higher = more verbose)
   - `-s` : Enable HTTPS (requires OpenSSL and certificate files)
   - `-h` or `--help` : Show all available options

4. Access the metrics:
   - JSON format: http://localhost:9738/ (with `Accept: application/json` header)
   - Prometheus format: http://localhost:9738/metrics

### Windows-specific limitations

- **Daemon mode not supported**: The `-d` (daemon/background) option is not available on Windows. The server runs in foreground mode only.
- **Real-time priority not supported**: The `-R` (real-time priority) option is not available on Windows.
- **Signal handling**: Use Ctrl+C to gracefully stop the server instead of SIGTERM/SIGINT.

### Example: Running with Grafana on Windows

1. Start pcm-sensor-server as Administrator:
   ```
   pcm-sensor-server.exe -p 9738
   ```

2. Configure Prometheus to scrape from `http://localhost:9738/metrics`

3. Configure Grafana to use your Prometheus data source

4. Import the PCM Grafana dashboard (see [scripts/grafana/README.md](../scripts/grafana/README.md))

For more details on using pcm-sensor-server with Grafana, see [PCM-EXPORTER.md](PCM-EXPORTER.md).

```

`doc/generate_summary_readme.md`:

```md
Step 1

```pip3 install pipreqs```

Step 2

```cd /path/to/pcm/scripts```

Step 3

```python3 -m  pipreqs.pipreqs --encoding utf-8 .```

Step 4

```pip3 install -r requirements.txt```

Step 5

```python3 generate_summary.py --help```

Step 6

```python3 generate_summary.py <filename.csv> -{argument1} -{argument2} ....-{argumentN}```
 


```

`doc/license.txt`:

```txt
This notice belongs to the code originating from "Intel Performance Counter Monitor".

Copyright (c) 2009-2016, Intel Corporation
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of Intel Corporation nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


```

`docker-compose.yml`:

```yml
version: '2.0'
services:
    pcm:
       image: ghcr.io/intel/pcm:latest
       ports:
           - "9738:9738"
       volumes:
           - "/sys/firmware/acpi/tables/MCFG:/pcm/sys/firmware/acpi/tables/MCFG:ro"
           - "/proc/bus/pci/:/pcm/proc/bus/pci/"
           - "/proc/sys/kernel/nmi_watchdog:/pcm/proc/sys/kernel/nmi_watchdog"
           - "/sys:/sys:rw"
       cap_add:
           - SYS_ADMIN
           - SYS_RAWIO
       devices:
           - /dev/cpu
           - /dev/mem

```

`examples/CMakeLists.txt`:

```txt
# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2022, Intel Corporation

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin/examples)

# Linux examples
if(UNIX)
    # Example part
    file(GLOB EXAMPLE_FILE c_example.c)

    # create static lib example
    add_executable(c_example ${EXAMPLE_FILE})
    add_dependencies(c_example PCM_SHARED)
    set_target_properties(c_example PROPERTIES
      BUILD_WITH_INSTALL_RPATH TRUE
      INSTALL_RPATH_USE_LINK_PATH TRUE
      INSTALL_RPATH "${CMAKE_BINARY_DIR}/lib:${INSTALL_RPATH}")   # rpath to libpcm.so
    target_compile_definitions(c_example PRIVATE PCM_DYNAMIC_LIB) # -DPCM_DYNAMIC_LIB
    target_link_libraries(c_example PRIVATE Threads::Threads dl)  # -pthread -ldl

    # create shared lib example
    add_executable(c_example_shlib ${EXAMPLE_FILE})
    target_link_libraries(c_example_shlib PUBLIC PCM_SHARED PRIVATE Threads::Threads)

    # numa_to_socket_example
    if(NOT APPLE)
        add_executable(numa_to_socket_example numa_to_socket_example.cpp)
        target_link_libraries(numa_to_socket_example PUBLIC PCM_SHARED PRIVATE Threads::Threads)
    endif()
endif(UNIX)

```

`examples/c_example.c`:

```c
#include <stdio.h>
#include <dlfcn.h>
#include <stdint.h>
#include <stdlib.h>

int pcm_getcpu()
{
	int id = -1;
	asm volatile (
		"rdtscp\n\t"
		"mov %%ecx, %0\n\t":
		"=r" (id) :: "%rax", "%rcx", "%rdx");
	// processor ID is in ECX: https://www.felixcloutier.com/x86/rdtscp
	// Linux encodes the NUMA node starting at bit 12, so remove the NUMA
	// bits when returning the CPU integer by masking with 0xFFF.
	return id & 0xFFF;
}

struct {
	int (*pcm_c_build_core_event)(uint8_t id, const char * argv);
	int (*pcm_c_init)();
	void (*pcm_c_start)();
	void (*pcm_c_stop)();
	uint64_t (*pcm_c_get_cycles)(uint32_t core_id);
	uint64_t (*pcm_c_get_instr)(uint32_t core_id);
	uint64_t (*pcm_c_get_core_event)(uint32_t core_id, uint32_t event_id);
} PCM; // lgtm [cpp/short-global-name]

#ifndef PCM_DYNAMIC_LIB
/* Library functions declaration (instead of .h file) */
int pcm_c_build_core_event(uint8_t, const char *);
int pcm_c_init();
void pcm_c_start();
void pcm_c_stop();
uint64_t pcm_c_get_cycles(uint32_t);
uint64_t pcm_c_get_instr(uint32_t);
uint64_t pcm_c_get_core_event(uint32_t, uint32_t);
#endif


int main(int argc, const char *argv[])
{
	int i,a[100],b[100],c[100];
	uint32_t total = 0;
	int lcore_id;
    int numEvents = argc - 1;

	/* Seed for predictable rand() results */
	srand(0);
	for (i=0; i < 100; ++i) {
		a[i] = rand();
		b[i] = rand();
		c[i] = rand();
	}

#ifdef PCM_DYNAMIC_LIB
	void * handle = dlopen("libpcm.so", RTLD_LAZY);
	if(!handle) {
		printf("Abort: could not (dynamically) load shared library \n");
		return -1;
	}

	PCM.pcm_c_build_core_event = (int (*)(uint8_t, const char *)) dlsym(handle, "pcm_c_build_core_event");
	PCM.pcm_c_init = (int (*)()) dlsym(handle, "pcm_c_init");
	PCM.pcm_c_start = (void (*)()) dlsym(handle, "pcm_c_start");
	PCM.pcm_c_stop = (void (*)()) dlsym(handle, "pcm_c_stop");
	PCM.pcm_c_get_cycles = (uint64_t (*)(uint32_t)) dlsym(handle, "pcm_c_get_cycles");
	PCM.pcm_c_get_instr = (uint64_t (*)(uint32_t)) dlsym(handle, "pcm_c_get_instr");
	PCM.pcm_c_get_core_event = (uint64_t (*)(uint32_t,uint32_t)) dlsym(handle, "pcm_c_get_core_event");
#else
	PCM.pcm_c_build_core_event = pcm_c_build_core_event;
	PCM.pcm_c_init = pcm_c_init;
	PCM.pcm_c_start = pcm_c_start;
	PCM.pcm_c_stop = pcm_c_stop;
	PCM.pcm_c_get_cycles = pcm_c_get_cycles;
	PCM.pcm_c_get_instr = pcm_c_get_instr;
	PCM.pcm_c_get_core_event = pcm_c_get_core_event;
#endif

	if(PCM.pcm_c_init == NULL || PCM.pcm_c_start == NULL || PCM.pcm_c_stop == NULL ||
			PCM.pcm_c_get_cycles == NULL || PCM.pcm_c_get_instr == NULL ||
			PCM.pcm_c_build_core_event == NULL || PCM.pcm_c_get_core_event == NULL)
		return -1;

    if (numEvents > 4)
    {
        printf("Number of arguments are too many! exit...\n");
        return -2;
    }

    for (i = 0; i < numEvents; ++i)
    {
        PCM.pcm_c_build_core_event(i, argv[i+1]);
    }

	printf("[c_example] Initializing PCM measurements:\n");
	PCM.pcm_c_init();

	printf("[c_example] Calling PCM start()\n");
	PCM.pcm_c_start();
	for(i=0;i<10000;i++)
		c[i%100] = 4 * a[i%100] + b[i%100];
	for(i=0;i<100;i++)
		total += c[i];
	PCM.pcm_c_stop();

	printf("[c_example] PCM measurement stopped, compute result %u\n", total);

	lcore_id = pcm_getcpu();
	printf("C:%llu I:%llu, IPC:%3.2f\n",
		(unsigned long long)PCM.pcm_c_get_cycles(lcore_id),
		(unsigned long long)PCM.pcm_c_get_instr(lcore_id),
		(double)PCM.pcm_c_get_instr(lcore_id)/PCM.pcm_c_get_cycles(lcore_id));
	printf("CPU%d E0: %llu, E1: %llu, E2: %llu, E3: %llu\n",
		lcore_id,
		(unsigned long long)PCM.pcm_c_get_core_event(lcore_id,0),
		(unsigned long long)PCM.pcm_c_get_core_event(lcore_id,1),
		(unsigned long long)PCM.pcm_c_get_core_event(lcore_id,2),
		(unsigned long long)PCM.pcm_c_get_core_event(lcore_id,3));

	return 0;
}

```

`examples/numa_node_example.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2024, Intel Corporation
// Example: How to retrieve NUMA node location for PCI devices

#include <iostream>
#include <iomanip>
#include "pci.h"

using namespace pcm;

int main()
{
    std::cout << "Example: Retrieving NUMA node location for PCI devices\n";
    std::cout << "========================================================\n\n";
    
    // Example 1: Get NUMA node for a specific PCI device
    // Format: segment (or group):bus:device.function
    uint32 segment = 0;    // Also known as "domain" or "group"
    uint32 bus = 0;
    uint32 device = 0;
    uint32 function = 0;
    
    try
    {
        // Create a handle to the PCI device
        // On Linux: uses /proc/bus/pci/ or PciHandleMM for memory-mapped access
        // On Windows: uses Windows driver
        // On FreeBSD: uses /dev/pci
        // On macOS: uses PCIDriver
        PciHandleType handle(segment, bus, device, function);
        
        std::cout << "Successfully opened PCI device " 
                  << segment << ":" << bus << ":" << device << "." << function << "\n";
        
        // Get the NUMA node location
        int32 numa_node = handle.getNUMANode();
        
        std::cout << "NUMA node: ";
        if (numa_node >= 0)
        {
            std::cout << numa_node << "\n";
        }
        else
        {
            std::cout << "Not available (return value: " << numa_node << ")\n";
            std::cout << "Note: -1 means NUMA information is not available on this platform\n";
            std::cout << "      or the PCI device does not have NUMA node association.\n";
        }
        
        // You can also read PCI configuration space as usual
        uint32 vendor_device_id = 0;
        if (handle.read32(0, &vendor_device_id) == sizeof(uint32))
        {
            uint32 vendor_id = vendor_device_id & 0xFFFF;
            uint32 device_id = (vendor_device_id >> 16) & 0xFFFF;
            std::cout << "\nPCI Device Info:\n";
            std::cout << "  Vendor ID: 0x" << std::hex << std::setw(4) << std::setfill('0') 
                      << vendor_id << "\n";
            std::cout << "  Device ID: 0x" << std::setw(4) << std::setfill('0') 
                      << device_id << std::dec << "\n";
        }
    }
    catch (const std::exception& e)
    {
        std::cerr << "Error: " << e.what() << "\n";
        std::cerr << "\nPossible reasons:\n";
        std::cerr << "  - PCI device does not exist\n";
        std::cerr << "  - Insufficient permissions (try running as root/administrator)\n";
        std::cerr << "  - PCI subsystem not available on this platform\n";
        return 1;
    }
    
    std::cout << "\n=== Example completed successfully ===\n";
    return 0;
}

```

`examples/numa_to_socket_example.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2025, Intel Corporation
// Example: How to map NUMA node IDs to CPU socket IDs

#include <iostream>
#include <iomanip>
#include "../src/cpucounters.h"

using namespace pcm;

int main()
{
    std::cout << "Example: Mapping NUMA node IDs to CPU socket IDs\n";
    std::cout << "==================================================\n\n";
    
    // Get PCM instance
    PCM * m = PCM::getInstance();
    
    // Initialize PCM
    PCM::ErrorCode status = m->program();
    if (status != PCM::Success)
    {
        std::cerr << "Error: Cannot access CPU counters\n";
        std::cerr << "Try running as root/administrator\n";
        std::cerr << "Error code: " << status << "\n";
        return 1;
    }
    
    std::cout << "System Information:\n";
    std::cout << "-------------------\n";
    std::cout << "Number of sockets: " << m->getNumSockets() << "\n";
    std::cout << "Number of cores:   " << m->getNumCores() << "\n";
    std::cout << "Number of online cores: " << m->getNumOnlineCores() << "\n\n";
    
    // Example: Map NUMA nodes to sockets
    std::cout << "NUMA Node to Socket Mapping:\n";
    std::cout << "----------------------------\n";
    
    // Try to map the first few NUMA nodes (typically 0-7 is sufficient)
    const uint32 max_numa_nodes_to_check = 8;
    bool found_any = false;
    
    for (uint32 numa_node = 0; numa_node < max_numa_nodes_to_check; ++numa_node)
    {
        int32 socket_id = m->mapNUMANodeToSocket(numa_node);
        
        if (socket_id >= 0)
        {
            std::cout << "  NUMA node " << numa_node 
                      << " -> Socket " << socket_id << "\n";
            found_any = true;
        }
    }
    
    if (!found_any)
    {
        std::cout << "  No NUMA node mappings available\n";
        std::cout << "\nNote: This is normal on:\n";
        std::cout << "  - Single-socket systems\n";
        std::cout << "  - Systems without NUMA support\n";
        std::cout << "  - macOS (not implemented)\n";
        std::cout << "  - FreeBSD without NUMA enabled (vm.ndomains <= 1)\n";
    }
    
    std::cout << "\n";
    
    // Example: Show relationship between cores and sockets
    std::cout << "Core to Socket Mapping (first 8 cores):\n";
    std::cout << "----------------------------------------\n";
    const uint32 cores_to_show = std::min((uint32)8, m->getNumCores());
    for (uint32 core = 0; core < cores_to_show; ++core)
    {
        int32 socket = m->getSocketId(core);
        std::cout << "  Core " << core << " -> Socket " << socket << "\n";
    }
    
    std::cout << "\n=== Example completed successfully ===\n";
    
    // Cleanup
    m->cleanup();
    
    return 0;
}

```

`pcm-kubernetes.yaml.experimental`:

```experimental
---
apiVersion: v1
kind: Namespace
metadata:
  name: intel-pcm
  labels: # uses host features by design privileges required
    pod-security.kubernetes.io/enforce: privileged
    pod-security.kubernetes.io/enforce-version: latest
    pod-security.kubernetes.io/audit: privileged
    pod-security.kubernetes.io/audit-version: latest
    pod-security.kubernetes.io/warn: privileged
    pod-security.kubernetes.io/warn-version: latest
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  labels:
    app.kubernetes.io/instance: pcm
    app.kubernetes.io/name: intel-pcm
    app.kubernetes.io/part-of: intel-pcm
  name: intel-pcm
  namespace: intel-pcm
spec:
  selector:
    matchLabels:
      app.kubernetes.io/component: pcm-sensor-server
      app.kubernetes.io/instance: pcm
      app.kubernetes.io/name: intel-pcm
  template:
    metadata:
      labels:
        app.kubernetes.io/component: pcm-sensor-server
        app.kubernetes.io/instance: pcm
        app.kubernetes.io/name: intel-pcm
        app.kubernetes.io/part-of: intel-pcm
        jobLabel: pcm
    spec:
      automountServiceAccountToken: false
      hostUsers: true
      containers:
      - image: ghcr.io/intel/pcm:latest
        env:
        - name: PCM_NO_MSR
          value: "1"
        - name: PCM_IGNORE_ARCH_PERFMON
          value: "0"
        - name: PCM_NO_PERF
          value: "0"
        livenessProbe:
          failureThreshold: 3
          httpGet:
            path: /
            port: 9738
            scheme: HTTP
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        name: intel-pcm
        ports:
        - containerPort: 9738
          hostPort: 9738
          name: pcm-metrics
          protocol: TCP
        readinessProbe:
          failureThreshold: 3
          httpGet:
            path: /
            port: 9738
            scheme: HTTP
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        securityContext:
          privileged: false
          runAsNonRoot: false
          runAsUser: 0
          readOnlyRootFilesystem: true
          capabilities:
            add:
            - SYS_ADMIN
            - SYS_RAWIO
          seccompProfile:
            type: RuntimeDefault
        volumeMounts:
        - mountPath: /dev/cpu
          name: dev-cpu
          readOnly: true
        - mountPath: /dev/mem
          name: dev-mem
          readOnly: true
        - mountPath: /pcm/proc/bus/pci
          name: proc-pci
          readOnly: true
        - mountPath: /pcm/sys/firmware/acpi/tables/MCFG
          name: sys-acpi
          readOnly: true
        - mountPath: /pcm/proc/sys/kernel/nmi_watchdog
          name: nmi-watchdog
          readOnly: true
        - mountPath: /sys
          name: sysfs
          readOnly: false
      nodeSelector:
        kubernetes.io/os: linux
        feature.node.kubernetes.io/cpu-model.vendor_id: Intel # node feature discovery populates this
      volumes:
      - hostPath:
          path: /dev/cpu
        name: dev-cpu
      - hostPath:
          path: /dev/mem
        name: dev-mem
      - hostPath:
          path: /sys
        name: sysfs
      - hostPath:
          path: /sys/firmware/acpi/tables/MCFG
        name: sys-acpi
      - hostPath:
          path: /proc/bus/pci
        name: proc-pci
      - hostPath:
          path: /proc/sys/kernel/nmi_watchdog
        name: nmi-watchdog
---
# prometheus operator defines this CRD
apiVersion: monitoring.coreos.com/v1
kind: PodMonitor
metadata:
  labels:
    app.kubernetes.io/instance: pcm
    app.kubernetes.io/name: intel-pcm
    app.kubernetes.io/part-of: intel-pcm
    app.kubernetes.io/component: metrics
    jobLabel: pcm
    prometheus.io/podmonitor: system-metrics
    release: prometheus
  name: pcm
  namespace: intel-pcm
spec:
  attachMetadata:
    node: true
  jobLabel: jobLabel
  namespaceSelector:
    matchNames:
    - intel-pcm
  podMetricsEndpoints:
  - enableHttp2: false
    filterRunning: true
    followRedirects: false
    honorLabels: true
    honorTimestamps: true
    path: /metrics
    port: pcm-metrics
    interval: 1s
    relabelings:
    - sourceLabels:
      - __meta_kubernetes_pod_node_name
      targetLabel: nodename
    scheme: http
  selector:
    matchLabels:
      app.kubernetes.io/component: pcm-sensor-server
      app.kubernetes.io/instance: pcm
      app.kubernetes.io/name: intel-pcm

```

`pcm.spec`:

```spec

Name:            pcm
Version:         master
Release:         0
Summary:         Intel(r) Performance Counter Monitor
Group:           System/Monitoring
License:         BSD-3-Clause
Url:             https://github.com/intel/pcm
Source:          %{version}.zip
Source1:         https://github.com/intel/perfmon/archive/main.zip
BuildRoot:       %{_tmppath}/%{name}-%{version}-build
AutoReqProv:     on
BuildRequires:   unzip
BuildRequires:   gcc
BuildRequires:   make
BuildRequires:   gcc-c++
BuildRequires:   cmake
%if 0%{?suse_version}
BuildRequires:   libopenssl-devel
%else
BuildRequires:   openssl-devel
BuildRequires:   libasan
%endif


%description

Intel(r) Performance Counter Monitor (Intel(r) PCM) is an application programming interface (API) and a set of tools based on the API to monitor performance and energy metrics of Intel(r) Core(tm), Xeon(r), Atom(tm) and Xeon Phi(tm) processors. PCM works on Linux, Windows, Mac OS X, FreeBSD and DragonFlyBSD operating systems.

%prep
%setup -n pcm-master
rm -rf perfmon
unzip $RPM_SOURCE_DIR/main.zip
mv perfmon-main perfmon

%build
mkdir build
cd build
cmake -DPCM_NO_STATIC_LIBASAN=ON -DCMAKE_INSTALL_PREFIX=/usr/ -DCMAKE_BUILD_TYPE=RelWithDebInfo ..
make -j 

%install
rm -rf $RPM_BUILD_ROOT
cd build
make install DESTDIR=$RPM_BUILD_ROOT

%clean
rm -rf $RPM_BUILD_ROOT

%post
%postun

%files
%defattr(-,root,root,0755)
%doc LICENSE doc/LINUX_HOWTO.txt
/usr/share/doc/PCM
/usr/share/licenses/pcm
/usr/share/doc/PCM/CUSTOM-COMPILE-OPTIONS.md
/usr/share/doc/PCM/DOCKER_README.md
/usr/share/doc/PCM/ENVVAR_README.md
/usr/share/doc/PCM/FAQ.md
/usr/share/doc/PCM/FREEBSD_HOWTO.txt
/usr/share/doc/PCM/LINUX_HOWTO.txt
/usr/share/doc/PCM/MAC_HOWTO.txt
/usr/share/doc/PCM/PCM-EXPORTER.md
/usr/share/doc/PCM/PCM-SENSOR-SERVER-README.md
/usr/share/doc/PCM/PCM_RAW_README.md
/usr/share/doc/PCM/README.md
/usr/share/doc/PCM/WINDOWS_HOWTO.md
/usr/share/doc/PCM/license.txt
/usr/share/licenses/pcm/LICENSE
%{_sbindir}/pcm-core
%{_sbindir}/pcm-iio
%{_sbindir}/pcm-latency
%{_sbindir}/pcm-memory
%{_sbindir}/pcm-msr
%{_sbindir}/pcm-mmio
%{_sbindir}/pcm-tpmi
%{_sbindir}/pcm-numa
%{_sbindir}/pcm-pcicfg
%{_sbindir}/pcm-accel
%{_sbindir}/pcm-pcie
%{_sbindir}/pcm-power
%{_sbindir}/pcm-sensor
%{_sbindir}/pcm-sensor-server
%{_sbindir}/pcm-tsx
%{_sbindir}/pcm-raw
%{_sbindir}/pcm
%{_bindir}/pcm-client
%{_sbindir}/pcm-daemon
%{_sbindir}/pcm-bw-histogram
%{_datadir}/pcm/

%changelog
* Mon Feb 28 2022 - roman.dementiev@intel.com
        add addition doc files
* Tue Jan 04 2022 - maria.markova@intel.com
        Add cmake adaptation
* Fri Dec 17 2021 - maria.markova@intel.com
        Move licence.txt Linix_HOWTO.txt to doc folder
* Tue Aug 25 2020 - roman.dementiev@intel.com
        Add pcm-raw under %files
* Wed Apr 01 2020 - otto.g.bruggeman@intel.com
        Add pcm-sensor-server under %files
* Mon Nov 25 2019 - roman.dementiev@intel.com
        call make install and use _sbindir or _bindir
* Mon Oct 21 2019 - roman.dementiev@intel.com
	add opCode file to /usr/share/pcm
	use "install" to copy pcm-bw-histogram.sh
* Fri Oct 18 2019 - roman.dementiev@intel.com
	created spec file

```

`scripts/bhs-power-mode.ps1`:

```ps1
Write-Output "Intel(r) Performance Counter Monitor"
Write-Output "Birch Stream Power Mode Utility"
Write-Output ""

Write-Output " Options:"
Write-Output " --optimized-power-mode   : set optimized power mode"
Write-Output " --latency-optimized-mode : set latency optimized mode"
Write-Output ""

# Run the pcm-tpmi command to determine I/O and compute dies
$output = pcm-tpmi 2 0x10 -d -b 26:26

# Parse the output to build lists of I/O and compute dies
# Store as "instance:entry" to handle multiple instances per socket
$io_dies = @()
$compute_dies = @()
$die_types = @{}

$output -split "`n" | ForEach-Object {
    $line = $_
    if ($line -match "entry" -and $line -match "instance") {
        $entry = $line -match 'entry (\d+)' | Out-Null; $matches[1]
        $instance = $line -match 'instance (\d+)' | Out-Null; $matches[1]
        $die_key = "${instance}:${entry}"
        if ($line -match "value 1") {
            $die_types[$die_key] = "IO"
            $io_dies += $die_key
        } elseif ($line -match "value 0") {
            $die_types[$die_key] = "Compute"
            $compute_dies += $die_key
        }
    }
}

if ($args[0] -eq "--optimized-power-mode") {
    Write-Output "Setting optimized power mode..."

    foreach ($die_key in $io_dies) {
        $instance = $die_key -split ":" | Select-Object -First 1
        $entry = $die_key -split ":" | Select-Object -Last 1
        # EFFICIENCY_LATENCY_CTRL_RATIO (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 28:22 -w 8 

        # EFFICIENCY_LATENCY_CTRL_LOW_THRESHOLD (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 38:32 -w 13

        # EFFICIENCY_LATENCY_CTRL_HIGH_THRESHOLD (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 46:40 -w 120

        # EFFICIENCY_LATENCY_CTRL_HIGH_THRESHOLD_ENABLE (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 39:39 -w 1
    }

    foreach ($die_key in $compute_dies) {
        $instance = $die_key -split ":" | Select-Object -First 1
        $entry = $die_key -split ":" | Select-Object -Last 1
        # EFFICIENCY_LATENCY_CTRL_RATIO (Uncore Compute)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 28:22 -w 12
    }
}

if ($args[0] -eq "--latency-optimized-mode") {
    Write-Output "Setting latency optimized mode..."

    foreach ($die_key in $io_dies) {
        $instance = $die_key -split ":" | Select-Object -First 1
        $entry = $die_key -split ":" | Select-Object -Last 1
        # EFFICIENCY_LATENCY_CTRL_RATIO (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 28:22 -w 0

        # EFFICIENCY_LATENCY_CTRL_LOW_THRESHOLD (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 38:32 -w 0

        # EFFICIENCY_LATENCY_CTRL_HIGH_THRESHOLD (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 46:40 -w 0

        # EFFICIENCY_LATENCY_CTRL_HIGH_THRESHOLD_ENABLE (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 39:39 -w 1
    }

    foreach ($die_key in $compute_dies) {
        $instance = $die_key -split ":" | Select-Object -First 1
        $entry = $die_key -split ":" | Select-Object -Last 1
        # EFFICIENCY_LATENCY_CTRL_RATIO (Uncore Compute)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 28:22 -w 0
    }
}

Write-Output "Dumping TPMI Power control register states..."
Write-Output ""

# Function to extract and calculate metrics from the value
function ExtractAndPrintMetrics {
    param (
        [int]$value,
        [int]$socket_id,
        [string]$die_key,
        [string]$numa_node,
        [int]$instance
    )

    $die_type = $die_types[$die_key]
    
    # Extract instance and entry from die_key
    $inst = $die_key -split ":" | Select-Object -First 1
    $entry = $die_key -split ":" | Select-Object -Last 1

    # Extract bits and calculate metrics
    $min_ratio = ($value -shr 15) -band 0x7F
    $max_ratio = ($value -shr 8) -band 0x7F
    $eff_latency_ctrl_ratio = ($value -shr 22) -band 0x7F
    $eff_latency_ctrl_low_threshold = ($value -shr 32) -band 0x7F
    $eff_latency_ctrl_high_threshold = ($value -shr 40) -band 0x7F
    $eff_latency_ctrl_high_threshold_enable = ($value -shr 39) -band 0x1

    # Convert to MHz or percentage
    $min_ratio = $min_ratio * 100
    $max_ratio = $max_ratio * 100
    $eff_latency_ctrl_ratio = $eff_latency_ctrl_ratio * 100
    $eff_latency_ctrl_low_threshold = ($eff_latency_ctrl_low_threshold * 100) / 127
    $eff_latency_ctrl_high_threshold = ($eff_latency_ctrl_high_threshold * 100) / 127

    # Print metrics
    $output_str = "Socket ID: $socket_id"
    if ($numa_node) {
        $output_str += ", NUMA node: $numa_node"
    }
    $output_str += ", instance: $instance, Die: $entry, Type: $die_type"
    Write-Output $output_str
    Write-Output "MIN_RATIO: $min_ratio MHz"
    Write-Output "MAX_RATIO: $max_ratio MHz"
    Write-Output "EFFICIENCY_LATENCY_CTRL_RATIO: $eff_latency_ctrl_ratio MHz"
    if ($die_type -eq "IO") {
        Write-Output "EFFICIENCY_LATENCY_CTRL_LOW_THRESHOLD: $eff_latency_ctrl_low_threshold%"
        Write-Output "EFFICIENCY_LATENCY_CTRL_HIGH_THRESHOLD: $eff_latency_ctrl_high_threshold%"
        Write-Output "EFFICIENCY_LATENCY_CTRL_HIGH_THRESHOLD_ENABLE: $eff_latency_ctrl_high_threshold_enable"
    }
    Write-Output ""
}

# Iterate over all dies and run pcm-tpmi for each to get the metrics
foreach ($die_key in $die_types.Keys) {
    $instance = $die_key -split ":" | Select-Object -First 1
    $entry = $die_key -split ":" | Select-Object -Last 1
    $output = pcm-tpmi 2 0x18 -d -i $instance -e $entry

    # Parse the output and extract metrics for each socket
    $output -split "`n" | ForEach-Object {
        $line = $_
        if ($line -match "Read value") {
            $value = $line -match 'value (\d+)' | Out-Null; $matches[1]
            $inst = $line -match 'instance (\d+)' | Out-Null; $matches[1]
            $ent = $line -match 'entry (\d+)' | Out-Null; $matches[1]
            $parsed_die_key = "${inst}:${ent}"
            # Extract socket ID if present, otherwise fallback to instance ID
            if ($line -match '\(socket (\d+)\)') {
                $socket_id = $matches[1]
            } else {
                $socket_id = $inst
            }
            # Extract NUMA node if present
            $numa_node = $null
            if ($line -match '\(NUMA node (\d+)\)') {
                $numa_node = $matches[1]
            }
            ExtractAndPrintMetrics -value $value -socket_id $socket_id -die_key $parsed_die_key -numa_node $numa_node -instance $inst
        }
    }
}
```

`scripts/bhs-power-mode.sh`:

```sh
#!/bin/bash

echo "Intel(r) Performance Counter Monitor"
echo "Birch Stream Power Mode Utility"
echo ""

echo " Options:"
echo " --optimized-power-mode   : set optimized power mode"
echo " --latency-optimized-mode : set latency optimized mode"
echo

# Run the pcm-tpmi command to determine I/O and compute dies
output=$(pcm-tpmi 2 0x10 -d -b 26:26)

# Parse the output to build lists of I/O and compute dies
# Store as "instance:entry" to handle multiple instances per socket
io_dies=()
compute_dies=()
declare -A die_types
while read -r line; do
    if [[ $line == *"entry"* && $line == *"instance"* ]]; then
        entry=$(echo "$line" | grep -oP 'entry \K[0-9]+')
        instance=$(echo "$line" | grep -oP 'instance \K[0-9]+')
        die_key="${instance}:${entry}"
        if [[ $line == *"value 1"* ]]; then
            die_types[$die_key]="IO"
	    io_dies+=("$die_key")
        elif [[ $line == *"value 0"* ]]; then
            die_types[$die_key]="Compute"
	    compute_dies+=("$die_key")
        fi
    fi
done <<< "$output"

if [ "$1" == "--optimized-power-mode" ]; then
	echo "Setting optimized power mode..."

    for die_key in "${io_dies[@]}"; do
        instance="${die_key%:*}"
        entry="${die_key#*:}"
        # EFFICIENCY_LATENCY_CTRL_RATIO (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 28:22 -w 8 

        #EFFICIENCY_LATENCY_CTRL_LOW_THRESHOLD (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 38:32 -w 13

        #EFFICIENCY_LATENCY_CTRL_HIGH_THRESHOLD(Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 46:40 -w 120

        #EFFICIENCY_LATENCY_CTRL_HIGH_THRESHOLD_ENABLE (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 39:39 -w 1
    done

    for die_key in "${compute_dies[@]}"; do
        instance="${die_key%:*}"
        entry="${die_key#*:}"
	 # EFFICIENCY_LATENCY_CTRL_RATIO (Uncore Compute)
	 pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 28:22 -w 12
    done

fi

if [ "$1" == "--latency-optimized-mode" ]; then
    echo "Setting latency optimized mode..."

    for die_key in "${io_dies[@]}"; do
        instance="${die_key%:*}"
        entry="${die_key#*:}"
        # EFFICIENCY_LATENCY_CTRL_RATIO (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 28:22 -w 0

        #EFFICIENCY_LATENCY_CTRL_LOW_THRESHOLD (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 38:32 -w 0

        #EFFICIENCY_LATENCY_CTRL_HIGH_THRESHOLD(Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 46:40 -w 0

        #EFFICIENCY_LATENCY_CTRL_HIGH_THRESHOLD_ENABLE (Uncore IO)
        pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 39:39 -w 1
    done

    for die_key in "${compute_dies[@]}"; do
        instance="${die_key%:*}"
        entry="${die_key#*:}"
         # EFFICIENCY_LATENCY_CTRL_RATIO (Uncore Compute)
         pcm-tpmi 2 0x18 -d -i $instance -e $entry -b 28:22 -w 0
    done

fi


echo "Dumping TPMI Power control register states..."
echo ""

# Function to extract and calculate metrics from the value
extract_and_print_metrics() {
    local value=$1
    local socket_id=$2
    local die_key=$3
    local numa_node=$4
    local instance=$5
    local die_type=${die_types[$die_key]}
    
    # Extract instance and entry from die_key
    local inst="${die_key%:*}"
    local entry="${die_key#*:}"

    # Extract bits and calculate metrics
    local min_ratio=$(( (value >> 15) & 0x7F ))
    local max_ratio=$(( (value >> 8) & 0x7F ))
    local eff_latency_ctrl_ratio=$(( (value >> 22) & 0x7F ))
    local eff_latency_ctrl_low_threshold=$(( (value >> 32) & 0x7F ))
    local eff_latency_ctrl_high_threshold=$(( (value >> 40) & 0x7F ))
    local eff_latency_ctrl_high_threshold_enable=$(( (value >> 39) & 0x1 ))

    # Convert to MHz or percentage
    min_ratio=$(( min_ratio * 100 ))
    max_ratio=$(( max_ratio * 100 ))
    eff_latency_ctrl_ratio=$(( eff_latency_ctrl_ratio * 100 ))
    eff_latency_ctrl_low_threshold=$(( (eff_latency_ctrl_low_threshold * 100) / 127 ))
    eff_latency_ctrl_high_threshold=$(( (eff_latency_ctrl_high_threshold * 100) / 127 ))

    # Print metrics
    echo -n "Socket ID: $socket_id"
    if [ -n "$numa_node" ]; then
        echo -n ", NUMA node: $numa_node"
    fi
    echo ", instance: $instance, Die: $entry, Type: $die_type"
    echo "MIN_RATIO: $min_ratio MHz"
    echo "MAX_RATIO: $max_ratio MHz"
    echo "EFFICIENCY_LATENCY_CTRL_RATIO: $eff_latency_ctrl_ratio MHz"
    if [ $die_type == "IO" ] ; then
        echo "EFFICIENCY_LATENCY_CTRL_LOW_THRESHOLD: $eff_latency_ctrl_low_threshold%"
        echo "EFFICIENCY_LATENCY_CTRL_HIGH_THRESHOLD: $eff_latency_ctrl_high_threshold%"
        echo "EFFICIENCY_LATENCY_CTRL_HIGH_THRESHOLD_ENABLE: $eff_latency_ctrl_high_threshold_enable"
    fi
    echo
}

# Iterate over all dies and run pcm-tpmi for each to get the metrics
for die_key in "${!die_types[@]}"; do
    instance="${die_key%:*}"
    entry="${die_key#*:}"
    output=$(pcm-tpmi 2 0x18 -d -i $instance -e $entry)

    # Parse the output and extract metrics for each socket
    while read -r line; do
        if [[ $line == *"Read value"* ]]; then
            value=$(echo "$line" | grep -oP 'value \K[0-9]+')
            # Extract instance ID
            inst=$(echo "$line" | grep -oP 'instance \K[0-9]+')
            # Extract entry ID
            ent=$(echo "$line" | grep -oP 'entry \K[0-9]+')
            # Create die_key from instance and entry
            parsed_die_key="${inst}:${ent}"
            # Extract socket ID if present, otherwise fallback to instance ID
            if [[ $line =~ \(socket\ ([0-9]+)\) ]]; then
                socket_id=${BASH_REMATCH[1]}
            else
                socket_id=$inst
            fi
            # Extract NUMA node ID if present in the output (format: "(NUMA node X)")
            numa_node=""
            if [[ $line =~ \(NUMA\ node\ ([0-9]+)\) ]]; then
                numa_node=${BASH_REMATCH[1]}
            fi
            extract_and_print_metrics "$value" "$socket_id" "$parsed_die_key" "$numa_node" "$inst"
        fi
    done <<< "$output"
done


```

`scripts/build.sh`:

```sh


mkdir build
cd build
cmake ..
make -j


```

`scripts/busy.sh`:

```sh


# simple script to keep all cores busy for some time

time -p bash -c 'for i in $(seq 1 $(nproc)); do perl -e '\''$c=0; for(0..99999999){$c++;}'\'' & done; wait'



```

`scripts/convert_edp_list.sh`:

```sh


cat "$1" | sed  '0,/^#.*[gG][rR][oO][uU][pP]/d' |  head  -n -1 | dos2unix


```

`scripts/cppcheck.sh`:

```sh

cppcheck $1 --force --enable=warning --inline-suppr -iPCMService.cpp -isimdjson -ipugixml -iPcmMsrDriver_info.c -igoogletest -DTEXT -j $2 2> cppcheck.out

if [ -s cppcheck.out ]
then
        cat cppcheck.out
        exit 1
fi

echo No issues found


```

`scripts/debug-build.sh`:

```sh


mkdir debug-build
cd debug-build
cmake -DCMAKE_BUILD_TYPE=Debug ..
make -j


```

`scripts/filter.sh`:

```sh


cat $1| rs -c, -C, -T | grep "$2" | rs -c, -C, -T > $3


```

`scripts/find_field.awk`:

```awk
#!/bin/awk -f

{
    for(i=1; i<=NF; i++) {
        if (index($i, term) > 0) print (i)":"$i;
      }
}
```

`scripts/find_field.sh`:

```sh


head -1 $1 | awk -F ',' -v term="$2" -f find_field.awk



```

`scripts/generate_summary.py`:

```py
#SPDX-License-Identifier: BSD-3-Clause
#Copyright (c) 2023, Intel Corporation

import pandas as pd
import io
import matplotlib
from matplotlib import pyplot as plt
import numpy as np
from xlsxwriter import Workbook
import xlsxwriter
from datetime import datetime
import sys

if len(sys.argv) < 2:
    print("Error: Please input a valid csv filename in the command arguments")
    exit()

try:
    df = pd.read_csv(sys.argv[1],header=[0,1])
except:
    arg = sys.argv[1]
    if arg == "--help" or arg == "-h":
        print("python3 <script_name> <filename.csv> -{arguments}")
        print("Following is the accepted list of arguments:") 
        print("sys_exec_time : System Instructions per nominal CPU cycle vs System Time")
        print("cpu_util_time : Socket Instructions per nominal CPU cycle vs System Time")
        print("mem_traffic_time : Memory Bandwidth per socket vs System Time")
        print("cpu_util_socket : Instructions per nominal CPU cycle  vs Socket")
        print("Mem_traffic_time : Average Memory Bandwidth per socket vs Socket")
        print("Note: If no arguments are passed, the default is to include everything above.")
    else:
        print("Error: Please input a avalid csv filename in the command arguments")
    exit()

n = len(sys.argv)
arguments=[]
for i in range(2, n):
    arg = sys.argv[i]
    arg = arg.split('-')
    arguments.append(arg[1])

n = len(arguments)

headers = df.columns
columns=[]
for title in headers:
  columns.append(title[0]+' '+title[1])

df.columns = columns

flag = True
count = 0
columns_added = []

while flag == True:
  column_name = 'Socket ' + str(count) + ' WRITE'
  if column_name in df.columns:
    insert_at_index = df.columns.get_loc(column_name) + 1
    columns_added.append(insert_at_index)
    df.insert (insert_at_index, 'Socket ' + str(count) + ' mem traffic', (df['Socket ' + str(count) + ' READ'] * df['Socket ' + str(count) + ' WRITE'])/950)
    count = count + 1
  else:
    count = count - 1
    break

try:
    system_time = df['System Time']
    updated_time_format = []
    for i in system_time:
        format = '%H:%M:%S'
    time_strip = i.split('.')[0]
    my_date = datetime.strptime(time_strip, format)
    updated_time_format.append(my_date.strftime("%H:%M:%S %p"))
    df['System Time'] = updated_time_format
except:
    print("Generating consolidated report...")


# 'System Exec'
data={'System Time': df['System Time'], 'System Exec': df['System EXEC']}
df1 = pd.DataFrame(data)

# 'CPU utilization per socket (NUMA region)'
data={}
data['System Time'] = df['System Time']
for i in range(0,count+1):
  key = 'Socket ' + str(i) + ' EXEC'
  data[key] = df[key]
df2 = pd.DataFrame(data)

# 'Memory Bandwidth per socket (NUMA region)' 
data={}
data['System Time'] = df['System Time']
for i in range(0,count+1):
  key = 'Socket ' + str(i) + ' mem traffic'
  data[key] = df[key]
df3 = pd.DataFrame(data)

# 'Average CPU utilization (extended instructions)'
data={}
data['System'] = df['System EXEC'].mean()*100
for i in range(0,count+1):
  key = 'Socket ' + str(i) + ' EXEC'
  data['Socket ' + str(i)] = df[key].mean()*100
df4 = pd.DataFrame(data,index=[1])
df4=df4.T

# 'Average Memory Bandwidth per socket (NUMA region)'
data={}
for i in range(0,count+1):
  key = 'Socket ' + str(i) + ' mem traffic'
  data['Socket ' + str(i)] = df[key].mean()*100
df5 = pd.DataFrame(data,index=[1])
df5=df5.T

writer = pd.ExcelWriter('consolidated_summary.xlsx', engine='xlsxwriter')
sheet_name = 'consolidated'
df.to_excel(writer, sheet_name=sheet_name)
workbook  = writer.book
worksheet = writer.sheets[sheet_name]

cell_format = workbook.add_format()
cell_format.set_bg_color('yellow')
cell_format.set_bold()

for index in columns_added:
  excel_column = '' + xlsxwriter.utility.xl_col_to_name(index+1)+':'+xlsxwriter.utility.xl_col_to_name(index+1)
  worksheet.set_column(excel_column, None, cell_format)

# ----------------------------------------------------------------------------------------
if "sys_exec_time" in arguments or n == 0:
    sheet_name = 'System EXEC'
    df1.to_excel(writer, sheet_name=sheet_name)
    workbook  = writer.book
    worksheet = writer.sheets[sheet_name]
    (max_row, max_col) = df1.shape
    chart1 = workbook.add_chart({'type': 'line'})

    chart1.add_series({
        'name':       [sheet_name, 0, 2],
        'categories': [sheet_name, 1, 1,   max_row, 1],
        'values':     [sheet_name, 1, 2, max_row, 2],
    })
    chart1.set_title ({'name': 'Instructions per nominal CPU cycle'})
    chart1.set_x_axis({'name': 'System Time'})
    chart1.set_y_axis({'name': 'System Instructions per nominal CPU cycle', 'major_gridlines': {'visible': False}})
    worksheet.insert_chart(1, 6, chart1)
# ----------------------------------------------------------------------------------------
if "cpu_util_time" in arguments or n == 0:
    sheet_name = 'CPU utilization per socket'
    df2.to_excel(writer, sheet_name=sheet_name)
    workbook  = writer.book
    worksheet = writer.sheets[sheet_name]
    (max_row, max_col) = df2.shape
    chart2 = workbook.add_chart({'type': 'line'})

    for i in range(0,max_col-1):
        col = i + 2
        chart2.add_series({
            'name':       [sheet_name, 0, col],
            'categories': [sheet_name, 1, 1,   max_row, 1],
            'values':     [sheet_name, 1, col, max_row, col],
        })
    chart2.set_title ({'name': 'Instructions per nominal CPU cycle'})
    chart2.set_x_axis({'name': 'System Time'})
    chart2.set_y_axis({'name': 'Socket Instructions per nominal CPU cycle', 'major_gridlines': {'visible': False}})
    worksheet.insert_chart(1, 6, chart2)
# ----------------------------------------------------------------------------------------
if "mem_traffic_time" in arguments or n == 0:
    sheet_name = 'Memory Bandwidth per socket'
    df3.to_excel(writer, sheet_name=sheet_name)
    workbook  = writer.book
    worksheet = writer.sheets[sheet_name]
    (max_row, max_col) = df3.shape
    chart3 = workbook.add_chart({'type': 'line'})

    for i in range(0,max_col-1):
        col = i + 2
        chart3.add_series({
            'name':       [sheet_name, 0, col],
            'categories': [sheet_name, 1, 1,   max_row, 1],
            'values':     [sheet_name, 1, col, max_row, col],
        })
    chart3.set_title ({'name': 'Memory Bandwidth per socket'})
    chart3.set_x_axis({'name': 'System Time'})
    chart3.set_y_axis({'name': 'Memory Traffic (GB)', 'major_gridlines': {'visible': False}})
    worksheet.insert_chart(1, 6, chart3)
# ----------------------------------------------------------------------------------------
if "cpu_util_socket" in arguments or n == 0:
    sheet_name = 'Average CPU Util'
    df4.to_excel(writer, sheet_name=sheet_name)
    workbook  = writer.book
    worksheet = writer.sheets[sheet_name]
    (max_row, max_col) = df4.shape
    chart4 = workbook.add_chart({'type': 'column'})


    chart4.add_series({
        'name':       [sheet_name, 1, 0],
        'categories': [sheet_name, 1, 0,   max_row, 0],
        'values':     [sheet_name, 1, 1, max_row, 1],
    })
    chart4.set_title ({'name': 'Instructions per nominal CPU cycle'})
    chart4.set_x_axis({'name': 'Socket'})
    chart4.set_y_axis({'name': 'Socket  Instructions per nominal CPU cycle', 'major_gridlines': {'visible': False}})
    worksheet.insert_chart(1, 6, chart4)

# ----------------------------------------------------------------------------------------
if "Mem_traffic_time" in arguments or n == 0:
    sheet_name = 'Avg Memory Bandwidth per socket'
    df5.to_excel(writer, sheet_name=sheet_name)
    workbook  = writer.book
    worksheet = writer.sheets[sheet_name]
    (max_row, max_col) = df4.shape
    chart5 = workbook.add_chart({'type': 'column'})


    chart5.add_series({
        'name':       [sheet_name, 1, 0],
        'categories': [sheet_name, 1, 0,   max_row, 0],
        'values':     [sheet_name, 1, 1, max_row, 1],
    })
    chart5.set_title ({'name': 'Average Memory Bandwidth per socket'})
    chart5.set_x_axis({'name': 'Socket'})
    chart5.set_y_axis({'name': 'Memory Traffic (GB)', 'major_gridlines': {'visible': False}})
    worksheet.insert_chart(1, 6, chart5)

writer.close()

```

`scripts/get_sles_bins.sh`:

```sh


filename=`curl https://download.opensuse.org/repositories/home:/opcm/SLE_15_SP1/x86_64/ -s | sed -n 's/.*\(pcm-0-[0-9]*\.1\.x86_64.rpm\).*/\1/p'`

curl -L https://download.opensuse.org/repositories/home:/opcm/SLE_15_SP1/x86_64/$filename -o $filename

rpm2cpio $filename | cpio -idmv


```

`scripts/grafana/README.md`:

```md
--------------------------------------------------------------------------------
Instructions on How To Run PCM Grafana Dashboard
--------------------------------------------------------------------------------

Installation on target system to be analyzed:
1.  Build from the root PCM directory:
    ```
    cd ../..  # if the current location is 'scripts/grafana/'
    mkdir build && cd build
    cmake .. && make -j$(nproc) pcm-sensor-server
    ```
2.  As root start pcm-sensor-server:
    `cd bin && sudo ./pcm-sensor-server`

Alternatively one can start [pcm-sensor-server as a container from docker hub](../../doc/DOCKER_README.md).

Installation of the grafana front-end (can be on any *host* system with connectivity to the target system):
1.  Make sure curl and docker are installed on the *host*
2.  In PCM source directory on the *host*: `cd scripts/grafana`
3.  (Download once and) start docker containers on the *host*: `sudo bash start.sh http://target_system_address:9738`
       - `start.sh` script starts telegraf/influxdb/grafana containers
       - `start-prometheus.sh` is an alternative script which starts prometheus + grafana containers: `sudo bash start-prometheus.sh target_system_address:9738`
       - `start.sh` and `start-prometheus.sh` can also be used to monitor multiple hosts running pcm-sensor-server containers:`sudo bash start.sh targets.txt` or `sudo bash start-prometheus.sh targets.txt`. Here `targets.txt` should be of the following format:
       ```properties
       host1_ipaddress:pcmport
       host2_ipaddress:pcmport
       .
       .
       hostn_ipaddress:pcmport
       ```
       - Don't use `localhost` to specify the `target_system_address` if the *host* and the target are the same machine because `localhost` resolves to the own private IP address of the docker container when accessed inside the container. The external IP address or hostname should be used instead.
4.  Start your browser at http://*host*:3000/ and then login with admin user, password admin . Change the password and then click on "**Home**" (left top corner) -> "**Dashboards**" -> "Intel&reg; Performance Counter Monitor (Intel&reg; PCM) Dashboard"
5.  You can also stop and delete the containers when needed: `sudo bash stop.sh`


![pcm grafana output](https://raw.githubusercontent.com/wiki/intel/pcm/pcm-dashboard-full.png)

```

`scripts/grafana/automatic_influxdb.yml`:

```yml
apiVersion: 1

datasources:
- name: PCM 
  type: influxdb
  access: proxy
  url: "http://influxdb:8086"
  password:
  user:
  database: telegraf 
  basicAuth: false
  basicAuthUser:
  basicAuthPassword:
  withCredentials:
  isDefault: true
  jsonData:
     tlsAuth: false
     tlsAuthWithCACert: false
     timeInterval: "2s"
  secureJsonData:
    tlsCACert: ""
    tlsClientCert: ""
    tlsClientKey: ""
  version: 1
  editable: true



```

`scripts/grafana/automatic_prometheus.yml`:

```yml
apiVersion: 1

datasources:
- name: PCM
  type: prometheus
  access: proxy
  url: "http://prometheus:9090"
  password:
  user:
  database:
  basicAuth: false
  isDefault: true
  editable: true
  jsonData:
  readOnly: false
  version: 1

```

`scripts/grafana/clean.sh`:

```sh

bash stop.sh
rm -rf provisioning/datasources
rm -rf *_volume

```

`scripts/grafana/prometheus.yml.template`:

```template
# my global config
global:
  scrape_interval:     2s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
  evaluation_interval: 2s # Evaluate rules every 15 seconds. The default is every 1 minute.
  # scrape_timeout is set to the global default (10s).

# Alertmanager configuration
alerting:
  alertmanagers:
  - static_configs:
    - targets:
      # - alertmanager:9093

# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.
rule_files:
  # - "first_rules.yml"
  # - "second_rules.yml"

# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
  - job_name: 'pcm'

    # metrics_path defaults to '/metrics'
    # scheme defaults to 'http'.

    static_configs:
    - targets: ['PCMSENSORSERVER']

```

`scripts/grafana/provisioning/dashboards/pcm-provider.yml`:

```yml
apiVersion: 1

providers:
  # <string> an unique provider name
- name: 'default PCM dashboard provider'
  # <int> org id. will default to orgId 1 if not specified
  orgId: 1
  # <string, required> name of the dashboard folder. Required
  folder: ''
  # <string> folder UID. will be automatically generated if not specified
  folderUid: ''
  # <string, required> provider type. Required
  type: file
  # <bool> disable dashboard deletion
  disableDeletion: false
  # <bool> enable dashboard editing
  editable: true
  # <int> how often Grafana will scan for changed dashboards
  updateIntervalSeconds: 1
  # <bool> allow updating provisioned dashboards from the UI
  allowUiUpdates: false
  options:
    # <string, required> path to dashboard files on disk. Required
    path: /var/lib/grafana/dashboards

```

`scripts/grafana/start-prometheus.sh`:

```sh
#!/bin/bash

set -e

usage() {
  echo
  echo "Usage: $0 target_address:port"
  echo
  echo "target_address is the hostname or IP address of the system that runs pcm-sensor-server"
  echo
  echo "Alternative usage: $0 filename"
  echo
  echo "Specify filename containing target_address:port in each line"
  exit 1
}

# Validate the URL format and reject localhost or 127.0.0.1
validate_url() {
  local url=$1
  local regex='^([a-zA-Z0-9.-]+):[0-9]+$'
  local localhost_regex='^(localhost|127\.0\.0\.1):[0-9]+$'

  if ! [[ $url =~ $regex ]]; then
    echo "Error: The target_address ($url) provided is not in the correct format."
    usage
  fi

  if [[ $url =~ $localhost_regex ]]; then
    echo "Error: The target_address cannot be localhost or 127.0.0.1."
    usage
  fi
}

if [ "$#" -ne 1 ]; then
  usage
fi

CTR_RUN=${CTR_RUN:-docker}

mkdir -p grafana_volume/dashboards || { echo "Error creating grafana_volume/dashboards directory"; exit 1; }
mkdir -p prometheus_volume || { echo "Error creating prometheus_volume directory"; exit 1; }

chmod -R 777 *_volume || { echo "Error setting permissions on volume directories"; exit 1; }

mkdir -p provisioning/datasources || { echo "Error creating provisioning/datasources directory"; exit 1; }
cp automatic_prometheus.yml provisioning/datasources/automatic.yml || { echo "Error copying automatic_prometheus.yml"; exit 1; }

# check if argument is file, create the prometheus.yml accordingly
if [ -f "$1" ]; then
  echo "creating prometheus.yml for hosts in targets file";
  head -n -1 "prometheus.yml.template" > prometheus.yml || { echo "Error creating prometheus.yml"; exit 1; }
  while read -r line; do
    validate_url "$line"
    echo "    - targets: ['$line']" >> "prometheus.yml"
  done < "$1"
  echo Downloading PCM dashboard
  curl -o grafana_volume/dashboards/pcm-dashboard.json $(head -1 "$1")/dashboard/prometheus || { echo "Error downloading PCM dashboard"; exit 1; }
else
  validate_url "$1"
  echo "creating prometheus.yml for $1 ";
  sed "s#PCMSENSORSERVER#$1#g" prometheus.yml.template > prometheus.yml || { echo "Error creating prometheus.yml"; exit 1; }
  echo Downloading PCM dashboard
  curl -o grafana_volume/dashboards/pcm-dashboard.json "$1"/dashboard/prometheus || { echo "Error downloading PCM dashboard"; exit 1; }
fi

echo "Starting prometheus network"
${CTR_RUN} network create prometheus-network || { echo "Error creating prometheus network"; exit 1; }
echo Starting prometheus
${CTR_RUN} run --name prometheus --network=prometheus-network -d -p 9090:9090 -v "$PWD"/prometheus.yml:/etc/prometheus/prometheus.yml:Z -v "$PWD"/prometheus_volume:/prometheus:Z quay.io/prometheus/prometheus:latest || { echo "Error starting prometheus"; exit 1; }
echo Starting grafana
${CTR_RUN} run -d --network=prometheus-network --name=grafana -p 3000:3000 -v "$PWD"/grafana_volume:/var/lib/grafana:Z -v "$PWD"/provisioning:/etc/grafana/provisioning:Z -e GF_DASHBOARDS_MIN_REFRESH_INTERVAL=1s docker.io/grafana/grafana:latest || { echo "Error starting grafana"; exit 1; }

echo "Start browser at http://"`hostname`":3000/ or http://localhost:3000/ and login with admin user, password admin"

```

`scripts/grafana/start.sh`:

```sh
#!/bin/bash

set -e

usage() {
  echo
  echo "Usage: $0 http(s)://target_address:port"
  echo
  echo "target_address is the hostname or IP address of the system that runs pcm-sensor-server"
  exit 1
}

# Validate the URL format and reject localhost or 127.0.0.1
validate_url() {
  local url=$1
  local regex='^https?://([a-zA-Z0-9.-]+):[0-9]+$'
  local localhost_regex='^(https?://)?(localhost|127\.0\.0\.1):[0-9]+$'

  if ! [[ $url =~ $regex ]]; then
    echo "Error: The URL provided is not in the correct format."
    usage
  fi

  if [[ $url =~ $localhost_regex ]]; then
    echo "Error: The target_address cannot be localhost or 127.0.0.1."
    usage
  fi
}

if [ "$#" -ne 1 ]; then
  usage
fi

validate_url "$1"

mkdir -p grafana_volume/dashboards || { echo "Error creating grafana_volume/dashboards directory"; exit 1; }
mkdir -p influxdb_volume || { echo "Error creating influxdb_volume directory"; exit 1; }

chmod -R 777 *_volume || { echo "Error setting permissions on volume directories"; exit 1; }

mkdir -p provisioning/datasources || { echo "Error creating provisioning/datasources directory"; exit 1; }
cp automatic_influxdb.yml provisioning/datasources/automatic.yml || { echo "Error copying automatic_influxdb.yml"; exit 1; }

CTR_RUN=${CTR_RUN:-docker}

# check if argument is file, create the telegraf.conf accordingly
if [ -f "$1" ]; then
  echo "creating telegraf.conf for hosts in targets file";
  head -n -7 "telegraf.conf.template" > telegraf.conf || { echo "Error creating telegraf.conf"; exit 1; }
  while IFS='' read -r line || [[ -n "$line" ]]; do
    # Split the line at the : character to get the IP and port
    ip=$(echo "$line" | cut -d ':' -f 1)
    port=$(echo "$line" | cut -d ':' -f 2)
    # Append the transformed line to the output file, separated by a comma
    echo -n "\"http://$ip:$port/persecond/\"," >> telegraf.conf
  done < "$1"
  sed -i '$ s/,$//' telegraf.conf || { echo "Error editing telegraf.conf"; exit 1; }
  tail -n -6 "telegraf.conf.template" >> telegraf.conf || { echo "Error appending to telegraf.conf"; exit 1; }
  echo Downloading PCM dashboard
  curl -o grafana_volume/dashboards/pcm-dashboard.json $(head -1 "$1")/dashboard || { echo "Error downloading PCM dashboard"; exit 1; }
else
  echo "creating telegraf.conf for $1 ";
  sed "s#PCMSENSORSERVER#$1#g" telegraf.conf.template > telegraf.conf || { echo "Error creating telegraf.conf"; exit 1; }
  echo Downloading PCM dashboard
  curl -o grafana_volume/dashboards/pcm-dashboard.json "$1"/dashboard || { echo "Error downloading PCM dashboard"; exit 1; }
fi

echo "Creating influxdb network"
${CTR_RUN} network create influxdb-network || { echo "Error creating influxdb network"; exit 1; }
echo Starting influxdb
${CTR_RUN} run -d --name influxdb -p 8083:8083 -p 8086:8086 --network=influxdb-network -v "$PWD"/influxdb_volume:/var/lib/influxdb influxdb:1.8.0-alpine || { echo "Error starting influxdb"; exit 1; }
echo Starting telegraf
${CTR_RUN} run -d --name telegraf --network=influxdb-network -v "$PWD"/telegraf.conf:/etc/telegraf/telegraf.conf:ro telegraf || { echo "Error starting telegraf"; exit 1; }
echo Starting grafana
${CTR_RUN} run -d --network=influxdb-network --name grafana -p 3000:3000 -v "$PWD"/provisioning:/etc/grafana/provisioning -v "$PWD"/grafana_volume:/var/lib/grafana -e GF_DASHBOARDS_MIN_REFRESH_INTERVAL=1s grafana/grafana || { echo "Error starting grafana"; exit 1; }

echo "Start browser at http://"`hostname`":3000/ or http://localhost:3000/ and login with admin user, password admin"

```

`scripts/grafana/stop.sh`:

```sh

CTR_RUN=${CTR_RUN:-docker}
for c in grafana telegraf influxdb prometheus; do

	id=`${CTR_RUN} ps -a -q --filter="name=$c" --format="{{.ID}}"`
	if [ ! -z "$id" ]
	then
	   echo Stopping and deleting $c
	   ${CTR_RUN} rm $(${CTR_RUN} stop $id)
	fi
done

${CTR_RUN} network rm prometheus-network influxdb-network


```

`scripts/grafana/telegraf.conf.template`:

```template
#
# Telegraf is entirely plugin driven. All metrics are gathered from the
# declared inputs, and sent to the declared outputs.
#
# Plugins must be declared in here to be active.
# To deactivate a plugin, comment out the name and any variables.
#
# Use 'telegraf -config telegraf.conf -test' to see what metrics a config
# file would generate.
#
# Environment variables can be used anywhere in this config file, simply prepend
# them with $. For strings the variable must be within quotes (ie, "$STR_VAR"),
# for numbers and booleans they should be plain (ie, $INT_VAR, $BOOL_VAR)


# Global tags can be specified here in key="value" format.
[global_tags]
  # dc = "us-east-1" # will tag all metrics with dc=us-east-1
  # rack = "1a"
  ## Environment variables can be used as tags, and throughout the config file
  # user = "$USER"


# Configuration for telegraf agent
[agent]
  ## Default data collection interval for all inputs
  # interval = "2s"
  ## Rounds collection interval to 'interval'
  ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
  round_interval = false 

  ## Telegraf will send metrics to outputs in batches of at
  ## most metric_batch_size metrics.
  metric_batch_size = 1000
  ## For failed writes, telegraf will cache metric_buffer_limit metrics for each
  ## output, and will flush this buffer on a successful write. Oldest metrics
  ## are dropped first when this buffer fills.
  metric_buffer_limit = 10000

  ## Collection jitter is used to jitter the collection by a random amount.
  ## Each plugin will sleep for a random time within jitter before collecting.
  ## This can be used to avoid many plugins querying things like sysfs at the
  ## same time, which can have a measurable effect on the system.
  collection_jitter = "0s"

  ## Default flushing interval for all outputs. You shouldn't set this below
  ## interval. Maximum flush_interval will be flush_interval + flush_jitter
  flush_interval = "1s"
  ## Jitter the flush interval by a random amount. This is primarily to avoid
  ## large write spikes for users running a large number of telegraf instances.
  ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
  flush_jitter = "0s"

  ## By default, precision will be set to the same timestamp order as the
  ## collection interval, with the maximum being 1s.
  ## Precision will NOT be used for service inputs, such as logparser and statsd.
  ## Valid values are "ns", "us" (or "µs"), "ms", "s".
  precision = ""
  ## Run telegraf in debug mode
  debug = false
  ## Run telegraf in quiet mode
  quiet = false
  ## Override default hostname, if empty use os.Hostname()
  ## hostname = ""
  ## If set to true, do no set the "host" tag in the telegraf agent.
  omit_hostname = false


###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################

# Configuration for influxdb server to send metrics to
[[outputs.influxdb]]
  ## The full HTTP or UDP endpoint URL for your InfluxDB instance.
  ## Multiple urls can be specified as part of the same cluster,
  ## this means that only ONE of the urls will be written to each interval.
  # urls = ["udp://localhost:8089"] # UDP endpoint example
  urls = ["http://influxdb:8086"] # required
  ## The target database for metrics (telegraf will create it if not exists).
  database = "telegraf" # required

  ## Retention policy to write to. Empty string writes to the default rp.
  retention_policy = ""
  ## Write consistency (clusters only), can be: "any", "one", "quorum", "all"
  write_consistency = "any"

  ## Write timeout (for the InfluxDB client), formatted as a string.
  ## If not provided, will default to 5s. 0s means no timeout (not recommended).
  timeout = "5s"
  # username = "telegraf"
  # password = "metricsmetricsmetricsmetrics"
  ## Set the user agent for HTTP POSTs (can be useful for log differentiation)
  # user_agent = "telegraf"
  ## Set UDP payload size, defaults to InfluxDB UDP Client default (512 bytes)
  # udp_payload = 512

  ## Optional SSL Config
  # ssl_ca = "/etc/telegraf/ca.pem"
  # ssl_cert = "/etc/telegraf/cert.pem"
  # ssl_key = "/etc/telegraf/key.pem"
  ## Use SSL but skip chain & host verification
  # insecure_skip_verify = false

[[inputs.http]]
  urls = [
    "PCMSENSORSERVER/persecond/"
  ]
  interval = "2s"
  data_format = "json"
  headers = {"Accept" = "application/json"}



```

`scripts/pcm-background.sh`:

```sh

pcm "$@" &

echo "$!" > pcm.pid

```

`scripts/pcm-exporter`:

```
#!/bin/sh

../build/bin/pcm-sensor-server "$@"


```

`scripts/pcm-stop.sh`:

```sh

kill `cat pcm.pid`

```

`scripts/pcm-win-power-tray.py`:

```py
import pystray
from PIL import Image, ImageDraw, ImageFont
import threading
import time
import subprocess  # nosec B404 - subprocess used for controlled system commands, no user input
import csv
import io

def create_image(text, background_color):
    width = 12 
    height = 12
    image = Image.new('RGB', (width, height), background_color)
    draw = ImageDraw.Draw(image)

    # Use the default font and scale it
    font = ImageFont.load_default()

    # Calculate text size and position
    text_bbox = draw.textbbox((0, 0), text, font=font)
    text_width = text_bbox[2] - text_bbox[0]
    text_height = text_bbox[3] - text_bbox[1]
    text_x = (width - text_width) // 2
    text_y = -2 + (height - text_height) // 2

    # Draw the text on the image
    draw.text((text_x, text_y), text, fill="white", font=font)

    # Scale the image down to fit the system tray icon size
    image = image.resize((64, 64), Image.LANCZOS)

    return image

# global process variable to kill the pcm.exe process when the icon is clicked
process = None

def update_icon(icon):
    # Start the pcm.exe process with -csv 3 parameters
    # store process into the global process variable
    global process
    process = subprocess.Popen(
        # change the path to pcm.exe as needed
        ["..\\windows_build22\\bin\\Release\\pcm.exe", "-r", "-csv", "3"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )

    count = 0

    while True:
        # find the header line to find the index of "SYSTEM Energy (Joules)"
        if (count > 1000):
            print (f"Can't find SYSTEM Energy (Joules) metric")
            process.kill()
            exit(0)
        count = count + 1
        line = process.stdout.readline()
        csv_reader = csv.reader(io.StringIO(line))
        header = next(csv_reader)
        try:
            system_energy_index = header.index("SYSTEM Energy (Joules)")
            print (f"SYSTEM Energy (Joules) found at index {system_energy_index}")
            break
        except ValueError:
            #print("SYSTEM Energy (Joules) not found in the header")
            continue

    # Skip the second header line
    process.stdout.readline()

    while True:
        # Read the output line by line
        line = process.stdout.readline()
        # print (line)
        if not line:
            break

        system_energy_joules = -1

        # Parse the CSV output
        csv_reader = csv.reader(io.StringIO(line))
        for row in csv_reader:
            # Extract the system power consumption in Watts
            try:
                system_energy_joules = float(row[system_energy_index])
                print (f"SYSTEM Energy (Joules): {system_energy_joules}")
                # Convert Joules to Watts
                power_consumption_watts = system_energy_joules / 3.0
                if (power_consumption_watts > 30) :
                    background_color = "red"
                elif (power_consumption_watts > 20) :
                    background_color = "darkblue"
                else:
                    background_color = "darkgreen"
                # Update the icon with the current power consumption in Watts
                icon.icon = create_image(f"{power_consumption_watts:.0f}", background_color)
            except (IndexError, ValueError):
                continue

        if (system_energy_joules == -1):
            continue

    print (f"pcm.exe exited with code {process.returncode}")

def on_quit(icon, item):
    icon.stop()
    process.kill()

def main():
    # Create the system tray icon
    icon = pystray.Icon("Intel PCM: System Watts")
    icon.icon = create_image("P", "darkblue")
    icon.title = "Intel PCM: System Watts"
    icon.menu = pystray.Menu(
        pystray.MenuItem("Quit", on_quit)
    )

    # Start a thread to update the icon
    threading.Thread(target=update_icon, args=(icon,), daemon=True).start()

    # Run the icon
    icon.run()

if __name__ == "__main__":
    main()
```

`scripts/pcm.plot`:

```plot

set key autotitle columnhead
set datafile separator ","

# change as needed
# set xlabel 'sample # (each is 1000ms)'

set ylabel 'metric value'

set terminal pdf
set output "pcm.pdf"

# change below as needed
# plot metrics 3 .. 37
do for [m=3:37] {
    plot "single_header.pcm.csv" using m with dots
}

# plot metrics 84 .. 107
do for [m=84:107] {
    plot "single_header.pcm.csv" using m with dots
}



```

`scripts/pmu-query.py`:

```py
#!/usr/bin/env python3
import io
import urllib.request
import urllib.parse
import json
import csv
# subprocess is used as multiplatform approach, usage is verified (20-07-2022)
import subprocess  # nosec
import sys
import platform
import getopt
import re
import shutil

all_flag = False
download_flag = False
filename = None
offcore_events = []
core_events = []

try:
    opts, args = getopt.getopt(sys.argv[1:], "a,f:,d", ["all", "file=", "download"])
    for o, a in opts:
        if o in ("-a", "--all"):
            all_flag = True
        if o in ("-f", "--file"):
            filename = a
        if o in ("-d", "--download"):
            download_flag = True
except getopt.GetoptError as err:
    print("parse error: %s\n" % (str(err)))
    sys.exit(-2)

if filename is None:
    # vefified that link to mapfile.csv is safe and correct (20-07-2022)
    map_file_raw = urllib.request.urlopen("https://raw.githubusercontent.com/intel/perfmon/main/mapfile.csv").read().decode('utf-8')  # nosec
    map_dict = csv.DictReader(io.StringIO(map_file_raw), delimiter=',')
    map_file = []
    core_path = ""
    offcore_path = ""

    while True:
        try:
            map_file.append(next(map_dict))
        except StopIteration:
            break

    if platform.system() == "CYGWIN_NT-6.1":
        p = subprocess.Popen(["./pcm-core.exe", "-c"], stdout=subprocess.PIPE, shell=False)
    elif platform.system() == "Windows":
        p = subprocess.Popen(["pcm-core.exe", "-c"], stdout=subprocess.PIPE, shell=False)
    elif platform.system() == "Linux":
        pcm_core = shutil.which("pcm-core")
        if not pcm_core:
            print("Could not find pcm-core executable!")
            sys.exit(-1)
        p = subprocess.Popen([pcm_core, "-c"], stdout=subprocess.PIPE, shell=False)
    else:
        p = subprocess.Popen(["../build/bin/pcm-core", "-c"], stdout=subprocess.PIPE, shell=False)

    (output, err) = p.communicate()
    p_status = p.wait()
    for model in map_file:
        if re.search(model["Family-model"], output.decode("utf-8")):
            if model["EventType"] == "core":
                core_path = model["Filename"]
            elif model["EventType"] == "offcore":
                offcore_path = model["Filename"]
            print(model)

    if core_path:
        # vefified that links, created on base of map_file are correct (20-07-2022)
        json_core_data = urllib.request.urlopen(  # nosec
            "https://raw.githubusercontent.com/intel/perfmon/main" + core_path
        )
        core_events = json.load(json_core_data)
        if download_flag:
            with open(core_path.split("/")[-1], "w") as outfile:
                json.dump(core_events, outfile, sort_keys=True, indent=4)
    else:
        print("no core event found for %s CPU, program abort..." % output.decode("utf-8"))
        sys.exit(-1)

    if offcore_path:
        # vefified that links, created on base of map_file are correct (20-07-2022)
        json_offcore_data = urllib.request.urlopen(  # nosec
            "https://raw.githubusercontent.com/intel/perfmon/main" + offcore_path
        )
        offcore_events = json.load(json_offcore_data)
        if download_flag:
            with open(offcore_path.split("/")[-1], "w") as outfile:
                json.dump(offcore_events, outfile, sort_keys=True, indent=4)
else:
    for f in filename.split(","):
        print(f)
        core_events.extend(json.load(open(f)))

if all_flag:
    for event in core_events + offcore_events:
        if "EventName" in event and "BriefDescription" in event:
            print(event["EventName"] + ":" + event["BriefDescription"])
    sys.exit(0)

name = input("Event to query (empty enter to quit):")
while name:
    for event in core_events + offcore_events:
        if "EventName" in event and name.lower() in event["EventName"].lower():
            print(event["EventName"] + ":" + event["BriefDescription"])
            for ev_code in event["EventCode"].split(", "):
                print(
                    "cpu/umask=%s,event=%s,name=%s%s%s%s%s%s/"
                    % (
                        event["UMask"],
                        ev_code,
                        event["EventName"],
                        (",offcore_rsp=%s" % (event["MSRValue"]))
                        if event["MSRValue"] != "0"
                        else "",
                        (",inv=%s" % (event["Invert"]))
                        if event["Invert"] != "0"
                        else "",
                        (",any=%s" % (event["AnyThread"]))
                        if event["AnyThread"] != "0"
                        else "",
                        (",edge=%s" % (event["EdgeDetect"]))
                        if event["EdgeDetect"] != "0"
                        else "",
                        (",cmask=%s" % (event["CounterMask"]))
                        if event["CounterMask"] != "0"
                        else "",
                    )
                )

    name = input("Event to query (empty enter to quit):")

```

`scripts/readmem.sh`:

```sh


numactl --cpunodebind=0 --membind=0 ./readmem 10 &
numactl --cpunodebind=1 --membind=1 ./readmem 10 &
numactl --cpunodebind=0 --membind=0 ./readmem 10 &
numactl --cpunodebind=1 --membind=1 ./readmem 10 &
numactl --cpunodebind=0 --membind=0 ./readmem 10 &
numactl --cpunodebind=1 --membind=1 ./readmem 10 &
numactl --cpunodebind=0 --membind=0 ./readmem 10 &
numactl --cpunodebind=1 --membind=1 ./readmem 10 &
numactl --cpunodebind=0 --membind=0 ./readmem 10 &
numactl --cpunodebind=1 --membind=1 ./readmem 10 &
numactl --cpunodebind=0 --membind=0 ./readmem 10 &
numactl --cpunodebind=1 --membind=1 ./readmem 10 &


```

`scripts/single_header.awk`:

```awk
BEGIN {
   line = 0;
}

{
  if (line == 0)
  {
#     print $0;
      for(i=1; i<=NF; i++) {
        first[i] = $i;
      }
  }
  else if (line == 1)
  {
      for(i=1; i<=NF; i++) {
        if ($i != "") printf first[i]" "$i","
      }
      print ""
  }
  else
  {
      print $0
  }

  line = line + 1;
}

```

`scripts/single_header.sh`:

```sh


cat $1 | awk -F ',' -f single_header.awk > single_header.$1


```

`scripts/topotop`:

```
#!/usr/bin/env python3

"""topotop - visualize CPU usage in NUMA nodes/packages/hyperthreads

Usage: topotop [options]

Options:
  -h, --help            print help.
  -d, --delay SECONDS   delay between updates. The default is "1.0".
  -l, --largest-share   show largest share of each busy CPU that a
                        single process got. The top dot stands for
                        at least 99 % CPU. Requires "bpftrace".
  -m, --memory          include memory bandwidth, requires "pcm-memory".
  -u, --upi             include UPI traffic, requires "pcm".
"""

import glob
import os
import subprocess
import sys
import time

# error prints error message and exits process
def error(msg, exit_status=1):
    sys.stderr.write("topotop: %s\n" % (msg,))
    sys.exit(exit_status)

# listset2list parses list set syntax (like "0,4-7,63") into a list
def listset2list(s):
    l = []
    if s == "":
        return l
    for comma in s.split(","):
        rng = comma.split("-")
        if len(rng) == 1:
            l.append(int(rng[0]))
            continue
        for i in range(int(rng[0]), int(rng[1])+1):
            l.append(i)
    return l

# coord2brbit maps (x, y) coordinates to offset bits in utf8/braille
# defined for width x height: 2 x 4
coord2brbit = [
    [0, 1, 2, 6],
    [3, 4, 5, 7],
]

# brbits2chr converts braille character bits to a braille character
def brbits2chr(bits):
    base = 10240
    offset = 0
    for bit in range(8):
        if bits & (1 << bit) != 0:
            offset += 1 << bit
    return chr(base + offset)

class Bitmap:
    def __init__(self, width=0, height=0, data=None):
        self._width = width
        self._height = height
        self._data = data
        self._max_color = 1
    # from_table() creates bitmap from table
    # [[x0y0, x1y0, ...],
    #  [x0y1, x1y1, ...],
    #  ...]
    def from_table(self, table):
        self._data = table
        self._height = len(self._data)
        self._width = max([len(line) for line in self._data])
        for row in self._data:
            self._max_color = max(self._max_color, max(row))
    def set_line(self, lineno, linedata):
        if self._data is None:
            self._data = []
        if lineno == -1:
            lineno = len(self._data)
        if lineno >= len(self._data):
            [self._data.append([]) for n in range(lineno-len(self._data)+1)]
        self._data[lineno] = linedata
        if len(linedata) > self._width:
            self._width = len(linedata)
        self._height = len(self._data)
        if len(linedata) > 0:
            self._max_color = max(self._max_color, max(linedata))
    def add_col(self, coldata):
        if self._data is None:
            self._data = []
        if len(self._data) < len(coldata):
            [self._data.append([]) for n in range(len(coldata)-len(self._data))]
        for lineidx, line in enumerate(self._data):
            line.append(coldata[lineidx])
        self._width = len(self._data[0])
        self._height = len(self._data)
    def line(self, lineno):
        if self._data and lineno < len(self._data):
            return self._data[lineno]
        return []
    def size(self):
        return (self._width, self._height)
    def max_color(self):
        return self._max_color
    def pixel(self, x, y, default=None):
        if y >= len(self._data) or x >= len(self._data[y]):
            return default
        return self._data[y][x]
    # to_braille() converts a bitmap into a string of braille
    # characters. If bitmap height > 4 the result will be a
    # multiline string.
    def to_braille(self, colormode=0):
        width, height = self.size()
        max_color = self.max_color()
        if width == 0 or height == 0:
            return ""
        braille = []
        for row in range((3+height)//4):
            braille.append([])
        for x2 in range((1+width)//2):
            for y4 in range((3+height)//4):
                braille_char_bits = 0
                pixel_count = 0
                color_sum = 0
                if colormode == 2:
                    color_sum = (0, 0, 0)
                for x in range(min(2, width - x2*2)):
                    for y in range(min(4, height - y4*4)):
                        c = self.pixel(x2*2+x, y4*4+y, default=0)
                        if c != 0:
                            braille_char_bits |= 1 << coord2brbit[x][y]
                            pixel_count += 1
                            if colormode == 1: # grayscale
                                color_sum += c
                            elif colormode == 2: # 8-bit RGB
                                r, g, b = c >> 16, c >> 8 & 255, c & 255
                                color_sum = (color_sum[0] + b, color_sum[1] + g, color_sum[2] + r)
                color, nocolor = "", ""
                if colormode == 1 and pixel_count > 0 and max_color > 0:
                    grayscale = 232 + int(15 * (color_sum / pixel_count) / max_color)
                    color = "\x1b[38;5;%dm" % (grayscale,)
                    nocolor = "\x1b[0m"
                elif colormode == 2 and pixel_count > 0:
                    r = int(color_sum[2]/pixel_count)
                    g = int(color_sum[1]/pixel_count)
                    b = int(color_sum[0]/pixel_count)
                    color = "\x1b[38;2;%d;%d;%dm" % (r, g, b)
                    nocolor = "\x1b[0m"
                braille[y4].append(color + brbits2chr(braille_char_bits) + nocolor)
        return '\n'.join(''.join(c for c in line) for line in braille)

_bpftrace_cpu_pid_process = None
def cpu_pid_stats():
    global _bpftrace_cpu_pid_process
    if _bpftrace_cpu_pid_process is None:
        bpfprog = (
            "tracepoint:sched:sched_stat_runtime{ if (@active[0]==0) { @run0[cpu,args->pid]+=args->runtime; } else { @run1[cpu,args->pid]+=args->runtime; } }" + # @run: {(cpu, pid): runtime}
            "interval:ms:%d{ @active[0]=1-@active[0]; if (@active[0]==1) { print(@run0); clear(@run0); } else { print(@run1); clear(@run1); } print(\"---\"); }" % (int(opt_delay * 1000),)
        )
        _bpftrace_cpu_pid_process = subprocess.Popen(
            ["bpftrace", "-e", bpfprog],
            bufsize=0,
            universal_newlines=True,
            stdout=subprocess.PIPE)
    # @MAP0[cpu,pid]: count
    stat_cpu_pid = {
        "run": {},
    }
    while True:
        line = _bpftrace_cpu_pid_process.stdout.readline().strip()
        if line == "":
            raise Exception("bpftrace exited")
        if line == "---":
            break
        if line.startswith("@"):
            stat = line[1:4]
            cpu_pid_value = stat_cpu_pid[stat]
            cpu_pid, count = line.split(":")
            # cpu_pid: "@XXX0[cpu, pid]"
            cpu = int(cpu_pid.split(",")[0][6:]) # cut "@XXX0["
            pid = int(cpu_pid.split(",")[1][:-1]) # cut "]"
            if not cpu in cpu_pid_value:
                cpu_pid_value[cpu] = {}
            cpu_pid_value[cpu][pid] = int(count.strip())
    return stat_cpu_pid

def cpu_lshare(stat_cpu_pid, cpu_usage):
    """Return largest share (lshare) that the most running process got from a CPU"""
    cpu_lshare = {}
    for cpu, pid_runtime in stat_cpu_pid["run"].items():
        # show largest share only on CPUs with at least 25 % usage
        if cpu_usage.get(cpu, 0) < 0.25:
            cpu_lshare[cpu] = 0
            continue
        max_time = max(pid_runtime.values())
        sum_time = sum(pid_runtime.values())
        if sum_time == 0:
            cpu_lshare[cpu] = 0
            continue
        cpu_lshare[cpu] = max_time / sum_time
    return cpu_lshare

_cpu_load_total, _cpu_load_idle = {}, {}
def cpu_usage_from_proc():
    """Read CPU usage statistics from /proc/stat"""
    global _cpu_load_total, _cpu_load_idle
    total1, idle1 = _cpu_load_total, _cpu_load_idle

    total2, idle2 = {}, {}
    with open("/proc/stat") as f:
        for line in f:
            if line.startswith("cpu") and line[3] in "0123456789":
                fields = line.split()
                vcpu = int(fields[0][3:])
                values = list(map(int, fields[1:]))  # Convert to integers
                total2[vcpu] = sum(values)  # Total time
                idle2[vcpu] = values[3]  # Idle time (4th column)
    _cpu_load_total, _cpu_load_idle = total2, idle2
    usage = {}
    for vcpu in total1:
        try:
            usage[vcpu] = 1-((idle2[vcpu]-idle1[vcpu]) / (total2[vcpu]-total1[vcpu]))
        except:
            usage[vcpu] = 0
    return usage

_pcm_memory_process = None
_pcm_memory_csv_headers = [] # expect two lines
def membw_from_pcm():
    global _pcm_memory_process
    global _pcm_memory_csv_headers
    if _pcm_memory_process is None:
        _pcm_memory_process = subprocess.Popen(
            ["stdbuf", "-oL", "pcm-memory", "-csv", "%.2f" % (opt_delay,)],
            bufsize=1,
            universal_newlines=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL)
        _pcm_memory_csv_headers.append([f.strip() for f in _pcm_memory_process.stdout.readline().strip().split(",")])
        if len(_pcm_memory_csv_headers[0]) <= 4:
            raise Exception("failed to launch pcm-memory")
        _pcm_memory_csv_headers.append([f.strip() for f in _pcm_memory_process.stdout.readline().strip().split(",")])
        return []
    # get latest output from pcm-memory
    h0, h1 = _pcm_memory_csv_headers[0], _pcm_memory_csv_headers[1]
    line = _pcm_memory_process.stdout.readline().strip()
    skt_chn_mbs = []
    for col, field in enumerate(line.split(",")):
        if not field:
            continue
        try:
            field_float = float(field.strip())
        except:
            continue
        if h0[col].startswith("SKT"):
            skt_chn_mbs.append(
                (int(h0[col][len("SKT"):]),
                 h1[col],
                 field_float))
        elif h0[col].startswith("System"):
            skt_chn_mbs.append(
                (-1,
                 h1[col],
                 field_float))
    return skt_chn_mbs

_pcm_process = None
_pcm_csv_headers = [] # expect two lines
_pcm_prevline_timestamp = None
def upi_from_pcm():
    global _pcm_process
    global _pcm_csv_headers
    global _pcm_prevline_timestamp
    if _pcm_process is None:
        _pcm_process = subprocess.Popen(
            ["stdbuf", "-oL", "pcm", "-nc", "-nsys", "-csv", "%.2f" % (opt_delay,)],
            bufsize=1,
            universal_newlines=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL)
        _pcm_csv_headers.append([f.strip() for f in _pcm_process.stdout.readline().strip().split(",")])
        if len(_pcm_csv_headers[0]) <= 4:
            raise Exception("failed to launch pcm")
        _pcm_csv_headers.append([f.strip() for f in _pcm_process.stdout.readline().strip().split(",")])
        return []
    # get latest output from pcm
    h0, h1 = _pcm_csv_headers[0], _pcm_csv_headers[1]
    line = _pcm_process.stdout.readline().strip()

    pcm_line_timestamp = time.time()
    pcm_line_timediff = 0
    if _pcm_prevline_timestamp is not None:
        pcm_line_timediff = pcm_line_timestamp - _pcm_prevline_timestamp
    _pcm_prevline_timestamp = pcm_line_timestamp

    skt_upi_mbs = []
    for col, field in enumerate(line.split(",")):
        if not field:
            continue
        try:
            field_float = float(field.strip())
        except:
            continue
        if h0[col].startswith("SKT") and h0[col].endswith("trafficOut"):
            if pcm_line_timediff > 0:
                mbps = field_float / pcm_line_timediff
            else:
                mbps = field_float
            skt_upi_mbs.append(
                (int(h0[col][len("SKT"):-len("trafficOut")]),
                 h1[col],
                 mbps))
    return skt_upi_mbs

def read_topology():
    cpus = []
    id_files=["physical_package_id", "die_id", "cluster_id", "core_id"]
    vcpu = lambda s: int(s[len("/sys/devices/system/cpu/cpu"):-len("/topology")])
    def readi(path):
        try:
            return int(open(path).read())
        except:
            return 0
    for d in glob.glob("/sys/devices/system/cpu/cpu*/topology"):
        cpus.append([readi(d + "/" + f) for f in id_files] + [vcpu(d)])
    cpus.sort()
    return cpus

def add_numa_info_to_pkg(cpus):
    nodeid = lambda s: int(s[len("/sys/devices/system/node/node"):-len("/cpulist")])
    cpu_node = {}
    for d in glob.glob("/sys/devices/system/node/node*/cpulist"):
        cpulist = listset2list(open(d).read())
        for cpuid in cpulist:
            cpu_node[cpuid] = nodeid(d)
    for cpu_vec in cpus:
        cpuid = cpu_vec[-1]
        cpu_vec[0:0] = [cpu_node.get(cpuid, "?")] # add NUMA node id to beginning

_width_bw = 0
_pkg_ch_max_read_bw, _pkg_ch_max_write_bw, _pkg_ch_max_bw = {}, {}, {}
_pkg_max_sum_read_bw, _pkg_max_sum_write_bw = {}, {}
def print_membw_usage(pkg, data):
    global _width_bw, _pkg_ch_max_read_bw, _pkg_ch_max_write_bw, _pkg_ch_max_bw
    global _max_sum_read_bw, _max_sum_write_bw
    if pkg not in _pkg_ch_max_read_bw:
        _pkg_ch_max_read_bw[pkg] = {}
        _pkg_ch_max_write_bw[pkg] = {}
        _pkg_ch_max_bw[pkg] = {}
        _pkg_max_sum_read_bw[pkg] = 0
        _pkg_max_sum_write_bw[pkg] = 0
    _ch_max_read_bw = _pkg_ch_max_read_bw[pkg]
    _ch_max_write_bw = _pkg_ch_max_write_bw[pkg]
    _ch_max_bw = _pkg_ch_max_bw[pkg]
    _max_sum_read_bw = _pkg_max_sum_read_bw[pkg]
    _max_sum_write_bw = _pkg_max_sum_write_bw[pkg]
    bm_width = 25*2
    lines = []
    ch_rw = {} # {channel: (readMBps, writeMBps)}
    for skt, metric, value in data:
        if skt != pkg:
            continue
        if metric.startswith("Ch"):
            gbps = value/1000.0
            if metric.endswith("Read"):
                try:
                    ch = int(metric[len("Ch"):-len("Read")])
                except:
                    continue
                ch_rw[ch] = (gbps, ch_rw.get(ch, (0, 0))[1])
                if gbps > _ch_max_read_bw.get(ch, 0):
                    _ch_max_read_bw[ch] = gbps
            elif metric.endswith("Write"):
                try:
                    ch = int(metric[len("Ch"):-len("Write")])
                except:
                    continue
                ch_rw[ch] = (ch_rw.get(ch, (0, 0))[0], gbps)
                if gbps > _ch_max_write_bw.get(ch, 0):
                    _ch_max_write_bw[ch] = gbps
    max_read_bw = max(rw[0] for rw in ch_rw.values())
    sum_read_bw = sum(rw[0] for rw in ch_rw.values())
    max_write_bw = max(rw[1] for rw in ch_rw.values())
    sum_write_bw = sum(rw[1] for rw in ch_rw.values())
    width_bw = max(max_read_bw, max_write_bw)
    if width_bw > _width_bw:
        _width_bw = width_bw
    if sum_read_bw > _max_sum_read_bw:
        _max_sum_read_bw = sum_read_bw
        _pkg_max_sum_read_bw[pkg] = sum_read_bw
    if sum_write_bw > _max_sum_write_bw:
        _max_sum_write_bw = sum_write_bw
        _pkg_max_sum_write_bw[pkg] = sum_write_bw
    print(f" skt{pkg}R {sum_read_bw:6.1f} GB/s peak {_max_sum_read_bw:6.1f} GB/s ch.peak {max(_ch_max_read_bw.values()):6.1f} GB/s")
    print(f" skt{pkg}W {sum_write_bw:6.1f} GB/s peak {_max_sum_write_bw:6.1f} GB/s ch.peak {max(_ch_max_write_bw.values()):6.1f} GB/s")
    for ch in sorted(ch_rw.keys()):
        if _ch_max_bw.get(ch, 0) < sum(ch_rw[ch]):
            _ch_max_bw[ch] = sum(ch_rw[ch])
        read, write = ch_rw[ch]
        bm = Bitmap()
        read_line = [1]*int(bm_width * read / _width_bw) + [0]*(bm_width-int(bm_width * read / _width_bw))
        read_empty = [0]*bm_width
        read_line[max(int(bm_width * _ch_max_read_bw[ch] / _width_bw)-1,0)] = 1
        read_empty[max(int(bm_width * _ch_max_read_bw[ch] / _width_bw)-1,0)] = 1
        write_line = [1]*int(bm_width * write / _width_bw) + [0]*(bm_width-int(bm_width * write / _width_bw))
        write_empty = [0]*bm_width
        write_line[max(int(bm_width * _ch_max_write_bw[ch] / _width_bw)-1,0)] = 1
        write_empty[max(int(bm_width * _ch_max_write_bw[ch] / _width_bw)-1,0)] = 1
        bm.set_line(0, read_empty)
        bm.set_line(1, read_line)
        bm.set_line(2, write_empty)
        bm.set_line(3, write_line)

        lines.append(f"ch{ch}R+W {read+write:6.1f} GB/s" + bm.to_braille() + f" {_ch_max_bw[ch]:6.1f} GB/s")
    print("\n".join(lines))

_upi_width_bw = 0
_upi_max_bw = 0
_upi_pkg_max_sum_bw = {}
def print_upi_usage(pkg, data, upidir):
    global _upi_width_bw, _upi_max_bw, _upi_pkg_max_sum_bw
    if pkg not in _upi_pkg_max_sum_bw:
        _upi_pkg_max_sum_bw[pkg] = 0
    upi_bw = {}
    lines = []
    for skt, metric, value in data:
        if skt != pkg:
            continue
        if metric.startswith("UPI"):
            gbps = value/1000.0
            try:
                upi = int(metric[len("UPI"):])
            except:
                continue
            upi_bw[upi] = gbps
    max_bw = max(upi_bw.values())
    sum_bw = sum(upi_bw.values())
    if max_bw > _upi_max_bw:
        _upi_max_bw = max_bw
    if sum_bw > _upi_pkg_max_sum_bw[pkg]:
        _upi_pkg_max_sum_bw[pkg] = sum_bw
    bm_width = 25*2
    upi_links = []
    bm = Bitmap()
    for upi in sorted(upi_bw.keys()):
        upi_links.append(upi)
        bw = upi_bw[upi]
        line = [1]*int(bm_width * bw / _upi_max_bw) + [0]*(bm_width-int(bm_width * bw / _upi_max_bw))
        bm.set_line(-1, line)
    bm_lines = bm.to_braille().split("\n")
    lines.append(f"{upidir}UPI{pkg}{upidir} {sum_bw:6.1f} GB/s{bm_lines[0]} {_upi_pkg_max_sum_bw[pkg]:6.1f} GB/s")
    bm_lines.pop(0)
    while bm_lines:
        lines.append(" "*18 + bm_lines[0])
        bm_lines.pop(0)
    print("\n".join(lines))

_max_sys_bw = 0
_max_sys_rbw = 0
_max_sys_wbw = 0
def print_sysmbw_usage(data):
    global _max_sys_bw, _max_sys_rbw, _max_sys_wbw
    skt_ch_bw = {}
    rgbps, wgbps = 0, 0
    for skt, metric, value in data:
        if skt == -1:
            if metric == "Read":
                rgbps = value/1000.0
            elif metric == "Write":
                wgbps = value/1000.0
    gbps = rgbps + wgbps
    if gbps > _max_sys_bw:
        _max_sys_bw = gbps
    if rgbps > _max_sys_rbw:
        _max_sys_rbw = rgbps
    if wgbps > _max_sys_wbw:
        _max_sys_wbw = wgbps
    max_bw = max(_max_sys_rbw, _max_sys_wbw)
    bm_width = 25*2
    bm = Bitmap()
    read_max_idx = max(int(bm_width * _max_sys_rbw / max_bw)-1,0)
    read_empty = [0]*bm_width
    read_bar = [1]*int(bm_width * rgbps / max_bw) + [0]*(bm_width-int(bm_width * rgbps / max_bw))
    read_empty[read_max_idx] = 1
    read_bar[read_max_idx] = 1
    write_max_idx = max(int(bm_width * _max_sys_wbw / max_bw)-1,0)
    write_empty = [0]*bm_width
    write_bar = [1]*int(bm_width * wgbps / max_bw) + [0]*(bm_width-int(bm_width * wgbps / max_bw))
    write_empty[write_max_idx] = 1
    write_bar[write_max_idx] = 1
    bm.set_line(-1, read_empty)
    bm.set_line(-1, read_bar)
    bm.set_line(-1, write_empty)
    bm.set_line(-1, write_bar)
    print(f"sysR+W {rgbps+wgbps:6.1f} GB/s{bm.to_braille()} {_max_sys_bw:6.1f} GB/s")

def print_cpu_load2(pkg, cpus, cpu_usage, cpu_ls):
    try:
        width = os.get_terminal_size().columns
    except:
        width = 72
    height_pts = 8 # resolution in braille points
    lines = []
    prev_pkg = None
    for node in sorted(set([cpu[0] for cpu in cpus])):
        line0 = []
        line1 = []
        line2 = []
        usage = []
        lshare = [] # largest share that any process got on a CPU
        for cpu in cpus:
            if cpu[0] != node or cpu[1] != pkg:
                continue
            if not line0:
                if cpu[1] != prev_pkg:
                    if prev_pkg is not None:
                        lines.append([""])
                    prev_pkg = cpu[1]
                line0.append(f" pkg{cpu[1]:2}")
                line1.append(f"node{cpu[0]:2}")
                line2.append(f"coreid")
            vcpu = cpu[-1]
            usage.append(round(height_pts * cpu_usage[vcpu]))
            if cpu_ls:
                # 99 % CPU usage is shown as 100 % in the braille,
                # anything lower than that lacks the last braille dot.
                lshare.append(int(height_pts * min(1.0, .01 + cpu_ls.get(vcpu, 0))))
            if len(usage) == 2:
                bm = Bitmap()
                if cpu_ls and lshare:
                    lshare_col0 = [0]*height_pts
                    if lshare[0] > 0:
                        lshare_col0[height_pts-lshare[0]] = 1
                    bm.add_col(lshare_col0)
                else:
                    bm.add_col([0]*height_pts)
                for u in usage:
                    coldata =  [0]*(height_pts-u) + [1]*u
                    bm.add_col(coldata)
                if cpu_ls and len(lshare) == 2:
                    lshare_col1 = [0]*height_pts
                    if lshare[1] > 0:
                        lshare_col1[height_pts-lshare[1]] = 1
                    bm.add_col(lshare_col1)
                else:
                    bm.add_col([0]*height_pts)
                s = bm.to_braille()
                if cpu[-2] % 4 == 0:
                    bgon = "\x1b[48;5;14m"
                    bgoff = "\x1b[0m"
                else:
                    bgon = ""
                    bgoff = ""
                line0.append(bgon + (s.split("\n")[0]) + bgoff)
                line1.append(bgon + (s.split("\n")[1]) + bgoff)
                line2.append(bgon + (" " + str(cpu[-2]))[-2:] + bgoff)
                usage = []
                lshare = []
        if line0:
            lines.append(line0)
            lines.append(line1)
            lines.append(line2)
    print("\n".join("".join(line) for line in lines))

if __name__ == "__main__":
    import getopt
    opt_delay = 1.0
    opt_memory = False
    opt_upi = False
    opt_largest_share = False

    # get stats on cpu pid events
    try:
        opts, remainder = getopt.gnu_getopt(
            sys.argv[1:], 'hd:lmu',
            ['help', 'delay=', 'largest-share', 'memory', 'upi'])
    except Exception as e:
        error(str(e))
    for opt, arg in opts:
        if opt in ["-h", "--help"]:
            print(__doc__)
            sys.exit(0)
        elif opt in ["-d", "--delay"]:
            try:
                opt_delay = float(arg)
            except:
                error("invalid delay: %s" % (arg,))
        elif opt in ["-l", "--largest-share"]:
            opt_largest_share = True
        elif opt in ["-m", "--memory"]:
            opt_memory = True
        elif opt in ["-u", "--upi"]:
            opt_upi = True
        else:
            error("internal error: unhandled option: %s" % (opt,))

    cpus = read_topology()
    add_numa_info_to_pkg(cpus)
    max_pkg = max([cpu[1] for cpu in cpus])
    membw_usage, upi_usage = None, None
    cpu_usage_from_proc() # read initial values

    if opt_largest_share:
        print("starting bpftrace")
        try:
            cpu_pid_stats()
        except Exception as err:
            error("cannot run bpftrace to show -l/--largest-share data: %s" % (err,))

    if opt_upi:
        print("starting pcm")
        try:
            upi_from_pcm()
        except Exception as err:
            error("cannot run pcm to show -u/--upi data: %s" % (err,))

    if opt_memory:
        print("starting pcm-memory")
        try:
            membw_from_pcm()
        except Exception as err:
            error("cannot run pcm-memory to show -m/--memory data: %s" % (err,))
        if opt_upi:
            print("sync pcm and pcm-memory")
            # read already printed lines from pcm output
            _start, _end = 0, 0
            while _end - _start < opt_delay/10:
                _start, _, _end = time.time(), upi_from_pcm(), time.time()
    else:
        membw_from_pcm = lambda: time.sleep(opt_delay)

    cpu_ls = {}
    # clear terminal
    print("\x1b[2J", end="")
    while True:
        membw_usage = membw_from_pcm()
        if opt_upi:
            upi_usage = upi_from_pcm()

        # move cursor to top left
        print("\x1b[H", end="")

        if opt_memory:
            print_membw_usage(0, membw_usage)
            print()

        cpu_usage = cpu_usage_from_proc()
        if opt_largest_share:
            cps = cpu_pid_stats()
            cpu_ls = cpu_lshare(cps, cpu_usage)

        print_cpu_load2(0, cpus, cpu_usage, cpu_ls)

        if max_pkg > 0:
            if opt_upi:
                print_upi_usage(0, upi_usage, "\u2193")
            for pkg in range(1, max_pkg + 1):
                print()
                if opt_upi:
                    print_upi_usage(pkg, upi_usage, "\u2191")
                print_cpu_load2(pkg, cpus, cpu_usage, cpu_ls)

            if membw_usage:
                for pkg in range(1, max_pkg + 1):
                    print()
                    print_membw_usage(pkg, membw_usage)
        if membw_usage:
            print()
            print_sysmbw_usage(membw_usage)

```

`scripts/ufs-die-stat.sh`:

```sh
#!/bin/bash


echo "Intel(r) Performance Counter Monitor"
echo "Uncore Frequency Scaling: Die Statistics Utility"
echo

# Run the pcm-tpmi command and store the output
output=$(pcm-tpmi 2 0x10 -d)

# Use a while loop to read each line of the output
echo "$output" | while read -r line; do
    # Check if the line contains "Read value"
    if [[ $line =~ Read\ value\ ([0-9]+)\ from\ TPMI\ ID\ 2@16\ for\ entry\ ([0-9]+)\ in\ instance\ ([0-9]+) ]]; then
        # Extract the value using BASH_REMATCH
        value=${BASH_REMATCH[1]}
	die=${BASH_REMATCH[2]}
	instance=${BASH_REMATCH[3]}
	
	# Extract socket ID if present in the output (format: "(socket X)")
	if [[ $line =~ \(socket\ ([0-9]+)\) ]]; then
	    socket=${BASH_REMATCH[1]}
	else
	    # Fallback to instance ID if socket info is not available
	    socket=$instance
	fi

	# Extract NUMA node ID if present in the output (format: "(NUMA node X)")
	numa_node=""
	if [[ $line =~ \(NUMA\ node\ ([0-9]+)\) ]]; then
	    numa_node=${BASH_REMATCH[1]}
	fi

        freq=$(( (value & 0x7F) * 100 ))
        compute=$(( (value >> 23) & 1 ))
        llc=$(( (value >> 24) & 1 ))
        memory=$(( (value >> 25) & 1 ))
        io=$(( (value >> 26) & 1 ))

        die_type=""
        if [ "$compute" -ne 0 ]; then
                die_type="compute/"
        fi
        if [ "$llc" -ne 0 ]; then
                die_type="${die_type}LLC/"
        fi
        if [ "$memory" -ne 0 ]; then
                die_type="${die_type}memory/"
        fi
        if [ "$io" -ne 0 ]; then
                die_type="${die_type}IO"
        fi
        die_type="${die_type%"${die_type##*[!\/]}"}"
        str="Socket $socket"
        if [ -n "$numa_node" ]; then
            str="$str NUMA node $numa_node"
        fi
        str="$str instance $instance die $die ($die_type) uncore frequency"
        printf "%-60s: %d MHz\n" "$str" "$freq"
    fi
done


```

`src/CMakeLists.txt`:

```txt
# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2022-2025, Intel Corporation

# All pcm-* executables
set(PROJECT_NAMES pcm pcm-numa pcm-latency pcm-power pcm-msr pcm-memory pcm-tsx pcm-pcie pcm-core pcm-iio pcm-pcicfg pcm-mmio pcm-tpmi pcm-raw pcm-accel pcm-sensor-server)

set(MINIMUM_OPENSSL_VERSION 1.1.1)

file(GLOB COMMON_SOURCES pcm-accel-common.cpp msr.cpp cpucounters.cpp pci.cpp mmio.cpp tpmi.cpp pmt.cpp bw.cpp utils.cpp topology.cpp debug.cpp threadpool.cpp uncore_pmu_discovery.cpp pcm-iio-pmu.cpp pcm-iio-topology.cpp lspci.cpp dashboard.cpp ${PCM_PUGIXML_CPP})

if (NOT APPLE)
  file(GLOB UNIX_SOURCES resctrl.cpp)
endif()

if (LINUX)
    if(EXISTS "/etc/os-release") #  AND IS_READABLE "/etc/os-release" (3.29 cmake required :-( )
      file(STRINGS "/etc/os-release" OS_RELEASE_CONTENTS)
      foreach(LINE ${OS_RELEASE_CONTENTS})
          if(LINE MATCHES "^ID=")
              string(REGEX REPLACE "^ID=\"?\([a-zA-Z]+\)\"?" "\\1" OS_ID ${LINE})
          endif()
      endforeach()
      message(STATUS "Detected Linux distribution: ${OS_ID}")
    else()
      message(STATUS "Unable to read /etc/os-release")
    endif()
endif()

if(NOT PCM_NO_ASAN)
    if(OS_ID STREQUAL "centos")
        set(PCM_NO_STATIC_LIBASAN ON)
        message(STATUS "CentOS detected, using dynamic libasan")
    endif()
    if(OS_ID STREQUAL "arch")
        set(PCM_NO_STATIC_LIBASAN ON)
        message(STATUS "arch Linux detected, using dynamic libasan")
    endif()
endif()

if(UNIX)  # LINUX, FREE_BSD, APPLE
    if (NOT APPLE)
      set(CMAKE_EXE_LINKER_FLAGS_RELEASE "${CMAKE_EXE_LINKER_FLAGS} -s")  # --strip-unneeded for packaging
    endif()
    list(APPEND PROJECT_NAMES pcm-sensor)

    # libpcm.a
    add_library(PCM_STATIC STATIC ${COMMON_SOURCES} ${UNIX_SOURCES})
    set_target_properties(PCM_STATIC PROPERTIES OUTPUT_NAME pcm)

    # libpcm.a with -DPCM_SILENT for Release*
    add_library(PCM_STATIC_SILENT STATIC ${COMMON_SOURCES} ${UNIX_SOURCES})
    target_compile_definitions(PCM_STATIC_SILENT PRIVATE
      $<$<CONFIG:Release>:PCM_SILENT>
      $<$<CONFIG:MinSizeRel>:PCM_SILENT>
      $<$<CONFIG:RelWithDebInfo>:PCM_SILENT>
    )

    set_target_properties(PCM_STATIC PROPERTIES POSITION_INDEPENDENT_CODE ON)
    set_target_properties(PCM_STATIC_SILENT PROPERTIES POSITION_INDEPENDENT_CODE ON)

    # libpcm.so
    add_library(PCM_SHARED SHARED pcm-core.cpp)
    target_compile_options(PCM_SHARED PRIVATE -DPCM_SHARED_LIBRARY=1)
    # PCM_SILENT in Release* for pcm-core.cpp
    target_compile_definitions(PCM_SHARED PRIVATE
      $<$<CONFIG:Release>:PCM_SILENT>
      $<$<CONFIG:MinSizeRel>:PCM_SILENT>
      $<$<CONFIG:RelWithDebInfo>:PCM_SILENT>
    )

    if(PCM_NO_ASAN)
        set(PCM_DYNAMIC_ASAN "")
        set(PCM_STATIC_ASAN "")
    else()
        if(PCM_NO_STATIC_LIBASAN)
            message(STATUS "Using dynamic libasan")
            set(PCM_DYNAMIC_ASAN "asan")
            set(PCM_STATIC_ASAN "")
        else()
            set(PCM_DYNAMIC_ASAN "")
            set(PCM_STATIC_ASAN "-static-libasan")
            message(STATUS "Using static libasan")
            message(STATUS "To use dynamic libasan, use -DPCM_NO_STATIC_LIBASAN=1 option (required for CentOS and arch Linux)")
        endif()
    endif()

    if(APPLE)
        add_subdirectory(MacMSRDriver)
        include_directories("${CMAKE_SOURCE_DIR}/src/MacMSRDriver") # target_include_directories doesn't work
        target_link_libraries(PCM_SHARED PRIVATE PCM_STATIC_SILENT PcmMsr Threads::Threads)
    elseif(LINUX)
        target_link_libraries(PCM_SHARED PRIVATE PCM_STATIC_SILENT Threads::Threads "${PCM_DYNAMIC_ASAN}")
    else()
        target_link_libraries(PCM_SHARED PRIVATE PCM_STATIC_SILENT Threads::Threads)
    endif()
    set_target_properties(PCM_SHARED PROPERTIES OUTPUT_NAME pcm)
endif()

if(MSVC)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /O2 /wd4251 /wd4273 /EHa /Zi /GS /Gy")
    add_definitions(/W3)
    # SDL429 security flags: ASLR (/DYNAMICBASE) and DEP (/NXCOMPAT)
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /DYNAMICBASE /NXCOMPAT")
    # Optional Spectre mitigation for newer MSVC versions
    if(MSVC_TOOLSET_VERSION GREATER_EQUAL 141)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /Qspectre")
    endif()

    # windows/* files -> PCM_STATIC
    file(GLOB WINDOWS_SOURCES winpmem/winpmem.cpp windows/stdafx.cpp freegetopt/getopt.cpp)
    add_library(PCM_STATIC STATIC ${COMMON_SOURCES} ${WINDOWS_SOURCES})
    target_compile_definitions(PCM_STATIC PRIVATE UNICODE _UNICODE _CONSOLE)
    if(PCM_NO_STATIC_MSVC_RUNTIME_LIBRARY)
        set(PCM_MSVC_RUNTIME_LIBRARY_OPTIONS "")
    else()
        set(PCM_MSVC_RUNTIME_LIBRARY_OPTIONS "/MT$<$<CONFIG:Debug>:d>")
        message(STATUS "Using static MSVC runtime library")
        message(STATUS "To use default/dynamic MSVC runtime library, use -DNO_STATIC_MSVC_RUNTIME_LIBRARY=1 option")
    endif()
    target_compile_options(PCM_STATIC PRIVATE "${PCM_MSVC_RUNTIME_LIBRARY_OPTIONS}")

    # Graphical perfmon front-end: pcm-lib, pcm-service
    # Files: COMMON_FILES() + pcm-lib.cpp winpmem\winpmem.cpp dllmain.cpp
    file(GLOB PCM_LIB_SOURCES winpmem/winpmem.cpp dllmain.cpp pcm-lib.cpp )
    add_library(pcm-lib SHARED ${COMMON_SOURCES} ${PCM_LIB_SOURCES})
    target_compile_definitions(pcm-lib PRIVATE _WINDOWS _USRDLL PCM_EXPORTS _WINDLL _UNICODE UNICODE)
    target_compile_options(pcm-lib PRIVATE "${PCM_MSVC_RUNTIME_LIBRARY_OPTIONS}")

    # Pcm-service files: PCM_SHARED + AssemblyInfo.cpp PCMInstaller.cpp PCMService.cpp
    file(GLOB PCM_SERVICE_SOURCES windows/PCMInstaller.cpp  windows/PCMService.cpp windows/AssemblyInfo.cpp winddows/utils.cpp)
    add_executable(pcm-service ${PCM_SERVICE_SOURCES})
    target_compile_definitions(pcm-service PRIVATE _UNICODE UNICODE _CONSOLE)
    set_target_properties(pcm-service PROPERTIES LINK_FLAGS "/INCREMENTAL:NO" COMMON_LANGUAGE_RUNTIME "")
    set_property(TARGET pcm-service PROPERTY VS_DOTNET_REFERENCES "System;System.Configuration.Install;System.Data;System.Management;System.ServiceProcess;System.Xml")
    target_link_libraries(pcm-service pcm-lib)

endif(MSVC)

#######################
# SIMDJSON dependency
#######################

add_library(PCM_SIMDJSON INTERFACE) # interface library for simdjson
set(SIMDJSON_IS_APPLICABLE TRUE)    # true if simdjson can be used, default - TRUE

# check simdjson support matrix - https://github.com/simdjson/simdjson/blob/master/doc/basics.md
# > GCC 7.4, > Clang 6.0 , > MSVC 2017
if((CMAKE_CXX_COMPILER_ID STREQUAL "GNU"   AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 7.4) OR
    (CMAKE_CXX_COMPILER_ID STREQUAL "Clang" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 6) OR
    (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC"  AND  MSVC_TOOLSET_VERSION VERSION_LESS 141)) # corresponds to VS2017
     message(WARNING
           " ${CMAKE_CXX_COMPILER} ${CMAKE_CXX_COMPILER_VERSION} is incompartible with simdjson features' requirements.\n"
           " Refer to simdjson support matrix - https://github.com/simdjson/simdjson/blob/master/doc/basics.md .\n"
           " Parsing events from https://github.com/intel/perfmon won't be supported.")
        set(SIMDJSON_IS_APPLICABLE FALSE)
endif()

if(SIMDJSON_IS_APPLICABLE)
    find_package(simdjson QUIET)  # Working form Ubuntu 22.04
    if(simdjson_FOUND)
        message(STATUS "System SIMDJSON is used")
        target_link_libraries(PCM_SIMDJSON INTERFACE simdjson::simdjson)
        target_compile_definitions(PCM_SIMDJSON INTERFACE SYSTEM_SIMDJSON)
        target_compile_definitions(PCM_SIMDJSON INTERFACE PCM_SIMDJSON_AVAILABLE)
    else()
        if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/simdjson/singleheader/simdjson.h")
            message(STATUS "Local SIMDJSON exists: ${CMAKE_CURRENT_SOURCE_DIR}/simdjson/singleheader/simdjson.h")
            file(GLOB SIMDJSON_SOURCE ${CMAKE_CURRENT_SOURCE_DIR}/simdjson/singleheader/simdjson.cpp)
            target_sources(PCM_SIMDJSON INTERFACE ${SIMDJSON_SOURCE})
            target_include_directories(PCM_SIMDJSON INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/simdjson/singleheader)
            target_compile_definitions(PCM_SIMDJSON INTERFACE PCM_SIMDJSON_AVAILABLE)
        else()
            message(WARNING
                " ${CMAKE_CURRENT_SOURCE_DIR}/simdjson/singleheader/simdjson.h doesn't exist\n"
                " Use `git clone --recursive` flag when cloning pcm repository to clone simdjson submodule as well or\n"
                " update submodule with command 'git submodule update --init --recursive' or\n"
                " run 'git clone https://github.com/simdjson/simdjson.git' in 'src' directory to get simdjson library")
        endif()
    endif(simdjson_FOUND)
endif(SIMDJSON_IS_APPLICABLE)

#######################
# End of SIMDJSON dependency section
#######################

if(PCM_BUILD_EXECUTABLES)
    foreach(PROJECT_NAME ${PROJECT_NAMES})
        file(GLOB PROJECT_FILE ${PROJECT_NAME}.cpp)
        set(LIBS PCM_STATIC)

        add_executable(${PROJECT_NAME} ${PROJECT_FILE})

        if(MSVC)
            target_compile_options(${PROJECT_NAME} PRIVATE "${PCM_MSVC_RUNTIME_LIBRARY_OPTIONS}")
        endif(MSVC)

        if(UNIX)
            set(LIBS ${LIBS} "-fPIE")
        endif(UNIX)

        if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
            set_target_properties(${PROJECT_NAME} PROPERTIES LINK_FLAGS "${PCM_STATIC_ASAN}")
        endif()

        # specific file for pcm-raw project
        if(${PROJECT_NAME} STREQUAL pcm-raw)
            set(LIBS ${LIBS} PCM_SIMDJSON)
        endif(${PROJECT_NAME} STREQUAL pcm-raw)

        if(${PROJECT_NAME} STREQUAL pcm-sensor-server)
          if(NO_SSL)
            message(STATUS "SSL is disabled")
          else()
            message(STATUS "Compiling with SSL support, requires libssl-dev or openssl-devel or libopenssl-devel or libopenssl-dev package installed")
            message(STATUS "To disable SSL support, use -DNO_SSL=1 option")
            find_package(OpenSSL ${MINIMUM_OPENSSL_VERSION} QUIET)
            if(OPENSSL_FOUND)
              message(STATUS "OpenSSL version ${OPENSSL_VERSION} >= ${MINIMUM_OPENSSL_VERSION}, OpenSSL support enabled")
              target_compile_options(${PROJECT_NAME} PRIVATE "-DUSE_SSL")
              set(LIBS ${LIBS} OpenSSL::SSL OpenSSL::Crypto)
              if(MSVC)
                # Static OpenSSL on Windows depends on these system libraries
                set(LIBS ${LIBS} crypt32 ws2_32)
              endif()
            else()
              message(STATUS "OpenSSL support has been disabled, the version is less than ${MINIMUM_OPENSSL_VERSION}")
            endif()
          endif()
          file(READ pcm-sensor-server.service.in SENSOR_SERVICE_IN)
          string(REPLACE "@@CMAKE_INSTALL_SBINDIR@@" "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_SBINDIR}" SENSOR_SERVICE "${SENSOR_SERVICE_IN}")
          file(WRITE "${CMAKE_BINARY_DIR}/pcm-sensor-server.service" "${SENSOR_SERVICE}")
          file(GLOB PROJECT_FILE ${PROJECT_NAME}.cpp pcm-accel-common.h pcm-accel-common.cpp)
          target_include_directories(pcm-sensor-server PUBLIC ${CMAKE_SOURCE_DIR})
          if(LINUX_SYSTEMD)
            install(FILES "${CMAKE_BINARY_DIR}/pcm-sensor-server.service" DESTINATION "${LINUX_SYSTEMD_UNITDIR}")
          endif(LINUX_SYSTEMD)
        endif(${PROJECT_NAME} STREQUAL pcm-sensor-server)

        if(LINUX OR FREE_BSD)
            set(LIBS ${LIBS} Threads::Threads)
            install(TARGETS ${PROJECT_NAME} DESTINATION ${CMAKE_INSTALL_SBINDIR})
        endif(LINUX OR FREE_BSD)

        if(APPLE)
            set(LIBS ${LIBS} Threads::Threads PcmMsr)
            install(TARGETS ${PROJECT_NAME} DESTINATION ${CMAKE_INSTALL_SBINDIR})
        endif(APPLE)

        if(MSVC)
            target_compile_definitions(${PROJECT_NAME} PRIVATE _UNICODE UNICODE _CONSOLE) # for all, except pcm-lib and pcm-service
        endif(MSVC)

        target_link_libraries(${PROJECT_NAME} PRIVATE ${LIBS})
    endforeach(PROJECT_NAME ${PROJECT_NAMES})
endif(PCM_BUILD_EXECUTABLES)

#######################
# Install
#######################

if(UNIX) # APPLE, LINUX, FREE_BSD
    if(LINUX)
        # Daemon & client
        file(GLOB DAEMON_SOURCES "daemon/*.cpp")
        add_executable(daemon ${DAEMON_SOURCES})
        target_link_libraries(daemon PRIVATE PCM_STATIC Threads::Threads "-fPIE")
        set_target_properties(daemon PROPERTIES OUTPUT_NAME "pcm-daemon")
        install(TARGETS daemon DESTINATION ${CMAKE_INSTALL_SBINDIR})

        file(GLOB CLIENT_SOURCES "client/*.cpp")
        add_executable(client ${CLIENT_SOURCES})
        target_link_libraries(client PRIVATE Threads::Threads "-fPIE")
        set_target_properties(client PROPERTIES OUTPUT_NAME "pcm-client")
        install(TARGETS client DESTINATION ${CMAKE_INSTALL_BINDIR})
    endif(LINUX)

    # Install extra files
    install(FILES pcm-bw-histogram.sh
            DESTINATION ${CMAKE_INSTALL_SBINDIR}
            RENAME pcm-bw-histogram
            PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ WORLD_EXECUTE WORLD_READ)
    file(GLOB OPCODE_FILES "opCode*.txt")
    foreach(opcode_file ${OPCODE_FILES})
        get_filename_component(opcode_file_name ${opcode_file} NAME)
        configure_file(${opcode_file} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${opcode_file_name} COPYONLY)
        install(FILES ${opcode_file} DESTINATION ${CMAKE_INSTALL_DATADIR}/pcm)
    endforeach(opcode_file ${OPCODE_FILES})

    file(COPY "PMURegisterDeclarations" DESTINATION ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
    install(DIRECTORY "PMURegisterDeclarations" DESTINATION ${CMAKE_INSTALL_DATADIR}/pcm)

    # Install docs
    install(FILES ${CMAKE_SOURCE_DIR}/LICENSE DESTINATION ${CMAKE_INSTALL_DATADIR}/licenses/pcm)
    install(FILES ${CMAKE_SOURCE_DIR}/README.md DESTINATION ${CMAKE_INSTALL_DOCDIR})

    file(GLOB DOC_FILES  ${CMAKE_SOURCE_DIR}/doc/*.txt  ${CMAKE_SOURCE_DIR}/doc/*.md)
    foreach(doc_file ${DOC_FILES})
        get_filename_component(doc_file_name ${doc_file} NAME)
        configure_file(${doc_file} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${doc_file_name} COPYONLY)
        install(FILES ${doc_file} DESTINATION ${CMAKE_INSTALL_DOCDIR})
    endforeach(doc_file ${DOC_FILES})

endif(UNIX)

if(MSVC)
    file(GLOB OPCODE_FILES "opCode*.txt")
    foreach(opcode_file ${OPCODE_FILES})
        add_custom_command(TARGET pcm-iio POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E copy_if_different
            ${opcode_file}
            $<TARGET_FILE_DIR:pcm-iio>)
    endforeach(opcode_file ${OPCODE_FILES})

    add_custom_command(TARGET pcm-raw POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E make_directory
        "$<TARGET_FILE_DIR:pcm-raw>/PMURegisterDeclarations")
    add_custom_command(TARGET pcm-raw POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_directory
        "${PROJECT_SOURCE_DIR}/src/PMURegisterDeclarations"
        "$<TARGET_FILE_DIR:pcm-raw>/PMURegisterDeclarations")
    add_custom_command(TARGET pcm-service POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
        "${PROJECT_SOURCE_DIR}/src/windows/pcm-service.exe.config"
        $<TARGET_FILE_DIR:pcm-service>)
endif(MSVC)

```

`src/MacMSRDriver/CMakeLists.txt`:

```txt
# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2022, Intel Corporation

set(CMAKE_MACOSX_RPATH 1)

set(CMAKE_CXX_FLAGS "-Wall")
set(CMAKE_CXX_FLAGS_RELEASE "-O3")
set(CMAKE_CXX_FLAGS_DEBUG "-O0 -g")

file(GLOB LIB_FILES PCIDriverInterface.cpp MSRAccessor.cpp)

find_library(IOKIT_LIBRARY IOKit)
add_library(PcmMsr SHARED ${LIB_FILES})
target_link_libraries(PcmMsr PRIVATE ${IOKIT_LIBRARY})

add_subdirectory(PcmMsr)

# Installation
install(TARGETS PcmMsr DESTINATION "lib")

```

`src/MacMSRDriver/MSRAccessor.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2012, Intel Corporation
// written by Austen Ott
//
#include "MSRAccessor.h"
#include <exception>
#include <iostream>
#include <iomanip>

using namespace std;

MSRAccessor::MSRAccessor()
{
    service = IOServiceGetMatchingService(kIOMainPortDefault,
                                          IOServiceMatching(kPcmMsrDriverClassName));
    openConnection();
}

int32_t MSRAccessor::buildTopology(uint32_t num_cores, void* pTopos)
{
    size_t topology_struct_size = sizeof(TopologyEntry)*num_cores;

    kern_return_t ret = IOConnectCallStructMethod(connect, kBuildTopology,
                                                  NULL, 0,
                                                  pTopos, &topology_struct_size);
    return (ret == KERN_SUCCESS) ? 0 : -1;
}

int32_t MSRAccessor::read(uint32_t core_num, uint64_t msr_num, uint64_t * value)
{
    pcm_msr_data_t idatas, odatas;

    size_t struct_size = sizeof(pcm_msr_data_t);
    idatas.msr_num = (uint32_t)msr_num;
    idatas.cpu_num = core_num;

    kern_return_t ret = IOConnectCallStructMethod(connect, kReadMSR,
                                                  &idatas, struct_size,
                                                  &odatas, &struct_size);

    if(ret == KERN_SUCCESS)
    {
        *value = odatas.value;
        return sizeof(uint64_t);
    } else {
        return -1;
    }
}

int32_t MSRAccessor::write(uint32_t core_num, uint64_t msr_num, uint64_t value){
    pcm_msr_data_t idatas;

    idatas.value = value;
    idatas.msr_num = (uint32_t)msr_num;
    idatas.cpu_num = core_num;

    kern_return_t ret = IOConnectCallStructMethod(connect, kWriteMSR,
                                                  &idatas, sizeof(pcm_msr_data_t),
                                                  NULL, NULL);

    if(ret == KERN_SUCCESS)
    {
        return sizeof(uint64_t);
    } else {
        return -1;
    }
}

uint32_t MSRAccessor::getNumInstances()
{
    kern_return_t   kernResult;
    uint32_t        output_count = 1;
    uint64_t        knum_insts = 0;

    kernResult = IOConnectCallScalarMethod(connect,
                                           kGetNumInstances,
                                           NULL, 0,
                                           &knum_insts, &output_count);

    if (kernResult != KERN_SUCCESS)
    {
        cerr << "IOConnectCallScalarMethod returned 0x" << hex << setw(8) << kernResult << dec << endl;
    }
    // TODO add error handling; also, number-of-instance related
    // functions may go away as they do not appear to be used.
    return knum_insts;
}

uint32_t MSRAccessor::incrementNumInstances()
{
    kern_return_t   kernResult;
    uint32_t        output_count = 1;
    uint64_t        knum_insts = 0;

    kernResult = IOConnectCallScalarMethod(connect,
                                           kIncrementNumInstances,
                                           NULL, 0,
                                           &knum_insts, &output_count);

    if (kernResult != KERN_SUCCESS)
    {
        cerr << "IOConnectCallScalarMethod returned 0x" << hex << setw(8) << kernResult << dec << endl;
    }
    // TODO add error handling; also, these functions may go away as
    // they do not appear to be used.
    return knum_insts;
}

uint32_t MSRAccessor::decrementNumInstances()
{
    kern_return_t   kernResult;
    uint32_t        output_count = 1;
    uint64_t        knum_insts = 0;

    kernResult = IOConnectCallScalarMethod(connect, kDecrementNumInstances,
                                           NULL, 0,
                                           &knum_insts, &output_count);

    if (kernResult != KERN_SUCCESS)
    {
        cerr << "IOConnectCallScalarMethod returned 0x" << hex << setw(8) << kernResult << dec << endl;
    }
    // TODO add error handling; also, these functions may go away as
    // they do not appear to be used.
    return knum_insts;
}

MSRAccessor::~MSRAccessor()
{
    closeConnection();
}

kern_return_t MSRAccessor::openConnection()
{
    kern_return_t kernResult = IOServiceOpen(service, mach_task_self(), 0, &connect);

    if (kernResult != KERN_SUCCESS)
    {
        cerr << "IOServiceOpen returned 0x" << hex << setw(8) << kernResult << dec <<  endl;
    } else {
        kernResult = IOConnectCallScalarMethod(connect, kOpenDriver, NULL, 0, NULL, NULL);

        if (kernResult != KERN_SUCCESS)
        {
            cerr << "kOpenDriver returned 0x" << hex << setw(8) << kernResult << dec <<  endl;
        }
    }

    return kernResult;
}

void MSRAccessor::closeConnection()
{
    kern_return_t kernResult = IOConnectCallScalarMethod(connect, kCloseDriver,
                                                         NULL, 0, NULL, NULL);
    if (kernResult != KERN_SUCCESS)
    {
        cerr << "kCloseDriver returned 0x" << hex << setw(8) << kernResult << dec << endl;
    }

    kernResult = IOServiceClose(connect);
    if (kernResult != KERN_SUCCESS)
    {
        cerr << "IOServiceClose returned 0x" << hex << setw(8) << kernResult << dec << endl;
    }
}

```

`src/MacMSRDriver/MSRAccessor.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2012, Intel Corporation
// written by Austen Ott
//    

#include <IOKit/IOKitLib.h>
#include "PcmMsr/UserKernelShared.h"

class MSRAccessor
{
private:
    io_service_t service;
    io_connect_t connect;
    kern_return_t openConnection();
    void closeConnection();
public:
    MSRAccessor();
    int32_t read(uint32_t cpu_num,uint64_t msr_num, uint64_t * value);
    int32_t write(uint32_t cpu_num, uint64_t msr_num, uint64_t value);
    int32_t buildTopology(uint32_t num_cores, void*);
    
    uint32_t getNumInstances();
    uint32_t incrementNumInstances();
    uint32_t decrementNumInstances();
    ~MSRAccessor();
};

```

`src/MacMSRDriver/MSRKernel.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2012, Intel Corporation
// written by Austen Ott
//    
#define PcmMsrDriverClassName com_intel_driver_PcmMsr
#define kPcmMsrDriverClassName "com_intel_driver_PcmMsr"
#ifndef MSR_KERNEL_SHARED
#define MSR_KERNEL_SHARED
#include <stdint.h>
typedef struct {
    uint64_t value;
    uint32_t cpu_num;
    uint32_t msr_num;
} pcm_msr_data_t;

#endif

```

`src/MacMSRDriver/PCIDriverInterface.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2013, Intel Corporation
// written by Patrick Konsor
//

#include <stdio.h>
#include <map>
#include "PCIDriverInterface.h"
#include <IOKit/IOKitLib.h>
#include "PcmMsr/UserKernelShared.h"

io_connect_t PCIDriver_connect = 0;
std::map<uint8_t*,void*> PCIDriver_mmap;

// setupDriver
#ifdef __cplusplus
extern "C"
#endif
int PCIDriver_setupDriver()
{
     kern_return_t   kern_result;
     io_iterator_t   iterator;
     bool            driverFound = false;
     io_service_t    local_driver_service;

     // get services
     kern_result = IOServiceGetMatchingServices(kIOMainPortDefault,
                                                IOServiceMatching(kPcmMsrDriverClassName),
                                                &iterator);
     if (kern_result != KERN_SUCCESS) {
          fprintf(stderr, "[error] IOServiceGetMatchingServices returned 0x%08x\n", kern_result);
          return kern_result;
     }

     // find service
     while ((local_driver_service = IOIteratorNext(iterator)) != IO_OBJECT_NULL) {
          driverFound = true;
          break;
     }

     if (driverFound == false) {
          fprintf(stderr, "[error] No matching drivers found \"%s\".\n", kPcmMsrDriverClassName);
          return KERN_FAILURE;
     }
     IOObjectRelease(iterator);

     // connect to service
     kern_result = IOServiceOpen(local_driver_service, mach_task_self(), 0, &PCIDriver_connect);
     if (kern_result != KERN_SUCCESS) {
          fprintf(stderr, "[error] IOServiceOpen returned 0x%08x\n", kern_result);
          return kern_result;
     }

     return KERN_SUCCESS;
}


// read32
#ifdef __cplusplus
extern "C"
#endif
uint32_t PCIDriver_read32(uint32_t addr, uint32_t* val)
{
	if (!PCIDriver_connect) {
		if (PCIDriver_setupDriver() != KERN_SUCCESS) {
			return KERN_FAILURE;
		}
	}
	
	uint64_t input[] = { (uint64_t)addr };
	uint64_t val_ = 0;
	uint32_t outputCnt = 1;
	kern_return_t result = IOConnectCallScalarMethod(PCIDriver_connect, kRead, input, 1, &val_, &outputCnt);
	*val = (uint32_t)val_;
	return result;
}


// read64
#ifdef __cplusplus
extern "C"
#endif
uint32_t PCIDriver_read64(uint32_t addr, uint64_t* val)
{
	if (!PCIDriver_connect) {
		if (PCIDriver_setupDriver() != KERN_SUCCESS) {
			return KERN_FAILURE;
		}
	}
	
	kern_return_t result;
	uint64_t input[] = { (uint64_t)addr };
	uint64_t lo = 0;
	uint64_t hi = 0;
	uint32_t outputCnt = 1;
	result  = IOConnectCallScalarMethod(PCIDriver_connect, kRead, input, 1, &lo, &outputCnt);
	input[0] = (uint64_t)addr + 4;
	result |= IOConnectCallScalarMethod(PCIDriver_connect, kRead, input, 1, &hi, &outputCnt);
	*val = (hi << 32) | lo;
	return result;
}


// write32
#ifdef __cplusplus
extern "C"
#endif
uint32_t PCIDriver_write32(uint32_t addr, uint32_t val)
{
	if (!PCIDriver_connect) {
		if (PCIDriver_setupDriver() != KERN_SUCCESS) {
			return KERN_FAILURE;
		}
	}
	
	uint64_t input[] = { (uint64_t)addr, (uint64_t)val };
	return IOConnectCallScalarMethod(PCIDriver_connect, kWrite, input, 2, NULL, 0);
}


// write64
#ifdef __cplusplus
extern "C"
#endif
uint32_t PCIDriver_write64(uint32_t addr, uint64_t val)
{
	if (!PCIDriver_connect) {
		if (PCIDriver_setupDriver() != KERN_SUCCESS) {
			return KERN_FAILURE;
		}
	}
	
	kern_return_t result;
	uint64_t input[] = { (uint64_t)addr, val & 0xffffffff };
	result  = IOConnectCallScalarMethod(PCIDriver_connect, kWrite, input, 2, NULL, 0);
	input[0] = (uint64_t)addr + 4;
	input[1] = val >> 32;
	result |= IOConnectCallScalarMethod(PCIDriver_connect, kWrite, input, 2, NULL, 0);
	return result;
}

// mapMemory
#ifdef __cplusplus
extern "C"
#endif
uint32_t PCIDriver_mapMemory(uint32_t address, uint8_t** virtual_address)
{
	if (!PCIDriver_connect) {
		if (PCIDriver_setupDriver() != KERN_SUCCESS) {
			return KERN_FAILURE;
		}
	}
	
	uint64_t input[] = { (uint64_t)address };
	uint64_t output[2];
	uint32_t outputCnt = 2;
	kern_return_t result = IOConnectCallScalarMethod(PCIDriver_connect, kMapMemory, input, 1, output, &outputCnt);
	PCIDriver_mmap[(uint8_t*)output[1]] = (void*)output[0];
	*virtual_address = (uint8_t*)output[1];
	return result;
}


// unmapMemory
#ifdef __cplusplus
extern "C"
#endif
uint32_t PCIDriver_unmapMemory(uint8_t* virtual_address)
{
	if (!PCIDriver_connect) {
		if (PCIDriver_setupDriver() != KERN_SUCCESS) {
			return KERN_FAILURE;
		}
	}
	
	void* memory_map = PCIDriver_mmap[virtual_address];
	if (memory_map != NULL) {
		uint64_t input[] = { (uint64_t)memory_map };
		kern_return_t result = IOConnectCallScalarMethod(PCIDriver_connect, kUnmapMemory, input, 1, NULL, 0);
		PCIDriver_mmap.erase(virtual_address); // remove from map
		return result;
	} else {
		return KERN_INVALID_ADDRESS;
	}
}

// readMemory32
#ifdef __cplusplus
extern "C"
#endif
uint32_t PCIDriver_readMemory32(uint8_t* address, uint32_t* val)
{
	if (!PCIDriver_connect) {
		if (PCIDriver_setupDriver() != KERN_SUCCESS) {
			return KERN_FAILURE;
		}
	}
	uint64_t input[] = { (uint64_t)address };
	uint64_t val_ = 0;
	uint32_t outputCnt = 1;
	kern_return_t result = IOConnectCallScalarMethod(PCIDriver_connect, kReadMemory, input, 1, &val_, &outputCnt);
	*val = (uint32_t)val_;
	return result;
}


// readMemory64
#ifdef __cplusplus
extern "C"
#endif
uint32_t PCIDriver_readMemory64(uint8_t* address, uint64_t* val)
{
	if (!PCIDriver_connect) {
		if (PCIDriver_setupDriver() != KERN_SUCCESS) {
			return KERN_FAILURE;
		}
	}
	kern_return_t result;
	uint64_t input[] = { (uint64_t)address };
	uint64_t lo = 0;
	uint64_t hi = 0;
	uint32_t outputCnt = 1;
	result  = IOConnectCallScalarMethod(PCIDriver_connect, kReadMemory, input, 1, &lo, &outputCnt);
	input[0] = (uint64_t)address + 4;
	result |= IOConnectCallScalarMethod(PCIDriver_connect, kReadMemory, input, 1, &hi, &outputCnt);
	*val = (hi << 32) | lo;
	return result;
}

```

`src/MacMSRDriver/PCIDriverInterface.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2013, Intel Corporation
// written by Patrick Konsor
//

#ifndef pci_driver_driverinterface_h
#define pci_driver_driverinterface_h

#ifdef __cplusplus
extern "C" {
#endif

#define PCI_ENABLE                         0x80000000
#define FORM_PCI_ADDR(bus,dev,fun,off)     (((PCI_ENABLE))          |   \
                                            ((bus & 0xFF) << 16)    |   \
                                            ((dev & 0x1F) << 11)    |   \
                                            ((fun & 0x07) <<  8)    |   \
                                            ((off & 0xFF) <<  0))

uint32_t PCIDriver_read32(uint32_t addr, uint32_t* val);
uint32_t PCIDriver_read64(uint32_t addr, uint64_t* val);
uint32_t PCIDriver_write32(uint32_t addr, uint32_t val);
uint32_t PCIDriver_write64(uint32_t addr, uint64_t val);
uint32_t PCIDriver_mapMemory(uint32_t address, uint8_t** virtual_address);
uint32_t PCIDriver_unmapMemory(uint8_t* virtual_address);
uint32_t PCIDriver_readMemory32(uint8_t* address, uint32_t* val);
uint32_t PCIDriver_readMemory64(uint8_t* address, uint64_t* val);

#ifdef __cplusplus
}
#endif
	
#endif

```

`src/MacMSRDriver/PcmMsr.xcodeproj/project.pbxproj`:

```pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 46;
	objects = {

/* Begin PBXBuildFile section */
		81ADBF0A156EBD73006D9B47 /* PcmMsrClient.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 81ADBF09156EBD73006D9B47 /* PcmMsrClient.cpp */; };
		81ADBF1A156EEDB9006D9B47 /* IOKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 81ADBF0B156EDBA1006D9B47 /* IOKit.framework */; };
		81DEAF6315703531005E8EC6 /* MSRAccessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 81ADBF1C156EFF69006D9B47 /* MSRAccessor.cpp */; };
		81DEAF6615703946005E8EC6 /* DriverInterface.c in Sources */ = {isa = PBXBuildFile; fileRef = 81DEAF6515703946005E8EC6 /* DriverInterface.c */; };
		81DEAF67157039F6005E8EC6 /* DriverInterface.h in Headers */ = {isa = PBXBuildFile; fileRef = 81ADBF17156EECDA006D9B47 /* DriverInterface.h */; };
		81DEAF68157039FB005E8EC6 /* MSRAccessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 81ADBF1B156EFF56006D9B47 /* MSRAccessor.h */; };
		81F91BC6156D9BF8007DD788 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = 81F91BC4156D9BF8007DD788 /* InfoPlist.strings */; };
		81F91BC9156D9BF8007DD788 /* PcmMsr.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 81F91BC8156D9BF8007DD788 /* PcmMsr.cpp */; };
		895805FC1760E6E5006ED117 /* PCIDriverInterface.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 895805FA1760E6E5006ED117 /* PCIDriverInterface.cpp */; };
		895805FD1760E6E5006ED117 /* PCIDriverInterface.h in Headers */ = {isa = PBXBuildFile; fileRef = 895805FB1760E6E5006ED117 /* PCIDriverInterface.h */; };
/* End PBXBuildFile section */

/* Begin PBXBuildRule section */
		816FC6A5158296D200D9DEB4 /* PBXBuildRule */ = {
			isa = PBXBuildRule;
			compilerSpec = com.apple.compilers.proxy.script;
			fileType = pattern.proxy;
			isEditable = 1;
			outputFiles = (
			);
		};
/* End PBXBuildRule section */

/* Begin PBXCopyFilesBuildPhase section */
		816FC6A31582965F00D9DEB4 /* CopyFiles */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = /usr/local/lib;
			dstSubfolderSpec = 0;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		81ADBF08156EBD65006D9B47 /* PcmMsrClient.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = PcmMsrClient.h; sourceTree = "<group>"; };
		81ADBF09156EBD73006D9B47 /* PcmMsrClient.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PcmMsrClient.cpp; sourceTree = "<group>"; };
		81ADBF0B156EDBA1006D9B47 /* IOKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = IOKit.framework; path = System/Library/Frameworks/IOKit.framework; sourceTree = SDKROOT; };
		81ADBF0D156EDD11006D9B47 /* UserKernelShared.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; name = UserKernelShared.h; path = PcmMsr/UserKernelShared.h; sourceTree = "<group>"; };
		81ADBF12156EEB93006D9B47 /* libPcmMsr.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libPcmMsr.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
		81ADBF17156EECDA006D9B47 /* DriverInterface.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = DriverInterface.h; sourceTree = "<group>"; };
		81ADBF1B156EFF56006D9B47 /* MSRAccessor.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = MSRAccessor.h; sourceTree = "<group>"; };
		81ADBF1C156EFF69006D9B47 /* MSRAccessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MSRAccessor.cpp; sourceTree = "<group>"; };
		81DEAF6515703946005E8EC6 /* DriverInterface.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = DriverInterface.c; sourceTree = "<group>"; };
		81F91BBC156D9BF8007DD788 /* PcmMsrDriver.kext */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = PcmMsrDriver.kext; sourceTree = BUILT_PRODUCTS_DIR; };
		81F91BC3156D9BF8007DD788 /* PcmMsr-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "PcmMsr-Info.plist"; sourceTree = "<group>"; };
		81F91BC5156D9BF8007DD788 /* en */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = en; path = en.lproj/InfoPlist.strings; sourceTree = "<group>"; };
		81F91BC7156D9BF8007DD788 /* PcmMsr.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = PcmMsr.h; sourceTree = "<group>"; };
		81F91BC8156D9BF8007DD788 /* PcmMsr.cpp */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.cpp.cpp; path = PcmMsr.cpp; sourceTree = "<group>"; };
		81F91BCA156D9BF8007DD788 /* PcmMsr-Prefix.pch */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "PcmMsr-Prefix.pch"; sourceTree = "<group>"; };
		895805FA1760E6E5006ED117 /* PCIDriverInterface.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PCIDriverInterface.cpp; sourceTree = "<group>"; };
		895805FB1760E6E5006ED117 /* PCIDriverInterface.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PCIDriverInterface.h; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		81ADBF0F156EEB93006D9B47 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				81ADBF1A156EEDB9006D9B47 /* IOKit.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		81F91BB7156D9BF8007DD788 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		81ADBF16156EECC6006D9B47 /* PcmMsrLibrary */ = {
			isa = PBXGroup;
			children = (
				81ADBF17156EECDA006D9B47 /* DriverInterface.h */,
				81DEAF6515703946005E8EC6 /* DriverInterface.c */,
				81ADBF1B156EFF56006D9B47 /* MSRAccessor.h */,
				81ADBF1C156EFF69006D9B47 /* MSRAccessor.cpp */,
				895805FA1760E6E5006ED117 /* PCIDriverInterface.cpp */,
				895805FB1760E6E5006ED117 /* PCIDriverInterface.h */,
				81F91BC1156D9BF8007DD788 /* PcmMsr */,
			);
			name = PcmMsrLibrary;
			sourceTree = "<group>";
		};
		81F91BAF156D9BF8007DD788 = {
			isa = PBXGroup;
			children = (
				81ADBF0D156EDD11006D9B47 /* UserKernelShared.h */,
				81ADBF16156EECC6006D9B47 /* PcmMsrLibrary */,
				81F91BBE156D9BF8007DD788 /* Frameworks */,
				81F91BBD156D9BF8007DD788 /* Products */,
			);
			sourceTree = "<group>";
		};
		81F91BBD156D9BF8007DD788 /* Products */ = {
			isa = PBXGroup;
			children = (
				81F91BBC156D9BF8007DD788 /* PcmMsrDriver.kext */,
				81ADBF12156EEB93006D9B47 /* libPcmMsr.dylib */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		81F91BBE156D9BF8007DD788 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				81ADBF0B156EDBA1006D9B47 /* IOKit.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		81F91BC1156D9BF8007DD788 /* PcmMsr */ = {
			isa = PBXGroup;
			children = (
				81F91BC7156D9BF8007DD788 /* PcmMsr.h */,
				81F91BC8156D9BF8007DD788 /* PcmMsr.cpp */,
				81F91BC2156D9BF8007DD788 /* Supporting Files */,
				81ADBF08156EBD65006D9B47 /* PcmMsrClient.h */,
				81ADBF09156EBD73006D9B47 /* PcmMsrClient.cpp */,
			);
			path = PcmMsr;
			sourceTree = "<group>";
		};
		81F91BC2156D9BF8007DD788 /* Supporting Files */ = {
			isa = PBXGroup;
			children = (
				81F91BC3156D9BF8007DD788 /* PcmMsr-Info.plist */,
				81F91BC4156D9BF8007DD788 /* InfoPlist.strings */,
				81F91BCA156D9BF8007DD788 /* PcmMsr-Prefix.pch */,
			);
			name = "Supporting Files";
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXHeadersBuildPhase section */
		81ADBF10156EEB93006D9B47 /* Headers */ = {
			isa = PBXHeadersBuildPhase;
			buildActionMask = 2147483647;
			files = (
				81DEAF67157039F6005E8EC6 /* DriverInterface.h in Headers */,
				81DEAF68157039FB005E8EC6 /* MSRAccessor.h in Headers */,
				895805FD1760E6E5006ED117 /* PCIDriverInterface.h in Headers */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		81F91BB8156D9BF8007DD788 /* Headers */ = {
			isa = PBXHeadersBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXHeadersBuildPhase section */

/* Begin PBXNativeTarget section */
		81ADBF11156EEB93006D9B47 /* PcmMsrLibrary */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 81ADBF13156EEB93006D9B47 /* Build configuration list for PBXNativeTarget "PcmMsrLibrary" */;
			buildPhases = (
				81ADBF0E156EEB93006D9B47 /* Sources */,
				81ADBF0F156EEB93006D9B47 /* Frameworks */,
				81ADBF10156EEB93006D9B47 /* Headers */,
				816FC6A31582965F00D9DEB4 /* CopyFiles */,
			);
			buildRules = (
				816FC6A5158296D200D9DEB4 /* PBXBuildRule */,
			);
			dependencies = (
			);
			name = PcmMsrLibrary;
			productName = PcmMsrLibrary;
			productReference = 81ADBF12156EEB93006D9B47 /* libPcmMsr.dylib */;
			productType = "com.apple.product-type.library.dynamic";
		};
		81F91BBB156D9BF8007DD788 /* PcmMsrDriver */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 81F91BCD156D9BF8007DD788 /* Build configuration list for PBXNativeTarget "PcmMsrDriver" */;
			buildPhases = (
				81F91BB6156D9BF8007DD788 /* Sources */,
				81F91BB7156D9BF8007DD788 /* Frameworks */,
				81F91BB8156D9BF8007DD788 /* Headers */,
				81F91BB9156D9BF8007DD788 /* Resources */,
				81F91BBA156D9BF8007DD788 /* Rez */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = PcmMsrDriver;
			productName = PcmMsr;
			productReference = 81F91BBC156D9BF8007DD788 /* PcmMsrDriver.kext */;
			productType = "com.apple.product-type.kernel-extension";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		81F91BB1156D9BF8007DD788 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				LastUpgradeCheck = 0710;
			};
			buildConfigurationList = 81F91BB4156D9BF8007DD788 /* Build configuration list for PBXProject "PcmMsr" */;
			compatibilityVersion = "Xcode 3.2";
			developmentRegion = English;
			hasScannedForEncodings = 0;
			knownRegions = (
				English,
				en,
			);
			mainGroup = 81F91BAF156D9BF8007DD788;
			productRefGroup = 81F91BBD156D9BF8007DD788 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				81F91BBB156D9BF8007DD788 /* PcmMsrDriver */,
				81ADBF11156EEB93006D9B47 /* PcmMsrLibrary */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		81F91BB9156D9BF8007DD788 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				81F91BC6156D9BF8007DD788 /* InfoPlist.strings in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXRezBuildPhase section */
		81F91BBA156D9BF8007DD788 /* Rez */ = {
			isa = PBXRezBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXRezBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		81ADBF0E156EEB93006D9B47 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				81DEAF6315703531005E8EC6 /* MSRAccessor.cpp in Sources */,
				81DEAF6615703946005E8EC6 /* DriverInterface.c in Sources */,
				895805FC1760E6E5006ED117 /* PCIDriverInterface.cpp in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		81F91BB6156D9BF8007DD788 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				81F91BC9156D9BF8007DD788 /* PcmMsr.cpp in Sources */,
				81ADBF0A156EBD73006D9B47 /* PcmMsrClient.cpp in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXVariantGroup section */
		81F91BC4156D9BF8007DD788 /* InfoPlist.strings */ = {
			isa = PBXVariantGroup;
			children = (
				81F91BC5156D9BF8007DD788 /* en */,
			);
			name = InfoPlist.strings;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		81ADBF14156EEB93006D9B47 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CLANG_ENABLE_OBJC_ARC = YES;
				COMBINE_HIDPI_IMAGES = YES;
				DEBUG_INFORMATION_FORMAT = dwarf;
				DEPLOYMENT_LOCATION = NO;
				EXECUTABLE_PREFIX = lib;
				GCC_VERSION = com.apple.compilers.llvm.clang.1_0;
				INSTALL_PATH = /usr/lib;
				PRODUCT_NAME = PcmMsr;
			};
			name = Debug;
		};
		81ADBF15156EEB93006D9B47 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CLANG_ENABLE_OBJC_ARC = YES;
				COMBINE_HIDPI_IMAGES = YES;
				DEBUG_INFORMATION_FORMAT = dwarf;
				DEPLOYMENT_LOCATION = NO;
				EXECUTABLE_PREFIX = lib;
				GCC_VERSION = com.apple.compilers.llvm.clang.1_0;
				INSTALL_PATH = /usr/lib;
				PRODUCT_NAME = PcmMsr;
			};
			name = Release;
		};
		81F91BCB156D9BF8007DD788 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
				GCC_VERSION = com.apple.compilers.llvm.clang.1_0;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 13.0;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = macosx;
			};
			name = Debug;
		};
		81F91BCC156D9BF8007DD788 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_ENABLE_OBJC_EXCEPTIONS = YES;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_VERSION = com.apple.compilers.llvm.clang.1_0;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 13.0;
				SDKROOT = macosx;
			};
			name = Release;
		};
		81F91BCE156D9BF8007DD788 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				COMBINE_HIDPI_IMAGES = YES;
				CURRENT_PROJECT_VERSION = 1.0.0d1;
				GCC_PRECOMPILE_PREFIX_HEADER = YES;
				GCC_PREFIX_HEADER = "PcmMsr/PcmMsr-Prefix.pch";
				GCC_VERSION = com.apple.compilers.llvm.clang.1_0;
				INFOPLIST_FILE = "PcmMsr/PcmMsr-Info.plist";
				MODULE_NAME = com.intel.driver.PcmMsrDriver;
				MODULE_VERSION = 1.0.0d1;
				ONLY_ACTIVE_ARCH = YES;
				PRODUCT_BUNDLE_IDENTIFIER = com.intel.driver.PcmMsr;
				PRODUCT_NAME = PcmMsrDriver;
				SDKROOT = macosx;
				VALID_ARCHS = x86_64;
				WRAPPER_EXTENSION = kext;
			};
			name = Debug;
		};
		81F91BCF156D9BF8007DD788 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				COMBINE_HIDPI_IMAGES = YES;
				CURRENT_PROJECT_VERSION = 1.0.0d1;
				GCC_PRECOMPILE_PREFIX_HEADER = YES;
				GCC_PREFIX_HEADER = "PcmMsr/PcmMsr-Prefix.pch";
				GCC_VERSION = com.apple.compilers.llvm.clang.1_0;
				INFOPLIST_FILE = "PcmMsr/PcmMsr-Info.plist";
				MODULE_NAME = com.intel.driver.PcmMsrDriver;
				MODULE_VERSION = 1.0.0d1;
				ONLY_ACTIVE_ARCH = YES;
				PRODUCT_BUNDLE_IDENTIFIER = com.intel.driver.PcmMsr;
				PRODUCT_NAME = PcmMsrDriver;
				SDKROOT = macosx;
				VALID_ARCHS = x86_64;
				WRAPPER_EXTENSION = kext;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		81ADBF13156EEB93006D9B47 /* Build configuration list for PBXNativeTarget "PcmMsrLibrary" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				81ADBF14156EEB93006D9B47 /* Debug */,
				81ADBF15156EEB93006D9B47 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		81F91BB4156D9BF8007DD788 /* Build configuration list for PBXProject "PcmMsr" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				81F91BCB156D9BF8007DD788 /* Debug */,
				81F91BCC156D9BF8007DD788 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		81F91BCD156D9BF8007DD788 /* Build configuration list for PBXNativeTarget "PcmMsrDriver" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				81F91BCE156D9BF8007DD788 /* Debug */,
				81F91BCF156D9BF8007DD788 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 81F91BB1156D9BF8007DD788 /* Project object */;
}

```

`src/MacMSRDriver/PcmMsr.xcodeproj/project.xcworkspace/contents.xcworkspacedata`:

```xcworkspacedata
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:PcmMsr.xcodeproj">
   </FileRef>
</Workspace>

```

`src/MacMSRDriver/PcmMsr.xcodeproj/xcuserdata/aiott.xcuserdatad/xcdebugger/Breakpoints.xcbkptlist`:

```xcbkptlist
<?xml version="1.0" encoding="UTF-8"?>
<Bucket
   type = "1"
   version = "1.0">
   <FileBreakpoints>
      <FileBreakpoint
         shouldBeEnabled = "Yes"
         ignoreCount = "0"
         continueAfterRunningActions = "No"
         filePath = "PcmMsr/PcmMsr.cpp"
         timestampString = "359509983.513871"
         startingColumnNumber = "9223372036854775807"
         endingColumnNumber = "9223372036854775807"
         startingLineNumber = "25"
         endingLineNumber = "25">
      </FileBreakpoint>
      <FileBreakpoint
         shouldBeEnabled = "Yes"
         ignoreCount = "0"
         continueAfterRunningActions = "No"
         filePath = "PcmMsr/PcmMsr.cpp"
         timestampString = "359509991.093247"
         startingColumnNumber = "9223372036854775807"
         endingColumnNumber = "9223372036854775807"
         startingLineNumber = "6"
         endingLineNumber = "6">
      </FileBreakpoint>
      <FileBreakpoint
         shouldBeEnabled = "Yes"
         ignoreCount = "0"
         continueAfterRunningActions = "No"
         filePath = "PcmMsr/PcmMsrClient.cpp"
         timestampString = "359587213.546903"
         startingColumnNumber = "9223372036854775807"
         endingColumnNumber = "9223372036854775807"
         startingLineNumber = "10"
         endingLineNumber = "10">
      </FileBreakpoint>
      <FileBreakpoint
         shouldBeEnabled = "No"
         ignoreCount = "0"
         continueAfterRunningActions = "No"
         filePath = "PcmMsr/PcmMsrClient.cpp"
         timestampString = "360889469.00617"
         startingColumnNumber = "9223372036854775807"
         endingColumnNumber = "9223372036854775807"
         startingLineNumber = "224"
         endingLineNumber = "224"
         landmarkName = "PcmMsrClientClassName::writeMSR(pcm_msr_data_t* data)"
         landmarkType = "5">
      </FileBreakpoint>
      <FileBreakpoint
         shouldBeEnabled = "Yes"
         ignoreCount = "0"
         continueAfterRunningActions = "No"
         filePath = "MSRAccessor.cpp"
         timestampString = "363042538.281266"
         startingColumnNumber = "9223372036854775807"
         endingColumnNumber = "9223372036854775807"
         startingLineNumber = "79"
         endingLineNumber = "79"
         landmarkName = "MSRAccessor::decrementNumInstances()"
         landmarkType = "5">
      </FileBreakpoint>
      <FileBreakpoint
         shouldBeEnabled = "No"
         ignoreCount = "0"
         continueAfterRunningActions = "No"
         filePath = "PcmMsr/PcmMsr.cpp"
         timestampString = "364153730.26105"
         startingColumnNumber = "9223372036854775807"
         endingColumnNumber = "9223372036854775807"
         startingLineNumber = "83"
         endingLineNumber = "83"
         landmarkName = "PcmMsrDriverClassName::start(IOService* provider)"
         landmarkType = "5">
      </FileBreakpoint>
      <FileBreakpoint
         shouldBeEnabled = "Yes"
         ignoreCount = "0"
         continueAfterRunningActions = "No"
         filePath = "PcmMsr/PcmMsr.cpp"
         timestampString = "364156579.781308"
         startingColumnNumber = "9223372036854775807"
         endingColumnNumber = "9223372036854775807"
         startingLineNumber = "88"
         endingLineNumber = "88"
         landmarkName = "PcmMsrDriverClassName::getNumCores()"
         landmarkType = "5">
      </FileBreakpoint>
      <FileBreakpoint
         shouldBeEnabled = "Yes"
         ignoreCount = "0"
         continueAfterRunningActions = "No"
         filePath = "PcmMsr/PcmMsr.cpp"
         timestampString = "364161339.052675"
         startingColumnNumber = "9223372036854775807"
         endingColumnNumber = "9223372036854775807"
         startingLineNumber = "97"
         endingLineNumber = "97"
         landmarkName = "PcmMsrDriverClassName::getNumCores()"
         landmarkType = "5">
      </FileBreakpoint>
   </FileBreakpoints>
</Bucket>

```

`src/MacMSRDriver/PcmMsr.xcodeproj/xcuserdata/aiott.xcuserdatad/xcschemes/PcmMsr.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "81F91BBB156D9BF8007DD788"
               BuildableName = "PcmMsrDriver.kext"
               BlueprintName = "PcmMsrDriver"
               ReferencedContainer = "container:PcmMsr.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      buildConfiguration = "Debug">
      <Testables>
      </Testables>
   </TestAction>
   <LaunchAction
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      buildConfiguration = "Release"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      allowLocationSimulation = "YES">
      <AdditionalOptions>
      </AdditionalOptions>
   </LaunchAction>
   <ProfileAction
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      buildConfiguration = "Release"
      debugDocumentVersioning = "YES">
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`src/MacMSRDriver/PcmMsr.xcodeproj/xcuserdata/aiott.xcuserdatad/xcschemes/PcmMsrLibrary.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "81ADBF11156EEB93006D9B47"
               BuildableName = "libPcmMsr.dylib"
               BlueprintName = "PcmMsrLibrary"
               ReferencedContainer = "container:PcmMsr.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      buildConfiguration = "Debug">
      <Testables>
      </Testables>
   </TestAction>
   <LaunchAction
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      buildConfiguration = "Release"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      allowLocationSimulation = "YES">
      <AdditionalOptions>
      </AdditionalOptions>
   </LaunchAction>
   <ProfileAction
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      buildConfiguration = "Release"
      debugDocumentVersioning = "YES">
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`src/MacMSRDriver/PcmMsr.xcodeproj/xcuserdata/aiott.xcuserdatad/xcschemes/xcschememanagement.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>PcmMsr.xcscheme</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
		<key>PcmMsrLibrary.xcscheme</key>
		<dict>
			<key>orderHint</key>
			<integer>1</integer>
		</dict>
	</dict>
	<key>SuppressBuildableAutocreation</key>
	<dict>
		<key>81ADBF11156EEB93006D9B47</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>81DEAF55157008B7005E8EC6</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>81F91BBB156D9BF8007DD788</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
	</dict>
</dict>
</plist>

```

`src/MacMSRDriver/PcmMsr.xcodeproj/xcuserdata/pjkerly.xcuserdatad/xcschemes/PcmMsrDriver.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "0710"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "81F91BBB156D9BF8007DD788"
               BuildableName = "PcmMsrDriver.kext"
               BlueprintName = "PcmMsrDriver"
               ReferencedContainer = "container:PcmMsr.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <Testables>
      </Testables>
      <AdditionalOptions>
      </AdditionalOptions>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "81F91BBB156D9BF8007DD788"
            BuildableName = "PcmMsrDriver.kext"
            BlueprintName = "PcmMsrDriver"
            ReferencedContainer = "container:PcmMsr.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <AdditionalOptions>
      </AdditionalOptions>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "81F91BBB156D9BF8007DD788"
            BuildableName = "PcmMsrDriver.kext"
            BlueprintName = "PcmMsrDriver"
            ReferencedContainer = "container:PcmMsr.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`src/MacMSRDriver/PcmMsr.xcodeproj/xcuserdata/pjkerly.xcuserdatad/xcschemes/PcmMsrLibrary.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "0710"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "81ADBF11156EEB93006D9B47"
               BuildableName = "libPcmMsr.dylib"
               BlueprintName = "PcmMsrLibrary"
               ReferencedContainer = "container:PcmMsr.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <Testables>
      </Testables>
      <AdditionalOptions>
      </AdditionalOptions>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "81ADBF11156EEB93006D9B47"
            BuildableName = "libPcmMsr.dylib"
            BlueprintName = "PcmMsrLibrary"
            ReferencedContainer = "container:PcmMsr.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <AdditionalOptions>
      </AdditionalOptions>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "81ADBF11156EEB93006D9B47"
            BuildableName = "libPcmMsr.dylib"
            BlueprintName = "PcmMsrLibrary"
            ReferencedContainer = "container:PcmMsr.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`src/MacMSRDriver/PcmMsr.xcodeproj/xcuserdata/pjkerly.xcuserdatad/xcschemes/xcschememanagement.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>PcmMsrDriver.xcscheme</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
		<key>PcmMsrLibrary.xcscheme</key>
		<dict>
			<key>orderHint</key>
			<integer>1</integer>
		</dict>
	</dict>
	<key>SuppressBuildableAutocreation</key>
	<dict>
		<key>81ADBF11156EEB93006D9B47</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>81F91BBB156D9BF8007DD788</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
	</dict>
</dict>
</plist>

```

`src/MacMSRDriver/PcmMsr/CMakeLists.txt`:

```txt
message(STATUS ${IOKIT_LIBRARY})

add_executable(
        PcmMsrDriver
        MACOSX_BUNDLE
        PcmMsr.cpp
        PcmMsrClient.cpp
        PcmMsrDriver_info.c
        PcmMsr-Info.plist
)

set_target_properties(PcmMsrDriver PROPERTIES BUNDLE_EXTENSION kext MACOSX_BUNDLE_INFO_PLIST ${CMAKE_CURRENT_SOURCE_DIR}/PcmMsr-Info.plist)

# For KEXT compilation on macOS, we must explicitly point to the Kernel frameworks within the SDK.
if(APPLE)
    # Find the active macOS SDK path
    execute_process(
        COMMAND xcrun --sdk macosx --show-sdk-path
        OUTPUT_VARIABLE MACOSX_SDK_PATH
        OUTPUT_STRIP_TRAILING_WHITESPACE
        RESULT_VARIABLE XCRUN_RESULT
    )
    if(NOT XCRUN_RESULT EQUAL 0 OR NOT MACOSX_SDK_PATH)
        message(FATAL_ERROR "Failed to find macOS SDK path using xcrun")
    endif()
    message(STATUS "Using SDK for KEXT: ${MACOSX_SDK_PATH}")
endif()

target_include_directories(PcmMsrDriver PRIVATE
        "${MACOSX_SDK_PATH}/System/Library/Frameworks/Kernel.framework/PrivateHeaders"
        "${MACOSX_SDK_PATH}/System/Library/Frameworks/Kernel.framework/Headers"
)
target_compile_definitions(PcmMsrDriver PRIVATE
        -DKERNEL
        -DKERNEL_PRIVATE
        -DDRIVER_PRIVATE
        -DAPPLE
        -DNeXT
)

target_compile_options(PcmMsrDriver PRIVATE
        "-ffreestanding"
        "$<$<COMPILE_LANGUAGE:CXX>:-fapple-kext>"
)

target_link_libraries(PcmMsrDriver PRIVATE
        "-lkmodc++"
        "-lkmod"
        "-lcc_kext"
        "-nostdlib"
        "-Xlinker -export_dynamic"
        "-Xlinker -kext"
)

# PcmMsrDriver.kext is built here and located in 'build/bin'
set(LIB_EXT_PATH "/Library/Extensions")
install(TARGETS PcmMsrDriver DESTINATION "${LIB_EXT_PATH}/")
install(CODE "execute_process(COMMAND kmutil load -b com.intel.driver.PcmMsr)")

```

`src/MacMSRDriver/PcmMsr/PcmMsr-Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>PcmMsrDriver</string>
	<key>CFBundleIdentifier</key>
	<string>com.intel.driver.PcmMsr</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>PcmMsrDriver</string>
	<key>CFBundlePackageType</key>
	<string>KEXT</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>IOKitPersonalities</key>
	<dict>
		<key>PcmMsrClient</key>
		<dict>
			<key>CFBundleIdentifier</key>
			<string>com.intel.driver.PcmMsr</string>
			<key>IOClass</key>
			<string>com_intel_driver_PcmMsr</string>
			<key>IOMatchCategory</key>
			<string>com_intel_driver_PcmMsr</string>
			<key>IOProbeScore</key>
			<integer>1000</integer>
			<key>IOProviderClass</key>
			<string>IOResources</string>
			<key>IOResourceMatch</key>
			<string>IOKit</string>
			<key>IOUserClientClass</key>
			<string>com_intel_driver_PcmMsrClient</string>
		</dict>
	</dict>
	<key>OSBundleLibraries</key>
	<dict>
		<key>com.apple.kpi.bsd</key>
		<string>10.9</string>
		<key>com.apple.kpi.mach</key>
		<string>10.9</string>
		<key>com.apple.kpi.unsupported</key>
		<string>10.9</string>
		<key>com.apple.kpi.iokit</key>
		<string>10.9</string>
		<key>com.apple.kpi.libkern</key>
		<string>10.9</string>
	</dict>
</dict>
</plist>

```

`src/MacMSRDriver/PcmMsr/PcmMsr-Prefix.pch`:

```pch
//
// Prefix header for all source files of the 'PcmMsr' target in the 'PcmMsr' project
//


```

`src/MacMSRDriver/PcmMsr/PcmMsr.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2012, Intel Corporation
// written by Austen Ott
//
#include <IOKit/IOLib.h>
#include <libkern/sysctl.h>
#include "PcmMsr.h"

PcmMsrDriverClassName *g_pci_driver = NULL;

#define wrmsr(msr,lo,hi) \
asm volatile ("wrmsr" : : "c" (msr), "a" (lo), "d" (hi))
#define rdmsr(msr,lo,hi) \
asm volatile ("\trdmsr\n" : "=a" (lo), "=d" (hi) : "c" (msr))

extern "C" {
    extern void mp_rendezvous_no_intrs(void (*func)(void *),
                                       void *arg);
    extern int cpu_number(void);
}

inline uint64_t RDMSR(uint32_t msr)
{
    uint64_t value;
	uint32_t low, hi;
	rdmsr(msr, low, hi);
	value = ((uint64_t) hi << 32) | low;
	return value;
}

inline void WRMSR(uint32_t msr, uint64_t value)
{
    uint32_t low, hi;
    low = (uint32_t)value;
    hi = (uint32_t) (value >> 32);
    wrmsr(msr, low, hi);
}

void cpuReadMSR(void* pIData){
    pcm_msr_data_t* data = (pcm_msr_data_t*)pIData;
    int cpu = cpu_number();
    if(data->cpu_num == cpu)
    {
        data->value = RDMSR(data->msr_num);
    }
}

void cpuWriteMSR(void* pIDatas){
    pcm_msr_data_t* idatas = (pcm_msr_data_t*)pIDatas;
    int cpu = cpu_number();
    if(idatas->cpu_num == cpu)
    {
        WRMSR(idatas->msr_num, idatas->value);
    }
}

void cpuGetTopoData(void* pTopos){
    TopologyEntry* entries = (TopologyEntry*)pTopos;
    const int cpu = cpu_number();

    TopologyEntry & entry = entries[cpu];
    entry.os_id = cpu;

    uint32 smtMaskWidth = 0;
    uint32 coreMaskWidth = 0;
    uint32 l2CacheMaskShift = 0;
    uint32 l3CacheMaskShift = 0;
    initCoreMasks(smtMaskWidth, coreMaskWidth, l2CacheMaskShift, l3CacheMaskShift);
    PCM_CPUID_INFO cpuid_args;
    pcm_cpuid(0xb, 0x0, cpuid_args);
    const auto apic_id = cpuid_args.array[3];
    fillEntry(entry, smtMaskWidth, coreMaskWidth, l2CacheMaskShift, apic_id);
    entry.l3_cache_id = extract_bits_32(apic_id, l3CacheMaskShift, 31);
}

OSDefineMetaClassAndStructors(com_intel_driver_PcmMsr, IOService)

#define super IOService

bool PcmMsrDriverClassName::start(IOService* provider){
    bool	success;
    success = super::start(provider);

	if (!g_pci_driver) {
		g_pci_driver = this;
	}

	if (success) {
		registerService();
	}

    return success;
}

int32_t PcmMsrDriverClassName::getNumCores()
{
    int32_t ncpus = 0;
    size_t ncpus_size = sizeof(ncpus);
    if(sysctlbyname("hw.logicalcpu", &ncpus, &ncpus_size, NULL, 0))
    {
         IOLog("%s[%p]::%s() -- sysctl failure retrieving hw.logicalcpu",
               getName(), this, __FUNCTION__);
         ncpus = 0;
    }

    return ncpus;
}

bool PcmMsrDriverClassName::init(OSDictionary *dict)
{
    bool result = super::init(dict);

    if (result) {
         num_cores = getNumCores();
    }

    return result && num_cores;
}

void PcmMsrDriverClassName::free()
{
    super::free();
}

// We override handleOpen, handleIsOpen, and handleClose to allow multiple clients to access the driver
// simultaneously. We always return true for these because we don't care who is accessing and we
// don't know how many people will be accessing it.
bool PcmMsrDriverClassName::handleOpen(IOService * forClient, IOOptionBits opts, void* args){
    return true;
}

bool PcmMsrDriverClassName::handleIsOpen(const IOService* forClient) const{
    return true;
}

void PcmMsrDriverClassName::handleClose(IOService* forClient, IOOptionBits opts){
}

IOReturn PcmMsrDriverClassName::readMSR(pcm_msr_data_t* idatas,pcm_msr_data_t* odatas){
    // All the msr_nums should be the same, so we just use the first one to pass to all cores
    IOReturn ret = kIOReturnBadArgument;
    if(idatas->cpu_num < num_cores)
    {
        mp_rendezvous_no_intrs(cpuReadMSR, (void*)idatas);

        odatas->cpu_num = idatas->cpu_num;
        odatas->msr_num = idatas->msr_num;
        odatas->value = idatas->value;
        ret = kIOReturnSuccess;
    }
    else
    {
        IOLog("Tried to read from a core with id higher than max core id.\n");
    }
    return ret;
}

IOReturn PcmMsrDriverClassName::writeMSR(pcm_msr_data_t* idata){
    IOReturn ret = kIOReturnBadArgument;
    if(idata->cpu_num < num_cores)
    {
        mp_rendezvous_no_intrs(cpuWriteMSR, (void*)idata);

        ret = kIOReturnSuccess;
    }
    else
    {
        IOLog("Tried to write to a core with id higher than max core id.\n");
    }

    return ret;
}

IOReturn PcmMsrDriverClassName::buildTopology(TopologyEntry* odata, uint32_t input_num_cores)
{
     size_t topologyBufferSize;

     // TODO figure out when input_num_cores is used rather than num_cores
     if (os_mul_overflow(sizeof(TopologyEntry), (size_t) num_cores, &topologyBufferSize))
     {
          return kIOReturnBadArgument;
     }

    TopologyEntry *topologies =
         (TopologyEntry *)IOMallocAligned(topologyBufferSize, 32);

    if (topologies == nullptr)
    {
        return kIOReturnNoMemory;
    }

    mp_rendezvous_no_intrs(cpuGetTopoData, (void*)topologies);

    for(uint32_t i = 0; i < num_cores && i < input_num_cores; i++)
    {
        odata[i].os_id = topologies[i].os_id;
        odata[i].thread_id = topologies[i].thread_id;
        odata[i].core_id = topologies[i].core_id;
        odata[i].tile_id = topologies[i].tile_id;
        odata[i].socket_id = topologies[i].socket_id;
    }

    IOFreeAligned(topologies, topologyBufferSize);
    return kIOReturnSuccess;
}

IOReturn PcmMsrDriverClassName::getNumInstances(uint32_t* num_insts){
    *num_insts = num_clients;
    return kIOReturnSuccess;
}

IOReturn PcmMsrDriverClassName::incrementNumInstances(uint32_t* num_insts){
    *num_insts = ++num_clients;
    return kIOReturnSuccess;
}

IOReturn PcmMsrDriverClassName::decrementNumInstances(uint32_t* num_insts){
    *num_insts = --num_clients;
    return kIOReturnSuccess;
}

// read
uint32_t PcmMsrDriverClassName::read(uint32_t pci_address)
{
    uint32_t value = 0;

    __asm__("\t"
			"movw $0xCF8,%%dx\n\t"
			"andb $0xFC,%%al\n\t"
			"outl %%eax,%%dx\n\t"
			"movl $0xCFC,%%edx\n\t"
			"in   %%dx,%%eax\n"
			: "=a"(value)
			: "a"(pci_address)
			: "%edx");

    return value;
}


// write
void PcmMsrDriverClassName::write(uint32_t pci_address, uint32_t value)
{

	__asm__("\t"
			"movw $0xCF8,%%dx\n\t"
			"andb $0xFC,%%al\n\t"
			"outl %%eax,%%dx\n\t"
			"movl $0xCFC,%%edx\n\t"
			"movl %%ebx,%%eax\n\t"
			"outl %%eax,%%dx\n"
			:
			: "a"(pci_address), "b"(value)
			: "%edx");
}


// mapMemory
void* PcmMsrDriverClassName::mapMemory (uint32_t address, UInt8 **virtual_address)
{
	PRINT_DEBUG("%s[%p]::%s()\n", getName(), this, __FUNCTION__);

    IOMemoryMap        *memory_map        = NULL;
    IOMemoryDescriptor *memory_descriptor = NULL;
	#ifndef __clang_analyzer__ // address a false-positive
    memory_descriptor = IOMemoryDescriptor::withPhysicalAddress(address,
                                                                4096,
                                                                kIODirectionInOut);
    #endif
    if (memory_descriptor) {
        IOReturn ioErr = memory_descriptor->prepare(kIODirectionInOut);
        if (ioErr == kIOReturnSuccess) {
            memory_map = memory_descriptor->map();
            if (memory_map) {
                if (virtual_address) {
                    *virtual_address = (UInt8*)memory_map->getVirtualAddress();
                } else {
					IOLog("%s[%p]::%s() -- virtual_address is null\n", getName(), this, __FUNCTION__);
				}
            } else {
				IOLog("%s[%p]::%s() -- IOMemoryDescriptor::map() failure\n", getName(), this, __FUNCTION__);
			}
        }
        else {
			IOLog("%s[%p]::%s() -- IOMemoryDescriptor::prepare() failure\n", getName(), this, __FUNCTION__);
        }
        if (!memory_map)
        {
            memory_descriptor->release();
        }
    } else {
		IOLog("%s[%p]::%s() -- IOMemoryDescriptor::withPhysicalAddress() failure\n", getName(), this, __FUNCTION__);
	}

    return (void*)memory_map;
}


// unmapMemory
void PcmMsrDriverClassName::unmapMemory (void *memory_map)
{
	PRINT_DEBUG("%s[%p]::%s()\n", getName(), this, __FUNCTION__);

    IOMemoryMap *m_map = (IOMemoryMap*)memory_map;

    if (m_map) {
        m_map->getMemoryDescriptor()->complete();
        #ifndef __clang_analyzer__ // address a false-positive
        m_map->getMemoryDescriptor()->release();
        #endif
        m_map->unmap();
        m_map->release();
    }

    return;
}

```

`src/MacMSRDriver/PcmMsr/PcmMsr.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2012, Intel Corporation
// written by Austen Ott
//    
#include <IOKit/IOService.h>
#include "UserKernelShared.h"

class PcmMsrDriverClassName : public IOService
{
    OSDeclareDefaultStructors(com_intel_driver_PcmMsr)
public:
    // IOService methods
    virtual bool start(IOService* provider) override;
    
    virtual IOReturn writeMSR(pcm_msr_data_t* data);
    virtual IOReturn readMSR(pcm_msr_data_t* idata,pcm_msr_data_t* odata);
    virtual IOReturn buildTopology(TopologyEntry* odata, uint32_t input_num_cores);
    virtual bool init(OSDictionary *dict) override;
    virtual void free(void) override;
    virtual bool handleOpen(IOService* forClient, IOOptionBits opts, void* args) override;
    virtual bool handleIsOpen(const IOService* forClient) const override;
    virtual void handleClose(IOService* forClient, IOOptionBits opts) override;
    
    virtual int32_t getNumCores();
    
    virtual IOReturn incrementNumInstances(uint32_t* num_instances);
    virtual IOReturn decrementNumInstances(uint32_t* num_instances);
    virtual IOReturn getNumInstances(uint32_t* num_instances);
	
	// PCI classes
	static uint32_t read(uint32_t pci_address);
	static void write(uint32_t pci_address, uint32_t value);
    void* mapMemory(uint32_t address, UInt8 **virtual_address);
    void unmapMemory(void* memory_map);
	
private:
    // number of providers currently using the driver
    uint32_t num_clients = 0;
    int32_t num_cores;
};

#ifdef DEBUG
#define _DEBUG 1
#else
#define _DEBUG 0
#endif
#define PRINT_DEBUG if (_DEBUG) IOLog

```

`src/MacMSRDriver/PcmMsr/PcmMsrClient.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2012, Intel Corporation
// written by Austen Ott
//    
#include <IOKit/IOLib.h>
#include <IOKit/IOKitKeys.h>
#include <libkern/OSByteOrder.h>
#include "PcmMsrClient.h"

#define super IOUserClient

OSDefineMetaClassAndStructors(com_intel_driver_PcmMsrClient, IOUserClient)

const IOExternalMethodDispatch PcmMsrClientClassName::sMethods[kNumberOfMethods] = {
    { (IOExternalMethodAction) &PcmMsrClientClassName::sOpenDriver, 0, 0, 0, 0},
    { (IOExternalMethodAction) &PcmMsrClientClassName::sCloseDriver, 0, 0, 0, 0},
    { (IOExternalMethodAction) &PcmMsrClientClassName::sReadMSR, 0, kIOUCVariableStructureSize, 0, kIOUCVariableStructureSize},
    { (IOExternalMethodAction) &PcmMsrClientClassName::sWriteMSR, 0, kIOUCVariableStructureSize, 0, 0},
    { (IOExternalMethodAction) &PcmMsrClientClassName::sBuildTopology, 0, 0, 0, kIOUCVariableStructureSize},
    { (IOExternalMethodAction) &PcmMsrClientClassName::sGetNumInstances, 0, 0, 1, 0},
    { (IOExternalMethodAction) &PcmMsrClientClassName::sIncrementNumInstances, 0, 0, 1, 0},
    { (IOExternalMethodAction) &PcmMsrClientClassName::sDecrementNumInstances, 0, 0, 1, 0},
	{ (IOExternalMethodAction) &PcmMsrClientClassName::sRead, 1, 0, 1, 0 },
	{ (IOExternalMethodAction) &PcmMsrClientClassName::sWrite, 2, 0, 0, 0 },
	{ (IOExternalMethodAction) &PcmMsrClientClassName::sMapMemory, 1, 0, 2, 0 },
	{ (IOExternalMethodAction) &PcmMsrClientClassName::sUnmapMemory, 1, 0, 0, 0 },
	{ (IOExternalMethodAction) &PcmMsrClientClassName::sReadMemory, 1, 0, 1, 0 }

};

IOReturn PcmMsrClientClassName::externalMethod(uint32_t selector, IOExternalMethodArguments* args,													IOExternalMethodDispatch* dispatch, OSObject* target, void* reference)
{
    if (selector < (uint32_t) kNumberOfMethods) {
        dispatch = (IOExternalMethodDispatch *) &sMethods[selector];
        
        if (!target) {
			target = this;
		}
    }
	
	return super::externalMethod(selector, args, dispatch, target, reference);
}

bool PcmMsrClientClassName::initWithTask(task_t owningTask, void *securityToken, UInt32 type, OSDictionary *properties)
{
    if(!IOUserClient::initWithTask(owningTask, securityToken, type, properties)) {
        return false;
    }
    
    sSecurityToken = securityToken;
    return true;
}

bool PcmMsrClientClassName::start(IOService* provider)
{
	bool result = false;

    if(clientHasPrivilege(sSecurityToken, kIOClientPrivilegeAdministrator) != kIOReturnSuccess) 
		return false;
		
    fProvider = OSDynamicCast(PcmMsrDriverClassName, provider);
    
    if (fProvider != NULL) {
		result = super::start(provider);
	}
    else
 		IOLog("PcmMsrClientClassName::start failed.\n");
        
    return result;
}

IOReturn PcmMsrClientClassName::clientClose(void)
{    
    closeUserClient();
    
	if (!terminate()) {
		IOLog("PcmMsrClientClassName::clientClose failed.\n");
	}
	
    return kIOReturnSuccess;
}

bool PcmMsrClientClassName::didTerminate(IOService* provider, IOOptionBits options, bool* defer)
{	
	closeUserClient();
	*defer = false;
	
	return super::didTerminate(provider, options, defer);
}


IOReturn PcmMsrClientClassName::sOpenDriver(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments)
{
    return target->openUserClient();
}

IOReturn PcmMsrClientClassName::openUserClient(void)
{
    IOReturn	result = kIOReturnSuccess;
    
    if (fProvider == NULL || isInactive()) {
        result = kIOReturnNotAttached;
		IOLog("%s::%s returned kIOReturnNotAttached.\n", getName(), __FUNCTION__);
	} else if (!fProvider->open(this)) {
		result = kIOReturnExclusiveAccess;
		IOLog("%s::%s returned kIOReturnExclusiveAccess.\n", getName(), __FUNCTION__);
	}
	
    return result;
}

IOReturn PcmMsrClientClassName::checkActiveAndOpened (const char* memberFunction)
{
    if (fProvider == NULL || isInactive()) {
        IOLog("%s::%s returned kIOReturnNotAttached.\n", getName(), memberFunction);
        return (IOReturn)kIOReturnNotAttached;
        
    } else if (!fProvider->isOpen(this)) {
        IOLog("%s::%s returned kIOReturnNotOpen.\n", getName(), memberFunction);
        return  (IOReturn)kIOReturnNotOpen;
    }
    return kIOReturnSuccess;
}


IOReturn PcmMsrClientClassName::sCloseDriver(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments)
{
    return target->closeUserClient();
}

IOReturn PcmMsrClientClassName::closeUserClient(void)
{
    IOReturn	result = checkActiveAndOpened (__FUNCTION__);
    
    if (result == kIOReturnSuccess)
 		fProvider->close(this);

    return result;
}

IOReturn PcmMsrClientClassName::sReadMSR(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments){
    return target->readMSR((pcm_msr_data_t*) arguments->structureInput, (pcm_msr_data_t*) arguments->structureOutput);
}

IOReturn PcmMsrClientClassName::readMSR(pcm_msr_data_t* idata, pcm_msr_data_t* odata)
{
    IOReturn	result = checkActiveAndOpened (__FUNCTION__);
    
    if (result == kIOReturnSuccess)
 		result = fProvider->readMSR(idata, odata);
    
    return result;
}

IOReturn PcmMsrClientClassName::sWriteMSR(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments){
    return target -> writeMSR((pcm_msr_data_t*)arguments->structureInput);
}

IOReturn PcmMsrClientClassName::writeMSR(pcm_msr_data_t* data)
{
    IOReturn	result = checkActiveAndOpened (__FUNCTION__);
    
    if (result == kIOReturnSuccess)
		result = fProvider->writeMSR(data);
    
    return result;
}

IOReturn PcmMsrClientClassName::sBuildTopology(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* args){
    return target -> buildTopology((TopologyEntry*)args->structureOutput, args->structureOutputSize);
}

IOReturn PcmMsrClientClassName::buildTopology(TopologyEntry* data, size_t output_size)
{
    uint32_t num_cores = (uint32_t) (output_size / sizeof(TopologyEntry) );
    IOReturn	result = checkActiveAndOpened (__FUNCTION__);
    
    if (result == kIOReturnSuccess)
		result = fProvider->buildTopology(data, num_cores);
    
    return result;
}

IOReturn PcmMsrClientClassName::sGetNumInstances(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* args){
    return target->getNumInstances((uint32_t*)&args->scalarOutput[0]);
}
IOReturn PcmMsrClientClassName::getNumInstances(uint32_t* num_insts){
    return fProvider->getNumInstances(num_insts);
}

IOReturn PcmMsrClientClassName::sIncrementNumInstances(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* args){
    return target->incrementNumInstances((uint32_t*)&args->scalarOutput[0]);
}
IOReturn PcmMsrClientClassName::incrementNumInstances(uint32_t* num_insts){
    return fProvider->incrementNumInstances(num_insts);
}

IOReturn PcmMsrClientClassName::sDecrementNumInstances(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* args){
    return target->decrementNumInstances((uint32_t*)&args->scalarOutput[0]);
}
IOReturn PcmMsrClientClassName::decrementNumInstances(uint32_t* num_insts){
    return fProvider->decrementNumInstances(num_insts);
}



extern PcmMsrDriverClassName* g_pci_driver;

// read32
IOReturn PcmMsrClientClassName::sRead(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments) {
    return target->read(arguments->scalarInput, arguments->scalarInputCount, arguments->scalarOutput, arguments->scalarOutputCount);
}
IOReturn PcmMsrClientClassName::read(const uint64_t* input, uint32_t inputSize, uint64_t* output, uint32_t outputSize)
{
	PRINT_DEBUG("%s[%p]::%s()\n", getName(), this, __FUNCTION__);
	
	if (inputSize != 1) {
		IOLog("%s[%p]::%s(): returning kIOReturnBadArgument.\n", getName(), this, __FUNCTION__);
		return kIOReturnBadArgument;
	}
	
	uint32_t addr = (uint32_t)input[0];
	PRINT_DEBUG("addr: %x\n", addr);
	
	if (g_pci_driver) {
        output[0] = g_pci_driver->read(addr);
    }
	IOLog("val: %llx\n", output[0]);
	
    return kIOReturnSuccess;
}


// write32
IOReturn PcmMsrClientClassName::sWrite(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments) {
    return target->write(arguments->scalarInput, arguments->scalarInputCount);
}
IOReturn PcmMsrClientClassName::write(const uint64_t* input, uint32_t inputSize)
{
	PRINT_DEBUG("%s[%p]::%s()\n", getName(), this, __FUNCTION__);
	
	if (inputSize != 2) {
		IOLog("%s[%p]::%s(): returning kIOReturnBadArgument.\n", getName(), this, __FUNCTION__);
		return kIOReturnBadArgument;
	}
	
	uint32_t addr = (uint32_t)input[0];
	uint32_t val  = (uint32_t)input[1];
	PRINT_DEBUG("addr: %x, val: %x\n", addr, val);
	
	if (g_pci_driver) {
        g_pci_driver->write(addr, val);
    }
	
    return kIOReturnSuccess;
}


// mapMemory
IOReturn PcmMsrClientClassName::sMapMemory(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments) {
    return target->mapMemory(arguments->scalarInput, arguments->scalarInputCount, arguments->scalarOutput, arguments->scalarOutputCount);
}
IOReturn PcmMsrClientClassName::mapMemory(const uint64_t* input, uint32_t inputSize, uint64_t* output, uint32_t outputSize)
{
	PRINT_DEBUG("%s[%p]::%s()\n", getName(), this, __FUNCTION__);
	
	if (inputSize != 1) {
		IOLog("%s[%p]::%s(): returning kIOReturnBadArgument.\n", getName(), this, __FUNCTION__);
		return kIOReturnBadArgument;
	}
	
	uint32_t address = (uint32_t)input[0];
	PRINT_DEBUG("address: %x\n", address);
	
	if (g_pci_driver) {
		uint8_t* virtual_address = NULL;
		void* memory_map = g_pci_driver->mapMemory(address, (uint8_t**)&virtual_address);
		output[0] = (uint64_t)memory_map;
		output[1] = (uint64_t)virtual_address;
		PRINT_DEBUG("memory_map: %p\n", memory_map);
		PRINT_DEBUG("virtual_address: %p\n", virtual_address);
    }
	
    return kIOReturnSuccess;
}


// unmapMemory
IOReturn PcmMsrClientClassName::sUnmapMemory(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments) {
    return target->unmapMemory(arguments->scalarInput, arguments->scalarInputCount);
}
IOReturn PcmMsrClientClassName::unmapMemory(const uint64_t* input, uint32_t inputSize)
{
	PRINT_DEBUG("%s[%p]::%s()\n", getName(), this, __FUNCTION__);
	
	if (inputSize != 1) {
		IOLog("%s[%p]::%s(): returning kIOReturnBadArgument.\n", getName(), this, __FUNCTION__);
		return kIOReturnBadArgument;
	}
	
	void* memory_map = (void*)input[0];
	PRINT_DEBUG("memory_map: %p\n", memory_map);
	
	if (g_pci_driver) {
		g_pci_driver->unmapMemory(memory_map);
    }
	
    return kIOReturnSuccess;
}


// readMemory
IOReturn PcmMsrClientClassName::sReadMemory(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments) {
    return target->readMemory(arguments->scalarInput, arguments->scalarInputCount, arguments->scalarOutput, arguments->scalarOutputCount);
}
IOReturn PcmMsrClientClassName::readMemory(const uint64_t* input, uint32_t inputSize, uint64_t* output, uint32_t outputSize)
{
	PRINT_DEBUG("%s[%p]::%s()\n", getName(), this, __FUNCTION__);
	
	if (inputSize != 1) {
		IOLog("%s[%p]::%s(): returning kIOReturnBadArgument.\n", getName(), this, __FUNCTION__);
		return kIOReturnBadArgument;
	}
	
	uint8_t* address = (uint8_t*)input[0];
	PRINT_DEBUG("address: %p\n", address);
	
	uint32_t val = 0;
	if (g_pci_driver) {
		val = *(uint32_t*)address;
    }
	output[0] = (uint64_t)val;
	PRINT_DEBUG("val: %x\n", val);
	
    return kIOReturnSuccess;
}

```

`src/MacMSRDriver/PcmMsr/PcmMsrClient.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2012, Intel Corporation
// written by Austen Ott
//
#include <IOKit/IOService.h>
#include <IOKit/IOUserClient.h>
#include "PcmMsr.h"

#define PcmMsrClientClassName com_intel_driver_PcmMsrClient

class PcmMsrClientClassName : public IOUserClient
{
    OSDeclareDefaultStructors(com_intel_driver_PcmMsrClient)

protected:
    PcmMsrDriverClassName*                  fProvider;
    void*                                   sSecurityToken;
    static const IOExternalMethodDispatch   sMethods[kNumberOfMethods];

public:
    virtual bool initWithTask(task_t owningTask, void *securityToken, UInt32 type, OSDictionary *properties) override;
    virtual bool start(IOService *provider) override;
    
    virtual IOReturn clientClose(void) override;

    virtual bool didTerminate(IOService* provider, IOOptionBits opts, bool* defer) override;

protected:
    IOReturn checkActiveAndOpened (const char* memberFunction);

    virtual IOReturn externalMethod(uint32_t selector,
                                    IOExternalMethodArguments* arguments,
                                    IOExternalMethodDispatch* dispatch,
                                    OSObject* target, void* reference) override;

    static IOReturn sOpenDriver(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* args);
    virtual IOReturn openUserClient(void);
    
    static  IOReturn sCloseDriver(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* args);
    virtual IOReturn closeUserClient(void);
    
    static IOReturn sReadMSR(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* args);
    virtual IOReturn readMSR(pcm_msr_data_t* idata, pcm_msr_data_t* odata);
    
    static IOReturn sWriteMSR(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* args);
    virtual IOReturn writeMSR(pcm_msr_data_t* data);
    
    static IOReturn sBuildTopology(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* args);
    virtual IOReturn buildTopology(TopologyEntry* data, size_t output_size);
    
    static IOReturn sGetNumInstances(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* args);
    virtual IOReturn getNumInstances(uint32_t* num_insts);
    
    static IOReturn sIncrementNumInstances(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* args);
    virtual IOReturn incrementNumInstances(uint32_t* num_insts);
    
    static IOReturn sDecrementNumInstances(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* args);
    virtual IOReturn decrementNumInstances(uint32_t* num_insts);
	
	// PCI functions
	static IOReturn sRead(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments);
	virtual IOReturn read(const uint64_t* input, uint32_t inputSize, uint64_t* output, uint32_t outputSize);
	
	static IOReturn sWrite(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments);
	virtual IOReturn write(const uint64_t* input, uint32_t inputSize);
	
	static IOReturn sMapMemory(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments);
	virtual IOReturn mapMemory(const uint64_t* input, uint32_t inputSize, uint64_t* output, uint32_t outputSize);
	
	static IOReturn sUnmapMemory(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments);
	virtual IOReturn unmapMemory(const uint64_t* input, uint32_t inputSize);
	
	static IOReturn sReadMemory(PcmMsrClientClassName* target, void* reference, IOExternalMethodArguments* arguments);
	virtual IOReturn readMemory(const uint64_t* input, uint32_t inputSize, uint64_t* output, uint32_t outputSize);
};

```

`src/MacMSRDriver/PcmMsr/PcmMsrDriver_info.c`:

```c
#include <mach/mach_types.h>
 
extern kern_return_t _start(kmod_info_t *ki, void *data);
extern kern_return_t _stop(kmod_info_t *ki, void *data);
 
__attribute__((visibility("default"))) KMOD_EXPLICIT_DECL(com.intel.driver.PcmMsrDriver, "1.0.0d1", _start, _stop)
__private_extern__ kmod_start_func_t *_realmain = 0;
__private_extern__ kmod_stop_func_t *_antimain = 0;
__private_extern__ int _kext_apple_cc = __APPLE_CC__ ;

```

`src/MacMSRDriver/PcmMsr/UserKernelShared.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2012, Intel Corporation
// written by Austen Ott
//
#define PcmMsrDriverClassName com_intel_driver_PcmMsr
#define kPcmMsrDriverClassName "com_intel_driver_PcmMsr"

#ifndef USER_KERNEL_SHARED
#define USER_KERNEL_SHARED

#define PCM_API

// kIOMainPortDefault is not supported before macOS Monterey
#if (MAC_OS_X_VERSION_MAX_ALLOWED < 120000)
    #define kIOMainPortDefault kIOMasterPortDefault
#endif

#include <stdint.h>
#include "../../topologyentry.h"

using namespace pcm;

typedef struct {
    uint64_t value;
    uint32_t cpu_num;
    uint32_t msr_num;
} pcm_msr_data_t;

typedef struct {
    uint64_t value;
    uint32_t msr_num;
    bool mask;
    char padding[115];
} k_pcm_msr_data_t;

enum {
    kOpenDriver,
    kCloseDriver,
    kReadMSR,
    kWriteMSR,
    kBuildTopology,
    kGetNumInstances,
    kIncrementNumInstances,
    kDecrementNumInstances,
    // PCI functions
    kRead,
    kWrite,
    kMapMemory,
    kUnmapMemory,
    kReadMemory,
    kNumberOfMethods
};
#endif

```

`src/MacMSRDriver/PcmMsr/en.lproj/InfoPlist.strings`:

```strings
/* Localized versions of Info.plist keys */


```

`src/MacMSRDriver/kextload.sh`:

```sh
#!/usr/bin/env bash

cp -R ../../build/bin/PcmMsrDriver.kext /Library/Extensions/.
chown -R root:wheel /Library/Extensions/PcmMsrDriver.kext
kextload /Library/Extensions/PcmMsrDriver.kext

```

`src/MacMSRDriver/kextunload.sh`:

```sh
#!/usr/bin/env bash

kextunload /Library/Extensions/PcmMsrDriver.kext
rm -rf /Library/Extensions/PcmMsrDriver.kext

```

`src/PMURegisterDeclarations/GenuineIntel-6-4F-1.json`:

```json
{
    "core" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "User":        {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 1},
            "OS":          {"Config": 0, "Position": 17, "Width": 1, "DefaultValue": 1},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1},
            "PinControl":  {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "APICInt":     {"Config": 0, "Position": 20, "Width": 1, "DefaultValue": 0},
            "AnyThread":   {"Config": 0, "Position": 21, "Width": 1},
            "Enable":      {"Config": 0, "Position": 22, "Width": 1, "DefaultValue": 1},
            "Invert":      {"Config": 0, "Position": 23, "Width": 1},
            "CounterMask": {"Config": 0, "Position": 24, "Width": 8},
            "InTX":        {"Config": 0, "Position": 32, "Width": 1, "DefaultValue": 0},
            "InTXCheckpointed": {"Config": 0, "Position": 33, "Width": 1, "DefaultValue": 0},
            "MSRIndex": {
                "0x1a6" : {"Config": 1, "Position": 0, "Width": 64},
                "0x1a7" : {"Config": 2, "Position": 0, "Width": 64},
                "0x3f6" : {"Config": 3, "Position": 0, "Width": 64},
                "0x3f7" : {"Config": 4, "Position": 0, "Width": 64}
            }
        },
        "fixed0" : {
            "OS":          {"Config": 0, "Position": 0, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 1, "Width": 1, "DefaultValue": 1},
            "AnyThread":   {"Config": 0, "Position": 2, "Width": 1},
            "EnablePMI":   {"Config": 0, "Position": 3, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed1" : {
            "OS":          {"Config": 0, "Position": 4, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 5, "Width": 1, "DefaultValue": 1},
            "AnyThread":   {"Config": 0, "Position": 6, "Width": 1},
            "EnablePMI":   {"Config": 0, "Position": 7, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed2" : {
            "OS":          {"Config": 0, "Position": 8, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 9, "Width": 1, "DefaultValue": 1},
            "AnyThread":   {"Config": 0, "Position": 10, "Width": 1},
            "EnablePMI":   {"Config": 0, "Position": 11, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        }
    },
    "cha" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "TIDEnable":   {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "Filter0":     {"Config": 1, "Position": 0, "Width": 64, "DefaultValue": 0},
            "TID":         {"Config": 1, "Position": 0,  "Width": 6, "DefaultValue": 0},
            "State":       {"Config": 1, "Position": 17, "Width": 7, "DefaultValue": 0},
            "Filter1":     {"Config": 2, "Position": 0, "Width": 64, "DefaultValue": 59},
            "OPC":         {"Config": 2, "Position": 20, "Width": 9, "DefaultValue": 0},
            "NC":          {"Config": 2, "Position": 30, "Width": 1, "DefaultValue": 0},
            "ISOC":        {"Config": 2, "Position": 31, "Width": 1, "DefaultValue": 0}
        }
    },
    "imc" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "ha" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "pcu" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "xpi" : {
        "__comment" :  "this is for UPI LL and QPI LL uncore PMUs",
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "irp" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "ubox" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    }
}

```

`src/PMURegisterDeclarations/GenuineIntel-6-55-4.json`:

```json
{
    "core" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "User":        {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 1},
            "OS":          {"Config": 0, "Position": 17, "Width": 1, "DefaultValue": 1},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1},
            "PinControl":  {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "APICInt":     {"Config": 0, "Position": 20, "Width": 1, "DefaultValue": 0},
            "AnyThread":   {"Config": 0, "Position": 21, "Width": 1},
            "Enable":      {"Config": 0, "Position": 22, "Width": 1, "DefaultValue": 1},
            "Invert":      {"Config": 0, "Position": 23, "Width": 1},
            "CounterMask": {"Config": 0, "Position": 24, "Width": 8},
            "InTX":        {"Config": 0, "Position": 32, "Width": 1, "DefaultValue": 0},
            "InTXCheckpointed": {"Config": 0, "Position": 33, "Width": 1, "DefaultValue": 0},
            "MSRIndex": {
                "0x1a6" : {"Config": 1, "Position": 0, "Width": 64},
                "0x1a7" : {"Config": 2, "Position": 0, "Width": 64},
                "0x3f6" : {"Config": 3, "Position": 0, "Width": 64},
                "0x3f7" : {"Config": 4, "Position": 0, "Width": 64}
            }
        },
        "fixed0" : {
            "OS":          {"Config": 0, "Position": 0, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 1, "Width": 1, "DefaultValue": 1},
            "AnyThread":   {"Config": 0, "Position": 2, "Width": 1},
            "EnablePMI":   {"Config": 0, "Position": 3, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed1" : {
            "OS":          {"Config": 0, "Position": 4, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 5, "Width": 1, "DefaultValue": 1},
            "AnyThread":   {"Config": 0, "Position": 6, "Width": 1},
            "EnablePMI":   {"Config": 0, "Position": 7, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed2" : {
            "OS":          {"Config": 0, "Position": 8, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 9, "Width": 1, "DefaultValue": 1},
            "AnyThread":   {"Config": 0, "Position": 10, "Width": 1},
            "EnablePMI":   {"Config": 0, "Position": 11, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        }
    },
    "cha" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "TIDEnable":   {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "Filter0":     {"Config": 1, "Position": 0, "Width": 64, "DefaultValue": 0},
            "TID":         {"Config": 1, "Position": 0,  "Width": 9, "DefaultValue": 0},
            "Filter1":     {"Config": 2, "Position": 0, "Width": 64, "DefaultValue": 59}
        }
    },
    "imc" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "xpi" : {
        "__comment" :  "this is for UPI LL and QPI LL uncore PMUs",
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "m2m" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "m3upi" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "pcu" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "irp" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "ubox" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "iio" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 12, "DefaultValue": 0},
            "PortMask":    {"Config": 0, "Position": 36, "Width": 8},
            "FCMask":      {"Config": 0, "Position": 44, "Width": 3}
        }
    }
}

```

`src/PMURegisterDeclarations/GenuineIntel-6-6A-0.json`:

```json
{
    "core" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "User":        {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 1},
            "OS":          {"Config": 0, "Position": 17, "Width": 1, "DefaultValue": 1},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1},
            "PinControl":  {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "APICInt":     {"Config": 0, "Position": 20, "Width": 1, "DefaultValue": 0},
            "Enable":      {"Config": 0, "Position": 22, "Width": 1, "DefaultValue": 1},
            "Invert":      {"Config": 0, "Position": 23, "Width": 1},
            "CounterMask": {"Config": 0, "Position": 24, "Width": 8},
            "InTX":        {"Config": 0, "Position": 32, "Width": 1, "DefaultValue": 0},
            "InTXCheckpointed": {"Config": 0, "Position": 33, "Width": 1, "DefaultValue": 0},
            "MSRIndex": {
                "0x1a6" : {"Config": 1, "Position": 0, "Width": 64},
                "0x1a7" : {"Config": 2, "Position": 0, "Width": 64},
                "0x3f6" : {"Config": 3, "Position": 0, "Width": 64},
                "0x3f7" : {"Config": 4, "Position": 0, "Width": 64}
            }
        },
        "fixed0" : {
            "OS":          {"Config": 0, "Position": 0, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 1, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 3, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed1" : {
            "OS":          {"Config": 0, "Position": 4, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 5, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 7, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed2" : {
            "OS":          {"Config": 0, "Position": 8, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 9, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 11, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed3" : {
            "OS":          {"Config": 0, "Position": 12, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 13, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 15, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "PerfMetrics": {"Config": 2, "Position": 0, "Width": 1, "DefaultValue": 0, "__comment": "fake field to tell the collector to also print the L1 top-down metrics, not just raw slots count"}
        }
    },
    "cha" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "TIDEnable":   {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 26},
            "TID":         {"Config": 1, "Position": 0,  "Width": 9, "DefaultValue": 0}
        }
    },
    "imc" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "xpi" : {
        "__comment" :  "this is for UPI LL and QPI LL uncore PMUs",
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 24}
        }
    },
    "m2m" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 8}
        }
    },
    "m3upi" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "irp" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "ubox" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "pcu" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "iio" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 12, "DefaultValue": 0},
            "PortMask":    {"Config": 0, "Position": 36, "Width": 12},
            "FCMask":      {"Config": 0, "Position": 48, "Width": 3}
        }
    }
}

```

`src/PMURegisterDeclarations/GenuineIntel-6-86-5.json`:

```json
{
    "core" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "User":        {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 1},
            "OS":          {"Config": 0, "Position": 17, "Width": 1, "DefaultValue": 1},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1},
            "PinControl":  {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "APICInt":     {"Config": 0, "Position": 20, "Width": 1, "DefaultValue": 0},
            "Enable":      {"Config": 0, "Position": 22, "Width": 1, "DefaultValue": 1},
            "Invert":      {"Config": 0, "Position": 23, "Width": 1},
            "CounterMask": {"Config": 0, "Position": 24, "Width": 8},
            "MSRIndex": {
                "0x1a6" : {"Config": 1, "Position": 0, "Width": 64},
                "0x1a7" : {"Config": 2, "Position": 0, "Width": 64},
                "0x3f6" : {"Config": 3, "Position": 0, "Width": 64},
                "0x3f7" : {"Config": 4, "Position": 0, "Width": 64}
            }
        },
        "fixed0" : {
            "OS":          {"Config": 0, "Position": 0, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 1, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 3, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed1" : {
            "OS":          {"Config": 0, "Position": 4, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 5, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 7, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed2" : {
            "OS":          {"Config": 0, "Position": 8, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 9, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 11, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        }
    },
    "cha" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 26}
        }
    },
    "imc" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "m2m" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 8}
        }
    },
    "irp" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "pcu" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "iio" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 12, "DefaultValue": 0},
            "PortMask":    {"Config": 0, "Position": 36, "Width": 12},
            "FCMask":      {"Config": 0, "Position": 48, "Width": 3}
        }
    }
}

```

`src/PMURegisterDeclarations/GenuineIntel-6-8E-C.json`:

```json
{
    "core" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "User":        {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 1},
            "OS":          {"Config": 0, "Position": 17, "Width": 1, "DefaultValue": 1},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1},
            "PinControl":  {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "APICInt":     {"Config": 0, "Position": 20, "Width": 1, "DefaultValue": 0},
            "AnyThread":   {"Config": 0, "Position": 21, "Width": 1},
            "Enable":      {"Config": 0, "Position": 22, "Width": 1, "DefaultValue": 1},
            "Invert":      {"Config": 0, "Position": 23, "Width": 1},
            "CounterMask": {"Config": 0, "Position": 24, "Width": 8},
            "InTX":        {"Config": 0, "Position": 32, "Width": 1, "DefaultValue": 0},
            "MSRIndex": {
                    "0x1a6" : {"Config": 1, "Position": 0, "Width": 64},
                    "0x1a7" : {"Config": 2, "Position": 0, "Width": 64},
                    "0x3f6" : {"Config": 3, "Position": 0, "Width": 64},
                    "0x3f7" : {"Config": 4, "Position": 0, "Width": 64}
                }
        },
        "fixed0" : {
            "OS":          {"Config": 0, "Position": 0, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 1, "Width": 1, "DefaultValue": 1},
            "AnyThread":   {"Config": 0, "Position": 2, "Width": 1},
            "EnablePMI":   {"Config": 0, "Position": 3, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed1" : {
            "OS":          {"Config": 0, "Position": 4, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 5, "Width": 1, "DefaultValue": 1},
            "AnyThread":   {"Config": 0, "Position": 6, "Width": 1},
            "EnablePMI":   {"Config": 0, "Position": 7, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed2" : {
            "OS":          {"Config": 0, "Position": 8, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 9, "Width": 1, "DefaultValue": 1},
            "AnyThread":   {"Config": 0, "Position": 10, "Width": 1},
            "EnablePMI":   {"Config": 0, "Position": 11, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        }
    }
}

```

`src/PMURegisterDeclarations/GenuineIntel-6-8F-6.json`:

```json
{
    "core" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "User":        {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 1},
            "OS":          {"Config": 0, "Position": 17, "Width": 1, "DefaultValue": 1},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1},
            "PinControl":  {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "APICInt":     {"Config": 0, "Position": 20, "Width": 1, "DefaultValue": 0},
            "Enable":      {"Config": 0, "Position": 22, "Width": 1, "DefaultValue": 1},
            "Invert":      {"Config": 0, "Position": 23, "Width": 1},
            "CounterMask": {"Config": 0, "Position": 24, "Width": 8},
            "InTX":        {"Config": 0, "Position": 32, "Width": 1, "DefaultValue": 0},
            "InTXCheckpointed": {"Config": 0, "Position": 33, "Width": 1, "DefaultValue": 0},
            "MSRIndex": {
                "0x1a6" : {"Config": 1, "Position": 0, "Width": 64},
                "0x1a7" : {"Config": 2, "Position": 0, "Width": 64},
                "0x3f6" : {"Config": 3, "Position": 0, "Width": 64},
                "0x3f7" : {"Config": 4, "Position": 0, "Width": 64}
            }
        },
        "fixed0" : {
            "OS":          {"Config": 0, "Position": 0, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 1, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 3, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed1" : {
            "OS":          {"Config": 0, "Position": 4, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 5, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 7, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed2" : {
            "OS":          {"Config": 0, "Position": 8, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 9, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 11, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed3" : {
            "OS":          {"Config": 0, "Position": 12, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 13, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 15, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "PerfMetrics": {"Config": 2, "Position": 0, "Width": 1, "DefaultValue": 0, "__comment": "fake field to tell the collector to also print the L1 top-down metrics, not just raw slots count"}
        }
    },
    "cha" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "TIDEnable":   {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 0},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 26},
            "TID":         {"Config": 1, "Position": 0,  "Width": 10, "DefaultValue": 0}
        }
    },
    "imc" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "xpi" : {
        "__comment" :  "this is for UPI LL and QPI LL uncore PMUs",
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 24}
        }
    },
    "m2m" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 8}
        }
    },
    "m3upi" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "mdf" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "irp" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "ubox" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "pcu" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "iio" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 12, "DefaultValue": 0},
            "PortMask":    {"Config": 0, "Position": 36, "Width": 12},
            "FCMask":      {"Config": 0, "Position": 48, "Width": 3}
        }
    }
}

```

`src/PMURegisterDeclarations/GenuineIntel-6-AD-0.json`:

```json
{
    "core" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "User":        {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 1},
            "OS":          {"Config": 0, "Position": 17, "Width": 1, "DefaultValue": 1},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1},
            "PinControl":  {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "APICInt":     {"Config": 0, "Position": 20, "Width": 1, "DefaultValue": 0},
            "Enable":      {"Config": 0, "Position": 22, "Width": 1, "DefaultValue": 1},
            "Invert":      {"Config": 0, "Position": 23, "Width": 1},
            "CounterMask": {"Config": 0, "Position": 24, "Width": 8},
            "InTX":        {"Config": 0, "Position": 32, "Width": 1, "DefaultValue": 0},
            "InTXCheckpointed": {"Config": 0, "Position": 33, "Width": 1, "DefaultValue": 0},
            "MSRIndex": {
                "0x1a6" : {"Config": 1, "Position": 0, "Width": 64},
                "0x1a7" : {"Config": 2, "Position": 0, "Width": 64},
                "0x3f6" : {"Config": 3, "Position": 0, "Width": 64},
                "0x3f7" : {"Config": 4, "Position": 0, "Width": 64}
            }
        },
        "fixed0" : {
            "OS":          {"Config": 0, "Position": 0, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 1, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 3, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed1" : {
            "OS":          {"Config": 0, "Position": 4, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 5, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 7, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed2" : {
            "OS":          {"Config": 0, "Position": 8, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 9, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 11, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed3" : {
            "OS":          {"Config": 0, "Position": 12, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 13, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 15, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "PerfMetrics": {"Config": 2, "Position": 0, "Width": 1, "DefaultValue": 0, "__comment": "fake field to tell the collector to also print the L1 top-down metrics, not just raw slots count"}
        }
    },
    "cha" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "TIDEnable":   {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 0},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 26},
            "TID":         {"Config": 1, "Position": 0,  "Width": 10, "DefaultValue": 0}
        }
    },
    "imc" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "xpi" : {
        "__comment" :  "this is for UPI LL and QPI LL uncore PMUs",
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 24}
        }
    },
    "m2m" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 8}
        }
    },
    "m3upi" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "mdf" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "irp" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "pcu" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "pciex8" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "pciex16" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "iio" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 12, "DefaultValue": 0},
            "PortMask":    {"Config": 0, "Position": 36, "Width": 12},
            "FCMask":      {"Config": 0, "Position": 48, "Width": 3}
        }
    }
}

```

`src/PMURegisterDeclarations/GenuineIntel-6-AE-0.json`:

```json
{
    "core" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "User":        {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 1},
            "OS":          {"Config": 0, "Position": 17, "Width": 1, "DefaultValue": 1},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1},
            "PinControl":  {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "APICInt":     {"Config": 0, "Position": 20, "Width": 1, "DefaultValue": 0},
            "Enable":      {"Config": 0, "Position": 22, "Width": 1, "DefaultValue": 1},
            "Invert":      {"Config": 0, "Position": 23, "Width": 1},
            "CounterMask": {"Config": 0, "Position": 24, "Width": 8},
            "InTX":        {"Config": 0, "Position": 32, "Width": 1, "DefaultValue": 0},
            "InTXCheckpointed": {"Config": 0, "Position": 33, "Width": 1, "DefaultValue": 0},
            "MSRIndex": {
                "0x1a6" : {"Config": 1, "Position": 0, "Width": 64},
                "0x1a7" : {"Config": 2, "Position": 0, "Width": 64},
                "0x3f6" : {"Config": 3, "Position": 0, "Width": 64},
                "0x3f7" : {"Config": 4, "Position": 0, "Width": 64}
            }
        },
        "fixed0" : {
            "OS":          {"Config": 0, "Position": 0, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 1, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 3, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed1" : {
            "OS":          {"Config": 0, "Position": 4, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 5, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 7, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed2" : {
            "OS":          {"Config": 0, "Position": 8, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 9, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 11, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed3" : {
            "OS":          {"Config": 0, "Position": 12, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 13, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 15, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "PerfMetrics": {"Config": 2, "Position": 0, "Width": 1, "DefaultValue": 0, "__comment": "fake field to tell the collector to also print the L1 top-down metrics, not just raw slots count"}
        }
    },
    "cha" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "TIDEnable":   {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 0},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 26},
            "TID":         {"Config": 1, "Position": 0,  "Width": 10, "DefaultValue": 0}
        }
    },
    "imc" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "xpi" : {
        "__comment" :  "this is for UPI LL and QPI LL uncore PMUs",
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 24}
        }
    },
    "m2m" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 8}
        }
    },
    "m3upi" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "mdf" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "irp" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "pcu" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "pciex8" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "pciex16" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "iio" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 12, "DefaultValue": 0},
            "PortMask":    {"Config": 0, "Position": 36, "Width": 12},
            "FCMask":      {"Config": 0, "Position": 48, "Width": 3}
        }
    }
}

```

`src/PMURegisterDeclarations/GenuineIntel-6-AF-0.json`:

```json
{
    "core" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "User":        {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 1},
            "OS":          {"Config": 0, "Position": 17, "Width": 1, "DefaultValue": 1},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1},
            "PinControl":  {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "APICInt":     {"Config": 0, "Position": 20, "Width": 1, "DefaultValue": 0},
            "Enable":      {"Config": 0, "Position": 22, "Width": 1, "DefaultValue": 1},
            "Invert":      {"Config": 0, "Position": 23, "Width": 1},
            "CounterMask": {"Config": 0, "Position": 24, "Width": 8},
            "MSRIndex": {
                "0x1a6" : {"Config": 1, "Position": 0, "Width": 64},
                "0x1a7" : {"Config": 2, "Position": 0, "Width": 64},
                "0x3f6" : {"Config": 3, "Position": 0, "Width": 64},
                "0x3f7" : {"Config": 4, "Position": 0, "Width": 64}
            }
        },
        "fixed0" : {
            "OS":          {"Config": 0, "Position": 0, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 1, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 3, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed1" : {
            "OS":          {"Config": 0, "Position": 4, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 5, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 7, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed2" : {
            "OS":          {"Config": 0, "Position": 8, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 9, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 11, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        }
    },
    "cha" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "TIDEnable":   {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 0},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 26},
            "TID":         {"Config": 1, "Position": 0,  "Width": 10, "DefaultValue": 0}
        }
    },
    "imc" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "xpi" : {
        "__comment" :  "this is for UPI LL and QPI LL uncore PMUs",
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 24}
        }
    },
    "m2m" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 8}
        }
    },
    "m3upi" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "mdf" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "irp" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "pcu" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "pciex8" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "pciex16" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "iio" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 12, "DefaultValue": 0},
            "PortMask":    {"Config": 0, "Position": 36, "Width": 12},
            "FCMask":      {"Config": 0, "Position": 48, "Width": 3}
        }
    }
}

```

`src/PMURegisterDeclarations/GenuineIntel-6-B6-0.json`:

```json
{
    "core" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "User":        {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 1},
            "OS":          {"Config": 0, "Position": 17, "Width": 1, "DefaultValue": 1},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1},
            "PinControl":  {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "APICInt":     {"Config": 0, "Position": 20, "Width": 1, "DefaultValue": 0},
            "Enable":      {"Config": 0, "Position": 22, "Width": 1, "DefaultValue": 1},
            "Invert":      {"Config": 0, "Position": 23, "Width": 1},
            "CounterMask": {"Config": 0, "Position": 24, "Width": 8},
            "MSRIndex": {
                "0x1a6" : {"Config": 1, "Position": 0, "Width": 64},
                "0x1a7" : {"Config": 2, "Position": 0, "Width": 64},
                "0x3f6" : {"Config": 3, "Position": 0, "Width": 64},
                "0x3f7" : {"Config": 4, "Position": 0, "Width": 64}
            }
        },
        "fixed0" : {
            "OS":          {"Config": 0, "Position": 0, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 1, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 3, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed1" : {
            "OS":          {"Config": 0, "Position": 4, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 5, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 7, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed2" : {
            "OS":          {"Config": 0, "Position": 8, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 9, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 11, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        }
    },
    "cha" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "TIDEnable":   {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 0},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 26},
            "TID":         {"Config": 1, "Position": 0,  "Width": 10, "DefaultValue": 0}
        }
    },
    "imc" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "xpi" : {
        "__comment" :  "this is for UPI LL and QPI LL uncore PMUs",
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 24}
        }
    },
    "m2m" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 8}
        }
    },
    "m3upi" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "mdf" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "irp" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "pcu" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "pciex8" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "pciex16" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "iio" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 12, "DefaultValue": 0},
            "PortMask":    {"Config": 0, "Position": 36, "Width": 12},
            "FCMask":      {"Config": 0, "Position": 48, "Width": 3}
        }
    }
}

```

`src/PMURegisterDeclarations/GenuineIntel-6-CF-1.json`:

```json
{
    "core" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "User":        {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 1},
            "OS":          {"Config": 0, "Position": 17, "Width": 1, "DefaultValue": 1},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1},
            "PinControl":  {"Config": 0, "Position": 19, "Width": 1, "DefaultValue": 0},
            "APICInt":     {"Config": 0, "Position": 20, "Width": 1, "DefaultValue": 0},
            "Enable":      {"Config": 0, "Position": 22, "Width": 1, "DefaultValue": 1},
            "Invert":      {"Config": 0, "Position": 23, "Width": 1},
            "CounterMask": {"Config": 0, "Position": 24, "Width": 8},
            "InTX":        {"Config": 0, "Position": 32, "Width": 1, "DefaultValue": 0},
            "InTXCheckpointed": {"Config": 0, "Position": 33, "Width": 1, "DefaultValue": 0},
            "MSRIndex": {
                "0x1a6" : {"Config": 1, "Position": 0, "Width": 64},
                "0x1a7" : {"Config": 2, "Position": 0, "Width": 64},
                "0x3f6" : {"Config": 3, "Position": 0, "Width": 64},
                "0x3f7" : {"Config": 4, "Position": 0, "Width": 64}
            }
        },
        "fixed0" : {
            "OS":          {"Config": 0, "Position": 0, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 1, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 3, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed1" : {
            "OS":          {"Config": 0, "Position": 4, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 5, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 7, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed2" : {
            "OS":          {"Config": 0, "Position": 8, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 9, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 11, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"}
        },
        "fixed3" : {
            "OS":          {"Config": 0, "Position": 12, "Width": 1, "DefaultValue": 1},
            "User":        {"Config": 0, "Position": 13, "Width": 1, "DefaultValue": 1},
            "EnablePMI":   {"Config": 0, "Position": 15, "Width": 1, "DefaultValue": 0},
            "EventCode":   {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "UMask":       {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "EdgeDetect":  {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "Invert":      {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "CounterMask": {"Config": 0, "Position": -1, "__comment": "position=-1 means field ignored"},
            "PerfMetrics": {"Config": 2, "Position": 0, "Width": 1, "DefaultValue": 0, "__comment": "fake field to tell the collector to also print the L1 top-down metrics, not just raw slots count"}
        }
    },
    "cha" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "TIDEnable":   {"Config": 0, "Position": 16, "Width": 1, "DefaultValue": 0},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 26},
            "TID":         {"Config": 1, "Position": 0,  "Width": 10, "DefaultValue": 0}
        }
    },
    "imc" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "xpi" : {
        "__comment" :  "this is for UPI LL and QPI LL uncore PMUs",
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 24}
        }
    },
    "m2m" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0},
            "UMaskExt":    {"Config": 0, "Position": 32, "Width": 8}
        }
    },
    "m3upi" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "mdf" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "irp" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "ubox" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 8, "DefaultValue": 0}
        }
    },
    "pcu" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0}
        }
    },
    "iio" : {
        "programmable" : {
            "EventCode":   {"Config": 0, "Position": 0, "Width": 8},
            "UMask":       {"Config": 0, "Position": 8, "Width": 8},
            "EdgeDetect":  {"Config": 0, "Position": 18, "Width": 1, "DefaultValue": 0},
            "Threshold":   {"Config": 0, "Position": 24, "Width": 12, "DefaultValue": 0},
            "PortMask":    {"Config": 0, "Position": 36, "Width": 12},
            "FCMask":      {"Config": 0, "Position": 48, "Width": 3}
        }
    }
}

```

`src/WinMSRDriver/MSR.inf`:

```inf
;
; MSR.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=MSR.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
MSR_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

[SourceDisksFiles]
MSR.sys  = 1,,

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%MSR.DeviceDesc%=MSR_Device, Root\MSR ; TODO: edit hw-id

[MSR_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
MSR.sys

;-------------- Service installation
[MSR_Device.NT.Services]
AddService = MSR,%SPSVCINST_ASSOCSERVICE%, MSR_Service_Inst

; -------------- MSR driver install sections
[MSR_Service_Inst]
DisplayName    = %MSR.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\MSR.sys

;
;--- MSR_Device Coinstaller installation ------
;

[MSR_Device.NT.CoInstallers]
AddReg=MSR_Device_CoInstaller_AddReg
CopyFiles=MSR_Device_CoInstaller_CopyFiles

[MSR_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[MSR_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[MSR_Device.NT.Wdf]
KmdfService =  MSR, MSR_wdfsect
[MSR_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "MSR Installation Disk"
MSR.DeviceDesc = "MSR Device"
MSR.SVCDESC = "MSR Service"

```

`src/WinMSRDriver/MSR.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{0A94F800-4821-4654-B0A9-53D02F51A81E}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>MSR</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>C:\Program Files (x86)\Windows Kits\10\Include\10.0.14393.0\um;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <AdditionalDependencies>Wdmsec.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="msr.h" />
    <ClInclude Include="msrstruct.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="msrmain.c" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`src/WinMSRDriver/makefile`:

```
!INCLUDE $(NTMAKEENV)\makefile.def
```

`src/WinMSRDriver/msr.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation

#ifndef MSR_INCLUDED
#define MSR_INCLUDED

/*
   written by Roman Dementiev
*/


#include <ntifs.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include "msrstruct.h"


#endif

```

`src/WinMSRDriver/msrmain.c`:

```c
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation

/*

   WARNING: This driver code is only for testing purposes, not for production use
*/

#include "msr.h"
#include "ntdef.h"
#include <wdm.h>
#include <wdmsec.h>


/*!     \file msrmain.cpp
        \brief Test Windows 7 Model Specific Driver implementation
*/

#define NT_DEVICE_NAME L"\\Driver\\RDMSR"
#define DOS_DEVICE_NAME L"\\DosDevices\\RDMSR"

struct DeviceExtension
{
    HANDLE devMemHandle;
    HANDLE counterSetHandle;
};

DRIVER_INITIALIZE DriverEntry;

__drv_dispatchType(IRP_MJ_CREATE)
__drv_dispatchType(IRP_MJ_CLOSE)
DRIVER_DISPATCH dummyFunction;

__drv_dispatchType(IRP_MJ_DEVICE_CONTROL)
DRIVER_DISPATCH deviceControl;

DRIVER_UNLOAD MSRUnload;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,MSRUnload)
#pragma alloc_text(PAGE,dummyFunction)
#pragma alloc_text(PAGE,deviceControl)
#endif


NTSTATUS
DriverEntry(
    __in PDRIVER_OBJECT DriverObject,
    __in PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING dosDeviceName;
    PDEVICE_OBJECT MSRSystemDeviceObject = NULL;
    struct DeviceExtension * pExt = NULL;
    UNICODE_STRING devMemPath;
    OBJECT_ATTRIBUTES attr;

    UNREFERENCED_PARAMETER(RegistryPath);

    RtlInitUnicodeString(&UnicodeString, NT_DEVICE_NAME);
    RtlInitUnicodeString(&dosDeviceName, DOS_DEVICE_NAME);

#if 1
    status = IoCreateDeviceSecure(DriverObject,
        sizeof(struct DeviceExtension),
        &UnicodeString,
        FILE_DEVICE_UNKNOWN,
        FILE_DEVICE_SECURE_OPEN,
        FALSE,
        &SDDL_DEVOBJ_SYS_ALL_ADM_ALL,
        NULL,
        &MSRSystemDeviceObject
    );
#else
    status = IoCreateDevice(DriverObject,
                            sizeof(struct DeviceExtension),
                            &UnicodeString,
                            FILE_DEVICE_UNKNOWN,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &MSRSystemDeviceObject
                            );
#endif

    if (!NT_SUCCESS(status))
        return status;

    DriverObject->DriverUnload = MSRUnload;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = dummyFunction;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = dummyFunction;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = deviceControl;

    pExt = DriverObject->DeviceObject->DeviceExtension;
    RtlInitUnicodeString(&devMemPath, L"\\Device\\PhysicalMemory");
    InitializeObjectAttributes(&attr, &devMemPath, OBJ_KERNEL_HANDLE, (HANDLE)NULL, (PSECURITY_DESCRIPTOR)NULL);
    status = ZwOpenSection(&pExt->devMemHandle, SECTION_MAP_READ | SECTION_MAP_WRITE, &attr);
    if (!NT_SUCCESS(status))
    {
        DbgPrint("Error: failed ZwOpenSection(devMemHandle) => %08X\n", status);
        return status;
    }
    pExt->counterSetHandle = NULL;

    IoCreateSymbolicLink(&dosDeviceName, &UnicodeString);

    return status;
}


NTSTATUS dummyFunction(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;


    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}


VOID MSRUnload(PDRIVER_OBJECT DriverObject)
{
    PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
    UNICODE_STRING nameString;

    PAGED_CODE();

    RtlInitUnicodeString(&nameString, DOS_DEVICE_NAME);

    IoDeleteSymbolicLink(&nameString);

    if (deviceObject != NULL)
    {
        IoDeleteDevice(deviceObject);
    }
}


NTSTATUS deviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpStackLocation = NULL;
    struct MSR_Request * input_msr_req = NULL;
    struct PCICFG_Request * input_pcicfg_req = NULL;
    struct MMAP_Request* input_mmap_req = NULL;
    ULONG64 * output = NULL;
    GROUP_AFFINITY old_affinity, new_affinity;
    ULONG inputSize = 0;
    PCI_SLOT_NUMBER slot;
    unsigned size = 0;
    PROCESSOR_NUMBER ProcNumber;
    struct DeviceExtension* pExt = NULL;
    LARGE_INTEGER offset;
    SIZE_T mmapSize = 0;
    PVOID baseAddress = NULL;

    pExt = DeviceObject->DeviceExtension;

    PAGED_CODE();

    IrpStackLocation = IoGetCurrentIrpStackLocation(Irp);

    if (IrpStackLocation)
    {
        inputSize = IrpStackLocation->Parameters.DeviceIoControl.InputBufferLength;

        if (IrpStackLocation->Parameters.DeviceIoControl.OutputBufferLength >=
            sizeof(ULONG64))
        {
            input_msr_req = (struct MSR_Request *)Irp->AssociatedIrp.SystemBuffer;
            input_pcicfg_req = (struct PCICFG_Request *)Irp->AssociatedIrp.SystemBuffer;
            input_mmap_req = (struct MMAP_Request*)Irp->AssociatedIrp.SystemBuffer;
            output = (ULONG64 *)Irp->AssociatedIrp.SystemBuffer;

            RtlSecureZeroMemory(&ProcNumber, sizeof(PROCESSOR_NUMBER));

            switch (IrpStackLocation->Parameters.DeviceIoControl.IoControlCode)
            {
            case IO_CTL_MSR_WRITE:
                if (inputSize < sizeof(struct MSR_Request))
                {
                    status = STATUS_INVALID_PARAMETER;
                    break;
                }
                RtlSecureZeroMemory(&new_affinity, sizeof(GROUP_AFFINITY));
                RtlSecureZeroMemory(&old_affinity, sizeof(GROUP_AFFINITY));
                KeGetProcessorNumberFromIndex(input_msr_req->core_id, &ProcNumber);
                new_affinity.Group = ProcNumber.Group;
                new_affinity.Mask = 1ULL << (ProcNumber.Number);
                KeSetSystemGroupAffinityThread(&new_affinity, &old_affinity);
                __try
                {
                    __writemsr(input_msr_req->msr_address, input_msr_req->write_value);
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    status = GetExceptionCode();
                    DbgPrint("Error: exception with code 0x%X in IO_CTL_MSR_WRITE core 0x%X msr 0x%llX value 0x%llX\n",
                        status, input_msr_req->core_id, input_msr_req->msr_address, input_msr_req->write_value);
                }
                KeRevertToUserGroupAffinityThread(&old_affinity);
                Irp->IoStatus.Information = 0;                         // result size
                break;
            case IO_CTL_MSR_READ:
                if (inputSize < sizeof(struct MSR_Request))
                {
                    status = STATUS_INVALID_PARAMETER;
                    break;
                }
                RtlSecureZeroMemory(&new_affinity, sizeof(GROUP_AFFINITY));
                RtlSecureZeroMemory(&old_affinity, sizeof(GROUP_AFFINITY));
                KeGetProcessorNumberFromIndex(input_msr_req->core_id, &ProcNumber);
                new_affinity.Group = ProcNumber.Group;
                new_affinity.Mask = 1ULL << (ProcNumber.Number);
                KeSetSystemGroupAffinityThread(&new_affinity, &old_affinity);
                __try
                {
                    *output = __readmsr(input_msr_req->msr_address);
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    status = GetExceptionCode();
                    DbgPrint("Error: exception with code 0x%X in IO_CTL_MSR_READ core 0x%X msr 0x%llX\n",
                        status, input_msr_req->core_id, input_msr_req->msr_address);
                }
                KeRevertToUserGroupAffinityThread(&old_affinity);
                Irp->IoStatus.Information = sizeof(ULONG64);                         // result size
                break;
            case IO_CTL_MMAP_SUPPORT:
                *output = 1;
                Irp->IoStatus.Information = sizeof(ULONG64); // result size
                break;
            case IO_CTL_MMAP:
                offset = input_mmap_req->address;
                mmapSize = input_mmap_req->size;
                status = ZwMapViewOfSection(pExt->devMemHandle, ZwCurrentProcess(), &baseAddress, 0L, PAGE_SIZE, &offset, &mmapSize, ViewUnmap, 0, PAGE_READWRITE);
                if (status != STATUS_SUCCESS || baseAddress == NULL)
                {
                    DbgPrint("Error: ZwMapViewOfSection failed, %lld %lld (%ld).\n", offset.QuadPart, mmapSize, status);
                }
                else
                {
                    *output = (ULONG64)baseAddress;
                    Irp->IoStatus.Information = sizeof(PVOID); // result size
                }
                break;
            case IO_CTL_MUNMAP:
                status = ZwUnmapViewOfSection(ZwCurrentProcess(), (PVOID) input_mmap_req->address.QuadPart);
                break;
            case IO_CTL_PMU_ALLOC_SUPPORT:
                *output = 1;
                Irp->IoStatus.Information = sizeof(ULONG64); // result size
                break;
            case IO_CTL_PMU_ALLOC:
                if (pExt->counterSetHandle == NULL)
                {
                    status = HalAllocateHardwareCounters(NULL, 0, NULL, &(pExt->counterSetHandle));
                }
                *output = status;
                Irp->IoStatus.Information = sizeof(ULONG64); // result size
                break;
            case IO_CTL_PMU_FREE:
                if (pExt->counterSetHandle != NULL)
                {
                    status = HalFreeHardwareCounters(pExt->counterSetHandle);
                    if (status == STATUS_SUCCESS)
                    {
                        pExt->counterSetHandle = NULL;
                    }
                }
                *output = status;
                Irp->IoStatus.Information = sizeof(ULONG64); // result size
                break;
            case IO_CTL_PCICFG_WRITE:
                if (inputSize < sizeof(struct PCICFG_Request) || (input_pcicfg_req->bytes != 4 && input_pcicfg_req->bytes != 8))
                {
                    status = STATUS_INVALID_PARAMETER;
                    break;
                }
                slot.u.AsULONG = 0;
                slot.u.bits.DeviceNumber = input_pcicfg_req->dev;
                slot.u.bits.FunctionNumber = input_pcicfg_req->func;
#pragma warning(push)
#pragma warning(disable: 4996)
                __try
                {
                    size = HalSetBusDataByOffset(PCIConfiguration, input_pcicfg_req->bus, slot.u.AsULONG,
                        &(input_pcicfg_req->write_value), input_pcicfg_req->reg, input_pcicfg_req->bytes);
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    status = GetExceptionCode();
                    size = 0;
                    DbgPrint("Error: exception with code 0x%X in IO_CTL_PCICFG_WRITE b 0x%X d 0x%X f 0x%X reg 0x%X bytes 0x%X value 0x%llX\n",
                        status, input_pcicfg_req->bus, input_pcicfg_req->dev, input_pcicfg_req->func, input_pcicfg_req->reg, input_pcicfg_req->bytes,
                        input_pcicfg_req->write_value);
                }
#pragma warning(pop)
                if (size != input_pcicfg_req->bytes)
                {
                    status = STATUS_INVALID_PARAMETER;
                    break;
                }
                Irp->IoStatus.Information = 0;                                         // result size
                break;
            case IO_CTL_PCICFG_READ:
                if (inputSize < sizeof(struct PCICFG_Request) || (input_pcicfg_req->bytes != 4 && input_pcicfg_req->bytes != 8))
                {
                    status = STATUS_INVALID_PARAMETER;
                    break;
                }
                slot.u.AsULONG = 0;
                slot.u.bits.DeviceNumber = input_pcicfg_req->dev;
                slot.u.bits.FunctionNumber = input_pcicfg_req->func;
#pragma warning(push)
#pragma warning(disable: 4996)
                __try
                {
                    size = HalGetBusDataByOffset(PCIConfiguration, input_pcicfg_req->bus, slot.u.AsULONG,
                        output, input_pcicfg_req->reg, input_pcicfg_req->bytes);
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    status = GetExceptionCode();
                    size = 0;
                    DbgPrint("Error: exception with code 0x%X in IO_CTL_PCICFG_READ b 0x%X d 0x%X f 0x%X reg 0x%X bytes 0x%X\n",
                        status, input_pcicfg_req->bus, input_pcicfg_req->dev, input_pcicfg_req->func, input_pcicfg_req->reg, input_pcicfg_req->bytes);
                }
#pragma warning(pop)
                if (size != input_pcicfg_req->bytes)
                {
                    status = STATUS_INVALID_PARAMETER;
                    break;
                }
                Irp->IoStatus.Information = size;                                         // result size
                break;

            default:
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
        }
        else
            status = STATUS_INVALID_PARAMETER;
    }
    else
        status = STATUS_INVALID_DEVICE_REQUEST;


    Irp->IoStatus.Status = status;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

```

`src/WinMSRDriver/msrstruct.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation

/*
   written by Roman Dementiev
*/

#ifndef MSR_STRUCT_HEADER
#define MSR_STRUCT_HEADER


#ifndef CTL_CODE
#include <WinIoCtl.h>
#endif

#define MSR_DEV_TYPE 50000

#define IO_CTL_MSR_READ     CTL_CODE(MSR_DEV_TYPE, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_CTL_MSR_WRITE    CTL_CODE(MSR_DEV_TYPE, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_CTL_PCICFG_READ  CTL_CODE(MSR_DEV_TYPE, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_CTL_PCICFG_WRITE CTL_CODE(MSR_DEV_TYPE, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_CTL_MMAP_SUPPORT CTL_CODE(MSR_DEV_TYPE, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_CTL_MMAP         CTL_CODE(MSR_DEV_TYPE, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_CTL_MUNMAP       CTL_CODE(MSR_DEV_TYPE, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_CTL_PMU_ALLOC_SUPPORT CTL_CODE(MSR_DEV_TYPE, 0x807, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_CTL_PMU_ALLOC         CTL_CODE(MSR_DEV_TYPE, 0x808, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_CTL_PMU_FREE          CTL_CODE(MSR_DEV_TYPE, 0x809, METHOD_BUFFERED, FILE_ANY_ACCESS)

struct MSR_Request
{
    int core_id;
    ULONG64 msr_address;
    ULONG64 write_value;     /* value to write if write requet
                                 ignored if read request */
};

struct PCICFG_Request
{
    ULONG bus, dev, func, reg, bytes;
    // "bytes" can be only 4 or 8
    /* value to write if write request ignored if read request */
    ULONG64 write_value;
};

struct MMAP_Request
{
    LARGE_INTEGER address;
    SIZE_T size;
};


#endif

```

`src/WinMSRDriver/sources`:

```
TARGETNAME=msr
TARGETTYPE=DRIVER
NTDDI_VERSION=NTDDI_WIN7

MSC_WARNING_LEVEL=/W3 /WX


INCLUDES=\
   $(DDK_INC_PATH);

TARGETLIBS=\
    $(DDK_LIB_PATH)\ntoskrnl.lib


SOURCES=msrmain.c

PRECOMPILED_INCLUDE=msr.h








```

`src/bw.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev,
//            Patrick Konsor
//

#include <iostream>
#include "bw.h"
#include "pci.h"
#include "utils.h"
#include <assert.h>

namespace pcm {

    constexpr auto PCM_CLIENT_IMC_BAR_OFFSET = 0x0048;
    constexpr auto PCM_TGL_IMC_STEP = 0x10000;
    unsigned int PCM_TGL_IMC_DRAM_DATA_READS[2]  = { 0x5058, 0xd858 };
    unsigned int PCM_TGL_IMC_DRAM_DATA_WRITES[2] = { 0x50A0, 0xd8A0 };
    unsigned int PCM_TGL_IMC_MMAP_SIZE[2]        = { 0x5000 + 0x1000, 0xd000 + 0x1000 };
    unsigned int PCM_TGL_IMC_EVENT_BASE[2]       = { 0x5000,          0xd000 };

    uint64 getClientIMCStartAddr()
    {
        PciHandleType imcHandle(0, 0, 0, 0); // memory controller device coordinates: domain 0, bus 0, device 0, function 0
        uint64 imcbar = 0;
        imcHandle.read64(PCM_CLIENT_IMC_BAR_OFFSET, &imcbar);
        // std::cout << "DEBUG: imcbar=" << std::hex << imcbar << "\n" << std::dec << std::flush;
        if (!imcbar)
        {
            std::cerr << "ERROR: imcbar is zero.\n";
            throw std::exception();
        }
        return imcbar & (~(4096ULL - 1ULL)); // round down to 4K
    }

    TGLClientBW::TGLClientBW()
    {
        const auto startAddr = getClientIMCStartAddr();
        for (size_t i = 0; i < mmioRange.size(); ++i)
        {
            for (size_t model = 0; model < mmioRange[i].size(); ++model)
            {
                mmioRange[i][model] = std::make_shared<MMIORange>(startAddr + i * PCM_TGL_IMC_STEP +  PCM_TGL_IMC_EVENT_BASE[model], PCM_TGL_IMC_MMAP_SIZE[model] - PCM_TGL_IMC_EVENT_BASE[model]);
            }
        }
    }

    uint64 TGLClientBW::getImcReads()
    {
        uint64 result = 0;
        for (auto & r : mmioRange)
            for (size_t model = 0; model < r.size(); ++model)
            {
                result += r[model]->read64(PCM_TGL_IMC_DRAM_DATA_READS[model] - PCM_TGL_IMC_EVENT_BASE[model]);
            }
        return result;
    }

    uint64 TGLClientBW::getImcWrites()
    {
        uint64 result = 0;
        for (auto & r : mmioRange)
            for (size_t model = 0; model < r.size(); ++model)
            {
                result += r[model]->read64(PCM_TGL_IMC_DRAM_DATA_WRITES[model] - PCM_TGL_IMC_EVENT_BASE[model]);
            }
        return result;
    }

#define PCM_CLIENT_IMC_DRAM_GT_REQUESTS (0x5040)
#define PCM_CLIENT_IMC_DRAM_IA_REQUESTS (0x5044)
#define PCM_CLIENT_IMC_DRAM_IO_REQUESTS (0x5048)
#define PCM_CLIENT_IMC_DRAM_DATA_READS  (0x5050)
#define PCM_CLIENT_IMC_DRAM_DATA_WRITES (0x5054)
#define PCM_CLIENT_IMC_MMAP_SIZE        (0x6000)
#define PCM_CLIENT_IMC_EVENT_BASE       (0x5000)

ClientBW::ClientBW()
{
    mmioRange = std::make_shared<MMIORange>(getClientIMCStartAddr() + PCM_CLIENT_IMC_EVENT_BASE, PCM_CLIENT_IMC_MMAP_SIZE - PCM_CLIENT_IMC_EVENT_BASE);
}

uint64 ClientBW::getImcReads()
{
    return mmioRange->read32(PCM_CLIENT_IMC_DRAM_DATA_READS - PCM_CLIENT_IMC_EVENT_BASE);
}

uint64 ClientBW::getImcWrites()
{
    return mmioRange->read32(PCM_CLIENT_IMC_DRAM_DATA_WRITES - PCM_CLIENT_IMC_EVENT_BASE);
}

uint64 ClientBW::getGtRequests()
{
    return mmioRange->read32(PCM_CLIENT_IMC_DRAM_GT_REQUESTS - PCM_CLIENT_IMC_EVENT_BASE);
}

uint64 ClientBW::getIaRequests()
{
    return mmioRange->read32(PCM_CLIENT_IMC_DRAM_IA_REQUESTS - PCM_CLIENT_IMC_EVENT_BASE);
}

uint64 ClientBW::getIoRequests()
{
    return mmioRange->read32(PCM_CLIENT_IMC_DRAM_IO_REQUESTS - PCM_CLIENT_IMC_EVENT_BASE);
}

#define PCM_ADL_IMC_EVENT_BASE       (0xd000)
#define PCM_ADL_IMC_DRAM_DATA_READS  (0x858)
#define PCM_ADL_IMC_DRAM_DATA_WRITES (0x8A0)

ADLClientBW::ADLClientBW()
{
    mmioRange = std::make_shared<MMIORange>(getClientIMCStartAddr() + PCM_ADL_IMC_EVENT_BASE, 0x1000);
}

uint64 ADLClientBW::getImcReads()
{
    return mmioRange->read32(PCM_ADL_IMC_DRAM_DATA_READS);
}

uint64 ADLClientBW::getImcWrites()
{
    return mmioRange->read32(PCM_ADL_IMC_DRAM_DATA_WRITES);
}

#define PCM_SERVER_IMC_DRAM_DATA_READS  (0x2290)
#define PCM_SERVER_IMC_DRAM_DATA_WRITES (0x2298)
#define PCM_SERVER_IMC_PMM_DATA_READS   (0x22a0)
#define PCM_SERVER_IMC_PMM_DATA_WRITES  (0x22a8)
#define PCM_SERVER_IMC_MMAP_SIZE        (0x4000)

std::vector<size_t> getServerBars(const size_t regBase, const uint32 numIMC, const uint32 root_segment_ubox0, const uint32 root_bus_ubox0)
{
    std::vector<size_t> result;
    PciHandleType ubox0Handle(root_segment_ubox0, root_bus_ubox0, SERVER_UBOX0_REGISTER_DEV_ADDR, SERVER_UBOX0_REGISTER_FUNC_ADDR);
    uint32 mmioBase = 0;
    ubox0Handle.read32(0xd0, &mmioBase);
    // std::cout << "mmioBase is 0x" << std::hex << mmioBase << std::dec << std::endl;
    for (uint32 i = 0; i < numIMC; ++i)
    {
        uint32 memOffset = 0;
        ubox0Handle.read32(regBase + i * 4, &memOffset);
        // std::cout << "memOffset for imc "<<i<<" is 0x" << std::hex << memOffset << std::dec << std::endl;
        size_t memBar = ((size_t(mmioBase) & ((1ULL << 29ULL) - 1ULL)) << 23ULL) |
            ((size_t(memOffset) & ((1ULL << 11ULL) - 1ULL)) << 12ULL);
        // std::cout << "membar for imc "<<i<<" is 0x" << std::hex << memBar << std::dec << std::endl;
        if (memBar == 0)
        {
            std::cerr << "ERROR: bar " << i << " is zero." << std::endl;
            throw std::exception();
        }
        result.push_back(memBar);
    }
    return result;
}

size_t getServerSCFBar(const uint32 root_segment_ubox0, const uint32 root_bus_ubox0)
{
    std::vector<size_t> result = getServerBars(0xd4, 1, root_segment_ubox0, root_bus_ubox0);
    assert(result.size() == 1);
    return result[0];
}

std::vector<size_t> getServerMemBars(const uint32 numIMC, const uint32 root_segment_ubox0, const uint32 root_bus_ubox0)
{
    return getServerBars(0xd8, numIMC, root_segment_ubox0, root_bus_ubox0);
}

ServerBW::ServerBW(const uint32 numIMC, const uint32 root_segment_ubox0, const uint32 root_bus_ubox0)
{
    auto memBars = getServerMemBars(numIMC, root_segment_ubox0, root_bus_ubox0);
    for (auto & memBar: memBars)
    {
        mmioRanges.push_back(std::make_shared<MMIORange>(memBar, PCM_SERVER_IMC_MMAP_SIZE));
    }
}

uint64 ServerBW::getImcReads()
{
    uint64 result = 0;
    for (auto & mmio: mmioRanges)
    {
        // std::cout << "PCM_SERVER_IMC_DRAM_DATA_READS: " << mmio->read64(PCM_SERVER_IMC_DRAM_DATA_READS) << std::endl;
        result += mmio->read64(PCM_SERVER_IMC_DRAM_DATA_READS);
    }
    return result;
}

uint64 ServerBW::getImcWrites()
{
    uint64 result = 0;
    for (auto & mmio : mmioRanges)
    {
        result += mmio->read64(PCM_SERVER_IMC_DRAM_DATA_WRITES);
    }
    return result;
}

uint64 ServerBW::getPMMReads()
{
    uint64 result = 0;
    for (auto & mmio : mmioRanges)
    {
        result += mmio->read64(PCM_SERVER_IMC_PMM_DATA_READS);
    }
    return result;
}

uint64 ServerBW::getPMMWrites()
{
    uint64 result = 0;
    for (auto & mmio : mmioRanges)
    {
        result += mmio->read64(PCM_SERVER_IMC_PMM_DATA_WRITES);
    }
    return result;
}

} // namespace pcm

```

`src/bw.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2012-2022, Intel Corporation
// written by Roman Dementiev
//

#pragma once

/*!     \file bw.h
        \brief Interfaces to access free-running bandwidth counters

*/

#include <memory>
#include <vector>
#include <array>
#include "mmio.h"

namespace pcm {

    class FreeRunningBWCounters
    {
    public:
        virtual uint64 getImcReads() { return 0; }
        virtual uint64 getImcWrites() { return 0; }
        virtual uint64 getGtRequests() { return 0; }
        virtual uint64 getIaRequests() { return 0; }
        virtual uint64 getIoRequests() { return 0; }
        virtual uint64 getPMMReads() { return 0; }
        virtual uint64 getPMMWrites() { return 0; }
        virtual ~FreeRunningBWCounters() {}
    };

    class TGLClientBW : public FreeRunningBWCounters
    {
        std::array<std::array<std::shared_ptr<MMIORange>, 2>, 2> mmioRange;
    public:
        TGLClientBW();

        uint64 getImcReads() override;
        uint64 getImcWrites() override;
    };

    class ADLClientBW : public FreeRunningBWCounters
    {
        std::shared_ptr<MMIORange> mmioRange;
    public:
        ADLClientBW();

        uint64 getImcReads() override;
        uint64 getImcWrites() override;
    };

    class ClientBW : public FreeRunningBWCounters
    {
        std::shared_ptr<MMIORange> mmioRange;
    public:
        ClientBW();

        uint64 getImcReads() override;
        uint64 getImcWrites() override;
        uint64 getGtRequests() override;
        uint64 getIaRequests() override;
        uint64 getIoRequests() override;
    };

std::vector<size_t> getServerMemBars(const uint32 numIMC, const uint32 root_segment_ubox0, const uint32 root_bus_ubox0);
size_t getServerSCFBar(const uint32 root_segment_ubox0, const uint32 root_bus_ubox0);

class ServerBW
{
    std::vector<std::shared_ptr<MMIORange> > mmioRanges;

    ServerBW();
public:
    ServerBW(const uint32 numIMC, const uint32 root_segment_ubox0, const uint32 root_bus_ubox0);

    uint64 getImcReads();
    uint64 getImcWrites();
    uint64 getPMMReads();
    uint64 getPMMWrites();
};

} // namespace pcm

```

`src/client/client.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Steven Briscoe

#include <cstdlib>
#include <iostream>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <errno.h>
#include <sstream>
#include <exception>
#include <stdexcept>
#include <grp.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <fcntl.h>

#include "../daemon/common.h"
#include "client.h"

namespace PCMDaemon {

	Client::Client()
	: pollIntervalMs_(0), shmIdLocation_(DEFAULT_SHM_ID_LOCATION), shmAttached_(false), lastUpdatedClientTsc_(0)
	{}

	void Client::setSharedMemoryIdLocation(const std::string& location)
	{
		if(shmAttached_)
		{
			throw std::runtime_error("Shared memory segment already attached. You must call this method before the .connect() method.");
		}
		shmIdLocation_ = location;
	}

	void Client::setPollInterval(int pollMs)
	{
		pollIntervalMs_ = pollMs;
	}

	void Client::connect()
	{
		setupSharedMemory();

		//Set last updated timestamp to avoid a detected change
		//when the client starts
		lastUpdatedClientTsc_ = sharedPCMState_->lastUpdateTscEnd;
	}

	PCMDaemon::SharedPCMState& Client::read()
	{
		if(pollIntervalMs_ <= 0)
		{
			throw std::runtime_error("The poll interval is not set or is negative.");
		}

		if(!shmAttached_)
		{
			throw std::runtime_error("Not attached to shared memory segment. Call .connect() method.");
		}

		while(true)
		{
			// Check client version matches daemon version
			if(strlen(sharedPCMState_->version) > 0 && strcmp(sharedPCMState_->version, VERSION) != 0)
			{
				std::cout << sharedPCMState_->lastUpdateTscEnd << " " << lastUpdatedClientTsc_ << "\n";
				std::stringstream ss;
				ss << "Out of date PCM daemon client. Client version: " << VERSION << " Daemon version: " << sharedPCMState_->version;

				throw std::runtime_error(ss.str());
			}

			if(countersHaveUpdated())
			{
				//There is new data
				lastUpdatedClientTsc_ = sharedPCMState_->lastUpdateTscEnd;

				return *sharedPCMState_;
			}
			else
			{
				//Nothing has changed since we last checked
				usleep(pollIntervalMs_ * 1000);
			}
		}
	}

	bool Client::countersHaveUpdated()
	{
		return lastUpdatedClientTsc_ != sharedPCMState_->lastUpdateTscEnd;
	}

	void Client::setupSharedMemory()
	{
		int sharedMemoryId;
		// SDL330: Use O_NOFOLLOW to reject symlinks
		int fd = open(shmIdLocation_.c_str(), O_RDONLY | O_NOFOLLOW);
		if (fd < 0 && errno == ELOOP) {
			std::cerr << "SDL330 ERROR: Symlink detected at " << shmIdLocation_ << "\n";
			exit(EXIT_FAILURE);
		}
		FILE *fp = (fd >= 0) ? fdopen(fd, "r") : NULL;
		if (!fp)
		{
			if (fd >= 0) close(fd);
			std::cerr << "Failed to open to shared memory key location: " << shmIdLocation_ << "\n";
			exit(EXIT_FAILURE);
		}
		const int maxCharsToRead = 11;
		char readBuffer[maxCharsToRead + 1];
		std::fill((char*)readBuffer, ((char*)readBuffer) + sizeof(readBuffer), 0);
		const auto nread = fread(&readBuffer, maxCharsToRead, 1, fp);
		if (nread == 0 && feof(fp) == 0)
		{
			fclose (fp);
			std::stringstream ss;
			ss << "fread failed for " << shmIdLocation_;
			throw std::runtime_error(ss.str());
		}
		fclose (fp);
		assert(nread <= maxCharsToRead);

		sharedMemoryId = atoi(readBuffer);

		sharedPCMState_ = (PCMDaemon::SharedPCMState*)shmat(sharedMemoryId, NULL, 0);
		if (sharedPCMState_ == (void *)-1)
		{
			std::stringstream ss;
			ss << "Failed to attach shared memory segment (errno=" << errno << ") " << strerror(errno);

			throw std::runtime_error(ss.str());
		}

		shmAttached_ = true;
	}

}

```

`src/client/client.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Steven Briscoe

#include <sys/types.h>
#include <string>
#include <grp.h>


#ifndef CLIENT_H_
#define CLIENT_H_

#include "../daemon/common.h"

namespace PCMDaemon {

	class Client {
	public:
		Client();
		void setSharedMemoryIdLocation(const std::string& location);
		void setPollInterval(int pollMs);
		void connect();
		PCMDaemon::SharedPCMState& read();
		bool countersHaveUpdated();
	private:
		void setupSharedMemory();

		int pollIntervalMs_;
		std::string shmIdLocation_;
		bool shmAttached_;
		PCMDaemon::SharedPCMState* sharedPCMState_ = nullptr;
		PCMDaemon::uint64 lastUpdatedClientTsc_;
	};

}


#endif /* CLIENT_H_ */

```

`src/client/main.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Steven Briscoe

//Test program for PCM Daemon client

#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <stdexcept>
#include "client.h"

void printTitle(std::string title)
{
    std::cout << std::setw(26) << std::left << title;
}

int main(int argc, char * argv[])
{
    if (argc < 2)
    {
        std::cerr << "Usage: " << argv[0] << " pollMs\n";
        return -1;
    }
    try {

    PCMDaemon::Client client;
    // client.setSharedMemoryIdLocation("/tmp/test-file");
    client.connect();
    client.setPollInterval(atoi(argv[1]));

    int coutPrecision = 2;

    while (true)
    {
        PCMDaemon::SharedPCMState& state = client.read();
        PCMDaemon::SharedPCMCounters& counters = state.pcm;

        std::cout << "\n----- Something changed -----\n\n";

        // 		Display internal metrics
        printTitle("Last updated TSC");
        std::cout << state.lastUpdateTscEnd << "\n";

        printTitle("Timestamp");
        std::cout << state.timestamp << "\n";

        printTitle("Cycles to get counters");
        std::cout << state.cyclesToGetPCMState << "\n";

        printTitle("Poll interval (ms)");
        std::cout << state.pollMs << "\n";

        std::cout << "\n\n";

        //		Display system counters
        printTitle("Num. of cores");
        std::cout << counters.system.numOfCores << "\n";

        printTitle("Num. of online cores");
        std::cout << counters.system.numOfOnlineCores << "\n";

        printTitle("Num. of sockets");
        std::cout << counters.system.numOfSockets << "\n";

        printTitle("Num. of online sockets");
        std::cout << counters.system.numOfOnlineSockets << "\n";

        printTitle("QPI/UPI links per socket");
        std::cout << counters.system.numOfQPILinksPerSocket << "\n";

        std::cout << "\n\n";

        //		Display core counters
        printTitle("Core ID");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].coreId << " ";
        }
        std::cout << "\n";

        printTitle("Socket ID");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].socketId << " ";
        }
        std::cout << "\n";

        printTitle("IPC");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].instructionsPerCycle << " ";
        }
        std::cout << "\n";

        printTitle("Cycles");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].cycles << " ";
        }
        std::cout << "\n";

        printTitle("Inst. Ret.");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].instructionsRetired << " ";
        }
        std::cout << "\n";

        printTitle("Exec usg.");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].execUsage << " ";
        }
        std::cout << "\n";

        printTitle("Rela. Freq.");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].relativeFrequency << " ";
        }
        std::cout << "\n";

        printTitle("Active Rela. Freq");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].activeRelativeFrequency << " ";
        }
        std::cout << "\n";

        printTitle("L3 C Miss");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].l3CacheMisses << " ";
        }
        std::cout << "\n";

        printTitle("L3 C Reference");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].l3CacheReference << " ";
        }
        std::cout << "\n";

        printTitle("L2 C Miss");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].l2CacheMisses << " ";
        }
        std::cout << "\n";

        printTitle("L3 Hit Ratio");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].l3CacheHitRatio << " ";
        }
        std::cout << "\n";

        printTitle("L2 Hit Ratio");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].l2CacheHitRatio << " ";
        }
        std::cout << "\n";

        printTitle("L3 C MPI");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].l3CacheMPI << " ";
        }
        std::cout << "\n";

        printTitle("L2 C MPI");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].l2CacheMPI << " ";
        }
        std::cout << "\n";

        printTitle("L3 Occu. Avail.");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].l3CacheOccupancyAvailable << " ";
        }
        std::cout << "\n";

        printTitle("L3 Occu.");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].l3CacheOccupancy << " ";
        }
        std::cout << "\n";

        printTitle("L. Mem. BW Avail.");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].localMemoryBWAvailable << " ";
        }
        std::cout << "\n";

        printTitle("L. Mem. BW");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].localMemoryBW << " ";
        }
        std::cout << "\n";

        printTitle("R. Mem. BW Avail.");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].remoteMemoryBWAvailable << " ";
        }
        std::cout << "\n";

        printTitle("R. Mem. BW");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].remoteMemoryBW << " ";
        }
        std::cout << "\n";

        printTitle("L. Mem. Accesses");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].localMemoryAccesses << " ";
        }
        std::cout << "\n";

        printTitle("R. Mem. Accesses");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].remoteMemoryAccesses << " ";
        }
        std::cout << "\n";

        printTitle("Thermal headroom");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineCores; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.core.cores[i].thermalHeadroom << " ";
        }
        std::cout << "\n";

        std::cout << "\n\n";

        //		Display memory counters

        printTitle("PMM Metrics Avail.");
        std::cout << std::setprecision(coutPrecision) << counters.memory.pmmMetricsAvailable << " ";
        std::cout << "\n";

        printTitle("DRAM Read p/Sock.");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineSockets; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.memory.sockets[i].read << " ";
        }
        std::cout << "\n";

        printTitle("DRAM Write p/Sock.");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineSockets; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.memory.sockets[i].write << " ";
        }
        std::cout << "\n";

        if (counters.memory.pmmMetricsAvailable)
        {
            printTitle("PMM Read p/Sock.");
            for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineSockets; ++i)
            {
                std::cout << std::setprecision(coutPrecision) << counters.memory.sockets[i].pmmRead << " ";
            }
            std::cout << "\n";

            printTitle("PMM Write p/Sock.");
            for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineSockets; ++i)
            {
                std::cout << std::setprecision(coutPrecision) << counters.memory.sockets[i].pmmWrite << " ";
            }
            std::cout << "\n";

            printTitle("PMM Memory Mode hit rate p/Sock. ");
            for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineSockets; ++i)
            {
                std::cout << std::setprecision(coutPrecision) << counters.memory.sockets[i].memoryModeHitRate << " ";
            }
            std::cout << "\n";
        }

        printTitle("Mem Total p/Sock.");
        for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineSockets; ++i)
        {
            std::cout << std::setprecision(coutPrecision) << counters.memory.sockets[i].total << " ";
        }
        std::cout << "\n";

        printTitle("DRAM Read Sys.");
        std::cout << std::setprecision(coutPrecision) << counters.memory.system.read << " ";
        std::cout << "\n";

        printTitle("DRAM Write Sys.");
        std::cout << std::setprecision(coutPrecision) << counters.memory.system.write << " ";
        std::cout << "\n";

        if (counters.memory.pmmMetricsAvailable)
        {
            printTitle("PMM Read Sys.");
            std::cout << std::setprecision(coutPrecision) << counters.memory.system.pmmRead << " ";
            std::cout << "\n";

            printTitle("PMM Write Sys.");
            std::cout << std::setprecision(coutPrecision) << counters.memory.system.pmmWrite << " ";
            std::cout << "\n";
        }

        printTitle("Mem Total Sys.");
        std::cout << std::setprecision(coutPrecision) << counters.memory.system.total << " ";
        std::cout << "\n";

        printTitle("Mem Energy Avail.");
        std::cout << std::setprecision(coutPrecision) << counters.memory.dramEnergyMetricsAvailable << " ";
        std::cout << "\n";

        if (counters.memory.dramEnergyMetricsAvailable)
        {
            printTitle("Mem Energy p/Sock");
            for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineSockets; ++i)
            {
                std::cout << std::setprecision(coutPrecision) << counters.memory.sockets[i].dramEnergy << " ";
            }
            std::cout << "\n";
        }

        std::cout << "\n\n";

        //		Display QPI counters
        printTitle("QPI/UPI in. Avail.");
        std::cout << std::setprecision(coutPrecision) << counters.qpi.incomingQPITrafficMetricsAvailable << " ";
        std::cout << "\n";

        if (counters.qpi.incomingQPITrafficMetricsAvailable)
        {
            printTitle("QPI/UPI No. of Links");
            std::cout << std::setprecision(coutPrecision) << counters.system.numOfQPILinksPerSocket << "\n";

            printTitle("QPI/UPI in. p/Sock");
            for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineSockets; ++i)
            {
                std::cout << std::setprecision(coutPrecision) << counters.qpi.incoming[i].total << " ";
            }
            std::cout << "\n";

            printTitle("QPI/UPI in. p/Link/Sock");
            for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineSockets; ++i)
            {
                std::cout << "Socket: " << i << " (bytes)\t\t";
                for (PCMDaemon::uint32 l = 0; l < counters.system.numOfQPILinksPerSocket; ++l)
                {
                    std::cout << std::setw(12) << std::left << std::setprecision(coutPrecision) << counters.qpi.incoming[i].links[l].bytes << " ";
                }
                std::cout << "\n";
                printTitle("");

                std::cout << "Socket: " << i << " (utilization)\t";
                for (PCMDaemon::uint32 l = 0; l < counters.system.numOfQPILinksPerSocket; ++l)
                {
                    std::cout << std::setw(12) << std::left << std::setprecision(coutPrecision) << counters.qpi.incoming[i].links[l].utilization << " ";
                }
                std::cout << "\n";
                printTitle("");
            }
            std::cout << "\n";

            printTitle("QPI/UPI in. Total");
            std::cout << std::setprecision(coutPrecision) << counters.qpi.incomingTotal << " ";
            std::cout << "\n\n";
        }

        printTitle("QPI/UPI out. Avail.");
        std::cout << std::setprecision(coutPrecision) << counters.qpi.outgoingQPITrafficMetricsAvailable << " ";
        std::cout << "\n";

        if (counters.qpi.outgoingQPITrafficMetricsAvailable)
        {
            printTitle("QPI/UPI No. of Links");
            std::cout << std::setprecision(coutPrecision) << counters.system.numOfQPILinksPerSocket << "\n";

            printTitle("QPI/UPI out. p/Sock");
            for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineSockets; ++i)
            {
                std::cout << std::setprecision(coutPrecision) << counters.qpi.outgoing[i].total << " ";
            }
            std::cout << "\n";

            printTitle("QPI/UPI out. p/Link/Sock");
            for (PCMDaemon::uint32 i = 0; i < counters.system.numOfOnlineSockets; ++i)
            {
                std::cout << "Socket: " << i << " (bytes)\t\t";
                for (PCMDaemon::uint32 l = 0; l < counters.system.numOfQPILinksPerSocket; ++l)
                {
                    std::cout << std::setw(12) << std::left << std::setprecision(coutPrecision) << counters.qpi.outgoing[i].links[l].bytes << " ";
                }
                std::cout << "\n";
                printTitle("");

                std::cout << "Socket: " << i << " (utilization)\t";
                for (PCMDaemon::uint32 l = 0; l < counters.system.numOfQPILinksPerSocket; ++l)
                {
                    std::cout << std::setw(12) << std::left << std::setprecision(coutPrecision) << counters.qpi.outgoing[i].links[l].utilization << " ";
                }
                std::cout << "\n";
                printTitle("");
            }
            std::cout << "\n";

            printTitle("QPI/UPI out. Total");
            std::cout << std::setprecision(coutPrecision) << counters.qpi.outgoingTotal << " ";
            std::cout << "\n";
        }
        std::cout << std::flush;
    }

    } catch (const std::runtime_error & e)
    {
        std::cerr << "PCM Error in client. Exception " << e.what() << "\n";
        return -1;
    }

    return 0;
}

```

`src/cpuasynchcounter.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
//
// asynchronous CPU conters
//
// contact: Thomas Willhalm

#ifndef CPUASYNCHCOUNTER_HEADER
#define CPUASYNCHCOUNTER_HEADER


/*!     \file cpuasynchcounter.h
        \brief Implementation of a POSIX thread that periodically saves the current state of counters and exposes them to other threads
*/

#include <pthread.h>
#include <stdlib.h>
#include "cpucounters.h"

#define DELAY 1 // in seconds

using namespace pcm;

void * UpdateCounters(void *);

class AsynchronCounterState {
    PCM * m;

    CoreCounterState * cstates1, * cstates2;
    SocketCounterState * skstates1, * skstates2;
    SystemCounterState sstate1, sstate2;

    pthread_t UpdateThread;
    pthread_mutex_t CounterMutex;

    friend void * UpdateCounters(void *);

    AsynchronCounterState(const AsynchronCounterState &) = delete;
    const AsynchronCounterState & operator = (const AsynchronCounterState &) = delete;

public:
    AsynchronCounterState()
    {
        m = PCM::getInstance();
        PCM::ErrorCode status = m->program();
        if (status != PCM::Success)
        {
            std::cerr << "\nCannot access CPU counters. Try to run 'pcm 1' to check the PMU access status.\n\n";
            exit(-1);
        }

        cstates1 = new  CoreCounterState[m->getNumCores()];
        cstates2 = new  CoreCounterState[m->getNumCores()];
        skstates1 = new SocketCounterState[m->getNumSockets()];
        skstates2 = new SocketCounterState[m->getNumSockets()];

        for (uint32 i = 0; i < m->getNumCores(); ++i) {
            cstates1[i] = getCoreCounterState(i);
            cstates2[i] = getCoreCounterState(i);
        }

        for (uint32 i = 0; i < m->getNumSockets(); ++i) {
            skstates1[i] = getSocketCounterState(i);
            skstates2[i] = getSocketCounterState(i);
        }

        pthread_mutex_init(&CounterMutex, NULL);
        pthread_create(&UpdateThread, NULL, UpdateCounters, this);
    }
    ~AsynchronCounterState()
    {
        pthread_cancel(UpdateThread);
        if (pthread_mutex_destroy(&CounterMutex) != 0) std::cerr << "pthread_mutex_destroy failed\n";
        try {
            m->cleanup();
        } catch (const std::runtime_error & e)
        {
            std::cerr << "PCM Error in ~AsynchronCounterState(). Exception " << e.what() << "\n";
        }
        deleteAndNullifyArray(cstates1);
        deleteAndNullifyArray(cstates2);
        deleteAndNullifyArray(skstates1);
        deleteAndNullifyArray(skstates2);
    }

    uint32 getNumCores()
    { return m->getNumCores(); }

    uint32 getNumSockets()
    { return m->getNumSockets(); }

    uint32 getQPILinksPerSocket()
    {
        return m->getQPILinksPerSocket();
    }

    uint32 getSocketId(uint32 c)
    {
        return m->getSocketId(c);
    }

    const char * getXpi() {
        return m->xPI();
    }

    template <typename T, T func(CoreCounterState const &)>
    T get(uint32 core)
    {
        pthread_mutex_lock(&CounterMutex);
        T value = func(cstates2[core]);
        pthread_mutex_unlock(&CounterMutex);
        return value;
    }
    template <typename T, T func(CoreCounterState const &, CoreCounterState const &)>
    T get(uint32 core)
    {
        pthread_mutex_lock(&CounterMutex);
        T value = func(cstates1[core], cstates2[core]);
        pthread_mutex_unlock(&CounterMutex);
        return value;
    }

    template <typename T, T func(int, CoreCounterState const &, CoreCounterState const &)>
    T get(int param, uint32 core)
    {
        pthread_mutex_lock(&CounterMutex);
        T value = func(param, cstates1[core], cstates2[core]);
        pthread_mutex_unlock(&CounterMutex);
        return value;
    }

    template <typename T, T func(SocketCounterState const &)>
    T getSocket(uint32 socket)
    {
        pthread_mutex_lock(&CounterMutex);
        T value = func(skstates2[socket]);
        pthread_mutex_unlock(&CounterMutex);
        return value;
    }

    template <typename T, T func(SocketCounterState const &, SocketCounterState const &)>
    T getSocket(uint32 socket)
    {
        pthread_mutex_lock(&CounterMutex);
        T value = func(skstates1[socket], skstates2[socket]);
        pthread_mutex_unlock(&CounterMutex);
        return value;
    }

    template <typename T, T func(int, SocketCounterState const &, SocketCounterState const &)>
    T getSocket(int param, uint32 socket)
    {
        pthread_mutex_lock(&CounterMutex);
        T value = func(param, skstates1[socket], skstates2[socket]);
        pthread_mutex_unlock(&CounterMutex);
        return value;
    }

    template <typename T, T func(uint32, uint32, SystemCounterState const &, SystemCounterState const &)>
    T getSocket(uint32 socket, uint32 param)
    {
        pthread_mutex_lock(&CounterMutex);
        T value = func(socket, param, sstate1, sstate2);
        pthread_mutex_unlock(&CounterMutex);
        return value;
    }

    template <typename T, T func(SystemCounterState const &, SystemCounterState const &)>
    T getSystem()
    {
        pthread_mutex_lock(&CounterMutex);
        T value = func(sstate1, sstate2);
        pthread_mutex_unlock(&CounterMutex);
        return value;
    }

    template <typename T, T func(int, SystemCounterState const &, SystemCounterState const &)>
    T getSystem(int param)
    {
        pthread_mutex_lock(&CounterMutex);
        T value = func(param, sstate1, sstate2);
        pthread_mutex_unlock(&CounterMutex);
        return value;
    }
};

void * UpdateCounters(void * state)
{
    AsynchronCounterState * s = (AsynchronCounterState *)state;

    while (true) {
        if (pthread_mutex_lock(&(s->CounterMutex)) != 0) std::cerr << "pthread_mutex_lock failed\n";
        for (uint32 core = 0; core < s->m->getNumCores(); ++core) {
            s->cstates1[core] = std::move(s->cstates2[core]);
            s->cstates2[core] = s->m->getCoreCounterState(core);
        }

        for (uint32 socket = 0; socket < s->m->getNumSockets(); ++socket) {
            s->skstates1[socket] = std::move(s->skstates2[socket]);
            s->skstates2[socket] = s->m->getSocketCounterState(socket);
        }

        s->sstate1 = std::move(s->sstate2);
        s->sstate2 = s->m->getSystemCounterState();

        if (pthread_mutex_unlock(&(s->CounterMutex)) != 0) std::cerr << "pthread_mutex_unlock failed\n";
        sleep(1);
    }
    return NULL;
}

#endif

```

`src/cpucounters.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2024, Intel Corporation
// written by Roman Dementiev
//            Otto Bruggeman
//            Thomas Willhalm
//            Pat Fay
//            Austen Ott
//            Jim Harris (FreeBSD)
//            and many others

/*!     \file cpucounters.cpp
        \brief The bulk of PCM implementation
  */

//#define PCM_TEST_FALLBACK_TO_ATOM

#include <stdio.h>
#include <assert.h>
#ifdef PCM_EXPORTS
// pcm-lib.h includes cpucounters.h
#include "windows\pcm-lib.h"
#else
#include "cpucounters.h"
#endif
#include "msr.h"
#include "pci.h"
#include "types.h"
#include "utils.h"
#include "topology.h"

#if defined (__FreeBSD__) || defined(__DragonFly__)
#include <sys/param.h>
#include <sys/module.h>
#include <sys/types.h>
#include <sys/sysctl.h>
#include <sys/sem.h>
#include <sys/ioccom.h>
#include <sys/cpuctl.h>
#include <machine/cpufunc.h>
#endif

#ifdef _MSC_VER
#include <intrin.h>
#include <windows.h>
#include <comdef.h>
#include <tchar.h>
#include "winring0/OlsApiInit.h"
#include "windows/windriver.h"
#else
#include <pthread.h>
#if defined(__FreeBSD__) || (defined(__DragonFly__) && __DragonFly_version >= 400707)
#include <pthread_np.h>
#include <sys/_cpuset.h>
#include <sys/cpuset.h>
#endif
#include <errno.h>
#include <sys/time.h>
#ifdef __linux__
#include <sys/mman.h>
#include <dirent.h>
#include <sys/resource.h>
#endif
#endif

#include <string.h>
#include <limits>
#include <map>
#include <unordered_map>
#include <algorithm>
#include <thread>
#include <future>
#include <functional>
#include <queue>
#include <condition_variable>
#include <mutex>
#include <atomic>
#include <system_error>

#ifdef __APPLE__
#include <sys/types.h>
#include <sys/sysctl.h>
#include <sys/sem.h>
#endif

namespace pcm {

#ifdef __APPLE__
// convertUnknownToInt is used in the safe sysctl call to convert an unknown size to an int
int convertUnknownToInt(size_t size, char* value);
#endif

#ifdef _MSC_VER

void PCM_API restrictDriverAccess(LPCTSTR path)
{
    restrictDriverAccessNative(path);
}

HMODULE hOpenLibSys = NULL;

#ifndef NO_WINRING
bool PCM::initWinRing0Lib()
{
    const BOOL result = InitOpenLibSys(&hOpenLibSys);

    if (result == FALSE)
    {
        DeinitOpenLibSys(&hOpenLibSys);
        hOpenLibSys = NULL;
        return false;
    }

    BYTE major, minor, revision, release;
    GetDriverVersion(&major, &minor, &revision, &release);
    TCHAR buffer[128];
    _stprintf_s(buffer, 128, TEXT("\\\\.\\WinRing0_%d_%d_%d"),(int)major,(int)minor, (int)revision);
    restrictDriverAccess(buffer);

    return true;
}
#endif // NO_WINRING

#endif


#if defined(__FreeBSD__)
#define cpu_set_t cpuset_t
#endif

PCM * PCM::instance = NULL;
std::atomic<bool> PCM::quietMode{false};

/*
static int bitCount(uint64 n)
{
    int count = 0;
    while (n)
    {
        count += static_cast<int>(n & 0x00000001);
        n >>= static_cast<uint64>(1);
    }
    return count;
}
*/

std::mutex instanceCreationMutex;

PCM * PCM::getInstance()
{
    // lock-free read
    // cppcheck-suppress identicalConditionAfterEarlyExit
    if (instance) return instance;

    std::unique_lock<std::mutex> _(instanceCreationMutex);
    // cppcheck-suppress identicalConditionAfterEarlyExit
    if (instance) return instance;

    return instance = new PCM();
}

uint64 PCM::extractCoreGenCounterValue(uint64 val)
{
    if (canUsePerf) return val;

    if(core_gen_counter_width)
        return extract_bits(val, 0, core_gen_counter_width-1);

    return val;
}

uint64 PCM::extractCoreFixedCounterValue(uint64 val)
{
    if (canUsePerf) return val;

    if(core_fixed_counter_width)
        return extract_bits(val, 0, core_fixed_counter_width-1);

    return val;
}

uint64 PCM::extractUncoreGenCounterValue(uint64 val)
{
    if(uncore_gen_counter_width)
        return extract_bits(val, 0, uncore_gen_counter_width-1);

    return val;
}

uint64 PCM::extractUncoreFixedCounterValue(uint64 val)
{
    if(uncore_fixed_counter_width)
        return extract_bits(val, 0, uncore_fixed_counter_width-1);

    return val;
}

uint64 PCM::extractQOSMonitoring(uint64 val)
{
    //Check if any of the error bit(63) or Unavailable bit(62) of the IA32_QM_CTR MSR are 1
    if(val & (3ULL<<62))
    {
        // invalid reading
        return static_cast<uint64>(PCM_INVALID_QOS_MONITORING_DATA);
    }

    // valid reading
    return extract_bits(val,0,61);
}
int32 extractThermalHeadroom(uint64 val)
{
    if(val & (1ULL<<31ULL))
    {  // valid reading
       return static_cast<int32>(extract_bits(val, 16, 22));
    }

    // invalid reading
    return static_cast<int32>(PCM_INVALID_THERMAL_HEADROOM);
}


uint64 get_frequency_from_cpuid();



#if defined(__FreeBSD__) || defined(__DragonFly__)
void pcm_cpuid_bsd(int leaf, PCM_CPUID_INFO& info, int core)
{
    cpuctl_cpuid_args_t cpuid_args_freebsd;
    char cpuctl_name[64];

    snprintf(cpuctl_name, 64, "/dev/cpuctl%d", core);
    auto fd = ::open(cpuctl_name, O_RDWR);

    cpuid_args_freebsd.level = leaf;

    ::ioctl(fd, CPUCTL_CPUID, &cpuid_args_freebsd);
    for (int i = 0; i < 4; ++i)
    {
        info.array[i] = cpuid_args_freebsd.data[i];
    }
    ::close(fd);
}
#endif

#ifdef __linux__
bool isNMIWatchdogEnabled(const bool silent);
bool keepNMIWatchdogEnabled();
#endif

void PCM::readCoreCounterConfig(const bool complainAboutMSR)
{
    if (max_cpuid >= 0xa)
    {
        // get counter related info
        PCM_CPUID_INFO cpuinfo;
        pcm_cpuid(0xa, cpuinfo);
        perfmon_version = extract_bits_32(cpuinfo.array[0], 0, 7);
        core_gen_counter_num_max = extract_bits_32(cpuinfo.array[0], 8, 15);
        core_gen_counter_width = extract_bits_32(cpuinfo.array[0], 16, 23);
        if (perfmon_version > 1)
        {
            core_fixed_counter_num_max = extract_bits_32(cpuinfo.array[3], 0, 4);
            core_fixed_counter_width = extract_bits_32(cpuinfo.array[3], 5, 12);
        }
        else if (1 == perfmon_version)
        {
            core_fixed_counter_num_max = 3;
            core_fixed_counter_width = core_gen_counter_width;
        }
        if (isForceRTMAbortModeAvailable())
        {
            uint64 TSXForceAbort = 0;
            if (MSR.empty())
            {
                if (complainAboutMSR)
                {
                    std::cerr << "PCM Error: Can't determine the number of available counters reliably because of no access to MSR.\n";
                }
            }
            else if (MSR[0]->read(MSR_TSX_FORCE_ABORT, &TSXForceAbort) == sizeof(uint64))
            {
                TSXForceAbort &= 1;
                /*
                    TSXForceAbort is 0 (default mode) => the number of useful gen counters is 3
                    TSXForceAbort is 1                => the number of gen counters is unchanged
                */
                if (TSXForceAbort == 0)
                {
                    core_gen_counter_num_max = 3;
                }
            }
            else
            {
                std::cerr << "PCM Error: Can't determine the number of available counters reliably because reading MSR_TSX_FORCE_ABORT failed.\n";
            }
        }
#if defined(__linux__)
        const auto env = std::getenv("PCM_NO_AWS_WORKAROUND");
        auto aws_workaround = true;
        if (env != nullptr && std::string(env) == std::string("1"))
        {
            aws_workaround = false;
        }
        if (aws_workaround == true && vm == true && linux_arch_perfmon == true && core_gen_counter_num_max > 3)
        {
            core_gen_counter_num_max = 3;
            if (!quietMode)
            {
                std::cerr << "INFO: Reducing the number of programmable counters to 3 to workaround the fixed cycle counter virtualization issue on AWS.\n";
                std::cerr << "      You can disable the workaround by setting PCM_NO_AWS_WORKAROUND=1 environment variable\n";
            }
        }
        if (isNMIWatchdogEnabled(true) && keepNMIWatchdogEnabled())
        {
            --core_gen_counter_num_max;
            if (!quietMode)
            {
                std::cerr << "INFO: Reducing the number of programmable counters to " << core_gen_counter_num_max  << " because NMI watchdog is enabled.\n";
            }
        }
#endif
    }
}

bool PCM::isFixedCounterSupported(unsigned c)
{
    if (max_cpuid >= 0xa)
    {
        PCM_CPUID_INFO cpuinfo;
        pcm_cpuid(0xa, cpuinfo);
        return extract_bits_32(cpuinfo.reg.ecx, c, c) || (extract_bits_32(cpuinfo.reg.edx, 4, 0) > c);
    }
    return false;
}

bool PCM::isHWTMAL1Supported() const
{
    #ifdef PCM_USE_PERF
    if (perfEventTaskHandle.empty() == false)
    {
       return false; // per PID/task perf collection does not support HW TMA L1
    }
    #endif
    static int supported = -1;
    if (supported < 0)
    {
        supported = 0;
        PCM_CPUID_INFO cpuinfo;
        pcm_cpuid(1, cpuinfo);
        if (extract_bits_32(cpuinfo.reg.ecx, 15, 15) && MSR.size())
        {
            uint64 perf_cap;
            if (MSR[0]->read(MSR_PERF_CAPABILITIES, &perf_cap) == sizeof(uint64))
            {
                supported = (int)extract_bits(perf_cap, 15, 15);
            }
        }
        if (hybrid)
        {
            supported = 0;
        }
    }
    return supported > 0;
}

void PCM::readCPUMicrocodeLevel()
{
    if (MSR.empty()) return;
    const int32 ref_core = socketRefCore[0];
    TemporalThreadAffinity affinity(ref_core);
    if (affinity.supported() && isCoreOnline(ref_core))
    {   // see "Update Signature and Verification" and "Determining the Signature"
        // sections in Intel SDM how to read ucode level
        if (MSR[ref_core]->write(MSR_IA32_BIOS_SIGN_ID, 0) == sizeof(uint64))
        {
            PCM_CPUID_INFO cpuinfo;
            pcm_cpuid(1, cpuinfo); // cpuid instructions updates MSR_IA32_BIOS_SIGN_ID
            uint64 result = 0;
            if (MSR[ref_core]->read(MSR_IA32_BIOS_SIGN_ID, &result) == sizeof(uint64))
            {
                cpu_microcode_level = result >> 32;
            }
        }
    }
}

int32 PCM::getMaxCustomCoreEvents()
{
    return core_gen_counter_num_max;
}

int PCM::getCPUFamilyModelFromCPUID()
{
    static int result = -1;
    if (result < 0)
    {
        PCM_CPUID_INFO cpuinfo;
        pcm_cpuid(1, cpuinfo);
        // follow https://www.felixcloutier.com/x86/cpuid#fig-3-6
        unsigned int Family_ID          = (cpuinfo.array[0] >> 8) & 0xF;
        unsigned int Extended_Family_ID = (cpuinfo.array[0] >> 20) & 0xFF;
        unsigned int Model_ID           = (cpuinfo.array[0] >> 4) & 0xF;
        unsigned int Extended_Model_ID  = (cpuinfo.array[0] >> 16) & 0xF;
        const auto cpu_family_ = (Family_ID != 0x0F) ? Family_ID : (Extended_Family_ID + Family_ID);
        const auto cpu_model_ = (Family_ID == 0x06 || Family_ID == 0x0F) ? (Model_ID + (Extended_Model_ID << 4)) : Model_ID;

        result = PCM_CPU_FAMILY_MODEL(cpu_family_, cpu_model_);
    }
    return result;
}

bool PCM::detectModel()
{
    char buffer[1024];
    union {
        char cbuf[16];
        int  ibuf[16 / sizeof(int)];
    } buf;
    PCM_CPUID_INFO cpuinfo;
    pcm_cpuid(0, cpuinfo);
    std::fill(buffer, buffer + 1024, 0);
    std::fill(buf.cbuf, buf.cbuf + 16, 0);
    buf.ibuf[0] = cpuinfo.array[1];
    buf.ibuf[1] = cpuinfo.array[3];
    buf.ibuf[2] = cpuinfo.array[2];
    if (strncmp(buf.cbuf, "GenuineIntel", 4 * 3) != 0)
    {
        std::cerr << getUnsupportedMessage() << "\n";
        return false;
    }
    max_cpuid = cpuinfo.array[0];

    pcm_cpuid(1, cpuinfo);

    DBG(2 , "cpuinfo.array[0]: 0x" , std::hex , cpuinfo.array[0] , std::dec);
    cpu_family_model = getCPUFamilyModelFromCPUID();
    cpu_family = (cpu_family_model >> 8) & 0xff;
    cpu_model_private = cpu_family_model & 0xff;
    cpu_stepping = cpuinfo.array[0] & 0x0f;

    if (cpuinfo.reg.ecx & (1UL << 31UL)) {
        vm = true;
        if (!quietMode)
        {
            std::cerr << "Detected a hypervisor/virtualization technology. Some metrics might not be available due to configuration or availability of virtual hardware features.\n";
        }
    }

    readCoreCounterConfig();

    pcm_cpuid(7, 0, cpuinfo);

    if (!quietMode)
    {
        std::cerr << "\n=====  Processor information  =====\n";
    }

#ifdef __linux__
    auto checkLinuxCpuinfoFlag = [](const std::string& flag) -> bool
    {
        std::ifstream linuxCpuinfo("/proc/cpuinfo");
        if (linuxCpuinfo.is_open())
        {
            std::string line;
            while (std::getline(linuxCpuinfo, line))
            {
                auto tokens = split(line, ':');
                if (tokens.size() >= 2 && tokens[0].find("flags") == 0)
                {
                    for (const auto & curFlag : split(tokens[1], ' '))
                    {
                        if (flag == curFlag)
                        {
                            return true;
                        }
                    }
                }
            }
            linuxCpuinfo.close();
        }
        return false;
    };
    linux_arch_perfmon = checkLinuxCpuinfoFlag("arch_perfmon");
    if (!quietMode)
    {
        std::cerr << "Linux arch_perfmon flag  : " << (linux_arch_perfmon ? "yes" : "no") << "\n";
    }
    if (vm == true && linux_arch_perfmon == false)
    {
        std::cerr << "ERROR: vPMU is not enabled in the hypervisor. Please see details in https://software.intel.com/content/www/us/en/develop/documentation/vtune-help/top/set-up-analysis-target/on-virtual-machine.html \n";
        std::cerr << "       you can force-continue by setting PCM_IGNORE_ARCH_PERFMON=1 environment variable.\n";
        auto env = std::getenv("PCM_IGNORE_ARCH_PERFMON");
        auto ignore_arch_perfmon = false;
        if (env != nullptr && std::string(env) == std::string("1"))
        {
            ignore_arch_perfmon = true;
        }
        if (!ignore_arch_perfmon)
        {
            return false;
        }
    }
#endif
    hybrid = (cpuinfo.reg.edx & (1 << 15)) ? true : false;
    if (!quietMode)
    {
        std::cerr << "Hybrid processor         : " << (hybrid ? "yes" : "no") << "\n";
        std::cerr << "IBRS and IBPB supported  : " << ((cpuinfo.reg.edx & (1 << 26)) ? "yes" : "no") << "\n";
        std::cerr << "STIBP supported          : " << ((cpuinfo.reg.edx & (1 << 27)) ? "yes" : "no") << "\n";
        std::cerr << "Spec arch caps supported : " << ((cpuinfo.reg.edx & (1 << 29)) ? "yes" : "no") << "\n";
        std::cerr << "Max CPUID level          : " << max_cpuid << "\n";
        std::cerr << "CPU family               : " << cpu_family << "\n";
        std::cerr << "CPU model number         : " << cpu_model_private << "\n";
    }

    return true;
}

bool PCM::isRDTDisabled() const
{
    static int flag = -1;
    if (flag < 0)
    {
        // flag not yet initialized
        const char * varname = "PCM_NO_RDT";
        char* env = nullptr;
#ifdef _MSC_VER
        _dupenv_s(&env, NULL, varname);
#else
        env = std::getenv(varname);
#endif
        if (env != nullptr && std::string(env) == std::string("1"))
        {
            if (!quietMode)
            {
                std::cout << "Disabling RDT usage because PCM_NO_RDT=1 environment variable is set.\n";
            }
            flag = 1;
        }
        else
        {
            flag = 0;
        }
#ifdef _MSC_VER
        freeAndNullify(env);
#endif
    }
    return flag > 0;
}

bool PCM::QOSMetricAvailable() const
{
    if (isRDTDisabled()) return false;
#ifndef __linux__
    if (isSecureBoot()) return false;
#endif
    PCM_CPUID_INFO cpuinfo;
    pcm_cpuid(0x7,0,cpuinfo);
    return (cpuinfo.reg.ebx & (1<<12))?true:false;
}

bool PCM::L3QOSMetricAvailable() const
{
    if (isRDTDisabled()) return false;
#ifndef __linux__
    if (isSecureBoot()) return false;
#endif
    PCM_CPUID_INFO cpuinfo;
    pcm_cpuid(0xf,0,cpuinfo);
    return (cpuinfo.reg.edx & (1<<1))?true:false;
}

bool PCM::L3CacheOccupancyMetricAvailable() const
{
    PCM_CPUID_INFO cpuinfo;
    if (!(QOSMetricAvailable() && L3QOSMetricAvailable()))
        return false;
    pcm_cpuid(0xf,0x1,cpuinfo);
    return (cpuinfo.reg.edx & 1)?true:false;
}

bool isMBMEnforced()
{
    static int flag = -1;
    if (flag < 0)
    {
        // flag not yet initialized
        flag = pcm::safe_getenv("PCM_ENFORCE_MBM") == std::string("1") ? 1 : 0;
    }
    return flag > 0;
}

bool PCM::CoreLocalMemoryBWMetricAvailable() const
{
    if (isMBMEnforced() == false && cpu_family_model == SKX && cpu_stepping < 5) return false; // SKZ4 errata
    PCM_CPUID_INFO cpuinfo;
    if (!(QOSMetricAvailable() && L3QOSMetricAvailable()))
            return false;
    pcm_cpuid(0xf,0x1,cpuinfo);
    return (cpuinfo.reg.edx & 2)?true:false;
}

bool PCM::CoreRemoteMemoryBWMetricAvailable() const
{
    if (isMBMEnforced() == false && cpu_family_model == SKX && cpu_stepping < 5) return false; // SKZ4 errata
    PCM_CPUID_INFO cpuinfo;
    if (!(QOSMetricAvailable() && L3QOSMetricAvailable()))
        return false;
    pcm_cpuid(0xf, 0x1, cpuinfo);
    return (cpuinfo.reg.edx & 4) ? true : false;
}

unsigned PCM::getMaxRMID() const
{
    unsigned maxRMID = 0;
    PCM_CPUID_INFO cpuinfo;
    pcm_cpuid(0xf,0,cpuinfo);
    maxRMID = (unsigned)cpuinfo.reg.ebx + 1;
    return maxRMID;
}

void PCM::initRDT()
{
    if (!(QOSMetricAvailable() && L3QOSMetricAvailable()))
        return;
#ifdef __linux__
    auto env = std::getenv("PCM_USE_RESCTRL");
    if (env != nullptr && std::string(env) == std::string("1"))
    {
        if (!quietMode)
        {
            std::cerr << "INFO: using Linux resctrl driver for RDT metrics (L3OCC, LMB, RMB) because environment variable PCM_USE_RESCTRL=1\n";
        }
        resctrl.init();
        useResctrl = true;
        return;
    }
    if (resctrl.isMounted())
    {
        if (!quietMode)
        {
            std::cerr << "INFO: using Linux resctrl driver for RDT metrics (L3OCC, LMB, RMB) because resctrl driver is mounted.\n";
        }
        resctrl.init();
        useResctrl = true;
        return;
    }
    if (isSecureBoot())
    {
        if (!quietMode)
        {
            std::cerr << "INFO: using Linux resctrl driver for RDT metrics (L3OCC, LMB, RMB) because Secure Boot mode is enabled.\n";
        }
        resctrl.init();
        useResctrl = true;
        return;
    }
#endif
    if (!quietMode)
    {
        std::cerr << "Initializing RMIDs" << std::endl;
    }
    unsigned maxRMID;
    /* Calculate maximum number of RMID supported by socket */
    maxRMID = getMaxRMID();
    DBG(2, "Maximum RMIDs per socket in the system : " , maxRMID );
    std::vector<uint32> rmid(num_sockets);
    for(int32 i = 0; i < num_sockets; i ++)
            rmid[i] = maxRMID - 1;

    /* Associate each core with 1 RMID */
    for(int32 core = 0; core < num_cores; core ++ )
    {
        if(!isCoreOnline(core)) continue;

        uint64 msr_pqr_assoc = 0 ;
        uint64 msr_qm_evtsel = 0 ;
                MSR[core]->lock();
        //Read 0xC8F MSR for each core
        MSR[core]->read(IA32_PQR_ASSOC, &msr_pqr_assoc);
        DBG(3, "initRMID reading IA32_PQR_ASSOC 0x" , std::hex , msr_pqr_assoc , std::dec);

        DBG(3, "Socket Id : " , topology[core].socket_id);
        msr_pqr_assoc &= 0xffffffff00000000ULL;
        msr_pqr_assoc |= (uint64)(rmid[topology[core].socket_id] & ((1ULL<<10)-1ULL));
        DBG(3, "initRMID writing IA32_PQR_ASSOC 0x" , std::hex , msr_pqr_assoc , std::dec);
        //Write 0xC8F MSR with new RMID for each core
        MSR[core]->write(IA32_PQR_ASSOC,msr_pqr_assoc);

        msr_qm_evtsel = static_cast<uint64>(rmid[topology[core].socket_id] & ((1ULL<<10)-1ULL));
        msr_qm_evtsel <<= 32;
        //Write 0xC8D MSR with new RMID for each core
        DBG(3, "initRMID writing IA32_QM_EVTSEL 0x" , std::hex , msr_qm_evtsel , std::dec);
        MSR[core]->write(IA32_QM_EVTSEL,msr_qm_evtsel);
                MSR[core]->unlock();

        /* Initializing the memory bandwidth counters */
        if (CoreLocalMemoryBWMetricAvailable())
        {
            memory_bw_local.push_back(std::make_shared<CounterWidthExtender>(new CounterWidthExtender::MBLCounter(MSR[core]), 24, 1000));
            if (CoreRemoteMemoryBWMetricAvailable())
            {
                memory_bw_total.push_back(std::make_shared<CounterWidthExtender>(new CounterWidthExtender::MBTCounter(MSR[core]), 24, 1000));
            }
        }
        rmid[topology[core].socket_id] --;
    }
    /* Get The scaling factor by running CPUID.0xF.0x1 instruction */
    L3ScalingFactor = getL3ScalingFactor();
}

void PCM::initQOSevent(const uint64 event, const int32 core)
{
   if(!isCoreOnline(core)) return;
   uint64 msr_qm_evtsel = 0 ;
   //Write 0xC8D MSR with the event id
   MSR[core]->read(IA32_QM_EVTSEL, &msr_qm_evtsel);
   DBG(3, "initQOSevent reading IA32_QM_EVTSEL 0x" , std::hex , msr_qm_evtsel , std::dec);
   msr_qm_evtsel &= 0xfffffffffffffff0ULL;
   msr_qm_evtsel |= event & ((1ULL<<8)-1ULL);
   DBG(3, "initQOSevent writing IA32_QM_EVTSEL 0x" , std::hex , msr_qm_evtsel , std::dec);
   MSR[core]->write(IA32_QM_EVTSEL,msr_qm_evtsel);
}


void PCM::initCStateSupportTables()
{
#define PCM_PARAM_PROTECT(...) __VA_ARGS__
#define PCM_CSTATE_ARRAY(array_ , val ) \
    { \
        static uint64 tmp[] = val; \
        PCM_COMPILE_ASSERT(sizeof(tmp) / sizeof(uint64) == (static_cast<int>(MAX_C_STATE)+1)); \
        array_ = tmp; \
        break; \
    }

    // fill package C state array
    switch(cpu_family_model)
    {
        case ATOM:
        case ATOM_2:
        case CENTERTON:
        case AVOTON:
        case BAYTRAIL:
        case CHERRYTRAIL:
        case APOLLO_LAKE:
        case GEMINI_LAKE:
        case DENVERTON:
        case ADL:
        case RPL:
        case MTL:
        case LNL:
        case ARL:
        case PTL:
        case SNOWRIDGE:
        case ELKHART_LAKE:
        case JASPER_LAKE:
            PCM_CSTATE_ARRAY(pkgCStateMsr, PCM_PARAM_PROTECT({0, 0, 0x3F8, 0, 0x3F9, 0, 0x3FA, 0, 0, 0, 0 }) );
        case NEHALEM_EP:
        case NEHALEM:
        case CLARKDALE:
        case WESTMERE_EP:
        case NEHALEM_EX:
        case WESTMERE_EX:
            PCM_CSTATE_ARRAY(pkgCStateMsr, PCM_PARAM_PROTECT({0, 0, 0, 0x3F8, 0, 0, 0x3F9, 0x3FA, 0, 0, 0}) );
        case SANDY_BRIDGE:
        case JAKETOWN:
        case IVY_BRIDGE:
        case IVYTOWN:
            PCM_CSTATE_ARRAY(pkgCStateMsr, PCM_PARAM_PROTECT({0, 0, 0x60D, 0x3F8, 0, 0, 0x3F9, 0x3FA, 0, 0, 0}) );
        case HASWELL:
        case HASWELL_2:
        case HASWELLX:
        case BDX_DE:
        case BDX:
        case KNL:
            PCM_CSTATE_ARRAY(pkgCStateMsr, PCM_PARAM_PROTECT({0, 0, 0x60D, 0x3F8, 0, 0, 0x3F9,  0x3FA, 0, 0, 0}) );
        case SKX:
        case ICX:
        case SPR:
        case EMR:
        case GNR:
        case GNR_D:
        case GRR:
        case SRF:
            PCM_CSTATE_ARRAY(pkgCStateMsr, PCM_PARAM_PROTECT({0, 0, 0x60D, 0, 0, 0, 0x3F9, 0, 0, 0, 0}) );
        case HASWELL_ULT:
        case BROADWELL:
        PCM_SKL_PATH_CASES
        case BROADWELL_XEON_E3:
            PCM_CSTATE_ARRAY(pkgCStateMsr, PCM_PARAM_PROTECT({0, 0, 0x60D, 0x3F8, 0, 0, 0x3F9, 0x3FA, 0x630, 0x631, 0x632}) );

        default:
            std::cerr << "PCM error: package C-states support array is not initialized. Package C-states metrics will not be shown.\n";
            PCM_CSTATE_ARRAY(pkgCStateMsr, PCM_PARAM_PROTECT({ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }) );
    };

    // fill core C state array
    switch(cpu_family_model)
    {
        case ATOM:
        case ATOM_2:
        case CENTERTON:
            PCM_CSTATE_ARRAY(coreCStateMsr, PCM_PARAM_PROTECT({ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }) );
        case NEHALEM_EP:
        case NEHALEM:
        case CLARKDALE:
        case WESTMERE_EP:
        case NEHALEM_EX:
        case WESTMERE_EX:
            PCM_CSTATE_ARRAY(coreCStateMsr, PCM_PARAM_PROTECT({0, 0, 0, 0x3FC, 0, 0, 0x3FD, 0, 0, 0, 0}) );
        case SANDY_BRIDGE:
        case JAKETOWN:
        case IVY_BRIDGE:
        case IVYTOWN:
        case HASWELL:
        case HASWELL_2:
        case HASWELL_ULT:
        case HASWELLX:
        case BDX_DE:
        case BDX:
        case BROADWELL:
        case BROADWELL_XEON_E3:
        case BAYTRAIL:
        case AVOTON:
        case CHERRYTRAIL:
        case APOLLO_LAKE:
        case GEMINI_LAKE:
        case DENVERTON:
        PCM_SKL_PATH_CASES
        case ADL:
        case RPL:
        case MTL:
        case LNL:
        case ARL:
        case PTL:
        case SNOWRIDGE:
        case ELKHART_LAKE:
        case JASPER_LAKE:
        case ICX:
        case SPR:
        case EMR:
        case GNR:
        case GNR_D:
        case GRR:
        case SRF:
            PCM_CSTATE_ARRAY(coreCStateMsr, PCM_PARAM_PROTECT({0, 0, 0, 0x3FC, 0, 0, 0x3FD, 0x3FE, 0, 0, 0}) );
        case KNL:
            PCM_CSTATE_ARRAY(coreCStateMsr, PCM_PARAM_PROTECT({0, 0, 0, 0, 0, 0, 0x3FF, 0, 0, 0, 0}) );
        case SKX:
            PCM_CSTATE_ARRAY(coreCStateMsr, PCM_PARAM_PROTECT({0, 0, 0, 0, 0, 0, 0x3FD, 0, 0, 0, 0}) );
        default:
            std::cerr << "PCM error: core C-states support array is not initialized. Core C-states metrics will not be shown.\n";
            PCM_CSTATE_ARRAY(coreCStateMsr, PCM_PARAM_PROTECT({ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }) );
    };
}


#ifdef __linux__
constexpr auto perfSlotsPath = "/sys/bus/event_source/devices/cpu/events/slots";
constexpr auto perfBadSpecPath = "/sys/bus/event_source/devices/cpu/events/topdown-bad-spec";
constexpr auto perfBackEndPath = "/sys/bus/event_source/devices/cpu/events/topdown-be-bound";
constexpr auto perfFrontEndPath = "/sys/bus/event_source/devices/cpu/events/topdown-fe-bound";
constexpr auto perfRetiringPath = "/sys/bus/event_source/devices/cpu/events/topdown-retiring";
// L2 extensions:
constexpr auto perfBrMispred = "/sys/bus/event_source/devices/cpu/events/topdown-br-mispredict";
constexpr auto perfFetchLat = "/sys/bus/event_source/devices/cpu/events/topdown-fetch-lat";
constexpr auto perfHeavyOps = "/sys/bus/event_source/devices/cpu/events/topdown-heavy-ops";
constexpr auto perfMemBound = "/sys/bus/event_source/devices/cpu/events/topdown-mem-bound";

bool PCM::perfSupportsTopDown()
{
    static int yes = -1;
    if (-1 == yes)
    {
        const auto slots = readSysFS(perfSlotsPath, true);
        const auto bad = readSysFS(perfBadSpecPath, true);
        const auto be = readSysFS(perfBackEndPath, true);
        const auto fe = readSysFS(perfFrontEndPath, true);
        const auto ret = readSysFS(perfRetiringPath, true);
        bool supported = slots.size() && bad.size() && be.size() && fe.size() && ret.size();
        if (isHWTMAL2Supported())
        {
            supported = supported &&
                readSysFS("/sys/bus/event_source/devices/cpu/events/topdown-br-mispredict", true).size() &&
                readSysFS("/sys/bus/event_source/devices/cpu/events/topdown-fetch-lat", true).size() &&
                readSysFS("/sys/bus/event_source/devices/cpu/events/topdown-heavy-ops", true).size() &&
                readSysFS("/sys/bus/event_source/devices/cpu/events/topdown-mem-bound", true).size();
        }
        yes = supported ? 1 : 0;
    }
    return 1 == yes;
}
#endif

const std::vector<std::string> qat_evtsel_mapping = 
{
    { "sample_cnt" },               //0x0
    { "pci_trans_cnt" },            //0x1
    { "max_rd_lat" },               //0x2
    { "rd_lat_acc_avg" },           //0x3
    { "max_lat" },                  //0x4
    { "lat_acc_avg" },              //0x5
    { "bw_in" },                    //0x6
    { "bw_out" },                   //0x7
    { "at_page_req_lat_acc_avg" },  //0x8
    { "at_trans_lat_acc_avg" },     //0x9
    { "at_max_tlb_used" },          //0xA
    { "util_cpr0" },                //0xB
    { "util_dcpr0" },               //0xC
    { "util_dcpr1" },               //0xD
    { "util_dcpr2" },               //0xE
    { "util_xlt0" },                //0xF
    { "util_xlt1" },                //0x10
    { "util_cph0" },                //0x11
    { "util_cph1" },                //0x12
    { "util_cph2" },                //0x13
    { "util_cph3" },                //0x14
    { "util_cph4" },                //0x15
    { "util_cph5" },                //0x16
    { "util_cph6" },                //0x17
    { "util_cph7" },                //0x18
    { "util_ath0" },                //0x19
    { "util_ath1" },                //0x1A
    { "util_ath2" },                //0x1B
    { "util_ath3" },                //0x1C
    { "util_ath4" },                //0x1D
    { "util_ath5" },                //0x1E
    { "util_ath6" },                //0x1F
    { "util_ath7" },                //0x20
    { "util_ucs0" },                //0x21
    { "util_ucs1" },                //0x22
    { "util_ucs2" },                //0x23
    { "util_ucs3" },                //0x24
    { "util_pke0" },                //0x25
    { "util_pke1" },                //0x26
    { "util_pke2" },                //0x27
    { "util_pke3" },                //0x28
    { "util_pke4" },                //0x29
    { "util_pke5" },                //0x2A
    { "util_pke6" },                //0x2B
    { "util_pke7" },                //0x2C
    { "util_pke8" },                //0x2D
    { "util_pke9" },                //0x2E
    { "util_pke10" },               //0x2F
    { "util_pke11" },               //0x30
    { "util_pke12" },               //0x31
    { "util_pke13" },               //0x32
    { "util_pke14" },               //0x33
    { "util_pke15" },               //0x34
    { "util_pke16" },               //0x35
    { "util_pke17" },               //0x36
    { "unknown" }                   //0x37
};

class VirtualDummyRegister : public HWRegister
{
    uint64 lastValue;
public:
    VirtualDummyRegister() : lastValue(0) {}
    void operator = (uint64 val) override
    {
        lastValue = val;
    }
    operator uint64 () override
    {
        return lastValue;
    }
};

class QATTelemetryVirtualGeneralConfigRegister : public HWRegister
{
    friend class QATTelemetryVirtualCounterRegister;
    int domain, b, d, f;
    PCM::IDX_OPERATION operation;
    PCM::IDX_STATE state;
    std::unordered_map<std::string, uint32> data_cache; //data cache
public:
    QATTelemetryVirtualGeneralConfigRegister(int domain_, int b_, int d_, int f_) :
        domain(domain_),
        b(b_),
        d(d_),
        f(f_),
        operation(PCM::QAT_TLM_STOP),
        state(PCM::IDX_STATE_OFF)
    {
    }
    void operator = (uint64 val) override
    {
        operation = PCM::IDX_OPERATION(val);
#ifdef __linux__
        std::ostringstream sysfs_path(std::ostringstream::out);
        std::string telemetry_filename;
        switch (operation)
        {
            case PCM::QAT_TLM_START: //enable
                state = PCM::IDX_STATE_ON; 
                // falls through
            case PCM::QAT_TLM_STOP: //disable
                if (state == PCM::IDX_STATE_ON)
                {
                    DBG(3, "QAT telemetry operation = ", operation, ".");
                    sysfs_path << std::string("/sys/bus/pci/devices/") <<
                        std::hex << std::setw(4) << std::setfill('0') << domain << ":" <<
                        std::hex << std::setw(2) << std::setfill('0') << b << ":" <<
                        std::hex << std::setw(2) << std::setfill('0') << d << "." <<
                        std::hex << f << "/telemetry/control";

                    /*check telemetry for out-of tree driver*/
                    telemetry_filename = readSysFS(sysfs_path.str().c_str(), true);
                    if(!telemetry_filename.size()){
                        /*is not oot driver, check telemetry for in tree driver  (since kernel 6.8)*/
                        sysfs_path.str("");
                        sysfs_path << std::string("/sys/kernel/debug/qat_4xxx_") <<
                            std::hex << std::setw(4) << std::setfill('0') << domain << ":" <<
                            std::hex << std::setw(2) << std::setfill('0') << b << ":" <<
                            std::hex << std::setw(2) << std::setfill('0') << d << "." <<
                            std::hex << f << "/telemetry/control";
                    }

                    if (writeSysFS(sysfs_path.str().c_str(), (operation == PCM::QAT_TLM_START  ? "1" : "0")) == false)
                    {
                        std::cerr << "Linux sysfs: Error on control QAT telemetry operation = " << operation << ".\n";
                    }
                }
                break;
            case PCM::QAT_TLM_REFRESH: //refresh data
                if (state == PCM::IDX_STATE_ON)
                {
                    DBG(3, "QAT telemetry operation = ", operation, ".");
                    sysfs_path << std::string("/sys/bus/pci/devices/") <<
                        std::hex << std::setw(4) << std::setfill('0') << domain << ":" <<
                        std::hex << std::setw(2) << std::setfill('0') << b << ":" <<
                        std::hex << std::setw(2) << std::setfill('0') << d << "." <<
                        std::hex << f << "/telemetry/device_data";
                    /*check telemetry for out-of tree driver*/
                    telemetry_filename = readSysFS(sysfs_path.str().c_str(), true);
                    if(!telemetry_filename.size()){
                        /*is not oot driver, check telemetry for in tree driver  (since kernel 6.8)*/
                        sysfs_path.str("");
                        sysfs_path << std::string("/sys/kernel/debug/qat_4xxx_") <<
                            std::hex << std::setw(4) << std::setfill('0') << domain << ":" <<
                            std::hex << std::setw(2) << std::setfill('0') << b << ":" <<
                            std::hex << std::setw(2) << std::setfill('0') << d << "." <<
                            std::hex << f << "/telemetry/device_data";
                    }
                    data_cache.clear();
                    readMapFromSysFS(sysfs_path.str().c_str(), data_cache);
                }
                break;
            default:
                break;
        }
#endif
    }
    operator uint64 () override
    {
        return operation;
    }
    ~QATTelemetryVirtualGeneralConfigRegister()
    {
        try {
            DBG(3, "~QATTelemetryVirtualGeneralConfigRegister.");
        }
        catch (...) {
            // disallow throwing exceptions from the destructor because it will this will result in a call to terminate()
        }
    }
};

class QATTelemetryVirtualControlRegister : public HWRegister
{
    friend class QATTelemetryVirtualCounterRegister;
    uint64 event;
public:
    QATTelemetryVirtualControlRegister() : event(0x0)
    {
    }
    void operator = (uint64 val) override
    {
        event = extract_bits(val, 32, 59);
    }
    operator uint64 () override
    {
        return event;
    }
};

class QATTelemetryVirtualCounterRegister : public HWRegister
{
    std::shared_ptr<QATTelemetryVirtualGeneralConfigRegister> gConfigReg;
    std::shared_ptr<QATTelemetryVirtualControlRegister> controlReg;
    const int ctr_id;
public:
    QATTelemetryVirtualCounterRegister( std::shared_ptr<QATTelemetryVirtualGeneralConfigRegister> gConfigReg_,
        std::shared_ptr<QATTelemetryVirtualControlRegister> controlReg_,
        const int ctr_id_) :
        gConfigReg(gConfigReg_),
        controlReg(controlReg_),
        ctr_id(ctr_id_)
    {
    }
    void operator = (uint64 /* val */) override
    {
        // no-op
    }
    operator uint64 () override
    {
        uint64 result = 0;
        uint32 eventsel = controlReg->event;
        std::string key;
        if (eventsel < qat_evtsel_mapping.size())
        {
            key = qat_evtsel_mapping[eventsel];
            if (gConfigReg->data_cache.find(key) != gConfigReg->data_cache.end())
            {
                result = gConfigReg->data_cache.at(key);
            }
        }
        DBG(3, std::hex, "QAT-CTR(0x", ctr_id, "), key=", key, ", val=0x", std::hex, result, ".", std::dec);
        return result;
    }
};

bool PCM::discoverSystemTopology()
{
    typedef std::map<uint32, uint32> socketIdMap_type;
    socketIdMap_type socketIdMap;

    PCM_CPUID_INFO cpuid_args;
    uint32 smtMaskWidth = 0;
    uint32 coreMaskWidth = 0;
    uint32 l2CacheMaskShift = 0;
    uint32 l3CacheMaskShift = 0;

    struct domain
    {
        TopologyEntry::DomainTypeID type = TopologyEntry::DomainTypeID::InvalidDomainTypeID;
        unsigned levelShift = 0, nextLevelShift = 0, width = 0;
    };
    std::unordered_map<int, domain> topologyDomainMap;
    {
        const int32 maxTopoDomainAff = 1<<16;
        int32 topoDomainAff = -1;

        for (int32 core = 0; core < maxTopoDomainAff; ++core)
        {
            try {
                TemporalThreadAffinity _(core);
                topoDomainAff = core;
            }
            catch (...)
            {
            }
            if (topoDomainAff != -1) break;
        }

        TemporalThreadAffinity _(topoDomainAff);

        if (initCoreMasks(smtMaskWidth, coreMaskWidth, l2CacheMaskShift, l3CacheMaskShift) == false)
        {
            std::cerr << "ERROR: Major problem? No leaf 0 under cpuid function 11.\n";
            return false;
        }

        int subleaf = 0;

        std::vector<domain> topologyDomains;
        if (max_cpuid >= 0x1F)
        {
            subleaf = 0;
            do
            {
                pcm_cpuid(0x1F, subleaf, cpuid_args);
                domain d;
                d.type = (TopologyEntry::DomainTypeID)extract_bits_32(cpuid_args.reg.ecx, 8, 15);
               DBG(1 , "pcm_cpuid 0x1F cpuid_args.reg.ecx = " , cpuid_args.reg.ecx , " d.type = ", d.type);
                if (d.type == TopologyEntry::DomainTypeID::InvalidDomainTypeID)
                {
                    break;
                }
                d.nextLevelShift = extract_bits_32(cpuid_args.reg.eax, 0, 4);
                d.levelShift = topologyDomains.empty() ? 0 : topologyDomains.back().nextLevelShift;
                d.width = d.nextLevelShift - d.levelShift;
                topologyDomains.push_back(d);
                ++subleaf;
            } while (true);

            if (topologyDomains.size())
            {
                domain d;
                d.type = TopologyEntry::DomainTypeID::SocketPackageDomain;
                d.levelShift = topologyDomains.back().nextLevelShift;
                d.nextLevelShift = 32;
                d.width = d.nextLevelShift - d.levelShift;
                topologyDomains.push_back(d);
            }
            for (size_t l = 0; l < topologyDomains.size(); ++l)
            {
                topologyDomainMap[topologyDomains[l].type] = topologyDomains[l];
                DBG(1 , "Topology level: " , l ,
                                      " type: " , topologyDomains[l].type ,
                                      " (" , TopologyEntry::getDomainTypeStr(topologyDomains[l].type) , ")" ,
                                      " width: " , topologyDomains[l].width ,
                                      " levelShift: " , topologyDomains[l].levelShift ,
                                      " nextLevelShift: " , topologyDomains[l].nextLevelShift);
            }
        }
    }

#ifndef __APPLE__
    auto populateEntry = [&topologyDomainMap,&smtMaskWidth, &coreMaskWidth, &l2CacheMaskShift, &l3CacheMaskShift](TopologyEntry& entry)
    {
        auto getAPICID = [&](const uint32 leaf)
        {
            PCM_CPUID_INFO cpuid_args;
#if defined(__FreeBSD__) || defined(__DragonFly__)
            pcm_cpuid_bsd(leaf, cpuid_args, entry.os_id);
#else
            pcm_cpuid(leaf, 0x0, cpuid_args);
#endif
            return cpuid_args.array[3];
        };
        if (topologyDomainMap.size())
        {
            auto getID = [&topologyDomainMap](const int apic_id, const TopologyEntry::DomainTypeID t)
            {
                const auto di = topologyDomainMap.find(t);
                if (di != topologyDomainMap.end())
                {
                    const auto & d = di->second;
                    return extract_bits_32(apic_id, d.levelShift, d.nextLevelShift - 1);
                }
                return 0U;
            };
            entry.tile_id = extract_bits_32(getAPICID(0xb), l2CacheMaskShift, 31);
            const int apic_id = getAPICID(0x1F);
            entry.thread_id = getID(apic_id, TopologyEntry::DomainTypeID::LogicalProcessorDomain);
            entry.core_id = getID(apic_id, TopologyEntry::DomainTypeID::CoreDomain);
            entry.module_id = getID(apic_id, TopologyEntry::DomainTypeID::ModuleDomain);
            if (entry.tile_id == 0)
            {
                entry.tile_id = getID(apic_id, TopologyEntry::DomainTypeID::TileDomain);
            }
            entry.die_id = getID(apic_id, TopologyEntry::DomainTypeID::DieDomain);
            entry.die_grp_id = getID(apic_id, TopologyEntry::DomainTypeID::DieGrpDomain);
            entry.socket_id = getID(apic_id, TopologyEntry::DomainTypeID::SocketPackageDomain);

            auto getDomain = [&topologyDomainMap](const TopologyEntry::DomainTypeID t)
            {
                auto di = topologyDomainMap.find(t);
                if (di != topologyDomainMap.end())
                {
                    return di->second;
                }
                throw std::runtime_error("DomainType not found");
            };
            domain d1 = getDomain( TopologyEntry::DomainTypeID::CoreDomain );
            domain d2 = getDomain( TopologyEntry::DomainTypeID::SocketPackageDomain );
            entry.socket_unique_core_id = extract_bits_32( apic_id, d1.levelShift, d2.levelShift - 1 );
        }
        else
        {
            fillEntry(entry, smtMaskWidth, coreMaskWidth, l2CacheMaskShift, getAPICID(0xb));
        }
        entry.l3_cache_id = extract_bits_32(getAPICID(0xb), l3CacheMaskShift, 31);
    };
#endif

    auto populateHybridEntry = [this](TopologyEntry& entry, int core) -> bool
    {
        if (hybrid == false) return true;
        PCM_CPUID_INFO cpuid_args;
#if defined(__FreeBSD__) || defined(__DragonFly__)
        pcm_cpuid_bsd(0x1a, cpuid_args, core);
#elif defined (_MSC_VER) || defined(__linux__)
        pcm_cpuid(0x1a, 0x0, cpuid_args);
        (void)core;
#else
        std::cerr << "PCM Error: Hybrid processors are not supported for your OS\n";
        (void)core;
        return false;
#endif
        entry.native_cpu_model = extract_bits_32(cpuid_args.reg.eax, 0, 23);
        entry.core_type = (TopologyEntry::CoreType) extract_bits_32(cpuid_args.reg.eax, 24, 31);
        return true;
    };

#ifdef _MSC_VER
// version for Windows 7 and later version

    char * slpi = new char[sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)];
    DWORD len = (DWORD)sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX);
    BOOL res = GetLogicalProcessorInformationEx(RelationAll, (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)slpi, &len);

    while (res == FALSE)
    {
        deleteAndNullifyArray(slpi);

        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            slpi = new char[len];
            res = GetLogicalProcessorInformationEx(RelationAll, (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)slpi, &len);
        }
        else
        {
            tcerr << "Error in Windows function 'GetLogicalProcessorInformationEx': " <<
                GetLastError() << " ";
            const TCHAR * strError = _com_error(GetLastError()).ErrorMessage();
            if (strError) tcerr << strError;
            tcerr << "\n";
            return false;
        }
    }

    char * base_slpi = slpi;
    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX pi = NULL;

    for ( ; slpi < base_slpi + len; slpi += (DWORD)pi->Size)
    {
        pi = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)slpi;
        if (pi->Relationship == RelationProcessorCore)
        {
            const auto current_threads_per_core = (pi->Processor.Flags == LTP_PC_SMT) ? 2 : 1;
            DBG(3, "thr per core: " , current_threads_per_core );
            num_cores += current_threads_per_core;
        }
    }

    num_online_cores = num_cores;

    if (num_cores != GetActiveProcessorCount(ALL_PROCESSOR_GROUPS))
    {
        std::cerr << "Error in processor group size counting: " << num_cores << "!=" << GetActiveProcessorCount(ALL_PROCESSOR_GROUPS) << "\n";
        std::cerr << "Make sure your binary is compiled for 64-bit: using 'x64' platform configuration.\n";
        return false;
    }

    for (int i = 0; i < (int)num_cores; i++)
    {
        ThreadGroupTempAffinity affinity(i);

        TopologyEntry entry;
        entry.os_id = i;

        populateEntry(entry);
        if (populateHybridEntry(entry, i) == false)
        {
            return false;
        }

        topology.push_back(entry);
        socketIdMap[entry.socket_id] = 0;
    }

    deleteAndNullifyArray(base_slpi);

#else
    // for Linux, Mac OS, FreeBSD and DragonFlyBSD

    TopologyEntry entry;

#ifdef __linux__
    num_cores = readMaxFromSysFS("/sys/devices/system/cpu/present");
    if(num_cores == -1)
    {
      std::cerr << "Cannot read number of present cores\n";
      return false;
    }
    ++num_cores;

    // open /proc/cpuinfo
    FILE * f_cpuinfo = fopen("/proc/cpuinfo", "r");
    if (!f_cpuinfo)
    {
        std::cerr << "Cannot open /proc/cpuinfo file.\n";
        return false;
    }

    // map with key=pkg_apic_id (not necessarily zero based or sequential) and
    // associated value=socket_id that should be 0 based and sequential
    std::map<int, int> found_pkg_ids;
    topology.resize(num_cores);
    char buffer[1024];
    while (0 != fgets(buffer, 1024, f_cpuinfo))
    {
        if (strncmp(buffer, "processor", sizeof("processor") - 1) == 0)
        {
            pcm_sscanf(buffer) >> s_expect("processor\t: ") >> entry.os_id;
            DBG(3, "os_core_id: " , entry.os_id );
            try {
                TemporalThreadAffinity _(entry.os_id);

                populateEntry(entry);
                if (populateHybridEntry(entry, entry.os_id) == false)
                {
                    return false;
                }

                topology[entry.os_id] = entry;
                socketIdMap[entry.socket_id] = 0;
                ++num_online_cores;
            }
            catch (std::exception &)
            {
                std::cerr << "Marking core " << entry.os_id << " offline\n";
            }
        }
    }
    fclose(f_cpuinfo);

#elif defined(__FreeBSD__) || defined(__DragonFly__)

    size_t size = sizeof(num_cores);

    if(0 != sysctlbyname("hw.ncpu", &num_cores, &size, NULL, 0))
    {
        std::cerr << "Unable to get hw.ncpu from sysctl.\n";
        return false;
    }
    num_online_cores = num_cores;

    if (modfind("cpuctl") == -1)
    {
        std::cerr << "cpuctl(4) not loaded.\n";
        return false;
    }

    for (int i = 0; i < num_cores; i++)
    {
        entry.os_id = i;

        populateEntry(entry);
        if (populateHybridEntry(entry, i) == false)
        {
            return false;
        }

        topology.push_back(entry);
        socketIdMap[entry.socket_id] = 0;
    }

#else // Getting processor info for Mac OS
#define SAFE_SYSCTLBYNAME(message, ret_value)                                                              \
    {                                                                                                      \
        size_t size;                                                                                       \
        char *pParam;                                                                                      \
        if(0 != sysctlbyname(message, NULL, &size, NULL, 0))                                               \
        {                                                                                                  \
            std::cerr << "Unable to determine size of " << message << " sysctl return type.\n";            \
            return false;                                                                                  \
        }                                                                                                  \
        if(NULL == (pParam = (char *)malloc(size)))                                                        \
        {                                                                                                  \
            std::cerr << "Unable to allocate memory for " << message << "\n";                              \
            return false;                                                                                  \
        }                                                                                                  \
        if(0 != sysctlbyname(message, (void*)pParam, &size, NULL, 0))                                      \
        {                                                                                                  \
            std::cerr << "Unable to get " << message << " from sysctl.\n";                                 \
            return false;                                                                                  \
        }                                                                                                  \
        ret_value = convertUnknownToInt(size, pParam);                                                     \
        freeAndNullify(pParam);                                                                            \
    }
// End SAFE_SYSCTLBYNAME

    // Using OSXs sysctl to get the number of CPUs right away
    SAFE_SYSCTLBYNAME("hw.logicalcpu", num_cores)
    num_online_cores = num_cores;

#undef SAFE_SYSCTLBYNAME

    // The OSX version needs the MSR handle earlier so that it can build the CPU topology.
    // This topology functionality should potentially go into a different KEXT
    for(int i = 0; i < num_cores; i++)
    {
        MSR.push_back(std::make_shared<SafeMsrHandle>(i));
    }

    assert(num_cores > 0);
    TopologyEntry entries[num_cores];
    if (MSR[0]->buildTopology(num_cores, entries) != 0) {
      std::cerr << "Unable to build CPU topology" << std::endl;
      return false;
    }
    for(int i = 0; i < num_cores; i++){
        socketIdMap[entries[i].socket_id] = 0;
        if(entries[i].os_id >= 0)
        {
            if (populateHybridEntry(entries[i], i) == false)
            {
                return false;
            }
            topology.push_back(entries[i]);
        }
    }
// End of OSX specific code
#endif

#endif //end of ifdef _MSC_VER

    if(num_cores == 0) {
        num_cores = (int32)topology.size();
    }
    if(num_sockets == 0) {
        num_sockets = (int32)(std::max)(socketIdMap.size(), (size_t)1);
        DBG(1, " num_sockets = ", num_sockets);
    }

    socketIdMap_type::iterator s = socketIdMap.begin();
    for (uint32 sid = 0; s != socketIdMap.end(); ++s)
    {
        s->second = sid++;
    }

    // use map to change apic socket id to the logical socket id
    for (int i = 0; (i < (int)num_cores) && (!socketIdMap.empty()); ++i)
    {
       DBG(2, "socket_id: ", topology[i].socket_id, ", socketIdMap tells me: ",
                        (socketIdMap.find(topology[i].socket_id) == socketIdMap.end()) ? (std::string("N/A")): std::to_string(socketIdMap[topology[i].socket_id]));
        if(isCoreOnline((int32)i))
          topology[i].socket_id = socketIdMap[topology[i].socket_id];
    }

#if 0
    std::cerr << "Number of socket ids: " << socketIdMap.size() << "\n";
    std::cerr << "Topology:\nsocket os_id core_id\n";
    for (int i = 0; i < num_cores; ++i)
    {
        std::cerr << topology[i].socket_id << " " << topology[i].os_id << " " << topology[i].core_id << "\n";
    }
#endif
    assert(threads_per_core == 0); // make sure it is not initialized yet
    // copy the topology array to a temp object
    auto sortedTopology = topology;
    std::sort(sortedTopology.begin(), sortedTopology.end());
    // find out max number of threads per core given that the topologyCopy is sorted now
    assert(sortedTopology.size() > 0);
    auto currentCore = sortedTopology.begin();
    while (currentCore != sortedTopology.end())
    {
        if (currentCore->os_id == -1 || currentCore->core_id == -1 || currentCore->socket_id == -1) // offlined core
        {
            ++currentCore;
            continue;
        }
        break;
    }
    assert(currentCore != sortedTopology.end());
    int current_threads_per_core = 0;
    for (auto firstCore = *currentCore; currentCore != sortedTopology.end(); ++currentCore)
    {
        DBG(3, "Examining core: os_id=", currentCore->os_id, ", core_id=", currentCore->core_id, ", socket_id=", currentCore->socket_id);
        if (currentCore->isSameCore(firstCore))
        {
            ++current_threads_per_core;
        }
        else
        {
            threads_per_core = (std::max)(threads_per_core, current_threads_per_core);
            firstCore = *currentCore;
            current_threads_per_core = 1;
        }
    }
    threads_per_core = (std::max)(threads_per_core, current_threads_per_core);
    assert(threads_per_core != 0);
    if(num_phys_cores_per_socket == 0 && num_cores == num_online_cores) num_phys_cores_per_socket = num_cores / num_sockets / threads_per_core;
    if(num_online_cores == 0) num_online_cores = num_cores;

    s = socketIdMap.begin();
    for (; s != socketIdMap.end(); ++s)
    {
        systemTopology->addSocket( s->second );
    }

    for (int32 cid = 0; cid < num_cores; ++cid)
    {
        DBG(3, "Cid: ", cid);
        systemTopology->addThread( cid, topology[cid] );
    }

    // All threads are here now so we can set the refCore for a socket
    for ( auto& socket : systemTopology->sockets() )
        socket->setRefCore();

    int32 i = 0;

    socketRefCore.resize(num_sockets, -1);
    for(i = 0; i < num_cores; ++i)
    {
        if(isCoreOnline(i))
        {
            socketRefCore[topology[i].socket_id] = i;
        }
    }

    num_online_sockets = 0;
    for(i = 0; i < num_sockets; ++i)
    {
        if(isSocketOnline(i))
        {
            ++num_online_sockets;
        }
    }

    FrontendBoundSlots.resize(num_cores, 0);
    BadSpeculationSlots.resize(num_cores, 0);
    BackendBoundSlots.resize(num_cores, 0);
    RetiringSlots.resize(num_cores, 0);
    AllSlotsRaw.resize(num_cores, 0);
    MemBoundSlots.resize(num_cores, 0);
    FetchLatSlots.resize(num_cores, 0);
    BrMispredSlots.resize(num_cores, 0);
    HeavyOpsSlots.resize(num_cores, 0);

#if 0
    std::cerr << "Socket reference cores:\n";
    for(int32 i=0; i< num_sockets;++i)
    {
        std::cerr << "socketRefCore[" << i << "]=" << socketRefCore[i] << "\n";
    }
#endif

    return true;
}

void PCM::printSystemTopology() const
{
    const bool all_cores_online_no_hybrid = (num_cores == num_online_cores && hybrid == false);

    if (all_cores_online_no_hybrid)
    {
      std::cerr << "Number of physical cores: " << (num_cores/threads_per_core) << "\n";
    }

    std::cerr << "Number of logical cores: " << num_cores << "\n";
    std::cerr << "Number of online logical cores: " << num_online_cores << "\n";

    if (all_cores_online_no_hybrid)
    {
      std::cerr << "Threads (logical cores) per physical core: " << threads_per_core << "\n";
    }
    else
    {
        std::cerr << "Threads (logical cores) per physical core: " << threads_per_core << " (maybe imprecise due to core offlining/hybrid CPU)\n";
        std::cerr << "Offlined cores: ";
        for (int i = 0; i < (int)num_cores; ++i)
            if(isCoreOnline((int32)i) == false)
                std::cerr << i << " ";
        std::cerr << "\n";
    }
    std::cerr << "Num sockets: " << num_sockets << "\n";
    if (all_cores_online_no_hybrid)
    {
        std::cerr << "Physical cores per socket: " << num_phys_cores_per_socket << "\n";
    }
    else
    {
        std::cerr << "Physical cores per socket: " << num_cores / num_sockets / threads_per_core << " (maybe imprecise due to core offlining/hybrid CPU)\n";
    }

    if (hybrid == false)
    {
        // TODO: deprecate this output and move it to uncore PMU section (use getMaxNumOfUncorePMUs(CBO_PMU_ID) )
        std::cerr << "Last level cache slices per socket: " << getMaxNumOfCBoxesInternal() << "\n";
    }
    std::cerr << "Core PMU (perfmon) version: " << perfmon_version << "\n";
    std::cerr << "Number of core PMU generic (programmable) counters: " << core_gen_counter_num_max << "\n";
    std::cerr << "Width of generic (programmable) counters: " << core_gen_counter_width << " bits\n";
    if (perfmon_version > 0)
    {
        std::cerr << "Number of core PMU fixed counters: " << core_fixed_counter_num_max << "\n";
        std::cerr << "Width of fixed counters: " << core_fixed_counter_width << " bits\n";
    }
    if (perfmon_version < 2 && vm == true)
    {
        std::cerr << "Warning: detected an unsupported virtualized environment: the hypervisor has limited the core PMU (perfmon) version to " << perfmon_version << "\n";
    }
}

bool PCM::initMSR()
{
#ifdef __APPLE__
    for (size_t i=0; i < MSR.size(); ++i)
    {
        systemTopology->addMSRHandleToOSThread(MSR[i], (uint32)i);
    }
#else
    try
    {
        for (int i = 0; i < (int)num_cores; ++i)
        {
            if ( isCoreOnline( (int32)i ) ) {
                MSR.push_back(std::make_shared<SafeMsrHandle>(i));
                systemTopology->addMSRHandleToOSThread( MSR.back(), (uint32)i );
            } else { // the core is offlined, assign an invalid MSR handle
                MSR.push_back(std::make_shared<SafeMsrHandle>());
                systemTopology->addMSRHandleToOSThread( MSR.back(), (uint32)i );
            }
        }
    }
    catch (...)
    {
        // failed
        MSR.clear();

        std::cerr << "Can not access CPUs Model Specific Registers (MSRs).\n";
#ifdef _MSC_VER
        std::cerr << "You must have signed msr.sys driver in your current directory and have administrator rights to run this program.\n";
#elif defined(__linux__)
        std::cerr << "execute 'modprobe msr' as root user, then execute pcm as root user.\n";
#elif defined(__FreeBSD__) || defined(__DragonFly__)
        std::cerr << "Ensure cpuctl module is loaded and that you have read and write\n";
        std::cerr << "permissions for /dev/cpuctl* devices (the 'chown' command can help).\n";
#endif
        return false;
    }
#endif
    return true;
}

bool PCM::detectNominalFrequency()
{
    if (MSR.size())
    {
        if (max_cpuid >= 0x16)
        {
            PCM_CPUID_INFO cpuinfo;
            pcm_cpuid(0x16, cpuinfo);
            nominal_frequency = uint64(extract_bits_32(cpuinfo.reg.eax, 0, 15)) * 1000000ULL;;
        }
        if (!nominal_frequency)
        {
            uint64 freq = 0;
            MSR[socketRefCore[0]]->read(PLATFORM_INFO_ADDR, &freq);
            const uint64 bus_freq = (
                  cpu_family_model == SANDY_BRIDGE
               || cpu_family_model == JAKETOWN
               || cpu_family_model == IVYTOWN
               || cpu_family_model == HASWELLX
               || cpu_family_model == BDX_DE
               || cpu_family_model == BDX
               || cpu_family_model == IVY_BRIDGE
               || cpu_family_model == HASWELL
               || cpu_family_model == BROADWELL
               || cpu_family_model == AVOTON
               || cpu_family_model == APOLLO_LAKE
               || cpu_family_model == GEMINI_LAKE
               || cpu_family_model == DENVERTON
               || useSKLPath()
               || cpu_family_model == SNOWRIDGE
               || cpu_family_model == ELKHART_LAKE
               || cpu_family_model == JASPER_LAKE
               || cpu_family_model == KNL
               || cpu_family_model == ADL
               || cpu_family_model == RPL
               || cpu_family_model == MTL
               || cpu_family_model == LNL
               || cpu_family_model == ARL
               || cpu_family_model == PTL
               || cpu_family_model == SKX
               || cpu_family_model == ICX
               || cpu_family_model == SPR
               || cpu_family_model == EMR
               || cpu_family_model == GNR
               || cpu_family_model == GNR_D
               || cpu_family_model == SRF
               || cpu_family_model == GRR
               ) ? (100000000ULL) : (133333333ULL);

            nominal_frequency = ((freq >> 8) & 255) * bus_freq;
        }

        if(!nominal_frequency)
            nominal_frequency = get_frequency_from_cpuid();

        if(!nominal_frequency)
        {
            computeNominalFrequency();
        }

        if(!nominal_frequency)
        {
            std::cerr << "Error: Can not detect core frequency.\n";
            destroyMSR();
            return false;
        }

#ifndef PCM_SILENT
        if (!quietMode)
        {
            std::cerr << "Nominal core frequency: " << nominal_frequency << " Hz\n";
        }
#endif
    }

    return true;
}

void PCM::initEnergyMonitoring()
{
    if(packageEnergyMetricsAvailable() && MSR.size())
    {
        uint64 rapl_power_unit = 0;
        MSR[socketRefCore[0]]->read(MSR_RAPL_POWER_UNIT,&rapl_power_unit);
        uint64 energy_status_unit = extract_bits(rapl_power_unit,8,12);
        if (cpu_family_model == PCM::CHERRYTRAIL || cpu_family_model == PCM::BAYTRAIL)
            joulesPerEnergyUnit = double(1ULL << energy_status_unit)/1000000.; // (2)^energy_status_unit microJoules
        else
            joulesPerEnergyUnit = 1./double(1ULL<<energy_status_unit); // (1/2)^energy_status_unit
        DBG(2, "MSR_RAPL_POWER_UNIT: " , energy_status_unit , "; Joules/unit " , joulesPerEnergyUnit);
        uint64 power_unit = extract_bits(rapl_power_unit,0,3);
        double wattsPerPowerUnit = 1./double(1ULL<<power_unit);

        uint64 package_power_info = 0;
        MSR[socketRefCore[0]]->read(MSR_PKG_POWER_INFO,&package_power_info);
        pkgThermalSpecPower = (int32) (double(extract_bits(package_power_info, 0, 14))*wattsPerPowerUnit);
        pkgMinimumPower = (int32) (double(extract_bits(package_power_info, 16, 30))*wattsPerPowerUnit);
        pkgMaximumPower = (int32) (double(extract_bits(package_power_info, 32, 46))*wattsPerPowerUnit);

#ifndef PCM_SILENT
        if (!quietMode)
        {
            std::cerr << "Package thermal spec power: " << pkgThermalSpecPower << " Watt; ";
            std::cerr << "Package minimum power: " << pkgMinimumPower << " Watt; ";
            std::cerr << "Package maximum power: " << pkgMaximumPower << " Watt;\n";
        }
#endif

        int i = 0;

        if(energy_status.empty())
            for (i = 0; i < (int)num_sockets; ++i)
                energy_status.push_back(
                    std::make_shared<CounterWidthExtender>(
                        new CounterWidthExtender::MsrHandleCounter(MSR[socketRefCore[i]], MSR_PKG_ENERGY_STATUS), 32, 10000));

        if(dramEnergyMetricsAvailable() && dram_energy_status.empty())
            for (i = 0; i < (int)num_sockets; ++i)
                dram_energy_status.push_back(
                    std::make_shared<CounterWidthExtender>(
                    new CounterWidthExtender::MsrHandleCounter(MSR[socketRefCore[i]], MSR_DRAM_ENERGY_STATUS), 32, 10000));
    }

    if (ppEnergyMetricsAvailable() && MSR.size() && num_sockets == 1 && pp_energy_status.empty())
    {
        pp_energy_status.push_back(std::make_shared<CounterWidthExtender>(
            new CounterWidthExtender::MsrHandleCounter(MSR[socketRefCore[0]], MSR_PP0_ENERGY_STATUS), 32, 10000));
        pp_energy_status.push_back(std::make_shared<CounterWidthExtender>(
            new CounterWidthExtender::MsrHandleCounter(MSR[socketRefCore[0]], MSR_PP1_ENERGY_STATUS), 32, 10000));
    }

    if (systemEnergyMetricAvailable() && MSR.size() && (system_energy_status.get() == nullptr))
    {
        system_energy_status = std::make_shared<CounterWidthExtender>(
            new CounterWidthExtender::MsrHandleCounter(MSR[socketRefCore[0]], MSR_SYS_ENERGY_STATUS, 0x00000000FFFFFFFF), 32, 10000);
    }
}

static const uint32 UBOX0_DEV_IDS[] = {
    0x3451,
    0x3251
};

std::vector<std::pair<uint32, uint32> > socket2UBOX0bus;

void initSocket2Bus(std::vector<std::pair<uint32, uint32> > & socket2bus, uint32 device, uint32 function, const uint32 DEV_IDS[], uint32 devIdsSize);

void initSocket2Ubox0Bus()
{
    initSocket2Bus(socket2UBOX0bus, SERVER_UBOX0_REGISTER_DEV_ADDR, SERVER_UBOX0_REGISTER_FUNC_ADDR,
        UBOX0_DEV_IDS, (uint32)sizeof(UBOX0_DEV_IDS) / sizeof(UBOX0_DEV_IDS[0]));
}

bool initRootBusMap(std::map<int, int> &rootbus_map)
{
    bool mapped = false;
    static const uint32 MSM_DEV_IDS[] = { SPR_MSM_DEV_ID };

    std::vector<std::pair<uint32, uint32> > socket2MSMbus;
    initSocket2Bus(socket2MSMbus, SPR_MSM_DEV_ADDR, SPR_MSM_FUNC_ADDR, MSM_DEV_IDS, (uint32)sizeof(MSM_DEV_IDS) / sizeof(MSM_DEV_IDS[0]));

    for (auto & s2bus : socket2MSMbus)
    {
        uint32 cpuBusValid = 0x0;
        int cpuBusPackageId = 0;
        std::vector<uint32> cpuBusNo;

        if (get_cpu_bus(s2bus.first, s2bus.second, SPR_MSM_DEV_ADDR, SPR_MSM_FUNC_ADDR, cpuBusValid, cpuBusNo, cpuBusPackageId) == false)
            return false;

        for (int cpuBusId = 0; cpuBusId < SPR_MSM_CPUBUSNO_MAX; ++cpuBusId)
        {
            if (!((cpuBusValid >> cpuBusId) & 0x1))
            {
                DBG(2, "CPU bus " , cpuBusId, " is disabled on package " , cpuBusPackageId);
                continue;
            }

            int rootBus = (cpuBusNo[(int)(cpuBusId / 4)] >> ((cpuBusId % 4) * 8)) & 0xff;
            rootbus_map[((s2bus.first << 8) | rootBus)] = cpuBusPackageId;
            DBG(2,  "Mapped CPU bus #" , std::dec , cpuBusId , std::hex , " (domain=0x" , s2bus.first , " bus=0x" , rootBus , ") to " , std::dec , "package" , cpuBusPackageId);
        }

        mapped = true;
    }

    return mapped;
}

#define SPR_IDX_ACCEL_COUNTER_MAX_NUM (8)
#define SPR_QAT_ACCEL_COUNTER_MAX_NUM (16)

struct idx_accel_dev_info {
    uint64 mem_bar;
    uint32 numa_node;
    uint32 socket_id;
    uint32 domain;
    uint32 bus;
    uint32 dev;
    uint32 func;
};

bool getIDXDevBAR(std::vector<std::pair<uint32, uint32> > & socket2bus, uint32 dev, uint32 func, std::map<int, int> &bus2socket, std::vector<struct idx_accel_dev_info> &idx_devs)
{
    uint64 memBar = 0x0;
    uint32 pciCmd = 0x0, pmCsr= 0x0;
    uint32 numaNode = 0xff;
    struct idx_accel_dev_info idx_dev;

    for (auto & s2bus : socket2bus)
    {
        memBar = 0x0;
        pciCmd = 0x0;

        PciHandleType IDXHandle(s2bus.first, s2bus.second, dev, func);
        IDXHandle.read64(SPR_IDX_ACCEL_BAR0_OFFSET, &memBar);
        IDXHandle.read32(SPR_IDX_ACCEL_PCICMD_OFFSET, &pciCmd);
        IDXHandle.read32(SPR_IDX_ACCEL_PMCSR_OFFSET, &pmCsr);
        DBG(1, "IDX - BAR0 of B:0x", std::hex, s2bus.second, ",D:0x", std::hex, dev, ",F:0x", std::hex, func, " is (memBar=0x",
            std::hex, memBar, ", pciCmd=0x", std::hex, pciCmd, ")", std::dec);
        if (memBar == 0x0
#ifndef _MSC_VER
            // on Windows the driver does not set the bit: do not check
            || (pciCmd & 0x02) == 0x0
#endif
            ) //Check BAR0 is valid or NOT.
        {
            std::cerr << "Warning: IDX - BAR0 of B:0x" << std::hex << s2bus.second << ",D:0x" << std::hex << dev << ",F:0x" << std::hex << func
                << " is invalid(memBar=0x" << std::hex << memBar << ", pciCmd=0x" << std::hex << pciCmd <<"), skipped." << std::dec << std::endl;
            continue;
        }

        if ((pmCsr & 0x03) == 0x3) //Check power state
        {
            std::cout << "Warning: IDX - Power state of B:0x" << std::hex << s2bus.second << ",D:0x" << std::hex << dev << ",F:0x" << std::hex << func \
                << " is off, skipped." << std::endl;
            continue;
        }

        numaNode = 0xff;
#ifdef __linux__
        std::ostringstream devNumaNodePath(std::ostringstream::out);
        devNumaNodePath << std::string("/sys/bus/pci/devices/") <<
            std::hex << std::setw(4) << std::setfill('0') << s2bus.first << ":" <<
            std::hex << std::setw(2) << std::setfill('0') << s2bus.second << ":" <<
            std::hex << std::setw(2) << std::setfill('0') << dev << "." <<
            std::hex << func << "/numa_node";
        const std::string devNumaNodeStr = readSysFS(devNumaNodePath.str().c_str(), true);
        if (devNumaNodeStr.size())
        {
            numaNode = std::atoi(devNumaNodeStr.c_str());
            if (numaNode == (std::numeric_limits<uint32>::max)())
            {
                numaNode = 0xff; //translate to special value for numa disable case. 
            }
        }
        DBG(2, "IDX DEBUG: numa node file path=" , devNumaNodePath.str().c_str()  , ", value=" , numaNode);
#endif
        idx_dev.mem_bar = memBar;
        idx_dev.numa_node = numaNode;
        idx_dev.socket_id = 0xff;
        idx_dev.domain = s2bus.first;
        idx_dev.bus = s2bus.second;
        idx_dev.dev = dev;
        idx_dev.func = func;
        if (bus2socket.find(((s2bus.first << 8 ) | s2bus.second)) != bus2socket.end())
        {
            idx_dev.socket_id = bus2socket.at(((s2bus.first << 8 ) | s2bus.second));
        }

        idx_devs.push_back(idx_dev);
    }

    return true;
}

void PCM::initUncoreObjects()
{
    if (hasPCICFGUncore() && MSR.size())
    {
        int i = 0;
        bool failed = false;
        try
        {
            for (i = 0; i < (int)num_sockets; ++i)
            {
                serverUncorePMUs.push_back(std::make_shared<ServerUncorePMUs>(i, this));
            }
        }
        catch (std::runtime_error & e)
        {
            std::cerr << e.what() << "\n";
            failed = true;
        }
        catch (...)
        {
            failed = true;
        }
        if (failed)
        {
            serverUncorePMUs.clear();
            std::cerr << "Can not access server uncore PCI configuration space. Access to uncore counters (memory and QPI bandwidth) is disabled.\n";
#ifdef _MSC_VER
            std::cerr << "You must have signed msr.sys driver in your current directory and have administrator rights to run this program.\n";
#else
            DBG(1, "you must have read and write permissions for /proc/bus/pci/7f/10.* and /proc/bus/pci/ff/10.* devices (the 'chown' command can help).");
            DBG(1, "you must have read and write permissions for /dev/mem device (the 'chown' command can help).");
            DBG(1, "you must have read permission for /sys/firmware/acpi/tables/MCFG device (the 'chmod' command can help).");
            std::cerr << "You must be root to access server uncore counters in PCM.\n";
#endif
        }
    } else if(hasClientMCCounters() && MSR.size())
    {
       // initialize memory bandwidth counting
       try
       {
           switch (cpu_family_model)
           {
           case TGL:
           case ADL: // TGLClientBW works fine for ADL
           case RPL: // TGLClientBW works fine for RPL
           case MTL: // TGLClientBW works fine for MTL
           case LNL: // TGLClientBW works fine for LNL
           case ARL: // TGLClientBW works fine for ARL
           case PTL: // TGLClientBW works fine for PTL
               clientBW = std::make_shared<TGLClientBW>();
               break;
/*         Disabled since ADLClientBW requires 2x multiplier for BW on top
           case ADL:
           case RPL:
               clientBW = std::make_shared<ADLClientBW>();
               break;
*/
           default:
               clientBW = std::make_shared<ClientBW>();
           }
           clientImcReads = std::make_shared<CounterWidthExtender>(
               new CounterWidthExtender::ClientImcReadsCounter(clientBW), 32, 10000);
           clientImcWrites = std::make_shared<CounterWidthExtender>(
               new CounterWidthExtender::ClientImcWritesCounter(clientBW), 32, 10000);
           clientGtRequests = std::make_shared<CounterWidthExtender>(
               new CounterWidthExtender::ClientGtRequestsCounter(clientBW), 32, 10000);
           clientIaRequests = std::make_shared<CounterWidthExtender>(
               new CounterWidthExtender::ClientIaRequestsCounter(clientBW), 32, 10000);
           clientIoRequests = std::make_shared<CounterWidthExtender>(
               new CounterWidthExtender::ClientIoRequestsCounter(clientBW), 32, 10000);

       } catch(...)
       {
           std::cerr << "Can not read memory controller counter information from PCI configuration space. Access to memory bandwidth counters is not possible.\n";
           #ifdef _MSC_VER
           // TODO: add message here
           #endif
           #ifdef __linux__
           std::cerr << "You must be root to access these SandyBridge/IvyBridge/Haswell counters in PCM. \n";
           #endif
       }
    }
    switch (cpu_family_model)
    {
    case ICX:
    case SNOWRIDGE:
    case SPR:
    case EMR:
    case GNR:
    case GNR_D:
    case GRR:
    case SRF:
        {
            bool failed = false;
            try
            {
                initSocket2Ubox0Bus();
            }
            catch (std::exception& e)
            {
                std::cerr << e.what() << "\n";
                failed = true;
            }
            catch (...)
            {
                failed = true;
            }
            if (failed)
            {
                std::cerr << "Can not read PCI configuration space bus mapping. Access to uncore counters is disabled.\n";
            }
        }
        break;
    }
    if (cpu_family_model == ICX || cpu_family_model == SNOWRIDGE)
    {
        for (size_t s = 0; s < (size_t)num_sockets && s < socket2UBOX0bus.size() && s < serverUncorePMUs.size(); ++s)
        {
            serverBW.push_back(std::make_shared<ServerBW>(serverUncorePMUs[s]->getNumMC(), socket2UBOX0bus[s].first, socket2UBOX0bus[s].second));
            DBG(2,  " Added serverBW object serverUncorePMUs[s]->getNumMC() = " , serverUncorePMUs[s]->getNumMC());
        }
        if (socket2UBOX0bus.size() != (size_t)num_sockets)
        {
            std::cerr << "PCM warning: found " << socket2UBOX0bus.size() << " uboxes. Expected " << num_sockets << std::endl;
        }
    }

    if (useLinuxPerfForUncore())
    {
        initUncorePMUsPerf();
    }
    else
    {
        initUncorePMUsDirect();
    }

    //TPMIHandle::setVerbose(true);
    try {
        if (isServerCPU() && TPMIHandle::getNumInstances() > 0)
        {
            const auto nInstances = TPMIHandle::getNumInstances();
            DBG(1, "TPMIHandle::getNumInstances(): ", nInstances);
            UFSStatus.resize(num_sockets);
            for (uint32 i = 0; i < (uint32)nInstances; ++i)
            {
                uint32 socket = (std::numeric_limits<uint32>::max)(); // invalid socket by default
                try {
                    TPMIHandle h(i, UFS_ID, UFS_FABRIC_CLUSTER_OFFSET * sizeof(uint64));
                    const auto numaNode = h.getNUMANode();
                    DBG(1, "Instance ", i, " NUMA node: ", numaNode);
                    if (numaNode >= 0)
                    {
                        const auto socketTmp = mapNUMANodeToSocket(numaNode);
                        DBG(1, "Instance ", i, " mapped to socket: ", socketTmp);
                        if (socketTmp >= 0 && socketTmp < (int32)num_sockets)
                        {
                            socket = (uint32)socketTmp;
                        }
                        else
                        {
                            socket = 0;
                            std::cerr << "WARNING: Could not map UFS TPMI instance " << i << " NUMA node " << numaNode << " to socket. Assuming socket 0.\n";
                        }
                    }
                    else
                    {
                        socket = 0;
                        std::cerr << "WARNING: Could not map UFS TPMI instance " << i << " to NUMA node. Assuming socket 0.\n";
                    }
                    DBG(1, "Instance ", i, " Socket ", socket, " dies: ", h.getNumEntries());
                    for (size_t die = 0; die < h.getNumEntries(); ++die)
                    {
                        const auto clusterOffset = extract_bits(h.read64(die), 0, 7);
                        assert(socket < UFSStatus.size());
                        UFSStatus[socket].push_back(
                            UFSStatusEntry(
                                std::make_shared<TPMIHandle>(i, UFS_ID, (clusterOffset + UFS_STATUS)* sizeof(uint64)),
                                die));
                    }
                } catch (std::exception & e)
                {
                    std::cerr << "ERROR: Could not open UFS TPMI register on socket " << socket << " instance " << i << ". Uncore frequency metrics will be unavailable. Exception details: " << e.what() << "\n";
                }
            }
        }
    } catch (std::exception & e)
    {
        std::cerr << "ERROR: Could not initialize TPMI. Uncore frequency metrics will be unavailable. Exception details: " << e.what() << "\n";
    }

    for (uint32 s = 0; s < (uint32)num_sockets && !quietMode; ++s)
    {
        std::cerr << "Socket " << s << ":" <<
            " " << getMaxNumOfUncorePMUs(PCU_PMU_ID, s) << " PCU units detected."
            " " << ((s < iioPMUs.size()) ? iioPMUs[s].size() : 0) << " IIO units detected."
            " " << ((s < irpPMUs.size()) ? irpPMUs[s].size() : 0) << " IRP units detected."
            " " << getMaxNumOfUncorePMUs(CBO_PMU_ID, s) << " CHA/CBO units detected."
            " " << getMaxNumOfUncorePMUs(MDF_PMU_ID, s) << " MDF units detected."
            " " << getMaxNumOfUncorePMUs(UBOX_PMU_ID, s) << " UBOX units detected."
            " " << ((s < cxlPMUs.size()) ? cxlPMUs[s].size() : 0) << " CXL units detected."
            " " << getMaxNumOfUncorePMUs(PCIE_GEN5x16_PMU_ID, s) << " PCIE_GEN5x16 units detected."
            " " << getMaxNumOfUncorePMUs(PCIE_GEN5x8_PMU_ID, s) << " PCIE_GEN5x8 units detected."
            "\n";
    }
}

void PCM::globalFreezeUncoreCounters()
{
    globalFreezeUncoreCountersInternal(1ULL);
}

void PCM::globalUnfreezeUncoreCounters()
{
    globalFreezeUncoreCountersInternal(0ULL);
}

// 1 : freeze
// 0 : unfreeze
void PCM::globalFreezeUncoreCountersInternal(const unsigned long long int freeze)
{
    for (uint32 s = 0; s < (uint32)num_sockets; ++s)
    {
        auto& handle = MSR[socketRefCore[s]];
        switch (cpu_family_model)
        {
        case SPR:
        case EMR:
            handle->write(SPR_MSR_UNCORE_PMON_GLOBAL_CTL, freeze);
            break;
        case SKX:
        case ICX:
            handle->write(MSR_UNCORE_PMON_GLOBAL_CTL, (1ULL - freeze) << 61ULL);
            break;
        case HASWELLX:
        case BDX:
            handle->write(MSR_UNCORE_PMON_GLOBAL_CTL, (1ULL - freeze) << 29ULL);
            break;
        case IVYTOWN:
            handle->write(IVT_MSR_UNCORE_PMON_GLOBAL_CTL, (1ULL - freeze) << 29ULL);
            break;
        }
    }
}


void PCM::initUncorePMUsDirect()
{
    uncorePMUs.resize(num_sockets);
    for (uint32 s = 0; s < (uint32)num_sockets; ++s)
    {
        auto & handle = MSR[socketRefCore[s]];
        // unfreeze uncore PMUs
        globalUnfreezeUncoreCounters();

        switch (cpu_family_model)
        {
        case IVYTOWN:
        case JAKETOWN:
            uncorePMUs[s].resize(1);
            {
            std::vector<std::shared_ptr<HWRegister> >   CounterControlRegs{
                    std::make_shared<MSRRegister>(handle, JKTIVT_UBOX_MSR_PMON_CTL0_ADDR),
                    std::make_shared<MSRRegister>(handle, JKTIVT_UBOX_MSR_PMON_CTL1_ADDR)
                },
                                                        CounterValueRegs{
                    std::make_shared<MSRRegister>(handle, JKTIVT_UBOX_MSR_PMON_CTR0_ADDR),
                    std::make_shared<MSRRegister>(handle, JKTIVT_UBOX_MSR_PMON_CTR1_ADDR)
                };
            uncorePMUs[s][0][UBOX_PMU_ID].push_back(
                std::make_shared<UncorePMU>(
                    std::shared_ptr<MSRRegister>(),
                    CounterControlRegs,
                    CounterValueRegs,
                    std::make_shared<MSRRegister>(handle, JKTIVT_UCLK_FIXED_CTL_ADDR),
                    std::make_shared<MSRRegister>(handle, JKTIVT_UCLK_FIXED_CTR_ADDR)
                )
            );
            }
            break;
        case SPR:
        case EMR:
            uncorePMUs[s].resize(1);
            {
            std::vector<std::shared_ptr<HWRegister> >   CounterControlRegs{
                    std::make_shared<MSRRegister>(handle, SPR_UBOX_MSR_PMON_CTL0_ADDR),
                    std::make_shared<MSRRegister>(handle, SPR_UBOX_MSR_PMON_CTL1_ADDR)
            },
                CounterValueRegs{
                    std::make_shared<MSRRegister>(handle, SPR_UBOX_MSR_PMON_CTR0_ADDR),
                    std::make_shared<MSRRegister>(handle, SPR_UBOX_MSR_PMON_CTR1_ADDR)
            };
            uncorePMUs[s][0][UBOX_PMU_ID].push_back(
                std::make_shared<UncorePMU>(
                    std::make_shared<MSRRegister>(handle, SPR_UBOX_MSR_PMON_BOX_CTL_ADDR),
                    CounterControlRegs,
                    CounterValueRegs,
                    std::make_shared<MSRRegister>(handle, SPR_UCLK_FIXED_CTL_ADDR),
                    std::make_shared<MSRRegister>(handle, SPR_UCLK_FIXED_CTR_ADDR)
                )
            );
            }
            break;
        case SRF:
        case GNR:
        case GNR_D:
            uncorePMUs[s].resize(1);
            {
            std::vector<std::shared_ptr<HWRegister> >   CounterControlRegs{
                    std::make_shared<MSRRegister>(handle, BHS_UBOX_MSR_PMON_CTL0_ADDR),
                    std::make_shared<MSRRegister>(handle, BHS_UBOX_MSR_PMON_CTL1_ADDR)
            },
                CounterValueRegs{
                    std::make_shared<MSRRegister>(handle, BHS_UBOX_MSR_PMON_CTR0_ADDR),
                    std::make_shared<MSRRegister>(handle, BHS_UBOX_MSR_PMON_CTR1_ADDR),
            };
            uncorePMUs[s][0][UBOX_PMU_ID].push_back(
                std::make_shared<UncorePMU>(
                    std::make_shared<MSRRegister>(handle, BHS_UBOX_MSR_PMON_BOX_CTL_ADDR),
                    CounterControlRegs,
                    CounterValueRegs,
                    std::make_shared<MSRRegister>(handle, BHS_UCLK_FIXED_CTL_ADDR),
                    std::make_shared<MSRRegister>(handle, BHS_UCLK_FIXED_CTR_ADDR)
                )
            );
            }
            break;
        case GRR:
            uncorePMUs[s].resize(1);
            {
            std::vector<std::shared_ptr<HWRegister> >   CounterControlRegs{
                    std::make_shared<MSRRegister>(handle, GRR_UBOX_MSR_PMON_CTL0_ADDR),
                    std::make_shared<MSRRegister>(handle, GRR_UBOX_MSR_PMON_CTL1_ADDR)
            },
                CounterValueRegs{
                    std::make_shared<MSRRegister>(handle, GRR_UBOX_MSR_PMON_CTR0_ADDR),
                    std::make_shared<MSRRegister>(handle, GRR_UBOX_MSR_PMON_CTR1_ADDR)
            };
            uncorePMUs[s][0][UBOX_PMU_ID].push_back(
                std::make_shared<UncorePMU>(
                    std::make_shared<MSRRegister>(handle, GRR_UBOX_MSR_PMON_BOX_CTL_ADDR),
                    CounterControlRegs,
                    CounterValueRegs,
                    std::make_shared<MSRRegister>(handle, GRR_UCLK_FIXED_CTL_ADDR),
                    std::make_shared<MSRRegister>(handle, GRR_UCLK_FIXED_CTR_ADDR)
                )
            );
            }
            break;
        default:
            if (isServerCPU() && hasPCICFGUncore())
            {
            uncorePMUs[s].resize(1);
            {
            std::vector<std::shared_ptr<HWRegister> >   CounterControlRegs{
                    std::make_shared<MSRRegister>(handle, UBOX_MSR_PMON_CTL0_ADDR),
                    std::make_shared<MSRRegister>(handle, UBOX_MSR_PMON_CTL1_ADDR),
            },
                CounterValueRegs{
                    std::make_shared<MSRRegister>(handle, UBOX_MSR_PMON_CTR0_ADDR),
                    std::make_shared<MSRRegister>(handle, UBOX_MSR_PMON_CTR1_ADDR),
            };
            uncorePMUs[s][0][UBOX_PMU_ID].push_back(
                std::make_shared<UncorePMU>(
                    std::shared_ptr<MSRRegister>(),
                    CounterControlRegs,
                    CounterValueRegs,
                    std::make_shared<MSRRegister>(handle, UCLK_FIXED_CTL_ADDR),
                    std::make_shared<MSRRegister>(handle, UCLK_FIXED_CTR_ADDR)
                )
            );
            }
            }
        }

        auto addPMUsFromDiscoveryRef = [this, &handle, &s](std::vector<UncorePMURef>& out, const unsigned int pmuType, const int filter0 = -1)
        {
            if (uncorePMUDiscovery.get())
            {
                for (size_t die = 0; die < uncorePMUDiscovery->getNumDies(s); ++die)
                {
                    for (size_t box = 0; box < uncorePMUDiscovery->getNumBoxes(pmuType, s, die); ++box)
                    {
                        if (uncorePMUDiscovery->getBoxAccessType(pmuType, s, die, box) == UncorePMUDiscovery::accessTypeEnum::MSR
                            && uncorePMUDiscovery->getBoxNumRegs(pmuType, s, die, box) >= 4)
                        {
                            out.push_back(
                                std::make_shared<UncorePMU>(
                                    std::make_shared<MSRRegister>(handle, uncorePMUDiscovery->getBoxCtlAddr(pmuType, s, die, box)),
                                    std::make_shared<MSRRegister>(handle, uncorePMUDiscovery->getBoxCtlAddr(pmuType, s, die, box, 0)),
                                    std::make_shared<MSRRegister>(handle, uncorePMUDiscovery->getBoxCtlAddr(pmuType, s, die, box, 1)),
                                    std::make_shared<MSRRegister>(handle, uncorePMUDiscovery->getBoxCtlAddr(pmuType, s, die, box, 2)),
                                    std::make_shared<MSRRegister>(handle, uncorePMUDiscovery->getBoxCtlAddr(pmuType, s, die, box, 3)),
                                    std::make_shared<MSRRegister>(handle, uncorePMUDiscovery->getBoxCtrAddr(pmuType, s, die, box, 0)),
                                    std::make_shared<MSRRegister>(handle, uncorePMUDiscovery->getBoxCtrAddr(pmuType, s, die, box, 1)),
                                    std::make_shared<MSRRegister>(handle, uncorePMUDiscovery->getBoxCtrAddr(pmuType, s, die, box, 2)),
                                    std::make_shared<MSRRegister>(handle, uncorePMUDiscovery->getBoxCtrAddr(pmuType, s, die, box, 3)),
                                    std::shared_ptr<MSRRegister>(),
                                    std::shared_ptr<MSRRegister>(),
                                    (filter0 < 0) ? std::shared_ptr<MSRRegister>() : std::make_shared<MSRRegister>(handle, uncorePMUDiscovery->getBoxCtlAddr(pmuType, s, die, box) + filter0) // filters not supported by discovery
                                )
                            );
                        }
                    }
                }
            }
        };

        switch (cpu_family_model)
        {
        case IVYTOWN:
        case JAKETOWN:
            uncorePMUs[s].resize(1);
            uncorePMUs[s][0][PCU_PMU_ID].push_back(
                std::make_shared<UncorePMU>(
                    std::make_shared<MSRRegister>(handle, JKTIVT_PCU_MSR_PMON_BOX_CTL_ADDR),
                    std::make_shared<MSRRegister>(handle, JKTIVT_PCU_MSR_PMON_CTL0_ADDR),
                    std::make_shared<MSRRegister>(handle, JKTIVT_PCU_MSR_PMON_CTL1_ADDR),
                    std::make_shared<MSRRegister>(handle, JKTIVT_PCU_MSR_PMON_CTL2_ADDR),
                    std::make_shared<MSRRegister>(handle, JKTIVT_PCU_MSR_PMON_CTL3_ADDR),
                    std::make_shared<MSRRegister>(handle, JKTIVT_PCU_MSR_PMON_CTR0_ADDR),
                    std::make_shared<MSRRegister>(handle, JKTIVT_PCU_MSR_PMON_CTR1_ADDR),
                    std::make_shared<MSRRegister>(handle, JKTIVT_PCU_MSR_PMON_CTR2_ADDR),
                    std::make_shared<MSRRegister>(handle, JKTIVT_PCU_MSR_PMON_CTR3_ADDR),
                    std::shared_ptr<MSRRegister>(),
                    std::shared_ptr<MSRRegister>(),
                    std::make_shared<MSRRegister>(handle, JKTIVT_PCU_MSR_PMON_BOX_FILTER_ADDR)
                )
            );
            break;
        case BDX_DE:
        case BDX:
        case KNL:
        case HASWELLX:
        case SKX:
        case ICX:
            uncorePMUs[s].resize(1);
            uncorePMUs[s][0][PCU_PMU_ID].push_back(
                std::make_shared<UncorePMU>(
                    std::make_shared<MSRRegister>(handle, HSX_PCU_MSR_PMON_BOX_CTL_ADDR),
                    std::make_shared<MSRRegister>(handle, HSX_PCU_MSR_PMON_CTL0_ADDR),
                    std::make_shared<MSRRegister>(handle, HSX_PCU_MSR_PMON_CTL1_ADDR),
                    std::make_shared<MSRRegister>(handle, HSX_PCU_MSR_PMON_CTL2_ADDR),
                    std::make_shared<MSRRegister>(handle, HSX_PCU_MSR_PMON_CTL3_ADDR),
                    std::make_shared<MSRRegister>(handle, HSX_PCU_MSR_PMON_CTR0_ADDR),
                    std::make_shared<MSRRegister>(handle, HSX_PCU_MSR_PMON_CTR1_ADDR),
                    std::make_shared<MSRRegister>(handle, HSX_PCU_MSR_PMON_CTR2_ADDR),
                    std::make_shared<MSRRegister>(handle, HSX_PCU_MSR_PMON_CTR3_ADDR),
                    std::shared_ptr<MSRRegister>(),
                    std::shared_ptr<MSRRegister>(),
                    std::make_shared<MSRRegister>(handle, HSX_PCU_MSR_PMON_BOX_FILTER_ADDR)
                )
            );
            break;
        case SPR:
        case EMR:
        case GNR:
        case GNR_D:
        case SRF:
            uncorePMUs[s].resize(1);
            addPMUsFromDiscoveryRef(uncorePMUs[s][0][PCU_PMU_ID], SPR_PCU_BOX_TYPE, 0xE);
            if (uncorePMUs[s][0][PCU_PMU_ID].empty())
            {
                std::cerr << "WARNING: PCU PMU not found\n";
            }
            break;
        }

        // add MDF PMUs
        auto addMDFPMUs = [&](const unsigned int boxType)
        {
            uncorePMUs[s].resize(1);
            addPMUsFromDiscoveryRef(uncorePMUs[s][0][MDF_PMU_ID], boxType);
            if (uncorePMUs[s][0][MDF_PMU_ID].empty())
            {
                std::cerr << "WARNING: MDF PMU not found\n";
            }
        };
        switch (cpu_family_model)
        {
        case SPR:
        case EMR:
            addMDFPMUs(SPR_MDF_BOX_TYPE);
            break;
        case GNR:
        case GNR_D:
        case SRF:
            addMDFPMUs(BHS_MDF_BOX_TYPE);
            break;
        }

        auto addPCICFGPMUsFromDiscoveryRef = [this, &s](std::vector<UncorePMURef>& out, const unsigned int BoxType)
        {
            getPCICFGPMUsFromDiscovery(BoxType, s, [&out](const UncorePMU& pmu) {
                out.push_back(std::make_shared<UncorePMU>(pmu));
            });
        };

        auto addPCICFGPMUsFallback = [&s](std::vector<UncorePMURef>& out, const std::vector<uint32> & DIDs, const char * info = nullptr)
        {
                if (s == 0)
                {
                    if (info)
                    {
#ifndef PCM_SILENT
                        std::cerr << info;
#endif
                    }
                    forAllIntelDevices([&DIDs, &out](const uint32 group, const uint32 bus, const uint32 device, const uint32 function, const uint32 device_id)
                    {
                        for (const auto & did: DIDs)
                        {
                            if (device_id == did)
                            {
                                auto handle = std::make_shared<PciHandleType>(group, bus, device, function);
                                const size_t n_regs = 4;
                                std::vector<std::shared_ptr<HWRegister> > CounterControlRegs, CounterValueRegs;
                                for (size_t r = 0; r < n_regs; ++r)
                                {
                                    CounterControlRegs.push_back(std::make_shared<PCICFGRegister64>(handle, BHS_PCIE_GEN5_PCI_PMON_CTL0_ADDR + sizeof(uint64)*r));
                                    CounterValueRegs.push_back(std::make_shared<PCICFGRegister64>(handle, BHS_PCIE_GEN5_PCI_PMON_CTR0_ADDR + sizeof(uint64)*r));
                                }
                                auto boxCtlRegister = std::make_shared<PCICFGRegister64>(handle, BHS_PCIE_GEN5_PCI_PMON_BOX_CTL_ADDR);
                                out.push_back(std::make_shared<UncorePMU>(boxCtlRegister, CounterControlRegs, CounterValueRegs));
                            }
                        }
                    });
                }
        };

        switch (cpu_family_model)
        {
            case GNR:
            case GNR_D:
            case GRR:
            case SRF:
                uncorePMUs[s].resize(1);
                if (safe_getenv("PCM_NO_PCIE_GEN5_DISCOVERY") == std::string("1"))
                {
                    addPCICFGPMUsFallback(uncorePMUs[s][0][PCIE_GEN5x16_PMU_ID], { 0x0DB0, 0x0DB1, 0x0DB2, 0x0DB3 },
                        "Info: PCM_NO_PCIE_GEN5_DISCOVERY=1 is set, detecting PCIE_GEN5 x16 PMUs manually and mapping them to socket 0.\n");
                    addPCICFGPMUsFallback(uncorePMUs[s][0][PCIE_GEN5x8_PMU_ID], { 0x0DB6, 0x0DB7, 0x0DB8, 0x0DB9 },
                        "Info: PCM_NO_PCIE_GEN5_DISCOVERY=1 is set, detecting PCIE_GEN5 x8 PMUs manually and mapping them to socket 0.\n");
                }
                else
                {
                    addPCICFGPMUsFromDiscoveryRef(uncorePMUs[s][0][PCIE_GEN5x16_PMU_ID], BHS_PCIE_GEN5x16_TYPE);
                    addPCICFGPMUsFromDiscoveryRef(uncorePMUs[s][0][PCIE_GEN5x8_PMU_ID], BHS_PCIE_GEN5x8_TYPE);
                }
                break;
        }
    }

    // init IIO addresses
    iioPMUs.resize(num_sockets);
    switch (cpu_family_model)
    {
    case PCM::SKX:
        for (uint32 s = 0; s < (uint32)num_sockets; ++s)
        {
            auto & handle = MSR[socketRefCore[s]];
            for (int unit = 0; unit < SKX_IIO_STACK_COUNT; ++unit)
            {
                iioPMUs[s][unit] = UncorePMU(
                    std::make_shared<MSRRegister>(handle, SKX_IIO_CBDMA_UNIT_CTL + SKX_IIO_PM_REG_STEP * unit),
                    std::make_shared<MSRRegister>(handle, SKX_IIO_CBDMA_CTL0 + SKX_IIO_PM_REG_STEP * unit + 0),
                    std::make_shared<MSRRegister>(handle, SKX_IIO_CBDMA_CTL0 + SKX_IIO_PM_REG_STEP * unit + 1),
                    std::make_shared<MSRRegister>(handle, SKX_IIO_CBDMA_CTL0 + SKX_IIO_PM_REG_STEP * unit + 2),
                    std::make_shared<MSRRegister>(handle, SKX_IIO_CBDMA_CTL0 + SKX_IIO_PM_REG_STEP * unit + 3),
                    std::make_shared<MSRRegister>(handle, SKX_IIO_CBDMA_CTR0 + SKX_IIO_PM_REG_STEP * unit + 0),
                    std::make_shared<MSRRegister>(handle, SKX_IIO_CBDMA_CTR0 + SKX_IIO_PM_REG_STEP * unit + 1),
                    std::make_shared<MSRRegister>(handle, SKX_IIO_CBDMA_CTR0 + SKX_IIO_PM_REG_STEP * unit + 2),
                    std::make_shared<MSRRegister>(handle, SKX_IIO_CBDMA_CTR0 + SKX_IIO_PM_REG_STEP * unit + 3)
                );
            }
        }
        break;
    case PCM::ICX:
        for (uint32 s = 0; s < (uint32)num_sockets; ++s)
        {
            auto & handle = MSR[socketRefCore[s]];
            for (int unit = 0; unit < ICX_IIO_STACK_COUNT; ++unit)
            {
                iioPMUs[s][unit] = UncorePMU(
                    std::make_shared<MSRRegister>(handle, ICX_IIO_UNIT_CTL[unit]),
                    std::make_shared<MSRRegister>(handle, ICX_IIO_UNIT_CTL[unit] + ICX_IIO_CTL_REG_OFFSET + 0),
                    std::make_shared<MSRRegister>(handle, ICX_IIO_UNIT_CTL[unit] + ICX_IIO_CTL_REG_OFFSET + 1),
                    std::make_shared<MSRRegister>(handle, ICX_IIO_UNIT_CTL[unit] + ICX_IIO_CTL_REG_OFFSET + 2),
                    std::make_shared<MSRRegister>(handle, ICX_IIO_UNIT_CTL[unit] + ICX_IIO_CTL_REG_OFFSET + 3),
                    std::make_shared<MSRRegister>(handle, ICX_IIO_UNIT_CTL[unit] + ICX_IIO_CTR_REG_OFFSET + 0),
                    std::make_shared<MSRRegister>(handle, ICX_IIO_UNIT_CTL[unit] + ICX_IIO_CTR_REG_OFFSET + 1),
                    std::make_shared<MSRRegister>(handle, ICX_IIO_UNIT_CTL[unit] + ICX_IIO_CTR_REG_OFFSET + 2),
                    std::make_shared<MSRRegister>(handle, ICX_IIO_UNIT_CTL[unit] + ICX_IIO_CTR_REG_OFFSET + 3)
                );
            }
        }
        break;
    case PCM::SNOWRIDGE:
        for (uint32 s = 0; s < (uint32)num_sockets; ++s)
        {
            auto & handle = MSR[socketRefCore[s]];
            for (int unit = 0; unit < SNR_IIO_STACK_COUNT; ++unit)
            {
                iioPMUs[s][unit] = UncorePMU(
                    std::make_shared<MSRRegister>(handle, SNR_IIO_CBDMA_UNIT_CTL + SNR_IIO_PM_REG_STEP * unit),
                    std::make_shared<MSRRegister>(handle, SNR_IIO_CBDMA_CTL0 + SNR_IIO_PM_REG_STEP * unit + 0),
                    std::make_shared<MSRRegister>(handle, SNR_IIO_CBDMA_CTL0 + SNR_IIO_PM_REG_STEP * unit + 1),
                    std::make_shared<MSRRegister>(handle, SNR_IIO_CBDMA_CTL0 + SNR_IIO_PM_REG_STEP * unit + 2),
                    std::make_shared<MSRRegister>(handle, SNR_IIO_CBDMA_CTL0 + SNR_IIO_PM_REG_STEP * unit + 3),
                    std::make_shared<MSRRegister>(handle, SNR_IIO_CBDMA_CTR0 + SNR_IIO_PM_REG_STEP * unit + 0),
                    std::make_shared<MSRRegister>(handle, SNR_IIO_CBDMA_CTR0 + SNR_IIO_PM_REG_STEP * unit + 1),
                    std::make_shared<MSRRegister>(handle, SNR_IIO_CBDMA_CTR0 + SNR_IIO_PM_REG_STEP * unit + 2),
                    std::make_shared<MSRRegister>(handle, SNR_IIO_CBDMA_CTR0 + SNR_IIO_PM_REG_STEP * unit + 3)
                );
            }
        }
        break;

    case PCM::SPR:
    case PCM::EMR:
        for (uint32 s = 0; s < (uint32)num_sockets; ++s)
        {
            auto & handle = MSR[socketRefCore[s]];
            for (int unit = 0; unit < SPR_M2IOSF_NUM; ++unit)
            {
                iioPMUs[s][unit] = UncorePMU(
                    std::make_shared<MSRRegister>(handle, SPR_M2IOSF_IIO_UNIT_CTL + SPR_M2IOSF_REG_STEP * unit),
                    std::make_shared<MSRRegister>(handle, SPR_M2IOSF_IIO_CTL0 + SPR_M2IOSF_REG_STEP * unit + 0),
                    std::make_shared<MSRRegister>(handle, SPR_M2IOSF_IIO_CTL0 + SPR_M2IOSF_REG_STEP * unit + 1),
                    std::make_shared<MSRRegister>(handle, SPR_M2IOSF_IIO_CTL0 + SPR_M2IOSF_REG_STEP * unit + 2),
                    std::make_shared<MSRRegister>(handle, SPR_M2IOSF_IIO_CTL0 + SPR_M2IOSF_REG_STEP * unit + 3),
                    std::make_shared<MSRRegister>(handle, SPR_M2IOSF_IIO_CTR0 + SPR_M2IOSF_REG_STEP * unit + 0),
                    std::make_shared<MSRRegister>(handle, SPR_M2IOSF_IIO_CTR0 + SPR_M2IOSF_REG_STEP * unit + 1),
                    std::make_shared<MSRRegister>(handle, SPR_M2IOSF_IIO_CTR0 + SPR_M2IOSF_REG_STEP * unit + 2),
                    std::make_shared<MSRRegister>(handle, SPR_M2IOSF_IIO_CTR0 + SPR_M2IOSF_REG_STEP * unit + 3)
                );
            }
        }
        break;
    case PCM::GNR:
    case PCM::GNR_D:
    case PCM::SRF:
        for (uint32 s = 0; s < (uint32)num_sockets; ++s)
        {
            auto & handle = MSR[socketRefCore[s]];
            for (int unit = 0; unit < BHS_M2IOSF_NUM; ++unit)
            {
                iioPMUs[s][unit] = UncorePMU(
                    std::make_shared<MSRRegister>(handle, BHS_M2IOSF_IIO_UNIT_CTL + BHS_M2IOSF_REG_STEP * unit),
                    std::make_shared<MSRRegister>(handle, BHS_M2IOSF_IIO_CTL0 + BHS_M2IOSF_REG_STEP * unit + 0),
                    std::make_shared<MSRRegister>(handle, BHS_M2IOSF_IIO_CTL0 + BHS_M2IOSF_REG_STEP * unit + 1),
                    std::make_shared<MSRRegister>(handle, BHS_M2IOSF_IIO_CTL0 + BHS_M2IOSF_REG_STEP * unit + 2),
                    std::make_shared<MSRRegister>(handle, BHS_M2IOSF_IIO_CTL0 + BHS_M2IOSF_REG_STEP * unit + 3),
                    std::make_shared<MSRRegister>(handle, BHS_M2IOSF_IIO_CTR0 + BHS_M2IOSF_REG_STEP * unit + 0),
                    std::make_shared<MSRRegister>(handle, BHS_M2IOSF_IIO_CTR0 + BHS_M2IOSF_REG_STEP * unit + 1),
                    std::make_shared<MSRRegister>(handle, BHS_M2IOSF_IIO_CTR0 + BHS_M2IOSF_REG_STEP * unit + 2),
                    std::make_shared<MSRRegister>(handle, BHS_M2IOSF_IIO_CTR0 + BHS_M2IOSF_REG_STEP * unit + 3)
                );
            }
        }
        break;
    case PCM::GRR:
        for (uint32 s = 0; s < (uint32)num_sockets; ++s)
        {
            auto & handle = MSR[socketRefCore[s]];
            for (int unit = 0; unit < GRR_M2IOSF_NUM; ++unit)
            {
                iioPMUs[s][unit] = UncorePMU(
                    std::make_shared<MSRRegister>(handle, GRR_M2IOSF_IIO_UNIT_CTL + GRR_M2IOSF_REG_STEP * unit),
                    std::make_shared<MSRRegister>(handle, GRR_M2IOSF_IIO_CTL0 + GRR_M2IOSF_REG_STEP * unit + 0),
                    std::make_shared<MSRRegister>(handle, GRR_M2IOSF_IIO_CTL0 + GRR_M2IOSF_REG_STEP * unit + 1),
                    std::make_shared<MSRRegister>(handle, GRR_M2IOSF_IIO_CTL0 + GRR_M2IOSF_REG_STEP * unit + 2),
                    std::make_shared<MSRRegister>(handle, GRR_M2IOSF_IIO_CTL0 + GRR_M2IOSF_REG_STEP * unit + 3),
                    std::make_shared<MSRRegister>(handle, GRR_M2IOSF_IIO_CTR0 + GRR_M2IOSF_REG_STEP * unit + 0),
                    std::make_shared<MSRRegister>(handle, GRR_M2IOSF_IIO_CTR0 + GRR_M2IOSF_REG_STEP * unit + 1),
                    std::make_shared<MSRRegister>(handle, GRR_M2IOSF_IIO_CTR0 + GRR_M2IOSF_REG_STEP * unit + 2),
                    std::make_shared<MSRRegister>(handle, GRR_M2IOSF_IIO_CTR0 + GRR_M2IOSF_REG_STEP * unit + 3)
                );
            }
        }
        break;
    }
    //init the IDX accelerator
    auto createIDXPMU = [](const size_t addr, const size_t mapSize, const size_t numaNode, const size_t socketId) -> IDX_PMU
    {
        const auto alignedAddr = addr & ~4095ULL;
        auto handle = std::make_shared<MMIORange>(alignedAddr, mapSize, false);
        auto pmon_offset = (handle->read64(SPR_IDX_ACCEL_PMON_BASE_OFFSET) & SPR_IDX_ACCEL_PMON_BASE_MASK)*SPR_IDX_ACCEL_PMON_BASE_RATIO;

        const auto n_regs = SPR_IDX_ACCEL_COUNTER_MAX_NUM;
        std::vector<std::shared_ptr<HWRegister> > CounterControlRegs, CounterValueRegs, CounterFilterWQRegs, CounterFilterENGRegs;
        std::vector<std::shared_ptr<HWRegister> > CounterFilterTCRegs, CounterFilterPGSZRegs, CounterFilterXFERSZRegs;

        for (size_t r = 0; r < n_regs; ++r)
        {
            CounterControlRegs.push_back(std::make_shared<MMIORegister64>(handle, (SPR_IDX_PMON_CTL_OFFSET(r) + pmon_offset)));
            CounterValueRegs.push_back(std::make_shared<MMIORegister64>(handle, (SPR_IDX_PMON_CTR_OFFSET(r) + pmon_offset)));
            CounterFilterWQRegs.push_back(std::make_shared<MMIORegister32>(handle, (SPR_IDX_PMON_FILTER_WQ_OFFSET(r) + pmon_offset)));
            CounterFilterENGRegs.push_back(std::make_shared<MMIORegister32>(handle, (SPR_IDX_PMON_FILTER_ENG_OFFSET(r) + pmon_offset)));
            CounterFilterTCRegs.push_back(std::make_shared<MMIORegister32>(handle, (SPR_IDX_PMON_FILTER_TC_OFFSET(r) + pmon_offset)));
            CounterFilterPGSZRegs.push_back(std::make_shared<MMIORegister32>(handle, (SPR_IDX_PMON_FILTER_PGSZ_OFFSET(r) + pmon_offset)));
            CounterFilterXFERSZRegs.push_back(std::make_shared<MMIORegister32>(handle, (SPR_IDX_PMON_FILTER_XFERSZ_OFFSET(r) + pmon_offset)));
        }

        return IDX_PMU(
            false,
            numaNode,
            socketId,
            std::make_shared<MMIORegister32>(handle, SPR_IDX_PMON_RESET_CTL_OFFSET + pmon_offset),
            std::make_shared<MMIORegister32>(handle, SPR_IDX_PMON_FREEZE_CTL_OFFSET + pmon_offset),
            std::make_shared<VirtualDummyRegister>(),
            CounterControlRegs,
            CounterValueRegs,
            CounterFilterWQRegs,
            CounterFilterENGRegs,
            CounterFilterTCRegs,
            CounterFilterPGSZRegs,
            CounterFilterXFERSZRegs
        );
    };

    //init the QAT accelerator
    auto createQATPMU = [](const size_t numaNode, const size_t socketId, const size_t domain, const size_t bus, const size_t dev, const size_t func) -> IDX_PMU
    {
        const auto n_regs = SPR_QAT_ACCEL_COUNTER_MAX_NUM;
        auto GlobalConfigReg= std::make_shared<QATTelemetryVirtualGeneralConfigRegister>(domain, bus, dev, func);
        std::vector<std::shared_ptr<HWRegister> > CounterControlRegs, CounterValueRegs, CounterFilterWQRegs, CounterFilterENGRegs;
        std::vector<std::shared_ptr<HWRegister> > CounterFilterTCRegs, CounterFilterPGSZRegs, CounterFilterXFERSZRegs;
        for (size_t r = 0; r < n_regs; ++r)
        {
            auto CounterControlReg= std::make_shared<QATTelemetryVirtualControlRegister>();
            CounterControlRegs.push_back(CounterControlReg);
            CounterValueRegs.push_back(std::make_shared<QATTelemetryVirtualCounterRegister>(GlobalConfigReg, CounterControlReg, r));
            CounterFilterWQRegs.push_back(std::make_shared<VirtualDummyRegister>()); //dummy
            CounterFilterENGRegs.push_back(std::make_shared<VirtualDummyRegister>()); //dummy
            CounterFilterTCRegs.push_back(std::make_shared<VirtualDummyRegister>()); //dummy
            CounterFilterPGSZRegs.push_back(std::make_shared<VirtualDummyRegister>()); //dummy
            CounterFilterXFERSZRegs.push_back(std::make_shared<VirtualDummyRegister>()); //dummy
        }

        return IDX_PMU(
            false,
            numaNode,
            socketId,
            std::make_shared<VirtualDummyRegister>(),
            std::make_shared<VirtualDummyRegister>(),
            GlobalConfigReg,
            CounterControlRegs,
            CounterValueRegs,
            CounterFilterWQRegs,
            CounterFilterENGRegs,
            CounterFilterTCRegs,
            CounterFilterPGSZRegs,
            CounterFilterXFERSZRegs
        );
    };

    if (supportIDXAccelDev() == true)
    {
        static const uint32 IAA_DEV_IDS[] = { 0x0CFE };
        static const uint32 DSA_DEV_IDS[] = { 0x0B25 };
        static const uint32 QAT_DEV_IDS[] = { 0x4940, 0x4942, 0x4944, 0x4946, 0x578a };
        std::vector<std::pair<uint32, uint32> > socket2IAAbus;
        std::vector<std::pair<uint32, uint32> > socket2DSAbus;
        std::vector<std::pair<uint32, uint32> > socket2QATbus;
        std::map<int, int> rootbusMap;

        //Enumerate IDX devices by PCIe bus scan
        initSocket2Bus(socket2IAAbus, SPR_IDX_IAA_REGISTER_DEV_ADDR, SPR_IDX_IAA_REGISTER_FUNC_ADDR, IAA_DEV_IDS, (uint32)sizeof(IAA_DEV_IDS) / sizeof(IAA_DEV_IDS[0]));
        initSocket2Bus(socket2DSAbus, SPR_IDX_DSA_REGISTER_DEV_ADDR, SPR_IDX_DSA_REGISTER_FUNC_ADDR, DSA_DEV_IDS, (uint32)sizeof(DSA_DEV_IDS) / sizeof(DSA_DEV_IDS[0]));
        initSocket2Bus(socket2QATbus, SPR_IDX_QAT_REGISTER_DEV_ADDR, SPR_IDX_QAT_REGISTER_FUNC_ADDR, QAT_DEV_IDS, (uint32)sizeof(QAT_DEV_IDS) / sizeof(QAT_DEV_IDS[0]));
#ifndef PCM_SILENT
        if (!quietMode) std::cerr << "INFO: IDX - Detected " << socket2IAAbus.size() << " IAA devices, " << socket2DSAbus.size() << " DSA devices, " << socket2QATbus.size() << " QAT devices. \n";
#endif
        initRootBusMap(rootbusMap);

        idxPMUs.resize(IDX_MAX);
        idxPMUs[IDX_IAA].clear();
        if (socket2IAAbus.size())
        {
            std::vector<struct idx_accel_dev_info> devInfos;
            getIDXDevBAR(socket2IAAbus, SPR_IDX_IAA_REGISTER_DEV_ADDR, SPR_IDX_IAA_REGISTER_FUNC_ADDR, rootbusMap, devInfos);
            for (auto & devInfo : devInfos)
            {
                idxPMUs[IDX_IAA].push_back(createIDXPMU(devInfo.mem_bar, SPR_IDX_ACCEL_BAR0_SIZE, devInfo.numa_node, devInfo.socket_id));
            }
        }

        idxPMUs[IDX_DSA].clear();
        if (socket2DSAbus.size())
        {
            std::vector<struct idx_accel_dev_info> devInfos;
            getIDXDevBAR(socket2DSAbus, SPR_IDX_DSA_REGISTER_DEV_ADDR, SPR_IDX_DSA_REGISTER_FUNC_ADDR, rootbusMap, devInfos);
            for (auto & devInfo : devInfos)
            {
                idxPMUs[IDX_DSA].push_back(createIDXPMU(devInfo.mem_bar, SPR_IDX_ACCEL_BAR0_SIZE, devInfo.numa_node, devInfo.socket_id));
            }
        }

        idxPMUs[IDX_QAT].clear();
#ifdef __linux__
        if (socket2QATbus.size())
        {
            std::vector<struct idx_accel_dev_info> devInfos;
            getIDXDevBAR(socket2QATbus, SPR_IDX_QAT_REGISTER_DEV_ADDR, SPR_IDX_QAT_REGISTER_FUNC_ADDR, rootbusMap, devInfos);
            for (auto & devInfo : devInfos)
            {
                std::ostringstream qat_TLMCTL_sysfs_path(std::ostringstream::out);
                /*parse telemetry follow rule of out of tree driver*/
                qat_TLMCTL_sysfs_path << std::string("/sys/bus/pci/devices/") <<
                    std::hex << std::setw(4) << std::setfill('0') << devInfo.domain << ":" <<
                    std::hex << std::setw(2) << std::setfill('0') << devInfo.bus << ":" <<
                    std::hex << std::setw(2) << std::setfill('0') << devInfo.dev << "." <<
                    std::hex << devInfo.func << "/telemetry/control";
                std::string qatTLMCTLStr = readSysFS(qat_TLMCTL_sysfs_path.str().c_str(), true);
                if (!qatTLMCTLStr.size()) //check TLM feature available or NOT.
                {
                    qat_TLMCTL_sysfs_path.str("");
                    /*parse telemetry follow rule of in tree driver*/
                    qat_TLMCTL_sysfs_path << std::string("/sys/kernel/debug/qat_4xxx_") <<
                        std::hex << std::setw(4) << std::setfill('0') << devInfo.domain << ":" <<
                        std::hex << std::setw(2) << std::setfill('0') << devInfo.bus << ":" <<
                        std::hex << std::setw(2) << std::setfill('0') << devInfo.dev << "." <<
                        std::hex << devInfo.func << "/telemetry/control";
                    qatTLMCTLStr = readSysFS(qat_TLMCTL_sysfs_path.str().c_str(), true);
                    if(!qatTLMCTLStr.size()){
                        if (!quietMode) std::cerr << "INFO: IDX - QAT telemetry feature of B:0x" << std::hex << devInfo.bus << ",D:0x" << devInfo.dev << ",F:0x" << devInfo.func \
                            << " is NOT available, skipped." << std::dec << std::endl;
                        continue;
                    }
                }
                idxPMUs[IDX_QAT].push_back(createQATPMU(devInfo.numa_node, devInfo.socket_id, devInfo.domain , devInfo.bus, devInfo.dev , devInfo.func));
            }
        }
#endif
    }

    // init IRP PMU
    int irpStacks = 0;
    size_t IRP_CTL_REG_OFFSET = 0;
    size_t IRP_CTR_REG_OFFSET = 0;
    const uint32* IRP_UNIT_CTL = nullptr;

    switch (getCPUFamilyModel())
    {
    case SKX:
        irpStacks = SKX_IIO_STACK_COUNT;
        IRP_CTL_REG_OFFSET = SKX_IRP_CTL_REG_OFFSET;
        IRP_CTR_REG_OFFSET = SKX_IRP_CTR_REG_OFFSET;
        IRP_UNIT_CTL = SKX_IRP_UNIT_CTL;
        break;
    case ICX:
        irpStacks = ICX_IIO_STACK_COUNT;
        IRP_CTL_REG_OFFSET = ICX_IRP_CTL_REG_OFFSET;
        IRP_CTR_REG_OFFSET = ICX_IRP_CTR_REG_OFFSET;
        IRP_UNIT_CTL = ICX_IRP_UNIT_CTL;
        break;
    case SNOWRIDGE:
        irpStacks = SNR_IIO_STACK_COUNT;
        IRP_CTL_REG_OFFSET = SNR_IRP_CTL_REG_OFFSET;
        IRP_CTR_REG_OFFSET = SNR_IRP_CTR_REG_OFFSET;
        IRP_UNIT_CTL = SNR_IRP_UNIT_CTL;
        break;
    case SPR:
    case EMR:
        irpStacks = SPR_M2IOSF_NUM;
        IRP_CTL_REG_OFFSET = SPR_IRP_CTL_REG_OFFSET;
        IRP_CTR_REG_OFFSET = SPR_IRP_CTR_REG_OFFSET;
        IRP_UNIT_CTL = SPR_IRP_UNIT_CTL;
        break;
    case GNR:
    case GNR_D:
    case SRF:
        irpStacks = BHS_M2IOSF_NUM;
        IRP_CTL_REG_OFFSET = BHS_IRP_CTL_REG_OFFSET;
        IRP_CTR_REG_OFFSET = BHS_IRP_CTR_REG_OFFSET;
        IRP_UNIT_CTL = BHS_IRP_UNIT_CTL;
        break;
    case GRR:
        irpStacks = GRR_M2IOSF_NUM;
        IRP_CTL_REG_OFFSET = GRR_IRP_CTL_REG_OFFSET;
        IRP_CTR_REG_OFFSET = GRR_IRP_CTR_REG_OFFSET;
        IRP_UNIT_CTL = GRR_IRP_UNIT_CTL;
        break;
    }
    irpPMUs.resize(num_sockets);
    if (IRP_UNIT_CTL)
    {
        for (uint32 s = 0; s < (uint32)num_sockets; ++s)
        {
            auto& handle = MSR[socketRefCore[s]];
            for (int unit = 0; unit < irpStacks; ++unit)
            {
                irpPMUs[s][unit] = UncorePMU(
                    std::make_shared<MSRRegister>(handle, IRP_UNIT_CTL[unit]),
                    std::make_shared<MSRRegister>(handle, IRP_UNIT_CTL[unit] + IRP_CTL_REG_OFFSET + 0),
                    std::make_shared<MSRRegister>(handle, IRP_UNIT_CTL[unit] + IRP_CTL_REG_OFFSET + 1),
                    std::shared_ptr<MSRRegister>(),
                    std::shared_ptr<MSRRegister>(),
                    std::make_shared<MSRRegister>(handle, IRP_UNIT_CTL[unit] + IRP_CTR_REG_OFFSET + 0),
                    std::make_shared<MSRRegister>(handle, IRP_UNIT_CTL[unit] + IRP_CTR_REG_OFFSET + 1),
                    std::shared_ptr<MSRRegister>(),
                    std::shared_ptr<MSRRegister>()
                );
            }
        }
    }
#if 0
    auto findPCICFGPMU = [](const uint32 did,
                            const int s,
                            const uint32 CtlOffset,
                            const std::vector<uint32> & CounterControlOffsets,
                            const std::vector<uint32> & CounterValueOffsets)
    {
        int found = 0;
        UncorePMU out;
        forAllIntelDevices([&](const uint32 group, const uint32 bus, const uint32 device, const uint32 function, const uint32 device_id)
        {
            if (device_id == did)
            {
                if (s == found)
                {
                    auto handle = std::make_shared<PciHandleType>(group, bus, device, function);
                    const size_t n_regs = 4;
                    std::vector<std::shared_ptr<HWRegister> > CounterControlRegs, CounterValueRegs;
                    for (size_t r = 0; r < n_regs; ++r)
                    {
                        CounterControlRegs.push_back(std::make_shared<PCICFGRegister32>(handle, CounterControlOffsets[r]));
                        CounterValueRegs.push_back(std::make_shared<PCICFGRegister64>(handle, CounterValueOffsets[r]));
                    }
                    auto boxCtlRegister = std::make_shared<PCICFGRegister32>(handle, CtlOffset);
                    DBG(2,  "socket ", std::hex ,  s ,  " device " , device_id , " " , group , ":" , bus , ":" , device , "@" , function , "\n" , std::dec);
                    out = UncorePMU(boxCtlRegister, CounterControlRegs, CounterValueRegs);
                }
                ++found;
            }
        });
        return out;
    };
    for (uint32 s = 0; s < (uint32)num_sockets; ++s)
    {
        switch (cpu_family_model)
        {
            case BDX:
                irpPMUs[s][0] = findPCICFGPMU(0x6f39, s, 0xF4, {0xD8, 0xDC, 0xE0, 0xE4}, {0xA0, 0xB0, 0xB8, 0xC0});
                iioPMUs[s][0] = findPCICFGPMU(0x6f34, s, 0xF4, {0xD8, 0xDC, 0xE0, 0xE4}, {0xA0, 0xA8, 0xB0, 0xB8});
                break;
        }
    }
#endif

    if (hasPCICFGUncore() && MSR.size())
    {
        for (uint32 s = 0; s < (uint32)num_sockets; ++s)
        {
            uncorePMUs[s].resize(1);
            auto & handle = MSR[socketRefCore[s]];
            for (uint32 cbo = 0; cbo < getMaxNumOfCBoxesInternal(); ++cbo)
            {
                assert(CX_MSR_PMON_BOX_CTL(cbo));
                const auto filter1MSR = CX_MSR_PMON_BOX_FILTER1(cbo);
                std::shared_ptr<HWRegister> filter1MSRHandle = filter1MSR ? std::make_shared<MSRRegister>(handle, filter1MSR) : std::shared_ptr<HWRegister>();
                uncorePMUs[s][0][CBO_PMU_ID].push_back(std::make_shared<UncorePMU>(
                        std::make_shared<MSRRegister>(handle, CX_MSR_PMON_BOX_CTL(cbo)),
                        std::make_shared<MSRRegister>(handle, CX_MSR_PMON_CTLY(cbo, 0)),
                        std::make_shared<MSRRegister>(handle, CX_MSR_PMON_CTLY(cbo, 1)),
                        std::make_shared<MSRRegister>(handle, CX_MSR_PMON_CTLY(cbo, 2)),
                        std::make_shared<MSRRegister>(handle, CX_MSR_PMON_CTLY(cbo, 3)),
                        std::make_shared<CounterWidthExtenderRegister>(
                            std::make_shared<CounterWidthExtender>(new CounterWidthExtender::MsrHandleCounter(MSR[socketRefCore[s]], CX_MSR_PMON_CTRY(cbo, 0)), 48, 5555)),
                        std::make_shared<CounterWidthExtenderRegister>(
                            std::make_shared<CounterWidthExtender>(new CounterWidthExtender::MsrHandleCounter(MSR[socketRefCore[s]], CX_MSR_PMON_CTRY(cbo, 1)), 48, 5555)),
                        std::make_shared<CounterWidthExtenderRegister>(
                            std::make_shared<CounterWidthExtender>(new CounterWidthExtender::MsrHandleCounter(MSR[socketRefCore[s]], CX_MSR_PMON_CTRY(cbo, 2)), 48, 5555)),
                        std::make_shared<CounterWidthExtenderRegister>(
                            std::make_shared<CounterWidthExtender>(new CounterWidthExtender::MsrHandleCounter(MSR[socketRefCore[s]], CX_MSR_PMON_CTRY(cbo, 3)), 48, 5555)),
                        std::shared_ptr<MSRRegister>(),
                        std::shared_ptr<MSRRegister>(),
                        std::make_shared<MSRRegister>(handle, CX_MSR_PMON_BOX_FILTER(cbo)),
                        filter1MSRHandle
                    )
                );
            }
        }
    }

    if (1)
    {
        cxlPMUs.resize(num_sockets);
        for (uint32 s = 0; s < (uint32)num_sockets; ++s)
        {
            if (uncorePMUDiscovery.get())
            {
                auto createCXLPMU = [this](const uint32 s, const size_t die, const unsigned BoxType, const size_t pos) -> UncorePMU
                {
                    std::vector<std::shared_ptr<HWRegister> > CounterControlRegs, CounterValueRegs;
                    const auto n_regs = uncorePMUDiscovery->getBoxNumRegs(BoxType, s, die, pos);
                    const auto unitControlAddr = uncorePMUDiscovery->getBoxCtlAddr(BoxType, s, die, pos);
                    const auto unitControlAddrAligned = unitControlAddr & ~4095ULL;
                    auto handle = std::make_shared<MMIORange>(unitControlAddrAligned, CXL_PMON_SIZE, false);
                    for (size_t r = 0; r < n_regs; ++r)
                    {
                        CounterControlRegs.push_back(std::make_shared<MMIORegister64>(handle, uncorePMUDiscovery->getBoxCtlAddr(BoxType, s, die, pos, r) - unitControlAddrAligned));
                        CounterValueRegs.push_back(std::make_shared<MMIORegister64>(handle, uncorePMUDiscovery->getBoxCtrAddr(BoxType, s, die, pos, r) - unitControlAddrAligned));
                    }
                    return UncorePMU(std::make_shared<MMIORegister64>(handle, unitControlAddr - unitControlAddrAligned), CounterControlRegs, CounterValueRegs);
                };

                switch (getCPUFamilyModel())
                {
                    case PCM::SPR:
                    case PCM::EMR:
                    case PCM::GNR:
                    case PCM::GNR_D:
                    case PCM::SRF:
                    for (size_t die = 0; die < uncorePMUDiscovery->getNumDies(s); ++die)
                    {
                        const auto n_units = (std::min)(uncorePMUDiscovery->getNumBoxes(SPR_CXLCM_BOX_TYPE, s, die),
                            uncorePMUDiscovery->getNumBoxes(SPR_CXLDP_BOX_TYPE, s, die));
                        for (size_t pos = 0; pos < n_units; ++pos)
                        {
                            try
                            {
                                cxlPMUs[s].push_back(std::make_pair(createCXLPMU(s, die, SPR_CXLCM_BOX_TYPE, pos), createCXLPMU(s, die, SPR_CXLDP_BOX_TYPE, pos)));
                            }
                            catch (const std::exception& e)
                            {
                                std::cerr << "CXL PMU initialization for socket " << s << " die " << die << " at position " << pos << " failed: " << e.what() << std::endl;
                            }
                        }
                    }
                    break;
                }
            }
        }
    }
}

#ifdef PCM_USE_PERF
std::vector<int> enumeratePerfPMUs(const std::string & type, int max_id);
void populatePerfPMUs(unsigned socket_, const std::vector<int> & ids, std::vector<UncorePMU> & pmus, bool fixed, bool filter0 = false, bool filter1 = false);
void populatePerfPMUs(unsigned socket_, const std::vector<int>& ids, std::vector<UncorePMURef>& pmus, bool fixed, bool filter0 = false, bool filter1 = false);

std::vector<std::pair<int, uint32> > enumerateIDXPerfPMUs(const std::string & type, int max_id);
void populateIDXPerfPMUs(unsigned socket_, const std::vector<std::pair<int, uint32> > & ids, std::vector<IDX_PMU> & pmus);
#endif

void PCM::initUncorePMUsPerf()
{
#ifdef PCM_USE_PERF
    uncorePMUs.resize(num_sockets);
    iioPMUs.resize(num_sockets);
    irpPMUs.resize(num_sockets);
    for (uint32 s = 0; s < (uint32)num_sockets; ++s)
    {
        uncorePMUs[s].resize(1);
        populatePerfPMUs(s, enumeratePerfPMUs("pcu", 100), uncorePMUs[s][0][PCU_PMU_ID], false, true);
        populatePerfPMUs(s, enumeratePerfPMUs("ubox", 100), uncorePMUs[s][0][UBOX_PMU_ID], true);
        populatePerfPMUs(s, enumeratePerfPMUs("cbox", 100), uncorePMUs[s][0][CBO_PMU_ID], false, true, true);
        populatePerfPMUs(s, enumeratePerfPMUs("cha", 200), uncorePMUs[s][0][CBO_PMU_ID], false, true, true);
        populatePerfPMUs(s, enumeratePerfPMUs("mdf", 200), uncorePMUs[s][0][MDF_PMU_ID], false, true, true);
        auto populateMapPMUs = [&s](const std::string& type, std::vector<std::map<int32, UncorePMU> > & out)
        {
            std::vector<UncorePMU> PMUVector;
            populatePerfPMUs(s, enumeratePerfPMUs(type, 100), PMUVector, false);
            for (size_t i = 0; i < PMUVector.size(); ++i)
            {
                out[s][i] = PMUVector[i];
            }
        };
        populateMapPMUs("iio", iioPMUs);
        populateMapPMUs("irp", irpPMUs);
    }

    if (supportIDXAccelDev() == true)
    {
        idxPMUs.resize(IDX_MAX);
        idxPMUs[IDX_IAA].clear();
        idxPMUs[IDX_DSA].clear();
        idxPMUs[IDX_QAT].clear(); //QAT NOT support perf driver mode.
        populateIDXPerfPMUs(0, enumerateIDXPerfPMUs("iax", 100), idxPMUs[IDX_IAA]);
        populateIDXPerfPMUs(0, enumerateIDXPerfPMUs("dsa", 100), idxPMUs[IDX_DSA]);
#ifndef PCM_SILENT
        std::cerr << "Info: IDX - Detected " << idxPMUs[IDX_IAA].size() << " IAA devices, " << idxPMUs[IDX_DSA].size() << " DSA devices.\n";
        std::cerr << "Warning: IDX - QAT device NOT support perf driver mode.\n";
#endif
    }
#endif
}

#ifdef __linux__

const char * keepNMIWatchdogEnabledEnvStr = "PCM_KEEP_NMI_WATCHDOG";

bool keepNMIWatchdogEnabled()
{
    static int keep = -1;
    if (keep < 0)
    {
        keep = (safe_getenv(keepNMIWatchdogEnabledEnvStr) == std::string("1")) ? 1 : 0;
    }
    return keep == 1;
}

#define PCM_NMI_WATCHDOG_PATH "/proc/sys/kernel/nmi_watchdog"

bool isNMIWatchdogEnabled(const bool silent)
{
    const auto watchdog = readSysFS(PCM_NMI_WATCHDOG_PATH, silent);
    if (watchdog.length() == 0)
    {
        return false;
    }

    return (std::atoi(watchdog.c_str()) == 1);
}

void disableNMIWatchdog(const bool silent)
{
    if (!silent)
    {
        std::cerr << " Disabling NMI watchdog since it consumes one hw-PMU counter. To keep NMI watchdog set environment variable "
                  << keepNMIWatchdogEnabledEnvStr << "=1 (this reduces the core metrics set)\n";
    }
    writeSysFS(PCM_NMI_WATCHDOG_PATH, "0");
}

void enableNMIWatchdog(const bool silent)
{
    if (!silent) std::cerr << " Re-enabling NMI watchdog.\n";
    writeSysFS(PCM_NMI_WATCHDOG_PATH, "1");
}
#endif

constexpr const char* threadCreateErrorMessage = "This might be due to a too low limit for the number of threads per process. Try to increase it\n";

class CoreTaskQueue
{
    std::queue<std::packaged_task<void()> > wQueue;
    std::mutex m;
    std::condition_variable condVar;
    std::thread worker;
    CoreTaskQueue() = delete;
    CoreTaskQueue(CoreTaskQueue &) = delete;
    CoreTaskQueue & operator = (CoreTaskQueue &) = delete;
public:
    CoreTaskQueue(int32 core)
    {
        try {
            worker = std::thread([=]() {
                try {
                    TemporalThreadAffinity tempThreadAffinity(core, false);
                    std::unique_lock<std::mutex> lock(m);
                    while (1) {
                        while (wQueue.empty()) {
                            condVar.wait(lock);
                        }
                        while (!wQueue.empty()) {
                            wQueue.front()();
                            wQueue.pop();
                        }
                    }
                }
                catch (const std::exception& e)
                {
                    std::cerr << "PCM Error. Exception in CoreTaskQueue worker function: " << e.what() << "\n";
                }

            });
        }
        catch (const std::exception& e)
        {
            std::cerr << "PCM Error: caught exception " << e.what() << " while creating thread for core task queue " << core << "\n" <<
                threadCreateErrorMessage;
            throw; // re-throw
        }

    }
    void push(std::packaged_task<void()> & task)
    {
        std::unique_lock<std::mutex> lock(m);
        wQueue.push(std::move(task));
        condVar.notify_one();
    }
};

std::ofstream* PCM::outfile = nullptr;       // output file stream
std::streambuf* PCM::backup_ofile = nullptr; // backup of original output = cout
std::streambuf* PCM::backup_ofile_cerr = nullptr; // backup of original output = cerr

#ifdef __linux__
void increaseULimit()
{
    rlimit lim{};
    if (getrlimit(RLIMIT_NOFILE, &lim) == 0)
    {
        const rlim_t recommendedLimit = 1000000;
        DBG(2,  "file open limit: " , lim.rlim_cur , "," , lim.rlim_max );
        if (lim.rlim_cur < recommendedLimit || lim.rlim_max < recommendedLimit)
        {
            lim.rlim_cur = lim.rlim_max = recommendedLimit;
            if (setrlimit(RLIMIT_NOFILE, &lim) != 0)
            {
                std::cerr << "PCM Info: setrlimit for file limit " << recommendedLimit << " failed with error " << strerror(errno) << "\n";
            }
        }
    }
    else
    {
       std::cerr << "PCM Info: getrlimit for file limit failed with error " << strerror(errno) << "\n";
    }
}
#endif

PCM::PCM() :
    cpu_family(-1),
    cpu_model_private(-1),
    cpu_family_model(-1),
    cpu_stepping(-1),
    cpu_microcode_level(-1),
    max_cpuid(0),
    threads_per_core(0),
    num_cores(0),
    num_sockets(0),
    num_phys_cores_per_socket(0),
    num_online_cores(0),
    num_online_sockets(0),
    accel(0),
    accel_counters_num_max(0),
    core_gen_counter_num_max(0),
    core_gen_counter_num_used(0), // 0 means no core gen counters used
    core_gen_counter_width(0),
    core_fixed_counter_num_max(0),
    core_fixed_counter_num_used(0),
    core_fixed_counter_width(0),
    uncore_gen_counter_num_max(8),
    uncore_gen_counter_num_used(0),
    uncore_gen_counter_width(48),
    uncore_fixed_counter_num_max(1),
    uncore_fixed_counter_num_used(0),
    uncore_fixed_counter_width(48),
    perfmon_version(0),
    perfmon_config_anythread(1),
    nominal_frequency(0),
    max_qpi_speed(0),
    L3ScalingFactor(0),
    pkgThermalSpecPower(-1),
    pkgMinimumPower(-1),
    pkgMaximumPower(-1),
    systemTopology(new SystemRoot(this)),
    joulesPerEnergyUnit(0),
#ifdef __linux__
    resctrl(*this),
#endif
    useResctrl(false),
    disable_JKT_workaround(false),
    blocked(false),
    coreCStateMsr(NULL),
    pkgCStateMsr(NULL),
    L2CacheHitRatioAvailable(false),
    L3CacheHitRatioAvailable(false),
    L3CacheMissesAvailable(false),
    L2CacheMissesAvailable(false),
    L2CacheHitsAvailable(false),
    L3CacheHitsNoSnoopAvailable(false),
    L3CacheHitsSnoopAvailable(false),
    L3CacheHitsAvailable(false),
    forceRTMAbortMode(false),
    mode(INVALID_MODE),
    canUsePerf(false),
    run_state(1),
    needToRestoreNMIWatchdog(false)
{
    // Check for PCM_QUIET environment variable
    if (safe_getenv("PCM_QUIET") == std::string("1"))
    {
        quietMode = true;
    }

#ifdef __linux__
    increaseULimit();
#endif
#ifdef _MSC_VER
    // WARNING: This driver code (msr.sys) is only for testing purposes, not for production use
    Driver drv(Driver::msrLocalPath());
    // drv.stop();     // restart driver (usually not needed)
    if (!drv.start())
    {
        tcerr << "Cannot access CPU counters\n";
        tcerr << "You must have a signed  driver at " << drv.driverPath() << " and have administrator rights to run this program\n";
        return;
    }
#endif

    if(!detectModel()) return;

    if(!checkModel()) return;

    initCStateSupportTables();

    if(!discoverSystemTopology()) return;

    if(!initMSR()) return;

    readCoreCounterConfig(true);

#ifndef PCM_SILENT
    if (!quietMode)
    {
        printSystemTopology();
    }
#endif

    if(!detectNominalFrequency()) return;

    if (!quietMode)
    {
        showSpecControlMSRs();
    }

#ifndef PCM_DEBUG_TOPOLOGY
    if (safe_getenv("PCM_PRINT_TOPOLOGY") == "1")
#endif
    {
        if (!quietMode)
        {
            printDetailedSystemTopology(1);
        }
    }

    initEnergyMonitoring();

#ifndef PCM_SILENT
    if (!quietMode)
    {
        std::cerr << "\n";
    }
#endif

    if (isServerCPU())
    {
        assert(topology.size());
        uncorePMUDiscovery = std::make_shared<UncorePMUDiscovery>(*this);
    }

    initUncoreObjects();

    initRDT();

    readCPUMicrocodeLevel();

#ifdef PCM_USE_PERF
    canUsePerf = true;
    perfEventHandle.resize(num_cores, std::vector<int>(PERF_MAX_COUNTERS, -1));
    std::fill(perfTopDownPos.begin(), perfTopDownPos.end(), 0);
#endif

    for (int32 i = 0; i < num_cores; ++i)
    {
        coreTaskQueues.push_back(std::make_shared<CoreTaskQueue>(i));
    }

#ifndef PCM_SILENT
    std::cerr << "\n";
#endif
}

void PCM::printDetailedSystemTopology(const int detailLevel)
{
    // produce debug output similar to Intel MPI cpuinfo
    if (true)
    {
        std::cerr << "\n=====  Processor topology  =====\n";
        std::cerr << "OS_Processor    Thread_Id       Core_Id         ";
        if (detailLevel > 0) std::cerr << "Module_Id       ";
        std::cerr << "Tile_Id         ";
        if (detailLevel > 0) std::cerr << "Die_Id          Die_Group_Id    ";
        std::cerr << "Package_Id      Core_Type       Native_CPU_Model\n";
        std::map<uint32, std::vector<uint32> > os_id_by_core, os_id_by_tile, core_id_by_socket, os_id_by_l3_cache;
        size_t counter = 0;
        for (auto it = topology.begin(); it != topology.end(); ++it)
        {
            std::cerr << std::left << std::setfill(' ')
                << std::setw(16) << ((it->os_id >= 0) ? it->os_id : counter)
                << std::setw(16) << it->thread_id
                << std::setw(16) << it->core_id;
            if (detailLevel > 0) std::cerr << std::setw(16) << it->module_id;
            std::cerr << std::setw(16) << it->tile_id;
            if (detailLevel > 0) std::cerr << std::setw(16) << it->die_id << std::setw(16) << it->die_grp_id;
            std::cerr << std::setw(16) << it->socket_id
                << std::setw(16) << it->getCoreTypeStr()
                << std::setw(16) << it->native_cpu_model
                << "\n";
            if (std::find(core_id_by_socket[it->socket_id].begin(), core_id_by_socket[it->socket_id].end(), it->core_id)
                == core_id_by_socket[it->socket_id].end())
                core_id_by_socket[it->socket_id].push_back(it->core_id);
            // add socket offset to distinguish cores and tiles from different sockets
            os_id_by_core[(it->socket_id << 15) + it->core_id].push_back(it->os_id);
            os_id_by_tile[(it->socket_id << 15) + it->tile_id].push_back(it->os_id);
            os_id_by_l3_cache[(it->socket_id << 15) + it->l3_cache_id].push_back(it->os_id);

            ++counter;
        }
        std::cerr << "=====  Placement on packages  =====\n";
        std::cerr << "Package Id.    Core Id.     Processors\n";
        for (auto pkg = core_id_by_socket.begin(); pkg != core_id_by_socket.end(); ++pkg)
        {
            auto core_id = pkg->second.begin();
            std::cerr << std::left << std::setfill(' ') << std::setw(15) << pkg->first << *core_id;
            for (++core_id; core_id != pkg->second.end(); ++core_id)
            {
                std::cerr << "," << *core_id;
            }
            std::cerr << "\n";
        }
        std::cerr << "\n=====  Core/Tile sharing  =====\n";
        std::cerr << "Level      Processors\nCore       ";
        for (auto core = os_id_by_core.begin(); core != os_id_by_core.end(); ++core)
        {
            auto os_id = core->second.begin();
            std::cerr << "(" << *os_id;
            for (++os_id; os_id != core->second.end(); ++os_id) {
                std::cerr << "," << *os_id;
            }
            std::cerr << ")";
        }
        std::cerr << "\nTile / L2$ ";
        for (auto core = os_id_by_tile.begin(); core != os_id_by_tile.end(); ++core)
        {
            auto os_id = core->second.begin();
            std::cerr << "(" << *os_id;
            for (++os_id; os_id != core->second.end(); ++os_id) {
                std::cerr << "," << *os_id;
            }
            std::cerr << ")";
        }
        std::cerr << "\nL3$ ";
        for (auto core = os_id_by_l3_cache.begin(); core != os_id_by_l3_cache.end(); ++core)
        {
            auto os_id = core->second.begin();
            std::cerr << "(" << *os_id;
            for (++os_id; os_id != core->second.end(); ++os_id) {
                std::cerr << "," << *os_id;
            }
            std::cerr << ")";
        }
        std::cerr << "\n";
        std::cerr << "\n";
    }
}

void PCM::enableJKTWorkaround(bool enable)
{
    if(disable_JKT_workaround) return;
    std::cerr << "Using PCM on your system might have a performance impact as per http://software.intel.com/en-us/articles/performance-impact-when-sampling-certain-llc-events-on-snb-ep-with-vtune\n";
    std::cerr << "You can avoid the performance impact by using the option --noJKTWA, however the cache metrics might be wrong then.\n";
    if(MSR.size())
    {
        for(int32 i = 0; i < num_cores; ++i)
        {
            uint64 val64 = 0;
            MSR[i]->read(0x39C, &val64);
            if(enable)
                val64 |= 1ULL;
            else
                val64 &= (~1ULL);
            MSR[i]->write(0x39C, val64);
        }
    }
    for (size_t i = 0; i < (size_t)serverUncorePMUs.size(); ++i)
    {
            if(serverUncorePMUs[i].get()) serverUncorePMUs[i]->enableJKTWorkaround(enable);
    }
}

void PCM::showSpecControlMSRs()
{
    PCM_CPUID_INFO cpuinfo;
    pcm_cpuid(7, 0, cpuinfo);

    if (MSR.size())
    {
        if ((cpuinfo.reg.edx & (1 << 26)) || (cpuinfo.reg.edx & (1 << 27)))
        {
            uint64 val64 = 0;
            MSR[0]->read(MSR_IA32_SPEC_CTRL, &val64);
            std::cerr << "IBRS enabled in the kernel   : " << ((val64 & 1) ? "yes" : "no") << "\n";
            std::cerr << "STIBP enabled in the kernel  : " << ((val64 & 2) ? "yes" : "no") << "\n";
        }
        if (cpuinfo.reg.edx & (1 << 29))
        {
            uint64 val64 = 0;
            MSR[0]->read(MSR_IA32_ARCH_CAPABILITIES, &val64);
            std::cerr << "The processor is not susceptible to Rogue Data Cache Load: " << ((val64 & 1) ? "yes" : "no") << "\n";
            std::cerr << "The processor supports enhanced IBRS                     : " << ((val64 & 2) ? "yes" : "no") << "\n";
        }
    }
}

bool PCM::isCoreOnline(int32 os_core_id) const
{
    return (topology[os_core_id].os_id != -1) && (topology[os_core_id].core_id != -1) && (topology[os_core_id].socket_id != -1);
}

bool PCM::isSocketOnline(int32 socket_id) const
{
    return socketRefCore[socket_id] != -1;
}

bool PCM::isCPUModelSupported(const int model_)
{
    return (   model_ == NEHALEM_EP
            || model_ == NEHALEM_EX
            || model_ == WESTMERE_EP
            || model_ == WESTMERE_EX
            || isAtom(model_)
            || model_ == SNOWRIDGE
            || model_ == ELKHART_LAKE
            || model_ == JASPER_LAKE
            || model_ == CLARKDALE
            || model_ == SANDY_BRIDGE
            || model_ == JAKETOWN
            || model_ == IVY_BRIDGE
            || model_ == HASWELL
            || model_ == IVYTOWN
            || model_ == HASWELLX
            || model_ == BDX_DE
            || model_ == BDX
            || model_ == BROADWELL
            || model_ == KNL
            || model_ == SKL
            || model_ == SKL_UY
            || model_ == KBL
            || model_ == KBL_1
            || model_ == CML
            || model_ == ICL
            || model_ == RKL
            || model_ == TGL
            || model_ == ADL
            || model_ == RPL
            || model_ == MTL
            || model_ == LNL
            || model_ == ARL
            || model_ == PTL
            || model_ == SKX
            || model_ == ICX
            || model_ == SPR
            || model_ == EMR
            || model_ == GNR
            || model_ == GNR_D
            || model_ == GRR
            || model_ == SRF
           );
}

bool PCM::checkModel()
{
    switch (cpu_family_model)
    {
        case NEHALEM:
            cpu_family_model = NEHALEM_EP;
            break;
        case ATOM_2:
            cpu_family_model = ATOM;
            break;
        case HASWELL_ULT:
        case HASWELL_2:
            cpu_family_model = HASWELL;
            break;
        case BROADWELL_XEON_E3:
            cpu_family_model = BROADWELL;
            break;
        case ICX_D:
            cpu_family_model = ICX;
            break;
        case CML_1:
            cpu_family_model = CML;
            break;
        case ARL_1:
            cpu_family_model = ARL;
            break;
        case ICL_1:
            cpu_family_model = ICL;
            break;
        case TGL_1:
            cpu_family_model = TGL;
            break;
        case ADL_1:
            cpu_family_model = ADL;
            break;
        case RPL_1:
        case RPL_2:
        case RPL_3:
            cpu_family_model = RPL;
            break;
    }

    if(!isCPUModelSupported((int)cpu_family_model))
    {
        std::cerr << getUnsupportedMessage() << " CPU family " << cpu_family << " model number " << cpu_model_private << " Brand: \"" << getCPUBrandString().c_str() << "\"\n";
/* FOR TESTING PURPOSES ONLY */
#ifdef PCM_TEST_FALLBACK_TO_ATOM
        std::cerr << "Fall back to ATOM functionality.\n";
        cpu_family_model = ATOM;
        return true;
#endif
        return false;
    }
    return true;
}

void PCM::destroyMSR()
{
    MSR.clear();
}

PCM::~PCM()
{
    deleteAndNullify(systemTopology);
    if (instance)
    {
        destroyMSR();
        instance = NULL;
    }
}

bool PCM::good()
{
    return !MSR.empty();
}

#ifdef PCM_USE_PERF
perf_event_attr PCM_init_perf_event_attr(bool group = true)
{
    perf_event_attr e;
    bzero(&e,sizeof(perf_event_attr));
    e.type = -1; // must be set up later
    e.size = sizeof(e);
    e.config = -1; // must be set up later
    e.sample_period = 0;
    e.sample_type = 0;
    e.read_format = group ? PERF_FORMAT_GROUP : 0; /* PERF_FORMAT_TOTAL_TIME_ENABLED | PERF_FORMAT_TOTAL_TIME_RUNNING |
                          PERF_FORMAT_ID | PERF_FORMAT_GROUP ; */
    e.disabled = 0;
    e.inherit = 0;
    e.pinned = 0;
    e.exclusive = 0;
    e.exclude_user = 0;
    e.exclude_kernel = 0;
    e.exclude_hv = 0;
    e.exclude_idle = 0;
    e.mmap = 0;
    e.comm = 0;
    e.freq = 0;
    e.inherit_stat = 0;
    e.enable_on_exec = 0;
    e.task = 0;
    e.watermark = 0;
    e.wakeup_events = 0;
    return e;
}
#endif

PCM::ErrorCode PCM::program(const PCM::ProgramMode mode_, const void * parameter_, const bool silent, const int pid)
{
#ifdef __linux__
    if (isNMIWatchdogEnabled(silent) && (keepNMIWatchdogEnabled() == false))
    {
        disableNMIWatchdog(silent);
        needToRestoreNMIWatchdog = true;
    }
#endif

    if (MSR.empty()) return PCM::MSRAccessDenied;

    ExtendedCustomCoreEventDescription * pExtDesc = (ExtendedCustomCoreEventDescription *)parameter_;

#ifdef PCM_USE_PERF
    closePerfHandles(silent);
    if (!silent) std::cerr << "Trying to use Linux perf events...\n";
    const char * no_perf_env = std::getenv("PCM_NO_PERF");
    if (no_perf_env != NULL && std::string(no_perf_env) == std::string("1"))
    {
        canUsePerf = false;
        if (!silent) std::cerr << "Usage of Linux perf events is disabled through PCM_NO_PERF environment variable. Using direct PMU programming...\n";
    }
/*
    if(num_online_cores < num_cores)
    {
        canUsePerf = false;
        std::cerr << "PCM does not support using Linux perf API on systems with offlined cores. Falling-back to direct PMU programming.\n";
    }
*/
    else if(PERF_COUNT_HW_MAX <= PCM_PERF_COUNT_HW_REF_CPU_CYCLES)
    {
        canUsePerf = false;
        if (!silent) std::cerr << "Can not use Linux perf because your Linux kernel does not support PERF_COUNT_HW_REF_CPU_CYCLES event. Falling-back to direct PMU programming.\n";
    }
    else if(EXT_CUSTOM_CORE_EVENTS == mode_ && pExtDesc && pExtDesc->fixedCfg && (pExtDesc->fixedCfg->value & 0x444))
    {
        canUsePerf = false;
        if (!silent)
        {
             std::cerr << "Can not use Linux perf because \"any_thread\" fixed counter configuration requested (0x" << std::hex << pExtDesc->fixedCfg->value
                       << std::dec << ") =\n" << *(pExtDesc->fixedCfg) << "\nFalling-back to direct PMU programming.\n\n";
        }
    }
    else if(EXT_CUSTOM_CORE_EVENTS == mode_ && pExtDesc && (pExtDesc->OffcoreResponseMsrValue[0] || pExtDesc->OffcoreResponseMsrValue[1]))
    {
        const std::string offcore_rsp_format = readSysFS("/sys/bus/event_source/devices/cpu/format/offcore_rsp");
        if (offcore_rsp_format != "config1:0-63\n")
        {
            canUsePerf = false;
            if (!silent) std::cerr << "Can not use Linux perf because OffcoreResponse usage is not supported. Falling-back to direct PMU programming.\n";
        }
    }
    if (isHWTMAL1Supported() == true && perfSupportsTopDown() == false && pid == -1)
    {
        canUsePerf = false;
        if (!silent) std::cerr << "Installed Linux kernel perf does not support hardware top-down level-1 counters. Using direct PMU programming instead.\n";
    }
    if (canUsePerf &&    (cpu_family_model == ADL
                       || cpu_family_model == RPL
                       || cpu_family_model == MTL
                       || cpu_family_model == LNL
                       || cpu_family_model == ARL
                       || cpu_family_model == PTL
                         ))
    {
        canUsePerf = false;
        if (!silent) std::cerr << "Linux kernel perf rejects an architectural event on your platform. Using direct PMU programming instead.\n";
    }

    if (canUsePerf == false && noMSRMode())
    {
        std::cerr << "ERROR: can not use perf driver and no-MSR mode is enabled\n" ;
        return PCM::UnknownError;
    }
#endif

    if (programmed_core_pmu == false)
    {
        if((canUsePerf == false) && PMUinUse())
        {
            return PCM::PMUBusy;
        }
    }

    mode = mode_;

    // copy custom event descriptions
    if (mode == CUSTOM_CORE_EVENTS)
    {
        if (!parameter_)
        {
            std::cerr << "PCM Internal Error: data structure for custom event not initialized\n";
            return PCM::UnknownError;
        }
        CustomCoreEventDescription * pDesc = (CustomCoreEventDescription *)parameter_;
        coreEventDesc[0] = pDesc[0];
        coreEventDesc[1] = pDesc[1];
        if (isAtom() == false && cpu_family_model != KNL)
        {
            coreEventDesc[2] = pDesc[2];
            core_gen_counter_num_used = 3;
            if (core_gen_counter_num_max > 3) {
                coreEventDesc[3] = pDesc[3];
                core_gen_counter_num_used = 4;
            }
        }
        else
            core_gen_counter_num_used = 2;
    }
    else if (mode != EXT_CUSTOM_CORE_EVENTS)
    {
        auto LLCArchEventInit = [](CustomCoreEventDescription * evt)
        {
            evt[0].event_number = ARCH_LLC_MISS_EVTNR;
            evt[0].umask_value = ARCH_LLC_MISS_UMASK;
            evt[1].event_number = ARCH_LLC_REFERENCE_EVTNR;
            evt[1].umask_value = ARCH_LLC_REFERENCE_UMASK;
        };
        if (isAtom() || cpu_family_model == KNL)
        {
            LLCArchEventInit(coreEventDesc);
            L2CacheHitRatioAvailable = true;
            L2CacheMissesAvailable = true;
            L2CacheHitsAvailable = true;
            core_gen_counter_num_used = 2;
        }
        else if (memoryEventErrata())
        {
            LLCArchEventInit(coreEventDesc);
            L3CacheHitRatioAvailable = true;
            L3CacheMissesAvailable = true;
            L2CacheMissesAvailable = true;
            L3CacheHitsAvailable = true;
            core_gen_counter_num_used = 2;
            if (HASWELLX == cpu_family_model || HASWELL == cpu_family_model)
            {
                coreEventDesc[BasicCounterState::HSXL2MissPos].event_number = HSX_L2_RQSTS_MISS_EVTNR;
                coreEventDesc[BasicCounterState::HSXL2MissPos].umask_value = HSX_L2_RQSTS_MISS_UMASK;
                coreEventDesc[BasicCounterState::HSXL2RefPos].event_number = HSX_L2_RQSTS_REFERENCES_EVTNR;
                coreEventDesc[BasicCounterState::HSXL2RefPos].umask_value = HSX_L2_RQSTS_REFERENCES_UMASK;
                L2CacheHitRatioAvailable = true;
                L2CacheHitsAvailable = true;
                core_gen_counter_num_used = 4;
            }
        }
        else
        switch (cpu_family_model) {
            case ADL:
            case RPL:
            case MTL:
            case LNL:
            case ARL:
            case PTL:
                LLCArchEventInit(hybridAtomEventDesc);
                hybridAtomEventDesc[2].event_number = SKL_MEM_LOAD_RETIRED_L2_MISS_EVTNR;
                hybridAtomEventDesc[2].umask_value = SKL_MEM_LOAD_RETIRED_L2_MISS_UMASK;
                hybridAtomEventDesc[3].event_number = SKL_MEM_LOAD_RETIRED_L2_HIT_EVTNR;
                hybridAtomEventDesc[3].umask_value = SKL_MEM_LOAD_RETIRED_L2_HIT_UMASK;
                LLCArchEventInit(coreEventDesc);
                coreEventDesc[2].event_number = SKL_MEM_LOAD_RETIRED_L2_MISS_EVTNR;
                coreEventDesc[2].umask_value = SKL_MEM_LOAD_RETIRED_L2_MISS_UMASK;
                coreEventDesc[3].event_number = SKL_MEM_LOAD_RETIRED_L2_HIT_EVTNR;
                coreEventDesc[3].umask_value = SKL_MEM_LOAD_RETIRED_L2_HIT_UMASK;
                L2CacheHitRatioAvailable = true;
                L3CacheHitRatioAvailable = true;
                L3CacheMissesAvailable = true;
                L2CacheMissesAvailable = true;
                L2CacheHitsAvailable = true;
                L3CacheHitsSnoopAvailable = true;
                L3CacheHitsAvailable = true;
                core_gen_counter_num_used = 4;
                break;
            case SNOWRIDGE:
            case ELKHART_LAKE:
            case JASPER_LAKE:
                LLCArchEventInit(coreEventDesc);
                coreEventDesc[2].event_number = SKL_MEM_LOAD_RETIRED_L2_MISS_EVTNR;
                coreEventDesc[2].umask_value = SKL_MEM_LOAD_RETIRED_L2_MISS_UMASK;
                coreEventDesc[3].event_number = SKL_MEM_LOAD_RETIRED_L2_HIT_EVTNR;
                coreEventDesc[3].umask_value = SKL_MEM_LOAD_RETIRED_L2_HIT_UMASK;
                L2CacheHitRatioAvailable = true;
                L3CacheHitRatioAvailable = true;
                L3CacheMissesAvailable = true;
                L2CacheMissesAvailable = true;
                L2CacheHitsAvailable = true;
                L3CacheHitsSnoopAvailable = true;
                L3CacheHitsAvailable = true;
                core_gen_counter_num_used = 4;
                break;
            case GRR:
            case SRF:
                LLCArchEventInit(coreEventDesc);
                coreEventDesc[2].event_number = CMT_MEM_LOAD_RETIRED_L2_MISS_EVTNR;
                coreEventDesc[2].umask_value = CMT_MEM_LOAD_RETIRED_L2_MISS_UMASK;
                coreEventDesc[3].event_number = CMT_MEM_LOAD_RETIRED_L2_HIT_EVTNR;
                coreEventDesc[3].umask_value = CMT_MEM_LOAD_RETIRED_L2_HIT_UMASK;
                L2CacheHitRatioAvailable = true;
                L3CacheHitRatioAvailable = true;
                L3CacheMissesAvailable = true;
                L2CacheMissesAvailable = true;
                L2CacheHitsAvailable = true;
                L3CacheHitsSnoopAvailable = true;
                L3CacheHitsAvailable = true;
                core_gen_counter_num_used = 4;
                break;
            PCM_SKL_PATH_CASES
            case SKX:
            case ICX:
            case SPR:
            case EMR:
            case GNR:
            case GNR_D:
                assert(useSkylakeEvents());
                coreEventDesc[0].event_number = SKL_MEM_LOAD_RETIRED_L3_MISS_EVTNR;
                coreEventDesc[0].umask_value = SKL_MEM_LOAD_RETIRED_L3_MISS_UMASK;
                coreEventDesc[1].event_number = SKL_MEM_LOAD_RETIRED_L3_HIT_EVTNR;
                coreEventDesc[1].umask_value = SKL_MEM_LOAD_RETIRED_L3_HIT_UMASK;
                coreEventDesc[2].event_number = SKL_MEM_LOAD_RETIRED_L2_MISS_EVTNR;
                coreEventDesc[2].umask_value = SKL_MEM_LOAD_RETIRED_L2_MISS_UMASK;
                coreEventDesc[3].event_number = SKL_MEM_LOAD_RETIRED_L2_HIT_EVTNR;
                coreEventDesc[3].umask_value = SKL_MEM_LOAD_RETIRED_L2_HIT_UMASK;
                if (core_gen_counter_num_max == 2)
                {
                    L3CacheHitRatioAvailable = true;
                    L3CacheMissesAvailable = true;
                    L3CacheHitsSnoopAvailable = true;
                    L3CacheHitsAvailable = true;
                    core_gen_counter_num_used = 2;
                    break;
                }
                else if (core_gen_counter_num_max == 3)
                {
                    L3CacheHitRatioAvailable = true;
                    L3CacheMissesAvailable = true;
                    L2CacheMissesAvailable = true;
                    L3CacheHitsSnoopAvailable = true;
                    L3CacheHitsAvailable = true;
                    core_gen_counter_num_used = 3;
                    break;
                }
                L2CacheHitRatioAvailable = true;
                L3CacheHitRatioAvailable = true;
                L3CacheMissesAvailable = true;
                L2CacheMissesAvailable = true;
                L2CacheHitsAvailable = true;
                L3CacheHitsSnoopAvailable = true;
                L3CacheHitsAvailable = true;
                core_gen_counter_num_used = 4;
                break;
            case SANDY_BRIDGE:
            case JAKETOWN:
            case IVYTOWN:
            case IVY_BRIDGE:
            case HASWELL:
            case HASWELLX:
            case BROADWELL:
            case BDX_DE:
            case BDX:
                coreEventDesc[0].event_number = ARCH_LLC_MISS_EVTNR;
                coreEventDesc[0].umask_value = ARCH_LLC_MISS_UMASK;
                coreEventDesc[1].event_number = MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_NONE_EVTNR;
                coreEventDesc[1].umask_value = MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_NONE_UMASK;
                coreEventDesc[2].event_number = MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_EVTNR;
                coreEventDesc[2].umask_value = MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_UMASK;
                coreEventDesc[3].event_number = MEM_LOAD_UOPS_RETIRED_L2_HIT_EVTNR;
                coreEventDesc[3].umask_value = MEM_LOAD_UOPS_RETIRED_L2_HIT_UMASK;
                if (core_gen_counter_num_max == 3)
                {
                    L3CacheHitRatioAvailable = true;
                    L3CacheMissesAvailable = true;
                    L2CacheMissesAvailable = true;
                    L3CacheHitsNoSnoopAvailable = true;
                    L3CacheHitsSnoopAvailable = true;
                    L3CacheHitsAvailable = true;
                    core_gen_counter_num_used = 3;
                    break;
                }
                L2CacheHitRatioAvailable = true;
                L3CacheHitRatioAvailable = true;
                L3CacheMissesAvailable = true;
                L2CacheMissesAvailable = true;
                L2CacheHitsAvailable = true;
                L3CacheHitsNoSnoopAvailable = true;
                L3CacheHitsSnoopAvailable = true;
                L3CacheHitsAvailable = true;
                core_gen_counter_num_used = 4;
                break;
            case NEHALEM_EP:
            case WESTMERE_EP:
            case CLARKDALE:
                coreEventDesc[0].event_number = MEM_LOAD_RETIRED_L3_MISS_EVTNR;
                coreEventDesc[0].umask_value = MEM_LOAD_RETIRED_L3_MISS_UMASK;
                coreEventDesc[1].event_number = MEM_LOAD_RETIRED_L3_UNSHAREDHIT_EVTNR;
                coreEventDesc[1].umask_value = MEM_LOAD_RETIRED_L3_UNSHAREDHIT_UMASK;
                coreEventDesc[2].event_number = MEM_LOAD_RETIRED_L2_HITM_EVTNR;
                coreEventDesc[2].umask_value = MEM_LOAD_RETIRED_L2_HITM_UMASK;
                coreEventDesc[3].event_number = MEM_LOAD_RETIRED_L2_HIT_EVTNR;
                coreEventDesc[3].umask_value = MEM_LOAD_RETIRED_L2_HIT_UMASK;
                L2CacheHitRatioAvailable = true;
                L3CacheHitRatioAvailable = true;
                L3CacheMissesAvailable = true;
                L2CacheMissesAvailable = true;
                L2CacheHitsAvailable = true;
                L3CacheHitsNoSnoopAvailable = true;
                L3CacheHitsSnoopAvailable = true;
                L3CacheHitsAvailable = true;
                core_gen_counter_num_used = 4;
                break;
            default:
                assert(!useSkylakeEvents());
                coreEventDesc[0].event_number = ARCH_LLC_MISS_EVTNR;
                coreEventDesc[0].umask_value = ARCH_LLC_MISS_UMASK;
                coreEventDesc[1].event_number = MEM_LOAD_RETIRED_L3_UNSHAREDHIT_EVTNR;
                coreEventDesc[1].umask_value = MEM_LOAD_RETIRED_L3_UNSHAREDHIT_UMASK;
                coreEventDesc[2].event_number = MEM_LOAD_RETIRED_L2_HITM_EVTNR;
                coreEventDesc[2].umask_value = MEM_LOAD_RETIRED_L2_HITM_UMASK;
                coreEventDesc[3].event_number = MEM_LOAD_RETIRED_L2_HIT_EVTNR;
                coreEventDesc[3].umask_value = MEM_LOAD_RETIRED_L2_HIT_UMASK;
                L2CacheHitRatioAvailable = true;
                L3CacheHitRatioAvailable = true;
                L3CacheMissesAvailable = true;
                L2CacheMissesAvailable = true;
                L2CacheHitsAvailable = true;
                L3CacheHitsNoSnoopAvailable = true;
                L3CacheHitsSnoopAvailable = true;
                L3CacheHitsAvailable = true;
                core_gen_counter_num_used = 4;
        }
    }

    core_fixed_counter_num_used = 3;

    if(EXT_CUSTOM_CORE_EVENTS == mode_ && pExtDesc && (pExtDesc->gpCounterCfg || pExtDesc->gpCounterHybridAtomCfg))
    {
        core_gen_counter_num_used = pExtDesc->nGPCounters;
    }

    if(cpu_family_model == JAKETOWN)
    {
        bool enableWA = false;
        for(uint32 i = 0; i< core_gen_counter_num_used; ++i)
        {
            if(coreEventDesc[i].event_number == MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_EVTNR)
                enableWA = true;
        }
        enableJKTWorkaround(enableWA); // this has a performance penalty on memory access
    }

    if (core_gen_counter_num_used > core_gen_counter_num_max)
    {
        std::cerr << "PCM ERROR: Trying to program " << core_gen_counter_num_used << " general purpose counters with only "
            << core_gen_counter_num_max << " available\n";
        return PCM::UnknownError;
    }
    if (core_fixed_counter_num_used > core_fixed_counter_num_max)
    {
        std::cerr << "PCM ERROR: Trying to program " << core_fixed_counter_num_used << " fixed counters with only "
            << core_fixed_counter_num_max << " available\n";
        return PCM::UnknownError;
    }
    if (pid != -1 && canUsePerf == false)
    {
        std::cerr << "PCM ERROR: pid monitoring is only supported with Linux perf_event driver\n";
        return PCM::UnknownError;
    }
#ifdef __linux__
    if (isNMIWatchdogEnabled(silent) && (canUsePerf == false))
    {
        std::cerr << "PCM ERROR: Unsupported mode. NMI watchdog is enabled and Linux perf_event driver is not used\n";
        return PCM::UnknownError;
    }
#endif

    std::vector<int> tids{};
    #ifdef PCM_USE_PERF
    if (pid != -1)
    {
        const auto strDir = std::string("/proc/") +  std::to_string(pid) + "/task/";
        DIR * tidDir = opendir(strDir.c_str());
        if (tidDir)
        {
            struct dirent * entry{nullptr};
            while ((entry = readdir(tidDir)) != nullptr)
            {
                assert(entry->d_name);
                const auto tid = atoi(entry->d_name);
                if (tid)
                {
                    tids.push_back(tid);
                    DBG(2, "Detected task " , tids.back());
                }
            }
            closedir(tidDir);
        }
        else
        {
            std::cerr << "ERROR: Can't open " << strDir << "\n";
            return PCM::UnknownError;
        }
    }
    if (tids.empty() == false)
    {
        if (isHWTMAL1Supported())
        {
            if (!silent) std::cerr << "INFO: TMA L1 metrics are not supported in PID collection mode\n";
        }
        if (!silent) std::cerr << "INFO: collecting core metrics for " << tids.size() << " threads in process " << pid << "\n";
        PerfEventHandleContainer _1(num_cores, std::vector<int>(PERF_MAX_COUNTERS, -1));
        perfEventTaskHandle.resize(tids.size(), _1);
    }
    #endif

    lastProgrammedCustomCounters.clear();
    lastProgrammedCustomCounters.resize(num_cores);
    core_global_ctrl_value = 0ULL;
    isHWTMAL1Supported(); // ínit value to prevent MT races

    std::vector<std::future<void> > asyncCoreResults;
    std::vector<PCM::ErrorCode> programmingStatuses(num_cores, PCM::Success);

    for (int i = 0; i < (int)num_cores; ++i)
    {
        if (isCoreOnline(i) == false) continue;

        std::packaged_task<void()> task([this, i, mode_, pExtDesc, &programmingStatuses, &tids]() -> void
            {
                TemporalThreadAffinity tempThreadAffinity(i, false); // speedup trick for Linux

                programmingStatuses[i] = programCoreCounters(i, mode_, pExtDesc, lastProgrammedCustomCounters[i], tids);
            });
        asyncCoreResults.push_back(task.get_future());
        coreTaskQueues[i]->push(task);
    }

    for (auto& ar : asyncCoreResults)
        ar.wait();

    for (const auto& status : programmingStatuses)
    {
        if (status != PCM::Success)
        {
            return status;
        }
    }

    programmed_core_pmu = true;

    if (canUsePerf && !silent)
    {
        std::cerr << "Successfully programmed on-core PMU using Linux perf\n";
    }

    if (EXT_CUSTOM_CORE_EVENTS == mode_ && pExtDesc && pExtDesc->defaultUncoreProgramming == false)
    {
        return PCM::Success;
    }

    if (hasPCICFGUncore()) // program uncore counters
    {
        std::vector<std::future<uint64>> qpi_speeds;
        for (size_t i = 0; i < (size_t)serverUncorePMUs.size(); ++i)
        {
            serverUncorePMUs[i]->program();
            qpi_speeds.push_back(std::async(std::launch::async,
                &ServerUncorePMUs::computeQPISpeed, serverUncorePMUs[i].get(), socketRefCore[i], cpu_family_model));
        }
        for (size_t i = 0; i < (size_t)serverUncorePMUs.size(); ++i)
        {
            max_qpi_speed = (std::max)(qpi_speeds[i].get(), max_qpi_speed);
        }

        programCbo();

    } // program uncore counters on old CPU arch
    else if (cpu_family_model == NEHALEM_EP || cpu_family_model == WESTMERE_EP || cpu_family_model == CLARKDALE)
    {
        for (int i = 0; i < (int)num_cores; ++i)
        {
            if (isCoreOnline(i) == false) continue;
            TemporalThreadAffinity tempThreadAffinity(i, false); // speedup trick for Linux
            programNehalemEPUncore(i);
        }
    }
    else if (hasBecktonUncore())
    {
        for (int i = 0; i < (int)num_cores; ++i)
        {
            if (isCoreOnline(i) == false) continue;
            TemporalThreadAffinity tempThreadAffinity(i, false); // speedup trick for Linux
            programBecktonUncore(i);
        }
    }

    if (!silent) reportQPISpeed();

    return PCM::Success;
}

void PCM::checkStatus(const PCM::ErrorCode status)
{
    switch (status)
    {
        case pcm::PCM::Success:
        {
            break;
        }
        case pcm::PCM::MSRAccessDenied:
            throw std::system_error(pcm::PCM::MSRAccessDenied, std::generic_category(),
                "Access to Intel(r) Performance Counter Monitor has denied (no MSR or PCI CFG space access).");
        case pcm::PCM::PMUBusy:
            throw std::system_error(pcm::PCM::PMUBusy, std::generic_category(),
                "Access to Intel(r) Performance Counter Monitor has denied (Performance Monitoring Unit"
                " is occupied by other application). Try to stop the application that uses PMU,"
                " or reset PMU configuration from PCM application itself");
        default:
            throw std::system_error(pcm::PCM::UnknownError, std::generic_category(),
                "Access to Intel(r) Performance Counter Monitor has denied (Unknown error).");
    }
}

void PCM::checkError(const PCM::ErrorCode code)
{
    try
    {
        checkStatus(code);
    }
    catch (const std::system_error &e)
    {
        switch (e.code().value())
        {
           case PCM::PMUBusy:
               std::cerr << e.what() << "\n"
                               << "You can try to reset PMU configuration now. Try to reset? (y/n)" << std::endl;
               char yn;
               std::cin >> yn;
               if ('y' == yn)
               {
                   resetPMU();
                   std::cerr << "PMU configuration has been reset. Try to rerun the program again." << std::endl;
               }
               exit(EXIT_FAILURE);
           case PCM::MSRAccessDenied:
           default:
               std::cerr << e.what() << std::endl;
               exit(EXIT_FAILURE);
        }
    }
}

std::mutex printErrorMutex;

PCM::ErrorCode PCM::programCoreCounters(const int i /* core */,
    const PCM::ProgramMode mode_,
    const ExtendedCustomCoreEventDescription * pExtDesc,
    std::vector<EventSelectRegister> & result,
    const std::vector<int> & tids)
{
    (void) tids; // to silence uused param warning on non Linux OS
    // program core counters

    result.clear();
    FixedEventControlRegister ctrl_reg;
    auto initFixedCtrl = [&](const bool & enableCtr3)
    {
        if (EXT_CUSTOM_CORE_EVENTS == mode_ && pExtDesc && pExtDesc->fixedCfg)
        {
             ctrl_reg = *(pExtDesc->fixedCfg);
        }
        else
        {
             ctrl_reg.value = 0;
             ctrl_reg.fields.os0 = 1;
             ctrl_reg.fields.usr0 = 1;

             ctrl_reg.fields.os1 = 1;
             ctrl_reg.fields.usr1 = 1;

             ctrl_reg.fields.os2 = 1;
             ctrl_reg.fields.usr2 = 1;

             if (enableCtr3 && isFixedCounterSupported(3))
             {
                  ctrl_reg.fields.os3 = 1;
                  ctrl_reg.fields.usr3 = 1;
             }
        }
    };
#ifdef PCM_USE_PERF
    int leader_counter = -1;
    auto programPerfEvent = [this, &leader_counter, &i, &tids](perf_event_attr e, const int eventPos, const std::string & eventName) -> bool
    {
        auto programPerfEventHelper = [&i]( PerfEventHandleContainer & perfEventHandle,
                                            perf_event_attr & e,
                                            const int eventPos,
                                            const std::string & eventName,
                                            const int leader_counter,
                                            const int tid) -> bool
        {
            if (i == 0) { DBG(3, "programming event ", std::hex , e.config , std::dec); }
            if ((perfEventHandle[i][eventPos] = syscall(SYS_perf_event_open, &e, tid,
                i /* core id */, leader_counter /* group leader */, 0)) <= 0)
            {
                std::lock_guard<std::mutex> _(printErrorMutex);
                std::cerr << "Linux Perf: Error when programming " << eventName << ", error: " << strerror(errno) <<
                " with config 0x" << std::hex << e.config <<
                " config1 0x" << e.config1 << std::dec << " for tid " << tid << " leader " << leader_counter << "\n";
                if (24 == errno)
                {
                    std::cerr << PCM_ULIMIT_RECOMMENDATION;
                }
                else
                {
                    std::cerr << "try running with environment variable PCM_NO_PERF=1\n";
                }
                return false;
            }
            return true;
        };
        if (tids.empty() == false)
        {
            e.inherit = 1;
            e.exclude_kernel = 1;
            e.exclude_hv = 1;
            e.read_format = 0; // 'inherit' does not work for combinations of read format (e.g. PERF_FORMAT_GROUP)
            auto handleIt = perfEventTaskHandle.begin();
            for (const auto & tid: tids)
            {
                if (handleIt == perfEventTaskHandle.end())
                {
                    break;
                }
                if (programPerfEventHelper(*handleIt, e, eventPos, eventName, -1, tid) == false)
                {
                    return false;
                }
                ++handleIt;
            }
            return true;
        }
        return programPerfEventHelper(perfEventHandle, e, eventPos, eventName, leader_counter, -1);
    };
    if (canUsePerf)
    {
        initFixedCtrl(false);
        perf_event_attr e = PCM_init_perf_event_attr();
        e.type = PERF_TYPE_HARDWARE;
        e.config = PERF_COUNT_HW_INSTRUCTIONS;
        e.exclude_kernel = 1 - ctrl_reg.fields.os0;
        e.exclude_hv = e.exclude_kernel;
        e.exclude_user = 1 - ctrl_reg.fields.usr0;
        if (programPerfEvent(e, PERF_INST_RETIRED_POS, "INST_RETIRED") == false)
        {
            return PCM::UnknownError;
        }
        leader_counter = perfEventHandle[i][PERF_INST_RETIRED_POS];
        e.config = PERF_COUNT_HW_CPU_CYCLES;
        e.exclude_kernel = 1 - ctrl_reg.fields.os1;
        e.exclude_hv = e.exclude_kernel;
        e.exclude_user = 1 - ctrl_reg.fields.usr1;
        if (programPerfEvent(e, PERF_CPU_CLK_UNHALTED_THREAD_POS, "CPU_CLK_UNHALTED_THREAD") == false)
        {
            return PCM::UnknownError;
        }
        e.config = PCM_PERF_COUNT_HW_REF_CPU_CYCLES;
        e.exclude_kernel = 1 - ctrl_reg.fields.os2;
        e.exclude_hv = e.exclude_kernel;
        e.exclude_user = 1 - ctrl_reg.fields.usr2;
        if (programPerfEvent(e, PERF_CPU_CLK_UNHALTED_REF_POS, "CPU_CLK_UNHALTED_REF") == false)
        {
            return PCM::UnknownError;
        }
    }
    else
#endif
    {
        // disable counters while programming
        MSR[i]->write(IA32_CR_PERF_GLOBAL_CTRL, 0);
        MSR[i]->read(IA32_CR_FIXED_CTR_CTRL, &ctrl_reg.value);

        initFixedCtrl(true);

        MSR[i]->write(INST_RETIRED_ADDR, 0);
        MSR[i]->write(CPU_CLK_UNHALTED_THREAD_ADDR, 0);
        MSR[i]->write(CPU_CLK_UNHALTED_REF_ADDR, 0);
        MSR[i]->write(IA32_CR_FIXED_CTR_CTRL, ctrl_reg.value);
    }

    if (EXT_CUSTOM_CORE_EVENTS == mode_ && pExtDesc)
    {
        if (pExtDesc->OffcoreResponseMsrValue[0]) // still need to do also if perf API is used due to a bug in perf in some kernels
        {
            DBG(3, "programming offcore response 0x", std::hex , pExtDesc->OffcoreResponseMsrValue[0] ,
                    " into MSR 0x" , MSR_OFFCORE_RSP0 , std::dec , " for core ", i);
            MSR[i]->write(MSR_OFFCORE_RSP0, pExtDesc->OffcoreResponseMsrValue[0]);
        }
        if (pExtDesc->OffcoreResponseMsrValue[1])
        {
            DBG(3, "programming offcore response 0x", std::hex , pExtDesc->OffcoreResponseMsrValue[1] ,
                    " into MSR 0x" , MSR_OFFCORE_RSP1 , std::dec , " for core ", i);
            MSR[i]->write(MSR_OFFCORE_RSP1, pExtDesc->OffcoreResponseMsrValue[1]);
        }

        if (pExtDesc->LoadLatencyMsrValue != ExtendedCustomCoreEventDescription::invalidMsrValue())
        {
            MSR[i]->write(MSR_LOAD_LATENCY, pExtDesc->LoadLatencyMsrValue);
        }
        if (pExtDesc->FrontendMsrValue != ExtendedCustomCoreEventDescription::invalidMsrValue())
        {
            MSR[i]->write(MSR_FRONTEND, pExtDesc->FrontendMsrValue);
        }
    }

    auto setEvent = [] (EventSelectRegister & reg, const uint64 event,  const uint64 umask)
    {
            reg.fields.event_select = event;
            reg.fields.umask = umask;
            reg.fields.usr = 1;
            reg.fields.os = 1;
            reg.fields.edge = 0;
            reg.fields.pin_control = 0;
            reg.fields.apic_int = 0;
            reg.fields.any_thread = 0;
            reg.fields.enable = 1;
            reg.fields.invert = 0;
            reg.fields.cmask = 0;
            reg.fields.in_tx = 0;
            reg.fields.in_txcp = 0;
    };
    EventSelectRegister event_select_reg;
    uint64 PEBSEnable = 0ULL;
    for (uint32 j = 0; j < core_gen_counter_num_used; ++j)
    {
        if (hybrid == false || (hybrid == true && topology[i].core_type == TopologyEntry::Core))
        {
            if (EXT_CUSTOM_CORE_EVENTS == mode_ && pExtDesc && pExtDesc->gpCounterCfg)
            {
                event_select_reg = pExtDesc->gpCounterCfg[j];
                event_select_reg.fields.enable = 1;
            }
            else
            {
                MSR[i]->read(IA32_PERFEVTSEL0_ADDR + j, &event_select_reg.value); // read-only also safe for perf
                setEvent(event_select_reg, coreEventDesc[j].event_number, coreEventDesc[j].umask_value);
            }
        }
        else if (hybrid == true && topology[i].core_type == TopologyEntry::Atom)
        {
            if (EXT_CUSTOM_CORE_EVENTS == mode_ && pExtDesc && pExtDesc->gpCounterHybridAtomCfg)
            {
                event_select_reg = pExtDesc->gpCounterHybridAtomCfg[j];
                event_select_reg.fields.enable = 1;
            }
            else
            {
                MSR[i]->read(IA32_PERFEVTSEL0_ADDR + j, &event_select_reg.value); // read-only also safe for perf
                setEvent(event_select_reg, hybridAtomEventDesc[j].event_number, hybridAtomEventDesc[j].umask_value);
            }
        }

        result.push_back(event_select_reg);
        if (pExtDesc != nullptr && event_select_reg.fields.event_select == LOAD_LATENCY_EVTNR && event_select_reg.fields.umask == LOAD_LATENCY_UMASK)
        {
            PEBSEnable |= (1ULL << j);
        }
#ifdef PCM_USE_PERF
        if (canUsePerf)
        {
            perf_event_attr e = PCM_init_perf_event_attr();
            e.type = PERF_TYPE_RAW;
            e.config = (1ULL << 63ULL) + event_select_reg.value;
            if (pExtDesc != nullptr)
            {
                if (event_select_reg.fields.event_select == getOCREventNr(0, i).first && event_select_reg.fields.umask == getOCREventNr(0, i).second)
                {
                    DBG(3, "writing offcore response 0x", std::hex , pExtDesc->OffcoreResponseMsrValue[0] ,
                            " into perf config1 for core ", std::dec , i, std::hex ," event 0x", event_select_reg.fields.event_select, " umask 0x", event_select_reg.fields.umask ,
                            " on counter ", std::dec , j);
                    e.config1 = pExtDesc->OffcoreResponseMsrValue[0];
                }
                if (event_select_reg.fields.event_select == getOCREventNr(1, i).first && event_select_reg.fields.umask == getOCREventNr(1, i).second)
                {
                    DBG(3, "writing offcore response 0x", std::hex , pExtDesc->OffcoreResponseMsrValue[1] ,
                            " into perf config1 for core ", std::dec , i, std::hex , " event 0x", event_select_reg.fields.event_select, " umask 0x", event_select_reg.fields.umask ,
                            " on counter ", std::dec , j);
                    e.config1 = pExtDesc->OffcoreResponseMsrValue[1];
                }

                if (event_select_reg.fields.event_select == LOAD_LATENCY_EVTNR && event_select_reg.fields.umask == LOAD_LATENCY_UMASK)
                {
                    e.config1 = pExtDesc->LoadLatencyMsrValue;
                }
                if (event_select_reg.fields.event_select == FRONTEND_EVTNR && event_select_reg.fields.umask == FRONTEND_UMASK)
                {
                    e.config1 = pExtDesc->FrontendMsrValue;
                }
            }

            if (programPerfEvent(e, PERF_GEN_EVENT_0_POS + j, std::string("generic event #") + std::to_string(j) + std::string(" on core #") + std::to_string(i)) == false)
            {
                return PCM::UnknownError;
            }
        }
        else
#endif
        {
            MSR[i]->write(IA32_PMC0 + j, 0);
            MSR[i]->write(IA32_PERFEVTSEL0_ADDR + j, event_select_reg.value);
        }
    }

    if (!canUsePerf)
    {
        // start counting, enable all (4 programmable + 3 fixed) counters
        uint64 value = (1ULL << 0) + (1ULL << 1) + (1ULL << 2) + (1ULL << 3) + (1ULL << 32) + (1ULL << 33) + (1ULL << 34);

	if (isFixedCounterSupported(3))
	{
	    value |= (1ULL << 35);
	    MSR[i]->write(TOPDOWN_SLOTS_ADDR, 0);
	}

	if (isHWTMAL1Supported())
	{
	    value |= (1ULL << 48);
	    MSR[i]->write(PERF_METRICS_ADDR, 0);
	}

        if (isAtom() || cpu_family_model == KNL)       // KNL and Atom have 3 fixed + only 2 programmable counters
            value = (1ULL << 0) + (1ULL << 1) + (1ULL << 32) + (1ULL << 33) + (1ULL << 34);

        for (uint32 j = 0; j < core_gen_counter_num_used; ++j)
        {
            value |= (1ULL << j); // enable all custom counters (if > 4)
        }

        if (core_global_ctrl_value)
        {
            assert(core_global_ctrl_value == value);
        }
        else
        {
            core_global_ctrl_value = value;
        }

        MSR[i]->write(IA32_PERF_GLOBAL_OVF_CTRL, value);
        MSR[i]->write(IA32_CR_PERF_GLOBAL_CTRL, value);
       DBG(3, "core_id = ", i, " wrote IA32_PERF_GLOBAL_OVF_CTRL and IA32_CR_PERF_GLOBAL_CTRL = 0x", std::hex, value, std::dec);
    }
#ifdef PCM_USE_PERF
    else
    {
	    if (isFixedCounterSupported(3) && isHWTMAL1Supported() && perfSupportsTopDown())
        {
            std::vector<std::pair<const char*, int> > topDownEvents = {  std::make_pair(perfSlotsPath, PERF_TOPDOWN_SLOTS_POS),
                                          std::make_pair(perfBadSpecPath, PERF_TOPDOWN_BADSPEC_POS),
                                          std::make_pair(perfBackEndPath, PERF_TOPDOWN_BACKEND_POS),
                                          std::make_pair(perfFrontEndPath, PERF_TOPDOWN_FRONTEND_POS),
                                          std::make_pair(perfRetiringPath, PERF_TOPDOWN_RETIRING_POS)};
            if (isHWTMAL2Supported())
            {
                topDownEvents.push_back(std::make_pair(perfMemBound, PERF_TOPDOWN_MEM_BOUND_POS));
                topDownEvents.push_back(std::make_pair(perfFetchLat, PERF_TOPDOWN_FETCH_LAT_POS));
                topDownEvents.push_back(std::make_pair(perfBrMispred, PERF_TOPDOWN_BR_MISPRED_POS));
                topDownEvents.push_back(std::make_pair(perfHeavyOps, PERF_TOPDOWN_HEAVY_OPS_POS));
            }
            int readPos = core_fixed_counter_num_used + core_gen_counter_num_used;
            leader_counter = -1;
            for (const auto & event : topDownEvents)
            {
                uint64 eventSel = 0, umask = 0;
                const auto eventDesc = readSysFS(event.first);
                const auto tokens = split(eventDesc, ',');
                for (const auto & token : tokens)
                {
                    if (match(token, "event=", &eventSel))
                    {
                        // found and matched event, wrote value to 'eventSel'
                    }
                    else if (match(token, "umask=", &umask))
                    {
                        // found and matched umask, wrote value to 'umask'
                    }
                    else
                    {
                        std::lock_guard<std::mutex> _(printErrorMutex);
                        std::cerr << "ERROR: unknown token " << token << " in event description \"" << eventDesc << "\" from " << event.first << "\n";
                        return PCM::UnknownError;
                    }
                }
                EventSelectRegister reg;
                reg.fields.event_select = eventSel;
                reg.fields.umask = umask;
                perf_event_attr e = PCM_init_perf_event_attr();
                e.type = PERF_TYPE_RAW;
                e.config = reg.value;
                DBG(3, "Programming perf event " , std::hex , e.config , std::dec);
                if (programPerfEvent(e, event.second, std::string("event ") + event.first + " " + eventDesc) == false)
                {
                    return PCM::UnknownError;
                }
                leader_counter = perfEventHandle[i][PERF_TOPDOWN_SLOTS_POS];
                perfTopDownPos[event.second] = readPos++;
            }
        }
    }
#endif
    if (PEBSEnable)
    {
        cleanupPEBS = true;
        MSR[i]->write(IA32_PEBS_ENABLE_ADDR, PEBSEnable);
    }
    return PCM::Success;
}

void PCM::reportQPISpeed() const
{
    if (!max_qpi_speed) return;

    if (hasPCICFGUncore()) {
        for (size_t i = 0; i < (size_t)serverUncorePMUs.size(); ++i)
        {
            std::cerr << "Socket " << i << "\n";
            if(serverUncorePMUs[i].get()) serverUncorePMUs[i]->reportQPISpeed();
        }
    } else {
        std::cerr << "Max " << xPI() << " speed: " << max_qpi_speed / (1e9) << " GBytes/second (" << max_qpi_speed / (1e9*getBytesPerLinkTransfer()) << " GT/second)\n";
    }

}

void PCM::programNehalemEPUncore(int32 core)
{

#define CPUCNT_INIT_THE_REST_OF_EVTCNT \
    unc_event_select_reg.fields.occ_ctr_rst = 1; \
    unc_event_select_reg.fields.edge = 0; \
    unc_event_select_reg.fields.enable_pmi = 0; \
    unc_event_select_reg.fields.enable = 1; \
    unc_event_select_reg.fields.invert = 0; \
    unc_event_select_reg.fields.cmask = 0;

    uncore_gen_counter_num_used = 8;

    UncoreEventSelectRegister unc_event_select_reg;

    MSR[core]->read(MSR_UNCORE_PERFEVTSEL0_ADDR, &unc_event_select_reg.value);

    unc_event_select_reg.fields.event_select = UNC_QMC_WRITES_FULL_ANY_EVTNR;
    unc_event_select_reg.fields.umask = UNC_QMC_WRITES_FULL_ANY_UMASK;

    CPUCNT_INIT_THE_REST_OF_EVTCNT

        MSR[core]->write(MSR_UNCORE_PERFEVTSEL0_ADDR, unc_event_select_reg.value);


    MSR[core]->read(MSR_UNCORE_PERFEVTSEL1_ADDR, &unc_event_select_reg.value);

    unc_event_select_reg.fields.event_select = UNC_QMC_NORMAL_READS_ANY_EVTNR;
    unc_event_select_reg.fields.umask = UNC_QMC_NORMAL_READS_ANY_UMASK;

    CPUCNT_INIT_THE_REST_OF_EVTCNT

        MSR[core]->write(MSR_UNCORE_PERFEVTSEL1_ADDR, unc_event_select_reg.value);


    MSR[core]->read(MSR_UNCORE_PERFEVTSEL2_ADDR, &unc_event_select_reg.value);
    unc_event_select_reg.fields.event_select = UNC_QHL_REQUESTS_EVTNR;
    unc_event_select_reg.fields.umask = UNC_QHL_REQUESTS_IOH_READS_UMASK;
    CPUCNT_INIT_THE_REST_OF_EVTCNT
        MSR[core]->write(MSR_UNCORE_PERFEVTSEL2_ADDR, unc_event_select_reg.value);

    MSR[core]->read(MSR_UNCORE_PERFEVTSEL3_ADDR, &unc_event_select_reg.value);
    unc_event_select_reg.fields.event_select = UNC_QHL_REQUESTS_EVTNR;
    unc_event_select_reg.fields.umask = UNC_QHL_REQUESTS_IOH_WRITES_UMASK;
    CPUCNT_INIT_THE_REST_OF_EVTCNT
        MSR[core]->write(MSR_UNCORE_PERFEVTSEL3_ADDR, unc_event_select_reg.value);

    MSR[core]->read(MSR_UNCORE_PERFEVTSEL4_ADDR, &unc_event_select_reg.value);
    unc_event_select_reg.fields.event_select = UNC_QHL_REQUESTS_EVTNR;
    unc_event_select_reg.fields.umask = UNC_QHL_REQUESTS_REMOTE_READS_UMASK;
    CPUCNT_INIT_THE_REST_OF_EVTCNT
        MSR[core]->write(MSR_UNCORE_PERFEVTSEL4_ADDR, unc_event_select_reg.value);

    MSR[core]->read(MSR_UNCORE_PERFEVTSEL5_ADDR, &unc_event_select_reg.value);
    unc_event_select_reg.fields.event_select = UNC_QHL_REQUESTS_EVTNR;
    unc_event_select_reg.fields.umask = UNC_QHL_REQUESTS_REMOTE_WRITES_UMASK;
    CPUCNT_INIT_THE_REST_OF_EVTCNT
        MSR[core]->write(MSR_UNCORE_PERFEVTSEL5_ADDR, unc_event_select_reg.value);

    MSR[core]->read(MSR_UNCORE_PERFEVTSEL6_ADDR, &unc_event_select_reg.value);
    unc_event_select_reg.fields.event_select = UNC_QHL_REQUESTS_EVTNR;
    unc_event_select_reg.fields.umask = UNC_QHL_REQUESTS_LOCAL_READS_UMASK;
    CPUCNT_INIT_THE_REST_OF_EVTCNT
        MSR[core]->write(MSR_UNCORE_PERFEVTSEL6_ADDR, unc_event_select_reg.value);

    MSR[core]->read(MSR_UNCORE_PERFEVTSEL7_ADDR, &unc_event_select_reg.value);
    unc_event_select_reg.fields.event_select = UNC_QHL_REQUESTS_EVTNR;
    unc_event_select_reg.fields.umask = UNC_QHL_REQUESTS_LOCAL_WRITES_UMASK;
    CPUCNT_INIT_THE_REST_OF_EVTCNT
        MSR[core]->write(MSR_UNCORE_PERFEVTSEL7_ADDR, unc_event_select_reg.value);


#undef CPUCNT_INIT_THE_REST_OF_EVTCNT

    // start uncore counting
    uint64 value = 255 + (1ULL << 32);           // enable all counters
    MSR[core]->write(MSR_UNCORE_PERF_GLOBAL_CTRL_ADDR, value);

    // synchronise counters
    MSR[core]->write(MSR_UNCORE_PMC0, 0);
    MSR[core]->write(MSR_UNCORE_PMC1, 0);
    MSR[core]->write(MSR_UNCORE_PMC2, 0);
    MSR[core]->write(MSR_UNCORE_PMC3, 0);
    MSR[core]->write(MSR_UNCORE_PMC4, 0);
    MSR[core]->write(MSR_UNCORE_PMC5, 0);
    MSR[core]->write(MSR_UNCORE_PMC6, 0);
    MSR[core]->write(MSR_UNCORE_PMC7, 0);
}

void PCM::programBecktonUncore(int32 core)
{
    // program Beckton uncore
    if (core == socketRefCore[0]) computeQPISpeedBeckton((int)core);

    uint64 value = 1 << 29ULL;           // reset all counters
    MSR[core]->write(U_MSR_PMON_GLOBAL_CTL, value);

    BecktonUncorePMUZDPCTLFVCRegister FVCreg;
    FVCreg.value = 0;
    if (cpu_family_model == NEHALEM_EX)
    {
        FVCreg.fields.bcmd = 0;             // rd_bcmd
        FVCreg.fields.resp = 0;             // ack_resp
        FVCreg.fields.evnt0 = 5;            // bcmd_match
        FVCreg.fields.evnt1 = 6;            // resp_match
        FVCreg.fields.pbox_init_err = 0;
    }
    else
    {
        FVCreg.fields_wsm.bcmd = 0;             // rd_bcmd
        FVCreg.fields_wsm.resp = 0;             // ack_resp
        FVCreg.fields_wsm.evnt0 = 5;            // bcmd_match
        FVCreg.fields_wsm.evnt1 = 6;            // resp_match
        FVCreg.fields_wsm.pbox_init_err = 0;
    }
    MSR[core]->write(MB0_MSR_PMU_ZDP_CTL_FVC, FVCreg.value);
    MSR[core]->write(MB1_MSR_PMU_ZDP_CTL_FVC, FVCreg.value);

    BecktonUncorePMUCNTCTLRegister CNTCTLreg;
    CNTCTLreg.value = 0;
    CNTCTLreg.fields.en = 1;
    CNTCTLreg.fields.pmi_en = 0;
    CNTCTLreg.fields.count_mode = 0;
    CNTCTLreg.fields.storage_mode = 0;
    CNTCTLreg.fields.wrap_mode = 1;
    CNTCTLreg.fields.flag_mode = 0;
    CNTCTLreg.fields.inc_sel = 0x0d;           // FVC_EV0
    MSR[core]->write(MB0_MSR_PMU_CNT_CTL_0, CNTCTLreg.value);
    MSR[core]->write(MB1_MSR_PMU_CNT_CTL_0, CNTCTLreg.value);
    CNTCTLreg.fields.inc_sel = 0x0e;           // FVC_EV1
    MSR[core]->write(MB0_MSR_PMU_CNT_CTL_1, CNTCTLreg.value);
    MSR[core]->write(MB1_MSR_PMU_CNT_CTL_1, CNTCTLreg.value);

    value = 1 + ((0x0C) << 1ULL);              // enable bit + (event select IMT_INSERTS_WR)
    MSR[core]->write(BB0_MSR_PERF_CNT_CTL_1, value);
    MSR[core]->write(BB1_MSR_PERF_CNT_CTL_1, value);

    MSR[core]->write(MB0_MSR_PERF_GLOBAL_CTL, 3); // enable two counters
    MSR[core]->write(MB1_MSR_PERF_GLOBAL_CTL, 3); // enable two counters

    MSR[core]->write(BB0_MSR_PERF_GLOBAL_CTL, 2); // enable second counter
    MSR[core]->write(BB1_MSR_PERF_GLOBAL_CTL, 2); // enable second counter

    // program R-Box to monitor QPI traffic

    // enable counting on all counters on the left side (port 0-3)
    MSR[core]->write(R_MSR_PMON_GLOBAL_CTL_7_0, 255);
    // ... on the right side (port 4-7)
    MSR[core]->write(R_MSR_PMON_GLOBAL_CTL_15_8, 255);

    // pick the event
    value = (1 << 7ULL) + (1 << 6ULL) + (1 << 2ULL); // count any (incoming) data responses
    MSR[core]->write(R_MSR_PORT0_IPERF_CFG0, value);
    MSR[core]->write(R_MSR_PORT1_IPERF_CFG0, value);
    MSR[core]->write(R_MSR_PORT4_IPERF_CFG0, value);
    MSR[core]->write(R_MSR_PORT5_IPERF_CFG0, value);

    // pick the event
    value = (1ULL << 30ULL); // count null idle flits sent
    MSR[core]->write(R_MSR_PORT0_IPERF_CFG1, value);
    MSR[core]->write(R_MSR_PORT1_IPERF_CFG1, value);
    MSR[core]->write(R_MSR_PORT4_IPERF_CFG1, value);
    MSR[core]->write(R_MSR_PORT5_IPERF_CFG1, value);

    // choose counter 0 to monitor R_MSR_PORT0_IPERF_CFG0
    MSR[core]->write(R_MSR_PMON_CTL0, 1 + 2 * (0));
    // choose counter 1 to monitor R_MSR_PORT1_IPERF_CFG0
    MSR[core]->write(R_MSR_PMON_CTL1, 1 + 2 * (6));
    // choose counter 8 to monitor R_MSR_PORT4_IPERF_CFG0
    MSR[core]->write(R_MSR_PMON_CTL8, 1 + 2 * (0));
    // choose counter 9 to monitor R_MSR_PORT5_IPERF_CFG0
    MSR[core]->write(R_MSR_PMON_CTL9, 1 + 2 * (6));

    // choose counter 2 to monitor R_MSR_PORT0_IPERF_CFG1
    MSR[core]->write(R_MSR_PMON_CTL2, 1 + 2 * (1));
    // choose counter 3 to monitor R_MSR_PORT1_IPERF_CFG1
    MSR[core]->write(R_MSR_PMON_CTL3, 1 + 2 * (7));
    // choose counter 10 to monitor R_MSR_PORT4_IPERF_CFG1
    MSR[core]->write(R_MSR_PMON_CTL10, 1 + 2 * (1));
    // choose counter 11 to monitor R_MSR_PORT5_IPERF_CFG1
    MSR[core]->write(R_MSR_PMON_CTL11, 1 + 2 * (7));

    // enable uncore TSC counter (fixed one)
    MSR[core]->write(W_MSR_PMON_GLOBAL_CTL, 1ULL << 31ULL);
    MSR[core]->write(W_MSR_PMON_FIXED_CTR_CTL, 1ULL);

    value = (1 << 28ULL) + 1;                  // enable all counters
    MSR[core]->write(U_MSR_PMON_GLOBAL_CTL, value);
}

uint64 RDTSC();

void PCM::computeNominalFrequency()
{
    const int32 ref_core = socketRefCore[0];
    const uint64 before = getInvariantTSC_Fast(ref_core);
    MySleepMs(100);
    const uint64 after = getInvariantTSC_Fast(ref_core);
    nominal_frequency = 10ULL*(after-before);
    std::cerr << "WARNING: Core nominal frequency has to be estimated\n";
}
std::string PCM::getCPUBrandString()
{
    char buffer[sizeof(int)*4*3+1];
    PCM_CPUID_INFO * info = (PCM_CPUID_INFO *) buffer;
    pcm_cpuid(0x80000002, *info);
    ++info;
    pcm_cpuid(0x80000003, *info);
    ++info;
    pcm_cpuid(0x80000004, *info);
    buffer[sizeof(int)*4*3] = 0;
    std::string result(buffer);
    while(result[0]==' ') result.erase(0,1);
    std::string::size_type i;
    while((i = result.find("  ")) != std::string::npos) result.replace(i,2," "); // remove duplicate spaces
    return result;
}

std::string PCM::getCPUFamilyModelString()
{
    return getCPUFamilyModelString(cpu_family, cpu_model_private, cpu_stepping);
}

std::string PCM::getCPUFamilyModelString(const uint32 cpu_family_, const uint32 internal_cpu_model_, const uint32 cpu_stepping_)
{
    char buffer[sizeof(int)*4*3+6];
    std::fill(buffer, buffer + sizeof(buffer), 0);
    std::snprintf(buffer,sizeof(buffer),"GenuineIntel-%u-%2X-%X", cpu_family_, internal_cpu_model_, cpu_stepping_);
    std::string result(buffer);
    return result;
}

void PCM::enableForceRTMAbortMode(const bool silent)
{
    DBG(2, "enableForceRTMAbortMode(): forceRTMAbortMode=" , forceRTMAbortMode );
    if (!forceRTMAbortMode)
    {
        if (isForceRTMAbortModeAvailable() && (core_gen_counter_num_max < 4))
        {
            for (auto& m : MSR)
            {
                const auto res = m->write(MSR_TSX_FORCE_ABORT, 1);
                if (res != sizeof(uint64))
                {
                    std::cerr << "Warning: writing 1 to MSR_TSX_FORCE_ABORT failed with error "
                        << res << " on core " << m->getCoreId() << "\n";
                }
            }
            readCoreCounterConfig(true); // re-read core_gen_counter_num_max from CPUID
            if (!silent) std::cerr << "The number of custom counters is now " << core_gen_counter_num_max << "\n";
            if (core_gen_counter_num_max < 4)
            {
                std::cerr << "PCM Warning: the number of custom counters did not increase (" << core_gen_counter_num_max << ")\n";
            }
            forceRTMAbortMode = true;
        }
    }
}

bool PCM::isForceRTMAbortModeEnabled() const
{
    return forceRTMAbortMode;
}

void PCM::disableForceRTMAbortMode(const bool silent)
{
    DBG(2, "disableForceRTMAbortMode(): forceRTMAbortMode=" , forceRTMAbortMode );
    if (forceRTMAbortMode)
    {
        for (auto& m : MSR)
        {
            const auto res = m->write(MSR_TSX_FORCE_ABORT, 0);
            if (res != sizeof(uint64))
            {
                std::cerr << "Warning: writing 0 to MSR_TSX_FORCE_ABORT failed with error "
                    << res << " on core " << m->getCoreId() << "\n";
            }
        }
        readCoreCounterConfig(true); // re-read core_gen_counter_num_max from CPUID
        if (!silent) std::cerr << "The number of custom counters is now " << core_gen_counter_num_max << "\n";
        if (core_gen_counter_num_max != 3)
        {
            std::cerr << "PCM Warning: the number of custom counters is not 3 (" << core_gen_counter_num_max << ")\n";
        }
        forceRTMAbortMode = false;
    }
}

bool PCM::isForceRTMAbortModeAvailable()
{
    PCM_CPUID_INFO info;
    pcm_cpuid(7, 0, info); // leaf 7, subleaf 0
    return (info.reg.edx & (0x1 << 13)) ? true : false;
}

uint64 get_frequency_from_cpuid() // from Pat Fay (Intel)
{
    double speed=0;
    std::string brand = PCM::getCPUBrandString();
    if (brand.length() > std::string::size_type(0))
    {
        std::string::size_type unitsg = brand.find("GHz");
        if(unitsg != std::string::npos)
        {
            std::string::size_type atsign = brand.rfind(' ', unitsg);
            if(atsign != std::string::npos)
            {
                std::istringstream(brand.substr(atsign)) >> speed;
                speed *= 1000;
            }
        }
        else
        {
            std::string::size_type unitsg = brand.find("MHz");
            if(unitsg != std::string::npos)
            {
                std::string::size_type atsign = brand.rfind(' ', unitsg);
                if(atsign != std::string::npos)
                {
                    std::istringstream(brand.substr(atsign)) >> speed;
                }
            }
        }
    }
    return (uint64)(speed * 1000. * 1000.);
}

std::string PCM::getSupportedUarchCodenames() const
{
    std::ostringstream ostr;
    for(int32 i=0; i < static_cast<int32>(PCM::END_OF_MODEL_LIST) ; ++i)
        if(isCPUModelSupported((int)i))
            ostr << getUArchCodename(i) << ", ";
    return std::string(ostr.str().substr(0, ostr.str().length() - 2));
}

std::string PCM::getUnsupportedMessage() const
{
    std::ostringstream ostr;
    ostr << "Error: unsupported processor. Only Intel(R) processors are supported (Atom(R) and microarchitecture codename " << getSupportedUarchCodenames() << ").";
    return std::string(ostr.str());
}

void PCM::computeQPISpeedBeckton(int core_nr)
{
    uint64 startFlits = 0;
    // reset all counters
    MSR[core_nr]->write(U_MSR_PMON_GLOBAL_CTL, 1 << 29ULL);

    // enable counting on all counters on the left side (port 0-3)
    MSR[core_nr]->write(R_MSR_PMON_GLOBAL_CTL_7_0, 255);
    // disable on the right side (port 4-7)
    MSR[core_nr]->write(R_MSR_PMON_GLOBAL_CTL_15_8, 0);

    // count flits sent
    MSR[core_nr]->write(R_MSR_PORT0_IPERF_CFG0, 1ULL << 31ULL);

    // choose counter 0 to monitor R_MSR_PORT0_IPERF_CFG0
    MSR[core_nr]->write(R_MSR_PMON_CTL0, 1 + 2 * (0));

    // enable all counters
    MSR[core_nr]->write(U_MSR_PMON_GLOBAL_CTL, (1 << 28ULL) + 1);

    MSR[core_nr]->read(R_MSR_PMON_CTR0, &startFlits);

    const uint64 timerGranularity = 1000000ULL; // mks
    uint64 startTSC = getTickCount(timerGranularity, core_nr);
    uint64 endTSC;
    do
    {
        endTSC = getTickCount(timerGranularity, core_nr);
    } while (endTSC - startTSC < 200000ULL); // spin for 200 ms

    uint64 endFlits = 0;
    MSR[core_nr]->read(R_MSR_PMON_CTR0, &endFlits);
    max_qpi_speed = (endFlits - startFlits) * 8ULL * timerGranularity / (endTSC - startTSC);

}

uint32 PCM::checkCustomCoreProgramming(std::shared_ptr<SafeMsrHandle> msr)
{
    const auto core = msr->getCoreId();
    if (size_t(core) >= lastProgrammedCustomCounters.size() || canUsePerf)
    {
        // checking 'canUsePerf'because corruption detection currently works
        // only if perf is not used, see https://github.com/opcm/pcm/issues/106
        return 0;
    }
    uint32 corruptedCountersMask = 0;

    for (size_t ctr = 0; ctr < lastProgrammedCustomCounters[core].size(); ++ctr)
    {
        EventSelectRegister current;
        if (msr->read(IA32_PERFEVTSEL0_ADDR + ctr, &current.value) != sizeof(current.value))
        {
            std::cerr << "PCM Error: can not read MSR 0x" << std::hex << (IA32_PERFEVTSEL0_ADDR + ctr) <<
                " on core " << std::dec << core << "\n";
            continue;
        }
        if (canUsePerf)
        {
            current.fields.apic_int = 0; // perf sets this bit
        }
        if (current.value != lastProgrammedCustomCounters[core][ctr].value)
        {
            std::cerr << "PCM Error: someone has corrupted custom counter " << ctr << " on core " << core
                << " expected value " << lastProgrammedCustomCounters[core][ctr].value << " value read "
                << current.value << "\n";

            corruptedCountersMask |= (1<<ctr);
        }
    }
    return corruptedCountersMask;
}

bool PCM::PMUinUse()
{
    // follow the "Performance Monitoring Unit Sharing Guide" by P. Irelan and Sh. Kuo
    for (int i = 0; i < (int)num_cores; ++i)
    {
        DBG(3, "Core ", i , " examine registers");
        uint64 value = 0;
        if (perfmon_version >= 4)
        {
            MSR[i]->read(MSR_PERF_GLOBAL_INUSE, &value);
            for (uint32 j = 0; j < core_gen_counter_num_max; ++j)
            {
                if (value & (1ULL << j))
                {
                    std::cerr << "WARNING: Custom counter " << j << " is in use. MSR_PERF_GLOBAL_INUSE on core " << i << ": 0x" << std::hex << value << std::dec << "\n";
                    /*
                    Testing MSR_PERF_GLOBAL_INUSE mechanism for a moment. At a later point in time will report BUSY.
                    return true;
                    */
                }
            }
        }

        MSR[i]->read(IA32_CR_PERF_GLOBAL_CTRL, &value);
        DBG(3, "Core " , i , " IA32_CR_PERF_GLOBAL_CTRL is " , std::hex , value , std::dec);

        EventSelectRegister event_select_reg;
        event_select_reg.value = 0xFFFFFFFFFFFFFFFF;

        for (uint32 j = 0; j < core_gen_counter_num_max; ++j)
        {
            const auto count = MSR[i]->read(IA32_PERFEVTSEL0_ADDR + j, &event_select_reg.value);

            if (count && (event_select_reg.fields.event_select != 0 || event_select_reg.fields.apic_int != 0))
            {
                std::cerr << "WARNING: Core " << i <<" IA32_PERFEVTSEL" << j << "_ADDR is not zeroed " << event_select_reg.value << "\n";

                if (needToRestoreNMIWatchdog == true && event_select_reg.fields.event_select == 0x3C && event_select_reg.fields.umask == 0)
                {
                    // NMI watchdog did not clear its event, ignore it
                    continue;
                }
                return true;
            }
        }

        FixedEventControlRegister ctrl_reg;
        ctrl_reg.value = 0xffffffffffffffff;

        const auto count = MSR[i]->read(IA32_CR_FIXED_CTR_CTRL, &ctrl_reg.value);

        // Check if someone has installed pmi handler on counter overflow.
        // If so, that agent might potentially need to change counter value
        // for the "sample after"-mode messing up PCM measurements
        if (count && (ctrl_reg.fields.enable_pmi0 || ctrl_reg.fields.enable_pmi1 || ctrl_reg.fields.enable_pmi2))
        {
            std::cerr << "WARNING: Core " << i << " fixed ctrl:" << ctrl_reg.value << "\n";
            if (needToRestoreNMIWatchdog == false) // if NMI watchdog did not clear the fields, ignore it
            {
                return true;
            }
        }
#if 0
        // either os=0,usr=0 (not running) or os=1,usr=1 (fits PCM modus) are ok, other combinations are not
        if(ctrl_reg.fields.os0 != ctrl_reg.fields.usr0 ||
           ctrl_reg.fields.os1 != ctrl_reg.fields.usr1 ||
           ctrl_reg.fields.os2 != ctrl_reg.fields.usr2)
        {
           std::cerr << "WARNING: Core " << i << " fixed ctrl:" << ctrl_reg.value << "\n";
           return true;
        }
#endif
    }
#ifdef _MSC_VER
    // try to check if PMU is reserved using MSR driver
    auto hDriver = openMSRDriver();
    if (hDriver != INVALID_HANDLE_VALUE)
    {
        DWORD reslength = 0;
        uint64 result = 0;
        BOOL status = DeviceIoControl(hDriver, IO_CTL_PMU_ALLOC_SUPPORT, NULL, 0, &result, sizeof(uint64), &reslength, NULL);
        if (status == TRUE && reslength == sizeof(uint64) && result == 1)
        {
            status = DeviceIoControl(hDriver, IO_CTL_PMU_ALLOC, NULL, 0, &result, sizeof(uint64), &reslength, NULL);
            if (status == FALSE)
            {
                std::cerr << "PMU can not be allocated with msr.sys driver. Error code is " << ((reslength == sizeof(uint64)) ? std::to_string(result) : "unknown") << " \n";
                CloseHandle(hDriver);
                return true;
            }
            else
            {
                DBG(1, "Successfully allocated PMU through msr.sys");
            }
        }
        CloseHandle(hDriver);
    }
#endif
    return false;
}

const char * PCM::cpuFamilyModelToUArchCodename(const int32 cpu_family_model_, const int32 cpu_stepping_)
{
    switch(cpu_family_model_)
    {
        case CENTERTON:
            return "Centerton";
        case BAYTRAIL:
            return "Baytrail";
        case AVOTON:
            return "Avoton";
        case CHERRYTRAIL:
            return "Cherrytrail";
        case APOLLO_LAKE:
            return "Apollo Lake";
        case GEMINI_LAKE:
            return "Gemini Lake";
        case DENVERTON:
            return "Denverton";
        case SNOWRIDGE:
            return "Snowridge";
        case ELKHART_LAKE:
            return "Elkhart Lake";
        case JASPER_LAKE:
            return "Jasper Lake";
        case NEHALEM_EP:
        case NEHALEM:
            return "Nehalem/Nehalem-EP";
        case ATOM:
            return "Atom(tm)";
        case CLARKDALE:
            return "Westmere/Clarkdale";
        case WESTMERE_EP:
            return "Westmere-EP";
        case NEHALEM_EX:
            return "Nehalem-EX";
        case WESTMERE_EX:
            return "Westmere-EX";
        case SANDY_BRIDGE:
            return "Sandy Bridge";
        case JAKETOWN:
            return "Sandy Bridge-EP/Jaketown";
        case IVYTOWN:
            return "Ivy Bridge-EP/EN/EX/Ivytown";
        case HASWELLX:
            return "Haswell-EP/EN/EX";
        case BDX_DE:
            return "Broadwell-DE";
        case BDX:
            return "Broadwell-EP/EX";
        case KNL:
            return "Knights Landing";
        case IVY_BRIDGE:
            return "Ivy Bridge";
        case HASWELL:
            return "Haswell";
        case BROADWELL:
            return "Broadwell";
        case SKL:
            return "Skylake";
        case SKL_UY:
            return "Skylake U/Y";
        case KBL:
            return "Kabylake";
        case KBL_1:
            return "Kabylake/Whiskey Lake";
        case CML:
            return "Comet Lake";
        case ICL:
            return "Icelake";
        case RKL:
            return "Rocket Lake";
        case TGL:
            return "Tiger Lake";
        case ADL:
            return "Alder Lake";
        case RPL:
            return "Raptor Lake";
        case MTL:
            return "Meteor Lake";
        case LNL:
            return "Lunar Lake";
        case ARL:
            return "Arrow Lake";
        case PTL:
            return "Panther Lake";
        case SKX:
            if (cpu_stepping_ < 0)
            {
                // Stepping is not provided
                return "Skylake-SP, Cascade Lake-SP";
            }
            if (isCLX(cpu_family_model_, cpu_stepping_))
            {
                return "Cascade Lake-SP";
            }
            if (isCPX(cpu_family_model_, cpu_stepping_))
            {
                return "Cooper Lake";
            }
            return "Skylake-SP";
        case ICX:
            return "Icelake-SP";
        case SPR:
            return "Sapphire Rapids-SP";
        case EMR:
            return "Emerald Rapids-SP";
        case GNR:
            return "Granite Rapids";
        case GNR_D:
            return "Granite Rapids-D";
        case GRR:
            return "Grand Ridge";
        case SRF:
            return "Sierra Forest";
    }
    return "unknown";
}

const char * PCM::getUArchCodename(const int32 cpu_family_model_param) const
{
    auto cpu_family_model_ = cpu_family_model_param;
    auto cpu_stepping_ = -1;
    if (cpu_family_model_ < 0) {
        cpu_family_model_ = this->cpu_family_model;
        cpu_stepping_ = this->cpu_stepping;
    }

    return cpuFamilyModelToUArchCodename(cpu_family_model_, cpu_stepping_);
}

#ifdef PCM_USE_PERF
void PCM::closePerfHandles(const bool silent)
{
    if (canUsePerf)
    {
        auto cleanOne = [this](PerfEventHandleContainer & cont)
        {
            for (int i = 0; i < num_cores; ++i)
            {
                for(int c = 0; c < PERF_MAX_COUNTERS; ++c)
                {
                    auto & h = cont[i][c];
                    if (h != -1) ::close(h);
                    h = -1;
                }
            }
        };
        cleanOne(perfEventHandle);
        for (auto & cont : perfEventTaskHandle)
        {
            cleanOne(cont);
        }
        perfEventTaskHandle.clear();

        if (!silent) std::cerr << " Closed perf event handles\n";
    }
}
#endif

void PCM::cleanupPMU(const bool silent)
{
    programmed_core_pmu = false;
#ifdef PCM_USE_PERF
    closePerfHandles(silent);
    if (canUsePerf)
    {
        return;
    }
#endif

    // follow the "Performance Monitoring Unit Sharing Guide" by P. Irelan and Sh. Kuo
    for (int i = 0; i < (int)num_cores; ++i)
    {
        // disable generic counters and continue free running counting for fixed counters
        MSR[i]->write(IA32_CR_PERF_GLOBAL_CTRL, (1ULL << 32) + (1ULL << 33) + (1ULL << 34));

        for (uint32 j = 0; j < core_gen_counter_num_max; ++j)
        {
            MSR[i]->write(IA32_PERFEVTSEL0_ADDR + j, 0);
        }
        if (cleanupPEBS)
        {
            MSR[i]->write(IA32_PEBS_ENABLE_ADDR, 0ULL);
        }
    }
    cleanupPEBS = false;

    if(cpu_family_model == JAKETOWN)
        enableJKTWorkaround(false);

#ifndef PCM_SILENT
    if (!silent) std::cerr << " Zeroed PMU registers\n";
#endif
}
#ifdef PCM_SILENT
    #pragma GCC diagnostic ignored "-Wunused-parameter"
#endif
void PCM::cleanupUncorePMUs(const bool silent)
{
    for (auto & sPMUs : iioPMUs)
    {
        for (auto & pmu : sPMUs)
        {
            pmu.second.cleanup();
        }
    }

    for (auto & sPMUs : idxPMUs)
    {
        for (auto & pmu : sPMUs)
        {
            pmu.cleanup();
        }
    }
    
    for (auto& sPMUs : irpPMUs)
    {
        for (auto& pmu : sPMUs)
        {
            pmu.second.cleanup();
        }
    }

    forAllUncorePMUs([](UncorePMU & p) { p.cleanup(); });

    for (auto& sPMUs : cxlPMUs)
    {
        for (auto& pmus : sPMUs)
        {
            pmus.first.cleanup();
            pmus.second.cleanup();
        }
    }
    for (auto & uncore : serverUncorePMUs)
    {
        uncore->cleanupPMUs();
    }
#ifndef PCM_SILENT
    if (!silent) std::cerr << " Zeroed uncore PMU registers\n";
#endif
}

void PCM::resetPMU()
{
    for (int i = 0; i < (int)MSR.size(); ++i)
    {
        // disable all counters
        MSR[i]->write(IA32_CR_PERF_GLOBAL_CTRL, 0);

        for (uint32 j = 0; j < core_gen_counter_num_max; ++j)
        {
            MSR[i]->write(IA32_PERFEVTSEL0_ADDR + j, 0);
        }


        FixedEventControlRegister ctrl_reg;
        ctrl_reg.value = 0xffffffffffffffff;

        MSR[i]->read(IA32_CR_FIXED_CTR_CTRL, &ctrl_reg.value);
        if ((ctrl_reg.fields.os0 ||
             ctrl_reg.fields.usr0 ||
             ctrl_reg.fields.enable_pmi0 ||
             ctrl_reg.fields.os1 ||
             ctrl_reg.fields.usr1 ||
             ctrl_reg.fields.enable_pmi1 ||
             ctrl_reg.fields.os2 ||
             ctrl_reg.fields.usr2 ||
             ctrl_reg.fields.enable_pmi2)
            != 0)
            MSR[i]->write(IA32_CR_FIXED_CTR_CTRL, 0);
    }

#ifndef PCM_SILENT
    std::cerr << " Zeroed PMU registers\n";
#endif
}
void PCM::cleanupRDT(const bool silent)
{
    if(!(QOSMetricAvailable() && L3QOSMetricAvailable())) {
        return;
    }
#ifdef __linux__
    if (useResctrl)
    {
        resctrl.cleanup();
        return;
    }
#endif

    for(int32 core = 0; core < num_cores; core ++ )
    {
                if(!isCoreOnline(core)) continue;
        uint64 msr_pqr_assoc = 0 ;
        uint64 msr_qm_evtsel = 0;
        int32 rmid = 0;
        int32 event = 0;

        //Read 0xC8F MSR for each core
        MSR[core]->read(IA32_PQR_ASSOC, &msr_pqr_assoc);
        msr_pqr_assoc &= 0xffffffff00000000ULL;

        //Write 0xC8F MSR with RMID 0
        MSR[core]->write(IA32_PQR_ASSOC,msr_pqr_assoc);

        msr_qm_evtsel = rmid & ((1ULL<<10)-1ULL) ;
        msr_qm_evtsel <<= 32 ;
        msr_qm_evtsel |= event & ((1ULL<<8)-1ULL);

        //Write Event Id as 0 and RMID 0 to the MSR for each core
        MSR[core]->write(IA32_QM_EVTSEL,msr_qm_evtsel);

    }


    if (!silent) std::cerr << " Freeing up all RMIDs\n";
}

void PCM::setOutput(const std::string filename, const bool cerrToo)
{
     const auto pos = filename.find_last_of("/");
     if (pos != std::string::npos) {
         const std::string dir_name = filename.substr(0, pos);
         struct stat info;
         if (stat(dir_name.c_str(), &info) != 0)
         {
             std::cerr << "Output directory: " << dir_name << " doesn't exist\n";
             exit(EXIT_FAILURE);
         }
     }

     outfile = new std::ofstream(filename.c_str());
     backup_ofile = std::cout.rdbuf();
     std::cout.rdbuf(outfile->rdbuf());
     if (cerrToo)
     {
         backup_ofile_cerr = std::cerr.rdbuf();
         std::cerr.rdbuf(outfile->rdbuf());
     }
}

void PCM::restoreOutput()
{
    // restore cout back to what it was originally
    if(backup_ofile)
        std::cout.rdbuf(backup_ofile);

    if (backup_ofile_cerr)
        std::cerr.rdbuf(backup_ofile_cerr);

// close output file
    if(outfile)
        outfile->close();
}

void PCM::cleanup(const bool silent)
{
    if (MSR.empty()) return;

    if (!silent) std::cerr << "Cleaning up\n";

    cleanupPMU(silent);

    disableForceRTMAbortMode(silent);

    cleanupUncorePMUs(silent);
    cleanupRDT(silent);
#ifdef __linux__
    if (needToRestoreNMIWatchdog)
    {
        enableNMIWatchdog(silent);
        needToRestoreNMIWatchdog = false;
    }
#endif
#ifdef _MSC_VER
    // free PMU using MSR driver
    auto hDriver = openMSRDriver();
    if (hDriver != INVALID_HANDLE_VALUE)
    {
        DWORD reslength = 0;
        uint64 result = 0;
        BOOL status = DeviceIoControl(hDriver, IO_CTL_PMU_ALLOC_SUPPORT, NULL, 0, &result, sizeof(uint64), &reslength, NULL);
        if (status == TRUE && reslength == sizeof(uint64) && result == 1)
        {
            status = DeviceIoControl(hDriver, IO_CTL_PMU_FREE, NULL, 0, &result, sizeof(uint64), &reslength, NULL);
            if (status == FALSE)
            {
                std::cerr << "PMU can not be freed with msr.sys driver. Error code is " << ((reslength == sizeof(uint64)) ? std::to_string(result) : "unknown") << " \n";
            }
        }
        CloseHandle(hDriver);
    }
#endif
}

// hle is only available when cpuid has this:
// HLE: CPUID.07H.EBX.HLE [bit 4]  = 1
bool PCM::supportsHLE() const
{
    PCM_CPUID_INFO info;
    pcm_cpuid(7, 0, info); // leaf 7, subleaf 0

   return (info.reg.ebx & (0x1 << 4)) ? true : false;
}

// rtm is only available when cpuid has this:
// RTM: CPUID.07H.EBX.RTM [bit 11] = 1
bool PCM::supportsRTM() const
{
    PCM_CPUID_INFO info;
    pcm_cpuid(7, 0, info); // leaf 7, subleaf 0

    return (info.reg.ebx & (0x1 << 11)) ? true : false;
}

bool PCM::supportsRDTSCP() const
{
    static int supports = -1;
    if (supports < 0)
    {
        PCM_CPUID_INFO info;
        pcm_cpuid(0x80000001, info);
        supports = (info.reg.edx & (0x1 << 27)) ? 1 : 0;
    }
    return 1 == supports;
}

#ifdef __APPLE__

int convertUnknownToInt(size_t size, char* value)
{
    if(sizeof(int) == size)
    {
        return *(int*)value;
    }
    else if(sizeof(long) == size)
    {
        return *(long *)value;
    }
    else if(sizeof(long long) == size)
    {
        return *(long long *)value;
    }
    else
    {
        // In this case, we don't know what it is so we guess int
        return *(int *)value;
    }
}

#endif


uint64 PCM::getTickCount(uint64 multiplier, int32 core)
{
    if (core == -1) core = socketRefCore[0];
    return (multiplier * getInvariantTSC_Fast(core)) / getNominalFrequency();
}

uint64 PCM::getInvariantTSC_Fast(uint32 core)
{
    if (supportsRDTSCP())
    {
        TemporalThreadAffinity aff(core);
        return RDTSCP();
    }
    else if (core < MSR.size())
    {
        uint64 cInvariantTSC = 0;
        MSR[core]->read(IA32_TIME_STAMP_COUNTER, &cInvariantTSC);
        if (cInvariantTSC) return cInvariantTSC;
    }
    std::cerr << "ERROR:  cannot read time stamp counter\n";
    return 0ULL;
}

SystemCounterState getSystemCounterState()
{
    PCM * inst = PCM::getInstance();
    SystemCounterState result;
    if (inst) result = inst->getSystemCounterState();
    return result;
}

SocketCounterState getSocketCounterState(uint32 socket)
{
    PCM * inst = PCM::getInstance();
    SocketCounterState result;
    if (inst) result = inst->getSocketCounterState(socket);
    return result;
}

CoreCounterState getCoreCounterState(uint32 core)
{
    PCM * inst = PCM::getInstance();
    CoreCounterState result;
    if (inst) result = inst->getCoreCounterState(core);
    return result;
}

#ifdef PCM_USE_PERF
void PCM::readPerfData(uint32 core, std::vector<uint64> & outData)
{
    if (perfEventTaskHandle.empty() == false)
    {
        std::fill(outData.begin(), outData.end(), 0);
        for (const auto & handleArray : perfEventTaskHandle)
        {
            for (size_t ctr = 0; ctr < PERF_MAX_COUNTERS; ++ctr)
            {
                const int fd = handleArray[core][ctr];
                if (fd != -1)
                {
                    uint64 result{0ULL};
                    const int status = ::read(fd, &result, sizeof(result));
                    if (status != sizeof(result))
                    {
                        std::cerr << "PCM Error: failed to read from Linux perf handle " << fd <<  "\n";
                    }
                    else
                    {
                        outData[ctr] += result;
                    }
                }
            }
        }
        return;
    }
    auto readPerfDataHelper = [this](const uint32 core, std::vector<uint64>& outData, const uint32 leader, const uint32 num_counters)
    {
        if (perfEventHandle[core][leader] < 0)
        {
            std::fill(outData.begin(), outData.end(), 0);
            return;
        }
        uint64 data[1 + PERF_MAX_COUNTERS];
        const int32 bytes2read = sizeof(uint64) * (1 + num_counters);
        assert(num_counters <= PERF_MAX_COUNTERS);
        int result = ::read(perfEventHandle[core][leader], data, bytes2read);
        // data layout: nr counters; counter 0, counter 1, counter 2,...
        if (result != bytes2read)
        {
            std::cerr << "Error while reading perf data. Result is " << result << "\n";
            std::cerr << "Check if you run other competing Linux perf clients.\n";
        }
        else if (data[0] != num_counters)
        {
            std::cerr << "Number of counters read from perf is wrong. Elements read: " << data[0] << "\n";
        }
        else
        {
            /*
            if (core == 0)
            {
                std::unique_lock<std::mutex> _(instanceCreationMutex);
                std::cerr << "DEBUG: perf raw: " << std::dec;
                for (uint32 p=0; p < (1 + num_counters) ; ++p) std::cerr << data[p] << " ";
                std::cerr << "\n";
            }
            */
            // copy all counters, they start from position 1 in data
            std::copy((data + 1), (data + 1) + data[0], outData.begin());
        }
    };
    readPerfDataHelper(core, outData, PERF_GROUP_LEADER_COUNTER, core_fixed_counter_num_used + core_gen_counter_num_used);
    if (isHWTMAL1Supported() && perfSupportsTopDown())
    {
        std::vector<uint64> outTopDownData(outData.size(), 0);
        const auto topdownCtrNum = isHWTMAL2Supported() ? PERF_TOPDOWN_COUNTERS : PERF_TOPDOWN_COUNTERS_L1;
        readPerfDataHelper(core, outTopDownData, PERF_TOPDOWN_GROUP_LEADER_COUNTER, topdownCtrNum);
        std::copy(outTopDownData.begin(), outTopDownData.begin() + topdownCtrNum, outData.begin() + core_fixed_counter_num_used + core_gen_counter_num_used);
    }
}
#endif

void BasicCounterState::readAndAggregateTSC(std::shared_ptr<SafeMsrHandle> msr)
{
    uint64 cInvariantTSC = 0;
    PCM * m = PCM::getInstance();
    const auto cpu_family_model = m->getCPUFamilyModel();
    if (m->isAtom() == false || cpu_family_model == PCM::AVOTON)
    {
        cInvariantTSC = m->getInvariantTSC_Fast(msr->getCoreId());
        MSRValues[IA32_TIME_STAMP_COUNTER] = cInvariantTSC;
    }
    else
    {
#ifdef _MSC_VER
        cInvariantTSC = ((static_cast<uint64>(GetTickCount()/1000ULL)))*m->getNominalFrequency();
#else
        struct timeval tp;
        gettimeofday(&tp, NULL);
        cInvariantTSC = (double(tp.tv_sec) + tp.tv_usec / 1000000.)*m->getNominalFrequency();
#endif
    }
    InvariantTSC += cInvariantTSC;
}

void BasicCounterState::readAndAggregate(std::shared_ptr<SafeMsrHandle> msr)
{
    assert(msr.get());
    uint64 cInstRetiredAny = 0, cCpuClkUnhaltedThread = 0, cCpuClkUnhaltedRef = 0;
    uint64 cL3Occupancy = 0;
    uint64 cCustomEvents[PERF_MAX_CUSTOM_COUNTERS] = {0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL, 0ULL };
    uint64 cCStateResidency[PCM::MAX_C_STATE + 1];
    std::fill(cCStateResidency, cCStateResidency + PCM::MAX_C_STATE + 1, 0);
    uint64 thermStatus = 0;
    uint64 cSMICount = 0;
    uint64 cFrontendBoundSlots = 0;
    uint64 cBadSpeculationSlots = 0;
    uint64 cBackendBoundSlots = 0;
    uint64 cRetiringSlots = 0;
    uint64 cAllSlotsRaw = 0;
    uint64 cMemBoundSlots = 0;
    uint64 cFetchLatSlots = 0;
    uint64 cBrMispredSlots = 0;
    uint64 cHeavyOpsSlots = 0;
    const int32 core_id = msr->getCoreId();
    TemporalThreadAffinity tempThreadAffinity(core_id); // speedup trick for Linux

    PCM * m = PCM::getInstance();
    assert(m);
    const auto core_global_ctrl_value = m->core_global_ctrl_value;
    const bool freezeUnfreeze = m->canUsePerf == false && core_global_ctrl_value != 0ULL;
    if (freezeUnfreeze)
    {
        msr->write(IA32_CR_PERF_GLOBAL_CTRL, 0ULL); // freeze
    }

    const int32 core_gen_counter_num_max = m->getMaxCustomCoreEvents();
    uint64 overflows = 0;

    const auto corruptedCountersMask = m->checkCustomCoreProgramming(msr);
    // reading core PMU counters
#ifdef PCM_USE_PERF
    if(m->canUsePerf)
    {
        std::vector<uint64> perfData(PERF_MAX_COUNTERS, 0ULL);
        m->readPerfData(msr->getCoreId(), perfData);
        cInstRetiredAny =       perfData[PCM::PERF_INST_RETIRED_POS];
        cCpuClkUnhaltedThread = perfData[PCM::PERF_CPU_CLK_UNHALTED_THREAD_POS];
        cCpuClkUnhaltedRef =    perfData[PCM::PERF_CPU_CLK_UNHALTED_REF_POS];
        for (int i = 0; i < core_gen_counter_num_max; ++i)
        {
            cCustomEvents[i] = perfData[PCM::PERF_GEN_EVENT_0_POS + i];
        }
        if (m->isHWTMAL1Supported() && m->perfSupportsTopDown())
        {
            cFrontendBoundSlots =   perfData[m->perfTopDownPos[PCM::PERF_TOPDOWN_FRONTEND_POS]];
            cBadSpeculationSlots =  perfData[m->perfTopDownPos[PCM::PERF_TOPDOWN_BADSPEC_POS]];
            cBackendBoundSlots =    perfData[m->perfTopDownPos[PCM::PERF_TOPDOWN_BACKEND_POS]];
            cRetiringSlots =        perfData[m->perfTopDownPos[PCM::PERF_TOPDOWN_RETIRING_POS]];
            cAllSlotsRaw =          perfData[m->perfTopDownPos[PCM::PERF_TOPDOWN_SLOTS_POS]];
            if (core_id == 0) { DBG(3, "All: ", cAllSlotsRaw , " FE: " , cFrontendBoundSlots , " BAD-SP: " , cBadSpeculationSlots , " BE: " , cBackendBoundSlots , " RET: " , cRetiringSlots); }
            if (m->isHWTMAL2Supported())
            {
                cMemBoundSlots = perfData[m->perfTopDownPos[PCM::PERF_TOPDOWN_MEM_BOUND_POS]];
                cFetchLatSlots = perfData[m->perfTopDownPos[PCM::PERF_TOPDOWN_FETCH_LAT_POS]];
                cBrMispredSlots = perfData[m->perfTopDownPos[PCM::PERF_TOPDOWN_BR_MISPRED_POS]];;
                cHeavyOpsSlots = perfData[m->perfTopDownPos[PCM::PERF_TOPDOWN_HEAVY_OPS_POS]];
            }
        }
    }
    else
#endif
    {
        {
            msr->read(IA32_PERF_GLOBAL_STATUS, &overflows); // read overflows
            DBG(3,  "core_id = " , core_id , " IA32_PERF_GLOBAL_STATUS: " , overflows);

            msr->read(INST_RETIRED_ADDR, &cInstRetiredAny);
            msr->read(CPU_CLK_UNHALTED_THREAD_ADDR, &cCpuClkUnhaltedThread);
            msr->read(CPU_CLK_UNHALTED_REF_ADDR, &cCpuClkUnhaltedRef);
            for (int i = 0; i < core_gen_counter_num_max; ++i)
            {
                msr->read(IA32_PMC0 + i, &cCustomEvents[i]);
            }
        }

        msr->write(IA32_PERF_GLOBAL_OVF_CTRL, overflows); // clear overflows

        if (m->isHWTMAL1Supported())
        {
            uint64 perfMetrics = 0, slots = 0;
            msr->lock();
            msr->read(PERF_METRICS_ADDR, &perfMetrics);
            msr->read(TOPDOWN_SLOTS_ADDR, &slots);
           DBG(3,  "core_id = " , core_id , " PERF_METRICS = ", perfMetrics, " TOPDOWN_SLOTS = ", slots);
            msr->write(PERF_METRICS_ADDR, 0);
            msr->write(TOPDOWN_SLOTS_ADDR, 0);
            cFrontendBoundSlots = extract_bits(perfMetrics, 16, 23);
            cBadSpeculationSlots = extract_bits(perfMetrics, 8, 15);
            cBackendBoundSlots = extract_bits(perfMetrics, 24, 31);
            cRetiringSlots = extract_bits(perfMetrics, 0, 7);
            if (m->isHWTMAL2Supported())
            {
                cMemBoundSlots = extract_bits(perfMetrics,  32 + 3*8, 32 + 3*8 + 7);
                cFetchLatSlots = extract_bits(perfMetrics,  32 + 2*8, 32 + 2*8 + 7);
                cBrMispredSlots = extract_bits(perfMetrics, 32 + 1*8, 32 + 1*8 + 7);
                cHeavyOpsSlots = extract_bits(perfMetrics,    32 + 0*8, 32 + 0*8 + 7);
            }
            const double total = double(cFrontendBoundSlots + cBadSpeculationSlots + cBackendBoundSlots + cRetiringSlots);
            if (true)
            {
                cFrontendBoundSlots = m->FrontendBoundSlots[core_id] += (total != 0) ? uint64((double(cFrontendBoundSlots) / total) * double(slots)) : 0;
                cBadSpeculationSlots = m->BadSpeculationSlots[core_id] += (total != 0) ? uint64((double(cBadSpeculationSlots) / total) * double(slots)) : 0;
                cBackendBoundSlots = m->BackendBoundSlots[core_id] += (total != 0) ? uint64((double(cBackendBoundSlots) / total) * double(slots)) : 0;
                cRetiringSlots = m->RetiringSlots[core_id] += (total != 0) ? uint64((double(cRetiringSlots) / total) * double(slots)) : 0;
                if (m->isHWTMAL2Supported())
                {
                    cMemBoundSlots = m->MemBoundSlots[core_id] += (total != 0) ? uint64((double(cMemBoundSlots) / total) * double(slots)) : 0;
                    cFetchLatSlots = m->FetchLatSlots[core_id] += (total != 0) ? uint64((double(cFetchLatSlots) / total) * double(slots)) : 0;
                    cBrMispredSlots = m->BrMispredSlots[core_id] += (total != 0) ? uint64((double(cBrMispredSlots) / total) * double(slots)) : 0;
                    cHeavyOpsSlots = m->HeavyOpsSlots[core_id] += (total != 0) ? uint64((double(cHeavyOpsSlots) / total) * double(slots)) : 0;
                }
            }
            cAllSlotsRaw = m->AllSlotsRaw[core_id] += slots;
            DBG(3, "HWTMAL1: ", slots , " " , cFrontendBoundSlots , " " , cBadSpeculationSlots , " " , cBackendBoundSlots , " " , cRetiringSlots);
            msr->unlock();
        }
    }

    for (int i = 0; i < core_gen_counter_num_max; ++i)
    {
        if (corruptedCountersMask & (1<<i)) cCustomEvents[i] = ~0ULL;
    }

    DBG(3, msr->getCoreId() , " " , cInstRetiredAny);
    if (m->L3CacheOccupancyMetricAvailable() && m->useResctrl == false)
    {
        msr->lock();
        uint64 event = 1;
        m->initQOSevent(event, core_id);
        msr->read(IA32_QM_CTR, &cL3Occupancy);
        DBG(3, "readAndAggregate reading IA32_QM_CTR " , std::dec , cL3Occupancy , std::dec);
        msr->unlock();
    }

    m->readAndAggregateMemoryBWCounters(static_cast<uint32>(core_id), *this);

    readAndAggregateTSC(msr);

    // reading core C state counters
    for (int i = 0; i <= (int)(PCM::MAX_C_STATE); ++i)
    {
        if (m->coreCStateMsr && m->coreCStateMsr[i])
        {
            const auto index = m->coreCStateMsr[i];
            msr->read(index, &(cCStateResidency[i]));
            MSRValues[index] = cCStateResidency[i];
        }
    }

    // reading temperature
    msr->read(MSR_IA32_THERM_STATUS, &thermStatus);
    MSRValues[MSR_IA32_THERM_STATUS] = thermStatus;

    msr->read(MSR_SMI_COUNT, &cSMICount);
    MSRValues[MSR_SMI_COUNT] = cSMICount;

    InstRetiredAny += checked_uint64(m->extractCoreFixedCounterValue(cInstRetiredAny), extract_bits(overflows, 32, 32));
    CpuClkUnhaltedThread += checked_uint64(m->extractCoreFixedCounterValue(cCpuClkUnhaltedThread), extract_bits(overflows, 33, 33));
    CpuClkUnhaltedRef += checked_uint64(m->extractCoreFixedCounterValue(cCpuClkUnhaltedRef), extract_bits(overflows, 34, 34));
    for (int i = 0; i < core_gen_counter_num_max; ++i)
    {
        Event[i] += checked_uint64(m->extractCoreGenCounterValue(cCustomEvents[i]), extract_bits(overflows, i, i));
    }
#ifdef __linux__
    if (m->useResctrl)
    {
        L3Occupancy = m->resctrl.getL3OCC(core_id) / 1024;
    }
    else
#endif
    {
        DBG(3, "Scaling Factor ", m->L3ScalingFactor);
        cL3Occupancy = m->extractQOSMonitoring(cL3Occupancy);
        L3Occupancy = (cL3Occupancy==PCM_INVALID_QOS_MONITORING_DATA)? PCM_INVALID_QOS_MONITORING_DATA : (uint64)((double)(cL3Occupancy * m->L3ScalingFactor) / 1024.0);
    }
    for(int i=0; i <= int(PCM::MAX_C_STATE);++i)
        CStateResidency[i] += cCStateResidency[i];
    ThermalHeadroom = extractThermalHeadroom(thermStatus);
    SMICount += cSMICount;
    FrontendBoundSlots  += cFrontendBoundSlots;
    BadSpeculationSlots += cBadSpeculationSlots;
    BackendBoundSlots   += cBackendBoundSlots;
    RetiringSlots       += cRetiringSlots;
    AllSlotsRaw         += cAllSlotsRaw;
    MemBoundSlots       += cMemBoundSlots;
    FetchLatSlots       += cFetchLatSlots;
    BrMispredSlots      += cBrMispredSlots;
    HeavyOpsSlots       += cHeavyOpsSlots;

    if (freezeUnfreeze)
    {
        msr->write(IA32_CR_PERF_GLOBAL_CTRL, core_global_ctrl_value); // unfreeze
    }
}

PCM::ErrorCode PCM::programServerUncoreLatencyMetrics(bool enable_pmm)
{
    uint32 DDRConfig[4] = {0,0,0,0};

    if (enable_pmm == false)
    {   //DDR is false
        if (ICX == cpu_family_model || SPR == cpu_family_model || EMR == cpu_family_model)
	{
            DDRConfig[0] = MC_CH_PCI_PMON_CTL_EVENT(0x80) + MC_CH_PCI_PMON_CTL_UMASK(1);  // DRAM RPQ occupancy
            DDRConfig[1] = MC_CH_PCI_PMON_CTL_EVENT(0x10) + MC_CH_PCI_PMON_CTL_UMASK(1);  // DRAM RPQ Insert
            DDRConfig[2] = MC_CH_PCI_PMON_CTL_EVENT(0x81) + MC_CH_PCI_PMON_CTL_UMASK(0);  // DRAM WPQ Occupancy
            DDRConfig[3] = MC_CH_PCI_PMON_CTL_EVENT(0x20) + MC_CH_PCI_PMON_CTL_UMASK(0);  // DRAM WPQ Insert

	} else {

            DDRConfig[0] = MC_CH_PCI_PMON_CTL_EVENT(0x80) + MC_CH_PCI_PMON_CTL_UMASK(0);  // DRAM RPQ occupancy
            DDRConfig[1] = MC_CH_PCI_PMON_CTL_EVENT(0x10) + MC_CH_PCI_PMON_CTL_UMASK(0);  // DRAM RPQ Insert
            DDRConfig[2] = MC_CH_PCI_PMON_CTL_EVENT(0x81) + MC_CH_PCI_PMON_CTL_UMASK(0);  // DRAM WPQ Occupancy
            DDRConfig[3] = MC_CH_PCI_PMON_CTL_EVENT(0x20) + MC_CH_PCI_PMON_CTL_UMASK(0);  // DRAM WPQ Insert
	}
    } else {
        DDRConfig[0] = MC_CH_PCI_PMON_CTL_EVENT(0xe0) + MC_CH_PCI_PMON_CTL_UMASK(1);  // PMM RDQ occupancy
        DDRConfig[1] = MC_CH_PCI_PMON_CTL_EVENT(0xe3) + MC_CH_PCI_PMON_CTL_UMASK(0);  // PMM RDQ Insert
        DDRConfig[2] = MC_CH_PCI_PMON_CTL_EVENT(0xe4) + MC_CH_PCI_PMON_CTL_UMASK(1);  // PMM WPQ Occupancy
        DDRConfig[3] = MC_CH_PCI_PMON_CTL_EVENT(0xe7) + MC_CH_PCI_PMON_CTL_UMASK(0);  // PMM WPQ Insert
    }

    if (DDRLatencyMetricsAvailable())
    {
        for (size_t i = 0; i < (size_t)serverUncorePMUs.size(); ++i)
        {
            serverUncorePMUs[i]->programIMC(DDRConfig);
        }
    }
    return PCM::Success;
}

PCM::ErrorCode PCM::programServerUncoreMemoryMetrics(const ServerUncoreMemoryMetrics & metrics, int rankA, int rankB)
{
    if (MSR.empty() || serverUncorePMUs.empty())  return PCM::MSRAccessDenied;

    for (int i = 0; (i < (int)serverUncorePMUs.size()) && MSR.size(); ++i)
    {
         serverUncorePMUs[i]->programServerUncoreMemoryMetrics(metrics, rankA, rankB);
    }
    programCXLCM();
    programCXLDP();

    return PCM::Success;
}

PCM::ErrorCode PCM::programServerUncorePowerMetrics(int mc_profile, int pcu_profile, int * freq_bands)
{
    if(MSR.empty() || serverUncorePMUs.empty())  return PCM::MSRAccessDenied;

    uint32 PCUCntConf[4] = {0,0,0,0};

    auto printError = [this](const char * eventCategory)
    {
        assert(eventCategory);
        std::cerr << "ERROR: no " << eventCategory << " events defined for CPU family " << cpu_family << " model " << cpu_model_private << "\n";
    };

    switch (cpu_family_model)
    {
        case SPR:
        case EMR:
        case SRF:
        case GNR:
        case GNR_D:
            PCUCntConf[0] = PCU_MSR_PMON_CTL_EVENT(1); // clock ticks
            break;
        default:
            PCUCntConf[0] = PCU_MSR_PMON_CTL_EVENT(0); // clock ticks
    }

    switch(pcu_profile)
    {
    case 0:
         PCUCntConf[1] =  PCU_MSR_PMON_CTL_EVENT(0xB); // FREQ_BAND0_CYCLES
         PCUCntConf[2] =  PCU_MSR_PMON_CTL_EVENT(0xC); // FREQ_BAND1_CYCLES
         PCUCntConf[3] =  PCU_MSR_PMON_CTL_EVENT(0xD); // FREQ_BAND2_CYCLES
         break;
    case 1:
         switch (cpu_family_model)
         {
             case SPR:
             case EMR:
             case SRF:
             case GNR:
             case GNR_D:
                 PCUCntConf[1] =  PCU_MSR_PMON_CTL_EVENT(0x35); // POWER_STATE_OCCUPANCY.C0
                 PCUCntConf[2] =  PCU_MSR_PMON_CTL_EVENT(0x36); // POWER_STATE_OCCUPANCY.C3
                 PCUCntConf[3] =  PCU_MSR_PMON_CTL_EVENT(0x37); // POWER_STATE_OCCUPANCY.C6
                 break;
             default:
                 PCUCntConf[1] =  PCU_MSR_PMON_CTL_EVENT(0x80) + PCU_MSR_PMON_CTL_OCC_SEL(1); // POWER_STATE_OCCUPANCY.C0 using CLOCKTICKS + 8th-bit
                 PCUCntConf[2] =  PCU_MSR_PMON_CTL_EVENT(0x80) + PCU_MSR_PMON_CTL_OCC_SEL(2); // POWER_STATE_OCCUPANCY.C3 using CLOCKTICKS + 8th-bit
                 PCUCntConf[3] =  PCU_MSR_PMON_CTL_EVENT(0x80) + PCU_MSR_PMON_CTL_OCC_SEL(3); // POWER_STATE_OCCUPANCY.C6 using CLOCKTICKS + 8th-bit
         }
         break;
    case 2:
         PCUCntConf[1] =  PCU_MSR_PMON_CTL_EVENT(0x09); // PROCHOT_INTERNAL_CYCLES
         PCUCntConf[2] =  PCU_MSR_PMON_CTL_EVENT(0x0A); // PROCHOT_EXTERNAL_CYCLES
         PCUCntConf[3] =  PCU_MSR_PMON_CTL_EVENT(0x04); // Thermal frequency limit cycles: FREQ_MAX_LIMIT_THERMAL_CYCLES
         break;
    case 3:
         PCUCntConf[1] =  PCU_MSR_PMON_CTL_EVENT(0x04); // Thermal frequency limit cycles: FREQ_MAX_LIMIT_THERMAL_CYCLES
         PCUCntConf[2] =  PCU_MSR_PMON_CTL_EVENT(0x05); // Power frequency limit cycles: FREQ_MAX_POWER_CYCLES
         PCUCntConf[3] =  PCU_MSR_PMON_CTL_EVENT(0x07); // Clipped frequency limit cycles: FREQ_MAX_CURRENT_CYCLES (not supported on SKX,ICX,SNOWRIDGE,SPR,EMR,SRF,GNR)
         break;
    case 4: // not supported on SKX, ICX, SNOWRIDGE, SPR, EMR
         PCUCntConf[1] =  PCU_MSR_PMON_CTL_EVENT(0x06); // OS frequency limit cycles: FREQ_MAX_OS_CYCLES
         PCUCntConf[2] =  PCU_MSR_PMON_CTL_EVENT(0x05); // Power frequency limit cycles: FREQ_MAX_POWER_CYCLES
         PCUCntConf[3] =  PCU_MSR_PMON_CTL_EVENT(0x07); // Clipped frequency limit cycles: FREQ_MAX_CURRENT_CYCLES (not supported on SKX,ICX,SNOWRIDGE,SPR,EMR,SRF,GNR)
         break;
    case 5:
         if (JAKETOWN == cpu_family_model)
         {
             PCUCntConf[1] =  PCU_MSR_PMON_CTL_EVENT(0) + PCU_MSR_PMON_CTL_EXTRA_SEL + PCU_MSR_PMON_CTL_EDGE_DET ; // number of frequency transitions
             PCUCntConf[2] =  PCU_MSR_PMON_CTL_EVENT(0) + PCU_MSR_PMON_CTL_EXTRA_SEL ; // cycles spent changing frequency
         } else if (IVYTOWN == cpu_family_model)
         {
             PCUCntConf[1] =  PCU_MSR_PMON_CTL_EVENT(0x60) + PCU_MSR_PMON_CTL_EDGE_DET ; // number of frequency transitions
             PCUCntConf[2] =  PCU_MSR_PMON_CTL_EVENT(0x60) ; // cycles spent changing frequency: FREQ_TRANS_CYCLES
         } else if (
               HASWELLX == cpu_family_model
            || BDX_DE == cpu_family_model
            || BDX == cpu_family_model
            || SKX == cpu_family_model
            || ICX == cpu_family_model
            || SNOWRIDGE == cpu_family_model
            || SPR == cpu_family_model
            || EMR == cpu_family_model
            || SRF == cpu_family_model
            || GNR == cpu_family_model
            || GNR_D == cpu_family_model
            )
         {
             PCUCntConf[1] =  PCU_MSR_PMON_CTL_EVENT(0x74) + PCU_MSR_PMON_CTL_EDGE_DET ; // number of frequency transitions
             PCUCntConf[2] =  PCU_MSR_PMON_CTL_EVENT(0x74) ; // cycles spent changing frequency: FREQ_TRANS_CYCLES
             if(HASWELLX == cpu_family_model)
             {
                 PCUCntConf[3] =  PCU_MSR_PMON_CTL_EVENT(0x79) + PCU_MSR_PMON_CTL_EDGE_DET ; // number of UFS transitions
                 PCUCntConf[0] =  PCU_MSR_PMON_CTL_EVENT(0x79)                             ; // UFS transition cycles
             }
         } else
         {
             printError("frequency transition");
         }
         break;
    case 6:
         if (IVYTOWN == cpu_family_model)
         {
             PCUCntConf[2] =  PCU_MSR_PMON_CTL_EVENT(0x2B) + PCU_MSR_PMON_CTL_EDGE_DET ; // PC2 transitions
             PCUCntConf[3] =  PCU_MSR_PMON_CTL_EVENT(0x2D) + PCU_MSR_PMON_CTL_EDGE_DET ; // PC6 transitions
         } else if (
               HASWELLX == cpu_family_model
            || BDX_DE == cpu_family_model
            || BDX == cpu_family_model
            || SKX == cpu_family_model
            || ICX == cpu_family_model
            || SNOWRIDGE == cpu_family_model
            || SPR == cpu_family_model
            || EMR == cpu_family_model
            || SRF == cpu_family_model
            || GNR == cpu_family_model
            || GNR_D == cpu_family_model
            )
         {
             PCUCntConf[0] =  PCU_MSR_PMON_CTL_EVENT(0x4E)                             ; // PC1e residenicies (not supported on SKX,ICX,SNOWRIDGE,SPR,EMR,SRF,GNR)
             PCUCntConf[1] =  PCU_MSR_PMON_CTL_EVENT(0x4E) + PCU_MSR_PMON_CTL_EDGE_DET ; // PC1 transitions (not supported on SKX,ICX,SNOWRIDGE,SPR,EMR,SRF,GNR)
             PCUCntConf[2] =  PCU_MSR_PMON_CTL_EVENT(0x2B) + PCU_MSR_PMON_CTL_EDGE_DET ; // PC2e transitions
             PCUCntConf[3] =  PCU_MSR_PMON_CTL_EVENT(0x2D) + PCU_MSR_PMON_CTL_EDGE_DET ; // PC6 transitions
         } else
         {
             printError("package C-state transition");
         }
         break;
     case 7:
         if (HASWELLX == cpu_family_model || BDX_DE == cpu_family_model || BDX == cpu_family_model)
         {
             PCUCntConf[0] =  PCU_MSR_PMON_CTL_EVENT(0x7E) ; // UFS_TRANSITIONS_PERF_P_LIMIT
             PCUCntConf[1] =  PCU_MSR_PMON_CTL_EVENT(0x7D) ; // UFS_TRANSITIONS_IO_P_LIMIT
             PCUCntConf[2] =  PCU_MSR_PMON_CTL_EVENT(0x7A) ; // UFS_TRANSITIONS_UP_RING_TRAFFIC
             PCUCntConf[3] =  PCU_MSR_PMON_CTL_EVENT(0x7B) ; // UFS_TRANSITIONS_UP_STALL_CYCLES
         } else
         {
             printError("UFS transition");
         }
         break;
    case 8:
         if (HASWELLX == cpu_family_model || BDX_DE == cpu_family_model || BDX == cpu_family_model)
         {
             PCUCntConf[0] =  PCU_MSR_PMON_CTL_EVENT(0x7C) ; // UFS_TRANSITIONS_DOWN
         } else
         {
             printError("UFS transition");
         }
         break;
    default:
         std::cerr << "ERROR: unsupported PCU profile " << pcu_profile << "\n";
    }

    for (auto& u : serverUncorePMUs)
    {
        u->program_power_metrics(mc_profile);
    }
    uint64 filter = 0;
    if (freq_bands == NULL)
    {
        filter =
            PCU_MSR_PMON_BOX_FILTER_BAND_0(10) + // 1000 MHz
            PCU_MSR_PMON_BOX_FILTER_BAND_1(20) + // 2000 MHz
            PCU_MSR_PMON_BOX_FILTER_BAND_2(30);  // 3000 MHz
    }
    else
    {
        filter =
            PCU_MSR_PMON_BOX_FILTER_BAND_0(freq_bands[0]) +
            PCU_MSR_PMON_BOX_FILTER_BAND_1(freq_bands[1]) +
            PCU_MSR_PMON_BOX_FILTER_BAND_2(freq_bands[2]);
    }
    programPCU(PCUCntConf, filter);

    return PCM::Success;
}

void PCM::programPCU(uint32* PCUCntConf, const uint64 filter)
{
    programUncorePMUs(PCU_PMU_ID, [&PCUCntConf, &filter](UncorePMU& pmu)
    {
        pmu.initFreeze(UNC_PMON_UNIT_CTL_FRZ_EN);

        if (pmu.filter[0].get())
        {
            *pmu.filter[0] = filter;
        }

        program(pmu, &PCUCntConf[0], &PCUCntConf[4], UNC_PMON_UNIT_CTL_FRZ_EN);
    });
}

PCM::ErrorCode PCM::program(const RawPMUConfigs& curPMUConfigs_, const bool silent, const int pid)
{
    if (MSR.empty())  return PCM::MSRAccessDenied;
    threadMSRConfig = RawPMUConfig{};
    packageMSRConfig = RawPMUConfig{};
    pcicfgConfig = RawPMUConfig{};
    mmioConfig = RawPMUConfig{};
    pmtConfig = RawPMUConfig{};
    RawPMUConfigs curPMUConfigs = curPMUConfigs_;
    constexpr auto globalRegPos = 0ULL;
    PCM::ExtendedCustomCoreEventDescription conf;
    auto updateRegs = [this, &conf](const RawPMUConfig& corePMUConfig, EventSelectRegister* regs) -> bool
    {
        if (corePMUConfig.programmable.size() > (size_t)getMaxCustomCoreEvents())
        {
            std::cerr << "ERROR: trying to program " << corePMUConfig.programmable.size() << " core PMU counters, which exceeds the max num possible (" << getMaxCustomCoreEvents() << ").\n";
            for (const auto& e : corePMUConfig.programmable)
            {
                std::cerr << "      Event: " << e.second << "\n";
            }
            return false;
        }
        size_t c = 0;
        for (; c < corePMUConfig.programmable.size() && c < (size_t)getMaxCustomCoreEvents() && c < PERF_MAX_CUSTOM_COUNTERS; ++c)
        {
            regs[c].value = corePMUConfig.programmable[c].first[0];
        }
        conf.nGPCounters = (std::max)((uint32)c, conf.nGPCounters);
        return true;
    };
    FixedEventControlRegister fixedReg;
    auto setOtherConf = [&conf, &fixedReg
#ifdef _MSC_VER
        , &globalRegPos
#endif
            ](const RawPMUConfig& corePMUConfig)
    {
        if ((size_t)globalRegPos < corePMUConfig.programmable.size())
        {
            conf.OffcoreResponseMsrValue[0] = corePMUConfig.programmable[globalRegPos].first[OCR0Pos];
            conf.OffcoreResponseMsrValue[1] = corePMUConfig.programmable[globalRegPos].first[OCR1Pos];
            conf.LoadLatencyMsrValue = corePMUConfig.programmable[globalRegPos].first[LoadLatencyPos];
            conf.FrontendMsrValue = corePMUConfig.programmable[globalRegPos].first[FrontendPos];
        }
        if (corePMUConfig.fixed.empty())
        {
            conf.fixedCfg = NULL; // default
        }
        else
        {
            fixedReg.value = 0;
            for (const auto& cfg : corePMUConfig.fixed)
            {
                fixedReg.value |= uint64(cfg.first[0]);
            }
            conf.fixedCfg = &fixedReg;
        }
    };
    EventSelectRegister regs[PERF_MAX_CUSTOM_COUNTERS];
    EventSelectRegister atomRegs[PERF_MAX_CUSTOM_COUNTERS];
    conf.OffcoreResponseMsrValue[0] = 0;
    conf.OffcoreResponseMsrValue[1] = 0;
    if (curPMUConfigs.count("core") > 0)
    {
        // need to program core PMU first
        const auto & corePMUConfig = curPMUConfigs["core"];
        if (updateRegs(corePMUConfig, regs) == false)
        {
            return PCM::UnknownError;
        }
        conf.gpCounterCfg = regs;
        setOtherConf(corePMUConfig);
        conf.defaultUncoreProgramming = false;
        curPMUConfigs.erase("core");

        if (curPMUConfigs.count("atom"))
        {
            const auto & atomPMUConfig = curPMUConfigs["atom"];
            if (updateRegs(atomPMUConfig, atomRegs) == false)
            {
                return PCM::UnknownError;
            }
            conf.gpCounterHybridAtomCfg = atomRegs;
            curPMUConfigs.erase("atom");
        }
        const auto status = program(PCM::EXT_CUSTOM_CORE_EVENTS, &conf, silent, pid);
        if (status != PCM::Success)
        {
            return status;
        }
    }
    else if (curPMUConfigs.count("atom") > 0) // no core, only atom
    {
        const auto& atomPMUConfig = curPMUConfigs["atom"];
        if (updateRegs(atomPMUConfig, atomRegs) == false)
        {
            return PCM::UnknownError;
        }
        conf.gpCounterHybridAtomCfg = atomRegs;
        setOtherConf(atomPMUConfig);
        conf.defaultUncoreProgramming = false;
        curPMUConfigs.erase("atom");

        const auto status = program(PCM::EXT_CUSTOM_CORE_EVENTS, &conf, silent, pid);
        if (status != PCM::Success)
        {
            return status;
        }
    }
    for (auto& pmuConfig : curPMUConfigs)
    {
        const auto & type = pmuConfig.first;
        const auto & events = pmuConfig.second;
        if (events.programmable.empty() && events.fixed.empty())
        {
            continue;
        }
        if (events.programmable.size() > ServerUncoreCounterState::maxCounters && isRegisterEvent(type) == false)
        {
            std::cerr << "ERROR: trying to program " << events.programmable.size() << " uncore PMU counters, which exceeds the max num possible (" << ServerUncoreCounterState::maxCounters << ").";
            return PCM::UnknownError;
        }
        uint32 events32[ServerUncoreCounterState::maxCounters] = { 0,0,0,0,0,0,0,0 };
        uint64 events64[ServerUncoreCounterState::maxCounters] = { 0,0,0,0,0,0,0,0 };
        for (size_t c = 0; c < events.programmable.size() && c < ServerUncoreCounterState::maxCounters; ++c)
        {
            events32[c] = (uint32)events.programmable[c].first[0];
            events64[c] = events.programmable[c].first[0];
        }
        if (type == "m3upi")
        {
            for (auto& uncore : serverUncorePMUs)
            {
                uncore->programM3UPI(events32);
            }
        }
        else if (type == "xpi" || type == "upi" || type == "qpi")
        {
            for (auto& uncore : serverUncorePMUs)
            {
                uncore->programXPI(events32);
            }
        }
        else if (type == "imc")
        {
            for (auto& uncore : serverUncorePMUs)
            {
                uncore->programIMC(events32);
            }
        }
        else if (type == "ha")
        {
            for (auto& uncore : serverUncorePMUs)
            {
                uncore->programHA(events32);
            }
        }
        else if (type == "m2m")
        {
            for (auto& uncore : serverUncorePMUs)
            {
                uncore->programM2M(events64);
            }
        }
        else if (type == "pcu")
        {
            uint64 filter = 0;
            if (globalRegPos < events.programmable.size())
            {
                filter = events.programmable[globalRegPos].first[1];
            }
            programPCU(events32, filter);
        }
        else if (type == "ubox")
        {
            programUBOX(events64);
        }
        else if (type == "cbo" || type == "cha")
        {
            uint64 filter0 = 0, filter1 = 0;
            if (globalRegPos < events.programmable.size())
            {
                filter0 = events.programmable[globalRegPos].first[1];
                filter1 = events.programmable[globalRegPos].first[2];
            }
            programCboRaw(events64, filter0, filter1);
        }
        else if (type == "mdf")
        {
            programMDF(events64);
        }
        else if (type == "irp")
        {
            programIRPCounters(events64);
        }
        else if (type == "iio")
        {
            programIIOCounters(events64);
        }
        else if (type == "package_msr")
        {
            packageMSRConfig = pmuConfig.second;
        }
        else if (type == "thread_msr")
        {
            threadMSRConfig = pmuConfig.second;
        }
        else if (type == "pcicfg")
        {
            pcicfgConfig = pmuConfig.second;
            auto addLocations = [this](const std::vector<RawEventConfig>& configs) {
                for (const auto& c : configs)
                {
                    if (PCICFGRegisterLocations.find(c.first) == PCICFGRegisterLocations.end())
                    {
                        // add locations
                        std::vector<PCICFGRegisterEncoding> locations;
                        const auto deviceID = c.first[PCICFGEventPosition::deviceID];
                        forAllIntelDevices([&locations, &deviceID, &c](const uint32 group, const uint32 bus, const uint32 device, const uint32 function, const uint32 device_id)
                            {
                                if (deviceID == device_id && PciHandleType::exists(group, bus, device, function))
                                {
                                    // PciHandleType shared ptr, offset
                                    locations.push_back(PCICFGRegisterEncoding{ std::make_shared<PciHandleType>(group, bus, device, function), (uint32)c.first[PCICFGEventPosition::offset] });
                                }
                            });
                        PCICFGRegisterLocations[c.first] = locations;
                    }
                }
            };
            addLocations(pcicfgConfig.programmable);
            addLocations(pcicfgConfig.fixed);
        }
        else if (type == "tpmi")
        {
            tpmiConfig = pmuConfig.second;
            auto addLocations = [this](const std::vector<RawEventConfig>& configs) {
                for (const auto& c : configs)
                {
                    if (TPMIRegisterLocations.find(c.first) == TPMIRegisterLocations.end())
                    {
                        // add locations
                        std::vector<TPMIRegisterEncoding> locations;
                        const auto tpmiID = c.first[TPMIEventPosition::ID];
                        const uint32 offset = (uint32)c.first[TPMIEventPosition::offset];
                        const auto numInstances = TPMIHandle::getNumInstances();
                        for (auto instance = 0ULL; instance < numInstances; ++instance)
                        {
                            std::shared_ptr<TPMIHandle> tpmiHandle = std::make_shared<TPMIHandle>(instance, tpmiID, offset);
                            locations.push_back(TPMIRegisterEncoding{ tpmiHandle });
                        }
                        TPMIRegisterLocations[c.first] = locations;
                    }
                }
            };
            addLocations(tpmiConfig.programmable);
            addLocations(tpmiConfig.fixed);
        }
        else if (type == "mmio")
        {
            mmioConfig = pmuConfig.second;
            auto addLocations = [this](const std::vector<RawEventConfig>& configs) {
                for (const auto& c : configs)
                {
                    if (MMIORegisterLocations.find(c.first) == MMIORegisterLocations.end())
                    {
                        // add locations
                        std::vector<MMIORegisterEncoding> locations;
                        const auto deviceID = c.first[MMIOEventPosition::deviceID];
                        forAllIntelDevices([&locations, &deviceID, &c](const uint32 group, const uint32 bus, const uint32 device, const uint32 function, const uint32 device_id)
                            {
                                if (deviceID == device_id && PciHandleType::exists(group, bus, device, function))
                                {
                                    PciHandleType pciHandle(group, bus, device, function);
                                    auto computeBarOffset = [&pciHandle](uint64 membarBits) -> size_t
                                    {
                                        if (membarBits)
                                        {
                                            const auto destPos = extract_bits(membarBits, 32, 39);
                                            const auto numBits = extract_bits(membarBits, 24, 31);
                                            const auto srcPos = extract_bits(membarBits, 16, 23);
                                            const auto pcicfgOffset = extract_bits(membarBits, 0, 15);
                                            uint32 memBarOffset = 0;
                                            pciHandle.read32(pcicfgOffset, &memBarOffset);
                                            return size_t(extract_bits_32(memBarOffset, srcPos, srcPos + numBits - 1)) << destPos;
                                        }
                                        return 0;
                                    };

                                    size_t memBar = computeBarOffset(c.first[MMIOEventPosition::membar_bits1])
                                        | computeBarOffset(c.first[MMIOEventPosition::membar_bits2]);

                                    assert(memBar);

                                    const size_t addr = memBar + c.first[MMIOEventPosition::offset];
                                    // MMIORange shared ptr (handle), offset
                                    locations.push_back(MMIORegisterEncoding{ std::make_shared<MMIORange>(addr & ~4095ULL, 4096), (uint32) (addr & 4095ULL) });
                                }
                            });
                        MMIORegisterLocations[c.first] = locations;
                    }
                }
            };
            addLocations(mmioConfig.programmable);
            addLocations(mmioConfig.fixed);
        }
        else if (type == "pmt")
        {
            pmtConfig = pmuConfig.second;
            auto addLocations = [this](const std::vector<RawEventConfig>& configs) {
                for (const auto& c : configs)
                {
                    if (PMTRegisterLocations.find(c.first) == PMTRegisterLocations.end())
                    {
                        // add locations
                        std::vector<PMTRegisterEncoding> locations;
                        const auto UID = c.first[PMTEventPosition::UID];
                        for (size_t inst = 0; inst < TelemetryArray::numInstances(UID); ++inst)
                        {
                            locations.push_back(std::make_shared<TelemetryArray>(UID, inst));
                            DBG(3, "PMTRegisterLocations: UID: 0x" , std::hex , UID , " inst: " , std::dec , inst);
                        }
                        PMTRegisterLocations[c.first] = locations;
                    }
                }
            };
            addLocations(pmtConfig.programmable);
            addLocations(pmtConfig.fixed);
        }
        else if (type == "cxlcm")
        {
            programCXLCM(events64);
        }
        else if (type == "cxldp")
        {
            programCXLDP(events64);
        }
        else if (strToUncorePMUID(type) != INVALID_PMU_ID)
        {
            const auto pmu_id = strToUncorePMUID(type);
            programUncorePMUs(pmu_id, [&events64, &events, &pmu_id](UncorePMU& pmu)
            {
                uint64 * eventsIter = (uint64 *)events64;
                if (pmu_id != PCIE_GEN5x16_PMU_ID && pmu_id != PCIE_GEN5x8_PMU_ID)
                {
                    pmu.initFreeze(UNC_PMON_UNIT_CTL_FRZ_EN);
                }
                PCM::program(pmu, eventsIter, eventsIter + (std::min)(events.programmable.size(), (size_t)ServerUncoreCounterState::maxCounters), UNC_PMON_UNIT_CTL_FRZ_EN);
            });
        }
        else
        {
            std::cerr << "ERROR: unrecognized PMU type \"" << type << "\" when trying to program PMUs.\n";
            return PCM::UnknownError;
        }
    }
    return PCM::Success;
}

void PCM::freezeServerUncoreCounters()
{
    for (int i = 0; (i < (int)serverUncorePMUs.size()) && MSR.size(); ++i)
    {
        serverUncorePMUs[i]->freezeCounters();

        const auto refCore = socketRefCore[i];
        TemporalThreadAffinity tempThreadAffinity(refCore); // speedup trick for Linux

        forAllUncorePMUs(i, PCU_PMU_ID, [](UncorePMU& pmu) { pmu.freeze(UNC_PMON_UNIT_CTL_FRZ_EN); });

        if (IIOEventsAvailable())
        {
            for (auto & pmu : iioPMUs[i])
            {
                pmu.second.freeze(UNC_PMON_UNIT_CTL_RSV);
            }
        }

        if (size_t(i) < irpPMUs.size())
        {
            for (auto& pmu : irpPMUs[i])
            {
                pmu.second.freeze(UNC_PMON_UNIT_CTL_RSV);
            }
        }

        forAllUncorePMUs(i, CBO_PMU_ID, [](UncorePMU& pmu) { pmu.freeze(UNC_PMON_UNIT_CTL_FRZ_EN); });

        forAllUncorePMUs(i, MDF_PMU_ID, [](UncorePMU& pmu) { pmu.freeze(UNC_PMON_UNIT_CTL_FRZ_EN); });

    }
    for (auto& sPMUs : cxlPMUs)
    {
        for (auto& pmus : sPMUs)
        {
            pmus.first.freeze(UNC_PMON_UNIT_CTL_FRZ_EN);
            pmus.second.freeze(UNC_PMON_UNIT_CTL_FRZ_EN);
        }
    }
}
void PCM::unfreezeServerUncoreCounters()
{
    for (int i = 0; (i < (int)serverUncorePMUs.size()) && MSR.size(); ++i)
    {
        serverUncorePMUs[i]->unfreezeCounters();

        const auto refCore = socketRefCore[i];
        TemporalThreadAffinity tempThreadAffinity(refCore); // speedup trick for Linux

        forAllUncorePMUs(i, PCU_PMU_ID, [](UncorePMU& pmu) { pmu.unfreeze(UNC_PMON_UNIT_CTL_FRZ_EN); });

        if (IIOEventsAvailable())
        {
            for (auto & pmu : iioPMUs[i])
            {
                pmu.second.unfreeze(UNC_PMON_UNIT_CTL_RSV);
            }
        }

        if (size_t(i) < irpPMUs.size())
        {
            for (auto& pmu : irpPMUs[i])
            {
                pmu.second.unfreeze(UNC_PMON_UNIT_CTL_RSV);
            }
        }

        forAllUncorePMUs(i, CBO_PMU_ID, [](UncorePMU& pmu) { pmu.unfreeze(UNC_PMON_UNIT_CTL_FRZ_EN); });

        forAllUncorePMUs(i, MDF_PMU_ID, [](UncorePMU& pmu) { pmu.unfreeze(UNC_PMON_UNIT_CTL_FRZ_EN); });

    }
    for (auto& sPMUs : cxlPMUs)
    {
        for (auto& pmus : sPMUs)
        {
            pmus.first.unfreeze(UNC_PMON_UNIT_CTL_FRZ_EN);
            pmus.second.unfreeze(UNC_PMON_UNIT_CTL_FRZ_EN);
        }
    }
}
void UncoreCounterState::readAndAggregate(std::shared_ptr<SafeMsrHandle> msr)
{
    const auto coreID = msr->getCoreId();
    TemporalThreadAffinity tempThreadAffinity(coreID); // speedup trick for Linux

    auto pcm = PCM::getInstance();
    pcm->readAndAggregatePackageCStateResidencies(msr, *this);
}

SystemCounterState PCM::getSystemCounterState()
{
    SystemCounterState result;
    if (MSR.size())
    {
        // read core and uncore counter state
        for (int32 core = 0; core < num_cores; ++core)
            if ( isCoreOnline( core ) )
                result.readAndAggregate(MSR[core]);

        for (uint32 s = 0; s < (uint32)num_sockets; s++)
        {
            if ( isSocketOnline( s ) ) {
                readAndAggregateUncoreMCCounters(s, result);
                readAndAggregateEnergyCounters(s, result);
            }
        }

        readAndAggregateCXLCMCounters(result);
        readQPICounters(result);
        readSystemEnergyStatus(result);

        result.ThermalHeadroom = static_cast<int32>(PCM_INVALID_THERMAL_HEADROOM); // not available for system
    }
    return result;
}

template <class CounterStateType>
void PCM::readAndAggregateMemoryBWCounters(const uint32 core, CounterStateType & result)
{
#ifdef __linux__
    if (useResctrl)
    {
        if (CoreLocalMemoryBWMetricAvailable())
        {
            result.MemoryBWLocal += resctrl.getMBL(core) / (1024*1024);
        }
        if (CoreRemoteMemoryBWMetricAvailable())
        {
            result.MemoryBWTotal += resctrl.getMBT(core) / (1024*1024);
        }
        return;
    }
#endif
     uint64 cMemoryBWLocal = 0;
     uint64 cMemoryBWTotal = 0;

     if(core < memory_bw_local.size())
     {
         cMemoryBWLocal = memory_bw_local[core]->read();
         cMemoryBWLocal = extractQOSMonitoring(cMemoryBWLocal);
         DBG(3,"Read MemoryBWLocal ", cMemoryBWLocal );
         if(cMemoryBWLocal==PCM_INVALID_QOS_MONITORING_DATA)
             result.MemoryBWLocal = PCM_INVALID_QOS_MONITORING_DATA; // do not accumulate invalid reading
         else
             result.MemoryBWLocal += (uint64)((double)(cMemoryBWLocal * L3ScalingFactor) / (1024.0 * 1024.0));
     }
     if(core < memory_bw_total.size())
     {
         cMemoryBWTotal = memory_bw_total[core]->read();
         cMemoryBWTotal = extractQOSMonitoring(cMemoryBWTotal);
         DBG(3, "Read MemoryBWTotal " , cMemoryBWTotal);
         if(cMemoryBWTotal==PCM_INVALID_QOS_MONITORING_DATA)
             result.MemoryBWTotal = PCM_INVALID_QOS_MONITORING_DATA; // do not accumulate invalid reading
         else
             result.MemoryBWTotal  += (uint64)((double)(cMemoryBWTotal * L3ScalingFactor) / (1024.0 * 1024.0));
     }
}


template <class CounterStateType>
void PCM::readAndAggregateCXLCMCounters( CounterStateType & result)
{

    for (size_t socket = 0; socket < getNumSockets(); ++socket)
    {
        uint64 CXLWriteMem = 0;
        uint64 CXLWriteCache = 0;
        for (size_t p = 0; p < getNumCXLPorts(socket); ++p)
        {
            CXLWriteMem += *cxlPMUs[socket][p].first.counterValue[0];
            CXLWriteCache += *cxlPMUs[socket][p].first.counterValue[1];
        }
        result.CXLWriteMem[socket] = CXLWriteMem;
        result.CXLWriteCache[socket] = CXLWriteCache;
    }
}


template <class CounterStateType>
void PCM::readAndAggregateUncoreMCCounters(const uint32 socket, CounterStateType & result)
{
    if (LLCReadMissLatencyMetricsAvailable())
    {
        result.TOROccupancyIAMiss += getUncoreCounterState(CBO_PMU_ID, socket, EventPosition::TOR_OCCUPANCY);
        result.TORInsertsIAMiss += getUncoreCounterState(CBO_PMU_ID, socket, EventPosition::TOR_INSERTS);
    }

    if (LLCReadMissLatencyMetricsAvailable() || uncoreFrequencyMetricAvailable())
    {
        result.UncClocks += getUncoreClocks(socket);
    }

    if (socket < UFSStatus.size())
    {
        result.UFSStatus.clear();
        for (auto & e : UFSStatus[socket])
        {
            auto & handle = e.tpmiHandle;
            const auto pos = e.pos;
            if (handle.get() && pos < handle->getNumEntries())
            {
                const auto value = handle->read64(pos);
                DBG(3, std::hex , value , std::dec);
                result.UFSStatus.push_back(value);
            }
        }
    }

    const bool ReadMCStatsFromServerBW = (socket < serverBW.size());
    if (ReadMCStatsFromServerBW)
    {
        result.UncMCNormalReads += serverBW[socket]->getImcReads();
        result.UncMCFullWrites += serverBW[socket]->getImcWrites();
        if (PMMTrafficMetricsAvailable())
        {
            result.UncPMMReads += serverBW[socket]->getPMMReads();
            result.UncPMMWrites += serverBW[socket]->getPMMWrites();
        }
    }

    if (hasPCICFGUncore())
    {
        if (serverUncorePMUs.size() && serverUncorePMUs[socket].get())
        {
            serverUncorePMUs[socket]->freezeCounters();
	    if (ReadMCStatsFromServerBW == false)
            {
                result.UncMCNormalReads += serverUncorePMUs[socket]->getImcReads();
                result.UncMCFullWrites += serverUncorePMUs[socket]->getImcWrites();
                if(nearMemoryMetricsAvailable()){
                    result.UncNMHit += serverUncorePMUs[socket]->getNMHits();
                    result.UncNMMiss += serverUncorePMUs[socket]->getNMMisses();
                }

            }
            if (localMemoryRequestRatioMetricAvailable())
            {
                if (hasCHA())
                {
                    result.UncHARequests += getUncoreCounterState(CBO_PMU_ID, socket, EventPosition::REQUESTS_ALL);
                    result.UncHALocalRequests += getUncoreCounterState(CBO_PMU_ID, socket, EventPosition::REQUESTS_LOCAL);
                }
                else
                {
                    result.UncHARequests += serverUncorePMUs[socket]->getHARequests();
                    result.UncHALocalRequests += serverUncorePMUs[socket]->getHALocalRequests();
                }
            }
            if (PMMTrafficMetricsAvailable() && (ReadMCStatsFromServerBW == false))
            {
                result.UncPMMReads += serverUncorePMUs[socket]->getPMMReads();
                result.UncPMMWrites += serverUncorePMUs[socket]->getPMMWrites();
            }
            if (HBMmemoryTrafficMetricsAvailable())
            {
                result.UncEDCNormalReads += serverUncorePMUs[socket]->getEdcReads();
                result.UncEDCFullWrites += serverUncorePMUs[socket]->getEdcWrites();
            }
            serverUncorePMUs[socket]->unfreezeCounters();
        }
    }
    else if(clientBW.get() && socket == 0)
    {
        result.UncMCNormalReads += clientImcReads->read();
        result.UncMCFullWrites += clientImcWrites->read();
        result.UncMCGTRequests += clientGtRequests->read();
        result.UncMCIARequests += clientIaRequests->read();
        result.UncMCIORequests += clientIoRequests->read();
    }
    else
    {
        std::shared_ptr<SafeMsrHandle> msr = MSR[socketRefCore[socket]];
        TemporalThreadAffinity tempThreadAffinity(socketRefCore[socket]); // speedup trick for Linux
        switch (cpu_family_model)
        {
            case PCM::WESTMERE_EP:
            case PCM::NEHALEM_EP:
            {
                uint64 cUncMCFullWrites = 0;
                uint64 cUncMCNormalReads = 0;
                msr->read(MSR_UNCORE_PMC0, &cUncMCFullWrites);
                msr->read(MSR_UNCORE_PMC1, &cUncMCNormalReads);
                result.UncMCFullWrites += extractUncoreGenCounterValue(cUncMCFullWrites);
                result.UncMCNormalReads += extractUncoreGenCounterValue(cUncMCNormalReads);
            }
            break;
            case PCM::NEHALEM_EX:
            case PCM::WESTMERE_EX:
            {
                uint64 cUncMCNormalReads = 0;
                msr->read(MB0_MSR_PMU_CNT_0, &cUncMCNormalReads);
                result.UncMCNormalReads += extractUncoreGenCounterValue(cUncMCNormalReads);
                msr->read(MB1_MSR_PMU_CNT_0, &cUncMCNormalReads);
                result.UncMCNormalReads += extractUncoreGenCounterValue(cUncMCNormalReads);

                uint64 cUncMCFullWrites = 0;                         // really good approximation of
                msr->read(BB0_MSR_PERF_CNT_1, &cUncMCFullWrites);
                result.UncMCFullWrites += extractUncoreGenCounterValue(cUncMCFullWrites);
                msr->read(BB1_MSR_PERF_CNT_1, &cUncMCFullWrites);
                result.UncMCFullWrites += extractUncoreGenCounterValue(cUncMCFullWrites);
            }
            break;

            default:;
        }
    }
}

template <class CounterStateType>
void PCM::readAndAggregateEnergyCounters(const uint32 socket, CounterStateType & result)
{
    if(socket < (uint32)energy_status.size())
        result.PackageEnergyStatus += energy_status[socket]->read();

    if (socket < (uint32)dram_energy_status.size())
        result.DRAMEnergyStatus += dram_energy_status[socket]->read();

    if (socket == 0)
    {
        for (size_t pp = 0; pp < pp_energy_status.size(); ++pp)
        {
            result.PPEnergyStatus[pp] += pp_energy_status[pp]->read();
        }
    }
}

template <class CounterStateType>
void PCM::readMSRs(std::shared_ptr<SafeMsrHandle> msr, const PCM::RawPMUConfig& msrConfig, CounterStateType& result)
{
    auto read = [&msr, &result](const RawEventConfig & cfg) {
        const auto index = cfg.first[MSREventPosition::index];
        if (result.MSRValues.find(index) == result.MSRValues.end())
        {
            uint64 val{ 0 };
            msr->read(index, &val);
            result.MSRValues[index] = val;
        }
    };
    for (const auto& cfg : msrConfig.programmable)
    {
        read(cfg);
    }
    for (const auto& cfg : msrConfig.fixed)
    {
        read(cfg);
    }
}

template <class CounterStateType>
void PCM::readAndAggregatePackageCStateResidencies(std::shared_ptr<SafeMsrHandle> msr, CounterStateType & result)
{
    // reading package C state counters
    uint64 cCStateResidency[PCM::MAX_C_STATE + 1];
    std::fill(cCStateResidency, cCStateResidency + PCM::MAX_C_STATE + 1, 0);

    for(int i=0; i <= int(PCM::MAX_C_STATE) ;++i)
        if(pkgCStateMsr && pkgCStateMsr[i])
                msr->read(pkgCStateMsr[i], &(cCStateResidency[i]));

    for (int i = 0; i <= int(PCM::MAX_C_STATE); ++i)
    {
        if (cCStateResidency[i])
        {
            atomic_fetch_add((std::atomic<uint64> *)(result.CStateResidency + i), cCStateResidency[i]);
        }
    }
}

void PCM::readPCICFGRegisters(SystemCounterState& systemState)
{
    auto read = [this, &systemState](const RawEventConfig& cfg) {
        const RawEventEncoding& reEnc = cfg.first;
        systemState.PCICFGValues[reEnc].clear();
        for (auto& reg : PCICFGRegisterLocations[reEnc])
        {
            const auto width = reEnc[PCICFGEventPosition::width];
            auto& h = reg.first;
            const auto& offset = reg.second;
            if (h.get())
            {
                uint64 value = ~0ULL;
                uint32 value32 = 0;
                switch (width)
                {
                case 16:
                    h->read32(offset, &value32);
                    value = (uint64)extract_bits_32(value32, 0, 15);
                    break;
                case 32:
                    h->read32(offset, &value32);
                    value = (uint64)value32;
                    break;
                case 64:
                    h->read64(offset, &value);
                    break;
                default:
                    std::cerr << "ERROR: Unsupported width " << width << " for pcicfg register " << cfg.second << "\n";
                }
                systemState.PCICFGValues[reEnc].push_back(value);
            }
        }
    };
    for (const auto& cfg : pcicfgConfig.programmable)
    {
        read(cfg);
    }
    for (const auto& cfg : pcicfgConfig.fixed)
    {
        read(cfg);
    }
}

void PCM::readTPMIRegisters(SystemCounterState& systemState)
{
    auto read = [this, &systemState](const RawEventConfig& cfg) {
        const RawEventEncoding& reEnc = cfg.first;
        systemState.TPMIValues[reEnc].clear();
        for (auto& h : TPMIRegisterLocations[reEnc])
        {
            if (h.get())
            {
                for (auto e = 0ULL; e < h->getNumEntries(); ++e)
                {
                    systemState.TPMIValues[reEnc].push_back(h->read64(e));
                }
            }
        }
    };
    for (const auto& cfg : tpmiConfig.programmable)
    {
        read(cfg);
    }
    for (const auto& cfg : tpmiConfig.fixed)
    {
        read(cfg);
    }
}

void PCM::readMMIORegisters(SystemCounterState& systemState)
{
    auto read = [this, &systemState](const RawEventConfig& cfg) {
        const RawEventEncoding& reEnc = cfg.first;
        systemState.MMIOValues[reEnc].clear();
        for (auto& reg : MMIORegisterLocations[reEnc])
        {
            const auto width = reEnc[MMIOEventPosition::width];
            auto& h = reg.first;
            const auto& offset = reg.second;
            if (h.get())
            {
                uint64 value = ~0ULL;
                uint32 value32 = 0;
                switch (width)
                {
                case 16:
                    value32 = h->read32(offset);
                    value = (uint64)extract_bits_32(value32, 0, 15);
                    break;
                case 32:
                    value32 = h->read32(offset);
                    value = (uint64)value32;
                    break;
                case 64:
                    value = h->read64(offset);
                    break;
                default:
                    std::cerr << "ERROR: Unsupported width " << width << " for mmio register " << cfg.second << "\n";
                }
                systemState.MMIOValues[reEnc].push_back(value);
            }
        }
    };
    for (const auto& cfg : mmioConfig.programmable)
    {
        read(cfg);
    }
    for (const auto& cfg : mmioConfig.fixed)
    {
        read(cfg);
    }
}

void PCM::readPMTRegisters(SystemCounterState& systemState)
{
    for (auto & p: PMTRegisterLocations)
    {
        for (auto & t: p.second)
        {
            if (t.get())
            {
                t->load();
            }
        }
    }
    auto read = [this, &systemState](const RawEventConfig& cfg) {
        const RawEventEncoding& reEnc = cfg.first;
        systemState.PMTValues[reEnc].clear();
        const auto lsb = reEnc[PMTEventPosition::lsb];
        const auto msb = reEnc[PMTEventPosition::msb];
        const auto offset = reEnc[PMTEventPosition::offset];
        DBG(3, "PMTValues: " , std::hex , reEnc[PMTEventPosition::UID] , std::dec);
        for (auto& reg : PMTRegisterLocations[reEnc])
        {
            if (reg.get())
            {
                systemState.PMTValues[reEnc].push_back(reg->get(offset, lsb, msb));
                DBG(3, "PMTValues: " , std::hex , reEnc[PMTEventPosition::UID] , " " , std::dec , reg->get(offset, lsb, msb));
            }
        }
    };
    for (const auto& cfg : pmtConfig.programmable)
    {
        read(cfg);
    }
    for (const auto& cfg : pmtConfig.fixed)
    {
        read(cfg);
    }
}

void PCM::readQPICounters(SystemCounterState & result)
{
        // read QPI counters
        std::vector<bool> SocketProcessed(num_sockets, false);
        if (cpu_family_model == PCM::NEHALEM_EX || cpu_family_model == PCM::WESTMERE_EX)
        {
            for (int32 core = 0; core < num_cores; ++core)
            {
                if(isCoreOnline(core) == false) continue;

                if(core == socketRefCore[0]) MSR[core]->read(W_MSR_PMON_FIXED_CTR, &(result.uncoreTSC));

                uint32 s = topology[core].socket_id;

                if (!SocketProcessed[s])
                {
                    TemporalThreadAffinity tempThreadAffinity(core); // speedup trick for Linux

                    // incoming data responses from QPI link 0
                    MSR[core]->read(R_MSR_PMON_CTR1, &(result.incomingQPIPackets[s][0]));
                    // incoming data responses from QPI link 1 (yes, from CTR0)
                    MSR[core]->read(R_MSR_PMON_CTR0, &(result.incomingQPIPackets[s][1]));
                    // incoming data responses from QPI link 2
                    MSR[core]->read(R_MSR_PMON_CTR8, &(result.incomingQPIPackets[s][2]));
                    // incoming data responses from QPI link 3
                    MSR[core]->read(R_MSR_PMON_CTR9, &(result.incomingQPIPackets[s][3]));

                    // outgoing idle flits from QPI link 0
                    MSR[core]->read(R_MSR_PMON_CTR3, &(result.outgoingQPIFlits[s][0]));
                    // outgoing idle flits from QPI link 1 (yes, from CTR0)
                    MSR[core]->read(R_MSR_PMON_CTR2, &(result.outgoingQPIFlits[s][1]));
                    // outgoing idle flits from QPI link 2
                    MSR[core]->read(R_MSR_PMON_CTR10, &(result.outgoingQPIFlits[s][2]));
                    // outgoing idle flits from QPI link 3
                    MSR[core]->read(R_MSR_PMON_CTR11, &(result.outgoingQPIFlits[s][3]));

                    SocketProcessed[s] = true;
                }
            }
        }
        else if ((cpu_family_model == PCM::NEHALEM_EP || cpu_family_model == PCM::WESTMERE_EP))
        {
            if (num_sockets == 2)
            {
                uint32 SCore[2] = { (uint32)socketRefCore[0], (uint32)socketRefCore[1] };
                uint64 Total_Reads[2] = { 0, 0 };
                uint64 Total_Writes[2] = { 0, 0 };
                uint64 IOH_Reads[2] = { 0, 0 };
                uint64 IOH_Writes[2] = { 0, 0 };
                uint64 Remote_Reads[2] = { 0, 0 };
                uint64 Remote_Writes[2] = { 0, 0 };
                uint64 Local_Reads[2] = { 0, 0 };
                uint64 Local_Writes[2] = { 0, 0 };

                for (int s = 0; s < 2; ++s)
                {
                    TemporalThreadAffinity tempThreadAffinity(SCore[s]); // speedup trick for Linux

                    MSR[SCore[s]]->read(MSR_UNCORE_PMC0, &Total_Writes[s]);
                    MSR[SCore[s]]->read(MSR_UNCORE_PMC1, &Total_Reads[s]);
                    MSR[SCore[s]]->read(MSR_UNCORE_PMC2, &IOH_Reads[s]);
                    MSR[SCore[s]]->read(MSR_UNCORE_PMC3, &IOH_Writes[s]);
                    MSR[SCore[s]]->read(MSR_UNCORE_PMC4, &Remote_Reads[s]);
                    MSR[SCore[s]]->read(MSR_UNCORE_PMC5, &Remote_Writes[s]);
                    MSR[SCore[s]]->read(MSR_UNCORE_PMC6, &Local_Reads[s]);
                    MSR[SCore[s]]->read(MSR_UNCORE_PMC7, &Local_Writes[s]);
                }

#if 1
                // compute Remote_Reads differently
                for (int s = 0; s < 2; ++s)
                {
                    uint64 total = Total_Writes[s] + Total_Reads[s];
                    uint64 rem = IOH_Reads[s]
                                 + IOH_Writes[s]
                                 + Local_Reads[s]
                                 + Local_Writes[s]
                                 + Remote_Writes[s];
                    Remote_Reads[s] = (total > rem) ? (total - rem) : 0;
                }
#endif


                // only an estimation (lower bound) - does not count NT stores correctly
                result.incomingQPIPackets[0][0] = Remote_Reads[1] + Remote_Writes[0];
                result.incomingQPIPackets[0][1] = IOH_Reads[0];
                result.incomingQPIPackets[1][0] = Remote_Reads[0] + Remote_Writes[1];
                result.incomingQPIPackets[1][1] = IOH_Reads[1];
            }
            else
            {
                // for a single socket systems no information is available
                result.incomingQPIPackets[0][0] = 0;
            }
        }
        else if (hasPCICFGUncore())
        {
                for (int32 s = 0; (s < (int32)serverUncorePMUs.size()); ++s)
                {
                    serverUncorePMUs[s]->freezeCounters();
                    for (uint32 port = 0; port < (uint32)getQPILinksPerSocket(); ++port)
                    {
                        result.incomingQPIPackets[s][port] = uint64(double(serverUncorePMUs[s]->getIncomingDataFlits(port)) / (64./getDataBytesPerFlit()));
                        result.outgoingQPIFlits[s][port] = serverUncorePMUs[s]->getOutgoingFlits(port);
                        result.TxL0Cycles[s][port] = serverUncorePMUs[s]->getUPIL0TxCycles(port);
                    }
                    serverUncorePMUs[s]->unfreezeCounters();
                }
        }
        // end of reading QPI counters
}

template <class CounterStateType>
void PCM::readPackageThermalHeadroom(const uint32 socket, CounterStateType & result)
{
    if(packageThermalMetricsAvailable())
    {
        uint64 val = 0;
        MSR[socketRefCore[socket]]->read(MSR_PACKAGE_THERM_STATUS,&val);
        result.MSRValues[MSR_PACKAGE_THERM_STATUS] = val;
        result.ThermalHeadroom = extractThermalHeadroom(val);
    }
    else
        result.ThermalHeadroom = PCM_INVALID_THERMAL_HEADROOM; // not available
}

// Explicit instantiation needed in topology.cpp
template void PCM::readAndAggregatePackageCStateResidencies(std::shared_ptr<SafeMsrHandle>, UncoreCounterState &);
template void PCM::readAndAggregateUncoreMCCounters<UncoreCounterState>(const uint32, UncoreCounterState&);
template void PCM::readAndAggregateEnergyCounters<UncoreCounterState>(const uint32, UncoreCounterState&);
template void PCM::readPackageThermalHeadroom<SocketCounterState>(const uint32, SocketCounterState &);
template void PCM::readAndAggregateCXLCMCounters<SystemCounterState>(SystemCounterState &);

SocketCounterState PCM::getSocketCounterState(uint32 socket)
{
    SocketCounterState result;
    if (MSR.size())
    {
        // reading core and uncore counter states
        for (int32 core = 0; core < num_cores; ++core)
            if (isCoreOnline(core) && (topology[core].socket_id == int32(socket)))
                result.readAndAggregate(MSR[core]);

        readAndAggregateUncoreMCCounters(socket, result);

        readAndAggregateEnergyCounters(socket, result);

        readPackageThermalHeadroom(socket, result);

    }
    return result;
}

void PCM::getAllCounterStates(SystemCounterState & systemState, std::vector<SocketCounterState> & socketStates, std::vector<CoreCounterState> & coreStates, const bool readAndAggregateSocketUncoreCounters)
{
    // clear and zero-initialize all inputs
    systemState = SystemCounterState();
    socketStates.clear();
    socketStates.resize(num_sockets);
    coreStates.clear();
    coreStates.resize(num_cores);

    std::vector<std::future<void> > asyncCoreResults;

    for (int32 core = 0; core < num_cores; ++core)
    {
        // read core counters
        if (isCoreOnline(core))
        {
            std::packaged_task<void()> task([this,&coreStates,&socketStates,core,readAndAggregateSocketUncoreCounters]() -> void
                {
                    coreStates[core].readAndAggregate(MSR[core]);
                    if (readAndAggregateSocketUncoreCounters)
                    {
                        socketStates[topology[core].socket_id].UncoreCounterState::readAndAggregate(MSR[core]); // read package C state counters
                    }
                    readMSRs(MSR[core], threadMSRConfig, coreStates[core]);
                }
            );
            asyncCoreResults.push_back(task.get_future());
            coreTaskQueues[core]->push(task);
        }
        DBG(3, core , " " , coreStates[core].InstRetiredAny.getRawData_NoOverflowProtection() );
    }
    for (uint32 s = 0; s < (uint32)num_sockets && readAndAggregateSocketUncoreCounters; ++s)
    {
        int32 refCore = socketRefCore[s];
        if (refCore<0) refCore = 0;
        std::packaged_task<void()> task([this, s, &socketStates, refCore]() -> void
            {
                readAndAggregateUncoreMCCounters(s, socketStates[s]);
                readAndAggregateEnergyCounters(s, socketStates[s]);
                readPackageThermalHeadroom(s, socketStates[s]);
                readMSRs(MSR[refCore], packageMSRConfig, socketStates[s]);
            } );
        asyncCoreResults.push_back(task.get_future());
        coreTaskQueues[refCore]->push(task);
    }

    if (readAndAggregateSocketUncoreCounters)
    {
        readQPICounters(systemState);
        readPCICFGRegisters(systemState);
        readMMIORegisters(systemState);
        readPMTRegisters(systemState);
        readTPMIRegisters(systemState);
    }

    for (auto & ar : asyncCoreResults)
        ar.wait();

    for (int32 core = 0; core < num_cores; ++core)
    {   // aggregate core counters into sockets
        if(isCoreOnline(core))
          socketStates[topology[core].socket_id] += coreStates[core];
    }

    for (int32 s = 0; s < num_sockets; ++s)
    {   // aggregate core counters from sockets into system state and
        // aggregate socket uncore iMC, energy and package C state counters into system
        systemState += socketStates[s];
    }

    readSystemEnergyStatus(systemState);
}

void PCM::readSystemEnergyStatus(SystemCounterState & systemState)
{
    if (systemEnergyMetricAvailable() && system_energy_status.get() != nullptr)
    {
        systemState.systemEnergyStatus = system_energy_status->read();
    }
}

void PCM::getUncoreCounterStates(SystemCounterState & systemState, std::vector<SocketCounterState> & socketStates)
{
    // clear and zero-initialize all inputs
    systemState = SystemCounterState();
    socketStates.clear();
    socketStates.resize(num_sockets);
    std::vector<CoreCounterState> refCoreStates(num_sockets);

    for (uint32 s = 0; s < (uint32)num_sockets; ++s)
    {
        const int32 refCore = socketRefCore[s];
        if(isCoreOnline(refCore))
        {
            refCoreStates[s].readAndAggregateTSC(MSR[refCore]);
        }
        readAndAggregateUncoreMCCounters(s, socketStates[s]);
        readAndAggregateEnergyCounters(s, socketStates[s]);
        readPackageThermalHeadroom(s, socketStates[s]);
    }

    readQPICounters(systemState);
    readSystemEnergyStatus(systemState);

    for (int32 s = 0; s < num_sockets; ++s)
    {
        const int32 refCore = socketRefCore[s];
        if(isCoreOnline(refCore))
        {
            for(uint32 core=0; core < getNumCores(); ++core)
            {
                if(topology[core].socket_id == s && isCoreOnline(core))
                    socketStates[s] += refCoreStates[s];
            }
        }
        // aggregate socket uncore iMC, energy counters into system
        systemState += socketStates[s];
    }
}

CoreCounterState PCM::getCoreCounterState(uint32 core)
{
    CoreCounterState result;
    if (MSR.size()) result.readAndAggregate(MSR[core]);
    return result;
}

uint32 PCM::getNumCores() const
{
    return (uint32)num_cores;
}

uint32 PCM::getNumOnlineCores() const
{
    return (uint32)num_online_cores;
}

uint32 PCM::getNumSockets() const
{
    return (uint32)num_sockets;
}

int32 PCM::mapNUMANodeToSocket(uint32 numa_node_id) const
{
    // Check cache (thread-safe read)
    {
        pcm::Mutex::Scope lock(numaNodeToSocketCacheMutex);
        auto it = numaNodeToSocketCache.find(numa_node_id);
        if (it != numaNodeToSocketCache.end())
        {
            return it->second;
        }
    }
    
    // Cache miss, compute the result
    int32 socket_id = -1;
    
    // Helper lambda to cache the result before returning
    auto cacheAndReturn = [&](int32 result) -> int32 {
        pcm::Mutex::Scope lock(numaNodeToSocketCacheMutex);
        numaNodeToSocketCache[numa_node_id] = result;
        return result;
    };
    
#ifdef __linux__
    // On Linux, read the CPU list for this NUMA node and map to socket
    std::ostringstream path;
    path << "/sys/devices/system/node/node" << numa_node_id << "/cpulist";
    
    std::ifstream cpulist_file(path.str());
    if (!cpulist_file.is_open())
    {
        // Try alternative path with /pcm prefix (for containerized environments)
        cpulist_file.open("/pcm" + path.str());
        if (!cpulist_file.is_open())
        {
            DBG(2, "Cannot open NUMA node cpulist file: ", path.str());
            return cacheAndReturn(-1);
        }
    }
    
    std::string cpulist;
    std::getline(cpulist_file, cpulist);
    
    if (cpulist.empty())
    {
        DBG(2, "Empty CPU list for NUMA node ", numa_node_id);
        return cacheAndReturn(-1);
    }
    
    // Parse the first CPU from the list (format: "0-15,32-47" or "0" or "0,2,4")
    size_t first_cpu_end = cpulist.find_first_of(",-");
    std::string first_cpu_str = (first_cpu_end == std::string::npos) ? cpulist : cpulist.substr(0, first_cpu_end);
    
    try
    {
        uint32 first_cpu = std::stoul(first_cpu_str);
        if (first_cpu < topology.size())
        {
            socket_id = topology[first_cpu].socket_id;
            DBG(3, "NUMA node ", numa_node_id, " maps to socket ", socket_id);
            return cacheAndReturn(socket_id);
        }
    }
    catch (const std::exception& e)
    {
        DBG(2, "Failed to parse CPU ID from cpulist: ", cpulist, " error: ", e.what());
        return cacheAndReturn(-1);
    }
    
    return cacheAndReturn(-1);
#elif defined(_MSC_VER)
    // On Windows, use GetLogicalProcessorInformationEx to map NUMA node to processors
    // and then map processor to socket using topology information
    DWORD length = 0;
    GetLogicalProcessorInformationEx(RelationNumaNode, nullptr, &length);
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        return cacheAndReturn(-1);
    }
    
    std::vector<uint8_t> buffer(length);
    auto info = reinterpret_cast<PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(buffer.data());
    
    if (!GetLogicalProcessorInformationEx(RelationNumaNode, info, &length))
    {
        return cacheAndReturn(-1);
    }
    
    // Iterate through NUMA nodes
    DWORD offset = 0;
    while (offset < length)
    {
        auto current = reinterpret_cast<PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(
            reinterpret_cast<uint8_t*>(info) + offset);
        
        if (current->Relationship == RelationNumaNode && 
            current->NumaNode.NodeNumber == numa_node_id)
        {
            // The GROUP_AFFINITY structure contains a processor group number and affinity mask
            WORD groupNumber = current->NumaNode.GroupMask.Group;
            KAFFINITY mask = current->NumaNode.GroupMask.Mask;
            
            if (mask != 0)
            {
                auto BitScanForward64 = [](unsigned long* Index, uint64_t Mask)
                {
                    if (Mask == 0) return 0;

                    // Magic numbers for LSB (chess engine style)
                    static const uint64_t magic = 0x03f79d71b4cb0a89ULL;
                    uint64_t isolated = Mask & -Mask;  // Rightmost set bit
                    *Index = (unsigned long)(((isolated * magic) >> 58));
                };

                // Find first set bit (first processor in this NUMA node within this group)
                DWORD bitPosition = 0;
                BitScanForward64(&bitPosition, mask);
                
                // On Windows, we need to find the logical processor ID that corresponds to
                // this bit position in this group. We iterate through topology to find a match.
                // Note: This is a simplified approach. A more robust implementation would need
                // to query the system for the mapping between group/bit position and logical processor IDs.
                for (size_t cpu = 0; cpu < topology.size(); ++cpu)
                {
                    // Check if this CPU belongs to the current NUMA node
                    // Since we don't have direct group information in topology, we use a heuristic:
                    // try the first CPU we find in the topology array
                    // A better approach would store group information in TopologyEntry
                    if (cpu == bitPosition + (groupNumber * 64))  // Rough approximation
                    {
                        socket_id = topology[cpu].socket_id;
                        return cacheAndReturn(socket_id);
                    }
                }
                
                // Fallback: just return the socket_id of the first available CPU if within bounds
                if (bitPosition < topology.size())
                {
                    socket_id = topology[bitPosition].socket_id;
                    return cacheAndReturn(socket_id);
                }
            }
        }
        
        offset += current->Size;
    }
    
    return cacheAndReturn(-1);
#elif defined(__FreeBSD__) || defined(__DragonFly__)
    // FreeBSD implementation using vm.ndomains and cpuset APIs
    
    // First check if NUMA is enabled on this system
    int ndomains = 0;
    size_t len = sizeof(ndomains);
    
    if (sysctlbyname("vm.ndomains", &ndomains, &len, nullptr, 0) != 0)
    {
        DBG(2, "Cannot query vm.ndomains, NUMA not available");
        return cacheAndReturn(-1);
    }
    
    if (ndomains <= 1)
    {
        // NUMA not enabled or single domain system
        DBG(3, "NUMA not enabled on FreeBSD (vm.ndomains = ", ndomains, ")");
        return cacheAndReturn(-1);
    }
    
    // Validate NUMA node ID
    if (numa_node_id >= (uint32)ndomains)
    {
        DBG(2, "Invalid NUMA node ID ", numa_node_id, " (max: ", ndomains - 1, ")");
        return cacheAndReturn(-1);
    }
    
#if defined(__FreeBSD__) && defined(CPU_WHICH_DOMAIN)
    // On FreeBSD with CPU_WHICH_DOMAIN support (FreeBSD 12.0+)
    // Query which CPUs belong to this NUMA domain
    cpuset_t cpuset;
    CPU_ZERO(&cpuset);
    
    // cpuset_getaffinity with CPU_WHICH_DOMAIN returns the cpuset for a specific NUMA domain
    if (cpuset_getaffinity(CPU_LEVEL_WHICH, CPU_WHICH_DOMAIN, numa_node_id, 
                           sizeof(cpuset), &cpuset) == 0)
    {
        // Find the first CPU in this domain's cpuset
        for (size_t cpu = 0; cpu < topology.size(); ++cpu)
        {
            if (CPU_ISSET(cpu, &cpuset))
            {
                socket_id = topology[cpu].socket_id;
                DBG(3, "NUMA domain ", numa_node_id, " maps to socket ", socket_id);
                return cacheAndReturn(socket_id);
            }
        }
    }
    else
    {
        DBG(2, "cpuset_getaffinity failed for domain ", numa_node_id);
    }
#endif

    return cacheAndReturn(-1);
#elif defined(__APPLE__)
    // On macOS, NUMA information is not readily available
    // For now, return -1 to indicate the mapping is not available
    (void)numa_node_id; // Suppress unused parameter warning
    return cacheAndReturn(-1);
#else
    // Unsupported platform
    (void)numa_node_id; // Suppress unused parameter warning
    return cacheAndReturn(-1);
#endif
}

uint32 PCM::getAccel() const
{
    return accel;
}

void PCM::setAccel(uint32 input)
{
    accel = input;
}

uint32 PCM::getNumberofAccelCounters() const
{
    return accel_counters_num_max;
}

void PCM::setNumberofAccelCounters(uint32 input)
{
    accel_counters_num_max = input;
}

uint32 PCM::getNumOnlineSockets() const
{
    return (uint32)num_online_sockets;
}


uint32 PCM::getThreadsPerCore() const
{
    return (uint32)threads_per_core;
}

bool PCM::getSMT() const
{
    return threads_per_core > 1;
}

uint64 PCM::getNominalFrequency() const
{
    return nominal_frequency;
}

uint32 PCM::getL3ScalingFactor() const
{
    PCM_CPUID_INFO cpuinfo;
    pcm_cpuid(0xf,0x1,cpuinfo);

    return (uint32)cpuinfo.reg.ebx;

}

bool PCM::isSomeCoreOfflined()
{
    PCM_CPUID_INFO cpuid_args;
    pcm_cpuid(0xB,1,cpuid_args);
    uint32 max_num_lcores_per_socket = cpuid_args.reg.ebx & 0xFFFF;
    uint32 max_num_lcores = max_num_lcores_per_socket * getNumSockets();
    if(threads_per_core == 1 && (getNumOnlineCores() * 2 == max_num_lcores)) // HT is disabled in the BIOS
    {
       return false;
    }
    return !(getNumOnlineCores() == max_num_lcores);
}

ServerUncoreCounterState PCM::getServerUncoreCounterState(uint32 socket)
{
    ServerUncoreCounterState result;
    if (socket < serverBW.size() && serverBW[socket].get())
    {
        result.freeRunningCounter[ServerUncoreCounterState::ImcReads] = serverBW[socket]->getImcReads();
        result.freeRunningCounter[ServerUncoreCounterState::ImcWrites] = serverBW[socket]->getImcWrites();
        result.freeRunningCounter[ServerUncoreCounterState::PMMReads] = serverBW[socket]->getPMMReads();
        result.freeRunningCounter[ServerUncoreCounterState::PMMWrites] = serverBW[socket]->getPMMWrites();
    }
    if(serverUncorePMUs.size() && serverUncorePMUs[socket].get())
    {
        serverUncorePMUs[socket]->freezeCounters();
        for(uint32 port=0;port < (uint32)serverUncorePMUs[socket]->getNumQPIPorts();++port)
        {
            assert(port < result.xPICounter.size());
            for (uint32 cnt = 0; cnt < ServerUncoreCounterState::maxCounters; ++cnt)
                result.xPICounter[port][cnt] = serverUncorePMUs[socket]->getQPILLCounter(port, cnt);
            assert(port < result.M3UPICounter.size());
            for (uint32 cnt = 0; cnt < ServerUncoreCounterState::maxCounters; ++cnt)
                result.M3UPICounter[port][cnt] = serverUncorePMUs[socket]->getM3UPICounter(port, cnt);
        }
        for (uint32 channel = 0; channel < (uint32)serverUncorePMUs[socket]->getNumMCChannels(); ++channel)
        {
            assert(channel < result.DRAMClocks.size());
            result.DRAMClocks[channel] = serverUncorePMUs[socket]->getDRAMClocks(channel);
            assert(channel < result.MCCounter.size());
            for (uint32 cnt = 0; cnt < ServerUncoreCounterState::maxCounters; ++cnt)
                result.MCCounter[channel][cnt] = serverUncorePMUs[socket]->getMCCounter(channel, cnt);
        }
        for (uint32 channel = 0; channel < (uint32)serverUncorePMUs[socket]->getNumEDCChannels(); ++channel)
        {
            assert(channel < result.HBMClocks.size());
            result.HBMClocks[channel] = serverUncorePMUs[socket]->getHBMClocks(channel);
            assert(channel < result.EDCCounter.size());
            for (uint32 cnt = 0; cnt < ServerUncoreCounterState::maxCounters; ++cnt)
                result.EDCCounter[channel][cnt] = serverUncorePMUs[socket]->getEDCCounter(channel, cnt);
        }
    for (uint32 controller = 0; controller < (uint32)serverUncorePMUs[socket]->getNumMC(); ++controller)
    {
      assert(controller < result.M2MCounter.size());
      for (uint32 cnt = 0; cnt < ServerUncoreCounterState::maxCounters; ++cnt)
          result.M2MCounter[controller][cnt] = serverUncorePMUs[socket]->getM2MCounter(controller, cnt);
      assert(controller < result.HACounter.size());
      for (uint32 cnt = 0; cnt < ServerUncoreCounterState::maxCounters; ++cnt)
          result.HACounter[controller][cnt] = serverUncorePMUs[socket]->getHACounter(controller, cnt);
    }
        serverUncorePMUs[socket]->unfreezeCounters();
    }
    if (MSR.size())
    {
        uint32 refCore = socketRefCore[socket];
        TemporalThreadAffinity tempThreadAffinity(refCore);

        readUncoreCounterValues(result, socket);

        for (uint32 stack = 0; socket < iioPMUs.size() && stack < iioPMUs[socket].size() && stack < ServerUncoreCounterState::maxIIOStacks; ++stack)
        {
            for (int i = 0; i < ServerUncoreCounterState::maxCounters && size_t(i) < iioPMUs[socket][stack].size(); ++i)
            {
                result.IIOCounter[stack][i] = *(iioPMUs[socket][stack].counterValue[i]);
            }
        }
        for (uint32 stack = 0; socket < irpPMUs.size() && stack < irpPMUs[socket].size() && stack < ServerUncoreCounterState::maxIIOStacks; ++stack)
        {
            for (int i = 0; i < ServerUncoreCounterState::maxCounters && size_t(i) < irpPMUs[socket][stack].size(); ++i)
            {
                if (irpPMUs[socket][stack].counterValue[i].get())
                {
                    result.IRPCounter[stack][i] = *(irpPMUs[socket][stack].counterValue[i]);
                }
            }
        }

        result.UncClocks = getUncoreClocks(socket);

        const auto numCXLPorts = getNumCXLPorts(socket);

        assert(numCXLPorts <= result.CXLCMCounter.size() && "Number of CXL ports exceeds CXLCMCounter array size");
        assert(numCXLPorts <= result.CXLDPCounter.size() && "Number of CXL ports exceeds CXLDPCounter array size");

        const auto maxPorts = (std::min)(numCXLPorts, (std::min)(result.CXLCMCounter.size(), result.CXLDPCounter.size()));

        for (size_t p = 0; p < maxPorts; ++p)
        {
            for (int i = 0; i < ServerUncoreCounterState::maxCounters && socket < cxlPMUs.size() && size_t(i) < cxlPMUs[socket][p].first.size(); ++i)
            {
                result.CXLCMCounter[p][i] = *cxlPMUs[socket][p].first.counterValue[i];
            }
            for (int i = 0; i < ServerUncoreCounterState::maxCounters && socket < cxlPMUs.size() && size_t(i) < cxlPMUs[socket][p].second.size(); ++i)
            {
                result.CXLDPCounter[p][i] = *cxlPMUs[socket][p].second.counterValue[i];
            }
        }
        uint64 val=0;
        //MSR[refCore]->read(MSR_PKG_ENERGY_STATUS,&val);
        //DBG(3, "Energy status: " , val );
        MSR[refCore]->read(MSR_PACKAGE_THERM_STATUS,&val);
        result.PackageThermalHeadroom = extractThermalHeadroom(val);
        result.InvariantTSC = getInvariantTSC_Fast(refCore);
        readAndAggregatePackageCStateResidencies(MSR[refCore], result);
    }
    readAndAggregateEnergyCounters(socket, result);

    return result;
}

#ifndef _MSC_VER
void print_mcfg(const char * path)
{
    int mcfg_handle = ::open(path, O_RDONLY);

    if (mcfg_handle < 0)
    {
        std::cerr << "PCM Error: Cannot open " << path << "\n";
        throw std::exception();
    }

    MCFGHeader header;

    ssize_t read_bytes = ::read(mcfg_handle, (void *)&header, sizeof(MCFGHeader));

    if(read_bytes == 0)
    {
        std::cerr << "PCM Error: Cannot read " << path << "\n";
        ::close(mcfg_handle);
        throw std::exception();
    }

    const unsigned segments = header.nrecords();
    header.print();
    std::cout << "Segments: " << segments << "\n";

    for(unsigned int i=0; i<segments;++i)
    {
        MCFGRecord record;
        read_bytes = ::read(mcfg_handle, (void *)&record, sizeof(MCFGRecord));
        if(read_bytes == 0)
        {
              std::cerr << "PCM Error: Cannot read " << path << " (2)\n";
              ::close(mcfg_handle);
              throw std::exception();
        }
        std::cout << "Segment " << std::dec << i << " ";
        record.print();
    }

    ::close(mcfg_handle);
}
#endif


static const uint32 IMC_DEV_IDS[] = {
    0x03cb0,
    0x03cb1,
    0x03cb4,
    0x03cb5,
    0x0EB4,
    0x0EB5,
    0x0EB0,
    0x0EB1,
    0x0EF4,
    0x0EF5,
    0x0EF0,
    0x0EF1,
    0x2fb0,
    0x2fb1,
    0x2fb4,
    0x2fb5,
    0x2fd0,
    0x2fd1,
    0x2fd4,
    0x2fd5,
    0x6fb0,
    0x6fb1,
    0x6fb4,
    0x6fb5,
    0x6fd0,
    0x6fd1,
    0x6fd4,
    0x6fd5,
    0x2042,
    0x2046,
    0x204a,
    0x7840,
    0x7841,
    0x7842,
    0x7843,
    0x7844,
    0x781f
};

static const uint32 UPI_DEV_IDS[] = {
    0x2058,
    0x3441,
    0x3241,
};

static const uint32 M2M_DEV_IDS[] = {
    0x2066,
    0x344A,
    0x324A
};

Mutex socket2busMutex;
std::vector<std::pair<uint32,uint32> > ServerUncorePMUs::socket2iMCbus{};
std::vector<std::pair<uint32,uint32> > ServerUncorePMUs::socket2UPIbus{};
std::vector<std::pair<uint32,uint32> > ServerUncorePMUs::socket2M2Mbus{};

void initSocket2Bus(std::vector<std::pair<uint32, uint32> > & socket2bus, uint32 device, uint32 function, const uint32 DEV_IDS[], uint32 devIdsSize)
{
    if (device == PCM_INVALID_DEV_ADDR || function == PCM_INVALID_FUNC_ADDR)
    {
        return;
    }
    Mutex::Scope _(socket2busMutex);
    if(!socket2bus.empty()) return;

    try {
    forAllIntelDevices(
        [&devIdsSize,&DEV_IDS, &socket2bus](const uint32 group, const uint32 bus, const uint32 /* device */, const uint32 /* function */, const uint32 device_id)
        {
            for (uint32 i = 0; i < devIdsSize; ++i)
            {
                // match
                if (DEV_IDS[i] == device_id)
                {
                    DBG(2, std::hex, "found group ", group, " bus ", bus, " with device ID ", device_id, std::dec);
                    socket2bus.push_back(std::make_pair(group, bus));
                    break;
                }
            }
        }, device, function);
    } catch (const std::exception & e)
    {
           std::cerr << "Error in initSocket2Bus: " << e.what() << "\n";
           socket2bus.clear();
    }
}

int getBusFromSocket(const uint32 socket)
{
    int cur_bus = 0;
    uint32 cur_socket = 0;
    DBG(2, "socket: " , socket);
    while(cur_socket <= socket)
    {
        DBG(2, "reading from bus 0x", std::hex, cur_bus, std::dec);
        PciHandleType h(0, cur_bus, 5, 0);
        uint32 cpubusno = 0;
        h.read32(0x108, &cpubusno); // CPUBUSNO register
        cur_bus = (cpubusno >> 8)& 0x0ff;
        DBG(2, "socket: ", cur_socket,  std::hex, " cpubusno: 0x", std::hex, cpubusno, " ", cur_bus, std::dec);
        if(socket == cur_socket)
            return cur_bus;
        ++cur_socket;
        ++cur_bus;
        if(cur_bus > 0x0ff)
           return -1;
    }
    return -1;
}

PciHandleType * ServerUncorePMUs::createIntelPerfMonDevice(uint32 groupnr_, int32 bus_, uint32 dev_, uint32 func_, bool checkVendor)
{
    if (PciHandleType::exists(groupnr_, (uint32)bus_, dev_, func_))
    {
        PciHandleType * handle = new PciHandleType(groupnr_, bus_, dev_, func_);

        if(!checkVendor) return handle;

        uint32 vendor_id = 0;
        handle->read32(PCM_PCI_VENDOR_ID_OFFSET,&vendor_id);
        vendor_id &= 0x0ffff;

        if(vendor_id == PCM_INTEL_PCI_VENDOR_ID) return handle;

        deleteAndNullify(handle);
    }
    return NULL;
}

bool PCM::isSecureBoot() const
{
    static int flag = -1;
    if (MSR.size() > 0 && flag == -1)
    {
        DBG(1, "checking MSR in isSecureBoot");
        uint64 val = 0;
        if (MSR[0]->read(IA32_PERFEVTSEL0_ADDR, &val) != sizeof(val))
        {
            flag = 0; // some problem with MSR read, not secure boot
        }
        // read works
        if (MSR[0]->write(IA32_PERFEVTSEL0_ADDR, val) != sizeof(val)/* && errno == 1 */) // errno works only on windows
        { // write does not work -> secure boot
            flag = 1;
        }
        else
        {
            flag = 0; // can write MSR -> no secure boot
        }
    }
    return flag == 1;
}

bool PCM::useLinuxPerfForUncore() const
{
    static int use = -1;
    if (use != -1)
    {
        return 1 == use;
    }
    use = 0;
    bool secureBoot = isSecureBoot();
#ifdef PCM_USE_PERF
    const auto imcIDs = enumeratePerfPMUs("imc", 100);
    if (!quietMode) std::cerr << "INFO: Linux perf interface to program uncore PMUs is " << (imcIDs.empty()?"NOT ":"") << "present\n";
    if (imcIDs.empty())
    {
        use = 0;
        return 1 == use;
    }
    const char * perf_env = std::getenv("PCM_USE_UNCORE_PERF");
    if (perf_env != NULL && std::string(perf_env) == std::string("1"))
    {
        if (!quietMode) std::cerr << "INFO: using Linux perf interface to program uncore PMUs because env variable PCM_USE_UNCORE_PERF=1\n";
        use = 1;
    }
    if (secureBoot)
    {
        if (!quietMode) std::cerr << "INFO: Secure Boot detected. Using Linux perf for uncore PMU programming.\n";
        use = 1;
    }
#else
    if (1)
    {
        if (secureBoot)
        {
            std::cerr << "ERROR: Secure Boot detected. Recompile PCM with -DPCM_USE_PERF or disable Secure Boot.\n";
        }
    }
#endif
    return 1 == use;
}

template <class F>
void PCM::getPCICFGPMUsFromDiscovery(const unsigned int BoxType, const size_t s, F f) const
{
    if (uncorePMUDiscovery.get())
    {
        for (size_t die = 0; die < uncorePMUDiscovery->getNumDies(s); ++die)
        {
            const auto numBoxes = uncorePMUDiscovery->getNumBoxes(BoxType, s, die);
            for (size_t pos = 0; pos < numBoxes; ++pos)
            {
                if (uncorePMUDiscovery->getBoxAccessType(BoxType, s, die, pos) == UncorePMUDiscovery::accessTypeEnum::PCICFG)
                {
                    std::vector<std::shared_ptr<HWRegister> > CounterControlRegs, CounterValueRegs;
                    const auto n_regs = uncorePMUDiscovery->getBoxNumRegs(BoxType, s, die, pos);
                    auto makeRegister = [&pos, &numBoxes, &BoxType, &s](const uint64 rawAddr)
                    {
    #ifndef PCI_ENABLE
                        constexpr auto PCI_ENABLE = 0x80000000ULL;
    #endif
                        UncorePMUDiscovery::PCICFGAddress Addr;
                        Addr.raw = rawAddr;
                        if ((Addr.raw & PCI_ENABLE) == 0)
                        {
                            std::cerr << "PCM Error: PCI_ENABLE bit not set in address 0x" << std::hex << Addr.raw << std::dec << "\n";
                            std::cerr << "This is likely a bug in the uncore PMU discovery BIOS table. Contact your BIOS vendor.\n";
                            std::cerr << "Socket: " << s << "\n";
                            std::cerr << "Box type: " << BoxType << "\n";
                            std::cerr << "Box position: " << pos << "/" << numBoxes << "\n";
                            std::cerr << "Address: " << Addr.getStr() << "\n";
                            return std::shared_ptr<PCICFGRegister64>();
                        }
                        try {
                            auto handle = std::make_shared<PciHandleType>(0, (uint32)Addr.fields.bus,
                                                                            (uint32)Addr.fields.device,
                                                                            (uint32)Addr.fields.function);
                            assert(handle.get());
                            DBG(3, "opened bdf ", Addr.getStr());
                            return std::make_shared<PCICFGRegister64>(handle, (size_t)Addr.fields.offset);
                        }
                        catch (...)
                        {
                            DBG(3,  "error opening bdf ", Addr.getStr());
                        }
                        return std::shared_ptr<PCICFGRegister64>();
                    };
                    auto boxCtlRegister = makeRegister(uncorePMUDiscovery->getBoxCtlAddr(BoxType, s, die, pos));
                    if (boxCtlRegister.get())
                    {
                        for (size_t r = 0; r < n_regs; ++r)
                        {
                            CounterControlRegs.push_back(makeRegister(uncorePMUDiscovery->getBoxCtlAddr(BoxType, s, die, pos, r)));
                            CounterValueRegs.push_back(makeRegister(uncorePMUDiscovery->getBoxCtrAddr(BoxType, s, die, pos, r)));
                        }
                        f(UncorePMU(boxCtlRegister, CounterControlRegs, CounterValueRegs));
                    }
                }
            }
        }
    }
};

ServerUncorePMUs::ServerUncorePMUs(uint32 socket_, const PCM * pcm) :
     iMCbus(-1)
   , UPIbus(-1)
   , M2Mbus(-1)
   , groupnr(0)
   , cpu_family_model(pcm->getCPUFamilyModel())
   , qpi_speed(0)
{
    if (pcm->useLinuxPerfForUncore())
    {
        initPerf(socket_, pcm);
    }
    else
    {
        initRegisterLocations(pcm);
        initBuses(socket_, pcm);
        initDirect(socket_, pcm);
    }

    if (!PCM::getQuietMode()) std::cerr << "Socket " << socket_ << ": " <<
        getNumMC() << " memory controllers detected with total number of " << getNumMCChannels() << " channels. " <<
        getNumQPIPorts() << " " << pcm->xPI() << " ports detected." <<
        " " << m2mPMUs.size() << " M2M (mesh to memory)/B2CMI blocks detected."
        " " << hbm_m2mPMUs.size() << " HBM M2M blocks detected."
        " " << edcPMUs.size() << " EDC/HBM channels detected."
        " " << haPMUs.size()  << " Home Agents detected."
        " " << m3upiPMUs.size() << " M3UPI/B2UPI blocks detected."
        "\n";
}

void ServerUncorePMUs::initRegisterLocations(const PCM * pcm)
{
#define PCM_PCICFG_MC_INIT(controller, channel, arch) \
    MCRegisterLocation.resize(controller + 1); \
    MCRegisterLocation[controller].resize(channel + 1); \
    MCRegisterLocation[controller][channel] =  \
        std::make_pair(arch##_MC##controller##_CH##channel##_REGISTER_DEV_ADDR, arch##_MC##controller##_CH##channel##_REGISTER_FUNC_ADDR);

#define PCM_PCICFG_QPI_INIT(port, arch) \
    XPIRegisterLocation.resize(port + 1); \
    XPIRegisterLocation[port] = std::make_pair(arch##_QPI_PORT##port##_REGISTER_DEV_ADDR, arch##_QPI_PORT##port##_REGISTER_FUNC_ADDR);

#define PCM_PCICFG_M3UPI_INIT(port, arch) \
    M3UPIRegisterLocation.resize(port + 1); \
    M3UPIRegisterLocation[port] = std::make_pair(arch##_M3UPI_PORT##port##_REGISTER_DEV_ADDR, arch##_M3UPI_PORT##port##_REGISTER_FUNC_ADDR);

#define PCM_PCICFG_EDC_INIT(controller, clock, arch) \
    EDCRegisterLocation.resize(controller + 1); \
    EDCRegisterLocation[controller] = std::make_pair(arch##_EDC##controller##_##clock##_REGISTER_DEV_ADDR, arch##_EDC##controller##_##clock##_REGISTER_FUNC_ADDR);

#define PCM_PCICFG_M2M_INIT(x, arch) \
    M2MRegisterLocation.resize(x + 1); \
    M2MRegisterLocation[x] = std::make_pair(arch##_M2M_##x##_REGISTER_DEV_ADDR, arch##_M2M_##x##_REGISTER_FUNC_ADDR);

#define PCM_PCICFG_HBM_M2M_INIT(x, arch) \
    HBM_M2MRegisterLocation.resize(x + 1); \
    HBM_M2MRegisterLocation[x] = std::make_pair(arch##_HBM_M2M_##x##_REGISTER_DEV_ADDR, arch##_HBM_M2M_##x##_REGISTER_FUNC_ADDR);

#define PCM_PCICFG_HA_INIT(x, arch) \
    HARegisterLocation.resize(x + 1); \
    HARegisterLocation[x] = std::make_pair(arch##_HA##x##_REGISTER_DEV_ADDR, arch##_HA##x##_REGISTER_FUNC_ADDR);

    switch (cpu_family_model)
    {
    case PCM::JAKETOWN:
    case PCM::IVYTOWN:
    {
        PCM_PCICFG_MC_INIT(0, 0, JKTIVT)
        PCM_PCICFG_MC_INIT(0, 1, JKTIVT)
        PCM_PCICFG_MC_INIT(0, 2, JKTIVT)
        PCM_PCICFG_MC_INIT(0, 3, JKTIVT)
        PCM_PCICFG_MC_INIT(1, 0, JKTIVT)
        PCM_PCICFG_MC_INIT(1, 1, JKTIVT)
        PCM_PCICFG_MC_INIT(1, 2, JKTIVT)
        PCM_PCICFG_MC_INIT(1, 3, JKTIVT)

        PCM_PCICFG_QPI_INIT(0, JKTIVT);
        PCM_PCICFG_QPI_INIT(1, JKTIVT);
        PCM_PCICFG_QPI_INIT(2, JKTIVT);
    }
    break;
    case PCM::HASWELLX:
    case PCM::BDX_DE:
    case PCM::BDX:
    {
        PCM_PCICFG_MC_INIT(0, 0, HSX)
        PCM_PCICFG_MC_INIT(0, 1, HSX)
        PCM_PCICFG_MC_INIT(0, 2, HSX)
        PCM_PCICFG_MC_INIT(0, 3, HSX)
        PCM_PCICFG_MC_INIT(1, 0, HSX)
        PCM_PCICFG_MC_INIT(1, 1, HSX)
        PCM_PCICFG_MC_INIT(1, 2, HSX)
        PCM_PCICFG_MC_INIT(1, 3, HSX)

        PCM_PCICFG_QPI_INIT(0, HSX);
        PCM_PCICFG_QPI_INIT(1, HSX);
        PCM_PCICFG_QPI_INIT(2, HSX);

        PCM_PCICFG_HA_INIT(0, HSX);
        PCM_PCICFG_HA_INIT(1, HSX);
    }
    break;
    case PCM::SKX:
    {
        PCM_PCICFG_MC_INIT(0, 0, SKX)
        PCM_PCICFG_MC_INIT(0, 1, SKX)
        PCM_PCICFG_MC_INIT(0, 2, SKX)
        PCM_PCICFG_MC_INIT(0, 3, SKX)
        PCM_PCICFG_MC_INIT(1, 0, SKX)
        PCM_PCICFG_MC_INIT(1, 1, SKX)
        PCM_PCICFG_MC_INIT(1, 2, SKX)
        PCM_PCICFG_MC_INIT(1, 3, SKX)

        PCM_PCICFG_QPI_INIT(0, SKX);
        PCM_PCICFG_QPI_INIT(1, SKX);
        PCM_PCICFG_QPI_INIT(2, SKX);

        if (pcm->isCPX())
        {
            PCM_PCICFG_QPI_INIT(3, CPX);
            PCM_PCICFG_QPI_INIT(4, CPX);
            PCM_PCICFG_QPI_INIT(5, CPX);
        }

        PCM_PCICFG_M2M_INIT(0, SKX)
        PCM_PCICFG_M2M_INIT(1, SKX)

        // M3UPI
        if (pcm->isCPX())
        {
            // CPX
            PCM_PCICFG_M3UPI_INIT(0, CPX);
            PCM_PCICFG_M3UPI_INIT(1, CPX);
            PCM_PCICFG_M3UPI_INIT(2, CPX);
            PCM_PCICFG_M3UPI_INIT(3, CPX);
            PCM_PCICFG_M3UPI_INIT(4, CPX);
            PCM_PCICFG_M3UPI_INIT(5, CPX);
        }
        else
        {
            // SKX/CLX
            PCM_PCICFG_M3UPI_INIT(0, SKX);
            PCM_PCICFG_M3UPI_INIT(1, SKX);
            PCM_PCICFG_M3UPI_INIT(2, SKX);
        }
    }
    break;
    case PCM::ICX:
    {
        PCM_PCICFG_QPI_INIT(0, ICX);
        PCM_PCICFG_QPI_INIT(1, ICX);
        PCM_PCICFG_QPI_INIT(2, ICX);

        PCM_PCICFG_M3UPI_INIT(0, ICX);
        PCM_PCICFG_M3UPI_INIT(1, ICX);
        PCM_PCICFG_M3UPI_INIT(2, ICX);

        PCM_PCICFG_M2M_INIT(0, SERVER)
        PCM_PCICFG_M2M_INIT(1, SERVER)
        PCM_PCICFG_M2M_INIT(2, SERVER)
        PCM_PCICFG_M2M_INIT(3, SERVER)
    }
    break;
    case PCM::SPR:
    case PCM::EMR:
    {
        PCM_PCICFG_QPI_INIT(0, SPR);
        PCM_PCICFG_QPI_INIT(1, SPR);
        PCM_PCICFG_QPI_INIT(2, SPR);
        PCM_PCICFG_QPI_INIT(3, SPR);

        PCM_PCICFG_M3UPI_INIT(0, SPR);
        PCM_PCICFG_M3UPI_INIT(1, SPR);
        PCM_PCICFG_M3UPI_INIT(2, SPR);
        PCM_PCICFG_M3UPI_INIT(3, SPR);

        PCM_PCICFG_M2M_INIT(0, SERVER)
        PCM_PCICFG_M2M_INIT(1, SERVER)
        PCM_PCICFG_M2M_INIT(2, SERVER)
        PCM_PCICFG_M2M_INIT(3, SERVER)

        PCM_PCICFG_HBM_M2M_INIT(0, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(1, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(2, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(3, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(4, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(5, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(6, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(7, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(8, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(9, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(10, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(11, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(12, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(13, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(14, SERVER)
        PCM_PCICFG_HBM_M2M_INIT(15, SERVER)
    }
    break;
    case PCM::KNL:
    {
        // 2 DDR4 Memory Controllers with 3 channels each
        PCM_PCICFG_MC_INIT(0, 0, KNL)
        PCM_PCICFG_MC_INIT(0, 1, KNL)
        PCM_PCICFG_MC_INIT(0, 2, KNL)
        PCM_PCICFG_MC_INIT(1, 0, KNL)
        PCM_PCICFG_MC_INIT(1, 1, KNL)
        PCM_PCICFG_MC_INIT(1, 2, KNL)

    // 8 MCDRAM (Multi-Channel [Stacked] DRAM) Memory Controllers
        PCM_PCICFG_EDC_INIT(0, ECLK, KNL)
        PCM_PCICFG_EDC_INIT(1, ECLK, KNL)
        PCM_PCICFG_EDC_INIT(2, ECLK, KNL)
        PCM_PCICFG_EDC_INIT(3, ECLK, KNL)
        PCM_PCICFG_EDC_INIT(4, ECLK, KNL)
        PCM_PCICFG_EDC_INIT(5, ECLK, KNL)
        PCM_PCICFG_EDC_INIT(6, ECLK, KNL)
        PCM_PCICFG_EDC_INIT(7, ECLK, KNL)
    }
    break;
    case PCM::SRF:
    case PCM::GNR:
    {
        PCM_PCICFG_QPI_INIT(0, BHS);
        PCM_PCICFG_QPI_INIT(1, BHS);
        PCM_PCICFG_QPI_INIT(2, BHS);
        PCM_PCICFG_QPI_INIT(3, BHS);
        PCM_PCICFG_QPI_INIT(4, BHS);
        PCM_PCICFG_QPI_INIT(5, BHS);

        // B2CMI (M2M)
        PCM_PCICFG_M2M_INIT(0, BHS)
        PCM_PCICFG_M2M_INIT(1, BHS)
        PCM_PCICFG_M2M_INIT(2, BHS)
        PCM_PCICFG_M2M_INIT(3, BHS)
        PCM_PCICFG_M2M_INIT(4, BHS)
        PCM_PCICFG_M2M_INIT(5, BHS)
        PCM_PCICFG_M2M_INIT(6, BHS)
        PCM_PCICFG_M2M_INIT(7, BHS)
        PCM_PCICFG_M2M_INIT(8, BHS)
        PCM_PCICFG_M2M_INIT(9, BHS)
        PCM_PCICFG_M2M_INIT(10, BHS)
        PCM_PCICFG_M2M_INIT(11, BHS)

        // B2UPI (M3UPI)
        PCM_PCICFG_M3UPI_INIT(0, BHS);
        PCM_PCICFG_M3UPI_INIT(1, BHS);
        PCM_PCICFG_M3UPI_INIT(2, BHS);
        PCM_PCICFG_M3UPI_INIT(3, BHS);
        PCM_PCICFG_M3UPI_INIT(4, BHS);
        PCM_PCICFG_M3UPI_INIT(5, BHS);
    }
    break;
    case PCM::GNR_D:
    {
        // B2CMI (M2M)
        PCM_PCICFG_M2M_INIT(0, BHS)
        PCM_PCICFG_M2M_INIT(1, BHS)
        PCM_PCICFG_M2M_INIT(2, BHS)
        PCM_PCICFG_M2M_INIT(3, BHS)
        PCM_PCICFG_M2M_INIT(4, BHS)
        PCM_PCICFG_M2M_INIT(5, BHS)
        PCM_PCICFG_M2M_INIT(6, BHS)
        PCM_PCICFG_M2M_INIT(7, BHS)
    }
    break;
    case PCM::SNOWRIDGE:
    {
        PCM_PCICFG_M2M_INIT(0, SERVER)
        PCM_PCICFG_M2M_INIT(1, SERVER)
        PCM_PCICFG_M2M_INIT(2, SERVER)
        PCM_PCICFG_M2M_INIT(3, SERVER)
    }
    break;
    case PCM::GRR:
    {
        // placeholder to init GRR PCICFG
    }
    break;
    default:
        std::cerr << "Error: Uncore PMU for processor with id 0x" << std::hex << cpu_family_model << std::dec << " is not supported.\n";
        throw std::exception();
    }

#undef PCM_PCICFG_MC_INIT
#undef PCM_PCICFG_QPI_INIT
#undef PCM_PCICFG_M3UPI_INIT
#undef PCM_PCICFG_EDC_INIT
#undef PCM_PCICFG_M2M_INIT
#undef PCM_PCICFG_HA_INIT
}

void ServerUncorePMUs::initBuses(uint32 socket_, const PCM * pcm)
{
    const uint32 total_sockets_ = pcm->getNumSockets();

    if (M2MRegisterLocation.size())
    {
        initSocket2Bus(socket2M2Mbus, M2MRegisterLocation[0].first, M2MRegisterLocation[0].second, M2M_DEV_IDS, (uint32)sizeof(M2M_DEV_IDS) / sizeof(M2M_DEV_IDS[0]));
        if (socket_ < socket2M2Mbus.size())
        {
            groupnr = socket2M2Mbus[socket_].first;
            M2Mbus = socket2M2Mbus[socket_].second;
        }
        else
        {
            std::cerr << "PCM error: socket_ " << socket_ << " >= socket2M2Mbus.size() " << socket2M2Mbus.size() << "\n";
        }
        if (total_sockets_ != socket2M2Mbus.size())
        {
            std::cerr << "PCM warning: total_sockets_ " << total_sockets_ << " does not match socket2M2Mbus.size() " << socket2M2Mbus.size() << "\n";
        }
    }

    if (MCRegisterLocation.size() > 0 && MCRegisterLocation[0].size() > 0)
    {
        initSocket2Bus(socket2iMCbus, MCRegisterLocation[0][0].first, MCRegisterLocation[0][0].second, IMC_DEV_IDS, (uint32)sizeof(IMC_DEV_IDS) / sizeof(IMC_DEV_IDS[0]));

        if (total_sockets_ == socket2iMCbus.size())
        {
            if (total_sockets_ == socket2M2Mbus.size() && socket2iMCbus[socket_].first != socket2M2Mbus[socket_].first)
            {
                std::cerr << "PCM error: mismatching PCICFG group number for M2M and IMC perfmon devices.\n";
                M2Mbus = -1;
            }
            groupnr = socket2iMCbus[socket_].first;
            iMCbus = socket2iMCbus[socket_].second;
        }
        else if (total_sockets_ <= 4)
        {
            iMCbus = getBusFromSocket(socket_);
            if (iMCbus < 0)
            {
                std::cerr << "Cannot find bus for socket " << socket_ << " on system with " << total_sockets_ << " sockets.\n";
                throw std::exception();
            }
            else
            {
                std::cerr << "PCM Warning: the bus for socket " << socket_ << " on system with " << total_sockets_ << " sockets could not find via PCI bus scan. Using cpubusno register. Bus = " << iMCbus << "\n";
            }
        }
        else
        {
            std::cerr << "Cannot find bus for socket " << socket_ << " on system with " << total_sockets_ << " sockets.\n";
            throw std::exception();
        }
    }

#if 1
    if (total_sockets_ == 1) {
        /*
         * For single socket systems, do not worry at all about QPI ports.  This
         *  eliminates QPI LL programming error messages on single socket systems
         *  with BIOS that hides QPI performance counting PCI functions.  It also
         *  eliminates register programming that is not needed since no QPI traffic
         *  is possible with single socket systems.
         */
        return;
    }
#endif

#ifdef PCM_NOQPI
    return;
#endif

    if (PCM::hasUPI(cpu_family_model) && XPIRegisterLocation.size() > 0)
    {
        initSocket2Bus(socket2UPIbus, XPIRegisterLocation[0].first, XPIRegisterLocation[0].second, UPI_DEV_IDS, (uint32)sizeof(UPI_DEV_IDS) / sizeof(UPI_DEV_IDS[0]));
        if(total_sockets_ == socket2UPIbus.size())
        {
            UPIbus = socket2UPIbus[socket_].second;
            if(groupnr != socket2UPIbus[socket_].first)
            {
                UPIbus = -1;
                std::cerr << "PCM error: mismatching PCICFG group number for UPI and IMC perfmon devices.\n";
            }
        }
        else
        {
            std::cerr << "PCM error: Did not find UPI perfmon device on every socket in a multisocket system.\n";
        }
    }
    else
    {
        UPIbus = iMCbus;
    }
    DBG(1, "UPIbus: ", UPIbus);
}

void ServerUncorePMUs::initDirect(uint32 socket_, const PCM * pcm)
{
    {
        std::vector<std::shared_ptr<PciHandleType> > imcHandles;

        auto lastWorkingChannels = imcHandles.size();
        for (auto & ctrl: MCRegisterLocation)
        {
            for (auto & channel : ctrl)
            {
                PciHandleType * handle = createIntelPerfMonDevice(groupnr, iMCbus, channel.first, channel.second, true);
                if (handle) imcHandles.push_back(std::shared_ptr<PciHandleType>(handle));
            }
            if (imcHandles.size() > lastWorkingChannels)
            {
                num_imc_channels.push_back((uint32)(imcHandles.size() - lastWorkingChannels));
            }
            lastWorkingChannels = imcHandles.size();
        }

        for (auto & handle : imcHandles)
        {
            if (cpu_family_model == PCM::KNL) {
                imcPMUs.push_back(
                    UncorePMU(
                        std::make_shared<PCICFGRegister32>(handle, KNX_MC_CH_PCI_PMON_BOX_CTL_ADDR),
                        std::make_shared<PCICFGRegister32>(handle, KNX_MC_CH_PCI_PMON_CTL0_ADDR),
                        std::make_shared<PCICFGRegister32>(handle, KNX_MC_CH_PCI_PMON_CTL1_ADDR),
                        std::make_shared<PCICFGRegister32>(handle, KNX_MC_CH_PCI_PMON_CTL2_ADDR),
                        std::make_shared<PCICFGRegister32>(handle, KNX_MC_CH_PCI_PMON_CTL3_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, KNX_MC_CH_PCI_PMON_CTR0_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, KNX_MC_CH_PCI_PMON_CTR1_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, KNX_MC_CH_PCI_PMON_CTR2_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, KNX_MC_CH_PCI_PMON_CTR3_ADDR),
                        std::make_shared<PCICFGRegister32>(handle, KNX_MC_CH_PCI_PMON_FIXED_CTL_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, KNX_MC_CH_PCI_PMON_FIXED_CTR_ADDR))
                );
            }
            else {
                imcPMUs.push_back(
                    UncorePMU(
                        std::make_shared<PCICFGRegister32>(handle, XPF_MC_CH_PCI_PMON_BOX_CTL_ADDR),
                        std::make_shared<PCICFGRegister32>(handle, XPF_MC_CH_PCI_PMON_CTL0_ADDR),
                        std::make_shared<PCICFGRegister32>(handle, XPF_MC_CH_PCI_PMON_CTL1_ADDR),
                        std::make_shared<PCICFGRegister32>(handle, XPF_MC_CH_PCI_PMON_CTL2_ADDR),
                        std::make_shared<PCICFGRegister32>(handle, XPF_MC_CH_PCI_PMON_CTL3_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, XPF_MC_CH_PCI_PMON_CTR0_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, XPF_MC_CH_PCI_PMON_CTR1_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, XPF_MC_CH_PCI_PMON_CTR2_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, XPF_MC_CH_PCI_PMON_CTR3_ADDR),
                        std::make_shared<PCICFGRegister32>(handle, XPF_MC_CH_PCI_PMON_FIXED_CTL_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, XPF_MC_CH_PCI_PMON_FIXED_CTR_ADDR))
                );
            }
        }
    }

    auto populateM2MPMUs = [](uint32 groupnr, int32 M2Mbus, int32 cpu_family_model, const std::vector<std::pair<uint32, uint32> > & M2MRegisterLocation, UncorePMUVector & m2mPMUs)
    {
        std::vector<std::shared_ptr<PciHandleType> > m2mHandles;

        if (M2Mbus >= 0)
        {
            for (auto & reg : M2MRegisterLocation)
            {
                PciHandleType * handle = createIntelPerfMonDevice(groupnr, M2Mbus, reg.first, reg.second, true);
                if (handle) m2mHandles.push_back(std::shared_ptr<PciHandleType>(handle));
            }
        }

        for (auto & handle : m2mHandles)
        {
            switch (cpu_family_model)
            {
            case PCM::ICX:
            case PCM::SNOWRIDGE:
            case PCM::SPR:
            case PCM::EMR:
            case PCM::GNR: // B2CMI PMUs
            case PCM::GNR_D:
            case PCM::SRF:
                m2mPMUs.push_back(
                    UncorePMU(
                        std::make_shared<PCICFGRegister32>(handle, SERVER_M2M_PCI_PMON_BOX_CTL_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SERVER_M2M_PCI_PMON_CTL0_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SERVER_M2M_PCI_PMON_CTL1_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SERVER_M2M_PCI_PMON_CTL2_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SERVER_M2M_PCI_PMON_CTL3_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SERVER_M2M_PCI_PMON_CTR0_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SERVER_M2M_PCI_PMON_CTR1_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SERVER_M2M_PCI_PMON_CTR2_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SERVER_M2M_PCI_PMON_CTR3_ADDR)
                    )
                );
                break;
            default:
                m2mPMUs.push_back(
                    UncorePMU(
                        std::make_shared<PCICFGRegister32>(handle, SKX_M2M_PCI_PMON_BOX_CTL_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SKX_M2M_PCI_PMON_CTL0_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SKX_M2M_PCI_PMON_CTL1_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SKX_M2M_PCI_PMON_CTL2_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SKX_M2M_PCI_PMON_CTL3_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SKX_M2M_PCI_PMON_CTR0_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SKX_M2M_PCI_PMON_CTR1_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SKX_M2M_PCI_PMON_CTR2_ADDR),
                        std::make_shared<PCICFGRegister64>(handle, SKX_M2M_PCI_PMON_CTR3_ADDR)
                    )
                );
            }
        }
    };
    populateM2MPMUs(groupnr, M2Mbus, cpu_family_model, M2MRegisterLocation, m2mPMUs);
    populateM2MPMUs(groupnr, M2Mbus, cpu_family_model, HBM_M2MRegisterLocation, hbm_m2mPMUs);

    int numChannels = 0;
    if (safe_getenv("PCM_NO_IMC_DISCOVERY") == std::string("1"))
    {
        if (cpu_family_model == PCM::SPR || cpu_family_model == PCM::EMR)
        {
            numChannels = 3;
        }
    }
    if (cpu_family_model == PCM::SNOWRIDGE || cpu_family_model == PCM::ICX)
    {
        numChannels = 2;
        if (PCM::getCPUFamilyModelFromCPUID() == PCM::ICX_D)
        {
            numChannels = 3;
        }
    }

    auto createIMCPMU = [](const size_t addr, const size_t mapSize) -> UncorePMU
    {
        const auto alignedAddr = addr & ~4095ULL;
        const auto alignDelta = addr & 4095ULL;
        auto handle = std::make_shared<MMIORange>(alignedAddr, mapSize, false);
        return UncorePMU(
            std::make_shared<MMIORegister32>(handle, SERVER_MC_CH_PMON_BOX_CTL_OFFSET + alignDelta),
            std::make_shared<MMIORegister32>(handle, SERVER_MC_CH_PMON_CTL0_OFFSET + alignDelta),
            std::make_shared<MMIORegister32>(handle, SERVER_MC_CH_PMON_CTL1_OFFSET + alignDelta),
            std::make_shared<MMIORegister32>(handle, SERVER_MC_CH_PMON_CTL2_OFFSET + alignDelta),
            std::make_shared<MMIORegister32>(handle, SERVER_MC_CH_PMON_CTL3_OFFSET + alignDelta),
            std::make_shared<MMIORegister64>(handle, SERVER_MC_CH_PMON_CTR0_OFFSET + alignDelta),
            std::make_shared<MMIORegister64>(handle, SERVER_MC_CH_PMON_CTR1_OFFSET + alignDelta),
            std::make_shared<MMIORegister64>(handle, SERVER_MC_CH_PMON_CTR2_OFFSET + alignDelta),
            std::make_shared<MMIORegister64>(handle, SERVER_MC_CH_PMON_CTR3_OFFSET + alignDelta),
            std::make_shared<MMIORegister32>(handle, SERVER_MC_CH_PMON_FIXED_CTL_OFFSET + alignDelta),
            std::make_shared<MMIORegister64>(handle, SERVER_MC_CH_PMON_FIXED_CTR_OFFSET + alignDelta)
        );
    };

    auto initAndCheckSocket2Ubox0Bus = [&socket_]() -> bool
    {
        initSocket2Ubox0Bus();
        if (socket_ >= socket2UBOX0bus.size())
        {
            std::cerr << "ERROR: socket " << socket_ << " is not found in socket2UBOX0bus. socket2UBOX0bus.size =" << socket2UBOX0bus.size() << std::endl;
            return false;
        }
        return true;
    };

    if (numChannels > 0)
    {
        if (initAndCheckSocket2Ubox0Bus())
        {
            auto memBars = getServerMemBars((uint32)m2mPMUs.size(), socket2UBOX0bus[socket_].first, socket2UBOX0bus[socket_].second);
            for (auto & memBar : memBars)
            {
                for (int channel = 0; channel < numChannels; ++channel)
                {
                    imcPMUs.push_back(createIMCPMU(memBar + SERVER_MC_CH_PMON_BASE_ADDR + channel * SERVER_MC_CH_PMON_STEP, SERVER_MC_CH_PMON_SIZE));
                }
                num_imc_channels.push_back(numChannels);
            }
        }
    }
    else
    {
        switch (cpu_family_model)
        {
            case PCM::SPR:
            case PCM::EMR:
                {
                    auto & uncorePMUDiscovery = pcm->uncorePMUDiscovery;
                    const auto BoxType = SPR_IMC_BOX_TYPE;
                    if (uncorePMUDiscovery.get())
                    {
                        for (size_t die = 0; die < uncorePMUDiscovery->getNumDies(socket_); ++die)
                        {
                            const auto numBoxes = uncorePMUDiscovery->getNumBoxes(BoxType, socket_, die);
                            for (size_t pos = 0; pos < numBoxes; ++pos)
                            {
                                if (uncorePMUDiscovery->getBoxAccessType(BoxType, socket_, die, pos) == UncorePMUDiscovery::accessTypeEnum::MMIO)
                                {
                                    std::vector<std::shared_ptr<HWRegister> > CounterControlRegs, CounterValueRegs;
                                    const auto n_regs = uncorePMUDiscovery->getBoxNumRegs(BoxType, socket_, die, pos);
                                    auto makeRegister = [](const uint64 rawAddr, const uint32 bits) -> std::shared_ptr<HWRegister>
                                    {
                                        const auto mapSize = SERVER_MC_CH_PMON_SIZE;
                                        const auto alignedAddr = rawAddr & ~4095ULL;
                                        const auto alignDelta = rawAddr & 4095ULL;
                                        try {
                                            auto handle = std::make_shared<MMIORange>(alignedAddr, mapSize, false);
                                            assert(handle.get());
                                            switch (bits)
                                            {
                                                case 32:
                                                    return std::make_shared<MMIORegister32>(handle, (size_t)alignDelta);
                                                case 64:
                                                    return std::make_shared<MMIORegister64>(handle, (size_t)alignDelta);
                                            }
                                        }
                                        catch (...)
                                        {
                                        }
                                        return std::shared_ptr<HWRegister>();
                                    };

                                    auto boxCtlRegister = makeRegister(uncorePMUDiscovery->getBoxCtlAddr(BoxType, socket_, die, pos), 32);
                                    if (boxCtlRegister.get())
                                    {
                                        for (size_t r = 0; r < n_regs; ++r)
                                        {
                                            CounterControlRegs.push_back(makeRegister(uncorePMUDiscovery->getBoxCtlAddr(BoxType, socket_, die, pos, r), 32));
                                            CounterValueRegs.push_back(makeRegister(uncorePMUDiscovery->getBoxCtrAddr(BoxType, socket_, die, pos, r), 64));
                                        }
                                        imcPMUs.push_back(UncorePMU(boxCtlRegister,
                                            CounterControlRegs,
                                            CounterValueRegs,
                                            makeRegister(uncorePMUDiscovery->getBoxCtlAddr(BoxType, socket_, die, pos) + SERVER_MC_CH_PMON_FIXED_CTL_OFFSET, 32),
                                            makeRegister(uncorePMUDiscovery->getBoxCtlAddr(BoxType, socket_, die, pos) + SERVER_MC_CH_PMON_FIXED_CTR_OFFSET, 64)));
                                    }
                                }
                            }
                        }
                    }
                    if (imcPMUs.empty() == false)
                    {
                        numChannels = 2;
                        for (size_t c = 0; c < imcPMUs.size(); c += numChannels)
                        {
                            num_imc_channels.push_back(numChannels);
                        }
                    }
                }
                break;
        }
    }

    auto initBHSiMCPMUsBase = [&](const size_t base, const size_t numChannelsParam)
    {
        numChannels = (std::min)(numChannelsParam, m2mPMUs.size());
        if (initAndCheckSocket2Ubox0Bus())
        {
            auto memBar = getServerSCFBar(socket2UBOX0bus[socket_].first, socket2UBOX0bus[socket_].second);
            for (int channel = 0; channel < numChannels; ++channel)
            {
                imcPMUs.push_back(createIMCPMU(memBar + base + channel * SERVER_MC_CH_PMON_STEP, SERVER_MC_CH_PMON_SIZE));
                num_imc_channels.push_back(1);
            }
        }
    };

    auto initBHSiMCPMUs = [&](const size_t numChannelsParam)
    {
        initBHSiMCPMUsBase(BHS_MC_CH_PMON_BASE_ADDR, numChannelsParam);
    };

    switch (cpu_family_model)
    {
        case PCM::GRR:
            initBHSiMCPMUs(2);
            break;
        case PCM::GNR:
        case PCM::SRF:
            initBHSiMCPMUs(12);
            break;
        case PCM::GNR_D:
            initBHSiMCPMUsBase(pcm->getCPUStepping() ? GNR_D_B_MC_CH_PMON_BASE_ADDR : GNR_D_A_MC_CH_PMON_BASE_ADDR, 8);
            break;
    }

    if (imcPMUs.empty())
    {
        std::cerr << "PCM error: no memory controllers found.\n";
        throw std::exception();
    }

    if (cpu_family_model == PCM::KNL)
    {
        std::vector<std::shared_ptr<PciHandleType> > edcHandles;

        for (auto & reg : EDCRegisterLocation)
        {
            PciHandleType * handle = createIntelPerfMonDevice(groupnr, iMCbus, reg.first, reg.second, true);
            if (handle) edcHandles.push_back(std::shared_ptr<PciHandleType>(handle));
        }

        for (auto & handle : edcHandles)
        {
            edcPMUs.push_back(
                UncorePMU(
                    std::make_shared<PCICFGRegister32>(handle, KNX_EDC_CH_PCI_PMON_BOX_CTL_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, KNX_EDC_CH_PCI_PMON_CTL0_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, KNX_EDC_CH_PCI_PMON_CTL1_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, KNX_EDC_CH_PCI_PMON_CTL2_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, KNX_EDC_CH_PCI_PMON_CTL3_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, KNX_EDC_CH_PCI_PMON_CTR0_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, KNX_EDC_CH_PCI_PMON_CTR1_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, KNX_EDC_CH_PCI_PMON_CTR2_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, KNX_EDC_CH_PCI_PMON_CTR3_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, KNX_EDC_CH_PCI_PMON_FIXED_CTL_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, KNX_EDC_CH_PCI_PMON_FIXED_CTR_ADDR))
            );
        }
    }

    if (hbm_m2mPMUs.empty() == false)
    {
        // HBM
        if (initAndCheckSocket2Ubox0Bus())
        {
            const auto bar = getServerSCFBar(socket2UBOX0bus[socket_].first, socket2UBOX0bus[socket_].second);
            for (size_t box = 0; box < hbm_m2mPMUs.size(); ++box)
            {
                for (int channel = 0; channel < 2; ++channel)
                {
                    edcPMUs.push_back(createIMCPMU(bar + SERVER_HBM_CH_PMON_BASE_ADDR + box * SERVER_HBM_BOX_PMON_STEP + channel * SERVER_HBM_CH_PMON_STEP, SERVER_HBM_CH_PMON_SIZE));
                }
            }
        }
    }

    std::vector<std::shared_ptr<PciHandleType> > m3upiHandles;
    if (UPIbus >= 0)
    {
        for (auto& reg : M3UPIRegisterLocation)
        {
            PciHandleType* handle = createIntelPerfMonDevice(groupnr, UPIbus, reg.first, reg.second, true);
            if (handle) m3upiHandles.push_back(std::shared_ptr<PciHandleType>(handle));
        }
    }
    for (auto& handle : m3upiHandles)
    {
        switch (cpu_family_model)
        {
        case PCM::ICX:
        case PCM::SPR:
        case PCM::EMR:
            m3upiPMUs.push_back(
                UncorePMU(
                    std::make_shared<PCICFGRegister32>(handle, ICX_M3UPI_PCI_PMON_BOX_CTL_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, ICX_M3UPI_PCI_PMON_CTL0_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, ICX_M3UPI_PCI_PMON_CTL1_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, ICX_M3UPI_PCI_PMON_CTL2_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, ICX_M3UPI_PCI_PMON_CTL3_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, ICX_M3UPI_PCI_PMON_CTR0_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, ICX_M3UPI_PCI_PMON_CTR1_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, ICX_M3UPI_PCI_PMON_CTR2_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, ICX_M3UPI_PCI_PMON_CTR3_ADDR)
                )
            );
            break;
        case PCM::GNR:
        case PCM::SRF:
            m3upiPMUs.push_back(
                UncorePMU(
                    std::make_shared<PCICFGRegister64>(handle, BHS_M3UPI_PCI_PMON_BOX_CTL_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, BHS_M3UPI_PCI_PMON_CTL0_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, BHS_M3UPI_PCI_PMON_CTL1_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, BHS_M3UPI_PCI_PMON_CTL2_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, BHS_M3UPI_PCI_PMON_CTL3_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, BHS_M3UPI_PCI_PMON_CTR0_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, BHS_M3UPI_PCI_PMON_CTR1_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, BHS_M3UPI_PCI_PMON_CTR2_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, BHS_M3UPI_PCI_PMON_CTR3_ADDR)
                )
            );
            break;

        default:
            m3upiPMUs.push_back(
                UncorePMU(
                    std::make_shared<PCICFGRegister32>(handle, M3UPI_PCI_PMON_BOX_CTL_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, M3UPI_PCI_PMON_CTL0_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, M3UPI_PCI_PMON_CTL1_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, M3UPI_PCI_PMON_CTL2_ADDR),
                    std::shared_ptr<PCICFGRegister32>(),
                    std::make_shared<PCICFGRegister64>(handle, M3UPI_PCI_PMON_CTR0_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, M3UPI_PCI_PMON_CTR1_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, M3UPI_PCI_PMON_CTR2_ADDR),
                    std::shared_ptr<PCICFGRegister64>()
                )
            );
        }
    }

    {
        std::vector<std::shared_ptr<PciHandleType> > haHandles;
        for (auto & reg : HARegisterLocation)
        {
            auto handle = createIntelPerfMonDevice(groupnr, iMCbus, reg.first, reg.second, true);
            if (handle) haHandles.push_back(std::shared_ptr<PciHandleType>(handle));
        }

        for (auto & handle : haHandles)
        {
            haPMUs.push_back(
                UncorePMU(
                    std::make_shared<PCICFGRegister32>(handle, XPF_HA_PCI_PMON_BOX_CTL_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, XPF_HA_PCI_PMON_CTL0_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, XPF_HA_PCI_PMON_CTL1_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, XPF_HA_PCI_PMON_CTL2_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, XPF_HA_PCI_PMON_CTL3_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, XPF_HA_PCI_PMON_CTR0_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, XPF_HA_PCI_PMON_CTR1_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, XPF_HA_PCI_PMON_CTR2_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, XPF_HA_PCI_PMON_CTR3_ADDR)
                )
            );
        }
    }

    if (pcm->getNumSockets() == 1) {
        /*
         * For single socket systems, do not worry at all about QPI ports.  This
         *  eliminates QPI LL programming error messages on single socket systems
         *  with BIOS that hides QPI performance counting PCI functions.  It also
         *  eliminates register programming that is not needed since no QPI traffic
         *  is possible with single socket systems.
         */
        xpiPMUs.clear();
        return;
    }

#ifdef PCM_NOQPI
    xpiPMUs.clear();
    std::cerr << getNumMC() << " memory controllers detected with total number of " << imcPMUs.size() << " channels. " <<
        m2mPMUs.size() << " M2M (mesh to memory) blocks detected. "
        << haPMUs.size() << " Home Agents detected. "
        << m3upiPMUs.size() << " M3UPI blocks detected. "
        "\n";
    return;
#endif

    if (pcm->getNumSockets() <= 4 && safe_getenv("PCM_NO_UPILL_DISCOVERY") != std::string("1"))
    {
        switch (cpu_family_model)
        {
            // don't use the discovery on SPR to work-around the issue
	    // mentioned in https://lore.kernel.org/lkml/20221129191023.936738-1-kan.liang@linux.intel.com/T/
            case PCM::EMR:
                {
                    std::cerr << "INFO: Trying to detect UPILL PMU through uncore PMU discovery..\n";
                    pcm->getPCICFGPMUsFromDiscovery(SPR_UPILL_BOX_TYPE, socket_, [this](const UncorePMU & pmu)
                    {
                        xpiPMUs.push_back(pmu);
                    });
                }
                break;
        }
    }

    std::vector<std::shared_ptr<PciHandleType> > qpiLLHandles;
    auto xPI = pcm->xPI();
    try
    {
        if (xpiPMUs.empty()) for (size_t i = 0; i < XPIRegisterLocation.size(); ++i)
        {
            PciHandleType * handle = createIntelPerfMonDevice(groupnr, UPIbus, XPIRegisterLocation[i].first, XPIRegisterLocation[i].second, true);
            if (handle)
                qpiLLHandles.push_back(std::shared_ptr<PciHandleType>(handle));
            else
            {
                if (i == 0 || i == 1)
                {
                    std::cerr << "ERROR: " << xPI << " LL monitoring device (" << std::hex << groupnr << ":" << UPIbus << ":" << XPIRegisterLocation[i].first << ":" <<
                        XPIRegisterLocation[i].second << ") is missing. The " << xPI << " statistics will be incomplete or missing." << std::dec << "\n";
                }
                else if (pcm->getCPUBrandString().find("E7") != std::string::npos) // Xeon E7
                {
                    std::cerr << "ERROR: " << xPI << " LL performance monitoring device for the third " << xPI << " link was not found on " << pcm->getCPUBrandString() <<
                        " processor in socket " << socket_ << ". Possibly BIOS hides the device. The " << xPI << " statistics will be incomplete or missing.\n";
                }
            }
        }
    }
    catch (...)
    {
        std::cerr << "PCM Error: can not create " << xPI << " LL handles.\n";
        throw std::exception();
    }

    if (xpiPMUs.empty()) for (auto & handle : qpiLLHandles)
    {
        switch (cpu_family_model)
        {
        case PCM::SKX:
            xpiPMUs.push_back(
                UncorePMU(
                    std::make_shared<PCICFGRegister32>(handle, U_L_PCI_PMON_BOX_CTL_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, U_L_PCI_PMON_CTL0_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, U_L_PCI_PMON_CTL1_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, U_L_PCI_PMON_CTL2_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, U_L_PCI_PMON_CTL3_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, U_L_PCI_PMON_CTR0_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, U_L_PCI_PMON_CTR1_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, U_L_PCI_PMON_CTR2_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, U_L_PCI_PMON_CTR3_ADDR)
                    )
            );
            break;
        case PCM::ICX:
            xpiPMUs.push_back(
                UncorePMU(
                    std::make_shared<PCICFGRegister32>(handle, ICX_UPI_PCI_PMON_BOX_CTL_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, ICX_UPI_PCI_PMON_CTL0_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, ICX_UPI_PCI_PMON_CTL1_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, ICX_UPI_PCI_PMON_CTL2_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, ICX_UPI_PCI_PMON_CTL3_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, ICX_UPI_PCI_PMON_CTR0_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, ICX_UPI_PCI_PMON_CTR1_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, ICX_UPI_PCI_PMON_CTR2_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, ICX_UPI_PCI_PMON_CTR3_ADDR)
                )
            );
            break;
       case PCM::SPR:
       case PCM::EMR:
       case PCM::GNR:
       case PCM::SRF:
            xpiPMUs.push_back(
                UncorePMU(
                    std::make_shared<PCICFGRegister32>(handle, SPR_UPI_PCI_PMON_BOX_CTL_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, SPR_UPI_PCI_PMON_CTL0_ADDR + 8*0),
                    std::make_shared<PCICFGRegister32>(handle, SPR_UPI_PCI_PMON_CTL0_ADDR + 8*1),
                    std::make_shared<PCICFGRegister32>(handle, SPR_UPI_PCI_PMON_CTL0_ADDR + 8*2),
                    std::make_shared<PCICFGRegister32>(handle, SPR_UPI_PCI_PMON_CTL0_ADDR + 8*3),
                    std::make_shared<PCICFGRegister64>(handle, SPR_UPI_PCI_PMON_CTR0_ADDR + 8*0),
                    std::make_shared<PCICFGRegister64>(handle, SPR_UPI_PCI_PMON_CTR0_ADDR + 8*1),
                    std::make_shared<PCICFGRegister64>(handle, SPR_UPI_PCI_PMON_CTR0_ADDR + 8*2),
                    std::make_shared<PCICFGRegister64>(handle, SPR_UPI_PCI_PMON_CTR0_ADDR + 8*3)
                )
            );
            break;
        default:
            xpiPMUs.push_back(
                UncorePMU(
                    std::make_shared<PCICFGRegister32>(handle, Q_P_PCI_PMON_BOX_CTL_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, Q_P_PCI_PMON_CTL0_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, Q_P_PCI_PMON_CTL1_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, Q_P_PCI_PMON_CTL2_ADDR),
                    std::make_shared<PCICFGRegister32>(handle, Q_P_PCI_PMON_CTL3_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, Q_P_PCI_PMON_CTR0_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, Q_P_PCI_PMON_CTR1_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, Q_P_PCI_PMON_CTR2_ADDR),
                    std::make_shared<PCICFGRegister64>(handle, Q_P_PCI_PMON_CTR3_ADDR)
                    )
            );
        }
    }
}

bool ServerUncorePMUs::HBMAvailable() const
{
    return edcPMUs.empty() == false;
}


#ifdef PCM_USE_PERF
class PerfVirtualFilterRegister;

class PerfVirtualControlRegister : public HWRegister
{
    friend class PerfVirtualCounterRegister;
    friend class PerfVirtualFilterRegister;
    friend class IDXPerfVirtualFilterRegister;
    int fd;
    int socket;
    int pmuID;
    perf_event_attr event;
    bool fixed;
    void close()
    {
        if (fd >= 0)
        {
            ::close(fd);
            fd = -1;
        }
    }
    PerfVirtualControlRegister(const PerfVirtualControlRegister &) = delete;
    PerfVirtualControlRegister & operator = (const PerfVirtualControlRegister &) = delete;
public:
    PerfVirtualControlRegister(int socket_, int pmuID_, bool fixed_ = false) :
        fd(-1),
        socket(socket_),
        pmuID(pmuID_),
        fixed(fixed_)
    {
        event = PCM_init_perf_event_attr(false);
        event.type = pmuID;
    }
    void operator = (uint64 val) override
    {
        close();
        event.config = fixed ? 0xff : val;
        const auto core = PCM::getInstance()->socketRefCore[socket];
        if ((fd = syscall(SYS_perf_event_open, &event, -1, core, -1, 0)) <= 0)
        {
            std::cerr << "Linux Perf: Error on programming PMU " << pmuID << ":  " << strerror(errno) << "\n";
            std::cerr << "config: 0x" << std::hex << event.config << " config1: 0x" << event.config1 << " config2: 0x" << event.config2 << std::dec << "\n";
            if (errno == 24) std::cerr << PCM_ULIMIT_RECOMMENDATION;
            return;
        }
    }
    operator uint64 () override
    {
        return event.config;
    }
    ~PerfVirtualControlRegister()
    {
        close();
    }
    int getFD() const { return fd; }
    int getPMUID() const { return pmuID; }
};

class PerfVirtualCounterRegister : public HWRegister
{
    std::shared_ptr<PerfVirtualControlRegister> controlReg;
public:
    PerfVirtualCounterRegister(const std::shared_ptr<PerfVirtualControlRegister> & controlReg_) : controlReg(controlReg_)
    {
    }
    void operator = (uint64 /* val */) override
    {
        // no-op
    }
    operator uint64 () override
    {
        uint64 result = 0;
        if (controlReg.get() && (controlReg->getFD() >= 0))
        {
            int status = ::read(controlReg->getFD(), &result, sizeof(result));
            if (status != sizeof(result))
            {
                std::cerr << "PCM Error: failed to read from Linux perf handle " << controlReg->getFD() << " PMU " << controlReg->getPMUID() << "\n";
            }
        }
        return result;
    }
};

class PerfVirtualFilterRegister : public HWRegister
{
    uint64 lastValue;
    std::array<std::shared_ptr<PerfVirtualControlRegister>, 4> controlRegs;
    int filterNr;
public:
    PerfVirtualFilterRegister(std::array<std::shared_ptr<PerfVirtualControlRegister>, 4> & controlRegs_, int filterNr_) :
            lastValue(0),
            controlRegs(controlRegs_),
            filterNr(filterNr_)
    {
    }
    void operator = (uint64 val) override
    {
        lastValue = val;
        for (auto & ctl: controlRegs)
        {
            union {
                uint64 config1;
                uint32 config1HL[2];
            } cvt;
            cvt.config1 = ctl->event.config1;
	    cvt.config1HL[filterNr] = val;
	    ctl->event.config1 = cvt.config1;
        }
    }
    operator uint64 () override
    {
        return lastValue;
    }
};

class IDXPerfVirtualFilterRegister : public HWRegister
{
    uint64 lastValue;
    std::shared_ptr<PerfVirtualControlRegister> controlReg;
    int filterNr;
public:
    IDXPerfVirtualFilterRegister(std::shared_ptr<PerfVirtualControlRegister> controlReg_, int filterNr_) :
            lastValue(0),
            controlReg(controlReg_),
            filterNr(filterNr_)
    {
    }
    void operator = (uint64 val) override
    {
        lastValue = val;

        /*
        struct {
            u64 wq:32;
            u64 tc:8;
            u64 pg_sz:4;
            u64 xfer_sz:8;
            u64 eng:8;
        } filter_cfg;
        */
        
        switch (filterNr)
        {
            case 0: //FLT_WQ
                controlReg->event.config1 = ((controlReg->event.config1 & 0xFFFFFFF00000000) | (val & 0xFFFFFFFF));
                break;

            case 1: //FLT_TC
                controlReg->event.config1 = ((controlReg->event.config1 & 0xFFFFF00FFFFFFFF) | ((val & 0xFF) << 32));
                break;
                
            case 2: //FLT_PG_SZ
                controlReg->event.config1 = ((controlReg->event.config1 & 0xFFFF0FFFFFFFFFF) | ((val & 0xF) << 40));
                break;
                
            case 3: //FLT_XFER_SZ
                controlReg->event.config1 = ((controlReg->event.config1 & 0xFF00FFFFFFFFFFF) | ((val & 0xFF) << 44));
                break;

            case 4: //FLT_ENG
                controlReg->event.config1 = ((controlReg->event.config1 & 0x00FFFFFFFFFFFFF) | ((val & 0xFF) << 52));
                break;

            default:
                break;
        }
    }
    operator uint64 () override
    {
        return lastValue;
    }
};

std::vector<int> enumeratePerfPMUs(const std::string & type, int max_id)
{
    auto getPerfPMUID = [](const std::string & type, int num)
    {
        int id = -1;
        std::ostringstream pmuIDPath(std::ostringstream::out);
        pmuIDPath << std::string("/sys/bus/event_source/devices/uncore_") << type;
        if (num != -1)
        {
            pmuIDPath << "_" << num;
        }
        pmuIDPath << "/type";
        const std::string pmuIDStr = readSysFS(pmuIDPath.str().c_str(), true);
        if (pmuIDStr.size())
        {
            id = std::atoi(pmuIDStr.c_str());
        }
        return id;
    };
    std::vector<int> ids;
    for (int i = -1; i < max_id; ++i)
    {
        int pmuID = getPerfPMUID(type, i);
        if (pmuID > 0)
        {
            DBG(2, type , " pmu id " , pmuID , " found");
            ids.push_back(pmuID);
        }
    }
    return ids;
}

#ifndef __clang_analyzer__

void populatePerfPMUs(unsigned socket_, const std::vector<int> & ids, std::vector<UncorePMU> & pmus, bool fixed, bool filter0, bool filter1)
{
    for (const auto & id : ids)
    {
        std::array<std::shared_ptr<PerfVirtualControlRegister>, 4> controlRegs = {
            std::make_shared<PerfVirtualControlRegister>(socket_, id),
                    std::make_shared<PerfVirtualControlRegister>(socket_, id),
                    std::make_shared<PerfVirtualControlRegister>(socket_, id),
                    std::make_shared<PerfVirtualControlRegister>(socket_, id)
        };
        std::shared_ptr<PerfVirtualCounterRegister> counterReg0 = std::make_shared<PerfVirtualCounterRegister>(controlRegs[0]);
        std::shared_ptr<PerfVirtualCounterRegister> counterReg1 = std::make_shared<PerfVirtualCounterRegister>(controlRegs[1]);
        std::shared_ptr<PerfVirtualCounterRegister> counterReg2 = std::make_shared<PerfVirtualCounterRegister>(controlRegs[2]);
        std::shared_ptr<PerfVirtualCounterRegister> counterReg3 = std::make_shared<PerfVirtualCounterRegister>(controlRegs[3]);
        std::shared_ptr<PerfVirtualControlRegister> fixedControlReg = std::make_shared<PerfVirtualControlRegister>(socket_, id, true);
        std::shared_ptr<PerfVirtualCounterRegister> fixedCounterReg = std::make_shared<PerfVirtualCounterRegister>(fixedControlReg);
        std::shared_ptr<PerfVirtualFilterRegister> filterReg0 = std::make_shared<PerfVirtualFilterRegister>(controlRegs, 0);
        std::shared_ptr<PerfVirtualFilterRegister> filterReg1 = std::make_shared<PerfVirtualFilterRegister>(controlRegs, 1);
        pmus.push_back(
            UncorePMU(
                std::make_shared<VirtualDummyRegister>(),
                controlRegs[0],
                controlRegs[1],
                controlRegs[2],
                controlRegs[3],
                counterReg0,
                counterReg1,
                counterReg2,
                counterReg3,
                fixed ? fixedControlReg : std::shared_ptr<HWRegister>(),
                fixed ? fixedCounterReg : std::shared_ptr<HWRegister>(),
                filter0 ? filterReg0 : std::shared_ptr<HWRegister>(),
                filter1 ? filterReg1 : std::shared_ptr<HWRegister>()
            )
        );
    }
}

void populatePerfPMUs(unsigned socket_, const std::vector<int>& ids, std::vector<UncorePMURef>& pmus, bool fixed, bool filter0, bool filter1)
{
    for (const auto& id : ids)
    {
        std::array<std::shared_ptr<PerfVirtualControlRegister>, 4> controlRegs = {
            std::make_shared<PerfVirtualControlRegister>(socket_, id),
                    std::make_shared<PerfVirtualControlRegister>(socket_, id),
                    std::make_shared<PerfVirtualControlRegister>(socket_, id),
                    std::make_shared<PerfVirtualControlRegister>(socket_, id)
        };
        std::shared_ptr<PerfVirtualCounterRegister> counterReg0 = std::make_shared<PerfVirtualCounterRegister>(controlRegs[0]);
        std::shared_ptr<PerfVirtualCounterRegister> counterReg1 = std::make_shared<PerfVirtualCounterRegister>(controlRegs[1]);
        std::shared_ptr<PerfVirtualCounterRegister> counterReg2 = std::make_shared<PerfVirtualCounterRegister>(controlRegs[2]);
        std::shared_ptr<PerfVirtualCounterRegister> counterReg3 = std::make_shared<PerfVirtualCounterRegister>(controlRegs[3]);
        std::shared_ptr<PerfVirtualControlRegister> fixedControlReg = std::make_shared<PerfVirtualControlRegister>(socket_, id, true);
        std::shared_ptr<PerfVirtualCounterRegister> fixedCounterReg = std::make_shared<PerfVirtualCounterRegister>(fixedControlReg);
        std::shared_ptr<PerfVirtualFilterRegister> filterReg0 = std::make_shared<PerfVirtualFilterRegister>(controlRegs, 0);
        std::shared_ptr<PerfVirtualFilterRegister> filterReg1 = std::make_shared<PerfVirtualFilterRegister>(controlRegs, 1);
        pmus.push_back(
            std::make_shared<UncorePMU>(
                std::make_shared<VirtualDummyRegister>(),
                controlRegs[0],
                controlRegs[1],
                controlRegs[2],
                controlRegs[3],
                counterReg0,
                counterReg1,
                counterReg2,
                counterReg3,
                fixed ? fixedControlReg : std::shared_ptr<HWRegister>(),
                fixed ? fixedCounterReg : std::shared_ptr<HWRegister>(),
                filter0 ? filterReg0 : std::shared_ptr<HWRegister>(),
                filter1 ? filterReg1 : std::shared_ptr<HWRegister>()
            )
        );
    }
}

#endif // __clang_analyzer__

std::vector<std::pair<int, uint32> > enumerateIDXPerfPMUs(const std::string & type, int max_id)
{
    uint32 numaNode=0xff;
    auto getPerfPMUID = [](const std::string & type, int num)
    {
        int id = -1;
        std::ostringstream pmuIDPath(std::ostringstream::out);
        pmuIDPath << std::string("/sys/bus/event_source/devices/") << type;
        if (num != -1)
        {
            pmuIDPath << num;
        }
        pmuIDPath << "/type";
        const std::string pmuIDStr = readSysFS(pmuIDPath.str().c_str(), true);
        if (pmuIDStr.size())
        {
            id = std::atoi(pmuIDStr.c_str());
        }
        return id;
    };

    //Enumurate IDX devices by linux sysfs scan
    std::vector<std::pair<int, uint32> > ids;
    for (int i = -1; i < max_id; ++i)
    {
        int pmuID = getPerfPMUID(type, i);
        if (pmuID > 0)
        {
            numaNode = 0xff;
            std::ostringstream devNumaNodePath(std::ostringstream::out);
            devNumaNodePath << std::string("/sys/bus/dsa/devices/") << type << i << "/numa_node";
            const std::string devNumaNodeStr = readSysFS(devNumaNodePath.str().c_str(), true);
            if (devNumaNodeStr.size())
            {
                numaNode = std::atoi(devNumaNodeStr.c_str());
                if (numaNode == (std::numeric_limits<uint32>::max)())
                {
                    numaNode = 0xff; //translate to special value for numa disable case.
                }
            }
            DBG(2, "IDX DEBUG: " , type , " pmu id " , pmuID , " found");
            DBG(2, "IDX DEBUG: numa node file path=" , devNumaNodePath.str().c_str()  , ", value=" , numaNode);
            ids.push_back(std::make_pair(pmuID, numaNode));
        }
    }
    
    return ids;
}

void populateIDXPerfPMUs(unsigned socket_, const std::vector<std::pair<int, uint32> > & ids, std::vector<IDX_PMU> & pmus)
{
    for (const auto & id : ids)
    {
        uint32 n_regs = SPR_IDX_ACCEL_COUNTER_MAX_NUM;

        std::vector<std::shared_ptr<HWRegister> > CounterControlRegs;
        std::vector<std::shared_ptr<HWRegister> > CounterValueRegs;
        std::vector<std::shared_ptr<HWRegister> > CounterFilterWQRegs, CounterFilterENGRegs, CounterFilterTCRegs, CounterFilterPGSZRegs, CounterFilterXFERSZRegs;

        for (size_t r = 0; r < n_regs; ++r)
        {
            auto CounterControlReg = std::make_shared<PerfVirtualControlRegister>(socket_, id.first);

            CounterControlRegs.push_back(CounterControlReg);
            CounterValueRegs.push_back(std::make_shared<PerfVirtualCounterRegister>(CounterControlReg));
            CounterFilterWQRegs.push_back(std::make_shared<IDXPerfVirtualFilterRegister>(CounterControlReg, 0));
            CounterFilterTCRegs.push_back(std::make_shared<IDXPerfVirtualFilterRegister>(CounterControlReg, 1));
            CounterFilterPGSZRegs.push_back(std::make_shared<IDXPerfVirtualFilterRegister>(CounterControlReg, 2));
            CounterFilterXFERSZRegs.push_back(std::make_shared<IDXPerfVirtualFilterRegister>(CounterControlReg, 3));
            CounterFilterENGRegs.push_back(std::make_shared<IDXPerfVirtualFilterRegister>(CounterControlReg, 4));
        }

        pmus.push_back(
            IDX_PMU(
                true,
                id.second,
                0xff,//No support of socket location in perf driver mode.
                std::make_shared<VirtualDummyRegister>(),
                std::make_shared<VirtualDummyRegister>(),
                std::make_shared<VirtualDummyRegister>(),
                CounterControlRegs,
                CounterValueRegs,
                CounterFilterWQRegs,
                CounterFilterENGRegs,
                CounterFilterTCRegs,
                CounterFilterPGSZRegs,
                CounterFilterXFERSZRegs
            ));
    }
}
#endif

void ServerUncorePMUs::initPerf(uint32 socket_, const PCM * /*pcm*/)
{
#ifdef PCM_USE_PERF
    auto imcIDs = enumeratePerfPMUs("imc", 100);
    auto m2mIDs = enumeratePerfPMUs("m2m", 100);
    auto haIDs = enumeratePerfPMUs("ha", 100);
    auto numMemControllers = std::max(m2mIDs.size(), haIDs.size());
    for (size_t i = 0; i < numMemControllers; ++i)
    {
        const int channelsPerController = imcIDs.size() / numMemControllers;
        num_imc_channels.push_back(channelsPerController);
    }
    populatePerfPMUs(socket_, imcIDs, imcPMUs, true);
    populatePerfPMUs(socket_, m2mIDs, m2mPMUs, false);
    populatePerfPMUs(socket_, enumeratePerfPMUs("qpi", 100), xpiPMUs, false);
    populatePerfPMUs(socket_, enumeratePerfPMUs("upi", 100), xpiPMUs, false);
    populatePerfPMUs(socket_, enumeratePerfPMUs("m3upi", 100), m3upiPMUs, false);
    populatePerfPMUs(socket_, haIDs, haPMUs, false);
#endif
}

size_t ServerUncorePMUs::getNumMCChannels(const uint32 controller) const
{
    if (controller < num_imc_channels.size())
    {
        return num_imc_channels[controller];
    }
    return 0;
}

ServerUncorePMUs::~ServerUncorePMUs()
{
}


void ServerUncorePMUs::programServerUncoreMemoryMetrics(const ServerUncoreMemoryMetrics & metrics, const int rankA, const int rankB)
{
    switch (metrics)
    {
        case PartialWrites:
        case Pmem:
        case PmemMemoryMode:
        case PmemMixedMode:
            break;
        default:
            std::cerr << "PCM Error: unknown memory metrics: " << metrics << "\n";
            return;
    }

    PCM * pcm = PCM::getInstance();
    uint32 MCCntConfig[4] = {0,0,0,0};
    uint32 EDCCntConfig[4] = {0,0,0,0};
    if(rankA < 0 && rankB < 0)
    {
        auto setEvents2_3 = [&](const uint32 partial_write_event) {
            auto noPmem = [&pcm]() -> bool
            {
                if (pcm->PMMTrafficMetricsAvailable() == false)
                {
                    std::cerr << "PCM Error: PMM/Pmem metrics are not available on your platform\n";
                    return true;
                }
                return false;
            };
            switch (metrics)
            {
                case PmemMemoryMode:
                case PmemMixedMode:
                    if (noPmem()) return false;
                    MCCntConfig[EventPosition::MM_MISS_CLEAN] = MC_CH_PCI_PMON_CTL_EVENT(0xd3) + MC_CH_PCI_PMON_CTL_UMASK(2); // monitor TAGCHK.MISS_CLEAN on counter 2
                    MCCntConfig[EventPosition::MM_MISS_DIRTY] = MC_CH_PCI_PMON_CTL_EVENT(0xd3) + MC_CH_PCI_PMON_CTL_UMASK(4); // monitor TAGCHK.MISS_DIRTY on counter 3
                    break;
                case Pmem:
                    if (noPmem()) return false;
                    MCCntConfig[EventPosition::PMM_READ] = MC_CH_PCI_PMON_CTL_EVENT(0xe3);  // monitor PMM_RDQ_REQUESTS on counter 2
                    MCCntConfig[EventPosition::PMM_WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0xe7); // monitor PMM_WPQ_REQUESTS on counter 3
                    break;
                case PartialWrites:
                    MCCntConfig[EventPosition::PARTIAL] = partial_write_event;
                    break;
                default:
                    std::cerr << "PCM Error: unknown metrics: " << metrics << "\n";
                    return false;
            }
            return true;
        };
        switch(cpu_family_model)
        {
        case PCM::KNL:
            MCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x03) + MC_CH_PCI_PMON_CTL_UMASK(1);  // monitor reads on counter 0: CAS.RD
            MCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x03) + MC_CH_PCI_PMON_CTL_UMASK(2);  // monitor reads on counter 1: CAS.WR
            EDCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x01) + MC_CH_PCI_PMON_CTL_UMASK(1);  // monitor reads on counter 0: RPQ
            EDCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x02) + MC_CH_PCI_PMON_CTL_UMASK(1);  // monitor reads on counter 1: WPQ
            break;
        case PCM::SNOWRIDGE:
        case PCM::ICX:
            if (metrics == PmemMemoryMode)
            {
                MCCntConfig[EventPosition::NM_HIT] = MC_CH_PCI_PMON_CTL_EVENT(0xd3) + MC_CH_PCI_PMON_CTL_UMASK(1);  // monitor reads on counter 0: UNC_M_TAGCHK.HIT
            }
            else
            {
                MCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x04) + MC_CH_PCI_PMON_CTL_UMASK(0x0f);  // monitor reads on counter 0: CAS_COUNT.RD
                MCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x04) + MC_CH_PCI_PMON_CTL_UMASK(0x30); // monitor writes on counter 1: CAS_COUNT.WR
            }
            if (setEvents2_3(MC_CH_PCI_PMON_CTL_EVENT(0x04) + MC_CH_PCI_PMON_CTL_UMASK(0x0c)) == false) // monitor partial writes on counter 2: CAS_COUNT.RD_UNDERFILL
            {
                return;
            }
            break;
        case PCM::SPR:
        case PCM::EMR:
            {
                EDCCntConfig[EventPosition::READ] = MCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x05) + MC_CH_PCI_PMON_CTL_UMASK(0xcf);  // monitor reads on counter 0: CAS_COUNT.RD
                EDCCntConfig[EventPosition::WRITE] = MCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x05) + MC_CH_PCI_PMON_CTL_UMASK(0xf0); // monitor writes on counter 1: CAS_COUNT.WR
            }
            if (setEvents2_3(MC_CH_PCI_PMON_CTL_EVENT(0x05) + MC_CH_PCI_PMON_CTL_UMASK(0xcc)) == false) // monitor partial writes on counter 2: CAS_COUNT.RD_UNDERFILL
            {
                return;
            }
            break;
        case PCM::GNR:
        case PCM::GNR_D:
        case PCM::GRR:
        case PCM::SRF:
            if (metrics == PmemMemoryMode)
            {
                std::cerr << "PCM Error: PMM/Pmem metrics are not available on your platform\n";
                return;
            }
            else
            {
                MCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x05) + MC_CH_PCI_PMON_CTL_UMASK(0xcf);  // monitor reads on counter 0: CAS_COUNT_SCH0.RD
                MCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x05) + MC_CH_PCI_PMON_CTL_UMASK(0xf0); // monitor writes on counter 1: CAS_COUNT_SCH0.WR
                MCCntConfig[EventPosition::READ2] = MC_CH_PCI_PMON_CTL_EVENT(0x06) + MC_CH_PCI_PMON_CTL_UMASK(0xcf);  // monitor reads on counter 2: CAS_COUNT_SCH1.RD
                MCCntConfig[EventPosition::WRITE2] = MC_CH_PCI_PMON_CTL_EVENT(0x06) + MC_CH_PCI_PMON_CTL_UMASK(0xf0); // monitor writes on counter 3: CAS_COUNT_SCH1.WR
            }
            break;
        default:
            MCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x04) + MC_CH_PCI_PMON_CTL_UMASK(3);  // monitor reads on counter 0: CAS_COUNT.RD
            MCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x04) + MC_CH_PCI_PMON_CTL_UMASK(12); // monitor writes on counter 1: CAS_COUNT.WR
            if (setEvents2_3(MC_CH_PCI_PMON_CTL_EVENT(0x04) + MC_CH_PCI_PMON_CTL_UMASK(2)) == false) // monitor partial writes on counter 2: CAS_COUNT.RD_UNDERFILL
            {
                return;
            }
        }
    } else {
        if (rankA < 0 || rankA > 7)
        {
            std::cerr << "PCM Error: invalid rankA value: " << rankA << "\n";
            return;
        }
        switch(cpu_family_model)
        {
        case PCM::IVYTOWN:
            MCCntConfig[EventPosition::READ_RANK_A] = MC_CH_PCI_PMON_CTL_EVENT((0xb0 + rankA)) + MC_CH_PCI_PMON_CTL_UMASK(0xff); // RD_CAS_RANK(rankA) all banks
            MCCntConfig[EventPosition::WRITE_RANK_A] = MC_CH_PCI_PMON_CTL_EVENT((0xb8 + rankA)) + MC_CH_PCI_PMON_CTL_UMASK(0xff); // WR_CAS_RANK(rankA) all banks
            if (rankB >= 0 && rankB <= 7)
            {
                MCCntConfig[EventPosition::READ_RANK_B] = MC_CH_PCI_PMON_CTL_EVENT((0xb0 + rankB)) + MC_CH_PCI_PMON_CTL_UMASK(0xff); // RD_CAS_RANK(rankB) all banks
                MCCntConfig[EventPosition::WRITE_RANK_B] = MC_CH_PCI_PMON_CTL_EVENT((0xb8 + rankB)) + MC_CH_PCI_PMON_CTL_UMASK(0xff); // WR_CAS_RANK(rankB) all banks
            }
            break;
        case PCM::HASWELLX:
        case PCM::BDX_DE:
        case PCM::BDX:
        case PCM::SKX:
            MCCntConfig[EventPosition::READ_RANK_A] = MC_CH_PCI_PMON_CTL_EVENT((0xb0 + rankA)) + MC_CH_PCI_PMON_CTL_UMASK(16); // RD_CAS_RANK(rankA) all banks
            MCCntConfig[EventPosition::WRITE_RANK_A] = MC_CH_PCI_PMON_CTL_EVENT((0xb8 + rankA)) + MC_CH_PCI_PMON_CTL_UMASK(16); // WR_CAS_RANK(rankA) all banks
            if (rankB >= 0 && rankB <= 7)
            {
                MCCntConfig[EventPosition::READ_RANK_B] = MC_CH_PCI_PMON_CTL_EVENT((0xb0 + rankB)) + MC_CH_PCI_PMON_CTL_UMASK(16); // RD_CAS_RANK(rankB) all banks
                MCCntConfig[EventPosition::WRITE_RANK_B] = MC_CH_PCI_PMON_CTL_EVENT((0xb8 + rankB)) + MC_CH_PCI_PMON_CTL_UMASK(16); // WR_CAS_RANK(rankB) all banks
            }
            break;
        case PCM::KNL:
            MCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x03) + MC_CH_PCI_PMON_CTL_UMASK(1);  // monitor reads on counter 0: CAS.RD
            MCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x03) + MC_CH_PCI_PMON_CTL_UMASK(2);  // monitor reads on counter 1: CAS.WR
            EDCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x01) + MC_CH_PCI_PMON_CTL_UMASK(1);  // monitor reads on counter 0: RPQ
            EDCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x02) + MC_CH_PCI_PMON_CTL_UMASK(1);  // monitor reads on counter 1: WPQ
            break;
        default:
            std::cerr << "PCM Error: your processor " << pcm->getCPUBrandString() << " ID 0x" << std::hex << cpu_family_model << std::dec << " does not support the required performance events \n";
            return;
        }
    }
    programIMC(MCCntConfig);
    if (pcm->HBMmemoryTrafficMetricsAvailable()) programEDC(EDCCntConfig);

    programM2M();

    xpiPMUs.clear(); // no QPI events used
    return;
}

void ServerUncorePMUs::program()
{
    PCM * pcm = PCM::getInstance();
    uint32 MCCntConfig[4] = {0, 0, 0, 0};
    uint32 EDCCntConfig[4] = {0, 0, 0, 0};
    switch(cpu_family_model)
    {
    case PCM::KNL:
        MCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x03) + MC_CH_PCI_PMON_CTL_UMASK(1);  // monitor reads on counter 0: CAS_COUNT.RD
        MCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x03) + MC_CH_PCI_PMON_CTL_UMASK(2); // monitor writes on counter 1: CAS_COUNT.WR
        EDCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x01) + MC_CH_PCI_PMON_CTL_UMASK(1);  // monitor reads on counter 0: RPQ
        EDCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x02) + MC_CH_PCI_PMON_CTL_UMASK(1);  // monitor reads on counter 1: WPQ
        break;
    case PCM::SNOWRIDGE:
    case PCM::ICX:
        MCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x04) + MC_CH_PCI_PMON_CTL_UMASK(0x0f);  // monitor reads on counter 0: CAS_COUNT.RD
        MCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x04) + MC_CH_PCI_PMON_CTL_UMASK(0x30); // monitor writes on counter 1: CAS_COUNT.WR
        break;
    case PCM::SPR:
    case PCM::EMR:
        EDCCntConfig[EventPosition::READ] = MCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x05) + MC_CH_PCI_PMON_CTL_UMASK(0xcf);  // monitor reads on counter 0: CAS_COUNT.RD
        EDCCntConfig[EventPosition::WRITE] = MCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x05) + MC_CH_PCI_PMON_CTL_UMASK(0xf0); // monitor writes on counter 1: CAS_COUNT.WR
        break;
    case PCM::GNR:
    case PCM::GNR_D:
    case PCM::GRR:
    case PCM::SRF:
        MCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x05) + MC_CH_PCI_PMON_CTL_UMASK(0xcf);  // monitor reads on counter 0: CAS_COUNT_SCH0.RD
        MCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x05) + MC_CH_PCI_PMON_CTL_UMASK(0xf0); // monitor writes on counter 1: CAS_COUNT_SCH0.WR
        MCCntConfig[EventPosition::READ2] = MC_CH_PCI_PMON_CTL_EVENT(0x06) + MC_CH_PCI_PMON_CTL_UMASK(0xcf);  // monitor reads on counter 2: CAS_COUNT_SCH1.RD
        MCCntConfig[EventPosition::WRITE2] = MC_CH_PCI_PMON_CTL_EVENT(0x06) + MC_CH_PCI_PMON_CTL_UMASK(0xf0); // monitor writes on counter 3: CAS_COUNT_SCH1.WR
        break;
    default:
        MCCntConfig[EventPosition::READ] = MC_CH_PCI_PMON_CTL_EVENT(0x04) + MC_CH_PCI_PMON_CTL_UMASK(3);  // monitor reads on counter 0: CAS_COUNT.RD
        MCCntConfig[EventPosition::WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0x04) + MC_CH_PCI_PMON_CTL_UMASK(12); // monitor writes on counter 1: CAS_COUNT.WR
    }

    if (pcm->PMMTrafficMetricsAvailable())
    {
        MCCntConfig[EventPosition::PMM_READ] = MC_CH_PCI_PMON_CTL_EVENT(0xe3); // monitor PMM_RDQ_REQUESTS on counter 2
        MCCntConfig[EventPosition::PMM_WRITE] = MC_CH_PCI_PMON_CTL_EVENT(0xe7); // monitor PMM_WPQ_REQUESTS on counter 3
    }

    programIMC(MCCntConfig);
    if (pcm->HBMmemoryTrafficMetricsAvailable()) programEDC(EDCCntConfig);

    programM2M();

    uint32 event[4];
    if (PCM::hasUPI(cpu_family_model))
    {
        // monitor TxL0_POWER_CYCLES
        event[0] = Q_P_PCI_PMON_CTL_EVENT(0x26);
        // monitor RxL_FLITS.ALL_DATA on counter 1
        event[1] = Q_P_PCI_PMON_CTL_EVENT(0x03) + Q_P_PCI_PMON_CTL_UMASK(0xF);
        // monitor TxL_FLITS.NON_DATA+ALL_DATA on counter 2
        event[2] = Q_P_PCI_PMON_CTL_EVENT(0x02) + Q_P_PCI_PMON_CTL_UMASK((0x97|0x0F));
        // monitor UPI CLOCKTICKS
        event[ServerUncoreCounterState::EventPosition::xPI_CLOCKTICKS] = Q_P_PCI_PMON_CTL_EVENT(0x01);
    }
    else
    {
        // monitor DRS data received on counter 0: RxL_FLITS_G1.DRS_DATA
        event[0] = Q_P_PCI_PMON_CTL_EVENT(0x02) + Q_P_PCI_PMON_CTL_EVENT_EXT + Q_P_PCI_PMON_CTL_UMASK(8);
        // monitor NCB data received on counter 1: RxL_FLITS_G2.NCB_DATA
        event[1] = Q_P_PCI_PMON_CTL_EVENT(0x03) + Q_P_PCI_PMON_CTL_EVENT_EXT + Q_P_PCI_PMON_CTL_UMASK(4);
        // monitor outgoing data+nondata flits on counter 2: TxL_FLITS_G0.DATA + TxL_FLITS_G0.NON_DATA
        event[2] = Q_P_PCI_PMON_CTL_EVENT(0x00) + Q_P_PCI_PMON_CTL_UMASK(6);
        // monitor QPI clocks
        event[ServerUncoreCounterState::EventPosition::xPI_CLOCKTICKS] = Q_P_PCI_PMON_CTL_EVENT(0x14); // QPI clocks (CLOCKTICKS)
    }
    programXPI(event);
    programHA();
}

void ServerUncorePMUs::programXPI(const uint32 * event)
{
    const uint32 extra = PCM::hasUPI(cpu_family_model) ? UNC_PMON_UNIT_CTL_RSV : UNC_PMON_UNIT_CTL_FRZ_EN;
    for (uint32 i = 0; i < (uint32)xpiPMUs.size(); ++i)
    {
        // QPI LL PMU

        if (xpiPMUs[i].initFreeze(extra,
            "       Please see BIOS options to enable the export of QPI/UPI performance monitoring devices (devices 8 and 9: function 2).\n")
            == false)
        {
            std::cout << "Link " << (i + 1) << " is disabled\n";
            continue;
        }

        PCM::program(xpiPMUs[i], event, event + 4, extra);
    }
    cleanupQPIHandles();
}

void ServerUncorePMUs::cleanupQPIHandles()
{
    for(auto i = xpiPMUs.begin(); i != xpiPMUs.end(); ++i)
    {
        if (!i->valid())
        {
            xpiPMUs.erase(i);
            cleanupQPIHandles();
            return;
        }
    }
}

void ServerUncorePMUs::cleanupPMUs()
{
    for (auto & pmu : xpiPMUs)
    {
        pmu.cleanup();
    }
    for (auto & pmu : imcPMUs)
    {
        pmu.cleanup();
    }
    for (auto & pmu : edcPMUs)
    {
        pmu.cleanup();
    }
    for (auto & pmu : m2mPMUs)
    {
        pmu.cleanup();
    }
    for (auto & pmu : haPMUs)
    {
        pmu.cleanup();
    }
}

uint64 ServerUncorePMUs::getImcReads()
{
    return getImcReadsForChannels((uint32)0, (uint32)imcPMUs.size());
}

uint64 ServerUncorePMUs::getImcReadsForController(uint32 controller)
{
    assert(controller < num_imc_channels.size());
    uint32 beginChannel = 0;
    for (uint32 i = 0; i < controller; ++i)
    {
        beginChannel += num_imc_channels[i];
    }
    const uint32 endChannel = beginChannel + num_imc_channels[controller];
    return getImcReadsForChannels(beginChannel, endChannel);
}

uint64 ServerUncorePMUs::getImcReadsForChannels(uint32 beginChannel, uint32 endChannel)
{
    uint64 result = 0;
    for (uint32 i = beginChannel; i < endChannel && i < imcPMUs.size(); ++i)
    {
        result += getMCCounter(i, EventPosition::READ);
        switch (cpu_family_model)
        {
            case PCM::GNR:
            case PCM::GNR_D:
            case PCM::GRR:
            case PCM::SRF:
                result += getMCCounter(i, EventPosition::READ2);
                break;
        }
    }
    return result;
}

uint64 ServerUncorePMUs::getImcWrites()
{
    uint64 result = 0;
    for (uint32 i = 0; i < (uint32)imcPMUs.size(); ++i)
    {
        result += getMCCounter(i, EventPosition::WRITE);
        switch (cpu_family_model)
        {
            case PCM::GNR:
            case PCM::GNR_D:
            case PCM::GRR:
            case PCM::SRF:
                result += getMCCounter(i, EventPosition::WRITE2);
                break;
        }
    }

    return result;
}


uint64 ServerUncorePMUs::getNMHits()
{
    uint64 result = 0;
    for (uint32 i = 0; i < (uint32)m2mPMUs.size(); ++i)
    {
        result += getM2MCounter(i, EventPosition::NM_HIT);
    }

    return result;
}

uint64 ServerUncorePMUs::getNMMisses()
{
    uint64 result = 0;
    for (uint32 i = 0; i < (uint32)m2mPMUs.size(); ++i)
    {
        result += getM2MCounter(i, EventPosition::MM_MISS_CLEAN) + getM2MCounter(i, EventPosition::MM_MISS_DIRTY);        
    }

    return result;
}


uint64 ServerUncorePMUs::getPMMReads()
{
    uint64 result = 0;
    for (uint32 i = 0; i < (uint32)m2mPMUs.size(); ++i)
    {
        result += getM2MCounter(i, EventPosition::PMM_READ);
    }
    return result;
}

uint64 ServerUncorePMUs::getPMMWrites()
{
    uint64 result = 0;
    for (uint32 i = 0; i < (uint32)m2mPMUs.size(); ++i)
    {
        result += getM2MCounter(i, EventPosition::PMM_WRITE);
    }
    return result;
}

uint64 ServerUncorePMUs::getEdcReads()
{
    uint64 result = 0;

    for (auto & pmu: edcPMUs)
    {
        result += *pmu.counterValue[EventPosition::READ];
    }

    return result;
}

uint64 ServerUncorePMUs::getEdcWrites()
{
    uint64 result = 0;

    for (auto & pmu : edcPMUs)
    {
        result += *pmu.counterValue[EventPosition::WRITE];
    }

    return result;
}

uint64 ServerUncorePMUs::getIncomingDataFlits(uint32 port)
{
    uint64 drs = 0, ncb = 0;

    if (port >= (uint32)xpiPMUs.size())
        return 0;

    if (PCM::hasUPI(cpu_family_model) == false)
    {
        drs = *xpiPMUs[port].counterValue[0];
    }
    ncb = *xpiPMUs[port].counterValue[1];

    return drs + ncb;
}

uint64 ServerUncorePMUs::getOutgoingFlits(uint32 port)
{
    return getQPILLCounter(port,2);
}

uint64 ServerUncorePMUs::getUPIL0TxCycles(uint32 port)
{
    if (PCM::hasUPI(cpu_family_model))
        return getQPILLCounter(port,0);
    return 0;
}

void ServerUncorePMUs::program_power_metrics(int mc_profile)
{
    uint32 xPIEvents[4] = { 0,0,0,0 };
    xPIEvents[ServerUncoreCounterState::EventPosition::xPI_TxL0P_POWER_CYCLES] = (uint32)Q_P_PCI_PMON_CTL_EVENT((PCM::hasUPI(cpu_family_model) ? 0x27 : 0x0D)); // L0p Tx Cycles (TxL0P_POWER_CYCLES)
    xPIEvents[ServerUncoreCounterState::EventPosition::xPI_L1_POWER_CYCLES] = (uint32)Q_P_PCI_PMON_CTL_EVENT((PCM::hasUPI(cpu_family_model) ? 0x21 : 0x12)); // L1 Cycles (L1_POWER_CYCLES)
    xPIEvents[ServerUncoreCounterState::EventPosition::xPI_CLOCKTICKS] = (uint32)Q_P_PCI_PMON_CTL_EVENT((PCM::hasUPI(cpu_family_model) ? 0x01 : 0x14)); // QPI/UPI clocks (CLOCKTICKS)

    programXPI(xPIEvents);

    uint32 MCCntConfig[4] = {0,0,0,0};
    unsigned int UNC_M_POWER_CKE_CYCLES = 0x83;
    switch (cpu_family_model)
    {
        case PCM::ICX:
        case PCM::SNOWRIDGE:
        case PCM::SPR:
        case PCM::EMR:
        case PCM::SRF:
        case PCM::GNR:
        case PCM::GNR_D:
            UNC_M_POWER_CKE_CYCLES = 0x47;
            break;
    }
    unsigned int UNC_M_POWER_CHANNEL_PPD_CYCLES = 0x85;
    switch (cpu_family_model)
    {
        case PCM::SRF:
        case PCM::GNR:
        case PCM::GNR_D:
            UNC_M_POWER_CHANNEL_PPD_CYCLES = 0x88;
            break;
    }
    unsigned int UNC_M_SELF_REFRESH_ENTER_SUCCESS_CYCLES_UMASK = 0;
    switch (cpu_family_model)
    {
        case PCM::SRF:
        case PCM::GNR:
        case PCM::GNR_D:
            UNC_M_SELF_REFRESH_ENTER_SUCCESS_CYCLES_UMASK = 0x01;
            break;
    }

    switch(mc_profile)
    {
        case 0: // POWER_CKE_CYCLES.RANK0 and POWER_CKE_CYCLES.RANK1
            MCCntConfig[0] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(1) + MC_CH_PCI_PMON_CTL_INVERT + MC_CH_PCI_PMON_CTL_THRESH(1);
            MCCntConfig[1] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(1) + MC_CH_PCI_PMON_CTL_THRESH(1) + MC_CH_PCI_PMON_CTL_EDGE_DET;
            MCCntConfig[2] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(2) + MC_CH_PCI_PMON_CTL_INVERT + MC_CH_PCI_PMON_CTL_THRESH(1);
            MCCntConfig[3] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(2) + MC_CH_PCI_PMON_CTL_THRESH(1) + MC_CH_PCI_PMON_CTL_EDGE_DET;
            break;
        case  1: // POWER_CKE_CYCLES.RANK2 and POWER_CKE_CYCLES.RANK3
            MCCntConfig[0] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(4) + MC_CH_PCI_PMON_CTL_INVERT + MC_CH_PCI_PMON_CTL_THRESH(1);
            MCCntConfig[1] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(4) + MC_CH_PCI_PMON_CTL_THRESH(1) + MC_CH_PCI_PMON_CTL_EDGE_DET;
            MCCntConfig[2] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(8) + MC_CH_PCI_PMON_CTL_INVERT + MC_CH_PCI_PMON_CTL_THRESH(1);
            MCCntConfig[3] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(8) + MC_CH_PCI_PMON_CTL_THRESH(1) + MC_CH_PCI_PMON_CTL_EDGE_DET;
            break;
        case 2: // POWER_CKE_CYCLES.RANK4 and POWER_CKE_CYCLES.RANK5
            MCCntConfig[0] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(0x10) + MC_CH_PCI_PMON_CTL_INVERT + MC_CH_PCI_PMON_CTL_THRESH(1);
            MCCntConfig[1] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(0x10) + MC_CH_PCI_PMON_CTL_THRESH(1) + MC_CH_PCI_PMON_CTL_EDGE_DET;
            MCCntConfig[2] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(0x20) + MC_CH_PCI_PMON_CTL_INVERT + MC_CH_PCI_PMON_CTL_THRESH(1);
            MCCntConfig[3] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(0x20) + MC_CH_PCI_PMON_CTL_THRESH(1) + MC_CH_PCI_PMON_CTL_EDGE_DET;
            break;
        case 3: // POWER_CKE_CYCLES.RANK6 and POWER_CKE_CYCLES.RANK7
            MCCntConfig[0] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(0x40) + MC_CH_PCI_PMON_CTL_INVERT + MC_CH_PCI_PMON_CTL_THRESH(1);
            MCCntConfig[1] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(0x40) + MC_CH_PCI_PMON_CTL_THRESH(1) + MC_CH_PCI_PMON_CTL_EDGE_DET;
            MCCntConfig[2] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(0x80) + MC_CH_PCI_PMON_CTL_INVERT + MC_CH_PCI_PMON_CTL_THRESH(1);
            MCCntConfig[3] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CKE_CYCLES) + MC_CH_PCI_PMON_CTL_UMASK(0x80) + MC_CH_PCI_PMON_CTL_THRESH(1) + MC_CH_PCI_PMON_CTL_EDGE_DET;
           break;
        case 4: // POWER_SELF_REFRESH
            MCCntConfig[0] = MC_CH_PCI_PMON_CTL_EVENT(0x43) + MC_CH_PCI_PMON_CTL_UMASK(UNC_M_SELF_REFRESH_ENTER_SUCCESS_CYCLES_UMASK);
            MCCntConfig[1] = MC_CH_PCI_PMON_CTL_EVENT(0x43) + MC_CH_PCI_PMON_CTL_UMASK(UNC_M_SELF_REFRESH_ENTER_SUCCESS_CYCLES_UMASK) + MC_CH_PCI_PMON_CTL_THRESH(1) + MC_CH_PCI_PMON_CTL_EDGE_DET;
            MCCntConfig[2] = MC_CH_PCI_PMON_CTL_EVENT(UNC_M_POWER_CHANNEL_PPD_CYCLES);
            break;
    }

    programIMC(MCCntConfig);
}

void enableAndResetMCFixedCounter(UncorePMU& pmu)
{
    // enable fixed counter (DRAM clocks)
    *pmu.fixedCounterControl = MC_CH_PCI_PMON_FIXED_CTL_EN;

    // reset it
    *pmu.fixedCounterControl = MC_CH_PCI_PMON_FIXED_CTL_EN + MC_CH_PCI_PMON_FIXED_CTL_RST;
}

void ServerUncorePMUs::programIMC(const uint32 * MCCntConfig)
{
    const uint32 extraIMC = (cpu_family_model == PCM::SKX)?UNC_PMON_UNIT_CTL_RSV:UNC_PMON_UNIT_CTL_FRZ_EN;

    for (uint32 i = 0; i < (uint32)imcPMUs.size(); ++i)
    {
        // imc PMU
        imcPMUs[i].initFreeze(extraIMC);

        enableAndResetMCFixedCounter(imcPMUs[i]);

        PCM::program(imcPMUs[i], MCCntConfig, MCCntConfig + 4, extraIMC);
    }
}

void ServerUncorePMUs::programEDC(const uint32 * EDCCntConfig)
{
    for (uint32 i = 0; i < (uint32)edcPMUs.size(); ++i)
    {
        edcPMUs[i].initFreeze(UNC_PMON_UNIT_CTL_FRZ_EN);

        // HBM clocks enabled by default
        if (cpu_family_model == PCM::KNL)
        {
            *edcPMUs[i].fixedCounterControl = EDC_CH_PCI_PMON_FIXED_CTL_EN;
        }
        else
        {
            enableAndResetMCFixedCounter(edcPMUs[i]);
        }

        PCM::program(edcPMUs[i], EDCCntConfig, EDCCntConfig + 4, UNC_PMON_UNIT_CTL_FRZ_EN);
    }
}

void ServerUncorePMUs::programM2M()
{
    uint64 cfg[4] = {0, 0, 0, 0};
    switch (cpu_family_model)
    {
    case PCM::SPR:
    case PCM::EMR:
        cfg[EventPosition::M2M_CLOCKTICKS] = M2M_PCI_PMON_CTL_EVENT(0x01);                         // CLOCKTICKS
        cfg[EventPosition::PMM_READ] = M2M_PCI_PMON_CTL_EVENT(0x24) + M2M_PCI_PMON_CTL_UMASK(0x20) + UNC_PMON_CTL_UMASK_EXT(0x03);  // UNC_M2M_IMC_READS.TO_PMM
        cfg[EventPosition::PMM_WRITE] = M2M_PCI_PMON_CTL_EVENT(0x25) + M2M_PCI_PMON_CTL_UMASK(0x80) + UNC_PMON_CTL_UMASK_EXT(0x18); // UNC_M2M_IMC_WRITES.TO_PMM
        break;
    case PCM::ICX:
        cfg[EventPosition::NM_HIT] = M2M_PCI_PMON_CTL_EVENT(0x2c) + M2M_PCI_PMON_CTL_UMASK(3);    // UNC_M2M_TAG_HIT.NM_DRD_HIT_* events (CLEAN | DIRTY)
        cfg[EventPosition::M2M_CLOCKTICKS] = 0;                                                      // CLOCKTICKS
        cfg[EventPosition::PMM_READ] = M2M_PCI_PMON_CTL_EVENT(0x37) + M2M_PCI_PMON_CTL_UMASK(0x20) + UNC_PMON_CTL_UMASK_EXT(0x07);  // UNC_M2M_IMC_READS.TO_PMM
        cfg[EventPosition::PMM_WRITE] = M2M_PCI_PMON_CTL_EVENT(0x38) + M2M_PCI_PMON_CTL_UMASK(0x80) + UNC_PMON_CTL_UMASK_EXT(0x1C); // UNC_M2M_IMC_WRITES.TO_PMM
        break;
    case PCM::GNR:
    case PCM::GNR_D:
    case PCM::SRF:
        cfg[EventPosition::NM_HIT] = M2M_PCI_PMON_CTL_EVENT(0x1F) + M2M_PCI_PMON_CTL_UMASK(0x0F);    // UNC_B2CMI_TAG_HIT.ALL
        cfg[EventPosition::M2M_CLOCKTICKS] = 0;                                                      // CLOCKTICKS
        cfg[EventPosition::MM_MISS_CLEAN] = M2M_PCI_PMON_CTL_EVENT(0x4B) + M2M_PCI_PMON_CTL_UMASK(0x05);  // UNC_B2CMI_TAG_MISS.CLEAN
        cfg[EventPosition::MM_MISS_DIRTY] = M2M_PCI_PMON_CTL_EVENT(0x4B) + M2M_PCI_PMON_CTL_UMASK(0x0A);  // UNC_B2CMI_TAG_MISS.DIRTY
        break;
    default:
        cfg[EventPosition::NM_HIT] = M2M_PCI_PMON_CTL_EVENT(0x2c) + M2M_PCI_PMON_CTL_UMASK(3);    // UNC_M2M_TAG_HIT.NM_DRD_HIT_* events (CLEAN | DIRTY)
        cfg[EventPosition::M2M_CLOCKTICKS] = 0;                                                      // CLOCKTICKS
        cfg[EventPosition::PMM_READ] = M2M_PCI_PMON_CTL_EVENT(0x37) + M2M_PCI_PMON_CTL_UMASK(0x8);  // UNC_M2M_IMC_READS.TO_PMM
        cfg[EventPosition::PMM_WRITE] = M2M_PCI_PMON_CTL_EVENT(0x38) + M2M_PCI_PMON_CTL_UMASK(0x20); // UNC_M2M_IMC_WRITES.TO_PMM
    }
    programM2M(cfg);
}

void ServerUncorePMUs::programM2M(const uint64* M2MCntConfig)
{
    {
        int i = 0;
        for (auto & pmu : m2mPMUs)
        {
            DBG(3, "programming m2m pmu ", i++ );
            pmu.initFreeze(UNC_PMON_UNIT_CTL_RSV);
            PCM::program(pmu, M2MCntConfig, M2MCntConfig + 4, UNC_PMON_UNIT_CTL_RSV);
        }
    }
}

void ServerUncorePMUs::programM3UPI(const uint32* M3UPICntConfig)
{
    {
        for (auto& pmu : m3upiPMUs)
        {
            pmu.initFreeze(UNC_PMON_UNIT_CTL_RSV);
            PCM::program(pmu, M3UPICntConfig, M3UPICntConfig + 4, UNC_PMON_UNIT_CTL_RSV);
        }
    }
}

void ServerUncorePMUs::programHA(const uint32 * config)
{
    for (auto & pmu : haPMUs)
    {
        pmu.initFreeze(UNC_PMON_UNIT_CTL_RSV);
        PCM::program(pmu, config, config + 4, UNC_PMON_UNIT_CTL_RSV);
    }
}

uint64 ServerUncorePMUs::getHARequests()
{
    uint64 result = 0;
    for (auto & pmu: haPMUs)
    {
        result += *pmu.counterValue[PCM::EventPosition::REQUESTS_ALL];
    }
    return result;
}

uint64 ServerUncorePMUs::getHALocalRequests()
{
    uint64 result = 0;
    for (auto & pmu: haPMUs)
    {
        result += *pmu.counterValue[PCM::EventPosition::REQUESTS_LOCAL];
    }
    return result;
}

void ServerUncorePMUs::programHA()
{
	uint32 config[4];
	config[0] = 0;
	config[1] = 0;
#ifdef PCM_HA_REQUESTS_READS_ONLY
	// HA REQUESTS READ: LOCAL + REMOTE
	config[PCM::EventPosition::REQUESTS_ALL] = HA_PCI_PMON_CTL_EVENT(0x01) + HA_PCI_PMON_CTL_UMASK((1 + 2));
	// HA REQUESTS READ: LOCAL ONLY
	config[PCM::EventPosition::REQUESTS_LOCAL] = HA_PCI_PMON_CTL_EVENT(0x01) + HA_PCI_PMON_CTL_UMASK((1));
#else
	// HA REQUESTS READ+WRITE+REMOTE+LOCAL
	config[PCM::EventPosition::REQUESTS_ALL] = HA_PCI_PMON_CTL_EVENT(0x01) + HA_PCI_PMON_CTL_UMASK((1 + 2 + 4 + 8));
	// HA REQUESTS READ+WRITE (LOCAL only)
	config[PCM::EventPosition::REQUESTS_LOCAL] = HA_PCI_PMON_CTL_EVENT(0x01) + HA_PCI_PMON_CTL_UMASK((1 + 4));
#endif
	programHA(config);
}

void ServerUncorePMUs::freezeCounters()
{
    for (auto& pmuVector : allPMUs)
    {
        for (auto& pmu : *pmuVector)
        {
            pmu.freeze((cpu_family_model == PCM::SKX) ? UNC_PMON_UNIT_CTL_RSV : UNC_PMON_UNIT_CTL_FRZ_EN);
        }
    }
}

void ServerUncorePMUs::unfreezeCounters()
{
    for (auto& pmuVector : allPMUs)
    {
        for (auto& pmu : *pmuVector)
        {
            pmu.unfreeze((cpu_family_model == PCM::SKX) ? UNC_PMON_UNIT_CTL_RSV : UNC_PMON_UNIT_CTL_FRZ_EN);
        }
    }
}

uint64 ServerUncorePMUs::getQPIClocks(uint32 port)
{
    return getQPILLCounter(port, ServerUncoreCounterState::EventPosition::xPI_CLOCKTICKS);
}

uint64 ServerUncorePMUs::getQPIL0pTxCycles(uint32 port)
{
    return getQPILLCounter(port, ServerUncoreCounterState::EventPosition::xPI_TxL0P_POWER_CYCLES);
}

uint64 ServerUncorePMUs::getQPIL1Cycles(uint32 port)
{
    return getQPILLCounter(port, ServerUncoreCounterState::EventPosition::xPI_L1_POWER_CYCLES);
}

uint64 ServerUncorePMUs::getDRAMClocks(uint32 channel)
{
    uint64 result = 0;

    if (channel < (uint32)imcPMUs.size())
        result = *(imcPMUs[channel].fixedCounterValue);

    DBG(3, "DRAMClocks on channel " , channel , " = " , result);
    return result;
}

uint64 ServerUncorePMUs::getHBMClocks(uint32 channel)
{
    uint64 result = 0;

    if (channel < (uint32)edcPMUs.size())
        result = *edcPMUs[channel].fixedCounterValue;

    DBG(3, "HBMClocks on EDC" , channel , " = " , result);
    return result;
}

uint64 ServerUncorePMUs::getPMUCounter(std::vector<UncorePMU> & pmu, const uint32 id, const uint32 counter)
{
    uint64 result = 0;

    if (id < (uint32)pmu.size() && counter < 4 && pmu[id].counterValue[counter].get() != nullptr)
    {
        result = *(pmu[id].counterValue[counter]);
    }
    else
    {
        DBG(3, "Invalid ServerUncorePMUs::getPMUCounter(" , id , ", " , counter , ")");
    }
    DBG(3, "ServerUncorePMUs::getPMUCounter(" , id , ", " , counter , ") = " , result);
    return result;
}

uint64 ServerUncorePMUs::getHACounter(uint32 id, uint32 counter)
{
    return getPMUCounter(haPMUs, id, counter);
}

uint64 ServerUncorePMUs::getMCCounter(uint32 channel, uint32 counter)
{
    return getPMUCounter(imcPMUs, channel, counter);
}

uint64 ServerUncorePMUs::getEDCCounter(uint32 channel, uint32 counter)
{
    return getPMUCounter(edcPMUs, channel, counter);
}

uint64 ServerUncorePMUs::getM2MCounter(uint32 box, uint32 counter)
{
    return getPMUCounter(m2mPMUs, box, counter);
}

uint64 ServerUncorePMUs::getQPILLCounter(uint32 port, uint32 counter)
{
    return getPMUCounter(xpiPMUs, port, counter);
}

uint64 ServerUncorePMUs::getM3UPICounter(uint32 port, uint32 counter)
{
    DBG(3, "ServerUncorePMUs::getM3UPICounter(" , port , ", " , counter , ") = " , getPMUCounter(m3upiPMUs, port, counter));
    return getPMUCounter(m3upiPMUs, port, counter);
}

void ServerUncorePMUs::enableJKTWorkaround(bool enable)
{
    {
        PciHandleType reg(groupnr,iMCbus,14,0);
        uint32 value = 0;
        reg.read32(0x84, &value);
        if(enable)
            value |= 2;
        else
            value &= (~2);
        reg.write32(0x84, value);
    }
    {
        PciHandleType reg(groupnr,iMCbus,8,0);
        uint32 value = 0;
        reg.read32(0x80, &value);
        if(enable)
            value |= 2;
        else
            value &= (~2);
        reg.write32(0x80, value);
    }
    {
        PciHandleType reg(groupnr,iMCbus,9,0);
        uint32 value = 0;
        reg.read32(0x80, &value);
        if(enable)
            value |= 2;
        else
            value &= (~2);
        reg.write32(0x80, value);
    }
}

#define PCM_MEM_CAPACITY (1024ULL*1024ULL*64ULL) // 64 MByte

void ServerUncorePMUs::initMemTest(ServerUncorePMUs::MemTestParam & param)
{
    auto & memBufferBlockSize = param.first;
    auto & memBuffers = param.second;
#ifdef __linux__
    size_t capacity = PCM_MEM_CAPACITY;
    char * buffer = (char *)mmap(NULL, capacity, PROT_READ | PROT_WRITE,
        MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
    if (buffer == MAP_FAILED) {
        std::cerr << "ERROR: mmap failed\n";
        return;
    }
    const int64 onlineNodes = (int64)readMaxFromSysFS("/sys/devices/system/node/online");
    unsigned long long maxNode = (unsigned long long)(onlineNodes + 1);
    if (maxNode == 0)
    {
        std::cerr << "ERROR: max node is 0 \n";
        return;
    }
    if (maxNode >= 63) maxNode = 63;
    const unsigned long long nodeMask = (1ULL << maxNode) - 1ULL;
    if (0 != syscall(SYS_mbind, buffer, capacity, 3 /* MPOL_INTERLEAVE */,
        &nodeMask, maxNode, 0))
    {
        std::cerr << "ERROR: mbind failed. nodeMask: " << nodeMask << " maxNode: " << maxNode << "\n";
        return;
    }
    memBuffers.push_back((uint64 *)buffer);
    memBufferBlockSize = capacity;
#elif defined(_MSC_VER)
    ULONG HighestNodeNumber;
    if (!GetNumaHighestNodeNumber(&HighestNodeNumber))
    {
        std::cerr << "ERROR: GetNumaHighestNodeNumber call failed.\n";
        return;
    }
    memBufferBlockSize = 4096;
    for (int i = 0; i < PCM_MEM_CAPACITY / memBufferBlockSize; ++i)
    {
        LPVOID result = VirtualAllocExNuma(
            GetCurrentProcess(),
            NULL,
            memBufferBlockSize,
            MEM_RESERVE | MEM_COMMIT,
            PAGE_READWRITE,
            i % (HighestNodeNumber + 1)
        );

        if (result == NULL)
        {
            std::cerr << "ERROR: " << i << " VirtualAllocExNuma failed.\n";
            for (auto& b : memBuffers)
            {
                VirtualFree(b, memBufferBlockSize, MEM_RELEASE);
            }
            memBuffers.clear();
            break;
        }
        else
        {
            memBuffers.push_back((uint64 *)result);
        }
    }
    #else
    std::cerr << "ERROR: memory test is not implemented. QPI/UPI speed and utilization metrics may not be reliable.\n";
    #endif
    for (auto& b : memBuffers)
        std::fill(b, b + (memBufferBlockSize / sizeof(uint64)), 0ULL);
}

void ServerUncorePMUs::doMemTest(const ServerUncorePMUs::MemTestParam & param)
{
    const auto & memBufferBlockSize = param.first;
    const auto & memBuffers = param.second;
    // read and write each cache line once
    for (auto& b : memBuffers)
        for (unsigned int i = 0; i < memBufferBlockSize / sizeof(uint64); i += 64 / sizeof(uint64))
        {
            (b[i])++;
        }
}

void ServerUncorePMUs::cleanupMemTest(const ServerUncorePMUs::MemTestParam & param)
{
    const auto & memBufferBlockSize = param.first;
    const auto & memBuffers = param.second;
    for (auto& b : memBuffers)
    {
#if defined(__linux__)
        munmap(b, memBufferBlockSize);
#elif defined(_MSC_VER)
        VirtualFree(b, memBufferBlockSize, MEM_RELEASE);
#elif defined(__FreeBSD__) || defined(__APPLE__)
        (void) b;                  // avoid the unused variable warning
        (void) memBufferBlockSize; // avoid the unused variable warning
#else
#endif
    }
}

uint64 ServerUncorePMUs::computeQPISpeed(const uint32 core_nr, const int cpufamilymodel)
{
    if(qpi_speed.empty())
    {
        PCM * pcm = PCM::getInstance();
        TemporalThreadAffinity aff(core_nr);
        qpi_speed.resize(getNumQPIPorts());

        auto getSpeed = [&] (size_t i) {
           if (PCM::hasUPI(cpufamilymodel) == false && i == 1) return 0ULL; // link 1 should have the same speed as link 0, skip it
           uint64 result = 0;
           if (PCM::hasUPI(cpufamilymodel) == false && i < XPIRegisterLocation.size())
           {
               PciHandleType reg(groupnr,UPIbus, XPIRegisterLocation[i].first, QPI_PORT0_MISC_REGISTER_FUNC_ADDR);
               uint32 value = 0;
               reg.read32(QPI_RATE_STATUS_ADDR, &value);
               value &= 7; // extract lower 3 bits
               if(value) result = static_cast<uint64>((4000000000ULL + ((uint64)value)*800000000ULL)*2ULL);
           }
           std::unordered_map<uint32, size_t> UPISpeedMap{};
           std::pair<uint32, uint32> regBits{};
           switch (cpufamilymodel)
           {
           case PCM::GNR:
           case PCM::SRF:
               UPISpeedMap = {
                   { 0,  2500},
                   { 1, 12800},
                   { 2, 14400},
                   { 3, 16000},
                   { 8, 20000},
                   { 9, 24000}
               };
               regBits = std::make_pair(5, 8);
               break;
           case PCM::SPR:
               UPISpeedMap = {
                   {0,  2500},
                   {1, 12800},
                   {2, 14400},
                   {3, 16000},
                   {4, 20000}
               };
               regBits = std::make_pair(0, 2);
               break;
           }
           if (UPISpeedMap.empty() == false && i < XPIRegisterLocation.size())
           {
               const auto UPI_SPEED_REGISTER_FUNC_ADDR = 2;
               const auto UPI_SPEED_REGISTER_OFFSET = 0x2e0;
               PciHandleType reg(groupnr, UPIbus, XPIRegisterLocation[i].first, UPI_SPEED_REGISTER_FUNC_ADDR);
               uint32 value = 0;
               if (reg.read32(UPI_SPEED_REGISTER_OFFSET, &value) == sizeof(uint32))
               {
                   const size_t speedMT = UPISpeedMap[extract_bits_32(value, regBits.first, regBits.second)];
                   if (false)
                   {
                       std::cerr << "speedMT: " << speedMT << "\n";
                   }
                   result = speedMT * 1000000ULL * pcm->getBytesPerLinkTransfer();
               }
           }
           if(result == 0ULL)
           {
               if (PCM::hasUPI(cpufamilymodel) == false)
                   std::cerr << "Warning: QPI_RATE_STATUS register is not available on port " << i << ". Computing QPI speed using a measurement loop.\n";

               // compute qpi speed
               const uint64 timerGranularity = 1000000ULL; // mks

               MemTestParam param;
               initMemTest(param);
               uint64 startClocks = getQPIClocks((uint32)i);
               uint64 startTSC = pcm->getTickCount(timerGranularity, core_nr);
               uint64 endTSC;
               do
               {
                    doMemTest(param);
                    endTSC = pcm->getTickCount(timerGranularity, core_nr);
               } while (endTSC - startTSC < 200000ULL); // spin for 200 ms

               uint64 endClocks = getQPIClocks((uint32)i);
               cleanupMemTest(param);

               result = (uint64(double(endClocks - startClocks) * PCM::getBytesPerLinkCycle(cpufamilymodel) * double(timerGranularity) / double(endTSC - startTSC)));
               if(cpufamilymodel == PCM::HASWELLX || cpufamilymodel == PCM::BDX) /* BDX_DE does not have QPI. */{
                  result /=2; // HSX runs QPI clocks with doubled speed
               }
           }
           return result;
         };
         std::vector<std::future<uint64> > getSpeedsAsync;
         for (size_t i = 0; i < getNumQPIPorts(); ++i) {
             getSpeedsAsync.push_back(std::async(std::launch::async, getSpeed, i));
         }
         for (size_t i = 0; i < getNumQPIPorts(); ++i) {
             qpi_speed[i] = (PCM::hasUPI(cpufamilymodel) == false && i==1)? qpi_speed[0] : getSpeedsAsync[i].get(); // link 1 does not have own speed register, it runs with the speed of link 0
         }
         if (PCM::hasUPI(cpufamilymodel))
         {
             // check the speed of link 3
             if(qpi_speed.size() == 3 && qpi_speed[2] == 0)
             {
                std::cerr << "UPI link 3 is disabled\n";
                qpi_speed.resize(2);
                xpiPMUs.resize(2);
             }
         }
    }
    if(!qpi_speed.empty())
    {
        return *std::max_element(qpi_speed.begin(),qpi_speed.end());
    }
    else
    {
        return 0;
    }
}

void ServerUncorePMUs::reportQPISpeed() const
{
    PCM * m = PCM::getInstance();
    std::cerr.precision(1);
    std::cerr << std::fixed;
    for (uint32 i = 0; i < (uint32)qpi_speed.size(); ++i)
        std::cerr << "Max " << m->xPI() << " link " << i << " speed: " << qpi_speed[i] / (1e9) << " GBytes/second (" << qpi_speed[i] / (1e9 * m->getBytesPerLinkTransfer()) << " GT/second)\n";
}

uint64 PCM::CX_MSR_PMON_CTRY(uint32 Cbo, uint32 Ctr) const
{
    switch (cpu_family_model)
    {
    case JAKETOWN:
    case IVYTOWN:
        return JKT_C0_MSR_PMON_CTR0 + (JKTIVT_CBO_MSR_STEP * Cbo) + Ctr;

    case HASWELLX:
    case BDX_DE:
    case BDX:
    case SKX:
        return HSX_C0_MSR_PMON_CTR0 + (HSX_CBO_MSR_STEP * Cbo) + Ctr;

    case ICX:
    case SNOWRIDGE:
        return CX_MSR_PMON_BOX_CTL(Cbo) + SERVER_CHA_MSR_PMON_CTR0_OFFSET + Ctr;

    case SPR:
    case EMR:
    case GNR:
    case GNR_D:
    case GRR:
    case SRF:
        return SPR_CHA0_MSR_PMON_CTR0 + SPR_CHA_MSR_STEP * Cbo + Ctr;

    default:
        return 0;
    }
}

uint64 PCM::CX_MSR_PMON_BOX_FILTER(uint32 Cbo) const
{
    switch (cpu_family_model)
    {
    case JAKETOWN:
    case IVYTOWN:
        return JKT_C0_MSR_PMON_BOX_FILTER + (JKTIVT_CBO_MSR_STEP * Cbo);

    case HASWELLX:
    case BDX_DE:
    case BDX:
    case SKX:
        return HSX_C0_MSR_PMON_BOX_FILTER + (HSX_CBO_MSR_STEP * Cbo);

    case KNL:
        return KNL_CHA0_MSR_PMON_BOX_CTL + (KNL_CHA_MSR_STEP * Cbo);

    case ICX:
        return CX_MSR_PMON_BOX_CTL(Cbo) + SERVER_CHA_MSR_PMON_BOX_FILTER_OFFSET;

    case SPR:
    case EMR:
    case GNR:
    case GNR_D:
    case GRR:
    case SRF:
        return SPR_CHA0_MSR_PMON_BOX_FILTER + SPR_CHA_MSR_STEP * Cbo;

    default:
        return 0;
    }
}

uint64 PCM::CX_MSR_PMON_BOX_FILTER1(uint32 Cbo) const
{
    switch (cpu_family_model) {
    case IVYTOWN:
        return IVT_C0_MSR_PMON_BOX_FILTER1 + (JKTIVT_CBO_MSR_STEP * Cbo);

    case HASWELLX:
    case BDX_DE:
    case BDX:
    case SKX:
        return HSX_C0_MSR_PMON_BOX_FILTER1 + (HSX_CBO_MSR_STEP * Cbo);

    default:
        return 0;
    }
}
uint64 PCM::CX_MSR_PMON_CTLY(uint32 Cbo, uint32 Ctl) const
{
    switch (cpu_family_model) {
    case JAKETOWN:
    case IVYTOWN:
        return JKT_C0_MSR_PMON_CTL0 + (JKTIVT_CBO_MSR_STEP * Cbo) + Ctl;

    case HASWELLX:
    case BDX_DE:
    case BDX:
    case SKX:
        return HSX_C0_MSR_PMON_CTL0 + (HSX_CBO_MSR_STEP * Cbo) + Ctl;

    case ICX:
    case SNOWRIDGE:
        return CX_MSR_PMON_BOX_CTL(Cbo) + SERVER_CHA_MSR_PMON_CTL0_OFFSET + Ctl;

    case SPR:
    case EMR:
    case GNR:
    case GNR_D:
    case GRR:
    case SRF:
        return SPR_CHA0_MSR_PMON_CTL0 + SPR_CHA_MSR_STEP * Cbo + Ctl;

    default:
        return 0;
    }
}

uint64 PCM::CX_MSR_PMON_BOX_CTL(uint32 Cbo) const
{
    switch (cpu_family_model) {
    case JAKETOWN:
    case IVYTOWN:
        return JKT_C0_MSR_PMON_BOX_CTL + (JKTIVT_CBO_MSR_STEP * Cbo);

    case HASWELLX:
    case BDX_DE:
    case BDX:
    case SKX:
        return HSX_C0_MSR_PMON_BOX_CTL + (HSX_CBO_MSR_STEP * Cbo);

    case KNL:
        return KNL_CHA0_MSR_PMON_BOX_CTRL + (KNL_CHA_MSR_STEP * Cbo);

    case ICX:
        return ICX_CHA_MSR_PMON_BOX_CTL[Cbo];

    case SPR:
    case EMR:
    case GNR:
    case GNR_D:
    case GRR:
    case SRF:
        return SPR_CHA0_MSR_PMON_BOX_CTRL + SPR_CHA_MSR_STEP * Cbo;

    case SNOWRIDGE:
        return SNR_CHA_MSR_PMON_BOX_CTL[Cbo];

    default:
        return 0;
    }
}


// Return the first device found with specific vendor/device IDs
PciHandleType * getDeviceHandle(uint32 vendorId, uint32 deviceId)
{
    #ifdef __linux__
    const std::vector<MCFGRecord> & mcfg = PciHandleMM::getMCFGRecords();
    #else
    std::vector<MCFGRecord> mcfg;
    getMCFGRecords(mcfg);
    #endif

    for(uint32 s = 0; s < (uint32)mcfg.size(); ++s)
    {
        for (uint32 bus = (uint32)mcfg[s].startBusNumber; bus <= (uint32)mcfg[s].endBusNumber; ++bus)
        {
            for (uint32 device = 0; device < 0x20; ++device)
            {
                for (uint32 function = 0; function < 0x8; ++function)
                {
                    if (PciHandleType::exists(mcfg[s].PCISegmentGroupNumber, bus, device, function))
                    {
                        PciHandleType * h = new PciHandleType(mcfg[s].PCISegmentGroupNumber, bus, device, function);
                        uint32 value;
                        h->read32(0, &value);
                        const uint32 vid = value & 0xffff;
                        const uint32 did = (value >> 16) & 0xffff;
                        if (vid == vendorId && did == deviceId)
                            return h;
                        deleteAndNullify(h);
                    }
                }
            }
        }
    }
    return NULL;
}

inline uint32 weight32(uint32 n)
{
    uint32 count = 0;
    while (n)
    {
        n &= (n - 1);
        count++;
    }

    return count;
}

uint32 PCM::getMaxNumOfCBoxesInternal() const
{
    static int num = -1;
    if (num >= 0)
    {
        return (uint32)num;
    }
    const auto refCore = socketRefCore[0];
    uint64 val = 0;
    switch (cpu_family_model)
    {
    case GRR:
    case GNR:
    case GNR_D:
    case SRF:
        {
            const auto MSR_PMON_NUMBER_CBOS = 0x3fed;
            MSR[refCore]->read(MSR_PMON_NUMBER_CBOS, &val);
            num = (uint32)(val & 511);
        }
        break;
    case SPR:
    case EMR:
        try {
            PciHandleType * h = getDeviceHandle(PCM_INTEL_PCI_VENDOR_ID, 0x325b);
            if (h)
            {
                uint32 value;
                h->read32(0x9c, &value);
                num = (uint32)weight32(value);
                h->read32(0xa0, &value);
                num += (uint32)weight32(value);
                deleteAndNullify(h);
            }
            else
            {
                num = 0;
            }
        }
        catch (std::exception& e)
        {
            std::cerr << "Warning: reading the number of CHA from PCICFG register has failed: " << e.what() << "\n";
        }
        break;
    case KNL:
    case SKX:
    case ICX:
        {
            /*
             *  on KNL two physical cores share CHA.
             *  The number of CHAs in the processor is stored in bits 5:0
             *  of NCUPMONConfig [0x702] MSR.
             */
            const auto NCUPMONConfig = 0x702;
            MSR[refCore]->read(NCUPMONConfig, &val);
        }
        num = (uint32)(val & 63);
        break;
    case SNOWRIDGE:
        num = (uint32)num_phys_cores_per_socket / 4;
        maxNumOfCBoxesBasedOnCoreCount = true;
        break;
    default:
        /*
         *  on other supported CPUs there is one CBox per physical core.  This calculation will get us
         *  the number of physical cores per socket which is the expected
         *  value to be returned.
         */
        num = (uint32)num_phys_cores_per_socket;
        maxNumOfCBoxesBasedOnCoreCount = true;
    }
#ifdef PCM_USE_PERF
    if (num <= 0)
    {
        num = (uint32)enumeratePerfPMUs("cbox", 100).size();
    }
    if (num <= 0)
    {
        num = (uint32)enumeratePerfPMUs("cha", 100).size();
    }
#endif
    assert(num >= 0);
    return (uint32)num;
}

uint32 PCM::getMaxNumOfIIOStacks() const
{
    if (iioPMUs.size() > 0)
    {
        assert(irpPMUs.size());
        assert(iioPMUs[0].size() == irpPMUs[0].size());
        return (uint32)iioPMUs[0].size();
    }
    return 0;
}

uint32 PCM::getMaxNumOfIOStacks() const
{
    return getMaxNumOfIIOStacks();
}

void PCM::programCboOpcodeFilter(const uint32 opc0, UncorePMU & pmu, const uint32 nc_, const uint32 opc1, const uint32 loc, const uint32 rem)
{
    if (JAKETOWN == cpu_family_model)
    {
        *pmu.filter[0] = JKT_CBO_MSR_PMON_BOX_FILTER_OPC(opc0);

    } else if (IVYTOWN == cpu_family_model || HASWELLX == cpu_family_model || BDX_DE == cpu_family_model || BDX == cpu_family_model)
    {
        *pmu.filter[1] = IVTHSX_CBO_MSR_PMON_BOX_FILTER1_OPC(opc0);
    } else if (SKX == cpu_family_model)
    {
        *pmu.filter[1] = SKX_CHA_MSR_PMON_BOX_FILTER1_OPC0(opc0) +
                SKX_CHA_MSR_PMON_BOX_FILTER1_OPC1(opc1) +
                (rem?SKX_CHA_MSR_PMON_BOX_FILTER1_REM(1):0ULL) +
                (loc?SKX_CHA_MSR_PMON_BOX_FILTER1_LOC(1):0ULL) +
                SKX_CHA_MSR_PMON_BOX_FILTER1_NM(1) +
                SKX_CHA_MSR_PMON_BOX_FILTER1_NOT_NM(1) +
                (nc_?SKX_CHA_MSR_PMON_BOX_FILTER1_NC(1):0ULL);
    }
    else
    {
        std::cerr << "ERROR: programCboOpcodeFilter function is not implemented for cpu family " << cpu_family << " model " << cpu_model_private << std::endl;
        throw std::exception();
    }
}

void PCM::programIIOCounters(uint64 rawEvents[4], int IIOStack)
{
    std::vector<int32> IIO_units;
    if (IIOStack == -1)
    {
        int stacks_count;
        switch (getCPUFamilyModel())
        {
        case PCM::GRR:
            stacks_count = GRR_M2IOSF_NUM;
            break;
        case PCM::GNR:
        case PCM::GNR_D:
        case PCM::SRF:
            stacks_count = BHS_M2IOSF_NUM;
            break;
        case PCM::SPR:
        case PCM::EMR:
            stacks_count = SPR_M2IOSF_NUM;
            break;
        case PCM::ICX:
            stacks_count = ICX_IIO_STACK_COUNT;
            break;
        case PCM::SNOWRIDGE:
            stacks_count = SNR_IIO_STACK_COUNT;
            break;
        case PCM::BDX:
            stacks_count = BDX_IIO_STACK_COUNT;
            break;
        case PCM::SKX:
        default:
            stacks_count = SKX_IIO_STACK_COUNT;
            break;
        }
        IIO_units.reserve(stacks_count);
        for (int stack = 0; stack < stacks_count; ++stack) {
            IIO_units.push_back(stack);
        }
    }
    else
        IIO_units.push_back(IIOStack);

    for (int32 i = 0; (i < num_sockets) && MSR.size() && iioPMUs.size(); ++i)
    {
        uint32 refCore = socketRefCore[i];
        TemporalThreadAffinity tempThreadAffinity(refCore); // speedup trick for Linux

        for (const auto & unit: IIO_units)
        {
            if (iioPMUs[i].count(unit) == 0)
            {
                std::cerr << "IIO PMU unit (stack) " << unit << " is not found \n";
                continue;
            }
            auto & pmu = iioPMUs[i][unit];
            pmu.initFreeze(UNC_PMON_UNIT_CTL_RSV);

            program(pmu, &rawEvents[0], &rawEvents[4], UNC_PMON_UNIT_CTL_RSV);
        }
    }
}

void PCM::programIRPCounters(uint64 rawEvents[4], int IIOStack)
{
    DBG(2, "PCM::programIRPCounters IRP PMU unit (stack) ", IIOStack, " getMaxNumOfIIOStacks(): ", getMaxNumOfIIOStacks());
    std::vector<int32> IIO_units;
    if (IIOStack == -1)
    {
        for (uint32 stack = 0; stack < getMaxNumOfIIOStacks(); ++stack)
        {
            IIO_units.push_back(stack);
        }
    }
    else
    {
        IIO_units.push_back(IIOStack);
    }

    for (int32 i = 0; (i < num_sockets) && MSR.size() && irpPMUs.size(); ++i)
    {
        uint32 refCore = socketRefCore[i];
        TemporalThreadAffinity tempThreadAffinity(refCore); // speedup trick for Linux

        for (const auto& unit : IIO_units)
        {
            if (irpPMUs[i].count(unit) == 0)
            {
                std::cerr << "IRP PMU unit (stack) " << unit << " is not found \n";
                continue;
            }
            DBG(2,  "Programming IRP PMU unit (stack) ", unit, " on socket ", i);
            auto& pmu = irpPMUs[i][unit];
            pmu.initFreeze(UNC_PMON_UNIT_CTL_RSV);

            program(pmu, &rawEvents[0], &rawEvents[2], UNC_PMON_UNIT_CTL_RSV);
        }
    }
}

void PCM::programPCIeEventGroup(eventGroup_t &eventGroup)
{
    assert(eventGroup.size() > 0);
    uint64 events[4] = {0};
    uint64 umask[4] = {0};

    switch (cpu_family_model)
    {
        case PCM::GNR:
        case PCM::GNR_D:
        case PCM::GRR:
        case PCM::SRF:
        case PCM::SPR:
        case PCM::EMR:
        case PCM::ICX:
        case PCM::SNOWRIDGE:
            for (uint32 idx = 0; idx < eventGroup.size(); ++idx)
                events[idx] = eventGroup[idx];
            programCbo(events);
            break;
        case PCM::SKX:
        //JKT through СLX generations allow programming only one required event at a time.
            if (eventGroup[0] & SKX_CHA_MSR_PMON_BOX_FILTER1_NC(1))
                umask[0] |= (uint64)(SKX_CHA_TOR_INSERTS_UMASK_IRQ(1));
                else
                umask[0] |= (uint64)(SKX_CHA_TOR_INSERTS_UMASK_PRQ(1));

            if (eventGroup[0] & SKX_CHA_MSR_PMON_BOX_FILTER1_RSV(1))
                umask[0] |= (uint64)(SKX_CHA_TOR_INSERTS_UMASK_HIT(1));
                else
                umask[0] |= (uint64)(SKX_CHA_TOR_INSERTS_UMASK_MISS(1));

            events[0] += CBO_MSR_PMON_CTL_EVENT(0x35) + CBO_MSR_PMON_CTL_UMASK(umask[0]);
            programCbo(events, SKX_CHA_MSR_PMON_BOX_GET_OPC0(eventGroup[0]),
                                    SKX_CHA_MSR_PMON_BOX_GET_NC(eventGroup[0]));
            break;
        case PCM::BDX_DE:
        case PCM::BDX:
        case PCM::KNL:
        case PCM::HASWELLX:
        case PCM::IVYTOWN:
        case PCM::JAKETOWN:
            events[0] = CBO_MSR_PMON_CTL_EVENT(0x35);
            events[0] += BDX_CBO_MSR_PMON_BOX_GET_FLT(eventGroup[0]) ? CBO_MSR_PMON_CTL_UMASK(0x3) : CBO_MSR_PMON_CTL_UMASK(1);
            events[0] += BDX_CBO_MSR_PMON_BOX_GET_TID(eventGroup[0]) ? CBO_MSR_PMON_CTL_TID_EN : 0ULL;

            programCbo(events, BDX_CBO_MSR_PMON_BOX_GET_OPC0(eventGroup[0]),
                    0, BDX_CBO_MSR_PMON_BOX_GET_TID(eventGroup[0]) ? 0x3e : 0ULL);
            break;
    }
}

void PCM::programCbo(const uint64 * events, const uint32 opCode, const uint32 nc_, const uint32 llc_lookup_tid_filter, const uint32 loc, const uint32 rem)
{
    programUncorePMUs(CBO_PMU_ID, [&](UncorePMU & pmu)
        {
            pmu.initFreeze(UNC_PMON_UNIT_CTL_FRZ_EN);

            if (    ICX != cpu_family_model
                &&  SNOWRIDGE != cpu_family_model
                &&  SPR != cpu_family_model
                &&  EMR != cpu_family_model
                &&  GNR != cpu_family_model
                &&  GNR_D != cpu_family_model
                &&  SRF != cpu_family_model
                &&  GRR != cpu_family_model
                )
            {
                programCboOpcodeFilter(opCode, pmu, nc_, 0, loc, rem);
            }

            if ((HASWELLX == cpu_family_model || BDX_DE == cpu_family_model || BDX == cpu_family_model || SKX == cpu_family_model) && llc_lookup_tid_filter != 0)
                *pmu.filter[0] = llc_lookup_tid_filter;

            PCM::program(pmu, events, events + ServerUncoreCounterState::maxCounters, UNC_PMON_UNIT_CTL_FRZ_EN);

            for (int c = 0; c < ServerUncoreCounterState::maxCounters && size_t(c) < pmu.size(); ++c)
            {
                *pmu.counterValue[c] = 0;
            }
        }
    );
}

void PCM::programCboRaw(const uint64* events, const uint64 filter0, const uint64 filter1)
{
    programUncorePMUs(CBO_PMU_ID, [&](UncorePMU& pmu)
        {
            pmu.initFreeze(UNC_PMON_UNIT_CTL_FRZ_EN);

            if (pmu.filter[0].get())
            {
                *pmu.filter[0] = filter0;
            }

            if (pmu.filter[1].get())
            {
                *pmu.filter[1] = filter1;
            }

            PCM::program(pmu, events, events + 4, UNC_PMON_UNIT_CTL_FRZ_EN);

            for (int c = 0; c < ServerUncoreCounterState::maxCounters && size_t(c) < pmu.size(); ++c)
            {
                *pmu.counterValue[c] = 0;
            }
        }
    );
}

void PCM::programMDF(const uint64* events)
{
    programUncorePMUs(MDF_PMU_ID, [&](UncorePMU& pmu)
    {
        pmu.initFreeze(UNC_PMON_UNIT_CTL_FRZ_EN);

        PCM::program(pmu, events, events + 4, UNC_PMON_UNIT_CTL_FRZ_EN);
    });
}

void PCM::programUBOX(const uint64* events)
{
    programUncorePMUs(UBOX_PMU_ID, [&events](UncorePMU& pmu)
    {
        pmu.initFreeze(UNC_PMON_UNIT_CTL_FRZ_EN);

        *pmu.fixedCounterControl = UCLK_FIXED_CTL_EN;

        if (events)
        {
            PCM::program(pmu, events, events + 2, 0);
        }
    });
}

void PCM::controlQATTelemetry(uint32 dev, uint32 operation)
{
    if (getNumOfIDXAccelDevs(IDX_QAT) == 0 || dev >= getNumOfIDXAccelDevs(IDX_QAT) || operation >= PCM::QAT_TLM_MAX)
        return;

    auto &gControl_reg = idxPMUs[IDX_QAT][dev].generalControl;
    switch (operation)
    {
        case PCM::QAT_TLM_START:
        case PCM::QAT_TLM_STOP:
        case PCM::QAT_TLM_REFRESH:
            *gControl_reg = operation;
            break;
        default:
            break;
    }
}

void PCM::programCXLCM(const uint64* events)
{
    for (auto & sPMUs : cxlPMUs)
    {
        for (auto& pmus : sPMUs)
        {
            pmus.first.initFreeze(UNC_PMON_UNIT_CTL_FRZ_EN);
            assert(pmus.first.size() == 8);
            PCM::program(pmus.first, events, events + 8, UNC_PMON_UNIT_CTL_FRZ_EN);
        }
    }
}

void PCM::programCXLDP(const uint64* events)
{
    for (auto& sPMUs : cxlPMUs)
    {
        for (auto& pmus : sPMUs)
        {
            pmus.second.initFreeze(UNC_PMON_UNIT_CTL_FRZ_EN);
            assert(pmus.second.size() == 4);
            PCM::program(pmus.second, events, events + 4, UNC_PMON_UNIT_CTL_FRZ_EN);
        }
    }
}
void PCM::programCXLCM()
{
    uint64 CXLCMevents[8] = { 0,0,0,0,0,0,0,0 };

    CXLCMevents[EventPosition::CXL_RxC_MEM] = UNC_PMON_CTL_EVENT(0x41) + UNC_PMON_CTL_UMASK(0x10); // CXLCM_RxC_PACK_BUF_INSERTS.MEM_DATA
    CXLCMevents[EventPosition::CXL_TxC_MEM] = UNC_PMON_CTL_EVENT(0x02) + UNC_PMON_CTL_UMASK(0x10); // CXLCM_TxC_PACK_BUF_INSERTS.MEM_DATA
    CXLCMevents[EventPosition::CXL_RxC_CACHE] = UNC_PMON_CTL_EVENT(0x41) + UNC_PMON_CTL_UMASK(0x04);// CXLCM_RxC_PACK_BUF_INSERTS.CACHE_DATA
    CXLCMevents[EventPosition::CXL_TxC_CACHE] = UNC_PMON_CTL_EVENT(0x02) + UNC_PMON_CTL_UMASK(0x04);// CXLCM_TxC_PACK_BUF_INSERTS.CACHE_DATA

    programCXLCM(CXLCMevents);
}


void PCM::programCXLDP()
{
    uint64 events[4] = { 0,0,0,0 };

    events[EventPosition::CXL_TxC_MEM] = UNC_PMON_CTL_EVENT(0x02) + UNC_PMON_CTL_UMASK(0x20); // UNC_CXLDP_TxC_AGF_INSERTS.M2S_DATA

    programCXLDP(events);
}

void PCM::programIDXAccelCounters(uint32 accel, std::vector<uint64_t> &events, std::vector<uint32_t> &filters_wq, std::vector<uint32_t> &filters_eng, std::vector<uint32_t> &filters_tc, std::vector<uint32_t> &filters_pgsz, std::vector<uint32_t> &filters_xfersz)
{
    uint32 maxCTR = getMaxNumOfIDXAccelCtrs(accel); //limit the number of physical counter to use

    if (events.size() == 0 || accel >= IDX_MAX || getNumOfIDXAccelDevs(accel) == 0)
        return; //invalid input parameter or IDX accel dev NOT exist

    if (events.size() < maxCTR)
        maxCTR = events.size();

    for (auto & pmu : idxPMUs[accel])
    {
        pmu.initFreeze();

        for (uint32 i = 0; i < maxCTR; i++)
        {
            auto &ctrl_reg = pmu.counterControl[i];
            auto &filter_wq_reg = pmu.counterFilterWQ[i];
            auto &filter_eng_reg = pmu.counterFilterENG[i];
            auto &filter_tc_reg = pmu.counterFilterTC[i];
            auto &filter_pgsz_reg = pmu.counterFilterPGSZ[i];
            auto &filter_xfersz_reg = pmu.counterFilterXFERSZ[i];

            if (pmu.getPERFMode() == false)
            {
                //disable the counter before raw program in PMU direct mode.
                *ctrl_reg = 0x0;
            }

            *filter_wq_reg = extract_bits_32(filters_wq.at(i), 0, 15);            
            *filter_eng_reg = extract_bits_32(filters_eng.at(i), 0, 15);
            *filter_tc_reg = extract_bits_32(filters_tc.at(i), 0, 7);
            *filter_pgsz_reg = extract_bits_32(filters_pgsz.at(i), 0, 7);
            *filter_xfersz_reg = extract_bits_32(filters_xfersz.at(i), 0, 7);

            if (pmu.getPERFMode() == false)
            {
                *ctrl_reg = events.at(i);
            }
            else{
                switch (accel)
                {
                    case IDX_IAA:
                    case IDX_DSA:
                        //translate the event config from raw to perf format in Linux perf mode.
                        //please reference the bitmap from DSA EAS spec and linux idxd driver perfmon interface.
                        *ctrl_reg = ((extract_bits(events.at(i), 8, 11)) | ((extract_bits(events.at(i), 32, 59)) << 4));
                        break;
                    case IDX_QAT://QAT NOT support perf mode
                        break;
                    default:
                        break;
                }
            }
        }

        pmu.resetUnfreeze();
    }
}

IDXCounterState PCM::getIDXAccelCounterState(uint32 accel, uint32 dev, uint32 counter_id)
{
    IDXCounterState result;

    if (accel >= IDX_MAX || dev >= getNumOfIDXAccelDevs(accel) || counter_id >= getMaxNumOfIDXAccelCtrs(accel))
        return result;

    result.data = *idxPMUs[accel][dev].counterValue[counter_id];
    return result;
}

uint32 PCM::getNumOfIDXAccelDevs(int accel) const
{
    if (accel >= IDX_MAX)
        return 0;

    return idxPMUs[accel].size();
}

uint32 PCM::getMaxNumOfIDXAccelCtrs(int accel) const
{
    uint32 retval = 0;

    if (supportIDXAccelDev() == true)
    {
        if (accel == IDX_IAA || accel == IDX_DSA)
        {
            retval = SPR_IDX_ACCEL_COUNTER_MAX_NUM;
        }
        else if(accel == IDX_QAT)
        {
            retval = SPR_QAT_ACCEL_COUNTER_MAX_NUM;
        }
    }

    return retval;
}

uint32 PCM::getNumaNodeOfIDXAccelDev(uint32 accel, uint32 dev) const
{
    uint32 numa_node = 0xff;

    if (accel >= IDX_MAX || dev >= getNumOfIDXAccelDevs(accel))
        return numa_node;

    numa_node = idxPMUs[accel][dev].getNumaNode();
    return numa_node;
}

uint32 PCM::getCPUSocketIdOfIDXAccelDev(uint32 accel, uint32 dev) const
{
    uint32 socketid = 0xff;

    if (accel >= IDX_MAX || dev >= getNumOfIDXAccelDevs(accel))
        return socketid;

    socketid = idxPMUs[accel][dev].getSocketId();
    return socketid;
}

bool PCM::supportIDXAccelDev() const
{
    bool retval = false;

    switch (this->getCPUFamilyModel())
    {
        case PCM::SPR:
        case PCM::EMR:
        case PCM::GNR:
        case PCM::SRF:
        case PCM::GNR_D:
            retval = true;
            break;

        default:
            retval = false;
            break;
    }

    return retval;
}

uint64 PCM::getUncoreCounterState(const int pmu_id, const size_t socket, const uint32 ctr) const
{
    uint64 result = 0;

    if (socket < uncorePMUs.size() && ctr < ServerUncoreCounterState::maxCounters)
    {
        for (size_t die = 0; die < uncorePMUs[socket].size(); ++die)
        {
            TemporalThreadAffinity tempThreadAffinity(socketRefCore[socket]); // speedup trick for Linux
            const auto pmusIter = uncorePMUs[socket][die].find(pmu_id);
            if (pmusIter != uncorePMUs[socket][die].end())
            {
                for (const auto& pmu : pmusIter->second)
                {
                    if (pmu.get())
                    {
                        result += *(pmu->counterValue[ctr]);
                    }
                }
            }
        }
    }
    return result;
}

uint64 PCM::getUncoreClocks(const uint32 socket_id)
{
    uint64 result = 0;
    if (socket_id < uncorePMUs.size())
    {
        for (auto& d : uncorePMUs[socket_id])
        {
            const auto iter = d.find(UBOX_PMU_ID);
            if (iter != d.end())
            {
                for (auto& pmu : iter->second)
                {
                    if (pmu.get())
                    {
                        result += *pmu->fixedCounterValue;
                    }
                }
            }
        }
    }
    return result;
}

PCIeCounterState PCM::getPCIeCounterState(const uint32 socket_, const uint32 ctr_)
{
    PCIeCounterState result;
    result.data = getUncoreCounterState(CBO_PMU_ID, socket_, ctr_);
    return result;
}

uint64 PCM::getPCIeCounterData(const uint32 socket_, const uint32 ctr_)
{
    return getUncoreCounterState(CBO_PMU_ID, socket_, ctr_);
}

void PCM::initLLCReadMissLatencyEvents(uint64 * events, uint32 & opCode)
{
    if (LLCReadMissLatencyMetricsAvailable() == false)
    {
        return;
    }
    uint64 umask = 3ULL; // MISS_OPCODE
    switch (cpu_family_model)
    {
        case ICX:
        case SPR:
        case SNOWRIDGE:
            umask = 1ULL;
            break;
        case SKX:
            umask = (uint64)(SKX_CHA_TOR_INSERTS_UMASK_IRQ(1)) + (uint64)(SKX_CHA_TOR_INSERTS_UMASK_MISS(1));
            break;
    }

    uint64 umask_ext = 0;
    switch (cpu_family_model)
    {
        case ICX:
            umask_ext = 0xC817FE;
            break;
        case SPR:
            umask_ext = 0x00C817FE;
            break;
        case SNOWRIDGE:
            umask_ext = 0xC827FE;
            break;
    }

    const uint64 all_umasks = CBO_MSR_PMON_CTL_UMASK(umask) + UNC_PMON_CTL_UMASK_EXT(umask_ext);
    events[EventPosition::TOR_OCCUPANCY] = CBO_MSR_PMON_CTL_EVENT(0x36) + all_umasks; // TOR_OCCUPANCY (must be on counter 0)
    events[EventPosition::TOR_INSERTS] = CBO_MSR_PMON_CTL_EVENT(0x35) + all_umasks; // TOR_INSERTS

    opCode = (SKX == cpu_family_model) ? 0x202 : 0x182;
}

void PCM::programCbo()
{
    uint64 events[ServerUncoreCounterState::maxCounters];
    std::fill(events, events + ServerUncoreCounterState::maxCounters, 0);
    uint32 opCode = 0;

    initLLCReadMissLatencyEvents(events, opCode);
    initCHARequestEvents(events);

    programCbo(events, opCode);

    programUBOX(nullptr);
}

void PCM::initCHARequestEvents(uint64 * config)
{
    if (localMemoryRequestRatioMetricAvailable() && hasCHA())
    {
#ifdef PCM_HA_REQUESTS_READS_ONLY
        // HA REQUESTS READ: LOCAL + REMOTE
        config[EventPosition::REQUESTS_ALL] = CBO_MSR_PMON_CTL_EVENT(0x50) + CBO_MSR_PMON_CTL_UMASK((1 + 2));
        // HA REQUESTS READ: LOCAL ONLY
        config[EventPosition::REQUESTS_LOCAL] = CBO_MSR_PMON_CTL_EVENT(0x50) + CBO_MSR_PMON_CTL_UMASK((1));
#else
        // HA REQUESTS READ+WRITE+REMOTE+LOCAL
        config[EventPosition::REQUESTS_ALL] = CBO_MSR_PMON_CTL_EVENT(0x50) + CBO_MSR_PMON_CTL_UMASK((1 + 2 + 4 + 8));
        // HA REQUESTS READ+WRITE (LOCAL only)
        config[EventPosition::REQUESTS_LOCAL] = CBO_MSR_PMON_CTL_EVENT(0x50) + CBO_MSR_PMON_CTL_UMASK((1 + 4));
#endif
    }
}

CounterWidthExtender::CounterWidthExtender(AbstractRawCounter * raw_counter_, uint64 counter_width_, uint32 watchdog_delay_ms_) : raw_counter(raw_counter_), counter_width(counter_width_), watchdog_delay_ms(watchdog_delay_ms_)
{
    last_raw_value = (*raw_counter)();
    extended_value = last_raw_value;
    DBG(3, "Initial Value " , extended_value);
    try {
        UpdateThread = new std::thread(
            [&]() {
            while (1)
            {
                MySleepMs(static_cast<int>(this->watchdog_delay_ms));
                /* uint64 dummy = */ this->read();
            }
        }
        );
    }
    catch (const std::exception& e)
    {
        std::cerr << "PCM Error: caught exception " << e.what() << " while creating thread for a CounterWidthExtender\n" <<
            threadCreateErrorMessage;
        throw; // re-throw
    }
}
CounterWidthExtender::~CounterWidthExtender()
{
    deleteAndNullify(UpdateThread);
    deleteAndNullify(raw_counter);
}


UncorePMU::UncorePMU(const HWRegisterPtr& unitControl_,
    const HWRegisterPtr& counterControl0,
    const HWRegisterPtr& counterControl1,
    const HWRegisterPtr& counterControl2,
    const HWRegisterPtr& counterControl3,
    const HWRegisterPtr& counterValue0,
    const HWRegisterPtr& counterValue1,
    const HWRegisterPtr& counterValue2,
    const HWRegisterPtr& counterValue3,
    const HWRegisterPtr& fixedCounterControl_,
    const HWRegisterPtr& fixedCounterValue_,
    const HWRegisterPtr& filter0,
    const HWRegisterPtr& filter1
) :
    cpu_family_model_(0),
    unitControl(unitControl_),
    counterControl{ counterControl0, counterControl1, counterControl2, counterControl3 },
    counterValue{ counterValue0, counterValue1, counterValue2, counterValue3 },
    fixedCounterControl(fixedCounterControl_),
    fixedCounterValue(fixedCounterValue_),
    filter{ filter0 , filter1 }
{
    assert(counterControl.size() == counterValue.size());
}

UncorePMU::UncorePMU(const HWRegisterPtr& unitControl_,
    const std::vector<HWRegisterPtr>& counterControl_,
    const std::vector<HWRegisterPtr>& counterValue_,
    const HWRegisterPtr& fixedCounterControl_,
    const HWRegisterPtr& fixedCounterValue_,
    const HWRegisterPtr& filter0,
    const HWRegisterPtr& filter1
):
    cpu_family_model_(0),
    unitControl(unitControl_),
    counterControl{counterControl_},
    counterValue{counterValue_},
    fixedCounterControl(fixedCounterControl_),
    fixedCounterValue(fixedCounterValue_),
    filter{ filter0 , filter1 }
{
    assert(counterControl.size() == counterValue.size());
}

uint32 UncorePMU::getCPUFamilyModel()
{
    if (cpu_family_model_ == 0)
    {
        cpu_family_model_ = PCM::getInstance()->getCPUFamilyModel();
    }
    return cpu_family_model_;
}

void UncorePMU::cleanup()
{
    for (auto& cc: counterControl)
    {
        if (cc.get()) *cc = 0;
    }
    if (unitControl.get()) *unitControl = 0;
    if (fixedCounterControl.get()) *fixedCounterControl = 0;
}

void UncorePMU::freeze(const uint32 extra)
{
    switch (getCPUFamilyModel())
    {
    case PCM::SPR:
    case PCM::EMR:
    case PCM::GNR:
    case PCM::GNR_D:
    case PCM::GRR:
    case PCM::SRF:
        *unitControl = SPR_UNC_PMON_UNIT_CTL_FRZ;
        break;
    default:
        *unitControl = extra + UNC_PMON_UNIT_CTL_FRZ;
    }
}

void UncorePMU::unfreeze(const uint32 extra)
{
    switch (getCPUFamilyModel())
    {
    case PCM::SPR:
    case PCM::EMR:
    case PCM::GNR:
    case PCM::GNR_D:
    case PCM::GRR:
    case PCM::SRF:
        *unitControl = 0;
        break;
    default:
        *unitControl = extra;
    }
}

bool UncorePMU::initFreeze(const uint32 extra, const char* xPICheckMsg)
{
    if (unitControl.get() == nullptr)
    {
        return true; // this PMU does not have unit control register => no op
    }

    switch (getCPUFamilyModel())
    {
        case PCM::SPR:
        case PCM::EMR:
        case PCM::GNR:
        case PCM::GNR_D:
        case PCM::GRR:
        case PCM::SRF:
            *unitControl = SPR_UNC_PMON_UNIT_CTL_FRZ; // freeze
            *unitControl = SPR_UNC_PMON_UNIT_CTL_FRZ + SPR_UNC_PMON_UNIT_CTL_RST_CONTROL; // freeze and reset control registers
            return true;
    }
    // freeze enable
    *unitControl = extra;
    if (xPICheckMsg)
    {
        if ((extra & UNC_PMON_UNIT_CTL_VALID_BITS_MASK) != ((*unitControl) & UNC_PMON_UNIT_CTL_VALID_BITS_MASK))
        {
            unitControl = nullptr;
            return false;
        }
    }
    // freeze
    *unitControl = extra + UNC_PMON_UNIT_CTL_FRZ;

#ifdef PCM_UNCORE_PMON_BOX_CHECK_STATUS
    const uint64 val = *unitControl;
    if ((val & UNC_PMON_UNIT_CTL_VALID_BITS_MASK) != (extra + UNC_PMON_UNIT_CTL_FRZ))
    {
        std::cerr << "ERROR: PMU counter programming seems not to work. PMON_BOX_CTL=0x" << std::hex << val << " needs to be =0x" << (UNC_PMON_UNIT_CTL_FRZ_EN + UNC_PMON_UNIT_CTL_FRZ) << std::dec << "\n";
        if (xPICheckMsg)
        {
            std::cerr << xPICheckMsg;
        }
    }
#endif
    return true;
}

void UncorePMU::resetUnfreeze(const uint32 extra)
{
    switch (getCPUFamilyModel())
    {
    case PCM::SPR:
    case PCM::EMR:
    case PCM::GNR:
    case PCM::GNR_D:
    case PCM::GRR:
    case PCM::SRF:
        *unitControl = SPR_UNC_PMON_UNIT_CTL_FRZ + SPR_UNC_PMON_UNIT_CTL_RST_COUNTERS; // freeze and reset counter registers
        *unitControl = 0; // unfreeze
        return;
    }
    // reset counter values
    *unitControl = extra + UNC_PMON_UNIT_CTL_FRZ + UNC_PMON_UNIT_CTL_RST_COUNTERS;

    // unfreeze counters
    *unitControl = extra;
}

IDX_PMU::IDX_PMU(const bool perfMode_,
        const uint32 numaNode_,
        const uint32 socketId_,
        const HWRegisterPtr& resetControl_,
        const HWRegisterPtr& freezeControl_,
        const HWRegisterPtr& generalControl_,
        const std::vector<HWRegisterPtr> & counterControl,
        const std::vector<HWRegisterPtr> & counterValue,
        const std::vector<HWRegisterPtr> & counterFilterWQ,
        const std::vector<HWRegisterPtr> & counterFilterENG,
        const std::vector<HWRegisterPtr> & counterFilterTC,
        const std::vector<HWRegisterPtr> & counterFilterPGSZ,
        const std::vector<HWRegisterPtr> & counterFilterXFERSZ
    ) : 
    cpu_family_model_(0),
    perf_mode_(perfMode_),
    numa_node_(numaNode_),
    socket_id_(socketId_),
    resetControl(resetControl_),
    freezeControl(freezeControl_),
    generalControl(generalControl_),
    counterControl{counterControl},
    counterValue{counterValue},
    counterFilterWQ{counterFilterWQ},
    counterFilterENG{counterFilterENG},
    counterFilterTC{counterFilterTC},
    counterFilterPGSZ{counterFilterPGSZ},
    counterFilterXFERSZ{counterFilterXFERSZ}
{
    assert(counterControl.size() == counterValue.size());
}

uint32 IDX_PMU::getCPUFamilyModel()
{
    if (cpu_family_model_ == 0)
    {
        cpu_family_model_ = PCM::getInstance()->getCPUFamilyModel();
    }

    return cpu_family_model_;
}

void IDX_PMU::cleanup()
{
    for (auto& cc: counterControl)
    {
        if (cc.get())
        {
            *cc = 0;
        }
    }

    if (resetControl.get())
    {
        *resetControl = 0x3;
    }

    if (generalControl.get())
    {
        *generalControl = 0x0;
    }
    DBG(3, "IDX_PMU::cleanup");
}

void IDX_PMU::freeze()
{
    *freezeControl = 0xFFFFFFFF;
}

void IDX_PMU::unfreeze()
{
    *freezeControl = 0x0;
}

bool IDX_PMU::initFreeze()
{
    if (resetControl.get() == nullptr || freezeControl.get() == nullptr)
    {
        return true; // does not have reset/freeze control register => no op
    }

    *resetControl = 0x2; // reset counter
    freeze(); // freeze counter
    return true;
}

void IDX_PMU::resetUnfreeze()
{
    unfreeze(); // unfreeze counter
}

bool IDX_PMU::getPERFMode()
{
    return perf_mode_;
}

uint32 IDX_PMU::getNumaNode() const
{
    return numa_node_;
}

uint32 IDX_PMU::getSocketId() const
{
    return socket_id_;
}

IIOCounterState PCM::getIIOCounterState(int socket, int IIOStack, int counter)
{
    IIOCounterState result;
    result.data = 0;

    if (socket < (int)iioPMUs.size() && iioPMUs[socket].count(IIOStack) > 0)
    {
        result.data = *iioPMUs[socket][IIOStack].counterValue[counter];
    }

    return result;
}

void PCM::getIIOCounterStates(int socket, int IIOStack, IIOCounterState * result)
{
    uint32 refCore = socketRefCore[socket];
    TemporalThreadAffinity tempThreadAffinity(refCore); // speedup trick for Linux

    for (int c = 0; c < 4; ++c) {
        result[c] = getIIOCounterState(socket, IIOStack, c);
    }
}

void PCM::setupCustomCoreEventsForNuma(PCM::ExtendedCustomCoreEventDescription& conf) const
{
    switch (this->getCPUFamilyModel())
    {
    case PCM::WESTMERE_EX:
        // OFFCORE_RESPONSE.ANY_REQUEST.LOCAL_DRAM:  Offcore requests satisfied by the local DRAM
        conf.OffcoreResponseMsrValue[0] = 0x40FF;
        // OFFCORE_RESPONSE.ANY_REQUEST.REMOTE_DRAM: Offcore requests satisfied by a remote DRAM
        conf.OffcoreResponseMsrValue[1] = 0x20FF;
        break;
    case PCM::JAKETOWN:
    case PCM::IVYTOWN:
        // OFFCORE_RESPONSE.*.LOCAL_DRAM
        conf.OffcoreResponseMsrValue[0] = 0x780400000 | 0x08FFF;
        // OFFCORE_RESPONSE.*.REMOTE_DRAM
        conf.OffcoreResponseMsrValue[1] = 0x7ff800000 | 0x08FFF;
        break;
    case PCM::HASWELLX:
        // OFFCORE_RESPONSE.*.LOCAL_DRAM
        conf.OffcoreResponseMsrValue[0] = 0x600400000 | 0x08FFF;
        // OFFCORE_RESPONSE.*.REMOTE_DRAM
        conf.OffcoreResponseMsrValue[1] = 0x63f800000 | 0x08FFF;
        break;
    case PCM::BDX:
        // OFFCORE_RESPONSE.ALL_REQUESTS.L3_MISS.LOCAL_DRAM
        conf.OffcoreResponseMsrValue[0] = 0x0604008FFF;
        // OFFCORE_RESPONSE.ALL_REQUESTS.L3_MISS.REMOTE_DRAM
        conf.OffcoreResponseMsrValue[1] = 0x067BC08FFF;
        break;
    case PCM::SKX:
        // OFFCORE_RESPONSE.ALL_REQUESTS.L3_MISS_LOCAL_DRAM.ANY_SNOOP
        conf.OffcoreResponseMsrValue[0] = 0x3FC0008FFF | (1 << 26);
        // OFFCORE_RESPONSE.ALL_REQUESTS.L3_MISS_REMOTE_(HOP0,HOP1,HOP2P)_DRAM.ANY_SNOOP
        conf.OffcoreResponseMsrValue[1] = 0x3FC0008FFF | (1 << 27) | (1 << 28) | (1 << 29);
        break;
    case PCM::ICX:
        std::cerr << "INFO: Monitored accesses include demand + L2 cache prefetcher, code read and RFO.\n";
        // OCR.READS_TO_CORE.LOCAL_DRAM
        conf.OffcoreResponseMsrValue[0] = 0x0104000477;
        // OCR.READS_TO_CORE.REMOTE_DRAM
        conf.OffcoreResponseMsrValue[1] = 0x0730000477;
        break;
    case PCM::SPR:
    case PCM::EMR:
    case PCM::GNR:
        std::cout << "INFO: Monitored accesses include demand + L2 cache prefetcher, code read and RFO.\n";
         // OCR.READS_TO_CORE.LOCAL_DRAM
        conf.OffcoreResponseMsrValue[0] = 0x104004477;
         // OCR.READS_TO_CORE.REMOTE_DRAM and OCR.READS_TO_CORE.SNC_DRAM
        conf.OffcoreResponseMsrValue[1] = 0x730004477 | 0x708004477;
       break;
    default:
        throw UnsupportedProcessorException();
    }
}

} // namespace pcm

```

`src/cpucounters.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2024, Intel Corporation
// written by Roman Dementiev
//            Thomas Willhalm
//            and others

#ifndef CPUCOUNTERS_HEADER
#define CPUCOUNTERS_HEADER

/*!     \file cpucounters.h
        \brief Main CPU counters header

        Include this header file if you want to access CPU counters (core and uncore - including memory controller chips and QPI)
*/

#include "version.h"

#ifndef PCM_API
#define PCM_API
#endif

#undef PCM_HA_REQUESTS_READS_ONLY
#undef PCM_DEBUG_TOPOLOGY // debug of topology enumeration routine
#undef PCM_UNCORE_PMON_BOX_CHECK_STATUS // debug only

#include "types.h"
#include "topologyentry.h"
#include "msr.h"
#include "pci.h"
#include "tpmi.h"
#include "pmt.h"
#include "bw.h"
#include "width_extender.h"
#include "exceptions/unsupported_processor_exception.hpp"
#include "uncore_pmu_discovery.h"

#include <vector>
#include <array>
#include <limits>
#include <string>
#include <memory>
#include <map>
#include <unordered_map>
#include <string.h>
#include <assert.h>
#include <atomic>
#include "mutex.h"

#ifdef PCM_USE_PERF
#include <linux/perf_event.h>
#include <errno.h>
#define PCM_PERF_COUNT_HW_REF_CPU_CYCLES (9)
#endif

#ifndef _MSC_VER
#define NOMINMAX
#include <semaphore.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/syscall.h>
#include <unistd.h>
#endif

#ifdef _MSC_VER
#if _MSC_VER>= 1600
#include <intrin.h>
#endif
#endif

#ifdef __linux__
#include "resctrl.h"
#endif

namespace pcm {

#ifdef _MSC_VER
void PCM_API restrictDriverAccess(LPCTSTR path);
#endif

class SystemCounterState;
class SocketCounterState;
class CoreCounterState;
class BasicCounterState;
class ServerUncoreCounterState;
class PCM;
class CoreTaskQueue;
class SystemRoot;

/*
        CPU performance monitoring routines

        A set of performance monitoring routines for recent Intel CPUs
*/

class HWRegister
{
public:
    virtual void operator = (uint64 val) = 0; // write operation
    virtual operator uint64 () = 0; //read operation
    virtual ~HWRegister() {}
};

class PCICFGRegister64 : public HWRegister
{
    std::shared_ptr<PciHandleType> handle;
    size_t offset;
public:
    PCICFGRegister64(const std::shared_ptr<PciHandleType> & handle_, size_t offset_) :
        handle(handle_),
        offset(offset_)
    {
    }
    void operator = (uint64 val) override
    {
        cvt_ds cvt;
        cvt.ui64 = val;
        handle->write32(offset, cvt.ui32.low);
        handle->write32(offset + sizeof(uint32), cvt.ui32.high);
    }
    operator uint64 ()  override
    {
        uint64 result = 0;
        handle->read64(offset, &result);
        return result;
    }
};

class PCICFGRegister32 : public HWRegister
{
    std::shared_ptr<PciHandleType> handle;
    size_t offset;
public:
    PCICFGRegister32(const std::shared_ptr<PciHandleType> & handle_, size_t offset_) :
        handle(handle_),
        offset(offset_)
    {
    }
    void operator = (uint64 val) override
    {
        handle->write32(offset, (uint32)val);
    }
    operator uint64 () override
    {
        uint32 result = 0;
        handle->read32(offset, &result);
        return result;
    }
};

class MMIORegister64 : public HWRegister
{
    std::shared_ptr<MMIORange> handle;
    size_t offset;
public:
    MMIORegister64(const std::shared_ptr<MMIORange> & handle_, size_t offset_) :
        handle(handle_),
        offset(offset_)
    {
    }
    void operator = (uint64 val) override
    {
        DBG(4, std::hex , "MMIORegister64 writing " , val , " at offset " , offset , std::dec);
        handle->write64(offset, val);
    }
    operator uint64 () override
    {
        const uint64 val = handle->read64(offset);
        DBG(4, std::hex , "MMIORegister64 read " , val , " from offset " , offset , std::dec);
        return val;
    }
};

class MMIORegister32 : public HWRegister
{
    std::shared_ptr<MMIORange> handle;
    size_t offset;
public:
    MMIORegister32(const std::shared_ptr<MMIORange> & handle_, size_t offset_) :
        handle(handle_),
        offset(offset_)
    {
    }
    void operator = (uint64 val) override
    {
        DBG(4, std::hex , "MMIORegister32 writing " , val , " at offset " , offset , std::dec);
        handle->write32(offset, (uint32)val);
    }
    operator uint64 () override
    {
        const uint64 val = (uint64)handle->read32(offset);
        DBG(4, std::hex , "MMIORegister32 read " , val , " from offset " , offset , std::dec);
        return val;
    }
};

class MSRRegister : public HWRegister
{
    std::shared_ptr<SafeMsrHandle> handle;
    size_t offset;
public:
    MSRRegister(const std::shared_ptr<SafeMsrHandle> & handle_, size_t offset_) :
        handle(handle_),
        offset(offset_)
    {
    }
    void operator = (uint64 val) override
    {
        handle->write(offset, val);
    }
    operator uint64 () override
    {
        uint64 value = 0;
        handle->read(offset, &value);
        DBG(4, "reading MSR " , offset , " returning " , value);
        return value;
    }
};

class CounterWidthExtenderRegister : public HWRegister
{
    std::shared_ptr<CounterWidthExtender> handle;
public:
    CounterWidthExtenderRegister(const std::shared_ptr<CounterWidthExtender> & handle_) :
        handle(handle_)
    {
    }
    void operator = (uint64 val) override
    {
        if (val == 0)
        {
            handle->reset();
        }
        else
        {
            std::cerr << "ERROR: writing non-zero values to CounterWidthExtenderRegister is not supported\n";
            throw std::exception();
        }
    }
    operator uint64 () override
    {
        return handle->read();;
    }
};

class UncorePMU
{
    typedef std::shared_ptr<HWRegister> HWRegisterPtr;
    uint32 cpu_family_model_;
    uint32 getCPUFamilyModel();
    HWRegisterPtr unitControl;
public:
    std::vector<HWRegisterPtr> counterControl;
    std::vector<HWRegisterPtr> counterValue;
    HWRegisterPtr fixedCounterControl;
    HWRegisterPtr fixedCounterValue;
    HWRegisterPtr filter[2];
    enum {
        maxCounters = 8
    };

    UncorePMU(const HWRegisterPtr& unitControl_,
        const HWRegisterPtr& counterControl0,
        const HWRegisterPtr& counterControl1,
        const HWRegisterPtr& counterControl2,
        const HWRegisterPtr& counterControl3,
        const HWRegisterPtr& counterValue0,
        const HWRegisterPtr& counterValue1,
        const HWRegisterPtr& counterValue2,
        const HWRegisterPtr& counterValue3,
        const HWRegisterPtr& fixedCounterControl_ = HWRegisterPtr(),
        const HWRegisterPtr& fixedCounterValue_ = HWRegisterPtr(),
        const HWRegisterPtr& filter0 = HWRegisterPtr(),
        const HWRegisterPtr& filter1 = HWRegisterPtr()
    );
    UncorePMU(const HWRegisterPtr& unitControl_,
        const std::vector<HWRegisterPtr> & counterControl_,
        const std::vector<HWRegisterPtr> & counterValue_,
        const HWRegisterPtr& fixedCounterControl_ = HWRegisterPtr(),
        const HWRegisterPtr& fixedCounterValue_ = HWRegisterPtr(),
        const HWRegisterPtr& filter0 = HWRegisterPtr(),
        const HWRegisterPtr& filter1 = HWRegisterPtr()
    );
    UncorePMU() : cpu_family_model_(0U) {}
    size_t size() const { return counterControl.size(); }
    virtual ~UncorePMU() {}
    bool valid() const
    {
        return unitControl.get() != nullptr;
    }
    void cleanup();
    void freeze(const uint32 extra);
    bool initFreeze(const uint32 extra, const char* xPICheckMsg = nullptr);
    void unfreeze(const uint32 extra);
    void resetUnfreeze(const uint32 extra);
};

typedef std::shared_ptr<UncorePMU> UncorePMURef;

class IDX_PMU
{
    typedef std::shared_ptr<HWRegister> HWRegisterPtr;
    uint32 cpu_family_model_;
    uint32 getCPUFamilyModel();
    bool perf_mode_;
    uint32 numa_node_;
    uint32 socket_id_;
    HWRegisterPtr resetControl;
    HWRegisterPtr freezeControl;
public:
    HWRegisterPtr generalControl;
    std::vector<HWRegisterPtr> counterControl;
    std::vector<HWRegisterPtr> counterValue;
    std::vector<HWRegisterPtr> counterFilterWQ;
    std::vector<HWRegisterPtr> counterFilterENG;
    std::vector<HWRegisterPtr> counterFilterTC;
    std::vector<HWRegisterPtr> counterFilterPGSZ;
    std::vector<HWRegisterPtr> counterFilterXFERSZ;

    IDX_PMU(const bool perfMode_,
        const uint32 numaNode_,
        const uint32 socketId_,
        const HWRegisterPtr& resetControl_,
        const HWRegisterPtr& freezeControl_,
        const HWRegisterPtr& generalControl_,
        const std::vector<HWRegisterPtr> & counterControl,
        const std::vector<HWRegisterPtr> & counterValue,
        const std::vector<HWRegisterPtr> & counterFilterWQ,
        const std::vector<HWRegisterPtr> & counterFilterENG,
        const std::vector<HWRegisterPtr> & counterFilterTC,
        const std::vector<HWRegisterPtr> & counterFilterPGSZ,
        const std::vector<HWRegisterPtr> & counterFilterXFERSZ
    );

    IDX_PMU() : cpu_family_model_(0U), perf_mode_(false), numa_node_(0), socket_id_(0) {}
    size_t size() const { return counterControl.size(); }
    virtual ~IDX_PMU() {}
    bool valid() const
    {
        return resetControl.get() != nullptr;
    }
    void cleanup();
    void freeze();
    bool initFreeze();
    void unfreeze();
    void resetUnfreeze();
    bool getPERFMode();
    uint32 getNumaNode() const;
    uint32 getSocketId() const;
};

enum ServerUncoreMemoryMetrics
{
    PartialWrites,
    Pmem,
    PmemMemoryMode,
    PmemMixedMode
};

//! Object to access uncore counters in a socket/processor with microarchitecture codename SandyBridge-EP (Jaketown) or Ivytown-EP or Ivytown-EX
class ServerUncorePMUs
{
    friend class PCM;
    int32 iMCbus,UPIbus,M2Mbus;
    uint32 groupnr;
    int32 cpu_family_model;
    typedef std::vector<UncorePMU> UncorePMUVector;
    UncorePMUVector imcPMUs;
    UncorePMUVector edcPMUs;
    UncorePMUVector xpiPMUs;
    UncorePMUVector m3upiPMUs;
    UncorePMUVector m2mPMUs;
    UncorePMUVector haPMUs;
    UncorePMUVector hbm_m2mPMUs;
    std::vector<UncorePMUVector*> allPMUs{ &imcPMUs, &edcPMUs, &xpiPMUs, &m3upiPMUs , &m2mPMUs, &haPMUs, &hbm_m2mPMUs };
    std::vector<uint64> qpi_speed;
    std::vector<uint32> num_imc_channels; // number of memory channels in each memory controller
    std::vector<std::pair<uint32, uint32> > XPIRegisterLocation; // (device, function)
    std::vector<std::pair<uint32, uint32> > M3UPIRegisterLocation; // (device, function)
    std::vector<std::vector< std::pair<uint32, uint32> > > MCRegisterLocation; // MCRegisterLocation[controller]: (device, function)
    std::vector<std::pair<uint32, uint32> > EDCRegisterLocation; // EDCRegisterLocation: (device, function)
    std::vector<std::pair<uint32, uint32> > M2MRegisterLocation; // M2MRegisterLocation: (device, function)
    std::vector<std::pair<uint32, uint32> > HARegisterLocation;  // HARegisterLocation: (device, function)
    std::vector<std::pair<uint32, uint32> > HBM_M2MRegisterLocation; // HBM_M2MRegisterLocation: (device, function)

    static std::vector<std::pair<uint32, uint32> > socket2iMCbus;
    static std::vector<std::pair<uint32, uint32> > socket2UPIbus;
    static std::vector<std::pair<uint32, uint32> > socket2M2Mbus;

    ServerUncorePMUs();                                         // forbidden
    ServerUncorePMUs(ServerUncorePMUs &);                     // forbidden
    ServerUncorePMUs & operator = (const ServerUncorePMUs &); // forbidden
    static PciHandleType * createIntelPerfMonDevice(uint32 groupnr, int32 bus, uint32 dev, uint32 func, bool checkVendor = false);
    void programIMC(const uint32 * MCCntConfig);
    void programEDC(const uint32 * EDCCntConfig);
    void programM2M(const uint64 * M2MCntConfig);
    void programM2M();
    void programHA(const uint32 * config);
    void programHA();
    void programXPI(const uint32 * XPICntConfig);
    void programM3UPI(const uint32* M3UPICntConfig);
    typedef std::pair<size_t, std::vector<uint64 *> > MemTestParam;
    void initMemTest(MemTestParam & param);
    void doMemTest(const MemTestParam & param);
    void cleanupMemTest(const MemTestParam & param);
    void cleanupQPIHandles();
    void cleanupPMUs();
    void initDirect(uint32 socket_, const PCM * pcm);
    void initPerf(uint32 socket_, const PCM * pcm);
    void initBuses(uint32 socket_, const PCM * pcm);
    void initRegisterLocations(const PCM * pcm);
    uint64 getPMUCounter(std::vector<UncorePMU> & pmu, const uint32 id, const uint32 counter);
    bool HBMAvailable() const;

public:
    enum EventPosition {
        READ=0,
        WRITE=1,
        READ2=2,
        WRITE2=3,
        READ_RANK_A=0,
        WRITE_RANK_A=1,
        READ_RANK_B=2,
        WRITE_RANK_B=3,
        PARTIAL=2,
        PMM_READ=2,
        PMM_WRITE=3,
        MM_MISS_CLEAN=2,
        MM_MISS_DIRTY=3,
        NM_HIT=0,  // NM :  Near Memory (DRAM cache) in Memory Mode
        M2M_CLOCKTICKS=1
    };
    //! \brief Initialize access data structures
    //! \param socket_ socket id
    //! \param pcm pointer to PCM instance
    ServerUncorePMUs(uint32 socket_, const PCM * pcm);
    //! \brief Program performance counters (disables programming power counters)
    void program();
    //! \brief Get the number of integrated controller reads (in cache lines)
    uint64 getImcReads();
    //! \brief Get the number of integrated controller reads for given controller (in cache lines)
    //! \param controller controller ID/number
    uint64 getImcReadsForController(uint32 controller);
    //! \brief Get the number of integrated controller reads for given channels (in cache lines)
    //! \param beginChannel first channel in the range
    //! \param endChannel last channel + 1: the range is [beginChannel, endChannel). endChannel is not included.
    uint64 getImcReadsForChannels(uint32 beginChannel, uint32 endChannel);
    //! \brief Get the number of integrated controller writes (in cache lines)
    uint64 getImcWrites();
    //! \brief Get the number of requests to home agent (BDX/HSX only)
    uint64 getHALocalRequests();
    //! \brief Get the number of local requests to home agent (BDX/HSX only)
    uint64 getHARequests();
    //! \brief Get the number of Near Memory Hits
    uint64 getNMHits();
    //! \brief Get the number of Near Memory Misses
    uint64 getNMMisses();
    //! \brief Get the number of PMM memory reads (in cache lines)
    uint64 getPMMReads();
    //! \brief Get the number of PMM memory writes (in cache lines)
    uint64 getPMMWrites();

    //! \brief Get the number of cache lines read by EDC (embedded DRAM controller)
    uint64 getEdcReads();
    //! \brief Get the number of cache lines written by EDC (embedded DRAM controller)
    uint64 getEdcWrites();

    //! \brief Get the number of incoming data flits to the socket through a port
    //! \param port QPI port id
    uint64 getIncomingDataFlits(uint32 port);

    //! \brief Get the number of outgoing data and non-data or idle flits (depending on the architecture) from the socket through a port
    //! \param port QPI port id
    uint64 getOutgoingFlits(uint32 port);

    ~ServerUncorePMUs();

    //! \brief Program power counters (disables programming performance counters)
    //! \param mc_profile memory controller measurement profile. See description of profiles in pcm-power.cpp
    void program_power_metrics(int mc_profile);

    //! \brief Program memory counters (disables programming performance counters)
    //! \param rankA count DIMM rank1 statistics (disables memory channel monitoring)
    //! \param rankB count DIMM rank2 statistics (disables memory channel monitoring)
    //! \brief metrics metric set (see the ServerUncoreMemoryMetrics enum)
    void programServerUncoreMemoryMetrics(const ServerUncoreMemoryMetrics & metrics, const int rankA = -1, const int rankB = -1);

    //! \brief Get number of QPI LL clocks on a QPI port
    //! \param port QPI port number
    uint64 getQPIClocks(uint32 port);

    //! \brief Get number cycles on a QPI port when the link was in a power saving half-lane mode
    //! \param port QPI port number
    uint64 getQPIL0pTxCycles(uint32 port);
    //! \brief Get number cycles on a UPI port when the link was in a L0 mode (fully active)
    //! \param port UPI port number
    uint64 getUPIL0TxCycles(uint32 port);
    //! \brief Get number cycles on a QPI port when the link was in a power saving shutdown mode
    //! \param port QPI port number
    uint64 getQPIL1Cycles(uint32 port);
    //! \brief Get number DRAM channel cycles
    //! \param channel channel number
    uint64 getDRAMClocks(uint32 channel);
    //! \brief Get number HBM channel cycles
    //! \param channel channel number
    uint64 getHBMClocks(uint32 channel);
    //! \brief Direct read of memory controller PMU counter (counter meaning depends on the programming: power/performance/etc)
    //! \param channel channel number
    //! \param counter counter number
    uint64 getMCCounter(uint32 channel, uint32 counter);
    //! \brief Direct read of embedded DRAM memory controller PMU counter (counter meaning depends on the programming: power/performance/etc)
    //! \param channel channel number
    //! \param counter counter number
    uint64 getEDCCounter(uint32 channel, uint32 counter);
    //! \brief Direct read of QPI LL PMU counter (counter meaning depends on the programming: power/performance/etc)
    //! \param port port number
    //! \param counter counter number
    uint64 getQPILLCounter(uint32 port, uint32 counter);
    //! \brief Direct read of M3UPI PMU counter (counter meaning depends on the programming: power/performance/etc)
    //! \param port port number
    //! \param counter counter number
    uint64 getM3UPICounter(uint32 port, uint32 counter);
    //! \brief Direct read of M2M counter
    //! \param box box ID/number
    //! \param counter counter number
    uint64 getM2MCounter(uint32 box, uint32 counter);
    //! \brief Direct read of HA counter
    //! \param box box ID/number
    //! \param counter counter number
    uint64 getHACounter(uint32 box, uint32 counter);

    //! \brief Freezes event counting
    void freezeCounters();
    //! \brief Unfreezes event counting
    void unfreezeCounters();

    //! \brief Measures/computes the maximum theoretical QPI link bandwidth speed in GByte/seconds
    uint64 computeQPISpeed(const uint32 ref_core, const int cpumodel);

    //! \brief Enable correct counting of various LLC events (with memory access perf penalty)
    void enableJKTWorkaround(bool enable);

    //! \brief Returns the number of detected QPI ports
    size_t getNumQPIPorts() const { return xpiPMUs.size(); }

    //! \brief Returns the speed of the QPI link
    uint64 getQPILinkSpeed(const uint32 linkNr) const
    {
        return qpi_speed.empty() ? 0 : qpi_speed[linkNr];
    }

    //! \brief Print QPI Speeds
    void reportQPISpeed() const;

    //! \brief Returns the number of detected integrated memory controllers
    uint32 getNumMC() const { return (uint32)num_imc_channels.size(); }

    //! \brief Returns the total number of detected memory channels on all integrated memory controllers
    size_t getNumMCChannels() const { return (size_t)imcPMUs.size(); }

    //! \brief Returns the total number of detected memory channels on given integrated memory controller
    //! \param controller controller number
    size_t getNumMCChannels(const uint32 controller) const;

    //! \brief Returns the total number of detected memory channels on all embedded DRAM controllers (EDC)
    size_t getNumEDCChannels() const { return edcPMUs.size(); }
};

class SimpleCounterState
{
    template <class T>
    friend uint64 getNumberOfEvents(const T & before, const T & after);
    friend class PCM;
    uint64 data;
public:
    SimpleCounterState() : data(0)
    { }
    uint64 getRawData() const {return data;}
    virtual ~SimpleCounterState() { }
};

typedef SimpleCounterState PCIeCounterState;
typedef SimpleCounterState IIOCounterState;
typedef SimpleCounterState IDXCounterState;

typedef std::vector<uint64> eventGroup_t;

inline constexpr int PCM_CPU_FAMILY_MODEL(int family_, int model_)
{
    return ((family_) << 8) + (model_);
}

class PerfVirtualControlRegister;

/*!
        \brief CPU Performance Monitor

        This singleton object needs to be instantiated for each process
        before accessing counting and measuring routines
*/
class PCM_API PCM
{
    friend class BasicCounterState;
    friend class UncoreCounterState;
    friend class Socket;
    friend class ServerUncore;
    friend class ClientUncore;
    friend class PerfVirtualControlRegister;
    friend class Aggregator;
    friend class ServerUncorePMUs;
    PCM();     // forbidden to call directly because it is a singleton
    PCM(const PCM &) = delete;
    PCM & operator = (const PCM &) = delete;

    int32 cpu_family;
    int32 cpu_model_private;
    int32 cpu_family_model;
    bool hybrid = false;
    int32 cpu_stepping;
    int64 cpu_microcode_level;
    uint32 max_cpuid;
    int32 threads_per_core;
    int32 num_cores;
    int32 num_sockets;
    int32 num_phys_cores_per_socket;
    int32 num_online_cores;
    int32 num_online_sockets;
    mutable bool maxNumOfCBoxesBasedOnCoreCount{false};
    uint32 accel;
    uint32 accel_counters_num_max;
    uint32 core_gen_counter_num_max;
    uint32 core_gen_counter_num_used;
    uint32 core_gen_counter_width;
    uint32 core_fixed_counter_num_max;
    uint32 core_fixed_counter_num_used;
    uint32 core_fixed_counter_width;
    uint64 core_global_ctrl_value{0ULL};
    uint32 uncore_gen_counter_num_max;
    uint32 uncore_gen_counter_num_used;
    uint32 uncore_gen_counter_width;
    uint32 uncore_fixed_counter_num_max;
    uint32 uncore_fixed_counter_num_used;
    uint32 uncore_fixed_counter_width;
    uint32 perfmon_version;
    int32 perfmon_config_anythread;
    uint64 nominal_frequency;
    uint64 max_qpi_speed; // in GBytes/second
    uint32 L3ScalingFactor;
    int32 pkgThermalSpecPower, pkgMinimumPower, pkgMaximumPower;
    enum UFS_TPMI
    {
        UFS_ID = 2,
        UFS_FABRIC_CLUSTER_OFFSET = 1,
        UFS_STATUS = 0
    };
    struct UFSStatusEntry
    {
        std::shared_ptr<TPMIHandle> tpmiHandle;
        size_t pos;
        UFSStatusEntry() : tpmiHandle(nullptr), pos(0) {}
        UFSStatusEntry(const std::shared_ptr<TPMIHandle>& handle, size_t position) : tpmiHandle(handle), pos(position) {}
    };
    std::vector<std::vector<UFSStatusEntry> > UFSStatus;

    std::vector<TopologyEntry> topology;
    mutable std::unordered_map<uint32, int32> numaNodeToSocketCache; // Cache for mapNUMANodeToSocket
    mutable pcm::Mutex numaNodeToSocketCacheMutex; // Mutex to protect cache access
    SystemRoot* systemTopology;
    std::string errorMessage;

    static PCM * instance;
    static std::atomic<bool> quietMode;
    bool programmed_core_pmu{false};
    std::vector<std::shared_ptr<SafeMsrHandle> > MSR;
    std::vector<std::shared_ptr<ServerUncorePMUs> > serverUncorePMUs;

    typedef std::vector<UncorePMURef> UncorePMUArrayType;
public:
    enum UncorePMUIDs
    {
        CBO_PMU_ID,
        MDF_PMU_ID,
        PCU_PMU_ID,
        UBOX_PMU_ID,
        PCIE_GEN5x16_PMU_ID,
        PCIE_GEN5x8_PMU_ID,
        INVALID_PMU_ID
    };
private:
    std::unordered_map<std::string, int> strToUncorePMUID_ {
        {"pciex8", PCIE_GEN5x8_PMU_ID},
        {"pciex16", PCIE_GEN5x16_PMU_ID}
    };
public:
    UncorePMUIDs strToUncorePMUID(const std::string & type) const
    {
        const auto iter = strToUncorePMUID_.find(type);
        return (iter == strToUncorePMUID_.end()) ? INVALID_PMU_ID : (UncorePMUIDs)iter->second;
    }
    size_t getNumUFSDies() const
    {
        if (UFSStatus.empty()) return 0;

        return UFSStatus[0].size();
    }
private:
    typedef std::unordered_map<int, UncorePMUArrayType> UncorePMUMapType;
    // socket -> die -> pmu map -> pmu ref array
    std::vector< std::vector<UncorePMUMapType> > uncorePMUs;

    template <class F>
    void forAllUncorePMUs(F f)
    {
        for (auto& s : uncorePMUs)
        {
            for (auto& d : s)
            {
                for (auto& p : d)
                {
                    for (auto& e : p.second)
                    {
                        if (e.get())
                        {
                            f(*e);
                        }
                    }
                }
            }
        }
    }

    template <class F>
    void forAllUncorePMUs(const int pmu_id, F f)
    {
        for (auto& s : uncorePMUs)
        {
            for (auto& d : s)
            {
                for (auto& e : d[pmu_id])
                {
                    if (e.get())
                    {
                        f(*e);
                    }
                }
            }
        }
    }

    template <class F>
    void forAllUncorePMUs(const size_t socket_id, const int pmu_id, F f)
    {
        if (socket_id < uncorePMUs.size())
        {
            for (auto& d : uncorePMUs[socket_id])
            {
                for (auto& e : d[pmu_id])
                {
                    if (e.get())
                    {
                        f(*e);
                    }
                }
            }
        }
    }

    template <class T>
    void readUncoreCounterValues(T& result, const size_t socket) const
    {
        if (socket < uncorePMUs.size())
        {
            result.Counters.resize(uncorePMUs[socket].size());
            for (size_t die = 0; die < uncorePMUs[socket].size(); ++die)
            {
                TemporalThreadAffinity tempThreadAffinity(socketRefCore[socket]); // speedup trick for Linux

                for (auto pmuIter = uncorePMUs[socket][die].begin(); pmuIter != uncorePMUs[socket][die].end(); ++pmuIter)
                {
                    const auto & pmu_id = pmuIter->first;
                    result.Counters[die][pmu_id].resize(pmuIter->second.size());
                    for (size_t unit = 0; unit < pmuIter->second.size(); ++unit)
                    {
                        auto& pmu = pmuIter->second[unit];
                        for (size_t i = 0; pmu.get() != nullptr && i < pmu->size(); ++i)
                        {
                            DBG(4, "s " , socket , " d " , die , " pmu " , pmu_id , " unit " , unit , " ctr " , i );
                            result.Counters[die][pmu_id][unit][i] = *(pmu->counterValue[i]);
                        }
                    }
                }
            }
        }
    }

    uint64 getUncoreCounterState(const int pmu_id, const size_t socket, const uint32 ctr) const;

    template <class F>
    void programUncorePMUs(const int pmu_id, F pmuFunc)
    {
        if (MSR.empty()) return;

        for (size_t socket = 0; socket < uncorePMUs.size(); ++socket)
        {
            for (size_t die = 0; die < uncorePMUs[socket].size(); ++die)
            {
                TemporalThreadAffinity tempThreadAffinity(socketRefCore[socket]); // speedup trick for Linux

                for (size_t unit = 0; unit < uncorePMUs[socket][die][pmu_id].size(); ++unit)
                {
                    auto& pmu = uncorePMUs[socket][die][pmu_id][unit];
                    if (pmu.get())
                    {
                        pmuFunc(*pmu);
                    }
                }
            }
        }
    }

    // TODO: gradually move other PMUs to the uncorePMUs structure
    std::vector<std::map<int32, UncorePMU> > iioPMUs;
    std::vector<std::map<int32, UncorePMU> > irpPMUs;
    std::vector<std::vector<IDX_PMU> > idxPMUs;

    double joulesPerEnergyUnit;
    std::vector<std::shared_ptr<CounterWidthExtender> > energy_status;
    std::vector<std::shared_ptr<CounterWidthExtender> > dram_energy_status;
    std::vector<std::shared_ptr<CounterWidthExtender> > pp_energy_status;
    std::shared_ptr<CounterWidthExtender> system_energy_status;
    std::vector<std::vector<std::pair<UncorePMU, UncorePMU>>> cxlPMUs; // socket X CXL ports X UNIT {0,1}

    std::vector<std::shared_ptr<CounterWidthExtender> > memory_bw_local;
    std::vector<std::shared_ptr<CounterWidthExtender> > memory_bw_total;
#ifdef __linux__
    Resctrl resctrl;
#endif
    bool useResctrl;

    std::shared_ptr<FreeRunningBWCounters> clientBW;
    std::shared_ptr<CounterWidthExtender> clientImcReads;
    std::shared_ptr<CounterWidthExtender> clientImcWrites;
    std::shared_ptr<CounterWidthExtender> clientGtRequests;
    std::shared_ptr<CounterWidthExtender> clientIaRequests;
    std::shared_ptr<CounterWidthExtender> clientIoRequests;

    std::vector<std::shared_ptr<ServerBW> > serverBW;

    std::shared_ptr<UncorePMUDiscovery> uncorePMUDiscovery;

    template <class F>
    void getPCICFGPMUsFromDiscovery(const unsigned int BoxType, const size_t s, F f) const;

    bool disable_JKT_workaround;
    bool blocked;              // track if time-driven counter update is running or not: PCM is blocked

    uint64 * coreCStateMsr;    // MSR addresses of core C-state free-running counters
    uint64 * pkgCStateMsr;     // MSR addresses of package C-state free-running counters

    std::vector<std::shared_ptr<CoreTaskQueue> > coreTaskQueues;

    bool L2CacheHitRatioAvailable;
    bool L3CacheHitRatioAvailable;
    bool L3CacheMissesAvailable;
    bool L2CacheMissesAvailable;
    bool L2CacheHitsAvailable;
    bool L3CacheHitsNoSnoopAvailable;
    bool L3CacheHitsSnoopAvailable;
    bool L3CacheHitsAvailable;

    bool forceRTMAbortMode;

    std::vector<uint64> FrontendBoundSlots, BadSpeculationSlots, BackendBoundSlots, RetiringSlots, AllSlotsRaw;
    std::vector<uint64> MemBoundSlots, FetchLatSlots, BrMispredSlots, HeavyOpsSlots;
    bool isFixedCounterSupported(unsigned c);
    bool vm = false;
    bool linux_arch_perfmon = false;

public:

    size_t getMaxNumOfUncorePMUs(const int pmu_id, const size_t socket = 0) const
    {
        size_t count = 0ULL;
        if (socket < uncorePMUs.size())
        {
            const auto & s = uncorePMUs[socket];
            for (auto& d : s)
            {
                const auto iter = d.find(pmu_id);
                if (iter != d.end())
                {
                    count += iter->second.size();
                }
            }
        }
        return count;
    }
    enum { MAX_PP = 1 }; // max power plane number on Intel architecture (client)
    enum { MAX_C_STATE = 10 }; // max C-state on Intel architecture

    //! \brief Returns true if the specified core C-state residency metric is supported
    bool isCoreCStateResidencySupported(int state) const
    {
        if (state == 0 || state == 1)
            return true;

        return (coreCStateMsr != NULL && state <= ((int)MAX_C_STATE) && coreCStateMsr[state] != 0);
    }

    //! \brief Returns true if the specified package C-state residency metric is supported
    bool isPackageCStateResidencySupported(int state)
    {
        if (state == 0)
        {
            return true;
        }
        return (pkgCStateMsr != NULL && state <= ((int)MAX_C_STATE) && pkgCStateMsr[state] != 0);
    }

    //! \brief Redirects output destination to provided file, instead of std::cout and std::cerr (optional)
    static void setOutput(const std::string filename, const bool cerrToo = false);

    //! \brief Restores output, closes output file if opened
    void restoreOutput();

    //! \brief Set Run State.
    // Arguments:
    //  -- 1 - program is running
    //  -- 0 -pgram is sleeping
    void setRunState(int new_state) { run_state = new_state; }

    //! \brief Returns program's Run State.
    // Results:
    //  -- 1 - program is running
    //  -- 0 -pgram is sleeping
    int getRunState(void) { return run_state; }

    bool isBlocked(void) { return blocked; }
    void setBlocked(const bool new_blocked) { blocked = new_blocked; }

    //! Mode of programming (parameter in the program() method)
    enum ProgramMode {
        DEFAULT_EVENTS = 0,         /*!< Default choice of events, the additional parameter is not needed and ignored */
        CUSTOM_CORE_EVENTS = 1,     /*!< Custom set of core events specified in the parameter to the program method. The parameter must be a pointer to array of four \c CustomCoreEventDescription values */
        EXT_CUSTOM_CORE_EVENTS = 2, /*!< Custom set of core events specified in the parameter to the program method. The parameter must be a pointer to a \c ExtendedCustomCoreEventDescription  data structure */
        INVALID_MODE                /*!< Non-programmed mode */
    };

    //! Return codes (e.g. for program(..) method)
    enum ErrorCode {
        Success = 0,
        MSRAccessDenied = 1,
        PMUBusy = 2,
        UnknownError
    };

    enum PerfmonField {
        INVALID, /* Use to parse invalid field */
        OPCODE,
        EVENT_SELECT,
        UMASK,
        RESET,
        EDGE_DET,
        IGNORED,
        OVERFLOW_ENABLE,
        ENABLE,
        INVERT,
        THRESH,
        CH_MASK,
        FC_MASK,
        UNIT_TYPE,
        /* Below are not part of perfmon definition */
        H_EVENT_NAME,
        V_EVENT_NAME,
        MULTIPLIER,
        DIVIDER,
        COUNTER_INDEX
    };

    enum PCIeWidthMode {
        X1,
        X4,
        X8,
        X16,
        XFF
    };

    enum { // offsets/enumeration of IIO stacks
        IIO_CBDMA = 0, // shared with DMI
        IIO_PCIe0 = 1,
        IIO_PCIe1 = 2,
        IIO_PCIe2 = 3,
        IIO_MCP0 = 4,
        IIO_MCP1 = 5
    };

    // Offsets/enumeration of IIO stacks Skylake server.
    enum SkylakeIIOStacks {
        SKX_IIO_CBDMA_DMI   = 0,
        SKX_IIO_PCIe0       = 1,
        SKX_IIO_PCIe1       = 2,
        SKX_IIO_PCIe2       = 3,
        SKX_IIO_MCP0        = 4,
        SKX_IIO_MCP1        = 5,
        SKX_IIO_STACK_COUNT = 6
    };

     // Offsets/enumeration of IIO stacks for IceLake server.
    enum IcelakeIIOStacks {
        ICX_IIO_PCIe0       = 0,
        ICX_IIO_PCIe1       = 1,
        ICX_IIO_MCP0        = 2,
        ICX_IIO_PCIe2       = 3,
        ICX_IIO_PCIe3       = 4,
        ICX_IIO_CBDMA_DMI   = 5,
        ICX_IIO_STACK_COUNT = 6
    };

    // Offsets/enumeration of IIO stacks for IceLake server.
    enum SnowridgeIIOStacks {
        SNR_IIO_QAT         = 0,
        SNR_IIO_CBDMA_DMI   = 1,
        SNR_IIO_NIS         = 2,
        SNR_IIO_HQM         = 3,
        SNR_IIO_PCIe0       = 4,
        SNR_IIO_STACK_COUNT = 5
    };

    enum BDXIIOStacks {
        BDX_IIO_STACK_COUNT = 1
    };

    enum IDX_IP
    {
        IDX_IAA = 0,
        IDX_DSA,
        IDX_QAT,
        IDX_MAX
    };

    enum IDX_OPERATION
    {
        QAT_TLM_STOP = 0,
        QAT_TLM_START,
        QAT_TLM_REFRESH,
        QAT_TLM_MAX
    };

    enum IDX_STATE
    {
        IDX_STATE_OFF = 0,
        IDX_STATE_ON,
    };

    struct SimplePCIeDevInfo
    {
        enum PCIeWidthMode width;
        std::string pciDevName;
        std::string busNumber;

        SimplePCIeDevInfo() : width(XFF) { }
    };

    /*! \brief Custom Core event description

        See "Intel 64 and IA-32 Architectures Software Developers Manual Volume 3B:
        System Programming Guide, Part 2" for the concrete values of the data structure fields,
        e.g. Appendix A.2 "Performance Monitoring Events for Intel(r) Core(tm) Processor Family
        and Xeon Processor Family"
    */
    struct CustomCoreEventDescription
    {
        int32 event_number = 0, umask_value = 0;
    };

    /*! \brief Extended custom core event description

        In contrast to CustomCoreEventDescription supports configuration of all fields.

        See "Intel 64 and IA-32 Architectures Software Developers Manual Volume 3B:
        System Programming Guide, Part 2" for the concrete values of the data structure fields,
        e.g. Appendix A.2 "Performance Monitoring Events for Intel(r) Core(tm) Processor Family
        and Xeon Processor Family"
    */
    struct ExtendedCustomCoreEventDescription
    {
        FixedEventControlRegister * fixedCfg; // if NULL, then default configuration performed for fixed counters
        uint32 nGPCounters;                   // number of general purpose counters
        EventSelectRegister * gpCounterCfg;   // general purpose counters, if NULL, then default configuration performed for GP counters
        EventSelectRegister * gpCounterHybridAtomCfg; // general purpose counters for Atom cores in hybrid processors
        uint64 OffcoreResponseMsrValue[2];
        uint64 LoadLatencyMsrValue, FrontendMsrValue;
        bool defaultUncoreProgramming{true};
        static uint64 invalidMsrValue() { return ~0ULL; }
        ExtendedCustomCoreEventDescription() : fixedCfg(NULL), nGPCounters(0), gpCounterCfg(nullptr), gpCounterHybridAtomCfg(nullptr), LoadLatencyMsrValue(invalidMsrValue()), FrontendMsrValue(invalidMsrValue())
        {
            OffcoreResponseMsrValue[0] = 0;
            OffcoreResponseMsrValue[1] = 0;
        }
    };

    struct CustomIIOEventDescription
    {
        /* We program the same counters to every IIO Stacks */
        std::string eventNames[4];
        IIOPMUCNTCTLRegister eventOpcodes[4];
        int multiplier[4]; //Some IIO event requires transformation to get meaningful output (i.e. DWord to bytes)
        int divider[4]; //We usually like to have some kind of divider (i.e. /10e6 )
    };

    struct MSREventPosition
    {
        enum constants
        {
            index = 0,
            type = 1
        };
    };
    enum MSRType
    {
        Static = 0,
        Freerun = 1
    };

private:
    ProgramMode mode;
    CustomCoreEventDescription coreEventDesc[PERF_MAX_CUSTOM_COUNTERS];
    CustomCoreEventDescription hybridAtomEventDesc[PERF_MAX_CUSTOM_COUNTERS];

    std::vector<int32> socketRefCore;

    bool canUsePerf;
#ifdef PCM_USE_PERF
    typedef std::vector<std::vector<int> > PerfEventHandleContainer;
    PerfEventHandleContainer perfEventHandle;
    std::vector<PerfEventHandleContainer> perfEventTaskHandle;
    void readPerfData(uint32 core, std::vector<uint64> & data);
    void closePerfHandles(const bool silent = false);

    enum {
        PERF_INST_RETIRED_POS = 0,
        PERF_CPU_CLK_UNHALTED_THREAD_POS = 1,
        PERF_CPU_CLK_UNHALTED_REF_POS = 2,
        PERF_GEN_EVENT_0_POS = 3,
        PERF_GEN_EVENT_1_POS = 4,
        PERF_GEN_EVENT_2_POS = 5,
        PERF_GEN_EVENT_3_POS = 6,
        PERF_TOPDOWN_SLOTS_POS = PERF_GEN_EVENT_0_POS + PERF_MAX_CUSTOM_COUNTERS,
        PERF_TOPDOWN_FRONTEND_POS = PERF_TOPDOWN_SLOTS_POS + 1,
        PERF_TOPDOWN_BADSPEC_POS = PERF_TOPDOWN_SLOTS_POS + 2,
        PERF_TOPDOWN_BACKEND_POS = PERF_TOPDOWN_SLOTS_POS + 3,
        PERF_TOPDOWN_RETIRING_POS = PERF_TOPDOWN_SLOTS_POS + 4,
        PERF_TOPDOWN_MEM_BOUND_POS = PERF_TOPDOWN_SLOTS_POS + 5,
        PERF_TOPDOWN_FETCH_LAT_POS = PERF_TOPDOWN_SLOTS_POS + 6,
        PERF_TOPDOWN_BR_MISPRED_POS = PERF_TOPDOWN_SLOTS_POS + 7,
        PERF_TOPDOWN_HEAVY_OPS_POS = PERF_TOPDOWN_SLOTS_POS + 8
    };

    std::array<int, (PERF_TOPDOWN_HEAVY_OPS_POS + 1)> perfTopDownPos;

    enum {
        PERF_GROUP_LEADER_COUNTER = PERF_INST_RETIRED_POS,
        PERF_TOPDOWN_GROUP_LEADER_COUNTER = PERF_TOPDOWN_SLOTS_POS
    };
#endif
    static std::ofstream * outfile;       // output file stream
    static std::streambuf * backup_ofile; // backup of original output = cout
    static std::streambuf * backup_ofile_cerr; // backup of original output = cerr
    int run_state;                 // either running (1) or sleeping (0)

    bool needToRestoreNMIWatchdog;
    bool cleanupPEBS{false};

    std::vector<std::vector<EventSelectRegister> > lastProgrammedCustomCounters;
    uint32 checkCustomCoreProgramming(std::shared_ptr<SafeMsrHandle> msr);
    ErrorCode programCoreCounters(int core, const PCM::ProgramMode mode, const ExtendedCustomCoreEventDescription * pExtDesc,
        std::vector<EventSelectRegister> & programmedCustomCounters, const std::vector<int> & tids);

    bool PMUinUse();
    void cleanupPMU(const bool silent = false);
    void cleanupRDT(const bool silent = false);

    void computeQPISpeedBeckton(int core_nr);
    void destroyMSR();
    void computeNominalFrequency();
    static bool isCPUModelSupported(const int model_);
    std::string getSupportedUarchCodenames() const;
    std::string getUnsupportedMessage() const;
    bool detectModel();
    bool checkModel();

    void initCStateSupportTables();
    bool discoverSystemTopology();
    void printSystemTopology() const;
    bool initMSR();
    bool detectNominalFrequency();
    void showSpecControlMSRs();
    void initEnergyMonitoring();
    void initUncoreObjects();
    /*!
    *       \brief initializes each core with an RMID
    *
    *       \returns nothing
    */
    void initRDT();
    /*!
     *      \brief Initializes RDT
     *
     *      Initializes RDT infrastructure through resctrl Linux driver or direct MSR programming.
     *      For the latter: initializes each core event MSR with an RMID for QOS event (L3 cache monitoring or memory bandwidth monitoring)
     *      \returns nothing
    */
    void initQOSevent(const uint64 event, const int32 core);
    void programBecktonUncore(int core);
    void programNehalemEPUncore(int core);
    void enableJKTWorkaround(bool enable);
    template <class CounterStateType>
    void readAndAggregateMemoryBWCounters(const uint32 core, CounterStateType & counterState);
    template <class CounterStateType>
    void readAndAggregateUncoreMCCounters(const uint32 socket, CounterStateType & counterState);
    template <class CounterStateType>
    void readAndAggregateEnergyCounters(const uint32 socket, CounterStateType & counterState);
    template <class CounterStateType>
    void readPackageThermalHeadroom(const uint32 socket, CounterStateType & counterState);
    template <class CounterStateType>
    void readAndAggregatePackageCStateResidencies(std::shared_ptr<SafeMsrHandle> msr, CounterStateType & result);
public:
    struct RawPMUConfig;
    void programCXLCM();
    void programCXLDP();
    template <class CounterStateType>
    void readAndAggregateCXLCMCounters(CounterStateType & counterState);

private:
    template <class CounterStateType>
    void readMSRs(std::shared_ptr<SafeMsrHandle> msr, const RawPMUConfig & msrConfig, CounterStateType & result);
    void readQPICounters(SystemCounterState & counterState);
    void readSystemEnergyStatus(SystemCounterState & systemState);
    void readPCICFGRegisters(SystemCounterState& result);
    void readTPMIRegisters(SystemCounterState& result);
    void readMMIORegisters(SystemCounterState& result);
    void readPMTRegisters(SystemCounterState& result);
    void reportQPISpeed() const;
    void readCoreCounterConfig(const bool complainAboutMSR = false);
    void readCPUMicrocodeLevel();
    void globalFreezeUncoreCountersInternal(const unsigned long long int freeze);

    uint64 CX_MSR_PMON_CTRY(uint32 Cbo, uint32 Ctr) const;
    uint64 CX_MSR_PMON_BOX_FILTER(uint32 Cbo) const;
    uint64 CX_MSR_PMON_BOX_FILTER1(uint32 Cbo) const;
    uint64 CX_MSR_PMON_CTLY(uint32 Cbo, uint32 Ctl) const;
    uint64 CX_MSR_PMON_BOX_CTL(uint32 Cbo) const;
    uint32 getMaxNumOfCBoxesInternal() const;
    void programCboOpcodeFilter(const uint32 opc0, UncorePMU & pmu, const uint32 nc_, const uint32 opc1, const uint32 loc, const uint32 rem);
    void initLLCReadMissLatencyEvents(uint64 * events, uint32 & opCode);
    void initCHARequestEvents(uint64 * events);
    void programCbo();
    template <class Iterator>
    static void program(UncorePMU& pmu, const Iterator& eventsBegin, const Iterator& eventsEnd, const uint32 extra)
    {
        if (!eventsBegin) return;
        Iterator curEvent = eventsBegin;
        const auto cpu_family_model = PCM::getInstance()->getCPUFamilyModel();
        for (int c = 0; curEvent != eventsEnd && size_t(c) < pmu.size(); ++c, ++curEvent)
        {
            auto ctrl = pmu.counterControl[c];
            if (ctrl.get() != nullptr)
            {
                switch (cpu_family_model)
                {
                case SPR:
                case EMR:
                case GNR:
                case GNR_D:
                case GRR:
                case SRF:
                    *ctrl = *curEvent;
                    break;
                default:
                    *ctrl = MC_CH_PCI_PMON_CTL_EN;
                    *ctrl = MC_CH_PCI_PMON_CTL_EN | *curEvent;
                }
            }
        }
        if (extra)
        {
            pmu.resetUnfreeze(extra);
        }
    }
    void programPCU(uint32 * events, const uint64 filter);
    void programUBOX(const uint64* events);
    void programCXLDP(const uint64* events);
    void programCXLCM(const uint64* events);
    void cleanupUncorePMUs(const bool silent = false);

    static bool isCLX(int cpu_family_model_, int cpu_stepping_)
    {
        return (PCM::SKX == cpu_family_model_) && (cpu_stepping_ > 4 && cpu_stepping_ < 8);
    }

    bool isCLX() const // Cascade Lake-SP
    {
        return isCLX(cpu_family_model, cpu_stepping);
    }

    static bool isCPX(int cpu_family_model_, int cpu_stepping_) // Cooper Lake
    {
        return (PCM::SKX == cpu_family_model_) && (cpu_stepping_ >= 10);
    }

    bool isCPX() const
    {
        return isCPX(cpu_family_model, cpu_stepping);
    }

    void initUncorePMUsDirect();
    void initUncorePMUsPerf();
    bool isRDTDisabled() const;

#ifdef __linux__
    bool perfSupportsTopDown();
#endif

public:
    static bool isInitialized() { return instance != nullptr; }

    /*!
        \brief Set quiet mode for PCM initialization

        When quiet mode is enabled, only errors are output during PCM initialization.
        This method should be called before getInstance() is called for the first time.

        \param enable true to enable quiet mode, false to disable
    */
    static void setQuietMode(bool enable) { quietMode = enable; }

    /*!
        \brief Check if quiet mode is enabled

        \return true if quiet mode is enabled, false otherwise
    */
    static bool getQuietMode() { return quietMode; }

    //! check if TMA level 1 metrics are supported
    bool isHWTMAL1Supported() const;

    //! check if TMA level 2 metrics are supported
    bool isHWTMAL2Supported() const
    {
        return isHWTMAL1Supported() &&
                (
                    SPR == cpu_family_model
                ||  EMR == cpu_family_model
                ||  GNR == cpu_family_model
                ||  GNR_D == cpu_family_model
                );
    }

    enum EventPosition
    {
        TOR_OCCUPANCY = 0,
        TOR_INSERTS = 1,
        REQUESTS_ALL = 2,
        REQUESTS_LOCAL = 3,
        CXL_TxC_MEM = 0,   // works only on counters 0-3
        CXL_TxC_CACHE = 1, // works only on counters 0-3
        CXL_RxC_MEM = 4,   // works only on counters 4-7
        CXL_RxC_CACHE = 5  // works only on counters 4-7
    };
    //! check if in secure boot mode
    bool isSecureBoot() const;

    //! true if Linux perf for uncore PMU programming should AND can be used internally
    bool useLinuxPerfForUncore() const;

    //! true if the CPU is hybrid
    bool isHybrid() const
    {
        return hybrid;
    }

    /*!
             \brief The system, sockets, uncores, cores and threads are structured like a tree

             \returns a reference to a const System object representing the root of the tree
     */
    SystemRoot const & getSystemTopology() const {
        return *systemTopology;
    }

    //! prints detailed system topology
    void printDetailedSystemTopology(const int detailLevel = 0);

    /*!
             \brief checks if QOS monitoring support present

             \returns true or false
     */
    bool QOSMetricAvailable() const;
    /*!
             \brief checks L3 cache support for QOS present

             \returns true or false
     */
    bool L3QOSMetricAvailable() const;
    /*!
             \brief checks if L3 cache monitoring present

             \returns true or false
     */
    bool L3CacheOccupancyMetricAvailable() const;
    /*!
            \brief checks if local memory bandwidth monitoring present

            \returns true or false
    */
    bool CoreLocalMemoryBWMetricAvailable() const;
    /*!
    \brief checks if total memory bandwidth monitoring present

    \returns true or false
    */
    bool CoreRemoteMemoryBWMetricAvailable() const;
    /*!
     *      \brief returns the max number of RMID supported by socket
     *
     *      \returns maximum number of RMID supported by socket
     */
    unsigned getMaxRMID() const;

    //! \brief Returns the number of IIO stacks per socket
    uint32 getMaxNumOfIIOStacks() const;

    //! \brief Returns the number of IO stacks per socket
    uint32 getMaxNumOfIOStacks() const;

    /*! \brief Returns the number of IDX accel devs
        \param accel index of IDX accel
    */
    uint32 getNumOfIDXAccelDevs(int accel) const;

    //! \brief Returns the number of IDX counters
    uint32 getMaxNumOfIDXAccelCtrs(int accel) const;

    //! \brief Returns the numa node of IDX accel dev
    uint32 getNumaNodeOfIDXAccelDev(uint32 accel, uint32 dev) const;

    //! \brief Returns the socketid of IDX accel dev
    uint32 getCPUSocketIdOfIDXAccelDev(uint32 accel, uint32 dev) const;

    //! \brief Returns the platform support IDX accel dev or NOT
    bool supportIDXAccelDev() const;

    /*!
            \brief Returns PCM object

            Returns PCM object. If the PCM has not been created before than
            an instance is created. PCM is a singleton.

            \return Pointer to PCM object
    */
    static PCM * getInstance();        // the only way to get access

    /*!
            \brief Checks the status of PCM object

            Call this method to check if PCM gained access to model specific registers. The method is deprecated, see program error code instead.

            \return true iff access to model specific registers works without problems
    */
    bool good();                       // true if access to CPU counters works

    /*! \brief Returns the error message

                Call this when good() returns false, otherwise return an empty string
    */
    const std::string & getErrorMessage() const
    {
        return errorMessage;
    }

    /*! \brief Programs performance counters
        \param mode_ mode of programming, see ProgramMode definition
        \param parameter_ optional parameter for some of programming modes
        \param silent set to true to silence diagnostic messages
        \param pid restrict core metrics only to specified pid (process id)

                Call this method before you start using the performance counting routines.

        \warning Using this routines with other tools that *program* Performance Monitoring
        Units (PMUs) on CPUs is not recommended because PMU can not be shared. Tools that are known to
        program PMUs: Intel(r) VTune(tm), Intel(r) Performance Tuning Utility (PTU). This code may make
        VTune or PTU measurements invalid. VTune or PTU measurement may make measurement with this code invalid. Please enable either usage of these routines or VTune/PTU/etc.
    */
    ErrorCode program(const ProgramMode mode_ = DEFAULT_EVENTS, const void * parameter_ = NULL, const bool silent = false, const int pid = -1); // program counters and start counting

    /*! \brief checks the error without side effects.
        \throw std::system_error generic_category exception with PCM error code.
        \param code error code from the 'program' call
    */
    void checkStatus(const ErrorCode status);

    /*! \brief checks the error and suggests solution and/or exits the process
        \param code error code from the 'program' call
    */
    void checkError(const ErrorCode code);

    /*! \brief Programs uncore latency counters on microarchitectures codename SandyBridge-EP and later Xeon uarch
        \param enable_pmm enables DDR/PMM. See possible profile values in pcm-latency.cpp example

        Call this method before you start using the latency counter routines on microarchitecture codename SandyBridge-EP and later Xeon uarch

        \warning After this call the memory and QPI bandwidth counters on microarchitecture codename SandyBridge-EP and later Xeon uarch will not work.
        \warning Using this routines with other tools that *program* Performance Monitoring
        Units (PMUs) on CPUs is not recommended because PMU can not be shared. Tools that are known to
        program PMUs: Intel(r) VTune(tm), Intel(r) Performance Tuning Utility (PTU). This code may make
        VTune or PTU measurements invalid. VTune or PTU measurement may make measurement with this code invalid. Please enable either usage of these routines or VTune/PTU/etc.
    */
    ErrorCode programServerUncoreLatencyMetrics(bool enable_pmm);

    /*! \brief Programs uncore power/energy counters on microarchitectures codename SandyBridge-EP and later Xeon uarch
        \param mc_profile profile for integrated memory controller PMU. See possible profile values in pcm-power.cpp example
        \param pcu_profile profile for power control unit PMU. See possible profile values in pcm-power.cpp example
        \param freq_bands array of three integer values for core frequency band monitoring. See usage in pcm-power.cpp example

        Call this method before you start using the power counter routines on microarchitecture codename SandyBridge-EP and later Xeon uarch

        \warning After this call the memory and QPI bandwidth counters on microarchitecture codename SandyBridge-EP and later Xeon uarch will not work.
        \warning Using this routines with other tools that *program* Performance Monitoring
        Units (PMUs) on CPUs is not recommended because PMU can not be shared. Tools that are known to
        program PMUs: Intel(r) VTune(tm), Intel(r) Performance Tuning Utility (PTU). This code may make
        VTune or PTU measurements invalid. VTune or PTU measurement may make measurement with this code invalid. Please enable either usage of these routines or VTune/PTU/etc.
    */
    ErrorCode programServerUncorePowerMetrics(int mc_profile, int pcu_profile, int * freq_bands = NULL);

    /*  \brief Program memory counters (disables programming performance counters)
        \param rankA count DIMM rank1 statistics (disables memory channel monitoring)
        \param rankB count DIMM rank2 statistics (disables memory channel monitoring)
        \brief metrics metric set (see the ServerUncoreMemoryMetrics enum)

        Call this method before you start using the memory counter routines on microarchitecture codename SandyBridge-EP and later Xeon uarch

        \warning Using this routines with other tools that *program* Performance Monitoring
        Units (PMUs) on CPUs is not recommended because PMU can not be shared. Tools that are known to
        program PMUs: Intel(r) VTune(tm), Intel(r) Performance Tuning Utility (PTU). This code may make
        VTune or PTU measurements invalid. VTune or PTU measurement may make measurement with this code invalid. Please enable either usage of these routines or VTune/PTU/etc.
    */
    ErrorCode programServerUncoreMemoryMetrics(const ServerUncoreMemoryMetrics & metrics, int rankA = -1, int rankB = -1);

    // vector of IDs. E.g. for core {raw event} or {raw event, offcore response1 msr value, } or {raw event, offcore response1 msr value, offcore response2}
    // or for cha/cbo {raw event, filter value}, etc
    // + user-supplied name
    typedef std::array<uint64, 6> RawEventEncoding;
    typedef std::pair<RawEventEncoding, std::string> RawEventConfig;
    struct RawPMUConfig
    {
        std::vector<RawEventConfig> programmable;
        std::vector<RawEventConfig> fixed;
    };
    enum {
        OCR0Pos = 1,
        OCR1Pos = 2,
        LoadLatencyPos = 3,
        FrontendPos = 4
    };
    typedef std::map<std::string, RawPMUConfig> RawPMUConfigs;
    ErrorCode program(const RawPMUConfigs& curPMUConfigs, const bool silent = false, const int pid = -1);

    struct TPMIEventPosition
    {
        enum constants
        {
            ID = 0,
            offset = 1,
            type = 2
        };
    };
    typedef std::shared_ptr<TPMIHandle> TPMIRegisterEncoding; // = TPMIHandle shared ptr
    struct TPMIRegisterEncodingHash
    {
        std::size_t operator()(const RawEventEncoding & e) const
        {
            std::size_t h1 = std::hash<uint64>{}(e[TPMIEventPosition::ID]);
            std::size_t h2 = std::hash<uint64>{}(e[TPMIEventPosition::offset]);
            return h1 ^ (h2 << 1ULL);
        }
    };
    struct TPMIRegisterEncodingCmp
    {
        bool operator ()(const RawEventEncoding& a, const RawEventEncoding& b) const
        {
            return a[TPMIEventPosition::ID] == b[TPMIEventPosition::ID]
                && a[TPMIEventPosition::offset] == b[TPMIEventPosition::offset];
        }
    };

    struct PCICFGEventPosition
    {
        enum constants
        {
            deviceID = 0,
            offset = 1,
            type = 2,
            width = 5
        };
    };
    typedef std::pair<std::shared_ptr<PciHandleType>, uint32> PCICFGRegisterEncoding; // PciHandleType shared ptr, offset
    struct PCICFGRegisterEncodingHash
    {
        std::size_t operator()(const RawEventEncoding & e) const
        {
            std::size_t h1 = std::hash<uint64>{}(e[PCICFGEventPosition::deviceID]);
            std::size_t h2 = std::hash<uint64>{}(e[PCICFGEventPosition::offset]);
            std::size_t h3 = std::hash<uint64>{}(e[PCICFGEventPosition::width]);
            return h1 ^ (h2 << 1ULL) ^ (h3 << 2ULL);
        }
    };
    struct PCICFGRegisterEncodingCmp
    {
        bool operator ()(const RawEventEncoding& a, const RawEventEncoding& b) const
        {
            return a[PCICFGEventPosition::deviceID] == b[PCICFGEventPosition::deviceID]
                && a[PCICFGEventPosition::offset] == b[PCICFGEventPosition::offset]
                && a[PCICFGEventPosition::width] == b[PCICFGEventPosition::width];
        }
    };
    struct MMIOEventPosition
    {
        enum constants
        {
            deviceID = PCICFGEventPosition::deviceID,
            offset = PCICFGEventPosition::offset,
            type = PCICFGEventPosition::type,
            membar_bits1 = 3,
            membar_bits2 = 4,
            width = PCICFGEventPosition::width
        };
    };
    typedef std::pair<std::shared_ptr<MMIORange>, uint32> MMIORegisterEncoding; // MMIORange shared ptr, offset
    struct MMIORegisterEncodingHash : public PCICFGRegisterEncodingHash
    {
        // cppcheck-suppress duplInheritedMember
        std::size_t operator()(const RawEventEncoding& e) const
        {
            std::size_t h4 = std::hash<uint64>{}(e[MMIOEventPosition::membar_bits1]);
            std::size_t h5 = std::hash<uint64>{}(e[MMIOEventPosition::membar_bits2]);
            return PCICFGRegisterEncodingHash::operator()(e) ^ (h4 << 3ULL) ^ (h5 << 4ULL);
        }
    };
    struct MMIORegisterEncodingCmp : public PCICFGRegisterEncodingCmp
    {
        // cppcheck-suppress duplInheritedMember
        bool operator ()(const RawEventEncoding& a, const RawEventEncoding& b) const
        {
            return PCICFGRegisterEncodingCmp::operator()(a,b)
                && a[MMIOEventPosition::membar_bits1] == b[MMIOEventPosition::membar_bits1]
                && a[MMIOEventPosition::membar_bits2] == b[MMIOEventPosition::membar_bits2];
        }
    };
    struct PMTEventPosition
    {
        enum constants
        {
            UID = PCICFGEventPosition::deviceID,
            offset = PCICFGEventPosition::offset,
            type = PCICFGEventPosition::type,
            lsb = 3,
            msb = 4
        };
    };
    struct PMTRegisterEncodingHash
    {
        std::size_t operator()(const RawEventEncoding & e) const
        {
            return std::hash<uint64>{}(e[PMTEventPosition::UID]);
        }
    };
    struct PMTRegisterEncodingHash2
    {
        std::size_t operator()(const RawEventEncoding & e) const
        {
            std::size_t h1 = std::hash<uint64>{}(e[PMTEventPosition::UID]);
            std::size_t h2 = std::hash<uint64>{}(e[PMTEventPosition::offset]);
            std::size_t h3 = std::hash<uint64>{}(e[PMTEventPosition::lsb]);
            return h1 ^ (h2 << 1ULL) ^ (h3 << 2ULL);
        }
    };
    struct PMTRegisterEncodingCmp
    {
        bool operator ()(const RawEventEncoding& a, const RawEventEncoding& b) const
        {
            return a[PMTEventPosition::UID] == b[PMTEventPosition::UID];
        }
    };
    typedef std::shared_ptr<TelemetryArray> PMTRegisterEncoding; // TelemetryArray shared ptr
private:
    std::unordered_map<RawEventEncoding, std::vector<TPMIRegisterEncoding>, TPMIRegisterEncodingHash, TPMIRegisterEncodingCmp> TPMIRegisterLocations{};
    std::unordered_map<RawEventEncoding, std::vector<PCICFGRegisterEncoding>, PCICFGRegisterEncodingHash, PCICFGRegisterEncodingCmp> PCICFGRegisterLocations{};
    std::unordered_map<RawEventEncoding, std::vector<MMIORegisterEncoding>, MMIORegisterEncodingHash, MMIORegisterEncodingCmp> MMIORegisterLocations{};
    std::unordered_map<RawEventEncoding, std::vector<PMTRegisterEncoding>, PMTRegisterEncodingHash, PMTRegisterEncodingCmp> PMTRegisterLocations{};
public:

    TopologyEntry::CoreType getCoreType(const unsigned coreID) const
    {
        assert(coreID < topology.size());
        return topology[coreID].core_type;
    }

    std::pair<unsigned, unsigned> getOCREventNr(const int event, const unsigned coreID) const
    {
       assert (coreID < topology.size());
       const auto eCoreOCREvent = std::make_pair(OFFCORE_RESPONSE_0_EVTNR, event + 1);
       if (hybrid)
       {
            switch (cpu_family_model)
            {
            case ADL:
            case RPL:
            case MTL:
            case LNL:
            case ARL:
            case PTL:
                if (topology[coreID].core_type == TopologyEntry::Atom)
                {
                    return eCoreOCREvent;
                }
                break;
            }
       }
       bool useGLCOCREvent = false;
       switch (cpu_family_model)
       {
       case SPR:
       case EMR:
       case GNR:
       case GNR_D:
       case ADL: // ADL big core (GLC)
       case RPL:
       case MTL:
       case LNL:
       case ARL:
       case PTL:
           useGLCOCREvent = true;
           break;

       case ATOM:
       case ATOM_2:
       case CENTERTON:
       case BAYTRAIL:
       case AVOTON:
       case CHERRYTRAIL:
       case APOLLO_LAKE:
       case GEMINI_LAKE:
       case DENVERTON:
       case SNOWRIDGE:
       case ELKHART_LAKE:
       case JASPER_LAKE:
       case SRF:
       case GRR:
            return eCoreOCREvent;
       }
       switch (event)
       {
            case 0:
                return std::make_pair(useGLCOCREvent ? GLC_OFFCORE_RESPONSE_0_EVTNR : OFFCORE_RESPONSE_0_EVTNR, OFFCORE_RESPONSE_0_UMASK);
            case 1:
                return std::make_pair(useGLCOCREvent ? GLC_OFFCORE_RESPONSE_1_EVTNR : OFFCORE_RESPONSE_1_EVTNR, OFFCORE_RESPONSE_1_UMASK);
       }
       assert (false && "wrong event nr in getOCREventNr");
       return std::make_pair(0U, 0U);
    }

    //! \brief Freezes uncore event counting using global control MSR
    void globalFreezeUncoreCounters();

    //! \brief Unfreezes uncore event counting using global control MSR
    void globalUnfreezeUncoreCounters();

    //! \brief Freezes uncore event counting
    void freezeServerUncoreCounters();

    //! \brief Unfreezes uncore event counting
    void unfreezeServerUncoreCounters();

    /*! \brief Reads the power/energy counter state of a socket (works only on microarchitecture codename SandyBridge-EP)
        \param socket socket id
        \return State of power counters in the socket
    */
    ServerUncoreCounterState getServerUncoreCounterState(uint32 socket);

    /*! \brief Cleanups resources and stops performance counting

            One needs to call this method when your program finishes or/and you are not going to use the
            performance counting routines anymore.
    */
    void cleanup(const bool silent = false);

    /*! \brief Forces PMU reset

                If there is no chance to free up PMU from other applications you might try to call this method at your own risk.
    */
    void resetPMU();

    /*! \brief Reads all counter states (including system, sockets and cores)

        \param systemState system counter state (return parameter)
        \param socketStates socket counter states (return parameter)
        \param coreStates core counter states (return parameter)
        \param readAndAggregateSocketUncoreCounters read and aggregate socket uncore counters

    */
    void getAllCounterStates(SystemCounterState & systemState, std::vector<SocketCounterState> & socketStates, std::vector<CoreCounterState> & coreStates, const bool readAndAggregateSocketUncoreCounters = true);

    /*! \brief Reads uncore counter states (including system and sockets) but no core counters

    \param systemState system counter state (return parameter)
    \param socketStates socket counter states (return parameter)

    */
    void getUncoreCounterStates(SystemCounterState & systemState, std::vector<SocketCounterState> & socketStates);

    /*! \brief Return true if the core in online

        \param os_core_id OS core id
    */
    bool isCoreOnline(int32 os_core_id) const;

    /*! \brief Return true if the socket in online

        \param socket_id OS socket id
    */
    bool isSocketOnline(int32 socket_id) const;

    /*! \brief Reads the counter state of the system

            System consists of several sockets (CPUs).
            Socket has a CPU in it. Socket (CPU) consists of several (logical) cores.

            \return State of counters in the entire system
    */
    SystemCounterState getSystemCounterState();

    /*! \brief Reads the counter state of a socket
            \param socket socket id
            \return State of counters in the socket
    */
    SocketCounterState getSocketCounterState(uint32 socket);

    /*! \brief Reads the counter state of a (logical) core

        Be aware that during the measurement other threads may be scheduled on the same core by the operating system (this is called context-switching). The performance events caused by these threads will be counted as well.


            \param core core id
            \return State of counters in the core
    */
    CoreCounterState getCoreCounterState(uint32 core);

    /*! \brief Reads number of logical cores in the system
            \return Number of logical cores in the system
    */
    uint32 getNumCores() const;

    /*! \brief Reads number of online logical cores in the system
            \return Number of online logical cores in the system
    */
    uint32 getNumOnlineCores() const;

    /*! \brief Reads number of sockets (CPUs) in the system
            \return Number of sockets in the system
    */
    uint32 getNumSockets() const;

    /*! \brief Reads  the accel type in the system
        \return acceltype
    */
    uint32 getAccel() const;

    /*! \brief Sets  the accel type in the system
        \return acceltype
    */
    void setAccel(uint32 input);

    /*! \brief Reads the Number of AccelCounters in the system
        \return None
    */
    uint32 getNumberofAccelCounters() const;

    /*! \brief Sets the Number of AccelCounters in the system
        \return number of counters
    */
    void setNumberofAccelCounters(uint32 input);

    /*! \brief Reads number of online sockets (CPUs) in the system
        \return Number of online sockets in the system
    */
    uint32 getNumOnlineSockets() const;

    /*! \brief Reads how many hardware threads has a physical core
            "Hardware thread" is a logical core in a different terminology.
            If Intel(r) Hyperthreading(tm) is enabled then this function returns 2.
            \return Number of hardware threads per physical core
    */
    uint32 getThreadsPerCore() const;

    /*! \brief Checks if SMT (HyperThreading) is enabled.
            \return true iff SMT (HyperThreading) is enabled.
    */
    bool getSMT() const; // returns true iff SMT ("Hyperthreading") is on

    /*! \brief Reads the nominal core frequency
            \return Nominal frequency in Hz
    */
    uint64 getNominalFrequency() const; // in Hz

    /*! \brief runs CPUID.0xF.0x01 to get the L3 up scaling factor to calculate L3 Occupancy
     *  Scaling factor is returned in EBX register after running the CPU instruction
     * \return L3 up scaling factor
     */
    uint32 getL3ScalingFactor() const;

    /*! \brief runs CPUID.0xB.0x01 to get maximum logical cores (including SMT) per socket.
     *  max_lcores_per_socket is returned in EBX[15:0]. Compare this value with number of cores per socket
     *  detected in the system to see if some cores are offlined
     * \return true iff max_lcores_per_socket == number of cores per socket detected
     */
    bool isSomeCoreOfflined();

    //! \brief Returns true if the CBox or CHA PMU count detection relies on physical core count
    bool isMaxNumOfCBoxesBasedOnCoreCount() const
    {
        return maxNumOfCBoxesBasedOnCoreCount;
    }

    /*! \brief Returns the maximum number of custom (general-purpose) core events supported by CPU
    */
    int32 getMaxCustomCoreEvents();

    /*! \brief Returns cpu model id number from cpuid instruction
    */
    /*
    static int getCPUModelFromCPUID();
    */

    /*! \brief Returns cpu family and model id number from cpuid instruction
    *   \return cpu family and model id number (model id is in the lower 8 bits, family id is in the next 8 bits)
    */
    static int getCPUFamilyModelFromCPUID();

    //! \brief Identifiers of supported CPU models
    enum SupportedCPUModels
    {
        NEHALEM_EP =    PCM_CPU_FAMILY_MODEL(6, 26),
        NEHALEM =       PCM_CPU_FAMILY_MODEL(6, 30),
        ATOM =          PCM_CPU_FAMILY_MODEL(6, 28),
        ATOM_2 =        PCM_CPU_FAMILY_MODEL(6, 53),
        CENTERTON =     PCM_CPU_FAMILY_MODEL(6, 54),
        BAYTRAIL =      PCM_CPU_FAMILY_MODEL(6, 55),
        AVOTON =        PCM_CPU_FAMILY_MODEL(6, 77),
        CHERRYTRAIL =   PCM_CPU_FAMILY_MODEL(6, 76),
        APOLLO_LAKE =   PCM_CPU_FAMILY_MODEL(6, 92),
        GEMINI_LAKE =   PCM_CPU_FAMILY_MODEL(6, 122),
        DENVERTON =     PCM_CPU_FAMILY_MODEL(6, 95),
        SNOWRIDGE =     PCM_CPU_FAMILY_MODEL(6, 134),
        ELKHART_LAKE =  PCM_CPU_FAMILY_MODEL(6, 150),
        JASPER_LAKE =   PCM_CPU_FAMILY_MODEL(6, 156),
        CLARKDALE =     PCM_CPU_FAMILY_MODEL(6, 37),
        WESTMERE_EP =   PCM_CPU_FAMILY_MODEL(6, 44),
        NEHALEM_EX =    PCM_CPU_FAMILY_MODEL(6, 46),
        WESTMERE_EX =   PCM_CPU_FAMILY_MODEL(6, 47),
        SANDY_BRIDGE =  PCM_CPU_FAMILY_MODEL(6, 42),
        JAKETOWN =      PCM_CPU_FAMILY_MODEL(6, 45),
        IVY_BRIDGE =    PCM_CPU_FAMILY_MODEL(6, 58),
        HASWELL =       PCM_CPU_FAMILY_MODEL(6, 60),
        HASWELL_ULT =   PCM_CPU_FAMILY_MODEL(6, 69),
        HASWELL_2 =     PCM_CPU_FAMILY_MODEL(6, 70),
        IVYTOWN =       PCM_CPU_FAMILY_MODEL(6, 62),
        HASWELLX =      PCM_CPU_FAMILY_MODEL(6, 63),
        BROADWELL =     PCM_CPU_FAMILY_MODEL(6, 61),
        BROADWELL_XEON_E3 = PCM_CPU_FAMILY_MODEL(6, 71),
        BDX_DE =        PCM_CPU_FAMILY_MODEL(6, 86),
        SKL_UY =        PCM_CPU_FAMILY_MODEL(6, 78),
        KBL =           PCM_CPU_FAMILY_MODEL(6, 158),
        KBL_1 =         PCM_CPU_FAMILY_MODEL(6, 142),
        CML =           PCM_CPU_FAMILY_MODEL(6, 166),
        CML_1 =         PCM_CPU_FAMILY_MODEL(6, 165),
        ICL =           PCM_CPU_FAMILY_MODEL(6, 126),
        ICL_1 =         PCM_CPU_FAMILY_MODEL(6, 125),
        RKL =           PCM_CPU_FAMILY_MODEL(6, 167),
        TGL =           PCM_CPU_FAMILY_MODEL(6, 140),
        TGL_1 =         PCM_CPU_FAMILY_MODEL(6, 141),
        ADL =           PCM_CPU_FAMILY_MODEL(6, 151),
        ADL_1 =         PCM_CPU_FAMILY_MODEL(6, 154),
        RPL =           PCM_CPU_FAMILY_MODEL(6, 0xb7),
        RPL_1 =         PCM_CPU_FAMILY_MODEL(6, 0xba),
        RPL_2 =         PCM_CPU_FAMILY_MODEL(6, 0xbf),
        RPL_3 =         PCM_CPU_FAMILY_MODEL(6, 0xbe),
        MTL =           PCM_CPU_FAMILY_MODEL(6, 0xAA),
        LNL =           PCM_CPU_FAMILY_MODEL(6, 0xBD),
        ARL =           PCM_CPU_FAMILY_MODEL(6, 197),
        ARL_1 =         PCM_CPU_FAMILY_MODEL(6, 198),
        PTL =           PCM_CPU_FAMILY_MODEL(6, 204),
        BDX =           PCM_CPU_FAMILY_MODEL(6, 79),
        KNL =           PCM_CPU_FAMILY_MODEL(6, 87),
        SKL =           PCM_CPU_FAMILY_MODEL(6, 94),
        SKX =           PCM_CPU_FAMILY_MODEL(6, 85),
        ICX_D =         PCM_CPU_FAMILY_MODEL(6, 108),
        ICX =           PCM_CPU_FAMILY_MODEL(6, 106),
        SPR =           PCM_CPU_FAMILY_MODEL(6, 143),
        EMR =           PCM_CPU_FAMILY_MODEL(6, 207),
        GNR =           PCM_CPU_FAMILY_MODEL(6, 173),
        SRF =           PCM_CPU_FAMILY_MODEL(6, 175),
        GNR_D =         PCM_CPU_FAMILY_MODEL(6, 174),
        GRR =           PCM_CPU_FAMILY_MODEL(6, 182),
        END_OF_MODEL_LIST = 0x0ffff
    };

#define PCM_SKL_PATH_CASES \
        case PCM::SKL_UY:  \
        case PCM::KBL:     \
        case PCM::KBL_1:   \
        case PCM::CML:     \
        case PCM::ICL:     \
        case PCM::RKL:     \
        case PCM::TGL:     \
        case PCM::SKL:

private:
    bool useSKLPath() const
    {
        switch (cpu_family_model)
        {
            PCM_SKL_PATH_CASES
                return true;
        }
        return false;
    }
    RawPMUConfig threadMSRConfig{}, packageMSRConfig{}, tpmiConfig{}, pcicfgConfig{}, mmioConfig{}, pmtConfig{};
public:

    //! \brief Reads CPU family
    //! \return CPU family
    uint32 getCPUFamily() const { return (uint32)cpu_family; }

    //! \brief Reads CPU model id (use only with the family API together, don't always assume family 6)
    //! \return Internal CPU model ID
    uint32 getInternalCPUModel() const { return (uint32)cpu_model_private; }

    //! \brief Reads CPU family and model id
    //! \return CPU family and model ID (lowest 8 bits is the model, next 8 bits is the family)
    uint32 getCPUFamilyModel() const { return cpu_family_model; }

    //! \brief Reads CPU stepping id
    //! \return CPU stepping ID
    uint32 getCPUStepping() const { return (uint32)cpu_stepping; }

    //! \brief Determines physical thread of given processor ID within a core
    //! \param os_id processor identifier
    //! \return physical thread identifier
    int32 getThreadId(uint32 os_id) const { return (int32)topology[os_id].thread_id; }

    //! \brief Determines physical core of given processor ID within a socket
    //! \param os_id processor identifier
    //! \return physical core identifier
    int32 getCoreId(uint32 os_id) const { return (int32)topology[os_id].core_id; }

    //! \brief Determines physical tile (cores sharing L2 cache) of given processor ID
    //! \param os_id processor identifier
    //! \return physical tile identifier
    int32 getTileId(uint32 os_id) const { return (int32)topology[os_id].tile_id; }

    //! \brief Determines socket of given core
    //! \param core_id core identifier
    //! \return socket identifier
    int32 getSocketId(uint32 core_id) const { return (int32)topology[core_id].socket_id; }

    //! \brief Maps NUMA node ID to CPU socket ID
    //! \param numa_node_id NUMA node identifier
    //! \return socket identifier, or -1 if mapping is not available or numa_node_id is invalid
    //! \note On Linux: Uses /sys/devices/system/node/nodeX/cpulist
    //! \note On Windows: Uses GetLogicalProcessorInformationEx (may have limitations with multi-group processors)
    //! \note On FreeBSD: Uses vm.ndomains and cpuset_getdomain (FreeBSD 12.0+)
    //! \note On macOS: Not implemented, returns -1
    int32 mapNUMANodeToSocket(uint32 numa_node_id) const;

    size_t getNumCXLPorts(uint32 socket) const
    {
        if (socket < cxlPMUs.size())
        {
            return cxlPMUs[socket].size();
        }
        return 0;
    }

    //! \brief Returns the number of Intel(r) Quick Path Interconnect(tm) links per socket
    //! \return number of QPI links per socket
    uint64 getQPILinksPerSocket() const
    {
        switch (cpu_family_model)
        {
        case NEHALEM_EP:
        case WESTMERE_EP:
        case CLARKDALE:
            if (num_sockets == 2)
                return 2;
            else
                return 1;
        case NEHALEM_EX:
        case WESTMERE_EX:
            return 4;
        case JAKETOWN:
        case IVYTOWN:
        case HASWELLX:
        case BDX_DE:
        case BDX:
        case SKX:
        case ICX:
        case SPR:
        case EMR:
        case GNR:
        case GNR_D:
        case GRR:
        case SRF:
            return (serverUncorePMUs.size() && serverUncorePMUs[0].get()) ? (serverUncorePMUs[0]->getNumQPIPorts()) : 0;
        }
        return 0;
    }

    //! \brief Returns the number of detected integrated memory controllers per socket
    uint32 getMCPerSocket() const
    {
        switch (cpu_family_model)
        {
        case NEHALEM_EP:
        case WESTMERE_EP:
        case CLARKDALE:
            return 1;
        case NEHALEM_EX:
        case WESTMERE_EX:
            return 2;
        case JAKETOWN:
        case IVYTOWN:
        case HASWELLX:
        case BDX_DE:
        case SKX:
        case ICX:
        case SPR:
        case EMR:
        case GNR:
        case GNR_D:
        case GRR:
        case SRF:
        case BDX:
        case KNL:
            return (serverUncorePMUs.size() && serverUncorePMUs[0].get()) ? (serverUncorePMUs[0]->getNumMC()) : 0;
        }
        return 0;
    }

    //! \brief Returns the total number of detected memory channels on all integrated memory controllers per socket
    size_t getMCChannelsPerSocket() const
    {
        switch (cpu_family_model)
        {
        case NEHALEM_EP:
        case WESTMERE_EP:
        case CLARKDALE:
            return 3;
        case NEHALEM_EX:
        case WESTMERE_EX:
            return 4;
        case JAKETOWN:
        case IVYTOWN:
        case HASWELLX:
        case BDX_DE:
        case SKX:
        case ICX:
        case SPR:
        case EMR:
        case GNR:
        case GNR_D:
        case GRR:
        case SRF:
        case BDX:
        case KNL:
        case SNOWRIDGE:
            return (serverUncorePMUs.size() && serverUncorePMUs[0].get()) ? (serverUncorePMUs[0]->getNumMCChannels()) : 0;
        }
        return 0;
    }

    //! \brief Returns the number of detected memory channels on given integrated memory controllers
    //! \param socket socket
    //! \param controller controller
    size_t getMCChannels(uint32 socket, uint32 controller) const
    {
        switch (cpu_family_model)
        {
        case NEHALEM_EP:
        case WESTMERE_EP:
        case CLARKDALE:
            return 3;
        case NEHALEM_EX:
        case WESTMERE_EX:
            return 4;
        case JAKETOWN:
        case IVYTOWN:
        case HASWELLX:
        case BDX_DE:
        case SKX:
        case ICX:
        case SPR:
        case EMR:
        case GNR:
        case GNR_D:
        case GRR:
        case SRF:
        case BDX:
        case KNL:
        case SNOWRIDGE:
            return (socket < serverUncorePMUs.size() && serverUncorePMUs[socket].get()) ? (serverUncorePMUs[socket]->getNumMCChannels(controller)) : 0;
        }
        return 0;
    }


    //! \brief Returns the total number of detected memory channels on all integrated memory controllers per socket
    size_t getEDCChannelsPerSocket() const
    {
        switch (cpu_family_model)
        {
        case KNL:
            return (serverUncorePMUs.size() && serverUncorePMUs[0].get()) ? (serverUncorePMUs[0]->getNumEDCChannels()) : 0;
        }
        return 0;
    }


    //! \brief Returns the max number of instructions per cycle
    //! \return max number of instructions per cycle
    uint32 getMaxIPC() const
    {
        if (ICL == cpu_family_model || TGL == cpu_family_model || RKL == cpu_family_model) return 5;
        switch (cpu_family_model)
        {
        case ADL:
        case RPL:
        case MTL:
            return 6;
        case LNL:
        case ARL:
        case PTL:
            return 12;
        case SNOWRIDGE:
        case ELKHART_LAKE:
        case JASPER_LAKE:
            return 4;
        case DENVERTON:
            return 3;
        case NEHALEM_EP:
        case WESTMERE_EP:
        case NEHALEM_EX:
        case WESTMERE_EX:
        case CLARKDALE:
        case SANDY_BRIDGE:
        case JAKETOWN:
        case IVYTOWN:
        case IVY_BRIDGE:
        case HASWELL:
        case HASWELLX:
        case BROADWELL:
        case BDX_DE:
        case BDX:
        PCM_SKL_PATH_CASES
        case SKX:
            return 4;
        case KNL:
            return 2;
        case ICX:
            return 5;
        case SPR:
        case EMR:
        case GNR:
        case GNR_D:
        case GRR:
        case SRF:
            return 6;
        }
        if (isAtom())
        {
            return 2;
        }
        std::cerr << "MaxIPC is not defined for your cpu family " << cpu_family << " model " << cpu_model_private << '\n';
        assert (0);
        return 0;
    }

    //! \brief Returns the frequency of Power Control Unit
    uint64 getPCUFrequency() const
    {
        switch (cpu_family_model)
        {
        case JAKETOWN:
        case IVYTOWN:
            return 800000000ULL;  // 800 MHz
        case HASWELLX:
        case BDX_DE:
        case BDX:
        case KNL:
            return 1000000000ULL; // 1 GHz
        case SKX:
        case ICX:
        case SNOWRIDGE:
            return 1100000000ULL; // 1.1 GHz
        }
        return 0;
    }

    //! \brief Returns whether it is a server part
    bool isServerCPU() const
    {
        switch (cpu_family_model)
        {
        case NEHALEM_EP:
        case NEHALEM_EX:
        case WESTMERE_EP:
        case WESTMERE_EX:
        case JAKETOWN:
        case IVYTOWN:
        case HASWELLX:
        case BDX:
        case BDX_DE:
        case SKX:
        case ICX:
        case SNOWRIDGE:
        case SPR:
        case EMR:
        case GNR:
        case GNR_D:
        case GRR:
        case SRF:
        case KNL:
            return true;
        default:
            return false;
        };
    }

    //! \brief Returns whether it is a client part
    bool isClientCPU() const
    {
        return !isServerCPU();
    }
    //! \brief Return TSC timer value in time units
    //! \param multiplier use 1 for seconds, 1000 for ms, 1000000 for mks, etc (default is 1000: ms)
    //! \param core core to read on-chip TSC value (default is -1: socketRefCore[0])
    //! \return time counter value
    uint64 getTickCount(uint64 multiplier = 1000 /* ms */, int32 core = -1);

    uint64 getInvariantTSC_Fast(uint32 core = 0);

    //! \brief Returns uncore clock ticks on specified socket
    uint64 getUncoreClocks(const uint32 socket_);

    //! \brief Return QPI Link Speed in GBytes/second
    //! \warning Works only for Nehalem-EX (Xeon 7500) and Xeon E7 and E5 processors
    //! \return QPI Link Speed in GBytes/second
    uint64 getQPILinkSpeed(uint32 socketNr, uint32 linkNr) const
    {
        return hasPCICFGUncore() ? serverUncorePMUs[socketNr]->getQPILinkSpeed(linkNr) : max_qpi_speed;
    }

    //! \brief Returns how many joules are in an internal processor energy unit
    double getJoulesPerEnergyUnit() const { return joulesPerEnergyUnit; }

    //! \brief Returns thermal specification power of the package domain in Watt
    int32 getPackageThermalSpecPower() const { return pkgThermalSpecPower; }

    //! \brief Returns minimum power derived from electrical spec of the package domain in Watt
    int32 getPackageMinimumPower() const { return pkgMinimumPower; }

    //! \brief Returns maximum power derived from electrical spec of the package domain in Watt
    int32 getPackageMaximumPower() const { return pkgMaximumPower; }

    #ifndef NO_WINRING // In cases where loading the WinRing0 driver is not desirable as a fallback to MSR.sys, add -DNO_WINRING to compile command to remove ability to load driver
    //! \brief Loads and initializes Winring0 third party library for access to processor model specific and PCI configuration registers
    //! \return returns true in case of success
    static bool initWinRing0Lib();
    #endif // NO_WINRING

    inline void disableJKTWorkaround() { disable_JKT_workaround = true; }

    enum PCIeEventCode
    {
        // PCIe read events (PCI devices reading from memory - application writes to disk/network/PCIe device)
        PCIeRdCur = 0x19E, // PCIe read current (full cache line)
        PCIeNSRd = 0x1E4,  // PCIe non-snoop read (full cache line)
        // PCIe write events (PCI devices writing to memory - application reads from disk/network/PCIe device)
        PCIeWiLF = 0x194,  // PCIe Write (non-allocating) (full cache line)
        PCIeItoM = 0x19C,  // PCIe Write (allocating) (full cache line)
        PCIeNSWr = 0x1E5,  // PCIe Non-snoop write (partial cache line)
        PCIeNSWrF = 0x1E6, // PCIe Non-snoop write (full cache line)
        // events shared by CPU and IO
        RFO = 0x180,       // Demand Data RFO; share the same code for CPU, use tid to filter PCIe only traffic
        CRd = 0x181,       // Demand Code Read
        DRd = 0x182,       // Demand Data Read
        PRd = 0x187,       // Partial Reads (UC) (MMIO Read)
        WiL = 0x18F,       // Write Invalidate Line - partial (MMIO write), PL: Not documented in HSX/IVT
        ItoM = 0x1C8,      // Request Invalidate Line; share the same code for CPU, use tid to filter PCIe only traffic

        SKX_RFO = 0x200,
        SKX_CRd = 0x201,
        SKX_DRd = 0x202,
        SKX_PRd = 0x207,
        SKX_WiL = 0x20F,
        SKX_RdCur = 0x21E,
        SKX_ItoM = 0x248,
    };

    enum ChaPipelineQueue
    {
        None,
        IRQ,
        PRQ,
    };

    enum CBoEventTid
    {
        RFOtid = 0x3E,
        ItoMtid = 0x3E,
    };

    //! \brief Program uncore PCIe monitoring event(s)
    //! \param eventGroup - events to program for the same run
    void programPCIeEventGroup(eventGroup_t &eventGroup);
    uint64 getPCIeCounterData(const uint32 socket_, const uint32 ctr_);

    //! \brief Program CBO (or CHA on SKX+) counters
    //! \param events array with four raw event values
    //! \param opCode opcode match filter
    //! \param nc_ match non-coherent requests
    //! \param llc_lookup_tid_filter filter for LLC lookup event filter and TID filter (core and thread ID)
    //! \param loc match on local node target
    //! \param rem match on remote node target
    void programCbo(const uint64 * events, const uint32 opCode = 0, const uint32 nc_ = 0, const uint32 llc_lookup_tid_filter = 0, const uint32 loc = 1, const uint32 rem = 1);

    //! \brief Program CBO (or CHA on SKX+) counters
    //! \param events array with four raw event values
    //! \param filter0 raw filter value
    //! \param filter1 raw filter1 value
    void programCboRaw(const uint64* events, const uint64 filter0, const uint64 filter1);

    //! \brief Program MDF counters
    //! \param events array with four raw event values
    void programMDF(const uint64* events);

    //! \brief Get the state of PCIe counter(s)
    //! \param socket_ socket of the PCIe controller
    //! \return State of PCIe counter(s)
    PCIeCounterState getPCIeCounterState(const uint32 socket_, const uint32 ctr_ = 0);

    //! \brief Program uncore IIO events
    //! \param rawEvents events to program (raw format)
    //! \param IIOStack id of the IIO stack to program (-1 for all, if parameter omitted)
    void programIIOCounters(uint64 rawEvents[4], int IIOStack = -1);

    //! \brief Program uncore IRP events
    //! \param rawEvents events to program (raw format)
    //! \param IIOStack id of the IIO stack to program (-1 for all, if parameter omitted)
    void programIRPCounters(uint64 rawEvents[4], int IIOStack = -1);

    //! \brief Control QAT telemetry service
    //! \param dev device index
    //! \param operation control code
    void controlQATTelemetry(uint32 dev, uint32 operation);

    //! \brief Program IDX events
    //! \param events config of event to program
    //! \param filters_wq filters(work queue) of event to program
    //! \param filters_eng filters(engine) of event to program
    //! \param filters_tc filters(traffic class) of event to program
    //! \param filters_pgsz filters(page size) of event to program
    //! \param filters_xfersz filters(transfer size) of event to program
    void programIDXAccelCounters(uint32 accel, std::vector<uint64_t> &events, std::vector<uint32> &filters_wq, std::vector<uint32> &filters_eng, std::vector<uint32> &filters_tc, std::vector<uint32> &filters_pgsz, std::vector<uint32> &filters_xfersz);

    //! \brief Get the state of IIO counter
    //! \param socket socket of the IIO stack
    //! \param IIOStack id of the IIO stack
    //! \return State of IIO counter
    IIOCounterState getIIOCounterState(int socket, int IIOStack, int counter);

    //! \brief Get the states of the four IIO counters in bulk (faster than four single reads)
    //! \param socket socket of the IIO stack
    //! \param IIOStack id of the IIO stack
    //! \param result states of IIO counters (array of four IIOCounterState elements)
    void getIIOCounterStates(int socket, int IIOStack, IIOCounterState * result);


    //! \brief Get the state of IDX accel counter
    //! \param accel ip index
    //! \param dev device index
    //! \param counter_id perf counter index
    //! \return State of IDX counter
    IDXCounterState getIDXAccelCounterState(uint32 accel, uint32 dev, uint32 counter_id);

    uint64 extractCoreGenCounterValue(uint64 val);
    uint64 extractCoreFixedCounterValue(uint64 val);
    uint64 extractUncoreGenCounterValue(uint64 val);
    uint64 extractUncoreFixedCounterValue(uint64 val);
    uint64 extractQOSMonitoring(uint64 val);

    //! \brief Get a string describing the codename of the processor microarchitecture
    //! \param cpu_family_model_ cpu model (if no parameter provided the codename of the detected CPU is returned)
    const char * getUArchCodename(const int32 cpu_family_model_ = -1) const;

    //! \brief Convert CPU Family/Model/Stepping to microarchitecture codename
    //! \param cpu_family_model_ cpu family model
    //! \param cpu_stepping necessary for some CPU models to distinguish between different microarchitectures
    static const char * cpuFamilyModelToUArchCodename(const int32 cpu_family_model_, const int32 cpu_stepping_ = -1);

    //! \brief Get Brand string of processor
    static std::string getCPUBrandString();
    std::string getCPUFamilyModelString();
    static std::string getCPUFamilyModelString(const uint32 cpu_family, const uint32 cpu_model, const uint32 cpu_stepping);

    //! \brief Enables "force all RTM transaction abort" mode also enabling 4+ programmable counters on Skylake generation processors
    void enableForceRTMAbortMode(const bool silent = false);

    //! \brief queries status of "force all RTM transaction abort" mode
    bool isForceRTMAbortModeEnabled() const;

    //! \brief Disables "force all RTM transaction abort" mode restricting the number of programmable counters on Skylake generation processors to 3
    void disableForceRTMAbortMode(const bool silent = false);

    //! \brief queries availability of "force all RTM transaction abort" mode
    static bool isForceRTMAbortModeAvailable();

    //! \brief Get microcode level (returns -1 if retrieval not supported due to some restrictions)
    int64 getCPUMicrocodeLevel() const { return cpu_microcode_level; }

    //! \brief returns true if CPU model is Atom-based
    static bool isAtom(const int32 cpu_family_model_)
    {
        return cpu_family_model_ == ATOM
            || cpu_family_model_ == ATOM_2
            || cpu_family_model_ == CENTERTON
            || cpu_family_model_ == BAYTRAIL
            || cpu_family_model_ == AVOTON
            || cpu_family_model_ == CHERRYTRAIL
            || cpu_family_model_ == APOLLO_LAKE
            || cpu_family_model_ == GEMINI_LAKE
            || cpu_family_model_ == DENVERTON
            // || cpu_family_model_ == SNOWRIDGE do not use Atom code for SNOWRIDGE
            ;
    }

    //! \brief returns true if CPU is Atom-based
    bool isAtom() const
    {
        return isAtom(cpu_family_model);
    }

    // From commit message: https://github.com/torvalds/linux/commit/e979121b1b1556e184492e6fc149bbe188fc83e6
    bool memoryEventErrata() const
    {
        switch (cpu_family_model)
        {
            case SANDY_BRIDGE:
            case JAKETOWN:
            case IVYTOWN:
            case IVY_BRIDGE:
            case HASWELL:
            case HASWELLX:
                return true;
        }
        return false;
    }

    bool packageEnergyMetricsAvailable() const
    {
        return (
                    cpu_family_model == PCM::JAKETOWN
                 || cpu_family_model == PCM::IVYTOWN
                 || cpu_family_model == PCM::SANDY_BRIDGE
                 || cpu_family_model == PCM::IVY_BRIDGE
                 || cpu_family_model == PCM::HASWELL
                 || cpu_family_model == PCM::AVOTON
                 || cpu_family_model == PCM::CHERRYTRAIL
                 || cpu_family_model == PCM::BAYTRAIL
                 || cpu_family_model == PCM::APOLLO_LAKE
                 || cpu_family_model == PCM::GEMINI_LAKE
                 || cpu_family_model == PCM::DENVERTON
                 || cpu_family_model == PCM::SNOWRIDGE
                 || cpu_family_model == PCM::ELKHART_LAKE
                 || cpu_family_model == PCM::JASPER_LAKE
                 || cpu_family_model == PCM::HASWELLX
                 || cpu_family_model == PCM::BROADWELL
                 || cpu_family_model == PCM::BDX_DE
                 || cpu_family_model == PCM::BDX
                 || cpu_family_model == PCM::KNL
                 || useSKLPath()
                 || cpu_family_model == PCM::SKX
                 || cpu_family_model == PCM::ICX
                 || cpu_family_model == PCM::ADL
                 || cpu_family_model == PCM::RPL
                 || cpu_family_model == PCM::MTL
                 || cpu_family_model == PCM::LNL
                 || cpu_family_model == PCM::ARL
                 || cpu_family_model == PCM::PTL
                 || cpu_family_model == PCM::SPR
                 || cpu_family_model == PCM::EMR
                 || cpu_family_model == PCM::GNR
                 || cpu_family_model == PCM::GNR_D
                 || cpu_family_model == PCM::SRF
                 || cpu_family_model == PCM::GRR
               );
    }

    bool dramEnergyMetricsAvailable() const
    {
        return (
             cpu_family_model == PCM::JAKETOWN
          || cpu_family_model == PCM::IVYTOWN
          || cpu_family_model == PCM::HASWELLX
          || cpu_family_model == PCM::BDX_DE
          || cpu_family_model == PCM::BDX
          || cpu_family_model == PCM::KNL
          || cpu_family_model == PCM::SKX
          || cpu_family_model == PCM::ICX
          || cpu_family_model == PCM::SPR
          || cpu_family_model == PCM::EMR
          || cpu_family_model == PCM::GNR
          || cpu_family_model == PCM::GNR_D
          || cpu_family_model == PCM::SRF
          || cpu_family_model == PCM::GRR
          );
    }

    bool systemEnergyMetricAvailable() const
    {
        return (
               useSKLPath()
            || cpu_family_model == PCM::SKX
            || cpu_family_model == PCM::ICX
            || cpu_family_model == PCM::ADL
            || cpu_family_model == PCM::RPL
            || cpu_family_model == PCM::MTL
            || cpu_family_model == PCM::LNL
            || cpu_family_model == PCM::ARL
            || cpu_family_model == PCM::PTL
            || cpu_family_model == PCM::SPR
            || cpu_family_model == PCM::EMR
            || cpu_family_model == PCM::GNR
            || cpu_family_model == PCM::SRF
            || cpu_family_model == PCM::GRR
            );
    }

    bool packageThermalMetricsAvailable() const
    {
        return packageEnergyMetricsAvailable();
    }

    bool outgoingQPITrafficMetricsAvailable() const
    {
        return getQPILinksPerSocket() > 0 &&
            (
               cpu_family_model == PCM::NEHALEM_EX
            || cpu_family_model == PCM::WESTMERE_EX
            || cpu_family_model == PCM::JAKETOWN
            || cpu_family_model == PCM::IVYTOWN
            || cpu_family_model == PCM::HASWELLX
            || cpu_family_model == PCM::BDX
            || cpu_family_model == PCM::SKX
            || cpu_family_model == PCM::ICX
            || cpu_family_model == PCM::SPR
            || cpu_family_model == PCM::EMR
            || cpu_family_model == PCM::GNR
            || cpu_family_model == PCM::SRF
            );
    }

    bool incomingQPITrafficMetricsAvailable() const
    {
        return getQPILinksPerSocket() > 0 &&
            (
               cpu_family_model == PCM::NEHALEM_EX
            || cpu_family_model == PCM::WESTMERE_EX
            || cpu_family_model == PCM::JAKETOWN
            || cpu_family_model == PCM::IVYTOWN
            || (cpu_family_model == PCM::SKX && cpu_stepping > 1)
            || cpu_family_model == PCM::ICX
            || cpu_family_model == PCM::SPR
            || cpu_family_model == PCM::EMR
            || cpu_family_model == PCM::GNR
            || cpu_family_model == PCM::SRF
               );
    }

    bool localMemoryRequestRatioMetricAvailable() const
    {
        return cpu_family_model == PCM::HASWELLX
            || cpu_family_model == PCM::BDX
            || cpu_family_model == PCM::SKX
            || cpu_family_model == PCM::ICX
            || cpu_family_model == PCM::SPR
            || cpu_family_model == PCM::EMR
            || cpu_family_model == PCM::SRF
            || cpu_family_model == PCM::GNR
            ;
    }

    bool qpiUtilizationMetricsAvailable() const
    {
        return outgoingQPITrafficMetricsAvailable();
    }

    bool nearMemoryMetricsAvailable() const
    {
        return (
               cpu_family_model == PCM::SRF
            || cpu_family_model == PCM::GNR
            || cpu_family_model == PCM::GNR_D
            );
    }

    bool memoryTrafficMetricsAvailable() const
    {
        return (!(isAtom() || cpu_family_model == PCM::CLARKDALE))
               ;
    }

    bool HBMmemoryTrafficMetricsAvailable() const
    {
        return serverUncorePMUs.empty() == false && serverUncorePMUs[0].get() != nullptr && serverUncorePMUs[0]->HBMAvailable();
    }

    size_t getHBMCASTransferSize() const
    {
        return (SPR == cpu_family_model) ? 32ULL : 64ULL;
    }

    bool memoryIOTrafficMetricAvailable() const
    {
        if (cpu_family_model == TGL) return false;
        return (
            cpu_family_model == PCM::SANDY_BRIDGE
            || cpu_family_model == PCM::IVY_BRIDGE
            || cpu_family_model == PCM::HASWELL
            || cpu_family_model == PCM::BROADWELL
            || useSKLPath()
            );
    }

    bool IIOEventsAvailable() const
    {
        return (
               cpu_family_model == PCM::SKX
            || cpu_family_model == PCM::ICX
	        || cpu_family_model == PCM::SNOWRIDGE
            || cpu_family_model == PCM::SPR
            || cpu_family_model == PCM::EMR
            || cpu_family_model == PCM::GRR
            || cpu_family_model == PCM::SRF
            || cpu_family_model == PCM::GNR
            || cpu_family_model == PCM::GNR_D
        );
    }

    bool uncoreFrequencyMetricAvailable() const
    {
        return MSR.empty() == false
                && getMaxNumOfUncorePMUs(UBOX_PMU_ID) > 0ULL
                && getNumCores() == getNumOnlineCores()
                && PCM::GNR != cpu_family_model
                && PCM::GNR_D != cpu_family_model
                && PCM::SRF != cpu_family_model
            ;
    }

    bool LatencyMetricsAvailable() const
    {
        return (
               cpu_family_model == PCM::HASWELLX
            || cpu_family_model == PCM::BDX
            || cpu_family_model == PCM::SKX
            || cpu_family_model == PCM::ICX
            || cpu_family_model == PCM::SPR
            || cpu_family_model == PCM::EMR
            || useSKLPath()
            );
    }

    bool DDRLatencyMetricsAvailable() const
    {
        return (
               cpu_family_model == PCM::SKX
            || cpu_family_model == PCM::ICX
            || cpu_family_model == PCM::SPR
            || cpu_family_model == PCM::EMR
            );
    }

    bool PMMTrafficMetricsAvailable() const
    {
        return (
            isCLX()
                    ||  isCPX()
                     || cpu_family_model == PCM::ICX
                     || cpu_family_model == PCM::SNOWRIDGE
                     || cpu_family_model == SPR
                     || cpu_family_model == EMR
        );
    }

    bool PMMMemoryModeMetricsAvailable() const
    {
       return (
                  isCLX()
               || isCPX()
               || cpu_family_model == PCM::ICX
               || cpu_family_model == PCM::SNOWRIDGE
              );
    }

    bool PMMMixedModeMetricsAvailable() const
    {
       return PMMMemoryModeMetricsAvailable();
    }

    bool LLCReadMissLatencyMetricsAvailable() const
    {
        return (
               HASWELLX == cpu_family_model
            || BDX_DE == cpu_family_model
            || BDX == cpu_family_model
            || isCLX()
            || isCPX()
#ifdef PCM_ENABLE_LLCRDLAT_SKX_MP
            || SKX == cpu_family_model
#else
            || ((SKX == cpu_family_model) && (num_sockets == 1))
#endif
            || ICX == cpu_family_model
            || SPR == cpu_family_model
            || SNOWRIDGE == cpu_family_model
               );
    }

    bool hasBecktonUncore() const
    {
        return (
            cpu_family_model == PCM::NEHALEM_EX
            || cpu_family_model == PCM::WESTMERE_EX
            );
    }
    bool hasPCICFGUncore() const // has PCICFG uncore PMON
    {
        return (
            cpu_family_model == PCM::JAKETOWN
            || cpu_family_model == PCM::SNOWRIDGE
            || cpu_family_model == PCM::IVYTOWN
            || cpu_family_model == PCM::HASWELLX
            || cpu_family_model == PCM::BDX_DE
            || cpu_family_model == PCM::SKX
            || cpu_family_model == PCM::ICX
            || cpu_family_model == PCM::SPR
            || cpu_family_model == PCM::EMR
            || cpu_family_model == PCM::GNR
            || cpu_family_model == PCM::GNR_D
            || cpu_family_model == PCM::SRF
            || cpu_family_model == PCM::GRR
            || cpu_family_model == PCM::BDX
            || cpu_family_model == PCM::KNL
            );
    }

    bool isSkxCompatible() const
    {
        return (
            cpu_family_model == PCM::SKX
               );
    }

    static bool hasUPI(const int32 cpu_family_model_) // Intel(r) Ultra Path Interconnect
    {
        return (
            cpu_family_model_ == PCM::SKX
         || cpu_family_model_ == PCM::ICX
         || cpu_family_model_ == PCM::SPR
         || cpu_family_model_ == PCM::EMR
         || cpu_family_model_ == PCM::GNR
         || cpu_family_model_ == PCM::SRF
               );
    }

    bool hasUPI() const
    {
        return hasUPI(cpu_family_model);
    }

    const char * xPI() const
    {
        if (hasUPI())
            return "UPI";

        return "QPI";
    }

    bool hasCHA() const
    {
        return (
            cpu_family_model == PCM::SKX
         || cpu_family_model == PCM::ICX
         || cpu_family_model == PCM::SPR
         || cpu_family_model == PCM::EMR
         || cpu_family_model == PCM::GNR
         || cpu_family_model == PCM::GNR_D
         || cpu_family_model == PCM::SRF
         || cpu_family_model == PCM::GRR
               );
    }

    bool supportsHLE() const;
    bool supportsRTM() const;
    bool supportsRDTSCP() const;

    bool useSkylakeEvents() const
    {
        return    useSKLPath()
               || PCM::SKX == cpu_family_model
               || PCM::ICX == cpu_family_model
               || PCM::SPR == cpu_family_model
               || PCM::EMR == cpu_family_model
               || PCM::GNR == cpu_family_model
               || PCM::GNR_D == cpu_family_model
               ;
    }

    bool hasClientMCCounters() const
    {
        return cpu_family_model == SANDY_BRIDGE
            || cpu_family_model == IVY_BRIDGE
            || cpu_family_model == HASWELL
            || cpu_family_model == BROADWELL
            || cpu_family_model == ADL
            || cpu_family_model == RPL
            || cpu_family_model == MTL
            || cpu_family_model == LNL
            || cpu_family_model == ARL
            || cpu_family_model == PTL
            || useSKLPath()
            ;
    }

    bool ppEnergyMetricsAvailable() const
    {
        return packageEnergyMetricsAvailable() && hasClientMCCounters() && num_sockets == 1;
    }

    static double getBytesPerFlit(int32 cpu_family_model_)
    {
        if (hasUPI(cpu_family_model_))
        {
            // 172 bits per UPI flit
            return 172./8.;
        }
        // 8 bytes per QPI flit
        return 8.;
    }

    double getBytesPerFlit() const
    {
        return getBytesPerFlit(cpu_family_model);
    }

    static double getDataBytesPerFlit(const int32 cpu_family_model_)
    {
        if (hasUPI(cpu_family_model_))
        {
            // 9 UPI flits to transfer 64 bytes
            return 64./9.;
        }
        // 8 bytes per QPI flit
        return 8.;
    }

    double getDataBytesPerFlit() const
    {
        return getDataBytesPerFlit(cpu_family_model);
    }

    static double getFlitsPerLinkCycle(const int32 cpu_family_model_)
    {
        if (hasUPI(cpu_family_model_))
        {
            // 5 UPI flits sent every 6 link cycles
            return 5./6.;
        }
        return 2.;
    }

    static double getBytesPerLinkCycle(const int32 cpu_family_model_)
    {
        return getBytesPerFlit(cpu_family_model_) * getFlitsPerLinkCycle(cpu_family_model_);
    }

    double getBytesPerLinkCycle() const
    {
        return getBytesPerLinkCycle(cpu_family_model);
    }

    double getLinkTransfersPerLinkCycle() const
    {
        return 8.;
    }

    double getBytesPerLinkTransfer() const
    {
        return getBytesPerLinkCycle() / getLinkTransfersPerLinkCycle();
    }

    //! \brief Setup ExtendedCustomCoreEventDescription object to read offcore (numa) counters for each processor type
    //! \param conf conf object to setup offcore MSR values
    void setupCustomCoreEventsForNuma(PCM::ExtendedCustomCoreEventDescription& conf) const;

    #define PCM_GENERATE_METRIC_AVAILABLE_FUNCTION(m) bool is##m() const { return m; }

    PCM_GENERATE_METRIC_AVAILABLE_FUNCTION(L2CacheHitRatioAvailable)
    PCM_GENERATE_METRIC_AVAILABLE_FUNCTION(L3CacheHitRatioAvailable)
    PCM_GENERATE_METRIC_AVAILABLE_FUNCTION(L3CacheMissesAvailable)
    PCM_GENERATE_METRIC_AVAILABLE_FUNCTION(L2CacheMissesAvailable)
    PCM_GENERATE_METRIC_AVAILABLE_FUNCTION(L2CacheHitsAvailable)
    PCM_GENERATE_METRIC_AVAILABLE_FUNCTION(L3CacheHitsNoSnoopAvailable)
    PCM_GENERATE_METRIC_AVAILABLE_FUNCTION(L3CacheHitsSnoopAvailable)
    PCM_GENERATE_METRIC_AVAILABLE_FUNCTION(L3CacheHitsAvailable)

    #undef PCM_GEN_METRIC_AVAILABLE_FUNCTION

    bool isActiveRelativeFrequencyAvailable() const
    {
        return !isAtom();
    }

    ~PCM();
};

//! \brief Basic core counter state
//!
//! Intended only for derivation, but not for the direct use
class BasicCounterState
{
    friend class PCM;
    friend class JSONPrinter;
    template <class CounterStateType>
    friend double getExecUsage(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getIPC(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getAverageFrequency(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getAverageFrequencyFromClocks(const int64 clocks, const CounterStateType& before, const CounterStateType& after);
    template <class CounterStateType>
    friend double getActiveAverageFrequency(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getRelativeFrequency(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getActiveRelativeFrequency(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getL2CacheHitRatio(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getL3CacheHitRatio(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getL3CacheMisses(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getL2CacheMisses(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getL2CacheHits(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getL3CacheHitsNoSnoop(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getL3CacheHitsSnoop(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getL3CacheHits(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getL3CacheOccupancy(const CounterStateType & now);
    template <class CounterStateType>
    friend uint64 getLocalMemoryBW(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getRemoteMemoryBW(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getCycles(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getInstructionsRetired(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getCycles(const CounterStateType & now);
    template <class CounterStateType>
    friend uint64 getInstructionsRetired(const CounterStateType & now);
    template <class CounterStateType>
    friend uint64 getNumberOfCustomEvents(int32 eventCounterNr, const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getInvariantTSC(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getRefCycles(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getCoreCStateResidency(int state, const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getCoreCStateResidency(int state, const CounterStateType& now);
    template <class CounterStateType>
    friend uint64 getSMICount(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getAllSlotsRaw(const CounterStateType& before, const CounterStateType& after);
    template <class CounterStateType>
    friend uint64 getAllSlots(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getBackendBound(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getFrontendBound(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getBadSpeculation(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getRetiring(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getFetchLatencyBound(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getFetchBandwidthBound(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getBranchMispredictionBound(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getMachineClearsBound(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getMemoryBound(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getCoreBound(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getHeavyOperationsBound(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getLightOperationsBound(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getMSREvent(const uint64 & index, const PCM::MSRType & type, const CounterStateType& before, const CounterStateType& after);
protected:
    checked_uint64 InstRetiredAny{};
    checked_uint64 CpuClkUnhaltedThread{};
    checked_uint64 CpuClkUnhaltedRef{};
    checked_uint64 Event[PERF_MAX_CUSTOM_COUNTERS];
    enum
    {
               L3MissPos = 0,
          ArchLLCMissPos = 0,
        L3UnsharedHitPos = 1,
           ArchLLCRefPos = 1,
             SKLL3HitPos = 1,
               L2HitMPos = 2,
            SKLL2MissPos = 2,
            HSXL2MissPos = 2,
                L2HitPos = 3,
             HSXL2RefPos = 3
    };
    uint64 InvariantTSC; // invariant time stamp counter
    uint64 CStateResidency[PCM::MAX_C_STATE + 1];
    int32 ThermalHeadroom;
    uint64 L3Occupancy;
    uint64 MemoryBWLocal;
    uint64 MemoryBWTotal;
    uint64 SMICount;
    uint64 FrontendBoundSlots, BadSpeculationSlots, BackendBoundSlots, RetiringSlots, AllSlotsRaw;
    uint64 MemBoundSlots, FetchLatSlots, BrMispredSlots, HeavyOpsSlots;
    std::unordered_map<uint64, uint64> MSRValues;

public:
    BasicCounterState() :
        InvariantTSC(0),
        ThermalHeadroom(PCM_INVALID_THERMAL_HEADROOM),
        L3Occupancy(0),
        MemoryBWLocal(0),
        MemoryBWTotal(0),
        SMICount(0),
    FrontendBoundSlots(0),
    BadSpeculationSlots(0),
    BackendBoundSlots(0),
    RetiringSlots(0),
    AllSlotsRaw(0),
    MemBoundSlots(0),
    FetchLatSlots(0),
    BrMispredSlots(0),
    HeavyOpsSlots(0)
    {
        std::fill(CStateResidency, CStateResidency + PCM::MAX_C_STATE + 1, 0);
    }
    virtual ~BasicCounterState() { }

    BasicCounterState( const BasicCounterState& ) = default;
    BasicCounterState( BasicCounterState&& ) = default;
    BasicCounterState & operator = ( BasicCounterState&& ) = default;

    BasicCounterState & operator += (const BasicCounterState & o)
    {
        InstRetiredAny += o.InstRetiredAny;
        CpuClkUnhaltedThread += o.CpuClkUnhaltedThread;
        CpuClkUnhaltedRef += o.CpuClkUnhaltedRef;
        for (int i = 0; i < PERF_MAX_CUSTOM_COUNTERS; ++i)
        {
            Event[i] += o.Event[i];
        }
        InvariantTSC += o.InvariantTSC;
        for (int i = 0; i <= (int)PCM::MAX_C_STATE; ++i)
            CStateResidency[i] += o.CStateResidency[i];
        // ThermalHeadroom is not accumulative
        L3Occupancy += o.L3Occupancy;
        MemoryBWLocal += o.MemoryBWLocal;
        MemoryBWTotal += o.MemoryBWTotal;
        SMICount += o.SMICount;
        DBG(4, "before PCM debug aggregate ", FrontendBoundSlots , " " , BadSpeculationSlots , " " , BackendBoundSlots , " " , RetiringSlots );
        BasicCounterState old = *this;
        FrontendBoundSlots += o.FrontendBoundSlots;
        BadSpeculationSlots += o.BadSpeculationSlots;
        BackendBoundSlots += o.BackendBoundSlots;
        RetiringSlots += o.RetiringSlots;
        AllSlotsRaw += o.AllSlotsRaw;
        MemBoundSlots += o.MemBoundSlots;
        FetchLatSlots += o.FetchLatSlots;
        BrMispredSlots += o.BrMispredSlots;
        HeavyOpsSlots += o.HeavyOpsSlots;
        DBG(4, "after PCM debug aggregate ", FrontendBoundSlots , " " , BadSpeculationSlots , " " , BackendBoundSlots , " " ,RetiringSlots);
        assert(FrontendBoundSlots >= old.FrontendBoundSlots);
        assert(BadSpeculationSlots >= old.BadSpeculationSlots);
        assert(BackendBoundSlots >= old.BackendBoundSlots);
        assert(RetiringSlots >= old.RetiringSlots);
        assert(MemBoundSlots >= old.MemBoundSlots);
        assert(FetchLatSlots >= old.FetchLatSlots);
        assert(BrMispredSlots >= old.BrMispredSlots);
        assert(HeavyOpsSlots >= old.HeavyOpsSlots);
        return *this;
    }

    void readAndAggregate(std::shared_ptr<SafeMsrHandle>);
    void readAndAggregateTSC(std::shared_ptr<SafeMsrHandle>);

    //! Returns current thermal headroom below TjMax
    int32 getThermalHeadroom() const { return ThermalHeadroom; }
};

inline uint64 RDTSC()
{
        uint64 result = 0;
#ifdef _MSC_VER
        // Windows
        #if _MSC_VER>= 1600
        result = static_cast<uint64>(__rdtsc());
        #endif
#else
        // Linux
        uint32 high = 0, low = 0;
        asm volatile("rdtsc" : "=a" (low), "=d" (high));
        result = low + (uint64(high)<<32ULL);
#endif
        return result;

}

inline uint64 RDTSCP()
{
    uint64 result = 0;
#ifdef _MSC_VER
    // Windows
    #if _MSC_VER>= 1600
    unsigned int Aux;
    result = __rdtscp(&Aux);
    #endif
#else
    // Linux and OS X
    uint32 high = 0, low = 0;
    asm volatile (
       "rdtscp\n\t"
       "mov %%edx, %0\n\t"
       "mov %%eax, %1\n\t":
       "=r" (high), "=r" (low) :: "%rax", "%rcx", "%rdx");
    result = low + (uint64(high)<<32ULL);
#endif
    return result;
}

template <class CounterStateType>
int32 getThermalHeadroom(const CounterStateType & /* before */, const CounterStateType & after)
{
    return after.getThermalHeadroom();
}

/*! \brief Returns the ratio of QPI cycles in power saving half-lane mode
    \param port QPI port number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return 0..1 - ratio of QPI cycles in power saving half-lane mode
*/
template <class CounterStateType>
double getNormalizedQPIL0pTxCycles(uint32 port, const CounterStateType & before, const CounterStateType & after)
{
    return double(getQPIL0pTxCycles(port, before, after)) / double(getQPIClocks(port, before, after));
}

/*! \brief Returns the ratio of QPI cycles in power saving shutdown mode
    \param port QPI port number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return 0..1 - ratio of QPI cycles in power saving shutdown mode
*/
template <class CounterStateType>
double getNormalizedQPIL1Cycles(uint32 port, const CounterStateType & before, const CounterStateType & after)
{
    return double(getQPIL1Cycles(port, before, after)) / double(getQPIClocks(port, before, after));
}

/*! \brief Returns DRAM clock ticks
    \param channel DRAM channel number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getDRAMClocks(uint32 channel, const CounterStateType & before, const CounterStateType & after)
{
    const auto clk = after.DRAMClocks[channel] - before.DRAMClocks[channel];
    const auto cpu_family_model = PCM::getInstance()->getCPUFamilyModel();
    if (cpu_family_model == PCM::ICX || cpu_family_model == PCM::SNOWRIDGE)
    {
        return 2 * clk;
    }
    return clk;
}

/*! \brief Returns HBM clock ticks
    \param channel HBM channel number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getHBMClocks(uint32 channel, const CounterStateType & before, const CounterStateType & after)
{
    return after.HBMClocks[channel] - before.HBMClocks[channel];
}


/*! \brief Direct read of memory controller PMU counter (counter meaning depends on the programming: power/performance/etc)
    \param counter counter number
    \param channel channel number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getMCCounter(uint32 channel, uint32 counter, const CounterStateType & before, const CounterStateType & after)
{
    return after.MCCounter[channel][counter] - before.MCCounter[channel][counter];
}

/*! \brief Direct read of CXLCM PMU counter (counter meaning depends on the programming: power/performance/etc)
    \param counter counter number
    \param port port number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getCXLCMCounter(uint32 port, uint32 counter, const CounterStateType& before, const CounterStateType& after)
{
    return after.CXLCMCounter[port][counter] - before.CXLCMCounter[port][counter];
}

/*! \brief Direct read of CXLDP PMU counter (counter meaning depends on the programming: power/performance/etc)
    \param counter counter number
    \param port port number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getCXLDPCounter(uint32 port, uint32 counter, const CounterStateType& before, const CounterStateType& after)
{
    return after.CXLDPCounter[port][counter] - before.CXLDPCounter[port][counter];
}

/*! \brief Direct read of M3UPI PMU counter (counter meaning depends on the programming: power/performance/etc)
    \param counter counter number
    \param port UPI port number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getM3UPICounter(uint32 port, uint32 counter, const CounterStateType& before, const CounterStateType& after)
{
    return after.M3UPICounter[port][counter] - before.M3UPICounter[port][counter];
}

/*! \brief Direct read of uncore PMU counter (counter meaning depends on the programming: power/performance/etc)
    \param counter counter number
    \param pmu_id ID of PMU (unit type: CBO, etc)
    \param unit uncore unit ID
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getUncoreCounter(const int pmu_id, uint32 unit, uint32 counter, const CounterStateType& before, const CounterStateType& after)
{
    for (size_t die = 0; counter < UncorePMU::maxCounters && die < after.Counters.size(); ++die)
    {
        assert(die < before.Counters.size());
        const auto afterIter = after.Counters[die].find(pmu_id);
        const auto beforeIter = before.Counters[die].find(pmu_id);
        if (afterIter != after.Counters[die].end() && beforeIter != before.Counters[die].end())
        {
            assert(afterIter->second.size() == beforeIter->second.size());
            if (unit < afterIter->second.size())
            {
                return afterIter->second[unit][counter] - beforeIter->second[unit][counter];
            }
            unit -= afterIter->second.size();
        }
    }
    return 0ULL;
}

/*! \brief Direct read of IIO PMU counter (counter meaning depends on the programming: power/performance/etc)
    \param counter counter number
    \param stack IIO stack number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getIIOCounter(uint32 stack, uint32 counter, const CounterStateType& before, const CounterStateType& after)
{
    return after.IIOCounter[stack][counter] - before.IIOCounter[stack][counter];
}

/*! \brief Direct read of IRP PMU counter (counter meaning depends on the programming: power/performance/etc)
    \param counter counter number
    \param stack IIO stack number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getIRPCounter(uint32 stack, uint32 counter, const CounterStateType& before, const CounterStateType& after)
{
    return after.IRPCounter[stack][counter] - before.IRPCounter[stack][counter];
}

/*! \brief Direct read of UPI or QPI PMU counter (counter meaning depends on the programming: power/performance/etc)
    \param counter counter number
    \param port UPI/QPI port number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getXPICounter(uint32 port, uint32 counter, const CounterStateType& before, const CounterStateType& after)
{
    return after.xPICounter[port][counter] - before.xPICounter[port][counter];
}

/*! \brief Direct read of Memory2Mesh controller PMU counter (counter meaning depends on the programming: power/performance/etc)
    \param counter counter number
    \param controller controller number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getM2MCounter(uint32 controller, uint32 counter, const CounterStateType & before, const CounterStateType & after)
{
    return after.M2MCounter[controller][counter] - before.M2MCounter[controller][counter];
}

/*! \brief Direct read of HA controller PMU counter (counter meaning depends on the programming: power/performance/etc)
    \param counter counter number
    \param controller controller number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getHACounter(uint32 controller, uint32 counter, const CounterStateType & before, const CounterStateType & after)
{
    return after.HACounter[controller][counter] - before.HACounter[controller][counter];
}

/*! \brief Direct read of embedded DRAM memory controller counter (counter meaning depends on the programming: power/performance/etc)
    \param counter counter number
    \param channel channel number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getEDCCounter(uint32 channel, uint32 counter, const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->HBMmemoryTrafficMetricsAvailable())
        return after.EDCCounter[channel][counter] - before.EDCCounter[channel][counter];
    return 0ULL;
}

/*!  \brief Returns clock ticks of power control unit
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getPCUClocks(uint32 unit, const CounterStateType & before, const CounterStateType & after)
{
    return getUncoreCounter(PCM::PCU_PMU_ID, unit, 0, before, after);
}

/*!  \brief Returns energy consumed by processor, excluding DRAM (measured in internal units)
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getConsumedEnergy(const CounterStateType & before, const CounterStateType & after)
{
    return after.PackageEnergyStatus - before.PackageEnergyStatus;
}

/*!  \brief Returns energy consumed by processor, excluding DRAM (measured in internal units)
    \param powerPlane power plane ID
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getConsumedEnergy(const int powerPlane, const CounterStateType& before, const CounterStateType& after)
{
    assert(powerPlane <= PCM::MAX_PP);
    return after.PPEnergyStatus[powerPlane] - before.PPEnergyStatus[powerPlane];
}

/*!  \brief Returns energy consumed by system
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getSystemConsumedEnergy(const CounterStateType& before, const CounterStateType& after)
{
    return after.systemEnergyStatus - before.systemEnergyStatus;
}

/*!  \brief Checks is systemEnergyStatusValid is valid in the state
*   \param s CPU counter state
*/
template <class CounterStateType>
bool systemEnergyStatusValid(const CounterStateType& s)
{
    return s.systemEnergyStatus != 0;
}

/*!  \brief Returns energy consumed by DRAM (measured in internal units)
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getDRAMConsumedEnergy(const CounterStateType & before, const CounterStateType & after)
{
    return after.DRAMEnergyStatus - before.DRAMEnergyStatus;
}


/*!  \brief Returns free running counter if it exists, -1 otherwise
 *   \param counter name of the counter
 *   \param before CPU counter state before the experiment
 *   \param after CPU counter state after the experiment
 */
template <class CounterStateType>
int64 getFreeRunningCounter(const typename CounterStateType::FreeRunningCounterID & counter, const CounterStateType & before, const CounterStateType & after)
{
    const auto beforeIt = before.freeRunningCounter.find(counter);
    const auto afterIt = after.freeRunningCounter.find(counter);
    if (beforeIt != before.freeRunningCounter.end() &&
        afterIt != after.freeRunningCounter.end())
    {
        return afterIt->second - beforeIt->second;
    }
    return -1;
}


/*!  \brief Returns uncore clock ticks
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getUncoreClocks(const CounterStateType& before, const CounterStateType& after)
{
    return after.UncClocks - before.UncClocks;
}

/*!  \brief Returns Joules consumed by processor (excluding DRAM)
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
double getConsumedJoules(const CounterStateType & before, const CounterStateType & after)
{
    PCM * m = PCM::getInstance();
    if (!m) return -1.;

    return double(getConsumedEnergy(before, after)) * m->getJoulesPerEnergyUnit();
}

/*!  \brief Returns Joules consumed by processor (excluding DRAM)
    \param powePlane power plane
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
double getConsumedJoules(const int powerPlane, const CounterStateType& before, const CounterStateType& after)
{
    PCM* m = PCM::getInstance();
    if (!m) return -1.;

    return double(getConsumedEnergy(powerPlane, before, after)) * m->getJoulesPerEnergyUnit();
}

/*!  \brief Returns Joules consumed by system
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
double getSystemConsumedJoules(const CounterStateType& before, const CounterStateType& after)
{
    PCM* m = PCM::getInstance();
    if (!m) return -1.;

    auto unit = m->getJoulesPerEnergyUnit();

    switch (m->getCPUFamilyModel())
    {
           case PCM::SPR:
           case PCM::EMR:
           case PCM::GNR:
           case PCM::SRF:
                   unit = 1.0;
                   break;
    }

    return double(getSystemConsumedEnergy(before, after)) * unit;
}

/*!  \brief Returns Joules consumed by DRAM
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
double getDRAMConsumedJoules(const CounterStateType & before, const CounterStateType & after)
{
    PCM * m = PCM::getInstance();
    if (!m) return -1.;
    double dram_joules_per_energy_unit = 0.;
    const auto cpu_family_model = m->getCPUFamilyModel();

    if (PCM::HASWELLX == cpu_family_model
        || PCM::BDX_DE == cpu_family_model
        || PCM::BDX == cpu_family_model
        || PCM::SKX == cpu_family_model
        || PCM::ICX == cpu_family_model
        || PCM::KNL == cpu_family_model
        ) {
/* as described in sections 5.3.2 (DRAM_POWER_INFO) and 5.3.3 (DRAM_ENERGY_STATUS) of
 * Volume 2 (Registers) of
 * Intel Xeon E5-1600 v3 and Intel Xeon E5-2600 v3 (Haswell-EP) Datasheet (Ref 330784-001, Sept.2014)
 * ENERGY_UNIT for DRAM domain is fixed to 15.3 uJ for server HSX, BDW and KNL processors.
 */
        dram_joules_per_energy_unit = 0.0000153;
    } else {
/* for all other processors (including Haswell client/mobile SKUs) the ENERGY_UNIT for DRAM domain
 * should be read from PACKAGE_POWER_SKU register (usually value around ~61uJ)
 */
        dram_joules_per_energy_unit = m->getJoulesPerEnergyUnit();
    }
    return double(getDRAMConsumedEnergy(before, after)) * dram_joules_per_energy_unit;
}

//! \brief Basic uncore counter state
//!
//! Intended only for derivation, but not for the direct use
class UncoreCounterState
{
    friend class PCM;
    friend class JSONPrinter;
    template <class CounterStateType>
    friend uint64 getBytesReadFromMC(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getBytesWrittenToMC(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>

    friend uint64 getNMHits(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getNMMisses(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getNMHitRate(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getNMMissBW(const CounterStateType & before, const CounterStateType & after);

    template <class CounterStateType>
    friend uint64 getBytesReadFromPMM(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getBytesWrittenToPMM(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getBytesReadFromEDC(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getBytesWrittenToEDC(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getGTRequestBytesFromMC(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getIARequestBytesFromMC(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getIORequestBytesFromMC(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getConsumedEnergy(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getConsumedEnergy(const int pp, const CounterStateType& before, const CounterStateType& after);
    template <class CounterStateType>
    friend uint64 getDRAMConsumedEnergy(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getUncoreClocks(const CounterStateType& before, const CounterStateType& after);
    template <class CounterStateType>
    friend double getPackageCStateResidency(int state, const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getPackageCStateResidency(int state, const CounterStateType& now);
    template <class CounterStateType>
    friend double getLLCReadMissLatency(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getLocalMemoryRequestRatio(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getAverageUncoreFrequency(const CounterStateType& before, const CounterStateType& after);
    template <class CounterStateType>
    friend std::vector<double> getUncoreFrequency(const CounterStateType& state);
    template <class CounterStateType>
    friend std::vector<uint64> getUncoreDieTypes(const CounterStateType& state);
    template <class CounterStateType>
    friend double getAverageFrequencyFromClocks(const int64 clocks, const CounterStateType& before, const CounterStateType& after);

public:
    enum DieTypeBits
    {
        Compute = 1<<23,
        LLC     = 1<<24,
        Memory  = 1<<25,
        IO      = 1<<26
    };
    static std::string getDieTypeStr(const uint64 d)
    {
        std::string type{};
        if (d & UncoreCounterState::Compute)
        {
            type += "COR";
        }
        if (d & UncoreCounterState::IO)
        {
            type += "IO";
        }
        if (d & UncoreCounterState::LLC)
        {
            type += "LLC";
        }
        if (d & UncoreCounterState::Memory)
        {
            type += "M";
        }
        return type;
    }
protected:
    std::vector<uint64> UFSStatus;
    uint64 UncMCFullWrites;
    uint64 UncMCNormalReads;
    uint64 UncHARequests;
    uint64 UncHALocalRequests;
    uint64 UncNMMiss;
    uint64 UncNMHit;
    uint64 UncPMMWrites;
    uint64 UncPMMReads;
    uint64 UncEDCFullWrites;
    uint64 UncEDCNormalReads;
    uint64 UncMCGTRequests;
    uint64 UncMCIARequests;
    uint64 UncMCIORequests;
    uint64 PackageEnergyStatus;
    uint64 PPEnergyStatus[PCM::MAX_PP + 1];
    uint64 DRAMEnergyStatus;
    uint64 TOROccupancyIAMiss;
    uint64 TORInsertsIAMiss;
    uint64 UncClocks;
    uint64 CStateResidency[PCM::MAX_C_STATE + 1];
    void readAndAggregate(std::shared_ptr<SafeMsrHandle>);

public:
    UncoreCounterState() :
        UFSStatus{{}},
        UncMCFullWrites(0),
        UncMCNormalReads(0),
        UncHARequests(0),
        UncHALocalRequests(0),
        UncNMMiss(0),
        UncNMHit(0),
        UncPMMWrites(0),
        UncPMMReads(0),
        UncEDCFullWrites(0),
        UncEDCNormalReads(0),
        UncMCGTRequests(0),
        UncMCIARequests(0),
        UncMCIORequests(0),
        PackageEnergyStatus(0),
        DRAMEnergyStatus(0),
        TOROccupancyIAMiss(0),
        TORInsertsIAMiss(0),
        UncClocks(0)
    {
        UFSStatus.clear();
        std::fill(CStateResidency, CStateResidency + PCM::MAX_C_STATE + 1, 0);
        std::fill(PPEnergyStatus, PPEnergyStatus + PCM::MAX_PP + 1, 0);
    }
    virtual ~UncoreCounterState() { }

    UncoreCounterState( const UncoreCounterState& ) = default;
    UncoreCounterState( UncoreCounterState&& ) = default;
    UncoreCounterState & operator = ( UncoreCounterState&& ) = default;

    UncoreCounterState & operator += (const UncoreCounterState & o)
    {
        UncMCFullWrites += o.UncMCFullWrites;
        UncMCNormalReads += o.UncMCNormalReads;
        UncHARequests += o.UncHARequests;
        UncHALocalRequests += o.UncHALocalRequests;
        UncPMMReads += o.UncPMMReads;
        UncPMMWrites += o.UncPMMWrites;
        UncEDCFullWrites += o.UncEDCFullWrites;
        UncEDCNormalReads += o.UncEDCNormalReads;
        UncMCGTRequests += o.UncMCGTRequests;
        UncMCIARequests += o.UncMCIARequests;
        UncMCIORequests += o.UncMCIORequests;
        PackageEnergyStatus += o.PackageEnergyStatus;
        DRAMEnergyStatus += o.DRAMEnergyStatus;
        TOROccupancyIAMiss += o.TOROccupancyIAMiss;
        TORInsertsIAMiss += o.TORInsertsIAMiss;
        UncClocks += o.UncClocks;
        for (int i = 0; i <= (int)PCM::MAX_C_STATE; ++i)
            CStateResidency[i] += o.CStateResidency[i];
        return *this;
    }
};


//! \brief Server uncore counter state
//!
class ServerUncoreCounterState : public UncoreCounterState
{
public:
    enum {
        maxControllers = 32,
        maxChannels = 32,
        maxXPILinks = 6,
        maxIIOStacks = 16,
        maxCXLPorts = 16,
        maxCounters = UncorePMU::maxCounters
    };
    enum EventPosition
    {
        xPI_TxL0P_POWER_CYCLES = 0,
        xPI_L1_POWER_CYCLES = 2,
        xPI_CLOCKTICKS = 3
    };
    enum FreeRunningCounterID
    {
        ImcReads,
        ImcWrites,
        PMMReads,
        PMMWrites
    };

    // typedef std::array<uint64, maxCounters> CounterArrayType;
    class CounterArrayType
    {
        std::array<uint64, maxCounters> data;
    public:
        CounterArrayType() : data{{}}
        {
            std::fill(data.begin(), data.end(), 0ULL);
        }
        const uint64& operator [] (size_t i) const
        {
            return data[i];
        }
        uint64& operator [] (size_t i)
        {
            return data[i];
        }
    };
    typedef std::vector<CounterArrayType> PMUCounterArrayType;
    typedef std::unordered_map<int, PMUCounterArrayType> PMUMapCounterArrayType;
    // die -> pmu map -> PMUs -> counters
    std::vector<PMUMapCounterArrayType>  Counters;

    std::array<std::array<uint64, maxCounters>, maxXPILinks> xPICounter;
    std::array<std::array<uint64, maxCounters>, maxXPILinks> M3UPICounter;
    std::array<std::array<uint64, maxCounters>, maxIIOStacks> IIOCounter;
    std::array<std::array<uint64, maxCounters>, maxIIOStacks> IRPCounter;
    std::array<std::array<uint64, maxCounters>, maxCXLPorts> CXLCMCounter;
    std::array<std::array<uint64, maxCounters>, maxCXLPorts> CXLDPCounter;
    std::array<uint64, maxChannels> DRAMClocks;
    std::array<uint64, maxChannels> HBMClocks;
    std::array<std::array<uint64, maxCounters>, maxChannels> MCCounter; // channel X counter
    std::array<std::array<uint64, maxCounters>, maxControllers> M2MCounter; // M2M/iMC boxes x counter
    std::array<std::array<uint64, maxCounters>, maxControllers> HACounter; // HA boxes x counter
    std::array<std::array<uint64, maxCounters>, maxChannels> EDCCounter; // EDC controller X counter
    std::unordered_map<int, uint64> freeRunningCounter;
    int32 PackageThermalHeadroom;
    uint64 InvariantTSC;    // invariant time stamp counter
    friend class PCM;
    template <class CounterStateType>
    friend uint64 getDRAMClocks(uint32 channel, const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getHBMClocks(uint32 channel, const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getMCCounter(uint32 channel, uint32 counter, const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getCXLCMCounter(uint32 port, uint32 counter, const CounterStateType& before, const CounterStateType& after);
    template <class CounterStateType>
    friend uint64 getCXLDPCounter(uint32 port, uint32 counter, const CounterStateType& before, const CounterStateType& after);
    template <class CounterStateType>
    friend uint64 getM3UPICounter(uint32 port, uint32 counter, const CounterStateType& before, const CounterStateType& after);
    template <class CounterStateType>
    friend uint64 getUncoreCounter(const int pmu_id, uint32 unit, uint32 counter, const CounterStateType& before, const CounterStateType& after);
    template <class CounterStateType>
    friend uint64 getIIOCounter(uint32 stack, uint32 counter, const CounterStateType& before, const CounterStateType& after);
    template <class CounterStateType>
    friend uint64 getIRPCounter(uint32 stack, uint32 counter, const CounterStateType& before, const CounterStateType& after);
    template <class CounterStateType>
    friend uint64 getXPICounter(uint32 port, uint32 counter, const CounterStateType& before, const CounterStateType& after);
    template <class CounterStateType>
    friend uint64 getM2MCounter(uint32 controller, uint32 counter, const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getHACounter(uint32 controller, uint32 counter, const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getEDCCounter(uint32 channel, uint32 counter, const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getConsumedEnergy(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getDRAMConsumedEnergy(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend uint64 getInvariantTSC(const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend int64 getFreeRunningCounter(const typename CounterStateType::FreeRunningCounterID &, const CounterStateType & before, const CounterStateType & after);
    template <class CounterStateType>
    friend double getAverageFrequencyFromClocks(const int64 clocks, const CounterStateType& before, const CounterStateType& after);

public:
    //! Returns current thermal headroom below TjMax
    int32 getPackageThermalHeadroom() const { return PackageThermalHeadroom; }
    ServerUncoreCounterState() :
        xPICounter{{}},
        M3UPICounter{{}},
        IIOCounter{{}},
        IRPCounter{{}},
        CXLCMCounter{{}},
        CXLDPCounter{{}},
        DRAMClocks{{}},
        HBMClocks{{}},
        MCCounter{{}},
        M2MCounter{{}},
        HACounter{{}},
        EDCCounter{{}},
        PackageThermalHeadroom(0),
        InvariantTSC(0)
    {
    }
};

/*! \brief Returns QPI LL clock ticks
    \param port QPI port number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getQPIClocks(uint32 port, const CounterStateType& before, const CounterStateType& after)
{
    return getXPICounter(port, ServerUncoreCounterState::EventPosition::xPI_CLOCKTICKS, before, after);
}

/*! \brief Returns the number of QPI cycles in power saving half-lane mode
    \param port QPI port number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getQPIL0pTxCycles(uint32 port, const CounterStateType& before, const CounterStateType& after)
{
    return getXPICounter(port, ServerUncoreCounterState::EventPosition::xPI_TxL0P_POWER_CYCLES, before, after);
}

/*! \brief Returns the number of QPI cycles in power saving shutdown mode
    \param port QPI port number
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
*/
template <class CounterStateType>
uint64 getQPIL1Cycles(uint32 port, const CounterStateType& before, const CounterStateType& after)
{
    return getXPICounter(port, ServerUncoreCounterState::EventPosition::xPI_L1_POWER_CYCLES, before, after);
}

//! \brief (Logical) core-wide counter state
class CoreCounterState : public BasicCounterState
{
    friend class PCM;

public:
    CoreCounterState() = default;
    CoreCounterState( const CoreCounterState& ) = default;
    CoreCounterState( CoreCounterState&& ) = default;
    CoreCounterState & operator= ( CoreCounterState&& ) = default;
    virtual ~ CoreCounterState() {}
};

//! \brief Socket-wide counter state
class SocketCounterState : public BasicCounterState, public UncoreCounterState
{
    friend class PCM;

protected:
    // cppcheck-suppress duplInheritedMember
    void readAndAggregate(std::shared_ptr<SafeMsrHandle> handle)
    {
        BasicCounterState::readAndAggregate(handle);
        UncoreCounterState::readAndAggregate(handle);
    }

public:
    // cppcheck-suppress duplInheritedMember
    SocketCounterState& operator += ( const BasicCounterState& ccs )
    {
        BasicCounterState::operator += ( ccs );

        return *this;
    }

    // cppcheck-suppress duplInheritedMember
    SocketCounterState& operator += ( const UncoreCounterState& ucs )
    {
        UncoreCounterState::operator += ( ucs );

        return *this;
    }

    SocketCounterState() = default;
    SocketCounterState( const SocketCounterState& ) = default;
    SocketCounterState( SocketCounterState&& ) = default;
    SocketCounterState & operator = ( SocketCounterState&& ) = default;

    // cppcheck-suppress duplInheritedMember
    SocketCounterState & operator = ( UncoreCounterState&& ucs ) {
        UncoreCounterState::operator = ( std::move(ucs) );
        return *this;
    }

    virtual ~ SocketCounterState() {}
};

//! \brief System-wide counter state
class SystemCounterState : public SocketCounterState
{
    friend class PCM;
    friend std::vector<uint64> getTPMIEvent(const PCM::RawEventEncoding& eventEnc, const SystemCounterState& before, const SystemCounterState& after);
    friend std::vector<uint64> getPCICFGEvent(const PCM::RawEventEncoding& eventEnc, const SystemCounterState& before, const SystemCounterState& after);
    friend std::vector<uint64> getMMIOEvent(const PCM::RawEventEncoding& eventEnc, const SystemCounterState& before, const SystemCounterState& after);
    friend std::vector<uint64> getPMTEvent(const PCM::RawEventEncoding& eventEnc, const SystemCounterState& before, const SystemCounterState& after);
    template <class CounterStateType> friend bool systemEnergyStatusValid(const CounterStateType& s);
    template <class CounterStateType> friend uint64 getSystemConsumedEnergy(const CounterStateType& before, const CounterStateType& after);

    std::vector<std::vector<uint64> > incomingQPIPackets; // each 64 byte
    std::vector<std::vector<uint64> > outgoingQPIFlits; // idle or data/non-data flits depending on the architecture
    std::vector<std::vector<uint64> > TxL0Cycles;
    uint64 uncoreTSC;
    uint64 systemEnergyStatus;
    std::unordered_map<PCM::RawEventEncoding, std::vector<uint64> , PCM::TPMIRegisterEncodingHash, PCM::TPMIRegisterEncodingCmp> TPMIValues{};
    std::unordered_map<PCM::RawEventEncoding, std::vector<uint64> , PCM::PCICFGRegisterEncodingHash, PCM::PCICFGRegisterEncodingCmp> PCICFGValues{};
    std::unordered_map<PCM::RawEventEncoding, std::vector<uint64>, PCM::MMIORegisterEncodingHash, PCM::MMIORegisterEncodingCmp> MMIOValues{};
    std::unordered_map<PCM::RawEventEncoding, std::vector<uint64>, PCM::PMTRegisterEncodingHash2> PMTValues{};

protected:
    // cppcheck-suppress duplInheritedMember
    void readAndAggregate(std::shared_ptr<SafeMsrHandle> handle)
    {
        BasicCounterState::readAndAggregate(handle);
        UncoreCounterState::readAndAggregate(handle);
    }

public:
    typedef uint32_t h_id;
    typedef uint32_t v_id;
    typedef std::map<std::pair<h_id,v_id>,uint64_t> ctr_data;
    typedef std::vector<ctr_data> dev_content;
    std::vector<SimpleCounterState> accel_counters;
    std::vector<uint64> CXLWriteMem,CXLWriteCache;
    friend uint64 getIncomingQPILinkBytes(uint32 socketNr, uint32 linkNr, const SystemCounterState & before, const SystemCounterState & after);
    friend uint64 getIncomingQPILinkBytes(uint32 socketNr, uint32 linkNr, const SystemCounterState & now);
    friend double getOutgoingQPILinkUtilization(uint32 socketNr, uint32 linkNr, const SystemCounterState & before, const SystemCounterState & after);
    friend uint64 getOutgoingQPILinkBytes(uint32 socketNr, uint32 linkNr, const SystemCounterState & before, const SystemCounterState & after);
    friend uint64 getOutgoingQPILinkBytes(uint32 socketNr, uint32 linkNr, const SystemCounterState & now);

    SystemCounterState() :
        uncoreTSC(0),
        systemEnergyStatus(0)
    {
        PCM * m = PCM::getInstance();
        accel_counters.resize(m->getNumberofAccelCounters());
        CXLWriteMem.resize(m->getNumSockets(),0);
        CXLWriteCache.resize(m->getNumSockets(),0);
        incomingQPIPackets.resize(m->getNumSockets(),
                                  std::vector<uint64>((uint32)m->getQPILinksPerSocket(), 0));
        outgoingQPIFlits.resize(m->getNumSockets(),
                                    std::vector<uint64>((uint32)m->getQPILinksPerSocket(), 0));
        TxL0Cycles.resize(m->getNumSockets(),
                                    std::vector<uint64>((uint32)m->getQPILinksPerSocket(), 0));
    }

    SystemCounterState( const SystemCounterState& ) = default;
    SystemCounterState( SystemCounterState&& ) = default;
    SystemCounterState & operator = ( SystemCounterState&& ) = default;

    // cppcheck-suppress duplInheritedMember
    SystemCounterState & operator += ( const SocketCounterState& scs )
    {
        BasicCounterState::operator += ( scs );
        UncoreCounterState::operator += ( scs );

        return *this;
    }

    // cppcheck-suppress duplInheritedMember
    SystemCounterState & operator += ( const UncoreCounterState& ucs )
    {
        UncoreCounterState::operator += ( ucs );

        return *this;
    }

    virtual ~ SystemCounterState() {}
};

/*! \brief Reads the counter state of the system

        Helper function. Uses PCM object to access counters.

        System consists of several sockets (CPUs).
        Socket has a CPU in it. Socket (CPU) consists of several (logical) cores.

        \return State of counters in the entire system
*/
PCM_API SystemCounterState getSystemCounterState();

/*! \brief Reads the counter state of a socket

        Helper function. Uses PCM object to access counters.

        \param socket socket id
        \return State of counters in the socket
*/
PCM_API SocketCounterState getSocketCounterState(uint32 socket);

/*! \brief Reads the counter state of a (logical) core

    Helper function. Uses PCM object to access counters.

    \param core core id
    \return State of counters in the core
*/
PCM_API CoreCounterState getCoreCounterState(uint32 core);


/*! \brief Computes average number of retired instructions per core cycle (IPC)

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return IPC
*/
template <class CounterStateType>
double getIPC(const CounterStateType & before, const CounterStateType & after) // instructions per cycle
{
    int64 clocks = after.CpuClkUnhaltedThread - before.CpuClkUnhaltedThread;
    if (clocks != 0)
        return double(after.InstRetiredAny - before.InstRetiredAny) / double(clocks);
    return -1;
}

// \brief Returns current uncore frequency vector
template <class CounterStateType>
std::vector<double> getUncoreFrequency(const CounterStateType& state)
{
    std::vector<double> result;
    for (auto & e : state.UFSStatus)
    {
        result.push_back(extract_bits(e, 0, 6) * 100000000.);
    }
    return result;
}

// \brief Returns uncore die type vector
template <class CounterStateType>
std::vector<uint64> getUncoreDieTypes(const CounterStateType& state)
{
    std::vector<uint64> result;
    for (auto & e : state.UFSStatus)
    {
        result.push_back(extract_bits(e, 23, 26) << 23);
    }
    return result;
}

/*! \brief Computes the number of retired instructions

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return number of retired instructions
*/
template <class CounterStateType>
uint64 getInstructionsRetired(const CounterStateType & before, const CounterStateType & after) // instructions
{
    return after.InstRetiredAny - before.InstRetiredAny;
}

/*! \brief Computes average number of retired instructions per time interval

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return usage
*/
template <class CounterStateType>
double getExecUsage(const CounterStateType & before, const CounterStateType & after) // usage
{
    int64 timer_clocks = after.InvariantTSC - before.InvariantTSC;
    if (timer_clocks != 0)
        return double(after.InstRetiredAny - before.InstRetiredAny) / double(timer_clocks);
    return -1;
}

/*! \brief Computes the number of retired instructions

    \param now Current CPU counter state
    \return number of retired instructions
*/
template <class CounterStateType>
uint64 getInstructionsRetired(const CounterStateType & now) // instructions
{
    return now.InstRetiredAny.getRawData_NoOverflowProtection();
}

/*! \brief Computes the number core clock cycles when signal on a specific core is running (not halted)

    Returns number of used cycles (halted cyles are not counted).
    The counter does not advance in the following conditions:
    - an ACPI C-state is other than C0 for normal operation
    - HLT
    - STPCLK+ pin is asserted
    - being throttled by TM1
    - during the frequency switching phase of a performance state transition

    The performance counter for this event counts across performance state
    transitions using different core clock frequencies

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return number core clock cycles
*/
template <class CounterStateType>
uint64 getCycles(const CounterStateType & before, const CounterStateType & after) // clocks
{
    return after.CpuClkUnhaltedThread - before.CpuClkUnhaltedThread;
}

/*! \brief Computes the number of reference clock cycles while clock signal on the core is running

    The reference clock operates at a fixed frequency, irrespective of core
    frequency changes due to performance state transitions. See Intel(r) Software
    Developer's Manual for more details

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return number core clock cycles
*/
template <class CounterStateType>
uint64 getRefCycles(const CounterStateType & before, const CounterStateType & after) // clocks
{
    return after.CpuClkUnhaltedRef - before.CpuClkUnhaltedRef;
}

/*! \brief Computes the number executed core clock cycles

    Returns number of used cycles (halted cyles are not counted).

    \param now Current CPU counter state
    \return number core clock cycles
*/
template <class CounterStateType>
uint64 getCycles(const CounterStateType & now) // clocks
{
    return now.CpuClkUnhaltedThread.getRawData_NoOverflowProtection();
}

/*! \brief Computes average number of retired instructions per core cycle for the entire system combining instruction counts from logical cores to corresponding physical cores

        Use this metric to evaluate IPC improvement between SMT(Hyperthreading) on and SMT off.

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return IPC
*/
template <class CounterStateType>
inline double getCoreIPC(const CounterStateType & before, const CounterStateType & after) // instructions per cycle
{
    double ipc = getIPC(before, after);
    PCM * m = PCM::getInstance();
    if (ipc >= 0. && m && (m->getNumCores() == m->getNumOnlineCores()))
        return ipc * double(m->getThreadsPerCore());
    return -1;
}

/*! \brief Computes average number of retired instructions per time interval for the entire system combining instruction counts from logical cores to corresponding physical cores

        Use this metric to evaluate cores utilization improvement between SMT(Hyperthreading) on and SMT off.

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return usage
*/
template <class CounterStateType>
inline double getTotalExecUsage(const CounterStateType & before, const CounterStateType & after) // usage
{
    double usage = getExecUsage(before, after);
    PCM * m = PCM::getInstance();
    if (usage >= 0. && m && (m->getNumCores() == m->getNumOnlineCores()))
        return usage * double(m->getThreadsPerCore());
    return -1;
}

template <class StateType>
double getAverageFrequencyFromClocks(const int64 clocks, const StateType& before, const StateType& after) // in Hz
{
    const int64 timer_clocks = after.InvariantTSC - before.InvariantTSC;
    PCM* m = PCM::getInstance();
    if (timer_clocks != 0 && m)
        return double(m->getNominalFrequency()) * double(clocks) / double(timer_clocks);
    return -1;
}

/*! \brief Computes average core frequency also taking Intel Turbo Boost technology into account

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return frequency in Hz
*/
template <class CounterStateType>
double getAverageFrequency(const CounterStateType & before, const CounterStateType & after) // in Hz
{
    return getAverageFrequencyFromClocks(after.CpuClkUnhaltedThread - before.CpuClkUnhaltedThread, before, after);
}

/*! \brief Computes average uncore frequency

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return frequency in Hz
*/
template <class UncoreStateType>
double getAverageUncoreFrequency(const UncoreStateType& before, const UncoreStateType & after) // in Hz
{
    auto m = PCM::getInstance();
    assert(m);
    return double(m->getNumOnlineCores()) * getAverageFrequencyFromClocks(after.UncClocks - before.UncClocks, before, after) / double(m->getNumOnlineSockets());
}

/*! \brief Computes uncore frequency for all dies

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return frequency in Hz
*/
template <class UncoreStateType>
std::vector<double> getUncoreFrequencies(const UncoreStateType& before, const UncoreStateType & after) // in Hz
{
    auto m = PCM::getInstance();
    assert(m);
    std::vector<double> uncoreFrequencies{getUncoreFrequency(after)};
    if (m->uncoreFrequencyMetricAvailable())
    {
        uncoreFrequencies.push_back(getAverageUncoreFrequency(before, after));
    }
    return uncoreFrequencies;
}

/*! \brief Computes average core frequency when not in powersaving C0-state (also taking Intel Turbo Boost technology into account)

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return frequency in Hz
*/
template <class CounterStateType>
double getActiveAverageFrequency(const CounterStateType & before, const CounterStateType & after) // in Hz
{
    int64 clocks = after.CpuClkUnhaltedThread - before.CpuClkUnhaltedThread;
    int64 ref_clocks = after.CpuClkUnhaltedRef - before.CpuClkUnhaltedRef;
    PCM * m = PCM::getInstance();
    if (ref_clocks != 0 && m)
        return double(m->getNominalFrequency()) * double(clocks) / double(ref_clocks);
    return -1;
}

/*! \brief Computes average core frequency also taking Intel Turbo Boost technology into account

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Fraction of nominal frequency
*/
template <class CounterStateType>
double getRelativeFrequency(const CounterStateType & before, const CounterStateType & after) // fraction of nominal frequency
{
    int64 clocks = after.CpuClkUnhaltedThread - before.CpuClkUnhaltedThread;
    int64 timer_clocks = after.InvariantTSC - before.InvariantTSC;
    if (timer_clocks != 0)
        return double(clocks) / double(timer_clocks);
    return -1;
}

/*! \brief Computes average core frequency when not in powersaving C0-state (also taking Intel Turbo Boost technology into account)

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Fraction of nominal frequency (if >1.0 then Turbo was working during the measurement)
*/
template <class CounterStateType>
double getActiveRelativeFrequency(const CounterStateType & before, const CounterStateType & after) // fraction of nominal frequency
{
    if (!PCM::getInstance()->isActiveRelativeFrequencyAvailable()) return -1.;
    int64 clocks = after.CpuClkUnhaltedThread - before.CpuClkUnhaltedThread;
    int64 ref_clocks = after.CpuClkUnhaltedRef - before.CpuClkUnhaltedRef;
    if (ref_clocks != 0)
        return double(clocks) / double(ref_clocks);
    return -1;
}

/*! \brief Computes L2 cache hit ratio

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \warning Works only in the DEFAULT_EVENTS programming mode (see program() method)
    \return value between 0 and 1
*/
template <class CounterStateType>
double getL2CacheHitRatio(const CounterStateType& before, const CounterStateType& after) // 0.0 - 1.0
{
    auto* pcm = PCM::getInstance();
    if (!pcm->isL2CacheHitRatioAvailable()) return 0;
    const auto hits = getL2CacheHits(before, after);
    if (pcm->memoryEventErrata())
    {
        const auto all = after.Event[BasicCounterState::HSXL2RefPos] - before.Event[BasicCounterState::HSXL2RefPos];
        if (all == 0ULL) return 0.;
        return double(hits) / double(all);
    }
    const auto misses = getL2CacheMisses(before, after);
    const auto all = double(hits + misses);
    if (all == 0.0) return 0.;
    return double(hits) / all;
}

/*! \brief Computes L3 cache hit ratio

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \warning Works only in the DEFAULT_EVENTS programming mode (see program() method)
    \return value between 0 and 1
*/
template <class CounterStateType>
double getL3CacheHitRatio(const CounterStateType& before, const CounterStateType& after) // 0.0 - 1.0
{
    if (!PCM::getInstance()->isL3CacheHitRatioAvailable()) return 0;
    const auto hits = getL3CacheHits(before, after);
    const auto misses = getL3CacheMisses(before, after);
    const auto all = double(hits + misses);
    if (all == 0.0) return 0.;
    return double(hits) / all;
}

/*! \brief Computes number of L3 cache misses

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \warning Works only in the DEFAULT_EVENTS programming mode (see program() method)
    \return number of misses
*/
template <class CounterStateType>
uint64 getL3CacheMisses(const CounterStateType & before, const CounterStateType & after)
{
    if (!PCM::getInstance()->isL3CacheMissesAvailable()) return 0;
    return after.Event[BasicCounterState::L3MissPos] - before.Event[BasicCounterState::L3MissPos];
}

/*! \brief Computes number of L2 cache misses

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \warning Works only in the DEFAULT_EVENTS programming mode (see program() method)
    \return number of misses
*/
template <class CounterStateType>
uint64 getL2CacheMisses(const CounterStateType & before, const CounterStateType & after)
{
    auto pcm = PCM::getInstance();
    if (pcm->isL2CacheMissesAvailable() == false) return 0ULL;
    const auto cpu_family_model = pcm->getCPUFamilyModel();
    if (pcm->useSkylakeEvents()
        || cpu_family_model == PCM::SNOWRIDGE
        || cpu_family_model == PCM::ELKHART_LAKE
        || cpu_family_model == PCM::JASPER_LAKE
        || cpu_family_model == PCM::SRF
        || cpu_family_model == PCM::GRR
        || cpu_family_model == PCM::ADL
        || cpu_family_model == PCM::RPL
        || cpu_family_model == PCM::MTL
        || cpu_family_model == PCM::LNL
        || cpu_family_model == PCM::ARL
        || cpu_family_model == PCM::PTL
        ) {
        return after.Event[BasicCounterState::SKLL2MissPos] - before.Event[BasicCounterState::SKLL2MissPos];
    }
    else if (pcm->isAtom() || cpu_family_model == PCM::KNL)
    {
        return after.Event[BasicCounterState::ArchLLCMissPos] - before.Event[BasicCounterState::ArchLLCMissPos];
    }
    else if (pcm->memoryEventErrata())
    {
        return after.Event[BasicCounterState::ArchLLCRefPos] - before.Event[BasicCounterState::ArchLLCRefPos];
    }
    uint64 L3Miss = after.Event[BasicCounterState::L3MissPos] - before.Event[BasicCounterState::L3MissPos];
    uint64 L3UnsharedHit = after.Event[BasicCounterState::L3UnsharedHitPos] - before.Event[BasicCounterState::L3UnsharedHitPos];
    uint64 L2HitM = after.Event[BasicCounterState::L2HitMPos] - before.Event[BasicCounterState::L2HitMPos];
    return L2HitM + L3UnsharedHit + L3Miss;
}

/*! \brief Computes number of L2 cache hits

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \warning Works only in the DEFAULT_EVENTS programming mode (see program() method)
    \return number of hits
*/
template <class CounterStateType>
uint64 getL2CacheHits(const CounterStateType & before, const CounterStateType & after)
{
    auto pcm = PCM::getInstance();
    if (pcm->isL2CacheHitsAvailable() == false) return 0ULL;
    if (pcm->isAtom() || pcm->getCPUFamilyModel() == PCM::KNL)
    {
        uint64 L2Miss = after.Event[BasicCounterState::ArchLLCMissPos] - before.Event[BasicCounterState::ArchLLCMissPos];
        uint64 L2Ref = after.Event[BasicCounterState::ArchLLCRefPos] - before.Event[BasicCounterState::ArchLLCRefPos];
        return L2Ref - L2Miss;
    }
    else if (pcm->memoryEventErrata())
    {
        const auto all = after.Event[BasicCounterState::HSXL2RefPos] - before.Event[BasicCounterState::HSXL2RefPos];
        const auto misses = after.Event[BasicCounterState::HSXL2MissPos] - before.Event[BasicCounterState::HSXL2MissPos];
        const auto hits = (all > misses) ? (all - misses) : 0ULL;
        return hits;
    }
    return after.Event[BasicCounterState::L2HitPos] - before.Event[BasicCounterState::L2HitPos];
}

/*! \brief Computes L3 Cache Occupancy

*/
template <class CounterStateType>
uint64 getL3CacheOccupancy(const CounterStateType & now)
{
    if (PCM::getInstance()->L3CacheOccupancyMetricAvailable() == false) return 0ULL;
    return now.L3Occupancy;
}
/*! \brief Computes Local Memory Bandwidth

 */
template <class CounterStateType>
uint64 getLocalMemoryBW(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->CoreLocalMemoryBWMetricAvailable() == false) return 0ULL;
    return after.MemoryBWLocal - before.MemoryBWLocal;
}

/*! \brief Computes Remote Memory Bandwidth

 */
template <class CounterStateType>
uint64 getRemoteMemoryBW(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->CoreRemoteMemoryBWMetricAvailable() == false) return 0ULL;
    const uint64 total = after.MemoryBWTotal - before.MemoryBWTotal;
    const uint64 local = getLocalMemoryBW(before, after);
    if (total > local)
        return total - local;

    return 0;
}

/*! \brief Computes number of L3 cache hits where no snooping in sibling L2 caches had to be done

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \warning Works only in the DEFAULT_EVENTS programming mode (see program() method)
    \return number of hits
*/
template <class CounterStateType>
uint64 getL3CacheHitsNoSnoop(const CounterStateType & before, const CounterStateType & after)
{
    if (!PCM::getInstance()->isL3CacheHitsNoSnoopAvailable()) return 0;
    return after.Event[BasicCounterState::L3UnsharedHitPos] - before.Event[BasicCounterState::L3UnsharedHitPos];
}

/*! \brief Computes number of L3 cache hits where snooping in sibling L2 caches had to be done

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \warning Works only in the DEFAULT_EVENTS programming mode (see program() method)
    \return number of hits
*/
template <class CounterStateType>
uint64 getL3CacheHitsSnoop(const CounterStateType & before, const CounterStateType & after)
{
    auto pcm = PCM::getInstance();
    if (!pcm->isL3CacheHitsSnoopAvailable()) return 0;
    const auto cpu_family_model = pcm->getCPUFamilyModel();
    if (cpu_family_model == PCM::SNOWRIDGE
        || cpu_family_model == PCM::GRR
        || cpu_family_model == PCM::ELKHART_LAKE
        || cpu_family_model == PCM::JASPER_LAKE
        || cpu_family_model == PCM::SRF
        || cpu_family_model == PCM::ADL
        || cpu_family_model == PCM::RPL
        || cpu_family_model == PCM::MTL
        || cpu_family_model == PCM::LNL
        || cpu_family_model == PCM::ARL
        || cpu_family_model == PCM::PTL
        )
    {
        const int64 misses = getL3CacheMisses(before, after);
        const int64 refs = after.Event[BasicCounterState::ArchLLCRefPos] - before.Event[BasicCounterState::ArchLLCRefPos];
        const int64 hits = refs - misses;
        return (hits > 0)? hits : 0;
    }
    if (pcm->useSkylakeEvents()) {
        return after.Event[BasicCounterState::SKLL3HitPos] - before.Event[BasicCounterState::SKLL3HitPos];
    }
    return after.Event[BasicCounterState::L2HitMPos] - before.Event[BasicCounterState::L2HitMPos];
}


/*! \brief Computes total number of L3 cache hits

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \warning Works only in the DEFAULT_EVENTS programming mode (see program() method)
    \return number of hits
*/
template <class CounterStateType>
uint64 getL3CacheHits(const CounterStateType & before, const CounterStateType & after)
{
    auto * pcm = PCM::getInstance();
    assert(pcm);
    if (!pcm->isL3CacheHitsAvailable()) return 0;
    else if (pcm->memoryEventErrata())
    {
        uint64 LLCMiss = after.Event[BasicCounterState::ArchLLCMissPos] - before.Event[BasicCounterState::ArchLLCMissPos];
        uint64 LLCRef = after.Event[BasicCounterState::ArchLLCRefPos] - before.Event[BasicCounterState::ArchLLCRefPos];
        return (LLCRef > LLCMiss) ? (LLCRef - LLCMiss) : 0ULL;
    }
    return getL3CacheHitsSnoop(before, after) + getL3CacheHitsNoSnoop(before, after);
}

/*! \brief Computes number of invariant time stamp counter ticks

    This counter counts irrespectively of C-, P- or T-states

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return number of time stamp counter ticks
*/
template <class CounterStateType>
uint64 getInvariantTSC(const CounterStateType & before, const CounterStateType & after)
{
    return after.InvariantTSC - before.InvariantTSC;
}

/*! \brief Computes residency in the core C-state

    \param state C-state
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return residence ratio (0..1): 0 - 0%, 1.0 - 100%
*/
template <class CounterStateType>
inline double getCoreCStateResidency(int state, const CounterStateType & before, const CounterStateType & after)
{
    const double tsc = double(getInvariantTSC(before, after));

    if (state == 0) return double(getRefCycles(before, after)) / tsc;

    if (state == 1)
    {
        PCM * m = PCM::getInstance();
        double result = 1.0 - double(getRefCycles(before, after)) / tsc; // 1.0 - cC0
        for (int i = 2; i <= PCM::MAX_C_STATE; ++i)
            if (m->isCoreCStateResidencySupported(state))
                result -= (after.BasicCounterState::CStateResidency[i] - before.BasicCounterState::CStateResidency[i]) / tsc;

        if (result < 0.) result = 0.;       // fix counter dissynchronization
        else if (result > 1.) result = 1.;  // fix counter dissynchronization

        return result;
    }
    return (after.BasicCounterState::CStateResidency[state] - before.BasicCounterState::CStateResidency[state]) / tsc;
}

/*! \brief Reads raw residency counter for the core C-state

    \param state C-state #
    \param now CPU counter state
    \return raw residency value
*/
template <class CounterStateType>
inline uint64 getCoreCStateResidency(int state, const CounterStateType& now)
{
    if (state == 0) return now.CpuClkUnhaltedRef.getRawData_NoOverflowProtection();

    return now.BasicCounterState::CStateResidency[state];
}

/*! \brief Computes residency in the package C-state

    \param state C-state
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return residence ratio (0..1): 0 - 0%, 1.0 - 100%
*/
template <class CounterStateType>
inline double getPackageCStateResidency(int state, const CounterStateType & before, const CounterStateType & after)
{
    const double tsc = double(getInvariantTSC(before, after));
    if (state == 0)
    {
        PCM * m = PCM::getInstance();
        double result = 1.0;
        for (int i = 1; i <= PCM::MAX_C_STATE; ++i)
            if (m->isPackageCStateResidencySupported(state))
                result -= (after.UncoreCounterState::CStateResidency[i] - before.UncoreCounterState::CStateResidency[i]) / tsc;

        if (result < 0.) result = 0.;       // fix counter dissynchronization
        else if (result > 1.) result = 1.;  // fix counter dissynchronization

        return result;
    }
    return double(after.UncoreCounterState::CStateResidency[state] - before.UncoreCounterState::CStateResidency[state]) / tsc;
}

/*! \brief Reads raw residency counter for the package C-state

    \param state C-state #
    \param now CPU counter state
    \return raw residency value
*/
template <class CounterStateType>
inline uint64 getPackageCStateResidency(int state, const CounterStateType& now)
{
    return now.UncoreCounterState::CStateResidency[state];
}

/*! \brief Computes number of bytes read from DRAM memory controllers

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
template <class CounterStateType>
uint64 getBytesReadFromMC(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->memoryTrafficMetricsAvailable())
        return (after.UncMCNormalReads - before.UncMCNormalReads) * 64;
    return 0ULL;
}

/*! \brief Computes number of bytes written to DRAM memory controllers

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
template <class CounterStateType>
uint64 getBytesWrittenToMC(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->memoryTrafficMetricsAvailable())
        return (after.UncMCFullWrites - before.UncMCFullWrites) * 64;
    return 0ULL;
}

/*! \brief Computes number of Near Memory Hits

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
template <class CounterStateType>
uint64 getNMHits(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->nearMemoryMetricsAvailable())
        return (after.UncNMHit - before.UncNMHit);
    return 0ULL;
}

/*! \brief Computes number of Near Memory Misses

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of NMMisses
*/
template <class CounterStateType>
uint64 getNMMisses(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->nearMemoryMetricsAvailable())
        return (after.UncNMMiss - before.UncNMMiss);
    return 0ULL;
}

/*! \brief Computes Near Memory Misses Bandwidth

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
template <class CounterStateType>
uint64 getNMMissBW(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->nearMemoryMetricsAvailable())
        return (after.UncNMMiss - before.UncNMMiss)*64*2;
    return 0ULL;
}

/*! \brief Computes Near Memory Hit/Miss rate as a percentage

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
template <class CounterStateType>
double getNMHitRate(const CounterStateType & before, const CounterStateType & after)
{

    if (PCM::getInstance()->nearMemoryMetricsAvailable())
    {
        auto hit = (after.UncNMHit - before.UncNMHit);
        auto miss = (after.UncNMMiss - before.UncNMMiss);
        if((hit+miss) != 0 )
        return (hit*100.0/(hit+miss));}

    return 0ULL;
}

/*! \brief Computes number of bytes read from PMM memory

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/

template <class CounterStateType>
uint64 getBytesReadFromPMM(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->PMMTrafficMetricsAvailable())
        return (after.UncPMMReads - before.UncPMMReads) * 64;
    return 0ULL;
}

/*! \brief Computes number of bytes written to PMM memory

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
template <class CounterStateType>
uint64 getBytesWrittenToPMM(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->PMMTrafficMetricsAvailable())
        return (after.UncPMMWrites - before.UncPMMWrites) * 64;
    return 0ULL;
}

/*! \brief Computes number of bytes read from HBM memory controllers

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
template <class CounterStateType>
uint64 getBytesReadFromEDC(const CounterStateType & before, const CounterStateType & after)
{
    auto m = PCM::getInstance();
    assert(m);
    if (m->HBMmemoryTrafficMetricsAvailable())
        return (after.UncEDCNormalReads - before.UncEDCNormalReads) * m->getHBMCASTransferSize();
    return 0ULL;
}

/*! \brief Computes number of bytes written to HBM memory controllers

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
template <class CounterStateType>
uint64 getBytesWrittenToEDC(const CounterStateType & before, const CounterStateType & after)
{
    auto m = PCM::getInstance();
    assert(m);
    if (m->HBMmemoryTrafficMetricsAvailable())
        return (after.UncEDCFullWrites - before.UncEDCFullWrites) * m->getHBMCASTransferSize();
    return 0ULL;
}

/*! \brief Computes number of bytes of read/write requests from GT engine

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
template <class CounterStateType>
uint64 getGTRequestBytesFromMC(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->memoryIOTrafficMetricAvailable())
        return (after.UncMCGTRequests - before.UncMCGTRequests) * 64;
    return 0ULL;
}

/*! \brief Computes number of bytes of read/write requests from all IA

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
template <class CounterStateType>
uint64 getIARequestBytesFromMC(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->memoryIOTrafficMetricAvailable())
        return (after.UncMCIARequests - before.UncMCIARequests) * 64;
    return 0ULL;
}

/*! \brief Computes number of bytes of read/write requests from all IO sources

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
template <class CounterStateType>
uint64 getIORequestBytesFromMC(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->memoryIOTrafficMetricAvailable())
        return (after.UncMCIORequests - before.UncMCIORequests) * 64;
    return 0ULL;
}

/*! \brief Returns the number of occurred system management interrupts

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of SMIs (system manegement interrupts)
*/
template <class CounterStateType>
uint64 getSMICount(const CounterStateType & before, const CounterStateType & after)
{
    return after.SMICount - before.SMICount;
}

/*! \brief Returns the number of occurred custom core events

    Read number of events programmed with the \c CUSTOM_CORE_EVENTS

    \param eventCounterNr Event/counter number (value from 0 to 3)
    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
template <class CounterStateType>
uint64 getNumberOfCustomEvents(int32 eventCounterNr, const CounterStateType & before, const CounterStateType & after)
{
    return after.Event[eventCounterNr] - before.Event[eventCounterNr];
}


/*! \brief Computes number of bytes Writen from CXL Cache

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
//template <class CounterStateType>
inline uint64 getCXLWriteCacheBytes(uint32 socket,const SystemCounterState & before,const SystemCounterState & after)
{
        return (after.CXLWriteCache[socket] - before.CXLWriteCache[socket]) * 64;
}

/*! \brief Computes number of bytes Writen from CXL Memory

    \param before CPU counter state before the experiment
    \param after CPU counter state after the experiment
    \return Number of bytes
*/
//template <class CounterStateType>
inline uint64 getCXLWriteMemBytes(uint32 socket, const SystemCounterState & before,const SystemCounterState & after)
{

        return (after.CXLWriteMem[socket] - before.CXLWriteMem[socket]) * 64;
}

/*! \brief Get estimation of QPI data traffic per incoming QPI link

    Returns an estimation of number of data bytes transferred to a socket over Intel(r) Quick Path Interconnect

    \param socketNr socket identifier
    \param linkNr linkNr
    \param before System CPU counter state before the experiment
    \param after System CPU counter state after the experiment
    \return Number of bytes
*/
inline uint64 getIncomingQPILinkBytes(uint32 socketNr, uint32 linkNr, const SystemCounterState & before, const SystemCounterState & after)
{
    if (!PCM::getInstance()->incomingQPITrafficMetricsAvailable()) return 0ULL;
    uint64 b = before.incomingQPIPackets[socketNr][linkNr];
    uint64 a = after.incomingQPIPackets[socketNr][linkNr];
    // prevent overflows due to counter dissynchronisation
    return (a > b) ? (64 * (a - b)) : 0;
}

/*! \brief Get data utilization of incoming QPI link (0..1)

    Returns an estimation of utilization of QPI link by data traffic transferred to a socket over Intel(r) Quick Path Interconnect

    \param socketNr socket identifier
    \param linkNr linkNr
    \param before System CPU counter state before the experiment
    \param after System CPU counter state after the experiment
    \return utilization (0..1)
*/
inline double getIncomingQPILinkUtilization(uint32 socketNr, uint32 linkNr, const SystemCounterState & before, const SystemCounterState & after)
{
    PCM * m = PCM::getInstance();
    if (!(m->qpiUtilizationMetricsAvailable())) return 0.;

    const double bytes = (double)getIncomingQPILinkBytes(socketNr, linkNr, before, after);
    const uint64 max_speed = m->getQPILinkSpeed(socketNr, linkNr);
    const double max_bytes = (double)(double(max_speed) * double(getInvariantTSC(before, after) / double(m->getNumOnlineCores())) / double(m->getNominalFrequency()));
    return bytes / max_bytes;
}

/*! \brief Get utilization of outgoing QPI link (0..1)

    Returns an estimation of utilization of QPI link by (data+nondata) traffic transferred from a socket over Intel(r) Quick Path Interconnect

    \param socketNr socket identifier
    \param linkNr linkNr
    \param before System CPU counter state before the experiment
    \param after System CPU counter state after the experiment
    \return utilization (0..1)
*/
inline double getOutgoingQPILinkUtilization(uint32 socketNr, uint32 linkNr, const SystemCounterState & before, const SystemCounterState & after)
{
    PCM * m = PCM::getInstance();

    if (m->outgoingQPITrafficMetricsAvailable() == false) return 0.;

    if (m->hasBecktonUncore())
    {
        const uint64 b = before.outgoingQPIFlits[socketNr][linkNr]; // idle flits
        const uint64 a = after.outgoingQPIFlits[socketNr][linkNr];  // idle flits
        // prevent overflows due to counter dissynchronisation
        const double idle_flits = (double)((a > b) ? (a - b) : 0);
        const uint64 bTSC = before.uncoreTSC;
        const uint64 aTSC = after.uncoreTSC;
        const double tsc = (double)((aTSC > bTSC) ? (aTSC - bTSC) : 0);
        if (idle_flits >= tsc) return 0.; // prevent overflows due to potential counter dissynchronization

        return (1. - (idle_flits / tsc));
    } else if (m->hasPCICFGUncore())
    {
        const uint64 b = before.outgoingQPIFlits[socketNr][linkNr]; // data + non-data flits or idle (null) flits
        const uint64 a = after.outgoingQPIFlits[socketNr][linkNr]; // data + non-data flits or idle (null) flits
        // prevent overflows due to counter dissynchronisation
        double flits = (double)((a > b) ? (a - b) : 0);
        const double max_flits = ((double(getInvariantTSC(before, after)) * double(m->getQPILinkSpeed(socketNr, linkNr)) / m->getBytesPerFlit()) / double(m->getNominalFrequency())) / double(m->getNumOnlineCores());
        if(m->hasUPI())
        {
            flits = flits/3.;
        }
        if (flits > max_flits) return 1.; // prevent overflows due to potential counter dissynchronization
        return (flits / max_flits);
    }

    return 0;
}

/*! \brief Get estimation of QPI (data+nondata) traffic per outgoing QPI link

    Returns an estimation of number of data bytes transferred from a socket over Intel(r) Quick Path Interconnect

    \param socketNr socket identifier
    \param linkNr linkNr
    \param before System CPU counter state before the experiment
    \param after System CPU counter state after the experiment
    \return Number of bytes
*/
inline uint64 getOutgoingQPILinkBytes(uint32 socketNr, uint32 linkNr, const SystemCounterState & before, const SystemCounterState & after)
{
    PCM * m = PCM::getInstance();
    if (!(m->outgoingQPITrafficMetricsAvailable())) return 0ULL;

    const double util = getOutgoingQPILinkUtilization(socketNr, linkNr, before, after);
    const double max_bytes = (double(m->getQPILinkSpeed(socketNr, linkNr)) * double(getInvariantTSC(before, after) / double(m->getNumOnlineCores())) / double(m->getNominalFrequency()));

    return (uint64)(max_bytes * util);
}


/*! \brief Get estimation of total QPI data traffic

    Returns an estimation of number of data bytes transferred to all sockets over all Intel(r) Quick Path Interconnect links

    \param before System CPU counter state before the experiment
    \param after System CPU counter state after the experiment
    \return Number of bytes
*/
inline uint64 getAllIncomingQPILinkBytes(const SystemCounterState & before, const SystemCounterState & after)
{
    PCM * m = PCM::getInstance();
    const uint32 ns = m->getNumSockets();
    const uint32 qpiLinks = (uint32)m->getQPILinksPerSocket();
    uint64 sum = 0;

    for (uint32 s = 0; s < ns; ++s)
        for (uint32 q = 0; q < qpiLinks; ++q)
            sum += getIncomingQPILinkBytes(s, q, before, after);

    return sum;
}

/*! \brief Get estimation of total QPI data+nondata traffic

    Returns an estimation of number of data and non-data bytes transferred from all sockets over all Intel(r) Quick Path Interconnect links

    \param before System CPU counter state before the experiment
    \param after System CPU counter state after the experiment
    \return Number of bytes
*/
inline uint64 getAllOutgoingQPILinkBytes(const SystemCounterState & before, const SystemCounterState & after)
{
    PCM * m = PCM::getInstance();
    const uint32 ns = m->getNumSockets();
    const uint32 qpiLinks = (uint32)m->getQPILinksPerSocket();
    uint64 sum = 0;

    for (uint32 s = 0; s < ns; ++s)
        for (uint32 q = 0; q < qpiLinks; ++q)
            sum += getOutgoingQPILinkBytes(s, q, before, after);

    return sum;
}


/*! \brief Return current value of the counter of QPI data traffic per incoming QPI link

    Returns the number of incoming data bytes to a socket over Intel(r) Quick Path Interconnect

    \param socketNr socket identifier
    \param linkNr linkNr
    \param now Current System CPU counter state
    \return Number of bytes
*/
inline uint64 getIncomingQPILinkBytes(uint32 socketNr, uint32 linkNr, const SystemCounterState & now)
{
    if (PCM::getInstance()->incomingQPITrafficMetricsAvailable())
        return 64 * now.incomingQPIPackets[socketNr][linkNr];
    return 0ULL;
}

/*! \brief Get estimation of total QPI data traffic for this socket

    Returns an estimation of number of bytes transferred to this sockets over all Intel(r) Quick Path Interconnect links on this socket

    \param before System CPU counter state before the experiment
    \param after System CPU counter state after the experiment
    \return Number of bytes
*/
inline uint64 getSocketIncomingQPILinkBytes(uint32 socketNr, const SystemCounterState & now)
{
    PCM * m = PCM::getInstance();
    const uint32 qpiLinks = (uint32)m->getQPILinksPerSocket();
    uint64 sum = 0;

    for (uint32 q = 0; q < qpiLinks; ++q)
        sum += getIncomingQPILinkBytes(socketNr, q, now);

    return sum;
}

/*! \brief Get estimation of Socket QPI data traffic

    Returns an estimation of number of data bytes transferred to all sockets over all Intel(r) Quick Path Interconnect links

    \param now System CPU counter state
    \return Number of bytes
*/
inline uint64 getAllIncomingQPILinkBytes(const SystemCounterState & now)
{
    PCM * m = PCM::getInstance();
    const uint32 ns = m->getNumSockets();
    uint64 sum = 0;

    for (uint32 s = 0; s < ns; ++s)
        sum += getSocketIncomingQPILinkBytes(s, now);
    return sum;
}


/*! \brief Get QPI data to Memory Controller traffic ratio

    Ideally for NUMA-optmized programs the ratio should be close to 0.

    \param before System CPU counter state before the experiment
    \param after System CPU counter state after the experiment
    \return Ratio
*/

inline double getQPItoMCTrafficRatio(const SystemCounterState & before, const SystemCounterState & after)
{
    const uint64 totalQPI = getAllIncomingQPILinkBytes(before, after);
    uint64 memTraffic = getBytesReadFromMC(before, after) + getBytesWrittenToMC(before, after);
    if (PCM::getInstance()->PMMTrafficMetricsAvailable())
    {
        memTraffic += getBytesReadFromPMM(before, after) + getBytesWrittenToPMM(before, after);
    }
    if (memTraffic == 0) return -1.;
    return double(totalQPI) / double(memTraffic);
}

/*! \brief Get local memory access ration measured in home agent

    \param before System CPU counter state before the experiment
    \param after System CPU counter state after the experiment
    \return Ratio
*/
template <class CounterStateType>
inline double getLocalMemoryRequestRatio(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->localMemoryRequestRatioMetricAvailable() == false) return -1.;
    const auto all = after.UncHARequests - before.UncHARequests;
    const auto local = after.UncHALocalRequests - before.UncHALocalRequests;
    DBG(4, 64*all/1e6 , " " , 64*local/1e6);
    return double(local)/double(all);
}

//! \brief Returns the raw count of events
//! \param before counter state before the experiment
//! \param after counter state after the experiment
template <class CounterType>
inline uint64 getNumberOfEvents(const CounterType & before, const CounterType & after)
{
    // prevent overflows due to counter dissynchronisation
    if (after.data < before.data)
    {
        return 0;
    }

    return after.data - before.data;
}
//! \brief Returns average last level cache read+prefetch miss latency in ns

template <class CounterStateType>
inline double getLLCReadMissLatency(const CounterStateType & before, const CounterStateType & after)
{
    auto * m = PCM::getInstance();
    if (m->LLCReadMissLatencyMetricsAvailable() == false) return -1.;
    const double occupancy = double(after.TOROccupancyIAMiss) - double(before.TOROccupancyIAMiss);
    const double inserts = double(after.TORInsertsIAMiss) - double(before.TORInsertsIAMiss);
    const double unc_clocks = double(after.UncClocks) - double(before.UncClocks);
    const double seconds = double(getInvariantTSC(before, after)) / double(m->getNumOnlineCores()/m->getNumSockets()) / double(m->getNominalFrequency());
    return 1e9*seconds*(occupancy/inserts)/unc_clocks;
}

template <class CounterStateType>
inline uint64 getAllSlots(const CounterStateType & before, const CounterStateType & after)
{
    const int64 a = after.BackendBoundSlots - before.BackendBoundSlots;
    const int64 b = after.FrontendBoundSlots - before.FrontendBoundSlots;
    const int64 c = after.BadSpeculationSlots - before.BadSpeculationSlots;
    const int64 d = after.RetiringSlots - before.RetiringSlots;
    DBG(4, "before: " , before.FrontendBoundSlots , " " , before.BadSpeculationSlots , " ", before.BackendBoundSlots , " " , before.RetiringSlots);
    DBG(4, "afterG: " ,  after.FrontendBoundSlots , " " , after.BadSpeculationSlots , " " , after.BackendBoundSlots , " " , after.RetiringSlots);
    assert(a >= 0);
    assert(b >= 0);
    assert(c >= 0);
    assert(d >= 0);
    return a + b + c + d;
}

template <class CounterStateType>
inline uint64 getAllSlotsRaw(const CounterStateType& before, const CounterStateType& after)
{
    return after.AllSlotsRaw - before.AllSlotsRaw;
}

//! \brief Returns unutilized pipeline slots where no uop was delivered due to lack of back-end resources as range 0..1
template <class CounterStateType>
inline double getBackendBound(const CounterStateType & before, const CounterStateType & after)
{
    DBG(4, (after.BackendBoundSlots - before.BackendBoundSlots) , " " , getAllSlots(before, after));
    if (PCM::getInstance()->isHWTMAL1Supported())
        return double(after.BackendBoundSlots - before.BackendBoundSlots)/double(getAllSlots(before, after));
    return 0.;
}

//! \brief Returns unutilized pipeline slots where no uop was delivered due to stalls on buffer, cache or memory resources as range 0..1
template <class CounterStateType>
inline double getMemoryBound(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->isHWTMAL2Supported())
        return double(after.MemBoundSlots - before.MemBoundSlots)/double(getAllSlots(before, after));
    return 0.;
}

//! \brief Returns unutilized pipeline slots where no uop was delivered due to lack of core resources as range 0..1
template <class CounterStateType>
inline double getCoreBound(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->isHWTMAL2Supported())
        return getBackendBound(before, after) - getMemoryBound(before, after);
    return 0.;
}

//! \brief Returns unutilized pipeline slots where Front-end did not deliver a uop while back-end is ready as range 0..1
template <class CounterStateType>
inline double getFrontendBound(const CounterStateType & before, const CounterStateType & after)
{
    DBG(4, (after.FrontendBoundSlots - before.FrontendBoundSlots) , " " , getAllSlots(before, after));
    if (PCM::getInstance()->isHWTMAL1Supported())
        return double(after.FrontendBoundSlots - before.FrontendBoundSlots)/double(getAllSlots(before, after));
    return 0.;
}

//! \brief Returns unutilized pipeline slots where Front-end due to fetch latency constraints did not deliver a uop while back-end is ready as range 0..1
template <class CounterStateType>
inline double getFetchLatencyBound(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->isHWTMAL2Supported())
        return double(after.FetchLatSlots - before.FetchLatSlots)/double(getAllSlots(before, after));
    return 0.;
}

//! \brief Returns unutilized pipeline slots where Front-end due to fetch bandwidth constraints did not deliver a uop while back-end is ready as range 0..1
template <class CounterStateType>
inline double getFetchBandwidthBound(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->isHWTMAL2Supported())
        return getFrontendBound(before, after) - getFetchLatencyBound(before, after);
    return 0.;
}

//! \brief Returns wasted pipeline slots due to incorrect speculation, covering whole penalty: Utilized by uops that do not retire, or Recovery Bubbles (unutilized slots) as range 0..1
template <class CounterStateType>
inline double getBadSpeculation(const CounterStateType & before, const CounterStateType & after)
{
    DBG(4, (after.BadSpeculationSlots - before.BadSpeculationSlots) , " " , getAllSlots(before, after));
    if (PCM::getInstance()->isHWTMAL1Supported())
        return double(after.BadSpeculationSlots - before.BadSpeculationSlots)/double(getAllSlots(before, after));
    return 0.;
}

//! \brief Returns wasted pipeline slots due to incorrect speculation (branch misprediction), covering whole penalty: Utilized by uops that do not retire, or Recovery Bubbles (unutilized slots) as range 0..1
template <class CounterStateType>
inline double getBranchMispredictionBound(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->isHWTMAL2Supported())
        return double(after.BrMispredSlots - before.BrMispredSlots)/double(getAllSlots(before, after));
    return 0.;
}

//! \brief Returns wasted pipeline slots due to incorrect speculation (machine clears), covering whole penalty: Utilized by uops that do not retire, or Recovery Bubbles (unutilized slots) as range 0..1
template <class CounterStateType>
inline double getMachineClearsBound(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->isHWTMAL2Supported())
        return getBadSpeculation(before, after) - getBranchMispredictionBound(before, after);
    return 0.;
}

//! \brief Returns pipeline slots utilized by uops that eventually retire (commit)
template <class CounterStateType>
inline double getRetiring(const CounterStateType & before, const CounterStateType & after)
{
    DBG(4, (after.RetiringSlots - before.RetiringSlots) , " " , getAllSlots(before, after));
    if (PCM::getInstance()->isHWTMAL1Supported())
        return double(after.RetiringSlots - before.RetiringSlots)/double(getAllSlots(before, after));
    return 0.;
}

//! \brief Returns pipeline slots utilized by uops that eventually retire (commit) - heavy operations
template <class CounterStateType>
inline double getHeavyOperationsBound(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->isHWTMAL2Supported())
        return double(after.HeavyOpsSlots - before.HeavyOpsSlots)/double(getAllSlots(before, after));
    return 0.;
}

//! \brief Returns pipeline slots utilized by uops that eventually retire (commit) - light operations
template <class CounterStateType>
inline double getLightOperationsBound(const CounterStateType & before, const CounterStateType & after)
{
    if (PCM::getInstance()->isHWTMAL2Supported())
        return getRetiring(before, after) - getHeavyOperationsBound(before, after);
    return 0.;
}

template <class ValuesType>
inline std::vector<uint64> getRegisterEvent(const PCM::RawEventEncoding& eventEnc, const ValuesType& beforeValues, const ValuesType& afterValues)
{
    std::vector<uint64> result{};
    auto beforeIter = beforeValues.find(eventEnc);
    auto afterIter = afterValues.find(eventEnc);
    if (beforeIter != beforeValues.end() &&
        afterIter != afterValues.end())
    {
        const auto& beforeValues = beforeIter->second;
        const auto& afterValues = afterIter->second;
        assert(beforeValues.size() == afterValues.size());
        const size_t sz = beforeValues.size();
        for (size_t i = 0; i < sz; ++i)
        {
            switch (eventEnc[PCM::PCICFGEventPosition::type])
            {
            case PCM::MSRType::Freerun:
                result.push_back(afterValues[i] - beforeValues[i]);
                break;
            case PCM::MSRType::Static:
                result.push_back(afterValues[i]);
                break;
            }
        }
    }
    return result;
}

inline std::vector<uint64> getTPMIEvent(const PCM::RawEventEncoding & eventEnc, const SystemCounterState& before, const SystemCounterState& after)
{
    return getRegisterEvent(eventEnc, before.TPMIValues, after.TPMIValues);
}

inline std::vector<uint64> getPCICFGEvent(const PCM::RawEventEncoding & eventEnc, const SystemCounterState& before, const SystemCounterState& after)
{
    return getRegisterEvent(eventEnc, before.PCICFGValues, after.PCICFGValues);
}

inline std::vector<uint64> getMMIOEvent(const PCM::RawEventEncoding& eventEnc, const SystemCounterState& before, const SystemCounterState& after)
{
    return getRegisterEvent(eventEnc, before.MMIOValues, after.MMIOValues);
}

inline std::vector<uint64> getPMTEvent(const PCM::RawEventEncoding& eventEnc, const SystemCounterState& before, const SystemCounterState& after)
{
    return getRegisterEvent(eventEnc, before.PMTValues, after.PMTValues);
}

template <class CounterStateType>
uint64 getMSREvent(const uint64& index, const PCM::MSRType& type, const CounterStateType& before, const CounterStateType& after)
{
    switch (type)
    {
    case PCM::MSRType::Freerun:
        {
            const auto beforeIt = before.MSRValues.find(index);
            const auto afterIt = after.MSRValues.find(index);
            if (beforeIt != before.MSRValues.end() && afterIt != after.MSRValues.end())
            {
                return afterIt->second - beforeIt->second;
            }
            break;
        }
    case PCM::MSRType::Static:
        {
            const auto result = after.MSRValues.find(index);
            if (result != after.MSRValues.end())
            {
                return result->second;
            }
            break;
        }
    }
    return 0ULL;
}

} // namespace pcm

#endif

```

`src/daemon/common.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2018,2022 Intel Corporation
// written by Steven Briscoe

#ifndef COMMON_H_
#define COMMON_H_

#include <cstring>
#include <stdint.h>

static const char DEFAULT_SHM_ID_LOCATION[] = "/tmp/opcm-daemon-shm-id";
static const char VERSION[] = "2.0.0";

#define MAX_CPU_CORES 4096
#define MAX_SOCKETS 256
#define MEMORY_MAX_IMC_CHANNELS (12)
#define MEMORY_READ 0
#define MEMORY_WRITE 1
#define QPI_MAX_LINKS (MAX_SOCKETS * 4)

#define VERSION_SIZE 12

#define ALIGNMENT 64
#define ALIGN(x) __attribute__((aligned((x))))

namespace PCMDaemon {
    typedef int int32;
    typedef long int64;
    typedef unsigned int uint32;
    typedef unsigned long uint64;

    struct PCMSystem {
        uint32 numOfCores;              // the number of logical cores in the system
        uint32 numOfOnlineCores;        // the number of online logical cores in the system
        uint32 numOfSockets;            // the number of CPU sockets in the system
        uint32 numOfOnlineSockets;      // the number of online CPU sockets in the system
        uint32 numOfQPILinksPerSocket;  // the number of QPI or UPI (xPI) links per socket
    public:
        PCMSystem() :
            numOfCores(0),
            numOfOnlineCores(0),
            numOfSockets(0),
            numOfOnlineSockets(0),
            numOfQPILinksPerSocket(0) {}
    } ALIGN(ALIGNMENT);

    typedef struct PCMSystem PCMSystem;

    struct PCMCoreCounter {
        uint64 coreId = 0;              // core ID
        int32 socketId = 0;             // socket ID
        double instructionsPerCycle = 0.; // instructions per cycle metric
        uint64 cycles = 0;                // cpu cycle metric
        uint64 instructionsRetired = 0;   // number of retired instructions metric
        double execUsage = 0.;            // instructions per nominal CPU cycle, i.e. in respect to the CPU frequency ignoring turbo and power saving
        double relativeFrequency = 0.;    // frequency relative to nominal CPU frequency (“clockticks”/”invariant timer ticks”)
        double activeRelativeFrequency = 0.; // frequency relative to nominal CPU frequency excluding the time when the CPU is sleeping
        uint64 l3CacheMisses = 0;            // L3 cache line misses
        uint64 l3CacheReference = 0;         // L3 cache line references (accesses)
        uint64 l2CacheMisses = 0;            // L2 cache line misses
        double l3CacheHitRatio = 0.;         // L3 cache hit ratio
        double l2CacheHitRatio = 0.;         // L2 cachhe hit ratio
        double l3CacheMPI = 0.;              // number of L3 cache misses per retired instruction
        double l2CacheMPI = 0.;              // number of L2 cache misses per retired instruction
        bool l3CacheOccupancyAvailable;      // true if L3 cache occupancy metric is available
        uint64 l3CacheOccupancy;             // L3 cache occupancy in  KBytes
        bool localMemoryBWAvailable;         // true if local memory bandwidth metric (L3 cache external bandwidth satisfied by local memory) is available
        uint64 localMemoryBW;                // L3 cache external bandwidth satisfied by local memory (in MBytes)
        bool remoteMemoryBWAvailable;        // true if remote memory bandwidth metric (L3 cache external bandwidth satisfied by remote memory) is available
        uint64 remoteMemoryBW;               // L3 cache external bandwidth satisfied by remote memory (in MBytes)
        uint64 localMemoryAccesses = 0;      // the number of local DRAM memory accesses
        uint64 remoteMemoryAccesses = 0;     // the number of remote DRAM memory accesses
        int32 thermalHeadroom = 0;           // thermal headroom in Kelvin (max design temperature – current temperature)

    public:
        PCMCoreCounter() :
            l3CacheOccupancyAvailable(false),
            l3CacheOccupancy(0),
            localMemoryBWAvailable(false),
            localMemoryBW(0),
            remoteMemoryBWAvailable(false),
            remoteMemoryBW(0) {}
    } ALIGN(ALIGNMENT);

    typedef struct PCMCoreCounter PCMCoreCounter;

    struct PCMCore {
        PCMCoreCounter cores[MAX_CPU_CORES];
        bool packageEnergyMetricsAvailable;  // true if CPU package (a.k.a. socket) energy metric is available
        double energyUsedBySockets[MAX_SOCKETS] ALIGN(ALIGNMENT); // energy consumed/used by CPU (socket) in Joules

    public:
        PCMCore() :
            packageEnergyMetricsAvailable(false) {
            for (int i = 0; i < MAX_SOCKETS; ++i)
            {
                energyUsedBySockets[i] = -1.0;
            }
        }
    } ALIGN(ALIGNMENT);

    typedef struct PCMCore PCMCore;

    struct PCMMemoryChannelCounter {
        float read;  // DRAM read traffic in MBytes/sec
        float write; // DRAM write traffic in MBytes/sec
        float total; // total traffic in MBytes/sec

    public:
        PCMMemoryChannelCounter() :
            read(-1.0),
            write(-1.0),
            total(-1.0) {}
    } ALIGN(ALIGNMENT);

    typedef struct PCMMemoryChannelCounter PCMMemoryChannelCounter;

    struct PCMMemorySocketCounter {
        uint64 socketId = 0; // socket ID
        PCMMemoryChannelCounter channels[MEMORY_MAX_IMC_CHANNELS];
        uint32 numOfChannels; // number of memory channels in the CPU socket
        float read;     // DRAM read traffic in MBytes/sec
        float write;    // DRAM write traffic in MBytes/sec
        float pmmRead;  // PMM read traffic in MBytes/sec
        float pmmWrite; // PMM write traffic in MBytes/sec
        float total;    // total traffic in MBytes/sec
        float memoryModeHitRate; // PMM memory mode hit rate estimation. Metric value range is [0..1]
        double dramEnergy; // energy consumed/used by DRAM memory in Joules

    public:
        PCMMemorySocketCounter() :
            numOfChannels(0),
            read(-1.0),
            write(-1.0),
            pmmRead(-1.0),
            pmmWrite(-1.0),
            total(-1.0),
            memoryModeHitRate(-1.0),
            dramEnergy(0.0) {}
    } ALIGN(ALIGNMENT);

    typedef struct PCMMemorySocketCounter PCMMemorySocketCounter;

    struct PCMMemorySystemCounter {
        float read;     // DRAM read traffic in MBytes/sec
        float write;    // DRAM write traffic in MBytes/sec
        float pmmRead;  // PMM read traffic in MBytes/sec
        float pmmWrite; // PMM write traffic in MBytes/sec
        float total;    // total traffic in MBytes/sec

    public:
        PCMMemorySystemCounter() :
            read(-1.0),
            write(-1.0),
            pmmRead(-1.0),
            pmmWrite(-1.0),
            total(-1.0) {}
    } ALIGN(ALIGNMENT);

    typedef struct PCMMemorySystemCounter PCMMemorySystemCounter;

    struct PCMMemory {
        PCMMemorySocketCounter sockets[MAX_SOCKETS];
        PCMMemorySystemCounter system;
        bool dramEnergyMetricsAvailable; // true if DRAM energy metrics are available
        bool pmmMetricsAvailable; // true if PMM metrics are available

    public:
        PCMMemory() :
            dramEnergyMetricsAvailable(false),
            pmmMetricsAvailable(false)
        {}
    } ALIGN(ALIGNMENT);

    typedef struct PCMMemory PCMMemory;

    struct PCMQPILinkCounter {
        uint64 bytes;  // bytes of certain traffic class transferred over QPI or UPI link
        double utilization; // utilization of the link caused by the certain traffic class

    public:
        PCMQPILinkCounter() :
            bytes(0),
            utilization(-1.0) {}
    } ALIGN(ALIGNMENT);

    typedef struct PCMQPILinkCounter PCMQPILinkCounter;

    struct PCMQPISocketCounter {
        uint64 socketId = 0; // socket ID
        PCMQPILinkCounter links[QPI_MAX_LINKS];
        uint64 total; // total number of transferred bytes of a certain traffic class

    public:
        PCMQPISocketCounter() :
            total(0) {}
    } ALIGN(ALIGNMENT);

    typedef struct PCMQPISocketCounter PCMQPISocketCounter;

    struct PCMQPI {
        PCMQPISocketCounter incoming[MAX_SOCKETS]; // incoming data traffic class statistics
        uint64 incomingTotal;                      // incoming data traffic total bytes
        PCMQPISocketCounter outgoing[MAX_SOCKETS]; // outgoing data+"non-data" traffic class statistics
        uint64 outgoingTotal;                      // outgoing data+"non-data" traffic total bytes
        bool incomingQPITrafficMetricsAvailable; // true if incoming data traffic class statistics metrics are available
        bool outgoingQPITrafficMetricsAvailable; // true if outgoing data+"non-data" class statistics metrics are available

    public:
        PCMQPI() :
            incomingTotal(0),
            outgoingTotal(0),
            incomingQPITrafficMetricsAvailable(false),
            outgoingQPITrafficMetricsAvailable(false) {}
    } ALIGN(ALIGNMENT);

    typedef struct PCMQPI PCMQPI;

    struct SharedPCMCounters {
        PCMSystem system;
        PCMCore core;
        PCMMemory memory;
        PCMQPI qpi;
    } ALIGN(ALIGNMENT);

    typedef struct SharedPCMCounters SharedPCMCounters;

    struct SharedPCMState {
        char version[VERSION_SIZE]; // version (null-terminated string)
        uint64 lastUpdateTscBegin;  // time stamp counter (TSC) obtained via rdtsc instruction *before* the state update
        uint64 timestamp;           // monotonic time since some unspecified starting point in nanoseconds *after* the state update
        uint64 cyclesToGetPCMState; // time it took to update the state measured in TSC cycles
        uint32 pollMs;              // the poll interval in shared memory in milliseconds
        SharedPCMCounters pcm;
        uint64 lastUpdateTscEnd;    // time stamp counter (TSC) obtained via rdtsc instruction *after* the state update

    public:
        SharedPCMState() :
            lastUpdateTscBegin(0),
            timestamp(0),
            cyclesToGetPCMState(0),
            pollMs(-1),
            lastUpdateTscEnd(0)
        {
            std::fill(this->version, this->version + VERSION_SIZE, 0);
        }
    } ALIGN(ALIGNMENT);

    typedef struct SharedPCMState SharedPCMState;
}

#endif /* COMMON_H_ */

```

`src/daemon/daemon.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2018,2022 Intel Corporation
// written by Steven Briscoe

#include <cstdlib>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <errno.h>
#include <time.h>
#include <assert.h>

#ifndef CLOCK_MONOTONIC_RAW
#define CLOCK_MONOTONIC_RAW             (4) /* needed for SLES11 */
#endif

#include "daemon.h"
#include "common.h"
#include "pcm.h"

namespace PCMDaemon {

    std::string Daemon::shmIdLocation_;
    int Daemon::sharedMemoryId_;
    SharedPCMState* Daemon::sharedPCMState_;

    Daemon::Daemon(int argc, char* argv[])
        : debugMode_(false), pollIntervalMs_(0), groupName_(""), mode_(Mode::DIFFERENCE), pcmInstance_(NULL)
    {
        allowedSubscribers_.push_back("core");
        allowedSubscribers_.push_back("memory");
        allowedSubscribers_.push_back("qpi");

        shmIdLocation_ = std::string(DEFAULT_SHM_ID_LOCATION);
        sharedMemoryId_ = 0;
        sharedPCMState_ = NULL;

        readApplicationArguments(argc, argv);
        setupSharedMemory();
        setupPCM();

        assert(sharedPCMState_);

        //Put the poll interval in shared memory so that the client knows
        sharedPCMState_->pollMs = pollIntervalMs_;

        collectionTimeAfter_ = 0;

        updatePCMState(&systemStatesBefore_, &socketStatesBefore_, &coreStatesBefore_, collectionTimeBefore_);
        systemStatesForQPIBefore_ = SystemCounterState(systemStatesBefore_);

        serverUncoreCounterStatesBefore_ = new ServerUncoreCounterState[pcmInstance_->getNumSockets()];
        serverUncoreCounterStatesAfter_ = new ServerUncoreCounterState[pcmInstance_->getNumSockets()];
    }

    int Daemon::run()
    {
        std::cout << "\n**** PCM Daemon Started *****\n";

        while (true)
        {
            if (debugMode_)
            {
                time_t rawtime;
                struct tm timeinfo;
                char timeBuffer[200];
                time(&rawtime);
                localtime_r(&rawtime, &timeinfo);

                snprintf(timeBuffer, 200, "[%02d %02d %04d %02d:%02d:%02d]", timeinfo.tm_mday, timeinfo.tm_mon + 1, timeinfo.tm_year + 1900, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);

                std::cout << timeBuffer << "\tFetching counters...\n";
            }

            // Here to make sure that any output elsewhere in this class or its callees is flushed before the sleep
            std::cout << std::flush;

            usleep(pollIntervalMs_ * 1000);

            getPCMCounters();
        }

        return EXIT_SUCCESS;
    }

    Daemon::~Daemon()
    {
        deleteAndNullifyArray(serverUncoreCounterStatesBefore_);
        deleteAndNullifyArray(serverUncoreCounterStatesAfter_);
    }

    void Daemon::setupPCM()
    {
        pcmInstance_ = PCM::getInstance();
        pcmInstance_->setBlocked(false);
        set_signal_handlers();
        set_post_cleanup_callback(&Daemon::cleanup);

        checkAccessAndProgramPCM();
    }

    void Daemon::checkAccessAndProgramPCM()
    {
        PCM::ErrorCode status;

        if (subscribers_.find("core") != subscribers_.end())
        {
            EventSelectRegister defEventSelectRegister;
            defEventSelectRegister.value = 0;
            defEventSelectRegister.fields.usr = 1;
            defEventSelectRegister.fields.os = 1;
            defEventSelectRegister.fields.enable = 1;

            uint32 numOfCustomCounters = 4;

            EventSelectRegister regs[numOfCustomCounters];
            PCM::ExtendedCustomCoreEventDescription conf;
            conf.nGPCounters = numOfCustomCounters;
            conf.gpCounterCfg = regs;

            try {
                pcmInstance_->setupCustomCoreEventsForNuma(conf);
            }
            catch (UnsupportedProcessorException& e) {
                std::cerr << "\nPCM daemon does not support your processor currently.\n\n";
                exit(EXIT_FAILURE);
            }

            // Set default values for event select registers
            for (uint32 i(0); i < numOfCustomCounters; ++i)
                regs[i] = defEventSelectRegister;

            regs[0].fields.event_select = 0xB7; // OFFCORE_RESPONSE 0 event
            regs[0].fields.umask = 0x01;
            regs[1].fields.event_select = 0xBB; // OFFCORE_RESPONSE 1 event
            regs[1].fields.umask = 0x01;
            regs[2].fields.event_select = ARCH_LLC_MISS_EVTNR;
            regs[2].fields.umask = ARCH_LLC_MISS_UMASK;
            regs[3].fields.event_select = ARCH_LLC_REFERENCE_EVTNR;
            regs[3].fields.umask = ARCH_LLC_REFERENCE_UMASK;

            if (pcmInstance_->getMaxCustomCoreEvents() == 3)
            {
                conf.nGPCounters = 2; // drop LLC metrics
            }

            status = pcmInstance_->program(PCM::EXT_CUSTOM_CORE_EVENTS, &conf);
        }
        else
        {
            status = pcmInstance_->program();
        }

        pcmInstance_->checkError(status);
    }

    void Daemon::readApplicationArguments(int argc, char* argv[])
    {
        int opt;
        int counterCount(0);

        if (argc == 1)
        {
            printExampleUsageAndExit(argv);
        }

        std::cout << "\n";

        while ((opt = getopt(argc, argv, "p:c:dg:m:s:")) != -1)
        {
            switch (opt) {
            case 'p':
                pollIntervalMs_ = atoi(optarg);

                std::cout << "Polling every " << pollIntervalMs_ << "ms\n";
                break;
            case 'c':
            {
                std::string subscriber(optarg);

                if (subscriber == "all")
                {
                    for (std::vector<std::string>::const_iterator it = allowedSubscribers_.begin(); it != allowedSubscribers_.end(); ++it)
                    {
                        subscribers_.insert(std::pair<std::string, uint32>(*it, 1));
                        ++counterCount;
                    }
                }
                else
                {
                    if (std::find(allowedSubscribers_.begin(), allowedSubscribers_.end(), subscriber) == allowedSubscribers_.end())
                    {
                        printExampleUsageAndExit(argv);
                    }

                    subscribers_.insert(std::pair<std::string, uint32>(subscriber, 1));
                    ++counterCount;
                }

                std::cout << "Listening to '" << subscriber << "' counters\n";
            }
            break;
            case 'd':
                debugMode_ = true;

                std::cout << "Debug mode enabled\n";
                break;
            case 'g':
            {
                groupName_ = std::string(optarg);

                std::cout << "Restricting to group: " << groupName_ << "\n";
            }
            break;
            case 'm':
            {
                std::string mode = std::string(optarg);
                std::transform(mode.begin(), mode.end(), mode.begin(), ::tolower);

                if (mode == "difference")
                {
                    mode_ = Mode::DIFFERENCE;
                }
                else if (mode == "absolute")
                {
                    mode_ = Mode::ABSOLUTE;
                }
                else
                {
                    printExampleUsageAndExit(argv);
                }

                std::cout << "Operational mode: " << mode_ << " (";

                if (mode_ == Mode::DIFFERENCE)
                    std::cout << "difference";
                else if (mode_ == Mode::ABSOLUTE)
                    std::cout << "absolute";

                std::cout << ")\n";
            }
            break;
            case 's':
            {
                shmIdLocation_ = std::string(optarg);

                std::cout << "Shared memory ID location: " << shmIdLocation_ << "\n";
            }
            break;
            default:
                printExampleUsageAndExit(argv);
                break;
            }
        }

        if (pollIntervalMs_ <= 0 || counterCount == 0)
        {
            printExampleUsageAndExit(argv);
        }

        std::cout << "PCM Daemon version: " << VERSION << "\n\n";
    }

    void Daemon::printExampleUsageAndExit(char* argv[])
    {
        std::cerr << "\n";
        std::cerr << "-------------------------------------------------------------------\n";
        std::cerr << "Example usage: " << argv[0] << " -p 50 -c numa -c memory\n";
        std::cerr << "Poll every 50ms. Fetch counters for numa and memory\n\n";

        std::cerr << "Example usage: " << argv[0] << " -p 250 -c all -g pcm -m absolute\n";
        std::cerr << "Poll every 250ms. Fetch all counters (core, numa & memory).\n";
        std::cerr << "Restrict access to user group 'pcm'. Store absolute values on each poll interval\n\n";

        std::cerr << "-p <milliseconds> for poll frequency\n";
        std::cerr << "-c <counter> to request specific counters (Allowed counters: all ";

        for (std::vector<std::string>::const_iterator it = allowedSubscribers_.begin(); it != allowedSubscribers_.end(); ++it)
        {
            std::cerr << *it;

            if (it + 1 != allowedSubscribers_.end())
            {
                std::cerr << " ";
            }
        }

        std::cerr << ")";

        std::cerr << "\n-d flag for debug output [optional]\n";
        std::cerr << "-g <group> to restrict access to group [optional]\n";
        std::cerr << "-m <mode> stores differences or absolute values (Allowed: difference absolute) Default: difference [optional]\n";
        std::cerr << "-s <filepath> to store shared memory ID Default: " << std::string(DEFAULT_SHM_ID_LOCATION) << " [optional]\n";

        std::cerr << "\n";

        exit(EXIT_FAILURE);
    }

    void Daemon::setupSharedMemory()
    {
        int mode = 0660;
        int shmFlag = IPC_CREAT | mode;

        sharedMemoryId_ = shmget(IPC_PRIVATE, sizeof(SharedPCMState), shmFlag);
        if (sharedMemoryId_ < 0)
        {
            std::cerr << "Failed to allocate shared memory segment (errno=" << errno << ")\n";
            exit(EXIT_FAILURE);
        }

        // Store shm id in a file (shmIdLocation_)
        // SDL330: Atomic file creation with symlink protection
        // Try O_EXCL first, unlink and retry only if needed (avoids TOCTOU race)
        int fd = -1;
        constexpr int MAX_FILE_CREATION_RETRIES = 3;
        for (int attempt = 0; attempt < MAX_FILE_CREATION_RETRIES && fd < 0; ++attempt) {
            fd = open(shmIdLocation_.c_str(), O_CREAT | O_EXCL | O_WRONLY | O_NOFOLLOW, 0660);
            if (fd >= 0) break;

            if (errno == ELOOP) {
                std::cerr << "SDL330 CRITICAL: Symlink detected at " << shmIdLocation_ << "\n";
                exit(EXIT_FAILURE);
            }
            if (errno == EEXIST) {
                // File exists from previous run - unlink and retry
                if (unlink(shmIdLocation_.c_str()) != 0 && errno != ENOENT) {
                    std::cerr << "Failed to delete stale shared memory id file: " << shmIdLocation_ << "\n";
                    exit(EXIT_FAILURE);
                }
                continue;  // retry
            }
            // Other error
            std::cerr << "Failed to create shared memory key location: " << shmIdLocation_ << " (errno=" << errno << ")\n";
            exit(EXIT_FAILURE);
        }
        if (fd < 0) {
            std::cerr << "SDL330 CRITICAL: Unable to create shared memory file after retries (possible attack): " << shmIdLocation_ << "\n";
            exit(EXIT_FAILURE);
        }

        FILE* fp = fdopen(fd, "w");
        if (!fp)
        {
            close(fd);
            std::cerr << "Failed to open stream for shared memory key location: " << shmIdLocation_ << "\n";
            exit(EXIT_FAILURE);
        }
        fprintf(fp, "%i", sharedMemoryId_);
        fclose(fp);

        if (groupName_.size() > 0)
        {
            ushort gid = (ushort)resolveGroupName(groupName_);

            struct shmid_ds shmData;
            shmData.shm_perm.gid = gid;
            shmData.shm_perm.mode = mode;

            int success = shmctl(sharedMemoryId_, IPC_SET, &shmData);
            if (success < 0)
            {
                std::cerr << "Failed to IPC_SET (errno=" << errno << ")\n";
                exit(EXIT_FAILURE);
            }

            //Change group of shared memory ID file
            uid_t uid = geteuid();
            success = chown(shmIdLocation_.c_str(), uid, gid);
            if (success < 0)
            {
                std::cerr << "Failed to change ownership of shared memory key location: " << shmIdLocation_ << "\n";
                exit(EXIT_FAILURE);
            }
        }

        sharedPCMState_ = (SharedPCMState*)shmat(sharedMemoryId_, NULL, 0);
        if (sharedPCMState_ == (void*)-1)
        {
            std::cerr << "Failed to attach shared memory segment (errno=" << errno << ")\n";
            exit(EXIT_FAILURE);
        }

        //Clear out shared memory
        sharedPCMState_ = new (sharedPCMState_) SharedPCMState(); // use placement new operator
    }

    gid_t Daemon::resolveGroupName(const std::string& groupName)
    {
        struct group* group = getgrnam(groupName.c_str());

        if (group == NULL)
        {
            std::cerr << "Failed to resolve group '" << groupName << "'\n";
            exit(EXIT_FAILURE);
        }

        return group->gr_gid;
    }

    void Daemon::getPCMCounters()
    {
        std::copy(VERSION, VERSION + sizeof(VERSION), sharedPCMState_->version);
        sharedPCMState_->version[sizeof(VERSION)] = '\0';

        sharedPCMState_->lastUpdateTscBegin = RDTSC();

        updatePCMState(&systemStatesAfter_, &socketStatesAfter_, &coreStatesAfter_, collectionTimeAfter_);

        getPCMSystem();

        if (subscribers_.find("core") != subscribers_.end())
        {
            getPCMCore();
        }
        if (subscribers_.find("memory") != subscribers_.end())
        {
            getPCMMemory();
        }
        bool fetchQPICounters = subscribers_.find("qpi") != subscribers_.end();
        if (fetchQPICounters)
        {
            getPCMQPI();
        }

        const auto lastUpdateTscEnd = RDTSC();
        sharedPCMState_->cyclesToGetPCMState = lastUpdateTscEnd - sharedPCMState_->lastUpdateTscBegin;
        sharedPCMState_->timestamp = getTimestamp();

        // As the client polls this timestamp (lastUpdateTsc)
        // All the data has to be in shm before
        sharedPCMState_->lastUpdateTscEnd = lastUpdateTscEnd;
        if (mode_ == Mode::DIFFERENCE)
        {
            swapPCMBeforeAfterState();
        }
        if (fetchQPICounters)
        {
            systemStatesForQPIBefore_ = SystemCounterState(systemStatesAfter_);
        }

        std::swap(collectionTimeBefore_, collectionTimeAfter_);
    }

    void Daemon::updatePCMState(SystemCounterState* systemStates, std::vector<SocketCounterState>* socketStates, std::vector<CoreCounterState>* coreStates, uint64& t)
    {
        if (subscribers_.find("core") != subscribers_.end())
        {
            pcmInstance_->getAllCounterStates(*systemStates, *socketStates, *coreStates);
        }
        else
        {
            if (subscribers_.find("memory") != subscribers_.end() || subscribers_.find("qpi") != subscribers_.end())
            {
                pcmInstance_->getUncoreCounterStates(*systemStates, *socketStates);
            }
        }
        t = pcmInstance_->getTickCount();
    }

    void Daemon::swapPCMBeforeAfterState()
    {
        //After state now becomes before state (for the next iteration)
        std::swap(coreStatesBefore_, coreStatesAfter_);
        std::swap(socketStatesBefore_, socketStatesAfter_);
        std::swap(systemStatesBefore_, systemStatesAfter_);
        std::swap(serverUncoreCounterStatesBefore_, serverUncoreCounterStatesAfter_);
    }

    void Daemon::getPCMSystem()
    {
        PCMSystem& system = sharedPCMState_->pcm.system;
        system.numOfCores = pcmInstance_->getNumCores();
        system.numOfOnlineCores = pcmInstance_->getNumOnlineCores();
        system.numOfSockets = pcmInstance_->getNumSockets();
        system.numOfOnlineSockets = pcmInstance_->getNumOnlineSockets();
        system.numOfQPILinksPerSocket = pcmInstance_->getQPILinksPerSocket();
    }

    void Daemon::getPCMCore()
    {
        PCMCore& core = sharedPCMState_->pcm.core;

        const uint32 numCores = sharedPCMState_->pcm.system.numOfCores;

        uint32 onlineCoresI(0);
        for (uint32 coreI(0); coreI < numCores; ++coreI)
        {
            if (!pcmInstance_->isCoreOnline(coreI))
                continue;

            PCMCoreCounter& coreCounters = core.cores[onlineCoresI];

            int32 socketId = pcmInstance_->getSocketId(coreI);
            double instructionsPerCycle = getIPC(coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
            uint64 cycles = getCycles(coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
            uint64 instructionsRetired = getInstructionsRetired(coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
            double execUsage = getExecUsage(coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
            double relativeFrequency = getRelativeFrequency(coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
            double activeRelativeFrequency = getActiveRelativeFrequency(coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
            uint64 l3CacheMisses = getNumberOfCustomEvents(2, coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
            uint64 l3CacheReference = getNumberOfCustomEvents(3, coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
            uint64 l2CacheMisses = getL2CacheMisses(coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
            double l3CacheHitRatio = getL3CacheHitRatio(coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
            double l2CacheHitRatio = getL2CacheHitRatio(coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
            double l3CacheMPI = double(l3CacheMisses) / instructionsRetired;
            double l2CacheMPI = double(l2CacheMisses) / instructionsRetired;
            int32 thermalHeadroom = coreStatesAfter_[coreI].getThermalHeadroom();

            coreCounters.coreId = coreI;
            coreCounters.socketId = socketId;
            coreCounters.instructionsPerCycle = instructionsPerCycle;
            coreCounters.cycles = cycles;
            coreCounters.instructionsRetired = instructionsRetired;
            coreCounters.execUsage = execUsage;
            coreCounters.relativeFrequency = relativeFrequency;
            coreCounters.activeRelativeFrequency = activeRelativeFrequency;
            coreCounters.l3CacheMisses = l3CacheMisses;
            coreCounters.l3CacheReference = l3CacheReference;
            coreCounters.l2CacheMisses = l2CacheMisses;
            coreCounters.l3CacheHitRatio = l3CacheHitRatio;
            coreCounters.l2CacheHitRatio = l2CacheHitRatio;
            coreCounters.l3CacheMPI = l3CacheMPI;
            coreCounters.l2CacheMPI = l2CacheMPI;
            coreCounters.thermalHeadroom = thermalHeadroom;

            coreCounters.l3CacheOccupancyAvailable = pcmInstance_->L3CacheOccupancyMetricAvailable();
            if (coreCounters.l3CacheOccupancyAvailable)
            {
                uint64 l3CacheOccupancy = getL3CacheOccupancy(coreStatesAfter_[coreI]);
                coreCounters.l3CacheOccupancy = l3CacheOccupancy;
            }

            coreCounters.localMemoryBWAvailable = pcmInstance_->CoreLocalMemoryBWMetricAvailable();
            if (coreCounters.localMemoryBWAvailable)
            {
                uint64 localMemoryBW = getLocalMemoryBW(coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
                coreCounters.localMemoryBW = localMemoryBW;
            }

            coreCounters.remoteMemoryBWAvailable = pcmInstance_->CoreRemoteMemoryBWMetricAvailable();
            if (coreCounters.remoteMemoryBWAvailable)
            {
                uint64 remoteMemoryBW = getRemoteMemoryBW(coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
                coreCounters.remoteMemoryBW = remoteMemoryBW;
            }

            coreCounters.localMemoryAccesses = getNumberOfCustomEvents(0, coreStatesBefore_[coreI], coreStatesAfter_[coreI]);
            coreCounters.remoteMemoryAccesses = getNumberOfCustomEvents(1, coreStatesBefore_[coreI], coreStatesAfter_[coreI]);

            ++onlineCoresI;
        }

        const uint32 numSockets = sharedPCMState_->pcm.system.numOfSockets;

        core.packageEnergyMetricsAvailable = pcmInstance_->packageEnergyMetricsAvailable();
        if (core.packageEnergyMetricsAvailable)
        {
            for (uint32 i(0); i < numSockets; ++i)
            {
                core.energyUsedBySockets[i] = getConsumedJoules(socketStatesBefore_[i], socketStatesAfter_[i]);
            }
        }
    }

    void Daemon::getPCMMemory()
    {
        pcmInstance_->disableJKTWorkaround();

        PCMMemory& memory = sharedPCMState_->pcm.memory;
        memory.dramEnergyMetricsAvailable = pcmInstance_->dramEnergyMetricsAvailable();
        memory.pmmMetricsAvailable = pcmInstance_->PMMTrafficMetricsAvailable();

        const uint32 numSockets = sharedPCMState_->pcm.system.numOfSockets;

        for (uint32 i(0); i < numSockets; ++i)
        {
            serverUncoreCounterStatesAfter_[i] = pcmInstance_->getServerUncoreCounterState(i);
        }

        uint64 elapsedTime = collectionTimeAfter_ - collectionTimeBefore_;

        float iMC_Rd_socket_chan[MAX_SOCKETS][MEMORY_MAX_IMC_CHANNELS];
        float iMC_Wr_socket_chan[MAX_SOCKETS][MEMORY_MAX_IMC_CHANNELS];
        float iMC_Rd_socket[MAX_SOCKETS];
        float iMC_Wr_socket[MAX_SOCKETS];
        float iMC_PMM_Rd_socket[MAX_SOCKETS];
        float iMC_PMM_Wr_socket[MAX_SOCKETS];

        for (uint32 skt(0); skt < numSockets; ++skt)
        {
            iMC_Rd_socket[skt] = 0.0;
            iMC_Wr_socket[skt] = 0.0;
            iMC_PMM_Rd_socket[skt] = 0.0;
            iMC_PMM_Wr_socket[skt] = 0.0;

            auto toBW = [&elapsedTime](const uint64 bytes)
            {
                return (float)(bytes / 1000000.0 / (elapsedTime / 1000.0));
            };

            if (memory.pmmMetricsAvailable)
            {
                iMC_PMM_Rd_socket[skt] = toBW(getBytesReadFromPMM(socketStatesBefore_[skt], socketStatesAfter_[skt]));
                iMC_PMM_Wr_socket[skt] = toBW(getBytesWrittenToPMM(socketStatesBefore_[skt], socketStatesAfter_[skt]));
            }

            for (uint32 channel(0); channel < MEMORY_MAX_IMC_CHANNELS; ++channel)
            {
                //In case of JKT-EN, there are only three channels. Skip one and continue.
                const bool memoryReadNotAvailable = getMCCounter(channel, MEMORY_READ, serverUncoreCounterStatesBefore_[skt], serverUncoreCounterStatesAfter_[skt]) == 0;
                const bool memoryWriteNotAvailable = getMCCounter(channel, MEMORY_WRITE, serverUncoreCounterStatesBefore_[skt], serverUncoreCounterStatesAfter_[skt]) == 0;
                if (memoryReadNotAvailable && memoryWriteNotAvailable)
                {
                    iMC_Rd_socket_chan[skt][channel] = -1.0;
                    iMC_Wr_socket_chan[skt][channel] = -1.0;
                    continue;
                }

                iMC_Rd_socket_chan[skt][channel] = (float)(toBW(getMCCounter(channel, MEMORY_READ, serverUncoreCounterStatesBefore_[skt], serverUncoreCounterStatesAfter_[skt]) * 64));
                iMC_Wr_socket_chan[skt][channel] = (float)(toBW(getMCCounter(channel, MEMORY_WRITE, serverUncoreCounterStatesBefore_[skt], serverUncoreCounterStatesAfter_[skt]) * 64));

                iMC_Rd_socket[skt] += iMC_Rd_socket_chan[skt][channel];
                iMC_Wr_socket[skt] += iMC_Wr_socket_chan[skt][channel];
            }
        }

        float systemRead(0.0);
        float systemWrite(0.0);
        float systemPMMRead(0.0);
        float systemPMMWrite(0.0);

        uint32 onlineSocketsI(0);
        for (uint32 skt(0); skt < numSockets; ++skt)
        {
            if (!pcmInstance_->isSocketOnline(skt))
                continue;

            uint64 currentChannelI(0);
            for (uint64 channel(0); channel < MEMORY_MAX_IMC_CHANNELS; ++channel)
            {
                //If the channel read neg. value, the channel is not working; skip it.
                if (iMC_Rd_socket_chan[skt][channel] < 0.0 && iMC_Wr_socket_chan[skt][channel] < 0.0)
                    continue;

                const float socketChannelRead = iMC_Rd_socket_chan[skt][channel];
                const float socketChannelWrite = iMC_Wr_socket_chan[skt][channel];

                memory.sockets[onlineSocketsI].channels[currentChannelI].read = socketChannelRead;
                memory.sockets[onlineSocketsI].channels[currentChannelI].write = socketChannelWrite;
                memory.sockets[onlineSocketsI].channels[currentChannelI].total = socketChannelRead + socketChannelWrite;

                ++currentChannelI;
            }

            memory.sockets[onlineSocketsI].socketId = skt;
            memory.sockets[onlineSocketsI].numOfChannels = currentChannelI;
            memory.sockets[onlineSocketsI].read = iMC_Rd_socket[skt];
            memory.sockets[onlineSocketsI].write = iMC_Wr_socket[skt];
            memory.sockets[onlineSocketsI].pmmRead = iMC_PMM_Rd_socket[skt];
            memory.sockets[onlineSocketsI].pmmWrite = iMC_PMM_Wr_socket[skt];
            memory.sockets[onlineSocketsI].total = iMC_Rd_socket[skt] + iMC_Wr_socket[skt] + iMC_PMM_Rd_socket[skt] + iMC_PMM_Wr_socket[skt];
            const auto all = memory.sockets[onlineSocketsI].total;
            memory.sockets[onlineSocketsI].memoryModeHitRate = (all == 0.0) ? -1.0 : ((iMC_Rd_socket[skt] + iMC_Wr_socket[skt]) / all); // simplified approximation
            if (memory.dramEnergyMetricsAvailable)
            {
                memory.sockets[onlineSocketsI].dramEnergy = getDRAMConsumedJoules(socketStatesBefore_[skt], socketStatesAfter_[skt]);
            }

            systemRead += iMC_Rd_socket[skt];
            systemWrite += iMC_Wr_socket[skt];
            systemPMMRead += iMC_PMM_Rd_socket[skt];
            systemPMMWrite += iMC_PMM_Wr_socket[skt];

            ++onlineSocketsI;
        }

        memory.system.read = systemRead;
        memory.system.write = systemWrite;
        memory.system.total = systemRead + systemWrite;
    }

    void Daemon::getPCMQPI()
    {
        PCMQPI& qpi = sharedPCMState_->pcm.qpi;

        const uint32 numSockets = sharedPCMState_->pcm.system.numOfSockets;
        const uint32 numLinksPerSocket = sharedPCMState_->pcm.system.numOfQPILinksPerSocket;

        qpi.incomingQPITrafficMetricsAvailable = pcmInstance_->incomingQPITrafficMetricsAvailable();
        if (qpi.incomingQPITrafficMetricsAvailable)
        {
            uint32 onlineSocketsI(0);
            for (uint32 i(0); i < numSockets; ++i)
            {
                if (!pcmInstance_->isSocketOnline(i))
                    continue;

                qpi.incoming[onlineSocketsI].socketId = i;

                uint64 total(0);
                for (uint32 l(0); l < numLinksPerSocket; ++l)
                {
                    uint64 bytes = getIncomingQPILinkBytes(i, l, systemStatesBefore_, systemStatesAfter_);
                    qpi.incoming[onlineSocketsI].links[l].bytes = bytes;
                    qpi.incoming[onlineSocketsI].links[l].utilization = getIncomingQPILinkUtilization(i, l, systemStatesForQPIBefore_, systemStatesAfter_);

                    total += bytes;
                }
                qpi.incoming[i].total = total;

                ++onlineSocketsI;
            }

            qpi.incomingTotal = getAllIncomingQPILinkBytes(systemStatesBefore_, systemStatesAfter_);
        }

        qpi.outgoingQPITrafficMetricsAvailable = pcmInstance_->outgoingQPITrafficMetricsAvailable();
        if (qpi.outgoingQPITrafficMetricsAvailable)
        {
            uint32 onlineSocketsI(0);
            for (uint32 i(0); i < numSockets; ++i)
            {
                if (!pcmInstance_->isSocketOnline(i))
                    continue;

                qpi.outgoing[onlineSocketsI].socketId = i;

                uint64 total(0);
                for (uint32 l(0); l < numLinksPerSocket; ++l)
                {
                    uint64 bytes = getOutgoingQPILinkBytes(i, l, systemStatesBefore_, systemStatesAfter_);
                    qpi.outgoing[onlineSocketsI].links[l].bytes = bytes;
                    qpi.outgoing[onlineSocketsI].links[l].utilization = getOutgoingQPILinkUtilization(i, l, systemStatesForQPIBefore_, systemStatesAfter_);

                    total += bytes;
                }
                qpi.outgoing[i].total = total;

                ++onlineSocketsI;
            }

            qpi.outgoingTotal = getAllOutgoingQPILinkBytes(systemStatesBefore_, systemStatesAfter_);
        }
    }

    uint64 Daemon::getTimestamp()
    {
        struct timespec now;

        clock_gettime(CLOCK_MONOTONIC_RAW, &now);

        uint64 epoch = (uint64)now.tv_sec * 1E9;
        epoch += (uint64)now.tv_nsec;

        return epoch;
    }

    void Daemon::cleanup()
    {
        if (sharedPCMState_ != NULL)
        {
            //Detach shared memory segment
            int success = shmdt(sharedPCMState_);
            if (success != 0)
            {
                std::cerr << "Failed to detach the shared memory segment (errno=" << errno << ")\n";
            }
            else
            {
                // Delete segment
                int success = shmctl(sharedMemoryId_, IPC_RMID, NULL);
                if (success != 0)
                {
                    std::cerr << "Failed to delete the shared memory segment (errno=" << errno << ")\n";
                }
            }

            //Delete shared memory ID file
            success = remove(shmIdLocation_.c_str());
            if (success != 0)
            {
                std::cerr << "Failed to delete shared memory id location: " << shmIdLocation_ << " (errno=" << errno << ")\n";
            }
        }
    }
}

```

`src/daemon/daemon.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Steven Briscoe

#ifndef DAEMON_H_
#define DAEMON_H_

#include <sys/types.h>
#include <map>
#include <string>
#include <grp.h>

#include "common.h"
#include "pcm.h"

namespace PCMDaemon {

	enum Mode { DIFFERENCE, ABSOLUTE };

	class Daemon {
	public:
		Daemon(int argc, char *argv[]);
		~Daemon();
		int run();
        Daemon (const Daemon &) = delete;
        Daemon & operator = (const Daemon &) = delete;
	private:
		void setupPCM();
		void checkAccessAndProgramPCM();
		void readApplicationArguments(int argc, char *argv[]);
		void printExampleUsageAndExit(char *argv[]);
		void setupSharedMemory();
		gid_t resolveGroupName(const std::string& groupName);
		void getPCMCounters();
		void updatePCMState(SystemCounterState* systemStates, std::vector<SocketCounterState>* socketStates, std::vector<CoreCounterState>* coreStates, uint64 & t);
		void swapPCMBeforeAfterState();
		void getPCMSystem();
		void getPCMCore();
		void getPCMMemory();
		void getPCMQPI();
		uint64 getTimestamp();
		static void cleanup();

		bool debugMode_;
		uint32 pollIntervalMs_;
		std::string groupName_;
		Mode mode_;
		static std::string shmIdLocation_;

		static int sharedMemoryId_;
		static SharedPCMState* sharedPCMState_;
		PCM* pcmInstance_;
		std::map<std::string, uint32> subscribers_;
		std::vector<std::string> allowedSubscribers_;

		//Data for core, socket and system state
		uint64 collectionTimeBefore_{0ULL}, collectionTimeAfter_{0ULL};
		std::vector<CoreCounterState> coreStatesBefore_, coreStatesAfter_;
		std::vector<SocketCounterState> socketStatesBefore_, socketStatesAfter_;
		SystemCounterState systemStatesBefore_, systemStatesForQPIBefore_, systemStatesAfter_;
		ServerUncoreCounterState* serverUncoreCounterStatesBefore_;
		ServerUncoreCounterState* serverUncoreCounterStatesAfter_;
	};

}

#endif /* DAEMON_H_ */

```

`src/daemon/main.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Steven Briscoe

#include "daemon.h"

PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
	PCMDaemon::Daemon daemon(argc, argv);

	return daemon.run();
}

```

`src/daemon/pcm.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Steven Briscoe

#ifndef PCM_H_
#define PCM_H_

#ifdef _MSC_VER
	#include <windows.h>
	#include "../../../PCM_Win/windriver.h"
#else
	#include <unistd.h>
	#include <signal.h>
	#include <sys/time.h> // for gettimeofday()
#endif
#include "../cpucounters.h"
#include "../utils.h"
#ifdef _MSC_VER
	#include "../../freegetopt/getopt.h"
#endif

using namespace pcm;

#endif /* PCM_H_ */

```

`src/dashboard.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2020-2022, Intel Corporation

#include <vector>
#include <memory>
#include <mutex>

#ifdef _MSC_VER
#include <winsock2.h>
#pragma comment(lib, "ws2_32.lib")
#else
#include <unistd.h>
#endif

#include "pcm-accel-common.h"
#include "dashboard.h"

namespace pcm {

class Target
{
public:
    virtual std::string operator () (const std::string& refId) const = 0;
    virtual ~Target() {}
};

class InfluxDBTarget : public Target
{
    std::string alias;
    std::string metric;
    InfluxDBTarget() = delete;
public:
    InfluxDBTarget(const std::string & alias_, const std::string & metric_) : alias(alias_), metric(metric_) {}
    std::string operator () (const std::string & refId) const
    {
        std::string result;
        result += R"PCMDELIMITER(
        {
          "alias": ")PCMDELIMITER";
        result += alias;
        result += R"PCMDELIMITER(",
          "groupBy": [
            {
              "params": [
                "$__interval"
              ],
              "type": "time"
            },
            {
              "params": [
                "null"
              ],
              "type": "fill"
            }
          ],
          "measurement": "http",
          "orderByTime": "ASC",
          "policy": "default",
          "query": "SELECT )PCMDELIMITER";
        result += metric;
        result += R"PCMDELIMITER( FROM \"http\" WHERE (\"url\" = '$node') AND $timeFilter GROUP BY time($__interval) fill(null)",
          "rawQuery": true,
          "refId": ")PCMDELIMITER";
        result += refId;
        result += R"PCMDELIMITER(",
          "resultFormat": "time_series",
          "select": [
            [
              {
                "params": [
                  "value"
                ],
                "type": "field"
              },
              {
                "params": [],
                "type": "mean"
              }
            ]
          ],
          "tags": []
        })PCMDELIMITER";
        return result;
    }
};

class PrometheusTarget : public Target
{
    std::string legend, expr;
    PrometheusTarget() = delete;
public:
    PrometheusTarget(const std::string& legend_, const std::string& expr_) : legend(legend_), expr(expr_) {}
    std::string operator () (const std::string& refId) const
    {
        std::string result;
        result += R"PCMDELIMITER(
        {
          "expr": ")PCMDELIMITER";
        result += expr;
        result += R"PCMDELIMITER(",
          "instant": false,
          "interval": "",
          "legendFormat": ")PCMDELIMITER";
        result += legend;
        result += R"PCMDELIMITER(",
          "refId": ")PCMDELIMITER";
        result += refId;
        result += R"PCMDELIMITER("
        })PCMDELIMITER";
        return result;
    }
};

const char * defaultDataSource = "null";

class Panel
{
    int x, y, w, h;
    std::string title;
    std::vector<std::shared_ptr<Target>> targets;
    Panel() = delete;
protected:
    std::string getHeader(const int id) const
    {
        std::string result;
        result += R"PCMDELIMITER(
    {
      "datasource": )PCMDELIMITER";
        result += defaultDataSource;
        result += R"PCMDELIMITER(,
      "interval": "2s",
      "gridPos": {
)PCMDELIMITER";
        result += "        \"x\": " + std::to_string(x) + ",\n";
        result += "        \"y\": " + std::to_string(y) + ",\n";
        result += "        \"w\": " + std::to_string(w) + ",\n";
        result += "        \"h\": " + std::to_string(h);
        result += R"PCMDELIMITER(
      },
      "title": ")PCMDELIMITER";
        result += title;
        result += "\",\n      \"id\": " + std::to_string(id) + ",\n      \"targets\": [";
        char refId[] = "A";
        for (size_t i = 0; i< targets.size(); ++i, ++(refId[0]))
        {
            if (i > 0)
            {
                result += ",";
            }
            result += targets[i]->operator()(refId);
        }
        result += "\n      ],\n";
        return result;
    }
public:
    Panel(int x_, int y_, int w_, int h_, const std::string & title_) : x(x_), y(y_), w(w_), h(h_), title(title_) {}
    void push(const std::shared_ptr<Target> & t)
    {
        targets.push_back(t);
    }
    virtual std::string operator () (const int id) const = 0;
    virtual ~Panel() {}
};

class GaugePanel : public Panel
{
    GaugePanel() = delete;
public:
    GaugePanel(int x_, int y_, int w_, int h_, const std::string & title_) : Panel(x_, y_, w_, h_, title_) {}
    std::string operator () (const int id) const
    {
        std::string result = Panel::getHeader(id);
        result += R"PCMDELIMITER(      "options": {
        "fieldOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "defaults": {
            "mappings": [],
            "max": 100,
            "min": 0,
            "thresholds": {
              "mode": "absolute",
              "steps": [
                {
                  "color": "green",
                  "value": null
                },
                {
                  "color": "red",
                  "value": 70
                }
              ]
            },
            "unit": "%"
          },
          "overrides": [],
          "values": false
        },
        "orientation": "auto",
        "showThresholdLabels": false,
        "showThresholdMarkers": true
      },
      "pluginVersion": "6.7.2",
      "timeFrom": null,
      "timeShift": null,
      "type": "gauge"
    })PCMDELIMITER";
        return result;
    }
};

class BarGaugePanel : public Panel
{
    BarGaugePanel() = delete;
public:
    BarGaugePanel(int x_, int y_, int w_, int h_, const std::string & title_) : Panel(x_, y_, w_, h_, title_) {}
    std::string operator () (const int id) const
    {
        std::string result = Panel::getHeader(id);
        result += R"PCMDELIMITER(      "cacheTimeout": null,
      "links": [
        {
          "title": "",
          "url": ""
        }
      ],
      "options": {
        "displayMode": "lcd",
        "fieldOptions": {
          "calcs": [
            "lastNotNull"
          ],
          "defaults": {
            "mappings": [
              {
                "$$hashKey": "object:413",
                "id": 0,
                "op": "=",
                "text": "N/A",
                "type": 1,
                "value": "null"
              }
            ],
            "nullValueMode": "connected",
            "thresholds": {
              "mode": "absolute",
              "steps": [
                {
                  "color": "green",
                  "value": null
                }
              ]
            },
            "unit": "none"
          },
          "overrides": [],
          "values": false
        },
        "orientation": "vertical",
        "showUnfilled": true
      },
      "pluginVersion": "6.7.2",
      "timeFrom": null,
      "timeShift": null,
      "type": "bargauge"
    })PCMDELIMITER";
        return result;
    }
};

class TimeSeriesPanel : public Panel
{
    std::string yAxisLabel;
    bool stack;
    TimeSeriesPanel() = delete;
public:
    TimeSeriesPanel(int x_, int y_, int w_, int h_, const std::string & title_, const std::string & yAxisLabel_, bool stack_)
        : Panel(x_, y_, w_, h_, title_)
        , yAxisLabel(yAxisLabel_)
        , stack(stack_)
    {
    }
    std::string operator () (const int id) const
    {
        std::string result = Panel::getHeader(id);
        result += R"PCMDELIMITER(      "aliasColors": {},
      "bars": false,
      "dashLength": 10,
      "dashes": false,
      "fill": 1,
      "fillGradient": 0,
      "hiddenSeries": false,
      "legend": {
        "avg": false,
        "current": false,
        "max": false,
        "min": false,
        "show": true,
        "total": false,
        "values": false
      },
      "lines": true,
      "linewidth": 1,
      "links": [
        {
          "title": "",
          "url": ""
        }
      ],
      "nullPointMode": "null",
      "options": {
        "dataLinks": []
      },
      "percentage": false,
      "pluginVersion": "10.4.2",
      "pointradius": 2,
      "points": false,
      "renderer": "flot",
      "seriesOverrides": [],
      "spaceLength": 10,
      "stack": )PCMDELIMITER";
      result += stack? "true" : "false";
      result += R"PCMDELIMITER(,
      "steppedLine": false,
      "thresholds": [],
      "timeFrom": null,
      "timeRegions": [],
      "timeShift": null,
      "tooltip": {
        "shared": true,
        "sort": 0,
        "value_type": "individual"
      },
      "type": "timeseries",
      "xaxis": {
        "buckets": null,
        "mode": "time",
        "name": null,
        "show": true,
        "values": []
      },
      "yaxes": [
        {
          "$$hashKey": "object:2758",
          "format": "none",
          "label": ")PCMDELIMITER";
          result += yAxisLabel;
          result += R"PCMDELIMITER(",
          "logBase": 1,
          "max": null,
          "min": "0",
          "show": true
        },
        {
          "$$hashKey": "object:2759",
          "format": "none",
          "label": null,
          "logBase": 1,
          "max": null,
          "min": null,
          "show": true
        }
      ],
      "yaxis": {
        "align": false,
        "alignLevel": null
      }
    })PCMDELIMITER";
        return result;
    }
};

class Dashboard
{
    std::string title;
    PCMDashboardType type;
    std::vector<std::shared_ptr<Panel>> panels;
    Dashboard() = delete;
public:
    Dashboard(const std::string & title_,PCMDashboardType type_) : title(title_), type(type_) {}
    void push(const std::shared_ptr<Panel> & p)
    {
        panels.push_back(p);
    }
    std::string operator () () const
    {
        std::string result;
        std::string definition,query;
        if(type==InfluxDB){
          definition = "\"SHOW TAG VALUES WITH KEY = \\\"url\\\"\"";
          query = "\"SHOW TAG VALUES WITH KEY = \\\"url\\\"\"";
        }
        else{
          definition = "\"label_values(Number_of_sockets,instance)\"";
          query = "{\"query\": \"label_values(Number_of_sockets,instance)\",\"refId\": \"StandardVariableQuery\"}"; 
        }
        result += R"PCMDELIMITER({
  "annotations": {
    "list": [
      {
        "$$hashKey": "object:2661",
        "builtIn": 1,
        "datasource": "-- Grafana --",
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "gnetId": null,
  "graphTooltip": 0,
  "id": 1,
  "links": [],
  "panels": [)PCMDELIMITER";
        for (size_t i=0; i < panels.size(); ++i)
        {
            if (i > 0)
            {
                result += ",";
            }
            result += panels[i]->operator()(i + 2);
        }
        result += R"PCMDELIMITER(
  ],
  "refresh": "1s",
  "schemaVersion": 22,
  "style": "dark",
  "tags": [],
  "templating": {
    "list": [
      {
        "current": {
          "selected": false,
          "text": "ip addr:port",
          "value": "ip addr:port"
        },
        "datasource": null,
        "definition": )PCMDELIMITER"; 
        result +=definition;
        result += R"PCMDELIMITER(,
        "hide": 0,
        "includeAll": false,
        "label": "Host",
        "multi": false,
        "name": "node",
        "options": [],
        "query":)PCMDELIMITER";
         result+=query;
         result += R"PCMDELIMITER(,
        "refresh": 1,
        "regex": "",
        "skipUrlSync": false,
        "sort": 0,
        "type": "query"
      }
    ]
  },
  "time": {
    "from": "now-5m",
    "to": "now"
  },
  "timepicker": {
    "refresh_intervals": [
      "1s",
      "2s",
      "5s",
      "10s",
      "30s",
      "1m",
      "5m",
      "15m",
      "30m",
      "1h",
      "2h",
      "1d"
    ]
  },
  "timezone": "",
  "title": ")PCMDELIMITER";
        result += title;
        result += R"PCMDELIMITER(",
  "uid": "A_CvwTCWk",
  "variables": {
    "list": []
  },
  "version": 1
})PCMDELIMITER";
        return result;
    }
};

std::string prometheusMetric(const std::string& m)
{
    auto result = m;
    for (char& c : result)
    {
        if (c == ' ' || c == '-')
        {
            c = '_';
        }
    }
    return result;
}

std::string prometheusSystem()
{
    return "{instance=\\\"$node\\\", aggregate=\\\"system\\\"}";
}

std::string prometheusSocket(const std::string& S, const bool aggregate = true)
{
    if (aggregate)
        return "{instance=\\\"$node\\\", aggregate=\\\"socket\\\", socket=\\\"" + S + "\\\"}";
    return "{instance=\\\"$node\\\", socket=\\\"" + S + "\\\"}";
}

std::string prometheusSystem(const std::string& S)
{
    return "{instance=\\\"$node\\\", aggregate=\\\"system\\\", socket=\\\"" + S + "\\\"}";
}

std::string influxDB_Counters(const std::string& S, const std::string& m, const char * domain)
{
    return std::string("mean(\\\"Sockets_") + S + "_" + domain + "_" + m + "\\\")";
}

std::string influxDB_Counters(const std::string& m, const char* domain)
{
    return std::string("mean(\\\"") + domain + "_" + m + "\\\")";
}

std::string influxDBCore_Aggregate_Core_Counters(const std::string& S, const std::string& m)
{
    return influxDB_Counters(S, m, "Core Aggregate_Core Counters");
}

std::string influxDBAccel_Counters(const std::string& S, const std::string& m)
{
    AcceleratorCounterState * accs = AcceleratorCounterState::getInstance();
    return std::string("mean(\\\"Sockets_") + S + "_Accelerators_" +accs->getAccelCounterName()+" Counters Device_"  + m + "\\\")";
}

std::string influxDBCore_Aggregate_Core_Counters(const std::string& m)
{
    return influxDB_Counters(m, "Core Aggregate_Core Counters");
}

std::string influxDBUncore_Uncore_Counters(const std::string& S, const std::string& m)
{
    return influxDB_Counters(S, m, "Uncore_Uncore Counters");
}

const char* interval = "[4s]";

std::string prometheusCounters(const std::string& S, const std::string& m, const bool aggregate = true)
{
    return std::string("rate(") + prometheusMetric(m) + prometheusSocket(S, aggregate) + interval + ")";
}

std::string prometheusCounters(const std::string& m)
{
    return std::string("rate(") + prometheusMetric(m) + prometheusSystem() + interval + ")";
}

std::mutex dashboardGenMutex;

std::string getPCMDashboardJSON(const PCMDashboardType type, int ns, int nu, int nc)
{
    auto pcm = PCM::getInstance();
    auto accs = AcceleratorCounterState::getInstance();
    std::lock_guard<std::mutex> dashboardGenGuard(dashboardGenMutex);
    const size_t NumSockets = (ns < 0) ? pcm->getNumSockets() : ns;
    const size_t NumUPILinksPerSocket = (nu < 0) ? pcm->getQPILinksPerSocket() : nu;
    const size_t maxCState = (nc < 0) ? PCM::MAX_C_STATE : nc;

    constexpr int height = 5;
    constexpr int width = 15;
    constexpr int max_width = 24;
    int y = 0;

    if (type == Prometheus_Default)
    {
        interval = "[60s]";
        defaultDataSource = "\"prometheus\"";
    }
    else
    {
        interval = "[4s]";
        defaultDataSource = "null";
    }
    char buffer[64];
    std::string hostname = "unknown hostname";
    if (gethostname(buffer, 63) == 0)
    {
        hostname = buffer;
    }
    Dashboard dashboard("Intel(r) Performance Counter Monitor (Intel(r) PCM) Dashboard - " + hostname,type);
    auto createTarget = [type](const std::string& title, const std::string& inluxdbMetric, const std::string& prometheusExpr) -> std::shared_ptr<Target>
    {
        std::shared_ptr<Target> t;
        if (type == InfluxDB)
            t = std::make_shared<InfluxDBTarget>(title, inluxdbMetric);
        else
            t = std::make_shared<PrometheusTarget>(title, prometheusExpr);
        return t;
    };
    auto scaled = [&] (const char * m, const char * unit, const char * op, const bool total = true)
    {
        auto panel = std::make_shared<TimeSeriesPanel>(0, y, width, height, std::string(m), unit, false);
        auto panel1 = std::make_shared<BarGaugePanel>(width, y, max_width - width, height, std::string(m) + " (" + unit + ")");
        y += height;
        for (size_t s = 0; s < NumSockets; ++s)
        {
            const auto S = std::to_string(s);
            auto t = createTarget("Socket" + S, influxDBCore_Aggregate_Core_Counters(S, m) + op, prometheusCounters(S, m) + op);
            panel->push(t);
            panel1->push(t);
        }
        if (total)
        {
            auto t = createTarget("Total", influxDBCore_Aggregate_Core_Counters(m) + op, prometheusCounters(m) + op);
            panel->push(t);
            panel1->push(t);
            dashboard.push(panel);
            dashboard.push(panel1);
        }
    };
    if (type == InfluxDB) {
        scaled("Core Frequency", "GHz", "/1000000000");
    }
    for (size_t s = 0; type == InfluxDB && s < NumSockets; ++s)
    {
        const char * op = "/1000000000";
        const auto S = std::to_string(s);
        auto panel = std::make_shared<TimeSeriesPanel>(0, y, width, height, std::string("Socket") +  S + " Uncore Frequencies", "GHz", false);
        auto panel1 = std::make_shared<BarGaugePanel>(width, y, max_width - width, height, std::string("Current Socket") +  S + " Uncore Frequencies (GHz)");
        y += height;
        for (size_t d = 0; d < (std::max)(pcm->getNumUFSDies(), (size_t)1ULL); ++d)
        {
          auto m = std::string("Uncore Frequency Die ") + std::to_string(d);
          auto t = createTarget(m, influxDBUncore_Uncore_Counters(S, m) + op, prometheusCounters(S, m, false) + op);
          panel->push(t);
          panel1->push(t);
        }
        dashboard.push(panel);
        dashboard.push(panel1);
    }
    for (size_t s = 0; s < NumSockets; ++s)
    {
        const auto S = std::to_string(s);
        auto panel = std::make_shared<TimeSeriesPanel>(0, y, width, height, std::string("Socket") +  S + " Energy Consumption", "Watt", false);
        auto panel1 = std::make_shared<BarGaugePanel>(width, y, max_width - width, height, std::string("Current Socket") +  S + " Energy Consumption (Watt)");
        y += height;
        for (auto &m : {"Package Joules Consumed", "DRAM Joules Consumed", "PP0 Joules Consumed", "PP1 Joules Consumed"})
        {
          auto t = createTarget(m, influxDBUncore_Uncore_Counters(S, m), prometheusCounters(S, m, false));
          panel->push(t);
          panel1->push(t);
        }
        dashboard.push(panel);
        dashboard.push(panel1);
    }
    {
        auto panel = std::make_shared<TimeSeriesPanel>(0, y, width, height, "Memory Bandwidth", "MByte/sec", false);
        auto panel1 = std::make_shared<BarGaugePanel>(width, y, max_width - width, height, "Memory Bandwidth (MByte/sec)");
        y += height;
        auto genAll = [type](const std::string& special) -> std::string
        {
            std::string all;
            for (auto& m : { "DRAM Reads", "DRAM Writes", "Persistent Memory Reads", "Persistent Memory Writes" })
            {
                if (all.size() > 0)
                {
                    all += " + ";
                }
                if (type == InfluxDB)
                    all += special + "_Uncore Counters_" + m + "\\\")/1048576";
                else
                    all += std::string("rate(") + prometheusMetric(m) + special + interval + ")/1048576";
            }
            return all;
        };
        for (size_t s = 0; s < NumSockets; ++s)
        {
            const auto S = std::to_string(s);
            auto t = createTarget("Socket" + S, genAll("mean(\\\"Sockets_" + S + "_Uncore"), genAll(prometheusSocket(S, false)));
            panel->push(t);
            panel1->push(t);
        }
        auto t = createTarget("Total", genAll("mean(\\\"Uncore Aggregate"), genAll(prometheusSystem()));
        panel->push(t);
        panel1->push(t);
        dashboard.push(panel);
        dashboard.push(panel1);
    };
    for (size_t s = 0; s < NumSockets; ++s)
    {
        const auto S = std::to_string(s);
        auto panel = std::make_shared<TimeSeriesPanel>(0, y, width, height, std::string("Socket") + S + " Memory Bandwidth", "MByte/sec", false);
        auto panel1 = std::make_shared<BarGaugePanel>(width, y, max_width - width, height, std::string("Current Socket") + S + " Memory Bandwidth (MByte/sec)");
        y += height;
        for (auto& m : { "DRAM Reads", "DRAM Writes", "Persistent Memory Reads", "Persistent Memory Writes" })
        {
            auto t = createTarget(m, influxDBUncore_Uncore_Counters(S, m) + "/1048576", prometheusCounters(S, m, false) + "/1048576");
            panel->push(t);
            panel1->push(t);
        }
        for (auto& m : {"CXL Write Mem","CXL Write Cache" }){
            auto t = createTarget(m, "mean(\\\"QPI/UPI Links_QPI Counters Socket " + S + "_" + m + "\\\")/1048576", prometheusCounters(S, m, false) + "/1048576");
            panel->push(t);
            panel1->push(t);
         }
        for (std::string m : { "DRAM ", "Persistent Memory " })
        {
            auto t = createTarget(m + "Total",
            "(" + influxDBUncore_Uncore_Counters(S, m + "Writes") + "+" + influxDBUncore_Uncore_Counters(S, m + "Reads") + ")/1048576",
            "(" + prometheusCounters(S, m + "Writes", false) + "+" + prometheusCounters(S, m + "Reads", false) + ")/1048576");
            panel->push(t);
            panel1->push(t);
        }
        dashboard.push(panel);
        dashboard.push(panel1);
    }
    if(pcm->nearMemoryMetricsAvailable()){        // Near Memory statistics
      y += height;
      for (size_t s = 0; s < NumSockets; ++s)
      {
      const auto S = std::to_string(s);
      
      auto panel = std::make_shared<TimeSeriesPanel>(0, y, width, height,std::string("Socket") + S + " Near Memory Hit Miss", "M/s", false);
      auto panel1 = std::make_shared<BarGaugePanel>(width, y, max_width - width, height,std::string("Current Socket") + S + "Near Memory Hit/Miss");
        for (auto& m : {"NM Hits","NM Misses","NM Miss Bw"})
          {
              auto t = createTarget(m, influxDBUncore_Uncore_Counters(S, m) + "/1048576", prometheusCounters(S, m, false) + "/1048576");
              panel->push(t);
              panel1->push(t);
          }
        dashboard.push(panel);
        dashboard.push(panel1);
      }


      auto NMpanel = std::make_shared<TimeSeriesPanel>(0, y, width, height, "Near Memory Hit Rate", "NM Hit Rate", false);
      auto NMpanel1 = std::make_shared<GaugePanel>(width, y, max_width - width, height, "Near Memory HitRate");
      y += height;
      for (size_t s = 0; s < NumSockets; ++s)
      {
        const auto S = std::to_string(s);
        auto t = createTarget("Socket " + S, influxDBUncore_Uncore_Counters(S, "NM HitRate") + "/1048576", prometheusCounters(S, "NM HitRate", false) + "/1048576");
              NMpanel->push(t);
              NMpanel1->push(t);
        
      }
      dashboard.push(NMpanel);
      dashboard.push(NMpanel1);
    }
    auto panel = std::make_shared<TimeSeriesPanel>(0, y, width, height, "PMEM/DRAM Bandwidth Ratio", "PMEM/DRAM", false);
    auto panel1 = std::make_shared<BarGaugePanel>(width, y, max_width - width, height, "PMEM/DRAM Bandwidth Ratio");
    y += height;
    for (size_t s = 0; s < NumSockets; ++s)
    {
        const auto S = std::to_string(s);
        auto t = createTarget("Socket" + S,
            "(" + influxDBUncore_Uncore_Counters(S, "Persistent Memory Writes") +
            "+" + influxDBUncore_Uncore_Counters(S, "Persistent Memory Reads") +
            ")/" +
            "(" + influxDBUncore_Uncore_Counters(S, "DRAM Writes") +
            "+" + influxDBUncore_Uncore_Counters(S, "DRAM Reads") + ")",
            "(" + prometheusCounters(S, "Persistent Memory Writes", false) +
            "+" + prometheusCounters(S, "Persistent Memory Reads", false) +
            ")/" +
            "(" + prometheusCounters(S, "DRAM Writes", false) +
            "+" + prometheusCounters(S, "DRAM Reads", false) +")");
        panel->push(t);
        panel1->push(t);
    }
    dashboard.push(panel);
    dashboard.push(panel1);
    auto stacked = [&] (const char * m, std::vector<const char *> metrics, size_t s, const bool core = false)
    {
        const auto S = std::to_string(s);
        auto my_height = 3 * height / 2;
        auto panel = std::make_shared<TimeSeriesPanel>(0, y, width, my_height, "Socket" + S + " " + std::string(m), "stacked %", true);
        auto panel1 = std::make_shared<BarGaugePanel>(width, y, max_width - width, my_height, std::string("Current ") + m + " (%)");
        y += my_height;
        for (auto & metric : metrics)
        {
            std::shared_ptr<pcm::Target> t;
            if (core)
            {
                t = createTarget(metric, influxDBCore_Aggregate_Core_Counters(S, metric), "");
            }
            else
            {
                t = createTarget(metric, influxDBUncore_Uncore_Counters(S, metric), "");
            }
            panel->push(t);
            panel1->push(t);
        }
        dashboard.push(panel);
        dashboard.push(panel1);
    };
    for (size_t s = 0; type == InfluxDB && s < NumSockets; ++s)
    {
        stacked("Memory Request Ratio", {"Local Memory Request Ratio", "Remote Memory Request Ratio"}, s);
    }
    auto upi = [&](const std::string & m, const bool utilization)
    {
        for (size_t s = 0; s < NumSockets && NumUPILinksPerSocket > 0; ++s)
        {
            const auto S = std::to_string(s);
            auto panel = std::make_shared<TimeSeriesPanel>(0, y, width, height, std::string("Socket") + S + " " + pcm->xPI() + " " + m, utilization?"%": "MByte/sec", false);
            std::shared_ptr<Panel> panel1;
            if (utilization)
                panel1 = std::make_shared<GaugePanel>(width, y, max_width - width, height, std::string("Current Socket") + S + " UPI " + m + " (%)");
            else
                panel1 = std::make_shared<BarGaugePanel>(width, y, max_width - width, height, std::string("Current Socket") + S + " UPI " + m + " (MByte/sec)");
            y += height;
            const auto suffix = utilization ? "*100" : "/1048576";
            for (size_t l = 0; l < NumUPILinksPerSocket; ++l)
            {
                const auto L = std::to_string(l);
                auto t = createTarget(pcm->xPI() + std::to_string(l),
                    "mean(\\\"QPI/UPI Links_QPI Counters Socket " + S + "_" + m + " On Link " + L + "\\\")" +  suffix,
                    "rate(" + prometheusMetric(m) + "_On_Link_" + L + prometheusSystem(S) + interval + ")" + suffix);
                panel->push(t);
                panel1->push(t);
            }
            dashboard.push(panel);
            dashboard.push(panel1);
        }
    };
    for (auto &m : {"Utilization Outgoing Data And Non-Data Traffic", "Utilization Incoming Data Traffic"})
    {
        upi(m, true);
    }
    for (auto & m : {"Outgoing Data And Non-Data Traffic", "Incoming Data Traffic"})
    {
        upi(m, false);
    }
    auto cstate = [&] (const char * m, const char * tPrefix, const char * source)
    {
        auto my_height = 3 * height / 2;
        auto panel = std::make_shared<TimeSeriesPanel>(0, y, width, my_height, std::string(m) + " C-state residency", "stacked %", true);
        auto panel1 = std::make_shared<BarGaugePanel>(width, y, max_width - width, my_height, std::string("Current ") + m + " C-state residency (%)");
        y += my_height;
        auto prometheusCStateExpression = [](const std::string& source, const size_t c) -> std::string
        {
            auto C = std::to_string(c);
            return std::string("100 * rate(RawCStateResidency{ instance=\\\"$node\\\", aggregate = \\\"system\\\", index = \\\"") + C + "\\\", source = \\\"" + source + "\\\" }" + interval +
                ") / ignoring(source, index) rate(Invariant_TSC{ instance=\\\"$node\\\", aggregate = \\\"system\\\" }" + interval + ")";
        };
        auto prometheusComputedCStateExpression = [&maxCState, &prometheusCStateExpression](const std::string& source, const size_t e) -> std::string
        {
            std::string result = "100";
            for (size_t c = 0; c < maxCState + 1; ++c)
            {
                if (e != c)
                {
                    result = result + " - (" + prometheusCStateExpression(source, c) + ") ";
                }
            }
            return result;
        };
        for (size_t c = 0; c < maxCState + 1; ++c)
        {
            auto C = std::to_string(c);
            auto pExpr = prometheusCStateExpression(source, c);
            if ((std::string(source) == "core" && c == 1) || (std::string(source) == "uncore" && c == 0))
            {
               pExpr = prometheusComputedCStateExpression(source, c);
            }
            auto t = createTarget("C" + C, std::string("mean(\\\"") + tPrefix + " Counters_CStateResidency[" + C + "]\\\")*100", pExpr);
            panel->push(t);
            panel1->push(t);
        }
        dashboard.push(panel);
        dashboard.push(panel1);
    };
    cstate("Core", "Core Aggregate_Energy", "core");
    cstate("Package", "Uncore Aggregate_Uncore", "uncore");
    auto derived = [&](const std::string & fullName, const std::string & shortName, const std::string & dividend, const std::string & divisor)
    {
        auto panel = std::make_shared<TimeSeriesPanel>(0, y, width, height, fullName, shortName, false);
        auto panel1 = std::make_shared<BarGaugePanel>(width, y, max_width - width, height, fullName);
        y += height;
        for (size_t s = 0; s < NumSockets; ++s)
        {
            const auto S = std::to_string(s);
            auto t = createTarget("Socket" + S,
                influxDBCore_Aggregate_Core_Counters(S, dividend) + "/" + influxDBCore_Aggregate_Core_Counters(S, divisor),
                prometheusCounters(S, dividend) + "/" + prometheusCounters(S, divisor));
            panel->push(t);
            panel1->push(t);
        }
        auto t = createTarget("Total",
            influxDBCore_Aggregate_Core_Counters(dividend) + "/" + influxDBCore_Aggregate_Core_Counters(divisor),
            prometheusCounters(dividend) + "/" + prometheusCounters(divisor)
        );
        panel->push(t);
        panel1->push(t);
        dashboard.push(panel);
        dashboard.push(panel1);
    };
    derived("Instructions Per Cycle", "IPC", "Instructions Retired Any", "Clock Unhalted Thread");
    for (size_t s = 0; type == InfluxDB && s < NumSockets; ++s)
    {
        stacked("Core Stalls", {
            "Frontend Bound",
            "Bad Speculation",
            "Backend Bound",
            "Retiring",
            "Fetch Latency Bound",
            "Fetch Bandwidth Bound",
            "Branch Misprediction Bound",
            "Machine Clears Bound",
            "Memory Bound",
            "Core Bound",
            "Heavy Operations Bound",
            "Light Operations Bound"
            }, s, true);
    }
    derived("Active Frequency Ratio", "AFREQ", "Clock Unhalted Thread", "Clock Unhalted Ref");
    derived("L3 Cache Misses Per Instruction", "L3 MPI", "L3 Cache Misses", "Instructions Retired Any");
    derived("L2 Cache Misses Per Instruction", "L2 MPI", "L2 Cache Misses", "Instructions Retired Any");
    for (auto & m : {"Instructions Retired Any", "Clock Unhalted Thread", "L2 Cache Hits", "L2 Cache Misses", "L3 Cache Hits", "L3 Cache Misses"})
    {
        scaled(m, "Million", "/1000000");
    }
    if (pcm->getAccel() != ACCEL_NOCONFIG){
        auto accelCounters = [&](const std::string & m)
        {
            auto panel = std::make_shared<TimeSeriesPanel>(0, y, width, height, accs->getAccelCounterName() + " " + m,"Byte/sec", false);
            std::shared_ptr<Panel> panel1;
            panel1 = std::make_shared<BarGaugePanel>(width, y, max_width - width, height, std::string("Current ") +accs->getAccelCounterName() + " (Byte/sec)");
            y += height;
            for (size_t s = 0; s < accs->getNumOfAccelDevs(); ++s)
            {
                const auto S = std::to_string(s);         
                const auto suffix = "/1";
                auto t = createTarget("Device "+S,
                    "mean(\\\"Accelerators_"+accs->getAccelCounterName()+" Counters Device " + S + "_" + m + "\\\")" +  suffix,
                    "rate(" + prometheusMetric(accs->remove_string_inside_use(m))  + "{instance=\\\"$node\\\", aggregate=\\\"system\\\", source=\\\"accel\\\" ,"+accs->getAccelCounterName()+"device=\\\"" + S + "\\\"}" + interval + ")" + suffix);
                panel->push(t);
                panel1->push(t);

            }
            dashboard.push(panel);
            dashboard.push(panel1);
        };
        for (int j =0;j<accs->getNumberOfCounters();j++)
        {
            accelCounters(accs->getAccelIndexCounterName(j));
        }
    }
    return dashboard();
}

} // namespace pcm

```

`src/dashboard.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2020-2022, Intel Corporation
#pragma once
#include <string>

namespace pcm {

enum PCMDashboardType { InfluxDB, Prometheus, Prometheus_Default };

std::string getPCMDashboardJSON(const PCMDashboardType type, int ns = -1, int nu = -1, int nc = -1);

} // namespace pcm

```

`src/dashboardtest.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2020-2022, Intel Corporation

#include "dashboard.h"
#include <iostream>

int main()
{
    std::cout << pcm::getPCMDashboardJSON(pcm::Prometheus, 2, 3, 10) << std::endl;
    return 0;
}

```

`src/debug.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2020-2022, Intel Corporation

namespace pcm {

namespace debug {
    int currentDebugLevel = 0;

    void dyn_debug_level( int debugLevel ) {
        debug::currentDebugLevel = debugLevel;
    }
}

} // namespace pcm

```

`src/debug.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2020-2022, Intel Corporation

#pragma once

#include <sstream>
#include <iomanip>
#include <iostream>

#ifdef _MSC_VER
#include <BaseTsd.h>
#define ssize_t SSIZE_T
#define __PRETTY_FUNCTION__ __FUNCSIG__
#endif

namespace pcm {

namespace debug {
    extern int currentDebugLevel;

    template<typename T>
    void dyn_debug_output_helper( std::stringstream& out, T t ) {
        out << t << "\n";
    }

    template<typename T, typename... Args>
    void dyn_debug_output_helper( std::stringstream& out, const T & t, Args... args ) {
        out << t;
        dyn_debug_output_helper( out, args... );
    }

    template<typename LVL, typename PF, typename F, typename L, typename... Args>
    void dyn_debug_output( std::ostream& out, LVL level, PF pretty_function, F file, L line, Args... args ) {
        std::stringstream ss;
        auto now = time(nullptr);
        ss << "DBG(" << std::dec << level << "): File '" << file << "', line '" << std::dec << line << "' :\n";
        ss << "DBG(" << std::dec << level << "): " << pretty_function << ":\n";
        ss << "DBG(" << std::dec << level << ") " << std::put_time( localtime(&now), "%F_%T: " ); // Next code line will continue printing on this output line
        dyn_debug_output_helper( ss, args... );
        out << ss.str() << std::flush;
    }

    template<typename T>
    void dyn_hex_table_output( int debugLevel, std::ostream& out, ssize_t len, T* inputBuffer_ ) {
        std::stringstream ss;
        if ( debug::currentDebugLevel < debugLevel )
            return;
        for ( ssize_t i = 0; i < len; ++i ) {
            constexpr int DHTO_CHARS_PER_LINE = 16;
            ss << std::hex << std::internal << std::setfill('0') << std::setw(2) << std::abs(inputBuffer_[i]) << " ";
            if ( (i % DHTO_CHARS_PER_LINE) == (DHTO_CHARS_PER_LINE - 1) ) ss << "\n";
        }
        out << ss.str() << std::flush;
    }

    void dyn_debug_level( int debugLevel );
}

#define DBG( level, ... ) \
    if ( debug::currentDebugLevel >= level ) \
        debug::dyn_debug_output( std::cerr, level, __PRETTY_FUNCTION__, __FILE__, __LINE__, __VA_ARGS__)

} // namespace pcm

```

`src/exceptions/unsupported_processor_exception.hpp`:

```hpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Steven Briscoe

#include <exception>
 
class UnsupportedProcessorException: public std::exception
{
	virtual const char* what() const throw()
	{
		return "Unsupported processor";
	}
};

```

`src/favicon.ico.h`:

```h
signed char favicon_ico[] = {
  0x00_uc, 0x00_uc, 0x01_uc, 0x00_uc, 0x01_uc, 0x00_uc, 0x10_uc, 0x10_uc, 0x02_uc, 0x00_uc, 0x01_uc, 0x00_uc,
  0x01_uc, 0x00_uc, 0xb0_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x16_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x28_uc, 0x00_uc,
  0x00_uc, 0x00_uc, 0x10_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x20_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x01_uc, 0x00_uc,
  0x01_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x40_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc,
  0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x02_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x02_uc, 0x00_uc,
  0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0xff_uc, 0xff_uc, 0xff_uc, 0x00_uc, 0xff_uc, 0xff_uc,
  0x00_uc, 0x00_uc, 0x7e_uc, 0x6e_uc, 0x00_uc, 0x00_uc, 0x7d_uc, 0xae_uc, 0x00_uc, 0x00_uc, 0x7d_uc, 0xae_uc,
  0x00_uc, 0x00_uc, 0x7d_uc, 0xee_uc, 0x00_uc, 0x00_uc, 0x7d_uc, 0xee_uc, 0x00_uc, 0x00_uc, 0x7d_uc, 0xee_uc,
  0x00_uc, 0x00_uc, 0x7d_uc, 0xee_uc, 0x00_uc, 0x00_uc, 0x0d_uc, 0xee_uc, 0x00_uc, 0x00_uc, 0x75_uc, 0xea_uc,
  0x00_uc, 0x00_uc, 0x75_uc, 0xea_uc, 0x00_uc, 0x00_uc, 0x75_uc, 0xea_uc, 0x00_uc, 0x00_uc, 0x75_uc, 0xa4_uc,
  0x00_uc, 0x00_uc, 0x75_uc, 0xa4_uc, 0x00_uc, 0x00_uc, 0x0e_uc, 0x6e_uc, 0x00_uc, 0x00_uc, 0xff_uc, 0xff_uc,
  0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc,
  0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc,
  0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc,
  0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc,
  0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc,
  0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc, 0x00_uc
};
unsigned int favicon_ico_len = 198;

```

`src/freegetopt/ChangeLog`:

```
2003-10-25  Mark K. Kim {getopt*cbreak.org}

	* *: freegetopt 0.11 released.

2003-10-25  Mark K. Kim {getopt*cbreak.org}

	* ChangeLog: ChangeLog file added.

	* LICENSE: License file added.  License is now officially BSD.

	* README: Updated to reflect the new license.  CVS tracking data
	  added.

	* getopt.h, getopt.c: License text added to the beginning of
	  each file.  CVS tracking data added.

	* test.c: License text added to the beginning of the file.
	  CVS tracking data added.

2003-10-20  Mark K. Kim {getopt*cbreak.org}

	* *: Sourceforge project approval.  Name changed to freegetopt.
	  License is now officially BSD.

2003-09-29  Jon Higdon {jhigdon*nni.com}

	* test.c: GCC 3.x gives compound statement warning.  Fixed.

2003.01.12  Mark K. Kim {getopt*cbreak.org}

	* *: Getopt 1.0 released!  Supports only short options, but
	  I think it's fully compatible with GNU getopt except for the
	  value of optind while getopt is still running.  The value
	  of optind is same after getopt finishes running, however.


```

`src/freegetopt/LICENSE`:

```
Free Getopt
Copyright (c)2002-2003 Mark K. Kim
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

  * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in
    the documentation and/or other materials provided with the
    distribution.

  * Neither the original author of this software nor the names of its
    contributors may be used to endorse or promote products derived
    from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.


```

`src/freegetopt/README`:

```
Free Getopt

******************************************************************************
Please read the file LICENSE for the terms of use and distribution of this
software.
******************************************************************************

"getopt" is a library that allows a parsing of arguments passed
to a program.  This is a useful library used in many software.
There are many versions of the getopt library available, two
popular versions being the BSD getopt and the GNU getopt.

BSD getopt is somewhat old, dated, and isn't very user-friendly.
The GNU getopt is great, except the user license doesn't let you
statically link the library to a proprietary software.  This
is usually not a problem on modern operating systems that allow
dynamic links to libraries, but sometimes you just gotta link
the library statically for one reason or another.  That's where
Free Getopt steps in.

Functionally, this getopt library is equivalent to GNU's getopt
library (the short option version, not the long one) in almost
every aspect.  The only exception is how the "optind" variable
increments.  Apparently due to different algorithms used by my
program and the GNU getopt, the "optind" changes quite differently
between our two software.  I personally find my algorithm to be
quite elegant; I couldn't tell you about the GNU version since
I never looked at its source.

GNU's getopt_long support is in progress.

This library was deliberately left in non-library (not in
*.lib, *.so, or *.a) form because it's most likely to be
statically-linked in various platforms, and linking it
directly from source is probably the most straight-forward
way to use the software in any platform.

I hope you find this software useful.

Mark K. Kim

$Header: /cvsroot/freegetopt/freegetopt/README,v 1.2 2003/10/26 03:10:19 vindaci Exp $


```

`src/freegetopt/getopt.cpp`:

```cpp
/*****************************************************************************
* getopt.c - competent and free getopt library.
* $Header: /cvsroot/freegetopt/freegetopt/getopt.c,v 1.2 2003/10/26 03:10:20 vindaci Exp $
*
* Copyright (c)2002-2003 Mark K. Kim
* All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*
*   * Redistributions in binary form must reproduce the above copyright
*     notice, this list of conditions and the following disclaimer in
*     the documentation and/or other materials provided with the
*     distribution.
*
*   * Neither the original author of this software nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
* OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
* AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
* THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*/
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "getopt.h"


//static const char* ID = "$Id: getopt.c,v 1.2 2003/10/26 03:10:20 vindaci Exp $";


char* optarg = NULL;
int optind = 0;
int opterr = 1;
int optopt = '?';


static char** prev_argv = NULL;        /* Keep a copy of argv and argc to */
static int prev_argc = 0;              /*    tell if getopt params change */
static int argv_index = 0;             /* Option we're checking */
static int argv_index2 = 0;            /* Option argument we're checking */
static int opt_offset = 0;             /* Index into compounded "-option" */
static int dashdash = 0;               /* True if "--" option reached */
static int nonopt = 0;                 /* How many nonopts we've found */

static void increment_index()
{
	/* Move onto the next option */
	if(argv_index < argv_index2)
	{
		while(prev_argv[++argv_index] && prev_argv[argv_index][0] != '-'
				&& argv_index < argv_index2+1);
	}
	else argv_index++;
	opt_offset = 1;
}


/*
* Permutes argv[] so that the argument currently being processed is moved
* to the end.
*/
static int permute_argv_once()
{
	/* Movability check */
	if(argv_index + nonopt >= prev_argc) return 1;
	/* Move the current option to the end, bring the others to front */
	else
	{
		char* tmp = prev_argv[argv_index];

		/* Move the data */
		memmove(&prev_argv[argv_index], &prev_argv[argv_index+1],
				sizeof(char**) * (prev_argc - argv_index - 1));
		prev_argv[prev_argc - 1] = tmp;

		nonopt++;
		return 0;
	}
}


int getopt(int argc, char** argv, char* optstr)
{
	int c = 0;

	/* If we have new argv, reinitialize */
	if(prev_argv != argv || prev_argc != argc)
	{
		/* Initialize variables */
		prev_argv = argv;
		prev_argc = argc;
		argv_index = 1;
		argv_index2 = 1;
		opt_offset = 1;
		dashdash = 0;
		nonopt = 0;
	}

	/* Jump point in case we want to ignore the current argv_index */
	getopt_top:

	/* Misc. initializations */
	optarg = NULL;

	/* Dash-dash check */
	if(argv[argv_index] && !strcmp(argv[argv_index], "--"))
	{
		dashdash = 1;
		increment_index();
	}

	/* If we're at the end of argv, that's it. */
	if(argv[argv_index] == NULL)
	{
		c = -1;
	}
	/* Are we looking at a string? Single dash is also a string */
	else if(dashdash || argv[argv_index][0] != '-' || !strcmp(argv[argv_index], "-"))
	{
		/* If we want a string... */
		if(optstr[0] == '-')
		{
			c = 1;
			optarg = argv[argv_index];
			increment_index();
		}
		/* If we really don't want it (we're in POSIX mode), we're done */
		else if(optstr[0] == '+' || getenv("POSIXLY_CORRECT"))
		{
			c = -1;

			/* Everything else is a non-opt argument */
			nonopt = argc - argv_index;
		}
		/* If we mildly don't want it, then move it back */
		else
		{
			if(!permute_argv_once()) goto getopt_top;
			else c = -1;
		}
	}
	/* Otherwise we're looking at an option */
	else
	{
		char* opt_ptr = NULL;

		/* Grab the option */
		c = argv[argv_index][opt_offset++];

		/* Is the option in the optstr? */
		if(optstr[0] == '-') opt_ptr = strchr(optstr+1, c);
		else opt_ptr = strchr(optstr, c);
		/* Invalid argument */
		if(!opt_ptr)
		{
			if(opterr)
			{
				fprintf(stderr, "%s: invalid option -- %c\n", argv[0], c);
			}

			optopt = c;
			c = '?';

			/* Move onto the next option */
			increment_index();
		}
		/* Option takes argument */
		else if(opt_ptr[1] == ':')
		{
			/* ie, -oARGUMENT, -xxxoARGUMENT, etc. */
			if(argv[argv_index][opt_offset] != '\0')
			{
				optarg = &argv[argv_index][opt_offset];
				increment_index();
			}
			/* ie, -o ARGUMENT (only if it's a required argument) */
			else if(opt_ptr[2] != ':')
			{
				/* One of those "you're not expected to understand this" moment */
				if(argv_index2 < argv_index) argv_index2 = argv_index;
				while(argv[++argv_index2] && argv[argv_index2][0] == '-');
				optarg = argv[argv_index2];

				/* Don't cross into the non-option argument list */
				if(argv_index2 + nonopt >= prev_argc) optarg = NULL;

				/* Move onto the next option */
				increment_index();
			}
			else
			{
				/* Move onto the next option */
				increment_index();
			}

			/* In case we got no argument for an option with required argument */
			if(optarg == NULL && opt_ptr[2] != ':')
			{
				optopt = c;
				c = '?';

				if(opterr)
				{
					fprintf(stderr,"%s: option requires an argument -- %c\n",
							argv[0], optopt);
				}
			}
		}
		/* Option does not take argument */
		else
		{
			/* Next argv_index */
			if(argv[argv_index][opt_offset] == '\0')
			{
				increment_index();
			}
		}
	}

	/* Calculate optind */
	if(c == -1)
	{
		optind = argc - nonopt;
	}
	else
	{
		optind = argv_index;
	}

	return c;
}


/* vim:ts=3
*/

```

`src/freegetopt/getopt.h`:

```h
/*****************************************************************************
* getopt.h - competent and free getopt library.
* $Header: /cvsroot/freegetopt/freegetopt/getopt.h,v 1.2 2003/10/26 03:10:20 vindaci Exp $
*
* Copyright (c)2002-2003 Mark K. Kim
* All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*
*   * Redistributions in binary form must reproduce the above copyright
*     notice, this list of conditions and the following disclaimer in
*     the documentation and/or other materials provided with the
*     distribution.
*
*   * Neither the original author of this software nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
* OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
* AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
* THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*/
#ifndef GETOPT_H_
#define GETOPT_H_


#ifdef __cplusplus
extern "C" {
#endif


extern char* optarg;
extern int optind;
extern int opterr;
extern int optopt;

int getopt(int argc, char** argv, char* optstr);


#ifdef __cplusplus
}
#endif


#endif /* GETOPT_H_ */


/* vim:ts=3
*/

```

`src/lspci.cpp`:

```cpp
#include "lspci.h"

namespace pcm {

const ccr_config ccr::skx_ccrs(44, 0xFFULL);
const ccr_config ccr::icx_ccrs(48, 0xFFFULL);

bool operator<(const iio_stack& lh, const iio_stack& rh)
{
    return lh.iio_unit_id < rh.iio_unit_id;
}

bool operator<(const bdf &l, const bdf &r) {
    if (l.domainno < r.domainno)
        return true;
    if (l.domainno > r.domainno)
        return false;
    if (l.busno < r.busno)
        return true;
    if (l.busno > r.busno)
        return false;
    if (l.devno < r.devno)
        return true;
    if (l.devno > r.devno)
        return false;
    if (l.funcno < r.funcno)
        return true;
    if (l.funcno > r.funcno)
        return false;

    return false; // bdf == bdf
}

void probe_capability_pci_express(struct pci *p, uint32_t cap_ptr)
{
    struct cap {
        union {
            struct {
                uint8_t id;
                union {
                    uint8_t next;
                    uint8_t cap_ptr;
                };
                uint16_t junk;
            };
            uint32 dw0;
        };
    } cap;
    uint32 value;
    PciHandleType h(0, p->bdf.busno, p->bdf.devno, p->bdf.funcno);
    h.read32(cap_ptr, &value); //Capability pointer
    cap.dw0 = value;
    if (cap.id != 0x10 && cap.next != 0x00) {
        probe_capability_pci_express(p, cap.cap_ptr);
    } else {
        if (cap.id == 0x10) { // We're in PCI express capability structure
            h.read32(cap_ptr+0x10, &value);
            p->link_info = value;
        } else { /*Finish recursive searching but cannot find PCI express capability structure*/ }
    }
}

bool probe_pci(struct pci *p)
{
    uint32 value;
    p->exist = false;
    struct bdf *bdf = &p->bdf;
    if (PciHandleType::exists(bdf->domainno, bdf->busno, bdf->devno, bdf->funcno)) {
        PciHandleType h(bdf->domainno, bdf->busno, bdf->devno, bdf->funcno);
        // VID:DID
        h.read32(0x0, &value);
        // Invalid VID::DID
        if (value != (std::numeric_limits<unsigned int>::max)()) {
            p->offset_0 = value;
            h.read32(0xc, &value);
            p->header_type = (value >> 16) & 0x7f;
            if (p->header_type == 0) {
                // Status register
                h.read32(0x4, &value);
                // Capability list == true
                if (value & 0x100000) {
                    // Capability pointer
                    h.read32(0x34, &value);
                    probe_capability_pci_express(p, value);
                }
            } else if (p->header_type == 1) {
                h.read32(0x18, &value);
                p->offset_18 = value;
            }
            p->exist = true;
        }
    }

    return p->exist;
}

void load_PCIDB(PCIDB & pciDB)
{
    std::ifstream in(PCI_IDS_PATH);
    std::string line, item;

    if (!in.is_open())
    {
#ifndef _MSC_VER
        // On Unix, try PCI_IDS_PATH2
        in.open(PCI_IDS_PATH2);
    }

    if (!in.is_open())
    {
        // On Unix, try the current directory if the default path failed
        in.open("pci.ids");
    }

    if (!in.is_open())
    {
#endif
        std::cerr << PCI_IDS_NOT_FOUND << "\n";
        return;
    }

    int vendorID = -1;

    while (std::getline(in, line)) {
        // Ignore any line starting with #
        if (line.size() == 0 || line[0] == '#')
            continue;

        if (line[0] == '\t' && line[1] == '\t')
        {
            // subvendor subdevice  subsystem_name
            continue;
        }
        if (line[0] == '\t')
        {
            int deviceID = stoi(line.substr(1,4),0,16);
            //std::cout << vendorID << ";" << vendorName << ";" << deviceID << ";" << line.substr(7) << "\n";
            pciDB.second[vendorID][deviceID] = line.substr(7);
            continue;
        }
        // vendor
        vendorID = stoi(line.substr(0,4),0,16);
        pciDB.first[vendorID] = line.substr(6);
    }
}

} // Namespace pcm

```

`src/lspci.h`:

```h
#ifndef CPUCounters_LSPCI_H
#define CPUCounters_LSPCI_H

#include <vector>
#include <fstream>
#include <memory>
#include "cpucounters.h"

#if defined(_MSC_VER)
#define PCI_IDS_PATH "pci.ids"
#define PCI_IDS_NOT_FOUND "pci.ids file is not available. Download it from" \
    " https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids."
#elif defined (__FreeBSD__) || defined(__DragonFly__)
#define PCI_IDS_PATH "/usr/local/share/pciids/pci.ids"
#define PCI_IDS_NOT_FOUND "/usr/local/share/pciids/pci.ids file is not available." \
    " Ensure that the \"pciids\" package is properly installed or download" \
    " https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids and" \
    " copy it to the current directory."
#else
// different distributions put it in different places
#define PCI_IDS_PATH "/usr/share/hwdata/pci.ids"
#define PCI_IDS_PATH2 "/usr/share/misc/pci.ids"
#define PCI_IDS_NOT_FOUND "/usr/share/hwdata/pci.ids file is not available." \
    " Ensure that the \"hwdata\" package is properly installed or download" \
    " https://raw.githubusercontent.com/pciutils/pciids/master/pci.ids and" \
    " copy it to the current directory."
#endif
#define PCI_IDS_PATH2 "/usr/share/misc/pci.ids"

namespace pcm {

typedef uint32_t h_id;
typedef uint32_t v_id;
typedef std::map<std::pair<h_id,v_id>,uint64_t> ctr_data;
typedef std::vector<ctr_data> stack_content;
typedef std::vector<stack_content> result_content;

struct ccr_config {
    static constexpr uint64_t EVENT_SELECT_MASK = 0xFFULL;
    static constexpr uint8_t  UMASK_SHIFT = 8;
    static constexpr uint64_t UMASK_MASK = 0xFFULL << UMASK_SHIFT;
    static constexpr uint8_t  RESET_SHIFT = 17;
    static constexpr uint64_t RESET_MASK = 0x01ULL << RESET_SHIFT;
    static constexpr uint8_t  EDGE_SHIFT = 18;
    static constexpr uint64_t EDGE_MASK = 0x01ULL << EDGE_SHIFT;
    static constexpr uint8_t  OV_EN_SHIFT = 20;
    static constexpr uint64_t OV_EN_MASK = 0x01ULL << OV_EN_SHIFT;
    static constexpr uint8_t  ENABLE_SHIFT = 22;
    static constexpr uint64_t ENABLE_MASK = 0x01ULL << ENABLE_SHIFT;
    static constexpr uint8_t  INVERT_SHIFT = 23;
    static constexpr uint64_t INVERT_MASK = 0x01ULL << INVERT_SHIFT;
    static constexpr uint8_t  THRESH_SHIFT = 24;
    static constexpr uint64_t THRESH_MASK = 0xFFFULL << THRESH_SHIFT;
    static constexpr uint8_t  CH_MASK_SHIFT = 36;

    uint8_t  FC_MASK_SHIFT;
    uint64_t FC_MASK;
    uint64_t CH_MASK;

    ccr_config(uint8_t fc_mask_shift, uint64_t ch_mask)
    : FC_MASK_SHIFT(fc_mask_shift), FC_MASK(0x07ULL << fc_mask_shift), CH_MASK(ch_mask << CH_MASK_SHIFT) {}
};

class ccr {
public:
    enum class ccr_type {
        skx,
        icx
    };

    ccr(uint64_t &v, const ccr_type &type) : ccr_value(v), config(type == ccr_type::skx ? skx_ccrs : icx_ccrs) { }

    ccr() = delete;

    ~ccr() = default;

    uint64_t get_event_select() const {
        return (ccr_value & config.EVENT_SELECT_MASK);
    }

    void set_event_select(uint64_t value) {
        ccr_value = (ccr_value & ~config.EVENT_SELECT_MASK) | (value & config.EVENT_SELECT_MASK);
    }

    uint64_t get_umask() const {
        return (ccr_value & config.UMASK_MASK) >> config.UMASK_SHIFT;
    }

    void set_umask(uint64_t value) {
        ccr_value = (ccr_value & ~config.UMASK_MASK) | ((value << config.UMASK_SHIFT) & config.UMASK_MASK);
    }

    uint64_t get_reset() const {
        return (ccr_value & config.RESET_MASK) >> config.RESET_SHIFT;
    }

    void set_reset(uint64_t value) {
        ccr_value = (ccr_value & ~config.RESET_MASK) | ((value << config.RESET_SHIFT) & config.RESET_MASK);
    }

    uint64_t get_edge() const {
        return (ccr_value & config.EDGE_MASK) >> config.EDGE_SHIFT;
    }

    void set_edge(uint64_t value) {
        ccr_value = (ccr_value & ~config.EDGE_MASK) | ((value << config.EDGE_SHIFT) & config.EDGE_MASK);
    }

    uint64_t get_ov_en() const {
        return (ccr_value & config.OV_EN_MASK) >> config.OV_EN_SHIFT;
    }

    void set_ov_en(uint64_t value) {
        ccr_value = (ccr_value & ~config.OV_EN_MASK) | ((value << config.OV_EN_SHIFT) & config.OV_EN_MASK);
    }

    uint64_t get_enable() const {
        return (ccr_value & config.ENABLE_MASK) >> config.ENABLE_SHIFT;
    }

    void set_enable(uint64_t value) {
        ccr_value = (ccr_value & ~config.ENABLE_MASK) | ((value << config.ENABLE_SHIFT) & config.ENABLE_MASK);
    }

    uint64_t get_invert() const {
        return (ccr_value & config.INVERT_MASK) >> config.INVERT_SHIFT;
    }

    void set_invert(uint64_t value) {
        ccr_value = (ccr_value & ~config.INVERT_MASK) | ((value << config.INVERT_SHIFT) & config.INVERT_MASK);
    }

    uint64_t get_thresh() const {
        return (ccr_value & config.THRESH_MASK) >> config.THRESH_SHIFT;
    }

    void set_thresh(uint64_t value) {
        ccr_value = (ccr_value & ~config.THRESH_MASK) | ((value << config.THRESH_SHIFT) & config.THRESH_MASK);
    }

    uint64_t get_ch_mask() const {
        return (ccr_value & config.CH_MASK) >> config.CH_MASK_SHIFT;
    }

    void set_ch_mask(uint64_t value) {
        ccr_value = (ccr_value & ~config.CH_MASK) | ((value << config.CH_MASK_SHIFT) & config.CH_MASK);
    }

    uint64_t get_fc_mask() const {
        return (ccr_value & config.FC_MASK) >> config.FC_MASK_SHIFT;
    }

    void set_fc_mask(uint64_t value) {
        ccr_value = (ccr_value & ~config.FC_MASK) | ((value << config.FC_MASK_SHIFT) & config.FC_MASK);
    }

    uint64_t get_ccr_value() const { return ccr_value; }

    void set_ccr_value(uint64_t value) { ccr_value = value; }
private:
    uint64_t &ccr_value;
    const ccr_config &config;

    static const ccr_config skx_ccrs;
    static const ccr_config icx_ccrs;
};

struct bdf {
    uint32_t domainno;
    uint8_t busno;
    uint8_t devno;
    uint8_t funcno;

    bdf() : domainno(0), busno(0), devno(0), funcno(0) {}
    bdf(uint32_t domain, uint8_t bus, uint8_t device, uint8_t function) :
        domainno(domain), busno(bus), devno(device), funcno(function) {}
    bdf(uint8_t bus, uint8_t device, uint8_t function) :
        domainno(0), busno(bus), devno(device), funcno(function) {}

    std::string to_string() const
    {
        std::ostringstream oss;
        oss << std::hex << std::uppercase << std::setfill('0')
            << std::setw(DOMAIN_WIDTH) << domainno << ":"
            << std::setw(BUS_WIDTH) << static_cast<int>(busno) << ":"
            << std::setw(DEVICE_WIDTH) << static_cast<int>(devno) << "."
            << std::setw(FUNCTION_WIDTH) << static_cast<int>(funcno);
        return oss.str();
    }

private:
    static const int DOMAIN_WIDTH = 4;
    static const int BUS_WIDTH = 2;
    static const int DEVICE_WIDTH = 2;
    static const int FUNCTION_WIDTH = 1;
};

struct pci {
    bool exist = false;
    struct bdf bdf;
    union {
        struct {
            uint16_t vendor_id;
            uint16_t device_id;
        };
        uint32_t offset_0;
    };
    int8_t header_type;
    union {
        struct {
            uint8_t primary_bus_number;
            uint8_t secondary_bus_number;
            uint8_t subordinate_bus_number;
            uint8_t junk;
        };
        uint32_t offset_18;
    };
    union {
        struct {
            uint16_t link_ctrl;
            union {
                struct {
                    uint16_t link_speed : 4;
                    uint16_t link_width : 6;
                    uint16_t undefined : 1;
                    uint16_t link_trained : 1;
                };
                uint16_t link_sta;
            };
        };
        uint32_t link_info;
    };

    std::vector<uint8_t> parts_no;
    std::vector<struct pci> child_pci_devs;

    pci() : exist(false), offset_0(0), header_type(0),
            offset_18(0), link_info(0), parts_no{},
            child_pci_devs{}
            {}

    pci(uint32_t domain, uint8_t bus, uint8_t device, uint8_t function) :
        exist(false), bdf(domain, bus, device, function), offset_0(0), header_type(0),
        offset_18(0), link_info(0), parts_no{}, child_pci_devs{}
        {}

    pci(uint8_t bus, uint8_t device, uint8_t function) :
        exist(false), bdf(bus, device, function), offset_0(0), header_type(0),
        offset_18(0), link_info(0), parts_no{}, child_pci_devs{}
        {}

    pci(const struct bdf &address) : exist(false), bdf(address), offset_0(0), header_type(0),
        offset_18(0), link_info(0), parts_no{}, child_pci_devs{}
        {}

    bool hasChildDevices() const { return (child_pci_devs.size() != 0); }

    bool isIntelDevice() const { return (vendor_id == PCM_INTEL_PCI_VENDOR_ID); }

    bool isIntelDeviceById(uint16_t device_id) const { return (isIntelDevice() && (this->device_id == device_id)); }
};

struct iio_bifurcated_part {
    int part_id{0};
    /* single device represent root port */
    struct pci root_pci_dev;
    /* Contain child switch and end-point devices */
    std::vector<struct pci> child_pci_devs;
};

struct iio_stack {
    std::vector<struct iio_bifurcated_part> parts{};
    uint32_t iio_unit_id{};
    std::string stack_name{};
    std::vector<uint64_t> values{};
    bool flipped = false;
    /* holding busno for each IIO stack */
    uint32_t domain{};
    uint8_t busno{};

    iio_stack() : iio_unit_id(0), stack_name(""), domain(0), busno(0) {}
};

bool operator<(const iio_stack& lh, const iio_stack& rh);

struct iio_stacks_on_socket {
    std::vector<struct iio_stack> stacks{};
    uint32_t socket_id{};
};

bool operator<(const bdf &l, const bdf &r);

void probe_capability_pci_express(struct pci *p, uint32_t cap_ptr);

bool probe_pci(struct pci *p);

/*
  first : [vendorID] -> vendor name
  second : [vendorID][deviceID] -> device name
 */
typedef std::pair< std::map<int, std::string> ,std::map< int, std::map<int, std::string> > > PCIDB;

void load_PCIDB(PCIDB & pciDB);

} // namespace pcm

#endif

```

`src/memoptest.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev
//

#include "cpucounters.h"
#include <iostream>
#include <algorithm>
#include <list>
#include <vector>
#include <sys/time.h>
#include <emmintrin.h>
#include <assert.h>

using std::cout;

inline double my_timestamp()
{
    struct timeval tp;
    gettimeofday(&tp, NULL);
    return double(tp.tv_sec) + tp.tv_usec / 1000000.;
}

struct T
{
    int key[1] = { 0 };
    int data[3] = { 0, 0, 0 };

    T() { }
    T(int a) { key[0] = a; }

    bool operator == (const T & k) const
    {
        return k.key[0] == key[0];
    }
};


template <class Y>
void write_intensive_task(Y * p, Y * e, int value)
{
    __m128i i = _mm_set_epi32(value, value, value, value);

#if 0
    while (p != e)
    {
        *p = value;
        ++p;
    }
#else
    while (p != e)
    {
        _mm_store_si128((__m128i *)p++, i);
    }
#endif
}

template <class Y>
void stream_write_task(Y * p, Y * e, int value)
{
    __m128i i = _mm_set_epi32(value, value, value, value);

    while (p != e)
    {
        _mm_stream_si128((__m128i *)p++, i);
    }
}

template <class Y>
void read_intensive_task(Y * p, Y * e, int value)
{
    // cppcheck-suppress ignoredReturnValue
    std::find(p, e, -1);
}


int main(int argc, char * argv[])
{
    assert((argc > 1) && "Need operation type as parameter: 0 - read, 1 - write, 2 - streaming write ");
    int op = atoi(argv[1]);
    T * vector;
    int nelements = 1024 * 1024 * 1024 / sizeof(T);
    vector = new T[nelements];

    int i = 0;

    cout << "Elements data size: " << sizeof(T) * nelements / 1024 << " KB\n";

    for ( ; i < nelements; ++i)
    {
        vector[i].key[0] = 10;
    }

    double before_ts, after_ts;


    while (1)
    {
        before_ts = my_timestamp();
        switch (op)
        {
        case 1:
            cout << "Writing memory\n";
            break;
        case 0:
            cout << "Reading memory\n";
            break;
        default:
            cout << "Streaming to memory\n";
        }
        cout << std::flush;

        int niter = 32;
        i = niter;
        int r = rand();
        while (i--)
        {
            switch (op)
            {
            case 1:
                write_intensive_task(vector, vector + nelements, r);
                break;
            case 0:
                read_intensive_task(vector, vector + nelements, r);
                break;
            default:
                stream_write_task(vector, vector + nelements, r);
            }

            after_ts = my_timestamp();
        }
        cout << "Bandwidth: " << (sizeof(T) * nelements * niter) / ((after_ts - before_ts) * 1024 * 1024) << " MByte/sec\n" << std::flush;
    }

    pcm::deleteAndNullifyArray(vector);

    return 0;
}

```

`src/mmio.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev,
//            Patrick Konsor
//

#include <iostream>
#include <string.h>
#ifndef _MSC_VER
#include <sys/types.h>
#endif
#include <sys/stat.h>
#include <fcntl.h>
#include "pci.h"
#include "mmio.h"

#ifndef _MSC_VER
#include <sys/mman.h>
#include <errno.h>
#endif

#ifdef _MSC_VER
#include <windows.h>
#endif

#include "utils.h"
#include <exception>
#include <assert.h>

namespace pcm {

#ifdef _MSC_VER

class PCMPmem : public WinPmem {
protected:
    virtual int load_driver_()
    {
        SYSTEM_INFO sys_info;
        SecureZeroMemory(&sys_info, sizeof(sys_info));

        GetCurrentDirectory(MAX_PATH - 10, driver_filename);

        GetNativeSystemInfo(&sys_info);
        switch (sys_info.wProcessorArchitecture)
        {
        case PROCESSOR_ARCHITECTURE_AMD64:
            _tcscat_s(driver_filename, MAX_PATH, TEXT("\\winpmem_x64.sys"));
            if (GetFileAttributes(driver_filename) == INVALID_FILE_ATTRIBUTES)
            {
                std::cerr << "ERROR: winpmem_x64.sys not found in current directory. Download it from https://github.com/Velocidex/WinPmem/blob/f044f340dd05658d026b0f293cdfa92876159872/kernel/binaries/winpmem_x64.sys .\n";
                std::cerr << "ERROR: Memory bandwidth statistics will not be available.\n";
            }
            break;
        case PROCESSOR_ARCHITECTURE_INTEL:
            _tcscat_s(driver_filename, MAX_PATH, TEXT("\\winpmem_x86.sys"));
            if (GetFileAttributes(driver_filename) == INVALID_FILE_ATTRIBUTES)
            {
                std::cerr << "ERROR: winpmem_x86.sys not found in current directory. Download it from https://github.com/Velocidex/WinPmem/blob/f044f340dd05658d026b0f293cdfa92876159872/kernel/binaries/winpmem_x86.sys .\n";
                std::cerr << "ERROR: Memory bandwidth statistics will not be available.\n";
            }
            break;
        default:
            return -1;
        }
        return 1;
    }
    virtual int write_crashdump_header_(struct PmemMemoryInfo * info)
    {
        return -1;
    }
};

std::shared_ptr<WinPmem> WinPmemMMIORange::pmem;
Mutex WinPmemMMIORange::mutex;
bool WinPmemMMIORange::writeSupported = false;

WinPmemMMIORange::WinPmemMMIORange(uint64 baseAddr_, uint64 /* size_ */, bool readonly_) : startAddr(baseAddr_), readonly(readonly_)
{
    mutex.lock();
    if (pmem.get() == NULL)
    {
        pmem = std::make_shared<PCMPmem>();
        pmem->install_driver(false);
        pmem->set_acquisition_mode(PMEM_MODE_IOSPACE);
        writeSupported = pmem->toggle_write_mode() >= 0; // since it is a global object enable write mode just in case someone needs it
    }
    mutex.unlock();
}

MMIORange::MMIORange(const uint64 baseAddr_, const uint64 size_, const bool readonly_, const bool silent_, const int core) :
    silent(silent_)
{
    auto hDriver = openMSRDriver();
    if (hDriver != INVALID_HANDLE_VALUE)
    {
        DWORD reslength = 0;
        uint64 result = 0;
        const BOOL status = DeviceIoControl(hDriver, IO_CTL_MMAP_SUPPORT, NULL, 0, &result, sizeof(uint64), &reslength, NULL);
        CloseHandle(hDriver);
        if (status == TRUE && reslength == sizeof(uint64) && result == 1)
        {
            impl = std::make_shared<OwnMMIORange>(baseAddr_, size_, readonly_, core);
            return;
        }
        else
        {
            if (!silent)
            {
                std::cerr << "MSR.sys does not support mmap operations\n";
            }
        }
    }
    if (core >= 0)
    {
        throw std::runtime_error("WinPmem does not support core affinity");
    }
    impl = std::make_shared<WinPmemMMIORange>(baseAddr_, size_, readonly_);
}

OwnMMIORange::OwnMMIORange( const uint64 baseAddr_,
                            const uint64 size_,
                            const bool /* readonly_ */,
                            const int core_) :
    core(core_)
{
    hDriver = openMSRDriver();
    MMAP_Request req{};
    uint64 result = 0;
    DWORD reslength = 0;
    req.address.QuadPart = baseAddr_;
    req.size = size_;
    const BOOL status = DeviceIoControl(hDriver, IO_CTL_MMAP, &req, sizeof(MMAP_Request), &result, sizeof(uint64), &reslength, NULL);
    if (status == FALSE || result == 0)
    {
        std::cerr << "Error mapping address 0x" << std::hex << req.address.QuadPart << " with size " << std::dec << req.size << "\n";
        throw std::runtime_error("OwnMMIORange error");
    }
    mmapAddr = (char*)result;
}

uint32 OwnMMIORange::read32(uint64 offset)
{
    CoreAffinityScope _(core);
    return *((uint32*)(mmapAddr + offset));
}

uint64 OwnMMIORange::read64(uint64 offset)
{
    CoreAffinityScope _(core);
    return *((uint64*)(mmapAddr + offset));
}

void OwnMMIORange::write32(uint64 offset, uint32 val)
{
    CoreAffinityScope _(core);
    *((uint32*)(mmapAddr + offset)) = val;
}
void OwnMMIORange::write64(uint64 offset, uint64 val)
{
    CoreAffinityScope _(core);
    *((uint64*)(mmapAddr + offset)) = val;
}

OwnMMIORange::~OwnMMIORange()
{
    MMAP_Request req{};
    uint64 result = 0;
    DWORD reslength = 0;
    req.address.QuadPart = (LONGLONG)mmapAddr;
    req.size = 0;
    DeviceIoControl(hDriver, IO_CTL_MUNMAP, &req, sizeof(MMAP_Request), &result, sizeof(uint64), &reslength, NULL);
    CloseHandle(hDriver);
}

#elif __APPLE__

#include "PCIDriverInterface.h"

MMIORange::MMIORange(const uint64 physical_address, const uint64 size_, const bool, const bool silent_, const int core_) :
    mmapAddr(NULL),
    size(size_),
    silent(silent_),
    core(core_)
{
    if (core_ >= 0)
    {
        throw std::runtime_error("MMIORange on MacOSX does not support core affinity");
    }
    if (size > 4096)
    {
        if (!silent)
        {
            std::cerr << "PCM Error: the driver does not support mapping of regions > 4KB\n";
        }
        return;
    }
    if (physical_address) {
        PCIDriver_mapMemory((uint32_t)physical_address, (uint8_t **)&mmapAddr);
    }
}

uint32 MMIORange::read32(uint64 offset)
{
    warnAlignment<4>("MMIORange::read32", silent, offset);
    uint32 val = 0;
    PCIDriver_readMemory32((uint8_t *)mmapAddr + offset, &val);
    return val;
}

uint64 MMIORange::read64(uint64 offset)
{
    warnAlignment<8>("MMIORange::read64", silent, offset);
    uint64 val = 0;
    PCIDriver_readMemory64((uint8_t *)mmapAddr + offset, &val);
    return val;
}

void MMIORange::write32(uint64 offset, uint32 val)
{
    std::cerr << "PCM Error: the driver does not support writing to MMIORange\n";
}
void MMIORange::write64(uint64 offset, uint64 val)
{
    std::cerr << "PCM Error: the driver does not support writing to MMIORange\n";
}

MMIORange::~MMIORange()
{
    if(mmapAddr) PCIDriver_unmapMemory((uint8_t *)mmapAddr);
}

#elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)

MMIORange::MMIORange(const uint64 baseAddr_, const uint64 size_, const bool readonly_, const bool silent_, const int core_) :
    fd(-1),
    mmapAddr(NULL),
    size(size_),
    readonly(readonly_),
    silent(silent_),
    core(core_)
{
    // SDL330: Use O_NOFOLLOW to reject symlinks
    const int oflag = (readonly ? O_RDONLY : O_RDWR) | O_NOFOLLOW;
    int handle = ::open("/dev/mem", oflag);
    if (handle < 0)
    {
       if (errno == ELOOP) {
           std::cerr << "SDL330 CRITICAL: Symlink detected at /dev/mem\n";
       }
       std::ostringstream strstr;
       strstr << "opening /dev/mem failed: errno is " << errno << " (" << strerror(errno) << ")\n";
       if (!silent)
       {
            std::cerr << strstr.str();
       }
       throw std::runtime_error(strstr.str());
    }
    fd = handle;

    const int prot = readonly ? PROT_READ : (PROT_READ | PROT_WRITE);
    mmapAddr = (char *)mmap(NULL, size, prot, MAP_SHARED, fd, baseAddr_);

    if (mmapAddr == MAP_FAILED)
    {
        std::ostringstream strstr;
        strstr << "mmap failed: errno is " << errno << " (" << strerror(errno) << ")\n";
        if (1 == errno)
        {
            strstr << "Try to add 'iomem=relaxed' parameter to the kernel boot command line and reboot.\n";
        }
        if (!silent)
        {
            std::cerr << strstr.str();
        }
        throw std::runtime_error(strstr.str());
    }
}

uint32 MMIORange::read32(uint64 offset)
{
    warnAlignment<4>("MMIORange::read32", silent, offset);
    CoreAffinityScope _(core);
    return *((uint32 *)(mmapAddr + offset));
}

uint64 MMIORange::read64(uint64 offset)
{
    warnAlignment<8>("MMIORange::read64", silent, offset);
    CoreAffinityScope _(core);
    return *((uint64 *)(mmapAddr + offset));
}

void MMIORange::write32(uint64 offset, uint32 val)
{
    warnAlignment<4>("MMIORange::write32", silent, offset);
    CoreAffinityScope _(core);
    if (readonly)
    {
        std::cerr << "PCM Error: attempting to write to a read-only MMIORange\n";
        return;
    }
    *((uint32 *)(mmapAddr + offset)) = val;
}
void MMIORange::write64(uint64 offset, uint64 val)
{
    warnAlignment<8>("MMIORange::write64", silent, offset);
    CoreAffinityScope _(core);
    if (readonly)
    {
        std::cerr << "PCM Error: attempting to write to a read-only MMIORange\n";
        return;
    }
    *((uint64 *)(mmapAddr + offset)) = val;
}

MMIORange::~MMIORange()
{
    if (mmapAddr) munmap(mmapAddr, size);
    if (fd >= 0) ::close(fd);
}

#endif

void mmio_memcpy(void * dest_, const uint64 src, const size_t n, const bool checkFailures, const bool silent)
{
    assert((src % sizeof(uint32)) == 0);
    assert((n % sizeof(uint32)) == 0);

    const uint64 end = src + n;
    const uint64 mapBegin = roundDownTo4K(src);
    const uint64 mapSize = roundUpTo4K(end) - mapBegin;
    uint32 * dest = (uint32 *)dest_;
    MMIORange range(mapBegin, mapSize, true, silent);

    for (uint64 i = src; i < end; i += sizeof(uint32), ++dest)
    {
        const auto value = range.read32(i - mapBegin);
        if (checkFailures && value == ~uint32(0))
        {
            // a bad read
            std::ostringstream strstr;
            strstr << "Failed to read memory at 0x" << std::hex << i << std::dec << "\n";
            if (!silent)
            {
                std::cerr << strstr.str();
            }
            throw std::runtime_error(strstr.str());
        }
        *dest = value;
    }
}

} // namespace pcm

```

`src/mmio.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2012-2022, Intel Corporation
// written by Roman Dementiev
//            Patrick Konsor
//

#pragma once

/*!     \file mmio.h
        \brief Interface to access memory mapped IO registers

*/

#include "types.h"

#ifdef _MSC_VER
#include "windows.h"
#include "winpmem\winpmem.h"
#include "Winmsrdriver\msrstruct.h"
#else
#include <unistd.h>
#endif

#include "mutex.h"
#include "utils.h"
#include <memory>

namespace pcm {

    class CoreAffinityScope // sets core affinity if core >= 0, nop otherwise
    {
        std::shared_ptr<TemporalThreadAffinity> affinity{nullptr};
        CoreAffinityScope(const CoreAffinityScope&) = delete;
        CoreAffinityScope& operator = (const CoreAffinityScope&) = delete;
    public:
        CoreAffinityScope(const int core)
            : affinity((core >= 0) ? std::make_shared<TemporalThreadAffinity>(core) : nullptr)
        {
        }
    };

#ifdef _MSC_VER

class MMIORangeInterface
{
public:
    virtual uint32 read32(uint64 offset) = 0;
    virtual uint64 read64(uint64 offset) = 0;
    virtual void write32(uint64 offset, uint32 val) = 0;
    virtual void write64(uint64 offset, uint64 val) = 0;
    virtual ~MMIORangeInterface() {}
};

class WinPmemMMIORange : public MMIORangeInterface
{
    static std::shared_ptr<WinPmem> pmem;
    static Mutex mutex;
    static bool writeSupported;
    uint64 startAddr;

    template <class T>
    void writeInternal(uint64 offset, T val)
    {
        if (!writeSupported)
        {
            std::cerr << "PCM Error: MMIORange writes are not supported by the driver\n";
            return;
        }
        if (readonly)
        {
            std::cerr << "PCM Error: attempting to write to a read-only MMIORange\n";
            return;
        }
        mutex.lock();
        pmem->write(startAddr + offset, val);
        mutex.unlock();
    }
    template <class T>
    void readInternal(uint64 offset, T & res)
    {
        mutex.lock();
        pmem->read(startAddr + offset, res);
        mutex.unlock();
    }
    const bool readonly;
public:
    WinPmemMMIORange(uint64 baseAddr_, uint64 size_, bool readonly_ = true);
    uint32 read32(uint64 offset)
    {
        uint32 result = 0;
        readInternal(offset, result);
        return result;
    }
    uint64 read64(uint64 offset)
    {
        uint64 result = 0;
        readInternal(offset, result);
        return result;
    }
    void write32(uint64 offset, uint32 val)
    {
        writeInternal(offset, val);
    }
    void write64(uint64 offset, uint64 val)
    {
        writeInternal(offset, val);
    }
};

class OwnMMIORange : public MMIORangeInterface
{
    HANDLE hDriver;
    char * mmapAddr;
    const int core;
    OwnMMIORange(const OwnMMIORange&) = delete;
    OwnMMIORange& operator = (const OwnMMIORange&) = delete;
public:
    OwnMMIORange(   const uint64 baseAddr_,
                    const uint64 size_,
                    const bool readonly_ = true,
                    const int core_ = -1);
    uint32 read32(uint64 offset);
    uint64 read64(uint64 offset);
    void write32(uint64 offset, uint32 val);
    void write64(uint64 offset, uint64 val);
    ~OwnMMIORange();
};

class MMIORange
{
    std::shared_ptr<MMIORangeInterface> impl;
    const bool silent;
    MMIORange(const MMIORange &) = delete;
    MMIORange & operator = (const MMIORange &) = delete;
public:
    MMIORange(  const uint64 baseAddr_,
                const uint64 size_,
                const bool readonly_ = true,
                const bool silent_ = false,
                const int core = -1);
    uint32 read32(uint64 offset)
    {
        warnAlignment<4>("MMIORange::read32", silent, offset);
        return impl->read32(offset);
    }
    uint64 read64(uint64 offset)
    {
        warnAlignment<8>("MMIORange::read64", silent, offset);
        return impl->read64(offset);
    }
    void write32(uint64 offset, uint32 val)
    {
        warnAlignment<4>("MMIORange::write32", silent, offset);
        impl->write32(offset, val);
    }
    void write64(uint64 offset, uint64 val)
    {
        warnAlignment<8>("MMIORange::write64", silent, offset);
        impl->write64(offset, val);
    }
};

#elif defined(__APPLE__) || defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)

class MMIORange
{
#ifndef __APPLE__
    int32 fd;
#endif
    char * mmapAddr;
    const uint64 size;
#ifndef __APPLE__
    const bool readonly;
#endif
    const bool silent;
    const int core;
    MMIORange(const MMIORange &) = delete;
    MMIORange & operator = (const MMIORange &) = delete;
public:
    MMIORange(  const uint64 baseAddr_,
                const uint64 size_,
                const bool readonly_ = true,
                const bool silent_ = false,
                const int core_ = -1);
    uint32 read32(uint64 offset);
    uint64 read64(uint64 offset);
    void write32(uint64 offset, uint32 val);
    void write64(uint64 offset, uint64 val);
    ~MMIORange();
};
#endif

void mmio_memcpy(void * dest, const uint64 src, const size_t n, const bool checkFailures, const bool silent = false);

} // namespace pcm

```

`src/msr.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev
//            Austen Ott
//            Jim Harris (FreeBSD)

#include <sys/types.h>
#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifndef _MSC_VER
#include <unistd.h>
#endif
#include "types.h"
#include "msr.h"
#include "utils.h"
#include <assert.h>

#ifdef _MSC_VER

#include <windows.h>
#include "utils.h"
#include "Winmsrdriver\msrstruct.h"
#include "winring0/OlsApiInitExt.h"

#endif

#if defined(__FreeBSD__) || defined(__DragonFly__)
#include <sys/ioccom.h>
#include <sys/cpuctl.h>
#endif

#include <mutex>

namespace pcm {

#ifdef _MSC_VER

extern HMODULE hOpenLibSys;

// here comes an implementation for Windows
MsrHandle::MsrHandle(uint32 cpu) : cpu_id(cpu)
{
    hDriver = openMSRDriver();

    if (hDriver == INVALID_HANDLE_VALUE && hOpenLibSys == NULL)
        throw std::exception();
}

MsrHandle::~MsrHandle()
{
    if (hDriver != INVALID_HANDLE_VALUE) CloseHandle(hDriver);
}

int32 MsrHandle::write(uint64 msr_number, uint64 value)
{
    if (hDriver != INVALID_HANDLE_VALUE)
    {
        MSR_Request req;
        ULONG64 result;
        DWORD reslength = 0;
        req.core_id = cpu_id;
        req.msr_address = msr_number;
        req.write_value = value;
        BOOL status = DeviceIoControl(hDriver, IO_CTL_MSR_WRITE, &req, sizeof(MSR_Request), &result, sizeof(uint64), &reslength, NULL);
        assert(status && "Error in DeviceIoControl");
        return status ? sizeof(uint64) : 0;
    }

    cvt_ds cvt;
    cvt.ui64 = value;

    ThreadGroupTempAffinity affinity(cpu_id);
    DWORD status = Wrmsr((DWORD)msr_number, cvt.ui32.low, cvt.ui32.high);

    return status ? sizeof(uint64) : 0;
}

int32 MsrHandle::read(uint64 msr_number, uint64 * value)
{
    if (hDriver != INVALID_HANDLE_VALUE)
    {
        MSR_Request req;
        // ULONG64 result;
        DWORD reslength = 0;
        req.core_id = cpu_id;
        req.msr_address = msr_number;
        BOOL status = DeviceIoControl(hDriver, IO_CTL_MSR_READ, &req, sizeof(MSR_Request), value, sizeof(uint64), &reslength, NULL);
        assert(status && "Error in DeviceIoControl");
        return (int32)reslength;
    }

    cvt_ds cvt;
    cvt.ui64 = 0;

    ThreadGroupTempAffinity affinity(cpu_id);
    DWORD status = Rdmsr((DWORD)msr_number, &(cvt.ui32.low), &(cvt.ui32.high));

    if (status) *value = cvt.ui64;

    return status ? sizeof(uint64) : 0;
}

#elif __APPLE__
// OSX Version

MSRAccessor * MsrHandle::driver = NULL;
int MsrHandle::num_handles = 0;

MsrHandle::MsrHandle(uint32 cpu)
{
    cpu_id = cpu;
    if (!driver)
    {
        driver = new MSRAccessor();
        MsrHandle::num_handles = 1;
    }
    else
    {
        MsrHandle::num_handles++;
    }
}

MsrHandle::~MsrHandle()
{
    MsrHandle::num_handles--;
    if (MsrHandle::num_handles == 0)
    {
        deleteAndNullify(driver);
    }
}

int32 MsrHandle::write(uint64 msr_number, uint64 value)
{
    return driver->write(cpu_id, msr_number, value);
}

int32 MsrHandle::read(uint64 msr_number, uint64 * value)
{
    return driver->read(cpu_id, msr_number, value);
}

int32 MsrHandle::buildTopology(uint32 num_cores, void * ptr)
{
    return driver->buildTopology(num_cores, ptr);
}

uint32 MsrHandle::getNumInstances()
{
    return driver->getNumInstances();
}

uint32 MsrHandle::incrementNumInstances()
{
    return driver->incrementNumInstances();
}

uint32 MsrHandle::decrementNumInstances()
{
    return driver->decrementNumInstances();
}

#elif defined(__FreeBSD__) || defined(__DragonFly__)

MsrHandle::MsrHandle(uint32 cpu) : fd(-1), cpu_id(cpu)
{
    char path[200];
    snprintf(path, 200, "/dev/cpuctl%u", cpu);
    int handle = ::open(path, O_RDWR | O_NOFOLLOW);
    if (handle < 0) {
        if (errno == ELOOP) {
            std::cerr << "SDL330 ERROR: Symlink detected at " << path << "\n";
        }
        throw std::exception();
    }
    fd = handle;
}

MsrHandle::~MsrHandle()
{
    if (fd >= 0) ::close(fd);
}

int32 MsrHandle::write(uint64 msr_number, uint64 value)
{
    cpuctl_msr_args_t args;
    int ret;

    args.msr = msr_number;
    args.data = value;
    ret = ::ioctl(fd, CPUCTL_WRMSR, &args);
    if (ret) return ret;
    return sizeof(value);
}

int32 MsrHandle::read(uint64 msr_number, uint64 * value)
{
    cpuctl_msr_args_t args;
    int32 ret;

    args.msr = msr_number;
    ret = ::ioctl(fd, CPUCTL_RDMSR, &args);
    if (ret) return ret;
    *value = args.data;
    return sizeof(*value);
}

#else
// here comes a Linux version

bool noMSRMode()
{
    static int noMSR = -1;
    if (noMSR < 0)
    {
        noMSR = (safe_getenv("PCM_NO_MSR") == std::string("1")) ? 1 : 0;
    }
    return 1 == noMSR;
}

MsrHandle::MsrHandle(uint32 cpu) : fd(-1), cpu_id(cpu)
{
    if (noMSRMode()) return;
    constexpr auto allowWritesPath = "/sys/module/msr/parameters/allow_writes";
    static bool writesEnabled = false;
    if (writesEnabled == false)
    {
        if (readSysFS(allowWritesPath, true).length() > 0)
        {
            writeSysFS(allowWritesPath, "on", false);
        }
        writesEnabled = true;
    }
    char * path = new char[200];
    if (!path) throw std::runtime_error("Allocation of 200 bytes failed.");
    snprintf(path, 200, "/dev/cpu/%u/msr", cpu);
    int handle = ::open(path, O_RDWR | O_NOFOLLOW);
    if (handle < 0 && errno == ELOOP) {
        std::cerr << "SDL330 ERROR: Symlink detected at MSR device path " << path << "\n";
    }
    if (handle < 0)
    {   // try Android msr device path
        snprintf(path, 200, "/dev/msr%u", cpu);
        handle = ::open(path, O_RDWR | O_NOFOLLOW);
        if (handle < 0 && errno == ELOOP) {
            std::cerr << "SDL330 ERROR: Symlink detected at MSR device path " << path << "\n";
        }
    }
    deleteAndNullifyArray(path);
    if (handle < 0)
    {
         std::cerr << "PCM Error: can't open MSR handle for core " << cpu << " (" << strerror(errno) << ")\n";
         std::cerr << "Try no-MSR mode by setting env variable PCM_NO_MSR=1\n";
         throw std::exception();
    }
    fd = handle;
}

MsrHandle::~MsrHandle()
{
    if (fd >= 0) ::close(fd);
}

int32 MsrHandle::write(uint64 msr_number, uint64 value)
{
#if 0
    static std::mutex m;
    std::lock_guard<std::mutex> g(m);
    std::cout << "DEBUG: writing MSR 0x" << std::hex << msr_number << " value 0x" << value << " on cpu " << std::dec << cpu_id << std::endl;
#endif
    if (fd < 0) return 0;
    DBG(4, "core_id = ", cpu_id, " writing MSR 0x", std::hex, msr_number, " value 0x", value, std::dec);
    return ::pwrite(fd, (const void *)&value, sizeof(uint64), msr_number);
}

int32 MsrHandle::read(uint64 msr_number, uint64 * value)
{
    if (fd < 0) return 0;
    assert(value);
    const auto ret = ::pread(fd, (void *)value, sizeof(uint64), msr_number);
    DBG(4, "core_id = ", cpu_id, " reading MSR 0x", std::hex, msr_number, " value 0x", *value, std::dec);
    return ret;
}

#endif


#ifndef __linux__
bool noMSRMode() { return false; }
#endif

} // namespace pcm

```

`src/msr.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev
//            Austen Ott

#ifndef CPUCounters_MSR_H
#define CPUCounters_MSR_H

/*!     \file msr.h
        \brief Low level interface to access hardware model specific registers

        Implemented and tested for Linux and 64-bit Windows 7
*/

#include "types.h"

#ifdef _MSC_VER
#include "windows.h"
#elif __APPLE__
#include <MSRAccessor.h>
#endif

#include "mutex.h"
#include <memory>

namespace pcm {

bool noMSRMode();

class MsrHandle
{
#ifdef _MSC_VER
    HANDLE hDriver;
#elif __APPLE__
    static MSRAccessor * driver;
    static int num_handles;
#else
    int32 fd;
#endif
    uint32 cpu_id;
    MsrHandle();                                // forbidden
    MsrHandle(const MsrHandle &);               // forbidden
    MsrHandle & operator = (const MsrHandle &); // forbidden

public:
    MsrHandle(uint32 cpu);
    int32 read(uint64 msr_number, uint64 * value);
    int32 write(uint64 msr_number, uint64 value);
    int32 getCoreId() { return (int32)cpu_id; }
#ifdef __APPLE__
    int32 buildTopology(uint32 num_cores, void *);
    uint32 getNumInstances();
    uint32 incrementNumInstances();
    uint32 decrementNumInstances();
#endif
    virtual ~MsrHandle();
};

class SafeMsrHandle
{
    std::shared_ptr<MsrHandle> pHandle;
    Mutex mutex;

    SafeMsrHandle(const SafeMsrHandle &);               // forbidden
    SafeMsrHandle & operator = (const SafeMsrHandle &); // forbidden

public:
    SafeMsrHandle() { }

    SafeMsrHandle(uint32 core_id) : pHandle(new MsrHandle(core_id))
    { }

    int32 read(uint64 msr_number, uint64 * value)
    {
        if (pHandle)
            return pHandle->read(msr_number, value);

        *value = 0;

        return (int32)sizeof(uint64);
    }

    int32 write(uint64 msr_number, uint64 value)
    {
        if (pHandle)
            return pHandle->write(msr_number, value);

        return (int32)sizeof(uint64);
    }

    int32 getCoreId()
    {
        if (pHandle)
            return pHandle->getCoreId();

        throw std::runtime_error("Core is offline");
    }

    void lock()
    {
        mutex.lock();
    }

    void unlock()
    {
        mutex.unlock();
    }

#ifdef __APPLE__
    int32 buildTopology(uint32 num_cores, void * p)
    {
        if (pHandle)
            return pHandle->buildTopology(num_cores, p);

        throw std::exception();
    }
    uint32 getNumInstances()
    {
        if (pHandle)
            return pHandle->getNumInstances();

        throw std::exception();
    }
    uint32 incrementNumInstances()
    {
        if (pHandle)
            return pHandle->incrementNumInstances();

        throw std::exception();
    }
    uint32 decrementNumInstances()
    {
        if (pHandle)
            return pHandle->decrementNumInstances();

        throw std::exception();
    }
#endif
    virtual ~SafeMsrHandle()
    { }
};

} // namespace pcm

#endif

```

`src/msrtest.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev
//            Austen Ott

#include <iostream>
#include <assert.h>
#include <unistd.h>
#include "msr.h"

#define NUM_CORES 16


int main()
{
    uint32 i = 0;
    uint32 res;
    MsrHandle * cpu_msr[NUM_CORES];

    for (i = 0; i < NUM_CORES; ++i)
    {
        cpu_msr[i] = new MsrHandle(i);
        assert(cpu_msr[i]);

        FixedEventControlRegister ctrl_reg;
        res = cpu_msr[i]->read(IA32_CR_FIXED_CTR_CTRL, &ctrl_reg.value);
        assert(res >= 0);

        ctrl_reg.fields.os0 = 1;
        ctrl_reg.fields.usr0 = 1;
        ctrl_reg.fields.any_thread0 = 0;
        ctrl_reg.fields.enable_pmi0 = 0;

        ctrl_reg.fields.os1 = 1;
        ctrl_reg.fields.usr1 = 1;
        ctrl_reg.fields.any_thread1 = 0;
        ctrl_reg.fields.enable_pmi1 = 0;

        ctrl_reg.fields.os2 = 1;
        ctrl_reg.fields.usr2 = 1;
        ctrl_reg.fields.any_thread2 = 0;
        ctrl_reg.fields.enable_pmi2 = 0;

        res = cpu_msr[i]->write(IA32_CR_FIXED_CTR_CTRL, ctrl_reg.value);
        assert(res >= 0);

        // start counting
        uint64 value = (1ULL << 0) + (1ULL << 1) + (1ULL << 2) + (1ULL << 3) + (1ULL << 32) + (1ULL << 33) + (1ULL << 34);
        res = cpu_msr[i]->write(IA32_CR_PERF_GLOBAL_CTRL, value);
        assert(res >= 0);
    }
    uint64 counters_before[NUM_CORES][3];
    uint64 counters_after[NUM_CORES][3];

    for (i = 0; i < NUM_CORES; ++i)
    {
        res = cpu_msr[i]->read(INST_RETIRED_ADDR, &counters_before[i][0]);
        assert(res >= 0);
        res = cpu_msr[i]->read(CPU_CLK_UNHALTED_THREAD_ADDR, &counters_before[i][1]);
        assert(res >= 0);
        res = cpu_msr[i]->read(CPU_CLK_UNHALTED_REF_ADDR, &counters_before[i][2]);
        assert(res >= 0);
    }
    //sleep for some time
    ::sleep(1);
    for (i = 0; i < NUM_CORES; ++i)
    {
        res = cpu_msr[i]->read(INST_RETIRED_ADDR, &counters_after[i][0]);
        assert(res >= 0);
        res = cpu_msr[i]->read(CPU_CLK_UNHALTED_THREAD_ADDR, &counters_after[i][1]);
        assert(res >= 0);
        res = cpu_msr[i]->read(CPU_CLK_UNHALTED_REF_ADDR, &counters_after[i][2]);
        assert(res >= 0);
    }
    for (i = 0; i < NUM_CORES; ++i)
        deleteAndNullify(cpu_msr[i]);
    for (i = 0; i < NUM_CORES; ++i)
        std::cout << "Core " << i <<
            "\t Instructions: " << (counters_after[i][0] - counters_before[i][0]) <<
            "\t Cycles: " << (counters_after[i][1] - counters_before[i][1]) <<
            "\t IPC: " << double(counters_after[i][0] - counters_before[i][0]) / double(counters_after[i][1] - counters_before[i][1]) << "\n";
}

```

`src/mutex.h`:

```h
#ifndef MUTEX_HEADER_
#define MUTEX_HEADER_

#ifdef _MSC_VER
#include <windows.h>
#else
#include <pthread.h>
#endif

#include <stdlib.h>

namespace pcm
{
    class Mutex {
        Mutex(const Mutex&) = delete;
        Mutex& operator = (const Mutex&) = delete;
#ifdef _MSC_VER
        HANDLE mutex_;
#else
        pthread_mutex_t mutex_;
#endif

    public:
        Mutex()
        {
#ifdef _MSC_VER
            mutex_ = CreateMutex(NULL, FALSE, NULL);
#else
            pthread_mutex_init(&mutex_, NULL);
#endif
        }
        virtual ~Mutex()
        {
#ifdef _MSC_VER
            CloseHandle(mutex_);
#else
            if (pthread_mutex_destroy(&mutex_) != 0) std::cerr << "pthread_mutex_destroy failed\n";
#endif
        }

        void lock()
        {
#ifdef _MSC_VER
            WaitForSingleObject(mutex_, INFINITE);
#else
            if (pthread_mutex_lock(&mutex_) != 0) std::cerr << "pthread_mutex_lock failed\n";;
#endif
        }
        void unlock()
        {
#ifdef _MSC_VER
            ReleaseMutex(mutex_);
#else
            if(pthread_mutex_unlock(&mutex_) != 0) std::cerr << "pthread_mutex_unlock failed\n";
#endif
        }

        class Scope {
            Mutex & m;
            Scope() = delete;
            Scope(const Scope &) = delete;
            Scope & operator = (const Scope &) = delete;
        public:
            Scope(Mutex & m_) : m(m_)
            {
                m.lock();
            }
            ~Scope() {
                m.unlock();
            }
        };
    };
}

#endif

```

`src/opCode-6-106.txt`:

```txt
#Clockticks
#ctr=0,unit=iio,ev_sel=0x1,umask=0x0,en=1,ch_mask=0,fc_mask=0x0,multiplier=1,hname=Clockticks,vname=Total
# Inbound (PCIe device DMA into system) payload events
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part0 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part1 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part2 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part3 (4th x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part4 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part5 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part6 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part7 (4th x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part0 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part1 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part2 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part3 (4th x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part4 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part5 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part6 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part7 (4th x4)
# Outbound (CPU MMIO to the PCIe device) payload events
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part0 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part1 (2nd x4)
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part2 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part3 (4th x4)
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part4 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part5 (2nd x4)
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part6 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part7 (4th x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part0 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part1 (2nd x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part2 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part3 (4th x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part4 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part5 (2nd x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part6 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part7 (4th x4)
# IOMMU events
ctr=0,unit=iio,ev_sel=0x40,umask=0x01,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Lookup,vname=Total
ctr=1,unit=iio,ev_sel=0x40,umask=0x20,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Miss,vname=Total
ctr=2,unit=iio,ev_sel=0x40,umask=0x80,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=Ctxt Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0x10,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=512G Cache Hit,vname=Total
ctr=0,unit=iio,ev_sel=0x41,umask=0x08,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=1G Cache Hit,vname=Total
ctr=1,unit=iio,ev_sel=0x41,umask=0x04,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=2M Cache Hit,vname=Total
ctr=2,unit=iio,ev_sel=0x41,umask=0x02,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=4K Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0x40,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOMMU Mem Access,vname=Total

```

`src/opCode-6-108.txt`:

```txt
#Clockticks
#ctr=0,unit=iio,ev_sel=0x1,umask=0x0,en=1,ch_mask=0,fc_mask=0x0,multiplier=1,hname=Clockticks,vname=Total
# Inbound (PCIe device DMA into system) payload events
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part0 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part1 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part2 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part3 (4th x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part4 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part5 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part6 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part7 (4th x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part0 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part1 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part2 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part3 (4th x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part4 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part5 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part6 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part7 (4th x4)
# Outbound (CPU MMIO to the PCIe device) payload events
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part0 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part1 (2nd x4)
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part2 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part3 (4th x4)
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part4 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part5 (2nd x4)
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part6 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part7 (4th x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part0 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part1 (2nd x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part2 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part3 (4th x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part4 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part5 (2nd x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part6 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part7 (4th x4)
# IOMMU events
ctr=0,unit=iio,ev_sel=0x40,umask=0x01,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Lookup,vname=Total
ctr=1,unit=iio,ev_sel=0x40,umask=0x20,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Miss,vname=Total
ctr=2,unit=iio,ev_sel=0x40,umask=0x80,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=Ctxt Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0x10,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=512G Cache Hit,vname=Total
ctr=0,unit=iio,ev_sel=0x41,umask=0x08,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=1G Cache Hit,vname=Total
ctr=1,unit=iio,ev_sel=0x41,umask=0x04,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=2M Cache Hit,vname=Total
ctr=2,unit=iio,ev_sel=0x41,umask=0x02,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=4K Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0x40,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOMMU Mem Access,vname=Total

```

`src/opCode-6-134.txt`:

```txt
#Clockticks
#ctr=0,unit=iio,ev_sel=0x1,umask=0x0,en=1,ch_mask=0,fc_mask=0x0,multiplier=1,hname=Clockticks,vname=Total
# Inbound (PCIe device DMA into system) payload events
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part0 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part1 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part2 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part3 (4th x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part4 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part5 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part6 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part7 (4th x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part0 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part1 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part2 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part3 (4th x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part4 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part5 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part6 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part7 (4th x4)
# Outbound (CPU MMIO to the PCIe device) payload events
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part0 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part1 (2nd x4)
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part2 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part3 (4th x4)
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part4 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part5 (2nd x4)
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part6 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,en=1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part7 (4th x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part0 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part1 (2nd x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part2 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part3 (4th x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part4 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part5 (2nd x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part6 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part7 (4th x4)
# IOMMU events
ctr=0,unit=iio,ev_sel=0x40,umask=0x01,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Lookup,vname=Total
ctr=1,unit=iio,ev_sel=0x40,umask=0x20,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Miss,vname=Total
ctr=2,unit=iio,ev_sel=0x40,umask=0x80,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=Ctxt Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0x10,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=512G Cache Hit,vname=Total
ctr=0,unit=iio,ev_sel=0x41,umask=0x08,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=1G Cache Hit,vname=Total
ctr=1,unit=iio,ev_sel=0x41,umask=0x04,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=2M Cache Hit,vname=Total
ctr=2,unit=iio,ev_sel=0x41,umask=0x02,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=4K Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0x40,en=1,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOMMU Mem Access,vname=Total
```

`src/opCode-6-143-accel.txt`:

```txt
# IAA events
ctr=0,ev_sel=0x1,ev_cat=0x1,en=1,multiplier=32,divider=1,hname=IAA,vname=Inbound_BW(Bps)
ctr=1,ev_sel=0x2,ev_cat=0x1,en=1,multiplier=512,divider=1,hname=IAA,vname=Outbound_BW(Bps)
ctr=2,ev_sel=0x5,ev_cat=0x0,en=1,multiplier=1,divider=1,hname=IAA,vname=ShareWQ_ReqNb
ctr=3,ev_sel=0x10,ev_cat=0x0,en=1,multiplier=1,divider=1,hname=IAA,vname=DedicateWQ_ReqNb

# DSA events
ctr=0,ev_sel=0x1,ev_cat=0x1,en=1,multiplier=32,divider=1,hname=DSA,vname=Inbound_BW(Bps)
ctr=1,ev_sel=0x2,ev_cat=0x1,en=1,multiplier=32,divider=1,hname=DSA,vname=Outbound_BW(Bps)
ctr=2,ev_sel=0x5,ev_cat=0x0,en=1,multiplier=1,divider=1,hname=DSA,vname=ShareWQ_ReqNb
ctr=3,ev_sel=0x10,ev_cat=0x0,en=1,multiplier=1,divider=1,hname=DSA,vname=DedicateWQ_ReqNb

# QAT events
ctr=0,ev_sel=0x6,ev_cat=0x1,en=1,multiplier=1048576,divider=1,hname=QAT,vname=Inbound_BW(Bps)
ctr=1,ev_sel=0x7,ev_cat=0x1,en=1,multiplier=1048576,divider=1,hname=QAT,vname=Outbound_BW(Bps)
ctr=2,ev_sel=0xB,ev_cat=0x1,en=1,multiplier=1,divider=1,hname=QAT,vname=util_comp0(%)
ctr=3,ev_sel=0xC,ev_cat=0x1,en=1,multiplier=1,divider=1,hname=QAT,vname=util_decomp0(%)
ctr=4,ev_sel=0xD,ev_cat=0x1,en=1,multiplier=1,divider=1,hname=QAT,vname=util_decomp1(%)
ctr=5,ev_sel=0xE,ev_cat=0x1,en=1,multiplier=1,divider=1,hname=QAT,vname=util_decomp2(%)
ctr=6,ev_sel=0xF,ev_cat=0x1,en=1,multiplier=1,divider=1,hname=QAT,vname=util_xlt0(%)

```

`src/opCode-6-143.txt`:

```txt
#Clockticks
#ctr=0,unit=iio,ev_sel=0x1,umask=0x0,en=1,ch_mask=0,fc_mask=0x0,multiplier=1,hname=Clockticks,vname=Total
# Inbound (PCIe device DMA into system) payload events
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part0
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part1
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part2
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part3
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part4
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part5
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part6
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part7
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part0
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part1
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part2
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part3
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part4
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part5
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part6
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part7
# Outbound (CPU MMIO to the PCIe device) payload events
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part0
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part1
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part2
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part3
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part4
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part5
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part6
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part7
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part0
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part1
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part2
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part3
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part4
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part5
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part6
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part7
# IOMMU events
ctr=0,unit=iio,ev_sel=0x40,umask=0x01,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Lookup,vname=Total
ctr=1,unit=iio,ev_sel=0x40,umask=0x20,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Miss,vname=Total
ctr=2,unit=iio,ev_sel=0x40,umask=0x80,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=Ctxt Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0x10,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=256T Cache Hit,vname=Total
ctr=0,unit=iio,ev_sel=0x41,umask=0x08,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=512G Cache Hit,vname=Total
ctr=1,unit=iio,ev_sel=0x41,umask=0x04,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=1G Cache Hit,vname=Total
ctr=2,unit=iio,ev_sel=0x41,umask=0x02,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=2M Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0xc0,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOMMU Mem Access,vname=Total

```

`src/opCode-6-173.txt`:

```txt
#Clockticks
#ctr=0,unit=iio,ev_sel=0x1,umask=0x0,en=1,ch_mask=0,fc_mask=0x0,multiplier=1,hname=Clockticks,vname=Total
# Inbound (PCIe device DMA into system) payload events
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part0
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part1
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part2
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part3
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part4
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part5
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part6
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part7
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part0
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part1
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part2
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part3
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part4
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part5
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part6
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part7
# Outbound (CPU MMIO to the PCIe device) payload events
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part0
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part1
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part2
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part3
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part4
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part5
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part6
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part7
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part0
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part1
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part2
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part3
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part4
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part5
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part6
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part7
# IOMMU events
ctr=0,unit=iio,ev_sel=0x40,umask=0x01,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Lookup,vname=Total
ctr=1,unit=iio,ev_sel=0x40,umask=0x20,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Miss,vname=Total
ctr=2,unit=iio,ev_sel=0x40,umask=0x80,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=Ctxt Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0x10,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=256T Cache Hit,vname=Total
ctr=0,unit=iio,ev_sel=0x41,umask=0x08,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=512G Cache Hit,vname=Total
ctr=1,unit=iio,ev_sel=0x41,umask=0x04,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=1G Cache Hit,vname=Total
ctr=2,unit=iio,ev_sel=0x41,umask=0x02,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=2M Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0xc0,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOMMU Mem Access,vname=Total

```

`src/opCode-6-174.txt`:

```txt
#Clockticks
#ctr=0,unit=iio,ev_sel=0x1,umask=0x0,en=1,ch_mask=0,fc_mask=0x0,multiplier=1,hname=Clockticks,vname=Total
# Inbound (PCIe device DMA into system) payload events
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part0
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part1
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part2
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part3
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part4
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part5
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part6
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part7
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part0
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part1
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part2
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part3
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part4
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part5
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part6
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part7
# Outbound (CPU MMIO to the PCIe device) payload events
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part0
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part1
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part2
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part3
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part4
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part5
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part6
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part7
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part0
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part1
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part2
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part3
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part4
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part5
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part6
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part7
# IOMMU events
ctr=0,unit=iio,ev_sel=0x40,umask=0x01,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Lookup,vname=Total
ctr=1,unit=iio,ev_sel=0x40,umask=0x20,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Miss,vname=Total
ctr=2,unit=iio,ev_sel=0x40,umask=0x80,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=Ctxt Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0x10,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=256T Cache Hit,vname=Total
ctr=0,unit=iio,ev_sel=0x41,umask=0x08,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=512G Cache Hit,vname=Total
ctr=1,unit=iio,ev_sel=0x41,umask=0x04,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=1G Cache Hit,vname=Total
ctr=2,unit=iio,ev_sel=0x41,umask=0x02,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=2M Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0xc0,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOMMU Mem Access,vname=Total

```

`src/opCode-6-175.txt`:

```txt
#Clockticks
#ctr=0,unit=iio,ev_sel=0x1,umask=0x0,en=1,ch_mask=0,fc_mask=0x0,multiplier=1,hname=Clockticks,vname=Total
# Inbound (PCIe device DMA into system) payload events
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part0
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part1
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part2
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part3
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part4
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part5
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part6
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part7
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part0
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part1
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part2
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part3
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part4
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part5
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part6
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part7
# Outbound (CPU MMIO to the PCIe device) payload events
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part0
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part1
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part2
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part3
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part4
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part5
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part6
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part7
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part0
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part1
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part2
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part3
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part4
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part5
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part6
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part7
# IOMMU events
ctr=0,unit=iio,ev_sel=0x40,umask=0x01,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Lookup,vname=Total
ctr=1,unit=iio,ev_sel=0x40,umask=0x20,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Miss,vname=Total
ctr=2,unit=iio,ev_sel=0x40,umask=0x80,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=Ctxt Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0x10,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=256T Cache Hit,vname=Total
ctr=0,unit=iio,ev_sel=0x41,umask=0x08,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=512G Cache Hit,vname=Total
ctr=1,unit=iio,ev_sel=0x41,umask=0x04,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=1G Cache Hit,vname=Total
ctr=2,unit=iio,ev_sel=0x41,umask=0x02,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=2M Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0xc0,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOMMU Mem Access,vname=Total

```

`src/opCode-6-182.txt`:

```txt
#Clockticks
#ctr=0,unit=iio,ev_sel=0x1,umask=0x0,en=1,ch_mask=0,fc_mask=0x0,multiplier=1,hname=Clockticks,vname=Total
# Inbound (PCIe device DMA into system) payload events
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part0
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part1
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part2
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part3
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part4
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part5
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part6
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part7
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part0
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part1
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part2
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part3
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part4
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part5
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part6
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part7
# Outbound (CPU MMIO to the PCIe device) payload events
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part0
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part1
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part2
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part3
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part4
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part5
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part6
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part7
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part0
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part1
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part2
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part3
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part4
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part5
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part6
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part7
# IOMMU events
ctr=0,unit=iio,ev_sel=0x40,umask=0x01,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Lookup,vname=Total
ctr=1,unit=iio,ev_sel=0x40,umask=0x20,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Miss,vname=Total
ctr=2,unit=iio,ev_sel=0x40,umask=0x80,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=Ctxt Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0x10,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=256T Cache Hit,vname=Total
ctr=0,unit=iio,ev_sel=0x41,umask=0x08,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=512G Cache Hit,vname=Total
ctr=1,unit=iio,ev_sel=0x41,umask=0x04,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=1G Cache Hit,vname=Total
ctr=2,unit=iio,ev_sel=0x41,umask=0x02,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=2M Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0xc0,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOMMU Mem Access,vname=Total

```

`src/opCode-6-207.txt`:

```txt
#Clockticks
#ctr=0,unit=iio,ev_sel=0x1,umask=0x0,en=1,ch_mask=0,fc_mask=0x0,multiplier=1,hname=Clockticks,vname=Total
# Inbound (PCIe device DMA into system) payload events
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part0
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part1
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part2
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part3
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part4
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part5
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part6
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB write,vname=Part7
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part0
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part1
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part2
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part3
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=16,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part4
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=32,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part5
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=64,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part6
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,ch_mask=128,fc_mask=0x7,multiplier=4,hname=IB read,vname=Part7
# Outbound (CPU MMIO to the PCIe device) payload events
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part0
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part1
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part2
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part3
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part4
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part5
ctr=2,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part6
ctr=3,unit=iio,ev_sel=0x83,umask=0x80,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB read,vname=Part7
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part0
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part1
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part2
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part3
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=16,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part4
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=32,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part5
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=64,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part6
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,ch_mask=128,fc_mask=0x7,multiplier=4,hname=OB write,vname=Part7
# IOMMU events
ctr=0,unit=iio,ev_sel=0x40,umask=0x01,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Lookup,vname=Total
ctr=1,unit=iio,ev_sel=0x40,umask=0x20,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOTLB Miss,vname=Total
ctr=2,unit=iio,ev_sel=0x40,umask=0x80,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=Ctxt Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0x10,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=256T Cache Hit,vname=Total
ctr=0,unit=iio,ev_sel=0x41,umask=0x08,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=512G Cache Hit,vname=Total
ctr=1,unit=iio,ev_sel=0x41,umask=0x04,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=1G Cache Hit,vname=Total
ctr=2,unit=iio,ev_sel=0x41,umask=0x02,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=2M Cache Hit,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0xc0,ch_mask=0x0,fc_mask=0x0,multiplier=1,hname=IOMMU Mem Access,vname=Total

```

`src/opCode-6-85.txt`:

```txt
# Inbound (PCIe device DMA into system) payload events
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB write (bytes),vname=Part0 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB write (bytes),vname=Part1 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB write (bytes),vname=Part2 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x1,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB write (bytes),vname=Part3 (4th x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=IB read (bytes),vname=Part0 (1st x16/x8/x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=IB read (bytes),vname=Part1 (2nd x4)
ctr=0,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=IB read (bytes),vname=Part2 (2nd x8/3rd x4)
ctr=1,unit=iio,ev_sel=0x83,umask=0x4,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=IB read (bytes),vname=Part3 (4th x4)
# Outbound (CPU MMIO to the PCIe device) payload events
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB read (bytes),vname=Part0 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB read (bytes),vname=Part1 (2nd x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x4,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB read (bytes),vname=Part2 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x4,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB read (bytes),vname=Part3 (4th x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=1,fc_mask=0x7,multiplier=4,hname=OB write (bytes),vname=Part0 (1st x16/x8/x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=2,fc_mask=0x7,multiplier=4,hname=OB write (bytes),vname=Part1 (2nd x4)
ctr=2,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=4,fc_mask=0x7,multiplier=4,hname=OB write (bytes),vname=Part2 (2nd x8/3rd x4)
ctr=3,unit=iio,ev_sel=0xc0,umask=0x1,en=1,ch_mask=8,fc_mask=0x7,multiplier=4,hname=OB write (bytes),vname=Part3 (4th x4)
# VTd events
ctr=0,unit=iio,ev_sel=0x41,umask=0x1,en=1,ch_mask=1,fc_mask=0x7,multiplier=1,hname=IOTLB Hit,vname=Total
ctr=1,unit=iio,ev_sel=0x41,umask=0x20,en=1,ch_mask=1,fc_mask=0x7,multiplier=1,hname=IOTLB Miss,vname=Total
ctr=2,unit=iio,ev_sel=0x41,umask=0x02,en=1,ch_mask=4,fc_mask=0x7,multiplier=1,hname=VT-d CTXT Miss,vname=Total
ctr=3,unit=iio,ev_sel=0x41,umask=0x04,en=1,ch_mask=4,fc_mask=0x7,multiplier=1,hname=VT-d L1 Miss,vname=Total
ctr=0,unit=iio,ev_sel=0x41,umask=0x08,en=1,ch_mask=4,fc_mask=0x7,multiplier=1,hname=VT-d L2 Miss,vname=Total
ctr=1,unit=iio,ev_sel=0x41,umask=0x10,en=1,ch_mask=1,fc_mask=0x7,multiplier=1,hname=VT-d L3 Miss,vname=Total
ctr=2,unit=iio,ev_sel=0x84,umask=0x04,en=1,ch_mask=0x10,fc_mask=0x7,multiplier=1,hname=VT-d Mem Read,vname=Total

```

`src/pci.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev,
//            Pat Fay
//	      Austen Ott
//            Jim Harris (FreeBSD)

#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <stdexcept>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <cstring>
#include <vector>
#include <unordered_map>
#include <mutex>
#include "pci.h"
#include "cpucounters.h"

#ifndef _MSC_VER
#include <sys/mman.h>
#include <errno.h>
#include <strings.h>
#endif

#ifdef _MSC_VER

#include <windows.h>
#include "Winmsrdriver\msrstruct.h"
#include "winring0/OlsDef.h"
#include "winring0/OlsApiInitExt.h"
#endif

#include "utils.h"

#if defined (__FreeBSD__) || defined(__DragonFly__)
#include <sys/pciio.h>
#include <sys/sysctl.h>
#endif

namespace pcm {

#ifdef _MSC_VER

void readSRATTable(std::unordered_map<uint64_t, uint32_t>& pciToNuma);

extern HMODULE hOpenLibSys;

static char * nonZeroGroupErrMsg = "Non-zero PCI group segments are not supported in Winring0 driver, make sure MSR.sys driver can be used.";

// Helper function to compute NUMA node for Windows
static int32 getNUMANodeWindows(uint32 groupnr, uint32 actual_bus, uint32 device, uint32 function)
{
    // Windows implementation: read SRAT ACPI table to map PCI devices to NUMA nodes
    static std::unordered_map<uint64_t, uint32_t> pciToNuma;
    static std::mutex initMutex;
    static bool initialized = false;
    
    // Thread-safe initialization using double-checked locking
    // cppcheck-suppress identicalInnerCondition
    if (!initialized)
    {
        std::lock_guard<std::mutex> lock(initMutex);
        // cppcheck-suppress identicalInnerCondition
        if (!initialized)
        {
            readSRATTable(pciToNuma);
            initialized = true;
        }
    }
    
    // Construct key matching SRAT format: segment(16) | bus(8) | device(5) | function(3)
    uint64_t key = ((uint64_t)groupnr << 16) | ((uint64_t)actual_bus << 8) | 
                  ((uint64_t)device << 3) | function;
    
    auto it = pciToNuma.find(key);
    if (it != pciToNuma.end())
    {
        DBG(3, "Found NUMA node ", it->second, " for PCI device ", std::hex, 
            groupnr, ":", actual_bus, ":", device, ".", function, std::dec);
        return (int32)it->second;
    }
    
    DBG(2, "No NUMA affinity found in SRAT for PCI device ", std::hex, 
        groupnr, ":", actual_bus, ":", device, ".", function, std::dec);
    return -1;
}

PciHandle::PciHandle(uint32 groupnr_, uint32 bus_, uint32 device_, uint32 function_) :
    hDriver(openMSRDriver()),
    bus((groupnr_ << 8) | bus_),
    device(device_),
    function(function_),
    pciAddress(PciBusDevFunc(bus_, device_, function_)),
    numaNode(-1)
{
    DBG(3, "Creating PCI Config space handle at g:b:d:f ", groupnr_, ":", bus_, ":", device_, ":", function_);
    if (groupnr_ != 0 && hDriver == INVALID_HANDLE_VALUE)
    {
        std::cerr << nonZeroGroupErrMsg << '\n';
        throw std::runtime_error(nonZeroGroupErrMsg);
    }

    if (hDriver == INVALID_HANDLE_VALUE && hOpenLibSys == NULL)
    {
        throw std::runtime_error("MSR and Winring0 drivers can't be opened");
    }
    
    // Initialize NUMA node during construction
    const uint32 groupnr = (bus >> 8);
    const uint32 actual_bus = bus & 0xFF;
    numaNode = getNUMANodeWindows(groupnr, actual_bus, device, function);
}

int32 PciHandle::getNUMANode() const
{
    return numaNode;
}

bool PciHandle::exists(uint32 groupnr_, uint32 bus_, uint32 device_, uint32 function_)
{
    DBG(3, "Checking PCI Config space at g:b:d:f ", groupnr_, ":", bus_, ":", device_, ":", function_);
    HANDLE tempHandle = openMSRDriver();
    if (tempHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(tempHandle);

        PciHandle tempHandle(groupnr_, bus_, device_, function_);
        uint32 value = 0;
        return tempHandle.read32(0, &value) == sizeof(uint32);
    }

    if (groupnr_ != 0)
    {
        std::cerr << nonZeroGroupErrMsg << '\n';
        return false;
    }

    if (hOpenLibSys != NULL)
    {
        DWORD addr(PciBusDevFunc(bus_, device_, function_));
        DWORD result = 0;
        return ReadPciConfigDwordEx(addr, 0, &result)?true:false;
    }

    return false;
}

int32 PciHandle::read32(uint64 offset, uint32 * value)
{
    warnAlignment<4>("PciHandle::read32", false, offset);
    if (hDriver != INVALID_HANDLE_VALUE)
    {
        PCICFG_Request req;
        ULONG64 result = 0;
        DWORD reslength = 0;
        req.bus = (ULONG)bus;
        req.dev = (ULONG)device;
        req.func = (ULONG)function;
        req.bytes = sizeof(uint32);
        req.reg = (ULONG)offset;

        BOOL status = DeviceIoControl(hDriver, IO_CTL_PCICFG_READ, &req, (DWORD)sizeof(PCICFG_Request), &result, (DWORD)sizeof(uint64), &reslength, NULL);
        *value = (uint32)result;
        if (!status)
        {
            DBG(3, "Error reading PCI Config space at bus ", bus, " dev ", device , " function ", function ," offset ",  offset , " size ", req.bytes  , ". Windows error: ", GetLastError());
        }
        return (int32)reslength;
    }
    DWORD result = 0;
    if (ReadPciConfigDwordEx(pciAddress, (DWORD)offset, &result))
    {
        *value = result;
        return (int32)sizeof(uint32);
    }
    return 0;
}

int32 PciHandle::write32(uint64 offset, uint32 value)
{
    warnAlignment<4>("PciHandle::write32", false, offset);
    if (hDriver != INVALID_HANDLE_VALUE)
    {
        PCICFG_Request req;
        ULONG64 result;
        DWORD reslength = 0;
        req.bus = bus;
        req.dev = device;
        req.func = function;
        req.bytes = sizeof(uint32);
        req.reg = (uint32)offset;
        req.write_value = value;

        BOOL status = DeviceIoControl(hDriver, IO_CTL_PCICFG_WRITE, &req, (DWORD)sizeof(PCICFG_Request), &result, (DWORD)sizeof(uint64), &reslength, NULL);
        if (!status)
        {
            DBG(3, "Error writing PCI Config space at bus " , bus, " dev ", device, " function ", function ," offset ", offset , " size ",  req.bytes  , ". Windows error: ", GetLastError());
            return 0;
        }
        return (int32)sizeof(uint32);
    }

    return (WritePciConfigDwordEx(pciAddress, (DWORD)offset, value)) ? sizeof(uint32) : 0;
}

int32 PciHandle::read64(uint64 offset, uint64 * value)
{
    warnAlignment<4>("PciHandle::read64", false, offset);
    if (hDriver != INVALID_HANDLE_VALUE)
    {
        if (offset & 7)
        {
            // this driver supports only 8-byte aligned reads
            // use read32 for unaligned reads
            uint32* value32Ptr = (uint32*)value;
            return read32(offset, value32Ptr) + read32(offset + sizeof(uint32), value32Ptr + 1);
        }
        PCICFG_Request req;
        DWORD reslength = 0;
        req.bus = bus;
        req.dev = device;
        req.func = function;
        req.bytes = sizeof(uint64);
        req.reg = (uint32)offset;

        BOOL status = DeviceIoControl(hDriver, IO_CTL_PCICFG_READ, &req, (DWORD)sizeof(PCICFG_Request), value, (DWORD)sizeof(uint64), &reslength, NULL);
        if (!status)
        {
            DBG(3, "Error reading PCI Config space at bus ", bus, " dev ", device, " function ", function ," offset ", offset , " size ", req.bytes  , ". Windows error: ", GetLastError());
        }
        return (int32)reslength;
    }

    cvt_ds cvt;
    cvt.ui64 = 0;

    BOOL status = ReadPciConfigDwordEx(pciAddress, (DWORD)offset, &(cvt.ui32.low));
    status &= ReadPciConfigDwordEx(pciAddress, ((DWORD)offset) + sizeof(uint32), &(cvt.ui32.high));

    if (status)
    {
        *value = cvt.ui64;
        return (int32)sizeof(uint64);
    }
    return 0;
}

PciHandle::~PciHandle()
{
    if (hDriver != INVALID_HANDLE_VALUE) CloseHandle(hDriver);
}

// Windows implementation to read MCFG table from ACPI firmware
int PciHandle::openMcfgTable() {
    // On Windows, ACPI tables are accessed via GetSystemFirmwareTable API
    // rather than through file system. This function returns -1 to indicate
    // the file-based approach is not available on Windows.
    // See PciHandle::readMCFGRecords() for the Windows implementation.
    return -1;
}

// Windows implementation to read MCFG ACPI table using Firmware Table API or physical memory
void PciHandle::readMCFGRecords(std::vector<MCFGRecord>& mcfg)
{
    mcfg.clear();
    
    // Signature for ACPI firmware tables
    const DWORD acpiSignature = 'ACPI';
    // MCFG table signature (note: stored in reverse byte order in ACPI tables)
    const DWORD mcfgSignature = 'GFCM'; // 'MCFG' in reverse
    
    // Try to get the MCFG table size first
    UINT tableSize = GetSystemFirmwareTable(acpiSignature, mcfgSignature, nullptr, 0);
    
    if (tableSize == 0)
    {
        DWORD error = GetLastError();
        DBG(1, "GetSystemFirmwareTable failed to get MCFG table size. Error: ", error);
        
        // Fallback: use default segments for known platforms
        MCFGRecord segment;
        segment.startBusNumber = 0;
        segment.endBusNumber = 0xff;
        segment.baseAddress = 0; // Actual base address is platform-specific and not available without MCFG table
        
        auto maxSegments = 1;
        switch (PCM::getCPUFamilyModelFromCPUID())
        {
        case PCM::SPR:
        case PCM::GNR:
            maxSegments = 4;
            break;
        }
        
        for (segment.PCISegmentGroupNumber = 0; segment.PCISegmentGroupNumber < maxSegments; ++(segment.PCISegmentGroupNumber))
        {
            mcfg.push_back(segment);
        }
        
        std::cerr << "PCM Warning: Could not read MCFG table from firmware, using default segments\n";
        return;
    }
    
    // Allocate buffer for the MCFG table
    std::vector<BYTE> tableBuffer(tableSize);
    
    // Read the actual table
    UINT bytesRead = GetSystemFirmwareTable(acpiSignature, mcfgSignature, tableBuffer.data(), tableSize);
    
    if (bytesRead == 0 || bytesRead != tableSize)
    {
        std::cerr << "PCM Error: Failed to read MCFG table from firmware\n";
        return;
    }
    
    // Parse the MCFG table
    // The table format is: ACPI header (variable) + MCFG records
    if (tableSize < sizeof(MCFGHeader))
    {
        std::cerr << "PCM Error: MCFG table too small\n";
        return;
    }
    
    // Use memcpy to avoid potential alignment issues
    MCFGHeader header;
    std::memcpy(&header, tableBuffer.data(), sizeof(MCFGHeader));
    
    DBG(1, "MCFG table signature: \"",
        header.signature[0], header.signature[1],
        header.signature[2], header.signature[3],
        "\" MCFG table length: ", header.length,
        " Number of MCFG records: ", header.nrecords());
    
    // Verify signature
    if (std::strncmp(header.signature, "MCFG", 4) != 0)
    {
        std::cerr << "PCM Error: Invalid MCFG table signature\n";
        return;
    }
    
    // Validate header length to prevent integer underflow in nrecords()
    if (header.length < sizeof(MCFGHeader))
    {
        std::cerr << "PCM Error: Invalid MCFG table length (too small)\n";
        return;
    }
    
    // Validate that the reported length matches the actual table size
    if (header.length > tableSize)
    {
        std::cerr << "PCM Error: MCFG table length mismatch\n";
        return;
    }
    
    // Read MCFG records
    const unsigned segments = header.nrecords();
    const BYTE* recordPtr = tableBuffer.data() + sizeof(MCFGHeader);
    
    for (unsigned int i = 0; i < segments; ++i)
    {
        if (recordPtr + sizeof(MCFGRecord) > tableBuffer.data() + tableSize)
        {
            std::cerr << "PCM Error: MCFG record out of bounds\n";
            break;
        }
        
        MCFGRecord record;
        std::memcpy(&record, recordPtr, sizeof(MCFGRecord));
        
        DBG(1, "MCFG segment " , i , ": ",
               "BaseAddress=0x" , std::hex , record.baseAddress,
               " PCISegmentGroupNumber=0x" , record.PCISegmentGroupNumber,
               " startBusNumber=0x" , (unsigned)record.startBusNumber,
               " endBusNumber=0x" , (unsigned)record.endBusNumber,
               std::dec);
        
        mcfg.push_back(record);
        recordPtr += sizeof(MCFGRecord);
    }
}

// Windows implementation to read SRAT ACPI table and build PCI device to NUMA node mapping
static void readSRATTable(std::unordered_map<uint64_t, uint32_t>& pciToNuma)
{
    pciToNuma.clear();
    
    const DWORD acpiSignature = 'ACPI';
    // SRAT table signature (note: stored in reverse byte order in ACPI tables)
    const DWORD sratSignature = 'TARS'; // 'SRAT' in reverse
    
    // Try to get the SRAT table size first
    UINT tableSize = GetSystemFirmwareTable(acpiSignature, sratSignature, nullptr, 0);
    
    if (tableSize == 0)
    {
        DBG(1, "SRAT table not available, NUMA node information will not be available");
        return;
    }
    
    // Allocate buffer for the SRAT table
    std::vector<BYTE> tableBuffer(tableSize);
    
    // Read the actual table
    UINT bytesRead = GetSystemFirmwareTable(acpiSignature, sratSignature, tableBuffer.data(), tableSize);
    
    if (bytesRead == 0 || bytesRead != tableSize)
    {
        DBG(1, "Failed to read SRAT table from firmware");
        return;
    }
    
    // SRAT table structure:
    // - ACPI header (36 bytes): Signature(4) + Length(4) + Revision(1) + Checksum(1) + OEMID(6) + 
    //                           OEM Table ID(8) + OEM Revision(4) + Creator ID(4) + Creator Revision(4)
    // - Reserved(4) + Reserved(8)
    // - Followed by variable-length subtable structures
    
    if (tableSize < 36)
    {
        DBG(1, "SRAT table too small");
        return;
    }
    
    // Verify signature
    if (std::memcmp(tableBuffer.data(), "SRAT", 4) != 0)
    {
        DBG(1, "Invalid SRAT table signature");
        return;
    }
    
    // Get table length from header using memcpy to avoid alignment issues
    uint32_t tableLength;
    std::memcpy(&tableLength, tableBuffer.data() + 4, sizeof(uint32_t));
    
    DBG(2, "SRAT table found, length: ", tableLength);
    
    // Skip ACPI header (36 bytes) + Reserved fields (12 bytes) = 48 bytes
    const BYTE* ptr = tableBuffer.data() + 48;
    const BYTE* endPtr = tableBuffer.data() + (std::min)((uint32_t)tableSize, tableLength);
    
    while (ptr + 2 <= endPtr)
    {
        uint8_t type = ptr[0];
        uint8_t length = ptr[1];
        
        if (ptr + length > endPtr)
        {
            DBG(2, "SRAT subtable extends beyond table boundary, stopping parse");
            break;
        }
        
        if (type == 2)  // PCI Device Affinity Structure
        {
            // Structure format (variable, at least 16 bytes):
            // Type(1) + Length(1) + Reserved(2) + 
            // Proximity Domain(4) + PCI Segment(2) + PCI Bus(1) + 
            // Device/Function(1) + Flags(4) + Reserved(4)
            
            if (length < 16)
            {
                DBG(2, "SRAT PCI Device Affinity structure too small: ", (int)length);
                ptr += length;
                continue;
            }
            
            // Use memcpy to avoid alignment issues
            uint32_t proximityDomain;
            uint16_t pciSegment;
            std::memcpy(&proximityDomain, ptr + 4, sizeof(uint32_t));
            std::memcpy(&pciSegment, ptr + 8, sizeof(uint16_t));
            uint8_t pciBus = ptr[10];
            uint8_t deviceFunction = ptr[11];
            uint8_t pciDevice = (deviceFunction >> 3) & 0x1F;
            uint8_t pciFunction = deviceFunction & 0x07;
            
            // Construct unique key: segment(16) | bus(8) | device(5) | function(3)
            uint64_t key = ((uint64_t)pciSegment << 16) | ((uint64_t)pciBus << 8) | 
                          ((uint64_t)pciDevice << 3) | pciFunction;
            
            pciToNuma[key] = proximityDomain;
            
            DBG(2, "SRAT: PCI ", std::hex, pciSegment, ":", (unsigned)pciBus, ":", 
                (unsigned)pciDevice, ".", (unsigned)pciFunction, 
                " -> NUMA node ", std::dec, proximityDomain);
        }
        
        ptr += length;
    }
    
    DBG(2, "SRAT parsing complete, found ", pciToNuma.size(), " PCI device entries");
}

#elif __APPLE__

PciHandle::PciHandle(uint32, uint32 bus_, uint32 device_, uint32 function_) :
    fd(-1),
    bus(bus_),
    device(device_),
    function(function_),
    numaNode(-1)
{ }

int32 PciHandle::getNUMANode() const
{
    return numaNode;
}

bool PciHandle::exists(uint32 groupnr_, uint32 bus_, uint32 device_, uint32 function_)
{
    if (groupnr_ != 0)
    {
        std::cerr << "Non-zero PCI group segments are not supported in PCM/APPLE OSX\n";
        return false;
    }
    uint32_t pci_address = FORM_PCI_ADDR(bus_, device_, function_, 0);
    uint32_t value = 0;
    PCIDriver_read32(pci_address, &value);
    uint32_t vendor_id = value & 0xffff;
    uint32_t device_id = (value >> 16) & 0xffff;

    //if (vendor_id == PCM_INTEL_PCI_VENDOR_ID) {
    if (vendor_id != 0xffff && device_id != 0xffff) {
        return true;
    } else {
        return false;
    }
}

int32 PciHandle::read32(uint64 offset, uint32 * value)
{
    warnAlignment<4>("PciHandle::read32", false, offset);
    uint32_t pci_address = FORM_PCI_ADDR(bus, device, function, (uint32_t)offset);
    return PCIDriver_read32(pci_address, value);
}

int32 PciHandle::write32(uint64 offset, uint32 value)
{
    warnAlignment<4>("PciHandle::write32", false, offset);
    uint32_t pci_address = FORM_PCI_ADDR(bus, device, function, (uint32_t)offset);
    return PCIDriver_write32(pci_address, value);
}

int32 PciHandle::read64(uint64 offset, uint64 * value)
{
    warnAlignment<4>("PciHandle::read64", false, offset);
    uint32_t pci_address = FORM_PCI_ADDR(bus, device, function, (uint32_t)offset);
    return PCIDriver_read64(pci_address, value);
}

PciHandle::~PciHandle()
{ }

#elif defined (__FreeBSD__) || defined(__DragonFly__)

// Helper function to compute NUMA node for FreeBSD
static int32 getNUMANodeFreeBSD(uint32 groupnr, uint32 bus, uint32 device, uint32 function)
{
    // FreeBSD implementation: try to query NUMA domain information via sysctl
    // Return -1 if not available or on error
    
#if defined(__FreeBSD__) || defined(__DragonFly__)
    // First check if NUMA is enabled on this system
    int ndomains = 0;
    size_t len = sizeof(ndomains);
    
    if (sysctlbyname("vm.ndomains", &ndomains, &len, nullptr, 0) == 0)
    {
        if (ndomains <= 1)
        {
            // NUMA not enabled or single domain system
            DBG(3, "NUMA not enabled on FreeBSD (vm.ndomains = ", ndomains, ")");
            return -1;
        }
    }
    else
    {
        DBG(2, "Cannot query vm.ndomains, assuming NUMA not available");
        return -1;
    }
    
    // Try platform-specific sysctl path for PCI device NUMA domain
    // Note: This is not standardized across FreeBSD versions
    // Buffer size: "hw.pci." (7) + max domain (10) + "." (1) + max bus (10) + "." (1) + 
    //              max device (10) + "." (1) + max function (10) + ".numa_domain" (12) + null (1) = 63
    // Use 128 to be safe
    constexpr size_t SYSCTL_PATH_MAX = 128;
    char sysctl_path[SYSCTL_PATH_MAX];
    int ret;
    
    ret = snprintf(sysctl_path, sizeof(sysctl_path), 
                   "hw.pci.%u.%u.%u.%u.numa_domain",
                   groupnr, bus, device, function);
    
    if (ret < 0 || ret >= (int)sizeof(sysctl_path))
    {
        DBG(2, "sysctl path truncated or error for PCI device ", 
            std::hex, groupnr, ":", bus, ":", device, ".", function, std::dec);
        return -1;
    }
    
    int numa_node = -1;
    len = sizeof(numa_node);
    
    if (sysctlbyname(sysctl_path, &numa_node, &len, nullptr, 0) == 0)
    {
        DBG(3, "Found NUMA node ", numa_node, " for PCI device ",
            std::hex, groupnr, ":", bus, ":", device, ".", function, std::dec);
        return numa_node;
    }
    
    // Try alternative sysctl format with colon separators
    ret = snprintf(sysctl_path, sizeof(sysctl_path), 
                   "hw.pci.%u:%u:%u.%u.numa_domain",
                   groupnr, bus, device, function);
    
    if (ret < 0 || ret >= (int)sizeof(sysctl_path))
    {
        DBG(2, "sysctl path truncated or error for PCI device ", 
            std::hex, groupnr, ":", bus, ":", device, ".", function, std::dec);
        return -1;
    }
    
    if (sysctlbyname(sysctl_path, &numa_node, &len, nullptr, 0) == 0)
    {
        DBG(3, "Found NUMA node ", numa_node, " for PCI device ",
            std::hex, groupnr, ":", bus, ":", device, ".", function, std::dec);
        return numa_node;
    }
    
    DBG(2, "NUMA node information not available for PCI device ",
        std::hex, groupnr, ":", bus, ":", device, ".", function, std::dec);
#endif
    
    return -1;
}

PciHandle::PciHandle(uint32 groupnr_, uint32 bus_, uint32 device_, uint32 function_) :
    fd(-1),
    groupnr(groupnr_),
    bus(bus_),
    device(device_),
    function(function_),
    numaNode(-1)
{
    int handle = ::open("/dev/pci", O_RDWR | O_NOFOLLOW);
    if (handle < 0) {
        if (errno == ELOOP) {
            std::cerr << "SDL330 ERROR: Symlink detected at /dev/pci\n";
        }
        throw std::exception();
    }
    fd = handle;
    
    // Initialize NUMA node during construction
    numaNode = getNUMANodeFreeBSD(groupnr, bus, device, function);
}

int32 PciHandle::getNUMANode() const
{
    return numaNode;
}

bool PciHandle::exists(uint32 groupnr_, uint32 bus_, uint32 device_, uint32 function_)
{
    struct pci_conf_io pc;
    struct pci_match_conf pattern;
    struct pci_conf conf[4];
    int fd;
    int ret;

    fd = ::open("/dev/pci", O_RDWR | O_NOFOLLOW, 0);
    if (fd < 0) {
        if (errno == ELOOP) {
            std::cerr << "SDL330 ERROR: Symlink detected at /dev/pci\n";
        }
        return false;
    }

    bzero(&pc, sizeof(pc));

    pattern.pc_sel.pc_domain = groupnr_;
    pattern.pc_sel.pc_bus = bus_;
    pattern.pc_sel.pc_dev = device_;
    pattern.pc_sel.pc_func = function_;
    pattern.flags = (pci_getconf_flags)(PCI_GETCONF_MATCH_DOMAIN | PCI_GETCONF_MATCH_BUS | PCI_GETCONF_MATCH_DEV | PCI_GETCONF_MATCH_FUNC);

    pc.pat_buf_len = sizeof(pattern);
    pc.patterns = &pattern;
    pc.num_patterns = 1;
    pc.match_buf_len = sizeof(conf);
    pc.matches = conf;

    ret = ioctl(fd, PCIOCGETCONF, &pc);
    ::close(fd);

    if (ret) return false;

    if (pc.status != PCI_GETCONF_LAST_DEVICE) return false;

    if (pc.num_matches > 0) return true;

    return false;
}

int32 PciHandle::read32(uint64 offset, uint32 * value)
{
    warnAlignment<4>("PciHandle::read32", false, offset);
    struct pci_io pi;
    int ret;

    pi.pi_sel.pc_domain = groupnr;
    pi.pi_sel.pc_bus = bus;
    pi.pi_sel.pc_dev = device;
    pi.pi_sel.pc_func = function;
    pi.pi_reg = offset;
    pi.pi_width = 4;

    ret = ioctl(fd, PCIOCREAD, &pi);
    if (ret) return ret;

    *value = pi.pi_data;
    return sizeof(*value);
}

int32 PciHandle::write32(uint64 offset, uint32 value)
{
    warnAlignment<4>("PciHandle::write32", false, offset);
    struct pci_io pi;
    int ret;

    pi.pi_sel.pc_domain = groupnr;
    pi.pi_sel.pc_bus = bus;
    pi.pi_sel.pc_dev = device;
    pi.pi_sel.pc_func = function;
    pi.pi_reg = offset;
    pi.pi_width = 4;
    pi.pi_data = value;

    ret = ioctl(fd, PCIOCWRITE, &pi);
    if (ret) return ret;

    return sizeof(value);
}

int32 PciHandle::read64(uint64 offset, uint64 * value)
{
    warnAlignment<4>("PciHandle::read64", false, offset);
    struct pci_io pi;
    int32 ret;

    pi.pi_sel.pc_domain = groupnr;
    pi.pi_sel.pc_bus = bus;
    pi.pi_sel.pc_dev = device;
    pi.pi_sel.pc_func = function;
    pi.pi_reg = offset;
    pi.pi_width = 4;

    ret = ioctl(fd, PCIOCREAD, &pi);
    if (ret) return ret;

    *value = pi.pi_data;

    pi.pi_reg += 4;

    ret = ioctl(fd, PCIOCREAD, &pi);
    if (ret) return ret;

    *value += ((uint64)pi.pi_data << 32);
    return sizeof(value);
}

PciHandle::~PciHandle()
{
    if (fd >= 0) ::close(fd);
}

#else


// Linux implementation

// Helper function to retrieve NUMA node for a PCI device
int32 getNUMANodeLinux(uint32 groupnr, uint32 bus, uint32 device, uint32 function)
{
    std::ostringstream path;
    path << std::hex << "/sys/bus/pci/devices/"
         << std::setw(4) << std::setfill('0') << groupnr << ":"
         << std::setw(2) << std::setfill('0') << bus << ":"
         << std::setw(2) << std::setfill('0') << device << "."
         << function << "/numa_node";
    
    std::string numa_path = path.str();
    std::ifstream numa_file(numa_path);
    if (!numa_file.is_open())
    {
        // Try alternative path with /pcm prefix (follows existing codebase pattern
        // for containerized or chroot environments where sysfs may be mounted under /pcm)
        numa_file.open("/pcm" + numa_path);
        if (!numa_file.is_open())
        {
            DBG(2, "Cannot open NUMA node file: ", numa_path);
            return -1;
        }
    }
    
    int32 numa_node = -1;
    numa_file >> numa_node;
    
    DBG(3, "NUMA node for ", std::hex, std::setw(4), std::setfill('0'), groupnr, ":",
        std::setw(2), bus, ":", std::setw(2), device, ".", function, std::dec, " is ", numa_node);
    
    if (numa_node == -1)
    {
        // No NUMA -> map to NUMA node 0
        numa_node = 0;
    }

    return numa_node;
}

int openHandle(uint32 groupnr_, uint32 bus, uint32 device, uint32 function)
{
    std::ostringstream path(std::ostringstream::out);

    path << std::hex << "/proc/bus/pci/";
    if (groupnr_)
    {
        path << std::setw(4) << std::setfill('0') << groupnr_ << ":";
    }
    path << std::setw(2) << std::setfill('0') << bus << "/" << std::setw(2) << std::setfill('0') << device << "." << function;

//    std::cout << "PciHandle: Opening "<<path.str()<<"\n";

    int handle = ::open(path.str().c_str(), O_RDWR | O_NOFOLLOW);
    if (handle < 0)
    {
       if (errno == 24) std::cerr << "ERROR: " << PCM_ULIMIT_RECOMMENDATION;
       if (errno == ELOOP) std::cerr << "SDL330 ERROR: Symlink detected at " << path.str() << "\n";
       handle = ::open((std::string("/pcm") + path.str()).c_str(), O_RDWR | O_NOFOLLOW);
       if (handle < 0 && errno == ELOOP) {
           std::cerr << "SDL330 ERROR: Symlink detected at /pcm" << path.str() << "\n";
       }
    }
    return handle;
}

PciHandle::PciHandle(uint32 groupnr_, uint32 bus_, uint32 device_, uint32 function_) :
    fd(-1),
    groupnr(groupnr_),
    bus(bus_),
    device(device_),
    function(function_),
    numaNode(-1)
{
    int handle = openHandle(groupnr_, bus_, device_, function_);
    if (handle < 0)
    {
        throw std::runtime_error(std::string("PCM error: can't open PciHandle ")
            + std::to_string(groupnr_) + ":" + std::to_string(bus_) + ":" + std::to_string(device_) + ":" + std::to_string(function_));
    }
    fd = handle;
    
    // Initialize NUMA node during construction
    numaNode = getNUMANodeLinux(groupnr, bus, device, function);

    // std::cout << "DEBUG: Opened "<< path.str().c_str() << " on handle "<< fd << "\n";
}

int32 PciHandle::getNUMANode() const
{
    return numaNode;
}


bool PciHandle::exists(uint32 groupnr_, uint32 bus_, uint32 device_, uint32 function_)
{
    int handle = openHandle(groupnr_, bus_, device_, function_);

    if (handle < 0) return false;

    ::close(handle);

    return true;
}

int32 PciHandle::read32(uint64 offset, uint32 * value)
{
    warnAlignment<4>("PciHandle::read32", false, offset);
    return ::pread(fd, (void *)value, sizeof(uint32), offset);
}

int32 PciHandle::write32(uint64 offset, uint32 value)
{
    warnAlignment<4>("PciHandle::write32", false, offset);
    return ::pwrite(fd, (const void *)&value, sizeof(uint32), offset);
}

int32 PciHandle::read64(uint64 offset, uint64 * value)
{
    warnAlignment<4>("PciHandle::read64", false, offset);
    size_t res = ::pread(fd, (void *)value, sizeof(uint64), offset);
    if(res != sizeof(uint64))
    {
        std::cerr << " ERROR: pread from " << fd << " with offset 0x" << std::hex << offset << std::dec << " returned " << res << " bytes \n";
    }
    return res;
}

PciHandle::~PciHandle()
{
    if (fd >= 0) ::close(fd);
}

int PciHandle::openMcfgTable() {
    const std::vector<std::string> base_paths = {"/sys/firmware/acpi/tables/MCFG", "/sys/firmware/acpi/tables/MCFG1"};
    std::vector<std::string> paths = base_paths;
    for (const auto & p: base_paths)
    {
        paths.push_back(std::string("/pcm") + p);
    }
    int handle = -1;
    for (const auto & p: paths)
    {
        if (handle < 0)
        {
            handle = ::open(p.c_str(), O_RDONLY);
        }
    }
    if (handle < 0)
    {
        for (const auto & p: paths)
        {
            std::cerr << "Can't open MCFG table. Check permission of " << p << "\n";
        }
    }
    return handle;
}

// mmapped I/O version

MCFGHeader PciHandleMM::mcfgHeader;
std::vector<MCFGRecord> PciHandleMM::mcfgRecords;

const std::vector<MCFGRecord> & PciHandleMM::getMCFGRecords()
{
    readMCFG();
    return mcfgRecords;
}

void PciHandleMM::readMCFG()
{
    if (mcfgRecords.size() > 0)
        return; // already initialized

    int mcfg_handle = PciHandle::openMcfgTable();
    if (mcfg_handle < 0) throw std::runtime_error("cannot open any of /[pcm]/sys/firmware/acpi/tables/MCFG* files!");

    ssize_t read_bytes = ::read(mcfg_handle, (void *)&mcfgHeader, sizeof(MCFGHeader));

    if (read_bytes == 0)
    {
        ::close(mcfg_handle);
        const auto msg = "PCM Error: Cannot read MCFG-table";
        std::cerr << msg;
        std::cerr << "\n";
        throw std::runtime_error(msg);
    }

    const unsigned segments = mcfgHeader.nrecords();
#ifdef PCM_DEBUG
    mcfgHeader.print();
    std::cout << "PCM Debug: total segments: " << segments << "\n";
#endif

    for (unsigned int i = 0; i < segments; ++i)
    {
        MCFGRecord record;
        read_bytes = ::read(mcfg_handle, (void *)&record, sizeof(MCFGRecord));
        if (read_bytes == 0)
        {
            ::close(mcfg_handle);
            const auto msg = "PCM Error: Cannot read MCFG-table (2)";
            std::cerr << msg;
            std::cerr << "\n";
            throw std::runtime_error(msg);
        }
#ifdef PCM_DEBUG
        std::cout << "PCM Debug: segment " << std::dec << i << " ";
        record.print();
#endif
        mcfgRecords.push_back(record);
    }

    ::close(mcfg_handle);
}

PciHandleMM::PciHandleMM(uint32 groupnr_, uint32 bus_, uint32 device_, uint32 function_) :
    fd(-1),
    mmapAddr(NULL),
    groupnr(groupnr_),
    bus(bus_),
    device(device_),
    function(function_),
    base_addr(0),
    numaNode(-1)
{
    int handle = ::open("/dev/mem", O_RDWR | O_NOFOLLOW);
    if (handle < 0) {
        if (errno == ELOOP) {
            std::cerr << "SDL330 CRITICAL: Symlink detected at /dev/mem - potential privilege escalation attack!\n";
        }
        throw std::exception();
    }
    fd = handle;

    readMCFG();

    unsigned segment = 0;
    for ( ; segment < mcfgRecords.size(); ++segment)
    {
        if (mcfgRecords[segment].PCISegmentGroupNumber == groupnr_
            && mcfgRecords[segment].startBusNumber <= bus_
            && bus <= mcfgRecords[segment].endBusNumber)
            break;
    }
    if (segment == mcfgRecords.size())
    {
        std::cerr << "PCM Error: (group " << groupnr_ << ", bus " << bus_ << ") not found in the MCFG table.\n";
        throw std::exception();
    }
    else
    {
#ifdef PCM_DEBUG
        std::cout << "PCM Debug: (group " << groupnr_ << ", bus " << bus_ << ") found in the MCFG table in segment " << segment << "\n";
#endif
    }

    base_addr = mcfgRecords[segment].baseAddress;

    base_addr += (bus * 1024ULL * 1024ULL + device * 32ULL * 1024ULL + function * 4ULL * 1024ULL);

    mmapAddr = (char *)mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, base_addr);

    if (mmapAddr == MAP_FAILED)
    {
        std::cout << "mmap failed: errno is " << errno << "\n";
        throw std::exception();
    }
    
    // Initialize NUMA node during construction
    numaNode = getNUMANodeLinux(groupnr, bus, device, function);
}

int32 PciHandleMM::getNUMANode() const
{
    return numaNode;
}

bool PciHandleMM::exists(uint32 /*groupnr_*/, uint32 /*bus_*/, uint32 /*device_*/, uint32 /*function_*/)
{
    int handle = ::open("/dev/mem", O_RDWR | O_NOFOLLOW);

    if (handle < 0) {
        if (errno == ELOOP) {
            std::cerr << "SDL330 CRITICAL: Symlink detected at /dev/mem - potential privilege escalation attack!\n";
        }
        perror("error opening /dev/mem");
        return false;
    }

    ::close(handle);

    handle = PciHandle::openMcfgTable();

    if (handle < 0) {
        return false;
    }

    ::close(handle);

    return true;
}


int32 PciHandleMM::read32(uint64 offset, uint32 * value)
{
    warnAlignment<4>("PciHandleMM::read32", false, offset);
    *value = *((uint32 *)(mmapAddr + offset));

    return sizeof(uint32);
}

int32 PciHandleMM::write32(uint64 offset, uint32 value)
{
    warnAlignment<4>("PciHandleMM::write32", false, offset);
    *((uint32 *)(mmapAddr + offset)) = value;

    return sizeof(uint32);
}

int32 PciHandleMM::read64(uint64 offset, uint64 * value)
{
    warnAlignment<4>("PciHandleMM::read64", false, offset);
    read32(offset, (uint32 *)value);
    read32(offset + sizeof(uint32), ((uint32 *)value) + 1);

    return sizeof(uint64);
}

PciHandleMM::~PciHandleMM()
{
    if (mmapAddr) munmap(mmapAddr, 4096);
    if (fd >= 0) ::close(fd);
}

#endif

} // namespace pcm

```

`src/pci.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev
//            Pat Fay
//            Jim Harris (FreeBSD)


#ifndef CPUCounters_PCI_H
#define CPUCounters_PCI_H

/*!     \file pci.h
        \brief Low level interface to access PCI configuration space

*/

#include "types.h"
#include "debug.h"
#include "utils.h"

#ifdef _MSC_VER
#include "windows.h"
#else
#include <unistd.h>
#endif

#ifdef __APPLE__
#include "PCIDriverInterface.h"
#endif

#include <vector>

namespace pcm {

class PciHandle
{
#ifdef _MSC_VER
    HANDLE hDriver;
#else
    int32 fd;
#endif

#if defined(__FreeBSD__) || defined(__DragonFly__) || defined(__linux__)
    uint32 groupnr{};
#endif
    uint32 bus;
    uint32 device;
    uint32 function;
#ifdef _MSC_VER
    DWORD pciAddress;
#endif
    int32 numaNode;

    friend class PciHandleMM;

    PciHandle();                                // forbidden
    PciHandle(const PciHandle &);               // forbidden
    PciHandle & operator = (const PciHandle &); // forbidden

public:
    PciHandle(uint32 groupnr_, uint32 bus_, uint32 device_, uint32 function_);

    static bool exists(uint32 groupnr_, uint32 bus_, uint32 device_, uint32 function_);

    int32 read32(uint64 offset, uint32 * value);
    int32 write32(uint64 offset, uint32 value);

    int32 read64(uint64 offset, uint64 * value);

    int32 getNUMANode() const;

    virtual ~PciHandle();

protected:
    static int openMcfgTable();
#ifdef _MSC_VER
public:
    static void readMCFGRecords(std::vector<MCFGRecord>& mcfg);
#endif
};

#ifdef _MSC_VER
typedef PciHandle PciHandleType;
#elif __APPLE__
// This may need to change if it can be implemented for OSX
typedef PciHandle PciHandleType;
#elif defined(__FreeBSD__) || defined(__DragonFly__)
typedef PciHandle PciHandleType;
#elif defined(__linux__)

// read/write PCI config space using physical memory using mmapped file I/O
class PciHandleMM
{
    int32 fd;
    char * mmapAddr;

    uint32 groupnr;
    uint32 bus;
    uint32 device;
    uint32 function;
    uint64 base_addr;
    int32 numaNode;

    static MCFGHeader mcfgHeader;
    static std::vector<MCFGRecord> mcfgRecords;
    static void readMCFG();

    PciHandleMM() = delete;             // forbidden
    PciHandleMM(const PciHandleMM &) = delete; // forbidden
    PciHandleMM & operator = (const PciHandleMM &) = delete;

public:
    PciHandleMM(uint32 groupnr_, uint32 bus_, uint32 device_, uint32 function_);

    static bool exists(uint32 groupnr_, uint32 bus_, uint32 device_, uint32 function_);

    int32 read32(uint64 offset, uint32 * value);
    int32 write32(uint64 offset, uint32 value);

    int32 read64(uint64 offset, uint64 * value);

    int32 getNUMANode() const;

    virtual ~PciHandleMM();

    static const std::vector<MCFGRecord> & getMCFGRecords();
};

#ifdef PCM_USE_PCI_MM_LINUX
#define PciHandleType PciHandleMM
#else
#define PciHandleType PciHandle
#endif

#else
#error "Platform not supported"
#endif

#ifdef __linux__
// Helper function to retrieve NUMA node for a PCI device (Linux only)
int32 getNUMANodeLinux(uint32 groupnr, uint32 bus, uint32 device, uint32 function);
#endif

template <class F>
inline void forAllDevices(F f, const int requestedVendorID = -1, const int requestedDevice = -1, const int requestedFunction = -1)
{
    std::vector<MCFGRecord> mcfg;
    getMCFGRecords(mcfg);

    auto probe = [&f, &requestedVendorID](const uint32 group, const uint32 bus, const uint32 device, const uint32 function)
    {
        DBG(3, "Probing " , std::hex , group , ":" , bus , ":" , device , ":" , function , " " , std::dec);
        uint32 value = 0;
        try
        {
            PciHandleType h(group, bus, device, function);
            DBG(3, "NUMA node: ", h.getNUMANode());
            h.read32(0, &value);

        } catch(...)
        {
            // invalid bus:device:function
            return;
        }
        const uint32 vendor_id = value & 0xffff;
        const uint32 device_id = (value >> 16) & 0xffff;
        DBG(3, "Found dev " , std::hex , vendor_id , ":" , device_id , std::dec);
        if (requestedVendorID >= 0 && int(vendor_id) != requestedVendorID)
        {
            return;
        }

        f(group, bus, device, function, device_id);
    };

    for (uint32 s = 0; s < (uint32)mcfg.size(); ++s)
    {
        const auto group = mcfg[s].PCISegmentGroupNumber;
        for (uint32 bus = (uint32)mcfg[s].startBusNumber; bus <= (uint32)mcfg[s].endBusNumber; ++bus)
        {
            auto forAllFunctions = [requestedFunction,&probe](const uint32 group, const uint32 bus, const uint32 device)
            {
                if (requestedFunction < 0)
                {
                    for (uint32 function = 0 ; function < 8; ++function)
                    {
                        probe(group, bus, device, function);
                    }
                }
                else
                {
                    probe(group, bus, device, requestedFunction);
                }
            };
            if (requestedDevice < 0)
            {
                for (uint32 device = 0 ; device < 32; ++device)
                {
                    forAllFunctions(group, bus, device);
                }
            }
            else
            {
                forAllFunctions(group, bus, requestedDevice);
            }
        }
    }
}

template <class F>
inline void forAllIntelDevices(F f, int requestedDevice = -1, int requestedFunction = -1)
{
    forAllDevices(f, PCM_INTEL_PCI_VENDOR_ID, requestedDevice, requestedFunction);
}

union VSEC {
    struct {
        uint64 cap_id:16;
        uint64 cap_version:4;
        uint64 cap_next:12;
        uint64 vsec_id:16;
        uint64 vsec_version:4;
        uint64 vsec_length:12;
        uint64 entryID:16;
        uint64 NumEntries:8;
        uint64 EntrySize:8;
        uint64 tBIR:3;
        uint64 Address:29;
    } fields;
    uint64 raw_value64[2];
    uint32 raw_value32[4];
};

template <class MatchFunc, class ProcessFunc>
void processDVSEC(MatchFunc matchFunc, ProcessFunc processFunc)
{
    forAllIntelDevices([&](const uint32 group, const uint32 bus, const uint32 device, const uint32 function, const uint32 device_id)
    {
        DBG(2, "Intel device scan.found " , std::hex , group , ":" , bus , " : " , device , " : " , function , " " , device_id);
        uint32 status{0};
        PciHandleType h(group, bus, device, function);
        const auto NUMANode = h.getNUMANode();
        DBG(2, "NUMA node: ", NUMANode);
        h.read32(4, &status); // read status
        if (status & 0x100000) // has capability list
        {
            DBG(2, "Intel device scan. found ", std::hex , group , ":" , bus , ":" , device , ":" , function , " " , device_id , " with capability list");
            VSEC header;
            uint64 offset = 0x100;
            do
            {
                if (offset == 0 || h.read32(offset, &header.raw_value32[0]) != sizeof(uint32) || header.raw_value32[0] == 0)
                {
                    return;
                }
                if (h.read64(offset, &header.raw_value64[0]) != sizeof(uint64) || h.read64(offset + sizeof(uint64), &header.raw_value64[1]) != sizeof(uint64))
                {
                    return;
                }
                DBG(2, "offset 0x" , std::hex , offset , " cap_id: 0x" , header.fields.cap_id , " vsec_id: 0x", header.fields.vsec_id, " entryID: 0x" , std::hex , header.fields.entryID ,
                    " NumEntries: ", std::dec, header.fields.NumEntries, " EntrySize: ", std::dec, header.fields.EntrySize, " tBIR: ", header.fields.tBIR,
                    " Address: 0x", std::hex, header.fields.Address, std::dec);
                if (matchFunc(header))
                {
                    DBG(2, ".... found match.  tBIR = ", header.fields.tBIR);
                    auto barOffset = 0x10 + header.fields.tBIR * 4;
                    uint32 bar = 0;
                    if (h.read32(barOffset, &bar) == sizeof(uint32) && bar != 0) // read bar
                    {
                        DBG(2, "bar = 0x", std::hex, bar, std::dec);
                        if (extract_bits_32(bar, 0, 0) == 0) // memory space
                        {
                            auto type = extract_bits_32(bar, 2, 1);
                            if (type == 0) // 32-bit address
                            {
                                bar &= ~0xfull;
                                processFunc(bar, header, NUMANode);
                            }
                            else if (type == 2) // 64-bit address
                            {
                                uint32 bar_high = 0;
                                if (h.read32(barOffset + 4, &bar_high) == sizeof(uint32))
                                {
                                    uint64 full_bar = (uint64(bar_high) << 32) | uint64(bar);
                                    full_bar &= ~0xfull;
                                    DBG(2, " full_bar = 0x", std::hex, full_bar, std::dec);
                                    processFunc(full_bar, header, NUMANode);
                                }
                                else
                                {
                                    std::cerr << "Error: can't read high part of 64-bit bar from offset 0x" << std::hex << (barOffset + 4) << std::dec << " \n";
                                }
                            }
                            else
                            {
                                // BAR type 1 is reserved by the PCI specification and is not valid.
                                // Any unknown BAR type (including type 1) is treated as an error.
                                std::cerr << "Error: unknown bar type " << type << " at bar offset 0x" << std::hex << barOffset << std::dec << " \n";
                            }
                        }
                    }
                    else
                    {
                        std::cerr << "Error: can't read bar from offset 0x" << std::hex << barOffset << std::dec << " \n";
                    }
                }
                const uint64 lastOffset = offset;
                offset = header.fields.cap_next & ~3;
                if (lastOffset == offset) // the offset did not change
                {
                    DBG(2, " lastOffset == offset ", lastOffset , "==", offset);
                    return; // deadlock protection
                }
            } while (1);
        }
    });
}

} // namespace pcm

#endif

```

`src/pcm-accel-common.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2022-2023, Intel Corporation
// written by White.Hu, Pavithran P

#include "pcm-accel-common.h"
#include "cpucounters.h"
#include <mutex>

idx_ccr* idx_get_ccr(uint64_t& ccr)
{
    return new spr_idx_ccr(ccr);
}

uint32_t AcceleratorCounterState::getNumOfAccelDevs()
{
    uint32_t dev_count = 0;

    if (evt_ctx.accel >= ACCEL_MAX || evt_ctx.m == NULL)
        return 0;

    switch (evt_ctx.accel)
    {
        case ACCEL_IAA:
            dev_count = evt_ctx.m->getNumOfIDXAccelDevs(PCM::IDX_IAA);
            break;
        case ACCEL_DSA:
            dev_count = evt_ctx.m->getNumOfIDXAccelDevs(PCM::IDX_DSA);
            break;
        case ACCEL_QAT:
            dev_count = evt_ctx.m->getNumOfIDXAccelDevs(PCM::IDX_QAT);
            break;
        default:
            dev_count = 0;
            break;
    }

    return dev_count;
}

uint32_t AcceleratorCounterState::getMaxNumOfAccelCtrs()
{
    uint32_t ctr_count = 0;

    if (evt_ctx.accel >= ACCEL_MAX || evt_ctx.m == NULL)
        return 0;

    switch (evt_ctx.accel)
    {
        case ACCEL_IAA:
        case ACCEL_DSA:
        case ACCEL_QAT:
            ctr_count = evt_ctx.m->getMaxNumOfIDXAccelCtrs(evt_ctx.accel);
            break;
        default:
            ctr_count = 0;
            break;
    }

    return ctr_count;
}

int32_t AcceleratorCounterState::programAccelCounters()
{
    std::vector<uint64_t> rawEvents;
    std::vector<uint32_t> filters_wq, filters_tc, filters_pgsz, filters_xfersz, filters_eng;

    if (evt_ctx.m == NULL || evt_ctx.accel >= ACCEL_MAX || evt_ctx.ctrs.size() == 0 || evt_ctx.ctrs.size()  > getMaxNumOfAccelCtrs())
        return -1;

    switch (evt_ctx.accel)
    {
        case ACCEL_IAA:
        case ACCEL_DSA:
        case ACCEL_QAT:
            for (auto pctr = evt_ctx.ctrs.begin(); pctr != evt_ctx.ctrs.end(); ++pctr)
            {
                rawEvents.push_back(pctr->ccr);
                filters_wq.push_back(pctr->cfr_wq);
                filters_tc.push_back(pctr->cfr_tc);
                filters_pgsz.push_back(pctr->cfr_pgsz);
                filters_xfersz.push_back(pctr->cfr_xfersz);
                filters_eng.push_back(pctr->cfr_eng);
                //std::cout<<"ctr idx=0x" << std::hex << pctr->idx << " hid=0x" << std::hex << pctr->h_id << " vid=0x" << std::hex << pctr->v_id <<" ccr=0x" << std::hex << pctr->ccr << "\n";
                //std::cout<<"mul=0x" << std::hex << pctr->multiplier << " div=0x" << std::hex << pctr->divider << "\n" << std::dec;
            }
            evt_ctx.m->programIDXAccelCounters(idx_accel_mapping[evt_ctx.accel], rawEvents, filters_wq, filters_eng, filters_tc, filters_pgsz, filters_xfersz);
            break;
        default:
            break;
    }

    return 0;
}

SimpleCounterState AcceleratorCounterState::getAccelCounterState(uint32 dev, uint32 ctr_index)
{
    SimpleCounterState result;
    
    if (evt_ctx.m == NULL || evt_ctx.accel >= ACCEL_MAX || dev >= getNumOfAccelDevs() || ctr_index >= getMaxNumOfAccelCtrs())
        return result;

    switch (evt_ctx.accel)
    {
        case ACCEL_IAA:
        case ACCEL_DSA:
        case ACCEL_QAT:
            result = evt_ctx.m->getIDXAccelCounterState(evt_ctx.accel, dev, ctr_index);
            break;
        case ACCEL_MAX:
        case ACCEL_NOCONFIG:
            break;
    }

    return result;
}

bool AcceleratorCounterState::isAccelCounterAvailable()
{
    bool ret = true;

    if (evt_ctx.m == NULL || evt_ctx.accel >= ACCEL_MAX)
        ret =false;

    if (getNumOfAccelDevs() == 0)
        ret = false;

    return ret;
}

std::string AcceleratorCounterState::getAccelCounterName()
{
    std::string ret;
    
    switch (evt_ctx.accel)
    {
        case ACCEL_IAA:
            ret = "iaa";
            break;
        case ACCEL_DSA:
            ret = "dsa";
            break;
        case ACCEL_QAT:
            ret = "qat";
            break;
        default:
            ret = "id=" + std::to_string(evt_ctx.accel) + "(unknown)";
    }

    return ret;
}

bool AcceleratorCounterState::getAccelDevLocation( uint32_t dev, const ACCEL_DEV_LOC_MAPPING loc_map, uint32_t &location)
{
    bool ret = true;
    
    switch (loc_map)
    {
        case SOCKET_MAP:
            location = evt_ctx.m->getCPUSocketIdOfIDXAccelDev(evt_ctx.accel, dev);
            break;
        case NUMA_MAP:
            location = evt_ctx.m->getNumaNodeOfIDXAccelDev(evt_ctx.accel, dev);
            break;
        default:
            ret = false;
    }
    
    return ret;
}

/*! \brief Computes number of accelerator counters present in system

    \return Number of accel counters in system
*/
int AcceleratorCounterState::getNumberOfCounters(){
    
    return getCounters().size();
}

std::string AcceleratorCounterState::getAccelIndexCounterName(int ctr_index)
{
    accel_counter pctr = getCounters().at(ctr_index);                
    return pctr.v_event_name;
}

uint64 AcceleratorCounterState::getAccelIndexCounter(uint32 dev, const SystemCounterState & before,const SystemCounterState & after,int ctr_index)
{
    const uint32_t counter_nb = getCounters().size();
    accel_counter pctr = getCounters().at(ctr_index);
    uint64_t raw_result = getNumberOfEvents(before.accel_counters[dev*counter_nb + ctr_index], after.accel_counters[dev*counter_nb + ctr_index]);
    uint64_t trans_result = uint64_t (raw_result * pctr.multiplier / (double) pctr.divider );
    return trans_result;
}

int idx_evt_parse_handler(evt_cb_type cb_type, void *cb_ctx, counter &base_ctr, std::map<std::string, uint32_t> &ofm, std::string key, uint64 numValue)
{
    accel_evt_parse_context *context = (accel_evt_parse_context *)cb_ctx;
    // PCM *m = context->m;
    AcceleratorCounterState *accs_;
    accs_ = AcceleratorCounterState::getInstance();

    if (cb_type == EVT_LINE_START) //this event will be called per line(start)
    {
        context->ctr.cfr_wq = 0xFFFF;
        context->ctr.cfr_eng = 0xFFFF;
        context->ctr.cfr_tc = 0xFFFF;
        context->ctr.cfr_pgsz = 0xFFFF;
        context->ctr.cfr_xfersz = 0xFFFF;
        context->ctr.ccr = 0;
    }
    else if (cb_type == EVT_LINE_FIELD) //this event will be called per field of line
    {
        std::unique_ptr<idx_ccr> pccr(idx_get_ccr(context->ctr.ccr));

        //std::cout << "Key:" << key << " Value:" << value << " opcodeFieldMap[key]:" << ofm[key] << "\n";
        switch (ofm[key]) 
        { 
            case PCM::EVENT_SELECT:
                pccr->set_event_select(numValue);
                //std::cout << "pccr value:" << std::hex << pccr->get_ccr_value() <<"\n" << std::dec;
                break;
            case PCM::ENABLE:
                pccr->set_enable(numValue);
                //std::cout << "pccr value:" << std::hex << pccr->get_ccr_value() <<"\n" << std::dec;
                break;
            case EVENT_CATEGORY:
                pccr->set_event_category(numValue);
                //std::cout << "pccr value:" << std::hex << pccr->get_ccr_value() <<"\n" << std::dec;
                break;
            case FILTER_WQ:
                context->ctr.cfr_wq = (uint32_t)numValue;
                break;
            case FILTER_ENG:
                context->ctr.cfr_eng = (uint32_t)numValue;
                break;
            case FILTER_TC:
                context->ctr.cfr_tc = (uint32_t)numValue;
                break;
            case FILTER_PGSZ:
                context->ctr.cfr_pgsz = (uint32_t)numValue;
                break;
            case FILTER_XFERSZ:
                context->ctr.cfr_xfersz = (uint32_t)numValue;
                break;
            case PCM::INVALID:
            default:
                std::cerr << "Field in -o file not recognized. The key is: " << key << "\n";
                return -1;
        }
    }
    else if(cb_type == EVT_LINE_COMPLETE) //this event will be called every line(end)
    {
        if (context->accel == ACCEL_IAA && base_ctr.h_event_name != "IAA")
        {
            return 0; //skip non-IAA cfg line
        }
        else if(context->accel == ACCEL_DSA && base_ctr.h_event_name != "DSA")
        {
            return 0; //skip non-DSA cfg line
        }
        else if(context->accel == ACCEL_QAT && base_ctr.h_event_name != "QAT")
        {
            return 0; //skip non-QAT cfg line
        }

        //Validate the total number of counter exceed the maximum or not.
        if ((uint32)base_ctr.idx >= accs_->getMaxNumOfAccelCtrs())
        {
            std::cerr << "line parse KO due to invalid value!" << std::dec << "\n";
            return 0; //skip the invalid cfg line
        }

        context->ctr.h_event_name = base_ctr.h_event_name;
        context->ctr.v_event_name = base_ctr.v_event_name;
        context->ctr.idx = base_ctr.idx;
        context->ctr.multiplier = base_ctr.multiplier;
        context->ctr.divider = base_ctr.divider;
        context->ctr.h_id = base_ctr.h_id;
        context->ctr.v_id = base_ctr.v_id;
        //std::cout << "line parse OK, ctrcfg=0x" << std::hex << context->ctr.ccr << ", h_event_name=" <<  base_ctr.h_event_name << ", v_event_name=" << base_ctr.v_event_name;
        //std::cout << ", h_id=0x" << std::hex << base_ctr.h_id << ", v_id=0x" << std::hex << base_ctr.v_id;
        //std::cout << ", idx=0x"<< std::hex << base_ctr.idx << ", multiplier=0x" << std::hex << base_ctr.multiplier << ", divider=0x" << std::hex << base_ctr.divider << std::dec << "\n";
        context->ctrs.push_back(context->ctr);
    }
    
    return 0;
}

std::vector<struct accel_counter>& AcceleratorCounterState::getCounters(){
    return evt_ctx.ctrs;
}

uint32_t AcceleratorCounterState::getAccel()
{
    return evt_ctx.accel;
}

void readAccelCounters(SystemCounterState& sycs_)
{
    AcceleratorCounterState *accs_ = AcceleratorCounterState::getInstance();
    PCM *pcm = PCM::getInstance();
    // const uint32_t delay_ms = uint32_t(delay * 1000);
    const uint32_t dev_count = accs_->getNumOfAccelDevs();
    const uint32_t counter_nb = accs_->getCounters().size();
    pcm->setNumberofAccelCounters(dev_count*counter_nb);
    uint32_t ctr_index = 0;
    // accel_content accel_results(ACCEL_MAX, dev_content(ACCEL_IP_DEV_COUNT_MAX, ctr_data()));
    sycs_.accel_counters.resize(size_t(dev_count) * size_t(counter_nb));
    SimpleCounterState *currState = new SimpleCounterState[dev_count*counter_nb];
    // programAccelCounters(m, accel, ctrs);

    switch (accs_->getAccel())
    {
        case ACCEL_IAA:
        case ACCEL_DSA:
            for (uint32_t dev = 0; dev != dev_count; ++dev)
            {
                ctr_index = 0;
                for (auto pctr = accs_->getCounters().begin(); pctr != accs_->getCounters().end(); ++pctr)
                {
                    sycs_.accel_counters[dev*counter_nb + ctr_index] = accs_->getAccelCounterState( dev, ctr_index);
                    ctr_index++;
                }
            }
            break;

        case ACCEL_QAT:
            // MySleepMs(delay_ms);

            for (uint32_t dev = 0; dev != dev_count; ++dev)
            { 
               pcm->controlQATTelemetry(dev, PCM::QAT_TLM_REFRESH);
               ctr_index = 0;
               for (auto pctr = accs_->getCounters().begin();pctr != accs_->getCounters().end(); ++pctr)
               {
                   sycs_.accel_counters[dev*counter_nb + ctr_index] = accs_->getAccelCounterState(dev, ctr_index);

                //    raw_result = currState[dev*counter_nb + ctr_index].getRawData();
                //    trans_result = uint64_t (raw_result * pctr->multiplier / (double) pctr->divider );

                //accel_result[evt_ctx.accel][dev][std::pair<h_id,v_id>(pctr->h_id,pctr->v_id)] = trans_result;
                //std::cout << "collect_data: accel=" << accel << " dev=" << dev << " h_id=" << pctr->h_id << " v_id=" << pctr->v_id << " data=" << std::hex << trans_result << "\n" << std::dec;
                   ctr_index++;
               }
            }
            break;
    }

    deleteAndNullifyArray(currState);
    
}

AcceleratorCounterState* AcceleratorCounterState::instance = NULL;

std::mutex instanceCreationMutexForAcceleratorCounterState{};

AcceleratorCounterState * AcceleratorCounterState::getInstance()
 {
    // lock-free read
    // cppcheck-suppress identicalConditionAfterEarlyExit
    if (instance) return instance;

    std::unique_lock<std::mutex> _(instanceCreationMutexForAcceleratorCounterState);
    // cppcheck-suppress identicalConditionAfterEarlyExit
    if (instance) return instance;

    return instance = new AcceleratorCounterState();
 }

std::string AcceleratorCounterState::remove_string_inside_use(std::string text) {
    std::string result = "";
    int open_use_count = 0;
    for (char c : text) {
        if (c == '(') {
            open_use_count += 1;
        } else if (c == ')' ) {
            open_use_count -= 1;
        } else if (open_use_count == 0) {
            result += c;
        }
    }
    return result;
}

void AcceleratorCounterState::setEvents(PCM *m,ACCEL_IP  accel, std::string specify_evtfile,bool evtfile)
{
    evt_ctx.m = m;
    evt_ctx.accel = accel;
    if (isAccelCounterAvailable() == true)
    {
        if (evtfile==false) //All platform use the spr config file by default.
        {
            ev_file_name = "opCode-6-143-accel.txt";
        }
        else
        {
            ev_file_name = specify_evtfile;
        }
        //std::cout << "load event config file from:" << ev_file_name << "\n";
    }
    else
    {
        std::cerr << "Error: " << getAccelCounterName() << " device is NOT available/ready with this platform! Program aborted\n";
        exit(EXIT_FAILURE);
    }

    switch (accel)
    {
        case ACCEL_IAA:
        case ACCEL_DSA:
        case ACCEL_QAT:
            opcodeFieldMap["hname"] = PCM::H_EVENT_NAME;
            opcodeFieldMap["vname"] = PCM::V_EVENT_NAME;
            opcodeFieldMap["multiplier"] = PCM::MULTIPLIER;
            opcodeFieldMap["divider"] = PCM::DIVIDER;
            opcodeFieldMap["ctr"] = PCM::COUNTER_INDEX;
            opcodeFieldMap["en"] = PCM::ENABLE;
            opcodeFieldMap["ev_sel"] = PCM::EVENT_SELECT;
            opcodeFieldMap["ev_cat"] = EVENT_CATEGORY;
            opcodeFieldMap["filter_wq"] = FILTER_WQ;
            opcodeFieldMap["filter_eng"] = FILTER_ENG;
            opcodeFieldMap["filter_tc"] = FILTER_TC;
            opcodeFieldMap["filter_pgsz"] = FILTER_PGSZ;
            opcodeFieldMap["filter_xfersz"] = FILTER_XFERSZ;

            p_evt_handler = idx_evt_parse_handler;
            evt_ctx.ctrs.clear();//fill the ctrs by evt_handler callback func.
            break;
        default:
            std::cerr << "Error: Accel type=0x" << std::hex << accel << " is not supported! Program aborted\n" << std::dec;
            exit(EXIT_FAILURE);
    }

    try
    {
        load_events(ev_file_name, opcodeFieldMap, p_evt_handler, (void *)&evt_ctx);
    }
    catch (std::exception & e)
    {
        std::cerr << "Error: " << e.what() << "\n";
        std::cerr << "Error: event cfg file have the problem, please double check it! Program aborted\n";
        exit(EXIT_FAILURE);
    }
    if (evt_ctx.ctrs.size() ==0 || evt_ctx.ctrs.size() > getMaxNumOfAccelCtrs())
    {
        std::cout<< evt_ctx.ctrs.size()<< " " << getMaxNumOfAccelCtrs();
        std::cerr << "Error: event counter size is 0 or exceed maximum, please check the event cfg file! Program aborted\n";
        exit(EXIT_FAILURE);
    }

    if (accel == ACCEL_QAT)
    {
        const uint32_t dev_count = getNumOfAccelDevs();
        for (uint32_t dev = 0; dev != dev_count; ++dev)
        {
            m->controlQATTelemetry(dev, PCM::QAT_TLM_START); //start the QAT telemetry service
        }
    }
}
```

`src/pcm-accel-common.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2022-2023, Intel Corporation
// written by White.Hu, Pavithran P

#pragma once
#include "cpucounters.h"
#ifdef __linux__
#include <sys/utsname.h>
#endif
using namespace pcm;

#define PCM_DELAY_DEFAULT 3.0 // in seconds

class idx_ccr {
    public:
        virtual uint64_t get_event_select() const = 0;
        virtual void set_event_select(uint64_t value) = 0;
        virtual uint64_t get_event_category() const  = 0;
        virtual void set_event_category(uint64_t value) = 0;
        virtual uint64_t get_enable() const  = 0;
        virtual void set_enable(uint64_t value) = 0;
        virtual uint64_t get_ccr_value() const  = 0;
        virtual void set_ccr_value(uint64_t value) = 0;
        virtual ~idx_ccr() {};
};

class spr_idx_ccr: public idx_ccr {
    public:
        spr_idx_ccr(uint64_t &v){
             ccr_value = &v;
        }
        virtual uint64_t get_event_select() const  { //EVENT bit, bit 32
             return ((*ccr_value >> 32) & 0xFFFFFFF);
        }
        virtual void set_event_select(uint64_t value) {
             *ccr_value |= (value << 32);
        }
        virtual uint64_t get_event_category() const  { //EVENT Categorg, bit 8
             return ((*ccr_value >> 8) & 0xF);
        }
        virtual void set_event_category(uint64_t value) {
             *ccr_value |= (value << 8);
        }
        virtual uint64_t get_enable() const  { //Enable counter, bit 0
             return ((*ccr_value >> 0 ) & 0x01);
        }
        virtual void set_enable(uint64_t value) {
             *ccr_value |= (value << 0);
        }
        virtual uint64_t get_ccr_value() const {
             return *ccr_value;
        }
        virtual void set_ccr_value(uint64_t value) {
             *ccr_value = value;
        }

    private:
        uint64_t* ccr_value = NULL;
};

idx_ccr* idx_get_ccr(uint64_t& ccr);

typedef enum
{
    ACCEL_IAA,
    ACCEL_DSA,
    ACCEL_QAT,
    ACCEL_MAX,
    ACCEL_NOCONFIG,
} ACCEL_IP;

enum IDXPerfmonField
{
    DPF_BASE = 0x100, //start from 0x100 to different with PerfmonField in cpucounter.h
    EVENT_CATEGORY,
    FILTER_WQ,
    FILTER_ENG,
    FILTER_TC,
    FILTER_PGSZ,
    FILTER_XFERSZ
};

typedef enum
{
    SOCKET_MAP,
    NUMA_MAP,
} ACCEL_DEV_LOC_MAPPING;

const std::vector<uint32_t> idx_accel_mapping = 
{
    PCM::IDX_IAA,
    PCM::IDX_DSA,
    PCM::IDX_QAT
};

#define ACCEL_IP_DEV_COUNT_MAX (16)

typedef uint32_t h_id;
typedef uint32_t v_id;
typedef std::map<std::pair<h_id,v_id>,uint64_t> ctr_data;
typedef std::vector<ctr_data> dev_content;
typedef std::vector<dev_content> accel_content;

struct accel_counter : public counter {
    //filter config for IDX Accelerator.
    uint32_t cfr_wq = 0;
    uint32_t cfr_eng = 0;
    uint32_t cfr_tc = 0;
    uint32_t cfr_pgsz = 0;
    uint32_t cfr_xfersz = 0;
};

typedef struct
{
    PCM *m;
    ACCEL_IP accel;
    accel_counter ctr;
    std::vector<struct accel_counter> ctrs;
} accel_evt_parse_context;

typedef int (*pfn_evt_handler)(evt_cb_type, void *, counter &, std::map<std::string, uint32_t> &, std::string, uint64);

int idx_evt_parse_handler(evt_cb_type cb_type, void *cb_ctx, counter &base_ctr, std::map<std::string, uint32_t> &ofm, std::string key, uint64 numValue);
void readAccelCounters(SystemCounterState &sycs_);

class AcceleratorCounterState {

    private:
        AcceleratorCounterState(){};     // forbidden to call directly because it is a singleton
        AcceleratorCounterState & operator = (const AcceleratorCounterState &) = delete;
        static AcceleratorCounterState * instance;
        accel_evt_parse_context evt_ctx = { {}, {}, {}, {} };
    public:
        AcceleratorCounterState(const AcceleratorCounterState& obj) = delete;
        // std::mutex instanceCreationMutex;
        static AcceleratorCounterState * getInstance();    
        std::map<std::string, uint32_t> opcodeFieldMap;
        std::string ev_file_name;
        pfn_evt_handler p_evt_handler = NULL;

        void setEvents(PCM * m,ACCEL_IP accel,std::string specify_evtfile,bool evtfile);
        uint32_t getNumOfAccelDevs();
        uint32_t getAccel();
        uint32_t getMaxNumOfAccelCtrs();
        std::vector<struct accel_counter>& getCounters();
        int32_t programAccelCounters();
        SimpleCounterState getAccelCounterState(uint32 dev, uint32 ctr_index);
        bool isAccelCounterAvailable();
        std::string getAccelCounterName();
        void setDSA();
        bool getAccelDevLocation( uint32_t dev, const ACCEL_DEV_LOC_MAPPING loc_map, uint32_t &location);
        // void readAccelCounters(SystemCounterState sycs_);
        int getNumberOfCounters();
        std::string getAccelIndexCounterName(int ctr_index);    
        std::string remove_string_inside_use(std::string text);
        uint64 getAccelIndexCounter(uint32 dev, const SystemCounterState & before,const SystemCounterState & after,int ctr_index);
    
};
```

`src/pcm-accel.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2022-2024, Intel Corporation
// written by White.Hu

#include "pcm-accel-common.h"
#ifdef _MSC_VER
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#endif
#include <memory>
#include <fstream>
#include <stdlib.h>
#include <stdexcept>      // std::length_error
#include <cstdint>
#include <numeric>
#include <algorithm>
#ifdef _MSC_VER
#include "freegetopt/getopt.h"
#endif
#include "lspci.h"
#include "utils.h"
using namespace pcm;
accel_content accel_results(ACCEL_MAX, dev_content(ACCEL_IP_DEV_COUNT_MAX, ctr_data()));
std::vector<std::string> build_counter_names(std::string dev_name, std::vector<struct accel_counter>& ctrs, const ACCEL_DEV_LOC_MAPPING loc_map)
{
    std::vector<std::string> v;
    std::map<uint32_t,std::map<uint32_t,struct accel_counter*>> v_sort;

    v.push_back(dev_name);
    
    switch (loc_map)
    {
        case SOCKET_MAP:
            v.push_back("Socket");
            break;
        case NUMA_MAP:
            v.push_back("NUMA Node");
            break;
        default:
            break;
    }

    //re-organize data collection to be row wise
    for (std::vector<struct accel_counter>::iterator counter = ctrs.begin(); counter != ctrs.end(); ++counter)
    {
        v_sort[counter->h_id][counter->v_id] = &(*counter);
    }
    
    for (std::map<uint32_t,std::map<uint32_t,struct accel_counter*>>::const_iterator hunit = v_sort.cbegin(); hunit != v_sort.cend(); ++hunit)
    {
       std::map<uint32_t, struct accel_counter*> v_array = hunit->second;

       //std::cout << "hunit: hhid=" << hh_id << "\n";
       for (std::map<uint32_t,struct accel_counter*>::const_iterator vunit = v_array.cbegin(); vunit != v_array.cend(); ++vunit)
       {
           std::string v_name = vunit->second->v_event_name;
           v.push_back(v_name);
       }
   }

   return v;
}

void print_usage(const std::string& progname)
{
    std::cout << "\n Usage: \n " << progname << " --help | [interval] [options] \n";
    std::cout << "   <interval>                           => time interval in seconds (floating point number is accepted)\n";
    std::cout << "                                        to sample performance counters.\n";
    std::cout << "                                        If not specified - 3.0 is used\n";
    std::cout << " Supported <options> are: \n";
    std::cout << "  -h    | --help  | /h               => print this help and exit\n";
    std::cout << "  -silent                            => silence information output and print only measurements\n";
    std::cout << "  -iaa | /iaa                        => print IAA accel device measurements(default)\n";
    std::cout << "  -dsa | /dsa                        => print DSA accel device measurements\n";
#ifdef __linux__
    std::cout << "  -qat | /qat                        => print QAT accel device measurements\n";
    std::cout << "  -numa | /numa                      => print accel device numa node mapping(for linux only)\n";
#endif
    std::cout << "  -evt[=cfg.txt] | /evt[=cfg.txt]    => specify the event cfg file to cfg.txt \n";
    std::cout << "  -csv[=file.csv] | /csv[=file.csv]  => output compact CSV format to screen or\n"
         << "                                        to a file, in case filename is provided\n";
    std::cout << "  -csv-delimiter=<value>  | /csv-delimiter=<value>   => set custom csv delimiter\n";
    std::cout << "  -human-readable | /human-readable  => use human readable format for output (for csv only)\n";
    std::cout << "  -i[=number] | /i[=number]          => allow to determine number of iterations\n";
    std::cout << " Examples:\n";
    std::cout << "  " << progname << " -iaa 1.0 -i=10             => print IAA counters every second 10 times and exit\n";
    std::cout << "  " << progname << " -iaa 0.5 -csv=test.log     => twice a second save IAA counter values to test.log in CSV format\n";
    std::cout << "  " << progname << " -iaa -csv -human-readable  => every 3 second print IAA counters in human-readable CSV format\n";
    std::cout << "\n";
}

std::vector<std::string> build_csv(const ACCEL_IP accel, std::vector<struct accel_counter>& ctrs,
    const bool human_readable, const std::string& csv_delimiter, accel_content& sample_data, const ACCEL_DEV_LOC_MAPPING loc_map)
{
    AcceleratorCounterState *accs_;
    accs_ = AcceleratorCounterState::getInstance();
    std::vector<std::string> result;
    std::vector<std::string> current_row;
    auto header = build_counter_names("Accelerator", ctrs, loc_map);
    result.push_back(build_csv_row(header, csv_delimiter));
    std::map<uint32_t,std::map<uint32_t,struct accel_counter*>> v_sort;
    uint32_t dev_count = accs_->getNumOfAccelDevs();

    for (uint32_t dev = 0; dev != dev_count; ++dev) 
    {
        //Re-organize data collection to be row wise
        std::map<uint32_t,std::map<uint32_t,struct accel_counter*>> v_sort;
        size_t max_name_width = 0;
        for (std::vector<struct accel_counter>::iterator counter = ctrs.begin(); counter != ctrs.end(); ++counter)
        {
            max_name_width = (std::max)(max_name_width, counter->v_event_name.size());
            v_sort[counter->h_id][counter->v_id] = &(*counter);
            //std::cout << "v_sort: h_id=" << std::hex << counter->h_id << ", v_id=" << std::hex << counter->v_id << "\n" << std::dec;
        }

        //Print data
        for (std::map<uint32_t,std::map<uint32_t,struct accel_counter*>>::const_iterator hunit = v_sort.cbegin(); hunit != v_sort.cend(); ++hunit)
        {
            std::map<uint32_t, struct accel_counter*> v_array = hunit->second;
            uint32_t hh_id = hunit->first;
            std::vector<uint64_t> v_data;
            std::string h_name = v_array[0]->h_event_name + "#" + std::to_string(dev);
            uint32 location = 0xff;

            current_row.clear();
            current_row.push_back(h_name); //dev name
			
            if (accs_->getAccelDevLocation( dev, loc_map, location) == true)
            {
                current_row.push_back(std::to_string(location)); //location info
            }

            //std::cout << "location mapping=" << loc_map << ", data=" << location << "\n";
            //std::cout << "hunit: hhid=" << hh_id << "\n";
            for (std::map<uint32_t,struct accel_counter*>::const_iterator vunit = v_array.cbegin(); vunit != v_array.cend(); ++vunit)
            {
                uint32_t vv_id = vunit->first;
                uint64_t raw_data = sample_data[accel][dev][std::pair<h_id,v_id>(hh_id,vv_id)];
                //std::cout << "vunit: hhid=" << hh_id << ", vname=" << vunit->second->v_event_name << ", data=" << raw_data << "\n";
                current_row.push_back(human_readable ? unit_format(raw_data) : std::to_string(raw_data)); //counter data
            }
            result.push_back(build_csv_row(current_row, csv_delimiter));
        }
    }
    
    return result;
}

std::vector<std::string> build_display(const ACCEL_IP accel, std::vector<struct accel_counter>& ctrs, accel_content& sample_data, const ACCEL_DEV_LOC_MAPPING loc_map)
{
    std::vector<std::string> buffer;
    std::vector<std::string> headers;
    std::vector<struct data> data;
    std::string row;
    AcceleratorCounterState *accs_;
    accs_ = AcceleratorCounterState::getInstance();
    uint32_t dev_count = accs_->getNumOfAccelDevs();

    headers = build_counter_names("Accelerator", ctrs, loc_map);
    //Print first row
    row = std::accumulate(headers.begin(), headers.end(), std::string(" "), a_header_footer);
    buffer.push_back(row);
    //Print a_title
    row = std::accumulate(headers.begin(), headers.end(), std::string("|"), a_title);
    buffer.push_back(row);
    //Print deliminator
    row = std::accumulate(headers.begin(), headers.end(), std::string("|"), a_header_footer);
    buffer.push_back(row);

    for (uint32_t dev = 0; dev != dev_count; ++dev)
    {
        //Print data
        std::map<uint32_t,std::map<uint32_t,struct accel_counter*>> v_sort;

        //re-organize data collection to be row wise
        for (std::vector<struct accel_counter>::iterator counter = ctrs.begin(); counter != ctrs.end(); ++counter)
        {
            v_sort[counter->h_id][counter->v_id] = &(*counter);
            //std::cout << "v_sort: h_id=" << std::hex << counter->h_id << ", v_id=" << std::hex << counter->v_id << "\n" << std::dec;
        }
        
        for (std::map<uint32_t,std::map<uint32_t,struct accel_counter*>>::const_iterator hunit = v_sort.cbegin(); hunit != v_sort.cend(); ++hunit)
        {
            std::map<uint32_t, struct accel_counter*> v_array = hunit->second;
            uint32_t hh_id = hunit->first;
            std::vector<uint64_t> v_data;
            std::string h_name = v_array[0]->h_event_name;
            uint32 location = 0xff;
            
            if (accs_->getAccelDevLocation(dev, loc_map, location) == true)
            {
                v_data.push_back(location); //location info
            }

            //std::cout << "location mapping=" << loc_map << ", data=" << location << "\n";
            //std::cout << "hunit: hhid=" << hh_id << "\n";
            for (std::map<uint32_t,struct accel_counter*>::const_iterator vunit = v_array.cbegin(); vunit != v_array.cend(); ++vunit)
            {
                uint32_t vv_id = vunit->first;
                uint64_t raw_data = sample_data[accel][dev][std::pair<h_id,v_id>(hh_id,vv_id)];
                //std::cout << "vunit: hhid=" << hh_id << ", vname=" << vunit->second->v_event_name << ", data=" << raw_data << "\n";
                v_data.push_back(raw_data); //counter data
            }
            data = prepare_data(v_data, headers);

            row = "| " + h_name + "#" + std::to_string(dev); //dev name
            row += std::string(abs(int(headers[0].size() - (row.size() - 1))), ' ');
            row += std::accumulate(data.begin(), data.end(), std::string("|"), a_data);

            buffer.push_back(row);
        }

    }

    //Print deliminator
    row = std::accumulate(headers.begin(), headers.end(), std::string("|"), a_header_footer);
    buffer.push_back(row);
    //Print footer
    row = std::accumulate(headers.begin(), headers.end(), std::string(" "), a_header_footer);
    buffer.push_back(row);

    return buffer;
}

void collect_data(PCM *m, const double delay, const ACCEL_IP accel, std::vector<struct accel_counter>& ctrs)
{
    const uint32_t delay_ms = uint32_t(delay * 1000);
    SimpleCounterState *before, *after;
    AcceleratorCounterState *accs_;
    accs_ = AcceleratorCounterState::getInstance();
    const uint32_t dev_count = accs_->getNumOfAccelDevs();
    const uint32_t counter_nb = ctrs.size();
    uint32_t ctr_index = 0;

    before = new SimpleCounterState[dev_count*counter_nb];
    after = new SimpleCounterState[dev_count*counter_nb];

    switch (accel)
    {
        case ACCEL_IAA:
        case ACCEL_DSA:
            for (uint32_t dev = 0; dev != dev_count; ++dev)
            {
                ctr_index = 0;
                for (auto pctr = ctrs.begin(); pctr != ctrs.end(); ++pctr)
                {
                    before[dev*counter_nb + ctr_index] = accs_->getAccelCounterState(dev, ctr_index);
                    ctr_index++;
                }
            }
            MySleepMs(delay_ms);
            for (uint32_t dev = 0; dev != dev_count; ++dev)
            {
                ctr_index = 0;
                for (auto pctr = ctrs.begin();pctr != ctrs.end(); ++pctr)
                {
                    after[dev*counter_nb + ctr_index] = accs_->getAccelCounterState(dev, ctr_index);
                    uint64_t raw_result = getNumberOfEvents(before[dev*counter_nb + ctr_index], after[dev*counter_nb + ctr_index]);
                    uint64_t trans_result = uint64_t (raw_result * pctr->multiplier / (double) pctr->divider * (1000 / (double) delay_ms));
                    accel_results[accel][dev][std::pair<h_id,v_id>(pctr->h_id,pctr->v_id)] = trans_result;
                    //std::cout << "collect_data: accel=" << accel << " dev=" << dev << " h_id=" << pctr->h_id << " v_id=" << pctr->v_id << " data=" << std::hex << trans_result << "\n" << std::dec;
                    ctr_index++;
                }
            }
            break;

        case ACCEL_QAT:
            MySleepMs(delay_ms);

            for (uint32_t dev = 0; dev != dev_count; ++dev)
            {
               m->controlQATTelemetry(dev, PCM::QAT_TLM_REFRESH);
               ctr_index = 0;
               for (auto pctr = ctrs.begin();pctr != ctrs.end(); ++pctr)
               {
                   after[dev*counter_nb + ctr_index] = accs_->getAccelCounterState(dev, ctr_index);

                   uint64_t raw_result = after[dev*counter_nb + ctr_index].getRawData();
                   uint64_t trans_result = uint64_t (raw_result * pctr->multiplier / (double) pctr->divider );

                   accel_results[accel][dev][std::pair<h_id,v_id>(pctr->h_id,pctr->v_id)] = trans_result;
                   //std::cout << "collect_data: accel=" << accel << " dev=" << dev << " h_id=" << pctr->h_id << " v_id=" << pctr->v_id << " data=" << std::hex << trans_result << "\n" << std::dec;
                   ctr_index++;
               }
            }
            break;

        default:
            break;
    }

    deleteAndNullifyArray(before);
    deleteAndNullifyArray(after);
}





PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
    null_stream nullStream;
    check_and_set_silent(argc, argv, nullStream);
    set_signal_handlers();

    std::cout << "\n Intel(r) Performance Counter Monitor " << PCM_VERSION ;
    std::cout << "\n This utility measures Sapphire Rapids-SP accelerators information.\n";

    std::string program = std::string(argv[0]);
    bool csv = false;
    bool human_readable = false;
    std::string csv_delimiter = ",";
    std::string output_file;
    double delay = PCM_DELAY_DEFAULT;
    ACCEL_IP accel=ACCEL_IAA; //default is IAA
    bool evtfile = false;
    std::string specify_evtfile;
    ACCEL_DEV_LOC_MAPPING loc_map = SOCKET_MAP; //default is socket mapping
    MainLoop mainLoop;
    PCM * m;
    AcceleratorCounterState *accs_;
    accs_ = AcceleratorCounterState::getInstance();

    std::string ev_file_name;

    while (argc > 1) 
    {
        argv++;
        argc--;
        std::string arg_value;
        if (check_argument_equals(*argv, {"--help", "-h", "/h"}))
        {
            print_usage(program);
            exit(EXIT_FAILURE);
        }
        else if (check_argument_equals(*argv, {"-silent", "/silent"}))
        {
            //handled in check_and_set_silent
            continue;
        }
        else if (extract_argument_value(*argv, {"-csv-delimiter", "/csv-delimiter"}, arg_value))
        {
            csv_delimiter = std::move(arg_value);
        }
        else if (check_argument_equals(*argv, {"-csv", "/csv"}))
        {
            csv = true;
        }
        else if (extract_argument_value(*argv, {"-csv", "/csv"}, arg_value))
        {
            csv = true;
            output_file = std::move(arg_value);
        }
        else if (check_argument_equals(*argv, {"-human-readable", "/human-readable"}))
        {
            human_readable = true;
        }
        else if (check_argument_equals(*argv, {"-iaa", "/iaa"}))
        {
            accel = ACCEL_IAA;
        }
        else if (check_argument_equals(*argv, {"-dsa", "/dsa"}))
        {
            accel = ACCEL_DSA;
        }
#ifdef __linux__
        else if (check_argument_equals(*argv, {"-qat", "/qat"}))
        {
            accel = ACCEL_QAT;
        }
        else if (check_argument_equals(*argv, {"-numa", "/numa"}))
        {
            loc_map = NUMA_MAP;
        }
#endif
        else if (extract_argument_value(*argv, {"-evt", "/evt"}, arg_value))
        {
            evtfile = true;
            specify_evtfile = std::move(arg_value);
        }
        else if (mainLoop.parseArg(*argv))
        {
            continue;
        }
        else
        {
            delay = parse_delay(*argv, program, (print_usage_func)print_usage);
            continue;
        }
    }

    print_cpu_details();

#ifdef __linux__
    // check kernel version for driver dependency.
    std::cout << "Info: IDX - Please ensure the required driver(e.g idxd driver for iaa/dsa, qat driver and etc) correct enabled with this system, else the tool may fail to run.\n";
    struct utsname sys_info;
    if (!uname(&sys_info))
    {
        std::string krel_str;
        uint32 krel_major_ver=0, krel_minor_ver=0;
        krel_str = sys_info.release;
        std::vector<std::string> krel_info = split(krel_str, '.');
        std::istringstream iss_krel_major(krel_info[0]);
        std::istringstream iss_krel_minor(krel_info[1]);
        iss_krel_major >> std::setbase(0) >> krel_major_ver;
        iss_krel_minor >> std::setbase(0) >> krel_minor_ver;

        switch (accel)
        {
            case ACCEL_IAA:
            case ACCEL_DSA:
                if ((krel_major_ver < 5) || (krel_major_ver == 5 && krel_minor_ver < 11))
                {
                    std::cout<< "Warning: IDX - current linux kernel version(" << krel_str << ") is too old, please upgrade it to the latest due to required idxd driver integrated to kernel since 5.11.\n";
                }
                break;
            default:
                break;
        }
    }
#endif

    try
    {
        m = PCM::getInstance();
    }
    catch (std::exception & e)
    {
        std::cerr << "Error: " << e.what() << "\n";
        exit(EXIT_FAILURE);
    }

    if (m->supportIDXAccelDev() == false)
    {
        std::cerr << "Error: IDX accelerator is NOT supported with this platform! Program aborted\n";
        exit(EXIT_FAILURE);
    }

    accs_->setEvents(m,accel,specify_evtfile,evtfile);

    std::ostream* output = &std::cout;
    std::fstream file_stream;
    if (!output_file.empty()) 
    {
        file_stream.open(output_file.c_str(), std::ios_base::out);
        output = &file_stream;
    }    
    accs_->programAccelCounters();
    std::vector<accel_counter> CTRS= accs_->getCounters();
    mainLoop([&]()
    {
        
        collect_data(m, delay, accel, CTRS);
        std::vector<std::string> display_buffer = csv ?
                    build_csv( accel, CTRS, human_readable, csv_delimiter, accel_results, loc_map) :
                    build_display( accel, CTRS, accel_results, loc_map);
        display(display_buffer, *output);
        return true;
    });

    file_stream.close();
    exit(EXIT_SUCCESS);
}

```

`src/pcm-bw-histogram.sh`:

```sh
#!/bin/sh


if [ "$#" -ne 1 ]; then
  echo
  echo "Usage: $0 <duration>" >&2
  echo
  echo "duration is in the same format as the argument of sleep command:"
  echo
  sleep --help
  exit 1
fi

mydir=$(dirname "$0")

out=bw-tmp

rm $out

echo
echo ========= CHECKING FOR PMM SUPPORT =========
echo
"$mydir/pcm-memory" -pmm -- sleep 1 >tmp 2>&1
dram_only=`cat tmp | grep "PMM traffic metrics are not available"  | wc -l`
rm tmp
if [ $dram_only -gt 0 ]
then
                echo PMM support is not present
else
                echo PMM support is present
fi


echo
echo ========= MEASURING =========
echo

if [ $dram_only -gt 0 ]
then
                chrt --rr 1 nice --adjustment=-20 "$mydir/pcm-memory" 0.005 -nc -csv=$out -- sleep $1
else
                chrt --rr 1 nice --adjustment=-20 "$mydir/pcm-memory" 0.005 -pmm -nc -csv=$out -- sleep $1
fi

cat $out | sed 's/;/,/g' > $out.csv

num_sockets=`lscpu | grep Socket | awk '{print $2}'`

echo
echo ======== POST-PROCESSING ====
echo

for s in `seq 0 $(($num_sockets-1))`; do

echo ============ Socket $s ============;
if [ $dram_only -gt 0 ]
then
                cat $out.csv | cut -d, -f$((4*s+6)) | awk '{ n=n+1; f[int($1/10000)] = f[int($1/10000)] + 1; } END { print "bandwidth(GB/s),count,time(%),chart"; for (i=0; i<32; i++) { if(i in f){ v=100.*f[i]/n; printf "%d-%d\t,%d\t,%3.2f\t,",i*10,(i+1)*10,f[i],v; for (j=0; j<v; j++) printf "#"; print "";  }}}';
else
                cat $out.csv | cut -d, -f$((5*s+7)) | awk '{ n=n+1; f[int($1/10000)] = f[int($1/10000)] + 1; } END { print "Memory bandwidth(GB/s),count,time(%),chart"; for (i=0; i<32; i++) { if(i in f){ v=100.*f[i]/n; printf "%d-%d\t,%d\t,%3.2f\t,",i*10,(i+1)*10,f[i],v; for (j=0; j<v; j++) printf "#"; print "";  }}}';
                cat $out.csv | cut -d, -f$((5*s+5)) | awk '{ n=n+1; f[int($1/1000)] = f[int($1/1000)] + 1; } END { print "PMM read bandwidth(GB/s),count,time(%),chart"; for (i=0; i<32; i++) { if(i in f){ v=100.*f[i]/n; printf "%d-%d\t,%d\t,%3.2f\t,",i,(i+1),f[i],v; for (j=0; j<v; j++) printf "#"; print "";  }}}';
                cat $out.csv | cut -d, -f$((5*s+6)) | awk '{ n=n+1; f[int($1/1000)] = f[int($1/1000)] + 1; } END { print "PMM write bandwidth(GB/s),count,time(%),chart"; for (i=0; i<32; i++) { if(i in f){ v=100.*f[i]/n; printf "%d-%d\t,%d\t,%3.2f\t,",i,(i+1),f[i],v; for (j=0; j<v; j++) printf "#"; print "";  }}}';

fi

done


```

`src/pcm-core.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Patrick Lu


/*!     \file pcm-core.cpp
  \brief Example of using CPU counters: implements a performance counter monitoring utility for Intel Core, Offcore events
  */
#include <iostream>
#ifdef _MSC_VER
#define strtok_r strtok_s
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#include <signal.h>
#include <sys/time.h> // for gettimeofday()
#endif
#include <math.h>
#include <iomanip>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <string>
#include <assert.h>
#include <bitset>
#include "cpucounters.h"
#include "utils.h"
#ifdef _MSC_VER
#include "freegetopt/getopt.h"
#endif

#include <vector>
#define PCM_DELAY_DEFAULT 1.0 // in seconds
#define PCM_DELAY_MIN 0.015 // 15 milliseconds is practical on most modern CPUs
#define MAX_CORES 4096

using namespace std;
using namespace pcm;

void build_event(const char * argv, EventSelectRegister *reg, int idx);

struct CoreEvent
{
	char name[256];
	uint64 value;
	uint64 msr_value;
	char * description;
} events[PERF_MAX_CUSTOM_COUNTERS];

#ifdef PCM_SHARED_LIBRARY

extern "C" {
	static std::shared_ptr<SystemCounterState> globalSysBeforeState, globalSysAfterState;
	static std::shared_ptr<std::vector<CoreCounterState> > globalBeforeState, globalAfterState;
	static std::shared_ptr<std::vector<SocketCounterState> > globalDummySocketStates;
	static EventSelectRegister globalRegs[PERF_MAX_COUNTERS];
	static PCM::ExtendedCustomCoreEventDescription globalConf;

	int pcm_c_build_core_event(uint8_t idx, const char * argv)
	{
		if(idx > 3)
			return -1;

		cout << "building core event " << argv << " " << idx << "\n";
		build_event(argv, &globalRegs[idx], idx);
		return 0;
	}

	int pcm_c_init()
	{
		PCM * m = PCM::getInstance();
		globalSysBeforeState = std::make_shared<SystemCounterState>();
		globalSysAfterState = std::make_shared<SystemCounterState>();
		globalBeforeState = std::make_shared<std::vector<CoreCounterState> >();
		globalAfterState = std::make_shared<std::vector<CoreCounterState> >();
		globalDummySocketStates = std::make_shared<std::vector<SocketCounterState> >();
		globalConf.fixedCfg = NULL; // default
		globalConf.nGPCounters = m->getMaxCustomCoreEvents();
		globalConf.gpCounterCfg = globalRegs;
		globalConf.OffcoreResponseMsrValue[0] = events[0].msr_value;
		globalConf.OffcoreResponseMsrValue[1] = events[1].msr_value;

		m->resetPMU();
		PCM::ErrorCode status = m->program(PCM::EXT_CUSTOM_CORE_EVENTS, &globalConf);
		if(status == PCM::Success)
			return 0;
		else
			return -1;
	}

	void pcm_c_start()
	{
		PCM * m = PCM::getInstance();
		m->getAllCounterStates(*globalSysBeforeState.get(), *globalDummySocketStates.get(), *globalBeforeState.get());
	}

	void pcm_c_stop()
	{
		PCM * m = PCM::getInstance();
		m->getAllCounterStates(*globalSysAfterState.get(), *globalDummySocketStates.get(), *globalAfterState.get());
	}

	uint64_t pcm_c_get_cycles(uint32_t core_id)
	{
		return getCycles((*globalBeforeState.get())[core_id], (*globalAfterState.get())[core_id]);
	}

	uint64_t pcm_c_get_instr(uint32_t core_id)
	{
		return getInstructionsRetired((*globalBeforeState.get())[core_id], (*globalAfterState.get())[core_id]);
	}

	uint64_t pcm_c_get_core_event(uint32_t core_id, uint32_t event_id)
	{
		return getNumberOfCustomEvents(event_id, (*globalBeforeState.get())[core_id], (*globalAfterState.get())[core_id]);
	}
}

#endif // PCM_SHARED_LIBRARY

void print_usage(const string & progname)
{
	cout << "\n Usage: \n " << progname
		 << " --help | [delay] [options] [-- external_program [external_program_options]]\n";
	cout << "   <delay>                               => time interval to sample performance counters.\n";
	cout << "                                            If not specified, or 0, with external program given\n";
	cout << "                                            will read counters only after external program finishes\n";
	cout << " Supported <options> are: \n";
	cout << "  -h    | --help      | /h               => print this help and exit\n";
	cout << "  -silent                                => silence information output and print only measurements\n";
	cout << "  --version                              => print application version\n";
	cout << "  -c    | /c                             => print CPU Model name and exit (used for pmu-query.py)\n";
	cout << "  -csv[=file.csv]     | /csv[=file.csv]  => output compact CSV format to screen or\n"
		<< "                                            to a file, in case filename is provided\n";
    cout << "  [-e event1] [-e event2] [-e event3] .. => optional list of custom events to monitor\n";
	cout << "  event description example: cpu/umask=0x01,event=0x05,name=MISALIGN_MEM_REF.LOADS/ \n";
	cout << "  -yc   | --yescores  | /yc              => enable specific cores to output\n";
	cout << "  -i[=number] | /i[=number]              => allow to determine number of iterations\n";
    print_help_force_rtm_abort_mode(41);
	cout << " Examples:\n";
	cout << "  " << progname << " 1                   => print counters every second without core and socket output\n";
	cout << "  " << progname << " 0.5 -csv=test.log   => twice a second save counter values to test.log in CSV format\n";
	cout << "  " << progname << " /csv 5 2>/dev/null  => one sample every 5 seconds, and discard all diagnostic output\n";
	cout << "\n";
}

	template <class StateType>
void print_custom_stats(const StateType & BeforeState, const StateType & AfterState ,bool csv, uint64 txn_rate)
{
    const uint64 cycles = getCycles(BeforeState, AfterState);
    const uint64 refCycles = getRefCycles(BeforeState, AfterState);
    const uint64 instr = getInstructionsRetired(BeforeState, AfterState);
	if(!csv)
	{
		cout << double(instr)/double(cycles);
		if(txn_rate == 1)
		{
			cout << setw(14) << unit_format(instr);
			cout << setw(11) << unit_format(cycles);
			cout << setw(12) << unit_format(refCycles);
		} else {
			cout << setw(14) << double(instr)/double(txn_rate);
			cout << setw(11) << double(cycles)/double(txn_rate);
			cout << setw(12) << double(refCycles) / double(txn_rate);
		}
	}
	else
	{
		cout << double(instr)/double(cycles) << ",";
		cout << double(instr)/double(txn_rate) << ",";
		cout << double(cycles)/double(txn_rate) << ",";
		cout << double(refCycles) / double(txn_rate) << ",";
	}
    const auto max_ctr = PCM::getInstance()->getMaxCustomCoreEvents();
    for (int i = 0; i < max_ctr; ++i)
		if(!csv) {
			cout << setw(10);
			if(txn_rate == 1)
				cout << unit_format(getNumberOfCustomEvents(i, BeforeState, AfterState));
			else
				cout << double(getNumberOfCustomEvents(i, BeforeState, AfterState))/double(txn_rate);
		}
		else
			cout << double(getNumberOfCustomEvents(i, BeforeState, AfterState))/double(txn_rate) << ",";

	cout << "\n";
}

// emulates scanf %i for hex 0x prefix otherwise assumes dec (no oct support)
bool match(const char * subtoken, const char * name, int * result)
{
    std::string sname(name);
    if (pcm_sscanf(subtoken) >> s_expect(sname + "0x") >> std::hex >> *result)
        return true;

    if (pcm_sscanf(subtoken) >> s_expect(sname) >> std::dec >> *result)
        return true;

    return false;
}

void build_event(const char * argv, EventSelectRegister *reg, int idx)
{
	char *token, *subtoken, *saveptr1, *saveptr2;
	char *str1, *str2;
	int j, tmp;
	uint64 tmp2;
	reg->value = 0;
	reg->fields.usr = 1;
	reg->fields.os = 1;
	reg->fields.enable = 1;

	/*
	   uint64 apic_int : 1;

	   offcore_rsp=2,period=10000
	   */
	for (j = 1, str1 = (char*) argv; ; j++, str1 = NULL) {
		token = strtok_r(str1, "/", &saveptr1);
		if (token == NULL)
			break;
		printf("%d: %s\n", j, token);
		if(strncmp(token,"cpu",3) == 0)
			continue;

		for (str2 = token; ; str2 = NULL) {
			tmp = -1;
			subtoken = strtok_r(str2, ",", &saveptr2);
			if (subtoken == NULL)
				break;
			if(match(subtoken,"event=",&tmp))
				reg->fields.event_select = tmp;
			else if(match(subtoken,"umask=",&tmp))
				reg->fields.umask = tmp;
			else if(strcmp(subtoken,"edge") == 0)
				reg->fields.edge = 1;
			else if(match(subtoken,"any=",&tmp))
				reg->fields.any_thread = tmp;
			else if(match(subtoken,"inv=",&tmp))
				reg->fields.invert = tmp;
			else if(match(subtoken,"cmask=",&tmp))
				reg->fields.cmask = tmp;
			else if(match(subtoken,"in_tx=",&tmp))
				reg->fields.in_tx = tmp;
			else if(match(subtoken,"in_tx_cp=",&tmp))
				reg->fields.in_txcp = tmp;
			else if(match(subtoken,"pc=",&tmp))
				reg->fields.pin_control = tmp;
			else if(pcm_sscanf(subtoken) >> s_expect("offcore_rsp=") >> std::hex >> tmp2) {
				if(idx >= 2)
				{
					cerr << "offcore_rsp must specify in first or second event only. idx=" << idx << "\n";
					throw idx;
				}
				events[idx].msr_value = tmp2;
			}
			else if(pcm_sscanf(subtoken) >> s_expect("name=") >> setw(255) >> events[idx].name) {
				if (check_for_injections(events[idx].name))
					throw events[idx].name;
			}
			else
			{
				cerr << "Event '" << subtoken << "' is not supported. See the list of supported events\n";
				throw subtoken;
			}

		}
	}
	events[idx].value = reg->value;
}

PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
	if(print_version(argc, argv))
		exit(EXIT_SUCCESS);

	null_stream nullStream2;
#ifdef PCM_FORCE_SILENT
	null_stream nullStream1;
	std::cout.rdbuf(&nullStream1);
	std::cerr.rdbuf(&nullStream2);
#else
	check_and_set_silent(argc, argv, nullStream2);
#endif

	set_signal_handlers();

	cerr << "\n";
	cerr << " Intel(r) Performance Counter Monitor: Core Monitoring Utility \n";
	cerr << "\n";

	double delay = -1.0;
	char *sysCmd = NULL;
	char **sysArgv = NULL;
	uint32 cur_event = 0;
	bool csv = false;
	uint64 txn_rate = 1;
	MainLoop mainLoop;
	string program = string(argv[0]);
	EventSelectRegister regs[PERF_MAX_COUNTERS];
	PCM::ExtendedCustomCoreEventDescription conf;
	bool show_partial_core_output = false;
	std::bitset<MAX_CORES> ycores;


        PCM * m = PCM::getInstance();

	conf.fixedCfg = NULL; // default
	conf.nGPCounters = m->getMaxCustomCoreEvents();
	conf.gpCounterCfg = regs;

	if(argc > 1) do
	{
		argv++;
		argc--;
		string arg_value;

		if (check_argument_equals(*argv, {"--help", "-h", "/h"}))
		{
			print_usage(program);
			exit(EXIT_FAILURE);
		}
		else if (check_argument_equals(*argv, {"-silent", "/silent"}))
		{
			// handled in check_and_set_silent
			continue;
		}
		else if (check_argument_equals(*argv, {"-csv", "/csv"}))
		{
			csv = true;
		}
		else if (extract_argument_value(*argv, {"-csv", "/csv"}, arg_value))
		{
			csv = true;
			if (!arg_value.empty()) {
				m->setOutput(arg_value);
			}
			continue;
		}
		else if (mainLoop.parseArg(*argv))
		{
			continue;
		}
		else if (check_argument_equals(*argv, {"-c", "/c"}))
		{
			cout << m->getCPUFamilyModelString() << "\n";
			exit(EXIT_SUCCESS);
		}
		else if (check_argument_equals(*argv, {"-txn", "/txn"}))
		{
			argv++;
			argc--;
			txn_rate = strtoull(*argv,NULL,10);
			cout << "txn_rate set to " << txn_rate << "\n";
			continue;
		}
		else if (check_argument_equals(*argv, {"--yescores", "-yc", "/yc"}))
		{
			argv++;
			argc--;
			show_partial_core_output = true;
			if(*argv == NULL)
			{
				cerr << "Error: --yescores requires additional argument.\n";
				exit(EXIT_FAILURE);
			}
			std::stringstream ss(*argv);
			while(ss.good())
			{
				string s;
				int core_id;
				std::getline(ss, s, ',');
				if(s.empty())
					continue;
				core_id = atoi(s.c_str());
				if(core_id > MAX_CORES)
				{
					cerr << "Core ID:" << core_id << " exceed maximum range " << MAX_CORES << ", program abort\n";
					exit(EXIT_FAILURE);
				}

				ycores.set(atoi(s.c_str()),true);
			}
			if(m->getNumCores() > MAX_CORES)
			{
				cerr << "Error: --yescores option is enabled, but #define MAX_CORES " << MAX_CORES << " is less than  m->getNumCores() = " << m->getNumCores() << "\n";
				cerr << "There is a potential to crash the system. Please increase MAX_CORES to at least " << m->getNumCores() << " and re-enable this option.\n";
				exit(EXIT_FAILURE);
			}
			continue;
		}
		else if (check_argument_equals(*argv, {"-e"}))
		{
			argv++;
			argc--;

			if(cur_event >= conf.nGPCounters) {
				cerr << "At most " << conf.nGPCounters << " events are allowed\n";
				exit(EXIT_FAILURE);
			}
			try {
				build_event(*argv,&regs[cur_event],cur_event);
				cur_event++;
			} catch (...) {
				exit(EXIT_FAILURE);
			}
			continue;
		}
		else if (CheckAndForceRTMAbortMode(*argv, m))
		{
			continue;
		}
		else if (check_argument_equals(*argv, {"--"}))
		{
			argv++;
			sysCmd = *argv;
			sysArgv = argv;
			break;
		}
		else
		{
			delay = parse_delay(*argv, program, (print_usage_func)print_usage);
			continue;
		}
	} while(argc > 1); // end of command line parsing loop

	if ( cur_event == 0 )
		cerr << "WARNING: you did not provide any custom events, is this intentional?\n";

	conf.OffcoreResponseMsrValue[0] = events[0].msr_value;
	conf.OffcoreResponseMsrValue[1] = events[1].msr_value;

	PCM::ErrorCode status = m->program(PCM::EXT_CUSTOM_CORE_EVENTS, &conf);
    m->checkError(status);

    print_cpu_details();

	uint64 BeforeTime = 0, AfterTime = 0;
	SystemCounterState SysBeforeState, SysAfterState;
	const uint32 ncores = m->getNumCores();
	std::vector<CoreCounterState> BeforeState, AfterState;
	std::vector<SocketCounterState> DummySocketStates;

	if ( (sysCmd != NULL) && (delay<=0.0) ) {
		// in case external command is provided in command line, and
		// delay either not provided (-1) or is zero
		m->setBlocked(true);
	} else {
		m->setBlocked(false);
	}

	if (csv) {
		if( delay<=0.0 ) delay = PCM_DELAY_DEFAULT;
	} else {
		// for non-CSV mode delay < 1.0 does not make a lot of practical sense: 
		// hard to read from the screen, or
		// in case delay is not provided in command line => set default
		if( ((delay<1.0) && (delay>0.0)) || (delay<=0.0) ) delay = PCM_DELAY_DEFAULT;
	}

	cerr << "Update every " << delay << " seconds\n";

	std::cout.precision(2);
	std::cout << std::fixed; 

	BeforeTime = m->getTickCount();
	m->getAllCounterStates(SysBeforeState, DummySocketStates, BeforeState);

	if( sysCmd != NULL ) {
		MySystem(sysCmd, sysArgv);
	}


	mainLoop([&]()
	{
		if(!csv) cout << std::flush;

		calibratedSleep(delay, sysCmd, mainLoop, m);

		AfterTime = m->getTickCount();
		m->getAllCounterStates(SysAfterState, DummySocketStates, AfterState);

		cout << "Time elapsed: " << dec << fixed << AfterTime-BeforeTime << " ms\n";
		cout << "txn_rate: " << txn_rate << "\n";
		//cout << "Called sleep function for " << dec << fixed << delay_ms << " ms\n";

		for(uint32 i=0;i<cur_event;++i)
		{
			cout << "Event" << i << ": " << events[i].name << " (raw 0x" <<
				std::hex << (uint32)events[i].value;

			if(events[i].msr_value)
				cout << ", offcore_rsp 0x" << (uint64) events[i].msr_value;

			cout << std::dec << ")\n";
		}
		cout << "\n";
        if (csv)
        {
            cout << "Core,IPC,Instructions,Cycles,RefCycles";
            for (unsigned i = 0; i < conf.nGPCounters; ++i)
            {
                cout << ",Event" << i;
            }
            cout << "\n";
        }
        else
        {
            cout << "Core | IPC | Instructions  |  Cycles  | RefCycles ";
            for (unsigned i = 0; i < conf.nGPCounters; ++i)
            {
                cout << "| Event" << i << "  ";
            }
            cout << "\n";
        }

		for(uint32 i = 0; i<ncores ; ++i)
		{
			if(m->isCoreOnline(i) == false || (show_partial_core_output && ycores.test(i) == false))
				continue;
			if(csv)
				cout << i << ",";
			else
				cout << " " << setw(3) << i << "   " << setw(2) ;
			print_custom_stats(BeforeState[i], AfterState[i], csv, txn_rate);
		}
		if(csv)
			cout << "*,";
		else
		{
			cout << "---------------------------------------------------------------------------------------------------------------------------------\n";
			cout << "   *   ";
		}
		print_custom_stats(SysBeforeState, SysAfterState, csv, txn_rate);

		std::cout << "\n";

		swap(BeforeTime, AfterTime);
		swap(BeforeState, AfterState);
		swap(SysBeforeState, SysAfterState);

		if ( m->isBlocked() ) {
			// in case PCM was blocked after spawning child application: break monitoring loop here
			return false;
		}
		return true;
	});
	exit(EXIT_SUCCESS);
}

```

`src/pcm-iio-pmu.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2017-2025, Intel Corporation

// written by Patrick Lu,
//            Aaron Cruz
//            Alexander Antonov
//            and others
#include <numeric>

#include "pcm-iio-pmu.h"
#include "pcm-iio-topology.h"

vector<string> combine_stack_name_and_counter_names(string stack_name, const PCIeEventNameMap& nameMap)
{
    vector<string> v;
    vector<string> tmp(nameMap.size());
    v.push_back(stack_name);
    for (auto iunit = nameMap.begin(); iunit != nameMap.end(); ++iunit) {
        string h_name = iunit->first;
        int h_id = (iunit->second).first;
        tmp[h_id] = h_name;
        //cout << "h_id:" << h_id << " name:" << h_name << "\n";
    }
    //XXX: How to simplify and just combine tmp & v?
    for (uint32_t i = 0; i < nameMap.size(); i++) {
        v.push_back(tmp[i]);
    }
    return v;
}

string build_pci_header(const PCIDB & pciDB, uint32_t column_width, const struct pci &p, int part, uint32_t level)
{
    string s = "|";
    char bdf_buf[32];
    char speed_buf[10];
    char vid_did_buf[10];
    char device_name_buf[128];

    snprintf(bdf_buf, sizeof(bdf_buf), "%04X:%02X:%02X.%1d", p.bdf.domainno, p.bdf.busno, p.bdf.devno, p.bdf.funcno);
    snprintf(speed_buf, sizeof(speed_buf), "Gen%1d x%-2d", p.link_speed, p.link_width);
    snprintf(vid_did_buf, sizeof(vid_did_buf), "%04X:%04X", p.vendor_id, p.device_id);
    snprintf(device_name_buf, sizeof(device_name_buf), "%s %s",
            (pciDB.first.count(p.vendor_id) > 0)?pciDB.first.at(p.vendor_id).c_str():"unknown vendor",
            (pciDB.second.count(p.vendor_id) > 0 && pciDB.second.at(p.vendor_id).count(p.device_id) > 0)?pciDB.second.at(p.vendor_id).at(p.device_id).c_str():"unknown device"
        );
    s += bdf_buf;
    s += '|';
    s += speed_buf;
    s += '|';
    s += vid_did_buf;
    s += " ";
    s += device_name_buf;

    if (!p.parts_no.empty()) {
        s += "; Part: ";
        for (auto& part : p.parts_no) {
            s += std::to_string(part) + ", ";
        }
        s.erase(s.size() - 2);
    }

    /* row with data */
    if (part >= 0) {
        s.insert(1,"P" + std::to_string(part) + " ");
        s += std::string(column_width - (s.size()-1), ' ');
    } else { /* row without data, just child pci device */
        s.insert(0, std::string(4*level, ' '));
    }

    return s;
}

void build_pci_tree(vector<string> &buffer, const PCIDB & pciDB, uint32_t column_width, const struct pci &p, int part, uint32_t level)
{
    string row;
    for (const auto& child : p.child_pci_devs) {
        row = build_pci_header(pciDB, column_width, child, part, level);
        buffer.push_back(row);
        if (child.hasChildDevices())
            build_pci_tree(buffer, pciDB, column_width, child, part, level + 1);
    }
}

std::string get_root_port_dev(const bool show_root_port, int part_id,  const pcm::iio_stack *stack)
{
    char tmp[9] = "        ";
    std::string rp_pci;

    if (!show_root_port)
        return rp_pci;

    for (auto part = stack->parts.begin(); part != stack->parts.end(); part = std::next(part))
    {
        if (part->part_id == part_id)
        {
            std::snprintf(tmp, sizeof(tmp), "%02x:%02x.%x", part->root_pci_dev.bdf.busno,
                        part->root_pci_dev.bdf.devno, part->root_pci_dev.bdf.funcno);
            break;
        }
    }

    rp_pci.append(tmp);
    return rp_pci;

}

class PcmIioCsvBuilder : public PcmIioOutputBuilder {
public:
    PcmIioCsvBuilder(struct pcm_iio_config& config) : PcmIioOutputBuilder(config) {}

    ~PcmIioCsvBuilder() = default;

    vector<string> buildDisplayBuffer() override;
private:
    void insertTimeStamp(vector<string> & out, CsvOutputType type);
};

void PcmIioCsvBuilder::insertTimeStamp(vector<string> & out, CsvOutputType type)
{
    std::string dateTime;
    printDateForCSV(type, m_config.display.csv_delimiter, &dateTime);
    // remove last delimiter
    dateTime.pop_back();
    out.insert(out.begin(), dateTime);
}

vector<string> PcmIioCsvBuilder::buildDisplayBuffer()
{
    vector<string> result;
    vector<string> current_row;
    auto header = combine_stack_name_and_counter_names("Part", m_config.pmu_config.pcieEventNameMap);
    header.insert(header.begin(), "Name");
    if (m_config.display.show_root_port)
        header.insert(header.begin(), "Root Port");
    header.insert(header.begin(), "Socket");
    insertTimeStamp(header, CsvOutputType::Header2);
    result.push_back(build_csv_row(header, m_config.display.csv_delimiter));
    std::map<uint32_t,map<uint32_t,struct iio_counter*>> v_sort;
    //re-organize data collection to be row wise
    size_t max_name_width = 0;
    for (auto counter = m_config.pmu_config.evt_ctx.ctrs.begin(); counter != m_config.pmu_config.evt_ctx.ctrs.end(); ++counter) {
        v_sort[counter->v_id][counter->h_id] = &(*counter);
        max_name_width = (std::max)(max_name_width, counter->v_event_name.size());
    }

    for (auto socket = m_config.pmu_config.iios.cbegin(); socket != m_config.pmu_config.iios.cend(); ++socket) {
        for (auto stack = socket->stacks.cbegin(); stack != socket->stacks.cend(); ++stack) {
            const std::string socket_name = "Socket" + std::to_string(socket->socket_id);

            std::string stack_name = stack->stack_name;
            if (!m_config.display.human_readable) {
                stack_name.erase(stack_name.find_last_not_of(' ') + 1);
            }

            const uint32_t stack_id = stack->iio_unit_id;
            //Print data
            int part_id;
            std::map<uint32_t,map<uint32_t,struct iio_counter*>>::const_iterator vunit;
            for (vunit = v_sort.cbegin(), part_id = 0;
                    vunit != v_sort.cend(); ++vunit, ++part_id) {
                map<uint32_t, struct iio_counter*> h_array = vunit->second;
                uint32_t vv_id = vunit->first;
                vector<uint64_t> h_data;
                string v_name = h_array[0]->v_event_name;
                if (m_config.display.human_readable) {
                    v_name += string(max_name_width - (v_name.size()), ' ');
                }

                current_row.clear();
                current_row.push_back(socket_name);
                if (m_config.display.show_root_port) {
                    auto pci_dev = get_root_port_dev(m_config.display.show_root_port, part_id, &(*stack));
                    current_row.push_back(pci_dev);
                }
                current_row.push_back(stack_name);
                current_row.push_back(v_name);
                for (map<uint32_t,struct iio_counter*>::const_iterator hunit = h_array.cbegin(); hunit != h_array.cend(); ++hunit) {
                    uint32_t hh_id = hunit->first;
                    uint64_t raw_data = hunit->second->data[0][socket->socket_id][stack_id][std::pair<h_id,v_id>(hh_id,vv_id)];
                    current_row.push_back(m_config.display.human_readable ? unit_format(raw_data) : std::to_string(raw_data));
                }
                insertTimeStamp(current_row, CsvOutputType::Data);
                result.push_back(build_csv_row(current_row, m_config.display.csv_delimiter));
            }
        }
    }
    return result;
}

class PcmIioDisplayBuilder : public PcmIioOutputBuilder {
public:
    PcmIioDisplayBuilder(struct pcm_iio_config& config) : PcmIioOutputBuilder(config) {}

    ~PcmIioDisplayBuilder() = default;

    vector<string> buildDisplayBuffer() override;
};

vector<string> PcmIioDisplayBuilder::buildDisplayBuffer()
{
    vector<string> buffer;
    vector<string> headers;
    vector<struct data> data;
    uint64_t header_width;
    string row;
    for (auto socket = m_config.pmu_config.iios.cbegin(); socket != m_config.pmu_config.iios.cend(); ++socket) {
        buffer.push_back("Socket" + std::to_string(socket->socket_id));
        for (auto stack = socket->stacks.cbegin(); stack != socket->stacks.cend(); ++stack) {
            auto stack_id = stack->iio_unit_id;
            headers = combine_stack_name_and_counter_names(stack->stack_name, m_config.pmu_config.pcieEventNameMap);
            //Print first row
            row = std::accumulate(headers.begin(), headers.end(), string(" "), a_header_footer);
            header_width = row.size();
            buffer.push_back(row);
            //Print a_title
            row = std::accumulate(headers.begin(), headers.end(), string("|"), a_title);
            buffer.push_back(row);
            //Print deliminator
            row = std::accumulate(headers.begin(), headers.end(), string("|"), a_header_footer);
            buffer.push_back(row);
            //Print data
            std::map<uint32_t,map<uint32_t,struct iio_counter*>> v_sort;
            //re-organize data collection to be row wise
            for (std::vector<struct iio_counter>::iterator counter = m_config.pmu_config.evt_ctx.ctrs.begin(); counter != m_config.pmu_config.evt_ctx.ctrs.end(); ++counter) {
                v_sort[counter->v_id][counter->h_id] = &(*counter);
            }
            for (std::map<uint32_t,map<uint32_t,struct iio_counter*>>::const_iterator vunit = v_sort.cbegin(); vunit != v_sort.cend(); ++vunit) {
                map<uint32_t, struct iio_counter*> h_array = vunit->second;
                uint32_t vv_id = vunit->first;
                vector<uint64_t> h_data;
                string v_name = h_array[0]->v_event_name;
                for (map<uint32_t,struct iio_counter*>::const_iterator hunit = h_array.cbegin(); hunit != h_array.cend(); ++hunit) {
                    uint32_t hh_id = hunit->first;
                    uint64_t raw_data = hunit->second->data[0][socket->socket_id][stack_id][std::pair<h_id,v_id>(hh_id,vv_id)];
                    h_data.push_back(raw_data);
                }
                data = prepare_data(h_data, headers);
                row = "| " + v_name;
                row += string(abs(int(headers[0].size() - (row.size() - 1))), ' ');
                row += std::accumulate(data.begin(), data.end(), string("|"), a_data);
                buffer.push_back(row);
            }
            //Print deliminator
            row = std::accumulate(headers.begin(), headers.end(), string("|"), a_header_footer);
            buffer.push_back(row);
            //Print pcie devices
            for (const auto& part : stack->parts) {
                uint8_t level = 1;
                for (const auto& pci_device : part.child_pci_devs) {
                    row = build_pci_header(m_config.pciDB, (uint32_t)header_width, pci_device, -1, level);
                    buffer.push_back(row);
                    if (pci_device.hasChildDevices()) {
                        build_pci_tree(buffer, m_config.pciDB, (uint32_t)header_width, pci_device, -1, level + 1);
                    } else if (pci_device.header_type == 1) {
                            level++;
                    }
                }
            }
            //Print footer
            row = std::accumulate(headers.begin(), headers.end(), string(" "), a_header_footer);
            buffer.push_back(row);
        }
    }
    return buffer;
}

std::unique_ptr<PcmIioOutputBuilder> getDisplayBuilder(struct pcm_iio_config& config)
{
    std::unique_ptr<PcmIioOutputBuilder> displayBuilder;
    if (config.display.csv) {
        displayBuilder = std::make_unique<PcmIioCsvBuilder>(config);
    } else {
        displayBuilder = std::make_unique<PcmIioDisplayBuilder>(config);
    }
    return displayBuilder;
}

ccr* get_ccr(uint32 cpu_family_model, uint64_t& ccr)
{
    switch (cpu_family_model)
    {
        case PCM::SKX:
            return new pcm::ccr(ccr, ccr::ccr_type::skx);
        case PCM::ICX:
        case PCM::SNOWRIDGE:
        case PCM::SPR:
        case PCM::EMR:
        case PCM::GRR:
        case PCM::SRF:
        case PCM::GNR:
        case PCM::GNR_D:
            return new pcm::ccr(ccr, ccr::ccr_type::icx);
        default:
            std::cerr << PCM::cpuFamilyModelToUArchCodename(cpu_family_model) << " is not supported! Program aborted" << std::endl;
            exit(EXIT_FAILURE);
    }
}

int iio_evt_parse_handler(evt_cb_type cb_type, void *cb_ctx, counter &base_ctr, std::map<std::string, uint32_t> &ofm, std::string key, uint64 numValue)
{
    iio_evt_parse_context *context = (iio_evt_parse_context *)cb_ctx;

    if (cb_type == EVT_LINE_START) //this event will be called per line(start)
    {
        context->ctr.ccr = 0;
    }
    else if (cb_type == EVT_LINE_FIELD) //this event will be called per field of line
    {
        std::unique_ptr<ccr> pccr(get_ccr(context->cpu_family_model, context->ctr.ccr));
        switch (ofm[key])
        {
            case PCM::OPCODE:
                break;
            case PCM::EVENT_SELECT:
                pccr->set_event_select(numValue);
                break;
            case PCM::UMASK:
                pccr->set_umask(numValue);
                break;
            case PCM::RESET:
                pccr->set_reset(numValue);
                break;
            case PCM::EDGE_DET:
                pccr->set_edge(numValue);
                break;
            case PCM::IGNORED:
                break;
            case PCM::OVERFLOW_ENABLE:
                pccr->set_ov_en(numValue);
                break;
            case PCM::ENABLE:
                pccr->set_enable(numValue);
                break;
            case PCM::INVERT:
                pccr->set_invert(numValue);
                break;
            case PCM::THRESH:
                pccr->set_thresh(numValue);
                break;
            case PCM::CH_MASK:
                pccr->set_ch_mask(numValue);
                break;
            case PCM::FC_MASK:
                pccr->set_fc_mask(numValue);
                break;
            case PCM::INVALID:
            default:
                std::cerr << "Field in -o file not recognized. The key is: " << key << "\n";
                return -1;
        }
    }
    else if (cb_type == EVT_LINE_COMPLETE) //this event will be called every line(end)
    {
        context->ctr.h_event_name = base_ctr.h_event_name;
        context->ctr.v_event_name = base_ctr.v_event_name;
        context->ctr.idx = base_ctr.idx;
        context->ctr.multiplier = base_ctr.multiplier;
        context->ctr.h_id = base_ctr.h_id;
        context->ctr.v_id = base_ctr.v_id;
        context->ctr.type = base_ctr.type;
        DBG(4, "line parse OK, ctrcfg=0x", std::hex, context->ctr.ccr, ", h_event_name=",  base_ctr.h_event_name, ", v_event_name=", base_ctr.v_event_name);
        DBG(4, ", h_id=0x", std::hex, base_ctr.h_id, ", v_id=0x", std::hex, base_ctr.v_id);
        DBG(4, ", idx=0x", std::hex, base_ctr.idx, ", multiplier=0x", std::hex, base_ctr.multiplier, std::dec, ", counter type = ", static_cast<int>(base_ctr.type), "\n");
        context->ctrs.push_back(context->ctr);
    }

    return 0;
}

class CounterHandlerStrategy {
public:
    CounterHandlerStrategy(PCM* pcm) : m_pcm(pcm) {}
    virtual ~CounterHandlerStrategy() = default;

    virtual void programCounters(uint64 rawEvents[4]) = 0;

    virtual SimpleCounterState getCounterState(uint32_t socket_id, uint32_t unit_id, uint32_t counter_idx) = 0;

protected:
    PCM* m_pcm;
};

class IIOCounterStrategy : public CounterHandlerStrategy {
public:
    IIOCounterStrategy(PCM* pcm) : CounterHandlerStrategy(pcm) {}

    void programCounters(uint64 rawEvents[4]) override
    {
        m_pcm->programIIOCounters(rawEvents);
    }

    SimpleCounterState getCounterState(uint32_t socket_id, uint32_t unit_id, uint32_t counter_idx) override
    {
        return m_pcm->getIIOCounterState(socket_id, unit_id, counter_idx);
    }
};

std::shared_ptr<CounterHandlerStrategy> createCounterStrategy(PCM* pcm, CounterType type)
{
    switch (type)
    {
    case CounterType::iio:
        return std::make_shared<IIOCounterStrategy>(pcm);
    default:
        std::cerr << "Unsupported counter type: " << static_cast<int>(type) << std::endl;
        exit(EXIT_FAILURE);
    }
}

void PcmIioDataCollector::initializeCounterHandlers()
{
    for (const auto& counter : m_config.evt_ctx.ctrs) {
        if (!m_strategies[static_cast<size_t>(counter.type)]) {
            m_strategies[static_cast<size_t>(counter.type)] = createCounterStrategy(m_pcm, counter.type);
        }
    }
}

PcmIioDataCollector::PcmIioDataCollector(struct pcm_iio_pmu_config& config) :
    m_config(config), m_strategies(static_cast<size_t>(CounterType::COUNTER_TYPES_COUNT), nullptr)
{
    m_pcm = PCM::getInstance();
    m_delay_ms = static_cast<uint32_t>(m_config.delay * 1000 / m_config.evt_ctx.ctrs.size());
    m_stacks_count = m_pcm->getMaxNumOfIOStacks();
    m_time_scaling_factor = 1000.0 / m_delay_ms;

    m_before = std::make_unique<SimpleCounterState[]>(m_config.iios.size() * m_stacks_count);
    m_after = std::make_unique<SimpleCounterState[]>(m_config.iios.size() * m_stacks_count);

    m_results.resize(m_pcm->getNumSockets(), stack_content(m_stacks_count, ctr_data()));

    initializeCounterHandlers();
}

void PcmIioDataCollector::collectData()
{
    for (auto& counter : m_config.evt_ctx.ctrs) {
        counter.data.clear();
        result_content sample = getSample(counter);
        counter.data.push_back(sample);
    }
}

result_content PcmIioDataCollector::getSample(struct iio_counter & ctr)
{
    uint64 rawEvents[COUNTERS_NUMBER] = {0};
    std::unique_ptr<ccr> pccr(get_ccr(m_pcm->getCPUFamilyModel(), ctr.ccr));
    rawEvents[ctr.idx] = pccr->get_ccr_value();

    auto strategy = m_strategies[static_cast<size_t>(ctr.type)];

    strategy->programCounters(rawEvents);
    for (const auto& socket : m_config.iios) {
        for (const auto& stack : socket.stacks) {
            auto iio_unit_id = stack.iio_unit_id;
            uint32_t idx = getStackIndex(socket.socket_id, iio_unit_id);
            m_before[idx] = strategy->getCounterState(socket.socket_id, iio_unit_id, ctr.idx);
        }
    }
    MySleepMs(m_delay_ms);
    for (const auto& socket : m_config.iios) {
        for (const auto& stack : socket.stacks) {
            auto iio_unit_id = stack.iio_unit_id;
            uint32_t idx = getStackIndex(socket.socket_id, iio_unit_id);
            m_after[idx] = strategy->getCounterState(socket.socket_id, iio_unit_id, ctr.idx);
            uint64_t raw_result = getNumberOfEvents(m_before[idx], m_after[idx]);
            uint64_t trans_result = static_cast<uint64_t>(raw_result * ctr.multiplier * m_time_scaling_factor);
            m_results[socket.socket_id][iio_unit_id][std::pair<h_id,v_id>(ctr.h_id, ctr.v_id)] = trans_result;
        }
    }
    return m_results;
}

void fillOpcodeFieldMapForPCIeEvents(map<string,uint32_t>& opcodeFieldMap)
{
    opcodeFieldMap["opcode"] = PCM::OPCODE;
    opcodeFieldMap["ev_sel"] = PCM::EVENT_SELECT;
    opcodeFieldMap["umask"] = PCM::UMASK;
    opcodeFieldMap["reset"] = PCM::RESET;
    opcodeFieldMap["edge_det"] = PCM::EDGE_DET;
    opcodeFieldMap["ignored"] = PCM::IGNORED;
    opcodeFieldMap["overflow_enable"] = PCM::OVERFLOW_ENABLE;
    opcodeFieldMap["en"] = PCM::ENABLE;
    opcodeFieldMap["invert"] = PCM::INVERT;
    opcodeFieldMap["thresh"] = PCM::THRESH;
    opcodeFieldMap["ch_mask"] = PCM::CH_MASK;
    opcodeFieldMap["fc_mask"] = PCM::FC_MASK;
    opcodeFieldMap["hname"] = PCM::H_EVENT_NAME;
    opcodeFieldMap["vname"] = PCM::V_EVENT_NAME;
    opcodeFieldMap["multiplier"] = PCM::MULTIPLIER;
    opcodeFieldMap["ctr"] = PCM::COUNTER_INDEX;
    opcodeFieldMap["unit"] = PCM::UNIT_TYPE;
}

bool setupPCIeEventContextAndNameMap( iio_evt_parse_context& evt_ctx, PCIeEventNameMap& nameMap)
{
    PCM * m = PCM::getInstance();

    string ev_file_name = "opCode-" + std::to_string(m->getCPUFamily()) + "-" + std::to_string(m->getInternalCPUModel()) + ".txt";

    map<string,uint32_t> opcodeFieldMap;
    fillOpcodeFieldMapForPCIeEvents( opcodeFieldMap );

    evt_ctx.cpu_family_model = m->getCPUFamilyModel();
    evt_ctx.ctrs.clear();//fill the ctrs by evt_handler call back func.

    try
    {
        load_events(ev_file_name, opcodeFieldMap, iio_evt_parse_handler, (void *)&evt_ctx, nameMap);
    }
    catch (const std::exception & e)
    {
        std::cerr << "Error info:" << e.what() << std::endl;
        std::cerr << "The event configuration file (" << ev_file_name << ") cannot be loaded. Please verify the file. Exiting." << std::endl;
        return false;
    }

    return true;
}

bool initializePCIeBWCounters(struct pcm_iio_pmu_config& pmu_config)
{
    PCM * m = PCM::getInstance();
    if (!m->IIOEventsAvailable())
    {
        cerr << "This CPU is not supported by PCM IIO tool! Program aborted\n";
        return false;
    }

    if (!IPlatformMapping::initializeIOStacksStructure(pmu_config.iios, m->getCPUFamilyModel(), m->getNumSockets(), m->getMaxNumOfIOStacks())) return false;

    return setupPCIeEventContextAndNameMap(pmu_config.evt_ctx, pmu_config.pcieEventNameMap);
}

```

`src/pcm-iio-pmu.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2017-2025, Intel Corporation

// written by Patrick Lu,
//            Aaron Cruz
//            Alexander Antonov
//            and others
#pragma once

#ifdef _MSC_VER
    #include <windows.h>
    #include "windows/windriver.h"
#else
    #include <unistd.h>
#endif

#include <memory>
#include <cstdint>
#include <algorithm>

#ifdef _MSC_VER
    #include "freegetopt/getopt.h"
#endif

#include "lspci.h"
#include "utils.h"
#include "cpucounters.h"

using namespace std;
using namespace pcm;

#define PCM_DELAY_DEFAULT 3.0 // in seconds

struct iio_counter : public counter {
  std::vector<result_content> data;
};

typedef struct
{
    uint32 cpu_family_model;
    iio_counter ctr;
    vector<struct iio_counter> ctrs;
} iio_evt_parse_context;

vector<string> combine_stack_name_and_counter_names(string stack_name, const PCIeEventNameMap& nameMap);

string build_pci_header(const PCIDB & pciDB, uint32_t column_width, const struct pci &p, int part = -1, uint32_t level = 0);

void build_pci_tree(vector<string> &buffer, const PCIDB & pciDB, uint32_t column_width, const struct pci &p, int part, uint32_t level = 0);

std::string get_root_port_dev(const bool show_root_port, int part_id,  const pcm::iio_stack *stack);

struct pcm_iio_display_config {
    bool csv            = false;
    bool human_readable = false;
    bool show_root_port = false;
    bool list           = false;
    std::string csv_delimiter = ",";
    std::string output_file   = "";
};

struct pcm_iio_pmu_config {
    double delay = PCM_DELAY_DEFAULT;
    // Map with metrics names.
    PCIeEventNameMap pcieEventNameMap;
    vector<struct iio_stacks_on_socket> iios;
    iio_evt_parse_context evt_ctx;
};

struct pcm_iio_config {
    struct pcm_iio_display_config display;
    struct pcm_iio_pmu_config pmu_config;
    PCIDB pciDB;
};

class PcmIioOutputBuilder {
public:
    PcmIioOutputBuilder(struct pcm_iio_config& config) : m_config(config) {}

    virtual ~PcmIioOutputBuilder() = default;

    virtual vector<string> buildDisplayBuffer() = 0;
protected:
    struct pcm_iio_config& m_config;
};

std::unique_ptr<PcmIioOutputBuilder> getDisplayBuilder(struct pcm_iio_config& config);

int iio_evt_parse_handler(evt_cb_type cb_type, void *cb_ctx, counter &base_ctr, std::map<std::string, uint32_t> &ofm, std::string key, uint64 numValue);

class CounterHandlerStrategy;

class PcmIioDataCollector {
public:
    PcmIioDataCollector(struct pcm_iio_pmu_config& config);
    ~PcmIioDataCollector() = default;

    void collectData();
private:
    struct pcm_iio_pmu_config& m_config;
    PCM *m_pcm;
    uint32_t m_delay_ms;
    uint32_t m_stacks_count;
    double m_time_scaling_factor;
    std::unique_ptr<SimpleCounterState[]> m_before;
    std::unique_ptr<SimpleCounterState[]> m_after;
    result_content m_results;
    std::vector<std::shared_ptr<CounterHandlerStrategy>> m_strategies;

    result_content getSample(struct iio_counter & ctr);
    void initializeCounterHandlers();

    uint32_t getStackIndex(uint32_t socket_id, uint32_t io_unit_id) const { return m_stacks_count * socket_id + io_unit_id; }

    static constexpr int COUNTERS_NUMBER = 4;
};

void fillOpcodeFieldMapForPCIeEvents(map<string,uint32_t>& opcodeFieldMap);

bool initializePCIeBWCounters(struct pcm_iio_pmu_config& pmu_config);


```

`src/pcm-iio-topology.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2017-2025, Intel Corporation

// written by Patrick Lu,
//            Aaron Cruz
//            Alexander Antonov
//            and others
#include <limits>
#include <numeric>
#include <set>
#include <unordered_map>
#include <unordered_set>

#include "pcm-iio-topology.h"

#define QAT_DID 0x18DA
#define NIS_DID 0x18D1
#define HQM_DID 0x270B

#define GRR_QAT_VRP_DID 0x5789 // Virtual Root Port to integrated QuickAssist (GRR QAT)
#define GRR_NIS_VRP_DID 0x5788 // VRP to Network Interface and Scheduler (GRR NIS)

#define ROOT_BUSES_OFFSET   0xCC
#define ROOT_BUSES_OFFSET_2 0xD0

#define SKX_SOCKETID_UBOX_DID 0x2014
#define SKX_UBOX_DEVICE_NUM   0x08
#define SKX_UBOX_FUNCTION_NUM 0x02
#define SKX_BUS_NUM_STRIDE    8
//the below LNID and GID applies to Skylake Server
#define SKX_UNC_SOCKETID_UBOX_LNID_OFFSET 0xC0
#define SKX_UNC_SOCKETID_UBOX_GID_OFFSET  0xD4

#define ICX_CBDMA_DMI_SAD_ID 0
#define ICX_MCP_SAD_ID       3

#define ICX_PCH_PART_ID   0
#define ICX_CBDMA_PART_ID 3

#define SNR_ICX_SAD_CONTROL_CFG_OFFSET 0x3F4
#define SNR_ICX_MESH2IIO_MMAP_DID      0x09A2

#define ICX_VMD_PCI_DEVNO   0x00
#define ICX_VMD_PCI_FUNCNO  0x05

#define SNR_ACCELERATOR_PART_ID 4

#define SNR_ROOT_PORT_A_DID 0x334A

#define SNR_CBDMA_DMI_SAD_ID 0
#define SNR_PCIE_GEN3_SAD_ID 1
#define SNR_HQM_SAD_ID       2
#define SNR_NIS_SAD_ID       3
#define SNR_QAT_SAD_ID       4

#define HQMV2_DID   0x2710 // Hardware Queue Manager v2
#define HQMV25_DID  0x2714 // Hardware Queue Manager v2.5
#define DSA_DID     0x0b25 // Data Streaming Accelerator (DSA)
#define IAX_DID     0x0cfe // In-Memory Database Analytics Accelerator (IAX)
#define QATV2_DID   0x4940 // QuickAssist (CPM) v2

#define SPR_DMI_PART_ID                7
#define SPR_XCC_HQM_PART_ID            5
#define SPR_MCC_HQM_PART_ID            4
#define SPR_XCC_QAT_PART_ID            4
#define SPR_MCC_QAT_PART_ID            5
#define SPR_SAD_CONTROL_CFG_OFFSET     SNR_ICX_SAD_CONTROL_CFG_OFFSET

#define SPR_PCU_CR3_DID 0x325b
#define SPR_PCU_CR3_REG_DEVICE 0x1e
#define SPR_PCU_CR3_REG_FUNCTION 0x03
#define SPR_CAPID4_OFFSET 0x94
#define SPR_CAPID4_GET_PHYSICAL_CHOP(capid4) ((capid4 >> 6) & 3)
#define SPR_PHYSICAL_CHOP_XCC 0b11
#define SPR_PHYSICAL_CHOP_MCC 0b01

#define SPR_XCC_DMI_PMON_ID         1
#define SPR_XCC_PCIE_GEN5_0_PMON_ID 2
#define SPR_XCC_PCIE_GEN5_1_PMON_ID 4
#define SPR_XCC_PCIE_GEN5_2_PMON_ID 6
#define SPR_XCC_PCIE_GEN5_3_PMON_ID 7
#define SPR_XCC_PCIE_GEN5_4_PMON_ID 9
#define SPR_XCC_IDX0_PMON_ID        0
#define SPR_XCC_IDX1_PMON_ID        3
#define SPR_XCC_IDX2_PMON_ID        5
#define SPR_XCC_IDX3_PMON_ID        8

#define SPR_MCC_DMI_PMON_ID         10
#define SPR_MCC_PCIE_GEN5_0_PMON_ID 0 // assumption
#define SPR_MCC_PCIE_GEN5_1_PMON_ID 1
#define SPR_MCC_PCIE_GEN5_2_PMON_ID 2
#define SPR_MCC_PCIE_GEN5_3_PMON_ID 4 // assumption
#define SPR_MCC_PCIE_GEN5_4_PMON_ID 5
#define SPR_MCC_IDX0_PMON_ID        3

// MS2IOSF stack IDs in CHA notation
#define GRR_PCH_DSA_GEN4_SAD_ID 0
#define GRR_DLB_SAD_ID          1
#define GRR_NIS_QAT_SAD_ID      2

#define GRR_PCH_DSA_GEN4_PMON_ID 2
#define GRR_DLB_PMON_ID          1
#define GRR_NIS_QAT_PMON_ID      0

#define GRR_DLB_PART_ID 0
#define GRR_NIS_PART_ID 0
#define GRR_QAT_PART_ID 1

#define EMR_DMI_PMON_ID         7
#define EMR_PCIE_GEN5_0_PMON_ID 1
#define EMR_PCIE_GEN5_1_PMON_ID 2
#define EMR_PCIE_GEN5_2_PMON_ID 3
#define EMR_PCIE_GEN5_3_PMON_ID 8
#define EMR_PCIE_GEN5_4_PMON_ID 6
#define EMR_IDX0_PMON_ID        0
#define EMR_IDX1_PMON_ID        4
#define EMR_IDX2_PMON_ID        5
#define EMR_IDX3_PMON_ID        9

#define SRF_PE0_PMON_ID         3
#define SRF_PE1_PMON_ID         4
#define SRF_PE2_PMON_ID         2
#define SRF_PE3_PMON_ID         5
/*
 * There are platform configuration when FlexUPI stacks (stacks 5 and 6) are enabled as
 * PCIe stack and PCIe ports are disabled (ports 2 and 3) and vice sersa. See details here:
 * In these cases the PMON IDs are different.
 * So, defines with _FLEX_ are applicable for cases when FlexUPI stacks
 * are working as PCIe ports.
 */
#define SRF_PE4_PMON_ID             11
#define SRF_FLEX_PE4_PMON_ID        13
#define SRF_PE5_PMON_ID             12
#define SRF_FLEX_PE5_PMON_ID        10

#define SRF_PE6_PMON_ID             0
#define SRF_PE7_PMON_ID             7
#define SRF_PE8_PMON_ID             8
#define SRF_HC0_PMON_ID             1
#define SRF_HC1_PMON_ID             6
#define SRF_HC2_PMON_ID             9
#define SRF_HC3_PMON_ID             14

#define SRF_PE0_SAD_BUS_ID         2
#define SRF_PE1_SAD_BUS_ID         3
#define SRF_PE2_SAD_BUS_ID         1
#define SRF_PE3_SAD_BUS_ID         4
#define SRF_PE4_SAD_BUS_ID         29
#define SRF_FLEX_PE4_SAD_BUS_ID    SRF_PE4_SAD_BUS_ID
#define SRF_PE5_SAD_BUS_ID         26
#define SRF_FLEX_PE5_SAD_BUS_ID    SRF_PE5_SAD_BUS_ID
#define SRF_PE6_SAD_BUS_ID         0  // UPI0
#define SRF_PE7_SAD_BUS_ID         5  // UPI1
#define SRF_PE8_SAD_BUS_ID         28 // UPI2
#define SRF_UBOXA_SAD_BUS_ID       30
#define SRF_UBOXB_SAD_BUS_ID       31

#define SRF_HC0_SAD_BUS_ID         8
#define SRF_HC1_SAD_BUS_ID         12
#define SRF_HC2_SAD_BUS_ID         20
#define SRF_HC3_SAD_BUS_ID         16

#define SRF_DSA_IAX_PART_NUMBER 0
#define SRF_HQM_PART_NUMBER     5
#define SRF_QAT_PART_NUMBER     4

// Mapping for SkyLake Server.
class PurleyPlatformMapping: public IPlatformMapping {
private:
    void getUboxBusNumbers(std::vector<uint32_t>& ubox);

    const std::string skx_iio_stack_names[6] = {
        "IIO Stack 0 - CBDMA/DMI      ",
        "IIO Stack 1 - PCIe0          ",
        "IIO Stack 2 - PCIe1          ",
        "IIO Stack 3 - PCIe2          ",
        "IIO Stack 4 - MCP0           ",
        "IIO Stack 5 - MCP1           "
    };
protected:
    bool pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios) override;
public:
    PurleyPlatformMapping(uint32_t model, uint32_t sockets) : IPlatformMapping(model, sockets) {}
    ~PurleyPlatformMapping() = default;
};

void PurleyPlatformMapping::getUboxBusNumbers(std::vector<uint32_t>& ubox)
{
    for (uint16_t bus = 0; bus < 256; bus++) {
        for (uint8_t device = 0; device < 32; device++) {
            for (uint8_t function = 0; function < 8; function++) {
                struct pci pci_dev;
                pci_dev.bdf.busno = (uint8_t)bus;
                pci_dev.bdf.devno = device;
                pci_dev.bdf.funcno = function;
                if (probe_pci(&pci_dev) && pci_dev.isIntelDeviceById(SKX_SOCKETID_UBOX_DID)) {
                    ubox.push_back(bus);
                }
            }
        }
    }
}

bool PurleyPlatformMapping::pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios)
{
    std::vector<uint32_t> ubox;
    getUboxBusNumbers(ubox);
    if (ubox.empty()) {
        cerr << "UBOXs were not found! Program aborted" << endl;
        return false;
    }

    for (uint32_t socket_id = 0; socket_id < socketsCount(); socket_id++) {
        if (!PciHandleType::exists(0, ubox[socket_id], SKX_UBOX_DEVICE_NUM, SKX_UBOX_FUNCTION_NUM)) {
            cerr << "No access to PCICFG\n" << endl;
            return false;
        }
        uint64 cpubusno = 0;
        struct iio_stacks_on_socket iio_on_socket;
        iio_on_socket.socket_id = socket_id;
        PciHandleType h(0, ubox[socket_id], SKX_UBOX_DEVICE_NUM, SKX_UBOX_FUNCTION_NUM);
        h.read64(ROOT_BUSES_OFFSET, &cpubusno);

        iio_on_socket.stacks.reserve(6);
        for (int stack_id = 0; stack_id < 6; stack_id++) {
            struct iio_stack stack;
            stack.iio_unit_id = stack_id;
            stack.busno = (uint8_t)(cpubusno >> (stack_id * SKX_BUS_NUM_STRIDE));
            stack.stack_name = skx_iio_stack_names[stack_id];
            for (uint8_t part_id = 0; part_id < 4; part_id++) {
                struct iio_bifurcated_part part;
                part.part_id = part_id;
                struct pci *pci = &part.root_pci_dev;
                struct bdf *bdf = &pci->bdf;
                bdf->busno = stack.busno;
                bdf->devno = part_id;
                bdf->funcno = 0;
                /* This is a workaround to catch some IIO stack does not exist */
                if (stack_id != 0 && stack.busno == 0) {
                    pci->exist = false;
                }
                else if (probe_pci(pci)) {
                    /* FIXME: for 0:0.0, we may need to scan from secondary switch down; lgtm [cpp/fixme-comment] */
                    for (uint8_t bus = pci->secondary_bus_number; bus <= pci->subordinate_bus_number; bus++) {
                        for (uint8_t device = 0; device < 32; device++) {
                            for (uint8_t function = 0; function < 8; function++) {
                                struct pci child_pci_dev;
                                child_pci_dev.bdf.busno = bus;
                                child_pci_dev.bdf.devno = device;
                                child_pci_dev.bdf.funcno = function;
                                if (probe_pci(&child_pci_dev)) {
                                    part.child_pci_devs.push_back(child_pci_dev);
                                }
                            }
                        }
                    }
                }
                stack.parts.push_back(part);
            }

            iio_on_socket.stacks.push_back(stack);
        }
        iios.push_back(iio_on_socket);
    }

    return true;
}

class IPlatformMapping10Nm: public IPlatformMapping {
private:
public:
    IPlatformMapping10Nm(uint32_t model, uint32_t sockets) : IPlatformMapping(model, sockets) {}
    ~IPlatformMapping10Nm() = default;
    bool getSadIdRootBusMap(uint32_t socket_id, std::map<uint8_t, uint8_t>& sad_id_bus_map);
};

bool IPlatformMapping10Nm::getSadIdRootBusMap(uint32_t socket_id, std::map<uint8_t, uint8_t>& sad_id_bus_map)
{
    for (uint16_t bus = 0; bus < 256; bus++) {
        for (uint8_t device = 0; device < 32; device++) {
            for (uint8_t function = 0; function < 8; function++) {
                struct pci pci_dev;
                pci_dev.bdf.busno = (uint8_t)bus;
                pci_dev.bdf.devno = device;
                pci_dev.bdf.funcno = function;
                if (probe_pci(&pci_dev) && pci_dev.isIntelDeviceById(SNR_ICX_MESH2IIO_MMAP_DID)) {

                    PciHandleType h(0, bus, device, function);
                    std::uint32_t sad_ctrl_cfg;
                    h.read32(SNR_ICX_SAD_CONTROL_CFG_OFFSET, &sad_ctrl_cfg);
                    if (sad_ctrl_cfg == (std::numeric_limits<uint32_t>::max)()) {
                        cerr << "Could not read SAD_CONTROL_CFG" << endl;
                        return false;
                    }

                    if ((sad_ctrl_cfg & 0xf) == socket_id) {
                        uint8_t sid = (sad_ctrl_cfg >> 4) & 0x7;
                        sad_id_bus_map.insert(std::pair<uint8_t, uint8_t>(sid, (uint8_t)bus));
                    }
                }
            }
        }
    }

    if (sad_id_bus_map.empty()) {
        cerr << "Could not find Root Port bus numbers" << endl;
        return false;
    }

    return true;
}

// Mapping for IceLake Server.
class WhitleyPlatformMapping: public IPlatformMapping10Nm {
private:
    const bool icx_d;
    const std::map<int, int>& sad_to_pmu_id_mapping;
    const std::string * iio_stack_names;

    const std::string icx_iio_stack_names[6] = {
        "IIO Stack 0 - PCIe0          ",
        "IIO Stack 1 - PCIe1          ",
        "IIO Stack 2 - MCP            ",
        "IIO Stack 3 - PCIe2          ",
        "IIO Stack 4 - PCIe3          ",
        "IIO Stack 5 - CBDMA/DMI      "
    };

    const std::string icx_d_iio_stack_names[6] = {
        "IIO Stack 0 - MCP            ",
        "IIO Stack 1 - PCIe0          ",
        "IIO Stack 2 - CBDMA/DMI      ",
        "IIO Stack 3 - PCIe2          ",
        "IIO Stack 4 - PCIe3          ",
        "IIO Stack 5 - PCIe1          "
    };

    const std::map<int, int> icx_sad_to_pmu_id_mapping = {
        { ICX_CBDMA_DMI_SAD_ID, 5 },
        { 1,                    0 },
        { 2,                    1 },
        { ICX_MCP_SAD_ID,       2 },
        { 4,                    3 },
        { 5,                    4 }
    };

    const std::map<int, int> icx_d_sad_to_pmu_id_mapping = {
        { ICX_CBDMA_DMI_SAD_ID, 2 },
        { 1,                    5 },
        { 2,                    1 },
        { ICX_MCP_SAD_ID,       0 },
        { 4,                    3 },
        { 5,                    4 }
    };
protected:
    bool pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios) override;
public:
    WhitleyPlatformMapping(uint32_t model, uint32_t sockets) : IPlatformMapping10Nm(model, sockets),
        icx_d(model == PCM::ICX_D),
        sad_to_pmu_id_mapping(icx_d ? icx_d_sad_to_pmu_id_mapping : icx_sad_to_pmu_id_mapping),
        iio_stack_names(icx_d ? icx_d_iio_stack_names : icx_iio_stack_names)
    {
    }
    ~WhitleyPlatformMapping() = default;
};

bool WhitleyPlatformMapping::pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios)
{
    for (uint32_t socket = 0; socket < socketsCount(); socket++) {
        struct iio_stacks_on_socket iio_on_socket;
        iio_on_socket.socket_id = socket;
        std::map<uint8_t, uint8_t> sad_id_bus_map;
        if (!getSadIdRootBusMap(socket, sad_id_bus_map)) {
            return false;
        }

        {
            struct iio_stack stack;
            stack.iio_unit_id = sad_to_pmu_id_mapping.at(ICX_MCP_SAD_ID);
            stack.stack_name = iio_stack_names[stack.iio_unit_id];
            iio_on_socket.stacks.push_back(stack);
        }

        for (auto sad_id_bus_pair = sad_id_bus_map.cbegin(); sad_id_bus_pair != sad_id_bus_map.cend(); ++sad_id_bus_pair) {
            int sad_id = sad_id_bus_pair->first;
            if (sad_to_pmu_id_mapping.find(sad_id) ==
                sad_to_pmu_id_mapping.end()) {
                cerr << "Unknown SAD ID: " << sad_id << endl;
                return false;
            }

            if (sad_id == ICX_MCP_SAD_ID) {
                continue;
            }

            struct iio_stack stack;
            int root_bus = sad_id_bus_pair->second;
            if (sad_id == ICX_CBDMA_DMI_SAD_ID) {
                // There is one DMA Controller on each socket
                stack.iio_unit_id = sad_to_pmu_id_mapping.at(sad_id);
                stack.busno = root_bus;
                stack.stack_name = iio_stack_names[stack.iio_unit_id];

                // PCH is on socket 0 only
                if (socket == 0) {
                    struct iio_bifurcated_part pch_part;
                    struct pci *pci = &pch_part.root_pci_dev;
                    struct bdf *bdf = &pci->bdf;
                    pch_part.part_id = ICX_PCH_PART_ID;
                    bdf->busno = root_bus;
                    bdf->devno = 0x00;
                    bdf->funcno = 0x00;
                    if (probe_pci(pci)) {
                        // Probe child devices only under PCH part.
                        for (uint8_t bus = pci->secondary_bus_number; bus <= pci->subordinate_bus_number; bus++) {
                            for (uint8_t device = 0; device < 32; device++) {
                                for (uint8_t function = 0; function < 8; function++) {
                                    struct pci child_pci_dev;
                                    child_pci_dev.bdf.busno = bus;
                                    child_pci_dev.bdf.devno = device;
                                    child_pci_dev.bdf.funcno = function;
                                    if (probe_pci(&child_pci_dev)) {
                                        pch_part.child_pci_devs.push_back(child_pci_dev);
                                    }
                                }
                            }
                        }
                        stack.parts.push_back(pch_part);
                    }
                }

                struct iio_bifurcated_part part;
                part.part_id = ICX_CBDMA_PART_ID;
                struct pci *pci = &part.root_pci_dev;
                struct bdf *bdf = &pci->bdf;
                bdf->busno = root_bus;
                bdf->devno = 0x01;
                bdf->funcno = 0x00;
                if (probe_pci(pci))
                    stack.parts.push_back(part);

                iio_on_socket.stacks.push_back(stack);
                continue;
            }
            stack.busno = root_bus;
            stack.iio_unit_id = sad_to_pmu_id_mapping.at(sad_id);
            stack.stack_name = iio_stack_names[stack.iio_unit_id];
            for (int slot = 2; slot < 6; slot++) {
                struct pci pci;
                pci.bdf.busno = root_bus;
                pci.bdf.devno = slot;
                pci.bdf.funcno = 0x00;
                if (!probe_pci(&pci)) {
                    continue;
                }
                struct iio_bifurcated_part part;
                part.part_id = slot - 2;
                part.root_pci_dev = pci;

                for (uint8_t bus = pci.secondary_bus_number; bus <= pci.subordinate_bus_number; bus++) {
                    for (uint8_t device = 0; device < 32; device++) {
                        for (uint8_t function = 0; function < 8; function++) {
                            struct pci child_pci_dev;
                            child_pci_dev.bdf.busno = bus;
                            child_pci_dev.bdf.devno = device;
                            child_pci_dev.bdf.funcno = function;
                            if (probe_pci(&child_pci_dev)) {
                                part.child_pci_devs.push_back(child_pci_dev);
                            }
                        }
                    }
                }
                stack.parts.push_back(part);
            }
            iio_on_socket.stacks.push_back(stack);
        }
        std::sort(iio_on_socket.stacks.begin(), iio_on_socket.stacks.end());
        iios.push_back(iio_on_socket);
    }
    return true;
}

// Mapping for Snowridge.
class JacobsvillePlatformMapping: public IPlatformMapping10Nm {
private:
    const std::map<int, int> snr_sad_to_pmu_id_mapping = {
        { SNR_CBDMA_DMI_SAD_ID, 1 },
        { SNR_PCIE_GEN3_SAD_ID, 4 },
        { SNR_HQM_SAD_ID      , 3 },
        { SNR_NIS_SAD_ID      , 2 },
        { SNR_QAT_SAD_ID      , 0 }
    };

    const std::string snr_iio_stack_names[5] = {
        "IIO Stack 0 - QAT            ",
        "IIO Stack 1 - CBDMA/DMI      ",
        "IIO Stack 2 - NIS            ",
        "IIO Stack 3 - HQM            ",
        "IIO Stack 4 - PCIe           "
    };
protected:
    bool pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios) override;
public:
    JacobsvillePlatformMapping(uint32_t model, uint32_t sockets) : IPlatformMapping10Nm(model, sockets) {}
    ~JacobsvillePlatformMapping() = default;
    bool JacobsvilleAccelerators(const std::pair<uint8_t, uint8_t>& sad_id_bus_pair, struct iio_stack& stack);
};

bool JacobsvillePlatformMapping::JacobsvilleAccelerators(const std::pair<uint8_t, uint8_t>& sad_id_bus_pair, struct iio_stack& stack)
{
    uint16_t expected_dev_id;
    auto sad_id = sad_id_bus_pair.first;
    switch (sad_id) {
    case SNR_HQM_SAD_ID:
        expected_dev_id = HQM_DID;
        break;
    case SNR_NIS_SAD_ID:
        expected_dev_id = NIS_DID;
        break;
    case SNR_QAT_SAD_ID:
        expected_dev_id = QAT_DID;
        break;
    default:
        return false;
    }
    stack.iio_unit_id = snr_sad_to_pmu_id_mapping.at(sad_id);
    stack.stack_name = snr_iio_stack_names[stack.iio_unit_id];
    for (uint16_t bus = sad_id_bus_pair.second; bus < 256; bus++) {
        for (uint8_t device = 0; device < 32; device++) {
            for (uint8_t function = 0; function < 8; function++) {
                struct pci pci_dev;
                pci_dev.bdf.busno = (uint8_t)bus;
                pci_dev.bdf.devno = device;
                pci_dev.bdf.funcno = function;
                if (probe_pci(&pci_dev)) {
                    if (expected_dev_id == pci_dev.device_id) {
                        struct iio_bifurcated_part part;
                        part.part_id = SNR_ACCELERATOR_PART_ID;
                        part.root_pci_dev = pci_dev;
                        stack.busno = (uint8_t)bus;
                        stack.parts.push_back(part);
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

bool JacobsvillePlatformMapping::pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios)
{
    std::map<uint8_t, uint8_t> sad_id_bus_map;
    if (!getSadIdRootBusMap(0, sad_id_bus_map)) {
        return false;
    }
    struct iio_stacks_on_socket iio_on_socket;
    iio_on_socket.socket_id = 0;
    if (sad_id_bus_map.size() != snr_sad_to_pmu_id_mapping.size()) {
        cerr << "Found unexpected number of stacks: " << sad_id_bus_map.size() << ", expected: " << snr_sad_to_pmu_id_mapping.size() << endl;
        return false;
    }

    for (auto sad_id_bus_pair = sad_id_bus_map.cbegin(); sad_id_bus_pair != sad_id_bus_map.cend(); ++sad_id_bus_pair) {
        int sad_id = sad_id_bus_pair->first;
        struct iio_stack stack;
        switch (sad_id) {
        case SNR_CBDMA_DMI_SAD_ID:
            {
                int root_bus = sad_id_bus_pair->second;
                stack.iio_unit_id = snr_sad_to_pmu_id_mapping.at(sad_id);
                stack.stack_name = snr_iio_stack_names[stack.iio_unit_id];
                stack.busno = root_bus;
                // DMA Controller
                struct iio_bifurcated_part part;
                part.part_id = 0;
                struct pci pci_dev;
                pci_dev.bdf.busno = root_bus;
                pci_dev.bdf.devno = 0x01;
                pci_dev.bdf.funcno = 0x00;
                if (probe_pci(&pci_dev)) {
                    part.root_pci_dev = pci_dev;
                    stack.parts.push_back(part);
                }

                part.part_id = 4;
                pci_dev.bdf.busno = root_bus;
                pci_dev.bdf.devno = 0x00;
                pci_dev.bdf.funcno = 0x00;
                if (probe_pci(&pci_dev)) {
                    for (uint8_t bus = pci_dev.secondary_bus_number; bus <= pci_dev.subordinate_bus_number; bus++) {
                        for (uint8_t device = 0; device < 32; device++) {
                            for (uint8_t function = 0; function < 8; function++) {
                                struct pci child_pci_dev;
                                child_pci_dev.bdf.busno = bus;
                                child_pci_dev.bdf.devno = device;
                                child_pci_dev.bdf.funcno = function;
                                if (probe_pci(&child_pci_dev)) {
                                    part.child_pci_devs.push_back(child_pci_dev);
                                }
                            }
                        }
                    }
                    part.root_pci_dev = pci_dev;
                    stack.parts.push_back(part);
                }
            }
            break;
        case SNR_PCIE_GEN3_SAD_ID:
            {
                int root_bus = sad_id_bus_pair->second;
                stack.busno = root_bus;
                stack.iio_unit_id = snr_sad_to_pmu_id_mapping.at(sad_id);
                stack.stack_name = snr_iio_stack_names[stack.iio_unit_id];
                for (int slot = 4; slot < 8; slot++) {
                    struct pci pci_dev;
                    pci_dev.bdf.busno = root_bus;
                    pci_dev.bdf.devno = slot;
                    pci_dev.bdf.funcno = 0x00;
                    if (!probe_pci(&pci_dev)) {
                        continue;
                    }
                    int part_id = 4 + pci_dev.device_id - SNR_ROOT_PORT_A_DID;
                    if ((part_id < 0) || (part_id > 4)) {
                        cerr << "Invalid part ID " << part_id << endl;
                        return false;
                    }
                    struct iio_bifurcated_part part;
                    part.part_id = part_id;
                    part.root_pci_dev = pci_dev;
                    for (uint8_t bus = pci_dev.secondary_bus_number; bus <= pci_dev.subordinate_bus_number; bus++) {
                        for (uint8_t device = 0; device < 32; device++) {
                            for (uint8_t function = 0; function < 8; function++) {
                                struct pci child_pci_dev;
                                child_pci_dev.bdf.busno = bus;
                                child_pci_dev.bdf.devno = device;
                                child_pci_dev.bdf.funcno = function;
                                if (probe_pci(&child_pci_dev)) {
                                    part.child_pci_devs.push_back(child_pci_dev);
                                }
                            }
                        }
                    }
                    stack.parts.push_back(part);
                }
            }
            break;
        case SNR_HQM_SAD_ID:
        case SNR_NIS_SAD_ID:
        case SNR_QAT_SAD_ID:
            JacobsvilleAccelerators(*sad_id_bus_pair, stack);
            break;
        default:
            cerr << "Unknown SAD ID: " << sad_id << endl;
            return false;
        }
        iio_on_socket.stacks.push_back(stack);
    }

    std::sort(iio_on_socket.stacks.begin(), iio_on_socket.stacks.end());

    iios.push_back(iio_on_socket);

    return true;
}

class EagleStreamPlatformMapping: public IPlatformMapping
{
private:
    bool getRootBuses(std::map<int, std::map<int, struct bdf>> &root_buses);
    bool stackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket);
    bool eagleStreamDmiStackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket);
    bool eagleStreamPciStackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket);
    bool eagleStreamAcceleratorStackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket);
    bool isDmiStack(int unit);
    bool isPcieStack(int unit);
    bool isDinoStack(int unit);
    std::uint32_t m_chop;

    enum class EagleStreamSupportedTypes
    {
        esInvalid = -1,
        esSprXcc,
        esSprMcc,
        esEmrXcc
    };

    typedef EagleStreamSupportedTypes estype;
    EagleStreamSupportedTypes m_es_type;

    const std::map<int, int> spr_xcc_sad_to_pmu_id_mapping = {
        { 0,  SPR_XCC_DMI_PMON_ID         },
        { 1,  SPR_XCC_PCIE_GEN5_0_PMON_ID },
        { 2,  SPR_XCC_PCIE_GEN5_1_PMON_ID },
        { 3,  SPR_XCC_PCIE_GEN5_2_PMON_ID },
        { 4,  SPR_XCC_PCIE_GEN5_3_PMON_ID },
        { 5,  SPR_XCC_PCIE_GEN5_4_PMON_ID },
        { 8,  SPR_XCC_IDX0_PMON_ID        },
        { 9,  SPR_XCC_IDX1_PMON_ID        },
        { 10, SPR_XCC_IDX2_PMON_ID        },
        { 11, SPR_XCC_IDX3_PMON_ID        }
    };

    const std::map<int, int> spr_mcc_sad_to_pmu_id_mapping = {
        { 0, SPR_MCC_PCIE_GEN5_0_PMON_ID },
        { 1, SPR_MCC_PCIE_GEN5_1_PMON_ID },
        { 2, SPR_MCC_PCIE_GEN5_2_PMON_ID },
        { 3, SPR_MCC_DMI_PMON_ID         },
        { 4, SPR_MCC_PCIE_GEN5_3_PMON_ID },
        { 5, SPR_MCC_PCIE_GEN5_4_PMON_ID },
        { 8, SPR_MCC_IDX0_PMON_ID        },
    };

    const std::string spr_xcc_iio_stack_names[12] = {
        "IIO Stack 0 - IDX0  ",
        "IIO Stack 1 - DMI   ",
        "IIO Stack 2 - PCIe0 ",
        "IIO Stack 3 - IDX1  ",
        "IIO Stack 4 - PCIe1 ",
        "IIO Stack 5 - IDX2  ",
        "IIO Stack 6 - PCIe2 ",
        "IIO Stack 7  - PCIe3",
        "IIO Stack 8  - IDX3 ",
        "IIO Stack 9  - PCIe4",
        "IIO Stack 10 - NONE ",
        "IIO Stack 11 - NONE ",
    };

    /*
    * SPR MCC has 7 I/O stacks but PMON block for DMI has ID number 10.
    * And just to follow such enumeration keep Stack 10 for DMI.
    */
    const std::string spr_mcc_iio_stack_names[11] = {
        "IIO Stack 0 - PCIe0 ",
        "IIO Stack 1 - PCIe1 ",
        "IIO Stack 2 - PCIe2 ",
        "IIO Stack 3 - IDX0  ",
        "IIO Stack 4 - PCIe3 ",
        "IIO Stack 5 - PCIe4 ",
        "IIO Stack 6 - NONE  ",
        "IIO Stack 7 - NONE  ",
        "IIO Stack 8 - NONE  ",
        "IIO Stack 9 - NONE  ",
        "IIO Stack 10 - DMI  ",
    };

    const std::map<int, int> emr_sad_to_pmu_id_mapping = {
        { 0,  EMR_DMI_PMON_ID         },
        { 1,  EMR_PCIE_GEN5_0_PMON_ID },
        { 2,  EMR_PCIE_GEN5_1_PMON_ID },
        { 3,  EMR_PCIE_GEN5_2_PMON_ID },
        { 4,  EMR_PCIE_GEN5_3_PMON_ID },
        { 5,  EMR_PCIE_GEN5_4_PMON_ID },
        { 8,  EMR_IDX0_PMON_ID        },
        { 9,  EMR_IDX1_PMON_ID        },
        { 10, EMR_IDX2_PMON_ID        },
        { 11, EMR_IDX3_PMON_ID        }
    };

    const std::string emr_iio_stack_names[12] = {
        "IIO Stack 0 - IDX0  ",
        "IIO Stack 1 - PCIe3 ",
        "IIO Stack 2 - PCIe0 ",
        "IIO Stack 3 - IDX1  ",
        "IIO Stack 4 - PCIe1 ",
        "IIO Stack 5 - IDX2  ",
        "IIO Stack 6 - PCIe2 ",
        "IIO Stack 7  - DMI",
        "IIO Stack 8  - IDX3 ",
        "IIO Stack 9  - PCIe4",
        "IIO Stack 10 - NONE ",
        "IIO Stack 11 - NONE ",
    };

    enum EagleStreamPlatformStacks
    {
        esDMI = 0,
        esPCIe0,
        esPCIe1,
        esPCIe2,
        esPCIe3,
        esPCIe4,
        esDINO0,
        esDINO1,
        esDINO2,
        esDINO3,
        esEndOfList
    };

    const std::vector<int> spr_xcc_stacks_enumeration = {
        /* esDMI   */ SPR_XCC_DMI_PMON_ID,
        /* esPCIe0 */ SPR_XCC_PCIE_GEN5_0_PMON_ID,
        /* esPCIe1 */ SPR_XCC_PCIE_GEN5_1_PMON_ID,
        /* esPCIe2 */ SPR_XCC_PCIE_GEN5_2_PMON_ID,
        /* esPCIe3 */ SPR_XCC_PCIE_GEN5_3_PMON_ID,
        /* esPCIe4 */ SPR_XCC_PCIE_GEN5_4_PMON_ID,
        /* esDINO0 */ SPR_XCC_IDX0_PMON_ID,
        /* esDINO1 */ SPR_XCC_IDX1_PMON_ID,
        /* esDINO2 */ SPR_XCC_IDX2_PMON_ID,
        /* esDINO3 */ SPR_XCC_IDX3_PMON_ID,
    };

    const std::vector<int> spr_mcc_stacks_enumeration = {
        /* esDMI   */ SPR_MCC_DMI_PMON_ID,
        /* esPCIe0 */ SPR_MCC_PCIE_GEN5_0_PMON_ID,
        /* esPCIe1 */ SPR_MCC_PCIE_GEN5_1_PMON_ID,
        /* esPCIe2 */ SPR_MCC_PCIE_GEN5_2_PMON_ID,
        /* esPCIe3 */ SPR_MCC_PCIE_GEN5_3_PMON_ID,
        /* esPCIe4 */ SPR_MCC_PCIE_GEN5_4_PMON_ID,
        /* esDINO0 */ SPR_MCC_IDX0_PMON_ID,
    };

    const std::vector<int> emr_stacks_enumeration = {
        /* esDMI   */ EMR_DMI_PMON_ID,
        /* esPCIe0 */ EMR_PCIE_GEN5_0_PMON_ID,
        /* esPCIe1 */ EMR_PCIE_GEN5_1_PMON_ID,
        /* esPCIe2 */ EMR_PCIE_GEN5_2_PMON_ID,
        /* esPCIe3 */ EMR_PCIE_GEN5_3_PMON_ID,
        /* esPCIe4 */ EMR_PCIE_GEN5_4_PMON_ID,
        /* esDINO0 */ EMR_IDX0_PMON_ID,
        /* esDINO1 */ EMR_IDX1_PMON_ID,
        /* esDINO2 */ EMR_IDX2_PMON_ID,
        /* esDINO3 */ EMR_IDX3_PMON_ID,
    };

    const std::map<estype, std::vector<int>> es_stacks_enumeration = {
        {estype::esSprXcc, spr_xcc_stacks_enumeration},
        {estype::esSprMcc, spr_mcc_stacks_enumeration},
        {estype::esEmrXcc, emr_stacks_enumeration    },
    };

    const std::map<estype, const std::string *> es_stack_names = {
        {estype::esSprXcc, spr_xcc_iio_stack_names},
        {estype::esSprMcc, spr_mcc_iio_stack_names},
        {estype::esEmrXcc, emr_iio_stack_names    },
    };

    const std::map<estype, std::map<int, int>> es_sad_to_pmu_id_mapping = {
        {estype::esSprXcc, spr_xcc_sad_to_pmu_id_mapping},
        {estype::esSprMcc, spr_mcc_sad_to_pmu_id_mapping},
        {estype::esEmrXcc, emr_sad_to_pmu_id_mapping    },
    };
protected:
    bool pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios) override;
public:
    EagleStreamPlatformMapping(uint32_t model, uint32_t sockets) : IPlatformMapping(model, sockets), m_chop(0), m_es_type(estype::esInvalid) {}
    ~EagleStreamPlatformMapping() = default;
    bool setChopValue();
    bool isXccPlatform() const { return m_chop == kXccChop; }

    const std::uint32_t kXccChop = 0b11;
    const std::uint32_t kMccChop = 0b01;
};

bool EagleStreamPlatformMapping::setChopValue()
{
    for (uint16_t b = 0; b < 256; b++) {
        struct pci pci_dev(0, b, SPR_PCU_CR3_REG_DEVICE, SPR_PCU_CR3_REG_FUNCTION);
        if (!(probe_pci(&pci_dev) && pci_dev.isIntelDeviceById(SPR_PCU_CR3_DID))) {
            continue;
        }

        std::uint32_t capid4;
        PciHandleType h(0, b, SPR_PCU_CR3_REG_DEVICE, SPR_PCU_CR3_REG_FUNCTION);
        h.read32(SPR_CAPID4_OFFSET, &capid4);
        if (capid4 == (std::numeric_limits<std::uint32_t>::max)()) {
            std::cerr << "Cannot read PCU RC3 register" << std::endl;
            return false;
        }
        capid4 = SPR_CAPID4_GET_PHYSICAL_CHOP(capid4);
        if (capid4 == kXccChop || capid4 == kMccChop) {
            m_chop = capid4;
            m_es_type = cpuId() == PCM::SPR ? (m_chop == kXccChop ? estype::esSprXcc : estype::esSprMcc) : estype::esEmrXcc;
        }
        else {
            std::cerr << "Unknown chop value " << capid4 << std::endl;
            return false;
        }
        return true;
    }
    std::cerr << "Cannot find PCU RC3 registers on the system. Device ID is " << std::hex << SPR_PCU_CR3_DID << std::dec << std::endl;
    return false;
}

bool EagleStreamPlatformMapping::getRootBuses(std::map<int, std::map<int, struct bdf>> &root_buses)
{
    bool mapped = true;
    for (uint32_t domain = 0; mapped; domain++) {
        mapped = false;
        for (uint16_t b = 0; b < 256; b++) {
            for (uint8_t d = 0; d < 32; d++) {
                for (uint8_t f = 0; f < 8; f++) {
                    struct pci pci_dev(domain, b, d, f);
                    if (!probe_pci(&pci_dev)) {
                        break;
                    }
                    if (!pci_dev.isIntelDeviceById(SPR_MSM_DEV_ID)) {
                        continue;
                    }

                    std::uint32_t cpuBusValid;
                    std::vector<std::uint32_t> cpuBusNo;
                    int package_id;

                    if (get_cpu_bus(domain, b, d, f, cpuBusValid, cpuBusNo, package_id) == false)
                    {
                        return false;
                    }

                    const auto& sad_to_pmu_id_mapping = es_sad_to_pmu_id_mapping.at(m_es_type);
                    for (int cpuBusId = 0; cpuBusId < SPR_MSM_CPUBUSNO_MAX; ++cpuBusId) {
                        if (!((cpuBusValid >> cpuBusId) & 0x1))
                        {
                            cout << "CPU bus " << cpuBusId << " is disabled on package " << package_id << endl;
                            continue;
                        }
                        if (sad_to_pmu_id_mapping.find(cpuBusId) == sad_to_pmu_id_mapping.end())
                        {
                            cerr << "Cannot map CPU bus " << cpuBusId << " to IO PMU ID" << endl;
                            continue;
                        }
                        int pmuId = sad_to_pmu_id_mapping.at(cpuBusId);
                        int rootBus = (cpuBusNo[(int)(cpuBusId / 4)] >> ((cpuBusId % 4) * 8)) & 0xff;
                        root_buses[package_id][pmuId] = bdf(domain, rootBus, 0, 0);
                        cout << "Mapped CPU bus #" << cpuBusId << " (domain " << domain << " bus " << std::hex << rootBus << std::dec << ") to IO PMU #"
                             << pmuId << " package " << package_id << endl;
                        mapped = true;
                    }
                }
            }
        }
    }
    return !root_buses.empty();
}

bool EagleStreamPlatformMapping::eagleStreamDmiStackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket)
{
    struct iio_stack stack;
    stack.iio_unit_id = unit;
    stack.stack_name = es_stack_names.at(m_es_type)[unit];
    stack.busno = address.busno;
    stack.domain = address.domainno;
    struct iio_bifurcated_part pch_part;
    struct pci *pci = &pch_part.root_pci_dev;
    auto dmi_part_id = SPR_DMI_PART_ID;
    pch_part.part_id = dmi_part_id;
    pci->bdf = address;
    if (!probe_pci(pci)) {
        cerr << "Failed to probe DMI Stack: address: " << std::setw(4) << std::setfill('0') << std::hex << address.domainno <<
                                                          std::setw(2) << std::setfill('0') << ":" << address.busno << ":" << address.devno <<
                                                          "." << address.funcno << std::dec << endl;
        return false;
    }

    /* Scan devices behind PCH port only */
    if (!iio_on_socket.socket_id)
        probeDeviceRange(pch_part.child_pci_devs, pci->bdf.domainno, pci->secondary_bus_number, pci->subordinate_bus_number);

    pci->parts_no.push_back(dmi_part_id);

    stack.parts.push_back(pch_part);
    iio_on_socket.stacks.push_back(stack);
    return true;
}

bool EagleStreamPlatformMapping::eagleStreamPciStackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket)
{
    /*
     * Stacks that manage PCIe 4.0 (device 2,4,6,8) and 5.0 (device 1,3,5,7) Root Ports.
     */
    struct iio_stack stack;
    stack.domain = address.domainno;
    stack.busno = address.busno;
    stack.iio_unit_id = unit;
    stack.stack_name = es_stack_names.at(m_es_type)[unit];
    for (int slot = 1; slot < 9; ++slot)
    {
        // Check if port is enabled
        struct pci root_pci_dev;
        root_pci_dev.bdf = bdf(address.domainno, address.busno, slot, 0x0);
        if (probe_pci(&root_pci_dev))
        {
            struct iio_bifurcated_part part;
            // Bifurcated Root Ports to channel mapping on SPR
            part.part_id = slot - 1;
            part.root_pci_dev = root_pci_dev;
            for (uint8_t b = root_pci_dev.secondary_bus_number; b <= root_pci_dev.subordinate_bus_number; ++b) {
                for (uint8_t d = 0; d < 32; ++d) {
                    for (uint8_t f = 0; f < 8; ++f) {
                        struct pci child_pci_dev(address.domainno, b, d, f);
                        if (probe_pci(&child_pci_dev)) {
                            child_pci_dev.parts_no.push_back(part.part_id);
                            part.child_pci_devs.push_back(child_pci_dev);
                        }
                    }
                }
            }
            stack.parts.push_back(part);
        }
    }
    iio_on_socket.stacks.push_back(stack);
    return true;
}

bool EagleStreamPlatformMapping::eagleStreamAcceleratorStackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket)
{
    struct iio_stack stack;
    stack.iio_unit_id = unit;
    stack.domain = address.domainno;
    stack.busno = address.busno;

    // Channel mappings are checked on B0 stepping
    auto rb = address.busno;
    const std::vector<int> acceleratorBuses{ rb, rb + 1, rb + 2, rb + 3 };
    stack.stack_name = es_stack_names.at(m_es_type)[unit];
    for (auto& b : acceleratorBuses) {
        for (auto d = 0; d < 32; ++d) {
            for (auto f = 0; f < 8; ++f) {
                struct iio_bifurcated_part part;
                struct pci pci_dev(address.domainno, b, d, f);

                if (probe_pci(&pci_dev)) {
                    if (pci_dev.isIntelDevice()) {
                        switch (pci_dev.device_id) {
                        case DSA_DID:
                            pci_dev.parts_no.push_back(0);
                            pci_dev.parts_no.push_back(1);
                            pci_dev.parts_no.push_back(2);
                            break;
                        case IAX_DID:
                            pci_dev.parts_no.push_back(0);
                            pci_dev.parts_no.push_back(1);
                            pci_dev.parts_no.push_back(2);
                            break;
                        case HQMV2_DID:
                            pci_dev.parts_no.push_back(isXccPlatform() ? SPR_XCC_HQM_PART_ID : SPR_MCC_HQM_PART_ID);
                            break;
                        case QATV2_DID:
                            pci_dev.parts_no.push_back(isXccPlatform() ? SPR_XCC_QAT_PART_ID : SPR_MCC_QAT_PART_ID);
                            break;
                        default:
                            continue;
                        }
                        part.child_pci_devs.push_back(pci_dev);
                    }
                    stack.parts.push_back(part);
                }
            }
        }
    }

    iio_on_socket.stacks.push_back(stack);
    return true;
}

bool EagleStreamPlatformMapping::isDmiStack(int unit)
{
    const auto& stacks_enumeration = es_stacks_enumeration.at(m_es_type);

    return stacks_enumeration[esDMI] == unit;
}

bool EagleStreamPlatformMapping::isPcieStack(int unit)
{
    const auto& stacks_enumeration = es_stacks_enumeration.at(m_es_type);

    return stacks_enumeration[esPCIe0] == unit || stacks_enumeration[esPCIe1] == unit ||
           stacks_enumeration[esPCIe2] == unit || stacks_enumeration[esPCIe3] == unit ||
           stacks_enumeration[esPCIe4] == unit;
}

bool EagleStreamPlatformMapping::isDinoStack(int unit)
{
    const auto& stacks_enumeration = es_stacks_enumeration.at(m_es_type);

    return stacks_enumeration[esDINO0] == unit || stacks_enumeration[esDINO1] == unit ||
           stacks_enumeration[esDINO2] == unit || stacks_enumeration[esDINO3] == unit;
}

bool EagleStreamPlatformMapping::stackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket)
{
    if (isDmiStack(unit)) {
        return eagleStreamDmiStackProbe(unit, address, iio_on_socket);
    }
    else if (isPcieStack(unit)) {
        return eagleStreamPciStackProbe(unit, address, iio_on_socket);
    }
    else if (isDinoStack(unit)) {
        return eagleStreamAcceleratorStackProbe(unit, address, iio_on_socket);
    }

    return false;
}

bool EagleStreamPlatformMapping::pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios)
{
    if (!setChopValue()) return false;

    std::map<int, std::map<int, struct bdf>> root_buses;
    if (!getRootBuses(root_buses))
    {
        return false;
    }

    for (auto iter = root_buses.cbegin(); iter != root_buses.cend(); ++iter) {
        auto rbs_on_socket = iter->second;
        struct iio_stacks_on_socket iio_on_socket;
        iio_on_socket.socket_id = iter->first;
        for (auto rb = rbs_on_socket.cbegin(); rb != rbs_on_socket.cend(); ++rb) {
            if (!stackProbe(rb->first, rb->second, iio_on_socket)) {
                return false;
            }
        }
        std::sort(iio_on_socket.stacks.begin(), iio_on_socket.stacks.end());
        iios.push_back(iio_on_socket);
    }

    return true;
}

class LoganvillePlatform: public IPlatformMapping10Nm {
private:
    bool loganvillePchDsaPciStackProbe(struct iio_stacks_on_socket& iio_on_socket, int root_bus, int stack_pmon_id);
    bool loganvilleDlbStackProbe(struct iio_stacks_on_socket& iio_on_socket, int root_bus, int stack_pmon_id);
    bool loganvilleNacStackProbe(struct iio_stacks_on_socket& iio_on_socket, int root_bus, int stack_pmon_id);

    const std::string grr_iio_stack_names[3] = {
        "IIO Stack 0 - NIS/QAT        ",
        "IIO Stack 1 - HQM            ",
        "IIO Stack 2 - PCH/DSA/PCIe   "
    };

    // Stack 0 contains PCH, DSA and CPU PCIe Gen4 Complex
    const std::map<int, int> grr_sad_to_pmu_id_mapping = {
        { GRR_PCH_DSA_GEN4_SAD_ID, GRR_PCH_DSA_GEN4_PMON_ID },
        { GRR_DLB_SAD_ID,          GRR_DLB_PMON_ID          },
        { GRR_NIS_QAT_SAD_ID,      GRR_NIS_QAT_PMON_ID      },
    };
protected:
    bool pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios) override;
public:
    LoganvillePlatform(uint32_t model, uint32_t sockets) : IPlatformMapping10Nm(model, sockets) {}
    ~LoganvillePlatform() = default;
};

bool LoganvillePlatform::loganvillePchDsaPciStackProbe(struct iio_stacks_on_socket& iio_on_socket, int root_bus, int stack_pmon_id)
{
    struct iio_stack stack;
    stack.busno = root_bus;
    stack.iio_unit_id = stack_pmon_id;
    stack.stack_name = grr_iio_stack_names[stack_pmon_id];

    struct iio_bifurcated_part pch_part;
    pch_part.part_id = 7;
    struct pci* pci_dev = &pch_part.root_pci_dev;
    pci_dev->bdf.busno = root_bus;

    if (probe_pci(pci_dev)) {
        probeDeviceRange(pch_part.child_pci_devs, pci_dev->bdf.domainno, pci_dev->secondary_bus_number, pci_dev->subordinate_bus_number);
        stack.parts.push_back(pch_part);
        iio_on_socket.stacks.push_back(stack);
        return true;
    }

    return false;
}

bool LoganvillePlatform::loganvilleDlbStackProbe(struct iio_stacks_on_socket& iio_on_socket, int root_bus, int stack_pmon_id)
{
    struct iio_stack stack;
    stack.busno = root_bus;
    stack.iio_unit_id = stack_pmon_id;
    stack.stack_name = grr_iio_stack_names[stack_pmon_id];

    struct iio_bifurcated_part dlb_part;
    dlb_part.part_id = GRR_DLB_PART_ID;

    for (uint8_t bus = root_bus; bus < 255; bus++) {
        struct pci pci_dev(bus, 0x00, 0x00);
        if (probe_pci(&pci_dev) && pci_dev.isIntelDeviceById(HQMV25_DID)) {
            dlb_part.root_pci_dev = pci_dev;
            // Check Virtual RPs for DLB
            for (uint8_t device = 0; device < 2; device++) {
                for (uint8_t function = 0; function < 8; function++) {
                    struct pci child_pci_dev(bus, device, function);
                    if (probe_pci(&child_pci_dev)) {
                        dlb_part.child_pci_devs.push_back(child_pci_dev);
                    }
                }
            }
            stack.parts.push_back(dlb_part);
            iio_on_socket.stacks.push_back(stack);
            return true;
        }
    }

    return false;
}

bool LoganvillePlatform::loganvilleNacStackProbe(struct iio_stacks_on_socket& iio_on_socket, int root_bus, int stack_pmon_id)
{
    struct iio_stack stack;
    stack.busno = root_bus;
    stack.iio_unit_id = stack_pmon_id;
    stack.stack_name = grr_iio_stack_names[stack_pmon_id];

    // Probe NIS
    {
        struct iio_bifurcated_part nis_part;
        nis_part.part_id = GRR_NIS_PART_ID;
        struct pci pci_dev(root_bus, 0x04, 0x00);
        if (probe_pci(&pci_dev)) {
            nis_part.root_pci_dev = pci_dev;
            for (uint8_t bus = pci_dev.secondary_bus_number; bus <= pci_dev.subordinate_bus_number; bus++) {
                for (uint8_t device = 0; device < 2; device++) {
                    for (uint8_t function = 0; function < 8; function++) {
                            struct pci child_pci_dev(bus, device, function);
                            if (probe_pci(&child_pci_dev)) {
                                nis_part.child_pci_devs.push_back(child_pci_dev);
                            }
                    }
                }
            }
            stack.parts.push_back(nis_part);
        }
    }

    // Probe QAT
    {
        struct iio_bifurcated_part qat_part;
        qat_part.part_id = GRR_QAT_PART_ID;
        struct pci pci_dev(root_bus, 0x05, 0x00);
        if (probe_pci(&pci_dev)) {
            qat_part.root_pci_dev = pci_dev;
            for (uint8_t bus = pci_dev.secondary_bus_number; bus <= pci_dev.subordinate_bus_number; bus++) {
                for (uint8_t device = 0; device < 17; device++) {
                    for (uint8_t function = 0; function < 8; function++) {
                            struct pci child_pci_dev(bus, device, function);
                            if (probe_pci(&child_pci_dev)) {
                                qat_part.child_pci_devs.push_back(child_pci_dev);
                            }
                    }
                }
            }
            stack.parts.push_back(qat_part);
        }
    }

    iio_on_socket.stacks.push_back(stack);
    return true;
}

bool LoganvillePlatform::pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios)
{
    std::map<uint8_t, uint8_t> sad_id_bus_map;
    if (!getSadIdRootBusMap(0, sad_id_bus_map)) {
        return false;
    }

    if (sad_id_bus_map.size() != grr_sad_to_pmu_id_mapping.size()) {
        cerr << "Found unexpected number of stacks: " << sad_id_bus_map.size() << ", expected: " << grr_sad_to_pmu_id_mapping.size() << endl;
        return false;
    }

    struct iio_stacks_on_socket iio_on_socket;
    iio_on_socket.socket_id = 0;

    for (auto sad_id_bus_pair = sad_id_bus_map.cbegin(); sad_id_bus_pair != sad_id_bus_map.cend(); ++sad_id_bus_pair) {
        if (grr_sad_to_pmu_id_mapping.find(sad_id_bus_pair->first) == grr_sad_to_pmu_id_mapping.end()) {
            cerr << "Cannot map SAD ID to PMON ID. Unknown ID: " << sad_id_bus_pair->first << endl;
            return false;
        }
        int stack_pmon_id = grr_sad_to_pmu_id_mapping.at(sad_id_bus_pair->first);
        int root_bus = sad_id_bus_pair->second;
        switch (stack_pmon_id) {
        case GRR_PCH_DSA_GEN4_PMON_ID:
            if (!loganvillePchDsaPciStackProbe(iio_on_socket, root_bus, stack_pmon_id)) {
                return false;
            }
            break;
        case GRR_DLB_PMON_ID:
            if (!loganvilleDlbStackProbe(iio_on_socket, root_bus, stack_pmon_id)) {
                return false;
            }
            break;
        case GRR_NIS_QAT_PMON_ID:
            if (!loganvilleNacStackProbe(iio_on_socket, root_bus, stack_pmon_id)) {
                return false;
            }
            break;
        default:
            return false;
        }
    }

    std::sort(iio_on_socket.stacks.begin(), iio_on_socket.stacks.end());

    iios.push_back(iio_on_socket);

    return true;
}

class Xeon6thNextGenPlatform: public IPlatformMapping {
private:
    bool getRootBuses(std::map<int, std::map<int, struct bdf>> &root_buses);
protected:
    virtual bool stackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket) = 0;
    virtual bool pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios) override;
public:
    Xeon6thNextGenPlatform(uint32_t model, uint32_t sockets) : IPlatformMapping(model, sockets) {}
    virtual ~Xeon6thNextGenPlatform() = default;
};

bool Xeon6thNextGenPlatform::getRootBuses(std::map<int, std::map<int, struct bdf>> &root_buses)
{
    bool mapped = true;
    for (uint32_t domain = 0; mapped; domain++) {
        mapped = false;
        for (uint16_t b = 0; b < 256; b++) {
            for (uint8_t d = 0; d < 32; d++) {
                for (uint8_t f = 0; f < 8; f++) {
                    struct pci pci_dev(domain, b, d, f);
                    if (!probe_pci(&pci_dev)) {
                        break;
                    }
                    if (!pci_dev.isIntelDeviceById(SPR_MSM_DEV_ID)) {
                        continue;
                    }

                    std::uint32_t cpuBusValid;
                    std::vector<std::uint32_t> cpuBusNo;
                    int package_id;

                    if (!get_cpu_bus(domain, b, d, f, cpuBusValid, cpuBusNo, package_id)) {
                        return false;
                    }

                    for (int cpuBusId = 0; cpuBusId < SPR_MSM_CPUBUSNO_MAX; ++cpuBusId) {
                        if (!((cpuBusValid >> cpuBusId) & 0x1)) {
                            cout << "CPU bus " << cpuBusId << " is disabled on package " << package_id << endl;
                            continue;
                        }
                        int rootBus = (cpuBusNo[(int)(cpuBusId / 4)] >> ((cpuBusId % 4) * 8)) & 0xff;
                        root_buses[package_id][cpuBusId] = bdf(domain, rootBus, 0, 0);
                        cout << "Mapped CPU bus #" << cpuBusId << " (domain " << domain << " bus " << std::hex << rootBus << std::dec << ")"
                             << " package " << package_id << endl;
                        mapped = true;
                    }
                }
            }
        }
    }
    return !root_buses.empty();
}

bool Xeon6thNextGenPlatform::pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios)
{
    std::map<int, std::map<int, struct bdf>> root_buses;
    if (!getRootBuses(root_buses))
    {
        return false;
    }

    for (auto iter = root_buses.cbegin(); iter != root_buses.cend(); ++iter) {
        auto rbs_on_socket = iter->second;
        struct iio_stacks_on_socket iio_on_socket;
        iio_on_socket.socket_id = iter->first;
        for (auto rb = rbs_on_socket.cbegin(); rb != rbs_on_socket.cend(); ++rb) {
            if (!stackProbe(rb->first, rb->second, iio_on_socket)) {
                return false;
            }
        }
        std::sort(iio_on_socket.stacks.begin(), iio_on_socket.stacks.end());
        iios.push_back(iio_on_socket);
    }

    return true;
}

class BirchStreamPlatform: public Xeon6thNextGenPlatform {
private:
    bool isPcieStack(int unit);
    bool isRootHcStack(int unit);
    bool isPartHcStack(int unit);
    bool isUboxStack(int unit);

    bool birchStreamPciStackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket);
    bool birchStreamAcceleratorStackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket);

    const std::string srf_iio_stack_names[15] = {
        "IIO Stack 0  - PCIe6     ", // SRF_PE6_PMON_ID      0
        "IIO Stack 1  - HCx0      ", // SRF_HC0_PMON_ID      1
        "IIO Stack 2  - PCIe2     ", // SRF_PE2_PMON_ID      2
        "IIO Stack 3  - PCIe0     ", // SRF_PE0_PMON_ID      3
        "IIO Stack 4  - PCIe1     ", // SRF_PE1_PMON_ID      4
        "IIO Stack 5  - PCIe3     ", // SRF_PE3_PMON_ID      5
        "IIO Stack 6  - HCx1      ", // SRF_HC1_PMON_ID      6
        "IIO Stack 7  - PCIe7     ", // SRF_PE7_PMON_ID      7
        "IIO Stack 8  - PCIe8     ", // SRF_PE8_PMON_ID      8
        "IIO Stack 9  - HCx3      ", // SRF_HC3_PMON_ID      9
        "IIO Stack 10 - Flex PCIe5", // SRF_FLEX_PE5_PMON_ID 10
        "IIO Stack 11 - PCIe4     ", // SRF_PE4_PMON_ID      11
        "IIO Stack 12 - PCIe5     ", // SRF_PE5_PMON_ID      12
        "IIO Stack 13 - Flex PCIe4", // SRF_FLEX_PE4_PMON_ID 13
        "IIO Stack 14 - HCx2      ", // SRF_HC2_PMON_ID      14
    };

    const std::unordered_map<int, int> srf_sad_to_pmu_id_mapping = {
        { SRF_PE0_SAD_BUS_ID,      SRF_PE0_PMON_ID      },
        { SRF_PE1_SAD_BUS_ID,      SRF_PE1_PMON_ID      },
        { SRF_PE2_SAD_BUS_ID,      SRF_PE2_PMON_ID      },
        { SRF_PE3_SAD_BUS_ID,      SRF_PE3_PMON_ID      },
        { SRF_PE4_SAD_BUS_ID,      SRF_PE4_PMON_ID      },
        { SRF_FLEX_PE4_SAD_BUS_ID, SRF_FLEX_PE4_PMON_ID },
        { SRF_PE5_SAD_BUS_ID,      SRF_PE5_PMON_ID      },
        { SRF_FLEX_PE5_SAD_BUS_ID, SRF_FLEX_PE5_PMON_ID },
        { SRF_PE6_SAD_BUS_ID,      SRF_PE6_PMON_ID      },
        { SRF_PE7_SAD_BUS_ID,      SRF_PE7_PMON_ID      },
        { SRF_PE8_SAD_BUS_ID,      SRF_PE8_PMON_ID      },
        { SRF_HC0_SAD_BUS_ID,      SRF_HC0_PMON_ID      },
        { SRF_HC1_SAD_BUS_ID,      SRF_HC1_PMON_ID      },
        { SRF_HC2_SAD_BUS_ID,      SRF_HC2_PMON_ID      },
        { SRF_HC3_SAD_BUS_ID,      SRF_HC3_PMON_ID      },
    };

    const std::unordered_set<int> srf_pcie_stacks = {
        SRF_PE0_SAD_BUS_ID,
        SRF_PE1_SAD_BUS_ID,
        SRF_PE2_SAD_BUS_ID,
        SRF_PE3_SAD_BUS_ID,
        SRF_PE4_SAD_BUS_ID,
        SRF_FLEX_PE4_SAD_BUS_ID,
        SRF_PE5_SAD_BUS_ID,
        SRF_FLEX_PE5_SAD_BUS_ID,
        SRF_PE6_SAD_BUS_ID,
        SRF_PE7_SAD_BUS_ID,
        SRF_PE8_SAD_BUS_ID
    };
protected:
    bool stackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket) override;
public:
    BirchStreamPlatform(uint32_t model, uint32_t sockets) : Xeon6thNextGenPlatform(model, sockets) {}
    ~BirchStreamPlatform() = default;
};

bool BirchStreamPlatform::birchStreamPciStackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket)
{
    /*
     * All stacks manage PCIe 5.0 Root Ports. Bifurcated Root Ports A-H appear as devices 2-9.
     */
    struct iio_stack stack;
    stack.domain = address.domainno;
    stack.busno = address.busno;
    stack.iio_unit_id = srf_sad_to_pmu_id_mapping.at(unit);
    stack.stack_name = srf_iio_stack_names[stack.iio_unit_id];
    for (int slot = 2; slot < 9; ++slot)
    {
        struct pci root_pci_dev;
        root_pci_dev.bdf = bdf(address.domainno, address.busno, slot, 0x0);
        if (probe_pci(&root_pci_dev))
        {
            struct iio_bifurcated_part part;
            part.part_id = slot - 2;
            part.root_pci_dev = root_pci_dev;
            for (uint8_t b = root_pci_dev.secondary_bus_number; b <= root_pci_dev.subordinate_bus_number; ++b) {
                for (uint8_t d = 0; d < 32; ++d) {
                    for (uint8_t f = 0; f < 8; ++f) {
                        struct pci child_pci_dev(address.domainno, b, d, f);
                        if (probe_pci(&child_pci_dev)) {
                            child_pci_dev.parts_no.push_back(part.part_id);
                            part.child_pci_devs.push_back(child_pci_dev);
                        }
                    }
                }
            }
            stack.parts.push_back(part);
        }
    }
    iio_on_socket.stacks.push_back(stack);
    return true;
}

bool BirchStreamPlatform::birchStreamAcceleratorStackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket)
{
    struct iio_stack stack;
    stack.iio_unit_id = srf_sad_to_pmu_id_mapping.at(unit);
    stack.domain = address.domainno;
    stack.busno = address.busno;
    stack.stack_name = srf_iio_stack_names[stack.iio_unit_id];

    /*
     * Instance of DSA(0, 1, 2, 3) appears as PCIe device with SAD Bus ID (8, 12, 20, 16), device 1, function 0
     * Instance of IAX(0, 1, 2, 3) appears as PCIe device with SAD Bus ID (8, 12, 20, 16), device 2, function 0
     * Instance of QAT(0, 1, 2, 3) appears as PCIe device with SAD Bus ID (9, 13, 21, 17), device 0, function 0
     * Instance of HQM(0, 1, 2, 3) appears as PCIe device with SAD Bus ID (10, 14, 22, 18), device 0, function 0
     */
    auto process_pci_dev = [](int domainno, int busno, int devno, int part_number, iio_bifurcated_part& part)
    {
        struct pci pci_dev(domainno, busno, devno, 0);
        if (probe_pci(&pci_dev) && pci_dev.isIntelDevice()) {
            part.part_id = part_number;
            pci_dev.parts_no.push_back(part_number);
            part.child_pci_devs.push_back(pci_dev);
            return true;
        }
        return false;
    };

    auto add_pci_part = [&](int domainno, int busno, int devno, int part_number) {
        struct iio_bifurcated_part part;
        if (process_pci_dev(domainno, busno, devno, part_number, part)) {
            stack.parts.push_back(part);
        }
    };

    add_pci_part(address.domainno, address.busno, 1, SRF_DSA_IAX_PART_NUMBER);
    add_pci_part(address.domainno, address.busno, 2, SRF_DSA_IAX_PART_NUMBER);

    add_pci_part(address.domainno, address.busno + 1, 0, SRF_QAT_PART_NUMBER);

    /* Bus number for HQM is higher on 3 than DSA bus number */
    add_pci_part(address.domainno, address.busno + 3, 0, SRF_HQM_PART_NUMBER);

    if (!stack.parts.empty()) {
        iio_on_socket.stacks.push_back(stack);
    }

    return true;
}

bool BirchStreamPlatform::isPcieStack(int unit)
{
    return srf_pcie_stacks.find(unit) != srf_pcie_stacks.end();
}

/*
 * HC is the name of DINO stacks as we had on SPR
 */
bool BirchStreamPlatform::isRootHcStack(int unit)
{
    return SRF_HC0_SAD_BUS_ID == unit || SRF_HC1_SAD_BUS_ID == unit ||
           SRF_HC2_SAD_BUS_ID == unit || SRF_HC3_SAD_BUS_ID == unit;
}

bool BirchStreamPlatform::isPartHcStack(int unit)
{
    return isRootHcStack(unit - 1) || isRootHcStack(unit - 2);
}

bool BirchStreamPlatform::isUboxStack(int unit)
{
    return SRF_UBOXA_SAD_BUS_ID == unit || SRF_UBOXB_SAD_BUS_ID == unit;
}

bool BirchStreamPlatform::stackProbe(int unit, const struct bdf &address, struct iio_stacks_on_socket &iio_on_socket)
{
    if (isPcieStack(unit)) {
        return birchStreamPciStackProbe(unit, address, iio_on_socket);
    }
    else if (isRootHcStack(unit)) {
        return birchStreamAcceleratorStackProbe(unit, address, iio_on_socket);
    }
    else if (isPartHcStack(unit)) {
        cout << "Found a part of HC stack. Stack ID - " << unit << " domain " << address.domainno
             << " bus " << std::hex << std::setfill('0') << std::setw(2) << (int)address.busno << std::dec << ". Don't probe it again." << endl;
        return true;
    }
    else if (isUboxStack(unit)) {
        cout << "Found UBOX stack. Stack ID - " << unit << " domain " << address.domainno
             << " bus " << std::hex << std::setfill('0') << std::setw(2) << (int)address.busno << std::dec << endl;
        return true;
    }

    cout << "Unknown stack ID " << unit << " domain " << address.domainno << " bus " << std::hex << std::setfill('0') << std::setw(2) << (int)address.busno << std::dec << endl;

    return false;
}

class DefaultPlatformMapping : public IPlatformMapping {
protected:
    const std::string stackIdToString(const int unit)
    {
        char buffer[64];
        snprintf(buffer, sizeof(buffer), "Stack %2d", unit);
        return std::string(buffer);
    }

    bool pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios) override;
public:
    DefaultPlatformMapping(uint32_t model, uint32_t sockets, uint32_t stacks)
        : IPlatformMapping(model, sockets, stacks) {}
};

bool DefaultPlatformMapping::pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios)
{
    for (uint32_t socket = 0; socket < socketsCount(); socket++)
    {
        struct iio_stacks_on_socket iio_on_socket;
        iio_on_socket.socket_id = socket;
        for (uint32_t unit = 0; unit < stacksCount(); unit++)
        {
            struct iio_stack stack;
            stack.iio_unit_id = unit;
            stack.stack_name = stackIdToString(unit);
            iio_on_socket.stacks.push_back(stack);
        }
        iios.push_back(iio_on_socket);
    }

    return true;
}

void IPlatformMapping::probeDeviceRange(std::vector<struct pci> &pci_devs, int domain, int secondary, int subordinate)
{
    for (uint8_t bus = secondary; int(bus) <= subordinate; bus++) {
        for (uint8_t device = 0; device < 32; device++) {
            for (uint8_t function = 0; function < 8; function++) {
                struct pci child_dev;
                child_dev.bdf.domainno = domain;
                child_dev.bdf.busno = bus;
                child_dev.bdf.devno = device;
                child_dev.bdf.funcno = function;
                if (probe_pci(&child_dev)) {
                    if (secondary < child_dev.secondary_bus_number && subordinate < child_dev.subordinate_bus_number) {
                        probeDeviceRange(child_dev.child_pci_devs, domain, child_dev.secondary_bus_number, child_dev.subordinate_bus_number);
                    }
                    pci_devs.push_back(child_dev);
                }
            }
        }
    }
}

std::unique_ptr<IPlatformMapping> IPlatformMapping::getPlatformMapping(uint32_t model, uint32_t sockets, uint32_t stacks)
{
    switch (model) {
    case PCM::SKX:
        return std::make_unique<PurleyPlatformMapping>(model, sockets);
    case PCM::ICX:
        return std::make_unique<WhitleyPlatformMapping>(model, sockets);
    case PCM::SNOWRIDGE:
        return std::make_unique<JacobsvillePlatformMapping>(model, sockets);
    case PCM::SPR:
    case PCM::EMR:
        return std::make_unique<EagleStreamPlatformMapping>(model, sockets);
    case PCM::GRR:
        return std::make_unique<LoganvillePlatform>(model, sockets);
    case PCM::SRF:
    case PCM::GNR:
        return std::make_unique<BirchStreamPlatform>(model, sockets);
    default:
        std::cerr << "Warning: Only initial support (without attribution to PCIe devices) for " << PCM::cpuFamilyModelToUArchCodename(model) << " is provided" << std::endl;
        return std::make_unique<DefaultPlatformMapping>(model, sockets, stacks);
    }
}

bool IPlatformMapping::initializeIOStacksStructure(std::vector<struct iio_stacks_on_socket>& iios, uint32_t model, uint32_t sockets, uint32_t stacks)
{
    std::unique_ptr<IPlatformMapping> mapping = nullptr;
    try
    {
        mapping = getPlatformMapping(model, sockets, stacks);
    }
    catch (const std::exception & e)
    {
        std::cerr << "Error info:" << e.what() << std::endl;
        return false;
    }

    return mapping->pciTreeDiscover(iios);
}
```

`src/pcm-iio-topology.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2017-2025, Intel Corporation

// written by Patrick Lu,
//            Aaron Cruz
//            Alexander Antonov
//            and others
#pragma once

#ifdef _MSC_VER
    #include <windows.h>
    #include "windows/windriver.h"
#else
    #include <unistd.h>
#endif

#include <memory>
#include <cstdint>
#include <algorithm>

#ifdef _MSC_VER
    #include "freegetopt/getopt.h"
#endif

#include "lspci.h"

using namespace std;
using namespace pcm;

class IPlatformMapping {
private:
    uint32_t m_sockets;
    uint32_t m_model;
    uint32_t m_stacks = 0;
protected:
    void probeDeviceRange(std::vector<struct pci> &child_pci_devs, int domain, int secondary, int subordinate);

    uint32_t socketsCount() const { return m_sockets; }
    uint32_t cpuId() const { return m_model; }
    uint32_t stacksCount() const { return m_stacks; }

    IPlatformMapping(uint32_t model, uint32_t sockets) : m_sockets(sockets), m_model(model) {}
    IPlatformMapping(uint32_t model, uint32_t sockets, uint32_t stacks) :
        m_sockets(sockets), m_model(model), m_stacks(stacks) {}

    virtual bool pciTreeDiscover(std::vector<struct iio_stacks_on_socket>& iios) = 0;
    static std::unique_ptr<IPlatformMapping> getPlatformMapping(uint32_t model, uint32_t sockets, uint32_t stacks);
public:
    virtual ~IPlatformMapping() {}

    static bool initializeIOStacksStructure(std::vector<struct iio_stacks_on_socket>& iios, uint32_t model, uint32_t sockets, uint32_t stacks);
};

```

`src/pcm-iio.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2017-2025, Intel Corporation

// written by Patrick Lu,
//            Aaron Cruz,
//            Alexander Antonov
//            and others

#include "pcm-iio-pmu.h"

void print_PCIeMapping(const std::vector<struct iio_stacks_on_socket>& iios, const PCIDB & pciDB, std::ostream& stream)
{
    uint32_t header_width = 100;
    string row;
    vector<string> buffer;

    for (auto it = iios.begin(); it != iios.end(); ++it) {
        row = "Socket " + std::to_string((*it).socket_id);
        buffer.push_back(row);
        for (auto & stack : it->stacks) {
            std::stringstream ss;
            ss << "\t" << stack.stack_name << " domain 0x" << std::hex << std::setfill('0') << std::setw(4) << stack.domain
               << "; root bus: 0x" << std::setfill('0') << std::setw(2) << (int)stack.busno << "\tflipped: " << (stack.flipped ? "true" : "false");
            buffer.push_back(ss.str());
            for (auto& part : stack.parts) {
                vector<struct pci> pp = part.child_pci_devs;
                uint8_t level = 5;
                for (std::vector<struct pci>::const_iterator iunit = pp.begin(); iunit != pp.end(); ++iunit) {
                    row = build_pci_header(pciDB, header_width, *iunit, -1, level);
                    buffer.push_back(row);
                    if (iunit->hasChildDevices()) {
                        build_pci_tree(buffer, pciDB, header_width, *iunit, -1, level + 1);
                    } else if (iunit->header_type == 1) {
                        level++;
                    }
                }
            }
        }
    }
    display(buffer, stream);
}

void print_usage(const string& progname)
{
    cout << "\n Usage: \n " << progname << " --help | [interval] [options] \n";
    cout << "   <interval>                           => time interval in seconds (floating point number is accepted)\n";
    cout << "                                        to sample performance counters.\n";
    cout << "                                        If not specified - 3.0 is used\n";
    cout << " Supported <options> are: \n";
    cout << "  -h    | --help  | /h               => print this help and exit\n";
    cout << "  -silent                            => silence information output and print only measurements\n";
    cout << "  --version                          => print application version\n";
    cout << "  -csv[=file.csv] | /csv[=file.csv]  => output compact CSV format to screen or\n"
         << "                                        to a file, in case filename is provided\n";
    cout << "  -csv-delimiter=<value>  | /csv-delimiter=<value>   => set custom csv delimiter\n";
    cout << "  -human-readable | /human-readable  => use human readable format for output (for csv only)\n";
    cout << "  -root-port | /root-port            => add root port devices to output (for csv only)\n";
    cout << "  -list | --list                     => provide platform topology info\n";
    cout << "  -i[=number] | /i[=number]          => allow to determine number of iterations\n";
    cout << " Examples:\n";
    cout << "  " << progname << " 1.0 -i=10             => print counters every second 10 times and exit\n";
    cout << "  " << progname << " 0.5 -csv=test.log     => twice a second save counter values to test.log in CSV format\n";
    cout << "  " << progname << " -csv -human-readable  => every 3 second print counters in human-readable CSV format\n";
    cout << "\n";
}

void parse_arguments(int argc, char * argv[], struct pcm_iio_config& config, MainLoop& mainLoop)
{
    const string program = string(argv[0]);
    while (argc > 1) {
        argv++;
        argc--;
        std::string arg_value;
        if (check_argument_equals(*argv, {"--help", "-h", "/h"})) {
            print_usage(program);
            exit(EXIT_FAILURE);
        }
        else if (check_argument_equals(*argv, {"-silent", "/silent"})) {
            // handled in check_and_set_silent
            continue;
        }
        else if (extract_argument_value(*argv, {"-csv-delimiter", "/csv-delimiter"}, arg_value)) {
            config.display.csv_delimiter = std::move(arg_value);
        }
        else if (check_argument_equals(*argv, {"-csv", "/csv"})) {
            config.display.csv = true;
        }
        else if (extract_argument_value(*argv, {"-csv", "/csv"}, arg_value)) {
            config.display.csv = true;
            config.display.output_file = std::move(arg_value);
        }
        else if (check_argument_equals(*argv, {"-human-readable", "/human-readable"})) {
            config.display.human_readable = true;
        }
        else if (check_argument_equals(*argv, {"-list", "--list"})) {
            config.display.list = true;
        }
        else if (check_argument_equals(*argv, {"-root-port", "/root-port"})) {
            config.display.show_root_port = true;
        }
        else if (mainLoop.parseArg(*argv)) {
            continue;
        }
        else {
            config.pmu_config.delay = parse_delay(*argv, program, (print_usage_func)print_usage);
            continue;
        }
    }
}

PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
    if (print_version(argc, argv))
        exit(EXIT_SUCCESS);

    null_stream nullStream;
    check_and_set_silent(argc, argv, nullStream);

    std::cout << "\n Intel(r) Performance Counter Monitor " << PCM_VERSION << "\n";
    std::cout << "\n This utility measures IIO information\n\n";

    struct pcm_iio_config config;
    MainLoop mainLoop;

    parse_arguments(argc, argv, config, mainLoop);

    set_signal_handlers();

    print_cpu_details();

    std::ostream* output = &std::cout;
    std::fstream file_stream;
    if (!config.display.output_file.empty()) {
        file_stream.open(config.display.output_file.c_str(), std::ios_base::out);
        output = &file_stream;
    }

    if (!initializePCIeBWCounters(config.pmu_config))
        exit(EXIT_FAILURE);

    load_PCIDB(config.pciDB);

    if (config.display.list) {
        print_PCIeMapping(config.pmu_config.iios, config.pciDB, *output);
        return 0;
    }

#ifdef PCM_DEBUG
    print_nameMap(config.pmu_config.nameMap);
#endif

    auto displayBuilder = getDisplayBuilder(config);
    auto collector = std::make_unique<PcmIioDataCollector>(config.pmu_config);

    mainLoop([&]()
    {
        collector->collectData();
        vector<string> display_buffer = displayBuilder->buildDisplayBuffer();
        display(display_buffer, *output);
        return true;
    });

    file_stream.close();

    exit(EXIT_SUCCESS);
}

```

`src/pcm-latency.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2018-2022, Intel Corporation
//
// written by Subhiksha Ravisundar
#include "cpucounters.h"
#ifdef _MSC_VER
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#endif
#include <fstream>
#include <stdlib.h>
#include <cstdint>
#include <numeric>
#include <bitset>
#include <algorithm>
#include <string.h>
#ifdef _MSC_VER
#include "freegetopt/getopt.h"
#endif

#include "lspci.h"
#include "utils.h"
using namespace std;
using namespace pcm;

#define DDR 0
#define PMM 1

#define L1 0
#define L2 1

#define RPQ_OCC 0
#define RPQ_INS 1
#define WPQ_OCC 2
#define WPQ_INS 3

#define FB_OCC_RD 0
#define FB_INS_RD 1

#define PCM_DELAY_DEFAULT 3.0 // in seconds
#define MAX_CORES 4096

EventSelectRegister regs[2];
const uint8_t max_sockets = 64;

struct socket_info_uncore
{
    int socket_id;
    double rlatency;
    double wlatency;
    double rinsert;
    double winsert;
    double roccupancy;
    double woccupancy;
};

struct core_info
{
    int core_id;
    int socket;
    int thread;
    double latency;
    double occ_rd;
    double insert_rd;
    core_info() : core_id(0), socket(0), thread(0), latency(0.), occ_rd(0.), insert_rd(0.) {}
};

struct socket_info_pci
{
    int socket_id;
    uint64_t latency;
};

struct res_uncore
{
    string name;
    vector<struct socket_info_uncore> skt;
} uncore_event[10];

struct res_core
{
    string name;
    vector<struct core_info> core;
    vector<struct core_info> socket;
} core_latency[10];

double DRAMSpeed;

ServerUncoreCounterState * BeforeState;
ServerUncoreCounterState * AfterState;


std::shared_ptr<SystemCounterState> SysBeforeState, SysAfterState;
std::shared_ptr<std::vector<CoreCounterState> > BeforeState_core, AfterState_core;
std::shared_ptr<std::vector<SocketCounterState> > DummySocketStates;

void collect_beforestate_uncore(PCM *m)
{
    for (unsigned int i=0; i<m->getNumSockets(); i++)
    {
        BeforeState[i] = m->getServerUncoreCounterState(i);
    }
}

void collect_afterstate_uncore(PCM *m)
{
    for (unsigned int i=0; i<m->getNumSockets(); i++)
    {
        AfterState[i] = m->getServerUncoreCounterState(i);
    }
}

void store_latency_uncore(PCM *m, bool ddr, int delay_ms)
{
    for (unsigned int i=0; i<m->getNumSockets(); i++)
    {
        uncore_event[ddr].skt[i].socket_id = i;
        const double delay_seconds = double(delay_ms) / 1000.;
        DRAMSpeed = double(getDRAMClocks(0, BeforeState[i], AfterState[i]))/(double(1e9) * delay_seconds);
        uncore_event[ddr].skt[i].rinsert = 0;
        uncore_event[ddr].skt[i].roccupancy = 0;
        uncore_event[ddr].skt[i].winsert = 0;
        uncore_event[ddr].skt[i].woccupancy = 0;
        for (size_t channel = 0; channel < m->getMCChannelsPerSocket(); ++channel)
        {
            uncore_event[ddr].skt[i].rinsert += (double)getMCCounter((uint32)channel, RPQ_INS, BeforeState[i], AfterState[i]);
            uncore_event[ddr].skt[i].roccupancy += (double)getMCCounter((uint32)channel, RPQ_OCC, BeforeState[i], AfterState[i]);
            uncore_event[ddr].skt[i].winsert += (double)getMCCounter((uint32)channel, WPQ_INS, BeforeState[i], AfterState[i]);
            uncore_event[ddr].skt[i].woccupancy += (double)getMCCounter((uint32)channel, WPQ_OCC, BeforeState[i], AfterState[i]);
        }
        if (uncore_event[ddr].skt[i].rinsert == 0.)
        {
            uncore_event[ddr].skt[i].rlatency = 0;
        } else {
            uncore_event[ddr].skt[i].rlatency = uncore_event[ddr].skt[i].roccupancy / uncore_event[ddr].skt[i].rinsert;
        }

        if (uncore_event[ddr].skt[i].winsert == 0.)
        {
            uncore_event[ddr].skt[i].wlatency = 0;
        } else {
            uncore_event[ddr].skt[i].wlatency = uncore_event[ddr].skt[i].woccupancy / uncore_event[ddr].skt[i].winsert;
        }

        swap(BeforeState[i], AfterState[i]);
    }
}

void collect_beforestate_core(PCM *m)
{
    m->getAllCounterStates(*SysBeforeState.get(), *DummySocketStates.get(), *BeforeState_core.get());
}

void collect_afterstate_core(PCM *m)
{
    m->getAllCounterStates(*SysAfterState.get(), *DummySocketStates.get(), *AfterState_core.get());
}

void store_latency_core(PCM *m)
{
    unsigned int extra_clocks_for_L1_miss = 5;
    struct res_core core_event[3];
    for (int k=0; k < 3; k++)
    {
         core_event[k].core.resize(MAX_CORES);
    }
    for (auto & s : core_latency[L1].socket)
    {
        s.occ_rd = 0;
        s.insert_rd = 0;
    }
    for (unsigned int i=0; i<m->getNumCores(); i++)
    {
        const double frequency = (((double)getCycles(BeforeState_core->operator[](i), AfterState_core->operator[](i)) /
            (double)getRefCycles(BeforeState_core->operator[](i), AfterState_core->operator[](i))) * (double)m->getNominalFrequency()) / 1000000000;
        for(int j=0; j<2; j++)// 2 events
        {
            core_event[j].core[i].core_id = i;
            core_event[j].core[i].latency = (double)getNumberOfCustomEvents(j, BeforeState_core->operator[](i), AfterState_core->operator[](i));
        }
        // L1 latency
        //Adding 5 clocks for L1 Miss
        core_latency[L1].core[i].latency = ((core_event[FB_OCC_RD].core[i].latency/core_event[FB_INS_RD].core[i].latency)+extra_clocks_for_L1_miss)/frequency;
        core_latency[L1].core[i].occ_rd = (core_event[FB_OCC_RD].core[i].latency);
        core_latency[L1].core[i].insert_rd = (core_event[FB_INS_RD].core[i].latency);
        const auto s = m->getSocketId(i);
        core_latency[L1].socket[s].occ_rd += (core_latency[L1].core[i].occ_rd + extra_clocks_for_L1_miss * core_latency[L1].core[i].insert_rd) / frequency;
        core_latency[L1].socket[s].insert_rd += core_latency[L1].core[i].insert_rd;
    }
    for (auto & s : core_latency[L1].socket)
    {
        s.latency = s.occ_rd / s.insert_rd;
    }
    swap(BeforeState_core, AfterState_core);
    swap(SysBeforeState, SysAfterState);
}


void print_verbose(PCM *m, int ddr_ip)
{
    cout << "L1 Cache Latency ============================= \n";
    for (unsigned int i=0; i<m->getNumCores(); i++)
    {
        cout << "Core: " << i << "\n";
        cout << "L1 Occupancy read: " << core_latency[0].core[i].occ_rd << "\n";
        cout << "L1 Inserts read: " << core_latency[0].core[i].insert_rd << "\n";
        cout << "\n";
    }
    if (ddr_ip == DDR)
    {
        cout << "DDR Latency =================================\n";
        cout << "Read Inserts Socket0: " << uncore_event[DDR].skt[0].rinsert << "\n";
        cout << "Read Occupancy Socket0: " << uncore_event[DDR].skt[0].roccupancy << "\n";
        cout << "Read Inserts Socket1: " << uncore_event[DDR].skt[1].rinsert << "\n";
        cout << "Read Occupancy Socket1: " << uncore_event[DDR].skt[1].roccupancy << "\n";
        cout << "\n";
        cout << "Write Inserts Socket0: " << uncore_event[DDR].skt[0].winsert << "\n";
        cout << "Write Occupancy Socket0: " << uncore_event[DDR].skt[0].woccupancy << "\n";
        cout << "Write Inserts Socket1: " << uncore_event[DDR].skt[1].winsert << "\n";
        cout << "Write Occupancy Socket1: " << uncore_event[DDR].skt[1].woccupancy << "\n";
    }

    if (ddr_ip == PMM)
    {
        cout << "PMM Latency =================================\n";
        cout << "Read Inserts Socket0: " << uncore_event[PMM].skt[0].rinsert << "\n";
        cout << "Read Occupancy Socket0: " << uncore_event[PMM].skt[0].roccupancy << "\n";
        cout << "Read Inserts Socket1: " << uncore_event[PMM].skt[1].rinsert << "\n";
        cout << "Read Occupancy Socket1: " << uncore_event[PMM].skt[1].roccupancy << "\n";
        cout << "\n";
        cout << "Write Inserts Socket0: " << uncore_event[PMM].skt[0].winsert << "\n";
        cout << "Write Occupancy Socket0: " << uncore_event[PMM].skt[0].woccupancy << "\n";
        cout << "Write Inserts Socket1: " << uncore_event[PMM].skt[1].winsert << "\n";
        cout << "Write Occupancy Socket1: " << uncore_event[PMM].skt[1].woccupancy << "\n";
    }
}

void print_ddr(PCM *m, int ddr_ip)
{
    if (ddr_ip == PMM)
    {
        if (m->PMMTrafficMetricsAvailable())
        {
            cout << "PMM read Latency(ns)\n";
            for (unsigned int n=0; n<m->getNumSockets(); n++)
            {
                cout << "Socket" << n << ": " << double(uncore_event[PMM].skt[n].rlatency)/DRAMSpeed;
                cout << "\n";
            }
        }
        else
        {
            cout << "PMM metrics are not supported on your processor\n";
        }
    }

    if (ddr_ip == DDR)
    {
        cout << "DDR read Latency(ns)\n";
        for (unsigned int n=0; n<m->getNumSockets(); n++)
        {
            cout << "Socket" << n << ": " << double(uncore_event[DDR].skt[n].rlatency)/DRAMSpeed;
            cout << "\n";
        }
    }
}

void print_core_stats(PCM *m, unsigned int core_size_per_socket, vector<vector<vector<struct core_info >>> &sk_th)
{
    auto printHeader = []()
    {
        cout << "\n\n";
        cout << "L1 Cache Miss Latency(ns) [Adding 5 clocks for L1 Miss]\n\n";;
    };
    printHeader();
    for (unsigned int sid=0; sid<m->getNumSockets(); sid++)
    {
        for (unsigned int tid=0; tid< m->getThreadsPerCore(); tid++)
        {
            cout << "Socket" << sid << " Thread" << tid << "     ";
        }
    }

    cout << "\n-----------------------------------------------------------------------------\n";

    for (unsigned int cid=0; cid<core_size_per_socket; cid++)
    {
        for (unsigned int sid=0; sid<m->getNumSockets(); sid++)
        {
            for (unsigned int tid=0; tid<m->getThreadsPerCore(); tid++)
            {
                cout << "Core" << sk_th[sid][tid][cid].core_id << ": " << fixed << setprecision(2) << sk_th[sid][tid][cid].latency << "        ";
            }
        }
        cout << "\n";
    }
    cout << "\n";

    cout << "Average latency per socket";
    printHeader();

    for (unsigned int s = 0; s < m->getNumSockets(); ++s)
    {
        cout << "Socket" << s << ": " << core_latency[L1].socket[s].latency << "\n";
    }
    cout << "\n";
}

void print_all_stats(PCM *m, bool enable_pmm, bool enable_verbose)
{
    vector < vector < vector < struct core_info >>> sk_th;
    unsigned int sid, cid, tid;
    unsigned int core_size_per_socket=0;
   //Populate Core info per Socket and thread_id
   //Create 3D vector with Socket as 1D, Thread as 2D and Core info for the 3D
    for (sid = 0; sid < m->getNumSockets(); sid++)
    {
        vector < vector <core_info> > tmp_thread;
        for (tid = 0; tid < m->getThreadsPerCore(); tid++)
        {
            vector <core_info> tmp_core;
            for (cid = 0; cid < m->getNumCores(); cid++)
            {
                if ((sid == (unsigned int)(m->getSocketId(cid))) && (tid == (unsigned int)(m->getThreadId(cid))))
                {
                core_info tmp;
                tmp.core_id = cid;
                tmp.latency = core_latency[L1].core[cid].latency;
                tmp_core.push_back(tmp);
                }
            }
            core_size_per_socket = (unsigned int)tmp_core.size();
            tmp_thread.push_back(tmp_core);
        }
        sk_th.push_back(tmp_thread);
    }

    print_core_stats(m, core_size_per_socket, sk_th);

    if (m->DDRLatencyMetricsAvailable())
    {
        print_ddr(m, enable_pmm);
        if (enable_verbose)
            print_verbose(m, enable_pmm);
    }
}

EventSelectRegister build_core_register(uint64 reg_used, uint64 value, uint64 usr, uint64 os, uint64 enable, uint64 umask, uint64 event_select, uint64 edge)
{
    regs[reg_used].value = value;
    regs[reg_used].fields.usr = usr;
    regs[reg_used].fields.os = os;
    regs[reg_used].fields.enable = enable;
    regs[reg_used].fields.umask = umask;
    regs[reg_used].fields.event_select = event_select;
    regs[reg_used].fields.edge = edge;
    return regs[reg_used];
}

void check_status(PCM *m, PCM::ErrorCode status)
{
    m->checkError(status);
    print_cpu_details();

    if(!(m->LatencyMetricsAvailable()))
    {
        cerr << "Platform not Supported! Program aborted\n";
        exit(EXIT_FAILURE);
    }

    if(m->getNumSockets() > max_sockets)
    {
        cerr << "Only systems with up to " <<(int)max_sockets<< " sockets are supported! Program aborted\n";
        exit(EXIT_FAILURE);
    }
}

void build_registers(PCM *m, PCM::ExtendedCustomCoreEventDescription conf, bool enable_pmm, bool /*enable_verbose*/)
{

//Check if Online Cores = Available Cores. This version only supports available cores = online cores
    if (m->getNumCores() != m->getNumOnlineCores())
    {
        cout << "Number of online cores should be equal to number of available cores\n";
        exit(EXIT_FAILURE);
    }

    //Check for Maximum Custom Core Events
    if (m->getMaxCustomCoreEvents() < 2)
    {
        cout << "System should support a minimum of 2 Custom Core Events to run pcm-latency\n";
        exit(EXIT_FAILURE);
    }
//Creating conf
    conf.fixedCfg = NULL; // default
    conf.nGPCounters = 2;
    conf.gpCounterCfg = regs;
    conf.OffcoreResponseMsrValue[0] = 0;
    conf.OffcoreResponseMsrValue[1] = 0;

// Registers for L1 cache
    regs[FB_OCC_RD] = build_core_register(FB_OCC_RD, 0, 1, 1, 1, 0x01, 0x48, 0); //L1d Fill Buffer Occupancy (Read Only)
    regs[FB_INS_RD] = build_core_register(FB_INS_RD, 0, 1, 1, 1, 0x48, 0xd1, 0); //MEM_LOAD_RETIRED(FB_HIT + L1_MISS)

//Restructuring Counters
    for (int i=0; i <5; i++)
    {
        uncore_event[i].skt.resize(m->getNumSockets());
        core_latency[i].core.resize(m->getNumCores());
        core_latency[i].socket.resize(m->getNumSockets());
    }

//Program Core and Uncore
    m->resetPMU();
    PCM::ErrorCode status = m->program(PCM::EXT_CUSTOM_CORE_EVENTS, &conf);
    check_status(m, status);
    m->programServerUncoreLatencyMetrics(enable_pmm);
}

void collect_data(PCM *m, bool enable_pmm, bool enable_verbose, int delay_ms, MainLoop & mainLoop)
{

    BeforeState = new ServerUncoreCounterState[m->getNumSockets()];
    AfterState = new ServerUncoreCounterState[m->getNumSockets()];

    mainLoop([&]()
    {
        collect_beforestate_uncore(m);
        collect_beforestate_core(m);

	MySleepMs(delay_ms);

        collect_afterstate_uncore(m);
        collect_afterstate_core(m);

	store_latency_uncore(m, enable_pmm, delay_ms);// 0 for DDR
	store_latency_core(m);

        print_all_stats(m, enable_pmm, enable_verbose);
        std::cout << std::flush;
        return true;
    });

    deleteAndNullifyArray(BeforeState);
    deleteAndNullifyArray(AfterState);
}

void print_usage()
{
    cout << "\nUsage: \n";
    cout << " -h | --help | /h          => print this help and exit\n";
    cout << " --PMM | -pmm              => to enable PMM (Default DDR uncore latency)\n";
    cout << " -i[=number] | /i[=number] => allow to determine number of iterations\n";
    cout << " -silent                   => silence information output and print only measurements\n";
    cout << " --version                 => print application version\n";
    cout << " -v | --verbose            => verbose Output\n";
    cout << "\n";
}

PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{   

    if(print_version(argc, argv))
        exit(EXIT_SUCCESS);

    null_stream nullStream;
    check_and_set_silent(argc, argv, nullStream);
    
    set_signal_handlers();

    std::cout << "\n Intel(r) Performance Counter Monitor " << PCM_VERSION << "\n";
    std::cout << "\n This utility measures Latency information\n\n";
    bool enable_pmm = false;
    bool enable_verbose = false;
    int delay_ms = 1000;
    MainLoop mainLoop;
    if(argc > 1) do
    {
        argv++;
        argc--;

        if (check_argument_equals(*argv, {"--help", "-h", "/h"}))
        {
            print_usage();
            exit(EXIT_FAILURE);
        }
        else if (check_argument_equals(*argv, {"-silent", "/silent"}))
        {
            // handled in check_and_set_silent
            continue;
        }
        else if (mainLoop.parseArg(*argv))
        {
            continue;
        }
        else if (check_argument_equals(*argv, {"--PMM", "-pmm"}))
        {
            enable_pmm = true;
            continue;
        }
        else if (check_argument_equals(*argv, {"--verbose", "-v", "/v"}))
        {
            enable_verbose = true;
            continue;
        }
    } while(argc > 1);

    PCM::ExtendedCustomCoreEventDescription conf;
    PCM * m = PCM::getInstance();

    SysBeforeState = std::make_shared<SystemCounterState>();
    SysAfterState = std::make_shared<SystemCounterState>();
    BeforeState_core = std::make_shared<std::vector<CoreCounterState> >();
    AfterState_core = std::make_shared<std::vector<CoreCounterState> >();
    DummySocketStates = std::make_shared<std::vector<SocketCounterState> >();

    build_registers(m, conf, enable_pmm, enable_verbose);
    collect_data(m, enable_pmm, enable_verbose, delay_ms, mainLoop);

    exit(EXIT_SUCCESS);
}

```

`src/pcm-memory.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Patrick Lu
// increased max sockets to 256 - Thomas Willhalm


/*!     \file pcm-memory.cpp
  \brief Example of using CPU counters: implements a performance counter monitoring utility for memory controller channels and DIMMs (ranks) + PMM memory traffic
  */
#include <iostream>
#ifdef _MSC_VER
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#include <signal.h>
#include <sys/time.h> // for gettimeofday()
#endif
#include <math.h>
#include <iomanip>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <string>
#include <assert.h>
#include "cpucounters.h"
#include "utils.h"

#define PCM_DELAY_DEFAULT 1.0 // in seconds
#define PCM_DELAY_MIN 0.015 // 15 milliseconds is practical on most modern CPUs

#define DEFAULT_DISPLAY_COLUMNS 2

using namespace std;
using namespace pcm;

constexpr uint32 max_sockets = 256;
uint32 max_imc_channels = ServerUncoreCounterState::maxChannels;
const uint32 max_edc_channels = ServerUncoreCounterState::maxChannels;
const uint32 max_imc_controllers = ServerUncoreCounterState::maxControllers;
bool SPR_CXL = false; // use SPR CXL monitoring implementation

typedef struct memdata {
    float iMC_Rd_socket_chan[max_sockets][ServerUncoreCounterState::maxChannels]{};
    float iMC_Wr_socket_chan[max_sockets][ServerUncoreCounterState::maxChannels]{};
    float iMC_PMM_Rd_socket_chan[max_sockets][ServerUncoreCounterState::maxChannels]{};
    float iMC_PMM_Wr_socket_chan[max_sockets][ServerUncoreCounterState::maxChannels]{};
    float MemoryMode_Miss_socket_chan[max_sockets][ServerUncoreCounterState::maxChannels]{};
    float iMC_Rd_socket[max_sockets]{};
    float iMC_Wr_socket[max_sockets]{};
    float iMC_PMM_Rd_socket[max_sockets]{};
    float iMC_PMM_Wr_socket[max_sockets]{};
    float CXLMEM_Rd_socket_port[max_sockets][ServerUncoreCounterState::maxCXLPorts]{};
    float CXLMEM_Wr_socket_port[max_sockets][ServerUncoreCounterState::maxCXLPorts]{};
    float CXLCACHE_Rd_socket_port[max_sockets][ServerUncoreCounterState::maxCXLPorts]{};
    float CXLCACHE_Wr_socket_port[max_sockets][ServerUncoreCounterState::maxCXLPorts]{};
    float MemoryMode_Miss_socket[max_sockets]{};
    bool NM_hit_rate_supported{};
    bool BHS_NM{};
    bool BHS{};
    float MemoryMode_Hit_socket[max_sockets]{};
    bool M2M_NM_read_hit_rate_supported{};
    float NM_hit_rate[max_sockets]{};
    float M2M_NM_read_hit_rate[max_sockets][max_imc_controllers]{};
    float EDC_Rd_socket_chan[max_sockets][max_edc_channels]{};
    float EDC_Wr_socket_chan[max_sockets][max_edc_channels]{};
    float EDC_Rd_socket[max_sockets]{};
    float EDC_Wr_socket[max_sockets]{};
    uint64 partial_write[max_sockets]{};
    ServerUncoreMemoryMetrics metrics{};
} memdata_t;

bool anyPmem(const ServerUncoreMemoryMetrics & metrics)
{
    return (metrics == Pmem) || (metrics == PmemMixedMode) || (metrics == PmemMemoryMode);
}

bool skipInactiveChannels = true;
bool enforceFlush = false;

void print_help(const string & prog_name)
{
    cout << "\n Usage: \n " << prog_name
         << " --help | [delay] [options] [-- external_program [external_program_options]]\n";
    cout << "   <delay>                           => time interval to sample performance counters.\n";
    cout << "                                        If not specified, or 0, with external program given\n";
    cout << "                                        will read counters only after external program finishes\n";
    cout << " Supported <options> are: \n";
    cout << "  -h    | --help  | /h               => print this help and exit\n";
    cout << "  -rank=X | /rank=X                  => monitor DIMM rank X. At most 2 out of 8 total ranks can be monitored simultaneously.\n";
    cout << "  -pmm | /pmm | -pmem | /pmem        => monitor PMM memory bandwidth and DRAM cache hit rate in Memory Mode (default on systems with PMM support).\n";
    cout << "  -mm                                => monitor detailed PMM Memory Mode metrics per-socket.\n";
    cout << "  -mixed                             => monitor PMM mixed mode (AppDirect + Memory Mode).\n";
    cout << "  -partial                           => monitor partial writes instead of PMM (default on systems without PMM support).\n";
    cout << "  -nc   | --nochannel | /nc          => suppress output for individual channels.\n";
    cout << "  --nocxl                            => suppress output for CXL ports.\n";
    cout << "  -csv[=file.csv] | /csv[=file.csv]  => output compact CSV format to screen or\n"
         << "                                        to a file, in case filename is provided\n";
    cout << "  -columns=X | /columns=X            => Number of columns to display the NUMA Nodes, defaults to 2.\n";
    cout << "  -all | /all                        => Display all channels (even with no traffic)\n";
    cout << "  -i[=number] | /i[=number]          => allow to determine number of iterations\n";
    cout << "  -silent                            => silence information output and print only measurements\n";
    cout << "  --version                          => print application version\n";
    cout << "  -u                                 => update measurements instead of printing new ones\n";
    print_enforce_flush_option_help();
#ifdef _MSC_VER
    cout << "  --uninstallDriver | --installDriver=> (un)install driver\n";
#endif
    cout << " Examples:\n";
    cout << "  " << prog_name << " 1                  => print counters every second without core and socket output\n";
    cout << "  " << prog_name << " 0.5 -csv=test.log  => twice a second save counter values to test.log in CSV format\n";
    cout << "  " << prog_name << " /csv 5 2>/dev/null => one sample every 5 seconds, and discard all diagnostic output\n";
    cout << "\n";
}

void printSocketBWHeader(uint32 no_columns, uint32 skt, const bool show_channel_output)
{
    for (uint32 i=skt; i<(no_columns+skt); ++i) {
        cout << "|---------------------------------------|";
    }
    cout << "\n";
    for (uint32 i=skt; i<(no_columns+skt); ++i) {
        cout << "|--             Socket " << setw(2) << i << "             --|";
    }
    cout << "\n";
    for (uint32 i=skt; i<(no_columns+skt); ++i) {
        cout << "|---------------------------------------|";
    }
    cout << "\n";
    if (show_channel_output) {
       for (uint32 i=skt; i<(no_columns+skt); ++i) {
           cout << "|--     Memory Channel Monitoring     --|";
       }
       cout << "\n";
       for (uint32 i=skt; i<(no_columns+skt); ++i) {
           cout << "|---------------------------------------|";
       }
       cout << "\n";
    }
}

void printSocketRankBWHeader(uint32 no_columns, uint32 skt)
{
    for (uint32 i=skt; i<(no_columns+skt); ++i) {
        cout << "|-------------------------------------------|";
    }
    cout << "\n";
    for (uint32 i=skt; i<(no_columns+skt); ++i) {
        cout << "|--               Socket " << setw(2) << i << "               --|";
    }
    cout << "\n";
    for (uint32 i=skt; i<(no_columns+skt); ++i) {
        cout << "|-------------------------------------------|";
    }
    cout << "\n";
    for (uint32 i=skt; i<(no_columns+skt); ++i) {
        cout << "|--           DIMM Rank Monitoring        --|";
    }
    cout << "\n";
    for (uint32 i=skt; i<(no_columns+skt); ++i) {
        cout << "|-------------------------------------------|";
    }
    cout << "\n";
}

void printSocketRankBWHeader_cvt(const uint32 numSockets, const uint32 num_imc_channels, const int rankA, const int rankB)
{
    printDateForCSV(Header1);
    for (uint32 skt = 0 ; skt < (numSockets) ; ++skt) {
        for (uint32 channel = 0; channel < num_imc_channels; ++channel) {
            if (rankA >= 0)
                cout << "SKT" << skt << "," << "SKT" << skt << ",";
            if (rankB >= 0)
                cout << "SKT" << skt << "," << "SKT" << skt << ",";
        }
    }
    cout << endl;

    printDateForCSV(Header2);
    for (uint32 skt = 0 ; skt < (numSockets) ; ++skt) {
        for (uint32 channel = 0; channel < num_imc_channels; ++channel) {
            if (rankA >= 0) {
                cout << "Mem_Ch" << channel << "_R" << rankA << "_reads,"
                     << "Mem_Ch" << channel << "_R" << setw(1) << rankA << "_writes,";
            }
            if (rankB >= 0) {
                cout << "Mem_Ch" << channel << "_R" << rankB << "_reads,"
                     << "Mem_Ch" << channel << "_R" << setw(1) << rankB << "_writes,";
            }
        }
    }
    cout << endl;
}

void printSocketChannelBW(PCM *, memdata_t *md, uint32 no_columns, uint32 skt)
{
    for (uint32 channel = 0; channel < max_imc_channels; ++channel) {
        // check all the sockets for bad channel "channel"
        unsigned bad_channels = 0;
        for (uint32 i=skt; i<(skt+no_columns); ++i) {
            if (md->iMC_Rd_socket_chan[i][channel] < 0.0 || md->iMC_Wr_socket_chan[i][channel] < 0.0) //If the channel read neg. value, the channel is not working; skip it.
                ++bad_channels;
        }
        if (bad_channels == no_columns) { // the channel is missing on all sockets in the row
            continue;
        }
        for (uint32 i=skt; i<(skt+no_columns); ++i) {
            cout << "|-- Mem Ch " << setw(2) << channel << ": Reads (MB/s): " << setw(8) << md->iMC_Rd_socket_chan[i][channel] << " --|";
        }
        cout << "\n";
        for (uint32 i=skt; i<(skt+no_columns); ++i) {
            cout << "|--            Writes(MB/s): " << setw(8) << md->iMC_Wr_socket_chan[i][channel] << " --|";
        }
        cout << "\n";
        if (md->metrics == Pmem)
        {
            for (uint32 i=skt; i<(skt+no_columns); ++i) {
                cout << "|--      PMM Reads(MB/s)   : " << setw(8) << md->iMC_PMM_Rd_socket_chan[i][channel] << " --|";
            }
            cout << "\n";
            for (uint32 i=skt; i<(skt+no_columns); ++i) {
                cout << "|--      PMM Writes(MB/s)  : " << setw(8) << md->iMC_PMM_Wr_socket_chan[i][channel] << " --|";
            }
            cout << "\n";
        }
    }
}

void printSocketChannelBW(uint32 no_columns, uint32 skt, uint32 num_imc_channels, const std::vector<ServerUncoreCounterState>& uncState1, const std::vector<ServerUncoreCounterState>& uncState2, uint64 elapsedTime, int rankA, int rankB)
{
    for (uint32 channel = 0; channel < num_imc_channels; ++channel) {
        if(rankA >= 0) {
          for (uint32 i=skt; i<(skt+no_columns); ++i) {
              cout << "|-- Mem Ch " << setw(2) << channel << " R " << setw(1) << rankA << ": Reads (MB/s): " << setw(8) << (float) (getMCCounter(channel,ServerUncorePMUs::EventPosition::READ_RANK_A,uncState1[i],uncState2[i]) * 64 / 1000000.0 / (elapsedTime/1000.0)) << " --|";
          }
          cout << "\n";
          for (uint32 i=skt; i<(skt+no_columns); ++i) {
              cout << "|--                Writes(MB/s): " << setw(8) << (float) (getMCCounter(channel,ServerUncorePMUs::EventPosition::WRITE_RANK_A,uncState1[i],uncState2[i]) * 64 / 1000000.0 / (elapsedTime/1000.0)) << " --|";
          }
          cout << "\n";
        }
        if(rankB >= 0) {
          for (uint32 i=skt; i<(skt+no_columns); ++i) {
              cout << "|-- Mem Ch " << setw(2) << channel << " R " << setw(1) << rankB << ": Reads (MB/s): " << setw(8) << (float) (getMCCounter(channel,ServerUncorePMUs::EventPosition::READ_RANK_B,uncState1[i],uncState2[i]) * 64 / 1000000.0 / (elapsedTime/1000.0)) << " --|";
          }
          cout << "\n";
          for (uint32 i=skt; i<(skt+no_columns); ++i) {
              cout << "|--                Writes(MB/s): " << setw(8) << (float) (getMCCounter(channel,ServerUncorePMUs::EventPosition::WRITE_RANK_B,uncState1[i],uncState2[i]) * 64 / 1000000.0 / (elapsedTime/1000.0)) << " --|";
          }
          cout << "\n";
        }
    }
}

void printSocketChannelBW_cvt(const uint32 numSockets, const uint32 num_imc_channels, const std::vector<ServerUncoreCounterState>& uncState1,
    const std::vector<ServerUncoreCounterState>& uncState2, const uint64 elapsedTime, const int rankA, const int rankB)
{
    printDateForCSV(Data);
    for (uint32 skt = 0 ; skt < numSockets; ++skt) {
        for (uint32 channel = 0 ; channel < num_imc_channels ; ++channel) {
            if(rankA >= 0) {
                cout << (float) (getMCCounter(channel,ServerUncorePMUs::EventPosition::READ_RANK_A,uncState1[skt],uncState2[skt]) * 64 / 1000000.0 / (elapsedTime/1000.0))
                << "," << (float) (getMCCounter(channel,ServerUncorePMUs::EventPosition::WRITE_RANK_A,uncState1[skt],uncState2[skt]) * 64 / 1000000.0 / (elapsedTime/1000.0)) << ",";
            }
            if(rankB >= 0) {
                cout << (float) (getMCCounter(channel,ServerUncorePMUs::EventPosition::READ_RANK_B,uncState1[skt],uncState2[skt]) * 64 / 1000000.0 / (elapsedTime/1000.0))
                << "," << (float) (getMCCounter(channel,ServerUncorePMUs::EventPosition::WRITE_RANK_B,uncState1[skt],uncState2[skt]) * 64 / 1000000.0 / (elapsedTime/1000.0)) << ",";
            }
        }
    }
    cout << endl;
}

uint32 getNumCXLPorts(PCM* m)
{
    static int numPorts = -1;
    if (numPorts < 0)
    {
        for (uint32 s = 0; s < m->getNumSockets(); ++s)
        {
            numPorts = (std::max)(numPorts, (int)m->getNumCXLPorts(s));
        }
        assert(numPorts >= 0);
    }
    return (uint32)numPorts;
}

void printSocketCXLBW(PCM* m, memdata_t* md, uint32 no_columns, uint32 skt)
{
    uint32 numPorts = getNumCXLPorts(m);
    if (numPorts > 0)
    {
        for (uint32 i = skt; i < (no_columns + skt); ++i) {
            cout << "|---------------------------------------|";
        }
        cout << "\n";
        for (uint32 i = skt; i < (no_columns + skt); ++i) {
            cout << "|--        CXL Port Monitoring        --|";
        }
        cout << "\n";
        for (uint32 i = skt; i < (no_columns + skt); ++i) {
            cout << "|---------------------------------------|";
        }
        cout << "\n";
    }
    for (uint32 port = 0; port < numPorts; ++port) {
        if (md->BHS)
        {
            for (uint32 i = skt; i < (skt + no_columns); ++i) {
                cout << "|-- .mem   " << setw(2) << port << "  Reads (MB/s): " << setw(8) << md->CXLMEM_Rd_socket_port[i][port] << " --|";
            }
        }
        else
        {
            for (uint32 i = skt; i < (skt + no_columns); ++i) {
                cout << "|-- .mem                              --|";
            }
        }
        cout << "\n";
        for (uint32 i = skt; i < (skt + no_columns); ++i) {
            cout << "|--            Writes(MB/s): " << setw(8) << md->CXLMEM_Wr_socket_port[i][port] << " --|";
        }
        cout << "\n";
        if (md->BHS)
        {
            for (uint32 i = skt; i < (skt + no_columns); ++i) {
                cout << "|-- .cache " << setw(2) << port << " dv->hst(MB/s): " << setw(8) << md->CXLCACHE_Rd_socket_port[i][port] << " --|";
            }
        }
        else
        {
            for (uint32 i = skt; i < (skt + no_columns); ++i) {
                cout << "|-- .cache                            --|";
            }
        }
        cout << "\n";
        for (uint32 i = skt; i < (skt + no_columns); ++i) {
            cout << "|--           hst->dv(MB/s): " << setw(8) << md->CXLCACHE_Wr_socket_port[i][port] << " --|";
        }
        cout << "\n";
    }
}

float AD_BW(const memdata_t *md, const uint32 skt)
{
    const auto totalPMM = md->iMC_PMM_Rd_socket[skt] + md->iMC_PMM_Wr_socket[skt];
    return (max)(totalPMM - md->MemoryMode_Miss_socket[skt], float(0.0));
}

float PMM_MM_Ratio(const memdata_t *md, const uint32 skt)
{
    const auto dram = md->iMC_Rd_socket[skt] + md->iMC_Wr_socket[skt];
    return md->MemoryMode_Miss_socket[skt] / dram;
}

void printSocketBWFooter(PCM *m, uint32 no_columns, uint32 skt, const memdata_t *md)
{
    for (uint32 i=skt; i<(skt+no_columns); ++i) {
        cout << "|-- SKT " << setw(2) << i << " Mem Read (MB/s) :" << setw(9) << md->iMC_Rd_socket[i] << " --|";
    }
    cout << "\n";
    for (uint32 i=skt; i<(skt+no_columns); ++i) {
        cout << "|-- SKT " << setw(2) << i << " Mem Write(MB/s) :" << setw(9) << md->iMC_Wr_socket[i] << " --|";
    }
    cout << "\n";
    if (anyPmem(md->metrics))
    {
        for (uint32 i=skt; i<(skt+no_columns); ++i) {
            cout << "|-- SKT " << setw(2) << i << " PMM Read (MB/s):  " << setw(8) << md->iMC_PMM_Rd_socket[i] << " --|";
        }
        cout << "\n";
        for (uint32 i=skt; i<(skt+no_columns); ++i) {
            cout << "|-- SKT " << setw(2) << i << " PMM Write(MB/s):  " << setw(8) << md->iMC_PMM_Wr_socket[i] << " --|";
        }
        cout << "\n";
    }
    if (md->metrics == PmemMixedMode)
    {
        for (uint32 i = skt; i < (skt + no_columns); ++i)
        {
            cout << "|-- SKT " << setw(2) << i << " PMM AD Bw(MB/s):  " << setw(8) << AD_BW(md, i) << " --|";
        }
        cout << "\n";
        for (uint32 i = skt; i < (skt + no_columns); ++i)
        {
            cout << "|-- SKT " << setw(2) << i << " PMM MM Bw(MB/s):  " << setw(8) << md->MemoryMode_Miss_socket[i] << " --|";
        }
        cout << "\n";
        for (uint32 i = skt; i < (skt + no_columns); ++i)
        {
            cout << "|-- SKT " << setw(2) << i << " PMM MM Bw/DRAM Bw:" << setw(8) << PMM_MM_Ratio(md, i) << " --|";
        }
        cout << "\n";
    }
    else if (md->metrics == Pmem && md->M2M_NM_read_hit_rate_supported)
    {
        for (uint32 ctrl = 0; ctrl < max_imc_controllers; ++ctrl)
        {
            for (uint32 i=skt; i<(skt+no_columns); ++i) {
                cout << "|-- SKT " << setw(2) << i << "." << ctrl << " NM read hit rate :" << setw(6) << md->M2M_NM_read_hit_rate[i][ctrl] << " --|";
            }
            cout << "\n";
        }
    }
    if ((md->metrics == PmemMemoryMode && md->NM_hit_rate_supported) || md->BHS_NM == true)
    {
        for (uint32 i=skt; i<(skt+no_columns); ++i) {
            cout << "|-- SKT " << setw(2) << i << " NM hit rate:        " << setw(6) << md->NM_hit_rate[i] << " --|";
        }
        cout << "\n";
        for (uint32 i=skt; i<(skt+no_columns); ++i) {
            cout << "|-- SKT " << setw(2) << i << " NM hits   (M/s):   " << setw(7) << (md->MemoryMode_Hit_socket[i])/1000000. << " --|";
        }
        cout << "\n";
        for (uint32 i=skt; i<(skt+no_columns); ++i) {
            cout << "|-- SKT " << setw(2) << i << " NM misses (M/s):   " << setw(7) << (md->MemoryMode_Miss_socket[i])/1000000. << " --|";
        }
        cout << "\n";
    }
    if (md->BHS_NM == true)
    {
        for (uint32 i = skt; i < (skt + no_columns); ++i) {
            cout << "|-- SKT " << setw(2) << i << " NM miss Bw(MB/s):" << setw(9) << (md->MemoryMode_Miss_socket[i] * 64. * 2.) / 1000000. << " --|";
        }
        cout << "\n";
    }
    if (    md->metrics == PartialWrites
        &&  m->getCPUFamilyModel() != PCM::SRF
        &&  m->getCPUFamilyModel() != PCM::GNR
        &&  m->getCPUFamilyModel() != PCM::GNR_D
        &&  m->getCPUFamilyModel() != PCM::GRR
        )
    {
        for (uint32 i=skt; i<(skt+no_columns); ++i) {
            cout << "|-- SKT " << setw(2) << i << " P. Write (T/s): " << dec << setw(10) << md->partial_write[i] << " --|";
        }
        cout << "\n";
    }
    for (uint32 i=skt; i<(skt+no_columns); ++i) {
        cout << "|-- SKT " << setw(2) << i << " Memory (MB/s): " << setw(11) << right << (md->iMC_Rd_socket[i]+md->iMC_Wr_socket[i]+
              md->iMC_PMM_Rd_socket[i]+md->iMC_PMM_Wr_socket[i]) << " --|";
    }
    cout << "\n";
    for (uint32 i=skt; i<(no_columns+skt); ++i) {
        cout << "|---------------------------------------|";
    }
    cout << "\n";
}

void display_bandwidth(PCM *m, memdata_t *md, const uint32 no_columns, const bool show_channel_output, const bool print_update, const float CXL_Read_BW, const bool show_cxl_bandwidth)
{
    float sysReadDRAM = 0.0, sysWriteDRAM = 0.0, sysReadPMM = 0.0, sysWritePMM = 0.0;
    uint32 numSockets = m->getNumSockets();
    uint32 skt = 0;
    cout.setf(ios::fixed);
    cout.precision(2);

    if (print_update)
        clear_screen();

    while (skt < numSockets)
    {
        auto printHBM = [&]()
        {
                cout << "\
                    \r|---------------------------------------||---------------------------------------|\n\
                    \r|--                              Processor socket "
                     << skt << "                            --|\n\
                    \r|---------------------------------------||---------------------------------------|\n\
                    \r|--       DRAM Channel Monitoring     --||--        HBM Channel Monitoring     --|\n\
                    \r|---------------------------------------||---------------------------------------|\n\
                    \r";
                const uint32 max_channels = (std::max)(max_edc_channels, max_imc_channels);
                if (show_channel_output)
                {
                    float iMC_Rd, iMC_Wr, EDC_Rd, EDC_Wr;
                    for (uint64 channel = 0; channel < max_channels; ++channel)
                    {
                        if (channel < max_imc_channels)
                        {
                            iMC_Rd = md->iMC_Rd_socket_chan[skt][channel];
                            iMC_Wr = md->iMC_Wr_socket_chan[skt][channel];
                        }
                        else
                        {
                            iMC_Rd = -1.0;
                            iMC_Wr = -1.0;
                        }
                        if (channel < max_edc_channels)
                        {
                            EDC_Rd = md->EDC_Rd_socket_chan[skt][channel];
                            EDC_Wr = md->EDC_Wr_socket_chan[skt][channel];
                        }
                        else
                        {
                            EDC_Rd = -1.0;
                            EDC_Wr = -1.0;
                        }

                        if (iMC_Rd >= 0.0 && iMC_Wr >= 0.0 && EDC_Rd >= 0.0 && EDC_Wr >= 0.0)
                            cout << "|-- DRAM Ch " << setw(2) << channel << ": Reads (MB/s):" << setw(8) << iMC_Rd
                                 << " --||-- HBM Ch " << setw(2) << channel << ": Reads (MB/s):" << setw(9) << EDC_Rd
                                 << " --|\n|--             Writes(MB/s):" << setw(8) << iMC_Wr
                                 << " --||--            Writes(MB/s):" << setw(9) << EDC_Wr
                                 << " --|\n";
                        else if ((iMC_Rd < 0.0 || iMC_Wr < 0.0) && EDC_Rd >= 0.0 && EDC_Wr >= 0.0)
                            cout << "|--                                  "
                                 << " --||-- HBM Ch " << setw(2) << channel << ": Reads (MB/s):" << setw(9) << EDC_Rd
                                 << " --|\n|--                                  "
                                 << " --||--            Writes(MB/s):" << setw(9) << EDC_Wr
                                 << " --|\n";

                        else if (iMC_Rd >= 0.0 && iMC_Wr >= 0.0 && (EDC_Rd < 0.0 || EDC_Wr < 0.0))
                            cout << "|-- DRAM Ch " << setw(2) << channel << ": Reads (MB/s):" << setw(8) << iMC_Rd
                                 << " --||--                                  "
                                 << " --|\n|--             Writes(MB/s):" << setw(8) << iMC_Wr
                                 << " --||--                                  "
                                 << " --|\n";
                        else
                            continue;
                    }
                }
                cout << "\
                    \r|-- DRAM Mem Read  (MB/s):"
                     << setw(11) << md->iMC_Rd_socket[skt] << " --||-- HBM Read (MB/s):" << setw(14+3) << md->EDC_Rd_socket[skt] << " --|\n\
                    \r|-- DRAM Mem Write (MB/s):"
                     << setw(11) << md->iMC_Wr_socket[skt] << " --||-- HBM Write(MB/s):" << setw(14+3) << md->EDC_Wr_socket[skt] << " --|\n\
                    \r|-- DRAM Memory (MB/s)   :"
                     << setw(11) << md->iMC_Rd_socket[skt] + md->iMC_Wr_socket[skt] << " --||-- HBM (MB/s)     :" << setw(14+3) << md->EDC_Rd_socket[skt] + md->EDC_Wr_socket[skt] << " --|\n\
                    \r|---------------------------------------||---------------------------------------|\n\
                    \r";

                sysReadDRAM += (md->iMC_Rd_socket[skt] + md->EDC_Rd_socket[skt]);
                sysWriteDRAM += (md->iMC_Wr_socket[skt] + md->EDC_Wr_socket[skt]);
                skt += 1;
            };
        auto printRow = [&skt,&show_channel_output,&m,&md,&sysReadDRAM,&sysWriteDRAM, &sysReadPMM, &sysWritePMM, &show_cxl_bandwidth](const uint32 no_columns)
        {
            printSocketBWHeader(no_columns, skt, show_channel_output);
            if (show_channel_output)
                printSocketChannelBW(m, md, no_columns, skt);
            printSocketBWFooter(m, no_columns, skt, md);
            if (show_cxl_bandwidth)
            {
                printSocketCXLBW(m, md, no_columns, skt);
            }
            for (uint32 i = skt; i < (skt + no_columns); i++)
            {
                sysReadDRAM += md->iMC_Rd_socket[i];
                sysWriteDRAM += md->iMC_Wr_socket[i];
                sysReadPMM += md->iMC_PMM_Rd_socket[i];
                sysWritePMM += md->iMC_PMM_Wr_socket[i];
            }
            skt += no_columns;
        };
        if (m->HBMmemoryTrafficMetricsAvailable())
        {
            printHBM(); // no_columns is ignored, always 1 socket at a time
        }
        else if ((skt + no_columns) <= numSockets) // Full row
        {
            printRow(no_columns);
        }
        else //Display the remaining sockets in this row
        {
            printRow(numSockets - skt);
        }
    }
    {
        cout << "\
            \r|---------------------------------------||---------------------------------------|\n";
        if (anyPmem(md->metrics))
        {
            cout << "\
            \r|--            System DRAM Read Throughput(MB/s):" << setw(14) << sysReadDRAM <<                                     "                --|\n\
            \r|--           System DRAM Write Throughput(MB/s):" << setw(14) << sysWriteDRAM <<                                    "                --|\n\
            \r|--             System PMM Read Throughput(MB/s):" << setw(14) << sysReadPMM <<                                      "                --|\n\
            \r|--            System PMM Write Throughput(MB/s):" << setw(14) << sysWritePMM <<                                     "                --|\n";
        }
        if (SPR_CXL)
        {
            cout << "\
            \r|--             System CXL Read Throughput(MB/s):" << setw(14) << CXL_Read_BW << "                --|\n";
        }
        cout << "\
            \r|--                 System Read Throughput(MB/s):" << setw(14) << sysReadDRAM+sysReadPMM <<                          "                --|\n\
            \r|--                System Write Throughput(MB/s):" << setw(14) << sysWriteDRAM+sysWritePMM <<                        "                --|\n\
            \r|--               System Memory Throughput(MB/s):" << setw(14) << sysReadDRAM+sysReadPMM+sysWriteDRAM+sysWritePMM << "                --|\n\
            \r|---------------------------------------||---------------------------------------|\n";
    }
}

constexpr float CXLBWWrScalingFactor = 0.5;

void display_bandwidth_csv(PCM *m, memdata_t *md, uint64 /*elapsedTime*/, const bool show_channel_output, const CsvOutputType outputType, const float CXL_Read_BW, const bool show_cxl_output)
{
    const uint32 numSockets = m->getNumSockets();
    printDateForCSV(outputType);

    float sysReadDRAM = 0.0, sysWriteDRAM = 0.0, sysReadPMM = 0.0, sysWritePMM = 0.0;

    for (uint32 skt = 0; skt < numSockets; ++skt)
    {
        auto printSKT = [skt](int c = 1) {
            for (int i = 0; i < c; ++i)
                cout << "SKT" << skt << ',';
        };
        if (show_channel_output)
        {
            for (uint64 channel = 0; channel < max_imc_channels; ++channel)
            {
                bool invalid_data = false;
                if (md->iMC_Rd_socket_chan[skt][channel] < 0.0 && md->iMC_Wr_socket_chan[skt][channel] < 0.0) //If the channel read neg. value, the channel is not working; skip it.
                    invalid_data = true;

                choose(outputType,
                       [printSKT]() {
                           printSKT(2);
                       },
                       [&channel]() {
                           cout << "Ch" << channel << "Read,"
                                << "Ch" << channel << "Write,";
                       },
                       [&md, &skt, &channel, &invalid_data]() {
                           if (invalid_data)
                               cout << ",,";
                           else
                               cout << setw(8) << md->iMC_Rd_socket_chan[skt][channel] << ','
                                    << setw(8) << md->iMC_Wr_socket_chan[skt][channel] << ',';
                       });

                if (md->metrics == Pmem)
                {
                    choose(outputType,
                           [printSKT]() {
                               printSKT(2);
                           },
                           [&channel]() {
                               cout << "Ch" << channel << "PMM_Read,"
                                    << "Ch" << channel << "PMM_Write,";
                           },
                           [&skt, &md, &channel, &invalid_data]() {
                               if (invalid_data)
                                   cout << ",,";
                               else
                                   cout << setw(8) << md->iMC_PMM_Rd_socket_chan[skt][channel] << ','
                                        << setw(8) << md->iMC_PMM_Wr_socket_chan[skt][channel] << ',';
                           });
                }
            }
        }
        choose(outputType,
               [printSKT]() {
                   printSKT(2);
               },
               []() {
                   cout << "Mem Read (MB/s),Mem Write (MB/s),";
               },
               [&md, &skt]() {
                   cout << setw(8) << md->iMC_Rd_socket[skt] << ','
                        << setw(8) << md->iMC_Wr_socket[skt] << ',';
               });

        if (anyPmem(md->metrics))
        {
            choose(outputType,
                   [printSKT]() {
                       printSKT(2);
                   },
                   []() {
                       cout << "PMM_Read (MB/s), PMM_Write (MB/s),";
                   },
                   [&md, &skt]() {
                       cout << setw(8) << md->iMC_PMM_Rd_socket[skt] << ','
                            << setw(8) << md->iMC_PMM_Wr_socket[skt] << ',';
                   });
        }
        if ((md->metrics == PmemMemoryMode && md->NM_hit_rate_supported) || md->BHS_NM == true)
        {
            choose(outputType,
                [printSKT]() {
                    printSKT(3);
                },
                []() {
                    cout << "NM hit rate,";
                    cout << "NM hits (M/s),";
                    cout << "NM misses (M/s),";
                },
                [&md, &skt]() {
                    cout << setw(8) << md->NM_hit_rate[skt]<< ',';
                    cout << setw(8) << md->MemoryMode_Hit_socket[skt]/1000000. << ',';
                    cout << setw(8) << md->MemoryMode_Miss_socket[skt]/1000000. << ',';
                });
        }
        if (md->BHS_NM == true)
        {
            choose(outputType,
                [printSKT]() {
                    printSKT();
                },
                []() {
                    cout << "NM miss Bw (MB/s),";
                },
                    [&md, &skt]() {
                    cout << setw(9) << (md->MemoryMode_Miss_socket[skt] * 64. * 2.) / 1000000. << ',';
                });
        }
        if (md->metrics == Pmem && md->M2M_NM_read_hit_rate_supported)
        {
            for (uint32 c = 0; c < max_imc_controllers; ++c)
            {
                choose(outputType,
                    [printSKT]() {
                        printSKT();
                    },
                    [c]() {
                        cout << "iMC" << c << " NM read hit rate,";
                    },
                    [&md, &skt, c]() {
                        cout << setw(8) << md->M2M_NM_read_hit_rate[skt][c] << ',';
                    });
            }
        }
        if (md->metrics == PmemMixedMode)
        {
            choose(outputType,
                   [printSKT]() {
                       printSKT(3);
                   },
                   []() {
                       cout << "PMM_AD (MB/s), PMM_MM (MB/s), PMM_MM_Bw/DRAM_Bw,";
                   },
                   [&md, &skt]() {
                       cout << setw(8) << AD_BW(md, skt) << ','
                            << setw(8) << md->MemoryMode_Miss_socket[skt] << ','
                            << setw(8) << PMM_MM_Ratio(md, skt) << ',';
                   });
        }
        if (m->HBMmemoryTrafficMetricsAvailable() == false)
        {
            if (    md->metrics == PartialWrites
                &&  m->getCPUFamilyModel() != PCM::GNR
                &&  m->getCPUFamilyModel() != PCM::GNR_D
                &&  m->getCPUFamilyModel() != PCM::SRF
                &&  m->getCPUFamilyModel() != PCM::GRR
                )
            {
                choose(outputType,
                       [printSKT]() {
                           printSKT();
                       },
                       []() {
                           cout << "P. Write (T/s),";
                       },
                       [&md, &skt]() {
                           cout << setw(10) << dec << md->partial_write[skt] << ',';
                       });
            }
        }

        choose(outputType,
               [printSKT]() {
                   printSKT();
               },
               []() {
                   cout << "Memory (MB/s),";
               },
               [&]() {
                   cout << setw(8) << md->iMC_Rd_socket[skt] + md->iMC_Wr_socket[skt] << ',';

                   sysReadDRAM += md->iMC_Rd_socket[skt];
                   sysWriteDRAM += md->iMC_Wr_socket[skt];
                   sysReadPMM += md->iMC_PMM_Rd_socket[skt];
                   sysWritePMM += md->iMC_PMM_Wr_socket[skt];
               });

        if (m->HBMmemoryTrafficMetricsAvailable())
        {
            if (show_channel_output)
            {
                for (uint64 channel = 0; channel < max_edc_channels; ++channel)
                {
                    if (md->EDC_Rd_socket_chan[skt][channel] < 0.0 && md->EDC_Wr_socket_chan[skt][channel] < 0.0) //If the channel read neg. value, the channel is not working; skip it.
                        continue;

                    choose(outputType,
                           [printSKT]() {
                               printSKT(2);
                           },
                           [&channel]() {
                               cout << "EDC_Ch" << channel << "Read,"
                                    << "EDC_Ch" << channel << "Write,";
                           },
                           [&md, &skt, &channel]() {
                               cout << setw(8) << md->EDC_Rd_socket_chan[skt][channel] << ','
                                    << setw(8) << md->EDC_Wr_socket_chan[skt][channel] << ',';
                           });
                }
            }

            choose(outputType,
                   [printSKT]() {
                       printSKT(3);
                   },
                   []() {
                       cout << "HBM Read (MB/s), HBM Write (MB/s), HBM (MB/s),";
                   },
                   [&]() {
                       cout << setw(8) << md->EDC_Rd_socket[skt] << ','
                            << setw(8) << md->EDC_Wr_socket[skt] << ','
                            << setw(8) << md->EDC_Rd_socket[skt] + md->EDC_Wr_socket[skt] << ',';

                       sysReadDRAM += md->EDC_Rd_socket[skt];
                       sysWriteDRAM += md->EDC_Wr_socket[skt];
                   });
        }
        if (show_cxl_output)
        {
            for (uint64 port = 0; port < m->getNumCXLPorts(skt); ++port)
            {
                choose(outputType,
                    [printSKT, &md]() {
                        printSKT((md->BHS)? 4 : 2 );
                    },
                    [&port,&md]() {
                        if (md->BHS)
                        {
                            cout << "CXL.mem_P" << port << "Read,"
                                << "CXL.mem_P" << port << "Write,"
                                << "CXL.cache_P" << port << "dv->hst,"
                                << "CXL.cache_P" << port << "hst->dv,";
                        }
                        else
                        {
                            cout
                                << "CXL.mem_P" << port << "Write,"
                                << "CXL.cache_P" << port << "hst->dv,";
                        }
                    },
                        [&md, &skt, &port]() {
                        if (md->BHS)
                        {
                            cout << setw(8) << md->CXLMEM_Rd_socket_port[skt][port] << ','
                                << setw(8) << md->CXLMEM_Wr_socket_port[skt][port] << ','
                                << setw(8) << md->CXLCACHE_Rd_socket_port[skt][port] << ','
                                << setw(8) << md->CXLCACHE_Wr_socket_port[skt][port] << ',';
                        }
                        else
                        {
                            cout << setw(8) << md->CXLMEM_Wr_socket_port[skt][port] << ','
                                << setw(8) << md->CXLCACHE_Wr_socket_port[skt][port] << ',';
                        }
                    });
            }
        }
    }

    if (anyPmem(md->metrics))
    {
        choose(outputType,
               []() {
                   cout << "System,System,System,System,";
               },
               []() {
                   cout << "DRAMRead,DRAMWrite,PMMREAD,PMMWrite,";
               },
               [&]() {
                   cout << setw(10) << sysReadDRAM << ','
                        << setw(10) << sysWriteDRAM << ','
                        << setw(10) << sysReadPMM << ','
                        << setw(10) << sysWritePMM << ',';
               });
    }

    if (SPR_CXL)
    {
        choose(outputType,
            []() {
                cout << "System,";
            },
            []() {
                cout << "CXLRead,";
            },
                [&]() {
                cout << setw(10) << CXL_Read_BW << ',';
            });
    }

    choose(outputType,
           []() {
               cout << "System,System,System\n";
           },
           []() {
               cout << "Read,Write,Memory\n";
           },
           [&]() {
               cout << setw(10) << sysReadDRAM + sysReadPMM << ','
                    << setw(10) << sysWriteDRAM + sysWritePMM << ','
                    << setw(10) << sysReadDRAM + sysReadPMM + sysWriteDRAM + sysWritePMM << "\n";
           });
}

void calculate_bandwidth(PCM *m,
    const std::vector<ServerUncoreCounterState>& uncState1,
    const std::vector<ServerUncoreCounterState>& uncState2,
    const uint64 elapsedTime,
    const bool csv,
    bool & csvheader,
    uint32 no_columns,
    const ServerUncoreMemoryMetrics & metrics,
    const bool show_channel_output,
    const bool print_update,
    const uint64 SPR_CHA_CXL_Count,
    const bool show_cxl_output)
{
    //const uint32 num_imc_channels = m->getMCChannelsPerSocket();
    //const uint32 num_edc_channels = m->getEDCChannelsPerSocket();
    memdata_t md;
    md.metrics = metrics;
    const auto cpu_family_model = m->getCPUFamilyModel();
    md.M2M_NM_read_hit_rate_supported = (cpu_family_model == PCM::SKX);
    md.NM_hit_rate_supported = (cpu_family_model == PCM::ICX);
    md.BHS_NM = m->nearMemoryMetricsAvailable();
    md.BHS = md.BHS_NM;
    static bool mm_once = true;
    if (metrics == Pmem && md.M2M_NM_read_hit_rate_supported == false && md.NM_hit_rate_supported == true && mm_once)
    {
        cerr << "INFO: Use -mm option to monitor NM Memory Mode metrics\n";
        mm_once = false;
    }
    static bool mm_once1 = true;
    if (metrics == PmemMemoryMode && md.M2M_NM_read_hit_rate_supported == true && md.NM_hit_rate_supported == false && mm_once1)
    {
        cerr << "INFO: Use -pmem option to monitor NM Memory Mode metrics\n";
        mm_once1 = false;
    }

    for(uint32 skt = 0; skt < max_sockets; ++skt)
    {
        md.iMC_Rd_socket[skt] = 0.0;
        md.iMC_Wr_socket[skt] = 0.0;
        md.iMC_PMM_Rd_socket[skt] = 0.0;
        md.iMC_PMM_Wr_socket[skt] = 0.0;
        md.MemoryMode_Miss_socket[skt] = 0.0;
        md.MemoryMode_Hit_socket[skt] = 0.0;
        md.NM_hit_rate[skt] = 0.0;
        md.EDC_Rd_socket[skt] = 0.0;
        md.EDC_Wr_socket[skt] = 0.0;
        md.partial_write[skt] = 0;
		for (uint32 i = 0; i < max_imc_controllers; ++i)
		{
			md.M2M_NM_read_hit_rate[skt][i] = 0.;
		}
        for (size_t p = 0; p < ServerUncoreCounterState::maxCXLPorts; ++p)
        {
            md.CXLMEM_Rd_socket_port[skt][p] = 0.0;
            md.CXLMEM_Wr_socket_port[skt][p] = 0.0;
            md.CXLCACHE_Rd_socket_port[skt][p] = 0.0;
            md.CXLCACHE_Wr_socket_port[skt][p] = 0.0;
        }
    }

    auto toBW = [&elapsedTime](const uint64 nEvents)
    {
        return (float)(nEvents * 64 / 1000000.0 / (elapsedTime / 1000.0));
    };

    auto toRate = [&elapsedTime](const uint64 nEvents)
    {
        return (float)(nEvents / (elapsedTime / 1000.0));
    };

    for(uint32 skt = 0; skt < m->getNumSockets(); ++skt)
    {
        const uint32 numChannels1 = (uint32)m->getMCChannels(skt, 0); // number of channels in the first controller


        if (m->HBMmemoryTrafficMetricsAvailable())
        {
            const float scalingFactor = ((float)m->getHBMCASTransferSize()) / float(64.);

            for (uint32 channel = 0; channel < max_edc_channels; ++channel)
            {
                if (skipInactiveChannels && getEDCCounter(channel, ServerUncorePMUs::EventPosition::READ, uncState1[skt], uncState2[skt]) == 0.0 && getEDCCounter(channel, ServerUncorePMUs::EventPosition::WRITE, uncState1[skt], uncState2[skt]) == 0.0)
                {
                    md.EDC_Rd_socket_chan[skt][channel] = -1.0;
                    md.EDC_Wr_socket_chan[skt][channel] = -1.0;
                    continue;
                }

                md.EDC_Rd_socket_chan[skt][channel] = scalingFactor * toBW(getEDCCounter(channel, ServerUncorePMUs::EventPosition::READ, uncState1[skt], uncState2[skt]));
                md.EDC_Wr_socket_chan[skt][channel] = scalingFactor * toBW(getEDCCounter(channel, ServerUncorePMUs::EventPosition::WRITE, uncState1[skt], uncState2[skt]));

                md.EDC_Rd_socket[skt] += md.EDC_Rd_socket_chan[skt][channel];
                md.EDC_Wr_socket[skt] += md.EDC_Wr_socket_chan[skt][channel];
            }
        }

        {
            for (uint32 channel = 0; channel < max_imc_channels; ++channel)
            {
                uint64 reads = 0, writes = 0, pmmReads = 0, pmmWrites = 0, memoryModeCleanMisses = 0, memoryModeDirtyMisses = 0;
                uint64 memoryModeHits = 0;
                reads = getMCCounter(channel, ServerUncorePMUs::EventPosition::READ, uncState1[skt], uncState2[skt]);
                writes = getMCCounter(channel, ServerUncorePMUs::EventPosition::WRITE, uncState1[skt], uncState2[skt]);
                switch (cpu_family_model)
                {
                case PCM::GNR:
                case PCM::GNR_D:
                case PCM::GRR:
                case PCM::SRF:
                    reads += getMCCounter(channel, ServerUncorePMUs::EventPosition::READ2, uncState1[skt], uncState2[skt]);
                    writes += getMCCounter(channel, ServerUncorePMUs::EventPosition::WRITE2, uncState1[skt], uncState2[skt]);
                    break;
                }
                if (metrics == Pmem)
                {
                    pmmReads = getMCCounter(channel, ServerUncorePMUs::EventPosition::PMM_READ, uncState1[skt], uncState2[skt]);
                    pmmWrites = getMCCounter(channel, ServerUncorePMUs::EventPosition::PMM_WRITE, uncState1[skt], uncState2[skt]);
                }
                else if (metrics == PmemMixedMode || metrics == PmemMemoryMode)
                {
                    memoryModeCleanMisses = getMCCounter(channel, ServerUncorePMUs::EventPosition::MM_MISS_CLEAN, uncState1[skt], uncState2[skt]);
                    memoryModeDirtyMisses = getMCCounter(channel, ServerUncorePMUs::EventPosition::MM_MISS_DIRTY, uncState1[skt], uncState2[skt]);
                }
                if (metrics == PmemMemoryMode)
                {
                    memoryModeHits = getMCCounter(channel, ServerUncorePMUs::EventPosition::NM_HIT, uncState1[skt], uncState2[skt]);
                }
                if (skipInactiveChannels && (reads + writes == 0))
                {
                    if ((metrics != Pmem) || (pmmReads + pmmWrites == 0))
                    {
                        if ((metrics != PmemMixedMode) || (memoryModeCleanMisses + memoryModeDirtyMisses == 0))
                        {

                            md.iMC_Rd_socket_chan[skt][channel] = -1.0;
                            md.iMC_Wr_socket_chan[skt][channel] = -1.0;
                            continue;
                        }
                    }
                }

                if (metrics != PmemMemoryMode)
                {
                    md.iMC_Rd_socket_chan[skt][channel] = toBW(reads);
                    md.iMC_Wr_socket_chan[skt][channel] = toBW(writes);

                    md.iMC_Rd_socket[skt] += md.iMC_Rd_socket_chan[skt][channel];
                    md.iMC_Wr_socket[skt] += md.iMC_Wr_socket_chan[skt][channel];
                }

                if (metrics == Pmem)
                {
                    md.iMC_PMM_Rd_socket_chan[skt][channel] = toBW(pmmReads);
                    md.iMC_PMM_Wr_socket_chan[skt][channel] = toBW(pmmWrites);

                    md.iMC_PMM_Rd_socket[skt] += md.iMC_PMM_Rd_socket_chan[skt][channel];
                    md.iMC_PMM_Wr_socket[skt] += md.iMC_PMM_Wr_socket_chan[skt][channel];

                    md.M2M_NM_read_hit_rate[skt][(channel < numChannels1) ? 0 : 1] += (float)reads;
                }
                else if (metrics == PmemMixedMode)
                {
                    md.MemoryMode_Miss_socket_chan[skt][channel] = toBW(memoryModeCleanMisses + 2 * memoryModeDirtyMisses);
                    md.MemoryMode_Miss_socket[skt] += md.MemoryMode_Miss_socket_chan[skt][channel];
                }
                else if (metrics == PmemMemoryMode)
                {
                    md.MemoryMode_Miss_socket[skt] += toRate(memoryModeCleanMisses + memoryModeDirtyMisses);
                    md.MemoryMode_Hit_socket[skt] += toRate(memoryModeHits);
                }
                else if (
                   cpu_family_model != PCM::GNR
                && cpu_family_model != PCM::GNR_D
                && cpu_family_model != PCM::SRF
                && cpu_family_model != PCM::GRR
                    )
                {
                    md.partial_write[skt] += (uint64)(getMCCounter(channel, ServerUncorePMUs::EventPosition::PARTIAL, uncState1[skt], uncState2[skt]) / (elapsedTime / 1000.0));
                }
            }
        }
        if (metrics == PmemMemoryMode)
        {
            const int64 imcReads = getFreeRunningCounter(ServerUncoreCounterState::ImcReads, uncState1[skt], uncState2[skt]);
            if (imcReads >= 0)
            {
                md.iMC_Rd_socket[skt] += toBW(imcReads);
            }
            const int64 imcWrites = getFreeRunningCounter(ServerUncoreCounterState::ImcWrites, uncState1[skt], uncState2[skt]);
            if (imcWrites >= 0)
            {
                md.iMC_Wr_socket[skt] += toBW(imcWrites);
            }
        }
        if (metrics == PmemMixedMode || metrics == PmemMemoryMode)
        {
            const int64 pmmReads = getFreeRunningCounter(ServerUncoreCounterState::PMMReads, uncState1[skt], uncState2[skt]);
            if (pmmReads >= 0)
            {
                md.iMC_PMM_Rd_socket[skt] += toBW(pmmReads);
            }
            else for (uint32 c = 0; c < max_imc_controllers; ++c)
            {
                md.iMC_PMM_Rd_socket[skt] += toBW(getM2MCounter(c, ServerUncorePMUs::EventPosition::PMM_READ, uncState1[skt], uncState2[skt]));
            }

            const int64 pmmWrites = getFreeRunningCounter(ServerUncoreCounterState::PMMWrites, uncState1[skt], uncState2[skt]);
            if (pmmWrites >= 0)
            {
                md.iMC_PMM_Wr_socket[skt] += toBW(pmmWrites);
            }
            else for (uint32 c = 0; c < max_imc_controllers; ++c)
            {
                md.iMC_PMM_Wr_socket[skt] += toBW(getM2MCounter(c, ServerUncorePMUs::EventPosition::PMM_WRITE, uncState1[skt], uncState2[skt]));;
            }
        }
        if (metrics == Pmem)
        {
            for (uint32 c = 0; c < max_imc_controllers; ++c)
            {
                if (md.M2M_NM_read_hit_rate[skt][c] != 0.0)
                {
                    md.M2M_NM_read_hit_rate[skt][c] = ((float)getM2MCounter(c, ServerUncorePMUs::EventPosition::NM_HIT, uncState1[skt], uncState2[skt])) / md.M2M_NM_read_hit_rate[skt][c];
                }
            }
        }
        if (md.BHS_NM)
        {
            for (uint32 c = 0; c < max_imc_controllers; ++c)
            {
                md.MemoryMode_Hit_socket[skt] += toRate(getM2MCounter(c, ServerUncorePMUs::EventPosition::NM_HIT, uncState1[skt], uncState2[skt]));
                md.MemoryMode_Miss_socket[skt] += toRate(getM2MCounter(c, ServerUncorePMUs::EventPosition::MM_MISS_CLEAN, uncState1[skt], uncState2[skt]));
                md.MemoryMode_Miss_socket[skt] += toRate(getM2MCounter(c, ServerUncorePMUs::EventPosition::MM_MISS_DIRTY, uncState1[skt], uncState2[skt]));
            }
        }
        const auto all = md.MemoryMode_Miss_socket[skt] + md.MemoryMode_Hit_socket[skt];
        if ((metrics == PmemMemoryMode || md.BHS_NM == true) && all != 0.0)
        {
            md.NM_hit_rate[skt] = md.MemoryMode_Hit_socket[skt] / all;
        }

        for (size_t p = 0; p < m->getNumCXLPorts(skt); ++p)
        {
            if (md.BHS)
            {
                md.CXLMEM_Rd_socket_port[skt][p] = toBW(getCXLCMCounter((uint32)p, PCM::EventPosition::CXL_RxC_MEM, uncState1[skt], uncState2[skt]));
                md.CXLMEM_Wr_socket_port[skt][p] = toBW(getCXLDPCounter((uint32)p, PCM::EventPosition::CXL_TxC_MEM, uncState1[skt], uncState2[skt]));
                md.CXLCACHE_Rd_socket_port[skt][p] = toBW(getCXLCMCounter((uint32)p, PCM::EventPosition::CXL_RxC_CACHE, uncState1[skt], uncState2[skt]));
                md.CXLCACHE_Wr_socket_port[skt][p] = toBW(getCXLCMCounter((uint32)p, PCM::EventPosition::CXL_TxC_CACHE, uncState1[skt], uncState2[skt]));
            }
            else
            {
                md.CXLMEM_Wr_socket_port[skt][p] = CXLBWWrScalingFactor * toBW(getCXLCMCounter((uint32)p, PCM::EventPosition::CXL_TxC_MEM, uncState1[skt], uncState2[skt]));
                md.CXLCACHE_Wr_socket_port[skt][p] = CXLBWWrScalingFactor * toBW(getCXLCMCounter((uint32)p, PCM::EventPosition::CXL_TxC_CACHE, uncState1[skt], uncState2[skt]));
            }
        }
    }

    const auto CXL_Read_BW = toBW(SPR_CHA_CXL_Count);

    if (csv)
    {
        if (csvheader)
        {
            display_bandwidth_csv(m, &md, elapsedTime, show_channel_output, Header1, CXL_Read_BW, show_cxl_output);
            display_bandwidth_csv(m, &md, elapsedTime, show_channel_output, Header2, CXL_Read_BW, show_cxl_output);
            csvheader = false;
        }
        display_bandwidth_csv(m, &md, elapsedTime, show_channel_output, Data, CXL_Read_BW, show_cxl_output);
    }
    else
    {
        display_bandwidth(m, &md, no_columns, show_channel_output, print_update, CXL_Read_BW, show_cxl_output);
    }
}

void calculate_bandwidth_rank(PCM *m, const std::vector<ServerUncoreCounterState> & uncState1, const std::vector<ServerUncoreCounterState>& uncState2,
		const uint64 elapsedTime, const bool csv, bool &csvheader, const uint32 no_columns, const int rankA, const int rankB)
{
    uint32 skt = 0;
    cout.setf(ios::fixed);
    cout.precision(2);
    uint32 numSockets = m->getNumSockets();

    if (csv) {
        if (csvheader) {
            printSocketRankBWHeader_cvt(numSockets, max_imc_channels, rankA, rankB);
            csvheader = false;
        }
        printSocketChannelBW_cvt(numSockets, max_imc_channels, uncState1, uncState2, elapsedTime, rankA, rankB);
    } else {
        while(skt < numSockets) {
            auto printRow = [&skt, &uncState1, &uncState2, &elapsedTime, &rankA, &rankB](const uint32 no_columns) {
                printSocketRankBWHeader(no_columns, skt);
                printSocketChannelBW(no_columns, skt, max_imc_channels, uncState1, uncState2, elapsedTime, rankA, rankB);
                for (uint32 i = skt; i < (no_columns + skt); ++i)
                    cout << "|-------------------------------------------|";
                cout << "\n";
                skt += no_columns;
            };
            // Full row
            if ((skt + no_columns) <= numSockets)
                printRow(no_columns);
            else //Display the remaining sockets in this row
                printRow(numSockets - skt);
        }
    }
}

void readState(std::vector<ServerUncoreCounterState>& state)
{
    auto* pcm = PCM::getInstance();
    assert(pcm);
    for (uint32 i = 0; i < pcm->getNumSockets(); ++i)
        state[i] = pcm->getServerUncoreCounterState(i);
};

class CHAEventCollector
{
    std::vector<eventGroup_t> eventGroups;
    double delay;
    const char* sysCmd;
    const MainLoop& mainLoop;
    PCM* pcm;
    std::vector<std::vector<ServerUncoreCounterState> > MidStates;
    size_t curGroup = 0ULL;
    uint64 totalCount = 0ULL;
    CHAEventCollector() = delete;
    CHAEventCollector(const CHAEventCollector&) = delete;
    CHAEventCollector & operator = (const CHAEventCollector &) = delete;

    uint64 extractCHATotalCount(const std::vector<ServerUncoreCounterState>& before, const std::vector<ServerUncoreCounterState>& after)
    {
        uint64 result = 0;
        for (uint32 i = 0; i < pcm->getNumSockets(); ++i)
        {
            for (uint32 cbo = 0; cbo < pcm->getMaxNumOfUncorePMUs(PCM::CBO_PMU_ID); ++cbo)
            {
                for (uint32 ctr = 0; ctr < 4 && ctr < eventGroups[curGroup].size(); ++ctr)
                {
                    result += getUncoreCounter(PCM::CBO_PMU_ID, cbo, ctr, before[i], after[i]);
                }
            }
        }
        return result;
    }
    void programGroup(const size_t group)
    {
        uint64 events[4] = { 0, 0, 0, 0 };
        assert(group < eventGroups.size());
        for (size_t i = 0; i < 4 && i < eventGroups[group].size(); ++i)
        {
            events[i] = eventGroups[group][i];
        }
        pcm->programCboRaw(events, 0, 0);
    }

public:
    CHAEventCollector(const double delay_, const char* sysCmd_, const MainLoop& mainLoop_, PCM* m) :
        sysCmd(sysCmd_),
        mainLoop(mainLoop_),
        pcm(m)
    {
        assert(pcm);
        switch (pcm->getCPUFamilyModel())
        {
            case PCM::SPR:
                eventGroups = {
                    {
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x10C80B82) , // UNC_CHA_TOR_INSERTS.IA_MISS_CRDMORPH_CXL_ACC
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x10c80782) , // UNC_CHA_TOR_INSERTS.IA_MISS_RFO_CXL_ACC
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x10c81782) , // UNC_CHA_TOR_INSERTS.IA_MISS_DRD_CXL_ACC
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x10C88782)   // UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFRFO_CXL_ACC
                    },
                    {
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x10CCC782) , // UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF_CXL_ACC
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x10C89782) , // UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF_CXL_ACC
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x10CCD782) , // UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFDATA_CXL_ACC
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x10CCCF82)   // UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFCODE_CXL_ACC
                    }
                };
                break;
            case PCM::EMR:
                eventGroups = {
                    {
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x20C80682) , // UNC_CHA_TOR_INSERTS.IA_MISS_RFO_CXL_EXP_LOCAL
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x20C81682) , // UNC_CHA_TOR_INSERTS.IA_MISS_DRD_CXL_EXP_LOCAL
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x20C88682)   // UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFRFO_CXL_EXP_LOCAL
                    },
                    {
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x20CCC682) , // UNC_CHA_TOR_INSERTS.IA_MISS_RFO_PREF_CXL_EXP_LOCAL
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x20C89682) , // UNC_CHA_TOR_INSERTS.IA_MISS_DRD_PREF_CXL_EXP_LOCAL
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x01) + UNC_PMON_CTL_UMASK_EXT(0x20CCD682) , // UNC_CHA_TOR_INSERTS.IA_MISS_LLCPREFDATA_CXL_EXP_LOCAL
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x40) + UNC_PMON_CTL_UMASK_EXT(0x20E87E82) , // UNC_CHA_TOR_INSERTS.RRQ_MISS_INVXTOM_CXL_EXP_LOCAL
                    },
                    {
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x40) + UNC_PMON_CTL_UMASK_EXT(0x20E80682) , // UNC_CHA_TOR_INSERTS.RRQ_MISS_RDCUR_CXL_EXP_LOCAL
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x40) + UNC_PMON_CTL_UMASK_EXT(0x20E80E82) , // UNC_CHA_TOR_INSERTS.RRQ_MISS_RDCODE_CXL_EXP_LOCAL
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x40) + UNC_PMON_CTL_UMASK_EXT(0x20E81682) , // UNC_CHA_TOR_INSERTS.RRQ_MISS_RDDATA_CXL_EXP_LOCAL
                        UNC_PMON_CTL_EVENT(0x35) + UNC_PMON_CTL_UMASK(0x40) + UNC_PMON_CTL_UMASK_EXT(0x20E82682) , // UNC_CHA_TOR_INSERTS.RRQ_MISS_RDINVOWN_OPT_CXL_EXP_LOCAL
                    }
                };
                break;
        }

        assert(eventGroups.size() > 1);

        delay = delay_ / double(eventGroups.size());
        MidStates.resize(eventGroups.size() - 1);
        for (auto& e : MidStates)
        {
            e.resize(pcm->getNumSockets());
        }
    }

    void programFirstGroup()
    {
        programGroup(0);
    }

    void multiplexEvents(const std::vector<ServerUncoreCounterState>& BeforeState)
    {
        for (curGroup = 0; curGroup < eventGroups.size() - 1; ++curGroup)
        {
            assert(curGroup < MidStates.size());
            calibratedSleep(delay, sysCmd, mainLoop, pcm);
            readState(MidStates[curGroup]);  // TODO: read only CHA counters (performance optmization)
            totalCount += extractCHATotalCount((curGroup > 0) ? MidStates[curGroup - 1] : BeforeState, MidStates[curGroup]);
            programGroup(curGroup + 1);
            readState(MidStates[curGroup]);  // TODO: read only CHA counters (performance optmization)
        }

        calibratedSleep(delay, sysCmd, mainLoop, pcm);
    }

    uint64 getTotalCount(const std::vector<ServerUncoreCounterState>& AfterState)
    {
        return eventGroups.size() * (totalCount + extractCHATotalCount(MidStates.back(), AfterState));
    }

    void reset()
    {
        totalCount = 0;
    }
};

#ifndef UNIT_TEST

PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
    if(print_version(argc, argv))
        exit(EXIT_SUCCESS);

    null_stream nullStream2;
#ifdef PCM_FORCE_SILENT
    null_stream nullStream1;
    cout.rdbuf(&nullStream1);
    cerr.rdbuf(&nullStream2);
#else
    check_and_set_silent(argc, argv, nullStream2);
#endif

    set_signal_handlers();

    cerr << "\n";
    cerr << " Intel(r) Performance Counter Monitor: Memory Bandwidth Monitoring Utility " << PCM_VERSION << "\n";
    cerr << "\n";

    cerr << " This utility measures memory bandwidth per channel or per DIMM rank in real-time\n";
    cerr << "\n";

    double delay = -1.0;
    bool csv = false, csvheader = false, show_channel_output = true, print_update = false;
    bool show_cxl_output = true;
    uint32 no_columns = DEFAULT_DISPLAY_COLUMNS; // Default number of columns is 2
    char * sysCmd = NULL;
    char ** sysArgv = NULL;
    int rankA = -1, rankB = -1;
    MainLoop mainLoop;

    string program = string(argv[0]);

    PCM * m = PCM::getInstance();
    assert(m);
    if (m->getNumSockets() > max_sockets)
    {
        cerr << "Only systems with up to " << max_sockets << " sockets are supported! Program aborted\n";
        exit(EXIT_FAILURE);
    }
    ServerUncoreMemoryMetrics metrics;
    metrics = m->PMMTrafficMetricsAvailable() ? Pmem : PartialWrites;

    if (argc > 1) do
    {
        argv++;
        argc--;
        string arg_value;

        if (check_argument_equals(*argv, {"--help", "-h", "/h"}))
        {
            print_help(program);
            exit(EXIT_FAILURE);
        }
        else if (check_argument_equals(*argv, {"-silent", "/silent"}))
        {
            // handled in check_and_set_silent
            continue;
        }
        else if (check_argument_equals(*argv, {"-csv", "/csv"}))
        {
            csv = csvheader = true;
        }
        else if (extract_argument_value(*argv, {"-csv", "/csv"}, arg_value))
        {
            csv = true;
            csvheader = true;
            if (!arg_value.empty()) {
                m->setOutput(arg_value);
            }
            continue;
        }
        else if (mainLoop.parseArg(*argv))
        {
            continue;
        }
        else if (extract_argument_value(*argv, {"-columns", "/columns"}, arg_value))
        {
            if(arg_value.empty()) {
                continue;
            }
            no_columns = stoi(arg_value);
            if (no_columns == 0)
                no_columns = DEFAULT_DISPLAY_COLUMNS;
            if (no_columns > m->getNumSockets())
                no_columns = m->getNumSockets();
            continue;
        }
        else if (extract_argument_value(*argv, {"-rank", "/rank"}, arg_value))
        {
            if(arg_value.empty()) {
                continue;
            }
            int rank = stoi(arg_value);
            if (rankA >= 0 && rankB >= 0)
            {
                cerr << "At most two DIMM ranks can be monitored \n";
                exit(EXIT_FAILURE);
            } else {
                if(rank > 7) {
                    cerr << "Invalid rank number " << rank << "\n";
                    exit(EXIT_FAILURE);
                }
                if(rankA < 0) rankA = rank;
                else if(rankB < 0) rankB = rank;
                metrics = PartialWrites;
            }
            continue;
        }
        else if (check_argument_equals(*argv, {"--nochannel", "/nc", "-nc"}))
        {
            show_channel_output = false;
            continue;
        }
        else if (check_argument_equals(*argv, {"--nocxl"}))
        {
            show_cxl_output = false;
            continue;
        }
        else if (check_argument_equals(*argv, {"-pmm", "/pmm", "-pmem", "/pmem"}))
        {
            metrics = Pmem;
            continue;
        }
        else if (check_argument_equals(*argv, {"-all", "/all"}))
        {
            skipInactiveChannels = false;
            continue;
        }
        else if (check_argument_equals(*argv, {"-mixed", "/mixed"}))
        {
            metrics = PmemMixedMode;
            continue;
        }
        else if (check_argument_equals(*argv, {"-mm", "/mm"}))
        {
            metrics = PmemMemoryMode;
            show_channel_output = false;
            continue;
        }
        else if (check_argument_equals(*argv, {"-partial", "/partial"}))
        {
            metrics = PartialWrites;
            continue;
        }
        else if (check_argument_equals(*argv, {"-u", "/u"}))
        {
            print_update = true;
            continue;
        }
        PCM_ENFORCE_FLUSH_OPTION
#ifdef _MSC_VER
        else if (check_argument_equals(*argv, {"--uninstallDriver"}))
        {
            Driver tmpDrvObject;
            tmpDrvObject.uninstall();
            cerr << "msr.sys driver has been uninstalled. You might need to reboot the system to make this effective.\n";
            exit(EXIT_SUCCESS);
        }
        else if (check_argument_equals(*argv, {"--installDriver"}))
        {
            Driver tmpDrvObject = Driver(Driver::msrLocalPath());
            if (!tmpDrvObject.start())
            {
                tcerr << "Can not access CPU counters\n";
                tcerr << "You must have a signed  driver at " << tmpDrvObject.driverPath() << " and have administrator rights to run this program\n";
                exit(EXIT_FAILURE);
            }
            exit(EXIT_SUCCESS);
        }
#endif
        else if (check_argument_equals(*argv, {"--"}))
        {
            argv++;
            sysCmd = *argv;
            sysArgv = argv;
            break;
        }
        else
        {
            delay = parse_delay(*argv, program, (print_usage_func)print_help);
            continue;
        }
    } while (argc > 1); // end of command line parsing loop

    m->disableJKTWorkaround();
    print_cpu_details();
    const auto cpu_family_model = m->getCPUFamilyModel();
    if (!m->hasPCICFGUncore())
    {
        cerr << "Unsupported processor model (0x" << std::hex << cpu_family_model << std::dec << ").\n";
        if (m->memoryTrafficMetricsAvailable())
            cerr << "For processor-level memory bandwidth statistics please use 'pcm' utility\n";
        exit(EXIT_FAILURE);
    }
    if (anyPmem(metrics) && (m->PMMTrafficMetricsAvailable() == false))
    {
        cerr << "PMM/Pmem traffic metrics are not available on your processor.\n";
        exit(EXIT_FAILURE);
    }
    if (metrics == PmemMemoryMode && m->PMMMemoryModeMetricsAvailable() == false)
    {
       cerr << "PMM Memory Mode metrics are not available on your processor.\n";
       exit(EXIT_FAILURE);
    }
    if (metrics == PmemMixedMode && m->PMMMixedModeMetricsAvailable() == false)
    {
        cerr << "PMM Mixed Mode metrics are not available on your processor.\n";
        exit(EXIT_FAILURE);
    }
    if((rankA >= 0 || rankB >= 0) && anyPmem(metrics))
    {
        cerr << "PMM/Pmem traffic metrics are not available on rank level\n";
        exit(EXIT_FAILURE);
    }
    if((rankA >= 0 || rankB >= 0) && !show_channel_output)
    {
        cerr << "Rank level output requires channel output\n";
        exit(EXIT_FAILURE);
    }
    PCM::ErrorCode status = m->programServerUncoreMemoryMetrics(metrics, rankA, rankB);
    m->checkError(status);

    max_imc_channels = (pcm::uint32)m->getMCChannelsPerSocket();

    std::vector<ServerUncoreCounterState> BeforeState(m->getNumSockets());
    std::vector<ServerUncoreCounterState> AfterState(m->getNumSockets());
    uint64 BeforeTime = 0, AfterTime = 0;

    if ( (sysCmd != NULL) && (delay<=0.0) ) {
        // in case external command is provided in command line, and
        // delay either not provided (-1) or is zero
        m->setBlocked(true);
    } else {
        m->setBlocked(false);
    }

    if (csv) {
        if( delay<=0.0 ) delay = PCM_DELAY_DEFAULT;
    } else {
        // for non-CSV mode delay < 1.0 does not make a lot of practical sense:
        // hard to read from the screen, or
        // in case delay is not provided in command line => set default
        if( ((delay<1.0) && (delay>0.0)) || (delay<=0.0) ) delay = PCM_DELAY_DEFAULT;
    }

    shared_ptr<CHAEventCollector> chaEventCollector;

    SPR_CXL = (PCM::SPR == cpu_family_model || PCM::EMR == cpu_family_model) && (getNumCXLPorts(m) > 0);
    if (SPR_CXL)
    {
         chaEventCollector = std::make_shared<CHAEventCollector>(delay, sysCmd, mainLoop, m);
         assert(chaEventCollector.get());
         chaEventCollector->programFirstGroup();
    }

    cerr << "Update every " << delay << " seconds\n";

    if (csv)
        cerr << "Read/Write values expressed in (MB/s)" << endl;

    readState(BeforeState);

    uint64 SPR_CHA_CXL_Event_Count = 0;

    BeforeTime = m->getTickCount();

    if( sysCmd != NULL ) {
        MySystem(sysCmd, sysArgv);
    }

    mainLoop([&]()
    {
        if (enforceFlush || !csv) cout << flush;

        if (chaEventCollector.get())
        {
            chaEventCollector->multiplexEvents(BeforeState);
        }
        else
        {
            calibratedSleep(delay, sysCmd, mainLoop, m);
        }

        AfterTime = m->getTickCount();
        readState(AfterState);
        if (chaEventCollector.get())
        {
            SPR_CHA_CXL_Event_Count = chaEventCollector->getTotalCount(AfterState);
            chaEventCollector->reset();
            chaEventCollector->programFirstGroup();
            readState(AfterState); // TODO: re-read only CHA counters (performance optmization)
        }

        if (!csv) {
          //cout << "Time elapsed: " << dec << fixed << AfterTime-BeforeTime << " ms\n";
          //cout << "Called sleep function for " << dec << fixed << delay_ms << " ms\n";
        }

        if(rankA >= 0 || rankB >= 0)
          calculate_bandwidth_rank(m,BeforeState, AfterState, AfterTime - BeforeTime, csv, csvheader, no_columns, rankA, rankB);
        else
          calculate_bandwidth(m,BeforeState,AfterState,AfterTime-BeforeTime,csv,csvheader, no_columns, metrics,
                show_channel_output, print_update, SPR_CHA_CXL_Event_Count, show_cxl_output);

        swap(BeforeTime, AfterTime);
        swap(BeforeState, AfterState);

        if ( m->isBlocked() ) {
        // in case PCM was blocked after spawning child application: break monitoring loop here
            return false;
        }
        return true;
    });

    exit(EXIT_SUCCESS);
}

#endif // UNIT_TEST
```

`src/pcm-mmio.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2012-2022, Intel Corporation

// written by Roman Dementiev
#include "cpucounters.h"
#ifdef _MSC_VER
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#endif
#include <iostream>
#include <functional>
#include <stdlib.h>
#include <iomanip>
#include <string.h>
#ifdef _MSC_VER
#include "freegetopt/getopt.h"
#endif

using namespace pcm;

#define MAX_BATCH_OPERATE_BYTES 1024
#define MAX_BATCH_READ_ROW_DISPLAY_BYTES 16

void print_usage(const char* progname)
{
    std::cout << "Usage " << progname << " [-w value] [-q] [-d] [-c core] address\n\n";
    std::cout << "  Reads/writes MMIO (memory mapped) register in the specified address\n";
    std::cout << "   -w value    : write the value before reading \n";
    std::cout << "   -b low:high : read or write only low..high bits of the register\n";
    std::cout << "   -q          : read/write 64-bit quad word (default is 32-bit double word)\n";
    std::cout << "   -d          : output all numbers in dec (default is hex)\n";
    std::cout << "   -n size     : number of bytes read from specified address(batch read mode), max bytes=" << MAX_BATCH_OPERATE_BYTES << "\n";
    std::cout << "   -c core     : perform the operation from specified core\n";
    std::cout << "   --version   : print application version\n";
    std::cout << "\n";
}

template <class T, class RD, class WR>
void doOp(  const std::pair<int64,int64> & bits,
            const uint64 address, const uint64 offset,
            const uint32 batch_bytes, const bool write,
            T value,
            RD readOp,
            WR writeOp,
            const bool dec,
            const int core)
{
    auto printCoreEndl = [&]() {
        if (core >= 0)
        {
            std::cout << " on core " << core;
        }
        std::cout << "\n\n";
    };
    if (batch_bytes == 0) //single mode
    {
        if (!dec) std::cout << std::hex << std::showbase;
        constexpr auto bit = sizeof(T) * 8;
        readOldValueHelper(bits, value, write, [&readOp, & offset](T & old_value){ old_value = readOp(offset); return true; });
        if (write)
        {
            std::cout << " Writing " << value << " to " << std::dec << bit;
            if (!dec) std::cout << std::hex << std::showbase;
            std::cout <<"-bit MMIO register " << address << "\n";
            writeOp(offset, value);
        }
        value = readOp(offset);
        extractBitsPrintHelper(bits, value, dec);
        std::cout << " from " << std::dec << bit;
        if (!dec) std::cout << std::hex << std::showbase;
        std::cout << "-bit MMIO register " << address;
        printCoreEndl();
    }
    else //batch mode
    {
        uint32 i = 0, j= 0;
        std::cout << std::hex << " Dumping MMIO register range from 0x" << address <<
            ", number of bytes=0x" << batch_bytes;
        printCoreEndl();
        for(i = 0; i < batch_bytes; i+=MAX_BATCH_READ_ROW_DISPLAY_BYTES)
        {
            std::ostringstream row_disp_str(std::ostringstream::out);
            std::cout << " 0x" << (address + i) << ": ";
            for(j = 0; j < (MAX_BATCH_READ_ROW_DISPLAY_BYTES/sizeof(T)); j++)
            {
                value = readOp(offset + i + j*sizeof(T));
                row_disp_str << "0x" << std::hex << std::setw(sizeof(T)*2) << std::setfill('0') << value << " ";
            }
            std::cout << row_disp_str.str() << ";\n";
        }
        std::cout << "\n";
    }
}

PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
    if(print_version(argc, argv))
        exit(EXIT_SUCCESS);

    std::cout << "\n Intel(r) Performance Counter Monitor " << PCM_VERSION << "\n";

    std::cout << "\n MMIO register read/write utility\n\n";

    uint64 value = ~(0ULL);
    bool write = false;
    uint64 address = 0;
    bool dec = false;
    bool quad = false;
    uint32 batch_bytes = 0;
    std::pair<int64,int64> bits{-1, -1};
    int core = -1;

    int my_opt = -1;
    while ((my_opt = getopt(argc, argv, "w:dqn:b:c:")) != -1)
    {
        switch (my_opt)
        {
        case 'w':
            write = true;
            value = read_number(optarg);
            break;
        case 'd':
            dec = true;
            break;
        case 'q':
            quad = true;
            break;
        case 'b':
            bits = parseBitsParameter(optarg);
            break;
        case 'n':
            batch_bytes = read_number(optarg);
            if (batch_bytes > MAX_BATCH_OPERATE_BYTES)
            {
                batch_bytes = MAX_BATCH_OPERATE_BYTES;
            }
            break;
        case 'c':
            core = read_number(optarg);
            break;
        default:
            print_usage(argv[0]);
            return -1;
        }
    }

    if (optind >= argc)
    {
        print_usage(argv[0]);
        return -1;
    }

    address = read_number(argv[optind]);

    if (write == true)
    {
        batch_bytes = 0; //batch mode only support read.
    }

    try
    {
        constexpr uint64 rangeSize = 4096ULL;
        const uint64 baseAddr = address & (~(rangeSize - 1ULL)); // round down to 4K boundary
        const uint64 offset = address - baseAddr;

        if ((batch_bytes != 0) && (offset + batch_bytes > rangeSize))
        {
            batch_bytes = (rangeSize - offset); //limit the boundary 
        }

        MMIORange mmio(baseAddr, rangeSize, !write, false, core);

        using namespace std::placeholders;
        if (quad)
        {
            doOp(bits, address, offset, batch_bytes, write, (uint64)value,
                std::bind(&MMIORange::read64, &mmio, _1), std::bind(&MMIORange::write64, &mmio, _1, _2), dec, core);
        }
        else
        {
            doOp(bits, address, offset, batch_bytes, write, (uint32)value,
                std::bind(&MMIORange::read32, &mmio, _1), std::bind(&MMIORange::write32, &mmio, _1, _2), dec, core);
        }
    }
    catch (std::exception & e)
    {
        std::cerr << "Error accessing MMIO registers: " << e.what() << "\n";
        std::cerr << "Please check if the program can access MMIO drivers.\n";
    }
    return 0;
}

```

`src/pcm-msr.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2012-2022, Intel Corporation

// written by Roman Dementiev
#include "cpucounters.h"
#ifdef _MSC_VER
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#endif
#include <iostream>
#include <stdlib.h>
#include <iomanip>
#include <string.h>
#ifdef _MSC_VER
#include "freegetopt/getopt.h"
#endif
#include <stdio.h>
#include <list>
#ifndef _MSC_VER
#include <fcntl.h>
#endif
#include <string>

using namespace pcm;

void print_usage(const char * progname)
{
    std::cout << "Usage " << progname << " [-w value] [-c core] [-a] [-d] msr\n\n";
    std::cout << "  Reads/writes specified msr (model specific register) \n";
    std::cout << "   -w value    : write the value before reading \n";
    std::cout << "   -c corelist : perform msr read/write on specified cores (default is 0)\n";
    std::cout << "                (examples: -c 10  -c 10-11 -c 4,6,12-20,6)\n";
    std::cout << "   -x          : print core number in hex (instead of decimal)\n";
    std::cout << "   -b low:high : read or write only low..high bits of the register\n";
    std::cout << "   -d          : output all numbers in dec (default is hex)\n";
    std::cout << "   -a          : perform msr read/write operations on all cores (same as -c -1)\n";
    std::cout << "   -s <d>      : iterate with <d> seconds between each iteration\n";
    std::cout << "   -o <f>      : write results of each iteration to file <f>\n";
    std::cout << "   --version   : print application version\n";
    std::cout << "\n";
}

PCM_MAIN_NOTHROW;

bool outflag = false;
FILE *ofile;
int loop_cnt = 0;
std::list<int> corelist;

int mainThrows(int argc, char * argv[])
{
    if(print_version(argc, argv))
        return 0;

    std::cout << "\n Intel(r) Performance Counter Monitor " << PCM_VERSION << "\n";

    std::cout << "\n MSR read/write utility\n\n";

    uint64 value = 0;
    bool write = false;
    bool core_in_dec = true;
    int msr = -1;
    bool dec = false;
    std::pair<int64,int64> bits{-1, -1};
    float sleep_delay = -1;
    std::string outfile;

    int my_opt = -1;
    while ((my_opt = getopt(argc, argv, "xw:c:dab:s:o:")) != -1)
    {
        switch (my_opt)
        {
        case 'w':
            write = true;
            value = read_number(optarg);
            break;
        case 'x':
            core_in_dec = false;
            break;
        case 's':
            sleep_delay = atof(optarg);
            break;
        case 'o':
            outfile = optarg;
            break;
        case 'c':
            corelist = extract_integer_list(optarg);
            break;
        case 'd':
            dec = true;
            break;
        case 'a':
            corelist.clear();
            corelist.push_back(-1);
            break;
        case 'b':
            bits = parseBitsParameter(optarg);
            break;
        default:
            print_usage(argv[0]);
            return -1;
        }
    }
    if (corelist.size()==0) corelist.push_back(0);
    if (1==2){
        for (auto const &v : corelist){
            printf("coreid=%d\n",v);
        }
    }

    if (optind >= argc)
    {
        print_usage(argv[0]);
        return -1;
    }

    msr = (int)read_number(argv[optind]);

    #ifdef _MSC_VER
    // Increase the priority a bit to improve context switching delays on Windows
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

    // WARNING: This driver code (msr.sys) is only for testing purposes, not for production use
    Driver drv = Driver(Driver::msrLocalPath());
    // drv.stop();     // restart driver (usually not needed)
    if (!drv.start())
    {
        tcerr << "Can not load MSR driver.\n";
        tcerr << "You must have a signed  driver at " << drv.driverPath() << " and have administrator rights to run this program\n";
        return -1;
    }
    #endif
    if (outfile.length() > 0){
      outflag = true;
#ifdef _MSC_VER
      // SDL330: Check for symlink/reparse point before opening (Windows)
      DWORD attrs = GetFileAttributesA(outfile.c_str());
      if (attrs != INVALID_FILE_ATTRIBUTES && (attrs & FILE_ATTRIBUTE_REPARSE_POINT)) {
        printf("SDL330 ERROR: Symlink/reparse point detected at '%s' (skipping write)\n", outfile.c_str());
        outflag = false;
      } else {
        ofile = fopen(outfile.c_str(),"w");
      }
#else
      // SDL330: Use O_NOFOLLOW to reject symlinks
      int fd = open(outfile.c_str(), O_WRONLY | O_CREAT | O_TRUNC | O_NOFOLLOW, 0644);
      ofile = (fd >= 0) ? fdopen(fd, "w") : NULL;
      if (fd >= 0 && !ofile) close(fd);
#endif
      if (outflag && ofile==NULL){
        printf("ERROR: can not open '%s' (skipping write)\n",outfile.c_str());
        printf("      (maybe a sudo issue .. need o+rwx on directory)\n");
        outflag = false;
      }
    }
    while(1){
       for (std::list<int>::iterator it=corelist.begin(); it != corelist.end(); ++it){
            int core = *it;
 
            // lambda funtion [<caputure-varibles](<fucntion arguments>)
            auto doOne = [&dec, &write, &msr, &bits, &it, &core_in_dec](int core, uint64 value)
            {
                try {
                    MsrHandle h(core);
                    if (!dec) std::cout << std::hex << std::showbase;
                    if (!readOldValueHelper(bits, value, write, [&h, &msr](uint64 & old_value){ return h.read(msr, &old_value) == 8; }))
                    {
                        std::cout << " Read error!\n";
                        return;
                    }
                    if (write)
                    {
                        std::cout << " Writing " << value << " to MSR " << msr << " on core " << core << "\n";
                        if (h.write(msr, value) != 8)
                        {
                            std::cout << " Write error!\n";
                        }
                    }   
                    value = 0;
                    if (h.read(msr, &value) == 8)
                    {
                        uint64 value2 = value;
                        extractBitsPrintHelper(bits, value, dec);
                        char cname[100];
                        if (core_in_dec) std::snprintf(cname, sizeof(cname), "%d", core);
                        else std::snprintf(cname, sizeof(cname), "0x%x", core);
                        std::cout << " from MSR " << msr << " on core " << cname << "\n";
                        auto itx = it;
                        itx++;
                        if (itx == corelist.end()) std::cout << "\n";
                        if (outflag){
                            if (bits.first >= 0){
                                uint32 value3 = extract_bits(value2,bits.first,bits.second);
                                if (dec)fprintf(ofile,"%d,%u\n",loop_cnt,value3);
                                else fprintf(ofile,"%d,0x%x\n",loop_cnt,value3);
                            }else{
                                if (dec)fprintf(ofile,"%d,%llu\n",loop_cnt,value2);
                                else fprintf(ofile,"%d,0x%llx\n",loop_cnt,value2);
                            }
                            fflush(ofile);
                        }
                    }
                    else
                    {
                        std::cout << " Read error!\n";
                    }
                }
                catch (std::exception & e)
                {
                    std::cerr << "Error accessing MSRs: " << e.what() << "\n";
                    std::cerr << "Please check if the program can access MSR drivers.\n";
                }
            };  // end of lambda definition

            if (core >= 0)
            {
                doOne(core, value);
            }
            else
            {
                set_signal_handlers();
                auto m = PCM::getInstance();
                for (uint32 i = 0; i < m->getNumCores(); ++i)
                {
                    if (m->isCoreOnline(i))
                    {
                        doOne(i, value);
                    }
                }
            }
       }
        if (sleep_delay == -1) break;
        loop_cnt++;
        MySleepMs(sleep_delay*1000.0);
    }
    return 0;
}

```

`src/pcm-numa.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev


/*!     \file pcm-numa.cpp
  \brief Example of using CPU counters: implements a performance counter monitoring utility for NUMA (remote and local memory accesses counting). Example for programming offcore response events
*/
#include <iostream>
#ifdef _MSC_VER
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#include <signal.h>
#include <sys/time.h> // for gettimeofday()
#endif
#include <math.h>
#include <iomanip>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <string>
#include <assert.h>
#include <list>
#include "cpucounters.h"
#include "utils.h"
#ifdef _MSC_VER
#include "freegetopt/getopt.h"
#endif

#include <vector>
#define PCM_DELAY_DEFAULT 1.0       // in seconds
#define PCM_DELAY_MIN 0.015         // 15 milliseconds is practical on most modern CPUs

using namespace std;
using namespace pcm;

void print_usage(const string & progname)
{
    cout << "\n Usage: \n " << progname
         << " --help | [delay] [options] [-- external_program [external_program_options]]\n";
    cout << "   <delay>                           => time interval to sample performance counters.\n";
    cout << "                                        If not specified, or 0, with external program given\n";
    cout << "                                        will read counters only after external program finishes\n";
    cout << " Supported <options> are: \n";
    cout << "  -h    | --help  | /h               => print this help and exit\n";
    cout << "  -silent                            => silence information output and print only measurements\n";
    cout << "  -c=corelist                        => check specified cores (default all cores)\n";
    cout << "                                        (examples: -c=10  -c=10-11 -c=4,6,12-20,6)\n";
    cout << "  --version                          => print application version\n";
    cout << "  -pid PID | /pid PID                => collect core metrics only for specified process ID\n";
    cout << "  -csv[=file.csv] | /csv[=file.csv]  => output compact CSV format to screen or\n"
         << "                                        to a file, in case filename is provided\n";
    cout << "  -i[=number] | /i[=number]          => allow to determine number of iterations\n";
    cout << " Examples:\n";
    cout << "  " << progname << " 1                  => print counters every second without core and socket output\n";
    cout << "  " << progname << " 0.5 -csv=test.log  => twice a second save counter values to test.log in CSV format\n";
    cout << "  " << progname << " /csv 5 2>/dev/null => one sample every 5 seconds, and discard all diagnostic output\n";
    cout << "\n";
}

template <class StateType>
void print_stats(const StateType & BeforeState, const StateType & AfterState, bool csv)
{
    uint64 cycles = getCycles(BeforeState, AfterState);
    uint64 instr = getInstructionsRetired(BeforeState, AfterState);

    if (csv)
    {
        cout << double(instr) / double(cycles) << ",";
        cout << instr << ",";
        cout << cycles << ",";
    }
    else
    {
        cout << double(instr) / double(cycles) << "       ";
        cout << unit_format(instr) << "     ";
        cout << unit_format(cycles) << "      ";
    }

    for (int i = 0; i < 2; ++i)
        if (!csv)
            cout << unit_format(getNumberOfCustomEvents(i, BeforeState, AfterState)) << "              ";
        else
            cout << getNumberOfCustomEvents(i, BeforeState, AfterState) << ",";

    cout << "\n";
}


PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
    if(print_version(argc, argv))
        exit(EXIT_SUCCESS);

    null_stream nullStream2;
#ifdef PCM_FORCE_SILENT
    null_stream nullStream1;
    cout.rdbuf(&nullStream1);
    cerr.rdbuf(&nullStream2);
#else
    check_and_set_silent(argc, argv, nullStream2);
#endif

    set_signal_handlers();

    cerr << "\n";
    cerr << " Intel(r) Performance Counter Monitor: NUMA monitoring utility \n";
    cerr << "\n";

    double delay = -1.0;
    int pid{ -1 };
    char * sysCmd = NULL;
    char ** sysArgv = NULL;
    bool csv = false;
    MainLoop mainLoop;
    string program = string(argv[0]);

    PCM * m = PCM::getInstance();

    parsePID(argc, argv, pid);

    std::list<int> corelist;
    
    if (argc > 1) do
        {
            argv++;
            argc--;
            string arg_value;

            if (*argv == nullptr)
            {
                continue;
            }
            else if (extract_argument_value(*argv, {"-c"}, arg_value))
            {
                const char *pstr = arg_value.c_str();
                corelist = extract_integer_list(pstr);
            }
            else if (check_argument_equals(*argv, {"--help", "-h", "/h"}))
            {
                print_usage(program);
                exit(EXIT_FAILURE);
            }
            else if (check_argument_equals(*argv, {"-silent", "/silent"}))
            {
                // handled in check_and_set_silent
                continue;
            }
            else if (check_argument_equals(*argv, {"-csv", "/csv"}))
            {
                csv = true;
            }
            else if (extract_argument_value(*argv, {"-csv", "/csv"}, arg_value))
            {
                csv = true;
                if (!arg_value.empty()) {
                    m->setOutput(arg_value);
                }
            }
            else if (isPIDOption(argv))
            {
                argv++;
                argc--;
                continue;
            }
            else if (mainLoop.parseArg(*argv))
            {
                continue;
            }
            else if (check_argument_equals(*argv, {"--"}))
            {
                argv++;
                sysCmd = *argv;
                sysArgv = argv;
                break;
            }
            else
            {
                delay = parse_delay(*argv, program, (print_usage_func)print_usage);
                continue;
            }
        } while (argc > 1); // end of command line partsing loop

    EventSelectRegister def_event_select_reg;
    def_event_select_reg.value = 0;
    def_event_select_reg.fields.usr = 1;
    def_event_select_reg.fields.os = 1;
    def_event_select_reg.fields.enable = 1;

    PCM::ExtendedCustomCoreEventDescription conf;
    conf.fixedCfg = NULL; // default
    conf.nGPCounters = 2;
    
    try {
        m->setupCustomCoreEventsForNuma(conf);
    }
    catch (UnsupportedProcessorException& ) {
        cerr << "pcm-numa tool does not support your processor currently.\n";
        exit(EXIT_FAILURE);
    }

    EventSelectRegister regs[4];
    conf.gpCounterCfg = regs;
    for (int i = 0; i < 4; ++i)
        regs[i] = def_event_select_reg;

    regs[0].fields.event_select = m->getOCREventNr(0, 0).first; // OFFCORE_RESPONSE 0 event
    regs[0].fields.umask =        m->getOCREventNr(0, 0).second;
    regs[1].fields.event_select = m->getOCREventNr(1, 0).first; // OFFCORE_RESPONSE 1 event
    regs[1].fields.umask =        m->getOCREventNr(1, 0).second;

    print_pid_collection_message(pid);

    PCM::ErrorCode status = m->program(PCM::EXT_CUSTOM_CORE_EVENTS, &conf, false, pid);
    m->checkError(status);

    print_cpu_details();

    uint64 BeforeTime = 0, AfterTime = 0;
    SystemCounterState SysBeforeState, SysAfterState;
    const uint32 ncores = m->getNumCores();
    if (corelist.size()==0){
      for (int ii = 0; ii < (int)ncores; ++ii) corelist.push_back(ii);
    }
    vector<CoreCounterState> BeforeState, AfterState;
    vector<SocketCounterState> DummySocketStates;

    if ((sysCmd != NULL) && (delay <= 0.0)) {
        // in case external command is provided in command line, and
        // delay either not provided (-1) or is zero
        m->setBlocked(true);
    } else {
        m->setBlocked(false);
    }

    if (csv) {
        if (delay <= 0.0) delay = PCM_DELAY_DEFAULT;
    } else {
        // for non-CSV mode delay < 1.0 does not make a lot of practical sense:
        // hard to read from the screen, or
        // in case delay is not provided in command line => set default
        if (((delay < 1.0) && (delay > 0.0)) || (delay <= 0.0)) delay = PCM_DELAY_DEFAULT;
    }

    cerr << "Update every " << delay << " seconds\n";

    cout.precision(2);
    cout << fixed;

    BeforeTime = m->getTickCount();
    m->getAllCounterStates(SysBeforeState, DummySocketStates, BeforeState);

    if (sysCmd != NULL) {
        MySystem(sysCmd, sysArgv);
    }

    mainLoop([&]()
    {
        if (!csv) cout << flush;

        calibratedSleep(delay, sysCmd, mainLoop, m);

        AfterTime = m->getTickCount();
        m->getAllCounterStates(SysAfterState, DummySocketStates, AfterState);

        cout << "Time elapsed: " << dec << fixed << AfterTime - BeforeTime << " ms\n";
        //cout << "Called sleep function for " << dec << fixed << delay_ms << " ms\n";

        if (csv)
            cout << "Core,IPC,Instructions,Cycles,Local DRAM accesses,Remote DRAM accesses \n";
        else
            cout << "Core | IPC  | Instructions | Cycles  |  Local DRAM accesses | Remote DRAM Accesses \n";

    for (int ix : corelist)
        {
            uint32 i = ix;
            if (csv)
                cout << i << ",";
            else
                cout << " " << setw(3) << i << "   " << setw(2);

            print_stats(BeforeState[i], AfterState[i], csv);
        }


        if (csv)
            cout << "*,";
        else
        {
            cout << "-------------------------------------------------------------------------------------------------------------------\n";
            cout << "   *   ";
        }

        print_stats(SysBeforeState, SysAfterState, csv);

        cout << "\n";

        swap(BeforeTime, AfterTime);
        swap(BeforeState, AfterState);
        swap(SysBeforeState, SysAfterState);

        if (m->isBlocked()) {
            // in case PCM was blocked after spawning child application: break monitoring loop here
            return false;
        }
        return true;
    });

    exit(EXIT_SUCCESS);
}

```

`src/pcm-pcicfg.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2012, 2018-2022 Intel Corporation

// written by Roman Dementiev
#include "cpucounters.h"
#include "lspci.h"
#ifdef _MSC_VER
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#endif
#include <iostream>
#include <stdlib.h>
#include <iomanip>
#include <string.h>
#ifdef _MSC_VER
#include "freegetopt/getopt.h"
#endif

using namespace pcm;

void print_usage(const char * progname)
{
    std::cout << "Usage " << progname << " [-w value] [-d] [-n] [-i ID] [group bus device function] offset\n";
    std::cout << "       " << progname << " -l [-v] [-d]\n\n";
    std::cout << "  Reads/writes 32-bit PCICFG register \n";
    std::cout << "   -w value    : write the value before reading \n";
    std::cout << "   -b low:high : read or write only low..high bits of the register\n";
    std::cout << "   -d          : output all numbers in dec (default is hex)\n";
    std::cout << "   -n          : print NUMA node of the device\n";
    std::cout << "   -i ID       : specify Intel device ID instead of group bus device function\n";
    std::cout << "   -l          : list all PCI devices (similar to lspci)\n";
    std::cout << "   -v          : increase verbosity (can be used multiple times with -l)\n";
    std::cout << "   --version   : print application version\n";
    std::cout << "\n";
}

PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
    if(print_version(argc, argv))
        return 0;

    std::cout << "\n Intel(r) Performance Counter Monitor " << PCM_VERSION << "\n";

    std::cout << "\n PCICFG read/write utility\n\n";

    #ifdef __linux__
    #ifndef PCM_USE_PCI_MM_LINUX
    std::cout << "\n To access *extended* configuration space recompile with -DPCM_USE_PCI_MM_LINUX option.\n";
    #endif
    #endif

    uint32 value = 0;
    bool write = false;
    bool dec = false;
    bool print_numa = false;
    bool list_devices = false;
    int verbosity = 0;
    uint32 deviceID = 0;
    std::pair<int64,int64> bits{-1, -1};

    int my_opt = -1;
    while ((my_opt = getopt(argc, argv, "i:w:db:nlv")) != -1)
    {
        switch (my_opt)
        {
        case 'i':
            deviceID = (uint32)read_number(optarg);
            break;
        case 'w':
            write = true;
            value = (pcm::uint32)read_number(optarg);
            break;
        case 'b':
            bits = parseBitsParameter(optarg);
            break;
        case 'd':
            dec = true;
            break;
        case 'n':
            print_numa = true;
            break;
        case 'l':
            list_devices = true;
            break;
        case 'v':
            verbosity++;
            break;
        default:
            print_usage(argv[0]);
            return -1;
        }
    }

    if (optind + ((deviceID)?0:4) >= argc)
    {
        // Allow -l option without additional arguments
        if (!list_devices)
        {
            print_usage(argv[0]);
            return -1;
        }
    }

    int group = -1;
    int bus = -1;
    int device = -1;
    int function = -1;
    int offset = -1;

    #ifdef _MSC_VER
    // Increase the priority a bit to improve context switching delays on Windows
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

    // WARNING: This driver code (msr.sys) is only for testing purposes, not for production use
    Driver drv = Driver(Driver::msrLocalPath());
    // drv.stop();     // restart driver (usually not needed)
    if (!drv.start())
    {
        tcerr << "Can not load MSR driver.\n";
        tcerr << "You must have a signed  driver at " << drv.driverPath() << " and have administrator rights to run this program\n";
        return -1;
    }
    #endif

    // Handle list devices mode
    if (list_devices)
    {
        // Load PCI database for device name lookups if verbosity is 1 or higher
        PCIDB pciDB;
        if (verbosity >= 1)
        {
            load_PCIDB(pciDB);
        }

        // List all PCI devices
        forAllDevices([&dec, &verbosity, &pciDB](const uint32 group, const uint32 bus, const uint32 device, const uint32 function, const uint32 device_id)
        {
            if (PciHandleType::exists(group, bus, device, function) == false)
            {
                return;
            }
            uint32 vendor_id = 0;
            uint32 dev_id = 0;
            int32 numa_node = -1;

            try
            {
                PciHandleType h(group, bus, device, function);
                uint32 value = 0;
                h.read32(0, &value);
                vendor_id = value & 0xffff;
                dev_id = (value >> 16) & 0xffff;
                numa_node = h.getNUMANode();
            }
            catch (...)
            {
                DBG(2, "Error accessing PCI device ", std::hex, group, ":", bus, ":", device, ".", function);
                return;
            }
            // Basic format: segment:bus:device.function
            if (dec)
            {
                std::cout << std::dec << std::setfill('0') << std::setw(4) << group << ":" 
                         << std::setfill('0') << std::setw(2) << bus << ":"
                         << std::setfill('0') << std::setw(2) << device << "."
                         << function;
            }
            else
            {
                std::cout << std::hex << std::setfill('0') << std::setw(4) << group << ":"
                         << std::setfill('0') << std::setw(2) << bus << ":"
                         << std::setfill('0') << std::setw(2) << device << "."
                         << function;
            }
            
            if (dec)
            {
                std::cout << " " << std::dec << vendor_id << ":" << dev_id;
            }
            else
            {
                std::cout << " " << std::hex << std::setfill('0') << std::setw(4) << vendor_id
                    << ":" << std::setfill('0') << std::setw(4) << dev_id;
            }

            // Add device names with verbosity level 1 or higher
            if (verbosity >= 1 && !pciDB.first.empty())
            {
                auto vendor_it = pciDB.first.find(vendor_id);
                if (vendor_it != pciDB.first.end())
                {
                    std::cout << " " << vendor_it->second;

                    auto device_map_it = pciDB.second.find(vendor_id);
                    if (device_map_it != pciDB.second.end())
                    {
                        auto device_it = device_map_it->second.find(dev_id);
                        if (device_it != device_map_it->second.end())
                        {
                            std::cout << " - " << device_it->second;
                        }
                    }
                }
            }
            
            // Add NUMA node information
            if (verbosity >= 2)
            {
                std::cout << " (NUMA node: ";
                if (numa_node >= 0)
                {
                    std::cout << std::dec << numa_node;
                }
                else
                {
                    std::cout << "n/a";
                }
                std::cout << ")";
            }
            
            std::cout << "\n";
        });
        
        return 0;
    }

    auto one = [&dec,&write,&bits,&print_numa](const uint32 & group, const uint32 & bus, const uint32 & device, const uint32 & function, const uint32 & offset, uint32 value)
    {

        try {
            PciHandleType h(group, bus, device, function);
            if (!dec) std::cout << std::hex << std::showbase;
            
            // Print NUMA node if requested
            if (print_numa)
            {
                int32 numa_node = h.getNUMANode();
                std::cout << " NUMA node: ";
                if (numa_node >= 0)
                {
                    std::cout << std::dec << numa_node;
                }
                else
                {
                    std::cout << "not available";
                }
                std::cout << " for " << group << ":" << bus << ":" << device << ":" << function << "\n";
                if (!dec) std::cout << std::hex << std::showbase;
            }
            
            readOldValueHelper(bits, value, write, [&h, &offset](uint32 & old_value){ h.read32(offset, &old_value); return true; });
            if (write)
            {
                std::cout << " Writing " << value << " to " << group << ":" << bus << ":" << device << ":" << function << "@" << offset << "\n";
                h.write32(offset, value);
            }
            value = 0;
            h.read32(offset, &value);
            extractBitsPrintHelper(bits, value, dec);
            std::cout << " from " << group << ":" << bus << ":" << device << ":" << function << "@" << offset << "\n\n";
        }
        catch (std::exception& e)
        {
            std::cerr << "Error accessing registers: " << e.what() << "\n";
            std::cerr << "Please check if the program can access MSR/PCICFG drivers.\n";
        }
    };

    if (deviceID)
    {
        offset = (int)read_number(argv[optind]);
        forAllIntelDevices([&deviceID,&one,&offset, &value](const uint32 group, const uint32 bus, const uint32 device, const uint32 function, const uint32 device_id)
            {
                if (deviceID == device_id)
                {
                    one(group, bus, device, function, offset, value);
                }
            });
    }
    else
    {
        group = (int)read_number(argv[optind]);
        bus = (int)read_number(argv[optind + 1]);
        device = (int)read_number(argv[optind + 2]);
        function = (int)read_number(argv[optind + 3]);
        offset = (int)read_number(argv[optind + 4]);
        one(group, bus, device, function, offset, value);
    }

    return 0;
}

```

`src/pcm-pcie.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// originally written by Patrick Lu
// redesigned by Roman Sudarikov


/*!     \file pcm-pcie.cpp
  \brief Example of using uncore CBo counters: implements a performance counter monitoring utility for monitoring PCIe bandwidth
  */
#ifdef _MSC_VER
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#include <signal.h>
#endif
#include <math.h>
#include <iomanip>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <string>
#include <assert.h>
#include "pcm-pcie.h"

#define PCM_DELAY_DEFAULT 1.0 // in seconds
#define PCM_DELAY_MIN 0.015 // 15 milliseconds is practical on most modern CPUs

using namespace std;

bool events_printed = false;

void print_events()
{
    if(events_printed)
    {
        return;
    }

    cout << " PCIe event definitions (each event counts as a transfer): \n";
    cout << "   PCIe read events (PCI devices reading from memory - application writes to disk/network/PCIe device):\n";
    cout << "     PCIePRd   - PCIe UC read transfer (partial cache line)\n";
    cout << "     PCIeRdCur* - PCIe read current transfer (full cache line)\n";
    cout << "         On Haswell Server PCIeRdCur counts both full/partial cache lines\n";
    cout << "     RFO*      - Demand Data RFO\n";
    cout << "     CRd*      - Demand Code Read\n";
    cout << "     DRd       - Demand Data Read\n";
    cout << "     PCIeNSRd  - PCIe Non-snoop read transfer\n";
    cout << "   PCIe write events (PCI devices writing to memory - application reads from disk/network/PCIe device):\n";
    cout << "     PCIeWiLF  - PCIe MMIO Write transfer (non-allocating) (full cache line)\n";
    cout << "     PCIeItoM  - PCIe Write transfer (allocating) (full cache line)\n";
    cout << "     PCIeNSWr  - PCIe Non-snoop write transfer (partial cache line)\n";
    cout << "     PCIeNSWrF - PCIe Non-snoop write transfer (full cache line)\n";
    cout << "     ItoM      - PCIe write full cache line\n";
    cout << "     RFO       - PCIe partial Write\n";
    cout << "   CPU MMIO events (CPU reading/writing to PCIe devices):\n";
    cout << "     UCRdF     - read from uncacheable memory, including MMIO\n";
    cout << "     WCiL      - streaming store (partial cache line), includes MOVDIRI\n\n";
    cout << "     WCiLF     - streaming store (full cache line), includes MOVDIR64\n\n";
    cout << "     PRd       - MMIO Read [Haswell Server only] (Partial Cache Line)\n";
    cout << "     WiL       - MMIO Write (Full/Partial)\n\n";
    cout << " * - NOTE: Depending on the configuration of your BIOS, this tool may report '0' if the message\n";
    cout << "           has not been selected.\n\n";

    events_printed = true;
}

void print_usage(const string & progname)
{
    cout << "\n Usage: \n " << progname
         << " --help | [delay] [options] [-- external_program [external_program_options]]\n";
    cout << "   <delay>                           => time interval to sample performance counters.\n";
    cout << "                                        If not specified, or 0, with external program given\n";
    cout << "                                        will read counters only after external program finishes\n";
    cout << " Supported <options> are: \n";
    cout << "  -h    | --help  | /h               => print this help and exit\n";
    cout << "  -silent                            => silence information output and print only measurements\n";
    cout << "  --version                          => print application version\n";
    cout << "  -csv[=file.csv] | /csv[=file.csv]  => output compact CSV format to screen or\n"
         << "                                        to a file, in case filename is provided\n";
    cout << "  -B                                 => Estimate PCIe B/W (in Bytes/sec) by multiplying\n";
    cout << "                                        the number of transfers by the cache line size (=64 bytes).\n";
    cout << "  -e                                 => print additional PCIe LLC miss/hit statistics.\n";
    cout << "  -i[=number] | /i[=number]          => allow to determine number of iterations\n";
    cout << " It overestimates the bandwidth under traffic with many partial cache line transfers.\n";
    cout << "\n";
    print_events();
    cout << "\n";
    cout << " Examples:\n";
    cout << "  " << progname << " 1                  => print counters every second without core and socket output\n";
    cout << "  " << progname << " 0.5 -csv=test.log  => twice a second save counter values to test.log in CSV format\n";
    cout << "  " << progname << " /csv 5 2>/dev/null => one sample every 5 seconds, and discard all diagnostic output\n";
    cout << "\n";
}

IPlatform *IPlatform::getPlatform(PCM *m, bool csv, bool print_bandwidth, bool print_additional_info, uint32 delay)
{
    switch (m->getCPUFamilyModel()) {
        case PCM::GNR:
        case PCM::GNR_D:
        case PCM::SRF:
            return new BirchStreamPlatform(m, csv, print_bandwidth, print_additional_info, delay);
        case PCM::GRR:
            return new LoganvillePlatform(m, csv, print_bandwidth, print_additional_info, delay);
        case PCM::SPR:
        case PCM::EMR:
            return new EagleStreamPlatform(m, csv, print_bandwidth, print_additional_info, delay);
        case PCM::ICX:
        case PCM::SNOWRIDGE:
            return new WhitleyPlatform(m, csv, print_bandwidth, print_additional_info, delay);
        case PCM::SKX:
            return new PurleyPlatform(m, csv, print_bandwidth, print_additional_info, delay);
        case PCM::BDX_DE:
        case PCM::BDX:
        case PCM::KNL:
        case PCM::HASWELLX:
            return new GrantleyPlatform(m, csv, print_bandwidth, print_additional_info, delay);
        case PCM::IVYTOWN:
        case PCM::JAKETOWN:
            return new BromolowPlatform(m, csv, print_bandwidth, print_additional_info, delay);
        default:
          return NULL;
    }
}

PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
    if(print_version(argc, argv))
        exit(EXIT_SUCCESS);

    null_stream nullStream2;
#ifdef PCM_FORCE_SILENT
    null_stream nullStream1;
    cout.rdbuf(&nullStream1);
    cerr.rdbuf(&nullStream2);
#else
    check_and_set_silent(argc, argv, nullStream2);
#endif

    set_signal_handlers();

    cerr << "\n";
    cerr << " Intel(r) Performance Counter Monitor: PCIe Bandwidth Monitoring Utility \n";
    cerr << " This utility measures PCIe bandwidth in real-time\n";
    cerr << "\n";
    print_events();

    double delay = -1.0;
    bool csv = false;
    bool print_bandwidth = false;
    bool print_additional_info = false;
    char * sysCmd = NULL;
    char ** sysArgv = NULL;
    MainLoop mainLoop;

    string program = string(argv[0]);

    PCM * m = PCM::getInstance();

    if (argc > 1) do
    {
        argv++;
        argc--;
        string arg_value;

        if (check_argument_equals(*argv, {"--help", "-h", "/h"}))
        {
            print_usage(program);
            exit(EXIT_FAILURE);
        }
        else if (check_argument_equals(*argv, {"-silent", "/silent"}))
        {
            // handled in check_and_set_silent
            continue;
        }
        else if (check_argument_equals(*argv, {"-csv", "/csv"}))
        {
            csv = true;
        }
        else if (extract_argument_value(*argv, {"-csv", "/csv"}, arg_value))
        {
            csv = true;
            if (!arg_value.empty()) {
                m->setOutput(arg_value);
            }
            continue;
        }
        else if (mainLoop.parseArg(*argv))
        {
            continue;
        }
        else if (check_argument_equals(*argv, {"-B", "/b"}))
        {
            print_bandwidth = true;
            continue;
        }
        else if (check_argument_equals(*argv, {"-e"}))
        {
            print_additional_info = true;
            continue;
        }
        else if (check_argument_equals(*argv, {"--"}))
        {
            argv++;
            sysCmd = *argv;
            sysArgv = argv;
            break;
        }
        else
        {
            delay = parse_delay(*argv, program, (print_usage_func)print_usage);
            continue;
        }
    } while(argc > 1); // end of command line partsing loop

    if ( (sysCmd != NULL) && (delay<=0.0) ) {
        // in case external command is provided in command line, and
        // delay either not provided (-1) or is zero
        m->setBlocked(true);
    } else {
        m->setBlocked(false);
    }

    if (csv) {
        if ( delay<=0.0 ) delay = PCM_DELAY_DEFAULT;
    } else {
        // for non-CSV mode delay < 1.0 does not make a lot of practical sense:
        // hard to read from the screen, or
        // in case delay is not provided in command line => set default
        if ( ((delay < 1.0) && (delay > 0.0)) || (delay <= 0.0) ) {
            cerr << "For non-CSV mode delay < 1.0s does not make a lot of practical sense. Default delay 1s is used. Consider to use CSV mode for lower delay values\n";
            delay = PCM_DELAY_DEFAULT;
        }
    }

    cerr << "Update every " << delay << " seconds\n";

    // Delay in milliseconds
    unique_ptr<IPlatform> platform(IPlatform::getPlatform(m, csv, print_bandwidth,
                                    print_additional_info, (uint)(delay * 1000)));

    if (!platform)
    {
        print_cpu_details();
        cerr << "Jaketown, Ivytown, Haswell, Broadwell-DE, Skylake, Icelake, Snowridge and Sapphirerapids Server CPU is required for this tool! Program aborted\n";
        exit(EXIT_FAILURE);
    }

    if ( sysCmd != NULL ) {
        MySystem(sysCmd, sysArgv);
    }

    // ================================== Begin Printing Output ==================================
    mainLoop([&]()
    {
        if (!csv) cout << flush;

        for(uint i=0; i < NUM_SAMPLES; i++)
            platform->getEvents();

        platform->printHeader();

        platform->printEvents();

        platform->printAggregatedEvents();

        platform->cleanup();

        if (m->isBlocked())
            return false;

        return true;
    });
    // ================================== End Printing Output ==================================

    exit(EXIT_SUCCESS);
}

```

`src/pcm-pcie.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2020-2022, Intel Corporation
#pragma once
//written by Roman Sudarikov

#include <iostream>
#include "cpucounters.h"
#include "utils.h"
#include <vector>
#include <array>
#include <string>
#include <initializer_list>
#include <algorithm>

#if defined(_MSC_VER)
typedef unsigned int uint;
#endif

using namespace std;
using namespace pcm;
#define NUM_SAMPLES (1)

static void print(const vector<string> &listNames, bool csv)
{
    for(auto& name : listNames)
        if (csv)
            cout << "," << name;
        else
            cout << "|  " << name << "  ";
}

static uint getIdent (const string &s)
{
    /*
     * We are adding "|  " before and "  " after the event name hence +5 to
     * strlen(eventNames). Rest of the logic is to center the event name.
     */
    uint ident = 5 + (uint)s.size();
    return (3 + ident / 2);
}

class IPlatform
{
    void init();

public:
    IPlatform(PCM *m, bool csv, bool bandwidth, bool verbose);
    virtual void getEvents() = 0;
    virtual void printHeader() = 0;
    virtual void printEvents() = 0;
    virtual void printAggregatedEvents() = 0;
    virtual void cleanup() = 0;
    static IPlatform *getPlatform(PCM* m, bool csv, bool bandwidth,
                                        bool verbose, uint32 delay);
    virtual ~IPlatform() { }

protected:
    PCM *m_pcm;
    bool m_csv;
    bool m_bandwidth;
    bool m_verbose;
    uint m_socketCount;

    enum eventFilter {TOTAL, MISS, HIT, fltLast};

    vector<string> filterNames, bwNames;
};

void IPlatform::init()
{
    print_cpu_details();

    if (m_pcm->getMaxNumOfUncorePMUs(PCM::CBO_PMU_ID) == 0) // CHAs (CBoxes) PMUs are not available
    {
        cerr << "Your processor/system does not support CHA PCIe performance counters. Program aborted\n";
        exit(EXIT_FAILURE);
    }

    if (m_pcm->isMaxNumOfCBoxesBasedOnCoreCount() &&  m_pcm->isSomeCoreOfflined())
    {
        /*
            The bandwwidth metrics can be calculated correctly only if we aggregate
            the event counts from all CHAs (CBoxes) in the socket. For this need to
            know the number of CBoxes in the socket. For some processors we do not
            have access to a register containing the CHA count but on those processors
            the number of CBoxes is equal to the number of cores. On such systems if
            the cores are offlined then the number of CBoxes can't be determined.
            pcm-pcie does not support such systems because the bandwidth can't be
            computed correctly.
        */
        cerr << "Core offlining is not supported on your processor. Program aborted\n";
        exit(EXIT_FAILURE);
    }
}

IPlatform::IPlatform(PCM *m, bool csv, bool bandwidth, bool verbose) :
        m_pcm(m),
        filterNames {"(Total)", "(Miss)", "(Hit)"},
        bwNames {"PCIe Rd (B)", "PCIe Wr (B)"}
{
    m_csv = csv;
    m_bandwidth = bandwidth;
    m_verbose = verbose;
    m_socketCount = m_pcm->getNumSockets();

    init();
}

/*
 * Common API to program, access and represent required Uncore counters.
 * The only difference is event opcodes and the way how bandwidth is calculated.
 */
class LegacyPlatform: public IPlatform
{
    enum {
        before,
        after,
        total
    };
    vector<string> eventNames;
    vector<eventGroup_t> eventGroups;
    uint32 m_delay;
    typedef vector <vector <uint64>> eventCount_t;
    array<eventCount_t, total> eventCount;

    virtual void getEvents() final;
    virtual void printHeader() final;
    virtual void printEvents() final;
    virtual void printAggregatedEvents() final;
    virtual void cleanup() final;

    void printBandwidth(uint socket, eventFilter filter);
    void printBandwidth();
    void printSocketScopeEvent(uint socket, eventFilter filter, uint idx);
    void printSocketScopeEvents(uint socket, eventFilter filter);
    uint64 getEventCount (uint socket, uint idx);
    uint eventGroupOffset(eventGroup_t &eventGroup);
    void getEventGroup(eventGroup_t &eventGroup);
    void printAggregatedEvent(uint idx);

public:
    LegacyPlatform(initializer_list<string> events, initializer_list <eventGroup_t> eventCodes,
        PCM *m, bool csv, bool bandwidth, bool verbose, uint32 delay) :
        IPlatform(m, csv, bandwidth, verbose),
            eventNames(events), eventGroups(eventCodes)
    {
        int eventsCount = 0;
        for (auto &group : eventGroups) eventsCount += (int)group.size();

        // Delay for each multiplexing group. Counters will be scaled.
        m_delay = uint32(delay / eventGroups.size() / NUM_SAMPLES);

        eventSample.resize(m_socketCount);
        for (auto &e: eventSample)
            e.resize(eventsCount);

        for (auto &run : eventCount) {
            run.resize(m_socketCount);
            for (auto &events_ : run)
                events_.resize(eventsCount);
        }
    };

protected:
    vector<vector<uint64>> eventSample;
    virtual uint64 getReadBw(uint socket, eventFilter filter) = 0;
    virtual uint64 getWriteBw(uint socket, eventFilter filter) = 0;
    virtual uint64 getReadBw() = 0;
    virtual uint64 getWriteBw() = 0;
    virtual uint64 event(uint socket, eventFilter filter, uint idx) = 0;
};

void LegacyPlatform::cleanup()
{
    for(auto& socket : eventSample)
        fill(socket.begin(), socket.end(), 0);
}

inline uint64 LegacyPlatform::getEventCount (uint skt, uint idx)
{
    return eventGroups.size() * (eventCount[after][skt][idx] -
                                        eventCount[before][skt][idx]);
}

uint LegacyPlatform::eventGroupOffset(eventGroup_t &eventGroup)
{
    uint offset = 0;
    uint grpIdx = (uint)(&eventGroup - eventGroups.data());

    for (auto iter = eventGroups.begin(); iter < eventGroups.begin() + grpIdx; iter++)
         offset += (uint)iter->size();

    return offset;
}

void LegacyPlatform::getEventGroup(eventGroup_t &eventGroup)
{
    m_pcm->programPCIeEventGroup(eventGroup);
    uint offset = eventGroupOffset(eventGroup);

    for (int run = before; run < total; run++) {
        for (uint skt = 0; skt < m_socketCount; ++skt)
            for (uint ctr = 0; ctr < eventGroup.size(); ++ctr)
                eventCount[run][skt][ctr + offset] = m_pcm->getPCIeCounterData(skt, ctr);
        if (run == before)
            MySleepMs(m_delay);
    }

    for(uint skt = 0; skt < m_socketCount; ++skt)
        for (uint idx = offset; idx < offset + eventGroup.size(); ++idx)
            eventSample[skt][idx] += getEventCount(skt, idx);
}

void LegacyPlatform::getEvents()
{
    for (auto& evGroup : eventGroups)
        getEventGroup(evGroup);
}

void LegacyPlatform::printHeader()
{
    cout << "Skt";
    if (!m_csv)
        cout << ' ';

    print(eventNames, m_csv);
    if (m_bandwidth)
        print(bwNames, m_csv);

    cout << "\n";
}

void LegacyPlatform::printBandwidth(uint skt, eventFilter filter)
{
    typedef uint64 (LegacyPlatform::*bwFunc_t)(uint, eventFilter);
    vector<bwFunc_t> bwFunc = {
        &LegacyPlatform::getReadBw,
        &LegacyPlatform::getWriteBw,
    };

    if (!m_csv)
        for(auto& bw_f : bwFunc) {
            int ident = getIdent(bwNames[&bw_f - bwFunc.data()]);
            cout << setw(ident)
                 << unit_format((this->*bw_f)(skt,filter))
                 << setw(5 + bwNames[&bw_f - bwFunc.data()].size() - ident)
                 << ' ';
        }
    else
        for(auto& bw_f : bwFunc)
            cout << ',' << (this->*bw_f)(skt,filter);
}

void LegacyPlatform::printSocketScopeEvent(uint skt, eventFilter filter, uint idx)
{
    uint64 value = event(skt, filter, idx);

    if (m_csv)
        cout << ',' << value;
    else
    {
        int ident = getIdent(eventNames[idx]);
        cout << setw(ident)
             << unit_format(value)
             << setw(5 + eventNames[idx].size() - ident)
             << ' ';
    }
}

void LegacyPlatform::printSocketScopeEvents(uint skt, eventFilter filter)
{
    if (!m_csv) {
        int ident = (int)strlen("Skt |") / 2;
        cout << setw(ident) << skt << setw(ident) << ' ';
    } else
        cout << skt;

    for(uint idx = 0; idx < eventNames.size(); ++idx)
        printSocketScopeEvent(skt, filter, idx);

    if (m_bandwidth)
        printBandwidth(skt, filter);

    if(m_verbose)
        cout << filterNames[filter];

    cout << "\n";
}

void LegacyPlatform::printEvents()
{
    for(uint skt =0; skt < m_socketCount; ++skt)
        if (!m_verbose)
            printSocketScopeEvents(skt, TOTAL);
        else
            for (uint flt = TOTAL; flt < fltLast; ++flt)
                printSocketScopeEvents(skt, static_cast<eventFilter>(flt));
}

void LegacyPlatform::printAggregatedEvent(uint idx)
{
    uint64 value = 0;
    for(uint skt =0; skt < m_socketCount; ++skt)
        value += event(skt, TOTAL, idx);

    int ident = getIdent(eventNames[idx]);
    cout << setw(ident)
         << unit_format(value)
         << setw(5 + eventNames[idx].size() - ident) << ' ';
}

void LegacyPlatform::printBandwidth()
{
    typedef uint64 (LegacyPlatform::*bwFunc_t)();
    vector<bwFunc_t> bwFunc = {
        &LegacyPlatform::getReadBw,
        &LegacyPlatform::getWriteBw,
    };

    for(auto& bw_f : bwFunc) {
        int ident = getIdent(bwNames[&bw_f - bwFunc.data()]);
        cout << setw(ident)
             << unit_format((this->*bw_f)())
             << setw(5 + bwNames[&bw_f - bwFunc.data()].size() - ident)
             << ' ';
    }
}

void LegacyPlatform::printAggregatedEvents()
{
    if (!m_csv)
    {
        uint len = (uint)strlen("Skt ");

        for(auto& evt : eventNames)
            len += (5 + (uint)evt.size());

        if (m_bandwidth)
            for(auto& bw : bwNames)
                len += (5 + (uint)bw.size());

        while (len--)
            cout << '-';
        cout << "\n";

        int ident = (int)strlen("Skt |") /2 ;
        cout << setw(ident) << "*" << setw(ident) << ' ';

        for (uint idx = 0; idx < eventNames.size(); ++idx)
            printAggregatedEvent(idx);

        if (m_bandwidth)
            printBandwidth();

        if (m_verbose)
            cout << "(Aggregate)\n\n";
        else
            cout << "\n\n";
    }
}

// BHS

class BirchStreamPlatform: public LegacyPlatform
{
public:
    BirchStreamPlatform(PCM *m, bool csv, bool bandwidth, bool verbose, uint32 delay) :
        LegacyPlatform( {"PCIRdCur", "ItoM", "ItoMCacheNear", "UCRdF", "WiL", "WCiL", "WCiLF"},
                        {
                            {0xC8F3FE00000435, 0xC8F3FD00000435, 0xCC43FE00000435, 0xCC43FD00000435},
                            {0xCD43FE00000435, 0xCD43FD00000435, 0xC877DE00000135, 0xC87FDE00000135},
                            {0xC86FFE00000135, 0xC867FE00000135,},
                        },
                        m, csv, bandwidth, verbose, delay)
    {
    };

private:
    enum eventIdx {
        PCIRdCur,
        ItoM,
        ItoMCacheNear,
        UCRdF,
        WiL,
        WCiL,
        WCiLF
    };

    enum Events {
            PCIRdCur_miss,
            PCIRdCur_hit,
            ItoM_miss,
            ItoM_hit,
            ItoMCacheNear_miss,
            ItoMCacheNear_hit,
            UCRdF_miss,
            WiL_miss,
            WCiL_miss,
            WCiLF_miss,
            eventLast
    };

    virtual uint64 getReadBw(uint socket, eventFilter filter);
    virtual uint64 getWriteBw(uint socket, eventFilter filter);
    virtual uint64 getReadBw();
    virtual uint64 getWriteBw();
    virtual uint64 event(uint socket, eventFilter filter, uint idx);
};

uint64 BirchStreamPlatform::event(uint socket, eventFilter filter, uint idx)
{
    uint64 event = 0;
    switch (idx)
    {
        case PCIRdCur:
            if (filter == TOTAL)
                event = eventSample[socket][PCIRdCur_miss] +
                        eventSample[socket][PCIRdCur_hit];
                else if (filter == MISS)
                    event = eventSample[socket][PCIRdCur_miss];
                else if (filter == HIT)
                    event = eventSample[socket][PCIRdCur_hit];
            break;
        case ItoM:
            if (filter == TOTAL)
                event = eventSample[socket][ItoM_miss] +
                        eventSample[socket][ItoM_hit];
                else if (filter == MISS)
                    event = eventSample[socket][ItoM_miss];
                else if (filter == HIT)
                    event = eventSample[socket][ItoM_hit];
            break;
        case ItoMCacheNear:
            if (filter == TOTAL)
                event = eventSample[socket][ItoMCacheNear_miss] +
                        eventSample[socket][ItoMCacheNear_hit];
                else if (filter == MISS)
                    event = eventSample[socket][ItoMCacheNear_miss];
                else if (filter == HIT)
                    event = eventSample[socket][ItoMCacheNear_hit];
            break;
        case UCRdF:
                if (filter == TOTAL || filter == MISS)
                    event = eventSample[socket][UCRdF_miss];
            break;
        case WiL:
                if (filter == TOTAL || filter == MISS)
                    event = eventSample[socket][WiL_miss];
            break;
        case WCiL:
                if (filter == TOTAL || filter == MISS)
                    event = eventSample[socket][WCiL_miss];
            break;
        case WCiLF:
                if (filter == TOTAL || filter == MISS)
                    event = eventSample[socket][WCiLF_miss];
            break;
        default:
            break;
    }
    return event;
}

uint64 BirchStreamPlatform::getReadBw(uint socket, eventFilter filter)
{
    uint64 readBw = event(socket, filter, PCIRdCur);
    return (readBw * 64ULL);
}

uint64 BirchStreamPlatform::getWriteBw(uint socket, eventFilter filter)
{
    uint64 writeBw = event(socket, filter, ItoM) +
                     event(socket, filter, ItoMCacheNear);
    return (writeBw * 64ULL);
}
uint64 BirchStreamPlatform::getReadBw()
{
    uint64 readBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        readBw += (event(socket, TOTAL, PCIRdCur));
    return (readBw * 64ULL);
}

uint64 BirchStreamPlatform::getWriteBw()
{
    uint64 writeBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        writeBw += (event(socket, TOTAL, ItoM) +
                    event(socket, TOTAL, ItoMCacheNear));
    return (writeBw * 64ULL);
}

// GRR

class LoganvillePlatform: public LegacyPlatform
{
public:
    LoganvillePlatform(PCM *m, bool csv, bool bandwidth, bool verbose, uint32 delay) :
        LegacyPlatform( {"PCIRdCur", "ItoM", "ItoMCacheNear", "UCRdF", "WiL", "WCiL", "WCiLF"},
                        {
                            {0xC8F3FE00000435, 0xC8F3FD00000435, 0xCC43FE00000435, 0xCC43FD00000435},
                            {0xCD43FE00000435, 0xCD43FD00000435, 0xC877DE00000135, 0xC87FDE00000135},
                            {0xC86FFE00000135, 0xC867FE00000135,},
                        },
                        m, csv, bandwidth, verbose, delay)
    {
    };

private:
    enum eventIdx {
        PCIRdCur,
        ItoM,
        ItoMCacheNear,
        UCRdF,
        WiL,
        WCiL,
        WCiLF
    };

    enum Events {
            PCIRdCur_miss,
            PCIRdCur_hit,
            ItoM_miss,
            ItoM_hit,
            ItoMCacheNear_miss,
            ItoMCacheNear_hit,
            UCRdF_miss,
            WiL_miss,
            WCiL_miss,
            WCiLF_miss,
            eventLast
    };

    virtual uint64 getReadBw(uint socket, eventFilter filter);
    virtual uint64 getWriteBw(uint socket, eventFilter filter);
    virtual uint64 getReadBw();
    virtual uint64 getWriteBw();
    virtual uint64 event(uint socket, eventFilter filter, uint idx);
};

uint64 LoganvillePlatform::event(uint socket, eventFilter filter, uint idx)
{
    uint64 event = 0;
    switch (idx)
    {
        case PCIRdCur:
            if (filter == TOTAL)
                event = eventSample[socket][PCIRdCur_miss] +
                        eventSample[socket][PCIRdCur_hit];
                else if (filter == MISS)
                    event = eventSample[socket][PCIRdCur_miss];
                else if (filter == HIT)
                    event = eventSample[socket][PCIRdCur_hit];
            break;
        case ItoM:
            if (filter == TOTAL)
                event = eventSample[socket][ItoM_miss] +
                        eventSample[socket][ItoM_hit];
                else if (filter == MISS)
                    event = eventSample[socket][ItoM_miss];
                else if (filter == HIT)
                    event = eventSample[socket][ItoM_hit];
            break;
        case ItoMCacheNear:
            if (filter == TOTAL)
                event = eventSample[socket][ItoMCacheNear_miss] +
                        eventSample[socket][ItoMCacheNear_hit];
                else if (filter == MISS)
                    event = eventSample[socket][ItoMCacheNear_miss];
                else if (filter == HIT)
                    event = eventSample[socket][ItoMCacheNear_hit];
            break;
        case UCRdF:
                if (filter == TOTAL || filter == MISS)
                    event = eventSample[socket][UCRdF_miss];
            break;
        case WiL:
                if (filter == TOTAL || filter == MISS)
                    event = eventSample[socket][WiL_miss];
            break;
        case WCiL:
                if (filter == TOTAL || filter == MISS)
                    event = eventSample[socket][WCiL_miss];
            break;
        case WCiLF:
                if (filter == TOTAL || filter == MISS)
                    event = eventSample[socket][WCiLF_miss];
            break;
        default:
            break;
    }
    return event;
}

uint64 LoganvillePlatform::getReadBw(uint socket, eventFilter filter)
{
    uint64 readBw = event(socket, filter, PCIRdCur);
    return (readBw * 64ULL);
}

uint64 LoganvillePlatform::getWriteBw(uint socket, eventFilter filter)
{
    uint64 writeBw = event(socket, filter, ItoM) +
                     event(socket, filter, ItoMCacheNear);
    return (writeBw * 64ULL);
}
uint64 LoganvillePlatform::getReadBw()
{
    uint64 readBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        readBw += (event(socket, TOTAL, PCIRdCur));
    return (readBw * 64ULL);
}

uint64 LoganvillePlatform::getWriteBw()
{
    uint64 writeBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        writeBw += (event(socket, TOTAL, ItoM) +
                    event(socket, TOTAL, ItoMCacheNear));
    return (writeBw * 64ULL);
}

//SPR
class EagleStreamPlatform: public LegacyPlatform
{
public:
    EagleStreamPlatform(PCM *m, bool csv, bool bandwidth, bool verbose, uint32 delay) :
        LegacyPlatform( {"PCIRdCur", "ItoM", "ItoMCacheNear", "UCRdF", "WiL", "WCiL", "WCiLF"},
                        {
                            {0xC8F3FE00000435, 0xC8F3FD00000435, 0xCC43FE00000435, 0xCC43FD00000435},
                            {0xCD43FE00000435, 0xCD43FD00000435, 0xC877DE00000135, 0xC87FDE00000135},
                            {0xC86FFE00000135, 0xC867FE00000135,},
                        },
                        m, csv, bandwidth, verbose, delay)
    {
    };

private:
    enum eventIdx {
        PCIRdCur,
        ItoM,
        ItoMCacheNear,
        UCRdF,
        WiL,
        WCiL,
        WCiLF
    };

    enum Events {
            PCIRdCur_miss,
            PCIRdCur_hit,
            ItoM_miss,
            ItoM_hit,
            ItoMCacheNear_miss,
            ItoMCacheNear_hit,
            UCRdF_miss,
            WiL_miss,
            WCiL_miss,
            WCiLF_miss,
            eventLast
    };

    virtual uint64 getReadBw(uint socket, eventFilter filter);
    virtual uint64 getWriteBw(uint socket, eventFilter filter);
    virtual uint64 getReadBw();
    virtual uint64 getWriteBw();
    virtual uint64 event(uint socket, eventFilter filter, uint idx);
};

uint64 EagleStreamPlatform::event(uint socket, eventFilter filter, uint idx)
{
    uint64 event = 0;
    switch (idx)
    {
        case PCIRdCur:
            if(filter == TOTAL)
                event = eventSample[socket][PCIRdCur_miss] +
                        eventSample[socket][PCIRdCur_hit];
                else if (filter == MISS)
                    event = eventSample[socket][PCIRdCur_miss];
                else if (filter == HIT)
                    event = eventSample[socket][PCIRdCur_hit];
            break;
        case ItoM:
            if(filter == TOTAL)
                event = eventSample[socket][ItoM_miss] +
                        eventSample[socket][ItoM_hit];
                else if (filter == MISS)
                    event = eventSample[socket][ItoM_miss];
                else if (filter == HIT)
                    event = eventSample[socket][ItoM_hit];
            break;
        case ItoMCacheNear:
            if(filter == TOTAL)
                event = eventSample[socket][ItoMCacheNear_miss] +
                        eventSample[socket][ItoMCacheNear_hit];
                else if (filter == MISS)
                    event = eventSample[socket][ItoMCacheNear_miss];
                else if (filter == HIT)
                    event = eventSample[socket][ItoMCacheNear_hit];
            break;
        case UCRdF:
                if(filter == TOTAL || filter == MISS)
                    event = eventSample[socket][UCRdF_miss];
            break;
        case WiL:
                if(filter == TOTAL || filter == MISS)
                    event = eventSample[socket][WiL_miss];
            break;
        case WCiL:
                if(filter == TOTAL || filter == MISS)
                    event = eventSample[socket][WCiL_miss];
            break;
        case WCiLF:
                if(filter == TOTAL || filter == MISS)
                    event = eventSample[socket][WCiLF_miss];
            break;
        default:
            break;
    }
    return event;
}

uint64 EagleStreamPlatform::getReadBw(uint socket, eventFilter filter)
{
    uint64 readBw = event(socket, filter, PCIRdCur);
    return (readBw * 64ULL);
}

uint64 EagleStreamPlatform::getWriteBw(uint socket, eventFilter filter)
{
    uint64 writeBw = event(socket, filter, ItoM) +
                     event(socket, filter, ItoMCacheNear);
    return (writeBw * 64ULL);
}
uint64 EagleStreamPlatform::getReadBw()
{
    uint64 readBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        readBw += (event(socket, TOTAL, PCIRdCur));
    return (readBw * 64ULL);
}

uint64 EagleStreamPlatform::getWriteBw()
{
    uint64 writeBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        writeBw += (event(socket, TOTAL, ItoM) +
                    event(socket, TOTAL, ItoMCacheNear));
    return (writeBw * 64ULL);
}

//ICX
class WhitleyPlatform: public LegacyPlatform
{
public:
    WhitleyPlatform(PCM *m, bool csv, bool bandwidth, bool verbose, uint32 delay) :
        LegacyPlatform( {"PCIRdCur", "ItoM", "ItoMCacheNear", "UCRdF","WiL"},
                        {
                            {0xC8F3FE00000435, 0xC8F3FD00000435, 0xCC43FE00000435, 0xCC43FD00000435},
                            {0xCD43FE00000435, 0xCD43FD00000435, 0xC877DE00000135, 0xC87FDE00000135},
                        },
                        m, csv, bandwidth, verbose, delay)
    {
    };

private:
    enum eventIdx {
        PCIRdCur,
        ItoM,
        ItoMCacheNear,
        UCRdF,
        WiL,
    };

    enum Events {
            PCIRdCur_miss,
            PCIRdCur_hit,
            ItoM_miss,
            ItoM_hit,
            ItoMCacheNear_miss,
            ItoMCacheNear_hit,
            UCRdF_miss,
            WiL_miss,
            eventLast
    };

    virtual uint64 getReadBw(uint socket, eventFilter filter);
    virtual uint64 getWriteBw(uint socket, eventFilter filter);
    virtual uint64 getReadBw();
    virtual uint64 getWriteBw();
    virtual uint64 event(uint socket, eventFilter filter, uint idx);
};

uint64 WhitleyPlatform::event(uint socket, eventFilter filter, uint idx)
{
    uint64 event = 0;
    switch (idx)
    {
        case PCIRdCur:
            if(filter == TOTAL)
                event = eventSample[socket][PCIRdCur_miss] +
                        eventSample[socket][PCIRdCur_hit];
                else if (filter == MISS)
                    event = eventSample[socket][PCIRdCur_miss];
                else if (filter == HIT)
                    event = eventSample[socket][PCIRdCur_hit];
            break;
        case ItoM:
            if(filter == TOTAL)
                event = eventSample[socket][ItoM_miss] +
                        eventSample[socket][ItoM_hit];
                else if (filter == MISS)
                    event = eventSample[socket][ItoM_miss];
                else if (filter == HIT)
                    event = eventSample[socket][ItoM_hit];
            break;
        case ItoMCacheNear:
            if(filter == TOTAL)
                event = eventSample[socket][ItoMCacheNear_miss] +
                        eventSample[socket][ItoMCacheNear_hit];
                else if (filter == MISS)
                    event = eventSample[socket][ItoMCacheNear_miss];
                else if (filter == HIT)
                    event = eventSample[socket][ItoMCacheNear_hit];
            break;
        case UCRdF:
                if(filter == TOTAL || filter == MISS)
                    event = eventSample[socket][UCRdF_miss];
            break;
        case WiL:
                if(filter == TOTAL || filter == MISS)
                    event = eventSample[socket][WiL_miss];
            break;
        default:
            break;
    }
    return event;
}

uint64 WhitleyPlatform::getReadBw(uint socket, eventFilter filter)
{
    uint64 readBw = event(socket, filter, PCIRdCur);
    return (readBw * 64ULL);
}

uint64 WhitleyPlatform::getWriteBw(uint socket, eventFilter filter)
{
    uint64 writeBw = event(socket, filter, ItoM) +
                     event(socket, filter, ItoMCacheNear);
    return (writeBw * 64ULL);
}
uint64 WhitleyPlatform::getReadBw()
{
    uint64 readBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        readBw += (event(socket, TOTAL, PCIRdCur));
    return (readBw * 64ULL);
}

uint64 WhitleyPlatform::getWriteBw()
{
    uint64 writeBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        writeBw += (event(socket, TOTAL, ItoM) +
                    event(socket, TOTAL, ItoMCacheNear));
    return (writeBw * 64ULL);
}

// CLX, SKX
class PurleyPlatform: public LegacyPlatform
{
public:
    PurleyPlatform(PCM *m, bool csv, bool bandwidth, bool verbose, uint32 delay) :
        LegacyPlatform( {"PCIRdCur", "RFO", "CRd", "DRd","ItoM", "PRd", "WiL"},
                        {
                            {0x00043c33}, //PCIRdCur_miss
                            {0x00043c37}, //PCIRdCur_hit
                            {0x00040033}, //RFO_miss
                            {0x00040037}, //RFO_hit
                            {0x00040233}, //CRd_miss
                            {0x00040237}, //CRd_hit
                            {0x00040433}, //DRd_miss
                            {0x00040437}, //DRd_hit
                            {0x00049033}, //ItoM_miss
                            {0x00049037}, //ItoM_hit
                            {0x40040e33}, //PRd_miss
                            {0x40040e37}, //PRd_hit
                            {0x40041e33}, //WiL_miss
                            {0x40041e37}, //WiL_hit
                        },
                        m, csv, bandwidth, verbose, delay)
    {
    };

private:
    enum eventIdx {
        PCIRdCur,
        RFO,
        CRd,
        DRd,
        ItoM,
        PRd,
        WiL,
    };

    enum Events {
            PCIRdCur_miss,
            PCIRdCur_hit,
            RFO_miss,
            RFO_hit,
            CRd_miss,
            CRd_hit,
            DRd_miss,
            DRd_hit,
            ItoM_miss,
            ItoM_hit,
            PRd_miss,
            PRd_hit,
            WiL_miss,
            WiL_hit,
    };

    virtual uint64 getReadBw(uint socket, eventFilter filter);
    virtual uint64 getWriteBw(uint socket, eventFilter filter);
    virtual uint64 getReadBw();
    virtual uint64 getWriteBw();
    virtual uint64 event(uint socket, eventFilter filter, uint idx);
};

uint64 PurleyPlatform::event(uint socket, eventFilter filter, uint idx)
{
    uint64 event = 0;
    if(filter == TOTAL)
        event = eventSample[socket][2 * idx] +
                eventSample[socket][2 * idx + 1];
        else if (filter == MISS)
            event = eventSample[socket][2 * idx];
        else if (filter == HIT)
            event = eventSample[socket][2 * idx + 1];

    return event;
}

uint64 PurleyPlatform::getReadBw(uint socket, eventFilter filter)
{
    uint64 readBw = event(socket, filter, PCIRdCur) +
                    event(socket, filter, RFO) +
                    event(socket, filter, CRd) +
                    event(socket, filter, DRd);

    return (readBw * 64ULL);
}

uint64 PurleyPlatform::getReadBw()
{
    uint64 readBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        readBw += (event(socket, TOTAL, PCIRdCur) +
                   event(socket, TOTAL, RFO) +
                   event(socket, TOTAL, CRd) +
                   event(socket, TOTAL, DRd));
    return (readBw * 64ULL);
}

uint64 PurleyPlatform::getWriteBw(uint socket, eventFilter filter)
{
    uint64 writeBw = event(socket, filter, RFO) +
                     event(socket, filter, ItoM);
    return (writeBw * 64ULL);
}

uint64 PurleyPlatform::getWriteBw()
{
    uint64 writeBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        writeBw += (event(socket, TOTAL, RFO) +
                    event(socket, TOTAL, ItoM));
    return (writeBw * 64ULL);
}

//BDX, HSX
class GrantleyPlatform: public LegacyPlatform
{
public:
    GrantleyPlatform(PCM *m, bool csv, bool bandwidth, bool verbose, uint32 delay) :
        LegacyPlatform( {"PCIRdCur", "RFO", "CRd", "DRd","ItoM", "PRd", "WiL"},
                        {
                            {0x19e10000}, //PCIRdCur_miss
                            {0x19e00000}, //PCIRdCur_total
                            {0x18030000}, //RFO_miss
                            {0x18020000}, //RFO_total
                            {0x18110000}, //CRd_miss
                            {0x18100000}, //CRd_total
                            {0x18210000}, //DRd_miss
                            {0x18200000}, //DRd_total
                            {0x1c830000}, //ItoM_miss
                            {0x1c820000}, //ItoM_total
                            {0x18710000}, //PRd_miss
                            {0x18700000}, //PRd_total
                            {0x18f10000}, //WiL_miss
                            {0x18f00000}, //WiL_total
                        },
                        m, csv, bandwidth, verbose, delay)
    {
    };

private:
    enum eventIdx {
        PCIRdCur,
        RFO,
        CRd,
        DRd,
        ItoM,
        PRd,
        WiL,
    };

    enum Events {
            PCIRdCur_miss,
            PCIRdCur_total,
            RFO_miss,
            RFO_total,
            CRd_miss,
            CRd_total,
            DRd_miss,
            DRd_total,
            ItoM_miss,
            ItoM_total,
            PRd_miss,
            PRd_total,
            WiL_miss,
            WiL_total,
    };

    virtual uint64 getReadBw(uint socket, eventFilter filter);
    virtual uint64 getWriteBw(uint socket, eventFilter filter);
    virtual uint64 getReadBw();
    virtual uint64 getWriteBw();
    virtual uint64 event(uint socket, eventFilter filter, uint idx);
};

uint64 GrantleyPlatform::event(uint socket, eventFilter filter, uint idx)
{
    uint64 event = 0;
    if(filter == HIT)
        if (eventSample[socket][2 * idx] < eventSample[socket][2 * idx + 1])
            event = eventSample[socket][2 * idx + 1] - eventSample[socket][2 * idx];
        else
            event = 0;
    else if (filter == MISS)
        event = eventSample[socket][2 * idx];
    else if (filter == TOTAL)
        event = eventSample[socket][2 * idx + 1];

    return event;
}

uint64 GrantleyPlatform::getReadBw(uint socket, eventFilter filter)
{
    uint64 readBw = event(socket, filter, PCIRdCur) +
                    event(socket, filter, RFO) +
                    event(socket, filter, CRd) +
                    event(socket, filter, DRd);

    return (readBw * 64ULL);
}

uint64 GrantleyPlatform::getReadBw()
{
    uint64 readBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        readBw += (event(socket, TOTAL, PCIRdCur) +
                   event(socket, TOTAL, RFO) +
                   event(socket, TOTAL, CRd) +
                   event(socket, TOTAL, DRd));
    return (readBw * 64ULL);
}

uint64 GrantleyPlatform::getWriteBw(uint socket, eventFilter filter)
{
    uint64 writeBw = event(socket, filter, RFO) +
                     event(socket, filter, ItoM);
    return (writeBw * 64ULL);
}

uint64 GrantleyPlatform::getWriteBw()
{
    uint64 writeBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        writeBw += (event(socket, TOTAL, RFO) +
                    event(socket, TOTAL, ItoM));
    return (writeBw * 64ULL);
}

//IVT, JKT
class BromolowPlatform: public LegacyPlatform
{
public:
    BromolowPlatform(PCM *m, bool csv, bool bandwidth, bool verbose, uint32 delay) :
        LegacyPlatform( {"PCIeRdCur", "PCIeNSRd", "PCIeWiLF", "PCIeItoM","PCIeNSWr", "PCIeNSWrF"},
                        {
                            {0x19e10000}, //PCIeRdCur_miss
                            {0x19e00000}, //PCIeRdCur_total
                            {0x1e410000}, //PCIeNSRd_miss
                            {0x1e400000}, //PCIeNSRd_total
                            {0x19410000}, //PCIeWiLF_miss
                            {0x19400000}, //PCIeWiLF_total
                            {0x19c10000}, //PCIeItoM_miss
                            {0x19c00000}, //PCIeItoM_total
                            {0x1e510000}, //PCIeNSWr_miss
                            {0x1e500000}, //PCIeNSWr_total
                            {0x1e610000}, //PCIeNSWrF_miss
                            {0x1e600000}, //PCIeNSWrF_total
                        },
                        m, csv, bandwidth, verbose, delay)
    {
    };

private:
    enum eventIdx {
        PCIeRdCur,
        PCIeNSRd,
        PCIeWiLF,
        PCIeItoM,
        PCIeNSWr,
        PCIeNSWrF,
    };

    enum Events {
            PCIeRdCur_miss,
            PCIeRdCur_total,
            PCIeNSRd_miss,
            PCIeNSRd_total,
            PCIeWiLF_miss,
            PCIeWiLF_total,
            PCIeItoM_miss,
            PCIeItoM_total,
            PCIeNSWr_miss,
            PCIeNSWr_total,
            PCIeNSWrF_miss,
            PCIeNSWrF_total,
    };

    virtual uint64 getReadBw(uint socket, eventFilter filter);
    virtual uint64 getWriteBw(uint socket, eventFilter filter);
    virtual uint64 getReadBw();
    virtual uint64 getWriteBw();
    virtual uint64 event(uint socket, eventFilter filter, uint idx);
};

uint64 BromolowPlatform::event(uint socket, eventFilter filter, uint idx)
{
    uint64 event = 0;
    if(filter == HIT)
        if (eventSample[socket][2 * idx] < eventSample[socket][2 * idx + 1])
            event = eventSample[socket][2 * idx + 1] - eventSample[socket][2 * idx];
        else
            event = 0;
    else if (filter == MISS)
        event = eventSample[socket][2 * idx];
    else if (filter == TOTAL)
        event = eventSample[socket][2 * idx + 1];

    return event;
}

uint64 BromolowPlatform::getReadBw(uint socket, eventFilter filter)
{
    uint64 readBw = event(socket, filter, PCIeRdCur) +
                    event(socket, filter, PCIeNSWr);
    return (readBw * 64ULL);
}

uint64 BromolowPlatform::getReadBw()
{
    uint64 readBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        readBw += (event(socket, TOTAL, PCIeRdCur) +
                   event(socket, TOTAL, PCIeNSWr));
    return (readBw * 64ULL);
}

uint64 BromolowPlatform::getWriteBw(uint socket, eventFilter filter)
{
    uint64 writeBw = event(socket, filter, PCIeWiLF) +
                     event(socket, filter, PCIeItoM) +
                     event(socket, filter, PCIeNSWr) +
                     event(socket, filter, PCIeNSWrF);
    return (writeBw * 64ULL);
}

uint64 BromolowPlatform::getWriteBw()
{
    uint64 writeBw = 0;
    for (uint socket = 0; socket < m_socketCount; socket++)
        writeBw += (event(socket, TOTAL, PCIeWiLF) +
                    event(socket, TOTAL, PCIeItoM) +
                    event(socket, TOTAL, PCIeNSWr) +
                    event(socket, TOTAL, PCIeNSWrF));
    return (writeBw * 64ULL);
}

```

`src/pcm-power.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation

// written by Roman Dementiev
// added PPD cycles by Thomas Willhalm

#include "cpucounters.h"
#ifdef _MSC_VER
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#include <signal.h>
#include <sys/time.h> // for gettimeofday()
#endif
#include <iostream>
#include <stdlib.h>
#include <iomanip>
#include <variant>
#ifdef _MSC_VER
#include "freegetopt/getopt.h"
#endif
#include "utils.h"

#define PCM_DELAY_DEFAULT 1.0       // in seconds
#define PCM_DELAY_MIN 0.015         // 15 milliseconds is practical on most modern CPUs

using namespace std;
using namespace pcm;

int getFirstRank(int imc_profile)
{
    return imc_profile * 2;
}
int getSecondRank(int imc_profile)
{
    return (imc_profile * 2) + 1;
}

double getCKEOffResidency(uint32 channel, uint32 rank, const ServerUncoreCounterState & before, const ServerUncoreCounterState & after)
{
    return double(getMCCounter(channel, (rank & 1) ? 2 : 0, before, after)) / double(getDRAMClocks(channel, before, after));
}

int64 getCKEOffAverageCycles(uint32 channel, uint32 rank, const ServerUncoreCounterState & before, const ServerUncoreCounterState & after)
{
    uint64 div = getMCCounter(channel, (rank & 1) ? 3 : 1, before, after);
    if (div)
        return getMCCounter(channel, (rank & 1) ? 2 : 0, before, after) / div;

    return -1;
}

int64 getCyclesPerTransition(uint32 channel, uint32 rank, const ServerUncoreCounterState & before, const ServerUncoreCounterState & after)
{
    uint64 div = getMCCounter(channel, (rank & 1) ? 3 : 1, before, after);
    if (div)
        return getDRAMClocks(channel, before, after) / div;

    return -1;
}

uint64 getSelfRefreshCycles(uint32 channel, const ServerUncoreCounterState & before, const ServerUncoreCounterState & after)
{
    return getMCCounter(channel, 0, before, after);
}

uint64 getSelfRefreshTransitions(uint32 channel, const ServerUncoreCounterState & before, const ServerUncoreCounterState & after)
{
    return getMCCounter(channel, 1, before, after);
}

uint64 getPPDCycles(uint32 channel, const ServerUncoreCounterState & before, const ServerUncoreCounterState & after)
{
    return getMCCounter(channel, 2, before, after);
}

double getNormalizedPCUCounter(uint32 unit, uint32 counter, const ServerUncoreCounterState & before, const ServerUncoreCounterState & after)
{
    const auto clk = getPCUClocks(unit, before, after);
    if (clk)
    {
        return double(getUncoreCounter(PCM::PCU_PMU_ID, unit, counter, before, after)) / double(clk);
    }
    return -1.0;
}

double getNormalizedPCUCounter(uint32 unit, uint32 counter, const ServerUncoreCounterState & before, const ServerUncoreCounterState & after, PCM * m)
{
    const uint64 PCUClocks = (m->getPCUFrequency() * getInvariantTSC(before, after)) / m->getNominalFrequency();
    // cout << "PCM Debug: PCU clocks " << PCUClocks << " PCU frequency: " << m->getPCUFrequency() << "\n";
    return double(getUncoreCounter(PCM::PCU_PMU_ID, unit, counter, before, after)) / double(PCUClocks);
}

namespace PERF_LIMIT_REASON_TPMI
{
    // from https://github.com/intel/tpmi_power_management
    //      https://github.com/intel/tpmi_power_management/blob/main/TPMI_Perf_Limit_reasons_rev3.pdf
    const auto PERF_LIMIT_REASON_TPMI_ID = 0xC;
    const auto PERF_LIMIT_REASON_TPMI_HEADER            = 0x0;
    const auto PERF_LIMIT_REASON_TPMI_MAILBOX_INTERFACE = 0x8;
    const auto PERF_LIMIT_REASON_TPMI_MAILBOX_DATA      = 0x10;
    const auto PERF_LIMIT_REASON_TPMI_DIE_LEVEL         = 0x18;
    const auto PERF_LIMIT_REASON_TPMI_MAILBOX_INTERFACE_COMMAND_WRITE = 1ULL;
    const auto PERF_LIMIT_REASON_TPMI_MAILBOX_INTERFACE_ID_SHIFT = 12ULL;
    const auto PERF_LIMIT_REASON_TPMI_MAILBOX_INTERFACE_RUN_BUSY = (1ULL << 63ULL);

    bool isSupported()
    {
        bool PERF_LIMIT_REASON_TPMI_Supported = false;
        auto numTPMIInstances = TPMIHandle::getNumInstances();
        DBG(1, "TPMI instances detected: ", numTPMIInstances);
        for (size_t i = 0; i < numTPMIInstances; ++i)
        {
            TPMIHandle h(i, PERF_LIMIT_REASON_TPMI_ID, PERF_LIMIT_REASON_TPMI_HEADER);
            DBG(1, "TPMI instance ", i, " has ", h.getNumEntries(), " entries");
            for (uint32 j = 0; j < h.getNumEntries(); ++j)
            {
                const auto header = h.read64(j);
                if (header == ~0ULL)
                {
                    DBG(1, "TPMI instance ", i, " die ", j, " header read failed");
                    return false;
                }
                const auto version =      extract_bits_64(header, 7, 0);
                const auto majorVersion = extract_bits_64(header, 7, 5);
                const auto minorVersion = extract_bits_64(header, 4, 0);
                DBG(1, "PLR_HEADER.INTERFACE_VERSION instance ", i, " die ", j, " version ", version, " (major version ", majorVersion, " minor version ", minorVersion, ")");
                PERF_LIMIT_REASON_TPMI_Supported = true;
            }
        }
        return PERF_LIMIT_REASON_TPMI_Supported;
    }

    int getMaxPMModuleID(const PCM * m)
    {
        int max_pm_module_id = -1;
        DBG(1, "Detecting max PM module ID from MSR_PM_LOGICAL_ID. numCores: ", m->getNumCores());
        for (unsigned int core = 0; core < m->getNumCores(); ++core)
        {
            if (m->isCoreOnline(core) == false)
                continue;

            MsrHandle msr(core);
            uint64 val = 0;
            constexpr auto MSR_PM_LOGICAL_ID = 0x54;
            const auto readSize = msr.read(MSR_PM_LOGICAL_ID, &val);
            if (readSize != sizeof(uint64))
            {
                std::cerr << "Error reading MSR_PM_LOGICAL_ID (0x54) on core " << core << "\n";
                continue;
            }
            DBG(2, "Core ", core, " MSR_PM_LOGICAL_ID value: 0x", std::hex, val, std::dec);
            const auto module_id = (int)extract_bits(val, 10, 3);
            DBG(2, "Core ", core, " PM module ID: ", module_id);
            max_pm_module_id = (std::max)(max_pm_module_id, module_id);
        }
        return max_pm_module_id;
    }

    void reset(const size_t max_pm_modules)
    {
        auto numTPMIInstances = TPMIHandle::getNumInstances();
        for (size_t i = 0; i < numTPMIInstances; ++i)
        {
            TPMIHandle die_level(i, PERF_LIMIT_REASON_TPMI_ID, PERF_LIMIT_REASON_TPMI_DIE_LEVEL, false);
            for (uint32 j = 0; j < die_level.getNumEntries(); ++j)
            {
                die_level.write64(j, 0);
            }
            for (size_t module = 0; module < max_pm_modules; ++module)
            {
                TPMIHandle mailbox_data(i, PERF_LIMIT_REASON_TPMI_ID, PERF_LIMIT_REASON_TPMI_MAILBOX_DATA, false);
                TPMIHandle mailbox_interface(i, PERF_LIMIT_REASON_TPMI_ID, PERF_LIMIT_REASON_TPMI_MAILBOX_INTERFACE, false);
                assert(mailbox_data.getNumEntries() == mailbox_interface.getNumEntries());
                for (uint32 j = 0; j < mailbox_data.getNumEntries(); ++j)
                {
                    mailbox_data.write64(j, 0);
                    const uint64 value =    PERF_LIMIT_REASON_TPMI_MAILBOX_INTERFACE_COMMAND_WRITE |
                                            (module << PERF_LIMIT_REASON_TPMI_MAILBOX_INTERFACE_ID_SHIFT) |
                                            PERF_LIMIT_REASON_TPMI_MAILBOX_INTERFACE_RUN_BUSY ;
                    mailbox_interface.write64(j, value);
                    while (mailbox_interface.read64(j) & PERF_LIMIT_REASON_TPMI_MAILBOX_INTERFACE_RUN_BUSY)
                    {
                        // wait for the command to be processed
                    }
                }
            }
        }
    };

    std::vector<std::vector<uint64>> readDies()
    {
        auto numTPMIInstances = TPMIHandle::getNumInstances();
        std::vector<std::vector<uint64>> data;
        for (size_t i = 0; i < numTPMIInstances; ++i)
        {
            std::vector<uint64> instanceData;
            TPMIHandle die_level(i, PERF_LIMIT_REASON_TPMI_ID, PERF_LIMIT_REASON_TPMI_DIE_LEVEL);
            for (uint32 j = 0; j < die_level.getNumEntries(); ++j)
            {
                instanceData.push_back(die_level.read64(j));
            }
            data.push_back(instanceData);
        }
        return data;
    };

    std::vector<std::vector<std::vector<uint64>>> readModules(const size_t max_pm_modules)
    {
        auto numTPMIInstances = TPMIHandle::getNumInstances();
        std::vector<std::vector<std::vector<uint64>>> data;
        for (size_t i = 0; i < numTPMIInstances; ++i)
        {
            std::vector<std::vector<uint64>> moduleData;
            for (size_t module = 0; module < max_pm_modules; ++module)
            {
                std::vector<uint64> instanceData;
                TPMIHandle mailbox_data(i, PERF_LIMIT_REASON_TPMI_ID, PERF_LIMIT_REASON_TPMI_MAILBOX_DATA);
                TPMIHandle mailbox_interface(i, PERF_LIMIT_REASON_TPMI_ID, PERF_LIMIT_REASON_TPMI_MAILBOX_INTERFACE, false);
                assert(mailbox_data.getNumEntries() == mailbox_interface.getNumEntries());
                for (uint32 j = 0; j < mailbox_data.getNumEntries(); ++j)
                {
                    const uint64 value =    (module << PERF_LIMIT_REASON_TPMI_MAILBOX_INTERFACE_ID_SHIFT) |
                                            PERF_LIMIT_REASON_TPMI_MAILBOX_INTERFACE_RUN_BUSY ;
                    mailbox_interface.write64(j, value);
                    while (mailbox_interface.read64(j) & PERF_LIMIT_REASON_TPMI_MAILBOX_INTERFACE_RUN_BUSY)
                    {
                        // wait for the command to be processed
                    }
                    instanceData.push_back(mailbox_data.read64(j));
                }
                moduleData.push_back(instanceData);
            }
            data.push_back(moduleData);
        }
        return data;
    };

    enum Coarse_Grained_PLR_Bit_Definition
    {
        FREQUENCY = 0,
        CURRENT = 1,
        POWER = 2,
        THERMAL = 3,
        PLATFORM = 4,
        MCP = 5,
        RAS = 6,
        MISC = 7,
        QOS = 8,
        DFC = 9,
        MAX = 10
    };
    const char * Coarse_Grained_PLR_Bit_Definition_Strings[] = {
        "FREQUENCY", // Limitation due to Turbo Ratio Limit (TRL)
        "CURRENT",   // Package ICCmax or MT-Pmax
        "POWER",     // Socket or Platform RAPL
        "THERMAL",   // Thermal Throttling
        "PLATFORM",  // Prochot or Hot VR
        "MCP",       // freq limit due to a companion die like PCH
        "RAS",       // freq limit due to RAS
        "MISC",      // Freq limit from out-of-band SW (e.g. BMC)
        "QOS",       // SST-CP, SST-BF, SST-TF
        "DFC"        // Freq limitation due to Dynamic Freq Capping
    };
    enum Fine_Grained_PLR_Bit_Definition
    {
        CDYN0 = 0,
        CDYN1 = 1,
        CDYN2 = 2,
        CDYN3 = 3,
        CDYN4 = 4,
        CDYN5 = 5,
        FCT = 6,
        PCS_TRL = 7,
        MTPMAX = 8,
        FAST_RAPL = 9,
        PKG_PL1_MSR_TPMI = 10,
        PKG_PL1_MMIO = 11,
        PKG_PL1_PCS = 12,
        PKG_PL2_MSR_TPMI = 13,
        PKG_PL2_MMIO = 14,
        PKG_PL2_PCS = 15,
        PLATFORM_PL1_MSR_TPMI = 16,
        PLATFORM_PL1_MMIO = 17,
        PLATFORM_PL1_PCS = 18,
        PLATFORM_PL2_MSR_TPMI = 19,
        PLATFORM_PL2_MMIO = 20,
        PLATFORM_PL2_PCS = 21,
        RSVD = 22,
        PER_CORE_THERMAL = 23,
        UFS_DFC = 24,
        XXPROCHOT = 25,
        HOT_VR = 26,
        RSVD2 = 27,
        RSVD3 = 28,
        PCS_PSTATE = 29,
        MAX_FINE = 30
    };
    struct FGData
    {
        const char * name;
        int coarse_grained_mapping;
        FGData(const char * n, int c) : name(n), coarse_grained_mapping(c) {}
    };
    const FGData Fine_Grained_PLR_Bit_Definition_Data[] = {
        FGData("TRL/CDYN0", FREQUENCY), // Turbo Ratio Limit 0
        FGData("TRL/CDYN1", FREQUENCY), // Turbo Ratio Limit 1
        FGData("TRL/CDYN2", FREQUENCY), // Turbo Ratio Limit 2
        FGData("TRL/CDYN3", FREQUENCY), // Turbo Ratio Limit 3
        FGData("TRL/CDYN4", FREQUENCY), // Turbo Ratio Limit 4
        FGData("TRL/CDYN5", FREQUENCY), // Turbo Ratio Limit 5
        FGData("FCT", FREQUENCY),       // Favored Core Turbo
        FGData("PCS_TRL", FREQUENCY),   // Turbo Ratio Limit from out-of-band (BMC)
        FGData("MTPMAX", CURRENT),
        FGData("FAST_RAPL", POWER),
        FGData("PKG_PL1_MSR_TPMI", POWER),
        FGData("PKG_PL1_MMIO", POWER),
        FGData("PKG_PL1_PCS", POWER),
        FGData("PKG_PL2_MSR_TPMI", POWER),
        FGData("PKG_PL2_MMIO", POWER),
        FGData("PKG_PL2_PCS", POWER),
        FGData("PLATFORM_PL1_MSR_TPMI", POWER),
        FGData("PLATFORM_PL1_MMIO", POWER),
        FGData("PLATFORM_PL1_PCS", POWER),
        FGData("PLATFORM_PL2_MSR_TPMI", POWER),
        FGData("PLATFORM_PL2_MMIO", POWER),
        FGData("PLATFORM_PL2_PCS", POWER),
        FGData("RSVD", POWER),
        FGData("PER_CORE_THERMAL", THERMAL), // Thermal Throttling
        FGData("UFS_DFC", DFC),              // Dynamic Freq Capping
        FGData("XXPROCHOT", PLATFORM),
        FGData("HOT_VR", PLATFORM),
        FGData("RSVD2", PLATFORM),
        FGData("RSVD3", PLATFORM),
        FGData("PCS_PSTATE", MISC)
    };
};

int default_freq_band[3] = { 12, 20, 40 };
int freq_band[3];

void print_usage(const string & progname)
{
    cout << "\n Usage: \n " << progname
         << " --help | [delay] [options] [-- external_program [external_program_options]]\n";
    cout << "   <delay>                           => time interval to sample performance counters.\n";
    cout << "                                        If not specified, or 0, with external program given\n";
    cout << "                                        will read counters only after external program finishes\n";
    cout << " Supported <options> are: \n";
    cout << "  -h    | --help  | /h               => print this help and exit\n";
    cout << "  -silent                            => silence information output and print only measurements\n";
    cout << "  --version                          => print application version\n";
    cout << "  -i[=number] | /i[=number]          => allow to determine number of iterations\n";
    cout << "  -csv[=file.csv] | /csv[=file.csv]  => output compact CSV format to screen or\n"
         << "                                        to a file, in case filename is provided\n";
    cout << "  [-m imc_profile] [-p pcu_profile] [-a freq_band0] [-b freq_band1] [-c freq_band2]\n\n";
    cout << " Where: imc_profile, pcu_profile, freq_band0, freq_band1 and freq_band2 are the following:\n";
    cout << "  <imc_profile>      - profile (counter group) for IMC PMU. Possible values are: 0,1,2,3,4,-1 \n";
    cout << "                       profile  0 - rank 0 and rank 1 residencies (default) \n";
    cout << "                       profile  1 - rank 2 and rank 3 residencies \n";
    cout << "                       profile  2 - rank 4 and rank 5 residencies \n";
    cout << "                       profile  3 - rank 6 and rank 7 residencies \n";
    cout << "                       profile  4 - self-refresh residencies \n";
    cout << "                       profile -1 - omit IMC PMU output\n";
    cout << "  <pcu_profile>      - profile (counter group) for PCU PMU. Possible values are: 0,1,2,3,4,5,-1 \n";
    cout << "                       profile  0 - frequency residencies (default) \n";
    cout << "                       profile  1 - core C-state residencies. The unit is the number of physical cores on the socket who were in C0, C3 or C6 during the measurement interval (e.g. 'C0 residency is 3.5' means on average 3.5 physical cores were resident in C0 state)\n";
    cout << "                       profile  2 - Prochot (throttled) residencies and thermal frequency limit cycles \n";
    cout << "                       profile  3 - {Thermal,Power,Clipped} frequency limit cycles \n";
    cout << "                       profile  4 - {OS,Power,Clipped} frequency limit cycles \n";
    cout << "                       profile  5 - frequency transition statistics \n";
    cout << "                       profile  6 - package C-states residency and transition statistics \n";
    cout << "                       profile  7 - UFS transition statistics (1) \n";
    cout << "                       profile  8 - UFS transition statistics (2) \n";
    cout << "                       profile -1 - omit PCU PMU output\n";
    cout << "  <freq_band0>       - frequency minimum for band 0 for PCU frequency residency profile [in 100MHz units] (default is " <<
        default_freq_band[0] << "= " << 100 * default_freq_band[0] << "MHz)\n";
    cout << "  <freq_band1>       - frequency minimum for band 1 for PCU frequency residency profile [in 100MHz units] (default is " <<
        default_freq_band[1] << "= " << 100 * default_freq_band[1] << "MHz)\n";
    cout << "  <freq_band2>       - frequency minimum for band 2 for PCU frequency residency profile [in 100MHz units] (default is " <<
        default_freq_band[2] << "= " << 100 * default_freq_band[2] << "MHz)\n";
    cout << "\n";
}

struct Metric
{
    typedef std::variant<double, uint64, int64, int32, bool> ValueType;
    std::string name{};
    ValueType value{};
    std::string unit{};
    Metric(const std::string & n, const ValueType & v, const std::string & u) : name(n), value(v), unit(u) {}
    Metric() = default;
};

bool csv = false;
bool csv_header = false;

void printMetrics(const std::string & header, const std::vector<Metric> & metrics, const CsvOutputType outputType, const bool skipZeroValues = false)
{
    if (csv)
    {
        const auto numMetrics = metrics.size();
        choose(outputType,
            [&]() {
                for (size_t i = 0; i < numMetrics; ++i)
                {
                    cout << header << ',';
                }
            },
            [&]() {
                for (size_t i = 0; i < numMetrics; ++i)
                {
                    cout << metrics[i].name;
                    if (!metrics[i].unit.empty())
                    {
                        cout << '(' << metrics[i].unit << ')';
                    }
                    cout << ',';
                }
            },
            [&]() {
                for (size_t i = 0; i < numMetrics; ++i)
                {
                    if (std::holds_alternative<uint64>(metrics[i].value))
                    {
                        cout << std::get<uint64>(metrics[i].value);
                    }
                    else if (std::holds_alternative<double>(metrics[i].value))
                    {
                        cout << std::get<double>(metrics[i].value);
                    }
                    else if (std::holds_alternative<int64>(metrics[i].value))
                    {
                        cout << std::get<int64>(metrics[i].value);
                    }
                    else if (std::holds_alternative<int32>(metrics[i].value))
                    {
                        cout << std::get<int32>(metrics[i].value);
                    }
                    else if (std::holds_alternative<bool>(metrics[i].value))
                    {
                        cout << (std::get<bool>(metrics[i].value) ? '1' : '0');
                    }
                    else
                    {
                        assert(false && "Unknown metric type");
                    }
                    cout << ',';
                }
            });
        return;
    }
    cout << header << "; ";
    for (const auto & metric : metrics)
    {
        if (skipZeroValues)
        {
            if (std::holds_alternative<uint64>(metric.value) && std::get<uint64>(metric.value) == 0)
            {
                continue;
            }
            if (std::holds_alternative<double>(metric.value) && std::get<double>(metric.value) == 0.0)
            {
                continue;
            }
            if (std::holds_alternative<int64>(metric.value) && std::get<int64>(metric.value) == 0)
            {
                continue;
            }
            if (std::holds_alternative<int32>(metric.value) && std::get<int32>(metric.value) == 0)
            {
                continue;
            }
        }
        if (std::holds_alternative<bool>(metric.value))
        {
            if (std::get<bool>(metric.value))
            {
                cout << metric.name << ";";
            }
            continue;
        }
        cout << metric.name << ": ";
        if (std::holds_alternative<uint64>(metric.value))
        {
            cout << std::get<uint64>(metric.value);
        }
        else if (std::holds_alternative<double>(metric.value))
        {
            cout << std::get<double>(metric.value);
        }
        else if (std::holds_alternative<int64>(metric.value))
        {
            cout << std::get<int64>(metric.value);
        }
        else if (std::holds_alternative<int32>(metric.value))
        {
            cout << std::get<int32>(metric.value);
        }
        else
        {
            assert(false && "Unknown metric type");
        }
        if (!metric.unit.empty())
        {
            cout << " " << metric.unit;
        }
        cout << "; ";
    }
    cout << "\n";
}

void printMetrics(const std::string & header, const std::initializer_list<Metric> & metrics, const CsvOutputType outputType, const bool skipZeroValues = false)
{
    std::vector<Metric> metricsVec;
    for (const auto & metric : metrics)
    {
        metricsVec.push_back(metric);
    }
    printMetrics(header, metricsVec, outputType, skipZeroValues);
}

PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
    if(print_version(argc, argv))
        exit(EXIT_SUCCESS);

    null_stream nullStream;
    check_and_set_silent(argc, argv, nullStream);

    set_signal_handlers();

    cerr << "\n Intel(r) Performance Counter Monitor " << PCM_VERSION << "\n";
    cerr << "\n Power Monitoring Utility\n";

    int imc_profile = 0;
    int pcu_profile = 0;
    double delay = -1.0;
    char * sysCmd = NULL;
    char ** sysArgv = NULL;

    freq_band[0] = default_freq_band[0];
    freq_band[1] = default_freq_band[1];
    freq_band[2] = default_freq_band[2];

    MainLoop mainLoop;
    string program = string(argv[0]);

    PCM * m = PCM::getInstance();

    if (argc > 1) do
        {
            argv++;
            argc--;
            string arg_value;

            if (check_argument_equals(*argv, {"--help", "-h", "/h"}))
            {
                print_usage(program);
                exit(EXIT_FAILURE);
            }
            else if (check_argument_equals(*argv, {"-silent", "/silent"}))
            {
                // handled in check_and_set_silent
                continue;
            }
            else if (check_argument_equals(*argv, {"-csv", "/csv"}))
            {
                csv = true;
                csv_header = true;
            }
            else if (extract_argument_value(*argv, {"-csv", "/csv"}, arg_value))
            {
                csv = true;
                csv_header = true;
                if (!arg_value.empty()) {
                    m->setOutput(arg_value);
                }
                continue;
            }
            else if (mainLoop.parseArg(*argv))
            {
                continue;
            }
            else if (check_argument_equals(*argv, {"-m"}))
            {
                argv++;
                argc--;
                imc_profile = atoi(*argv);
                continue;
            }
            else if (check_argument_equals(*argv, {"-p"}))
            {
                argv++;
                argc--;
                pcu_profile = atoi(*argv);
                continue;
            }
            else if (check_argument_equals(*argv, {"-a"}))
            {
                argv++;
                argc--;
                freq_band[0] = atoi(*argv);
                continue;
            }
            else if (check_argument_equals(*argv, {"-b"}))
            {
                argv++;
                argc--;
                freq_band[1] = atoi(*argv);
                continue;
            }
            else if (check_argument_equals(*argv, {"-c"}))
            {
                argv++;
                argc--;
                freq_band[2] = atoi(*argv);
                continue;
            }
            else if (check_argument_equals(*argv, {"--"}))
            {
                argv++;
                sysCmd = *argv;
                sysArgv = argv;
                break;
            }
            else
            {
                delay = parse_delay(*argv, program, (print_usage_func)print_usage);
                continue;
            }
        } while (argc > 1); // end of command line partsing loop

    m->disableJKTWorkaround();

    const int cpu_family_model = m->getCPUFamilyModel();
    if (!(m->hasPCICFGUncore()))
    {
        cerr << "Unsupported processor model (0x" << std::hex << cpu_family_model << std::dec << ").\n";
        exit(EXIT_FAILURE);
    }

    EventSelectRegister regs[PERF_MAX_CUSTOM_COUNTERS];
    PCM::ExtendedCustomCoreEventDescription conf;
    int32 nCorePowerLicenses = 0;
    std::vector<std::string> licenseStr;
    switch (cpu_family_model)
    {
    case PCM::SKX:
    case PCM::ICX:
        {
            std::vector<std::string> skxLicenseStr = { "Core cycles where the core was running with power-delivery for baseline license level 0.  This includes non-AVX codes, SSE, AVX 128-bit, and low-current AVX 256-bit codes.",
                                          "Core cycles where the core was running with power-delivery for license level 1.  This includes high current AVX 256-bit instructions as well as low current AVX 512-bit instructions.",
                                          "Core cycles where the core was running with power-delivery for license level 2 (introduced in Skylake Server michroarchtecture). This includes high current AVX 512-bit instructions." };
            licenseStr = skxLicenseStr;
            regs[0].fields.event_select = 0x28; // CORE_POWER.LVL0_TURBO_LICENSE
            regs[0].fields.umask = 0x07;        // CORE_POWER.LVL0_TURBO_LICENSE
            regs[1].fields.event_select = 0x28; // CORE_POWER.LVL1_TURBO_LICENSE
            regs[1].fields.umask = 0x18;        // CORE_POWER.LVL1_TURBO_LICENSE
            regs[2].fields.event_select = 0x28; // CORE_POWER.LVL2_TURBO_LICENSE
            regs[2].fields.umask = 0x20;        // CORE_POWER.LVL2_TURBO_LICENSE
            conf.nGPCounters = 3;
            nCorePowerLicenses = 3;
            conf.gpCounterCfg = regs;
        }
        break;
    }

    for (size_t l = 0; l < licenseStr.size(); ++l)
    {
        cout << "Core Power License " << std::to_string(l) << ": " << licenseStr[l] << "\n";
    }

    if (conf.gpCounterCfg)
    {
        m->checkError(m->program(PCM::EXT_CUSTOM_CORE_EVENTS, &conf));
    }

    m->checkError(m->programServerUncorePowerMetrics(imc_profile, pcu_profile, freq_band));

    const auto numSockets = m->getNumSockets();
    std::vector<ServerUncoreCounterState> BeforeState(numSockets);
    std::vector<ServerUncoreCounterState> AfterState(numSockets);
    SystemCounterState dummySystemState;
    std::vector<CoreCounterState> dummyCoreStates;
    std::vector<SocketCounterState> beforeSocketState, afterSocketState;
    uint64 BeforeTime = 0, AfterTime = 0;

    cerr << dec;
    cerr.precision(2);
    cerr << fixed;
    cout << dec;
    cout.precision(2);
    cout << fixed;
    cerr << "\nMC counter group: " << imc_profile << "\n";
    cerr << "PCU counter group: " << pcu_profile << "\n";
    if (pcu_profile == 0) {
        if (cpu_family_model == PCM::HASWELLX || cpu_family_model == PCM::BDX_DE || cpu_family_model == PCM::SKX)
            cerr << "Your processor does not support frequency band statistics\n";
        else
            cerr << "Freq bands [0/1/2]: " << freq_band[0] * 100 << " MHz; " << freq_band[1] * 100 << " MHz; " << freq_band[2] * 100 << " MHz; \n";
    }
    if (sysCmd != NULL)
        cerr << "Update every " << delay << " seconds\n";

    if ((sysCmd != NULL) && (delay <= 0.0)) {
        // in case external command is provided in command line, and
        // delay either not provided (-1) or is zero
        m->setBlocked(true);
    } else {
        m->setBlocked(false);
    }

    if (delay <= 0.0) delay = PCM_DELAY_DEFAULT;

    const bool PERF_LIMIT_REASON_TPMI_Supported = PERF_LIMIT_REASON_TPMI::isSupported();

    const size_t max_pm_modules = PERF_LIMIT_REASON_TPMI_Supported ? (size_t)(PERF_LIMIT_REASON_TPMI::getMaxPMModuleID(m) + 1) : 0;
    DBG(1, "max_pm_modules = ", max_pm_modules);
    std::vector<std::vector<uint64>> PERF_LIMIT_REASON_TPMI_dies_data;
    std::vector<std::vector<std::vector<uint64>>> PERF_LIMIT_REASON_TPMI_modules_data;

    uint32 i = 0;

    for (i = 0; i < numSockets; ++i)
        BeforeState[i] = m->getServerUncoreCounterState(i);

    m->getAllCounterStates(dummySystemState, beforeSocketState, dummyCoreStates, false);

    BeforeTime = m->getTickCount();
    if (sysCmd != NULL) {
        MySystem(sysCmd, sysArgv);
    }

    auto getPowerLicenseResidency = [nCorePowerLicenses](const int32 license, const SocketCounterState & before, const SocketCounterState& after)
    {
        uint64 all = 0;
        for (int32 l = 0; l < nCorePowerLicenses; ++l)
        {
            all += getNumberOfCustomEvents(l, before, after);
        }
        assert(license < nCorePowerLicenses);
	if (all > 0)
            return 100.0 * double(getNumberOfCustomEvents(license, before, after)) / double(all);
        return -1.;
    };

    const auto uncoreFreqFactor = double(m->getNumOnlineSockets()) / double(m->getNumOnlineCores());

    if (PERF_LIMIT_REASON_TPMI_Supported) PERF_LIMIT_REASON_TPMI::reset(max_pm_modules);

    auto printAll = [&](const int delay_ms, const CsvOutputType outputType)
    {
        if (csv)
        {
            printDateForCSV(outputType);
        }
        else
        {
            cout << "Time elapsed: " << AfterTime - BeforeTime << " ms\n";
            cout << "Called sleep function for " << delay_ms << " ms\n";
        }
        for (uint32 socket = 0; socket < numSockets; ++socket)
        {
            if (nCorePowerLicenses)
            {
                std::vector<Metric> metrics;
                metrics.push_back(Metric("Uncore Freq", getAverageUncoreFrequency(BeforeState[socket], AfterState[socket]) * uncoreFreqFactor / 1e9, "Ghz"));
                metrics.push_back(Metric("Core Freq", getActiveAverageFrequency(beforeSocketState[socket], afterSocketState[socket]) / 1e9, "Ghz"));
                for (int32 l = 0; l < nCorePowerLicenses; ++l)
                {
                    metrics.push_back(Metric("Core Power License " + std::to_string(l), getPowerLicenseResidency(l, beforeSocketState[socket], afterSocketState[socket]), "%"));
                }
                printMetrics("S" + std::to_string(socket), metrics, outputType);
            }
            for (uint32 port = 0; port < m->getQPILinksPerSocket(); ++port)
            {
                printMetrics("S" + std::to_string(socket) + "P" + std::to_string(port),
                    {
                        Metric(std::string(m->xPI()) + " Clocks", getQPIClocks(port, BeforeState[socket], AfterState[socket]), ""),
                        Metric("L0p Tx Cycles", 100. * getNormalizedQPIL0pTxCycles(port, BeforeState[socket], AfterState[socket]), "%"),
                        Metric("L1 Cycles", 100. * getNormalizedQPIL1Cycles(port, BeforeState[socket], AfterState[socket]), "%")
                    }, outputType);
            }
            for (uint32 channel = 0; channel < m->getMCChannelsPerSocket(); ++channel)
            {
                if (imc_profile <= 3 && imc_profile >= 0)
                {
                    printMetrics("S" + std::to_string(socket) + "CH" + std::to_string(channel),
                    {
                        Metric("DRAMClocks", getDRAMClocks(channel, BeforeState[socket], AfterState[socket]), ""),
                        Metric("Rank" + std::to_string(getFirstRank(imc_profile)) + " CKE Off Residency", 
                               100. * getCKEOffResidency(channel, getFirstRank(imc_profile), BeforeState[socket], AfterState[socket]), "%"),
                        Metric("Rank" + std::to_string(getFirstRank(imc_profile)) + " CKE Off Average Cycles", 
                               getCKEOffAverageCycles(channel, getFirstRank(imc_profile), BeforeState[socket], AfterState[socket]), ""),
                        Metric("Rank" + std::to_string(getFirstRank(imc_profile)) + " Cycles per transition", 
                               getCyclesPerTransition(channel, getFirstRank(imc_profile), BeforeState[socket], AfterState[socket]), "")
                    }, outputType);

                    printMetrics("S" + std::to_string(socket) + "CH" + std::to_string(channel),
                    {
                        Metric("DRAMClocks", getDRAMClocks(channel, BeforeState[socket], AfterState[socket]), ""),
                        Metric("Rank" + std::to_string(getSecondRank(imc_profile)) + " CKE Off Residency", 
                               100. * getCKEOffResidency(channel, getSecondRank(imc_profile), BeforeState[socket], AfterState[socket]), "%"),
                        Metric("Rank" + std::to_string(getSecondRank(imc_profile)) + " CKE Off Average Cycles", 
                               getCKEOffAverageCycles(channel, getSecondRank(imc_profile), BeforeState[socket], AfterState[socket]), ""),
                        Metric("Rank" + std::to_string(getSecondRank(imc_profile)) + " Cycles per transition", 
                               getCyclesPerTransition(channel, getSecondRank(imc_profile), BeforeState[socket], AfterState[socket]), "")
                    }, outputType);
                } else if (imc_profile == 4)
                {
                    printMetrics("S" + std::to_string(socket) + "CH" + std::to_string(channel),
                    {
                        Metric("DRAMClocks", getDRAMClocks(channel, BeforeState[socket], AfterState[socket]), ""),
                        Metric("Self-refresh cycles", getSelfRefreshCycles(channel, BeforeState[socket], AfterState[socket]), ""),
                        Metric("Self-refresh transitions", getSelfRefreshTransitions(channel, BeforeState[socket], AfterState[socket]), ""),
                        Metric("PPD cycles", getPPDCycles(channel, BeforeState[socket], AfterState[socket]), "")
                    }, outputType);
                }
            }

            for (uint32 u = 0; u < m->getMaxNumOfUncorePMUs(PCM::PCU_PMU_ID); ++u)
            {
                std::string header = "S" + std::to_string(socket);
                if (m->getMaxNumOfUncorePMUs(PCM::PCU_PMU_ID) > 1)
                {
                    header += "U" + std::to_string(u);
                }
                std::vector<Metric> metrics;
                switch (pcu_profile)
                {
                case 0:
                    if (cpu_family_model == PCM::HASWELLX || cpu_family_model == PCM::BDX_DE || cpu_family_model == PCM::SKX)
                        break;

                    printMetrics(header,
                    {
                        Metric("PCUClocks", getPCUClocks(u, BeforeState[socket], AfterState[socket]), ""),
                        Metric("Freq band 0 cycles", 100. * getNormalizedPCUCounter(u, 1, BeforeState[socket], AfterState[socket]), "%"),
                        Metric("Freq band 1 cycles", 100. * getNormalizedPCUCounter(u, 2, BeforeState[socket], AfterState[socket]), "%"),
                        Metric("Freq band 2 cycles", 100. * getNormalizedPCUCounter(u, 3, BeforeState[socket], AfterState[socket]), "%")
                    }, outputType);
                    break;

                case 1:
                    printMetrics(header,
                    {
                        Metric("PCUClocks", getPCUClocks(u, BeforeState[socket], AfterState[socket]), ""),
                        Metric(cpu_family_model == PCM::SKX ? "C0_1-state residency" : "C0-state residency", getNormalizedPCUCounter(u, 1, BeforeState[socket], AfterState[socket]), ""),
                        Metric("C3-state residency", getNormalizedPCUCounter(u, 2, BeforeState[socket], AfterState[socket]), ""),
                        Metric(cpu_family_model == PCM::SKX ? "C6_7-state residency" : "C6-state residency", getNormalizedPCUCounter(u, 3, BeforeState[socket], AfterState[socket]), "")
                    }, outputType);
                    break;

                case 2:
                    printMetrics(header,
                    {
                        Metric("PCUClocks", getPCUClocks(u, BeforeState[socket], AfterState[socket]), ""),
                        Metric("Internal prochot cycles", 100. * getNormalizedPCUCounter(u, 1, BeforeState[socket], AfterState[socket]), "%"),
                        Metric("External prochot cycles", 100. * getNormalizedPCUCounter(u, 2, BeforeState[socket], AfterState[socket]), "%"),
                        Metric("Thermal freq limit cycles", 100. * getNormalizedPCUCounter(u, 3, BeforeState[socket], AfterState[socket]), "%")
                    }, outputType);
                    break;

                case 3:
                    metrics.push_back(Metric("PCUClocks", getPCUClocks(u, BeforeState[socket], AfterState[socket]), ""));
                    metrics.push_back(Metric("Thermal freq limit cycles", 100. * getNormalizedPCUCounter(u, 1, BeforeState[socket], AfterState[socket]), "%"));
                    metrics.push_back(Metric("Power freq limit cycles", 100. * getNormalizedPCUCounter(u, 2, BeforeState[socket], AfterState[socket]), "%"));
                    if (cpu_family_model != PCM::SKX
                        && cpu_family_model != PCM::ICX
                        && cpu_family_model != PCM::SNOWRIDGE
                        && cpu_family_model != PCM::SPR
                        && cpu_family_model != PCM::EMR
                        && cpu_family_model != PCM::SRF
                        && cpu_family_model != PCM::GNR
                        && cpu_family_model != PCM::GNR_D)
                    {
                        metrics.push_back(Metric("Clipped freq limit cycles", 100. * getNormalizedPCUCounter(u, 3, BeforeState[socket], AfterState[socket]), "%"));
                    }
                    printMetrics(header, metrics, outputType);
                    break;

                case 4:
                    if (    cpu_family_model == PCM::SKX
                         || cpu_family_model == PCM::ICX
                         || cpu_family_model == PCM::SNOWRIDGE
                         || cpu_family_model == PCM::SPR
                         || cpu_family_model == PCM::EMR
                         || cpu_family_model == PCM::SRF
                         || cpu_family_model == PCM::GNR
                         || cpu_family_model == PCM::GNR_D
                         )
                    {
                        cout << "This PCU profile is not supported on your processor\n";
                        break;
                    }
                    printMetrics(header,
                    {
                        Metric("PCUClocks", getPCUClocks(u, BeforeState[socket], AfterState[socket]), ""),
                        Metric("OS freq limit cycles", 100. * getNormalizedPCUCounter(u, 1, BeforeState[socket], AfterState[socket]), "%"),
                        Metric("Power freq limit cycles", 100. * getNormalizedPCUCounter(u, 2, BeforeState[socket], AfterState[socket]), "%"),
                        Metric("Clipped freq limit cycles", 100. * getNormalizedPCUCounter(u, 3, BeforeState[socket], AfterState[socket]), "%")
                    }, outputType);
                    break;
                case 5:
                    metrics.push_back(Metric("PCUClocks", getPCUClocks(u, BeforeState[socket], AfterState[socket]), ""));
                    metrics.push_back(Metric("Frequency transition count", getUncoreCounter(PCM::PCU_PMU_ID, u, 1, BeforeState[socket], AfterState[socket]), ""));
                    metrics.push_back(Metric("Cycles spent changing frequency", 100. * getNormalizedPCUCounter(u, 2, BeforeState[socket], AfterState[socket], m), "%"));
                    if (PCM::HASWELLX == cpu_family_model)
                    {
                        metrics.push_back(Metric("UFS transition count", getUncoreCounter(PCM::PCU_PMU_ID, u, 3, BeforeState[socket], AfterState[socket]), ""));
                        metrics.push_back(Metric("UFS transition cycles", 100. * getNormalizedPCUCounter(u, 0, BeforeState[socket], AfterState[socket], m), "%"));
                    }
                    printMetrics(header, metrics, outputType);
                    break;
                case 6:
                    if (cpu_family_model == PCM::HASWELLX || PCM::BDX_DE == cpu_family_model)
                    {
                        metrics.push_back(Metric("PC1e+ residency", getNormalizedPCUCounter(u, 0, BeforeState[socket], AfterState[socket], m) * 100., "%"));
                        metrics.push_back(Metric("PC1e+ transition count", getUncoreCounter(PCM::PCU_PMU_ID, u, 1, BeforeState[socket], AfterState[socket]), ""));
                    }
                    switch (cpu_family_model)
                    {
                    case PCM::IVYTOWN:
                    case PCM::HASWELLX:
                    case PCM::BDX_DE:
                    case PCM::SKX:
                    case PCM::ICX:
                    case PCM::SNOWRIDGE:
                    case PCM::SPR:
                    case PCM::EMR:
                    case PCM::SRF:
                    case PCM::GNR:
                    case PCM::GNR_D:
                        metrics.push_back(Metric("PC2 residency", getPackageCStateResidency(2, BeforeState[socket], AfterState[socket]) * 100., "%"));
                        metrics.push_back(Metric("PC2 transitions", getUncoreCounter(PCM::PCU_PMU_ID, u, 2, BeforeState[socket], AfterState[socket]), ""));
                        metrics.push_back(Metric("PC3 residency", getPackageCStateResidency(3, BeforeState[socket], AfterState[socket]) * 100., "%"));
                        metrics.push_back(Metric("PC6 residency", getPackageCStateResidency(6, BeforeState[socket], AfterState[socket]) * 100., "%"));
                        metrics.push_back(Metric("PC6 transitions", getUncoreCounter(PCM::PCU_PMU_ID, u, 3, BeforeState[socket], AfterState[socket]), ""));
                        break;
                    }
                    printMetrics(header, metrics, outputType);
                    break;
                case 7:
                    if (PCM::HASWELLX == cpu_family_model || PCM::BDX_DE == cpu_family_model || PCM::BDX == cpu_family_model) {
                        printMetrics(header,
                        {
                            Metric("UFS_TRANSITIONS_PERF_P_LIMIT", getNormalizedPCUCounter(u, 0, BeforeState[socket], AfterState[socket], m) * 100., "%"),
                            Metric("UFS_TRANSITIONS_IO_P_LIMIT", getNormalizedPCUCounter(u, 1, BeforeState[socket], AfterState[socket], m) * 100., "%"),
                            Metric("UFS_TRANSITIONS_UP_RING_TRAFFIC", getNormalizedPCUCounter(u, 2, BeforeState[socket], AfterState[socket], m) * 100., "%"),
                            Metric("UFS_TRANSITIONS_UP_STALL_CYCLES", getNormalizedPCUCounter(u, 3, BeforeState[socket], AfterState[socket], m) * 100., "%")
                        }, outputType);
                    }
                    break;
                case 8:
                    if (PCM::HASWELLX == cpu_family_model || PCM::BDX_DE == cpu_family_model || PCM::BDX == cpu_family_model) {
                        printMetrics(header,
                        {
                            Metric("UFS_TRANSITIONS_DOWN", getNormalizedPCUCounter(u, 0, BeforeState[socket], AfterState[socket], m) * 100., "%")
                        }, outputType);
                    }
                    break;
                }
            }

            printMetrics("S" + std::to_string(socket),
                {
                    Metric("Consumed energy units", getConsumedEnergy(BeforeState[socket], AfterState[socket]), ""),
                    Metric("Consumed Joules", getConsumedJoules(BeforeState[socket], AfterState[socket]), ""),
                    Metric("Watts", 1000. * getConsumedJoules(BeforeState[socket], AfterState[socket]) / double(AfterTime - BeforeTime), ""),
                    Metric("Thermal headroom below TjMax", AfterState[socket].getPackageThermalHeadroom(), "°C")
                }, outputType);
            printMetrics("S" + std::to_string(socket),
                {
                    Metric("Consumed DRAM energy units", getDRAMConsumedEnergy(BeforeState[socket], AfterState[socket]), ""),
                    Metric("Consumed DRAM Joules", getDRAMConsumedJoules(BeforeState[socket], AfterState[socket]), ""),
                    Metric("DRAM Watts", 1000. * getDRAMConsumedJoules(BeforeState[socket], AfterState[socket]) / double(AfterTime - BeforeTime), "")
                }, outputType);
        }
        for (auto instance = 0ULL; instance < PERF_LIMIT_REASON_TPMI_dies_data.size(); ++instance)
        {
            for (auto die = 0ULL; die < PERF_LIMIT_REASON_TPMI_dies_data[instance].size(); ++die)
            {
                std::vector<Metric> metrics;
                const auto data = PERF_LIMIT_REASON_TPMI_dies_data[instance][die];
                for (auto l = 0; l < PERF_LIMIT_REASON_TPMI::Coarse_Grained_PLR_Bit_Definition::MAX; ++l)
                {
                    metrics.push_back(Metric(PERF_LIMIT_REASON_TPMI::Coarse_Grained_PLR_Bit_Definition_Strings[l], extract_bits(data, l, l) ? true : false, ""));
                }
                printMetrics("S" + std::to_string(instance) + "D" + std::to_string(die) + " PERF LIMIT REASONS (DIE LEVEL)", metrics, outputType);
            }
        }
        for (auto instance = 0ULL; instance < PERF_LIMIT_REASON_TPMI_modules_data.size(); ++instance)
        {
            assert(PERF_LIMIT_REASON_TPMI_modules_data[instance].size());
            std::vector<std::array<uint64, 32>> coarseGrainedData, fineGrainedData;
            std::array<uint64, 32> empty;
            empty.fill(0);
            coarseGrainedData.resize(PERF_LIMIT_REASON_TPMI_modules_data[instance][0].size(), empty);
            fineGrainedData.resize(coarseGrainedData.size(), empty);

            for (auto module = 0ULL; module < PERF_LIMIT_REASON_TPMI_modules_data[instance].size(); ++module)
            {
                assert(PERF_LIMIT_REASON_TPMI_modules_data[instance][module].size() == coarseGrainedData.size());
                for (auto die = 0ULL; die < PERF_LIMIT_REASON_TPMI_modules_data[instance][module].size(); ++die)
                {
                    const auto data = PERF_LIMIT_REASON_TPMI_modules_data[instance][module][die];
                    DBG(1, "S", instance, "M", module, "D", die, " data = ", data);
                    for (auto l = 0; l < PERF_LIMIT_REASON_TPMI::Coarse_Grained_PLR_Bit_Definition::MAX; ++l)
                    {
                        if (extract_bits(data, l, l))  ++(coarseGrainedData[die][l]);
                    }
                    for (auto l = 0; l < PERF_LIMIT_REASON_TPMI::Fine_Grained_PLR_Bit_Definition::MAX_FINE; ++l)
                    {
                        if (extract_bits(data, 32 + l, 32 + l))  ++(fineGrainedData[die][l]);
                    }
                }
            }
            for (auto die = 0ULL; die < coarseGrainedData.size(); ++die)
            {
                std::vector<Metric> metrics;
                for (auto l = 0; l < PERF_LIMIT_REASON_TPMI::Coarse_Grained_PLR_Bit_Definition::MAX; ++l)
                {
                    metrics.push_back(Metric(PERF_LIMIT_REASON_TPMI::Coarse_Grained_PLR_Bit_Definition_Strings[l], coarseGrainedData[die][l], ""));
                }
                for (auto l = 0; l < PERF_LIMIT_REASON_TPMI::Fine_Grained_PLR_Bit_Definition::MAX_FINE; ++l)
                {
                    metrics.push_back(Metric(std::string(PERF_LIMIT_REASON_TPMI::Coarse_Grained_PLR_Bit_Definition_Strings[PERF_LIMIT_REASON_TPMI::Fine_Grained_PLR_Bit_Definition_Data[l].coarse_grained_mapping]) + "." +
                        PERF_LIMIT_REASON_TPMI::Fine_Grained_PLR_Bit_Definition_Data[l].name, fineGrainedData[die][l], ""));
                }
                printMetrics("S" + std::to_string(instance) + "D" + std::to_string(die) + " PERF LIMIT REASONS (#CORE MODULES)", metrics, outputType, true);
            }
        }
        if (csv)
        {
            cout << "\n";
        }
    };

    auto printLine = []()
    {
        cout << "----------------------------------------------------------------------------------------------\n";
    };

    mainLoop([&]()
    {
        if (!csv)
        {
            printLine();
            cout << flush;
        }

        const auto delay_ms = calibratedSleep(delay, sysCmd, mainLoop, m);

        AfterTime = m->getTickCount();
        for (i = 0; i < numSockets; ++i)
            AfterState[i] = m->getServerUncoreCounterState(i);

        m->getAllCounterStates(dummySystemState, afterSocketState, dummyCoreStates, false);

        if (PERF_LIMIT_REASON_TPMI_Supported)
        {
            PERF_LIMIT_REASON_TPMI_dies_data = PERF_LIMIT_REASON_TPMI::readDies();
            PERF_LIMIT_REASON_TPMI_modules_data = PERF_LIMIT_REASON_TPMI::readModules(max_pm_modules);
            PERF_LIMIT_REASON_TPMI::reset(max_pm_modules);
        }

        if (csv_header)
        {
            printAll(delay_ms, Header1);
            printAll(delay_ms, Header2);
            csv_header = false;
        }
        printAll(delay_ms, Data);

        swap(BeforeState, AfterState);
        swap(BeforeTime, AfterTime);
        swap(beforeSocketState, afterSocketState);

        if (m->isBlocked()) {
            if (!csv)
            {
                printLine();
            }
            // in case PCM was blocked after spawning child application: break monitoring loop here
            return false;
        }
        return true;
    });

    exit(EXIT_SUCCESS);
}

```

`src/pcm-raw.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2023, Intel Corporation

 /*!     \file pcm-raw.cpp
         \brief Example of using CPU counters: implements a performance counter monitoring utility with raw events interface
   */
#include <iostream>
#ifdef _MSC_VER
#define strtok_r strtok_s
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#include <signal.h>
#include <sys/time.h> // for gettimeofday()
#endif
#include <math.h>
#include <iomanip>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <string>
#include <assert.h>
#include <bitset>
#include <regex>
#include <unordered_map>
#include "cpucounters.h"
#include "utils.h"

#if PCM_SIMDJSON_AVAILABLE
#include "simdjson.h"
#endif

#ifdef _MSC_VER
#include "freegetopt/getopt.h"
#endif

#include <vector>
#define PCM_DELAY_MIN 0.015 // 15 milliseconds is practical on most modern CPUs
#define MAX_CORES 4096

using namespace std;
using namespace pcm;

void print_usage(const string & progname)
{
    cout << "\n Usage: \n " << progname
        << " --help | [delay] [options] [-- external_program [external_program_options]]\n";
    cout << "   <delay>                               => time interval to sample performance counters.\n";
    cout << "                                            If not specified, or 0, with external program given\n";
    cout << "                                            will read counters only after external program finishes\n";
    cout << " Supported <options> are: \n";
    cout << "  -h    | --help      | /h               => print this help and exit\n";
    cout << "  -silent                                => silence information output and print only measurements\n";
    cout << "  --version                              => print application version\n";
    cout << "  -e event1 [-e event2] [-e event3] ..   => list of custom events to monitor\n";
    cout << "  -pid PID | /pid PID                    => collect core metrics only for specified process ID\n";
    cout << "  -r    | --reset     | /reset           => reset PMU configuration (at your own risk)\n";
    cout << "  -csv[=file.csv]     | /csv[=file.csv]  => output compact CSV format to screen or\n"
         << "                                            to a file, in case filename is provided\n";
    cout << "  -json[=file.json]   | /json[=file.json]  => output json format to screen or\n"
         << "                                              to a file, in case filename is provided\n";
    cout << "  -out filename       | /out filename    => write all output (stdout and stderr) to specified file\n";
    cout << "  event description example: -e core/config=0x30203,name=LD_BLOCKS.STORE_FORWARD/ -e core/fixed,config=0x333/ \n";
    cout << "                             -e cha/config=0,name=UNC_CHA_CLOCKTICKS/ -e imc/fixed,name=DRAM_CLOCKS/\n";
#ifdef PCM_SIMDJSON_AVAILABLE
    cout << "                             -e NAME where the NAME is an event from https://github.com/intel/perfmon event lists\n";
    cout << "   -? | /?                               => print all events that can be monitored on the host platform along with a description\n";
    cout << "  -ep path | /ep path                    => path to event list directory (default is the current directory)\n";
#endif
    cout << "  -yc   | --yescores  | /yc              => enable specific cores to output\n";
    cout << "  -f    | /f                             => enforce flushing each line for interactive output\n";
    cout << "  -i[=number] | /i[=number]              => allow to determine number of iterations\n";
    cout << "  -tr | /tr                              => transpose output (print single event data in a row)\n";
    cout << "  -ext | /ext                            => add headers to transposed output and extend printout to match it\n";
    cout << "  -single-header | /single-header        => headers for transposed output are merged into single header\n";
    cout << "  -s  | /s                               => print a sample separator line between samples in transposed output\n";
    cout << "  -v  | /v                               => verbose mode (print additional diagnostic messages)\n";
    cout << "  -l                                     => use locale for printing values, calls -tab for readability\n";
    cout << "  -tab                                   => replace default comma separator with tab\n";
    cout << "  -el event_list.txt | /el event_list.txt  => read event list from event_list.txt file, \n";
    cout << "                                              each line represents an event,\n";
    cout << "                                              event groups are separated by a semicolon\n";
    cout << "  -edp | /edp                            => 'edp' output mode\n";
    print_help_force_rtm_abort_mode(41);
    cout << " Examples:\n";
    cout << "  " << progname << " 1                   => print counters every second without core and socket output\n";
    cout << "  " << progname << " 0.5 -csv=test.log   => twice a second save counter values to test.log in CSV format\n";
    cout << "  " << progname << " /csv 5 2>/dev/null  => one sample every 5 seconds, and discard all diagnostic output\n";
    cout << "\n";
}

bool verbose = false;
double defaultDelay = 1.0; // in seconds
TelemetryDB telemDB;

PCM::RawEventConfig initCoreConfig()
{
    return PCM::RawEventConfig{ {0,0,0,
        PCM::ExtendedCustomCoreEventDescription::invalidMsrValue(),PCM::ExtendedCustomCoreEventDescription::invalidMsrValue(), 0
        },
        "" };
}

void printEvent(const std::string & pmuName, const bool fixed, const PCM::RawEventConfig & config)
{
    cerr << "parsed " << (fixed ? "fixed " : "") << " " << pmuName << " event: \"" << hex << config.second << "\" : {" << hex <<
        "0x" << config.first[0] <<
        ", 0x" << config.first[1] <<
        ", 0x" << config.first[2] <<
        ", 0x" << config.first[3] <<
        ", 0x" << config.first[4] <<
        ", 0x" << config.first[5] <<
        "}\n" << dec;
}

void lowerCase(std::string & str)
{
    std::transform(str.begin(), str.end(), str.begin(), [](unsigned char c) {
#ifdef _MSC_VER
        return std::tolower(c, std::locale());
#else
        return std::tolower(c); // std::locale has some bad_cast issues in g++
#endif
    });
}

enum AddEventStatus
{
    OK,
    Failed,
    FailedTooManyEvents
};

bool tooManyEvents(const std::string & pmuName, const int event_pos, const std::string& fullEventStr)
{
    if (isRegisterEvent(pmuName))
    {
        return false;
    }
    PCM* m = PCM::getInstance();
    assert(m);
    const int maxCounters = (pmuName == "core" || pmuName == "atom") ? m->getMaxCustomCoreEvents() : ServerUncoreCounterState::maxCounters;
    if (event_pos >= maxCounters)
    {
        std::cerr << "ERROR: trying to add event " << fullEventStr << " at position " << event_pos << " of an event group, which exceeds the max num possible (" << maxCounters << ").\n";
        return true;
    }
    return false;
}

#ifdef PCM_SIMDJSON_AVAILABLE
using namespace simdjson;

std::vector<std::shared_ptr<simdjson::dom::parser> > JSONparsers;
std::unordered_map<std::string, simdjson::dom::object> PMUEventMapJSON;
std::vector<std::unordered_map<std::string, std::vector<std::string>>> PMUEventMapsTSV;
std::shared_ptr<simdjson::dom::element> PMURegisterDeclarations;
std::string eventFileLocationPrefix = ".";

bool parse_tsv(const string &path) {
    bool col_names_parsed = false;
    int event_name_pos = -1;
    ifstream inFile;
    string line;
    inFile.open(path);
    std::unordered_map<std::string, std::vector<std::string>> PMUEventMap;

    while (getline(inFile, line)) {
        if (line.size() == 1 && line[0] == '\n')
            continue;
        // Trim whitespaces left/right // MOVE to utils
        auto ws_left_count = 0;
        for (size_t i = 0 ; i < line.size() ; i++) {
            if (line[i] == ' ') ws_left_count++;
            else break;
        }
        auto ws_right_count = 0;
        for (size_t i = line.size() - 1 ; i > 0 ; i--) {
            if (line[i] == ' ') ws_right_count++;
            else break;
        }
        line.erase(0, ws_left_count);
        line.erase(line.size() - ws_right_count, ws_right_count);
        if (line[0] == '#')
            continue;
        if (!col_names_parsed) {
            // Consider first row as Column name row
            std::vector<std::string> col_names = split(line, '\t');
            PMUEventMap["COL_NAMES"] = col_names;
            const auto event_name_it = std::find(col_names.begin(), col_names.end(), "EventName");
            if (event_name_it == col_names.end()) {
                cerr << "ERROR: First row does not contain EventName\n";
                inFile.close();
                return false;
            }
            event_name_pos = (int)(event_name_it - col_names.begin());
            col_names_parsed = true;
            continue;
        }
        std::vector<std::string> entry = split(line, '\t');
        std::string event_name = entry[event_name_pos];
        PMUEventMap[event_name] = entry;
    }
    inFile.close();
    PMUEventMapsTSV.push_back(PMUEventMap);
    return true;
}

bool initPMUEventMap()
{
    static bool inited = false;

    if (inited == true)
    {
        return true;
    }
    inited = true;
    const auto mapfile = "mapfile.csv";
    const auto mapfilePath = eventFileLocationPrefix + "/"  + mapfile;
    const auto mapfilePathAlt = getInstallPathPrefix() + "perfmon/" + mapfile;
    std::ifstream in(mapfilePath);
    std::string line, item;

    if (!in.is_open())
    {
        in.open(mapfilePathAlt);
        if (!in.is_open())
        {
            cerr << "ERROR: File " << mapfilePath << " or " << mapfilePathAlt << " can't be open. \n";
            #ifndef _MSC_VER
            cerr << "       run 'make install' in the pcm build directory if you cloned PCM source repository recursively with submodules, or\n";
            #endif
            cerr << "       use -ep <pcm_source_directory>/perfmon option if you cloned PCM source repository recursively with submodules,\n";
            cerr << "       or run 'git clone https://github.com/intel/perfmon' to download the perfmon event repository and use -ep <perfmon_directory> option\n";
            cerr << "       or download the file from https://raw.githubusercontent.com/intel/perfmon/main/" << mapfile << " \n";
            return false;
        }
    }
    int32 FMSPos = -1;
    int32 FilenamePos = -1;
    int32 EventTypetPos = -1;
    if (std::getline(in, line))
    {
        auto header = split(line, ',');
        for (int32 i = 0; i < (int32)header.size(); ++i)
        {
            if (header[i] == "Family-model")
            {
                FMSPos = i;
            }
            else if (header[i] == "Filename")
            {
                FilenamePos = i;
            }
            else if (header[i] == "EventType")
            {
                EventTypetPos = i;
            }
        }
    }
    else
    {
        cerr << "Can't read first line from " << mapfile << " \n";
        return false;
    }
    DBG(1, FMSPos , " " , FilenamePos , " " , EventTypetPos);
    assert(FMSPos >= 0);
    assert(FilenamePos >= 0);
    assert(EventTypetPos >= 0);
    const std::string ourFMS = PCM::getInstance()->getCPUFamilyModelString();
    DBG(1, "Our FMS: " , ourFMS);
    std::multimap<std::string, std::string> eventFiles;
    cerr << "Matched event files:\n";
    while (std::getline(in, line))
    {
        auto tokens = split(line, ',');
        assert(FMSPos < (int32)tokens.size());
        assert(FilenamePos < (int32)tokens.size());
        assert(EventTypetPos < (int32)tokens.size());
        std::regex FMSRegex(tokens[FMSPos]);
        std::cmatch FMSMatch;
        if (std::regex_search(ourFMS.c_str(), FMSMatch, FMSRegex))
        {
            cerr << tokens[FMSPos] << " " << tokens[EventTypetPos] << " " << tokens[FilenamePos] << "\n";
            eventFiles.insert(std::make_pair(tokens[EventTypetPos], tokens[FilenamePos]));
        }
    }
    in.close();

    if (eventFiles.empty())
    {
        cerr << "ERROR: CPU " << ourFMS << " not found in " << mapfile << "\n";
        return false;
    }

    for (const auto& evfile : eventFiles)
    {
        std::string path;
        auto printError = [&evfile]()
        {
            cerr << "Make sure you have downloaded " << evfile.second << " from https://raw.githubusercontent.com/intel/perfmon/main/" + evfile.second + " \n";
        };
        try {

            cerr << evfile.first << " " << evfile.second << "\n";

            if (evfile.first == "core" || evfile.first == "uncore" || evfile.first == "uncore experimental")
            {
                const std::string path1 = eventFileLocationPrefix + evfile.second;
                const std::string path2 = eventFileLocationPrefix + evfile.second.substr(evfile.second.rfind('/'));
                const std::string path3 = getInstallPathPrefix() + "perfmon" + evfile.second;

                if (std::ifstream(path1).good())
                {
                    path = path1;
                }
                else if (std::ifstream(path2).good())
                {
                    path = path2;
                }
                else if (std::ifstream(path3).good())
                {
                    path = path3;
                }
                else
                {
                    std::cerr << "ERROR: Can't open event file at location " << path1 << " or " << path2 << " or " << path3 << "\n";
                    printError();
                    return false;
                }

                if (path.find(".json") != std::string::npos) {
                    JSONparsers.push_back(std::make_shared<simdjson::dom::parser>());
                    auto JSONObjects = JSONparsers.back()->load(path);
                    if (JSONObjects["Header"].error() != NO_SUCH_FIELD)
                    {
                        JSONObjects = JSONObjects["Events"];
                    }
                    for (simdjson::dom::object eventObj : JSONObjects) {
                        // cout << "Event ----------------\n";
                        const std::string EventName{eventObj["EventName"].get_c_str()};
                        if (EventName.empty())
                        {
                            cerr << "Did not find EventName in JSON object:\n";
                            for (const auto& keyValue : eventObj)
                            {
                                cout << "key: " << keyValue.key << " value: " << keyValue.value << "\n";
                            }
                        }
                        else
                        {
                            PMUEventMapJSON[EventName] = eventObj;
                        }
                    }
                } else if (path.find(".tsv") != std::string::npos) {
                    if (!parse_tsv(path))
                        return false;
                } else {
                    cerr << "ERROR: Could not determine Event file type (JSON/TSV)\n";
                    return false;
                }
            }
        }
        catch (std::exception& e)
        {
            cerr << "Error while opening and/or parsing " << path << " : " << e.what() << "\n";
            printError();
            return false;
        }
    }
    if (PMUEventMapJSON.empty() && PMUEventMapsTSV.empty())
    {
        return false;
    }

    return true;
}

class EventMap {
public:
    static bool isEvent(const std::string &eventStr) {
        if (PMUEventMapJSON.find(eventStr) != PMUEventMapJSON.end())
            return true;
        for (const auto &EventMapTSV : PMUEventMapsTSV) {
            if (EventMapTSV.find(eventStr) != EventMapTSV.end())
                return true;
        }
        return false;
    }

    static bool isField(const std::string &eventStr, const std::string event) {
        if (PMUEventMapJSON.find(eventStr) != PMUEventMapJSON.end()) {
            const auto eventObj = PMUEventMapJSON[eventStr];
            const auto unitObj = eventObj[event];
            return unitObj.error() != NO_SUCH_FIELD;
        }

        for (auto &EventMapTSV : PMUEventMapsTSV) {
            if (EventMapTSV.find(eventStr) != EventMapTSV.end()) {
                const auto &col_names = EventMapTSV["COL_NAMES"];
                const auto event_name_it = std::find(col_names.begin(), col_names.end(), event);
                if (event_name_it != col_names.end()) {
                    const size_t event_name_pos = event_name_it - col_names.begin();
                    return event_name_pos < EventMapTSV[eventStr].size();
                }
            }
        }

        return false;
    }

    static std::string getField(const std::string &eventStr, const std::string &event) {
        std::string res;

        if (PMUEventMapJSON.find(eventStr) != PMUEventMapJSON.end()) {
            const auto eventObj = PMUEventMapJSON[eventStr];
            const auto unitObj = eventObj[event];
            return std::string(unitObj.get_c_str());
        }

        for (auto &EventMapTSV : PMUEventMapsTSV) {
            if (EventMapTSV.find(eventStr) != EventMapTSV.end()) {
                const auto col_names = EventMapTSV["COL_NAMES"];
                const auto event_name_it = std::find(col_names.begin(), col_names.end(), event);
                if (event_name_it != col_names.end()) {
                    const auto event_name_pos = event_name_it - col_names.begin();
                    res = EventMapTSV[eventStr][event_name_pos];
                }
            }
        }
        return res;
    }

    static void print_event_description(const std::string &eventStr) {
        if (PMUEventMapJSON.find(eventStr) != PMUEventMapJSON.end()) {
            const auto eventObj = PMUEventMapJSON[eventStr];
            for (const auto & key : {"BriefDescription", "PublicDescription"})
                std::cout << key << " : " << eventObj[key] << "\n";
            return;
        }
    }

    static void print_event(const std::string &eventStr) {
        if (PMUEventMapJSON.find(eventStr) != PMUEventMapJSON.end()) {
            const auto eventObj = PMUEventMapJSON[eventStr];
            for (const auto & keyValue : eventObj)
                std::cout << keyValue.key << " : " << keyValue.value << "\n";
            return;
        }

        for (auto &EventMapTSV : PMUEventMapsTSV) {
            if (EventMapTSV.find(eventStr) != EventMapTSV.end()) {
                const auto &col_names = EventMapTSV["COL_NAMES"];
                const auto event = EventMapTSV[eventStr];
                if (EventMapTSV.find(eventStr) != EventMapTSV.end()) {
                    for (size_t i = 0 ; i < col_names.size() ; i++)
                        std::cout << col_names[i] << " : " << event[i] << "\n";
                    return;
                }
            }
        }
    }

    static void print_event_debug(const std::string &eventStr, const int debugLevel = 1) {
        if (PMUEventMapJSON.find(eventStr) != PMUEventMapJSON.end()) {
            const auto eventObj = PMUEventMapJSON[eventStr];
            for (const auto & keyValue : eventObj)
                DBG(debugLevel, "JSON " , keyValue.key , " : " , keyValue.value);
        }

        for (auto &EventMapTSV : PMUEventMapsTSV) {
            if (EventMapTSV.find(eventStr) != EventMapTSV.end()) {
                const auto &col_names = EventMapTSV["COL_NAMES"];
                const auto event = EventMapTSV[eventStr];
                if (EventMapTSV.find(eventStr) != EventMapTSV.end()) {
                    for (size_t i = 0 ; i < col_names.size() ; i++)
                        DBG(debugLevel, "TSV " , col_names[i] , " : " , event[i]);
                }
            }
        }
    }
};

void printAllEventDescriptions()
{
    if (initPMUEventMap() == false)
    {
        cerr << "ERROR: PMU Event map can not be initialized\n";
        return;
    }
    for (const auto& event : PMUEventMapJSON)
    {
        std::cout << event.first << "\n";
        EventMap::print_event_description(event.first);
        std::cout << "\n";
    }
}

AddEventStatus addEventFromDB(PCM::RawPMUConfigs& curPMUConfigs, string fullEventStr)
{
    if (initPMUEventMap() == false)
    {
        cerr << "ERROR: PMU Event map can not be initialized\n";
        return AddEventStatus::Failed;
    }
    DBG(2,  "Parsing event " , fullEventStr);
    DBG(2,  "size: " , fullEventStr.size());
    while (fullEventStr.empty() == false && fullEventStr.back() == ' ')
    {
        fullEventStr.resize(fullEventStr.size() - 1); // remove trailing spaces
    }
    while (fullEventStr.empty() == false && fullEventStr.front() == ' ')
    {
        fullEventStr = fullEventStr.substr(1); // remove leading spaces
    }
    if (fullEventStr.empty())
    {
        return AddEventStatus::OK;
    }
    const auto EventTokens = split(fullEventStr, ':');
    assert(!EventTokens.empty());
    auto mod = EventTokens.begin();
    ++mod;

    const auto eventStr = EventTokens[0];

    EventMap::print_event_debug(eventStr);

    DBG(2, "size: " , eventStr.size());
    PCM::RawEventConfig config = { {0,0,0,0,0}, "" };
    std::string pmuName;

    auto unsupported = [&]()
    {
        cerr << "Unsupported event modifier: " << *mod << " in event " << fullEventStr << "\n";
    };

    if (eventStr == "MSR_EVENT")
    {
        while (mod != EventTokens.end())
        {
            auto assignment = split(*mod, '=');
            for (auto& s : assignment)
            {
                lowerCase(s);
            }
            if (assignment.size() == 2 && assignment[0] == "msr")
            {
                config.first[PCM::MSREventPosition::index] = read_number(assignment[1].c_str());
            }
            else if (assignment.size() == 2 && assignment[0] == "type")
            {
                if (assignment[1] == "static")
                {
                    config.first[PCM::MSREventPosition::type] = PCM::MSRType::Static;
                } else if (assignment[1] == "freerun")
                {
                    config.first[PCM::MSREventPosition::type] = PCM::MSRType::Freerun;
                }
                else
                {
                    unsupported();
                    return AddEventStatus::Failed;
                }
            }
            else if (assignment.size() == 2 && assignment[0] == "scope")
            {
                if (assignment[1] == "package")
                {
                    pmuName = "package_msr";
                }
                else if (assignment[1] == "thread")
                {
                    pmuName = "thread_msr";
                }
                else
                {
                    unsupported();
                    return AddEventStatus::Failed;
                }
            }
            else
            {
                unsupported();
                return AddEventStatus::Failed;
            }
            ++mod;
        }
        if (pmuName.empty())
        {
            cerr << "ERROR: scope is not defined in event " << fullEventStr << ". Possible values: package, thread\n";
            return AddEventStatus::Failed;
        }

        config.second = fullEventStr;
        curPMUConfigs[pmuName].fixed.push_back(config);
        return AddEventStatus::OK;
    }

    if (!EventMap::isEvent(eventStr))
    {
        cerr << "ERROR: event " << eventStr << " could not be found in event database. Ignoring the event.\n";
        return AddEventStatus::OK;
    }

    bool fixed = false;
    static size_t offcoreEventIndex = 0;
    auto * pcm = PCM::getInstance();
    assert(pcm);

    int stepping = pcm->getCPUStepping();
    assert(stepping >= 0);
    std::string path, err_msg;

    for (; stepping >= 0; --stepping)
    {
        try
        {
            path = std::string("PMURegisterDeclarations/") + pcm->getCPUFamilyModelString(pcm->getCPUFamily(), pcm->getInternalCPUModel(), (uint32)stepping) + ".json";

            std::ifstream in(path);
            if (!in.is_open())
            {
                const auto alt_path = getInstallPathPrefix() + path;
                in.open(alt_path);
                if (!in.is_open())
                {
                    err_msg = std::string("event file ") + path + " or " + alt_path + " is not available.";
                    throw std::invalid_argument(err_msg);
                }
                path = alt_path;
            }
            in.close();
            break;
        }
        catch (std::invalid_argument & e)
        {
            std::cerr << "INFO: " << e.what() << "\n";
            path.clear();
        }
    }

    if (path.empty())
    {
        throw std::invalid_argument(err_msg);
    }

    if (PMURegisterDeclarations.get() == nullptr)
    {
        // declaration not loaded yet
        try {

            JSONparsers.push_back(std::make_shared<simdjson::dom::parser>());
            PMURegisterDeclarations = std::make_shared<simdjson::dom::element>();
            *PMURegisterDeclarations = JSONparsers.back()->load(path);
        }
        catch (std::exception& e)
        {
            cerr << "Error while opening and/or parsing " << path << " : " << e.what() << "\n";
            return AddEventStatus::Failed;
        }
    }

    static std::map<std::string, std::string> pmuNameMap = {
        {std::string("cbo"), std::string("cha")},
        {std::string("b2cmi"), std::string("m2m")},
        {std::string("upi"), std::string("xpi")},
        {std::string("upi ll"), std::string("xpi")},
        {std::string("b2upi"), std::string("m3upi")},
        {std::string("qpi"), std::string("xpi")},
        {std::string("qpi ll"), std::string("xpi")}
    };

    if (!EventMap::isField(eventStr, "Unit"))
    {
        pmuName = "core";
        config = initCoreConfig();
    }
    else
    {
        std::string unit = EventMap::getField(eventStr, "Unit");
        lowerCase(unit);
        DBG(2, eventStr , " is uncore event for unit " , unit);
        pmuName = (pmuNameMap.find(unit) == pmuNameMap.end()) ? unit : pmuNameMap[unit];
    }

    config.second = fullEventStr;

    if (1)
    {
        DBG(2, "pmuName: " , pmuName , " full event ", fullEventStr);
        std::string CounterStr = EventMap::getField(eventStr, "Counter");
        DBG(2, "Counter: " , CounterStr);
        int fixedCounter = -1;
        fixed = (pcm_sscanf(CounterStr) >> s_expect("Fixed counter ") >> fixedCounter) ? true : false;
        if (!fixed){
            bool counter_match=false;
            std::stringstream ss(CounterStr);
            // to get current event position
            int event_pos = curPMUConfigs[pmuName].programmable.size();
            // loop through counter string and check if event pos matches any counter values
            for (int i = 0; ss >> i;) {
                if(event_pos == i)
                    counter_match = true;  
                if (ss.peek() == ',')
                    ss.ignore();
            }
            if(!counter_match)
            {
                std::cerr << "ERROR: position of " << fullEventStr << " event in the command is " << event_pos<<" but the supported counters are "<<CounterStr<<"\n";
                return AddEventStatus::Failed;
            }
            if (tooManyEvents(pmuName, event_pos, fullEventStr))
            {
                return AddEventStatus::FailedTooManyEvents;
            }
        }
        bool offcore = false;
        if (EventMap::isField(eventStr, "Offcore"))
        {
            const std::string offcoreStr = EventMap::getField(eventStr, "Offcore");
            offcore = (offcoreStr == "1");
        }
        if (pmuName == "core" && curPMUConfigs[pmuName].programmable.empty() && fixed == false)
        {
            // on first programmable core PMU event
            offcoreEventIndex = 0; // reset offcore event index
        }

        try {
            auto setConfig = [](PCM::RawEventConfig & config, const simdjson::dom::object& fieldDescriptionObj, const uint64 value, const int64_t position)
            {
                const auto cfg = uint64_t(fieldDescriptionObj["Config"]);
                if (cfg >= config.first.size()) throw std::runtime_error("Config field value is out of bounds");
                const auto width = uint64_t(fieldDescriptionObj["Width"]);
                assert(width <= 64);
                config.first[cfg] = insertBits(config.first[cfg], value, position, width);
            };
            auto PMUObj = (*PMURegisterDeclarations)[pmuName];
            if (PMUObj.error() == NO_SUCH_FIELD)
            {
                cerr << "ERROR: PMU \"" << pmuName << "\" not found for event " << fullEventStr << " in " << path << ", ignoring the event.\n";
                return AddEventStatus::OK;
            }
            simdjson::dom::object PMUDeclObj;
            if (fixed)
            {
                PMUDeclObj = (*PMURegisterDeclarations)[pmuName][std::string("fixed") + std::to_string(fixedCounter)].get_object();
            }
            else
            {
                PMUDeclObj = (*PMURegisterDeclarations)[pmuName]["programmable"].get_object();
            }
            auto& myPMUConfigs = fixed ? curPMUConfigs[pmuName].fixed : curPMUConfigs[pmuName].programmable;
            simdjson::dom::object MSRObject;
            auto setMSRValue = [&setConfig,&MSRObject,&config,&myPMUConfigs](const string & valueStr)
            {
                const auto value = read_number(valueStr.c_str());
                const auto position = int64_t(MSRObject["Position"]);
                // update the first event
                setConfig(myPMUConfigs.empty() ? config : myPMUConfigs.front(), MSRObject, value, position);
                // update the current as well for display
                setConfig(config, MSRObject, value, position);
            };
            for (const auto & registerKeyValue : PMUDeclObj)
            {
                DBG(2, "Setting " , registerKeyValue.key , " : " , registerKeyValue.value);
                simdjson::dom::object fieldDescriptionObj = registerKeyValue.value;
                const std::string fieldNameStr{ registerKeyValue.key.begin(), registerKeyValue.key.end() };
                if (fieldNameStr == "MSRIndex")
                {
                    string fieldValueStr = EventMap::getField(eventStr, fieldNameStr);
                    DBG(2, "MSR field " , fieldNameStr , " value is " , fieldValueStr , " (" , read_number(fieldValueStr.c_str()) , ") offcore=" , offcore);;
                    lowerCase(fieldValueStr);
                    if (fieldValueStr == "0" || fieldValueStr == "0x00")
                    {
                        continue;
                    }
                    auto MSRIndexStr = fieldValueStr;
                    if (offcore)
                    {
                        const auto MSRIndexes = split(MSRIndexStr, ',');
                        if (offcoreEventIndex >= MSRIndexes.size())
                        {
                            std::cerr << "ERROR: too many offcore events specified (max is " << MSRIndexes.size() << "). MSRIndex string:" << MSRIndexStr << " Ignoring " << fullEventStr << " event\n";
                            return AddEventStatus::FailedTooManyEvents;
                        }
                        MSRIndexStr = MSRIndexes[offcoreEventIndex];
                    }
                    DBG(2, " MSR field " , fieldNameStr , " value is " , MSRIndexStr , " (" , read_number(MSRIndexStr.c_str()) , ") offcore=" , offcore);
                    MSRObject = registerKeyValue.value[MSRIndexStr];
                    const string msrValueStr = EventMap::getField(eventStr, "MSRValue");
                    setMSRValue(msrValueStr);
                    continue;
                }
                const int64_t position = int64_t(fieldDescriptionObj["Position"]);
                if (position == -1)
                {
                    continue; // field ignored
                }
                if (!EventMap::isField(eventStr, fieldNameStr))
                {
                    DBG(2, fieldNameStr , " not found");
                    if (fieldDescriptionObj["DefaultValue"].error() == NO_SUCH_FIELD)
                    {
                        cerr << "ERROR: DefaultValue not provided for field \"" << fieldNameStr << "\" in " << path << "\n";
                        return AddEventStatus::Failed;
                    }
                    else
                    {
                        const auto cfg = uint64_t(fieldDescriptionObj["Config"]);
                        if (cfg >= config.first.size()) throw std::runtime_error("Config field value is out of bounds");
                        config.first[cfg] |= uint64_t(fieldDescriptionObj["DefaultValue"]) << position;
                    }
                }
                else
                {
                    auto getFieldValueArray = [&eventStr](const std::string & fieldNameStr)
                    {
                        std::string fieldValueStr = EventMap::getField(eventStr, fieldNameStr);
                        // remove all double quote characters from the fieldValueStr string
                        fieldValueStr.erase(std::remove(fieldValueStr.begin(), fieldValueStr.end(), '\"'), fieldValueStr.end());
                        return split(fieldValueStr, ',');
                    };
                    const auto fieldValueArray = getFieldValueArray(fieldNameStr);
                    // print all fieldValueArray values
                    DBG(2, " field " , fieldNameStr , " offcore=" , offcore, " size=" , fieldValueArray.size(), " values:");
                    for (const auto& fieldValue : fieldValueArray)
                    {
                        DBG(2, "Field value: " , fieldValue, " (" , read_number(fieldValue.c_str()) , ")");
                    }
                    assert(fieldValueArray.size() >= 1);
                    auto setOffcoreConfig = [&](const std::string & secondField)
                    {
                        const auto offcoreCodes = fieldValueArray;
                        std::string fieldValueStr{};
                        DBG(2, "offcoreEventIndex: " , offcoreEventIndex);
                        if (offcoreEventIndex >= offcoreCodes.size())
                        {
                            const auto adjustedMaxSize = getFieldValueArray(secondField).size();
                            if (offcoreEventIndex >= adjustedMaxSize)
                            {
                                std::cerr << "ERROR: too many offcore events specified (max is " << adjustedMaxSize << "). " << fieldNameStr << " string: " << EventMap::getField(eventStr, fieldNameStr)
                                    << " for " << fullEventStr << " event\n";
                                return AddEventStatus::FailedTooManyEvents;
                            }
                            fieldValueStr = offcoreCodes[0];
                        }
                        else
                        {
                            fieldValueStr = offcoreCodes[offcoreEventIndex];
                        }
                        assert(!fieldValueStr.empty());
                        DBG(2, "Setting field " , fieldNameStr , " value is " , fieldValueStr , " (" , read_number(fieldValueStr.c_str()) , ")");
                        setConfig(config, fieldDescriptionObj, read_number(fieldValueStr.c_str()), position);
                        return AddEventStatus::OK;
                    };
                    if (offcore && fieldNameStr == "EventCode")
                    {
                        const auto status = setOffcoreConfig("UMask");
                        if (status != AddEventStatus::OK)
                        {
                            return status;
                        }
                    } else if (offcore && fieldNameStr == "UMask")
                    {
                        const auto status = setOffcoreConfig("EventCode");
                        if (status != AddEventStatus::OK)
                        {
                            return status;
                        }
                    }
                    else
                    {
                        if (fieldValueArray.size() > 1)
                        {
                            std::cout << "WARNING: multiple field values specified for field " << fieldNameStr << " for event " << fullEventStr << ": " << EventMap::getField(eventStr, fieldNameStr)
                               << ", choosing the first one...\n";
                        }
                        DBG(2, "Setting field " , fieldNameStr , " value is " , fieldValueArray[0] , " (" , read_number(fieldValueArray[0].c_str()) , ")");
                        setConfig(config, fieldDescriptionObj, read_number(fieldValueArray[0].c_str()), position);
                    }
                }
            }

            auto setField = [&PMUDeclObj, &config, &setConfig](const char* field, const uint64 value)
            {
                const auto pos = int64_t(PMUDeclObj[field]["Position"]);
                setConfig(config, PMUDeclObj[field], value, pos);
            };

            std::regex CounterMaskRegex("c(0x[0-9a-fA-F]+|[[:digit:]]+)");
            std::regex UmaskRegex("u(0x[0-9a-fA-F]+|[[:digit:]]+)");
            std::regex EdgeDetectRegex("e(0x[0-9a-fA-F]+|[[:digit:]]+)");
            std::regex AnyThreadRegex("amt(0x[0-9a-fA-F]+|[[:digit:]]+)");
            std::regex InvertRegex("i(0x[0-9a-fA-F]+|[[:digit:]]+)");
            while (mod != EventTokens.end())
            {
                const auto assignment = split(*mod, '=');
                if (*mod == "SUP")
                {
                    setField("User", 0);
                    setField("OS", 1);
                }
                else if (*mod == "USER")
                {
                    setField("User", 1);
                    setField("OS", 0);
                }
                else if (*mod == "tx")
                {
                    setField("InTX", 1);
                }
                else if (*mod == "cp")
                {
                    setField("InTXCheckpointed", 1);
                }
                else if (*mod == "percore")
                {
                    unsupported();
                    return AddEventStatus::OK;
                }
                else if (*mod == "perf_metrics")
                {
                    setField("PerfMetrics", 1);
                }
                else if (std::regex_match(mod->c_str(), CounterMaskRegex))
                {
                    // Counter Mask modifier
                    const std::string CounterMaskStr{ mod->begin() + 1, mod->end() };
                    setField("CounterMask", read_number(CounterMaskStr.c_str()));
                }
                else if (std::regex_match(mod->c_str(), EdgeDetectRegex))
                {
                    // Edge Detect modifier
                    const std::string Str{ mod->begin() + 1, mod->end() };
                    setField("EdgeDetect", read_number(Str.c_str()));
                }
                else if (std::regex_match(mod->c_str(), AnyThreadRegex))
                {
                    // AnyThread modifier
                    const std::string Str{ mod->begin() + 1, mod->end() };
                    setField("AnyThread", read_number(Str.c_str()));
                }
                else if (std::regex_match(mod->c_str(), InvertRegex))
                {
                    // Invert modifier
                    const std::string Str{ mod->begin() + 1, mod->end() };
                    setField("Invert", read_number(Str.c_str()));
                }
                else if (std::regex_match(mod->c_str(), UmaskRegex))
                {
                    // UMask modifier
                    const std::string Str{ mod->begin() + 1, mod->end() };
                    setField("UMask", read_number(Str.c_str()));
                }
                else if (assignment.size() == 2 && assignment[0] == "request")
                {
                    unsupported();
                    return AddEventStatus::OK;
                }
                else if (assignment.size() == 2 && assignment[0] == "response")
                {
                    unsupported();
                    return AddEventStatus::OK;
                }
                else if (assignment.size() == 2 && assignment[0] == "filter0")
                {
                    setField("Filter0", read_number(assignment[1].c_str()));
                }
                else if (assignment.size() == 2 && assignment[0] == "filter1")
                {
                    setField("Filter1", read_number(assignment[1].c_str()));
                }
                else if (assignment.size() == 2 && assignment[0] == "opc")
                {
                    setField("OPC", read_number(assignment[1].c_str()));
                }
                else if (assignment.size() == 2 && assignment[0] == "nc")
                {
                    setField("NC", read_number(assignment[1].c_str()));
                }
                else if (assignment.size() == 2 && assignment[0] == "isoc")
                {
                    setField("ISOC", read_number(assignment[1].c_str()));
                }
                else if (assignment.size() == 2 && assignment[0] == "state")
                {
                    setField("State", read_number(assignment[1].c_str()));
                }
                else if (assignment.size() == 2 && assignment[0] == "t")
                {
                    setField("Threshold", read_number(assignment[1].c_str()));
                }
                else if (assignment.size() == 2 && assignment[0] == "tid")
                {
                    setField("TIDEnable", 1);
                    setField("TID", read_number(assignment[1].c_str()));
                }
                else if (assignment.size() == 2 && assignment[0] == "umask_ext")
                {
                    setField("UMaskExt", read_number(assignment[1].c_str()));
                }
                else if (assignment.size() == 2 && assignment[0] == "ocr_msr_val")
                {
                    setMSRValue(assignment[1]);
                }
                else
                {
                    unsupported();
                    return AddEventStatus::Failed;
                }
                ++mod;
            }
            if (offcore)
            {
                ++offcoreEventIndex;
            }
            myPMUConfigs.push_back(config);
        }
        catch (std::exception& e)
        {
            cerr << "Error while setting a register field for event " << fullEventStr << " : " << e.what() << "\n";
            EventMap::print_event(eventStr);
            return AddEventStatus::Failed;
        }
    }

    printEvent(pmuName, fixed, config);

    return AddEventStatus::OK;
}

#endif

AddEventStatus addEvent(PCM::RawPMUConfigs & curPMUConfigs, string eventStr)
{
    if (eventStr.empty())
    {
        return AddEventStatus::OK;
    }
#ifdef PCM_SIMDJSON_AVAILABLE
    if (eventStr.find('/') == string::npos)
    {
        return addEventFromDB(curPMUConfigs, eventStr);
    }
#endif
    PCM::RawEventConfig config = { {0,0,0,0,0}, "" };
    const auto typeConfig = split(eventStr, '/');
    if (typeConfig.size() < 2)
    {
#ifndef PCM_SIMDJSON_AVAILABLE
        cerr << "WARNING: pcm-raw is compiled without simdjson library (check cmake output). Collecting events by names from json event lists is not supported.\n";
#endif
        cerr << "ERROR: wrong syntax in event description \"" << eventStr << "\"\n";
        return AddEventStatus::Failed;
    }
    auto pmuName = typeConfig[0];
    if (pmuName.empty())
    {
        pmuName = "core";
    }
    const auto configStr = typeConfig[1];
    if (configStr.empty())
    {
        cerr << "ERROR: empty config description in event description \"" << eventStr << "\"\n";
        return AddEventStatus::Failed;
    }
    if (pmuName == "core" || pmuName == "atom")
    {
        config = initCoreConfig();
    }
    const auto configArray = split(configStr, ',');
    bool fixed = false;
    std::string lookup;
    auto pmtAddRecord = [&lookup, &pmuName, &config](const std::vector<TelemetryDB::PMTRecord> & records, const bool first = false) -> AddEventStatus
    {
        if (pmuName == "pmt")
        {
                if (records.empty())
                {
                    cerr << "ERROR: lookup \"" << lookup << "\" not found in PMT telemetry database\n";
                    return AddEventStatus::Failed;
                }
                if (records.size() > 1 && first == false)
                {
                    cerr << "ERROR: lookup \"" << lookup << "\" is ambiguous in PMT telemetry database\n\n";
                    for (const auto & record : records)
                    {
                        cerr << "  ";
                        record.print(cerr);
                        cerr << "\n";
                    }
                    cerr << "Alternatively use lookupf or ilookupf to select the first record in the list.\n";
                    return AddEventStatus::Failed;
                }
                config.second = records[0].fullName;
                assert(records.size() >= 1);
                config.first[PCM::PMTEventPosition::UID] = records[0].uid;
                config.first[PCM::PMTEventPosition::offset] = records[0].qWordOffset;
                config.first[PCM::PMTEventPosition::type] = (records[0].sampleType == "Snapshot") ? PCM::MSRType::Static : PCM::MSRType::Freerun;
                config.first[PCM::PMTEventPosition::lsb] = records[0].lsb;
                config.first[PCM::PMTEventPosition::msb] = records[0].msb;
        }
        return AddEventStatus::OK;
    };
    for (const auto & item : configArray)
    {
        if (match(item, "config=", &config.first[0]))
        {
            // matched and initialized config 0
        }
        else if (match(item, "config1=", &config.first[1]))
        {
            // matched and initialized config 1
        }
        else if (match(item, "config2=", &config.first[2]))
        {
            // matched and initialized config 2
        }
        else if (match(item, "config3=", &config.first[3]))
        {
            // matched and initialized config 3
        }
        else if (match(item, "config4=", &config.first[4]))
        {
            // matched and initialized config 4
        }
        else if (match(item, "config5=", &config.first[5]))
        {
            // matched and initialized config 5
        }
        else if (match(item, "width=", &config.first[PCM::PCICFGEventPosition::width]))
        {
            // matched and initialized config 5 (width)
        }
        else if (pcm_sscanf(item) >> s_expect("name=") >> setw(255) >> config.second)
        {
            // matched and initialized name
            if (check_for_injections(config.second))
                return AddEventStatus::Failed;
        }
        else if (pcm_sscanf(item) >> s_expect("lookup=") >> setw(255) >> lookup)
        {
            if (pmtAddRecord(telemDB.lookup(lookup)) != AddEventStatus::OK)
                return AddEventStatus::Failed;
        }
        else if (pcm_sscanf(item) >> s_expect("ilookup=") >> setw(255) >> lookup)
        {
            if (pmtAddRecord(telemDB.ilookup(lookup)) != AddEventStatus::OK)
                return AddEventStatus::Failed;
        }
        else if (pcm_sscanf(item) >> s_expect("lookupf=") >> setw(255) >> lookup)
        {
            if (pmtAddRecord(telemDB.lookup(lookup), true) != AddEventStatus::OK)
                return AddEventStatus::Failed;
        }
        else if (pcm_sscanf(item) >> s_expect("ilookupf=") >> setw(255) >> lookup)
        {
            if (pmtAddRecord(telemDB.ilookup(lookup), true) != AddEventStatus::OK)
                return AddEventStatus::Failed;
        }
        else if (item == "fixed")
        {
            fixed = true;
        }
        else
        {
            cerr << "ERROR: unknown token " << item << " in event description \"" << eventStr << "\"\n";
            return AddEventStatus::Failed;
        }
    }
    printEvent(pmuName, fixed, config);
    if (fixed == false && tooManyEvents(pmuName, curPMUConfigs[pmuName].programmable.size(), eventStr))
    {
        return AddEventStatus::FailedTooManyEvents;
    }
    if (fixed)
        curPMUConfigs[pmuName].fixed.push_back(config);
    else
        curPMUConfigs[pmuName].programmable.push_back(config);
    return AddEventStatus::OK;
}

bool addEvents(std::vector<PCM::RawPMUConfigs>& PMUConfigs, string fn)
{
    std::ifstream in(fn);
    std::string line, item;

    if (!in.is_open())
    {
        cerr << "ERROR: File " << fn << " can't be open. \n";
        return false;
    }
    PCM::RawPMUConfigs curConfig;
    auto doFinishGroup = [&curConfig, &PMUConfigs]()
    {
        if (!curConfig.empty())
        {
            cerr << "Adding new group \n";
            PMUConfigs.push_back(curConfig);
            curConfig.clear();
        }
    };
    while (std::getline(in, line))
    {
        if (line.empty() || line[0] == '#')
        {
            continue;
        }
        const auto last = line[line.size() - 1];
        bool finishGroup = false;
        if (last == ',')
        {
            line.resize(line.size() - 1);
        }
        else if (last == ';')
        {
            line.resize(line.size() - 1);
            finishGroup = true;
        }
        const auto status = addEvent(curConfig, line);
        switch (status)
        {
        case AddEventStatus::Failed:
            return false;
        case AddEventStatus::FailedTooManyEvents:
            cerr << "Failed to add event due to a too large group. Trying to split the event group.\n";
            doFinishGroup();
            if (addEvent(curConfig, line) != AddEventStatus::OK)
            {
                return false;
            }
            break;
        case AddEventStatus::OK:
            // all is fine
            break;
        }
        if (finishGroup)
        {
            doFinishGroup();
        }
    }
    in.close();
    doFinishGroup();
    return true;
}

bool show_partial_core_output = false;
bitset<MAX_CORES> ycores;
bool flushLine = false;
bool transpose = false;
bool extendPrintout = false;
bool singleHeader = false;
std::string separator = ",";
const std::string jsonSeparator = "\":";
bool sampleSeparator = false;
bool outputToJson = false;

struct PrintOffset {
    const std::string entry;
    int start;
    int end;
};

std::vector<PrintOffset> printOffsets;
std::vector<std::string> printedBlocks;

int getPrintOffsetIdx(const std::string &value) {
    for (size_t i = 0 ; i < printOffsets.size() ; i++) {
        if (printOffsets[i].entry == value)
            return (int)i;
    }
    return -1;
}

void printNewLine(const CsvOutputType outputType) {
    if (outputType == Data)
        cout << "\n";
    else if (outputType == Json)
        cout << "}\n";
}

void printRowBeginCSV(const std::string & EventName, const CoreCounterState & BeforeState, const CoreCounterState & AfterState, PCM* m)
{
    printDateForCSV(CsvOutputType::Data, separator);
    cout << EventName << separator << (1000ULL * getInvariantTSC(BeforeState, AfterState)) / m->getNominalFrequency() << separator << getInvariantTSC(BeforeState, AfterState);
}

void printRowBeginJson(const std::string & EventName, const CoreCounterState & BeforeState, const CoreCounterState & AfterState, PCM* m)
{
    cout << "{\"";
    printDateForJson(separator, jsonSeparator);
    cout << "Event" << jsonSeparator << "\"" << EventName << "\"" << separator << "ms" << jsonSeparator << (1000ULL * getInvariantTSC(BeforeState, AfterState)) / m->getNominalFrequency()
        << separator << "InvariantTSC" << jsonSeparator << getInvariantTSC(BeforeState, AfterState);
}

void printRowBegin(const std::string & EventName, const CoreCounterState & BeforeState, const CoreCounterState & AfterState, PCM* m, const CsvOutputType outputType, PrintOffset& printOffset) {
    if (outputType == Data) {
        printRowBeginCSV(EventName, BeforeState, AfterState, m);
        for (int i = 0 ; i < printOffset.start ; i++)
            std::cout << separator;
    } else if (outputType == Json) {
        printRowBeginJson(EventName, BeforeState, AfterState, m);
    }
}

template <class MetricFunc>
void printRow(const std::string & EventName, MetricFunc metricFunc, const std::vector<CoreCounterState>& BeforeState, const std::vector<CoreCounterState>& AfterState, PCM* m,
    const CsvOutputType outputType, PrintOffset& printOffset, const pcm::TopologyEntry::CoreType & coreType, const std::string & pmuType)
{
    printRowBegin(EventName, BeforeState[0], AfterState[0], m, outputType, printOffset);

    for (uint32 core = 0; core < m->getNumCores(); ++core)
    {
        if (extendPrintout && m->isHybrid() && m->getCoreType(core) != coreType)
        {
            continue;
        }
        if (!(show_partial_core_output && ycores.test(core) == false))
        {
            if (outputType == Header1) {
                cout << separator << "SKT" << m->getSocketId(core) << "CORE" << core;
                printOffset.end++;
            }
            else if (outputType == Header2)
                cout << separator << pmuType;
            else if (outputType == Data) {
                cout << separator;
                if (m->isHybrid() == false || m->getCoreType(core) == coreType) {
                    cout << metricFunc(BeforeState[core], AfterState[core]);
                }
            }
            else if (outputType == Header21) {
                cout << separator << pmuType << "_SKT" << m->getSocketId(core) << "_CORE" << core;
                printOffset.end++;
            }
            else if (outputType == Json) {
                cout << separator << pmuType << "_SKT" << m->getSocketId(core) << "_CORE" << core <<
                    jsonSeparator;
                if (m->isHybrid() == false || m->getCoreType(core) == coreType) {
                    cout << metricFunc(BeforeState[core], AfterState[core]);
                }
            } else
                assert(!"unknown output type");
        }
    }

    printNewLine(outputType);
};

typedef uint64 (*UncoreMetricFunc)(const uint32 u, const uint32 i,  const ServerUncoreCounterState& before, const ServerUncoreCounterState& after);
typedef uint64(*UncoreFixedMetricFunc)(const uint32 u, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after);

uint64 nullFixedMetricFunc(const uint32, const ServerUncoreCounterState&, const ServerUncoreCounterState&)
{
    return ~0ULL;
}

const char* fixedCoreEventNames[] = { "InstructionsRetired" , "Cycles", "RefCycles", "TopDownSlots" };
const char* topdownEventNames[] = { "PERF_METRICS.FRONTEND_BOUND" , "PERF_METRICS.BAD_SPECULATION", "PERF_METRICS.BACKEND_BOUND", "PERF_METRICS.RETIRING",
                                    "PERF_METRICS.HEAVY_OPERATIONS", "PERF_METRICS.BRANCH_MISPREDICTS", "PERF_METRICS.FETCH_LATENCY", "PERF_METRICS.MEMORY_BOUND"};
constexpr uint32 PerfMetricsConfig = 2;
constexpr uint64 PerfMetricsMask = 1ULL;
constexpr uint64 maxPerfMetricsValue = 255ULL;

const char * getTypeString(uint64 typeID)
{
    switch (typeID)
    {
    case PCM::MSRType::Freerun:
        return "freerun";
    case PCM::MSRType::Static:
        return "static";
    }
    return "unknownType";
}

std::string getMSREventString(const uint64 & index, const std::string & type, const PCM::MSRType & msrType)
{
    std::stringstream c;
    c << type << "/MSR 0x" << std::hex << index << "/" << getTypeString(msrType);
    return c.str();
}

std::string getTPMIEventString(const PCM::RawEventEncoding & eventEnc, const std::string& type)
{
    std::stringstream c;
    c << type << "/TPMI_ID 0x" << std::hex << eventEnc[PCM::TPMIEventPosition::ID]
              << "/offset 0x" << eventEnc[PCM::TPMIEventPosition::offset] << "/"
        << getTypeString(eventEnc[PCM::TPMIEventPosition::type]);
    return c.str();
}

std::string getPCICFGEventString(const PCM::RawEventEncoding & eventEnc, const std::string& type)
{
    std::stringstream c;
    c << type << "/deviceID 0x" << std::hex << eventEnc[PCM::PCICFGEventPosition::deviceID]
              << "/offset 0x" << eventEnc[PCM::PCICFGEventPosition::offset]
              << "/width 0x" << eventEnc[PCM::PCICFGEventPosition::width] << "/"
        << getTypeString(eventEnc[PCM::PCICFGEventPosition::type]);
    return c.str();
}

std::string getMMIOEventString(const PCM::RawEventEncoding& eventEnc, const std::string& type)
{
    std::stringstream c;
    c << type << "/deviceID 0x" << std::hex <<
                          eventEnc[PCM::MMIOEventPosition::deviceID] <<
                 "/offset 0x" << eventEnc[PCM::MMIOEventPosition::offset] <<
                 "/membar_bits1 0x" << eventEnc[PCM::MMIOEventPosition::membar_bits1] <<
                 "/membar_bits2 0x" << eventEnc[PCM::MMIOEventPosition::membar_bits2] <<
                 "/width 0x" << eventEnc[PCM::MMIOEventPosition::width] <<
                 "/" << getTypeString(eventEnc[PCM::MMIOEventPosition::type]);
    return c.str();
}

std::string getPMTEventString(const PCM::RawEventEncoding& eventEnc, const std::string& type)
{
    std::stringstream c;
    c << type << "/UID 0x" << std::hex <<
                          eventEnc[PCM::PMTEventPosition::UID] <<
                 "/offset 0x" << eventEnc[PCM::PMTEventPosition::offset] <<
                 "/lsb 0x" << eventEnc[PCM::PMTEventPosition::lsb] <<
                 "/msb 0x" << eventEnc[PCM::PMTEventPosition::msb] <<
                 "/" << getTypeString(eventEnc[PCM::PMTEventPosition::type]);
    return c.str();
}

typedef std::string(*getEventStringFunc)(const PCM::RawEventEncoding& eventEnc, const std::string& type);
typedef std::vector<uint64>(getEventFunc)(const PCM::RawEventEncoding& eventEnc, const SystemCounterState& before, const SystemCounterState& after);

enum MSRScope
{
    Thread,
    Package
};

uint32 numTMAEvents(PCM* m)
{
    return (m->isHWTMAL2Supported() ? 8 : 4);
}

uint32 pmu_type = PCM::INVALID_PMU_ID;

void printTransposed(const PCM::RawPMUConfigs& curPMUConfigs,
    PCM* m,
    SystemCounterState& SysBeforeState, SystemCounterState& SysAfterState,
    vector<CoreCounterState>& BeforeState, vector<CoreCounterState>& AfterState,
    vector<ServerUncoreCounterState>& BeforeUncoreState, vector<ServerUncoreCounterState>& AfterUncoreState,
    vector<SocketCounterState>& BeforeSocketState, vector<SocketCounterState>& AfterSocketState,
    const CsvOutputType outputType,
    const bool& isLastGroup)
{
        const bool is_header = (outputType == Header1 || outputType == Header2 || outputType == Header21);
        for (const auto & typeEvents : curPMUConfigs)
        {
            bool is_header_printed = false;
            const auto& type = typeEvents.first;
            const auto& events = typeEvents.second.programmable;
            const auto& fixedEvents = typeEvents.second.fixed;

            PrintOffset printOffset{type, 0, 0};
            const auto print_idx = getPrintOffsetIdx(type);

            if (outputType == Header1 || outputType == Header21) {
                if (print_idx != -1)
                    continue; // header already printed
                else {
                    printOffset.start = (printOffsets.empty()) ? 0 : printOffsets.back().end;
                    printOffset.end = printOffset.start;
                }
            } else if (outputType == Header2) {
                if (std::find(printedBlocks.begin(), printedBlocks.end(), type) != printedBlocks.end())
                    continue;
                printedBlocks.push_back(type);
            } else if (outputType == Data) {
                assert(printOffsets.empty() || print_idx >= 0);
                printOffset.start = (printOffsets.empty()) ? 0 : printOffsets[print_idx].start;
                printOffset.end = (printOffsets.empty()) ? 0 : printOffsets[print_idx].end;
            }

            auto printUncoreRows = [&](UncoreMetricFunc metricFunc, const uint32 maxUnit, const std::string &miscName = std::string("<invalid-fixed-event-name>"), UncoreFixedMetricFunc fixedMetricFunc = nullFixedMetricFunc)
            {
                if (fixedEvents.size())
                {
                    printRowBegin(miscName, BeforeState[0], AfterState[0], m, outputType, printOffset);

                    for (uint32 s = 0; s < m->getNumSockets(); ++s)
                    {
                        for (uint32 u = 0; u < maxUnit; ++u)
                        {
                            if (outputType == Header1)
                            {
                                cout << separator << "SKT" << s << miscName << u;
                                printOffset.end++;
                            }
                            else if (outputType == Header2)
                                cout << separator << miscName ;
                            else if (outputType == Data)
                                cout << separator << fixedMetricFunc(u, BeforeUncoreState[s], AfterUncoreState[s]);
                            else if (outputType == Header21) {
                                cout << separator << type << "_SKT" << s << "_" << miscName << u;
                                printOffset.end++;
                            } else if (outputType == Json) {
                                cout << separator << type << "_SKT" << s << "_" << miscName << u
                                    << jsonSeparator << fixedMetricFunc(u, BeforeUncoreState[s], AfterUncoreState[s]);
                            } else
                                assert(!"unknown output type");
                        }
                    }

                    if (is_header)
                        is_header_printed = true;

                    printNewLine(outputType);
                }
                uint32 i = 0;
                for (auto& event : events)
                {
                    const std::string name = (event.second.empty()) ? (type + "Event" + std::to_string(i)) : event.second;

                    if (is_header && is_header_printed)
                        break;

                    printRowBegin(name, BeforeState[0], AfterState[0], m, outputType, printOffset);

                    for (uint32 s = 0; s < m->getNumSockets(); ++s)
                    {
                        for (uint32 u = 0; u < maxUnit; ++u)
                        {
                            if (outputType == Header1)
                            {
                                cout  << separator << "SKT_" << s << miscName << u;
                                printOffset.end++;
                            }
                            else if (outputType == Header2)
                            {
                                cout << separator << miscName ;
                            }
                            else if (outputType == Data)
                            {
                                assert(metricFunc);
                                cout << separator << metricFunc(u, i, BeforeUncoreState[s], AfterUncoreState[s]);
                            }
                            else if (outputType == Header21)
                            {
                                cout << separator << type << "_SKT" << s << "_" << miscName << u;
                                printOffset.end++;
                            }
                            else if (outputType == Json)
                            {
                                assert(metricFunc);
                                cout << separator << type << "_SKT" << s << "_" << miscName << u
                                    << jsonSeparator << metricFunc(u, i, BeforeUncoreState[s], AfterUncoreState[s]);
                            }
                            else
                            {
                                assert(!"unknown output type");
                            }
                        }
                    }

                    if (is_header)
                        is_header_printed = true;

                    ++i;
                    printNewLine(outputType);
                }
            };
            auto printMSRRows = [&](const MSRScope& scope)
            {
                auto printMSR = [&](const PCM::RawEventConfig& event) -> bool
                {
                    const auto index = event.first[PCM::MSREventPosition::index];
                    const auto msrType = (PCM::MSRType)event.first[PCM::MSREventPosition::type];
                    const std::string name = (event.second.empty()) ? getMSREventString(index, type, msrType) : event.second;

                    if (is_header && is_header_printed)
                        return false;

                    printRowBegin(name, BeforeState[0], AfterState[0], m, outputType, printOffset);

                    switch (scope)
                    {
                    case MSRScope::Package:
                        for (uint32 s = 0; s < m->getNumSockets(); ++s)
                        {
                            if (outputType == Header1)
                            {
                                cout << separator << "SKT" << s ;
                                printOffset.end++;
                            }
                            else if (outputType == Header2)
                            {
                                cout << separator << type ;
                            }
                            else if (outputType == Data)
                            {
                                cout << separator << getMSREvent(index, msrType, BeforeSocketState[s], AfterSocketState[s]);
                            }
                            else if (outputType == Header21)
                            {
                                cout << separator << type << "_SKT" << s ;
                                printOffset.end++;
                            }
                            else if (outputType == Json) {
                                cout << separator << type << "_SKT" << s
                                    << jsonSeparator << getMSREvent(index, msrType, BeforeSocketState[s], AfterSocketState[s]);
                            }
                            else
                            {
                                assert(!"unknown output type");
                            }
                        }
                        break;
                    case MSRScope::Thread:
                        for (uint32 core = 0; core < m->getNumCores(); ++core)
                        {
                            if (outputType == Header1)
                            {
                                cout << separator << "SKT" << m->getSocketId(core) << "CORE" << core;
                                printOffset.end++;
                            }
                            else if (outputType == Header2)
                            {
                                cout << separator << type ;
                            }
                            else if (outputType == Data)
                            {
                                cout << separator << getMSREvent(index, msrType, BeforeState[core], AfterState[core]);
                            }
                            else if (outputType == Header21)
                            {
                                cout << separator << type << "_SKT" << m->getSocketId(core) << "_CORE" << core;
                                printOffset.end++;
                            }
                            else if (outputType == Json) {
                                cout << separator << type << "_SKT" << m->getSocketId(core) << "_CORE" << core
                                    << jsonSeparator << getMSREvent(index, msrType, BeforeState[core], AfterState[core]);
                            }
                            else
                            {
                                assert(!"unknown output type");
                            }
                        }
                        break;
                    }

                    if (is_header)
                        is_header_printed = true;

                    printNewLine(outputType);

                    return true;
                };
                for (const auto& event : events)
                {
                    if (!printMSR(event))
                    {
                        break;
                    }
                }
                for (const auto& event : fixedEvents)
                {
                    if (!printMSR(event))
                    {
                        break;
                    }
                }
            };
            auto printCores = [&](const pcm::TopologyEntry::CoreType & coreType)
            {
                typedef uint64(*FuncType) (const CoreCounterState& before, const CoreCounterState& after);
                static FuncType funcFixed[] = { [](const CoreCounterState& before, const CoreCounterState& after) { return getInstructionsRetired(before, after); },
                              [](const CoreCounterState& before, const CoreCounterState& after) { return getCycles(before, after); },
                              [](const CoreCounterState& before, const CoreCounterState& after) { return getRefCycles(before, after); },
                              [](const CoreCounterState& before, const CoreCounterState& after) { return getAllSlotsRaw(before, after); }
                };
                static FuncType funcTopDown[] = { [](const CoreCounterState& before, const CoreCounterState& after) { return uint64(getFrontendBound(before, after) * maxPerfMetricsValue); },
                              [](const CoreCounterState& before, const CoreCounterState& after) { return uint64(getBadSpeculation(before, after) * maxPerfMetricsValue); },
                              [](const CoreCounterState& before, const CoreCounterState& after) { return uint64(getBackendBound(before, after) * maxPerfMetricsValue); },
                              [](const CoreCounterState& before, const CoreCounterState& after) { return uint64(getRetiring(before, after) * maxPerfMetricsValue); },
                              // "PERF_METRICS.HEAVY_OPERATIONS" :
                              [](const CoreCounterState& before, const CoreCounterState& after) { return uint64(getHeavyOperationsBound(before, after) * maxPerfMetricsValue); },
                              // "PERF_METRICS.BRANCH_MISPREDICTS" :
                              [](const CoreCounterState& before, const CoreCounterState& after) { return uint64(getBranchMispredictionBound(before, after) * maxPerfMetricsValue); },
                              // "PERF_METRICS.FETCH_LATENCY" :
                              [](const CoreCounterState& before, const CoreCounterState& after) { return uint64(getFetchLatencyBound(before, after) * maxPerfMetricsValue); },
                              // "PERF_METRICS.MEMORY_BOUND" :
                              [](const CoreCounterState& before, const CoreCounterState& after) { return uint64(getMemoryBound(before, after) * maxPerfMetricsValue); }
                };
                for (const auto& event : fixedEvents)
                {
                    for (uint32 cnt = 0; cnt < 4; ++cnt)
                    {
                        if (extract_bits(event.first[0], 4U * cnt, 1U + 4U * cnt))
                        {
                            if (is_header && is_header_printed)
                                break;

                            printRow(event.second.empty() ? fixedCoreEventNames[cnt] : event.second, funcFixed[cnt], BeforeState, AfterState, m, outputType, printOffset, coreType, type);

                            if (is_header)
                                is_header_printed = true;

                            if (cnt == 3 && (event.first[PerfMetricsConfig] & PerfMetricsMask))
                            {
                                for (uint32 t = 0; t < numTMAEvents(m); ++t)
                                {
                                    printRow(topdownEventNames[t], funcTopDown[t], BeforeState, AfterState, m, outputType, printOffset, coreType, type);
                                }
                            }
                        }
                    }
                }
                uint32 i = 0;
                for (const auto& event : events)
                {
                    if (is_header && is_header_printed)
                        break;

                    const std::string name = (event.second.empty()) ? (type + "Event" + std::to_string(i)) : event.second;
                    printRow(name, [&i](const CoreCounterState& before, const CoreCounterState& after) { return getNumberOfCustomEvents(i, before, after); }, BeforeState, AfterState, m, outputType, printOffset, coreType, type);
                    ++i;

                    if (is_header)
                        is_header_printed = true;
                }
            };
            auto printRegisterRows = [&](getEventStringFunc getEventString, getEventFunc getEvent)
            {
                auto printRegister = [&](const PCM::RawEventConfig& event) -> bool
                {
                    const std::string name = (event.second.empty()) ? getEventString(event.first, type) : event.second;
                    const auto values = getEvent(event.first, SysBeforeState, SysAfterState);

                    if (is_header && is_header_printed)
                        return false;

                    printRowBegin(name, BeforeState[0], AfterState[0], m, outputType, printOffset);

                    for (size_t r = 0; r < values.size(); ++r)
                    {
                        if (outputType == Header1)
                        {
                            cout << separator << "SYSTEM_" << r;
                            printOffset.end++;
                        }
                        else if (outputType == Header2)
                        {
                            cout << separator << type;
                        }
                        else if (outputType == Data)
                        {
                            cout << separator << values[r];
                        }
                        else if (outputType == Header21)
                        {
                            cout << separator << type << "_SYSTEM_" << r;
                            printOffset.end++;
                        }
                        else if (outputType == Json) {
                            cout << separator << type << "_SYSTEM_" << r
                                << jsonSeparator << values[r];
                        }
                        else
                        {
                            assert(!"unknown output type");
                        }
                    }

                    if (is_header)
                        is_header_printed = true;

                    printNewLine(outputType);

                    return true;
                };
                for (const auto& event : events)
                {
                    if (!printRegister(event))
                    {
                        break;
                    }
                }
                for (const auto& event : fixedEvents)
                {
                    if (!printRegister(event))
                    {
                        break;
                    }
                }
            };
            if (type == "core")
            {
                printCores(pcm::TopologyEntry::Core);
            }
            else if (type == "atom")
            {
                printCores(pcm::TopologyEntry::Atom);
            }
            else if (type == "thread_msr")
            {
                printMSRRows(MSRScope::Thread);
            }
            else if (type == "package_msr")
            {
                printMSRRows(MSRScope::Package);
            }
            else if (type == "tpmi")
            {
                printRegisterRows(getTPMIEventString, getTPMIEvent);
            }
            else if (type == "pcicfg")
            {
                printRegisterRows(getPCICFGEventString, getPCICFGEvent);
            }
            else if (type == "mmio")
            {
                printRegisterRows(getMMIOEventString, getMMIOEvent);
            }
            else if (type == "pmt")
            {
                printRegisterRows(getPMTEventString, getPMTEvent);
            }
            else if (type == "m3upi")
            {
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, (uint32) m->getQPILinksPerSocket(), "LINK"); },
                    [&]() { printUncoreRows(nullptr, (uint32) m->getQPILinksPerSocket(), type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getM3UPICounter(u, i, before, after); }, (uint32) m->getQPILinksPerSocket(), "LINK");
                    });
            }
            else if (type == "xpi" || type == "upi" || type == "qpi")
            {
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, (uint32) m->getQPILinksPerSocket(), "LINK"); },
                    [&]() { printUncoreRows(nullptr, (uint32) m->getQPILinksPerSocket(), type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getXPICounter(u, i, before, after); }, (uint32) m->getQPILinksPerSocket(), "LINK");
                    });
            }
            else if (type == "imc")
            {
                const std::string fixedEventName = (fixedEvents.empty() == false && fixedEvents[0].second.empty() == false) ? fixedEvents[0].second : "DRAMClocks";
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMCChannelsPerSocket(), "CHAN"); },
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMCChannelsPerSocket(), type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getMCCounter(u, i, before, after); }, (uint32)m->getMCChannelsPerSocket(),
                        fixedEventName, [](const uint32 u, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getDRAMClocks(u, before, after); });
                    });
            }
            else if (type == "m2m")
            {
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMCPerSocket(), "MC"); },
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMCPerSocket(), type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getM2MCounter(u, i, before, after); }, (uint32)m->getMCPerSocket(), "MC");
                    });
            }
            else if (type == "ha")
            {
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMCPerSocket(), "HA"); },
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMCPerSocket(), type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getHACounter(u, i, before, after); }, (uint32)m->getMCPerSocket(), "HA");
                    });
            }
            else if (type == "pcu")
            {
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMaxNumOfUncorePMUs(PCM::PCU_PMU_ID), "P"); },
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMaxNumOfUncorePMUs(PCM::PCU_PMU_ID), type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getUncoreCounter(PCM::PCU_PMU_ID, u, i, before, after); }, 1U, "");
                    });
            }
            else if (type == "ubox")
            {
                const auto numPMUs = (uint32)m->getMaxNumOfUncorePMUs(PCM::UBOX_PMU_ID);
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, numPMUs, ""); },
                    [&]() { printUncoreRows(nullptr, numPMUs, type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getUncoreCounter(PCM::UBOX_PMU_ID, u, i, before, after); }, numPMUs,
                            "UncoreClocks", [](const uint32, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getUncoreClocks(before, after); });
                    });
            }
            else if (type == "cbo" || type == "cha")
            {
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMaxNumOfUncorePMUs(PCM::CBO_PMU_ID), "C"); },
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMaxNumOfUncorePMUs(PCM::CBO_PMU_ID), type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getUncoreCounter(PCM::CBO_PMU_ID, u, i, before, after); }, (uint32)m->getMaxNumOfUncorePMUs(PCM::CBO_PMU_ID), "C");
                    });
            }
            else if (type == "mdf")
            {
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMaxNumOfUncorePMUs(PCM::MDF_PMU_ID), "MDF"); },
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMaxNumOfUncorePMUs(PCM::MDF_PMU_ID), type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getUncoreCounter(PCM::MDF_PMU_ID, u, i, before, after); }, (uint32)m->getMaxNumOfUncorePMUs(PCM::MDF_PMU_ID), "MDF");
                    });
            }
            else if (type == "irp")
            {
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMaxNumOfIIOStacks(), "IRP"); },
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMaxNumOfIIOStacks(), type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getIRPCounter(u, i, before, after); }, (uint32)m->getMaxNumOfIIOStacks(), "IRP");
                    });
            }
            else if (type == "iio")
            {
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMaxNumOfIIOStacks(), "IIO"); },
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMaxNumOfIIOStacks(), type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getIIOCounter(u, i, before, after); }, (uint32)m->getMaxNumOfIIOStacks(), "IIO");
                    });
            }
            else if (type == "cxlcm")
            {
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, (uint32) ServerUncoreCounterState::maxCXLPorts, "CXLCM"); },
                    [&]() { printUncoreRows(nullptr, (uint32) ServerUncoreCounterState::maxCXLPorts, type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getCXLCMCounter(u, i, before, after); }, ServerUncoreCounterState::maxCXLPorts, "CXLCM");
                    });
            }
            else if (type == "cxldp")
            {
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, (uint32) ServerUncoreCounterState::maxCXLPorts, "CXLDP"); },
                    [&]() { printUncoreRows(nullptr, (uint32) ServerUncoreCounterState::maxCXLPorts, type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getCXLDPCounter(u, i, before, after); }, ServerUncoreCounterState::maxCXLPorts, "CXLDP");
                    });
            }
            else if ((pmu_type = m->strToUncorePMUID(type)) != PCM::INVALID_PMU_ID)
            {
                choose(outputType,
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMaxNumOfUncorePMUs(pmu_type), type); },
                    [&]() { printUncoreRows(nullptr, (uint32) m->getMaxNumOfUncorePMUs(pmu_type), type); },
                    [&]() { printUncoreRows([](const uint32 u, const uint32 i, const ServerUncoreCounterState& before, const ServerUncoreCounterState& after) { return getUncoreCounter(pmu_type, u, i, before, after); }, (uint32)m->getMaxNumOfUncorePMUs(pmu_type), type);
                    });
            }
            else
            {
                std::cerr << "ERROR: unrecognized PMU type \"" << type << "\"\n";
            }

            if (outputType == Header1 || outputType == Header21)
                printOffsets.push_back(printOffset);
        }
        if (sampleSeparator)
        {
            cout << (isLastGroup? "==========\n" : "----------\n");
        }
        if (flushLine)
        {
            cout.flush();
        }
}

void print(const PCM::RawPMUConfigs& curPMUConfigs,
            PCM* m,
            SystemCounterState& SysBeforeState, SystemCounterState& SysAfterState,
            vector<CoreCounterState>& BeforeState, vector<CoreCounterState>& AfterState,
            vector<ServerUncoreCounterState>& BeforeUncoreState, vector<ServerUncoreCounterState>& AfterUncoreState,
            vector<SocketCounterState>& BeforeSocketState, vector<SocketCounterState>& AfterSocketState,
            const CsvOutputType outputType)
{
    printDateForCSV(outputType, separator);
    if (BeforeState.size() > 0 && AfterState.size() > 0)
    {
        choose(outputType,
            []() { cout << separator; },
            []() { cout << "ms" << separator; },
            [&]() { cout << (1000ULL * getInvariantTSC(BeforeState[0], AfterState[0])) / m->getNominalFrequency() << separator; });
    }
    for (auto& typeEvents : curPMUConfigs)
    {
        const auto & type = typeEvents.first;
        const auto & events = typeEvents.second.programmable;
        const auto & fixedEvents = typeEvents.second.fixed;
        auto printCores = [&m, &BeforeState, &AfterState, &type, &fixedEvents, &events, &outputType](const pcm::TopologyEntry::CoreType & coreType)
        {
            for (uint32 core = 0; core < m->getNumCores(); ++core)
            {
                if (show_partial_core_output && ycores.test(core) == false)
                    continue;

                if (m->isHybrid() && m->getCoreType(core) != coreType)
                {
                    continue;
                }

                const uint64 fixedCtrValues[] = {
                    getInstructionsRetired(BeforeState[core], AfterState[core]),
                    getCycles(BeforeState[core], AfterState[core]),
                    getRefCycles(BeforeState[core], AfterState[core]),
                    getAllSlotsRaw(BeforeState[core], AfterState[core])
                };
                const uint64 topdownCtrValues[] = {
                    uint64(getFrontendBound(BeforeState[core], AfterState[core]) * maxPerfMetricsValue),
                    uint64(getBadSpeculation(BeforeState[core], AfterState[core]) * maxPerfMetricsValue),
                    uint64(getBackendBound(BeforeState[core], AfterState[core]) * maxPerfMetricsValue),
                    uint64(getRetiring(BeforeState[core], AfterState[core]) * maxPerfMetricsValue),
                    uint64(getHeavyOperationsBound(BeforeState[core], AfterState[core]) * maxPerfMetricsValue),
                    uint64(getBranchMispredictionBound(BeforeState[core], AfterState[core]) * maxPerfMetricsValue),
                    uint64(getFetchLatencyBound(BeforeState[core], AfterState[core]) * maxPerfMetricsValue),
                    uint64(getMemoryBound(BeforeState[core], AfterState[core]) * maxPerfMetricsValue)
                };
                for (const auto& event : fixedEvents)
                {
                    auto print = [&](const std::string& metric, const uint64 value)
                    {
                        choose(outputType,
                            [m, core]() { cout << "SKT" << m->getSocketId(core) << "CORE" << core << separator; },
                            [&metric]() { cout << metric << separator; },
                            [&value]() { cout << value << separator; });
                    };
                    for (uint32 cnt = 0; cnt < 4; ++cnt)
                    {
                        if (extract_bits(event.first[0], 4U * cnt, 1U + 4U * cnt))
                        {
                            print(event.second.empty() ? fixedCoreEventNames[cnt] : event.second, fixedCtrValues[cnt]);
                            if (cnt == 3 && (event.first[PerfMetricsConfig] & PerfMetricsMask))
                            {
                                for (uint32 t = 0; t < numTMAEvents(m); ++t)
                                {
                                    print(topdownEventNames[t], topdownCtrValues[t]);
                                }
                            }
                        }
                    }
                }
                int i = 0;
                for (auto& event : events)
                {
                    choose(outputType,
                        [m, core]() { cout << "SKT" << m->getSocketId(core) << "CORE" << core << separator; },
                        [&event, &i, &type]() { if (event.second.empty()) cout << type << "Event" << i << separator;  else cout << event.second << separator; },
                        [&]() { cout << getNumberOfCustomEvents(i, BeforeState[core], AfterState[core]) << separator; });
                    ++i;
                }
            }
        };
        auto printRegisters = [&](getEventStringFunc getEventString, getEventFunc getEvent)
        {
            auto printOneRegister = [&](const PCM::RawEventConfig& event)
            {
                const auto values = getEvent(event.first, SysBeforeState, SysAfterState);
                for (size_t r = 0; r < values.size(); ++r)
                {
                    choose(outputType,
                        [&r]() { cout << "SYSTEM_" << r << separator; },
                        [&]() { if (event.second.empty()) cout << getEventString(event.first, type) << separator;  else cout << event.second << separator; },
                        [&]() { cout << values[r] << separator; });
                }
            };
            for (const auto& event : events)
            {
                printOneRegister(event);
            }
            for (const auto& event : fixedEvents)
            {
                printOneRegister(event);
            }
        };
        if (type == "core")
        {
            printCores(pcm::TopologyEntry::Core);
        }
        else if (type == "atom")
        {
            printCores(pcm::TopologyEntry::Atom);
        }
        else if (type == "m3upi")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 l = 0; l < m->getQPILinksPerSocket(); ++l)
                {
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, l]() { cout << "SKT" << s << "LINK" << l << separator; },
                            [&event, &i]() { if (event.second.empty()) cout << "M3UPIEvent" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getM3UPICounter(l, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else if (type == "xpi" || type == "upi" || type == "qpi")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 l = 0; l < m->getQPILinksPerSocket(); ++l)
                {
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, l]() { cout << "SKT" << s << "LINK" << l << separator; },
                            [&event, &i]() { if (event.second.empty()) cout << "XPIEvent" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getXPICounter(l, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else if (type == "imc")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 ch = 0; ch < m->getMCChannelsPerSocket(); ++ch)
                {
                    if (fixedEvents.size())
                    {
                        choose(outputType,
                            [s, ch]() { cout << "SKT" << s << "CHAN" << ch << separator; },
                            [&fixedEvents]() { cout << "DRAMClocks" << fixedEvents[0].second << separator; },
                            [&]() { cout << getDRAMClocks(ch, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                    }
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, ch]() { cout << "SKT" << s << "CHAN" << ch << separator; },
                            [&event, &i]() { if (event.second.empty()) cout << "IMCEvent" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getMCCounter(ch, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else if (type == "m2m")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 mc = 0; mc < m->getMCPerSocket(); ++mc)
                {
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, mc]() { cout << "SKT" << s << "MC" << mc << separator; },
                            [&event, &i]() { if (event.second.empty()) cout << "M2MEvent" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getM2MCounter(mc, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else if (type == "ha")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 mc = 0; mc < m->getMCPerSocket(); ++mc)
                {
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, mc]() { cout << "SKT" << s << "HA" << mc << separator; },
                            [&event, &i]() { if (event.second.empty()) cout << "HAEvent" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getHACounter(mc, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else if (type == "pcu")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 u = 0; u < m->getMaxNumOfUncorePMUs(PCM::PCU_PMU_ID); ++u)
                {
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, u]() { cout << "SKT" << s << "P" << u << separator; },
                            [&event, &i]() { if (event.second.empty()) cout << "PCUEvent" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getUncoreCounter(PCM::PCU_PMU_ID, u, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else if (type == "package_msr")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                auto printMSR = [&](const PCM::RawEventConfig & event)
                {
                    const auto index = event.first[PCM::MSREventPosition::index];
                    const auto msrType = (PCM::MSRType)event.first[PCM::MSREventPosition::type];
                    choose(outputType,
                        [s]() { cout << "SKT" << s << separator; },
                        [&]() { if (event.second.empty()) cout << getMSREventString(index, type, msrType) << separator;  else cout << event.second << separator; },
                        [&]() { cout << getMSREvent(index, msrType, BeforeSocketState[s], AfterSocketState[s]) << separator; });
                };
                for (const auto& event : events)
                {
                    printMSR(event);
                }
                for (const auto& event : fixedEvents)
                {
                    printMSR(event);
                }
            }
        }
        else if (type == "thread_msr")
        {
            for (uint32 core = 0; core < m->getNumCores(); ++core)
            {
                auto printMSR = [&](const PCM::RawEventConfig& event)
                {
                    const auto index = event.first[PCM::MSREventPosition::index];
                    const auto msrType = (PCM::MSRType)event.first[PCM::MSREventPosition::type];
                    choose(outputType,
                        [m, core]() { cout << "SKT" << m->getSocketId(core) << "CORE" << core << separator; },
                        [&]() { if (event.second.empty()) cout << getMSREventString(index, type, msrType) << separator;  else cout << event.second << separator; },
                        [&]() { cout << getMSREvent(index, msrType, BeforeState[core], AfterState[core]) << separator; });
                };
                for (const auto& event : events)
                {
                    printMSR(event);
                }
                for (const auto& event : fixedEvents)
                {
                    printMSR(event);
                }
            }
        }
        else if (type == "pcicfg")
        {
            printRegisters(getPCICFGEventString, getPCICFGEvent);
        }
        else if (type == "tpmi")
        {
            printRegisters(getTPMIEventString, getTPMIEvent);
        }
        else if (type == "mmio")
        {
            printRegisters(getMMIOEventString, getMMIOEvent);
        }
        else if (type == "pmt")
        {
            printRegisters(getPMTEventString, getPMTEvent);
        }
        else if (type == "ubox")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                if (fixedEvents.size())
                {
                    choose(outputType,
                        [s]() { cout << "SKT" << s << separator; },
                        [&fixedEvents]() { cout << "UncoreClocks" << fixedEvents[0].second << separator; },
                        [&]() { cout << getUncoreClocks(BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                }
                for (uint32 u = 0; u < m->getMaxNumOfUncorePMUs(PCM::UBOX_PMU_ID); ++u)
                {
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, u]() { cout << "SKT" << s << "U" << u << separator; },
                            [&event, &i]() { if (event.second.empty()) cout << "UBOXEvent" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getUncoreCounter(PCM::UBOX_PMU_ID, u, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else if (type == "cbo" || type == "cha")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 cbo = 0; cbo < m->getMaxNumOfUncorePMUs(PCM::CBO_PMU_ID); ++cbo)
                {
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, cbo]() { cout << "SKT" << s << "C" << cbo << separator; },
                            [&event, &i]() { if (event.second.empty()) cout << "CBOEvent" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getUncoreCounter(PCM::CBO_PMU_ID, cbo, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else if (type == "mdf")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 mdf = 0; mdf < m->getMaxNumOfUncorePMUs(PCM::MDF_PMU_ID); ++mdf)
                {
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, mdf]() { cout << "SKT" << s << "MDF" << mdf << separator; },
                            [&event, &i]() { if (event.second.empty()) cout << "MDFEvent" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getUncoreCounter(PCM::MDF_PMU_ID, mdf, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else if (type == "irp")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 stack = 0; stack < m->getMaxNumOfIIOStacks(); ++stack)
                {
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, stack]() { cout << "SKT" << s << "IRP" << stack << separator; },
                            [&event, &i]() { if (event.second.empty()) cout << "IRPEvent" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getIRPCounter(stack, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else if (type == "iio")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 stack = 0; stack < m->getMaxNumOfIIOStacks(); ++stack)
                {
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, stack]() { cout << "SKT" << s << "IIO" << stack << separator; },
                            [&event, &i]() { if (event.second.empty()) cout << "IIOEvent" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getIIOCounter(stack, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else if (type == "cxlcm")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 p = 0; p < ServerUncoreCounterState::maxCXLPorts; ++p)
                {
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, p]() { cout << "SKT" << s << "CXLCM" << p << separator; },
                            [&event, &i]() { if (event.second.empty()) cout << "CXLCMEvent" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getCXLCMCounter(p, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else if (type == "cxldp")
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 p = 0; p < ServerUncoreCounterState::maxCXLPorts; ++p)
                {
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, p]() { cout << "SKT" << s << "CXLDP" << p << separator; },
                            [&event, &i]() { if (event.second.empty()) cout << "CXLDPEvent" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getCXLDPCounter(p, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else if ((pmu_type = m->strToUncorePMUID(type)) != PCM::INVALID_PMU_ID)
        {
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 unit = 0; unit < m->getMaxNumOfUncorePMUs(pmu_type); ++unit)
                {
                    int i = 0;
                    for (auto& event : events)
                    {
                        choose(outputType,
                            [s, unit, &type]() { cout << "SKT" << s << type << unit << separator; },
                            [&event, &i, &type]() { if (event.second.empty()) cout << type << "Event" << i << separator;  else cout << event.second << separator; },
                            [&]() { cout << getUncoreCounter(pmu_type, unit, i, BeforeUncoreState[s], AfterUncoreState[s]) << separator; });
                        ++i;
                    }
                }
            }
        }
        else
        {
            std::cerr << "ERROR: unrecognized PMU type \"" << type << "\"\n";
        }
    }
    if (flushLine)
    {
        cout << endl;
    }
    else
    {
        cout << "\n";
    }
}

void printAll(const PCM::RawPMUConfigs& curPMUConfigs,
                PCM * m,
                SystemCounterState & SysBeforeState, SystemCounterState& SysAfterState,
                vector<CoreCounterState>& BeforeState, vector<CoreCounterState>& AfterState,
                vector<ServerUncoreCounterState>& BeforeUncoreState, vector<ServerUncoreCounterState>& AfterUncoreState,
                vector<SocketCounterState>& BeforeSocketState, vector<SocketCounterState>& AfterSocketState,
                std::vector<PCM::RawPMUConfigs>& PMUConfigs,
                const bool & isLastGroup)
{
    if (outputToJson) {
        printTransposed(curPMUConfigs, m, SysBeforeState, SysAfterState, BeforeState, AfterState, BeforeUncoreState, AfterUncoreState, BeforeSocketState, AfterSocketState, Json, isLastGroup);
        return;
    }

    static bool displayHeader = true;

    if (!extendPrintout && transpose)
        displayHeader = false;

    if (transpose) {
        if (displayHeader) {
            // Need to go through all possible print on first run to form header.
            if (singleHeader) {
                // merge header 2 and 1, print and get all offsets
                cout << "Date" << separator << "Time" << separator << "Event" << separator;
                cout << "ms" << separator << "InvariantTSC";
                for (auto &config : PMUConfigs)
                    printTransposed(config, m, SysBeforeState, SysAfterState, BeforeState, AfterState, BeforeUncoreState, AfterUncoreState, BeforeSocketState, AfterSocketState, Header21, isLastGroup);
            } else {
                // print 2 headers in 2 rows
                for (int i = 0 ; i < 4 ; i++)
                    cout << separator;

                // print header_1 and get all offsets
                for (auto &config : PMUConfigs)
                    printTransposed(config, m, SysBeforeState, SysAfterState, BeforeState, AfterState, BeforeUncoreState, AfterUncoreState, BeforeSocketState, AfterSocketState, Header1, isLastGroup);

                cout << endl;

                // print header_2
                cout << "Date" << separator << "Time" << separator << "Event" << separator;
                cout << "ms" << separator << "InvariantTSC";
                for (auto &config : PMUConfigs)
                    printTransposed(config, m, SysBeforeState, SysAfterState, BeforeState, AfterState, BeforeUncoreState, AfterUncoreState, BeforeSocketState, AfterSocketState, Header2, isLastGroup);
            }
            cout << endl;
        }
        printTransposed(curPMUConfigs, m, SysBeforeState, SysAfterState, BeforeState, AfterState, BeforeUncoreState, AfterUncoreState, BeforeSocketState, AfterSocketState, Data, isLastGroup);
    } else {
        if (displayHeader) {
            print(curPMUConfigs, m, SysBeforeState, SysAfterState, BeforeState, AfterState, BeforeUncoreState, AfterUncoreState, BeforeSocketState, AfterSocketState, Header1);
            print(curPMUConfigs, m, SysBeforeState, SysAfterState, BeforeState, AfterState, BeforeUncoreState, AfterUncoreState, BeforeSocketState, AfterSocketState, Header2);
        }
        print(curPMUConfigs, m, SysBeforeState, SysAfterState, BeforeState, AfterState, BeforeUncoreState, AfterUncoreState, BeforeSocketState, AfterSocketState, Data);
    }

    displayHeader = false;
}

PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
    if(print_version(argc, argv))
        exit(EXIT_SUCCESS);

    parseParam(argc, argv, "out", [](const char* p) {
            const string filename{ p };
            if (!filename.empty()) {
                PCM::setOutput(filename, true);
            }
        });

    null_stream nullStream2;
#ifdef PCM_FORCE_SILENT
    null_stream nullStream1;
    std::cout.rdbuf(&nullStream1);
    std::cerr.rdbuf(&nullStream2);
#else
    check_and_set_silent(argc, argv, nullStream2);
#endif

    set_signal_handlers();
    set_real_time_priority(true);

    cerr << "\n";
    cerr << " Intel(r) Performance Counter Monitor: Raw Event Monitoring Utility \n";
    cerr << "\n";

    std::vector<PCM::RawPMUConfigs> PMUConfigs(1);
    double delay = -1.0;
    int pid{-1};
    char* sysCmd = NULL;
    char** sysArgv = NULL;
    MainLoop mainLoop;
    string program = string(argv[0]);
    bool forceRTMAbortMode = false;
    bool reset_pmu = false;
    PCM* m = PCM::getInstance();

    telemDB.loadFromXML("Intel-PMT");

    parsePID(argc, argv, pid);

#ifdef PCM_SIMDJSON_AVAILABLE
    parseParam(argc, argv, "ep", [](const char* p) { eventFileLocationPrefix = p;});
#endif

    if (argc > 1) do
    {
        argv++;
        argc--;
        string arg_value;

        if (*argv == nullptr)
        {
            continue;
        }
        else if (check_argument_equals(*argv, {"--help", "-h", "/h"}))
        {
            print_usage(program);
            exit(EXIT_FAILURE);
        }
        else if (check_argument_equals(*argv, {"-silent", "/silent"}))
        {
            // handled in check_and_set_silent
            continue;
        }
        else if (extract_argument_value(*argv, {"-csv", "/csv"}, arg_value))
        {
            if (!arg_value.empty()) {
                m->setOutput(arg_value);
            }
        }
        else if (check_argument_equals(*argv, {"-json", "/json"}))
        {
            separator = ",\"";
            outputToJson = true;
        }
        else if (extract_argument_value(*argv, {"-json", "/json"}, arg_value))
        {
            separator = ",\"";
            outputToJson = true;
            if (!arg_value.empty()) {
                m->setOutput(arg_value);
            }
            continue;
        }
        else if (mainLoop.parseArg(*argv))
        {
            continue;
        }
        else if (isPIDOption(argv))
        {
            argv++;
            argc--;
            continue;
        }
        else if (check_argument_equals(*argv, {"-reset", "/reset", "-r"}))
        {
            reset_pmu = true;
            continue;
        }
        else if (check_argument_equals(*argv, {"-tr", "/tr"}))
        {
            transpose = true;
            continue;
        }
        else if (check_argument_equals(*argv, {"-ext", "/ext"}))
        {
            extendPrintout = true;
            continue;
        }
#if PCM_SIMDJSON_AVAILABLE
        else if (check_argument_equals(*argv, {"-?", "/?"}))
        {
            printAllEventDescriptions();
            return 0;
        }
#endif
        else if (check_argument_equals(*argv, {"-single-header", "/single-header"}))
        {
            singleHeader = true;
            continue;
        }
        else if (check_argument_equals(*argv, {"-l"})) {
            std::cout.imbue(std::locale(""));
            separator = "\t";
            continue;
        }
        else if (check_argument_equals(*argv, {"-tab"})) {
            separator = "\t";
            continue;
        }
        else if (check_argument_equals(*argv, {"--yescores", "-yc", "/yc"}))
        {
            argv++;
            argc--;
            show_partial_core_output = true;
            if (*argv == NULL)
            {
                cerr << "Error: --yescores requires additional argument.\n";
                exit(EXIT_FAILURE);
            }
            std::stringstream ss(*argv);
            while (ss.good())
            {
                string s;
                int core_id;
                std::getline(ss, s, ',');
                if (s.empty())
                    continue;
                core_id = atoi(s.c_str());
                if (core_id > MAX_CORES)
                {
                    cerr << "Core ID:" << core_id << " exceed maximum range " << MAX_CORES << ", program abort\n";
                    exit(EXIT_FAILURE);
                }

                ycores.set(atoi(s.c_str()), true);
            }
            if (m->getNumCores() > MAX_CORES)
            {
                cerr << "Error: --yescores option is enabled, but #define MAX_CORES " << MAX_CORES << " is less than  m->getNumCores() = " << m->getNumCores() << "\n";
                cerr << "There is a potential to crash the system. Please increase MAX_CORES to at least " << m->getNumCores() << " and re-enable this option.\n";
                exit(EXIT_FAILURE);
            }
            continue;
        }
        else if (check_argument_equals(*argv, {"-out", "/out"}))
        {
            argv++;
            argc--;
            continue;
        }
        else if (check_argument_equals(*argv, {"-ep", "/ep"}))
        {
            argv++;
            argc--;
            continue;
        }
        else if (check_argument_equals(*argv, {"-edp", "/edp"}))
        {
            sampleSeparator = true;
            defaultDelay = 0.2;
            transpose = true;
            m->printDetailedSystemTopology();
            continue;
        }
        else if (check_argument_equals(*argv, {"-el", "/el"}))
        {
            argv++;
            argc--;
            const auto p = *argv;
            if (p == nullptr)
            {
                cerr << "ERROR: no parameter value provided for 'el' option\n";
                exit(EXIT_FAILURE);
            }
            else if (addEvents(PMUConfigs, p) == false)
            {
                exit(EXIT_FAILURE);
            }
            continue;
        }
        else if (check_argument_equals(*argv, {"-e"}))
        {
            argv++;
            argc--;
            const auto p = *argv;
            if (p == nullptr)
            {
                cerr << "ERROR: no parameter value provided for 'e' option\n";
                exit(EXIT_FAILURE);
            } else if (addEvent(PMUConfigs[0], p) != AddEventStatus::OK)
            {
                exit(EXIT_FAILURE);
            }
            continue;
        }
        else if (CheckAndForceRTMAbortMode(*argv, m))
        {
            forceRTMAbortMode = true;
            continue;
        }
        else if (check_argument_equals(*argv, {"-f", "/f"}))
        {
            flushLine = true;
            continue;
        }
        else if (check_argument_equals(*argv, {"-s", "/s"}))
        {
            sampleSeparator = true;
            continue;
        }
        else if (check_argument_equals(*argv, {"-v", "/v"}))
        {
            verbose = true;
            continue;
        }
        else if (check_argument_equals(*argv, {"--"}))
        {
            argv++;
            sysCmd = *argv;
            sysArgv = argv;
            break;
        }
        else
        {
            delay = parse_delay(*argv, program, (print_usage_func)print_usage);
            continue;
        }
    } while (argc > 1); // end of command line parsing loop

    if (reset_pmu)
    {
        cerr << "\n Resetting PMU configuration\n";
        m->resetPMU();
    }

    print_cpu_details();

    size_t nGroups = 0;
    for (const auto& group : PMUConfigs)
    {
        if (!group.empty()) ++nGroups;
    }
    for (size_t i = 0; i < PMUConfigs.size(); ++i)
    {
        if (PMUConfigs[i].empty())
        {   // erase empty groups
            PMUConfigs.erase(PMUConfigs.begin() + i);
            --i;
        }
    }
    assert(PMUConfigs.size() == nGroups);
    if (nGroups == 0)
    {
        cerr << "No events specified. Exiting.\n";
        exit(EXIT_FAILURE);
    }
    cerr << "Collecting " << nGroups << " event group(s)\n";

    if (nGroups > 1)
    {
        transpose = true;
        cerr << "Enforcing transposed event output because the number of event groups > 1\n";
    }

    print_pid_collection_message(pid);

    auto programPMUs = [&m, &pid](const PCM::RawPMUConfigs & config)
    {
        if (verbose)
        {
            for (const auto & pmuConfig: config)
            {
                for (const auto & e : pmuConfig.second.fixed)
                {
                    cerr << "Programming " << pmuConfig.first << " fixed event: " << e.second << "\n";
                }
                for (const auto & e : pmuConfig.second.programmable)
                {
                    cerr << "Programming " << pmuConfig.first << " programmable event: " << e.second << "\n";
                }
            }
        }
        PCM::ErrorCode status = m->program(config, !verbose, pid);
        m->checkError(status);
    };

    SystemCounterState SysBeforeState, SysAfterState;
    vector<CoreCounterState> BeforeState, AfterState;
    vector<SocketCounterState> BeforeSocketState, AfterSocketState;
    vector<ServerUncoreCounterState> BeforeUncoreState, AfterUncoreState;
    BeforeUncoreState.resize(m->getNumSockets());
    AfterUncoreState.resize(m->getNumSockets());

    if ((sysCmd != NULL) && (delay <= 0.0)) {
        // in case external command is provided in command line, and
        // delay either not provided (-1) or is zero
        m->setBlocked(true);
    }
    else {
        m->setBlocked(false);
    }

    if (delay <= 0.0) delay = defaultDelay;

    cerr << "Update every " << delay << " seconds\n";

    std::cout.precision(2);
    std::cout << std::fixed;

    if (sysCmd != NULL) {
        MySystem(sysCmd, sysArgv);
    }

    auto programAndReadGroup = [&](const PCM::RawPMUConfigs & group)
    {
        if (forceRTMAbortMode)
        {
            m->enableForceRTMAbortMode(true);
        }
        programPMUs(group);
        m->globalFreezeUncoreCounters();
        m->getAllCounterStates(SysBeforeState, BeforeSocketState, BeforeState);
        for (uint32 s = 0; s < m->getNumSockets(); ++s)
        {
            BeforeUncoreState[s] = m->getServerUncoreCounterState(s);
        }
        m->globalUnfreezeUncoreCounters();
    };

    if (nGroups == 1)
    {
        programAndReadGroup(PMUConfigs[0]);
    }

    mainLoop([&]()
    {
         size_t groupNr = 0;
         for (const auto & group : PMUConfigs)
         {
                ++groupNr;

                if (nGroups > 1)
                {
                    programAndReadGroup(group);
                }

                calibratedSleep(delay, sysCmd, mainLoop, m);

                m->globalFreezeUncoreCounters();
                m->getAllCounterStates(SysAfterState, AfterSocketState, AfterState);
                for (uint32 s = 0; s < m->getNumSockets(); ++s)
                {
                    AfterUncoreState[s] = m->getServerUncoreCounterState(s);
                }
                m->globalUnfreezeUncoreCounters();

                printAll(group, m, SysBeforeState, SysAfterState, BeforeState, AfterState, BeforeUncoreState, AfterUncoreState, BeforeSocketState, AfterSocketState, PMUConfigs, groupNr == nGroups);
                if (nGroups == 1)
                {
                    std::swap(BeforeState, AfterState);
                    std::swap(BeforeSocketState, AfterSocketState);
                    std::swap(BeforeUncoreState, AfterUncoreState);
                    std::swap(SysBeforeState, SysAfterState);
                }
         }
         if (m->isBlocked()) {
             // in case PCM was blocked after spawning child application: break monitoring loop here
             return false;
         }
         return true;
    });
    exit(EXIT_SUCCESS);
}

```

`src/pcm-sensor-server.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2016-2022, Intel Corporation

// Windows: Define WIN32_LEAN_AND_MEAN before ANY includes to prevent winsock.h conflicts
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#endif

// Use port allocated for PCM in prometheus:
// https://github.com/prometheus/prometheus/wiki/Default-port-allocations
constexpr unsigned int DEFAULT_HTTP_PORT = 9738;
#if defined (USE_SSL)
constexpr unsigned int DEFAULT_HTTPS_PORT = DEFAULT_HTTP_PORT;
#endif
#include "pcm-accel-common.h"

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include<string>

// Platform-specific includes
#ifdef _WIN32
// winsock2.h must be included before windows.h (already included by pcm-accel-common.h -> cpucounters.h -> types.h)
#include <winsock2.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")
// Define UNIX-like types for Windows
typedef SOCKET socket_t;
#define SHUT_RDWR SD_BOTH
#define MSG_NOSIGNAL 0
// errno values
#define EAGAIN WSAEWOULDBLOCK
#define EWOULDBLOCK WSAEWOULDBLOCK
inline int close(SOCKET s) { return closesocket(s); }
#else
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sched.h>
typedef int socket_t;
#define INVALID_SOCKET (-1)
#define SOCKET_ERROR (-1)
#endif

#include <cstring>
#include <fstream>
#include <ctime>
#include <vector>
#include <unordered_map>

#include "cpucounters.h"
#include "debug.h"
#include "topology.h"
#include "dashboard.h"

#define PCMWebServerVersion "0.1"
#if defined (USE_SSL)
#  include <openssl/ssl.h>
#  include <openssl/err.h>

#  define CERT_FILE_NAME "./server.pem"
#  define KEY_FILE_NAME  "./server.pem"
#endif // USE_SSL

#include <chrono>
#include <algorithm>

#include "threadpool.h"

#include "pcm-iio-pmu.h"

using namespace pcm;

std::string const HTTP_EOL( "\r\n" );
std::string const PROM_EOL( "\n" );

class Indent {
    public:
        explicit Indent( std::string const & is = std::string("    ") ) : indstr_(is), indent_(""), len_(0), indstrlen_(is.length())
    {
        }
        Indent() = delete;
        Indent(Indent const &) = default;
        Indent & operator = (Indent const &) = delete;
        ~Indent() = default;

        friend std::stringstream& operator <<( std::stringstream& stream, Indent in );

        void printIndentationString(std::stringstream& s) {
            s << indent_;
        }
        // We only need post inc und pre dec
        Indent& operator--() {
            if ( len_ > 0 )
                --len_;
            else
                throw std::runtime_error("Indent: Decremented len_ too often!");
            indent_.erase( len_ * indstrlen_ );
            return *this;
        }
        Indent operator++(int) {
            Indent copy( *this );
            ++len_;
            indent_ += indstr_; // add one more indstr_
            return copy;
        }

    private:
        std::string indstr_;
        std::string indent_;
        size_t len_;
        size_t const indstrlen_;
};

std::stringstream& operator <<( std::stringstream& stream, Indent in ) {
    in.printIndentationString( stream );
    return stream;
}

class datetime {
    public:
        datetime() {
            std::time_t t = std::time( nullptr );
            const auto gt = std::gmtime( &t );
            if (gt == nullptr)
                throw std::runtime_error("std::gmtime returned nullptr");
            now = *gt;
        }
        datetime( std::tm t ) : now( t ) {}
        ~datetime() = default;
        datetime( datetime const& ) = default;
        datetime & operator = ( datetime const& ) = default;

    public:
        void printDateTimeString( std::ostream& os ) const {
            std::stringstream str("");
            char timeBuffer[64];
            std::fill(timeBuffer, timeBuffer + 64, 0);
            str.imbue( std::locale::classic() );
            if ( strftime( timeBuffer, 63, "%a, %d %b %Y %T GMT", &now ) )
                str << timeBuffer;
            else
                throw std::runtime_error("Error writing to timeBuffer, too small?");
            os << str.str();
        }
        std::string toString() const {
            std::stringstream str("");
            char timeBuffer[64];
            std::fill(timeBuffer, timeBuffer + 64, 0);
            str.imbue( std::locale::classic() );
            if ( strftime( timeBuffer, 63, "%a, %d %b %Y %T GMT", &now ) )
                str << timeBuffer;
            else
                throw std::runtime_error("Error writing to timeBuffer, too small?");
            return str.str();
        }

    private:
        std::tm now;
};

std::ostream& operator<<( std::ostream& os, datetime const & dt ) {
    dt.printDateTimeString(os);
    return os;
}

class date {
    public:
        date() {
            now = std::time(nullptr);
        }
        ~date() = default;
        date( date const& ) = default;
        date & operator = ( date const& ) = default;

    public:
        void printDate( std::ostream& os ) const {
            char buf[64];
            const auto t = std::localtime(&now);
            assert(t);
            std::strftime( buf, 64, "%F", t);
            os << buf;
        }

    private:
        std::time_t now;
};

std::ostream& operator<<( std::ostream& os, date const & d ) {
    d.printDate(os);
    return os;
}

/* Not used right now

std::string read_ndctl_info( std::ofstream& logfile ) {
    int pipes[2];
    if ( pipe( pipes ) == -1 ) {
        logfile << date() << ": ERROR Cannot create pipe, errno = " << errno << ", strerror: " << strerror(errno) << ". Exit 50.\n";
        exit(50);
    }
    std::stringstream ndctl;
    if ( fork() == 0 ) {
        // child, writes to pipe, close read-end
        close( pipes[0] );
        dup2( pipes[1], fileno(stdout) );
        execl( "/usr/bin/ndctl", "ndctl", "list", (char*)NULL );
    } else {
        // parent, reads from pipe, close write-end
        close( pipes[1] );
        char buf[2049];
        std::fill(buf, buf + 2049, 0);
        ssize_t len = 0;
        while( (len = read( pipes[0], buf, 2048 )) > 0 ) {
            buf[len] = '\0';
            ndctl << buf;
        }
        close( pipes[0] );
        if ( len < 0 ) {
            logfile << ": ERROR Read from ndctl pipe failed. errno = " << errno << ". strerror(errno) = " << strerror(errno) << ". Exit 52.\n";
            exit(52);
        }
        logfile << datetime() << ": INFO Read JSON from ndctl pipe: " << ndctl.str() << ".\n";
    }
    return ndctl.str();
}

*/

class HTTPServer;

class SignalHandler {
public:
    static SignalHandler* getInstance() {
        static SignalHandler instance;
        return &instance;
    }

#ifdef _WIN32
    static BOOL WINAPI handleSignal( DWORD signum );
#else
    static void handleSignal( int signum );
#endif

    void setSocket( socket_t s ) {
        networkSocket_ = s;
    }

    void setHTTPServer( HTTPServer* hs ) {
        httpServer_ = hs;
    }

    void ignoreSignal( int signum ) {
#ifdef _WIN32
        // On Windows, ignoring signals is handled differently
        // SIGPIPE doesn't exist on Windows, so this is a no-op
#else
        struct sigaction sa;
        sigemptyset(&sa.sa_mask);
        sa.sa_handler = SIG_IGN;
        sa.sa_flags = 0;
        sigaction( signum, &sa, 0 );
#endif
    }

    void installHandler( void (*handler)(int), int signum ) {
#ifdef _WIN32
        // On Windows, use SetConsoleCtrlHandler for CTRL+C and CTRL+BREAK
        (void)handler; // unused on Windows
        (void)signum;  // unused on Windows
        SetConsoleCtrlHandler((PHANDLER_ROUTINE)handleSignal, TRUE);
#else
        struct sigaction sa;
        sigemptyset(&sa.sa_mask);
        sa.sa_handler = handler;
        sa.sa_flags = 0;
        sigaction( signum, &sa, 0 );
#endif
    }

    SignalHandler( SignalHandler const & ) = delete;
    void operator=( SignalHandler const & ) = delete;
    ~SignalHandler() = default;

private:
    SignalHandler() = default;

private:
    static socket_t networkSocket_;
    static HTTPServer* httpServer_;
};

socket_t SignalHandler::networkSocket_ = INVALID_SOCKET;
HTTPServer* SignalHandler::httpServer_ = nullptr;

namespace pcm {

class JSONPrinter : Visitor
{
public:
    enum LineEndAction {
        NewLineOnly = 0,
        DelimiterOnly,
        DelimiterAndNewLine,
        LineEndAction_Spare = 255
    };

    JSONPrinter( std::pair<std::shared_ptr<Aggregator>,std::shared_ptr<Aggregator>> aggregatorPair ) : indentation("  "), aggPair_( aggregatorPair ) {
        if ( nullptr == aggPair_.second.get() )
            throw std::runtime_error("BUG: second Aggregator == nullptr!");
        DBG( 2, "Constructor: before=", std::hex, aggPair_.first.get(), ", after=", std::hex, aggPair_.second.get() );
    }

    JSONPrinter( JSONPrinter const & ) = delete;
    JSONPrinter & operator = ( JSONPrinter const & ) = delete;
    JSONPrinter() = delete;

    CoreCounterState const getCoreCounter( std::shared_ptr<Aggregator> ag, uint32 tid ) const {
        CoreCounterState ccs;
        if ( nullptr == ag.get() )
            return ccs;
        return std::move( ag->coreCounterStates()[tid] );
    }

    SocketCounterState const getSocketCounter( std::shared_ptr<Aggregator> ag, uint32 sid ) const {
        SocketCounterState socs;
        if ( nullptr == ag.get() )
            return socs;
        return std::move( ag->socketCounterStates()[sid] );
    }

    SystemCounterState getSystemCounter( std::shared_ptr<Aggregator> ag ) const {
        SystemCounterState sycs;
        if ( nullptr == ag.get() )
            return sycs;
        return std::move( ag->systemCounterState() );
    }


    virtual void dispatch( HyperThread* ht )  override {
        printCounter( "Object", "HyperThread" );
        printCounter( "Thread ID", ht->threadID() );
        printCounter( "OS ID", ht->osID() );
        CoreCounterState before = getCoreCounter( aggPair_.first,  ht->osID() );
        CoreCounterState after  = getCoreCounter( aggPair_.second, ht->osID() );
        printBasicCounterState( before, after );
    }

    virtual void dispatch( ServerUncore* su ) override {
        printCounter( "Object", "ServerUncore" );
        SocketCounterState before = getSocketCounter( aggPair_.first,  su->socketID() );
        SocketCounterState after  = getSocketCounter( aggPair_.second, su->socketID() );
        printUncoreCounterState( before, after );
    }

    virtual void dispatch( ClientUncore* cu) override {
        printCounter( "Object", "ClientUncore" );
        SocketCounterState before = getSocketCounter( aggPair_.first,  cu->socketID() );
        SocketCounterState after  = getSocketCounter( aggPair_.second, cu->socketID() );
        printUncoreCounterState( before, after );
    }

    virtual void dispatch( Core* c ) override {
        printCounter( "Object", "Core" );
        auto vec = c->threads();
        printCounter( "Number of threads", vec.size() );
        startObject( "Threads", BEGIN_LIST );
        iterateVectorAndCallAccept( vec );
        endObject( JSONPrinter::LineEndAction::DelimiterAndNewLine, END_LIST );

        // For backward compatibility we use socketUniqueCoreID to create a unique number inside the socket for a core
        // and introduce HW Core ID as the physical core id inside a module, keep in mind this core id is not unique inside a socket
        printCounter( "Core ID", c->socketUniqueCoreID() );
        printCounter( "HW Core ID", c->coreID() );
        printCounter( "Module ID", c->moduleID() );
        printCounter( "Tile ID", c->tileID() );
        printCounter( "Die ID", c->dieID() );
        printCounter( "Die Group ID", c->dieGroupID() );
        printCounter( "Socket ID", c->socketID() );
    }

    virtual void dispatch( SystemRoot const & s ) override {
        using namespace std::chrono;
        auto interval = duration_cast<microseconds>( aggPair_.second->dispatchedAt() - aggPair_.first->dispatchedAt() ).count();
        startObject( "", BEGIN_OBJECT );
        printCounter( "Interval us", interval );
        printCounter( "Object", "SystemRoot" );
        auto vec = s.sockets();
        printCounter( "Number of sockets", vec.size() );
        startObject( "Sockets", BEGIN_LIST );
        iterateVectorAndCallAccept( vec );
        endObject( JSONPrinter::LineEndAction::DelimiterAndNewLine, END_LIST );
        SystemCounterState before = getSystemCounter( aggPair_.first );
        SystemCounterState after  = getSystemCounter( aggPair_.second  );
        PCM * pcm = PCM::getInstance();
        if (pcm->getAccel()!=ACCEL_NOCONFIG){
            startObject ("Accelerators",BEGIN_OBJECT);
            printAccelCounterState(before,after);
            endObject( JSONPrinter::LineEndAction::DelimiterAndNewLine, END_OBJECT );
        }
        startObject( "QPI/UPI Links", BEGIN_OBJECT );
        printSystemCounterState( before, after );
        endObject( JSONPrinter::LineEndAction::DelimiterAndNewLine, END_OBJECT );
        startObject( "Core Aggregate", BEGIN_OBJECT );
        printBasicCounterState( before, after );
        endObject( JSONPrinter::LineEndAction::DelimiterAndNewLine, END_OBJECT );
        startObject( "Uncore Aggregate", BEGIN_OBJECT );
        printUncoreCounterState( before, after );
        endObject( JSONPrinter::LineEndAction::NewLineOnly, END_OBJECT );

        endObject( JSONPrinter::LineEndAction::NewLineOnly, END_OBJECT );
    }

    virtual void dispatch( Socket* s ) override {
        printCounter( "Object", "Socket" );
        printCounter( "Socket ID", s->socketID() );
        auto vec = s->cores();
        printCounter( "Number of cores", vec.size() );
        startObject( "Cores", BEGIN_LIST );
        iterateVectorAndCallAccept( vec );
        endObject( JSONPrinter::LineEndAction::DelimiterAndNewLine, END_LIST );

        startObject( "Uncore", BEGIN_OBJECT );
        s->uncore()->accept( *this );
        endObject( JSONPrinter::LineEndAction::DelimiterAndNewLine, END_OBJECT );
        startObject( "Core Aggregate", BEGIN_OBJECT );
        SocketCounterState before = getSocketCounter( aggPair_.first,  s->socketID() );
        SocketCounterState after  = getSocketCounter( aggPair_.second, s->socketID() );
        printBasicCounterState( before, after );
        endObject( JSONPrinter::LineEndAction::NewLineOnly, END_OBJECT );
    }

    std::string str( void ) {
        return ss.str();
    }

private:
    void printBasicCounterState( BasicCounterState const& before, BasicCounterState const& after ) {
        startObject( "Core Counters", BEGIN_OBJECT );
        printCounter( "Instructions Retired Any", getInstructionsRetired( before, after ) );
        printCounter( "Clock Unhalted Thread",    getCycles             ( before, after ) );
        printCounter( "Clock Unhalted Ref",       getRefCycles          ( before, after ) );
        printCounter( "L3 Cache Misses",          getL3CacheMisses      ( before, after ) );
        printCounter( "L3 Cache Hits",            getL3CacheHits        ( before, after ) );
        printCounter( "L2 Cache Misses",          getL2CacheMisses      ( before, after ) );
        printCounter( "L2 Cache Hits",            getL2CacheHits        ( before, after ) );
        printCounter( "L3 Cache Occupancy",       getL3CacheOccupancy   ( after ) );
        printCounter( "Invariant TSC",            getInvariantTSC       ( before, after ) );
        printCounter( "SMI Count",                getSMICount           ( before, after ) );

        printCounter( "Core Frequency",           getActiveAverageFrequency ( before, after ) );

        printCounter( "Frontend Bound",             int(100. * getFrontendBound(before, after)) );
        printCounter( "Bad Speculation",            int(100. * getBadSpeculation(before, after)) );
        printCounter( "Backend Bound",              int(100. * getBackendBound(before, after)) );
        printCounter( "Retiring",                   int(100. * getRetiring(before, after)) );
        printCounter( "Fetch Latency Bound",        int(100. * getFetchLatencyBound(before, after)) );
        printCounter( "Fetch Bandwidth Bound",      int(100. * getFetchBandwidthBound(before, after)) );
        printCounter( "Branch Misprediction Bound", int(100. * getBranchMispredictionBound(before, after)) );
        printCounter( "Machine Clears Bound",       int(100. * getMachineClearsBound(before, after)) );
        printCounter( "Memory Bound",               int(100. * getMemoryBound(before, after)) );
        printCounter( "Core Bound",                 int(100. * getCoreBound(before, after)) );
        printCounter( "Heavy Operations Bound",     int(100. * getHeavyOperationsBound(before, after)) );
        printCounter( "Light Operations Bound",     int(100. * getLightOperationsBound(before, after)) );

        endObject( JSONPrinter::DelimiterAndNewLine, END_OBJECT );
        //DBG( 2, "Invariant TSC before=", before.InvariantTSC, ", after=", after.InvariantTSC, ", difference=", after.InvariantTSC-before.InvariantTSC );

        startObject( "Energy Counters", BEGIN_OBJECT );
        printCounter( "Thermal Headroom", after.getThermalHeadroom() );
        uint32 i = 0;
        for ( ; i < ( PCM::MAX_C_STATE ); ++i ) {
            std::stringstream s;
            s << "CStateResidency[" << i << "]";
            printCounter( s.str(), getCoreCStateResidency( i, before, after ) );
        }
        // Here i == PCM::MAX_STATE so no need to type so many characters ;-)
        std::stringstream s;
        s << "CStateResidency[" << i << "]";
        printCounter( s.str(), getCoreCStateResidency( i, before, after ) );
        endObject( JSONPrinter::DelimiterAndNewLine, END_OBJECT );

        startObject( "Core Memory Bandwidth Counters", BEGIN_OBJECT );
        printCounter( "Local Memory Bandwidth", getLocalMemoryBW( before, after ) );
        printCounter( "Remote Memory Bandwidth", getRemoteMemoryBW( before, after ) );
        endObject( JSONPrinter::NewLineOnly, END_OBJECT );
    }

    void printUncoreCounterState( SocketCounterState const& before, SocketCounterState const& after ) {
        startObject( "Uncore Counters", BEGIN_OBJECT );
        PCM* pcm = PCM::getInstance();
        printCounter( "DRAM Writes",                   getBytesWrittenToMC    ( before, after ) );
        printCounter( "DRAM Reads",                    getBytesReadFromMC     ( before, after ) );
        if(pcm->nearMemoryMetricsAvailable()){
            printCounter( "NM HitRate",                    getNMHitRate           ( before, after ) );
            printCounter( "NM Hits",                       getNMHits              ( before, after ) );
            printCounter( "NM Misses",                     getNMMisses            ( before, after ) );
            printCounter( "NM Miss Bw",                    getNMMissBW            ( before, after ) );
        }
        printCounter( "Persistent Memory Writes",      getBytesWrittenToPMM   ( before, after ) );
        printCounter( "Persistent Memory Reads",       getBytesReadFromPMM    ( before, after ) );
        printCounter( "Embedded DRAM Writes",          getBytesWrittenToEDC   ( before, after ) );
        printCounter( "Embedded DRAM Reads",           getBytesReadFromEDC    ( before, after ) );
        printCounter( "Memory Controller IA Requests", getIARequestBytesFromMC( before, after ) );
        printCounter( "Memory Controller GT Requests", getGTRequestBytesFromMC( before, after ) );
        printCounter( "Memory Controller IO Requests", getIORequestBytesFromMC( before, after ) );
        printCounter( "Package Joules Consumed",       getConsumedJoules      ( before, after ) );
        printCounter( "PP0 Joules Consumed",           getConsumedJoules      ( 0, before, after ) );
        printCounter( "PP1 Joules Consumed",           getConsumedJoules      ( 1, before, after ) );
        printCounter( "DRAM Joules Consumed",          getDRAMConsumedJoules  ( before, after ) );
        auto uncoreFrequencies = getUncoreFrequencies( before, after );
        for (size_t i = 0; i < uncoreFrequencies.size(); ++i)
        {
            printCounter( std::string("Uncore Frequency Die ") + std::to_string(i), uncoreFrequencies[i]);
        }
        const auto localRatio = int(100.* getLocalMemoryRequestRatio(before, after));
        printCounter( "Local Memory Request Ratio",  int(100.* getLocalMemoryRequestRatio(before, after)) );
        printCounter( "Remote Memory Request Ratio", 100 - localRatio);
        uint32 i = 0;
        for ( ; i < ( PCM::MAX_C_STATE ); ++i ) {
            std::stringstream s;
            s << "CStateResidency[" << i << "]";
            printCounter( s.str(), getPackageCStateResidency( i, before, after ) );
        }
        // Here i == PCM::MAX_STATE so no need to type so many characters ;-)
        std::stringstream s;
        s << "CStateResidency[" << i << "]";
        printCounter( s.str(), getPackageCStateResidency( i, before, after ) );
        endObject( JSONPrinter::NewLineOnly, END_OBJECT );
    }

    void printAccelCounterState( SystemCounterState const& before, SystemCounterState const& after ) {
        AcceleratorCounterState* accs_ = AcceleratorCounterState::getInstance();
        uint32 devs = accs_->getNumOfAccelDevs();
        for ( uint32 i=0; i < devs; ++i ) {
            startObject( std::string( accs_->getAccelCounterName() + " Counters Device " ) + std::to_string( i ), BEGIN_OBJECT );
            for(int j=0;j<accs_->getNumberOfCounters();j++){
                printCounter( accs_->getAccelIndexCounterName(j), accs_->getAccelIndexCounter(i,  before, after,j) );
            }
            // debug prints 
            //for(uint32 j=0;j<accs_->getNumberOfCounters();j++){
            //     std::cout<<accs_->getAccelIndexCounterName(j) << " "<<accs_->getAccelIndexCounter(i,  before, after,j)<<std::endl;
            // }
            // std::cout <<i << " Influxdb "<<accs_->getAccelIndexCounterName()<< accs_->getAccelInboundBW   (i,  before, after ) << " "<< accs_->getAccelOutboundBW   (i,  before, after ) << " "<<accs_->getAccelShareWQ_ReqNb   (i,  before, after ) << " "<<accs_->getAccelDedicateWQ_ReqNb   (i,  before, after ) << std::endl;
            endObject( JSONPrinter::DelimiterAndNewLine, END_OBJECT );
        }
    }

    void printSystemCounterState( SystemCounterState const& before, SystemCounterState const& after ) {
        PCM* pcm = PCM::getInstance();
        uint32 sockets = pcm->getNumSockets();
        uint32 links   = pcm->getQPILinksPerSocket();
        for ( uint32 i=0; i < sockets; ++i ) {
            startObject( std::string( "QPI Counters Socket " ) + std::to_string( i ), BEGIN_OBJECT );
            printCounter( std::string( "CXL Write Cache" ), getCXLWriteCacheBytes   (i,  before, after ) );
            printCounter( std::string( "CXL Write Mem"   ), getCXLWriteMemBytes     (i,  before, after ) );

            for ( uint32 j=0; j < links; ++j ) {
                printCounter( std::string( "Incoming Data Traffic On Link " ) + std::to_string( j ), getIncomingQPILinkBytes      ( i, j, before, after ) );
                printCounter( std::string( "Outgoing Data And Non-Data Traffic On Link " ) + std::to_string( j ), getOutgoingQPILinkBytes      ( i, j, before, after ) );
                printCounter( std::string( "Utilization Incoming Data Traffic On Link " ) + std::to_string( j ), getIncomingQPILinkUtilization( i, j, before, after ) );
                printCounter( std::string( "Utilization Outgoing Data And Non-Data Traffic On Link " ) + std::to_string( j ), getOutgoingQPILinkUtilization( i, j, before, after ) );
            }
            endObject( JSONPrinter::DelimiterAndNewLine, END_OBJECT );
        }
    }

    template <typename Counter>
    void printCounter( std::string const & name, Counter c );

    template <typename Vector>
    void iterateVectorAndCallAccept( Vector const& v );

    void startObject(std::string const& s, char const ch ) {
        std::string name;
        if ( s.size() != 0 )
            name = "\"" + s + "\" : ";
        ss << (indentation++) << name << ch << HTTP_EOL;
    }

    void endObject( enum JSONPrinter::LineEndAction lea, char const ch ) {
        // look 3 chars back, if it is a ',' then delete it.
        // make read same as write position - 3
        std::stringstream::pos_type oldReadPos = ss.tellg();
        ss.seekg( -3, std::ios_base::end );
        if ( ss.peek() == ',' ) {
            ss.seekp( ss.tellg() ); // Make write same as read position
            ss << HTTP_EOL;
        }
        ss.seekg( oldReadPos );// Just making sure the readpointer is set back to where it was

        ss << (--indentation) << ch;

        if ( lea == LineEndAction::NewLineOnly )
            ss << HTTP_EOL;
        else if ( lea == LineEndAction::DelimiterAndNewLine )
            ss << "," << HTTP_EOL;
        else if ( lea == LineEndAction::DelimiterOnly )
            ss << ",";
        else
            throw std::runtime_error( "Unknown LineEndAction enum" );
    }

    void insertListDelimiter() {
        ss << "," << HTTP_EOL;
    }

private:
    Indent            indentation;
    std::pair<std::shared_ptr<Aggregator>,std::shared_ptr<Aggregator>> aggPair_;

    const char BEGIN_OBJECT = '{';
    const char END_OBJECT = '}';
    const char BEGIN_LIST = '[';
    const char END_LIST = ']';
};

template <typename Counter>
void JSONPrinter::printCounter( std::string const & name, Counter c ) {
    if ( std::is_same<Counter, std::string>::value || std::is_same<Counter, char const*>::value )
        ss << indentation << "\"" << name << "\" : \"" << c << "\"," << HTTP_EOL;
    else
        ss << indentation << "\"" << name << "\" : " << c << "," << HTTP_EOL;
}

template <typename Vector>
void JSONPrinter::iterateVectorAndCallAccept(Vector const& v) {
    for ( auto* vecElem: v ) {
        // Inside a list objects are not named
        startObject( "", BEGIN_OBJECT );
        vecElem->accept( *this );
        endObject( JSONPrinter::DelimiterAndNewLine, END_OBJECT );
    }
};

class PrometheusPrinter : Visitor
{
public:
    PrometheusPrinter( std::pair<std::shared_ptr<Aggregator>,std::shared_ptr<Aggregator>> aggregatorPair ) : aggPair_( aggregatorPair ) {
        if ( nullptr == aggPair_.second.get() )
            throw std::runtime_error("BUG: second Aggregator == nullptr!");
        DBG( 2, "Constructor: before=", std::hex, aggPair_.first.get(), ", after=", std::hex, aggPair_.second.get() );
    }

    PrometheusPrinter( PrometheusPrinter const & ) = delete;
    PrometheusPrinter & operator = ( PrometheusPrinter const & ) = delete;
    PrometheusPrinter() = delete;

    CoreCounterState const getCoreCounter( std::shared_ptr<Aggregator> ag, uint32 tid ) const {
        CoreCounterState ccs;
        if ( nullptr == ag.get() )
            return ccs;
        return std::move( ag->coreCounterStates()[tid] );
    }

    SocketCounterState const getSocketCounter( std::shared_ptr<Aggregator> ag, uint32 sid ) const {
        SocketCounterState socs;
        if ( nullptr == ag.get() )
            return socs;
        return std::move( ag->socketCounterStates()[sid] );
    }

    SystemCounterState getSystemCounter( std::shared_ptr<Aggregator> ag ) const {
        SystemCounterState sycs;
        if ( nullptr == ag.get() )
            return sycs;
        return std::move( ag->systemCounterState() );
    }

    virtual void dispatch( HyperThread* ht ) override {
        addToHierarchy( "thread=\"" + std::to_string( ht->threadID() ) + "\"" );
        printCounter( "OS ID", ht->osID() );
        CoreCounterState before = getCoreCounter( aggPair_.first,  ht->osID() );
        CoreCounterState after  = getCoreCounter( aggPair_.second, ht->osID() );
        printBasicCounterState( before, after );
        removeFromHierarchy();
    }

    virtual void dispatch( ServerUncore* su ) override {
        printComment( std::string( "Uncore Counters Socket " ) + std::to_string( su->socketID() ) );
        SocketCounterState before = getSocketCounter( aggPair_.first,  su->socketID() );
        SocketCounterState after  = getSocketCounter( aggPair_.second, su->socketID() );
        printUncoreCounterState( before, after );
    }

    virtual void dispatch( ClientUncore* cu) override {
        printComment( std::string( "Uncore Counters Socket " ) + std::to_string( cu->socketID() ) );
        SocketCounterState before = getSocketCounter( aggPair_.first,  cu->socketID() );
        SocketCounterState after  = getSocketCounter( aggPair_.second, cu->socketID() );
        printUncoreCounterState( before, after );
    }

    virtual void dispatch( Core* c ) override {
        addToHierarchy( std::string( "core=\"" ) + std::to_string( c->socketUniqueCoreID() ) + "\"" );
        auto vec = c->threads();
        iterateVectorAndCallAccept( vec );
        removeFromHierarchy();
    }

    virtual void dispatch( SystemRoot const & s ) override {
        using namespace std::chrono;
        auto interval = duration_cast<microseconds>( aggPair_.second->dispatchedAt() - aggPair_.first->dispatchedAt() ).count();
        printCounter( "Measurement Interval in us", interval );
        auto vec = s.sockets();
        printCounter( "Number of sockets", vec.size() );
        iterateVectorAndCallAccept( vec );
        SystemCounterState before = getSystemCounter( aggPair_.first );
        SystemCounterState after  = getSystemCounter( aggPair_.second );
        addToHierarchy( "aggregate=\"system\"" );
        PCM* pcm = PCM::getInstance();
        if (pcm->getAccel()!=ACCEL_NOCONFIG){
            printComment( "Accelerator Counters" );
            printAccelCounterState(before,after);
        }
        if ( pcm->isServerCPU() && pcm->getNumSockets() >= 2 ) {
            printComment( "UPI/QPI Counters" );
            printSystemCounterState( before, after );
        }
        printComment( "Core Counters Aggregate System" );
        printBasicCounterState ( before, after );
        printComment( "Uncore Counters Aggregate System" );
        printUncoreCounterState( before, after );
        removeFromHierarchy(); // aggregate=system
    }

    virtual void dispatch( Socket* s ) override {
        addToHierarchy( std::string( "socket=\"" ) + std::to_string( s->socketID() ) + "\"" );
        printComment( std::string( "Core Counters Socket " ) + std::to_string( s->socketID() ) );
        auto vec = s->cores();
        iterateVectorAndCallAccept( vec );

        // Uncore writes the comment for the socket uncore counters
        s->uncore()->accept( *this );
        addToHierarchy( "aggregate=\"socket\"" );
        printComment( std::string( "Core Counters Aggregate Socket " ) + std::to_string( s->socketID() ) );
        SocketCounterState before = getSocketCounter( aggPair_.first,  s->socketID() );
        SocketCounterState after  = getSocketCounter( aggPair_.second, s->socketID() );
        printBasicCounterState( before, after );
        removeFromHierarchy(); // aggregate=socket
        removeFromHierarchy(); // socket=x
    }

    std::string str( void ) {
        return ss.str();
    }

private:
    void printBasicCounterState( BasicCounterState const& before, BasicCounterState const& after ) {
        addToHierarchy( "source=\"core\"" );
        printCounter( "Instructions Retired Any", getInstructionsRetired( before, after ) );
        printCounter( "Clock Unhalted Thread",    getCycles             ( before, after ) );
        printCounter( "Clock Unhalted Ref",       getRefCycles          ( before, after ) );
        printCounter( "L3 Cache Misses",          getL3CacheMisses      ( before, after ) );
        printCounter( "L3 Cache Hits",            getL3CacheHits        ( before, after ) );
        printCounter( "L2 Cache Misses",          getL2CacheMisses      ( before, after ) );
        printCounter( "L2 Cache Hits",            getL2CacheHits        ( before, after ) );
        printCounter( "L3 Cache Occupancy",       getL3CacheOccupancy   ( after ) );
        printCounter( "Invariant TSC",            getInvariantTSC       ( before, after ) );
        printCounter( "SMI Count",                getSMICount           ( before, after ) );
#if 0
        // disabling this metric for a moment due to https://github.com/intel/pcm/issues/789
        printCounter( "Core Frequency",           getActiveAverageFrequency ( before, after ) );
#endif
        //DBG( 2, "Invariant TSC before=", before.InvariantTSC, ", after=", after.InvariantTSC, ", difference=", after.InvariantTSC-before.InvariantTSC );

        printCounter( "Thermal Headroom", after.getThermalHeadroom() );
        uint32 i = 0;
        for ( ; i <= ( PCM::MAX_C_STATE ); ++i ) {
            std::stringstream s;
            s << "index=\"" << i << "\"";
            addToHierarchy( s.str() );
            printCounter( "CStateResidency", getCoreCStateResidency( i, before, after ) );
            // need a raw CStateResidency metric because the precision is lost to unacceptable levels when trying
            // to compute CStateResidency for the last second using the existing CStateResidency metric
            printCounter( "RawCStateResidency", getCoreCStateResidency( i, after ) );
            removeFromHierarchy();
        }

        printCounter( "Local Memory Bandwidth", getLocalMemoryBW( before, after ) );
        printCounter( "Remote Memory Bandwidth", getRemoteMemoryBW( before, after ) );
        removeFromHierarchy();
    }

    void printUncoreCounterState( SocketCounterState const& before, SocketCounterState const& after ) {
        PCM* pcm = PCM::getInstance();
        addToHierarchy( "source=\"uncore\"" );
        printCounter( "DRAM Writes",                   getBytesWrittenToMC    ( before, after ) );
        printCounter( "DRAM Reads",                    getBytesReadFromMC     ( before, after ) );
        if(pcm->nearMemoryMetricsAvailable()){
            printCounter( "NM Hits",                       getNMHits              ( before, after ) );
            printCounter( "NM Misses",                     getNMMisses            ( before, after ) );
            printCounter( "NM Miss Bw",                    getNMMissBW            ( before, after ) );
            printCounter( "NM HitRate",                    getNMHitRate           ( before, after ) );
        }
        printCounter( "Persistent Memory Writes",      getBytesWrittenToPMM   ( before, after ) );
        printCounter( "Persistent Memory Reads",       getBytesReadFromPMM    ( before, after ) );
        printCounter( "Embedded DRAM Writes",          getBytesWrittenToEDC   ( before, after ) );
        printCounter( "Embedded DRAM Reads",           getBytesReadFromEDC    ( before, after ) );
        printCounter( "Memory Controller IA Requests", getIARequestBytesFromMC( before, after ) );
        printCounter( "Memory Controller GT Requests", getGTRequestBytesFromMC( before, after ) );
        printCounter( "Memory Controller IO Requests", getIORequestBytesFromMC( before, after ) );
        printCounter( "Package Joules Consumed",       getConsumedJoules      ( before, after ) );
        printCounter( "PP0 Joules Consumed",           getConsumedJoules      ( 0, before, after ) );
        printCounter( "PP1 Joules Consumed",           getConsumedJoules      ( 1, before, after ) );
        printCounter( "DRAM Joules Consumed",          getDRAMConsumedJoules  ( before, after ) );
#if 0
        // disabling these metrics for a moment due to https://github.com/intel/pcm/issues/789
        auto uncoreFrequencies = getUncoreFrequencies( before, after );
        for (size_t i = 0; i < uncoreFrequencies.size(); ++i)
        {
            printCounter( std::string("Uncore Frequency Die ") + std::to_string(i), uncoreFrequencies[i]);
        }
#endif
        uint32 i = 0;
        for ( ; i <= ( PCM::MAX_C_STATE ); ++i ) {
            std::stringstream s;
            s << "index=\"" << i << "\"";
            addToHierarchy( s.str() );
            printCounter( "CStateResidency", getPackageCStateResidency( i, before, after ) );
            // need a CStateResidency raw metric because the precision is lost to unacceptable levels when trying
            // to compute CStateResidency for the last second using the existing CStateResidency metric
            printCounter( "RawCStateResidency", getPackageCStateResidency( i, after ) );
            removeFromHierarchy();
        }
        removeFromHierarchy();
    }

    void printAccelCounterState( SystemCounterState const& before, SystemCounterState const& after )
    {
        addToHierarchy( "source=\"accel\"" );
        AcceleratorCounterState* accs_ = AcceleratorCounterState::getInstance();
        uint32 devs = accs_->getNumOfAccelDevs();
        
        for ( uint32 i=0; i < devs; ++i ) 
        {
            addToHierarchy( std::string( accs_->getAccelCounterName() + "device=\"" ) + std::to_string( i ) + "\"" );
            for(int j=0;j<accs_->getNumberOfCounters();j++)
            {        
                printCounter( accs_->remove_string_inside_use(accs_->getAccelIndexCounterName(j)), accs_->getAccelIndexCounter(i,  before, after,j) );
            }
            removeFromHierarchy();
        }
        removeFromHierarchy();
    }

    void printSystemCounterState( SystemCounterState const& before, SystemCounterState const& after ) {
        addToHierarchy( "source=\"uncore\"" );
        PCM* pcm = PCM::getInstance();
        uint32 sockets = pcm->getNumSockets();
        uint32 links   = pcm->getQPILinksPerSocket();
        for ( uint32 i=0; i < sockets; ++i ) {
            addToHierarchy( std::string( "socket=\"" ) + std::to_string( i ) + "\"" );
            printCounter( std::string( "CXL Write Cache" ), getCXLWriteCacheBytes   (i,  before, after ) );
            printCounter( std::string( "CXL Write Mem"   ), getCXLWriteMemBytes     (i,  before, after ) );
            for ( uint32 j=0; j < links; ++j ) {
                printCounter( std::string( "Incoming Data Traffic On Link " ) + std::to_string( j ),                          getIncomingQPILinkBytes      ( i, j, before, after ) );
                printCounter( std::string( "Outgoing Data And Non-Data Traffic On Link " ) + std::to_string( j ),             getOutgoingQPILinkBytes      ( i, j, before, after ) );
                printCounter( std::string( "Utilization Incoming Data Traffic On Link " ) + std::to_string( j ),              getIncomingQPILinkUtilization( i, j, before, after ) );
                printCounter( std::string( "Utilization Outgoing Data And Non-Data Traffic On Link " ) + std::to_string( j ), getOutgoingQPILinkUtilization( i, j, before, after ) );
            }
            removeFromHierarchy();
        }
        removeFromHierarchy();
    }

    std::string replaceIllegalCharsWithUnderbar( std::string const& s ) {
        size_t pos = 0;
        std::string str(s);
        while ( ( pos = str.find( '-', pos ) ) != std::string::npos ) {
            str.replace( pos, 1, "_" );
        }
        pos = 0;
        while ( ( pos = str.find( ' ', pos ) ) != std::string::npos ) {
            str.replace( pos, 1, "_" );
        }
        return str;
    }

    void addToHierarchy( std::string const& s ) {
        hierarchy_.push_back( s );
    }

    void removeFromHierarchy() {
        hierarchy_.pop_back();
    }

    std::string printHierarchy() {
        std::string s(" ");
        if (hierarchy_.size() == 0 )
            return s;
        s = "{";
        for(const auto & level : hierarchy_ ) {
            s += level + ',';
        }
        s.pop_back();
        s += "} ";
        return s;
    }

    template <typename Counter>
    void printCounter( std::string const & name, Counter c );

    void printComment( std::string const &comment ) {
        ss << "# " << comment << PROM_EOL;
    }

    template <typename Vector>
    void iterateVectorAndCallAccept( Vector const& v );

private:
    std::pair<std::shared_ptr<Aggregator>,std::shared_ptr<Aggregator>> aggPair_;
    std::vector<std::string> hierarchy_;
};

template <typename Counter>
void PrometheusPrinter::printCounter( std::string const & name, Counter c ) {
        ss << replaceIllegalCharsWithUnderbar(name) << printHierarchy() << c << PROM_EOL;
}

template <typename Vector>
void PrometheusPrinter::iterateVectorAndCallAccept(Vector const& v) {
    for ( auto* vecElem: v ) {
        vecElem->accept( *this );
    }
};

}  // end anonymous namespace

#if defined (USE_SSL)
void closeSSLConnectionAndFD( socket_t fd, SSL* ssl ) {
    int ret;

    if ( (ret = SSL_shutdown( ssl )) == 0 ) {
        DBG( 3, "first shutdown returned: ", ret );
        // Call it again when it returns 0, it has sent the notification but not received it back yet
        if ( (ret = SSL_shutdown( ssl )) != 1 )
            // Big trouble but we did all we could.
            DBG( 3, "Could not shutdown the SSL connection the second time... ret: ", ret );
    }
    ERR_clear_error();
    SSL_free( ssl ); // Free the SSL structure to prevent memory leaks
    // cppcheck-suppress uselessAssignmentPtrArg
    ssl = nullptr;
    DBG( 3, "close fd" );
    ::close( fd );
}
#endif

template <std::size_t SIZE = 256, class CharT = char, class Traits = std::char_traits<CharT>>
class basic_socketbuf : public std::basic_streambuf<CharT> {
public:
    basic_socketbuf(const basic_socketbuf&) = delete;
    basic_socketbuf & operator = (const basic_socketbuf&) = delete;
    using Base = std::basic_streambuf<CharT>;
    using char_type   = typename Base::char_type;
    using int_type    = typename Base::int_type;
    using traits_type = typename Base::traits_type;

    basic_socketbuf( std::string dbg_ = std::string("Server: ") ): socketFD_(INVALID_SOCKET), dbg(dbg_) {
        // According to http://en.cppreference.com/w/cpp/io/basic_streambuf
        // epptr and egptr point beyond the buffer, so start + SIZE
        Base::setp( outputBuffer_, outputBuffer_ + SIZE );
        Base::setg( inputBuffer_, inputBuffer_, inputBuffer_ );
        // Default timeout of 10 seconds and 0 microseconds
#ifdef _WIN32
        timeout_ = 10000; // Windows uses milliseconds
#else
        timeout_ = { 10, 0 };
#endif
#if defined (USE_SSL)
        // I guess one could say that the instantiation of the ptr in this object will always be 0, i just want this to be explicit for now
        // cppcheck-suppress uselessAssignmentPtrArg
        ssl_ = nullptr;
#endif
    }

    virtual ~basic_socketbuf() {
        close();
        DBG( 3, dbg, "socketbuf destructor finished" );
    }

    socket_t socket() {
        return socketFD_;
    }

    void setSocket( socket_t socketFD ) {
        socketFD_ = socketFD;
        if( INVALID_SOCKET == socketFD )  // avoid work with invalid socket after closure
            return;
        // When receiving the socket descriptor, set the timeout
#ifdef _WIN32
        DWORD timeout_ms = timeout_;
        const auto res = setsockopt( socketFD_, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout_ms, sizeof(DWORD) );
#else
        const auto res = setsockopt( socketFD_, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout_, sizeof(struct timeval) );
#endif
        if (res != 0)
        {
#ifdef _WIN32
            std::cerr << "setsockopt failed while setting timeout value, error: " << WSAGetLastError() << "\n";
#else
            std::cerr << "setsockopt failed while setting timeout value, " << strerror( errno ) << "\n";
#endif
        }
    }

#ifdef _WIN32
    void setTimeout( DWORD t ) {
        timeout_ = t;
        const auto res = setsockopt( socketFD_, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout_, sizeof(DWORD) );
#else
    void setTimeout( struct timeval t ) {
        timeout_ = t;
        const auto res = setsockopt( socketFD_, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout_, sizeof(struct timeval) );
#endif
        if (res != 0)
        {
#ifdef _WIN32
            std::cerr << "setsockopt failed while setting timeout value, error: " << WSAGetLastError() << "\n";
#else
            std::cerr << "setsockopt failed while setting timeout value, " << strerror( errno ) << "\n";
#endif
        }
    }

#if defined (USE_SSL)
    SSL* ssl() {
        return ssl_;
    }

    void setSSL( SSL* ssl ) {
        if ( nullptr != ssl_ )
            throw std::runtime_error( "BUG: You can set the SSL pointer only once" );
        if ( nullptr == ssl )
            throw std::runtime_error( "BUG: Trying to set a nullptr as ssl" );
        ssl_ = ssl;
    }
#endif

    void close() {
        basic_socketbuf::sync();
#if defined (USE_SSL)
        if ( nullptr != ssl_ ) {
            SSL_shutdown( ssl_ );
            ERR_clear_error();
            SSL_free( ssl_ );
            ssl_ = nullptr;
        }
#endif
        if ( INVALID_SOCKET != socketFD_ ) {
            DBG( 3, dbg, "close clientsocketFD" );
            ::close( socketFD_ );
            socketFD_ = INVALID_SOCKET;
        }
    }

protected:
    int_type writeToSocket() {
        size_t bytesToSend;
        int bytesSent;
        bytesToSend = (char*)Base::pptr() - (char*)Base::pbase();
        DBG( 3, dbg, "wts: Bytes to send: ", bytesToSend );

#if defined (USE_SSL)
        if ( nullptr == ssl_ ) {
#endif
#ifdef _WIN32
            bytesSent= ::send( socketFD_, (const char*)outputBuffer_, static_cast<int>(bytesToSend), MSG_NOSIGNAL );
#else
            bytesSent= ::send( socketFD_, (void*)outputBuffer_, bytesToSend, MSG_NOSIGNAL );
#endif
            if ( SOCKET_ERROR == bytesSent ) {
#ifdef _WIN32
                DBG( 3, "bytesSent == SOCKET_ERROR: WSAGetLastError: ", WSAGetLastError(), ", returning eof..." );
#else
                DBG( 3, "bytesSent == -1: strerror( ", errno, " ): ", strerror( errno ), ", returning eof..." );
#endif
                return traits_type::eof();
            }
#if defined (USE_SSL)
        }
        else {
            while( 1 ) {
                // openSSL has no support for setting the MSG_NOSIGNAL during send
                // but we ignore sigpipe so we should be fine
                bytesSent = SSL_write( ssl_, (void*)outputBuffer_, bytesToSend );
                DBG( 3, dbg, "wts: SSL_write returned for bytesSent: ", bytesSent );
                if ( 0 >= bytesSent ) {
                    int sslError = SSL_get_error( ssl_, bytesSent );
                    if ( sslError == SSL_ERROR_ZERO_RETURN ) {
                        // TSL/SSL Connection has been closed, the underlying socket may not though
                        return traits_type::eof();
                    } else {
                        DBG( 3, dbg, "wts: SSL_get_error returned: ", sslError );
                        ERR_clear_error(); // Clear error because SSL_get_error does not do so
                        switch ( sslError ) {
                            case SSL_ERROR_WANT_READ:
                            case SSL_ERROR_WANT_WRITE:
                                DBG( 3, dbg, "wts: Want read or write or error none. Trying SSL_write again...");
                                // retry
                                continue; // Should continue in the while loop and attempt to write again
//                                break;
                            case SSL_ERROR_SYSCALL:
                                DBG( 3, dbg, "wts: errno is: ", errno, " strerror(errno): ", strerror(errno) );
                                if ( errno == 0 )
                                    return 0;
                                /* fall-through */
                            case SSL_ERROR_SSL:
                            default:
                                DBG( 3, dbg, "wts: SSL_write, syscall, ssl or default. Returning eof" );
                                return traits_type::eof();
                        }
                    }
                } else {
                    // Valid write
                    break; // out of the while loop
                }
            }
        }
#endif
        Base::pbump( -bytesSent );
        return bytesSent;
    }

    int sync() override {
        DBG( 3, dbg, "sync socketFD_: ", socketFD_ );
        if ( INVALID_SOCKET == socketFD_ ) // Socket is closed already
            return 0;

        DBG( 3, dbg, "sync: Calling writeToSocket()" );
        int_type ret = writeToSocket();
        DBG( 3, dbg, "sync: writeToSocket returned: ", ret );
        if ( traits_type::eof() == ret )
            return -1;
        return 0;
    }

    virtual int_type overflow( int_type ch ) override {
        // send data in buffer and reset it
        if ( traits_type::eof() != ch ) {
            *Base::pptr() = ch;
            Base::pbump(1);
        }
        int_type bytesWritten = 0;
        if ( traits_type::eof() == (bytesWritten = writeToSocket()) ) {
            return traits_type::eof();
        }
        return bytesWritten; // Anything but traits_type::eof() to signal ok.
    }

    virtual int_type underflow() override {
        std::fill(inputBuffer_, inputBuffer_ + SIZE, 0);
        int bytesReceived;

#if defined (USE_SSL)
        if ( nullptr == ssl_ ) {
#endif
            DBG( 3, dbg, "Socketbuf: Read from socket:" );
#ifdef _WIN32
            bytesReceived = ::recv( socketFD_, static_cast<char*>(inputBuffer_), SIZE * sizeof( char_type ), 0 );
#else
            bytesReceived = ::read( socketFD_, static_cast<char*>(inputBuffer_), SIZE * sizeof( char_type ) );
#endif
            if ( 0 == bytesReceived ) {
                // Client closed the socket normally, we will do the same
                close();
                return traits_type::eof();
            }
            if ( SOCKET_ERROR == bytesReceived ) {
#ifdef _WIN32
                int err = WSAGetLastError();
                if ( err )
                    DBG( 3, dbg, "WSAError: ", err );
#else
                if ( errno )
                    DBG( 3, dbg, "Errno: ", errno, ", (", strerror( errno ) , ")" );
#endif
                close();
                Base::setg( nullptr, nullptr, nullptr );
                return traits_type::eof();
            }
            DBG( 3, dbg, "Bytes received: ", bytesReceived );
            debug::dyn_hex_table_output( 3, std::cout, bytesReceived, inputBuffer_ );
            DBG( 3, dbg, "End", std::dec );
#if defined (USE_SSL)
        }
        else {
            bool loopAgain = true;
            while (loopAgain) {
                bytesReceived = SSL_read( ssl_, static_cast<void*>(inputBuffer_), SIZE * sizeof( char_type ) );
                DBG( 3, dbg, "SSL_read: bytesReceived: ", bytesReceived );
                if ( 0 >= bytesReceived ) {
                    int sslError = SSL_get_error( ssl_, bytesReceived );
                    if ( sslError == SSL_ERROR_ZERO_RETURN ) {
                        // TSL/SSL Connection has been closed, the underlying socket may not though
                        throw std::runtime_error( "SSL_read returned SSL_ERROR_ZERO_RETURN, connection was closed" );
                    } else {
                        DBG( 3, dbg, "SSL_read: sslError: ", sslError );
                        int err = 0;
                        char buf[256];
                        err = ERR_get_error();
                        DBG( 3, dbg, "ERR_get_error(): ", err  );
                        ERR_error_string( err, buf );
                        DBG( 3, dbg, "ERR_error_string(): ", buf );
                        ERR_clear_error(); // Clear error because SSL_get_error does not do so
                        //ERR_print_errors_fp(stderr);
                        switch ( sslError ) {
                            case SSL_ERROR_WANT_READ:
                                DBG( 3, "SSL_ERROR_WANT_READ: Errno = ", errno, ", strerror(errno): ", strerror(errno) );
                                if ( errno == EAGAIN || errno == EWOULDBLOCK ) {
                                    DBG( 3, dbg, "Most likely the set timeout, so aborting..." );
                                    close();
                                    Base::setg( nullptr, nullptr, nullptr );
                                    DBG( 3, dbg, "return eof" );
                                    return traits_type::eof();
                                }
                            /* fall-through */
                            case SSL_ERROR_WANT_WRITE:
                                // retry
                                loopAgain = true; // Should continue in the while loop and attempt to read again
                                break;
                            case SSL_ERROR_SYSCALL:
                                DBG( 3, "SSL_ERROR_SYSCALL: Errno = ", errno );
                                if ( errno == EAGAIN || errno == EWOULDBLOCK ) {
                                    DBG( 3, dbg, "Most likely the set timeout, so aborting..." );
                                    close();
                                    Base::setg( nullptr, nullptr, nullptr );
                                    DBG( 3, dbg, "return eof" );
                                    return traits_type::eof();
                                }
                                /* fall-through */
                            case SSL_ERROR_SSL:
                            default:
                                 close();
                                 Base::setg( nullptr, nullptr, nullptr );
                                 DBG( 3, dbg, "return eof" );
                                 return traits_type::eof();
                        }
                    }
                } else {
                    // Valid read
                    ERR_get_error();
                    ERR_clear_error();
                    loopAgain = false; // out of the while loop
                }
            }
        }
#endif
        // In case the number of bytes read is not the size of the buffer, we have to set
        // egptr to start plus the number of bytes received
        Base::setg( inputBuffer_, inputBuffer_, inputBuffer_ + bytesReceived );
        return *inputBuffer_;
    }

protected:
    CharT outputBuffer_[SIZE];
    CharT inputBuffer_[SIZE];
    socket_t socketFD_;
#ifdef _WIN32
    DWORD timeout_;
#else
    struct timeval timeout_;
#endif
    std::string dbg;
#if defined (USE_SSL)
    SSL*  ssl_;
#endif
};

template <class CharT, class Traits = std::char_traits<CharT>>
class basic_socketstream : public std::basic_iostream<CharT, Traits> {
public:
    using Base = std::basic_iostream<CharT, Traits>;
    using stream_type = typename std::basic_iostream<CharT, Traits>;
    using buf_type = basic_socketbuf<16385, CharT, Traits>;
    using traits_type = typename Base::traits_type;

public:
    basic_socketstream(const basic_socketstream &) = delete;
    virtual ~basic_socketstream() = default;
    basic_socketstream & operator = (const basic_socketstream &) = delete;
    basic_socketstream() : stream_type( &socketBuffer_ ) {}
#if defined (USE_SSL)
    basic_socketstream( socket_t socketFD, SSL* ssl, std::string dbg_ = "Server: " ) : stream_type( &socketBuffer_ ), dbg( dbg_ ), socketBuffer_( dbg_ ) {
        DBG( 3, dbg, "socketFD = ", socketFD );
        if ( INVALID_SOCKET == socketFD ) {
            DBG( 3, dbg, "Trying to set socketFD to INVALID_SOCKET which is not allowed!" );
            throw std::runtime_error( "Trying to set socketFD to INVALID_SOCKET on basic_socketstream level which is not allowed." );
        }
        socketBuffer_.setSocket( socketFD );

        if ( nullptr != ssl )
            socketBuffer_.setSSL( ssl );
    }
#endif

    basic_socketstream( socket_t socketFD ) : stream_type( &socketBuffer_ ) {
        DBG( 3, dbg, "socketFD = ", socketFD );
        if ( INVALID_SOCKET == socketFD ) {
            DBG( 3, dbg, "Trying to set socketFD to INVALID_SOCKET which is not allowed!" );
            throw std::runtime_error( "Trying to set socketFD to INVALID_SOCKET on basic_socketstream level which is not allowed." );
        }
        socketBuffer_.setSocket( socketFD );
    }

public:
    // For clients only, servers will have to create a socketstream
    // by providing a socket descriptor in the constructor
    int open( std::string& hostname, uint16_t port ) {
        if ( hostname.empty() )
            return -1;
        if ( port == 0 )
            return -2;

        struct addrinfo* address;
        int retval = 0;

        retval = getaddrinfo( hostname.c_str(), nullptr, nullptr, &address );
        if ( 0 != retval ) {
            perror( "getaddrinfo" );
            return -3;
        }

        int sockfd = socket( address->ai_family, address->ai_socktype, address->ai_protocol );
        if ( -1 == sockfd ) {
            freeaddrinfo( address );
            return -4;
        }

        retval = connect( sockfd, address->ai_addr, address->ai_addrlen );
        if ( -1 == retval ) {
            DBG( 3, dbg, "close clientsocketFD" );
            ::close( sockfd );
            freeaddrinfo( address );
            return -5;
        }

        freeaddrinfo( address );

        socketBuffer_.setSocket( sockfd );
    }

    // might be useful in the future so leaving it in
//    std::string getLine() {
//        if ( !socketBuffer_.socket() )
//            throw std::runtime_error( "The socket is not or no longer open!" );
//        std::string result;
//        CharT chr;
//        while( '\n' != ( chr = Base::get()) ) {
//            result += chr;
//        }
//        result += chr;
//        return result;
//    }

    bool usesSSL() {
#ifdef USE_SSL
        return ( socketBuffer_.ssl() != nullptr );
#else
        return false;
#endif
    }

    void putLine( std::string& line ) {
        if ( INVALID_SOCKET == socketBuffer_.socket() )
            throw std::runtime_error( "The socket is not or no longer open!" );
        DBG( 3, dbg, "socketstream::putLine: putting \"", line, "\" into the socket." );
        Base::write( line.c_str(), line.size() );
    }

    void close() {
        DBG( 3, dbg, "close clientsocketFD" );
        socketBuffer_.close();
    }

protected:
    std::string dbg;
    buf_type socketBuffer_;
};

typedef basic_socketstream<char> socketstream;
typedef basic_socketstream<wchar_t> wsocketstream;

class Server {
public:
    Server() = delete;
    Server( const std::string & listenIP, uint16_t port, bool useIPv4 = false ) noexcept( false ) : listenIP_(listenIP), wq_( WorkQueue::getInstance() ), port_( port ), useIPv4_( useIPv4 ) {
        DBG( 3, "Initializing Server" );
#ifdef _WIN32
        // Initialize Winsock on Windows
        WSADATA wsaData;
        int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
        if (result != 0) {
            throw std::runtime_error(std::string("WSAStartup failed: ") + std::to_string(result));
        }
        // Verify that Winsock 2.2 or higher is available
        if (LOBYTE(wsaData.wVersion) < 2 || (LOBYTE(wsaData.wVersion) == 2 && HIBYTE(wsaData.wVersion) < 2)) {
            WSACleanup();
            throw std::runtime_error(std::string("Winsock 2.2 or higher required. Found version: ") + 
                                   std::to_string(LOBYTE(wsaData.wVersion)) + "." + std::to_string(HIBYTE(wsaData.wVersion)));
        }
#endif
        serverSocket_ = initializeServerSocket();
        SignalHandler* shi = SignalHandler::getInstance();
        shi->setSocket( serverSocket_ );
#ifndef _WIN32
        shi->ignoreSignal( SIGPIPE ); // Sorry Dennis Ritchie, we do not care about this, we always check return codes
#endif
#ifndef UNIT_TEST // libFuzzer installs own signal handlers
#ifndef _WIN32
        shi->installHandler( SignalHandler::handleSignal, SIGTERM );
        shi->installHandler( SignalHandler::handleSignal, SIGINT );
#else
        shi->installHandler( nullptr, 0 ); // Windows uses SetConsoleCtrlHandler
#endif
#endif
    }
    Server( Server const & ) = delete;
    Server & operator = ( Server const & ) = delete;
    virtual ~Server() {
        wq_ = nullptr;
#ifdef _WIN32
        WSACleanup();
#endif
    }

public:
    virtual void run() = 0;

private:
    socket_t initializeServerSocket() {
        if ( port_ == 0 )
            throw std::runtime_error( "Server Constructor: No port specified." );

        bool useIPv4 = false;
#ifdef _WIN32
        // On Windows, use IPv4 by default for better compatibility
        socket_t sockfd = ::socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
        if ( INVALID_SOCKET == sockfd )
        {
            throw std::runtime_error( std::string("Server Constructor: Can't create socket. WSAGetLastError: ") + std::to_string(WSAGetLastError()) );
        }
        useIPv4 = true;
#else
        // On non-Windows systems, use IPv6 by default unless IPv4 is explicitly requested
        useIPv4 = useIPv4_;
        socket_t sockfd;
        if ( useIPv4 ) {
            sockfd = ::socket( AF_INET, SOCK_STREAM, 0 );
            if ( INVALID_SOCKET == sockfd )
            {
                throw std::runtime_error( "Server Constructor: Can't create IPv4 socket" );
            }
        } else {
            sockfd = ::socket( AF_INET6, SOCK_STREAM, 0 );
            if ( INVALID_SOCKET == sockfd )
            {
                throw std::runtime_error( "Server Constructor: Can't create IPv6 socket" );
            }
        }
#endif

        int retval = 0;

        if (useIPv4) {
            // Use IPv4
            struct sockaddr_in serv4;
            memset(&serv4, 0, sizeof(serv4));
            serv4.sin_family = AF_INET;
            serv4.sin_port = htons( port_ );
            if ( listenIP_.empty() )
                serv4.sin_addr.s_addr = INADDR_ANY;
            else {
                if ( 1 != ::inet_pton( AF_INET, listenIP_.c_str(), &(serv4.sin_addr) ) )
                {
                    DBG( 3, "close clientsocketFD" );
#ifdef _WIN32
                    closesocket(sockfd);
#else
                    ::close(sockfd);
#endif
                    throw std::runtime_error(std::string("Server Constructor: Cannot convert IP string ") + listenIP_ + " to IPv4 address");
                }
            }
            socklen_t len = sizeof( struct sockaddr_in );
            retval = ::bind( sockfd, reinterpret_cast<struct sockaddr*>(&serv4), len );
        } else {
            // Use IPv6
            struct sockaddr_in6 serv;
            serv.sin6_family = AF_INET6;
            serv.sin6_port = htons( port_ );
            if ( listenIP_.empty() )
                serv.sin6_addr = in6addr_any;
            else {
                if ( 1 != ::inet_pton( AF_INET6, listenIP_.c_str(), &(serv.sin6_addr) ) )
                {
                    DBG( 3, "close clientsocketFD" );
#ifdef _WIN32
                    closesocket(sockfd);
#else
                    ::close(sockfd);
#endif
                    throw std::runtime_error( std::string("Server Constructor: Cannot convert IP string ") + listenIP_ + " to IPv6 address" );
                }
            }
            socklen_t len = sizeof( struct sockaddr_in6 );
            retval = ::bind( sockfd, reinterpret_cast<struct sockaddr*>(&serv), len );
        }
        if ( 0 != retval ) {
            DBG( 3, "close clientsocketFD" );
#ifdef _WIN32
            closesocket( sockfd );
#else
            ::close( sockfd );
#endif
            throw std::runtime_error( std::string("Server Constructor: Cannot bind to port ") + std::to_string(port_) );
        }

        retval = listen( sockfd, 64 );
        if ( 0 != retval ) {
            DBG( 3, "close clientsocketFD" );
#ifdef _WIN32
            closesocket( sockfd );
#else
            ::close( sockfd );
#endif
            throw std::runtime_error( "Server Constructor: Cannot listen on socket" );
        }
        // Here everything should be fine, return socket fd
        return sockfd;
    }

protected:
    std::string  listenIP_;
    WorkQueue*   wq_;
    socket_t     serverSocket_;
    uint16_t     port_;
    bool         useIPv4_;
};

enum HTTPRequestMethod {
    GET = 1,
    HEAD,
    POST,
    PUT,
    HTTP_DELETE,  // Renamed from DELETE to avoid conflict with Windows macro
    CONNECT,
    OPTIONS,
    TRACE,
    PATCH,
    HTTPRequestMethod_Spare = 255 // To save some space for future methods
};

enum HTTPProtocol {
    InvalidProtocol = 0,
    HTTP_0_9,
    HTTP_1_0,
    HTTP_1_1,
    HTTP_2_0,
    HTTPProtocol_Spare = 255
};

enum HTTPResponseCode {
    RC_100_Continue = 100,
    RC_101_SwitchingProtocols,
    RC_102_Processing,
    RC_200_OK = 200,
    RC_201_Created,
    RC_202_Accepted,
    RC_203_NonAuthorativeInformation,
    RC_204_NoContent,
    RC_205_ResetContent,
    RC_206_PartialContent,
    RC_207_MultiStatus,
    RC_208_AlreadyReported,
    RC_226_IMUsed = 226,
    RC_300_MultipleChoices = 300,
    RC_301_MovedPermanently,
    RC_302_Found,
    RC_303_SeeOther,
    RC_304_NotModified,
    RC_305_UseProxy,
    RC_307_TemporaryRedirect = 307,
    RC_308_PermanentRedirect,
    RC_400_BadRequest = 400,
    RC_401_Unauthorized,
    RC_402_PaymentRequired,
    RC_403_Forbidden,
    RC_404_NotFound,
    RC_405_MethodNotAllowed,
    RC_406_NotAcceptable,
    RC_407_ProxyAuthenticationRequired,
    RC_408_RequestTimeout,
    RC_409_Conflict,
    RC_410_Gone,
    RC_411_LengthRequired,
    RC_412_PreconditionFailed,
    RC_413_PayloadTooLarge,
    RC_414_RequestURITooLong,
    RC_415_UnsupportedMediaType,
    RC_416_RequestRangeNotSatisfiable,
    RC_417_ExpectationFailed,
    RC_418_ImATeapot,
    RC_421_MisdirectedRequest = 421,
    RC_422_UnprocessableEntity,
    RC_423_Locked,
    RC_424_FailedDependency,
    RC_426_UpgradeRequired = 426,
    RC_428_PreconditionRequired = 428,
    RC_429_TooManyRequests,
    RC_431_RequestHeaderFieldsTooLarge = 431,
    RC_444_ConnectionClosedWithoutResponse = 444,
    RC_451_UnavailableForLegalReasons = 451,
    RC_499_ClientClosedRequest = 499,
    RC_500_InternalServerError,
    RC_501_NotImplemented,
    RC_502_BadGateway,
    RC_503_ServiceUnavailable,
    RC_504_GatewayTimeout,
    RC_505_HTTPVersionNotSupported,
    RC_506_VariantAlsoNegotiates,
    RC_507_InsufficientStorage,
    RC_508_LoopDetected,
    RC_510_NotExtended = 510,
    RC_511_NetworkAuthenticationRequired,
    RC_599_NetworkConnectTimeoutError = 599,
    HTTPReponseCode_Spare = 1000 // Filler
};

enum HTTPRequestHasBody {
    No = 0,
    Optional = 1,
    Required = 2
};

class HTTPMethodProperties {
private:
    // Embedded declaration, no need for this info outside of this container class
    struct HTTPMethodProperty {
        enum HTTPRequestMethod method_;
        std::string methodName_;
        enum HTTPRequestHasBody requestHasBody_;
        bool responseHasBody_;
    };

public:
    static enum HTTPRequestMethod getMethodAsEnum( std::string const& rms ) {
        static HTTPMethodProperties props_;
        struct HTTPMethodProperty const& prop = props_.findProperty( rms );
        return prop.method_;
    }
    static std::string const& getMethodAsString( enum HTTPRequestMethod rme ) {
        static HTTPMethodProperties props_;
        struct HTTPMethodProperty const& prop = props_.findProperty( rme );
        return prop.methodName_;
    }
    static enum HTTPRequestHasBody requestHasBody( enum HTTPRequestMethod rme ) {
        static HTTPMethodProperties props_;
        struct HTTPMethodProperty const& prop = props_.findProperty( rme );
        return prop.requestHasBody_;
    }
    static bool responseHasBody( enum HTTPRequestMethod rme ) {
        static HTTPMethodProperties props_;
        struct HTTPMethodProperty const& prop = props_.findProperty( rme );
        return prop.responseHasBody_;
    }

private:
    struct HTTPMethodProperty const& findProperty( std::string rm ) {
        for( auto& prop : httpMethodProperties )
            if ( prop.methodName_ == rm )
                return prop;
        throw std::runtime_error( "HTTPMethodProperties::findProperty: HTTPRequestMethod as string not found." );
    }
    struct HTTPMethodProperty const& findProperty( enum HTTPRequestMethod rm ) {
        for( auto& prop : httpMethodProperties )
            if ( prop.method_ == rm )
                return prop;
        throw std::runtime_error( "HTTPMethodProperties::findProperty: HTTPRequestMethod as enum not found." );
    }

    std::vector<struct HTTPMethodProperty> const httpMethodProperties = {
        { GET,         "GET",     HTTPRequestHasBody::No,       true  },
        { HEAD,        "HEAD",    HTTPRequestHasBody::No,       false },
        { POST,        "POST",    HTTPRequestHasBody::Required, true  },
        { PUT,         "PUT",     HTTPRequestHasBody::Required, true  },
        { HTTP_DELETE, "DELETE",  HTTPRequestHasBody::No,       true  },
        { CONNECT,     "CONNECT", HTTPRequestHasBody::Required, true  },
        { OPTIONS,     "OPTIONS", HTTPRequestHasBody::Optional, true  },
        { TRACE,       "TRACE",   HTTPRequestHasBody::No,       true  },
        { PATCH,       "PATCH",   HTTPRequestHasBody::Required, true  }
    };
};

enum HeaderType {
    ServerSet = -2,
    Invalid = -1,
    Unspecified = 0,
    String = 1,
    Integer = 2,
    Float = 3,
    Date = 4,
    Range = 5,
    True = 7, // Only allowed value is "true", all lowercase
    Email = 8,
    ETag = 9,
    DateOrETag = 10,
    Parameters = 11,
    Url = 12,
    HostPort = 13,
    ProtoHostPort = 14,
    DateOrSeconds = 15,
    NoCache = 16,
    IP = 17,
    Character = 18,
    OnOff = 19,
    ContainsOtherHeaders = 20,
    StarOrFQURL = 21,
    CustomHeader = 22,
    HeaderType_Spare = 127 // Reserving some values
};

class HTTPHeaderProperties {
private:
    struct HTTPHeaderProperty {
        HTTPHeaderProperty( std::string name, enum HeaderType ht, bool w = false, bool l = false, char lsc = ',' ) :
            name_( name ), type_( ht ), canBeWeighted_( w ), canBeAList_( l ), listSeparatorChar_( lsc ) {}

        std::string     name_;
        enum HeaderType type_;
        bool canBeWeighted_;
        bool canBeAList_;
        char listSeparatorChar_;
    };

    std::unordered_map<enum HeaderType, std::string, std::hash<int>> const headerTypeToString_ = {
        { ServerSet, "ServerSet" },
        { Invalid, "Invalid" },
        { Unspecified, "Unspecified" },
        { String, "String" },
        { Integer, "Integer" },
        { Float, "Float" },
        { Date, "Date" },
        { Range, "Range" },
        { True, "True" },
        { Email, "Email" },
        { ETag, "ETag" },
        { DateOrETag, "DateOrETag" },
        { Parameters, "Parameters" },
        { Url, "Url" },
        { HostPort, "HostPort" },
        { ProtoHostPort, "ProtoHostPort" },
        { DateOrSeconds, "DateOrSeconds" },
        { NoCache, "NoCache" },
        { IP, "IP" },
        { Character, "Character" },
        { OnOff, "OnOff" },
        { ContainsOtherHeaders, "ContainsOtherHeaders" },
        { StarOrFQURL, "StarOrFQURL" },
        { CustomHeader, "CustomHeader" }
    };

public:
    static enum HeaderType headerType( std::string const & str ) {
        static HTTPHeaderProperties props;
        for ( auto& prop : props.httpHeaderProperties ) {
            if ( prop.name_ == str )
                return prop.type_;
        }
        return CustomHeader;
    }
    static char listSeparatorChar( std::string const & headerName ) {
        static HTTPHeaderProperties props;
        for ( auto& prop : props.httpHeaderProperties ) {
            if ( prop.name_ == headerName )
                return prop.listSeparatorChar_;
        }
        return ',';
    }
    static std::string const& headerTypeAsString( enum HeaderType ht ) {
        static HTTPHeaderProperties props;
        return props.headerTypeToString_.at( ht );
    }

private:
    // Contains most if not all headers from RFC2616 RFC7230 and RFC7231
    // This is a mix of request and response headers!
    // Please add if you find that headers are missing
    std::vector<HTTPHeaderProperty> const httpHeaderProperties = {
        { "Accept", HeaderType::String, true, true },
        { "Accept-Charset", HeaderType::String, true, true },
        { "Accept-Encoding", HeaderType::String, true, true },
        { "Accept-Language", HeaderType::String, true, true },
        { "Accept-Ranges", HeaderType::String, false, false },
        { "Access-Control-Allow-Credentials", HeaderType::True, false, false },
        { "Access-Control-Allow-Headers", HeaderType::String, false, true },
        { "Access-Control-Allow-Methods", HeaderType::String, false, true },
        { "Access-Control-Allow-Origin", HeaderType::StarOrFQURL, false, false },
        { "Access-Control-Expose-Headers", HeaderType::String, false, true },
        { "Access-Control-Max-Age", HeaderType::Integer, false, false },
        { "Access-Control-Request-Headers", HeaderType::String, false, true },
        { "Access-Control-Request-Method", HeaderType::String, false, false },
        { "Age", HeaderType::Integer, false ,false },
        { "Allow", HeaderType::String, false, true },
        { "Authorization", HeaderType::String, false, false },
        { "Cache-Control", HeaderType::String, false, true },
        { "Connection", HeaderType::String, false, false },
        { "Content-Disposition", HeaderType::String, false, false },
        { "Content-Encoding", HeaderType::String, false, true },
        { "Content-Language", HeaderType::String, false, true },
        { "Content-Length", HeaderType::Integer, false, false },
        { "Content-Location", HeaderType::Url, false, false },
        { "Content-Range", HeaderType::Range, false, true },
        { "Content-Security-Policy", HeaderType::String, false, false },
        { "Content-Security-Policy-Report-Only", HeaderType::String, false, false },
        { "Content-Type", HeaderType::String, false, false },
        { "Cookie", HeaderType::Parameters, false, false },
        { "Cookie2", HeaderType::String, false, false }, // Obsolete by RFC 6265
        { "DNT", HeaderType::Integer, false, false },
        { "Date", HeaderType::Date, false, false },
        { "ETag", HeaderType::ETag, false, false },
        { "Expect", HeaderType::String, false, false },
        { "Expires", HeaderType::Date, false, false },
        { "Forwarded", HeaderType::String, false, false },
        { "From", HeaderType::Email, false, false },
        { "Host", HeaderType::HostPort, false, false },
        { "If-Match", HeaderType::ETag, false, true },
        { "If-Modified-Since", HeaderType::Date, false, false },
        { "If-None-Match", HeaderType::ETag, false, true },
        { "If-Range", HeaderType::DateOrETag, false ,false },
        { "If-Unmodified-Since", HeaderType::Date, false, false },
        { "Keep-Alive", HeaderType::Parameters, false, true },
        { "Large-Allocation", HeaderType::Integer, false, false }, // Not Standard yet
        { "Last-Modified", HeaderType::Date,false ,false },
        { "Location", HeaderType::Url, false ,false },
        { "Origin", HeaderType::ProtoHostPort, false, false },
        { "Pragma", HeaderType::NoCache, false, false },
        { "Proxy-Authenticate", HeaderType::String, false ,false },
        { "Proxy-Authorization", HeaderType::String, false, false },
        { "Public-Key-Pins", HeaderType::Parameters, false, false },
        { "Public-Key-Pins-Report-Only", HeaderType::Parameters, false, false },
        { "Range",  HeaderType::Range, false, true  },
        { "Referer", HeaderType::Url, false, false },
        { "Referrer-Policy", HeaderType::String, false, false },
        { "Retry-After", HeaderType::DateOrSeconds, false, false },
        { "Server", HeaderType::String, false, false },
        { "Set-Cookie", HeaderType::Parameters, false, false },
        { "Set-Cookie2",  HeaderType::Parameters, false, false  }, // Obsolete
        { "SourceMap",  HeaderType::Url, false, false  },
        { "Strict-Transport-Security",  HeaderType::Parameters, false, false },
        { "TE", HeaderType::String, true, true },
        { "Tk", HeaderType::Character, false, false },
        { "Trailer", HeaderType::ContainsOtherHeaders, false, false },
        { "Transfer-Encoding", HeaderType::String, false, true },
        { "Upgrade-Insecure-Requests", HeaderType::Integer },
        { "User-Agent", HeaderType::String, false, false },
        { "Vary", HeaderType::String, false, true },
        { "Via", HeaderType::String, false, true },
        { "WWW-Authenticate", HeaderType::String, false, false },
        { "Warning", HeaderType::String, false, false },
        { "X-Content-Type-Options", HeaderType::String, false, false },
        { "X-DNS-Prefetch-Control", HeaderType::OnOff, false, false },
        { "X-Forwarded-For", HeaderType::IP, false, true },
        { "X-Forwarded-Host", HeaderType::String, false, false },
        { "X-Forwarded-Proto", HeaderType::String, false, false },
        { "X-Frame-Options", HeaderType::String, false, false },
        { "X-XSS-Protection", HeaderType::String, false, false }
//        { "",  HeaderType:: , , }, // Default LCS is ',', no need to add it
    };
};

// This URL class tries to follow RFC 3986
// the updates in 6874 and 8820 are not taken into account
struct URL {
public:
    URL() : scheme_( "" ), user_( "" ), passwd_( "" ), host_( "" ), path_( "" ), fragment_( "" ), port_( 0 ),
            hasScheme_( false ), hasUser_ ( false ), hasPasswd_( false ), hasHost_( false ), hasPort_( false ),
            hasQuery_( false ), hasFragment_( false ), pathIsStar_( false ) {}
    URL( URL const & ) = default;
    ~URL() = default;
    URL& operator=( URL const & ) = default;

private:
    int charToNumber( std::string::value_type c ) const {
        if ( 'A' <= c && 'F' >= c )
            return (int)(c - 'A') + 10;
        if ( 'a' <= c && 'f' >= c )
            return (int)(c - 'a') + 10;
        if ( '0' <= c && '9' >= c )
            return (int)(c - '0');
        std::stringstream s;
        s << "'" << c << "' is not a hexadecimal digit!";
        throw std::runtime_error( s.str() );
    }
public:
    // Following https://en.wikipedia.org/wiki/Percent-encoding
    std::string percentEncode( const std::string& s ) const {
        std::stringstream r;
        for ( std::string::value_type c : s ) {
            // skip alpha and unreserved characters
            if ( isalnum( c ) || '-' == c || '_' == c || '.' == c || '~' == c ) {
                r << c;
                continue;
            }
            r << '%' << std::setw(2) << std::uppercase << std::hex << int( (unsigned char)c ) << std::nouppercase;
        }
        return r.str();
    }

    std::string percentDecode( const std::string& s ) const {
        std::stringstream r;
        // cppcheck-suppress StlMissingComparison
        for ( std::string::const_iterator ci = s.begin(); ci != s.end(); ++ci ) {
            std::string::value_type c = *ci;
            int n = 0;
            if ( '%' == c ) {
                if ( ++ci == s.end() )
                    throw std::runtime_error( "Malformed URL, percent found but no next char" );
                n += charToNumber(*ci);
                n *= 16;
                if ( ++ci == s.end() )
                    throw std::runtime_error( "Malformed URL, percent found but no next next char" ); // better error message needed :-)
                n += charToNumber(*ci);
                r << (unsigned char)n;
                continue;
            }
            r << c;
        }
        return r.str();
    }

    static URL parse( std::string fullURL ) {
        DBG( 3, "fullURL: '", fullURL, "'" );
        URL url;
        size_t pathBeginPos = 0;
        size_t pathEndPos = std::string::npos;
        size_t questionMarkPos = 0;
        size_t numberPos = 0;
        if ( fullURL.empty() ) {
            url.path_ = '/';
            return url;
        }
        if ( fullURL.size() == 1 && fullURL[0] == '*' ) {
            url.path_ = fullURL;
            url.pathIsStar_ = true;
            return url;
        }

        questionMarkPos = fullURL.find( '?' );
        numberPos = fullURL.find( '#' );

        if ( fullURL[0] == '/' ) {
            pathBeginPos = 0;
        } else {
            // If first character is not a / then the first colon is end of scheme
            size_t schemeColonPos = fullURL.find( ':' );
            if ( std::string::npos != schemeColonPos && 0 != schemeColonPos ) {
                std::string scheme;
                scheme = fullURL.substr( 0, schemeColonPos );
                std::string validSchemeChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-.";
                DBG( 3, "scheme: '", scheme, "'" );
                if ( scheme.find_first_not_of( validSchemeChars ) != std::string::npos )
                    throw std::runtime_error( "Scheme contains invalid characters" );
                url.scheme_ = scheme;
                url.hasScheme_ = true;
            } else
                throw std::runtime_error( "URL does not start with / and has no scheme" );

            size_t authorityPos = fullURL.find( "//", schemeColonPos+1 );
            size_t authorityEndPos;
            std::string authority;

            if ( std::string::npos != authorityPos ) {
                if ( (schemeColonPos+1) != authorityPos )
                    throw std::runtime_error( "Something between : and //" );

                pathBeginPos = fullURL.find( '/', authorityPos+2 );
                authorityEndPos = (std::min)( { pathBeginPos, questionMarkPos, numberPos } );
                authority = fullURL.substr( authorityPos+2, authorityEndPos - (authorityPos + 2) );
                DBG( 3, "authority: '", authority, "'" );

                const size_t atPos = authority.find( '@' );
                bool atFound = (atPos != std::string::npos);
                if ( atFound ) {
                    if ( atPos == 0 )
                        throw std::runtime_error( "'@' found in the first column, username would be empty" );
                    // User (+passwd) found user : passwd @ host
                    size_t passwdColonPos = authority.rfind( ':', atPos );
                    size_t userEndPos = std::string::npos;
                    DBG( 3, "1 userEndPos '", userEndPos, "'" );
                    if ( passwdColonPos != std::string::npos ) {
                        std::string passwd = authority.substr( passwdColonPos+1, atPos-(passwdColonPos+1) );
                        DBG( 3, "passwd: '", passwd, "', passwdColonPos: ", passwdColonPos );
                        userEndPos = passwdColonPos;
                        DBG( 3, "2a userEndPos '", userEndPos, "'" );
                        // passwd is possibly percent encoded FIXME
                        url.passwd_ = url.percentDecode( passwd );
                        url.hasPasswd_ = true;
                    } else {
                        userEndPos = atPos;
                        DBG( 3, "2b userEndPos '", userEndPos, "'" );
                    }
                    DBG( 3, "3 userEndPos '", userEndPos, "'" );
                    std::string user = authority.substr( 0, userEndPos );
                    DBG( 3, "user: '", user, "'" );
                    if ( !user.empty() ) {
                        // user is possibly percent encoded FIXME
                        url.user_ = url.percentDecode( user );
                        url.hasUser_ = true;
                        // delete user/pass including the at
                        authority.erase( 0, atPos+1 );
                    }
                    else {
                        throw std::runtime_error( "User not found before @ sign" );
                    }
                }

                // Instead of all the logic it is easier to work on substrings

                // authority now at most contains hostname possibly in ipv6 notation plus port
                bool angleBracketOpenFound = (authority[0] == '[');
                size_t angleBracketClosePos;
                bool angleBracketCloseFound = false;
                if ( angleBracketOpenFound ) {
                    angleBracketClosePos = authority.find( ']', 0 );
                    angleBracketCloseFound = (angleBracketClosePos != std::string::npos);
                    if ( !angleBracketCloseFound )
                        throw std::runtime_error( "No matching IPv6 ']' found." );
                    url.host_ = authority.substr( 0, angleBracketClosePos );
                    url.hasHost_ = true;
                    DBG( 3, "angleBracketCloseFound: host: '", url.host_, "'" );
                    authority.erase( 0, angleBracketClosePos+1 );
                }

                if ( !authority.empty() ) {
                    // authority now at most has host and port, port is now the definitive separator
                    // (can't be part of the ipv6 address anymore)
                    size_t portColonPos = authority.rfind( ':' );
                    bool portColonFound = (portColonPos != std::string::npos);

                    if ( portColonFound ) {
                        if ( portColonPos == 0 && !url.hasHost_ )
                            throw std::runtime_error( "No hostname found" );
                        if ( portColonPos != 0 ) {
                            url.host_ = authority.substr( 0, portColonPos );
                            DBG( 3, "portColonFound: host: '", url.host_, "'" );
                            url.hasHost_ = true;
                        }
                        size_t port = 0;
                        std::string portString = authority.substr( portColonPos+1 );
                        DBG( 3, "portString: '", portString, "'" );
                        if ( portString.empty() )
                            // Use the default port number, use scheme and the /etc/services file
                            port = 0; // FIXME
                        else {
                            size_t pos = 0;
                            try {
                                port = std::stoull( portString, &pos );
                            } catch ( std::invalid_argument& e ) {
                                DBG( 3, "invalid_argument exception caught in stoull: ", e.what() );
                                DBG( 3, "number of characters processed: ", pos );
                            } catch ( std::out_of_range& e ) {
                                DBG( 3, "out_of_range exception caught in stoull: ", e.what() );
                                DBG( 3, "errno: ", errno, ", strerror(errno): ", strerror(errno) );
                            }
                        }
                        if ( port >= 65536 )
                            throw std::runtime_error( "URL::parse: port too large" );
                        url.port_ = (unsigned short)port;
                        url.hasPort_ = true;
                        DBG( 3, "port: ", port );
                    } else {
                        url.host_ = authority;
                        url.hasHost_ = true;
                        DBG( 3, "portColonNotFound: host: '", url.host_, "'" );
                    }
                } else if ( !url.hasHost_ )
                    throw std::runtime_error( "No hostname found" );
            } else {
                throw std::runtime_error( "// not found" );
            }
        }

        pathEndPos = (std::min)( {questionMarkPos, numberPos} );
        if ( std::string::npos != pathBeginPos ) {
            url.path_ = fullURL.substr( pathBeginPos, pathEndPos - pathBeginPos );
        } else {
            url.path_ = "";
        }
        DBG( 3, "path: '", url.path_, "'" );

        if ( std::string::npos != questionMarkPos ) {
            // Why am i not checking numberPos for validity?
            std::string queryString = fullURL.substr( questionMarkPos+1, numberPos-(questionMarkPos+1) );
            DBG( 3, "queryString: '", queryString, "'" );

            if ( queryString.empty() ) {
                url.hasQuery_ = false;
                throw std::runtime_error( "Invalid URL: query not found after question mark" );
            }
            else {
                url.hasQuery_ = true;
                size_t ampPos = 0;
                while ( !queryString.empty() ) {
                    ampPos = queryString.find( '&' );
                    std::string query = queryString.substr( 0, ampPos );
                    DBG( 3, "query: '", query, "'" );
                    size_t equalsPos = query.find( '=' );
                    if ( std::string::npos == equalsPos )
                        throw std::runtime_error( "Did not find a '=' in the query" );
                    std::string one, two;
                    one = url.percentDecode( query.substr( 0, equalsPos ) );
                    DBG( 3, "one: '", one, "'" );
                    two = url.percentDecode( query.substr( equalsPos+1 ) );
                    DBG( 3, "two: '", two, "'" );
                    url.arguments_.push_back( std::make_pair( one ,two ) );
                    // npos + 1 == 0... ouch
                    if ( std::string::npos == ampPos )
                        queryString.erase( 0, ampPos );
                    else
                        queryString.erase( 0, ampPos+1 );
                }
            }
        }

        if ( std::string::npos != numberPos ) {
            url.hasFragment_ = true;
            url.fragment_ = fullURL.substr( numberPos+1 );
            DBG( 3, "path: '", url.path_, "'" );
        }

        // Now make sure the URL does not contain %xx values
        size_t percentPos = url.path_.find( '%' );
        if ( std::string::npos != percentPos ) {
            // throwing an error mentioning a dev issue
            throw std::runtime_error( std::string("DEV: Some URL component still contains percent encoded values, please report the URL: ") + url.path_ );
        }

        // Done!
        return url;
    }

    void printURL( std::ostream& os ) const {
        DBG( 3, "URL::printURL: debug level 3 to see more" );
        std::stringstream ss;
        DBG( 3, " hasScheme_: ", hasScheme_, ", scheme_: ", scheme_ );
        if ( hasScheme_ ) {
            ss << scheme_ << ':';
        }
        DBG( 3, " hasHost_: ", hasHost_, ", host_: ", host_ );
        if ( hasHost_ ) {
            ss << "//";
            DBG( 3, " hasUser_: ", hasUser_, ", user_: ", user_ );
            if ( hasUser_ ) {
                ss << percentEncode( user_ );
            }
            DBG( 3, " hasPasswd_: ", hasPasswd_, ", passwd_: ", passwd_ );
            if ( hasPasswd_ ) {
                ss << ':' << percentEncode( passwd_ );
            }
            DBG( 3, " hasUser_: ", hasUser_, ", user_: ", user_ );
            if ( hasUser_ ) {
                ss << '@';
            }
            DBG( 3, " hasHost_: ", hasHost_, ", host_: ", host_ );
            if ( hasHost_ ) {
                ss << host_;
            }
            DBG( 3, " hasPort_: ", hasPort_, ", port_: ", port_ );
            if ( hasPort_ ) {
                ss << ':' << port_;
            }
        }
        DBG( 3, " path_: '", path_, "'" );
        ss << (path_.empty() ? "/" : path_);
        if ( hasQuery_ ) {
            DBG( 3, " hasQuery_: ", hasQuery_ );
            ss << '?';
            size_t i;
            for ( i = 0; i < (arguments_.size()-1); ++i ) {
                DBG( 3, " query[", i, "]: ", arguments_[i].first, " ==> ", arguments_[i].second );
                ss << percentEncode( arguments_[i].first ) << '=' << percentEncode( arguments_[i].second ) << "&";
            }
            DBG( 3, " query[", i, "]: ", arguments_[i].first, " ==> ", arguments_[i].second );
            ss << percentEncode( arguments_[i].first ) << '=' << percentEncode( arguments_[i].second );
        }
        if ( hasFragment_ ) {
            DBG( 3, " hasFragment_: ", hasFragment_, ", fragment_: ", fragment_ );
            ss << '#' << fragment_;
        }
        os << ss.str() << "\n";
        DBG( 3, "URL::printURL: done" );
    }

public:
    std::string scheme_;
    std::string user_;
    std::string passwd_;
    std::string host_;
    std::string path_;
    std::string fragment_;
    std::vector<std::pair<std::string,std::string>> arguments_;
    unsigned short port_;
    bool hasScheme_;
    bool hasUser_;
    bool hasPasswd_;
    bool hasHost_;
    bool hasPort_;
    bool hasQuery_;
    bool hasFragment_;
    bool pathIsStar_;
};

std::ostream& operator<<(  std::ostream& os, URL const & url ) {
    url.printURL( os );
    return os;
}

enum MimeType {
    CatchAll = 0,
    TextHTML,
    TextXML,
    TextPlain,
    TextPlainProm_0_0_4,
    ApplicationJSON,
    ImageXIcon,
    MimeType_spare = 255
};

std::unordered_map<enum MimeType, std::string, std::hash<int>> mimeTypeMap = {
    { CatchAll,            "*/*" },
    { TextHTML,            "text/html" },
    { TextPlain,           "text/plain" },
    { TextPlainProm_0_0_4, "text/plain; version=0.0.4" },
    { ImageXIcon,          "image/x-icon" },
    { ApplicationJSON,     "application/json" }
};

class HTTPHeader {
public:
    HTTPHeader() {
        type_ = HeaderType::Invalid;
    }
    HTTPHeader( std::string n, std::string v ) : name_( n ), value_( v ) {
        type_ = HeaderType::ServerSet;
    }
    HTTPHeader( char const * n, char const * v ) : name_( n ), value_( v ) {
        type_ = HeaderType::ServerSet;
    }
    HTTPHeader( HTTPHeader const & ) = default;
    HTTPHeader( HTTPHeader&& ) = default;
    HTTPHeader& operator=( HTTPHeader const& ) = default;
    ~HTTPHeader() = default;

public:
    static HTTPHeader parse( std::string& header ) {
        HTTPHeader hh;
        hh.type_ = HeaderType::Invalid;

        DBG( 3, "Raw Header : '", header, "'" );

        std::string::size_type colonPos = header.find( ':' );
        if ( std::string::npos == colonPos ) {
            hh.invalidReason_ = "Not a valid header, no : found";
            return hh;
        }

        std::string headerName  = header.substr( 0, colonPos );
        std::string headerValue = header.substr( colonPos+1 ); // FIXME: possible whitespace before, between and after

        // Spaces in header names are illegal but be lenient und just remove them
        headerName.erase( std::remove ( headerName.begin(), headerName.begin() + colonPos, ' ' ), headerName.end() );

        hh.name_  = headerName;
        hh.value_ = headerValue;
        hh.type_  = HTTPHeaderProperties::headerType( hh.name_ );

        DBG( 3, "Headername : '", headerName, "'" );
        DBG( 3, "Headervalue: '", headerValue, "'" );
        DBG( 3, "HeaderType : '", HTTPHeaderProperties::headerTypeAsString(hh.type_), "'" );

        if ( hh.type_ == HeaderType::Invalid ) {
            hh.invalidReason_ = "parse header: found an Invalid HeaderType";
            return hh;
        }

        std::string::size_type quotes = std::count( headerValue.begin(), headerValue.end(), '"' );
        bool properlyQuoted = (quotes % 2 == 0);
        if ( !properlyQuoted ) {
            DBG( 3, "Parse: header not properly quoted: uneven number of  quotes (", quotes, ") found" );
            hh.type_ = HeaderType::Invalid;
            hh.invalidReason_ = "parse header: header improperly quoted";
        }

        return hh;
    }

    std::string headerName() const { return name_; }
    // Not sure what I needed it for but leaving it for now
//     std::string headerValue() const {
//         std::cout << "Calling headerValue for HeaderName: " << name_ << "\n";
//         std::cout.flush();
//         std::string value;
//         switch ( type_ ) {
//         case ServerSet:
//             return value_;
//         case String:
//             if ( valueList_.size() > 0 )
//                 return valueList_[0];
//             throw std::runtime_error( "headerValue(): Empty valuelist" );
//             break;
//         case Integer:
//             if ( integers_.size() > 0 )
//                 return std::to_string( integers_[0] );
//             throw std::runtime_error( "headerValue(): Empty valuelist" );
//             break;
//         case Float:
//             if ( floats_.size() > 0 )
//                 return std::to_string( floats_[0] );
//             throw std::runtime_error( "headerValue(): Empty valuelist" );
//             break;
//         case Date:
//             return date_.toString();
//             break;
//         case Range:
//             return "";
//             break;
//         default:
//             return std::string("Not implemented yet for '") + name_ + "', type is '" + std::to_string((int)type_) + "'";
//         }
//     }

    std::vector<std::string> const headerValueAsList() const {
        return splitHeaderValue();
    }

    void debugPrint() const {
        if ( type_ == HeaderType::Invalid ) {
            DBG( 3, "HeaderType::Invalid, invalidReason: ", invalidReason_ );
        } else {
            DBG( 3, "Headername: '", name_, "', Headervalue: '", value_, "'" );
        }
    }

    size_t headerValueAsNumber() const {
        size_t number = std::stoll( value_ );
        return number;
    }

    double headerValueAsDouble() const {
        double number = std::stod( value_ );
        return number;
    }

    HeaderType type() const {
        return type_;
    }

    std::string const & headerValueAsString() const {
        return value_;
    }

    enum MimeType headerValueAsMimeType() const {
        auto list = headerValueAsList();
        for ( auto& item : list ) {
            DBG( 3, "item: '", item, "'" );
            for( auto& mt : mimeTypeMap ) {
                DBG( 3, "comparing item: '", item, "' to '", mt.second, "'" );
                if ( mt.second.compare( item ) == 0 ) {
                    DBG( 3, "MimeType ", mt.second, " found." );
                    return mt.first;
                }
            }
        }
        // If we did not recognize the mimetype we will return TextHTML so the client can see the HTML page
        return TextHTML;
    }

    const std::string& invalidReason() const {
        return invalidReason_;
    }

private:
    std::vector<std::string> splitHeaderValue() const {
        std::vector<std::string> elementList;
        std::stringstream ss( value_ );
        std::string s;
        char listSeparatorChar = HTTPHeaderProperties::listSeparatorChar( name_ );
        while ( ss.good() ) {
            std::getline( ss, s, listSeparatorChar );
            // Remove leading whitespace
            s.erase( s.begin(), std::find_if( s.begin(), s.end(), []( char c ){ return c != ' '; } ) );
            // Remove trailing whitespace
            s.erase( std::find_if( s.rbegin(), s.rend(), []( char c ){ return c != ' '; } ).base(), s.end() );
            elementList.push_back( s );
        }
        return elementList;
    }

private:
    std::string name_;
    std::string value_;
    enum HeaderType type_;
    std::string invalidReason_;
    std::vector<std::string> valueList_;
    std::vector<double> floats_;
    std::vector<long long> integers_;
    std::vector<std::pair<size_t,size_t>> ranges_;
    std::vector<std::pair<std::string,std::string>> parameters_;
    datetime date_;
};

class HTTPMessage {
protected:
    HTTPMessage() {
        initialized_ = false;
        protocol_ = HTTPProtocol::InvalidProtocol;
    }
    HTTPMessage( HTTPMessage const & ) = default;
    HTTPMessage & operator = ( HTTPMessage const & ) = default;
    ~HTTPMessage() = default;

public:
    // Data manipulators/extractors
    std::string const & body() const {
        return body_;
    }

    void addBody( std::string const& body ) {
        body_ = body;
    }

    void addHeader( std::string const & name, std::string const & value ) {
        if ( headers_.insert( std::make_pair( name, HTTPHeader( name, value ) ) ).second == false ) {
            throw std::runtime_error( "Header already exists in the headerlist" );
        }
    }

    void addHeader( const HTTPHeader & hh ) {
        if ( headers_.insert( std::make_pair( hh.headerName(), hh ) ).second == false ) {
            throw std::runtime_error( "Header already exists in the headerlist" );
        }
    }

    bool hasHeader( std::string const & header ) const {
        auto pos = headers_.find( header );
        if ( pos == headers_.end() )
            return false;
        return true;
    }

    HTTPHeader const & getHeader( std::string const & header ) const {
        auto pos = headers_.find( header );
        if ( pos == headers_.end() ) {
            std::stringstream ss;
            ss << "HTTPMessage::getHeader: Header '" << header << "' not found.";
            throw std::runtime_error( ss.str() );
        }
        return (*pos).second;
    }

    std::string const & protocolAsString() const {
        // will throw if key not found, it is a bug anyway
        return protocol_map_.at(protocol_);
    }

    enum HTTPProtocol protocol() const {
        return protocol_;
    }

    void setProtocol( enum HTTPProtocol protocol ) {
        if ( protocol < HTTPProtocol::HTTP_0_9 || protocol > HTTPProtocol::HTTP_2_0 )
            throw std::runtime_error( std::string("Protocol enum value out of bounds: ") + std::to_string(protocol) );
        protocol_ = protocol;
    }

    void setProtocol( std::string const & protocolString ) {
        auto it = protocol_map_.begin();
        while( it != protocol_map_.end() ) {
            if ( (*it).second == protocolString ) {
                protocol_ = (*it).first;
                break;
            }
            ++it;
        }
        if ( it == protocol_map_.end() ) {
            DBG( 3, "Protocol string '", protocolString, "' not found in map, protocol unsupported!" );
            throw std::runtime_error( std::string("Protocol is not supported: ") + protocolString );
        }
    }

    std::string const host() const {
        std::string host;
        if ( hasHeader( "Host" ) ) {
            HTTPHeader host = getHeader( "Host" );
        } else {
            DBG( 3, "HTTPMessage::host: header Host not found." );
            host = "";
        }
        return host;
    }

    bool isInitialized() const {
        return initialized_;
    }

    void setInitialized() {
        initialized_ = true;
    }

protected:
    std::string readData( socketstream& in, size_t length ) {
        std::string data( length, '\0' );
        in.read( &data[0], length );
        return data;
    }

    std::string readChunkedData( socketstream& in ) {
        std::string chunkHeader;
        std::string data;
        std::getline( in, chunkHeader, '\n' );
        // Final header starts with 0, rest of the line is not important
        while ( '0' != chunkHeader[0] ) {
            // chunkheader: hexadecimal numbers followed by an optional semi-colon with a comment and a \r
            // stoll should filter all that crap out for us and return just the hexadecimal digits
            DBG( 3, "chunkHeader (ater check for 0): '", chunkHeader, "'" );
            size_t length = std::stoll( chunkHeader, nullptr, 16 );
            DBG( 3, "length: '", length, "'" );
            // Initialize chunk to all zeros
            std::string chunk( length, '\0' );
            in.read( &chunk[0], length );
            DBG( 3, "chunk: '", chunk, "'" );
            data += chunk;
            // Reads trailing \r\n from the chunk
            std::getline( in, chunkHeader, '\n' );
            // Reads the empty line following the chunk
            std::getline( in, chunkHeader, '\n' );
            DBG( 3, "chunkHeader (should be empty line): '", chunkHeader, "'" );
            // Read a new line to check for 0\r header
            std::getline( in, chunkHeader, '\n' );
            DBG( 3, "chunkHeader (should be next chunk header): '", chunkHeader, "'" );
        }
        return data;
    }

protected:
    enum HTTPProtocol protocol_;
    std::unordered_map<std::string, HTTPHeader> headers_;
    std::string body_;
    std::unordered_map<enum HTTPProtocol, std::string, std::hash<int>> protocol_map_ = {
        { HTTPProtocol::HTTP_0_9, "HTTP/0.9" },
        { HTTPProtocol::HTTP_1_0, "HTTP/1.0" },
        { HTTPProtocol::HTTP_1_1, "HTTP/1.1" },
        { HTTPProtocol::HTTP_2_0, "HTTP/2.0" }
    };
    bool initialized_;
};

class HTTPRequest : public HTTPMessage {
public:
    HTTPRequest() : method_( HTTPRequestMethod::GET ) {}
    HTTPRequest( HTTPRequest const & ) = default;
    HTTPRequest & operator = ( HTTPRequest const & ) = default;
    ~HTTPRequest() = default;

    template <typename CharT, typename Traits>
    friend basic_socketstream<CharT,Traits>& operator>>(basic_socketstream<CharT,Traits>&, HTTPRequest& );

public:
    enum HTTPRequestMethod method() const {
        return method_;
    }

    URL const & url() const {
        return url_;
    }

    void debugPrint() {
        DBG( 3, "HTTPRequest::debugPrint:" );
        DBG( 3, "Method  : \"", method_, "\"" );
        DBG( 3, "URL     : \"", url_, "\"" );
        DBG( 3, "Protocol: \"", protocol_, "\"" );
        for ( auto& header: headers_ )
            DBG( 3, "Header : \"", header.first, "\" ==> \"", header.second.headerValueAsString(), "\"" );
        DBG( 3, "Body    : \"", body_, "\"" );
    }

private:
    enum HTTPRequestMethod method_;
    URL url_;
};

class HTTPResponse : public HTTPMessage {
public:
    HTTPResponse( bool bodyExpected = true ) : responseCode_( HTTPResponseCode::RC_200_OK ), bodyExpected_( bodyExpected ) {}
    HTTPResponse( HTTPResponse const & ) = default;
    HTTPResponse & operator = ( HTTPResponse const & ) = default;
    virtual ~HTTPResponse() = default;

    template <typename CharT, typename Traits>
    friend basic_socketstream<CharT,Traits>& operator<<(basic_socketstream<CharT,Traits>&, HTTPResponse& );

    template <typename CharT, typename Traits>
    friend basic_socketstream<CharT,Traits>& operator>>(basic_socketstream<CharT,Traits>&, HTTPResponse& );

public:
    enum HTTPResponseCode responseCode() const {
        return responseCode_;
    }

    std::string reasonPhrase() const {
        return reasonPhrase_;
    }

    std::string responseCodeAsString() const {
        return response_map_.at( responseCode_ );
    }

    bool bodyExpected() const {
        return bodyExpected_;
    }

    void setResponseCode( enum HTTPResponseCode rc ) {
        DBG( 3, "Setting response code to: '", std::dec, (int)rc, "'" );
        responseCode_ = rc;
    }

    void setResponseCode( std::string& rc ) {
        int anInt = std::stoi( rc );
        if ( anInt < 0 || anInt > HTTPResponseCode::HTTPReponseCode_Spare )
            throw std::runtime_error( "Responsecode is out of bounds!" );
        responseCode_ = static_cast<HTTPResponseCode>( anInt );
    }

    void setReasonPhrase( std::string& reason ) {
        reasonPhrase_ = reason;
    }

    void debugPrint() {
        DBG( 3, "HTTPReponse::debugPrint:" );
        DBG( 3, "Response Code: \"", (int)responseCode_, "\"" );
        for ( auto& header: headers_ )
            DBG( 3, "Header: \"", header.first, "\" ==> \"", header.second.headerValueAsString(), "\"" );
        // Leaving body at 3, too large and spams the output
        DBG( 3, "Body: \"", body_, "\"" );
    }

    void createResponse( enum MimeType mimeType, std::string body, enum HTTPResponseCode rc ) {
        // mimetype validity checking?
        addHeader( HTTPHeader( "Content-Type", mimeTypeMap[mimeType] ) );
        addHeader( HTTPHeader( "Content-Length", std::to_string( body.size() ) ) );
        addBody( body );
        setResponseCode( rc );
    }

private:
    enum HTTPResponseCode responseCode_;
    bool bodyExpected_;
    std::string reasonPhrase_;
    std::unordered_map<enum HTTPResponseCode, std::string, std::hash<int>> response_map_ = {
        { RC_100_Continue, "Continue" },
        { RC_101_SwitchingProtocols, "Switching Protocols" },
        { RC_102_Processing, "Processing" },
        { RC_200_OK, "OK" },
        { RC_201_Created, "Created" },
        { RC_202_Accepted, "Accepted" },
        { RC_203_NonAuthorativeInformation, "Non-authorative Information" },
        { RC_204_NoContent, "No Content" },
        { RC_205_ResetContent, "Reset Content" },
        { RC_206_PartialContent, "Partial Content" },
        { RC_207_MultiStatus, "Multi-Status" },
        { RC_208_AlreadyReported, "Already Reported" },
        { RC_226_IMUsed, "IM Used" },
        { RC_300_MultipleChoices, "Multiple Choices" },
        { RC_301_MovedPermanently, "Moved Permanently" },
        { RC_302_Found, "Found" },
        { RC_303_SeeOther, "See Other" },
        { RC_304_NotModified, "Not Modified" },
        { RC_305_UseProxy, "Use Proxy" },
        { RC_307_TemporaryRedirect, "Temporary Redirect" },
        { RC_308_PermanentRedirect, "Permanent Redirect" },
        { RC_400_BadRequest, "Bad Request" },
        { RC_401_Unauthorized, "Unauthorized" },
        { RC_402_PaymentRequired, "Payment Required" },
        { RC_403_Forbidden, "Forbidden" },
        { RC_404_NotFound, "Not Found" },
        { RC_405_MethodNotAllowed, "Method Not Allowed" },
        { RC_406_NotAcceptable, "Not Acceptable" },
        { RC_407_ProxyAuthenticationRequired, "Proxy Authentication Required" },
        { RC_408_RequestTimeout, "Request Timeout" },
        { RC_409_Conflict, "Conflict" },
        { RC_410_Gone, "Gone" },
        { RC_411_LengthRequired, "Length Required" },
        { RC_412_PreconditionFailed, "Precondition Failed" },
        { RC_413_PayloadTooLarge, "Payload Too Large" },
        { RC_414_RequestURITooLong, "Request-URI Too Long" },
        { RC_415_UnsupportedMediaType, "Unsupported Media Type" },
        { RC_416_RequestRangeNotSatisfiable, "Request Range Not Satisfiable" },
        { RC_417_ExpectationFailed, "Expectation Failed" },
        { RC_418_ImATeapot, "I'm a teapot" },
        { RC_421_MisdirectedRequest, "Misdirected Request" },
        { RC_422_UnprocessableEntity, "Unprocessable Entity" },
        { RC_423_Locked, "Locked" },
        { RC_424_FailedDependency, "Failed Dependency" },
        { RC_426_UpgradeRequired, "Upgrade Required" },
        { RC_428_PreconditionRequired, "Precondition Required" },
        { RC_429_TooManyRequests, "Too Many Requests" },
        { RC_431_RequestHeaderFieldsTooLarge, "Request Header Fields Too Large" },
        { RC_444_ConnectionClosedWithoutResponse, "Connection Closed Without Response" },
        { RC_451_UnavailableForLegalReasons, "Unavailable For Legal Reasons" },
        { RC_499_ClientClosedRequest, "Client Closed Request" },
        { RC_500_InternalServerError, "Internal Server Error" },
        { RC_501_NotImplemented, "Not Implemented" },
        { RC_502_BadGateway, "Bad Gateway" },
        { RC_503_ServiceUnavailable, "Service Unavailable" },
        { RC_504_GatewayTimeout, "Gateway Timeout" },
        { RC_505_HTTPVersionNotSupported, "HTTP Version Not Supported" },
        { RC_506_VariantAlsoNegotiates, "Variant Also Negotiates" },
        { RC_507_InsufficientStorage, "Insufficient Storage" },
        { RC_508_LoopDetected, "Loop Detected" },
        { RC_510_NotExtended, "Not Extended" },
        { RC_511_NetworkAuthenticationRequired, "Network Authentication Required" },
        { RC_599_NetworkConnectTimeoutError, "Network Connect Timeout Error" }
    };
};

// Compress linear white space and remove carriage return, not new line, this one is gone already
std::string& compressLWSAndRemoveCR( std::string& line ) {
    std::string::size_type pos = 0, end = line.size(), start = 0;

    for ( pos = 0; pos < end; ++pos ) {
        start = pos;
        if ( ::isspace( line[pos] ) ) {
            while ( (pos+1) < line.size() && ::isspace( line[++pos] ) ) {
            }
            if ( (pos - start) > 1 ) {
                line.erase( start+1,  pos-start-1 );
                end -= pos-start-1;
                pos = start+1;
            }
        }
    }

    // Remove trailing '\r'
    if (!line.empty() && line.back() == '\r') {
        line.pop_back();
    }

    return line;
}

// This method is for a server reading a request from the client
template <class CharT, class Traits>
basic_socketstream<CharT, Traits>& operator>>( basic_socketstream<CharT, Traits>& rs, HTTPRequest& m ) {
    DBG( 3, "Reading from the socket" );

    // Read something like: GET /persecond/10 HTTP/1.1\r\n
    std::string requestLine, method, url, protocol;
    // We need to read a line and check if the request is valid
    // Fuzzers like to remove spaces so there are not enough elements
    // on the line and then we're in trouble with the old method
    std::getline( rs, requestLine );
    if ( rs.fail() ) {
        DBG( 3, "Could not read from socket, might have been closed due to e.g. timeout" );
        throw std::runtime_error( "Could not read from socket, might have been closed due to e.g. timeout" );
    }
    size_t nlPos = requestLine.find( '\n', 0 );
    if ( nlPos != std::string::npos )
        requestLine.erase( nlPos, 1 );
    size_t crPos = requestLine.find( '\r', 0 );
    if ( crPos != std::string::npos )
        requestLine.erase( crPos, 1 );
    DBG( 3, "RequestLine: \"", requestLine, "\"" );
    // Method does not have spaces, url has %20, protocol does not have spaces, so exactly 2
    if ( std::count( requestLine.begin(), requestLine.end(), ' ' ) == 2 ) {
        // No need to check for npos, we determined there are enough spaces in the string
        size_t firstSpace = requestLine.find( ' ', 0 );
        // Bogus check, we checked for the existence of 2 spaces...
        // A simple assert is not enough to silence cppcheck and coverity.
        if ( firstSpace == std::string::npos )
            throw std::runtime_error("No first space found in request line");
        DBG( 3, "firstSpace: ", firstSpace );
        method = requestLine.substr( 0, firstSpace );
        DBG( 3, "method: ", method );
        if ( method.size() == 0 )
            throw std::runtime_error( "Not a valid request string: Method is empty" );
        size_t secondSpace = requestLine.find( ' ', firstSpace+1 );
        // Bogus check, we checked for the existence of 2 spaces...
        // A simple assert is not enough to silence cppcheck and coverity.
        if ( secondSpace == std::string::npos )
            throw std::runtime_error("No second space found in request line");
        DBG( 3, "secondSpace: ", secondSpace );
        url = requestLine.substr( firstSpace+1, secondSpace-firstSpace-1 );
        DBG( 3, "url: ", url );
        if ( url.size() == 0 )
            throw std::runtime_error( "Not a valid request string: URL is empty" );
        protocol = requestLine.substr( secondSpace+1, std::string::npos );
        DBG( 3, "protocol: ", protocol );
        if ( protocol.size() == 0 )
            throw std::runtime_error( "Not a valid request string: Protocol is empty" );
    }
    else
        throw std::runtime_error( std::string( "Not a valid request string: Not exactly 3 space separated tokens: " ) + requestLine );

    m.setProtocol( protocol );
    m.method_ = HTTPMethodProperties::getMethodAsEnum( method );
    m.url_    = URL::parse( url );
    m.setInitialized();

    // m.debugPrint();
    std::string line;
    std::string concatLine;
    while ( true ) {
        std::getline( rs, line );
        DBG( 3, "Line with whitespace: '", line, "'" );
        concatLine += compressLWSAndRemoveCR( line );

        DBG( 3, "Line without whitespace: '", line, "'" );
        DBG( 3, "ConcatLine: '", concatLine, "'" );
        // empty line is separator between headers and body
        if ( concatLine.empty() ) {
            break;
        }

        // Header spans multiple lines if a line starts with SP or HTAB, fetch another line and append to concatLine
        if ( rs.peek() == ' ' || rs.peek() == '\t' )
            continue;

        HTTPHeader hh;
        hh = HTTPHeader::parse( concatLine );
        hh.debugPrint();
        if ( hh.type() == HeaderType::Invalid ) {
            // Bad request, throw exception, catch in httpconnection, create response there
            throw std::runtime_error( std::string("Bad Request received: ") + hh.invalidReason() );
        }
        m.addHeader( hh );
        // Parsing of header done, clear concatLine to start fresh
        concatLine.clear();
    }
    DBG( 3, "Done parsing headers" );

    enum HTTPRequestHasBody hasBody = HTTPMethodProperties::requestHasBody( m.method_ );
    DBG( 3, "Request has Body (0 No, 1 Optional, 2 Yes): ", (int)hasBody );
    if ( hasBody != HTTPRequestHasBody::No ) {
        // this mess of code checks if the body will arrive in pieces (chunked) or in one piece and tests the pre-conditions
        // that belong with them either content-length header or transfer-encoding header, both
        // means bad request, in case neither is there we need to check if body is optional
        bool validCL = false;
        size_t contentLength = 0;
        bool chunkedTE = false;
        std::string body( "" );
        // cl = Content Length
        if ( m.hasHeader( "Content-Length" ) ) {
            HTTPHeader const h = m.getHeader( "Content-Length" );
            contentLength = h.headerValueAsNumber();
            validCL = true;
            DBG( 3, "Content-Length: clValue: ", contentLength, ", validCL: ", validCL );
        } else {
            validCL = false;
            DBG( 3, "Content-Length: header not found." );
        }
        // te = Transfer Encoding
        if ( m.hasHeader( "Transfer-Encoding" ) ) {
            HTTPHeader const h = m.getHeader( "Transfer-Encoding" );
            std::string teString = h.headerValueAsString();
            // Validate header
            if ( teString.find( "chunked" ) != std::string::npos ) {
                chunkedTE = true;
            } else {
                chunkedTE = false;
            }
            DBG( 3, "Transfer-Encoding: teString: ", teString, ", chunkedTE: ", chunkedTE );
        } else {
            DBG( 3, "Transfer-Encoding: header not found " );
            chunkedTE = false;
        }
        size_t trailerLength = 0;
        if ( m.hasHeader( "Trailer" ) ) {
            HTTPHeader const trailer = m.getHeader( "Trailer" );
            trailerLength = trailer.headerValueAsList().size();

        } else {
            DBG( 3, "Trailer: header not found " );
        }

        if ( ( chunkedTE && !validCL ) || ( !chunkedTE && validCL ) ) {
            DBG( 3, "Good request" );
            // Good request, get body
            // but first check if the client sent the Expect header, if so we
            // need to respond with 100 Continue so it starts transmitting the body
            std::string expect( "" );
            if ( m.hasHeader( "Expect" ) ) {
                HTTPHeader const h = m.getHeader( "Expect" );
                expect = h.headerValueAsString();
            } else {
                expect = "";
            }
            if ( expect == "100-continue" ) {
                // We have to send a HTTP/1.1 100 Continue response followed by an empty line
                HTTPResponse resp;
                resp.setProtocol( HTTPProtocol::HTTP_1_1 );
                resp.setResponseCode( HTTPResponseCode::RC_100_Continue );
                rs << resp;
            }
            else if ( expect != "" )
                throw std::runtime_error( "Not a valid Expect header" );

            // now load the body
            if ( chunkedTE ) {
                m.body_ = m.readChunkedData( rs );
                // There is now either a \r\n pair in the stream, or footers/trailers, lets see:
                std::string remainder;
                size_t numHeadersAdded = 0;
                std::getline( rs, remainder, '\n' );
                DBG( 3, "Parsing remainder '", remainder, "'" );
                while ( remainder[0] != '\r' ) {
                    HTTPHeader hh = HTTPHeader::parse( remainder );
                    if ( hh.type() == HeaderType::Invalid ) {
                        // Bad request, throw exception, catch in httpconnection, create response there
                        throw std::runtime_error( std::string("Bad Request received: ") + hh.invalidReason() );
                    }
                    m.addHeader( hh );
                    ++numHeadersAdded;
                }
                // If trailer contains 3 headers then 3 headers should be added
                if ( numHeadersAdded != trailerLength )
                    throw std::runtime_error( "Trailing headers does not match Trailer header content" );
            } else {
                body = m.readData( rs, contentLength );
            }
        } else if ( hasBody == HTTPRequestHasBody::Optional && ! validCL && !chunkedTE ){
            // Good request, no body, done
            return rs;
        } else {
            // Bad request, throw exception, catch in connection, create response there
            throw std::runtime_error( "Bad Request received" );
        }
    }
    return rs;
}

// This method is for a client reading a response from the server
template <class CharT, class Traits>
basic_socketstream<CharT, Traits>& operator>>( basic_socketstream<CharT, Traits>& rs, HTTPResponse& m ) {
    DBG( 3, "Reading from the socket" );

    // Read something like: HTTP/1.1 403 OK\r\n
    std::string protocol, statuscode, reasonphrase;
    rs >> protocol >> statuscode;
    std::getline( rs, reasonphrase );
    if ( rs.fail() ) {
        DBG( 3, "Could not read from socket, might have been closed due to e.g. timeout" );
        throw std::runtime_error( "Could not read from socket, might have been closed due to e.g. timeout" );
    }

    m.setProtocol( protocol );
    m.setResponseCode( statuscode );
    m.setReasonPhrase( reasonphrase );

    //m.debugPrint();
    // ignore the '\n' after the protocol
    //rs.ignore( std::numeric_limits<std::streamsize>::max(), '\n' );
    std::string line;
    std::string concatLine;
    while ( true ) {
        std::getline( rs, line );
        DBG( 3, "Line with whitespace: '", line, "'" );
        concatLine += compressLWSAndRemoveCR( line );

        DBG( 3, "Line without whitespace: '", line, "'" );
        DBG( 3, "ConcatLine: '", concatLine, "'" );
        // empty line is separator between headers and body
        if ( concatLine.empty() ) {
            break;
        }

        // Header spans multiple lines if a line starts with SP or HTAB, fetch another line and append to concatLine
        if ( rs.peek() == ' ' || rs.peek() == '\t' )
            continue;

        HTTPHeader hh;
        hh = HTTPHeader::parse( concatLine );
        if ( hh.type() == HeaderType::Invalid ) {
            // Bad request, throw exception, catch in httpconnection, create response there
            throw std::runtime_error( std::string("Bad Request received: ") + hh.invalidReason() );
        }
        hh.debugPrint();
        m.addHeader( hh );
        // Parsing of header done, clear concatLine to start fresh
        concatLine.clear();
    }
    DBG( 3, "Done parsing headers" );

    DBG( 3, "Body expected: ", (int)m.bodyExpected() );
    if ( m.bodyExpected() ) {
        bool validCL = false;
        size_t contentLength = 0;
        std::string body( "" );
        // cl = Content Length
        if ( m.hasHeader( "Content-Length" ) ) {
            HTTPHeader const h = m.getHeader( "Content-Length" );
            contentLength = h.headerValueAsNumber();
            if ( contentLength == 0 )
                throw std::runtime_error( "Client: Server did not send a body (cl=0) but we expected one." );
            validCL = true;
            DBG( 3, "Content-Length: clValue: ", contentLength, ", validCL: ", validCL );
        } else {
            validCL = false;
            DBG( 3, "Content-Length: header not found." );
            throw std::runtime_error( "Could not find a Content-Length header so we're not sure how much data is coming, this is a protocol error on the server." );
        }

        body = m.readData( rs, contentLength );
        m.addBody( body );
    }
    return rs;
}

// This method is for a server writing a response to the client
template <class CharT, class Traits>
basic_socketstream<CharT, Traits>& operator<<( basic_socketstream<CharT, Traits>& ws, HTTPResponse& m ) {
    DBG( 3, "Writing the HTTPResponse to the socket" );
    m.debugPrint();

    DBG( 3, m.protocolAsString(), " ", (int)m.responseCode(), " ", m.responseCodeAsString() );
    ws << m.protocolAsString() << " " << (int)m.responseCode() << " " << m.responseCodeAsString() << HTTP_EOL;

    DBG( 3, "Headers:" );
    // write headers
    for( auto& header : m.headers_ ) {
        DBG( 3, header.first, ": ", header.second.headerValueAsString() );
        if ( header.first == "Content-Type" )
            ws << header.first << ": " << header.second.headerValueAsString() << "; charset=UTF-8" << HTTP_EOL;
        else
            ws << header.first << ": " << header.second.headerValueAsString() << HTTP_EOL;
    }

    ws << HTTP_EOL;

    DBG( 3, "Body:", m.body() );
    ws << m.body();

    ws.flush();
    DBG( 3, "Written the response to the socket and flushed it" );
    return ws;
}

typedef void (*http_callback)( HTTPServer *, HTTPRequest const &, HTTPResponse & );

class HTTPConnection : public Work {
public:
    HTTPConnection() = delete;
#if defined (USE_SSL)
    HTTPConnection( HTTPServer* hs, socket_t socketFD, struct sockaddr_in /* clientAddr */, std::vector<http_callback> const & cl, SSL* ssl = nullptr ) : hs_( hs ), socketStream_( socketFD, ssl ), /* clientAddress_( clientAddr ), */ callbackList_( cl ) {
        DBG( 3, "HTTPConnection Constructor called..." );
    }
#else
    HTTPConnection( HTTPServer* hs, socket_t socketFD, struct sockaddr_in /* clientAddr */, std::vector<http_callback> const & cl ) : hs_( hs ), socketStream_( socketFD ), /* clientAddress_( clientAddr ), */ callbackList_( cl ) {}
#endif
    HTTPConnection( HTTPConnection const & ) = delete;
    void operator=( HTTPConnection const & ) = delete;
    ~HTTPConnection() = default;

public:
    virtual void execute() override {
        bool keepListening = false;
        int numRequests = 0;
        do {
            HTTPRequest  request;
            HTTPResponse response;

            try {
                DBG( 3, "Starting a HTTPConnection read from socket" );
                socketStream_ >> request;
            } catch( std::exception& e ) {
                DBG( 3, "Reading request from socket: Exception caught: ", e.what(), "\n" );
                // Use the protocol that the client used or simply respond with HTTP/1.1 if it could not be determined
                if ( request.isInitialized() ) {
                    // No need to catch here, if request isInitialized is true then the protocol
                    // is set and there was no throw at that point
                    response.setProtocol( request.protocol() );
                } else {
                    response.setProtocol( HTTPProtocol::HTTP_1_1 );
                }
                // Always send a response
                response.createResponse( TextPlain, std::string( "400 Bad Request" ), RC_400_BadRequest );
                socketStream_ << response;
                break;
            }
            DBG( 3, "Request read from socket, processing..." );
            ++numRequests;
            // Debug:
            // request.debugPrint();

            response.setProtocol( request.protocol() );

            // Check for protocol conformity
            if ( request.protocol() == HTTPProtocol::HTTP_1_1 ) {
                if ( ! request.hasHeader( "Host" ) ) {
                    DBG( 3, "Mandatory Host header not found." );
                    std::string body( "400 Bad Request. HTTP 1.1: Mandatory Host header is missing." );
                    response.createResponse( TextPlain, body, RC_400_BadRequest );
                    socketStream_ << response;
                    break;
                }
            }

            // Do processing of the request here
            if (*callbackList_[request.method()])
                (*callbackList_[request.method()])( hs_, request, response );
            else {
                std::string body( "501 Not Implemented." );
                body += " Method \"" + HTTPMethodProperties::getMethodAsString(request.method()) + "\" is not implemented (yet).";
                response.createResponse( TextPlain, body, RC_501_NotImplemented );
            }

            // Post-processing, adding some server specific response headers
            int const requestLimit = 100;
            int const connectionTimeout = 10;
            response.addHeader( HTTPHeader( "Server", std::string( "PCMWebServer " ) + PCMWebServerVersion ) );
            response.addHeader( HTTPHeader( "Date", datetime().toString() ) );
            if ( numRequests < requestLimit ) {
                std::string connection;
                if ( request.hasHeader( "Connection" ) ) {
                    HTTPHeader const h = request.getHeader( "Connection" );
                    connection = h.headerValueAsString();
                } else {
                    DBG( 3, "Connection: header not found, this is not an error" );
                    connection = "";
                }
                // FIXME: case insensitive compare
                if ( connection == "keep-alive" ) {
                    DBG( 3, "HTTPConnection::execute: keep-alive header found" );
                    response.addHeader( HTTPHeader( "Connection", "keep-alive" ) );
                    std::string tmp = "timeout=" + std::to_string(connectionTimeout) + ", max=" + std::to_string( requestLimit );
                    HTTPHeader header2( "Keep-Alive", tmp );
                    response.addHeader( header2 );
                    keepListening = true;
                }
            } else {
                DBG( 3, "Keep-Alive connection request limit (", requestLimit, ") reached" );
                // Now respond with the answer
                response.addHeader( HTTPHeader( "Connection", "close" ) );
                keepListening = false;
            }
            // Remove body if method is HEAD, it is using the same callback as GET but does not need the body
            if ( request.method() == HEAD ) {
                DBG( 1, "Method HEAD, removing body" );
                response.addBody( "" );
            }
            response.debugPrint();
            DBG( 3, "Writing back the response to the client" );
            socketStream_ << response;
            DBG( 3, "Now flushing the socket" );
            socketStream_.flush();
            DBG( 3, "Flushed, keep listening: ", keepListening );
        } while ( keepListening );

        DBG( 3, "Stopped listening and ending this HTTPConnection" );
    }

private:
    HTTPServer*  hs_;
    socketstream socketStream_;
    // struct sockaddr_in clientAddress_; // Not used yet
    std::vector<http_callback> const & callbackList_;
    std::vector<std::string> responseHeader_;
    std::string responseBody_;
    std::string protocol_;
};

class PeriodicCounterFetcher : public Work
{
public:
    PeriodicCounterFetcher( HTTPServer* hs ) : hs_(hs), run_(false), exit_(false) {}
    virtual ~PeriodicCounterFetcher() override {
        hs_ = nullptr;
    }

    void start( void ) {
        DBG( 4, "PeriodicCounterFetcher::start() called" );
        run_ = true;
    }

    void pause( void ) {
        DBG( 4, "PeriodicCounterFetcher::pause() called" );
        run_ = false;
    }

    void stop( void ) {
        DBG( 4, "PeriodicCounterFetcher::stop() called" );
        exit_ = true;
    }

    virtual void execute() override;

private:
    HTTPServer*       hs_;
    std::atomic<bool> run_;
    std::atomic<bool> exit_;
};

class HTTPServer : public Server {
public:
    HTTPServer() : Server( "", 80 ), stopped_( false ){
        DBG( 3, "HTTPServer::HTTPServer()" );
        callbackList_.resize( 256 );
        createPeriodicCounterFetcher();
        pcf_->start();
        SignalHandler::getInstance()->setHTTPServer( this );
    }

    HTTPServer( std::string const & ip, uint16_t port, bool useIPv4 = false ) : Server( ip, port, useIPv4 ), stopped_( false ) {
        DBG( 3, "HTTPServer::HTTPServer( ip=", ip, ", port=", port, " )" );
        callbackList_.resize( 256 );
        createPeriodicCounterFetcher();
        pcf_->start();
        SignalHandler::getInstance()->setHTTPServer( this );
    }

    HTTPServer( HTTPServer const & ) = delete;
    HTTPServer & operator = ( HTTPServer const & ) = delete;

    virtual ~HTTPServer() {
        if ( ! stopped_ ) {
            DBG( 0, "BUG: HTTPServer or derived class not explicitly stopped before destruction!" );
            stop();
        }
        SignalHandler::getInstance()->setHTTPServer( nullptr );
    }

public:
    virtual void run() override;

    void stop() {
        stopped_ = true;
        pcf_->stop();
        // pcf is a Work object in the threadpool, calling stop makes
        // it leave the loop and then automatically gets deleted,
        // we just set it to nullptr here
        pcf_ = nullptr;
        // It takes up to one second for a pcf to leave the loop
        std::this_thread::sleep_for( std::chrono::seconds(1) );
        ThreadPool::getInstance().emptyThreadPool();
    }

    // Register Callbacks
    void registerCallback( HTTPRequestMethod rm, http_callback hc )
    {
        callbackList_[rm] = hc;
    }

    void unregisterCallback( HTTPRequestMethod rm )
    {
        callbackList_[rm] = nullptr;
    }

    void addAggregator( std::shared_ptr<Aggregator> agp ) {
        DBG( 4, "HTTPServer::addAggregator( agp=", std::hex, agp.get(), " ) called" );

        agVectorMutex_.lock();
        agVector_.insert( agVector_.begin(), agp );
        if ( agVector_.size() > 30 ) {
            DBG( 4, "HTTPServer::addAggregator(): Removing last Aggegator" );
            agVector_.pop_back();
        }
        agVectorMutex_.unlock();
    }

    std::pair<std::shared_ptr<Aggregator>,std::shared_ptr<Aggregator>> getAggregators( size_t index, size_t index2 ) {
        if ( index == index2 )
            throw std::runtime_error("BUG: getAggregator: both indices are equal. Fix the code!" );

        // simply wait until we have enough samples to return
        while( agVector_.size() < ( (std::max)( index, index2 ) + 1 ) )
            std::this_thread::sleep_for(std::chrono::seconds(1));

        agVectorMutex_.lock();
        auto ret = std::make_pair( agVector_[ index ], agVector_[ index2 ] );
        agVectorMutex_.unlock();
        return ret;
    }

    bool checkForIncomingSSLConnection( socket_t fd ) {
        char ch = ' ';
#ifdef _WIN32
        int bytes = ::recv( fd, &ch, 1, MSG_PEEK );
#else
        ssize_t bytes = ::recv( fd, &ch, 1, MSG_PEEK );
#endif
        if ( SOCKET_ERROR == bytes ) {
#ifdef _WIN32
            DBG( 1, "recv call to peek for the first incoming character failed, WSAGetLastError = ", WSAGetLastError() );
#else
            DBG( 1, "recv call to peek for the first incoming character failed, errno = ", errno, ", strerror: ", strerror(errno) );
#endif
            throw std::runtime_error( "recv to peek first char failed" );
        } else if ( bytes == 0 ) {
            DBG( 0, "Connection was properly closed by the client, no bytes to read" );
            throw std::runtime_error( "No error but the connecton is closed so we should just wait for a new connection again" );
        }
        DBG( 1, "SSL: Peeked Char: ", (EOF == ch) ? std::string("EOF") : std::string(1, ch) );
        if ( ch == EOF )
            throw std::runtime_error( "Peeking for SSL resulted in EOF" );
        // for SSLv2 bit 7 is set and for SSLv3 and up the first ClientHello Message is 0x16
        if ( ( ch & 0x80 ) || ( ch == 0x16 ) ) {
            DBG( 3, "SSL detected" );
            return true;
        }
        return false;
    }

private:
    void createPeriodicCounterFetcher() {
        // We keep a pointer to pcf to start and stop execution
        // not to delete it when done with it, that is up to threadpool/workqueue
        pcf_ = new PeriodicCounterFetcher( this );
        wq_->addWork( pcf_ );
        pcf_->start();
    }

protected:
    std::vector<http_callback>               callbackList_;
    std::vector<std::shared_ptr<Aggregator>> agVector_;
    std::mutex agVectorMutex_;
    PeriodicCounterFetcher* pcf_;
    bool stopped_;
};

// Here to break dependency on HTTPServer
#ifdef _WIN32
BOOL WINAPI SignalHandler::handleSignal( DWORD signum )
{
    // Clean up, close socket and such
    std::cerr << "handleSignal: signal " << signum << " caught.\n";
    std::cerr << "handleSignal: closing socket " << networkSocket_ << "\n";
    ::close( networkSocket_ );
    std::cerr << "Cleaning up PMU:\n";
    PCM::getInstance()->cleanup();
    std::cerr << "Stopping HTTPServer\n";
    if (httpServer_)
        httpServer_->stop();
    std::cerr << "handleSignal: exiting with exit code 1...\n";
    exit(1);
    return TRUE;
}
#else
void SignalHandler::handleSignal( int signum )
{
    // Clean up, close socket and such
    std::cerr << "handleSignal: signal " << signum << " caught.\n";
    std::cerr << "handleSignal: closing socket " << networkSocket_ << "\n";
    ::close( networkSocket_ );
    std::cerr << "Stopping HTTPServer\n";
    httpServer_->stop();
    std::cerr << "Cleaning up PMU:\n";
    PCM::getInstance()->cleanup();
    std::cerr << "handleSignal: exiting with exit code 1...\n";
    exit(1);
}
#endif

void PeriodicCounterFetcher::execute() {
    using namespace std::chrono;
    system_clock::time_point now = system_clock::now();
    now = now + std::chrono::seconds(1);
    std::this_thread::sleep_until( now );
    while( 1 ) {
        if ( exit_ )
            break;
        if ( run_ ) {
            auto before = steady_clock::now();
            // create an aggregator
            std::shared_ptr<Aggregator> sagp = std::make_shared<Aggregator>();
            assert(sagp.get());
            DBG( 4, "PCF::execute(): AGP=", sagp.get(), " )" );
            // dispatch it
            sagp->dispatch( PCM::getInstance()->getSystemTopology() );
            // add it to the vector
            hs_->addAggregator( sagp );
            auto after = steady_clock::now();
            auto elapsed = duration_cast<std::chrono::milliseconds>(after - before);
            DBG( 4, "Aggregation Duration: ", elapsed.count(), "ms." );
        }
        now = now + std::chrono::seconds(1);
        std::this_thread::sleep_until( now );
    }
}

void HTTPServer::run() {
    struct sockaddr_in clientAddress;
    clientAddress.sin_family = AF_INET;
    socket_t clientSocketFD = INVALID_SOCKET;
    while ( ! stopped_ ) {
        // Listen on socket for incoming requests
        socklen_t sa_len = sizeof( struct sockaddr_in );
        socket_t retval = ::accept( serverSocket_, (struct sockaddr*)&clientAddress, &sa_len );
        if ( INVALID_SOCKET == retval ) {
#ifdef _WIN32
            DBG( 3, "Accept returned INVALID_SOCKET, WSAGetLastError: ", WSAGetLastError() );
#else
            DBG( 3, "Accept returned -1, errno: ", strerror( errno ) );
#endif
            continue;
        }
        clientSocketFD = retval;

        bool clientWantsSSL = false;
        try {
            clientWantsSSL = checkForIncomingSSLConnection( clientSocketFD );
        } catch( std::exception& e ) {
            DBG( 3, "Exception during checkForIncomingConnection: ", e.what(), ", closing clientsocketFD" );
            ::close( clientSocketFD );
            continue;
        }

        // HTTPServer so we cannot do SSL
        if ( clientWantsSSL ) {
            DBG( 0, "Client wants SSL but we can't speak SSL ourselves" );
            // TODO: return a 403 response, then close the connection
            DBG( 3, "close clientsocketFD" );
            ::close( clientSocketFD );
            continue;
        }

        // Client connected, let's determine the client ip as string.
        char ipbuf[INET_ADDRSTRLEN];
        std::fill(ipbuf, ipbuf + INET_ADDRSTRLEN, 0);
        char const * resbuf = ::inet_ntop( AF_INET, &(clientAddress.sin_addr), ipbuf, INET_ADDRSTRLEN );
        if ( nullptr == resbuf ) {
#ifdef _WIN32
            DBG( 3, "inet_ntop returned nullptr, WSAGetLastError: ", WSAGetLastError() );
#else
            DBG( 3, "inet_ntop returned -1, strerror: ", strerror( errno ) );
#endif
            DBG( 3, "close clientsocketFD" );
            ::close( clientSocketFD );
            continue;
        }

        int port = ntohs( clientAddress.sin_port );
        DBG( 3, "Client IP is: ", ipbuf, ", and the port it uses is : ", port );

        HTTPConnection* connection = nullptr;
        try {
            connection = new HTTPConnection( this, clientSocketFD, clientAddress, callbackList_ );
        } catch ( std::exception& e ) {
            DBG( 3, "Exception caught while creating a HTTPConnection: " );
            deleteAndNullify( connection );
            DBG( 3, "close clientsocketFD" );
            ::close( clientSocketFD );
            continue;
        }

        if ( stopped_ ) {
            // Overkill if you know the program flow but we want to be overly cautious...
            deleteAndNullify( connection );
            break;
        }
        wq_->addWork( connection );
    }
}

#if defined (USE_SSL)
class HTTPSServer : public HTTPServer {
public:
    HTTPSServer() : HTTPServer( "", 443 ) {}
    HTTPSServer( std::string const & ip, uint16_t port, bool useIPv4 = false ) : HTTPServer( ip, port, useIPv4 ), sslCTX_( nullptr ) {}
    HTTPSServer( HTTPSServer const & ) = delete;
    HTTPSServer & operator = ( HTTPSServer const & ) = delete;
    virtual ~HTTPSServer() {
        if ( ! stopped_ ) {
            DBG( 0, "BUG: HTTPServer or derived class not explicitly stopped before destruction!" );
            stop();
        }
        // Program ends after this, no need to set it to nullptr
        SSL_CTX_free( sslCTX_ );
        sslCTX_ = nullptr; // a reuse of sslCTX_ can never happen but we want to be overly cautious.
    }

public:
    virtual void run() final;

public:
    void setPrivateKeyFile ( std::string const & privateKeyFile )  { privateKeyFile_  = privateKeyFile;  }
    void setCertificateFile( std::string const & certificateFile ) { certificateFile_ = certificateFile; }

    void initialiseSSL() {
        if ( nullptr != sslCTX_ )
            throw std::runtime_error( "HTTPSServer SSL already initialised" );
        if ( privateKeyFile_.empty() )
            throw std::runtime_error( "No private key file given" );
        if ( certificateFile_.empty() )
            throw std::runtime_error( "No certificate file given" );

        SSL_library_init();
        SSL_load_error_strings();
        // SSL too old on development machine, not available yet FIXME
        //OPENSSL_config(nullptr);

        // We require 1.1.1 now so TLS_method is available but still 
        // make sure minimum protocol is TSL1_VERSION below
        sslCTX_ = SSL_CTX_new( TLS_method() );
        if ( nullptr == sslCTX_ )
            throw std::runtime_error( "Cannot create an SSL context" );
        DBG( 3, "SSLCTX set up" );
        if( SSL_CTX_set_min_proto_version( sslCTX_, TLS1_VERSION ) != 1 )
            throw std::runtime_error( "Cannot set minimum protocol to TSL1_VERSION" );
        DBG( 3, "Min TLS Version set" );
        if ( SSL_CTX_use_certificate_file( sslCTX_, certificateFile_.c_str(), SSL_FILETYPE_PEM ) <= 0 )
            throw std::runtime_error( "Cannot use certificate file" );
        DBG( 3, "Certificate file set up" );
        if ( SSL_CTX_use_PrivateKey_file( sslCTX_, privateKeyFile_.c_str(), SSL_FILETYPE_PEM ) <= 0 )
            throw std::runtime_error( "Cannot use private key file" );
        DBG( 3, "Private key set up" );
    }

private:
    SSL_CTX* sslCTX_ = nullptr;
    std::string certificateFile_;
    std::string privateKeyFile_;
};

void HTTPSServer::run() {
    struct sockaddr_in clientAddress;
    clientAddress.sin_family = AF_INET;
    socket_t clientSocketFD = INVALID_SOCKET;
    // Check SSL CTX for validity
    if ( nullptr == sslCTX_ )
        throw std::runtime_error( "No SSL_CTX created" );

    while ( ! stopped_ ) {
        // Listen on socket for incoming requests, same as for regular connection
        socklen_t sa_len = sizeof( struct sockaddr_in );
        socket_t retval = ::accept( serverSocket_, (struct sockaddr*)&clientAddress, &sa_len );
        DBG( 3, "RegularAccept: (if not INVALID_SOCKET it is client socket descriptor) ", retval );
        if ( INVALID_SOCKET == retval ) {
#ifdef _WIN32
            DBG( 3, "Accept failed: WSAGetLastError( ): ", WSAGetLastError() );
#else
            DBG( 3, "Accept failed: strerror( ", errno, " ): ", strerror( errno ) );
#endif
            continue;
        }
        clientSocketFD = retval;

        bool clientWantsSSL = false;
        try {
            clientWantsSSL = checkForIncomingSSLConnection( clientSocketFD );
        } catch( std::exception& e ) {
            DBG( 3, "Exception during checkForIncomingConnection: ", e.what(), ", closing clientsocketFD" );
            ::close( clientSocketFD );
            continue;
        }

        // HTTPSServer so we want to do SSL
        if ( ! clientWantsSSL ) {
            DBG( 0, "Client wants Plain HTTP but we want to speak SSL ourselves" );
            // TODO: return a 403 response, then close the connection
            DBG( 3, "close clientsocketFD" );
            ::close( clientSocketFD );
            continue;
        }

        // Create and setup SSL on the socket
        SSL* ssl = SSL_new( sslCTX_ );
        if (ssl == nullptr ) {
            DBG( 3, "We're in big trouble, we could not create an SSL object with the SSL_CTX..." );
            throw std::runtime_error( "Could not create SSL object" );
        }
        int ret = SSL_set_fd( ssl, clientSocketFD );
        DBG( 3, "set_fd: ret = ", ret );
        if (ret == 0 ) {
            DBG( 3, "SSL_set_fd returned 0, oops...", ret );
            throw std::runtime_error("SSL_set_fd returned 0, oops...");
        }

        bool cleanupAndRestartListening = false;
        while (1) {
            bool leaveLoop = true;
            // Check if the SSL handshake worked
            int accept = SSL_accept( ssl );
            DBG( 3, "SSL_accept: ", accept );
            if ( 0 >= accept ) {
                int errorCode = SSL_get_error( ssl, accept );
                if ( errorCode == SSL_ERROR_ZERO_RETURN ) {
                    // TLS/SSL Connection has been closed, socket may not though
                    cleanupAndRestartListening = true;
                    break;
                }
                int err = 0;
                char buf[256];
                DBG( 3, "errorCode: ", errorCode );
                switch ( errorCode ) {
                case SSL_ERROR_WANT_READ:
                case SSL_ERROR_WANT_WRITE:
                    // All good, just try again
                    leaveLoop = false;
                    break;
                case SSL_ERROR_SSL:
                case SSL_ERROR_SYSCALL:
                    err = ERR_get_error();
                    DBG( 3, "ERR_get_error(): ", err  );
                    ERR_error_string( err, buf );
                    DBG( 3, "ERR_error_string(): ", buf );
                    cleanupAndRestartListening = true;
                    break;
                default:
                    DBG( 3, "Unhandled SSL Error: ", errorCode );
                    ERR_print_errors_fp( stderr);
                    cleanupAndRestartListening = true;
                }
            }
            ERR_clear_error(); // Clear error because SSL_get_error does not do so
            if ( leaveLoop )
                break;
        }

        if ( cleanupAndRestartListening ) {
            // Here we still have not passed it to socket_buffer so we need to deal with shutdown properly.
            DBG( 3, "SSL Accept: error accepting incoming connection, closing the FD and continuing: " );
            closeSSLConnectionAndFD( clientSocketFD, ssl );
            continue;
        }

        DBG( 1, "Server: client connected successfully, starting a new HTTPConnection" );
        // Client connected, let's determine the client ip as string.
        char ipbuf[INET_ADDRSTRLEN];
        memset( ipbuf, 0, 16 );
        char const * resbuf = ::inet_ntop( AF_INET, &(clientAddress.sin_addr), ipbuf, INET_ADDRSTRLEN );
        if ( nullptr == resbuf ) {
#ifdef _WIN32
            DBG( 3, "inet_ntop returned an error: ", WSAGetLastError(), "\n");
#else
            DBG( 3, "inet_ntop returned an error: ", errno, ", error string: ", strerror( errno ), "\n");
#endif
            ERR_clear_error();
            SSL_free( ssl ); // Free the SSL structure to prevent memory leaks
            ssl = nullptr;
            DBG( 3, "close clientsocketFD" );
            ::close( clientSocketFD );
            continue;
        }

        int port = ntohs( clientAddress.sin_port );
        DBG( 3, "Client IP is: ", ipbuf, ", and the port it uses is : ", port );
        DBG( 3, "SSL info: version: ", SSL_get_version( ssl ), ", stuff" );

        // Ownership of ssl is now passed to HTTPConnection, it will delete ssl when done
        HTTPConnection* connection = new HTTPConnection( this, clientSocketFD, clientAddress, callbackList_, ssl );
        ssl = nullptr;

        if ( stopped_ ) {
            // Overkill if you know the program flow but we want to be overly cautious...
            deleteAndNullify( connection );
            break;
        }
        wq_->addWork( connection );
    }
}
#endif // USE_SSL

// Hack needed to convert from unsigned char to signed char, favicon.h is changed to have _uc for each char
inline constexpr signed char operator "" _uc( unsigned long long arg ) noexcept {
    return static_cast<signed char>(arg);
}

#include "favicon.ico.h"

std::pair<std::shared_ptr<Aggregator>,std::shared_ptr<Aggregator>> getNullAndCurrentAggregator() {
    std::shared_ptr<Aggregator> current = std::make_shared<Aggregator>();
    std::shared_ptr<Aggregator> null    = std::make_shared<Aggregator>();
    assert(current.get());
    current->dispatch( PCM::getInstance()->getSystemTopology() );
    return std::make_pair( null, current );
}

enum OutputFormat {
    Prometheus_0_0_4 = 1,
    JSON,
    HTML,
    XML,
    PlainText,
    OutputFormat_Spare = 255
};

std::unordered_map<enum MimeType, enum OutputFormat, std::hash<int>> mimeTypeToOutputFormat = {
    { TextHTML,            HTML },
    { TextXML,             XML  },
    { ApplicationJSON,     JSON },
    { TextPlainProm_0_0_4, Prometheus_0_0_4 },
    { CatchAll,            HTML }
};

std::unordered_map<enum MimeType, std::string, std::hash<int>> supportedOutputMimeTypes = {
    { TextPlainProm_0_0_4, "text/plain;version=0.0.4" },
    { ApplicationJSON,     "application/json" }
};

enum MimeType matchSupportedWithAcceptedMimeTypes( HTTPHeader const& h ) {
    auto list = h.headerValueAsList();
    // TODO: We should actually build up a list of accepted mimetypes and their preference, sort
    // the list and then compare against it. We now use the inherent order as preference which
    // is not entirely accurate but is good enough.
    for ( auto& item : list ) {
        DBG( 2, "Item: \"", item, "\"" );
        // Search for preference and remove it
        auto copy = item;
        size_t pos;
        // Using erase with npos as second parameter to be explicit about the intent: delete until end
        if ( std::string::npos != ( pos = item.find( "q=", 0 ) ) ){
            // found it, remove q=...
            copy.erase( pos, std::string::npos );
            DBG( 2, "q= found and erased: \"", copy, "\"" );
            if ( std::string::npos != ( pos = item.rfind( ";", pos ) ) ) {
                // remove trailing ;
                copy.erase( pos, std::string::npos );
                DBG( 2, "trailing ';' found and erased: \"", copy, "\"" );
            }
        }
        // remove all whitespace from the item
        copy.erase( std::remove_if( copy.begin(), copy.end(), ::isspace ), copy.end() );
        // compare mimetype with supported ones
        for ( auto& mimetype : supportedOutputMimeTypes ) {
            auto str = mimetype.second;
            str.erase( std::remove_if( str.begin(), str.end(), ::isspace ), str.end() );
            DBG( 2, "Comparing mimetype '", copy, "' with known Mimetype '", str, "'" );
            if ( str == copy ) {
                DBG( 2, "Found a match!" );
                return mimetype.first;
            }
        }
    }
    return CatchAll;
}

/* Normally the Accept Header decides what format is returned but certain endpoints can override this,
 * therefore we have a separate enum for output format */
void my_get_callback( HTTPServer* hs, HTTPRequest const & req, HTTPResponse & resp )
{
    enum MimeType mt;
    enum OutputFormat format;

    HTTPHeader accept;
    if ( req.hasHeader( "Accept" ) ) {
        accept = req.getHeader( "Accept" );
        mt = matchSupportedWithAcceptedMimeTypes( accept );
    } else {
        // If there is no accept header then the assumption is that the client can handle anything
        mt = CatchAll;
    }
    format = mimeTypeToOutputFormat[ mt ];

    URL url;
    url = req.url();

    DBG( 3, "PATH=\"", url.path_, "\", size=", url.path_.size() );

    if ( url.path_ == "/favicon.ico" ) {
        DBG( 3, "my_get_callback: client requesting '/favicon.ico'" );
        std::string favicon( favicon_ico, favicon_ico + favicon_ico_len );
        resp.createResponse( ImageXIcon, favicon, RC_200_OK );
        return;
    }

    std::pair<std::shared_ptr<Aggregator>,std::shared_ptr<Aggregator>> aggregatorPair;

    if ( (1 == url.path_.size()) && (url.path_ == "/") ) {
        DBG( 3, "my_get_callback: client requesting '/'" );
        // If it is not Prometheus and not JSON just return this html code
        // It might violate the protocol but it makes coding this easier
        if ( ApplicationJSON != mt && TextPlainProm_0_0_4 != mt ) {
            // If you make changes to the HTML, please validate it
            // Probably best to put this in static files and serve this
            std::string body = "\
<!DOCTYPE html>\n\
<html lang=\"en\">\n\
  <head>\n\
    <title>PCM Sensor Server</title>\n\
  </head>\n\
  <body>\n\
    <h1>PCM Sensor Server</h1>\n\
    <p>PCM Sensor Server provides performance counter data through an HTTP interface. By default this text is served when requesting the endpoint \"/\".</p>\n\
    <p>The endpoints for retrieving counter data, /, /persecond and /persecond/X, support returning data in JSON or prometheus format. For JSON have your client send the HTTP header \"Accept: application/json\" and for prometheus \"Accept: text/plain; version=0.0.4\" along with the request, PCM Sensor Server will then return the counter data in the requested format.</p>\n\
    <p>Endpoints you can call are:</p>\n\
    <ul>\n\
      <li>/ : This will fetch the counter values since start of the daemon, minus overflow so should be considered absolute numbers and should be used for further processing by yourself.</li>\n\
      <li>/persecond : This will fetch data from the internal sample thread which samples every second and returns the difference between the last 2 samples.</li>\n\
      <li>/persecond/X : This will fetch data from the internal sample thread which samples every second and returns the difference between the last 2 samples which are X seconds apart. X can be at most 30 seconds without changing the source code.</li>\n\
      <li>/metrics : The Prometheus server does not send an Accept header to decide what format to return so it got its own endpoint that will always return data in the Prometheus format. pcm-sensor-server is sending the header \"Content-Type: text/plain; version=0.0.4\" as required. This /metrics endpoints mimics the same behavior as / and data is thus absolute, not relative.</li>\n\
      <li>/dashboard/influxdb : This will return JSON for a Grafana dashboard with InfluxDB backend that holds all counters. Please see the documentation for more information.</li>\n\
      <li>/dashboard/prometheus : This will return JSON for a Grafana dashboard with Prometheus backend that holds all counters. Please see the documentation for more information.</li>\n\
      <li>/dashboard/prometheus/default : Same as /dashboard/prometheus but tuned for existing installations with default Prometheus scrape period of 15 seconds and the rate of 1 minute in Grafana. Please see the documentation for more information.</li>\n\
      <li>/dashboard : same as /dashboard/influxdb </li>\n\
      <li>/favicon.ico : This will return a small favicon.ico as requested by many browsers.</li>\n\
    </ul>\n\
  </body>\n\
</html>\n";
            resp.createResponse( TextHTML, body, RC_200_OK );
            return;
        }

        //std::shared_ptr<Aggregator> current;
        //std::shared_ptr<Aggregator> null;
        //current = std::make_shared<Aggregator>();
        //null    = std::make_shared<Aggregator>();
        //current->dispatch( PCM::getInstance()->getSystemTopology() );
        //aggregatorPair = std::make_pair( null, current );
        aggregatorPair = getNullAndCurrentAggregator();
    } else if ( url.path_ == "/dashboard" || url.path_ == "/dashboard/influxdb") {
        DBG( 3, "client requesting /dashboard path: '", url.path_, "'" );
        resp.createResponse( ApplicationJSON, getPCMDashboardJSON(InfluxDB), RC_200_OK );
        return;
    }
    else if (url.path_ == "/dashboard/prometheus") {
        DBG( 3, "client requesting /dashboard path: '", url.path_, "'");
        resp.createResponse(ApplicationJSON, getPCMDashboardJSON(Prometheus), RC_200_OK);
        return;
    }
    else if (url.path_ == "/dashboard/prometheus/default") {
        DBG( 3, "client requesting /dashboard path: '", url.path_, "'");
        resp.createResponse(ApplicationJSON, getPCMDashboardJSON(Prometheus_Default), RC_200_OK);
        return;
    } else if ( 0 == url.path_.rfind( "/persecond", 0 ) ) {
        DBG( 3, "client requesting /persecond path: '", url.path_, "'" );
        if ( 10 == url.path_.size() || ( 11 == url.path_.size() && url.path_.at(10) == '/' ) ) {
            DBG( 3, "size == 10 or 11" );
            // path looks like /persecond or /persecond/
            aggregatorPair = hs->getAggregators( 1, 0 );
        } else {
            DBG( 3, "size > 11: size = ", url.path_.size() );
            // We're looking for value X after /persecond/X and possibly a trailing / anything else not
            url.path_.erase( 0, 10 ); // remove /persecond
            DBG( 3, "after removal: path = \"", url.path_, "\", size = ", url.path_.size() );
            if ( url.path_.at(0) == '/' ) {
                url.path_.erase( 0, 1 );
                if ( url.path_.at( url.path_.size() - 1 ) == '/' ) {
                    url.path_.pop_back();
                }
                if ( std::all_of( url.path_.begin(), url.path_.end(), ::isdigit ) ) {
                    size_t seconds;
                    try {
                        seconds = std::stoll( url.path_ );
                    } catch ( std::exception& e ) {
                        DBG( 3, "Error during conversion of /persecond/ seconds: ", e.what() );
                        seconds = 0;
                    }
                    if ( 1 <= seconds && 30 >= seconds ) {
                        aggregatorPair = hs->getAggregators( seconds, 0 );
                    } else {
                        DBG( 3, "seconds equals 0 or seconds larger than 30 is not allowed" );
                        std::string body( "400 Bad Request. seconds equals 0 or seconds larger than 30 is not allowed" );
                        resp.createResponse( TextPlain, body, RC_400_BadRequest );
                        return;
                    }
                } else {
                    DBG( 3, "/persecond/ Not followed by all numbers" );
                    std::string body( "400 Bad Request Request starts with /persecond/ but is not followed by numbers only." );
                    resp.createResponse( TextPlain, body, RC_400_BadRequest );
                    return;
                }
            } else {
                DBG( 3, "/persecond something requested: something=\"", url.path_, "\"" );
                std::string body( "404 Bad Request. Request starts with /persecond but contains bad characters." );
                resp.createResponse( TextPlain, body, RC_404_NotFound );
                return;
            }
        }
    } else if ( 8 == url.path_.size() && 0 == url.path_.find( "/metrics", 0 ) ) {
        DBG( 3, "Special snowflake prometheus wants a /metrics URL, it can't be bothered to use its own mimetype in the Accept header" );
        format = Prometheus_0_0_4;
        aggregatorPair = getNullAndCurrentAggregator();
    } else {
        DBG( 3, "Unknown path requested: \"", url.path_, "\"" );
        std::string body( "404 Unknown path." );
        resp.createResponse( TextPlain, body, RC_404_NotFound );
        return;
    }

    switch ( format ) {
    case JSON:
    {
        JSONPrinter jp( aggregatorPair );
        jp.dispatch( PCM::getInstance()->getSystemTopology() );
        resp.createResponse( ApplicationJSON, jp.str(), RC_200_OK );
        break;
    }
    case Prometheus_0_0_4:
    {
        PrometheusPrinter pp( aggregatorPair );
        pp.dispatch( PCM::getInstance()->getSystemTopology() );
        resp.createResponse( TextPlainProm_0_0_4, pp.str(), RC_200_OK );
        break;
    }
    default:
        std::string body( "406 Not Acceptable. Server can only serve \"" );
        body += req.url().path_ + "\" as application/json or \"text/plain; version=0.0.4\" (prometheus format).";
        resp.createResponse( TextPlain, body, RC_406_NotAcceptable );
    }
}

int startHTTPServer( const std::string& listenAddr, unsigned short port, bool useIPv4 = false ) {
    HTTPServer server( listenAddr, port, useIPv4 );
    try {
        // HEAD is GET without body, we will remove the body in execute()
        server.registerCallback( HTTPRequestMethod::GET,  my_get_callback );
        server.registerCallback( HTTPRequestMethod::HEAD, my_get_callback );
        server.run();
    } catch (std::exception & e) {
        std::cerr << "Exception caught: " << e.what() << "\n";
        return -1;
    }
    return 0;
}

#if defined (USE_SSL)
int startHTTPSServer( const std::string& listenAddr, unsigned short port, std::string const & cFile, std::string const & pkFile, bool useIPv4 = false ) {
    HTTPSServer server( listenAddr, port, useIPv4 );
    try {
        server.setPrivateKeyFile ( pkFile );
        server.setCertificateFile( cFile );
        server.initialiseSSL();
        // HEAD is GET without body, we will remove the body in execute()
        server.registerCallback( HTTPRequestMethod::GET,  my_get_callback );
        server.registerCallback( HTTPRequestMethod::HEAD, my_get_callback );
        server.run();
    } catch (std::exception & e) {
        std::cerr << "Exception caught: " << e.what() << "\n";
        return -1;
    }
    return 0;
}
#endif

// Validate IP address string (IPv4 or IPv6)
bool isValidIPAddress( const std::string& ipAddress ) {
    if ( ipAddress.empty() ) {
        return true;  // Empty string is valid - means bind to all interfaces
    }
    
    // Try IPv4 first
    struct sockaddr_in sa4;
    if ( 1 == ::inet_pton( AF_INET, ipAddress.c_str(), &(sa4.sin_addr) ) ) {
        return true;
    }
    
    // Try IPv6
    struct sockaddr_in6 sa6;
    if ( 1 == ::inet_pton( AF_INET6, ipAddress.c_str(), &(sa6.sin6_addr) ) ) {
        return true;
    }
    
    return false;
}

void printHelpText( std::string const & programName ) {
    std::cout << "Usage: " << programName << " [OPTION]\n\n";
    std::cout << "Valid Options:\n";
#ifndef _WIN32
    std::cout << "    -d                   : Run in the background\n";
#endif
#if defined (USE_SSL)
    std::cout << "    -s                   : Use https protocol (default port " << DEFAULT_HTTPS_PORT << ")\n";
#endif
    std::cout << "    -p portnumber        : Run on port <portnumber> (default port is " << DEFAULT_HTTP_PORT << ")\n";
    std::cout << "    -l|--listen address  : Listen on IP address <address> (default: all interfaces)\n";
#ifndef _WIN32
    std::cout << "    -4|--ipv4            : Use IPv4 instead of IPv6 (non-Windows only)\n";
#endif
    std::cout << "    -r|--reset           : Reset programming of the performance counters.\n";
    std::cout << "    -D|--debug level     : level = 0: no debug info, > 0 increase verbosity.\n";
#if !defined(__APPLE__) && !defined(_WIN32)
    std::cout << "    -R|--real-time       : If possible the daemon will run with real time\n";
    std::cout << "                           priority, could be useful under heavy load to \n";
    std::cout << "                           stabilize the async counter fetching.\n";
#endif
#if defined (USE_SSL)
    std::cout << "    -C|--certificateFile : \n";
    std::cout << "    -P|--privateKeyFile  : \n";
#endif
    std::cout << "    -h|--help            : This information\n";
    std::cout << "    -silent              : Silence information output and print only measurements\n";
    std::cout << "    --version            : Print application version\n";
    print_help_force_rtm_abort_mode(25, ":");
}

#ifndef UNIT_TEST

/* Main */
PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[]) {

    if(print_version(argc, argv))
        exit(EXIT_SUCCESS);

    // Argument handling
    bool daemonMode = false;
#if defined (USE_SSL)
    bool useSSL = false;
#endif
    bool forcedProgramming = false;
#ifndef __APPLE__
    bool useRealtimePriority = false;
#endif
    bool forceRTMAbortMode = false;
    bool printTopology = false;
    bool useIPv4 = false;
    unsigned short port = 0;
    unsigned short debug_level = 0;
    std::string listenAddress = "";  // Empty string means listen on all interfaces
    std::string certificateFile;
    std::string privateKeyFile;
    AcceleratorCounterState *accs_ = AcceleratorCounterState::getInstance();
    null_stream nullStream;
    check_and_set_silent(argc, argv, nullStream);
    ACCEL_IP accel=ACCEL_NOCONFIG; //default is no device
    bool evtfile = false;
    std::string specify_evtfile;
    // ACCEL_DEV_LOC_MAPPING loc_map = SOCKET_MAP; //default is socket mapping
    MainLoop mainLoop;

    auto PPTEnv = pcm::safe_getenv( "PCMSENSORSERVER_PRINT_TOPOLOGY" );
    if ( ! PPTEnv.empty() ) {
        if ( 1 == std::stoi(PPTEnv) ) {
            printTopology = true;
        }
    } else if ( argc > 1 ) {
        std::string arg_value;

        for ( int i=1; i < argc; ++i ) {
            if ( check_argument_equals( argv[i], {"-d"} ) )
                daemonMode = true;
            else if ( check_argument_equals( argv[i], {"-p"} ) )
            {
                if ( (++i) < argc ) {
                    std::stringstream ss( argv[i] );
                    try {
                        ss >> port;
                    } catch( std::exception& e ) {
                        std::cerr << "main: port number is not an unsigned short!\n";
                        ::exit( 2 );
                    }
                } else {
                    throw std::runtime_error( "main: Error no port argument given" );
                }
            }
            else if ( check_argument_equals( argv[i], {"-l", "--listen"} ) )
            {
                if ( (++i) < argc ) {
                    listenAddress = argv[i];
                    if ( !isValidIPAddress( listenAddress ) ) {
                        std::cerr << "Error: Invalid IP address '" << listenAddress << "'. ";
                        std::cerr << "Please provide a valid IPv4 or IPv6 address.\n";
                        exit( 1 );
                    }
                } else {
                    throw std::runtime_error( "main: Error no listen address argument given" );
                }
            }
#ifndef _WIN32
            else if ( check_argument_equals( argv[i], {"-4", "--ipv4"} ) )
            {
                useIPv4 = true;
            }
#endif
#if defined (USE_SSL)
            else if ( check_argument_equals( argv[i], {"-s"} ) )
            {
                useSSL = true;
            }
#endif
            else if ( check_argument_equals( argv[i], {"-r", "--reset"} ) )
            {
                forcedProgramming = true;
            }
            else if ( check_argument_equals( argv[i], {"-D", "--debug"} ) )
            {
                if ( (++i) < argc ) {
                    std::stringstream ss( argv[i] );
                    try {
                        ss >> debug_level;
                    } catch( std::exception& e ) {
                        std::cerr << "main: debug level is not an unsigned short!\n";
                        ::exit( 2 );
                    }
                } else {
                    throw std::runtime_error( "main: Error no debug level argument given" );
                }
            }
#ifndef __APPLE__
            else if ( check_argument_equals( argv[i], {"-R", "--real-time"} ) )
            {
                useRealtimePriority = true;
            }
#endif
            else if ( check_argument_equals( argv[i], {"--help", "-h", "/h"} ) )
            {
                printHelpText( argv[0] );
                exit(0);
            }
            else if (check_argument_equals( argv[i], { "-force-rtm-abort-mode" }))
            {
                forceRTMAbortMode = true;
            }
            else if (check_argument_equals(argv[i], {"-iaa", "/iaa"}))
            {
                accel = ACCEL_IAA;  
            }
            else if (check_argument_equals(argv[i], {"-dsa", "/dsa"}))
            {
                accel = ACCEL_DSA;
                std::cout << "Aggregator firstest : " << accs_->getAccelCounterName() << accel; 
            }
#ifdef __linux__
            else if (check_argument_equals(argv[i], {"-qat", "/qat"}))
            {
                accel = ACCEL_QAT;
            }
            // else if (check_argument_equals(argv[i], {"-numa", "/numa"}))
            // {
            //     loc_map = NUMA_MAP;
            // }
#endif
            else if (extract_argument_value(argv[i], {"-evt", "/evt"}, arg_value))
            {
                evtfile = true;
                specify_evtfile = std::move(arg_value);
            }
            else if ( check_argument_equals( argv[i], {"-silent", "/silent"} ) )
            {
                // handled in check_and_set_silent
                continue;
            }
#if defined (USE_SSL)
            else if ( check_argument_equals( argv[i], {"-C", "--certificateFile"} ) ) {

                if ( (++i) < argc ) {
                    std::ifstream fp( argv[i] );
                    if ( ! fp.is_open() ) {
                        std::cerr << "Cannot open certificate file \"" << argv[i] << "\".\n";
                        printHelpText( argv[0] );
                        exit( 3 );
                    }
                    certificateFile = argv[i];
                } else {
                    std::cerr << "Missing certificate file argument.\n";
                    printHelpText( argv[0] );
                    exit( 3 );
                }
            }
            else if ( check_argument_equals( argv[i], {"-P", "--privateKeyFile"} ) ) {

                if ( (++i) < argc ) {
                    std::ifstream fp( argv[i] );
                    if ( ! fp.is_open() ) {
                        std::cerr << "Cannot open private key file \"" << argv[i] << "\".\n";
                        printHelpText( argv[0] );
                        exit( 4 );
                    }
                    privateKeyFile = argv[i];
                } else {
                    std::cerr << "Missing private key file argument.\n";
                    printHelpText( argv[0] );
                    exit( 4 );
                }
            }
#endif
            else
                throw std::runtime_error( "Unknown argument" );
        }
    }

#ifdef __linux__
    // check kernel version for driver dependency.
    if (accel != ACCEL_NOCONFIG)
    {
        std::cout << "Info: IDX - Please ensure the required driver(e.g idxd driver for iaa/dsa, qat driver and etc) correct enabled with this system, else the tool may fail to run.\n";
        struct utsname sys_info;
        if (!uname(&sys_info))
        {
            std::string krel_str;
            uint32 krel_major_ver=0, krel_minor_ver=0;
            krel_str = sys_info.release;
            std::vector<std::string> krel_info = split(krel_str, '.');
            std::istringstream iss_krel_major(krel_info[0]);
            std::istringstream iss_krel_minor(krel_info[1]);
            iss_krel_major >> std::setbase(0) >> krel_major_ver;
            iss_krel_minor >> std::setbase(0) >> krel_minor_ver;

            switch (accel)
            {
                case ACCEL_IAA:
                case ACCEL_DSA:
                    if ((krel_major_ver < 5) || (krel_major_ver == 5 && krel_minor_ver < 11))
                    {
                        std::cout<< "Warning: IDX - current linux kernel version(" << krel_str << ") is too old, please upgrade it to the latest due to required idxd driver integrated to kernel since 5.11.\n";
                    }
                    break;
                default:
                    std::cout<< "Info: Chosen "<< accel<<" IDX - current linux kernel version(" << krel_str << ")";

            }
        }
    }
#endif

    debug::dyn_debug_level( debug_level );

#if defined (USE_SSL)
    if ( useSSL ) {
        if ( certificateFile.empty() || privateKeyFile.empty() ) {
            std::cerr << "Error: wanting to use SSL but missing certificate and or private key file(s).\n";
            printHelpText( argv[0] );
            exit( 5 );
        }
    }
#endif

#if !defined(__APPLE__) && !defined(_WIN32)
    if ( useRealtimePriority ) {
        int priority = sched_get_priority_min( SCHED_RR );
        if ( priority == -1 ) {
            std::cerr << "Could not get SCHED_RR min priority: " << strerror( errno ) << "\n";
            exit( 6 );
        } else {
            struct sched_param sp = { .sched_priority = priority };
            if ( sched_setscheduler(0, SCHED_RR, &sp ) == -1 ) {
                int errnosave = errno;
                std::cerr << "Could not set scheduler to realtime! Errno: " << errnosave << "\n";
                std::cerr << "Error message: \"" << strerror( errnosave ) << "\"\n";
                exit( 6 );
            } else {
                std::cerr << "Scheduler changed to SCHED_RR and priority to " << priority << "\n";
            }
        }
    }
#endif

#ifdef _WIN32
    // Windows doesn't support fork(), so daemon mode is not available
    if ( daemonMode ) {
        std::cerr << "Daemon mode is not supported on Windows. Starting in foreground mode.\n";
        daemonMode = false;
    }
    const int pid = 0; // Always run in foreground on Windows
#else
    pid_t pid;
    if ( daemonMode )
        pid = fork();
    else
        pid = 0;
#endif

    if ( pid == 0 ) {
        /* child (or Windows foreground mode) */
        // Default programming is to use normal core counters and memory bandwidth counters
        // and if pmem is available to also show this instead of partial writes
        // A HTTP interface to change the programming is planned
        PCM::ErrorCode status;
        PCM * pcmInstance = PCM::getInstance();
        pcmInstance->setAccel(accel);
        assert(pcmInstance);
        if (forceRTMAbortMode)
        {
            pcmInstance->enableForceRTMAbortMode();
        }
        do {
            status = pcmInstance->program();

            switch ( status ) {
                case PCM::PMUBusy:
                {
                    if ( forcedProgramming == false ) 
                    {
                        std::cout << "Warning: PMU appears to be busy, do you want to reset it? (y/n)\n";
                        char answer;
                        std::cin >> answer;
                        if ( answer == 'y' || answer == 'Y' )
                            pcmInstance->resetPMU();
                        else
                            exit(0);
                    } else {
                        pcmInstance->resetPMU();
                    }
                    break;
                }
                case PCM::Success:
                    break;
                case PCM::MSRAccessDenied:
                case PCM::UnknownError:
                default:
                    exit(1);
            }
        } while( status != PCM::Success );

        if ( pcmInstance->PMMTrafficMetricsAvailable() ) {
            DBG( 1, "Programmed PMEM R/W BW instead of Partial Writes" );
        } else {
            DBG( 1, "Programmed Partial Writes instead of PMEM R/W BW" );
        }

        //TODO: check return value when its implemented  
        pcmInstance->programCXLCM();

        if (pcmInstance->getAccel()!=ACCEL_NOCONFIG)
        {
            if (pcmInstance->supportIDXAccelDev() == false)
            {
                std::cerr << "Error: IDX accelerator is NOT supported with this platform! Program aborted\n";
                exit(EXIT_FAILURE);
            }

            accs_->setEvents(pcmInstance,accel,specify_evtfile,evtfile);

            accs_->programAccelCounters();
        }

        if ( printTopology ) {
            TopologyPrinter* tp = new TopologyPrinter();
            tp->dispatch( PCM::getInstance()->getSystemTopology() );
            std::vector<std::string> & tpData = tp->topologyDataStrings();
            std::sort( tpData.begin(), tpData.end(), TopologyStringCompare );
            for( auto& line: tpData ) {
                std::cout << line << "\n";
            }
            deleteAndNullify( tp );
            delete pcmInstance;
            return( 0 );
        }

        std::vector<struct iio_stacks_on_socket> iios;
        iio_evt_parse_context evt_ctx;
        std::string ev_file_name;

        // TODO: add check for IIO support before trying to initialize the pmu
        // Map with metrics names.
        // PCIeEventNameMap nameMap;
// Otto: re-add this check when there is support for IIO and do it properly, seems to fail for some reason, see #788
//        if ( !initializePCIeBWCounters( iios, evt_ctx, nameMap ) )
//        {
//            std::cerr << "Error: IIO is NOT supported with this platform! Program aborted\n";
//            exit(EXIT_FAILURE);
//        }

        // Now that everything is set we can start the http(s) server
#if defined (USE_SSL)
        if ( useSSL ) {
            if ( port == 0 )
                port = DEFAULT_HTTPS_PORT;
            std::string displayAddr = listenAddress.empty() ? "localhost" : listenAddress;
            std::cerr << "Starting SSL enabled server on https://" << displayAddr << ":" << port << "/\n";
            startHTTPSServer( listenAddress, port, certificateFile, privateKeyFile, useIPv4 );
        } else
#endif
        {
            if ( port == 0 )
                port = DEFAULT_HTTP_PORT;
            std::string displayAddr = listenAddress.empty() ? "localhost" : listenAddress;
            std::cerr << "Starting plain HTTP server on http://" << displayAddr << ":" << port << "/\n";
            startHTTPServer( listenAddress, port, useIPv4 );
        }
        delete pcmInstance;
    } else if ( pid > 0 ) {
        /* Parent, just leave */
        DBG( 2, "Child pid: ", pid );
    } else {
        /* Error */
        DBG( 2, "Error forking. " );
        return 200;
    }
    return 0;
}

#endif // UNIT_TEST

```

`src/pcm-sensor-server.service.in`:

```in
[Unit]
Description=Intel Performance Counter Monitor (PCM) Sensor Service
Wants=network-online.target
After=network-online.target

[Service]
Type=simple
ExecStart=@@CMAKE_INSTALL_SBINDIR@@/pcm-sensor-server

[Install]
WantedBy=multi-user.target

```

`src/pcm-sensor.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
//
// monitor CPU conters for ksysguard
//
// contact: Thomas Willhalm, Patrick Ungerer, Roman Dementiev
//
// This program is not a tutorial on how to write nice interpreters
// but a proof of concept on using ksysguard with performance counters
//

/*!     \file pcm-sensor.cpp
        \brief Example of using CPU counters: implements a graphical plugin for KDE ksysguard
*/
#include <iostream>
#include <string>
#include <sstream>
#include "cpuasynchcounter.h"
#include "utils.h"

using namespace std;
using namespace pcm;

PCM_MAIN_NOTHROW;

int mainThrows(int /* argc */, char * /*argv*/ [])
{
    set_signal_handlers();

    AsynchronCounterState counters;

    cout << "CPU counter sensor " << PCM_VERSION << "\n";
    cout << "ksysguardd 1.2.0\n";
    cout << "ksysguardd> ";

    while (1)
    {
        string s;
        cin >> s;

        const auto xpi = counters.getXpi();

        // list counters
        if (s == "monitors") {
            for (uint32 i = 0; i < counters.getNumCores(); ++i) {
                for (uint32 a = 0; a < counters.getNumSockets(); ++a)
                    if (a == counters.getSocketId(i)) {
                        cout << "Socket" << a << "/CPU" << i << "/Frequency\tfloat\n";
                        cout << "Socket" << a << "/CPU" << i << "/IPC\tfloat\n";
                        cout << "Socket" << a << "/CPU" << i << "/L2CacheHitRatio\tfloat\n";
                        cout << "Socket" << a << "/CPU" << i << "/L3CacheHitRatio\tfloat\n";
                        cout << "Socket" << a << "/CPU" << i << "/L2CacheMisses\tinteger\n";
                        cout << "Socket" << a << "/CPU" << i << "/L3CacheMisses\tinteger\n";
                        cout << "Socket" << a << "/CPU" << i << "/L3Occupancy\tfloat\n";
                        cout << "Socket" << a << "/CPU" << i << "/LocalMemoryBandwidth\tfloat\n";
                        cout << "Socket" << a << "/CPU" << i << "/RemoteMemoryBandwidth\tfloat\n";
                        cout << "Socket" << a << "/CPU" << i << "/CoreC0StateResidency\tfloat\n";
                        cout << "Socket" << a << "/CPU" << i << "/CoreC3StateResidency\tfloat\n";
                        cout << "Socket" << a << "/CPU" << i << "/CoreC6StateResidency\tfloat\n";
                        cout << "Socket" << a << "/CPU" << i << "/CoreC7StateResidency\tfloat\n";
                        cout << "Socket" << a << "/CPU" << i << "/ThermalHeadroom\tinteger\n";
                    }
            }
            for (uint32 a = 0; a < counters.getNumSockets(); ++a) {
                cout << "Socket" << a << "/BytesReadFromMC\tfloat\n";
                cout << "Socket" << a << "/BytesWrittenToMC\tfloat\n";
                cout << "Socket" << a << "/BytesReadFromPMM\tfloat\n";
                cout << "Socket" << a << "/BytesWrittenToPMM\tfloat\n";
                cout << "Socket" << a << "/Frequency\tfloat\n";
                cout << "Socket" << a << "/IPC\tfloat\n";
                cout << "Socket" << a << "/L2CacheHitRatio\tfloat\n";
                cout << "Socket" << a << "/L3CacheHitRatio\tfloat\n";
                cout << "Socket" << a << "/L2CacheMisses\tinteger\n";
                cout << "Socket" << a << "/L3CacheMisses\tinteger\n";
                cout << "Socket" << a << "/L3Occupancy\tfloat\n";
                cout << "Socket" << a << "/LocalMemoryBandwidth\tfloat\n";
                cout << "Socket" << a << "/RemoteMemoryBandwidth\tfloat\n";
                cout << "Socket" << a << "/CoreC0StateResidency\tfloat\n";
                cout << "Socket" << a << "/CoreC3StateResidency\tfloat\n";
                cout << "Socket" << a << "/CoreC6StateResidency\tfloat\n";
                cout << "Socket" << a << "/CoreC7StateResidency\tfloat\n";
                cout << "Socket" << a << "/PackageC2StateResidency\tfloat\n";
                cout << "Socket" << a << "/PackageC3StateResidency\tfloat\n";
                cout << "Socket" << a << "/PackageC6StateResidency\tfloat\n";
                cout << "Socket" << a << "/PackageC7StateResidency\tfloat\n";
                cout << "Socket" << a << "/ThermalHeadroom\tinteger\n";
                cout << "Socket" << a << "/CPUEnergy\tfloat\n";
                cout << "Socket" << a << "/DRAMEnergy\tfloat\n";
            }
            for (uint32 a = 0; a < counters.getNumSockets(); ++a) {
                for (uint32 l = 0; l < counters.getQPILinksPerSocket(); ++l)
                    cout << "Socket" << a << "/BytesIncomingTo" << xpi << l << "\tfloat\n";
            }

            cout << xpi << "_Traffic\tfloat\n";
            cout << "Frequency\tfloat\n";
            cout << "IPC\tfloat\n";       //double check output
            cout << "L2CacheHitRatio\tfloat\n";
            cout << "L3CacheHitRatio\tfloat\n";
            cout << "L2CacheMisses\tinteger\n";
            cout << "L3CacheMisses\tinteger\n";
            cout << "CoreC0StateResidency\tfloat\n";
            cout << "CoreC3StateResidency\tfloat\n";
            cout << "CoreC6StateResidency\tfloat\n";
            cout << "CoreC7StateResidency\tfloat\n";
            cout << "PackageC2StateResidency\tfloat\n";
            cout << "PackageC3StateResidency\tfloat\n";
            cout << "PackageC6StateResidency\tfloat\n";
            cout << "PackageC7StateResidency\tfloat\n";
            cout << "CPUEnergy\tfloat\n";
            cout << "DRAMEnergy\tfloat\n";
        }

        // provide metadata

        for (uint32 i = 0; i < counters.getNumCores(); ++i) {
            for (uint32 a = 0; a < counters.getNumSockets(); ++a)
                if (a == counters.getSocketId(i)) {
                    {
                        stringstream c;
                        c << "Socket" << a << "/CPU" << i << "/Frequency?";
                        if (s == c.str()) {
                            cout << "FREQ. CPU" << i << "\t\t\tMHz\n";
                        }
                    }
                    {
                        stringstream c;
                        c << "Socket" << a << "/CPU" << i << "/ThermalHeadroom?";
                        if (s == c.str()) {
                            cout << "Temperature reading in 1 degree Celsius relative to the TjMax temperature (thermal headroom) for CPU" << i << "\t\t\t°C\n";
                        }
                    }
                    {
                        stringstream c;
                        c << "Socket" << a << "/CPU" << i << "/CoreC0StateResidency?";
                        if (s == c.str()) {
                            cout << "core C0-state residency for CPU" << i << "\t\t\t%\n";
                        }
                    }
                    {
                        stringstream c;
                        c << "Socket" << a << "/CPU" << i << "/CoreC3StateResidency?";
                        if (s == c.str()) {
                            cout << "core C3-state residency for CPU" << i << "\t\t\t%\n";
                        }
                    }
                    {
                        stringstream c;
                        c << "Socket" << a << "/CPU" << i << "/CoreC6StateResidency?";
                        if (s == c.str()) {
                            cout << "core C6-state residency for CPU" << i << "\t\t\t%\n";
                        }
                    }
                    {
                        stringstream c;
                        c << "Socket" << a << "/CPU" << i << "/CoreC7StateResidency?";
                        if (s == c.str()) {
                            cout << "core C7-state residency for CPU" << i << "\t\t\t%\n";
                        }
                    }
                }
        }
        for (uint32 i = 0; i < counters.getNumCores(); ++i) {
            for (uint32 a = 0; a < counters.getNumSockets(); ++a)
                if (a == counters.getSocketId(i)) {
                    stringstream c;
                    c << "Socket" << a << "/CPU" << i << "/IPC?";
                    if (s == c.str()) {
                        cout << "IPC CPU" << i << "\t0\t\t\n";
                        //cout << "CPU" << i << "\tInstructions per Cycle\t0\t1\t \n";
                    }
                }
        }
        for (uint32 i = 0; i < counters.getNumCores(); ++i) {
            for (uint32 a = 0; a < counters.getNumSockets(); ++a)
                if (a == counters.getSocketId(i)) {
                    stringstream c;
                    c << "Socket" << a << "/CPU" << i << "/L2CacheHitRatio?";
                    if (s == c.str()) {
                        cout << "L2 Cache Hit Ratio CPU" << i << "\t0\t\t\n";
                        //   cout << "CPU" << i << "\tL2 Cache Hit Ratio\t0\t1\t \n";
                    }
                }
        }
        for (uint32 i = 0; i < counters.getNumCores(); ++i) {
            for (uint32 a = 0; a < counters.getNumSockets(); ++a)
                if (a == counters.getSocketId(i)) {
                    stringstream c;
                    c << "Socket" << a << "/CPU" << i << "/L3CacheHitRatio?";
                    if (s == c.str()) {
                        cout << "L3 Cache Hit Ratio CPU" << i << "\t0\t\t \n";
                    }
                }
        }
        for (uint32 i = 0; i < counters.getNumCores(); ++i) {
            for (uint32 a = 0; a < counters.getNumSockets(); ++a)
                if (a == counters.getSocketId(i)) {
                    stringstream c;
                    c << "Socket" << a << "/CPU" << i << "/L2CacheMisses?";
                    if (s == c.str()) {
                        cout << "L2 Cache Misses CPU" << i << "\t0\t\t \n";
                        //cout << "CPU" << i << "\tL2 Cache Misses\t0\t1\t \n";
                    }
                }
        }
        for (uint32 i = 0; i < counters.getNumCores(); ++i) {
            for (uint32 a = 0; a < counters.getNumSockets(); ++a)
                if (a == counters.getSocketId(i)) {
                    stringstream c;
                    c << "Socket" << a << "/CPU" << i << "/L3CacheMisses?";
                    if (s == c.str()) {
                        cout << "L3 Cache Misses CPU" << i << "\t0\t\t \n";
                        //cout << "CPU" << i << "\tL3 Cache Misses\t0\t1\t \n";
                    }
                }
        }
        for (uint32 i = 0; i < counters.getNumCores(); ++i) {
            for (uint32 a = 0; a < counters.getNumSockets(); ++a)
                if (a == counters.getSocketId(i)) {
                    stringstream c;
                    c << "Socket" << a << "/CPU" << i << "/L3Occupancy?";
                    if (s == c.str()) {
                        cout << "L3 Cache Occupancy CPU " << i << "\t0\t\t \n";
                        //cout << "CPU" << i << "\tL3 Cache Occupancy\t0\t1\t \n";
                    }
                }
        }
        for (uint32 i = 0; i < counters.getNumCores(); ++i) {
            for (uint32 a = 0; a < counters.getNumSockets(); ++a)
                if (a == counters.getSocketId(i)) {
                    stringstream c;
                    c << "Socket" << a << "/CPU" << i << "/LocalMemoryBandwidth?";
                    if (s == c.str()) {
                        cout << "Local Memory Bandwidth CPU " << i << "\t0\t\t \n";
                        //cout << "CPU" << i << "\tLocal Memory Bandwidth\t0\t1\t \n";
                    }
                }
        }
        for (uint32 i = 0; i < counters.getNumCores(); ++i) {
            for (uint32 a = 0; a < counters.getNumSockets(); ++a)
                if (a == counters.getSocketId(i)) {
                    stringstream c;
                    c << "Socket" << a << "/CPU" << i << "/RemoteMemoryBandwidth?";
                    if (s == c.str()) {
                        cout << "Remote Memory Bandwidth CPU " << i << "\t0\t\t \n";
                        //cout << "CPU" << i << "\tRemote Memory Bandwidth\t0\t1\t \n";
                    }
                }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/BytesReadFromMC?";
            if (s == c.str()) {
                cout << "read from MC Socket" << i << "\t0\t\tGB\n";
            }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/BytesReadFromPMM?";
            if (s == c.str()) {
                cout << "read from PMM memory on Socket" << i << "\t0\t\tGB\n";
            }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/DRAMEnergy?";
            if (s == c.str()) {
                cout << "Energy consumed by DRAM on socket " << i << "\t0\t\tJoule\n";
            }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/CPUEnergy?";
            if (s == c.str()) {
                cout << "Energy consumed by CPU package " << i << "\t0\t\tJoule\n";
            }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/ThermalHeadroom?";
            if (s == c.str()) {
                cout << "Temperature reading in 1 degree Celsius relative to the TjMax temperature (thermal headroom) for CPU package " << i << "\t0\t\t°C\n";
            }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/CoreC0StateResidency?";
            if (s == c.str()) {
                cout << "core C0-state residency for CPU package " << i << "\t0\t\t%\n";
            }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/CoreC3StateResidency?";
            if (s == c.str()) {
                cout << "core C3-state residency for CPU package " << i << "\t0\t\t%\n";
            }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/CoreC6StateResidency?";
            if (s == c.str()) {
                cout << "core C6-state residency for CPU package " << i << "\t0\t\t%\n";
            }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/CoreC7StateResidency?";
            if (s == c.str()) {
                cout << "core C7-state residency for CPU package " << i << "\t0\t\t%\n";
            }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/PackageC2StateResidency?";
            if (s == c.str()) {
                cout << "package C2-state residency for CPU package " << i << "\t0\t\t%\n";
            }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/PackageC3StateResidency?";
            if (s == c.str()) {
                cout << "package C3-state residency for CPU package " << i << "\t0\t\t%\n";
            }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/PackageC6StateResidency?";
            if (s == c.str()) {
                cout << "package C6-state residency for CPU package " << i << "\t0\t\t%\n";
            }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/PackageC7StateResidency?";
            if (s == c.str()) {
                cout << "package C7-state residency for CPU package " << i << "\t0\t\t%\n";
            }
        }
        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/BytesWrittenToPMM?";
            if (s == c.str()) {
                cout << "written to PMM memory on Socket" << i << "\t0\t\tGB\n";
                //cout << "CPU" << i << "\tBytes written to memory channel\t0\t1\t GB\n";
            }
        }

        for (uint32 l = 0; l < counters.getQPILinksPerSocket(); ++l) {
            for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
                stringstream c;
                c << "Socket" << i << "/BytesIncomingTo" << xpi << l << "?";
                if (s == c.str()) {
                    //cout << "Socket" << i << "\tBytes incoming to QPI link\t" << l<< "\t\t GB\n";
                    cout << "incoming to Socket" << i << " " << xpi << " Link" << l << "\t0\t\tGB\n";
                }
            }
        }

        {
            stringstream c;
            c << xpi << "_Traffic?";
            if (s == c.str()) {
                cout << "Traffic on all " << xpi << " links\t0\t\tGB\n";
            }
        }

        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/Frequency?";
            if (s == c.str()) {
                cout << "Socket" << i << " Frequency\t0\t\tMHz\n";
            }
        }

        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/IPC?";
            if (s == c.str()) {
                cout << "Socket" << i << " IPC\t0\t\t\n";
            }
        }

        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/L2CacheHitRatio?";
            if (s == c.str()) {
                cout << "Socket" << i << " L2 Cache Hit Ratio\t0\t\t\n";
            }
        }

        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/L3CacheHitRatio?";
            if (s == c.str()) {
                cout << "Socket" << i << " L3 Cache Hit Ratio\t0\t\t\n";
            }
        }

        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/L2CacheMisses?";
            if (s == c.str()) {
                cout << "Socket" << i << " L2 Cache Misses\t0\t\t\n";
            }
        }

        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/L3CacheMisses?";
            if (s == c.str()) {
                cout << "Socket" << i << " L3 Cache Misses\t0\t\t\n";
            }
        }

        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/L3Occupancy";
            if (s == c.str()) {
                cout << "Socket" << i << " L3 Cache Occupancy\t0\t\t\n";
            }
        }

        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/LocalMemoryBandwidth";
            if (s == c.str()) {
                cout << "Socket" << i << " Local Memory Bandwidth\t0\t\t\n";
            }
        }

        for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
            stringstream c;
            c << "Socket" << i << "/RemoteMemoryBandwidth";
            if (s == c.str()) {
                cout << "Socket" << i << " Remote Memory Bandwidth\t0\t\t\n";
            }
        }

        {
            stringstream c;
            c << "Frequency?";
            if (s == c.str()) {
                cout << "Frequency system wide\t0\t\tMhz\n";
            }
        }

        {
            stringstream c;
            c << "IPC?";
            if (s == c.str()) {
                cout << "IPC system wide\t0\t\t\n";
            }
        }

        {
            stringstream c;
            c << "L2CacheHitRatio?";
            if (s == c.str()) {
                cout << "System wide L2 Cache Hit Ratio\t0\t\t\n";
            }
        }

        {
            stringstream c;
            c << "L3CacheHitRatio?";
            if (s == c.str()) {
                cout << "System wide L3 Cache Hit Ratio\t0\t\t\n";
            }
        }

        {
            stringstream c;
            c << "L2CacheMisses?";
            if (s == c.str()) {
                cout << "System wide L2 Cache Misses\t0\t\t\n";
            }
        }

        {
            stringstream c;
            c << "L3CacheMisses?";
            if (s == c.str()) {
                cout << "System wide L3 Cache Misses\t0\t\t\n";
            }
        }

        {
            stringstream c;
            c << "L3CacheMisses?";
            if (s == c.str()) {
                cout << "System wide L3 Cache Misses\t0\t\t\n";
            }
        }

        {
            stringstream c;
            c << "DRAMEnergy?";
            if (s == c.str()) {
                cout << "System wide energy consumed by DRAM \t0\t\tJoule\n";
            }
        }
        {
            stringstream c;
            c << "CPUEnergy?";
            if (s == c.str()) {
                cout << "System wide energy consumed by CPU packages \t0\t\tJoule\n";
            }
        }
        {
            stringstream c;
            c << "CoreC0StateResidency?";
            if (s == c.str()) {
                cout << "System wide core C0-state residency \t0\t\t%\n";
            }
        }
        {
            stringstream c;
            c << "CoreC3StateResidency?";
            if (s == c.str()) {
                cout << "System wide core C3-state residency \t0\t\t%\n";
            }
        }
        {
            stringstream c;
            c << "CoreC6StateResidency?";
            if (s == c.str()) {
                cout << "System wide core C6-state residency \t0\t\t%\n";
            }
        }
        {
            stringstream c;
            c << "CoreC7StateResidency?";
            if (s == c.str()) {
                cout << "System wide core C7-state residency \t0\t\t%\n";
            }
        }
        {
            stringstream c;
            c << "PackageC2StateResidency?";
            if (s == c.str()) {
                cout << "System wide package C2-state residency \t0\t\t%\n";
            }
        }
        {
            stringstream c;
            c << "PackageC3StateResidency?";
            if (s == c.str()) {
                cout << "System wide package C3-state residency \t0\t\t%\n";
            }
        }
        {
            stringstream c;
            c << "PackageC6StateResidency?";
            if (s == c.str()) {
                cout << "System wide package C6-state residency \t0\t\t%\n";
            }
        }
        {
            stringstream c;
            c << "PackageC7StateResidency?";
            if (s == c.str()) {
                cout << "System wide package C7-state residency \t0\t\t%\n";
            }
        }

        // sensors

#define OUTPUT_CORE_METRIC(name, function) \
    for (uint32 i = 0; i<counters.getNumCores(); ++i) { \
                             for (uint32 a = 0; a<counters.getNumSockets(); ++a) \
                                                  if (a == counters.getSocketId(i)) { \
                                                      stringstream c; \
                                                      c << "Socket" << a << "/CPU" << i << name; \
                                                      if (s == c.str()) { \
                                                          cout << function << "\n"; \
                                                      } \
                                                  } \
                                                  }

        OUTPUT_CORE_METRIC("/Frequency", (counters.get<double, ::getAverageFrequency>(i) / 1000000))
        OUTPUT_CORE_METRIC("/IPC", (counters.get<double, ::getIPC>(i)))
        OUTPUT_CORE_METRIC("/L2CacheHitRatio", (counters.get<double, ::getL2CacheHitRatio>(i)))
        OUTPUT_CORE_METRIC("/L3CacheHitRatio", (counters.get<double, ::getL3CacheHitRatio>(i)))
        OUTPUT_CORE_METRIC("/L2CacheMisses", (counters.get<uint64, ::getL2CacheMisses>(i)))
        OUTPUT_CORE_METRIC("/L3CacheMisses", (counters.get<uint64, ::getL3CacheMisses>(i)))
        OUTPUT_CORE_METRIC("/L3Occupancy", (counters.get<uint64, ::getL3CacheOccupancy>(i)))
        OUTPUT_CORE_METRIC("/LocalMemoryBandwidth", (counters.get<uint64, ::getLocalMemoryBW>(i)))
        OUTPUT_CORE_METRIC("/RemoteMemoryBandwidth", (counters.get<uint64, ::getRemoteMemoryBW>(i)))
        OUTPUT_CORE_METRIC("/CoreC0StateResidency", (counters.get<double, ::getCoreCStateResidency>(0, i) * 100.))
        OUTPUT_CORE_METRIC("/CoreC3StateResidency", (counters.get<double, ::getCoreCStateResidency>(3, i) * 100.))
        OUTPUT_CORE_METRIC("/CoreC6StateResidency", (counters.get<double, ::getCoreCStateResidency>(6, i) * 100.))
        OUTPUT_CORE_METRIC("/CoreC7StateResidency", (counters.get<double, ::getCoreCStateResidency>(7, i) * 100.))
        OUTPUT_CORE_METRIC("/ThermalHeadroom", (counters.get<int32, ::getThermalHeadroom>(i)))

        #define OUTPUT_SOCKET_METRIC(name, function) \
    for (uint32 i = 0; i<counters.getNumSockets(); ++i) { \
                             stringstream c; \
                             c << "Socket" << i << name; \
                             if (s == c.str()) { \
                                 cout << function << "\n"; \
                             } \
                         }

        OUTPUT_SOCKET_METRIC("/DRAMEnergy", (counters.getSocket<double, ::getDRAMConsumedJoules>(i)))
        OUTPUT_SOCKET_METRIC("/CPUEnergy", (counters.getSocket<double, ::getConsumedJoules>(i)))
        OUTPUT_SOCKET_METRIC("/CoreC0StateResidency", (counters.getSocket<double, ::getCoreCStateResidency>(0, i) * 100.))
        OUTPUT_SOCKET_METRIC("/CoreC3StateResidency", (counters.getSocket<double, ::getCoreCStateResidency>(3, i) * 100.))
        OUTPUT_SOCKET_METRIC("/CoreC6StateResidency", (counters.getSocket<double, ::getCoreCStateResidency>(6, i) * 100.))
        OUTPUT_SOCKET_METRIC("/CoreC7StateResidency", (counters.getSocket<double, ::getCoreCStateResidency>(7, i) * 100.))
        OUTPUT_SOCKET_METRIC("/PackageC2StateResidency", (counters.getSocket<double, ::getPackageCStateResidency>(2, i) * 100.))
        OUTPUT_SOCKET_METRIC("/PackageC3StateResidency", (counters.getSocket<double, ::getPackageCStateResidency>(3, i) * 100.))
        OUTPUT_SOCKET_METRIC("/PackageC6StateResidency", (counters.getSocket<double, ::getPackageCStateResidency>(6, i) * 100.))
        OUTPUT_SOCKET_METRIC("/PackageC7StateResidency", (counters.getSocket<double, ::getPackageCStateResidency>(7, i) * 100.))
        OUTPUT_SOCKET_METRIC("/ThermalHeadroom", (counters.getSocket<int32, ::getThermalHeadroom>(i)))
        OUTPUT_SOCKET_METRIC("/BytesReadFromMC", (double(counters.getSocket<uint64, ::getBytesReadFromMC>(i)) / 1024 / 1024 / 1024))
        OUTPUT_SOCKET_METRIC("/BytesWrittenToMC", (double(counters.getSocket<uint64, ::getBytesWrittenToMC>(i)) / 1024 / 1024 / 1024))
        OUTPUT_SOCKET_METRIC("/BytesReadFromPMM", (double(counters.getSocket<uint64, ::getBytesReadFromPMM>(i)) / 1024 / 1024 / 1024))
        OUTPUT_SOCKET_METRIC("/BytesWrittenToPMM", (double(counters.getSocket<uint64, ::getBytesWrittenToPMM>(i)) / 1024 / 1024 / 1024))
        OUTPUT_SOCKET_METRIC("/Frequency", (counters.getSocket<double, ::getAverageFrequency>(i) / 1000000))
        OUTPUT_SOCKET_METRIC("/IPC", (counters.getSocket<double, ::getIPC>(i)))
        OUTPUT_SOCKET_METRIC("/L2CacheHitRatio", (counters.getSocket<double, ::getL2CacheHitRatio>(i)))
        OUTPUT_SOCKET_METRIC("/L3CacheHitRatio", (counters.getSocket<double, ::getL3CacheHitRatio>(i)))
        OUTPUT_SOCKET_METRIC("/L2CacheMisses", (counters.getSocket<uint64, ::getL2CacheMisses>(i)))
        OUTPUT_SOCKET_METRIC("/L3CacheMisses", (counters.getSocket<uint64, ::getL3CacheMisses>(i)))
        OUTPUT_SOCKET_METRIC("/L3Occupancy", (counters.getSocket<uint64, ::getL3CacheOccupancy>(i)))
        OUTPUT_SOCKET_METRIC("/LocalMemoryBandwidth", (counters.getSocket<uint64, ::getLocalMemoryBW>(i)))
        OUTPUT_SOCKET_METRIC("/RemoteMemoryBandwidth", (counters.getSocket<uint64, ::getRemoteMemoryBW>(i)))

        for (uint32 l = 0; l < counters.getQPILinksPerSocket(); ++l) {
            for (uint32 i = 0; i < counters.getNumSockets(); ++i) {
                stringstream c;
                c << "Socket" << i << "/BytesIncomingTo" << xpi << l;
                if (s == c.str()) {
                    cout << double(counters.getSocket<uint64, ::getIncomingQPILinkBytes>(i, l)) / 1024 / 1024 / 1024 << "\n";
                }
            }
        }

    #define OUTPUT_SYSTEM_METRIC(name, function) \
    { \
        stringstream c; \
        c << name; \
        if (s == c.str()) { \
            cout << function << "\n"; \
        } \
    }

        OUTPUT_SYSTEM_METRIC("DRAMEnergy", (counters.getSystem<double, ::getDRAMConsumedJoules>()))
        OUTPUT_SYSTEM_METRIC("CPUEnergy", (counters.getSystem<double, ::getConsumedJoules>()))
        OUTPUT_SYSTEM_METRIC("CoreC0StateResidency", (counters.getSystem<double, ::getCoreCStateResidency>(0) * 100.))
        OUTPUT_SYSTEM_METRIC("CoreC3StateResidency", (counters.getSystem<double, ::getCoreCStateResidency>(3) * 100.))
        OUTPUT_SYSTEM_METRIC("CoreC6StateResidency", (counters.getSystem<double, ::getCoreCStateResidency>(6) * 100.))
        OUTPUT_SYSTEM_METRIC("CoreC7StateResidency", (counters.getSystem<double, ::getCoreCStateResidency>(7) * 100.))
        OUTPUT_SYSTEM_METRIC("PackageC2StateResidency", (counters.getSystem<double, ::getPackageCStateResidency>(2) * 100.))
        OUTPUT_SYSTEM_METRIC("PackageC3StateResidency", (counters.getSystem<double, ::getPackageCStateResidency>(3) * 100.))
        OUTPUT_SYSTEM_METRIC("PackageC6StateResidency", (counters.getSystem<double, ::getPackageCStateResidency>(6) * 100.))
        OUTPUT_SYSTEM_METRIC("PackageC7StateResidency", (counters.getSystem<double, ::getPackageCStateResidency>(7) * 100.))
        OUTPUT_SYSTEM_METRIC("Frequency", (double(counters.getSystem<double, ::getAverageFrequency>()) / 1000000))
        OUTPUT_SYSTEM_METRIC("IPC", (double(counters.getSystem<double, ::getIPC>())))
        OUTPUT_SYSTEM_METRIC("L2CacheHitRatio", (double(counters.getSystem<double, ::getL2CacheHitRatio>())))
        OUTPUT_SYSTEM_METRIC("L3CacheHitRatio", (double(counters.getSystem<double, ::getL3CacheHitRatio>())))
        OUTPUT_SYSTEM_METRIC("L2CacheMisses", (double(counters.getSystem<uint64, ::getL2CacheMisses>())))
        OUTPUT_SYSTEM_METRIC("L3CacheMisses", (double(counters.getSystem<uint64, ::getL3CacheMisses>())))
        OUTPUT_SYSTEM_METRIC(std::string(xpi + std::string("_Traffic")),
            (double(counters.getSystem<uint64, ::getAllIncomingQPILinkBytes>()) / 1024 / 1024 / 1024))

        // exit
        if (s == "quit" || s == "exit" || s == "") {
            break;
        }


        cout << "ksysguardd> ";
    }

    return 0;
}

```

`src/pcm-tpmi.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2023 Intel Corporation

// written by Roman Dementiev
#include "cpucounters.h"
#ifdef _MSC_VER
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#endif
#include <iostream>
#include <stdlib.h>
#include <iomanip>
#include <string.h>
#ifdef _MSC_VER
#include "freegetopt/getopt.h"
#endif

using namespace pcm;

void print_usage(const char * progname)
{
    std::cout << "Usage " << progname << " [-w value] [-d] [-b low:high] [-e entries] ID offset\n\n";
    std::cout << "  Reads/writes TPMI (Topology Aware Register and PM Capsule Interface) register \n";
    std::cout << "   ID          : TPMI ID\n";
    std::cout << "   offset      : register offset\n";
    std::cout << "   -w value    : write the value before reading \n";
    std::cout << "   -b low:high : read or write only low..high bits of the register\n";
    std::cout << "   -e entries  : perform read/write on specified entries (default is all entries)\n";
    std::cout << "                 (examples: -e 10 -e 10-11 -e 4,6,12-20,6)\n";
    std::cout << "   -i instances: perform read/write on specified instances (default is all instances)\n";
    std::cout << "                 (examples: -i 1 -i 0,1 -i 0,2-3)\n";
    std::cout << "   -d          : output all numbers in dec (default is hex)\n";
    std::cout << "   -v          : verbose ouput\n";
    std::cout << "   --version   : print application version\n";
    std::cout << "\n";
}

PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
    if(print_version(argc, argv))
        return 0;

    std::cout << "\n Intel(r) Performance Counter Monitor " << PCM_VERSION << "\n";

    std::cout << "\n TPMI (Topology Aware Register and PM Capsule Interface) read/write utility\n\n";
    // register documentation: https://github.com/intel/tpmi_power_management

    uint64 value = 0;
    bool write = false;
    bool dec = false;
    std::pair<int64,int64> bits{-1, -1};
    std::list<int> entries, instances;

    int my_opt = -1;
    while ((my_opt = getopt(argc, argv, "w:dvb:e:i:")) != -1)
    {
        switch (my_opt)
        {
        case 'w':
            write = true;
            value = read_number(optarg);
            break;
        case 'd':
            dec = true;
            break;
        case 'v':
            TPMIHandle::setVerbose(true);
            break;
        case 'b':
            bits = parseBitsParameter(optarg);
            break;
        case 'e':
            entries = extract_integer_list(optarg);
            break;
        case 'i':
            instances = extract_integer_list(optarg);
            break;
        default:
            print_usage(argv[0]);
            return -1;
        }
    }

    if (optind + 1 >= argc)
    {
        print_usage(argv[0]);
        return -1;
    }

    uint64 requestedID = (uint64)read_number(argv[optind]);
    uint64 requestedRelativeOffset = (uint64)read_number(argv[optind + 1]);

    #ifdef _MSC_VER
    // Increase the priority a bit to improve context switching delays on Windows
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

    // WARNING: This driver code (msr.sys) is only for testing purposes, not for production use
    Driver drv = Driver(Driver::msrLocalPath());
    // drv.stop();     // restart driver (usually not needed)
    if (!drv.start())
    {
        tcerr << "Can not load MSR driver.\n";
        tcerr << "You must have a signed  driver at " << drv.driverPath() << " and have administrator rights to run this program\n";
        return -1;
    }
    #endif

    try
    {
        PCM::setQuietMode(true);
        auto pcmInstance = PCM::getInstance();
        
        if (instances.empty())
        {
            for (size_t i = 0; i < TPMIHandle::getNumInstances(); ++i)
            {
                instances.push_back(i);
            }
        }
        for (const size_t i : instances)
        {
            if (i >= TPMIHandle::getNumInstances())
            {
                std::cerr << "Instance " << i << " does not exist\n";
                continue;
            }
            TPMIHandle h(i, requestedID, requestedRelativeOffset, !write);
            
            // Get NUMA node and socket ID
            int32 numaNode = h.getNUMANode();
            int32 socketId = -1;
            if (numaNode >= 0)
            {
                socketId = pcmInstance->mapNUMANodeToSocket(static_cast<uint32>(numaNode));
            }
            
            // Helper lambda to print socket ID and NUMA node information
            auto printTopologyInfo = [&socketId, &numaNode]() {
                if (socketId >= 0 || numaNode >= 0)
                {
                    // Save stream format state
                    auto flags = std::cout.flags();
                    
                    if (socketId >= 0)
                        std::cout << " (socket " << std::dec << socketId << ")";
                    if (numaNode >= 0)
                        std::cout << " (NUMA node " << std::dec << numaNode << ")";
                    
                    // Restore stream format state
                    std::cout.flags(flags);
                }
            };
            
            auto one = [&](const size_t p, uint64 value)
            {
                if (!dec)
                    std::cout << std::hex << std::showbase;
                readOldValueHelper(bits, value, write, [&h, &p](uint64& old_value)
                { old_value = h.read64(p); return true; });
                if (write)
                {
                    std::cout << " Writing " << value << " to TPMI ID " << requestedID << "@" << requestedRelativeOffset << " for entry " << p << " in instance " << i;
                    printTopologyInfo();
                    std::cout << "\n";
                    h.write64(p, value);
                }
                value = h.read64(p);
                extractBitsPrintHelper(bits, value, dec);
                std::cout << " from TPMI ID " << requestedID << "@" << requestedRelativeOffset << " for entry " << p << " in instance " << i;
                printTopologyInfo();
                std::cout << "\n\n";
            };
            if (entries.empty())
            {
                for (size_t p = 0; p < h.getNumEntries(); ++p)
                {
                    entries.push_back(p);
                }
            }
            for (const size_t p : entries)
            {
                if (p < h.getNumEntries())
                {
                    one(p, value);
                }
            }
        }
    }
    catch (std::exception &e)
    {
        std::cerr << "Error accessing registers: " << e.what() << "\n";
        std::cerr << "Please check if the program can access MSR/PCICFG drivers.\n";
    }

    return 0;
}

```

`src/pcm-tsx.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev


/*!     \file pcm-tsx.cpp
  \brief Example of using CPU counters: implements a performance counter monitoring utility for Intel Transactional Synchronization Extensions
  */
#include <iostream>
#ifdef _MSC_VER
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#include <signal.h>
#include <sys/time.h> // for gettimeofday()
#endif
#include <math.h>
#include <iomanip>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <string>
#include <assert.h>
#include "cpucounters.h"
#include "utils.h"
#ifdef _MSC_VER
#include "freegetopt/getopt.h"
#endif

#include <vector>
#define PCM_DELAY_DEFAULT 1.0       // in seconds
#define PCM_DELAY_MIN 0.015         // 15 milliseconds is practical on most modern CPUs

using namespace std;
using namespace pcm;

struct TSXEvent
{
    const char * name;
    unsigned char event;
    unsigned char umask;
    const char * description;
};

vector<TSXEvent> eventDefinition = {
    { "RTM_RETIRED.START", 0xC9, 0x01, "Number of times an RTM execution started." },
    { "RTM_RETIRED.COMMIT", 0xC9, 0x02, "Number of times an RTM execution successfully committed" },
    { "RTM_RETIRED.ABORTED", 0xC9, 0x04, "Number of times an RTM execution aborted due to any reasons (multiple categories may count as one)" },
    { "RTM_RETIRED.ABORTED_MEM", 0xC9, 0x08, "Number of times an RTM execution aborted due to various memory events" },
    { "RTM_RETIRED.ABORTED_TIMER", 0xC9, 0x10, "Number of times an RTM execution aborted due to uncommon conditions" },
    { "RTM_RETIRED.ABORTED_UNFRIENDLY", 0xC9, 0x20, "Number of times an RTM execution aborted due to Intel TSX-unfriendly instructions" },
    { "RTM_RETIRED.ABORTED_MEMTYPE", 0xC9, 0x40, "Number of times an RTM execution aborted due to incompatible memory type" },
    { "RTM_RETIRED.ABORTED_EVENTS", 0xC9, 0x80, "Number of times an RTM execution aborted due to none of the previous 4 categories (e.g. interrupt)" },

    { "HLE_RETIRED.START", 0xC8, 0x01, "Number of times an HLE execution started." },
    { "HLE_RETIRED.COMMIT", 0xC8, 0x02, "Number of times an HLE execution successfully committed" },
    { "HLE_RETIRED.ABORTED", 0xC8, 0x04, "Number of times an HLE execution aborted due to any reasons (multiple categories may count as one)" },
    { "HLE_RETIRED.ABORTED_MEM", 0xC8, 0x08, "Number of times an HLE execution aborted due to various memory events" },
    { "HLE_RETIRED.ABORTED_TIMER", 0xC8, 0x10, "Number of times an HLE execution aborted due to uncommon conditions" },
    { "HLE_RETIRED.ABORTED_UNFRIENDLY", 0xC8, 0x20, "Number of times an HLE execution aborted due to Intel TSX-unfriendly instructions" },
    { "HLE_RETIRED.ABORTED_MEMTYPE", 0xC8, 0x40, "Number of times an HLE execution aborted due to incompatible memory type" },
    { "HLE_RETIRED.ABORTED_EVENTS", 0xC8, 0x80, "Number of times an HLE execution aborted due to none of the previous 4 categories (e.g. interrupt)" },

    { "TX_MEM.ABORT_CONFLICT", 0x54, 0x01, "Number of times a transactional abort was signaled due to a data conflict on a transactionally accessed address" },
    { "TX_MEM.ABORT_CAPACITY_WRITE", 0x54, 0x02, "Number of times a transactional abort was signaled due to limited resources for transactional stores" },
    { "TX_MEM.ABORT_HLE_STORE_TO_ELIDED_LOCK", 0x54, 0x04, "Number of times a HLE transactional region aborted due to a non XRELEASE prefixed instruction writing to an elided lock in the elision buffer" },
    { "TX_MEM.ABORT_HLE_ELISION_BUFFER_NOT_EMPTY", 0x54, 0x08, "Number of times an HLE transactional execution aborted due to NoAllocatedElisionBuffer being nonzero." },
    { "TX_MEM.ABORT_HLE_ELISION_BUFFER_MISMATCH", 0x54, 0x10, "Number of times an HLE transactional execution aborted due to XRELEASE lock not satisfying the address and value requirements in the elision buffer." },
    { "TX_MEM.ABORT_HLE_ELISION_BUFFER_UNSUPPORTED_ALIGNMENT", 0x54, 0x20, "Number of times an HLE transactional execution aborted due to an unsupported read alignment from the elision buffer." },
    { "TX_MEM.HLE_ELISION_BUFFER_FULL", 0x54, 0x40, "Number of times HLE lock could not be elided due to ElisionBufferAvailable being zero." },

    { "TX_EXEC.MISC1", 0x5D, 0x01, "Counts the number of times a class of instructions that may cause a transactional abort was executed. Since this is the count of execution, it may not always cause a transactional abort." },
    { "TX_EXEC.MISC2", 0x5D, 0x02, "Counts the number of times a class of instructions that may cause a transactional abort was executed inside a transactional region" },
    { "TX_EXEC.MISC3", 0x5D, 0x04, "Counts the number of times an instruction execution caused the nest count supported to be exceeded" },
    { "TX_EXEC.MISC4", 0x5D, 0x08, "Counts the number of times a XBEGIN instruction was executed inside an HLE transactional region" },
    { "TX_EXEC.MISC5", 0x5D, 0x10, "Counts the number of times an HLE XACQUIRE instruction was executed inside an RTM transactional region" }
};

const vector<TSXEvent> sklEventDefinition = {
    { "RTM_RETIRED.START", 0xC9, 0x01, "Number of times an RTM execution started." },
    { "RTM_RETIRED.COMMIT", 0xC9, 0x02, "Number of times an RTM execution successfully committed" },
    { "RTM_RETIRED.ABORTED", 0xC9, 0x04, "Number of times an RTM execution aborted due to any reasons (multiple categories may count as one)" },
    { "RTM_RETIRED.ABORTED_MEM", 0xC9, 0x08, "Number of times an RTM execution aborted due to various memory events" },
    { "RTM_RETIRED.ABORTED_TIMER", 0xC9, 0x10, "Number of times an RTM execution aborted due to uncommon conditions" },
    { "RTM_RETIRED.ABORTED_UNFRIENDLY", 0xC9, 0x20, "Number of times an RTM execution aborted due to Intel TSX-unfriendly instructions" },
    { "RTM_RETIRED.ABORTED_MEMTYPE", 0xC9, 0x40, "Number of times an RTM execution aborted due to incompatible memory type" },
    { "RTM_RETIRED.ABORTED_EVENTS", 0xC9, 0x80, "Number of times an RTM execution aborted due to none of the previous 4 categories (e.g. interrupt)" },

    { "HLE_RETIRED.START", 0xC8, 0x01, "Number of times an HLE execution started." },
    { "HLE_RETIRED.COMMIT", 0xC8, 0x02, "Number of times an HLE execution successfully committed" },
    { "HLE_RETIRED.ABORTED", 0xC8, 0x04, "Number of times an HLE execution aborted due to any reasons (multiple categories may count as one)" },
    { "HLE_RETIRED.ABORTED_MEM", 0xC8, 0x08, "Number of times an HLE execution aborted due to various memory events" },
    { "HLE_RETIRED.ABORTED_TIMER", 0xC8, 0x10, "Number of times an HLE execution aborted due to uncommon conditions" },
    { "HLE_RETIRED.ABORTED_UNFRIENDLY", 0xC8, 0x20, "Number of times an HLE execution aborted due to Intel TSX-unfriendly instructions" },
    { "HLE_RETIRED.ABORTED_MEMTYPE", 0xC8, 0x40, "Number of times an HLE execution aborted due to incompatible memory type" },
    { "HLE_RETIRED.ABORTED_EVENTS", 0xC8, 0x80, "Number of times an HLE execution aborted due to none of the previous 4 categories (e.g. interrupt)" },

    { "TX_MEM.ABORT_CONFLICT", 0x54, 0x01, "Number of times a transactional abort was signaled due to a data conflict on a transactionally accessed address" },
    { "TX_MEM.ABORT_CAPACITY", 0x54, 0x02, "Number of times a transactional abort was signaled due to a data capacity limitation for transactional reads or writes" },
    { "TX_MEM.ABORT_HLE_STORE_TO_ELIDED_LOCK", 0x54, 0x04, "Number of times a HLE transactional region aborted due to a non XRELEASE prefixed instruction writing to an elided lock in the elision buffer" },
    { "TX_MEM.ABORT_HLE_ELISION_BUFFER_NOT_EMPTY", 0x54, 0x08, "Number of times an HLE transactional execution aborted due to NoAllocatedElisionBuffer being nonzero." },
    { "TX_MEM.ABORT_HLE_ELISION_BUFFER_MISMATCH", 0x54, 0x10, "Number of times an HLE transactional execution aborted due to XRELEASE lock not satisfying the address and value requirements in the elision buffer." },
    { "TX_MEM.ABORT_HLE_ELISION_BUFFER_UNSUPPORTED_ALIGNMENT", 0x54, 0x20, "Number of times an HLE transactional execution aborted due to an unsupported read alignment from the elision buffer." },
    { "TX_MEM.HLE_ELISION_BUFFER_FULL", 0x54, 0x40, "Number of times HLE lock could not be elided due to ElisionBufferAvailable being zero." },

    { "TX_EXEC.MISC1", 0x5D, 0x01, "Counts the number of times a class of instructions that may cause a transactional abort was executed. Since this is the count of execution, it may not always cause a transactional abort." },
    { "TX_EXEC.MISC2", 0x5D, 0x02, "Counts the number of times a class of instructions (e.g., vzeroupper) that may cause a transactional abort was executed inside a transactional region" },
    { "TX_EXEC.MISC3", 0x5D, 0x04, "Counts the number of times an instruction execution caused the nest count supported to be exceeded" },
    { "TX_EXEC.MISC4", 0x5D, 0x08, "Counts the number of times a XBEGIN instruction was executed inside an HLE transactional region" },
    { "TX_EXEC.MISC5", 0x5D, 0x10, "Counts the number of times an HLE XACQUIRE instruction was executed inside an RTM transactional region" }
};

const vector<TSXEvent> iclEventDefinition = {
    { "RTM_RETIRED.START", 0xC9, 0x01, "Number of times an RTM execution started." },
    { "RTM_RETIRED.COMMIT", 0xC9, 0x02, "Number of times an RTM execution successfully committed" },
    { "RTM_RETIRED.ABORTED", 0xC9, 0x04, "Number of times an RTM execution aborted due to any reasons (multiple categories may count as one)" },
    { "RTM_RETIRED.ABORTED_MEM", 0xC9, 0x08, "Number of times an RTM execution aborted due to various memory events" },
    { "RTM_RETIRED.ABORTED_TIMER", 0xC9, 0x10, "Number of times an RTM execution aborted due to uncommon conditions" },
    { "RTM_RETIRED.ABORTED_UNFRIENDLY", 0xC9, 0x20, "Number of times an RTM execution aborted due to Intel TSX-unfriendly instructions" },
    { "RTM_RETIRED.ABORTED_MEMTYPE", 0xC9, 0x40, "Number of times an RTM execution aborted due to incompatible memory type" },
    { "RTM_RETIRED.ABORTED_EVENTS", 0xC9, 0x80, "Number of times an RTM execution aborted due to none of the previous 4 categories (e.g. interrupt)" },

    { "HLE_RETIRED.START", 0xC8, 0x01, "Number of times an HLE execution started." },
    { "HLE_RETIRED.COMMIT", 0xC8, 0x02, "Number of times an HLE execution successfully committed" },
    { "HLE_RETIRED.ABORTED", 0xC8, 0x04, "Number of times an HLE execution aborted due to any reasons (multiple categories may count as one)" },
    { "HLE_RETIRED.ABORTED_MEM", 0xC8, 0x08, "Number of times an HLE execution aborted due to various memory events" },
    { "HLE_RETIRED.ABORTED_TIMER", 0xC8, 0x10, "Number of times an HLE execution aborted due to uncommon conditions" },
    { "HLE_RETIRED.ABORTED_UNFRIENDLY", 0xC8, 0x20, "Number of times an HLE execution aborted due to Intel TSX-unfriendly instructions" },
    { "HLE_RETIRED.ABORTED_MEMTYPE", 0xC8, 0x40, "Number of times an HLE execution aborted due to incompatible memory type" },
    { "HLE_RETIRED.ABORTED_EVENTS", 0xC8, 0x80, "Number of times an HLE execution aborted due to none of the previous 4 categories (e.g. interrupt)" },

    { "TX_MEM.ABORT_CONFLICT", 0x54, 0x01, "Number of times a transactional abort was signaled due to a data conflict on a transactionally accessed address" },
    { "TX_MEM.ABORT_CAPACITY_WRITE", 0x54, 0x02, "Speculatively counts the number of TSX aborts due to a data capacity limitation for transactional writes" },
    { "TX_MEM.ABORT_CAPACITY_READ", 0x54, 0x80, "Speculatively counts the number of TSX aborts due to a data capacity limitation for transactional reads" },
    { "TX_MEM.ABORT_HLE_STORE_TO_ELIDED_LOCK", 0x54, 0x04, "Number of times a HLE transactional region aborted due to a non XRELEASE prefixed instruction writing to an elided lock in the elision buffer" },
    { "TX_MEM.ABORT_HLE_ELISION_BUFFER_NOT_EMPTY", 0x54, 0x08, "Number of times an HLE transactional execution aborted due to NoAllocatedElisionBuffer being nonzero." },
    { "TX_MEM.ABORT_HLE_ELISION_BUFFER_MISMATCH", 0x54, 0x10, "Number of times an HLE transactional execution aborted due to XRELEASE lock not satisfying the address and value requirements in the elision buffer." },
    { "TX_MEM.ABORT_HLE_ELISION_BUFFER_UNSUPPORTED_ALIGNMENT", 0x54, 0x20, "Number of times an HLE transactional execution aborted due to an unsupported read alignment from the elision buffer." },
    { "TX_MEM.HLE_ELISION_BUFFER_FULL", 0x54, 0x40, "Number of times HLE lock could not be elided due to ElisionBufferAvailable being zero." },

    { "TX_EXEC.MISC2", 0x5D, 0x02, "Counts the number of times a class of instructions (e.g., vzeroupper) that may cause a transactional abort was executed inside a transactional region" },
    { "TX_EXEC.MISC3", 0x5D, 0x04, "Counts the number of times an instruction execution caused the nest count supported to be exceeded" }
};

const vector<TSXEvent> sprEventDefinition = {
    { "RTM_RETIRED.START", 0xC9, 0x01, "Number of times an RTM execution started." },
    { "RTM_RETIRED.COMMIT", 0xC9, 0x02, "Number of times an RTM execution successfully committed" },
    { "RTM_RETIRED.ABORTED", 0xC9, 0x04, "Number of times an RTM execution aborted." },
    { "RTM_RETIRED.ABORTED_MEM", 0xC9, 0x08, "Number of times an RTM execution aborted due to various memory events (e.g. read/write capacity and conflicts)" },
    { "RTM_RETIRED.ABORTED_UNFRIENDLY", 0xC9, 0x20, "Number of times an RTM execution aborted due to HLE-unfriendly instructions" },
    { "RTM_RETIRED.ABORTED_MEMTYPE", 0xC9, 0x40, "Number of times an RTM execution aborted due to incompatible memory type" },
    { "RTM_RETIRED.ABORTED_EVENTS", 0xC9, 0x80, "Number of times an RTM execution aborted due to none of the previous 4 categories (e.g. interrupt)" },

    { "TX_MEM.ABORT_CONFLICT", 0x54, 0x01, "Number of times a transactional abort was signaled due to a data conflict on a transactionally accessed address" },
    { "TX_MEM.ABORT_CAPACITY_WRITE", 0x54, 0x02, "Speculatively counts the number of TSX aborts due to a data capacity limitation for transactional writes." },
    { "TX_MEM.ABORT_CAPACITY_READ", 0x54, 0x80, "Speculatively counts the number of TSX aborts due to a data capacity limitation for transactional reads" }
};

void print_usage(const string & progname)
{
    cout << "\n Usage: \n " << progname
         << " --help | [delay] [options] [-- external_program [external_program_options]]\n";
    cout << "   <delay>                           => time interval to sample performance counters.\n";
    cout << "                                        If not specified, or 0, with external program given\n";
    cout << "                                        will read counters only after external program finishes\n";
    cout << " Supported <options> are: \n";
    cout << "  -h    | --help  | /h               => print this help and exit\n";
    cout << "  -silent                            => silence information output and print only measurements\n";
    cout << "  --version                          => print application version\n";
    cout << "  -F    | -force                     => force running this program despite lack of HW RTM support (optional)\n";
    cout << "  -pid PID | /pid PID                => collect core metrics only for specified process ID\n";
    cout << "  -csv[=file.csv] | /csv[=file.csv]  => output compact CSV format to screen or\n"
         << "                                        to a file, in case filename is provided\n";
    cout << "  -i[=number] | /i[=number]          => allow to determine number of iterations\n";
    cout << "  [-e event1] [-e event2] [-e event3]=> optional list of custom TSX events to monitor (up to 4)."
         << "  The list of supported events:\n";
    for (auto & e: eventDefinition)
    {
        cout << e.name << "\t" << e.description << "\n";
    }
    cout << "\n";
    cout << " Examples:\n";
    cout << "  " << progname << " 1                  => print counters every second without core and socket output\n";
    cout << "  " << progname << " 0.5 -csv=test.log  => twice a second save counter values to test.log in CSV format\n";
    cout << "  " << progname << " /csv 5 2>/dev/null => one sample every 5 seconds, and discard all diagnostic output\n";
    cout << "\n";
}


#define TX_CYCLES_POS           (1)
#define TX_CYCLES_COMMITED_POS  (2)
#define N_HLE_POS               (3)
#define N_RTM_POS               (0)

bool supportNHLECountBasicStat = true;

template <class StateType>
void print_basic_stats(const StateType & BeforeState, const StateType & AfterState, bool csv)
{
    uint64 cycles = getCycles(BeforeState, AfterState);
    uint64 instr = getInstructionsRetired(BeforeState, AfterState);
    const uint64 TXcycles = getNumberOfCustomEvents(TX_CYCLES_POS, BeforeState, AfterState);
    const uint64 TXcycles_commited = getNumberOfCustomEvents(TX_CYCLES_COMMITED_POS, BeforeState, AfterState);
    const uint64 Abr_cycles = (TXcycles > TXcycles_commited) ? (TXcycles - TXcycles_commited) : 0ULL;
    uint64 nRTM = getNumberOfCustomEvents(N_RTM_POS, BeforeState, AfterState);
    uint64 nHLE = getNumberOfCustomEvents(N_HLE_POS, BeforeState, AfterState);

    if (csv)
    {
        cout << double(instr) / double(cycles) << ",";
        cout << instr << ",";
        cout << cycles << ",";
        cout << TXcycles << "," << std::setw(5) << 100. * double(TXcycles) / double(cycles) << "%,";
        cout << Abr_cycles << "," << std::setw(5) << 100. * double(Abr_cycles) / double(cycles) << "%,";
        cout << nRTM << ",";
        if (supportNHLECountBasicStat)
        {
            cout << nHLE << ",";
        }
    }
    else
    {
        cout << double(instr) / double(cycles) << "       ";
        cout << unit_format(instr) << "     ";
        cout << unit_format(cycles) << "      ";
        cout << unit_format(TXcycles) << " (" << std::setw(5) << 100. * double(TXcycles) / double(cycles) << "%)       ";
        cout << unit_format(Abr_cycles) << " (" << std::setw(5) << 100. * double(Abr_cycles) / double(cycles) << "%) ";
        cout << unit_format(nRTM) << "   ";
        if (supportNHLECountBasicStat)
        {
            cout << unit_format(nHLE) << "    ";
        }
    }

    if (nRTM + nHLE)
    {
        uint64 cyclesPerTransaction = TXcycles / (nRTM + nHLE);
        if (csv)
            cout << cyclesPerTransaction << "\n";
        else
            cout << unit_format(cyclesPerTransaction) << "\n";
    }
    else
        cout << " N/A\n";
}

std::vector<int> events;

template <class StateType>
void print_custom_stats(const StateType & BeforeState, const StateType & AfterState, bool csv)
{
    for (size_t i = 0; i < events.size(); ++i)
        if (!csv)
            cout << unit_format(getNumberOfCustomEvents((pcm::int32)i, BeforeState, AfterState)) << "    ";
        else
            cout << getNumberOfCustomEvents((pcm::int32)i, BeforeState, AfterState) << ",";

    cout << "\n";
}


int findEvent(const char * name)
{
    for (size_t i = 0; i < eventDefinition.size(); ++i)
    {
        if (strcmp(name, eventDefinition[i].name) == 0)
            return (int)i;
    }
    return -1;
}

PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
    if(print_version(argc, argv))
        exit(EXIT_SUCCESS);

    null_stream nullStream2;
#ifdef PCM_FORCE_SILENT
    null_stream nullStream1;
    std::cout.rdbuf(&nullStream1);
    std::cerr.rdbuf(&nullStream2);
#else
    check_and_set_silent(argc, argv, nullStream2);
#endif

    set_signal_handlers();


    cerr << "\n";
    cerr << " Intel(r) Performance Counter Monitor: Intel(r) Transactional Synchronization Extensions Monitoring Utility \n";
    cerr << "\n";

    double delay = -1.0;
    int pid{ -1 };
    char * sysCmd = NULL;
    char ** sysArgv = NULL;
    int cur_event;
    bool csv = false;
    bool force = false;
    MainLoop mainLoop;
    string program = string(argv[0]);

    parsePID(argc, argv, pid);

    PCM * m = PCM::getInstance();
    const size_t numCtrSupported = m->getMaxCustomCoreEvents();
    switch (m->getCPUFamilyModel())
    {
    case PCM::SKL:
    case PCM::SKX:
    case PCM::KBL:
        eventDefinition = sklEventDefinition;
        break;
    case PCM::ICL:
    case PCM::ICX:
    case PCM::RKL:
        eventDefinition = iclEventDefinition;
        break;
    case PCM::SPR:
    case PCM::EMR:
    case PCM::GNR:
    case PCM::GNR_D:
        eventDefinition = sprEventDefinition;
        break;
    }

    if (argc > 1) do
        {
            argv++;
            argc--;
            string arg_value;

            if (*argv == nullptr)
            {
                continue;
            }
            else if (check_argument_equals(*argv, {"--help", "-h", "/h"}))
            {
                print_usage(program);
                exit(EXIT_FAILURE);
            }
            else if (check_argument_equals(*argv, {"-silent", "/silent"}))
            {
                // handled in check_and_set_silent
                continue;
            }
            else if (isPIDOption(argv))
            {
                argv++;
                argc--;
                continue;
            }
            else if (check_argument_equals(*argv, {"-csv", "/csv"}))
            {
                csv = true;
            }
            else if (extract_argument_value(*argv, {"-csv", "/csv"}, arg_value))
            {
                csv = true;
                if (!arg_value.empty()) {
                    m->setOutput(arg_value);
                }
                continue;
            }
            else if (mainLoop.parseArg(*argv))
            {
                continue;
            }
            else if (check_argument_equals(*argv, {"-e"}))
            {
                argv++;
                argc--;
                if (events.size() >= numCtrSupported) {
                    cerr << "At most " << numCtrSupported << " events are allowed\n";
                    exit(EXIT_FAILURE);
                }
                cur_event = findEvent(*argv);
                if (cur_event < 0) {
                    cerr << "Event " << *argv << " is not supported. See the list of supported events\n";
                    print_usage(program);
                    exit(EXIT_FAILURE);
                }
                events.push_back(cur_event);
                continue;
            }
            else if (CheckAndForceRTMAbortMode(*argv, m)) // for pcm-tsx this option is enabled for testing only, not exposed in the help
            {
                continue;
            }
            else if (check_argument_equals(*argv, {"-F", "-f", "-force"}))
            {
                force = true;
            }
            else if (check_argument_equals(*argv, {"--"}))
            {
                argv++;
                sysCmd = *argv;
                sysArgv = argv;
                break;
            }
            else
            {
                delay = parse_delay(*argv, program, (print_usage_func)print_usage);
                continue;
            }
        } while (argc > 1); // end of command line partsing loop

    EventSelectRegister def_event_select_reg;
    def_event_select_reg.value = 0;
    def_event_select_reg.fields.usr = 1;
    def_event_select_reg.fields.os = 1;
    def_event_select_reg.fields.enable = 1;

    PCM::ExtendedCustomCoreEventDescription conf;
    conf.fixedCfg = NULL; // default
    EventSelectRegister regs[PERF_MAX_CUSTOM_COUNTERS];
    conf.gpCounterCfg = regs;
    for (int i = 0; i < PERF_MAX_CUSTOM_COUNTERS; ++i)
        regs[i] = def_event_select_reg;

    if (events.empty())
    {
        conf.nGPCounters = 4;
        if (m->getMaxCustomCoreEvents() == 3)
        {
            conf.nGPCounters = 3;
            supportNHLECountBasicStat = false;
        }
        regs[N_RTM_POS].fields.event_select = 0xc9;
        regs[N_RTM_POS].fields.umask = 0x01;
        regs[N_HLE_POS].fields.event_select = 0xc8;
        regs[N_HLE_POS].fields.umask = 0x01;
        regs[TX_CYCLES_COMMITED_POS].fields.event_select = 0x3c;
        regs[TX_CYCLES_COMMITED_POS].fields.in_tx = 1;
        regs[TX_CYCLES_COMMITED_POS].fields.in_txcp = 1;
        regs[TX_CYCLES_POS].fields.event_select = 0x3c;
        regs[TX_CYCLES_POS].fields.in_tx = 1;
    }
    else
    {
        conf.nGPCounters = (uint32) events.size();
        for (unsigned int i = 0; i < events.size(); ++i)
        {
            const auto event = eventDefinition[events[i]].event;
            if (event == 0x54 && i >= 4)
            {
                cerr << "Error: a TX_MEM.* event found in position " << i <<
                    " which is not supported. Reorder the events in the command line such that TX_MEM events are at positions 0..3.\n";
                return -1;
            }
            regs[i].fields.event_select = event;
            regs[i].fields.umask = eventDefinition[events[i]].umask;
        }
    }

    bool rtm_support = m->supportsRTM();

    if (!rtm_support) {
        if (!force) {
            cerr << "No RTM support detected, use -F if you still want to run this program.\n";
            exit(EXIT_FAILURE);
        }
        cerr << "No RTM support detected, but -F found as argument, running anyway.\n";
    }

    print_pid_collection_message(pid);

    PCM::ErrorCode status = m->program(PCM::EXT_CUSTOM_CORE_EVENTS, &conf, false, pid);
    m->checkError(status);

    print_cpu_details();

    uint64 BeforeTime = 0, AfterTime = 0;
    SystemCounterState SysBeforeState, SysAfterState;
    const uint32 ncores = m->getNumCores();
    std::vector<CoreCounterState> BeforeState, AfterState;
    std::vector<SocketCounterState> DummySocketStates;

    if ((sysCmd != NULL) && (delay <= 0.0)) {
        // in case external command is provided in command line, and
        // delay either not provided (-1) or is zero
        m->setBlocked(true);
    } else {
        m->setBlocked(false);
    }

    if (csv) {
        if (delay <= 0.0) delay = PCM_DELAY_DEFAULT;
    } else {
        // for non-CSV mode delay < 1.0 does not make a lot of practical sense:
        // hard to read from the screen, or
        // in case delay is not provided in command line => set default
        if (((delay < 1.0) && (delay > 0.0)) || (delay <= 0.0)) delay = PCM_DELAY_DEFAULT;
    }

    cerr << "Update every " << delay << " seconds\n";

    std::cout.precision(2);
    std::cout << std::fixed;

    BeforeTime = m->getTickCount();
    m->getAllCounterStates(SysBeforeState, DummySocketStates, BeforeState);

    if (sysCmd != NULL) {
        MySystem(sysCmd, sysArgv);
    }

    mainLoop([&]()
    {
        if (!csv) cout << std::flush;

        calibratedSleep(delay, sysCmd, mainLoop, m);

        AfterTime = m->getTickCount();
        m->getAllCounterStates(SysAfterState, DummySocketStates, AfterState);

        cout << "Time elapsed: " << dec << fixed << AfterTime - BeforeTime << " ms\n";
        //cout << "Called sleep function for " <<dec<<fixed<<delay_ms<< " ms\n";

        if (events.empty())
        {
            if (csv) {
                cout << "Core,IPC,Instructions,Cycles,Transactional Cycles,Transactional Cycles %,Aborted Cycles,Aborted Cycles %,#RTM,";
                if (supportNHLECountBasicStat)
                {
                    cout << "#HLE,";
                }
                cout << "Cycles/Transaction \n";
            }
            else {
                cout << "Core | IPC  | Instructions | Cycles  | Transactional Cycles | Aborted Cycles  | #RTM  |";
                if (supportNHLECountBasicStat)
                {
                    cout << " #HLE  |";
                }
                cout << " Cycles/Transaction \n";
            }
        }
        else
        {
            for (uint32 i = 0; i < events.size(); ++i)
            {
                cout << "Event" << i << ": " << eventDefinition[events[i]].name << " " << eventDefinition[events[i]].description << " (raw 0x" <<
                std::hex << (uint32)eventDefinition[events[i]].umask << (uint32)eventDefinition[events[i]].event << std::dec << ")\n";
            }
            cout << "\n";
            if (csv)
            {
                cout << "Core";
                for (unsigned i = 0; i < events.size(); ++i)
                {
                    cout << ",Event" << i;
                }
                cout << "\n";
            }
            else
            {
                cout << "Core ";
                for (unsigned i = 0; i < events.size(); ++i)
                {
                    cout << "| Event" << i << "  ";
                }
                cout << "\n";
            }
        }
        for (uint32 i = 0; i < ncores; ++i)
        {
            if (csv)
                cout << i << ",";
            else
                cout << " " << setw(3) << i << "   " << setw(2);
            if (events.empty())
                print_basic_stats(BeforeState[i], AfterState[i], csv);
            else
                print_custom_stats(BeforeState[i], AfterState[i], csv);
        }
        if (csv)
            cout << "*,";
        else
        {
            cout << "-------------------------------------------------------------------------------------------------------------------\n";
            cout << "   *   ";
        }
        if (events.empty())
            print_basic_stats(SysBeforeState, SysAfterState, csv);
        else
            print_custom_stats(SysBeforeState, SysAfterState, csv);

        std::cout << "\n";

        swap(BeforeTime, AfterTime);
        swap(BeforeState, AfterState);
        swap(SysBeforeState, SysAfterState);

        if (m->isBlocked()) {
            // in case PCM was blocked after spawning child application: break monitoring loop here
            return false;
        }
        return true;
    });
    exit(EXIT_SUCCESS);
}

```

`src/pcm.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev,
//            Thomas Willhalm,
//            Patrick Ungerer


/*!     \file pcm.cpp
\brief Example of using CPU counters: implements a simple performance counter monitoring utility
*/
#include <iostream>
#ifdef _MSC_VER
#include <windows.h>
#include "windows/windriver.h"
#else
#include <unistd.h>
#include <signal.h>   // for atexit()
#include <sys/time.h> // for gettimeofday()
#endif
#include <math.h>
#include <iomanip>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <cstring>
#include <sstream>
#include <assert.h>
#include <bitset>
#include "cpucounters.h"
#include "utils.h"

#define SIZE (10000000)
#define PCM_DELAY_DEFAULT 1.0 // in seconds
#define PCM_DELAY_MIN 0.015 // 15 milliseconds is practical on most modern CPUs
#define MAX_CORES 4096

using namespace std;
using namespace pcm;

template <class IntType>
double float_format(IntType n)
{
    return double(n) / 1e6;
}

std::string temp_format(int32 t)
{
    char buffer[1024];
    if (t == PCM_INVALID_THERMAL_HEADROOM)
        return "N/A";

    snprintf(buffer, 1024, "%2d", t);
    return buffer;
}

std::string l3cache_occ_format(uint64 o)
{
    char buffer[1024];
    if (o == PCM_INVALID_QOS_MONITORING_DATA)
        return "N/A";

    snprintf(buffer, 1024, "%6u", (uint32) o);
    return buffer;
}

template <class UncoreStateType>
double getAverageUncoreFrequencyGhz(const UncoreStateType& before, const UncoreStateType& after) // in GHz
{
    return getAverageUncoreFrequency(before, after) / 1e9;
}

void print_help(const string & prog_name)
{
    cout << "\n Usage: \n " << prog_name
        << " --help | [delay] [options] [-- external_program [external_program_options]]\n";
    cout << "   <delay>                           => time interval to sample performance counters.\n";
    cout << "                                        If not specified, or 0, with external program given\n";
    cout << "                                        will read counters only after external program finishes\n";
    cout << " Supported <options> are: \n";
    cout << "  -h    | --help      | /h           => print this help and exit\n";
    cout << "  -silent                            => silence information output and print only measurements\n";
    cout << "  --version                          => print application version\n";
    cout << "  -pid PID | /pid PID                => collect core metrics only for specified process ID\n";
#ifdef _MSC_VER
    cout << "  --uninstallDriver   | --installDriver=> (un)install driver\n";
#endif
    cout << "  -r    | --reset     | /reset       => reset PMU configuration (at your own risk)\n";
    cout << "  -nc   | --nocores   | /nc          => hide core related output\n";
    cout << "  -yc   | --yescores  | /yc          => enable specific cores to output\n";
    cout << "  -ns   | --nosockets | /ns          => hide socket related output\n";
    cout << "  -nsys | --nosystem  | /nsys        => hide system related output\n";
    cout << "  --color                            => use ASCII colors\n";
    cout << "  --no-color                         => don't use ASCII colors\n";
    cout << "  -csv[=file.csv] | /csv[=file.csv]  => output compact CSV format to screen or\n"
        << "                                        to a file, in case filename is provided\n"
        << "                                        the format used is documented here: https://www.intel.com/content/www/us/en/developer/articles/technical/intel-pcm-column-names-decoder-ring.html\n";
    cout << "  -i[=number] | /i[=number]          => allow to determine number of iterations\n";
    cout << "  -m=integer | /m=integer            => metrics version (default = 2)\n";
    print_enforce_flush_option_help();
    print_help_force_rtm_abort_mode(37);
    cout << " Examples:\n";
    cout << "  " << prog_name << " 1 -nc -ns          => print counters every second without core and socket output\n";
    cout << "  " << prog_name << " 1 -i=10            => print counters every second 10 times and exit\n";
    cout << "  " << prog_name << " 0.5 -csv=test.log  => twice a second save counter values to test.log in CSV format\n";
    cout << "  " << prog_name << " /csv 5 2>/dev/null => one sample every 5 seconds, and discard all diagnostic output\n";
    cout << "\n";
}


template <class State>
void print_basic_metrics(const PCM * m, const State & state1, const State & state2, const int metricVersion)
{
    switch (metricVersion)
    {
        case 2:
            if (m->isCoreCStateResidencySupported(0))
            {
                cout << setNextColor() << "     " << getCoreCStateResidency(0, state1, state2);
            }
            cout << setNextColor() <<  "   " << getIPC(state1, state2);
            if (m->isActiveRelativeFrequencyAvailable())
            {
                cout << setNextColor() <<  "    " << getActiveAverageFrequency(state1, state2)/1e9;
            }
            break;
        default:
            cout << setNextColor() << "     " << getExecUsage(state1, state2) <<
                setNextColor() << "   " << getIPC(state1, state2) <<
                setNextColor() << "   " << getRelativeFrequency(state1, state2);
            if (m->isActiveRelativeFrequencyAvailable())
                cout << setNextColor() << "    " << getActiveRelativeFrequency(state1, state2);
    }
    if (m->isL3CacheMissesAvailable())
        cout << setNextColor() << "    " << unit_format(getL3CacheMisses(state1, state2));
    if (m->isL2CacheMissesAvailable())
        cout << setNextColor() << "   " << unit_format(getL2CacheMisses(state1, state2));
    if (m->isL3CacheHitRatioAvailable())
        cout << setNextColor() << "    " << getL3CacheHitRatio(state1, state2);
    if (m->isL2CacheHitRatioAvailable())
        cout << setNextColor() << "    " << getL2CacheHitRatio(state1, state2);
    cout.precision(4);
    if (m->isL3CacheMissesAvailable())
        cout << setNextColor() << "  " << double(getL3CacheMisses(state1, state2)) / getInstructionsRetired(state1, state2);
    if (m->isL2CacheMissesAvailable())
        cout << setNextColor() << "  " << double(getL2CacheMisses(state1, state2)) / getInstructionsRetired(state1, state2);
    cout.precision(2);
}

template <class State>
void print_other_metrics(const PCM * m, const State & state1, const State & state2)
{
    if (m->L3CacheOccupancyMetricAvailable())
        cout << setNextColor() << "   " << setw(6) << l3cache_occ_format(getL3CacheOccupancy(state2));
    if (m->CoreLocalMemoryBWMetricAvailable())
        cout << setNextColor() << "   " << setw(6) << getLocalMemoryBW(state1, state2);
    if (m->CoreRemoteMemoryBWMetricAvailable())
        cout << setNextColor() << "   " << setw(6) << getRemoteMemoryBW(state1, state2);
    cout << setNextColor() <<  "     " << temp_format(state2.getThermalHeadroom()) << "\n";
}

void print_output(PCM * m,
    const std::vector<CoreCounterState> & cstates1,
    const std::vector<CoreCounterState> & cstates2,
    const std::vector<SocketCounterState> & sktstate1,
    const std::vector<SocketCounterState> & sktstate2,
    const std::bitset<MAX_CORES> & ycores,
    const SystemCounterState& sstate1,
    const SystemCounterState& sstate2,
    const int cpu_family_model,
    const bool show_core_output,
    const bool show_partial_core_output,
    const bool show_socket_output,
    const bool show_system_output,
    const int metricVersion
    )
{
    cout << "\n";

    switch (metricVersion)
    {
        case 2:
            if (m->isCoreCStateResidencySupported(0))
            {
                cout << " UTIL  : utlization (same as core C0 state active state residency, the value is in 0..1) \n";
            }
            cout << " IPC   : instructions per CPU cycle\n";
            if (m->isActiveRelativeFrequencyAvailable())
            {
                cout << " CFREQ : core frequency in GHz\n";
            }
            break;
        default:
            cout << " EXEC  : instructions per nominal CPU cycle\n";
            cout << " IPC   : instructions per CPU cycle\n";
            cout << " FREQ  : relation to nominal CPU frequency='unhalted clock ticks'/'invariant timer ticks' (includes Intel Turbo Boost)\n";
            if (m->isActiveRelativeFrequencyAvailable())
                cout << " AFREQ : relation to nominal CPU frequency while in active state (not in power-saving C state)='unhalted clock ticks'/'invariant timer ticks while in C0-state'  (includes Intel Turbo Boost)\n";
    };
    if (m->isL3CacheMissesAvailable())
        cout << " L3MISS: L3 (read) cache misses \n";
    if (m->isL2CacheHitsAvailable())
    {
        if (m->isAtom() || cpu_family_model == PCM::KNL)
            cout << " L2MISS: L2 (read) cache misses \n";
        else
            cout << " L2MISS: L2 (read) cache misses (including other core's L2 cache *hits*) \n";
    }
    if (m->isL3CacheHitRatioAvailable())
        cout << " L3HIT : L3 (read) cache hit ratio (0.00-1.00)\n";
    if (m->isL2CacheHitRatioAvailable())
        cout << " L2HIT : L2 cache hit ratio (0.00-1.00)\n";
    if (m->isL3CacheMissesAvailable())
        cout << " L3MPI : number of L3 (read) cache misses per instruction\n";
    if (m->isL2CacheMissesAvailable())
        cout << " L2MPI : number of L2 (read) cache misses per instruction\n";
    if (m->memoryTrafficMetricsAvailable()) cout << " READ  : bytes read from main memory controller (in GBytes)\n";
    if (m->memoryTrafficMetricsAvailable()) cout << " WRITE : bytes written to main memory controller (in GBytes)\n";
    if (m->localMemoryRequestRatioMetricAvailable()) cout << " LOCAL : ratio of local memory requests to memory controller in %\n";
    if (m->LLCReadMissLatencyMetricsAvailable()) cout << "LLCRDMISSLAT: average latency of last level cache miss for reads and prefetches (in ns)\n";
    if (m->PMMTrafficMetricsAvailable()) cout << " PMM RD : bytes read from PMM memory (in GBytes)\n";
    if (m->PMMTrafficMetricsAvailable()) cout << " PMM WR : bytes written to PMM memory (in GBytes)\n";
    if (m->HBMmemoryTrafficMetricsAvailable()) cout << " HBM READ  : bytes read from HBM controller (in GBytes)\n";
    if (m->HBMmemoryTrafficMetricsAvailable()) cout << " HBM WRITE : bytes written to HBM controller (in GBytes)\n";
    if (m->memoryIOTrafficMetricAvailable()) {
        cout << " IO    : bytes read/written due to IO requests to memory controller (in GBytes); this may be an over estimate due to same-cache-line partial requests\n";
        cout << " IA    : bytes read/written due to IA requests to memory controller (in GBytes); this may be an over estimate due to same-cache-line partial requests\n";
        cout << " GT    : bytes read/written due to GT requests to memory controller (in GBytes); this may be an over estimate due to same-cache-line partial requests\n";
    }
    if (m->L3CacheOccupancyMetricAvailable()) cout << " L3OCC : L3 occupancy (in KBytes)\n";
    if (m->CoreLocalMemoryBWMetricAvailable()) cout << " LMB   : L3 cache external bandwidth satisfied by local memory (in MBytes)\n";
    if (m->CoreRemoteMemoryBWMetricAvailable()) cout << " RMB   : L3 cache external bandwidth satisfied by remote memory (in MBytes)\n";
    cout << " TEMP  : Temperature reading in 1 degree Celsius relative to the TjMax temperature (thermal headroom): 0 corresponds to the max temperature\n";
    cout << " energy: Energy in Joules\n";
    cout << "\n";
    cout << "\n";
    const char * longDiv = "---------------------------------------------------------------------------------------------------------------\n";
    cout.precision(2);
    cout << std::fixed;
    if (cpu_family_model == PCM::KNL)
        cout << " Proc Tile Core Thread |";
    else
        cout << " Core (SKT) |";

    switch (metricVersion)
    {
        case 2:
            if (m->isCoreCStateResidencySupported(0))
            {
                cout << setNextColor() << " UTIL |";
            }
            cout << setNextColor() << " IPC  |";
            if (m->isActiveRelativeFrequencyAvailable())
            {
                cout << setNextColor() << " CFREQ |";
            }
            break;
        default:
            cout << setNextColor() << " EXEC |" << setNextColor() << " IPC  |" << setNextColor() <<" FREQ  |";
            if (m->isActiveRelativeFrequencyAvailable())
                cout << setNextColor() << " AFREQ |";
    }
    if (m->isL3CacheMissesAvailable())
        cout << setNextColor() << " L3MISS |";
    if (m->isL2CacheMissesAvailable())
        cout << setNextColor() << " L2MISS |";
    if (m->isL3CacheHitRatioAvailable())
        cout << setNextColor() << " L3HIT |";
    if (m->isL2CacheHitRatioAvailable())
        cout << setNextColor() << " L2HIT |";
    if (m->isL3CacheMissesAvailable())
        cout << setNextColor() << " L3MPI |";
    if (m->isL2CacheMissesAvailable())
        cout << setNextColor() << " L2MPI | ";
    if (m->L3CacheOccupancyMetricAvailable())
        cout << setNextColor() << "  L3OCC |";
    if (m->CoreLocalMemoryBWMetricAvailable())
        cout << setNextColor() << "   LMB  |";
    if (m->CoreRemoteMemoryBWMetricAvailable())
        cout << setNextColor() << "   RMB  |";

    cout << setNextColor() << " TEMP\n\n";

    cout << resetColor();

    if (show_core_output)
    {
        for (uint32 i = 0; i < m->getNumCores(); ++i)
        {
            if (m->isCoreOnline(i) == false || (show_partial_core_output && ycores.test(i) == false))
                continue;

            if (cpu_family_model == PCM::KNL)
                cout << setfill(' ') << internal << setw(5) << i
                << setw(5) << m->getTileId(i) << setw(5) << m->getCoreId(i)
                << setw(7) << m->getThreadId(i);
            else
                cout << " " << setw(3) << i << "   " << setw(2) << m->getSocketId(i);

            print_basic_metrics(m, cstates1[i], cstates2[i], metricVersion);
            print_other_metrics(m, cstates1[i], cstates2[i]);
            cout << resetColor();
        }
    }
    if (show_socket_output)
    {
        if (!(m->getNumSockets() == 1 && (m->isAtom() || cpu_family_model == PCM::KNL)))
        {
            cout << longDiv;
            for (uint32 i = 0; i < m->getNumSockets(); ++i)
            {
                cout << " SKT   " << setw(2) << i;
                print_basic_metrics(m, sktstate1[i], sktstate2[i], metricVersion);
                print_other_metrics(m, sktstate1[i], sktstate2[i]);
                cout << resetColor();
            }
        }
    }
    cout << longDiv;

    if (show_system_output)
    {
        if (cpu_family_model == PCM::KNL)
            cout << setw(22) << left << " TOTAL" << internal << setw(7-5);
        else
            cout << " TOTAL  *";

        print_basic_metrics(m, sstate1, sstate2, metricVersion);

        if (m->L3CacheOccupancyMetricAvailable())
            cout << setNextColor() <<"     N/A ";
        if (m->CoreLocalMemoryBWMetricAvailable())
            cout << setNextColor() <<"    N/A ";
        if (m->CoreRemoteMemoryBWMetricAvailable())
            cout << setNextColor() <<"    N/A ";

        cout << setNextColor() << "     N/A\n";
        cout << resetColor();
        cout << setNextColor() << "\n Instructions retired: " << unit_format(getInstructionsRetired(sstate1, sstate2)) << " ;"
            << setNextColor() << " Active cycles: " << unit_format(getCycles(sstate1, sstate2)) << " ;"
            << setNextColor() << " Time (TSC): " << unit_format(getInvariantTSC(cstates1[0], cstates2[0])) << "ticks;";
        if (m->systemEnergyMetricAvailable() && systemEnergyStatusValid(sstate1) && systemEnergyStatusValid(sstate2))
        {
            cout << setNextColor() << " SYS energy: " << getSystemConsumedJoules(sstate1, sstate2) << " J;";
        }
        cout << "\n\n";

        cout << resetColor() << setNextColor() << " Core C-state residencies: "<< setNextColor() << "C0 (active,non-halted): " << (getCoreCStateResidency(0, sstate1, sstate2)*100.) << " %;";
        for (int s = 1; s <= PCM::MAX_C_STATE; ++s)
        {
            if (m->isCoreCStateResidencySupported(s))
            {
                std::cout << setNextColor() << " C" << s << ": " << (getCoreCStateResidency(s, sstate1, sstate2)*100.) << " %;";
            }
        }
        cout << "\n" ;
        cout << resetColor() << setNextColor() << " Package C-state residencies: ";
        std::vector<StackedBarItem> CoreCStateStackedBar, PackageCStateStackedBar;
        for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
        {
            std::ostringstream sstr(std::ostringstream::out);
            sstr << std::hex << s;
            const char fill = sstr.str().c_str()[0];
            if (m->isCoreCStateResidencySupported(s))
            {
                CoreCStateStackedBar.push_back(StackedBarItem(getCoreCStateResidency(s, sstate1, sstate2), "", fill));
            }
            if (m->isPackageCStateResidencySupported(s))
            {
                std::cout << setNextColor() << " C" << s << ": " << (getPackageCStateResidency(s, sstate1, sstate2)*100.) << " %;";
                PackageCStateStackedBar.push_back(StackedBarItem(getPackageCStateResidency(s, sstate1, sstate2), "", fill));
            }
        }
        cout << "\n" << resetColor() << setColor(ASCII_BRIGHT_GREEN);

        drawStackedBar(" Core    C-state distribution", CoreCStateStackedBar, 80);
        cout << setColor(ASCII_GREEN);
        drawStackedBar(" Package C-state distribution", PackageCStateStackedBar, 80);

        cout << resetColor();

        if (m->getNumCores() == m->getNumOnlineCores() && false)
        {
            cout << "\n PHYSICAL CORE IPC                 : " << getCoreIPC(sstate1, sstate2) << " => corresponds to " << 100. * (getCoreIPC(sstate1, sstate2) / double(m->getMaxIPC())) << " % utilization for cores in active state";
            cout << "\n Instructions per nominal CPU cycle: " << getTotalExecUsage(sstate1, sstate2) << " => corresponds to " << 100. * (getTotalExecUsage(sstate1, sstate2) / double(m->getMaxIPC())) << " % core utilization over time interval\n";
        }
        if (m->isHWTMAL2Supported())
        {
            cout << setColor(ASCII_BRIGHT_MAGENTA);
            cout << " Pipeline stalls: " << setColor(ASCII_BRIGHT_CYAN) << "Frontend (fetch latency: " << int(100. * getFetchLatencyBound(sstate1, sstate2)) <<" %, fetch bandwidth: " << int(100. * getFetchBandwidthBound(sstate1, sstate2)) <<
                " %)\n                  " << setColor(ASCII_BRIGHT_RED) << "bad Speculation (branch misprediction: " << int(100. * getBranchMispredictionBound(sstate1, sstate2)) <<
                " %, machine clears: " << int(100. * getMachineClearsBound(sstate1, sstate2)) <<
                " %)\n                  " << setColor(ASCII_BRIGHT_YELLOW) << "Backend (buffer/cache/memory: " << int(100. * getMemoryBound(sstate1, sstate2)) <<
                " %, core: " << int(100. * getCoreBound(sstate1, sstate2)) <<
                " %)\n                  " << setColor(ASCII_BRIGHT_GREEN) << "Retiring (heavy operations: " << int(100. * getHeavyOperationsBound(sstate1, sstate2)) <<
                " %, light operations: " << int(100. * getLightOperationsBound(sstate1, sstate2)) << " %)\n";
        }
        else if (m->isHWTMAL1Supported())
        {
            cout << setColor(ASCII_BRIGHT_MAGENTA);
            cout << " Pipeline stalls: " << setColor(ASCII_BRIGHT_CYAN) << "Frontend bound: " << int(100. * getFrontendBound(sstate1, sstate2)) <<
                " %, " << setColor(ASCII_BRIGHT_RED) << "bad Speculation: " << int(100. * getBadSpeculation(sstate1, sstate2)) <<
                " %, " << setColor(ASCII_BRIGHT_YELLOW) << "Backend bound: " << int(100. * getBackendBound(sstate1, sstate2)) <<
                " %, " << setColor(ASCII_BRIGHT_GREEN) << "Retiring: " << int(100. * getRetiring(sstate1, sstate2)) << " %\n";
        }

        if (m->isHWTMAL1Supported())
        {
            cout << setColor(ASCII_BRIGHT_MAGENTA);
            std::vector<StackedBarItem> TMAStackedBar;
            TMAStackedBar.push_back(StackedBarItem(getFrontendBound(sstate1, sstate2), "", 'F'));
            TMAStackedBar.push_back(StackedBarItem(getBadSpeculation(sstate1, sstate2), "", 'S'));
            TMAStackedBar.push_back(StackedBarItem(getBackendBound(sstate1, sstate2), "", 'B'));
            TMAStackedBar.push_back(StackedBarItem(getRetiring(sstate1, sstate2), "", 'R'));
            drawStackedBar(" Pipeline stall distribution ", TMAStackedBar, 80);
            cout << resetColor() << "\n";
        }

#if 0
        cout << " SMI count: " << getSMICount(sstate1, sstate2) << "\n";
#endif
    }

    cout << setColor(ASCII_CYAN);

    if (show_socket_output)
    {
        if (m->getNumSockets() > 1 && m->incomingQPITrafficMetricsAvailable()) // QPI info only for multi socket systems
        {
            cout << "Intel(r) " << m->xPI() << " data traffic estimation in bytes (data traffic coming to CPU/socket through " << m->xPI() << " links):\n\n";

            const uint32 qpiLinks = (uint32)m->getQPILinksPerSocket();

            cout << "              ";
            for (uint32 i = 0; i < qpiLinks; ++i)
                cout << " " << m->xPI() << i << "    ";

            if (m->qpiUtilizationMetricsAvailable())
            {
                cout << "| ";
                for (uint32 i = 0; i < qpiLinks; ++i)
                    cout << " " << m->xPI() << i << "  ";
            }

            cout << "\n" << longDiv;


            for (uint32 i = 0; i < m->getNumSockets(); ++i)
            {
                cout << " SKT   " << setw(2) << i << "     ";
                for (uint32 l = 0; l < qpiLinks; ++l)
                    cout << unit_format(getIncomingQPILinkBytes(i, l, sstate1, sstate2)) << "   ";

                if (m->qpiUtilizationMetricsAvailable())
                {
                    cout << "|  ";
                    for (uint32 l = 0; l < qpiLinks; ++l)
                        cout << setw(3) << std::dec << int(100. * getIncomingQPILinkUtilization(i, l, sstate1, sstate2)) << "%   ";
                }

                cout << "\n";
            }
        }
    }

    if (show_system_output)
    {
        cout << longDiv;

        if (m->getNumSockets() > 1 && m->incomingQPITrafficMetricsAvailable()) // QPI info only for multi socket systems
            cout << "Total " << m->xPI() << " incoming data traffic: " << unit_format(getAllIncomingQPILinkBytes(sstate1, sstate2)) << "     " << m->xPI() << " data traffic/Memory controller traffic: " << getQPItoMCTrafficRatio(sstate1, sstate2) << "\n";
    }

    cout << setColor(ASCII_BRIGHT_CYAN);

    if (show_socket_output)
    {
        if (m->getNumSockets() > 1 && (m->outgoingQPITrafficMetricsAvailable())) // QPI info only for multi socket systems
        {
            cout << "\nIntel(r) " << m->xPI() << " traffic estimation in bytes (data and non-data traffic outgoing from CPU/socket through " << m->xPI() << " links):\n\n";

            const uint32 qpiLinks = (uint32)m->getQPILinksPerSocket();

            cout << "              ";
            for (uint32 i = 0; i < qpiLinks; ++i)
                cout << " " << m->xPI() << i << "    ";


            cout << "| ";
            for (uint32 i = 0; i < qpiLinks; ++i)
                cout << " " << m->xPI() << i << "  ";

            cout << "\n" << longDiv;

            for (uint32 i = 0; i < m->getNumSockets(); ++i)
            {
                cout << " SKT   " << setw(2) << i << "     ";
                for (uint32 l = 0; l < qpiLinks; ++l)
                    cout << unit_format(getOutgoingQPILinkBytes(i, l, sstate1, sstate2)) << "   ";

                cout << "|  ";
                for (uint32 l = 0; l < qpiLinks; ++l)
                    cout << setw(3) << std::dec << int(100. * getOutgoingQPILinkUtilization(i, l, sstate1, sstate2)) << "%   ";

                cout << "\n";
            }

            cout << longDiv;
            cout << "Total " << m->xPI() << " outgoing data and non-data traffic: " << unit_format(getAllOutgoingQPILinkBytes(sstate1, sstate2)) << "\n";
        }
    }
    cout << resetColor();

    if (show_socket_output)
    {
        cout << "\nMEM (GB)->|";
        if (m->memoryTrafficMetricsAvailable())
            cout << setNextColor() << "  READ |  WRITE |";
        if (m->localMemoryRequestRatioMetricAvailable())
            cout << setNextColor() << " LOCAL |";
        if (m->PMMTrafficMetricsAvailable())
            cout << setNextColor() << " PMM RD | PMM WR |";
        if (m->HBMmemoryTrafficMetricsAvailable())
            cout << setNextColor() << " HBM READ | HBM WRITE |";
        if (m->memoryIOTrafficMetricAvailable())
            cout << setNextColor() << "   IO   |";
        if (m->memoryIOTrafficMetricAvailable())
            cout << setNextColor() << "   IA   |";
        if (m->memoryIOTrafficMetricAvailable())
            cout << setNextColor() << "   GT   |";
        if (m->packageEnergyMetricsAvailable())
            cout << setNextColor() << " CPU energy |";
        if (m->ppEnergyMetricsAvailable())
        {
            cout << setNextColor() << " PP0 energy |";
            cout << setNextColor() << " PP1 energy |";
        }
        if (m->dramEnergyMetricsAvailable())
            cout << setNextColor() << " DIMM energy |";
        if (m->LLCReadMissLatencyMetricsAvailable())
            cout << setNextColor() << " LLCRDMISSLAT (ns)|";
        if (m->uncoreFrequencyMetricAvailable())
            cout << setNextColor() << " UncFREQ (Ghz)|";

        auto printCentered = [](const std::string& str, int width)
        {
            int len = str.length();
            if(width < len) {
                std::cout << str;
            } else {
                int diff = width - len;
                int pad1 = diff/2;
                int pad2 = diff - pad1;
                std::cout << std::string(pad1, ' ') << str << std::string(pad2, ' ');
            }
        };
        const std::vector<uint64> uncoreDieTypes{getUncoreDieTypes(sktstate2[0])};
        DBG(2, " Uncore die types count: ", uncoreDieTypes.size());
        if (uncoreDieTypes.empty() == false)
        {
            cout << setNextColor() << " Unc(Ghz) ";
            for (auto & d: uncoreDieTypes)
            {
                cout << setNextColor();
                printCentered(UncoreCounterState::getDieTypeStr(d), 7);
                cout << " ";
            }
            std::cout << "|" ;
        }
        cout << resetColor() << "\n";

        cout << longDiv;
        for (uint32 i = 0; i < m->getNumSockets(); ++i)
        {
                cout << " SKT  " << setw(2) << i;
                if (m->memoryTrafficMetricsAvailable())
                    cout << setNextColor() << "    " << setw(5) << getBytesReadFromMC(sktstate1[i], sktstate2[i]) / double(1e9) <<
                            "    " << setw(5) << getBytesWrittenToMC(sktstate1[i], sktstate2[i]) / double(1e9);
                if (m->localMemoryRequestRatioMetricAvailable())
                    cout << setNextColor() << "  " << setw(3) << int(100.* getLocalMemoryRequestRatio(sktstate1[i], sktstate2[i])) << " %";
                if (m->PMMTrafficMetricsAvailable())
                    cout << setNextColor() << "     " << setw(5) << getBytesReadFromPMM(sktstate1[i], sktstate2[i]) / double(1e9) <<
                            "     " << setw(5) << getBytesWrittenToPMM(sktstate1[i], sktstate2[i]) / double(1e9);
                if (m->HBMmemoryTrafficMetricsAvailable())
                    cout << setNextColor() << "   " << setw(11) << getBytesReadFromEDC(sktstate1[i], sktstate2[i]) / double(1e9) <<
                            "    " << setw(11) << getBytesWrittenToEDC(sktstate1[i], sktstate2[i]) / double(1e9);
                if (m->memoryIOTrafficMetricAvailable()) {
                    cout << setNextColor() << "    " << setw(5) << getIORequestBytesFromMC(sktstate1[i], sktstate2[i]) / double(1e9);
                    cout << setNextColor() << "    " << setw(5) << getIARequestBytesFromMC(sktstate1[i], sktstate2[i]) / double(1e9);
                    cout << setNextColor() << "    " << setw(5) << getGTRequestBytesFromMC(sktstate1[i], sktstate2[i]) / double(1e9);
                }
                if(m->packageEnergyMetricsAvailable()) {
                    cout << setNextColor() << "     ";
                    cout << setw(6) << getConsumedJoules(sktstate1[i], sktstate2[i]);
                }
                if (m->ppEnergyMetricsAvailable()) {
                    cout << setNextColor() << "     ";
                    cout << setw(6) << getConsumedJoules(0, sktstate1[i], sktstate2[i]);
                    cout << setNextColor() << "     ";
                    cout << setw(6) << getConsumedJoules(1, sktstate1[i], sktstate2[i]);
                }
                if(m->dramEnergyMetricsAvailable()) {
                    cout << setNextColor() << "     ";
                    cout << setw(6) << getDRAMConsumedJoules(sktstate1[i], sktstate2[i]);
                }
                if (m->LLCReadMissLatencyMetricsAvailable()) {
                    cout << setNextColor() << "         ";
                    cout << setw(6) << getLLCReadMissLatency(sktstate1[i], sktstate2[i]);
                }
                if (m->uncoreFrequencyMetricAvailable()) {
                    cout << setNextColor() << "             ";
                    cout << setw(4) << getAverageUncoreFrequencyGhz(sktstate1[i], sktstate2[i]);
                }
                const std::vector<double> uncoreFrequencies{getUncoreFrequency(sktstate2[i])};
                assert(uncoreFrequencies.size() == uncoreDieTypes.size());

                if (uncoreFrequencies.empty() == false)
                {
                    cout << setNextColor() << "                ";
                    for (auto & d: uncoreFrequencies)
                    {
                        cout << setNextColor() << "  " << std::setw(4) << d/1e9 << "  ";
                    }
                }
                cout << resetColor() << "\n";
        }
        cout << longDiv;
        if (m->getNumSockets() > 1) {
            cout << "       *";
            if (m->memoryTrafficMetricsAvailable())
                cout << setNextColor() << "    " << setw(5) << getBytesReadFromMC(sstate1, sstate2) / double(1e9) <<
                        "    " << setw(5) << getBytesWrittenToMC(sstate1, sstate2) / double(1e9);
            if (m->localMemoryRequestRatioMetricAvailable())
                cout << setNextColor() << "  " << setw(3) << int(100.* getLocalMemoryRequestRatio(sstate1, sstate2)) << " %";
            if (m->PMMTrafficMetricsAvailable())
                cout << setNextColor() << "     " << setw(5) << getBytesReadFromPMM(sstate1, sstate2) / double(1e9) <<
                        "     " << setw(5) << getBytesWrittenToPMM(sstate1, sstate2) / double(1e9);
            if (m->memoryIOTrafficMetricAvailable())
                cout << setNextColor() << "    " << setw(5) << getIORequestBytesFromMC(sstate1, sstate2) / double(1e9);
            if (m->packageEnergyMetricsAvailable()) {
                cout << setNextColor() << "     ";
                cout << setw(6) << getConsumedJoules(sstate1, sstate2);
            }
            if (m->ppEnergyMetricsAvailable()) {
                cout << setNextColor() << "     ";
                cout << setw(6) << getConsumedJoules(0, sstate1, sstate2);
                cout << setNextColor() << "     ";
                cout << setw(6) << getConsumedJoules(1, sstate1, sstate2);
            }
            if (m->dramEnergyMetricsAvailable()) {
                cout << setNextColor() << "     ";
                cout << setw(6) << getDRAMConsumedJoules(sstate1, sstate2);
            }
            if (m->LLCReadMissLatencyMetricsAvailable()) {
                cout << setNextColor() << "         ";
                cout << setw(6) << getLLCReadMissLatency(sstate1, sstate2);
            }
            if (m->uncoreFrequencyMetricAvailable()) {
                cout << setNextColor() << "             ";
                cout << setw(4) << getAverageUncoreFrequencyGhz(sstate1, sstate2);
            }
            cout << resetColor() << "\n";
        }
    }

}


void print_basic_metrics_csv_header(const PCM * m)
{
    cout << "EXEC,IPC,FREQ,";
    if (m->isActiveRelativeFrequencyAvailable())
        cout << "AFREQ,CFREQ,";
    if (m->isL3CacheMissesAvailable())
        cout << "L3MISS,";
    if (m->isL2CacheMissesAvailable())
        cout << "L2MISS,";
    if (m->isL3CacheHitRatioAvailable())
        cout << "L3HIT,";
    if (m->isL2CacheHitRatioAvailable())
        cout << "L2HIT,";
    if (m->isL3CacheMissesAvailable())
        cout << "L3MPI,";
    if (m->isL2CacheMissesAvailable())
        cout << "L2MPI,";
    if (m->isHWTMAL1Supported())
        cout << "Frontend_bound(%),Bad_Speculation(%),Backend_Bound(%),Retiring(%),";
    if (m->isHWTMAL2Supported())
    {
        cout << "Fetch_latency_bound(%),Fetch_bandwidth_bound(%),Branch_misprediction_bound(%),Machine_clears_bound(%),"
             << "Buffer_Cache_Memory_bound(%),Core_bound(%),Heavy_operations_bound(%),Light_operations_bound(%),";
    }
}

void print_csv_header_helper(const string & header, int count=1){
  for(int i = 0; i < count; i++){
    cout << header << ",";
  }
}

void print_basic_metrics_csv_semicolons(const PCM * m, const string & header)
{
    print_csv_header_helper(header, 3);    // EXEC;IPC;FREQ;
    if (m->isActiveRelativeFrequencyAvailable())
        print_csv_header_helper(header, 2);  // AFREQ;CFREQ;
    if (m->isL3CacheMissesAvailable())
        print_csv_header_helper(header);  // L3MISS;
    if (m->isL2CacheMissesAvailable())
        print_csv_header_helper(header);  // L2MISS;
    if (m->isL3CacheHitRatioAvailable())
        print_csv_header_helper(header);  // L3HIT
    if (m->isL2CacheHitRatioAvailable())
        print_csv_header_helper(header);  // L2HIT;
    if (m->isL3CacheMissesAvailable())
        print_csv_header_helper(header);  // L3MPI;
    if (m->isL2CacheMissesAvailable())
        print_csv_header_helper(header);  // L2MPI;
    if (m->isHWTMAL1Supported())
        print_csv_header_helper(header, 4); // Frontend_bound(%),Bad_Speculation(%),Backend_Bound(%),Retiring(%)
    if (m->isHWTMAL2Supported())
        print_csv_header_helper(header, 8);
}

void print_csv_header(PCM * m,
    const std::bitset<MAX_CORES> & ycores,
    const bool show_core_output,
    const bool show_partial_core_output,
    const bool show_socket_output,
    const bool show_system_output
    )
{
    // print first header line
    string header;
    header = "System";
    print_csv_header_helper(header,2);
    if (show_system_output)
    {
        print_basic_metrics_csv_semicolons(m,header);

        if (m->memoryTrafficMetricsAvailable())
            print_csv_header_helper(header,2);

        if (m->localMemoryRequestRatioMetricAvailable())
            print_csv_header_helper(header);

        if (m->PMMTrafficMetricsAvailable())
            print_csv_header_helper(header,2);

        if (m->HBMmemoryTrafficMetricsAvailable())
            print_csv_header_helper(header,2);

        print_csv_header_helper(header,7);
        if (m->getNumSockets() > 1) { // QPI info only for multi socket systems
            if (m->incomingQPITrafficMetricsAvailable())
                print_csv_header_helper(header,2);
            if (m->outgoingQPITrafficMetricsAvailable())
                print_csv_header_helper(header);
        }

        for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
            if (m->isCoreCStateResidencySupported(s))
                print_csv_header_helper("System Core C-States");
        for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
            if (m->isPackageCStateResidencySupported(s))
                print_csv_header_helper("System Pack C-States");
        if (m->packageEnergyMetricsAvailable())
            print_csv_header_helper(header);
        if (m->ppEnergyMetricsAvailable())
            print_csv_header_helper(header, 2);
        if (m->dramEnergyMetricsAvailable())
            print_csv_header_helper(header);
        if (m->systemEnergyMetricAvailable())
            print_csv_header_helper(header);
        if (m->LLCReadMissLatencyMetricsAvailable())
            print_csv_header_helper(header);
        if (m->uncoreFrequencyMetricAvailable())
            print_csv_header_helper(header);
    }

    if (show_socket_output)
    {
        for (uint32 i = 0; i < m->getNumSockets(); ++i)
        {
            header = "Socket " + std::to_string(i);
            print_basic_metrics_csv_semicolons(m,header);
            if (m->L3CacheOccupancyMetricAvailable())
                print_csv_header_helper(header);
            if (m->CoreLocalMemoryBWMetricAvailable())
                print_csv_header_helper(header);
            if (m->CoreRemoteMemoryBWMetricAvailable())
                print_csv_header_helper(header);
            if (m->memoryTrafficMetricsAvailable())
                print_csv_header_helper(header,2);
            if (m->localMemoryRequestRatioMetricAvailable())
                print_csv_header_helper(header);
            if (m->PMMTrafficMetricsAvailable())
                print_csv_header_helper(header,2);
            if (m->HBMmemoryTrafficMetricsAvailable())
                print_csv_header_helper(header,2);
            if (m->memoryIOTrafficMetricAvailable())
                print_csv_header_helper(header,3);
            print_csv_header_helper(header, 8); //TEMP,INST,ACYC,TIME(ticks),PhysIPC,PhysIPC%,INSTnom,INSTnom%,
        }

        if (m->getNumSockets() > 1 && (m->incomingQPITrafficMetricsAvailable())) // QPI info only for multi socket systems
        {
            const uint32 qpiLinks = (uint32)m->getQPILinksPerSocket();

            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                header = "SKT" + std::to_string(s) + "dataIn";
                print_csv_header_helper(header,qpiLinks);
                if (m->qpiUtilizationMetricsAvailable())
                {
                    header = "SKT" + std::to_string(s) + "dataIn (percent)";
                    print_csv_header_helper(header,qpiLinks);
                }
            }
        }

        if (m->getNumSockets() > 1 && (m->outgoingQPITrafficMetricsAvailable())) // QPI info only for multi socket systems
        {
            const uint32 qpiLinks = (uint32)m->getQPILinksPerSocket();

            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                header = "SKT" + std::to_string(s) + "trafficOut";
                print_csv_header_helper(header,qpiLinks);
                header = "SKT" + std::to_string(s) + "trafficOut (percent)";
                print_csv_header_helper(header,qpiLinks);
            }
        }


        for (uint32 i = 0; i < m->getNumSockets(); ++i)
        {
            header = "SKT" + std::to_string(i) + " Core C-State";
            for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
            if (m->isCoreCStateResidencySupported(s))
                print_csv_header_helper(header);
            header = "SKT" + std::to_string(i) + " Package C-State";
            for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
            if (m->isPackageCStateResidencySupported(s))
                print_csv_header_helper(header);
        }

        if (m->packageEnergyMetricsAvailable())
        {
            header = "Proc Energy (Joules)";
            print_csv_header_helper(header,m->getNumSockets());
        }
        if (m->ppEnergyMetricsAvailable())
        {
            header = "Power Plane 0 Energy (Joules)";
            print_csv_header_helper(header, m->getNumSockets());
            header = "Power Plane 1 Energy (Joules)";
            print_csv_header_helper(header, m->getNumSockets());
        }
        if (m->dramEnergyMetricsAvailable())
        {
            header = "DRAM Energy (Joules)";
            print_csv_header_helper(header,m->getNumSockets());
        }
        if (m->LLCReadMissLatencyMetricsAvailable())
        {
            header = "LLCRDMISSLAT (ns)";
            print_csv_header_helper(header,m->getNumSockets());
        }
        if (m->uncoreFrequencyMetricAvailable())
        {
            header = "UncFREQ (Ghz)";
            print_csv_header_helper(header, m->getNumSockets());
        }
        for (uint32 s = 0; s < m->getNumSockets(); ++s)
        {
            for (size_t die = 0; die < m->getNumUFSDies(); ++die)
            {
                header = "UncFREQ Die " + std::to_string(die) + " (Ghz)";
                print_csv_header_helper(header);
            }
        }
    }

    if (show_core_output)
    {
        for (uint32 i = 0; i < m->getNumCores(); ++i)
        {
            if (show_partial_core_output && ycores.test(i) == false)
                continue;

            std::stringstream hstream;
            hstream << "Core" << i << " (Socket" << setw(2) << m->getSocketId(i) << ")";
            header = hstream.str();
            print_basic_metrics_csv_semicolons(m,header);
            if (m->L3CacheOccupancyMetricAvailable())
                print_csv_header_helper(header);
            if (m->CoreLocalMemoryBWMetricAvailable())
                print_csv_header_helper(header);
            if (m->CoreRemoteMemoryBWMetricAvailable())
                print_csv_header_helper(header);

            for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
                if (m->isCoreCStateResidencySupported(s))
                    print_csv_header_helper(header);
            print_csv_header_helper(header);// TEMP
            print_csv_header_helper(header,7); //ACYC,TIME(ticks),PhysIPC,PhysIPC%,INSTnom,INSTnom%,
        }
    }

    // print second header line
    cout << "\n";
    printDateForCSV(Header2);
    if (show_system_output)
    {
        print_basic_metrics_csv_header(m);

        if (m->memoryTrafficMetricsAvailable())
                cout << "READ,WRITE,";

        if (m->localMemoryRequestRatioMetricAvailable())
            cout << "LOCAL,";

        if (m->PMMTrafficMetricsAvailable())
            cout << "PMM_RD,PMM_WR,";

        if (m->HBMmemoryTrafficMetricsAvailable())
                cout << "HBM_READ,HBM_WRITE,";

        cout << "INST,ACYC,TIME(ticks),PhysIPC,PhysIPC%,INSTnom,INSTnom%,";
        if (m->getNumSockets() > 1) { // QPI info only for multi socket systems
            if (m->incomingQPITrafficMetricsAvailable())
                cout << "Total" << m->xPI() << "in," << m->xPI() << "toMC,";
            if (m->outgoingQPITrafficMetricsAvailable())
                cout << "Total" << m->xPI() << "out,";
        }

        for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
        if (m->isCoreCStateResidencySupported(s))
            cout << "C" << s << "res%,";

        for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
        if (m->isPackageCStateResidencySupported(s))
            cout << "C" << s << "res%,";

        if (m->packageEnergyMetricsAvailable())
            cout << "Proc Energy (Joules),";
        if (m->ppEnergyMetricsAvailable())
        {
            cout << "Power Plane 0 Energy (Joules),";
            cout << "Power Plane 1 Energy (Joules),";
        }
        if (m->dramEnergyMetricsAvailable())
            cout << "DRAM Energy (Joules),";
        if (m->systemEnergyMetricAvailable())
            cout << "SYSTEM Energy (Joules),";
        if (m->LLCReadMissLatencyMetricsAvailable())
            cout << "LLCRDMISSLAT (ns),";
        if (m->uncoreFrequencyMetricAvailable())
            cout << "UncFREQ (Ghz),";
    }


    if (show_socket_output)
    {
        for (uint32 i = 0; i < m->getNumSockets(); ++i)
        {
             print_basic_metrics_csv_header(m);
             if (m->L3CacheOccupancyMetricAvailable())
                 cout << "L3OCC,";
             if (m->CoreLocalMemoryBWMetricAvailable())
                 cout << "LMB,";
             if (m->CoreRemoteMemoryBWMetricAvailable())
                 cout << "RMB,";
             if (m->memoryTrafficMetricsAvailable())
                 cout << "READ,WRITE,";
             if (m->localMemoryRequestRatioMetricAvailable())
                 cout << "LOCAL,";
             if (m->PMMTrafficMetricsAvailable())
                 cout << "PMM_RD,PMM_WR,";
             if (m->HBMmemoryTrafficMetricsAvailable())
                 cout << "HBM_READ,HBM_WRITE,";
             if (m->memoryIOTrafficMetricAvailable())
                 cout << "IO,IA,GT,";
             cout << "TEMP,INST,ACYC,TIME(ticks),PhysIPC,PhysIPC%,INSTnom,INSTnom%,";
        }

        if (m->getNumSockets() > 1 && (m->incomingQPITrafficMetricsAvailable())) // QPI info only for multi socket systems
        {
            const uint32 qpiLinks = (uint32)m->getQPILinksPerSocket();

            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 i = 0; i < qpiLinks; ++i)
                    cout << m->xPI() << i << ",";

                if (m->qpiUtilizationMetricsAvailable())
                for (uint32 i = 0; i < qpiLinks; ++i)
                    cout << m->xPI() << i << ",";
            }
        }

        if (m->getNumSockets() > 1 && (m->outgoingQPITrafficMetricsAvailable())) // QPI info only for multi socket systems
        {
            const uint32 qpiLinks = (uint32)m->getQPILinksPerSocket();
            for (uint32 s = 0; s < m->getNumSockets(); ++s)
            {
                for (uint32 i = 0; i < qpiLinks; ++i)
                    cout << m->xPI() << i << ",";
                for (uint32 i = 0; i < qpiLinks; ++i)
                    cout << m->xPI() << i << ",";
            }
        }

        for (uint32 i = 0; i < m->getNumSockets(); ++i)
        {
            for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
            if (m->isCoreCStateResidencySupported(s))
                cout << "C" << s << "res%,";

            for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
            if (m->isPackageCStateResidencySupported(s))
                cout << "C" << s << "res%,";
        }

        auto printSKT = [] (const uint32 i, const uint32 count = 1)
        {
            for (uint32 j = 0; j < count; ++j)
            {
                cout << "SKT" << i << ",";
            }
        };
        if (m->packageEnergyMetricsAvailable())
        {
            for (uint32 i = 0; i < m->getNumSockets(); ++i)
                printSKT(i);
        }
        if (m->ppEnergyMetricsAvailable())
        {
            for (uint32 i = 0; i < m->getNumSockets(); ++i)
                printSKT(i, 2);
        }
        if (m->dramEnergyMetricsAvailable())
        {
            for (uint32 i = 0; i < m->getNumSockets(); ++i)
                printSKT(i);
        }
        if (m->LLCReadMissLatencyMetricsAvailable())
        {
            for (uint32 i = 0; i < m->getNumSockets(); ++i)
                printSKT(i);
        }
        if (m->uncoreFrequencyMetricAvailable())
        {
            for (uint32 i = 0; i < m->getNumSockets(); ++i)
                printSKT(i);
        }
        for (uint32 i = 0; i < m->getNumSockets(); ++i)
        {
            printSKT(i, m->getNumUFSDies());
        }
    }

    if (show_core_output)
    {
        for (uint32 i = 0; i < m->getNumCores(); ++i)
        {
            if (show_partial_core_output && ycores.test(i) == false)
                continue;

            print_basic_metrics_csv_header(m);
            if (m->L3CacheOccupancyMetricAvailable())
                cout << "L3OCC,";
            if (m->CoreLocalMemoryBWMetricAvailable())
                cout << "LMB,";
            if (m->CoreRemoteMemoryBWMetricAvailable())
                cout << "RMB,";

            for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
                if (m->isCoreCStateResidencySupported(s))
                    cout << "C" << s << "res%,";

            cout << "TEMP,";
            cout << "INST,ACYC,TIME(ticks),PhysIPC,PhysIPC%,INSTnom,INSTnom%,";
        }
    }
}

template <class State>
void print_basic_metrics_csv(const PCM * m, const State & state1, const State & state2, const bool print_last_semicolon = true)
{
    cout << getExecUsage(state1, state2) <<
        ',' << getIPC(state1, state2) <<
        ',' << getRelativeFrequency(state1, state2);

    if (m->isActiveRelativeFrequencyAvailable())
        cout << ',' << getActiveRelativeFrequency(state1, state2) << ',' << getActiveAverageFrequency(state1, state2)/1e9;
    if (m->isL3CacheMissesAvailable())
        cout << ',' << float_format(getL3CacheMisses(state1, state2));
    if (m->isL2CacheMissesAvailable())
        cout << ',' << float_format(getL2CacheMisses(state1, state2));
    if (m->isL3CacheHitRatioAvailable())
        cout << ',' << getL3CacheHitRatio(state1, state2);
    if (m->isL2CacheHitRatioAvailable())
        cout << ',' << getL2CacheHitRatio(state1, state2);
    cout.precision(4);
    if (m->isL3CacheMissesAvailable())
        cout << ',' << double(getL3CacheMisses(state1, state2)) / getInstructionsRetired(state1, state2);
    if (m->isL2CacheMissesAvailable())
        cout << ',' << double(getL2CacheMisses(state1, state2)) / getInstructionsRetired(state1, state2);
    cout.precision(2);
    if (m->isHWTMAL1Supported())
    {
        cout << ',' << int(100. * getFrontendBound(state1, state2));
        cout << ',' << int(100. * getBadSpeculation(state1, state2));
        cout << ',' << int(100. * getBackendBound(state1, state2));
        cout << ',' << int(100. * getRetiring(state1, state2));
    }
    if (m->isHWTMAL2Supported())
    {
        cout << ',' << int(100. * getFetchLatencyBound(state1, state2));
        cout << ',' << int(100. * getFetchBandwidthBound(state1, state2));
        cout << ',' << int(100. * getBranchMispredictionBound(state1, state2));
        cout << ',' << int(100. * getMachineClearsBound(state1, state2));
        cout << ',' << int(100. * getMemoryBound(state1, state2));
        cout << ',' << int(100. * getCoreBound(state1, state2));
        cout << ',' << int(100. * getHeavyOperationsBound(state1, state2));
        cout << ',' << int(100. * getLightOperationsBound(state1, state2));
    }
    if (print_last_semicolon)
        cout << ",";
}

template <class State>
void print_other_metrics_csv(const PCM * m, const State & state1, const State & state2)
{
    if (m->L3CacheOccupancyMetricAvailable())
        cout << ',' << l3cache_occ_format(getL3CacheOccupancy(state2));
    if (m->CoreLocalMemoryBWMetricAvailable())
        cout << ',' << getLocalMemoryBW(state1, state2);
    if (m->CoreRemoteMemoryBWMetricAvailable())
        cout << ',' << getRemoteMemoryBW(state1, state2);
}

void print_csv(PCM * m,
    const std::vector<CoreCounterState> & cstates1,
    const std::vector<CoreCounterState> & cstates2,
    const std::vector<SocketCounterState> & sktstate1,
    const std::vector<SocketCounterState> & sktstate2,
    const std::bitset<MAX_CORES> & ycores,
    const SystemCounterState& sstate1,
    const SystemCounterState& sstate2,
    const bool show_core_output,
    const bool show_partial_core_output,
    const bool show_socket_output,
    const bool show_system_output
    )
{
    cout << "\n";
    printDateForCSV(CsvOutputType::Data);

    if (show_system_output)
    {
        print_basic_metrics_csv(m, sstate1, sstate2);

        if (m->memoryTrafficMetricsAvailable())
                cout << getBytesReadFromMC(sstate1, sstate2) / double(1e9) <<
                ',' << getBytesWrittenToMC(sstate1, sstate2) / double(1e9) << ',';

        if (m->localMemoryRequestRatioMetricAvailable())
            cout << int(100. * getLocalMemoryRequestRatio(sstate1, sstate2)) << ',';

        if (m->PMMTrafficMetricsAvailable())
            cout << getBytesReadFromPMM(sstate1, sstate2) / double(1e9) <<
            ',' << getBytesWrittenToPMM(sstate1, sstate2) / double(1e9) << ',';

        if (m->HBMmemoryTrafficMetricsAvailable())
                cout << getBytesReadFromEDC(sstate1, sstate2) / double(1e9) <<
                ',' << getBytesWrittenToEDC(sstate1, sstate2) / double(1e9) << ',';

        cout << float_format(getInstructionsRetired(sstate1, sstate2)) << ","
            << float_format(getCycles(sstate1, sstate2)) << ","
            << float_format(getInvariantTSC(cstates1[0], cstates2[0])) << ","
            << getCoreIPC(sstate1, sstate2) << ","
            << 100. * (getCoreIPC(sstate1, sstate2) / double(m->getMaxIPC())) << ","
            << getTotalExecUsage(sstate1, sstate2) << ","
            << 100. * (getTotalExecUsage(sstate1, sstate2) / double(m->getMaxIPC())) << ",";

        if (m->getNumSockets() > 1) { // QPI info only for multi socket systems
            if (m->incomingQPITrafficMetricsAvailable())
               cout << float_format(getAllIncomingQPILinkBytes(sstate1, sstate2)) << ","
                    << getQPItoMCTrafficRatio(sstate1, sstate2) << ",";
            if (m->outgoingQPITrafficMetricsAvailable())
               cout << float_format(getAllOutgoingQPILinkBytes(sstate1, sstate2)) << ",";
        }

        for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
        if (m->isCoreCStateResidencySupported(s))
            cout << getCoreCStateResidency(s, sstate1, sstate2) * 100 << ",";

        for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
        if (m->isPackageCStateResidencySupported(s))
            cout << getPackageCStateResidency(s, sstate1, sstate2) * 100 << ",";

        if (m->packageEnergyMetricsAvailable())
            cout << getConsumedJoules(sstate1, sstate2) << ",";
        if (m->ppEnergyMetricsAvailable())
            cout << getConsumedJoules(0, sstate1, sstate2) << "," << getConsumedJoules(1, sstate1, sstate2) << ",";
        if (m->dramEnergyMetricsAvailable())
            cout << getDRAMConsumedJoules(sstate1, sstate2) << ",";
        if (m->systemEnergyMetricAvailable())
            cout << getSystemConsumedJoules(sstate1, sstate2) << ",";
        if (m->LLCReadMissLatencyMetricsAvailable())
            cout << getLLCReadMissLatency(sstate1, sstate2) << ",";
        if (m->uncoreFrequencyMetricAvailable())
            cout << getAverageUncoreFrequencyGhz(sstate1, sstate2) << ",";
    }

    if (show_socket_output)
    {
        for (uint32 i = 0; i < m->getNumSockets(); ++i)
        {
            print_basic_metrics_csv(m, sktstate1[i], sktstate2[i], false);
            print_other_metrics_csv(m, sktstate1[i], sktstate2[i]);
            if (m->memoryTrafficMetricsAvailable())
                cout << ',' << getBytesReadFromMC(sktstate1[i], sktstate2[i]) / double(1e9) <<
                    ',' << getBytesWrittenToMC(sktstate1[i], sktstate2[i]) / double(1e9);
            if (m->localMemoryRequestRatioMetricAvailable())
                cout << ',' << int(100. * getLocalMemoryRequestRatio(sktstate1[i], sktstate2[i]));
            if (m->PMMTrafficMetricsAvailable())
                cout << ',' << getBytesReadFromPMM(sktstate1[i], sktstate2[i]) / double(1e9) <<
                ',' << getBytesWrittenToPMM(sktstate1[i], sktstate2[i]) / double(1e9);
            if (m->HBMmemoryTrafficMetricsAvailable())
                cout << ',' << getBytesReadFromEDC(sktstate1[i], sktstate2[i]) / double(1e9) <<
                ',' << getBytesWrittenToEDC(sktstate1[i], sktstate2[i]) / double(1e9);
            if (m->memoryIOTrafficMetricAvailable()) {
                cout << ',' << getIORequestBytesFromMC(sktstate1[i], sktstate2[i]) / double(1e9)
                     << ',' << getIARequestBytesFromMC(sktstate1[i], sktstate2[i]) / double(1e9)
                     << ',' << getGTRequestBytesFromMC(sktstate1[i], sktstate2[i]) / double(1e9);
            }
            cout << ',' << temp_format(sktstate2[i].getThermalHeadroom()) << ',';

            cout << float_format(getInstructionsRetired(sktstate1[i], sktstate2[i])) << ","
                << float_format(getCycles(sktstate1[i], sktstate2[i])) << ","
                << float_format(getInvariantTSC(cstates1[0], cstates2[0])) << ","
                << getCoreIPC(sktstate1[i], sktstate2[i]) << ","
                << 100. * (getCoreIPC(sktstate1[i], sktstate2[i]) / double(m->getMaxIPC())) << ","
                << getTotalExecUsage(sktstate1[i], sktstate2[i]) << ","
                << 100. * (getTotalExecUsage(sktstate1[i], sktstate2[i]) / double(m->getMaxIPC())) << ",";

        }

        if (m->getNumSockets() > 1 && (m->incomingQPITrafficMetricsAvailable())) // QPI info only for multi socket systems
        {
            const uint32 qpiLinks = (uint32)m->getQPILinksPerSocket();
            for (uint32 i = 0; i < m->getNumSockets(); ++i)
            {
                for (uint32 l = 0; l < qpiLinks; ++l)
                    cout << float_format(getIncomingQPILinkBytes(i, l, sstate1, sstate2)) << ",";

                if (m->qpiUtilizationMetricsAvailable())
                {
                    for (uint32 l = 0; l < qpiLinks; ++l)
                        cout << setw(3) << std::dec << int(100. * getIncomingQPILinkUtilization(i, l, sstate1, sstate2)) << "%,";
                }
            }
        }

        if (m->getNumSockets() > 1 && (m->outgoingQPITrafficMetricsAvailable())) // QPI info only for multi socket systems
        {
            const uint32 qpiLinks = (uint32)m->getQPILinksPerSocket();
            for (uint32 i = 0; i < m->getNumSockets(); ++i)
            {
                for (uint32 l = 0; l < qpiLinks; ++l)
                    cout << float_format(getOutgoingQPILinkBytes(i, l, sstate1, sstate2)) << ",";

                for (uint32 l = 0; l < qpiLinks; ++l)
                    cout << setw(3) << std::dec << int(100. * getOutgoingQPILinkUtilization(i, l, sstate1, sstate2)) << "%,";
            }
        }

        for (uint32 i = 0; i < m->getNumSockets(); ++i)
        {
            for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
                if (m->isCoreCStateResidencySupported(s))
                    cout << getCoreCStateResidency(s, sktstate1[i], sktstate2[i]) * 100 << ",";

            for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
                if (m->isPackageCStateResidencySupported(s))
                    cout << getPackageCStateResidency(s, sktstate1[i], sktstate2[i]) * 100 << ",";
        }

        if (m->packageEnergyMetricsAvailable())
        {
            for (uint32 i = 0; i < m->getNumSockets(); ++i)
                cout << getConsumedJoules(sktstate1[i], sktstate2[i]) << ",";
        }
        if (m->ppEnergyMetricsAvailable())
        {
            for (uint32 i = 0; i < m->getNumSockets(); ++i)
                cout << getConsumedJoules(0, sktstate1[i], sktstate2[i]) << "," << getConsumedJoules(1, sktstate1[i], sktstate2[i]) << ",";
        }
        if (m->dramEnergyMetricsAvailable())
        {
            for (uint32 i = 0; i < m->getNumSockets(); ++i)
                cout << getDRAMConsumedJoules(sktstate1[i], sktstate2[i]) << " ,";
        }
        if (m->LLCReadMissLatencyMetricsAvailable())
        {
            for (uint32 i = 0; i < m->getNumSockets(); ++i)
                cout << getLLCReadMissLatency(sktstate1[i], sktstate2[i]) << " ,";
        }
        if (m->uncoreFrequencyMetricAvailable())
        {
            for (uint32 i = 0; i < m->getNumSockets(); ++i)
                cout << getAverageUncoreFrequencyGhz(sktstate1[i], sktstate2[i]) << ",";
        }
        for (uint32 i = 0; i < m->getNumSockets(); ++i)
        {
            const auto freqs = getUncoreFrequency(sktstate2[i]);
            assert(freqs.size() == (size_t)m->getNumUFSDies());
            for (auto & f : freqs)
            {
                cout << f/1e9 << ",";
            }
        }
    }

    if (show_core_output)
    {
        for (uint32 i = 0; i < m->getNumCores(); ++i)
        {
            if (show_partial_core_output && ycores.test(i) == false)
                continue;

            print_basic_metrics_csv(m, cstates1[i], cstates2[i], false);
            print_other_metrics_csv(m, cstates1[i], cstates2[i]);
            cout << ',';

            for (int s = 0; s <= PCM::MAX_C_STATE; ++s)
                if (m->isCoreCStateResidencySupported(s))
                    cout << getCoreCStateResidency(s, cstates1[i], cstates2[i]) * 100 << ",";

            cout << temp_format(cstates2[i].getThermalHeadroom()) << ',';

            cout << float_format(getInstructionsRetired(cstates1[i], cstates2[i])) << ","
                << float_format(getCycles(cstates1[i], cstates2[i])) << ","
                << float_format(getInvariantTSC(cstates1[0], cstates2[0])) << ","
                << getCoreIPC(cstates1[i], cstates2[i]) << ","
                << 100. * (getCoreIPC(cstates1[i], cstates2[i]) / double(m->getMaxIPC())) << ","
                << getTotalExecUsage(cstates1[i], cstates2[i]) << ","
                << 100. * (getTotalExecUsage(cstates1[i], cstates2[i]) / double(m->getMaxIPC())) << ",";
        }
    }
}

#ifndef UNIT_TEST

PCM_MAIN_NOTHROW;

int mainThrows(int argc, char * argv[])
{
    if(print_version(argc, argv))
        exit(EXIT_SUCCESS);

    null_stream nullStream2;
#ifdef PCM_FORCE_SILENT
    null_stream nullStream1;
    std::cout.rdbuf(&nullStream1);
    std::cerr.rdbuf(&nullStream2);
#else
    check_and_set_silent(argc, argv, nullStream2);
#endif

    set_signal_handlers();

    cerr << "\n";
    cerr << " Intel(r) Performance Counter Monitor " << PCM_VERSION << "\n";
    cerr << "\n";
    
    cerr << "\n";

    // if delay is not specified: use either default (1 second),
    // or only read counters before or after PCM started: keep PCM blocked
    double delay = -1.0;
    int pid{-1};
    char *sysCmd = NULL;
    char **sysArgv = NULL;
    bool show_core_output = true;
    bool show_partial_core_output = false;
    bool show_socket_output = true;
    bool show_system_output = true;
    bool csv_output = false;
    bool reset_pmu = false;
    bool disable_JKT_workaround = false; // as per http://software.intel.com/en-us/articles/performance-impact-when-sampling-certain-llc-events-on-snb-ep-with-vtune
    bool enforceFlush = false;
    int metricVersion = 2;

    parsePID(argc, argv, pid);

    MainLoop mainLoop;
    std::bitset<MAX_CORES> ycores;
    string program = string(argv[0]);

    PCM * m = PCM::getInstance();

    if (argc > 1) do
    {
        argv++;
        argc--;
        std::string arg_value;

        if (*argv == nullptr)
        {
            continue;
        }
        else if (check_argument_equals(*argv, {"--help", "-h", "/h"}))
        {
            print_help(program);
            exit(EXIT_FAILURE);
        }
        else if (check_argument_equals(*argv, {"-silent", "/silent"}))
        {
            // handled in check_and_set_silent
            continue;
        }
        else if (check_argument_equals(*argv, {"--yescores", "-yc", "/yc"}))
        {
            argv++;
            argc--;
            show_partial_core_output = true;
            if(*argv == NULL)
            {
                cerr << "Error: --yescores requires additional argument.\n";
                exit(EXIT_FAILURE);
            }
            std::stringstream ss(*argv);
            while(ss.good())
            {
                string s;
                int core_id;
                std::getline(ss, s, ',');
                if(s.empty())
                    continue;
                core_id = atoi(s.c_str());
                if(core_id > MAX_CORES)
                {
                    cerr << "Core ID:" << core_id << " exceed maximum range " << MAX_CORES << ", program abort\n";
                    exit(EXIT_FAILURE);
                }

                ycores.set(core_id, true);
            }
            if(m->getNumCores() > MAX_CORES)
            {
                cerr << "Error: --yescores option is enabled, but #define MAX_CORES " << MAX_CORES << " is less than  m->getNumCores() = " << m->getNumCores() << "\n";
                cerr << "There is a potential to crash the system. Please increase MAX_CORES to at least " << m->getNumCores() << " and re-enable this option.\n";
                exit(EXIT_FAILURE);
            }
            continue;
        }
        else if (check_argument_equals(*argv, {"--nocores", "-nc", "/nc"}))
        {
            show_core_output = false;
            continue;
        }
        else if (check_argument_equals(*argv, {"--nosockets", "-ns", "/ns"}))
        {
            show_socket_output = false;
            continue;
        }
        else if (check_argument_equals(*argv, {"--nosystem", "-nsys", "/nsys"}))
        {
            show_system_output = false;
            continue;
        }
        else if (check_argument_equals(*argv, {"--color"}))
        {
            setColorEnabled();
            continue;
        }
        else if (check_argument_equals(*argv, { "--no-color" }))
        {
            setColorEnabled(false);
            continue;
        }
        else if (check_argument_equals(*argv, {"-csv", "/csv"}))
        {
            csv_output = true;
        }
        else if (extract_argument_value(*argv, {"-csv", "/csv"}, arg_value))
        {
            csv_output = true;
            if (!arg_value.empty()) {
                m->setOutput(arg_value);
            }
            continue;
        }
        else if (extract_argument_value(*argv, {"-m", "/m"}, arg_value))
        {
            if (!arg_value.empty()) {
                metricVersion = atoi(arg_value.c_str());
            }
            if (metricVersion == 0)
            {
                metricVersion = 2;
            }
            continue;
        }
        else if (isPIDOption(argv))
        {
            argv++;
            argc--;
            continue;
        }
        else if (mainLoop.parseArg(*argv))
        {
            continue;
        }
        else if (check_argument_equals(*argv, {"-reset", "/reset", "-r"}))
        {
            reset_pmu = true;
            continue;
        }
        else if (CheckAndForceRTMAbortMode(*argv, m))
        {
            continue;
        }
        else if (check_argument_equals(*argv, {"--noJKTWA"}))
        {
            disable_JKT_workaround = true;
            continue;
        }
        PCM_ENFORCE_FLUSH_OPTION
#ifdef _MSC_VER
        else if (check_argument_equals(*argv, {"--uninstallDriver"}))
        {
            Driver tmpDrvObject;
            tmpDrvObject.uninstall();
            cerr << "msr.sys driver has been uninstalled. You might need to reboot the system to make this effective.\n";
            exit(EXIT_SUCCESS);
        }
        else if (check_argument_equals(*argv, {"--installDriver"}))
        {
            Driver tmpDrvObject = Driver(Driver::msrLocalPath());
            if (!tmpDrvObject.start())
            {
                tcerr << "Can not access CPU counters\n";
                tcerr << "You must have a signed  driver at " << tmpDrvObject.driverPath() << " and have administrator rights to run this program\n";
                exit(EXIT_FAILURE);
            }
            exit(EXIT_SUCCESS);
        }
#endif
        else if (check_argument_equals(*argv, {"--"}))
        {
            argv++;
            sysCmd = *argv;
            sysArgv = argv;
            break;
        }
        else
        {
            delay = parse_delay(*argv, program, (print_usage_func)print_help);
            continue;
        }
    } while (argc > 1); // end of command line partsing loop

    if (disable_JKT_workaround) m->disableJKTWorkaround();

    if (reset_pmu)
    {
        cerr << "\n Resetting PMU configuration\n";
        m->resetPMU();
    }

    // program() creates common semaphore for the singleton, so ideally to be called before any other references to PCM
    const PCM::ErrorCode status = m->program(PCM::DEFAULT_EVENTS, nullptr, false, pid);

    switch (status)
    {
    case PCM::Success:
        break;
    case PCM::MSRAccessDenied:
        cerr << "Access to Intel(r) Performance Counter Monitor has denied (no MSR or PCI CFG space access).\n";
        exit(EXIT_FAILURE);
    case PCM::PMUBusy:
        cerr << "Access to Intel(r) Performance Counter Monitor has denied (Performance Monitoring Unit is occupied by other application). Try to stop the application that uses PMU.\n";
        cerr << "Alternatively you can try running PCM with option -r to reset PMU.\n";
        exit(EXIT_FAILURE);
    default:
        cerr << "Access to Intel(r) Performance Counter Monitor has denied (Unknown error).\n";
        exit(EXIT_FAILURE);
    }

    print_cpu_details();

    std::vector<CoreCounterState> cstates1, cstates2;
    std::vector<SocketCounterState> sktstate1, sktstate2;
    SystemCounterState sstate1, sstate2;
    const auto cpu_family_model = m->getCPUFamilyModel();

    print_pid_collection_message(pid);

    if ((sysCmd != NULL) && (delay <= 0.0)) {
        // in case external command is provided in command line, and
        // delay either not provided (-1) or is zero
        m->setBlocked(true);
    }
    else {
        m->setBlocked(false);
    }
    // in case delay is not provided in command line => set default
    if (delay <= 0.0) delay = PCM_DELAY_DEFAULT;
    // cerr << "DEBUG: Delay: " << delay << " seconds. Blocked: " << m->isBlocked() << "\n";

    if (csv_output) {
        print_csv_header(m, ycores, show_core_output, show_partial_core_output, show_socket_output, show_system_output);
    }

    m->getAllCounterStates(sstate1, sktstate1, cstates1);

    if (sysCmd != NULL) {
        MySystem(sysCmd, sysArgv);
    }

    mainLoop([&]()
    {
        if (enforceFlush || !csv_output) cout << std::flush;

        calibratedSleep(delay, sysCmd, mainLoop, m);

        m->getAllCounterStates(sstate2, sktstate2, cstates2);

        if (csv_output)
            print_csv(m, cstates1, cstates2, sktstate1, sktstate2, ycores, sstate1, sstate2,
                show_core_output, show_partial_core_output, show_socket_output, show_system_output);
        else
            print_output(m, cstates1, cstates2, sktstate1, sktstate2, ycores, sstate1, sstate2,
                cpu_family_model, show_core_output, show_partial_core_output, show_socket_output, show_system_output,
                metricVersion);

        std::swap(sstate1, sstate2);
        std::swap(sktstate1, sktstate2);
        std::swap(cstates1, cstates2);

        if (m->isBlocked()) {
            // in case PCM was blocked after spawning child application: break monitoring loop here
            return false;
        }
        return true;
    });

    exit(EXIT_SUCCESS);
}

#endif // UNIT_TEST

```

`src/pmt.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2024, Intel Corporation

#include "pmt.h"
#include "utils.h"
#include <assert.h>
#include <vector>
#include <unordered_map>
#include <iostream>
#include <algorithm>
#include <cctype>

#ifdef PCM_PUGIXML_AVAILABLE
#include "pugixml/src/pugixml.hpp"
#endif

#ifdef __linux__
#include <unistd.h>
#endif

namespace pcm {

#ifdef __linux__
class TelemetryArrayLinux : public TelemetryArrayInterface
{
    TelemetryArrayLinux() = delete;
    typedef std::vector<std::FILE *> FileVector;
    typedef std::unordered_map<uint64, FileVector> FileMap;
    static std::shared_ptr<FileMap> TelemetryFiles;
    static FileMap & getTelemetryFiles()
    {
        if (!TelemetryFiles.get())
        {
            std::shared_ptr<FileMap> TelemetryFilesTemp = std::make_shared<FileMap>();
            auto paths = findPathsFromPattern("/sys/class/intel_pmt/telem*");
            for (auto & path : paths)
            {
                const auto guid = read_number(readSysFS((path + "/guid").c_str()).c_str());
                #if 0
                auto size = read_number(readSysFS((path + "/size").c_str()).c_str());
                std::cout << "path: " << path << " guid: 0x" << std::hex << guid << " size: "<< std::dec << size <<  std::endl;
                #endif
                auto file = std::fopen((path + "/telem").c_str(), "rb");
                if (!file)
                {
                    std::cerr << "Error: failed to open " << path << "/telem" << std::endl;
                    continue;
                }
                TelemetryFilesTemp->operator[](guid).push_back(file);
            }
            
            // print the telemetry files
            for (auto & guid : *TelemetryFilesTemp)
            {
                auto & files = guid.second;
                for (auto & file : files)
                {
                    if (!file)
                    {
                        std::cerr << "Error: file is null" << std::endl;
                        continue;
                    }
                    // std::cout << "guid: 0x" << std::hex << guid.first << " file: " << file << std::endl;
                }
            }

            TelemetryFiles = TelemetryFilesTemp;
        }
        return *TelemetryFiles;
    }
    std::vector<unsigned char> data;
    size_t uid, instance;
public:
    TelemetryArrayLinux(const size_t uid_, const size_t instance_): uid(uid_), instance(instance_)
    {
        assert(instance < numInstances(uid));
        TelemetryArrayLinux::load();
    }
    static size_t numInstances(const size_t uid)
    {
        auto t = getTelemetryFiles();
        if (t.find(uid) == t.end())
        {
            return 0;
        }
        return t.at(uid).size();
    }
    static std::vector<size_t> getUIDs()
    {
        auto t = getTelemetryFiles();
        std::vector<size_t> result;
        for (auto & guid : t)
        {
            result.push_back(guid.first);
        }
        return result;
    }
    virtual ~TelemetryArrayLinux() override
    {
    }
    size_t size() override
    {
        return data.size();
    }
    void load() override
    {
        FILE * file = getTelemetryFiles().at(uid).at(instance);
        assert(file);
        // get the file size
        fseek(file, 0, SEEK_END);
        const auto pos = ftell(file);
        if (pos < 0)
        {
            std::cerr << "Error: failed to get file size" << std::endl;
            return;
        }
        const size_t fileSize = pos;
        fseek(file, 0, SEEK_SET);
        data.resize(fileSize);
        const size_t bytesRead = fread(data.data(), 1, fileSize, file);
        if (bytesRead != fileSize)
        {
            std::cerr << "Error: failed to read " << fileSize << " bytes from telemetry file" << std::endl;
        }
    }
    uint64 get(size_t qWordOffset, size_t lsb, size_t msb) override
    {
        assert(qWordOffset * sizeof(uint64) + sizeof(uint64) <= data.size());
        return extract_bits(*reinterpret_cast<uint64 *>(&data[qWordOffset * sizeof(uint64)]), lsb, msb);
    }
};

std::shared_ptr<TelemetryArrayLinux::FileMap> TelemetryArrayLinux::TelemetryFiles;

#else

class TelemetryArrayDummy : public TelemetryArrayInterface
{
    TelemetryArrayDummy() = delete;
public:
    TelemetryArrayDummy(const size_t /* uid */, const size_t /* instance */) {};
    static size_t numInstances(const size_t /* uid */) { return 0; };
    static std::vector<size_t> getUIDs() { return std::vector<size_t>(); };
    virtual ~TelemetryArrayDummy() override {};
    size_t size() override { return 0;}; // in bytes
    void load() override {};
    uint64 get(size_t , size_t , size_t ) override { return 0;} ;
};

#endif

TelemetryArray::TelemetryArray(const size_t uid, const size_t instance)
{
#ifdef __linux__
    impl = std::make_shared<TelemetryArrayLinux>(uid, instance);
#else
    impl = std::make_shared<TelemetryArrayDummy>(uid, instance);
#endif
}

size_t TelemetryArray::numInstances(const size_t uid)
{
#ifdef __linux__
    return TelemetryArrayLinux::numInstances(uid);
#else
    return TelemetryArrayDummy::numInstances(uid);
#endif
}

std::vector<size_t> TelemetryArray::getUIDs()
{
#ifdef __linux__
    return TelemetryArrayLinux::getUIDs();
#else
    return TelemetryArrayDummy::getUIDs();
#endif
}

TelemetryArray::~TelemetryArray() {}

size_t TelemetryArray::size()
{
    assert(impl.get());
    return impl->size();
}

void TelemetryArray::load()
{
    assert(impl.get());
    impl->load();
}

uint64 TelemetryArray::get(size_t qWordOffset, size_t lsb, size_t msb)
{
    assert(impl.get());
    return impl->get(qWordOffset, lsb, msb);
}


bool TelemetryDB::loadFromXML(const std::string& pmtXMLPath)
{
#ifdef PCM_PUGIXML_AVAILABLE
    pugi::xml_document doc;
    auto result = doc.load_file((pmtXMLPath + "/xml/pmt.xml").c_str());

    if (!result)
    {
        std::cerr << "Error: failed to load " << pmtXMLPath << "/xml/pmt.xml" << std::endl;
        return false;
    }

    constexpr bool debug = false;

    auto guids = TelemetryArray::getUIDs();
    for (pugi::xml_node mapping: doc.child("pmt").child("mappings").children("mapping"))
    {
        auto guid = read_number(mapping.attribute("guid").value());
        if (std::find(guids.begin(), guids.end(), guid) == guids.end())
        {
            // std::cerr << " guid " << std::hex << guid << " not found in telemetry files" << std::endl;
            continue;
        }
        if (debug) std::cout << "Found mapping with guid: " << mapping.attribute("guid").value() << std::endl;
        if (debug) std::cout << "  Description: " << mapping.child("description").text().as_string() << std::endl;
        const auto xmlset = mapping.child("xmlset");
        const auto basedir = xmlset.child("basedir").text().as_string();
        const auto aggregator = xmlset.child("aggregator").text().as_string();
        const auto aggregator_path = pmtXMLPath + "/xml/" + basedir + "/" + aggregator;
        if (debug) std::cout << "  Aggregator XML path: " << aggregator_path << std::endl;

        pugi::xml_document aggregatorDoc;
        auto aggregatorResult = aggregatorDoc.load_file(aggregator_path.c_str());
        if (!aggregatorResult)
        {
            std::cerr << "Error: failed to load " << aggregator_path << std::endl;
            return false;
        }

        auto aggregatorNode = aggregatorDoc.child("TELEM:Aggregator");
        const std::string aggregatorName = aggregatorNode.child("TELEM:name").text().as_string();
        if (debug) std::cout << "  Agregator name: " << aggregatorName << std::endl;
        PMTRecord record;
        record.uid = guid;
        for (pugi::xml_node sampleGroup: aggregatorNode.children("TELEM:SampleGroup"))
        {
            const auto sampleID = sampleGroup.attribute("sampleID").as_uint();
            if (debug) std::cout << "    SampleID: " << sampleID << std::endl;
            record.qWordOffset = sampleID;
            for (pugi::xml_node sample: sampleGroup.children("TELC:sample"))
            {
                const auto name = sample.attribute("name").as_string();
                const std::string sampleSubGroup = sample.child("TELC:sampleSubGroup").text().as_string();
                record.fullName = aggregatorName + "." + sampleSubGroup + "." + name;
                record.sampleType = sample.child("TELC:sampleType").text().as_string();
                record.lsb = sample.child("TELC:lsb").text().as_uint();
                record.msb = sample.child("TELC:msb").text().as_uint();
                record.description = sample.child("TELC:description").text().as_string();
                if (debug) std::cout << "      ";
                if (debug) record.print(std::cout);
                records.push_back(record);
            }
        }

        if (debug) std::cout << std::endl;
    }

    return true;
#else
    (void)pmtXMLPath; // suppress warning
    std::cerr << "INFO: pugixml library is not available" << std::endl;
    return false;
#endif
}

std::vector<TelemetryDB::PMTRecord> TelemetryDB::lookup(const std::string & name)
{
    std::vector<PMTRecord> result;
    for (auto & record : records)
    {
        if (record.fullName.find(name) != std::string::npos)
        {
            result.push_back(record);
        }
    }
    return result;
}

std::vector<TelemetryDB::PMTRecord> TelemetryDB::ilookup(const std::string & name)
{
    std::vector<PMTRecord> result;
    auto to_lower = [](const std::string & s) -> std::string
    {
        std::string result;
        for (auto c : s)
        {
            result.push_back(std::tolower(c));
        }
        return result;
    };
    for (auto & record : records)
    {
        if (to_lower(record.fullName).find(to_lower(name)) != std::string::npos)
        {
            result.push_back(record);
        }
    }
    return result;
}


}; // namespace pcm
```

`src/pmt.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2024, Intel Corporation

#pragma once

#include "types.h"
#include <memory>
#include <vector>

namespace pcm {

class TelemetryArrayInterface
{
public:
    virtual size_t size() = 0; // in bytes
    virtual size_t numQWords()
    {
        return size() / sizeof(uint64);
    }
    virtual void load() = 0;
    virtual uint64 get(size_t qWordOffset, size_t lsb, size_t msb) = 0;
    virtual ~TelemetryArrayInterface() {};
};

class TelemetryArray : public TelemetryArrayInterface
{
    TelemetryArray() = delete;
    std::shared_ptr<TelemetryArrayInterface> impl;
public:
    TelemetryArray(const size_t /* uid */, const size_t /* instance */);
    static size_t numInstances(const size_t /* uid */);
    static std::vector<size_t> getUIDs();
    virtual ~TelemetryArray() override;
    size_t size() override; // in bytes
    void load() override;
    uint64 get(size_t qWordOffset, size_t lsb, size_t msb) override;
};

class TelemetryDB
{
public:
    struct PMTRecord
    {
        size_t uid;
        std::string fullName;
        std::string sampleType;
        size_t qWordOffset;
        uint32 lsb;
        uint32 msb;
        std::string description;
        void print(std::ostream & os) const
        {
            os << "uid: " << uid << " fullName: " << fullName << " description: \"" << description <<
                "\" sampleType: " << sampleType << " qWordOffset: " << qWordOffset << " lsb: " << lsb << " msb: " << msb << std::endl;
        }
    };
    std::vector<PMTRecord> records;
    TelemetryDB() = default;
    bool loadFromXML(const std::string& pmtXMLPath);
    virtual ~TelemetryDB() = default;
    std::vector<PMTRecord> lookup(const std::string & name);
    std::vector<PMTRecord> ilookup(const std::string & name);
};

} // namespace pcm
```

`src/readmem.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev
//

#include "cpucounters.h"
#include <iostream>
#include <algorithm>
#include <list>
#include <vector>
#include <sys/time.h>

using std::cout;

inline double my_timestamp()
{
    struct timeval tp;
    gettimeofday(&tp, NULL);
    return double(tp.tv_sec) + tp.tv_usec / 1000000.;
}

struct T
{
    int key[1] = { 0 };
    int data[15] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

    T() { }
    T(int a) { key[0] = a; }

    bool operator == (const T & k) const
    {
        return k.key[0] == key[0];
    }
};

template <class DS>
void Memory_intensive_task(DS & ds)
{
    // cppcheck-suppress ignoredReturnValue
    std::find(ds.begin(), ds.end(), ds.size());
}


int main(int argc, char * argv[])
{
    std::vector<T> vector;
    int nelements = 13000000;

    int i = 0;
    int delay = atoi(argv[1]);

    cout << "Elements data size: " << sizeof(T) * nelements / 1024 << " KB\n";

    for ( ; i < nelements; ++i)
    {
        vector.push_back(i);
    }

    double before_ts, after_ts;


    while (1)
    {
        before_ts = my_timestamp();
        cout << "Reading memory for " << delay << " seconds\n" << flush;
        do
        {
            Memory_intensive_task(vector);
            after_ts = my_timestamp();
        } while ((after_ts - before_ts) < delay);


        cout << "Sleeping for " << delay << " seconds\n" << flush;
        sleep(delay);
    }


    return 0;
}

```

`src/realtime.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev
//

#include "cpucounters.h"
#include "cpuasynchcounter.h"
#include <iostream>
#include <list>
#include <vector>
#include <algorithm>
#include <sys/time.h>

/*!     \file realtime.cpp
        \brief Two use-cases: realtime data structure performance analysis and memory-bandwidth aware scheduling
*/

using std::cout;

inline double my_timestamp()
{
    struct timeval tp;
    gettimeofday(&tp, NULL);
    return double(tp.tv_sec) + tp.tv_usec / 1000000.;
}

long long int fib(long long int num)
{
    long long int result = 1, a = 1, b = 1;

    for (long long int i = 3; i <= num; ++i)
    {
        result = a + b;
        a = b;
        b = result;
    }

    return result;
}

SystemCounterState before_sstate, after_sstate;
double before_time, after_time;

AsynchronCounterState counters;

long long int all_fib = 0;


void CPU_intensive_task()
{
    cout << "CPU task\n";
    all_fib += fib(80000000ULL + (rand() % 2));
}


template <class DS>
void Memory_intensive_task(DS & ds)
{
    cout << "Mem task\n";
    // cppcheck-suppress ignoredReturnValue
    std::find(ds.begin(), ds.end(), ds.size());
}

double currentMemoryBandwidth()
{
    return (counters.getSystem<uint64, ::getBytesReadFromMC>() + counters.getSystem<uint64, ::getBytesWrittenToMC>()) / (1024 * 1024);
}

template <class DS>
void measure(DS & ds, size_t repeat, size_t nelements)
{
    SystemCounterState before_sstate, after_sstate;
    double before_ts = 0.0, after_ts;

    // warm up
    // cppcheck-suppress ignoredReturnValue
    std::find(ds.begin(), ds.end(), nelements);

    double before1_ts;
#if 0
    for (int kkk = 1000; kkk > 0; --kkk)
    {
        ::sleep(1);
        before1_ts = my_timestamp();

        // start measuring
        before_sstate = getSystemCounterState();
        before_ts = my_timestamp();

        cout << "Response time of getSystemCounterState(): " << 1000. * (before_ts - before1_ts) << " ms\n";
    }
#endif

    // cppcheck-suppress ignoredReturnValue
    for (int j = 0; j < repeat; ++j) std::find(ds.begin(), ds.end(), nelements);

    // stop measuring
    after_sstate = getSystemCounterState();
    after_ts = my_timestamp();


    cout << "\nSearch runtime: " << ((after_ts - before_ts) * 1000. / repeat) << " ms \n";
    cout << "Search runtime per element: " << ((after_ts - before_ts) * 1000000000. / repeat) / nelements << " ns \n";

    cout << "Number of L2 cache misses per 1000 elements: "
         << (1000. * getL2CacheMisses(before_sstate, after_sstate) / repeat) / nelements <<
        " \nL2 Cache hit ratio : " << getL2CacheHitRatio(before_sstate, after_sstate) * 100. << " %\n";


    cout << "Number of L3 cache misses per 1000 elements: "
         << (1000. * getL3CacheMisses(before_sstate, after_sstate) / repeat) / nelements <<
        " \nL3 Cache hit ratio : " << getL3CacheHitRatio(before_sstate, after_sstate) * 100. << " %\n";

    cout << "Bytes written to memory controller per element: " <<
    (double(getBytesWrittenToMC(before_sstate, after_sstate)) / repeat) / nelements << "\n";

    cout << "Bytes read from memory controller per element : " <<
    (double(getBytesReadFromMC(before_sstate, after_sstate)) / repeat) / nelements << "\n";


    cout << "Used memory bandwidth: " <<
    ((getBytesReadFromMC(before_sstate, after_sstate) + getBytesWrittenToMC(before_sstate, after_sstate)) / (after_ts - before_ts)) / (1024 * 1024) << " MByte/sec\n";

    cout << "Instructions retired: " << getInstructionsRetired(before_sstate, after_sstate) / 1000000 << "mln\n";

    cout << "CPU cycles: " << getCycles(before_sstate, after_sstate) / 1000000 << "mln\n";

    cout << "Instructions per cycle: " << getCoreIPC(before_sstate, after_sstate) << "\n";
    cout << flush;
}

#if 0
typedef int T;

#else

struct T
{
    int key[1] = { 0 };
    int data[15] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };;

    T() { }
    T(int a) { key[0] = a; }

    bool operator == (const T & k) const
    {
        return k.key[0] == key[0];
    }
};

#endif

int main(int argc, char * argv[])
{
    PCM * m = PCM::getInstance();

    if (!m->good())
    {
        cout << "Can not access CPU counters\n";
        cout << "Try to execute 'modprobe msr' as root user and then\n";
        cout << "you also must have read and write permissions for /dev/cpu/?/msr devices (the 'chown' command can help).";
        return -1;
    }

    if (m->program() != PCM::Success) {
        cout << "Program was not successful...\n";
        deleteAndNullify(m);
        return -1;
    }

    int nelements = atoi(argv[1]);


#if 1 /* use-case: compare data structures in real-time */
    std::list<T> list;
    std::vector<T> vector;
    int i = 0;

    for ( ; i < nelements; ++i)
    {
        list.push_back(i);
        vector.push_back(i);
    }


    unsigned long long int totalops = 200000ULL * 1000ULL * 64ULL / sizeof(T);
    int repeat = totalops / nelements, j;

    cout << "\n\nElements to traverse: " << totalops << "\n";
    cout << "Items in data structure: " << nelements << "\n";
    cout << "Elements data size: " << sizeof(T) * nelements / 1024 << " KB\n";
    cout << "Test repetitions: " << repeat << "\n";

    cout << "\n*List data structure*\n";
    measure(list, repeat, nelements);

    cout << "\n\n*Vector/array data structure*\n";
    measure(vector, repeat, nelements);

#else
    /* use-case: memory bandwidth-aware scheduling */

    std::vector<T> vector;
    nelements = 13000000;

    int i = 0;

    cout << "Elements data size: " << sizeof(T) * nelements / 1024 << " KB\n";

    for ( ; i < nelements; ++i)
    {
        vector.push_back(i);
    }

    double before_ts, after_ts;

    before_ts = my_timestamp();
    {
        int m_tasks = 1000;
        int c_tasks = 1000;
        while (m_tasks + c_tasks != 0)
        {
            if (m_tasks > 0)
            {
                Memory_intensive_task(vector);
                --m_tasks;
                continue;
            }

            if (c_tasks > 0)
            {
                CPU_intensive_task();
                --c_tasks;
            }
        }
    }
    after_ts = my_timestamp();

    cout << "In order scheduling, Running time: " << (after_ts - before_ts) << " seconds\n";


    before_ts = my_timestamp();
    {
        int m_tasks = 1000;
        int c_tasks = 1000;
        while (m_tasks + c_tasks != 0)
        {
            double band = currentMemoryBandwidth();
            //cout << "Mem band: " << band << " MB/sec\n";
            if (m_tasks > 0 && (band < (25 * 1024 /* MB/sec*/)
                                || c_tasks == 0))
            {
                Memory_intensive_task(vector);
                --m_tasks;
                continue;
            }

            if (c_tasks > 0)
            {
                CPU_intensive_task();
                --c_tasks;
                continue;
            }
        }
    }

    after_ts = my_timestamp();

    cout << "CPU monitoring conscoius scheduling, Running time: " << (after_ts - before_ts) << " seconds\n";

#endif
    m->cleanup();

    return 0;
}

```

`src/resctrl.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2020-2022, Intel Corporation
// written by Roman Dementiev

#ifdef __linux__

#include "resctrl.h"
#include "cpucounters.h"
#include <sys/stat.h>
#include <sys/types.h>
#include <string>
#include <iostream>
#include <cstdlib>

namespace pcm
{
    bool Resctrl::isMounted()
    {
        struct stat st;
        if (stat("/sys/fs/resctrl/mon_groups", &st) < 0)
        {
            return false;
        }
        return true;
    }
    void Resctrl::init()
    {
        if (isMounted() == false)
        {
            std::cerr << "ERROR: /sys/fs/resctrl is not mounted\n";
            std::cerr << "ERROR: RDT metrics (L3OCC,LMB,RMB) will not be available\n";
            std::cerr << "Mount it to make it work: mount -t resctrl resctrl /sys/fs/resctrl\n";
            return;
        }
        const auto numCores = pcm.getNumCores();
        for (unsigned int c = 0; c < numCores; ++c)
        {
            if (pcm.isCoreOnline(c))
            {
                const auto C = std::to_string(c);
                const auto dir = std::string(PCMPath) + C;
                struct stat st;
                if (stat(dir.c_str(), &st) < 0 && mkdir(dir.c_str(), 0700) < 0)
                {
                    std::cerr << "INFO: can't create directory " << dir << " error: " << strerror(errno) << "\n";
                    const auto containerDir = std::string("/pcm") + dir;
                    if (stat(containerDir.c_str(), &st) < 0 && mkdir(containerDir.c_str(), 0700) < 0)
                    {
                        std::cerr << "INFO: can't create directory " << containerDir << " error: " << strerror(errno) << "\n";
                        std::cerr << "ERROR: RDT metrics (L3OCC,LMB,RMB) will not be available\n";
                        break;
                    }
                }
                const auto cpus_listFilename = dir + "/cpus_list";
                writeSysFS(cpus_listFilename.c_str(), C, false);
                auto generateMetricFiles = [&dir, c] (PCM & pcm, const std::string & metric, FileMapType & fileMap)
                {
                    auto getMetricFilename = [] (const std::string & dir, const uint64 s, const std::string & metric)
                    {
                        std::ostringstream ostr;
                        ostr << dir << "/mon_data/mon_L3_" << std::setfill('0') << std::setw(2) << s << "/" << metric;
                        return ostr.str();
                    };
                    for (uint64 s = 0; s < pcm.getNumSockets(); ++s)
                    {
                        fileMap[c].push_back(getMetricFilename(dir, s, metric));
                    }
                };
                if (pcm.L3CacheOccupancyMetricAvailable())
                {
                    generateMetricFiles(pcm, "llc_occupancy", L3OCC);
                }
                if (pcm.CoreLocalMemoryBWMetricAvailable())
                {
                    generateMetricFiles(pcm, "mbm_local_bytes", MBL);
                }
                if (pcm.CoreRemoteMemoryBWMetricAvailable())
                {
                    generateMetricFiles(pcm, "mbm_total_bytes", MBT);
                }
            }
        }
    }
    void Resctrl::cleanup()
    {
        const auto numCores = pcm.getNumCores();
        for (unsigned int c = 0; c < numCores; ++c)
        {
            if (pcm.isCoreOnline(c))
            {
                const auto dir = std::string(PCMPath) + std::to_string(c);
                rmdir(dir.c_str());
                const auto containerDir = std::string("/pcm") + dir;
                rmdir(containerDir.c_str());
            }
        }
    }
    size_t Resctrl::getMetric(const Resctrl::FileMapType & fileMap, int core)
    {
        auto files = fileMap.find(core);
        if (files == fileMap.end())
        {
            return 0ULL;
        }
        size_t result = 0;
        for (auto& f : files->second)
        {
            const auto data = readSysFS(f.c_str(), false);
            if (data.empty() == false)
            {
                result += atoll(data.c_str());
            }
            else
            {
                static std::mutex lock;
                std::lock_guard<std::mutex> _(lock);
                std::cerr << "Error reading " << f << ". Error: " << strerror(errno) << "\n";
                if (errno == 24)
                {
                    std::cerr << PCM_ULIMIT_RECOMMENDATION;
                }
            }
        }
        return result;
    }
    size_t Resctrl::getL3OCC(int core)
    {
        return getMetric(L3OCC, core);
    }
    size_t Resctrl::getMBL(int core)
    {
        return getMetric(MBL, core);
    }
    size_t Resctrl::getMBT(int core)
    {
        return getMetric(MBT, core);
    }
};

 #endif // __linux__

```

`src/resctrl.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2020-2022, Intel Corporation
// written by Roman Dementiev

#pragma once

/*!     \file resctrl.h
        \brief interface to MBM and CMT using Linux resctrl
  */

#ifdef __linux__

#include <stdlib.h>
#include <stdio.h>
#include <unordered_map>
#include <vector>
#include <mutex>
#include <memory>

namespace pcm
{
    class PCM;

    class Resctrl
    {
        PCM & pcm;
        typedef std::unordered_map<int, std::vector<std::string> > FileMapType;
        FileMapType L3OCC, MBL, MBT;
        Resctrl() = delete;
        size_t getMetric(const FileMapType & fileMap, int core);
        static constexpr auto PCMPath = "/sys/fs/resctrl/mon_groups/pcm";
    public:
        Resctrl(PCM & m) : pcm(m) {}
        bool isMounted();
        void init();
        size_t getL3OCC(int core);
        size_t getMBL(int core);
        size_t getMBT(int core);
        void cleanup();
    };
};

 #endif // __linux__

```

`src/threadpool.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2020-2022, Intel Corporation

#include "threadpool.h"
#include "utils.h"

namespace pcm {

void ThreadPool::execute( ThreadPool* tp ) {
    while( 1 ) {
        Work* w = tp->retrieveWork();
        if ( w == nullptr ) break;
        w->execute();
        // There can never be a double delete here, once taken from the tp it is owned by this thread
        // but in order to silence cppcheck w is set explicitly to null
        deleteAndNullify( w );
        DBG( 5, "Work deleted, waiting for more work..." );
    }
    DBG( 4, "Thread is explicitly dying now..." );
}

} // namespace pcm

```

`src/threadpool.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2020-2022, Intel Corporation

#pragma once

#include "debug.h"

#include <thread>
#include <future>
#include <functional>
#include <mutex>
#include <condition_variable>
#include <queue>

namespace pcm {

class Work {
public:
    Work() {}
    virtual ~Work() {}
    virtual void execute() = 0;
};

template<class ReturnType>
class LambdaJob : public Work {
public:
    template<class F, class ... Args>
    LambdaJob( F&& f, Args&& ... args )
        //: task_( std::forward<F>(f)(std::forward<Args>( args )... ) ) {
        : task_(std::bind( f, args... ) ) {
    }

    virtual void execute() override {
        task_();
    }

    std::future<ReturnType> getFuture() {
        return task_.get_future();
    }

private:
    std::packaged_task<ReturnType()> task_;
};

class WorkQueue;

class ThreadPool {
private:
    ThreadPool( const int n ) {
        for ( int i = 0; i < n; ++i )
            addThread();
    }

    ThreadPool( ThreadPool const& ) = delete;
    ThreadPool & operator = ( ThreadPool const& ) = delete;

public:
    void emptyThreadPool( void ) {
        try {
            for (size_t i = 0; i < threads_.size(); ++i)
                addWork(nullptr);
            for (size_t i = 0; i < threads_.size(); ++i)
                threads_[i].join();
            threads_.clear();
        }
        catch (const std::exception& e)
        {
            std::cerr << "PCM Error. Exception in ThreadPool::~ThreadPool: " << e.what() << "\n";
        }
    }

    ~ThreadPool() {
        DBG( 5, "Threadpool is being deleted..." );
        emptyThreadPool();
    }

public:
    static ThreadPool& getInstance() {
        static ThreadPool tp_(64);
        return tp_;
    }

    void addWork( Work* w ) {
        DBG( 5, "WQ: Adding work" );
        std::lock_guard<std::mutex> lg( qMutex_ );
        workQ_.push( w );
        queueCV_.notify_one();
        DBG( 5, "WQ: Work available" );
    }

    Work* retrieveWork() {
        DBG( 5, "WQ: Retrieving work" );
        std::unique_lock<std::mutex> lock( qMutex_ );
        queueCV_.wait( lock, [this]{ return !workQ_.empty(); } );
        Work* w = workQ_.front();
        workQ_.pop();
        lock.unlock();
        DBG( 5, "WQ: Work retrieved" );

        return w;
    }

private:
    void addThread() {
        try {
            threads_.push_back( std::thread( std::bind( &this->execute, this ) ) );
        } catch (const std::exception& e) {
            std::cerr << "PCM Error. Exception in ThreadPool::addThread: " << e.what()
                      << ". Possible causes: insufficient system resources, thread limit reached, or invalid thread function."
                      << " Suggested actions: check system resource availability, verify thread pool configuration, and ensure the thread function is valid.\n";
            throw;
        }
    }

    // Executes work items from a std::thread, do not call manually
    static void execute( ThreadPool* );

private:
    std::vector<std::thread> threads_;
    std::queue<Work*> workQ_;
    std::mutex qMutex_;
    std::condition_variable queueCV_;
};

class WorkQueue {
private:
    WorkQueue( size_t init ) : tp_( ThreadPool::getInstance() ), workProcessed_( init ) {
        DBG( 5, "Constructing WorkQueue..." );
    }
    WorkQueue( WorkQueue const& ) = delete;
    WorkQueue & operator = ( WorkQueue const& ) = delete;

public:
    ~WorkQueue() {
        DBG( 5, "Destructing WorkQueue..." );
    }

public:
    static WorkQueue* getInstance() {
        static WorkQueue wq_( 0 );
        return &wq_;
    }
    // Just forwarding to the threadpool
    void addWork( Work* w ) {
        ++workProcessed_;
        tp_.addWork( w );
    }

private:
    ThreadPool& tp_;
    size_t workProcessed_;
};

} // namespace pcm

```

`src/topology.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2016-2022, Intel Corporation

#include "topology.h"
#include "pcm-accel-common.h"

namespace pcm {

UncoreCounterState ServerUncore::uncoreCounterState( void ) const
{
    UncoreCounterState ucs;
    // Fill the ucs
    PCM* pcm = PCM::getInstance();
    pcm->readAndAggregateUncoreMCCounters( socketID(), ucs );
    pcm->readAndAggregateEnergyCounters( socketID(), ucs );
    pcm->readAndAggregatePackageCStateResidencies( refCore()->msrHandle(), ucs );

    return ucs;
}

UncoreCounterState ClientUncore::uncoreCounterState( void ) const
{
    UncoreCounterState ucs;
    // Fill the ucs
    PCM* pcm = PCM::getInstance();
    pcm->readAndAggregateUncoreMCCounters( socketID(), ucs );
    pcm->readAndAggregateEnergyCounters( socketID(), ucs );
    pcm->readAndAggregatePackageCStateResidencies( refCore()->msrHandle(), ucs );

    return ucs;
}

Socket::Socket( PCM* m, int32 logicalID )
    : pcm_(m), refCore_(nullptr), logicalID_(logicalID)
{
    if ( pcm_->isServerCPU() )
        uncore_ = new ServerUncore( pcm_, logicalID );
    else if ( pcm_->isClientCPU() )
        uncore_ = new ClientUncore( pcm_, logicalID );
    else
        throw std::runtime_error( "ERROR: Neither a client nor a server part, please fix the code!" );
}

SocketCounterState Socket::socketCounterState( void ) const {
    SocketCounterState scs;
    // Fill the scs
    // by iterating the cores
    for( auto& core : cores_ ) {
        scs.BasicCounterState::operator += ( core->coreCounterState() );
    }
    // and the uncore
    scs.UncoreCounterState::operator += ( uncore_->uncoreCounterState() );
    PCM::getInstance()->readPackageThermalHeadroom( socketID(), scs );
    return scs;
}

void Aggregator::dispatch( SystemRoot const& syp ) {
    // std::cerr << "Aggregator::dispatch( SystemRoot )\n";
    dispatchedAt_ = std::chrono::steady_clock::now();
    // CoreCounterStates are fetched asynchronously here
    for ( auto* socket : syp.sockets() )
        socket->accept( *this );
    // Dispatching offlined cores
    for ( auto* htp : syp.offlinedThreadsAtStart() )
        htp->accept( *this );

    auto ccsFuturesIter = ccsFutures_.begin();
    auto ccsIter = ccsVector_.begin();
    // int i;
    // i = 0;
    for ( ; ccsFuturesIter != ccsFutures_.end() && ccsIter != ccsVector_.end(); ++ccsFuturesIter, ++ccsIter ) {
        // std::cerr << "Works ccsFuture: " << ++i << "\n";
        (*ccsIter) = (*ccsFuturesIter).get();
    }

    // Aggregate BasicCounterStates
    for ( auto* socket : syp.sockets() ) {
        for ( auto* core : socket->cores() )
            for ( auto* thread : core->threads() )
                socsVector_[ socket->socketID() ] += ( ccsVector_[ thread->osID() ] );
        // UncoreCounterStates have not been filled here so it is ok to add
        // the entire SocketCounterState here
        sycs_ += socsVector_[ socket->socketID() ];
    }

    // Fetch and aggregate UncoreCounterStates
    auto ucsFuturesIter = ucsFutures_.begin();
    auto socsIter = socsVector_.begin();
    // i = 0;
    for ( ; ucsFuturesIter != ucsFutures_.end() && socsIter != socsVector_.end(); ++ucsFuturesIter, ++socsIter ) {
        // std::cerr << "Works ucsFuture: " << ++i << "\n";
        // Because we already aggregated the Basic/CoreCounterStates above, sycs_
        // only needs the ucs added here. If we would add socs to sycs we would
        // count all Basic/CoreCounterState counters double
        UncoreCounterState ucs = (*ucsFuturesIter).get();
        sycs_ += ucs;
        (*socsIter) = std::move( ucs );
    }
    PCM* pcm = PCM::getInstance();
    pcm->readQPICounters( sycs_ );
    pcm->readAndAggregateCXLCMCounters( sycs_ );
    readAccelCounters(sycs_);
}

bool TopologyStringCompare( const std::string& topology1, const std::string& topology2 ) {
    if ( topology1.size() == 0 ) return true;
    if ( topology2.size() == 0 ) return false;

    int topo1asint, topo2asint;
    std::stringstream ss1(topology1);
    std::stringstream ss2(topology2);
    ss1 >> topo1asint;
    ss2 >> topo2asint;
    return topo1asint < topo2asint;
}

}// namespace pcm

```

`src/topology.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// 2016-2020, Intel Corporation

#pragma once

#include <vector>
#include <string>
#include <algorithm>
#include <future>

#include "types.h"
#include "cpucounters.h"
#include "threadpool.h"

namespace pcm {

// all can be done with forwards, anything hat actually uses PCM should be put in the topology.cpp file
class PCM;

class SystemRoot;
class Socket;
class Core;
class HyperThread;
class ServerUncore;
class ClientUncore;

class Visitor {
public:
    Visitor() {
        // Set the floatingpoint format to fixed. Setting the number of decimal digits to 3.
        ss << std::fixed << std::setprecision(3);
    }

    Visitor(const Visitor &) = delete;
    Visitor & operator = (const Visitor &) = delete;

public:
    virtual void dispatch( SystemRoot const & ) = 0;
    virtual void dispatch( Socket* )        = 0;
    virtual void dispatch( Core* )          = 0;
    virtual void dispatch( HyperThread* )   = 0;
    virtual void dispatch( ServerUncore* )  = 0;
    virtual void dispatch( ClientUncore* )  = 0;

    virtual ~Visitor() {};

protected:
    std::stringstream ss{};
};

class SystemObject
{
public:
    virtual void accept( Visitor & v ) = 0;
    virtual ~SystemObject() {};
};

enum Status {
    Offline = 0,
    Online = 1
};

class HyperThread : public SystemObject
{
public:
    HyperThread( PCM* m, int32 osID, TopologyEntry te, enum Status status ) : pcm_(m), osID_(osID), te_(te), status_(status) {}
    virtual ~HyperThread() { pcm_ = nullptr; }

    virtual void accept( Visitor& v ) override {
        v.dispatch( this );
    }

    CoreCounterState coreCounterState() const {
        CoreCounterState ccs;
        // fill ccs
        ccs.BasicCounterState::readAndAggregate( msrHandle_ );
        return ccs;
    }

    std::string topologyDataString() const {
        std::stringstream ss;
        ss << osID_ << "\t" << te_.socket_id << "\t" << te_.die_grp_id << "\t" << te_.die_id << "\t" << te_.tile_id << "\t" << te_.core_id << "\t" << te_.thread_id << "\t";
        return ss.str();
    }

    TopologyEntry topologyEntry() const {
        return te_;
    }

    void addMSRHandle( std::shared_ptr<SafeMsrHandle> handle ) {
        msrHandle_ = handle;
    }

    int32 osID() const {
        return osID_;
    }

    int32 threadID() const {
        return te_.thread_id;
    }

    int32 coreID() const {
        return te_.core_id;
    }

    int32 moduleID() const {
        return te_.module_id;
    }

    int32 tileID() const {
        return te_.tile_id;
    }

    int32 dieID() const {
        return te_.die_id;
    }

    int32 dieGroupID() const {
        return te_.die_grp_id;
    }

    int32 socketID() const {
        return te_.socket_id;
    }

    int32 socketUniqueCoreID() const {
        return te_.socket_unique_core_id;
    }

    // We simply pass by value, this way the refcounting works best and as expected
    std::shared_ptr<SafeMsrHandle> msrHandle() const {
        return msrHandle_;
    }

    bool isOnline() const {
        return (status_ == Status::Online);
    }

private:
    PCM*                           pcm_;
    std::shared_ptr<SafeMsrHandle> msrHandle_;
    // osID is the expected osID, offlined cores have te.os_id == -1
    int32                          osID_;
    TopologyEntry                  te_;
    enum Status                    status_;
};

class Core : public SystemObject
{
public:
    Core( PCM* m ) : pcm_(m) {
        // PCM* m is not 0, we're being called from the PCM constructor
        // Just before this Core object is constructed, the value for
        // threads_per_core is determined
        MAX_THREADS_PER_CORE = pcm_->getThreadsPerCore();
    }
    virtual ~Core() {
        pcm_ = nullptr;
        for ( auto& thread : threads_ )
            deleteAndNullify(thread);
    }

    virtual void accept( Visitor& v ) override {
        v.dispatch( this );
    }

    CoreCounterState coreCounterState() const {
        CoreCounterState ccs;
        // Fill bcs
        for ( HyperThread* thread : threads_ ) {
            ccs += thread->coreCounterState();
        }
        return ccs;
    }

    void addHyperThreadInfo( int32 osID, TopologyEntry te ) {
        if ( te.thread_id >= MAX_THREADS_PER_CORE ) {
            std::stringstream ss;
            ss << "ERROR: Core: thread_id " << te.thread_id << " cannot be larger than " << MAX_THREADS_PER_CORE << ".\n";
            throw std::runtime_error( ss.str() );
        }
        if ( threads_.size() == 0 ||
           std::find_if( threads_.begin(), threads_.end(),
                [osID]( HyperThread const * ht ) -> bool {
                    return ht->osID() == osID;
                }
           ) == threads_.end() )
        {
            // std::cerr << "Core::addHyperThreadInfo: " << te.thread_id << ", " << te.os_id << "\n";
            threads_.push_back( new HyperThread( pcm_, osID, te, Status::Online ) );
        }
    }

    HyperThread* hyperThread( size_t threadNo ) const {
        if ( threadNo >= threads_.size() )
            throw std::runtime_error( "ERROR: hyperThread: threadNo larger than vector." );
        return threads_[ threadNo ];
    }

    HyperThread* findThreadByOSID( int32 osID ) {
        for ( HyperThread* thread : threads_ ) {
            if ( thread->osID() == osID )
                return thread;
        }
        return nullptr;
    }

    std::vector<HyperThread*> threads() const {
        return threads_;
    }

    std::shared_ptr<SafeMsrHandle> msrHandle() const {
        if ( 0 == threads_.size() )
            throw std::runtime_error("BUG: No threads yet but asking for a msrHandle!");
        return threads_.front()->msrHandle();
    }

    int32 coreID() const {
        if ( 0 == threads_.size() )
            throw std::runtime_error("BUG: No threads yet but asking for a coreID!");
        return threads_.front()->coreID();
    }

    int32 moduleID() const {
        if ( 0 == threads_.size() )
            throw std::runtime_error("BUG: No threads yet but asking for a moduleID!");
        return threads_.front()->moduleID();
    }

    int32 tileID() const {
        if ( 0 == threads_.size() )
            throw std::runtime_error("BUG: No threads yet but asking for a tileID!");
        return threads_.front()->tileID();
    }

    int32 dieID() const {
        if ( 0 == threads_.size() )
            throw std::runtime_error("BUG: No threads yet but asking for a tileID!");
        return threads_.front()->dieID();
    }

    int32 dieGroupID() const {
        if ( 0 == threads_.size() )
            throw std::runtime_error("BUG: No threads yet but asking for a tileID!");
        return threads_.front()->dieGroupID();
    }

    int32 socketID() const {
        if ( 0 == threads_.size() )
            throw std::runtime_error("BUG: No threads yet but asking for a socketID!");
        return threads_.front()->socketID();
    }

    int32 socketUniqueCoreID() const {
        if ( 0 == threads_.size() )
            throw std::runtime_error("BUG: No threads yet but asking for a socketID!");
        return threads_.front()->socketUniqueCoreID();
    }

    bool isOnline() const {
        for( auto& thread : threads_ )
            if ( thread->isOnline() )
                return true;
        return false;
    }

private:
    PCM*                      pcm_;
    std::vector<HyperThread*> threads_;
    int32                     MAX_THREADS_PER_CORE;
};

class Uncore : public SystemObject
{
public:
    Uncore( PCM* m, int32 socketID ) : pcm_( m ), refCore_( nullptr ), socketID_( socketID ) {}
    virtual ~Uncore() {
        pcm_ = nullptr;
        refCore_ = nullptr;
    }

    virtual void accept( Visitor& v ) = 0;

    virtual UncoreCounterState uncoreCounterState( void ) const = 0;

    Core* refCore() const {
        if ( refCore_ == nullptr )
            throw std::runtime_error( "BUG: Uncore: refCore was never set!" );
        return refCore_;
    }

    int32 socketID() const {
        return socketID_;
    }

    void setRefCore( Core* refCore ) {
        refCore_ = refCore;
    }

private:
    PCM*  pcm_;
    Core* refCore_;
    int32 socketID_;
};

class ServerUncore : public Uncore
{
public:
    ServerUncore( PCM* m, int32 socketID ) : Uncore( m, socketID ) {}
    virtual ~ServerUncore() {}

    virtual void accept( Visitor& v ) override {
        v.dispatch( this );
    }

    virtual UncoreCounterState uncoreCounterState( void ) const override;
};

class ClientUncore : public Uncore
{
public:
    ClientUncore( PCM* m, int32 socketID ) : Uncore( m, socketID ) {}
    virtual ~ClientUncore() {}

    virtual void accept( Visitor& v ) override {
        v.dispatch( this );
    }

    virtual UncoreCounterState uncoreCounterState( void ) const override;
};

class Socket : public SystemObject {
    Socket(const Socket &) = delete;
    Socket & operator = (const Socket &) = delete;
public:
    Socket( PCM* m, int32 logicalID );
    virtual ~Socket() {
        pcm_ = nullptr;
        refCore_ = nullptr; // cores_ is owner, set it to null before deleting it one below
        for ( auto& core : cores_ )
            deleteAndNullify(core);
        deleteAndNullify(uncore_);
    }

    virtual void accept( Visitor& v ) override {
        v.dispatch( this );
    }

    void addCore( Core* c ) {
        cores_.push_back( c );
    }

    HyperThread* findThreadByOSID( int32 osID ) {
        HyperThread* thread;
        for ( Core* core : cores_ ) {
            thread = core->findThreadByOSID(osID);
            if ( nullptr != thread )
                return thread;
        }
        return nullptr;
    }

    void setRefCore() {
        if ( cores_.size() == 0 )
            throw std::runtime_error("No cores added to the socket so cannot set reference core");
        refCore_ = cores_.front();
        // uncore_ cannot be null, it is set in the constructor
        uncore_->setRefCore( refCore_ );
    }

    SocketCounterState socketCounterState( void ) const;

    Core* findCoreByTopologyEntry( TopologyEntry te ) {
        for ( auto& core : cores_ )
            if ( core->hyperThread( 0 )->topologyEntry().isSameCore( te ) )
                return core;
        return nullptr;
    }

    std::vector<Core*> const & cores( void ) const {
        return cores_;
    }

    Uncore* uncore( void ) const {
        return uncore_;
    }

    int32 socketID() const {
        return logicalID_;
    }

    bool isOnline() const {
        return refCore_->isOnline();
    }

private:
    std::vector<Core*> cores_;
    PCM*    pcm_;
    Core*   refCore_;
    Uncore* uncore_;
    int32   logicalID_;
};

class SystemRoot : public SystemObject {
public:
    SystemRoot(PCM * p) : pcm_(p) {}

    SystemRoot( SystemRoot const & ) = delete; // do not try to copy this please
    SystemRoot & operator = ( SystemRoot const & ) = delete; // do not try to copy this please

    virtual ~SystemRoot() {
        pcm_ = nullptr;
        for ( auto& socket : sockets_ )
            deleteAndNullify(socket);
        for ( auto& thread : offlinedThreadsAtStart_ )
            deleteAndNullify(thread);
    }

    virtual void accept( Visitor& v ) override {
        v.dispatch( *this );
    }

    void addSocket( int32 logical_id ) {
        Socket* s = new Socket( pcm_, logical_id );
        sockets_.push_back( s );
    }

    // osID is the expected os_id, this is used in case te.os_id = -1 (offlined core)
    void addThread( int32 osID, TopologyEntry& te ) {
        // std::cerr << "SystemRoot::addThread: coreid: " << te.core_id <<  ", module_id: " << te.module_id << ", tile_id: " << te.tile_id << ", die_id: " << te.die_id << ", die_grp_id: " << te.die_grp_id << ", socket_id: " << te.socket_id << ", os_id: " << osID << "\n";
        // quick check during development to see if expected osId == te.os_id for onlined cores
        // assert( te.os_id != -1 && osID == te.os_id );
        bool entryAdded = false;
        for ( auto& socket : sockets_ ) {
            if ( socket->socketID() == te.socket_id ) {
                Core* core = nullptr;
                if ( (core = socket->findCoreByTopologyEntry( te )) == nullptr ) {
                    core = new Core( pcm_ );
                    // std::cerr << "new Core ThreadID: " << te.thread_id << "\n";
                    core->addHyperThreadInfo( osID, te );
                    socket->addCore( core );
                    // std::cerr << "Added core " << te.core_id << " with os_id " << osID << ", threadid " << te.thread_id << " and tileid " << te.tile_id << " to socket " << te.socket_id << ".\n";
                } else {
                    // std::cerr << "existing Core ThreadID: " << te.thread_id << "\n";
                    core->addHyperThreadInfo( osID, te );
                    // std::cerr << "Augmented core " << te.core_id << " with osID " << osID << " and threadid " << te.thread_id << " for the hyperthread to socket " << te.socket_id << ".\n";
                }
                entryAdded = true;
                break;
            }
        }
        if ( !entryAdded ) {
            // if ( te.os_id == -1 )
            //     std::cerr << "TE not added because os_id == -1, core is offline\n";
            offlinedThreadsAtStart_.push_back( new HyperThread( pcm_, osID, te, Status::Offline ) );
        }
    }

    HyperThread* findThreadByOSID( int32 osID ) {
        HyperThread* thread;
        for ( Socket* socket : sockets_ ) {
            thread = socket->findThreadByOSID( osID );
            if ( nullptr != thread )
                return thread;
        }
        for ( HyperThread* ht: offlinedThreadsAtStart_ )
            if ( ht->osID() == osID )
                return ht;
        return nullptr;
    }

    void addMSRHandleToOSThread( std::shared_ptr<SafeMsrHandle> handle, uint32 osID )
    {
        // std::cerr << "addMSRHandleToOSThread: osID: " << osID << "\n";
        HyperThread* thread = findThreadByOSID( osID );
        if ( nullptr == thread )
            throw std::runtime_error( "SystemRoot::addMSRHandleToOSThread osID not found" );
        thread->addMSRHandle( handle );
    }

    SystemCounterState systemCounterState() const {
        SystemCounterState scs;
        // Fill scs
        // by iterating the sockets
        for ( auto& socket : sockets_ ) {
            scs += ( socket->socketCounterState() );
        }
        return scs;
    }

    std::vector<Socket*> const & sockets( void ) const {
        return sockets_;
    }

    std::vector<HyperThread*> const & offlinedThreadsAtStart( void ) const {
        return offlinedThreadsAtStart_;
    }

private:
    std::vector<Socket*>      sockets_;
    std::vector<HyperThread*> offlinedThreadsAtStart_;
    PCM*                      pcm_;
};


/* Method used here: while walking the tree and iterating the vector
 * elements, collect the counters. Once all elements have been walked
 * the vectors contain the aggregates.
 */
class Aggregator : Visitor
{
public:
    Aggregator() : wq_( WorkQueue::getInstance() )
    {
        PCM* const pcm = PCM::getInstance();
        // Resize user provided vectors to the right size
        ccsVector_.resize( pcm->getNumCores() );
        socsVector_.resize( pcm->getNumSockets() );
        // Internal use only, need to be the same size as the user provided vectors
        ccsFutures_.resize( pcm->getNumCores() );
        ucsFutures_.resize( pcm->getNumSockets() );
    }

    virtual ~Aggregator() {
        wq_ = nullptr;
    }

public:
    virtual void dispatch( SystemRoot const& syp ) override;

    virtual void dispatch( Socket* sop ) override {
        // std::cerr << "Aggregator::dispatch( Socket )\n";
        // Fetch CoreCounterStates
        for ( auto* core : sop->cores() )
            core->accept( *this );
        // Fetch UncoreCounterState async result
        auto job = new LambdaJob<UncoreCounterState>(
            []( Socket* s ) -> UncoreCounterState {
                DBG( 5, "Lambda fetching UncoreCounterState async" );
                UncoreCounterState ucs;
                if ( !s->isOnline() )
                    return ucs;
                return s->uncore()->uncoreCounterState();
            }, sop
        );
        ucsFutures_[ sop->socketID() ] = job->getFuture();
        wq_->addWork( job );
    }

    virtual void dispatch( Core* cop ) override {
        // std::cerr << "Aggregator::dispatch( Core )\n";
        // Loop each HyperThread
        for ( auto* thread : cop->threads() ) {
            // Fetch the CoreCounterState
            thread->accept( *this );
        }
    }

    virtual void dispatch( HyperThread* htp ) override {
        // std::cerr << "Aggregator::dispatch( HyperThread )\n";
        // std::cerr << "Dispatch htp with osID=" << htp->osID() << "\n";
        auto job = new LambdaJob<CoreCounterState>(
            []( HyperThread* h ) -> CoreCounterState {
                DBG( 5, "Lambda fetching CoreCounterState async" );
                CoreCounterState ccs;
                if ( !h->isOnline() )
                    return ccs;
                return h->coreCounterState();
            }, htp
        );
        ccsFutures_[ htp->osID() ] = job->getFuture();
        wq_->addWork( job );
    }

    virtual void dispatch( ServerUncore* /*sup*/ ) override {
        // std::cerr << "Aggregator::dispatch( ServerUncore )\n";
    }

    virtual void dispatch( ClientUncore* /*cup*/ ) override {
        // std::cerr << "Aggregator::dispatch( ClientUncore )\n";
    }

    std::vector<CoreCounterState>const & coreCounterStates( void ) const {
        return ccsVector_;
    }

    std::vector<SocketCounterState>const & socketCounterStates( void ) const {
        return socsVector_;
    }

    SystemCounterState const & systemCounterState( void ) const {
        return sycs_;
    }

    std::chrono::steady_clock::time_point dispatchedAt( void ) const {
        return dispatchedAt_;
    }

private:
    WorkQueue* wq_;
    std::vector<CoreCounterState> ccsVector_;
    std::vector<SocketCounterState> socsVector_;
    SystemCounterState sycs_;
    std::vector<std::future<CoreCounterState>> ccsFutures_;
    std::vector<std::future<UncoreCounterState>> ucsFutures_;
    std::chrono::steady_clock::time_point dispatchedAt_{};
};

/* Method used here: while walking the cores in the tree and iterating the
 * vector elements, print the core related ids into a large string. Once all
 * cores have been walked the vector of strings contains all ids.
 */
class TopologyPrinter : Visitor
{
public:
    TopologyPrinter() : wq_( WorkQueue::getInstance() )
    {
        PCM* const pcm = PCM::getInstance();
        // Resize user provided vectors to the right size
        threadIDsVector_.resize( pcm->getNumCores() );
        // Internal use only, need to be the same size as the user provided vectors
        threadIDsFutures_.resize( pcm->getNumCores() );
    }

    virtual ~TopologyPrinter() {
        wq_ = nullptr;
    }

public:
    virtual void dispatch( SystemRoot const& syp ) override {
        // std::cerr << "TopologyPrinter::dispatch( SystemRoot )\n";
        for ( auto* socket : syp.sockets() )
            socket->accept( *this );

        auto tidFuturesIter = threadIDsFutures_.begin();
        auto tidIter = threadIDsVector_.begin();
        // int i;
        // i = 0;
        for ( ; tidFuturesIter != threadIDsFutures_.end() && tidIter != threadIDsVector_.end(); ++tidFuturesIter, ++tidIter ) {
            // std::cerr << "Works tidFuture: " << ++i << "\n";
            (*tidIter) = (*tidFuturesIter).get();
        }
    }

    virtual void dispatch( Socket* sop ) override {
        // std::cerr << "TopologyPrinter::dispatch( Socket )\n";
        // Fetch Topology Data
        for ( auto* core : sop->cores() )
            core->accept( *this );
    }

    virtual void dispatch( Core* cop ) override {
        // std::cerr << "TopologyPrinter::dispatch( Core )\n";
        // Loop each HyperThread
        for ( auto* thread : cop->threads() ) {
            // Fetch the Topology Data
            thread->accept( *this );
        }
    }

    virtual void dispatch( HyperThread* htp ) override {
        // std::cerr << "TopologyPrinter::dispatch( HyperThread )\n";
        // std::cerr << "Dispatch htp with osID=" << htp->osID() << "\n";
        auto job = new LambdaJob<std::string>(
            []( HyperThread* h ) -> std::string {
                DBG( 5, "Lambda fetching Topology Data async" );
                std::string s;
                if ( !h->isOnline() )
                    return s;
                return h->topologyDataString();
            }, htp
        );
        threadIDsFutures_[ htp->osID() ] = job->getFuture();
        wq_->addWork( job );
    }

    virtual void dispatch( ServerUncore* /*sup*/ ) override {
        // std::cerr << "TopologyPrinter::dispatch( ServerUncore )\n";
    }

    virtual void dispatch( ClientUncore* /*cup*/ ) override {
        // std::cerr << "TopologyPrinter::dispatch( ClientUncore )\n";
    }

    std::vector<std::string> & topologyDataStrings( void ) {
        return threadIDsVector_;
    }

    std::chrono::steady_clock::time_point dispatchedAt( void ) const {
        return dispatchedAt_;
    }

private:
    WorkQueue* wq_;
    std::vector<std::string> threadIDsVector_;
    std::vector<std::future<std::string>> threadIDsFutures_;
    std::chrono::steady_clock::time_point dispatchedAt_{};
};

bool TopologyStringCompare( const std::string& topology1, const std::string& topology2 );

} // namespace pcm

```

`src/topologyentry.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2022-, Intel Corporation

#pragma once

#include "types.h"
#ifndef USER_KERNEL_SHARED
#include "debug.h"
#endif

namespace pcm
{

struct PCM_API TopologyEntry // describes a core
{
    /*
     * core_id is the hw specific physical core id that was introduced in newer generations, on
     * older generations this is the same as socket_unique_core_id.
     * socket_unique_core_id is like the name says a socket unique core id that is built out of the core_id, module_id, thread_id, die_id and die_grp_id.
     * With it, we have unique core ids inside a socket for keeping backward compatibility in the prometheus and json output.
     */
    int32 os_id;
    int32 thread_id;
    int32 core_id;
    int32 module_id;
    int32 tile_id; // tile is a constellation of 1 or more cores sharing same L2 cache. Unique for entire system
    int32 die_id;
    int32 die_grp_id;
    int32 socket_id;
    int32 socket_unique_core_id;
    int32 l3_cache_id = -1;
    int32 native_cpu_model = -1;
    enum DomainTypeID
    {
        InvalidDomainTypeID       = 0,
        LogicalProcessorDomain    = 1,
        CoreDomain                = 2,
        ModuleDomain              = 3,
        TileDomain                = 4,
        DieDomain                 = 5,
        DieGrpDomain              = 6,
        SocketPackageDomain       = 0xffff
    };
    enum CoreType
    {
        Atom = 0x20,
        Core = 0x40,
        Invalid = -1
    };
    CoreType core_type = Invalid;

    TopologyEntry() : os_id(-1), thread_id (-1), core_id(-1), module_id(-1), tile_id(-1), die_id(-1), die_grp_id(-1), socket_id(-1), socket_unique_core_id(-1) { }
    const char* getCoreTypeStr()
    {
        switch (core_type)
        {
            case Atom:
                return "Atom";
            case Core:
                return "Core";
            case Invalid:
                return "invalid";
        }
        return "unknown";
    }
    static const char* getDomainTypeStr(const DomainTypeID & id)
    {
        switch (id)
        {
            case InvalidDomainTypeID: return "invalid";
            case LogicalProcessorDomain: return "LogicalProcessor";
            case CoreDomain: return "Core";
            case ModuleDomain: return "Module";
            case TileDomain: return "Tile";
            case DieDomain: return "Die";
            case DieGrpDomain: return "DieGroup";
            case SocketPackageDomain: return "Socket/Package";
        }
        return "unknown";
    }
    bool isSameSocket( TopologyEntry& te ) const {
        return this->socket_id == te.socket_id;
    }
    bool isSameDieGroup( TopologyEntry& te ) const {
        return this->die_grp_id == te.die_grp_id && isSameSocket(te);
    }
    bool isSameDie( TopologyEntry& te ) const {
        return this->die_id == te.die_id && isSameDieGroup(te);
    }
    bool isSameTile( TopologyEntry& te ) const {
        return this->tile_id == te.tile_id && isSameDie(te);
    }
    bool isSameModule( TopologyEntry& te ) const {
        return this->module_id == te.module_id && isSameTile (te);
    }
    bool isSameCore( TopologyEntry& te ) const {
        return this->core_id == te.core_id && isSameModule(te);
    }
    bool operator <(const TopologyEntry& other) const
    {
        if (socket_id != other.socket_id)
            return socket_id < other.socket_id;
        if (die_grp_id != other.die_grp_id)
            return die_grp_id < other.die_grp_id;
        if (die_id != other.die_id)
            return die_id < other.die_id;
        if (tile_id != other.tile_id)
            return tile_id < other.tile_id;
        if (module_id != other.module_id)
            return module_id < other.module_id;
        if (core_id != other.core_id)
            return core_id < other.core_id;
        return thread_id < other.thread_id;
    }
};

inline void fillEntry(TopologyEntry & entry, const uint32 & smtMaskWidth, const uint32 & coreMaskWidth, const uint32 & l2CacheMaskShift, const int apic_id)
{
    #ifndef USER_KERNEL_SHARED
    DBG(1, "entry.os_id = ", entry.os_id, " apic_id = ", apic_id);
    #endif
    entry.thread_id = smtMaskWidth ? extract_bits_32(apic_id, 0, smtMaskWidth - 1) : 0;
    entry.core_id = coreMaskWidth ? extract_bits_32(apic_id, smtMaskWidth, smtMaskWidth + coreMaskWidth - 1) : 0;
    entry.socket_id = extract_bits_32(apic_id, smtMaskWidth + coreMaskWidth, 31);
    entry.tile_id = extract_bits_32(apic_id, l2CacheMaskShift, 31);
    entry.socket_unique_core_id = entry.core_id;
    #ifndef USER_KERNEL_SHARED
    DBG(1, "entry.os_id = ", entry.os_id, " apic_id = ", apic_id, " entry.thread_id = ", entry.thread_id, " entry.core_id = ", entry.core_id, " entry.socket_id = ", entry.socket_id , " entry.tile_id = ", entry.tile_id, " entry.socket_unique_core_id = ", entry.socket_unique_core_id);
    #endif
}

inline bool initCoreMasks(uint32 & smtMaskWidth, uint32 & coreMaskWidth, uint32 & l2CacheMaskShift, uint32 & l3CacheMaskShift)
{
    // init constants for CPU topology leaf 0xB
    // adapted from Topology Enumeration Reference code for Intel 64 Architecture
    // https://software.intel.com/en-us/articles/intel-64-architecture-processor-topology-enumeration
    int wasCoreReported = 0, wasThreadReported = 0;
    PCM_CPUID_INFO cpuid_args;
    if (true)
    {
        uint32 corePlusSMTMaskWidth = 0;
        int subleaf = 0, levelType, levelShift;
        do
        {
            pcm_cpuid(0xb, subleaf, cpuid_args);
            if (cpuid_args.array[1] == 0)
            { // if EBX ==0 then this subleaf is not valid, we can exit the loop
                break;
            }
            levelType = extract_bits_32(cpuid_args.array[2], 8, 15);
            levelShift = extract_bits_32(cpuid_args.array[0], 0, 4);
            #ifndef USER_KERNEL_SHARED
            DBG(1, "levelType = ", levelType, " levelShift = ", levelShift);
            #endif
            switch (levelType)
            {
            case 1: //level type is SMT, so levelShift is the SMT_Mask_Width
                smtMaskWidth = levelShift;
                wasThreadReported = 1;
                break;
            case 2: //level type is Core, so levelShift is the CorePlusSMT_Mask_Width
                corePlusSMTMaskWidth = levelShift;
                wasCoreReported = 1;
                break;
            default:
                break;
            }
            subleaf++;
        } while (1);

        if (wasThreadReported && wasCoreReported)
        {
            coreMaskWidth = corePlusSMTMaskWidth - smtMaskWidth;
        }
        else if (!wasCoreReported && wasThreadReported)
        {
            coreMaskWidth = smtMaskWidth;
        }
        else
        {
            return false;
        }

        (void) coreMaskWidth; // to suppress warnings on MacOS (unused vars)

        uint32 threadsSharingL2 = 0;
        uint32 l2CacheMaskWidth = 0;

        pcm_cpuid(0x4, 2, cpuid_args); // get ID for L2 cache
        l2CacheMaskWidth = 1 + extract_bits_32(cpuid_args.array[0],14,25); // number of APIC IDs sharing L2 cache
        threadsSharingL2 = l2CacheMaskWidth;
        for( ; l2CacheMaskWidth > 1; l2CacheMaskWidth >>= 1)
        {
            l2CacheMaskShift++;
        }

#ifndef USER_KERNEL_SHARED
        DBG(1, "Number of threads sharing L2 cache = " , threadsSharingL2, " [the most significant bit = " , l2CacheMaskShift , "]");
#endif

        uint32 threadsSharingL3 = 0;
        uint32 l3CacheMaskWidth = 0;

        pcm_cpuid(0x4, 3, cpuid_args); // get ID for L3 cache
        l3CacheMaskWidth = 1 + extract_bits_32(cpuid_args.array[0], 14, 25); // number of APIC IDs sharing L3 cache
        threadsSharingL3 = l3CacheMaskWidth;
        for( ; l3CacheMaskWidth > 1; l3CacheMaskWidth >>= 1)
        {
            l3CacheMaskShift++;
        }

#ifndef USER_KERNEL_SHARED
        DBG(1, "Number of threads sharing L3 cache = " , threadsSharingL3, " [the most significant bit = " , l3CacheMaskShift , "]");
#endif

        (void) threadsSharingL2; // to suppress warnings on MacOS (unused vars)
        (void) threadsSharingL3; // to suppress warnings on MacOS (unused vars)

        // Validate l3CacheMaskShift and ensure the bit range is correct
        if (l3CacheMaskShift > 31)
        {
#ifndef USER_KERNEL_SHARED
            DBG(0, "Invalid bit range for L3 cache ID extraction = ", l3CacheMaskShift);
#endif
            return false;
        }

#ifndef USER_KERNEL_SHARED
        uint32 it = 0;

        for (int i = 0; i < 100; ++i)
        {
            uint32 threadsSharingCache = 0;
            uint32 CacheMaskWidth = 0;
            uint32 CacheMaskShift = 0;
            pcm_cpuid(0x4, it, cpuid_args);
            const auto cacheType = extract_bits_32(cpuid_args.array[0], 0, 4);
            if (cacheType == 0)
            {
                break; // no more caches
            }
            const char * cacheTypeStr = nullptr;
            switch (cacheType)
            {
                case 1: cacheTypeStr = "data"; break;
                case 2: cacheTypeStr = "instruction"; break;
                case 3: cacheTypeStr = "unified"; break;
                default: cacheTypeStr = "unknown"; break;
            }
            const auto level = extract_bits_32(cpuid_args.array[0], 5, 7);
            CacheMaskWidth = 1 + extract_bits_32(cpuid_args.array[0], 14, 25); // number of APIC IDs sharing cache
            threadsSharingCache = CacheMaskWidth;
            for( ; CacheMaskWidth > 1; CacheMaskWidth >>= 1)
            {
                CacheMaskShift++;
            }
            DBG(1, "Max number of threads sharing L" , level , " " , cacheTypeStr , " cache = " , threadsSharingCache, " [the most significant bit = " , CacheMaskShift , "]",
                " shift = " , CacheMaskShift);
            ++it;
        }
#endif
    }
    #ifndef USER_KERNEL_SHARED
    DBG(1, "smtMaskWidth = ", smtMaskWidth, " coreMaskWidth = ", coreMaskWidth, " l2CacheMaskShift = ", l2CacheMaskShift, " l3CacheMaskShift = ", l3CacheMaskShift);
    #endif
    return true;
}

}


```

`src/tpmi.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2023, Intel Corporation
// written by Roman Dementiev
//

#include "tpmi.h"
#include "pci.h"
#include "utils.h"
#include "debug.h"
#include <vector>
#include <unordered_map>
#include <assert.h>
#ifdef __linux__
#include <algorithm>
#endif

namespace pcm {

constexpr uint32 TPMIInvalidValue = ~0U;

bool TPMIverbose = false;

class PFSInstances
{
public:
    // [TPMI ID][entry] -> base address
    typedef std::unordered_map<size_t, std::vector<size_t> > PFSMapType;
    struct PFSInstance
    {
        PFSMapType pfsMap{}; // [TPMI ID][entry] -> base address
        int32 NUMANode{-1};
    };
    typedef std::vector<PFSInstance> PFSInstancesType;
private:
    static std::shared_ptr<PFSInstancesType> PFSInstancesSingleton;
public:
    static PFSInstancesType & get()
    {
        if (PFSInstancesSingleton.get())
        {
            return *PFSInstancesSingleton.get();
        }
        // PFSInstancesSingleton not initialized, let us initialize it
        auto PFSInstancesSingletonInit = std::make_shared<PFSInstancesType>();

        processDVSEC([](const VSEC & vsec)
        {
            return vsec.fields.cap_id == 0xb // Vendor Specific DVSEC
                && vsec.fields.vsec_id == 0x42; // TPMI PM_Features
        }, [&](const uint64 bar, const VSEC & vsec, const int32 NUMANode)
        {
            DBG(1, "TPMI detection. Bar 0x", std::hex, bar, std::dec,
                   " NUMANode: ", NUMANode);
            struct PFS
            {
                uint64 TPMI_ID:8;
                uint64 NumEntries:8;
                uint64 EntrySize:16;
                uint64 CapOffset:16;
                uint64 Attribute:2;
                uint64 Reserved:14;
            };
            static_assert(sizeof(PFS) == sizeof(uint64), "sizeof(PFS) != sizeof(uint64)");
            assert(vsec.fields.EntrySize == 2);
            std::vector<PFS> pfsArray(vsec.fields.NumEntries);
            try {
                mmio_memcpy(&(pfsArray[0]), bar + 8ULL * vsec.fields.Address, vsec.fields.NumEntries * sizeof(PFS), true, true);
            } catch (std::runtime_error & e)
            {
                std::cerr << "Can't read PFS\n";
                std::cerr << e.what();
            }
            PFSInstancesSingletonInit->push_back(PFSInstance());
            PFSInstancesSingletonInit->back().NUMANode = NUMANode;
            for (const auto & pfs : pfsArray)
            {
                if (TPMIverbose)
                {
                    std::cout << "PFS" <<
                    "\t TPMI_ID: " << pfs.TPMI_ID <<
                    "\t NumEntries: " << pfs.NumEntries <<
                    "\t EntrySize: " << pfs.EntrySize <<
                    "\t CapOffset: " << pfs.CapOffset <<
                    "\t Attribute: " << pfs.Attribute <<
                    "\n";
                }
                DBG(1, " PFS TPMI_ID: ", pfs.TPMI_ID,
                    " NumEntries: ", pfs.NumEntries,
                    " EntrySize: ", pfs.EntrySize,
                    " CapOffset: ", pfs.CapOffset,
                    " Attribute: ", pfs.Attribute);

                for (uint64 p = 0; p < pfs.NumEntries; ++p)
                {
                    uint32 reg0 = 0;
                    const auto addr = bar + 8ULL * vsec.fields.Address + pfs.CapOffset * 1024ULL + p * pfs.EntrySize * sizeof(uint32);
                    try {
                        mmio_memcpy(&reg0, addr, sizeof(uint32), false, true);
                    } catch (std::runtime_error & e)
                    {
                        if (TPMIverbose)
                        {
                            std::cout << "can't read entry " << p << "\n";
                            std::cout << e.what();
                        }
                        DBG(2, "can't read entry ", p, " error: ", e.what());
                        PFSInstancesSingletonInit->back().pfsMap[pfs.TPMI_ID].push_back(addr);
                        continue;
                    }
                    if (reg0 == TPMIInvalidValue)
                    {
                        if (TPMIverbose)
                        {
                            std::cout << "invalid entry " << p << "\n";
                        }
                        DBG(2, "invalid entry ", p);
                    }
                    else
                    {
                        if (TPMIverbose)
                        {
                            std::cout << "Entry "<< p << std::hex;
                            for (uint64 i_offset = 0; i_offset < pfs.EntrySize * sizeof(uint32);  i_offset += sizeof(uint64))
                            {
                                uint64 reg = 0;
                                mmio_memcpy(&reg, addr + i_offset, sizeof(uint64), false);
                                std::cout << " register "<< i_offset << " = " << reg;
                            }
                            std::cout << std::dec << "\n";
                        }
                        DBG(2, "valid entry ", p);
                        for (uint64 i_offset = 0; i_offset < pfs.EntrySize * sizeof(uint32); i_offset += sizeof(uint64))
                        {
                            uint64 reg = 0;
                            mmio_memcpy(&reg, addr + i_offset, sizeof(uint64), false);
                            DBG(2, " register 0x", std::hex , i_offset, " = 0x", reg, std::dec);
                        }
                        PFSInstancesSingletonInit->back().pfsMap[pfs.TPMI_ID].push_back(addr);
                    }
                }
            }
        });
        PFSInstancesSingleton = PFSInstancesSingletonInit;
        return *PFSInstancesSingleton.get();
    }
};

std::shared_ptr<PFSInstances::PFSInstancesType> PFSInstances::PFSInstancesSingleton;

class TPMIHandleMMIO : public TPMIHandleInterface
{
    TPMIHandleMMIO(const TPMIHandleMMIO&) = delete;
    TPMIHandleMMIO& operator = (const TPMIHandleMMIO&) = delete;
    struct Entry
    {
        std::shared_ptr<MMIORange> range;
        size_t offset;
    };
    std::vector<Entry> entries;
    int32 numaNode{-1};
public:
    static size_t getNumInstances();
    static void setVerbose(const bool);
    TPMIHandleMMIO(const size_t instance_, const size_t ID_, const size_t offset_, const bool readonly_ = true);
    size_t getNumEntries() const override
    {
        return entries.size();
    }
    uint64 read64(size_t entryPos) override;
    void write64(size_t entryPos, uint64 val) override;
    int32 getNUMANode() override
    {
        return numaNode;
    }
};

size_t TPMIHandleMMIO::getNumInstances()
{
    return PFSInstances::get().size();
}

void TPMIHandle::setVerbose(const bool v)
{
    TPMIverbose = v;
}

TPMIHandleMMIO::TPMIHandleMMIO(const size_t instance_, const size_t ID_, const size_t requestedRelativeOffset, const bool readonly_)
{
    auto & pfsInstances = PFSInstances::get();
    assert(instance_ < pfsInstances.size());
    numaNode = pfsInstances[instance_].NUMANode;
    for (const auto & addr: pfsInstances[instance_].pfsMap[ID_])
    {
        const auto requestedAddr = addr + requestedRelativeOffset;
        const auto baseAddr = roundDownTo4K(requestedAddr);
        const auto baseOffset = requestedAddr - baseAddr;
        Entry e;
        e.range = std::make_shared<MMIORange>(baseAddr, 4096ULL, readonly_);
        e.offset = baseOffset;
        entries.push_back(e);
    }
}

uint64 TPMIHandleMMIO::read64(size_t entryPos)
{
    assert(entryPos < entries.size());
    return entries[entryPos].range->read64(entries[entryPos].offset);
}

void TPMIHandleMMIO::write64(size_t entryPos, uint64 val)
{
    assert(entryPos < entries.size());
    entries[entryPos].range->write64(entries[entryPos].offset, val);
}

#ifdef __linux__

int32 getNUMANodeLinux(uint32 groupnr, uint32 bus, uint32 device, uint32 function);

class TPMIHandleDriver : public TPMIHandleInterface
{
    TPMIHandleDriver(const TPMIHandleDriver&) = delete;
    TPMIHandleDriver& operator = (const TPMIHandleDriver&) = delete;
    static std::vector<std::string> instancePaths;
    typedef std::unordered_map<uint32, std::string> TPMI_IDPathMap;
    static std::vector<TPMI_IDPathMap> AllIDPaths;
    static int available;
    static bool isAvailable();
    const size_t instance;
    const size_t ID;
    const size_t offset;
    int32 numaNode{ -1 };
    // const bool readonly; // not used
    size_t nentries;
    struct TPMIEntry {
        unsigned int offset{0};
        std::vector<uint32> data;
    };

    size_t findValidIndex(const std::vector<TPMIEntry> & entries, const size_t & entryPos)
    {
        size_t validIndex = 0;
        for (size_t i = 0; i < entries.size(); ++i)
        {
            if (entries[i].data.empty() || entries[i].data[0] == TPMIInvalidValue)
            {
                // invalid, skip it
                continue;
            }
            if (validIndex == entryPos)
            {
                // found the right instance
                return i;
            }
            ++validIndex;
        }
        assert(0 && "TPMIHandleDriver: entryPos not found");
        return 0;
    }
    std::vector<TPMIEntry> readTPMIFile(std::string filePath)
    {
        filePath += "/mem_dump";
        std::vector<TPMIEntry> entries;
        std::ifstream file(filePath);
        std::string line;

        if (!file.is_open()) {
            std::cerr << "Error opening file: " << filePath << std::endl;
            return entries;
        }

        TPMIEntry currentEntry;
        while (getline(file, line)) {
            if (line.find("TPMI Instance:") != std::string::npos) {
                // If we have a previous instance, push it back to the vector
                if (!currentEntry.data.empty()) {
                    entries.push_back(currentEntry);
                    currentEntry.data.clear();
                }

                std::istringstream iss(line);
                std::string temp;
                iss >> temp >> temp >> temp; // Skip "TPMI Instance:"
                iss >> temp; // Skip entry number
                iss >> temp >> std::hex >> currentEntry.offset; // Read offset
            } else {
                std::istringstream iss(line);
                std::string address;
                iss >> address; // Skip the address part

                uint32_t value;
                while (iss >> std::hex >> value) {
                    currentEntry.data.push_back(value);
                }
            }
        }

        // Push the last instance if it exists
        if (!currentEntry.data.empty()) {
            entries.push_back(currentEntry);
        }

        return entries;
    }
public:
    static size_t getNumInstances();
    TPMIHandleDriver(const size_t instance_, const size_t ID_, const size_t offset_, const bool /* readonly_ */ = true) :
        instance(instance_),
        ID(ID_),
        offset(offset_),
        // readonly(readonly_), // not used
        nentries(0)
    {
        assert(available > 0);
        assert(instance < getNumInstances());
        const auto path = AllIDPaths[instance][ID];
        const auto entries = readTPMIFile(path);
        for (auto & e: entries)
        {
            if (e.data.empty() == false && e.data[0] != TPMIInvalidValue)
            {
                // count valid entries
                ++nentries;
            }
        }
        // path is like /sys/kernel/debug/tpmi-0000:80:03.1/tpmi-id-0a
        // extract the 0000:80:03.1 part:
        const auto prefix = std::string("/sys/kernel/debug/tpmi-");
        const auto startPos = path.find(prefix);
        assert(startPos != std::string::npos);
        const auto endPos = path.find("/tpmi-id-");
        assert(endPos != std::string::npos);
        const auto pciAddress = path.substr(startPos + prefix.size(), endPos - (startPos + prefix.size()));
        DBG(2, "TPMIHandleDriver: PCI address: ", pciAddress);
        std::istringstream iss(pciAddress);
        uint32 segment = 0;
        char separator{};
        uint32 bus = 0;
        uint32 device = 0;
        uint32 function = 0;
        iss >> std::hex >> segment >> separator >> std::hex >> bus >> separator >> std::hex;
        iss >> std::hex >> device;
        iss >> separator >> std::hex >> function;
        DBG(2, "TPMIHandleDriver: segment=", segment,
            " bus=", bus,
            " device=", device,
            " function=", function);
        numaNode = getNUMANodeLinux(segment, bus, device, function);
        DBG(2, "TPMIHandleDriver: NUMA node: ", numaNode);
    }
    size_t getNumEntries() const override
    {
        assert(available > 0);
        return nentries;
    }
    uint64 read64(size_t entryPos) override
    {
        assert(available > 0);
        assert(instance < getNumInstances());
        const auto entries = readTPMIFile(AllIDPaths[instance][ID]);
        size_t i = findValidIndex(entries, entryPos);
        cvt_ds result;
        const auto i4 = offset / 4;
        assert(i4 + 1 < entries[i].data.size());
        result.ui32.low = entries[i].data[i4];
        result.ui32.high = entries[i].data[i4 + 1];
        return result.ui64;
    }
    void write64(size_t entryPos, uint64 val) override
    {
        assert(available > 0);
        assert(instance < getNumInstances());
        const auto entries = readTPMIFile(AllIDPaths[instance][ID]);
        size_t i = findValidIndex(entries, entryPos);
        cvt_ds out;
        out.ui64 = val;
        const auto path = AllIDPaths[instance][ID] + "/mem_write";
        writeSysFS(path.c_str(), std::to_string(i) + "," + std::to_string(offset) + "," + std::to_string(out.ui32.low));
        writeSysFS(path.c_str(), std::to_string(i) + "," + std::to_string(offset + 4) + "," + std::to_string(out.ui32.high));
    }
    int32 getNUMANode() override
    {
        return numaNode;
    }
};

int TPMIHandleDriver::available = -1;
std::vector<std::string> TPMIHandleDriver::instancePaths;
std::vector<TPMIHandleDriver::TPMI_IDPathMap> TPMIHandleDriver::AllIDPaths;

bool TPMIHandleDriver::isAvailable()
{
    if (available < 0) // not initialized yet
    {
        instancePaths = findPathsFromPattern("/sys/kernel/debug/tpmi-*");
        std::sort(instancePaths.begin(), instancePaths.end());
        for (size_t i = 0; i < instancePaths.size(); ++i)
        {
            // std::cout << instancePaths[i] << std::endl;
            std::string prefix = instancePaths[i] + "/tpmi-id-";
            std::vector<std::string> IDPaths = findPathsFromPattern((prefix + "*").c_str());
            TPMI_IDPathMap idMap;
            for (auto & p : IDPaths)
            {
                const auto id = read_number((std::string("0x") + p.substr(prefix.size())).c_str());
                // std::cout << p << " -> " <<  id << std::endl;
                idMap[id] = p;
                std::ifstream mem_dump((p + "/mem_dump").c_str());
                std::ifstream mem_write((p + "/mem_write").c_str());
                if (mem_dump.good() && mem_write.good())
                {
                    available = 1;
                }
            }
            AllIDPaths.push_back(idMap);
        }
        if (available < 0)
        {
            available = 0;
        }
        if (safe_getenv("PCM_NO_TPMI_DRIVER") == std::string("1"))
        {
            available = 0;
        }
    }
    return available > 0;
}

size_t TPMIHandleDriver::getNumInstances()
{
    // std::cout << "isAvailable: " << isAvailable() << std::endl;
    if (isAvailable())
    {
        return AllIDPaths.size();
    }
    return 0;
}

#endif

size_t TPMIHandle::getNumInstances()
{
    #ifdef __linux__
    const auto tpmiNInstances = TPMIHandleDriver::getNumInstances();
    if (tpmiNInstances)
    {
        return tpmiNInstances;
    }
    #endif
    return TPMIHandleMMIO::getNumInstances();
}

TPMIHandle::TPMIHandle(const size_t instance_, const size_t ID_, const size_t requestedRelativeOffset, const bool readonly_)
{
    #ifdef __linux__
    const auto tpmiNInstances = TPMIHandleDriver::getNumInstances();
    if (tpmiNInstances)
    {
        impl = std::make_shared<TPMIHandleDriver>(instance_, ID_, requestedRelativeOffset, readonly_);
        return;
    }
    #endif
    impl = std::make_shared<TPMIHandleMMIO>(instance_, ID_, requestedRelativeOffset, readonly_);
}

size_t TPMIHandle::getNumEntries() const
{
    assert(impl.get());;
    return impl->getNumEntries();
}

uint64 TPMIHandle::read64(size_t entryPos)
{
    assert(impl.get());
    return impl->read64(entryPos);
}

void TPMIHandle::write64(size_t entryPos, uint64 val)
{
    assert(impl.get());
    impl->write64(entryPos, val);
}

int32 TPMIHandle::getNUMANode()
{
    assert(impl.get());
    return impl->getNUMANode();
}

} // namespace pcm

```

`src/tpmi.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2023-2024, Intel Corporation
// written by Roman Dementiev
//

#pragma once

/*!     \file tpmi.h
        \brief Interface to access TPMI registers

*/

#include "mmio.h"
#include <vector>

namespace pcm {

class TPMIHandleInterface
{
public:
    virtual size_t getNumEntries() const = 0;
    virtual uint64 read64(size_t entryPos) = 0;
    virtual void write64(size_t entryPos, uint64 val) = 0;
    virtual int32 getNUMANode() = 0;
    virtual ~TPMIHandleInterface() {}
};

class TPMIHandle : public TPMIHandleInterface
{
    TPMIHandle(const TPMIHandle&) = delete;
    TPMIHandle& operator = (const TPMIHandle&) = delete;
    std::shared_ptr<TPMIHandleInterface> impl;
public:
    static size_t getNumInstances();
    static void setVerbose(const bool);
    TPMIHandle(const size_t instance_, const size_t ID_, const size_t offset_, const bool readonly_ = true);
    size_t getNumEntries() const override;
    uint64 read64(size_t entryPos) override;
    void write64(size_t entryPos, uint64 val) override;
    int32 getNUMANode() override;
};

} // namespace pcm

```

`src/types.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2024, Intel Corporation
// written by Roman Dementiev
//

#ifndef CPUCounters_TYPES_H
#define CPUCounters_TYPES_H


/*!     \file types.h
        \brief Internal type and constant definitions
*/

#undef PCM_DEBUG

#ifndef KERNEL

#include <iostream>
#include <istream>
#include <sstream>
#include <iomanip>
#include <stdexcept>
#include <string>
#include <string.h>
#include <assert.h>
#include <limits>

#ifdef _MSC_VER
#include <windows.h>
#include <intrin.h>
#endif

#endif // #ifndef KERNEL

namespace pcm {

typedef unsigned long long uint64;
typedef signed long long int64;
typedef unsigned int uint32;
typedef signed int int32;

#define PCM_ULIMIT_RECOMMENDATION ("try executing 'ulimit -n 1000000' to increase the limit on the number of open files.\n")

/*
    MSR addresses from
    "Intel 64 and IA-32 Architectures Software Developers Manual Volume 3B:
    System Programming Guide, Part 2", Appendix A "PERFORMANCE-MONITORING EVENTS"
*/

constexpr auto INST_RETIRED_ADDR = 0x309;
constexpr auto CPU_CLK_UNHALTED_THREAD_ADDR = 0x30A;
constexpr auto CPU_CLK_UNHALTED_REF_ADDR = 0x30B;
constexpr auto TOPDOWN_SLOTS_ADDR = 0x30C;
constexpr auto PERF_METRICS_ADDR = 0x329;
constexpr auto IA32_CR_PERF_GLOBAL_CTRL = 0x38F;
constexpr auto IA32_CR_FIXED_CTR_CTRL = 0x38D;
constexpr auto IA32_PERFEVTSEL0_ADDR = 0x186;
constexpr auto IA32_PERFEVTSEL1_ADDR = IA32_PERFEVTSEL0_ADDR + 1;
constexpr auto IA32_PERFEVTSEL2_ADDR = IA32_PERFEVTSEL0_ADDR + 2;
constexpr auto IA32_PERFEVTSEL3_ADDR = IA32_PERFEVTSEL0_ADDR + 3;
constexpr auto IA32_PERF_GLOBAL_STATUS = 0x38E;
constexpr auto IA32_PERF_GLOBAL_OVF_CTRL = 0x390;
constexpr auto IA32_PEBS_ENABLE_ADDR = 0x3F1;

constexpr auto PERF_MAX_FIXED_COUNTERS = 3;
constexpr auto PERF_MAX_CUSTOM_COUNTERS = 8;
constexpr auto PERF_TOPDOWN_COUNTERS_L1 = 5;
constexpr auto PERF_TOPDOWN_COUNTERS = PERF_TOPDOWN_COUNTERS_L1 + 4;
constexpr auto PERF_MAX_COUNTERS = PERF_MAX_FIXED_COUNTERS + PERF_MAX_CUSTOM_COUNTERS + PERF_TOPDOWN_COUNTERS;

constexpr auto IA32_DEBUGCTL = 0x1D9;

constexpr auto IA32_PMC0 = 0xC1;
constexpr auto IA32_PMC1 = IA32_PMC0 + 1;
constexpr auto IA32_PMC2 = IA32_PMC0 + 2;
constexpr auto IA32_PMC3 = IA32_PMC0 + 3;

constexpr auto MSR_OFFCORE_RSP0 = 0x1A6;
constexpr auto MSR_OFFCORE_RSP1 = 0x1A7;
constexpr auto MSR_LOAD_LATENCY = 0x3F6;
constexpr auto MSR_FRONTEND = 0x3F7;

/* From Table B-5. of the above mentioned document */
constexpr auto PLATFORM_INFO_ADDR = 0xCE;

constexpr auto IA32_TIME_STAMP_COUNTER = 0x10;

// Event IDs

// Nehalem/Westmere on-core events
constexpr auto MEM_LOAD_RETIRED_L3_MISS_EVTNR = 0xCB;
constexpr auto MEM_LOAD_RETIRED_L3_MISS_UMASK = 0x10;

constexpr auto MEM_LOAD_RETIRED_L3_UNSHAREDHIT_EVTNR = 0xCB;
constexpr auto MEM_LOAD_RETIRED_L3_UNSHAREDHIT_UMASK = 0x04;

constexpr auto MEM_LOAD_RETIRED_L2_HITM_EVTNR = 0xCB;
constexpr auto MEM_LOAD_RETIRED_L2_HITM_UMASK = 0x08;

constexpr auto MEM_LOAD_RETIRED_L2_HIT_EVTNR = 0xCB;
constexpr auto MEM_LOAD_RETIRED_L2_HIT_UMASK = 0x02;

// Sandy Bridge on-core events

constexpr auto MEM_LOAD_UOPS_MISC_RETIRED_LLC_MISS_EVTNR = 0xD4;
constexpr auto MEM_LOAD_UOPS_MISC_RETIRED_LLC_MISS_UMASK = 0x02;

constexpr auto MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_NONE_EVTNR = 0xD2;
constexpr auto MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_NONE_UMASK = 0x08;

constexpr auto MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_HITM_EVTNR = 0xD2;
constexpr auto MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_HITM_UMASK = 0x04;

constexpr auto MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_EVTNR = 0xD2;
constexpr auto MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_UMASK = 0x07;

constexpr auto MEM_LOAD_UOPS_RETIRED_L2_HIT_EVTNR = 0xD1;
constexpr auto MEM_LOAD_UOPS_RETIRED_L2_HIT_UMASK = 0x02;
// Haswell on-core events

constexpr auto HSX_L2_RQSTS_MISS_EVTNR = 0x24;
constexpr auto HSX_L2_RQSTS_MISS_UMASK = 0x3f;
constexpr auto HSX_L2_RQSTS_REFERENCES_EVTNR = 0x24;
constexpr auto HSX_L2_RQSTS_REFERENCES_UMASK = 0xff;

// Skylake on-core events

#define SKL_MEM_LOAD_RETIRED_L3_MISS_EVTNR (0xD1)
#define SKL_MEM_LOAD_RETIRED_L3_MISS_UMASK (0x20)

#define SKL_MEM_LOAD_RETIRED_L3_HIT_EVTNR (0xD1)
#define SKL_MEM_LOAD_RETIRED_L3_HIT_UMASK (0x04)

#define SKL_MEM_LOAD_RETIRED_L2_MISS_EVTNR (0xD1)
#define SKL_MEM_LOAD_RETIRED_L2_MISS_UMASK (0x10)

#define SKL_MEM_LOAD_RETIRED_L2_HIT_EVTNR (0xD1)
#define SKL_MEM_LOAD_RETIRED_L2_HIT_UMASK (0x02)

// Crestmont on-core events

constexpr auto CMT_MEM_LOAD_RETIRED_L2_MISS_EVTNR = 0xD1;
constexpr auto CMT_MEM_LOAD_RETIRED_L2_MISS_UMASK = 0x80;

constexpr auto CMT_MEM_LOAD_RETIRED_L2_HIT_EVTNR = 0xD1;
constexpr auto CMT_MEM_LOAD_RETIRED_L2_HIT_UMASK = 0x02;

// architectural on-core events
constexpr auto ARCH_LLC_REFERENCE_EVTNR = 0x2E;
constexpr auto ARCH_LLC_REFERENCE_UMASK = 0x4F;

constexpr auto ARCH_LLC_MISS_EVTNR = 0x2E;
constexpr auto ARCH_LLC_MISS_UMASK = 0x41;

// Atom on-core events
constexpr auto ATOM_MEM_LOAD_RETIRED_L2_HIT_EVTNR = 0xCB;
constexpr auto ATOM_MEM_LOAD_RETIRED_L2_HIT_UMASK = 0x01;

constexpr auto ATOM_MEM_LOAD_RETIRED_L2_MISS_EVTNR = 0xCB;
constexpr auto ATOM_MEM_LOAD_RETIRED_L2_MISS_UMASK = 0x02;

// Offcore response events
constexpr auto OFFCORE_RESPONSE_0_EVTNR = 0xB7;
constexpr auto OFFCORE_RESPONSE_1_EVTNR = 0xBB;
constexpr auto GLC_OFFCORE_RESPONSE_0_EVTNR = 0x2A;
constexpr auto GLC_OFFCORE_RESPONSE_1_EVTNR = 0x2B;
constexpr auto OFFCORE_RESPONSE_0_UMASK = 1;
constexpr auto OFFCORE_RESPONSE_1_UMASK = 1;

constexpr auto LOAD_LATENCY_EVTNR = 0xcd;
constexpr auto LOAD_LATENCY_UMASK = 0x01;
constexpr auto FRONTEND_EVTNR = 0xC6;
constexpr auto FRONTEND_UMASK = 0x01;

/*
     For Nehalem(-EP) processors from Intel(r) 64 and IA-32 Architectures Software Developer's Manual
*/

// Uncore msrs
constexpr auto MSR_UNCORE_PERF_GLOBAL_CTRL_ADDR = 0x391;

constexpr auto MSR_UNCORE_PERFEVTSEL0_ADDR = 0x3C0;
constexpr auto MSR_UNCORE_PERFEVTSEL1_ADDR = MSR_UNCORE_PERFEVTSEL0_ADDR + 1;
constexpr auto MSR_UNCORE_PERFEVTSEL2_ADDR = MSR_UNCORE_PERFEVTSEL0_ADDR + 2;
constexpr auto MSR_UNCORE_PERFEVTSEL3_ADDR = MSR_UNCORE_PERFEVTSEL0_ADDR + 3;
constexpr auto MSR_UNCORE_PERFEVTSEL4_ADDR = MSR_UNCORE_PERFEVTSEL0_ADDR + 4;
constexpr auto MSR_UNCORE_PERFEVTSEL5_ADDR = MSR_UNCORE_PERFEVTSEL0_ADDR + 5;
constexpr auto MSR_UNCORE_PERFEVTSEL6_ADDR = MSR_UNCORE_PERFEVTSEL0_ADDR + 6;
constexpr auto MSR_UNCORE_PERFEVTSEL7_ADDR = MSR_UNCORE_PERFEVTSEL0_ADDR + 7;

constexpr auto MSR_UNCORE_PMC0 = 0x3B0;
constexpr auto MSR_UNCORE_PMC1 = MSR_UNCORE_PMC0 + 1;
constexpr auto MSR_UNCORE_PMC2 = MSR_UNCORE_PMC0 + 2;
constexpr auto MSR_UNCORE_PMC3 = MSR_UNCORE_PMC0 + 3;
constexpr auto MSR_UNCORE_PMC4 = MSR_UNCORE_PMC0 + 4;
constexpr auto MSR_UNCORE_PMC5 = MSR_UNCORE_PMC0 + 5;
constexpr auto MSR_UNCORE_PMC6 = MSR_UNCORE_PMC0 + 6;
constexpr auto MSR_UNCORE_PMC7 = MSR_UNCORE_PMC0 + 7;
// Uncore event IDs
constexpr auto UNC_QMC_WRITES_FULL_ANY_EVTNR = 0x2F;
constexpr auto UNC_QMC_WRITES_FULL_ANY_UMASK = 0x07;

constexpr auto UNC_QMC_NORMAL_READS_ANY_EVTNR = 0x2C;
constexpr auto UNC_QMC_NORMAL_READS_ANY_UMASK = 0x07;

constexpr auto UNC_QHL_REQUESTS_EVTNR = 0x20;

constexpr auto UNC_QHL_REQUESTS_IOH_READS_UMASK = 0x01;
constexpr auto UNC_QHL_REQUESTS_IOH_WRITES_UMASK = 0x02;
constexpr auto UNC_QHL_REQUESTS_REMOTE_READS_UMASK = 0x04;
constexpr auto UNC_QHL_REQUESTS_REMOTE_WRITES_UMASK = 0x08;
constexpr auto UNC_QHL_REQUESTS_LOCAL_READS_UMASK = 0x10;
constexpr auto UNC_QHL_REQUESTS_LOCAL_WRITES_UMASK = 0x20;
/*
        From "Intel(r) Xeon(r) Processor 7500 Series Uncore Programming Guide"
*/

// Beckton uncore event IDs
constexpr auto U_MSR_PMON_GLOBAL_CTL = 0x0C00;

constexpr auto MB0_MSR_PERF_GLOBAL_CTL = 0x0CA0;
constexpr auto MB0_MSR_PMU_CNT_0 = 0x0CB1;
constexpr auto MB0_MSR_PMU_CNT_CTL_0 = 0x0CB0;
constexpr auto MB0_MSR_PMU_CNT_1 = 0x0CB3;
constexpr auto MB0_MSR_PMU_CNT_CTL_1 = 0x0CB2;
constexpr auto MB0_MSR_PMU_ZDP_CTL_FVC = 0x0CAB;

constexpr auto MB1_MSR_PERF_GLOBAL_CTL = 0x0CE0;
constexpr auto MB1_MSR_PMU_CNT_0 = 0x0CF1;
constexpr auto MB1_MSR_PMU_CNT_CTL_0 = 0x0CF0;
constexpr auto MB1_MSR_PMU_CNT_1 = 0x0CF3;
constexpr auto MB1_MSR_PMU_CNT_CTL_1 = 0x0CF2;
constexpr auto MB1_MSR_PMU_ZDP_CTL_FVC = 0x0CEB;

constexpr auto BB0_MSR_PERF_GLOBAL_CTL = 0x0C20;
constexpr auto BB0_MSR_PERF_CNT_1 = 0x0C33;
constexpr auto BB0_MSR_PERF_CNT_CTL_1 = 0x0C32;

constexpr auto BB1_MSR_PERF_GLOBAL_CTL = 0x0C60;
constexpr auto BB1_MSR_PERF_CNT_1 = 0x0C73;
constexpr auto BB1_MSR_PERF_CNT_CTL_1 = 0x0C72;

constexpr auto R_MSR_PMON_CTL0 = 0x0E10;
constexpr auto R_MSR_PMON_CTR0 = 0x0E11;
constexpr auto R_MSR_PMON_CTL1 = 0x0E12;
constexpr auto R_MSR_PMON_CTR1 = 0x0E13;
constexpr auto R_MSR_PMON_CTL2 = 0x0E14;
constexpr auto R_MSR_PMON_CTR2 = 0x0E15;
constexpr auto R_MSR_PMON_CTL3 = 0x0E16;
constexpr auto R_MSR_PMON_CTR3 = 0x0E17;
constexpr auto R_MSR_PMON_CTL4 = 0x0E18;
constexpr auto R_MSR_PMON_CTR4 = 0x0E19;
constexpr auto R_MSR_PMON_CTL5 = 0x0E1A;
constexpr auto R_MSR_PMON_CTR5 = 0x0E1B;
constexpr auto R_MSR_PMON_CTL6 = 0x0E1C;
constexpr auto R_MSR_PMON_CTR6 = 0x0E1D;
constexpr auto R_MSR_PMON_CTL7 = 0x0E1E;
constexpr auto R_MSR_PMON_CTR7 = 0x0E1F;
constexpr auto R_MSR_PMON_CTL8 = 0x0E30;
constexpr auto R_MSR_PMON_CTR8 = 0x0E31;
constexpr auto R_MSR_PMON_CTL9 = 0x0E32;
constexpr auto R_MSR_PMON_CTR9 = 0x0E33;
constexpr auto R_MSR_PMON_CTL10 = 0x0E34;
constexpr auto R_MSR_PMON_CTR10 = 0x0E35;
constexpr auto R_MSR_PMON_CTL11 = 0x0E36;
constexpr auto R_MSR_PMON_CTR11 = 0x0E37;
constexpr auto R_MSR_PMON_CTL12 = 0x0E38;
constexpr auto R_MSR_PMON_CTR12 = 0x0E39;
constexpr auto R_MSR_PMON_CTL13 = 0x0E3A;
constexpr auto R_MSR_PMON_CTR13 = 0x0E3B;
constexpr auto R_MSR_PMON_CTL14 = 0x0E3C;
constexpr auto R_MSR_PMON_CTR14 = 0x0E3D;
constexpr auto R_MSR_PMON_CTL15 = 0x0E3E;
constexpr auto R_MSR_PMON_CTR15 = 0x0E3F;

constexpr auto R_MSR_PORT0_IPERF_CFG0 = 0x0E04;
constexpr auto R_MSR_PORT1_IPERF_CFG0 = 0x0E05;
constexpr auto R_MSR_PORT2_IPERF_CFG0 = 0x0E06;
constexpr auto R_MSR_PORT3_IPERF_CFG0 = 0x0E07;
constexpr auto R_MSR_PORT4_IPERF_CFG0 = 0x0E08;
constexpr auto R_MSR_PORT5_IPERF_CFG0 = 0x0E09;
constexpr auto R_MSR_PORT6_IPERF_CFG0 = 0x0E0A;
constexpr auto R_MSR_PORT7_IPERF_CFG0 = 0x0E0B;

constexpr auto R_MSR_PORT0_IPERF_CFG1 = 0x0E24;
constexpr auto R_MSR_PORT1_IPERF_CFG1 = 0x0E25;
constexpr auto R_MSR_PORT2_IPERF_CFG1 = 0x0E26;
constexpr auto R_MSR_PORT3_IPERF_CFG1 = 0x0E27;
constexpr auto R_MSR_PORT4_IPERF_CFG1 = 0x0E28;
constexpr auto R_MSR_PORT5_IPERF_CFG1 = 0x0E29;
constexpr auto R_MSR_PORT6_IPERF_CFG1 = 0x0E2A;
constexpr auto R_MSR_PORT7_IPERF_CFG1 = 0x0E2B;

constexpr auto R_MSR_PMON_GLOBAL_CTL_7_0 = 0x0E00;
constexpr auto R_MSR_PMON_GLOBAL_CTL_15_8 = 0x0E20;

constexpr auto W_MSR_PMON_GLOBAL_CTL = 0xC80;
constexpr auto W_MSR_PMON_FIXED_CTR_CTL = 0x395;
constexpr auto W_MSR_PMON_FIXED_CTR = 0x394;
/*
 * Platform QoS MSRs
 */

constexpr auto IA32_PQR_ASSOC = 0xc8f;
constexpr auto IA32_QM_EVTSEL = 0xc8d;
constexpr auto IA32_QM_CTR = 0xc8e;

#ifndef KERNEL
constexpr auto PCM_INVALID_QOS_MONITORING_DATA = (std::numeric_limits<uint64>::max)();
#endif

/* \brief Event Select Register format

        According to
        "Intel 64 and IA-32 Architectures Software Developers Manual Volume 3B:
        System Programming Guide, Part 2", Figure 30-6. Layout of IA32_PERFEVTSELx
        MSRs Supporting Architectural Performance Monitoring Version 3
*/
struct EventSelectRegister
{
    union
    {
        struct
        {
            uint64 event_select : 8;
            uint64 umask : 8;
            uint64 usr : 1;
            uint64 os : 1;
            uint64 edge : 1;
            uint64 pin_control : 1;
            uint64 apic_int : 1;
            uint64 any_thread : 1;
            uint64 enable : 1;
            uint64 invert : 1;
            uint64 cmask : 8;
            uint64 in_tx : 1;
            uint64 in_txcp : 1;
            uint64 reservedX : 30;
        } fields;
        uint64 value;
    };

    EventSelectRegister() : value(0) {}
};


/* \brief Fixed Event Control Register format

        According to
        "Intel 64 and IA-32 Architectures Software Developers Manual Volume 3B:
        System Programming Guide, Part 2", Figure 30-7. Layout of
        IA32_FIXED_CTR_CTRL MSR Supporting Architectural Performance Monitoring Version 3
*/
struct FixedEventControlRegister
{
    union
    {
        struct
        {
            // CTR0
            uint64 os0 : 1;
            uint64 usr0 : 1;
            uint64 any_thread0 : 1;
            uint64 enable_pmi0 : 1;
            // CTR1
            uint64 os1 : 1;
            uint64 usr1 : 1;
            uint64 any_thread1 : 1;
            uint64 enable_pmi1 : 1;
            // CTR2
            uint64 os2 : 1;
            uint64 usr2 : 1;
            uint64 any_thread2 : 1;
            uint64 enable_pmi2 : 1;
	    // CTR3
            uint64 os3 : 1;
            uint64 usr3 : 1;
            uint64 any_thread3 : 1;
            uint64 enable_pmi3 : 1;

            uint64 reserved1 : 48;
        } fields;
        uint64 value;
    };
    FixedEventControlRegister() : value(0) {}
};

#ifndef KERNEL

inline std::ostream & operator << (std::ostream & o, const FixedEventControlRegister & reg)
{
    o << "os0\t\t" << reg.fields.os0 << "\n";
    o << "usr0\t\t" << reg.fields.usr0 << "\n";
    o << "any_thread0\t" << reg.fields.any_thread0 << "\n";
    o << "enable_pmi0\t" << reg.fields.enable_pmi0 << "\n";

    o << "os1\t\t" << reg.fields.os1 << "\n";
    o << "usr1\t\t" << reg.fields.usr1 << "\n";
    o << "any_thread1\t" << reg.fields.any_thread1 << "\n";
    o << "enable_pmi10\t" << reg.fields.enable_pmi1 << "\n";

    o << "os2\t\t" << reg.fields.os2 << "\n";
    o << "usr2\t\t" << reg.fields.usr2 << "\n";
    o << "any_thread2\t" << reg.fields.any_thread2 << "\n";
    o << "enable_pmi2\t" << reg.fields.enable_pmi2 << "\n";

    o << "reserved1\t" << reg.fields.reserved1 << "\n";
    return o;
}

#endif // #ifndef KERNEL

// UNCORE COUNTER CONTROL

/* \brief Uncore Event Select Register Register format

        According to
        "Intel 64 and IA-32 Architectures Software Developers Manual Volume 3B:
        System Programming Guide, Part 2", Figure 30-20. Layout of MSR_UNCORE_PERFEVTSELx MSRs
*/
struct UncoreEventSelectRegister
{
    union
    {
        struct
        {
            uint64 event_select : 8;
            uint64 umask : 8;
            uint64 reserved1 : 1;
            uint64 occ_ctr_rst : 1;
            uint64 edge : 1;
            uint64 reserved2 : 1;
            uint64 enable_pmi : 1;
            uint64 reserved3 : 1;
            uint64 enable : 1;
            uint64 invert : 1;
            uint64 cmask : 8;
            uint64 reservedx : 32;
        } fields;
        uint64 value;
    };
};

/* \brief Beckton Uncore PMU ZDP FVC Control Register format

        From "Intel(r) Xeon(r) Processor 7500 Series Uncore Programming Guide"
        Table 2-80. M_MSR_PMU_ZDP_CTL_FVC Register - Field Definitions
*/
struct BecktonUncorePMUZDPCTLFVCRegister
{
    union
    {
        struct
        {
            uint64 fvid : 5;
            uint64 bcmd : 3;
            uint64 resp : 3;
            uint64 evnt0 : 3;
            uint64 evnt1 : 3;
            uint64 evnt2 : 3;
            uint64 evnt3 : 3;
            uint64 pbox_init_err : 1;
        } fields; // nehalem-ex version
        struct
        {
            uint64 fvid : 6;
            uint64 bcmd : 3;
            uint64 resp : 3;
            uint64 evnt0 : 3;
            uint64 evnt1 : 3;
            uint64 evnt2 : 3;
            uint64 evnt3 : 3;
            uint64 pbox_init_err : 1;
        } fields_wsm; // westmere-ex version
        uint64 value;
    };
};

/* \brief Beckton Uncore PMU Counter Control Register format

        From "Intel(r) Xeon(r) Processor 7500 Series Uncore Programming Guide"
        Table 2-67. M_MSR_PMU_CNT_CTL{5-0} Register - Field Definitions
*/
struct BecktonUncorePMUCNTCTLRegister
{
    union
    {
        struct
        {
            uint64 en : 1;
            uint64 pmi_en : 1;
            uint64 count_mode : 2;
            uint64 storage_mode : 2;
            uint64 wrap_mode : 1;
            uint64 flag_mode : 1;
            uint64 rsv1 : 1;
            uint64 inc_sel : 5;
            uint64 rsv2 : 5;
            uint64 set_flag_sel : 3;
        } fields;
        uint64 value;
    };
};

constexpr auto MSR_SMI_COUNT = 0x34;

/* \brief Sandy Bridge energy counters
*/

constexpr auto MSR_PKG_ENERGY_STATUS = 0x611;
constexpr auto MSR_SYS_ENERGY_STATUS = 0x64D;
constexpr auto MSR_RAPL_POWER_UNIT = 0x606;
constexpr auto MSR_PKG_POWER_INFO = 0x614;

constexpr auto PCM_INTEL_PCI_VENDOR_ID = 0x8086;
constexpr auto PCM_PCI_VENDOR_ID_OFFSET = 0;

// server PCICFG uncore counters
constexpr auto JKTIVT_MC0_CH0_REGISTER_DEV_ADDR = 16;
constexpr auto JKTIVT_MC0_CH1_REGISTER_DEV_ADDR = 16;
constexpr auto JKTIVT_MC0_CH2_REGISTER_DEV_ADDR = 16;
constexpr auto JKTIVT_MC0_CH3_REGISTER_DEV_ADDR = 16;
constexpr auto JKTIVT_MC0_CH0_REGISTER_FUNC_ADDR = 4;
constexpr auto JKTIVT_MC0_CH1_REGISTER_FUNC_ADDR = 5;
constexpr auto JKTIVT_MC0_CH2_REGISTER_FUNC_ADDR = 0;
constexpr auto JKTIVT_MC0_CH3_REGISTER_FUNC_ADDR = 1;

constexpr auto JKTIVT_MC1_CH0_REGISTER_DEV_ADDR = 30;
constexpr auto JKTIVT_MC1_CH1_REGISTER_DEV_ADDR = 30;
constexpr auto JKTIVT_MC1_CH2_REGISTER_DEV_ADDR = 30;
constexpr auto JKTIVT_MC1_CH3_REGISTER_DEV_ADDR = 30;
constexpr auto JKTIVT_MC1_CH0_REGISTER_FUNC_ADDR = 4;
constexpr auto JKTIVT_MC1_CH1_REGISTER_FUNC_ADDR = 5;
constexpr auto JKTIVT_MC1_CH2_REGISTER_FUNC_ADDR = 0;
constexpr auto JKTIVT_MC1_CH3_REGISTER_FUNC_ADDR = 1;

constexpr auto HSX_MC0_CH0_REGISTER_DEV_ADDR = 20;
constexpr auto HSX_MC0_CH1_REGISTER_DEV_ADDR = 20;
constexpr auto HSX_MC0_CH2_REGISTER_DEV_ADDR = 21;
constexpr auto HSX_MC0_CH3_REGISTER_DEV_ADDR = 21;
constexpr auto HSX_MC0_CH0_REGISTER_FUNC_ADDR = 0;
constexpr auto HSX_MC0_CH1_REGISTER_FUNC_ADDR = 1;
constexpr auto HSX_MC0_CH2_REGISTER_FUNC_ADDR = 0;
constexpr auto HSX_MC0_CH3_REGISTER_FUNC_ADDR = 1;

constexpr auto HSX_MC1_CH0_REGISTER_DEV_ADDR = 23;
constexpr auto HSX_MC1_CH1_REGISTER_DEV_ADDR = 23;
constexpr auto HSX_MC1_CH2_REGISTER_DEV_ADDR = 24;
constexpr auto HSX_MC1_CH3_REGISTER_DEV_ADDR = 24;
constexpr auto HSX_MC1_CH0_REGISTER_FUNC_ADDR = 0;
constexpr auto HSX_MC1_CH1_REGISTER_FUNC_ADDR = 1;
constexpr auto HSX_MC1_CH2_REGISTER_FUNC_ADDR = 0;
constexpr auto HSX_MC1_CH3_REGISTER_FUNC_ADDR = 1;

constexpr auto KNL_MC0_CH0_REGISTER_DEV_ADDR = 8;
constexpr auto KNL_MC0_CH1_REGISTER_DEV_ADDR = 8;
constexpr auto KNL_MC0_CH2_REGISTER_DEV_ADDR = 8;
constexpr auto KNL_MC0_CH0_REGISTER_FUNC_ADDR = 2;
constexpr auto KNL_MC0_CH1_REGISTER_FUNC_ADDR = 3;
constexpr auto KNL_MC0_CH2_REGISTER_FUNC_ADDR = 4;

constexpr auto SKX_MC0_CH0_REGISTER_DEV_ADDR = 10;
constexpr auto SKX_MC0_CH1_REGISTER_DEV_ADDR = 10;
constexpr auto SKX_MC0_CH2_REGISTER_DEV_ADDR = 11;
constexpr auto SKX_MC0_CH3_REGISTER_DEV_ADDR = -1; //Does not exist
constexpr auto SKX_MC0_CH0_REGISTER_FUNC_ADDR = 2;
constexpr auto SKX_MC0_CH1_REGISTER_FUNC_ADDR = 6;
constexpr auto SKX_MC0_CH2_REGISTER_FUNC_ADDR = 2;
constexpr auto SKX_MC0_CH3_REGISTER_FUNC_ADDR = -1; //Does not exist

constexpr auto SKX_MC1_CH0_REGISTER_DEV_ADDR = 12;
constexpr auto SKX_MC1_CH1_REGISTER_DEV_ADDR = 12;
constexpr auto SKX_MC1_CH2_REGISTER_DEV_ADDR = 13;
constexpr auto SKX_MC1_CH3_REGISTER_DEV_ADDR = -1; //Does not exist
constexpr auto SKX_MC1_CH0_REGISTER_FUNC_ADDR = 2;
constexpr auto SKX_MC1_CH1_REGISTER_FUNC_ADDR = 6;
constexpr auto SKX_MC1_CH2_REGISTER_FUNC_ADDR = 2;
constexpr auto SKX_MC1_CH3_REGISTER_FUNC_ADDR = -1; //Does not exist

constexpr auto SERVER_UBOX0_REGISTER_DEV_ADDR = 0;
constexpr auto SERVER_UBOX0_REGISTER_FUNC_ADDR = 1;

constexpr auto KNL_MC1_CH0_REGISTER_DEV_ADDR = 9;
constexpr auto KNL_MC1_CH1_REGISTER_DEV_ADDR = 9;
constexpr auto KNL_MC1_CH2_REGISTER_DEV_ADDR = 9;
constexpr auto KNL_MC1_CH0_REGISTER_FUNC_ADDR = 2;
constexpr auto KNL_MC1_CH1_REGISTER_FUNC_ADDR = 3;
constexpr auto KNL_MC1_CH2_REGISTER_FUNC_ADDR = 4;

constexpr auto KNL_EDC0_ECLK_REGISTER_DEV_ADDR = 24;
constexpr auto KNL_EDC0_ECLK_REGISTER_FUNC_ADDR = 2;
constexpr auto KNL_EDC1_ECLK_REGISTER_DEV_ADDR = 25;
constexpr auto KNL_EDC1_ECLK_REGISTER_FUNC_ADDR = 2;
constexpr auto KNL_EDC2_ECLK_REGISTER_DEV_ADDR = 26;
constexpr auto KNL_EDC2_ECLK_REGISTER_FUNC_ADDR = 2;
constexpr auto KNL_EDC3_ECLK_REGISTER_DEV_ADDR = 27;
constexpr auto KNL_EDC3_ECLK_REGISTER_FUNC_ADDR = 2;
constexpr auto KNL_EDC4_ECLK_REGISTER_DEV_ADDR = 28;
constexpr auto KNL_EDC4_ECLK_REGISTER_FUNC_ADDR = 2;
constexpr auto KNL_EDC5_ECLK_REGISTER_DEV_ADDR = 29;
constexpr auto KNL_EDC5_ECLK_REGISTER_FUNC_ADDR = 2;
constexpr auto KNL_EDC6_ECLK_REGISTER_DEV_ADDR = 30;
constexpr auto KNL_EDC6_ECLK_REGISTER_FUNC_ADDR = 2;
constexpr auto KNL_EDC7_ECLK_REGISTER_DEV_ADDR = 31;
constexpr auto KNL_EDC7_ECLK_REGISTER_FUNC_ADDR = 2;

constexpr auto HSX_HA0_REGISTER_DEV_ADDR = 18;
constexpr auto HSX_HA0_REGISTER_FUNC_ADDR = 1;
constexpr auto HSX_HA1_REGISTER_DEV_ADDR = 18;
constexpr auto HSX_HA1_REGISTER_FUNC_ADDR = 5;

constexpr auto XPF_HA_PCI_PMON_BOX_CTL_ADDR = 0xF4;
constexpr auto XPF_HA_PCI_PMON_CTL0_ADDR = 0xD8 + 4*0;
constexpr auto XPF_HA_PCI_PMON_CTL1_ADDR = 0xD8 + 4*1;
constexpr auto XPF_HA_PCI_PMON_CTL2_ADDR = 0xD8 + 4*2;
constexpr auto XPF_HA_PCI_PMON_CTL3_ADDR = 0xD8 + 4*3;
constexpr auto XPF_HA_PCI_PMON_CTR0_ADDR = 0xA0 + 8*0;
constexpr auto XPF_HA_PCI_PMON_CTR1_ADDR = 0xA0 + 8*1;
constexpr auto XPF_HA_PCI_PMON_CTR2_ADDR = 0xA0 + 8*2;
constexpr auto XPF_HA_PCI_PMON_CTR3_ADDR = 0xA0 + 8*3;
constexpr auto BHS_PCIE_GEN5_PCI_PMON_BOX_CTL_ADDR = 0x620;
constexpr auto BHS_PCIE_GEN5_PCI_PMON_CTL0_ADDR = 0x630;
constexpr auto BHS_PCIE_GEN5_PCI_PMON_CTR0_ADDR = 0x650;

/**
 * XPF_ for Xeons: SNB, IVT, HSX, BDW, etc.
 * KNX_ for Xeon Phi (Knights *) processors
 */
constexpr auto XPF_MC_CH_PCI_PMON_BOX_CTL_ADDR = 0x0F4;
constexpr auto KNX_MC_CH_PCI_PMON_BOX_CTL_ADDR = 0xB30;
constexpr auto KNX_EDC_CH_PCI_PMON_BOX_CTL_ADDR = 0xA30;

//! for Xeons
constexpr auto XPF_MC_CH_PCI_PMON_FIXED_CTL_ADDR = 0x0F0;
constexpr auto XPF_MC_CH_PCI_PMON_CTL3_ADDR = 0x0E4;
constexpr auto XPF_MC_CH_PCI_PMON_CTL2_ADDR = 0x0E0;
constexpr auto XPF_MC_CH_PCI_PMON_CTL1_ADDR = 0x0DC;
constexpr auto XPF_MC_CH_PCI_PMON_CTL0_ADDR = 0x0D8;

//! KNL IMC
constexpr auto KNX_MC_CH_PCI_PMON_FIXED_CTL_ADDR = 0xB44;
constexpr auto KNX_MC_CH_PCI_PMON_CTL3_ADDR = 0xB2C;
constexpr auto KNX_MC_CH_PCI_PMON_CTL2_ADDR = 0xB28;
constexpr auto KNX_MC_CH_PCI_PMON_CTL1_ADDR = 0xB24;
constexpr auto KNX_MC_CH_PCI_PMON_CTL0_ADDR = 0xB20;

//! KNL EDC ECLK
constexpr auto KNX_EDC_CH_PCI_PMON_FIXED_CTL_ADDR = 0xA44;
constexpr auto KNX_EDC_CH_PCI_PMON_CTL3_ADDR = 0xA2C;
constexpr auto KNX_EDC_CH_PCI_PMON_CTL2_ADDR = 0xA28;
constexpr auto KNX_EDC_CH_PCI_PMON_CTL1_ADDR = 0xA24;
constexpr auto KNX_EDC_CH_PCI_PMON_CTL0_ADDR = 0xA20;
constexpr auto KNX_EDC_ECLK_PMON_UNIT_CTL_REG = 0xA30;

//! for Xeons
constexpr auto XPF_MC_CH_PCI_PMON_FIXED_CTR_ADDR = 0x0D0;
constexpr auto XPF_MC_CH_PCI_PMON_CTR3_ADDR = 0x0B8;
constexpr auto XPF_MC_CH_PCI_PMON_CTR2_ADDR = 0x0B0;
constexpr auto XPF_MC_CH_PCI_PMON_CTR1_ADDR = 0x0A8;
constexpr auto XPF_MC_CH_PCI_PMON_CTR0_ADDR = 0x0A0;

//! for KNL IMC
constexpr auto KNX_MC_CH_PCI_PMON_FIXED_CTR_ADDR = 0xB3C;
constexpr auto KNX_MC_CH_PCI_PMON_CTR3_ADDR = 0xB18;
constexpr auto KNX_MC_CH_PCI_PMON_CTR2_ADDR = 0xB10;
constexpr auto KNX_MC_CH_PCI_PMON_CTR1_ADDR = 0xB08;
constexpr auto KNX_MC_CH_PCI_PMON_CTR0_ADDR = 0xB00;

//! for KNL EDC ECLK
constexpr auto KNX_EDC_CH_PCI_PMON_FIXED_CTR_ADDR = 0xA3C;
constexpr auto KNX_EDC_CH_PCI_PMON_CTR3_ADDR = 0xA18;
constexpr auto KNX_EDC_CH_PCI_PMON_CTR2_ADDR = 0xA10;
constexpr auto KNX_EDC_CH_PCI_PMON_CTR1_ADDR = 0xA08;
constexpr auto KNX_EDC_CH_PCI_PMON_CTR0_ADDR = 0xA00;

constexpr auto SERVER_HBM_CH_PMON_BASE_ADDR = 0x141c00;
constexpr auto SERVER_HBM_CH_PMON_STEP = 0x4000;
constexpr auto SERVER_HBM_CH_PMON_SIZE = 0x1000;
constexpr auto SERVER_HBM_BOX_PMON_STEP = 0x9000;

constexpr auto SERVER_MC_CH_PMON_BASE_ADDR = 0x22800;
constexpr auto SERVER_MC_CH_PMON_STEP = 0x4000;
constexpr auto SERVER_MC_CH_PMON_SIZE = 0x1000;
constexpr auto SERVER_MC_CH_PMON_BOX_CTL_OFFSET = 0x00;
constexpr auto SERVER_MC_CH_PMON_CTL0_OFFSET = 0x40;
constexpr auto SERVER_MC_CH_PMON_CTL1_OFFSET = SERVER_MC_CH_PMON_CTL0_OFFSET + 4*1;
constexpr auto SERVER_MC_CH_PMON_CTL2_OFFSET = SERVER_MC_CH_PMON_CTL0_OFFSET + 4*2;
constexpr auto SERVER_MC_CH_PMON_CTL3_OFFSET = SERVER_MC_CH_PMON_CTL0_OFFSET + 4*3;
constexpr auto SERVER_MC_CH_PMON_CTR0_OFFSET = 0x08;
constexpr auto SERVER_MC_CH_PMON_CTR1_OFFSET = SERVER_MC_CH_PMON_CTR0_OFFSET + 8*1;
constexpr auto SERVER_MC_CH_PMON_CTR2_OFFSET = SERVER_MC_CH_PMON_CTR0_OFFSET + 8*2;
constexpr auto SERVER_MC_CH_PMON_CTR3_OFFSET = SERVER_MC_CH_PMON_CTR0_OFFSET + 8*3;
constexpr auto SERVER_MC_CH_PMON_FIXED_CTL_OFFSET = 0x54;
constexpr auto SERVER_MC_CH_PMON_FIXED_CTR_OFFSET = 0x38;
constexpr auto BHS_MC_CH_PMON_BASE_ADDR = 0x024e800;
constexpr auto GNR_D_A_MC_CH_PMON_BASE_ADDR = 0x0104800;
constexpr auto GNR_D_B_MC_CH_PMON_BASE_ADDR = 0x0208800;

constexpr auto JKTIVT_QPI_PORT0_REGISTER_DEV_ADDR = 8;
constexpr auto JKTIVT_QPI_PORT0_REGISTER_FUNC_ADDR = 2;
constexpr auto JKTIVT_QPI_PORT1_REGISTER_DEV_ADDR = 9;
constexpr auto JKTIVT_QPI_PORT1_REGISTER_FUNC_ADDR = 2;
constexpr auto JKTIVT_QPI_PORT2_REGISTER_DEV_ADDR = 24;
constexpr auto JKTIVT_QPI_PORT2_REGISTER_FUNC_ADDR = 2;

constexpr auto HSX_QPI_PORT0_REGISTER_DEV_ADDR = 8;
constexpr auto HSX_QPI_PORT0_REGISTER_FUNC_ADDR = 2;
constexpr auto HSX_QPI_PORT1_REGISTER_DEV_ADDR = 9;
constexpr auto HSX_QPI_PORT1_REGISTER_FUNC_ADDR = 2;
constexpr auto HSX_QPI_PORT2_REGISTER_DEV_ADDR = 10;
constexpr auto HSX_QPI_PORT2_REGISTER_FUNC_ADDR = 2;

constexpr auto SKX_QPI_PORT0_REGISTER_DEV_ADDR = 14;
constexpr auto SKX_QPI_PORT0_REGISTER_FUNC_ADDR = 0;
constexpr auto SKX_QPI_PORT1_REGISTER_DEV_ADDR = 15;
constexpr auto SKX_QPI_PORT1_REGISTER_FUNC_ADDR = 0;
constexpr auto SKX_QPI_PORT2_REGISTER_DEV_ADDR = 16;
constexpr auto SKX_QPI_PORT2_REGISTER_FUNC_ADDR = 0;

constexpr auto CPX_QPI_PORT3_REGISTER_DEV_ADDR = 14;
constexpr auto CPX_QPI_PORT3_REGISTER_FUNC_ADDR = 4;
constexpr auto CPX_QPI_PORT4_REGISTER_DEV_ADDR = 15;
constexpr auto CPX_QPI_PORT4_REGISTER_FUNC_ADDR = 4;
constexpr auto CPX_QPI_PORT5_REGISTER_DEV_ADDR = 16;
constexpr auto CPX_QPI_PORT5_REGISTER_FUNC_ADDR = 4;

constexpr auto ICX_QPI_PORT0_REGISTER_DEV_ADDR = 2;
constexpr auto ICX_QPI_PORT0_REGISTER_FUNC_ADDR = 1;
constexpr auto ICX_QPI_PORT1_REGISTER_DEV_ADDR = 3;
constexpr auto ICX_QPI_PORT1_REGISTER_FUNC_ADDR = 1;
constexpr auto ICX_QPI_PORT2_REGISTER_DEV_ADDR = 4;
constexpr auto ICX_QPI_PORT2_REGISTER_FUNC_ADDR = 1;

constexpr auto SPR_QPI_PORT0_REGISTER_DEV_ADDR = 1;
constexpr auto SPR_QPI_PORT0_REGISTER_FUNC_ADDR = 1;

constexpr auto SPR_QPI_PORT1_REGISTER_DEV_ADDR = 2;
constexpr auto SPR_QPI_PORT1_REGISTER_FUNC_ADDR = 1;

constexpr auto SPR_QPI_PORT2_REGISTER_DEV_ADDR = 3;
constexpr auto SPR_QPI_PORT2_REGISTER_FUNC_ADDR = 1;

constexpr auto SPR_QPI_PORT3_REGISTER_DEV_ADDR = 4;
constexpr auto SPR_QPI_PORT3_REGISTER_FUNC_ADDR = 1;
constexpr auto BHS_QPI_PORT0_REGISTER_DEV_ADDR = 16;
constexpr auto BHS_QPI_PORT0_REGISTER_FUNC_ADDR = 1;

constexpr auto BHS_QPI_PORT1_REGISTER_DEV_ADDR = 17;
constexpr auto BHS_QPI_PORT1_REGISTER_FUNC_ADDR = 1;

constexpr auto BHS_QPI_PORT2_REGISTER_DEV_ADDR = 18;
constexpr auto BHS_QPI_PORT2_REGISTER_FUNC_ADDR = 1;

constexpr auto BHS_QPI_PORT3_REGISTER_DEV_ADDR = 19;
constexpr auto BHS_QPI_PORT3_REGISTER_FUNC_ADDR = 1;

constexpr auto BHS_QPI_PORT4_REGISTER_DEV_ADDR = 20;
constexpr auto BHS_QPI_PORT4_REGISTER_FUNC_ADDR = 1;

constexpr auto BHS_QPI_PORT5_REGISTER_DEV_ADDR = 21;
constexpr auto BHS_QPI_PORT5_REGISTER_FUNC_ADDR = 1;

constexpr auto QPI_PORT0_MISC_REGISTER_FUNC_ADDR = 0;
constexpr auto QPI_PORT1_MISC_REGISTER_FUNC_ADDR = 0;
constexpr auto QPI_PORT2_MISC_REGISTER_FUNC_ADDR = 0;

constexpr auto SKX_M3UPI_PORT0_REGISTER_DEV_ADDR = (0x12);
constexpr auto SKX_M3UPI_PORT0_REGISTER_FUNC_ADDR = (1);
constexpr auto SKX_M3UPI_PORT1_REGISTER_DEV_ADDR = (0x12);
constexpr auto SKX_M3UPI_PORT1_REGISTER_FUNC_ADDR = (2);
constexpr auto SKX_M3UPI_PORT2_REGISTER_DEV_ADDR = (0x12);
constexpr auto SKX_M3UPI_PORT2_REGISTER_FUNC_ADDR = (5);

constexpr auto CPX_M3UPI_PORT0_REGISTER_DEV_ADDR = (0x12);
constexpr auto CPX_M3UPI_PORT0_REGISTER_FUNC_ADDR = (1);
constexpr auto CPX_M3UPI_PORT1_REGISTER_DEV_ADDR = (0x12);
constexpr auto CPX_M3UPI_PORT1_REGISTER_FUNC_ADDR = (2);
constexpr auto CPX_M3UPI_PORT2_REGISTER_DEV_ADDR = (0x13);
constexpr auto CPX_M3UPI_PORT2_REGISTER_FUNC_ADDR = (1);
constexpr auto CPX_M3UPI_PORT3_REGISTER_DEV_ADDR = (0x13);
constexpr auto CPX_M3UPI_PORT3_REGISTER_FUNC_ADDR = (2);
constexpr auto CPX_M3UPI_PORT4_REGISTER_DEV_ADDR = (0x14);
constexpr auto CPX_M3UPI_PORT4_REGISTER_FUNC_ADDR = (1);
constexpr auto CPX_M3UPI_PORT5_REGISTER_DEV_ADDR = (0x14);
constexpr auto CPX_M3UPI_PORT5_REGISTER_FUNC_ADDR = (2);

constexpr auto ICX_M3UPI_PORT0_REGISTER_DEV_ADDR = (5);
constexpr auto ICX_M3UPI_PORT1_REGISTER_DEV_ADDR = (6);
constexpr auto ICX_M3UPI_PORT2_REGISTER_DEV_ADDR = (7);
constexpr auto ICX_M3UPI_PORT0_REGISTER_FUNC_ADDR = (1);
constexpr auto ICX_M3UPI_PORT1_REGISTER_FUNC_ADDR = (1);
constexpr auto ICX_M3UPI_PORT2_REGISTER_FUNC_ADDR = (1);

constexpr auto SPR_M3UPI_PORT0_REGISTER_DEV_ADDR = 5;
constexpr auto SPR_M3UPI_PORT1_REGISTER_DEV_ADDR = 6;
constexpr auto SPR_M3UPI_PORT2_REGISTER_DEV_ADDR = 7;
constexpr auto SPR_M3UPI_PORT3_REGISTER_DEV_ADDR = 8;
constexpr auto SPR_M3UPI_PORT0_REGISTER_FUNC_ADDR = 1;
constexpr auto SPR_M3UPI_PORT1_REGISTER_FUNC_ADDR = 1;
constexpr auto SPR_M3UPI_PORT2_REGISTER_FUNC_ADDR = 1;
constexpr auto SPR_M3UPI_PORT3_REGISTER_FUNC_ADDR = 1;

constexpr auto SKX_M2M_0_REGISTER_DEV_ADDR = 8;
constexpr auto SKX_M2M_0_REGISTER_FUNC_ADDR = 0;
constexpr auto SKX_M2M_1_REGISTER_DEV_ADDR = 9;
constexpr auto SKX_M2M_1_REGISTER_FUNC_ADDR = 0;

constexpr auto SERVER_M2M_0_REGISTER_DEV_ADDR = 12;
constexpr auto SERVER_M2M_0_REGISTER_FUNC_ADDR = 0;
constexpr auto SERVER_M2M_1_REGISTER_DEV_ADDR = 13;
constexpr auto SERVER_M2M_1_REGISTER_FUNC_ADDR = 0;
constexpr auto SERVER_M2M_2_REGISTER_DEV_ADDR = 14;
constexpr auto SERVER_M2M_2_REGISTER_FUNC_ADDR = 0;
constexpr auto SERVER_M2M_3_REGISTER_DEV_ADDR = 15;
constexpr auto SERVER_M2M_3_REGISTER_FUNC_ADDR = 0;

constexpr auto SERVER_HBM_M2M_0_REGISTER_DEV_ADDR = 12;
constexpr auto SERVER_HBM_M2M_0_REGISTER_FUNC_ADDR = 1;
constexpr auto SERVER_HBM_M2M_1_REGISTER_DEV_ADDR = 13;
constexpr auto SERVER_HBM_M2M_1_REGISTER_FUNC_ADDR = 1;
constexpr auto SERVER_HBM_M2M_2_REGISTER_DEV_ADDR = 14;
constexpr auto SERVER_HBM_M2M_2_REGISTER_FUNC_ADDR = 1;
constexpr auto SERVER_HBM_M2M_3_REGISTER_DEV_ADDR = 15;
constexpr auto SERVER_HBM_M2M_3_REGISTER_FUNC_ADDR = 1;

constexpr auto SERVER_HBM_M2M_4_REGISTER_DEV_ADDR = 12;
constexpr auto SERVER_HBM_M2M_4_REGISTER_FUNC_ADDR = 2;
constexpr auto SERVER_HBM_M2M_5_REGISTER_DEV_ADDR = 13;
constexpr auto SERVER_HBM_M2M_5_REGISTER_FUNC_ADDR = 2;
constexpr auto SERVER_HBM_M2M_6_REGISTER_DEV_ADDR = 14;
constexpr auto SERVER_HBM_M2M_6_REGISTER_FUNC_ADDR = 2;
constexpr auto SERVER_HBM_M2M_7_REGISTER_DEV_ADDR = 15;
constexpr auto SERVER_HBM_M2M_7_REGISTER_FUNC_ADDR = 2;

constexpr auto SERVER_HBM_M2M_8_REGISTER_DEV_ADDR = 12;
constexpr auto SERVER_HBM_M2M_8_REGISTER_FUNC_ADDR = 3;
constexpr auto SERVER_HBM_M2M_9_REGISTER_DEV_ADDR = 13;
constexpr auto SERVER_HBM_M2M_9_REGISTER_FUNC_ADDR = 3;
constexpr auto SERVER_HBM_M2M_10_REGISTER_DEV_ADDR = 14;
constexpr auto SERVER_HBM_M2M_10_REGISTER_FUNC_ADDR = 3;
constexpr auto SERVER_HBM_M2M_11_REGISTER_DEV_ADDR = 15;
constexpr auto SERVER_HBM_M2M_11_REGISTER_FUNC_ADDR = 3;

constexpr auto SERVER_HBM_M2M_12_REGISTER_DEV_ADDR = 12;
constexpr auto SERVER_HBM_M2M_12_REGISTER_FUNC_ADDR = 4;
constexpr auto SERVER_HBM_M2M_13_REGISTER_DEV_ADDR = 13;
constexpr auto SERVER_HBM_M2M_13_REGISTER_FUNC_ADDR = 4;
constexpr auto SERVER_HBM_M2M_14_REGISTER_DEV_ADDR = 14;
constexpr auto SERVER_HBM_M2M_14_REGISTER_FUNC_ADDR = 4;
constexpr auto SERVER_HBM_M2M_15_REGISTER_DEV_ADDR = 15;
constexpr auto SERVER_HBM_M2M_15_REGISTER_FUNC_ADDR = 4;


// BHS B2CMI (M2M)
constexpr auto BHS_M2M_0_REGISTER_DEV_ADDR = 5;
constexpr auto BHS_M2M_0_REGISTER_FUNC_ADDR = 1;
constexpr auto BHS_M2M_1_REGISTER_DEV_ADDR = 5;
constexpr auto BHS_M2M_1_REGISTER_FUNC_ADDR = 2;
constexpr auto BHS_M2M_2_REGISTER_DEV_ADDR = 5;
constexpr auto BHS_M2M_2_REGISTER_FUNC_ADDR = 3;
constexpr auto BHS_M2M_3_REGISTER_DEV_ADDR = 5;
constexpr auto BHS_M2M_3_REGISTER_FUNC_ADDR = 4;
constexpr auto BHS_M2M_4_REGISTER_DEV_ADDR = 5;
constexpr auto BHS_M2M_4_REGISTER_FUNC_ADDR = 5;
constexpr auto BHS_M2M_5_REGISTER_DEV_ADDR = 5;
constexpr auto BHS_M2M_5_REGISTER_FUNC_ADDR = 6;
constexpr auto BHS_M2M_6_REGISTER_DEV_ADDR = 5;
constexpr auto BHS_M2M_6_REGISTER_FUNC_ADDR = 7;
constexpr auto BHS_M2M_7_REGISTER_DEV_ADDR = 6;
constexpr auto BHS_M2M_7_REGISTER_FUNC_ADDR = 1;
constexpr auto BHS_M2M_8_REGISTER_DEV_ADDR = 6;
constexpr auto BHS_M2M_8_REGISTER_FUNC_ADDR = 2;
constexpr auto BHS_M2M_9_REGISTER_DEV_ADDR = 6;
constexpr auto BHS_M2M_9_REGISTER_FUNC_ADDR = 3;
constexpr auto BHS_M2M_10_REGISTER_DEV_ADDR = 6;
constexpr auto BHS_M2M_10_REGISTER_FUNC_ADDR = 4;
constexpr auto BHS_M2M_11_REGISTER_DEV_ADDR = 6;
constexpr auto BHS_M2M_11_REGISTER_FUNC_ADDR = 5;

// BHS B2UPI (M3UPI)
constexpr auto BHS_M3UPI_PORT0_REGISTER_DEV_ADDR = 24;
constexpr auto BHS_M3UPI_PORT1_REGISTER_DEV_ADDR = 25;
constexpr auto BHS_M3UPI_PORT2_REGISTER_DEV_ADDR = 26;
constexpr auto BHS_M3UPI_PORT3_REGISTER_DEV_ADDR = 27;
constexpr auto BHS_M3UPI_PORT4_REGISTER_DEV_ADDR = 28;
constexpr auto BHS_M3UPI_PORT5_REGISTER_DEV_ADDR = 29;
constexpr auto BHS_M3UPI_PORT0_REGISTER_FUNC_ADDR = 0;
constexpr auto BHS_M3UPI_PORT1_REGISTER_FUNC_ADDR = 0;
constexpr auto BHS_M3UPI_PORT2_REGISTER_FUNC_ADDR = 0;
constexpr auto BHS_M3UPI_PORT3_REGISTER_FUNC_ADDR = 0;
constexpr auto BHS_M3UPI_PORT4_REGISTER_FUNC_ADDR = 0;
constexpr auto BHS_M3UPI_PORT5_REGISTER_FUNC_ADDR = 0;

constexpr auto SKX_M2M_PCI_PMON_BOX_CTL_ADDR = 0x258;

constexpr auto SKX_M2M_PCI_PMON_CTL0_ADDR = 0x228;
constexpr auto SKX_M2M_PCI_PMON_CTL1_ADDR = 0x230;
constexpr auto SKX_M2M_PCI_PMON_CTL2_ADDR = 0x238;
constexpr auto SKX_M2M_PCI_PMON_CTL3_ADDR = 0x240;

constexpr auto SKX_M2M_PCI_PMON_CTR0_ADDR = 0x200;
constexpr auto SKX_M2M_PCI_PMON_CTR1_ADDR = 0x208;
constexpr auto SKX_M2M_PCI_PMON_CTR2_ADDR = 0x210;
constexpr auto SKX_M2M_PCI_PMON_CTR3_ADDR = 0x218;

constexpr auto SERVER_M2M_PCI_PMON_BOX_CTL_ADDR = 0x438;

constexpr auto SERVER_M2M_PCI_PMON_CTL0_ADDR = 0x468;
constexpr auto SERVER_M2M_PCI_PMON_CTL1_ADDR = SERVER_M2M_PCI_PMON_CTL0_ADDR + 1*8;
constexpr auto SERVER_M2M_PCI_PMON_CTL2_ADDR = SERVER_M2M_PCI_PMON_CTL0_ADDR + 2*8;
constexpr auto SERVER_M2M_PCI_PMON_CTL3_ADDR = SERVER_M2M_PCI_PMON_CTL0_ADDR + 3*8;

constexpr auto SERVER_M2M_PCI_PMON_CTR0_ADDR = 0x440;
constexpr auto SERVER_M2M_PCI_PMON_CTR1_ADDR = SERVER_M2M_PCI_PMON_CTR0_ADDR + 1*8;
constexpr auto SERVER_M2M_PCI_PMON_CTR2_ADDR = SERVER_M2M_PCI_PMON_CTR0_ADDR + 2*8;
constexpr auto SERVER_M2M_PCI_PMON_CTR3_ADDR = SERVER_M2M_PCI_PMON_CTR0_ADDR + 3*8;

constexpr auto M3UPI_PCI_PMON_BOX_CTL_ADDR = (0xF4);

constexpr auto M3UPI_PCI_PMON_CTL0_ADDR = (0xD8);
constexpr auto M3UPI_PCI_PMON_CTL1_ADDR = (0xDC);
constexpr auto M3UPI_PCI_PMON_CTL2_ADDR = (0xE0);

constexpr auto M3UPI_PCI_PMON_CTR0_ADDR = (0xA0);
constexpr auto M3UPI_PCI_PMON_CTR1_ADDR = (0xA8);
constexpr auto M3UPI_PCI_PMON_CTR2_ADDR = (0xB0);

constexpr auto ICX_M3UPI_PCI_PMON_BOX_CTL_ADDR = (0xA0);

constexpr auto ICX_M3UPI_PCI_PMON_CTL0_ADDR = (0xD8);
constexpr auto ICX_M3UPI_PCI_PMON_CTL1_ADDR = (0xDC);
constexpr auto ICX_M3UPI_PCI_PMON_CTL2_ADDR = (0xE0);
constexpr auto ICX_M3UPI_PCI_PMON_CTL3_ADDR = (0xE4);

constexpr auto ICX_M3UPI_PCI_PMON_CTR0_ADDR = (0xA8);
constexpr auto ICX_M3UPI_PCI_PMON_CTR1_ADDR = (0xB0);
constexpr auto ICX_M3UPI_PCI_PMON_CTR2_ADDR = (0xB8);
constexpr auto ICX_M3UPI_PCI_PMON_CTR3_ADDR = (0xC0);

constexpr auto BHS_M3UPI_PCI_PMON_BOX_CTL_ADDR = (0x408);

constexpr auto BHS_M3UPI_PCI_PMON_CTL0_ADDR = (0x430);
constexpr auto BHS_M3UPI_PCI_PMON_CTL1_ADDR = (0x438);
constexpr auto BHS_M3UPI_PCI_PMON_CTL2_ADDR = (0x440);
constexpr auto BHS_M3UPI_PCI_PMON_CTL3_ADDR = (0x448);

constexpr auto BHS_M3UPI_PCI_PMON_CTR0_ADDR = (0x410);
constexpr auto BHS_M3UPI_PCI_PMON_CTR1_ADDR = (0x418);
constexpr auto BHS_M3UPI_PCI_PMON_CTR2_ADDR = (0x420);
constexpr auto BHS_M3UPI_PCI_PMON_CTR3_ADDR = (0x428);

constexpr auto MSR_UNCORE_PMON_GLOBAL_CTL = 0x700;

constexpr auto IVT_MSR_UNCORE_PMON_GLOBAL_CTL = 0x0C00;

constexpr auto SPR_MSR_UNCORE_PMON_GLOBAL_CTL = 0x2FF0;

constexpr auto PCM_INVALID_DEV_ADDR = ~(uint32)0UL;
constexpr auto PCM_INVALID_FUNC_ADDR = ~(uint32)0UL;

constexpr auto Q_P_PCI_PMON_BOX_CTL_ADDR = 0x0F4;

constexpr auto Q_P_PCI_PMON_CTL3_ADDR = 0x0E4;
constexpr auto Q_P_PCI_PMON_CTL2_ADDR = 0x0E0;
constexpr auto Q_P_PCI_PMON_CTL1_ADDR = 0x0DC;
constexpr auto Q_P_PCI_PMON_CTL0_ADDR = 0x0D8;

constexpr auto Q_P_PCI_PMON_CTR3_ADDR = 0x0B8;
constexpr auto Q_P_PCI_PMON_CTR2_ADDR = 0x0B0;
constexpr auto Q_P_PCI_PMON_CTR1_ADDR = 0x0A8;
constexpr auto Q_P_PCI_PMON_CTR0_ADDR = 0x0A0;

constexpr auto QPI_RATE_STATUS_ADDR = 0x0D4;

constexpr auto U_L_PCI_PMON_BOX_CTL_ADDR = 0x378;

constexpr auto U_L_PCI_PMON_CTL3_ADDR = 0x368;
constexpr auto U_L_PCI_PMON_CTL2_ADDR = 0x360;
constexpr auto U_L_PCI_PMON_CTL1_ADDR = 0x358;
constexpr auto U_L_PCI_PMON_CTL0_ADDR = 0x350;

constexpr auto U_L_PCI_PMON_CTR3_ADDR = 0x330;
constexpr auto U_L_PCI_PMON_CTR2_ADDR = 0x328;
constexpr auto U_L_PCI_PMON_CTR1_ADDR = 0x320;
constexpr auto U_L_PCI_PMON_CTR0_ADDR = 0x318;

constexpr auto ICX_UPI_PCI_PMON_BOX_CTL_ADDR = 0x318;

constexpr auto ICX_UPI_PCI_PMON_CTL3_ADDR = 0x368;
constexpr auto ICX_UPI_PCI_PMON_CTL2_ADDR = 0x360;
constexpr auto ICX_UPI_PCI_PMON_CTL1_ADDR = 0x358;
constexpr auto ICX_UPI_PCI_PMON_CTL0_ADDR = 0x350;

constexpr auto ICX_UPI_PCI_PMON_CTR3_ADDR = 0x338;
constexpr auto ICX_UPI_PCI_PMON_CTR2_ADDR = 0x330;
constexpr auto ICX_UPI_PCI_PMON_CTR1_ADDR = 0x328;
constexpr auto ICX_UPI_PCI_PMON_CTR0_ADDR = 0x320;
constexpr auto SPR_UPI_PCI_PMON_BOX_CTL_ADDR =  0x318;
constexpr auto SPR_UPI_PCI_PMON_CTL0_ADDR =     0x350;
constexpr auto SPR_UPI_PCI_PMON_CTR0_ADDR = 0x320;

constexpr auto UCLK_FIXED_CTR_ADDR = 0x704;
constexpr auto UCLK_FIXED_CTL_ADDR = 0x703;
constexpr auto UBOX_MSR_PMON_CTL0_ADDR = 0x705;
constexpr auto UBOX_MSR_PMON_CTL1_ADDR = 0x706;
constexpr auto UBOX_MSR_PMON_CTR0_ADDR = 0x709;
constexpr auto UBOX_MSR_PMON_CTR1_ADDR = 0x70a;

constexpr auto SPR_UCLK_FIXED_CTR_ADDR = 0x2FDF;
constexpr auto SPR_UCLK_FIXED_CTL_ADDR = 0x2FDE;
constexpr auto SPR_UBOX_MSR_PMON_BOX_CTL_ADDR = 0x2FD0;
constexpr auto SPR_UBOX_MSR_PMON_CTL0_ADDR = 0x2FD2;
constexpr auto SPR_UBOX_MSR_PMON_CTL1_ADDR = 0x2FD3;
constexpr auto SPR_UBOX_MSR_PMON_CTR0_ADDR = 0X2FD8;
constexpr auto SPR_UBOX_MSR_PMON_CTR1_ADDR = 0X2FD9;

constexpr auto BHS_UCLK_FIXED_CTR_ADDR = 0x3FFD;
constexpr auto BHS_UCLK_FIXED_CTL_ADDR = 0x3FFE;
constexpr auto BHS_UBOX_MSR_PMON_BOX_CTL_ADDR = 0x3FF0;
constexpr auto BHS_UBOX_MSR_PMON_CTL0_ADDR = 0x3FF2;
constexpr auto BHS_UBOX_MSR_PMON_CTL1_ADDR = 0x3FF3;
constexpr auto BHS_UBOX_MSR_PMON_CTR0_ADDR = 0x3FF8;
constexpr auto BHS_UBOX_MSR_PMON_CTR1_ADDR = 0x3FF9;

constexpr auto GRR_UCLK_FIXED_CTR_ADDR        = 0x3F5F;
constexpr auto GRR_UCLK_FIXED_CTL_ADDR        = 0x3F5E;
constexpr auto GRR_UBOX_MSR_PMON_BOX_CTL_ADDR = 0x3F50;
constexpr auto GRR_UBOX_MSR_PMON_CTL0_ADDR    = 0x3F52;
constexpr auto GRR_UBOX_MSR_PMON_CTL1_ADDR    = 0x3F53;
constexpr auto GRR_UBOX_MSR_PMON_CTR0_ADDR    = 0x3F58;
constexpr auto GRR_UBOX_MSR_PMON_CTR1_ADDR    = 0x3F59;

constexpr auto GRR_M2IOSF_IIO_UNIT_CTL = 0x2900;
constexpr auto GRR_M2IOSF_IIO_CTR0     = 0x2908;
constexpr auto GRR_M2IOSF_IIO_CTL0     = 0x2902;
constexpr auto GRR_M2IOSF_REG_STEP = 0x10;
constexpr auto GRR_M2IOSF_NUM      = 3;

constexpr auto JKTIVT_UCLK_FIXED_CTR_ADDR = (0x0C09);
constexpr auto JKTIVT_UCLK_FIXED_CTL_ADDR = (0x0C08);
constexpr auto JKTIVT_UBOX_MSR_PMON_CTL0_ADDR = (0x0C10);
constexpr auto JKTIVT_UBOX_MSR_PMON_CTL1_ADDR = (0x0C11);
constexpr auto JKTIVT_UBOX_MSR_PMON_CTR0_ADDR = (0x0C16);
constexpr auto JKTIVT_UBOX_MSR_PMON_CTR1_ADDR = (0x0C17);

#define JKTIVT_PCU_MSR_PMON_CTR3_ADDR (0x0C39)
#define JKTIVT_PCU_MSR_PMON_CTR2_ADDR (0x0C38)
#define JKTIVT_PCU_MSR_PMON_CTR1_ADDR (0x0C37)
#define JKTIVT_PCU_MSR_PMON_CTR0_ADDR (0x0C36)

#define JKTIVT_PCU_MSR_PMON_BOX_FILTER_ADDR (0x0C34)

#define JKTIVT_PCU_MSR_PMON_CTL3_ADDR (0x0C33)
#define JKTIVT_PCU_MSR_PMON_CTL2_ADDR (0x0C32)
#define JKTIVT_PCU_MSR_PMON_CTL1_ADDR (0x0C31)
#define JKTIVT_PCU_MSR_PMON_CTL0_ADDR (0x0C30)

#define JKTIVT_PCU_MSR_PMON_BOX_CTL_ADDR (0x0C24)

#define HSX_PCU_MSR_PMON_CTR3_ADDR (0x071A)
#define HSX_PCU_MSR_PMON_CTR2_ADDR (0x0719)
#define HSX_PCU_MSR_PMON_CTR1_ADDR (0x0718)
#define HSX_PCU_MSR_PMON_CTR0_ADDR (0x0717)

#define HSX_PCU_MSR_PMON_BOX_FILTER_ADDR (0x0715)

#define HSX_PCU_MSR_PMON_CTL3_ADDR (0x0714)
#define HSX_PCU_MSR_PMON_CTL2_ADDR (0x0713)
#define HSX_PCU_MSR_PMON_CTL1_ADDR (0x0712)
#define HSX_PCU_MSR_PMON_CTL0_ADDR (0x0711)

#define HSX_PCU_MSR_PMON_BOX_CTL_ADDR (0x0710)

#define UNC_PMON_UNIT_CTL_RST_CONTROL  (1 << 0)
#define UNC_PMON_UNIT_CTL_RST_COUNTERS     (1 << 1)
#define UNC_PMON_UNIT_CTL_FRZ  (1 << 8)
#define UNC_PMON_UNIT_CTL_FRZ_EN   (1 << 16)
#define UNC_PMON_UNIT_CTL_RSV  ((1 << 16) + (1 << 17))

#define SPR_UNC_PMON_UNIT_CTL_FRZ          (1 << 0)
#define SPR_UNC_PMON_UNIT_CTL_RST_CONTROL  (1 << 8)
#define SPR_UNC_PMON_UNIT_CTL_RST_COUNTERS (1 << 9)

#define UNC_PMON_UNIT_CTL_VALID_BITS_MASK  ((1 << 17) - 1)

#define MC_CH_PCI_PMON_FIXED_CTL_RST (1 << 19)
#define MC_CH_PCI_PMON_FIXED_CTL_EN (1 << 22)
#define EDC_CH_PCI_PMON_FIXED_CTL_EN (1 << 0)

#define MC_CH_PCI_PMON_CTL_EVENT(x) (x << 0)
#define MC_CH_PCI_PMON_CTL_UMASK(x) (x << 8)
#define MC_CH_PCI_PMON_CTL_RST (1 << 17)
#define MC_CH_PCI_PMON_CTL_EDGE_DET (1 << 18)
#define MC_CH_PCI_PMON_CTL_EN (1 << 22)
#define MC_CH_PCI_PMON_CTL_INVERT (1 << 23)
#define MC_CH_PCI_PMON_CTL_THRESH(x) (x << 24UL)

#define Q_P_PCI_PMON_CTL_EVENT(x)   (x << 0)
#define Q_P_PCI_PMON_CTL_UMASK(x)   (x << 8)
#define Q_P_PCI_PMON_CTL_RST        (1 << 17)
#define Q_P_PCI_PMON_CTL_EDGE_DET   (1 << 18)
#define Q_P_PCI_PMON_CTL_EVENT_EXT  (1 << 21)
#define Q_P_PCI_PMON_CTL_EN         (1 << 22)
#define Q_P_PCI_PMON_CTL_INVERT     (1 << 23)
#define Q_P_PCI_PMON_CTL_THRESH(x)  (x << 24UL)

#define PCU_MSR_PMON_BOX_FILTER_BAND_0(x) (x << 0)
#define PCU_MSR_PMON_BOX_FILTER_BAND_1(x) (x << 8)
#define PCU_MSR_PMON_BOX_FILTER_BAND_2(x) (x << 16)
#define PCU_MSR_PMON_BOX_FILTER_BAND_3(x) (x << 24)

#define PCU_MSR_PMON_CTL_EVENT(x) (x << 0)
#define PCU_MSR_PMON_CTL_OCC_SEL(x) (x << 14)
#define PCU_MSR_PMON_CTL_RST    (1 << 17)
#define PCU_MSR_PMON_CTL_EDGE_DET (1 << 18)
#define PCU_MSR_PMON_CTL_EXTRA_SEL (1 << 21)
#define PCU_MSR_PMON_CTL_EN (1 << 22)
#define PCU_MSR_PMON_CTL_INVERT (1 << 23)
#define PCU_MSR_PMON_CTL_THRESH(x) (x << 24UL)
#define PCU_MSR_PMON_CTL_OCC_INVERT (1UL << 30UL)
#define PCU_MSR_PMON_CTL_OCC_EDGE_DET (1UL << 31UL)


#define JKT_C0_MSR_PMON_CTR3        0x0D19 // CBo 0 PMON Counter 3
#define JKT_C0_MSR_PMON_CTR2        0x0D18 // CBo 0 PMON Counter 2
#define JKT_C0_MSR_PMON_CTR1        0x0D17 // CBo 0 PMON Counter 1
#define JKT_C0_MSR_PMON_CTR0        0x0D16 // CBo 0 PMON Counter 0
#define JKT_C0_MSR_PMON_BOX_FILTER  0x0D14 // CBo 0 PMON Filter
#define JKT_C0_MSR_PMON_CTL3        0x0D13 // CBo 0 PMON Control for Counter 3
#define JKT_C0_MSR_PMON_CTL2        0x0D12 // CBo 0 PMON Control for Counter 2
#define JKT_C0_MSR_PMON_CTL1        0x0D11 // CBo 0 PMON Control for Counter 1
#define JKT_C0_MSR_PMON_CTL0        0x0D10 // CBo 0 PMON Control for Counter 0
#define JKT_C0_MSR_PMON_BOX_CTL     0x0D04 // CBo 0 PMON Box-Wide Control

#define JKTIVT_CBO_MSR_STEP         0x0020 // CBo MSR Step

#define IVT_C0_MSR_PMON_BOX_FILTER1 0x0D1A // CBo 0 PMON Filter 1

#define HSX_C0_MSR_PMON_CTR3 0x0E0B        // CBo 0 PMON Counter 3
#define HSX_C0_MSR_PMON_CTR2 0x0E0A        // CBo 0 PMON Counter 2
#define HSX_C0_MSR_PMON_CTR1 0x0E09        // CBo 0 PMON Counter 1
#define HSX_C0_MSR_PMON_CTR0 0x0E08        // CBo 0 PMON Counter 0

#define HSX_C0_MSR_PMON_BOX_FILTER1 0x0E06 // CBo 0 PMON Filter1
#define HSX_C0_MSR_PMON_BOX_FILTER 0x0E05  // CBo 0 PMON Filter0

#define HSX_C0_MSR_PMON_CTL3 0x0E04        // CBo 0 PMON Control for Counter 3
#define HSX_C0_MSR_PMON_CTL2 0x0E03        // CBo 0 PMON Control for Counter 2
#define HSX_C0_MSR_PMON_CTL1 0x0E02        // CBo 0 PMON Control for Counter 1
#define HSX_C0_MSR_PMON_CTL0 0x0E01        // CBo 0 PMON Control for Counter 0

#define HSX_C0_MSR_PMON_BOX_STATUS 0x0E07  // CBo 0 PMON Box-Wide Status
#define HSX_C0_MSR_PMON_BOX_CTL 0x0E00     // CBo 0 PMON Box-Wide Control

#define HSX_CBO_MSR_STEP         0x0010    // CBo MSR Step

#define KNL_CHA_MSR_STEP             0x000C // CHA MSR Step
#define KNL_CHA0_MSR_PMON_BOX_CTRL   0x0E00 // CHA 0 PMON Control

#define KNL_CHA0_MSR_PMON_EVT_SEL0   0x0E01 // CHA 0 PMON Event Select for Counter 0
#define KNL_CHA0_MSR_PMON_EVT_SEL1   0x0E02 // CHA 0 PMON Event Select for Counter 1
#define KNL_CHA0_MSR_PMON_EVT_SEL2   0x0E03 // CHA 0 PMON Event Select for Counter 2
#define KNL_CHA0_MSR_PMON_EVT_SEL3   0x0E04 // CHA 0 PMON Event Select for Counter 3

#define KNL_CHA0_MSR_PMON_BOX_CTL    0x0E05 // PERF_UNIT_CTL_CHA_0
#define KNL_CHA0_MSR_PMON_BOX_CTL1   0x0E06 // PERF_UNIT_CTL_1_CHA_0
#define KNL_CHA0_MSR_PMON_BOX_STATUS 0x0E07 // CHA 0 PMON Status

#define KNL_CHA0_MSR_PMON_CTR0       0x0E08 // CHA 0 PMON Counter 0
#define KNL_CHA0_MSR_PMON_CTR1       0x0E09 // CHA 0 PMON Counter 1
#define KNL_CHA0_MSR_PMON_CTR2       0x0E0A // CHA 0 PMON Counter 2
#define KNL_CHA0_MSR_PMON_CTR3       0x0E0B // CHA 0 PMON Counter 3

static const uint32 ICX_CHA_MSR_PMON_BOX_CTL[] = {
    0x0E00, 0x0E0E, 0x0E1C, 0x0E2A, 0x0E38, 0x0E46, 0x0E54, 0x0E62, 0x0E70, 0x0E7E, 0x0E8C, 0x0E9A,
    0x0EA8, 0x0EB6, 0x0EC4, 0x0ED2, 0x0EE0, 0x0EEE, 0x0F0A, 0x0F18, 0x0F26, 0x0F34, 0x0F42, 0x0F50,
    0x0F5E, 0x0F6C, 0x0F7A, 0x0F88, 0x0F96, 0x0FA4, 0x0FB2, 0x0FC0, 0x0FCE, 0x0FDC, 0x0B60, 0x0B6E,
    0x0B7C, 0x0B8A, 0x0B98, 0x0BA6, 0x0BB4, 0x0BC2
};

static const uint32 SNR_CHA_MSR_PMON_BOX_CTL[] = {
    0x1C00, 0x1C10, 0x1C20, 0x1C30, 0x1C40, 0x1C50
};

#define SERVER_CHA_MSR_PMON_CTL0_OFFSET        (1)
/*
#define SERVER_CHA_MSR_PMON_CTL1_OFFSET        (2)
#define SERVER_CHA_MSR_PMON_CTL2_OFFSET        (3)
#define SERVER_CHA_MSR_PMON_CTL3_OFFSET        (4)
*/

#define SERVER_CHA_MSR_PMON_BOX_FILTER_OFFSET  (5)

#define SERVER_CHA_MSR_PMON_CTR0_OFFSET        (8)
/*
#define SERVER_CHA_MSR_PMON_CTR1_OFFSET        (9)
#define SERVER_CHA_MSR_PMON_CTR2_OFFSET        (10)
#define SERVER_CHA_MSR_PMON_CTR3_OFFSET        (11)
*/

constexpr auto SPR_CHA0_MSR_PMON_BOX_CTRL   = 0x2000;
constexpr auto SPR_CHA0_MSR_PMON_CTL0       = 0x2002;
constexpr auto SPR_CHA0_MSR_PMON_CTR0       = 0x2008;
constexpr auto SPR_CHA0_MSR_PMON_BOX_FILTER = 0x200E;
constexpr auto SPR_CHA_MSR_STEP = 0x10;

#define CBO_MSR_PMON_CTL_EVENT(x) (x << 0)
#define CBO_MSR_PMON_CTL_UMASK(x) (x << 8)
#define CBO_MSR_PMON_CTL_RST    (1 << 17)
#define CBO_MSR_PMON_CTL_EDGE_DET (1 << 18)
#define CBO_MSR_PMON_CTL_TID_EN (1 << 19)
#define CBO_MSR_PMON_CTL_EN (1 << 22)
#define CBO_MSR_PMON_CTL_INVERT (1 << 23)
#define CBO_MSR_PMON_CTL_THRESH(x) (x << 24UL)
#define UNC_PMON_CTL_UMASK_EXT(x) (uint64(x) << 32ULL)
#define UNC_PMON_CTL_EVENT(x) (x << 0)
#define UNC_PMON_CTL_UMASK(x) (x << 8)

#define JKT_CBO_MSR_PMON_BOX_FILTER_OPC(x) (x << 23UL)
#define IVTHSX_CBO_MSR_PMON_BOX_FILTER1_OPC(x) (x << 20UL)
#define BDX_CBO_MSR_PMON_BOX_GET_OPC0(x) ((x >> 20) & 0x3FF)
#define BDX_CBO_MSR_PMON_BOX_GET_FLT(x) ((x >> 0x10) & 0x1)
#define BDX_CBO_MSR_PMON_BOX_GET_TID(x) ((x >> 0x11) & 0x1)

#define SKX_CHA_MSR_PMON_BOX_FILTER1_REM(x) (x << 0UL)
#define SKX_CHA_MSR_PMON_BOX_FILTER1_LOC(x) (x << 1UL)
#define SKX_CHA_MSR_PMON_BOX_FILTER1_NM(x) (x << 4UL)
#define SKX_CHA_MSR_PMON_BOX_FILTER1_NOT_NM(x) (x << 5UL)
#define SKX_CHA_MSR_PMON_BOX_FILTER1_OPC0(x) ((x) << 9UL)
#define SKX_CHA_MSR_PMON_BOX_FILTER1_OPC1(x) ((x) << 19UL)
#define SKX_CHA_MSR_PMON_BOX_FILTER1_NC(x) (x << 30UL)
#define SKX_CHA_MSR_PMON_BOX_FILTER1_RSV(x) (x << 2UL)
#define SKX_CHA_MSR_PMON_BOX_GET_OPC0(x) ((x >> 9) & 0x3FF)
#define SKX_CHA_MSR_PMON_BOX_GET_NC(x) ((x >> 0x1e) & 0x1)

#define SKX_CHA_TOR_INSERTS_UMASK_IRQ(x) (x << 0)
#define SKX_CHA_TOR_INSERTS_UMASK_PRQ(x) (x << 2)
#define SKX_CHA_TOR_INSERTS_UMASK_HIT(x) (x << 4)
#define SKX_CHA_TOR_INSERTS_UMASK_MISS(x) (x << 5)

/*ICX UmaskExt Filter*/
#define ICX_CHA_UMASK_EXT(x)   (x << 32UL)

#define SKX_IIO_CBDMA_UNIT_STATUS   (0x0A47)
#define SKX_IIO_CBDMA_UNIT_CTL      (0x0A40)
#define SKX_IIO_CBDMA_CTR0          (0x0A41)
#define SKX_IIO_CBDMA_CLK           (0x0A45)
#define SKX_IIO_CBDMA_CTL0          (0x0A48)
#define SKX_IIO_PM_REG_STEP         (0x0020)

#define ICX_IIO_CBDMA_UNIT_STATUS   (0x0A57)
#define ICX_IIO_CTL_REG_OFFSET      (0x0008)
#define ICX_IIO_CTR_REG_OFFSET      (0x0001)
/*
 * M2IOSF MSRs in order:
 * M2IOSF0 - PCIe0 stack
 * M2IOSF1 - PCIe1 stack
 * M2IOSF2 - MCP stack
 * M2IOSF3 - PCIe2 stack
 * M2IOSF4 - PCIe3 stack
 * M2IOSF5 - CBDMA/DMI stack
 */
static const uint32 ICX_IIO_UNIT_CTL[] = {
    0x0A50, 0x0A70, 0x0A90, 0x0AE0, 0x0B00, 0x0B20
};

static const uint32 GRR_IRP_UNIT_CTL[] = {
    0x2A00,
    0x2A10,
    0x2A20
};

#define GRR_IRP_CTL_REG_OFFSET      (0x0002)
#define GRR_IRP_CTR_REG_OFFSET      (0x0008)

static const uint32 BHS_IRP_UNIT_CTL[] = {
    0x2A00,
    0x2A10,
    0x2A20,
    0x2A30,
    0x2A40,
    0x2A50,
    0x2A60,
    0x2A70,
    0x2A80,
    0x2A90,
    0x2AA0,
    0x2AB0,
    0x2AC0,
    0x2AD0,
    0x2AE0,
    0x2AF0
};

#define BHS_IRP_CTL_REG_OFFSET      (0x0002)
#define BHS_IRP_CTR_REG_OFFSET      (0x0008)

static const uint32 SPR_IRP_UNIT_CTL[] = {
    0x3400,
    0x3410,
    0x3420,
    0x3430,
    0x3440,
    0x3450,
    0x3460,
    0x3470,
    0x3480,
    0x3490,
    0x34A0,
    0x34B0
};

#define SPR_IRP_CTL_REG_OFFSET      (0x0002)
#define SPR_IRP_CTR_REG_OFFSET      (0x0008)

static const uint32 ICX_IRP_UNIT_CTL[] = {
    0x0A4A,
    0x0A6A,
    0x0A8A,
    0x0ADA,
    0x0AFA,
    0x0B1A
};

#define ICX_IRP_CTL_REG_OFFSET      (0x0003)
#define ICX_IRP_CTR_REG_OFFSET      (0x0001)


static const uint32 SNR_IRP_UNIT_CTL[] = {
    0x1EA0,
    0x1EB0,
    0x1EC0,
    0x1ED0,
    0x1EE0
};

#define SNR_IRP_CTL_REG_OFFSET      (0x0008)
#define SNR_IRP_CTR_REG_OFFSET      (0x0001)

static const uint32 SKX_IRP_UNIT_CTL[] = {
    0x0A58,
    0x0A78,
    0x0A98,
    0x0AB8,
    0x0AD8,
    0x0AF8
};

#define SKX_IRP_CTL_REG_OFFSET      (0x0003)
#define SKX_IRP_CTR_REG_OFFSET      (0x0001)

#define SNR_IIO_CBDMA_UNIT_STATUS   (0x1E07)
#define SNR_IIO_CBDMA_UNIT_CTL      (0x1E00)
#define SNR_IIO_CBDMA_CTR0          (0x1E01)
#define SNR_IIO_CBDMA_CTL0          (0x1E08)
#define SNR_IIO_PM_REG_STEP         (0x0010)

constexpr auto SPR_M2IOSF_IIO_UNIT_CTL = 0x3000;
constexpr auto SPR_M2IOSF_IIO_CTR0     = 0x3008;
constexpr auto SPR_M2IOSF_IIO_CTL0     = 0x3002;
constexpr auto SPR_M2IOSF_REG_STEP = 0x10;
constexpr auto SPR_M2IOSF_NUM      = 12;

constexpr auto BHS_M2IOSF_IIO_UNIT_CTL = 0x2900;
constexpr auto BHS_M2IOSF_IIO_CTR0     = 0x2908;
constexpr auto BHS_M2IOSF_IIO_CTL0     = 0x2902;
constexpr auto BHS_M2IOSF_REG_STEP = 0x10;
constexpr auto BHS_M2IOSF_NUM      = 16;

constexpr auto CXL_PMON_SIZE = 0x1000;

#define IIO_MSR_PMON_CTL_EVENT(x)   ((x) << 0)
#define IIO_MSR_PMON_CTL_UMASK(x)   ((x) << 8)
#define IIO_MSR_PMON_CTL_RST        (1 << 17)
#define IIO_MSR_PMON_CTL_EDGE_DET   (1 << 18)
#define IIO_MSR_PMON_CTL_OV_EN      (1 << 20)
#define IIO_MSR_PMON_CTL_EN         (1 << 22)
#define IIO_MSR_PMON_CTL_INVERT     (1 << 23)
#define IIO_MSR_PMON_CTL_THRESH(x)  ((x) << 24ULL)
#define IIO_MSR_PMON_CTL_CH_MASK(x) ((x) << 36ULL)
#define IIO_MSR_PMON_CTL_FC_MASK(x) ((x) << 44ULL)

#define ICX_IIO_MSR_PMON_CTL_EVENT(x)   ((x) << 0)
#define ICX_IIO_MSR_PMON_CTL_UMASK(x)   ((x) << 8)
#define ICX_IIO_MSR_PMON_CTL_RST        (1 << 17)
#define ICX_IIO_MSR_PMON_CTL_EDGE_DET   (1 << 18)
#define ICX_IIO_MSR_PMON_CTL_OV_EN      (1 << 20)
#define ICX_IIO_MSR_PMON_CTL_EN         (1 << 22)
#define ICX_IIO_MSR_PMON_CTL_INVERT     (1 << 23)
#define ICX_IIO_MSR_PMON_CTL_THRESH(x)  ((x) << 24ULL)
#define ICX_IIO_MSR_PMON_CTL_CH_MASK(x) ((x) << 36ULL)
#define ICX_IIO_MSR_PMON_CTL_FC_MASK(x) ((x) << 48ULL)

#define M2M_PCI_PMON_CTL_EVENT(x)   ((x) << 0)
#define M2M_PCI_PMON_CTL_UMASK(x)   ((x) << 8)
#define M2M_PCI_PMON_CTL_RST        (1 << 17)
#define M2M_PCI_PMON_CTL_EDGE_DET   (1 << 18)
#define M2M_PCI_PMON_CTL_OV_EN      (1 << 20)
#define M2M_PCI_PMON_CTL_EN         (1 << 22)
#define M2M_PCI_PMON_CTL_INVERT     (1 << 23)
#define M2M_PCI_PMON_CTL_THRESH(x)  ((x) << 24ULL)

#define HA_PCI_PMON_CTL_EVENT(x)   ((x) << 0)
#define HA_PCI_PMON_CTL_UMASK(x)   ((x) << 8)
#define HA_PCI_PMON_CTL_RST        (1 << 17)
#define HA_PCI_PMON_CTL_EDGE_DET   (1 << 18)
#define HA_PCI_PMON_CTL_OV_EN      (1 << 20)
#define HA_PCI_PMON_CTL_EN         (1 << 22)
#define HA_PCI_PMON_CTL_INVERT     (1 << 23)
#define HA_PCI_PMON_CTL_THRESH(x)  ((x) << 24ULL)

#define UCLK_FIXED_CTL_OV_EN (1 << 20)
#define UCLK_FIXED_CTL_EN    (1 << 22)

/* \brief IIO Performance Monitoring Control Register format

    IIOn_MSR_PMON_CTL{3-0} Register- Field Definitions
*/
struct IIOPMUCNTCTLRegister
{
    union
    {
        struct
        {
            uint64 event_select : 8;
            uint64 umask : 8;
            uint64 reserved1 : 1;
            uint64 reset : 1;
            uint64 edge_det : 1;
            uint64 ignored : 1;
            uint64 overflow_enable : 1;
            uint64 reserved2 : 1;
            uint64 enable : 1;
            uint64 invert : 1;
            uint64 thresh : 12;
            uint64 ch_mask : 8;
            uint64 fc_mask : 3;
            uint64 reservedX : 17;
        } fields;
        uint64 value;
    };
    IIOPMUCNTCTLRegister() : value(0) { }
    IIOPMUCNTCTLRegister(const uint64 v) : value(v) { }
    operator uint64() { return value; }
};

struct ICX_IIOPMUCNTCTLRegister
{
    union
    {
        struct
        {
            uint64 event_select : 8;
            uint64 umask : 8;
            uint64 reserved1 : 1;
            uint64 reset : 1;
            uint64 edge_det : 1;
            uint64 ignored : 1;
            uint64 overflow_enable : 1;
            uint64 reserved2 : 1;
            uint64 enable : 1;
            uint64 invert : 1;
            uint64 thresh : 12;
            uint64 ch_mask : 12;
            uint64 fc_mask : 3;
            uint64 reservedX : 13;
        } fields;
        uint64 value;
    };
    ICX_IIOPMUCNTCTLRegister() : value(0) { }
};

constexpr auto MSR_PACKAGE_THERM_STATUS = 0x01B1;
constexpr auto MSR_IA32_THERM_STATUS = 0x019C;
#ifndef KERNEL
constexpr auto PCM_INVALID_THERMAL_HEADROOM = (std::numeric_limits<int32_t>::min)();
#endif

constexpr auto MSR_IA32_BIOS_SIGN_ID = 0x8B;

constexpr auto MSR_DRAM_ENERGY_STATUS = 0x0619;
constexpr auto MSR_PP0_ENERGY_STATUS = 0x639;
constexpr auto MSR_PP1_ENERGY_STATUS = 0x641;

constexpr auto MSR_PKG_C2_RESIDENCY    = 0x60D;
constexpr auto MSR_PKG_C3_RESIDENCY    = 0x3F8;
constexpr auto MSR_PKG_C6_RESIDENCY    = 0x3F9;
constexpr auto MSR_PKG_C7_RESIDENCY    = 0x3FA;
constexpr auto MSR_CORE_C3_RESIDENCY   = 0x3FC;
constexpr auto MSR_CORE_C6_RESIDENCY   = 0x3FD;
constexpr auto MSR_CORE_C7_RESIDENCY   = 0x3FE;

constexpr auto MSR_PERF_GLOBAL_INUSE   = 0x392;

constexpr auto MSR_IA32_SPEC_CTRL         = 0x48;
constexpr auto MSR_IA32_ARCH_CAPABILITIES = 0x10A;

constexpr auto MSR_TSX_FORCE_ABORT = 0x10f;

constexpr auto MSR_PERF_CAPABILITIES = 0x345;

// data structure for converting two uint32s <-> uin64
union cvt_ds
{
#ifndef _MSC_VER
    typedef uint64 UINT64;
    typedef uint32 DWORD;
#endif
    UINT64 ui64;
    struct
    {
        DWORD low;
        DWORD high;
    } ui32;
};

#ifndef KERNEL

struct MCFGRecord
{
    unsigned long long baseAddress;
    unsigned short PCISegmentGroupNumber;
    unsigned char startBusNumber;
    unsigned char endBusNumber;
    char reserved[4];
    MCFGRecord() : baseAddress(0), PCISegmentGroupNumber(0), startBusNumber(0), endBusNumber(0)
    {
        std::fill(reserved, reserved + 4, 0);
    }
    void print()
    {
        std::cout << "BaseAddress=" << (std::hex) << "0x" << baseAddress << " PCISegmentGroupNumber=0x" << PCISegmentGroupNumber <<
            " startBusNumber=0x" << (unsigned)startBusNumber << " endBusNumber=0x" << (unsigned)endBusNumber << "\n" << std::dec;
    }
};

struct MCFGHeader
{
    char signature[4];
    unsigned length;
    unsigned char revision;
    unsigned char checksum;
    char OEMID[6];
    char OEMTableID[8];
    unsigned OEMRevision;
    unsigned creatorID;
    unsigned creatorRevision;
    char reserved[8];

    unsigned nrecords() const
    {
        return (length - sizeof(MCFGHeader)) / sizeof(MCFGRecord);
    }

    void print()
    {
        std::cout << "Header: length=" << length << " nrecords=" << nrecords() << "\n";
    }
};

#endif // #ifndef KERNEL


inline uint32 build_bit_ui(uint32 beg, uint32 end)
{
    assert(end <= 31);
    uint32 myll = 0;
    if (end > 31)
    {
        end = 31;
    }
    if (beg > 31)
    {
        return 0;
    }
    if (end == 31)
    {
        myll = (uint32)(-1);
    }
    else
    {
        myll = (1 << (end + 1)) - 1;
    }
    myll = myll >> beg;
    return myll;
}

inline uint32 extract_bits_32(uint32 myin, uint32 beg, uint32 end)
{
    uint32 myll = 0;
    uint32 beg1, end1;

    // Let the user reverse the order of beg & end.
    if (beg <= end)
    {
        beg1 = beg;
        end1 = end;
    }
    else
    {
        beg1 = end;
        end1 = beg;
    }
    myll = myin >> beg1;
    myll = myll & build_bit_ui(beg1, end1);
    return myll;
}

inline uint64 build_bit(uint32 beg, uint32 end)
{
    uint64 myll = 0;
    if (end > 63)
    {
        end = 63;
    }
    if (end == 63)
    {
        myll = static_cast<uint64>(-1);
    }
    else
    {
        myll = (1LL << (end + 1)) - 1;
    }
    myll = myll >> beg;
    return myll;
}

inline uint64 extract_bits(uint64 myin, uint32 beg, uint32 end)
{
    uint64 myll = 0;
    uint32 beg1, end1;

    // Let the user reverse the order of beg & end.
    if (beg <= end)
    {
        beg1 = beg;
        end1 = end;
    }
    else
    {
        beg1 = end;
        end1 = beg;
    }
    myll = myin >> beg1;
    myll = myll & build_bit(beg1, end1);
    return myll;
}

inline uint64 extract_bits_64(uint64 myin, uint32 beg, uint32 end)
{
    return extract_bits(myin, beg, end);
}

union PCM_CPUID_INFO
{
    int array[4];
    struct { unsigned int eax, ebx, ecx, edx; } reg;
};

inline void pcm_cpuid(int leaf, PCM_CPUID_INFO& info)
{
#ifdef _MSC_VER
    // version for Windows
    __cpuid(info.array, leaf);
#else
    __asm__ __volatile__("cpuid" : \
        "=a" (info.reg.eax), "=b" (info.reg.ebx), "=c" (info.reg.ecx), "=d" (info.reg.edx) : "a" (leaf));
#endif
}

/* Adding the new version of cpuid with leaf and subleaf as an input */
inline void pcm_cpuid(const unsigned leaf, const unsigned subleaf, PCM_CPUID_INFO & info)
{
    #ifdef _MSC_VER
    __cpuidex(info.array, leaf, subleaf);
    #else
    __asm__ __volatile__ ("cpuid" : \
                          "=a" (info.reg.eax), "=b" (info.reg.ebx), "=c" (info.reg.ecx), "=d" (info.reg.edx) : "a" (leaf), "c" (subleaf));
    #endif
}

//IDX accel device/func number(PCIe).
//The device/function number from SPR register guide.
#define SPR_IDX_IAA_REGISTER_DEV_ADDR  (2)
#define SPR_IDX_IAA_REGISTER_FUNC_ADDR (0)

#define SPR_IDX_DSA_REGISTER_DEV_ADDR  (1)
#define SPR_IDX_DSA_REGISTER_FUNC_ADDR (0)

#define SPR_IDX_QAT_REGISTER_DEV_ADDR  (0)
#define SPR_IDX_QAT_REGISTER_FUNC_ADDR (0)

//IDX accel perfmon register offset
//The offset of register from DSA external architecture spec(intel-data-streaming-accelerator-preliminary-architecture-specification).
#define SPR_IDX_ACCEL_PCICMD_OFFSET        (0x4)
#define SPR_IDX_ACCEL_BAR0_OFFSET          (0x10)
#define SPR_IDX_ACCEL_BAR0_SIZE            (0x10000)
#define SPR_IDX_ACCEL_TABLE_OFFSET         (0x60)
#define SPR_IDX_ACCEL_PMON_BASE_OFFSET     (0x68)
#define SPR_IDX_ACCEL_PMON_BASE_MASK       (0xFFFF)
#define SPR_IDX_ACCEL_PMON_BASE_RATIO      (0x100)
#define SPR_IDX_ACCEL_PMCSR_OFFSET         (0x94)

#define SPR_IDX_PMON_RESET_CTL_OFFSET              (0x10)
#define SPR_IDX_PMON_FREEZE_CTL_OFFSET             (0x20)
#define SPR_IDX_PMON_CTL_OFFSET(x)                 (0x100 + ((x)*8))
#define SPR_IDX_PMON_CTR_OFFSET(x)                 (0x200 + ((x)*8))
#define SPR_IDX_PMON_FILTER_WQ_OFFSET(x)           (0x300 + ((x)*32))
#define SPR_IDX_PMON_FILTER_TC_OFFSET(x)           (0x304 + ((x)*32))
#define SPR_IDX_PMON_FILTER_PGSZ_OFFSET(x)         (0x308 + ((x)*32))
#define SPR_IDX_PMON_FILTER_XFERSZ_OFFSET(x)       (0x30C + ((x)*32))
#define SPR_IDX_PMON_FILTER_ENG_OFFSET(x)          (0x310 + ((x)*32))

//MSM device/func number and register offset from SPR register guide.
constexpr auto SPR_MSM_DEV_ID                       = 0x09a6;
constexpr auto SPR_MSM_DEV_ADDR                     = 0x03;
constexpr auto SPR_MSM_FUNC_ADDR                    = 0x00;
constexpr auto SPR_MSM_REG_CPUBUSNO_VALID_OFFSET    = 0x1a0;
constexpr auto SPR_MSM_REG_CPUBUSNO0_OFFSET         = 0x190;
constexpr auto SPR_MSM_REG_CPUBUSNO4_OFFSET         = 0x1c0;
constexpr auto SPR_MSM_CPUBUSNO_MAX                 = 32;

//SAD register offset from SPR register guide.
constexpr auto SPR_SAD_REG_CTL_CFG_OFFSET           = 0x3F4;

} // namespace pcm

#endif

```

`src/uncore_pmu_discovery.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2021-2022, Intel Corporation

#include "uncore_pmu_discovery.h"
#include "pci.h"
#include "mmio.h"
#include "iostream"
#include "utils.h"
#include "cpucounters.h"

namespace pcm {

UncorePMUDiscovery::UncorePMUDiscovery(PCM & m)
{
    if (safe_getenv("PCM_NO_UNCORE_PMU_DISCOVERY") == std::string("1"))
    {
        return;
    }
    const auto debug = (safe_getenv("PCM_DEBUG_PMU_DISCOVERY") == std::string("1"));
    
    auto processTables = [this, &debug, &m](const uint64 bar, const VSEC & vsec, const int32 NUMANode)
    {
        try {
            DBG(1, "Uncore discovery detection. Reading from bar 0x", std::hex, bar, std::dec,
                   " NUMANode: ", NUMANode);
            constexpr size_t UncoreDiscoverySize = 3UL;
            union UncoreGlobalDiscovery {
                GlobalPMU pmu;
                uint64 table[UncoreDiscoverySize];
            };
            UncoreGlobalDiscovery global;
            mmio_memcpy(global.table, bar, UncoreDiscoverySize * sizeof(uint64), true);
            size_t socket = 0; // default socket if NUMA node -> socket mapping fails
            if (NUMANode >= 0)
            {
                const auto socketFromNUMANode = m.mapNUMANodeToSocket(NUMANode);
                DBG(1, "Socket of NUMANode: ", socketFromNUMANode);
                if (socketFromNUMANode >= 0)
                {
                    socket = static_cast<size_t>(socketFromNUMANode);
                }
            }
            globalPMUs.resize((std::max)(socket + 1, globalPMUs.size()));
            assert(socket < globalPMUs.size());
            globalPMUs[socket].push_back(global.pmu);
            if (debug)
            {
                std::cerr << "Read global.pmu from 0x" << std::hex << bar << std::dec << "\n";
                global.pmu.print();
                std::cout.flush();
            }
            union UncoreUnitDiscovery {
                BoxPMU pmu;
                uint64 table[UncoreDiscoverySize];
            };
            UncoreUnitDiscovery unit;
            const auto step = global.pmu.stride * 8;
            BoxPMUMap boxPMUMap;
            for (size_t u = 0; u < global.pmu.maxUnits; ++u)
            {
                mmio_memcpy(unit.table, bar + (u + 1) * step, UncoreDiscoverySize * sizeof(uint64), true);
                if (debug)
                {
                    std::cerr << "Read unit.pmu " << u << " from 0x" << std::hex << (bar + (u + 1) * step) << std::dec << "\n";
                    unit.pmu.print();
                    std::cout.flush();
                }
                if (unit.table[0] == 0 && unit.table[1] == 0)
                {
                    if (debug)
                    {
                        std::cerr << "Invalid entry\n";
                    }
                    // invalid entry
                    continue;
                }
                // unit.pmu.print();
                boxPMUMap[unit.pmu.boxType].push_back(unit.pmu);
            }
            boxPMUs.resize((std::max)(socket + 1, boxPMUs.size()));
            assert(socket < boxPMUs.size());
            boxPMUs[socket].push_back(boxPMUMap);
        }
        catch (const std::exception & e)
        {
            std::cerr << "WARNING: enumeration of devices in UncorePMUDiscovery failed on bar 0x"
                << std::hex << bar << "\n" << e.what() << "\n" <<
                " CAP_ID: 0x" << vsec.fields.cap_id << "\n" <<
                " CAP_VERSION: 0x" << vsec.fields.cap_version << "\n" <<
                " CAP_NEXT: 0x" << vsec.fields.cap_next << "\n" <<
                " VSEC_ID: 0x" << vsec.fields.vsec_id << "\n" <<
                " VSEC_VERSION: 0x" << vsec.fields.vsec_version << "\n" <<
                " VSEC_LENGTH: 0x" << vsec.fields.vsec_length << "\n" <<
                " ENTRY_ID: 0x" << vsec.fields.entryID << "\n" <<
                " NUM_ENTRIES: 0x" << vsec.fields.NumEntries << "\n" <<
                " ENTRY_SIZE: 0x" << vsec.fields.EntrySize << "\n" <<
                " TBIR: 0x" << vsec.fields.tBIR << "\n" <<
                " ADDRESS: 0x" << vsec.fields.Address <<
                std::dec << "\n";
            std::cerr << "INFO: discovery has " << boxPMUs.size() << " entries\n";
        }
    };
    try {
        processDVSEC([](const VSEC & vsec)
        {
            return vsec.fields.cap_id == 0x23 // UNCORE_EXT_CAP_ID_DISCOVERY
                && vsec.fields.entryID == 1; // UNCORE_DISCOVERY_DVSEC_ID_PMON
        }, processTables);

    } catch (...)
    {
        std::cerr << "WARNING: enumeration of devices in UncorePMUDiscovery failed\n";
    }

    if (safe_getenv("PCM_PRINT_UNCORE_PMU_DISCOVERY") == std::string("1"))
    {
        for (size_t s = 0; s < boxPMUs.size(); ++s)
        {
            for (size_t die = 0; die < boxPMUs[s].size(); ++die)
            {
                std::cout << "Socket " << s << " die " << die << " global PMU:\n";
                std::cout << "    ";
                assert(s < globalPMUs.size() && die < globalPMUs[s].size());
                globalPMUs[s][die].print();
                std::cout << "Socket " << s << " die " << die << " unit PMUs:\n";
                for (const auto& pmuType : boxPMUs[s][die])
                {
                    const auto n = pmuType.second.size();
                    std::cout << "   PMU type " << pmuType.first << " (" << n << " boxes)" << "\n";
                    for (size_t i = 0; i < n; ++i)
                    {
                        std::cout << "        ";
                        pmuType.second[i].print();
                    }
                }
            }
        }
    }
}

} // namespace pcm

```

`src/uncore_pmu_discovery.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2021-2022, Intel Corporation

#pragma once

#include <vector>
#include <unordered_map>
#include <iostream>
#include "types.h"

namespace pcm {

class PCM;

constexpr auto SPR_PCU_BOX_TYPE = 4U;
constexpr auto SPR_IMC_BOX_TYPE = 6U;
constexpr auto SPR_UPILL_BOX_TYPE = 8U;
constexpr auto SPR_MDF_BOX_TYPE = 11U;
constexpr auto SPR_CXLCM_BOX_TYPE = 12U;
constexpr auto SPR_CXLDP_BOX_TYPE = 13U;
constexpr auto BHS_MDF_BOX_TYPE = 20U;
constexpr auto BHS_PCIE_GEN5x16_TYPE = 21U;
constexpr auto BHS_PCIE_GEN5x8_TYPE = 22U;

class UncorePMUDiscovery
{
public:
    enum accessTypeEnum {
        MSR = 0,
        MMIO = 1,
        PCICFG = 2,
        unknownAccessType = 255
    };
    static const char * accessTypeStr(const uint64 t)
    {
        switch (t)
        {
            case MSR:
                return "MSR";
            case MMIO:
                return "MMIO";
            case PCICFG:
                return "PCICFG";
        }
        return "unknown";
    };
    union PCICFGAddress
    {
        uint64 raw;
        struct {
            uint64 offset:12;
            uint64 function:3;
            uint64 device:5;
            uint64 bus:8;
        } fields;
        std::string getStr() const
        {
            std::ostringstream out(std::ostringstream::out);
            out << std::hex << fields.bus << ":" << fields.device << "." << fields.function << "@" << fields.offset;
            out << std::dec;
            return out.str();
        }
    };
    static void printHelper(const accessTypeEnum accessType, const uint64 addr)
    {
        if (accessType == PCICFG)
        {
            PCICFGAddress Addr;
            Addr.raw = addr;
            std::cout << " (" << Addr.getStr() << ")";
        }
        else
        {
            std::cout << " (-)";
        }
        std::cout << " with access type " << std::dec << accessTypeStr(accessType);
    }
protected:
    struct GlobalPMU
    {
        uint64 type:8;
        uint64 stride:8;
        uint64 maxUnits:10;
        uint64 __reserved1:36;
        uint64 accessType:2;
        uint64 globalCtrlAddr;
        uint64 statusOffset:8;
        uint64 numStatus:16;
        uint64 __reserved2:40;
        void print() const
        {
            std::cout << "global PMU " <<
            " of type " << std::dec << type <<
            " globalCtrl: 0x" << std::hex << globalCtrlAddr;
            UncorePMUDiscovery::printHelper((accessTypeEnum)accessType, globalCtrlAddr);
            std::cout << " stride: " << std::dec <<  stride
                      << " maxUnits: " << maxUnits
                      << " statusOffset: " << statusOffset
                      << " numStatus: " << numStatus
            << "\n";
        }
    };
    struct BoxPMU
    {
        uint64 numRegs : 8;
        uint64 ctrlOffset : 8;
        uint64 bitWidth : 8;
        uint64 ctrOffset : 8;
        uint64 statusOffset : 8;
        uint64 __reserved1 : 22;
        uint64 accessType : 2;
        uint64 boxCtrlAddr;
        uint64 boxType : 16;
        uint64 boxID : 16;
        uint64 __reserved2 : 32;
        void print() const
        {
           std::cout << "unit PMU " <<
                " of type " << std::dec <<  boxType <<
                " ID " << boxID <<
                " box ctrl: 0x" << std::hex << boxCtrlAddr;
            UncorePMUDiscovery::printHelper((accessTypeEnum)accessType, boxCtrlAddr);
            std::cout <<
                " width " << bitWidth <<
                " numRegs " << numRegs <<
                " ctrlOffset " << ctrlOffset <<
                " ctrOffset " << ctrOffset <<
                "\n";
        }
    };
    typedef std::vector<BoxPMU> BoxPMUs;
    typedef std::unordered_map<size_t, BoxPMUs> BoxPMUMap; // boxType -> BoxPMUs
    std::vector<std::vector<BoxPMUMap> > boxPMUs; // socket -> die -> BoxPMUs
    std::vector<std::vector<GlobalPMU> > globalPMUs; // socket -> die -> GlobalPMU

    bool validBox(const size_t boxType, const size_t socket, const size_t die, const size_t pos)
    {
        return socket < boxPMUs.size() && die < boxPMUs[socket].size() && pos < boxPMUs[socket][die][boxType].size();
    }
    size_t registerStep(const size_t boxType, const size_t socket, const size_t die, const size_t pos)
    {
        const auto width = boxPMUs[socket][die][boxType][pos].bitWidth;
        switch (boxPMUs[socket][die][boxType][pos].accessType)
        {
        case MSR:
            if (width <= 64)
            {
                return 1;
            }
            break;
        case PCICFG:
        case MMIO:
            if (width <= 8)
            {
                return 1;
            }
            else if (width <= 16)
            {
                return 2;
            }
            else if (width <= 32)
            {
                return 4;
            }
            else if (width <= 64)
            {
                return 8;
            }
            break;
        }
        return 0;
    }
    UncorePMUDiscovery() = delete;
public:
    UncorePMUDiscovery(PCM &);

    size_t getNumDies(const size_t socket) const
    {
        if (socket < boxPMUs.size())
        {
            return boxPMUs[socket].size();
        }
        return 0;
    }

    size_t getNumBoxes(const size_t boxType, const size_t socket, const size_t die)
    {
        if (socket < boxPMUs.size() && die < boxPMUs[socket].size())
        {
            return boxPMUs[socket][die][boxType].size();
        }
        return 0;
    }

    uint64 getBoxCtlAddr(const size_t boxType, const size_t socket, const size_t die, const size_t pos)
    {
        if (validBox(boxType, socket, die, pos))
        {
            return boxPMUs[socket][die][boxType][pos].boxCtrlAddr;
        }
        return 0;
    }

    uint64 getBoxCtlAddr(const size_t boxType, const size_t socket, const size_t die, const size_t pos, const size_t c)
    {
        if (validBox(boxType, socket, die, pos) && c < boxPMUs[socket][die][boxType][pos].numRegs)
        {
            const size_t step = (boxType == SPR_IMC_BOX_TYPE) ? 4 : registerStep(boxType, socket, die, pos);
            return boxPMUs[socket][die][boxType][pos].boxCtrlAddr + boxPMUs[socket][die][boxType][pos].ctrlOffset + c * step;
        }
        return 0;
    }

    uint64 getBoxCtrAddr(const size_t boxType, const size_t socket, const size_t die, const size_t pos, const size_t c)
    {
        if (validBox(boxType, socket, die, pos) && c < boxPMUs[socket][die][boxType][pos].numRegs)
        {
            return boxPMUs[socket][die][boxType][pos].boxCtrlAddr + boxPMUs[socket][die][boxType][pos].ctrOffset + c * registerStep(boxType, socket, die, pos);
        }
        return 0;
    }

    accessTypeEnum getBoxAccessType(const size_t boxType, const size_t socket, const size_t die, const size_t pos)
    {
        if (validBox(boxType, socket, die, pos))
        {
            return static_cast<accessTypeEnum>(boxPMUs[socket][die][boxType][pos].accessType);
        }
        return unknownAccessType;
    }

    uint64 getBoxNumRegs(const size_t boxType, const size_t socket, const size_t die, const size_t pos)
    {
        if (validBox(boxType, socket, die, pos))
        {
            return boxPMUs[socket][die][boxType][pos].numRegs;
        }
        return 0;
    }
};

} // namespace pcm

```

`src/utils.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Andrey Semin and many others

#include <array>
#include <iostream>
#include <cassert>
#include <climits>
#include <algorithm>
#ifdef _MSC_VER
#include <windows.h>
#include <accctrl.h>
#include <aclapi.h>
#include <sddl.h>
#include <process.h>
#include <comdef.h>
#else
#include <sys/wait.h> // for waitpid()
#include <unistd.h> // for ::sleep
#include <fcntl.h>  // for open(), O_NOFOLLOW
#endif
#include "utils.h"
#include "cpucounters.h"
#include <numeric>
#ifndef _MSC_VER
#include <execinfo.h>
extern char ** environ;
#endif
#ifdef __linux__
#include <glob.h>
#endif

#include "debug.h"

namespace pcm {


bool startsWithPCM(const StringType& varName) {
    const StringType prefix = PCM_STRING("PCM_");
    return varName.compare(0, prefix.size(), prefix) == 0;
}

bool isInKeepList(const StringType& varName, const std::vector<StringType>& keepList) {
    for (const auto& keepVar : keepList) {
        if (varName == keepVar) {
            return true;
        }
    }
    return false;
}

void setDefaultDebugLevel()
{
    auto strDebugLevel = pcm::safe_getenv("PCM_DEBUG_LEVEL");
    if (strDebugLevel.empty() == false)
    {
        auto intDebugLevel = std::stoi(strDebugLevel);
        debug::dyn_debug_level(intDebugLevel);
        DBG(0, "Debug level set to ", intDebugLevel);
    }
}

void getMCFGRecords(std::vector<MCFGRecord>& mcfg)
{
#ifdef __linux__
    mcfg = PciHandleMM::getMCFGRecords();
#elif defined(_MSC_VER)
    PciHandle::readMCFGRecords(mcfg);
#else
    MCFGRecord segment;
    segment.startBusNumber = 0;
    segment.endBusNumber = 0xff;
    auto maxSegments = 1;
#if defined(__FreeBSD__) || defined(__DragonFly__)
    switch (PCM::getCPUFamilyModelFromCPUID())
    {
    case PCM::SPR:
    case PCM::GNR:
        maxSegments = 4;
        break;
    }
#endif
    for (segment.PCISegmentGroupNumber = 0; segment.PCISegmentGroupNumber < maxSegments; ++(segment.PCISegmentGroupNumber))
    {
        mcfg.push_back(segment);
    }
#endif
}

#if defined(_MSC_VER)

void eraseEnvironmentVariables(const std::vector<std::wstring>& keepList) {
    // Get a snapshot of the current environment block
    LPWCH envBlock = GetEnvironmentStrings();
    if (!envBlock) {
        std::cerr << "Error getting environment strings." << std::endl;
        return;
    }

    // Iterate over the environment block
    for (LPWCH var = envBlock; *var != 0; var += std::wcslen(var) + 1) {
        std::wstring varName(var);
        size_t pos = varName.find('=');
        if (pos != std::string::npos) {
            varName = varName.substr(0, pos);
            if (!startsWithPCM(varName) && !isInKeepList(varName, keepList)) {
                SetEnvironmentVariable(varName.c_str(), NULL);
            }
        }
    }

    // Free the environment block
    FreeEnvironmentStrings(envBlock);
}
#else
void eraseEnvironmentVariables(const std::vector<std::string>& keepList) {
    std::vector<std::string> varsToDelete;

    // Collect all the variables that need to be deleted
    for (char **env = environ; *env != nullptr; ++env) {
        std::string envEntry(*env);
        size_t pos = envEntry.find('=');
        if (pos != std::string::npos) {
            std::string varName = envEntry.substr(0, pos);
            if (!startsWithPCM(varName) && !isInKeepList(varName, keepList)) {
                varsToDelete.push_back(varName);
            }
        }
    }

    // Delete the collected variables
    for (const auto& varName : varsToDelete) {
        unsetenv(varName.c_str());
    }
}
#endif

void (*post_cleanup_callback)(void) = NULL;

//! \brief handler of exit() call
void exit_cleanup(void)
{
    std::cout << std::flush;

    restore_signal_handlers();

    // this replaces same call in cleanup() from util.h
    if (PCM::isInitialized()) PCM::getInstance()->cleanup(); // this replaces same call in cleanup() from util.h

//TODO: delete other shared objects.... if any.

    if(post_cleanup_callback != NULL)
    {
        post_cleanup_callback();
    }
}


#ifdef _MSC_VER
bool colorEnabled = false;
#else
bool colorEnabled = true;
#endif

void setColorEnabled(bool value)
{
    colorEnabled = value;
}

const char * setColor (const char * colorStr)
{
    return colorEnabled ? colorStr : "";
}

template<typename T, typename... N>
constexpr auto make_array(N&&... args) -> std::array<T, sizeof...(args)>
{
    return {std::forward<N>(args)...};
}

constexpr auto colorTable{make_array<const char*>(
    ASCII_GREEN,
    ASCII_YELLOW,
    ASCII_MAGENTA,
    ASCII_CYAN,
    ASCII_BRIGHT_GREEN,
    ASCII_BRIGHT_YELLOW,
    ASCII_BRIGHT_BLUE,
    ASCII_BRIGHT_MAGENTA,
    ASCII_BRIGHT_CYAN,
    ASCII_BRIGHT_WHITE
)};

size_t currentColor = 0;
const char * setNextColor()
{
    const auto result = setColor(colorTable[currentColor++]);
    if (currentColor == colorTable.size())
    {
        currentColor = 0;
    }
    return result;
}

const char * resetColor()
{
    currentColor = 0;
    return setColor(ASCII_RESET_COLOR);
}

void print_cpu_details()
{
    const auto m = PCM::getInstance();
    std::cerr << "\nDetected " << m->getCPUBrandString() << " \"Intel(r) microarchitecture codename " <<
        m->getUArchCodename() << "\" stepping " << m->getCPUStepping();
    const auto ucode_level = m->getCPUMicrocodeLevel();
    if (ucode_level >= 0)
    {
        std::cerr << " microcode level 0x" << std::hex << ucode_level << std::dec;
    }
    std::cerr << "\n";
}

#ifdef __linux__
std::vector<std::string> findPathsFromPattern(const char* pattern)
{
            std::vector<std::string> result;
            glob_t glob_result;
            memset(&glob_result, 0, sizeof(glob_result));
            if (glob(pattern, GLOB_TILDE, nullptr, &glob_result) == 0)
            {
                for (size_t i = 0; i < glob_result.gl_pathc; ++i)
                {
                    result.push_back(glob_result.gl_pathv[i]);
                }
            }
            globfree(&glob_result);
            return result;
};
#endif

#ifdef _MSC_VER

ThreadGroupTempAffinity::ThreadGroupTempAffinity(uint32 core_id, bool checkStatus, const bool restore_)
  : restore(restore_)
{
    GROUP_AFFINITY NewGroupAffinity;
    SecureZeroMemory(&NewGroupAffinity, sizeof(GROUP_AFFINITY));
    SecureZeroMemory(&PreviousGroupAffinity, sizeof(GROUP_AFFINITY));
    DWORD currentGroupSize = 0;

    while ((DWORD)core_id >= (currentGroupSize = GetActiveProcessorCount(NewGroupAffinity.Group)))
    {
        if (currentGroupSize == 0)
        {
            std::cerr << "ERROR: GetActiveProcessorCount for core " << core_id << " failed with error " << GetLastError() << "\n";
            throw std::exception();
        }
        core_id -= (uint32)currentGroupSize;
        ++NewGroupAffinity.Group;
    }
    NewGroupAffinity.Mask = 1ULL << core_id;
    if (GetThreadGroupAffinity(GetCurrentThread(), &PreviousGroupAffinity)
        && (std::memcmp(&NewGroupAffinity, &PreviousGroupAffinity, sizeof(GROUP_AFFINITY)) == 0))
    {
        restore = false;
        return;
    }
    const auto res = SetThreadGroupAffinity(GetCurrentThread(), &NewGroupAffinity, &PreviousGroupAffinity);
    if (res == FALSE && checkStatus)
    {
        std::cerr << "ERROR: SetThreadGroupAffinity for core " << core_id << " failed with error " << GetLastError() << "\n";
        throw std::exception();
    }
}
ThreadGroupTempAffinity::~ThreadGroupTempAffinity()
{
    if (restore) SetThreadGroupAffinity(GetCurrentThread(), &PreviousGroupAffinity, NULL);
}

LONG unhandled_exception_handler(LPEXCEPTION_POINTERS p)
{
    std::cerr << "DEBUG: Unhandled Exception event\n";
    exit(EXIT_FAILURE);
}

/**
* \brief version of interrupt handled for Windows
*/
BOOL sigINT_handler(DWORD fdwCtrlType)
{
    // output for DEBUG only
    std::cerr << "DEBUG: caught signal to interrupt: ";
    switch (fdwCtrlType)
    {
    // Handle the CTRL-C signal.
    case CTRL_C_EVENT:
        std::cerr << "Ctrl-C event\n";
        break;

    // CTRL-CLOSE: confirm that the user wants to exit.
    case CTRL_CLOSE_EVENT:
        std::cerr << "Ctrl-Close event\n";
        break;

    // Pass other signals to the next handler.
    case CTRL_BREAK_EVENT:
        std::cerr << "Ctrl-Break event\n";
        break;

    case CTRL_LOGOFF_EVENT:
        std::cerr << "Ctrl-Logoff event\n";
        break;

    case CTRL_SHUTDOWN_EVENT:
        std::cerr << "Ctrl-Shutdown event\n";
        break;

    default:
        std::cerr << "Unknown event\n";
        break;
    }

    // TODO: dump summary, if needed

    // in case PCM is blocked just return and summary will be dumped in
    // calling function, if needed
    if (PCM::isInitialized() && PCM::getInstance()->isBlocked()) {
        return FALSE;
    } else {
        exit_cleanup();
        _exit(EXIT_SUCCESS);
        return FALSE; // to prevent Warning
    }
}

/**
* \brief started in a separate thread and blocks waiting for child application to exit.
* After child app exits: -> print Child's termination status and terminates PCM
*/
void waitForChild(void * proc_id)
{
    intptr_t procHandle = (intptr_t)proc_id;
    int termstat;
    _cwait(&termstat, procHandle, _WAIT_CHILD);
    std::cerr << "Program exited with status " << termstat << "\n";
    exit(EXIT_SUCCESS);
}
#else
/**
 * \brief handles signals that lead to termination of the program
 * such as SIGINT, SIGQUIT, SIGABRT, SIGSEGV, SIGTERM, SIGCHLD
 * this function specifically works when the client application launched
 * by pcm -- terminates
 */
void sigINT_handler(int signum)
{
    // output for DEBUG only
    std::cerr << "DEBUG: caught signal to interrupt (" << strsignal(signum) << ").\n";
    // TODO: dump summary, if needed

    // in case PCM is blocked just return and summary will be dumped in
    // calling function, if needed
    if (PCM::isInitialized() && PCM::getInstance()->isBlocked()) {
        return;
    } else {
        exit_cleanup();
        if (signum == SIGABRT || signum == SIGSEGV)
        {
            _exit(EXIT_FAILURE);
        }
        else
        {
            _exit(EXIT_SUCCESS);
        }
    }
}

constexpr auto BACKTRACE_MAX_STACK_FRAME = 30;
void printBacktrace()
{
    void* backtrace_buffer[BACKTRACE_MAX_STACK_FRAME] = { 0 };
    char** backtrace_strings = NULL;
    size_t backtrace_size = 0;

    backtrace_size = backtrace(backtrace_buffer, BACKTRACE_MAX_STACK_FRAME);
    backtrace_strings = backtrace_symbols(backtrace_buffer, backtrace_size);
    if (backtrace_strings == NULL)
    {
        std::cerr << "Debug: backtrace empty. \n";
    }
    else
    {
        std::cerr << "Debug: backtrace dump(" << backtrace_size << " stack frames).\n";
        for (size_t i = 0; i < backtrace_size; i++)
        {
            std::cerr << backtrace_strings[i] << "\n";
        }
        freeAndNullify(backtrace_strings);
    }
}

/**
 * \brief handles SIGSEGV signals that lead to termination of the program
 * this function specifically works when the client application launched
 * by pcm -- terminates
 */
void sigSEGV_handler(int signum)
{
    printBacktrace();
    sigINT_handler(signum);
}

/**
 * \brief handles signals that lead to restart the application
 * such as SIGHUP.
 * for example to re-read environment variables controlling PCM execution
 */
void sigHUP_handler(int /*signum*/)
{
    // output for DEBUG only
    std::cerr << "DEBUG: caught signal to hangup. Reloading configuration and continue...\n";
    // TODO: restart; so far do nothing

    return; // continue program execution
}

/**
 * \brief handles signals that lead to update of configuration
 * such as SIGUSR1 and SIGUSR2.
 * for the future extensions
 */
void sigUSR_handler(int /*signum*/)
{
    std::cerr << "DEBUG: caught USR signal. Continue.\n";
    // TODO: reload configurationa, reset accumulative counters;

    return;
}

/**
 * \brief handles signals that lead to update of configuration
 * such as SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU
 */
void sigSTOP_handler(int /*signum*/)
{
    PCM * m = PCM::getInstance();
    int runState = m->getRunState();
    std::string state = (runState == 1 ? "suspend" : "continue");
    std::cerr << "DEBUG: caught signal to " << state << " execution.\n"; // debug of signals only
    if (runState == 1) {
        // stop counters and sleep... almost forever;
        m->setRunState(0);
        sleep(INT_MAX);
    } else {
        // resume
        m->setRunState(1);
        alarm(1);
    }
    return;
}

/**
* \brief handles signals that lead to update of configuration
* such as SIGCONT
*/
void sigCONT_handler(int /*signum*/)
{
    std::cout << "DEBUG: caught signal to continue execution.\n"; // debug of signals only
    // TODO: clear counters, resume counting.
    return;
}
#endif // ifdef _MSC_VER

//! \brief install various handlers for system signals
void set_signal_handlers(void)
{
    if (atexit(exit_cleanup) != 0)
    {
        std::cerr << "ERROR: Failed to install exit handler.\n";
        return;
    }

#ifdef _MSC_VER
    BOOL handlerStatus;
    // Increase the priority a bit to improve context switching delays on Windows
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);
// to fix Cygwin/BASH setting Ctrl+C handler need first to restore the default one
    handlerStatus = SetConsoleCtrlHandler(NULL, FALSE); // restores normal processing of CTRL+C input
    if (handlerStatus == 0) {
        tcerr << "Failed to set Ctrl+C handler. Error code: " << GetLastError() << " ";
        const TCHAR * errorStr = _com_error(GetLastError()).ErrorMessage();
        if (errorStr) tcerr << errorStr;
        tcerr << "\n";
        _exit(EXIT_FAILURE);
    }
    handlerStatus = SetConsoleCtrlHandler((PHANDLER_ROUTINE)sigINT_handler, TRUE);
    if (handlerStatus == 0) {
        tcerr << "Failed to set Ctrl+C handler. Error code: " << GetLastError() << " ";
        const TCHAR * errorStr = _com_error(GetLastError()).ErrorMessage();
        if (errorStr) tcerr << errorStr;
        tcerr << "\n";
        _exit(EXIT_FAILURE);
    }
    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)&unhandled_exception_handler);
    char *envPath;
    if (_dupenv_s(&envPath, NULL, "_"))
    {
        std::cerr << "\nPCM ERROR: _dupenv_s failed.\n";
        _exit(EXIT_FAILURE);
    }
    if (envPath)
    {
        std::cerr << "\nPCM ERROR: Detected cygwin/mingw environment which does not allow to setup PMU clean-up handlers on Ctrl-C and other termination signals.\n";
        std::cerr << "See https://www.mail-archive.com/cygwin@cygwin.com/msg74817.html\n";
        std::cerr << "As a workaround please run pcm directly from a native windows shell (e.g. cmd).\n";
        std::cerr << "Exiting...\n\n";
        freeAndNullify(envPath);
        _exit(EXIT_FAILURE);
    }
    freeAndNullify(envPath);
    std::cerr << "DEBUG: Setting Ctrl+C done.\n";

#else
    struct sigaction saINT, saHUP, saUSR, saSTOP, saCONT;

    // install handlers that interrupt execution
    saINT.sa_handler = sigINT_handler;
    sigemptyset(&saINT.sa_mask);
    saINT.sa_flags = SA_RESTART;
    sigaction(SIGINT, &saINT, NULL);
    sigaction(SIGQUIT, &saINT, NULL);
    sigaction(SIGABRT, &saINT, NULL);
    sigaction(SIGTERM, &saINT, NULL);
    
    saINT.sa_flags = SA_RESTART | SA_NOCLDSTOP;
    sigaction(SIGCHLD, &saINT, NULL); // get there is our child exits. do nothing if it stopped/continued

    saINT.sa_handler = sigSEGV_handler;
    sigemptyset(&saINT.sa_mask);
    saINT.sa_flags = SA_RESTART;
    sigaction(SIGSEGV, &saINT, NULL);

    // install SIGHUP handler to restart
    saHUP.sa_handler = sigHUP_handler;
    sigemptyset(&saHUP.sa_mask);
    saHUP.sa_flags = SA_RESTART;
    sigaction(SIGHUP, &saHUP, NULL);

    // install SIGHUP handler to restart
    saUSR.sa_handler = sigUSR_handler;
    sigemptyset(&saUSR.sa_mask);
    saUSR.sa_flags = SA_RESTART;
    sigaction(SIGUSR1, &saUSR, NULL);
    sigaction(SIGUSR2, &saUSR, NULL);

    // install SIGSTOP handler: pause/resume
    saSTOP.sa_handler = sigSTOP_handler;
    sigemptyset(&saSTOP.sa_mask);
    saSTOP.sa_flags = SA_RESTART;
    sigaction(SIGSTOP, &saSTOP, NULL);
    sigaction(SIGTSTP, &saSTOP, NULL);
    sigaction(SIGTTIN, &saSTOP, NULL);
    sigaction(SIGTTOU, &saSTOP, NULL);

    // install SIGCONT & SIGALRM handler
    saCONT.sa_handler = sigCONT_handler;
    sigemptyset(&saCONT.sa_mask);
    saCONT.sa_flags = SA_RESTART;
    sigaction(SIGCONT, &saCONT, NULL);
    sigaction(SIGALRM, &saCONT, NULL);

#endif
    return;
}

//! \brief Restores default signal handlers under Linux/UNIX
void restore_signal_handlers(void)
{
#ifndef _MSC_VER
    struct sigaction action;
    action.sa_handler = SIG_DFL;
    action.sa_flags = 0;
    sigemptyset(&action.sa_mask);

    sigaction(SIGINT, &action, NULL);
    sigaction(SIGQUIT, &action, NULL);
    sigaction(SIGABRT, &action, NULL);
    sigaction(SIGTERM, &action, NULL);
    sigaction(SIGSEGV, &action, NULL);

    sigaction(SIGCHLD, &action, NULL);

    // restore SIGHUP handler to restart
    sigaction(SIGHUP, &action, NULL);

    // restore SIGHUP handler to restart
    sigaction(SIGUSR1, &action, NULL);
    sigaction(SIGUSR2, &action, NULL);

    // restore SIGSTOP handler: pause/resume
//     sigaction(SIGSTOP, &action, NULL); // cannot catch this
// handle SUSP character: normally C-z)
    sigaction(SIGTSTP, &action, NULL);
    sigaction(SIGTTIN, &action, NULL);
    sigaction(SIGTTOU, &action, NULL);

    // restore SIGCONT & SIGALRM handler
    sigaction(SIGCONT, &action, NULL);
    sigaction(SIGALRM, &action, NULL);
#endif

    return;
}

void set_real_time_priority(const bool & silent)
{
    if (!silent)
    {
        std::cerr << "Setting real time priority for the process\n";
    }
#ifdef _MSC_VER
    if (!SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS))
    {
        std::cerr << "ERROR: SetPriorityClass with REALTIME_PRIORITY_CLASS failed with error " << GetLastError() << "\n";
    }
    if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL))
    {
        std::cerr << "ERROR: SetThreadPriority with THREAD_PRIORITY_TIME_CRITICAL failed with error " << GetLastError() << "\n";
    }
#elif __linux__
    const auto priority = sched_get_priority_max(SCHED_RR);
    if (priority == -1)
    {
        std::cerr << "ERROR: Could not get SCHED_RR max priority: " << strerror(errno) << "\n";
    }
    else
    {
        struct sched_param sp = { .sched_priority = priority };
        if (sched_setscheduler(0, SCHED_RR, &sp) == -1)
        {
            const auto errnosave = errno;
            std::cerr << "ERROR: Could not set scheduler to realtime! Errno: " << errnosave << " Error message: \"" << strerror(errnosave) << "\"\n";
        }
        else
        {
            if (!silent)
            {
                std::cerr << "Scheduler changed to SCHED_RR and priority to " << priority << "\n";
            }
        }
    }
#else
    std::cerr << "Setting real time priority for the process not implemented on your OS.\n";
#endif
}

void set_post_cleanup_callback(void(*cb)(void))
{
    post_cleanup_callback = cb;
}

//!\brief launches external program in a separate process
void MySystem(char * sysCmd, char ** sysArgv)
{
    if (sysCmd == NULL) {
        assert("No program provided. NULL pointer");
        exit(EXIT_FAILURE);
    }
    std::cerr << "\nExecuting \"";
    std::cerr << sysCmd;
    std::cerr << "\" command:\n";
#ifdef _MSC_VER
    intptr_t ret;
    char cbuf[128];

    if (PCM::getInstance()->isBlocked()) {  // synchronous start: wait for child process completion
        // in case PCM should be blocked waiting for the child application to end
        // 1. returns and ret = -1 in case of error creating process is encountered
        // 2.
        ret = _spawnvp(_P_WAIT, sysCmd, sysArgv);
        if (ret == -1) { // process creation failed.
            strerror_s(cbuf, 128, errno);
            std::cerr << "Failed to start program \"" << sysCmd << "\". " << cbuf << "\n";
            exit(EXIT_FAILURE);
        } else {         // process created, worked, and completed with exist code in ret. ret=0 -> Success
            std::cerr << "Program exited with status " << ret << "\n";
        }
    } else {             // async start: PCM works in parallel with the child process, and exits when
        ret = _spawnvp(_P_NOWAIT, sysCmd, sysArgv);
        if (ret == -1) {
            strerror_s(cbuf, 128, errno);
            std::cerr << "Failed to start program \"" << sysCmd << "\". " << cbuf << "\n";
            exit(EXIT_FAILURE);
        } else { // ret here is the new process handle.
            // start new thread which will wait for child completion, and continue PCM's execution
            if (_beginthread(waitForChild, 0, (void *)ret) == -1L) {
                strerror_s(cbuf, 128, errno);
                std::cerr << "WARNING: Failed to set waitForChild. PCM will continue infinitely: finish it manually! " << cbuf << "\n";
            }
        }
    }
#else
    pid_t child_pid = fork();

    if (child_pid == 0) {
        execvp(sysCmd, sysArgv);
        std::cerr << "Failed to start program \"" << sysCmd << "\"\n";
        exit(EXIT_FAILURE);
    }
    else
    {
        if (PCM::getInstance()->isBlocked()) {
            int res;
            waitpid(child_pid, &res, 0);
            std::cerr << "Program " << sysCmd << " launched with PID: " << std::dec << child_pid << "\n";

            if (WIFEXITED(res)) {
                std::cerr << "Program exited with status " << WEXITSTATUS(res) << "\n";
            }
            else if (WIFSIGNALED(res)) {
                std::cerr << "Process " << child_pid << " was terminated with status " << WTERMSIG(res) << "\n";
            }
        }
    }
#endif
}

#ifdef _MSC_VER
#define HORIZONTAL     char(196)
#define VERTICAL       char(179)
#define DOWN_AND_RIGHT char(218)
#define DOWN_AND_LEFT  char(191)
#define UP_AND_RIGHT   char(192)
#define UP_AND_LEFT    char(217)
#else
#define HORIZONTAL     u8"\u2500"
#define VERTICAL       u8"\u2502"
#define DOWN_AND_RIGHT u8"\u250C"
#define DOWN_AND_LEFT  u8"\u2510"
#define UP_AND_RIGHT   u8"\u2514"
#define UP_AND_LEFT    u8"\u2518"
#endif

template <class T>
void drawBar(const int nempty, const T & first, const int width, const T & last)
{
    for (int c = 0; c < nempty; ++c)
    {
        std::cout << ' ';
    }
    std::cout << first;
    for (int c = 0; c < width; ++c)
    {
        std::cout << HORIZONTAL;
    }
    std::cout << last << '\n';
}

void drawStackedBar(const std::string & label, std::vector<StackedBarItem> & h, const int width)
{
    int real_width = 0;
    auto scale = [&width](double fraction)
    {
        return int(round(fraction * double(width)));
    };
    for (const auto & i : h)
    {
        real_width += scale(i.fraction);
    }
    if (real_width > 2*width)
    {
        std::cout << "ERROR: sum of fractions > 2 ("<< real_width << " > " << width << ")\n";
        return;
    }
    drawBar((int)label.length(), DOWN_AND_RIGHT, real_width, DOWN_AND_LEFT);
    std::cout << label << VERTICAL;
    for (const auto & i : h)
    {
        const int c_width = scale(i.fraction);
        for (int c = 0; c < c_width; ++c)
        {
            std::cout << i.fill;
        }
    }
    std::cout << VERTICAL << "\n";
    drawBar((int)label.length(), UP_AND_RIGHT, real_width, UP_AND_LEFT);
}


bool CheckAndForceRTMAbortMode(const char * arg, PCM * m)
{
    if (check_argument_equals(arg, {"-force-rtm-abort-mode"}))
    {
        if (nullptr == m)
        {
            m = PCM::getInstance();
            assert(m);
        }
        m->enableForceRTMAbortMode();
        return true;
    }
    return false;
}

std::vector<std::string> split(const std::string & str, const char delim)
{
    std::string token;
    std::vector<std::string> result;
    std::istringstream strstr(str);
    while (std::getline(strstr, token, delim))
    {
        result.push_back(token);
    }
    return result;
}

uint64 read_number(const char* str)
{
    if (str == nullptr || *str == '\0')
    {
        throw std::invalid_argument("Input string is null or empty");
    }

    std::string input(str);
    // Trim leading and trailing whitespace
    size_t start = input.find_first_not_of(" \t\n\r");
    size_t end = input.find_last_not_of(" \t\n\r");
    
    if (start == std::string::npos)
    {
        throw std::invalid_argument("Input string contains only whitespace");
    }
    
    input = input.substr(start, end - start + 1);
    
    std::istringstream stream(input);
    uint64 result = 0;
    
    // Check if the input is hexadecimal (starts with 0x or 0X)
    if (input.length() >= 2 && input[0] == '0' && (input[1] == 'x' || input[1] == 'X'))
    {
        if (input.length() == 2)
        {
            throw std::invalid_argument("Invalid hexadecimal number: no digits after 0x");
        }
        
        // Validate that all characters after 0x are valid hex digits
        for (size_t i = 2; i < input.length(); ++i)
        {
            char c = input[i];
            if (!((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')))
            {
                throw std::invalid_argument("Invalid hexadecimal number: contains non-hex characters");
            }
        }
        
        stream >> std::hex >> result;
    }
    else
    {
        // Validate that all characters are valid decimal digits
        for (size_t i = 0; i < input.length(); ++i)
        {
            char c = input[i];
            if (!(c >= '0' && c <= '9'))
            {
                throw std::invalid_argument("Invalid decimal number: contains non-digit characters");
            }
        }
        
        stream >> result;
    }
    
    // Check if the stream operation failed or if there are remaining characters
    if (stream.fail())
    {
        throw std::invalid_argument("Failed to parse number from input string");
    }
    
    // Check if there are any remaining characters in the stream
    std::string remaining;
    stream >> remaining;
    if (!remaining.empty())
    {
        throw std::invalid_argument("Input string contains extra characters after the number");
    }
    
    return result;
}

// emulates scanf %i for hex 0x prefix otherwise assumes dec (no oct support)
bool match(const std::string& subtoken, const std::string& sname, uint64* result)
{
    if (pcm_sscanf(subtoken) >> s_expect(sname + "0x") >> std::hex >> *result)
        return true;

    if (pcm_sscanf(subtoken) >> s_expect(sname) >> std::dec >> *result)
        return true;

    return false;
}

#define PCM_CALIBRATION_INTERVAL 50 // calibrate clock only every 50th iteration

int calibratedSleep(const double delay, const char* sysCmd, const MainLoop& mainLoop, PCM* m)
{
    static uint64 TimeAfterSleep = 0;
    int delay_ms = int(delay * 1000);

    if (TimeAfterSleep) delay_ms -= (int)(m->getTickCount() - TimeAfterSleep);
    if (delay_ms < 0) delay_ms = 0;

    if (sysCmd == NULL || mainLoop.getNumberOfIterations() != 0 || m->isBlocked() == false)
    {
        if (delay_ms > 0)
        {
            DBG(1, "sleeping for " , std::dec , delay_ms , " ms...");
            MySleepMs(delay_ms);
        }
    }

    TimeAfterSleep = m->getTickCount();

    return delay_ms;
};

void print_help_force_rtm_abort_mode(const int alignment, const char * separator)
{
    if (PCM::isForceRTMAbortModeAvailable() == false)
    {
        return;
    }
    try
    {
        const auto m = PCM::getInstance();
        if (m->getMaxCustomCoreEvents() < 4)
        {
            std::cout << "  -force-rtm-abort-mode";
            for (int i = 0; i < (alignment - 23); ++i)
            {
                std::cout << " ";
            }
            assert(separator);
            std::cout << separator << " force RTM transaction abort mode to enable more programmable counters\n";
        }
    }
    catch (std::exception & e)
    {
        std::cerr << "ERROR: " << e.what() << "\n";
    }
    catch (...)
    {
        std::cerr << "ERROR: Unknown exception caught in print_help_force_rtm_abort_mode\n";
    }
}

#ifdef _MSC_VER
std::string safe_getenv(const char* env)
{
    char * buffer;
    std::string result;
    if (_dupenv_s(&buffer, NULL, env) == 0 && buffer != nullptr)
    {
        result = buffer;
        freeAndNullify(buffer);
    }
    return result;
}
#else
std::string safe_getenv(const char* env)
{
    const auto getenvResult = std::getenv(env);
    return getenvResult ? std::string(getenvResult) : std::string("");
}
#endif

void print_pid_collection_message(int pid)
{
    if (pid != -1)
    {
        std::cerr << "Collecting core metrics for process ID " << std::dec << pid << "\n";
    }
}

double parse_delay(const char *arg, const std::string& progname, print_usage_func print_usage_func)
{
    // any other options positional that is a floating point number is treated as <delay>,
    // while the other options are ignored with a warning issues to stderr
    double delay_input = 0.0;
    std::istringstream is_str_stream(arg);
    is_str_stream >> std::noskipws >> delay_input;
    if(is_str_stream.eof() && !is_str_stream.fail())
    {
        if (delay_input < 0)
        {
            std::cerr << "Invalid delay specified: \"" << *arg << "\". Delay should be positive.\n";
            if(print_usage_func)
            {
                print_usage_func(progname);
            }
            exit(EXIT_FAILURE);
        }
        return delay_input;
    }
    else
    {
        std::cerr << "WARNING: unknown command-line option: \"" << *arg << "\". Ignoring it.\n";
        if(print_usage_func)
        {
            print_usage_func(progname);
        }
        exit(EXIT_FAILURE);
    }
}

std::list<int> extract_integer_list(const char *optarg){
    const char *pstr = optarg;
    std::list<int> corelist;
    std::string snum1, snum2;
    std::string *pnow = &snum1;
    char nchar = ',';
    while(*pstr != '\0' || nchar != ','){
        nchar = ',';
        if (*pstr != '\0'){
            nchar = *pstr;
            pstr++;
        } 
        //printf("c=%c\n",nchar);
        if (nchar=='-' && pnow == &snum1 && snum1.size()>0){
            pnow = &snum2;
        }else if (nchar == ','){
            if (!snum1.empty() && !snum2.empty()){
                int num1 = atoi(snum1.c_str()), num2 =atoi(snum2.c_str());
                if (num2 < num1) std::swap(num1,num2);
                if (num1 < 0) num1 = 0;
                for (int ix=num1; ix <= num2; ix++){
                    corelist.push_back(ix);
                }
            }else if (!snum1.empty()){
                int num1 = atoi(snum1.c_str());
                corelist.push_back(num1);
            }
            snum1.clear();
            snum2.clear();
            pnow = &snum1;
        }else if (nchar != ' '){
            pnow->push_back(nchar);
        }
    }
    return(corelist);
}

bool extract_argument_value(const char* arg, std::initializer_list<const char*> arg_names, std::string& value)
{
    const auto arg_len = strlen(arg);
    for (const auto& arg_name: arg_names) {
        const auto arg_name_len = strlen(arg_name);
        if (arg_len > arg_name_len && strncmp(arg, arg_name, arg_name_len) == 0 && arg[arg_name_len] == '=') {
            value = arg + arg_name_len + 1;
            const auto last_pos = value.find_last_not_of("\"");
            if (last_pos != std::string::npos) {
                value.erase(last_pos + 1);
            }
            const auto first_pos = value.find_first_not_of("\"");
            if (first_pos != std::string::npos) {
                value.erase(0, first_pos);
            }

            return true;
        }
    }

    return false;
}

bool check_argument_equals(const char* arg, std::initializer_list<const char*> arg_names)
{
    const auto arg_len = strlen(arg);
    for (const auto& arg_name: arg_names) {
        if (arg_len == strlen(arg_name) && strncmp(arg, arg_name, arg_len) == 0) {
            return true;
        }
    }

    return false;
}

void check_and_set_silent(int argc, char * argv[], null_stream &nullStream2)
{
    if (argc > 1) do
    {
        argv++;
        argc--;

        if (check_argument_equals(*argv, {"--help", "-h", "/h"}) ||
            check_argument_equals(*argv, {"-silent", "/silent"}))
        {
            std::cerr.rdbuf(&nullStream2);
            return;
        }
    } while (argc > 1);
}

bool check_for_injections(const std::string & str)
{
    const std::array<char, 4> symbols = {'=', '+', '-', '@'};
    if (std::find(std::begin(symbols), std::end(symbols), str[0]) != std::end(symbols)) {
        std::cerr << "ERROR: First letter in event name: " << str << " cannot be \"" << str[0] << "\" , please use escape \"\\\" or remove it\n";
        return true;
    }
    return false;
}

void print_enforce_flush_option_help()
{
    std::cout << "  -f    | /f                         => enforce flushing output\n";
}

bool print_version(int argc, char * argv[])
{
    if (argc > 1) do
    {
        argv++;
        argc--;

        if (check_argument_equals(*argv, {"--version"}))
        {
            std::cout << "version: " << PCM_VERSION << "\n";
            return true;
        }
    } while (argc > 1);

    return false;
}

std::string dos2unix(std::string in)
{
    if (in.length() > 0 && int(in[in.length() - 1]) == 13)
    {
        in.erase(in.length() - 1);
    }
    return in;
}

bool isRegisterEvent(const std::string & pmu)
{
    if (pmu == "mmio"
       || pmu == "pcicfg"
       || pmu == "pmt"
       || pmu == "tpmi"
       || pmu == "package_msr"
       || pmu == "thread_msr")
    {
        return true;
    }
    return false;
}

std::string a_title(const std::string &init, const std::string &name) {
    char begin = init[0];
    std::string row = init;
    row += name;
    return row + begin;
}

std::string a_data (std::string init, struct data d) {
    char begin = init[0];
    std::string row = init;
    std::string str_d = unit_format(d.value);
    row += str_d;
    if (str_d.size() > d.width)
        throw std::length_error("counter value > event_name length");
    row += std::string(d.width - str_d.size(), ' ');
    return row + begin;
}

std::string build_line(std::string init, std::string name, bool last_char = true, char this_char = '_')
{
    char begin = init[0];
    std::string row = init;
    row += std::string(name.size(), this_char);
    if (last_char == true)
        row += begin;
    return row;
}

std::string a_header_footer (std::string init, std::string name)
{
    return build_line(init, name);
}

std::string build_csv_row(const std::vector<std::string>& chunks, const std::string& delimiter)
{
    return std::accumulate(chunks.begin(), chunks.end(), std::string(""),
                           [delimiter](const std::string &left, const std::string &right){
                               return left.empty() ? right : left + delimiter + right;
                           });
}


std::vector<struct data> prepare_data(const std::vector<uint64_t> &values, const std::vector<std::string> &headers)
{
    std::vector<struct data> v;
    uint32_t idx = 0;
    for (std::vector<std::string>::const_iterator iunit = std::next(headers.begin()); iunit != headers.end() && idx < values.size(); ++iunit, idx++)
    {
        struct data d;
        d.width = (uint32_t)iunit->size();
        d.value = values[idx];
        v.push_back(d);
    }

    return v;
}

void display(const std::vector<std::string> &buff, std::ostream& stream)
{
    for (std::vector<std::string>::const_iterator iunit = buff.begin(); iunit != buff.end(); ++iunit)
        stream << *iunit << "\n";
    stream << std::flush;
}

void print_nameMap(const PCIeEventNameMap& nameMap)
{
    for (const auto& iunit : nameMap)
    {
        const std::string& h_name = iunit.first;
        const auto& value = iunit.second;
        uint32_t hid = value.first;
        const auto& vMap = value.second;
        std::cout << "H name: " << h_name << " id =" << hid << " vMap size:" << vMap.size() << "\n";
        for (const auto& junit : vMap)
        {
            const std::string& v_name = junit.first;
            uint32_t vid = junit.second;
            std::cout << "V name: " << v_name << " id =" << vid << "\n";
        }
    }
}

//! \brief load_events: parse the evt config file.
//! \param fn:event config file name.
//! \param ofm: operation field map struct.
//! \param pfn_evtcb: see below.
//! \param evtcb_ctx: pointer of the callback context(user define).
//! \param nameMap: human readable metrics names.
//! \return -1 means fail, 0 means success.

//! \brief pfn_evtcb: call back func of event config file processing, app should provide it.
//! \param void *: pointer of the callback context.
//! \param counter &: common base counter struct.
//! \param std::map<std::string, uint32_t> &: operation field map struct.
//! \param std::string: event field name.
//! \param uint64: event field value.
//! \return -1 means fail with app exit, 0 means success or fail with continue.
int load_events(const std::string &fn, std::map<std::string, uint32_t> &ofm,
                int (*pfn_evtcb)(evt_cb_type, void *, counter &, std::map<std::string, uint32_t> &, std::string, uint64),
                void *evtcb_ctx, PCIeEventNameMap& nameMap)
{
    struct counter ctr;

    std::ifstream in(fn);
    std::string line, item;
    if (!in.is_open())
    {
        const auto alt_fn = getInstallPathPrefix() + fn;
        std::cout << "INFO: Couldn't load event config file " << fn << ", trying to load it from PCM install path: " << alt_fn << std::endl;
        in.open(alt_fn);
        if (!in.is_open())
        {
            in.close();
            const auto err_msg = std::string("event config file ") + fn + " or " + alt_fn + " is not available, you can try to manually copy it from PCM source package.";
            throw std::invalid_argument(err_msg);
        }
    }

    while (std::getline(in, line))
    {
        //TODO: substring until #, if len == 0, skip, else parse normally
        //Set default value if the item is NOT available in cfg file.
        ctr.h_event_name = "INVALID";
        ctr.v_event_name = "INVALID";
        ctr.ccr = 0;
        ctr.idx = 0;
        ctr.multiplier = 1;
        ctr.divider = 1;
        ctr.h_id = 0;
        ctr.v_id = 0;

        if (pfn_evtcb(EVT_LINE_START, evtcb_ctx, ctr, ofm, "", 0))
        {
            in.close();
            const auto err_msg = std::string("event line processing(start) fault.\n");
            throw std::invalid_argument(err_msg);
        }

        /* Ignore anyline with # */
        if (line.find("#") != std::string::npos) continue;
        /* If line does not have any deliminator, we ignore it as well */
        if (line.find("=") == std::string::npos) continue;

        std::string h_name, v_name;
        std::istringstream iss(line);
        while (std::getline(iss, item, ','))
        {
            std::string key, value;
            uint64 numValue;
            /* assume the token has the format <key>=<value> */
            key = item.substr(0,item.find("="));
            value = item.substr(item.find("=")+1);

            if (key.empty() || value.empty())
                continue; //skip the item if the token invalid

            std::istringstream iss2(value);
            iss2 >> std::setbase(0) >> numValue;

            switch (ofm[key])
            {
                case PCM::H_EVENT_NAME:
                    h_name = dos2unix(value);
                    ctr.h_event_name = h_name;
                    if (nameMap.find(h_name) == nameMap.end())
                    {
                        /* It's a new horizontal event name */
                        auto next_h_id = static_cast<uint32_t>(nameMap.size());
                        auto nameMap_value = std::make_pair(next_h_id, CounterValueMap());
                        nameMap[h_name] = nameMap_value;
                    }
                    ctr.h_id = static_cast<uint32_t>(nameMap.size()) - 1;
                    DBG(2, "h_name:" , ctr.h_event_name , "h_id: ", ctr.h_id);
                    break;
                case PCM::V_EVENT_NAME:
                    {
                        v_name = dos2unix(value);
                        ctr.v_event_name = v_name;
                        //XXX: If h_name comes after v_name, we'll have a problem.
                        //XXX: It's very weird, I forgot to assign nameMap[h_name] = nameMap_value earlier (:298), but this part still works?
                        auto& v_nameMap = nameMap[h_name].second;
                        if (v_nameMap.find(v_name) == v_nameMap.end())
                        {
                            v_nameMap[v_name] = static_cast<uint32_t>(v_nameMap.size()) - 1;
                            DBG(2, "v_name(" , v_name , ")=", v_nameMap[v_name]);
                        }
                        else
                        {
                            in.close();
                            const auto err_msg = std::string("Detect duplicated v_name:") + v_name + "\n";
                            throw std::invalid_argument(err_msg);
                        }
                        ctr.v_id = static_cast<uint32_t>(v_nameMap.size()) - 1;
                        DBG(2, "h_name:" , ctr.h_event_name , ",hid=" , ctr.h_id , ",v_name:" , ctr.v_event_name , ",v_id: ", ctr.v_id);
                        break;
                    }
                //TODO: double type for multiplier. drop divider variable
                case PCM::MULTIPLIER:
                    ctr.multiplier = static_cast<int>(numValue);
                    break;
                case PCM::DIVIDER:
                    ctr.divider = static_cast<int>(numValue);
                    break;
                case PCM::COUNTER_INDEX:
                    ctr.idx = static_cast<int>(numValue);
                    break;
                case PCM::UNIT_TYPE:
                    {
                        auto typeString = dos2unix(value);
                        if (typeString == std::string("iio"))
                        {
                            ctr.type = CounterType::iio;
                        }
                        else
                        {
                            in.close();
                            const auto err_msg = std::string("event line processing(end) fault.\n");
                            throw std::invalid_argument(err_msg);
                        }
                    }
                    break;
                default:
                    if (pfn_evtcb(EVT_LINE_FIELD, evtcb_ctx, ctr, ofm, key, numValue))
                    {
                        in.close();
                        const auto err_msg = std::string("event line processing(field) fault.\n");
                        throw std::invalid_argument(err_msg);
                    }
                    break;
            }
        }

        DBG(2, "Finished parsing: " , line);
        if (pfn_evtcb(EVT_LINE_COMPLETE, evtcb_ctx, ctr, ofm, "", 0))
        {
            in.close();
            const auto err_msg = std::string("event line processing(end) fault.\n");
            throw std::invalid_argument(err_msg);
        }
    }

    //print_nameMap(nameMap); //DEBUG purpose
    in.close();
    return 0;
}

int load_events(const std::string &fn, std::map<std::string, uint32_t> &ofm,
                int (*pfn_evtcb)(evt_cb_type, void *, counter &, std::map<std::string, uint32_t> &, std::string, uint64),
                void *evtcb_ctx)
{
    PCIeEventNameMap nm;
    return load_events(fn, ofm, pfn_evtcb, evtcb_ctx, nm);
}

bool get_cpu_bus(uint32 msmDomain, uint32 msmBus, uint32 msmDev, uint32 msmFunc, uint32 &cpuBusValid, std::vector<uint32> &cpuBusNo, int &cpuPackageId)
{
    DBG(2, "get_cpu_bus: d=" , std::hex , msmDomain , ",b=" , msmBus , ",d=" , msmDev , ",f=" , msmFunc , std::dec );
    try
    {
        PciHandleType h(msmDomain, msmBus, msmDev, msmFunc);

        h.read32(SPR_MSM_REG_CPUBUSNO_VALID_OFFSET, &cpuBusValid);
        if (cpuBusValid == (std::numeric_limits<uint32>::max)()) {
            std::cerr << "Failed to read CPUBUSNO_VALID" << std::endl;
            return false;
        }

        if (!cpuBusValid)
        {
            /**
             * Return true because an unexpected device might appear in the OS due to specific configurations.
             * This ensures the function does not fail in such cases and allows further processing.
             */
            std::cerr << "CPUBUSNO_VALID is 0" << std::endl;
            return true;
        }

        cpuBusNo.resize(8);
        for (int i = 0; i < 4; ++i) {
            h.read32(SPR_MSM_REG_CPUBUSNO0_OFFSET + i * 4, &cpuBusNo[i]);

            h.read32(SPR_MSM_REG_CPUBUSNO4_OFFSET + i * 4, &cpuBusNo[i + 4]);

            if (cpuBusNo[i] == (std::numeric_limits<uint32>::max)() ||
                cpuBusNo[i + 4] == (std::numeric_limits<uint32>::max)()) {
                std::cerr << "Failed to read CPUBUSNO registers" << std::endl;
                return false;
            }
        }

        /*
        * It's possible to have not enabled first stack that's why
        * need to find the first valid bus to read CSR
        */
        int firstValidBusId = 0;
        while (!((cpuBusValid >> firstValidBusId) & 0x1)) firstValidBusId++;
        int cpuBusNo0 = (cpuBusNo[(int)(firstValidBusId / 4)] >> ((firstValidBusId % 4) * 8)) & 0xff;

        uint32 sadControlCfg = 0x0;
        PciHandleType sad_cfg_handler(msmDomain, cpuBusNo0, 0, 0);
        sad_cfg_handler.read32(SPR_SAD_REG_CTL_CFG_OFFSET, &sadControlCfg);
        if (sadControlCfg == (std::numeric_limits<uint32>::max)()) {
            std::cerr << "Failed to read SAD_CONTROL_CFG" << std::endl;
            return false;
        }
        cpuPackageId = sadControlCfg & 0xf;

        return true;
    }
    catch (...)
    {
        std::cerr << "Warning: unable to enumerate CPU Buses" << std::endl;
        return false;
    }
}

std::pair<int64,int64> parseBitsParameter(const char * param)
{
    std::pair<int64,int64> bits{-1, -1};
    const auto bitsArray = pcm::split(std::string(param),':');
    switch ( bitsArray.size() ) {
    case 1:
        bits.first  = (int64)read_number(bitsArray[0].c_str());
        bits.second = bits.first;
        break;
    case 2:
        bits.first = (int64)read_number(bitsArray[0].c_str());
        bits.second = (int64)read_number(bitsArray[1].c_str());
        break;
    default:
        assert(bitsArray.size() == 1 || bitsArray.size() == 2);
    }
    assert(bits.first >= 0);
    assert(bits.second >= 0);
    assert(bits.first < 64);
    assert(bits.second < 64);
    if (bits.first > bits.second)
    {
        std::swap(bits.first, bits.second);
    }
    return bits;
}

#ifdef __linux__
FILE * tryOpen(const char * path, const char * mode)
{
    // SDL330: O_NOFOLLOW rejects symlinks atomically (no TOCTOU)
    int flags = O_NOFOLLOW;
    if (strchr(mode, 'w')) {
        flags |= O_WRONLY | O_CREAT | O_TRUNC;
    } else {
        flags |= O_RDONLY;
    }

    int fd = open(path, flags, 0644);
    if (fd < 0)
    {
        const std::string alt_path = std::string("/pcm") + path;
        fd = open(alt_path.c_str(), flags, 0644);
    }

    if (fd < 0) {
        return nullptr;
    }

    FILE * f = fdopen(fd, mode);
    if (!f) {
        close(fd);
    }
    return f;
}

std::string readSysFS(const char * path, bool silent)
{
    FILE * f = tryOpen(path, "r");
    if (!f)
    {
        if (silent == false) std::cerr << "ERROR: Can not open " << path << " file.\n";
        return std::string();
    }
    char buffer[1024];
    if(NULL == fgets(buffer, 1024, f))
    {
        if (silent == false) std::cerr << "ERROR: Can not read from " << path << ".\n";
        fclose(f);
        return std::string();
    }
    fclose(f);
    
    return std::string(buffer);
}

bool writeSysFS(const char * path, const std::string & value, bool silent)
{
    FILE * f = tryOpen(path, "w");
    if (!f)
    {
        if (silent == false) std::cerr << "ERROR: Can not open " << path << " file.\n";
        return false;
    }
    if (fputs(value.c_str(), f) < 0)
    {
        if (silent == false) std::cerr << "ERROR: Can not write to " << path << ".\n";
        fclose(f);
        return false;
    }
    fclose(f);
    return true;
}

int readMaxFromSysFS(const char * path)
{
    std::string content = readSysFS(path);
    const char * buffer = content.c_str();
    int result = -1;
    pcm_sscanf(buffer) >> s_expect("0-") >> result;
    if(result == -1)
    {
       pcm_sscanf(buffer) >> result;
    }
    return result;
}

bool readMapFromSysFS(const char * path, std::unordered_map<std::string, uint32> &result, bool silent)
{
    FILE * f = tryOpen(path, "r");
    if (!f)
    {
        if (silent == false) std::cerr << "ERROR: Can not open " << path << " file.\n";
        return false;
    }
    char buffer[1024];
    while(fgets(buffer, 1024, f) != NULL)
    {
        std::string key, value, item;
        uint32 numValue = 0;

        item = std::string(buffer);
        key = item.substr(0,item.find(" "));
        value = item.substr(item.find(" ")+1);
        if (key.empty() || value.empty())
            continue; //skip the item if the token invalid
        std::istringstream iss2(value);
        iss2 >> std::setbase(0) >> numValue;
        result.insert(std::pair<std::string, uint32>(key, numValue));
        DBG(3, "readMapFromSysFS:" , key , "=" , numValue , ".");
    }

    fclose(f);
    return true;
}
#endif

#ifdef _MSC_VER

//! restrict usage of driver to system (SY) and builtin admins (BA)
void restrictDriverAccessNative(LPCTSTR path)
{
    PSECURITY_DESCRIPTOR pSD = nullptr;

    if (!ConvertStringSecurityDescriptorToSecurityDescriptor(
        _T("O:BAG:SYD:(A;;FA;;;SY)(A;;FA;;;BA)"),
        SDDL_REVISION_1,
        &pSD,
        nullptr))
    {
        _tprintf(TEXT("Error in ConvertStringSecurityDescriptorToSecurityDescriptor: %d\n"), GetLastError());
        return;
    }

    if (SetFileSecurity(path, DACL_SECURITY_INFORMATION, pSD))
    {
        // _tprintf(TEXT("Successfully restricted access for %s\n"), path);
    }
    else
    {
        _tprintf(TEXT("Error in SetFileSecurity for %s. Error %d\n"), path, GetLastError());
    }

    LocalFree(pSD);
}
#endif

} // namespace pcm

```

`src/utils.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev


/*!     \file utils.h
        \brief Some common utility routines
  */

#pragma once

#include <cstdio>
#include <cstring>
#include <fstream>
#include <time.h>
#include "types.h"
#include "debug.h"
#include <vector>
#include <list>
#include <chrono>
#include <math.h>
#include <assert.h>

#if defined(__FreeBSD__) || (defined(__DragonFly__) && __DragonFly_version >= 400707)
#include <pthread_np.h>
#include <sys/_cpuset.h>
#include <sys/cpuset.h>
#endif

#ifndef _MSC_VER
#include <unistd.h>
#include <csignal>
#include <ctime>
#include <cmath>
#else
#include <intrin.h>
#endif
#include <map>
#include <unordered_map>

#ifdef __linux__
#include <unistd.h>
#endif

namespace pcm {

    template <class T>
    inline void deleteAndNullify(T & p)
    {
        if (p)
        {
            delete p;
            p = nullptr;
        }
    }

    template <class T>
    inline void deleteAndNullifyArray(T & p)
    {
        if (p)
        {
            delete [] p;
            p = nullptr;
        }
    }

    template <class T>
    inline void freeAndNullify(T & p)
    {
        if (p)
        {
            free(p);
            p = nullptr;
        }
    }

    std::string safe_getenv(const char* env);
#ifdef _MSC_VER
    typedef std::wstring StringType;
    #define PCM_STRING(x) (L ## x)
#else
    typedef std::string StringType;
    #define PCM_STRING(x) (x)
#endif
    void eraseEnvironmentVariables(const std::vector<StringType>& keepList);
    void setDefaultDebugLevel();
}

#ifdef _MSC_VER
// Security hardening: remove the current working directory from the DLL search
// order to prevent DLL planting attacks (CWE-427). This ensures DLLs are only
// loaded from trusted system directories.
#define PCM_SET_DLL_DIR SetDllDirectory(_T("")); SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_SYSTEM32);
#else
#define PCM_SET_DLL_DIR
#endif

#define PCM_MAIN_NOTHROW \
int mainThrows(int argc, char * argv[]); \
int main(int argc, char * argv[]) \
{ \
    try { \
       eraseEnvironmentVariables({PCM_STRING("POSIXLY_CORRECT"), PCM_STRING("SystemRoot")}); \
    } catch(const std::exception & e) \
    { \
        std::cerr << "PCM ERROR. Exception in eraseEnvironmentVariables: " << e.what() << "\n"; \
        return -1; \
    } \
    PCM_SET_DLL_DIR \
    if (pcm::safe_getenv("PCM_NO_MAIN_EXCEPTION_HANDLER") == std::string("1")) return mainThrows(argc, argv); \
    try { \
        setDefaultDebugLevel(); \
        return mainThrows(argc, argv); \
    } catch(const std::runtime_error & e) \
    { \
        std::cerr << "PCM ERROR. Exception " << e.what() << "\n"; \
    } catch(const std::exception & e) \
    { \
        std::cerr << "PCM ERROR. Exception " << e.what() << "\n"; \
    } catch (...) \
    { \
        std::cerr << "PCM ERROR. Exception detected (no further details available).\n"; \
    } \
    return -1; \
}

namespace pcm {

#ifdef _MSC_VER
    using tstring = std::basic_string<TCHAR>;
#ifdef UNICODE
    static auto& tcerr = std::wcerr;
#else
    static auto& tcerr = std::cerr;
#endif
#endif // _MSC_VER

typedef void (* print_usage_func)(const std::string & progname);
std::list<int> extract_integer_list(const char *optarg);
double parse_delay(const char * arg, const std::string & progname, print_usage_func print_usage_func);
bool extract_argument_value(const char * arg, std::initializer_list<const char*> arg_names, std::string & value);
bool check_argument_equals(const char * arg, std::initializer_list<const char*> arg_names);
bool check_for_injections(const std::string & str);

void exit_cleanup(void);
void set_signal_handlers(void);
void set_real_time_priority(const bool & silent);
void restore_signal_handlers(void);
#ifndef _MSC_VER
void printBacktrace();
void sigINT_handler(int signum);
void sigHUP_handler(int signum);
void sigUSR_handler(int signum);
void sigSTOP_handler(int signum);
void sigCONT_handler(int signum);
#endif

void set_post_cleanup_callback(void(*cb)(void));

inline void MySleep(int delay)
{
#ifdef _MSC_VER
    if (delay) Sleep(delay * 1000);
#else
    ::sleep(delay);
#endif
}

inline void MySleepMs(int delay_ms)
{
#ifdef _MSC_VER
    if (delay_ms) Sleep((DWORD)delay_ms);
#else
    struct timespec sleep_intrval;
    double complete_seconds;
    sleep_intrval.tv_nsec = static_cast<long>(1000000000.0 * (::modf(delay_ms / 1000.0, &complete_seconds)));
    sleep_intrval.tv_sec = static_cast<time_t>(complete_seconds);
    ::nanosleep(&sleep_intrval, NULL);
#endif
}

void MySystem(char * sysCmd, char ** argc);

#ifdef _MSC_VER
#pragma warning (disable : 4068 ) // disable unknown pragma warning
#endif

#ifdef __GCC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Woverloaded-virtual"
#elif defined __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Woverloaded-virtual"
#endif
struct null_stream : public std::streambuf
{
    int_type overflow(int_type) override { return {}; }
};
#ifdef __GCC__
#pragma GCC diagnostic pop
#elif defined __clang__
#pragma clang diagnostic pop
#endif

constexpr const char* ASCII_BLACK = "\033[0;30m";
constexpr const char* ASCII_RED = "\033[0;31m";
constexpr const char* ASCII_GREEN = "\033[0;32m";
constexpr const char* ASCII_YELLOW = "\033[0;33m";
constexpr const char* ASCII_BLUE = "\033[0;34m";
constexpr const char* ASCII_MAGENTA = "\033[0;35m";
constexpr const char* ASCII_CYAN = "\033[0;36m";
constexpr const char* ASCII_WHITE = "\033[0;37m";
constexpr const char* ASCII_BRIGHT_BLACK = "\033[1;30m";
constexpr const char* ASCII_BRIGHT_RED = "\033[1;31m";
constexpr const char* ASCII_BRIGHT_GREEN = "\033[1;32m";
constexpr const char* ASCII_BRIGHT_YELLOW = "\033[1;33m";
constexpr const char* ASCII_BRIGHT_BLUE = "\033[1;34m";
constexpr const char* ASCII_BRIGHT_MAGENTA = "\033[1;35m";
constexpr const char* ASCII_BRIGHT_CYAN = "\033[1;36m";
constexpr const char* ASCII_BRIGHT_WHITE = "\033[1;37m";
constexpr const char* ASCII_RESET_COLOR = "\033[0m";

void setColorEnabled(bool value = true);
const char * setColor(const char * colorStr);
const char * setNextColor();
const char * resetColor();

template <class IntType>
inline std::string unit_format(IntType n)
{
    char buffer[1024];
    if (n <= 9999ULL)
    {
        snprintf(buffer, 1024, "%4d  ", int32(n));
        return std::string{buffer};
    }
    if (n <= 9999999ULL)
    {
        snprintf(buffer, 1024, "%4d K", int32(n / 1000ULL));
        return std::string{buffer};
    }
    if (n <= 9999999999ULL)
    {
        snprintf(buffer, 1024, "%4d M", int32(n / 1000000ULL));
        return std::string{buffer};
    }
    if (n <= 9999999999999ULL)
    {
        snprintf(buffer, 1024, "%4d G", int32(n / 1000000000ULL));
        return std::string{buffer};
    }

    snprintf(buffer, 1024, "%4d T", int32(n / (1000000000ULL * 1000ULL)));
    return std::string{buffer};
}

void print_cpu_details();


inline void printDebugCallstack()
{
#ifndef _MSC_VER
    if (safe_getenv("PCM_PRINT_DEBUG_CALLSTACK") == "1")
    {
        printBacktrace();
    }
#endif
}

template <unsigned Bytes>
inline void warnAlignment(const char* call, const bool silent, const uint64 offset)
{
    if (silent == false && (offset % Bytes) != 0)
    {
        std::cerr << "PCM Warning: " << call << " offset " << offset << " is not " << Bytes << "-byte aligned\n";
        printDebugCallstack();
    }
}

#define PCM_UNUSED(x) (void)(x)

#define PCM_COMPILE_ASSERT(condition) \
    typedef char pcm_compile_assert_failed[(condition) ? 1 : -1]; \
    pcm_compile_assert_failed pcm_compile_assert_failed_; \
    PCM_UNUSED(pcm_compile_assert_failed_);

#ifdef _MSC_VER
class ThreadGroupTempAffinity
{
    GROUP_AFFINITY PreviousGroupAffinity;
    bool restore;

    ThreadGroupTempAffinity();                                              // forbidden
    ThreadGroupTempAffinity(const ThreadGroupTempAffinity &);               // forbidden
    ThreadGroupTempAffinity & operator = (const ThreadGroupTempAffinity &); // forbidden

public:
    ThreadGroupTempAffinity(uint32 core_id, bool checkStatus = true, const bool restore_ = false);
    ~ThreadGroupTempAffinity();
};
#endif

class checked_uint64 // uint64 with checking for overflows when computing differences
{
    uint64 data;
    uint64 overflows;
public:
    checked_uint64() : data(0), overflows(0) {}
    checked_uint64(const uint64 d, const uint64 o) : data(d), overflows(o) {}
    const checked_uint64& operator += (const checked_uint64& o)
    {
        data += o.data;
        overflows += o.overflows;
        return *this;
    }

    uint64 operator - (const checked_uint64& o) const
    {
        // computing data - o.data
        constexpr uint64 counter_width = 48;
        return data + overflows * (1ULL << counter_width) - o.data;
    }

    uint64 getRawData_NoOverflowProtection() const { return data; }
};

// a secure (but partial) alternative for sscanf
// see example usage in pcm-core.cpp
typedef std::istringstream pcm_sscanf;

class s_expect : public std::string
{
public:
    explicit s_expect(const char * s) : std::string(s) {}
    explicit s_expect(const std::string & s) : std::string(s) {}
    friend std::istream & operator >> (std::istream & istr, s_expect && s);
    friend std::istream & operator >> (std::istream && istr, s_expect && s);
private:

    void match(std::istream & istr) const
    {
        istr >> std::noskipws;
        const auto len = length();
        char * buffer = new char[len + 2];
        buffer[0] = 0;
        istr.get(buffer, len+1);
        if (*this != std::string(buffer))
        {
            istr.setstate(std::ios_base::failbit);
        }
        deleteAndNullifyArray(buffer);
    }
};

inline std::istream & operator >> (std::istream & istr, s_expect && s)
{
    s.match(istr);
    return istr;
}

inline std::istream & operator >> (std::istream && istr, s_expect && s)
{
    s.match(istr);
    return istr;
}

inline std::pair<tm, uint64> pcm_localtime() // returns <tm, milliseconds>
{
    const auto durationSinceEpoch = std::chrono::system_clock::now().time_since_epoch();
    const auto durationSinceEpochInSeconds = std::chrono::duration_cast<std::chrono::seconds>(durationSinceEpoch);
    time_t now = durationSinceEpochInSeconds.count();
    tm result{};
#ifdef _MSC_VER
    localtime_s(&result, &now);
#else
    localtime_r(&now, &result);
#endif
    return std::make_pair(result, std::chrono::duration_cast<std::chrono::milliseconds>(durationSinceEpoch- durationSinceEpochInSeconds).count());
}

enum CsvOutputType
{
    Header1,
    Header2,
    Data,
    Header21, // merged headers 2 and 1
    Json
};

template <class H1, class H2, class D>
inline void choose(const CsvOutputType outputType, H1 h1Func, H2 h2Func, D dataFunc)
{
    switch (outputType)
    {
    case Header1:
    case Header21:
        h1Func();
        break;
    case Header2:
        h2Func();
        break;
    case Data:
    case Json:
        dataFunc();
        break;
    default:
        std::cerr << "PCM internal error: wrong CSvOutputType\n";
    }
}

inline void printDateForCSV(const CsvOutputType outputType, std::string separator = std::string(","), std::string * out = nullptr)
{
    std::ostringstream strstr;
    std::ostream & stdcout = out ? strstr : std::cout;
    choose(outputType,
        [&separator, &stdcout]() {
            stdcout << separator << separator; // Time
        },
        [&separator, &stdcout]() {
            stdcout << "Date" << separator << "Time" << separator;
        },
        [&separator, &stdcout]() {
            std::pair<tm, uint64> tt{ pcm_localtime() };
            stdcout.precision(3);
            char old_fill = stdcout.fill('0');
            stdcout <<
                std::setw(4) <<  1900 + tt.first.tm_year << '-' <<
                std::setw(2) << 1 + tt.first.tm_mon << '-' <<
                std::setw(2) << tt.first.tm_mday << separator <<
                std::setw(2) << tt.first.tm_hour << ':' <<
                std::setw(2) << tt.first.tm_min << ':' <<
                std::setw(2) << tt.first.tm_sec << '.' <<
                std::setw(3) << tt.second << separator; // milliseconds
            stdcout.fill(old_fill);
            stdcout.setf(std::ios::fixed);
            stdcout.precision(2);
        });
        if (out)
        {
            *out = strstr.str();
        }
}

inline void printDateForJson(const std::string& separator, const std::string &jsonSeparator)
{
    std::pair<tm, uint64> tt{ pcm_localtime() };
    std::cout.precision(3);
    char old_fill = std::cout.fill('0');
    std::cout <<
        "Date" << jsonSeparator << "\"" <<
        std::setw(4) <<  1900 + tt.first.tm_year << '-' <<
        std::setw(2) << 1 + tt.first.tm_mon << '-' <<
        std::setw(2) << tt.first.tm_mday << "\"" << separator <<
        "Time" << jsonSeparator << "\"" <<
        std::setw(2) << tt.first.tm_hour << ':' <<
        std::setw(2) << tt.first.tm_min << ':' <<
        std::setw(2) << tt.first.tm_sec << '.' <<
        std::setw(3) << tt.second << "\"" << separator; // milliseconds
    std::cout.fill(old_fill);
    std::cout.setf(std::ios::fixed);
    std::cout.precision(2);
}

std::vector<std::string> split(const std::string & str, const char delim);

class PCM;
bool CheckAndForceRTMAbortMode(const char * argv, PCM * m);

void print_help_force_rtm_abort_mode(const int alignment, const char * separator = "=>");

template <class F>
void parseParam(int argc, char* argv[], const char* param, F f)
{
    if (argc > 1) do
    {
        argv++;
        argc--;
        if ((std::string("-") + param == *argv) || (std::string("/") + param == *argv))
        {
            argv++;
            argc--;
            if (argc == 0)
            {
                std::cerr << "ERROR: no parameter provided for option " << param << "\n";
                exit(EXIT_FAILURE);
            }
            f(*argv);
            continue;
        }
    } while (argc > 1); // end of command line parsing loop
}

class MainLoop
{
    unsigned numberOfIterations = 0;
public:
    MainLoop() {}
    bool parseArg(const char * arg)
    {
        std::string arg_value;
        if (extract_argument_value(arg, {"-i", "/i"}, arg_value))
        {
            numberOfIterations = (unsigned int)atoi(arg_value.c_str());
            return true;
        }
        
        return false;
    }
    unsigned getNumberOfIterations() const
    {
        return numberOfIterations;
    }
    template <class Body>
    void operator ()(const Body & body)
    {
        unsigned int i = 1;
        DBG(1, "numberOfIterations: " , numberOfIterations);
        while ((i <= numberOfIterations) || (numberOfIterations == 0))
        {
            if (body() == false)
            {
                break;
            }
            ++i;
        }
    }
};

#ifdef __linux__
FILE * tryOpen(const char * path, const char * mode);
std::string readSysFS(const char * path, bool silent);
bool writeSysFS(const char * path, const std::string & value, bool silent);
#endif

int calibratedSleep(const double delay, const char* sysCmd, const MainLoop& mainLoop, PCM* m);

struct StackedBarItem {
    double fraction{0.0};
    std::string label{""}; // not used currently
    char fill{'0'};
    StackedBarItem() {}
    StackedBarItem(double fraction_,
        const std::string & label_,
        char fill_) : fraction(fraction_), label(label_), fill(fill_) {}
};

void drawStackedBar(const std::string & label, std::vector<StackedBarItem> & h, const int width = 80);

// emulates scanf %i for hex 0x prefix otherwise assumes dec (no oct support)
bool match(const std::string& subtoken, const std::string& sname, uint64* result);

uint64 read_number(const char* str);

inline void clear_screen() {
#ifdef _MSC_VER
    system("cls");
#else
    std::cout << "\033[2J\033[0;0H";
#endif
}

#ifdef _MSC_VER

#define PCM_MSR_DRV_NAME TEXT("\\\\.\\RDMSR")

inline HANDLE openMSRDriver()
{
    return CreateFile(PCM_MSR_DRV_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
}
#endif

#define PCM_ENFORCE_FLUSH_OPTION else if (check_argument_equals(*argv, { "-f", "/f" })) { enforceFlush = true; continue; }
void print_enforce_flush_option_help();

// called before everything else to read '-s' arg and
// silence all following err output
void check_and_set_silent(int argc, char * argv[], null_stream &nullStream2);

void print_pid_collection_message(int pid);

bool print_version(int argc, char * argv[]);

inline bool isPIDOption(char * argv [])
{
    return check_argument_equals(*argv, {"-pid", "/pid"});
}

inline void parsePID(int argc, char* argv[], int& pid)
{
    parseParam(argc, argv, "pid", [&pid](const char* p) { if (p) pid = atoi(p); });
}

enum class CounterType {
    COUNTER_TYPE_INVALID = -1,
    iio = 0,
    COUNTER_TYPES_COUNT
};

struct counter {
    std::string h_event_name = "";
    std::string v_event_name = "";
    uint64_t ccr = 0;
    int idx = 0; /* Some counters need to be placed in specific index */
    int multiplier = 0;
    int divider = 0;
    uint32_t h_id = 0;
    uint32_t v_id = 0;
    CounterType type = CounterType::COUNTER_TYPE_INVALID;
};

struct data{
    uint32_t width;
    uint64_t value;
};

typedef enum{
    EVT_LINE_START,
    EVT_LINE_FIELD,
    EVT_LINE_COMPLETE
}evt_cb_type;

using EventName = std::string;
using CounterName = std::string;

using CounterValueMap = std::unordered_map<CounterName, uint32_t>;
using EventDefinition = std::pair<uint32_t, CounterValueMap>;
using PCIeEventNameMap = std::unordered_map<EventName, EventDefinition>;

void getMCFGRecords(std::vector<MCFGRecord>& mcfg);
std::string dos2unix(std::string in);
bool isRegisterEvent(const std::string & pmu);
std::string a_title (const std::string &init, const std::string &name);
std::string a_data (std::string init, struct data d);
std::string a_header_footer(std::string init, std::string name);
std::string build_line(std::string init, std::string name, bool last_char, char this_char);
std::string build_csv_row(const std::vector<std::string>& chunks, const std::string& delimiter);
std::vector<struct data> prepare_data(const std::vector<uint64_t> &values, const std::vector<std::string> &headers);
void display(const std::vector<std::string> &buff, std::ostream& stream);

void print_nameMap(const PCIeEventNameMap& nameMap);
int load_events(const std::string &fn, std::map<std::string, uint32_t> &ofm,
                int (*p_fn_evtcb)(evt_cb_type, void *, counter &, std::map<std::string, uint32_t> &, std::string, uint64),
                void *evtcb_ctx, PCIeEventNameMap& nameMap);
int load_events(const std::string &fn, std::map<std::string, uint32_t> &ofm,
                int (*pfn_evtcb)(evt_cb_type, void *, counter &, std::map<std::string, uint32_t> &, std::string, uint64),
                void *evtcb_ctx);

bool get_cpu_bus(uint32 msmDomain, uint32 msmBus, uint32 msmDev, uint32 msmFunc, uint32 &cpuBusValid, std::vector<uint32> &cpuBusNo, int &cpuPackageId);

#ifdef __linux__
FILE * tryOpen(const char * path, const char * mode);
std::string readSysFS(const char * path, bool silent = false);
bool writeSysFS(const char * path, const std::string & value, bool silent = false);
int readMaxFromSysFS(const char * path);
bool readMapFromSysFS(const char * path, std::unordered_map<std::string, uint32> &result, bool silent = false);
#endif

inline uint64 insertBits(uint64 input, const uint64 value, const int64_t position, const uint64 width)
{
    const uint64 mask = (width == 64) ? (~0ULL) : ((1ULL << width) - 1ULL); // 1 -> 1b, 2 -> 11b, 3 -> 111b
    input &= ~(mask << position); // clear
    input |= (value & mask) << position;
    return input;
}

inline uint64 roundDownTo4K(uint64 number) {
    return number & ~0xFFFULL; // Mask the lower 12 bits to round down to 4K
}

inline uint64 roundUpTo4K(uint64 number) {
    if (number % 4096ULL == 0ULL) {
        // Already a multiple of 4K
        return number;
    } else {
        // Round up to the next multiple of 4K
        return ((number / 4096ULL) + 1ULL) * 4096ULL;
    }
}

#define PCM_STRINGIFY(x) #x
#define PCM_TOSTRING(x) PCM_STRINGIFY(x)

inline std::string getInstallPathPrefix()
{
#if defined (CMAKE_INSTALL_PREFIX)
    const std::string prefix{ PCM_TOSTRING(CMAKE_INSTALL_PREFIX) };
#else
    const std::string prefix{ "/usr" };
#endif
    return prefix + "/share/pcm/";
}

std::pair<int64,int64> parseBitsParameter(const char * param);
template <class T, class R>
inline bool readOldValueHelper(const std::pair<int64,int64> & bits, T & value, const bool & write, R readValue)
{
    if (bits.first >= 0 && write)
    {
        // to write bits need to read the old value first
        T old_value = 0;
        if (!readValue(old_value))
        {
            return false;
        }
        value = insertBits(old_value, value, bits.first, bits.second - bits.first + 1);
    }
    return true;
}

template <class T>
inline void extractBitsPrintHelper(const std::pair<int64,int64> & bits, T & value, const bool & dec)
{
    std::cout << " Read ";
    if (bits.first >= 0)
    {
        std::cout << "bits "<< std::dec << bits.first << ":" << bits.second << " ";
        if (!dec) std::cout << std::hex << std::showbase;
        value = extract_bits(value, bits.first, bits.second);
    }
    std::cout << "value " << value;
}

#ifdef _MSC_VER
void restrictDriverAccessNative(LPCTSTR path);
#endif

#ifdef __linux__
std::vector<std::string> findPathsFromPattern(const char* pattern);
#endif

class TemporalThreadAffinity
{
    TemporalThreadAffinity(); // forbidden
#if defined(__FreeBSD__) || (defined(__DragonFly__) && __DragonFly_version >= 400707)
    cpu_set_t old_affinity;
    bool restore;

public:
    TemporalThreadAffinity(uint32 core_id, bool checkStatus = true, const bool restore_ = true)
        : restore(restore_)
    {
        assert(core_id < 1024);
        auto res = pthread_getaffinity_np(pthread_self(), sizeof(cpu_set_t), &old_affinity);
        if (res != 0)
        {
            std::cerr << "ERROR: pthread_getaffinity_np for core " << core_id << " failed with code " << res << "\n";
            throw std::exception();
        }
        cpu_set_t new_affinity;
        CPU_ZERO(&new_affinity);
        CPU_SET(core_id, &new_affinity);
        // CPU_CMP() returns true if old_affinity is NOT equal to new_affinity
        if (!(CPU_CMP(&old_affinity, &new_affinity)))
        {
            restore = false;
            return; // the same affinity => return
        }
        res = pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &new_affinity);
        if (res != 0 && checkStatus)
        {
            std::cerr << "ERROR: pthread_setaffinity_np for core " << core_id << " failed with code " << res << "\n";
            throw std::exception();
        }
    }
    ~TemporalThreadAffinity()
    {
        if (restore) pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &old_affinity);
    }
    bool supported() const { return true; }

#elif defined(__linux__)
    cpu_set_t* old_affinity = nullptr;
    static constexpr auto maxCPUs = 8192;
    const size_t set_size;
    bool restore;

public:
    TemporalThreadAffinity(const uint32 core_id, bool checkStatus = true, const bool restore_ = true)
        : set_size(CPU_ALLOC_SIZE(maxCPUs)), restore(restore_)
    {
        assert(core_id < maxCPUs);
        old_affinity = CPU_ALLOC(maxCPUs);
        assert(old_affinity);
        auto res = pthread_getaffinity_np(pthread_self(), set_size, old_affinity);
        if (res != 0)
        {
            std::cerr << "ERROR: pthread_getaffinity_np for core " << core_id << " failed with code " << res << "\n";
            CPU_FREE(old_affinity);
            old_affinity = nullptr;
            throw std::runtime_error("pthread_getaffinity_np failed");
        }
        cpu_set_t* new_affinity = CPU_ALLOC(maxCPUs);
        assert(new_affinity);
        CPU_ZERO_S(set_size, new_affinity);
        CPU_SET_S(core_id, set_size, new_affinity);
        if (CPU_EQUAL_S(set_size, old_affinity, new_affinity))
        {
            CPU_FREE(new_affinity);
            restore = false;
            return;
        }
        res = pthread_setaffinity_np(pthread_self(), set_size, new_affinity);
        CPU_FREE(new_affinity);
        if (res != 0 && checkStatus)
        {
            std::cerr << "ERROR: pthread_setaffinity_np for core " << core_id << " failed with code " << res << "\n";
            CPU_FREE(old_affinity);
            old_affinity = nullptr;
            throw std::runtime_error("pthread_setaffinity_np failed");
        }
    }
    ~TemporalThreadAffinity()
    {
        if (restore) pthread_setaffinity_np(pthread_self(), set_size, old_affinity);
        CPU_FREE(old_affinity);
        old_affinity = nullptr;
    }
    bool supported() const { return true; }
#elif defined(_MSC_VER)
    ThreadGroupTempAffinity affinity;
public:
    TemporalThreadAffinity(uint32 core, bool checkStatus = true, const bool restore = true)
        : affinity(core, checkStatus, restore)
    {
    }
    bool supported() const { return true; }
#else // not implemented for os x
public:
    TemporalThreadAffinity(uint32) { }
    TemporalThreadAffinity(uint32, bool) {}
    bool supported() const { return false; }
#endif
};


} // namespace pcm

```

`src/version.h`:

```h
#define PCM_VERSION "($Format:%ci ID=%h$)"

```

`src/width_extender.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
// written by Roman Dementiev
//            Austen Ott

#ifndef WIDTH_EXTENDER_HEADER_
#define WIDTH_EXTENDER_HEADER_

/*!     \file width_extender.h
        \brief Provides 64-bit "virtual" counters from underlying 32-bit HW counters
*/

#include <stdlib.h>
#include "cpucounters.h"
#include "utils.h"
#include "bw.h"
#include "mutex.h"
#include <memory>
#ifndef _MSC_VER
// the header can not be included into code using CLR
#include <thread>
#else
namespace std {
     class thread;
 }
#endif

namespace pcm {

class CounterWidthExtender
{
public:
    struct AbstractRawCounter
    {
        virtual uint64 operator () () = 0;
        virtual ~AbstractRawCounter() { }
    };

    struct MsrHandleCounter : public AbstractRawCounter
    {
        std::shared_ptr<SafeMsrHandle> msr;
        uint64 msr_addr;
        uint64 msr_mask;
        MsrHandleCounter(   std::shared_ptr<SafeMsrHandle> msr_,
                            const uint64 msr_addr_,
                            const uint64 msr_mask_ = ~uint64(0ULL)) :
            msr(msr_),
            msr_addr(msr_addr_),
            msr_mask(msr_mask_)
        {
        }
        uint64 operator () ()
        {
            uint64 value = 0;
            msr->read(msr_addr, &value);
            return value & msr_mask;
        }
    };

    template <uint64 (FreeRunningBWCounters::*F)()>
    struct ClientImcCounter : public AbstractRawCounter
    {
        std::shared_ptr<FreeRunningBWCounters> clientBW;
        ClientImcCounter(std::shared_ptr<FreeRunningBWCounters> clientBW_) : clientBW(clientBW_) { }
        uint64 operator () () { return (clientBW.get()->*F)(); }
    };

    typedef ClientImcCounter<&FreeRunningBWCounters::getImcReads> ClientImcReadsCounter;
    typedef ClientImcCounter<&FreeRunningBWCounters::getImcWrites> ClientImcWritesCounter;
    typedef ClientImcCounter<&FreeRunningBWCounters::getGtRequests> ClientGtRequestsCounter;
    typedef ClientImcCounter<&FreeRunningBWCounters::getIaRequests> ClientIaRequestsCounter;
    typedef ClientImcCounter<&FreeRunningBWCounters::getIoRequests> ClientIoRequestsCounter;

    struct MBLCounter : public AbstractRawCounter
    {
        std::shared_ptr<SafeMsrHandle> msr;
        MBLCounter(std::shared_ptr<SafeMsrHandle> msr_) : msr(msr_) { }
        uint64 operator () ()
        {
            msr->lock();
            uint64 event = 3; // L3 Local External Bandwidth
            uint64 msr_qm_evtsel = 0, value = 0;
            msr->read(IA32_QM_EVTSEL, &msr_qm_evtsel);
            //std::cout << "MBLCounter reading IA32_QM_EVTSEL 0x"<< std::hex << msr_qm_evtsel << std::dec << "\n";
            msr_qm_evtsel &= 0xfffffffffffffff0ULL;
            msr_qm_evtsel |= event & ((1ULL << 8) - 1ULL);
            //std::cout << "MBL event " << msr_qm_evtsel << "\n";
            //std::cout << "MBLCounter writing IA32_QM_EVTSEL 0x"<< std::hex << msr_qm_evtsel << std::dec << "\n";
            msr->write(IA32_QM_EVTSEL, msr_qm_evtsel);
            msr->read(IA32_QM_CTR, &value);
            //std::cout << "MBLCounter reading IA32_QM_CTR "<< std::dec << value << std::dec << "\n";
            msr->unlock();
            return value;
        }
    };

    struct MBTCounter : public AbstractRawCounter
    {
        std::shared_ptr<SafeMsrHandle> msr;
        MBTCounter(std::shared_ptr<SafeMsrHandle> msr_) : msr(msr_) { }
        uint64 operator () ()
        {
            msr->lock();
            uint64 event = 2; // L3 Total External Bandwidth
            uint64 msr_qm_evtsel = 0, value = 0;
            msr->read(IA32_QM_EVTSEL, &msr_qm_evtsel);
            //std::cout << "MBTCounter reading IA32_QM_EVTSEL 0x"<< std::hex << msr_qm_evtsel << std::dec << "\n";
            msr_qm_evtsel &= 0xfffffffffffffff0ULL;
            msr_qm_evtsel |= event & ((1ULL << 8) - 1ULL);
            //std::cout << "MBR event " << msr_qm_evtsel << "\n";
            //std::cout << "MBTCounter writing IA32_QM_EVTSEL 0x"<< std::hex << msr_qm_evtsel << std::dec << "\n";
            msr->write(IA32_QM_EVTSEL, msr_qm_evtsel);
            msr->read(IA32_QM_CTR, &value);
            //std::cout << "MBTCounter reading IA32_QM_CTR "<< std::dec << value << std::dec << "\n";
            msr->unlock();
            return value;
        }
    };

private:
    std::thread * UpdateThread;

    Mutex CounterMutex;

    AbstractRawCounter * raw_counter;
    uint64 extended_value;
    uint64 last_raw_value;
    uint64 counter_width;
    uint32 watchdog_delay_ms;

    CounterWidthExtender();                                           // forbidden
    CounterWidthExtender(CounterWidthExtender &);                     // forbidden
    CounterWidthExtender & operator = (const CounterWidthExtender &); // forbidden


    uint64 internal_read()
    {
        uint64 result = 0, new_raw_value = 0;
        CounterMutex.lock();

        new_raw_value = (*raw_counter)();
        if (new_raw_value < last_raw_value)
        {
            extended_value += ((1ULL << counter_width) - last_raw_value) + new_raw_value;
        }
        else
        {
            extended_value += (new_raw_value - last_raw_value);
        }

        last_raw_value = new_raw_value;

        result = extended_value;

        CounterMutex.unlock();
        return result;
    }

public:

    CounterWidthExtender(AbstractRawCounter * raw_counter_, uint64 counter_width_, uint32 watchdog_delay_ms_);
    virtual ~CounterWidthExtender();

    uint64 read() // read extended value
    {
        return internal_read();
    }
    void reset()
    {
        CounterMutex.lock();
        extended_value = last_raw_value = (*raw_counter)();
        CounterMutex.unlock();
    }
};

} // namespace pcm

#endif

```

`src/windows/AssemblyInfo.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
/*
** Written by Otto Bruggeman
*/


using namespace System;
using namespace System::Reflection;
using namespace System::Runtime::CompilerServices;
using namespace System::Runtime::InteropServices;
using namespace System::Security::Permissions;

//
// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitleAttribute("PCMService")];
[assembly:AssemblyDescriptionAttribute("")];
[assembly:AssemblyConfigurationAttribute("")];
[assembly:AssemblyCompanyAttribute("Intel Corp")];
[assembly:AssemblyProductAttribute("PCMService")];
[assembly:AssemblyCopyrightAttribute("Copyright (c) Intel Corp 2010-2022")];
[assembly:AssemblyTrademarkAttribute("")];
[assembly:AssemblyCultureAttribute("")];

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the value or you can default the Revision and Build Numbers
// by using the '*' as shown below:

[assembly:AssemblyVersionAttribute("1.0.*")];

[assembly:ComVisible(false)];

[assembly:CLSCompliantAttribute(true)];

```

`src/windows/PCM-Service.exe.config`:

```config
<configuration>
    <runtime>
        <NetFx40_LegacySecurityPolicy enabled="true"/>
    </runtime>
    <system.diagnostics>
        <performanceCounters filemappingsize="33554432" />
    </system.diagnostics>
</configuration>

```

`src/windows/PCMInstaller.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
/*
** Written by Otto Bruggeman
*/


#include "PCMInstaller.h"

```

`src/windows/PCMInstaller.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
/*
** Written by Otto Bruggeman
*/

#pragma once

using namespace System;
using namespace System::ComponentModel;
using namespace System::Collections;
using namespace System::Configuration::Install;


namespace PMUService {

	[RunInstaller(true)]

	/// <summary>
	/// Summary for ProjectInstaller
	/// </summary>
	public ref class ProjectInstaller : public System::Configuration::Install::Installer
	{
	public:
		ProjectInstaller(void)
		{
			InitializeComponent();
			//
			//TODO: Add the constructor code here
			//
		}

	protected:
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		~ProjectInstaller()
		{
			if (components)
			{
				delete components;
			}
		}
    private: System::ServiceProcess::ServiceProcessInstaller^  serviceProcessInstaller1;
    protected: 
    private: System::ServiceProcess::ServiceInstaller^  serviceInstaller1;

	private:
		/// <summary>
		/// Required designer variable.
		/// </summary>
		System::ComponentModel::Container ^components;

#pragma region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		void InitializeComponent(void)
		{
            this->serviceProcessInstaller1 = (gcnew System::ServiceProcess::ServiceProcessInstaller());
            this->serviceInstaller1 = (gcnew System::ServiceProcess::ServiceInstaller());
            // 
            // serviceProcessInstaller1
            // 
            this->serviceProcessInstaller1->Account = System::ServiceProcess::ServiceAccount::LocalSystem;
            this->serviceProcessInstaller1->Password = nullptr;
            this->serviceProcessInstaller1->Username = nullptr;
            // 
            // serviceInstaller1
            // 
            this->serviceInstaller1->Description = L"This service provides performance counters for perfmon to show hardware events ov" 
                L"er time such as Clockticks, Instruction Retired,  Cache Misses and Memory Bandwi" 
                L"dth.";
            this->serviceInstaller1->DisplayName = L"Intel(r) Performance Counter Monitor Service";
            this->serviceInstaller1->ServiceName = L"PCMService";
            this->serviceInstaller1->StartType = System::ServiceProcess::ServiceStartMode::Automatic;
            // 
            // PCMInstaller
            // 
            this->Installers->AddRange(gcnew cli::array< System::Configuration::Install::Installer^  >(2) {this->serviceProcessInstaller1, 
                this->serviceInstaller1});

        }
#pragma endregion
	};
}

```

`src/windows/PCMService.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
/*
** Written by Otto Bruggeman and Roman Dementiev
*/

// PCMService.cpp : main Windows Service project file.

#include "PCMService.h"

#include <stdio.h>
#include <tchar.h>
#include <string.h>

using namespace PCMServiceNS;
using namespace System::Text;
using namespace System::Security::Policy;
using namespace System::Reflection;

//To install/uninstall the service, type: "PCM-Service.exe [-Install/-Uninstall]"
int _tmain(int argc, _TCHAR* argv[])
{
	PCM_SET_DLL_DIR
	if (argc >= 2)
	{
		if (argv[1][0] == _T('/'))
		{
			argv[1][0] = _T('-');
		}

		if (_tcsicmp(argv[1], _T("-Install")) == 0)
		{
			array<String^>^ myargs = System::Environment::GetCommandLineArgs();
			array<String^>^ args = gcnew array<String^>(myargs->Length - 1);

			// Set args[0] with the full path to the assembly,
			Assembly^ assem = Assembly::GetExecutingAssembly();
			args[0] = assem->Location;

			Array::Copy(myargs, 2, args, 1, args->Length - 1);
			AppDomain^ dom = AppDomain::CreateDomain(L"execDom");
			Type^ type = System::Object::typeid;
			String^ path = type->Assembly->Location;
			StringBuilder^ sb = gcnew StringBuilder(path->Substring(0, path->LastIndexOf(L"\\")));
			sb->Append(L"\\InstallUtil.exe");
			dom->ExecuteAssembly(sb->ToString(), args);
		}
		else
		if (_tcsicmp(argv[1], _T("-Uninstall")) == 0)
		{
			array<String^>^ myargs = System::Environment::GetCommandLineArgs();
			array<String^>^ args = gcnew array<String^>(2);

			args[0] = L"-u";

			// Set args[0] with the full path to the assembly,
			Assembly^ assem = Assembly::GetExecutingAssembly();
			args[1] = assem->Location;

			AppDomain^ dom = AppDomain::CreateDomain(L"execDom");
			Type^ type = System::Object::typeid;
			String^ path = type->Assembly->Location;
			StringBuilder^ sb = gcnew StringBuilder(path->Substring(0, path->LastIndexOf(L"\\")));
			sb->Append(L"\\InstallUtil.exe");
			dom->ExecuteAssembly(sb->ToString(), args);
		}

	}
	else
	{
        ServiceBase::Run(gcnew PCMService);
	}
}

```

`src/windows/PCMService.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation
/*
** Written by Otto Bruggeman, Roman Dementiev
*/

#pragma once

#pragma unmanaged
#include "pcm-lib.h"
#include "windriver.h"
#include <stdexcept>

#ifndef UNICODE
#include <locale>
#include <codecvt>
#endif
#pragma managed

using namespace pcm;
using namespace System;
using namespace System::Collections;
using namespace System::ServiceProcess;
using namespace System::ComponentModel;
using namespace System::Diagnostics;
using namespace System::Threading;
using namespace System::Runtime::InteropServices;

namespace PCMServiceNS {
    ref struct Globals
    {
        static initonly String^ ServiceName = gcnew String(L"PCMService");
    };

    ref struct CollectionInformation {
        CollectionInformation()
        {
            core = true;
            socket = true;
            qpi = true;
        }

        CollectionInformation(const CollectionInformation^ &copyable)
        {
            core = copyable->core;
            socket = copyable->socket;
            qpi = copyable->qpi;
        }

        bool core;
        bool socket;
        bool qpi;
    };

    ref class MeasureThread
    {
    public:
        MeasureThread(System::Diagnostics::EventLog^ log, int sampleRate, CollectionInformation^ collectionInformation) : log_(log), sampleRate_(sampleRate), collectionInformation_(collectionInformation)
        {
            // Get a Monitor instance which sets up the PMU, it also figures out the number of cores and sockets which we need later on to create the performance counters
            m_ = PCM::getInstance();
            if ( !m_->good() )
            {
                log_->WriteEntry(Globals::ServiceName, "Monitor Instance could not be created.", EventLogEntryType::Error);
                m_->cleanup();
                String^ s = gcnew String(m_->getErrorMessage().c_str());
                throw gcnew Exception(s);
            }
            log_->WriteEntry(Globals::ServiceName, "PCM: Number of cores detected: " + UInt32(m_->getNumCores()).ToString());

            m_->program();

            log_->WriteEntry(Globals::ServiceName, "PMU Programmed.");

            CountersQpi = gcnew String(L"PCM " + gcnew System::String(m_->xPI()) + L" Counters");
            MetricQpiBand = gcnew String(gcnew System::String(m_->xPI()) + L" Link Bandwidth");

            // This here will only create the necessary registry entries, the actual counters are created later.
            // New unified category
            if (PerformanceCounterCategory::Exists(CountersCore))
            {
                PerformanceCounterCategory::Delete(CountersCore);
            }
            if (PerformanceCounterCategory::Exists(CountersSocket))
            {
                PerformanceCounterCategory::Delete(CountersSocket);
            }
            if (PerformanceCounterCategory::Exists(CountersQpi))
            {
                PerformanceCounterCategory::Delete(CountersQpi);
            }
            log_->WriteEntry(Globals::ServiceName, "Old categories deleted.");

            // First create the collection, then add counters to it so we add them all at once
            CounterCreationDataCollection^ counterCollection = gcnew CounterCreationDataCollection;

            // Here we add the counters one by one, need list of counters currently collected.
            // This is a stub: copy and paste when new counters are added to ipcustat "library".
            // CounterCreationData^ counter = gcnew CounterCreationData( "counter", "helptext for counter", PerformanceCounterType::NumberOfItems64 );
            // counterCollection->Add( counter );
            CounterCreationData^ counter;

            if (collectionInformation_->core)
            {
                counter = gcnew CounterCreationData(MetricCoreClocktick, "Displays the number of clockticks elapsed since previous measurement.", PerformanceCounterType::CounterDelta64);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreRetired, "Displays the number of instructions retired since previous measurement.", PerformanceCounterType::CounterDelta64);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreMissL2, "Displays the L2 Cache Misses caused by this core.", PerformanceCounterType::CounterDelta64);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreMissL3, "Displays the L3 Cache Misses caused by this core.", PerformanceCounterType::CounterDelta64);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreIpc, "Displays the instructions per clocktick executed for this core.", PerformanceCounterType::AverageCount64);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreBaseIpc, "Not visible", PerformanceCounterType::AverageBase);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreFreqRel, "Displays the current frequency of the core to its rated frequency in percent.", PerformanceCounterType::SampleFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreFreqNom, "Not visible", PerformanceCounterType::SampleBase);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreHeadroom, "Displays temperature reading in 1 degree Celsius relative to the TjMax temperature. 0 corresponds to the max temperature.", PerformanceCounterType::NumberOfItems64);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreResC0, "Displays the residency of core or socket in core C0-state in percent.", PerformanceCounterType::RawFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreResC0Base, "", PerformanceCounterType::RawBase);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreResC1, "Displays the residency of core or socket in core C1-state in percent.", PerformanceCounterType::RawFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreResC1Base, "", PerformanceCounterType::RawBase);
                counterCollection->Add(counter);
                counter = gcnew CounterCreationData(MetricCoreResC3, "Displays the residency of core or socket in core C3-state in percent.", PerformanceCounterType::RawFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreResC3Base, "", PerformanceCounterType::RawBase);
                counterCollection->Add(counter);
                counter = gcnew CounterCreationData(MetricCoreResC6, "Displays the residency of core or socket in core C6-state in percent.", PerformanceCounterType::RawFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreResC6Base, "", PerformanceCounterType::RawBase);
                counterCollection->Add(counter);
                counter = gcnew CounterCreationData(MetricCoreResC7, "Displays the residency of core or socket in core C7-state in percent.", PerformanceCounterType::RawFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricCoreResC7Base, "", PerformanceCounterType::RawBase);
                counterCollection->Add(counter);
                PerformanceCounterCategory::Create(CountersCore, "Intel(r) Performance Counter Monitor", PerformanceCounterCategoryType::MultiInstance, counterCollection);
            }

            if (collectionInformation_->socket)
            {
                counterCollection->Clear();
                counter = gcnew CounterCreationData(MetricSocketBandRead, "Displays the memory read bandwidth in bytes/s of this socket.", PerformanceCounterType::NumberOfItems64);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricSocketBandWrite, "Displays the memory write bandwidth in bytes/s of this socket.", PerformanceCounterType::NumberOfItems64);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricSocketEnergyPack, "Displays the energy in Joules consumed by this socket.", PerformanceCounterType::NumberOfItems64);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricSocketEnergyDram, "Displays the energy in Joules consumed by DRAM memory attached to the memory controller of this socket.", PerformanceCounterType::NumberOfItems64);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricSocketResC0, "Displays the residency of socket in package C0-state in percent.", PerformanceCounterType::RawFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricSocketResC0Base, "", PerformanceCounterType::RawBase);
                counterCollection->Add(counter);
                counter = gcnew CounterCreationData(MetricSocketResC2, "Displays the residency of socket in package C2-state in percent.", PerformanceCounterType::RawFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricSocketResC2Base, "", PerformanceCounterType::RawBase);
                counterCollection->Add(counter);
                counter = gcnew CounterCreationData(MetricSocketResC3, "Displays the residency of socket in package C3-state in percent.", PerformanceCounterType::RawFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricSocketResC3Base, "", PerformanceCounterType::RawBase);
                counterCollection->Add(counter);
                counter = gcnew CounterCreationData(MetricSocketResC6, "Displays the residency of socket in package C6-state in percent.", PerformanceCounterType::RawFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricSocketResC6Base, "", PerformanceCounterType::RawBase);
                counterCollection->Add(counter);
                counter = gcnew CounterCreationData(MetricSocketResC7, "Displays the residency of socket in package C7-state in percent.", PerformanceCounterType::RawFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricSocketResC7Base, "", PerformanceCounterType::RawBase);
                counterCollection->Add(counter);
                counter = gcnew CounterCreationData(MetricSocketResC8, "Displays the residency of socket in package C8-state in percent.", PerformanceCounterType::RawFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricSocketResC8Base, "", PerformanceCounterType::RawBase);
                counterCollection->Add(counter);
                counter = gcnew CounterCreationData(MetricSocketResC9, "Displays the residency of socket in package C9-state in percent.", PerformanceCounterType::RawFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricSocketResC9Base, "", PerformanceCounterType::RawBase);
                counterCollection->Add(counter);
                counter = gcnew CounterCreationData(MetricSocketResC10, "Displays the residency of socket in package C10-state in percent.", PerformanceCounterType::RawFraction);
                counterCollection->Add( counter );
                counter = gcnew CounterCreationData(MetricSocketResC10Base, "", PerformanceCounterType::RawBase);
                counterCollection->Add(counter);
                PerformanceCounterCategory::Create(CountersSocket, "Intel(r) Performance Counter Monitor", PerformanceCounterCategoryType::MultiInstance, counterCollection);
            }

            if (collectionInformation_->qpi)
            {
                counterCollection->Clear();
                counter = gcnew CounterCreationData(MetricQpiBand, L"Displays the incoming bandwidth in bytes/s of this " + gcnew System::String(m_->xPI()) + L" link", PerformanceCounterType::CounterDelta64);
                counterCollection->Add( counter );
                PerformanceCounterCategory::Create(CountersQpi, "Intel(r) Performance Counter Monitor", PerformanceCounterCategoryType::MultiInstance, counterCollection);
            }

            log_->WriteEntry(Globals::ServiceName, "New categories added.");

            // Registry entries created, now we need to create the programmatic counters. For some things you may want one instance for every core/thread/socket/qpilink so create in a loop.
            // PerformanceCounter^ pc1 = gcnew PerformanceCounter( "SomeCounterName", "nameOfCounterAsEnteredInTheRegistry", "instanceNameOfCounterAsANumber" );

            // Create #processors instances of the core specific performance counters
            String^ s; // Used for creating the instance name and the string to search for in the hashtable
            PerformanceCounter^ pc;
            for ( unsigned int i = 0; i < m_->getNumCores(); ++i )
            {
                s = UInt32(i).ToString(); // For core counters we use just the number of the core
                if (collectionInformation_->core)
                {
                    ticksHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreClocktick, s, false));
                    instRetHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreRetired, s, false));
                    l2CacheMissHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreMissL2, s, false));
                    l3CacheMissHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreMissL3, s, false));
                    ipcHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreIpc, s, false));
                    baseTicksForIpcHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreBaseIpc, s, false));
                    relFreqHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreFreqRel, s, false));
                    baseTicksForRelFreqHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreFreqNom, s, false));
                    thermalHeadroomHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreHeadroom, s, false));
                    CoreC0StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC0, s, false));
                    pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC0Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    CoreC1StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC1, s, false));
                    pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC1Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    CoreC3StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC3, s, false));
                    pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC3Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    CoreC6StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC6, s, false));
                    pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC6Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    CoreC7StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC7, s, false));
                    pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC7Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                }
            }

            // Create socket instances of the common core counters, names are Socket+number
            for ( unsigned int i=0; i<m_->getNumSockets(); ++i )
            {
                s = "Socket"+UInt32(i).ToString();
                if (collectionInformation_->core)
                {
                    ticksHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreClocktick, s, false));
                    instRetHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreRetired, s, false));
                    l2CacheMissHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreMissL2, s, false));
                    l3CacheMissHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreMissL3, s, false));
                    ipcHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreIpc, s, false));
                    baseTicksForIpcHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreBaseIpc, s, false));
                    relFreqHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreFreqRel, s, false));
                    baseTicksForRelFreqHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreFreqNom, s, false));
                    thermalHeadroomHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreHeadroom, s, false));
                    CoreC0StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC0, s, false));
                    pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC0Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    CoreC1StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC1, s, false));
                    pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC1Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    CoreC3StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC3, s, false));
                    pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC3Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    CoreC6StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC6, s, false));
                    pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC6Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    CoreC7StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC7, s, false));
                    pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC7Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                }

                if (collectionInformation_->socket)
                {
                    mrbHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketBandRead, s, false));
                    mwbHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketBandWrite, s, false));
                    packageEnergyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketEnergyPack, s, false));
                    DRAMEnergyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketEnergyDram, s, false));
                    PackageC0StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC0, s, false));
                    pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC0Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    PackageC2StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC2, s, false));
                    pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC2Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    PackageC3StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC3, s, false));
                    pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC3Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    PackageC6StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC6, s, false));
                    pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC6Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    PackageC7StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC7, s, false));
                    pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC7Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    PackageC8StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC8, s, false));
                    pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC8Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    PackageC9StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC9, s, false));
                    pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC9Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                    PackageC10StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC10, s, false));
                    pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC10Base, s, false);
                    pc->RawValue = 1000;
                    baseArrayList_.Add(pc);
                }

                if (collectionInformation_->qpi)
                {
                    qpiHash_.Add(s, gcnew PerformanceCounter(CountersQpi, MetricQpiBand, s, false)); // Socket aggregate
                    String^ t;
                    for ( unsigned int j=0; j<m_->getQPILinksPerSocket(); ++j )
                    {
                        t = s + "_Link" + UInt32(j).ToString();
                        qpiHash_.Add(t, gcnew PerformanceCounter(CountersQpi, MetricQpiBand, t, false));
                    }
                }
            }

            // Create #system instances of the system specific performance counters, just kidding, there is only one system so 1 instance
            s = "Total_";
            if (collectionInformation_->core)
            {
                ticksHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreClocktick, s, false));
                instRetHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreRetired, s, false));
                l2CacheMissHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreMissL2, s, false));
                l3CacheMissHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreMissL3, s, false));
                ipcHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreIpc, s, false));
                baseTicksForIpcHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreBaseIpc, s, false));
                relFreqHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreFreqRel, s, false));
                baseTicksForRelFreqHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreFreqNom, s, false));
                thermalHeadroomHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreHeadroom, s, false));
                CoreC0StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC0, s, false));
                pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC0Base, s, false);
                pc->RawValue = 1000;
                baseArrayList_.Add(pc);
                CoreC1StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC1, s, false));
                pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC1Base, s, false);
                pc->RawValue = 1000;
                baseArrayList_.Add(pc);
                CoreC3StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC3, s, false));
                pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC3Base, s, false);
                pc->RawValue = 1000;
                baseArrayList_.Add(pc);
                CoreC6StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC6, s, false));
                pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC6Base, s, false);
                pc->RawValue = 1000;
                baseArrayList_.Add(pc);
                CoreC7StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersCore, MetricCoreResC7, s, false));
                pc = gcnew PerformanceCounter(CountersCore, MetricCoreResC7Base, s, false);
                pc->RawValue = 1000;
                baseArrayList_.Add(pc);
            }

            if (collectionInformation_->socket)
            {
                mrbHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketBandRead, s, false));
                mwbHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketBandWrite, s, false));
                packageEnergyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketEnergyPack, s, false));
                DRAMEnergyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketEnergyDram, s, false));
                PackageC0StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC0, s, false));
                pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC0Base, s, false);
                pc->RawValue = 1000;
                baseArrayList_.Add(pc);
                PackageC2StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC2, s, false));
                pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC2Base, s, false);
                pc->RawValue = 1000;
                baseArrayList_.Add(pc);
                PackageC3StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC3, s, false));
                pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC3Base, s, false);
                pc->RawValue = 1000;
                baseArrayList_.Add(pc);
                PackageC6StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC6, s, false));
                pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC6Base, s, false);
                pc->RawValue = 1000;
                baseArrayList_.Add(pc);
                PackageC7StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC7, s, false));
                pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC7Base, s, false);
                pc->RawValue = 1000;
                baseArrayList_.Add(pc);
                PackageC8StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC8, s, false));
                pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC8Base, s, false);
                pc->RawValue = 1000;
                baseArrayList_.Add(pc);
                PackageC9StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC9, s, false));
                pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC9Base, s, false);
                pc->RawValue = 1000;
                baseArrayList_.Add(pc);
                PackageC10StateResidencyHash_.Add(s, gcnew PerformanceCounter(CountersSocket, MetricSocketResC10, s, false));
                pc = gcnew PerformanceCounter(CountersSocket, MetricSocketResC10Base, s, false);
                pc->RawValue = 1000;
                baseArrayList_.Add(pc);
            }

            if (collectionInformation_->qpi)
            {
                qpiHash_.Add(s, gcnew PerformanceCounter(CountersQpi, MetricQpiBand, s, false));
            }

            log_->WriteEntry(Globals::ServiceName, "All instances of the performance counter categories have been created.");
        }

        void doMeasurements( void )
        {
            // FIXME: Do we care about hot swappability of CPUs?
            const size_t numSockets  = m_->getNumSockets();
            const size_t numCores    = m_->getNumCores();
            const size_t numQpiLinks = (size_t) m_->getQPILinksPerSocket();

            SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

            // The structures
            SystemCounterState  oldSystemState;
            std::vector<SocketCounterState> oldSocketStates;
            std::vector<CoreCounterState>   oldCoreStates;
            SystemCounterState  systemState;
            std::vector<SocketCounterState> socketStates;
            std::vector<CoreCounterState>   coreStates;
            ULONGLONG BeforeTime = 0, AfterTime = 0;

            m_->getAllCounterStates(oldSystemState, oldSocketStates, oldCoreStates);
            BeforeTime = GetTickCount64();

 // labmda functions are not allowed in managed code, using a macro
#define  toBW(val) (val * 1000ULL / (AfterTime - BeforeTime))

            try {
                while (true)
                {
                    Thread::Sleep(sampleRate_);

                    // Fetch counter data here and store in the PerformanceCounter instances
                    m_->getAllCounterStates(systemState, socketStates, coreStates);
                    AfterTime = GetTickCount64();

                    // Set system performance counters
                    String^ s = "Total_";
                    if (collectionInformation_->core)
                    {
                        __int64 totalTicks    = getCycles(systemState);
                        __int64 totalRefTicks = m_->getNominalFrequency() * numCores;
                        __int64 totalInstr    = getInstructionsRetired(systemState);
                        ((PerformanceCounter^)ticksHash_[s])->RawValue = totalTicks;
                        ((PerformanceCounter^)instRetHash_[s])->RawValue = totalInstr;
                        ((PerformanceCounter^)l2CacheMissHash_[s])->IncrementBy(getL2CacheMisses(oldSystemState, systemState));
                        ((PerformanceCounter^)l3CacheMissHash_[s])->IncrementBy(getL3CacheMisses(oldSystemState, systemState));
                        ((PerformanceCounter^)ipcHash_[s])->RawValue = totalInstr >> 17;
                        ((PerformanceCounter^)baseTicksForIpcHash_[s])->RawValue = totalTicks >> 17;
                        ((PerformanceCounter^)relFreqHash_[s])->RawValue = totalTicks >> 17;
                        ((PerformanceCounter^)baseTicksForRelFreqHash_[s])->IncrementBy(totalRefTicks >> 17);
                        ((PerformanceCounter^)thermalHeadroomHash_[s])->RawValue = systemState.getThermalHeadroom();
                        ((PerformanceCounter^)CoreC0StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(0,oldSystemState, systemState));
                        ((PerformanceCounter^)CoreC1StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(1,oldSystemState, systemState));
                        ((PerformanceCounter^)CoreC3StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(3,oldSystemState, systemState));
                        ((PerformanceCounter^)CoreC6StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(6,oldSystemState, systemState));
                        ((PerformanceCounter^)CoreC7StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(7,oldSystemState, systemState));
                        //log_->WriteEntry(Globals::ServiceName, "Std: " + UInt64(totalTicks).ToString());
                        //log_->WriteEntry(Globals::ServiceName, "Ref: " + UInt64(totalRefTicks).ToString());
                    }

                    if (collectionInformation_->socket)
                    {
                        ((PerformanceCounter^)mrbHash_[s])->RawValue = toBW(getBytesReadFromMC(oldSystemState, systemState));
                        ((PerformanceCounter^)mwbHash_[s])->RawValue = toBW(getBytesWrittenToMC(oldSystemState, systemState));
                        ((PerformanceCounter^)packageEnergyHash_[s])->RawValue = (__int64)getConsumedJoules(oldSystemState, systemState);
                        ((PerformanceCounter^)DRAMEnergyHash_[s])->RawValue = (__int64)getDRAMConsumedJoules(oldSystemState, systemState);
                        ((PerformanceCounter^)PackageC0StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 0, oldSystemState, systemState));
                        ((PerformanceCounter^)PackageC2StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 2, oldSystemState, systemState));
                        ((PerformanceCounter^)PackageC3StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 3, oldSystemState, systemState));
                        ((PerformanceCounter^)PackageC6StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 6, oldSystemState, systemState));
                        ((PerformanceCounter^)PackageC7StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 7, oldSystemState, systemState));
                        ((PerformanceCounter^)PackageC8StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 8, oldSystemState, systemState));
                        ((PerformanceCounter^)PackageC9StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 9, oldSystemState, systemState));
                        ((PerformanceCounter^)PackageC10StateResidencyHash_[s])->RawValue = __int64(1000. * getPackageCStateResidency(10, oldSystemState, systemState));
                    }

                    if (collectionInformation_->qpi)
                    {
                        ((PerformanceCounter^)qpiHash_[s])->RawValue = getAllIncomingQPILinkBytes(systemState);
                    }

                    // Set socket performance counters
                    for ( unsigned int i = 0; i < numSockets; ++i )
                    {
                        s = "Socket"+UInt32(i).ToString();
                        const SocketCounterState & socketState = socketStates[i];
                        if (collectionInformation_->core)
                        {
                            __int64 socketTicks    = getCycles(socketState);
                            __int64 socketRefTicks = m_->getNominalFrequency()* numCores / numSockets;
                            __int64 socketInstr    = getInstructionsRetired(socketState);
                            ((PerformanceCounter^)instRetHash_[s])->RawValue = socketInstr;
                            ((PerformanceCounter^)ipcHash_[s])->RawValue = socketInstr >> 17;
                            ((PerformanceCounter^)l2CacheMissHash_[s])->IncrementBy(getL2CacheMisses(oldSocketStates[i], socketState));
                            ((PerformanceCounter^)l3CacheMissHash_[s])->IncrementBy(getL3CacheMisses(oldSocketStates[i], socketState));
                            ((PerformanceCounter^)ticksHash_[s])->RawValue = socketTicks;
                            ((PerformanceCounter^)baseTicksForIpcHash_[s])->RawValue = socketTicks >> 17;
                            ((PerformanceCounter^)relFreqHash_[s])->RawValue = socketTicks >> 17;
                            ((PerformanceCounter^)baseTicksForRelFreqHash_[s])->IncrementBy(socketRefTicks >> 17);
                            ((PerformanceCounter^)thermalHeadroomHash_[s])->RawValue = socketState.getThermalHeadroom();
                            ((PerformanceCounter^)CoreC0StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(0, oldSocketStates[i], socketState));
                            ((PerformanceCounter^)CoreC1StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(1, oldSocketStates[i], socketState));
                            ((PerformanceCounter^)CoreC3StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(3, oldSocketStates[i], socketState));
                            ((PerformanceCounter^)CoreC6StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(6, oldSocketStates[i], socketState));
                            ((PerformanceCounter^)CoreC7StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(7, oldSocketStates[i], socketState));
                        }

                        if (collectionInformation_->socket)
                        {
                            ((PerformanceCounter^)mrbHash_[s])->RawValue = toBW(getBytesReadFromMC(oldSocketStates[i], socketState));
                            ((PerformanceCounter^)mwbHash_[s])->RawValue = toBW(getBytesWrittenToMC(oldSocketStates[i], socketState));
                            ((PerformanceCounter^)packageEnergyHash_[s])->RawValue = (__int64)getConsumedJoules(oldSocketStates[i], socketState);
                            ((PerformanceCounter^)DRAMEnergyHash_[s])->RawValue = (__int64)getDRAMConsumedJoules(oldSocketStates[i], socketState);
                            ((PerformanceCounter^)PackageC0StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 0,oldSocketStates[i], socketState));
                            ((PerformanceCounter^)PackageC2StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 2,oldSocketStates[i], socketState));
                            ((PerformanceCounter^)PackageC3StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 3,oldSocketStates[i], socketState));
                            ((PerformanceCounter^)PackageC6StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 6,oldSocketStates[i], socketState));
                            ((PerformanceCounter^)PackageC7StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 7,oldSocketStates[i], socketState));
                            ((PerformanceCounter^)PackageC8StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 8,oldSocketStates[i], socketState));
                            ((PerformanceCounter^)PackageC9StateResidencyHash_[s])->RawValue  = __int64(1000. * getPackageCStateResidency( 9,oldSocketStates[i], socketState));
                            ((PerformanceCounter^)PackageC10StateResidencyHash_[s])->RawValue = __int64(1000. * getPackageCStateResidency(10,oldSocketStates[i], socketState));
                        }

                        if (collectionInformation_->qpi)
                        {
                            ((PerformanceCounter^)qpiHash_[s])->RawValue = toBW(getSocketIncomingQPILinkBytes(i, systemState));
                            String^ t;
                            // and qpi link counters per socket
                            for ( unsigned int j=0; j<numQpiLinks; ++j )
                            {
                                t = s + "_Link" + UInt32(j).ToString();
                                ((PerformanceCounter^)qpiHash_[t])->RawValue = toBW(getIncomingQPILinkBytes(i, j, systemState));
                            }
                        }
                    }

                    // Set core performance counters
                    for ( unsigned int i = 0; i < numCores; ++i )
                    {
                        s = UInt32(i).ToString();
                        const CoreCounterState & coreState = coreStates[i];
                        if (collectionInformation_->core)
                        {
                            __int64 ticks    = getCycles(coreState);
                            __int64 refTicks = m_->getNominalFrequency();
                            __int64 instr    = getInstructionsRetired(coreState);
                            ((PerformanceCounter^)instRetHash_[s])->RawValue = instr;
                            ((PerformanceCounter^)ipcHash_[s])->RawValue = instr >> 17;
                            ((PerformanceCounter^)l2CacheMissHash_[s])->IncrementBy(getL2CacheMisses(oldCoreStates[i], coreState));
                            ((PerformanceCounter^)l3CacheMissHash_[s])->IncrementBy(getL3CacheMisses(oldCoreStates[i], coreState));
                            ((PerformanceCounter^)ticksHash_[s])->RawValue = ticks;
                            ((PerformanceCounter^)baseTicksForIpcHash_[s])->RawValue = ticks >> 17;
                            ((PerformanceCounter^)relFreqHash_[s])->RawValue = ticks >> 17;
                            ((PerformanceCounter^)baseTicksForRelFreqHash_[s])->IncrementBy(refTicks >> 17);
                            ((PerformanceCounter^)thermalHeadroomHash_[s])->RawValue = coreState.getThermalHeadroom();
                            ((PerformanceCounter^)CoreC0StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(0,oldCoreStates[i], coreState));
                            ((PerformanceCounter^)CoreC1StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(1,oldCoreStates[i], coreState));
                            ((PerformanceCounter^)CoreC3StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(3,oldCoreStates[i], coreState));
                            ((PerformanceCounter^)CoreC6StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(6,oldCoreStates[i], coreState));
                            ((PerformanceCounter^)CoreC7StateResidencyHash_[s])->RawValue = __int64(1000. * getCoreCStateResidency(7,oldCoreStates[i], coreState));
                        }
                    }

                    std::swap(oldSystemState, systemState);
                    std::swap(oldSocketStates, socketStates);
                    std::swap(oldCoreStates, coreStates);
                    std::swap(BeforeTime, AfterTime);
                }
            }
            catch( ThreadAbortException^ )
            {
                // We get here when for instance the service gets stopped or something bad happens.
                // In order to do our cleanup, like unprogram the MSRs, close the driver and such, in case we get stopped we want to execute normally after this
                // so this resets the abort and allows a normal exit
                Thread::ResetAbort();
            }
            // Here we now have the chance to do cleanup after catching the ThreadAbortException because of the ResetAbort
            m_->cleanup();
        }

    private:
        // Core counter hashtables
        System::Collections::Hashtable ticksHash_;
        System::Collections::Hashtable instRetHash_;
        System::Collections::Hashtable ipcHash_;
        System::Collections::Hashtable baseTicksForIpcHash_;
        System::Collections::Hashtable relFreqHash_;
        System::Collections::Hashtable baseTicksForRelFreqHash_;
        System::Collections::Hashtable l3CacheMissHash_;
        System::Collections::Hashtable l2CacheMissHash_;
        // Socket counter hashtables
        System::Collections::Hashtable mrbHash_;
        System::Collections::Hashtable mwbHash_;
        // QPI counter hashtables
        System::Collections::Hashtable qpiHash_;
        // Energy counters
        System::Collections::Hashtable packageEnergyHash_;
        System::Collections::Hashtable DRAMEnergyHash_;
        // Thermal headroom
        System::Collections::Hashtable thermalHeadroomHash_;
        // C-state Residencies
        System::Collections::Hashtable CoreC0StateResidencyHash_;		
        System::Collections::Hashtable CoreC1StateResidencyHash_;
        System::Collections::Hashtable CoreC3StateResidencyHash_;
        System::Collections::Hashtable CoreC6StateResidencyHash_;
        System::Collections::Hashtable CoreC7StateResidencyHash_;
        System::Collections::Hashtable PackageC0StateResidencyHash_;
        System::Collections::Hashtable PackageC2StateResidencyHash_;
        System::Collections::Hashtable PackageC3StateResidencyHash_;
        System::Collections::Hashtable PackageC6StateResidencyHash_;
        System::Collections::Hashtable PackageC7StateResidencyHash_;
        System::Collections::Hashtable PackageC8StateResidencyHash_;
        System::Collections::Hashtable PackageC9StateResidencyHash_;
        System::Collections::Hashtable PackageC10StateResidencyHash_;
        System::Collections::ArrayList baseArrayList_;

        System::Diagnostics::EventLog^ log_;

        PCM* m_;

        // Counter variable names
        initonly String^ CountersCore = gcnew String(L"PCM Core Counters");
        initonly String^ CountersSocket = gcnew String(L"PCM Socket Counters");
        initonly String^ CountersQpi;

        initonly String^ MetricCoreClocktick = gcnew String(L"Clockticks");
        initonly String^ MetricCoreRetired = gcnew String(L"Instructions Retired");
        initonly String^ MetricCoreMissL2 = gcnew String(L"L2 Cache Misses");
        initonly String^ MetricCoreMissL3 = gcnew String(L"L3 Cache Misses");
        initonly String^ MetricCoreIpc = gcnew String(L"Instructions Per Clocktick (IPC)");
        initonly String^ MetricCoreBaseIpc = gcnew String(L"Base ticks IPC");
        initonly String^ MetricCoreFreqRel = gcnew String(L"Relative Frequency (%)");
        initonly String^ MetricCoreFreqNom = gcnew String(L"Nominal Frequency");
        initonly String^ MetricCoreHeadroom = gcnew String(L"Thermal Headroom below TjMax");
        initonly String^ MetricCoreResC0 = gcnew String(L"core C0-state residency (%)");
        initonly String^ MetricCoreResC1 = gcnew String(L"core C1-state residency (%)");
        initonly String^ MetricCoreResC3 = gcnew String(L"core C3-state residency (%)");
        initonly String^ MetricCoreResC6 = gcnew String(L"core C6-state residency (%)");
        initonly String^ MetricCoreResC7 = gcnew String(L"core C7-state residency (%)");
        initonly String^ MetricCoreResC0Base = gcnew String(L"core C0-state base");
        initonly String^ MetricCoreResC1Base = gcnew String(L"core C1-state base");
        initonly String^ MetricCoreResC3Base = gcnew String(L"core C3-state base");
        initonly String^ MetricCoreResC6Base = gcnew String(L"core C6-state base");
        initonly String^ MetricCoreResC7Base = gcnew String(L"core C7-state base");

        initonly String^ MetricSocketBandRead  = gcnew String(L"Memory Read Bandwidth");
        initonly String^ MetricSocketBandWrite = gcnew String(L"Memory Write Bandwidth");
        initonly String^ MetricSocketEnergyPack = gcnew String(L"Package/Socket Consumed Energy");
        initonly String^ MetricSocketEnergyDram = gcnew String(L"DRAM/Memory Consumed Energy");
        initonly String^ MetricSocketResC0  = gcnew String(L"package C0-state residency (%)");
        initonly String^ MetricSocketResC2  = gcnew String(L"package C2-state residency (%)");
        initonly String^ MetricSocketResC3  = gcnew String(L"package C3-state residency (%)");
        initonly String^ MetricSocketResC6  = gcnew String(L"package C6-state residency (%)");
        initonly String^ MetricSocketResC7  = gcnew String(L"package C7-state residency (%)");
        initonly String^ MetricSocketResC8  = gcnew String(L"package C8-state residency (%)");
        initonly String^ MetricSocketResC9  = gcnew String(L"package C9-state residency (%)");
        initonly String^ MetricSocketResC10 = gcnew String(L"package C10-state residency (%)");
        initonly String^ MetricSocketResC0Base  = gcnew String(L"package C0-state base");
        initonly String^ MetricSocketResC2Base  = gcnew String(L"package C2-state base");
        initonly String^ MetricSocketResC3Base  = gcnew String(L"package C3-state base");
        initonly String^ MetricSocketResC6Base  = gcnew String(L"package C6-state base");
        initonly String^ MetricSocketResC7Base  = gcnew String(L"package C7-state base");
        initonly String^ MetricSocketResC8Base  = gcnew String(L"package C8-state base");
        initonly String^ MetricSocketResC9Base  = gcnew String(L"package C9-state base");
        initonly String^ MetricSocketResC10Base = gcnew String(L"package C10-state base");

        initonly String^ MetricQpiBand;

        // Configuration values
        const int sampleRate_;
        const CollectionInformation^ collectionInformation_;
    };

    /// <summary>
    /// Summary for PMCService
    /// </summary>
    ///
    /// WARNING: If you change the name of this class, you will need to change the
    ///          'Resource File Name' property for the managed resource compiler tool
    ///          associated with all .resx files this class depends on.  Otherwise,
    ///          the designers will not be able to interact properly with localized
    ///          resources associated with this form.
    public ref class PCMService : public System::ServiceProcess::ServiceBase
    {
    [DllImport ("advapi32.dll")]
    static bool SetServiceStatus (IntPtr hServiceStatus, LPSERVICE_STATUS lpServiceStatus);

    private:
        void SetServiceFail (int ErrorCode) 
        { 
            SERVICE_STATUS ServiceStatus_;
            ServiceStatus_.dwCurrentState = (int)SERVICE_STOPPED;
            ServiceStatus_.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
            ServiceStatus_.dwWaitHint = 0;
            ServiceStatus_.dwWin32ExitCode = ErrorCode;
            ServiceStatus_.dwServiceSpecificExitCode = 0;
            ServiceStatus_.dwCheckPoint = 0;
            ServiceStatus_.dwControlsAccepted = 0 |
                (this->CanStop ? (int) SERVICE_ACCEPT_STOP : 0) |
                (this->CanShutdown ? (int) SERVICE_ACCEPT_SHUTDOWN : 0) |
                (this->CanPauseAndContinue ? (int) SERVICE_ACCEPT_PAUSE_CONTINUE : 0) |
                (this->CanHandleSessionChangeEvent ? (int) SERVICE_ACCEPT_SESSIONCHANGE : 0) |
                (this->CanHandlePowerEvent ? (int) SERVICE_ACCEPT_POWEREVENT : 0);
            SetServiceStatus (this->ServiceHandle, &ServiceStatus_);
        }


    public:
        PCMService()
        {
            InitializeComponent();
            //
            //TODO: Add the constructor code here
            //
        }
    protected:
        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        ~PCMService()
        {
            if (components)
            {
                delete components;
            }
        }

        /// <summary>
        /// Set things in motion so your service can do its work.
        /// </summary>
        virtual void OnStart(array<String^>^ args) override
        {
            PCM* m_ = PCM::getInstance();
            SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
            // Default values for configuration
            int sampleRate = 1000;
            CollectionInformation^ collectionInformation = gcnew CollectionInformation();

            // Read configuration values from registry
            HKEY hkey;
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\pcm\\service"), NULL, KEY_READ, &hkey))
            {
                DWORD regDWORD = static_cast<DWORD>(REG_DWORD);
                DWORD lenDWORD = 32;

                DWORD sampleRateRead(0);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("SampleRate"), NULL, NULL, reinterpret_cast<LPBYTE>(&sampleRateRead), &lenDWORD))
                {
                    sampleRate = (int)sampleRateRead;
                }

                DWORD collectCoreRead(0);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("CollectCore"), NULL, NULL, reinterpret_cast<LPBYTE>(&collectCoreRead), &lenDWORD)) {
                    collectionInformation->core = (int)collectCoreRead > 0;
                }

                DWORD collectSocketRead(0);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("CollectSocket"), NULL, NULL, reinterpret_cast<LPBYTE>(&collectSocketRead), &lenDWORD)) {
                    collectionInformation->socket = (int)collectSocketRead > 0;
                }

                DWORD collectQpiRead(0);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("CollectQpi"), NULL, NULL, reinterpret_cast<LPBYTE>(&collectQpiRead), &lenDWORD)) {
                    collectionInformation->qpi = (int)collectQpiRead > 0;
                }

                RegCloseKey(hkey);
            }

            this->RequestAdditionalTime(4000);
            // We should open the driver here
            EventLog->WriteEntry(Globals::ServiceName, "Trying to start the driver...", EventLogEntryType::Information);
            drv_ = new Driver;
            if (!drv_->start())
            {
#ifdef UNICODE
                const auto& driverPath = drv_->driverPath();
#else
                std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> char_to_wide;
                std::wstring driverPath = char_to_wide.from_bytes(drv_->driverPath().c_str());
#endif
                String^ s = gcnew String((L"Cannot open the driver.\nYou must have a signed driver at " + driverPath + L" and have administrator rights to run this program.\n\n").c_str());
                EventLog->WriteEntry(Globals::ServiceName, s, EventLogEntryType::Error);
                SetServiceFail(ERROR_FILE_NOT_FOUND);
                throw gcnew Exception(s);
            }

            // TODO: Add code here to start your service.
            MeasureThread^ mt;
            EventLog->WriteEntry(Globals::ServiceName, "Trying to create the measure thread...", EventLogEntryType::Information);
            try
            {
                mt = gcnew MeasureThread(EventLog, sampleRate, collectionInformation);
            }
            catch (Exception^ e)
            {
                EventLog->WriteEntry(Globals::ServiceName, "Could not create MeasureThread, aborting", EventLogEntryType::Error);
                EventLog->WriteEntry(Globals::ServiceName, e->Message, EventLogEntryType::Error);
                SetServiceFail(0x80886);
                throw e;
            }

            // Create thread, pretty obvious comment here
            workerThread_ = gcnew Thread( gcnew ThreadStart( mt, &MeasureThread::doMeasurements ) );
            // Start timer/thread to read out registers and fill performance counter structures
            workerThread_->Start();
//            EventLog->WriteEntry("PCMService", System::DateTime::Now.ToLongTimeString() + " Monitor could not initialize PMU, aborting.", EventLogEntryType::Error);

        }

        /// <summary>
        /// Stop this service.
        /// </summary>
        virtual void OnStop() override
        {
            // TODO: Add code here to perform any tear-down necessary to stop your service.
            this->RequestAdditionalTime(4000);
            // Stop timer/thread
            // doMeasurements will do cleanup itself, might have to do some sanity checks here
            workerThread_->Abort();
            drv_->stop();
        }

    private:
        /// <summary>
        /// Required designer variable.
        /// </summary>
        System::ComponentModel::Container ^components;
        System::Threading::Thread^ workerThread_;
        Driver* drv_;

#pragma region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        void InitializeComponent(void)
        {
            // 
            // PCMService
            // 
            this->CanPauseAndContinue = true;
            this->ServiceName = Globals::ServiceName;

        }
#pragma endregion
    };
}

```

`src/windows/PCM_cpp_ReadMe.txt`:

```txt
========================================================================
    CONSOLE APPLICATION : pcm Project Overview
========================================================================

AppWizard has created this pcm application for you.  

This file contains a summary of what you will find in each of the files that
make up your pcm application.


pcm.vcproj
    This is the main project file for VC++ projects generated using an Application Wizard. 
    It contains information about the version of Visual C++ that generated the file, and 
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

pcm.cpp
    This is the main application source file.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named pcm.pch and a precompiled types file named StdAfx.obj.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" comments to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////

```

`src/windows/ReadMe_PCMService.txt`:

```txt
========================================================================
    APPLICATION : PMU Service Project Overview
========================================================================

Windows Service Wizard has created this PMU Service Application for you.  

This file contains a summary of what you will find in each of the files that
make up your PMU Service application.

PMU Service.vcproj
    This is the main project file for VC++ projects generated using a Windows Service Wizard. 
    It contains information about the version of Visual C++ that generated the file, and 
    information about the platforms, configurations.

PMU ServiceWinService.cpp
    This is the main application source file.

AssemblyInfo.cpp
	Contains custom attributes for modifying assembly metadata.


/////////////////////////////////////////////////////////////////////////////
Other notes:

Windows Service Wizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////

To run your service:
	1. Build the project
	2. From the command line, run:
		PMU Service.exe -Install

```

`src/windows/dllmain.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation

/* 
** Written by Otto Bruggeman
*/

// dllmain.cpp : Defines the entry point for the DLL application.

#include <windows.h>

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}


```

`src/windows/pcm-core-win.cpp`:

```cpp
// pcm-core-win.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "../pcm-core.cpp"

```

`src/windows/pcm-iio-win.cpp`:

```cpp
// pcm-iio-win.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "../pcm-iio.cpp"

```

`src/windows/pcm-latency-win.cpp`:

```cpp
// pcm-latency-win.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "../pcm-latency.cpp"

```

`src/windows/pcm-lib.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation

/* 
** Written by Otto Bruggeman
*/

// pcm-lib.cpp : Defines the exported functions for the DLL application.
//


#include "pcm-lib.h"



```

`src/windows/pcm-lib.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation

/*
** Written by Otto Bruggeman
*/

// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the PCM_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// PCM_API functions as being imported from a DLL, whereas this DLL sees symbols
// defined with this macro as being exported.
#ifdef PCM_EXPORTS
#define PCM_API __declspec(dllexport)
#else
#define PCM_API __declspec(dllimport)
#endif

#include "..\cpucounters.h"

```

`src/windows/pcm-memory-win.cpp`:

```cpp
// pcm-memory-win.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "../pcm-memory.cpp"

```

`src/windows/pcm-mmio-win.cpp`:

```cpp
// pcm-mmio-win.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "../pcm-mmio.cpp"

```

`src/windows/pcm-msr-win.cpp`:

```cpp
// pcm-msr-win.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "../pcm-msr.cpp"

```

`src/windows/pcm-numa-win.cpp`:

```cpp
// pcm-numa-win.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "../pcm-numa.cpp"

```

`src/windows/pcm-pcicfg-win.cpp`:

```cpp
// pcm-pcicfg-win.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "../pcm-pcicfg.cpp"

```

`src/windows/pcm-pcie-win.cpp`:

```cpp
// pcm-pcie-win.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "../pcm-pcie.cpp"

```

`src/windows/pcm-power-win.cpp`:

```cpp
// pcm-power-win.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "../pcm-power.cpp"

```

`src/windows/pcm-raw-win.cpp`:

```cpp
// pcm-raw-win.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "../pcm-raw.cpp"

```

`src/windows/pcm-tsx-win.cpp`:

```cpp
// pcm-tsx-win.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "../pcm-tsx.cpp"

```

`src/windows/pcm.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation

// pcm.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "../pcm.cpp"

```

`src/windows/pcm_lib_ReadMe.txt`:

```txt
========================================================================
    DYNAMIC LINK LIBRARY : PMU Library Project Overview
========================================================================

AppWizard has created this PMU Library DLL for you.

This file contains a summary of what you will find in each of the files that
make up your PMU Library application.


PMU Library.vcproj
    This is the main project file for VC++ projects generated using an Application Wizard.
    It contains information about the version of Visual C++ that generated the file, and
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

PMU Library.cpp
    This is the main DLL source file.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named PMU Library.pch and a precompiled types file named StdAfx.obj.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" comments to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////

```

`src/windows/pcm_power_ReadMe.txt`:

```txt
========================================================================
    CONSOLE APPLICATION : pcm Project Overview
========================================================================

AppWizard has created this pcm application for you.  

This file contains a summary of what you will find in each of the files that
make up your pcm application.


pcm.vcproj
    This is the main project file for VC++ projects generated using an Application Wizard. 
    It contains information about the version of Visual C++ that generated the file, and 
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

pcm.cpp
    This is the main application source file.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named pcm.pch and a precompiled types file named StdAfx.obj.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" comments to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////

```

`src/windows/stdafx.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation

// stdafx.cpp : source file that includes just the standard includes
// pcm.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`src/windows/stdafx.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation

// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#ifndef _WIN32_WINNT            // Allow use of features specific to Windows XP or later.
#define _WIN32_WINNT 0x0501     // Change this to the appropriate value to target other versions of Windows.
#endif

#include <stdio.h>
#include <tchar.h>


// TODO: reference additional headers your program requires here

```

`src/windows/windriver.h`:

```h
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation

#ifndef WINDRIVER_HEADER
#define WINDRIVER_HEADER

// contact: Roman Dementiev
// WARNING: This driver code is only for testing purposes, not for production use
//

#include <iostream>
#include <winreg.h>
#include <comdef.h>
#include "../cpucounters.h"

namespace pcm {

/*!     \file windriver.h
        \brief Loading and unloading custom Windows MSR (Model Specific Register) Driver
*/

extern void restrictDriverAccess(LPCTSTR path);

/*! \brief Manage custom Windows MSR (Model Specific Register) Driver
    The driver is required to access hardware Model Specific Registers (MSRs)
    under Windows. Currently only 64-bit Windows 7 has been tested.
*/

class Driver
{
    SC_HANDLE hSCManager{};
    SC_HANDLE hService{};
    SERVICE_STATUS ss{};

public:
    static tstring msrLocalPath()
    {
        tstring driverPath;
        DWORD driverPathLen = 1;
        DWORD gcdReturn = 0;

        do {
            if (0 != gcdReturn)
            {
                driverPathLen = gcdReturn;
            }
            driverPath.resize(driverPathLen);
            gcdReturn = GetCurrentDirectory(driverPathLen, &driverPath[0]);
        } while (0 != gcdReturn && driverPathLen < gcdReturn);

        removeNullTerminator(driverPath);

        return driverPath + TEXT("\\msr.sys");
    }

    Driver() :
        Driver(TEXT("c:\\windows\\system32\\msr.sys"))
    {
    }

    Driver(const tstring& driverPath) :
        Driver(driverPath, TEXT("PCM MSR"), TEXT("PCM MSR Driver"))
    {
    }

    Driver(const tstring& driverPath, const tstring& driverName, const tstring& driverDescription) :
        driverPath_(setConfigValue(TEXT("DriverPath"), driverPath)),
        driverName_(setConfigValue(TEXT("DriverName"), driverName)),
        driverDescription_(setConfigValue(TEXT("DriverDescription"), driverDescription))
    {
    }

    const tstring& driverPath() const
    {
        return driverPath_;
    }


    /*! \brief Installs and loads the driver

        Installs the driver if not installed and then loads it.

        \param driverPath full path to the driver
        \return true iff driver start up was successful
    */
    bool start()
    {
        hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
        if (hSCManager)
        {
            hService = CreateService(hSCManager, &driverName_[0], &driverDescription_[0], SERVICE_START | DELETE | SERVICE_STOP,
                                     SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, &driverPath_[0], NULL, NULL, NULL, NULL, NULL);

            if (!hService)
            {
                hService = OpenService(hSCManager, &driverName_[0], SERVICE_START | DELETE | SERVICE_STOP);
            }

            if (hService)
            {
                if (0 != StartService(hService, 0, NULL))
                {
                    restrictDriverAccess(PCM_MSR_DRV_NAME);
                    return true;
                }
                DWORD err = GetLastError();
                if (err == ERROR_SERVICE_ALREADY_RUNNING) return true;

                std::wcerr << "Starting MSR service failed with error " << err << " ";
                const _com_error comError{ (int)err };
                const TCHAR * errorStr = comError.ErrorMessage();
                if (errorStr)
                    std::wcerr << errorStr << "\n";

                ControlService(hService, SERVICE_CONTROL_STOP, &ss);

                // DeleteService(hService);

                CloseServiceHandle(hService);
            }
            else
            {
                std::wcerr << "Opening service manager failed with error " << GetLastError() << " ";
                const _com_error comError{ (int)GetLastError() };
                const TCHAR * errorStr = comError.ErrorMessage();
                if (errorStr)
                    std::wcerr << errorStr << "\n";
            }

            CloseServiceHandle(hSCManager);
        }
        else
        {
            std::wcerr << "Opening service manager failed with error " << GetLastError() << " ";
            const _com_error comError{ (int)GetLastError() };
            const TCHAR * errorStr = comError.ErrorMessage();
            if (errorStr)
                std::wcerr << errorStr << "\n";
        }

        #ifndef NO_WINRING // In cases where loading the WinRing0 driver is not desirable as a fallback to MSR.sys, add -DNO_WINRING to compile command to remove ability to load driver (will also remove initWinRing0Lib function)
        std::cerr << "Trying to load winring0.dll/winring0.sys driver...\n";
        if(PCM::initWinRing0Lib())
        {
            std::cerr << "Using winring0.dll/winring0.sys driver.\n\n";
            return true;
        }
        else
        {
            std::cerr << "Failed to load winring0.dll/winring0.sys driver.\n\n";
        }
        #endif // NO_WINRING

        return false;
    }

    //! \brief Stop and unload the driver
    void stop()
    {
        hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
        if (hSCManager)
        {
            hService = OpenService(hSCManager, &driverName_[0], SERVICE_START | DELETE | SERVICE_STOP);
            if (hService)
            {
                ControlService(hService, SERVICE_CONTROL_STOP, &ss);
                CloseServiceHandle(hService);
            }

            CloseServiceHandle(hSCManager);
        }
        else
        {
            std::wcerr << "Opening service manager failed with error " << GetLastError() << " ";
            const _com_error comError{ (int)GetLastError() };
            const TCHAR * errorStr = comError.ErrorMessage();
            if (errorStr)
                std::wcerr << errorStr;
        }
    }

    /*! \brief Uninstall the driver

         Uninstalls the driver. For successeful uninstallation you need to reboot the system after calling this method.
    */
    void uninstall()
    {
        hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
        if (hSCManager)
        {
            hService = OpenService(hSCManager, &driverName_[0], SERVICE_START | DELETE | SERVICE_STOP);
            if (hService)
            {
                ControlService(hService, SERVICE_CONTROL_STOP, &ss);
                DeleteService(hService);
                CloseServiceHandle(hService);
            }

            CloseServiceHandle(hSCManager);
        }
        else
        {
            std::wcerr << "Opening service manager failed with error " << GetLastError() << " ";
            const _com_error comError{ (int)GetLastError() };
            const TCHAR * errorStr = comError.ErrorMessage();
            if (errorStr)
                std::wcerr << errorStr;
        }
    }

private:

    static tstring setConfigValue(LPCTSTR key, const tstring& defaultValue)
    {
        tstring regRead;
        DWORD regLen = 1 * sizeof(TCHAR);
        DWORD regRes = ERROR_FILE_NOT_FOUND; // Safe error to start with in case key doesn't exist

        HKEY hKey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\pcm"), NULL, KEY_READ, &hKey))
        {
            do {
                regRead.resize(regLen / sizeof(TCHAR));
                regRes = RegQueryValueEx(hKey, key, NULL, NULL, (LPBYTE)&regRead[0], &regLen);
            } while (ERROR_MORE_DATA == regRes);

            RegCloseKey(hKey);
        }

        removeNullTerminator(regRead);
            
        return ERROR_SUCCESS == regRes ? regRead : defaultValue;
    }

    static void removeNullTerminator(tstring& s)
    {
        if (!s.empty() && s.back() == '\0')
        {
            s.pop_back();
        }
    }

    const tstring driverName_;
    const tstring driverPath_;
    const tstring driverDescription_;
};

} // namespace pcm

#endif

```

`src/winpmem/LICENSE.txt`:

```txt

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2012 Michael Cohen <scudette@gmail.com>

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
```

`src/winpmem/winpmem.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2022, Intel Corporation

/*
  Copyright 2012 Michael Cohen <scudette@gmail.com>

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

/********************************************************************
   This is a single binary memory imager for Windows.

   Supported systems:
    - Windows XPSP2 to Windows 8 inclusive, both 32 bit and 64 bit.

*********************************************************************/

#include "winpmem.h"

#ifdef PCM_EXPORTS
#define PCM_API __declspec(dllexport)
#else
#define PCM_API 
#endif

namespace pcm {

extern PCM_API void restrictDriverAccess(LPCTSTR path);

int WinPmem::set_acquisition_mode(__int32 mode) {
  DWORD size;
  // Set the acquisition mode.
  if(!DeviceIoControl(fd_, PMEM_CTRL_IOCTRL, &mode, 4, NULL, 0,
                      &size, NULL)) {
    LogError(TEXT("Failed to set acquisition mode.\n"));
    return -1;
  };

  return 1;
};

int WinPmem::toggle_write_mode() {
    DWORD size;
    // Set the acquisition mode.
    if (!DeviceIoControl(fd_, PMEM_WRITE_ENABLE, NULL, 0, NULL, 0,
        &size, NULL)) {
        LogError(TEXT("INFO: winpmem driver does not support write mode.\n"));
        return -1;
    };

    return 1;
};

WinPmem::WinPmem():
  suppress_output(FALSE),
  fd_(INVALID_HANDLE_VALUE),
  out_fd_(INVALID_HANDLE_VALUE) {
  _tcscpy_s(service_name, PMEM_SERVICE_NAME);
  _tcscpy_s(last_error, TEXT(""));
  max_physical_memory_ = 0;
  }

WinPmem::~WinPmem() {
  if (fd_ != INVALID_HANDLE_VALUE) {
    CloseHandle(fd_);
  }
}

void WinPmem::LogError(const TCHAR *message) {
  _tcsncpy_s(last_error, message, sizeof(last_error));
  if (suppress_output) return;

  _tprintf(TEXT("%s"), message);
};

void WinPmem::Log(const TCHAR *message, ...) {
  if (suppress_output) return;

  va_list ap;
  va_start(ap, message);
  _vtprintf(message, ap);
  va_end(ap);
};

// Roman Dementiev (Intel): added delete_driver option (default is true)
int WinPmem::install_driver(bool delete_driver) {
  SC_HANDLE scm, service;
  int status = -1;

  // Try to load the driver from the resource section.
  if (load_driver_() < 0)
    goto error;

  uninstall_driver();

  scm = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
  if (!scm) {
    LogError(TEXT("Can not open SCM. Are you administrator?"));
    goto error;
  }

  service = CreateService(scm,
                          service_name,
                          service_name,
                          SERVICE_ALL_ACCESS,
                          SERVICE_KERNEL_DRIVER,
                          SERVICE_DEMAND_START,
                          SERVICE_ERROR_NORMAL,
                          driver_filename,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL);

  if (GetLastError() == ERROR_SERVICE_EXISTS) {
    CloseServiceHandle(service);
    service = OpenService(scm, service_name, SERVICE_ALL_ACCESS);
  }

  if (!service) {
    CloseServiceHandle(scm);
    goto error;
  };
  if (!StartService(service, 0, NULL)) {
    if (GetLastError() != ERROR_SERVICE_ALREADY_RUNNING) {
      LogError(TEXT("Error: StartService(), Cannot start the driver.\n"));
      goto service_error;
    }
  }

  Log(TEXT("Loaded Driver %s.\n"), driver_filename);

  fd_ = CreateFile(TEXT("\\\\.\\") TEXT(PMEM_DEVICE_NAME),
                   // Write is needed for IOCTL.
                   GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL);

  if(fd_ == INVALID_HANDLE_VALUE) {
    LogError(TEXT("Can not open raw device."));
    status = -1;
  }
  else
    status = 1;

 service_error:
  CloseServiceHandle(service);
  CloseServiceHandle(scm);

  if(status == 1) restrictDriverAccess(TEXT("\\\\.\\") TEXT(PMEM_DEVICE_NAME));
  if(delete_driver) DeleteFile(driver_filename);

 error:
  return status;
}

int WinPmem::uninstall_driver() {
  SC_HANDLE scm, service;
  SERVICE_STATUS ServiceStatus;

  scm = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);

  if (!scm) return 0;

  service = OpenService(scm, service_name, SERVICE_ALL_ACCESS);

  if (service) {
    ControlService(service, SERVICE_CONTROL_STOP, &ServiceStatus);
  };

  DeleteService(service);
  CloseServiceHandle(service);
  Log(TEXT("Driver Unloaded.\n"));

  CloseServiceHandle(scm);

  return 1;
}

} // namespace pcm

```

`src/winpmem/winpmem.h`:

```h
#include "windows.h"
#include "stdio.h"
#include "tchar.h"

namespace pcm {

// Executable version.
static TCHAR version[] = TEXT("1.3. Built ") TEXT(__DATE__);
#define PMEM_DEVICE_NAME "pmem"
#define PMEM_SERVICE_NAME TEXT("winpmem")

#define PAGE_SIZE 0x1000

class WinPmem {
  WinPmem(const WinPmem&) = delete;
  WinPmem& operator = (const WinPmem&) = delete;
 public:
  WinPmem();
  virtual ~WinPmem();

  virtual int install_driver(bool delete_driver = true);
  virtual int uninstall_driver();
  virtual int set_acquisition_mode(__int32 mode);
  virtual int toggle_write_mode();

  template <class T>
  void read(__int64 start, T & result)
  {
      LARGE_INTEGER large_start;

      DWORD bytes_read = 0;
      large_start.QuadPart = start;

      if (0xFFFFFFFF == SetFilePointer(fd_, (LONG)large_start.LowPart,
          &large_start.HighPart, FILE_BEGIN))
      {
          LogError(TEXT("Failed to seek in the pmem device.\n"));
          return;
      }

      if (!ReadFile(fd_, &result, (DWORD)sizeof(T), &bytes_read, NULL))
      {
          LogError(TEXT("Failed to read memory."));
      }
  }

  template <class T>
  void write(__int64 start, T val)
  {
      LARGE_INTEGER large_start;

      DWORD bytes_written = 0;
      large_start.QuadPart = start;

      if (0xFFFFFFFF == SetFilePointer(fd_, (LONG)large_start.LowPart,
          &large_start.HighPart, FILE_BEGIN))
      {
          LogError(TEXT("Failed to seek in the pmem device.\n"));
          return;
      }

      if (!WriteFile(fd_, &val, (DWORD)sizeof(T), &bytes_written, NULL))
      {
          LogError(TEXT("Failed to write memory."));
      }
  }

  // This is set if output should be suppressed (e.g. if we pipe the
  // image to the STDOUT).
  int suppress_output;
  TCHAR last_error[1024];

 protected:
  virtual int load_driver_() = 0;

  virtual void LogError(const TCHAR *message);
  virtual void Log(const TCHAR *message, ...);

  // The file handle to the pmem device.
  HANDLE fd_;

  // The file handle to the image file.
  HANDLE out_fd_;
  
  // 256: The maximum length of Windows service name string.
  TCHAR service_name[256];
  TCHAR driver_filename[MAX_PATH];

  // This is the maximum size of memory calculated.
  __int64 max_physical_memory_;
};

// This is the filename of the driver we drop.
static TCHAR driver_filename[MAX_PATH];

// ioctl to get memory ranges from our driver.
#define PMEM_CTRL_IOCTRL CTL_CODE(0x22, 0x101, 3, 3)
#define PMEM_WRITE_ENABLE CTL_CODE(0x22, 0x102, 3, 3)
#define PMEM_INFO_IOCTRL CTL_CODE(0x22, 0x103, 3, 3)

// Available modes
#define PMEM_MODE_IOSPACE 0
#define PMEM_MODE_PHYSICAL 1

} // namespace pcm
```

`src/winring0/COPYRIGHT.txt`:

```txt
Copyright (c) 2007-2009 OpenLibSys.org. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`src/winring0/OlsApi.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2009 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------
// for WinRing0 1.3.x

#pragma once

/******************************************************************************
**
** DLL Information
**
******************************************************************************/

//-----------------------------------------------------------------------------
// GetDllStatus
//-----------------------------------------------------------------------------
DWORD // DLL Status, defined OLS_DLL_****
WINAPI GetDllStatus();

//-----------------------------------------------------------------------------
// GetDllVersion
//-----------------------------------------------------------------------------
DWORD // DLL Version, defined OLS_VERSION
WINAPI GetDllVersion(
	PBYTE major,		// major version
	PBYTE minor,		// minor version
	PBYTE revision,		// revision
	PBYTE release		// release/build
);

//-----------------------------------------------------------------------------
// GetDriverVersion
//-----------------------------------------------------------------------------
DWORD // Device Driver Version, defined OLS_DRIVER_VERSION
WINAPI GetDriverVersion(
	PBYTE major,		// major version
	PBYTE minor,		// minor version
	PBYTE revision,		// revision
	PBYTE release		// release/build
);

//-----------------------------------------------------------------------------
// GetDriverType
//-----------------------------------------------------------------------------
DWORD // Device Driver Type, defined OLS_DRIVER_TYPE_****
WINAPI GetDriverType();

//-----------------------------------------------------------------------------
// InitializeOls
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI InitializeOls();

//-----------------------------------------------------------------------------
// DeinitializeOls
//-----------------------------------------------------------------------------
VOID WINAPI DeinitializeOls();

/******************************************************************************
**
** CPU
**
******************************************************************************/

//-----------------------------------------------------------------------------
// IsCpuid
//-----------------------------------------------------------------------------
BOOL // TRUE: support CPUID instruction, FALSE: not support CPUID instruction
WINAPI IsCpuid();

//-----------------------------------------------------------------------------
// IsMsr
//-----------------------------------------------------------------------------
BOOL // TRUE: support MSR(Model-Specific Register), FALSE: not support MSR
WINAPI IsMsr();

//-----------------------------------------------------------------------------
// IsTsc
//-----------------------------------------------------------------------------
BOOL // TRUE: support TSC(Time Stamp Counter), FALSE: not support TSC
WINAPI IsTsc();

//-----------------------------------------------------------------------------
// Rdmsr
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Rdmsr(
	DWORD index,					// MSR index
	PDWORD eax,						// bit  0-31
	PDWORD edx						// bit 32-63
);

//-----------------------------------------------------------------------------
// RdmsrTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdmsrTx(
	DWORD index,					// MSR index
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// RdmsrPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdmsrPx(
	DWORD index,					// MSR index
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Wrmsr
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Wrmsr(
	DWORD index,					// MSR index
	DWORD eax,						// bit  0-31
	DWORD edx						// bit 32-63
);

//-----------------------------------------------------------------------------
// WrmsrTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WrmsrTx(
	DWORD index,					// MSR index
	DWORD eax,						// bit  0-31
	DWORD edx,						// bit 32-63
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// WrmsrPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WrmsrPx(
	DWORD index,					// MSR index
	DWORD eax,						// bit  0-31
	DWORD edx,						// bit 32-63
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Rdpmc
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Rdpmc(
	DWORD index,					// PMC index
	PDWORD eax,						// bit  0-31
	PDWORD edx						// bit 32-63
);

//-----------------------------------------------------------------------------
// RdmsrTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdpmcTx(
	DWORD index,					// PMC index
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// RdmsrPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdpmcPx(
	DWORD index,					// PMC index
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Cpuid
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Cpuid(
	DWORD index,					// CPUID index
	PDWORD eax,
	PDWORD ebx,
	PDWORD ecx,
	PDWORD edx
);

//-----------------------------------------------------------------------------
// CpuidTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI CpuidTx(
	DWORD index,					// CPUID index
	PDWORD eax,
	PDWORD ebx,
	PDWORD ecx,
	PDWORD edx,
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// CpuidPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI CpuidPx(
	DWORD index,					// CPUID index
	PDWORD eax,
	PDWORD ebx,
	PDWORD ecx,
	PDWORD edx,
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Rdtsc
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Rdtsc(
	PDWORD eax,						// bit  0-31
	PDWORD edx						// bit 32-63
);

//-----------------------------------------------------------------------------
// RdmsrTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdtscTx(
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// RdmsrPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdtscPx(
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Hlt
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Hlt();

//-----------------------------------------------------------------------------
// HltTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI HltTx(
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// HltPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI HltPx(
	DWORD_PTR processAffinityMask
);

/******************************************************************************
**
** I/O
**
******************************************************************************/

//-----------------------------------------------------------------------------
// ReadIoPortByte
//-----------------------------------------------------------------------------
BYTE // Read Value
WINAPI ReadIoPortByte(
	WORD port			// I/O port address
);

//-----------------------------------------------------------------------------
// ReadIoPortWord
//-----------------------------------------------------------------------------
WORD // Read Value
WINAPI ReadIoPortWord(
	WORD port			// I/O port address
);

//-----------------------------------------------------------------------------
// ReadIoPortDword
//-----------------------------------------------------------------------------
DWORD // Read Value
WINAPI ReadIoPortDword(
	WORD port			// I/O port address
);

//-----------------------------------------------------------------------------
// ReadIoPortByteEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadIoPortByteEx(
	WORD port,			// I/O port address
	PBYTE value			// Read Value
);
//-----------------------------------------------------------------------------
// ReadIoPortWordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadIoPortWordEx(
	WORD port,			// I/O port address
	PWORD value			// Read Value
);
//-----------------------------------------------------------------------------
// ReadIoPortDwordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadIoPortDwordEx(
	WORD port,			// I/O port address
	PDWORD value		// Read Value
);

//-----------------------------------------------------------------------------
// WriteIoPortByte
//-----------------------------------------------------------------------------
VOID
WINAPI WriteIoPortByte(
	WORD port,			// I/O port address
	BYTE value			// Write Value
);

//-----------------------------------------------------------------------------
// WriteIoPortDword
//-----------------------------------------------------------------------------
VOID
WINAPI WriteIoPortDword(
	WORD port,			// I/O port address
	DWORD value			// Write Value
);


//-----------------------------------------------------------------------------
// WriteIoPortWord
//-----------------------------------------------------------------------------
VOID 
WINAPI WriteIoPortWord(
	WORD port,			// I/O port address
	WORD value			// Write Value
);

//-----------------------------------------------------------------------------
// WriteIoPortByteEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WriteIoPortByteEx(
	WORD port,			// I/O port address
	BYTE value			// Write Value
);

//-----------------------------------------------------------------------------
// WriteIoPortWordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WriteIoPortWordEx(
	WORD port,			// I/O port address
	WORD value			// Write Value
);


//-----------------------------------------------------------------------------
// WriteIoPortDwordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WriteIoPortDwordEx(
	WORD port,			// I/O port address
	DWORD value			// Write Value
);

/******************************************************************************
**
** PCI
**
******************************************************************************/
// pciAddress
//  0- 2: Function Number
//  3- 7: Device Number
//  8-15: PCI Bus Number
// 16-31: Reserved
// 0xFFFFFFFF : Error

//-----------------------------------------------------------------------------
// SetPciMaxBusNo
//-----------------------------------------------------------------------------
VOID
WINAPI SetPciMaxBusIndex(
	BYTE max			// Max PCI Bus to Scan
);

//-----------------------------------------------------------------------------
// ReadPciConfigByte
//-----------------------------------------------------------------------------
BYTE // Read Value
WINAPI ReadPciConfigByte(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress		// Configuration Address 0-255
);

//-----------------------------------------------------------------------------
// ReadPciConfigWord
//-----------------------------------------------------------------------------
WORD // Read Value
WINAPI ReadPciConfigWord(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress		// Configuration Address 0-255
);

//-----------------------------------------------------------------------------
// ReadPciConfigDword
//-----------------------------------------------------------------------------
DWORD // Read Value
WINAPI ReadPciConfigDword(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress		// Configuration Address 0-255
);

//-----------------------------------------------------------------------------
// ReadPciConfigByteEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadPciConfigByteEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	PBYTE value			// Read Value
);

//-----------------------------------------------------------------------------
// ReadPciConfigWordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadPciConfigWordEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	PWORD value			// Read Value
);

//-----------------------------------------------------------------------------
// ReadPciConfigDwordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadPciConfigDwordEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	PDWORD value		// Read Value
);

//-----------------------------------------------------------------------------
// WritePciConfigByte
//-----------------------------------------------------------------------------
VOID
WINAPI WritePciConfigByte(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress,	// Configuration Address 0-255
	BYTE value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigWord
//-----------------------------------------------------------------------------
VOID
WINAPI WritePciConfigWord(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress,	// Configuration Address 0-255
	WORD value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigDword
//-----------------------------------------------------------------------------
VOID
WINAPI WritePciConfigDword(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress,	// Configuration Address 0-255
	DWORD value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigByteEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WritePciConfigByteEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	BYTE value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigWordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WritePciConfigWordEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	WORD value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigDwordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WritePciConfigDwordEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	DWORD value			// Write Value
);

//-----------------------------------------------------------------------------
// FindPciDeviceById
//-----------------------------------------------------------------------------
DWORD // pciAddress, 0xFFFFFFFF: failure
WINAPI FindPciDeviceById(
	WORD vendorId,		// Vendor ID
	WORD deviceId,		// Device ID
	BYTE index			// Index
);

//-----------------------------------------------------------------------------
// FindPciDeviceByClass
//-----------------------------------------------------------------------------
DWORD // pciAddress, 0xFFFFFFFF: failure
WINAPI FindPciDeviceByClass(
	BYTE baseClass,		// Base Class
	BYTE subClass,		// Sub Class
	BYTE programIf,		// Program Interface
	BYTE index			// Index
);

/******************************************************************************
**
** Memory (Special API)
**
******************************************************************************/

#ifdef _PHYSICAL_MEMORY_SUPPORT
//-----------------------------------------------------------------------------
// ReadDmiMemory
//-----------------------------------------------------------------------------
DWORD // Read size(byte), 0: failure
WINAPI ReadDmiMemory(
	PBYTE buffer,		// Buffer
	DWORD count,		// Count
	DWORD unitSize		// Unit Size (BYTE, WORD, DWORD)
);

//-----------------------------------------------------------------------------
// ReadPhysicalMemory
//-----------------------------------------------------------------------------
DWORD // Read size(byte), 0: failure
WINAPI ReadPhysicalMemory(
	DWORD_PTR address,	// Physical Memory Address
	PBYTE buffer,		// Buffer
	DWORD count,		// Count
	DWORD unitSize		// Unit Size (BYTE, WORD, DWORD)
);

//-----------------------------------------------------------------------------
// WritePhysicalMemory
//-----------------------------------------------------------------------------
DWORD // Write size(byte), 0: failure
WINAPI WritePhysicalMemory(
	DWORD_PTR address,	// Physical Memory Address
	PBYTE buffer,		// Buffer
	DWORD count,		// Count
	DWORD unitSize		// Unit Size (BYTE, WORD, DWORD)
);
#endif
```

`src/winring0/OlsApiInit.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2009 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------
// for WinRing0 1.3.x

#pragma once

#include "OlsDef.h"
#include "OlsApiInitDef.h"

//-----------------------------------------------------------------------------
//
// Prototypes
//
//-----------------------------------------------------------------------------

BOOL InitOpenLibSys(HMODULE *hModule);
BOOL DeinitOpenLibSys(HMODULE *hModule);

//-----------------------------------------------------------------------------
//
// Functions
//
//-----------------------------------------------------------------------------

// DLL
_GetDllStatus GetDllStatus = NULL;
_GetDllVersion GetDllVersion = NULL;
_GetDriverVersion GetDriverVersion = NULL;
_GetDriverType GetDriverType = NULL;

_InitializeOls InitializeOls = NULL;
_DeinitializeOls DeinitializeOls = NULL;

// CPU
_IsCpuid IsCpuid = NULL;
_IsMsr IsMsr = NULL;
_IsTsc IsTsc = NULL;

_Hlt Hlt = NULL;
_Rdmsr Rdmsr = NULL;
_Wrmsr Wrmsr = NULL;
_Rdpmc Rdpmc = NULL;
_Cpuid Cpuid = NULL;
_Rdtsc Rdtsc = NULL;

_HltTx HltTx = NULL;
_RdmsrTx RdmsrTx = NULL;
_WrmsrTx WrmsrTx = NULL;
_RdpmcTx RdpmcTx = NULL;
_CpuidTx CpuidTx = NULL;
_RdtscTx RdtscTx = NULL;

_HltPx HltPx = NULL;
_RdmsrPx RdmsrPx = NULL;
_WrmsrPx WrmsrPx = NULL;
_RdpmcPx RdpmcPx = NULL;
_CpuidPx CpuidPx = NULL;
_RdtscPx RdtscPx = NULL;

// I/O
_ReadIoPortByte ReadIoPortByte = NULL;
_ReadIoPortWord ReadIoPortWord = NULL;
_ReadIoPortDword ReadIoPortDword = NULL;

_ReadIoPortByteEx ReadIoPortByteEx = NULL;
_ReadIoPortWordEx ReadIoPortWordEx = NULL;
_ReadIoPortDwordEx ReadIoPortDwordEx = NULL;

_WriteIoPortByte WriteIoPortByte = NULL;
_WriteIoPortWord WriteIoPortWord = NULL;
_WriteIoPortDword WriteIoPortDword = NULL;

_WriteIoPortByteEx WriteIoPortByteEx = NULL;
_WriteIoPortWordEx WriteIoPortWordEx = NULL;
_WriteIoPortDwordEx WriteIoPortDwordEx = NULL;

// PCI
_SetPciMaxBusIndex SetPciMaxBusIndex = NULL;

_ReadPciConfigByte ReadPciConfigByte = NULL;
_ReadPciConfigWord ReadPciConfigWord = NULL;
_ReadPciConfigDword ReadPciConfigDword = NULL;

_ReadPciConfigByteEx ReadPciConfigByteEx = NULL;
_ReadPciConfigWordEx ReadPciConfigWordEx = NULL;
_ReadPciConfigDwordEx ReadPciConfigDwordEx = NULL;

_WritePciConfigByte WritePciConfigByte = NULL;
_WritePciConfigWord WritePciConfigWord = NULL;
_WritePciConfigDword WritePciConfigDword = NULL;

_WritePciConfigByteEx WritePciConfigByteEx = NULL;
_WritePciConfigWordEx WritePciConfigWordEx = NULL;
_WritePciConfigDwordEx WritePciConfigDwordEx = NULL;

_FindPciDeviceById FindPciDeviceById = NULL;
_FindPciDeviceByClass FindPciDeviceByClass = NULL;

// Memory
#ifdef _PHYSICAL_MEMORY_SUPPORT
_ReadDmiMemory ReadDmiMemory = NULL;
_ReadPhysicalMemory ReadPhysicalMemory = NULL;
_WritePhysicalMemory WritePhysicalMemory = NULL;
#endif

#ifdef _OPEN_LIB_SYS
#ifdef _UNICODE
#define GetOlsString GetOlsStringW
#else
#define GetOlsString GetOlsStringA
#endif

_InstallOpenLibSys InstallOpenLibSys = NULL;
_UninstallOpenLibSys UninstallOpenLibSys = NULL;
_GetDriverStatus GetDriverStatus = NULL;

_GetOlsStringA GetOlsStringA = NULL;
_GetOlsStringW GetOlsStringW = NULL;
_GetOlsValue GetOlsValue = NULL;
_SetOlsValue SetOlsValue = NULL;
#endif

//-----------------------------------------------------------------------------
//
// Initialize
//
//-----------------------------------------------------------------------------

BOOL InitOpenLibSys(HMODULE *hModule)
{
	TCHAR dll_path[MAX_PATH];
	// SDL436: Use fully qualified path from System32 directory
	// GetSystemDirectory ensures we load from the trusted System32 location
	if (!GetSystemDirectory(dll_path, MAX_PATH - 20))
	{
		std::wcerr << "Failed to get System32 directory path.\n";
		return FALSE;
	}
#ifdef _M_X64
	_tcscat_s(dll_path, MAX_PATH, TEXT("\\WinRing0x64.dll"));
#else
	_tcscat_s(dll_path, MAX_PATH, TEXT("\\WinRing0.dll"));
#endif

	// SDL436: Use LoadLibraryEx with LOAD_LIBRARY_SEARCH_SYSTEM32 flag
	// This ensures secure DLL loading from System32 only, preventing DLL injection
	*hModule = LoadLibraryEx(dll_path, NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);

	if(*hModule == NULL)
	{
		std::wcerr << "The dll could not be loaded from " << dll_path <<"\n";
		return FALSE;
	}

	//-----------------------------------------------------------------------------
	// GetProcAddress
	//-----------------------------------------------------------------------------
	// DLL
	GetDllStatus =			(_GetDllStatus)			GetProcAddress (*hModule, "GetDllStatus");
	GetDllVersion =			(_GetDllVersion)		GetProcAddress (*hModule, "GetDllVersion");
	GetDriverVersion =		(_GetDriverVersion)		GetProcAddress (*hModule, "GetDriverVersion");
	GetDriverType =			(_GetDriverType)		GetProcAddress (*hModule, "GetDriverType");

	InitializeOls =			(_InitializeOls)		GetProcAddress (*hModule, "InitializeOls");
	DeinitializeOls =		(_DeinitializeOls)		GetProcAddress (*hModule, "DeinitializeOls");

	// CPU
	IsCpuid =				(_IsCpuid)				GetProcAddress (*hModule, "IsCpuid");
	IsMsr =					(_IsMsr)				GetProcAddress (*hModule, "IsMsr");
	IsTsc =					(_IsTsc)				GetProcAddress (*hModule, "IsTsc");
	Hlt =					(_Hlt)					GetProcAddress (*hModule, "Hlt");
	Rdmsr =					(_Rdmsr)				GetProcAddress (*hModule, "Rdmsr");
	Wrmsr =					(_Wrmsr)				GetProcAddress (*hModule, "Wrmsr");
	Rdpmc =					(_Rdpmc)				GetProcAddress (*hModule, "Rdpmc");
	Cpuid =					(_Cpuid)				GetProcAddress (*hModule, "Cpuid");
	Rdtsc =					(_Rdtsc)				GetProcAddress (*hModule, "Rdtsc");
	HltTx =					(_HltTx)				GetProcAddress (*hModule, "HltTx");
	RdmsrTx =				(_RdmsrTx)				GetProcAddress (*hModule, "RdmsrTx");
	WrmsrTx =				(_WrmsrTx)				GetProcAddress (*hModule, "WrmsrTx");
	RdpmcTx =				(_RdpmcTx)				GetProcAddress (*hModule, "RdpmcTx");
	CpuidTx =				(_CpuidTx)				GetProcAddress (*hModule, "CpuidTx");
	RdtscTx =				(_RdtscTx)				GetProcAddress (*hModule, "RdtscTx");
	HltPx =					(_HltPx)				GetProcAddress (*hModule, "HltPx");
	RdmsrPx =				(_RdmsrPx)				GetProcAddress (*hModule, "RdmsrPx");
	WrmsrPx =				(_WrmsrPx)				GetProcAddress (*hModule, "WrmsrPx");
	RdpmcPx =				(_RdpmcPx)				GetProcAddress (*hModule, "RdpmcPx");
	CpuidPx =				(_CpuidPx)				GetProcAddress (*hModule, "CpuidPx");
	RdtscPx =				(_RdtscPx)				GetProcAddress (*hModule, "RdtscPx");

	// I/O
	ReadIoPortByte =		(_ReadIoPortByte)		GetProcAddress (*hModule, "ReadIoPortByte");
	ReadIoPortWord =		(_ReadIoPortWord)		GetProcAddress (*hModule, "ReadIoPortWord");
	ReadIoPortDword =		(_ReadIoPortDword)		GetProcAddress (*hModule, "ReadIoPortDword");

	ReadIoPortByteEx =		(_ReadIoPortByteEx)		GetProcAddress (*hModule, "ReadIoPortByteEx");
	ReadIoPortWordEx =		(_ReadIoPortWordEx)		GetProcAddress (*hModule, "ReadIoPortWordEx");
	ReadIoPortDwordEx =		(_ReadIoPortDwordEx)	GetProcAddress (*hModule, "ReadIoPortDwordEx");

	WriteIoPortByte =		(_WriteIoPortByte)		GetProcAddress (*hModule, "WriteIoPortByte");
	WriteIoPortWord =		(_WriteIoPortWord)		GetProcAddress (*hModule, "WriteIoPortWord");
	WriteIoPortDword =		(_WriteIoPortDword)		GetProcAddress (*hModule, "WriteIoPortDword");

	WriteIoPortByteEx =		(_WriteIoPortByteEx)	GetProcAddress (*hModule, "WriteIoPortByteEx");
	WriteIoPortWordEx =		(_WriteIoPortWordEx)	GetProcAddress (*hModule, "WriteIoPortWordEx");
	WriteIoPortDwordEx =	(_WriteIoPortDwordEx)	GetProcAddress (*hModule, "WriteIoPortDwordEx");

	// PCI
	SetPciMaxBusIndex =		(_SetPciMaxBusIndex)	GetProcAddress (*hModule, "SetPciMaxBusIndex");

	ReadPciConfigByte =		(_ReadPciConfigByte)	GetProcAddress (*hModule, "ReadPciConfigByte");
	ReadPciConfigWord =		(_ReadPciConfigWord)	GetProcAddress (*hModule, "ReadPciConfigWord");
	ReadPciConfigDword =	(_ReadPciConfigDword)	GetProcAddress (*hModule, "ReadPciConfigDword");

	ReadPciConfigByteEx =	(_ReadPciConfigByteEx)	GetProcAddress (*hModule, "ReadPciConfigByteEx");
	ReadPciConfigWordEx =	(_ReadPciConfigWordEx)	GetProcAddress (*hModule, "ReadPciConfigWordEx");
	ReadPciConfigDwordEx =	(_ReadPciConfigDwordEx)	GetProcAddress (*hModule, "ReadPciConfigDwordEx");

	WritePciConfigByte =	(_WritePciConfigByte)	GetProcAddress (*hModule, "WritePciConfigByte");
	WritePciConfigWord =	(_WritePciConfigWord)	GetProcAddress (*hModule, "WritePciConfigWord");
	WritePciConfigDword =	(_WritePciConfigDword)	GetProcAddress (*hModule, "WritePciConfigDword");

	WritePciConfigByteEx =	(_WritePciConfigByteEx)	GetProcAddress (*hModule, "WritePciConfigByteEx");
	WritePciConfigWordEx =	(_WritePciConfigWordEx)	GetProcAddress (*hModule, "WritePciConfigWordEx");
	WritePciConfigDwordEx =	(_WritePciConfigDwordEx)GetProcAddress (*hModule, "WritePciConfigDwordEx");

	FindPciDeviceById =		(_FindPciDeviceById)	GetProcAddress (*hModule, "FindPciDeviceById");
	FindPciDeviceByClass =	(_FindPciDeviceByClass)	GetProcAddress (*hModule, "FindPciDeviceByClass");

	// Memory
#ifdef _PHYSICAL_MEMORY_SUPPORT
	ReadDmiMemory =			(_ReadDmiMemory)		GetProcAddress (*hModule, "ReadDmiMemory");
	ReadPhysicalMemory =	(_ReadPhysicalMemory)	GetProcAddress (*hModule, "ReadPhysicalMemory");
	WritePhysicalMemory =	(_WritePhysicalMemory)	GetProcAddress (*hModule, "WritePhysicalMemory");
#endif

	//-----------------------------------------------------------------------------
	// Check Functions
	//-----------------------------------------------------------------------------
	if(!(
		GetDllStatus
	&&	GetDllVersion
	&&	GetDriverVersion
	&&	GetDriverType
	&&	InitializeOls
	&&	DeinitializeOls
	&&	IsCpuid
	&&	IsMsr
	&&	IsTsc
	&&	Hlt
	&&	HltTx
	&&	HltPx
	&&	Rdmsr
	&&	RdmsrTx
	&&	RdmsrPx
	&&	Wrmsr
	&&	WrmsrTx
	&&	WrmsrPx
	&&	Rdpmc
	&&	RdpmcTx
	&&	RdpmcPx
	&&	Cpuid
	&&	CpuidTx
	&&	CpuidPx
	&&	Rdtsc
	&&	RdtscTx
	&&	RdtscPx
	&&	ReadIoPortByte
	&&	ReadIoPortWord
	&&	ReadIoPortDword
	&&	ReadIoPortByteEx
	&&	ReadIoPortWordEx
	&&	ReadIoPortDwordEx
	&&	WriteIoPortByte
	&&	WriteIoPortWord
	&&	WriteIoPortDword
	&&	WriteIoPortByteEx
	&&	WriteIoPortWordEx
	&&	WriteIoPortDwordEx
	&&	SetPciMaxBusIndex
	&&	ReadPciConfigByte
	&&	ReadPciConfigWord
	&&	ReadPciConfigDword
	&&	ReadPciConfigByteEx
	&&	ReadPciConfigWordEx
	&&	ReadPciConfigDwordEx
	&&	WritePciConfigByte
	&&	WritePciConfigWord 
	&&	WritePciConfigDword
	&&	WritePciConfigByteEx
	&&	WritePciConfigWordEx 
	&&	WritePciConfigDwordEx
	&&	FindPciDeviceById
	&&	FindPciDeviceByClass
#ifdef _PHYSICAL_MEMORY_SUPPORT
	&&	ReadDmiMemory
	&&	ReadPhysicalMemory
	&&	WritePhysicalMemory
#endif
	))
	{
		return FALSE;
	}

	return InitializeOls();
}

//-----------------------------------------------------------------------------
//
// Deinitialize
//
//-----------------------------------------------------------------------------

BOOL DeinitOpenLibSys(HMODULE *hModule)
{
	BOOL result = FALSE;

	if(*hModule == NULL)
	{
		return TRUE;
	}
	else
	{
		DeinitializeOls();
		result = FreeLibrary(*hModule);
		*hModule = NULL;

		return result;
	}
}

```

`src/winring0/OlsApiInitDef.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2009 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------
// for WinRing0 1.3.x

#pragma once

//-----------------------------------------------------------------------------
//
// Type Defines
//
//-----------------------------------------------------------------------------

// DLL
typedef DWORD (WINAPI *_GetDllStatus) ();
typedef DWORD (WINAPI *_GetDllVersion) (PBYTE major, PBYTE minor, PBYTE revision, PBYTE release);
typedef DWORD (WINAPI *_GetDriverVersion) (PBYTE major, PBYTE minor, PBYTE revision, PBYTE release);
typedef DWORD (WINAPI *_GetDriverType) ();

typedef BOOL (WINAPI *_InitializeOls) ();
typedef VOID (WINAPI *_DeinitializeOls) ();

// CPU
typedef BOOL (WINAPI *_IsCpuid) ();
typedef BOOL (WINAPI *_IsMsr) ();
typedef BOOL (WINAPI *_IsTsc) ();

typedef BOOL  (WINAPI *_Hlt) ();
typedef DWORD (WINAPI *_Rdmsr) (DWORD index, PDWORD eax, PDWORD edx);
typedef DWORD (WINAPI *_Wrmsr) (DWORD index, DWORD eax, DWORD edx);
typedef DWORD (WINAPI *_Rdpmc) (DWORD index, PDWORD eax, PDWORD edx);
typedef DWORD (WINAPI *_Cpuid) (DWORD index, PDWORD eax, PDWORD ebx, PDWORD ecx, PDWORD edx);
typedef DWORD (WINAPI *_Rdtsc) (PDWORD eax, PDWORD edx);

typedef BOOL  (WINAPI *_HltTx) (DWORD_PTR threadAffinityMask);
typedef DWORD (WINAPI *_RdmsrTx) (DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR threadAffinityMask);
typedef DWORD (WINAPI *_WrmsrTx) (DWORD index, DWORD eax, DWORD edx, DWORD_PTR threadAffinityMask);
typedef DWORD (WINAPI *_RdpmcTx) (DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR threadAffinityMask);
typedef DWORD (WINAPI *_CpuidTx) (DWORD index, PDWORD eax, PDWORD ebx, PDWORD ecx, PDWORD edx, DWORD_PTR threadAffinityMask);
typedef DWORD (WINAPI *_RdtscTx) (PDWORD eax, PDWORD edx, DWORD_PTR threadAffinityMask);

typedef BOOL  (WINAPI *_HltPx)   (DWORD_PTR processAffinityMask);
typedef DWORD (WINAPI *_RdmsrPx) (DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR processAffinityMask);
typedef DWORD (WINAPI *_WrmsrPx) (DWORD index, DWORD eax, DWORD edx, DWORD_PTR processAffinityMask);
typedef DWORD (WINAPI *_RdpmcPx) (DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR processAffinityMask);
typedef DWORD (WINAPI *_CpuidPx) (DWORD index, PDWORD eax, PDWORD ebx, PDWORD ecx, PDWORD edx, DWORD_PTR processAffinityMask);
typedef DWORD (WINAPI *_RdtscPx) (PDWORD eax, PDWORD edx, DWORD_PTR processAffinityMask);

// I/O
typedef BYTE  (WINAPI *_ReadIoPortByte) (WORD address);
typedef WORD  (WINAPI *_ReadIoPortWord) (WORD address);
typedef DWORD (WINAPI *_ReadIoPortDword) (WORD address);

typedef BOOL (WINAPI *_ReadIoPortByteEx) (WORD address, PBYTE value);
typedef BOOL (WINAPI *_ReadIoPortWordEx) (WORD address, PWORD value);
typedef BOOL (WINAPI *_ReadIoPortDwordEx) (WORD address, PDWORD value);

typedef VOID (WINAPI *_WriteIoPortByte) (WORD address, BYTE value);
typedef VOID (WINAPI *_WriteIoPortWord) (WORD address, WORD value);
typedef VOID (WINAPI *_WriteIoPortDword) (WORD address, DWORD value);

typedef BOOL (WINAPI *_WriteIoPortByteEx) (WORD address, BYTE value);
typedef BOOL (WINAPI *_WriteIoPortWordEx) (WORD address, WORD value);
typedef BOOL (WINAPI *_WriteIoPortDwordEx) (WORD address, DWORD value);

// PCI
typedef VOID (WINAPI *_SetPciMaxBusIndex) (BYTE max);

typedef BYTE  (WINAPI *_ReadPciConfigByte) (DWORD pciAddress, BYTE regAddress);
typedef WORD  (WINAPI *_ReadPciConfigWord) (DWORD pciAddress, BYTE regAddress);
typedef DWORD (WINAPI *_ReadPciConfigDword) (DWORD pciAddress, BYTE regAddress);

typedef BOOL (WINAPI *_ReadPciConfigByteEx) (DWORD pciAddress, DWORD regAddress, PBYTE value);
typedef BOOL (WINAPI *_ReadPciConfigWordEx) (DWORD pciAddress, DWORD regAddress, PWORD value);
typedef BOOL (WINAPI *_ReadPciConfigDwordEx) (DWORD pciAddress, DWORD regAddress, PDWORD value);

typedef VOID (WINAPI *_WritePciConfigByte) (DWORD pciAddress, BYTE regAddress, BYTE value);
typedef VOID (WINAPI *_WritePciConfigWord) (DWORD pciAddress, BYTE regAddress, WORD value);
typedef VOID (WINAPI *_WritePciConfigDword) (DWORD pciAddress, BYTE regAddress, DWORD value);

typedef BOOL (WINAPI *_WritePciConfigByteEx) (DWORD pciAddress, DWORD regAddress, BYTE value);
typedef BOOL (WINAPI *_WritePciConfigWordEx) (DWORD pciAddress, DWORD regAddress, WORD value);
typedef BOOL (WINAPI *_WritePciConfigDwordEx) (DWORD pciAddress, DWORD regAddress, DWORD value);

typedef DWORD (WINAPI *_FindPciDeviceById) (WORD vendorId, WORD deviceId, BYTE index);
typedef DWORD (WINAPI *_FindPciDeviceByClass) (BYTE baseClass, BYTE subClass, BYTE programIf, BYTE index);

// Memory
#ifdef _PHYSICAL_MEMORY_SUPPORT
typedef DWORD (WINAPI *_ReadDmiMemory) (PBYTE buffer, DWORD count, DWORD unitSize);
typedef DWORD (WINAPI *_ReadPhysicalMemory) (DWORD_PTR address, PBYTE buffer, DWORD count, DWORD unitSize);
typedef DWORD (WINAPI *_WritePhysicalMemory) (DWORD_PTR address, PBYTE buffer, DWORD count, DWORD unitSize);
#endif

```

`src/winring0/OlsApiInitExt.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2009 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------
// for WinRing0 1.3.x

#pragma once

#include "OlsApiInitDef.h"

//-----------------------------------------------------------------------------
//
// Externs
//
//-----------------------------------------------------------------------------

// DLL
extern _GetDllStatus GetDllStatus;
extern _GetDllVersion GetDllVersion;
extern _GetDriverVersion GetDriverVersion;
extern _GetDriverType GetDriverType;

extern _InitializeOls InitializeOls;
extern _DeinitializeOls DeinitializeOls;

// CPU
extern _IsCpuid IsCpuid;
extern _IsMsr IsMsr;
extern _IsTsc IsTsc;

extern _Hlt Hlt;
extern _Rdmsr Rdmsr;
extern _Wrmsr Wrmsr;
extern _Rdpmc Rdpmc;
extern _Cpuid Cpuid;
extern _Rdtsc Rdtsc;

extern _HltTx HltTx;
extern _RdmsrTx RdmsrTx;
extern _WrmsrTx WrmsrTx;
extern _RdpmcTx RdpmcTx;
extern _CpuidTx CpuidTx;
extern _RdtscTx RdtscTx;

extern _HltPx HltPx;
extern _RdmsrPx RdmsrPx;
extern _WrmsrPx WrmsrPx;
extern _RdpmcPx RdpmcPx;
extern _CpuidPx CpuidPx;
extern _RdtscPx RdtscPx;

// I/O
extern _ReadIoPortByte ReadIoPortByte;
extern _ReadIoPortWord ReadIoPortWord;
extern _ReadIoPortDword ReadIoPortDword;

extern _ReadIoPortByteEx ReadIoPortByteEx;
extern _ReadIoPortWordEx ReadIoPortWordEx;
extern _ReadIoPortDwordEx ReadIoPortDwordEx;

extern _WriteIoPortByte WriteIoPortByte;
extern _WriteIoPortWord WriteIoPortWord;
extern _WriteIoPortDword WriteIoPortDword;

extern _WriteIoPortByteEx WriteIoPortByteEx;
extern _WriteIoPortWordEx WriteIoPortWordEx;
extern _WriteIoPortDwordEx WriteIoPortDwordEx;

// PCI
extern _SetPciMaxBusIndex SetPciMaxBusIndex;

extern _ReadPciConfigByte ReadPciConfigByte;
extern _ReadPciConfigWord ReadPciConfigWord;
extern _ReadPciConfigDword ReadPciConfigDword;

extern _ReadPciConfigByteEx ReadPciConfigByteEx;
extern _ReadPciConfigWordEx ReadPciConfigWordEx;
extern _ReadPciConfigDwordEx ReadPciConfigDwordEx;

extern _WritePciConfigByte WritePciConfigByte;
extern _WritePciConfigWord WritePciConfigWord;
extern _WritePciConfigDword WritePciConfigDword;

extern _WritePciConfigByteEx WritePciConfigByteEx;
extern _WritePciConfigWordEx WritePciConfigWordEx;
extern _WritePciConfigDwordEx WritePciConfigDwordEx;

extern _FindPciDeviceById FindPciDeviceById;
extern _FindPciDeviceByClass FindPciDeviceByClass;

// Memory
#ifdef _PHYSICAL_MEMORY_SUPPORT
extern _ReadDmiMemory ReadDmiMemory;
extern _ReadPhysicalMemory ReadPhysicalMemory;
extern _WritePhysicalMemory WritePhysicalMemory;
#endif

```

`src/winring0/OlsDef.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                          Copyright 2007 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
//
// DLL Status Code
//
//-----------------------------------------------------------------------------

#define OLS_DLL_NO_ERROR						0
#define OLS_DLL_UNSUPPORTED_PLATFORM			1
#define OLS_DLL_DRIVER_NOT_LOADED				2
#define OLS_DLL_DRIVER_NOT_FOUND				3
#define OLS_DLL_DRIVER_UNLOADED					4
#define OLS_DLL_DRIVER_NOT_LOADED_ON_NETWORK	5
#define OLS_DLL_UNKNOWN_ERROR					9

//-----------------------------------------------------------------------------
//
// Driver Type
//
//-----------------------------------------------------------------------------

#define OLS_DRIVER_TYPE_UNKNOWN			0
#define OLS_DRIVER_TYPE_WIN_9X			1
#define OLS_DRIVER_TYPE_WIN_NT			2
#define OLS_DRIVER_TYPE_WIN_NT4			3	// Obsolete
#define OLS_DRIVER_TYPE_WIN_NT_X64		4
#define OLS_DRIVER_TYPE_WIN_NT_IA64		5	// Reserved

//-----------------------------------------------------------------------------
//
// PCI Error Code
//
//-----------------------------------------------------------------------------

#define OLS_ERROR_PCI_BUS_NOT_EXIST		(0xE0000001L)
#define OLS_ERROR_PCI_NO_DEVICE			(0xE0000002L)
#define OLS_ERROR_PCI_WRITE_CONFIG		(0xE0000003L)
#define OLS_ERROR_PCI_READ_CONFIG		(0xE0000004L)

//-----------------------------------------------------------------------------
//
// Support Macros
//
//-----------------------------------------------------------------------------

// Bus Number, Device Number and Function Number to PCI Device Address
#define PciBusDevFunc(Bus, Dev, Func)	((Bus&0xFF)<<8) | ((Dev&0x1F)<<3) | (Func&7)
// PCI Device Address to Bus Number
#define PciGetBus(address)				((address>>8) & 0xFF)
// PCI Device Address to Device Number
#define PciGetDev(address)				((address>>3) & 0x1F)
// PCI Device Address to Function Number
#define PciGetFunc(address)				(address&7)

```

`tests/CMakeLists.txt`:

```txt
# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2022-2024, Intel Corporation

set(CMAKE_TEST_BINARY_DIR ${CMAKE_BINARY_DIR}/bin/tests)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_TEST_BINARY_DIR})

if(UNIX)

    # daemon_alignment_test on Linux and Unix
    file(GLOB TEST_FILE daemon_alignment_test.cpp pcm-accel-common.cpp)
    add_executable(daemon_alignment_test ${TEST_FILE})
    target_link_libraries(daemon_alignment_test)

    if(NOT APPLE)
        # numa_to_socket_test
        add_executable(numa_to_socket_test numa_to_socket_test.cpp)
        target_link_libraries(numa_to_socket_test Threads::Threads PCM_STATIC)

    	# cache_verification_test
    	add_executable(cache_verification_test cache_verification_test.cpp)
    	target_link_libraries(cache_verification_test Threads::Threads PCM_STATIC)
    endif()

    # PCM_STATIC + pcm_sensor = urltest
    if(LINUX)
        add_executable(urltest urltest.cpp)
        target_link_libraries(urltest Threads::Threads PCM_STATIC)
    endif(LINUX)

    if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/googletest/googletest/include/gtest/gtest.h")
        add_subdirectory(googletest)
        add_subdirectory(utests)
    else()
        message(WARNING
            "Local googletest does not exist - unit tests will not be built.\n"
            "If you need unit tests, please update submodules with the command: 'git submodule update --init --recursive'.\n")
    endif()
endif(UNIX)

if(PCM_FUZZ)
    find_package(OpenSSL REQUIRED)
    set(SSL_LIBS OpenSSL::SSL OpenSSL::Crypto)
    add_executable(urltest-fuzz urltest-fuzz.cpp)
    add_executable(pcm-sensor-server-fuzz pcm-sensor-server-fuzz.cpp)
    add_executable(pcm-sensor-server-ssl-fuzz pcm-sensor-server-fuzz.cpp)
    target_compile_options(pcm-sensor-server-fuzz PRIVATE -DUSE_SSL=1)
    target_compile_options(pcm-sensor-server-ssl-fuzz PRIVATE -DUSE_SSL=1 -DFUZZ_USE_SSL=1)
    add_executable(pcm-fuzz pcm-fuzz.cpp)
    add_executable(pcm-memory-fuzz pcm-memory-fuzz.cpp)
    target_link_libraries(urltest-fuzz Threads::Threads PCM_STATIC)
    target_link_libraries(pcm-sensor-server-fuzz Threads::Threads PCM_STATIC ${SSL_LIBS})
    target_link_libraries(pcm-sensor-server-ssl-fuzz Threads::Threads PCM_STATIC ${SSL_LIBS})
    target_link_libraries(pcm-fuzz Threads::Threads PCM_STATIC)
    target_link_libraries(pcm-memory-fuzz Threads::Threads PCM_STATIC)
endif()

```

`tests/cache_verification_test.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2025, Intel Corporation
// Test program to verify cache functionality in mapNUMANodeToSocket()

#include <iostream>
#include <chrono>
#include "../src/cpucounters.h"

using namespace pcm;
using namespace std::chrono;

int main()
{
    std::cout << "Testing mapNUMANodeToSocket() cache functionality\n";
    std::cout << "================================================\n\n";
    
    PCM * m = PCM::getInstance();
    
    if (m->program() != PCM::Success)
    {
        std::cout << "Note: Cannot access CPU counters (expected on non-Intel or without root)\n";
        std::cout << "This test will still verify that the cache mechanism compiles correctly.\n";
        std::cout << "Cache verification test PASSED (compilation check)\n";
        return 0;
    }
    
    std::cout << "PCM initialized successfully\n";
    std::cout << "Testing cache performance...\n\n";
    
    // Test NUMA node 0 multiple times to measure caching effect
    const int iterations = 100;
    
    // First call - should compute and cache
    auto start = high_resolution_clock::now();
    int32 result1 = m->mapNUMANodeToSocket(0);
    auto end = high_resolution_clock::now();
    auto first_duration = duration_cast<microseconds>(end - start).count();
    
    std::cout << "First call (cache miss) for NUMA node 0: " << result1 
              << " (took " << first_duration << " microseconds)\n";
    
    // Subsequent calls - should use cache
    start = high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        int32 result = m->mapNUMANodeToSocket(0);
        if (result != result1) {
            std::cerr << "ERROR: Inconsistent results from cache!\n";
            return 1;
        }
    }
    end = high_resolution_clock::now();
    auto cached_duration = duration_cast<microseconds>(end - start).count();
    double avg_cached = static_cast<double>(cached_duration) / iterations;
    
    std::cout << "Average time for " << iterations << " cached calls: " 
              << avg_cached << " microseconds per call\n";
    
    // Cache should be significantly faster (at least 2x)
    if (first_duration > 0 && avg_cached > 0) {
        double speedup = static_cast<double>(first_duration) / avg_cached;
        std::cout << "\nSpeedup from caching: " << speedup << "x\n";
        
        if (speedup > 2.0) {
            std::cout << "\nCache is working effectively!\n";
        } else {
            std::cout << "\nWarning: Cache speedup is less than expected, but this may be normal on some systems.\n";
        }
    }
    
    // Test multiple NUMA nodes to verify cache stores multiple entries
    std::cout << "\nTesting multiple NUMA nodes (0-7):\n";
    for (uint32 node = 0; node < 8; ++node) {
        int32 socket = m->mapNUMANodeToSocket(node);
        std::cout << "  NUMA node " << node << " -> Socket " << socket << "\n";
    }
    
    // Test NUMA node > 255 (now also cached)
    std::cout << "\nTesting NUMA node 256 (now also cached):\n";
    int32 result_256 = m->mapNUMANodeToSocket(256);
    std::cout << "  NUMA node 256 -> Socket " << result_256 << "\n";
    
    std::cout << "\nCache verification test PASSED\n";
    
    m->cleanup();
    return 0;
}

```

`tests/daemon_alignment_test.cpp`:

```cpp
#include <stdio.h>
#include <cstdlib>
#include <cstdint>
#include <algorithm>

#include "../src/daemon/common.h"
#include "../src/utils.h"

#define ALIGNMENT 64

void checkAlignment(char const * debugMessage, void* ptr)
{
	printf("Checking: %-20s\t\t", debugMessage);
	uint64_t currentAlignment = (uint64_t)ptr % ALIGNMENT;
	if(currentAlignment != 0)
	{
		printf("Failed\n");
		printf("Current alignment: %llu\n\n", (unsigned long long)currentAlignment);
		exit(EXIT_FAILURE);
	}
	else
	{
		printf("Passed\n");
	}
}

int main()
{
    printf("Testing alignment\n\n");

    PCMDaemon::SharedPCMState* pcmState = (PCMDaemon::SharedPCMState*)aligned_alloc(ALIGNMENT, sizeof(PCMDaemon::SharedPCMState));

    if (pcmState == nullptr)
    {
        printf("Memory allocation failed\n\n");
        exit(EXIT_FAILURE);
    }

    std::fill((char*)pcmState, ((char*)pcmState) + sizeof(PCMDaemon::SharedPCMState), 0);

    checkAlignment("pcmState", pcmState);

    checkAlignment("pcm", &pcmState->pcm);

    checkAlignment("pcm core", &pcmState->pcm.core);
    checkAlignment("pcm memory", &pcmState->pcm.memory);
    checkAlignment("pcm qpi", &pcmState->pcm.qpi);

    for(uint32_t i(0); i < MAX_CPU_CORES; ++i)
    {
    	checkAlignment("pcm core cores", &pcmState->pcm.core.cores[i]);
    }

    checkAlignment("pcm core energyUsed", &pcmState->pcm.core.energyUsedBySockets);

    for(uint32_t i(0); i < MAX_SOCKETS; ++i)
    {
    	checkAlignment("pcm memory sockets", &pcmState->pcm.memory.sockets[i]);
    }

    for(uint32_t i(0); i < MAX_SOCKETS; ++i)
    {
    	checkAlignment("pcm qpi incoming", &pcmState->pcm.qpi.incoming[i]);
    }
    
    for(uint32_t i(0); i < MAX_SOCKETS; ++i)
    {
    	for(uint32_t j(0); j < QPI_MAX_LINKS; ++j)
    	{
    		checkAlignment("pcm qpi incoming links", &pcmState->pcm.qpi.incoming[i].links[j]);
    	}
    }

    for(uint32_t i(0); i < MAX_SOCKETS; ++i)
    {
    	checkAlignment("pcm qpi outgoing", &pcmState->pcm.qpi.outgoing[i]);
    }

    for(uint32_t i(0); i < MAX_SOCKETS; ++i)
    {
    	for(uint32_t j(0); j < QPI_MAX_LINKS; ++j)
    	{
    		checkAlignment("pcm qpi outgoing links", &pcmState->pcm.qpi.outgoing[i].links[j]);
    	}
    }

    pcm::freeAndNullify(pcmState);

    printf("\n------ All passed ------\n\n");

    return EXIT_SUCCESS;
}
```

`tests/fuzz.sh`:

```sh

export PCM_ENFORCE_MBM="1"

factor=1

if [ "$#" -eq 1 ]; then
    factor=$1
fi

# Suppress leaks in libcrypto
# Below is caused by openssl leaks
# similar to https://github.com/spdk/spdk/issues/2947
echo leak:libcrypto.so >> pcm_asan_suppression_file
export LSAN_OPTIONS=suppressions="pcm_asan_suppression_file"

echo "Running fuzz tests with running time multiplier $factor"

CC=`which clang` CXX=`which clang++` cmake ..  -DCMAKE_BUILD_TYPE=Debug -DPCM_FUZZ=ON && mkdir -p corpus &&
make urltest-fuzz \
     pcm-fuzz \
     pcm-memory-fuzz \
     pcm-sensor-server-fuzz \
     pcm-sensor-server-ssl-fuzz \
     -j &&
ldd bin/tests/pcm-fuzz &&
rm -rf corpus/* &&
printf '%b' "GET / HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/1 &&
printf '%b' "GET /metrics HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/2 &&
printf '%b' "GET /persecond HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/3 &&
printf '%b' "GET /persecond HTTP/1.1\r\nHost: localhost\r\nAccept: application/json\r\n\r\n" > corpus/3.1 &&
printf '%b' "GET /persecond HTTP/1.1\r\nHost: localhost\r\nAccept: text/plain; version=0.0.4\r\n\r\n" > corpus/3.2 &&
printf '%b' "GET /persecond/1 HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n"   > corpus/4 &&
printf '%b' "GET /persecond/1 HTTP/1.1\r\nHost: localhost\r\nAccept: application/json\r\n\r\n"   > corpus/4.1 &&
printf '%b' "GET /persecond/1 HTTP/1.1\r\nHost: localhost\r\nAccept: text/plain; version=0.0.4\r\n\r\n"   > corpus/4.2 &&
printf '%b' "GET /persecond/10 HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/5 &&
printf '%b' "GET /persecond/10 HTTP/1.1\r\nHost: localhost\r\nAccept: application/json\r\n\r\n" > corpus/5.1 &&
printf '%b' "GET /persecond/10 HTTP/1.1\r\nHost: localhost\r\nAccept: text/plain; version=0.0.4\r\n\r\n" > corpus/5.2 &&
printf '%b' "GET /persecond/100 HTTP/1.1\r\nHost: localhost\r\nAccept: application/json\r\n\r\n" > corpus/6 &&
printf '%b' "GET /metrics HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/7 &&
printf '%b' "GET /dashboard/influxdb HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/8 &&
printf '%b' "GET /dashboard/prometheus HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/9 &&
printf '%b' "GET /dashboard/prometheus/default HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/10 &&
printf '%b' "GET /dashboard HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/11 &&
printf '%b' "GET /favicon.ico HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/12 &&
LLVM_PROFILE_FILE="pcm-sensor-server-ssl.profraw" bin/tests/pcm-sensor-server-ssl-fuzz -detect_leaks=0 -max_total_time=$((10 * $factor)) -rss_limit_mb=10000 corpus > /dev/null &&
rm -rf corpus/* &&
printf '%b' "GET / HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/1 &&
printf '%b' "GET /metrics HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/2 &&
printf '%b' "GET /persecond HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/3 &&
printf '%b' "GET /persecond HTTP/1.1\r\nHost: localhost\r\nAccept: application/json\r\n\r\n" > corpus/3.1 &&
printf '%b' "GET /persecond HTTP/1.1\r\nHost: localhost\r\nAccept: text/plain; version=0.0.4\r\n\r\n" > corpus/3.2 &&
printf '%b' "GET /persecond/1 HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n"   > corpus/4 &&
printf '%b' "GET /persecond/1 HTTP/1.1\r\nHost: localhost\r\nAccept: application/json\r\n\r\n"   > corpus/4.1 &&
printf '%b' "GET /persecond/1 HTTP/1.1\r\nHost: localhost\r\nAccept: text/plain; version=0.0.4\r\n\r\n"   > corpus/4.2 &&
printf '%b' "GET /persecond/10 HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/5 &&
printf '%b' "GET /persecond/10 HTTP/1.1\r\nHost: localhost\r\nAccept: application/json\r\n\r\n" > corpus/5.1 &&
printf '%b' "GET /persecond/10 HTTP/1.1\r\nHost: localhost\r\nAccept: text/plain; version=0.0.4\r\n\r\n" > corpus/5.2 &&
printf '%b' "GET /persecond/100 HTTP/1.1\r\nHost: localhost\r\nAccept: application/json\r\n\r\n" > corpus/6 &&
printf '%b' "GET /metrics HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/7 &&
printf '%b' "GET /dashboard/influxdb HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/8 &&
printf '%b' "GET /dashboard/prometheus HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/9 &&
printf '%b' "GET /dashboard/prometheus/default HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/10 &&
printf '%b' "GET /dashboard HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/11 &&
printf '%b' "GET /favicon.ico HTTP/1.1\r\nHost: localhost\r\nAccept: */*\r\n\r\n" > corpus/12 &&
LLVM_PROFILE_FILE="pcm-sensor-server.profraw" bin/tests/pcm-sensor-server-fuzz -detect_leaks=0 -rss_limit_mb=10000 -max_total_time=$((10 * $factor)) corpus > /dev/null &&
rm -rf corpus/* &&
printf '%b' "http://otto:test@www.intel.com/~otto/file1.txt" > corpus/1 &&
printf '%b' "file://localhost/c/mnt/cd/file2.txt" > corpus/2 &&
printf '%b' "ftp://otto%40yahoo.com:abcd%3B1234@www.intel.com:30/xyz.php?a=1&t=3" > corpus/3 &&
printf '%b' "gopher://otto@hostname1.intel.com:8080/file3.zyx" > corpus/4 &&
printf '%b' "www.intel.com" > corpus/5 &&
printf '%b' "http://www.blah.org/file.html#firstmark" > corpus/6 &&
printf '%b' "http://www.blah.org/file.html#firstmark%21%23" > corpus/7 &&
printf '%b' "localhost" > corpus/8 &&
printf '%b' "https://www.intel.com" > corpus/9 &&
printf '%b' "://google.com/" > corpus/10 &&
printf '%b' "https://intc.com/request?" > corpus/11 &&
printf '%b' "htt:ps//www.intel.com" > corpus/12 &&
printf '%b' "http://www.intel.com:66666/" > corpus/13 &&
printf '%b' "http:///" > corpus/14 &&
printf '%b' "http://[1234::1234::1234/" > corpus/15 &&
printf '%b' "http://@www.intel.com" > corpus/16 &&
printf '%b' "http://otto@:www.intel.com" > corpus/17 &&
printf '%b' "https://:@www.intel.com" > corpus/18 &&
printf '%b' "https://user:@www.intel.com" > corpus/19 &&
printf '%b' "http:www.intel.com/" > corpus/20 &&
printf '%b' "http://ww\x00\x00\x00rstmark\x0a" > corpus/21 &&
LLVM_PROFILE_FILE="urltest.profraw" bin/tests/urltest-fuzz -max_total_time=$((10 * $factor)) corpus > /dev/null &&
rm -rf corpus/* && LLVM_PROFILE_FILE="pcm.profraw" bin/tests/pcm-fuzz -max_total_time=$((5 * $factor)) corpus > /dev/null &&
rm -rf corpus/* && LLVM_PROFILE_FILE="pcm.no_perf.profraw" PCM_NO_PERF=1 bin/tests/pcm-fuzz -max_total_time=$((5 * $factor)) corpus  > /dev/null &&
rm -rf corpus/* && LLVM_PROFILE_FILE="pcm.uncore_perf.profraw" PCM_USE_UNCORE_PERF=1 bin/tests/pcm-fuzz -max_total_time=$((5 * $factor)) corpus > /dev/null &&
rm -rf corpus/* && LLVM_PROFILE_FILE="pcm.nmi_watchdog.profraw" PCM_KEEP_NMI_WATCHDOG=1 bin/tests/pcm-fuzz -max_total_time=$((1 * $factor)) corpus > /dev/null &&
rm -rf corpus/* && LLVM_PROFILE_FILE="pcm-memory.profraw" bin/tests/pcm-memory-fuzz -max_total_time=$((10 * $factor)) corpus > /dev/null &&
llvm-profdata merge -sparse \
        urltest.profraw \
        pcm.profraw \
        pcm.no_perf.profraw \
        pcm.uncore_perf.profraw \
        pcm.nmi_watchdog.profraw \
        pcm-memory.profraw \
        pcm-sensor-server.profraw \
        pcm-sensor-server-ssl.profraw \
        -o all.profdata &&
llvm-cov report --summary-only \
        -object ./bin/tests/pcm-fuzz \
        -object ./bin/tests/urltest-fuzz \
        -object ./bin/tests/pcm-memory-fuzz \
        -object ./bin/tests/pcm-sensor-server-fuzz \
        -object ./bin/tests/pcm-sensor-server-ssl-fuzz \
        -instr-profile=all.profdata | tee report.txt


```

`tests/numa_test.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2024, Intel Corporation
// Test program for getNUMANode() API

#include <iostream>
#include <iomanip>
#include "../src/pci.h"

using namespace pcm;

int main()
{
    std::cout << "Testing getNUMANode() API\n";
    std::cout << "=========================\n\n";
    
    // Note: Testing with PCI device 0:0:0.0 which is commonly the host bridge
    // This device may not exist on all systems or may require root permissions to access
    std::cout << "Attempting to test with PCI device 0:0:0.0 (host bridge)\n";
    
    try
    {
        // Try to create a PciHandle for a common device
        // We'll try bus 0, device 0, function 0 as it often exists
        PciHandleType handle(0, 0, 0, 0);
        
        std::cout << "Successfully created PciHandle for 0:0:0.0\n";
        
        // Get NUMA node
        int32 numa_node = handle.getNUMANode();
        
        std::cout << "NUMA node: " << numa_node;
        if (numa_node == -1)
        {
            std::cout << " (not available or not applicable)";
        }
        std::cout << "\n";
        
        // Test reading vendor ID to verify the handle works
        uint32 vendor_device_id = 0;
        if (handle.read32(0, &vendor_device_id) == sizeof(uint32))
        {
            uint32 vendor_id = vendor_device_id & 0xFFFF;
            uint32 device_id = (vendor_device_id >> 16) & 0xFFFF;
            std::cout << "Vendor ID: 0x" << std::hex << std::setw(4) << std::setfill('0') 
                      << vendor_id << ", Device ID: 0x" << device_id << std::dec << "\n";
        }
        
        std::cout << "\nTest PASSED\n";
        return 0;
    }
    catch (const std::exception& e)
    {
        std::cerr << "Exception: " << e.what() << "\n";
        std::cerr << "Note: This is expected if device 0:0:0.0 doesn't exist or you don't have permissions\n";
        std::cerr << "\nTest completed (device not accessible)\n";
        return 0;  // Not a failure - just means device doesn't exist
    }
}

```

`tests/numa_to_socket_test.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2025, Intel Corporation
// Test program for mapNUMANodeToSocket() API

#include <iostream>
#include <iomanip>
#include "../src/cpucounters.h"

using namespace pcm;

int main()
{
    std::cout << "Testing mapNUMANodeToSocket() API\n";
    std::cout << "==================================\n\n";
    
    PCM * m = PCM::getInstance();
    
    if (m->program() != PCM::Success)
    {
        std::cerr << "Error: Cannot access CPU counters\n";
        std::cerr << "Try running as root/administrator\n";
        return 1;
    }
    
    std::cout << "PCM initialized successfully\n";
    std::cout << "Number of sockets: " << m->getNumSockets() << "\n";
    std::cout << "Number of cores: " << m->getNumCores() << "\n\n";
    
    // Test mapping for NUMA nodes 0-7 (most systems won't have more)
    std::cout << "NUMA Node -> Socket Mapping:\n";
    std::cout << "-----------------------------\n";
    
    bool found_valid_mapping = false;
    for (uint32 numa_node = 0; numa_node < 8; ++numa_node)
    {
        int32 socket_id = m->mapNUMANodeToSocket(numa_node);
        
        if (socket_id >= 0)
        {
            std::cout << "NUMA node " << numa_node << " -> Socket " << socket_id << "\n";
            found_valid_mapping = true;
        }
        else
        {
            // Only show -1 for first few nodes to avoid clutter
            if (numa_node < 4)
            {
                std::cout << "NUMA node " << numa_node << " -> Not available (returned " << socket_id << ")\n";
            }
        }
    }
    
    if (!found_valid_mapping)
    {
        std::cout << "\nNo valid NUMA node mappings found.\n";
        std::cout << "This may be expected on:\n";
        std::cout << "  - Single-socket systems\n";
        std::cout << "  - Systems without NUMA support\n";
        std::cout << "  - macOS (not implemented)\n";
        std::cout << "  - Systems where NUMA information is not available\n";
    }
    
    std::cout << "\nTest PASSED\n";
    
    m->cleanup();
    return 0;
}

```

`tests/pcm-fuzz.cpp`:

```cpp
#define UNIT_TEST 1

#include "../src/pcm.cpp"

#undef UNIT_TEST


extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
{
       size_t size_int = size / sizeof(int);
       const auto ints_used = 7;
       if (size_int < ints_used)
       {
               return 0;
       }

       auto m = PCM::getInstance();
       const int *data_int = reinterpret_cast<const int *>(data);
       int pos = 0;
       int pid = data_int[pos++];
       bool use_pid = data_int[pos++] % 2;
       if (!use_pid)
       {
                pid = -1;
       }

       print_help("");

       m->resetPMU();

       m->disableJKTWorkaround();

       const PCM::ErrorCode status = m->program(PCM::DEFAULT_EVENTS, nullptr, false, pid);

       switch (status)
       {
        case PCM::Success:
                break;
        case PCM::UnknownError: // expected for invalid pid
                return 0;
        case PCM::MSRAccessDenied:
                cerr << "Access to Intel(r) Performance Counter Monitor has denied (no MSR or PCI CFG space access).\n";
                exit(EXIT_FAILURE);
        case PCM::PMUBusy:
                cerr << "Access to Intel(r) Performance Counter Monitor has denied (Performance Monitoring Unit is occupied by other application). Try to stop the application that uses PMU.\n";
                cerr << "Alternatively you can try running PCM with option -r to reset PMU.\n";
                exit(EXIT_FAILURE);
        default:
                cerr << "Access to Intel(r) Performance Counter Monitor has denied (Unknown error).\n";
                exit(EXIT_FAILURE);
        }

        print_cpu_details();

        std::vector<CoreCounterState> cstates1, cstates2;
        std::vector<SocketCounterState> sktstate1, sktstate2;
        SystemCounterState sstate1, sstate2;
        bitset<MAX_CORES> ycores;
        const auto cpu_family_model = m->getCPUFamilyModel();

        print_pid_collection_message(pid);
        bool show_partial_core_output = false; // TODO: add support for partial core output
        bool csv_output = data_int[pos++] % 2;
        int metricVersion = data_int[pos++];
        bool show_socket_output = data_int[pos++] % 2;
        bool show_system_output = data_int[pos++] % 2;
        bool show_core_output = data_int[pos++] % 2;
        assert(pos == ints_used);

        m->getAllCounterStates(sstate1, sktstate1, cstates1);
        m->getAllCounterStates(sstate2, sktstate2, cstates2);
        if (csv_output)
                print_csv(m, cstates1, cstates2, sktstate1, sktstate2, ycores, sstate1, sstate2,
                        show_core_output, show_partial_core_output, show_socket_output, show_system_output);
        else
                print_output(m, cstates1, cstates2, sktstate1, sktstate2, ycores, sstate1, sstate2,
                        cpu_family_model, show_core_output, show_partial_core_output, show_socket_output, show_system_output,
                        metricVersion);

       return 0;
}


```

`tests/pcm-memory-fuzz.cpp`:

```cpp
#define UNIT_TEST 1

#include "../src/pcm-memory.cpp"

#undef UNIT_TEST


extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
{
        size_t size_int = size / sizeof(int);
        const auto ints_used = 9;
        if (size_int < ints_used)
        {
                return 0;
        }
        print_help("");

        auto m = PCM::getInstance();
        const int *data_int = reinterpret_cast<const int *>(data);
        int pos = 0;

        bool csv = data_int[pos++] % 2;
        bool csvheader = data_int[pos++] % 2;
        bool show_channel_output = data_int[pos++] % 2;
        bool print_update = data_int[pos++] % 2;
        uint32 no_columns = DEFAULT_DISPLAY_COLUMNS; // Default number of columns is 2
        int delay = data_int[pos++] % 4;
        int rankA = data_int[pos++] % 11;
        int rankB = data_int[pos++] % 11;
        bool use_rank = data_int[pos++] % 2;
        if (!use_rank)
        {
                rankA = -1;
                rankB = -1;
        }


        ServerUncoreMemoryMetrics metrics;
        switch (data_int[pos++] % 4)
        {
        case 0:
                metrics = PartialWrites;
                break;
        case 1:
                metrics = Pmem;
                break;
        case 2:
                metrics = PmemMemoryMode;
                break;
        case 3:
                metrics = PmemMixedMode;
                break;
        }

        assert(pos == ints_used);

        m->resetPMU();
        m->disableJKTWorkaround();

        const auto cpu_family_model = m->getCPUFamilyModel();
        if (!m->hasPCICFGUncore())
        {
                cerr << "Unsupported processor model (0x" << std::hex << cpu_family_model << std::dec << ").\n";
                if (m->memoryTrafficMetricsAvailable())
                        cerr << "For processor-level memory bandwidth statistics please use 'pcm' utility\n";
                return 0;
        }
        if (anyPmem(metrics) && (m->PMMTrafficMetricsAvailable() == false))
        {
                cerr << "PMM/Pmem traffic metrics are not available on your processor.\n";
                return 0;
        }
        if (metrics == PmemMemoryMode && m->PMMMemoryModeMetricsAvailable() == false)
        {
                cerr << "PMM Memory Mode metrics are not available on your processor.\n";
                return 0;
        }
        if (metrics == PmemMixedMode && m->PMMMixedModeMetricsAvailable() == false)
        {
                cerr << "PMM Mixed Mode metrics are not available on your processor.\n";
                return 0;
        }
        if((rankA >= 0 || rankB >= 0) && anyPmem(metrics))
        {
                cerr << "PMM/Pmem traffic metrics are not available on rank level\n";
                return 0;
        }
        if((rankA >= 0 || rankB >= 0) && !show_channel_output)
        {
                cerr << "Rank level output requires channel output\n";
                return 0;
        }
        std::cerr << "programServerUncoreMemoryMetrics parameters:" << metrics << ";" << rankA << ";" << rankB << "\n";
        PCM::ErrorCode status = m->programServerUncoreMemoryMetrics(metrics, rankA, rankB);
        m->checkError(status);

        max_imc_channels = (pcm::uint32)m->getMCChannelsPerSocket();

        std::vector<ServerUncoreCounterState> BeforeState(m->getNumSockets());
        std::vector<ServerUncoreCounterState> AfterState(m->getNumSockets());
        uint64 BeforeTime = 0, AfterTime = 0;

        readState(BeforeState);
        BeforeTime = m->getTickCount();
        MySleepMs(delay);
        AfterTime = m->getTickCount();
        readState(AfterState);

        if(rankA >= 0 || rankB >= 0)
          calculate_bandwidth_rank(m,BeforeState, AfterState, AfterTime - BeforeTime, csv, csvheader, no_columns, rankA, rankB);
        else
          calculate_bandwidth(m,BeforeState,AfterState,AfterTime-BeforeTime,csv,csvheader, no_columns, metrics,
                show_channel_output, print_update, 0, true);

        return 0;
}


```

`tests/pcm-sensor-server-fuzz.cpp`:

```cpp
#include <iostream>
#include <cstring>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <cstring>
#include <netdb.h>
#include <netinet/tcp.h>

#define UNIT_TEST 1

#include "../src/pcm-sensor-server.cpp"

#undef UNIT_TEST

int port = 0;

bool waitForPort(int port, int timeoutSeconds) {
    int sockfd;
    struct sockaddr_in address;
    bool isBound = false;
    time_t startTime = time(nullptr);

    // Create a socket
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        DBG( 0, "Client: Error creating socket" );
        return false;
    }

    // Set up the address structure
    memset(&address, 0, sizeof(address));
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = inet_addr("127.0.0.1");
    address.sin_port = htons(port);

    // Loop until the port is bound or the timeout is reached
    while (!isBound && (time(nullptr) - startTime) < timeoutSeconds) {
        // Attempt to connect to the port
        if (connect(sockfd, (struct sockaddr *)&address, sizeof(address)) < 0) {
            // Connection failed, wait a bit before retrying
            sleep(1);
        } else {
            // Connection succeeded, the port is bound
            isBound = true;
        }
    }

    // Clean up the socket
    close(sockfd);
    return isBound;
}

HTTPServer * httpServer;
std::thread * serverThread;

void cleanup()
{
    DBG( 0, "Client: Stopping HTTPServer" );
    httpServer->stop();
    DBG( 0, "Client: Cleaning up PMU:" );
    PCM::getInstance()->cleanup();
}

bool init()
{
    port = (rand() % 100) + 10000; // to be able to restart the fuzzer quickly without waiting for the port to be released
    serverThread = new std::thread([]() {
        PCM::ErrorCode status;
        PCM * pcmInstance = PCM::getInstance();
        assert(pcmInstance);
        pcmInstance->resetPMU();
        status = pcmInstance->program();
        if (status != PCM::Success) {
            DBG( 0, "Client: Error in program() function" );
            exit(1);
        }
        debug::dyn_debug_level(1);
        #ifdef FUZZ_USE_SSL
        DBG( 0, "Client: Starting SSL enabled server on https://localhost:", port );
        auto httpsServer = new HTTPSServer( "", port );
        httpsServer->setPrivateKeyFile ( "/private.key" );
        httpsServer->setCertificateFile( "/certificate.crt" );
        httpsServer->initialiseSSL();
        httpServer = httpsServer;
        #else
        DBG( 0, "Client: Starting plain HTTP server on http://localhost:", port );
        httpServer = new HTTPServer( "", port );
        #endif
        // HEAD is GET without body, we will remove the body in execute()
        httpServer->registerCallback( HTTPRequestMethod::GET,  my_get_callback );
        httpServer->registerCallback( HTTPRequestMethod::HEAD, my_get_callback );
        httpServer->run();
    });
    int timeout = 60; // Timeout in seconds
    DBG( 0, "Client: Waiting for port ", port, " to be bound with timeout of ", timeout, " seconds..." );
    if (waitForPort(port, timeout)) {
            DBG( 0, "Client: Port ", port, " is now bound." );
    } else {
            DBG( 0, "Client: Port ", port, " is not bound after ", timeout, " seconds." );
            exit(1);
    }
    atexit(cleanup);
    return true;
}

std::string make_request(const std::string& request) {
#ifdef FUZZ_USE_SSL
    const SSL_METHOD* method = TLS_client_method();
    SSL_CTX* ctx = SSL_CTX_new(method);
    if (!ctx) {
        throw std::runtime_error("Unable to create SSL context");
    }
#endif
    std::string server = "127.0.0.1";
    // Resolve the host
    struct hostent* host = gethostbyname(server.c_str());
    if (!host) {
#ifdef FUZZ_USE_SSL
        SSL_CTX_free(ctx);
#endif
        DBG( 0, "Client: Failed to resolve host. Error: ", strerror(errno) );
        throw std::runtime_error("Failed to resolve host: " + server);
    }

    // Create socket
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
#ifdef FUZZ_USE_SSL
        SSL_CTX_free(ctx);
#endif
        DBG( 0, "Client: Failed to create socket. Error: ", strerror(errno) );
        throw std::runtime_error("Failed to create socket");
    }

    // Create server address structure
    struct sockaddr_in server_addr;
    std::memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    std::memcpy(&server_addr.sin_addr, host->h_addr, host->h_length);

    // Connect to server
    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        DBG( 0, "Failed to connect to server. Error: ", strerror(errno) );
        close(sock);
#ifdef FUZZ_USE_SSL
        SSL_CTX_free(ctx);
#endif
        throw std::runtime_error("Failed to connect to server");
    }

#ifdef FUZZ_USE_SSL
    // Create SSL structure
    SSL* ssl = SSL_new(ctx);
    SSL_set_fd(ssl, sock);
    int con_ret = SSL_connect(ssl);
    DBG( 1, "Client: SSL_connect returned ", con_ret );
    if ( con_ret <= 0) {
        SSL_free(ssl);
        close(sock);
        SSL_CTX_free(ctx);
        throw std::runtime_error("Failed to establish SSL connection");
    }
#endif

#ifdef FUZZ_USE_SSL
    // "Client:" is used as a hint to indicate whether client or server wrote the debug messages inside socketstream and socketbuf
    // When using this socketstream, it takes ownership of the socket and ssl connection and is responsible for properly closing 
    // connections and freeing the allocated structures, this is why all of the frees and closes are commented out below
    DBG( 0, "Client: Opening an SSL socket stream" );
    socketstream mystream( sock, ssl, "Client: " );
#else
    DBG( 0, "Client: Opening a normal socket stream" );
    socketstream mystream( sock );
#endif
    DBG( 0, "Sending request: \n", request, "\n=====" );

    std::string response;
    int bytes_received = -1;
    // Send the request
    try {
        mystream << request.c_str();
        mystream.sync();
    } catch ( const std::exception& e ) {
        DBG( 0, "Writing caused an exception: ", e.what() );
        mystream.close();
#ifdef FUZZ_USE_SSL
        SSL_CTX_free(ctx);
#endif
        throw std::runtime_error(std::string("Client Failed to write the request: ") + e.what());
    }
    // Receive the response
    HTTPResponse resp;
    DBG( 0, "Client: Waiting for response:" );
    try {
        mystream >> resp;
    } catch ( const std::exception& e ) {
        mystream.close();
#ifdef FUZZ_USE_SSL
        SSL_CTX_free(ctx);
#endif
        DBG( 0, "Reading from the socket failed, reason: ", e.what() );
        return std::string("Not necessarily fatal: Client: Exception caught while reading a response from the server: ") + e.what();
    }

    // We've got a valid HTTPResponse otherwise we'd have caught an exception above
    HTTPHeader const h = resp.getHeader( "Content-Length" );
    size_t contentLength = h.headerValueAsNumber();

    // contentLength must be positive now otherwise the bad Content-Length should have thrown an exception
    bytes_received = contentLength;

    DBG( 0, "Client: received ", bytes_received, " bytes, copying them into response." );
    // Reducing verbosity, only print the first 1024 characters of the response
    response.append( resp.body() );
    if ( response.size() > 1024 )
        response.erase(1024, std::string::npos );

    // clean up
    mystream.close();
#ifdef FUZZ_USE_SSL
    SSL_CTX_free(ctx);
#endif

    return response;
}

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
{
    static bool initialized = false;
    if (!initialized) {
        initialized = init();
    }
    try {
        std::string request = std::string((const char*)data, size);
        std::string response = make_request(request);
        DBG( 0, "Response:\n", response, "\n====" );
    } catch (const std::exception& e) {
        DBG( 0, "Client: LLVMFuzzerTestOneInput Exception: \"", e.what(), "\"" );
        exit(1);
    }
   return 0;
}

```

`tests/test.sh`:

```sh
modprobe msr

export PCM_ENFORCE_MBM="1"
export BIN_DIR="build/bin"

pushd $BIN_DIR

echo Enable NMI watchdog
echo 1 > /proc/sys/kernel/nmi_watchdog

echo Testing pcm with PCM_NO_PERF=1
PCM_NO_PERF=1 ./pcm -r -- sleep 1
if [ "$?" -ne "0" ]; then
   echo "Error in pcm"
   exit 1
fi

echo Testing pcm with PCM_USE_UNCORE_PERF=1
PCM_USE_UNCORE_PERF=1 ./pcm -r -- sleep 1
if [ "$?" -ne "0" ]; then
   echo "Error in pcm"
   exit 1
fi

echo Testing pcm with PCM_DEBUG_LEVEL=100
PCM_DEBUG_LEVEL=100 ./pcm -r -- sleep 1
if [ "$?" -ne "0" ]; then
   echo "Error in pcm"
   exit 1
fi

echo Testing pcm w/o env vars
./pcm -r -- sleep 1
if [ "$?" -ne "0" ]; then
   echo "Error in pcm"
   exit 1
fi

echo Testing pcm w/o env vars + color
./pcm -r --color -- sleep 1
if [ "$?" -ne "0" ]; then
   echo "Error in pcm"
   exit 1
fi

echo Testing pcm with -pid
perl -e ' do {} until (0)' &
test_pid="$!"
./pcm -pid $test_pid -- sleep 1
if [ "$?" -ne "0" ]; then
   echo "Error in pcm"
   kill $perl_pid
   exit 1
fi
kill $test_pid

echo Testing pcm with PCM_KEEP_NMI_WATCHDOG=1
PCM_KEEP_NMI_WATCHDOG=1 ./pcm -r -- sleep 1
if [ "$?" -ne "0" ]; then
   echo "Error in pcm"
   exit 1
fi

echo Testing pcm with -csv
./pcm -r 0.1 -csv=pcm.csv -- sleep 5
if [ "$?" -ne "0" ]; then
   echo "Error in pcm"
   exit 1
fi

echo Testing pcm-memory
./pcm-memory -- sleep 1
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-memory"
    exit 1
fi

echo Testing pcm-memory with csv output
./pcm-memory -csv=pcm-memory.csv -- sleep 1
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-memory"
    exit 1
fi

echo Testing pcm-memory with -rank
./pcm-memory -rank=1 -- sleep 1
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-memory"
    exit 1
fi

echo Testing pcm-memory with -rank and -csv
./pcm-memory -rank=1 -csv -- sleep 1
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-memory"
    exit 1
fi

echo Testing pcm-iio --list
./pcm-iio --list
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-iio"
    exit 1
fi

echo Testing pcm-iio
./pcm-iio -i=1
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-iio"
    exit 1
fi

echo Testing pcm-raw
./pcm-raw -e core/config=0x30203,name=LD_BLOCKS.STORE_FORWARD/ -e cha/config=0,name=UNC_CHA_CLOCKTICKS/ -e imc/fixed,name=DRAM_CLOCKS -e thread_msr/config=0x10,config1=1 -e thread_msr/config=0x19c,config1=0 -- sleep 1
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-raw"
    exit 1
fi

echo Testing pcm-mmio
./pcm-mmio 0x0
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-mmio"
    exit 1
fi

echo Testing pcm-pcicfg
./pcm-pcicfg 0 0 0 0 0
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-pcicfg"
    exit 1
fi

echo Testing pcm-pcicfg with -n option
./pcm-pcicfg -n 0 0 0 0 0
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-pcicfg with -n option"
    exit 1
fi

echo Testing pcm-pcicfg with -n and -d options
./pcm-pcicfg -n -d 0 0 0 0 0
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-pcicfg with -n -d options"
    exit 1
fi

echo Testing pcm-tpmi
./pcm-tpmi 2 0x10 -d -b 26:26
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-tpmi"
    exit 1
fi

echo Testing pcm-numa
./pcm-numa -- sleep 1
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-numa"
    exit 1
fi

echo Testing pcm-core
./pcm-core -e cpu/umask=0x01,event=0x0e,name=UOPS_ISSUED.STALL_CYCLES/ -- sleep 1
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-core"
    exit 1
fi

echo Testing c_example
# see https://github.com/google/sanitizers/issues/934
LD_PRELOAD="$(realpath "$(gcc -print-file-name=libasan.so)") $(realpath "$(gcc -print-file-name=libstdc++.so)")" LD_LIBRARY_PATH=../lib/ ./examples/c_example
if [ "$?" -ne "0" ]; then
    echo "Error in c_example"
    exit 1
fi

echo Testing c_example_shlib
./examples/c_example_shlib
if [ "$?" -ne "0" ]; then
    echo "Error in c_example_shlib"
    exit 1
fi

echo Testing pcm-msr \(read only\)
./pcm-msr -a 0x30A
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-msr"
    exit 1
fi

echo Testing pcm-power
./pcm-power -- sleep 1
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-power"
    exit 1
fi

echo "/sys/fs/cgroup/cpuset/cpuset.cpus:"
cat /sys/fs/cgroup/cpuset/cpuset.cpus

echo Testing pcm-pcie
./pcm-pcie -- sleep 1
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-pcie"
    exit 1
fi

echo Testing pcm-latency
./pcm-latency -i=1
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-latency"
    exit 1
fi

echo Testing pcm-tsx
./pcm-tsx -- sleep 1
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-tsx"
    exit 1
fi

# TODO add more tests
# e.g for ./pcm-sensor-server, ./pcm-sensor, ...

echo Testing urltest
./tests/urltest
# We have 14 expected errors, anything else is a bug
if [ "$?" != 14 ]; then
    echo "Error in urltest, 14 expected errors but found $?!"
    exit 1
fi

echo Testing pcm-raw with event files
echo   Download necessary files
if [ ! -f "mapfile.csv" ]; then
    echo "Downloading https://raw.githubusercontent.com/intel/perfmon/main/mapfile.csv"
    wget -q --timeout=10 https://raw.githubusercontent.com/intel/perfmon/main/mapfile.csv
    if [ "$?" -ne "0" ]; then
        echo "Could not download mapfile.csv"
        exit 1
    fi
fi

VENDOR=$(lscpu | grep "Vendor ID:" | awk '{print $3}')
FAMILY=$(lscpu | grep "CPU family:" | awk '{print $3}')
MODEL=$(lscpu | grep "Model:" | awk '{printf("%x", $2)}')
STRING="${VENDOR}-${FAMILY}-${MODEL}-"
FILES=$(grep $STRING "mapfile.csv" | awk -F "\"*,\"*" '{print $3}')
DIRS=

for FILE in $FILES
do
    DIR="$(dirname $FILE)"
    DIR="${DIR#?}"
    if [[ ! " ${DIRS[*]} " =~ " ${DIR} " ]]; then
        DIRS+="${DIR} "
    fi
done

for DIR in $DIRS
do
    if [ ! -d $DIR ]; then
        mkdir -p $DIR
        cd $DIR

        DIRPATH="https://github.com/intel/perfmon.git"
        echo "Downloading all files from ${DIRPATH} using git"

        git clone $DIRPATH
        if [ "$?" -ne "0" ]; then
            cd ..
            echo "Could not download ${DIRPATH}"
            exit 1
        fi
        mv perfmon/${DIR}/* .
        rm -rf perfmon
        cd ../..
    fi
done

echo   Now check pcm-raw with JSON files from mapFile.csv
./pcm-raw -r -e LD_BLOCKS.STORE_FORWARD -e CPU_CLK_UNHALTED.THREAD_ANY -e INST_RETIRED.ANY -e UNC_CHA_CLOCKTICKS -- sleep 1

if [ "$?" -ne "0" ]; then
    echo "Error in pcm-raw"
    exit 1
fi

echo   Now get corresponding TSV files and replace JSON files in mapFile.csv with them
cp "mapfile.csv" "mapfile.csv_orig"
for FILE in $FILES
do
    DIR="$(dirname $FILE)"
    DIR="${DIR#?}"
    cd $DIR
    BASE="$(basename $FILE)"
    TYPE="$(echo $BASE | sed 's/_v[0-9].*json//g')"
    # TYPE can be for example: skylakex_core or skylakex_uncore.
    CMD="find . -type f -regex '\.\/${TYPE}_v[0-9]*\.[0-9]*.tsv'"
    TSVFILE=$(eval $CMD)
    TSVFILE="${TSVFILE:2}"
    cd ../..
    CMD="sed -i 's/${BASE}/${TSVFILE}/g' mapfile.csv"
    eval $CMD
done


# echo Test pcm-raw with TSV files
#./pcm-raw -r -e LD_BLOCKS.STORE_FORWARD -e CPU_CLK_UNHALTED.THREAD_ANY -e INST_RETIRED.ANY -e UNC_CHA_CLOCKTICKS -- sleep 1

#if [ "$?" -ne "0" ]; then
#    echo "Error in pcm-raw"
#    rm -rf mapfile.csv
#    cp "mapfile.csv_orig" "mapfile.csv"
#    exit 1
#fi
rm -rf mapfile.csv
cp "mapfile.csv_orig" "mapfile.csv"


if [ ! -f "event_file_test.txt" ]; then
    cat <<EOF > event_file_test.txt
# group 1
INST_RETIRED.ANY
CPU_CLK_UNHALTED.REF_TSC
MEM_TRANS_RETIRED.LOAD_LATENCY_GT_4
UNC_CHA_DIR_LOOKUP.SNP
UNC_CHA_DIR_LOOKUP.NO_SNP
UNC_M_CAS_COUNT.RD
UNC_M_CAS_COUNT.WR
UNC_UPI_CLOCKTICKS
UNC_UPI_TxL_FLITS.ALL_DATA
UNC_UPI_TxL_FLITS.NON_DATA
UNC_UPI_L1_POWER_CYCLES
UNC_CHA_TOR_INSERTS.IA_MISS
MSR_EVENT:msr=0x19C:type=STATIC:scope=THREAD
MSR_EVENT:msr=0x1A2:type=STATIC:scope=THREAD
MSR_EVENT:msr=0x34:type=FREERUN:scope=PACKAGE
MSR_EVENT:msr=0x34:type=static:scope=PACKAGE
package_msr/config=0x34,config1=0
thread_msr/config=0x10,config1=1,name=TSC_DELTA
thread_msr/config=0x10,config1=0,name=TSC
pcicfg/config=0x208d,config1=0,config2=0,width=64,name=first_8_bytes_of_208d_device
pcicfg/config=0x2021,config1=0,config2=0,width=32
pcicfg/config=0x2021,config1=0,config2=0,width=64
pcicfg/config=0x2058,config1=0x318,config2=1,width=64,name=UPI_reg
;
# group 2
OFFCORE_REQUESTS_BUFFER.SQ_FULL
UNC_CHA_DIR_UPDATE.HA
UNC_CHA_DIR_UPDATE.TOR
UNC_M2M_DIRECTORY_UPDATE.ANY
UNC_M_CAS_COUNT.RD
UNC_M_CAS_COUNT.WR
imc/fixed,name=DRAM_CLOCKS
UNC_CHA_TOR_INSERTS.IA_MISS:tid=0x20
UNC_M_PRE_COUNT.PAGE_MISS
UNC_UPI_TxL0P_POWER_CYCLES
UNC_UPI_RxL0P_POWER_CYCLES
UNC_UPI_RxL_FLITS.ALL_DATA
UNC_UPI_RxL_FLITS.NON_DATA
UNC_P_FREQ_MAX_LIMIT_THERMAL_CYCLES
MSR_EVENT:msr=0x10:type=FREERUN:scope=thread
MSR_EVENT:msr=0x10:type=static:scope=thread
pcicfg/config=0x2021,config1=4,config2=0,width=32
pcicfg/config=0x208d,config1=0,config2=1,width=64,name=first_8_bytes_of_208d_device_diff
;
EOF

fi

echo Testing pcm-raw with -el event_file_test.txt -tr -csv
./pcm-raw -el event_file_test.txt -tr -csv=raw_tr_wo_ext.csv -i=4 0.25
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-raw"
    exit 1
fi

echo Testing pcm-raw with -el event_file_test.txt -tr -ext -csv
./pcm-raw -el event_file_test.txt -tr -ext -csv=raw_tr_wi_ext.csv -i=4 0.25
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-raw"
    exit 1
fi

echo Testing pcm-raw with -el event_file_test.txt -tr -ext -single-header -csv
./pcm-raw -el event_file_test.txt -tr -ext -single-header -csv=raw_tr_wi_ext_single_header.csv -i=4 0.25
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-raw"
    exit 1
fi

echo Testing pcm-raw with -json
./pcm-raw -el event_file_test.txt -json=raw_json.json -i=4 0.25
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-raw"
    exit 1
fi

echo Testing pcm-raw with -edp
./pcm-raw -edp -out raw_edp.txt 0.25 -tr -i=4 -el event_file_test.txt
if [ "$?" -ne "0" ]; then
    echo "Error in pcm-raw"
    exit 1
fi

echo Testing pcm-raw with -edp and offlined cores

online_offline_cores() {
    for i in {5..10};
    do
        echo $1 > /sys/devices/system/cpu/cpu$i/online
    done
}

online_offline_cores 0
./pcm-raw -edp -out raw_edp_offlined_cores.txt 0.25 -tr -i=4 -el event_file_test.txt
if [ "$?" -ne "0" ]; then
    online_offline_cores 1
    echo "Error in pcm-raw with offlined cores"
    exit 1
fi
online_offline_cores 1

# Below is UT part

echo "Running Unit Tests"
failed=()
for test_binary in ./tests/utests/*; do
    if [ -x "$test_binary" ]; then
        echo "Running $test_binary"
        "$test_binary"
        if [ "$?" -ne "0" ]; then
            failed+=("$test_binary")
        fi
    else
        echo "Skipping $test_binary (not executable)"
    fi
done

if [ "${#failed[@]}" -ne "0" ]; then
    echo "Failed test programs: ${failed[@]}"
    exit 1
fi

popd

```

`tests/urltest-fuzz.cpp`:

```cpp
#define UNIT_TEST 1

#include "../src/pcm-sensor-server.cpp"

#undef UNIT_TEST


extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
{
       try
       {
               std::string buf(reinterpret_cast<const char*>(data), size);
               buf.push_back('\0');
               URL x = URL::parse(buf.c_str());
       }
       catch (std::runtime_error & )
       {
               // catch recognized malformed input (thrown as runtime_error in the URL::parse)
               // do not catch any other errors or exceptions to let them be reported
               // by libFuzzer
       }

       return 0;
}


```

`tests/urltest.cpp`:

```cpp
#define UNIT_TEST 1

#include "../src/pcm-sensor-server.cpp"

#undef UNIT_TEST

std::vector<std::string> urls{
    "http://otto:test@www.intel.com/~otto/file1.txt",
    "file://localhost/c/mnt/cd/file2.txt",
    "ftp://otto%40yahoo.com:abcd%3B1234@www.intel.com:30/xyz.php?a=1&t=3",
    "gopher://otto@hostname1.intel.com:8080/file3.zyx",
    "www.intel.com",
    "http://www.blah.org/file.html#firstmark",
    "http://www.blah.org/file.html#firstmark%21%23",
    "localhost",
    "https://www.intel.com",
    "://google.com/",
    "https://intc.com/request?",
    "htt:ps//www.intel.com",
    "http://www.intel.com:66666/",
    "http:///",
    "http://[1234::1234::1234/",
    "http://@www.intel.com",
    "http://otto@:www.intel.com",
    "https://:@www.intel.com",
    "https://user:@www.intel.com",
    "http:www.intel.com/",
    "http://ww\x00\x00\x00rstmark\x0a"
};

std::vector<std::string> headers{
    "Content-Encoding text/html", // Invalid header no colon found
    "       Content-Encoding   :    text/html      ", // Valid header, should clean up the whitespace before and after
    " H o s t : my.host.com", // Valid, spaces in header name should be accepted and silenty removed
    "MyUnknownHeaderType : value", // Valid, MyUnknownHeaderType is considered a custom header type
    " Host : \"my.host.com" // Invalid, header value not properly quoted
};

int main( int, char** ) {
    // httpheader::debugPrint uses dbg(3), picking 5 for future changes
    debug::dyn_debug_level( 5 );

    int errors = 0, errors2 = 0;
    for ( auto & s : urls ) {
        try {
            std::cout << s << "\n";
            URL x = URL::parse( s );
            x.printURL(std::cout);
	} catch (const std::runtime_error & x ) {
            std::cout << "\"" << s << "\": " << x.what() << "\n";
	    ++errors;
        }
    }
    for ( auto & h : headers ) {
        std::cout << h << "\n";
        HTTPHeader hh = HTTPHeader::parse( h );
        hh.debugPrint();
        if ( hh.type() == HeaderType::Invalid )
            ++errors2;
    }
    return errors+errors2;
}

```

`tests/utests/CMakeLists.txt`:

```txt
# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2009-2025, Intel Corporation

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_TEST_BINARY_DIR}/utests)

project(pcm_utests LANGUAGES CXX)

enable_testing()

include_directories(${CMAKE_SOURCE_DIR}/src/)
include_directories("${GMOCK_DIR}/include")

if(APPLE)
    include_directories("${CMAKE_SOURCE_DIR}/src/MacMSRDriver") # target_include_directories doesn't work
endif()

file(GLOB LSPCI_TEST_FILES lspci-utest.cpp ${CMAKE_SOURCE_DIR}/src/lspci.cpp)
file(GLOB PCM_IIO_TEST_FILES pcm-iio-utest.cpp ${CMAKE_SOURCE_DIR}/src/pcm-iio-pmu.cpp ${CMAKE_SOURCE_DIR}/src/pcm-iio-topology.cpp)
file(GLOB READ_NUMBER_TEST_FILES read-number-utest.cpp)

if(APPLE)
    set(LIBS PcmMsr Threads::Threads PCM_STATIC)
else()
    set(LIBS Threads::Threads PCM_STATIC)
endif()

add_executable(lspci-utest ${LSPCI_TEST_FILES})
add_executable(pcm-iio-utest ${PCM_IIO_TEST_FILES})
add_executable(read-number-utest ${READ_NUMBER_TEST_FILES})

configure_file(
    ${CMAKE_SOURCE_DIR}/src/opCode-6-174.txt
    ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/opCode-6-174.txt
    COPYONLY
)

target_link_libraries(
    lspci-utest
    GTest::gtest_main
    GTest::gmock_main
    ${LIBS}
)

target_link_libraries(
    pcm-iio-utest
    GTest::gtest_main
    GTest::gmock_main
    ${LIBS}
)

target_link_libraries(
    read-number-utest
    GTest::gtest_main
    GTest::gmock_main
    ${LIBS}
)

include(GoogleTest)
gtest_discover_tests(lspci-utest)
gtest_discover_tests(pcm-iio-utest)
gtest_discover_tests(read-number-utest)

```

`tests/utests/lspci-utest.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2025, Intel Corporation
// written by Alexander Antonov

#include "lspci.h"
#include <gtest/gtest.h>
#include <string>

using namespace pcm;

TEST(BDFTest, ToStringDefaultConstructor)
{
    struct bdf default_bdf;
    EXPECT_EQ(default_bdf.to_string(), "0000:00:00.0");
}

TEST(BDFTest, ToStringCustomConstructor)
{
    struct bdf custom_bdf(0x1234, 0x56, 0x10, 0x7);
    EXPECT_EQ(custom_bdf.to_string(), "1234:56:10.7");
}

TEST(BDFTest, ToStringPartialConstructor)
{
    struct bdf partial_bdf(0x56, 0x10, 0x7);
    EXPECT_EQ(partial_bdf.to_string(), "0000:56:10.7");
}

```

`tests/utests/pcm-iio-utest.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2025, Intel Corporation
// written by Alexander Antonov

#include <gtest/gtest.h>
#include <string>
#include <map>
#include <vector>
#include <iostream>
#include "utils.h"
#include "pcm-iio-pmu.h"
#include "pcm-iio-topology.h"

using namespace pcm;

class LoadEventsTest : public ::testing::Test {
protected:
    void SetUp() override
    {
        fillOpcodeFieldMapForPCIeEvents(opcodeFieldMap);

        evt_ctx.ctrs.clear();
    }

    std::map<std::string, uint32_t> opcodeFieldMap;
    iio_evt_parse_context evt_ctx;
    PCIeEventNameMap nameMap;
};

// Structure to hold expected event data from file
struct ExpectedEvent {
    int ctr;
    uint32_t ev_sel;
    uint32_t umask;
    uint32_t ch_mask;
    uint32_t fc_mask;
    int multiplier;
    std::string hname;
    std::string vname;
    CounterType type;

    bool operator==(const struct iio_counter& actual) const
    {
        bool basic_match =
            ctr == actual.idx &&
            hname == actual.h_event_name &&
            vname == actual.v_event_name &&
            multiplier == actual.multiplier;

        bool ev_sel_match = (actual.ccr & 0xFF) == ev_sel;
        bool umask_match = ((actual.ccr >> 8) & 0xFF) == umask;

        bool ch_mask_match = (((actual.ccr >> 36) & 0xFFF) == ch_mask);
        bool fc_mask_match = (((actual.ccr >> 48) & 0x7) == fc_mask);

        bool counter_type_match = (actual.type == type);

        return basic_match && ev_sel_match && umask_match && ch_mask_match && fc_mask_match && counter_type_match;
    }
};

TEST_F(LoadEventsTest, TestLoadEventsAlternateVersion)
{
    const std::string eventFile = "opCode-6-174.txt";

    evt_ctx.cpu_family_model = PCM_CPU_FAMILY_MODEL(6, 174);

    ASSERT_NO_THROW({
        load_events(eventFile, opcodeFieldMap, iio_evt_parse_handler, &evt_ctx);
    });

    ASSERT_FALSE(evt_ctx.ctrs.empty()) << "No events were loaded from the file";

    // Verify at least one counter was properly initialized
    bool foundCounterWithProperConfig = false;
    for (const auto& ctr : evt_ctx.ctrs) {
        if (ctr.ccr != 0) {
            foundCounterWithProperConfig = true;
            break;
        }
    }
    EXPECT_TRUE(foundCounterWithProperConfig) << "No properly configured counters found";
}

TEST_F(LoadEventsTest, TestVerifyAllFieldsFromOpcodeFile)
{
    std::vector<ExpectedEvent> expectedEvents = {
        // IB write events
        {0, 0x83, 0x1, 1,  0x7,  4, "IB write", "Part0", CounterType::iio},
        {1, 0x83, 0x1, 2,  0x7,  4, "IB write", "Part1", CounterType::iio},
        {0, 0x83, 0x1, 4,  0x7,  4, "IB write", "Part2", CounterType::iio},
        {1, 0x83, 0x1, 8,  0x7,  4, "IB write", "Part3", CounterType::iio},
        {0, 0x83, 0x1, 16, 0x7,  4, "IB write", "Part4", CounterType::iio},
        {1, 0x83, 0x1, 32, 0x7,  4, "IB write", "Part5", CounterType::iio},
        {0, 0x83, 0x1, 64, 0x7,  4, "IB write", "Part6", CounterType::iio},
        {1, 0x83, 0x1, 128, 0x7, 4, "IB write", "Part7", CounterType::iio},

        // IB read events
        {0, 0x83, 0x4, 1,   0x7, 4, "IB read", "Part0", CounterType::iio},
        {1, 0x83, 0x4, 2,   0x7, 4, "IB read", "Part1", CounterType::iio},
        {0, 0x83, 0x4, 4,   0x7, 4, "IB read", "Part2", CounterType::iio},
        {1, 0x83, 0x4, 8,   0x7, 4, "IB read", "Part3", CounterType::iio},
        {0, 0x83, 0x4, 16,  0x7, 4, "IB read", "Part4", CounterType::iio},
        {1, 0x83, 0x4, 32,  0x7, 4, "IB read", "Part5", CounterType::iio},
        {0, 0x83, 0x4, 64,  0x7, 4, "IB read", "Part6", CounterType::iio},
        {1, 0x83, 0x4, 128, 0x7, 4, "IB read", "Part7", CounterType::iio},

        // OB read events
        {2, 0xc0, 0x4, 1,   0x7, 4, "OB read", "Part0", CounterType::iio},
        {3, 0xc0, 0x4, 2,   0x7, 4, "OB read", "Part1", CounterType::iio},
        {2, 0xc0, 0x4, 4,   0x7, 4, "OB read", "Part2", CounterType::iio},
        {3, 0xc0, 0x4, 8,   0x7, 4, "OB read", "Part3", CounterType::iio},
        {2, 0xc0, 0x4, 16,  0x7, 4, "OB read", "Part4", CounterType::iio},
        {3, 0xc0, 0x4, 32,  0x7, 4, "OB read", "Part5", CounterType::iio},
        {2, 0xc0, 0x4, 64,  0x7, 4, "OB read", "Part6", CounterType::iio},
        {3, 0xc0, 0x4, 128, 0x7, 4, "OB read", "Part7", CounterType::iio},

        // OB write events
        {2, 0xc0, 0x1, 1,   0x7, 4, "OB write", "Part0", CounterType::iio},
        {3, 0xc0, 0x1, 2,   0x7, 4, "OB write", "Part1", CounterType::iio},
        {2, 0xc0, 0x1, 4,   0x7, 4, "OB write", "Part2", CounterType::iio},
        {3, 0xc0, 0x1, 8,   0x7, 4, "OB write", "Part3", CounterType::iio},
        {2, 0xc0, 0x1, 16,  0x7, 4, "OB write", "Part4", CounterType::iio},
        {3, 0xc0, 0x1, 32,  0x7, 4, "OB write", "Part5", CounterType::iio},
        {2, 0xc0, 0x1, 64,  0x7, 4, "OB write", "Part6", CounterType::iio},
        {3, 0xc0, 0x1, 128, 0x7, 4, "OB write", "Part7", CounterType::iio},

        // IOMMU events
        {0, 0x40, 0x01, 0x0, 0x0, 1, "IOTLB Lookup",     "Total", CounterType::iio},
        {1, 0x40, 0x20, 0x0, 0x0, 1, "IOTLB Miss",       "Total", CounterType::iio},
        {2, 0x40, 0x80, 0x0, 0x0, 1, "Ctxt Cache Hit",   "Total", CounterType::iio},
        {3, 0x41, 0x10, 0x0, 0x0, 1, "256T Cache Hit",   "Total", CounterType::iio},
        {0, 0x41, 0x08, 0x0, 0x0, 1, "512G Cache Hit",   "Total", CounterType::iio},
        {1, 0x41, 0x04, 0x0, 0x0, 1, "1G Cache Hit",     "Total", CounterType::iio},
        {2, 0x41, 0x02, 0x0, 0x0, 1, "2M Cache Hit",     "Total", CounterType::iio},
        {3, 0x41, 0xc0, 0x0, 0x0, 1, "IOMMU Mem Access", "Total", CounterType::iio},
    };

    evt_ctx.cpu_family_model = PCM_CPU_FAMILY_MODEL(6, 174);

    evt_ctx.ctrs.clear();
    ASSERT_NO_THROW({
        load_events("opCode-6-174.txt", opcodeFieldMap, iio_evt_parse_handler, &evt_ctx);
    });

    ASSERT_EQ(expectedEvents.size(), evt_ctx.ctrs.size())
        << "Number of loaded events doesn't match expected count";

    std::vector<bool> foundEvents(expectedEvents.size(), false);

    // For each loaded event, find and verify the matching expected event
    for (const auto& actualEvt : evt_ctx.ctrs) {
        bool found = false;
        for (size_t i = 0; i < expectedEvents.size(); ++i) {
            if (!foundEvents[i] && expectedEvents[i] == actualEvt) {
                foundEvents[i] = true;
                found = true;

                EXPECT_EQ(expectedEvents[i].ctr, actualEvt.idx)
                    << "Counter index mismatch for " << actualEvt.h_event_name
                    << "/" << actualEvt.v_event_name;

                EXPECT_EQ(expectedEvents[i].ev_sel, (actualEvt.ccr & 0xFF))
                    << "Event select mismatch for " << actualEvt.h_event_name
                    << "/" << actualEvt.v_event_name;

                EXPECT_EQ(expectedEvents[i].umask, ((actualEvt.ccr >> 8) & 0xFF))
                    << "UMASK mismatch for " << actualEvt.h_event_name
                    << "/" << actualEvt.v_event_name;

                EXPECT_EQ(expectedEvents[i].ch_mask, ((actualEvt.ccr >> 36) & 0xFFF))
                    << "CH_MASK mismatch for " << actualEvt.h_event_name
                    << "/" << actualEvt.v_event_name;

                EXPECT_EQ(expectedEvents[i].fc_mask, ((actualEvt.ccr >> 48) & 0x7))
                    << "FC_MASK mismatch for " << actualEvt.h_event_name
                    << "/" << actualEvt.v_event_name;

                EXPECT_EQ(expectedEvents[i].multiplier, actualEvt.multiplier)
                    << "Multiplier mismatch for " << actualEvt.h_event_name
                    << "/" << actualEvt.v_event_name;

                EXPECT_EQ(expectedEvents[i].type, actualEvt.type)
                    << "Counter type mismatch for " << actualEvt.h_event_name
                    << "/" << actualEvt.v_event_name;

                break;
            }
        }
        EXPECT_TRUE(found) << "Could not find expected event for " << actualEvt.h_event_name << "/" << actualEvt.v_event_name
            << "\nActual event details:"
            << "\n  Counter index: " << actualEvt.idx
            << "\n  Event select: 0x" << std::hex << (actualEvt.ccr & 0xFF) << std::dec
            << "\n  UMASK: 0x" << std::hex << ((actualEvt.ccr >> 8) & 0xFF) << std::dec
            << "\n  CH_MASK: 0x" << std::hex << ((actualEvt.ccr >> 36) & 0xFFF) << std::dec
            << "\n  FC_MASK: 0x" << std::hex << ((actualEvt.ccr >> 48) & 0x7) << std::dec
            << "\n  CCR (full): 0x" << std::hex << actualEvt.ccr << std::dec
            << "\n  Multiplier: " << actualEvt.multiplier
            << "\n  Type: " << static_cast<int>(actualEvt.type);
    }

    // Verify all expected events were found
    for (size_t i = 0; i < foundEvents.size(); ++i) {
        EXPECT_TRUE(foundEvents[i]) << "Expected event " << expectedEvents[i].hname
                                << "/" << expectedEvents[i].vname << " was not loaded";
    }
}

class PcmIioTopologyTestBase: public ::testing::Test
{
};

TEST_F(PcmIioTopologyTestBase, DefaultTopologyTest)
{
    // Use invalid value to trigger default platform mapping
    const uint32_t model = PCM::END_OF_MODEL_LIST;
    const uint32_t sockets = 2;
    const uint32_t stacks = 12;

    const std::vector<std::string> expectedStackNames =
    {
        "Stack  0", "Stack  1", "Stack  2",
        "Stack  3", "Stack  4", "Stack  5",
        "Stack  6", "Stack  7", "Stack  8",
        "Stack  9", "Stack 10", "Stack 11"
    };

    std::vector<struct iio_stacks_on_socket> iios;
    ASSERT_TRUE(IPlatformMapping::initializeIOStacksStructure(iios, model, sockets, stacks)) << "Failed to initialize IIO stacks structure";

    ASSERT_EQ(iios.size(), sockets) << "Number of sockets mismatch";
    for (const auto &iio_on_socket : iios)
    {
        ASSERT_EQ(iio_on_socket.stacks.size(), stacks) << "Number of stacks per socket mismatch";
        for (uint32_t unit = 0; unit < stacks; unit++)
        {
            ASSERT_EQ(iio_on_socket.stacks[unit].iio_unit_id, unit) << "Stack ID mismatch";
            EXPECT_EQ(iio_on_socket.stacks[unit].stack_name, expectedStackNames[unit]) << "Stack name mismatch";
        }
    }
}

```

`tests/utests/read-number-utest.cpp`:

```cpp
// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2009-2025, Intel Corporation

#include "utils.h"
#include <gtest/gtest.h>
#include <stdexcept>

using namespace pcm;

// Test valid decimal numbers
TEST(ReadNumberTest, ValidDecimalNumbers)
{
    EXPECT_EQ(read_number("0"), 0ULL);
    EXPECT_EQ(read_number("123"), 123ULL);
    EXPECT_EQ(read_number("456789"), 456789ULL);
    EXPECT_EQ(read_number("18446744073709551615"), 18446744073709551615ULL); // max uint64
}

// Test valid hexadecimal numbers
TEST(ReadNumberTest, ValidHexadecimalNumbers)
{
    EXPECT_EQ(read_number("0x0"), 0ULL);
    EXPECT_EQ(read_number("0x10"), 16ULL);
    EXPECT_EQ(read_number("0xFF"), 255ULL);
    EXPECT_EQ(read_number("0xABCD"), 43981ULL);
    EXPECT_EQ(read_number("0xFFFFFFFFFFFFFFFF"), 18446744073709551615ULL); // max uint64
    EXPECT_EQ(read_number("0Xabcd"), 43981ULL); // capital X
}

// Test invalid inputs - should throw exceptions
TEST(ReadNumberTest, InvalidInputsThrowException)
{
    EXPECT_THROW(read_number(""), std::invalid_argument);
    EXPECT_THROW(read_number("abc"), std::invalid_argument);
    EXPECT_THROW(read_number("12abc"), std::invalid_argument);
    EXPECT_THROW(read_number("0xGHI"), std::invalid_argument);
    EXPECT_THROW(read_number("not a number"), std::invalid_argument);
    EXPECT_THROW(read_number("123.456"), std::invalid_argument);
    EXPECT_THROW(read_number("-123"), std::invalid_argument);
    EXPECT_THROW(read_number("0x"), std::invalid_argument);
    EXPECT_THROW(read_number("x123"), std::invalid_argument);
    EXPECT_THROW(read_number("  "), std::invalid_argument);
}

// Test edge cases with whitespace
TEST(ReadNumberTest, WhitespaceHandling)
{
    // Leading/trailing whitespace should be acceptable
    EXPECT_EQ(read_number(" 123"), 123ULL);
    EXPECT_EQ(read_number("123 "), 123ULL);
    EXPECT_EQ(read_number(" 123 "), 123ULL);
    EXPECT_EQ(read_number(" 0x10 "), 16ULL);
}

// Test numbers with extra characters should throw
TEST(ReadNumberTest, ExtraCharactersThrowException)
{
    EXPECT_THROW(read_number("123abc"), std::invalid_argument);
    EXPECT_THROW(read_number("0x10ZZ"), std::invalid_argument);
    EXPECT_THROW(read_number("12 34"), std::invalid_argument);
}

```