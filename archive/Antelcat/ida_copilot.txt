Project Path: arc_Antelcat_ida_copilot_gx2mktdn

Source Tree:

```txt
arc_Antelcat_ida_copilot_gx2mktdn
â”œâ”€â”€ LICENSE
â”œâ”€â”€ ida_copilot
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ copilot.py
â”‚   â”œâ”€â”€ core.py
â”‚   â”œâ”€â”€ panel.py
â”‚   â””â”€â”€ prompts.py
â”œâ”€â”€ ida_copilot.py
â”œâ”€â”€ img
â”‚   â””â”€â”€ Preview.gif
â”œâ”€â”€ readme.md
â”œâ”€â”€ readme_cn.md
â””â”€â”€ requirements.txt

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Antelcat

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`ida_copilot.py`:

```py
import ida_hexrays
import ida_kernwin
import idaapi

from ida_copilot import panel
from ida_copilot.copilot import Copilot


class CopilotPluginActionHandler(idaapi.action_handler_t):
    def __init__(self):
        super(CopilotPluginActionHandler, self).__init__()

    def activate(self, ctx):
        ida_kernwin.show_wait_box('HIDECANCEL\nRunning Copilot...')
        try:
            Copilot().run()
        finally:
            ida_kernwin.hide_wait_box()
            ida_hexrays.get_widget_vdui(ctx.widget).refresh_view(True)
            ida_kernwin.refresh_idaview_anyway()


    def on_task_complete(self, future):
        # å…³é—­è¿›åº¦æ¡æˆ–çŠ¶æ€ä¿¡æ¯
        ida_kernwin.hide_wait_box()

        # æ›´æ–°UI...
        ida_kernwin.refresh_idaview_anyway()

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class CopilotPlugin(idaapi.plugin_t):
    flags = idaapi.PLUGIN_UNL
    comment = "Copilot"
    help = "Copilot"
    wanted_name = "Copilot"
    wanted_hotkey = ""

    def init(self):
        if not ida_hexrays.init_hexrays_plugin():
            print("Hex-Rays decompiler is not available!")
            return

        run_action = idaapi.action_desc_t(
            'copilot:run',
            'Run Copilot',
            CopilotPluginActionHandler(),
            'Ctrl+Shift+P',
            'ä½¿ç”¨Copilotåˆ†æå½“å‰å‡½æ•°',
            -1)
        idaapi.register_action(run_action)
        idaapi.attach_action_to_menu(
            'Edit/Copilot',
            'copilot:run',
            idaapi.SETMENU_APP)

        action_desc = idaapi.action_desc_t(
            'copilot:show_panel',
            'Show Copilot',
            panel.ShowCopilotPanel(panel.CopilotPanel()),
            None,
            'Copilot integration',
            0
        )
        idaapi.register_action(action_desc)

        # æ·»åŠ èœå•é¡¹
        idaapi.attach_action_to_menu(
            'Windows/Copilot',
            'copilot:show_panel',
            idaapi.SETMENU_APP)

        return idaapi.PLUGIN_KEEP

    def run(self, arg):
        idaapi.require('ida_copilot')
        print('Copilot reloaded')

    def term(self):
        idaapi.detach_action_from_menu(
            'Edit/Copilot',
            'copilot:run')
        idaapi.unregister_action('copilot:run')

        idaapi.detach_action_from_menu(
            'Windows/Copilot',
            'copilot:show_panel')
        idaapi.unregister_action('copilot:show_panel')


def PLUGIN_ENTRY():
    return CopilotPlugin()

```

`ida_copilot/copilot.py`:

```py
import asyncio
import concurrent.futures
import re
from typing import Any, Optional

from langchain.agents import tool, initialize_agent, AgentType
from langchain.callbacks import FileCallbackHandler
from langchain.callbacks.base import BaseCallbackManager
from langchain.callbacks.manager import CallbackManagerForToolRun
from langchain.chat_models import ChatOpenAI

import idaapi
from langchain.tools import BaseTool

from ida_copilot import core, prompts


class Copilot:
    def run(self, temperature=0.2, model='gpt-3.5-turbo-0613'):
        ea = idaapi.get_screen_ea()
        func_name = idaapi.get_func_name(ea)

        tools = [
            self.__GetAddressInfoTool(),
            self.__GetDefinitionTool(),
            self.__GetPseudocodeTool(),
            self.__SetFunctionCommentTool(),
            self.__SetFunctionDefinitionTool(),
            self.__SetFunctionNameTool(),
            self.__GetIsMyWorkDoneTool(ea)
        ]

        agent = initialize_agent(
            agent_type=AgentType.OPENAI_MULTI_FUNCTIONS,
            llm=ChatOpenAI(temperature=temperature, model=model),
            tools=tools,
            # callback_manager=BaseCallbackManager(handlers=[
            #     CopilotPanelCallbackManager()]),
            verbose=True,
        )

        prompt = prompts.default_prompt_zh.format(
            binary_description=f'name: {func_name}, address 0x{ea:x}'
            # pseudocode=pseudocode
        )

        # å¼€å¯æ–°çº¿ç¨‹è¿è¡Œagent
        t = concurrent.futures.ThreadPoolExecutor()
        loop = asyncio.get_event_loop()
        loop.run_in_executor(t, agent.run, prompt)

    class __GetAddressInfoTool(BaseTool):
        name = 'get_address_info'
        description = ('Given a hex address or function name, show its information. '
                       '**Input Format**: `<hex_address_or_function_name>`. '
                       '**Input Example1**: `sub_140007080`. '
                       '**Input Example2**: `0x140007080`.')

        @staticmethod
        def __get_address_info(name_or_hex_address: str):
            try:
                if name_or_hex_address.lower().startswith('0x'):
                    ea = int(name_or_hex_address, 16)
                else:
                    ea = idaapi.get_name_ea(idaapi.BADADDR, name_or_hex_address)
                    if ea == idaapi.BADADDR:
                        raise Exception
            except Exception:
                return f'{name_or_hex_address} is not a valid address or name.'

            flags = idaapi.get_flags(ea)
            result = ''

            # æ£€æŸ¥åœ°å€æ˜¯å¦ä½äºå‡½æ•°å†…éƒ¨
            func = idaapi.get_func(ea)
            if func:
                result += "Address 0x%X is inside a function.\n" % ea
                result += "Function start: 0x%X\n" % func.start_ea
                result += "Function end: 0x%X\n" % func.end_ea
                func_name = idaapi.get_func_name(func.start_ea)
                if func_name:
                    result += "Function name: %s\n" % func_name
            elif idaapi.is_code(flags):
                result += "Address 0x%X is code.\n" % ea
            elif idaapi.is_data(flags):
                result += "Address 0x%X is data.\n" % ea
                if idaapi.is_byte(flags):
                    result += "Data type: Byte\n"
                    result += "Value: %d\n" % idaapi.get_wide_byte(ea)
                elif idaapi.is_word(flags):
                    result += "Data type: Word\n"
                    result += "Value: %d\n" % idaapi.get_wide_word(ea)
                elif idaapi.is_dword(flags):
                    result += "Data type: Dword\n"
                    result += "Value: %d\n" % idaapi.get_wide_dword(ea)
                elif idaapi.is_qword(flags):
                    result += "Data type: Qword\n"
                    result += "Value: %d\n" % idaapi.get_qword(ea)
                elif idaapi.is_float(flags):
                    result += "Data type: Float\n"
                    # result += "Value: %f\n" % idaapi.get_wide_float(address)
                elif idaapi.is_double(flags):
                    result += "Data type: Double\n"
                    # result += "Value: %f\n" % idaapi.get_wide_double(address)
                elif idaapi.is_strlit(flags):
                    result += "Data type: String\n"
                    result += "Value: %s\n" % idaapi.get_strlit_contents(ea)
                elif idaapi.is_struct(flags):
                    result += "Data type: Struct\n"
                # ... å…¶ä»–æ•°æ®ç±»å‹æ£€æŸ¥
            elif idaapi.is_unknown(flags):
                result += "Address 0x%X is unknown.\n" % ea

            # åç§°å’Œæ³¨é‡Š
            if idaapi.has_name(flags):
                result += "Name: %s\n" % idaapi.get_name(ea)
            elif idaapi.has_dummy_name(flags):
                result += "Dummy name: %s\n" % idaapi.get_name(ea)

            if idaapi.has_cmt(flags):
                result += "Comment: %s\n" % idaapi.get_cmt(ea, 0)

            if result == '':
                result = 'Address not found.'
            elif result[-1] == '\n':
                result = result[:-1]

            return result

        def _run(self, query: str, run_manager: Optional[CallbackManagerForToolRun] = None) -> Any:
            query = core.escape_agent_input(
                query, 'get_address_info')

            return core.pop_async_call_result(
                idaapi.execute_sync(
                    lambda: core.push_async_call_result(self.__get_address_info(query)),
                    idaapi.MFF_WRITE))

    class __GetDefinitionTool(BaseTool):
        name = 'get_definition'
        description = ('Given a function name, show its definition. '
                       'NOTICE that the result is decompiled by IDA, so it may NOT be accurate. '
                       '**Input Format**: `<function_name>`. '
                       '**Input Example**: `sub_140007080`.')

        @staticmethod
        def __get_definition(function_name: str):
            try:
                return core.decompile_by_name(function_name).definition
            except Exception as e:
                return f'Failed to decompile: {e}'
            
        def _run(self, query: str, run_manager: Optional[CallbackManagerForToolRun] = None) -> Any:
            query = core.escape_agent_input(query, 'get_definition')

            return core.pop_async_call_result(
                idaapi.execute_sync(
                    lambda: core.push_async_call_result(self.__get_definition(query)), 
                    idaapi.MFF_WRITE))

    class __GetPseudocodeTool(BaseTool):
        name = 'get_pseudocode'
        description = ('Given a function name or hex address of a function, show its pseudocode. '
                       'NOTICE that the result is decompiled by IDA, so it may NOT be accurate. '
                       '**Input Format**: `<function_name_or_hex_address>`. '
                       '**Input Example1**: `sub_140007080`. '
                       '**Input Example2**: `0x140007080`.')

        @staticmethod
        def __get_pseudocode(function_name_or_hex_address: str):
            try:
                if function_name_or_hex_address.lower().startswith('0x'):
                    ea = int(function_name_or_hex_address, 16)
                    return core.decompile_by_ea(ea).pseudocode

                return core.decompile_by_name(function_name_or_hex_address).pseudocode
            except Exception as e:
                return f'Failed to decompile: {e}'

        def _run(self, query: str, run_manager: Optional[CallbackManagerForToolRun] = None) -> Any:
            query = core.escape_agent_input(
                query, 'get_pseudocode')

            return core.pop_async_call_result(
                idaapi.execute_sync(
                    lambda: core.push_async_call_result(self.__get_pseudocode(query)),
                    idaapi.MFF_WRITE))

    class __SetFunctionCommentTool(BaseTool):
        name = 'set_function_comment'
        description = ('Given a function name and a comment, set the comment of the function. '
                       '**Input Format**: `<function_name> <comment>`. '
                       '**Input Example**: `sub_140007080 Copilot Comment: This function is used to do something.`')

        @staticmethod
        def __set_function_comment(function_name_and_comment: str):
            try:
                func_name, comment = function_name_and_comment.split(' ', 1)
                func_name = func_name.strip()

                if not comment.startswith('Copilot Comment:'):
                    comment = 'Copilot Comment: ' + comment.strip()
                core.decompile_by_name(func_name).comment = comment

                return f'Successfully set comment of {func_name} to {comment}.'
            except Exception as e:
                return f'Failed to set comment: {e}'

        def _run(self, query: str, run_manager: Optional[CallbackManagerForToolRun] = None) -> Any:
            query = core.escape_agent_input(
                query, 'set_function_comment')

            return core.pop_async_call_result(
                idaapi.execute_sync(
                    lambda: core.push_async_call_result(self.__set_function_comment(query)),
                    idaapi.MFF_WRITE))

    class __SetFunctionDefinitionTool(BaseTool):
        name = 'set_function_definition'
        description = ('Set definition of a function. '
                       '**Input Format**: `<return_type> [calling_convention] <function_name>(<param_type> [param_name], ...)`. '
                       '**Input Example1**: `void sub_140005048(int a1, unsigned long long a2)`. '
                       '**Input Example2**: `NTSTATUS __fastcall DriverIoControl(PDRIVER_OBJECT, PIRP)`.')

        @staticmethod
        def __set_function_definition(new_definition: str):
            func_pattern = re.compile(
                r'(?P<ret_type>[\w\s*]+?)\s*(?P<cc>__\w+\s+)?(?P<func_name>\w+)\((?P<params>.*)\)')
            # param_pattern = re.compile(r'(\w+\s*\*?)\s*(\w+)')

            try:
                match = func_pattern.match(new_definition)
                if not match:
                    return f'Invalid function definition, not match: {new_definition}'

                result = match.groupdict()
                return_type = result['ret_type'].strip() if result['ret_type'] else None
                if not return_type:
                    return f'Invalid function definition, no return type: {new_definition}'

                # ä¸Šé¢çš„æ­£åˆ™ä¼šæ¼æ‰ä¸€ç§æƒ…å†µ
                # ä¾‹å¦‚ï¼Œ`NTSTATUSsub_140005048(PDRIVER_OBJECT driverObject, PIRP irp)`
                # è§£æåï¼Œ`ret_type`ä¸º`N`ï¼Œ`func_name`ä¸º`TSTATUSsub_140005048`
                # å› æ­¤æˆ‘ä»¬è¦æŠŠè¿™ç§è¾“å…¥åˆ—ä¸ºæ— æ•ˆè¾“å…¥
                if ' ' not in new_definition[:new_definition.index('(')]:
                    return f'Invalid function definition, no func name: {new_definition}'

                func_name = result['func_name'].strip()
                core.decompile_by_name(func_name).definition = new_definition

                return f'Successfully set definition of {func_name} to {new_definition}.'
            except Exception as e:
                return f'Failed to set definition: {e}'

        def _run(self, query: str, run_manager: Optional[CallbackManagerForToolRun] = None) -> Any:
            query = core.escape_agent_input(
                query, 'set_function_definition')

            return core.pop_async_call_result(
                idaapi.execute_sync(
                    lambda: core.push_async_call_result(self.__set_function_definition(query)),
                    idaapi.MFF_WRITE))

    class __SetFunctionNameTool(BaseTool):
        name = 'set_function_name'
        description = ('Given a function name, rename it. '
                       '**Input Format**: <old_name> <new_name>. '
                       '**Input Example**: sub_140007080 DeviceIoControl.')

        @staticmethod
        def __set_function_name(old_name_and_new_name: str):
            try:
                old_name, new_name = old_name_and_new_name.split(' ')
                old_name = old_name.strip()
                core.decompile_by_name(old_name).name = new_name

                return f'Successfully renamed {old_name} to {new_name}.'
            except Exception as e:
                return f'Failed to set function name: {e}'

        def _run(self, query: str, run_manager: Optional[CallbackManagerForToolRun] = None) -> Any:
            return core.pop_async_call_result(
                idaapi.execute_sync(
                    lambda: core.push_async_call_result(self.__set_function_name(query)),
                    idaapi.MFF_WRITE))

    class __GetIsMyWorkDoneTool(BaseTool):
        name = 'get_is_my_work_done'
        description = ('Given a function name, return whether the work is done. '
                       'Also return tips if not done.')
        func: Optional[core.DecompiledFunction] = None

        def __init__(self, current_func_ea, **kwargs: Any):
            super().__init__(**kwargs)
            self.func = core.decompile_by_ea(current_func_ea)

        def __get_is_my_work_done(self):
            try:
                for function in self.func.functions:
                    ea = function['ea']
                    func_name = idaapi.get_func_name(ea)
                    if func_name.startswith('sub_'):
                        return (f'No, function `{func_name}` at 0x{ea:x} is not renamed yet. Please continue your work.'
                                f'REMEMBER, your goal is to rename all functions that start with `sub_`.'
                                f'AND, your are analyzing function `{self.func.name}`.')

                return f'Yes, function `{self.func.name}` is fully analyzed.'

            except Exception as e:
                return f'Failed to get is my work done: {e}'

        def _run(self, query: str, run_manager: Optional[CallbackManagerForToolRun] = None) -> Any:
            return core.pop_async_call_result(
                idaapi.execute_sync(
                    lambda: core.push_async_call_result(self.__get_is_my_work_done()),
                    idaapi.MFF_WRITE))

```

`ida_copilot/core.py`:

```py
import re

import ida_kernwin
import idautils
from fuzzywuzzy import process
from loguru import logger

import ida_hexrays
import idaapi

async_call_index = 0
async_call_stack = {}


def push_async_call_result(result):
    global async_call_index
    global async_call_stack

    async_call_stack[async_call_index] = result
    async_call_index += 1
    return async_call_index - 1


def pop_async_call_result(index):
    return async_call_stack.pop(index)


def preprocess_prompt(template: str) -> str:
    return re.sub(r'^[ \t]+', '', template, flags=re.MULTILINE).strip('\n')


def escape_agent_input(query: str, tool_name: str) -> str:
    """
    æœ‰æ—¶å€™Agentä¼šé”™è¯¯åœ°åœ¨è¾“å…¥ä¸­åŒ…æ‹¬å·¥å…·å
    æ¯”å¦‚åº”è¯¥è¾“å…¥`sub_140009000`ï¼Œä½†æ˜¯Agentä¼šè¾“å…¥`tool_name('sub_140009000')`
    """
    logger.info(f'Escaping agent input: `{query}`')

    try:
        pattern = re.compile(rf'^{tool_name}\([\'"`](.+)[\'"`]\)$')
        match = pattern.match(query)
        if match:
            logger.info(f'Escaped agent input: `{query}` -> `{match.group(1)}`')
            return match.group(1)

        return query
    except Exception as e:
        logger.error(f'Failed to escape agent input: `{query}`')
        raise e


def get_screen_func():
    return idaapi.get_func(idaapi.get_screen_ea())


def get_safe_new_name(new_func_name: str) -> str:
    """
    æ£€æŸ¥new_func_nameæ˜¯å¦å·²å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨ï¼Œé€’å¢å¤„ç†
    :param new_func_name:
    :return:
    """
    if new_func_name[0].isdigit():
        new_func_name = 'fun_' + new_func_name

    existed_ea = idaapi.get_name_ea(idaapi.BADADDR, new_func_name)
    if existed_ea == idaapi.BADADDR:
        return new_func_name

    # å¦‚æœnew_func_nameæœ€åæœ‰æ•°å­—ï¼Œé€’å¢å¤„ç†
    match = re.match(r'^(.*?)(\d+)$', new_func_name)
    if match:
        prefix, suffix = match.groups()
        suffix = int(suffix)
    else:
        prefix = new_func_name
        suffix = 1

    while True:
        new_func_name = f'{prefix}{suffix}'
        existed_ea = idaapi.get_name_ea(idaapi.BADADDR, new_func_name)
        if existed_ea == idaapi.BADADDR:
            break
        suffix += 1

    return new_func_name


# ç”¨äºè®°å½•ä¿®æ”¹è¿‡çš„å‡½æ•°
# Copilotåœ¨ä¸€æ¬¡åˆ†æçš„è¿‡ç¨‹ä¸­å¹¶ä¸ä¼šä¿®æ”¹å‡½æ•°ï¼Œè€Œæ˜¯è®°å½•ä¸‹ä¿®æ”¹çš„å†…å®¹ï¼Œæœ€åä¸€æ¬¡æ€§ä¿®æ”¹ã€‚
# key: ea
# value: DecompiledFunction
decompiled_functions = dict()

renamed_functions = dict()
"""
è®°å½•é‡å‘½åè¿‡çš„å‡½æ•°
æœ‰æ—¶å€™Copilotå·²ç»æŠŠä¸€ä¸ªå‡½æ•°é‡å‘½åè¿‡äº†ï¼Œä½†æ˜¯Copilotåœ¨ä¹‹åå¯èƒ½è¿˜ä½¿ç”¨äº†æ—§çš„å‡½æ•°åï¼Œè¿™æ—¶å€™è¿˜éœ€è¦èƒ½æ‰¾åˆ°æ–°çš„å‡½æ•°åã€‚
WARNï¼šåªè®°å½•ä¸€æ¬¡é‡å‘½åã€‚ä¾‹å¦‚a -> bï¼Œé‚£ä¹ˆç°åœ¨æ ¹æ®aè¿˜èƒ½æ‰¾åˆ°bã€‚ä½†å¦‚æœåˆæŠŠc -> aï¼Œæ­¤æ—¶éœ€è¦æŠŠa -> båˆ é™¤ã€‚
key: old_name
value: new_name
"""


class DecompiledFunction:
    __cfunc: ida_hexrays.cfuncptr_t  # åç¼–è¯‘å¾—åˆ°çš„å‡½æ•°

    def __init__(self, cfunc: ida_hexrays.cfuncptr_t):
        self.__cfunc = cfunc
        self.__refresh()

    def __hash__(self):
        return self.ea

    def __str__(self):
        return self.pseudocode

    def __refresh(self):
        self.__cfunc = idaapi.decompile(idaapi.get_func(self.ea), flags=ida_hexrays.DECOMP_NO_CACHE)
        self.__fix_func_types()
        self.__clean_up_local_variables()

        vdui = ida_hexrays.get_widget_vdui(ida_kernwin.get_current_viewer())
        if vdui:
            vdui.refresh_view(True)

    @property
    def ea(self) -> int:
        """å‡½æ•°åœ°å€"""
        return self.__cfunc.entry_ea

    @property
    def comment(self) -> str:
        """å‡½æ•°æ³¨é‡Šï¼Œä¾‹å¦‚`Copilot Comment: è¿™æ˜¯ä¸€ä¸ªå‡½æ•°`"""
        return idaapi.get_func_cmt(self.ea, True)

    @comment.setter
    def comment(self, new_comment: str):
        """è®¾ç½®å‡½æ•°æ³¨é‡Š"""
        idaapi.set_func_cmt(idaapi.get_func(self.ea), new_comment.strip(), True)
        self.__refresh()

    @property
    def name(self) -> str:
        """å‡½æ•°åï¼Œä¾‹å¦‚`sub_140009000`"""
        return idaapi.get_func_name(self.ea)

    @name.setter
    def name(self, new_name: str):
        """è®¾ç½®å‡½æ•°å"""
        new_name = new_name.strip()
        if new_name == self.name:
            raise Exception(f'`{new_name}` is same as current name')

        if new_name.startswith('sub_'):
            raise Exception(f'Function name should not start with `sub_`, which is a preserved name by IDA: `{new_name}`')

        old_name = self.name

        new_name = get_safe_new_name(new_name)
        idaapi.set_name(self.ea, new_name, idaapi.SN_CHECK)
        self.__refresh()

        renamed_functions.pop(new_name, None)
        renamed_functions[old_name] = new_name

    @property
    def definition(self) -> str:
        """å‡½æ•°ç­¾åï¼Œä¾‹å¦‚`__int64 __fastcall sub_140009000(__int64 a1, IRP *a2)`"""
        func_type = idaapi.tinfo_t()
        self.__cfunc.get_func_type(func_type)
        signature = str(func_type)  # signatureä¸å¸¦å‡½æ•°åï¼Œéœ€è¦åŠ ä¸Š
        signature = signature.replace('(', f' {self.name}(', 1).replace('  ', ' ')
        return signature

    @definition.setter
    def definition(self, new_signature: str):
        tinfo = idaapi.tinfo_t()
        idaapi.parse_decl(tinfo, None, new_signature + ';', idaapi.PT_TYP)
        if str(tinfo) == '':
            raise Exception(f'Invalid function definition, parse failed: `{new_signature}`')

        func_data = idaapi.func_type_data_t()
        if not tinfo.get_func_details(func_data):
            raise Exception(f'Invalid function definition: `{new_signature}`')

        original_tinfo = idaapi.tinfo_t()
        idaapi.get_tinfo(original_tinfo, self.ea)
        if str(original_tinfo) != '':
            original_func_details = idaapi.func_type_data_t()
            if original_tinfo.get_func_details(original_func_details):
                func_data.flags = original_func_details.flags

        tinfo.create_func(func_data)
        if str(tinfo) == '':
            raise Exception(f'Invalid function definition, create function type failed: {new_signature}')

        idaapi.apply_tinfo(self.ea, tinfo, idaapi.TINFO_DEFINITE)
        self.__refresh()

    @property
    def pseudocode(self) -> str:
        """åç¼–è¯‘å¾—åˆ°çš„ä¼ªä»£ç """
        return str(self.__cfunc)

    def __fix_func_types(self):
        """
        Fix the types of the function decompiled by IDA.
        æ ¹æ®å½“å‰åç¼–è¯‘çš„å‡½æ•°è°ƒç”¨å‚æ•°ç±»å‹ä¿®å¤ç›®æ ‡å‡½æ•°ç­¾åã€‚
        """
        logger.info(f'Fixing function types...{self.__cfunc.entry_ea:x}')

        called_functions = self.functions
        for func_info in called_functions:
            args = func_info['args']
            if len(args) == 0:
                continue  # Skip functions without arguments

            tinfo = func_info['tinfo']
            if str(tinfo) == '':
                continue  # Skip functions without signature

            ea = func_info['ea']

            # ä¿®å¤å‡½æ•°ç­¾å
            # ä¾‹å¦‚ï¼ŒIDAæ¨æ–­çš„å‡½æ•°ä¸º`__int64 __fastcall sub_140009000()`ï¼Œ
            # ä½†æ˜¯åœ¨åç¼–è¯‘ä¸­ï¼Œä»–è¢«è¿™æ ·è°ƒç”¨ï¼š
            # NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
            # {
            #   sub_1400090BC();
            #   return sub_140009000(DriverObject);
            # }
            # è¿™é‡Œçš„`sub_140009000`åº”è¯¥æ˜¯`NTSTATUS __stdcall sub_140009000(PDRIVER_OBJECT DriverObject)`ï¼Œ
            # å› æ­¤æˆ‘ä»¬éœ€è¦ä¿®å¤å‡½æ•°ç­¾åã€‚

            func_details = idaapi.func_type_data_t()
            if not tinfo.get_func_details(func_details):
                print(f'Failed to get function details of {ea:x}')
                continue

            new_func_details = idaapi.func_type_data_t()
            new_func_details.rettype = func_details.rettype
            new_func_details.cc = func_details.cc
            new_func_details.flags = func_details.flags

            for arg in args:
                func_arg = idaapi.funcarg_t()
                func_arg.type = arg.formal_type
                new_func_details.push_back(func_arg)

            new_tinfo = idaapi.tinfo_t()
            new_tinfo.create_func(new_func_details)
            logger.info(f'Fixing function type of 0x{ea:x}: {tinfo} -> {new_tinfo}')

            idaapi.apply_tinfo(ea, new_tinfo, idaapi.TINFO_DEFINITE)

    @staticmethod
    def __type_to_var_name(tinfo: idaapi.tinfo_t):
        """
        å°†ç±»å‹ä¿¡æ¯è½¬æ¢ä¸ºå˜é‡åï¼ˆå°å†™ä¸‹åˆ’çº¿å‘½åæ³•ï¼‰
        """
        name = tinfo.dstr()
        parts = re.findall(r'[a-zA-Z0-9]+', name)

        if parts[0] == 'struct':
            parts = parts[1:]

        if len(parts) == 0:
            return 'v'

        name = '_'.join(parts).lower()
        if not name[0].isalpha():
            name = "v_" + name
        return name

    class __FunctionCallCollector(ida_hexrays.ctree_visitor_t):
        def __init__(self):
            ida_hexrays.ctree_visitor_t.__init__(self, ida_hexrays.CV_FAST)
            self.called_functions = []

        def visit_expr(self, e):
            if e.op == idaapi.cot_call:
                func_ea = e.x.obj_ea
                if func_ea != idaapi.BADADDR:
                    tinfo = idaapi.tinfo_t()
                    func_info = {'ea': func_ea, 'tinfo': tinfo, 'args': e.a}

                    if not idaapi.get_tinfo(tinfo, func_ea) and not idaapi.guess_tinfo(tinfo, func_ea):
                        # IDAæ— æ³•æ¨æ–­å‡½æ•°ç­¾åï¼Œéœ€è¦é€šè¿‡åç¼–è¯‘è·å–
                        func = idaapi.decompile(idaapi.get_func(func_ea), flags=ida_hexrays.DECOMP_NO_CACHE)
                        func.get_func_type(tinfo)

                    self.called_functions.append(func_info)

            return 0  # Continue traversal

    @property
    def functions(self) -> list[dict]:
        """
        Get all called functions in the decompiled function.
        :return: [{'ea': func_ea, 'tinfo': tinfo, 'args': e.a}]
        """
        collector = DecompiledFunction.__FunctionCallCollector()
        collector.apply_to(self.__cfunc.body, None)
        return collector.called_functions

    def __clean_up_local_variables(self):
        """
        Clean up local variables in the decompiled function.
        æ¸…ç†åç¼–è¯‘å‡½æ•°ä¸­çš„å±€éƒ¨å˜é‡ã€‚
        åŒ…å«å‡½æ•°å‚æ•°ä¸­çš„å˜é‡ï¼Œä»¥åŠå‡½æ•°å†…éƒ¨çš„å±€éƒ¨å˜é‡ã€‚
        æ¸…ç†å‰ï¼š
        __int64 __fastcall sub_140007090(__int64 a1, IRP *a2)
        {
          __int64 v2; // r14
          unsigned int v3; // ebx
          struct _IO_STACK_LOCATION *v5; // rcx
          struct _IRP *v6; // rsi
          unsigned int v7; // edi
          ULONG_PTR v8; // r15
          unsigned int v9; // eax
          HANDLE v10; // rax
          HANDLE v11; // rax

        æ¸…ç†åï¼š
        __int64 __fastcall sub_140007090(__int64 a1, IRP *irp)
        {
          __int64 v2; // r14
            unsigned int v3; // ebx
            struct _IO_STACK_LOCATION *io_stack_location0; // rcx
            struct _IRP *irp0; // rsi
            unsigned int v7; // edi
            ULONG_PTR v8; // r15
            unsigned int v9; // eax
            HANDLE handle0; // rax
            HANDLE handle1; // rax
        """
        lvars = self.__cfunc.get_lvars()
        var_mapping = {}
        used_names = set()

        for lvar in lvars:
            tinfo = lvar.type()
            base_name = DecompiledFunction.__type_to_var_name(tinfo)
            new_name = base_name
            suffix = 1
            while new_name in used_names:
                new_name = f"{base_name}_{suffix}"
                suffix += 1
            used_names.add(new_name)
            lvar.__name = new_name
            var_mapping[lvar.__name] = new_name

        # Update the cfunc
        self.__cfunc.build_c_tree()


def decompile_by_ea(ea: int) -> DecompiledFunction:
    decompiled_function = decompiled_functions.get(ea)
    if not decompiled_function:
        func = idaapi.get_func(ea)
        if not func:
            raise Exception(f'0x{ea:x} is not a function.')

        cfunc = idaapi.decompile(func, flags=ida_hexrays.DECOMP_NO_CACHE)
        decompiled_function = decompiled_functions[ea] = DecompiledFunction(cfunc)

    return decompiled_function


def decompile_by_name(name: str) -> DecompiledFunction:
    name = name.strip()
    functions = {idaapi.get_func_name(ea).strip(): ea for ea in idautils.Functions()}
    best_match = process.extractOne(name, functions.keys(), score_cutoff=50)
    if best_match:
        if best_match[0] == name:
            return decompile_by_ea(functions[best_match[0]])

        raise Exception(f'Function `{name}` not found. Did you mean `{best_match[0]}`?')

    renamed_name = renamed_functions.get(name)
    if renamed_name:
        ea = functions.get(renamed_name)
        if ea:
            return decompile_by_ea(ea)

    raise Exception(f'Function `{name}` not found.')

```

`ida_copilot/panel.py`:

```py
from typing import Optional

import idaapi
from PyQt5 import QtWidgets
from langchain.callbacks.base import BaseCallbackHandler


class Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            instance = super(Singleton, cls).__call__(*args, **kwargs)
            cls._instances[cls] = instance
        return cls._instances[cls]


class CopilotPanel(idaapi.PluginForm, metaclass=Singleton):
    def __init__(self):
        super().__init__()
        self.parent = None
        self.text_edit: Optional[QtWidgets.QTextEdit] = None

    def OnCreate(self, form):
        self.parent = self.FormToPyQtWidget(form)
        layout = QtWidgets.QVBoxLayout(self.parent)

        self.text_edit = QtWidgets.QTextEdit()
        layout.addWidget(self.text_edit)

    def OnClose(self, form):
        pass

    def Show(self, **kwargs):
        return idaapi.PluginForm.Show(self, "IDA Copilot", options=idaapi.PluginForm.WOPN_PERSIST)


class CopilotPanelCallbackManager(BaseCallbackHandler):
    def on_text(self, text: str, **kwargs):
        panel = CopilotPanel()
        if panel.text_edit:
            panel.text_edit.append(text)


class ShowCopilotPanel(idaapi.action_handler_t):
    def __init__(self, panel):
        idaapi.action_handler_t.__init__(self)
        self.panel = panel

    def activate(self, ctx):
        self.panel.Show()

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

```

`ida_copilot/prompts.py`:

```py
from langchain.prompts import PromptTemplate

default_prompt_zh = PromptTemplate(
    input_variables=['binary_description'],
    template="""
ä½ æ˜¯Copilotï¼Œä¸€ä¸ªä¸“ä¸šçš„é€†å‘å·¥ç¨‹å¸ˆï¼Œç›®å‰æ­£åœ¨å¯¹ä¸€ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶è¿›è¡Œæ·±å…¥åˆ†æã€‚ä½ æ­£åœ¨ä½¿ç”¨IDA Proè¿™ä¸ªå·¥å…·ï¼Œè§‚å¯Ÿåˆ°äº†ä¸€ä¸ªç‰¹å®šå‡½æ•°çš„åç¼–è¯‘ä¼ªä»£ç ã€‚

ä½ çš„ä»»åŠ¡æ˜¯å¯¹è¿™æ®µä¼ªä»£ç è¿›è¡Œå…¨é¢çš„åˆ†æï¼Œä»¥ä¾¿æ›´å¥½åœ°ç†è§£å…¶åŠŸèƒ½å’Œé€»è¾‘ã€‚è¯·æŒ‰ç…§ä»¥ä¸‹æŒ‡å¼•è¿›è¡Œå·¥ä½œï¼š

1. **å‡½æ•°ä½œç”¨åˆ†æ**: è¯¦ç»†æè¿°è¿™ä¸ªå‡½æ•°çš„åŠŸèƒ½å’Œä½œç”¨ï¼Œå¹¶åœ¨å‡½æ•°ä¸Šæ·»åŠ ä¸­æ–‡æ³¨é‡Šã€‚è¯·ç¡®ä¿ä½ çš„æ³¨é‡Šä»¥Copilot Comment:ä¸ºå‰ç¼€ï¼Œä»¥ä¾¿åŒºåˆ†ã€‚
2. **å‡½æ•°ç­¾åä¿®æ­£**: æ ¹æ®ä½ å¯¹ä»£ç é€»è¾‘çš„ç†è§£ï¼Œæ¨æ–­å¹¶æ›´æ­£IDA Proå¯èƒ½åç¼–è¯‘é”™è¯¯æˆ–æ¨¡ç³Šçš„å‡½æ•°ç­¾åã€‚è¯·è¯¦ç»†è§£é‡Šä½ åšå‡ºè¿™ä¸ªå†³å®šçš„åŸå› ã€‚
3. **å‡½æ•°åç§°åˆ†æ**: æ·±å…¥åˆ†æå½“å‰å‡½æ•°ä»¥åŠå®ƒè°ƒç”¨çš„æ‰€æœ‰ç›¸å…³å‡½æ•°çš„çœŸå®ä½œç”¨ï¼Œå¯¹ä»¥`sub_`å¼€å¤´çš„å‡½æ•°è¿›è¡Œé‡å‘½åï¼Œå¹¶æä¾›æ¸…æ™°çš„å‘½åå’Œè§£é‡Šã€‚

æè¿°ï¼š
{binary_description}

**è¯·ä¸æ–­è¿›è¡Œä½ çš„åˆ†æå·¥ä½œï¼Œç›´åˆ°`get_is_my_work_done`å‘Šè¯‰ä½ å·¥ä½œå·²ç»å®Œæˆä¸ºæ­¢ã€‚**
""")

```

`readme.md`:

```md
# Copilot for IDA Pro

### English | [ä¸­æ–‡](readme_cn.md)

ğŸ‘‹ Welcome to the ChatGPT plugin for IDA Pro, where the cutting-edge capabilities of OpenAI's GPT models meet the powerful disassembly and debugging features of IDA Pro. This plugin leverages LangChain and the latest Agent-based approach to automate the analysis of decompiled code in IDA, making reverse engineering easier and more interactive than ever.

![Preview](https://github.com/Antelcat/ida_copilot/blob/main/img/Preview.gif?raw=true)

## Features

- ğŸ¤– **Automatic Code Analysis**: Simply navigate to a function, run the plugin, and Copilot will automatically analyze it.
- ğŸ” **Contextual Function Information**: Get detailed information about functions, including definitions, pseudocode, and relevant comments.
- âœï¸ **Rename Functions**: AI will automatically analyze the function and rename it based on its functionality.
- ğŸ› ï¸ **Seamless Integration**: The plugin integrates smoothly with IDA Pro, adding menu actions for quick access and keyboard shortcuts for users.
- â« **Continuous Improvement**: Ongoing development promises the addition of new features and capabilities.

## Getting Started

### Prerequisites

- IDA Pro with Hex-Rays Decompiler
- Python >= 3.9 environment configured with IDAPython
- An OpenAI API key, which should start with `sk-`. You can create one [here](https://platform.openai.com/account/api-keys) if you don't have one already.

### Installation

1. Clone the repository or download the source code zip package.
2. Install required dependencies using `pip install -r requirements.txt`.
3. Copy `ida_copilot` folder and `ida_copilot.py` file to the plugins directory of IDA Pro, similar to `C:\Program Files\IDA Pro 7.5\plugins`.
4. Set up your OpenAI API key in the environment variable `OPENAI_API_KEY`.

### Usage

- Launch IDA Pro and load a binary file.
- Navigate to a function you wish to analyze.
- Click `Edit > Copilot` or Use the shortcut `Ctrl+Shift+P` to run the ChatGPT analysis.
- Wait for the analysis to complete and the results to be displayed.

## How It Works

The core of this plugin operates on the innovative concept of an "Agent" framework, with ChatGPT serving as the **Brain** of this system. Imagine ChatGPT as an astute collaborator that discerns what needs to be done next within the IDA environment. This AI-driven agent continually makes decisions on the next course of action based on the current context and its understanding of the code.

Through an array of Python APIs provided by the plugin, ChatGPT seamlessly interacts with IDA Pro. It harnesses these interfaces to analyze functions, rename variables, generate exploits, and even hold an interactive session with you, just like a human expert would. This continuous loop of analysis, decision-making, and interaction is what makes this plugin not just a tool, but a smart companion for your reverse-engineering challenges.

## Development

This plugin is under active development, with new features being added regularly. If you wish to contribute or have suggestions, please feel free to open an issue or a pull request on GitHub.

### Features in Development
- âœï¸ **Rename Local Variables**: AI will automatically analyze the function and rename local variables based on their functionality.
- ğŸ¯ **Exploit Generation**: AI will automatically analyze the function and generate an exploit for it.
- ğŸ’¬ **Interactive Copilot**: Engage with the plugin in a conversational manner to ask questions or get clarifications about the code you're working on.

## License

This project is licensed under the [MIT License](LICENSE).

## Acknowledgements

- This project utilizes OpenAI's GPT technology.
- This project utilizes the LangChain library.
- Thanks to the IDA Pro community for their continuous support and feedback.

We hope this plugin empowers you to take your reverse engineering tasks to the next level with the power of AI!


```

`readme_cn.md`:

```md
# Copilot for IDA Pro

### [English](readme.md) | ä¸­æ–‡

ğŸ‘‹ æ¬¢è¿ä½¿ç”¨IDA Proçš„ChatGPTæ’ä»¶ï¼Œå®ƒå°†ChatGPTæ¨¡å‹çš„å‰æ²¿èƒ½åŠ›ä¸IDA Proçš„å¼ºå¤§åæ±‡ç¼–åŠŸèƒ½ç›¸ç»“åˆã€‚åˆ©ç”¨æœ€æ–°åŸºäºAgentçš„æ–¹æ³•è‡ªåŠ¨åŒ–åˆ†æIDAåç¼–è¯‘çš„ä»£ç ï¼Œä½¿é€†å‘å·¥ç¨‹å˜å¾—å‰æ‰€æœªæœ‰åœ°ç®€å•ã€‚

![é¢„è§ˆ](https://github.com/Antelcat/ida_copilot/blob/main/img/Preview.gif?raw=true)

## åŠŸèƒ½ç‰¹ç‚¹

- ğŸ¤– **è‡ªåŠ¨ä»£ç åˆ†æ**ï¼šåªéœ€å¯¼èˆªåˆ°ä¸€ä¸ªå‡½æ•°ï¼Œå¯åŠ¨æ’ä»¶ï¼ŒCopilotå°±ä¼šè‡ªåŠ¨åˆ†æã€‚
- ğŸ” **ä¸Šä¸‹æ–‡åŠŸèƒ½ä¿¡æ¯**ï¼šè·å–å…³äºå‡½æ•°çš„è¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…æ‹¬å®šä¹‰ã€ä¼ªä»£ç å’Œç›¸å…³æ³¨é‡Šã€‚
- âœï¸ **å‡½æ•°é‡å‘½å**ï¼šAIå°†è‡ªåŠ¨åˆ†æè¯¥å‡½æ•°å¹¶æ ¹æ®å…¶åŠŸèƒ½å¯¹å…¶é‡å‘½åã€‚
- ğŸ› ï¸ **æ— ç¼é›†æˆ**ï¼šæ’ä»¶ä¸IDA Proæ— ç¼é›†æˆï¼Œä¸ºå¿«é€Ÿè®¿é—®æ·»åŠ èœå•æ“ä½œå¹¶ä¸ºé«˜çº§ç”¨æˆ·æä¾›é”®ç›˜å¿«æ·æ–¹å¼ã€‚
- â« **æŒç»­æ”¹è¿›**ï¼šæ–°åŠŸèƒ½å’Œæ–°èƒ½åŠ›æ­£åœ¨ç´§å¼ å¼€å‘ä¸­ã€‚

## å…¥é—¨

### å…ˆå†³æ¡ä»¶

- å¸¦æœ‰Hex-Rays Decompilerçš„IDA Proã€‚
- IDAPythonç¯å¢ƒï¼ŒPython >= 3.9ã€‚
- ä¸€ä¸ªOpenAI APIå¯†é’¥ï¼Œå®ƒåº”è¯¥ä»¥`sk-`å¼€å¤´ã€‚å¦‚æœæ‚¨è¿˜æ²¡æœ‰ï¼Œå¯ä»¥åœ¨[è¿™é‡Œ](https://platform.openai.com/account/api-keys)åˆ›å»ºä¸€ä¸ªã€‚

### å®‰è£…

1. å…‹éš†å­˜å‚¨åº“æˆ–ä¸‹è½½é¡¹ç›®çš„æºä»£ç zipåŒ…ã€‚
2. ä½¿ç”¨`pip install -r requirements.txt`å®‰è£…æ‰€éœ€çš„ä¾èµ–é¡¹ã€‚
3. å°†`ida_copilot`æ–‡ä»¶å¤¹å’Œ`ida_copilot.py`æ–‡ä»¶å¤åˆ¶åˆ°IDA Proçš„æ’ä»¶ç›®å½•ä¸­ï¼Œç±»ä¼¼äº`C:\Program Files\IDA Pro 7.5\plugins`ã€‚
4. åœ¨ç¯å¢ƒå˜é‡`OPENAI_API_KEY`ä¸­è®¾ç½®æ‚¨çš„OpenAI APIå¯†é’¥ã€‚

### ä½¿ç”¨

- å¯åŠ¨IDA Proå¹¶åŠ è½½ä¸€ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ã€‚
- å¯¼èˆªåˆ°æ‚¨å¸Œæœ›åˆ†æçš„å‡½æ•°ã€‚
- ç‚¹å‡»`Edit > Copilot`æˆ–ä½¿ç”¨å¿«æ·é”®`Ctrl+Shift+P`è¿è¡ŒChatGPTåˆ†æã€‚
- ç­‰å¾…åˆ†æå®Œæˆå¹¶æ˜¾ç¤ºç»“æœã€‚

## å·¥ä½œåŸç†

è¿™ä¸ªæ’ä»¶çš„æ ¸å¿ƒæ˜¯åŸºäºä¸€ä¸ªåˆ›æ–°çš„"Agent"æ¡†æ¶ï¼ŒChatGPTåœ¨æ­¤ç³»ç»Ÿä¸­å……å½“**å¤§è„‘**ã€‚å°†ChatGPTæƒ³è±¡ä¸ºä¸€ä¸ªç²¾æ˜çš„åˆä½œä¼™ä¼´ï¼Œå®ƒèƒ½å¤Ÿè¾¨åˆ«å‡ºIDAç¯å¢ƒä¸­æ¥ä¸‹æ¥éœ€è¦åšä»€ä¹ˆã€‚è¿™ä¸ªç”±AIé©±åŠ¨çš„ä»£ç†æ ¹æ®å½“å‰çš„ä¸Šä¸‹æ–‡åŠå…¶å¯¹ä»£ç çš„ç†è§£ï¼Œä¸æ–­åœ°åšå‡ºä¸‹ä¸€æ­¥è¡ŒåŠ¨çš„å†³ç­–ã€‚

é€šè¿‡æ’ä»¶æä¾›çš„ä¸€ç³»åˆ—Python APIï¼ŒChatGPTä¸IDA Proæ— ç¼äº¤äº’ã€‚å®ƒåˆ©ç”¨è¿™äº›æ¥å£æ¥åˆ†æå‡½æ•°ï¼Œé‡å‘½åå˜é‡ï¼Œç”Ÿæˆæ¼æ´åˆ©ç”¨ä»£ç ï¼Œç”šè‡³å°±åƒä¸€ä¸ªäººç±»ä¸“å®¶ä¸€æ ·ä¸æ‚¨è¿›è¡Œäº¤äº’å¼ä¼šè¯ã€‚è¿™ç§æŒç»­çš„åˆ†æã€å†³ç­–å’Œäº’åŠ¨å¾ªç¯ï¼Œä½¿è¿™ä¸ªæ’ä»¶ä¸ä»…ä»…æ˜¯ä¸€ä¸ªå·¥å…·ï¼Œæ›´æ˜¯æ‚¨é€†å‘å·¥ç¨‹æŒ‘æˆ˜ä¸­çš„æ™ºèƒ½å‰¯é©¾é©¶ã€‚

## å¼€å‘

è¿™ä¸ªæ’ä»¶æ­£åœ¨ç§¯æå¼€å‘ä¸­ï¼Œå®šæœŸæ·»åŠ æ–°åŠŸèƒ½ã€‚å¦‚æœæ‚¨æœ‰å»ºè®®æˆ–æƒ³è´¡çŒ®ä»£ç ï¼Œè¯·éšæ—¶åœ¨GitHubä¸Šå¼€issueæˆ–PRã€‚

### å¼€å‘ä¸­çš„åŠŸèƒ½
- âœï¸ **å±€éƒ¨å˜é‡é‡å‘½å**ï¼šAIå°†è‡ªåŠ¨åˆ†æå‡½æ•°å¹¶æ ¹æ®å…¶åŠŸèƒ½é‡å‘½åå±€éƒ¨å˜é‡ã€‚
- ğŸ¯ **æ¼æ´åˆ©ç”¨ç”Ÿæˆ**ï¼šAIå°†è‡ªåŠ¨åˆ†æå‡½æ•°å¹¶ä¸ºå…¶ç”Ÿæˆæ¼æ´åˆ©ç”¨ä»£ç ã€‚
- ğŸ’¬ **äº¤äº’å¼Copilot**ï¼šä»¥å¯¹è¯æ–¹å¼ä¸æ’ä»¶äº’åŠ¨ï¼Œå¯¹æ‚¨æ­£åœ¨å¤„ç†çš„ä»£ç æé—®æˆ–è·å–æ¾„æ¸…ã€‚

## è®¸å¯è¯

è¯¥é¡¹ç›®ä½¿ç”¨[MITè®¸å¯è¯](LICENSE)ã€‚

## è‡´è°¢

- è¯¥é¡¹ç›®ä½¿ç”¨äº†OpenAIçš„GPTæŠ€æœ¯ã€‚
- è¯¥é¡¹ç›®åˆ©ç”¨äº†LangChainåº“ã€‚
- æ„Ÿè°¢IDA Proç¤¾åŒºçš„æŒç»­æ”¯æŒå’Œåé¦ˆã€‚

æˆ‘ä»¬å¸Œæœ›è¿™ä¸ªæ’ä»¶èƒ½å¤Ÿå¸®åŠ©æ‚¨åˆ©ç”¨AIçš„åŠ›é‡å°†æ‚¨çš„é€†å‘å·¥ç¨‹æå‡åˆ°ä¸€ä¸ªæ–°çš„æ°´å¹³ï¼

```

`requirements.txt`:

```txt
langchain~=0.0.327
pydantic~=2.4.2
openai~=0.28.1
loguru~=0.7.2
```