Project Path: arc_android1337_crystr_vn8aeoyf

Source Tree:

```txt
arc_android1337_crystr_vn8aeoyf
├── LICENSE
├── README.md
├── include
│   └── crystr.hpp
└── src
    └── main.cpp

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Android1337

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# crystr | Compile-Time Strings and Numbers Encryption for C++20

## Description
This repository provides a compile-time strings and numbers encryption mechanism based on xor bitwise operations using mathematical operations at compile-time in order to make the strings and numbers challenging to decompile.\
Users can easily encrypt their strings using the `crystr` macro provided in the header, and numbers using `crynum` and `crynum_long`.\
The repository includes an example demonstrating the usage of `crystr`, `crynum` and `crynum_long` to use encrypted strings and numbers.\
It's recommended, but not necessarily, to `disable the optimization under C/C++ -> Optimization -> "Optimization" and "Whole Program Optimization"`\
When using the virtual functions option it `needs RTTI OFF (Run-Time Type Information under C/C++ -> Language (/GR-))`

## Key Aspects
 - The xor key is generated by mathematical operations based on a uniqueid that is different every time the program is compiled and for each encrypted string/number.
 - The uniqueid is an hash based on the date, time and a counter which increases every time a string/number encrypts: ```const_hash(__DATE__ __TIME__) + __COUNTER__ * __COUNTER__```.
 - When using crystr every character is encrypted with a different xor key based on the index of the character inside the string.
 - It is possible to choose between virtual and inline functions to decrypt the strings/numbers.
 - If using the virtual implementation it works well with `crycall` ([see the repo](https://github.com/Android1337/crycall)).
 - All the variables used to retrieve the xor key are thread_local, meaning they're stored as `(NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex)->x_var`, making it more challenging to decompile and **not** ready-pastable from decompiler tools such as ida or ghidra.
 - The string is never copied but instead it's being written on, in order to prevent unwanted decrypted copies of the string in memory.
 - The decrypted string can be re-encrypted at any time using the built-in `encrypt` function.
 - The decrypted/encrypted string/number can be removed from memory at any time using the built-in `clear` function.
 - The string/number will show as never referenced in most common decompiler tools such as ida or ghidra see ([How it shows](https://github.com/Android1337/crystr/tree/main#how-it-shows)).
 - Compatible with char[], wchar_t[], int, __int64, unsigned int, unsigned __int64, float, double.
 - Supports C++20 and higher versions.

## How it shows
[Look here](https://imgur.com/a/acamGoW)\
How it shows using [inline functions option](https://crystr-inline.tiiny.site)

## Repository Structure
- **`include/`**: Contains the `crystr.hpp` header file providing the compile-time string/number encryption mechanism.
- **`src/`**: Holds the example `main.cpp` file showcasing the usage of `crystr`, `crynum`, `crynum_long`.
- **`LICENSE`**: Licensing information for the provided code.
- **`README.md`**: Documentation explaining how to use everything.

## Usage Example
The repository includes an example demonstrating the usage of the `crystr`, `crynum`, `crynum_long` macros:

### `main.cpp`
```cpp
//#include "crycall.hpp" // see https://github.com/Android1337/crycall for an all-potential virtual implementation
#include "crystr.hpp"

int main() {
    auto encrypted_str = crystr("Hello, this is an encrypted string!");
    printf("Decrypted String: %s\n", encrypted_str.decrypt());
    encrypted_str.clear();

    auto encrypted_int = crynum(1234);
    printf("Decrypted Int: %d\n", encrypted_int.decrypt());
    encrypted_int.clear();

    auto encrypted_double = crynum_long(1.234);
    printf("Decrypted Double: %f\n", encrypted_double.decrypt());
    encrypted_double.clear();

    return 0;
}
```

```

`include/crystr.hpp`:

```hpp
/*
 * MIT License https://github.com/Android1337/crystr/blob/main/LICENSE
 * 
 * Copyright (c) 2023 Android1337
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef CRYSTR_HPP
#define CRYSTR_HPP
#include <bit> // std::bit_cast

#define USE_INLINE_FUNCTIONS 1 // you can either use virtual or __forceinline

#if USE_INLINE_FUNCTIONS == 1
#define CRYSTR_TYPE __forceinline
#else
#define CRYSTR_TYPE virtual
#ifdef _CPPRTTI
#error("Please disable Run-Time Type Information under C/C++ -> Language (/GR-)")
#endif
#endif

constexpr unsigned long long const_hash(const char* input, unsigned long long value = 0) {
	return *input ? static_cast<unsigned long long>(*input) + 33 * const_hash(input + 1, value)
		: (5381 + 33 * value);
}

#define crystr(str) []() { \
			constexpr static auto const_str = crys::cryStr \
				<const_hash(__DATE__ __TIME__, __COUNTER__), sizeof(str) / sizeof(str[0]), std::remove_const_t<std::remove_reference_t<decltype(str[0])>>>((std::remove_const_t<std::remove_reference_t<decltype(str[0])>>*)str); \
					return const_str; }()

#define crynum(num) []() { \
			constexpr thread_local auto val = num; \
			constexpr static auto const_str = crys::cryNum \
				<const_hash(__DATE__ __TIME__, __COUNTER__), decltype(val)>(std::bit_cast<unsigned int, decltype(val)>(num)); \
					return const_str; }()

#define crynum_long(num) []() { \
			constexpr thread_local auto val = num; \
			constexpr static auto const_str = crys::cryNum \
				<const_hash(__DATE__ __TIME__, __COUNTER__), decltype(val)>(std::bit_cast<unsigned long long, decltype(val)>(num)); \
					return const_str; }()

namespace crys
{
	template <unsigned long long uniqueid, unsigned int data_size, typename T>
	class cryStr
	{
	public:
		__forceinline constexpr cryStr(T* str)
		{
			for (int i = 0; i < data_size; i++)
			{
				auto v = (uniqueid + i) * double((3.1415926535897932f / (180.f)) / 2.f);
				auto y = v - (2.0f * 3.1415926535897932f) * double((0.31830988618f * 0.5f) * v + 0.5f);
				auto w = double(0);

				if (y > 3.1415926535897932f / 2)
				{
					y = 3.1415926535897932f - y;
					w = (-1.f * ((((-2.6051615e-07f * (y * y) + 2.4760495e-05f) * (y * y) - 0.0013888378f) * (y * y) + 0.041666638f) * (y * y) - 0.5f) * (y * y) + 1.0f);
				}
				else if (y < (3.1415926535897932f / 2) * -1)
				{
					y = -3.1415926535897932f - y;
					w = (-1.f * ((((-2.6051615e-07f * (y * y) + 2.4760495e-05f) * (y * y) - 0.0013888378f) * (y * y) + 0.041666638f) * (y * y) - 0.5f) * (y * y) + 1.0f);
				}
				else
					w = (1.f * ((((-2.6051615e-07f * (y * y) + 2.4760495e-05f) * (y * y) - 0.0013888378f) * (y * y) + 0.041666638f) * (y * y) - 0.5f) * (y * y) + 1.0f);

				auto z = (((((-2.3889859e-08f * (y * y) + 2.7525562e-06f) * (y * y) - 0.00019840874f) * (y * y) + 0.0083333310f) * (y * y) - 0.16666667f) * (y * y) + 1.0f);
				data[i] = str[i] ^ T(std::bit_cast<unsigned long long>(z * y + w) + i);
			}
		}

		__forceinline void encrypt()
		{
#if defined(CRYCALL_HPP) && USE_INLINE_FUNCTIONS == 0
			crycall_virtual(void, this, 0x2);
#else
			xor_encrypt();
#endif
		}

		__forceinline T* decrypt()
		{
#if defined(CRYCALL_HPP) && USE_INLINE_FUNCTIONS == 0
			crycall_virtual(void, this, 0x3);
#else
			xor_decrypt();
#endif
			thread_local auto ret = data;
			return ret;
		}

		__forceinline void clear()
		{
			for (unsigned int i = 0; i < data_size; i++)
				data[i] = 0;
		}

	private:
		CRYSTR_TYPE unsigned long long get_xor_key(unsigned int i)
		{
			thread_local auto d = double((3.1415926535897932f / (180.f)) / 2.f);
			thread_local auto v = (uniqueid + i) * d;
			thread_local auto q = double((0.31830988618f * 0.5f) * v + 0.5f);
			thread_local auto y = v - (2.0f * 3.1415926535897932f) * q;

			if (y > 3.1415926535897932f / 2)
			{
				thread_local auto ny = 3.1415926535897932f - y;
				thread_local auto z = (((((-2.3889859e-08f * (ny * ny) + 2.7525562e-06f) * (ny * ny) - 0.00019840874f) * (ny * ny) + 0.0083333310f) * (ny * ny) - 0.16666667f) * (ny * ny) + 1.0f);
				thread_local auto w = (-1.f * ((((-2.6051615e-07f * (ny * ny) + 2.4760495e-05f) * (ny * ny) - 0.0013888378f) * (ny * ny) + 0.041666638f) * (ny * ny) - 0.5f) * (ny * ny) + 1.0f);
				thread_local auto ret = z * ny + w;
				return std::bit_cast<unsigned long long>(ret) + i;
			}
			else if (y < (3.1415926535897932f / 2) * -1)
			{
				thread_local auto ny = -3.1415926535897932f - y;
				thread_local auto z = (((((-2.3889859e-08f * (ny * ny) + 2.7525562e-06f) * (ny * ny) - 0.00019840874f) * (ny * ny) + 0.0083333310f) * (ny * ny) - 0.16666667f) * (ny * ny) + 1.0f);
				thread_local auto w = (-1.f * ((((-2.6051615e-07f * (ny * ny) + 2.4760495e-05f) * (ny * ny) - 0.0013888378f) * (ny * ny) + 0.041666638f) * (ny * ny) - 0.5f) * (ny * ny) + 1.0f);
				thread_local auto ret = z * ny + w;
				return std::bit_cast<unsigned long long>(ret) + i;
			}

			thread_local auto z = (((((-2.3889859e-08f * (y * y) + 2.7525562e-06f) * (y * y) - 0.00019840874f) * (y * y) + 0.0083333310f) * (y * y) - 0.16666667f) * (y * y) + 1.0f);
			thread_local auto w = (1.f * ((((-2.6051615e-07f * (y * y) + 2.4760495e-05f) * (y * y) - 0.0013888378f) * (y * y) + 0.041666638f) * (y * y) - 0.5f) * (y * y) + 1.0f);
			thread_local auto ret = z * y + w;
			return std::bit_cast<unsigned long long>(ret) + i;
		}

		CRYSTR_TYPE void xor_byte(T* out, T* data, unsigned int i)
		{
#if defined(CRYCALL_HPP) && USE_INLINE_FUNCTIONS == 0
			out[i] = data[i] ^ T(crycall_virtual(unsigned long long, this, 0x0, i));
#else
			out[i] = data[i] ^ T(get_xor_key(i));
#endif
		}

		CRYSTR_TYPE void xor_encrypt()
		{
			if (data[data_size - 1] == 0)
			{
				for (unsigned int i = 0; i < data_size; i++)
				{
#if defined(CRYCALL_HPP) && USE_INLINE_FUNCTIONS == 0
					crycall_virtual(void, this, 0x1, data, data, i);
#else
					xor_byte(data, data, i);
#endif
				}

				data[data_size - 1] = 0xFF;
			}
		}

		CRYSTR_TYPE void xor_decrypt()
		{
			if (data[data_size - 1] != 0)
			{
				for (unsigned int i = 0; i < data_size; i++)
				{
#if defined(CRYCALL_HPP) && USE_INLINE_FUNCTIONS == 0
					crycall_virtual(void, this, 0x1, data, data, i);
#else
					xor_byte(data, data, i);
#endif
				}

				data[data_size - 1] = 0;
			}
		}

		T data[data_size] = {};
	};

	template <unsigned long long uniqueid, typename T>
	class cryNum
	{
	public:
		__forceinline constexpr cryNum(unsigned long long value)
		{
			auto v = uniqueid * double((3.1415926535897932f / (180.f)) / 2.f);
			auto y = v - (2.0f * 3.1415926535897932f) * double((0.31830988618f * 0.5f) * v + 0.5f);
			auto w = double(0);

			if (y > 3.1415926535897932f / 2)
			{
				y = 3.1415926535897932f - y;
				w = (-1.f * ((((-2.6051615e-07f * (y * y) + 2.4760495e-05f) * (y * y) - 0.0013888378f) * (y * y) + 0.041666638f) * (y * y) - 0.5f) * (y * y) + 1.0f);
			}
			else if (y < (3.1415926535897932f / 2) * -1)
			{
				y = -3.1415926535897932f - y;
				w = (-1.f * ((((-2.6051615e-07f * (y * y) + 2.4760495e-05f) * (y * y) - 0.0013888378f) * (y * y) + 0.041666638f) * (y * y) - 0.5f) * (y * y) + 1.0f);
			}
			else
				w = (1.f * ((((-2.6051615e-07f * (y * y) + 2.4760495e-05f) * (y * y) - 0.0013888378f) * (y * y) + 0.041666638f) * (y * y) - 0.5f) * (y * y) + 1.0f);

			auto z = (((((-2.3889859e-08f * (y * y) + 2.7525562e-06f) * (y * y) - 0.00019840874f) * (y * y) + 0.0083333310f) * (y * y) - 0.16666667f) * (y * y) + 1.0f);
			data = value ^ std::bit_cast<unsigned long long>(z * y + w);
		}

		__forceinline T decrypt()
		{
#if defined(CRYCALL_HPP) && USE_INLINE_FUNCTIONS == 0
			thread_local auto ret = crycall_virtual(unsigned long long, this, 0x2);
#else
			thread_local auto ret = xor_decrypt();
#endif
			return *(T*)&ret;
		}

		__forceinline void clear()
		{
			data = 0;
		}

	private:
		CRYSTR_TYPE unsigned long long get_xor_key()
		{
			thread_local auto d = double((3.1415926535897932f / (180.f)) / 2.f);
			thread_local auto v = uniqueid * d;
			thread_local auto q = double((0.31830988618f * 0.5f) * v + 0.5f);
			thread_local auto y = v - (2.0f * 3.1415926535897932f) * q;

			if (y > 3.1415926535897932f / 2)
			{
				thread_local auto ny = 3.1415926535897932f - y;
				thread_local auto z = (((((-2.3889859e-08f * (ny * ny) + 2.7525562e-06f) * (ny * ny) - 0.00019840874f) * (ny * ny) + 0.0083333310f) * (ny * ny) - 0.16666667f) * (ny * ny) + 1.0f);
				thread_local auto w = (-1.f * ((((-2.6051615e-07f * (ny * ny) + 2.4760495e-05f) * (ny * ny) - 0.0013888378f) * (ny * ny) + 0.041666638f) * (ny * ny) - 0.5f) * (ny * ny) + 1.0f);
				thread_local auto ret = z * ny + w;
				return std::bit_cast<unsigned long long>(ret);
			}
			else if (y < (3.1415926535897932f / 2) * -1)
			{
				thread_local auto ny = -3.1415926535897932f - y;
				thread_local auto z = (((((-2.3889859e-08f * (ny * ny) + 2.7525562e-06f) * (ny * ny) - 0.00019840874f) * (ny * ny) + 0.0083333310f) * (ny * ny) - 0.16666667f) * (ny * ny) + 1.0f);
				thread_local auto w = (-1.f * ((((-2.6051615e-07f * (ny * ny) + 2.4760495e-05f) * (ny * ny) - 0.0013888378f) * (ny * ny) + 0.041666638f) * (ny * ny) - 0.5f) * (ny * ny) + 1.0f);
				thread_local auto ret = z * ny + w;
				return std::bit_cast<unsigned long long>(ret);
			}

			thread_local auto z = (((((-2.3889859e-08f * (y * y) + 2.7525562e-06f) * (y * y) - 0.00019840874f) * (y * y) + 0.0083333310f) * (y * y) - 0.16666667f) * (y * y) + 1.0f);
			thread_local auto w = (1.f * ((((-2.6051615e-07f * (y * y) + 2.4760495e-05f) * (y * y) - 0.0013888378f) * (y * y) + 0.041666638f) * (y * y) - 0.5f) * (y * y) + 1.0f);
			thread_local auto ret = z * y + w;
			return std::bit_cast<unsigned long long>(ret);
		}

		CRYSTR_TYPE void xor_byte(unsigned long long* out, unsigned long long data)
		{
#if defined(CRYCALL_HPP) && USE_INLINE_FUNCTIONS == 0
			*out = data ^ crycall_virtual(unsigned long long, this, 0x0);
#else
			*out = data ^ get_xor_key();
#endif
		}

		CRYSTR_TYPE unsigned long long xor_decrypt()
		{
			unsigned long long ret{};
#if defined(CRYCALL_HPP) && USE_INLINE_FUNCTIONS == 0
			crycall_virtual(void, this, 0x1, &ret, data);
#else
			xor_byte(&ret, data);
#endif
			return ret;
		}

		unsigned long long data = {};
	};
}

#endif // include guard

```

`src/main.cpp`:

```cpp
//#include "crycall.hpp" // see https://github.com/Android1337/crycall for an all-potential virtual implementation
#include "crystr.hpp"

int main() {
    auto encrypted_str = crystr("Hello, this is an encrypted string!");

    printf("Decrypted String: %s", encrypted_str.decrypt());

    encrypted_str.clear();

    return 0;
}

```