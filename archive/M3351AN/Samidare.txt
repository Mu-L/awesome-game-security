Directory structure:
└── m3351an-samidare/
    ├── README.md
    ├── CS2x64.cc
    ├── CS2x64.h
    ├── Driver.h
    ├── entry_point.cc
    ├── FIFO.h
    ├── framework.h
    ├── Game.cc
    ├── Game.h
    ├── global.h
    ├── HARMONYOSSANS字体许可协议
    ├── Lang.h
    ├── LICENSE
    ├── maths.h
    ├── Offsets.cc
    ├── Offsets.h
    ├── Overlay.cc
    ├── Overlay.h
    ├── pch.cc
    ├── pch.h
    ├── resource.h
    ├── Samidare.rc
    ├── Samidare.sln
    ├── Samidare.vcxproj
    ├── Samidare.vcxproj.filters
    ├── UkiaStuff.cc
    ├── UkiaStuff.h
    ├── zekamashi.h
    ├── Functions/
    │   ├── config.h
    │   ├── ConfigSaver.cc
    │   ├── ConfigSaver.h
    │   ├── Func.cc
    │   ├── Func.h
    │   ├── menu.h
    │   ├── Aimbot/
    │   │   ├── Aimbot.cc
    │   │   ├── Aimbot.h
    │   │   ├── RCS.cc
    │   │   ├── RCS.h
    │   │   ├── TriggerBot.cc
    │   │   └── TriggerBot.h
    │   ├── Miscs/
    │   │   ├── BombTimer.cc
    │   │   ├── BombTimer.h
    │   │   ├── Miscs.cc
    │   │   ├── Miscs.h
    │   │   ├── SpecList.cc
    │   │   └── SpecList.h
    │   └── Visuals/
    │       ├── ESP.cc
    │       ├── ESP.h
    │       ├── Radar.cc
    │       └── Radar.h
    ├── ImGui/
    │   ├── imconfig.h
    │   ├── imgui_impl_dx9.cpp
    │   ├── imgui_impl_dx9.h
    │   ├── imgui_impl_win32.cpp
    │   ├── imgui_impl_win32.h
    │   ├── imgui_tables.cpp
    │   ├── imstb_rectpack.h
    │   ├── imstb_textedit.h
    │   └── imstb_truetype.h
    ├── Utils/
    │   ├── CallStack-Spoofer.h
    │   ├── miniz.h
    │   ├── mouse_input_injection.h
    │   ├── uiaccess.c
    │   ├── uiaccess.h
    │   ├── XorStr.h
    │   ├── nlohmann/
    │   │   └── json_fwd.hpp
    │   ├── vphys_parser/
    │   │   ├── ray_trace.h
    │   │   └── vector.h
    │   └── yaml-cpp/
    │       ├── anchor.h
    │       ├── binary.h
    │       ├── depthguard.h
    │       ├── dll.h
    │       ├── emitfromevents.h
    │       ├── emitter.h
    │       ├── emitterdef.h
    │       ├── emittermanip.h
    │       ├── emitterstyle.h
    │       ├── eventhandler.h
    │       ├── exceptions.h
    │       ├── mark.h
    │       ├── noexcept.h
    │       ├── null.h
    │       ├── ostream_wrapper.h
    │       ├── parser.h
    │       ├── stlemitter.h
    │       ├── traits.h
    │       ├── yaml.h
    │       ├── contrib/
    │       │   ├── anchordict.h
    │       │   └── graphbuilder.h
    │       └── node/
    │           ├── convert.h
    │           ├── emit.h
    │           ├── impl.h
    │           ├── iterator.h
    │           ├── node.h
    │           ├── parse.h
    │           ├── ptr.h
    │           ├── type.h
    │           └── detail/
    │               ├── impl.h
    │               ├── iterator.h
    │               ├── iterator_fwd.h
    │               ├── memory.h
    │               ├── node.h
    │               ├── node_data.h
    │               ├── node_iterator.h
    │               └── node_ref.h
    └── .github/
        ├── CODE_OF_CONDUCT.md
        ├── CONTRIBUTING.md
        ├── FUNDING.yml
        ├── SECURITY.MD
        └── workflows/
            ├── CI.yml
            └── windows.yml


================================================
FILE: README.md
================================================
![SAMIDARETITLE](.github/Samidare-Title.png)
*"五月雨を集めて早し最上川"*

## WIP, but when continue?
- Firstly, since I haven't worked in this area for so long, I need to update the game and see what needs to be improved.
- As you can see, the current project's code style is not easy and needs some sorting out. It shouldn't take long, but it still takes some time.
- Similarly, there are some C++20 features mixed with old features in the code, as well as some meaningless duplication of implementations, which also need to be cleaned up.
- I will gradually move forward with the above content when I have enough time and a stable network connection
## Feature 
- Use Native APIs to OpenProcess/WPM/RPM/MouseEvent (Ring3) and CreateWindow
- Inplement WPM/RPM/MouseEvent in kernel-mode (Ring0)
- Multithread
- Basic imgui Overlay/Menu
- Overlay at most top with uiaccess(which allows you overlay while game in full-screen mode, but some bugs need to resolve)
- Automatic change exe file hash with .bat eachtime run/exit
- Basic config system with yaml-cpp
- Customizable i18n system with yaml-cpp
- Random title with 风花雪月
- Visible check with vphys parser
- Auto teamcheck with cvar finder
- Bypass Capture ability
## Functions

<details>
<summary>Legit</summary>
  
- Customizable Aim Assist
- Customizable Triggerbot
- Customizable RCS
</details>

![Screenshot 2025-06-13 062118](https://github.com/user-attachments/assets/7f314185-98ed-4e48-a62a-f8db5d5b3deb)

<details>

<summary>Visuals</summary>
  
- Customizable player ESP
- Bomb ESP
- Customizable Radar
</details>

![Screenshot 2025-06-13 062148](https://github.com/user-attachments/assets/21fcd5a5-d3b6-4d1f-adb0-0aa60f6f4f44)

<details>
<summary>Miscs</summary>

- Sonar
- Pitch indicator
- Bomb timer with damage calculation
- Spectator List
- Closest Enemy info
- Fast stop
</details>

![Screenshot 2025-06-13 062219](https://github.com/user-attachments/assets/9f93a50a-30b1-451d-a9b3-f2789b0fb273)

<details>
<summary>Settings</summary>
  
- Build Info
- Config Saver
- Force Team Check Switch
- Bypass Capture
</details>

![Screenshot 2025-06-13 062258](https://github.com/user-attachments/assets/4a7649f0-146d-40a8-851f-e1405725e4f9)

<details>
<summary>Experimental</summary>
  
- Performances Settings
</details>

![Screenshot 2025-06-13 062307](https://github.com/user-attachments/assets/d4477133-4f01-4ca2-99e1-76ac4a6746ab)

## Related
- [UkiaRPM](https://github.com/M3351AN/UkiaRPM) as start point.
- [Vphys-Parser-Online](https://github.com/M3351AN/Vphys-Parser-Online)
- [mouse_input_injection](https://github.com/M3351AN/mouse_input_injection) (Ring3)
- [Usugumo](https://github.com/M3351AN/Usugumo) (Ring0)
- [Shirakumo](https://github.com/M3351AN/Shirakumo) (Ring3 FIFO)
## Credits
- [3A1(Z3bra)](https://github.com/3a1/) for his CS1.6 hack [Evelion](https://github.com/3a1/Evelion)
- [ekknod](https://github.com/ekknod/) for his CS2 pen-test [EC](https://github.com/ekknod/EC)
- [IMXNOOBX](https://github.com/IMXNOOBX/) for his [cs2-external-esp](https://github.com/IMXNOOBX/cs2-external-esp)
- [AtomicBool(AtomicBoolean)](https://github.com/AtomicBool/) for his [cs2-map-parser](https://github.com/AtomicBool/cs2-map-parser)
- [TKazer(Liv)](https://github.com/TKazer) for his [CS2_External](https://github.com/TKazer/CS2_External)
- [TKazer(Liv)](https://github.com/TKazer),[Vekor64(CowNow)](https://github.com/Vekor64/),Shinyaluvs,[oakboat](https://github.com/oakboat/),[Me"M3351AN(渟雲)"](https://github.com/M3351AN) ...and many others who ever contribute to [Aimstar](https://github.com/M3351AN/AimStar)
- Friendly users on UC that ever helps me
- [ocornut(omar)](https://github.com/ocornut/) for his [Dear ImGui](https://github.com/ocornut/imgui)
- [killtimer0(killtimer)](https://github.com/killtimer0/) for his [uiaccess](https://github.com/killtimer0/uiaccess)
- [Barracudach(Evgeny)](https://github.com/Barracudach/) for his [CallStack-Spoofer](https://github.com/Barracudach/CallStack-Spoofer)
- [TheCruZ](https://github.com/TheCruZ/) for his [kdmapper](https://github.com/TheCruZ/kdmapper)
- [oakboat](https://github.com/oakboat/) for his [RTCore64_Vulnerability](https://github.com/oakboat/RTCore64_Vulnerability)
- [jbeder(Jesse Beder)](https://github.com/jbeder/) for his [yaml-cpp](https://github.com/jbeder/yaml-cpp)
- [nlohmann(Niels Lohmann)](https://github.com/nlohmann/) for his [json](https://github.com/nlohmann/json)
- [nothings(Sean Barrett)](https://github.com/nothings/) for his [stb](https://github.com/nothings/stb)
- [richgel999(Rich Geldreich)](https://github.com/richgel999/) for his [miniz](https://github.com/richgel999/miniz)
- Huawei Device Co., Ltd. for their [HarmonyOS Sans Fonts](https://developer.huawei.com/consumer/en/doc/design-guides-V1/font-0000001157868583-V1) ([LICENCE](HARMONYOSSANS字体许可协议))
- [舰娘百科(zh.kcwiki.cn)](https://zh.kcwiki.cn/wiki/%E8%88%B0%E5%A8%98%E7%99%BE%E7%A7%91) for some images licenced under [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc/4.0/)
- [DeepSeek R1](https://github.com/deepseek-ai/DeepSeek-R1) for cleaning my sh1t code
- CHINA TOBACCO GUANGXI INDUSTRIAL CO., LTD. for magics
## License

This project is licensed under [**TOSSRCU**](LICENSE).
```diff
+ You are free to:
    • Use: Utilize the software for any purpose not explicitly restricted
    • Copy: Reproduce the software without limitation
    • Modify: Create derivative works through remixing/transforming
    • Merge: Combine with other materials
    • Publish: Display/communicate the software publicly
    • Distribute: Share copies of the software
    • Sublicense: Grant sublicenses for original/modified material

+ Under the following terms:
    • Attribution: Must include copyright notice and this license in all copies
    • Non-Commercial Restriction: Cannot use for commercial activities "as is" without written permission from the right holder

+ Disclaimer:
    • The Software is provided "AS IS", without warranty of any kind
    • The right holder is not liable for any claim, damages, or other liability

- You are not allowed to:
    • Commercial Use "AS IS": You cannot use the Software in its unmodified form for commercial activities without written permission from the right holder
```
**Note**: This section is a simplified summary. For the full legal terms, please refer to the [LICENSE](LICENSE) file.

- This project contains codes released into [**the public domain**](https://unlicense.org/).
- This project contains codes licensed under [**The MIT License**](https://opensource.org/license/mit).
- This project contains codes licensed under [**Apache License, Version 2.0**](https://www.apache.org/licenses/LICENSE-2.0).
- This project contains codes licensed under [**CC BY-NC-SA 4.0**](https://creativecommons.org/licenses/by-nc/4.0/).
- This project contains HarmonyOS Sans Fonts licensed under [**HARMONYOSSANS字体许可协议**](HARMONYOSSANS字体许可协议).
- This project contains images & texts licensed under [**CC BY-NC-SA 4.0**](https://creativecommons.org/licenses/by-nc/4.0/).



================================================
FILE: CS2x64.cc
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: CS2x64.cc
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file mainly manages the processing of game data in the Samidare project.
//
// -----------------------------------------------------------------------------
#include "pch.h"
#include "CS2x64.h"

#include "Offsets.h"
#include "UkiaStuff.h"
#include "Utils/XorStr.h"
#include "Utils/vphys_parser/ray_trace.h"
#include "maths.h"

inline size_t strlen_imp(const char* str) {
  size_t length = 0;
  while (str[length] != '\0') {
    length++;
  }
  return length;
}
inline int strcmpi_imp(const char* s1, const char* s2) {
#if defined(_WIN32)
  return _stricmp(s1, s2);
#else
  return strcasecmp(s1, s2);
#endif
}

DWORD64 GetConvar(const char* name) {
  if (!name) return 0;
  DWORD64 cvar_interface = gGame.GetTier0DLLAddress() + Offset::VEngineCvar007;

  DWORD64 objs;
  Ukia::ProcessMgr.ReadMemory(cvar_interface + 64, objs);

  DWORD convar_length = static_cast<DWORD>(strlen_imp(name));

  DWORD max_index;
  Ukia::ProcessMgr.ReadMemory(cvar_interface + 160, max_index);

  for (DWORD i = 0; i < max_index; i++) {
    DWORD64 entry;
    Ukia::ProcessMgr.ReadMemory(objs + 16 * i, entry);
    if (entry == 0) {
      break;
    }
    DWORD64 name_entry;
    char convar_name[120]{};
    Ukia::ProcessMgr.ReadMemory(entry + 0x00, name_entry);
    Ukia::ProcessMgr.ReadMemory(name_entry, convar_name, convar_length);
    convar_name[convar_length] = 0;

    if (!strcmpi_imp(convar_name, name)) {
      return entry;
    }
  }
  return 0;
}
template <typename ReadType>
bool GetConvarValue(const char* name, ReadType& Value) {
  DWORD64 convar = GetConvar(name);
  if (!convar) return false;
  return Ukia::ProcessMgr.ReadMemory(convar + 0x40, Value);
}

bool CBone::UpdateAllBoneData(const DWORD64& EntityPawnAddress) {
  if (EntityPawnAddress == 0) {
    return false;
  }
  this->EntityPawnAddress = EntityPawnAddress;

  DWORD64 GameSceneNode = 0;
  DWORD64 BoneArrayAddress = 0;
  if (!Ukia::ProcessMgr.ReadMemory<DWORD64>(
          EntityPawnAddress + Offset::C_BaseEntity.m_pGameSceneNode,
          GameSceneNode)) {
    return false;
  }
  if (!Ukia::ProcessMgr.ReadMemory<DWORD64>(
          GameSceneNode + Offset::Pawn.BoneArray, BoneArrayAddress)) {
    return false;
  }

  constexpr size_t NUM_BONES = 30;
  BoneJointData BoneArray[NUM_BONES]{};
  if (!Ukia::ProcessMgr.ReadMemory(BoneArrayAddress, BoneArray,
                                   NUM_BONES * sizeof(BoneJointData))) {
    return false;
  }

  BonePosList.clear();

  for (const auto& bone : BoneArray) {
    Vector2 ScreenPos;
    bool IsVisible = false;

    if (gGame.View.WorldToScreen(bone.Pos, ScreenPos)) {
      IsVisible = true;
    }

    this->BonePosList.push_back({bone.Pos, ScreenPos, IsVisible});
  }

  return !BonePosList.empty();
}
bool PlayerController::GetMoney() {
  DWORD64 MoneyServices;
  std::memcpy(&MoneyServices,
              this->ControllerBuffer.data() +
                  Offset::CCSPlayerController.m_pInGameMoneyServices,
              sizeof(MoneyServices));
  Ukia::ProcessMgr.GetDataAddressWithOffset<int>(
      MoneyServices, Offset::CCSPlayerController_InGameMoneyServices.m_iAccount,
      this->Money);
  Ukia::ProcessMgr.GetDataAddressWithOffset<int>(
      MoneyServices,
      Offset::CCSPlayerController_InGameMoneyServices.m_iTotalCashSpent,
      this->CashSpent);
  Ukia::ProcessMgr.GetDataAddressWithOffset<int>(
      MoneyServices,
      Offset::CCSPlayerController_InGameMoneyServices.m_iCashSpentThisRound,
      this->CashSpentTotal);
  return true;
}
bool PlayerController::GetTeamID() {
  std::memcpy(&this->TeamID,
              this->ControllerBuffer.data() + Offset::C_BaseEntity.m_iTeamNum,
              sizeof(this->TeamID));
  return true;
}
bool PlayerController::GetHealth() {
  std::memcpy(&this->Health,
              this->ControllerBuffer.data() + Offset::C_BaseEntity.m_iHealth,
              sizeof(this->Health));
  return true;
}
bool PlayerController::GetIsAlive() {
  std::memcpy(&this->AliveStatus,
              this->ControllerBuffer.data() +
                  Offset::CCSPlayerController.m_bPawnIsAlive,
              sizeof(this->AliveStatus));
  return true;
}
bool PlayerController::GetIsCtrlBot() {
  std::memcpy(&this->CtrlBot,
              this->ControllerBuffer.data() +
                  Offset::CCSPlayerController.m_bControllingBot,
              sizeof(this->CtrlBot));
  return true;
}
bool PlayerController::GetConnected() {
  std::memcpy(&this->Connected,
              this->ControllerBuffer.data() +
                  Offset::CCSPlayerController.m_bEverPlayedOnTeam,
              sizeof(this->Connected));
  return true;
}
bool PlayerController::GetHasHelmet() {
  std::memcpy(&this->HasHelmet,
              this->ControllerBuffer.data() +
                  Offset::CCSPlayerController.m_bPawnHasHelmet,
              sizeof(this->HasHelmet));
  return true;
}
bool PlayerController::GetPlayerSteamID() {
  std::memcpy(
      &this->SteamID,
      this->ControllerBuffer.data() + Offset::CBasePlayerController.m_steamID,
      sizeof(this->SteamID));
  return true;
}
bool PlayerController::GetPlayerName() {
  DWORD64 Addr;
  char Buffer[128]{};
  std::memcpy(&Addr,
              this->ControllerBuffer.data() +
                  Offset::CCSPlayerController.m_sSanitizedPlayerName,
              sizeof(Addr));
  if (!Ukia::ProcessMgr.ReadMemory(Addr, Buffer, 128)) return false;

  if (!this->SteamID)
    this->PlayerName = XorStr("BOT ") + std::string(Buffer);
  else
    this->PlayerName = Buffer;
  if (this->PlayerName.empty()) this->PlayerName = XorStr("Name_None");

  return true;
}
inline DWORD64 GethPawn(uint64_t Target) {
  DWORD64 EntityPawnListEntry = 0;
  DWORD64 EntityPawnAddress = 0;

  if (!Ukia::ProcessMgr.ReadMemory<DWORD64>(gGame.GetEntityListAddress(),
                                            EntityPawnListEntry))
    return 0;

  if (!Ukia::ProcessMgr.ReadMemory<DWORD64>(
          EntityPawnListEntry + 0x10 + 8 * ((Target & 0x7FFF) >> 9),
          EntityPawnListEntry))
    return 0;

  if (!Ukia::ProcessMgr.ReadMemory<DWORD64>(
          EntityPawnListEntry + 0x78 * (Target & 0x1FF), EntityPawnAddress))
    return 0;

  return EntityPawnAddress;
}
bool PlayerController::GetSpec() {
  uintptr_t pawn = this->GetPlayerhPawnAddress();

  uintptr_t obsService;
  Ukia::ProcessMgr.ReadMemory(
      pawn + Offset::C_BasePlayerPawn.m_pObserverServices, obsService);
  uint64_t obsTarget;
  Ukia::ProcessMgr.ReadMemory(
      obsService + Offset::CPlayer_ObserverServices.m_hObserverTarget,
      obsTarget);
  uintptr_t obsPawnHandle = GethPawn(obsTarget);

  if (obsPawnHandle == gamevars::LocalPawnAddress) {
    this->IsSpec = true;
  } else
    this->IsSpec = false;
  return true;
}
DWORD64 PlayerController::GetPlayerPawnAddress() {
  std::memcpy(
      &this->Pawn,
      this->ControllerBuffer.data() + Offset::CCSPlayerController.m_hPlayerPawn,
      sizeof(this->Pawn));

  return GethPawn(this->Pawn);
}

DWORD64 PlayerController::GetPlayerhPawnAddress() {
  std::memcpy(
      &this->Pawn,
      this->ControllerBuffer.data() + Offset::CBasePlayerController.m_hPawn,
      sizeof(this->Pawn));

  return GethPawn(this->Pawn);
}

bool PlayerPawn::GetPos() {
  DWORD64 GameSceneNode;
  std::memcpy(&GameSceneNode,
              this->PawnBuffer.data() + Offset::C_BaseEntity.m_pGameSceneNode,
              sizeof(GameSceneNode));
  if (!Ukia::ProcessMgr.ReadMemory<bool>(
          GameSceneNode + Offset::CGameSceneNode.m_bDormant, this->IsDormanted))
    return false;

  if (!Ukia::ProcessMgr.ReadMemory<Vector3>(
          GameSceneNode + Offset::CGameSceneNode.m_vecOrigin, this->Pos))
    return false;
  gGame.View.WorldToScreen(this->Pos, this->ScreenPos);
  return true;
  // return GetDataAddressWithOffset<Vec3>(Address,
  // Offset::C_BasePlayerPawn.m_vOldOrigin, this->Pos);
}
bool PlayerPawn::GetHeight() {
  DWORD64 Collision;
  std::memcpy(&Collision,
              this->PawnBuffer.data() + Offset::C_BaseEntity.m_pCollision,
              sizeof(Collision));
  if (!Ukia::ProcessMgr.ReadMemory<Vector3>(
          Collision + Offset::CCollisionProperty.m_vecMins, this->MinPos))
    return false;
  if (!Ukia::ProcessMgr.ReadMemory<Vector3>(
          Collision + Offset::CCollisionProperty.m_vecMaxs, this->MaxPos))
    return false;
  this->Height = this->MaxPos.z - this->MinPos.z;
  this->Width = (Vector2{this->MaxPos.x, this->MaxPos.y} -
                 Vector2{this->MinPos.x, this->MinPos.y})
                    .Length();
  return true;
  // return GetDataAddressWithOffset<Vec3>(Address,
  // Offset::C_BasePlayerPawn.m_vOldOrigin, this->Pos);
}
bool PlayerPawn::GetViewAngle() {
  std::memcpy(
      &this->ViewAngle,
      this->PawnBuffer.data() + Offset::C_CSPlayerPawnBase.m_angEyeAngles,
      sizeof(this->ViewAngle));
  return true;
}

bool PlayerPawn::GetCameraPos() {
  std::memcpy(&this->CameraPos,
              this->PawnBuffer.data() +
                  Offset::C_CSPlayerPawnBase.m_vecLastClipCameraPos,
              sizeof(this->CameraPos));
  return true;
}
bool PlayerPawn::GetWeaponName() {
  DWORD64 WeaponNameAddress = 0;
  // char Buffer[256]{};

  WeaponNameAddress = Ukia::ProcessMgr.TraceAddress(
      this->Address + Offset::C_CSPlayerPawnBase.m_pClippingWeapon,
      {0x10, 0x20, 0x0});
  if (WeaponNameAddress == 0) return false;

  auto sBuffer = Ukia::ProcessMgr.ReadString(WeaponNameAddress);

  if (!strstr(sBuffer.c_str(), "weapon_")) return false;

  sBuffer = sBuffer.substr(7);  // get rid of weapon_ prefix
  this->WeaponName = sBuffer;
  return true;
}

bool PlayerPawn::GetShotsFired() {
  std::memcpy(&this->ShotsFired,
              this->PawnBuffer.data() + Offset::C_CSPlayerPawn.m_iShotsFired,
              sizeof(this->ShotsFired));
  return true;
}

bool PlayerPawn::GetScoped() {
  std::memcpy(&this->Scoped,
              this->PawnBuffer.data() + Offset::C_CSPlayerPawn.m_bIsScoped,
              sizeof(this->Scoped));
  return true;
}

bool PlayerPawn::GetAimPunchAngle() {
  std::memcpy(&this->AimPunchAngle,
              this->PawnBuffer.data() + Offset::C_CSPlayerPawn.m_aimPunchAngle,
              sizeof(this->AimPunchAngle));
  return true;
}
bool PlayerPawn::GetHealth() {
  std::memcpy(&this->Health,
              this->PawnBuffer.data() + Offset::C_BaseEntity.m_iHealth,
              sizeof(this->Health));
  return true;
}
bool PlayerPawn::GetTeamID() {
  std::memcpy(&this->TeamID,
              this->PawnBuffer.data() + Offset::C_BaseEntity.m_iTeamNum,
              sizeof(this->TeamID));
  return true;
}
bool PlayerPawn::GetFov() {
  DWORD64 CameraServices = 0;
  std::memcpy(
      &CameraServices,
      this->PawnBuffer.data() + Offset::C_BasePlayerPawn.m_pCameraServices,
      sizeof(CameraServices));
  return Ukia::ProcessMgr.GetDataAddressWithOffset<int>(
      CameraServices, Offset::CCSPlayerBase_CameraServices.m_iFOVStart,
      this->Fov);
}
bool PlayerPawn::GetSpotted() {
  std::memcpy(&this->bSpottedByMask,
              this->PawnBuffer.data() + Offset::C_CSPlayerPawn.m_bSpottedByMask,
              sizeof(this->bSpottedByMask));
  return true;
}
bool PlayerPawn::GetFFlags() {
  std::memcpy(&this->fFlags,
              this->PawnBuffer.data() + Offset::C_BaseEntity.m_fFlags,
              sizeof(this->fFlags));
  return true;
}
bool PlayerPawn::GetAimPunchCache() {
  std::memcpy(&this->AimPunchCache,
              this->PawnBuffer.data() + Offset::C_CSPlayerPawn.m_aimPunchCache,
              sizeof(this->AimPunchCache));
  return true;
}
bool PlayerPawn::GetAmmo() {
  DWORD64 ClippingWeapon = 0;
  std::memcpy(
      &ClippingWeapon,
      this->PawnBuffer.data() + Offset::C_CSPlayerPawnBase.m_pClippingWeapon,
      sizeof(ClippingWeapon));

  return Ukia::ProcessMgr.GetDataAddressWithOffset<int>(
      ClippingWeapon, Offset::WeaponBaseData.Clip1, this->Ammo);
}

bool PlayerPawn::GetMaxAmmo() {
  DWORD64 ClippingWeapon = 0;
  DWORD64 WeaponData = 0;
  std::memcpy(
      &ClippingWeapon,
      this->PawnBuffer.data() + Offset::C_CSPlayerPawnBase.m_pClippingWeapon,
      sizeof(ClippingWeapon));
  if (!Ukia::ProcessMgr.ReadMemory<DWORD64>(
          ClippingWeapon + Offset::WeaponBaseData.WeaponDataPTR, WeaponData))
    return false;

  return Ukia::ProcessMgr.GetDataAddressWithOffset<int>(
      WeaponData, Offset::WeaponBaseData.MaxClip, this->MaxAmmo);
}
bool PlayerPawn::GetIsAuto() {
  DWORD64 ClippingWeapon = 0;
  DWORD64 WeaponData = 0;
  std::memcpy(
      &ClippingWeapon,
      this->PawnBuffer.data() + Offset::C_CSPlayerPawnBase.m_pClippingWeapon,
      sizeof(ClippingWeapon));
  if (!Ukia::ProcessMgr.ReadMemory<DWORD64>(
          ClippingWeapon + Offset::WeaponBaseData.WeaponDataPTR, WeaponData))
    return false;

  return Ukia::ProcessMgr.GetDataAddressWithOffset<bool>(
      WeaponData, Offset::WeaponBaseData.m_bIsFullAuto, this->IsAuto);
}
bool PlayerPawn::GetArmor() {
  std::memcpy(&this->Armor,
              this->PawnBuffer.data() + Offset::C_CSPlayerPawn.m_ArmorValue,
              sizeof(this->Armor));
  return true;
}
bool PlayerPawn::GetFlashDuration() {
  std::memcpy(
      &this->FlashDuration,
      this->PawnBuffer.data() + Offset::C_CSPlayerPawnBase.m_flFlashDuration,
      sizeof(this->FlashDuration));
  return true;
}
bool PlayerPawn::GetIsImmunity() {
  std::memcpy(
      &this->isImmunity,
      this->PawnBuffer.data() + Offset::C_CSPlayerPawnBase.m_bGunGameImmunity,
      sizeof(this->isImmunity));
  return true;
}
bool PlayerPawn::GetVelocity() {
  std::memcpy(&this->Velocity,
              this->PawnBuffer.data() + Offset::C_BaseEntity.m_vecAbsVelocity,
              sizeof(this->Velocity));
  this->Speed = sqrt(this->Velocity.x * this->Velocity.x +
                     this->Velocity.y * this->Velocity.y);
  return true;
}

bool PlantedC4::GetIsPlanted() {
  std::memcpy(&this->isPlanted,
              this->c4Buffer.data() + Offset::C_PlantedC4.m_bC4Activated,
              sizeof(this->isPlanted));
  return true;
}
bool PlantedC4::GetIsDefusing() {
  std::memcpy(&this->isDefusing,
              this->c4Buffer.data() + Offset::C_PlantedC4.m_bBeingDefused,
              sizeof(this->isDefusing));
  return true;
}
bool PlantedC4::GetHasExploded() {
  std::memcpy(&this->hasExploded,
              this->c4Buffer.data() + Offset::C_PlantedC4.m_bHasExploded,
              sizeof(this->hasExploded));
  return true;
}
bool PlantedC4::GetBoomTime() {
  std::memcpy(&this->boomTime,
              this->c4Buffer.data() + Offset::C_PlantedC4.m_flC4Blow,
              sizeof(this->boomTime));
  return true;
}

bool PlantedC4::GetDefuseTime() {
  std::memcpy(&this->defuseTime,
              this->c4Buffer.data() + Offset::C_PlantedC4.m_flDefuseCountDown,
              sizeof(this->defuseTime));
  return true;
}
bool PlantedC4::GetBoomRemaining() {
  if (!this->isPlanted)
    this->boomRemaining = 0;
  else
    this->boomRemaining = this->boomTime - gamevars::CurTime;
  return true;
}
bool PlantedC4::GetDefuseRemaining() {
  if (!this->isDefusing)
    this->defuseRemaining = 0;
  else
    this->defuseRemaining = this->defuseTime - gamevars::CurTime;
  return true;
}
bool PlantedC4::GetBombSite() {
  std::memcpy(&this->bombSite,
              this->c4Buffer.data() + Offset::C_PlantedC4.m_nBombSite,
              sizeof(this->bombSite));
  return true;
}
bool PlantedC4::GetBombPos() {
  DWORD64 GameSceneNode;
  std::memcpy(&GameSceneNode,
              this->c4Buffer.data() + Offset::C_BaseEntity.m_pGameSceneNode,
              sizeof(GameSceneNode));
  if (!Ukia::ProcessMgr.ReadMemory<Vector3>(
          GameSceneNode + Offset::CGameSceneNode.m_vecOrigin, this->Pos))
    this->Pos = {0, 0, 0};
  return true;
}

bool PlantedC4::UpdatePlantedC4(const DWORD64& PlantedC4Address) {
  if (PlantedC4Address == 0) return false;
  this->Address = PlantedC4Address;
  Ukia::ProcessMgr.ReadMemory(this->Address, this->c4Buffer);

  if (!this->GetIsPlanted()) return false;
  if (!this->GetIsDefusing()) return false;
  if (!this->GetHasExploded()) return false;
  if (!this->GetBoomTime()) return false;
  if (!this->GetDefuseTime()) return false;
  if (!this->GetBoomRemaining()) return false;
  if (!this->GetDefuseRemaining()) return false;
  if (!this->GetBombSite()) return false;
  if (!this->GetBombPos()) return false;
  return true;
}

// 更新数据
bool CEntity::UpdateController(const DWORD64& PlayerControllerAddress) {
  if (PlayerControllerAddress == 0) return false;
  this->Controller.Address = PlayerControllerAddress;
  Ukia::ProcessMgr.ReadMemory(this->Controller.Address,
                              this->Controller.ControllerBuffer);
  if (!this->Controller.GetHealth()) return false;
  if (!this->Controller.GetIsAlive()) return false;
  if (!this->Controller.GetIsCtrlBot()) return false;
  if (!this->Controller.GetConnected()) return false;
  if (!this->Controller.GetHasHelmet()) return false;
  if (!this->Controller.GetTeamID()) return false;
  if (!this->Controller.GetPlayerSteamID()) return false;
  if (!this->Controller.GetPlayerName()) return false;
  if (!this->Controller.GetSpec()) return false;
  if (!this->Controller.GetMoney()) return false;

  this->Pawn.Address =
      this->Controller
          .GetPlayerhPawnAddress();  // this->Controller.GetPlayerPawnAddress();
  return true;
}
bool CEntity::UpdatePawn(const DWORD64& PlayerPawnAddress) {
  if (PlayerPawnAddress == 0) return false;
  this->Pawn.Address = PlayerPawnAddress;
  Ukia::ProcessMgr.ReadMemory(this->Pawn.Address, this->Pawn.PawnBuffer);
  if (!this->Pawn.GetCameraPos()) return false;
  if (!this->Pawn.GetPos()) return false;
  if (!this->Pawn.GetHeight()) return false;
  if (!this->Pawn.GetViewAngle()) return false;
  if (!this->Pawn.GetWeaponName()) return false;
  if (!this->Pawn.GetAimPunchAngle()) return false;
  if (!this->Pawn.GetShotsFired()) return false;
  if (!this->Pawn.GetScoped()) return false;
  if (!this->Pawn.GetHealth()) return false;
  if (!this->Pawn.GetAmmo()) return false;
  if (!this->Pawn.GetMaxAmmo()) return false;
  if (!this->Pawn.GetIsAuto()) return false;
  if (!this->Pawn.GetArmor()) return false;
  if (!this->Pawn.GetTeamID()) return false;
  if (!this->Pawn.GetFov()) return false;
  if (!this->Pawn.GetSpotted()) return false;
  if (!this->Pawn.GetFFlags()) return false;
  if (!this->Pawn.GetFlashDuration()) return false;
  if (!this->Pawn.GetIsImmunity()) return false;
  if (!this->Pawn.GetVelocity()) return false;
  if (!this->Pawn.GetAimPunchCache()) return false;
  if (!this->Pawn.BoneData.UpdateAllBoneData(PlayerPawnAddress)) return false;

  return true;
}

bool CEntity::IsEnemy() {
  if (!config::TeamCheck || gamevars::FreeFire) return true;
  if (this->Controller.TeamID == gamevars::LocalEntity.Controller.TeamID)
    return false;
  if (this->Pawn.TeamID == gamevars::LocalEntity.Pawn.TeamID) return false;
  return true;
}

bool CEntity::IsVisible() {
  if (!this->IsInScreen()) return false;
  if (gamevars::IsMapFileExist) {
    std::lock_guard<std::mutex> lock(gamevars::VisibleEntityAddrMutex);
    bool ParserVisible =
        std::find(gamevars::VisibleEntityAddr.begin(),
                  gamevars::VisibleEntityAddr.end(),
                                   this->Controller.Address) !=
                         gamevars::VisibleEntityAddr.end();
    // bool SpottedVisible = this->Pawn.bSpottedByMask;
    return (ParserVisible /* || SpottedVisible*/);
  } else {
    return this->Pawn.bSpottedByMask;
  }
}

namespace gamevars {

map_loader ParsingMap;
std::string ParsingMapName = {};

void ParserRun() noexcept {
  if (!IsInGame) return;

  std::string mapPath = config::path + XorStr("\\Maps\\") + MapName;
  if (MapName != ParsingMapName) {
    if (IsMapFileExist) {
      ParsingMap.unload();
      IsMapFileExist = false;
    }
    std::ifstream in(mapPath + ".tri.minz", std::ios::in | std::ios::binary);
    if (!in) {
      IsMapFileExist = false;
    } else {
      in.close();
      ParsingMapName = MapName;
      ParsingMap.load_map(mapPath);
      IsMapFileExist = true;
    }
  }
  std::vector<DWORD64> tempVisibleEntityAddr;
  std::lock_guard<std::mutex> lock(validEntityMutex);
  for (int index = 0; index < ValidEntity.size(); index++) {
    CEntity Entity = ValidEntity[index].first;
    DWORD64 EntityAddress = ValidEntity[index].second;

    if (!Entity.IsEnemy()) continue;  // might someday remove this

    if (Entity.Pawn.IsDormanted) continue;

    if (!Entity.ESPAlive()) continue;

    if (!Entity.IsInScreen()) continue;
    Vector r_start = Vector(LocalEntity.Pawn.CameraPos.x,
                            LocalEntity.Pawn.CameraPos.y,
                            LocalEntity.Pawn.CameraPos.z);
    Vector r_end = Vector(Entity.Pawn.Pos.x, Entity.Pawn.Pos.y,
                          Entity.Pawn.Pos.z + 0.45f * Entity.Pawn.Height);
    if (!ParsingMap.is_visible(r_start, r_end)) continue;
    tempVisibleEntityAddr.push_back(EntityAddress);
  }
  std::lock_guard<std::mutex> lock0(VisibleEntityAddrMutex);
  VisibleEntityAddr.clear();
  VisibleEntityAddr.reserve(tempVisibleEntityAddr.size());
  for (DWORD64 theVisibleEntityAddress : tempVisibleEntityAddr) {
    VisibleEntityAddr.emplace_back(theVisibleEntityAddress);
  }
}

inline void InGameCheck() {
  /*
    DWORD game_state;
  Ukia::ProcessMgr.ReadMemory(gGame.GetEngineDLLAddress()+
  Offset::dwNetworkGameClient_signOnState, game_state); std::cout << game_state
  << std::endl; if (game_state != 6) { IsInGame = false; return;
    }

    */
  if (MapName.empty() || MapName == XorStr("<empty>") ||
      MapName == XorStr("SNDLVL_35dB")) {
    IsInGame = false;
    return;
  }
  IsInGame = true;
  return;
}

inline bool GetSensitivity() {
  DWORD64 dwSensitivity;
  float flSensitivity;
  Ukia::ProcessMgr.ReadMemory(
      gGame.GetClientDLLAddress() + Offset::dwSensitivity, dwSensitivity);
  if (Ukia::ProcessMgr.ReadMemory(dwSensitivity + Offset::Sensitivity,
                                  flSensitivity)) {
    Sensitivity = flSensitivity;
    return true;
  } else
    return false;
}
void UpdateDataSlow() {
  if (!Ukia::ProcessMgr.ReadMemory<CGlobalVarsBase>(
          gGame.GetGlobalVarsAddress(), Global_Vars))
    return;
  MapName = Ukia::ProcessMgr.ReadString(Global_Vars.m_current_mapname, 32);
  CurTime = Global_Vars.m_curtime;
  TickCount = Global_Vars.m_tickcount;
  FrameTime = Global_Vars.m_frametime;
  UpdateIntervals();
  GetConvarValue(XorStr("mp_teammates_are_enemies"), FreeFire);
  InGameCheck();
  GetSensitivity();
  if (!IsInGame) return;

  DWORD64 PlantedC4PTRAddress = 0;
  if (!Ukia::ProcessMgr.ReadMemory(gGame.GetPlantedC4PTRAddress(),
                                   PlantedC4PTRAddress))
    return;
  if (!Ukia::ProcessMgr.ReadMemory(PlantedC4PTRAddress, PlantedC4Address))
    return;
  if (!PlantedBomb.UpdatePlantedC4(PlantedC4Address)) return;
}
void UpdateData() {
  if (!global::isFocused()) return;
  if (!Ukia::ProcessMgr.ReadMemory(gGame.GetMatrixAddress(), gGame.View.Matrix,
                                   64))
    return;

  if (!gGame.UpdateEntityListEntry()) return;
  if (!Ukia::ProcessMgr.ReadMemory(gGame.GetLocalControllerAddress(),
                                   LocalControllerAddress))
    return;
  if (!Ukia::ProcessMgr.ReadMemory(gGame.GetLocalPawnAddress(),
                                   LocalPawnAddress))
    return;
  if (!LocalEntity.UpdateController(LocalControllerAddress)) return;
  if (!LocalEntity.UpdatePawn(LocalPawnAddress) && !config::WorkInSpec) return;

  if (global::user_name == std::getenv(XorStr("USERNAME")))
    global::user_name = LocalEntity.Controller.PlayerName;
  if (!IsInGame) {
    std::lock_guard<std::mutex> lock(validEntityMutex);
    ValidEntity.clear();
    return;
  }

  std::vector<std::pair<std::shared_ptr<CEntity>, DWORD64>> tempValidEntity;

  constexpr int MAX_ENTITY = 64;
  constexpr int ENTITY_STRIDE = 0x78;
  std::array<char, MAX_ENTITY * ENTITY_STRIDE> entityAddresses{};

  Ukia::ProcessMgr.ReadMemory(gGame.GetEntityListEntry() + 0x78,
                              entityAddresses, MAX_ENTITY * ENTITY_STRIDE);

  for (int i = 0; i <= MAX_ENTITY; i++) {
    DWORD64 EntityAddress;
    std::memcpy(&EntityAddress, entityAddresses.data() + i * ENTITY_STRIDE,
                sizeof(DWORD64));

    if (EntityAddress == 0) continue;
    if (EntityAddress == LocalEntity.Controller.Address) {
      LocalPlayerControllerIndex = i;
      continue;
    }
    auto Entity = std::make_shared<CEntity>();
    if (!Entity->UpdateController(EntityAddress)) continue;
    Entity->UpdatePawn(Entity->Pawn.Address);
    // here,grab it.
    tempValidEntity.push_back(std::make_pair(Entity, EntityAddress));
  }
  std::lock_guard<std::mutex> lock(validEntityMutex);
  ValidEntity.clear();
  ValidEntity.reserve(tempValidEntity.size());

  for (auto& pair : tempValidEntity) {
    ValidEntity.emplace_back(*pair.first, pair.second);
  }
}

void UpdateIntervals() {
  RenderInterval =
      config::RenderInterval ? config::RenderInterval : static_cast<int>(std::floor(FrameTime));
  GlobalVarsInterval = config::GlobalVarsInterval ? config::GlobalVarsInterval
                           : static_cast<int>(std::floor(FrameTime));
  EntityInterval = config::EntityInterval
                       ? config::EntityInterval
                       : static_cast<int>(std::floor(FrameTime));
  ParserInterval = config::ParserInterval
                       ? config::ParserInterval
                       : static_cast<int>(std::floor(FrameTime));
  AimInterval = config::AimInterval ? config::AimInterval
                                    : static_cast<int>(std::floor(FrameTime));
  ViewInterval = config::ViewInterval ? config::ViewInterval
                                      : static_cast<int>(std::floor(FrameTime));
  MemoryInterval =
      config::MemoryInterval ? config::MemoryInterval : static_cast<int>(std::floor(FrameTime));
  NonMemoryInterval = config::NonMemoryInterval ? config::NonMemoryInterval
                                                : static_cast<int>(std::floor(FrameTime));
}

}  // namespace Vars



================================================
FILE: CS2x64.h
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: CS2x64.h
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file mainly manages the processing of game data in the Samidare
//   project.
//
// -----------------------------------------------------------------------------
#pragma once
#ifndef CS2X64_H_
#define CS2X64_H_
#include "pch.h"
#include "Functions/ConfigSaver.h"
#include "Game.h"

#ifndef CS_VERSION
#define CS_VERSION 14084
#endif

enum BONEINDEX : DWORD {
  head = 6,
  neck_0 = 5,
  spine_1 = 4,
  spine_2 = 2,
  pelvis = 0,
  arm_upper_L = 8,
  arm_lower_L = 9,
  hand_L = 10,
  arm_upper_R = 13,
  arm_lower_R = 14,
  hand_R = 15,
  leg_upper_L = 22,
  leg_lower_L = 23,
  ankle_L = 24,
  leg_upper_R = 25,
  leg_lower_R = 26,
  ankle_R = 27,
};

struct BoneJointData {
  Vector3 Pos;
  float Scale;
  char pad[0x10];
};

struct BoneJointPos {
  Vector3 Pos;
  Vector2 ScreenPos;
  bool IsVisible = false;
};

class CBone {
 private:
  DWORD64 EntityPawnAddress = 0;

 public:
  std::vector<BoneJointPos> BonePosList;

  bool UpdateAllBoneData(const DWORD64& EntityPawnAddress);
};

struct C_UTL_VECTOR {
  DWORD64 Count = 0;
  DWORD64 Data = 0;
};

class PlayerController {
 public:
  std::array<char, 0x8CF> ControllerBuffer{};

  DWORD64 Address = 0;
  int Money = 0;
  int CashSpent = 0;
  int CashSpentTotal = 0;
  int TeamID = 0;
  int Health = 0;
  int AliveStatus = 0;
  int CtrlBot = 0;
  bool Connected = false;
  bool HasHelmet = false;
  bool IsSpec = false;
  INT64 SteamID = 0;
  std::string PlayerName;
  DWORD Pawn = 0;

 public:
  bool GetMoney();
  bool GetTeamID();
  bool GetHealth();
  bool GetIsAlive();
  bool GetIsCtrlBot();
  bool GetConnected();
  bool GetHasHelmet();
  bool GetPlayerSteamID();
  bool GetPlayerName();
  bool GetSpec();
  DWORD64 GetPlayerPawnAddress();

  DWORD64 GetPlayerhPawnAddress();
};

class PlayerPawn {
 public:
  std::array<char, 0x25CF> PawnBuffer{};

  enum class Flags { NONE, IN_AIR = 1 << 0, IN_CROUCH = 1 << 1 };

  DWORD64 Address = 0;
  CBone BoneData;
  Vector2 ViewAngle;
  bool IsDormanted;
  Vector3 Pos;
  Vector2 ScreenPos;
  Vector3 CameraPos;
  Vector3 MaxPos;
  Vector3 MinPos;
  float Height;
  float Width;
  Vector3 Velocity;
  float Speed;
  std::string WeaponName;
  DWORD ShotsFired;
  bool Scoped;
  Vector3 AimPunchAngle;
  C_UTL_VECTOR AimPunchCache;
  int Health;
  int Ammo;
  int MaxAmmo;
  bool IsAuto;
  int Armor;
  int TeamID;
  int Fov;
  bool bSpottedByMask;
  int fFlags;
  float FlashDuration;
  bool isImmunity;

 public:
  bool GetPos();
  bool GetHeight();
  bool GetViewAngle();

  bool GetCameraPos();
  bool GetWeaponName();
  bool GetShotsFired();
  bool GetScoped();
  bool GetAimPunchAngle();
  bool GetHealth();
  bool GetTeamID();
  bool GetFov();
  bool GetSpotted();
  bool GetFFlags();
  bool GetAimPunchCache();
  bool GetAmmo();
  bool GetMaxAmmo();
  bool GetIsAuto();
  bool GetArmor();
  bool GetFlashDuration();
  bool GetIsImmunity();
  bool GetVelocity();
  constexpr bool HasFlag(const Flags Flag) const noexcept {
    return fFlags & (int)Flag;
  }
};

class CEntity {
 public:
  PlayerController Controller;
  PlayerPawn Pawn;

 public:
  // 更新数据
  bool UpdateController(const DWORD64& PlayerControllerAddress);
  bool UpdatePawn(const DWORD64& PlayerPawnAddress);

  // 是否存活
  inline bool IsAlive() {
    return (this->Controller.AliveStatus == 1 ||
            this->Controller.CtrlBot == 1) &&
           this->Pawn.Health > 0;
  }
  inline bool ESPAlive() { return this->Pawn.Health > 0; }
  // 是否在屏幕内
  inline bool IsInScreen() {
    return gGame.View.WorldToScreen(this->Pawn.Pos, this->Pawn.ScreenPos);
  }
  // 获取骨骼数据
  inline CBone GetBone() const {
    if (this->Pawn.Address == 0) return CBone{};
    return this->Pawn.BoneData;
  }

  bool IsEnemy();
  bool IsVisible();
};

class PlantedC4 {
 public:
  std::array<char, 0x14DF> c4Buffer{};

  DWORD64 Address = 0;
  Vector3 Pos;
  bool isPlanted = false;
  bool isDefusing = false;
  bool hasExploded = false;
  float boomTime = 0;
  float defuseTime = 0;
  float boomRemaining = 0;
  float defuseRemaining = 0;
  int bombSite = -1;

 public:
  bool GetIsPlanted();
  bool GetIsDefusing();
  bool GetHasExploded();
  bool GetBoomTime();
  bool GetDefuseTime();
  bool GetBoomRemaining();
  bool GetDefuseRemaining();
  bool GetBombSite();
  bool GetBombPos();

  bool UpdatePlantedC4(const DWORD64& PlantedC4PTRAddress);
};

namespace gamevars {
inline std::mutex validEntityMutex;
inline std::mutex VisibleEntityAddrMutex;

inline DWORD64 LocalControllerAddress = 0;
inline DWORD64 LocalPawnAddress = 0;
inline DWORD64 PlantedC4Address = 0;
inline CEntity LocalEntity, ServerEntity;
inline PlantedC4 PlantedBomb;
inline int LocalPlayerControllerIndex = 1;
inline DWORD GameVersion = 0;
inline CGlobalVarsBase Global_Vars = {};
inline std::string MapName = {};
inline float CurTime = 0;
inline int32_t TickCount = 0;
inline float FrameTime = 0;
inline std::vector<std::pair<CEntity, DWORD64>> ValidEntity = {};
inline std::vector<DWORD64> VisibleEntityAddr = {};
inline bool FreeFire = false;
inline bool IsInGame = false;
inline float Sensitivity = 0.f;
inline bool IsMapFileExist = false;

inline int RenderInterval = 0;
inline int GlobalVarsInterval = 15;
inline int EntityInterval = 1;
inline int ParserInterval = 100;
inline int AimInterval = 1;
inline int ViewInterval = 1;
inline int MemoryInterval = 15;
inline int NonMemoryInterval = 1;

inline bool IsAimbotting = false;

void ParserRun() noexcept;
void UpdateDataSlow();
void UpdateData();
void UpdateIntervals();
}  // namespace Vars

namespace DirectX9Interface {
inline IDirect3D9Ex* Direct3D9 = NULL;
inline IDirect3DDevice9Ex* pDevice = NULL;
inline D3DPRESENT_PARAMETERS pParams = {NULL};
inline MARGINS Margin = {-1};
inline MSG Message = {NULL};
}  // namespace DirectX9Interface

namespace OverlayWindow {
inline WNDCLASSEXA WindowClass;
inline HWND Hwnd;
inline LPCSTR Name;
}  // namespace OverlayWindow
#endif  // CS2X64_H_



================================================
FILE: Driver.h
================================================
﻿#pragma once
#include <fileapi.h>
#include <handleapi.h>
#include <ioapiset.h>
#include <libloaderapi.h>
#include <processthreadsapi.h>
#include <vadefs.h>
#include <winioctl.h>

#include <cstdint>
#include <cstdio>
#include <string>

constexpr ULONG ioctl_call_driver =
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x775, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);

class _driver {
 private:
  HANDLE _driver_handle;
  UINT64 _processid;
  UINT64 _cur_processid;
  // ULONG64 _dlladdress;

// request codes
#define DRIVER_READVM 0xCAFE1
#define DRIVER_WRITEVM 0xCAFE2
#define HID 0xCAFE3
#define DLL_BASE 0xCAFE4

#pragma pack(push, 1)
  typedef struct _FixedStr64 {
    uint64_t blocks[4];
  } FixedStr64;
#pragma pack(pop)
  inline void encodeFixedStr64(const char* str, FixedStr64* fs) {
    size_t len = strlen(str);
    if (len > 32) {
      len = 32;
    }

    memset(fs->blocks, 0, sizeof(fs->blocks));

    for (size_t i = 0; i < len; i++) {
      size_t blockIndex = i / 8;
      size_t posInBlock = i % 8;
      int shift = static_cast<int>(8 * (7 - posInBlock));
      fs->blocks[blockIndex] |= ((uint64_t)(unsigned char)str[i]) << shift;
    }
  }

  inline void decodeFixedStr64(const FixedStr64* fs, char* output,
                               size_t origLen) {
    size_t idx = 0;
    for (size_t block = 0; block < 4; block++) {
      for (int i = 0; i < 8; i++) {
        if (idx >= origLen) break;
        int shift = 8 * (7 - i);
        output[idx++] = (char)((fs->blocks[block] >> shift) & 0xFF);
      }
    }
    output[origLen] = '\0';
  }
#pragma pack(push, 1)
  typedef struct _Requests {
    // function requests
    int request_key;

    // memory read/write
    UINT64 src_pid;
    UINT64 src_addr;
    UINT64 dst_pid;
    UINT64 dst_addr;
    size_t size;

    // mouse_event
    DWORD dwFlags;
    DWORD dx;
    DWORD dy;
    DWORD dwData;
    ULONG_PTR dwExtraInfo;

    // return value
    UINT64 dll_base;

    // dllbase request
    FixedStr64 dll_name;
    SIZE_T dll_name_length;
  } Requests;
#pragma pack(pop)
  auto readvm(uint32_t src_pid, uint64_t src_addr, uint64_t dst_addr,
              size_t size) -> void {
    if (src_pid == 0 || src_addr == 0) return;

    Requests out = {DRIVER_READVM,  src_pid,  src_addr,
                    _cur_processid, dst_addr, size};

    DeviceIoControl(_driver_handle, ioctl_call_driver, &out, sizeof(out),
                    nullptr, 0, nullptr, nullptr);
  }
  auto writevm(uint32_t src_pid, uint64_t src_addr, uint64_t dst_addr,
               size_t size) -> void {
    if (src_pid == 0 || dst_addr == 0) return;

    Requests out = {DRIVER_WRITEVM, src_pid,  src_addr,
                    _cur_processid, dst_addr, size};

    DeviceIoControl(_driver_handle, ioctl_call_driver, &out, sizeof(out),
                    nullptr, 0, nullptr, nullptr);
  }

 public:
  auto initdriver(UINT64 processid) -> void {
    _driver_handle = CreateFileA("\\\\.\\Usugum0", GENERIC_READ, 0, nullptr,
                                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                 nullptr);  // get a handle to our driver
    if (_driver_handle != INVALID_HANDLE_VALUE) {
      _processid = processid;
      _cur_processid = GetCurrentProcessId();
    }
  }

  void readsize(const uintptr_t address, const void* buffer,
                const size_t size) {
    readvm(static_cast<uint32_t>(_processid), address, uintptr_t(buffer), size);
  }

  template <typename T>
  void write(const uintptr_t address, const T& buffer, int Size) {
    writevm(_processid, address, (uintptr_t)&buffer, Size);
  }
  auto dll_address(const char* dllname) -> ULONG64 {
    Requests out = {0};
    out.request_key = DLL_BASE;
    out.src_pid = _processid;

    size_t originalLen = strlen(dllname);
    if (originalLen > 32) originalLen = 32;
    out.dll_name_length = originalLen;
    FixedStr64 fs;
    encodeFixedStr64(dllname, &fs);
    out.dll_name = fs;

    DeviceIoControl(_driver_handle, ioctl_call_driver, &out, sizeof(out), &out,
                    sizeof(out), nullptr, nullptr);

    return out.dll_base;
  }

  void mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData,
                   ULONG_PTR dwExtraInfo) {
    Requests request = {0};
    request.request_key = HID;
    request.dwFlags = dwFlags;
    request.dx = dx;
    request.dy = dy;
    request.dwData = dwData;
    request.dwExtraInfo = dwExtraInfo;

    DeviceIoControl(_driver_handle, ioctl_call_driver, &request,
                    sizeof(request), nullptr, 0, nullptr, nullptr);
  }
};

inline _driver driver;






================================================
FILE: entry_point.cc
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: entrypoint.cc
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-28
//
// Description:
//   This file is entry point for Samidare.
//
// -----------------------------------------------------------------------------
#include "pch.h"

#include "Functions/Func.h"
#include "Game.h"
#include "Lang.h"
#include "UkiaStuff.h"
#include "Utils/uiaccess.h"
#include "shigure.h"
#include "zekamashi.h"

enum ZBID {
  ZBID_DEFAULT = 0,
  ZBID_DESKTOP = 1,
  ZBID_UIACCESS = 2,
  ZBID_IMMERSIVE_IHM = 3,
  ZBID_IMMERSIVE_NOTIFICATION = 4,
  ZBID_IMMERSIVE_APPCHROME = 5,
  ZBID_IMMERSIVE_MOGO = 6,
  ZBID_IMMERSIVE_EDGY = 7,
  ZBID_IMMERSIVE_INACTIVEMOBODY = 8,
  ZBID_IMMERSIVE_INACTIVEDOCK = 9,
  ZBID_IMMERSIVE_ACTIVEMOBODY = 10,
  ZBID_IMMERSIVE_ACTIVEDOCK = 11,
  ZBID_IMMERSIVE_BACKGROUND = 12,
  ZBID_IMMERSIVE_SEARCH = 13,
  ZBID_GENUINE_WINDOWS = 14,
  ZBID_IMMERSIVE_RESTRICTED = 15,
  ZBID_SYSTEM_TOOLS = 16,
  // Win10
  ZBID_LOCK = 17,
  ZBID_ABOVELOCK_UX = 18,
};

typedef HWND(WINAPI* CreateWindowInBand)(
    _In_ DWORD dwExStyle, _In_opt_ ATOM atom, _In_opt_ LPCWSTR lpWindowName,
    _In_ DWORD dwStyle, _In_ int X, _In_ int Y, _In_ int nWidth,
    _In_ int nHeight, _In_opt_ HWND hWndParent, _In_opt_ HMENU hMenu,
    _In_opt_ HINSTANCE hInstance, _In_opt_ LPVOID lpParam, DWORD band);

CreateWindowInBand pCreateWindowInBand =
    reinterpret_cast<CreateWindowInBand>(GetProcAddress(
        LoadLibraryA(XorStr("user32.dll")), XorStr("CreateWindowInBand")));

void JustGetWindowRect() {
  if (Ukia::IsFullscreen(global::game_hwnd)) {
    global::screen_size.x = static_cast<float>(GetSystemMetrics(SM_CXSCREEN));
    global::screen_size.y = static_cast<float>(GetSystemMetrics(SM_CYSCREEN));
    global::screen_pos.x = 0.f;
    global::screen_pos.y = 0.f;
  } else {
    RECT clientRect;
    if (GetClientRect(global::game_hwnd, &clientRect)) {
      int clientWidth = clientRect.right - clientRect.left;
      int clientHeight = clientRect.bottom - clientRect.top;

      global::screen_size.x = static_cast<float>(clientWidth);
      global::screen_size.y = static_cast<float>(clientHeight);
    } else {
      MessageBoxA(nullptr, XorStr("Failed to get window rect."),
                  XorStr("Samidare"), MB_OK);
      Ukia::UkiaExit();
    }
  }
}

extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd,
                                                             UINT msg,
                                                             WPARAM wParam,
                                                             LPARAM lParam);
LRESULT CALLBACK WinProc(HWND hWnd, UINT Message, WPARAM wParam,
                         LPARAM lParam) {
  if (ImGui_ImplWin32_WndProcHandler(hWnd, Message, wParam, lParam))
    return true;

  switch (Message) {
    case WM_DESTROY:
      if (DirectX9Interface::pDevice != NULL) {
        DirectX9Interface::pDevice->EndScene();
        DirectX9Interface::pDevice->Release();
      }
      if (DirectX9Interface::Direct3D9 != NULL) {
        DirectX9Interface::Direct3D9->Release();
      }
      PostQuitMessage(0);
      Ukia::UkiaExit(4);
      break;
    case WM_MOVE:
    case WM_SIZE:
      if (DirectX9Interface::pDevice != NULL && wParam != SIZE_MINIMIZED) {
        if (LOWORD(lParam) > 0 && HIWORD(lParam) > 0) {
          ImGui_ImplDX9_InvalidateDeviceObjects();
          DirectX9Interface::pParams.BackBufferWidth = LOWORD(lParam);
          DirectX9Interface::pParams.BackBufferHeight = HIWORD(lParam);
        }
      }
      break;
    default:
      return DefWindowProc(hWnd, Message, wParam, lParam);
      break;
  }
  return 0;
}

std::mutex g_d3dMutex;
struct WindowStateTracker {
  RECT oldRect = {0};
  bool lastMenuState = false;
  bool wasGameFocused = true;
  bool lastFullscreen = false;

  template <typename T>
  void UpdateWindowState(T&& checker) {
    lastFullscreen = checker();
  }
};

bool HandleFocusState(bool& wasFocused) {
  const HWND foreground = GetForegroundWindow();
  const bool focused =
      (foreground == global::game_hwnd) || (foreground == OverlayWindow::Hwnd);

  if (focused != wasFocused) {
    ShowWindow(OverlayWindow::Hwnd, focused ? SW_SHOW : SW_HIDE);
    if (focused) {
      SetWindowPos(OverlayWindow::Hwnd, HWND_TOPMOST, 0, 0, 0, 0,
                   SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
    }
    wasFocused = focused;
  }
  return focused;
}

void SyncMenuState(bool& lastState) {
  if (config::ShowMenu == lastState) return;

  DWORD newExStyle = WS_EX_TOPMOST | WS_EX_LAYERED;
  newExStyle |= config::ShowMenu ? 0 : WS_EX_TRANSPARENT;

  SetWindowLongPtr(OverlayWindow::Hwnd, GWL_EXSTYLE, newExStyle);

  SetWindowPos(OverlayWindow::Hwnd, HWND_TOPMOST, 0, 0, 0, 0,
               SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);

  if (!config::ShowMenu) {
    SetForegroundWindow(global::game_hwnd);
    SetActiveWindow(global::game_hwnd);
    SetFocus(global::game_hwnd);
  }

  lastState = config::ShowMenu;
}

void ProcessMessageQueue() {
  MSG msg;
  while (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE)) {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }
}

void SyncOverlayPosition(WindowStateTracker& stateTracker) {
  std::lock_guard<std::mutex> lock(g_d3dMutex);
  RECT clientRect;
  GetClientRect(global::game_hwnd, &clientRect);
  POINT clientPos{0};
  ClientToScreen(global::game_hwnd, &clientPos);

  bool positionChanged = (clientPos.x != stateTracker.oldRect.left) ||
                         (clientPos.y != stateTracker.oldRect.top);
  bool sizeChanged =
      (clientRect.right - clientRect.left != stateTracker.oldRect.right) ||
      (clientRect.bottom - clientRect.top != stateTracker.oldRect.bottom);

  if (positionChanged || sizeChanged) {
    SetWindowPos(OverlayWindow::Hwnd, HWND_TOPMOST, clientPos.x, clientPos.y,
                 clientRect.right, clientRect.bottom,
                 SWP_NOZORDER | SWP_NOACTIVATE);

    global::screen_size.x = static_cast<float>(clientRect.right);
    global::screen_size.y = static_cast<float>(clientRect.bottom);
    stateTracker.oldRect = {0, 0, clientRect.right, clientRect.bottom};

    global::screen_size.x = static_cast<float>(clientRect.right);
    global::screen_size.y = static_cast<float>(clientRect.bottom);

    DirectX9Interface::pParams.BackBufferWidth =
        static_cast<unsigned int>(global::screen_size.x);
    DirectX9Interface::pParams.BackBufferHeight =
        static_cast<unsigned int>(global::screen_size.y);
  }
}

void UpdateInputState() noexcept {
  ImGuiIO& io = ImGui::GetIO();

  POINT cursorPos{0};
  GetCursorPos(&cursorPos);
  ScreenToClient(global::game_hwnd, &cursorPos);
  io.MousePos =
      ImVec2(static_cast<float>(cursorPos.x), static_cast<float>(cursorPos.y));
  io.MouseDown[0] = (GetAsyncKeyState(VK_LBUTTON) & 0x8000) != 0;

  static std::unordered_map<UINT, bool> keyStates;

  bool insertState = (GetAsyncKeyState(VK_INSERT) & 0x8000);
  bool deleteState = (GetAsyncKeyState(VK_DELETE) & 0x8000);

  if ((insertState || deleteState) && !keyStates[VK_INSERT] &&
      !keyStates[VK_DELETE]) {
    config::ShowMenu = !config::ShowMenu;
  }

  keyStates[VK_INSERT] = insertState;
  keyStates[VK_DELETE] = deleteState;

  io.KeyCtrl = (GetAsyncKeyState(VK_CONTROL) & 0x8000) != 0;
  io.KeyShift = (GetAsyncKeyState(VK_SHIFT) & 0x8000) != 0;
  io.KeyAlt = (GetAsyncKeyState(VK_MENU) & 0x8000) != 0;
}

void HandlePresentResult(HRESULT result) {
  if (result == D3DERR_DEVICELOST &&
      DirectX9Interface::pDevice->TestCooperativeLevel() ==
          D3DERR_DEVICENOTRESET) {
    ImGui_ImplDX9_InvalidateDeviceObjects();
    DirectX9Interface::pDevice->Reset(&DirectX9Interface::pParams);
    ImGui_ImplDX9_CreateDeviceObjects();
  }
}

void RenderFrame() noexcept {
  std::lock_guard<std::mutex> lock(g_d3dMutex);
  ImGui_ImplDX9_NewFrame();
  ImGui_ImplWin32_NewFrame();
  ImGui::NewFrame();

  RenderFunctions(gamevars::ValidEntity);

  ImGui::EndFrame();

  if (SUCCEEDED(DirectX9Interface::pDevice->BeginScene())) {
    DirectX9Interface::pDevice->Clear(0, NULL, D3DCLEAR_TARGET,
                                      D3DCOLOR_ARGB(0, 0, 0, 0), 1.0f, 0);
    ImGui::Render();
    ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
    DirectX9Interface::pDevice->EndScene();
  }

  HandlePresentResult(
      DirectX9Interface::pDevice->Present(NULL, NULL, NULL, NULL));
}

void CleanupRenderResources() {
  ImGui_ImplDX9_Shutdown();
  ImGui_ImplWin32_Shutdown();
  ImGui::DestroyContext();

  if (DirectX9Interface::pDevice) {
    DirectX9Interface::pDevice->Release();
    DirectX9Interface::pDevice = nullptr;
  }

  if (OverlayWindow::Hwnd) {
    DestroyWindow(OverlayWindow::Hwnd);
    UnregisterClassA(OverlayWindow::WindowClass.lpszClassName,
                     OverlayWindow::WindowClass.hInstance);
  }
}

void MainLoop() noexcept {
  static WindowStateTracker stateTracker;
  MSG& msg = DirectX9Interface::Message;
  ZeroMemory(&msg, sizeof(MSG));

  while (msg.message != WM_QUIT) {
    if (!global::isRunning()) break;

    if (config::BypassCapture)
      SetWindowDisplayAffinity(OverlayWindow::Hwnd, WDA_EXCLUDEFROMCAPTURE);
    else
      SetWindowDisplayAffinity(OverlayWindow::Hwnd, WDA_NONE);

    stateTracker.UpdateWindowState([&]() {
      const bool isFullscreen = Ukia::IsFullscreen(global::game_hwnd);
      if (isFullscreen != stateTracker.lastFullscreen) {
        JustGetWindowRect();
        return true;
      }
      return false;
    });

    global::is_focused = HandleFocusState(stateTracker.wasGameFocused);
    if (!global::isFocused()) {
      std::this_thread::sleep_for(std::chrono::milliseconds(15));
      continue;
    }

    SyncMenuState(stateTracker.lastMenuState);

    ProcessMessageQueue();

    SyncOverlayPosition(stateTracker);

    UpdateInputState();

    if (global::isFontUpdatePending()) font_manager.ReloadFonts();

    RenderFrame();
    std::this_thread::sleep_for(
        std::chrono::milliseconds(gamevars::RenderInterval));
  }

  CleanupRenderResources();
}

static void* MySettingsReadOpen(ImGuiContext*, ImGuiSettingsHandler*,
                                const char* name) {
  return (strcmp(name, "Language") == 0) ? reinterpret_cast<void*>(1) : nullptr;
}

static void MySettingsReadLine(ImGuiContext*, ImGuiSettingsHandler*, void*,
                               const char* line) {
  char buf[256] = {};
  if (sscanf(line, "Selected=%255s", buf) == 1 && buf[0] != '\0') {
    configsaver::selectedLangsFile = buf;
    configsaver::LoadLangs(configsaver::selectedLangsFile + ".yaml");
  }
}

void AfterImGuiIniLoaded() {
  if (configsaver::selectedLangsFile.empty()) {
    configsaver::selectedLangsFile = "Default";
    configsaver::LoadLangs("Default.yaml");
  }
}

static void MySettingsWriteAll(ImGuiContext*, ImGuiSettingsHandler* handler,
                               ImGuiTextBuffer* out_buf) {
  out_buf->appendf("[%s][Language]\nSelected=%s\n", handler->TypeName,
                   configsaver::selectedLangsFile.c_str());
}

void RegisterImGuiLangSettingsHandler() {
  ImGuiSettingsHandler ini_handler;
  ini_handler.TypeName = "Samidare";
  ini_handler.TypeHash = ImHashStr("Samidare");
  ini_handler.ReadOpenFn = MySettingsReadOpen;
  ini_handler.ReadLineFn = MySettingsReadLine;
  ini_handler.WriteAllFn = MySettingsWriteAll;
  ImGui::GetCurrentContext()->SettingsHandlers.push_back(ini_handler);
}

bool DirectXInit() noexcept {
  if (FAILED(
          Direct3DCreate9Ex(D3D_SDK_VERSION, &DirectX9Interface::Direct3D9))) {
    return false;
  }

  D3DPRESENT_PARAMETERS Params = {0};
  Params.Windowed = TRUE;
  Params.SwapEffect = D3DSWAPEFFECT_DISCARD;
  Params.hDeviceWindow = OverlayWindow::Hwnd;
  Params.MultiSampleQuality = D3DMULTISAMPLE_NONE;
  Params.BackBufferFormat = D3DFMT_A8R8G8B8;
  Params.BackBufferWidth = static_cast<unsigned int>(global::screen_size.x);
  Params.BackBufferHeight = static_cast<unsigned int>(global::screen_size.y);
  Params.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
  Params.EnableAutoDepthStencil = TRUE;
  Params.AutoDepthStencilFormat = D3DFMT_D16;
  Params.PresentationInterval = D3DPRESENT_INTERVAL_ONE;
  Params.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;

  if (FAILED(DirectX9Interface::Direct3D9->CreateDeviceEx(
          D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, OverlayWindow::Hwnd,
          D3DCREATE_HARDWARE_VERTEXPROCESSING, &Params, 0,
          &DirectX9Interface::pDevice))) {
    DirectX9Interface::Direct3D9->Release();
    return false;
  }

  ImGui::CreateContext();
  ImGuiIO& io = ImGui::GetIO();
  (void)io;
  static std::string iniPath;
  iniPath = config::path + XorStr("\\imgui_config.ini");
  io.IniFilename = iniPath.c_str();
  configsaver::ExportDefaultLang();
  RegisterImGuiLangSettingsHandler();
  AfterImGuiIniLoaded();
  // I forgoted what these line do.
  // ImGui::GetIO().WantCaptureMouse ||
  // ImGui::GetIO().WantTextInput ||
  // ImGui::GetIO().WantCaptureKeyboard;
  io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
  ImFontConfig font_cfg;
  font_cfg.FontDataOwnedByAtlas = false;
  static constexpr ImWchar basic_ranges[] = {
      0x0020, 0x00FF,  // ASCII + Latin-1 Supplement
      0x0102, 0x0103, 0x0110, 0x0111, 0x0128, 0x0129, 0x0168,
      0x0169, 0x01A0, 0x01A1, 0x01AF, 0x01B0,

      0x0400, 0x052F, 0x2DE0, 0x2DFF, 0xA640, 0xA69F,

      0x2000, 0x206F, 0xFF00, 0xFFEF, 0xFFFD, 0xFFFD, 0};
  io.Fonts->AddFontFromMemoryTTF(
      (void*)rawdata::kHarmonyosSansscRegularRawData,
      sizeof(rawdata::kHarmonyosSansscRegularRawData), 16.0f, &font_cfg,
      basic_ranges);

  io.Fonts->Build();

  // io.FontDefault = font;

  ImGui_ImplWin32_EnableDpiAwareness();
  ImGui_ImplWin32_Init(OverlayWindow::Hwnd);
  ImGui_ImplDX9_Init(DirectX9Interface::pDevice);
  LoadTextureFromMemory(DirectX9Interface::pDevice, rawdata::kShigureRawData,
                        sizeof(rawdata::kShigureRawData),
                        &global::shigure_texture);
  LoadTextureFromMemory(DirectX9Interface::pDevice, rawdata::kZekamashiRawData,
                        sizeof(rawdata::kZekamashiRawData),
                        &global::zekamashi_texture);
  DirectX9Interface::Direct3D9->Release();
  return true;
}
static LPCSTR randomWindowName;
static LPCWSTR randomWindowNameW;
void SetupWindow() noexcept {
  if (global::game_hwnd) {
    static RECT TempRect = {NULL};
    static POINT TempPoint;
    GetClientRect(global::game_hwnd, &TempRect);
    ClientToScreen(global::game_hwnd, &TempPoint);
    TempRect.left = TempPoint.x;
    TempRect.top = TempPoint.y;
    global::screen_size.x = static_cast<float>(TempRect.right);
    global::screen_size.y = static_cast<float>(TempRect.bottom);
  }

  JustGetWindowRect();  // again.

  if (global::ui_access_status != ERROR_SUCCESS) {
    OverlayWindow::WindowClass = {};
    OverlayWindow::WindowClass.cbSize = sizeof(WNDCLASSEX);
    OverlayWindow::WindowClass.style = 0;
    OverlayWindow::WindowClass.lpfnWndProc = WinProc;
    OverlayWindow::WindowClass.cbClsExtra = 0;
    OverlayWindow::WindowClass.cbWndExtra = 0;
    OverlayWindow::WindowClass.hInstance = GetModuleHandle(NULL);
    OverlayWindow::WindowClass.hIcon = NULL;
    OverlayWindow::WindowClass.hCursor = NULL;
    OverlayWindow::WindowClass.hbrBackground = nullptr;
    OverlayWindow::WindowClass.lpszMenuName = nullptr;
    OverlayWindow::WindowClass.lpszClassName = OverlayWindow::Name;
    OverlayWindow::WindowClass.hIconSm = NULL;

    RegisterClassExA(&OverlayWindow::WindowClass);
    OverlayWindow::Hwnd = CreateWindowExA(
        WS_EX_TOPMOST, OverlayWindow::Name, OverlayWindow::Name,
        WS_POPUP | WS_VISIBLE, static_cast<int>(global::screen_pos.x),
        static_cast<int>(global::screen_pos.y),
        static_cast<int>(global::screen_size.x),
        static_cast<int>(global::screen_size.y), NULL, NULL,
        OverlayWindow::WindowClass.hInstance, NULL);
  } else {
    WNDCLASSEXW wc = {};
    wc.cbSize = sizeof(wc);
    wc.style = CS_CLASSDC;
    wc.lpfnWndProc = WinProc;
    wc.cbClsExtra = 0L;
    wc.cbWndExtra = 0L;
    wc.hInstance = GetModuleHandle(NULL);
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = randomWindowNameW;
    wc.hIconSm = NULL;
    auto res = RegisterClassExW(&wc);
    OverlayWindow::Hwnd = pCreateWindowInBand(
        WS_EX_TOPMOST, res, randomWindowNameW, WS_POPUP | WS_VISIBLE,
        static_cast<int>(global::screen_pos.x),
        static_cast<int>(global::screen_pos.y),
        static_cast<int>(global::screen_size.x),
        static_cast<int>(global::screen_size.y), NULL, NULL, wc.hInstance, NULL,
        ZBID_UIACCESS);
  }
  if (OverlayWindow::Hwnd != NULL)
    DwmExtendFrameIntoClientArea(OverlayWindow::Hwnd,
                                 &DirectX9Interface::Margin);
  SetWindowLong(OverlayWindow::Hwnd, GWL_EXSTYLE,
                WS_EX_LAYERED | WS_EX_TRANSPARENT);
  ShowWindow(OverlayWindow::Hwnd, SW_SHOW);
  UpdateWindow(OverlayWindow::Hwnd);
}

void LogInfo() noexcept {
#ifdef NDEBUG
  system("cls");
#endif
  printf("%s", XorStr("  ####    ##   #    # # #####    ##   #####  ###### \n"
                      " #       #  #  ##  ## # #    #  #  #  #    # #      \n"
                      "  ####  #    # # ## # # #    # #    # #    # #####  \n"
                      "      # ###### #    # # #    # ###### #####  #      \n"
                      " #    # #    # #    # # #    # #    # #   #  #      \n"
                      "  ####  #    # #    # # #####  #    # #    # ###### \n"
                      "\"\u4e94\u6708\u96e8\" for Counter-Strike 2\n"));
  printf(XorStr("Build - %s - %s\n"), __DATE__, __TIME__);
  printf(
      "%s",
      XorStr(
          "\u305d\u308c\u3067\u3082\u8ab0\u304b\u306b\u898b\u3064\u3051\u3066"
          "\u6b32"
          "\u3057\u304f\u3066"
          "\n\u591c\u7a7a\u898b\u4e0a\u3052\u3066\u53eb\u3093\u3067\u3044\u308b"
          "\n"));
  printf("%s", XorStr("Menukey [DEL]/[INS]\n"));
  printf(
      XorStr("ProcessId: %d\nClientBase: %p\nEngineBase: %p\nTier0Base: %p\n"),
      global::process_id, reinterpret_cast<void*>(gGame.GetClientDLLAddress()),
      reinterpret_cast<void*>(gGame.GetEngineDLLAddress()),
      reinterpret_cast<void*>(gGame.GetTier0DLLAddress()));
}

bool InitializeGameProcess() noexcept {
  Ukia::ProcessMgr.Attach(XorStr("cs2.exe"));
  const DWORD processId = Ukia::ProcessMgr.ProcessID;
  if (!processId) return false;
  if (!gGame.InitAddress()) {
    MessageBoxA(nullptr, XorStr("Failed to call InitAddress()."),
                XorStr("Samidare Error"), MB_ICONERROR);
    return false;
  }
  if (!Ukia::ProcessMgr.ReadMemory(gGame.GetBuildNumberAddress(),
                                   gamevars::GameVersion)) {
    MessageBoxA(nullptr, XorStr("Failed to get game version."),
                XorStr("Samidare Error"), MB_ICONERROR);
    Ukia::UkiaExit();
  }
  global::process_id = processId;
  global::game_hwnd = Ukia::ProcessMgr.GetWindowHandleFromProcessId(processId);

  LogInfo();
  return true;
}

class ScopedThreadManager {
 public:
  bool CreateThreads() noexcept {
    try {
      m_threads.emplace_back([&] { CheckAliveThread(); });
      m_threads.emplace_back([&] { DataUpdateThread(); });
      m_threads.emplace_back([&] { EntityUpdateThread(); });
      m_threads.emplace_back([&] { MapUpdateThread(); });
      m_threads.emplace_back([&] { AimProcessThread(); });
      m_threads.emplace_back([&] { ViewProcessThread(); });
      m_threads.emplace_back([&] { MemoryProcessThread(); });
      m_threads.emplace_back([&] { NonMemoryProcessThread(); });
      return true;
    } catch (const std::exception& e) {
      MessageBoxA(nullptr, e.what(), XorStr("Thread Creation Error"),
                  MB_ICONERROR);
      return false;
    }
  }

  ~ScopedThreadManager() noexcept {
    global::is_running = false;
    for (auto& thread : m_threads) {
      if (thread.joinable()) thread.join();
    }
  }

 private:
  std::vector<std::thread> m_threads;

  void CheckAliveThread() noexcept {
    while (global::isRunning()) {
      constexpr wchar_t EXPECTED_TITLE[] = L"Counter-Strike 2";
      wchar_t actualTitle[256] = {0};
      GetWindowTextW(global::game_hwnd, actualTitle, _countof(actualTitle));
      constexpr wchar_t EXPECTED_TITLE_CN[] =
          L"\u53cd\u6050\u7cbe\u82f1\uff1a\u5168\u7403\u653b\u52bf";
      wchar_t actualTitleCN[256] = {0};
      GetWindowTextW(global::game_hwnd, actualTitleCN, _countof(actualTitle));
      global::is_running = ((wcscmp(actualTitle, EXPECTED_TITLE) == 0) ||
                           (wcscmp(actualTitleCN, EXPECTED_TITLE_CN) == 0));
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
  }
  void DataUpdateThread() noexcept {
    while (global::isRunning()) {
      gamevars::UpdateDataSlow();
      std::this_thread::sleep_for(
          std::chrono::milliseconds(gamevars::GlobalVarsInterval));
    }
  }
  void EntityUpdateThread() noexcept {
    while (global::isRunning()) {
      gamevars::UpdateData();
      std::this_thread::sleep_for(
          std::chrono::milliseconds(gamevars::EntityInterval));
    }
  }
  void MapUpdateThread() noexcept {
    while (global::isRunning()) {
      gamevars::ParserRun();
      std::this_thread::sleep_for(
          std::chrono::milliseconds(gamevars::ParserInterval));
    }
  }
  void AimProcessThread() noexcept {
    while (global::isRunning()) {
      AimFunctions(gamevars::ValidEntity);
      std::this_thread::sleep_for(std::chrono::milliseconds(gamevars::AimInterval));
    }
  }
  void ViewProcessThread() noexcept {
    while (global::isRunning()) {
      ViewFunctions(gamevars::ValidEntity);
      std::this_thread::sleep_for(
          std::chrono::milliseconds(gamevars::ViewInterval));
    }
  }
  void MemoryProcessThread() noexcept {
    while (global::isRunning()) {
      MemoryFunctions(gamevars::ValidEntity);
      std::this_thread::sleep_for(
          std::chrono::milliseconds(gamevars::MemoryInterval));
    }
  }
  void NonMemoryProcessThread() noexcept {
    while (global::isRunning()) {
      NonMemoryFunctions();
      std::this_thread::sleep_for(
          std::chrono::milliseconds(gamevars::NonMemoryInterval));
    }
  }
};

bool WaitForGameFocus() {
  constexpr auto focusCheckInterval = std::chrono::milliseconds(15);
  auto startTime = std::chrono::steady_clock::now();

  while (global::isRunning()) {
    DWORD foregroundPID = 0;
    GetWindowThreadProcessId(GetForegroundWindow(), &foregroundPID);

    if (foregroundPID == global::process_id) {
      JustGetWindowRect();
      return true;
    }

    if (std::chrono::steady_clock::now() - startTime >
        std::chrono::seconds(30)) {
      MessageBoxA(nullptr, XorStr("Focus wait timeout"),
                  XorStr("Samidare Error"), MB_ICONERROR);
      return false;
    }
    std::this_thread::sleep_for(focusCheckInterval);
  }
  return false;
}

bool InitializeRendering() noexcept {
  randomWindowName = Ukia::getRandomPoem().c_str();
  randomWindowNameW = Ukia::getRandomPoemW();
  OverlayWindow::Name = randomWindowName;
  SetupWindow();

  if (!DirectXInit()) {
    MessageBoxA(nullptr, XorStr("DirectX initialization failed"),
                XorStr("Samidare Error"), MB_ICONERROR);
    return false;
  }

  return true;
}

void RunMainLoop() noexcept {
  try {
    while (global::isRunning()) {
      MainLoop();
    }
  } catch (const std::exception& e) {
    MessageBoxA(nullptr, e.what(), XorStr("Rendering Error"), MB_ICONERROR);
  }
}

void CleanupResources() noexcept {
  if (OverlayWindow::Hwnd) {
    DestroyWindow(OverlayWindow::Hwnd);
    UnregisterClassA(OverlayWindow::WindowClass.lpszClassName,
                     OverlayWindow::WindowClass.hInstance);
    Ukia::UkiaExit();
  }
}

void ShowUpdateError() {
  MessageBoxA(
      nullptr,
      XorStr("Failed to update offsets.\nPlease visit "
             "https://github.com/a2x/cs2-dumper/tree/main/output \nto get "
             "latest offsets.json & buttons.json & client_dll.json & "
             "interfaces.json\n"),
      XorStr("Samidare Error"), MB_ICONERROR);
  ShellExecuteA(nullptr, XorStr("open"),
                XorStr("https://github.com/a2x/cs2-dumper/tree/main/output"),
                nullptr, nullptr, SW_SHOWNORMAL);
}

int Mian() noexcept {
  global::ui_access_status = PrepareForUIAccess();

  char documentsPath[MAX_PATH];
  if (SHGetFolderPathA(NULL, CSIDL_PERSONAL, NULL, 0, documentsPath) != S_OK) {
    MessageBoxA(nullptr, XorStr("Failed to get the Documents folder path."),
                XorStr("Samidare Error"), MB_ICONERROR);
    Ukia::UkiaExit();
  }

  config::path = documentsPath;
  config::path += XorStr("\\Samidare");
  LangSettings::path = config::path + XorStr("\\Langs");
  if (std::filesystem::exists(config::path)) {
    printf(XorStr("Config folder connected: %s\n"), config::path.c_str());
  } else {
    if (std::filesystem::create_directories(config::path)) {
      printf(XorStr("Config folder created: %s\n"), config::path.c_str());
    } else {
      MessageBoxA(nullptr, XorStr("Failed to create the config directory."),
                  XorStr("Samidare Error"), MB_ICONERROR);
      Ukia::UkiaExit();
    }
  }
  if (!Offset::UpdateOffsets()) {
    ShowUpdateError();
    Ukia::UkiaExit();
  }
  if (std::filesystem::exists(LangSettings::path)) {
    printf(XorStr("Languages file folder connected: %s\n"),
           LangSettings::path.c_str());
  } else {
    if (std::filesystem::create_directories(LangSettings::path)) {
      printf(XorStr("Languages file folder created: %s\n"),
             LangSettings::path.c_str());
    } else {
      MessageBoxA(nullptr,
                  XorStr("Failed to create the languages file directory."),
                  XorStr("Samidare Error"), MB_ICONERROR);
      Ukia::UkiaExit();
    }
  }
  if (std::filesystem::exists(config::path + XorStr("\\Maps"))) {
    printf(XorStr("Maps folder connected: %s\n"),
           (config::path + XorStr("\\Maps\\")).c_str());
  } else {
    if (std::filesystem::create_directories(config::path + XorStr("\\Maps"))) {
      printf(XorStr("Maps folder created: %s\n"),
             (config::path + XorStr("\\Maps")).c_str());
    } else {
      MessageBoxA(nullptr, XorStr("Failed to create the Maps directory."),
                  XorStr("Samidare Error"), MB_ICONERROR);
      Ukia::UkiaExit();
    }
  }
  global::user_name = std::getenv(XorStr("USERNAME"));

  if (!InitializeGameProcess()) {
    MessageBoxA(nullptr, XorStr("Failed to initialize game process"),
                XorStr("Samidare Error"), MB_ICONERROR);
    return -1;
  }

  global::is_running = true;

  if (!WaitForGameFocus()) {
    MessageBoxA(nullptr, XorStr("Wait game window focus time out"),
                XorStr("Samidare Error"), MB_ICONERROR);
    return -1;
  }

  ScopedThreadManager threadManager;
  if (!threadManager.CreateThreads()) {
    MessageBoxA(nullptr, XorStr("Failed to create worker threads"),
                XorStr("Samidare Error"), MB_ICONERROR);
    return -1;
  }

  if (!InitializeRendering()) {
    MessageBoxA(nullptr, XorStr("Failed to initialize rendering system"),
                XorStr("Samidare Error"), MB_ICONERROR);
    return -1;
  }

  RunMainLoop();

  CleanupResources();
  return 0;
}

int main(int argc, char* argv[]) noexcept {
  Ukia::UkiaInit(argc, argv);
  return Mian();
}



================================================
FILE: FIFO.h
================================================
#pragma once
#include <fileapi.h>
#include <handleapi.h>
#include <windows.h>

#include <cstdint>
#include <cstdio>
#include <cstring>
#include <mutex>
#include <string>

#define kInitFifo 0xF1F0
#define kFifoReadVm 0xF1F01
#define kFifoWriteVm 0xF1F02
#define kFifoDllBase 0xF1F04

#pragma pack(push, 1)
struct FixedStr64 {
  uint64_t blocks[4];
};
#pragma pack(pop)

inline void encodeFixedStr64(const char* str, FixedStr64* fs) {
  size_t len = strlen(str);
  if (len > 32) {
    len = 32;
  }
  memset(fs->blocks, 0, sizeof(fs->blocks));
  for (size_t i = 0; i < len; i++) {
    size_t blockIndex = i / 8;
    size_t posInBlock = i % 8;
    int shift = 8 * (7 - posInBlock);
    fs->blocks[blockIndex] |=
        (static_cast<uint64_t>(static_cast<unsigned char>(str[i])) << shift);
  }
}

#pragma pack(push, 1)
struct Requests {
  int request_key;

  uint64_t src_pid;
  uint64_t src_addr;
  uint64_t dst_pid;
  uint64_t dst_addr;
  size_t size;

  DWORD dwFlags;
  DWORD dx;
  DWORD dy;
  DWORD dwData;
  ULONG_PTR dwExtraInfo;

  uint64_t dll_base;

  FixedStr64 dll_name;
  size_t dll_name_length;
};
#pragma pack(pop)

inline bool pipeRequest(HANDLE pipe_handle, Requests* req) {
  DWORD bytes_written = 0;
  if (!WriteFile(pipe_handle, req, sizeof(Requests), &bytes_written, nullptr) ||
      bytes_written != sizeof(Requests)) {
    return false;
  }

  DWORD bytes_read = 0;
  if (!ReadFile(pipe_handle, req, sizeof(Requests), &bytes_read, nullptr) ||
      bytes_read != sizeof(Requests)) {
    return false;
  }
  return true;
}

class Fifo {
 public:
  void initPipe(UINT64 process_id) {
    pipe_handle_ =
        CreateFileA("\\\\.\\pipe\\Shirakumo", GENERIC_READ | GENERIC_WRITE, 0,
                    nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);

    if (pipe_handle_ != INVALID_HANDLE_VALUE) {
      process_id_ = process_id;
      cur_processid_ = GetCurrentProcessId();
    } else {
      return;
    }
    Requests out = {0};
    out.request_key = kInitFifo;
    out.src_pid = process_id_;
    out.dst_pid = static_cast<uint64_t>(cur_processid_);
    {
      std::lock_guard<std::mutex> lock(pipe_mutex_);
      if (!pipeRequest(pipe_handle_, &out)) {
        return;
      }
    }
  }

  void readSize(const uintptr_t address, const void* buffer,
                const size_t size) {
    readVm(process_id_, address, reinterpret_cast<uint64_t>(buffer), size);
  }

  template <typename T>
  void write(uintptr_t address, const T& buffer, int size) {
    writeVm(process_id_, address, reinterpret_cast<uint64_t>(&buffer), size);
  }

  ULONG64 dllAddress(const char* dll_name) {
    Requests out = {};
    out.request_key = kFifoDllBase;
    out.src_pid = process_id_;

    size_t original_len = strlen(dll_name);
    if (original_len > 32) {
      original_len = 32;
    }
    out.dll_name_length = original_len;
    FixedStr64 fs;
    encodeFixedStr64(dll_name, &fs);
    out.dll_name = fs;

    {
      std::lock_guard<std::mutex> lock(pipe_mutex_);
      if (!pipeRequest(pipe_handle_, &out)) {
        return 0;
      }
    }
    return static_cast<ULONG64>(out.dll_base);
  }

 private:
  HANDLE pipe_handle_;
  UINT64 process_id_;
  UINT64 cur_processid_;
  std::mutex pipe_mutex_;

  void readVm(uint32_t src_pid, uint64_t src_addr, uint64_t dst_addr,
              size_t size) {
    if (src_pid == 0 || src_addr == 0) return;

    Requests out = {kFifoReadVm, src_pid,  src_addr,
                    cur_processid_,
                    dst_addr,    size};

    {
      std::lock_guard<std::mutex> lock(pipe_mutex_);
      if (!pipeRequest(pipe_handle_, &out)) {
      }
    }
  }

  void writeVm(uint32_t src_pid, uint64_t src_addr, uint64_t dst_addr,
               size_t size) {
    if (src_pid == 0 || dst_addr == 0) return;

    Requests out = {kFifoWriteVm, src_pid,  src_addr,
                    cur_processid_,
                    dst_addr,     size};

    {
      std::lock_guard<std::mutex> lock(pipe_mutex_);
      if (!pipeRequest(pipe_handle_, &out)) {
      }
    }
  }
};

inline Fifo fifo;



================================================
FILE: framework.h
================================================
﻿#pragma once
#ifndef FRAMEWORK_H_
#define FRAMEWORK_H_
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <Windows.h>
#include <ShlObj.h>
#include <TlHelp32.h>
#include <atlconv.h>
#include <iphlpapi.h>
#include <malloc.h>
#include <mmsystem.h>
#include <psapi.h>
#include <shellapi.h>
#include <stdio.h>
#include <tchar.h>
#include <math.h>
#include <stdlib.h>
#include <Uxtheme.h>
#include <d3d9.h>
#include <dwmapi.h>

#include <algorithm>
#include <atomic>
#include <chrono>
#include <execution>
#include <iostream>
#include <memory>
#include <mutex>
#include <array>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <filesystem>
#include <limits>
#include <fstream>
#include <sstream>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>
#include <random>
#include <utility>
#endif  // FRAMEWORK_H_


================================================
FILE: Game.cc
================================================
﻿#include "pch.h"
#include "Game.h"

#include "UkiaStuff.h"
bool CGame::InitAddress() {
  this->Address.ClientDLL = reinterpret_cast<DWORD64>(
      Ukia::ProcessMgr.GetProcessModuleHandle("client.dll"));
  this->Address.EngineDLL = reinterpret_cast<DWORD64>(
      Ukia::ProcessMgr.GetProcessModuleHandle("engine2.dll"));
  this->Address.ServerDLL = reinterpret_cast<DWORD64>(
      Ukia::ProcessMgr.GetProcessModuleHandle("server.dll"));
  this->Address.Tier0DLL = reinterpret_cast<DWORD64>(
      Ukia::ProcessMgr.GetProcessModuleHandle("tier0.dll"));
  this->Address.EntityList = GetClientDLLAddress() + Offset::EntityList;
  this->Address.Matrix = GetClientDLLAddress() + Offset::Matrix;
  this->Address.ViewAngle = GetClientDLLAddress() + Offset::ViewAngle;
  this->Address.LocalController =
      GetClientDLLAddress() + Offset::LocalPlayerController;
  this->Address.LocalPawn = GetClientDLLAddress() + Offset::LocalPlayerPawn;
  this->Address.ServerPawn = GetServerDLLAddress() + Offset::LocalPlayerPawn;
  this->Address.PlantedC4PTR = GetClientDLLAddress() + Offset::PlantedC4;
  this->Address.ForceJump = GetClientDLLAddress() + Offset::ForceJump;
  this->Address.ForceCrouch = GetClientDLLAddress() + Offset::ForceCrouch;
  this->Address.ForceForward = GetClientDLLAddress() + Offset::ForceForward;
  this->Address.ForceLeft = GetClientDLLAddress() + Offset::ForceLeft;
  this->Address.ForceRight = GetClientDLLAddress() + Offset::ForceRight;
  this->Address.GlobalVars = GetClientDLLAddress() + Offset::GlobalVars;
  this->Address.BuildNumber = GetEngineDLLAddress() + Offset::BuildNumber;
  
  return this->Address.ClientDLL != 0;
}

DWORD64 CGame::GetClientDLLAddress() { return this->Address.ClientDLL; }

DWORD64 CGame::GetEngineDLLAddress() { return this->Address.EngineDLL; }

DWORD64 CGame::GetServerDLLAddress() { return this->Address.ServerDLL; }

DWORD64 CGame::GetTier0DLLAddress() { return this->Address.Tier0DLL; }

DWORD64 CGame::GetEntityListAddress() { return this->Address.EntityList; }

DWORD64 CGame::GetMatrixAddress() { return this->Address.Matrix; }

DWORD64 CGame::GetViewAngleAddress() { return this->Address.ViewAngle; }

DWORD64 CGame::GetEntityListEntry() { return this->Address.EntityListEntry; }

DWORD64 CGame::GetLocalControllerAddress() {
  return this->Address.LocalController;
}

DWORD64 CGame::GetLocalPawnAddress() { return this->Address.LocalPawn; }

DWORD64 CGame::GetServerPawnAddress() { return this->Address.ServerPawn; }

DWORD64 CGame::GetPlantedC4PTRAddress() { return this->Address.PlantedC4PTR; }

DWORD64 CGame::GetGlobalVarsAddress() {
  DWORD64 Global_Vars_Addr = 0;
  Ukia::ProcessMgr.ReadMemory(this->Address.GlobalVars, Global_Vars_Addr);
  return Global_Vars_Addr;
}
DWORD64 CGame::GetCSGOInputAddress() { return this->Address.CSGOInput; }

DWORD64 CGame::GetBuildNumberAddress() { return this->Address.BuildNumber; }

bool CGame::UpdateEntityListEntry() {
  DWORD64 EntityListEntry = 0;
  if (!Ukia::ProcessMgr.ReadMemory<DWORD64>(gGame.GetEntityListAddress(),
                                            EntityListEntry))
    return false;
  if (!Ukia::ProcessMgr.ReadMemory<DWORD64>(EntityListEntry + 0x10,
                                            EntityListEntry))
    return false;

  this->Address.EntityListEntry = EntityListEntry;

  return this->Address.EntityListEntry != 0;
}
bool CGame::GetViewAngles(Vector3& Angle) {

  if (!Ukia::ProcessMgr.ReadMemory<Vector3>(this->Address.ViewAngle, Angle))
    return false;

  return true;
}
bool CGame::SetViewAngles(Vector3 Angle) {

  if (!Ukia::ProcessMgr.WriteMemory<Vector3>(this->Address.ViewAngle, Angle))
    return false;

  return true;
}

bool CGame::SetForceJump(int value) {
  if (!Ukia::ProcessMgr.WriteMemory<int>(this->Address.ForceJump, value))
    return false;

  return true;
}
bool CGame::GetForceJump(int& value) {
  if (!Ukia::ProcessMgr.ReadMemory<int>(this->Address.ForceJump, value))
    return false;

  return true;
}
bool CGame::SetForceCrouch(int value) {
  if (!Ukia::ProcessMgr.WriteMemory<int>(this->Address.ForceCrouch, value))
    return false;

  return true;
}
bool CGame::GetForceCrouch(int& value) {
  if (!Ukia::ProcessMgr.ReadMemory<int>(this->Address.ForceCrouch, value))
    return false;

  return true;
}

// MovingType: 0 = Forward, 1 = Left, 2 = Right
bool CGame::SetForceMove(int MovingType, int Value) {
  switch (MovingType) {
    case 0:
      if (!Ukia::ProcessMgr.WriteMemory<int>(this->Address.ForceForward, Value))
        return false;
      break;
    case 1:
      if (!Ukia::ProcessMgr.WriteMemory<int>(this->Address.ForceLeft, Value))
        return false;
      break;
    case 2:
      if (!Ukia::ProcessMgr.WriteMemory<int>(this->Address.ForceRight, Value))
        return false;
      break;
    default:
      return false;
      break;
  }
  return true;
}

bool CGame::GetForceMove(int MovingType, int& Value) {
  switch (MovingType) {
    case 0:
      if (!Ukia::ProcessMgr.ReadMemory<int>(this->Address.ForceForward, Value))
        return false;
      break;
    case 1:
      if (!Ukia::ProcessMgr.ReadMemory<int>(this->Address.ForceLeft, Value))
        return false;
      break;
    case 2:
      if (!Ukia::ProcessMgr.ReadMemory<int>(this->Address.ForceRight, Value))
        return false;
      break;
    default:
      return false;
      break;
  }
  return true;
}


================================================
FILE: Game.h
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: Game.h
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file contains functions and classes for game interaction and
//   world-to-screen.
//
// -----------------------------------------------------------------------------
#pragma once
#ifndef GAME_H_
#define GAME_H_
#include <optional>
#include "global.h"
#include "Offsets.h"
#include "Overlay.h"
class CView {
 public:
  float Matrix[4][4]{};

  bool WorldToScreen(const Vector3& Pos, Vector2& ToPos) {
    float SightX = global::screen_size.x * .5f;
    float SightY = global::screen_size.y * .5f;

    float m30 = Matrix[3][0], m31 = Matrix[3][1], m32 = Matrix[3][2],
          m33 = Matrix[3][3];
    float m00 = Matrix[0][0], m01 = Matrix[0][1], m02 = Matrix[0][2],
          m03 = Matrix[0][3];
    float m10 = Matrix[1][0], m11 = Matrix[1][1], m12 = Matrix[1][2],
          m13 = Matrix[1][3];

    float View = m30 * Pos.x + m31 * Pos.y + m32 * Pos.z + m33;

    if (View <= 0.01f) return false;

    float invView = 1.0f / View;
    ToPos.x = SightX + (m00 * Pos.x + m01 * Pos.y + m02 * Pos.z + m03) *
                           invView * SightX;
    ToPos.y = SightY - (m10 * Pos.x + m11 * Pos.y + m12 * Pos.z + m13) *
                           invView * SightY;

    return true;
  }

  Vector2 GetScreenCenterVec2() {
    Vector2 Pos = global::screen_size * .5f;
    return Pos;
  }
};
class CGame
{
private:
	struct
	{
		DWORD64 ForceJump;
		DWORD64 ForceCrouch;
		DWORD64 ForceForward;
		DWORD64 ForceLeft;
		DWORD64 ForceRight;

		DWORD64 ClientDLL;
        DWORD64 EngineDLL;
        DWORD64 ServerDLL;
        DWORD64 Tier0DLL;
		DWORD64 EntityList;
		DWORD64 Matrix;
		DWORD64 ViewAngle;
		DWORD64 EntityListEntry;
		DWORD64 LocalController;
		DWORD64 LocalPawn;
		DWORD64 ServerPawn;
        DWORD64 PlantedC4PTR;
		DWORD64 GlobalVars;
		DWORD64 CSGOInput;
        DWORD64 BuildNumber;
	}Address;

public:
	CView View;

public:	

	bool InitAddress();

	DWORD64 GetClientDLLAddress();
    DWORD64 GetEngineDLLAddress();
	DWORD64 GetServerDLLAddress();
    DWORD64 GetTier0DLLAddress();

	DWORD64 GetEntityListAddress();

	DWORD64 GetMatrixAddress();

	DWORD64 GetViewAngleAddress();

	DWORD64 GetEntityListEntry();

	DWORD64 GetLocalControllerAddress();

	DWORD64 GetLocalPawnAddress();

	DWORD64 GetServerPawnAddress();

    DWORD64 GetPlantedC4PTRAddress();

	DWORD64 GetGlobalVarsAddress();

	DWORD64 GetCSGOInputAddress();

	DWORD64 GetBuildNumberAddress();
        
	bool UpdateEntityListEntry();

    bool GetViewAngles(Vector3& Angle);
    bool SetViewAngles(Vector3 Angle);

	bool SetForceJump(int Value);
	bool GetForceJump(int& Value);
	bool SetForceCrouch(int Value);
	bool GetForceCrouch(int& Value);
	bool SetForceMove(int MovingType, int Value);
	bool GetForceMove(int MovingType, int& Value);
};

inline CGame gGame;
#endif  // GAME_H_



================================================
FILE: global.h
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: global.h
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file contains globalvars of samidare project.
//
// -----------------------------------------------------------------------------
#pragma once
#ifndef GLOBAL_H_
#define GLOBAL_H_
#include "pch.h"
#include "Overlay.h"

namespace global {
inline std::atomic<bool> is_running(true);
inline bool is_focused = false;

inline DWORD ui_access_status = 0;
inline DWORD process_id = 0;

// unused
// inline HDC hdc_buffer = NULL;
// inline HBITMAP hbm_buffer = NULL;

// inline RECT game_bounds;
inline HWND game_hwnd;

inline Vector2 screen_size;
inline Vector2 screen_pos;

inline std::string user_name;

inline std::string gamedata_infos;

inline bool is_font_update_pending = false;

inline IDirect3DTexture9* shigure_texture = nullptr;
inline IDirect3DTexture9* zekamashi_texture = nullptr;

inline std::atomic<bool> isRunning() { return is_running.load(); }
inline bool isFocused() { return is_focused; }
inline bool isFontUpdatePending() { return is_font_update_pending; }
}  // namespace global

#endif  // GLOBAL_H_



================================================
FILE: HARMONYOSSANS字体许可协议
================================================
[Binary file]


================================================
FILE: Lang.h
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: Lang.h
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file contains functions for managing language and font loading.
//
// -----------------------------------------------------------------------------
#pragma once
#ifndef LANG_H_
#define LANG_H_
#include "pch.h"

#include "./HarmonyOS_SansSC_Regular.h"
#include "Functions/config.h"
#include "ImGui/imgui.h"

static constexpr ImWchar basic_ranges[] = {

    0x0020, 0x00FF,  // ASCII + Latin-1 Supplement
    0x0102, 0x0103, 0x0110, 0x0111, 0x0128, 0x0129, 0x0168,
    0x0169, 0x01A0, 0x01A1, 0x01AF, 0x01B0,

    0x0400, 0x052F, 0x2DE0, 0x2DFF, 0xA640, 0xA69F,

    0x2000, 0x206F, 0xFF00, 0xFFEF, 0xFFFD, 0xFFFD, 0};

static constexpr ImWchar greek_ranges[] = {0x0370, 0x03FF, 0};

static constexpr ImWchar vietnamese_ranges[] = {0x1EA0, 0x1EF9, 0};

static constexpr ImWchar kanji_ranges[] = {
    0x3000, 0x30FF, 0x31F0, 0x31FF, 0xFF00, 0xFFEF, 0x4e00, 0x9FAF, 0,
};

static constexpr ImWchar korean_ranges[] = {0x3131, 0x3163,  // Korean alphabets
                                            0xAC00,
                                            0xD7A3,  // Korean characters
                                            0};
static constexpr ImWchar arab_ranges[] = {0x0600, 0x06FF, 0};
static constexpr ImWchar thai_ranges[] = {0x0E00, 0x0E7F,  // Thai
                                          0};

class FontManager {
 public:
  inline void ReloadFonts() {
    ImGuiIO& io = ImGui::GetIO();
    io.Fonts->Clear();

    ImFontConfig base_cfg;
    base_cfg.FontDataOwnedByAtlas = false;
    io.Fonts->AddFontFromMemoryTTF(
        (void*)rawdata::kHarmonyosSansscRegularRawData,
        sizeof(rawdata::kHarmonyosSansscRegularRawData), 16.0f, &base_cfg,
        basic_ranges);

    ImFontConfig merge_cfg;
    merge_cfg.MergeMode = true;
    merge_cfg.FontDataOwnedByAtlas = false;

    if (LangSettings::greek) {
      io.Fonts->AddFontFromMemoryTTF(
          (void*)rawdata::kHarmonyosSansscRegularRawData,
          sizeof(rawdata::kHarmonyosSansscRegularRawData), 16.0f, &merge_cfg,
          greek_ranges);
    }
    if (LangSettings::vietnamese) {
      io.Fonts->AddFontFromMemoryTTF(
          (void*)rawdata::kHarmonyosSansscRegularRawData,
          sizeof(rawdata::kHarmonyosSansscRegularRawData), 16.0f, &merge_cfg,
          vietnamese_ranges);
    }
    if (LangSettings::kanji) {
      io.Fonts->AddFontFromMemoryTTF(
          (void*)rawdata::kHarmonyosSansscRegularRawData,
          sizeof(rawdata::kHarmonyosSansscRegularRawData), 16.0f, &merge_cfg,
          kanji_ranges);
    }
    if (LangSettings::korean) {
      AddFontWithRange(merge_cfg, "malgun.ttf", korean_ranges);
    }
    if (LangSettings::arabic) {
      AddFontWithRange(merge_cfg, "dubai-regular.ttf", arab_ranges);
    }
    if (LangSettings::thai) {
      AddFontWithRange(merge_cfg, "leelawui.ttf", thai_ranges);
    }

    io.Fonts->Build();
    ImGui_ImplDX9_InvalidateDeviceObjects();
    ImGui_ImplDX9_CreateDeviceObjects();
    global::is_font_update_pending = false;
  }

 private:
  inline std::string GetSystemFontPath() {
    char path[MAX_PATH];
    SHGetFolderPathA(NULL, CSIDL_FONTS, NULL, 0, path);
    return std::string(path) + "/";
  }

  inline void AddFontWithRange(ImFontConfig& cfg, const char* fontName,
                               const ImWchar* ranges) {
    const std::string fullPath = GetSystemFontPath() + fontName;
    if (!std::filesystem::exists(fullPath)) {
      MessageBoxA(nullptr, XorStr("Font file missing."),
                  XorStr("Samidare Error"), MB_ICONERROR);
      return;
    }
    ImGuiIO& io = ImGui::GetIO();
    io.Fonts->AddFontFromFileTTF(fullPath.c_str(), 16.0f, &cfg, ranges);
  }
};

static FontManager font_manager;
#endif  // LANG_H_



================================================
FILE: LICENSE
================================================
[Binary file]


================================================
FILE: maths.h
================================================
#pragma once

#include <corecrt_math.h>

// convert angle in degrees to radians
#define M_DEG2RAD(DEGREES) ((DEGREES) * (MATH::_PI / 180.f))
// convert angle in radians to degrees
#define M_RAD2DEG(RADIANS) ((RADIANS) * (180.f / MATH::_PI))
/// linearly interpolate the value between @a'X0' and @a'X1' by @a'FACTOR'
#define M_LERP(X0, X1, FACTOR) ((X0) + ((X1) - (X0)) * (FACTOR))
/// trigonometry
#define M_COS(ANGLE) cos(ANGLE)
#define M_SIN(ANGLE) sin(ANGLE)
#define M_TAN(ANGLE) tan(ANGLE)
/// power
#define M_POW(BASE, EXPONENT) pow(BASE, EXPONENT)
/// absolute value
#define M_ABS(VALUE) abs(VALUE)
/// square root
#define M_SQRT(VALUE) sqrt(VALUE)
/// floor
#define M_FLOOR(VALUE) floor(VALUE)

/*
 * MATHEMATICS
 * - basic trigonometry, algebraic mathematical functions and constants
 */
namespace MATH {
/* @section: constants */
// pi value
inline constexpr float _PI = 3.141592654f;
// double of pi
inline constexpr float _2PI = 6.283185307f;
// half of pi
inline constexpr float _HPI = 1.570796327f;
// quarter of pi
inline constexpr float _QPI = 0.785398163f;
// reciprocal of double of pi
inline constexpr float _1DIV2PI = 0.159154943f;
// golden ratio
inline constexpr float _PHI = 1.618033988f;

[[nodiscard]] inline float normalize_yaw(float yaw) noexcept {
  while (yaw > 180.0f) yaw -= 360.0f;

  while (yaw < -180.0f) yaw += 360.0f;

  return yaw;
}

template <typename T>
inline T clamp(const T& n, const T& lower, const T& upper) {
  return Max(lower, Min(n, upper));
}

/* @section: exponential */
/// @returns: true if given number is power of two, false otherwise
template <typename T>
  requires(std::is_integral_v<T>)
[[nodiscard]] inline constexpr bool IsPowerOfTwo(const T value) noexcept {
  return value != 0 && (value & (value - 1)) == 0;
}
}  // namespace MATH


================================================
FILE: Offsets.cc
================================================
﻿#include "pch.h"
#include "Offsets.h"

#include "Functions/config.h"
#include "UkiaStuff.h"
#include "Utils/XorStr.h"

namespace Offset {

uintptr_t ForceJump = 0;
uintptr_t ForceCrouch = 0;
uintptr_t ForceForward = 0;
uintptr_t ForceLeft = 0;
uintptr_t ForceRight = 0;

uintptr_t EntityList = 0;
uintptr_t Matrix = 0;
uintptr_t ViewAngle = 0;
uintptr_t LocalPlayerController = 0;
uintptr_t LocalPlayerPawn = 0;
uintptr_t GlobalVars = 0;
uintptr_t CSGOInput = 0;
uintptr_t InventoryServices = 0;
uintptr_t PlantedC4 = 0;
uintptr_t InputSystem = 0;
uintptr_t dwSensitivity = 0;
uintptr_t Sensitivity = 0;
uintptr_t BuildNumber = 0;
uintptr_t dwNetworkGameClient_signOnState = 0;

uintptr_t VEngineCvar007 = 0;

C_BaseEntityT C_BaseEntity = {};

C_BaseModelEntityT C_BaseModelEntity = {};

CGameSceneNodeT CGameSceneNode = {};

CCollisionPropertyT CCollisionProperty = {};

CBasePlayerControllerT CBasePlayerController = {};

CCSPlayerControllerT CCSPlayerController = {};

C_BasePlayerPawnT C_BasePlayerPawn = {};

C_CSPlayerPawnBaseT C_CSPlayerPawnBase = {};

C_CSPlayerPawnT C_CSPlayerPawn = {};

C_PlantedC4T C_PlantedC4 = {};

CPlayer_ObserverServicesT CPlayer_ObserverServices = {};

CCSPlayer_ViewModelServicesT CCSPlayer_ViewModelServices = {};

CPlayer_MovementServices_HumanoidT CPlayer_MovementServices_Humanoid = {};

CCSPlayerBase_CameraServicesT CCSPlayerBase_CameraServices = {};

CCSPlayer_BulletServicesT CCSPlayer_BulletServices = {};

CCSPlayerController_InGameMoneyServicesT
    CCSPlayerController_InGameMoneyServices = {};

EconEntityT EconEntity = {};

WeaponBaseDataT WeaponBaseData = {};

SmokeGrenadeProjectileT SmokeGrenadeProjectile = {};

PawnT Pawn = {};

}  // namespace Offset

using json = nlohmann::json;

namespace fs = std::filesystem;
/*
DWORD64 SearchOffsets(std::string Signature, DWORD64 ModuleAddress)
{
        std::vector<DWORD64> TempAddressList;
        DWORD64 Address = 0;
        DWORD Offsets = 0;

        TempAddressList = ProcessMgr.SearchMemory(Signature, ModuleAddress,
ModuleAddress + 0x4000000);

        if (TempAddressList.size() <= 0)
                return 0;

        if (!ProcessMgr.ReadMemory<DWORD>(TempAddressList.at(0) + 3, Offsets))
                return 0;

        Address = TempAddressList.at(0) + Offsets + 7;
        return Address;
}
*/
template <typename T>
inline static T ReadJsonData(const nlohmann::json& node, T defaultValue) {
  return node.is_null() ? defaultValue : node.get<T>();
}

bool Offset::UpdateOffsets() {
  std::string currentDir = fs::current_path().string();
  std::string offsetFileName = "offsets.json";
  std::string buttonFileName = "buttons.json";
  std::string clientFileName = "client_dll.json";
  std::string interfaceFileName = "interfaces.json";
  std::string offsetsDir = config::path + XorStr("\\Offsets\\");

  struct FilePair {
    std::string src;
    std::string dst;
    const char* name;
  };

  FilePair files[] = {{currentDir + "\\" + offsetFileName,
                       offsetsDir + offsetFileName, "offsets.json"},
                      {currentDir + "\\" + buttonFileName,
                       offsetsDir + buttonFileName, "buttons.json"},
                      {currentDir + "\\" + clientFileName,
                       offsetsDir + clientFileName, "client_dll.json"},
                      {currentDir + "\\" + interfaceFileName,
                       offsetsDir + interfaceFileName, "interfaces.json"}};

  // bool anyCopied = false;
  for (const auto& file : files) {
    if (fs::exists(file.src)) {
      try {
        fs::copy_file(file.src, file.dst, fs::copy_options::overwrite_existing);
        printf(XorStr("Copied and overwrote %s\n"), file.name);
        // anyCopied = true;
      } catch (const std::exception& e) {
        printf(XorStr("Error copying %s: %s\n"), file.name, e.what());
      }
    }
  }

  // 检查目标文件是否都存在
  if (!(fs::exists(files[0].dst) && fs::exists(files[1].dst) &&
        fs::exists(files[2].dst) && fs::exists(files[3].dst))) {
    printf("%s",
           XorStr("Failed to locate all offsets file. Please visit "
               "https://github.com/a2x/cs2-dumper/tree/main/output to get "
               "latest offsets.json & buttons.json & client_dll.json & "
               "interfaces.json\n"));
    return false;
  }

  Offset::WeaponBaseData.WeaponSize = 0x50;

  Offset::Pawn.BoneArray = 0x1F0;

  std::ifstream offsetfile(files[0].dst);
  nlohmann::json offset;
  offsetfile >> offset;

  Offset::EntityList = ReadJsonData(offset["client.dll"]["dwEntityList"], 0);

  Offset::LocalPlayerController =
      ReadJsonData(offset["client.dll"]["dwLocalPlayerController"], 0);
  Offset::Matrix = ReadJsonData(offset["client.dll"]["dwViewMatrix"], 0);
  Offset::GlobalVars = ReadJsonData(offset["client.dll"]["dwGlobalVars"], 0);
  Offset::CSGOInput = ReadJsonData(offset["client.dll"]["dwCSGOInput"], 0);
  Offset::ViewAngle = ReadJsonData(offset["client.dll"]["dwViewAngles"], 0);
  Offset::LocalPlayerPawn =
      ReadJsonData(offset["client.dll"]["dwLocalPlayerPawn"], 0);
  Offset::PlantedC4 = ReadJsonData(offset["client.dll"]["dwPlantedC4"], 0);
  Offset::dwSensitivity =
      ReadJsonData(offset["client.dll"]["dwSensitivity"], 0);
  Offset::Sensitivity =
      ReadJsonData(offset["client.dll"]["dwSensitivity_sensitivity"], 0);
  Offset::BuildNumber = ReadJsonData(offset["engine2.dll"]["dwBuildNumber"], 0);
  Offset::dwNetworkGameClient_signOnState =
      ReadJsonData(offset["engine2.dll"]["dwNetworkGameClient_signOnState"], 0);
  Offset::InputSystem =
      ReadJsonData(offset["inputsystem.dll"]["dwInputSystem"], 0);

  std::ifstream interfacesfile(files[3].dst);
  nlohmann::json interfaces;
  interfacesfile >> interfaces;
  Offset::VEngineCvar007 =
      ReadJsonData(interfaces["tier0.dll"]["VEngineCvar007"], 0);

  std::ifstream buttonfile(files[1].dst);
  nlohmann::json button;
  buttonfile >> button;
  Offset::ForceJump = ReadJsonData(button["client.dll"]["jump"], 0);
  Offset::ForceCrouch = ReadJsonData(button["client.dll"]["duck"], 0);
  Offset::ForceForward = ReadJsonData(button["client.dll"]["forward"], 0);
  Offset::ForceLeft = ReadJsonData(button["client.dll"]["left"], 0);
  Offset::ForceRight = ReadJsonData(button["client.dll"]["right"], 0);

  std::ifstream clientfile(files[2].dst);
  nlohmann::json client;
  clientfile >> client;
  Offset::C_BaseEntity.m_flGravityScale =
      ReadJsonData(client["client.dll"]["classes"]["C_BaseEntity"]["fields"]
                         ["m_flGravityScale"],
                   0);
  Offset::C_BaseEntity.m_iMaxHealth = ReadJsonData(
      client["client.dll"]["classes"]["C_BaseEntity"]["fields"]["m_iMaxHealth"],
      0);
  Offset::C_BaseEntity.m_iHealth = ReadJsonData(
      client["client.dll"]["classes"]["C_BaseEntity"]["fields"]["m_iHealth"],
      0);
  Offset::C_BaseEntity.m_pGameSceneNode =
      ReadJsonData(client["client.dll"]["classes"]["C_BaseEntity"]["fields"]
                         ["m_pGameSceneNode"],
                   0);
  Offset::C_BaseEntity.m_pCollision = ReadJsonData(
      client["client.dll"]["classes"]["C_BaseEntity"]["fields"]["m_pCollision"],
      0);
  Offset::C_BaseEntity.m_vecAbsVelocity =
      ReadJsonData(client["client.dll"]["classes"]["C_BaseEntity"]["fields"]
                         ["m_vecAbsVelocity"],
                   0);
  Offset::C_BaseEntity.m_iTeamNum = ReadJsonData(
      client["client.dll"]["classes"]["C_BaseEntity"]["fields"]["m_iTeamNum"],
      0);
  Offset::C_BaseEntity.m_fFlags = ReadJsonData(
      client["client.dll"]["classes"]["C_BaseEntity"]["fields"]["m_fFlags"], 0);

  Offset::C_BaseModelEntity.GlowFunction =
      ReadJsonData(client["client.dll"]["classes"]["C_BaseModelEntity"]
                         ["fields"]["m_Glow"],
                   0) +
      ReadJsonData(client["client.dll"]["classes"]["CGlowProperty"]["fields"]
                         ["m_bGlowing"],
                   0);
  Offset::C_BaseModelEntity.GlowColorOverride =
      ReadJsonData(client["client.dll"]["classes"]["C_BaseModelEntity"]
                         ["fields"]["m_Glow"],
                   0) +
      ReadJsonData(client["client.dll"]["classes"]["CGlowProperty"]["fields"]
                         ["m_glowColorOverride"],
                   0);

  Offset::CGameSceneNode.m_vecOrigin =
      ReadJsonData(client["client.dll"]["classes"]["CGameSceneNode"]["fields"]
                         ["m_vecOrigin"],
                   0);
  Offset::CGameSceneNode.m_bDormant = ReadJsonData(
      client["client.dll"]["classes"]["CGameSceneNode"]["fields"]["m_bDormant"],
      0);

  Offset::CCollisionProperty.m_vecMins =
      ReadJsonData(client["client.dll"]["classes"]["CCollisionProperty"]
                         ["fields"]["m_vecMins"],
                   0);
  Offset::CCollisionProperty.m_vecMaxs =
      ReadJsonData(client["client.dll"]["classes"]["CCollisionProperty"]
                         ["fields"]["m_vecMaxs"],
                   0);

  Offset::CBasePlayerController.m_hPawn =
      ReadJsonData(client["client.dll"]["classes"]["CBasePlayerController"]
                         ["fields"]["m_hPawn"],
                   0);
  Offset::CBasePlayerController.m_iszPlayerName =
      ReadJsonData(client["client.dll"]["classes"]["CBasePlayerController"]
                         ["fields"]["m_iszPlayerName"],
                   0);
  Offset::CBasePlayerController.m_iDesiredFOV =
      ReadJsonData(client["client.dll"]["classes"]["CBasePlayerController"]
                         ["fields"]["m_iDesiredFOV"],
                   0);
  Offset::CBasePlayerController.m_steamID =
      ReadJsonData(client["client.dll"]["classes"]["CBasePlayerController"]
                         ["fields"]["m_steamID"],
                   0);

  Offset::CCSPlayerController.m_bPawnIsAlive =
      ReadJsonData(client["client.dll"]["classes"]["CCSPlayerController"]
                         ["fields"]["m_bPawnIsAlive"],
                   0);
  Offset::CCSPlayerController.m_bControllingBot =
      ReadJsonData(client["client.dll"]["classes"]["CCSPlayerController"]
                         ["fields"]["m_bControllingBot"],
                   0);
  Offset::CCSPlayerController.m_bEverPlayedOnTeam =
      ReadJsonData(client["client.dll"]["classes"]["CCSPlayerController"]
                         ["fields"]["m_bEverPlayedOnTeam"],
                   0);
  Offset::CCSPlayerController.m_hPlayerPawn =
      ReadJsonData(client["client.dll"]["classes"]["CCSPlayerController"]
                         ["fields"]["m_hPlayerPawn"],
                   0);
  Offset::CCSPlayerController.m_sSanitizedPlayerName =
      ReadJsonData(client["client.dll"]["classes"]["CCSPlayerController"]
                         ["fields"]["m_sSanitizedPlayerName"],
                   0);
  Offset::CCSPlayerController.m_iPawnArmor =
      ReadJsonData(client["client.dll"]["classes"]["CCSPlayerController"]
                         ["fields"]["m_iPawnArmor"],
                   0);
  Offset::CCSPlayerController.m_bPawnHasDefuser =
      ReadJsonData(client["client.dll"]["classes"]["CCSPlayerController"]
                         ["fields"]["m_bPawnHasDefuser"],
                   0);
  Offset::CCSPlayerController.m_bPawnHasHelmet =
      ReadJsonData(client["client.dll"]["classes"]["CCSPlayerController"]
                         ["fields"]["m_bPawnHasHelmet"],
                   0);
  Offset::CCSPlayerController.m_iPing =
      ReadJsonData(client["client.dll"]["classes"]["CCSPlayerController"]
                         ["fields"]["m_iPing"],
                   0);
  Offset::CCSPlayerController.m_pInGameMoneyServices =
      ReadJsonData(client["client.dll"]["classes"]["CCSPlayerController"]
                         ["fields"]["m_pInGameMoneyServices"],
                   0);

  Offset::C_BasePlayerPawn.m_pMovementServices =
      ReadJsonData(client["client.dll"]["classes"]["C_BasePlayerPawn"]["fields"]
                         ["m_pMovementServices"],
                   0);
  Offset::C_BasePlayerPawn.m_pWeaponServices =
      ReadJsonData(client["client.dll"]["classes"]["C_BasePlayerPawn"]["fields"]
                         ["m_pWeaponServices"],
                   0);
  Offset::C_BasePlayerPawn.m_pCameraServices =
      ReadJsonData(client["client.dll"]["classes"]["C_BasePlayerPawn"]["fields"]
                         ["m_pCameraServices"],
                   0);
  Offset::C_BasePlayerPawn.m_pObserverServices =
      ReadJsonData(client["client.dll"]["classes"]["C_BasePlayerPawn"]["fields"]
                         ["m_pObserverServices"],
                   0);
  Offset::C_BasePlayerPawn.m_vOldOrigin =
      ReadJsonData(client["client.dll"]["classes"]["C_BasePlayerPawn"]["fields"]
                         ["m_vOldOrigin"],
                   0);
  Offset::C_BasePlayerPawn.m_hController =
      ReadJsonData(client["client.dll"]["classes"]["C_BasePlayerPawn"]["fields"]
                         ["m_hController"],
                   0);

  Offset::C_CSPlayerPawnBase.m_pViewModelServices =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawnBase"]
                         ["fields"]["m_pViewModelServices"],
                   0);
  Offset::C_CSPlayerPawnBase.m_pClippingWeapon =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawnBase"]
                         ["fields"]["m_pClippingWeapon"],
                   0);
  Offset::C_CSPlayerPawnBase.m_angEyeAngles =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawnBase"]
                         ["fields"]["m_angEyeAngles"],
                   0);
  Offset::C_CSPlayerPawnBase.m_bGunGameImmunity =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawnBase"]
                         ["fields"]["m_bGunGameImmunity"],
                   0);
  Offset::C_CSPlayerPawnBase.m_vecLastClipCameraPos =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawnBase"]
                         ["fields"]["m_vecLastClipCameraPos"],
                   0);
  Offset::C_CSPlayerPawnBase.m_flFlashMaxAlpha =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawnBase"]
                         ["fields"]["m_flFlashMaxAlpha"],
                   0);
  Offset::C_CSPlayerPawnBase.m_flFlashDuration =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawnBase"]
                         ["fields"]["m_flFlashDuration"],
                   0);
  Offset::C_CSPlayerPawnBase.m_iIDEntIndex =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawnBase"]
                         ["fields"]["m_iIDEntIndex"],
                   0);

  Offset::C_CSPlayerPawn.m_pBulletServices =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawn"]["fields"]
                         ["m_pBulletServices"],
                   0);
  Offset::C_CSPlayerPawn.m_bIsScoped =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawn"]["fields"]
                         ["m_bIsScoped"],
                   0);
  Offset::C_CSPlayerPawn.m_bIsDefusing =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawn"]["fields"]
                         ["m_bIsDefusing"],
                   0);
  Offset::C_CSPlayerPawn.m_ArmorValue =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawn"]["fields"]
                         ["m_ArmorValue"],
                   0);
  Offset::C_CSPlayerPawn.m_iShotsFired =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawn"]["fields"]
                         ["m_iShotsFired"],
                   0);
  Offset::C_CSPlayerPawn.m_aimPunchAngle =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawn"]["fields"]
                         ["m_aimPunchAngle"],
                   0);
  Offset::C_CSPlayerPawn.m_aimPunchCache =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawn"]["fields"]
                         ["m_aimPunchCache"],
                   0);
  Offset::C_CSPlayerPawn.m_bIsBuyMenuOpen =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawn"]["fields"]
                         ["m_bIsBuyMenuOpen"],
                   0);
  Offset::C_CSPlayerPawn.m_bWaitForNoAttack =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawn"]["fields"]
                         ["m_bWaitForNoAttack"],
                   0);
  Offset::C_CSPlayerPawn.m_bSpottedByMask =
      ReadJsonData(client["client.dll"]["classes"]["C_CSPlayerPawn"]["fields"]
                         ["m_entitySpottedState"],
                   0) +
      ReadJsonData(client["client.dll"]["classes"]["EntitySpottedState_t"]
                         ["fields"]["m_bSpottedByMask"],
                   0);

  Offset::C_PlantedC4.m_flC4Blow = ReadJsonData(
      client["client.dll"]["classes"]["C_PlantedC4"]["fields"]["m_flC4Blow"],
      0);
  Offset::C_PlantedC4.m_bC4Activated =
      ReadJsonData(client["client.dll"]["classes"]["C_PlantedC4"]["fields"]
                         ["m_bC4Activated"],
                   0);
  Offset::C_PlantedC4.m_bBeingDefused =
      ReadJsonData(client["client.dll"]["classes"]["C_PlantedC4"]["fields"]
                         ["m_bBeingDefused"],
                   0);
  Offset::C_PlantedC4.m_bHasExploded =
      ReadJsonData(client["client.dll"]["classes"]["C_PlantedC4"]["fields"]
                         ["m_bHasExploded"],
                   0);
  Offset::C_PlantedC4.m_hBombDefuser =
      ReadJsonData(client["client.dll"]["classes"]["C_PlantedC4"]["fields"]
                         ["m_hBombDefuser"],
                   0);
  Offset::C_PlantedC4.m_flDefuseCountDown =
      ReadJsonData(client["client.dll"]["classes"]["C_PlantedC4"]["fields"]
                         ["m_flDefuseCountDown"],
                   0);
  Offset::C_PlantedC4.m_nBombSite = ReadJsonData(
      client["client.dll"]["classes"]["C_PlantedC4"]["fields"]["m_nBombSite"],
      0);

  Offset::CPlayer_ObserverServices.m_hObserverTarget =
      ReadJsonData(client["client.dll"]["classes"]["CPlayer_ObserverServices"]
                         ["fields"]["m_hObserverTarget"],
                   0);
  Offset::CPlayer_ObserverServices.m_iObserverMode =
      ReadJsonData(client["client.dll"]["classes"]["CPlayer_ObserverServices"]
                         ["fields"]["m_iObserverMode"],
                   0);
  Offset::CCSPlayer_ViewModelServices.m_hViewModel = ReadJsonData(
      client["client.dll"]["classes"]["CCSPlayer_ViewModelServices"]["fields"]
            ["m_hViewModel"],
      0);
  Offset::CPlayer_MovementServices_Humanoid.m_nCrouchState = ReadJsonData(
      client["client.dll"]["classes"]["CPlayer_MovementServices_Humanoid"]
            ["fields"]["m_nCrouchState"],
      0);
  Offset::CCSPlayerBase_CameraServices.m_iFOVStart = ReadJsonData(
      client["client.dll"]["classes"]["CCSPlayerBase_CameraServices"]["fields"]
            ["m_iFOVStart"],
      0);
  Offset::CCSPlayer_BulletServices.m_totalHitsOnServer =
      ReadJsonData(client["client.dll"]["classes"]["CCSPlayer_BulletServices"]
                         ["fields"]["m_totalHitsOnServer"],
                   0);

  Offset::CCSPlayerController_InGameMoneyServices.m_iAccount = ReadJsonData(
      client["client.dll"]["classes"]["CCSPlayerController_InGameMoneyServices"]
            ["fields"]["m_iAccount"],
      0);
  Offset::CCSPlayerController_InGameMoneyServices
      .m_iTotalCashSpent = ReadJsonData(
      client["client.dll"]["classes"]["CCSPlayerController_InGameMoneyServices"]
            ["fields"]["m_iTotalCashSpent"],
      0);
  Offset::CCSPlayerController_InGameMoneyServices
      .m_iCashSpentThisRound = ReadJsonData(
      client["client.dll"]["classes"]["CCSPlayerController_InGameMoneyServices"]
            ["fields"]["m_iCashSpentThisRound"],
      0);

  Offset::WeaponBaseData.WeaponDataPTR =
      ReadJsonData(client["client.dll"]["classes"]["C_BaseEntity"]["fields"]
                         ["m_nSubclassID"],
                   0) +
      0x08;
  Offset::WeaponBaseData.szName =
      ReadJsonData(client["client.dll"]["classes"]["CCSWeaponBaseVData"]
                         ["fields"]["m_szName"],
                   0);
  Offset::WeaponBaseData.Clip1 =
      ReadJsonData(client["client.dll"]["classes"]["C_BasePlayerWeapon"]
                         ["fields"]["m_iClip1"],
                   0);
  Offset::WeaponBaseData.MaxClip =
      ReadJsonData(client["client.dll"]["classes"]["CBasePlayerWeaponVData"]
                         ["fields"]["m_iMaxClip1"],
                   0);
  Offset::WeaponBaseData.CycleTime =
      ReadJsonData(client["client.dll"]["classes"]["CCSWeaponBaseVData"]
                         ["fields"]["m_flCycleTime"],
                   0);
  Offset::WeaponBaseData.Penetration =
      ReadJsonData(client["client.dll"]["classes"]["CCSWeaponBaseVData"]
                         ["fields"]["m_flPenetration"],
                   0);
  Offset::WeaponBaseData.WeaponType =
      ReadJsonData(client["client.dll"]["classes"]["CCSWeaponBaseVData"]
                         ["fields"]["m_WeaponType"],
                   0);
  Offset::WeaponBaseData.Inaccuracy =
      ReadJsonData(client["client.dll"]["classes"]["CCSWeaponBaseVData"]
                         ["fields"]["m_flInaccuracyMove"],
                   0);
  Offset::WeaponBaseData.inReload =
      ReadJsonData(client["client.dll"]["classes"]["C_CSWeaponBase"]["fields"]
                         ["m_bInReload"],
                   0);
  Offset::WeaponBaseData.m_nNumBullets =
      ReadJsonData(client["client.dll"]["classes"]["CCSWeaponBaseVData"]
                         ["fields"]["m_nNumBullets"],
                   0);
  Offset::WeaponBaseData.ActiveWeapon =
      ReadJsonData(client["client.dll"]["classes"]["CPlayer_WeaponServices"]
                         ["fields"]["m_hActiveWeapon"],
                   0);
  Offset::WeaponBaseData.Item =
      ReadJsonData(client["client.dll"]["classes"]["C_AttributeContainer"]
                         ["fields"]["m_Item"],
                   0);
  Offset::WeaponBaseData.ItemDefinitionIndex =
      ReadJsonData(client["client.dll"]["classes"]["C_EconItemView"]["fields"]
                         ["m_iItemDefinitionIndex"],
                   0);
  Offset::WeaponBaseData.m_MeshGroupMask = ReadJsonData(
      client["client.dll"]["classes"]["CModelState"]["m_MeshGroupMask"], 0);
  Offset::WeaponBaseData.m_bIsFullAuto =
      ReadJsonData(client["client.dll"]["classes"]["CCSWeaponBaseVData"]
                         ["fields"]["m_bIsFullAuto"],
                   0);

  Offset::EconEntity.AttributeManager = ReadJsonData(
      client["client.dll"]["classes"]["C_EconEntity"]["m_AttributeManager"], 0);
  Offset::EconEntity.FallbackPaintKit = ReadJsonData(
      client["client.dll"]["classes"]["C_EconEntity"]["m_nFallbackPaintKit"],
      0);
  Offset::EconEntity.FallbackSeed = ReadJsonData(
      client["client.dll"]["classes"]["C_EconEntity"]["m_nFallbackSeed"], 0);
  Offset::EconEntity.FallbackWear = ReadJsonData(
      client["client.dll"]["classes"]["C_EconEntity"]["m_flFallbackWear"], 0);
  Offset::EconEntity.FallbackStatTrak = ReadJsonData(
      client["client.dll"]["classes"]["C_EconEntity"]["m_nFallbackStatTrak"],
      0);
  Offset::EconEntity.szCustomName =
      ReadJsonData(client["client.dll"]["classes"]["C_EconItemView"]["fields"]
                         ["m_szCustomName"],
                   0);
  Offset::EconEntity.EntityQuality =
      ReadJsonData(client["client.dll"]["classes"]["C_EconItemView"]["fields"]
                         ["m_iEntityQuality"],
                   0);
  Offset::EconEntity.ItemIDHigh =
      ReadJsonData(client["client.dll"]["classes"]["C_EconItemView"]["fields"]
                         ["m_iItemIDHigh"],
                   0);

  Offset::SmokeGrenadeProjectile.nSmokeEffectTickBegin =
      ReadJsonData(client["client.dll"]["classes"]["C_SmokeGrenadeProjectile"]
                         ["fields"]["m_nSmokeEffectTickBegin"],
                   0);
  Offset::SmokeGrenadeProjectile.bDidSmokeEffect =
      ReadJsonData(client["client.dll"]["classes"]["C_SmokeGrenadeProjectile"]
                         ["fields"]["m_bDidSmokeEffect"],
                   0);
  Offset::SmokeGrenadeProjectile.nRandomSeed =
      ReadJsonData(client["client.dll"]["classes"]["C_SmokeGrenadeProjectile"]
                         ["fields"]["m_nRandomSeed"],
                   0);
  Offset::SmokeGrenadeProjectile.vSmokeColor =
      ReadJsonData(client["client.dll"]["classes"]["C_SmokeGrenadeProjectile"]
                         ["fields"]["m_vSmokeColor"],
                   0);
  Offset::SmokeGrenadeProjectile.vSmokeDetonationPos =
      ReadJsonData(client["client.dll"]["classes"]["C_SmokeGrenadeProjectile"]
                         ["fields"]["m_vSmokeDetonationPos"],
                   0);
  Offset::SmokeGrenadeProjectile.VoxelFrameData =
      ReadJsonData(client["client.dll"]["classes"]["C_SmokeGrenadeProjectile"]
                         ["fields"]["m_VoxelFrameData"],
                   0);
  Offset::SmokeGrenadeProjectile.bSmokeVolumeDataReceived =
      ReadJsonData(client["client.dll"]["classes"]["C_SmokeGrenadeProjectile"]
                         ["fields"]["m_bSmokeVolumeDataReceived"],
                   0);
  Offset::SmokeGrenadeProjectile.bSmokeEffectSpawned =
      ReadJsonData(client["client.dll"]["classes"]["C_SmokeGrenadeProjectile"]
                         ["fields"]["m_bSmokeEffectSpawned"],
                   0);

  return true;
}



================================================
FILE: Offsets.h
================================================
#pragma once
#include <windows.h>
#include <cstdint>
/*
We using a2x header for quick PoC while develop & to figure out type of data
In the end, we use our own offset system by reading offset.yaml for release
version.
*/
class CGlobalVarsBase {
 public:
  float m_realtime;            // 0x0000
  int32_t m_framecount;        // 0x0004
  float m_frametime;           // 0x0008
  float m_abs_frametime;       // 0x000C
  int32_t m_maxclients;        // 0x0010
  char pad_0014[28];           // 0x0014
  float m_frametime2;          // 0x0030
  float m_curtime;             // 0x0034
  float m_curtime2;            // 0x0038
  char pad_003C[20];           // 0x003C
  int32_t m_tickcount;         // 0x0050
  char pad_0054[292];          // 0x0054
  uintptr_t m_current_map;      // 0x0178
  uintptr_t m_current_mapname;  // 0x0180
};

namespace Offset {

extern uintptr_t ForceJump;
extern uintptr_t ForceCrouch;
extern uintptr_t ForceForward;
extern uintptr_t ForceLeft;
extern uintptr_t ForceRight;

extern uintptr_t EntityList;
extern uintptr_t Matrix;
extern uintptr_t ViewAngle;
extern uintptr_t LocalPlayerController;
extern uintptr_t LocalPlayerPawn;
extern uintptr_t GlobalVars;
extern uintptr_t CSGOInput;
extern uintptr_t InventoryServices;
extern uintptr_t PlantedC4;
extern uintptr_t InputSystem;
extern uintptr_t dwSensitivity;
extern uintptr_t Sensitivity;
extern uintptr_t BuildNumber;
extern uintptr_t dwNetworkGameClient_signOnState;
extern uintptr_t VEngineCvar007;

              // yaml(need
         // manual dump tho)
// entity stuff
struct C_BaseEntityT {
  DWORD m_flGravityScale;
  DWORD m_iMaxHealth;      // C_BaseEntity::m_iMaxHealth
  DWORD m_iHealth;         // C_BaseEntity::m_iHealth
  DWORD m_pGameSceneNode;  // C_BaseEntity::m_pGameSceneNode
  DWORD m_pCollision;
  DWORD m_vecAbsVelocity;
  DWORD m_fFlags;
  DWORD m_iTeamNum;
} ;
extern C_BaseEntityT C_BaseEntity;
struct C_BaseModelEntityT {
  DWORD GlowFunction;
  DWORD GlowColorOverride;
};
extern C_BaseModelEntityT C_BaseModelEntity;
// gamescenenode stuff
struct CGameSceneNodeT {
  DWORD m_vecOrigin;
  DWORD m_bDormant;
};
extern CGameSceneNodeT CGameSceneNode;

struct CCollisionPropertyT {
  DWORD m_vecMins;
  DWORD m_vecMaxs;
};
extern CCollisionPropertyT CCollisionProperty;
// contoller stuff
struct CBasePlayerControllerT {
  DWORD m_hPawn;
  DWORD m_iszPlayerName;
  DWORD m_iDesiredFOV;
  DWORD m_steamID;
};
extern CBasePlayerControllerT CBasePlayerController;

struct CCSPlayerControllerT {
  DWORD m_bPawnIsAlive;
  DWORD m_bControllingBot;
  DWORD m_bEverPlayedOnTeam;
  DWORD m_hPlayerPawn;
  DWORD m_sSanitizedPlayerName;
  DWORD m_iPawnArmor;
  DWORD m_bPawnHasDefuser;
  DWORD m_bPawnHasHelmet;
  DWORD m_iPing;
  DWORD m_pInGameMoneyServices;
};
extern CCSPlayerControllerT CCSPlayerController;
    // pawn stuff
struct C_BasePlayerPawnT {
  DWORD m_pMovementServices;  // CPlayer_MovementServices*
  DWORD m_pWeaponServices;    // CPlayer_WeaponServices*
  DWORD m_pCameraServices;    // CPlayer_CameraServices*
  DWORD m_pObserverServices;
  DWORD m_vOldOrigin;  // C_BasePlayerPawn::m_vOldOrigin
  DWORD m_hController;
};
extern C_BasePlayerPawnT C_BasePlayerPawn;

struct C_CSPlayerPawnBaseT {
  DWORD m_pViewModelServices;  // CPlayer_ViewModelServices*
  DWORD m_pClippingWeapon;     // C_CSWeaponBase*
  DWORD m_angEyeAngles;
  DWORD m_bGunGameImmunity;
  DWORD m_vecLastClipCameraPos;
  DWORD m_flFlashMaxAlpha;
  DWORD m_flFlashDuration;
  DWORD m_iIDEntIndex;
};
extern C_CSPlayerPawnBaseT C_CSPlayerPawnBase;

struct C_CSPlayerPawnT {
  DWORD m_pBulletServices;  // CCSPlayer_BulletServices*
  DWORD m_bIsScoped;
  DWORD m_bIsDefusing;
  DWORD m_ArmorValue;  // C_CSPlayerPawn::m_ArmorValue
  DWORD m_iShotsFired;
  DWORD m_aimPunchAngle;  // C_CSPlayerPawn::m_aimPunchAngle
  DWORD m_aimPunchCache;
  DWORD m_bIsBuyMenuOpen;
  DWORD m_bWaitForNoAttack;
  DWORD m_bSpottedByMask;  // C_CSPlayerPawn::entitySpottedState +
                           // EntitySpottedState_t::bSpottedByMask
};
extern C_CSPlayerPawnT C_CSPlayerPawn;
// C4 stuff
struct C_PlantedC4T {
  DWORD m_flC4Blow;
  DWORD m_bC4Activated;
  DWORD m_bBeingDefused;
  DWORD m_bHasExploded;
  DWORD m_flDefuseCountDown;
  DWORD m_hBombDefuser;
  DWORD m_nBombSite;
};
extern C_PlantedC4T C_PlantedC4;
// services stuff
struct CPlayer_ObserverServicesT {
  DWORD m_hObserverTarget;
  DWORD m_iObserverMode;
};
extern CPlayer_ObserverServicesT CPlayer_ObserverServices;
struct CCSPlayer_ViewModelServicesT {
  DWORD m_hViewModel;  // CCSPlayer_ViewModelServices::m_hViewModel
};
extern CCSPlayer_ViewModelServicesT CCSPlayer_ViewModelServices;
struct CPlayer_MovementServices_HumanoidT {
  DWORD m_nCrouchState;
};
extern CPlayer_MovementServices_HumanoidT CPlayer_MovementServices_Humanoid;
struct CCSPlayerBase_CameraServicesT {
  DWORD m_iFOVStart;
};
extern CCSPlayerBase_CameraServicesT CCSPlayerBase_CameraServices;
struct CCSPlayer_BulletServicesT {
  DWORD m_totalHitsOnServer;
};
extern CCSPlayer_BulletServicesT CCSPlayer_BulletServices;
struct CCSPlayerController_InGameMoneyServicesT {
  DWORD m_iAccount;
  DWORD m_iTotalCashSpent;
  DWORD m_iCashSpentThisRound;
};
extern CCSPlayerController_InGameMoneyServicesT
    CCSPlayerController_InGameMoneyServices;

// random misc stuff
struct EconEntityT {
  DWORD AttributeManager;  // C_AttributeContainer
  DWORD FallbackPaintKit;
  DWORD FallbackSeed;
  DWORD FallbackWear;
  DWORD FallbackStatTrak;
  DWORD szCustomName;
  DWORD EntityQuality;  // EconItemView::m_iEntityQuality
  DWORD ItemIDHigh;     // EconItemView::m_iItemIDHigh
};
extern EconEntityT EconEntity;

struct WeaponBaseDataT {
  DWORD WeaponDataPTR;
  DWORD szName;
  DWORD Clip1;    // C_BasePlayerWeapon::m_iClip1
  DWORD MaxClip;  // CBasePlayerWeaponVData::m_iMaxClip1
  DWORD CycleTime;
  DWORD Penetration;
  DWORD WeaponType;
  DWORD Inaccuracy;  // CCSWeaponBaseVData::m_flInaccuracyMove
  DWORD inReload;
  DWORD m_nNumBullets;
  DWORD WeaponSize;
  DWORD ActiveWeapon;
  DWORD Item;  // C_AttributeContainer::m_Item
  DWORD ItemDefinitionIndex;
  DWORD m_MeshGroupMask;  // CModelState::m_MeshGroupMask
  DWORD m_bIsFullAuto;
};
extern WeaponBaseDataT WeaponBaseData;

struct SmokeGrenadeProjectileT  // C_BaseCSGrenadeProjectile
{
  DWORD nSmokeEffectTickBegin;     // int32_t
  DWORD bDidSmokeEffect;           // bool
  DWORD nRandomSeed;               // int32_t
  DWORD vSmokeColor;               // Vector
  DWORD vSmokeDetonationPos;       // Vector
  DWORD VoxelFrameData;            // CUtlVector<uint8_t>
  DWORD bSmokeVolumeDataReceived;  // bool
  uintptr_t bSmokeEffectSpawned;   // bool
};
extern SmokeGrenadeProjectileT SmokeGrenadeProjectile;

struct PawnT {
  DWORD BoneArray;
};
extern PawnT Pawn;

bool UpdateOffsets();
}  // namespace Offset



================================================
FILE: Overlay.cc
================================================
﻿#include "pch.h"
#include "Overlay.h"

#include "Functions/config.h"

#define STB_IMAGE_IMPLEMENTATION
#include "./Utils/stb_image.h"
std::string string_To_UTF8(const std::string& str) noexcept {
  int nwLen = ::MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, NULL, 0);
  wchar_t* pwBuf = new wchar_t[nwLen + 1];
  ZeroMemory(pwBuf, nwLen * 2 + 2);
  ::MultiByteToWideChar(CP_ACP, 0, str.c_str(), (int)str.length(), pwBuf, nwLen);
  int nLen =
      ::WideCharToMultiByte(CP_UTF8, 0, pwBuf, -1, NULL, NULL, NULL, NULL);
  char* pBuf = new char[nLen + 1];
  ZeroMemory(pBuf, nLen + 1);
  ::WideCharToMultiByte(CP_UTF8, 0, pwBuf, nwLen, pBuf, nLen, NULL, NULL);
  std::string retStr(pBuf);
  delete[] pwBuf;
  delete[] pBuf;
  pwBuf = NULL;
  pBuf = NULL;
  return retStr;
}

void DrawStrokeText(float x, float y, RGBA* color, const char* str,
                    ImDrawList* drawlist) noexcept {
  ImFont a;
  std::string utf_8_1 = std::string(str);
  std::string utf_8_2 = string_To_UTF8(utf_8_1);
  drawlist->AddText(ImVec2(x, y - 1),
                    ImGui::ColorConvertFloat4ToU32(
                        ImVec4(1 / 255.f, 1 / 255.f, 1 / 255.f, 255 / 255.f)),
                    utf_8_2.c_str());
  drawlist->AddText(ImVec2(x, y + 1),
                    ImGui::ColorConvertFloat4ToU32(
                        ImVec4(1 / 255.f, 1 / 255.f, 1 / 255.f, 255 / 255.f)),
                    utf_8_2.c_str());
  drawlist->AddText(ImVec2(x - 1, y),
                    ImGui::ColorConvertFloat4ToU32(
                        ImVec4(1 / 255.f, 1 / 255.f, 1 / 255.f, 255 / 255.f)),
                    utf_8_2.c_str());
  drawlist->AddText(ImVec2(x + 1, y),
                    ImGui::ColorConvertFloat4ToU32(
                        ImVec4(1 / 255.f, 1 / 255.f, 1 / 255.f, 255 / 255.f)),
                    utf_8_2.c_str());
  drawlist->AddText(ImVec2(x, y),
                    ImGui::ColorConvertFloat4ToU32(
                        ImVec4(color->R / 255.f, color->G / 255.f,
                               color->B / 255.f, color->A / 255.f)),
                    utf_8_2.c_str());
}

void DrawNewText(float x, float y, RGBA* color, const char* str,
                 ImDrawList* drawlist) noexcept {
  ImFont a;
  std::string utf_8_1 = std::string(str);
  std::string utf_8_2 = string_To_UTF8(utf_8_1);
  drawlist->AddText(ImVec2(x, y),
                    ImGui::ColorConvertFloat4ToU32(
                        ImVec4(color->R / 255.f, color->G / 255.f,
                               color->B / 255.f, color->A / 255.f)),
                    utf_8_2.c_str());
}

void DrawRect(float x, float y, float w, float h, RGBA* color, float thickness,
              ImDrawList* drawlist) noexcept {
  drawlist->AddRect(ImVec2(x, y), ImVec2(x + w, y + h),
                    ImGui::ColorConvertFloat4ToU32(
                        ImVec4(color->R / 255.f, color->G / 255.f,
                               color->B / 255.f, color->A / 255.f)),
                    0, 0, thickness);
}

void DrawEspBox2D(Vector2 feet, Vector2 head, RGBA* color, float thickness,
                  ImDrawList* drawlist) noexcept {
  float t = feet.x - head.x;
  float height = feet.y - head.y;
  float pd = feet.x + t;

  ImVec4 boxColor(color->R / 255.f, color->G / 255.f, color->B / 255.f,
                  color->A / 255.f);

  // Calculate box position and draw the rectangle
  ImVec2 boxMin(head.x - (height / 2) / 2, head.y);
  ImVec2 boxMax(pd + (height / 2) / 2, feet.y);

  drawlist->AddRect(boxMin, boxMax, ImColor(boxColor), 0.0f, 0, thickness);
  drawlist->AddRect(ImVec2(boxMin.x - thickness, boxMin.y - thickness),
                    ImVec2(boxMax.x + thickness, boxMax.y + thickness),
                    ImColor(0, 0, 0, 255), 0.0f, 0, thickness);
  drawlist->AddRect(ImVec2(boxMin.x + thickness, boxMin.y + thickness),
                    ImVec2(boxMax.x - thickness, boxMax.y - thickness),
                    ImColor(0, 0, 0, 255), 0.0f, 0, thickness);
}

void DrawNameTag(Vector2 feet, Vector2 head, char* name,
                 ImDrawList* drawlist) noexcept {
  float t = feet.x - head.x;
  float pd = feet.x + t;

  ImVec2 boxMin(head.x - 5, head.y);
  ImVec2 boxMax(pd, feet.y);

  const ImVec2 textSize = ImGui::CalcTextSize(name);
  const ImVec2 textPos = ImFloor(
      {(boxMin.x + boxMax.x - textSize.x) / 2.f, boxMin.y - textSize.y - 2.f});

  drawlist->AddText(ImVec2(textPos.x + 1.f, textPos.y + 1.f),
                    IM_COL32(0, 0, 0, 255), name);
  drawlist->AddText(textPos, IM_COL32(255, 255, 255, 255), name);
}

void DrawFilledRect(float x, float y, float w, float h, RGBA* color,
                    ImDrawList* drawlist) noexcept {
  drawlist->AddRectFilled(ImVec2(x, y), ImVec2(x + w, y + h),
                          ImGui::ColorConvertFloat4ToU32(
                              ImVec4(color->R / 255.f, color->G / 255.f,
                                     color->B / 255.f, color->A / 255.f)),
                          0, 0);
}

void DrawCircleFilled(float x, float y, float radius, RGBA* color,
                      ImDrawList* drawlist) noexcept {
  drawlist->AddCircleFilled(ImVec2(x, y), radius,
                            ImGui::ColorConvertFloat4ToU32(
                                ImVec4(color->R / 255.f, color->G / 255.f,
                                       color->B / 255.f, color->A / 255.f)));
}

void DrawCircle(float x, float y, float radius, RGBA* color, int segments,
                ImDrawList* drawlist) noexcept {
  drawlist->AddCircle(ImVec2(x, y), radius,
                      ImGui::ColorConvertFloat4ToU32(
                          ImVec4(color->R / 255.f, color->G / 255.f,
                                 color->B / 255.f, color->A / 255.f)),
                      segments);
}

void DrawTriangle(float x1, float y1, float x2, float y2, float x3, float y3,
                  RGBA* color,
                  float thickne, ImDrawList* drawlist) noexcept {
  drawlist->AddTriangle(ImVec2(x1, y1), ImVec2(x2, y2), ImVec2(x3, y3),
                        ImGui::ColorConvertFloat4ToU32(
                            ImVec4(color->R / 255.f, color->G / 255.f,
                                   color->B / 255.f, color->A / 255.f)),
                        thickne);
}

void DrawTriangleFilled(float x1, float y1, float x2, float y2, float x3,
                        float y3,
                        RGBA* color, ImDrawList* drawlist) noexcept {
  drawlist->AddTriangleFilled(ImVec2(x1, y1), ImVec2(x2, y2), ImVec2(x3, y3),
                              ImGui::ColorConvertFloat4ToU32(
                                  ImVec4(color->R / 255.f, color->G / 255.f,
                                         color->B / 255.f, color->A / 255.f)));
}

void DrawLine(float x1, float y1, float x2, float y2, RGBA* color,
              float thickness,
              ImDrawList* drawlist) noexcept {
  drawlist->AddLine(ImVec2(x1, y1), ImVec2(x2, y2),
                    ImGui::ColorConvertFloat4ToU32(
                        ImVec4(color->R / 255.f, color->G / 255.f,
                               color->B / 255.f, color->A / 255.f)),
                    thickness);
}

void DrawCornerBox(float x, float y, float w, float h, float borderPx,
                   RGBA* color,
                   ImDrawList* drawlist) noexcept {
  DrawFilledRect(x + borderPx, y, w / 3, borderPx, color, drawlist);
  DrawFilledRect(x + w - w / 3 + borderPx, y, w / 3, borderPx, color, drawlist);
  DrawFilledRect(x, y, borderPx, h / 3, color, drawlist);
  DrawFilledRect(x, y + h - h / 3 + borderPx * 2, borderPx, h / 3, color,
                 drawlist);
  DrawFilledRect(x + borderPx, y + h + borderPx, w / 3, borderPx, color,
                 drawlist);
  DrawFilledRect(x + w - w / 3 + borderPx, y + h + borderPx, w / 3, borderPx,
                 color, drawlist);
  DrawFilledRect(x + w + borderPx, y, borderPx, h / 3, color, drawlist);
  DrawFilledRect(x + w + borderPx, y + h - h / 3 + borderPx * 2, borderPx,
                 h / 3, color, drawlist);
}
void DrawHealthBar(Vector2 feet, Vector2 head, int curHealth, int maxHealth,
                   RGBA* barColor, RGBA* backColor,
                   ImDrawList* drawlist) noexcept {
  if (curHealth > maxHealth) curHealth = maxHealth;
  if (curHealth < 0) curHealth = 0;
  float boxHeight = feet.y - head.y;
  float t = feet.x - head.x;
  float pd = feet.x + t;
  ImVec2 boxMin(head.x - (boxHeight / 2) / 2, head.y);
  ImVec2 boxMax(pd + (boxHeight / 2) / 2, feet.y);

  int barWidth = 5;
  float barX = boxMin.x - barWidth - 3;
  float barY = boxMin.y;
  float barHeight = boxMax.y - boxMin.y;

  drawlist->AddRectFilled(ImVec2(barX, barY),
                          ImVec2(barX + barWidth, barY + barHeight),
                          ImGui::ColorConvertFloat4ToU32(ImVec4(
                              backColor->R / 255.f, backColor->G / 255.f,
                              backColor->B / 255.f, backColor->A / 255.f)));

  float healthRatio = (float)curHealth / (float)maxHealth;
  float healthHeight = barHeight * healthRatio;
  float healthTop = barY + (barHeight - healthHeight);

  drawlist->AddRectFilled(ImVec2(barX, healthTop),
                          ImVec2(barX + barWidth, barY + barHeight),
                          ImGui::ColorConvertFloat4ToU32(ImVec4(
                              barColor->R / 255.f, barColor->G / 255.f,
                              barColor->B / 255.f, barColor->A / 255.f)));

  drawlist->AddRect(ImVec2(barX, barY),
                    ImVec2(barX + barWidth, barY + barHeight),
                    IM_COL32(0, 0, 0, 255));

  if (curHealth < maxHealth) {
    char hpText[16];
    snprintf(hpText, sizeof(hpText), "%d", curHealth);
    ImVec2 textSize = ImGui::CalcTextSize(hpText);
    float textX = barX + (barWidth - textSize.x) / 2.0f;
    float textY = healthTop - textSize.y - 2.0f;
    drawlist->AddText(ImVec2(textX + 1, textY + 1), IM_COL32(0, 0, 0, 255),
                      hpText);
    drawlist->AddText(ImVec2(textX, textY), IM_COL32(255, 255, 255, 255),
                      hpText);
  }
}

bool LoadTextureFromMemory(IDirect3DDevice9* device,
                           const unsigned char* image_data, size_t image_size,
                           IDirect3DTexture9** out_texture) noexcept {
  int width, height, channels;
  unsigned char* data = stbi_load_from_memory(image_data, static_cast<int>(image_size), &width,
                                              &height, &channels, 4);
  if (!data) return false;

  if (device->CreateTexture(width, height, 1, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8,
                            D3DPOOL_DEFAULT, out_texture, nullptr) != D3D_OK) {
    stbi_image_free(data);
    return false;
  }

  D3DLOCKED_RECT rect;
  (*out_texture)->LockRect(0, &rect, nullptr, D3DLOCK_DISCARD);

  for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
      unsigned char* src = data + (y * width + x) * 4;
      unsigned char* dest =
          (unsigned char*)rect.pBits + (y * rect.Pitch) + (x * 4);
      dest[0] = src[2];  // R
      dest[1] = src[1];  // G
      dest[2] = src[0];  // B
      dest[3] = src[3];  // A
    }
  }
  (*out_texture)->UnlockRect(0);

  stbi_image_free(data);
  return true;
}

int ImGuiKeyToVK(int imguiKey) {
  switch (imguiKey) {
    case ImGuiKey_Tab:
      return VK_TAB;
    case ImGuiKey_LeftArrow:
      return VK_LEFT;
    case ImGuiKey_RightArrow:
      return VK_RIGHT;
    case ImGuiKey_UpArrow:
      return VK_UP;
    case ImGuiKey_DownArrow:
      return VK_DOWN;
    case ImGuiKey_PageUp:
      return VK_PRIOR;
    case ImGuiKey_PageDown:
      return VK_NEXT;
    case ImGuiKey_Home:
      return VK_HOME;
    case ImGuiKey_End:
      return VK_END;
    case ImGuiKey_Insert:
      return VK_INSERT;
    case ImGuiKey_Delete:
      return VK_DELETE;
    case ImGuiKey_Backspace:
      return VK_BACK;
    case ImGuiKey_Space:
      return VK_SPACE;
    case ImGuiKey_Enter:
      return VK_RETURN;
    case ImGuiKey_Escape:
      return VK_ESCAPE;
    case ImGuiKey_A:
      return 'A';
    case ImGuiKey_B:
      return 'B';
    case ImGuiKey_C:
      return 'C';
    case ImGuiKey_D:
      return 'D';
    case ImGuiKey_E:
      return 'E';
    case ImGuiKey_F:
      return 'F';
    case ImGuiKey_G:
      return 'G';
    case ImGuiKey_H:
      return 'H';
    case ImGuiKey_I:
      return 'I';
    case ImGuiKey_J:
      return 'J';
    case ImGuiKey_K:
      return 'K';
    case ImGuiKey_L:
      return 'L';
    case ImGuiKey_M:
      return 'M';
    case ImGuiKey_N:
      return 'N';
    case ImGuiKey_O:
      return 'O';
    case ImGuiKey_P:
      return 'P';
    case ImGuiKey_Q:
      return 'Q';
    case ImGuiKey_R:
      return 'R';
    case ImGuiKey_S:
      return 'S';
    case ImGuiKey_T:
      return 'T';
    case ImGuiKey_U:
      return 'U';
    case ImGuiKey_V:
      return 'V';
    case ImGuiKey_W:
      return 'W';
    case ImGuiKey_X:
      return 'X';
    case ImGuiKey_Y:
      return 'Y';
    case ImGuiKey_Z:
      return 'Z';
    case ImGuiKey_F1:
      return VK_F1;
    case ImGuiKey_F2:
      return VK_F2;
    case ImGuiKey_F3:
      return VK_F3;
    case ImGuiKey_F4:
      return VK_F4;
    case ImGuiKey_F5:
      return VK_F5;
    case ImGuiKey_F6:
      return VK_F6;
    case ImGuiKey_F7:
      return VK_F7;
    case ImGuiKey_F8:
      return VK_F8;
    case ImGuiKey_F9:
      return VK_F9;
    case ImGuiKey_F10:
      return VK_F10;
    case ImGuiKey_F11:
      return VK_F11;
    case ImGuiKey_F12:
      return VK_F12;
    case ImGuiKey_MouseLeft:
      return VK_LBUTTON;
    case ImGuiKey_MouseRight:
      return VK_RBUTTON;
    case ImGuiKey_MouseMiddle:
      return VK_MBUTTON;
    case ImGuiKey_MouseX1:
      return VK_XBUTTON1;
    case ImGuiKey_MouseX2:
      return VK_XBUTTON2;

    case ImGuiKey_0:
      return '0';
    case ImGuiKey_1:
      return '1';
    case ImGuiKey_2:
      return '2';
    case ImGuiKey_3:
      return '3';
    case ImGuiKey_4:
      return '4';
    case ImGuiKey_5:
      return '5';
    case ImGuiKey_6:
      return '6';
    case ImGuiKey_7:
      return '7';
    case ImGuiKey_8:
      return '8';
    case ImGuiKey_9:
      return '9';

    case ImGuiKey_Keypad0:
      return VK_NUMPAD0;
    case ImGuiKey_Keypad1:
      return VK_NUMPAD1;
    case ImGuiKey_Keypad2:
      return VK_NUMPAD2;
    case ImGuiKey_Keypad3:
      return VK_NUMPAD3;
    case ImGuiKey_Keypad4:
      return VK_NUMPAD4;
    case ImGuiKey_Keypad5:
      return VK_NUMPAD5;
    case ImGuiKey_Keypad6:
      return VK_NUMPAD6;
    case ImGuiKey_Keypad7:
      return VK_NUMPAD7;
    case ImGuiKey_Keypad8:
      return VK_NUMPAD8;
    case ImGuiKey_Keypad9:
      return VK_NUMPAD9;
    case ImGuiKey_KeypadDecimal:
      return VK_DECIMAL;
    case ImGuiKey_KeypadDivide:
      return VK_DIVIDE;
    case ImGuiKey_KeypadMultiply:
      return VK_MULTIPLY;
    case ImGuiKey_KeypadSubtract:
      return VK_SUBTRACT;
    case ImGuiKey_KeypadAdd:
      return VK_ADD;
    case ImGuiKey_KeypadEnter:
      return VK_RETURN;
    case ImGuiKey_KeypadEqual:
      return VK_OEM_PLUS;

    case ImGuiKey_Apostrophe:
      return VK_OEM_7;  // '
    case ImGuiKey_Comma:
      return VK_OEM_COMMA;  // ,
    case ImGuiKey_Minus:
      return VK_OEM_MINUS;  // -
    case ImGuiKey_Period:
      return VK_OEM_PERIOD;  // .
    case ImGuiKey_Slash:
      return VK_OEM_2;  // /
    case ImGuiKey_Semicolon:
      return VK_OEM_1;  // ;
    case ImGuiKey_Equal:
      return VK_OEM_PLUS;  // =
    case ImGuiKey_LeftBracket:
      return VK_OEM_4;  // [
    case ImGuiKey_Backslash:
      return VK_OEM_5;  // "\"
    case ImGuiKey_RightBracket: return VK_OEM_6;     // ]
    case ImGuiKey_GraveAccent:
      return VK_OEM_3;  // `

    case ImGuiKey_LeftCtrl:
      return VK_LCONTROL;
    case ImGuiKey_RightCtrl:
      return VK_RCONTROL;
    case ImGuiKey_LeftShift:
      return VK_LSHIFT;
    case ImGuiKey_RightShift:
      return VK_RSHIFT;
    case ImGuiKey_LeftAlt:
      return VK_LMENU;
    case ImGuiKey_RightAlt:
      return VK_RMENU;
    case ImGuiKey_LeftSuper:
      return VK_LWIN;
    case ImGuiKey_RightSuper:
      return VK_RWIN;

    case ImGuiKey_CapsLock:
      return VK_CAPITAL;
    case ImGuiKey_ScrollLock:
      return VK_SCROLL;
    case ImGuiKey_NumLock:
      return VK_NUMLOCK;

    case ImGuiKey_PrintScreen:
      return VK_SNAPSHOT;
    case ImGuiKey_Pause:
      return VK_PAUSE;
    case ImGuiKey_Menu:
      return VK_APPS;

    case ImGuiKey_F13:
      return VK_F13;
    case ImGuiKey_F14:
      return VK_F14;
    case ImGuiKey_F15:
      return VK_F15;
    case ImGuiKey_F16:
      return VK_F16;
    case ImGuiKey_F17:
      return VK_F17;
    case ImGuiKey_F18:
      return VK_F18;
    case ImGuiKey_F19:
      return VK_F19;
    case ImGuiKey_F20:
      return VK_F20;
    case ImGuiKey_F21:
      return VK_F21;
    case ImGuiKey_F22:
      return VK_F22;
    case ImGuiKey_F23:
      return VK_F23;
    case ImGuiKey_F24:
      return VK_F24;

    case ImGuiKey_AppBack:
      return VK_BROWSER_BACK;
    case ImGuiKey_AppForward:
      return VK_BROWSER_FORWARD;

    default:
      return 0; 
  }
}

bool GetBindState(KeyBind_t& keyBind) {
  if (keyBind.uKey == ImGuiKey_None) return false;

  int vk = ImGuiKeyToVK(keyBind.uKey);
  if (vk == 0) return false;

  switch (keyBind.nMode) {
    case EKeyBindMode::HOLD:
      keyBind.bEnable = (GetAsyncKeyState(vk) & 0x8000) != 0;
      break;
    case EKeyBindMode::TOGGLE: {
      static bool lastDown[256] = {0};
      bool isDown = (GetAsyncKeyState(vk) & 0x8000) != 0;
      if (isDown && !lastDown[vk]) {
        keyBind.bEnable = !keyBind.bEnable;
      }
      lastDown[vk] = isDown;
      break;
    }
    case EKeyBindMode::DISABLE: 
      keyBind.bEnable = (GetAsyncKeyState(vk) & 0x8000) == 0;
      break;
  }
  return keyBind.bEnable;
}

bool ImGui::HotKey(const char* szLabel, int* pKey) {
    ImGuiContext& g = *GImGui;
    ImGuiWindow* pWindow = g.CurrentWindow;
    if (pWindow->SkipItems) return false;

    ImGuiIO& io = g.IO;
    const ImGuiStyle& style = g.Style;
    const ImGuiID nIndex = pWindow->GetID(szLabel);

    const float flWidth = CalcItemWidth();
    const ImVec2 vecLabelSize = CalcTextSize(szLabel, nullptr, true);

    const ImRect rectFrame(
        pWindow->DC.CursorPos +
            ImVec2(vecLabelSize.x > 0.0f
                       ? style.ItemInnerSpacing.x + GetFrameHeight()
                       : 0.0f,
                   0.0f),
        pWindow->DC.CursorPos +
            ImVec2(flWidth, vecLabelSize.x > 0.0f
                                ? vecLabelSize.y + style.FramePadding.y
                                : 0.f));
    const ImRect rectTotal(rectFrame.Min, rectFrame.Max);

    ItemSize(rectTotal, style.FramePadding.y);
    if (!ItemAdd(rectTotal, nIndex, &rectFrame)) return false;

    const bool bHovered = ItemHoverable(rectFrame, nIndex, NULL);
    if (bHovered) {
        SetHoveredID(nIndex);
        g.MouseCursor = ImGuiMouseCursor_TextInput;
    }

    const bool bClicked = bHovered && io.MouseClicked[0];
    const bool bDoubleClicked = bHovered && io.MouseDoubleClicked[0];
    static ImGuiID lastActiveId = 0;
    static int skipFrame = 0;

    if (bClicked || bDoubleClicked) {
        if (g.ActiveId != nIndex) {
            std::memset(io.MouseDown, 0, sizeof(io.MouseDown));
            io.ClearInputKeys();
            *pKey = ImGuiKey_None;
            skipFrame = 1; // 激活后跳过一帧输入
            lastActiveId = nIndex;
        }
        SetActiveID(nIndex, pWindow);
        FocusWindow(pWindow);
    }

    bool bValueChanged = false;
    if (int nKey = *pKey; g.ActiveId == nIndex) {
        if (skipFrame > 0 && lastActiveId == nIndex) {
            --skipFrame;
        } else {
            for (int n = ImGuiKey_NamedKey_BEGIN; n < ImGuiKey_NamedKey_END; ++n) {
                if (ImGui::IsKeyPressed((ImGuiKey)n, false)) {
                    nKey = (ImGuiKey)n;
                    bValueChanged = true;
                    ClearActiveID();
                    break;
                }
            }
            if (ImGui::IsKeyPressed(ImGuiKey_Escape)) {
                *pKey = ImGuiKey_None;
                ClearActiveID();
            } else {
                *pKey = nKey;
            }
        }
    }

    char szBuffer[64] = {};
    char* szBufferEnd = std::strcpy(szBuffer, "  ");
    if (*pKey != ImGuiKey_None && g.ActiveId != nIndex)
        szBufferEnd = std::strcat(szBufferEnd, ImGui::GetKeyName(static_cast<ImGuiKey>(*pKey)));
    else if (g.ActiveId == nIndex)
      szBufferEnd =
          std::strcat(szBufferEnd, LangSettings::TextPress.c_str());
    else
      szBufferEnd =
          std::strcat(szBufferEnd, LangSettings::TextNone.c_str());
    std::strcat(szBufferEnd, "  ");

    PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(style.FramePadding.x, -1));
    const ImVec2 vecBufferSize = CalcTextSize(szBuffer);
    RenderFrame(ImVec2(rectFrame.Max.x - vecBufferSize.x, rectTotal.Min.y),
                ImVec2(rectFrame.Max.x,
                       rectTotal.Min.y + style.FramePadding.y + vecBufferSize.y),
                GetColorU32((bHovered || bClicked || bDoubleClicked)
                                ? ImGuiCol_FrameBgHovered
                                : ImGuiCol_FrameBg),
                true, style.FrameRounding);
    pWindow->DrawList->AddText(
        ImVec2(rectFrame.Max.x - vecBufferSize.x,
               rectTotal.Min.y + style.FramePadding.y),
        GetColorU32(g.ActiveId == nIndex ? ImGuiCol_Text : ImGuiCol_TextDisabled),
        szBuffer);

    if (vecLabelSize.x > 0.f)
        RenderText(ImVec2(rectTotal.Min.x, rectTotal.Min.y + style.FramePadding.y),
                   szLabel);

    PopStyleVar();
    return bValueChanged;
}

bool ImGui::HotKey(const char* szLabel, KeyBind_t* pKeyBind,
                   const bool bAllowSwitch) {
  const bool bValueChanged = HotKey(szLabel, &pKeyBind->uKey);

  if (bAllowSwitch) {
    PushID(szLabel);
    if (IsItemClicked(ImGuiMouseButton_Right)) OpenPopup(XorStr("key##Popup"));

    if (BeginPopup(XorStr("key##Popup"))) {
      SetNextItemWidth(95.f);
      const std::string& hold = LangSettings::TextHold;
      const std::string& toggle = LangSettings::TextToggle;
      const std::string& disable = LangSettings::TextDisable;
      std::string comboItems = hold + '\0' + toggle + '\0' + disable + '\0';
      comboItems.push_back('\0');

      if (Combo(XorStr("##keybind.mode"),
                reinterpret_cast<int*>(&pKeyBind->nMode), comboItems.c_str()))
        CloseCurrentPopup();

      EndPopup();
    }

    PopID();
  }

  return bValueChanged;
}


================================================
FILE: Overlay.h
================================================
﻿#pragma once
#include <Windows.h>
#include <d3d9.h>

#include <iostream>
#include <string>

#include "./ImGui/imgui.h"
#include "./ImGui/imgui_internal.h"
#include "./ImGui/imgui_impl_dx9.h"
#include "./ImGui/imgui_impl_win32.h"

#define ABS(X) ((X < 0) ? (-X) : (X))
#define BOX_OFFSET 20.f
#ifndef KEY_H
#define KEY_H
enum EKeyBindMode : int { HOLD = 0, TOGGLE,DISABLE};
struct KeyBind_t {
  constexpr KeyBind_t(int uKey = ImGuiKey_None,
                      int nMode = EKeyBindMode::HOLD)
      : uKey(uKey), nMode(nMode) {}

  bool bEnable = false;
  int uKey = ImGuiKey_None;
  int nMode = EKeyBindMode::HOLD;
};
#endif
#ifndef RGBA_H
#define RGBA_H

typedef struct {
  DWORD R;
  DWORD G;
  DWORD B;
  DWORD A;
} RGBA;
inline RGBA White = {255, 255, 255, 255};
inline RGBA Grey = {155, 155, 155, 255};
inline RGBA Black = {0, 0, 0, 255};
inline RGBA Red = {255, 0, 0, 255};
inline RGBA Green = {0, 255, 0, 255};
inline RGBA Blue = {0, 0, 255, 255};
inline RGBA Transparent = {0, 0, 0, 0};
#endif
#ifndef VECTOR2_H
#define VECTOR2_H
class Vector2 {
 public:
  float x, y;

 public:
  Vector2() : x(0.f), y(0.f) {}
  Vector2(float x_, float y_) : x(x_), y(y_) {}
  Vector2(ImVec2 ImVector2_) : x(ImVector2_.x), y(ImVector2_.y) {}

  Vector2 operator+(Vector2 Vector2_) {
    return {x + Vector2_.x, y + Vector2_.y};
  }
  Vector2 operator-(Vector2 Vector2_) {
    return {x - Vector2_.x, y - Vector2_.y};
  }
  Vector2 operator*(Vector2 Vector2_) {
    return {x * Vector2_.x, y * Vector2_.y};
  }
  Vector2 operator/(Vector2 Vector2_) {
    return {x / Vector2_.x, y / Vector2_.y};
  }
  Vector2 operator*(float n) { return {x / n, y / n}; }
  Vector2 operator/(float n) { return {x / n, y / n}; }
  bool operator==(Vector2 Vector2_) {
    return x == Vector2_.x && y == Vector2_.y;
  }
  bool operator!=(Vector2 Vector2_) {
    return x != Vector2_.x || y != Vector2_.y;
  }
  ImVec2 ToImVector2() noexcept { return ImVec2(x, y); }
  float Length() noexcept { return sqrtf(powf(x, 2) + powf(y, 2)); }
  float DistanceTo(const Vector2& Pos) noexcept {
    return sqrtf(powf(Pos.x - x, 2) + powf(Pos.y - y, 2));
  }
};
#endif
#ifndef VECTOR3_H
#define VECTOR3_H
class Vector3 {
 public:
  float x, y, z;

 public:
  Vector3() : x(0.f), y(0.f), z(0.f) {}
  Vector3(float x_, float y_, float z_) : x(x_), y(y_), z(z_) {}
  Vector3 operator+(Vector3 Vector3_) {
    return {x + Vector3_.x, y + Vector3_.y, z + Vector3_.z};
  }
  Vector3 operator-(Vector3 Vector3_) {
    return {x - Vector3_.x, y - Vector3_.y, z - Vector3_.z};
  }
  Vector3 operator*(Vector3 Vector3_) {
    return {x * Vector3_.x, y * Vector3_.y, z * Vector3_.z};
  }
  Vector3 operator/(Vector3 Vector3_) {
    return {x / Vector3_.x, y / Vector3_.y, z / Vector3_.z};
  }
  Vector3 operator*(float n) { return {x * n, y * n, z * n}; }
  Vector3 operator/(float n) { return {x / n, y / n, z / n}; }
  bool operator==(Vector3 Vector3_) {
    return x == Vector3_.x && y == Vector3_.y && z == Vector3_.z;
  }
  bool operator!=(Vector3 Vector3_) {
    return x != Vector3_.x || y != Vector3_.y || z != Vector3_.z;
  }
  float Length() noexcept {
    return sqrtf(powf(x, 2) + powf(y, 2) + powf(z, 2));
  }
  float DistanceTo(const Vector3& Pos) noexcept {
    return sqrtf(powf(Pos.x - x, 2) + powf(Pos.y - y, 2) + powf(Pos.z - z, 2));
  }
  void Normalize() noexcept {
    float len = Length();
    if (len != 0) {
      x /= len;
      y /= len;
      z /= len;
    }
  }
  Vector3 Normalized() const {
    Vector3 result = *this;
    result.Normalize();
    return result;
  }
};
#endif
std::string string_To_UTF8(const std::string& str) noexcept;
#ifndef OVERLAY_H
#define OVERLAY_H

void DrawStrokeText(
    float x, float y, RGBA* color, const char* str,
    ImDrawList* drawlist = ImGui::GetBackgroundDrawList()) noexcept;

void DrawNewText(
    float x, float y, RGBA* color, const char* str,
                 ImDrawList* drawlist = ImGui::GetBackgroundDrawList()) noexcept;

void DrawRect(float x, float y, float w, float h, RGBA* color, float thickness,
              ImDrawList* drawlist = ImGui::GetBackgroundDrawList()) noexcept;

void DrawEspBox2D(
    Vector2 feet, Vector2 head, RGBA* color, float thickness,
                  ImDrawList* drawlist = ImGui::GetBackgroundDrawList()) noexcept;

void DrawNameTag(Vector2 feet, Vector2 head, char* name,
                 ImDrawList* drawlist = ImGui::GetBackgroundDrawList()) noexcept;

void DrawFilledRect(
    float x, float y, float w, float h, RGBA* color,
                    ImDrawList* drawlist = ImGui::GetBackgroundDrawList()) noexcept;

void DrawCircleFilled(
    float x, float y, float radius, RGBA* color,
                      ImDrawList* drawlist = ImGui::GetBackgroundDrawList()) noexcept;

void DrawCircle(float x, float y, float radius, RGBA* color, float segments,
                ImDrawList* drawlist = ImGui::GetBackgroundDrawList()) noexcept;

void DrawTriangle(
    float x1, float y1, float x2, float y2, float x3, float y3, RGBA* color,
                  float thickne, ImDrawList* drawlist = ImGui::GetBackgroundDrawList()) noexcept;

void DrawTriangleFilled(
    float x1, float y1, float x2, float y2, float x3, float y3,
                        RGBA* color,
                        ImDrawList* drawlist = ImGui::GetBackgroundDrawList()) noexcept;

void DrawLine(float x1, float y1, float x2, float y2, RGBA* color,
              float thickness,
              ImDrawList* drawlist = ImGui::GetBackgroundDrawList()) noexcept;

void DrawCornerBox(
    float x, float y, float w, float h, float borderPx, RGBA* color,
                   ImDrawList* drawlist = ImGui::GetBackgroundDrawList()) noexcept;

void DrawHealthBar(Vector2 feet, Vector2 head, 
                   int curHealth, int maxHealth = 100,
                   RGBA* barColor = &Green,
                   RGBA* backColor = &Transparent,
                   ImDrawList* drawlist = ImGui::GetBackgroundDrawList()) noexcept;
#endif
bool LoadTextureFromMemory(IDirect3DDevice9* device,
                           const unsigned char* image_data, size_t image_size,
                           IDirect3DTexture9** out_texture) noexcept;

bool GetBindState(KeyBind_t& keyBind);
namespace ImGui {
/* @section: main */
bool HotKey(const char* szLabel, int* pKey);
bool HotKey(const char* szLabel, KeyBind_t* pKeyBind,
            const bool bAllowSwitch = true);
}  // namespace ImGui


================================================
FILE: pch.cc
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: pch.cc
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This is where the precompiled header file for the Samidare project is
//   created.
//
// -----------------------------------------------------------------------------
#include "pch.h"


================================================
FILE: pch.h
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: pch.h
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This is the precompiled header file for the Samidare project.
//   Only include headers here that won't change frequently.
//
// -----------------------------------------------------------------------------
#pragma once
#ifndef PCH_H_
#define PCH_H_
#include "./framework.h"

#include "./Utils/nlohmann/json.hpp"
#include "./Utils/yaml-cpp/yaml.h"
#include "./Utils/miniz.h"
#include "./Utils/uiaccess.h"
#include "./Utils/mouse_input_injection.h"
#endif  // PCH_H_


================================================
FILE: resource.h
================================================
//{{NO_DEPENDENCIES}}
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



================================================
FILE: Samidare.rc
================================================
[Binary file]


================================================
FILE: Samidare.sln
================================================
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.11.35312.102
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Samidare", "Samidare.vcxproj", "{85EBA95A-A588-4A7D-ACE0-F1A6F97B8E6C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Ring0|x64 = Ring0|x64
		Ring3 FIFO|x64 = Ring3 FIFO|x64
		Ring3|x64 = Ring3|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{85EBA95A-A588-4A7D-ACE0-F1A6F97B8E6C}.Debug|x64.ActiveCfg = Debug|x64
		{85EBA95A-A588-4A7D-ACE0-F1A6F97B8E6C}.Debug|x64.Build.0 = Debug|x64
		{85EBA95A-A588-4A7D-ACE0-F1A6F97B8E6C}.Ring0|x64.ActiveCfg = Ring0|x64
		{85EBA95A-A588-4A7D-ACE0-F1A6F97B8E6C}.Ring0|x64.Build.0 = Ring0|x64
		{85EBA95A-A588-4A7D-ACE0-F1A6F97B8E6C}.Ring3 FIFO|x64.ActiveCfg = Ring3 FIFO|x64
		{85EBA95A-A588-4A7D-ACE0-F1A6F97B8E6C}.Ring3 FIFO|x64.Build.0 = Ring3 FIFO|x64
		{85EBA95A-A588-4A7D-ACE0-F1A6F97B8E6C}.Ring3|x64.ActiveCfg = Ring3|x64
		{85EBA95A-A588-4A7D-ACE0-F1A6F97B8E6C}.Ring3|x64.Build.0 = Ring3|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {50D3DB92-71B4-4B6A-A9D1-7DC280AF66DA}
	EndGlobalSection
EndGlobal



================================================
FILE: Samidare.vcxproj
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Ring0|x64">
      <Configuration>Ring0</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Ring3 FIFO|x64">
      <Configuration>Ring3 FIFO</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Ring3|x64">
      <Configuration>Ring3</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{85eba95a-a588-4a7d-ace0-f1a6f97b8e6c}</ProjectGuid>
    <RootNamespace>Samidare</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Samidare</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x64</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Ring3|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>ClangCL</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x64</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Ring0|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>ClangCL</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x64</PreferredToolArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Ring3 FIFO|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>ClangCL</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PreferredToolArchitecture>x64</PreferredToolArchitecture>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Ring3|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Ring0|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Ring3 FIFO|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>$(SolutionDir);$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)Utils/yaml-cpp/lib;$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64)</LibraryPath>
    <TargetName>$(ProjectName)-$(Configuration)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Ring0|x64'">
    <IncludePath>$(SolutionDir);$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)Utils/yaml-cpp/lib;$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64)</LibraryPath>
    <TargetName>$(ProjectName)-$(Configuration)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Ring3 FIFO|x64'">
    <IncludePath>$(SolutionDir);$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)Utils/yaml-cpp/lib;$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64)</LibraryPath>
    <TargetName>$(ProjectName)-$(Configuration)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Ring3|x64'">
    <IncludePath>$(SolutionDir);$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)Utils/yaml-cpp/lib;$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64)</LibraryPath>
    <TargetName>$(ProjectName)-$(Configuration)</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NOMINMAX;YAML_CPP_STATIC_DEFINE;USERMODE;_CRT_SECURE_NO_WARNINGS;__DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <FloatingPointModel>Precise</FloatingPointModel>
      <AdditionalOptions>/utf-8  /FI"pch.h"
</AdditionalOptions>
      <IntelJCCErratum>true</IntelJCCErratum>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <LanguageStandard_C>stdc11</LanguageStandard_C>
      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
      <OpenMPSupport>false</OpenMPSupport>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>true</TreatWarningAsError>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <CompileAs>CompileAsCpp</CompileAs>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
      <AdditionalDependencies>d3d9.lib;dwmapi.lib;iphlpapi.lib;winmm.lib;yaml-cppd.lib;$(CoreLibraryDependencies);%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateMapFile>true</GenerateMapFile>
      <LargeAddressAware>true</LargeAddressAware>
    </Link>
    <Manifest>
      <EnableDpiAwareness>true</EnableDpiAwareness>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Ring3|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NOMINMAX;YAML_CPP_STATIC_DEFINE;USERMODE;_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <StringPooling>true</StringPooling>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel>Precise</FloatingPointModel>
      <AdditionalOptions>/utf-8  /FI"pch.h" -mbranches-within-32B-boundaries -Wno-microsoft-cast
</AdditionalOptions>
      <IntelJCCErratum>true</IntelJCCErratum>
      <LanguageStandard_C>stdc11</LanguageStandard_C>
      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
      <OpenMPSupport>true</OpenMPSupport>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>true</TreatWarningAsError>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <CompileAs>CompileAsCpp</CompileAs>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>HighestAvailable</UACExecutionLevel>
      <AdditionalDependencies>d3d9.lib;dwmapi.lib;iphlpapi.lib;winmm.lib;yaml-cpp.lib;$(CoreLibraryDependencies);%(AdditionalDependencies)</AdditionalDependencies>
      <LargeAddressAware>true</LargeAddressAware>
    </Link>
    <Manifest>
      <EnableDpiAwareness>true</EnableDpiAwareness>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Ring0|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NOMINMAX;YAML_CPP_STATIC_DEFINE;_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <StringPooling>true</StringPooling>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel>Precise</FloatingPointModel>
      <AdditionalOptions>/utf-8  /FI"pch.h" -mbranches-within-32B-boundaries -Wno-microsoft-cast</AdditionalOptions>
      <IntelJCCErratum>true</IntelJCCErratum>
      <LanguageStandard_C>stdc11</LanguageStandard_C>
      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
      <OpenMPSupport>true</OpenMPSupport>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>true</TreatWarningAsError>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <CompileAs>CompileAsCpp</CompileAs>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>HighestAvailable</UACExecutionLevel>
      <AdditionalDependencies>d3d9.lib;dwmapi.lib;iphlpapi.lib;winmm.lib;yaml-cpp.lib;$(CoreLibraryDependencies);%(AdditionalDependencies)</AdditionalDependencies>
      <LargeAddressAware>true</LargeAddressAware>
    </Link>
    <Manifest>
      <EnableDpiAwareness>true</EnableDpiAwareness>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Ring3 FIFO|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NOMINMAX;YAML_CPP_STATIC_DEFINE;FIFO_MODE;_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <StringPooling>true</StringPooling>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel>Precise</FloatingPointModel>
      <AdditionalOptions>/utf-8  /FI"pch.h" -mbranches-within-32B-boundaries -Wno-microsoft-cast
</AdditionalOptions>
      <IntelJCCErratum>true</IntelJCCErratum>
      <LanguageStandard_C>stdc11</LanguageStandard_C>
      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
      <OpenMPSupport>true</OpenMPSupport>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>true</TreatWarningAsError>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <CompileAs>CompileAsCpp</CompileAs>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>HighestAvailable</UACExecutionLevel>
      <AdditionalDependencies>d3d9.lib;dwmapi.lib;iphlpapi.lib;winmm.lib;yaml-cpp.lib;$(CoreLibraryDependencies);%(AdditionalDependencies)</AdditionalDependencies>
      <LargeAddressAware>true</LargeAddressAware>
    </Link>
    <Manifest>
      <EnableDpiAwareness>true</EnableDpiAwareness>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="CS2x64.cc" />
    <ClCompile Include="Functions\Aimbot\Aimbot.cc" />
    <ClCompile Include="Functions\Aimbot\RCS.cc" />
    <ClCompile Include="Functions\Aimbot\TriggerBot.cc" />
    <ClCompile Include="Functions\ConfigSaver.cc" />
    <ClCompile Include="Functions\Func.cc" />
    <ClCompile Include="Functions\Miscs\BombTimer.cc" />
    <ClCompile Include="Functions\Miscs\Miscs.cc" />
    <ClCompile Include="Functions\Miscs\SpecList.cc" />
    <ClCompile Include="Functions\Visuals\ESP.cc" />
    <ClCompile Include="Functions\Visuals\Radar.cc" />
    <ClCompile Include="Game.cc" />
    <ClCompile Include="ImGui\imgui.cpp" />
    <ClCompile Include="ImGui\imgui_demo.cpp" />
    <ClCompile Include="ImGui\imgui_draw.cpp" />
    <ClCompile Include="ImGui\imgui_impl_dx9.cpp" />
    <ClCompile Include="ImGui\imgui_impl_win32.cpp" />
    <ClCompile Include="ImGui\imgui_tables.cpp" />
    <ClCompile Include="ImGui\imgui_widgets.cpp" />
    <ClCompile Include="Offsets.cc" />
    <ClCompile Include="Overlay.cc" />
    <ClCompile Include="pch.cc">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Ring3|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Ring3 FIFO|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Ring0|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="UkiaStuff.cc" />
    <ClCompile Include="Utils\miniz.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Ring3|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Ring3 FIFO|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Ring0|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="Utils\uiaccess.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Ring3|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Ring3 FIFO|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Ring0|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="entry_point.cc" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CS2x64.h" />
    <ClInclude Include="Driver.h" />
    <ClInclude Include="FIFO.h" />
    <ClInclude Include="framework.h" />
    <ClInclude Include="Functions\Aimbot\Aimbot.h" />
    <ClInclude Include="Functions\Aimbot\RCS.h" />
    <ClInclude Include="Functions\Aimbot\TriggerBot.h" />
    <ClInclude Include="Functions\config.h" />
    <ClInclude Include="Functions\ConfigSaver.h" />
    <ClInclude Include="Functions\Func.h" />
    <ClInclude Include="Functions\menu.h" />
    <ClInclude Include="Functions\Miscs\BombTimer.h" />
    <ClInclude Include="Functions\Miscs\Miscs.h" />
    <ClInclude Include="Functions\Miscs\SpecList.h" />
    <ClInclude Include="Functions\Visuals\ESP.h" />
    <ClInclude Include="Functions\Visuals\Radar.h" />
    <ClInclude Include="Game.h" />
    <ClInclude Include="global.h" />
    <ClInclude Include="HarmonyOS_SansSC_Regular.h" />
    <ClInclude Include="ImGui\imconfig.h" />
    <ClInclude Include="ImGui\imgui.h" />
    <ClInclude Include="ImGui\imgui_impl_dx9.h" />
    <ClInclude Include="ImGui\imgui_impl_win32.h" />
    <ClInclude Include="ImGui\imgui_internal.h" />
    <ClInclude Include="ImGui\imstb_rectpack.h" />
    <ClInclude Include="ImGui\imstb_textedit.h" />
    <ClInclude Include="ImGui\imstb_truetype.h" />
    <ClInclude Include="Lang.h" />
    <ClInclude Include="maths.h" />
    <ClInclude Include="Offsets.h" />
    <ClInclude Include="Overlay.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="shigure.h" />
    <ClInclude Include="UkiaStuff.h" />
    <ClInclude Include="Utils\CallStack-Spoofer.h" />
    <ClInclude Include="Utils\miniz.h" />
    <ClInclude Include="Utils\mouse_input_injection.h" />
    <ClInclude Include="Utils\nlohmann\json.hpp" />
    <ClInclude Include="Utils\nlohmann\json_fwd.hpp" />
    <ClInclude Include="Utils\stb_image.h" />
    <ClInclude Include="Utils\uiaccess.h" />
    <ClInclude Include="Utils\vphys_parser\ray_trace.h" />
    <ClInclude Include="Utils\vphys_parser\vector.h" />
    <ClInclude Include="Utils\XorStr.h" />
    <ClInclude Include="Utils\yaml-cpp\anchor.h" />
    <ClInclude Include="Utils\yaml-cpp\binary.h" />
    <ClInclude Include="Utils\yaml-cpp\depthguard.h" />
    <ClInclude Include="Utils\yaml-cpp\dll.h" />
    <ClInclude Include="Utils\yaml-cpp\emitfromevents.h" />
    <ClInclude Include="Utils\yaml-cpp\emitter.h" />
    <ClInclude Include="Utils\yaml-cpp\emitterdef.h" />
    <ClInclude Include="Utils\yaml-cpp\emittermanip.h" />
    <ClInclude Include="Utils\yaml-cpp\emitterstyle.h" />
    <ClInclude Include="Utils\yaml-cpp\eventhandler.h" />
    <ClInclude Include="Utils\yaml-cpp\exceptions.h" />
    <ClInclude Include="Utils\yaml-cpp\mark.h" />
    <ClInclude Include="Utils\yaml-cpp\noexcept.h" />
    <ClInclude Include="Utils\yaml-cpp\null.h" />
    <ClInclude Include="Utils\yaml-cpp\ostream_wrapper.h" />
    <ClInclude Include="Utils\yaml-cpp\parser.h" />
    <ClInclude Include="Utils\yaml-cpp\stlemitter.h" />
    <ClInclude Include="Utils\yaml-cpp\traits.h" />
    <ClInclude Include="Utils\yaml-cpp\yaml.h" />
    <ClInclude Include="zekamashi.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Samidare.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="Samidare.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
FILE: Samidare.vcxproj.filters
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Headers">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Headers\Utils">
      <UniqueIdentifier>{464098fd-779b-4b7c-8c4d-ea56431e14fb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headers\Utils\yaml-cpp">
      <UniqueIdentifier>{23cb46c3-1829-4a0f-bfd1-3298f506fbf5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headers\Utils\nlohmann">
      <UniqueIdentifier>{98dc854c-30d4-40e7-8d80-560dd5721221}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headers\Utils\vphys_parser">
      <UniqueIdentifier>{1ab215d3-d789-4a4b-a4ac-f19af889dcbc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headers\Functions">
      <UniqueIdentifier>{0d84691b-ad53-4e8b-89be-15337bbe38be}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headers\Functions\Miscs">
      <UniqueIdentifier>{ba6a50c4-dd82-4da8-abee-195efc4759db}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headers\Functions\Visuals">
      <UniqueIdentifier>{110944b5-c3bc-494a-84fb-aa79b1dadfbe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headers\Functions\Aimbot">
      <UniqueIdentifier>{0076d590-d7a5-4fb4-8e72-df8308bfd5f4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headers\ImGui">
      <UniqueIdentifier>{908b7e56-a5e1-4807-a376-1bade3d6f142}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resources">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Sources">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry_point.cc">
      <Filter>Sources</Filter>
    </ClCompile>
    <ClCompile Include="ImGui\imgui.cpp">
      <Filter>Headers\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="ImGui\imgui_demo.cpp">
      <Filter>Headers\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="ImGui\imgui_draw.cpp">
      <Filter>Headers\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="ImGui\imgui_impl_dx9.cpp">
      <Filter>Headers\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="ImGui\imgui_impl_win32.cpp">
      <Filter>Headers\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="ImGui\imgui_tables.cpp">
      <Filter>Headers\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="ImGui\imgui_widgets.cpp">
      <Filter>Headers\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="Utils\uiaccess.c">
      <Filter>Headers\Utils</Filter>
    </ClCompile>
    <ClCompile Include="Functions\ConfigSaver.cc">
      <Filter>Headers\Functions</Filter>
    </ClCompile>
    <ClCompile Include="Functions\Func.cc">
      <Filter>Headers\Functions</Filter>
    </ClCompile>
    <ClCompile Include="Functions\Aimbot\RCS.cc">
      <Filter>Headers\Functions\Aimbot</Filter>
    </ClCompile>
    <ClCompile Include="Functions\Miscs\Miscs.cc">
      <Filter>Headers\Functions\Miscs</Filter>
    </ClCompile>
    <ClCompile Include="Functions\Visuals\ESP.cc">
      <Filter>Headers\Functions\Visuals</Filter>
    </ClCompile>
    <ClCompile Include="Functions\Visuals\Radar.cc">
      <Filter>Headers\Functions\Visuals</Filter>
    </ClCompile>
    <ClCompile Include="Functions\Aimbot\TriggerBot.cc">
      <Filter>Headers\Functions\Aimbot</Filter>
    </ClCompile>
    <ClCompile Include="Functions\Miscs\BombTimer.cc">
      <Filter>Headers\Functions\Miscs</Filter>
    </ClCompile>
    <ClCompile Include="Utils\miniz.c">
      <Filter>Headers\Utils</Filter>
    </ClCompile>
    <ClCompile Include="Functions\Aimbot\Aimbot.cc">
      <Filter>Headers\Functions\Aimbot</Filter>
    </ClCompile>
    <ClCompile Include="Functions\Miscs\SpecList.cc">
      <Filter>Headers\Functions\Miscs</Filter>
    </ClCompile>
    <ClCompile Include="UkiaStuff.cc">
      <Filter>Sources</Filter>
    </ClCompile>
    <ClCompile Include="Overlay.cc">
      <Filter>Sources</Filter>
    </ClCompile>
    <ClCompile Include="Offsets.cc">
      <Filter>Sources</Filter>
    </ClCompile>
    <ClCompile Include="Game.cc">
      <Filter>Sources</Filter>
    </ClCompile>
    <ClCompile Include="CS2x64.cc">
      <Filter>Sources</Filter>
    </ClCompile>
    <ClCompile Include="pch.cc">
      <Filter>Sources</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="UkiaStuff.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Utils\XorStr.h">
      <Filter>Headers\Utils</Filter>
    </ClInclude>
    <ClInclude Include="CS2x64.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imconfig.h">
      <Filter>Headers\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imgui.h">
      <Filter>Headers\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imgui_impl_dx9.h">
      <Filter>Headers\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imgui_impl_win32.h">
      <Filter>Headers\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imgui_internal.h">
      <Filter>Headers\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imstb_rectpack.h">
      <Filter>Headers\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imstb_textedit.h">
      <Filter>Headers\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="ImGui\imstb_truetype.h">
      <Filter>Headers\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="Overlay.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Utils\uiaccess.h">
      <Filter>Headers\Utils</Filter>
    </ClInclude>
    <ClInclude Include="shigure.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Utils\stb_image.h">
      <Filter>Headers\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Functions\Func.h">
      <Filter>Headers\Functions</Filter>
    </ClInclude>
    <ClInclude Include="Functions\Visuals\ESP.h">
      <Filter>Headers\Functions\Visuals</Filter>
    </ClInclude>
    <ClInclude Include="Functions\config.h">
      <Filter>Headers\Functions</Filter>
    </ClInclude>
    <ClInclude Include="Functions\Miscs\Miscs.h">
      <Filter>Headers\Functions\Miscs</Filter>
    </ClInclude>
    <ClInclude Include="Functions\menu.h">
      <Filter>Headers\Functions</Filter>
    </ClInclude>
    <ClInclude Include="Functions\ConfigSaver.h">
      <Filter>Headers\Functions</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\anchor.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\binary.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\depthguard.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\dll.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\emitfromevents.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\emitter.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\emitterdef.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\emittermanip.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\emitterstyle.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\eventhandler.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\exceptions.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\mark.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\noexcept.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\null.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\ostream_wrapper.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\parser.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\stlemitter.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\traits.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Utils\yaml-cpp\yaml.h">
      <Filter>Headers\Utils\yaml-cpp</Filter>
    </ClInclude>
    <ClInclude Include="Functions\Aimbot\RCS.h">
      <Filter>Headers\Functions\Aimbot</Filter>
    </ClInclude>
    <ClInclude Include="Functions\Visuals\Radar.h">
      <Filter>Headers\Functions\Visuals</Filter>
    </ClInclude>
    <ClInclude Include="maths.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Game.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="global.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Lang.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Utils\nlohmann\json.hpp">
      <Filter>Headers\Utils\nlohmann</Filter>
    </ClInclude>
    <ClInclude Include="Utils\nlohmann\json_fwd.hpp">
      <Filter>Headers\Utils\nlohmann</Filter>
    </ClInclude>
    <ClInclude Include="Functions\Aimbot\TriggerBot.h">
      <Filter>Headers\Functions\Aimbot</Filter>
    </ClInclude>
    <ClInclude Include="Functions\Miscs\BombTimer.h">
      <Filter>Headers\Functions\Miscs</Filter>
    </ClInclude>
    <ClInclude Include="Utils\miniz.h">
      <Filter>Headers\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\vphys_parser\ray_trace.h">
      <Filter>Headers\Utils\vphys_parser</Filter>
    </ClInclude>
    <ClInclude Include="Utils\vphys_parser\vector.h">
      <Filter>Headers\Utils\vphys_parser</Filter>
    </ClInclude>
    <ClInclude Include="Functions\Aimbot\Aimbot.h">
      <Filter>Headers\Functions\Aimbot</Filter>
    </ClInclude>
    <ClInclude Include="zekamashi.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Driver.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Utils\mouse_input_injection.h">
      <Filter>Headers\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\CallStack-Spoofer.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="FIFO.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Functions\Miscs\SpecList.h">
      <Filter>Headers\Functions\Miscs</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Resources</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="framework.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="HarmonyOS_SansSC_Regular.h">
      <Filter>Headers</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Samidare.rc">
      <Filter>Resources</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="Samidare.ico">
      <Filter>Resources</Filter>
    </Image>
  </ItemGroup>
</Project>


================================================
FILE: UkiaStuff.cc
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: UkiaStuff.cc
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file mainly includes some practical functions packaging 
//   and reuse that simplify code usage.
//
// -----------------------------------------------------------------------------
#include "pch.h"
#include "./UkiaStuff.h"
#include "./Utils/XorStr.h"
#ifndef USERMODE
#ifndef FIFO_MODE
#include "./Driver.h"
#else
#include "./FIFO.h"
#endif
#endif  // USERMODE

#define WIN32_LEAN_AND_MEAN

constexpr uint32_t CompileTimeSeed() noexcept {
  const char* time_str = __TIME__ __DATE__;
  uint32_t hash = 0;
  for (int i = 0; time_str[i] != '\0'; ++i) {
    hash = hash * 65599 + time_str[i];
  }
  return hash;
}

namespace Ukia {
void HideConsole() noexcept {
  HWND hwndConsole = GetConsoleWindow();
  if (hwndConsole) {
    ShowWindow(hwndConsole, SW_SHOWMINNOACTIVE);  // 隐藏控制台
  }
}

void ShowConsole() noexcept {
  HWND hwndConsole = GetConsoleWindow();
  if (hwndConsole) {
    ShowWindow(hwndConsole, SW_SHOWNOACTIVATE);  // 显示控制台
  }
}
void AntiDebugger(std::string log) noexcept {
  if (IsDebuggerPresent()) {
    if (log != "")
      printf("%s",(log + "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
                    "\n\n\n\n\n\n\n\n\n\n\n\n")
                 .c_str());
    ShowWindow(GetConsoleWindow(), false);
    _exit(0);
  }
}

std::wstring utf8ToUtf16(const std::string& utf8Str) noexcept {
  int size_needed =
      MultiByteToWideChar(CP_UTF8, 0, utf8Str.c_str(), -1, nullptr, 0);
  if (size_needed == 0) {
    return std::wstring();
  }
  std::wstring wstr(size_needed, 0);
  MultiByteToWideChar(CP_UTF8, 0, utf8Str.c_str(), -1, &wstr[0], size_needed);
  return wstr;
}

std::string getRandomPoem() noexcept {
  static const std::vector<std::string> words = {
      "\xE9\xA3\x8E",  // 风
      "\xE8\x8A\xB1",  // 花
      "\xE9\x9B\xAA",  // 雪
      "\xE6\x9C\x88",  // 月
      "\xE7\x83\x9F",  // 烟
      "\xE6\x97\xB6",  // 时
      "\xE9\x9B\xA8",  // 雨
      "\xE6\xB8\x9F",  // 渟
      "\xE4\xBA\x91",  // 云
      "\xE6\xB1\x9F",  // 江
      "\xE6\xB9\x96",  // 湖
      "\xE6\x98\x9F",  // 星
      "\xE6\x9C\x88",  // 月
      "\xE6\x99\xAF",  // 景
      "\xE7\x94\x9F",  // 生
      "\xE6\xA2\x85",  // 梅
      "\xE6\x9F\xB3",  // 柳
      "\xE8\x93\x89",  // 莲
      "\xE5\xAE\x87",  // 宇
      "\xE5\xAE\x99",  // 宙
      "\xE6\x98\xA5",  // 春
      "\xE5\xA4\x8F",  // 夏
      "\xE7\xA7\x8B",  // 秋
      "\xE5\x86\xAC",  // 冬
      "\xE5\xB1\xB1",  // 山
      "\xE6\xB0\xB4"   // 水
  };

  static std::mt19937 rng(static_cast<unsigned>(
      std::chrono::system_clock::now().time_since_epoch().count()));

  std::vector<std::string> shuffled = words;
  std::shuffle(shuffled.begin(), shuffled.end(), rng);

  std::string poem;
  for (int i = 0; i < 10; ++i) {
    poem += shuffled[i];
    if ((i + 1) % 5 == 0 && i != 10 - 1) {
      poem += "\xEF\xBC\x8C";
    }
  }
  poem += "\xE3\x80\x82";
  return poem;
}

LPCWSTR getRandomPoemW() noexcept {
  std::string utf8Poem = getRandomPoem();
  std::wstring wstr = utf8ToUtf16(utf8Poem);
  static std::wstring staticWstr;
  staticWstr = wstr;
  return staticWstr.c_str();
}

std::string GetSelfPath() noexcept {
  char pathBuffer[MAX_PATH] = {0};

  if (GetModuleFileNameA(NULL, pathBuffer, sizeof(pathBuffer)) == 0) {
    perror("GetModuleFileNameA failed");
    return "";
  }
  return std::string(pathBuffer);
}

bool HasHashReadyParameter(int argc, char* argv[]) noexcept {
  for (int i = 1; i < argc; ++i) {
    if (strcmp(argv[i], "--hash-ready") == 0) return true;
  }
  return false;
}

void PreUpdateHash(const std::string& exePath, char* argv[]) noexcept {
  size_t pos = exePath.find_last_of("\\/");
  std::string folder =
      (pos != std::string::npos) ? exePath.substr(0, pos + 1) : "";
  std::string exeName =
      (pos != std::string::npos) ? exePath.substr(pos + 1) : exePath;
  srand(static_cast<unsigned int>(time(nullptr)));
  long long randomNum = (static_cast<long long>(rand() * 2654435761u));
  std::ostringstream oss;
  oss << folder << "ukiaUpd_" << std::hex << randomNum << ".bat";
  std::string batPath = oss.str();

  std::ofstream batFile(batPath);
  if (!batFile) {
    fprintf(stderr, "failed create shell: %s\n", batPath.c_str());
    return;
  }

  batFile << "@echo off\n";
  batFile
      << "powershell -NoProfile -Command \""
      << "$exePath = '%~dp0" << exeName << "'; "
      << "$fs = [System.IO.File]::Open($exePath, [System.IO.FileMode]::Open, "
         "[System.IO.FileAccess]::ReadWrite); "
      << "try { "
      << "  $fs.Seek(0, [System.IO.SeekOrigin]::End) | Out-Null; "
      << "  $length = $fs.Length; "
      << "  $bufferSize = [Math]::Min(1024, $length); "
      << "  $fs.Seek(-$bufferSize, [System.IO.SeekOrigin]::End) | Out-Null; "
      << "  $buffer = New-Object Byte[] $bufferSize; "
      << "  $fs.Read($buffer, 0, $bufferSize) | Out-Null; "
      << "  $text = [System.Text.Encoding]::ASCII.GetString($buffer); "
      << "  if($text -match '##TE_QUIERO_MUCHO##(.*?)##UKIA_LOVES_YOU##') { "
      << "      $newHash = " << randomNum << " ; "
      << "      $newBlock = '##TE_QUIERO_MUCHO##' + $newHash + "
         "'##UKIA_LOVES_YOU##'; "
      << "      $match = [System.Text.RegularExpressions.Regex]::Match($text, "
         "'##TE_QUIERO_MUCHO##.*?##UKIA_LOVES_YOU##'); "
      << "      if($match.Success) { "
      << "          $matchIndex = $match.Index; "
      << "          $absoluteIndex = $length - $bufferSize + $matchIndex; "
      << "          $fs.SetLength($absoluteIndex); "
      << "          $writer = New-Object System.IO.BinaryWriter($fs); "
      << "          "
         "$writer.Write([System.Text.Encoding]::ASCII.GetBytes($newBlock)); "
      << "          $writer.Flush(); "
      << "          $writer.Close(); "
      << "      } "
      << "  } else { "
      << "      $newHash = " << randomNum << " ; "
      << "      $newBlock = '##TE_QUIERO_MUCHO##' + $newHash + "
         "'##UKIA_LOVES_YOU##'; "
      << "      $writer = New-Object System.IO.BinaryWriter($fs); "
      << "      "
         "$writer.Write([System.Text.Encoding]::ASCII.GetBytes($newBlock)); "
      << "      $writer.Flush(); "
      << "      $writer.Close(); "
      << "  } "
      << "} finally { $fs.Close(); }\" \n";
  batFile << "start \"\" \"%~dp0" << exeName << "\" --hash-ready " << argv
          << "\n ";
  batFile << "del \"%~f0\"\n";
  batFile.close();

  ShellExecuteA(NULL, "open", batPath.c_str(), NULL,
                folder.empty() ? NULL : folder.c_str(), SW_HIDE);
}
void PostUpdateHash(const std::string& exePath) noexcept {
  size_t pos = exePath.find_last_of("\\/");
  std::string folder =
      (pos != std::string::npos) ? exePath.substr(0, pos + 1) : "";
  std::string exeName =
      (pos != std::string::npos) ? exePath.substr(pos + 1) : exePath;
  srand(static_cast<unsigned int>(time(nullptr)));
  long long randomNum = (static_cast<long long>(rand() * 2654435761u));
  std::ostringstream oss;
  oss << folder << "ukiaUpd_" << std::hex << randomNum << ".bat";
  std::string batPath = oss.str();

  std::ofstream batFile(batPath);
  if (!batFile) {
    fprintf(stderr, "failed create shell: %s\n", batPath.c_str());
    return;
  }

  batFile << "@echo off\n";
  batFile << "timeout /t 0.5 /nobreak >nul\n";
  batFile
      << "powershell -NoProfile -Command \""
      << "$exePath = '%~dp0" << exeName << "'; "
      << "$fs = [System.IO.File]::Open($exePath, [System.IO.FileMode]::Open, "
         "[System.IO.FileAccess]::ReadWrite); "
      << "try { "
      << "  $fs.Seek(0, [System.IO.SeekOrigin]::End) | Out-Null; "
      << "  $length = $fs.Length; "
      << "  $bufferSize = [Math]::Min(1024, $length); "
      << "  $fs.Seek(-$bufferSize, [System.IO.SeekOrigin]::End) | Out-Null; "
      << "  $buffer = New-Object Byte[] $bufferSize; "
      << "  $fs.Read($buffer, 0, $bufferSize) | Out-Null; "
      << "  $text = [System.Text.Encoding]::ASCII.GetString($buffer); "
      << "  if($text -match '##TE_QUIERO_MUCHO##(.*?)##UKIA_LOVES_YOU##') { "
      << "      $newHash = " << randomNum << " ; "
      << "      $newBlock = '##TE_QUIERO_MUCHO##' + $newHash + "
         "'##UKIA_LOVES_YOU##'; "
      << "      $match = [System.Text.RegularExpressions.Regex]::Match($text, "
         "'##TE_QUIERO_MUCHO##.*?##UKIA_LOVES_YOU##'); "
      << "      if($match.Success) { "
      << "          $matchIndex = $match.Index; "
      << "          $absoluteIndex = $length - $bufferSize + $matchIndex; "
      << "          $fs.SetLength($absoluteIndex); "
      << "          $writer = New-Object System.IO.BinaryWriter($fs); "
      << "          "
         "$writer.Write([System.Text.Encoding]::ASCII.GetBytes($newBlock)); "
      << "          $writer.Flush(); "
      << "          $writer.Close(); "
      << "      } "
      << "  } else { "  // idk, but if he would deleted it manually? haha
      << "      $newHash = " << randomNum << " ; "
      << "      $newBlock = '##TE_QUIERO_MUCHO##' + $newHash + "
         "'##UKIA_LOVES_YOU##'; "
      << "      $writer = New-Object System.IO.BinaryWriter($fs); "
      << "      "
         "$writer.Write([System.Text.Encoding]::ASCII.GetBytes($newBlock)); "
      << "      $writer.Flush(); "
      << "      $writer.Close(); "
      << "  } "
      << "} finally { $fs.Close(); }\" \n";
  batFile << "del \"%~f0\"\n";
  batFile.close();

  ShellExecuteA(NULL, "open", batPath.c_str(), NULL,
                folder.empty() ? NULL : folder.c_str(), SW_HIDE);
}
void RandomTitle() noexcept {
  LPCWSTR title = getRandomPoemW();
  SetConsoleTitle(title);
}

bool IsFullscreen(HWND hwnd) noexcept {
  RECT windowRect, screenRect;
  GetWindowRect(hwnd, &windowRect);
  GetWindowRect(GetDesktopWindow(), &screenRect);
  return (windowRect.left <= screenRect.left &&
          windowRect.top <= screenRect.top &&
          windowRect.right >= screenRect.right &&
          windowRect.bottom >= screenRect.bottom);
}

std::string GenerateMacAddress() noexcept {
  IP_ADAPTER_INFO AdapterInfo[16];
  DWORD dwBufLen = sizeof(AdapterInfo);
  DWORD dwStatus = GetAdaptersInfo(AdapterInfo, &dwBufLen);

  if (dwStatus != ERROR_SUCCESS) {
    return "Error";
  }

  PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo;
  std::stringstream macAddress;

  do {
    macAddress << std::hex << std::uppercase << std::setw(2)
               << std::setfill('0')
               << static_cast<int>(pAdapterInfo->Address[0]) << std::setw(2)
               << std::setfill('0')
               << static_cast<int>(pAdapterInfo->Address[1]) << std::setw(2)
               << std::setfill('0')
               << static_cast<int>(pAdapterInfo->Address[2]) << std::setw(2)
               << std::setfill('0')
               << static_cast<int>(pAdapterInfo->Address[3]) << std::setw(2)
               << std::setfill('0')
               << static_cast<int>(pAdapterInfo->Address[4]) << std::setw(2)
               << std::setfill('0')
               << static_cast<int>(pAdapterInfo->Address[5]);

    pAdapterInfo = pAdapterInfo->Next;
  } while (pAdapterInfo);

  return macAddress.str();
}

std::string GenerateDiskSerial() noexcept {
  DWORD serialNum;
  GetVolumeInformationA("C:\\", NULL, 0, &serialNum, NULL, NULL, NULL, 0);

  std::stringstream ss;
  ss << serialNum;
  return ss.str();
}

static std::string GenerateHwId() noexcept {
  std::string strMac = GenerateMacAddress();
  std::string strDiskSerial = GenerateDiskSerial();
  return strMac + strDiskSerial;
}

// simple function i made that will just initialize our Object_Attributes
// structure as NtOpenProcess will fail otherwise
#ifdef USERMODE
OBJECT_ATTRIBUTES InitObjectAttributes(PUNICODE_STRING name, ULONG attributes,
                                       HANDLE hRoot,
                                       PSECURITY_DESCRIPTOR security) noexcept {
  OBJECT_ATTRIBUTES object;

  object.Length = sizeof(OBJECT_ATTRIBUTES);
  object.ObjectName = name;
  object.Attributes = attributes;
  object.RootDirectory = hRoot;
  object.SecurityDescriptor = security;

  return object;
}


HANDLE UkiaOpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle,
                       DWORD dwProcessId) noexcept {
  // At last is same with "OpenProcess", but we call "NtOpenProcess" (Native
  // API) directly.
  HANDLE hProcess = 0;
  _NtOpenProcess NtOpenProcess = (_NtOpenProcess)GetProcAddress(
      GetModuleHandleA(XorStr("ntdll.dll")), XorStr("NtOpenProcess"));
  CLIENT_ID clientId = {(PVOID)(ULONG_PTR)dwProcessId, NULL};
  OBJECT_ATTRIBUTES objAttr = InitObjectAttributes(NULL, 0, NULL, NULL);
  SPOOF_FUNC;
  SPOOF_CALL(NtOpenProcess)(&hProcess, dwDesiredAccess, &objAttr, &clientId);
  return hProcess;
}

inline static pNtReadVirtualMemory NtReadVirtualMemory = []() {
  return reinterpret_cast<pNtReadVirtualMemory>(GetProcAddress(
      GetModuleHandleA(XorStr("ntdll.dll")), XorStr("NtReadVirtualMemory")));
}();
inline static pNtWriteVirtualMemory NtWriteVirtualMemory = []() {
  return reinterpret_cast<pNtWriteVirtualMemory>(GetProcAddress(
      GetModuleHandleA(XorStr("ntdll.dll")), XorStr("NtWriteVirtualMemory")));
}();
using RtlNtStatusToDosErrorFn = ULONG(WINAPI*)(NTSTATUS);
inline static auto RtlNtStatusToDosError = reinterpret_cast<RtlNtStatusToDosErrorFn>(
    GetProcAddress(GetModuleHandleA(XorStr("ntdll.dll")),
                   XorStr("RtlNtStatusToDosError")));
#endif
BOOL UkiaReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress,
                           LPVOID lpBuffer, SIZE_T nSize,
                           SIZE_T* lpNumberOfBytesRead) noexcept {
#ifndef USERMODE
#ifndef FIFO_MODE
  driver.readsize((uintptr_t)lpBaseAddress, lpBuffer, nSize);
  return TRUE;
#else
  fifo.readSize((uintptr_t)lpBaseAddress, lpBuffer, nSize);
  return TRUE;
#endif
#else
  if (!NtReadVirtualMemory) {
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
  }

  ULONG ulSize = static_cast<ULONG>(nSize);
  ULONG bytesRead = 0;
  SPOOF_FUNC;
  NTSTATUS status = SPOOF_CALL(NtReadVirtualMemory)(
      hProcess, const_cast<PVOID>(lpBaseAddress), lpBuffer,
                          ulSize, lpNumberOfBytesRead ? &bytesRead : nullptr);

  if (lpNumberOfBytesRead) {
    *lpNumberOfBytesRead = static_cast<SIZE_T>(bytesRead);
  }

  if (status == SUCCEED) {
    return TRUE;
  }

  if (status == 0x8000000D) {
    SetLastError(ERROR_PARTIAL_COPY);
    return FALSE;
  }

  if (RtlNtStatusToDosError) {
    SetLastError(RtlNtStatusToDosError(status));
  } else {
    SetLastError(ERROR_UNIDENTIFIED_ERROR);
  }

  return FALSE;
  #endif
}

BOOL UkiaWriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress,
                            LPCVOID lpBuffer, SIZE_T nSize,
                            SIZE_T* lpNumberOfBytesWritten) noexcept {
#ifndef USERMODE
#ifndef FIFO_MODE
  driver.write((uintptr_t)lpBaseAddress, lpBuffer, nSize);
  return TRUE;
  #else
   fifo.write((uintptr_t)lpBaseAddress, lpBuffer, nSize);
  return TRUE;
#endif
    #else
  if (!NtWriteVirtualMemory) {
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
  }

  ULONG ulSize = static_cast<ULONG>(nSize);
  ULONG bytesWritten = 0;
  SPOOF_FUNC;
  NTSTATUS status = SPOOF_CALL(NtWriteVirtualMemory)(
      hProcess, lpBaseAddress, const_cast<PVOID>(lpBuffer), ulSize,
      lpNumberOfBytesWritten ? &bytesWritten : nullptr);

  if (lpNumberOfBytesWritten) {
    *lpNumberOfBytesWritten = static_cast<SIZE_T>(bytesWritten);
  }

  if (status == SUCCEED) {
    return TRUE;
  }

  if (status == 0xC0000005)  // STATUS_ACCESS_VIOLATION
    SetLastError(ERROR_NOACCESS);
  if (status == 0xC0000022)  // STATUS_ACCESS_DENIED
    SetLastError(ERROR_ACCESS_DENIED);
  if (status == 0x8000000D)
    SetLastError(ERROR_WRITE_FAULT);
  else {
    if (RtlNtStatusToDosError) {
      SetLastError(RtlNtStatusToDosError(status));
    } else {
      SetLastError(ERROR_UNIDENTIFIED_ERROR);
    }
  }

  return FALSE;
  #endif
}

BOOL WINAPI ConsoleCtrlHandler(DWORD dwCtrlType) noexcept {
  switch (dwCtrlType) {
    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
#ifdef NDEBUG
      Ukia::AntiDebugger(XorStr("Initialize fail"));
      if (true) {
        ProcessMgr.Detach();
        std::string selfPath = Ukia::GetSelfPath();
        if (selfPath.empty()) {
          return EXIT_FAILURE;
        }
        Ukia::PostUpdateHash(selfPath);
        _exit(0);
        return 0;
      }
#endif
      Sleep(2000);
      return FALSE;
    default:
      break;
  }
  return FALSE;
}
StatusCode ProcessManager::Attach(std::string ProcessName) noexcept {

  ProcessID = this->GetProcessID(ProcessName);
  IS_INVALID_R(ProcessID, FAILE_PROCESSID);
#ifndef USERMODE
#ifndef FIFO_MODE
  driver.initdriver(ProcessID);
  ModuleAddress = (uintptr_t) driver.dll_address("client.dll");
  IS_INVALID_R(ModuleAddress, FAILE_MODULE);
  attached_ = true;

  return SUCCEED;
  #else
  fifo.initPipe(ProcessID);
  ModuleAddress = (uintptr_t)fifo.dllAddress("client.dll");
  IS_INVALID_R(ModuleAddress, FAILE_MODULE);
  attached_ = true;

  return SUCCEED;
  #endif
  #else
  ModuleAddress =
      reinterpret_cast<DWORD64>(this->GetProcessModuleHandle(ProcessName));
  IS_INVALID_R(ModuleAddress, FAILE_MODULE);

  // hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_READ |
  // PROCESS_VM_WRITE, FALSE, ProcessID);

  hProcess = UkiaOpenProcess(
      PROCESS_QUERY_LIMITED_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ
      // | PROCESS_VM_WRITE
      ,
      FALSE, ProcessID);

  if (GetProcessId(hProcess) == ProcessID) {
    attached_ = true;
    delete[] t_SYSTEM_HANDLE_INFORMATION;
  } else {
    CloseHandle(hProcess);
    return FAILE_HPROCESS;
  }
  return SUCCEED;
  #endif
}

void ProcessManager::Detach() noexcept {
#ifdef USERMODE
  if (hProcess) CloseHandle(hProcess);
#endif

  hProcess = 0;
  ProcessID = 0;
  ModuleAddress = 0;
  attached_ = false;
}
HWND ProcessManager::GetWindowHandleFromProcessId(DWORD ProcessId) noexcept {
  HWND hwnd = NULL;
  do {
    hwnd = FindWindowEx(NULL, hwnd, NULL, NULL);
    DWORD pid = 0;
    GetWindowThreadProcessId(hwnd, &pid);
    if (pid == ProcessId) {
      TCHAR windowTitle[MAX_PATH];
      GetWindowText(hwnd, windowTitle, MAX_PATH);
      if (IsWindowVisible(hwnd) && windowTitle[0] != '\0') {
        return hwnd;
      }
    }
  } while (hwnd != NULL);
  return NULL;  // No main window found for the given process ID
}
/*
bool ProcessManager::IsActive() noexcept {
  if (!attached_) return false;
  DWORD ExitCode{};
  GetExitCodeProcess(hProcess, &ExitCode);
  return ExitCode == STILL_ACTIVE;
}
*/
// tewshi0 idea
std::string ProcessManager::ReadString(DWORD64 address,
                                       size_t maxLength) noexcept {
  std::vector<char> buffer(maxLength, 0);

  if (!ReadMemory<char>(address, buffer[0], maxLength)) {
    return "";
  }

  buffer[maxLength - 1] = '\0';

  size_t actualLength = 0;
  while (actualLength < maxLength && buffer[actualLength] != '\0') {
    ++actualLength;
  }

  return std::string(buffer.data(), actualLength);
}

DWORD ProcessManager::GetProcessID(std::string ProcessName) noexcept {
  PROCESSENTRY32 ProcessInfoPE;
  ProcessInfoPE.dwSize = sizeof(PROCESSENTRY32);
  SPOOF_FUNC;
  HANDLE hSnapshot = SPOOF_CALL(CreateToolhelp32Snapshot)(15, 0);
  Process32First(hSnapshot, &ProcessInfoPE);
  USES_CONVERSION;
  do {
    if (strcmp(W2A(ProcessInfoPE.szExeFile), ProcessName.c_str()) == 0) {
      CloseHandle(hSnapshot);
      return ProcessInfoPE.th32ProcessID;
    }
  } while (Process32Next(hSnapshot, &ProcessInfoPE));
  SPOOF_CALL(CloseHandle)(hSnapshot);
  return 0;
}
DWORD64 ProcessManager::TraceAddress(DWORD64 BaseAddress,
                                     std::vector<DWORD> Offsets) noexcept {
#ifdef USERMODE
  IS_INVALID_R(hProcess, 0);
#endif
  IS_INVALID_R(ProcessID, 0);
  DWORD64 Address = 0;

  if (Offsets.size() == 0) return BaseAddress;

  if (!ReadMemory<DWORD64>(BaseAddress, Address)) return 0;

  for (int i = 0; i < Offsets.size() - 1; i++) {
    if (!ReadMemory<DWORD64>(Address + Offsets[i], Address)) return 0;
  }
  return Address == 0 ? 0 : Address + Offsets[Offsets.size() - 1];
}

HMODULE ProcessManager::GetProcessModuleHandle(
    std::string ModuleName) noexcept {
#ifndef USERMODE
#ifndef FIFO_MODE
    return (HMODULE)driver.dll_address(ModuleName.c_str());
#else
  return (HMODULE)fifo.dllAddress(ModuleName.c_str());
  #endif
    #else
  MODULEENTRY32 ModuleInfoPE;
  ModuleInfoPE.dwSize = sizeof(MODULEENTRY32);
  SPOOF_FUNC;
  HANDLE hSnapshot =
      SPOOF_CALL(CreateToolhelp32Snapshot)(TH32CS_SNAPMODULE, this->ProcessID);
  Module32First(hSnapshot, &ModuleInfoPE);
  USES_CONVERSION;
  do {
    if (strcmp(W2A(ModuleInfoPE.szModule), ModuleName.c_str()) == 0) {
      SPOOF_CALL(CloseHandle)(hSnapshot);
      return ModuleInfoPE.hModule;
    }
  } while (Module32Next(hSnapshot, &ModuleInfoPE));
  SPOOF_CALL(CloseHandle)(hSnapshot);
  return 0;
  #endif
}

int UkiaInit(int argc, char* argv[]) noexcept {
  std::locale::global(std::locale("en_HK.UTF-8"));
#ifdef NDEBUG
  Ukia::HideConsole();
  Ukia::AntiDebugger(XorStr("Initialize fail"));
  if (!HasHashReadyParameter(argc, argv)) {
    std::string selfPath = GetSelfPath();
    if (selfPath.empty()) {
      return EXIT_FAILURE;
    }
    Ukia::PreUpdateHash(selfPath, argv);
    _exit(0);
  }
  SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);
#endif
  Ukia::ShowConsole();

  srand(static_cast<unsigned int>(time(nullptr)));
  RandomTitle();
  int iPadding = RANDOM_PADDING +
                 static_cast<int>(std::hash<std::string>{}(__FILE__)) +
                 __LINE__;
  // So that we can get randon .exe file Hash even codes are 100% same.
  printf(XorStr("%d\n"), iPadding);
  system("cls");
  printf(XorStr("Build - %s - %s\n"), __DATE__, __TIME__);
  UkiaData::strHWID = Ukia::GenerateHwId();
  printf(XorStr("%s\n"),
         UkiaData::strHWID.substr(UkiaData::strHWID.length() - 16).c_str());

  return 0;
}

int UkiaExit(DWORD code) noexcept {
  ProcessMgr.Detach();
  std::string selfPath = Ukia::GetSelfPath();
  if (selfPath.empty()) {
    return EXIT_FAILURE;
  }
  Ukia::PostUpdateHash(selfPath);
  _exit(code);
}
}  // namespace Ukia


================================================
FILE: UkiaStuff.h
================================================
﻿#pragma once
#include "pch.h"
#include "./Utils/CallStack-Spoofer.h"

#ifndef M_PI
#define M_PI 3.14159265358979323846  // matches value in gcc v2 math.h
#endif
#ifndef M_PI_F
#define M_PI_F ((float)(M_PI))  // Shouldn't collide with anything.
#endif
#ifndef M_PHI
#define M_PHI 1.61803398874989484820  // golden ratio
#endif
#ifndef RANDOM_PADDING
#define RANDOM_PADDING rand()
#endif
#ifndef IS_INVALID
#define IS_INVALID(v) \
  if (v == NULL) return false
#define IS_INVALID_R(v, n) \
  if (v == NULL) return n
#endif
enum StatusCode {
  SUCCEED,
  FAILE_PROCESSID,
  FAILE_HPROCESS,
  FAILE_MODULE,
};
typedef struct _UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWCH Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
  ULONG Length;
  HANDLE RootDirectory;
  PUNICODE_STRING ObjectName;
  ULONG Attributes;
  PVOID SecurityDescriptor;
  PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

typedef struct _CLIENT_ID {
  PVOID UniqueProcess;
  PVOID UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
  ULONG ProcessId;
  BYTE ObjectTypeNumber;
  BYTE Flags;
  USHORT Handle;
  PVOID Object;
  ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION {
  ULONG HandleCount;
  SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef NTSTATUS(NTAPI* _NtDuplicateObject)(HANDLE SourceProcessHandle,
                                            HANDLE SourceHandle,
                                            HANDLE TargetProcessHandle,
                                            PHANDLE TargetHandle,
                                            ACCESS_MASK DesiredAccess,
                                            ULONG Attributes, ULONG Options);

typedef NTSTATUS(NTAPI* _RtlAdjustPrivilege)(ULONG Privilege, BOOLEAN Enable,
                                             BOOLEAN CurrentThread,
                                             PBOOLEAN Enabled);

typedef NTSTATUS(NTAPI* _NtOpenProcess)(PHANDLE ProcessHandle,
                                        ACCESS_MASK DesiredAccess,
                                        POBJECT_ATTRIBUTES ObjectAttributes,
                                        PCLIENT_ID ClientId);

typedef NTSTATUS(NTAPI* _NtQuerySystemInformation)(
    ULONG
        SystemInformationClass,  // your supposed to supply the whole class but
                                 // microsoft kept the enum mostly empty so I
                                 // just passed 16 instead for handle info.
                                 // Thats why you get a warning in your code btw
    PVOID SystemInformation, ULONG SystemInformationLength,
    PULONG ReturnLength);

typedef NTSTATUS(WINAPI* pNtReadVirtualMemory)(HANDLE ProcessHandle,
                                               PVOID BaseAddress, PVOID Buffer,
                                               ULONG NumberOfBytesToRead,
                                               PULONG NumberOfBytesRead);

typedef NTSTATUS(WINAPI* pNtWriteVirtualMemory)(HANDLE ProcessHandle,
                                                PVOID BaseAddress, PVOID Buffer,
                                                ULONG NumberOfBytesToWrite,
                                                PULONG NumberOfBytesWritten);

inline SYSTEM_HANDLE_INFORMATION* hInfo;  // holds the handle information
namespace UkiaData {
inline std::string strHWID = "";
}
constexpr uint32_t CompileTimeSeed() noexcept;
namespace Ukia {
void HideConsole() noexcept;
void ShowConsole() noexcept;
void AntiDebugger(std::string log = "") noexcept;
std::wstring utf8ToUtf16(const std::string& utf8Str) noexcept;
std::string getRandomPoem() noexcept;
LPCWSTR getRandomPoemW() noexcept;
std::string GetSelfPath() noexcept;
bool HasHashReadyParameter(int argc, char* argv[]) noexcept;
void PreUpdateHash(const std::string& exePath, char* argv[]) noexcept;
void PostUpdateHash(const std::string& exePath) noexcept;
void RandomTitle() noexcept;
bool IsFullscreen(HWND hwnd) noexcept;
std::string GenerateMacAddress() noexcept;
std::string GenerateDiskSerial() noexcept;
std::string GenerateHwId() noexcept;
HANDLE UkiaOpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle,
                       DWORD dwProcessId) noexcept;
BOOL UkiaReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress,
                           LPVOID lpBuffer, SIZE_T nSize,
                           SIZE_T* lpNumberOfBytesRead) noexcept;
BOOL UkiaWriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress,
                            LPCVOID lpBuffer, SIZE_T nSize,
                            SIZE_T* lpNumberOfBytesWritten) noexcept;

class ProcessManager {
 private:
  bool attached_ = false;

 public:
  HANDLE hProcess = 0;
  DWORD ProcessID = 0;
  DWORD64 ModuleAddress = 0;

 public:
  inline ~ProcessManager() noexcept {
    if (hProcess) {
      SPOOF_FUNC;
      SPOOF_CALL(CloseHandle)(hProcess);
    }
  }

  SYSTEM_HANDLE_INFORMATION* t_SYSTEM_HANDLE_INFORMATION;

  StatusCode Attach(std::string ProcessName) noexcept;
  void Detach() noexcept;
  HWND GetWindowHandleFromProcessId(DWORD ProcessId) noexcept;
  //bool IsActive() noexcept;
  template <typename ReadType>
  inline bool ReadMemory(DWORD64 Address, ReadType& Value, size_t Size) noexcept {
#ifdef USERMODE
    IS_INVALID(hProcess);
#endif
    IS_INVALID(ProcessID);

    if (UkiaReadProcessMemory(hProcess, reinterpret_cast<LPCVOID>(Address),
                              &Value, Size, 0))
      return true;
    return false;
  }

  template <typename ReadType>
  inline bool ReadMemory(DWORD64 Address, ReadType& Value) noexcept {
#ifdef USERMODE
    IS_INVALID(hProcess);
#endif
    IS_INVALID(ProcessID);

    if (UkiaReadProcessMemory(hProcess, reinterpret_cast<LPCVOID>(Address),
                              &Value, sizeof(ReadType), 0))
      return true;
    return false;
  }

  template <typename ReadType>
  inline bool WriteMemory(DWORD64 Address, ReadType& Value, int Size) noexcept {
#ifdef USERMODE
    IS_INVALID(hProcess);
#endif
    IS_INVALID(ProcessID);

    if (UkiaWriteProcessMemory(hProcess, reinterpret_cast<LPCVOID>(Address),
                               &Value, Size, 0))
      return true;
    return false;
  }

  template <typename ReadType>
  inline bool WriteMemory(DWORD64 Address, ReadType& Value) noexcept {
#ifdef USERMODE
    IS_INVALID(hProcess);
#endif
    IS_INVALID(ProcessID);

    if (UkiaWriteProcessMemory(hProcess, reinterpret_cast<LPVOID>(Address),
                               &Value, sizeof(ReadType), 0))
      return true;
    return false;
  }
  std::string ReadString(DWORD64 address, size_t maxLength = 256) noexcept;
  DWORD GetProcessID(std::string ProcessName) noexcept;
  DWORD64 TraceAddress(DWORD64 BaseAddress,
                       std::vector<DWORD> Offsets) noexcept;
  template <typename T>
  inline bool GetDataAddressWithOffset(const DWORD64& Address,
                                                DWORD Offset,
                                                T& Data) noexcept {
    if (Address == 0) return false;

    if (!ReadMemory<T>(Address + Offset, Data)) return false;

    return true;
  }
  HMODULE GetProcessModuleHandle(std::string ModuleName) noexcept;
};
inline ProcessManager ProcessMgr;

BOOL WINAPI ConsoleCtrlHandler(DWORD dwCtrlType) noexcept;
int UkiaInit(int argc, char* argv[]) noexcept;
int UkiaExit(DWORD code = 0) noexcept;
}  // namespace Ukia


================================================
FILE: zekamashi.h
================================================
#pragma once
#ifndef ZEKAMASHI_H_
#define ZEKAMASHI_H_

namespace rawdata {
inline static constexpr unsigned char kZekamashiRawData[23386] = {
  0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
  0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x01, 0x45,
  0x08, 0x03, 0x00, 0x00, 0x00, 0x14, 0xF0, 0xCB, 0x5F, 0x00, 0x00, 0x03,
  0x00, 0x50, 0x4C, 0x54, 0x45, 0x47, 0x70, 0x4C, 0x1B, 0x0D, 0x0C, 0x29,
  0x1B, 0x1B, 0x30, 0x22, 0x25, 0x32, 0x27, 0x29, 0x37, 0x2A, 0x2D, 0x3B,
  0x27, 0x2A, 0x3C, 0x2C, 0x2E, 0x48, 0x43, 0x44, 0x50, 0x4D, 0x4B, 0x44,
  0x42, 0x45, 0x33, 0x30, 0x34, 0x40, 0x3F, 0x41, 0x48, 0x45, 0x46, 0x5C,
  0x5A, 0x59, 0x6B, 0x69, 0x67, 0x5E, 0x5C, 0x5E, 0x4A, 0x48, 0x50, 0x4E,
  0x4A, 0x53, 0x44, 0x42, 0x49, 0x36, 0x2F, 0x33, 0x3D, 0x39, 0x44, 0x39,
  0x37, 0x37, 0x3F, 0x3D, 0x3C, 0x32, 0x2D, 0x2F, 0x45, 0x46, 0x44, 0x4A,
  0x4A, 0x47, 0x4D, 0x4D, 0x4A, 0x50, 0x50, 0x4D, 0x53, 0x53, 0x50, 0x56,
  0x56, 0x54, 0x47, 0x41, 0x3E, 0x5A, 0x59, 0x57, 0x5D, 0x5D, 0x5A, 0x61,
  0x61, 0x5E, 0x64, 0x64, 0x60, 0x67, 0x67, 0x64, 0x6D, 0x6D, 0x6A, 0x69,
  0x6A, 0x67, 0x73, 0x74, 0x70, 0x71, 0x70, 0x6D, 0x76, 0x77, 0x73, 0x7A,
  0x79, 0x76, 0x7C, 0x7C, 0x79, 0x7F, 0x7F, 0x7C, 0x82, 0x82, 0x7E, 0x84,
  0x85, 0x80, 0x86, 0x87, 0x83, 0x8A, 0x89, 0x85, 0x8C, 0x8C, 0x87, 0x8F,
  0x8F, 0x8A, 0x92, 0x91, 0x8D, 0x94, 0x94, 0x90, 0x99, 0x99, 0x94, 0x9C,
  0x9C, 0x97, 0x98, 0x96, 0x8F, 0x9F, 0x9F, 0x9B, 0xA2, 0xA1, 0x9D, 0xA6,
  0xA5, 0xA0, 0xA9, 0xA9, 0xA4, 0xAD, 0xAC, 0xA6, 0xB0, 0xB0, 0xAB, 0x96,
  0x97, 0x96, 0xB4, 0xB3, 0xAF, 0xB8, 0xB7, 0xB2, 0xBB, 0xBA, 0xB6, 0x92,
  0x8C, 0x85, 0x29, 0x21, 0x25, 0x8D, 0x83, 0x7D, 0x7E, 0x74, 0x6E, 0xC1,
  0xBD, 0xBA, 0xC4, 0xC1, 0xBC, 0xC8, 0xC5, 0xBE, 0xCD, 0xC9, 0xC4, 0xD4,
  0xCF, 0xCB, 0xD9, 0xD3, 0xD0, 0x73, 0x6A, 0x62, 0x67, 0x5F, 0x5A, 0x89,
  0x7B, 0x7A, 0xB5, 0xA9, 0x9F, 0xAE, 0xA0, 0x92, 0xB7, 0xA4, 0x95, 0xAA,
  0x9B, 0x92, 0xB0, 0xA2, 0x9B, 0xA5, 0x95, 0x8E, 0x9F, 0x90, 0x87, 0xBD,
  0xAB, 0x99, 0xBE, 0xAE, 0xA5, 0xC8, 0xBB, 0xAB, 0xC1, 0xB4, 0xA5, 0xCF,
  0xC2, 0xB2, 0xD5, 0xC9, 0xBB, 0xE0, 0xD1, 0xC1, 0xDB, 0xCD, 0xBB, 0xE4,
  0xD7, 0xC8, 0xEA, 0xDC, 0xCC, 0xF1, 0xE2, 0xD2, 0xF9, 0xEA, 0xD7, 0xFC,
  0xEE, 0xDB, 0xFD, 0xF1, 0xDF, 0xF2, 0xE7, 0xD9, 0xFA, 0xE8, 0xCF, 0xFD,
  0xE6, 0xCC, 0xFD, 0xE4, 0xCB, 0xFC, 0xE1, 0xC8, 0xFC, 0xDE, 0xC3, 0xF7,
  0xDE, 0xC8, 0xFA, 0xDA, 0xBF, 0xE7, 0xDF, 0xDB, 0xDE, 0xD9, 0xD6, 0xE3,
  0xE3, 0xE0, 0xEB, 0xE6, 0xE5, 0xEF, 0xE1, 0xE2, 0xE8, 0xDA, 0xDA, 0xE4,
  0xD4, 0xD5, 0xE2, 0xD0, 0xD0, 0xDD, 0xCB, 0xCB, 0xDB, 0xC6, 0xC7, 0xD4,
  0xC2, 0xC1, 0xEB, 0xEA, 0xE6, 0xF4, 0xE8, 0xE8, 0xF7, 0xED, 0xEE, 0xFC,
  0xF3, 0xF3, 0xFD, 0xF9, 0xF9, 0xCC, 0xB3, 0xB3, 0xD5, 0xBB, 0xBA, 0xF9,
  0xD6, 0xB9, 0xF7, 0xD2, 0xB6, 0xF8, 0xD0, 0xB2, 0xF6, 0xCD, 0xAF, 0xEE,
  0xD6, 0xC0, 0xB0, 0x98, 0x84, 0xE9, 0xCA, 0xB4, 0xF6, 0xC8, 0xAC, 0xF3,
  0xC3, 0xA8, 0xE3, 0xC3, 0xAF, 0xEF, 0xC0, 0xA1, 0xF2, 0xBC, 0xA1, 0xE9,
  0xBD, 0x9E, 0xEE, 0xB9, 0x9A, 0xD9, 0xB1, 0x97, 0xEB, 0xB0, 0x93, 0xDB,
  0xB9, 0xA3, 0xD2, 0xA8, 0x9D, 0xCA, 0x9D, 0x89, 0x90, 0x71, 0x65, 0x9D,
  0x87, 0x75, 0x98, 0x7B, 0x66, 0xE6, 0xA8, 0x8B, 0xDC, 0xA1, 0x8B, 0x60,
  0x4A, 0x41, 0x71, 0x55, 0x50, 0xC1, 0x93, 0x91, 0xB6, 0x8E, 0x81, 0xC6,
  0xA0, 0xA2, 0x76, 0x60, 0x5A, 0x6D, 0x3E, 0x3E, 0xCD, 0x91, 0x7C, 0xA9,
  0x7C, 0x79, 0x9F, 0x64, 0x65, 0xB3, 0x73, 0x71, 0xE1, 0x99, 0x7B, 0xC0,
  0x83, 0x6D, 0x88, 0x67, 0x63, 0xAC, 0x86, 0x7D, 0x56, 0x30, 0x2F, 0xBC,
  0x83, 0x88, 0x81, 0x40, 0x44, 0x8F, 0x42, 0x45, 0x9D, 0x47, 0x4A, 0x90,
  0x4B, 0x48, 0xA7, 0x4C, 0x50, 0xA2, 0x51, 0x52, 0xAC, 0x56, 0x58, 0xB2,
  0x51, 0x56, 0xB2, 0x61, 0x65, 0xBE, 0x54, 0x53, 0x8E, 0x57, 0x58, 0xFC,
  0xF8, 0xE3, 0x66, 0x57, 0x6A, 0x82, 0x3D, 0x43, 0x83, 0x36, 0x3C, 0x73,
  0x31, 0x36, 0x6D, 0x30, 0x32, 0x93, 0x37, 0x3D, 0x78, 0x2B, 0x2D, 0x5E,
  0x1F, 0x20, 0x62, 0x23, 0x27, 0xBE, 0x97, 0x60, 0xD6, 0xAD, 0x93, 0xD1,
  0x9F, 0x85, 0xE8, 0xB5, 0x68, 0x8E, 0x8C, 0xAF, 0x7E, 0x7F, 0x9D, 0x8E,
  0x8D, 0x8B, 0xC4, 0xBA, 0xB6, 0xD0, 0xC5, 0xC0, 0xD4, 0xCC, 0xC3, 0xAE,
  0xA4, 0x9A, 0xD5, 0xCD, 0xC4, 0xC0, 0xB7, 0xAD, 0x77, 0x74, 0x93, 0x8F,
  0x8B, 0x97, 0x71, 0x64, 0x76, 0x6D, 0x6D, 0x8C, 0x6C, 0x6C, 0x98, 0x68,
  0x68, 0x8A, 0x63, 0x63, 0x84, 0x5E, 0x5D, 0x7C, 0x56, 0x56, 0x77, 0x40,
  0x3E, 0x5C, 0x47, 0x48, 0x68, 0x50, 0x50, 0x6D, 0x30, 0x2F, 0x48, 0xDE,
  0xD7, 0xD2, 0xB3, 0xA6, 0x9B, 0xC3, 0xBB, 0xB4, 0xC5, 0xBB, 0xB4, 0xBE,
  0xB7, 0xB1, 0xB9, 0xAE, 0xA7, 0xAF, 0xA2, 0x95, 0x81, 0x7B, 0x76, 0xA0,
  0x93, 0x8A, 0xA9, 0x9F, 0x97, 0xA9, 0x9D, 0x95, 0x97, 0x8E, 0x86, 0x9A,
  0x94, 0x8F, 0x96, 0x87, 0x7D, 0xAD, 0x9E, 0x95, 0xAE, 0xA3, 0x9C, 0xB1,
  0x9F, 0x96, 0x74, 0x70, 0x6B, 0x73, 0x6B, 0x66, 0x52, 0x4E, 0x50, 0x76,
  0x75, 0x74, 0x7E, 0x79, 0x75, 0x57, 0x56, 0x57, 0x85, 0x81, 0x7E, 0x6A,
  0x67, 0x66, 0x6C, 0x64, 0x60, 0x88, 0x71, 0x65, 0x99, 0x86, 0x7C, 0x8B,
  0x7A, 0x73, 0x62, 0x5B, 0x58, 0x8D, 0x7E, 0x75, 0x5F, 0x56, 0x50, 0x5C,
  0x55, 0x52, 0x5F, 0x56, 0x50, 0x84, 0x76, 0x6A, 0x7C, 0x6D, 0x62, 0x36,
  0x2D, 0x30, 0x38, 0x27, 0x29, 0x59, 0x41, 0x39, 0x32, 0x24, 0x25, 0x27,
  0x16, 0x12, 0x31, 0x20, 0x1D, 0x61, 0x4F, 0xA2, 0x77, 0x00, 0x00, 0x01,
  0x00, 0x74, 0x52, 0x4E, 0x53, 0x00, 0x02, 0x0F, 0x25, 0x35, 0x58, 0x73,
  0x90, 0x89, 0x75, 0xDF, 0xC3, 0xF1, 0xC6, 0xA2, 0xB8, 0xC5, 0xFF, 0xFF,
  0xFF, 0xE2, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFE, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xDF, 0xFF, 0xB4, 0xFC, 0xFF, 0xFF, 0xFE,
  0xCA, 0xFF, 0xE8, 0xD4, 0xFF, 0xFF, 0xFF, 0xF4, 0xEC, 0xE6, 0xAE, 0xEF,
  0xC8, 0x7B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xDE, 0xDE, 0xA3, 0xDA, 0xC7, 0xEA, 0xCC, 0xB5, 0x33,
  0x9D, 0x51, 0xC3, 0xE1, 0x9C, 0x86, 0x6B, 0xB6, 0xA0, 0x78, 0xAF, 0xED,
  0xD3, 0xE1, 0xE9, 0xDE, 0x89, 0x35, 0x75, 0x5D, 0x63, 0x44, 0x38, 0x4C,
  0x29, 0x22, 0x13, 0xA7, 0x46, 0x16, 0x1A, 0x05, 0x09, 0x07, 0xCA, 0x33,
  0x68, 0x00, 0x00, 0x57, 0x09, 0x49, 0x44, 0x41, 0x54, 0x78, 0xDA, 0xED,
  0xDD, 0x07, 0x9C, 0x66, 0x67, 0x5D, 0xF0, 0xFD, 0xDF, 0xFF, 0xBA, 0x4E,
  0xBB, 0xCB, 0xF4, 0xD9, 0xDE, 0x5B, 0xCA, 0x6E, 0x36, 0x15, 0x08, 0x01,
  0x42, 0x0B, 0x90, 0x10, 0x20, 0x44, 0x51, 0x54, 0x10, 0x81, 0x28, 0xA2,
  0xA0, 0x88, 0x80, 0x22, 0x88, 0x74, 0x50, 0x90, 0x26, 0x0A, 0x3C, 0xBC,
  0xA2, 0x0F, 0xA0, 0xBE, 0x02, 0x3E, 0x96, 0x50, 0xA4, 0x19, 0x5A, 0xA8,
  0x81, 0x14, 0x92, 0x6C, 0xDA, 0x26, 0xBB, 0x49, 0xB6, 0xCC, 0xB6, 0xE9,
  0x77, 0x39, 0xED, 0xFA, 0xFF, 0x5F, 0x70, 0x37, 0xC9, 0x26, 0xCF, 0x86,
  0x37, 0x82, 0x6C, 0xB2, 0x91, 0xEF, 0xCC, 0xCE, 0xCE, 0xEC, 0x67, 0x3F,
  0x33, 0x9F, 0xDF, 0xFC, 0xAF, 0x73, 0xEE, 0x33, 0xF7, 0x39, 0xF7, 0x3D,
  0xFC, 0xCC, 0xCF, 0xFC, 0xCC, 0xCF, 0xFC, 0xCC, 0xCF, 0x3C, 0x20, 0xB9,
  0x2A, 0x8A, 0x22, 0xE5, 0xC1, 0xCA, 0xC7, 0xCA, 0x8F, 0x12, 0xCA, 0x76,
  0x7B, 0xBC, 0xE5, 0x1E, 0xB4, 0xC3, 0x6D, 0x25, 0xFC, 0x08, 0x5A, 0xB5,
  0xC6, 0x7E, 0x20, 0xE1, 0xA7, 0xC5, 0x71, 0x7F, 0x72, 0xF1, 0x62, 0x53,
  0xEE, 0x95, 0x44, 0xF5, 0x48, 0x06, 0xF4, 0xC3, 0x83, 0xB2, 0xDF, 0x7C,
  0xDC, 0x56, 0x0D, 0xDC, 0x1B, 0x8D, 0xB3, 0x25, 0x29, 0xC0, 0x8C, 0x3D,
  0x18, 0xFB, 0x5D, 0x23, 0x6D, 0x5A, 0xDD, 0x35, 0xEE, 0x85, 0x35, 0x93,
  0x14, 0x00, 0x06, 0xEA, 0x07, 0x61, 0xBF, 0xCF, 0x9B, 0xA9, 0x58, 0xE1,
  0xB9, 0x17, 0x9A, 0x0E, 0x0D, 0x70, 0x90, 0xBA, 0x07, 0x5F, 0x7F, 0xD4,
  0x5C, 0x64, 0x42, 0xA5, 0x3F, 0x22, 0xBF, 0x2E, 0x01, 0xA0, 0x9F, 0xF3,
  0xA0, 0xEB, 0xAF, 0x92, 0x08, 0x40, 0x94, 0x7B, 0xE1, 0x5C, 0x93, 0x43,
  0x66, 0x84, 0x9F, 0x1A, 0xE1, 0xFE, 0x20, 0xE5, 0x50, 0x0A, 0x02, 0xF3,
  0x15, 0xF7, 0xC2, 0xAA, 0x25, 0x1C, 0x54, 0x94, 0xE5, 0x83, 0x6D, 0xFE,
  0xFF, 0x99, 0x8F, 0x59, 0xAF, 0xE0, 0xDE, 0xD4, 0xCB, 0x38, 0x28, 0xD1,
  0xC0, 0x4F, 0x4F, 0xC4, 0xFD, 0xA0, 0x3A, 0x34, 0xFD, 0xAA, 0xEB, 0xB8,
  0x37, 0x59, 0x96, 0x01, 0x40, 0x39, 0x93, 0xF2, 0xD3, 0x23, 0xF7, 0x57,
  0x3E, 0x48, 0xD5, 0x0B, 0xDC, 0xBB, 0x72, 0x09, 0x07, 0xCD, 0x97, 0x3C,
  0xA8, 0xD6, 0x7F, 0x34, 0x94, 0x09, 0x40, 0xDE, 0x0F, 0x1C, 0x81, 0x3A,
  0x00, 0x6C, 0x04, 0x00, 0x12, 0x51, 0x1E, 0x54, 0xEB, 0xDF, 0xA7, 0x89,
  0x81, 0x50, 0x56, 0x35, 0x47, 0x20, 0x59, 0x1E, 0x47, 0xAE, 0x97, 0xA5,
  0x09, 0x00, 0x94, 0xB9, 0xF2, 0x60, 0x9A, 0x7F, 0xE8, 0x27, 0x20, 0xC0,
  0x54, 0xC9, 0x91, 0x44, 0xC9, 0x68, 0x92, 0x8D, 0x8E, 0x34, 0x06, 0x62,
  0x00, 0x12, 0x57, 0x3D, 0xA8, 0xFA, 0xAD, 0xB9, 0x48, 0x10, 0x20, 0x6F,
  0xCA, 0x91, 0x37, 0x8E, 0x38, 0x4E, 0xB3, 0x32, 0x8E, 0x35, 0x53, 0x00,
  0xDD, 0xD5, 0x83, 0x07, 0xCF, 0xFE, 0x4F, 0xD3, 0x34, 0x46, 0x00, 0xEB,
  0x95, 0xC6, 0xFF, 0xCD, 0x35, 0x32, 0xBD, 0xDB, 0x6C, 0x26, 0xBC, 0xE7,
  0x41, 0x34, 0xFF, 0x10, 0xC7, 0x02, 0x40, 0xD5, 0x39, 0x52, 0xBE, 0x44,
  0x4D, 0xE3, 0x20, 0x77, 0x30, 0xBF, 0xE9, 0x79, 0x10, 0xF5, 0xD7, 0xC3,
  0x29, 0x08, 0x20, 0x55, 0xC4, 0x11, 0xB8, 0xC1, 0x9A, 0x43, 0x14, 0xD0,
  0xDC, 0xD7, 0xC0, 0x83, 0x67, 0xFF, 0xDF, 0x1C, 0x30, 0x00, 0x23, 0x0F,
  0xC2, 0x11, 0x78, 0xE3, 0x2E, 0xCA, 0x41, 0x1A, 0x95, 0x02, 0xE0, 0xE4,
  0x58, 0x9F, 0x7F, 0x14, 0xA9, 0x01, 0x40, 0x08, 0x1C, 0x41, 0x88, 0x55,
  0x38, 0xC4, 0x01, 0xAE, 0xA1, 0x55, 0xA3, 0xB1, 0x77, 0x60, 0x7C, 0x6C,
  0x6A, 0x66, 0x66, 0x6A, 0x4F, 0xCF, 0x1D, 0xDB, 0xFD, 0xD6, 0x1B, 0x02,
  0xC0, 0x70, 0x6A, 0x1C, 0x41, 0xD6, 0x14, 0xE3, 0x10, 0x05, 0xE7, 0x19,
  0xDD, 0x78, 0xDC, 0xA6, 0xA7, 0xAF, 0x5B, 0xB7, 0xFE, 0x9C, 0xF3, 0xCF,
  0x3F, 0xFF, 0x82, 0xEF, 0x6D, 0x9D, 0x0F, 0xC7, 0x72, 0x7F, 0x32, 0x5A,
  0x00, 0x18, 0x22, 0xCA, 0x11, 0xA8, 0x8B, 0xC0, 0x00, 0x70, 0x00, 0xD1,
  0xE6, 0x74, 0x45, 0x2B, 0x26, 0xF3, 0x5E, 0x52, 0x55, 0xAB, 0x5E, 0xF6,
  0xCB, 0x8F, 0x9F, 0xDA, 0x13, 0x39, 0xEE, 0xD4, 0xED, 0x75, 0xBB, 0x73,
  0xF9, 0xB1, 0x72, 0xFB, 0x57, 0xEB, 0x22, 0x40, 0x0C, 0xD8, 0x1B, 0xCB,
  0x11, 0x6F, 0xFC, 0x12, 0xC1, 0x38, 0xC8, 0x45, 0xB6, 0xF9, 0xC6, 0x81,
  0x48, 0x62, 0x07, 0xAE, 0xF2, 0x82, 0x21, 0xB9, 0x58, 0xF8, 0xC0, 0x53,
  0xBB, 0x81, 0x83, 0x7A, 0xFD, 0x5F, 0x7A, 0xC6, 0x81, 0xD6, 0x29, 0x0F,
  0x1D, 0x3C, 0x26, 0xE6, 0x2F, 0xCD, 0x25, 0x82, 0x60, 0x20, 0xAE, 0x2D,
  0x1C, 0x81, 0x13, 0xC1, 0xEE, 0xA8, 0xF7, 0xB6, 0xF9, 0xDA, 0xB4, 0x28,
  0xBD, 0x1A, 0xD4, 0xE2, 0xCC, 0x89, 0xAB, 0xD5, 0x7C, 0xF6, 0xEA, 0xE3,
  0xB7, 0xCD, 0x1B, 0x00, 0xFD, 0xEE, 0x93, 0x9B, 0x5F, 0x8A, 0xEA, 0xAF,
  0xEF, 0x2B, 0x8E, 0x89, 0x7E, 0x1F, 0x99, 0x61, 0x22, 0x20, 0x85, 0x72,
  0x24, 0x2E, 0xE5, 0x20, 0xE7, 0xBC, 0x38, 0x77, 0xED, 0x40, 0xDA, 0xA2,
  0xB0, 0x2A, 0x88, 0x8B, 0x70, 0xA6, 0xD6, 0x18, 0x6C, 0xA5, 0x31, 0xA3,
  0xBF, 0x79, 0xDE, 0x1E, 0x0F, 0xE8, 0xCC, 0x33, 0x54, 0xA5, 0x95, 0xB5,
  0x30, 0x57, 0x3C, 0xF0, 0xD7, 0xBF, 0xC4, 0x2D, 0xC1, 0x00, 0x27, 0xF3,
  0xF3, 0x99, 0xF2, 0x7F, 0x0B, 0x83, 0x89, 0x18, 0x00, 0x91, 0xC0, 0xE6,
  0x6B, 0xDA, 0x3E, 0xCF, 0x16, 0xED, 0x8D, 0x92, 0x42, 0xDA, 0x62, 0xE2,
  0xBD, 0x1A, 0x60, 0xB8, 0x24, 0xCD, 0xFF, 0xCF, 0x70, 0x13, 0xF6, 0x9E,
  0x53, 0x2D, 0x79, 0xF4, 0x30, 0xE8, 0x2F, 0x56, 0x75, 0x36, 0x9E, 0x3E,
  0xC0, 0xE7, 0x5F, 0xC7, 0x1C, 0x54, 0xCC, 0xF6, 0xBD, 0x72, 0x04, 0x2A,
  0x02, 0x00, 0x4E, 0x70, 0x9B, 0xAF, 0x1D, 0xF5, 0x9A, 0x2E, 0x60, 0xC8,
  0xFA, 0x45, 0x31, 0xD5, 0x73, 0x16, 0x4A, 0xD5, 0x4E, 0x47, 0x45, 0x34,
  0xEF, 0xA6, 0xCF, 0x7C, 0xE8, 0xE8, 0x78, 0x7A, 0xE2, 0xBE, 0x0E, 0xA0,
  0xDA, 0xFB, 0xE0, 0x87, 0xB7, 0x7F, 0x7C, 0x7B, 0xF1, 0xC0, 0xEE, 0x97,
  0x2C, 0x11, 0x00, 0x71, 0x96, 0x3B, 0xCF, 0x91, 0xB4, 0x53, 0xEE, 0xE0,
  0xD8, 0xB6, 0xB8, 0x35, 0x16, 0xCB, 0x7C, 0x9E, 0x0E, 0x85, 0x08, 0x17,
  0x75, 0x4A, 0x91, 0x90, 0x6B, 0xD1, 0x0B, 0xE2, 0x5C, 0xE8, 0xD8, 0xA2,
  0x45, 0x0C, 0x46, 0xDA, 0x4F, 0x2F, 0x67, 0x74, 0xCE, 0xBB, 0x70, 0x2D,
  0xFF, 0xE7, 0x4A, 0x79, 0x40, 0xF7, 0x6B, 0x97, 0x83, 0x94, 0x7B, 0x51,
  0x47, 0x0A, 0x00, 0xCE, 0x39, 0xDA, 0xED, 0x32, 0x30, 0xE2, 0xBA, 0xBD,
  0xC2, 0x0F, 0xE5, 0xB2, 0x70, 0xD9, 0xCA, 0xA8, 0x53, 0x95, 0x2A, 0x95,
  0x13, 0x11, 0xC4, 0xCA, 0x6E, 0x3C, 0xD8, 0xAC, 0xC4, 0x5F, 0x73, 0x0E,
  0x53, 0x67, 0x9D, 0xDE, 0x4A, 0x47, 0x35, 0x8C, 0xF4, 0x1F, 0xD0, 0xFD,
  0xD1, 0xB0, 0x18, 0x88, 0x40, 0x23, 0xE5, 0x88, 0x1A, 0x22, 0x1C, 0x24,
  0x34, 0x86, 0x02, 0xCD, 0x84, 0x51, 0xDF, 0xEF, 0xE5, 0xF1, 0xC8, 0x89,
  0x2B, 0x46, 0x16, 0x1C, 0xBF, 0xB4, 0x5B, 0x49, 0x73, 0x49, 0xA3, 0x04,
  0x21, 0xF4, 0xE6, 0xCB, 0xC1, 0xD1, 0x81, 0x3A, 0xEE, 0x67, 0x9A, 0x7D,
  0x8B, 0x53, 0x75, 0xDA, 0xA5, 0x9F, 0xD9, 0xF3, 0x80, 0xEE, 0x77, 0x0D,
  0x30, 0x00, 0xB1, 0x5E, 0xC4, 0x11, 0xB8, 0x24, 0x01, 0x04, 0x88, 0x9C,
  0x4F, 0xCB, 0x21, 0xE9, 0x76, 0x82, 0x8C, 0xF8, 0x7E, 0x5E, 0x8C, 0x03,
  0xDA, 0xC7, 0x15, 0x98, 0x14, 0x26, 0x58, 0xD6, 0x4E, 0xD2, 0x34, 0x6E,
  0xAE, 0x1C, 0x28, 0xAA, 0x4A, 0x2E, 0x19, 0xE2, 0xFA, 0xC1, 0xE7, 0x5C,
  0xEA, 0x18, 0x7F, 0x60, 0xF7, 0xAB, 0x89, 0x00, 0x98, 0x2E, 0x72, 0x1C,
  0x81, 0x17, 0x0E, 0x72, 0xC6, 0x50, 0xA3, 0xEE, 0x0F, 0xBA, 0x76, 0x24,
  0x41, 0xF3, 0xA2, 0xDF, 0xEC, 0x25, 0x5E, 0x3B, 0x7B, 0x12, 0xC0, 0xC2,
  0xA8, 0x51, 0x75, 0xCB, 0x88, 0xA8, 0xCE, 0x6D, 0x79, 0x96, 0xBC, 0x29,
  0x7E, 0x94, 0xBD, 0x8F, 0xE7, 0xA4, 0xEF, 0xFD, 0xDE, 0x05, 0xD1, 0x03,
  0xB9, 0x5F, 0xE7, 0xC1, 0x30, 0x30, 0x84, 0x8E, 0xC2, 0x3D, 0x59, 0x37,
  0x01, 0x40, 0x04, 0xE7, 0x32, 0x89, 0x42, 0xE9, 0x3B, 0xD6, 0xEB, 0x20,
  0x12, 0x35, 0x16, 0x6B, 0xBD, 0x6F, 0x4F, 0x2C, 0xE2, 0x20, 0xB4, 0x8D,
  0xD4, 0x27, 0xB5, 0x87, 0xA2, 0xC7, 0xF2, 0xD8, 0xBD, 0xE5, 0xCF, 0xBF,
  0x78, 0xFA, 0xD7, 0xF0, 0xE3, 0xEF, 0x5C, 0x9C, 0x3D, 0x90, 0xFB, 0xA3,
  0x11, 0x87, 0x18, 0x66, 0x60, 0x32, 0x72, 0x84, 0xFE, 0x78, 0x94, 0x43,
  0x1C, 0x4D, 0x91, 0x28, 0xA1, 0x2C, 0xA7, 0xBA, 0x58, 0xA3, 0xB1, 0x21,
  0x12, 0xBA, 0x7B, 0x53, 0x2A, 0x33, 0x34, 0xF4, 0x9B, 0x60, 0x45, 0x12,
  0x84, 0x58, 0xBB, 0xB2, 0x5C, 0xE2, 0xF0, 0xDD, 0xCB, 0x4E, 0xFE, 0x87,
  0x99, 0xC6, 0xB2, 0x36, 0x0F, 0xE4, 0xFE, 0x0A, 0x30, 0x84, 0xC8, 0x89,
  0x20, 0xC6, 0x3D, 0x89, 0x8F, 0x01, 0x30, 0x4C, 0xB4, 0x81, 0x99, 0x38,
  0x29, 0x44, 0xE4, 0x24, 0x36, 0x38, 0x5C, 0xB8, 0x7E, 0xC4, 0xB5, 0xF5,
  0x44, 0xB3, 0xBA, 0x6A, 0x0D, 0x34, 0xD4, 0xE5, 0xDD, 0x7E, 0xE1, 0x9C,
  0x94, 0xF3, 0x8D, 0x76, 0xB7, 0xA8, 0xAE, 0xF8, 0x1A, 0xC7, 0xA9, 0x03,
  0xA9, 0xBB, 0x9D, 0xE2, 0x01, 0xDA, 0xEF, 0xA6, 0x9D, 0x43, 0x4C, 0x7C,
  0x2C, 0x66, 0xB1, 0x29, 0xF7, 0xE0, 0x06, 0x04, 0x00, 0xC1, 0xB9, 0x2A,
  0x15, 0xC4, 0x7B, 0x2F, 0x16, 0x65, 0xFB, 0xE2, 0x39, 0xED, 0x17, 0x07,
  0x42, 0x37, 0x23, 0x2A, 0xEA, 0xF7, 0xF7, 0xD7, 0x36, 0x5B, 0x0B, 0xF6,
  0x4D, 0x56, 0x8D, 0xE1, 0x38, 0x0F, 0xC4, 0x61, 0xA6, 0x92, 0xB1, 0x85,
  0x8D, 0x9F, 0xCB, 0xEA, 0x58, 0x7D, 0x6F, 0xF7, 0x74, 0x7E, 0x45, 0x4F,
  0x1E, 0x98, 0xFD, 0x32, 0x20, 0xCE, 0x19, 0x56, 0xE1, 0x41, 0x96, 0x26,
  0xDC, 0x83, 0x8F, 0x39, 0xC4, 0x31, 0xEC, 0x1C, 0xAE, 0x98, 0x53, 0xE7,
  0x9A, 0xED, 0x64, 0x7C, 0xBA, 0x33, 0xA1, 0x5B, 0xA3, 0xDE, 0xEC, 0xDE,
  0x46, 0x73, 0xFD, 0x1F, 0xDB, 0x82, 0xD8, 0xF6, 0xB6, 0x16, 0x2C, 0x4E,
  0x5D, 0xD2, 0xAC, 0x83, 0xE8, 0x4C, 0xAF, 0xED, 0x24, 0xF9, 0xEC, 0x9B,
  0x1B, 0xFD, 0xE1, 0xFD, 0x9D, 0x27, 0x9E, 0xF7, 0xA4, 0x97, 0x6A, 0xEF,
  0x01, 0x7A, 0xFC, 0xEF, 0xB3, 0xB6, 0x49, 0x29, 0xC4, 0x27, 0x5D, 0x65,
  0x96, 0xCC, 0x14, 0xDC, 0x8D, 0xB5, 0x53, 0x0E, 0x92, 0x89, 0xB9, 0xC7,
  0xB6, 0x5C, 0xC9, 0x6C, 0xD5, 0xB6, 0x66, 0xC3, 0x01, 0x45, 0x3F, 0xEF,
  0xB4, 0x7C, 0xED, 0x4F, 0x13, 0xCC, 0x79, 0x2E, 0xAF, 0x17, 0xB6, 0x2D,
  0x37, 0x35, 0xCB, 0x8B, 0x3A, 0x2F, 0x06, 0x9C, 0x23, 0xCC, 0x13, 0x06,
  0x13, 0x87, 0xF7, 0xC1, 0x2E, 0x1D, 0x7C, 0x40, 0xCE, 0x9F, 0x50, 0xAA,
  0x68, 0x24, 0x56, 0x5D, 0x73, 0xAA, 0xA7, 0x1E, 0xF0, 0xDC, 0x4D, 0x2D,
  0x1C, 0x94, 0x4E, 0xF8, 0xB5, 0x19, 0x86, 0x08, 0x24, 0x41, 0x15, 0x48,
  0x07, 0x07, 0x46, 0xEA, 0x42, 0x97, 0xAA, 0x77, 0xDE, 0xD3, 0x0D, 0xCD,
  0x7E, 0x87, 0x4C, 0x10, 0x97, 0x48, 0x1D, 0x04, 0x03, 0xEF, 0x20, 0x8C,
  0x35, 0x62, 0x45, 0xBE, 0xE4, 0x78, 0x60, 0xF6, 0x4B, 0x39, 0xA7, 0x4E,
  0x7C, 0x64, 0xF5, 0x35, 0x3E, 0x8A, 0x5C, 0xA4, 0x1C, 0x46, 0xDB, 0x31,
  0x00, 0x64, 0x73, 0x0D, 0xDF, 0x9F, 0xAD, 0x42, 0x14, 0x0F, 0x54, 0x21,
  0x95, 0x5E, 0x50, 0xC0, 0x35, 0x9A, 0x83, 0x49, 0x35, 0x5F, 0xD5, 0x40,
  0x39, 0xD7, 0x70, 0xD6, 0x9B, 0xD3, 0x2C, 0xC2, 0xEA, 0x10, 0x42, 0x16,
  0x00, 0x13, 0xC9, 0xAA, 0xB9, 0xBC, 0x34, 0x0B, 0x65, 0xEB, 0x01, 0x7A,
  0xFF, 0xAF, 0x89, 0xDB, 0xB5, 0x1C, 0x07, 0x75, 0x1D, 0x79, 0x95, 0x81,
  0xC0, 0x61, 0x42, 0x2C, 0x20, 0x28, 0xE5, 0x4C, 0x2C, 0xBE, 0x91, 0xD4,
  0xCC, 0x56, 0x52, 0x48, 0xA6, 0x45, 0x12, 0x39, 0x70, 0x09, 0x0E, 0xD5,
  0xBE, 0x65, 0x4C, 0xEE, 0x6A, 0x01, 0x79, 0x88, 0x63, 0xAD, 0x72, 0x89,
  0xA5, 0xDD, 0xC5, 0x04, 0xF1, 0xB5, 0x56, 0x48, 0xA8, 0xBF, 0x34, 0x2C,
  0x0F, 0xD0, 0xF9, 0x83, 0x66, 0x3B, 0x01, 0x1F, 0x5B, 0xAD, 0x0E, 0x67,
  0x0E, 0x10, 0x13, 0x80, 0x60, 0x31, 0x12, 0x79, 0x1F, 0x7F, 0x7D, 0x36,
  0x86, 0x39, 0x11, 0x98, 0x2B, 0xA5, 0xE9, 0xC5, 0xA7, 0x65, 0x5E, 0x2B,
  0x48, 0x1C, 0x35, 0x8B, 0x39, 0xA4, 0x9A, 0xDC, 0xD9, 0x30, 0x40, 0xAA,
  0xB9, 0xF9, 0xBA, 0xAF, 0x81, 0xD1, 0x86, 0x2A, 0x00, 0x1E, 0xB5, 0x72,
  0xF7, 0x65, 0xA3, 0x8D, 0x07, 0xF2, 0xF9, 0xAF, 0x10, 0x56, 0x02, 0x97,
  0x3C, 0xDA, 0xBC, 0x57, 0x66, 0x4A, 0xAB, 0xDB, 0x51, 0x5D, 0x07, 0x29,
  0x87, 0x13, 0x89, 0x30, 0xF8, 0xCA, 0x69, 0x95, 0x41, 0x35, 0xFB, 0x44,
  0x97, 0x86, 0x10, 0x7B, 0xC0, 0xAC, 0x72, 0x2E, 0x02, 0x55, 0xAD, 0x47,
  0x9A, 0xBD, 0x66, 0xAF, 0x6B, 0xB5, 0x09, 0xA0, 0x5D, 0x27, 0x92, 0xB7,
  0x06, 0xCA, 0x03, 0x91, 0x73, 0xF4, 0x95, 0xA2, 0xD8, 0x9E, 0x44, 0xE9,
  0x03, 0xFB, 0xFE, 0x5F, 0xEF, 0x6F, 0x87, 0x4B, 0xCE, 0x89, 0x25, 0x98,
  0x93, 0xC1, 0x38, 0x1B, 0x19, 0xCB, 0x46, 0x46, 0x92, 0x64, 0x64, 0x98,
  0xC4, 0x99, 0x7C, 0xC5, 0x4E, 0x2B, 0x0C, 0x48, 0x96, 0xCE, 0x43, 0x9C,
  0x79, 0x40, 0xC4, 0x25, 0xD2, 0xEF, 0xD5, 0xC1, 0x4C, 0xE5, 0xC0, 0x75,
  0x13, 0x07, 0x72, 0xE7, 0x13, 0x87, 0x01, 0x82, 0x84, 0xA2, 0x61, 0x88,
  0x00, 0xE0, 0x7A, 0x93, 0xA3, 0xAD, 0xF4, 0x01, 0x7F, 0xFE, 0xD3, 0xD2,
  0xC1, 0x08, 0x08, 0xB5, 0xFB, 0xDA, 0x63, 0xED, 0xAB, 0x67, 0xE3, 0x05,
  0x57, 0xB4, 0xFA, 0xA7, 0xB2, 0x65, 0xD3, 0x55, 0xFD, 0xBD, 0x43, 0x0A,
  0x80, 0x35, 0x77, 0x3E, 0xC5, 0x0B, 0x77, 0xD0, 0x7E, 0x15, 0x0F, 0xD0,
  0xB3, 0x5E, 0xD6, 0xD0, 0xC8, 0x2A, 0xEF, 0x42, 0x85, 0x14, 0x65, 0x54,
  0x17, 0xD1, 0x42, 0x8B, 0x77, 0x4A, 0x6C, 0xF4, 0x71, 0x37, 0xA5, 0x76,
  0x0C, 0x9C, 0xFF, 0x93, 0x72, 0x62, 0x9E, 0x4B, 0xF0, 0xA9, 0x7B, 0xF4,
  0x57, 0x4E, 0x79, 0x2C, 0xE0, 0x9C, 0x64, 0xE5, 0xA9, 0xA0, 0xD7, 0xD8,
  0xC2, 0x72, 0xE7, 0x5C, 0x0D, 0x20, 0xDD, 0xE5, 0x9F, 0xAC, 0x0C, 0x60,
  0x0C, 0x81, 0x05, 0xCD, 0xAC, 0x3A, 0x30, 0x55, 0x55, 0xDE, 0x2A, 0x29,
  0x8A, 0x76, 0x5A, 0xFA, 0x98, 0x50, 0xF9, 0xBA, 0x8E, 0x5A, 0x84, 0xAE,
  0x58, 0xB0, 0x10, 0x3C, 0x03, 0xC7, 0xCA, 0xF5, 0x3F, 0x96, 0x24, 0x03,
  0x80, 0x86, 0x53, 0xAF, 0xAE, 0xE3, 0xCD, 0x70, 0x8D, 0x03, 0x95, 0x0C,
  0xE8, 0x8C, 0x2D, 0xFA, 0x9B, 0xC5, 0x03, 0x02, 0xE2, 0xD3, 0x45, 0x0B,
  0xBC, 0x88, 0x18, 0x63, 0x93, 0x8C, 0xED, 0xA7, 0x2A, 0x2B, 0xEF, 0x80,
  0x2C, 0xB6, 0x2A, 0xEA, 0x64, 0x41, 0x8B, 0xC2, 0x99, 0x73, 0x2D, 0xB1,
  0x30, 0x8B, 0xB7, 0xAA, 0x4E, 0xEB, 0xBD, 0xE5, 0x31, 0xD2, 0x0F, 0x1A,
  0x6C, 0xE5, 0x26, 0xB6, 0x6C, 0x82, 0x1B, 0x4F, 0xDF, 0xAB, 0xAD, 0x86,
  0x58, 0x68, 0xCF, 0xB8, 0xEC, 0xCA, 0xA8, 0x2F, 0x9B, 0xD2, 0xF7, 0x2F,
  0x6E, 0xFA, 0x68, 0xE7, 0x59, 0xBD, 0x78, 0x3C, 0xA1, 0x5F, 0xB7, 0xFD,
  0xD8, 0x24, 0xA6, 0xD4, 0xC1, 0xC0, 0x14, 0x69, 0x44, 0x65, 0x0D, 0x65,
  0x1E, 0xBC, 0x68, 0xDB, 0xA3, 0xF5, 0x9C, 0x87, 0x92, 0x74, 0x4F, 0x59,
  0x1F, 0x33, 0xFD, 0xF8, 0x9B, 0x9E, 0x3A, 0xBD, 0x89, 0xAD, 0xC7, 0x0F,
  0x2F, 0xEA, 0x03, 0x26, 0x80, 0x85, 0x1A, 0x3D, 0x70, 0x53, 0xD1, 0x3E,
  0xFE, 0x35, 0xE7, 0x6E, 0x7B, 0x94, 0xC5, 0x74, 0x64, 0xD4, 0x4F, 0xE6,
  0xED, 0x71, 0x61, 0xEC, 0x80, 0xF5, 0xE7, 0x43, 0x6D, 0x71, 0x33, 0x0A,
  0xB8, 0x96, 0x2F, 0xFB, 0xA5, 0x39, 0xB5, 0x6A, 0x30, 0xC2, 0xAC, 0xE8,
  0x7A, 0x28, 0x22, 0x7F, 0x60, 0x4E, 0x8E, 0x95, 0xEB, 0x9F, 0xA4, 0x33,
  0xF1, 0xB4, 0xE9, 0x4D, 0xD7, 0xAD, 0x3F, 0x69, 0x3C, 0xEE, 0x1B, 0x60,
  0x20, 0x26, 0x51, 0x5C, 0xCA, 0xAA, 0x85, 0x7B, 0xB7, 0x7E, 0xFF, 0x4D,
  0x8F, 0x7A, 0xA4, 0xB4, 0x52, 0xFB, 0xEA, 0xC0, 0xF4, 0xB9, 0xA3, 0xDD,
  0xB9, 0x78, 0x78, 0xEC, 0x00, 0xE2, 0xFB, 0xEA, 0xB4, 0x8A, 0x22, 0xF1,
  0xD6, 0x91, 0xBA, 0x36, 0x87, 0xF5, 0x07, 0x63, 0x03, 0x2A, 0x07, 0x66,
  0xAE, 0xCE, 0x85, 0x1F, 0x8F, 0xE7, 0x68, 0xEB, 0xEC, 0xBA, 0x60, 0xE9,
  0x54, 0xF7, 0x51, 0x0B, 0x16, 0x15, 0x02, 0x80, 0x00, 0x08, 0x78, 0x29,
  0xFC, 0x48, 0x6B, 0xD9, 0xD5, 0x8B, 0x1E, 0x92, 0xFF, 0xD9, 0x6F, 0xFC,
  0xFA, 0x40, 0xF6, 0xCE, 0xE9, 0xEF, 0x7D, 0x22, 0xEB, 0x26, 0x25, 0x82,
  0xF7, 0xC5, 0xF0, 0x50, 0x92, 0x98, 0x47, 0x28, 0x0D, 0x09, 0x75, 0xD1,
  0x5E, 0xD2, 0x17, 0xA8, 0x73, 0x90, 0x1A, 0x66, 0x3A, 0x6F, 0xE4, 0x18,
  0x59, 0xFF, 0xFD, 0xDB, 0xFF, 0xE0, 0x7B, 0x0F, 0xB3, 0x46, 0x92, 0x04,
  0xAF, 0x1C, 0x46, 0x40, 0xFA, 0x2E, 0xA6, 0x3B, 0xB9, 0x6C, 0xE0, 0x0F,
  0x96, 0x7B, 0x40, 0xCA, 0x05, 0xAB, 0x32, 0x8B, 0x01, 0xB3, 0x03, 0xDD,
  0x45, 0x49, 0xCF, 0x09, 0x52, 0x57, 0x46, 0xD0, 0x3A, 0x6D, 0x09, 0x60,
  0x9D, 0xD2, 0x1B, 0x25, 0x73, 0x45, 0xC5, 0x31, 0x32, 0xFF, 0xE2, 0xD6,
  0x3F, 0xE9, 0x9C, 0x9A, 0x95, 0x99, 0x88, 0xE8, 0xE1, 0xF3, 0x17, 0x00,
  0x1F, 0xCC, 0xA5, 0xAD, 0xAA, 0xFC, 0xEA, 0x39, 0x6F, 0x03, 0x78, 0x53,
  0xF7, 0xE5, 0x57, 0x7C, 0xD4, 0x81, 0x08, 0x71, 0x99, 0x8A, 0x1F, 0x28,
  0x21, 0x40, 0xB0, 0x3A, 0xCB, 0x10, 0x31, 0x2B, 0x7A, 0x5E, 0xA4, 0x36,
  0x26, 0xDE, 0x64, 0x70, 0x6C, 0x6C, 0xFF, 0xF9, 0xEB, 0xEA, 0x55, 0xDA,
  0x4B, 0x41, 0x14, 0x00, 0xC4, 0xA4, 0x26, 0x7A, 0x3A, 0x17, 0x63, 0x90,
  0xD6, 0xEA, 0x22, 0xD7, 0xD7, 0x6B, 0xE6, 0xDB, 0x00, 0x9E, 0x85, 0xCD,
  0x35, 0xA9, 0x07, 0x92, 0x05, 0xEA, 0x5D, 0xE9, 0x6B, 0xD5, 0x1F, 0xBE,
  0x36, 0xBC, 0x8A, 0x99, 0xE9, 0xBC, 0x28, 0xA6, 0xCC, 0x89, 0xC2, 0xB1,
  0xB1, 0xFE, 0xDD, 0xF6, 0x57, 0xA7, 0xD4, 0xB3, 0x43, 0x68, 0x82, 0x09,
  0x80, 0x80, 0xAC, 0xDA, 0xD2, 0x70, 0x4F, 0xBF, 0x18, 0x00, 0x41, 0xD1,
  0xE9, 0xC6, 0x1B, 0x57, 0xA5, 0x00, 0xE0, 0x66, 0xF3, 0xF3, 0x62, 0x11,
  0x42, 0x95, 0x68, 0x15, 0xAC, 0xB4, 0x5A, 0x43, 0x43, 0x00, 0xA0, 0x57,
  0x7B, 0x0C, 0x66, 0xCB, 0xCA, 0x8E, 0x91, 0x7E, 0x99, 0xFD, 0xED, 0xCC,
  0x34, 0xB7, 0x86, 0xD5, 0xE9, 0x1D, 0xD3, 0xE7, 0xE9, 0x7C, 0xEC, 0x09,
  0x73, 0xFD, 0xAD, 0x17, 0x02, 0x17, 0x43, 0x88, 0x14, 0xCD, 0x79, 0xC7,
  0x0A, 0x03, 0x00, 0xE9, 0x2D, 0xBA, 0xF9, 0xFC, 0x38, 0x94, 0xA9, 0xCB,
  0x83, 0xEF, 0x15, 0xCE, 0x24, 0x31, 0x00, 0xA4, 0x57, 0x09, 0x20, 0xB3,
  0x55, 0xDF, 0x1D, 0x2B, 0xD7, 0xBF, 0x75, 0xAE, 0xCE, 0xCC, 0x82, 0x09,
  0x12, 0x1C, 0x00, 0x08, 0x40, 0x36, 0x17, 0x2F, 0xDC, 0xFC, 0x2F, 0xC0,
  0xD3, 0xC1, 0xD5, 0x86, 0xA4, 0xF4, 0x6F, 0xE1, 0x20, 0x6B, 0x4C, 0xD9,
  0x54, 0xA7, 0x10, 0xB3, 0xC8, 0xE5, 0x16, 0x59, 0x9C, 0x1A, 0x80, 0xB3,
  0xF9, 0xCA, 0xFD, 0x67, 0x7E, 0x99, 0x3B, 0x8E, 0x91, 0xFE, 0x7A, 0xE2,
  0x6F, 0x0D, 0x5F, 0x21, 0xE0, 0x2A, 0x00, 0x0E, 0x36, 0x5F, 0xD8, 0x6F,
  0xCF, 0xC4, 0x0F, 0xBD, 0xEA, 0x3F, 0x3F, 0x12, 0x67, 0x38, 0x97, 0xBC,
  0x56, 0x8C, 0x83, 0xC2, 0xE4, 0x23, 0xD3, 0x62, 0x76, 0x3E, 0xAF, 0xA9,
  0xAD, 0xD6, 0x48, 0x14, 0x9C, 0xD3, 0x7E, 0xC7, 0xF9, 0x08, 0x64, 0xA6,
  0xA8, 0x84, 0x63, 0xA5, 0xBF, 0xFB, 0x26, 0x11, 0xC9, 0x29, 0x37, 0x12,
  0x39, 0x05, 0x11, 0x0E, 0xB9, 0x69, 0x5A, 0xBB, 0x36, 0xF6, 0x4F, 0x5C,
  0xCC, 0xC5, 0x88, 0x18, 0xE2, 0xDC, 0x44, 0x17, 0x00, 0xFA, 0x07, 0xCE,
  0x59, 0x30, 0x32, 0x3C, 0x14, 0xF6, 0xEF, 0x39, 0xD0, 0x9D, 0x93, 0x38,
  0x02, 0xA4, 0x9A, 0x2F, 0xEB, 0x54, 0x42, 0xC9, 0xDC, 0x81, 0xBC, 0x32,
  0x7E, 0x12, 0x9E, 0xA3, 0x67, 0x66, 0xEF, 0xB7, 0xEC, 0xC2, 0x1B, 0xF6,
  0xB6, 0xCF, 0x5E, 0x72, 0x8B, 0xC7, 0x62, 0x13, 0x00, 0xB9, 0xF1, 0xC6,
  0x13, 0x38, 0x71, 0x52, 0x6F, 0x1D, 0x88, 0x16, 0xDF, 0x36, 0xAB, 0x86,
  0x00, 0xC0, 0x37, 0xCF, 0x7E, 0x0F, 0x80, 0xFF, 0xCB, 0x4F, 0x0F, 0xC6,
  0xDE, 0xC7, 0x59, 0x4C, 0xBF, 0x4E, 0x0F, 0xF4, 0x66, 0xE7, 0x44, 0x8B,
  0xCA, 0x79, 0x5F, 0xFA, 0x7E, 0x67, 0xCF, 0x1F, 0xFD, 0xC9, 0xEB, 0x8F,
  0x9D, 0xEB, 0x9F, 0xC3, 0xDE, 0xD7, 0x9A, 0x5D, 0xF8, 0xC9, 0xDD, 0x23,
  0x0F, 0x1B, 0xF9, 0x7C, 0x82, 0x5A, 0xC4, 0x41, 0x82, 0x5D, 0x78, 0xF5,
  0xC8, 0x35, 0xB2, 0xB6, 0x51, 0x5D, 0xD7, 0x97, 0xC4, 0x00, 0x16, 0x4E,
  0x84, 0x3F, 0x5E, 0x93, 0x41, 0x3D, 0xF9, 0xE4, 0x96, 0x03, 0x08, 0xA5,
  0x95, 0xF5, 0xA5, 0x03, 0x69, 0x95, 0x75, 0x87, 0xB9, 0x9D, 0x95, 0x4D,
  0xFA, 0x55, 0xA8, 0x1C, 0x3C, 0xF0, 0xFB, 0x9D, 0x04, 0x40, 0xA6, 0x7B,
  0x7F, 0x90, 0x08, 0x28, 0xA7, 0x8C, 0x31, 0x75, 0x95, 0xF8, 0x3C, 0x72,
  0xE0, 0x03, 0x00, 0x92, 0x1E, 0x37, 0xB5, 0x73, 0xC5, 0xE0, 0xF0, 0xA7,
  0xDB, 0x75, 0x26, 0x00, 0x58, 0x08, 0x1F, 0x18, 0x44, 0x5B, 0xC7, 0x0F,
  0x89, 0x01, 0x68, 0xA8, 0x5D, 0xFF, 0xA6, 0xAE, 0x03, 0xA9, 0x13, 0x31,
  0xC1, 0x6A, 0xE1, 0xD8, 0xE0, 0xB2, 0x19, 0x2B, 0xB6, 0x7D, 0xFB, 0xC6,
  0x67, 0x3D, 0xF7, 0xD7, 0x2F, 0xBA, 0xE8, 0xF9, 0xCF, 0x7B, 0xDE, 0x07,
  0x3F, 0xF2, 0xBE, 0x0F, 0xBE, 0xF9, 0x05, 0xCF, 0x7F, 0xDE, 0x73, 0x5F,
  0xF0, 0xFC, 0x1F, 0xBC, 0x5C, 0xF4, 0x82, 0x8B, 0x7E, 0xE8, 0x1D, 0x6F,
  0xB8, 0xE8, 0x37, 0xDF, 0xF7, 0xE1, 0x0F, 0xBE, 0xF1, 0x83, 0x6F, 0x7C,
  0xFE, 0xF3, 0x2F, 0x7A, 0xFE, 0x0F, 0xFE, 0xDF, 0x73, 0x7F, 0x6D, 0xBB,
  0x50, 0x4D, 0x3D, 0xE2, 0xB1, 0x8F, 0x79, 0xCC, 0xD9, 0x8F, 0xF9, 0x81,
  0x47, 0x9D, 0xF5, 0xE8, 0x09, 0x77, 0x4C, 0x5E, 0xFF, 0x2F, 0x73, 0x3B,
  0xFD, 0xE4, 0x3F, 0xCD, 0xE5, 0x75, 0xE6, 0x0C, 0xA8, 0x9E, 0x34, 0xD7,
  0x8F, 0xE7, 0x6D, 0x47, 0xD5, 0xEC, 0x25, 0x98, 0x18, 0x50, 0x23, 0x1B,
  0xD8, 0xB1, 0xB4, 0x3D, 0x30, 0xAF, 0x0B, 0xF7, 0x5F, 0x5F, 0x81, 0x18,
  0xA6, 0xBF, 0x7D, 0x5A, 0x96, 0xAC, 0x1C, 0x6D, 0x62, 0x00, 0x68, 0xF5,
  0xA9, 0x66, 0xEB, 0x98, 0xBC, 0xFE, 0xD7, 0x1A, 0x43, 0x6F, 0xFA, 0xE0,
  0x54, 0xA5, 0x08, 0x80, 0x9C, 0x4E, 0xD1, 0xD1, 0x85, 0xD7, 0x96, 0xF4,
  0x9A, 0x91, 0x38, 0x71, 0x02, 0x11, 0x16, 0x1A, 0xAB, 0xB3, 0x72, 0x86,
  0xB4, 0xDB, 0x58, 0x1E, 0x21, 0x5E, 0x88, 0xF5, 0x03, 0x57, 0x89, 0x7E,
  0xBB, 0x67, 0x22, 0x02, 0x10, 0x3E, 0xD5, 0x6A, 0x71, 0x4C, 0xCE, 0x1F,
  0xE9, 0xEF, 0xFD, 0x43, 0x47, 0x6F, 0x20, 0x31, 0x13, 0x91, 0xCD, 0x03,
  0xD3, 0x97, 0x9F, 0x16, 0x77, 0xAE, 0x38, 0x6D, 0x0F, 0x80, 0xBA, 0x80,
  0x2D, 0xBF, 0xCE, 0xEB, 0x99, 0x71, 0x3F, 0x8F, 0x06, 0xB2, 0xF9, 0xB8,
  0xB8, 0x3E, 0x18, 0x62, 0x04, 0x26, 0xFF, 0x9F, 0x65, 0x51, 0xB4, 0xE3,
  0x19, 0x35, 0x68, 0xF5, 0xB9, 0x68, 0x3C, 0x70, 0x8C, 0xF6, 0x23, 0xFD,
  0x62, 0xA6, 0xF7, 0xAA, 0x21, 0x87, 0x3A, 0x71, 0x8F, 0xB6, 0x5B, 0xB7,
  0x9E, 0xAE, 0x8D, 0x68, 0xBE, 0xB7, 0x47, 0x30, 0x00, 0x75, 0x2B, 0x48,
  0xDD, 0x00, 0xD3, 0x64, 0x83, 0x73, 0xF9, 0x65, 0x4D, 0x11, 0x30, 0xB4,
  0x8A, 0x7E, 0xF3, 0xD4, 0xB6, 0xC6, 0xF3, 0xA1, 0x5E, 0x22, 0x93, 0x69,
  0x64, 0x1C, 0xBB, 0x84, 0x62, 0xE6, 0xE6, 0xE7, 0x5D, 0xF4, 0xFC, 0xE7,
  0x3C, 0xFF, 0xA2, 0x17, 0xFD, 0xCD, 0xFB, 0x5E, 0xF7, 0xC2, 0x17, 0xBD,
  0xF9, 0x9D, 0xEF, 0x7B, 0xCF, 0x3B, 0xDE, 0xF8, 0xE2, 0xD7, 0xBE, 0xF8,
  0xC5, 0x6F, 0x7C, 0xDD, 0x8B, 0x5F, 0xFC, 0xE2, 0x17, 0xFD, 0xF6, 0xEB,
  0xFE, 0xEA, 0xAF, 0xFE, 0xF4, 0x45, 0xAF, 0x7D, 0xEB, 0x3B, 0xDE, 0xF6,
  0xF6, 0xF7, 0x3C, 0xFB, 0x3F, 0xF7, 0x7F, 0xCF, 0x7F, 0xDE, 0x85, 0xBF,
  0xF2, 0xAC, 0x9B, 0x3A, 0x00, 0x88, 0x1C, 0xFB, 0x8F, 0x7F, 0xCA, 0xB7,
  0xBF, 0x53, 0xAD, 0x48, 0xDD, 0xAA, 0x65, 0xFD, 0x7D, 0xFB, 0xDC, 0x8A,
  0xC1, 0x2C, 0xAF, 0xD0, 0x59, 0x83, 0x84, 0x72, 0x12, 0x96, 0x64, 0xDD,
  0x1B, 0x4F, 0x1C, 0x1C, 0xAD, 0xE6, 0x8A, 0x84, 0xAB, 0x41, 0x0C, 0xFA,
  0xC6, 0x9B, 0x59, 0xD8, 0x8A, 0x1E, 0x1C, 0x8F, 0xFF, 0x31, 0x6A, 0xF3,
  0x0A, 0x71, 0x5C, 0xE0, 0xA9, 0xB6, 0x5C, 0x3E, 0x1B, 0xC5, 0x43, 0x2B,
  0x07, 0x53, 0x4F, 0x33, 0x19, 0x5F, 0xB4, 0x88, 0xCB, 0xD6, 0x7E, 0xE9,
  0x2F, 0xDF, 0xEA, 0x96, 0x6F, 0x5C, 0x35, 0x3C, 0xAC, 0x00, 0x9E, 0x58,
  0x92, 0x85, 0x8B, 0xA8, 0x39, 0xF6, 0xFB, 0x0F, 0xD7, 0x03, 0xC2, 0xE2,
  0xEB, 0x76, 0x9F, 0x30, 0x20, 0xE4, 0x2C, 0x5C, 0xDC, 0x74, 0xB4, 0xE3,
  0x10, 0xFC, 0xE6, 0x8F, 0x3C, 0xE2, 0x9C, 0xC7, 0x7D, 0x7A, 0xCB, 0xF5,
  0xA3, 0xCB, 0x5A, 0x27, 0x44, 0x98, 0x04, 0x04, 0x99, 0x18, 0x18, 0xCA,
  0xE4, 0x41, 0xD2, 0x1F, 0x99, 0x05, 0x0C, 0x23, 0x5B, 0xF6, 0xC8, 0x75,
  0xFB, 0xBF, 0xF3, 0xC5, 0x48, 0x73, 0xF2, 0x79, 0x46, 0x97, 0x3B, 0x5A,
  0xB1, 0x43, 0x5A, 0xF3, 0xDD, 0x7A, 0xEA, 0xF2, 0xD9, 0x7D, 0x90, 0x02,
  0xE6, 0xBD, 0x83, 0xBF, 0x9D, 0x05, 0x7B, 0x70, 0xF4, 0x17, 0x04, 0x13,
  0x6F, 0x40, 0xDF, 0x2F, 0xE2, 0xE9, 0x8F, 0xF5, 0xFF, 0xF4, 0xA5, 0xFE,
  0x6C, 0xB7, 0xD7, 0xCF, 0xA7, 0x46, 0x69, 0x36, 0xE3, 0xD8, 0x9F, 0xFB,
  0x73, 0x56, 0xEC, 0xB5, 0xAD, 0xFF, 0x7E, 0x7B, 0x4A, 0x15, 0x41, 0x0D,
  0xD4, 0xBD, 0x0E, 0x3C, 0x68, 0xD6, 0xBF, 0x19, 0xCE, 0x00, 0x19, 0xDC,
  0x7F, 0xFD, 0x65, 0xF5, 0x93, 0xB6, 0x7D, 0xE7, 0xFB, 0x75, 0xB7, 0x37,
  0x67, 0x71, 0x15, 0xF7, 0x25, 0xCE, 0x2E, 0x7B, 0xE3, 0x9F, 0x5D, 0xC0,
  0xD4, 0xF4, 0x01, 0xED, 0x6E, 0x57, 0x00, 0xAB, 0x4C, 0x42, 0xA7, 0x57,
  0xF3, 0x20, 0xD1, 0xF9, 0xA5, 0xF3, 0xCE, 0xBF, 0xE8, 0x57, 0x9F, 0x7D,
  0xD1, 0x6B, 0x3E, 0xFC, 0xCE, 0x8B, 0xDF, 0xFF, 0x6B, 0xCF, 0x7E, 0xEA,
  0xFB, 0xFF, 0x7A, 0xF5, 0x8A, 0xE7, 0xBC, 0xFE, 0x2D, 0x6F, 0x79, 0xEB,
  0xFB, 0xFE, 0xE6, 0x6F, 0xDE, 0xF1, 0x03, 0xCF, 0x7C, 0xDA, 0xC8, 0xFB,
  0x4F, 0xD8, 0xF4, 0xCA, 0x4F, 0x3E, 0xFB, 0x83, 0x7F, 0xFE, 0xEE, 0x17,
  0xBD, 0xE0, 0x05, 0xCF, 0x7F, 0xF6, 0xB3, 0x9E, 0xF7, 0xF4, 0x67, 0x3C,
  0xF7, 0x57, 0x3B, 0x0F, 0x92, 0xF9, 0x8B, 0xEE, 0x1B, 0x1D, 0x71, 0x4E,
  0x55, 0x46, 0xB2, 0x03, 0x52, 0x03, 0x75, 0x70, 0xA7, 0xC7, 0x22, 0xE4,
  0x11, 0x10, 0xC9, 0xC3, 0xB3, 0xE4, 0x0D, 0x2B, 0x1A, 0x8F, 0x24, 0xEE,
  0x12, 0xA8, 0x2A, 0xD3, 0x42, 0x33, 0x0B, 0xD9, 0x8C, 0x3C, 0x38, 0xFA,
  0x6D, 0x2E, 0x0E, 0x93, 0x99, 0xF4, 0x6A, 0x6E, 0x1D, 0xD8, 0x5B, 0x93,
  0x1D, 0xF8, 0xF7, 0xB7, 0x54, 0x6F, 0x6D, 0xE2, 0xBD, 0xAF, 0x21, 0x6B,
  0x0C, 0xD4, 0x7A, 0x59, 0xF6, 0x3A, 0x36, 0x70, 0xF1, 0xDA, 0x79, 0x71,
  0x90, 0x29, 0x51, 0xC5, 0x7A, 0x1F, 0x6E, 0xED, 0x3F, 0x38, 0xFA, 0xD5,
  0x51, 0x0C, 0xCF, 0x0B, 0x35, 0x4E, 0x7D, 0xB1, 0xF1, 0xE9, 0x0F, 0xEB,
  0x0E, 0xA5, 0x2F, 0x8B, 0x05, 0xE0, 0x40, 0x3C, 0x90, 0xF5, 0x29, 0x5F,
  0xFD, 0x1A, 0x79, 0x5A, 0xFA, 0x2F, 0x45, 0x0C, 0x3D, 0x9A, 0x7D, 0x35,
  0xAF, 0x61, 0x4F, 0xCC, 0x5F, 0x17, 0x0F, 0x92, 0xFE, 0x5E, 0xF9, 0xEE,
  0x37, 0x98, 0x35, 0xF2, 0xAD, 0x5F, 0xD4, 0x76, 0x29, 0x9F, 0x79, 0x42,
  0x92, 0xF3, 0xE6, 0x29, 0x80, 0xBA, 0x9E, 0x97, 0xBC, 0x0B, 0xFB, 0xF7,
  0xCE, 0xCC, 0xAD, 0x3F, 0x7E, 0x93, 0x46, 0x28, 0x73, 0x75, 0x70, 0x2E,
  0x8D, 0x24, 0x10, 0xEF, 0xAD, 0x1F, 0x0C, 0xFD, 0x52, 0xF3, 0xFF, 0x2E,
  0x1D, 0x50, 0xE4, 0x6F, 0xE8, 0x25, 0x19, 0x7E, 0xDD, 0xD5, 0x8B, 0x4F,
  0x7F, 0xF9, 0x74, 0xE9, 0x03, 0x56, 0x87, 0xCE, 0x5C, 0x87, 0x80, 0x13,
  0x8D, 0x62, 0xCD, 0x25, 0xF1, 0x7B, 0xE6, 0xCA, 0x3A, 0xB8, 0x28, 0x69,
  0xC7, 0xC0, 0xEF, 0xE7, 0x0F, 0x8A, 0xE7, 0x3F, 0x98, 0xE9, 0xE5, 0x6B,
  0x77, 0xFD, 0x81, 0xFB, 0xE3, 0x91, 0x6D, 0xEF, 0xBA, 0x50, 0x27, 0x20,
  0xD2, 0x5E, 0x24, 0x60, 0x99, 0xE5, 0x02, 0x40, 0x1D, 0x09, 0xF8, 0x60,
  0x92, 0xF6, 0xB9, 0x3C, 0xCB, 0xE3, 0x86, 0x5B, 0xB4, 0xCF, 0x88, 0x6A,
  0xFF, 0x8A, 0xE3, 0xDC, 0xB1, 0xDF, 0x2F, 0xF3, 0xFB, 0xD6, 0x32, 0xB3,
  0xFF, 0x25, 0x7F, 0x33, 0x58, 0xBC, 0xC0, 0x9D, 0x5D, 0xE7, 0x24, 0x1A,
  0xB0, 0x9A, 0x90, 0x64, 0xDB, 0xC7, 0x10, 0x4C, 0xC4, 0x1C, 0x11, 0x88,
  0x8F, 0x7B, 0x76, 0x9D, 0xF4, 0xA2, 0x66, 0x04, 0x18, 0xF8, 0xFE, 0xFB,
  0x86, 0x8F, 0xFD, 0x7E, 0xD4, 0x81, 0x4D, 0x3C, 0xFF, 0x6F, 0x87, 0xCE,
  0x69, 0xF1, 0xFC, 0xB9, 0x9E, 0x12, 0xA8, 0xD4, 0x26, 0x15, 0xCC, 0x04,
  0xF0, 0x63, 0x02, 0x38, 0xA2, 0xA6, 0xCC, 0x97, 0xDB, 0xEC, 0xE1, 0x97,
  0x46, 0x0D, 0x30, 0x31, 0x3C, 0x7F, 0xBC, 0xCA, 0x1D, 0xEB, 0xFD, 0x87,
  0xEC, 0xEA, 0x2D, 0x99, 0xFD, 0xC3, 0x7E, 0x7D, 0xCE, 0xC8, 0xDE, 0xEA,
  0x60, 0xBD, 0x19, 0x18, 0x02, 0x20, 0x1E, 0xC6, 0x84, 0x2C, 0x1E, 0x99,
  0xBB, 0xAE, 0xA8, 0xCE, 0xFA, 0xCA, 0xCC, 0x0A, 0x0F, 0x60, 0x3E, 0x94,
  0x3F, 0xCD, 0x05, 0x10, 0x71, 0x14, 0x8D, 0xE5, 0xD9, 0xB5, 0x49, 0xF0,
  0x12, 0xAA, 0xCA, 0x74, 0x32, 0x00, 0x60, 0x60, 0x08, 0xA8, 0x89, 0x4C,
  0xC2, 0x58, 0x3F, 0xFA, 0x6E, 0xE6, 0xFA, 0x97, 0xC2, 0xCC, 0x18, 0x00,
  0xC1, 0x37, 0xA6, 0xD5, 0x3D, 0x38, 0xE6, 0xAF, 0x73, 0x83, 0x37, 0xFD,
  0x79, 0x3D, 0x3F, 0xF7, 0xDC, 0xDB, 0x8B, 0x49, 0x35, 0x13, 0x40, 0xC5,
  0x0C, 0x01, 0x10, 0x04, 0x90, 0x05, 0xB1, 0xDD, 0x56, 0x14, 0x06, 0xD2,
  0x88, 0x00, 0xCC, 0xEB, 0xF3, 0x1F, 0x57, 0x3F, 0x38, 0xFA, 0xC1, 0xBE,
  0xFD, 0xD7, 0x36, 0x13, 0x7E, 0x71, 0xE7, 0xED, 0x6A, 0x20, 0x82, 0x99,
  0x39, 0xAF, 0x41, 0x00, 0x40, 0x0C, 0xB7, 0x68, 0xC3, 0x7F, 0xB8, 0x5E,
  0x30, 0x40, 0x47, 0xD5, 0x04, 0xCC, 0x67, 0x7F, 0xBC, 0x58, 0x1E, 0x24,
  0xF7, 0x7F, 0x6C, 0xFF, 0x00, 0x91, 0xF5, 0xA7, 0x1A, 0x6A, 0x00, 0x06,
  0xC4, 0xCB, 0x16, 0x77, 0x72, 0x03, 0x00, 0x83, 0x70, 0xFD, 0x94, 0xD3,
  0x0A, 0x01, 0xF5, 0x5D, 0x11, 0x03, 0x09, 0xED, 0x5F, 0xD8, 0xD7, 0x7D,
  0x90, 0xF4, 0xA7, 0x9E, 0x7E, 0x87, 0xAF, 0xCB, 0x32, 0x33, 0xE3, 0xE0,
  0xCB, 0xB6, 0x1D, 0xCD, 0x01, 0x11, 0x41, 0x00, 0xAA, 0xF2, 0xEC, 0x6F,
  0x5C, 0x58, 0x9B, 0x99, 0x40, 0x75, 0x56, 0x29, 0x66, 0x20, 0x76, 0xDA,
  0xB9, 0x73, 0xFA, 0xA0, 0xE8, 0x77, 0xB7, 0x42, 0xF8, 0xC7, 0x8F, 0x99,
  0x13, 0x0F, 0x26, 0x60, 0x54, 0xB1, 0x10, 0x44, 0x10, 0xC3, 0xAC, 0x0E,
  0x3B, 0xFE, 0x35, 0xB9, 0xB8, 0x76, 0xAA, 0x26, 0xF8, 0xAF, 0xF4, 0x83,
  0xA8, 0x19, 0xFB, 0x7B, 0x9B, 0xE0, 0x41, 0xD1, 0x3F, 0x35, 0xE2, 0xEA,
  0x22, 0xEA, 0xCA, 0xCC, 0xF0, 0x69, 0x2B, 0xC0, 0x40, 0xBC, 0x13, 0x00,
  0xC3, 0x30, 0xE8, 0x4D, 0x6D, 0x69, 0xA5, 0x52, 0x01, 0x98, 0x37, 0xD1,
  0x69, 0x89, 0x15, 0x58, 0x98, 0xCC, 0xC7, 0x0F, 0x8A, 0xFE, 0xCE, 0xDB,
  0xA4, 0x78, 0x37, 0x2F, 0xE5, 0xCA, 0x99, 0xD6, 0xDA, 0x8D, 0x2B, 0xCC,
  0x10, 0x10, 0x4C, 0xD5, 0xCC, 0x4C, 0x56, 0xAC, 0x7C, 0xF4, 0x35, 0x88,
  0x95, 0x3B, 0x55, 0xD0, 0xDA, 0xBC, 0x49, 0xDC, 0x33, 0x09, 0xC6, 0x5E,
  0x79, 0xFB, 0xCD, 0xF6, 0x20, 0xD8, 0xFF, 0xE7, 0xB7, 0xFD, 0x79, 0x2F,
  0xFF, 0x48, 0xE7, 0xB7, 0xE3, 0xCA, 0xE1, 0xCE, 0x9F, 0xB7, 0xE9, 0x09,
  0x03, 0x04, 0x0C, 0x64, 0x65, 0x7B, 0xC0, 0xFF, 0xDD, 0x16, 0x1E, 0x7E,
  0xD1, 0xFF, 0x7B, 0x60, 0x88, 0xE0, 0x09, 0xCE, 0x51, 0x47, 0x69, 0x16,
  0xCC, 0x21, 0xD4, 0x7F, 0x39, 0x6C, 0xC7, 0xFE, 0xF1, 0xDF, 0xAB, 0xB4,
  0xFF, 0x9E, 0xD5, 0xDB, 0x5F, 0xEA, 0xCC, 0xC0, 0x9D, 0x3D, 0x36, 0xE9,
  0xEA, 0xEE, 0xED, 0x87, 0xEA, 0x6D, 0x85, 0x33, 0xF9, 0x93, 0x9E, 0x3F,
  0x75, 0xE9, 0xEB, 0xD7, 0x3F, 0xE9, 0xC0, 0x32, 0x00, 0xCC, 0xA9, 0x6B,
  0x24, 0x52, 0x0B, 0xC2, 0x2B, 0xB2, 0xB5, 0xC7, 0xFA, 0xFA, 0xAF, 0xBB,
  0x94, 0xEF, 0x5A, 0x3A, 0xF3, 0x52, 0x6F, 0xBB, 0x45, 0x55, 0x2E, 0xFE,
  0xB7, 0x77, 0x8D, 0x8E, 0x2C, 0x3F, 0x73, 0x8D, 0x13, 0xD6, 0x9E, 0xB9,
  0x72, 0xA9, 0x18, 0x55, 0xE7, 0x92, 0x6A, 0x7D, 0x68, 0x77, 0xBF, 0x72,
  0xFB, 0xEC, 0x04, 0x13, 0x20, 0xBB, 0x1C, 0xDD, 0xC2, 0x62, 0x05, 0xDE,
  0x39, 0x51, 0x1C, 0xE3, 0xFD, 0xB2, 0xF7, 0x83, 0xE5, 0x3B, 0xC6, 0xA5,
  0xA3, 0xB0, 0x14, 0x38, 0x7B, 0x74, 0xA6, 0xFF, 0x32, 0x84, 0x85, 0x0F,
  0x3D, 0xE5, 0xE1, 0xCB, 0xB0, 0xA8, 0x06, 0x8C, 0xB1, 0x7E, 0x79, 0x7C,
  0x5B, 0xED, 0x9A, 0xFD, 0x13, 0x00, 0x4B, 0x4D, 0x5D, 0x5E, 0xA8, 0x54,
  0x6A, 0xF6, 0xA9, 0xED, 0xC5, 0xB1, 0xBD, 0xFE, 0xFB, 0xB7, 0xBF, 0xE1,
  0xCF, 0xC6, 0x9B, 0x7E, 0xFB, 0xCB, 0x54, 0x40, 0x23, 0xAA, 0xAB, 0xCA,
  0xF8, 0xBD, 0x33, 0x50, 0x47, 0x1C, 0xD2, 0x71, 0xAF, 0x5D, 0xF1, 0xFA,
  0x57, 0xFD, 0xE3, 0xE3, 0xF3, 0x41, 0x42, 0xBA, 0x64, 0x71, 0x04, 0x10,
  0x22, 0x49, 0x32, 0x29, 0x9C, 0xC3, 0x3F, 0xFF, 0x8C, 0xEC, 0x18, 0x9E,
  0xBF, 0x4E, 0xBE, 0xE1, 0x77, 0x86, 0x9B, 0xEC, 0x7A, 0xA9, 0x08, 0xE8,
  0xE9, 0x67, 0xEB, 0x5F, 0x1F, 0x90, 0xFE, 0xFE, 0x3B, 0xF3, 0x3B, 0x40,
  0xBB, 0x2D, 0x0B, 0xFE, 0xE3, 0xE3, 0xE2, 0x9B, 0x48, 0x29, 0x7B, 0x7A,
  0x13, 0x00, 0xDE, 0xC2, 0x44, 0x8F, 0x98, 0x60, 0xFC, 0xEF, 0x2B, 0xB7,
  0x1D, 0x93, 0xF3, 0x97, 0xBA, 0x9C, 0xB2, 0x61, 0x26, 0xF6, 0xAF, 0xCD,
  0xE3, 0xD1, 0xDD, 0x7F, 0x80, 0xA0, 0xF6, 0xF8, 0x2F, 0xFF, 0xFE, 0x13,
  0xA2, 0xEF, 0xC2, 0x95, 0x81, 0xBB, 0xCC, 0x87, 0x37, 0xFE, 0xDC, 0x8E,
  0x77, 0xF0, 0xD8, 0x53, 0xDF, 0x7B, 0xFE, 0x2B, 0x5F, 0xE3, 0xFD, 0xB5,
  0xBF, 0x55, 0x45, 0x00, 0x21, 0xB6, 0x66, 0x2C, 0x25, 0x83, 0xF9, 0xCB,
  0x86, 0x96, 0xCA, 0xB1, 0x36, 0x7F, 0xEB, 0xEF, 0xBC, 0xE5, 0xF6, 0xBF,
  0xFA, 0xAB, 0x89, 0x1D, 0xAF, 0x59, 0xA6, 0xFF, 0xEB, 0x9D, 0x75, 0xEC,
  0x34, 0x28, 0xF1, 0xAC, 0x3C, 0x9B, 0x66, 0x00, 0xEB, 0x70, 0x17, 0x59,
  0xFD, 0xC8, 0x85, 0x7D, 0xF8, 0xCA, 0x7B, 0xB6, 0xBD, 0xFC, 0x5F, 0x3E,
  0x72, 0x49, 0xBD, 0xF4, 0xDF, 0x7B, 0x35, 0x80, 0x57, 0x76, 0xF6, 0x88,
  0xDD, 0x5C, 0xF9, 0xFE, 0x77, 0xDC, 0x98, 0x1F, 0x5B, 0xF3, 0xB7, 0xF9,
  0xCE, 0xEC, 0xFB, 0x6D, 0x50, 0xFA, 0xD7, 0x9F, 0x76, 0x55, 0xF7, 0x2C,
  0xFF, 0x9C, 0x45, 0x2F, 0x38, 0xE5, 0x0A, 0xEC, 0x0C, 0x2E, 0xBF, 0xEA,
  0x80, 0xC9, 0x37, 0xE1, 0xEB, 0x2D, 0x00, 0x3A, 0x6D, 0xA0, 0xD3, 0x3C,
  0xE3, 0x15, 0xA7, 0x7F, 0xE2, 0x62, 0xE1, 0xD5, 0x8F, 0xFB, 0xE6, 0x1F,
  0x9E, 0x17, 0x5F, 0x72, 0x5A, 0x3C, 0x7E, 0xF2, 0xBE, 0xC5, 0x11, 0x00,
  0x2E, 0x64, 0x4D, 0x93, 0x8A, 0x81, 0x67, 0xAF, 0x5C, 0x2A, 0xC7, 0xCE,
  0xFC, 0x6D, 0xD7, 0x2F, 0x3F, 0xFB, 0xE5, 0x03, 0x83, 0x62, 0xD1, 0x29,
  0xD6, 0x3D, 0xC5, 0xCF, 0x0E, 0xD7, 0x5C, 0x61, 0xC0, 0x15, 0xA1, 0xDF,
  0xB8, 0xEC, 0x5B, 0xC8, 0x39, 0x49, 0x0D, 0xC0, 0x7F, 0xE6, 0xD7, 0x2F,
  0xBF, 0xED, 0xB8, 0xAB, 0xFE, 0x4D, 0x78, 0xF5, 0x63, 0x2F, 0x7D, 0x15,
  0xA7, 0xAD, 0x7E, 0xDE, 0x6E, 0xA9, 0xBE, 0xB7, 0xE3, 0xC6, 0x1D, 0x35,
  0x80, 0x52, 0x1E, 0x28, 0x35, 0xF2, 0x9D, 0xF7, 0xFD, 0xE1, 0x8D, 0xDB,
  0x8E, 0x9D, 0xF9, 0xE7, 0xB7, 0xFD, 0xF5, 0x77, 0x1F, 0x01, 0x52, 0xEC,
  0x5C, 0x72, 0xD3, 0x86, 0x36, 0xDF, 0xFD, 0x87, 0xDF, 0x56, 0x83, 0xC7,
  0x49, 0xF6, 0x27, 0x97, 0xA0, 0xC6, 0x39, 0x7F, 0x3A, 0x32, 0x2F, 0x00,
  0xFF, 0x99, 0xFF, 0x86, 0xAF, 0xFE, 0xCA, 0x5B, 0xDF, 0xF1, 0x3E, 0x7D,
  0xF9, 0x78, 0xFE, 0xC7, 0xF2, 0x9A, 0xA5, 0x16, 0x95, 0x3B, 0xAE, 0x17,
  0x84, 0x8D, 0x03, 0x02, 0x40, 0x38, 0xE3, 0xF2, 0x76, 0x22, 0x66, 0xAD,
  0x5F, 0x8E, 0x16, 0xAE, 0x91, 0x63, 0x63, 0xFE, 0x4D, 0x71, 0x69, 0x11,
  0xCA, 0x62, 0xE7, 0x86, 0xF6, 0xBA, 0x36, 0x9D, 0x91, 0xDF, 0xAE, 0x0D,
  0x3A, 0x6F, 0xD6, 0xDE, 0x17, 0x82, 0xCA, 0x39, 0x4F, 0x78, 0x83, 0x74,
  0xEE, 0xA8, 0xEF, 0x34, 0xE3, 0x4B, 0xEA, 0x11, 0xF6, 0xF1, 0x6B, 0xE3,
  0xE5, 0x96, 0xE7, 0x7C, 0x62, 0xA9, 0x8F, 0x25, 0x59, 0xF5, 0xC8, 0x58,
  0x9C, 0xDC, 0xF4, 0x9D, 0x39, 0xAB, 0x01, 0xAE, 0x70, 0x9D, 0x4E, 0x69,
  0xAE, 0xF7, 0xB7, 0x1F, 0xCA, 0xBF, 0xF9, 0xED, 0x6D, 0x8E, 0xFF, 0x0E,
  0x9E, 0x9F, 0x82, 0xFA, 0x95, 0xAF, 0xF9, 0xB3, 0xF0, 0x06, 0x00, 0x5E,
  0xF9, 0x9D, 0x95, 0x96, 0x98, 0x7B, 0xC8, 0xB7, 0xB6, 0xAF, 0xC5, 0xB2,
  0xB1, 0x8D, 0xB7, 0x82, 0x7D, 0x3F, 0x39, 0x29, 0x5B, 0x0B, 0xF5, 0xDF,
  0xBD, 0x3D, 0xED, 0x25, 0x0E, 0x80, 0x4E, 0x14, 0x2D, 0x3C, 0x01, 0xBE,
  0x31, 0xF5, 0xF6, 0x97, 0xFD, 0xFC, 0xC8, 0xF3, 0xFF, 0xED, 0xC4, 0x42,
  0xEA, 0x6A, 0x4D, 0x9F, 0x28, 0xD9, 0xE7, 0x24, 0xD8, 0x9E, 0xDD, 0xBD,
  0x7C, 0x08, 0x27, 0x26, 0x61, 0xF3, 0x4E, 0xE2, 0xA0, 0xDF, 0xBC, 0xEA,
  0x7B, 0x5F, 0xF9, 0xC0, 0x1B, 0xDF, 0xFA, 0x96, 0x07, 0xE6, 0xFC, 0xC3,
  0x48, 0xF7, 0x61, 0xFB, 0xBB, 0x00, 0x30, 0xFC, 0x82, 0xAD, 0x46, 0x72,
  0xE3, 0x67, 0xD6, 0x3E, 0x04, 0xF2, 0xAD, 0x25, 0xC0, 0x93, 0xFD, 0xBF,
  0x34, 0x66, 0xCB, 0xBA, 0xB6, 0xBF, 0xED, 0x75, 0x40, 0x81, 0xCE, 0xB2,
  0x7A, 0xE9, 0x43, 0x96, 0x0A, 0xD5, 0xE6, 0x9B, 0xB7, 0xB7, 0xFB, 0x4F,
  0x7D, 0xF5, 0xA9, 0x6B, 0x87, 0x73, 0x5D, 0xB6, 0x6F, 0xCE, 0xC9, 0x88,
  0x00, 0xB8, 0xC6, 0xBA, 0xC9, 0x6A, 0x27, 0x38, 0x27, 0x57, 0x94, 0x9D,
  0xB9, 0xA0, 0x65, 0x61, 0xEE, 0x43, 0xAF, 0xDB, 0x76, 0xFD, 0xAD, 0xC5,
  0x03, 0xB1, 0xBF, 0x58, 0xFC, 0x90, 0xE9, 0xB3, 0x97, 0x1B, 0x80, 0x04,
  0xCE, 0xD9, 0xB0, 0xF5, 0xF2, 0xD5, 0x9B, 0x52, 0xC1, 0x76, 0x2D, 0x37,
  0x38, 0xFD, 0xBC, 0x6E, 0xD3, 0x5F, 0x76, 0x05, 0x21, 0x18, 0x15, 0xED,
  0x8E, 0x03, 0xB4, 0xFF, 0xE8, 0xA5, 0x0A, 0x4E, 0x1E, 0x39, 0x78, 0xEB,
  0xFC, 0x79, 0xAF, 0x5B, 0x7C, 0xD2, 0xEC, 0xD0, 0x86, 0xE5, 0x7E, 0x68,
  0x51, 0x97, 0xC8, 0x19, 0x20, 0xC9, 0x36, 0xB7, 0x6D, 0x60, 0xF6, 0xDD,
  0xE0, 0x9C, 0x48, 0x39, 0x5F, 0x20, 0x65, 0x51, 0xD5, 0xEF, 0xFA, 0xF3,
  0x77, 0x5F, 0xF1, 0xED, 0x6D, 0xF6, 0x80, 0xEB, 0x1F, 0x6B, 0x8C, 0xAF,
  0x18, 0x05, 0x90, 0xCE, 0x75, 0x6F, 0xFA, 0x20, 0x37, 0xAF, 0x3B, 0xBD,
  0x2D, 0x80, 0xE6, 0x21, 0x33, 0xD6, 0x4C, 0xCD, 0xBC, 0xC8, 0xE9, 0x23,
  0x7F, 0xD5, 0xC1, 0x8A, 0x71, 0xA3, 0x6D, 0x1D, 0x71, 0x67, 0x2F, 0x55,
  0x10, 0x09, 0x6F, 0xB9, 0xB8, 0xFE, 0xC2, 0xEF, 0xDD, 0x78, 0x46, 0xC3,
  0xB7, 0x0D, 0x81, 0xC6, 0x6A, 0x73, 0x06, 0x86, 0x08, 0xCE, 0xCD, 0xCD,
  0x24, 0xFF, 0xFB, 0x2F, 0xA9, 0xD5, 0x89, 0x94, 0xDD, 0xD2, 0x4B, 0x5D,
  0xF5, 0xFB, 0x5B, 0xFF, 0xED, 0x5F, 0xDF, 0xFD, 0xCD, 0x5B, 0x8B, 0x07,
  0x58, 0xBF, 0xD5, 0x3E, 0xEA, 0x9B, 0x43, 0x76, 0xDE, 0xFE, 0x91, 0xBA,
  0x71, 0x7D, 0x2C, 0x00, 0x20, 0xEB, 0xB2, 0x2D, 0x72, 0xDE, 0xAD, 0x7D,
  0xBE, 0x4E, 0xE9, 0x36, 0x21, 0x62, 0x7D, 0x60, 0xBE, 0x31, 0xB2, 0x31,
  0x00, 0x56, 0xBF, 0xE5, 0xCD, 0x6D, 0xE6, 0xCF, 0xBF, 0xE5, 0x96, 0xDD,
  0x7C, 0xBF, 0xA1, 0x85, 0xA3, 0xBF, 0xB5, 0x5B, 0x56, 0xA9, 0x57, 0x89,
  0x55, 0xC4, 0xE3, 0xA4, 0x1A, 0x18, 0x7B, 0xE7, 0x7B, 0x5E, 0x59, 0x83,
  0x49, 0x31, 0x1F, 0xBC, 0xC3, 0xFF, 0xC5, 0xEF, 0x5E, 0x10, 0x7F, 0xF2,
  0x1D, 0x57, 0xEC, 0xCA, 0x1F, 0x48, 0xFD, 0x9A, 0x08, 0x75, 0xB3, 0x32,
  0xE6, 0xDF, 0xF9, 0x0F, 0xFD, 0xA4, 0x6A, 0x72, 0x90, 0x61, 0xDF, 0x9A,
  0x9B, 0xED, 0x4F, 0x88, 0x9C, 0x52, 0xBE, 0xE1, 0xEB, 0x67, 0xBE, 0x5E,
  0x8C, 0x4F, 0x1D, 0xD8, 0x35, 0x3D, 0xB4, 0x60, 0x89, 0x58, 0x1D, 0xDE,
  0xF2, 0xE6, 0xDF, 0x79, 0xC9, 0xF5, 0xD3, 0x32, 0xD4, 0x9D, 0xD9, 0xC3,
  0x72, 0x24, 0x37, 0x74, 0xD7, 0x82, 0xC6, 0xDA, 0xA5, 0xCF, 0x5C, 0x1E,
  0x69, 0xB6, 0x41, 0x0D, 0x15, 0xB1, 0x3C, 0x5D, 0xBD, 0x7A, 0xE3, 0x7B,
  0xFE, 0x00, 0x41, 0x24, 0xEF, 0x54, 0x2E, 0xBC, 0x61, 0xC7, 0x29, 0x6F,
  0xFD, 0xB9, 0x67, 0xFF, 0xC3, 0xDB, 0xB7, 0x7D, 0xBB, 0xB8, 0x1F, 0xFA,
  0xD5, 0x5C, 0x61, 0xC6, 0x3D, 0xC9, 0x56, 0xAB, 0xF5, 0xCD, 0x35, 0x6E,
  0x32, 0xB5, 0xEB, 0x2A, 0x0F, 0x80, 0x69, 0x98, 0x2B, 0x77, 0xFB, 0xA1,
  0x35, 0xFD, 0x31, 0x28, 0x6E, 0x74, 0xAF, 0xBC, 0x2C, 0x33, 0xB8, 0xD9,
  0x49, 0x6B, 0x78, 0xA1, 0xBE, 0xF0, 0xCD, 0x6F, 0xFB, 0xED, 0x9B, 0xFE,
  0xF8, 0x7D, 0xEF, 0x3C, 0xF9, 0xF8, 0xFA, 0x91, 0xBD, 0x7D, 0x46, 0xBC,
  0x4C, 0x2C, 0x9D, 0xBF, 0x4E, 0x86, 0xB4, 0xD7, 0x70, 0x8F, 0x49, 0x87,
  0x7E, 0xFE, 0xEC, 0x91, 0x20, 0xC1, 0xDC, 0xAF, 0xD6, 0x20, 0xC3, 0xAB,
  0x96, 0xBE, 0xCF, 0xE1, 0x10, 0xF2, 0x39, 0xEC, 0x7D, 0x57, 0xED, 0x79,
  0xF8, 0xE9, 0xAF, 0xF8, 0xE5, 0x0F, 0x7E, 0xEC, 0x8A, 0x5B, 0xF5, 0xE8,
  0xF5, 0x4B, 0x68, 0x4C, 0xCF, 0x37, 0xA6, 0xF7, 0x6E, 0xDB, 0xBE, 0x67,
  0xE2, 0xF6, 0x59, 0xE3, 0x1E, 0x36, 0x20, 0xFA, 0x42, 0x90, 0x9E, 0x28,
  0x8D, 0x43, 0xF9, 0xB3, 0x3B, 0x1B, 0x8D, 0xFD, 0x23, 0xE1, 0x40, 0x3F,
  0x32, 0x93, 0x1D, 0x97, 0x25, 0x5B, 0xFC, 0xE5, 0x35, 0x16, 0xB7, 0x3F,
  0xFE, 0xE1, 0xB7, 0xFD, 0xF9, 0xD0, 0x6B, 0x5E, 0xF7, 0xE1, 0x7D, 0xDF,
  0xFC, 0xC6, 0xA3, 0xCF, 0xB2, 0xE8, 0x3B, 0xBB, 0x02, 0x51, 0x37, 0xA1,
  0xB9, 0x72, 0xE3, 0xF9, 0xAB, 0x21, 0x11, 0xEB, 0x9D, 0xF4, 0x44, 0x87,
  0x47, 0x4C, 0x29, 0x15, 0xC0, 0xAD, 0x59, 0xF8, 0x17, 0x7F, 0x80, 0x81,
  0x48, 0x3F, 0xC8, 0xFF, 0xDA, 0xB9, 0x2D, 0x5D, 0xFD, 0xD0, 0x5F, 0xF9,
  0xCD, 0xBF, 0x79, 0xEF, 0x4D, 0xF9, 0x51, 0xEA, 0x37, 0x3F, 0x37, 0x7A,
  0xCA, 0x63, 0x1E, 0x7F, 0xDA, 0x05, 0xBF, 0x7C, 0xD1, 0x73, 0x9F, 0xFB,
  0x2B, 0xCF, 0x7E, 0xD2, 0x5E, 0xE5, 0x6E, 0xA4, 0x54, 0x62, 0xF1, 0x10,
  0x59, 0x7E, 0x92, 0x00, 0x68, 0xAF, 0x6A, 0x2D, 0xC9, 0xBE, 0x3D, 0xAC,
  0x67, 0x94, 0x04, 0x90, 0xFE, 0xA7, 0x92, 0xBF, 0x7F, 0xE9, 0x7F, 0xBC,
  0x27, 0x58, 0xEB, 0xAB, 0x6F, 0xFD, 0xC3, 0xD7, 0xBE, 0xF6, 0xFB, 0x4F,
  0x7D, 0xA2, 0x7B, 0x67, 0xE8, 0xCD, 0xF5, 0x66, 0xF0, 0x60, 0x4B, 0xC4,
  0x01, 0x7D, 0x11, 0x3A, 0x02, 0xC9, 0x46, 0x67, 0xDD, 0x52, 0x04, 0x83,
  0x19, 0x03, 0xB0, 0x68, 0xF9, 0xC9, 0x6F, 0x13, 0xCC, 0x09, 0x65, 0x61,
  0xFF, 0xCF, 0xDE, 0x9C, 0xE8, 0xAC, 0x95, 0xCF, 0x9F, 0x7B, 0xC7, 0x95,
  0xB7, 0xEA, 0x51, 0xE8, 0xF7, 0xF3, 0xC3, 0xFB, 0x9E, 0x78, 0x0A, 0x71,
  0x9A, 0x44, 0x02, 0xA1, 0x36, 0x3B, 0xA7, 0xA5, 0xDC, 0xCD, 0xBC, 0xE6,
  0x34, 0x33, 0x57, 0x68, 0x9F, 0x04, 0x4C, 0xBB, 0x45, 0xEC, 0xEC, 0x82,
  0xDF, 0xFC, 0xB8, 0x9D, 0x4E, 0xD7, 0x99, 0x13, 0xC3, 0xBF, 0x24, 0xC9,
  0xFE, 0xB0, 0x7A, 0xCB, 0xDE, 0xB3, 0x5E, 0x93, 0xB5, 0x5F, 0xEE, 0xA8,
  0x1A, 0xBF, 0xB7, 0x7D, 0xEB, 0x6D, 0x13, 0x37, 0x52, 0x63, 0x22, 0xC5,
  0x3C, 0xE4, 0x4C, 0x52, 0xF5, 0x33, 0xB3, 0xFE, 0x8D, 0x79, 0x74, 0xE5,
  0x75, 0x73, 0x1E, 0x1C, 0x48, 0xCE, 0x41, 0x6D, 0xF7, 0x1E, 0x04, 0xB0,
  0xBA, 0x5F, 0xBE, 0xE9, 0xF2, 0x02, 0x6B, 0x9F, 0xF1, 0x8A, 0xEC, 0x6F,
  0x5E, 0x7C, 0x59, 0xFD, 0x53, 0xEF, 0xAF, 0xF6, 0x3C, 0xE9, 0xE4, 0x0B,
  0x63, 0x2D, 0xBC, 0x84, 0xBA, 0xAE, 0x4B, 0x15, 0x97, 0x34, 0x6E, 0xEB,
  0x72, 0x37, 0xEE, 0x9B, 0xA1, 0x8E, 0x6E, 0x71, 0x4C, 0x81, 0x80, 0xE4,
  0x49, 0x64, 0xF6, 0xC2, 0x53, 0xC6, 0x7E, 0x0B, 0x5A, 0x86, 0x03, 0x37,
  0x98, 0x6D, 0x3D, 0xE7, 0xDC, 0xEC, 0x35, 0x17, 0xC9, 0xF9, 0xE7, 0xFD,
  0x3E, 0x57, 0x3D, 0x4A, 0xDB, 0xAF, 0xD8, 0xB0, 0x53, 0x15, 0x0C, 0x9C,
  0xAC, 0xBA, 0xA5, 0x89, 0xC9, 0x17, 0xB8, 0xC4, 0x35, 0x5D, 0x5D, 0xB4,
  0xB2, 0x20, 0x49, 0xA3, 0x16, 0x21, 0xC0, 0x33, 0x2B, 0x0E, 0x59, 0xBB,
  0xEC, 0xBD, 0xAE, 0x06, 0x8C, 0x72, 0xE0, 0xFD, 0x57, 0x1A, 0x64, 0xC7,
  0xFF, 0x6A, 0xB6, 0xFE, 0xEF, 0xBF, 0xB3, 0xED, 0xA7, 0xDD, 0xDF, 0x39,
  0x37, 0x32, 0x33, 0x5A, 0x89, 0x82, 0xB8, 0x24, 0x89, 0xA3, 0xC8, 0x3F,
  0xA6, 0xA8, 0x1C, 0x87, 0xF1, 0xCB, 0x42, 0x29, 0xE7, 0xEE, 0x84, 0x0C,
  0x00, 0x4B, 0xCD, 0xFD, 0xD6, 0xB2, 0xC1, 0x39, 0x63, 0x60, 0x56, 0xAC,
  0x15, 0xA7, 0x83, 0xD5, 0xAA, 0x85, 0xCA, 0x13, 0xE2, 0xB5, 0xA7, 0x9D,
  0xAC, 0xD7, 0x3D, 0x31, 0x49, 0x1E, 0xF1, 0x90, 0x7A, 0x05, 0x2A, 0x80,
  0xB9, 0x85, 0xCB, 0xB3, 0x25, 0x82, 0x34, 0x4E, 0xD8, 0x7A, 0x8E, 0x91,
  0x3A, 0x7F, 0xC3, 0x4A, 0xB7, 0x3D, 0xDB, 0x19, 0x89, 0x11, 0x04, 0x31,
  0xEE, 0xE0, 0x96, 0xBE, 0x3D, 0x02, 0xB0, 0xD3, 0xAA, 0xFA, 0x2F, 0x77,
  0x03, 0xF2, 0xF0, 0x57, 0x85, 0xFC, 0x63, 0xF9, 0xAD, 0x3F, 0xED, 0xF3,
  0xFF, 0x4E, 0x15, 0x9C, 0x78, 0x01, 0x10, 0x80, 0xCA, 0x3F, 0xA2, 0x1E,
  0xB8, 0x71, 0x81, 0xE7, 0x10, 0xF1, 0x89, 0x94, 0x29, 0xC7, 0xED, 0x1D,
  0x22, 0x13, 0x40, 0x48, 0x9F, 0x7F, 0x5C, 0x20, 0xAD, 0xCF, 0x28, 0x4D,
  0x88, 0x1A, 0x27, 0x5C, 0x75, 0xC3, 0xD2, 0x45, 0xDB, 0x4E, 0xBB, 0xEA,
  0x51, 0x29, 0x41, 0x1B, 0xFD, 0xD7, 0xD7, 0xDF, 0x5E, 0x3C, 0x35, 0xE2,
  0x54, 0xC0, 0xA0, 0x2D, 0x8D, 0x00, 0xD0, 0xA9, 0x3F, 0xBF, 0x0E, 0x74,
  0x47, 0xB9, 0xE1, 0xF3, 0xD1, 0xCA, 0xA9, 0xDC, 0xA0, 0x36, 0xC2, 0x8C,
  0x53, 0x0E, 0x72, 0x84, 0xB7, 0xBF, 0x5C, 0x80, 0x2B, 0x4E, 0xBF, 0xDC,
  0x3A, 0x9D, 0x36, 0xB0, 0x6C, 0xD7, 0x9F, 0xDA, 0x9F, 0xFD, 0xD1, 0xAD,
  0xAB, 0x7F, 0xAA, 0xF3, 0x5F, 0x65, 0xEA, 0xA2, 0x34, 0xB6, 0x4A, 0x04,
  0x30, 0xC3, 0xC4, 0x47, 0xE6, 0x37, 0x5C, 0x70, 0xE7, 0x85, 0x8A, 0x75,
  0xBA, 0xFB, 0xC4, 0xF1, 0xA6, 0x16, 0x37, 0x4D, 0x90, 0x03, 0x18, 0xDC,
  0xB8, 0x24, 0x20, 0x39, 0x03, 0x3D, 0x27, 0x6E, 0x74, 0xD0, 0x9F, 0x51,
  0x71, 0xCA, 0x89, 0x5B, 0x34, 0xD9, 0x04, 0x5F, 0xDD, 0xFC, 0x27, 0x27,
  0xF6, 0x2E, 0xDA, 0xD3, 0xDB, 0xBD, 0x54, 0x00, 0xD5, 0xE0, 0x1C, 0x19,
  0x66, 0x34, 0xD7, 0x45, 0xB7, 0x5D, 0x67, 0xAE, 0x3E, 0x99, 0x8D, 0xCB,
  0xD2, 0xED, 0xCE, 0xC4, 0x82, 0x80, 0x4C, 0x71, 0x27, 0x59, 0xFC, 0x5E,
  0x03, 0xE2, 0x2B, 0xCE, 0xA8, 0xFE, 0x70, 0x4F, 0x0E, 0xB0, 0xE4, 0x57,
  0x73, 0xF7, 0xFE, 0xDE, 0xB6, 0x9F, 0x6A, 0xFF, 0x6D, 0x92, 0x44, 0x1E,
  0x22, 0x33, 0xAB, 0x3A, 0x20, 0x86, 0x45, 0x75, 0x94, 0x5A, 0xFC, 0x9C,
  0xDD, 0x35, 0x00, 0xD1, 0xF8, 0xA6, 0x9F, 0x8B, 0x5D, 0xF2, 0xAE, 0xAF,
  0x2D, 0x5D, 0xF8, 0x37, 0x20, 0x00, 0x37, 0xBD, 0xD3, 0x01, 0xBD, 0x33,
  0x4A, 0x85, 0xB6, 0x2C, 0x25, 0x44, 0xEE, 0xFB, 0xB7, 0x2B, 0x42, 0xE3,
  0xF4, 0x0F, 0x8D, 0x9C, 0xC8, 0x99, 0x3C, 0x24, 0xC8, 0x1C, 0x70, 0xBC,
  0xA0, 0x6D, 0xCD, 0x41, 0x04, 0xE9, 0x6D, 0xD8, 0xB0, 0x71, 0xEB, 0x6D,
  0x1B, 0x8B, 0xAD, 0xB9, 0x7C, 0xDB, 0x10, 0xBC, 0x82, 0x7B, 0xA6, 0xE3,
  0x4E, 0xAE, 0x3D, 0xE4, 0x1C, 0x54, 0x5C, 0x2E, 0xEE, 0xE5, 0x07, 0x14,
  0x70, 0xA7, 0x3D, 0xDF, 0xE5, 0xEF, 0xCA, 0xF3, 0x9F, 0x66, 0x3F, 0x4D,
  0x00, 0x24, 0x92, 0x5E, 0x2F, 0x18, 0x16, 0xAA, 0xF9, 0x59, 0x9F, 0x21,
  0x26, 0xBF, 0x34, 0x2F, 0x30, 0x33, 0xBD, 0x6F, 0x43, 0x03, 0xFC, 0xC5,
  0xC7, 0x0D, 0xEB, 0x01, 0x6A, 0x01, 0x20, 0x37, 0x01, 0x9A, 0x74, 0x90,
  0x64, 0x01, 0x84, 0x8F, 0x2C, 0xFF, 0xFA, 0x15, 0xC7, 0x99, 0xDB, 0xB4,
  0xE5, 0x84, 0x33, 0x9A, 0x9E, 0x10, 0x6E, 0xF9, 0x7E, 0xBD, 0x23, 0x13,
  0x03, 0xA6, 0xF6, 0x59, 0xF2, 0xD5, 0xDC, 0x0C, 0x63, 0xE0, 0xB2, 0x62,
  0x66, 0xC9, 0x82, 0x79, 0x1F, 0xD5, 0x97, 0xDF, 0xE8, 0xC0, 0x24, 0x80,
  0xCA, 0xAC, 0x70, 0x27, 0x1B, 0xF9, 0x2B, 0x33, 0x40, 0x3C, 0xEE, 0xF6,
  0x09, 0x80, 0x6C, 0xC9, 0x2B, 0x4C, 0xDF, 0x75, 0x79, 0xF1, 0xD3, 0xBB,
  0xFF, 0x47, 0x87, 0x37, 0xA6, 0x22, 0x00, 0xF4, 0xF3, 0x46, 0x82, 0x54,
  0x79, 0xA5, 0x24, 0x45, 0x16, 0xFB, 0xF2, 0x73, 0x83, 0x72, 0xA0, 0xFC,
  0xF5, 0x8E, 0x37, 0x8A, 0xCF, 0x0E, 0x27, 0xC6, 0xAE, 0x77, 0x5A, 0x43,
  0x30, 0xF2, 0x5B, 0xFF, 0x6A, 0x89, 0xC0, 0xF4, 0xFF, 0xEA, 0x0F, 0x3B,
  0x6B, 0xFD, 0x47, 0xD4, 0x5C, 0x78, 0xE1, 0x05, 0x6C, 0x02, 0x6E, 0x7A,
  0x96, 0x17, 0x76, 0x55, 0x96, 0x2C, 0xC9, 0xE3, 0xF4, 0xD6, 0x46, 0xB4,
  0xF4, 0xDA, 0x6B, 0x34, 0x9A, 0x7B, 0xDD, 0x35, 0x0D, 0x31, 0x31, 0x72,
  0x6D, 0x02, 0x46, 0xFF, 0xDA, 0xAD, 0x8D, 0x18, 0x2C, 0x1F, 0x05, 0xFE,
  0x69, 0x59, 0xC4, 0x5D, 0x3A, 0x57, 0xBF, 0x2B, 0x00, 0x16, 0xB9, 0xF0,
  0xE6, 0x74, 0x2D, 0xC0, 0xB7, 0x3F, 0x28, 0x2C, 0xBC, 0xF0, 0x2C, 0xFB,
  0x69, 0xCD, 0x3F, 0xD4, 0x41, 0xCD, 0x0C, 0xB0, 0x6C, 0x38, 0x73, 0x4E,
  0xAC, 0x76, 0x5E, 0xBB, 0x79, 0x59, 0x95, 0xE1, 0xB9, 0xA3, 0xB7, 0xBE,
  0xF0, 0x0F, 0xE7, 0x96, 0x9A, 0xF5, 0xB7, 0xB6, 0x63, 0x43, 0x4C, 0x2A,
  0x40, 0x70, 0x0E, 0x2C, 0xF8, 0x7D, 0x3B, 0xC5, 0x65, 0x8D, 0x1B, 0xD7,
  0xAF, 0x59, 0xF0, 0xA9, 0xD6, 0x25, 0x9B, 0x9A, 0xB3, 0x5B, 0xB6, 0xC4,
  0x4E, 0x60, 0xD9, 0x2F, 0xAD, 0x59, 0x66, 0x37, 0xF6, 0xA6, 0x83, 0x08,
  0x93, 0x79, 0x36, 0xFB, 0x47, 0x95, 0x33, 0x03, 0xD0, 0x06, 0x18, 0x22,
  0xFE, 0xA6, 0xCA, 0x04, 0xC4, 0x0C, 0x4C, 0x3A, 0x1C, 0xA6, 0xB5, 0xA2,
  0xF2, 0x80, 0x50, 0xD5, 0x2F, 0x8E, 0x0B, 0x80, 0x53, 0xFF, 0x40, 0xD8,
  0xF7, 0x89, 0xED, 0xFC, 0x94, 0xFA, 0xC5, 0x86, 0x6B, 0x03, 0x0C, 0x00,
  0x92, 0x24, 0xF6, 0x62, 0xB2, 0x54, 0xCA, 0xA9, 0xA5, 0xD3, 0xCB, 0xF2,
  0xA7, 0xBE, 0xB6, 0xC5, 0x1A, 0xD1, 0xFC, 0x33, 0xFB, 0x1A, 0x40, 0xA8,
  0x88, 0x00, 0x33, 0x11, 0xA2, 0x6C, 0xA0, 0xF9, 0xE2, 0xD1, 0x78, 0x3C,
  0xCF, 0x8F, 0x2F, 0xBA, 0xDF, 0xDB, 0xFB, 0xD8, 0x73, 0xAE, 0x5C, 0x7F,
  0x56, 0x15, 0xBC, 0x03, 0xF8, 0x0E, 0x56, 0x9D, 0x38, 0xD4, 0x5E, 0xD2,
  0xE5, 0xEA, 0x1B, 0xFE, 0x68, 0xFF, 0xBA, 0x4B, 0xAC, 0x61, 0x86, 0x61,
  0x00, 0x82, 0xD9, 0xB7, 0x0B, 0xE1, 0x20, 0xEF, 0xE4, 0x99, 0xC2, 0x61,
  0x64, 0xE0, 0xCF, 0x6A, 0x21, 0xA6, 0xF6, 0x0C, 0x9E, 0x54, 0x00, 0x64,
  0x73, 0x26, 0x4C, 0x4D, 0x14, 0xFF, 0x6D, 0xFD, 0xE6, 0x84, 0x3B, 0xF8,
  0x38, 0x19, 0x45, 0x01, 0x50, 0x03, 0x89, 0x41, 0xBC, 0x9A, 0x66, 0xEB,
  0x4F, 0x38, 0xB3, 0xBD, 0xC9, 0x2D, 0x72, 0x20, 0x44, 0xFA, 0xB9, 0xA1,
  0x14, 0x40, 0x52, 0x00, 0xE8, 0x09, 0xF8, 0x66, 0xF6, 0xAD, 0x2B, 0x56,
  0x0E, 0x5E, 0xFC, 0xB5, 0xAF, 0xCC, 0x2C, 0x3F, 0xFE, 0xAA, 0xE0, 0xF9,
  0xFD, 0xB1, 0xCB, 0x3C, 0xB1, 0x01, 0x18, 0xEA, 0x12, 0x5C, 0x58, 0x3A,
  0xFE, 0xC8, 0xEE, 0x9F, 0x94, 0xE3, 0xBE, 0x5A, 0x50, 0x9A, 0x81, 0x01,
  0x60, 0x74, 0xF6, 0x66, 0x00, 0x20, 0x0A, 0xCE, 0xCD, 0x29, 0x87, 0x19,
  0x5C, 0x6A, 0xCE, 0x40, 0x88, 0xEC, 0x8A, 0x90, 0x03, 0x9C, 0x30, 0x6C,
  0xF0, 0xBE, 0x2B, 0xFF, 0x9B, 0xFA, 0x5D, 0x6F, 0xB8, 0x55, 0x34, 0x7A,
  0x7D, 0x05, 0x17, 0xA5, 0xE9, 0x82, 0xC5, 0x83, 0xA6, 0x06, 0x98, 0x00,
  0xB1, 0x03, 0x81, 0xD0, 0x7D, 0x7A, 0xBC, 0xB0, 0x19, 0xB7, 0x9A, 0x66,
  0x60, 0xDA, 0x5F, 0x1E, 0x3C, 0x00, 0xA1, 0x23, 0x60, 0x48, 0x48, 0xA6,
  0xD3, 0x5D, 0x6B, 0x8F, 0x7F, 0xE1, 0xA6, 0x8F, 0x5E, 0x32, 0xB1, 0xCF,
  0xAE, 0xB9, 0xF4, 0x75, 0x35, 0x9B, 0xFE, 0x78, 0x64, 0x7C, 0x8F, 0x30,
  0x2E, 0x00, 0x58, 0x1E, 0x1C, 0xD2, 0x0C, 0x19, 0x9E, 0xE8, 0xBB, 0x53,
  0x5F, 0xF8, 0xD3, 0x9B, 0x73, 0x33, 0xCD, 0xA5, 0x6F, 0x66, 0xDA, 0xB9,
  0x76, 0xAE, 0x12, 0x00, 0xA4, 0xAC, 0xEA, 0x50, 0xAB, 0x72, 0x18, 0x97,
  0xFC, 0x59, 0xE5, 0x2A, 0xE2, 0xDA, 0xB2, 0xB8, 0x28, 0x01, 0x46, 0x9F,
  0x21, 0x88, 0x1B, 0xC9, 0xF9, 0xC9, 0xFB, 0xA5, 0x3B, 0x3D, 0xD0, 0x5F,
  0x35, 0x7C, 0xDC, 0xCA, 0xD3, 0xBA, 0xAD, 0x5E, 0xA3, 0x95, 0x8D, 0x8F,
  0xFB, 0x1A, 0x14, 0xCC, 0xA4, 0x36, 0x00, 0x01, 0x61, 0xCD, 0x9A, 0xCF,
  0x36, 0x1C, 0x88, 0x82, 0xE2, 0x1C, 0xEF, 0x1A, 0x49, 0x01, 0xA8, 0xCD,
  0x40, 0xEA, 0x2B, 0x2F, 0xFF, 0xE2, 0xE0, 0x2F, 0xBC, 0x71, 0xF1, 0x70,
  0xE2, 0xD9, 0x17, 0xCA, 0xED, 0xD5, 0x35, 0x01, 0xDF, 0x9C, 0x9D, 0x2D,
  0x0B, 0xC7, 0xA2, 0x00, 0x20, 0x88, 0x02, 0xA2, 0xE9, 0x1C, 0x21, 0xD7,
  0xAD, 0xB7, 0xF8, 0xEE, 0xCE, 0x6E, 0x3F, 0x17, 0xF1, 0xC5, 0x7C, 0xE7,
  0x9A, 0x9B, 0xA7, 0x37, 0xD7, 0x95, 0x1A, 0x08, 0xA1, 0x0E, 0x16, 0x44,
  0x38, 0x5C, 0xA3, 0x9D, 0x41, 0x8C, 0xB8, 0xFC, 0x25, 0xAD, 0xD9, 0x02,
  0x30, 0xAF, 0x88, 0xFE, 0xD6, 0x9E, 0x9F, 0xBC, 0x3F, 0x4C, 0xE5, 0xE7,
  0x9D, 0xF0, 0x44, 0x86, 0xDB, 0x3E, 0x3A, 0x75, 0x70, 0xE3, 0xCA, 0xE1,
  0xB1, 0xD8, 0x7B, 0x50, 0x4C, 0x61, 0x7E, 0x7F, 0x0F, 0x04, 0x13, 0x8B,
  0xC7, 0x8B, 0x36, 0x0A, 0x88, 0x85, 0xBE, 0x81, 0x7B, 0xE5, 0x48, 0x06,
  0x00, 0xF9, 0xBE, 0x1B, 0xEA, 0xF9, 0xAF, 0x7F, 0xA5, 0x13, 0x35, 0xA7,
  0xEC, 0xEA, 0xD9, 0xD9, 0x7E, 0xBF, 0xDB, 0x6B, 0x0F, 0x1E, 0xBF, 0xA7,
  0xA3, 0x34, 0x5A, 0xB7, 0xEF, 0xFA, 0x73, 0x95, 0xE6, 0x39, 0x43, 0x06,
  0x80, 0x18, 0x40, 0x3A, 0xBD, 0xE8, 0x35, 0x3E, 0xCA, 0x7B, 0x93, 0xCA,
  0xA5, 0x57, 0x7B, 0x27, 0x22, 0xBE, 0x31, 0x7C, 0xD2, 0xE0, 0x9B, 0xDE,
  0xF1, 0xF9, 0x2A, 0x5F, 0x04, 0x86, 0x00, 0x50, 0x72, 0x37, 0xD5, 0x9B,
  0xCD, 0x20, 0x3E, 0x45, 0x92, 0xEE, 0x60, 0x01, 0xD8, 0xE2, 0x16, 0xB8,
  0xC1, 0x5C, 0x7F, 0xD2, 0xFE, 0xEE, 0xAD, 0xE7, 0x9D, 0x47, 0x08, 0xE2,
  0xD3, 0x38, 0xE0, 0x53, 0xA1, 0x74, 0x5E, 0x00, 0x33, 0xA7, 0x53, 0x73,
  0x3E, 0x80, 0x20, 0x26, 0x32, 0x8B, 0x53, 0x41, 0x42, 0xA8, 0x27, 0xC5,
  0xA9, 0x76, 0x37, 0x0D, 0x01, 0x80, 0x44, 0x4C, 0x7D, 0x7D, 0x4B, 0x99,
  0x39, 0xF2, 0xFE, 0x7C, 0x2F, 0x2F, 0xDA, 0xCF, 0x5E, 0xB7, 0x6E, 0x64,
  0xD1, 0x50, 0x3F, 0xE0, 0x5E, 0x93, 0xC9, 0x44, 0x11, 0x15, 0x7F, 0xD4,
  0x89, 0x0D, 0xC0, 0xA4, 0x09, 0x20, 0xF9, 0x8E, 0xC6, 0xE6, 0x33, 0xC5,
  0x2D, 0xB0, 0x2D, 0x72, 0x9B, 0x43, 0x30, 0xA3, 0x48, 0x27, 0x7F, 0x37,
  0xE8, 0x67, 0x3F, 0xBD, 0x07, 0x38, 0x1E, 0x30, 0xE3, 0xEE, 0x64, 0xA5,
  0x24, 0x40, 0x71, 0xF9, 0x19, 0xA2, 0x32, 0x07, 0xB0, 0xF8, 0x45, 0x20,
  0x91, 0x95, 0x3F, 0x61, 0xBF, 0xEF, 0xFD, 0x32, 0xA0, 0xDE, 0x67, 0xCD,
  0xF9, 0x7E, 0x32, 0x3E, 0x50, 0x8A, 0x73, 0x4E, 0x00, 0x0B, 0x84, 0xDC,
  0x51, 0x9B, 0x00, 0x02, 0x7E, 0x07, 0xF4, 0xEA, 0xA2, 0x5F, 0x31, 0x24,
  0xBD, 0x7E, 0xFE, 0xAE, 0x11, 0x03, 0x28, 0x6A, 0x37, 0xFE, 0xC6, 0x56,
  0x53, 0xD3, 0xD0, 0x8B, 0xD5, 0x27, 0xEF, 0x7B, 0xDF, 0xF6, 0xAC, 0xDE,
  0xBC, 0x78, 0xA4, 0x5D, 0x4E, 0x04, 0x89, 0xFA, 0xD2, 0xF9, 0x6A, 0xE8,
  0x47, 0xFF, 0x3C, 0xEF, 0x6F, 0xEB, 0x9A, 0x59, 0xFF, 0x06, 0x01, 0xE8,
  0x5B, 0xBE, 0x63, 0x34, 0xCB, 0x98, 0x52, 0xA3, 0x97, 0x0A, 0x66, 0xA6,
  0x5A, 0x3C, 0xFC, 0x9F, 0x9C, 0x44, 0xA8, 0x00, 0xEB, 0x80, 0xBA, 0xA5,
  0x1C, 0xCE, 0xE2, 0x14, 0x2A, 0x52, 0xF9, 0x3E, 0x3D, 0x5F, 0x15, 0x40,
  0x3A, 0x2B, 0x48, 0x14, 0xED, 0xF9, 0xC9, 0xFA, 0x43, 0xFB, 0xA9, 0x0D,
  0xA8, 0x4C, 0xB2, 0x6C, 0x5E, 0x06, 0xC6, 0x32, 0x27, 0x4E, 0xC4, 0x44,
  0xA2, 0xB8, 0xCE, 0xF0, 0x63, 0x51, 0x5D, 0x2B, 0x60, 0x20, 0xE9, 0x8A,
  0x5D, 0x6E, 0xCF, 0xFE, 0xAB, 0xAF, 0x9B, 0xAD, 0x67, 0x67, 0xF7, 0x48,
  0xB4, 0x50, 0x01, 0xEB, 0x4C, 0xEE, 0xDA, 0x7F, 0x42, 0xB7, 0x8E, 0xCB,
  0x7E, 0x7F, 0xE5, 0xB0, 0xB4, 0x5E, 0x9D, 0xA4, 0x5F, 0x39, 0x77, 0xA6,
  0x96, 0x48, 0x76, 0xE7, 0x6A, 0xF6, 0x8D, 0x30, 0x27, 0x06, 0xE3, 0xFB,
  0xA6, 0x4F, 0x9F, 0xE8, 0x59, 0xCF, 0x9F, 0x20, 0xA0, 0xB3, 0x11, 0xE4,
  0xAB, 0xA6, 0x0D, 0x65, 0x2C, 0xD9, 0x7C, 0x1D, 0x66, 0x66, 0x37, 0x98,
  0x16, 0xD7, 0x5C, 0xF6, 0xC6, 0x50, 0x56, 0xC0, 0x4D, 0xDB, 0xC1, 0x44,
  0x06, 0xB9, 0x1B, 0x1B, 0x34, 0x31, 0xE0, 0x14, 0x33, 0x63, 0x17, 0x80,
  0xF2, 0x93, 0x1F, 0xFF, 0xDA, 0xDC, 0x7A, 0xED, 0x85, 0xBA, 0xF6, 0x0D,
  0x37, 0xD9, 0x1F, 0x6A, 0x78, 0x6F, 0x26, 0x06, 0x42, 0xE4, 0xB4, 0xA7,
  0xA4, 0x0B, 0x16, 0x8E, 0x46, 0x09, 0x08, 0x46, 0xC4, 0xE0, 0xF5, 0x07,
  0xB6, 0x57, 0xF5, 0x6D, 0x9A, 0xDD, 0xBA, 0xE0, 0x86, 0x0F, 0xC4, 0x68,
  0xBE, 0x6B, 0xE2, 0xEA, 0x97, 0xBD, 0xE4, 0x99, 0x89, 0xE5, 0x9D, 0x5E,
  0xB1, 0x56, 0xC3, 0x13, 0x5E, 0xF2, 0x6B, 0x02, 0xA4, 0xD9, 0xD2, 0xF1,
  0xA9, 0x6B, 0x2D, 0x4A, 0xFC, 0xAE, 0x4B, 0x2F, 0x33, 0x8B, 0x1E, 0x9A,
  0xBA, 0xFD, 0x37, 0x6F, 0x6E, 0xD7, 0x03, 0x3B, 0x9B, 0xC1, 0xBA, 0xC5,
  0x36, 0x30, 0x33, 0x9C, 0x39, 0x3F, 0xD3, 0x62, 0xCE, 0xA0, 0xB6, 0x31,
  0x53, 0x4D, 0xFA, 0x8F, 0x7A, 0xD7, 0x9F, 0x1E, 0x8F, 0x80, 0x00, 0xC2,
  0x3D, 0x49, 0x11, 0x0B, 0x45, 0x7C, 0x65, 0xF5, 0x1A, 0x8D, 0x1D, 0x60,
  0x63, 0xC0, 0xEF, 0xD4, 0x3F, 0xD9, 0xCF, 0xBF, 0xC9, 0x9E, 0x88, 0xB2,
  0xA6, 0xE1, 0xE7, 0x2A, 0xDF, 0xF4, 0x1E, 0xA1, 0xF6, 0x06, 0x0E, 0x55,
  0x0D, 0x38, 0x91, 0xA6, 0x20, 0x62, 0x20, 0x24, 0xBB, 0x57, 0xD7, 0x69,
  0x00, 0xD9, 0x8A, 0x2F, 0xEA, 0x15, 0x33, 0xB7, 0xDE, 0x24, 0xAF, 0x43,
  0xAC, 0xD1, 0xAD, 0x4A, 0x60, 0xBD, 0x3B, 0xA1, 0x90, 0x8F, 0x7E, 0xDE,
  0x2B, 0x86, 0xA3, 0xF5, 0xD8, 0xAF, 0x79, 0x02, 0xB7, 0x68, 0x09, 0xD2,
  0xCA, 0x70, 0xBA, 0xC3, 0x2F, 0x76, 0xA7, 0xD2, 0xDB, 0x31, 0x22, 0x27,
  0x5E, 0xC7, 0x46, 0x31, 0xDD, 0xBC, 0x75, 0x7F, 0x56, 0x4F, 0x2E, 0xDD,
  0x7D, 0x72, 0x15, 0x45, 0x8C, 0x55, 0xB1, 0x7E, 0x02, 0x5E, 0xF3, 0xF6,
  0x9B, 0x63, 0xEE, 0x8D, 0x01, 0xA4, 0x28, 0xB0, 0x93, 0x43, 0xEC, 0xAF,
  0xDE, 0xFC, 0x13, 0xCC, 0xDF, 0xC5, 0xE9, 0xC4, 0x39, 0xBD, 0x9E, 0xC6,
  0x51, 0x79, 0xA0, 0x48, 0x52, 0xEF, 0x15, 0x11, 0x67, 0x02, 0x48, 0x15,
  0x02, 0xCE, 0x49, 0x2C, 0x08, 0x00, 0x86, 0x2C, 0xCA, 0x23, 0x9C, 0x08,
  0x1A, 0xAA, 0xEC, 0x84, 0x1D, 0xB7, 0xFF, 0xE6, 0x4B, 0xDF, 0x00, 0x56,
  0x16, 0x14, 0x79, 0x68, 0x2E, 0x5A, 0xBD, 0xAA, 0x20, 0x77, 0x7F, 0xF2,
  0xBB, 0xCF, 0x79, 0xDC, 0x7F, 0x08, 0x5A, 0xBC, 0x11, 0x2E, 0x39, 0x59,
  0xCA, 0x3A, 0x23, 0x69, 0x37, 0x08, 0xE6, 0x5C, 0xBD, 0x73, 0xC7, 0x6D,
  0x3B, 0x87, 0x56, 0x00, 0x6C, 0x94, 0x6B, 0xDD, 0x23, 0x08, 0x89, 0x46,
  0xD1, 0x96, 0xB5, 0x16, 0x51, 0x41, 0x5C, 0x25, 0x3B, 0xDE, 0xF0, 0x3A,
  0xFF, 0xEA, 0x12, 0x8C, 0x23, 0x2F, 0xEE, 0x0E, 0x50, 0x81, 0x38, 0x67,
  0x2B, 0x10, 0x00, 0x2C, 0x38, 0x59, 0xFC, 0xE3, 0xF6, 0x4B, 0xD5, 0x5A,
  0xB8, 0xE0, 0xF4, 0x52, 0xAD, 0xEE, 0x17, 0xFD, 0x28, 0x8B, 0x05, 0x05,
  0x33, 0x27, 0x02, 0x88, 0x51, 0x1B, 0x71, 0x0C, 0x22, 0x02, 0x20, 0x30,
  0xBF, 0x43, 0x61, 0xC3, 0x86, 0x15, 0x2B, 0x4E, 0x3B, 0x3D, 0x1A, 0xF8,
  0xBD, 0xD7, 0x8F, 0x8F, 0x2A, 0x90, 0xD8, 0xC8, 0xBA, 0xCD, 0xE7, 0x3D,
  0x62, 0x33, 0x80, 0x6C, 0x78, 0xE8, 0x43, 0xCE, 0x7D, 0xDC, 0x13, 0x91,
  0x78, 0x78, 0xD3, 0x26, 0x5E, 0xB2, 0xA5, 0x02, 0x32, 0x3B, 0x33, 0x06,
  0x1B, 0x73, 0x71, 0xE4, 0x16, 0x2E, 0x63, 0x34, 0x02, 0xB9, 0xCE, 0x4E,
  0xB2, 0x7C, 0x6E, 0x5E, 0x3D, 0x92, 0x5E, 0x57, 0x43, 0x0C, 0xD5, 0xEC,
  0x64, 0xA3, 0x36, 0x54, 0x11, 0x43, 0x8E, 0xD4, 0xAF, 0x16, 0x03, 0xC0,
  0x69, 0xCC, 0x33, 0x1C, 0x40, 0x26, 0x31, 0xDD, 0xED, 0x1B, 0x3F, 0x66,
  0xBF, 0x4F, 0x86, 0x06, 0x25, 0x8B, 0x2B, 0x5C, 0x7B, 0x78, 0x64, 0x7C,
  0x40, 0xF2, 0x12, 0x03, 0x13, 0x44, 0x00, 0x87, 0xC4, 0x81, 0x83, 0x82,
  0x0A, 0xFD, 0x19, 0x15, 0x87, 0xAB, 0xCA, 0x7E, 0x7B, 0xF1, 0xF2, 0x66,
  0x6B, 0x30, 0xE2, 0x90, 0xFC, 0x8C, 0x47, 0xC5, 0xAB, 0x0C, 0x1C, 0x5B,
  0x4A, 0x97, 0x83, 0x19, 0x50, 0x76, 0xC6, 0x46, 0x87, 0xB6, 0x18, 0x51,
  0x84, 0x9D, 0x99, 0x3A, 0xD0, 0xC9, 0x85, 0x4B, 0x97, 0xAF, 0x1D, 0x1A,
  0x5C, 0x30, 0xB6, 0x54, 0x6E, 0xE0, 0x44, 0x0D, 0x1A, 0xE2, 0x34, 0x51,
  0x8B, 0x63, 0x89, 0x01, 0x88, 0x17, 0xB4, 0xDB, 0x7B, 0x22, 0xE7, 0x38,
  0x48, 0x70, 0xA1, 0xE4, 0xEE, 0xAA, 0x0F, 0x70, 0x90, 0x56, 0x20, 0x50,
  0x3A, 0x6C, 0xF7, 0x87, 0x16, 0xD8, 0x8F, 0xD7, 0x5F, 0x65, 0x63, 0xC3,
  0x96, 0x26, 0x1B, 0xD3, 0xC1, 0x81, 0x38, 0x72, 0x92, 0xB6, 0x07, 0xA2,
  0xA2, 0xCE, 0xC0, 0x39, 0x33, 0x30, 0x81, 0xBC, 0x0C, 0x20, 0x08, 0x2E,
  0xB7, 0x79, 0xDF, 0x74, 0x16, 0x51, 0x56, 0x63, 0xE9, 0xAC, 0x61, 0x77,
  0x8E, 0x48, 0xFA, 0x7F, 0xF9, 0x3B, 0x4F, 0x5A, 0x2B, 0x20, 0xB8, 0x53,
  0x5B, 0x2E, 0x12, 0xEC, 0x31, 0x10, 0xAA, 0x9D, 0x43, 0x03, 0x1E, 0x8B,
  0x0D, 0x53, 0x27, 0x00, 0xF5, 0xBE, 0x2A, 0x92, 0x54, 0x3A, 0x73, 0x2C,
  0x3B, 0x7D, 0x23, 0x66, 0xEA, 0xB7, 0x94, 0x2A, 0x3E, 0x4D, 0xDC, 0x8D,
  0x00, 0x98, 0xD5, 0x27, 0xE1, 0x7C, 0x12, 0x8C, 0x83, 0x7C, 0xBF, 0xE4,
  0x70, 0x52, 0x91, 0x13, 0x03, 0xE0, 0xD8, 0x01, 0x60, 0x9F, 0xD0, 0xDA,
  0x5A, 0x2D, 0x7E, 0xAC, 0xFE, 0x78, 0xC9, 0xA2, 0xCC, 0x25, 0x89, 0x5D,
  0x1F, 0x04, 0x70, 0xDE, 0x49, 0x32, 0x38, 0x24, 0xD3, 0xBD, 0x1A, 0x07,
  0x02, 0x02, 0x98, 0x82, 0x09, 0x26, 0x52, 0x18, 0x33, 0x4A, 0x73, 0xF1,
  0x92, 0x05, 0xED, 0x1A, 0x53, 0x04, 0x54, 0x15, 0xE9, 0x57, 0xEF, 0x1A,
  0x8B, 0x27, 0xC5, 0x40, 0x4A, 0x6F, 0x86, 0x83, 0x2C, 0x4E, 0xAC, 0x32,
  0x95, 0x7C, 0x6A, 0x53, 0xE3, 0x11, 0x8F, 0x7F, 0xF8, 0xE6, 0x27, 0x2C,
  0x88, 0x11, 0x83, 0xDA, 0x15, 0xFD, 0xAF, 0x86, 0xA0, 0xD1, 0xD0, 0xB2,
  0xA5, 0xCB, 0xDB, 0x37, 0xB1, 0x23, 0x50, 0x45, 0x49, 0x64, 0x62, 0x00,
  0xD4, 0xC4, 0xE1, 0x4D, 0xBF, 0x95, 0x9F, 0x2D, 0x62, 0x00, 0x60, 0xDC,
  0x9D, 0xED, 0x8A, 0x07, 0x01, 0xE0, 0x4A, 0x08, 0x18, 0x4C, 0xCE, 0x6B,
  0x40, 0xE5, 0xC7, 0xEA, 0x8F, 0x86, 0x06, 0x7D, 0xE4, 0x1A, 0x3E, 0x4A,
  0xD6, 0x2B, 0xE2, 0x80, 0xE5, 0x42, 0x34, 0x20, 0xFB, 0xF7, 0xE7, 0x0E,
  0x51, 0x44, 0x04, 0x6A, 0xAD, 0x10, 0x00, 0xA1, 0xAD, 0x83, 0x82, 0x64,
  0xED, 0x05, 0xD9, 0xE0, 0x88, 0x13, 0x53, 0x35, 0xA7, 0x66, 0xFD, 0xF7,
  0xFE, 0xED, 0x86, 0xD6, 0x81, 0x4F, 0x1A, 0x88, 0x35, 0x11, 0x20, 0xE7,
  0x86, 0x76, 0x0F, 0x3B, 0x60, 0xD4, 0xAF, 0x93, 0x47, 0x0D, 0x35, 0x16,
  0x2E, 0x6F, 0x39, 0xC1, 0x30, 0x2D, 0x6F, 0xF8, 0xF2, 0xA7, 0x6F, 0xFF,
  0xBB, 0xBF, 0xFB, 0xFB, 0x8F, 0xFE, 0x7D, 0xB1, 0x40, 0x96, 0xB7, 0xA4,
  0xF2, 0x51, 0x52, 0x16, 0xB5, 0xE8, 0x46, 0x00, 0x22, 0x68, 0x36, 0x1F,
  0xF5, 0x77, 0x23, 0x29, 0x98, 0x22, 0x20, 0xDC, 0xC3, 0xF8, 0x30, 0x07,
  0xA9, 0x46, 0xCC, 0x38, 0x64, 0x9E, 0x5A, 0x3E, 0x54, 0xF2, 0xE3, 0xDC,
  0xFE, 0x85, 0xC1, 0x66, 0x12, 0xAA, 0x38, 0x91, 0xD1, 0xC9, 0x6B, 0x86,
  0x06, 0x9C, 0x60, 0x4C, 0x00, 0xD2, 0xEE, 0x77, 0x67, 0x32, 0xD0, 0x08,
  0x11, 0xCB, 0xAA, 0x00, 0x60, 0x58, 0x5C, 0xFA, 0x0C, 0x30, 0xC1, 0xD6,
  0xDD, 0x68, 0x63, 0x56, 0x88, 0x64, 0x50, 0xCA, 0x5F, 0x2E, 0x4C, 0x21,
  0x36, 0x00, 0xC3, 0x00, 0xCC, 0x95, 0x1F, 0x3D, 0xB7, 0x56, 0x15, 0x37,
  0xFE, 0x9D, 0x15, 0x91, 0x88, 0x38, 0x10, 0x13, 0xB3, 0xDA, 0xF7, 0x66,
  0x5B, 0x00, 0xFD, 0xF9, 0x7F, 0x4E, 0x9F, 0x3B, 0xFB, 0xC8, 0x03, 0x4E,
  0x84, 0x46, 0xDD, 0x6D, 0xD9, 0x96, 0x13, 0x80, 0x3A, 0x42, 0x38, 0xE9,
  0xB2, 0x53, 0x5B, 0xB5, 0x89, 0x39, 0x31, 0x11, 0xE3, 0xEE, 0x8A, 0x3C,
  0x0E, 0x62, 0x00, 0x62, 0x8C, 0x0C, 0x41, 0x7F, 0x5B, 0x19, 0x24, 0x5A,
  0xC5, 0x8F, 0x33, 0xFF, 0xC6, 0x78, 0x12, 0xB0, 0x54, 0x60, 0x2C, 0x9E,
  0x37, 0x00, 0x10, 0xB0, 0x7A, 0xF1, 0xFA, 0xA0, 0x86, 0xAA, 0x22, 0x94,
  0xB5, 0x81, 0x99, 0x81, 0x4B, 0x0D, 0x30, 0x01, 0x98, 0xDA, 0x19, 0x4A,
  0xC1, 0xFA, 0x45, 0x69, 0x7F, 0xB1, 0x30, 0x05, 0xD9, 0x61, 0x80, 0xA8,
  0x88, 0x00, 0xD7, 0xA7, 0xFA, 0x4C, 0xB3, 0x49, 0x31, 0xEA, 0x34, 0x71,
  0x22, 0x88, 0x60, 0x62, 0x05, 0xD4, 0x8F, 0x8F, 0x00, 0x68, 0x34, 0xF2,
  0x62, 0xAA, 0x91, 0x9A, 0x00, 0x69, 0x4B, 0x7A, 0x1B, 0x37, 0x03, 0x44,
  0x98, 0xD8, 0xE0, 0x49, 0x53, 0x99, 0x61, 0x00, 0x98, 0x70, 0x77, 0x55,
  0x94, 0xCE, 0x43, 0x0C, 0x50, 0x79, 0x0A, 0x38, 0xF0, 0x8A, 0x5A, 0xDE,
  0xB0, 0xC4, 0xFD, 0x38, 0xFD, 0x3E, 0x32, 0xEF, 0x0D, 0xAF, 0x40, 0xC6,
  0xAC, 0x82, 0x08, 0x60, 0xF5, 0x6C, 0x67, 0x42, 0x02, 0x04, 0x33, 0x13,
  0x44, 0x83, 0x55, 0x94, 0x65, 0xA1, 0x86, 0x9A, 0xAA, 0xA9, 0x99, 0x6E,
  0xCF, 0xE2, 0x7C, 0x6E, 0x6E, 0x2E, 0x9E, 0xDB, 0xD6, 0xF9, 0xF2, 0x92,
  0x14, 0xB0, 0xE5, 0xDC, 0x39, 0x7F, 0xE3, 0xF8, 0x5B, 0x9E, 0x92, 0x97,
  0xA0, 0x20, 0x80, 0x18, 0x1C, 0x0C, 0x85, 0xF0, 0x85, 0x56, 0xBF, 0x0F,
  0x40, 0xC6, 0xBF, 0x15, 0x5F, 0x14, 0x43, 0x23, 0xEF, 0x9B, 0x7A, 0xE5,
  0x35, 0x00, 0x20, 0x56, 0x30, 0x38, 0xB6, 0xB4, 0xC6, 0x54, 0x55, 0x30,
  0xE3, 0x6E, 0xB6, 0x85, 0x26, 0x15, 0x02, 0xA0, 0xF6, 0xBC, 0xE9, 0x35,
  0xE4, 0xDD, 0x30, 0xF1, 0xC6, 0x24, 0xE3, 0xC7, 0xE9, 0x8F, 0x87, 0x22,
  0xE1, 0xC4, 0xCD, 0x8B, 0x04, 0x58, 0x90, 0x75, 0x7B, 0x06, 0x22, 0x86,
  0x76, 0xAB, 0xFD, 0x3D, 0x8F, 0x88, 0x1A, 0x38, 0x22, 0x97, 0x97, 0x55,
  0xAF, 0xAA, 0x8A, 0xCE, 0xFC, 0xDC, 0x0F, 0x5E, 0xE6, 0xE7, 0xE6, 0xE6,
  0x3B, 0x73, 0x73, 0xE2, 0x6E, 0x9E, 0xED, 0xCE, 0xEF, 0xE8, 0xA4, 0x73,
  0xD7, 0xD4, 0x00, 0x08, 0x00, 0x76, 0x30, 0x96, 0xB5, 0x56, 0x57, 0x82,
  0x70, 0xD7, 0x10, 0x0D, 0x13, 0x5C, 0x3C, 0x10, 0xFB, 0x21, 0xD7, 0x07,
  0x80, 0x7D, 0x9F, 0x01, 0x20, 0x12, 0x89, 0x1B, 0xB6, 0x09, 0x40, 0x30,
  0xBC, 0x92, 0xF6, 0xD7, 0x04, 0x70, 0x86, 0x06, 0xE1, 0x70, 0x45, 0x32,
  0x29, 0x9A, 0x62, 0x50, 0xA9, 0xB3, 0xE3, 0x57, 0x8B, 0x4E, 0xBC, 0xA4,
  0x7C, 0x4B, 0x73, 0x35, 0x20, 0xCE, 0xFE, 0x8B, 0xFD, 0x21, 0x16, 0x0F,
  0xD7, 0x5C, 0xBF, 0x77, 0x01, 0x30, 0x13, 0x65, 0xD3, 0x1D, 0x30, 0xB0,
  0x22, 0xAF, 0x43, 0x82, 0x8B, 0xCC, 0xCC, 0x70, 0xE0, 0xCA, 0x02, 0x89,
  0xE2, 0x34, 0xF5, 0xE6, 0x06, 0x06, 0x07, 0x87, 0x87, 0x06, 0xDA, 0x43,
  0x5E, 0x92, 0x85, 0x89, 0x45, 0x3E, 0x6D, 0xB4, 0x7E, 0x7B, 0x0F, 0x00,
  0x43, 0x02, 0xA8, 0x99, 0x09, 0x20, 0x32, 0x50, 0x89, 0x61, 0x1C, 0x64,
  0x66, 0x00, 0x06, 0x52, 0x8F, 0x2F, 0x6E, 0x2E, 0xC8, 0xBB, 0x00, 0xDD,
  0xAA, 0x38, 0x91, 0xD9, 0x38, 0x4A, 0x04, 0xFC, 0x69, 0x06, 0x82, 0x21,
  0x50, 0x29, 0x9B, 0xCD, 0x6A, 0x21, 0xF4, 0x6B, 0x2B, 0xB2, 0xD1, 0x9A,
  0x3B, 0xB8, 0xA2, 0x5E, 0x4B, 0xD5, 0x03, 0x2A, 0xA0, 0xFD, 0xAC, 0x71,
  0x99, 0x78, 0xE1, 0x7B, 0xFF, 0xF6, 0xA4, 0x25, 0x14, 0xDD, 0xF9, 0xDD,
  0x03, 0x43, 0xE1, 0xBF, 0xD6, 0xAF, 0xC3, 0xE2, 0x40, 0x4F, 0x00, 0x80,
  0x28, 0xCD, 0xA6, 0xF7, 0x57, 0xA6, 0xA1, 0x0C, 0x03, 0x99, 0xC7, 0xD2,
  0x04, 0x02, 0x20, 0x6A, 0x12, 0xC7, 0x8D, 0x34, 0x89, 0x93, 0x5A, 0x8A,
  0x42, 0x04, 0x11, 0x24, 0x6D, 0x4A, 0x27, 0xF6, 0x82, 0x49, 0x6A, 0x11,
  0x00, 0xD1, 0xD3, 0x0D, 0x68, 0x00, 0x80, 0x2B, 0xFE, 0xB5, 0x04, 0xE5,
  0x2E, 0xC2, 0x41, 0x22, 0xD9, 0x48, 0xB2, 0xAA, 0x9B, 0xF4, 0xFA, 0x14,
  0x6E, 0xEB, 0xB7, 0xAF, 0xBF, 0xB6, 0x2F, 0x62, 0x86, 0x73, 0x06, 0x06,
  0x62, 0xE0, 0xAA, 0x3C, 0x0C, 0x96, 0x98, 0x14, 0x5A, 0x54, 0xC5, 0xA3,
  0x56, 0xCC, 0x73, 0x07, 0xF1, 0xAB, 0xC1, 0xAA, 0x92, 0x0A, 0x75, 0xC9,
  0xC8, 0x92, 0x64, 0xA6, 0xFB, 0xC1, 0x45, 0xAB, 0x07, 0x5D, 0xB4, 0xA8,
  0x7B, 0xEA, 0x59, 0xA3, 0x2B, 0x76, 0xDB, 0x7F, 0xA9, 0xBF, 0x25, 0xCE,
  0x1B, 0xEE, 0x06, 0xF6, 0x02, 0xE0, 0xE2, 0x66, 0x35, 0xB1, 0x7B, 0xDF,
  0xFE, 0x7D, 0xFD, 0x06, 0xCE, 0xB2, 0x34, 0x12, 0x09, 0x80, 0xD3, 0x58,
  0x04, 0x40, 0xCC, 0xD2, 0xB4, 0x2A, 0xD4, 0xCC, 0x08, 0xF3, 0xF8, 0x7E,
  0xEE, 0x5C, 0xDC, 0x4C, 0xB0, 0x4A, 0x00, 0xD2, 0x71, 0xC0, 0x72, 0x04,
  0x00, 0xD3, 0x60, 0x06, 0x18, 0x87, 0x18, 0x87, 0x94, 0x2E, 0x1E, 0x1A,
  0x5A, 0x2A, 0x23, 0x03, 0x5D, 0xF5, 0xFD, 0x6B, 0xBF, 0x21, 0x92, 0x9B,
  0x8A, 0xB0, 0xCD, 0x10, 0x44, 0x10, 0x0C, 0x27, 0xAC, 0xF5, 0x10, 0xC5,
  0x49, 0x16, 0xA5, 0xA1, 0x5A, 0xE3, 0x38, 0x44, 0x5B, 0xC0, 0x9E, 0x69,
  0x03, 0x4D, 0x89, 0x7F, 0x65, 0x55, 0xF0, 0x2B, 0xD7, 0x0E, 0x0B, 0xB8,
  0xC6, 0x99, 0x16, 0xB9, 0xFE, 0xF6, 0x99, 0x38, 0xB2, 0xFB, 0x7E, 0xFB,
  0xD7, 0x39, 0x4E, 0xC5, 0xEB, 0xE6, 0x6B, 0x61, 0x5C, 0x19, 0x9E, 0x16,
  0x2F, 0x2E, 0x94, 0xC1, 0xAA, 0x4E, 0xCF, 0x25, 0xD9, 0x68, 0x3F, 0x4E,
  0x72, 0x05, 0xE7, 0x03, 0x55, 0x5C, 0x03, 0xA8, 0x96, 0xBE, 0xAF, 0x7D,
  0x31, 0x35, 0x2D, 0x09, 0x4D, 0x83, 0xBA, 0xF6, 0xA9, 0x4F, 0xC5, 0x00,
  0xB7, 0x53, 0x80, 0x1A, 0x03, 0x40, 0xCE, 0x08, 0x00, 0x88, 0x71, 0x90,
  0x18, 0x26, 0x00, 0x29, 0xDE, 0xB3, 0xAE, 0xB7, 0x77, 0x77, 0xE6, 0xCB,
  0xAC, 0x2F, 0xDE, 0x69, 0x1D, 0xA9, 0x98, 0x81, 0x1D, 0xB6, 0xCE, 0x69,
  0xE5, 0xE6, 0xCA, 0xC4, 0x63, 0xF4, 0xB7, 0x8E, 0x44, 0x1C, 0x64, 0x00,
  0xD1, 0x42, 0x01, 0x57, 0x35, 0x16, 0x2D, 0x11, 0x0E, 0xD1, 0xD9, 0x66,
  0xA8, 0x23, 0x77, 0x51, 0x7A, 0xDC, 0xA5, 0x7B, 0xEA, 0xE8, 0x3E, 0xCE,
  0x5F, 0xA6, 0x01, 0xB7, 0xE2, 0xFA, 0x52, 0xD9, 0x3F, 0xC5, 0x34, 0x88,
  0xF8, 0xA4, 0xD5, 0x68, 0x0C, 0x8D, 0x0F, 0x8D, 0x2C, 0x6D, 0xF4, 0x1B,
  0x64, 0x50, 0x56, 0x45, 0x45, 0x55, 0x4C, 0x16, 0xFD, 0x6E, 0xA7, 0xD3,
  0xAD, 0xFB, 0xBD, 0x5E, 0x51, 0xE4, 0x45, 0x55, 0x05, 0x3F, 0xD3, 0x53,
  0xA5, 0x19, 0x47, 0xA1, 0x47, 0xAF, 0x04, 0xB0, 0xD6, 0x85, 0x86, 0xC4,
  0x06, 0xD0, 0xB7, 0xF4, 0x6A, 0x03, 0x27, 0x18, 0x08, 0xC0, 0x5D, 0xEF,
  0x14, 0x20, 0x89, 0x6B, 0x2E, 0x1F, 0x5A, 0x2E, 0xBD, 0xD2, 0x9B, 0xE1,
  0x2B, 0x4C, 0x03, 0x20, 0x00, 0x02, 0x86, 0xC4, 0xD6, 0xC0, 0x99, 0x01,
  0x26, 0x66, 0x15, 0x87, 0x29, 0x3A, 0x3E, 0xAE, 0xB0, 0x24, 0x79, 0xF9,
  0x6A, 0xEE, 0x50, 0x87, 0xB9, 0x6E, 0x3E, 0x8D, 0x95, 0xEE, 0xC2, 0x73,
  0x27, 0xEA, 0xFB, 0x38, 0x7F, 0x43, 0x9D, 0xB9, 0x89, 0x34, 0xAF, 0x63,
  0x13, 0x40, 0x4C, 0x0C, 0x11, 0xC1, 0x01, 0x8D, 0x5E, 0x47, 0x89, 0x8A,
  0x60, 0x18, 0x24, 0x55, 0xE9, 0x0C, 0xB0, 0x3A, 0x0E, 0xE6, 0x04, 0x0C,
  0x89, 0x43, 0x99, 0x46, 0x15, 0x49, 0x1A, 0xAD, 0x6F, 0x26, 0x00, 0x0C,
  0x8D, 0x03, 0x62, 0x82, 0x41, 0x78, 0x72, 0x52, 0x09, 0x07, 0xD9, 0x3D,
  0xE7, 0x0F, 0x62, 0x22, 0xC7, 0x7F, 0xAB, 0xAE, 0xC1, 0x69, 0x6A, 0x06,
  0xC8, 0x3A, 0x40, 0x10, 0x10, 0x00, 0x11, 0x01, 0x0C, 0x0C, 0x40, 0x39,
  0xCC, 0x44, 0x1A, 0x2A, 0x20, 0xCB, 0xDB, 0x8E, 0x3B, 0xF8, 0xF9, 0xC5,
  0x82, 0x2B, 0xD2, 0x90, 0x77, 0x86, 0x9F, 0xF6, 0x29, 0x93, 0xFB, 0x34,
  0x7F, 0x56, 0x42, 0x40, 0x7C, 0x52, 0x61, 0x3A, 0x35, 0x32, 0x32, 0x84,
  0x08, 0x60, 0x00, 0x45, 0xB7, 0x2E, 0x8B, 0xCA, 0x4B, 0x62, 0x08, 0x50,
  0xE3, 0xBC, 0x77, 0x22, 0x0C, 0x38, 0x71, 0x22, 0xAD, 0xD8, 0x59, 0x14,
  0x7B, 0x2B, 0xCB, 0xA2, 0xD7, 0xE9, 0x5C, 0xD5, 0x0F, 0x00, 0x48, 0x26,
  0x20, 0xB9, 0x19, 0x56, 0xBF, 0x60, 0xD3, 0x23, 0x1C, 0x8C, 0x39, 0xEE,
  0x74, 0x47, 0xBE, 0x61, 0x98, 0x01, 0xA1, 0xA7, 0x92, 0x78, 0x75, 0x9E,
  0xA0, 0x16, 0x38, 0x6C, 0x9D, 0x80, 0x80, 0x99, 0x18, 0x98, 0x08, 0xC2,
  0xE1, 0x2C, 0x4A, 0xF6, 0xC5, 0xC4, 0x83, 0xD5, 0xDB, 0x86, 0xB9, 0x43,
  0xD4, 0x3C, 0x71, 0xBC, 0xB1, 0x60, 0xAC, 0x57, 0x7A, 0x2B, 0x7A, 0xEE,
  0xD9, 0x73, 0x7A, 0xDF, 0xFA, 0xC5, 0x89, 0x89, 0xD0, 0xA8, 0x82, 0x59,
  0x98, 0x64, 0x1A, 0x43, 0x10, 0x30, 0x2C, 0xCF, 0x4B, 0x85, 0xC4, 0x63,
  0x00, 0x18, 0x34, 0x9B, 0x2D, 0x27, 0xA0, 0x06, 0x4D, 0x14, 0x11, 0x9F,
  0xD0, 0xEB, 0x76, 0xE7, 0xE7, 0xA7, 0xA7, 0x4E, 0x73, 0x00, 0xC8, 0x92,
  0xDF, 0x0C, 0x26, 0xCE, 0xA0, 0xC8, 0x86, 0xE2, 0xCB, 0xB8, 0x07, 0x13,
  0xC3, 0x30, 0x10, 0x00, 0x98, 0x0F, 0x18, 0xE2, 0x1D, 0x78, 0xC0, 0xDD,
  0xE4, 0x0C, 0x00, 0x41, 0xEE, 0x78, 0x5B, 0x9B, 0x62, 0xA6, 0x22, 0x19,
  0x77, 0xB9, 0x0D, 0x7B, 0x4F, 0x95, 0x25, 0xE5, 0xEF, 0x8C, 0x29, 0x00,
  0x04, 0x1F, 0xEF, 0x59, 0x19, 0x87, 0x76, 0x31, 0x49, 0x97, 0x34, 0x54,
  0xD1, 0xEC, 0xD3, 0x3A, 0xF7, 0x69, 0xFD, 0x13, 0xA0, 0x36, 0xC1, 0xC7,
  0x45, 0x03, 0x74, 0xBF, 0x07, 0x41, 0x40, 0xB1, 0x5A, 0x45, 0x9C, 0x20,
  0xCD, 0x39, 0x00, 0xCA, 0x48, 0x9B, 0x39, 0x88, 0xA3, 0x17, 0xD3, 0x04,
  0x40, 0x43, 0x2C, 0xDE, 0x09, 0xF8, 0x3A, 0x9F, 0x8C, 0x01, 0xB0, 0x74,
  0xA7, 0x60, 0x92, 0x67, 0x79, 0xF4, 0xD2, 0xE5, 0xB3, 0x81, 0x7B, 0x10,
  0x00, 0x13, 0x03, 0xC0, 0xD0, 0xCB, 0x2D, 0x77, 0x79, 0xA6, 0x91, 0x21,
  0x28, 0x56, 0x7B, 0x05, 0x31, 0x01, 0x04, 0xC0, 0x1C, 0x44, 0x75, 0xE1,
  0xA8, 0x7D, 0xED, 0xB8, 0x53, 0x71, 0x60, 0x68, 0x47, 0x95, 0x48, 0x59,
  0xAC, 0x1C, 0x00, 0x80, 0x10, 0xF6, 0xF3, 0x44, 0x5F, 0x55, 0x33, 0x05,
  0x31, 0x79, 0xE2, 0xAB, 0xBF, 0x7E, 0xC5, 0x64, 0xD5, 0x6D, 0xDD, 0x97,
  0xF9, 0xDB, 0xF7, 0x44, 0x4B, 0xA0, 0x51, 0x06, 0x33, 0x25, 0x04, 0x53,
  0x0D, 0x75, 0x5D, 0x57, 0xA5, 0xF9, 0x28, 0xF2, 0xCE, 0xB9, 0x38, 0x4D,
  0xEA, 0xD9, 0x99, 0x19, 0x82, 0xF6, 0x9D, 0x73, 0xD2, 0xC4, 0x22, 0x00,
  0xF0, 0x62, 0x95, 0xF7, 0x02, 0x04, 0x76, 0xA6, 0x1C, 0x52, 0xBE, 0x50,
  0x00, 0xF9, 0xCD, 0xDF, 0x5F, 0x66, 0xF3, 0x01, 0x00, 0xE1, 0x30, 0x62,
  0x80, 0x60, 0x80, 0x58, 0x51, 0x43, 0xE2, 0xFA, 0xCE, 0x83, 0x17, 0x0F,
  0x76, 0x0B, 0x60, 0x02, 0x62, 0x00, 0x75, 0x2E, 0x26, 0x1E, 0xAF, 0x55,
  0x1C, 0xB5, 0x85, 0x3B, 0xC8, 0x44, 0x2B, 0xBC, 0xDA, 0xE8, 0xCA, 0x07,
  0x16, 0x1B, 0x00, 0xD2, 0x78, 0xE8, 0xCF, 0x3F, 0xAD, 0xC8, 0x3B, 0xBD,
  0x4E, 0x5E, 0xD2, 0x2A, 0xBB, 0xE6, 0x9E, 0x3F, 0x9B, 0x9D, 0xB5, 0xD4,
  0xDF, 0x97, 0xF9, 0xEB, 0x9A, 0x71, 0xA9, 0x22, 0x6F, 0xAE, 0xD9, 0x6D,
  0x0B, 0x01, 0x10, 0x33, 0x00, 0xE7, 0x9D, 0x88, 0x85, 0x2F, 0xAF, 0xDB,
  0x9E, 0x0E, 0xF5, 0x1A, 0x26, 0xB7, 0x6D, 0x30, 0x40, 0x5C, 0xEE, 0x14,
  0xCB, 0xCD, 0x9A, 0x40, 0x54, 0x55, 0xB5, 0x8B, 0xCC, 0xE4, 0x0B, 0xC9,
  0x00, 0x87, 0xAC, 0xCD, 0x5F, 0xDA, 0xDB, 0xF7, 0xA7, 0x7F, 0xDE, 0x5C,
  0x6E, 0x18, 0x00, 0x63, 0xFB, 0x41, 0x8C, 0xC3, 0x98, 0x20, 0x26, 0x58,
  0x1D, 0xC4, 0xC8, 0xAD, 0x21, 0x04, 0x71, 0x82, 0x0F, 0x7E, 0x4E, 0x00,
  0x10, 0x13, 0x13, 0xB8, 0x25, 0x17, 0x34, 0x8E, 0x5C, 0x5D, 0x4E, 0xDC,
  0xD8, 0xE0, 0x2E, 0x4B, 0x6C, 0x27, 0x89, 0x65, 0xAF, 0x6F, 0x1E, 0xCA,
  0x70, 0xD1, 0x40, 0x31, 0xDD, 0x9B, 0x9A, 0x6A, 0x06, 0x73, 0xA5, 0x0C,
  0x57, 0xF3, 0x03, 0x52, 0x5A, 0x63, 0xAC, 0xEC, 0xDF, 0x97, 0xFE, 0x1C,
  0xD1, 0x32, 0xC3, 0xE2, 0xAA, 0xD3, 0x16, 0x03, 0x05, 0xC0, 0x45, 0x1E,
  0x2B, 0xBE, 0xB1, 0xBA, 0x6A, 0x1C, 0x88, 0xC4, 0x62, 0xC0, 0x6D, 0x3D,
  0xB9, 0x51, 0x0A, 0xE2, 0x23, 0x75, 0xC1, 0x85, 0x26, 0x00, 0x66, 0x11,
  0x84, 0x2F, 0x68, 0xD6, 0xE0, 0x4E, 0x99, 0xE4, 0x4B, 0xDF, 0xA7, 0xAB,
  0x41, 0xF7, 0x18, 0x20, 0xE6, 0x0C, 0xC4, 0x38, 0xC8, 0x30, 0x11, 0x40,
  0x30, 0x89, 0xFA, 0x08, 0x58, 0x19, 0x3B, 0x6B, 0x44, 0x20, 0xB8, 0x1B,
  0xC2, 0xC6, 0x04, 0x13, 0x03, 0x40, 0x12, 0x8D, 0x02, 0x9E, 0x28, 0x24,
  0x13, 0x4D, 0xEE, 0x62, 0xE9, 0xCE, 0x97, 0xA7, 0xC8, 0xEB, 0x57, 0xB4,
  0x39, 0xC8, 0xAD, 0x62, 0xBE, 0x53, 0x95, 0x71, 0x0D, 0xFE, 0xB6, 0x6D,
  0xBF, 0x16, 0xD5, 0xFD, 0xB6, 0x05, 0x49, 0xC3, 0x7D, 0x59, 0xFF, 0xF4,
  0x0F, 0x20, 0xA1, 0x04, 0x52, 0x3A, 0xCA, 0x72, 0x00, 0x9C, 0x43, 0x84,
  0x4E, 0xAF, 0x3D, 0xDB, 0x6F, 0x46, 0x18, 0x00, 0x51, 0xE3, 0x9B, 0x5D,
  0x01, 0x70, 0x00, 0x92, 0xF7, 0x09, 0x41, 0x25, 0x71, 0xCE, 0xFC, 0xFC,
  0xA2, 0x96, 0xE3, 0x2E, 0x96, 0xB6, 0xD7, 0xAC, 0x03, 0xF4, 0x7A, 0x11,
  0xE4, 0xAE, 0xCF, 0x07, 0x80, 0x20, 0x1C, 0xCA, 0xB3, 0xF2, 0xFC, 0xD4,
  0x1D, 0x5C, 0x08, 0x89, 0x20, 0x62, 0x68, 0x7D, 0xF3, 0x56, 0x43, 0x40,
  0x00, 0x64, 0x3E, 0x72, 0x20, 0x82, 0x39, 0xEE, 0x66, 0x5B, 0x1F, 0xB8,
  0x2B, 0x1F, 0xDF, 0x98, 0x9F, 0x65, 0x3E, 0x08, 0x44, 0x7B, 0x2F, 0xF8,
  0x75, 0xF5, 0xB1, 0xE4, 0x4E, 0x7B, 0x55, 0x33, 0xDC, 0x97, 0xFE, 0x28,
  0x37, 0xB1, 0xB2, 0x46, 0x2C, 0x91, 0x5E, 0xB8, 0x5D, 0x11, 0x50, 0x24,
  0xF4, 0x27, 0xEB, 0xAA, 0x2D, 0xDC, 0x25, 0xAC, 0x09, 0x06, 0x80, 0xA9,
  0x8A, 0x43, 0x40, 0x8D, 0xB2, 0xAC, 0x45, 0x5B, 0xC2, 0x3D, 0x98, 0x01,
  0xD5, 0xF7, 0x23, 0x30, 0x40, 0x44, 0xE4, 0x8E, 0xB7, 0x60, 0xDC, 0xA1,
  0x7E, 0x43, 0x8E, 0x60, 0xA1, 0x4E, 0x13, 0xCC, 0x2C, 0x50, 0x44, 0xE9,
  0xAD, 0x37, 0xDE, 0x08, 0x82, 0x80, 0x5D, 0xB6, 0xCF, 0x41, 0x00, 0x31,
  0xE3, 0x70, 0x79, 0xF6, 0x0A, 0xE4, 0xAD, 0x4B, 0xEE, 0xCC, 0x77, 0x19,
  0xBD, 0x34, 0xAB, 0x15, 0xA2, 0xF6, 0xD3, 0x8A, 0xBE, 0x28, 0xD3, 0x07,
  0x34, 0x72, 0x45, 0x3B, 0xBB, 0x2F, 0xFD, 0x84, 0x03, 0x60, 0xFD, 0xCA,
  0x7C, 0x1C, 0x47, 0x65, 0xBF, 0xAA, 0x55, 0x55, 0xAB, 0xDE, 0xF4, 0x6C,
  0x08, 0x73, 0xCA, 0xE1, 0xCA, 0xA0, 0x00, 0x0E, 0xD4, 0x00, 0xDF, 0x14,
  0x43, 0x22, 0xA9, 0xB7, 0x0D, 0x73, 0x44, 0x65, 0x51, 0x9B, 0x01, 0x63,
  0x8C, 0x8D, 0x21, 0x00, 0x88, 0x08, 0x87, 0x93, 0xBA, 0x36, 0x1A, 0xCD,
  0x08, 0x09, 0x5A, 0x63, 0x75, 0x33, 0xB5, 0x9D, 0x20, 0x98, 0x39, 0xD9,
  0x32, 0x67, 0x20, 0x88, 0x70, 0x77, 0xBA, 0xFF, 0x77, 0xE1, 0xCF, 0x56,
  0x0C, 0x73, 0x87, 0xEA, 0xC6, 0xFF, 0xF8, 0xFA, 0xAE, 0x5B, 0x0B, 0xC3,
  0xB7, 0x37, 0xE6, 0xB3, 0x11, 0xAE, 0x88, 0x5C, 0xA7, 0x4C, 0xB2, 0x86,
  0xDC, 0xA7, 0x7E, 0x9D, 0xBA, 0x4C, 0x9C, 0xF6, 0x0A, 0x33, 0x2F, 0x3E,
  0xD2, 0x50, 0xE6, 0x45, 0x9E, 0x97, 0xE2, 0x9D, 0x56, 0x25, 0x87, 0x91,
  0xEA, 0x92, 0x0C, 0xCC, 0x9C, 0x07, 0xC1, 0x79, 0xE9, 0x59, 0xFD, 0xB5,
  0xCF, 0xFF, 0xD3, 0x97, 0xBE, 0x39, 0x95, 0x71, 0x24, 0xDA, 0x2D, 0x11,
  0x01, 0xC1, 0x81, 0x03, 0x0C, 0x0C, 0x04, 0x84, 0x83, 0x24, 0xF1, 0x71,
  0x9C, 0xA4, 0xE6, 0xC1, 0x44, 0x91, 0x4E, 0x9A, 0xB8, 0xB4, 0xD3, 0x07,
  0x94, 0x94, 0x5E, 0xDF, 0x23, 0x12, 0x1B, 0xC6, 0x97, 0x8D, 0xBB, 0xF4,
  0x3A, 0xF5, 0x07, 0xFE, 0x62, 0x69, 0xCA, 0x9D, 0xFC, 0xF8, 0xD0, 0xC2,
  0x7E, 0x2D, 0xD4, 0xAD, 0x4D, 0xE5, 0x7C, 0xEC, 0xA2, 0xAA, 0xD3, 0x6E,
  0xCC, 0x77, 0x43, 0x14, 0x37, 0xC2, 0x7D, 0x3A, 0xFF, 0x95, 0x44, 0x4B,
  0xBC, 0xAB, 0x7B, 0x49, 0x2C, 0x08, 0x1E, 0xBC, 0xA1, 0xB5, 0xA1, 0x65,
  0xED, 0x38, 0x8C, 0xE5, 0x63, 0x1B, 0x12, 0x13, 0x4B, 0xBA, 0x71, 0xFD,
  0x71, 0xAC, 0x1E, 0x8D, 0x16, 0xB2, 0xD0, 0x6A, 0x11, 0x8E, 0xCC, 0x6E,
  0x30, 0xE1, 0xA0, 0xAC, 0x54, 0x17, 0x10, 0x40, 0x8C, 0x3B, 0x49, 0xE3,
  0x84, 0x2D, 0x0E, 0x31, 0xD4, 0x1B, 0x86, 0xF6, 0xA3, 0x26, 0x66, 0xE9,
  0x56, 0x1A, 0x27, 0x7A, 0x29, 0xD8, 0x2F, 0x00, 0x02, 0xC2, 0x61, 0xDC,
  0xCC, 0x5C, 0xF6, 0x77, 0x69, 0xCA, 0xE1, 0x3C, 0x00, 0xD6, 0x38, 0x2D,
  0xCC, 0x79, 0xE7, 0xAA, 0xDB, 0x19, 0x96, 0x5E, 0x52, 0x0D, 0xE4, 0xCB,
  0xDA, 0x62, 0xF7, 0xA1, 0xDF, 0x8A, 0x6C, 0xA1, 0x33, 0x4A, 0x75, 0x8E,
  0x83, 0x34, 0x40, 0xA8, 0x66, 0x03, 0x77, 0x13, 0x75, 0xE7, 0x7A, 0x4D,
  0xA4, 0x55, 0x4F, 0x2D, 0x8C, 0x48, 0x9C, 0x88, 0x01, 0x82, 0x71, 0x44,
  0x92, 0x5F, 0x21, 0x18, 0x62, 0x40, 0x54, 0x39, 0xB8, 0xAB, 0x46, 0xCC,
  0x04, 0x80, 0xB1, 0x38, 0x08, 0x82, 0x81, 0x94, 0x79, 0xED, 0x1A, 0xCE,
  0xC4, 0x54, 0xAF, 0x5F, 0x36, 0x5B, 0x86, 0xA1, 0xD6, 0xF4, 0xB8, 0x89,
  0x18, 0x82, 0x79, 0x1C, 0x77, 0xA8, 0xF2, 0xD1, 0xE4, 0xF0, 0xA3, 0x57,
  0x4C, 0x01, 0x50, 0x6B, 0x9E, 0x21, 0x7B, 0x63, 0xC7, 0x25, 0x2B, 0xF3,
  0xF0, 0xAD, 0xDF, 0x6A, 0x32, 0xDD, 0xF8, 0xBB, 0x5F, 0xDB, 0xB5, 0xB0,
  0xBE, 0x0F, 0xFD, 0x38, 0x4B, 0x93, 0x21, 0x71, 0xD4, 0x38, 0x2F, 0x60,
  0x21, 0x98, 0x69, 0x98, 0xAD, 0xB8, 0x87, 0x16, 0x12, 0xBC, 0x21, 0xA2,
  0x00, 0x18, 0x3F, 0x8A, 0xA9, 0x02, 0x20, 0x30, 0x26, 0x11, 0xCA, 0xE1,
  0xD3, 0x17, 0x00, 0xDC, 0xC0, 0x86, 0xAD, 0x8A, 0x61, 0x58, 0xB7, 0x32,
  0xB4, 0x68, 0x8A, 0x5A, 0xA5, 0x7E, 0x3F, 0x15, 0x07, 0x4A, 0xAF, 0xCE,
  0x9C, 0x0A, 0x82, 0x70, 0x17, 0x2F, 0x76, 0x78, 0x47, 0xBC, 0x73, 0xFA,
  0xA4, 0xDA, 0x54, 0xA5, 0x15, 0x2D, 0xCE, 0x7B, 0xB1, 0xA3, 0x5A, 0xD9,
  0x73, 0xBD, 0x3F, 0xAC, 0xA8, 0x25, 0x22, 0x39, 0x2B, 0xBA, 0x4F, 0xFD,
  0xB8, 0x90, 0x15, 0x89, 0x38, 0x87, 0xD6, 0x2A, 0x98, 0xC2, 0xFC, 0xD4,
  0x11, 0x37, 0x1E, 0x73, 0x80, 0x19, 0xF7, 0x81, 0xCE, 0xD7, 0x1C, 0x22,
  0xC2, 0xD8, 0x64, 0x38, 0x3C, 0xDF, 0x00, 0x40, 0x96, 0x35, 0xAE, 0x70,
  0x62, 0x4A, 0xC7, 0x32, 0x4D, 0xBC, 0x05, 0xA1, 0x2E, 0x22, 0x94, 0x44,
  0x2C, 0x56, 0x51, 0x04, 0x0F, 0xA0, 0x6D, 0xEE, 0x64, 0x1C, 0x46, 0x86,
  0x1F, 0x3E, 0xBC, 0x7A, 0xC7, 0xED, 0x6B, 0x0A, 0x95, 0xA5, 0xC9, 0xEE,
  0x11, 0x47, 0xF8, 0xDA, 0x12, 0xC7, 0x9C, 0x68, 0x8F, 0xFC, 0x8B, 0xD1,
  0x57, 0xD6, 0xD6, 0x1C, 0x99, 0xBB, 0x67, 0x56, 0x39, 0x33, 0x79, 0x20,
  0x20, 0x3E, 0x4A, 0x22, 0x27, 0x68, 0x55, 0xC4, 0x81, 0x9F, 0x8C, 0x74,
  0x8D, 0x43, 0xA4, 0x81, 0x8C, 0x89, 0x08, 0x08, 0x20, 0xC2, 0x1D, 0xC4,
  0xB5, 0x4C, 0x10, 0x8A, 0x3A, 0x89, 0x9A, 0x91, 0xB3, 0xB2, 0xB0, 0xBE,
  0x00, 0xE0, 0x23, 0x8F, 0x81, 0x22, 0x80, 0xAD, 0x2F, 0x38, 0xB2, 0x7A,
  0xFF, 0x6D, 0xB7, 0x75, 0x33, 0x1D, 0x5B, 0x34, 0xB4, 0x98, 0x62, 0x40,
  0x4C, 0xBF, 0x32, 0xAE, 0xD8, 0xF1, 0x7F, 0x11, 0xC8, 0xAB, 0x25, 0x0B,
  0x86, 0xE6, 0xEA, 0xFB, 0x7C, 0xFE, 0xBF, 0x94, 0x78, 0x6F, 0x67, 0x2C,
  0x8C, 0x3A, 0x87, 0x44, 0xF1, 0xF7, 0x52, 0xE1, 0x27, 0xD4, 0xFB, 0x44,
  0x6D, 0x26, 0x60, 0xA0, 0x99, 0x08, 0x4E, 0xEF, 0xBE, 0xFE, 0x0D, 0x90,
  0x24, 0x7A, 0xC8, 0xE5, 0x5E, 0x0B, 0x6D, 0x44, 0x11, 0x52, 0xA7, 0x49,
  0x35, 0x83, 0x80, 0x21, 0x58, 0x10, 0x00, 0xC4, 0x40, 0xF1, 0x1C, 0x89,
  0xD4, 0x85, 0x1B, 0xA8, 0x6D, 0x6E, 0x64, 0xE7, 0x70, 0x3A, 0x5B, 0x2C,
  0xC9, 0x3A, 0x73, 0xE5, 0xD2, 0x00, 0xD1, 0xBE, 0x47, 0x44, 0x16, 0x6A,
  0x93, 0xC8, 0xEE, 0xFB, 0xF9, 0x7F, 0x27, 0xA1, 0x8A, 0xA6, 0xCB, 0x59,
  0x97, 0x0C, 0x8E, 0x8C, 0x0E, 0x1A, 0x3F, 0x29, 0x9D, 0xAA, 0x91, 0x18,
  0x40, 0x4C, 0xEA, 0x08, 0xC6, 0x1C, 0x80, 0x03, 0xC1, 0x09, 0x07, 0x99,
  0x31, 0x24, 0x52, 0x85, 0xAC, 0x8C, 0x41, 0x35, 0x71, 0x03, 0x87, 0xBE,
  0xB2, 0x81, 0x02, 0x60, 0x22, 0x82, 0x09, 0x47, 0x64, 0x8D, 0x53, 0x66,
  0xA4, 0x35, 0x9C, 0x16, 0xF4, 0xB4, 0x5F, 0x4E, 0xCC, 0x86, 0xFE, 0x54,
  0x80, 0x10, 0x3F, 0x34, 0xA6, 0x08, 0x86, 0x19, 0xF7, 0xBD, 0x1F, 0xCC,
  0x5C, 0x54, 0xEF, 0x99, 0xA9, 0x6B, 0x27, 0xA6, 0x29, 0x3F, 0xA1, 0x78,
  0xAB, 0x42, 0x10, 0x00, 0xB1, 0xBE, 0x00, 0x63, 0x0E, 0x50, 0x10, 0xD1,
  0x3B, 0x83, 0xC4, 0xC5, 0xCB, 0xFA, 0xB1, 0x54, 0xCE, 0x40, 0x9C, 0x22,
  0xC3, 0x89, 0x02, 0xD4, 0xA5, 0x8A, 0x00, 0x26, 0x86, 0xDC, 0x7B, 0x87,
  0xEE, 0x4A, 0xA2, 0xFE, 0xC4, 0xA2, 0x87, 0x4E, 0xAC, 0x1D, 0xA8, 0x0D,
  0x9F, 0x68, 0x04, 0x1A, 0xD6, 0x2D, 0x8F, 0x0A, 0x0D, 0x3F, 0xDE, 0xF5,
  0x6F, 0xAD, 0xC9, 0xCB, 0xBF, 0xD9, 0x2B, 0x8A, 0x2C, 0xE2, 0x27, 0x34,
  0x7D, 0x95, 0x8B, 0x22, 0x00, 0xC1, 0xA8, 0x0D, 0x41, 0xEE, 0x58, 0x01,
  0x86, 0x18, 0x77, 0xF0, 0x27, 0xB4, 0x80, 0x18, 0xC1, 0xD1, 0xB1, 0x5A,
  0xC6, 0xD4, 0x02, 0x48, 0x5D, 0x09, 0x00, 0x01, 0xC3, 0xB8, 0xD1, 0x38,
  0xA2, 0xB2, 0x5A, 0xCE, 0xFC, 0xCC, 0x6D, 0xB7, 0xAC, 0xB9, 0x79, 0x97,
  0x64, 0xB7, 0xEF, 0xB9, 0xAD, 0x23, 0x10, 0x8F, 0x0D, 0xD6, 0xDD, 0xC9,
  0xDA, 0x7E, 0xBC, 0x7E, 0xFC, 0x68, 0x63, 0xFB, 0xF6, 0xDB, 0x86, 0xF8,
  0x49, 0xCD, 0x15, 0x88, 0x44, 0x00, 0x08, 0x20, 0x08, 0x00, 0x0E, 0x45,
  0xC0, 0x81, 0x20, 0x06, 0x88, 0x3B, 0xD9, 0x5B, 0x11, 0x61, 0xDA, 0xEF,
  0xF6, 0x2B, 0xB5, 0x74, 0xA8, 0x1A, 0x5C, 0x90, 0xA8, 0x77, 0x0A, 0x06,
  0x40, 0xD3, 0xD8, 0xC0, 0x91, 0xB9, 0xAA, 0x28, 0x7A, 0xBE, 0xCA, 0x67,
  0xCA, 0x29, 0x7F, 0xF3, 0xC2, 0x7E, 0x15, 0x01, 0xF9, 0xA2, 0xA8, 0x57,
  0x47, 0xE1, 0x27, 0xBA, 0xFE, 0x5F, 0x30, 0x7E, 0x32, 0x61, 0xEA, 0xFD,
  0xA9, 0x82, 0xD5, 0x18, 0xE8, 0x40, 0x28, 0xCC, 0x30, 0xF6, 0x1B, 0x38,
  0x05, 0xC1, 0xC0, 0xC0, 0x04, 0xB4, 0x9A, 0xEC, 0x5D, 0xB5, 0x20, 0x14,
  0x15, 0x9E, 0xAC, 0x9D, 0xC4, 0x61, 0xF7, 0xD0, 0x60, 0x35, 0x59, 0xC4,
  0x45, 0xDA, 0x04, 0x2B, 0x1A, 0x3E, 0xA9, 0x8B, 0x9D, 0xF3, 0xC6, 0x8F,
  0x66, 0xEA, 0x04, 0x00, 0x92, 0x8D, 0xAD, 0x7D, 0xE9, 0x7F, 0x2C, 0xFE,
  0x89, 0x1E, 0xFF, 0x64, 0xFC, 0xA4, 0xF4, 0xDF, 0x50, 0xA7, 0x77, 0x3F,
  0x80, 0x15, 0x73, 0xC1, 0xA9, 0xE2, 0xD4, 0x0E, 0x3B, 0x27, 0x28, 0xD2,
  0xEE, 0xC5, 0xB3, 0x88, 0x17, 0xAC, 0xF0, 0x2E, 0xF2, 0xC3, 0x9D, 0x76,
  0xBC, 0x70, 0x5F, 0xDF, 0xE2, 0x3B, 0x67, 0x11, 0x4A, 0xE0, 0x3E, 0x0E,
  0xD4, 0xF6, 0x3D, 0x3D, 0xFC, 0xC3, 0xD8, 0x82, 0xFB, 0xF9, 0xF9, 0x6F,
  0x9C, 0x55, 0xDE, 0x29, 0x87, 0x88, 0x70, 0x88, 0x3B, 0xF4, 0x2A, 0x77,
  0x7E, 0x88, 0xC4, 0xED, 0x6D, 0x9B, 0x5C, 0xEC, 0x31, 0x13, 0xEB, 0xE5,
  0x15, 0x03, 0x6E, 0x1E, 0xB7, 0x20, 0x73, 0x62, 0x86, 0x89, 0x62, 0x95,
  0x8A, 0x71, 0x5F, 0xE9, 0xF1, 0xBC, 0x7D, 0xE5, 0x2A, 0x7F, 0xFF, 0x3E,
  0xFF, 0x89, 0xCD, 0x7D, 0xAC, 0x3D, 0x51, 0x08, 0x50, 0x61, 0x02, 0x0D,
  0xFA, 0x86, 0x61, 0x4C, 0x9A, 0x02, 0x62, 0x87, 0xDF, 0x19, 0x4E, 0x39,
  0xF5, 0xAD, 0x14, 0x13, 0x03, 0xCC, 0x8D, 0x35, 0xE3, 0xFE, 0xBE, 0xD1,
  0x4C, 0xC2, 0x4C, 0x15, 0x01, 0x78, 0x6F, 0x61, 0x62, 0xA2, 0xC1, 0x7D,
  0x24, 0xD2, 0x96, 0x89, 0x96, 0x71, 0xFF, 0xCE, 0xBF, 0xF7, 0xBD, 0xA9,
  0xD9, 0xC5, 0x38, 0x20, 0x42, 0x80, 0x5A, 0x01, 0x10, 0xC6, 0xC6, 0x41,
  0x04, 0x40, 0x10, 0x0E, 0x89, 0x87, 0xCF, 0xEC, 0xFE, 0x7B, 0xB7, 0x2B,
  0x02, 0xCE, 0x75, 0x22, 0x9A, 0xF1, 0x74, 0xA9, 0x6E, 0x30, 0xAE, 0x44,
  0xC4, 0x13, 0xC2, 0x57, 0x77, 0x35, 0xB8, 0xAF, 0x4C, 0x3B, 0xF3, 0x4D,
  0xE3, 0xFE, 0xED, 0x97, 0xA9, 0x6F, 0x95, 0xC1, 0x04, 0x07, 0x80, 0x41,
  0x15, 0x00, 0xC0, 0xC9, 0xE4, 0xAA, 0x8E, 0xAA, 0x01, 0x26, 0x8E, 0x3B,
  0xB8, 0xF4, 0x6B, 0xE1, 0x2B, 0x5F, 0xED, 0x88, 0x88, 0xD5, 0xBD, 0x99,
  0x20, 0x63, 0xE5, 0x4C, 0x69, 0x7E, 0x30, 0x2D, 0x83, 0x20, 0xA1, 0x6E,
  0xB4, 0xE0, 0xBE, 0x53, 0x85, 0xFB, 0xB9, 0xDF, 0x75, 0x6A, 0xEA, 0xF9,
  0x44, 0x01, 0x30, 0x0C, 0x6A, 0x30, 0x04, 0xB3, 0x75, 0x43, 0x8F, 0x98,
  0x98, 0xCD, 0xCD, 0x39, 0x41, 0x0D, 0x01, 0x80, 0x68, 0xF5, 0x76, 0xA3,
  0x42, 0x51, 0xAD, 0xE3, 0x7E, 0x59, 0xC7, 0xAD, 0x5E, 0xA7, 0x24, 0x1A,
  0x6E, 0x04, 0x15, 0xD3, 0x2B, 0x8E, 0xB5, 0xDF, 0x7F, 0x17, 0x0E, 0x5C,
  0x2C, 0xF4, 0x65, 0x14, 0x1C, 0x82, 0x70, 0x07, 0x83, 0x88, 0x7F, 0x7F,
  0xF3, 0xB7, 0xBF, 0xBC, 0xAB, 0x1B, 0x14, 0x4C, 0x9C, 0x03, 0x40, 0xDC,
  0xEC, 0x2B, 0x1D, 0x72, 0x69, 0xA0, 0x0E, 0xBE, 0xCE, 0xF3, 0x7E, 0x3F,
  0x4A, 0x8A, 0x4E, 0xA5, 0x6E, 0xA8, 0x51, 0x87, 0xAF, 0x5C, 0x31, 0xE8,
  0x8E, 0xA9, 0x7E, 0x8B, 0x07, 0x3F, 0x9A, 0x43, 0x59, 0x05, 0x2F, 0x40,
  0xC4, 0x61, 0x44, 0x67, 0x1E, 0xF6, 0xB8, 0xB3, 0x36, 0x6F, 0x99, 0xF1,
  0x80, 0x88, 0x43, 0x38, 0x68, 0xC3, 0xE3, 0xBC, 0x52, 0x5A, 0x14, 0xF9,
  0xC4, 0xFA, 0x45, 0x89, 0x44, 0x45, 0xB7, 0x0A, 0x6E, 0xA8, 0x5D, 0xAE,
  0x1C, 0x34, 0x8E, 0xA5, 0x7E, 0xDF, 0xB8, 0x32, 0x9D, 0x03, 0xA4, 0xAC,
  0xDA, 0x01, 0x9C, 0x00, 0x80, 0x61, 0x00, 0xB8, 0x7A, 0x70, 0xC9, 0xF2,
  0xC7, 0x9E, 0x3F, 0x6D, 0xE0, 0x30, 0x11, 0x00, 0x13, 0x19, 0x22, 0xD4,
  0x15, 0x60, 0x48, 0x64, 0x75, 0x15, 0xC4, 0x25, 0x79, 0xBF, 0xAC, 0xA5,
  0x39, 0x9C, 0x76, 0xE5, 0x18, 0x7A, 0xFE, 0x47, 0x0D, 0x0B, 0xBE, 0xEC,
  0x1E, 0xF7, 0x9A, 0xB9, 0x18, 0x58, 0x59, 0xEF, 0x33, 0x50, 0xAB, 0x0D,
  0x04, 0x33, 0x13, 0x00, 0x0C, 0xF6, 0xED, 0x2C, 0xD6, 0x3B, 0x05, 0x87,
  0x9A, 0x89, 0x99, 0x55, 0x37, 0x7E, 0xA0, 0x16, 0x92, 0xF3, 0xC0, 0xC5,
  0xE6, 0x13, 0xB5, 0x5A, 0xA7, 0x8A, 0x6C, 0x79, 0x92, 0xA0, 0xFA, 0xEF,
  0xAB, 0x3A, 0xFE, 0x58, 0x99, 0xBF, 0x6B, 0xDE, 0xF0, 0x55, 0xE7, 0x1F,
  0xD9, 0xA3, 0xAA, 0x61, 0xB2, 0xDF, 0x3A, 0xD2, 0x37, 0x5B, 0x04, 0x5F,
  0xFC, 0xDC, 0xC2, 0x71, 0x00, 0xC4, 0x50, 0xAD, 0x86, 0x5E, 0xF4, 0xFE,
  0x20, 0xD4, 0x41, 0xD5, 0x04, 0xA7, 0x02, 0x2E, 0xDC, 0x98, 0x4F, 0xEC,
  0x28, 0x0B, 0x35, 0x3B, 0x6F, 0xC3, 0x68, 0xF7, 0x18, 0xE9, 0xB7, 0xA4,
  0x89, 0xF7, 0x26, 0x25, 0x50, 0x4B, 0x15, 0x1B, 0x80, 0x44, 0x20, 0x00,
  0x02, 0x80, 0x80, 0x00, 0x4E, 0x9C, 0x73, 0x18, 0xA6, 0xD5, 0xAE, 0xDF,
  0x7E, 0x56, 0xA4, 0x50, 0x43, 0x19, 0x00, 0xA9, 0x31, 0xBC, 0xAD, 0xA1,
  0xB1, 0xE7, 0xE2, 0xB2, 0x5F, 0x1B, 0xF1, 0x29, 0xF9, 0xBC, 0x1E, 0x13,
  0xFD, 0xBA, 0xF3, 0xAB, 0xC0, 0x63, 0x3C, 0xA0, 0x18, 0xCE, 0xA7, 0x00,
  0x77, 0xE4, 0x1B, 0x18, 0x18, 0xB0, 0xE8, 0x99, 0x78, 0x60, 0x0C, 0xB0,
  0xE2, 0xEA, 0xB7, 0xC4, 0xA8, 0x41, 0x14, 0x79, 0x07, 0x08, 0x75, 0x4D,
  0x94, 0x0D, 0x1A, 0x34, 0x56, 0xEF, 0xB4, 0xB2, 0xB2, 0x96, 0x3E, 0x6B,
  0x4F, 0x57, 0x8E, 0x85, 0xFE, 0x78, 0xBD, 0x5A, 0xE0, 0x2D, 0x0F, 0x13,
  0x33, 0xAF, 0xB5, 0xCD, 0x48, 0xE6, 0x70, 0x0E, 0x38, 0xFC, 0xB2, 0x16,
  0x11, 0x42, 0x45, 0x10, 0x98, 0xC4, 0x2C, 0x9E, 0xF8, 0x1B, 0xB5, 0xE7,
  0x3E, 0xDB, 0x51, 0xD7, 0xA9, 0x7E, 0xD9, 0x09, 0x06, 0xFD, 0xA8, 0x31,
  0x30, 0xBA, 0xCB, 0x83, 0x9F, 0xBC, 0xF4, 0x6B, 0x56, 0xCE, 0x7B, 0xF7,
  0x92, 0xE9, 0xEE, 0x31, 0x31, 0xFF, 0xBC, 0x12, 0x39, 0xBB, 0xCC, 0x45,
  0xA8, 0xCD, 0x94, 0xE4, 0x0D, 0xE3, 0xA0, 0x44, 0x70, 0xD8, 0xFA, 0x37,
  0x63, 0xE8, 0x8D, 0xB1, 0x01, 0xB0, 0x60, 0xC1, 0xD2, 0xB7, 0xAA, 0xAB,
  0xD7, 0x6E, 0x72, 0x44, 0xA9, 0xFA, 0x1A, 0x10, 0xA2, 0xCA, 0x50, 0xF7,
  0xF4, 0x96, 0x42, 0x34, 0xD2, 0xF8, 0x72, 0x5C, 0x59, 0x9F, 0x5F, 0xDB,
  0x1F, 0x8E, 0x81, 0x7E, 0x82, 0x2F, 0x5D, 0x74, 0x49, 0xAC, 0x7A, 0x60,
  0x72, 0xFF, 0xFE, 0xC0, 0xF4, 0xEB, 0xD2, 0x88, 0xC8, 0x03, 0x60, 0x18,
  0x02, 0x82, 0x88, 0x45, 0x9B, 0xBE, 0x20, 0x11, 0xAA, 0xE3, 0x69, 0x2A,
  0x48, 0xFD, 0x56, 0x73, 0x3B, 0xCC, 0xCB, 0x54, 0x97, 0xD0, 0x33, 0xC3,
  0xD1, 0xAF, 0x55, 0xFD, 0xF6, 0x00, 0xD0, 0x5C, 0xBC, 0x3D, 0x9A, 0x2E,
  0x73, 0xF9, 0x95, 0xFD, 0xF2, 0xC0, 0xEF, 0x97, 0x7C, 0x85, 0x14, 0x9F,
  0x7F, 0xE3, 0xB9, 0x57, 0x47, 0x21, 0x58, 0x28, 0x2A, 0x2D, 0x16, 0x2C,
  0xF2, 0x20, 0xF7, 0x38, 0xEF, 0x9D, 0xBC, 0xE3, 0xE6, 0xB3, 0xA2, 0x3A,
  0x1B, 0x9F, 0x1C, 0x6E, 0x7A, 0x20, 0xC6, 0xDD, 0x4A, 0x2C, 0xD3, 0xF4,
  0xF5, 0x4B, 0x5F, 0xCF, 0x0D, 0x7C, 0x5E, 0xC4, 0x41, 0x9F, 0x32, 0xE5,
  0x00, 0xC2, 0xD4, 0x36, 0x2D, 0x94, 0xB8, 0xEC, 0x3C, 0xF0, 0xFB, 0x2D,
  0x5B, 0xED, 0x22, 0x67, 0xFC, 0xFA, 0xF7, 0x66, 0x72, 0x65, 0x6F, 0x4F,
  0xAB, 0xBD, 0x1F, 0x5E, 0x62, 0x46, 0x04, 0x18, 0x87, 0x88, 0x59, 0xFE,
  0xB2, 0xF9, 0xF4, 0xD2, 0x5F, 0xFE, 0x85, 0xD7, 0xAE, 0x5F, 0xFF, 0xBD,
  0x1A, 0xE4, 0xC6, 0x5D, 0x53, 0x17, 0xC9, 0x34, 0x50, 0x85, 0xF2, 0xCB,
  0x35, 0x2A, 0x54, 0xF3, 0xAA, 0xD1, 0xE3, 0x3D, 0x00, 0xBE, 0x7B, 0x69,
  0x15, 0x70, 0xBF, 0x3C, 0x67, 0x0F, 0xE0, 0x7E, 0xF5, 0xC1, 0x54, 0xAA,
  0x89, 0x6F, 0x7B, 0xEF, 0xA3, 0xC6, 0xCA, 0x17, 0x3C, 0x7B, 0x67, 0x5F,
  0xD9, 0xB7, 0x23, 0x1C, 0xB8, 0x48, 0x22, 0x11, 0x89, 0x40, 0x10, 0x44,
  0xC4, 0x84, 0x68, 0x4C, 0xBE, 0xB2, 0xE2, 0xFD, 0x7F, 0x1E, 0x3D, 0xFD,
  0xA9, 0xBF, 0xBB, 0xE2, 0x95, 0xFE, 0x06, 0xD1, 0x8F, 0x6D, 0x9B, 0xFF,
  0xB2, 0x08, 0x22, 0x88, 0xD5, 0xC1, 0x40, 0xFA, 0x55, 0xAD, 0x32, 0xD0,
  0x0A, 0x00, 0x84, 0x65, 0xB5, 0x83, 0x78, 0x6B, 0xFF, 0x01, 0xDC, 0x1F,
  0xF6, 0xCF, 0x0E, 0x0F, 0x27, 0xB3, 0xB7, 0xE2, 0x4C, 0x30, 0xB7, 0x7A,
  0xE5, 0xEF, 0x4D, 0xCF, 0xA8, 0x86, 0xBC, 0xEA, 0xBC, 0x7C, 0x21, 0x02,
  0x00, 0x26, 0x22, 0x38, 0x18, 0x7C, 0x63, 0xFA, 0xEA, 0xD3, 0xFF, 0x89,
  0x6F, 0x7F, 0xE8, 0x7F, 0xBF, 0xF4, 0x35, 0x7B, 0xF2, 0x29, 0x70, 0x5F,
  0xFE, 0x42, 0x57, 0x07, 0xE5, 0xC5, 0x80, 0x00, 0x88, 0xAB, 0x8B, 0x2A,
  0x36, 0xBF, 0xA2, 0x25, 0x00, 0x74, 0x76, 0x4F, 0x57, 0xC8, 0x1F, 0x2D,
  0x71, 0x0F, 0xD4, 0x7E, 0x71, 0x0B, 0x6E, 0xBE, 0xF9, 0xE2, 0xFF, 0xF8,
  0xDA, 0xAD, 0x91, 0xBE, 0xC4, 0x29, 0x80, 0x5B, 0xFD, 0x67, 0xCF, 0xD9,
  0xDE, 0x0F, 0x7B, 0x74, 0xEE, 0x55, 0x1F, 0x1E, 0x11, 0x27, 0x51, 0x84,
  0x08, 0x44, 0xB1, 0xA7, 0xF1, 0xE6, 0x4B, 0x3E, 0xE5, 0x6B, 0x7B, 0x7C,
  0xCB, 0xDF, 0x7E, 0xCA, 0x4B, 0x77, 0xAC, 0xFC, 0xBA, 0x8B, 0x43, 0xA5,
  0xDE, 0xE0, 0x7D, 0x00, 0x86, 0x61, 0xB8, 0x7E, 0x3D, 0x5F, 0x4B, 0x63,
  0xB7, 0x07, 0x20, 0xEA, 0x16, 0xB9, 0x51, 0x3C, 0x3A, 0x71, 0x0F, 0xD0,
  0x7E, 0xF3, 0x9F, 0x07, 0xFA, 0x3E, 0xF6, 0x4F, 0xBA, 0x22, 0x78, 0x67,
  0xC0, 0xA3, 0x6D, 0xF5, 0x7B, 0x9E, 0xB9, 0x2F, 0xEC, 0xA0, 0x7A, 0x46,
  0xBB, 0xED, 0x23, 0x00, 0x24, 0x02, 0xE7, 0xBF, 0x48, 0x59, 0xAB, 0xB8,
  0x8F, 0x2E, 0x0D, 0xCB, 0xC2, 0x6D, 0x92, 0x9F, 0xF9, 0x94, 0xBC, 0x40,
  0xA2, 0xC8, 0x01, 0x80, 0x18, 0x08, 0xAE, 0x0A, 0x75, 0xA5, 0xF1, 0x63,
  0x76, 0x19, 0x80, 0xE5, 0x13, 0xBD, 0x99, 0x03, 0xA3, 0xFB, 0x4E, 0x9B,
  0x7D, 0x80, 0xFE, 0xFE, 0x2B, 0xD7, 0x92, 0x9E, 0xB4, 0x63, 0x6F, 0xF6,
  0xC5, 0x0B, 0x6E, 0x5B, 0xA3, 0xBF, 0xFF, 0xDE, 0x80, 0x03, 0x5B, 0x7D,
  0xE9, 0x9A, 0x93, 0xE6, 0x07, 0x4A, 0x52, 0x72, 0x09, 0x87, 0xEA, 0xDC,
  0xD8, 0x3B, 0x6A, 0x45, 0x38, 0xA8, 0xFB, 0xAE, 0xF5, 0x4F, 0x79, 0xBF,
  0x73, 0x4E, 0x00, 0x20, 0xF7, 0x31, 0x60, 0x02, 0xBE, 0x70, 0x75, 0x4B,
  0x47, 0x1E, 0x75, 0x2B, 0x00, 0x3E, 0xEE, 0xA4, 0x0B, 0x16, 0x2D, 0xAD,
  0xA7, 0x9C, 0x3E, 0x30, 0xD7, 0xFF, 0x4D, 0xBD, 0xF6, 0x50, 0xEC, 0xCD,
  0x44, 0x3F, 0xB5, 0xE6, 0xFC, 0xDB, 0xDE, 0xAB, 0xC2, 0x97, 0x9D, 0x33,
  0xFB, 0xDA, 0x47, 0x76, 0xE7, 0xF3, 0xA5, 0xFD, 0xE3, 0xDB, 0x5B, 0x2E,
  0x4E, 0x92, 0x28, 0xF2, 0xEE, 0xFB, 0x8D, 0xD3, 0x6B, 0x00, 0x74, 0xCD,
  0x16, 0xE0, 0x7D, 0xFF, 0x26, 0x0B, 0xD6, 0x38, 0x2F, 0x1C, 0xD2, 0xC9,
  0x5D, 0x81, 0x18, 0xE6, 0xBE, 0xAB, 0xA1, 0xAB, 0xA1, 0xD1, 0x0A, 0x00,
  0xCC, 0x2E, 0x58, 0xBC, 0x52, 0x8B, 0xF0, 0xCA, 0xDD, 0x1C, 0xE2, 0x7A,
  0xF3, 0x1E, 0x5C, 0x0D, 0xE2, 0xB6, 0x75, 0xEA, 0xFB, 0x79, 0xFE, 0xB2,
  0x73, 0x48, 0xC4, 0x51, 0xE3, 0x08, 0xF6, 0x49, 0x01, 0x51, 0x33, 0x8F,
  0x47, 0xDF, 0xBD, 0xFD, 0x43, 0xCB, 0x79, 0xDE, 0x87, 0x5F, 0xFF, 0xE6,
  0xB4, 0xB2, 0x79, 0x18, 0x3F, 0x27, 0x32, 0x21, 0x00, 0x94, 0xEF, 0x7C,
  0x55, 0xF4, 0xC9, 0x4F, 0xB8, 0xA7, 0x1E, 0x5F, 0x63, 0x02, 0x06, 0x00,
  0x7D, 0x6F, 0x06, 0x20, 0x6B, 0x59, 0x16, 0xA2, 0x10, 0x8D, 0x35, 0x4C,
  0x80, 0x81, 0xED, 0xAF, 0xC8, 0xB3, 0xC8, 0xDB, 0x74, 0x54, 0x03, 0x58,
  0x7F, 0xFF, 0x55, 0xAF, 0xDC, 0x7E, 0x7C, 0xDD, 0x9C, 0x8E, 0x7B, 0x9D,
  0xD5, 0xE1, 0xB5, 0xBF, 0xB8, 0x6B, 0x3C, 0xBD, 0x3F, 0xFB, 0x8B, 0x03,
  0x13, 0x5E, 0xAA, 0x00, 0xA6, 0x38, 0xFF, 0x84, 0xAF, 0x04, 0x03, 0x53,
  0x73, 0x62, 0x6E, 0xF5, 0x5B, 0x7E, 0x75, 0xCE, 0x3D, 0x83, 0x7F, 0x84,
  0x2D, 0x50, 0x7E, 0x3E, 0x16, 0x0F, 0x0E, 0x35, 0xB5, 0x7F, 0x8D, 0xE4,
  0x4C, 0x61, 0x74, 0xCF, 0x0A, 0x0C, 0x84, 0x43, 0xB4, 0x05, 0x80, 0xB0,
  0xA7, 0xF3, 0xB8, 0x39, 0xB5, 0xB1, 0x05, 0x7B, 0xC5, 0xA0, 0xDE, 0x56,
  0xA4, 0xB1, 0x83, 0xB7, 0x6E, 0x5F, 0x2E, 0x48, 0x67, 0xE7, 0x8E, 0x57,
  0x98, 0xFC, 0xD2, 0xEA, 0x05, 0x72, 0xDE, 0x9A, 0xB9, 0xA7, 0x9C, 0xF1,
  0x9C, 0x33, 0x3F, 0x16, 0x5E, 0x92, 0x67, 0xF7, 0x63, 0x7F, 0xE4, 0xF7,
  0xEC, 0x08, 0x87, 0xDE, 0x73, 0x2F, 0xB9, 0xA4, 0x52, 0x40, 0x21, 0x44,
  0x2A, 0x8F, 0xBF, 0xE4, 0xEF, 0xFB, 0xEF, 0x3A, 0x73, 0x0B, 0x6C, 0xE2,
  0x0B, 0x6A, 0xCE, 0x13, 0x0C, 0x44, 0x88, 0xC4, 0x99, 0x68, 0xE0, 0xA5,
  0x1F, 0x36, 0x30, 0x10, 0xB2, 0x1C, 0xC0, 0x29, 0x20, 0x50, 0xB6, 0x07,
  0x96, 0x76, 0x5B, 0x9B, 0xA6, 0x6D, 0x7E, 0xBE, 0x0D, 0x32, 0x17, 0x81,
  0x89, 0x70, 0xEB, 0x18, 0x6E, 0xF7, 0xED, 0x17, 0x99, 0xB3, 0x6A, 0x3A,
  0x9A, 0x75, 0xD9, 0xF8, 0xD3, 0x87, 0x5D, 0x14, 0xBC, 0xFF, 0xCB, 0x57,
  0x75, 0xDA, 0xF7, 0xE3, 0xFE, 0x5F, 0x43, 0x00, 0x7C, 0x1C, 0x3B, 0x17,
  0xDE, 0x55, 0xD7, 0x6A, 0xA6, 0xF8, 0x58, 0x82, 0x55, 0x5F, 0x44, 0xB3,
  0x67, 0x7D, 0xE3, 0x21, 0x9B, 0xF4, 0xCA, 0xCF, 0x05, 0x89, 0x3D, 0xC1,
  0xCC, 0x0C, 0xEF, 0xE3, 0x08, 0xAD, 0x2A, 0x33, 0x5D, 0x01, 0x08, 0x0A,
  0x39, 0x00, 0xBF, 0xE0, 0x41, 0xC0, 0x89, 0xF6, 0xD6, 0xAF, 0xDA, 0x68,
  0xC3, 0xA3, 0x6F, 0xD8, 0x5D, 0x03, 0xFE, 0xE5, 0x85, 0x09, 0xF0, 0xC1,
  0xDD, 0xD1, 0xAE, 0x5F, 0xFA, 0xB5, 0x2A, 0x42, 0x2B, 0x4D, 0x07, 0x16,
  0x0E, 0xF9, 0xD3, 0x4E, 0xD9, 0x10, 0x83, 0xF1, 0x1B, 0x57, 0xCE, 0xDD,
  0x7F, 0xFD, 0xE8, 0x2A, 0xF7, 0x9F, 0xF5, 0xE2, 0xEA, 0xBA, 0x36, 0x11,
  0x90, 0x28, 0x12, 0x6A, 0xD5, 0x5A, 0xC5, 0x56, 0xBD, 0xEE, 0x85, 0xEF,
  0xFA, 0xDC, 0x97, 0x24, 0x72, 0x06, 0xE0, 0x22, 0x2F, 0xA2, 0x35, 0xAA,
  0xEA, 0x54, 0x2F, 0x15, 0xC0, 0x4C, 0x6B, 0x9F, 0x01, 0x34, 0x67, 0xBD,
  0x61, 0x86, 0xEC, 0xC3, 0x3E, 0xBC, 0x20, 0xA8, 0xF3, 0xEE, 0x4D, 0x5D,
  0xC0, 0x2D, 0xC7, 0x82, 0x01, 0xAF, 0xDD, 0xF7, 0x88, 0x32, 0x89, 0xA9,
  0xAC, 0x5A, 0xB2, 0x6C, 0x40, 0xB0, 0x9B, 0x73, 0xD6, 0xC4, 0x86, 0xC9,
  0x3F, 0x5F, 0x3D, 0x77, 0xBF, 0xAD, 0x7F, 0xE8, 0x1E, 0x98, 0x10, 0x1F,
  0xC0, 0x6A, 0x81, 0x3A, 0x02, 0x1F, 0x41, 0x65, 0x08, 0x4A, 0xA4, 0xB2,
  0x5A, 0x13, 0x00, 0xCC, 0x44, 0x90, 0x3A, 0x08, 0x2E, 0xF8, 0x80, 0x3A,
  0xAD, 0xA3, 0x20, 0x98, 0xA2, 0xE6, 0x81, 0x66, 0x9A, 0x09, 0x87, 0x58,
  0x37, 0xB7, 0x26, 0xEB, 0x6F, 0x96, 0xDD, 0xFD, 0x06, 0x71, 0x89, 0x51,
  0x89, 0x13, 0x3D, 0x2F, 0xDE, 0x37, 0xE8, 0x2D, 0x99, 0x8D, 0x06, 0x31,
  0x13, 0xDF, 0x37, 0xBB, 0xD9, 0x6D, 0x30, 0xEA, 0xAD, 0x1F, 0xB7, 0x5B,
  0x57, 0xDF, 0x5F, 0xF3, 0x47, 0xC6, 0x1F, 0x76, 0xE2, 0x59, 0x78, 0xAD,
  0x41, 0x5C, 0xEA, 0x9D, 0x97, 0x60, 0x95, 0x01, 0x58, 0xA8, 0x25, 0x20,
  0xFA, 0x43, 0x8F, 0x33, 0xBC, 0x85, 0x22, 0x00, 0x2A, 0xA6, 0xA0, 0x28,
  0x82, 0x29, 0xA8, 0xF8, 0x2C, 0x1B, 0x7E, 0xF2, 0xE3, 0x63, 0x11, 0x44,
  0x0C, 0x8F, 0x0E, 0x18, 0x2A, 0x08, 0x2F, 0x3F, 0xA0, 0x24, 0xA0, 0x84,
  0x13, 0x8F, 0x2F, 0x18, 0x1D, 0x97, 0xB9, 0x4E, 0xDE, 0xA9, 0x43, 0x57,
  0xC0, 0x5C, 0xF9, 0xBD, 0xEF, 0xED, 0x53, 0xF0, 0xED, 0xE6, 0x95, 0xAF,
  0x15, 0x7F, 0xBF, 0xF5, 0xBB, 0xA8, 0x4C, 0xFB, 0x8F, 0xC2, 0x26, 0x26,
  0x74, 0xCB, 0xD7, 0xAE, 0xB8, 0xF6, 0xDA, 0x08, 0x17, 0x8C, 0x83, 0xEA,
  0x70, 0x4E, 0x30, 0xE7, 0x44, 0xDC, 0x97, 0x9D, 0xE0, 0x40, 0x04, 0x08,
  0x20, 0x80, 0x22, 0xA6, 0x20, 0x52, 0x9D, 0xF3, 0xA6, 0x37, 0x9D, 0x9B,
  0x34, 0x4C, 0xC4, 0x30, 0xDC, 0x62, 0x67, 0x0B, 0xDE, 0xEB, 0xE1, 0xA6,
  0x75, 0x32, 0x9E, 0xF7, 0x29, 0x41, 0x2C, 0xBA, 0x7E, 0x4B, 0x14, 0x2F,
  0x58, 0x73, 0xB2, 0xAC, 0xEF, 0xD6, 0x45, 0xD9, 0x55, 0x28, 0x0A, 0xE7,
  0x5C, 0xB4, 0x01, 0x61, 0x72, 0x57, 0xA4, 0xBF, 0xB8, 0x33, 0xDC, 0x5F,
  0xFD, 0x18, 0x56, 0xCF, 0x9C, 0x76, 0xE6, 0xC3, 0x77, 0x5D, 0x36, 0x5B,
  0x4D, 0xDC, 0xBC, 0xED, 0x8B, 0xAF, 0x78, 0xB4, 0x02, 0x80, 0x21, 0xF6,
  0x15, 0xB4, 0x2C, 0xEB, 0xBA, 0x0E, 0x48, 0x08, 0x0A, 0x02, 0x18, 0x0E,
  0x01, 0x82, 0x28, 0x00, 0xF5, 0x5F, 0x3C, 0xF9, 0xDC, 0xC3, 0xAF, 0x15,
  0x28, 0xA9, 0x24, 0x02, 0x6E, 0x81, 0x37, 0x2E, 0x75, 0x09, 0x80, 0xF8,
  0x28, 0xDA, 0x60, 0x2E, 0x59, 0x2D, 0x74, 0x9D, 0xEF, 0x17, 0x46, 0xD8,
  0x3B, 0x51, 0x39, 0xB6, 0xFE, 0x00, 0x3E, 0x71, 0xC9, 0xE3, 0x47, 0xF7,
  0xF4, 0xEF, 0xA7, 0x7E, 0x00, 0x5F, 0x95, 0xD7, 0x74, 0xAD, 0x98, 0xDF,
  0xB5, 0x67, 0xCF, 0x8D, 0x67, 0x3F, 0x26, 0x08, 0x00, 0x02, 0x2E, 0x18,
  0x22, 0x60, 0x5A, 0x23, 0x06, 0x18, 0x07, 0x99, 0x88, 0xA8, 0x17, 0x11,
  0xA7, 0x7F, 0x74, 0xC5, 0x9C, 0x29, 0xA6, 0x56, 0x14, 0xA6, 0xA6, 0x36,
  0x11, 0x21, 0x63, 0xBF, 0x27, 0x8A, 0x81, 0x9C, 0x13, 0x11, 0xA3, 0x6A,
  0xA0, 0x37, 0x3B, 0xA3, 0x9D, 0x6B, 0x9A, 0x88, 0x29, 0x84, 0x50, 0x19,
  0xF1, 0xEC, 0x81, 0xC9, 0xC9, 0xC2, 0x57, 0x74, 0xFC, 0xE9, 0xCF, 0xDD,
  0xD5, 0xBF, 0xFF, 0xFA, 0xC1, 0x93, 0x16, 0xF3, 0xFB, 0x7B, 0xB9, 0xB1,
  0x6B, 0xF1, 0xBB, 0x9E, 0xE5, 0xEE, 0xFE, 0xC5, 0x0C, 0x2C, 0x60, 0x20,
  0x00, 0x86, 0x20, 0x80, 0x9A, 0x73, 0xFA, 0xCA, 0x1B, 0x2F, 0xAC, 0x8C,
  0x51, 0xC4, 0xB9, 0x38, 0x12, 0x21, 0xBB, 0xCC, 0x80, 0xF6, 0xB2, 0x1E,
  0x80, 0x68, 0x63, 0xC2, 0x3B, 0x74, 0x7B, 0x5E, 0x2A, 0xAA, 0x38, 0xE6,
  0x11, 0x21, 0x12, 0xA8, 0xAA, 0x24, 0xC5, 0x25, 0x8D, 0xC4, 0xC4, 0x80,
  0xAC, 0xEE, 0x5C, 0x94, 0xCB, 0xFD, 0xD8, 0x5F, 0x42, 0xB5, 0x5F, 0x1A,
  0x0D, 0xD4, 0x74, 0xE0, 0xF4, 0xD7, 0x29, 0x00, 0x0E, 0x31, 0x00, 0x01,
  0xC0, 0xC0, 0x00, 0x8C, 0x43, 0xF4, 0xDA, 0xEB, 0x2F, 0x3F, 0x7F, 0x8F,
  0x01, 0x1D, 0x15, 0x71, 0x4E, 0x10, 0x4A, 0x97, 0x01, 0x9A, 0x8A, 0x89,
  0x62, 0xB8, 0x8B, 0xF6, 0xB4, 0x7A, 0xD7, 0x2C, 0x9A, 0xBF, 0x61, 0x5B,
  0x30, 0x11, 0x65, 0xF1, 0xAA, 0x52, 0x75, 0x30, 0x31, 0xCA, 0x28, 0x75,
  0x00, 0x3E, 0xAD, 0x21, 0x6E, 0xD7, 0x9D, 0x99, 0xDD, 0x2B, 0xF5, 0x7E,
  0xEC, 0x4F, 0x29, 0x0A, 0x70, 0x0E, 0x33, 0x91, 0xF6, 0x43, 0xDE, 0xA6,
  0x4E, 0x04, 0x51, 0xE1, 0x0E, 0x1E, 0xC0, 0x38, 0xDC, 0xED, 0x32, 0x51,
  0xAB, 0x14, 0x20, 0x06, 0xE0, 0x4C, 0x00, 0x6A, 0x80, 0x81, 0xF7, 0x5A,
  0x50, 0x35, 0xD1, 0xE6, 0x0B, 0x2E, 0xA2, 0x75, 0xA0, 0xE3, 0xA7, 0xF7,
  0x77, 0x42, 0x9D, 0x43, 0x4F, 0x1A, 0x0B, 0x07, 0x04, 0x7A, 0xF5, 0x80,
  0xAA, 0x96, 0x65, 0xF0, 0x71, 0x41, 0x15, 0x0F, 0xA4, 0x03, 0x4B, 0xB6,
  0xCC, 0xDE, 0x8F, 0xFD, 0x1D, 0x6A, 0xC5, 0x30, 0xA8, 0xCD, 0x6C, 0xC7,
  0xC8, 0xE7, 0xDF, 0xF4, 0xFA, 0x67, 0x29, 0x56, 0xDF, 0x35, 0x7A, 0xC1,
  0x10, 0x01, 0x84, 0x83, 0x76, 0x6F, 0x9B, 0xA5, 0xAF, 0xA4, 0x90, 0xBD,
  0x8D, 0x43, 0x4C, 0xD6, 0x36, 0x00, 0xB2, 0x06, 0xDA, 0xEB, 0x56, 0xC1,
  0x88, 0xB3, 0xD1, 0x50, 0xBB, 0x6C, 0xF0, 0xD6, 0xAD, 0xBD, 0x3E, 0xEC,
  0xAE, 0x16, 0x2D, 0x6C, 0x82, 0xE4, 0xB5, 0xEB, 0x1D, 0xD8, 0x37, 0xB1,
  0x6B, 0x57, 0xC7, 0x22, 0xFA, 0x46, 0xD4, 0x68, 0x44, 0xBF, 0xD1, 0xAB,
  0xEF, 0xB7, 0x7E, 0x29, 0x2C, 0x00, 0x86, 0x81, 0x81, 0xC8, 0x8E, 0x25,
  0x67, 0xFD, 0xC6, 0x15, 0x97, 0x7E, 0x77, 0x87, 0x7C, 0x6F, 0xE7, 0xE3,
  0x96, 0x2E, 0x5D, 0x09, 0xD4, 0x08, 0x66, 0x06, 0x82, 0x01, 0xFE, 0xBA,
  0x5D, 0x75, 0x4F, 0x0D, 0x8A, 0xA2, 0x88, 0x73, 0xEE, 0x5A, 0x04, 0x01,
  0xC0, 0xE5, 0x86, 0x37, 0x53, 0x0B, 0xE2, 0xFC, 0x89, 0xED, 0x0A, 0x4B,
  0x8A, 0xAD, 0x30, 0x11, 0x9A, 0x03, 0x00, 0xD4, 0xC6, 0x81, 0x99, 0x4E,
  0x3F, 0xD8, 0x6C, 0x55, 0x47, 0xD6, 0x33, 0x00, 0x9E, 0xB7, 0xC3, 0xC0,
  0xF5, 0x7A, 0xE1, 0xE8, 0xFF, 0xFE, 0x6F, 0x03, 0x63, 0x6C, 0x52, 0x11,
  0xA8, 0x63, 0x07, 0x84, 0xBE, 0x9A, 0x73, 0xB7, 0xDC, 0x62, 0x27, 0x4F,
  0x3A, 0xA2, 0x24, 0xBD, 0xD4, 0x9C, 0xE1, 0xCC, 0xC0, 0x3D, 0xF6, 0xC3,
  0xC0, 0xEE, 0x8E, 0x82, 0x8A, 0xA9, 0x4B, 0x8B, 0x69, 0xE3, 0x20, 0x43,
  0x30, 0x00, 0x99, 0x16, 0xD1, 0xD8, 0x7B, 0x9C, 0x43, 0x59, 0xE0, 0xF7,
  0x94, 0x44, 0xC5, 0xF6, 0x28, 0x19, 0x13, 0x4C, 0x8C, 0xCA, 0x8D, 0x85,
  0xA0, 0xE2, 0x1C, 0x4E, 0xCC, 0xA2, 0x3C, 0x4F, 0x05, 0xA9, 0xB8, 0xE8,
  0xDF, 0xD4, 0xA5, 0xE7, 0x14, 0x9F, 0xAD, 0xA3, 0xA3, 0xDD, 0x2F, 0x50,
  0x01, 0x18, 0x77, 0xB0, 0xB9, 0x72, 0x79, 0x6A, 0x11, 0x45, 0xEC, 0x04,
  0xF2, 0xF2, 0xEC, 0x77, 0x95, 0x24, 0x71, 0x7E, 0xAA, 0xF1, 0xCD, 0xBF,
  0xB8, 0x65, 0x60, 0xBE, 0x56, 0x03, 0x04, 0x8C, 0x82, 0x04, 0x04, 0xF1,
  0x15, 0x18, 0x37, 0x78, 0x00, 0x56, 0x3D, 0xBE, 0x99, 0x28, 0xE6, 0x3C,
  0xEA, 0xAA, 0xDC, 0xBA, 0x31, 0xB8, 0xCE, 0xE2, 0x36, 0x20, 0x46, 0x85,
  0x6F, 0xAB, 0x03, 0x50, 0x4C, 0x43, 0x9C, 0x14, 0x12, 0x39, 0xC4, 0xF8,
  0xFE, 0x39, 0x36, 0x3C, 0x50, 0x9C, 0xBD, 0xFD, 0xE8, 0xCF, 0x3F, 0x05,
  0x26, 0x01, 0x83, 0x08, 0x00, 0x66, 0xC8, 0x23, 0x20, 0x0D, 0x02, 0x58,
  0xB8, 0xED, 0xEF, 0xA0, 0xA6, 0xBA, 0xAC, 0x22, 0xDE, 0xCB, 0x8C, 0x9A,
  0x98, 0x33, 0x00, 0x51, 0x97, 0x19, 0x80, 0x98, 0x22, 0x90, 0x19, 0x80,
  0xEE, 0xBD, 0x70, 0x8D, 0x2F, 0x42, 0x03, 0x45, 0xAA, 0x42, 0xBA, 0xA2,
  0xBE, 0xCA, 0x16, 0x35, 0xB9, 0x8B, 0x13, 0x03, 0x35, 0x20, 0x46, 0xA2,
  0x42, 0x54, 0x20, 0xBC, 0xBC, 0x15, 0xDF, 0xF2, 0x82, 0x52, 0x1A, 0xA5,
  0x1C, 0xE5, 0xED, 0x1F, 0xB9, 0xEB, 0xAF, 0x1A, 0x03, 0x8A, 0x2C, 0xDB,
  0x5F, 0x15, 0xC0, 0x20, 0x00, 0xD6, 0x65, 0x00, 0x8A, 0x90, 0x87, 0x90,
  0x83, 0x06, 0x55, 0x67, 0x80, 0x61, 0x10, 0xBD, 0x4D, 0x00, 0x04, 0x0C,
  0x0A, 0x00, 0xE8, 0xF9, 0xBE, 0x9A, 0xEF, 0x06, 0xD1, 0x3A, 0x17, 0x58,
  0x55, 0xD7, 0xC3, 0xCB, 0xEE, 0x96, 0xEF, 0x38, 0xC4, 0x63, 0x12, 0xFB,
  0xC2, 0x4C, 0xEB, 0xB9, 0xD9, 0x41, 0xD7, 0x93, 0xE0, 0x9D, 0x72, 0xB4,
  0xFB, 0x23, 0xE1, 0xEE, 0xEB, 0x3F, 0x75, 0x42, 0x11, 0x72, 0xC4, 0x03,
  0x10, 0x6E, 0x60, 0x9E, 0x02, 0x01, 0x50, 0x0D, 0x08, 0x6A, 0x80, 0x03,
  0xB4, 0xC4, 0x30, 0xC4, 0xB8, 0x4B, 0x74, 0x7A, 0x6F, 0xBE, 0x8C, 0x34,
  0xEE, 0x96, 0x45, 0x81, 0xC2, 0x6C, 0xB4, 0x70, 0x4C, 0x38, 0xA8, 0xAA,
  0x0C, 0xE1, 0x4E, 0x86, 0x40, 0x2C, 0x65, 0xD5, 0x9B, 0x2D, 0xAA, 0x69,
  0x3B, 0xE0, 0xD1, 0x6D, 0xC9, 0xD1, 0xEE, 0x97, 0x00, 0x00, 0xC2, 0x9D,
  0x54, 0x64, 0x7F, 0x65, 0x9C, 0xE8, 0x01, 0xA4, 0x73, 0x3D, 0x14, 0xA4,
  0x00, 0x8A, 0x02, 0x20, 0x98, 0x00, 0x90, 0x75, 0x68, 0x08, 0xE2, 0xC0,
  0x90, 0x16, 0x40, 0xDD, 0x5E, 0xE5, 0xA9, 0xB6, 0x04, 0xEA, 0xFD, 0x41,
  0xF7, 0x40, 0x23, 0x5F, 0x9C, 0x72, 0x90, 0x99, 0x19, 0xC4, 0xF7, 0x58,
  0x79, 0xD6, 0x2C, 0x66, 0xFB, 0xB5, 0x4B, 0x6E, 0xEF, 0xBD, 0xBA, 0x67,
  0xA1, 0x9E, 0x3B, 0xDA, 0xFD, 0xC6, 0x21, 0x02, 0x18, 0x22, 0x80, 0x42,
  0xA9, 0x05, 0x31, 0x80, 0x89, 0x51, 0x40, 0x41, 0x8A, 0xA2, 0x0E, 0x02,
  0x82, 0xA1, 0x80, 0xB9, 0x8A, 0xA8, 0x34, 0xA8, 0x01, 0x1C, 0x80, 0xED,
  0xDF, 0x38, 0x30, 0x5E, 0xDD, 0x56, 0x7D, 0xBF, 0xBF, 0xD3, 0x6F, 0xDD,
  0xB5, 0x98, 0x5B, 0xDD, 0x68, 0x14, 0x0B, 0x00, 0x48, 0x05, 0x50, 0x01,
  0x02, 0x26, 0x00, 0x98, 0x55, 0x53, 0xE2, 0x35, 0x4A, 0x2E, 0x4D, 0x72,
  0x2D, 0x8D, 0x33, 0x97, 0x14, 0x47, 0xB9, 0x9F, 0xE4, 0x04, 0x03, 0x15,
  0x53, 0xDF, 0x68, 0x94, 0x31, 0x06, 0x88, 0x39, 0xAB, 0x39, 0xC1, 0x03,
  0xC8, 0x1C, 0x07, 0x15, 0x0A, 0x28, 0xE2, 0xCC, 0x4C, 0x40, 0x31, 0xF5,
  0x6F, 0x23, 0xC2, 0x51, 0x55, 0x66, 0x20, 0x00, 0x9D, 0x5F, 0x52, 0xED,
  0x76, 0x5C, 0x9C, 0x4E, 0x8D, 0xF4, 0x5B, 0xF5, 0x6D, 0x5B, 0xCB, 0xC2,
  0xC7, 0x62, 0x00, 0x60, 0x48, 0x77, 0xD7, 0x74, 0x1D, 0x23, 0xA0, 0x18,
  0x00, 0xD6, 0xEB, 0xBB, 0x22, 0x64, 0x91, 0x84, 0x66, 0x1D, 0x29, 0x3E,
  0xBE, 0xB9, 0x75, 0x94, 0xF7, 0xFF, 0x18, 0xC8, 0xD8, 0x7E, 0x56, 0x35,
  0x86, 0x0D, 0xB0, 0xD9, 0x9B, 0x4B, 0x6F, 0xA2, 0x54, 0x12, 0x04, 0x20,
  0xFF, 0x06, 0x05, 0x00, 0x0A, 0x88, 0x61, 0x80, 0x98, 0x00, 0x12, 0x7C,
  0x9E, 0x5D, 0xB1, 0x72, 0x51, 0x69, 0x82, 0xA9, 0xF3, 0x1E, 0x6C, 0x64,
  0x61, 0x88, 0xC5, 0x97, 0x32, 0x4E, 0x29, 0x49, 0xA2, 0xA9, 0x77, 0x82,
  0x61, 0x62, 0x40, 0x05, 0x56, 0x4F, 0xEE, 0x1F, 0x1D, 0x75, 0xA8, 0x09,
  0x86, 0x51, 0xF5, 0x45, 0xCA, 0xC8, 0xC1, 0x57, 0x1A, 0x6E, 0xB7, 0xAB,
  0xAD, 0xCA, 0xA2, 0xC2, 0x1F, 0xE5, 0x7E, 0xBF, 0x03, 0x26, 0x97, 0xAD,
  0x1C, 0x2A, 0xCC, 0x81, 0xD2, 0x1E, 0x9E, 0xBE, 0x51, 0x70, 0x68, 0x31,
  0x08, 0x40, 0xDF, 0x0A, 0xEE, 0x64, 0x86, 0x80, 0x98, 0x18, 0xA2, 0x90,
  0x65, 0x71, 0x30, 0x11, 0x33, 0xB0, 0xC8, 0x19, 0xF8, 0x16, 0xBE, 0x6B,
  0x36, 0x34, 0x02, 0x02, 0x38, 0x07, 0x14, 0x65, 0x68, 0x26, 0x54, 0x26,
  0x06, 0x69, 0x50, 0x3F, 0xD5, 0x1D, 0x6D, 0x3B, 0x35, 0x0C, 0x2B, 0x73,
  0x9F, 0xBB, 0x18, 0xC4, 0xCA, 0x51, 0xDD, 0x46, 0x70, 0x31, 0xAB, 0xE7,
  0x8F, 0xFA, 0xFC, 0x07, 0xE2, 0x72, 0xDD, 0x48, 0x1A, 0x22, 0x30, 0x04,
  0x06, 0x06, 0xDC, 0x4D, 0xAA, 0xE0, 0x01, 0xC0, 0x5D, 0xCF, 0x9D, 0x14,
  0x30, 0x67, 0x2A, 0x26, 0x06, 0x64, 0xBF, 0x3F, 0x72, 0xA0, 0x5D, 0x5E,
  0xF6, 0xD0, 0xCA, 0x0C, 0xE2, 0xBD, 0x11, 0xCC, 0xE7, 0x8F, 0xEE, 0x67,
  0xA1, 0x39, 0x24, 0x26, 0x00, 0x42, 0xDD, 0xED, 0xE7, 0x41, 0x96, 0x0A,
  0x66, 0x18, 0xB8, 0xD8, 0x88, 0xEB, 0xBD, 0x9D, 0x71, 0x31, 0xB0, 0xB2,
  0xA4, 0x97, 0x38, 0x20, 0x7C, 0xB9, 0x2D, 0x61, 0xB0, 0xA8, 0xAC, 0x0E,
  0xA8, 0x1C, 0xE5, 0xEB, 0x1F, 0x65, 0xFB, 0xDF, 0xC7, 0x0B, 0x07, 0x1C,
  0x00, 0xA2, 0x60, 0x30, 0xB9, 0x77, 0xF7, 0x42, 0x92, 0x5F, 0x5D, 0x0D,
  0xC8, 0x8E, 0x8F, 0xDF, 0xD5, 0x8E, 0x1A, 0x22, 0x2A, 0x06, 0x80, 0x9E,
  0xF9, 0xD4, 0xC9, 0xD4, 0x13, 0xC7, 0xE3, 0x66, 0xB3, 0xF5, 0xEE, 0xAC,
  0x81, 0xDC, 0xFE, 0xF3, 0x53, 0xDE, 0x92, 0x61, 0x01, 0x4C, 0x08, 0xBD,
  0xA2, 0x2C, 0x2D, 0x75, 0xF5, 0xD2, 0xD4, 0x0C, 0x00, 0xF6, 0x75, 0xC4,
  0x09, 0x7E, 0x69, 0x25, 0x68, 0x51, 0xE7, 0x24, 0x82, 0x58, 0x3F, 0x9A,
  0x98, 0x15, 0x3F, 0x71, 0x7E, 0xC7, 0x94, 0xBD, 0x33, 0xEE, 0x68, 0xCF,
  0x7F, 0xD1, 0x59, 0x73, 0x41, 0x0C, 0x01, 0xD4, 0x70, 0x42, 0x18, 0x49,
  0xDD, 0xC4, 0x18, 0xE3, 0x00, 0x3A, 0xC1, 0x41, 0x4E, 0xC1, 0x00, 0xC0,
  0x10, 0x13, 0x43, 0x57, 0xCD, 0x47, 0x40, 0xAD, 0xFB, 0x99, 0x4C, 0xA2,
  0x51, 0xA0, 0xF3, 0xFD, 0xBE, 0xB9, 0xB4, 0xA1, 0x4E, 0x30, 0x8C, 0xFD,
  0xA5, 0x49, 0x63, 0x30, 0xDB, 0x23, 0x4E, 0x95, 0x83, 0x62, 0x3C, 0x44,
  0x23, 0x25, 0xC4, 0xB3, 0xA1, 0x74, 0x51, 0x2D, 0xE6, 0xE7, 0x7C, 0xBC,
  0x47, 0x10, 0xB4, 0x8E, 0x01, 0x38, 0xCA, 0xFD, 0x92, 0xF5, 0x2B, 0x27,
  0x60, 0x6E, 0xBA, 0x44, 0xE2, 0x91, 0xDA, 0x3B, 0x69, 0x2C, 0x63, 0x62,
  0xC9, 0x3E, 0x80, 0x70, 0x03, 0x1C, 0xBE, 0xFB, 0x03, 0x01, 0x0C, 0xC0,
  0xA7, 0x31, 0x80, 0x69, 0x9F, 0x26, 0x18, 0x30, 0xF5, 0xB2, 0xD2, 0xA5,
  0x2D, 0xB1, 0xE0, 0x1C, 0x88, 0xA9, 0x4F, 0xDB, 0x99, 0xE4, 0x45, 0x53,
  0x94, 0x43, 0x62, 0x1C, 0x8D, 0xB6, 0x18, 0x65, 0xAF, 0xD6, 0xA8, 0x2C,
  0x4B, 0x9F, 0xCD, 0x55, 0x6E, 0xA2, 0x7D, 0xC7, 0xD1, 0xA0, 0x72, 0xD4,
  0x8F, 0x7F, 0xCD, 0x3B, 0x87, 0xDA, 0xDC, 0xE4, 0x3F, 0x7F, 0x73, 0xFB,
  0x77, 0xB7, 0x7D, 0xED, 0x1B, 0xD3, 0x62, 0xC4, 0xCD, 0xE5, 0x8B, 0x3C,
  0x00, 0x1D, 0xE3, 0x6E, 0xC4, 0x21, 0x00, 0x06, 0xE9, 0xB0, 0x01, 0x60,
  0x1C, 0xD2, 0xB7, 0x32, 0xC4, 0x4D, 0x70, 0x51, 0x55, 0x80, 0xC9, 0xC8,
  0xF8, 0x82, 0x0C, 0xBA, 0x1A, 0x61, 0x06, 0x60, 0x98, 0x87, 0x81, 0x01,
  0x4C, 0xCB, 0xBA, 0x08, 0xAE, 0xE8, 0xBA, 0xAC, 0x28, 0x0C, 0x76, 0x2A,
  0xF4, 0x31, 0xC4, 0x1B, 0x1C, 0xED, 0x7E, 0x50, 0xA3, 0x33, 0xB9, 0xE5,
  0xFA, 0x65, 0x0B, 0xDC, 0x38, 0x8B, 0xFC, 0x75, 0xDF, 0xEC, 0x29, 0x51,
  0x73, 0xED, 0x14, 0x00, 0xEE, 0x2A, 0x05, 0x40, 0x01, 0x0C, 0x01, 0x04,
  0x00, 0xF4, 0x94, 0x88, 0xBB, 0x2B, 0x9F, 0x59, 0x49, 0x1A, 0x83, 0x59,
  0x2A, 0x85, 0x09, 0x8D, 0x54, 0xC1, 0x4A, 0x37, 0x00, 0x02, 0x98, 0x98,
  0x45, 0xAD, 0xC1, 0x46, 0x20, 0xA9, 0x43, 0xDF, 0x7C, 0xE8, 0x25, 0x26,
  0x54, 0xB1, 0x9B, 0x6E, 0x00, 0xCD, 0xC7, 0x20, 0x82, 0xC9, 0xD1, 0xEF,
  0x2F, 0xA1, 0xDC, 0x72, 0xF1, 0x75, 0x14, 0x66, 0x00, 0x69, 0xFF, 0xFB,
  0x07, 0x4C, 0xA3, 0x64, 0x3D, 0x00, 0x86, 0xBB, 0xB7, 0x87, 0x18, 0x9E,
  0x98, 0x71, 0x37, 0x6E, 0x46, 0x6B, 0x57, 0x4D, 0xD7, 0x20, 0x16, 0x27,
  0x65, 0x10, 0x10, 0x28, 0xCB, 0x58, 0x00, 0xCC, 0x30, 0x43, 0x86, 0xE3,
  0x60, 0x65, 0xA7, 0xEA, 0x3B, 0x97, 0x4F, 0x87, 0x52, 0xC1, 0xEA, 0xAC,
  0x8A, 0x01, 0x01, 0x27, 0x04, 0xB3, 0xA3, 0xDE, 0x0F, 0xF3, 0x97, 0xD7,
  0x50, 0x03, 0xE2, 0x20, 0x8F, 0x8B, 0x2D, 0xB7, 0x47, 0xC1, 0x06, 0x17,
  0x01, 0x32, 0x05, 0x0A, 0xE0, 0x00, 0xC3, 0xC4, 0x71, 0x87, 0xC8, 0x09,
  0x87, 0x93, 0xF9, 0xE7, 0x84, 0x3A, 0x42, 0xF3, 0x0A, 0x03, 0x97, 0xD6,
  0x15, 0x02, 0x54, 0xCE, 0x3B, 0x05, 0xC3, 0x00, 0x4C, 0xB1, 0x92, 0xB2,
  0x47, 0x98, 0x9F, 0x77, 0xA2, 0x95, 0x73, 0xA8, 0xB9, 0x08, 0x70, 0x12,
  0x14, 0x15, 0x38, 0xEA, 0xFD, 0xC9, 0xAF, 0x5E, 0x1F, 0x2A, 0x0E, 0x32,
  0x91, 0x86, 0xC1, 0xB6, 0x2B, 0xBA, 0x4E, 0x86, 0x01, 0x4D, 0xC1, 0x01,
  0x28, 0x20, 0x2A, 0xC6, 0x41, 0x0E, 0x3D, 0x63, 0x80, 0xBB, 0xB1, 0xF9,
  0xBC, 0x34, 0x44, 0x42, 0xAF, 0x36, 0x30, 0x49, 0xA9, 0x0D, 0x24, 0xE0,
  0x84, 0xBA, 0x30, 0xC3, 0xD4, 0xB4, 0x36, 0xED, 0x49, 0xBF, 0x5F, 0x75,
  0x3A, 0x95, 0x17, 0x6F, 0x51, 0x2D, 0x42, 0xBF, 0x9D, 0x38, 0x04, 0xAD,
  0x4C, 0x4A, 0x77, 0x3F, 0xF4, 0x73, 0x5D, 0x55, 0xB3, 0x96, 0x34, 0x8E,
  0x17, 0xAD, 0x5E, 0xBB, 0x76, 0x51, 0xEC, 0x63, 0x63, 0x7A, 0x4B, 0x17,
  0x01, 0xCA, 0x1B, 0xB8, 0x8B, 0x0A, 0x02, 0x00, 0x4E, 0x61, 0xFD, 0x3D,
  0xFA, 0x5D, 0xD7, 0xC8, 0x62, 0xEF, 0xBC, 0x75, 0xFA, 0x01, 0x20, 0x72,
  0x25, 0x58, 0x36, 0xD8, 0xA4, 0x0C, 0x98, 0x61, 0xA6, 0x71, 0x16, 0x8A,
  0xB8, 0x97, 0x57, 0x51, 0x92, 0x78, 0x81, 0x46, 0x5E, 0x10, 0xD7, 0x44,
  0x83, 0x11, 0x46, 0x1D, 0x24, 0x54, 0x0E, 0x7F, 0xD4, 0xFB, 0xC3, 0x9C,
  0x3A, 0x37, 0x3B, 0xB8, 0x73, 0xC7, 0xF1, 0xCB, 0x16, 0x8E, 0x8D, 0x2F,
  0x3F, 0xF5, 0x51, 0x0F, 0x1D, 0x89, 0x28, 0xB6, 0xF4, 0x05, 0x30, 0x40,
  0x39, 0x44, 0x4C, 0x38, 0x48, 0x1D, 0x51, 0xAA, 0xDC, 0x4D, 0x77, 0xB8,
  0x31, 0x32, 0x1A, 0x39, 0x2F, 0x9E, 0xBC, 0x57, 0x9A, 0x19, 0x2E, 0x2A,
  0x95, 0x64, 0xB0, 0x6D, 0x3E, 0x8E, 0xC1, 0xCC, 0xEA, 0xDE, 0x6C, 0xED,
  0xE7, 0x35, 0xF7, 0x91, 0xCF, 0x01, 0xAA, 0x48, 0xEB, 0x3C, 0x8A, 0x5C,
  0x73, 0x77, 0xE5, 0xB3, 0xA0, 0xD4, 0x31, 0xBB, 0xEC, 0xA8, 0xF7, 0x4B,
  0x0A, 0xB3, 0xA5, 0x1F, 0x1E, 0xFA, 0x7A, 0x47, 0x31, 0x2F, 0x9A, 0x9C,
  0x7A, 0xBC, 0x50, 0x6C, 0x4B, 0x05, 0x72, 0x53, 0x1C, 0x07, 0x99, 0x18,
  0x02, 0x80, 0xC3, 0xD4, 0x0D, 0x72, 0x77, 0x16, 0xC8, 0x11, 0x27, 0x22,
  0xDE, 0x57, 0x79, 0x14, 0xCC, 0xCC, 0xC5, 0x1A, 0xCC, 0x14, 0x2F, 0x66,
  0xA6, 0x21, 0xB1, 0x12, 0x99, 0x77, 0x16, 0xEA, 0x20, 0x2E, 0x06, 0x91,
  0x5A, 0x93, 0x46, 0xD2, 0x1A, 0x6E, 0x3E, 0x6C, 0x74, 0xF7, 0x40, 0xB7,
  0x16, 0x17, 0xED, 0x6E, 0x72, 0xD4, 0xFB, 0x49, 0x54, 0xAB, 0x8D, 0x4D,
  0x44, 0xA7, 0x0C, 0xCC, 0x10, 0x59, 0x78, 0xD6, 0x0C, 0xD3, 0x37, 0x28,
  0x77, 0x52, 0x40, 0xCC, 0x81, 0x61, 0xA0, 0x18, 0x17, 0x26, 0xDC, 0x5D,
  0xF8, 0x8D, 0x1E, 0x20, 0x4E, 0xC0, 0x45, 0xF5, 0x54, 0x55, 0x99, 0xD6,
  0xE6, 0x43, 0x6D, 0x60, 0x66, 0x16, 0x82, 0x76, 0x4B, 0xB1, 0x4E, 0xEC,
  0x0A, 0xA9, 0xCD, 0x7C, 0x8E, 0x97, 0x3A, 0x6A, 0x44, 0xD9, 0x48, 0x7B,
  0xE1, 0x82, 0xE6, 0xE0, 0x43, 0x7C, 0x24, 0x12, 0x2E, 0xDD, 0xEF, 0xEF,
  0x87, 0xFE, 0xA1, 0x24, 0xF3, 0x3B, 0x1D, 0x48, 0x25, 0x80, 0x08, 0x10,
  0x9F, 0x17, 0xB9, 0xDB, 0x02, 0x70, 0xFD, 0x61, 0x5F, 0x5B, 0xCC, 0x44,
  0x10, 0x00, 0x21, 0x8B, 0xB9, 0x1B, 0xE9, 0xD2, 0x74, 0xFD, 0x26, 0x86,
  0x88, 0x08, 0x45, 0xBF, 0x9C, 0xEF, 0x87, 0x4A, 0x1D, 0xB9, 0x82, 0x85,
  0x60, 0x0D, 0x2D, 0x12, 0xED, 0x46, 0xD6, 0xF3, 0x16, 0xEA, 0xCA, 0xA2,
  0x48, 0x43, 0x23, 0xF1, 0xC3, 0x0B, 0xBD, 0x9B, 0x65, 0xE1, 0xE9, 0xC1,
  0x37, 0x92, 0x72, 0x7E, 0x75, 0x72, 0xF4, 0x8F, 0x7F, 0xC1, 0xFF, 0xF6,
  0x6B, 0x53, 0x07, 0x18, 0xE0, 0x0C, 0xC4, 0xF0, 0x3C, 0xE4, 0xBB, 0x43,
  0x35, 0x9A, 0x7D, 0xA8, 0x50, 0x1C, 0x0A, 0x26, 0x28, 0x82, 0x09, 0x80,
  0xD3, 0x6C, 0xD0, 0xB8, 0x1B, 0x5B, 0xF3, 0xC4, 0x2E, 0xAD, 0xAE, 0x62,
  0x60, 0x12, 0x61, 0xFD, 0xB4, 0x25, 0x3D, 0xA7, 0xB8, 0x3C, 0x8E, 0xCC,
  0xA0, 0x9B, 0x37, 0xCA, 0x7E, 0x24, 0xF3, 0x51, 0xD9, 0x28, 0x2A, 0x27,
  0x51, 0x29, 0x4D, 0x6B, 0x0C, 0x48, 0x1F, 0x0F, 0x33, 0x07, 0x28, 0xA2,
  0xB4, 0x66, 0xEB, 0x02, 0x77, 0x3F, 0xCC, 0xBF, 0x75, 0x3A, 0x09, 0x0E,
  0x2C, 0x05, 0x05, 0xCC, 0xC0, 0x27, 0x9B, 0xA7, 0x76, 0x63, 0xFF, 0x92,
  0xAC, 0x5A, 0xD4, 0x44, 0xEF, 0x1C, 0xBE, 0x61, 0x88, 0x60, 0x7A, 0x6A,
  0x02, 0xF7, 0xD4, 0x6A, 0xCD, 0xE7, 0xD3, 0x3D, 0x0C, 0x31, 0x5C, 0x15,
  0x0D, 0xE8, 0x6C, 0x19, 0x30, 0x1F, 0xE5, 0x85, 0x82, 0xF6, 0x1B, 0xBD,
  0x9E, 0xD7, 0xB9, 0xBA, 0x04, 0x41, 0xA2, 0xD2, 0x37, 0xDC, 0xE8, 0x68,
  0xEA, 0xBD, 0xC0, 0x1C, 0xF1, 0xB0, 0x16, 0x1D, 0xCB, 0x56, 0x39, 0xEE,
  0x87, 0x7E, 0xBD, 0xDD, 0x0B, 0x0A, 0x22, 0x4E, 0x80, 0x60, 0x60, 0x4A,
  0x6B, 0xEB, 0x42, 0x74, 0x5E, 0xEA, 0x64, 0xC1, 0xAA, 0x05, 0xA3, 0x4E,
  0x55, 0x51, 0x0E, 0x11, 0xDC, 0x71, 0x19, 0xF7, 0x30, 0xF9, 0xA1, 0xF9,
  0x5E, 0xD5, 0x6F, 0x8A, 0x62, 0x66, 0x56, 0x91, 0xE6, 0x73, 0x7D, 0xCC,
  0x08, 0xA4, 0x55, 0x57, 0xB4, 0x68, 0xF4, 0x73, 0x67, 0x9D, 0xE0, 0xA0,
  0xC4, 0xBB, 0x7E, 0x94, 0xF8, 0xB1, 0x0C, 0x89, 0x9C, 0x28, 0xDE, 0xD1,
  0x68, 0x46, 0x73, 0x93, 0x93, 0x5D, 0xEE, 0x8F, 0xF5, 0x8F, 0x3B, 0x6E,
  0x37, 0x60, 0xD2, 0x08, 0xE2, 0x99, 0xA9, 0x76, 0x2C, 0x1F, 0x13, 0x51,
  0xD7, 0x48, 0x01, 0xC3, 0x59, 0xC8, 0x18, 0xF2, 0xF3, 0x36, 0x5F, 0xA8,
  0x02, 0x06, 0x81, 0x6C, 0x98, 0x7B, 0x92, 0x28, 0x38, 0x6F, 0x49, 0x17,
  0x43, 0x09, 0x65, 0x5A, 0x5A, 0xE5, 0x2B, 0x89, 0x1D, 0x26, 0xCD, 0xF9,
  0xB9, 0xB8, 0xD1, 0x2F, 0x63, 0xE6, 0x93, 0x12, 0x40, 0x28, 0x92, 0x28,
  0x1A, 0x73, 0x06, 0x78, 0x0B, 0xE0, 0x6B, 0x06, 0x2C, 0xD4, 0x3D, 0x77,
  0xFF, 0x3C, 0xFF, 0xC1, 0xEC, 0xBB, 0xF7, 0x1A, 0x90, 0x9F, 0x35, 0xB0,
  0x6F, 0x32, 0xF5, 0x37, 0x45, 0xEE, 0xB4, 0x31, 0x1F, 0xD4, 0x9E, 0x53,
  0xF9, 0x8B, 0x3B, 0x20, 0x80, 0x53, 0x27, 0xE2, 0x98, 0x87, 0x8A, 0xA8,
  0x03, 0x4F, 0x5D, 0x16, 0x71, 0x0F, 0x36, 0xBC, 0x32, 0x2A, 0xFB, 0x03,
  0xBD, 0x06, 0xA2, 0xA1, 0x20, 0x55, 0x23, 0xB2, 0x10, 0xC5, 0xE2, 0x10,
  0xED, 0x0C, 0x54, 0x65, 0x5E, 0x99, 0x01, 0x80, 0xAB, 0x53, 0x5A, 0xC3,
  0x0E, 0x10, 0x4F, 0x1D, 0x82, 0x83, 0x9A, 0x7A, 0x7A, 0x6F, 0x69, 0xDC,
  0x1F, 0xEB, 0x5F, 0x24, 0x42, 0x04, 0xB3, 0xAF, 0x7D, 0xE1, 0xDA, 0xF9,
  0x5B, 0xAF, 0x37, 0xEC, 0x9A, 0x39, 0xC1, 0x89, 0x90, 0x83, 0x30, 0x84,
  0x03, 0x87, 0x13, 0xB3, 0x76, 0xA3, 0x31, 0xD8, 0x6E, 0x2C, 0x58, 0xB4,
  0xF0, 0x1A, 0xE1, 0x9E, 0xA4, 0xF4, 0x04, 0x01, 0xC3, 0x20, 0x44, 0x46,
  0x9C, 0x38, 0x1F, 0xD5, 0x45, 0xA8, 0x43, 0xD9, 0x1B, 0xA8, 0x8B, 0xBC,
  0x94, 0x90, 0x00, 0x20, 0x3F, 0xCC, 0x1F, 0x10, 0xC0, 0x2C, 0x28, 0x22,
  0x80, 0xE0, 0x5B, 0xDE, 0x73, 0xBF, 0xF4, 0x1B, 0x1E, 0x33, 0xB0, 0xB1,
  0x45, 0x63, 0xD6, 0x1A, 0x54, 0xAC, 0xFC, 0xEA, 0xB7, 0x0A, 0x11, 0x6C,
  0xFF, 0xCE, 0x86, 0xC8, 0x2C, 0xEA, 0x44, 0xC4, 0x54, 0x43, 0xF0, 0xE0,
  0xBC, 0x03, 0x12, 0xB8, 0xA7, 0xF2, 0x8B, 0x71, 0x70, 0x75, 0x00, 0x30,
  0x49, 0x6A, 0x71, 0x88, 0x08, 0xD6, 0x57, 0xCD, 0x8B, 0xE9, 0xD9, 0xD2,
  0x44, 0x3C, 0x80, 0x10, 0x12, 0xDA, 0x2D, 0x03, 0xC6, 0x31, 0x55, 0x13,
  0xA7, 0xE0, 0x85, 0xEC, 0x91, 0x8D, 0x34, 0xAE, 0xEF, 0x87, 0x7E, 0x7C,
  0xEA, 0x80, 0x02, 0xC8, 0x21, 0x1A, 0x2B, 0x2A, 0x1B, 0xCA, 0x2F, 0x9F,
  0x4A, 0x85, 0xB9, 0x1B, 0xBE, 0x31, 0xD5, 0xF3, 0x02, 0x66, 0xE2, 0x40,
  0x50, 0x04, 0x75, 0xC6, 0x91, 0x68, 0x36, 0xE8, 0x31, 0x01, 0xA8, 0x9D,
  0x10, 0x89, 0x13, 0x9C, 0x2B, 0xB3, 0xE1, 0x34, 0xCB, 0x5C, 0x22, 0x2A,
  0xB5, 0x95, 0x02, 0xA6, 0x69, 0x34, 0x98, 0x99, 0x29, 0x76, 0x40, 0x16,
  0x88, 0x81, 0x08, 0xE0, 0x65, 0x64, 0xE6, 0x71, 0xFF, 0xF6, 0xD1, 0x2F,
  0x24, 0xF5, 0xD1, 0xDF, 0xFE, 0xF3, 0xDB, 0xDE, 0x1B, 0x72, 0x74, 0xCC,
  0x00, 0x8C, 0x90, 0xA2, 0x41, 0xA3, 0xF6, 0x7B, 0x67, 0x6E, 0x7A, 0xBF,
  0xC3, 0xB5, 0x96, 0x25, 0x32, 0x80, 0x38, 0x05, 0x73, 0x0A, 0x86, 0xDA,
  0xF3, 0xFA, 0x02, 0xF7, 0x64, 0x7B, 0x1E, 0x6B, 0x52, 0x35, 0x1D, 0xD6,
  0x8B, 0x93, 0x7E, 0x13, 0xC0, 0xFA, 0x9A, 0xA8, 0x00, 0x41, 0xCC, 0x9B,
  0xAB, 0xF3, 0x9A, 0x10, 0xA5, 0xED, 0x18, 0x11, 0x89, 0x1C, 0x06, 0x60,
  0x50, 0x3B, 0x58, 0x39, 0x39, 0xBB, 0xE6, 0xBC, 0xB6, 0xE8, 0xD0, 0x13,
  0xBD, 0x3B, 0xCA, 0xF3, 0x4F, 0x05, 0x30, 0x10, 0xEC, 0x87, 0x7C, 0x1D,
  0xCC, 0xC5, 0x3A, 0x73, 0x43, 0x04, 0xAA, 0xF5, 0xEC, 0xF5, 0x57, 0x5C,
  0x7B, 0xD5, 0x81, 0x62, 0xD6, 0x01, 0x6A, 0x18, 0x38, 0x99, 0x17, 0xFE,
  0x6F, 0xB2, 0x70, 0x6F, 0x38, 0xF4, 0x39, 0x62, 0x75, 0x66, 0x80, 0x99,
  0xAB, 0x31, 0x33, 0x73, 0xE6, 0xCD, 0xC5, 0x43, 0xCB, 0x16, 0x8B, 0x48,
  0x16, 0x99, 0x81, 0x0B, 0x06, 0x02, 0x4B, 0x58, 0x84, 0x27, 0x84, 0xED,
  0x33, 0x7A, 0x7B, 0xD7, 0xCC, 0x77, 0xFE, 0xB9, 0xE1, 0x8F, 0xF2, 0xED,
  0x9F, 0xEC, 0x5C, 0xB4, 0xC7, 0x0E, 0xAC, 0xA9, 0x9C, 0x00, 0x68, 0x6C,
  0x86, 0x54, 0xCE, 0x75, 0xAA, 0x6F, 0x03, 0x60, 0x3E, 0xAA, 0xB7, 0x17,
  0x7E, 0xBC, 0xBB, 0x52, 0xA5, 0xE5, 0x00, 0xC8, 0x39, 0x12, 0xEF, 0xB7,
  0x9D, 0x05, 0x26, 0x46, 0x9C, 0x3B, 0x00, 0xD4, 0x3C, 0x00, 0x58, 0x93,
  0xCA, 0xD5, 0x95, 0xCB, 0x16, 0xCE, 0x06, 0xAD, 0x23, 0x51, 0xA7, 0xD4,
  0x11, 0x8B, 0x27, 0x98, 0x60, 0x2F, 0x2A, 0x3E, 0x78, 0x54, 0xBE, 0xFE,
  0xF3, 0x06, 0xF2, 0xD1, 0xD6, 0xB9, 0x89, 0x1D, 0xD5, 0xFE, 0x61, 0xB7,
  0x78, 0xFF, 0x00, 0x28, 0x69, 0x63, 0xA5, 0x0E, 0x32, 0xD7, 0xDF, 0x19,
  0x1C, 0x42, 0x3E, 0x82, 0x82, 0x03, 0xFA, 0x59, 0xCA, 0x9C, 0xDE, 0x92,
  0x03, 0x18, 0xFC, 0xD6, 0x7E, 0x8E, 0x28, 0x2C, 0x5B, 0xE5, 0x11, 0x43,
  0x24, 0x78, 0xB8, 0xF3, 0x64, 0x81, 0x04, 0x27, 0x55, 0xF0, 0xE2, 0x45,
  0x73, 0xCB, 0xAA, 0x99, 0x28, 0x6D, 0x44, 0x88, 0x48, 0xED, 0x77, 0x89,
  0x80, 0x89, 0x0B, 0xCE, 0xB3, 0x66, 0x72, 0xC6, 0x66, 0xE2, 0x96, 0x40,
  0xF7, 0xF3, 0x71, 0xEE, 0x8E, 0xE2, 0xFA, 0xB7, 0xE8, 0x17, 0x6F, 0x36,
  0x47, 0xB6, 0xEE, 0x11, 0x27, 0x9D, 0x36, 0xB6, 0x28, 0x4D, 0x16, 0xAC,
  0x7A, 0xD4, 0xC3, 0x06, 0x67, 0x32, 0x13, 0xEF, 0x1C, 0x0E, 0x10, 0xA4,
  0xC8, 0x35, 0xBF, 0x23, 0xDF, 0x0F, 0xAD, 0xE5, 0xC8, 0x8A, 0x6B, 0x6E,
  0xFF, 0x12, 0xA8, 0x88, 0x38, 0x03, 0x10, 0x09, 0x40, 0x68, 0x66, 0x04,
  0x15, 0x01, 0xF1, 0x91, 0xF7, 0xCD, 0xA8, 0x3F, 0x53, 0x28, 0x0E, 0xA9,
  0x09, 0x66, 0x60, 0x2A, 0x0A, 0x8C, 0x0D, 0xEF, 0x28, 0x11, 0x0C, 0xEB,
  0x7E, 0xA4, 0x71, 0x34, 0xFB, 0x49, 0x6C, 0x98, 0xD9, 0x75, 0x8F, 0x5C,
  0x15, 0x0F, 0x89, 0x07, 0x01, 0x4B, 0x4F, 0x7B, 0x7C, 0xBC, 0x6F, 0x68,
  0xEB, 0xC3, 0x12, 0x07, 0x64, 0x7D, 0x20, 0x83, 0x0C, 0xCB, 0x0C, 0xDC,
  0x0B, 0x0A, 0xEE, 0x85, 0xC6, 0xBD, 0x55, 0x97, 0x58, 0x2D, 0x04, 0x01,
  0x01, 0x05, 0xC0, 0xF7, 0xFA, 0x2E, 0x72, 0xAE, 0x56, 0x9C, 0x88, 0x8F,
  0xB2, 0x10, 0x74, 0xAE, 0x1B, 0x02, 0x38, 0xC5, 0x0C, 0x14, 0x80, 0x5B,
  0xB6, 0x1E, 0x28, 0x2E, 0xC6, 0xC0, 0x1A, 0xFD, 0xFE, 0x27, 0x12, 0x3D,
  0x7A, 0xFB, 0x7F, 0xB8, 0xE1, 0x03, 0xF1, 0xE9, 0x89, 0x03, 0x30, 0x87,
  0x39, 0x50, 0xB3, 0x78, 0xEA, 0x85, 0x1F, 0x19, 0xAC, 0x27, 0xB7, 0xF5,
  0x8B, 0xB6, 0x01, 0xD0, 0x6F, 0x00, 0x7D, 0x90, 0x17, 0xAF, 0x8D, 0xB8,
  0x57, 0x12, 0xED, 0x7D, 0xB8, 0x34, 0xFB, 0x31, 0x22, 0x50, 0x04, 0xEA,
  0x04, 0xBC, 0xB9, 0x3A, 0x2C, 0x08, 0xFD, 0xDC, 0xA5, 0x8E, 0xBA, 0x32,
  0xB1, 0x59, 0x37, 0xD4, 0x8A, 0x08, 0xDE, 0x1C, 0x10, 0xC0, 0x51, 0x0D,
  0xF7, 0x5D, 0xCF, 0xFD, 0xC6, 0xCA, 0xB9, 0xE6, 0xDE, 0xAF, 0xAB, 0x2D,
  0x7B, 0xDA, 0xC9, 0xC3, 0x76, 0xD4, 0xE6, 0xCF, 0x40, 0xB2, 0xE2, 0x60,
  0x3E, 0x02, 0x4E, 0xC1, 0x79, 0xA9, 0xB2, 0x0E, 0xF3, 0x69, 0xF3, 0xD4,
  0x47, 0x3D, 0x62, 0x51, 0x12, 0xCA, 0x3E, 0x34, 0x00, 0xF0, 0x5E, 0xE3,
  0x98, 0x7B, 0x67, 0xD5, 0xC2, 0x6F, 0xC6, 0x6A, 0x00, 0x58, 0x10, 0x2F,
  0x95, 0x43, 0x5D, 0xE9, 0x6C, 0xB6, 0x4E, 0x07, 0xA3, 0x7E, 0x89, 0x90,
  0x2C, 0x4D, 0x91, 0xAE, 0xD6, 0x81, 0x60, 0xA0, 0x8A, 0x73, 0x60, 0xD5,
  0xC3, 0x1E, 0x32, 0x34, 0x54, 0x4E, 0xF8, 0xEF, 0x5D, 0x37, 0x3C, 0x3C,
  0x7D, 0xF5, 0x5B, 0xAF, 0x9E, 0xE7, 0xE8, 0xF5, 0x8F, 0x3C, 0x6A, 0x91,
  0x61, 0xFF, 0x49, 0xC0, 0x29, 0xAA, 0x62, 0x2C, 0x65, 0x98, 0x61, 0xAB,
  0xE3, 0x15, 0xA7, 0x6E, 0x3A, 0xE5, 0xF4, 0x53, 0xD6, 0xAC, 0x59, 0xBC,
  0x78, 0xF1, 0xBA, 0x87, 0x9F, 0xB2, 0xF9, 0xB6, 0x71, 0xE3, 0x47, 0xA9,
  0x97, 0x08, 0x11, 0x60, 0x28, 0xC4, 0x4D, 0xAB, 0x40, 0xD5, 0xA7, 0xF5,
  0x7C, 0x6E, 0x63, 0x03, 0x04, 0xAD, 0x7D, 0x1A, 0x47, 0xAE, 0x2E, 0xC4,
  0x83, 0x53, 0x75, 0x06, 0x81, 0x40, 0x01, 0x4D, 0x3E, 0xC5, 0xC7, 0xE7,
  0x6B, 0x65, 0x5C, 0xF8, 0xD3, 0xB9, 0xE2, 0xE8, 0xAD, 0xFF, 0xF0, 0xD9,
  0x8E, 0x78, 0x04, 0x04, 0x44, 0x01, 0x01, 0x9A, 0xAE, 0xF2, 0xCC, 0x7A,
  0x13, 0x8C, 0xA8, 0x06, 0xF0, 0x01, 0x85, 0xD6, 0x85, 0x35, 0x3F, 0x92,
  0x1F, 0x58, 0x10, 0x45, 0x08, 0x52, 0xD6, 0x3E, 0x51, 0x9B, 0xCF, 0xBC,
  0x79, 0x8F, 0x56, 0x4A, 0x12, 0x9B, 0x95, 0xB3, 0xCD, 0xA8, 0xCA, 0x9D,
  0x0D, 0xB4, 0x01, 0x44, 0xC0, 0x5C, 0x0D, 0xE6, 0x1E, 0xC9, 0xCD, 0x7D,
  0x9A, 0xBA, 0xB6, 0x33, 0x82, 0xB8, 0x2D, 0x62, 0x1F, 0x1B, 0x3A, 0x6A,
  0xF3, 0xF7, 0xCF, 0xC0, 0x40, 0x7E, 0x28, 0xDF, 0x7F, 0xFB, 0x0F, 0x1C,
  0xD8, 0x97, 0x4B, 0x27, 0x10, 0x02, 0xE0, 0xF0, 0x0E, 0xE7, 0x3C, 0x04,
  0x00, 0x5C, 0xC5, 0x8F, 0x16, 0xE6, 0x6F, 0xDD, 0x65, 0x18, 0xAA, 0x44,
  0x86, 0x0C, 0xF4, 0xAA, 0xD8, 0x83, 0x4B, 0xD3, 0x28, 0x14, 0x35, 0x79,
  0xEC, 0xE6, 0x82, 0x88, 0x73, 0x6A, 0x60, 0x06, 0xE6, 0x30, 0x03, 0xE0,
  0x78, 0xA0, 0x96, 0x76, 0x55, 0xD9, 0xF5, 0x62, 0xEC, 0x99, 0x39, 0x6A,
  0xFD, 0xA8, 0x0D, 0x04, 0x99, 0xDB, 0x77, 0xDB, 0x15, 0xFF, 0xFA, 0x85,
  0x6B, 0x6F, 0xDD, 0xB3, 0x67, 0xCF, 0xB6, 0x1B, 0xBE, 0xFB, 0xF5, 0xEF,
  0xDC, 0xBE, 0x6F, 0x0E, 0x4C, 0x40, 0xC1, 0x44, 0x45, 0x44, 0x14, 0xB8,
  0x50, 0xE0, 0x47, 0x0B, 0x55, 0xE7, 0xF6, 0x20, 0xD4, 0x1A, 0x09, 0x68,
  0xD9, 0x3E, 0x71, 0xB5, 0x02, 0xB8, 0x38, 0xF1, 0x2E, 0x04, 0x17, 0xA8,
  0x40, 0x22, 0x00, 0xCC, 0xCC, 0x51, 0x99, 0x56, 0x95, 0x81, 0xB9, 0x03,
  0x0C, 0x80, 0x73, 0x61, 0x2D, 0xF0, 0xD2, 0x69, 0x3D, 0x3A, 0xC7, 0x3F,
  0x80, 0x0E, 0xD4, 0xE1, 0xDA, 0x19, 0x73, 0xB2, 0x84, 0xDC, 0x72, 0x00,
  0x8A, 0x68, 0x87, 0xD8, 0xDA, 0xB1, 0xCA, 0x82, 0x08, 0x80, 0x53, 0x40,
  0x8C, 0x56, 0x37, 0xE6, 0xFF, 0x97, 0xCE, 0x36, 0x77, 0x3D, 0x46, 0x0D,
  0x74, 0xCD, 0xF5, 0x27, 0xC6, 0xF1, 0x63, 0x79, 0x6F, 0x22, 0x06, 0x22,
  0x30, 0x9A, 0xF7, 0x04, 0x2C, 0xF6, 0x06, 0x20, 0x0E, 0xCA, 0x66, 0x4C,
  0xF0, 0x29, 0xE0, 0x46, 0x98, 0x5E, 0x1A, 0x07, 0x54, 0xC4, 0x60, 0xE7,
  0xC8, 0xD1, 0xDA, 0xFE, 0xA9, 0xA6, 0xDF, 0xA6, 0x56, 0x03, 0x1E, 0x40,
  0x0C, 0x44, 0xB8, 0xCE, 0x1D, 0x27, 0xF1, 0x86, 0x64, 0x28, 0x20, 0x12,
  0x00, 0x10, 0x55, 0xD7, 0x7C, 0xB2, 0xE7, 0xBE, 0x88, 0xDA, 0x63, 0x12,
  0xAD, 0x48, 0x29, 0x9E, 0x2A, 0xBA, 0x68, 0x70, 0xA2, 0x7C, 0x77, 0x2C,
  0x42, 0x5D, 0xF9, 0x41, 0xB7, 0xA7, 0x12, 0x91, 0xC1, 0x14, 0x73, 0x62,
  0x22, 0xBE, 0xE6, 0x91, 0x02, 0x04, 0x8F, 0xBB, 0xB1, 0xB7, 0x33, 0x59,
  0xB3, 0xD6, 0x00, 0xB9, 0xD9, 0x84, 0xF7, 0xAF, 0x72, 0x47, 0x67, 0xFE,
  0x7E, 0x78, 0xF4, 0xE4, 0x35, 0xC4, 0x15, 0x2E, 0x83, 0xBE, 0x18, 0x00,
  0x95, 0x33, 0xB3, 0xFE, 0x16, 0x91, 0x68, 0x69, 0xAB, 0x5D, 0xC2, 0x10,
  0xCC, 0x52, 0xF4, 0x9F, 0x1B, 0x71, 0x9F, 0x84, 0xFD, 0x6B, 0x4F, 0xBD,
  0xA0, 0x07, 0xB8, 0xE1, 0x7A, 0x70, 0x7E, 0xD9, 0xD4, 0x2B, 0xA1, 0xFC,
  0xB3, 0xCA, 0x34, 0x77, 0x95, 0x60, 0x59, 0x62, 0x62, 0x06, 0x43, 0x33,
  0x2A, 0xC1, 0xC4, 0xD0, 0xED, 0xEB, 0xAD, 0xC2, 0x4C, 0x0D, 0x00, 0x9C,
  0x9A, 0xEC, 0x5C, 0x70, 0x74, 0xB6, 0x7F, 0xED, 0x0F, 0x56, 0xFB, 0x5B,
  0x2E, 0x38, 0x47, 0x2E, 0xE2, 0x82, 0x38, 0x27, 0x75, 0x15, 0xB9, 0x02,
  0x45, 0x48, 0xFD, 0xBE, 0x5B, 0xBE, 0x7F, 0xFD, 0xF7, 0xBE, 0x77, 0xC9,
  0xD7, 0x2E, 0xFD, 0xF2, 0x97, 0x2E, 0x7D, 0x4A, 0x62, 0xDC, 0x37, 0x3A,
  0xFF, 0xA4, 0x1C, 0x40, 0xA7, 0xFA, 0x13, 0x03, 0xCE, 0xB5, 0x20, 0x19,
  0x1A, 0xCD, 0xD8, 0xD0, 0x13, 0x7C, 0x33, 0x53, 0x33, 0x31, 0x03, 0xC0,
  0xB6, 0x01, 0x62, 0x26, 0xEC, 0xDF, 0x13, 0xAF, 0x60, 0x1B, 0x80, 0xAD,
  0x05, 0xDE, 0xBA, 0x5F, 0x8F, 0x4A, 0x7F, 0x32, 0x2A, 0x0C, 0xF5, 0xBD,
  0x8F, 0xB2, 0xA1, 0x4D, 0xAB, 0x4F, 0x7E, 0xD8, 0xFA, 0x87, 0x9D, 0x72,
  0xCA, 0xC3, 0x1E, 0xF1, 0x88, 0x13, 0x9E, 0x36, 0xE6, 0x00, 0xA3, 0xAF,
  0x39, 0xB4, 0x5A, 0xAD, 0x64, 0xB2, 0x3E, 0x75, 0x93, 0xA4, 0xDC, 0x37,
  0x96, 0xEE, 0x60, 0xC6, 0xC1, 0x28, 0xEE, 0x99, 0xBF, 0xE7, 0xA6, 0xF2,
  0x7E, 0xB7, 0x6A, 0x54, 0x51, 0x6B, 0xF8, 0xA6, 0x2C, 0x6D, 0x37, 0x63,
  0x53, 0x40, 0x30, 0x00, 0x21, 0x13, 0x41, 0x01, 0x15, 0xF6, 0x70, 0x27,
  0x93, 0xBA, 0x3C, 0x2A, 0xEB, 0xDF, 0x0D, 0x18, 0x8D, 0x6C, 0x6D, 0x66,
  0x0C, 0x22, 0xB0, 0xB0, 0x91, 0x01, 0x36, 0x3C, 0x70, 0xF6, 0x76, 0x9C,
  0x8A, 0x65, 0x39, 0xE4, 0x64, 0xEC, 0xAA, 0x4F, 0x29, 0xAD, 0xE9, 0xB9,
  0xAF, 0x5A, 0xBF, 0xF0, 0xA2, 0xC7, 0x38, 0x99, 0x72, 0x26, 0x33, 0xB7,
  0xFF, 0x7A, 0x0A, 0x0F, 0xFB, 0x0F, 0x94, 0xA8, 0x09, 0xA0, 0xDE, 0xD4,
  0x39, 0x0E, 0xD2, 0xCE, 0xD5, 0x6A, 0x3D, 0x04, 0x86, 0xBA, 0xBA, 0xE8,
  0xCE, 0x78, 0x83, 0x17, 0xFF, 0x9F, 0xA3, 0x31, 0x7F, 0xED, 0x08, 0x9B,
  0x2E, 0xBC, 0x6D, 0x68, 0x41, 0x73, 0x48, 0xBC, 0x73, 0xAE, 0x9E, 0xC5,
  0x61, 0x88, 0x5B, 0x2D, 0x40, 0x06, 0x19, 0x90, 0xB1, 0xF3, 0xF4, 0x53,
  0x0C, 0xDF, 0x12, 0xEE, 0x2B, 0xB7, 0xE0, 0xBD, 0x75, 0x59, 0x7C, 0xE3,
  0xD2, 0xB2, 0x5B, 0x85, 0xCC, 0xCC, 0x2E, 0xEB, 0x0E, 0x96, 0x8E, 0x83,
  0xCC, 0x54, 0x01, 0x18, 0xC6, 0xFC, 0xCC, 0x8E, 0x5D, 0x13, 0xD3, 0x05,
  0xC8, 0x3E, 0xC2, 0x34, 0x6B, 0xC1, 0x03, 0x02, 0xE6, 0x27, 0xE5, 0x28,
  0xF4, 0x57, 0x14, 0x09, 0xC9, 0x4A, 0xF1, 0xA6, 0x06, 0x8A, 0x02, 0x86,
  0xD8, 0xAE, 0xCE, 0xE6, 0xA6, 0x77, 0x42, 0xDE, 0x47, 0x98, 0x1C, 0x3E,
  0xA3, 0xC0, 0x69, 0x6C, 0xDC, 0x77, 0xD1, 0xF2, 0x17, 0x3C, 0xEB, 0x29,
  0x15, 0x17, 0x8E, 0xD4, 0xBF, 0xA3, 0x20, 0x58, 0xA3, 0x42, 0xDC, 0xDD,
  0xBE, 0x01, 0xD3, 0x33, 0xC3, 0xE0, 0xE3, 0xD8, 0xBB, 0x28, 0x84, 0x5B,
  0x96, 0xAC, 0xD8, 0xB8, 0x0A, 0x9C, 0xEB, 0x46, 0xB0, 0x56, 0x40, 0x42,
  0x7E, 0x14, 0xFA, 0x13, 0xB4, 0xC4, 0xFA, 0xFD, 0x30, 0x10, 0x50, 0x1C,
  0xC3, 0x43, 0x4E, 0xBD, 0x20, 0xCB, 0x46, 0x9B, 0x8F, 0xDC, 0xBC, 0x31,
  0x52, 0xEF, 0x5D, 0xE1, 0xFA, 0xBE, 0x14, 0x94, 0xA7, 0x8E, 0xC2, 0x7D,
  0x27, 0x43, 0x4B, 0xD6, 0xFC, 0xC3, 0x87, 0x97, 0xB7, 0x3B, 0x0E, 0x30,
  0x21, 0xD5, 0x4A, 0x04, 0x00, 0x05, 0x53, 0x33, 0xB0, 0x19, 0x04, 0xC0,
  0xEC, 0x96, 0xAD, 0xFB, 0xD2, 0xDB, 0xAF, 0xDB, 0x07, 0x48, 0xD3, 0x1C,
  0x80, 0x31, 0xD1, 0x3F, 0x1A, 0xE7, 0x7F, 0x8A, 0x06, 0x5B, 0x8A, 0xC6,
  0xE7, 0x2E, 0x1C, 0x34, 0xF5, 0xEA, 0x14, 0x17, 0x7C, 0xF0, 0x95, 0xF9,
  0x4A, 0xCA, 0x01, 0x59, 0xC4, 0x94, 0x00, 0x33, 0x39, 0x88, 0x68, 0xD3,
  0xF8, 0x2F, 0x71, 0x06, 0x6C, 0xAB, 0x0C, 0x10, 0x67, 0x9A, 0x55, 0x91,
  0x70, 0x90, 0xA1, 0x22, 0x20, 0x06, 0x00, 0x6E, 0x7E, 0x3E, 0x68, 0x47,
  0x7C, 0x4C, 0x64, 0x26, 0x38, 0x05, 0xB0, 0x37, 0xFD, 0xCB, 0x51, 0x98,
  0xBF, 0xB5, 0x0D, 0x5D, 0x79, 0x5A, 0xBA, 0x8F, 0x81, 0x00, 0x60, 0x00,
  0xEA, 0x4C, 0x00, 0xB1, 0xB2, 0x6C, 0x0F, 0xB5, 0x1B, 0xCD, 0x00, 0x08,
  0xD9, 0xA0, 0xF1, 0x5F, 0x62, 0x00, 0xEE, 0x77, 0x01, 0x58, 0x77, 0x82,
  0x1B, 0xC2, 0x38, 0x48, 0x15, 0x53, 0xCC, 0x00, 0xC0, 0x10, 0x2F, 0x22,
  0xA6, 0x69, 0x83, 0x70, 0xF8, 0xC3, 0x0D, 0xF5, 0x28, 0xF4, 0xD3, 0x9D,
  0x97, 0xC6, 0xDB, 0x64, 0xD5, 0xFE, 0x79, 0x3F, 0x5C, 0xA1, 0x26, 0x81,
  0x00, 0x0C, 0x3D, 0x05, 0x40, 0x40, 0xC0, 0x79, 0x45, 0x31, 0x95, 0xD9,
  0xB8, 0x31, 0xBB, 0x6B, 0x9B, 0xC2, 0x8F, 0xE6, 0xE2, 0xC4, 0x73, 0x07,
  0x89, 0x05, 0xA8, 0x4E, 0x89, 0xCC, 0x35, 0x3C, 0x4B, 0xB9, 0x83, 0x99,
  0x81, 0xAA, 0x81, 0x61, 0x66, 0x26, 0xA0, 0xC7, 0x6D, 0xDC, 0xE8, 0x68,
  0x64, 0x56, 0x03, 0x08, 0xA7, 0xDA, 0xD1, 0xE8, 0x17, 0xB3, 0xEA, 0x1A,
  0x5D, 0x9B, 0xCF, 0x10, 0x54, 0xC1, 0x04, 0x8F, 0xD9, 0x85, 0x00, 0x66,
  0x60, 0x00, 0xAA, 0xA2, 0x96, 0x7D, 0xE7, 0x33, 0xFF, 0xF0, 0xB1, 0x8F,
  0xBF, 0x23, 0xBF, 0xA9, 0xA3, 0xFC, 0x48, 0xFE, 0x93, 0x9F, 0xFE, 0x5C,
  0xAC, 0x77, 0x76, 0x02, 0xC4, 0x57, 0x57, 0x9D, 0x75, 0xCD, 0x66, 0xBD,
  0x1B, 0xE1, 0x10, 0x0D, 0x6A, 0x60, 0x66, 0x18, 0x66, 0x18, 0x1B, 0x5E,
  0xF9, 0x8C, 0x47, 0x3E, 0xF2, 0xD4, 0xD3, 0x16, 0xB7, 0xBB, 0x39, 0x20,
  0x70, 0x0D, 0x47, 0xA3, 0x3F, 0xAA, 0x02, 0x8D, 0x97, 0x27, 0x9B, 0x6E,
  0x99, 0x9A, 0x1B, 0xAC, 0x2B, 0xC3, 0x08, 0xAA, 0x99, 0xFA, 0xAE, 0x80,
  0x07, 0x01, 0xC2, 0x90, 0x10, 0x4D, 0x7F, 0x71, 0x2E, 0x91, 0x3A, 0x6E,
  0xFF, 0xDD, 0x47, 0xAE, 0x9A, 0xF5, 0xDC, 0x3B, 0x71, 0x17, 0xAB, 0xE9,
  0x27, 0x33, 0x77, 0x8F, 0xCD, 0x20, 0xDF, 0x7B, 0xC1, 0x2B, 0x8E, 0xC3,
  0x99, 0x70, 0x90, 0xAA, 0x9A, 0x99, 0x1D, 0x7C, 0x8B, 0xA9, 0x3C, 0x45,
  0x46, 0x6B, 0x19, 0x1E, 0x5E, 0x79, 0xE2, 0x43, 0xFB, 0x0E, 0x00, 0xE6,
  0xB9, 0x83, 0xE7, 0xA7, 0xA7, 0x7C, 0x43, 0x1C, 0xD5, 0xBB, 0x9E, 0x9C,
  0x6D, 0x4D, 0x5A, 0x95, 0x81, 0x05, 0x73, 0xDD, 0xB3, 0xFE, 0xFC, 0xA2,
  0x7F, 0x4F, 0x06, 0xD4, 0x00, 0x90, 0xEE, 0x17, 0x17, 0xB3, 0xC5, 0x8F,
  0x8F, 0xE4, 0xCB, 0x48, 0x47, 0x6E, 0xF3, 0x5B, 0xFF, 0xF7, 0x3B, 0x3E,
  0x66, 0xDC, 0xAB, 0xF2, 0x96, 0x08, 0xE4, 0x97, 0xFF, 0x49, 0x01, 0xE0,
  0x75, 0x37, 0xED, 0x85, 0x33, 0x97, 0xAD, 0xDB, 0x70, 0x6A, 0x36, 0xBA,
  0xF4, 0xB1, 0xDF, 0xC0, 0x00, 0x1C, 0xEA, 0x14, 0x00, 0x04, 0x03, 0x35,
  0xDB, 0xB0, 0xA9, 0x5D, 0x78, 0x07, 0xE2, 0x9A, 0xCB, 0xBE, 0xB7, 0x60,
  0x9F, 0x21, 0x5C, 0xF0, 0xAE, 0xA3, 0x30, 0x7F, 0x7C, 0x11, 0x70, 0xD7,
  0xBE, 0x6D, 0xD9, 0xAA, 0xF6, 0xC4, 0x5C, 0xEE, 0x25, 0xE9, 0x5E, 0xFD,
  0xFD, 0xB3, 0x82, 0x1B, 0x98, 0xB9, 0xEE, 0xEB, 0xDF, 0xAF, 0xBA, 0x9D,
  0xA8, 0x98, 0xFA, 0xCE, 0xF7, 0x97, 0xEC, 0xDD, 0x35, 0xE2, 0x6E, 0x91,
  0xB9, 0x3E, 0x8E, 0x18, 0x5B, 0xBB, 0x77, 0xB7, 0x59, 0x95, 0x96, 0x69,
  0x12, 0x09, 0xDC, 0xD3, 0x17, 0x3D, 0x80, 0xFB, 0xB4, 0xE7, 0x90, 0x53,
  0x44, 0x56, 0xAC, 0x1D, 0x1F, 0xF4, 0xF1, 0xCC, 0xF2, 0x8E, 0x39, 0x07,
  0x38, 0x70, 0xA0, 0x6A, 0xAA, 0xB6, 0x7A, 0xB5, 0xA9, 0x02, 0x4F, 0x59,
  0x22, 0xA9, 0x07, 0xC0, 0x0D, 0x3D, 0x73, 0xD3, 0x19, 0x00, 0x72, 0x74,
  0x7E, 0xFE, 0xA5, 0x1A, 0x6E, 0x3B, 0x95, 0x4D, 0x5C, 0x33, 0x78, 0x4A,
  0xB2, 0x6E, 0xEB, 0x9B, 0xDA, 0xAD, 0x34, 0xA3, 0xF7, 0xDA, 0x52, 0x9D,
  0x84, 0xB9, 0x21, 0x6F, 0x06, 0xA0, 0x23, 0x6B, 0xAE, 0x18, 0x58, 0x33,
  0x6E, 0x6E, 0xEF, 0xF5, 0x59, 0xF7, 0x21, 0xFA, 0xC4, 0x45, 0xA3, 0x03,
  0x91, 0xD8, 0xA4, 0x56, 0x81, 0xBB, 0xF3, 0x17, 0x47, 0x02, 0xC0, 0xD3,
  0x4A, 0x00, 0xE6, 0xDE, 0xCC, 0xD5, 0x8D, 0xE7, 0xF5, 0x12, 0x4F, 0xD0,
  0xD0, 0xB1, 0xF7, 0x58, 0x90, 0x15, 0x3B, 0x01, 0x50, 0x9C, 0x00, 0x60,
  0x28, 0xAF, 0x90, 0x76, 0xE2, 0x38, 0xA4, 0x68, 0xD7, 0xDF, 0xBD, 0x5C,
  0xF4, 0x7F, 0xAD, 0x3E, 0x3A, 0xFD, 0xE2, 0x87, 0x1D, 0x38, 0x00, 0x8D,
  0xA2, 0x5B, 0x12, 0x03, 0x66, 0x7E, 0x65, 0x03, 0xEA, 0x1C, 0xB5, 0x03,
  0xC0, 0xAF, 0x5C, 0x69, 0xDF, 0x8A, 0xE2, 0xD3, 0xC4, 0xE6, 0xAE, 0x4E,
  0x8A, 0x13, 0x93, 0x6D, 0xFF, 0x58, 0x05, 0x9C, 0x93, 0x6A, 0xBA, 0x2C,
  0x85, 0xC3, 0x68, 0xFA, 0x29, 0x11, 0x03, 0x78, 0x5C, 0xE4, 0x00, 0x3A,
  0xCF, 0x70, 0x67, 0x3C, 0xB4, 0x27, 0x89, 0x03, 0xAD, 0xB4, 0x6B, 0xEF,
  0x36, 0x05, 0x1C, 0x80, 0xE2, 0x00, 0x40, 0x57, 0x3E, 0x53, 0xDA, 0x3E,
  0x0E, 0x1E, 0x00, 0x2A, 0x0B, 0xE4, 0xD7, 0x6F, 0x79, 0xD5, 0xD2, 0xB5,
  0x47, 0x63, 0xFD, 0x83, 0x69, 0x91, 0x35, 0x0E, 0xE5, 0xA7, 0xBE, 0x65,
  0x00, 0xE9, 0x3B, 0x51, 0x14, 0x62, 0xA7, 0xA0, 0xF1, 0xF1, 0x2B, 0x6A,
  0x91, 0x5C, 0xC0, 0x0F, 0xFB, 0xBE, 0xD9, 0xE0, 0xE8, 0x79, 0x2D, 0x6F,
  0x40, 0x9C, 0x0E, 0x57, 0x81, 0xC3, 0xC8, 0xC5, 0x10, 0x14, 0xA8, 0x11,
  0x00, 0xA2, 0x3F, 0x61, 0x41, 0x4F, 0x08, 0x80, 0x8B, 0x5D, 0xBB, 0xFD,
  0xFB, 0x38, 0x56, 0xAE, 0x04, 0xC0, 0x39, 0x96, 0x83, 0xC2, 0xCA, 0x9F,
  0x97, 0x96, 0xDC, 0x99, 0xAF, 0xAA, 0x48, 0xE3, 0x04, 0x16, 0x2C, 0xE5,
  0xE8, 0xF4, 0x53, 0x97, 0x51, 0xDA, 0x4C, 0x22, 0x97, 0xA4, 0xCD, 0x4D,
  0xBE, 0x63, 0x00, 0xAD, 0x96, 0x8F, 0x80, 0xBA, 0xAA, 0xF1, 0xF1, 0xF0,
  0xE6, 0x11, 0x73, 0x73, 0x4A, 0x01, 0xAA, 0x42, 0xA0, 0x1E, 0x1A, 0x58,
  0xF3, 0x27, 0x6F, 0xFF, 0x23, 0x85, 0x8F, 0xD4, 0x2B, 0xC6, 0xBA, 0xDC,
  0x25, 0xD6, 0x20, 0x38, 0x20, 0xC2, 0x00, 0x90, 0x85, 0x83, 0x0B, 0x85,
  0x61, 0x05, 0x0A, 0x62, 0x11, 0x79, 0xC9, 0x3A, 0xD9, 0x71, 0x3B, 0x08,
  0xA0, 0xEC, 0x04, 0xC7, 0xF2, 0x9F, 0x8F, 0xDB, 0x2E, 0xC5, 0x73, 0x88,
  0x99, 0xE0, 0xDA, 0xA7, 0x59, 0x7A, 0xB4, 0xFA, 0x9D, 0x33, 0xF3, 0x49,
  0x1A, 0xF9, 0x88, 0x1B, 0x65, 0x4C, 0x01, 0x74, 0xC3, 0xEA, 0x76, 0x8A,
  0x39, 0xC7, 0xF4, 0xF1, 0x27, 0x9D, 0xDA, 0x76, 0x90, 0x96, 0x96, 0x02,
  0x0E, 0xE2, 0x41, 0x5C, 0x6F, 0xBD, 0x1F, 0x1D, 0xAA, 0x8D, 0x97, 0xB4,
  0xDD, 0x78, 0x11, 0x71, 0x90, 0x55, 0xDE, 0x77, 0x22, 0x1C, 0x35, 0x30,
  0xE0, 0x01, 0xC8, 0xE2, 0x73, 0x61, 0x78, 0xC6, 0x2A, 0xCD, 0x47, 0xCC,
  0x1C, 0xED, 0xE1, 0x0B, 0x35, 0x88, 0xAA, 0x01, 0x4E, 0x40, 0xD7, 0xBD,
  0xE4, 0x97, 0xE2, 0x96, 0xA4, 0x1C, 0x12, 0x42, 0x85, 0xE0, 0xD0, 0xB5,
  0x6D, 0x39, 0x5A, 0xFD, 0x54, 0xDF, 0x05, 0xF1, 0xDE, 0x44, 0x61, 0x7B,
  0x0A, 0x80, 0xAE, 0x3B, 0xF5, 0xA4, 0xD3, 0xCF, 0xDC, 0xF4, 0xF0, 0x87,
  0x3C, 0x61, 0xA4, 0x69, 0x88, 0xC8, 0xDE, 0xC8, 0x8D, 0x1A, 0xA0, 0x50,
  0x82, 0x89, 0xCC, 0xF5, 0xB5, 0x84, 0x48, 0xF4, 0xEC, 0x5D, 0x06, 0xE6,
  0x83, 0x65, 0x5F, 0xFE, 0xF4, 0xA7, 0x06, 0xC4, 0x20, 0x02, 0xCC, 0x00,
  0xB0, 0xB1, 0x31, 0x98, 0x86, 0x72, 0x4F, 0x67, 0xC6, 0x72, 0x49, 0x90,
  0x7A, 0xF5, 0x10, 0xB5, 0xD5, 0xF5, 0x0F, 0xFF, 0x54, 0xA5, 0x3C, 0x7D,
  0xF5, 0x92, 0x76, 0x94, 0x72, 0x27, 0x35, 0x70, 0x20, 0x83, 0x6D, 0x8E,
  0x5E, 0x7F, 0x10, 0x30, 0xA7, 0x02, 0x3C, 0x54, 0x00, 0xA8, 0x1C, 0xCD,
  0x41, 0x3F, 0xEC, 0x1B, 0x4D, 0xE7, 0x31, 0x33, 0xBF, 0x4B, 0xEB, 0x06,
  0x84, 0xBE, 0x22, 0x86, 0xAA, 0x0C, 0xB1, 0xE0, 0x9D, 0xB1, 0x81, 0x58,
  0x12, 0x47, 0x16, 0x7F, 0xF6, 0xD3, 0x5F, 0xCA, 0x3E, 0x65, 0x8E, 0x18,
  0xA0, 0xA6, 0x16, 0x0E, 0x19, 0xF1, 0x82, 0x60, 0xBC, 0xF1, 0x4D, 0xE9,
  0x0C, 0x55, 0xDD, 0xBF, 0xF6, 0xDA, 0x13, 0xCE, 0x5A, 0xBB, 0x74, 0x78,
  0xB4, 0xDD, 0xCA, 0x5A, 0x8D, 0xE1, 0xA5, 0x17, 0xDC, 0x74, 0x60, 0x3E,
  0x89, 0xB9, 0x93, 0x29, 0x60, 0x20, 0xCD, 0xA1, 0xA3, 0xD7, 0xEF, 0x56,
  0x2B, 0xE0, 0x1D, 0x08, 0xCE, 0x03, 0xE0, 0x2E, 0x54, 0x8F, 0x73, 0xDE,
  0x7B, 0x0C, 0xD0, 0xBD, 0x35, 0x49, 0x46, 0x70, 0xD7, 0x05, 0x5A, 0x03,
  0x54, 0x4E, 0xA0, 0xE8, 0xE7, 0x01, 0x24, 0xC8, 0xD9, 0x51, 0xF5, 0x49,
  0x71, 0xFA, 0x49, 0x50, 0x30, 0x20, 0x02, 0x8C, 0x83, 0xF4, 0x19, 0x60,
  0x08, 0x9B, 0x5E, 0xB9, 0xEB, 0x0D, 0x73, 0xFA, 0x07, 0xDB, 0xC2, 0xCD,
  0xDF, 0x61, 0xED, 0x0F, 0xEE, 0x63, 0x7B, 0xEC, 0xA3, 0xCE, 0x3E, 0xFB,
  0xD1, 0x67, 0x3D, 0xA4, 0xDF, 0xFF, 0x4C, 0xE4, 0x0E, 0x9F, 0x84, 0x81,
  0x03, 0xC2, 0x13, 0xE5, 0xE8, 0xF5, 0xDB, 0x9C, 0x02, 0x26, 0x6A, 0x01,
  0xEF, 0x03, 0x80, 0x69, 0xD3, 0x0C, 0xCC, 0x02, 0x20, 0xD6, 0xDF, 0x5A,
  0xBB, 0x66, 0xDB, 0xB4, 0xE8, 0xE2, 0xD7, 0x04, 0xB7, 0x53, 0x9C, 0xC3,
  0x5A, 0x19, 0x66, 0x98, 0xF9, 0x45, 0x1B, 0xA6, 0xB6, 0xEF, 0x30, 0x53,
  0x1C, 0x08, 0x00, 0x91, 0x28, 0x07, 0x59, 0xC7, 0x10, 0x33, 0x2E, 0x1A,
  0x7F, 0xDB, 0xAB, 0x6C, 0xF6, 0x61, 0xB5, 0xED, 0xD8, 0x67, 0x42, 0x5C,
  0x5D, 0xF9, 0x1D, 0x90, 0x9B, 0xAF, 0x72, 0x3E, 0x9B, 0xD3, 0xBB, 0xF2,
  0xD5, 0x70, 0x0E, 0x31, 0x1B, 0xF2, 0x1C, 0xBD, 0x7E, 0x71, 0x97, 0x01,
  0xB8, 0x1A, 0xC3, 0xC6, 0x1B, 0x00, 0x52, 0x39, 0x50, 0xC0, 0xA9, 0x68,
  0x5D, 0x5E, 0x5E, 0xB9, 0xA9, 0xF5, 0x41, 0x7B, 0x57, 0x06, 0x4E, 0x6C,
  0x31, 0xDF, 0xE1, 0xB8, 0x02, 0xBA, 0x88, 0x62, 0xAF, 0x1E, 0x71, 0x64,
  0x6F, 0xFC, 0x97, 0x34, 0x80, 0xDD, 0x35, 0xF7, 0xC7, 0xD4, 0x1C, 0x92,
  0x0E, 0x81, 0xEF, 0xFE, 0x6D, 0xBF, 0x7A, 0xEB, 0xF8, 0x88, 0x1C, 0x7F,
  0x5B, 0xD1, 0x5D, 0x72, 0xC5, 0x97, 0x5B, 0x3A, 0x30, 0xBB, 0x6F, 0x9B,
  0x6B, 0xEC, 0xD8, 0x76, 0x43, 0x23, 0xDA, 0x6E, 0x87, 0xE7, 0xA3, 0x00,
  0xAD, 0x0B, 0xDC, 0x51, 0xEC, 0x37, 0x17, 0x00, 0x3C, 0x98, 0x48, 0x88,
  0x3C, 0x60, 0x72, 0x41, 0x03, 0x54, 0x55, 0xA9, 0x65, 0xE6, 0x72, 0xD1,
  0xE8, 0x49, 0x0D, 0xFA, 0xD7, 0xF5, 0x75, 0xCD, 0x28, 0xBD, 0x1B, 0x34,
  0x19, 0x33, 0xAC, 0x01, 0x08, 0x6F, 0x9F, 0x51, 0x8B, 0x1A, 0xD3, 0xEF,
  0xB9, 0x3D, 0x80, 0x29, 0x02, 0x80, 0xB4, 0x85, 0x43, 0xF4, 0xE9, 0xE6,
  0x60, 0x4B, 0xAB, 0xEF, 0x24, 0x92, 0x2F, 0x7E, 0xE5, 0x2B, 0xE8, 0x6C,
  0x99, 0x67, 0x8C, 0x54, 0x73, 0xC6, 0x78, 0x75, 0x40, 0x98, 0x9F, 0xD4,
  0xC3, 0xF2, 0x9D, 0x53, 0xB0, 0x5F, 0x08, 0x1C, 0xC5, 0x7E, 0xDC, 0x6A,
  0x03, 0x2C, 0x02, 0xD5, 0x68, 0x71, 0x6C, 0x00, 0xE1, 0xDC, 0x86, 0x80,
  0x99, 0xF5, 0xAF, 0xBE, 0xC1, 0x5C, 0x7A, 0x72, 0x24, 0xD5, 0x35, 0x25,
  0xEB, 0x56, 0x84, 0xFE, 0xF5, 0x45, 0xBC, 0xA9, 0x46, 0x8C, 0x1A, 0x82,
  0x4A, 0x28, 0x22, 0x2F, 0xD2, 0xFA, 0xE7, 0x09, 0xEE, 0x1A, 0x7F, 0xE8,
  0x72, 0xA7, 0x72, 0x08, 0x6D, 0x41, 0x5B, 0x82, 0xDD, 0x12, 0xB9, 0xBD,
  0xB2, 0xB3, 0xE7, 0xB8, 0xEA, 0x4B, 0x7B, 0xFC, 0x2D, 0xD7, 0x4F, 0x9E,
  0x74, 0x7A, 0xB7, 0xD7, 0xCA, 0xBE, 0x31, 0xA7, 0x80, 0x16, 0x6A, 0xE0,
  0x14, 0x81, 0xC1, 0xAE, 0x1D, 0xD5, 0x7E, 0xAB, 0xBE, 0x0D, 0xE0, 0xA0,
  0x0E, 0x2E, 0x5B, 0x56, 0x03, 0x58, 0xFC, 0xE4, 0x5F, 0x1D, 0x68, 0xB9,
  0xFE, 0x13, 0xCF, 0xFE, 0xB5, 0x17, 0xBD, 0xE8, 0x45, 0x7F, 0xBC, 0xAC,
  0x3F, 0x73, 0x55, 0x99, 0x6E, 0x5E, 0xA6, 0xE1, 0x9A, 0x72, 0xF0, 0xA4,
  0x06, 0x36, 0xA7, 0xBF, 0xEF, 0xF9, 0x77, 0x2D, 0xAD, 0xD4, 0xD8, 0x09,
  0xC5, 0xAC, 0x01, 0x18, 0x02, 0x48, 0xE4, 0xB8, 0x93, 0x5C, 0xD0, 0x14,
  0xF9, 0xE8, 0xEF, 0x87, 0x8E, 0xA5, 0x9C, 0xDE, 0xCA, 0x4E, 0x48, 0xFD,
  0x7A, 0xBA, 0xDB, 0x7B, 0xC9, 0x86, 0x9A, 0xDC, 0x55, 0x81, 0xFE, 0xE2,
  0x29, 0x43, 0xAB, 0xCA, 0x0C, 0xC0, 0x81, 0x85, 0x27, 0x7A, 0x0E, 0x17,
  0xF1, 0xD3, 0xA6, 0x6B, 0x96, 0x00, 0x52, 0xFB, 0x90, 0x26, 0x3E, 0x6A,
  0x01, 0x40, 0x64, 0x4F, 0x8E, 0xFB, 0x95, 0x2C, 0xA0, 0x4F, 0x94, 0xD0,
  0xA9, 0x7A, 0xC7, 0xD9, 0xFF, 0x62, 0xE6, 0x7A, 0x36, 0xC6, 0x99, 0x0E,
  0xEF, 0x7A, 0xD3, 0x7A, 0x0F, 0x4F, 0x0D, 0x51, 0xAC, 0x22, 0x32, 0x3C,
  0xBB, 0xF2, 0xD6, 0x4F, 0xBD, 0xD0, 0x03, 0x20, 0x26, 0x10, 0x73, 0x27,
  0x09, 0x3F, 0xFF, 0x51, 0xB9, 0x7D, 0xD3, 0xDF, 0x6E, 0x79, 0xF7, 0xE4,
  0x75, 0x73, 0xB3, 0xEB, 0xE8, 0x0F, 0x5F, 0xBD, 0x76, 0x68, 0x85, 0x3B,
  0xB0, 0x7B, 0x45, 0x36, 0x70, 0xAB, 0x73, 0x19, 0x7C, 0x7F, 0xB4, 0xA5,
  0x06, 0x80, 0x03, 0xC4, 0x9E, 0xFB, 0x2C, 0xEE, 0x46, 0xF8, 0xA9, 0x4B,
  0xCE, 0xDD, 0xAA, 0x6A, 0x55, 0xEC, 0xE2, 0x48, 0xF4, 0xB6, 0x79, 0xE3,
  0x10, 0x01, 0xE3, 0x0E, 0x52, 0xA7, 0xD2, 0x3A, 0xFB, 0xE9, 0xCB, 0x98,
  0x7A, 0xB5, 0x46, 0x85, 0x46, 0x22, 0x14, 0x7E, 0x90, 0x3A, 0x4D, 0x44,
  0x22, 0xAD, 0x7E, 0x67, 0x39, 0x82, 0x00, 0xF0, 0xD4, 0x92, 0xC3, 0x58,
  0xF6, 0x77, 0xCC, 0xBD, 0xE6, 0x9D, 0xFD, 0xCF, 0xF5, 0xAE, 0xAD, 0x4F,
  0x9B, 0xBC, 0xAD, 0xE1, 0x9E, 0x72, 0xE9, 0x84, 0xF8, 0xC6, 0xEC, 0xE9,
  0x27, 0xFF, 0xB3, 0x3C, 0x99, 0x6F, 0xCF, 0xAE, 0x6E, 0xFF, 0xE2, 0xE1,
  0x0B, 0xBD, 0xFD, 0x54, 0x85, 0xA3, 0xBA, 0xFE, 0x91, 0xF0, 0xAD, 0x15,
  0x49, 0xA3, 0xD9, 0x4E, 0x9A, 0xDE, 0xBB, 0x48, 0x84, 0x3B, 0x98, 0x19,
  0x77, 0x32, 0x5F, 0x57, 0xFD, 0xCB, 0x5E, 0xF3, 0xDC, 0xE7, 0xBD, 0x22,
  0x58, 0x15, 0x3B, 0xA0, 0x22, 0x23, 0x10, 0x01, 0x38, 0x47, 0x40, 0x00,
  0x8C, 0xD0, 0xE5, 0x70, 0xAE, 0xFB, 0x18, 0x06, 0xDF, 0xDD, 0x6F, 0xFB,
  0x3D, 0x1B, 0xC6, 0x6C, 0x32, 0x5A, 0xBF, 0x7E, 0xEB, 0xD0, 0x88, 0x0B,
  0xEB, 0x4F, 0x59, 0x7F, 0xF5, 0x7C, 0x7E, 0xF3, 0xCD, 0xC9, 0xF4, 0xD6,
  0x75, 0xFD, 0x01, 0x70, 0xCE, 0x99, 0x01, 0xED, 0x73, 0x95, 0xA3, 0xDD,
  0x6F, 0xF5, 0xEE, 0x9F, 0x5F, 0x1C, 0x45, 0x69, 0x34, 0xB6, 0xC8, 0x46,
  0xE4, 0xE6, 0x92, 0x7B, 0x15, 0xBA, 0x02, 0x1A, 0x42, 0xA8, 0xC4, 0x50,
  0x8D, 0x13, 0x34, 0x02, 0x20, 0x50, 0x45, 0x01, 0x91, 0xA7, 0x3E, 0xF6,
  0xD9, 0xE1, 0x9C, 0x94, 0xC3, 0x59, 0xB4, 0xF4, 0xD7, 0x71, 0x03, 0x6C,
  0x18, 0xBC, 0x69, 0x70, 0xFB, 0x7C, 0x14, 0x3B, 0xF2, 0xF9, 0xFA, 0xC4,
  0x2B, 0x77, 0x5D, 0x4B, 0x56, 0x04, 0x89, 0x45, 0xAF, 0xFD, 0xF4, 0x1C,
  0x04, 0x00, 0xA3, 0x7D, 0xAE, 0xE7, 0xA8, 0xF7, 0x23, 0x32, 0xF8, 0x34,
  0x11, 0x89, 0xA6, 0x74, 0x9C, 0x61, 0x84, 0x7B, 0x23, 0x55, 0xE5, 0xBC,
  0x98, 0x26, 0x39, 0x66, 0x5A, 0x91, 0xA1, 0x78, 0x33, 0x08, 0x46, 0x5B,
  0xB1, 0xFD, 0x8F, 0x2D, 0xE3, 0xE9, 0xA7, 0x79, 0xE5, 0xEE, 0x42, 0xFF,
  0xD7, 0x05, 0x56, 0x9E, 0xBE, 0x79, 0xA8, 0xB5, 0xA9, 0x09, 0x4C, 0x14,
  0xAD, 0x6B, 0x5B, 0x8B, 0xAF, 0xD3, 0x75, 0xEE, 0xFA, 0xDB, 0xAE, 0xE3,
  0x14, 0x7A, 0xF9, 0x30, 0x02, 0x82, 0x3C, 0xE7, 0x49, 0x9E, 0xFB, 0xA1,
  0x9F, 0xE4, 0xA2, 0xF1, 0xE5, 0x82, 0x30, 0x77, 0x80, 0xF6, 0x2A, 0xEE,
  0x95, 0x49, 0x98, 0x16, 0x69, 0xD0, 0x01, 0x91, 0x9A, 0x24, 0xA6, 0x8A,
  0x31, 0xC0, 0x8C, 0x8F, 0xEC, 0x42, 0x17, 0x0A, 0x12, 0x42, 0xC4, 0x3D,
  0xD5, 0xBD, 0xB6, 0x11, 0xDD, 0x08, 0x0B, 0xF3, 0x85, 0x6A, 0x2C, 0x80,
  0x6C, 0xC3, 0x7C, 0x36, 0xDF, 0xD8, 0xD0, 0xEA, 0x8E, 0x9D, 0x50, 0x99,
  0x2B, 0xA6, 0xC1, 0x8C, 0xD6, 0x73, 0xF3, 0x88, 0xFB, 0x47, 0x28, 0x3F,
  0xF4, 0xC4, 0xC7, 0x3F, 0xE4, 0xB4, 0x87, 0x9C, 0xFE, 0x17, 0x1F, 0x6A,
  0xD5, 0xFC, 0x08, 0x55, 0x73, 0x6C, 0x6C, 0xD1, 0xA2, 0xA5, 0xCB, 0x96,
  0x2E, 0x1C, 0x5B, 0x73, 0xD2, 0xC6, 0xB5, 0xEB, 0x4F, 0xD8, 0xB4, 0xF9,
  0xD4, 0xD3, 0xCE, 0x38, 0xE3, 0xB4, 0xC7, 0x9F, 0xFE, 0xD7, 0x9F, 0xFD,
  0x7C, 0xCA, 0xBD, 0x90, 0x68, 0xFC, 0x1F, 0xFF, 0xF7, 0x2B, 0xCE, 0x3F,
  0xFF, 0xFC, 0xA7, 0x9C, 0x7F, 0xFE, 0x93, 0xCF, 0x3F, 0xFF, 0x21, 0xAB,
  0xD6, 0x3D, 0xF9, 0xFC, 0xF3, 0x9E, 0xFC, 0xC3, 0x0F, 0x9F, 0xF2, 0xC3,
  0x7F, 0xFC, 0xC3, 0x8B, 0x3F, 0xF6, 0xF1, 0x8F, 0x7F, 0xE2, 0xD3, 0x95,
  0x70, 0x04, 0xC2, 0xD1, 0xE0, 0xFB, 0x97, 0xCC, 0x17, 0x53, 0xCD, 0x7A,
  0xB5, 0x7B, 0x7A, 0xCE, 0x8F, 0xE2, 0xA3, 0x01, 0x4F, 0x1D, 0x59, 0xD2,
  0x6A, 0x54, 0x5F, 0x7D, 0x68, 0x8A, 0xF7, 0x0E, 0x07, 0x26, 0x63, 0x2F,
  0xE3, 0x69, 0x35, 0xF7, 0x22, 0xDA, 0xF3, 0x89, 0xE4, 0x8B, 0x1D, 0xE3,
  0x20, 0x51, 0x01, 0x30, 0x31, 0x01, 0x31, 0xE4, 0xDC, 0x85, 0xF0, 0xDC,
  0x3A, 0x88, 0xDD, 0x6F, 0xFD, 0x58, 0x72, 0xB1, 0x11, 0xD5, 0xC8, 0xB9,
  0x9E, 0x1F, 0x41, 0x08, 0xB1, 0x73, 0x91, 0xDD, 0x6E, 0xAC, 0x2F, 0xAB,
  0x5D, 0x67, 0x26, 0x3E, 0x72, 0x88, 0xC0, 0x07, 0xFF, 0xF8, 0x65, 0xD1,
  0xE3, 0x22, 0xEE, 0x45, 0xBC, 0x96, 0xDC, 0xD6, 0xB4, 0x31, 0x00, 0xC4,
  0xEE, 0xD1, 0x76, 0xDA, 0xB2, 0x55, 0x4F, 0xF4, 0x0E, 0xB8, 0xFF, 0xFA,
  0xC1, 0xF9, 0x8B, 0x63, 0x9E, 0xD2, 0xF7, 0xF0, 0xA3, 0x09, 0xE6, 0xA4,
  0x23, 0x34, 0x95, 0xDE, 0x26, 0x17, 0xC5, 0xF2, 0x43, 0x26, 0xE3, 0x2F,
  0x8B, 0xCE, 0x55, 0x8E, 0x4C, 0xD2, 0x0D, 0x56, 0x57, 0xE5, 0x69, 0xF3,
  0x0D, 0x80, 0x13, 0x6F, 0xB0, 0x13, 0x6F, 0x38, 0xE1, 0x06, 0x0E, 0x5A,
  0xCB, 0xB6, 0x57, 0xAD, 0x1D, 0x6E, 0x2B, 0xF7, 0x33, 0x01, 0x71, 0x4E,
  0xB8, 0x6F, 0x04, 0x00, 0x7F, 0x60, 0xDD, 0x09, 0x9B, 0x4E, 0x3A, 0xF9,
  0xE4, 0x53, 0x4F, 0x3D, 0xE5, 0xB4, 0x0B, 0x3E, 0xF4, 0xC5, 0x9A, 0x7B,
  0xE1, 0x86, 0x4E, 0x3F, 0xE9, 0x84, 0x4D, 0x1B, 0x9F, 0xB6, 0xF7, 0xB6,
  0xAD, 0xE7, 0x9D, 0xFF, 0x94, 0xA7, 0xFC, 0xF0, 0xF5, 0x07, 0x7F, 0x0E,
  0x3A, 0xFF, 0xC6, 0xED, 0x1D, 0xE3, 0xDE, 0x79, 0x8E, 0x22, 0xE3, 0xBF,
  0x44, 0x17, 0xB7, 0x70, 0x22, 0x22, 0x40, 0x7C, 0xDC, 0xD0, 0xDA, 0x37,
  0x71, 0x64, 0xF5, 0x0B, 0xFE, 0x3E, 0x17, 0xE1, 0x53, 0x8B, 0xDF, 0xF3,
  0xB6, 0x9F, 0x7F, 0xF2, 0xE3, 0x4E, 0xBF, 0x54, 0x10, 0x01, 0x30, 0x7D,
  0xCF, 0xD3, 0x7E, 0x6D, 0x74, 0x2C, 0x7D, 0x03, 0xC7, 0xA8, 0x6C, 0xED,
  0xFA, 0x13, 0x4F, 0xDA, 0x7C, 0xF2, 0x29, 0xA7, 0x9E, 0x72, 0xCA, 0xA9,
  0x1F, 0xF8, 0x6C, 0xCA, 0xBD, 0xA8, 0x26, 0x4F, 0x3B, 0xE1, 0xF8, 0x8D,
  0x1B, 0x1B, 0x20, 0x58, 0xE8, 0xCC, 0xEE, 0xDC, 0xB1, 0xFB, 0xE6, 0x9B,
  0x76, 0x6F, 0xDF, 0xB9, 0xAB, 0x93, 0x2B, 0xC7, 0xB2, 0x78, 0xCD, 0x0F,
  0x36, 0x80, 0xCD, 0x9B, 0x37, 0x3F, 0xE1, 0x94, 0x93, 0x4F, 0x79, 0xE2,
  0x67, 0xBF, 0xE8, 0x39, 0xB2, 0xDE, 0x29, 0xA7, 0xFE, 0xA0, 0x7F, 0x38,
  0x70, 0x07, 0x51, 0xE7, 0x54, 0x10, 0xE1, 0x98, 0x26, 0xFE, 0xC0, 0xDA,
  0x13, 0x4E, 0xFC, 0x61, 0xFF, 0xC9, 0x27, 0x9F, 0x7C, 0xC1, 0x87, 0x3E,
  0x9B, 0x70, 0x44, 0x12, 0x4D, 0xFE, 0xA0, 0xFF, 0x84, 0x98, 0x07, 0x1D,
  0x37, 0xB0, 0xEE, 0xB8, 0xE3, 0x4F, 0xDA, 0xBC, 0xF9, 0x82, 0x93, 0x9F,
  0xB0, 0xF9, 0xE4, 0x0F, 0xDC, 0xEB, 0x02, 0xD0, 0x3D, 0xFB, 0x4E, 0x38,
  0x21, 0x33, 0x1E, 0x7C, 0xB2, 0x75, 0x87, 0x36, 0x80, 0x27, 0x5C, 0xB0,
  0xF9, 0xA9, 0x9F, 0xFD, 0x7C, 0xC2, 0x91, 0x59, 0x6F, 0xB0, 0x61, 0x3C,
  0x08, 0x55, 0x6B, 0x7F, 0xB0, 0x01, 0x9C, 0x74, 0xD2, 0x05, 0x4F, 0x38,
  0x79, 0xF3, 0x49, 0x17, 0xFC, 0xE3, 0xE7, 0x4B, 0xE5, 0x5E, 0x28, 0x0F,
  0x4A, 0xE1, 0xC0, 0xDA, 0xE3, 0x8E, 0xDF, 0x74, 0xD2, 0x05, 0x3F, 0x58,
  0x02, 0x27, 0x6D, 0xFC, 0xD0, 0xE7, 0x53, 0xFE, 0x87, 0xD1, 0x74, 0xFD,
  0xDA, 0x13, 0x36, 0x9E, 0x74, 0xD2, 0xE6, 0x1F, 0xBC, 0x3E, 0xF5, 0xB3,
  0x9F, 0xAD, 0xF8, 0x6F, 0xE7, 0x78, 0x20, 0xF3, 0xAA, 0x04, 0xD6, 0x82,
  0xDA, 0x82, 0xA7, 0x68, 0xE4, 0xF8, 0x9F, 0x26, 0x59, 0xBA, 0x6E, 0xDD,
  0xC6, 0x93, 0x36, 0x9D, 0xF8, 0x84, 0x5F, 0xF8, 0xDB, 0xCF, 0x7C, 0x26,
  0xE1, 0x7F, 0x9C, 0x6C, 0xE9, 0xDA, 0x35, 0x27, 0x6C, 0xDC, 0xF4, 0x90,
  0x47, 0xFD, 0xC2, 0xC7, 0x3E, 0xF7, 0x45, 0xCF, 0xFF, 0x34, 0x9A, 0x2E,
  0x5F, 0xB7, 0x7E, 0xE3, 0x69, 0x0F, 0x7B, 0xD4, 0x59, 0x17, 0x7F, 0xEE,
  0x33, 0x31, 0xFF, 0xE3, 0x68, 0xB9, 0x66, 0xE3, 0x05, 0xBF, 0xF8, 0x0B,
  0x0F, 0x3D, 0xF3, 0x2F, 0x3E, 0xF3, 0xB9, 0x7F, 0x37, 0xFE, 0xC7, 0xB1,
  0x72, 0xDD, 0xF1, 0x27, 0x9F, 0x7E, 0xC6, 0xE3, 0xFF, 0xE2, 0x1F, 0xFF,
  0x27, 0xAE, 0x7E, 0xA0, 0x5C, 0xBB, 0xFE, 0xB4, 0xD3, 0x2F, 0xF8, 0xC0,
  0x87, 0x3E, 0xF3, 0xC5, 0x88, 0xFF, 0x89, 0xAA, 0xF1, 0x55, 0x1F, 0xF8,
  0xD0, 0x67, 0x3F, 0xFB, 0xD9, 0x7F, 0x8F, 0xF8, 0x9F, 0x29, 0x19, 0xFF,
  0xC2, 0x17, 0xFE, 0xE1, 0x8B, 0x89, 0xE3, 0x7F, 0xAA, 0x28, 0x49, 0xE2,
  0xC0, 0xCF, 0xFC, 0xCC, 0xCF, 0xFC, 0xCC, 0xCF, 0xFC, 0xCC, 0x7F, 0xAB,
  0xFF, 0x0F, 0xE5, 0x1E, 0x45, 0x88, 0xA7, 0x4D, 0x97, 0xCD, 0x00, 0x00,
  0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82, 
};
} // namespace rawdata

#endif  // ZEKAMASHI_H_



================================================
FILE: Functions/config.h
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: config.h
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file contains config vars and language vars of samidare project.
// 
// Note:
//	 Please do not modify the var names, since they are same with yaml keys.
//
// -----------------------------------------------------------------------------
#pragma once
#ifndef CONFIG_H_
#define CONFIG_H_
#include "pch.h"
#include "../Utils/XorStr.h"
#include "../Overlay.h"

#define AUTO_CONFIG_VARS                   \
  X(AimBot, bool)                          \
  X(AimBotHotKey.uKey, int)                \
  X(AimBotHotKey.nMode, int)               \
  X(AimBullet, int)                        \
  X(AimScopeOnly, bool)                    \
  X(AimIgnoreFlash, bool)                  \
  X(AimFov, float)                         \
  X(AimFovMin, float)                      \
  X(AimSmooth, float)                      \
  X(AimMaxRecoil, float)                   \
  X(HitboxList, std::vector<unsigned int>) \
  X(TriggerBot, bool)                      \
  X(TriggerBotHotKey.uKey, int)            \
  X(TriggerBotHotKey.nMode, int)           \
  X(TriggerDelay, int)                     \
  X(ShotDuration, int)                     \
  X(TriggerMaxRecoil, float)               \
  X(TriggerScopeOnly, bool)                \
  X(TriggerIgnoreFlash, bool)              \
  X(RCS, bool)                             \
  X(RCSScale.x, float)                     \
  X(RCSScale.y, float)                     \
  X(RCSBullet, int)                        \
  X(ESP, bool)                             \
  X(ESPInfo, bool)                         \
  X(ESPBox, bool)                          \
  X(ESPName, bool)                         \
  X(ESPHealth, bool)                       \
  X(C4ESP, bool)                           \
  X(Radar, bool)                           \
  X(RadarCrossLine, bool)                  \
  X(RadarPointSize, float)                 \
  X(RadarProportion, float)                \
  X(RadarRange, float)                     \
  X(Sonar, bool)                           \
  X(PitchIndicator, bool)                  \
  X(C4Timer, bool)                         \
  X(SpecList, bool)                        \
  X(InfoString, bool)                      \
  X(FastStop, bool)                        \
  X(FastStopMinVelocity, float)            \
  X(TeamCheck, bool)                       \
  X(WorkInSpec, bool)                      \
  X(BypassCapture, bool)                   \
  X(DormantTime, float)                    \
  X(Style, int)                            \
  X(RenderFPS, int)                        \
  X(GlobalVarsInterval, int)               \
  X(EntityInterval, int)                   \
  X(ParserInterval, int)                   \
  X(AimInterval, int)                      \
  X(ViewInterval, int)                     \
  X(MemoryInterval, int)                   \
  X(NonMemoryInterval, int)

#ifndef UKIARPM_CONFIGS
#define UKIARPM_CONFIGS
namespace config {
inline std::string path = "";
inline bool ShowMenu = false;
inline int RenderInterval = 0;

inline bool AimBot = false;
inline KeyBind_t AimBotHotKey(ImGuiKey_MouseX1, EKeyBindMode::HOLD);
inline float AimFov = 5;
inline float AimFovMin = 0.f;
inline float AimSmooth = 15.0f;
inline float AimMaxRecoil = 15.f;
inline bool AimScopeOnly = false;
inline bool AimIgnoreFlash = false;
inline int AimBullet = 0;
inline std::vector<unsigned int> HitboxList = {6, 5, 4};

inline bool TriggerBot = false;
inline KeyBind_t TriggerBotHotKey(ImGuiKey_MouseX2, EKeyBindMode::HOLD);
inline int TriggerDelay = 90;
inline int ShotDuration = 200;
inline float TriggerMaxRecoil = 15.f;
inline bool TriggerScopeOnly = false;
inline bool TriggerIgnoreFlash = false;

inline bool RCS = false;
inline Vector2 RCSScale = {2.f, 2.f};
inline int RCSBullet = 2;

inline bool ESP = false;
inline bool ESPInfo = false;
inline bool ESPBox = true;
inline bool ESPName = true;
inline bool ESPHealth = true;

inline bool C4ESP = false;

inline bool Radar = false;
inline bool RadarCrossLine = true;
inline float RadarPointSize = 1.f;
inline float RadarProportion = 3300.f;
inline float RadarRange = 150.f;

inline bool Sonar = false;
inline bool PitchIndicator = false;
inline bool C4Timer = false;
inline bool SpecList = false;
inline bool InfoString = false;
inline bool FastStop = false;
inline float FastStopMinVelocity = 24.f;

inline bool TeamCheck = true;
inline bool WorkInSpec = true;
inline bool BypassCapture = false;
inline float DormantTime = 1.f;
inline int Style = 0;

inline int RenderFPS = 0;
inline int GlobalVarsInterval = 15;
inline int EntityInterval = 1;
inline int ParserInterval = 100;
inline int AimInterval = 1;
inline int ViewInterval = 1;
inline int MemoryInterval = 15;
inline int NonMemoryInterval = 1;
}  // namespace config
#endif

#define AUTO_LANG_VARS                      \
  Y(greek, bool)                            \
  Y(vietnamese, bool)                       \
  Y(kanji, bool)                            \
  Y(korean, bool)                           \
  Y(arabic, bool)                           \
  Y(thai, bool)                             \
  Y(textfortranslator, std::string)         \
  Y(TabLegit, std::string)                  \
  Y(TabVisuals, std::string)                \
  Y(TabMiscs, std::string)                  \
  Y(TabSettings, std::string)               \
  Y(TabExperimental, std::string)           \
  Y(ChildAimAssist, std::string)            \
  Y(SwitchEnableAimBot, std::string)        \
  Y(SliderAimFov, std::string)              \
  Y(SliderAimFovMin, std::string)           \
  Y(SliderAimSmooth, std::string)           \
  Y(SliderAimMaxRecoil, std::string)        \
  Y(SwitchAimScopeOnly, std::string)        \
  Y(SwitchAimIgnoreFlash, std::string)      \
  Y(SliderAimBullet, std::string)           \
  Y(ChildHitBox, std::string)               \
  Y(ChildTriggerbot, std::string)           \
  Y(SwitchEnableTriggerbot, std::string)    \
  Y(SliderTriggerDelay, std::string)        \
  Y(SliderShotDuration, std::string)        \
  Y(SliderTriggerMaxRecoil, std::string)    \
  Y(SwitchTriggerScopeOnly, std::string)    \
  Y(SwitchTriggerIgnoreFlash, std::string)  \
  Y(ChildRCS, std::string)                  \
  Y(SwitchEnableRCS, std::string)           \
  Y(SliderRCSScale, std::string)            \
  Y(SliderRCSStartBullet, std::string)      \
  Y(ChildESP, std::string)                  \
  Y(SwitchEnableESP, std::string)           \
  Y(SwitchPlayerInfo, std::string)          \
  Y(SwitchBox, std::string)                 \
  Y(SwitchPlayerName, std::string)          \
  Y(SwitchHealthBar, std::string)           \
  Y(ChildWorld, std::string)                \
  Y(SwitchC4ESP, std::string)               \
  Y(ChildVisualOthers, std::string)         \
  Y(SwitchEnableRadar, std::string)         \
  Y(SwitchRadarCrossline, std::string)      \
  Y(SliderRadarPointSize, std::string)      \
  Y(SliderRadarProportion, std::string)     \
  Y(SliderRadarRange, std::string)          \
  Y(ChildMiscGlobals, std::string)          \
  Y(SwitchSonar, std::string)               \
  Y(SwitchPitchIndicator, std::string)      \
  Y(SwitchC4Timer, std::string)             \
  Y(SwitchSpecList, std::string)            \
  Y(ChildMisc, std::string)                 \
  Y(SwitchEnemyInfo, std::string)           \
  Y(ChildMovement, std::string)             \
  Y(SwitchFastStop, std::string)            \
  Y(SliderFastStopMinVelocity, std::string) \
  Y(ChildInfo, std::string)                 \
  Y(TextLastBuild, std::string)             \
  Y(TextBuildVersion, std::string)          \
  Y(TextCurrentGameVersion, std::string)    \
  Y(TextCompiler, std::string)              \
  Y(TextLicenceToUser, std::string)         \
  Y(ChildConfigList, std::string)           \
  Y(TextConfigAuthor, std::string)          \
  Y(ButtonLoad, std::string)                \
  Y(ButtonReLoad, std::string)              \
  Y(ButtonSave, std::string)                \
  Y(ButtonDelete, std::string)              \
  Y(TextDeleteConfirm, std::string)         \
  Y(ButtonYes, std::string)                 \
  Y(ButtonNo, std::string)                  \
  Y(ChildSettings, std::string)             \
  Y(SwitchTeamCheck, std::string)           \
  Y(SwitchBypassCapture, std::string)       \
  Y(SliderDormantTime, std::string)         \
  Y(ComboStyle, std::string)                \
  Y(ButtonCreateConfig, std::string)        \
  Y(TextNewConfigName, std::string)         \
  Y(TextConfigAuthorName, std::string)      \
  Y(ButtonCreate, std::string)              \
  Y(ButtonOpenFolder, std::string)          \
  Y(ButtonExtendFonts, std::string)         \
  Y(ButtonApply, std::string)               \
  Y(ButtonUnhook, std::string)              \
  Y(ChildLoopInterval, std::string)         \
  Y(SliderRenderFPS, std::string)           \
  Y(SliderGlobalVarsInterval, std::string)  \
  Y(SliderEntityInterval, std::string)      \
  Y(SliderParserInterval, std::string)      \
  Y(SliderAimInterval, std::string)         \
  Y(SliderViewInterval, std::string)        \
  Y(SliderMemoryInterval, std::string)      \
  Y(SliderNonMemoryInterval, std::string)   \
  Y(TextFPSBased, std::string)              \
  Y(TextBombOn, std::string)                \
  Y(TextBombNotPlanted, std::string)        \
  Y(TextBombEstimDamage, std::string)       \
  Y(TextDefuseCount, std::string)           \
  Y(TextCanDefuse, std::string)             \
  Y(TextCanNotDefuse, std::string)          \
  Y(TextNotDefusing, std::string)           \
  Y(TextPress, std::string)                 \
  Y(TextNone, std::string)                  \
  Y(TextHold, std::string)                  \
  Y(TextToggle, std::string)                \
  Y(TextDisable, std::string)

namespace LangSettings {
inline std::string path = "";
inline bool greek = false;
inline bool vietnamese = false;
inline bool kanji = false;
inline bool korean = false;
inline bool arabic = false;
inline bool thai = false;
inline std::string textfortranslator = XorStr("");

inline std::string TabLegit = XorStr("Legit");
inline std::string TabVisuals = XorStr("Visuals");
inline std::string TabMiscs = XorStr("Miscs");
inline std::string TabSettings = XorStr("Settings");
inline std::string TabExperimental = XorStr("Experimental");

inline std::string ChildAimAssist = XorStr("Aim Assist");
inline std::string SwitchEnableAimBot = XorStr("Enable AimBot");
inline std::string SliderAimFov = XorStr("Aim FOV");
inline std::string SliderAimFovMin = XorStr("Min Aim FOV");
inline std::string SliderAimSmooth = XorStr("Aim Smooth");
inline std::string SliderAimMaxRecoil = XorStr("Max Recoil##Aim");
inline std::string SwitchAimScopeOnly = XorStr("Scoped only##Aim");
inline std::string SwitchAimIgnoreFlash = XorStr("Ignore flash##Aim");
inline std::string SliderAimBullet = XorStr("Start bullet##Aim");

inline std::string ChildHitBox = XorStr("HitBox");

inline std::string ChildTriggerbot = XorStr("Triggerbot");
inline std::string SwitchEnableTriggerbot = XorStr("Enable triggerbot");
inline std::string SliderTriggerDelay = XorStr("Delay##Trigger");
inline std::string SliderShotDuration = XorStr("Shot duration");
inline std::string SliderTriggerMaxRecoil = XorStr("Max Recoil##Trigger");
inline std::string SwitchTriggerScopeOnly = XorStr("Scoped only##Trigger");
inline std::string SwitchTriggerIgnoreFlash = XorStr("Ignore flash##Trigger");

inline std::string ChildRCS = XorStr("RCS");
inline std::string SwitchEnableRCS = XorStr("Enable RCS");
inline std::string SliderRCSScale = XorStr("Scale X,Y##RCS");
inline std::string SliderRCSStartBullet = XorStr("Start bullet##RCS");

inline std::string ChildESP = XorStr("ESP");
inline std::string SwitchEnableESP = XorStr("Enable ESP");
inline std::string SwitchPlayerInfo = XorStr("Player info");
inline std::string SwitchBox = XorStr("Box");
inline std::string SwitchPlayerName = XorStr("Player name");
inline std::string SwitchHealthBar = XorStr("Health bar");

inline std::string ChildWorld = XorStr("World");
inline std::string SwitchC4ESP = XorStr("Bomb ESP");

inline std::string ChildVisualOthers = XorStr("Others");
inline std::string SwitchEnableRadar = XorStr("Enable radar");
inline std::string SwitchRadarCrossline = XorStr("Crossline");
inline std::string SliderRadarPointSize = XorStr("Point size");
inline std::string SliderRadarProportion = XorStr("Proportion");
inline std::string SliderRadarRange = XorStr("Range");

inline std::string ChildMiscGlobals = XorStr("Globals");
inline std::string SwitchSonar = XorStr("Sonar");
inline std::string SwitchPitchIndicator = XorStr("Pitch indicator");
inline std::string SwitchC4Timer = XorStr("Bomb timer");
inline std::string SwitchSpecList = XorStr("Spec list");

inline std::string ChildMisc = XorStr("Misc");
inline std::string SwitchEnemyInfo = XorStr("Enemy info");

inline std::string ChildMovement = XorStr("Movement");
inline std::string SwitchFastStop = XorStr("Fast stop");
inline std::string SliderFastStopMinVelocity = XorStr("Min velocity");

inline std::string ChildInfo = XorStr("Info");
inline std::string TextLastBuild = XorStr("Last build: %s");
inline std::string TextBuildVersion = XorStr("Build for version: %s");
inline std::string TextCurrentGameVersion = XorStr("Current version: %s");
inline std::string TextCompiler = XorStr("Compiler:");
inline std::string TextLicenceToUser = XorStr("Copy licenced to: %s");

inline std::string ChildConfigList = XorStr("Config List");
inline std::string TextConfigAuthor = XorStr("Author: %s");
inline std::string ButtonLoad = XorStr("Load");
inline std::string ButtonReLoad = XorStr("Reload");
inline std::string ButtonSave = XorStr("Save");
inline std::string ButtonDelete = XorStr("Delete");
inline std::string TextDeleteConfirm = XorStr("Are you sure to delete %s?");
inline std::string ButtonYes = XorStr("Yes");
inline std::string ButtonNo = XorStr("No");
inline std::string ChildSettings = XorStr("Settings");
inline std::string SwitchTeamCheck = XorStr("Team Check");
inline std::string SwitchBypassCapture = XorStr("Bypass Capture");
inline std::string SliderDormantTime = XorStr("Max Dormant Time");
inline std::string ComboStyle = XorStr("Style");
inline std::string ButtonCreateConfig = XorStr("Create Config");
inline std::string TextNewConfigName = XorStr("New Config Name");
inline std::string TextConfigAuthorName = XorStr("Author Name");
inline std::string ButtonCreate = XorStr("Create");
inline std::string ButtonOpenFolder = XorStr("Open Folder");
inline std::string ButtonExtendFonts = XorStr("Extend Fonts");
inline std::string ButtonApply = XorStr("Apply");
inline std::string ButtonUnhook = XorStr("Unhook");

inline std::string ChildLoopInterval = XorStr("Performances");
inline std::string SliderRenderFPS = XorStr("Render FPS");
inline std::string SliderGlobalVarsInterval = XorStr("GlobalVars interval");
inline std::string SliderEntityInterval = XorStr("Entity interval");
inline std::string SliderParserInterval = XorStr("Map parser interval");
inline std::string SliderAimInterval = XorStr("Aim interval");
inline std::string SliderViewInterval = XorStr("View interval");
inline std::string SliderMemoryInterval = XorStr("Memory func interval");
inline std::string SliderNonMemoryInterval = XorStr("NonMemory func interval");
inline std::string TextFPSBased = XorStr("Based on FPS");

inline std::string TextBombOn = XorStr("Bomb on %s.Remain %.3f s.");
inline std::string TextBombNotPlanted = XorStr("C4 not planted");
inline std::string TextBombEstimDamage = XorStr("Estim Damage : %d");
inline std::string TextDefuseCount = XorStr("C4 %s in %.3f s.");
inline std::string TextCanDefuse = XorStr("can be defused");
inline std::string TextCanNotDefuse = XorStr("cannot be defused");
inline std::string TextNotDefusing = XorStr("C4 is not being defused");

inline std::string TextPress = XorStr("Press");
inline std::string TextNone = XorStr("None");
inline std::string TextHold = XorStr("Hold");
inline std::string TextToggle = XorStr("Toggle");
inline std::string TextDisable = XorStr("Disable");
};  // namespace LangSettings
#endif  // CONFIG_H_



================================================
FILE: Functions/ConfigSaver.cc
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: ConfigSaver.cc
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file is config saving functions of Samidare project.
//
// -----------------------------------------------------------------------------
#include "pch.h"
#include "ConfigSaver.h"

#include "../global.h"

namespace configsaver {

static std::string GetAuthorFromFile(const std::string& filePath) {
  std::ifstream file(filePath);
  std::string line;
  for (int i = 0; i < 3 && std::getline(file, line); ++i) {
    if (i == 2 && line.find(XorStr("# Author: ")) == 0) {
      return line.substr(10);
    }
  }
  return "";
}

void SaveConfig(const std::string& filename, const std::string& author) {
  const std::string fullPath = config::path + XorStr("/") + filename;
  const bool isNewFile = !std::filesystem::exists(fullPath);

  std::string actualAuthor = author;

  if (isNewFile) {
    if (actualAuthor.empty()) {
      if (const char* username = global::user_name.c_str()) {
        actualAuthor = username;
      }
    }
  } else {
    actualAuthor = GetAuthorFromFile(fullPath);
  }

  YAML::Emitter emitter;
  emitter << YAML::Comment(
      XorStr("Samidare Configuration File\nVersion: 1.0\nAuthor: ") +
      actualAuthor);
  emitter << YAML::BeginMap;

  emitter << YAML::Key << XorStr("config") << YAML::Value << YAML::BeginMap;
#define X(var, type) emitter << YAML::Key << #var << YAML::Value << config::var;
  AUTO_CONFIG_VARS
#undef X
  emitter << YAML::EndMap;

  emitter << YAML::EndMap;

  std::ofstream configFile(fullPath);
  if (!configFile.is_open()) {
    MessageBoxA(nullptr, (XorStr("Could not open file:") + fullPath).c_str(),
                XorStr("Samidare"), MB_OK);
    return;
  }
  configFile << emitter.c_str();
  configFile.close();

  printf(XorStr("Configuration %s at %s (Author: %s)\n"),
         isNewFile ? XorStr("created") : XorStr("updated"), fullPath.c_str(),
         actualAuthor.c_str());
}

void LoadConfig(const std::string& filename) {
  YAML::Node root = YAML::LoadFile(config::path + XorStr("/") + filename);
  if (root["config"]) {
    YAML::Node configNode = root["config"];
#define X(var, type)                           \
  if (configNode[#var]) {                      \
    config::var = configNode[#var].as<type>(); \
  }
    AUTO_CONFIG_VARS
#undef X
  }
}

#ifdef _DEBUG
void ExportLangs() {
  YAML::Emitter out;
  out << YAML::BeginMap;
  out << YAML::Key << "translate" << YAML::Value << YAML::BeginMap;

#define Y(var, type) \
  out << YAML::Key << #var << YAML::Value << LangSettings::var;

  AUTO_LANG_VARS

#undef Y

  out << YAML::EndMap;
  out << YAML::EndMap;

  std::ofstream fout(LangSettings::path + XorStr("/") +
                     "language_template.yaml");
  fout << out.c_str();
}
#endif

void ExportDefaultLang() {
  YAML::Emitter out;
  out << YAML::Comment(
      XorStr("This is Samidare default language file\nDo NOT edit this unless "
             "you renamed this file."));
  out << YAML::BeginMap;
  out << YAML::Key << "translate" << YAML::Value << YAML::BeginMap;

#define Y(var, type) \
  out << YAML::Key << #var << YAML::Value << LangSettings::var;

  AUTO_LANG_VARS

#undef Y

  out << YAML::EndMap;
  out << YAML::EndMap;

  std::ofstream fout(LangSettings::path + XorStr("/") +
                     "Default.yaml");
  fout << out.c_str();
}

void LoadLangs(const std::string& filename) {
  YAML::Node root = YAML::LoadFile(LangSettings::path + XorStr("/") + filename);
  if (root["translate"]) {
    YAML::Node configNode = root["translate"];
#define Y(var, type)                                 \
  if (configNode[#var]) {                            \
    LangSettings::var = configNode[#var].as<type>(); \
  }
    AUTO_LANG_VARS
#undef Y
  }
  global::is_font_update_pending = true;
}

void UpdateLangsFileList() {
  langsFileList.clear();
  std::error_code ec;

  for (const auto& entry :
       std::filesystem::directory_iterator(LangSettings::path, ec)) {
    if (ec) {
      MessageBoxA(nullptr, XorStr("Fetch language files error."),
                  XorStr("Samidare Error"), MB_ICONERROR);
      return;
    }

    if (!entry.is_regular_file() || entry.path().extension() != XorStr(".yaml"))
      continue;
    std::string langname = entry.path().filename().string();
    size_t pos = langname.find_last_of('.');
    if (pos != std::string::npos) {
      langname.erase(pos);
    }
    langsFileList.push_back(langname);
  }
}

void RenderLangsFileCombo() {
  UpdateLangsFileList();

  const char* currentItem = selectedLangsFile.empty()
                                ? XorStr("English")
                                : selectedLangsFile.c_str();

  if (ImGui::BeginCombo(XorStr("Language"), currentItem)) {
    for (const auto& file : langsFileList) {
      bool is_selected = (selectedLangsFile == file);
      if (ImGui::Selectable(file.c_str(), is_selected)) {
        selectedLangsFile = file;
        LoadLangs(selectedLangsFile + XorStr(".yaml"));
        ImGui::SaveIniSettingsToDisk(ImGui::GetIO().IniFilename);
      }
      if (is_selected) ImGui::SetItemDefaultFocus();
    }
    ImGui::EndCombo();
  }
#ifdef _DEBUG
  if (ImGui::Button(XorStr("Export Current Language Template"))) {
    ExportLangs();
  }
#endif
}
}  // namespace MyConfigSaver



================================================
FILE: Functions/ConfigSaver.h
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: ConfigSaver.h
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file is declare of config saving functions of Samidare project.
//
// -----------------------------------------------------------------------------
#pragma once
#ifndef CONFIGSAVER_H_
#define CONFIGSAVER_H_
#include "pch.h"

#include "../ImGui/imgui.h"
#include "config.h"

#if defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-function"
#endif

namespace configsaver {
struct ConfigFileCache {
  std::filesystem::file_time_type modifyTime;
  std::string author;
  std::string modiTimeStr;
};
inline std::string selectedLangsFile;
static std::string selectedConfigFile;
static std::string deletePendingFile;
static std::vector<std::tuple<std::string, std::string, std::string>>
    configFiles;
static std::unordered_map<std::string, ConfigFileCache> configFileCache;
static std::filesystem::file_time_type lastConfigScanTime;
static std::vector<std::string> langsFileList;
inline void UpdateConfigFiles() {
  static std::vector<std::string> currentFiles;
  currentFiles.clear();

  auto currentScanTime = std::filesystem::last_write_time(config::path);
  if (currentScanTime <= lastConfigScanTime && !configFiles.empty() &&
      deletePendingFile.empty() && selectedConfigFile.empty()) {
    return;
  }
  lastConfigScanTime = currentScanTime;

  std::vector<std::tuple<std::string, std::string, std::string>> newFiles;
  std::error_code ec;
  auto dirIter = std::filesystem::directory_iterator(config::path, ec);
  if (ec) return;

  newFiles.reserve(configFiles.size() * 2);

  for (const auto& entry : dirIter) {
    if (!entry.is_regular_file() || entry.path().extension() != XorStr(".yaml"))
      continue;

    const auto filename = entry.path().filename().string();
    currentFiles.push_back(filename);

    const auto modifyTime = entry.last_write_time();
    auto& cache = configFileCache[filename];

    if (cache.modifyTime == modifyTime && !cache.modiTimeStr.empty()) {
      newFiles.emplace_back(filename, cache.modiTimeStr, cache.author);
      continue;
    }

    std::string author;
    if (std::ifstream file{entry.path()}) {
      std::string line;
      for (int i = 0; i < 3 && std::getline(file, line); ++i) {
        if (i == 2 && line.find(XorStr("# Author: ")) == 0) {
          author = line.substr(10);
          break;
        }
      }
    }

    const auto sysTime =
        std::chrono::clock_cast<std::chrono::system_clock>(modifyTime);
    const std::time_t cTime = std::chrono::system_clock::to_time_t(sysTime);
    char timeBuf[26];
    ctime_s(timeBuf, sizeof(timeBuf), &cTime);
    std::string timeStr = timeBuf;
    if (!timeStr.empty() && timeStr.back() == '\n') {
      timeStr.pop_back();
    }

    cache = {modifyTime, author, timeStr};
    newFiles.emplace_back(filename, std::move(timeStr), std::move(author));
  }

  for (auto it = configFileCache.begin(); it != configFileCache.end();) {
    if (std::find(currentFiles.begin(), currentFiles.end(), it->first) ==
        currentFiles.end()) {
      it = configFileCache.erase(it);
    } else {
      ++it;
    }
  }

  std::sort(newFiles.begin(), newFiles.end(), [](const auto& a, const auto& b) {
    return std::get<0>(a) > std::get<0>(b);
  });

  configFiles.swap(newFiles);
}

static std::string GetAuthorFromFile(const std::string& filePath);

void SaveConfig(const std::string& filename, const std::string& author);

void LoadConfig(const std::string& filename);

#ifdef _DEBUG
void ExportLangs();
#endif
void ExportDefaultLang();

void LoadLangs(const std::string& filename);

void UpdateLangsFileList();

void RenderLangsFileCombo();

template <typename T>
inline static T ReadData(const YAML::Node& node, T defaultValue) {
  return node.IsDefined() ? node.as<T>() : defaultValue;
}
inline static int ReadOffset(const YAML::Node& node, int defaultValue) {
  return node.IsDefined() ? std::stoi(node.as<std::string>(), nullptr, 16)
                          : defaultValue;
}
inline static uint32_t ImColorToUInt32(const ImColor& color) {
  uint32_t r = static_cast<uint32_t>(color.Value.x * 255);
  uint32_t g = static_cast<uint32_t>(color.Value.y * 255) << 8;
  uint32_t b = static_cast<uint32_t>(color.Value.z * 255) << 16;
  uint32_t a = static_cast<uint32_t>(color.Value.w * 255) << 24;

  return r | g | b | a;
}

inline static ImColor UInt32ToImColor(uint32_t value) {
  ImColor TempColor;
  TempColor.Value.x = static_cast<float>(value & 0xFF) / 255.0f;
  TempColor.Value.y = static_cast<float>((value >> 8) & 0xFF) / 255.0f;
  TempColor.Value.z = static_cast<float>((value >> 16) & 0xFF) / 255.0f;
  TempColor.Value.w = static_cast<float>((value >> 24) & 0xFF) / 255.0f;
  return TempColor;
}

inline static std::vector<int> LoadVector(const YAML::Node& node,
                                          std::vector<int> defaultValue) {
  if (node.IsDefined() && node.IsSequence()) {
    std::vector<int> result;
    for (const YAML::Node& element : node) {
      result.push_back(element.as<int>());
    }
    return result;
  } else
    return defaultValue;
}

}  // namespace MyConfigSaver
#endif  // CONFIGSAVER_H_



================================================
FILE: Functions/Func.cc
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: Func.cc
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file is trunk of all functions in the Samidare project.
//
// -----------------------------------------------------------------------------
#include "pch.h"
#include "Func.h"

#include "../Overlay.h"
#include "Aimbot/Aimbot.h"
#include "Aimbot/TriggerBot.h"
#include "Aimbot/RCS.h"
#include "Miscs/Miscs.h"
#include "Visuals/ESP.h"
#include "Visuals/Radar.h"
#include "menu.h"
#include "Miscs/BombTimer.h"
#include "Miscs/SpecList.h"
#include "../UkiaStuff.h"
void RenderFunctions(
    std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept {
  if (!global::isFocused()) return;
  std::lock_guard<std::mutex> lock(gamevars::validEntityMutex);
  std::vector<std::pair<CEntity, DWORD64>> EntityList = ValidEntity;
  ESP::ESPRun(EntityList);
  Radar::RadarRun(EntityList);
  Misc::PitchIndicator(gamevars::LocalEntity);
  BombTimer::RenderWindow(EntityList);
  SpecList::RenderWindow(EntityList);
  Menu::DrawMenu();
  DrawNewText(10, 10, &White, XorStr("Samidare for Counter-Strike 2"));
  DrawNewText(10, 100, &White, global::gamedata_infos.c_str());
  DrawNewText(
      10, ImGui::GetIO().DisplaySize.y - 20, &White,
      UkiaData::strHWID.substr(UkiaData::strHWID.length() - 16).c_str());
}
void AimFunctions(
    std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept {
  if (!global::isFocused() || config::ShowMenu) return;
  if (!gamevars::IsInGame) return;
  if (!gamevars::LocalEntity.Controller.Connected) return;
  std::lock_guard<std::mutex> lock(gamevars::validEntityMutex);
  std::vector<std::pair<CEntity, DWORD64>> EntityList = ValidEntity;
  AimBot::AimBotRun(EntityList);
  TriggerBot::TriggerBotRun(gamevars::LocalEntity);
  RCS::RCSRun(gamevars::LocalEntity);
}
  void ViewFunctions(
    std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept {
  if (!global::isFocused()) return;
  if (!gamevars::IsInGame) return;
  std::lock_guard<std::mutex> lock(gamevars::validEntityMutex);
  std::vector<std::pair<CEntity, DWORD64>> EntityList = ValidEntity;
  Misc::SonarRun(EntityList);
  Misc::FastStop(gamevars::LocalEntity);
  }
void MemoryFunctions(
    std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept {
  if (!global::isFocused()) return;
  if (!gamevars::IsInGame) return;
  std::lock_guard<std::mutex> lock(gamevars::validEntityMutex);
  std::vector<std::pair<CEntity, DWORD64>> EntityList = ValidEntity;
  Misc::FoundEnemy(EntityList);
}
void NonMemoryFunctions() noexcept {
  if (!global::isFocused()) return;
  if (!gamevars::IsInGame) return;
  Sonar::SoundThread();
}



================================================
FILE: Functions/Func.h
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: Func.h
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file is declared functions used in Func.cc.
//
// -----------------------------------------------------------------------------
#pragma once
#ifndef FUNC_H_
#define FUNC_H_
#include "pch.h"
#include "../CS2x64.h"
void RenderFunctions(
    std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept;
void AimFunctions(
    std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept;
void ViewFunctions(
    std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept;
void MemoryFunctions(
    std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept;
void NonMemoryFunctions() noexcept;
#endif  // FUNC_H_



================================================
FILE: Functions/menu.h
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: menu.h
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file contains the menu rendering function and some helper functions.
//
// -----------------------------------------------------------------------------
#pragma once
#ifndef MENU_H_
#define MENU_H_
#include "pch.h"

#include "../CS2x64.h"
#include "../UkiaStuff.h"
#include "../global.h"
#include "ConfigSaver.h"
static bool checkbox1;
static bool checkbox2;
static bool checkbox3;
static bool checkbox4;
static bool checkbox5;

inline void InitHitboxList() {

  auto HitboxList = config::HitboxList;

  auto it = std::find(HitboxList.begin(), HitboxList.end(), BONEINDEX::head);
  if (it != HitboxList.end()) checkbox1 = true;
  else
    checkbox1 = false;

  it = std::find(HitboxList.begin(), HitboxList.end(), BONEINDEX::neck_0);
  if (it != HitboxList.end()) checkbox2 = true;
  else
    checkbox2 = false;
  it = std::find(HitboxList.begin(), HitboxList.end(), BONEINDEX::spine_1);
  if (it != HitboxList.end()) checkbox3 = true;
  else
    checkbox3 = false;
  it = std::find(HitboxList.begin(), HitboxList.end(), BONEINDEX::spine_2);
  if (it != HitboxList.end()) checkbox4 = true;
  else
    checkbox4 = false;
  it = std::find(HitboxList.begin(), HitboxList.end(), BONEINDEX::pelvis);
  if (it != HitboxList.end()) checkbox5 = true;
  else
    checkbox5 = false;
}
inline void addHitbox(int BoneIndex) {
  config::HitboxList.push_back(BoneIndex);
}
inline void removeHitbox(int BoneIndex) {
  for (auto it = config::HitboxList.begin(); it != config::HitboxList.end();
       ++it) {
    if (*it == BoneIndex) {
      config::HitboxList.erase(it);
      break;
    }
  }
}
namespace Menu {

inline void Lumine() {
  ImGuiStyle& style = ImGui::GetStyle();

  style.Colors[ImGuiCol_Text] = ImColor(45, 35, 30, 255);
  style.Colors[ImGuiCol_TextDisabled] = ImColor(160, 130, 100, 255);

  style.Colors[ImGuiCol_WindowBg] = ImColor(241, 230, 221, 245);
  style.Colors[ImGuiCol_ChildBg] = ImColor(252, 239, 233, 245);
  style.Colors[ImGuiCol_PopupBg] = ImColor(239, 229, 209, 245);

  style.Colors[ImGuiCol_Border] = ImColor(106, 164, 196, 250);
  style.Colors[ImGuiCol_BorderShadow] = ImColor(161, 224, 245, 255);

  style.Colors[ImGuiCol_FrameBg] = ImColor(229, 219, 211, 255);
  style.Colors[ImGuiCol_FrameBgHovered] = ImColor(220, 210, 200, 255);
  style.Colors[ImGuiCol_FrameBgActive] = ImColor(148, 197, 220, 250);

  style.Colors[ImGuiCol_TitleBg] = ImColor(255, 240, 220, 200);
  style.Colors[ImGuiCol_TitleBgActive] = ImColor(255, 235, 210, 255);
  style.Colors[ImGuiCol_TitleBgCollapsed] = ImColor(255, 240, 220, 200);

  style.Colors[ImGuiCol_MenuBarBg] = ImColor(245, 230, 215, 255);

  style.Colors[ImGuiCol_ScrollbarBg] = ImColor(240, 230, 220, 255);
  style.Colors[ImGuiCol_ScrollbarGrab] = ImColor(158, 207, 229, 250);
  style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImColor(148, 197, 219, 250);
  style.Colors[ImGuiCol_ScrollbarGrabActive] = ImColor(138, 187, 209, 250);

  style.Colors[ImGuiCol_CheckMark] = ImColor(255, 255, 255, 255);

  style.Colors[ImGuiCol_SliderGrab] = ImColor(205, 225, 235, 255);
  style.Colors[ImGuiCol_SliderGrabActive] = ImColor(195, 215, 225, 255);

  style.Colors[ImGuiCol_Button] = ImColor(216, 176, 132, 225);
  style.Colors[ImGuiCol_ButtonHovered] = ImColor(208, 187, 135, 225);
  style.Colors[ImGuiCol_ButtonActive] = ImColor(192, 149, 111, 225);

  style.Colors[ImGuiCol_Header] = ImColor(235, 208, 185, 255);
  style.Colors[ImGuiCol_HeaderHovered] = ImColor(220, 193, 177, 255);
  style.Colors[ImGuiCol_HeaderActive] = ImColor(211, 185, 168, 255);

  style.Colors[ImGuiCol_Separator] = ImColor(210, 190, 160, 255);
  style.Colors[ImGuiCol_SeparatorHovered] = ImColor(200, 180, 150, 255);
  style.Colors[ImGuiCol_SeparatorActive] = ImColor(190, 170, 140, 255);

  style.Colors[ImGuiCol_ResizeGrip] = ImColor(200, 180, 160, 255);
  style.Colors[ImGuiCol_ResizeGripHovered] = ImColor(190, 170, 150, 255);
  style.Colors[ImGuiCol_ResizeGripActive] = ImColor(180, 160, 140, 255);

  style.Colors[ImGuiCol_Tab] = ImColor(245, 215, 185, 255);
  style.Colors[ImGuiCol_TabHovered] = ImColor(235, 205, 175, 255);
  style.Colors[ImGuiCol_TabActive] = ImColor(225, 195, 165, 255);
  style.Colors[ImGuiCol_TabUnfocused] = ImColor(250, 230, 210, 255);
  style.Colors[ImGuiCol_TabUnfocusedActive] = ImColor(240, 220, 200, 255);

  style.Colors[ImGuiCol_PlotLines] = ImColor(120, 100, 80, 255);
  style.Colors[ImGuiCol_PlotLinesHovered] = ImColor(140, 120, 100, 255);
  style.Colors[ImGuiCol_PlotHistogram] = ImColor(180, 150, 120, 255);
  style.Colors[ImGuiCol_PlotHistogramHovered] = ImColor(200, 170, 140, 255);

  style.Colors[ImGuiCol_TableHeaderBg] = ImColor(235, 225, 215, 255);
  style.Colors[ImGuiCol_TableBorderStrong] = ImColor(210, 190, 160, 255);
  style.Colors[ImGuiCol_TableBorderLight] = ImColor(240, 230, 220, 255);
  style.Colors[ImGuiCol_TableRowBg] = ImColor(255, 245, 235, 255);
  style.Colors[ImGuiCol_TableRowBgAlt] = ImColor(250, 235, 225, 255);

  style.Colors[ImGuiCol_TextSelectedBg] = ImColor(230, 200, 150, 150);

  style.Colors[ImGuiCol_DragDropTarget] = ImColor(255, 220, 100, 200);

  style.Colors[ImGuiCol_NavHighlight] = ImColor(175, 210, 235, 255);
  style.Colors[ImGuiCol_NavWindowingHighlight] = ImColor(255, 240, 220, 180);
  style.Colors[ImGuiCol_NavWindowingDimBg] = ImColor(200, 180, 160, 50);
  style.Colors[ImGuiCol_ModalWindowDimBg] = ImColor(200, 180, 160, 100);
}

inline void Style_AimStar() {
  ImGuiStyle& style = ImGui::GetStyle();

  style.Colors[ImGuiCol_Text] = ImVec4(1.0f, 0.99999f, 0.99999f, 1.0f);
  style.Colors[ImGuiCol_TextDisabled] =
      ImVec4(0.690987f, 0.690980f, 0.690980f, 1.0f);
  style.Colors[ImGuiCol_WindowBg] =
      ImVec4(0.345098f, 0.219608f, 0.0f, 0.896400f);
  style.Colors[ImGuiCol_ChildBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.502146f);
  style.Colors[ImGuiCol_PopupBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.690987f);
  style.Colors[ImGuiCol_Border] = ImVec4(1.0f, 0.800000f, 0.0f, 1.0f);
  style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
  style.Colors[ImGuiCol_FrameBg] =
      ImVec4(0.545064f, 0.421080f, 0.0f, 0.502146f);
  style.Colors[ImGuiCol_FrameBgHovered] =
      ImVec4(1.0f, 0.999996f, 0.99999f, 0.8964f);
  style.Colors[ImGuiCol_FrameBgActive] =
      ImVec4(0.499142f, 0.326123f, 0.1989f, 0.780392f);
  style.Colors[ImGuiCol_TitleBg] =
      ImVec4(0.824034f, 0.615373f, 0.0f, 0.788235f);
  style.Colors[ImGuiCol_TitleBgActive] = ImVec4(1.0f, 0.695278f, 0.0f, 1.0f);
  style.Colors[ImGuiCol_TitleBgCollapsed] =
      ImVec4(1.0f, 0.695279f, 0.0f, 0.75f);
  style.Colors[ImGuiCol_MenuBarBg] =
      ImVec4(0.200000f, 0.219608f, 0.266667f, 0.65f);
  style.Colors[ImGuiCol_ScrollbarBg] =
      ImVec4(0.622318f, 0.432683f, 0.0f, 0.630901f);
  style.Colors[ImGuiCol_ScrollbarGrab] =
      ImVec4(1.0f, 0.999996f, 0.99999f, 1.0f);
  style.Colors[ImGuiCol_ScrollbarGrabHovered] =
      ImVec4(0.875537f, 0.875528f, 0.875532f, 1.0f);
  style.Colors[ImGuiCol_ScrollbarGrabActive] =
      ImVec4(0.678112f, 0.678105f, 0.678108f, 1.0f);
  style.Colors[ImGuiCol_CheckMark] = ImVec4(0.99999f, 0.999995f, 1.0f, 1.0f);
  style.Colors[ImGuiCol_SliderGrab] = ImVec4(1.0f, 0.618026f, 0.0f, 1.0f);
  style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(1.0f, 0.721030f, 0.0f, 1.0f);
  style.Colors[ImGuiCol_Button] = ImVec4(1.0f, 0.892857f, 0.0f, 0.75f);
  style.Colors[ImGuiCol_ButtonHovered] =
      ImVec4(0.996463f, 1.0f, 0.175966f, 0.75f);
  style.Colors[ImGuiCol_ButtonActive] = ImVec4(1.0f, 0.669528f, 0.0f, 0.75f);
  style.Colors[ImGuiCol_Header] = ImVec4(1.0f, 0.515021f, 0.0f, 0.785408f);
  style.Colors[ImGuiCol_HeaderHovered] =
      ImVec4(1.0f, 0.643114f, 0.266094f, 0.785408f);
  style.Colors[ImGuiCol_HeaderActive] =
      ImVec4(0.836910f, 0.429642f, 0.0f, 0.784314f);
  style.Colors[ImGuiCol_Separator] =
      ImVec4(0.261803f, 0.261802f, 0.261800f, 0.5f);
  style.Colors[ImGuiCol_SeparatorHovered] =
      ImVec4(0.098039f, 0.438896f, 0.749020f, 0.78f);
  style.Colors[ImGuiCol_SeparatorActive] =
      ImVec4(0.098039f, 0.400000f, 0.749020f, 1.0f);
  style.Colors[ImGuiCol_ResizeGrip] =
      ImVec4(0.466667f, 0.768627f, 0.827451f, 0.04f);
  style.Colors[ImGuiCol_ResizeGripHovered] =
      ImVec4(0.454902f, 0.196078f, 0.298039f, 1.0f);
  style.Colors[ImGuiCol_ResizeGripActive] =
      ImVec4(0.454902f, 0.196078f, 0.298039f, 1.0f);
  style.Colors[ImGuiCol_Tab] = ImVec4(1.0f, 0.360515f, 0.0f, 0.862000f);
  style.Colors[ImGuiCol_TabHovered] =
      ImVec4(0.991416f, 0.518159f, 0.251045f, 0.862745f);
  style.Colors[ImGuiCol_TabActive] =
      ImVec4(0.716738f, 0.258586f, 0.0f, 0.862745f);
  style.Colors[ImGuiCol_TabUnfocused] =
      ImVec4(0.066667f, 0.101961f, 0.145098f, 0.972400f);
  style.Colors[ImGuiCol_TabUnfocusedActive] =
      ImVec4(0.133333f, 0.258824f, 0.423529f, 1.0f);
  style.Colors[ImGuiCol_PlotLines] =
      ImVec4(0.858824f, 0.929412f, 0.886275f, 0.63f);
  style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.197425f, 1.0f, 0.0f, 1.0f);
  style.Colors[ImGuiCol_PlotHistogram] =
      ImVec4(0.858824f, 0.929412f, 0.886275f, 0.63f);
  style.Colors[ImGuiCol_PlotHistogramHovered] =
      ImVec4(0.454902f, 0.196078f, 0.298039f, 1.0f);
  style.Colors[ImGuiCol_TableHeaderBg] =
      ImVec4(0.201715f, 0.201715f, 0.201717f, 1.0f);
  style.Colors[ImGuiCol_TableBorderStrong] =
      ImVec4(0.403429f, 0.403429f, 0.403434f, 1.0f);
  style.Colors[ImGuiCol_TableBorderLight] =
      ImVec4(9.9999e-07f, 9.9999e-07f, 9.999999e-07f, 0.0f);
  style.Colors[ImGuiCol_TableRowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
  style.Colors[ImGuiCol_TableRowBgAlt] =
      ImVec4(9.9999e-07f, 9.9999e-07f, 9.9999e-07f, 0.223176f);
  style.Colors[ImGuiCol_TextSelectedBg] =
      ImVec4(0.729614f, 0.729606f, 0.729610f, 0.43f);
  style.Colors[ImGuiCol_DragDropTarget] = ImVec4(1.0f, 1.0f, 0.0f, 0.9f);
  style.Colors[ImGuiCol_NavHighlight] =
      ImVec4(0.258824f, 0.588235f, 0.976471f, 1.0f);
  style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 1.0f, 1.0f, 0.7f);
  style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.8f, 0.8f, 0.8f, 0.2f);
  style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.8f, 0.8f, 0.8f, 0.35f);
}

inline void DrawMenu() {
  switch (config::Style) {
    case 0:
      Lumine();
      break;
    case 1:
      Style_AimStar();
      break;
    case 2:
      ImGui::StyleColorsClassic();
      break;
    case 3:
      ImGui::StyleColorsDark();
      break;
    case 4:
      ImGui::StyleColorsLight();
      break;
    default:
      Lumine();
  }
  float textoffset;
  int randomresult = (rand() % 15) + 1;
  if (randomresult % 2 == 0)
    textoffset = randomresult * -0.1f;
  else
    textoffset = randomresult * 0.1f;
  ImGuiIO& io = ImGui::GetIO();
  ImGuiStyle& style = ImGui::GetStyle();
  if (!config::ShowMenu) return;
  // const ImVec2 vecScreenSize = io.DisplaySize;

  ImGui::PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(720, 365));

  ImGui::SetNextWindowPos(
      ImVec2(io.DisplaySize.x / 2.f, io.DisplaySize.y / 2.f), ImGuiCond_Once,
      ImVec2(0.5f, 0.5f));
  ImGui::SetNextWindowSize(ImVec2(720, 370), ImGuiCond_Always);
  ImGui::Begin(XorStr("Samidare for Counter-Strike 2"), NULL,
               ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize |
                   ImGuiWindowFlags_NoScrollbar |
                   ImGuiWindowFlags_NoScrollWithMouse |
                   ImGuiWindowFlags_NoCollapse);

  const ImVec2 vecMenuPos = ImGui::GetWindowPos();
  // const ImVec2 vecMenuSize = ImGui::GetWindowSize();
  // ImDrawList* pDrawList = ImGui::GetWindowDrawList();

  ImGui::BeginTabBar(XorStr("##Tabs"));
#ifdef _DEBUG
  if (ImGui::BeginTabItem(XorStr("Semi-rage"))) {
    ImGui::Text("%s",XorStr("Coming soon?"));
    ImGui::EndTabItem();
  }
#endif
  if (ImGui::BeginTabItem(LangSettings::TabLegit.c_str())) {
    ImVec2 child_size =
        ImVec2((ImGui::GetColumnWidth() - (style.ItemSpacing.x * 2)) / 3,
               ImGui::GetWindowHeight() - 10.f -
                   (ImGui::GetCursorPosY() + style.ItemInnerSpacing.y * 2));
    auto childBegin = ImGui::GetCursorPosY();

    ImGui::SetCursorPosY(childBegin);
    ImGui::BeginChild(LangSettings::ChildAimAssist.c_str(), child_size);
    {
        ImGui::Checkbox(LangSettings::SwitchEnableAimBot.c_str(), &config::AimBot);
        ImGui::HotKey(XorStr(" ##hotkeyaim"),&config::AimBotHotKey);
        ImGui::SliderFloat(LangSettings::SliderAimFov.c_str(), &config::AimFov, 0.1f, 45.f, XorStr("%.2f"));
        ImGui::SliderFloat(LangSettings::SliderAimFovMin.c_str(), &config::AimFovMin, 0.f, 1.f, XorStr("%.2f"));
        ImGui::SliderFloat(LangSettings::SliderAimSmooth.c_str(), &config::AimSmooth, 2.f, 100.f, XorStr("%.1f"));
        ImGui::SliderFloat(LangSettings::SliderAimMaxRecoil.c_str(),&config::AimMaxRecoil, 1.f, 90.f, XorStr("%.1f"));
        ImGui::Checkbox(LangSettings::SwitchAimScopeOnly.c_str(), &config::AimScopeOnly);
        ImGui::Checkbox(LangSettings::SwitchAimIgnoreFlash.c_str(), &config::AimIgnoreFlash);
        ImGui::SliderInt(LangSettings::SliderAimBullet.c_str(), &config::AimBullet, 0, 5, XorStr("%d"));
    }
    ImGui::EndChild();
    ImGui::SameLine();
    ImGui::SetCursorPosY(childBegin);
    ImGui::BeginChild(LangSettings::ChildHitBox.c_str(), child_size);
    {
      InitHitboxList();
      ImVec2 StartPos = ImGui::GetCursorScreenPos();
      ImGui::PushStyleVar(ImGuiStyleVar_FramePadding,
                          ImVec2(style.FramePadding.x, 0));
      ImGui::Image((ImTextureID)global::zekamashi_texture, ImVec2{192, 260},
                   ImVec2{0, 0}, ImVec2{1, 1});
      ImGui::GetWindowDrawList()->AddLine(
          ImVec2(StartPos.x + 100, StartPos.y + 55),
          ImVec2(StartPos.x + 190, StartPos.y + 55),
          ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)), 1.8f);  // Head
      ImGui::SetCursorScreenPos(ImVec2(StartPos.x + 190, StartPos.y + 55));
      if (ImGui::Checkbox(XorStr("###Head"), &checkbox1)) {
        if (checkbox1) {
          addHitbox(BONEINDEX::head);
        } else {
          removeHitbox(BONEINDEX::head);
        }
      }
      ImGui::GetWindowDrawList()->AddLine(
          ImVec2(StartPos.x + 100, StartPos.y + 85),
          ImVec2(StartPos.x + 15, StartPos.y + 85),
          ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)), 1.8f);  // Neck
      ImGui::SetCursorScreenPos(ImVec2(StartPos.x + 5, StartPos.y + 85));
      if (ImGui::Checkbox(XorStr("###Neck"), &checkbox2)) {
        if (checkbox2) {
          addHitbox(BONEINDEX::neck_0);
        } else {
          removeHitbox(BONEINDEX::neck_0);
        }
      }
      ImGui::GetWindowDrawList()->AddLine(
          ImVec2(StartPos.x + 90, StartPos.y + 110),
          ImVec2(StartPos.x + 190, StartPos.y + 110),
          ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)), 1.8f);  // Chest
      ImGui::SetCursorScreenPos(ImVec2(StartPos.x + 190, StartPos.y + 110));
      if (ImGui::Checkbox(XorStr("###Chest"), &checkbox3)) {
        if (checkbox3) {
          addHitbox(BONEINDEX::spine_1);
        } else {
          removeHitbox(BONEINDEX::spine_1);
        }
      }
      ImGui::GetWindowDrawList()->AddLine(
          ImVec2(StartPos.x + 80, StartPos.y + 135),
          ImVec2(StartPos.x + 15, StartPos.y + 135),
          ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)), 1.8f);  // Stomache
      ImGui::SetCursorScreenPos(ImVec2(StartPos.x + 5, StartPos.y + 135));
      if (ImGui::Checkbox(XorStr("###Stomache"), &checkbox4)) {
        if (checkbox4) {
          addHitbox(BONEINDEX::spine_2);
        } else {
          removeHitbox(BONEINDEX::spine_2);
        }
      }
      ImGui::GetWindowDrawList()->AddLine(
          ImVec2(StartPos.x + 85, StartPos.y + 165),
          ImVec2(StartPos.x + 190, StartPos.y + 165),
          ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)), 1.8f);  // Penis
      ImGui::SetCursorScreenPos(ImVec2(StartPos.x + 190, StartPos.y + 165));
      if (ImGui::Checkbox(XorStr("###Penis"), &checkbox5)) {
        if (checkbox5) {
          addHitbox(BONEINDEX::pelvis);
        } else {
          removeHitbox(BONEINDEX::pelvis);
        }
      }
      ImGui::SetCursorScreenPos(ImVec2(StartPos.x, StartPos.y + 260));
      ImGui::PopStyleVar();
    }
    ImGui::EndChild();
    ImGui::SameLine();
    ImGui::SetCursorPosY(childBegin);
    ImGui::BeginGroup();
    {
      ImGui::BeginChild(
          LangSettings::ChildTriggerbot.c_str(),
          ImVec2(child_size.x,
                 (child_size.y - (style.ItemInnerSpacing.y)) * .55f));
      {
        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding,
                            ImVec2(style.FramePadding.x, 0));
        ImGui::Checkbox(LangSettings::SwitchEnableTriggerbot.c_str(),
                        &config::TriggerBot);
        ImGui::HotKey(XorStr(" ##hotkeytrigger"), &config::TriggerBotHotKey);
        ImGui::SliderInt(LangSettings::SliderTriggerDelay.c_str(),
                         &config::TriggerDelay, 0, 1000, XorStr("%d ms"));
        ImGui::SliderInt(LangSettings::SliderShotDuration.c_str(),
                         &config::ShotDuration, 15, 1000, XorStr("%d ms"));
        ImGui::SliderFloat(LangSettings::SliderTriggerMaxRecoil.c_str(),
                           &config::TriggerMaxRecoil, 1.f, 90.f,
                           XorStr("%.1f"));
        ImGui::Checkbox(LangSettings::SwitchTriggerScopeOnly.c_str(),
                        &config::TriggerScopeOnly);
        ImGui::Checkbox(LangSettings::SwitchTriggerIgnoreFlash.c_str(),
                        &config::TriggerIgnoreFlash);
        ImGui::PopStyleVar();
      }
      ImGui::EndChild();

      ImGui::BeginChild(
          LangSettings::ChildRCS.c_str(),
          ImVec2(child_size.x,
                 (child_size.y - (style.ItemInnerSpacing.y)) * .45f));
      {
        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding,
                            ImVec2(style.FramePadding.x, 0));
        ImGui::Checkbox(LangSettings::SwitchEnableRCS.c_str(), &config::RCS);
        float RCSScaleValues[2] = {config::RCSScale.x, config::RCSScale.y};
        ImGui::SliderFloat2(LangSettings::SliderRCSScale.c_str(),
                            RCSScaleValues, -.5f, 2.5f, XorStr("%.2f"));
        config::RCSScale = Vector2(RCSScaleValues[0], RCSScaleValues[1]);
        ImGui::SliderInt(LangSettings::SliderRCSStartBullet.c_str(),
                         &config::RCSBullet, 1, 15, XorStr("%d"));
        ImGui::PopStyleVar();
      }
      ImGui::EndChild();

    }
    ImGui::EndGroup();
    ImGui::EndTabItem();
  }

  if (ImGui::BeginTabItem(LangSettings::TabVisuals.c_str())) {
    ImVec2 child_size =
        ImVec2((ImGui::GetColumnWidth() - (style.ItemSpacing.x * 2)) / 3,
               ImGui::GetWindowHeight() - 10.f -
                   (ImGui::GetCursorPosY() + style.ItemInnerSpacing.y * 2));
    // static float flOverlayChildSize = 0.f;

    ImGui::BeginChild(LangSettings::ChildESP.c_str(), child_size);
    {
      ImGui::PushStyleVar(ImGuiStyleVar_FramePadding,
                          ImVec2(style.FramePadding.x, 0));

      ImGui::Checkbox(LangSettings::SwitchEnableESP.c_str(), &config::ESP);
      ImGui::Checkbox(LangSettings::SwitchPlayerInfo.c_str(), &config::ESPInfo);
      ImGui::Checkbox(LangSettings::SwitchBox.c_str(), &config::ESPBox);
      ImGui::Checkbox(LangSettings::SwitchPlayerName.c_str(), &config::ESPName);
      ImGui::Checkbox(LangSettings::SwitchHealthBar.c_str(), &config::ESPHealth);
      ImGui::PopStyleVar();

      // flOverlayChildSize = ImGui::GetCursorPosY() + style.ItemSpacing.y;
    }
    ImGui::EndChild();

    ImGui::SameLine();

    ImGui::BeginChild(LangSettings::ChildWorld.c_str(), child_size);
    {
      ImGui::PushStyleVar(ImGuiStyleVar_FramePadding,
                          ImVec2(style.FramePadding.x, 0));
      ImGui::Checkbox(LangSettings::SwitchC4ESP.c_str(), &config::C4ESP);
      ImGui::PopStyleVar();
    }
    ImGui::EndChild();

    ImGui::SameLine();

    ImGui::BeginChild(LangSettings::ChildVisualOthers.c_str(), child_size);
    {
      ImGui::PushStyleVar(ImGuiStyleVar_FramePadding,
                          ImVec2(style.FramePadding.x, 0));
      ImGui::Checkbox(LangSettings::SwitchEnableRadar.c_str(), &config::Radar);
      ImGui::Checkbox(LangSettings::SwitchRadarCrossline.c_str(),
                      &config::RadarCrossLine);
      ImGui::SliderFloat(LangSettings::SliderRadarPointSize.c_str(),
                         &config::RadarPointSize, 0.5f, 5.f, XorStr("%.1f p"));
      ImGui::SliderFloat(LangSettings::SliderRadarProportion.c_str(),
                         &config::RadarProportion, 500.f, 5000.f,
                         XorStr("%.1f u"));
      ImGui::SliderFloat(LangSettings::SliderRadarRange.c_str(),
                         &config::RadarRange, 50.f, 300.f, XorStr("%.1f u"));
      ImGui::PopStyleVar();
    }
    ImGui::EndChild();

    ImGui::EndTabItem();
  }

  if (ImGui::BeginTabItem(LangSettings::TabMiscs.c_str())) {
    ImVec2 child_size =
        ImVec2((ImGui::GetColumnWidth() - (style.ItemSpacing.x * 2)) / 3,
               ImGui::GetWindowHeight() - 10.f -
                   (ImGui::GetCursorPosY() + style.ItemInnerSpacing.y * 2));

    ImGui::BeginChild(LangSettings::ChildMiscGlobals.c_str(), child_size);
    {
      ImGui::PushStyleVar(ImGuiStyleVar_FramePadding,
                          ImVec2(style.FramePadding.x, 0));
      ImGui::Checkbox(LangSettings::SwitchSonar.c_str(), &config::Sonar);
      ImGui::Checkbox(LangSettings::SwitchPitchIndicator.c_str(),
                      &config::PitchIndicator);
      ImGui::Checkbox(LangSettings::SwitchC4Timer.c_str(), &config::C4Timer);
      ImGui::Checkbox(LangSettings::SwitchSpecList.c_str(), &config::SpecList);
      ImGui::PopStyleVar();
    }
    ImGui::EndChild();

    ImGui::SameLine();

    ImGui::BeginChild(LangSettings::ChildMisc.c_str(), child_size);
    {
      ImGui::PushStyleVar(ImGuiStyleVar_FramePadding,
                          ImVec2(style.FramePadding.x, 0));
      ImGui::Checkbox(LangSettings::SwitchEnemyInfo.c_str(),
                      &config::InfoString);
      ImGui::PopStyleVar();
    }
    ImGui::EndChild();

    ImGui::SameLine();

    ImGui::BeginChild(LangSettings::ChildMovement.c_str(), child_size);
    {
      ImGui::PushStyleVar(ImGuiStyleVar_FramePadding,
                          ImVec2(style.FramePadding.x, 0));
      ImGui::Checkbox(LangSettings::SwitchFastStop.c_str(), &config::FastStop);
      ImGui::SliderFloat(LangSettings::SliderFastStopMinVelocity.c_str(),
                         &config::FastStopMinVelocity, 2.5f, 100.f,
                         XorStr("%.1f u/s"));
      ImGui::PopStyleVar();
    }
    ImGui::EndChild();

    ImGui::EndTabItem();
  }

  if (ImGui::BeginTabItem(LangSettings::TabSettings.c_str())) {
    ImVec2 child_size =
        ImVec2((ImGui::GetColumnWidth() - (style.ItemSpacing.x * 2)) / 3,
               ImGui::GetWindowHeight() - 10.f -
                   (ImGui::GetCursorPosY() + style.ItemInnerSpacing.y * 2));
    static char configNameBuffer[64] = "NewConfig";
    static char configAuthorBuffer[64] = "";
    ImGui::BeginChild(XorStr("Info"), child_size);
    {
      ImGui::PushStyleVar(ImGuiStyleVar_FramePadding,
                          ImVec2(style.FramePadding.x, 0));
      ImGui::Text(LangSettings::TextLastBuild.c_str(), __DATE__);
      ImGui::Text(LangSettings::TextBuildVersion.c_str(),
                  std::to_string(CS_VERSION).c_str());
      ImGui::Text(LangSettings::TextCurrentGameVersion.c_str(),
                  std::to_string(gamevars::GameVersion).c_str());
#ifdef _MSC_VER
#ifndef __clang__
      ImGui::Text((LangSettings::TextCompiler + XorStr(" MSVC %s")).c_str(),
                  std::to_string(_MSC_VER).c_str());
#endif
#endif
#ifdef __GNUC__
#ifndef __clang__
      ImGui::Text((LangSettings::TextCompiler + XorStr(" GCC %s")).c_str(),
                  std::to_string(__GNUC__).c_str());
#endif
#endif
#ifdef __clang__
      ImGui::Text((LangSettings::TextCompiler + XorStr(" Clang %s")).c_str(),
                  std::to_string(__clang_major__).c_str());
#endif
      ImGui::Text(LangSettings::TextLicenceToUser.c_str(),
                  global::user_name.c_str());
      ImGui::TextUnformatted(LangSettings::textfortranslator.c_str());
      ImGui::PopStyleVar();
    }
    ImGui::EndChild();

    ImGui::SameLine();

    configsaver::UpdateConfigFiles();
    ImGui::BeginChild(LangSettings::ChildConfigList.c_str(), child_size);
    {
      ImGui::PushStyleVar(ImGuiStyleVar_FramePadding,
                          ImVec2(ImGui::GetStyle().FramePadding.x, 0));

      const float itemWidth = 200.0f;
      const float availableWidth = ImGui::GetContentRegionAvail().x;
      const int columns = std::max(1, static_cast<int>(availableWidth / itemWidth));

      ImGui::Columns(columns, NULL, false);

      for (const auto& [file_name, modify_time_string, author_name] :
           configsaver::configFiles) {
        ImGui::PushID(file_name.c_str());
        ImGui::BeginChild(
            (XorStr("##") + file_name).c_str(), ImVec2(itemWidth - 10, 85),
            true,
            ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoScrollbar);
        {
          ImGui::SetCursorPos(ImVec2(5.f, 3.f));
          std::string configname = file_name;
          size_t pos = configname.find_last_of('.');
          if (pos != std::string::npos) {
            configname.erase(pos);
          }
          ImGui::TextUnformatted(configname.c_str());
          ImGui::TextUnformatted(modify_time_string.c_str());
          ImGui::Text(LangSettings::TextConfigAuthor.c_str(),
                      author_name.empty() ? XorStr("Akaza Akari")
                                          : author_name.c_str());

          if (configsaver::selectedConfigFile == file_name) {
            if (ImGui::Button(LangSettings::ButtonSave.c_str())) {
              configsaver::SaveConfig(file_name, configAuthorBuffer);
            }
            ImGui::SameLine();
            if (ImGui::Button(LangSettings::ButtonReLoad.c_str())) {
              configsaver::LoadConfig(file_name);
            }
          } else {
            if (ImGui::Button(LangSettings::ButtonLoad.c_str())) {
              configsaver::LoadConfig(file_name);
              configsaver::selectedConfigFile = file_name;
            }
          }
          ImGui::SameLine();
          if (ImGui::Button(LangSettings::ButtonDelete.c_str())) {
            configsaver::deletePendingFile = file_name;
            ImGui::OpenPopup(XorStr("##deleteConfirm"));
          }
          if (ImGui::BeginPopup(XorStr("##deleteConfirm"))) {
            ImGui::Text(LangSettings::TextDeleteConfirm.c_str(),
                        configsaver::deletePendingFile.c_str());
            if (ImGui::Button(LangSettings::ButtonYes.c_str())) {
              std::string fullPath =
                  config::path + "\\" + configsaver::deletePendingFile;
              std::remove(fullPath.c_str());
              configsaver::deletePendingFile.clear();
              ImGui::CloseCurrentPopup();
            }
            ImGui::SameLine();
            if (ImGui::Button(LangSettings::ButtonNo.c_str())) {
              configsaver::deletePendingFile.clear();
              ImGui::CloseCurrentPopup();
            }
            ImGui::EndPopup();
          }
        }
        ImGui::EndChild();
        if (ImGui::IsItemClicked() &&
            configsaver::selectedConfigFile != file_name) {
          configsaver::LoadConfig(file_name);
          configsaver::selectedConfigFile = file_name;
        }
        bool hovered = ImGui::IsItemHovered();
        ImVec2 p_min = ImGui::GetItemRectMin();
        ImVec2 p_max = ImGui::GetItemRectMax();
        ImU32 border_color =
            (configsaver::selectedConfigFile == file_name)
                ? ImGui::GetColorU32(ImGuiCol_FrameBgActive)
                : (hovered ? ImGui::GetColorU32(ImGuiCol_FrameBgHovered)
                           : ImGui::GetColorU32(ImGuiCol_FrameBg));
        ImDrawList* draw_list = ImGui::GetWindowDrawList();
        draw_list->AddRect(p_min, p_max, border_color, 0.0f, 0, 1.0f);
        ImGui::PopID();

        ImGui::NextColumn();
      }
      ImGui::Columns(1);

      ImGui::PopStyleVar();
    }
    ImGui::EndChild();

    ImGui::SameLine();

    ImGui::BeginChild(LangSettings::ChildSettings.c_str(), child_size);
    {
      ImGui::PushStyleVar(ImGuiStyleVar_FramePadding,
                          ImVec2(style.FramePadding.x, 0));
      ImGui::Checkbox(LangSettings::SwitchTeamCheck.c_str(),
                      &config::TeamCheck);
      ImGui::Checkbox(LangSettings::SwitchBypassCapture.c_str(),
                      &config::BypassCapture);
      ImGui::SliderFloat(LangSettings::SliderDormantTime.c_str(),
                         &config::DormantTime, 0.f, 10.f, XorStr("%.1f s"));
      ImGui::Combo(
          LangSettings::ComboStyle.c_str(), &config::Style,
          XorStr("Lumine\0Aimstar\0ImGui Classic\0ImGui Dark\0ImGui Light\0"));
      configsaver::RenderLangsFileCombo();
      const float CursorX = 10.f;
      const float ComponentWidth = ImGui::GetColumnWidth() -
                                   ImGui::GetStyle().ItemSpacing.x -
                                   CursorX * 2;

      if (ImGui::Button(LangSettings::ButtonCreateConfig.c_str())) {
        ImGui::OpenPopup(XorStr("##createConfirm"));
      }
      if (ImGui::BeginPopup(XorStr("##createConfirm"))) {
        ImGui::SetNextItemWidth(ComponentWidth);
        ImGui::Text("%s", LangSettings::TextNewConfigName.c_str());
        ImGui::InputText(XorStr("##newConfigName"), configNameBuffer,
                         sizeof(configNameBuffer));

        ImGui::SetNextItemWidth(ComponentWidth);
        ImGui::Text("%s", LangSettings::TextConfigAuthorName.c_str());
        ImGui::InputText(XorStr("##authorName"), configAuthorBuffer,
                         sizeof(configAuthorBuffer));
        std::string configFileName =
            std::string(configNameBuffer) + XorStr(".yaml");
        bool exists = std::any_of(configsaver::configFiles.begin(),
                        configsaver::configFiles.end(),
                                  [&](const auto& item) {
                                    return std::get<0>(item) == configFileName;
                                  });

        if (!exists && !configFileName.empty()) {
          if (ImGui::Button(LangSettings::ButtonCreate.c_str())) {
            configsaver::SaveConfig(configFileName, configAuthorBuffer);
            configsaver::selectedConfigFile = configFileName;
          }
        } else {
          ImGui::BeginDisabled();
          {
            ImGui::Button(LangSettings::ButtonCreate.c_str());
          }
          ImGui::EndDisabled();
        }
        ImGui::EndPopup();
      }
      ImGui::SameLine();
      if (ImGui::Button(LangSettings::ButtonOpenFolder.c_str())) {
        ShellExecuteA(NULL, XorStr("open"), config::path.c_str(), NULL, NULL,
                      SW_SHOWNORMAL);
      }
      if (ImGui::Button(LangSettings::ButtonExtendFonts.c_str())) {
        ImGui::OpenPopup(XorStr("##extendFonts"));
      }
      if (ImGui::BeginPopup(XorStr("##extendFonts"))) {
        ImGui::Checkbox(XorStr("Greek"), &LangSettings::greek);
        ImGui::Checkbox(XorStr("Viet"), &LangSettings::vietnamese);
        ImGui::Checkbox(XorStr("China&Nippon"), &LangSettings::kanji);
        ImGui::Checkbox(XorStr("Korea"), &LangSettings::korean);
        ImGui::Checkbox(XorStr("Arab"), &LangSettings::arabic);
        ImGui::Checkbox(XorStr("Thai"), &LangSettings::thai);

        if (ImGui::Button(LangSettings::ButtonApply.c_str())) {
          global::is_font_update_pending = true;
        }
        ImGui::EndPopup();
      }
      if (ImGui::Button(LangSettings::ButtonUnhook.c_str())) {
        global::is_running = false;
      }

      ImGui::Text("%s", XorStr("Menukey [DEL]"));
      ImGui::PopStyleVar();
    }
    ImGui::EndChild();

    ImGui::EndTabItem();
  }

  if (ImGui::BeginTabItem(LangSettings::TabExperimental.c_str())) {
    ImVec2 child_size =
        ImVec2((ImGui::GetColumnWidth() - (style.ItemSpacing.x * 2)) / 3,
               ImGui::GetWindowHeight() - 10.f -
                   (ImGui::GetCursorPosY() + style.ItemInnerSpacing.y * 2));

    ImGui::BeginChild(LangSettings::ChildLoopInterval.c_str(), child_size);
    {
      ImGui::PushStyleVar(ImGuiStyleVar_FramePadding,
                          ImVec2(style.FramePadding.x, 0));
      ImGui::SliderInt(LangSettings::SliderRenderFPS.c_str(),
                       &config::RenderFPS, 29, 1000,
                       (config::RenderFPS >= 30)
                           ? XorStr("%d")
                           : LangSettings::TextFPSBased.c_str());
      config::RenderInterval = (config::RenderFPS > 30) ? (1000 / config::RenderFPS) : 0;
      ImGui::SliderInt(LangSettings::SliderGlobalVarsInterval.c_str(),
                       &config::GlobalVarsInterval, 0, 1000,
                       config::GlobalVarsInterval
                           ? XorStr("%d ms")
                           : LangSettings::TextFPSBased.c_str());
      ImGui::SliderInt(LangSettings::SliderEntityInterval.c_str(),
                       &config::EntityInterval, 0, 1000,
                       config::EntityInterval
                           ? XorStr("%d ms")
                           : LangSettings::TextFPSBased.c_str());
      ImGui::SliderInt(LangSettings::SliderParserInterval.c_str(),
                       &config::ParserInterval, 0, 1000,
                       config::ParserInterval
                           ? XorStr("%d ms")
                           : LangSettings::TextFPSBased.c_str());
      ImGui::SliderInt(LangSettings::SliderAimInterval.c_str(),
                       &config::AimInterval, 0, 1000,
                       config::AimInterval
                           ? XorStr("%d ms")
                           : LangSettings::TextFPSBased.c_str());
      ImGui::SliderInt(LangSettings::SliderViewInterval.c_str(),
                       &config::ViewInterval, 0, 1000,
                       config::ViewInterval
                           ? XorStr("%d ms")
                           : LangSettings::TextFPSBased.c_str());
      ImGui::SliderInt(LangSettings::SliderMemoryInterval.c_str(),
                       &config::MemoryInterval, 0, 1000,
                       config::MemoryInterval
                           ? XorStr("%d ms")
                           : LangSettings::TextFPSBased.c_str());
      ImGui::SliderInt(LangSettings::SliderNonMemoryInterval.c_str(),
                       &config::NonMemoryInterval, 0, 1000,
                       config::NonMemoryInterval
                           ? XorStr("%d ms")
                           : LangSettings::TextFPSBased.c_str());
      

      ImGui::PopStyleVar();
    }
    ImGui::EndChild();

    ImGui::EndTabItem();
  }

  ImGui::EndTabBar();
  ImGui::SetCursorPos(ImVec2{style.ItemSpacing.x, 350});
  ImGui::Text(
      XorStr("Samidare for Counter-Strike 2 by Ukia %s"),
      UkiaData::strHWID.substr(UkiaData::strHWID.length() - 16).c_str());

  ImGui::End();
  ImVec2 mousePos = ImGui::GetMousePos();
  float interpolationFactorX = 0.035f;
  float interpolationFactorY = 0.015f;
  ImVec2 center = ImVec2(vecMenuPos.x - 300, vecMenuPos.y + 25);
  float radius = 40;
  ImVec2 factor = ImVec2(interpolationFactorX * (mousePos.x - vecMenuPos.x),
                         interpolationFactorY * (mousePos.y - vecMenuPos.y));
  ImVec2 interpolatedPos{center.x - factor.x, center.y - factor.y};

  // 计算 interpolatedPos 到圆心的距离
  float dx = interpolatedPos.x - center.x;
  float dy = interpolatedPos.y - center.y;
  float distance = sqrt(dx * dx + dy * dy);

  // 如果距离超过半径，则调整 interpolatedPos
  if (distance > radius) {
    float scale = radius / distance;
    factor.x = -dx * scale;
    factor.y = -dy * scale;
    interpolatedPos = ImVec2{center.x - factor.x, center.y - factor.y};
  }

  const ImVec2 vecOverlayPadding = ImVec2(90.f, 30.f);
  ImGui::PopStyleVar();
  ImGui::SetNextWindowPos(interpolatedPos);
  ImGui::Begin(XorStr("moe"), nullptr,
               ImGuiWindowFlags_NoMouseInputs |
                   ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove |
                   ImGuiWindowFlags_NoFocusOnAppearing |
                   ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar |
                   ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoCollapse |
                   ImGuiWindowFlags_NoScrollbar |
                   ImGuiWindowFlags_::ImGuiWindowFlags_NoBringToFrontOnFocus |
                   ImGuiWindowFlags_::ImGuiWindowFlags_NoBackground |
                   ImGuiWindowFlags_::ImGuiWindowFlags_NoNavFocus |
                   ImGuiWindowFlags_::ImGuiWindowFlags_NoNav);
  {
    ImGui::SetCursorPos(ImVec2{50, 25});
    ImGui::Image((ImTextureID)global::shigure_texture, ImVec2{258, 349},
                 ImVec2{0, 0},
                 ImVec2{1, 1});

    const ImVec2 vecWindPos = ImGui::GetWindowPos();
    const ImVec2 vecWindSize = ImGui::GetWindowSize();

    ImDrawList* pDrawList = ImGui::GetWindowDrawList();
    ImGui::SetCursorPos(ImVec2{20, 40});
    if (config::ESP) {
      ImVec4 vecBox = {
          vecWindPos.x + vecOverlayPadding.x + 50.f, vecWindPos.y + 15,
          vecWindPos.x + vecWindSize.x - vecOverlayPadding.x + 50.f,
          vecWindPos.y + vecWindSize.y - vecOverlayPadding.y};
      vecBox.x -= factor.x * 0.15f;
      vecBox.z -= factor.x * 0.15f;
      vecBox.y -= factor.y * 0.15f;
      vecBox.w -= factor.y * 0.15f;
      if (config::ESPInfo) {
        std::ostringstream playerInfo;
        playerInfo << XorStr("^\n") << XorStr("Health: ") << 100 << XorStr("\n")
                   << XorStr("Dist:") << 114.514f << XorStr("\n");
        DrawStrokeText((vecBox.x + vecBox.z) * 0.5f,
                       vecBox.w, &White,
                       playerInfo.str().c_str());
      }

      if (config::ESPBox) {
        DrawEspBox2D(ImVec2((vecBox.x + vecBox.z) * 0.5f, vecBox.w),
                     ImVec2((vecBox.x + vecBox.z) * 0.5f, vecBox.y),
                     &Red, 1, pDrawList);
      }
      if (config::ESPName)
        DrawNameTag(ImVec2((vecBox.x + vecBox.z) * 0.5f, vecBox.w),
                    ImVec2((vecBox.x + vecBox.z) * 0.5f, vecBox.y),
                    (char*)(XorStr("Not ") + global::user_name).c_str());
      float t = static_cast<float>(ImGui::GetTime());
      int valueHealth = static_cast<int>(std::abs(std::sin(t)) * 120.f);
      if (config::ESPHealth)
        DrawHealthBar(ImVec2((vecBox.x + vecBox.z) * 0.5f, vecBox.w),
                      ImVec2((vecBox.x + vecBox.z) * 0.5f, vecBox.y),
                      valueHealth, 100, &Green, &Transparent, pDrawList);
    }
    ImGui::SetCursorPos(ImVec2{15 + textoffset, 250 - textoffset} * 1.f +
                        factor * 0.3351f);
    ImGui::TextColored(ImColor(70, 50, 240, 200), "%s",
                       XorStr("NOT FOR SELLING!!"));
    ImGui::SetCursorPos(ImVec2{15 + textoffset, 295 - textoffset} * 1.f +
                        factor * 0.1337f);
    ImGui::TextColored(ImColor(70, 50, 240, 200), "%s",
                       XorStr("Samidare for Counter-Strike 2"));
    ImGui::SetCursorPos(ImVec2{15 + textoffset, 335 - textoffset} * 1.f +
                        factor * 0.2024f);
    ImGui::TextColored(ImColor(70, 50, 240, 200), XorStr("Build: %s %s"),
                       __DATE__, __TIME__);
    ImGui::SetCursorPos(ImVec2{15 - textoffset, 250 + textoffset} * 1.f +
                        factor * 0.3351f);
    ImGui::TextColored(ImColor(235, 5, 85, 200), "%s",
                       XorStr("NOT FOR SELLING!!"));
    ImGui::SetCursorPos(ImVec2{15 - textoffset, 295 + textoffset} * 1.f +
                        factor * 0.1337f);
    ImGui::TextColored(ImColor(235, 5, 85, 200), "%s",
                       XorStr("Samidare for Counter-Strike 2"));
    ImGui::SetCursorPos(ImVec2{15 - textoffset, 335 + textoffset} * 1.f +
                        factor * 0.2024f);
    ImGui::TextColored(ImColor(235, 5, 85, 200), XorStr("Build: %s %s"),
                       __DATE__, __TIME__);
    ImGui::SetCursorPos(ImVec2{15, 250} * 1.f + factor * 0.3351f);
    ImGui::TextColored(ImColor(245, 245, 245, 245), "%s",
                       XorStr("NOT FOR SELLING!!"));
    ImGui::SetCursorPos(ImVec2{15, 295} * 1.f + factor * 0.1337f);
    ImGui::TextColored(ImColor(245, 245, 245, 245), "%s",
                       XorStr("Samidare for Counter-Strike 2"));
    ImGui::SetCursorPos(ImVec2{15, 335} * 1.f + factor * 0.2024f);
    ImGui::TextColored(ImColor(245, 245, 245, 245), XorStr("Build: %s %s"),
                       __DATE__, __TIME__);
  }
  ImGui::End();
}
}  // namespace Menu
#endif  // MENU_H_



================================================
FILE: Functions/Aimbot/Aimbot.cc
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: Aimbot.cc
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file contains aimbot functions.
//
// -----------------------------------------------------------------------------
#include "pch.h"
#include "Aimbot.h"

#include "../../UkiaStuff.h"
#include "../config.h"
#include "../../Driver.h"

inline void UpdateAngles(const CEntity& Local, Vector3& Angles) {
  auto oldPunch = Vector3{};
  auto shotsFired = Local.Pawn.ShotsFired;

  int ScreenCenterX = static_cast<int>(global::screen_size.x / 2);
  int ScreenCenterY = static_cast<int>(global::screen_size.y / 2);
  auto aimPunch = Local.Pawn.AimPunchAngle;
  if (shotsFired) {
    Vector3 viewAngles;
    if (!gGame.GetViewAngles(viewAngles)) return;
    auto newAngles = Vector3{viewAngles.x + oldPunch.x - aimPunch.x * 2.f,
                             viewAngles.y + oldPunch.y - aimPunch.y * 2.f, 0};

    if (newAngles.x > 89.f) newAngles.x = 89.f;

    if (newAngles.x < -89.f) newAngles.x = -89.f;

    while (newAngles.y > 180.f) newAngles.y -= 360.f;

    while (newAngles.y < -180.f) newAngles.y += 360.f;

    newAngles.x += ScreenCenterX;
    newAngles.y += ScreenCenterY;
    Angles = newAngles;
    oldPunch = aimPunch;
  } else {
    oldPunch = aimPunch;
  }

  if (Local.Pawn.Ammo > 1 /*Local.Pawn.ShotsFired > RCSBullet*/) {
    Vector2 PunchAngle;
    if (Local.Pawn.AimPunchCache.Count <= 0 ||
        Local.Pawn.AimPunchCache.Count > 0xFFFF)
      return;
    if (!Ukia::ProcessMgr.ReadMemory<Vector2>(
            Local.Pawn.AimPunchCache.Data +
                (Local.Pawn.AimPunchCache.Count - 1) * sizeof(Vector3),
            PunchAngle))
      return;

    Angles.x = PunchAngle.x;
    Angles.y = PunchAngle.y;
  } else {
    Angles.x = 0.f;
    Angles.y = 0.f;
  }
}

namespace AimBot {

inline void AimBot(const CEntity& Local, Vector3 LocalPos,
                   std::vector<Vector3>& AimPosList) {
  // int isFired;
  // ProcessMgr.ReadMemory(Local.Pawn.Address + Offset::Pawn.iShotsFired,
  // isFired); if (!isFired && !AimLock)
  //  When players hold these weapons, don't aim
  // When players hold c4/knife/grenades etc., don't aim
  if (Local.Pawn.MaxAmmo < 1) {
    gamevars::IsAimbotting = false;
    return;
  }
  if (Local.Pawn.ShotsFired <=  static_cast<unsigned int>(config::AimBullet) && config::AimBullet != 0) {
    gamevars::IsAimbotting = false;
    return;
  }
  Vector3 Aimpunch = Local.Pawn.AimPunchAngle;
  if (Aimpunch.Length() > config::TriggerMaxRecoil) {
    gamevars::IsAimbotting = false;
    return;
  }
  if (config::AimScopeOnly) {
    if (!Local.Pawn.Scoped) {
      gamevars::IsAimbotting = false;
      return;
    }
  }

  if (!config::AimIgnoreFlash && Local.Pawn.FlashDuration > 0.15f) {
    gamevars::IsAimbotting = false;
    return;
  }

  int ListSize =  static_cast<int>(AimPosList.size());
  float BestNorm = FLT_MAX;
  if (!ListSize) {
    gamevars::IsAimbotting = false;
    return;
  }
  float Yaw, Pitch;
  float Distance, Norm;
  // , Length;
  Vector3 Angles{0, 0, 0};
  int ScreenCenterX = static_cast<int>(global::screen_size.x / 2);
  int ScreenCenterY = static_cast<int>(global::screen_size.y / 2);
  float TargetX = 0.f;
  float TargetY = 0.f;

  Vector2 ScreenPos;

  bool IsAuto = Local.Pawn.IsAuto;

  for (int i = 0; i < ListSize; i++) {
    Vector3 OppPos;

    OppPos = AimPosList[i] - LocalPos;

    Distance = static_cast<float>(sqrt(pow(OppPos.x, 2) + pow(OppPos.y, 2)));

    // Length = OppPos.Length();

    // RCS by @Tairitsu
    if (IsAuto) {
      UpdateAngles(Local, Angles);
      float rad = Angles.x / 360.f * static_cast<float>(M_PI);
      float si = sinf(rad);
      float co = cosf(rad);

      float z = OppPos.z * co + Distance * si;
      float d = (Distance * co - OppPos.z * si) / Distance;

      rad = -Angles.y / 360.f * static_cast<float>(M_PI);
      si = sinf(rad);
      co = cosf(rad);

      float x = (OppPos.x * co - OppPos.y * si) * d;
      float y = (OppPos.x * si + OppPos.y * co) * d;

      OppPos = Vector3{x, y, z};

      AimPosList[i] = LocalPos + OppPos;
    }

    Yaw = atan2f(OppPos.y, OppPos.x) * 57.2957795131f - Local.Pawn.ViewAngle.y;
    Pitch = -atan(OppPos.z / Distance) * 57.2957795131f - Local.Pawn.ViewAngle.x;
    Norm = static_cast<float>(sqrt(pow(Yaw, 2) + pow(Pitch, 2)));
    if (Norm < BestNorm) BestNorm = Norm;
    gGame.View.WorldToScreen(Vector3(AimPosList[i]), ScreenPos);
  }

  if (Norm < config::AimFov && Norm > config::AimFovMin) {
    // Shake Fixed by @Sweely
    if (ScreenPos.x != ScreenCenterX) {
      TargetX = (ScreenPos.x > ScreenCenterX) ? -(ScreenCenterX - ScreenPos.x)
                                              : ScreenPos.x - ScreenCenterX;
      TargetX /= config::AimSmooth != 0.0f ? config::AimSmooth : 1.5f;
      TargetX = (TargetX + ScreenCenterX > ScreenCenterX * 2 ||
                 TargetX + ScreenCenterX < 0)
                    ? 0
                    : TargetX;
    }

    if (ScreenPos.y != 0) {
      if (ScreenPos.y != ScreenCenterY) {
        TargetY = (ScreenPos.y > ScreenCenterY) ? -(ScreenCenterY - ScreenPos.y)
                                                : ScreenPos.y - ScreenCenterY;
        TargetY /= config::AimSmooth != 0.0f ? config::AimSmooth : 1.5f;
        TargetY = (TargetY + ScreenCenterY > ScreenCenterY * 2 ||
                   TargetY + ScreenCenterY < 0)
                      ? 0
                      : TargetY;
      }
    }

    // Dynamic AimSmooth based on distance
    float DistanceRatio =
        Norm / config::AimFov;  // Calculate the distance ratio
    float SpeedFactor =
        1.0f + (1.0f - DistanceRatio);  // Determine the speed factor based on
                                        // the distance ratio
    TargetX /= (config::AimSmooth * SpeedFactor);
    TargetY /= (config::AimSmooth * SpeedFactor);
    // by Skarbor

    if (ScreenPos.x != ScreenCenterX) {
      TargetX = (ScreenPos.x > ScreenCenterX) ? -(ScreenCenterX - ScreenPos.x)
                                              : ScreenPos.x - ScreenCenterX;
      TargetX /= config::AimSmooth != 0.0f ? config::AimSmooth : 1.5f;
      TargetX = (TargetX + ScreenCenterX > ScreenCenterX * 2 ||
                 TargetX + ScreenCenterX < 0)
                    ? 0
                    : TargetX;
    }

    if (ScreenPos.y != 0) {
      if (ScreenPos.y != ScreenCenterY) {
        TargetY = (ScreenPos.y > ScreenCenterY) ? -(ScreenCenterY - ScreenPos.y)
                                                : ScreenPos.y - ScreenCenterY;
        TargetY /= config::AimSmooth != 0.0f ? config::AimSmooth : 1.5f;
        TargetY = (TargetY + ScreenCenterY > ScreenCenterY * 2 ||
                   TargetY + ScreenCenterY < 0)
                      ? 0
                      : TargetY;
      }
    }
    gamevars::IsAimbotting = true;
    #ifndef USERMODE
    driver.mouse_event(MOUSEEVENTF_MOVE, TargetX, TargetY, NULL, NULL);
    #else
    my_mouse_event(MOUSEEVENTF_MOVE, static_cast<DWORD>(TargetX),
                   static_cast<DWORD>(TargetY),
                   NULL, NULL);
    #endif
  } else
    gamevars::IsAimbotting = false;
}

void AimBotRun(std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) {
  if (!config::AimBot) {
    gamevars::IsAimbotting = false;
    return;
  }
  // AimBot data
  float DistanceToSight = 0;
  float MaxAimDistance = 100000;
  CEntity NearestEntity;
  Vector3 Angles{0, 0, 0};
  std::vector<Vector3> AimPosList;
  for (int index = 0; index < ValidEntity.size(); index++) {
    CEntity Entity = ValidEntity[index].first;
    if (!Entity.ESPAlive()) continue;
    if (!Entity.IsEnemy()) continue;
    if (!Entity.IsVisible()) continue;

    if (config::HitboxList.size() != 0) {
      for (int p = 0; p < config::HitboxList.size(); p++) {
        Vector3 TempPos;
        if (Entity.Pawn.Address == 0) continue;
        DistanceToSight = Entity.GetBone()
                              .BonePosList[config::HitboxList[p]]
                              .ScreenPos.DistanceTo(
                {global::screen_size.x / 2, global::screen_size.y / 2});

        TempPos = Entity.GetBone().BonePosList[config::HitboxList[p]].Pos;
        /*
        if (LocalEntity.Pawn.ShotsFired >= AimBullet + 1 &&
            MenuConfig::SparyPosition != 0 &&
            NearestEntity.Controller.Address != 0 &&
            Entity.Controller.Address == NearestEntity.Controller.Address) {
          if (HitboxList[p] == MenuConfig::SparyPositionIndex) {
            if (HitboxList[p] == BONEINDEX::head)
              TempPos.z -= 1.f;
            AimPosList.push_back(TempPos);
          }
        } else */
        if (DistanceToSight < MaxAimDistance) {
          MaxAimDistance = DistanceToSight;
          NearestEntity = Entity;
          if (config::HitboxList[p] == BONEINDEX::head) TempPos.z -= 1.f;
          AimPosList.push_back(TempPos);
        }
      }
    }
  }
  if (GetBindState(config::AimBotHotKey)) {
    if (AimPosList.size() != 0) {
      AimBot::AimBot(gamevars::LocalEntity, gamevars::LocalEntity.Pawn.CameraPos,
                     AimPosList);
    }
  }
}

}  // namespace AimBot



================================================
FILE: Functions/Aimbot/Aimbot.h
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: Aimbot.h
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file contains declare of aimbot function.
//
// -----------------------------------------------------------------------------
#pragma once
#ifndef AIMBOT_H_
#define AIMBOT_H_
#include "pch.h"

#include "../../CS2x64.h"

namespace AimBot
{

    void AimBotRun(std::vector<std::pair<CEntity, DWORD64>>& ValidEntity);
}
#endif  // AIMBOT_H_



================================================
FILE: Functions/Aimbot/RCS.cc
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: RCS.cc
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file contains recoil control system function.
//
// -----------------------------------------------------------------------------
#include "pch.h"
#include "RCS.h"

#include "../../Driver.h"
namespace RCS {

void RCSRun(CEntity& Local) noexcept {
  if (!config::RCS) return;
  static Vector3 OldPunch;
  if (Local.Pawn.ShotsFired > static_cast<unsigned int>(config::RCSBullet) &&
      !gamevars::IsAimbotting) {
    Vector3 delta = (OldPunch - (Local.Pawn.AimPunchAngle));

    int MouseX = static_cast<int>(std::round(
        (delta.y * config::RCSScale.x / gamevars::Sensitivity) / -0.022f));
    int MouseY = static_cast<int>(std::round(
        (delta.x * config::RCSScale.y / gamevars::Sensitivity) / 0.022f));

    if ((GetAsyncKeyState(VK_LBUTTON) & 0x8000))
#ifndef USERMODE
      driver.mouse_event(MOUSEEVENTF_MOVE, MouseX, MouseY, 0, 0);
#else
      my_mouse_event(MOUSEEVENTF_MOVE, MouseX, MouseY, 0, 0);
#endif
    OldPunch = Local.Pawn.AimPunchAngle;
  } else {
    OldPunch = Local.Pawn.AimPunchAngle;
  }
}
}  // namespace RCS



================================================
FILE: Functions/Aimbot/RCS.h
================================================
﻿#pragma once
#include "pch.h"
#include "../../CS2x64.h"
namespace RCS {
void RCSRun(CEntity& Local) noexcept;
}  // namespace RCS



================================================
FILE: Functions/Aimbot/TriggerBot.cc
================================================
﻿#include "pch.h"
#include "TriggerBot.h"

#include "../../UkiaStuff.h"
#include "../config.h"
#include "../../Driver.h"
namespace TriggerBot {
DWORD uHandle = 0;
DWORD64 ListEntry = 0;
DWORD64 PawnAddress = 0;
CEntity Entity;
bool AllowShoot = false;
//bool WaitForNoAttack = false;
HANDLE hDelayQueue, hDurationQueue;

inline void ReleaseMouseButton() {
#ifndef USERMODE
  driver.mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
#else
  my_mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
#endif
}

inline void DownMouseButton() {
#ifndef USERMODE
  driver.mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
#else
  my_mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
#endif
}

VOID CALLBACK OnDurationEnd(PVOID lpParam, BOOLEAN TimerOrWaitFired) {
  ReleaseMouseButton();
}

VOID CALLBACK OnDelay(PVOID lpParam, BOOLEAN TimerOrWaitFired) {
  DownMouseButton();
  HANDLE hDurationTimer = nullptr;
  CreateTimerQueueTimer(&hDurationTimer, hDurationQueue, OnDurationEnd, nullptr,
                        config::ShotDuration, 0, WT_EXECUTEDEFAULT);
}

void TriggerBotRun(const CEntity& LocalEntity) {

  if (!config::TriggerBot) {
    if (hDelayQueue != 0) {
      DeleteTimerQueueEx(hDelayQueue, nullptr);
      hDelayQueue = 0;
    }
    if (hDurationQueue != 0) {
      DeleteTimerQueueEx(hDurationQueue, nullptr);
      hDurationQueue = 0;
    }
    return;
  }
  if (LocalEntity.Controller.AliveStatus == 0) return;
  // When players hold c4/knife/grenades etc., don't shot
  if (LocalEntity.Pawn.MaxAmmo < 1) return;
  if (hDelayQueue == 0) {
    hDelayQueue = CreateTimerQueue();
  }
  if (hDurationQueue == 0) {
    hDurationQueue = CreateTimerQueue();
  }
  Vector3 Aimpunch = LocalEntity.Pawn.AimPunchAngle;
  if (Aimpunch.Length() > config::TriggerMaxRecoil)
    return;
  /*
  if (!Ukia::ProcessMgr.ReadMemory<bool>(
          LocalEntity.Pawn.Address + Offset::C_CSPlayerPawn.m_bWaitForNoAttack,
          WaitForNoAttack))
    return;
    */
  if (!Ukia::ProcessMgr.ReadMemory<DWORD>(
          LocalEntity.Pawn.Address + Offset::C_CSPlayerPawnBase.m_iIDEntIndex,
          uHandle))
    return;
  if (uHandle == -1) return;

  ListEntry = Ukia::ProcessMgr.TraceAddress(gGame.GetEntityListAddress(),
                                            {0x8 * (uHandle >> 9) + 0x10, 0x0});
  if (ListEntry == 0) return;

  if (!Ukia::ProcessMgr.ReadMemory<DWORD64>(
          ListEntry + 0x78 * (uHandle & 0x1FF), PawnAddress))
    return;

  if (!Entity.UpdatePawn(PawnAddress)) return;

  if (!config::TriggerIgnoreFlash && LocalEntity.Pawn.FlashDuration > 0.f)
    return;

  if (config::TriggerScopeOnly) {
    if (!LocalEntity.Pawn.Scoped) {
      return;
    }
  }

  AllowShoot = Entity.IsEnemy() && Entity.ESPAlive() &&
               GetBindState(config::TriggerBotHotKey) && !Entity.Pawn.isImmunity;

  if (Entity.Pawn.Pos.DistanceTo(LocalEntity.Pawn.Pos) >= 120.f &&
      LocalEntity.Pawn.WeaponName == XorStr("taser"))
    return;

  if (!AllowShoot) return;
  const bool isShootingInDuration =
      (GetAsyncKeyState(VK_LBUTTON) < 0);
  if (!isShootingInDuration) {
    HANDLE hDelayTimer = nullptr;
    CreateTimerQueueTimer(&hDelayTimer, hDelayQueue, OnDelay, nullptr,
                          config::TriggerDelay, 0, WT_EXECUTEDEFAULT);
  }
}
}  // namespace TriggerBot


================================================
FILE: Functions/Aimbot/TriggerBot.h
================================================
﻿#pragma once
#include "pch.h"

#include "../../CS2x64.h"

namespace TriggerBot
{
	inline unsigned int HotKey = VK_XBUTTON2;
	inline std::chrono::time_point<std::chrono::system_clock> timepoint = std::chrono::system_clock::now();
	inline std::chrono::time_point<std::chrono::system_clock> startTime = std::chrono::system_clock::now();
	inline bool recorded = false;
    inline bool isAim = false;
	// Triggerbot
    void TriggerBotRun(const CEntity& LocalEntity);
}


================================================
FILE: Functions/Miscs/BombTimer.cc
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: BombTimer.cc
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file contains bomb timer function.
//
// -----------------------------------------------------------------------------
#include "pch.h"
#include "BombTimer.h"

#include "../../UkiaStuff.h"
#include "../config.h"

namespace BombTimer {
std::pair<int, int> get_bomb_calculations_by_map(const std::string& map) {
  // get these with map_showbombradius
  if (map == "de_dust2") {
    return {500, 1750};
  } else if (map == "de_ancient") {
    return {650, 2275};
  } else if (map == "de_anubis") {
    return {450, 1575};
  } else if (map == "de_inferno") {
    return {620, 2170};
  } else if (map == "de_mirage") {
    return {650, 2275};
  } else if (map == "de_nuke") {
    return {650, 2275};
  } else if (map == "de_overpass") {
    return {650, 2275};
  } else if (map == "de_vertigo") {
    return {500, 1750};
  } else if (map == "de_train") {
    return {500, 1750};
  } else if (map == "de_assembly") {
    return {500, 1750};
  } else if (map == "de_memento") {
    return {500, 1750};
  } else if (map == "de_thera") {
    return {500, 1750};
  } else if (map == "de_mills") {
    return {500, 1750};
  } else if (map == "de_dogtown") {
    return {650, 2275};
  } else if (map == "de_brewery") {
    return {500, 1750};
  } else if (map == "de_jura") {
    return {500, 1750};
  } else if (map == "de_grail") {
    return {500, 1750};
  } else {
    return {500, 1750};
  }
}
float armor_modifier(float damage, int armor) {
  if (armor > 0) {
    const float armor_ratio = 0.5f;
    const float armor_bonus = 0.5f;
    float armor_ratio_multiply = damage * armor_ratio;
    float actual = (damage - armor_ratio_multiply) * armor_bonus;

    if (actual > static_cast<float>(armor)) {
      actual = static_cast<float>(armor) * (1.f / armor_bonus);
      armor_ratio_multiply = damage - actual;
    }

    damage = armor_ratio_multiply;
  }
  return damage;
}

int calculate_bomb_damage(Vector3 player, Vector3 bomb, int armor) {
  const std::pair<int, int> bomb_calculations =
      get_bomb_calculations_by_map(gamevars::MapName);
  const int bomb_damage = bomb_calculations.first;
  const int bomb_radius = bomb_calculations.second;

  const double c = bomb_radius / 3;
  const float damage = static_cast<float>(bomb_damage *
                       std::exp(-std::pow(sqrt(pow(player.x - bomb.x, 2) +
                                            pow(player.y - bomb.y, 2) +
                                            pow(player.z - bomb.z, 2)),
                                       2) / (2 * std::pow(c, 2))));
  const float damage_armor = armor_modifier(damage, armor);

  return static_cast<int>(std::ceil(
      damage_armor));  // if wanna more accurte, use std::round, ceil is to
                       // estim max damage to avoid unexpected death
}

void RenderWindow(std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) {
  if (!config::C4Timer) return;
  int damage = 0;

  if (gamevars::PlantedBomb.isPlanted && gamevars::PlantedBomb.boomRemaining > 0) {
    damage =
        calculate_bomb_damage(gamevars::LocalEntity.Pawn.Pos, gamevars::PlantedBomb.Pos,
                              gamevars::LocalEntity.Pawn.Armor);
  } else {
    damage = 0;
  }

  ImGuiWindowFlags flags =
      ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar;
  ImVec4 default_bg_color = ImGui::GetStyleColorVec4(ImGuiCol_WindowBg);
  default_bg_color.w = 0.5f;
  ImGui::PushStyleColor(ImGuiCol_WindowBg, default_bg_color);
  ImGui::SetNextWindowSizeConstraints(ImVec2(224, 95), ImVec2(500, 95));
  ImGui::Begin(XorStr("Bomb Timer"), nullptr, flags);

  float windowWidth = ImGui::GetWindowSize().x;
  float barLength = gamevars::PlantedBomb.boomRemaining <= 0.0f ? 0.0f
                    : gamevars::PlantedBomb.boomRemaining >= 40
                        ? 1.0f
                        : (gamevars::PlantedBomb.boomRemaining / 40.0f);
  if (gamevars::PlantedBomb.isPlanted && gamevars::PlantedBomb.boomRemaining > 0 &&
      !gamevars::PlantedBomb.hasExploded) {
    std::string text = LangSettings::TextBombOn;
    char buf[128];
    snprintf(buf, sizeof(buf), text.c_str(),
             (!gamevars::PlantedBomb.bombSite ? XorStr("A") : XorStr("B")),
             gamevars::PlantedBomb.boomRemaining);
    float textWidth = ImGui::CalcTextSize(buf).x;
    ImGui::SetCursorPosX((windowWidth - textWidth) * 0.5f);
    ImGui::Text(XorStr("%s"), buf);

    float barWidth = windowWidth - 20;
    ImGui::SetCursorPosX((windowWidth - barWidth) * 0.5f);
    ImGui::ProgressBar(barLength, ImVec2(barWidth, 15), "");

    text = LangSettings::TextBombEstimDamage;
    snprintf(buf, sizeof(buf), text.c_str(), damage);
    textWidth = ImGui::CalcTextSize(buf).x;
    ImGui::SetCursorPosX((windowWidth - textWidth) * 0.5f);
    ImGui::Text(XorStr("%s"), buf);

    if (gamevars::PlantedBomb.isDefusing) {
      std::string defuseText;
      snprintf(buf, sizeof(buf), LangSettings::TextDefuseCount.c_str(),
               (gamevars::PlantedBomb.defuseTime < gamevars::PlantedBomb.boomTime)
                   ? LangSettings::TextCanDefuse.c_str()
                   : LangSettings::TextCanNotDefuse.c_str(),
               gamevars::PlantedBomb.defuseRemaining);
      float defuseTextWidth = ImGui::CalcTextSize(buf).x;
      ImGui::SetCursorPosX((windowWidth - defuseTextWidth) * 0.5f);
      ImVec4 color = (gamevars::PlantedBomb.defuseTime < gamevars::PlantedBomb.boomTime)
                         ? ImVec4(0.2f, 1.0f, 0.2f, 1.0f)
                         : ImVec4(1.0f, 0.2f, 0.2f, 1.0f);
      ImGui::PushStyleColor(ImGuiCol_Text, color);
      ImGui::Text("%s", buf);
      ImGui::PopStyleColor();
    } else {
      text = LangSettings::TextNotDefusing;
      snprintf(buf, sizeof(buf), text.c_str(), damage);
      textWidth = ImGui::CalcTextSize(buf).x;
      ImGui::SetCursorPosX((windowWidth - textWidth) * 0.5f);
      ImGui::Text(XorStr("%s"), buf);
    }
  } else {
    std::string text = LangSettings::TextBombNotPlanted;
    float textWidth = ImGui::CalcTextSize(text.c_str()).x;
    ImGui::SetCursorPosX((windowWidth - textWidth) * 0.5f);
    ImGui::Text(XorStr("%s"), text.c_str());

    float barWidth = windowWidth - 20;
    ImGui::SetCursorPosX((windowWidth - barWidth) * 0.5f);
    ImGui::ProgressBar(0.0f, ImVec2(barWidth, 15), "");
  }

  ImGui::PopStyleColor();
  ImGui::End();
}
}  // namespace BombTimer



================================================
FILE: Functions/Miscs/BombTimer.h
================================================
﻿#pragma once
#include "pch.h"
#include "../../CS2x64.h"

namespace BombTimer
{
std::pair<int, int> get_bomb_calculations_by_map(const std::string& map);
float armor_modifier(float damage, int armor);
int calculate_bomb_damage(Vector3 player, Vector3 bomb, int armor);
void RenderWindow(std::vector<std::pair<CEntity, DWORD64>>& ValidEntity);
}


================================================
FILE: Functions/Miscs/Miscs.cc
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: Misc.cc
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file contains misc functions.
//
// -----------------------------------------------------------------------------
#include "pch.h"
#include "Miscs.h"

namespace Sonar {
struct SoundParams {
  float frequency = 1000.0f;  // 默认频率
  float interval = 1000.0f;   // 默认间隔(ms)
  bool active = false;        // 是否激活
};

std::atomic<bool> running{true};
std::mutex soundMutex;
SoundParams currentParams;

void SoundThread() noexcept {
  auto lastBeep = std::chrono::steady_clock::now();

  while (running) {
    if (!config::Sonar) break;
    std::this_thread::sleep_for(std::chrono::milliseconds(1));

    SoundParams localParams;
    {
      std::lock_guard<std::mutex> lock(soundMutex);
      localParams = currentParams;
    }

    if (localParams.active) {
      auto now = std::chrono::steady_clock::now();
      auto elapsed =
          std::chrono::duration_cast<std::chrono::milliseconds>(now - lastBeep)
              .count();

      if (elapsed >= localParams.interval) {
        Beep(static_cast<DWORD>(localParams.frequency), 35);
        lastBeep = now;
      }
    }
  }
}
}  // namespace Sonar

namespace Misc {

void FoundEnemy(
    std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept {
  if (!config::InfoString) return;

  std::ostringstream allinfo;

  int centerX = static_cast<int>(global::screen_size.x * 0.5f);
  int centerY = static_cast<int>(global::screen_size.y * 0.5f);
  CEntity* best_enemy = nullptr;
  float min_center_dist_sq = FLT_MAX;
  float min_3d_dist = FLT_MAX;
  Vector2 best_screen_pos;
  bool best_on_screen = false;
  const Vector3& local_pos = gamevars::LocalEntity.Pawn.CameraPos;
  for (int index = 0; index < ValidEntity.size(); index++) {
    CEntity Entity = ValidEntity[index].first;
    if (!Entity.IsEnemy()) continue;
    if (Entity.Pawn.IsDormanted) continue;
    Vector3 vecPos = Entity.Pawn.Pos;
    Vector3 head_pos = {vecPos.x, vecPos.y, vecPos.z + Entity.Pawn.Height};
    Vector2 head_screen_pos;
    bool on_screen = gGame.View.WorldToScreen(head_pos, head_screen_pos);
    float dist = vecPos.DistanceTo(local_pos);
    float center_dist_sq = FLT_MAX;

    if (on_screen && Entity.ESPAlive()) {
      float dx = head_screen_pos.x - centerX;
      float dy = head_screen_pos.y - centerY;
      center_dist_sq = dx * dx + dy * dy;
    }

    if (center_dist_sq < min_center_dist_sq) {
      min_center_dist_sq = center_dist_sq;
      min_3d_dist = dist;
      best_enemy = &ValidEntity[index].first;
      best_on_screen = on_screen;
      if (on_screen) {
        best_screen_pos = head_screen_pos;
      }
    } else if (center_dist_sq == min_center_dist_sq && dist < min_3d_dist) {
      min_3d_dist = dist;
      best_enemy = &ValidEntity[index].first;
      best_on_screen = on_screen;
      if (on_screen) {
        best_screen_pos = head_screen_pos;
      }
    }
  }

  if (best_enemy) {
    allinfo << "Enemy:\n"
            //<< "Name: " << best_enemy->Controller.PlayerName << "\n" show UTF8
            //incorrect
            << "Address: 0x" << std::hex << best_enemy->Pawn.Address << std::dec
            << "\n"
            << "Health: " << best_enemy->Pawn.Health << " HP\n"
            << "Team: " << best_enemy->Pawn.TeamID << "\n"
            << "Pos: (" << best_enemy->Pawn.Pos.x << ", "
            << best_enemy->Pawn.Pos.y << ", " << best_enemy->Pawn.Pos.z
            << ")\n";

    if (best_on_screen) {
      allinfo << "Screen pos: (" << best_screen_pos.x << ", "
              << best_screen_pos.y << ")\n";
    } else {
      allinfo << "Enemy OOF\n";
    }
  } else {
    allinfo << "No valid enemy\n";
  }

  allinfo << "Local:\n"
          << "Health: " << gamevars::LocalEntity.Pawn.Health << " HP\n"
          << "Team: " << gamevars::LocalEntity.Pawn.TeamID << "\n"
          << "Pos: (" << local_pos.x << ", " << local_pos.y << ", "
          << local_pos.z << ")\n"
          << "Flags: " << gamevars::LocalEntity.Pawn.fFlags << "\n"
          << "FOV: " << gamevars::LocalEntity.Pawn.Fov << "\n\n";
  global::gamedata_infos = allinfo.str();
  return;
}

void SonarRun(std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept {
  if (!config::Sonar) return;

  Sonar::SoundParams newParams;
  newParams.active = false;

  int centerX = static_cast<int>(global::screen_size.x * 0.5f);
  int centerY = static_cast<int>(global::screen_size.y * 0.5f);
  CEntity* best_enemy = nullptr;
  float min_center_dist_sq = FLT_MAX;
  float min_3d_dist = FLT_MAX;
  Vector2 best_screen_pos;
  bool best_on_screen = false;
  const Vector3& local_pos = gamevars::LocalEntity.Pawn.CameraPos;

  for (int index = 0; index < ValidEntity.size(); index++) {
    CEntity Entity = ValidEntity[index].first;
    if (!Entity.IsEnemy()) continue;
    if (Entity.Pawn.IsDormanted) continue;
    Vector3 vecPos = Entity.Pawn.Pos;
    Vector3 head_pos = {vecPos.x, vecPos.y, vecPos.z + Entity.Pawn.Height};
    Vector2 head_screen_pos;
    bool on_screen = gGame.View.WorldToScreen(head_pos, head_screen_pos);
    float dist = vecPos.DistanceTo(local_pos);
    float center_dist_sq = FLT_MAX;

    if (on_screen) {
      float dx = head_screen_pos.x - centerX;
      float dy = head_screen_pos.y - centerY;
      center_dist_sq = dx * dx + dy * dy;
    }

    if (center_dist_sq < min_center_dist_sq) {
      min_center_dist_sq = center_dist_sq;
      min_3d_dist = dist;
      best_enemy = &ValidEntity[index].first;
      best_on_screen = on_screen;
      if (on_screen) {
        best_screen_pos = head_screen_pos;
      }
    } else if (center_dist_sq == min_center_dist_sq && dist < min_3d_dist) {
      min_3d_dist = dist;
      best_enemy = &ValidEntity[index].first;
      best_on_screen = on_screen;
      if (on_screen) {
        best_screen_pos = head_screen_pos;
      }
    }
  }
  if (best_enemy) {
    if (best_on_screen) {
      float dx = best_screen_pos.x - centerX;
      float dy = best_screen_pos.y - centerY;
      float centerDist = sqrtf(dx * dx + dy * dy);
      float playerDist = min_3d_dist;
      newParams.frequency =
          500 + (3500 * (1 - std::clamp(playerDist / 1000.0f, 0.0f, 1.0f)));
      newParams.interval = 30 + (950 * (centerDist / centerX));
      newParams.active = true;
    }
  }
  {
    std::lock_guard<std::mutex> lock(Sonar::soundMutex);
    Sonar::currentParams = newParams;
  }
  return;
}

void PitchIndicator(CEntity& Local) noexcept {
  if (!config::PitchIndicator) return;
  if (!gamevars::IsInGame) return;
  int centerX = static_cast<int>(global::screen_size.x * 0.5f);
  int centerY = static_cast<int>(global::screen_size.y * 0.5f);
  Vector3 ViewAngle;
  if (!gGame.GetViewAngles(ViewAngle)) return;
  float pitch = ViewAngle.x;
  Vector3 camPos = Local.Pawn.CameraPos;
  Vector2 screenPos;
  Vector3 SHITPos = camPos - Vector3{1000.f, 0, 0};
  if (!gGame.View.WorldToScreen(SHITPos, screenPos)) {
    SHITPos = camPos - Vector3{0, 1000.f, 0};
    if (!gGame.View.WorldToScreen(SHITPos, screenPos)) {
      SHITPos = camPos + Vector3{1000.f, 0, 0};
      if (!gGame.View.WorldToScreen(SHITPos, screenPos)) {
        SHITPos = camPos + Vector3{0, 1000.f, 0};
        if (!gGame.View.WorldToScreen(SHITPos, screenPos)) {
          // impossible to get here, but just in case

          float pitchRadians = pitch * (3.14159265f / 180.0f);

          float actualFOV = static_cast<float>(Local.Pawn.Fov);

          float verticalOffsetRatio =
              (pitchRadians / (actualFOV * (3.14159265f / 180.0f)));

          float verticalOffset = verticalOffsetRatio * global::screen_size.y;

          screenPos.y = static_cast<float>(centerY - static_cast<int>(verticalOffset));
        }
      }
    }
  }

  int dynamicY = static_cast<int>(std::round(screenPos.y));

  RGBA lineColor = {0, 255, 0, 255};
  int lineLength = 15;
  int thickness = 1;
  DrawNewText(centerX - 3.f, centerY - 3.f, &lineColor, "^");
  DrawLine(static_cast<float>(centerX - lineLength), static_cast<float>(dynamicY), static_cast<float>(centerX + lineLength - 20), static_cast<float>(dynamicY),
           &lineColor, static_cast<float>(thickness));
  DrawLine(static_cast<float>(centerX - lineLength + 20), static_cast<float>(dynamicY), static_cast<float>(centerX + lineLength), static_cast<float>(dynamicY),
           &lineColor, static_cast<float>(thickness));
  DrawNewText(static_cast<float>(centerX + lineLength + 5), static_cast<float>(dynamicY), &lineColor,
              std::to_string(pitch).c_str());
}
inline void SendKey(WORD vk, bool bKeyDown) {
  INPUT input = {0};
  input.type = INPUT_KEYBOARD;
  input.ki.wVk = vk;
  input.ki.dwFlags = bKeyDown ? 0 : KEYEVENTF_KEYUP;

  SendInput(1, &input, sizeof(INPUT));
}
void FastStop(CEntity& Local) noexcept {
  if (!config::FastStop) return;
  const float Trigger_Value = config::FastStopMinVelocity;
  if (!(GetAsyncKeyState('W') || GetAsyncKeyState('A') ||
        GetAsyncKeyState('S') || GetAsyncKeyState('D') ||
        GetAsyncKeyState(VK_SPACE) || GetAsyncKeyState(VK_LSHIFT)) &&
      Local.Pawn.Speed > Trigger_Value && Local.Pawn.fFlags != 65664) {
    const auto LocalVel = Local.Pawn.Velocity;
    const auto LocalYaw = Local.Pawn.ViewAngle.y;
    const auto X = (LocalVel.x * cos(LocalYaw / 180 * 3.1415926) +
                    LocalVel.y * sin(LocalYaw / 180 * 3.1415926));
    const auto Y = (LocalVel.y * cos(LocalYaw / 180 * 3.1415926) -
                    LocalVel.x * sin(LocalYaw / 180 * 3.1415926));
    if (X > Trigger_Value) {
      SendKey('S', true);
      std::this_thread::sleep_for(std::chrono::milliseconds(1));
      SendKey('S', false);
    } else if (X < -Trigger_Value) {
      SendKey('W', true);
      std::this_thread::sleep_for(std::chrono::milliseconds(1));
      SendKey('W', false);
    }
    if (Y > Trigger_Value) {
      SendKey('D', true);
      std::this_thread::sleep_for(std::chrono::milliseconds(1));
      SendKey('D', false);
    } else if (Y < -Trigger_Value) {
      SendKey('A', true);
      std::this_thread::sleep_for(std::chrono::milliseconds(1));
      SendKey('A', false);
    }
  }
}
}  // namespace Misc



================================================
FILE: Functions/Miscs/Miscs.h
================================================
﻿#pragma once
#include "pch.h"
#include "../../CS2x64.h"

namespace Sonar {
void SoundThread() noexcept;
}  // namespace Sonar

namespace Misc {
void FoundEnemy(std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept;
void SonarRun(std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept;
void PitchIndicator(CEntity& Local) noexcept;
void FastStop(CEntity& Local) noexcept;
}  // namespace Misc


================================================
FILE: Functions/Miscs/SpecList.cc
================================================
﻿#include "pch.h"
#include "SpecList.h"

#include "../../UkiaStuff.h"
#include "../config.h"

namespace SpecList {

  inline uintptr_t get_pcs_player_pawn(uintptr_t entity_list, uintptr_t pawn) {
  uintptr_t l_list_entry2;
   Ukia::ProcessMgr.ReadMemory<uintptr_t>(entity_list +
                                         0x8 * ((pawn & 0x7FFF) >> 9) + 16,l_list_entry2);
    if (!l_list_entry2) return 0;
   uintptr_t RETURN;
    Ukia::ProcessMgr.ReadMemory<uintptr_t>(l_list_entry2 + 120 * (pawn & 0x1FF),
                                           RETURN);
    return RETURN;
  }

void RenderWindow(std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) {
  if (!config::SpecList) return;
  ImGui::SetNextWindowSize(ImVec2(200, -1));
  ImVec4 default_bg_color = ImGui::GetStyleColorVec4(ImGuiCol_WindowBg);
  default_bg_color.w = 0.5f;
  ImGui::PushStyleColor(ImGuiCol_WindowBg, default_bg_color);
  ImGui::Begin(XorStr("SPECTATORS"), nullptr,
               ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize |
                    ImGuiWindowFlags_NoCollapse |
                   ImGuiWindowFlags_NoScrollbar |
                   ImGuiWindowFlags_::ImGuiWindowFlags_NoBringToFrontOnFocus |
                   ImGuiWindowFlags_::ImGuiWindowFlags_NoNavFocus |
                   ImGuiWindowFlags_::ImGuiWindowFlags_NoNav);
  { 
    ImGui::SetCursorPosY(22);
    for (int index = 0; index < ValidEntity.size(); index++) {
      CEntity Entity = ValidEntity[index].first;
      // DWORD64 EntityAddress = ValidEntity[index].second;

      if (Entity.Controller.IsSpec) {
        const char* Name = (Entity.Controller.PlayerName).c_str();
        ImGui::Text("%s", Name);
      }
      }
  }
  ImGui::End();
  ImGui::PopStyleColor();
}
}  // namespace SpecList


================================================
FILE: Functions/Miscs/SpecList.h
================================================
﻿#pragma once
#include "pch.h"

#include "../../CS2x64.h"

namespace SpecList {
void RenderWindow(std::vector<std::pair<CEntity, DWORD64>>& ValidEntity);
}


================================================
FILE: Functions/Visuals/ESP.cc
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: ESP.cc
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file contains ESP functions.
//
// -----------------------------------------------------------------------------
#include "pch.h"
#include "ESP.h"

namespace ESP {

static std::unordered_map<uintptr_t, float> g_dormantStartTimes;

void ESPRun(std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept {
  if (!gamevars::IsInGame) return;
  auto now = std::chrono::steady_clock::now();
  float currentTime =
      std::chrono::duration<float>(now.time_since_epoch()).count();
  if (config::ESP) {
    for (int index = 0; index < ValidEntity.size(); index++) {
      CEntity Entity = ValidEntity[index].first;
      DWORD64 EntityAddress = ValidEntity[index].second;
      if (!Entity.IsEnemy()) continue;

      if (Entity.Pawn.IsDormanted) {
        if (g_dormantStartTimes.find(EntityAddress) ==
            g_dormantStartTimes.end()) {
          g_dormantStartTimes[EntityAddress] = currentTime;
        }

        if (currentTime - g_dormantStartTimes[EntityAddress] >
            config::DormantTime) {
          continue;
        }
      } else {
        g_dormantStartTimes.erase(EntityAddress);
      }

      Vector3 vecPos = Entity.Pawn.Pos;

      float dist = vecPos.DistanceTo(gamevars::LocalEntity.Pawn.Pos);
      Vector2 screen_pos = Entity.Pawn.ScreenPos;

      if (Entity.ESPAlive() && Entity.IsInScreen()) {
        Vector3 head_pos = {vecPos.x, vecPos.y, vecPos.z + Entity.Pawn.Height};
        Vector2 head_screen_pos;
        gGame.View.WorldToScreen(head_pos, head_screen_pos);

        if (config::ESPInfo) {
          std::ostringstream playerInfo;
          playerInfo << XorStr("^\n") << XorStr("Health: ")
                     << Entity.Pawn.Health << XorStr("\n") << XorStr("Dist:")
                     << dist << XorStr("\n");
          if (Entity.Pawn.IsDormanted || Entity.Pawn.isImmunity)
            DrawStrokeText(screen_pos.x, screen_pos.y, &Grey,
                           playerInfo.str().c_str());
          else
            DrawStrokeText(screen_pos.x, screen_pos.y, &White,
                           playerInfo.str().c_str());
        }

        if (config::ESPBox) {
          if (Entity.Pawn.IsDormanted || Entity.Pawn.isImmunity)
            DrawEspBox2D(screen_pos, head_screen_pos, &Grey, 1);
          else if (Entity.IsVisible())
            DrawEspBox2D(screen_pos, head_screen_pos, &Red, 1);
          else
            DrawEspBox2D(screen_pos, head_screen_pos, &Green, 1);
        }
        if (config::ESPName)
          DrawNameTag(screen_pos, head_screen_pos,
                      (char*)Entity.Controller.PlayerName.c_str());
        if (config::ESPHealth)
          DrawHealthBar(screen_pos, head_screen_pos, Entity.Pawn.Health);
      }
    }
  }
  if (config::C4ESP && gamevars::PlantedBomb.isPlanted &&
      gamevars::PlantedBomb.boomRemaining > 0) 
      {
    Vector2 screen_pos;
    gGame.View.WorldToScreen(gamevars::PlantedBomb.Pos, screen_pos);
    Vector2 head_screen_pos;
    gGame.View.WorldToScreen(
        Vector3(gamevars::PlantedBomb.Pos.x, gamevars::PlantedBomb.Pos.y,
                              gamevars::PlantedBomb.Pos.z+10.f),
                             head_screen_pos);
    DrawEspBox2D(screen_pos, head_screen_pos, &Green, 1);
    DrawNameTag(screen_pos, head_screen_pos, XorStr("C4"));
  }
}
}  // namespace ESP



================================================
FILE: Functions/Visuals/ESP.h
================================================
﻿#pragma once
#include "pch.h"
#include "../../CS2x64.h"

namespace ESP {

void ESPRun(std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept;
}  // namespace ESP


================================================
FILE: Functions/Visuals/Radar.cc
================================================
﻿// Copyright (c) 2025 渟雲. All rights reserved.
//
// Licensed under the TOSSRCU 2025.9 License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  https://raw.githubusercontent.com/M3351AN/M3351AN/9e7630a8511b8306c62952ca1a4f1ce0cc5b784a/LICENSE
//
// -----------------------------------------------------------------------------
// File: Radar.cc
// Author: 渟雲(quq[at]outlook.it)
// Date: 2025-09-29
//
// Description:
//   This file contains radar functions.
//
// -----------------------------------------------------------------------------
#include "pch.h"
#include "Radar.h"
#include "../../maths.h"
namespace Radar {

class Base_Radar {
 public:
  // 设置雷达数据
  void SetSize(const float& Size) noexcept;
  void SetPos(const ImVec2& Pos) noexcept;
  void SetRange(const float& Range) noexcept;
  void SetCrossColor(const ImColor& Color) noexcept;
  void SetProportion(const float& Proportion) noexcept;
  void SetDrawList(ImDrawList* DrawList) noexcept;
  // 获取雷达数据
  float GetSize() noexcept;
  ImVec2 GetPos() noexcept;
  // 添加绘制点
  void AddPoint(const Vector3& LocalPos, const float& LocalYaw,
                const Vector3& Pos, ImColor Color, int Type = 0,
                float Yaw = 0.0f) noexcept;
  // 渲染
  void Render() noexcept;
  void RadarSetting() noexcept;

 public:
  ImDrawList* DrawList = nullptr;
  // 十字显示
  bool ShowCrossLine = true;
  // 十字颜色
  ImColor CrossColor = ImColor(255, 255, 255, 255);
  // 比例
  float Proportion = 2680;
  // 圆点半径
  float CircleSize = 4;
  // 箭头尺寸
  float ArrowSize = 11;
  // 圆弧箭头尺寸
  float ArcArrowSize = 7;
  // 雷达范围
  float RenderRange = 250;
  // 本地Yaw数据
  float LocalYaw = 0.0f;
  // 状态
  bool Opened = true;
  // 雷达绘制类型 0:圆形 1:箭头 2:圆弧箭头
  int PointType = 0;

 private:
  ImVec2 Pos{0, 0};
  float Width = 200;
  std::vector<std::tuple<ImVec2, ImColor, int, float>> Points;
};

ImVec2 RevolveCoordinatesSystem(float RevolveAngle, ImVec2 OriginPos,
                                ImVec2 DestPos) noexcept {
  ImVec2 ResultPos;
  if (RevolveAngle == 0) return DestPos;
  ResultPos.x = OriginPos.x +
                (DestPos.x - OriginPos.x) * cos(M_DEG2RAD(RevolveAngle)) +
                (DestPos.y - OriginPos.y) * sin(M_DEG2RAD(RevolveAngle));
  ResultPos.y = OriginPos.y -
                (DestPos.x - OriginPos.x) * sin(M_DEG2RAD(RevolveAngle)) +
                (DestPos.y - OriginPos.y) * cos(M_DEG2RAD(RevolveAngle));
  return ResultPos;
}
void Base_Radar::SetRange(const float& Range) noexcept {
  this->RenderRange = Range;
}

void Base_Radar::SetCrossColor(const ImColor& Color) noexcept {
  this->CrossColor = Color;
}

void Base_Radar::SetPos(const ImVec2& Pos) noexcept { this->Pos = Pos; }

void Base_Radar::SetSize(const float& Size) noexcept { this->Width = Size; }

float Base_Radar::GetSize() noexcept { return this->Width; }

ImVec2 Base_Radar::GetPos() noexcept { return this->Pos; }

void Base_Radar::SetProportion(const float& Proportion) noexcept {
  this->Proportion = Proportion;
}

void Base_Radar::SetDrawList(ImDrawList* DrawList) noexcept {
  this->DrawList = DrawList;
}

void Base_Radar::AddPoint(const Vector3& LocalPos, const float& LocalYaw,
                          const Vector3& Pos, ImColor Color, int Type,
                          float Yaw) noexcept {
  ImVec2 PointPos;
  float Distance;
  float Angle;

  this->LocalYaw = LocalYaw;

  Distance = static_cast<float>(sqrt(pow(LocalPos.x - Pos.x, 2) + pow(LocalPos.y - Pos.y, 2)));

  Angle = M_RAD2DEG(atan2(Pos.y - LocalPos.y, Pos.x - LocalPos.x));
  Angle = M_DEG2RAD(this->LocalYaw - Angle);

  Distance = Distance / this->Proportion * this->RenderRange * 2;

  PointPos.x = this->Pos.x + Distance * sin(Angle);
  PointPos.y = this->Pos.y - Distance * cos(Angle);

  // Circle range
  // Distance = sqrt(pow(this->Pos.x - PointPos.x, 2) + pow(this->Pos.y -
  // PointPos.y, 2)); if (Distance > this->RenderRange) 	return;

  // Rectangle range
  if (PointPos.x < this->Pos.x - RenderRange ||
      PointPos.x > this->Pos.x + RenderRange ||
      PointPos.y > this->Pos.y + RenderRange ||
      PointPos.y < this->Pos.y - RenderRange)
    return;

  std::tuple<ImVec2, ImColor, int, float> Data(PointPos, Color, Type, Yaw);
  this->Points.push_back(Data);
}

void DrawTriangle(ImVec2 Center, ImColor Color, float Width, float Height,
                  float Yaw) noexcept {
  ImVec2 a, b, c;
  a = ImVec2{Center.x - Width / 2, Center.y};
  b = ImVec2{Center.x + Width / 2, Center.y};
  c = ImVec2{Center.x, Center.y - Height};
  a = RevolveCoordinatesSystem(-Yaw, Center, a);
  b = RevolveCoordinatesSystem(-Yaw, Center, b);
  c = RevolveCoordinatesSystem(-Yaw, Center, c);
  ImGui::GetForegroundDrawList()->AddTriangleFilled(
      ImVec2(a.x, a.y), ImVec2(b.x, b.y), ImVec2(c.x, c.y), Color);
}

void Base_Radar::Render() noexcept {
  if (Width <= 0) return;

  // Cross
  std::pair<ImVec2, ImVec2> Line1;
  std::pair<ImVec2, ImVec2> Line2;

  Line1.first = ImVec2(this->Pos.x - this->Width / 2, this->Pos.y);
  Line1.second = ImVec2(this->Pos.x + this->Width / 2, this->Pos.y);
  Line2.first = ImVec2(this->Pos.x, this->Pos.y - this->Width / 2);
  Line2.second = ImVec2(this->Pos.x, this->Pos.y + this->Width / 2);

  if (this->Opened) {
    if (this->ShowCrossLine) {
      this->DrawList->AddLine(Line1.first, Line1.second, this->CrossColor, 1);
      this->DrawList->AddLine(Line2.first, Line2.second, this->CrossColor, 1);
    }
    for (auto PointSingle : this->Points) {
      ImVec2 PointPos = std::get<0>(PointSingle);
      ImColor PointColor = std::get<1>(PointSingle);
      int PointType = std::get<2>(PointSingle);
      float PointYaw = std::get<3>(PointSingle);
      if (PointType == 0) {
        // 圆形样式
        this->DrawList->AddCircle(PointPos, this->CircleSize, PointColor);
        this->DrawList->AddCircleFilled(PointPos, this->CircleSize,
                                        ImColor(0, 0, 0));
      } else if (PointType == 1) {
        // 箭头样式
        ImVec2 a, b, c;
        ImVec2 Re_a, Re_b, Re_c;
        ImVec2 Re_Point;
        float Angle = (this->LocalYaw - PointYaw) + 180;
        Re_Point = RevolveCoordinatesSystem(Angle, this->Pos, PointPos);

        Re_a = ImVec2(Re_Point.x, Re_Point.y + this->ArrowSize);
        Re_b = ImVec2(Re_Point.x - this->ArrowSize / 1.5f,
                      Re_Point.y - this->ArrowSize / 2.f);
        Re_c = ImVec2(Re_Point.x + this->ArrowSize / 1.5f,
                      Re_Point.y - this->ArrowSize / 2.f);

        a = RevolveCoordinatesSystem(-Angle, this->Pos, Re_a);
        b = RevolveCoordinatesSystem(-Angle, this->Pos, Re_b);
        c = RevolveCoordinatesSystem(-Angle, this->Pos, Re_c);

        this->DrawList->AddQuadFilled(ImVec2(a.x, a.y), ImVec2(b.x, b.y),
                                      ImVec2(PointPos.x, PointPos.y),
                                      ImVec2(c.x, c.y), PointColor);
        this->DrawList->AddQuad(ImVec2(a.x, a.y), ImVec2(b.x, b.y),
                                ImVec2(PointPos.x, PointPos.y),
                                ImVec2(c.x, c.y), ImColor(0, 0, 0, 150), 0.1f);
      } else {
        // 圆弧箭头
        ImVec2 TrianglePoint, TrianglePoint_1, TrianglePoint_2;
        float Angle = (this->LocalYaw - PointYaw) - 90;

        this->DrawList->AddCircleFilled(PointPos, 0.85f * this->ArcArrowSize,
                                        PointColor, 30);
        this->DrawList->AddCircle(PointPos, 0.95f * this->ArcArrowSize,
                                  ImColor(0, 0, 0, 150), 0, 0.1f);

        TrianglePoint.x =
            PointPos.x + (this->ArcArrowSize + this->ArcArrowSize / 3) *
                             cos(M_DEG2RAD(-Angle));
        TrianglePoint.y =
            PointPos.y - (this->ArcArrowSize + this->ArcArrowSize / 3) *
                             sin(M_DEG2RAD(-Angle));

        TrianglePoint_1.x =
            PointPos.x + this->ArcArrowSize * cos(M_DEG2RAD(-(Angle - 30)));
        TrianglePoint_1.y =
            PointPos.y - this->ArcArrowSize * sin(M_DEG2RAD(-(Angle - 30)));

        TrianglePoint_2.x =
            PointPos.x + this->ArcArrowSize * cos(M_DEG2RAD(-(Angle + 30)));
        TrianglePoint_2.y =
            PointPos.y - this->ArcArrowSize * sin(M_DEG2RAD(-(Angle + 30)));

        this->DrawList->PathLineTo(TrianglePoint);
        this->DrawList->PathLineTo(TrianglePoint_1);
        this->DrawList->PathLineTo(TrianglePoint_2);
        this->DrawList->PathFillConvex(ImColor(220, 220, 220, 240));
      }
    }
  }

  if (this->Points.size() > 0) this->Points.clear();
}

void Base_Radar::RadarSetting() noexcept {
  // Radar window
  ImGui::SetNextWindowBgAlpha(0.f);
  ImGui::SetNextWindowSize({config::RadarRange * 2, config::RadarRange * 2},
                           ImGuiCond_Always);
  ImGui::Begin(XorStr("RADAR"), 0,
               ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoBackground |
                   ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoScrollbar |
                   ImGuiWindowFlags_::ImGuiWindowFlags_NoBringToFrontOnFocus |
                   ImGuiWindowFlags_::ImGuiWindowFlags_NoBackground |
                   ImGuiWindowFlags_::ImGuiWindowFlags_NoNavFocus |
                   ImGuiWindowFlags_::ImGuiWindowFlags_NoNav);

  // this->SetPos({ Gui.Window.Size.x / 2,Gui.Window.Size.y / 2 });
  this->SetDrawList(ImGui::GetWindowDrawList());
  this->SetPos({ImGui::GetWindowPos().x + config::RadarRange,
                ImGui::GetWindowPos().y + config::RadarRange});
  this->SetProportion(config::RadarProportion);
  this->SetRange(config::RadarRange);
  this->SetSize(config::RadarRange * 2);
  this->SetCrossColor(ImColor(220, 220, 220, 255));

  this->ArcArrowSize *= config::RadarPointSize;
  this->ArrowSize *= config::RadarPointSize;
  this->CircleSize *= config::RadarPointSize;

  this->ShowCrossLine = config::RadarCrossLine;
  this->Opened = true;
}

static std::unordered_map<uintptr_t, float> g_dormantStartTimes;

void RadarRun(std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept {
  if (!config::Radar) return;
  Base_Radar Radar;
  Radar.RadarSetting();

  auto now = std::chrono::steady_clock::now();
  float currentTime =
      std::chrono::duration<float>(now.time_since_epoch()).count();
    for (int index = 0; index < ValidEntity.size(); index++) {
      CEntity Entity = ValidEntity[index].first;
      DWORD64 EntityAddress = ValidEntity[index].second;
      if (!Entity.IsEnemy())
        continue;
      
    if (Entity.Pawn.IsDormanted) {
        if (g_dormantStartTimes.find(EntityAddress) ==
            g_dormantStartTimes.end()) {
        g_dormantStartTimes[EntityAddress] = currentTime;
      }

      if (currentTime - g_dormantStartTimes[EntityAddress] >
          config::DormantTime) {
        continue;
      }
    } else {
      g_dormantStartTimes.erase(EntityAddress);
    }

    Vector3 vecPos = Entity.Pawn.Pos;

    float eyeAng = Entity.Pawn.ViewAngle.y;

    Radar.AddPoint(gamevars::LocalEntity.Pawn.CameraPos,
                   gamevars::LocalEntity.Pawn.ViewAngle.y,
                   vecPos,
                   ImColor(237, 85, 106, 200), 2, eyeAng);
  }
  Radar.Render();
  ImGui::End();
}

}  // namespace Radar



================================================
FILE: Functions/Visuals/Radar.h
================================================
﻿#pragma once
#include "pch.h"
#include "../../CS2x64.h"

namespace Radar {

void RadarRun(std::vector<std::pair<CEntity, DWORD64>>& ValidEntity) noexcept;

}  // namespace Radar


================================================
FILE: ImGui/imconfig.h
================================================
//-----------------------------------------------------------------------------
// DEAR IMGUI COMPILE-TIME OPTIONS
// Runtime options (clipboard callbacks, enabling various features, etc.) can generally be set via the ImGuiIO structure.
// You can use ImGui::SetAllocatorFunctions() before calling ImGui::CreateContext() to rewire memory allocation functions.
//-----------------------------------------------------------------------------
// A) You may edit imconfig.h (and not overwrite it when updating Dear ImGui, or maintain a patch/rebased branch with your modifications to it)
// B) or '#define IMGUI_USER_CONFIG "my_imgui_config.h"' in your project and then add directives in your own file without touching this template.
//-----------------------------------------------------------------------------
// You need to make sure that configuration settings are defined consistently _everywhere_ Dear ImGui is used, which include the imgui*.cpp
// files but also _any_ of your code that uses Dear ImGui. This is because some compile-time options have an affect on data structures.
// Defining those options in imconfig.h will ensure every compilation unit gets to see the same data structure layouts.
// Call IMGUI_CHECKVERSION() from your .cpp file to verify that the data structures your files are using are matching the ones imgui.cpp is using.
//-----------------------------------------------------------------------------

#pragma once

//---- Define assertion handler. Defaults to calling assert().
// If your macro uses multiple statements, make sure is enclosed in a 'do { .. } while (0)' block so it can be used as a single statement.
//#define IM_ASSERT(_EXPR)  MyAssert(_EXPR)
//#define IM_ASSERT(_EXPR)  ((void)(_EXPR))     // Disable asserts

//---- Define attributes of all API symbols declarations, e.g. for DLL under Windows
// Using Dear ImGui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.
// - Windows DLL users: heaps and globals are not shared across DLL boundaries! You will need to call SetCurrentContext() + SetAllocatorFunctions()
//   for each static/DLL boundary you are calling from. Read "Context and Memory Allocators" section of imgui.cpp for more details.
//#define IMGUI_API __declspec(dllexport)                   // MSVC Windows: DLL export
//#define IMGUI_API __declspec(dllimport)                   // MSVC Windows: DLL import
//#define IMGUI_API __attribute__((visibility("default")))  // GCC/Clang: override visibility when set is hidden

//---- Don't define obsolete functions/enums/behaviors. Consider enabling from time to time after updating to clean your code of obsolete function/names.
//#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS

//---- Disable all of Dear ImGui or don't implement standard windows/tools.
// It is very strongly recommended to NOT disable the demo windows and debug tool during development. They are extremely useful in day to day work. Please read comments in imgui_demo.cpp.
//#define IMGUI_DISABLE                                     // Disable everything: all headers and source files will be empty.
//#define IMGUI_DISABLE_DEMO_WINDOWS                        // Disable demo windows: ShowDemoWindow()/ShowStyleEditor() will be empty.
//#define IMGUI_DISABLE_DEBUG_TOOLS                         // Disable metrics/debugger and other debug tools: ShowMetricsWindow(), ShowDebugLogWindow() and ShowIDStackToolWindow() will be empty.

//---- Don't implement some functions to reduce linkage requirements.
//#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS   // [Win32] Don't implement default clipboard handler. Won't use and link with OpenClipboard/GetClipboardData/CloseClipboard etc. (user32.lib/.a, kernel32.lib/.a)
//#define IMGUI_ENABLE_WIN32_DEFAULT_IME_FUNCTIONS          // [Win32] [Default with Visual Studio] Implement default IME handler (require imm32.lib/.a, auto-link for Visual Studio, -limm32 on command-line for MinGW)
//#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS         // [Win32] [Default with non-Visual Studio compilers] Don't implement default IME handler (won't require imm32.lib/.a)
//#define IMGUI_DISABLE_WIN32_FUNCTIONS                     // [Win32] Won't use and link with any Win32 function (clipboard, IME).
//#define IMGUI_ENABLE_OSX_DEFAULT_CLIPBOARD_FUNCTIONS      // [OSX] Implement default OSX clipboard handler (need to link with '-framework ApplicationServices', this is why this is not the default).
//#define IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS             // Don't implement default platform_io.Platform_OpenInShellFn() handler (Win32: ShellExecute(), require shell32.lib/.a, Mac/Linux: use system("")).
//#define IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS            // Don't implement ImFormatString/ImFormatStringV so you can implement them yourself (e.g. if you don't want to link with vsnprintf)
//#define IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS              // Don't implement ImFabs/ImSqrt/ImPow/ImFmod/ImCos/ImSin/ImAcos/ImAtan2 so you can implement them yourself.
//#define IMGUI_DISABLE_FILE_FUNCTIONS                      // Don't implement ImFileOpen/ImFileClose/ImFileRead/ImFileWrite and ImFileHandle at all (replace them with dummies)
//#define IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS              // Don't implement ImFileOpen/ImFileClose/ImFileRead/ImFileWrite and ImFileHandle so you can implement them yourself if you don't want to link with fopen/fclose/fread/fwrite. This will also disable the LogToTTY() function.
//#define IMGUI_DISABLE_DEFAULT_ALLOCATORS                  // Don't implement default allocators calling malloc()/free() to avoid linking with them. You will need to call ImGui::SetAllocatorFunctions().
//#define IMGUI_DISABLE_DEFAULT_FONT                        // Disable default embedded font (ProggyClean.ttf), remove ~9.5 KB from output binary. AddFontDefault() will assert.
//#define IMGUI_DISABLE_SSE                                 // Disable use of SSE intrinsics even if available

//---- Enable Test Engine / Automation features.
//#define IMGUI_ENABLE_TEST_ENGINE                          // Enable imgui_test_engine hooks. Generally set automatically by include "imgui_te_config.h", see Test Engine for details.

//---- Include imgui_user.h at the end of imgui.h as a convenience
// May be convenient for some users to only explicitly include vanilla imgui.h and have extra stuff included.
//#define IMGUI_INCLUDE_IMGUI_USER_H
//#define IMGUI_USER_H_FILENAME         "my_folder/my_imgui_user.h"

//---- Pack vertex colors as BGRA8 instead of RGBA8 (to avoid converting from one to another). Need dedicated backend support.
//#define IMGUI_USE_BGRA_PACKED_COLOR

//---- Use legacy CRC32-adler tables (used before 1.91.6), in order to preserve old .ini data that you cannot afford to invalidate.
//#define IMGUI_USE_LEGACY_CRC32_ADLER

//---- Use 32-bit for ImWchar (default is 16-bit) to support Unicode planes 1-16. (e.g. point beyond 0xFFFF like emoticons, dingbats, symbols, shapes, ancient languages, etc...)
//#define IMGUI_USE_WCHAR32

//---- Avoid multiple STB libraries implementations, or redefine path/filenames to prioritize another version
// By default the embedded implementations are declared static and not available outside of Dear ImGui sources files.
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_STB_SPRINTF_FILENAME    "my_folder/stb_sprintf.h"    // only used if IMGUI_USE_STB_SPRINTF is defined.
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_SPRINTF_IMPLEMENTATION                   // only disabled if IMGUI_USE_STB_SPRINTF is defined.

//---- Use stb_sprintf.h for a faster implementation of vsnprintf instead of the one from libc (unless IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS is defined)
// Compatibility checks of arguments and formats done by clang and GCC will be disabled in order to support the extra formats provided by stb_sprintf.h.
//#define IMGUI_USE_STB_SPRINTF

//---- Use FreeType to build and rasterize the font atlas (instead of stb_truetype which is embedded by default in Dear ImGui)
// Requires FreeType headers to be available in the include path. Requires program to be compiled with 'misc/freetype/imgui_freetype.cpp' (in this repository) + the FreeType library (not provided).
// On Windows you may use vcpkg with 'vcpkg install freetype --triplet=x64-windows' + 'vcpkg integrate install'.
//#define IMGUI_ENABLE_FREETYPE

//---- Use FreeType + plutosvg or lunasvg to render OpenType SVG fonts (SVGinOT)
// Only works in combination with IMGUI_ENABLE_FREETYPE.
// - plutosvg is currently easier to install, as e.g. it is part of vcpkg. It will support more fonts and may load them faster. See misc/freetype/README for instructions.
// - Both require headers to be available in the include path + program to be linked with the library code (not provided).
// - (note: lunasvg implementation is based on Freetype's rsvg-port.c which is licensed under CeCILL-C Free Software License Agreement)
//#define IMGUI_ENABLE_FREETYPE_PLUTOSVG
//#define IMGUI_ENABLE_FREETYPE_LUNASVG

//---- Use stb_truetype to build and rasterize the font atlas (default)
// The only purpose of this define is if you want force compilation of the stb_truetype backend ALONG with the FreeType backend.
//#define IMGUI_ENABLE_STB_TRUETYPE

//---- Define constructor and implicit cast operators to convert back<>forth between your math types and ImVec2/ImVec4.
// This will be inlined as part of ImVec2 and ImVec4 class declarations.
/*
#define IM_VEC2_CLASS_EXTRA                                                     \
        constexpr ImVec2(const MyVec2& f) : x(f.x), y(f.y) {}                   \
        operator MyVec2() const { return MyVec2(x,y); }

#define IM_VEC4_CLASS_EXTRA                                                     \
        constexpr ImVec4(const MyVec4& f) : x(f.x), y(f.y), z(f.z), w(f.w) {}   \
        operator MyVec4() const { return MyVec4(x,y,z,w); }
*/
//---- ...Or use Dear ImGui's own very basic math operators.
#define IMGUI_DEFINE_MATH_OPERATORS

//---- Use 32-bit vertex indices (default is 16-bit) is one way to allow large meshes with more than 64K vertices.
// Your renderer backend will need to support it (most example renderer backends support both 16/32-bit indices).
// Another way to allow large meshes while keeping 16-bit indices is to handle ImDrawCmd::VtxOffset in your renderer.
// Read about ImGuiBackendFlags_RendererHasVtxOffset for details.
//#define ImDrawIdx unsigned int

//---- Override ImDrawCallback signature (will need to modify renderer backends accordingly)
//struct ImDrawList;
//struct ImDrawCmd;
//typedef void (*MyImDrawCallback)(const ImDrawList* draw_list, const ImDrawCmd* cmd, void* my_renderer_user_data);
//#define ImDrawCallback MyImDrawCallback

//---- Debug Tools: Macro to break in Debugger (we provide a default implementation of this in the codebase)
// (use 'Metrics->Tools->Item Picker' to pick widgets with the mouse and break into them for easy debugging.)
//#define IM_DEBUG_BREAK  IM_ASSERT(0)
//#define IM_DEBUG_BREAK  __debugbreak()

//---- Debug Tools: Enable slower asserts
//#define IMGUI_DEBUG_PARANOID

//---- Tip: You can add extra functions within the ImGui:: namespace from anywhere (e.g. your own sources/header files)
/*
namespace ImGui
{
    void MyFunction(const char* name, MyMatrix44* mtx);
}
*/



================================================
FILE: ImGui/imgui_impl_dx9.cpp
================================================
// dear imgui: Renderer Backend for DirectX9
// This needs to be used along with a Platform Backend (e.g. Win32)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'LPDIRECT3DTEXTURE9' as ImTextureID. Read the FAQ about ImTextureID!
//  [X] Renderer: Large meshes support (64k+ vertices) even with 16-bit indices (ImGuiBackendFlags_RendererHasVtxOffset).
//  [X] Renderer: IMGUI_USE_BGRA_PACKED_COLOR support, as this is the optimal color encoding for DirectX9.

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// Learn about Dear ImGui:
// - FAQ                  https://dearimgui.com/faq
// - Getting Started      https://dearimgui.com/getting-started
// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).
// - Introduction, links and more at the top of imgui.cpp

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2024-10-07: DirectX9: Changed default texture sampler to Clamp instead of Repeat/Wrap.
//  2024-02-12: DirectX9: Using RGBA format when supported by the driver to avoid CPU side conversion. (#6575)
//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.
//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).
//  2021-06-25: DirectX9: Explicitly disable texture state stages after >= 1.
//  2021-05-19: DirectX9: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)
//  2021-04-23: DirectX9: Explicitly setting up more graphics states to increase compatibility with unusual non-default states.
//  2021-03-18: DirectX9: Calling IDirect3DStateBlock9::Capture() after CreateStateBlock() as a workaround for state restoring issues (see #3857).
//  2021-03-03: DirectX9: Added support for IMGUI_USE_BGRA_PACKED_COLOR in user's imconfig file.
//  2021-02-18: DirectX9: Change blending equation to preserve alpha in output buffer.
//  2019-05-29: DirectX9: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.
//  2019-04-30: DirectX9: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.
//  2019-03-29: Misc: Fixed erroneous assert in ImGui_ImplDX9_InvalidateDeviceObjects().
//  2019-01-16: Misc: Disabled fog before drawing UI's. Fixes issue #2288.
//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.
//  2018-06-08: Misc: Extracted imgui_impl_dx9.cpp/.h away from the old combined DX9+Win32 example.
//  2018-06-08: DirectX9: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.
//  2018-05-07: Render: Saving/restoring Transform because they don't seem to be included in the StateBlock. Setting shading mode to Gouraud.
//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX9_RenderDrawData() in the .h file so you can call it yourself.
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.

#include "imgui.h"
#ifndef IMGUI_DISABLE
#include "imgui_impl_dx9.h"

// DirectX
#include <d3d9.h>

// DirectX data
struct ImGui_ImplDX9_Data
{
    LPDIRECT3DDEVICE9           pd3dDevice;
    LPDIRECT3DVERTEXBUFFER9     pVB;
    LPDIRECT3DINDEXBUFFER9      pIB;
    LPDIRECT3DTEXTURE9          FontTexture;
    int                         VertexBufferSize;
    int                         IndexBufferSize;
    bool                        HasRgbaSupport;

    ImGui_ImplDX9_Data()        { memset((void*)this, 0, sizeof(*this)); VertexBufferSize = 5000; IndexBufferSize = 10000; }
};

struct CUSTOMVERTEX
{
    float    pos[3];
    D3DCOLOR col;
    float    uv[2];
};
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)

#ifdef IMGUI_USE_BGRA_PACKED_COLOR
#define IMGUI_COL_TO_DX9_ARGB(_COL)     (_COL)
#else
#define IMGUI_COL_TO_DX9_ARGB(_COL)     (((_COL) & 0xFF00FF00) | (((_COL) & 0xFF0000) >> 16) | (((_COL) & 0xFF) << 16))
#endif

// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts
// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.
static ImGui_ImplDX9_Data* ImGui_ImplDX9_GetBackendData()
{
    return ImGui::GetCurrentContext() ? (ImGui_ImplDX9_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;
}

// Functions
static void ImGui_ImplDX9_SetupRenderState(ImDrawData* draw_data)
{
    ImGui_ImplDX9_Data* bd = ImGui_ImplDX9_GetBackendData();

    // Setup viewport
    D3DVIEWPORT9 vp;
    vp.X = vp.Y = 0;
    vp.Width = (DWORD)draw_data->DisplaySize.x;
    vp.Height = (DWORD)draw_data->DisplaySize.y;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;

    LPDIRECT3DDEVICE9 device = bd->pd3dDevice;
    device->SetViewport(&vp);

    // Setup render state: fixed-pipeline, alpha-blending, no face culling, no depth testing, shade mode (for gradient), bilinear sampling.
    device->SetPixelShader(nullptr);
    device->SetVertexShader(nullptr);
    device->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
    device->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
    device->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
    device->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
    device->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    device->SetRenderState(D3DRS_ZENABLE, FALSE);
    device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    device->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
    device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    device->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, TRUE);
    device->SetRenderState(D3DRS_SRCBLENDALPHA, D3DBLEND_ONE);
    device->SetRenderState(D3DRS_DESTBLENDALPHA, D3DBLEND_INVSRCALPHA);
    device->SetRenderState(D3DRS_SCISSORTESTENABLE, TRUE);
    device->SetRenderState(D3DRS_FOGENABLE, FALSE);
    device->SetRenderState(D3DRS_RANGEFOGENABLE, FALSE);
    device->SetRenderState(D3DRS_SPECULARENABLE, FALSE);
    device->SetRenderState(D3DRS_STENCILENABLE, FALSE);
    device->SetRenderState(D3DRS_CLIPPING, TRUE);
    device->SetRenderState(D3DRS_LIGHTING, FALSE);
    device->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
    device->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    device->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    device->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
    device->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    device->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
    device->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
    device->SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
    device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
    device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
    device->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);
    device->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);

    // Setup orthographic projection matrix
    // Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right). DisplayPos is (0,0) for single viewport apps.
    // Being agnostic of whether <d3dx9.h> or <DirectXMath.h> can be used, we aren't relying on D3DXMatrixIdentity()/D3DXMatrixOrthoOffCenterLH() or DirectX::XMMatrixIdentity()/DirectX::XMMatrixOrthographicOffCenterLH()
    {
        float L = draw_data->DisplayPos.x + 0.5f;
        float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x + 0.5f;
        float T = draw_data->DisplayPos.y + 0.5f;
        float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y + 0.5f;
        D3DMATRIX mat_identity = { { { 1.0f, 0.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 0.0f, 1.0f } } };
        D3DMATRIX mat_projection =
        { { {
            2.0f/(R-L),   0.0f,         0.0f,  0.0f,
            0.0f,         2.0f/(T-B),   0.0f,  0.0f,
            0.0f,         0.0f,         0.5f,  0.0f,
            (L+R)/(L-R),  (T+B)/(B-T),  0.5f,  1.0f
        } } };
        device->SetTransform(D3DTS_WORLD, &mat_identity);
        device->SetTransform(D3DTS_VIEW, &mat_identity);
        device->SetTransform(D3DTS_PROJECTION, &mat_projection);
    }
}

// Render function.
void ImGui_ImplDX9_RenderDrawData(ImDrawData* draw_data)
{
    // Avoid rendering when minimized
    if (draw_data->DisplaySize.x <= 0.0f || draw_data->DisplaySize.y <= 0.0f)
        return;

    ImGui_ImplDX9_Data* bd = ImGui_ImplDX9_GetBackendData();
    LPDIRECT3DDEVICE9 device = bd->pd3dDevice;

    // Create and grow buffers if needed
    if (!bd->pVB || bd->VertexBufferSize < draw_data->TotalVtxCount)
    {
        if (bd->pVB) { bd->pVB->Release(); bd->pVB = nullptr; }
        bd->VertexBufferSize = draw_data->TotalVtxCount + 5000;
        if (device->CreateVertexBuffer(bd->VertexBufferSize * sizeof(CUSTOMVERTEX), D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX, D3DPOOL_DEFAULT, &bd->pVB, nullptr) < 0)
            return;
    }
    if (!bd->pIB || bd->IndexBufferSize < draw_data->TotalIdxCount)
    {
        if (bd->pIB) { bd->pIB->Release(); bd->pIB = nullptr; }
        bd->IndexBufferSize = draw_data->TotalIdxCount + 10000;
        if (device->CreateIndexBuffer(bd->IndexBufferSize * sizeof(ImDrawIdx), D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY, sizeof(ImDrawIdx) == 2 ? D3DFMT_INDEX16 : D3DFMT_INDEX32, D3DPOOL_DEFAULT, &bd->pIB, nullptr) < 0)
            return;
    }

    // Backup the DX9 state
    IDirect3DStateBlock9* state_block = nullptr;
    if (device->CreateStateBlock(D3DSBT_ALL, &state_block) < 0)
        return;
    if (state_block->Capture() < 0)
    {
        state_block->Release();
        return;
    }

    // Backup the DX9 transform (DX9 documentation suggests that it is included in the StateBlock but it doesn't appear to)
    D3DMATRIX last_world, last_view, last_projection;
    device->GetTransform(D3DTS_WORLD, &last_world);
    device->GetTransform(D3DTS_VIEW, &last_view);
    device->GetTransform(D3DTS_PROJECTION, &last_projection);

    // Allocate buffers
    CUSTOMVERTEX* vtx_dst;
    ImDrawIdx* idx_dst;
    if (bd->pVB->Lock(0, (UINT)(draw_data->TotalVtxCount * sizeof(CUSTOMVERTEX)), (void**)&vtx_dst, D3DLOCK_DISCARD) < 0)
    {
        state_block->Release();
        return;
    }
    if (bd->pIB->Lock(0, (UINT)(draw_data->TotalIdxCount * sizeof(ImDrawIdx)), (void**)&idx_dst, D3DLOCK_DISCARD) < 0)
    {
        bd->pVB->Unlock();
        state_block->Release();
        return;
    }

    // Copy and convert all vertices into a single contiguous buffer, convert colors to DX9 default format.
    // FIXME-OPT: This is a minor waste of resource, the ideal is to use imconfig.h and
    //  1) to avoid repacking colors:   #define IMGUI_USE_BGRA_PACKED_COLOR
    //  2) to avoid repacking vertices: #define IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT struct ImDrawVert { ImVec2 pos; float z; ImU32 col; ImVec2 uv; }
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* draw_list = draw_data->CmdLists[n];
        const ImDrawVert* vtx_src = draw_list->VtxBuffer.Data;
        for (int i = 0; i < draw_list->VtxBuffer.Size; i++)
        {
            vtx_dst->pos[0] = vtx_src->pos.x;
            vtx_dst->pos[1] = vtx_src->pos.y;
            vtx_dst->pos[2] = 0.0f;
            vtx_dst->col = IMGUI_COL_TO_DX9_ARGB(vtx_src->col);
            vtx_dst->uv[0] = vtx_src->uv.x;
            vtx_dst->uv[1] = vtx_src->uv.y;
            vtx_dst++;
            vtx_src++;
        }
        memcpy(idx_dst, draw_list->IdxBuffer.Data, draw_list->IdxBuffer.Size * sizeof(ImDrawIdx));
        idx_dst += draw_list->IdxBuffer.Size;
    }
    bd->pVB->Unlock();
    bd->pIB->Unlock();
    device->SetStreamSource(0, bd->pVB, 0, sizeof(CUSTOMVERTEX));
    device->SetIndices(bd->pIB);
    device->SetFVF(D3DFVF_CUSTOMVERTEX);

    // Setup desired DX state
    ImGui_ImplDX9_SetupRenderState(draw_data);

    // Render command lists
    // (Because we merged all buffers into a single one, we maintain our own offset into them)
    int global_vtx_offset = 0;
    int global_idx_offset = 0;
    ImVec2 clip_off = draw_data->DisplayPos;
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* draw_list = draw_data->CmdLists[n];
        for (int cmd_i = 0; cmd_i < draw_list->CmdBuffer.Size; cmd_i++)
        {
            const ImDrawCmd* pcmd = &draw_list->CmdBuffer[cmd_i];
            if (pcmd->UserCallback != nullptr)
            {
                // User callback, registered via ImDrawList::AddCallback()
                // (ImDrawCallback_ResetRenderState is a special callback value used by the user to request the renderer to reset render state.)
                if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)
                    ImGui_ImplDX9_SetupRenderState(draw_data);
                else
                    pcmd->UserCallback(draw_list, pcmd);
            }
            else
            {
                // Project scissor/clipping rectangles into framebuffer space
                ImVec2 clip_min(pcmd->ClipRect.x - clip_off.x, pcmd->ClipRect.y - clip_off.y);
                ImVec2 clip_max(pcmd->ClipRect.z - clip_off.x, pcmd->ClipRect.w - clip_off.y);
                if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
                    continue;

                // Apply scissor/clipping rectangle
                const RECT r = { (LONG)clip_min.x, (LONG)clip_min.y, (LONG)clip_max.x, (LONG)clip_max.y };
                device->SetScissorRect(&r);

                // Bind texture, Draw
                const LPDIRECT3DTEXTURE9 texture = (LPDIRECT3DTEXTURE9)pcmd->GetTexID();
                device->SetTexture(0, texture);
                device->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, pcmd->VtxOffset + global_vtx_offset, 0, (UINT)draw_list->VtxBuffer.Size, pcmd->IdxOffset + global_idx_offset, pcmd->ElemCount / 3);
            }
        }
        global_idx_offset += draw_list->IdxBuffer.Size;
        global_vtx_offset += draw_list->VtxBuffer.Size;
    }

    // Restore the DX9 transform
    device->SetTransform(D3DTS_WORLD, &last_world);
    device->SetTransform(D3DTS_VIEW, &last_view);
    device->SetTransform(D3DTS_PROJECTION, &last_projection);

    // Restore the DX9 state
    state_block->Apply();
    state_block->Release();
}

static bool ImGui_ImplDX9_CheckFormatSupport(LPDIRECT3DDEVICE9 pDevice, D3DFORMAT format)
{
    LPDIRECT3D9 pd3d = nullptr;
    if (pDevice->GetDirect3D(&pd3d) != D3D_OK)
        return false;
    D3DDEVICE_CREATION_PARAMETERS param = {};
    D3DDISPLAYMODE mode = {};
    if (pDevice->GetCreationParameters(&param) != D3D_OK || pDevice->GetDisplayMode(0, &mode) != D3D_OK)
    {
        pd3d->Release();
        return false;
    }
    // Font texture should support linear filter, color blend and write to render-target
    bool support = (pd3d->CheckDeviceFormat(param.AdapterOrdinal, param.DeviceType, mode.Format, D3DUSAGE_DYNAMIC | D3DUSAGE_QUERY_FILTER | D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING, D3DRTYPE_TEXTURE, format)) == D3D_OK;
    pd3d->Release();
    return support;
}

bool ImGui_ImplDX9_Init(IDirect3DDevice9* device)
{
    ImGuiIO& io = ImGui::GetIO();
    IMGUI_CHECKVERSION();
    IM_ASSERT(io.BackendRendererUserData == nullptr && "Already initialized a renderer backend!");

    // Setup backend capabilities flags
    ImGui_ImplDX9_Data* bd = IM_NEW(ImGui_ImplDX9_Data)();
    io.BackendRendererUserData = (void*)bd;
    io.BackendRendererName = "imgui_impl_dx9";
    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.

    bd->pd3dDevice = device;
    bd->pd3dDevice->AddRef();
    bd->HasRgbaSupport = ImGui_ImplDX9_CheckFormatSupport(bd->pd3dDevice, D3DFMT_A8B8G8R8);

    return true;
}

void ImGui_ImplDX9_Shutdown()
{
    ImGui_ImplDX9_Data* bd = ImGui_ImplDX9_GetBackendData();
    IM_ASSERT(bd != nullptr && "No renderer backend to shutdown, or already shutdown?");
    ImGuiIO& io = ImGui::GetIO();

    ImGui_ImplDX9_InvalidateDeviceObjects();
    if (bd->pd3dDevice) { bd->pd3dDevice->Release(); }
    io.BackendRendererName = nullptr;
    io.BackendRendererUserData = nullptr;
    io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;
    IM_DELETE(bd);
}

// Convert RGBA32 to BGRA32 (because RGBA32 is not well supported by DX9 devices)
static void ImGui_ImplDX9_CopyTextureRegion(bool tex_use_colors, ImU32* src, int src_pitch, ImU32* dst, int dst_pitch, int w, int h)
{
#ifndef IMGUI_USE_BGRA_PACKED_COLOR
    ImGui_ImplDX9_Data* bd = ImGui_ImplDX9_GetBackendData();
    const bool convert_rgba_to_bgra = (!bd->HasRgbaSupport && tex_use_colors);
#else
    const bool convert_rgba_to_bgra = false;
    IM_UNUSED(tex_use_colors);
#endif
    for (int y = 0; y < h; y++)
    {
        ImU32* src_p = (ImU32*)((unsigned char*)src + src_pitch * y);
        ImU32* dst_p = (ImU32*)((unsigned char*)dst + dst_pitch * y);
        if (convert_rgba_to_bgra)
            for (int x = w; x > 0; x--, src_p++, dst_p++) // Convert copy
                *dst_p = IMGUI_COL_TO_DX9_ARGB(*src_p);
        else
            memcpy(dst_p, src_p, w * 4); // Raw copy
    }
}

static bool ImGui_ImplDX9_CreateFontsTexture()
{
    // Build texture atlas
    ImGuiIO& io = ImGui::GetIO();
    ImGui_ImplDX9_Data* bd = ImGui_ImplDX9_GetBackendData();
    unsigned char* pixels;
    int width, height, bytes_per_pixel;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height, &bytes_per_pixel);

    // Upload texture to graphics system
    bd->FontTexture = nullptr;
    if (bd->pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_DYNAMIC, bd->HasRgbaSupport ? D3DFMT_A8B8G8R8 : D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &bd->FontTexture, nullptr) < 0)
        return false;
    D3DLOCKED_RECT tex_locked_rect;
    if (bd->FontTexture->LockRect(0, &tex_locked_rect, nullptr, 0) != D3D_OK)
        return false;
    ImGui_ImplDX9_CopyTextureRegion(io.Fonts->TexPixelsUseColors, (ImU32*)pixels, width * bytes_per_pixel, (ImU32*)tex_locked_rect.pBits, (int)tex_locked_rect.Pitch, width, height);
    bd->FontTexture->UnlockRect(0);

    // Store our identifier
    io.Fonts->SetTexID((ImTextureID)bd->FontTexture);
    return true;
}

bool ImGui_ImplDX9_CreateDeviceObjects()
{
    ImGui_ImplDX9_Data* bd = ImGui_ImplDX9_GetBackendData();
    if (!bd || !bd->pd3dDevice)
        return false;
    if (!ImGui_ImplDX9_CreateFontsTexture())
        return false;
    return true;
}

void ImGui_ImplDX9_InvalidateDeviceObjects()
{
    ImGui_ImplDX9_Data* bd = ImGui_ImplDX9_GetBackendData();
    if (!bd || !bd->pd3dDevice)
        return;
    if (bd->pVB) { bd->pVB->Release(); bd->pVB = nullptr; }
    if (bd->pIB) { bd->pIB->Release(); bd->pIB = nullptr; }
    if (bd->FontTexture) { bd->FontTexture->Release(); bd->FontTexture = nullptr; ImGui::GetIO().Fonts->SetTexID(0); } // We copied bd->pFontTextureView to io.Fonts->TexID so let's clear that as well.
}

void ImGui_ImplDX9_NewFrame()
{
    ImGui_ImplDX9_Data* bd = ImGui_ImplDX9_GetBackendData();
    IM_ASSERT(bd != nullptr && "Context or backend not initialized! Did you call ImGui_ImplDX9_Init()?");

    if (!bd->FontTexture)
        ImGui_ImplDX9_CreateDeviceObjects();
}

//-----------------------------------------------------------------------------

#endif // #ifndef IMGUI_DISABLE



================================================
FILE: ImGui/imgui_impl_dx9.h
================================================
// dear imgui: Renderer Backend for DirectX9
// This needs to be used along with a Platform Backend (e.g. Win32)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'LPDIRECT3DTEXTURE9' as ImTextureID. Read the FAQ about ImTextureID!
//  [X] Renderer: Large meshes support (64k+ vertices) even with 16-bit indices (ImGuiBackendFlags_RendererHasVtxOffset).
//  [X] Renderer: IMGUI_USE_BGRA_PACKED_COLOR support, as this is the optimal color encoding for DirectX9.

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// Learn about Dear ImGui:
// - FAQ                  https://dearimgui.com/faq
// - Getting Started      https://dearimgui.com/getting-started
// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).
// - Introduction, links and more at the top of imgui.cpp

#pragma once
#include "imgui.h"      // IMGUI_IMPL_API
#ifndef IMGUI_DISABLE

struct IDirect3DDevice9;

// Follow "Getting Started" link and check examples/ folder to learn about using backends!
IMGUI_IMPL_API bool     ImGui_ImplDX9_Init(IDirect3DDevice9* device);
IMGUI_IMPL_API void     ImGui_ImplDX9_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplDX9_NewFrame();
IMGUI_IMPL_API void     ImGui_ImplDX9_RenderDrawData(ImDrawData* draw_data);

// Use if you want to reset your rendering device without losing Dear ImGui state.
IMGUI_IMPL_API bool     ImGui_ImplDX9_CreateDeviceObjects();
IMGUI_IMPL_API void     ImGui_ImplDX9_InvalidateDeviceObjects();

#endif // #ifndef IMGUI_DISABLE



================================================
FILE: ImGui/imgui_impl_win32.cpp
================================================
// dear imgui: Platform Backend for Windows (standard windows API for 32-bits AND 64-bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)
//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen.
//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy VK_* values are obsolete since 1.87 and not supported since 1.91.5]
//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.
//  [X] Platform: Mouse cursor shape and visibility (ImGuiBackendFlags_HasMouseCursors). Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// Learn about Dear ImGui:
// - FAQ                  https://dearimgui.com/faq
// - Getting Started      https://dearimgui.com/getting-started
// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).
// - Introduction, links and more at the top of imgui.cpp

// Configuration flags to add in your imconfig file:
//#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD              // Disable gamepad support. This was meaningful before <1.81 but we now load XInput dynamically so the option is now less relevant.

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2025-03-10: When dealing with OEM keys, use scancodes instead of translated keycodes to choose ImGuiKey values. (#7136, #7201, #7206, #7306, #7670, #7672, #8468)
//  2025-02-18: Added ImGuiMouseCursor_Wait and ImGuiMouseCursor_Progress mouse cursor support.
//  2024-07-08: Inputs: Fixed ImGuiMod_Super being mapped to VK_APPS instead of VK_LWIN||VK_RWIN. (#7768)
//  2023-10-05: Inputs: Added support for extra ImGuiKey values: F13 to F24 function keys, app back/forward keys.
//  2023-09-25: Inputs: Synthesize key-down event on key-up for VK_SNAPSHOT / ImGuiKey_PrintScreen as Windows doesn't emit it (same behavior as GLFW/SDL).
//  2023-09-07: Inputs: Added support for keyboard codepage conversion for when application is compiled in MBCS mode and using a non-Unicode window.
//  2023-04-19: Added ImGui_ImplWin32_InitForOpenGL() to facilitate combining raw Win32/Winapi with OpenGL. (#3218)
//  2023-04-04: Inputs: Added support for io.AddMouseSourceEvent() to discriminate ImGuiMouseSource_Mouse/ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen. (#2702)
//  2023-02-15: Inputs: Use WM_NCMOUSEMOVE / WM_NCMOUSELEAVE to track mouse position over non-client area (e.g. OS decorations) when app is not focused. (#6045, #6162)
//  2023-02-02: Inputs: Flipping WM_MOUSEHWHEEL (horizontal mouse-wheel) value to match other backends and offer consistent horizontal scrolling direction. (#4019, #6096, #1463)
//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.
//  2022-09-28: Inputs: Convert WM_CHAR values with MultiByteToWideChar() when window class was registered as MBCS (not Unicode).
//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introduced in 1.87 to ImGuiMod_XXX (old names still supported).
//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago) with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.
//  2021-01-20: Inputs: calling new io.AddKeyAnalogEvent() for gamepad support, instead of writing directly to io.NavInputs[].
//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).
//  2022-01-17: Inputs: always update key mods next and before a key event (not in NewFrame) to fix input queue with very low framerates.
//  2022-01-12: Inputs: Update mouse inputs using WM_MOUSEMOVE/WM_MOUSELEAVE + fallback to provide it when focused but not hovered/captured. More standard and will allow us to pass it to future input queue API.
//  2022-01-12: Inputs: Maintain our own copy of MouseButtonsDown mask instead of using ImGui::IsAnyMouseDown() which will be obsoleted.
//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyModsEvent() + io.SetKeyEventNativeData() API (1.87+). Support for full ImGuiKey range.
//  2021-12-16: Inputs: Fill VK_LCONTROL/VK_RCONTROL/VK_LSHIFT/VK_RSHIFT/VK_LMENU/VK_RMENU for completeness.
//  2021-08-17: Calling io.AddFocusEvent() on WM_SETFOCUS/WM_KILLFOCUS messages.
//  2021-08-02: Inputs: Fixed keyboard modifiers being reported when host window doesn't have focus.
//  2021-07-29: Inputs: MousePos is correctly reported when the host platform window is hovered but not focused (using TrackMouseEvent() to receive WM_MOUSELEAVE events).
//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).
//  2021-06-08: Fixed ImGui_ImplWin32_EnableDpiAwareness() and ImGui_ImplWin32_GetDpiScaleForMonitor() to handle Windows 8.1/10 features without a manifest (per-monitor DPI, and properly calls SetProcessDpiAwareness() on 8.1).
//  2021-03-23: Inputs: Clearing keyboard down array when losing focus (WM_KILLFOCUS).
//  2021-02-18: Added ImGui_ImplWin32_EnableAlphaCompositing(). Non Visual Studio users will need to link with dwmapi.lib (MinGW/gcc: use -ldwmapi).
//  2021-02-17: Fixed ImGui_ImplWin32_EnableDpiAwareness() attempting to get SetProcessDpiAwareness from shcore.dll on Windows 8 whereas it is only supported on Windows 8.1.
//  2021-01-25: Inputs: Dynamically loading XInput DLL.
//  2020-12-04: Misc: Fixed setting of io.DisplaySize to invalid/uninitialized data when after hwnd has been closed.
//  2020-03-03: Inputs: Calling AddInputCharacterUTF16() to support surrogate pairs leading to codepoint >= 0x10000 (for more complete CJK inputs)
//  2020-02-17: Added ImGui_ImplWin32_EnableDpiAwareness(), ImGui_ImplWin32_GetDpiScaleForHwnd(), ImGui_ImplWin32_GetDpiScaleForMonitor() helper functions.
//  2020-01-14: Inputs: Added support for #define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD/IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT.
//  2019-12-05: Inputs: Added support for ImGuiMouseCursor_NotAllowed mouse cursor.
//  2019-05-11: Inputs: Don't filter value from WM_CHAR before calling AddInputCharacter().
//  2019-01-17: Misc: Using GetForegroundWindow()+IsChild() instead of GetActiveWindow() to be compatible with windows created in a different thread or parent.
//  2019-01-17: Inputs: Added support for mouse buttons 4 and 5 via WM_XBUTTON* messages.
//  2019-01-15: Inputs: Added support for XInput gamepads (if ImGuiConfigFlags_NavEnableGamepad is set by user application).
//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.
//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.
//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).
//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.
//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.
//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).
//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.
//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavMoveMouse is set).
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.
//  2018-01-20: Inputs: Added Horizontal Mouse Wheel support.
//  2018-01-08: Inputs: Added mapping for ImGuiKey_Insert.
//  2018-01-05: Inputs: Added WM_LBUTTONDBLCLK double-click handlers for window classes with the CS_DBLCLKS flag.
//  2017-10-23: Inputs: Added WM_SYSKEYDOWN / WM_SYSKEYUP handlers so e.g. the VK_MENU key can be read.
//  2017-10-23: Inputs: Using Win32 ::SetCapture/::GetCapture() to retrieve mouse positions outside the client area when dragging.
//  2016-11-12: Inputs: Only call Win32 ::SetCursor(nullptr) when io.MouseDrawCursor is set.

#include "imgui.h"
#ifndef IMGUI_DISABLE
#include "imgui_impl_win32.h"
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h> // GET_X_LPARAM(), GET_Y_LPARAM()
#include <tchar.h>
#include <dwmapi.h>

// Using XInput for gamepad (will load DLL dynamically)
#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
#include <xinput.h>
typedef DWORD(WINAPI* PFN_XInputGetCapabilities)(DWORD, DWORD, XINPUT_CAPABILITIES*);
typedef DWORD(WINAPI* PFN_XInputGetState)(DWORD, XINPUT_STATE*);
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wcast-function-type"     // warning: cast between incompatible function types (for loader)
#endif
#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"                  // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wcast-function-type"       // warning: cast between incompatible function types (for loader)
#endif

struct ImGui_ImplWin32_Data
{
    HWND                        hWnd;
    HWND                        MouseHwnd;
    int                         MouseTrackedArea;   // 0: not tracked, 1: client area, 2: non-client area
    int                         MouseButtonsDown;
    INT64                       Time;
    INT64                       TicksPerSecond;
    ImGuiMouseCursor            LastMouseCursor;
    UINT32                      KeyboardCodePage;

#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
    bool                        HasGamepad;
    bool                        WantUpdateHasGamepad;
    HMODULE                     XInputDLL;
    PFN_XInputGetCapabilities   XInputGetCapabilities;
    PFN_XInputGetState          XInputGetState;
#endif

    ImGui_ImplWin32_Data()      { memset((void*)this, 0, sizeof(*this)); }
};

// Backend data stored in io.BackendPlatformUserData to allow support for multiple Dear ImGui contexts
// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.
// FIXME: multi-context support is not well tested and probably dysfunctional in this backend.
// FIXME: some shared resources (mouse cursor shape, gamepad) are mishandled when using multi-context.
static ImGui_ImplWin32_Data* ImGui_ImplWin32_GetBackendData()
{
    return ImGui::GetCurrentContext() ? (ImGui_ImplWin32_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;
}
static ImGui_ImplWin32_Data* ImGui_ImplWin32_GetBackendData(ImGuiIO& io)
{
    return (ImGui_ImplWin32_Data*)io.BackendPlatformUserData;
}

// Functions
static void ImGui_ImplWin32_UpdateKeyboardCodePage(ImGuiIO& io)
{
    // Retrieve keyboard code page, required for handling of non-Unicode Windows.
    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData(io);
    HKL keyboard_layout = ::GetKeyboardLayout(0);
    LCID keyboard_lcid = MAKELCID(HIWORD(keyboard_layout), SORT_DEFAULT);
    if (::GetLocaleInfoA(keyboard_lcid, (LOCALE_RETURN_NUMBER | LOCALE_IDEFAULTANSICODEPAGE), (LPSTR)&bd->KeyboardCodePage, sizeof(bd->KeyboardCodePage)) == 0)
        bd->KeyboardCodePage = CP_ACP; // Fallback to default ANSI code page when fails.
}

static bool ImGui_ImplWin32_InitEx(void* hwnd, bool platform_has_own_dc)
{
    ImGuiIO& io = ImGui::GetIO();
    IMGUI_CHECKVERSION();
    IM_ASSERT(io.BackendPlatformUserData == nullptr && "Already initialized a platform backend!");

    INT64 perf_frequency, perf_counter;
    if (!::QueryPerformanceFrequency((LARGE_INTEGER*)&perf_frequency))
        return false;
    if (!::QueryPerformanceCounter((LARGE_INTEGER*)&perf_counter))
        return false;

    // Setup backend capabilities flags
    ImGui_ImplWin32_Data* bd = IM_NEW(ImGui_ImplWin32_Data)();
    io.BackendPlatformUserData = (void*)bd;
    io.BackendPlatformName = "imgui_impl_win32";
    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)
    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)

    bd->hWnd = (HWND)hwnd;
    bd->TicksPerSecond = perf_frequency;
    bd->Time = perf_counter;
    bd->LastMouseCursor = ImGuiMouseCursor_COUNT;
    ImGui_ImplWin32_UpdateKeyboardCodePage(io);

    // Set platform dependent data in viewport
    ImGuiViewport* main_viewport = ImGui::GetMainViewport();
    main_viewport->PlatformHandle = main_viewport->PlatformHandleRaw = (void*)bd->hWnd;
    IM_UNUSED(platform_has_own_dc); // Used in 'docking' branch

    // Dynamically load XInput library
#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
    bd->WantUpdateHasGamepad = true;
    const char* xinput_dll_names[] =
    {
        "xinput1_4.dll",   // Windows 8+
        "xinput1_3.dll",   // DirectX SDK
        "xinput9_1_0.dll", // Windows Vista, Windows 7
        "xinput1_2.dll",   // DirectX SDK
        "xinput1_1.dll"    // DirectX SDK
    };
    for (int n = 0; n < IM_ARRAYSIZE(xinput_dll_names); n++)
        if (HMODULE dll = ::LoadLibraryA(xinput_dll_names[n]))
        {
            bd->XInputDLL = dll;
            bd->XInputGetCapabilities = (PFN_XInputGetCapabilities)::GetProcAddress(dll, "XInputGetCapabilities");
            bd->XInputGetState = (PFN_XInputGetState)::GetProcAddress(dll, "XInputGetState");
            break;
        }
#endif // IMGUI_IMPL_WIN32_DISABLE_GAMEPAD

    return true;
}

IMGUI_IMPL_API bool     ImGui_ImplWin32_Init(void* hwnd)
{
    return ImGui_ImplWin32_InitEx(hwnd, false);
}

IMGUI_IMPL_API bool     ImGui_ImplWin32_InitForOpenGL(void* hwnd)
{
    // OpenGL needs CS_OWNDC
    return ImGui_ImplWin32_InitEx(hwnd, true);
}

void    ImGui_ImplWin32_Shutdown()
{
    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData();
    IM_ASSERT(bd != nullptr && "No platform backend to shutdown, or already shutdown?");
    ImGuiIO& io = ImGui::GetIO();

    // Unload XInput library
#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
    if (bd->XInputDLL)
        ::FreeLibrary(bd->XInputDLL);
#endif // IMGUI_IMPL_WIN32_DISABLE_GAMEPAD

    io.BackendPlatformName = nullptr;
    io.BackendPlatformUserData = nullptr;
    io.BackendFlags &= ~(ImGuiBackendFlags_HasMouseCursors | ImGuiBackendFlags_HasSetMousePos | ImGuiBackendFlags_HasGamepad);
    IM_DELETE(bd);
}

static bool ImGui_ImplWin32_UpdateMouseCursor(ImGuiIO& io, ImGuiMouseCursor imgui_cursor)
{
    if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)
        return false;

    if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)
    {
        // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
        ::SetCursor(nullptr);
    }
    else
    {
        // Show OS mouse cursor
        LPTSTR win32_cursor = IDC_ARROW;
        switch (imgui_cursor)
        {
        case ImGuiMouseCursor_Arrow:        win32_cursor = IDC_ARROW; break;
        case ImGuiMouseCursor_TextInput:    win32_cursor = IDC_IBEAM; break;
        case ImGuiMouseCursor_ResizeAll:    win32_cursor = IDC_SIZEALL; break;
        case ImGuiMouseCursor_ResizeEW:     win32_cursor = IDC_SIZEWE; break;
        case ImGuiMouseCursor_ResizeNS:     win32_cursor = IDC_SIZENS; break;
        case ImGuiMouseCursor_ResizeNESW:   win32_cursor = IDC_SIZENESW; break;
        case ImGuiMouseCursor_ResizeNWSE:   win32_cursor = IDC_SIZENWSE; break;
        case ImGuiMouseCursor_Hand:         win32_cursor = IDC_HAND; break;
        case ImGuiMouseCursor_Wait:         win32_cursor = IDC_WAIT; break;
        case ImGuiMouseCursor_Progress:     win32_cursor = IDC_APPSTARTING; break;
        case ImGuiMouseCursor_NotAllowed:   win32_cursor = IDC_NO; break;
        }
        ::SetCursor(::LoadCursor(nullptr, win32_cursor));
    }
    return true;
}

static bool IsVkDown(int vk)
{
    return (::GetKeyState(vk) & 0x8000) != 0;
}

static void ImGui_ImplWin32_AddKeyEvent(ImGuiIO& io, ImGuiKey key, bool down, int native_keycode, int native_scancode = -1)
{
    io.AddKeyEvent(key, down);
    io.SetKeyEventNativeData(key, native_keycode, native_scancode); // To support legacy indexing (<1.87 user code)
    IM_UNUSED(native_scancode);
}

static void ImGui_ImplWin32_ProcessKeyEventsWorkarounds(ImGuiIO& io)
{
    // Left & right Shift keys: when both are pressed together, Windows tend to not generate the WM_KEYUP event for the first released one.
    if (ImGui::IsKeyDown(ImGuiKey_LeftShift) && !IsVkDown(VK_LSHIFT))
        ImGui_ImplWin32_AddKeyEvent(io, ImGuiKey_LeftShift, false, VK_LSHIFT);
    if (ImGui::IsKeyDown(ImGuiKey_RightShift) && !IsVkDown(VK_RSHIFT))
        ImGui_ImplWin32_AddKeyEvent(io, ImGuiKey_RightShift, false, VK_RSHIFT);

    // Sometimes WM_KEYUP for Win key is not passed down to the app (e.g. for Win+V on some setups, according to GLFW).
    if (ImGui::IsKeyDown(ImGuiKey_LeftSuper) && !IsVkDown(VK_LWIN))
        ImGui_ImplWin32_AddKeyEvent(io, ImGuiKey_LeftSuper, false, VK_LWIN);
    if (ImGui::IsKeyDown(ImGuiKey_RightSuper) && !IsVkDown(VK_RWIN))
        ImGui_ImplWin32_AddKeyEvent(io, ImGuiKey_RightSuper, false, VK_RWIN);
}

static void ImGui_ImplWin32_UpdateKeyModifiers(ImGuiIO& io)
{
    io.AddKeyEvent(ImGuiMod_Ctrl, IsVkDown(VK_CONTROL));
    io.AddKeyEvent(ImGuiMod_Shift, IsVkDown(VK_SHIFT));
    io.AddKeyEvent(ImGuiMod_Alt, IsVkDown(VK_MENU));
    io.AddKeyEvent(ImGuiMod_Super, IsVkDown(VK_LWIN) || IsVkDown(VK_RWIN));
}

static void ImGui_ImplWin32_UpdateMouseData(ImGuiIO& io)
{
    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData(io);
    IM_ASSERT(bd->hWnd != 0);

    HWND focused_window = ::GetForegroundWindow();
    const bool is_app_focused = (focused_window == bd->hWnd);
    if (is_app_focused)
    {
        // (Optional) Set OS mouse position from Dear ImGui if requested (rarely used, only when io.ConfigNavMoveSetMousePos is enabled by user)
        if (io.WantSetMousePos)
        {
            POINT pos = { (int)io.MousePos.x, (int)io.MousePos.y };
            if (::ClientToScreen(bd->hWnd, &pos))
                ::SetCursorPos(pos.x, pos.y);
        }

        // (Optional) Fallback to provide mouse position when focused (WM_MOUSEMOVE already provides this when hovered or captured)
        // This also fills a short gap when clicking non-client area: WM_NCMOUSELEAVE -> modal OS move -> gap -> WM_NCMOUSEMOVE
        if (!io.WantSetMousePos && bd->MouseTrackedArea == 0)
        {
            POINT pos;
            if (::GetCursorPos(&pos) && ::ScreenToClient(bd->hWnd, &pos))
                io.AddMousePosEvent((float)pos.x, (float)pos.y);
        }
    }
}

// Gamepad navigation mapping
static void ImGui_ImplWin32_UpdateGamepads(ImGuiIO& io)
{
#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData(io);
    //if ((io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) == 0) // FIXME: Technically feeding gamepad shouldn't depend on this now that they are regular inputs.
    //    return;

    // Calling XInputGetState() every frame on disconnected gamepads is unfortunately too slow.
    // Instead we refresh gamepad availability by calling XInputGetCapabilities() _only_ after receiving WM_DEVICECHANGE.
    if (bd->WantUpdateHasGamepad)
    {
        XINPUT_CAPABILITIES caps = {};
        bd->HasGamepad = bd->XInputGetCapabilities ? (bd->XInputGetCapabilities(0, XINPUT_FLAG_GAMEPAD, &caps) == ERROR_SUCCESS) : false;
        bd->WantUpdateHasGamepad = false;
    }

    io.BackendFlags &= ~ImGuiBackendFlags_HasGamepad;
    XINPUT_STATE xinput_state;
    XINPUT_GAMEPAD& gamepad = xinput_state.Gamepad;
    if (!bd->HasGamepad || bd->XInputGetState == nullptr || bd->XInputGetState(0, &xinput_state) != ERROR_SUCCESS)
        return;
    io.BackendFlags |= ImGuiBackendFlags_HasGamepad;

    #define IM_SATURATE(V)                      (V < 0.0f ? 0.0f : V > 1.0f ? 1.0f : V)
    #define MAP_BUTTON(KEY_NO, BUTTON_ENUM)     { io.AddKeyEvent(KEY_NO, (gamepad.wButtons & BUTTON_ENUM) != 0); }
    #define MAP_ANALOG(KEY_NO, VALUE, V0, V1)   { float vn = (float)(VALUE - V0) / (float)(V1 - V0); io.AddKeyAnalogEvent(KEY_NO, vn > 0.10f, IM_SATURATE(vn)); }
    MAP_BUTTON(ImGuiKey_GamepadStart,           XINPUT_GAMEPAD_START);
    MAP_BUTTON(ImGuiKey_GamepadBack,            XINPUT_GAMEPAD_BACK);
    MAP_BUTTON(ImGuiKey_GamepadFaceLeft,        XINPUT_GAMEPAD_X);
    MAP_BUTTON(ImGuiKey_GamepadFaceRight,       XINPUT_GAMEPAD_B);
    MAP_BUTTON(ImGuiKey_GamepadFaceUp,          XINPUT_GAMEPAD_Y);
    MAP_BUTTON(ImGuiKey_GamepadFaceDown,        XINPUT_GAMEPAD_A);
    MAP_BUTTON(ImGuiKey_GamepadDpadLeft,        XINPUT_GAMEPAD_DPAD_LEFT);
    MAP_BUTTON(ImGuiKey_GamepadDpadRight,       XINPUT_GAMEPAD_DPAD_RIGHT);
    MAP_BUTTON(ImGuiKey_GamepadDpadUp,          XINPUT_GAMEPAD_DPAD_UP);
    MAP_BUTTON(ImGuiKey_GamepadDpadDown,        XINPUT_GAMEPAD_DPAD_DOWN);
    MAP_BUTTON(ImGuiKey_GamepadL1,              XINPUT_GAMEPAD_LEFT_SHOULDER);
    MAP_BUTTON(ImGuiKey_GamepadR1,              XINPUT_GAMEPAD_RIGHT_SHOULDER);
    MAP_ANALOG(ImGuiKey_GamepadL2,              gamepad.bLeftTrigger, XINPUT_GAMEPAD_TRIGGER_THRESHOLD, 255);
    MAP_ANALOG(ImGuiKey_GamepadR2,              gamepad.bRightTrigger, XINPUT_GAMEPAD_TRIGGER_THRESHOLD, 255);
    MAP_BUTTON(ImGuiKey_GamepadL3,              XINPUT_GAMEPAD_LEFT_THUMB);
    MAP_BUTTON(ImGuiKey_GamepadR3,              XINPUT_GAMEPAD_RIGHT_THUMB);
    MAP_ANALOG(ImGuiKey_GamepadLStickLeft,      gamepad.sThumbLX, -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32768);
    MAP_ANALOG(ImGuiKey_GamepadLStickRight,     gamepad.sThumbLX, +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
    MAP_ANALOG(ImGuiKey_GamepadLStickUp,        gamepad.sThumbLY, +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
    MAP_ANALOG(ImGuiKey_GamepadLStickDown,      gamepad.sThumbLY, -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32768);
    MAP_ANALOG(ImGuiKey_GamepadRStickLeft,      gamepad.sThumbRX, -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32768);
    MAP_ANALOG(ImGuiKey_GamepadRStickRight,     gamepad.sThumbRX, +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
    MAP_ANALOG(ImGuiKey_GamepadRStickUp,        gamepad.sThumbRY, +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
    MAP_ANALOG(ImGuiKey_GamepadRStickDown,      gamepad.sThumbRY, -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32768);
    #undef MAP_BUTTON
    #undef MAP_ANALOG
#else // #ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
    IM_UNUSED(io);
#endif
}

void    ImGui_ImplWin32_NewFrame()
{
    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData();
    IM_ASSERT(bd != nullptr && "Context or backend not initialized? Did you call ImGui_ImplWin32_Init()?");
    ImGuiIO& io = ImGui::GetIO();

    // Setup display size (every frame to accommodate for window resizing)
    RECT rect = { 0, 0, 0, 0 };
    ::GetClientRect(bd->hWnd, &rect);
    io.DisplaySize = ImVec2((float)(rect.right - rect.left), (float)(rect.bottom - rect.top));

    // Setup time step
    INT64 current_time = 0;
    ::QueryPerformanceCounter((LARGE_INTEGER*)&current_time);
    io.DeltaTime = (float)(current_time - bd->Time) / bd->TicksPerSecond;
    bd->Time = current_time;

    // Update OS mouse position
    ImGui_ImplWin32_UpdateMouseData(io);

    // Process workarounds for known Windows key handling issues
    ImGui_ImplWin32_ProcessKeyEventsWorkarounds(io);

    // Update OS mouse cursor with the cursor requested by imgui
    ImGuiMouseCursor mouse_cursor = io.MouseDrawCursor ? ImGuiMouseCursor_None : ImGui::GetMouseCursor();
    if (bd->LastMouseCursor != mouse_cursor)
    {
        bd->LastMouseCursor = mouse_cursor;
        ImGui_ImplWin32_UpdateMouseCursor(io, mouse_cursor);
    }

    // Update game controllers (if enabled and available)
    ImGui_ImplWin32_UpdateGamepads(io);
}

// Map VK_xxx to ImGuiKey_xxx.
// Not static to allow third-party code to use that if they want to (but undocumented)
ImGuiKey ImGui_ImplWin32_KeyEventToImGuiKey(WPARAM wParam, LPARAM lParam);
ImGuiKey ImGui_ImplWin32_KeyEventToImGuiKey(WPARAM wParam, LPARAM lParam)
{
    // There is no distinct VK_xxx for keypad enter, instead it is VK_RETURN + KF_EXTENDED.
    if ((wParam == VK_RETURN) && (HIWORD(lParam) & KF_EXTENDED))
        return ImGuiKey_KeypadEnter;

    const int scancode = (int)LOBYTE(HIWORD(lParam));
    //IMGUI_DEBUG_LOG("scancode %3d, keycode = 0x%02X\n", scancode, wParam);
    switch (wParam)
    {
        case VK_TAB: return ImGuiKey_Tab;
        case VK_LEFT: return ImGuiKey_LeftArrow;
        case VK_RIGHT: return ImGuiKey_RightArrow;
        case VK_UP: return ImGuiKey_UpArrow;
        case VK_DOWN: return ImGuiKey_DownArrow;
        case VK_PRIOR: return ImGuiKey_PageUp;
        case VK_NEXT: return ImGuiKey_PageDown;
        case VK_HOME: return ImGuiKey_Home;
        case VK_END: return ImGuiKey_End;
        case VK_INSERT: return ImGuiKey_Insert;
        case VK_DELETE: return ImGuiKey_Delete;
        case VK_BACK: return ImGuiKey_Backspace;
        case VK_SPACE: return ImGuiKey_Space;
        case VK_RETURN: return ImGuiKey_Enter;
        case VK_ESCAPE: return ImGuiKey_Escape;
        //case VK_OEM_7: return ImGuiKey_Apostrophe;
        case VK_OEM_COMMA: return ImGuiKey_Comma;
        //case VK_OEM_MINUS: return ImGuiKey_Minus;
        case VK_OEM_PERIOD: return ImGuiKey_Period;
        //case VK_OEM_2: return ImGuiKey_Slash;
        //case VK_OEM_1: return ImGuiKey_Semicolon;
        //case VK_OEM_PLUS: return ImGuiKey_Equal;
        //case VK_OEM_4: return ImGuiKey_LeftBracket;
        //case VK_OEM_5: return ImGuiKey_Backslash;
        //case VK_OEM_6: return ImGuiKey_RightBracket;
        //case VK_OEM_3: return ImGuiKey_GraveAccent;
        case VK_CAPITAL: return ImGuiKey_CapsLock;
        case VK_SCROLL: return ImGuiKey_ScrollLock;
        case VK_NUMLOCK: return ImGuiKey_NumLock;
        case VK_SNAPSHOT: return ImGuiKey_PrintScreen;
        case VK_PAUSE: return ImGuiKey_Pause;
        case VK_NUMPAD0: return ImGuiKey_Keypad0;
        case VK_NUMPAD1: return ImGuiKey_Keypad1;
        case VK_NUMPAD2: return ImGuiKey_Keypad2;
        case VK_NUMPAD3: return ImGuiKey_Keypad3;
        case VK_NUMPAD4: return ImGuiKey_Keypad4;
        case VK_NUMPAD5: return ImGuiKey_Keypad5;
        case VK_NUMPAD6: return ImGuiKey_Keypad6;
        case VK_NUMPAD7: return ImGuiKey_Keypad7;
        case VK_NUMPAD8: return ImGuiKey_Keypad8;
        case VK_NUMPAD9: return ImGuiKey_Keypad9;
        case VK_DECIMAL: return ImGuiKey_KeypadDecimal;
        case VK_DIVIDE: return ImGuiKey_KeypadDivide;
        case VK_MULTIPLY: return ImGuiKey_KeypadMultiply;
        case VK_SUBTRACT: return ImGuiKey_KeypadSubtract;
        case VK_ADD: return ImGuiKey_KeypadAdd;
        case VK_LSHIFT: return ImGuiKey_LeftShift;
        case VK_LCONTROL: return ImGuiKey_LeftCtrl;
        case VK_LMENU: return ImGuiKey_LeftAlt;
        case VK_LWIN: return ImGuiKey_LeftSuper;
        case VK_RSHIFT: return ImGuiKey_RightShift;
        case VK_RCONTROL: return ImGuiKey_RightCtrl;
        case VK_RMENU: return ImGuiKey_RightAlt;
        case VK_RWIN: return ImGuiKey_RightSuper;
        case VK_APPS: return ImGuiKey_Menu;
        case '0': return ImGuiKey_0;
        case '1': return ImGuiKey_1;
        case '2': return ImGuiKey_2;
        case '3': return ImGuiKey_3;
        case '4': return ImGuiKey_4;
        case '5': return ImGuiKey_5;
        case '6': return ImGuiKey_6;
        case '7': return ImGuiKey_7;
        case '8': return ImGuiKey_8;
        case '9': return ImGuiKey_9;
        case 'A': return ImGuiKey_A;
        case 'B': return ImGuiKey_B;
        case 'C': return ImGuiKey_C;
        case 'D': return ImGuiKey_D;
        case 'E': return ImGuiKey_E;
        case 'F': return ImGuiKey_F;
        case 'G': return ImGuiKey_G;
        case 'H': return ImGuiKey_H;
        case 'I': return ImGuiKey_I;
        case 'J': return ImGuiKey_J;
        case 'K': return ImGuiKey_K;
        case 'L': return ImGuiKey_L;
        case 'M': return ImGuiKey_M;
        case 'N': return ImGuiKey_N;
        case 'O': return ImGuiKey_O;
        case 'P': return ImGuiKey_P;
        case 'Q': return ImGuiKey_Q;
        case 'R': return ImGuiKey_R;
        case 'S': return ImGuiKey_S;
        case 'T': return ImGuiKey_T;
        case 'U': return ImGuiKey_U;
        case 'V': return ImGuiKey_V;
        case 'W': return ImGuiKey_W;
        case 'X': return ImGuiKey_X;
        case 'Y': return ImGuiKey_Y;
        case 'Z': return ImGuiKey_Z;
        case VK_F1: return ImGuiKey_F1;
        case VK_F2: return ImGuiKey_F2;
        case VK_F3: return ImGuiKey_F3;
        case VK_F4: return ImGuiKey_F4;
        case VK_F5: return ImGuiKey_F5;
        case VK_F6: return ImGuiKey_F6;
        case VK_F7: return ImGuiKey_F7;
        case VK_F8: return ImGuiKey_F8;
        case VK_F9: return ImGuiKey_F9;
        case VK_F10: return ImGuiKey_F10;
        case VK_F11: return ImGuiKey_F11;
        case VK_F12: return ImGuiKey_F12;
        case VK_F13: return ImGuiKey_F13;
        case VK_F14: return ImGuiKey_F14;
        case VK_F15: return ImGuiKey_F15;
        case VK_F16: return ImGuiKey_F16;
        case VK_F17: return ImGuiKey_F17;
        case VK_F18: return ImGuiKey_F18;
        case VK_F19: return ImGuiKey_F19;
        case VK_F20: return ImGuiKey_F20;
        case VK_F21: return ImGuiKey_F21;
        case VK_F22: return ImGuiKey_F22;
        case VK_F23: return ImGuiKey_F23;
        case VK_F24: return ImGuiKey_F24;
        case VK_BROWSER_BACK: return ImGuiKey_AppBack;
        case VK_BROWSER_FORWARD: return ImGuiKey_AppForward;
        default: break;
    }

    // Fallback to scancode
    // https://handmade.network/forums/t/2011-keyboard_inputs_-_scancodes,_raw_input,_text_input,_key_names
    switch (scancode)
    {
    case 41: return ImGuiKey_GraveAccent;  // VK_OEM_8 in EN-UK, VK_OEM_3 in EN-US, VK_OEM_7 in FR, VK_OEM_5 in DE, etc.
    case 12: return ImGuiKey_Minus;
    case 13: return ImGuiKey_Equal;
    case 26: return ImGuiKey_LeftBracket;
    case 27: return ImGuiKey_RightBracket;
    case 86: return ImGuiKey_Oem102;
    case 43: return ImGuiKey_Backslash;
    case 39: return ImGuiKey_Semicolon;
    case 40: return ImGuiKey_Apostrophe;
    case 51: return ImGuiKey_Comma;
    case 52: return ImGuiKey_Period;
    case 53: return ImGuiKey_Slash;
    }

    return ImGuiKey_None;
}

// Allow compilation with old Windows SDK. MinGW doesn't have default _WIN32_WINNT/WINVER versions.
#ifndef WM_MOUSEHWHEEL
#define WM_MOUSEHWHEEL 0x020E
#endif
#ifndef DBT_DEVNODES_CHANGED
#define DBT_DEVNODES_CHANGED 0x0007
#endif

// Helper to obtain the source of mouse messages.
// See https://learn.microsoft.com/en-us/windows/win32/tablet/system-events-and-mouse-messages
// Prefer to call this at the top of the message handler to avoid the possibility of other Win32 calls interfering with this.
static ImGuiMouseSource ImGui_ImplWin32_GetMouseSourceFromMessageExtraInfo()
{
    LPARAM extra_info = ::GetMessageExtraInfo();
    if ((extra_info & 0xFFFFFF80) == 0xFF515700)
        return ImGuiMouseSource_Pen;
    if ((extra_info & 0xFFFFFF80) == 0xFF515780)
        return ImGuiMouseSource_TouchScreen;
    return ImGuiMouseSource_Mouse;
}

// Win32 message handler (process Win32 mouse/keyboard inputs, etc.)
// Call from your application's message handler. Keep calling your message handler unless this function returns TRUE.
// When implementing your own backend, you can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if Dear ImGui wants to use your inputs.
// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application, or clear/overwrite your copy of the mouse data.
// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application, or clear/overwrite your copy of the keyboard data.
// Generally you may always pass all inputs to Dear ImGui, and hide them from your application based on those two flags.
// PS: We treat DBLCLK messages as regular mouse down messages, so this code will work on windows classes that have the CS_DBLCLKS flag set. Our own example app code doesn't set this flag.

// Copy either line into your .cpp file to forward declare the function:
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);                // Use ImGui::GetCurrentContext()
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandlerEx(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, ImGuiIO& io); // Doesn't use ImGui::GetCurrentContext()

IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    // Most backends don't have silent checks like this one, but we need it because WndProc are called early in CreateWindow().
    // We silently allow both context or just only backend data to be nullptr.
    if (ImGui::GetCurrentContext() == nullptr)
        return 0;
    return ImGui_ImplWin32_WndProcHandlerEx(hwnd, msg, wParam, lParam, ImGui::GetIO());
}

// This version is in theory thread-safe in the sense that no path should access ImGui::GetCurrentContext().
IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandlerEx(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, ImGuiIO& io)
{
    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData(io);
    if (bd == nullptr)
        return 0;
    switch (msg)
    {
    case WM_MOUSEMOVE:
    case WM_NCMOUSEMOVE:
    {
        // We need to call TrackMouseEvent in order to receive WM_MOUSELEAVE events
        ImGuiMouseSource mouse_source = ImGui_ImplWin32_GetMouseSourceFromMessageExtraInfo();
        const int area = (msg == WM_MOUSEMOVE) ? 1 : 2;
        bd->MouseHwnd = hwnd;
        if (bd->MouseTrackedArea != area)
        {
            TRACKMOUSEEVENT tme_cancel = { sizeof(tme_cancel), TME_CANCEL, hwnd, 0 };
            TRACKMOUSEEVENT tme_track = { sizeof(tme_track), (DWORD)((area == 2) ? (TME_LEAVE | TME_NONCLIENT) : TME_LEAVE), hwnd, 0 };
            if (bd->MouseTrackedArea != 0)
                ::TrackMouseEvent(&tme_cancel);
            ::TrackMouseEvent(&tme_track);
            bd->MouseTrackedArea = area;
        }
        POINT mouse_pos = { (LONG)GET_X_LPARAM(lParam), (LONG)GET_Y_LPARAM(lParam) };
        if (msg == WM_NCMOUSEMOVE && ::ScreenToClient(hwnd, &mouse_pos) == FALSE) // WM_NCMOUSEMOVE are provided in absolute coordinates.
            return 0;
        io.AddMouseSourceEvent(mouse_source);
        io.AddMousePosEvent((float)mouse_pos.x, (float)mouse_pos.y);
        return 0;
    }
    case WM_MOUSELEAVE:
    case WM_NCMOUSELEAVE:
    {
        const int area = (msg == WM_MOUSELEAVE) ? 1 : 2;
        if (bd->MouseTrackedArea == area)
        {
            if (bd->MouseHwnd == hwnd)
                bd->MouseHwnd = nullptr;
            bd->MouseTrackedArea = 0;
            io.AddMousePosEvent(-FLT_MAX, -FLT_MAX);
        }
        return 0;
    }
    case WM_DESTROY:
        if (bd->MouseHwnd == hwnd && bd->MouseTrackedArea != 0)
        {
            TRACKMOUSEEVENT tme_cancel = { sizeof(tme_cancel), TME_CANCEL, hwnd, 0 };
            ::TrackMouseEvent(&tme_cancel);
            bd->MouseHwnd = nullptr;
            bd->MouseTrackedArea = 0;
            io.AddMousePosEvent(-FLT_MAX, -FLT_MAX);
        }
        return 0;
    case WM_LBUTTONDOWN: case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN: case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN: case WM_MBUTTONDBLCLK:
    case WM_XBUTTONDOWN: case WM_XBUTTONDBLCLK:
    {
        ImGuiMouseSource mouse_source = ImGui_ImplWin32_GetMouseSourceFromMessageExtraInfo();
        int button = 0;
        if (msg == WM_LBUTTONDOWN || msg == WM_LBUTTONDBLCLK) { button = 0; }
        if (msg == WM_RBUTTONDOWN || msg == WM_RBUTTONDBLCLK) { button = 1; }
        if (msg == WM_MBUTTONDOWN || msg == WM_MBUTTONDBLCLK) { button = 2; }
        if (msg == WM_XBUTTONDOWN || msg == WM_XBUTTONDBLCLK) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 3 : 4; }
        if (bd->MouseButtonsDown == 0 && ::GetCapture() == nullptr)
            ::SetCapture(hwnd); // Allow us to read mouse coordinates when dragging mouse outside of our window bounds.
        bd->MouseButtonsDown |= 1 << button;
        io.AddMouseSourceEvent(mouse_source);
        io.AddMouseButtonEvent(button, true);
        return 0;
    }
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_XBUTTONUP:
    {
        ImGuiMouseSource mouse_source = ImGui_ImplWin32_GetMouseSourceFromMessageExtraInfo();
        int button = 0;
        if (msg == WM_LBUTTONUP) { button = 0; }
        if (msg == WM_RBUTTONUP) { button = 1; }
        if (msg == WM_MBUTTONUP) { button = 2; }
        if (msg == WM_XBUTTONUP) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 3 : 4; }
        bd->MouseButtonsDown &= ~(1 << button);
        if (bd->MouseButtonsDown == 0 && ::GetCapture() == hwnd)
            ::ReleaseCapture();
        io.AddMouseSourceEvent(mouse_source);
        io.AddMouseButtonEvent(button, false);
        return 0;
    }
    case WM_MOUSEWHEEL:
        io.AddMouseWheelEvent(0.0f, (float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA);
        return 0;
    case WM_MOUSEHWHEEL:
        io.AddMouseWheelEvent(-(float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA, 0.0f);
        return 0;
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
    {
        const bool is_key_down = (msg == WM_KEYDOWN || msg == WM_SYSKEYDOWN);
        if (wParam < 256)
        {
            // Submit modifiers
            ImGui_ImplWin32_UpdateKeyModifiers(io);

            // Obtain virtual key code and convert to ImGuiKey
            const ImGuiKey key = ImGui_ImplWin32_KeyEventToImGuiKey(wParam, lParam);
            const int vk = (int)wParam;
            const int scancode = (int)LOBYTE(HIWORD(lParam));

            // Special behavior for VK_SNAPSHOT / ImGuiKey_PrintScreen as Windows doesn't emit the key down event.
            if (key == ImGuiKey_PrintScreen && !is_key_down)
                ImGui_ImplWin32_AddKeyEvent(io, key, true, vk, scancode);

            // Submit key event
            if (key != ImGuiKey_None)
                ImGui_ImplWin32_AddKeyEvent(io, key, is_key_down, vk, scancode);

            // Submit individual left/right modifier events
            if (vk == VK_SHIFT)
            {
                // Important: Shift keys tend to get stuck when pressed together, missing key-up events are corrected in ImGui_ImplWin32_ProcessKeyEventsWorkarounds()
                if (IsVkDown(VK_LSHIFT) == is_key_down) { ImGui_ImplWin32_AddKeyEvent(io, ImGuiKey_LeftShift, is_key_down, VK_LSHIFT, scancode); }
                if (IsVkDown(VK_RSHIFT) == is_key_down) { ImGui_ImplWin32_AddKeyEvent(io, ImGuiKey_RightShift, is_key_down, VK_RSHIFT, scancode); }
            }
            else if (vk == VK_CONTROL)
            {
                if (IsVkDown(VK_LCONTROL) == is_key_down) { ImGui_ImplWin32_AddKeyEvent(io, ImGuiKey_LeftCtrl, is_key_down, VK_LCONTROL, scancode); }
                if (IsVkDown(VK_RCONTROL) == is_key_down) { ImGui_ImplWin32_AddKeyEvent(io, ImGuiKey_RightCtrl, is_key_down, VK_RCONTROL, scancode); }
            }
            else if (vk == VK_MENU)
            {
                if (IsVkDown(VK_LMENU) == is_key_down) { ImGui_ImplWin32_AddKeyEvent(io, ImGuiKey_LeftAlt, is_key_down, VK_LMENU, scancode); }
                if (IsVkDown(VK_RMENU) == is_key_down) { ImGui_ImplWin32_AddKeyEvent(io, ImGuiKey_RightAlt, is_key_down, VK_RMENU, scancode); }
            }
        }
        return 0;
    }
    case WM_SETFOCUS:
    case WM_KILLFOCUS:
        io.AddFocusEvent(msg == WM_SETFOCUS);
        return 0;
    case WM_INPUTLANGCHANGE:
        ImGui_ImplWin32_UpdateKeyboardCodePage(io);
        return 0;
    case WM_CHAR:
        if (::IsWindowUnicode(hwnd))
        {
            // You can also use ToAscii()+GetKeyboardState() to retrieve characters.
            if (wParam > 0 && wParam < 0x10000)
                io.AddInputCharacterUTF16((unsigned short)wParam);
        }
        else
        {
            wchar_t wch = 0;
            ::MultiByteToWideChar(bd->KeyboardCodePage, MB_PRECOMPOSED, (char*)&wParam, 1, &wch, 1);
            io.AddInputCharacter(wch);
        }
        return 0;
    case WM_SETCURSOR:
        // This is required to restore cursor when transitioning from e.g resize borders to client area.
        if (LOWORD(lParam) == HTCLIENT && ImGui_ImplWin32_UpdateMouseCursor(io, bd->LastMouseCursor))
            return 1;
        return 0;
    case WM_DEVICECHANGE:
#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
        if ((UINT)wParam == DBT_DEVNODES_CHANGED)
            bd->WantUpdateHasGamepad = true;
#endif
        return 0;
    }
    return 0;
}


//--------------------------------------------------------------------------------------------------------
// DPI-related helpers (optional)
//--------------------------------------------------------------------------------------------------------
// - Use to enable DPI awareness without having to create an application manifest.
// - Your own app may already do this via a manifest or explicit calls. This is mostly useful for our examples/ apps.
// - In theory we could call simple functions from Windows SDK such as SetProcessDPIAware(), SetProcessDpiAwareness(), etc.
//   but most of the functions provided by Microsoft require Windows 8.1/10+ SDK at compile time and Windows 8/10+ at runtime,
//   neither we want to require the user to have. So we dynamically select and load those functions to avoid dependencies.
//---------------------------------------------------------------------------------------------------------
// This is the scheme successfully used by GLFW (from which we borrowed some of the code) and other apps aiming to be highly portable.
// ImGui_ImplWin32_EnableDpiAwareness() is just a helper called by main.cpp, we don't call it automatically.
// If you are trying to implement your own backend for your own engine, you may ignore that noise.
//---------------------------------------------------------------------------------------------------------

// Perform our own check with RtlVerifyVersionInfo() instead of using functions from <VersionHelpers.h> as they
// require a manifest to be functional for checks above 8.1. See https://github.com/ocornut/imgui/issues/4200
static BOOL _IsWindowsVersionOrGreater(WORD major, WORD minor, WORD)
{
    typedef LONG(WINAPI* PFN_RtlVerifyVersionInfo)(OSVERSIONINFOEXW*, ULONG, ULONGLONG);
    static PFN_RtlVerifyVersionInfo RtlVerifyVersionInfoFn = nullptr;
    if (RtlVerifyVersionInfoFn == nullptr)
        if (HMODULE ntdllModule = ::GetModuleHandleA("ntdll.dll"))
            RtlVerifyVersionInfoFn = (PFN_RtlVerifyVersionInfo)GetProcAddress(ntdllModule, "RtlVerifyVersionInfo");
    if (RtlVerifyVersionInfoFn == nullptr)
        return FALSE;

    RTL_OSVERSIONINFOEXW versionInfo = { };
    ULONGLONG conditionMask = 0;
    versionInfo.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOEXW);
    versionInfo.dwMajorVersion = major;
    versionInfo.dwMinorVersion = minor;
    VER_SET_CONDITION(conditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL);
    VER_SET_CONDITION(conditionMask, VER_MINORVERSION, VER_GREATER_EQUAL);
    return (RtlVerifyVersionInfoFn(&versionInfo, VER_MAJORVERSION | VER_MINORVERSION, conditionMask) == 0) ? TRUE : FALSE;
}

#define _IsWindowsVistaOrGreater()   _IsWindowsVersionOrGreater(HIBYTE(0x0600), LOBYTE(0x0600), 0) // _WIN32_WINNT_VISTA
#define _IsWindows8OrGreater()       _IsWindowsVersionOrGreater(HIBYTE(0x0602), LOBYTE(0x0602), 0) // _WIN32_WINNT_WIN8
#define _IsWindows8Point1OrGreater() _IsWindowsVersionOrGreater(HIBYTE(0x0603), LOBYTE(0x0603), 0) // _WIN32_WINNT_WINBLUE
#define _IsWindows10OrGreater()      _IsWindowsVersionOrGreater(HIBYTE(0x0A00), LOBYTE(0x0A00), 0) // _WIN32_WINNT_WINTHRESHOLD / _WIN32_WINNT_WIN10

#ifndef DPI_ENUMS_DECLARED
typedef enum { PROCESS_DPI_UNAWARE = 0, PROCESS_SYSTEM_DPI_AWARE = 1, PROCESS_PER_MONITOR_DPI_AWARE = 2 } PROCESS_DPI_AWARENESS;
typedef enum { MDT_EFFECTIVE_DPI = 0, MDT_ANGULAR_DPI = 1, MDT_RAW_DPI = 2, MDT_DEFAULT = MDT_EFFECTIVE_DPI } MONITOR_DPI_TYPE;
#endif
#ifndef _DPI_AWARENESS_CONTEXTS_
DECLARE_HANDLE(DPI_AWARENESS_CONTEXT);
#define DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE    (DPI_AWARENESS_CONTEXT)-3
#endif
#ifndef DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2
#define DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 (DPI_AWARENESS_CONTEXT)-4
#endif
typedef HRESULT(WINAPI* PFN_SetProcessDpiAwareness)(PROCESS_DPI_AWARENESS);                     // Shcore.lib + dll, Windows 8.1+
typedef HRESULT(WINAPI* PFN_GetDpiForMonitor)(HMONITOR, MONITOR_DPI_TYPE, UINT*, UINT*);        // Shcore.lib + dll, Windows 8.1+
typedef DPI_AWARENESS_CONTEXT(WINAPI* PFN_SetThreadDpiAwarenessContext)(DPI_AWARENESS_CONTEXT); // User32.lib + dll, Windows 10 v1607+ (Creators Update)

// Helper function to enable DPI awareness without setting up a manifest
void ImGui_ImplWin32_EnableDpiAwareness()
{
    if (_IsWindows10OrGreater())
    {
        static HINSTANCE user32_dll = ::LoadLibraryA("user32.dll"); // Reference counted per-process
        if (PFN_SetThreadDpiAwarenessContext SetThreadDpiAwarenessContextFn = (PFN_SetThreadDpiAwarenessContext)::GetProcAddress(user32_dll, "SetThreadDpiAwarenessContext"))
        {
            SetThreadDpiAwarenessContextFn(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
            return;
        }
    }
    if (_IsWindows8Point1OrGreater())
    {
        static HINSTANCE shcore_dll = ::LoadLibraryA("shcore.dll"); // Reference counted per-process
        if (PFN_SetProcessDpiAwareness SetProcessDpiAwarenessFn = (PFN_SetProcessDpiAwareness)::GetProcAddress(shcore_dll, "SetProcessDpiAwareness"))
        {
            SetProcessDpiAwarenessFn(PROCESS_PER_MONITOR_DPI_AWARE);
            return;
        }
    }
#if _WIN32_WINNT >= 0x0600
    ::SetProcessDPIAware();
#endif
}

#if defined(_MSC_VER) && !defined(NOGDI)
#pragma comment(lib, "gdi32")   // Link with gdi32.lib for GetDeviceCaps(). MinGW will require linking with '-lgdi32'
#endif

float ImGui_ImplWin32_GetDpiScaleForMonitor(void* monitor)
{
    UINT xdpi = 96, ydpi = 96;
    if (_IsWindows8Point1OrGreater())
    {
        static HINSTANCE shcore_dll = ::LoadLibraryA("shcore.dll"); // Reference counted per-process
        static PFN_GetDpiForMonitor GetDpiForMonitorFn = nullptr;
        if (GetDpiForMonitorFn == nullptr && shcore_dll != nullptr)
            GetDpiForMonitorFn = (PFN_GetDpiForMonitor)::GetProcAddress(shcore_dll, "GetDpiForMonitor");
        if (GetDpiForMonitorFn != nullptr)
        {
            GetDpiForMonitorFn((HMONITOR)monitor, MDT_EFFECTIVE_DPI, &xdpi, &ydpi);
            IM_ASSERT(xdpi == ydpi); // Please contact me if you hit this assert!
            return xdpi / 96.0f;
        }
    }
#ifndef NOGDI
    const HDC dc = ::GetDC(nullptr);
    xdpi = ::GetDeviceCaps(dc, LOGPIXELSX);
    ydpi = ::GetDeviceCaps(dc, LOGPIXELSY);
    IM_ASSERT(xdpi == ydpi); // Please contact me if you hit this assert!
    ::ReleaseDC(nullptr, dc);
#endif
    return xdpi / 96.0f;
}

float ImGui_ImplWin32_GetDpiScaleForHwnd(void* hwnd)
{
    HMONITOR monitor = ::MonitorFromWindow((HWND)hwnd, MONITOR_DEFAULTTONEAREST);
    return ImGui_ImplWin32_GetDpiScaleForMonitor(monitor);
}

//---------------------------------------------------------------------------------------------------------
// Transparency related helpers (optional)
//--------------------------------------------------------------------------------------------------------

#if defined(_MSC_VER)
#pragma comment(lib, "dwmapi")  // Link with dwmapi.lib. MinGW will require linking with '-ldwmapi'
#endif

// [experimental]
// Borrowed from GLFW's function updateFramebufferTransparency() in src/win32_window.c
// (the Dwm* functions are Vista era functions but we are borrowing logic from GLFW)
void ImGui_ImplWin32_EnableAlphaCompositing(void* hwnd)
{
    if (!_IsWindowsVistaOrGreater())
        return;

    BOOL composition;
    if (FAILED(::DwmIsCompositionEnabled(&composition)) || !composition)
        return;

    BOOL opaque;
    DWORD color;
    if (_IsWindows8OrGreater() || (SUCCEEDED(::DwmGetColorizationColor(&color, &opaque)) && !opaque))
    {
        HRGN region = ::CreateRectRgn(0, 0, -1, -1);
        DWM_BLURBEHIND bb = {};
        bb.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
        bb.hRgnBlur = region;
        bb.fEnable = TRUE;
        ::DwmEnableBlurBehindWindow((HWND)hwnd, &bb);
        ::DeleteObject(region);
    }
    else
    {
        DWM_BLURBEHIND bb = {};
        bb.dwFlags = DWM_BB_ENABLE;
        ::DwmEnableBlurBehindWindow((HWND)hwnd, &bb);
    }
}

//---------------------------------------------------------------------------------------------------------

#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif
#if defined(__clang__)
#pragma clang diagnostic pop
#endif

#endif // #ifndef IMGUI_DISABLE



================================================
FILE: ImGui/imgui_impl_win32.h
================================================
// dear imgui: Platform Backend for Windows (standard windows API for 32-bits AND 64-bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)
//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen.
//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy VK_* values are obsolete since 1.87 and not supported since 1.91.5]
//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.
//  [X] Platform: Mouse cursor shape and visibility (ImGuiBackendFlags_HasMouseCursors). Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// Learn about Dear ImGui:
// - FAQ                  https://dearimgui.com/faq
// - Getting Started      https://dearimgui.com/getting-started
// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).
// - Introduction, links and more at the top of imgui.cpp

#pragma once
#include "imgui.h"      // IMGUI_IMPL_API
#ifndef IMGUI_DISABLE

// Follow "Getting Started" link and check examples/ folder to learn about using backends!
IMGUI_IMPL_API bool     ImGui_ImplWin32_Init(void* hwnd);
IMGUI_IMPL_API bool     ImGui_ImplWin32_InitForOpenGL(void* hwnd);
IMGUI_IMPL_API void     ImGui_ImplWin32_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplWin32_NewFrame();

// Win32 message handler your application need to call.
// - Intentionally commented out in a '#if 0' block to avoid dragging dependencies on <windows.h> from this helper.
// - You should COPY the line below into your .cpp code to forward declare the function and then you can call it.
// - Call from your application's message handler. Keep calling your message handler unless this function returns TRUE.

#if 0
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
#endif

// DPI-related helpers (optional)
// - Use to enable DPI awareness without having to create an application manifest.
// - Your own app may already do this via a manifest or explicit calls. This is mostly useful for our examples/ apps.
// - In theory we could call simple functions from Windows SDK such as SetProcessDPIAware(), SetProcessDpiAwareness(), etc.
//   but most of the functions provided by Microsoft require Windows 8.1/10+ SDK at compile time and Windows 8/10+ at runtime,
//   neither we want to require the user to have. So we dynamically select and load those functions to avoid dependencies.
IMGUI_IMPL_API void     ImGui_ImplWin32_EnableDpiAwareness();
IMGUI_IMPL_API float    ImGui_ImplWin32_GetDpiScaleForHwnd(void* hwnd);       // HWND hwnd
IMGUI_IMPL_API float    ImGui_ImplWin32_GetDpiScaleForMonitor(void* monitor); // HMONITOR monitor

// Transparency related helpers (optional) [experimental]
// - Use to enable alpha compositing transparency with the desktop.
// - Use together with e.g. clearing your framebuffer with zero-alpha.
IMGUI_IMPL_API void     ImGui_ImplWin32_EnableAlphaCompositing(void* hwnd);   // HWND hwnd

#endif // #ifndef IMGUI_DISABLE



================================================
FILE: ImGui/imgui_tables.cpp
================================================
// dear imgui, v1.91b
// (tables and columns code)

/*

Index of this file:

// [SECTION] Commentary
// [SECTION] Header mess
// [SECTION] Tables: Main code
// [SECTION] Tables: Simple accessors
// [SECTION] Tables: Row changes
// [SECTION] Tables: Columns changes
// [SECTION] Tables: Columns width management
// [SECTION] Tables: Drawing
// [SECTION] Tables: Sorting
// [SECTION] Tables: Headers
// [SECTION] Tables: Context Menu
// [SECTION] Tables: Settings (.ini data)
// [SECTION] Tables: Garbage Collection
// [SECTION] Tables: Debugging
// [SECTION] Columns, BeginColumns, EndColumns, etc.

*/

// Navigating this file:
// - In Visual Studio: CTRL+comma ("Edit.GoToAll") can follow symbols inside comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
// - In Visual Studio w/ Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols inside comments.
// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.

//-----------------------------------------------------------------------------
// [SECTION] Commentary
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Typical tables call flow: (root level is generally public API):
//-----------------------------------------------------------------------------
// - BeginTable()                               user begin into a table
//    | BeginChild()                            - (if ScrollX/ScrollY is set)
//    | TableBeginInitMemory()                  - first time table is used
//    | TableResetSettings()                    - on settings reset
//    | TableLoadSettings()                     - on settings load
//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests
//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)
//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width
// - TableSetupColumn()                         user submit columns details (optional)
// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)
//-----------------------------------------------------------------------------
// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().
//    | TableSetupDrawChannels()                - setup ImDrawList channels
//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission
//    | TableBeginContextMenuPopup()
//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents
//-----------------------------------------------------------------------------
// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)
//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction
//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu
// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)
// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())
//    | TableEndRow()                           - finish existing row
//    | TableBeginRow()                         - add a new row
// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell
//    | TableEndCell()                          - close existing column/cell
//    | TableBeginCell()                        - enter into current column/cell
// - [...]                                      user emit contents
//-----------------------------------------------------------------------------
// - EndTable()                                 user ends the table
//    | TableDrawBorders()                      - draw outer borders, inner vertical borders
//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required
//    | EndChild()                              - (if ScrollX/ScrollY is set)
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// TABLE SIZING
//-----------------------------------------------------------------------------
// (Read carefully because this is subtle but it does make sense!)
//-----------------------------------------------------------------------------
// About 'outer_size':
// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.
// Default value is ImVec2(0.0f, 0.0f).
//   X
//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.
//   - outer_size.x  > 0.0f  ->  Set Fixed width.
//   Y with ScrollX/ScrollY disabled: we output table directly in current window
//   - outer_size.y  < 0.0f  ->  Bottom-align (but will auto extend, unless _NoHostExtendY is set). Not meaningful if parent window can vertically scroll.
//   - outer_size.y  = 0.0f  ->  No minimum height (but will auto extend, unless _NoHostExtendY is set)
//   - outer_size.y  > 0.0f  ->  Set Minimum height (but will auto extend, unless _NoHostExtendY is set)
//   Y with ScrollX/ScrollY enabled: using a child window for scrolling
//   - outer_size.y  < 0.0f  ->  Bottom-align. Not meaningful if parent window can vertically scroll.
//   - outer_size.y  = 0.0f  ->  Bottom-align, consistent with BeginChild(). Not recommended unless table is last item in parent window.
//   - outer_size.y  > 0.0f  ->  Set Exact height. Recommended when using Scrolling on any axis.
//-----------------------------------------------------------------------------
// Outer size is also affected by the NoHostExtendX/NoHostExtendY flags.
// Important to note how the two flags have slightly different behaviors!
//   - ImGuiTableFlags_NoHostExtendX -> Make outer width auto-fit to columns (overriding outer_size.x value). Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.
//   - ImGuiTableFlags_NoHostExtendY -> Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX/ScrollY is disabled. Data below the limit will be clipped and not visible.
// In theory ImGuiTableFlags_NoHostExtendY could be the default and any non-scrolling tables with outer_size.y != 0.0f would use exact height.
// This would be consistent but perhaps less useful and more confusing (as vertically clipped items are not useful and not easily noticeable).
//-----------------------------------------------------------------------------
// About 'inner_width':
//   With ScrollX disabled:
//   - inner_width          ->  *ignored*
//   With ScrollX enabled:
//   - inner_width  < 0.0f  ->  *illegal* fit in known width (right align from outer_size.x) <-- weird
//   - inner_width  = 0.0f  ->  fit in outer_width: Fixed size columns will take space they need (if avail, otherwise shrink down), Stretch columns becomes Fixed columns.
//   - inner_width  > 0.0f  ->  override scrolling width, generally to be larger than outer_size.x. Fixed column take space they need (if avail, otherwise shrink down), Stretch columns share remaining space!
//-----------------------------------------------------------------------------
// Details:
// - If you want to use Stretch columns with ScrollX, you generally need to specify 'inner_width' otherwise the concept
//   of "available space" doesn't make sense.
// - Even if not really useful, we allow 'inner_width < outer_size.x' for consistency and to facilitate understanding
//   of what the value does.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// COLUMNS SIZING POLICIES
// (Reference: ImGuiTableFlags_SizingXXX flags and ImGuiTableColumnFlags_WidthXXX flags)
//-----------------------------------------------------------------------------
// About overriding column sizing policy and width/weight with TableSetupColumn():
// We use a default parameter of -1 for 'init_width'/'init_weight'.
//   - with ImGuiTableColumnFlags_WidthFixed,    init_width  <= 0 (default)  --> width is automatic
//   - with ImGuiTableColumnFlags_WidthFixed,    init_width  >  0 (explicit) --> width is custom
//   - with ImGuiTableColumnFlags_WidthStretch,  init_weight <= 0 (default)  --> weight is 1.0f
//   - with ImGuiTableColumnFlags_WidthStretch,  init_weight >  0 (explicit) --> weight is custom
// Widths are specified _without_ CellPadding. If you specify a width of 100.0f, the column will be cover (100.0f + Padding * 2.0f)
// and you can fit a 100.0f wide item in it without clipping and with padding honored.
//-----------------------------------------------------------------------------
// About default sizing policy (if you don't specify a ImGuiTableColumnFlags_WidthXXXX flag)
//   - with Table policy ImGuiTableFlags_SizingFixedFit      --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is equal to contents width
//   - with Table policy ImGuiTableFlags_SizingFixedSame     --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is max of all contents width
//   - with Table policy ImGuiTableFlags_SizingStretchSame   --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is 1.0f
//   - with Table policy ImGuiTableFlags_SizingStretchWeight --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is proportional to contents
// Default Width and default Weight can be overridden when calling TableSetupColumn().
//-----------------------------------------------------------------------------
// About mixing Fixed/Auto and Stretch columns together:
//   - the typical use of mixing sizing policies is: any number of LEADING Fixed columns, followed by one or two TRAILING Stretch columns.
//   - using mixed policies with ScrollX does not make much sense, as using Stretch columns with ScrollX does not make much sense in the first place!
//     that is, unless 'inner_width' is passed to BeginTable() to explicitly provide a total width to layout columns in.
//   - when using ImGuiTableFlags_SizingFixedSame with mixed columns, only the Fixed/Auto columns will match their widths to the width of the maximum contents.
//   - when using ImGuiTableFlags_SizingStretchSame with mixed columns, only the Stretch columns will match their weights/widths.
//-----------------------------------------------------------------------------
// About using column width:
// If a column is manually resizable or has a width specified with TableSetupColumn():
//   - you may use GetContentRegionAvail().x to query the width available in a given column.
//   - right-side alignment features such as SetNextItemWidth(-x) or PushItemWidth(-x) will rely on this width.
// If the column is not resizable and has no width specified with TableSetupColumn():
//   - its width will be automatic and be set to the max of items submitted.
//   - therefore you generally cannot have ALL items of the columns use e.g. SetNextItemWidth(-FLT_MIN).
//   - but if the column has one or more items of known/fixed size, this will become the reference width used by SetNextItemWidth(-FLT_MIN).
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// TABLES CLIPPING/CULLING
//-----------------------------------------------------------------------------
// About clipping/culling of Rows in Tables:
// - For large numbers of rows, it is recommended you use ImGuiListClipper to submit only visible rows.
//   ImGuiListClipper is reliant on the fact that rows are of equal height.
//   See 'Demo->Tables->Vertical Scrolling' or 'Demo->Tables->Advanced' for a demo of using the clipper.
// - Note that auto-resizing columns don't play well with using the clipper.
//   By default a table with _ScrollX but without _Resizable will have column auto-resize.
//   So, if you want to use the clipper, make sure to either enable _Resizable, either setup columns width explicitly with _WidthFixed.
//-----------------------------------------------------------------------------
// About clipping/culling of Columns in Tables:
// - Both TableSetColumnIndex() and TableNextColumn() return true when the column is visible or performing
//   width measurements. Otherwise, you may skip submitting the contents of a cell/column, BUT ONLY if you know
//   it is not going to contribute to row height.
//   In many situations, you may skip submitting contents for every column but one (e.g. the first one).
// - Case A: column is not hidden by user, and at least partially in sight (most common case).
// - Case B: column is clipped / out of sight (because of scrolling or parent ClipRect): TableNextColumn() return false as a hint but we still allow layout output.
// - Case C: column is hidden explicitly by the user (e.g. via the context menu, or _DefaultHide column flag, etc.).
//
//                        [A]         [B]          [C]
//  TableNextColumn():    true        false        false       -> [userland] when TableNextColumn() / TableSetColumnIndex() returns false, user can skip submitting items but only if the column doesn't contribute to row height.
//          SkipItems:    false       false        true        -> [internal] when SkipItems is true, most widgets will early out if submitted, resulting is no layout output.
//           ClipRect:    normal      zero-width   zero-width  -> [internal] when ClipRect is zero, ItemAdd() will return false and most widgets will early out mid-way.
//  ImDrawList output:    normal      dummy        dummy       -> [internal] when using the dummy channel, ImDrawList submissions (if any) will be wasted (because cliprect is zero-width anyway).
//
// - We need to distinguish those cases because non-hidden columns that are clipped outside of scrolling bounds should still contribute their height to the row.
//   However, in the majority of cases, the contribution to row height is the same for all columns, or the tallest cells are known by the programmer.
//-----------------------------------------------------------------------------
// About clipping/culling of whole Tables:
// - Scrolling tables with a known outer size can be clipped earlier as BeginTable() will return false.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif

#include "imgui.h"
#ifndef IMGUI_DISABLE
#include "imgui_internal.h"

// System includes
#include <stdint.h>     // intptr_t

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127)     // condition expression is constant
#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types
#endif
#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-warning-option"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"                // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wold-style-cast"                 // warning: use of old-style cast                            // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat"                         // warning: format specifies type 'int' but the argument has type 'unsigned int'
#pragma clang diagnostic ignored "-Wformat-nonliteral"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wsign-conversion"                // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
#pragma clang diagnostic ignored "-Wdouble-promotion"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#pragma clang diagnostic ignored "-Wenum-enum-conversion"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')
#pragma clang diagnostic ignored "-Wdeprecated-enum-enum-conversion"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated
#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion"  // warning: implicit conversion from 'xxx' to 'float' may lose precision
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"            // warning: 'xxx' is an unsafe pointer used for buffer access
#pragma clang diagnostic ignored "-Wnontrivial-memaccess"           // warning: first argument in call to 'memset' is a pointer to non-trivially copyable type
#pragma clang diagnostic ignored "-Wswitch-default"                 // warning: 'switch' missing 'default' label
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wpragmas"                          // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wfloat-equal"                      // warning: comparing floating-point with '==' or '!=' is unsafe
#pragma GCC diagnostic ignored "-Wformat-nonliteral"                // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wdouble-promotion"                 // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wformat"                           // warning: format '%p' expects argument of type 'int'/'void*', but argument X has type 'unsigned int'/'ImGuiWindow*'
#pragma GCC diagnostic ignored "-Wstrict-overflow"
#pragma GCC diagnostic ignored "-Wclass-memaccess"                  // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

//-----------------------------------------------------------------------------
// [SECTION] Tables: Main code
//-----------------------------------------------------------------------------
// - TableFixFlags() [Internal]
// - TableFindByID() [Internal]
// - BeginTable()
// - BeginTableEx() [Internal]
// - TableBeginInitMemory() [Internal]
// - TableBeginApplyRequests() [Internal]
// - TableSetupColumnFlags() [Internal]
// - TableUpdateLayout() [Internal]
// - TableUpdateBorders() [Internal]
// - EndTable()
// - TableSetupColumn()
// - TableSetupScrollFreeze()
//-----------------------------------------------------------------------------

// Configuration
static const int TABLE_DRAW_CHANNEL_BG0 = 0;
static const int TABLE_DRAW_CHANNEL_BG2_FROZEN = 1;
static const int TABLE_DRAW_CHANNEL_NOCLIP = 2;                     // When using ImGuiTableFlags_NoClip (this becomes the last visible channel)
static const float TABLE_BORDER_SIZE                     = 1.0f;    // FIXME-TABLE: Currently hard-coded because of clipping assumptions with outer borders rendering.
static const float TABLE_RESIZE_SEPARATOR_HALF_THICKNESS = 4.0f;    // Extend outside inner borders.
static const float TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER = 0.06f;   // Delay/timer before making the hover feedback (color+cursor) visible because tables/columns tends to be more cramped.

// Helper
inline ImGuiTableFlags TableFixFlags(ImGuiTableFlags flags, ImGuiWindow* outer_window)
{
    // Adjust flags: set default sizing policy
    if ((flags & ImGuiTableFlags_SizingMask_) == 0)
        flags |= ((flags & ImGuiTableFlags_ScrollX) || (outer_window->Flags & ImGuiWindowFlags_AlwaysAutoResize)) ? ImGuiTableFlags_SizingFixedFit : ImGuiTableFlags_SizingStretchSame;

    // Adjust flags: enable NoKeepColumnsVisible when using ImGuiTableFlags_SizingFixedSame
    if ((flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)
        flags |= ImGuiTableFlags_NoKeepColumnsVisible;

    // Adjust flags: enforce borders when resizable
    if (flags & ImGuiTableFlags_Resizable)
        flags |= ImGuiTableFlags_BordersInnerV;

    // Adjust flags: disable NoHostExtendX/NoHostExtendY if we have any scrolling going on
    if (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY))
        flags &= ~(ImGuiTableFlags_NoHostExtendX | ImGuiTableFlags_NoHostExtendY);

    // Adjust flags: NoBordersInBodyUntilResize takes priority over NoBordersInBody
    if (flags & ImGuiTableFlags_NoBordersInBodyUntilResize)
        flags &= ~ImGuiTableFlags_NoBordersInBody;

    // Adjust flags: disable saved settings if there's nothing to save
    if ((flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Sortable)) == 0)
        flags |= ImGuiTableFlags_NoSavedSettings;

    // Inherit _NoSavedSettings from top-level window (child windows always have _NoSavedSettings set)
    if (outer_window->RootWindow->Flags & ImGuiWindowFlags_NoSavedSettings)
        flags |= ImGuiTableFlags_NoSavedSettings;

    return flags;
}

ImGuiTable* ImGui::TableFindByID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    return g.Tables.GetByKey(id);
}

// Read about "TABLE SIZING" at the top of this file.
bool    ImGui::BeginTable(const char* str_id, int columns_count, ImGuiTableFlags flags, const ImVec2& outer_size, float inner_width)
{
    ImGuiID id = GetID(str_id);
    return BeginTableEx(str_id, id, columns_count, flags, outer_size, inner_width);
}

bool    ImGui::BeginTableEx(const char* name, ImGuiID id, int columns_count, ImGuiTableFlags flags, const ImVec2& outer_size, float inner_width)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* outer_window = GetCurrentWindow();
    if (outer_window->SkipItems) // Consistent with other tables + beneficial side effect that assert on miscalling EndTable() will be more visible.
        return false;

    // Sanity checks
    IM_ASSERT(columns_count > 0 && columns_count < IMGUI_TABLE_MAX_COLUMNS);
    if (flags & ImGuiTableFlags_ScrollX)
        IM_ASSERT(inner_width >= 0.0f);

    // If an outer size is specified ahead we will be able to early out when not visible. Exact clipping criteria may evolve.
    // FIXME: coarse clipping because access to table data causes two issues:
    // - instance numbers varying/unstable. may not be a direct problem for users, but could make outside access broken or confusing, e.g. TestEngine.
    // - can't implement support for ImGuiChildFlags_ResizeY as we need to somehow pull the height data from somewhere. this also needs stable instance numbers.
    // The side-effects of accessing table data on coarse clip would be:
    // - always reserving the pooled ImGuiTable data ahead for a fully clipped table (minor IMHO). Also the 'outer_window_is_measuring_size' criteria may already be defeating this in some situations.
    // - always performing the GetOrAddByKey() O(log N) query in g.Tables.Map[].
    const bool use_child_window = (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) != 0;
    const ImVec2 avail_size = GetContentRegionAvail();
    const ImVec2 actual_outer_size = ImTrunc(CalcItemSize(outer_size, ImMax(avail_size.x, 1.0f), use_child_window ? ImMax(avail_size.y, 1.0f) : 0.0f));
    const ImRect outer_rect(outer_window->DC.CursorPos, outer_window->DC.CursorPos + actual_outer_size);
    const bool outer_window_is_measuring_size = (outer_window->AutoFitFramesX > 0) || (outer_window->AutoFitFramesY > 0); // Doesn't apply to AlwaysAutoResize windows!
    if (use_child_window && IsClippedEx(outer_rect, 0) && !outer_window_is_measuring_size)
    {
        ItemSize(outer_rect);
        ItemAdd(outer_rect, id);
        g.NextWindowData.ClearFlags();
        return false;
    }

    // [DEBUG] Debug break requested by user
    if (g.DebugBreakInTable == id)
        IM_DEBUG_BREAK();

    // Acquire storage for the table
    ImGuiTable* table = g.Tables.GetOrAddByKey(id);

    // Acquire temporary buffers
    const int table_idx = g.Tables.GetIndex(table);
    if (++g.TablesTempDataStacked > g.TablesTempData.Size)
        g.TablesTempData.resize(g.TablesTempDataStacked, ImGuiTableTempData());
    ImGuiTableTempData* temp_data = table->TempData = &g.TablesTempData[g.TablesTempDataStacked - 1];
    temp_data->TableIndex = table_idx;
    table->DrawSplitter = &table->TempData->DrawSplitter;
    table->DrawSplitter->Clear();

    // Fix flags
    table->IsDefaultSizingPolicy = (flags & ImGuiTableFlags_SizingMask_) == 0;
    flags = TableFixFlags(flags, outer_window);

    // Initialize
    const int previous_frame_active = table->LastFrameActive;
    const int instance_no = (previous_frame_active != g.FrameCount) ? 0 : table->InstanceCurrent + 1;
    const ImGuiTableFlags previous_flags = table->Flags;
    table->ID = id;
    table->Flags = flags;
    table->LastFrameActive = g.FrameCount;
    table->OuterWindow = table->InnerWindow = outer_window;
    table->ColumnsCount = columns_count;
    table->IsLayoutLocked = false;
    table->InnerWidth = inner_width;
    table->NavLayer = (ImS8)outer_window->DC.NavLayerCurrent;
    temp_data->UserOuterSize = outer_size;

    // Instance data (for instance 0, TableID == TableInstanceID)
    ImGuiID instance_id;
    table->InstanceCurrent = (ImS16)instance_no;
    if (instance_no > 0)
    {
        IM_ASSERT(table->ColumnsCount == columns_count && "BeginTable(): Cannot change columns count mid-frame while preserving same ID");
        if (table->InstanceDataExtra.Size < instance_no)
            table->InstanceDataExtra.push_back(ImGuiTableInstanceData());
        instance_id = GetIDWithSeed(instance_no, GetIDWithSeed("##Instances", NULL, id)); // Push "##Instances" followed by (int)instance_no in ID stack.
    }
    else
    {
        instance_id = id;
    }
    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    table_instance->TableInstanceID = instance_id;

    // When not using a child window, WorkRect.Max will grow as we append contents.
    if (use_child_window)
    {
        // Ensure no vertical scrollbar appears if we only want horizontal one, to make flag consistent
        // (we have no other way to disable vertical scrollbar of a window while keeping the horizontal one showing)
        ImVec2 override_content_size(FLT_MAX, FLT_MAX);
        if ((flags & ImGuiTableFlags_ScrollX) && !(flags & ImGuiTableFlags_ScrollY))
            override_content_size.y = FLT_MIN;

        // Ensure specified width (when not specified, Stretched columns will act as if the width == OuterWidth and
        // never lead to any scrolling). We don't handle inner_width < 0.0f, we could potentially use it to right-align
        // based on the right side of the child window work rect, which would require knowing ahead if we are going to
        // have decoration taking horizontal spaces (typically a vertical scrollbar).
        if ((flags & ImGuiTableFlags_ScrollX) && inner_width > 0.0f)
            override_content_size.x = inner_width;

        if (override_content_size.x != FLT_MAX || override_content_size.y != FLT_MAX)
            SetNextWindowContentSize(ImVec2(override_content_size.x != FLT_MAX ? override_content_size.x : 0.0f, override_content_size.y != FLT_MAX ? override_content_size.y : 0.0f));

        // Reset scroll if we are reactivating it
        if ((previous_flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) == 0)
            if ((g.NextWindowData.HasFlags & ImGuiNextWindowDataFlags_HasScroll) == 0)
                SetNextWindowScroll(ImVec2(0.0f, 0.0f));

        // Create scrolling region (without border and zero window padding)
        ImGuiChildFlags child_child_flags = (g.NextWindowData.HasFlags & ImGuiNextWindowDataFlags_HasChildFlags) ? g.NextWindowData.ChildFlags : ImGuiChildFlags_None;
        ImGuiWindowFlags child_window_flags = (g.NextWindowData.HasFlags & ImGuiNextWindowDataFlags_HasWindowFlags) ? g.NextWindowData.WindowFlags : ImGuiWindowFlags_None;
        if (flags & ImGuiTableFlags_ScrollX)
            child_window_flags |= ImGuiWindowFlags_HorizontalScrollbar;
        BeginChildEx(name, instance_id, outer_rect.GetSize(), child_child_flags, child_window_flags);
        table->InnerWindow = g.CurrentWindow;
        table->WorkRect = table->InnerWindow->WorkRect;
        table->OuterRect = table->InnerWindow->Rect();
        table->InnerRect = table->InnerWindow->InnerRect;
        IM_ASSERT(table->InnerWindow->WindowPadding.x == 0.0f && table->InnerWindow->WindowPadding.y == 0.0f && table->InnerWindow->WindowBorderSize == 0.0f);

        // Allow submitting when host is measuring
        if (table->InnerWindow->SkipItems && outer_window_is_measuring_size)
            table->InnerWindow->SkipItems = false;

        // When using multiple instances, ensure they have the same amount of horizontal decorations (aka vertical scrollbar) so stretched columns can be aligned)
        if (instance_no == 0)
        {
            table->HasScrollbarYPrev = table->HasScrollbarYCurr;
            table->HasScrollbarYCurr = false;
        }
        table->HasScrollbarYCurr |= table->InnerWindow->ScrollbarY;
    }
    else
    {
        // For non-scrolling tables, WorkRect == OuterRect == InnerRect.
        // But at this point we do NOT have a correct value for .Max.y (unless a height has been explicitly passed in). It will only be updated in EndTable().
        table->WorkRect = table->OuterRect = table->InnerRect = outer_rect;
        table->HasScrollbarYPrev = table->HasScrollbarYCurr = false;
    }

    // Push a standardized ID for both child-using and not-child-using tables
    PushOverrideID(id);
    if (instance_no > 0)
        PushOverrideID(instance_id); // FIXME: Somehow this is not resolved by stack-tool, even tho GetIDWithSeed() submitted the symbol.

    // Backup a copy of host window members we will modify
    ImGuiWindow* inner_window = table->InnerWindow;
    table->HostIndentX = inner_window->DC.Indent.x;
    table->HostClipRect = inner_window->ClipRect;
    table->HostSkipItems = inner_window->SkipItems;
    temp_data->HostBackupWorkRect = inner_window->WorkRect;
    temp_data->HostBackupParentWorkRect = inner_window->ParentWorkRect;
    temp_data->HostBackupColumnsOffset = outer_window->DC.ColumnsOffset;
    temp_data->HostBackupPrevLineSize = inner_window->DC.PrevLineSize;
    temp_data->HostBackupCurrLineSize = inner_window->DC.CurrLineSize;
    temp_data->HostBackupCursorMaxPos = inner_window->DC.CursorMaxPos;
    temp_data->HostBackupItemWidth = outer_window->DC.ItemWidth;
    temp_data->HostBackupItemWidthStackSize = outer_window->DC.ItemWidthStack.Size;
    inner_window->DC.PrevLineSize = inner_window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);

    // Make borders not overlap our contents by offsetting HostClipRect (#6765, #7428, #3752)
    // (we normally shouldn't alter HostClipRect as we rely on TableMergeDrawChannels() expanding non-clipped column toward the
    // limits of that rectangle, in order for ImDrawListSplitter::Merge() to merge the draw commands. However since the overlap
    // problem only affect scrolling tables in this case we can get away with doing it without extra cost).
    if (inner_window != outer_window)
    {
        // FIXME: Because inner_window's Scrollbar doesn't know about border size, since it's not encoded in window->WindowBorderSize,
        // it already overlaps it and doesn't need an extra offset. Ideally we should be able to pass custom border size with
        // different x/y values to BeginChild().
        if (flags & ImGuiTableFlags_BordersOuterV)
        {
            table->HostClipRect.Min.x = ImMin(table->HostClipRect.Min.x + TABLE_BORDER_SIZE, table->HostClipRect.Max.x);
            if (inner_window->DecoOuterSizeX2 == 0.0f)
                table->HostClipRect.Max.x = ImMax(table->HostClipRect.Max.x - TABLE_BORDER_SIZE, table->HostClipRect.Min.x);
        }
        if (flags & ImGuiTableFlags_BordersOuterH)
        {
            table->HostClipRect.Min.y = ImMin(table->HostClipRect.Min.y + TABLE_BORDER_SIZE, table->HostClipRect.Max.y);
            if (inner_window->DecoOuterSizeY2 == 0.0f)
                table->HostClipRect.Max.y = ImMax(table->HostClipRect.Max.y - TABLE_BORDER_SIZE, table->HostClipRect.Min.y);
        }
    }

    // Padding and Spacing
    // - None               ........Content..... Pad .....Content........
    // - PadOuter           | Pad ..Content..... Pad .....Content.. Pad |
    // - PadInner           ........Content.. Pad | Pad ..Content........
    // - PadOuter+PadInner  | Pad ..Content.. Pad | Pad ..Content.. Pad |
    const bool pad_outer_x = (flags & ImGuiTableFlags_NoPadOuterX) ? false : (flags & ImGuiTableFlags_PadOuterX) ? true : (flags & ImGuiTableFlags_BordersOuterV) != 0;
    const bool pad_inner_x = (flags & ImGuiTableFlags_NoPadInnerX) ? false : true;
    const float inner_spacing_for_border = (flags & ImGuiTableFlags_BordersInnerV) ? TABLE_BORDER_SIZE : 0.0f;
    const float inner_spacing_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) == 0) ? g.Style.CellPadding.x : 0.0f;
    const float inner_padding_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) != 0) ? g.Style.CellPadding.x : 0.0f;
    table->CellSpacingX1 = inner_spacing_explicit + inner_spacing_for_border;
    table->CellSpacingX2 = inner_spacing_explicit;
    table->CellPaddingX = inner_padding_explicit;

    const float outer_padding_for_border = (flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;
    const float outer_padding_explicit = pad_outer_x ? g.Style.CellPadding.x : 0.0f;
    table->OuterPaddingX = (outer_padding_for_border + outer_padding_explicit) - table->CellPaddingX;

    table->CurrentColumn = -1;
    table->CurrentRow = -1;
    table->RowBgColorCounter = 0;
    table->LastRowFlags = ImGuiTableRowFlags_None;
    table->InnerClipRect = (inner_window == outer_window) ? table->WorkRect : inner_window->ClipRect;
    table->InnerClipRect.ClipWith(table->WorkRect);     // We need this to honor inner_width
    table->InnerClipRect.ClipWithFull(table->HostClipRect);
    table->InnerClipRect.Max.y = (flags & ImGuiTableFlags_NoHostExtendY) ? ImMin(table->InnerClipRect.Max.y, inner_window->WorkRect.Max.y) : table->HostClipRect.Max.y;

    table->RowPosY1 = table->RowPosY2 = table->WorkRect.Min.y; // This is needed somehow
    table->RowTextBaseline = 0.0f; // This will be cleared again by TableBeginRow()
    table->RowCellPaddingY = 0.0f;
    table->FreezeRowsRequest = table->FreezeRowsCount = 0; // This will be setup by TableSetupScrollFreeze(), if any
    table->FreezeColumnsRequest = table->FreezeColumnsCount = 0;
    table->IsUnfrozenRows = true;
    table->DeclColumnsCount = table->AngledHeadersCount = 0;
    if (previous_frame_active + 1 < g.FrameCount)
        table->IsActiveIdInTable = false;
    table->AngledHeadersHeight = 0.0f;
    temp_data->AngledHeadersExtraWidth = 0.0f;

    // Using opaque colors facilitate overlapping lines of the grid, otherwise we'd need to improve TableDrawBorders()
    table->BorderColorStrong = GetColorU32(ImGuiCol_TableBorderStrong);
    table->BorderColorLight = GetColorU32(ImGuiCol_TableBorderLight);

    // Make table current
    g.CurrentTable = table;
    outer_window->DC.NavIsScrollPushableX = false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();
    outer_window->DC.CurrentTableIdx = table_idx;
    if (inner_window != outer_window) // So EndChild() within the inner window can restore the table properly.
        inner_window->DC.CurrentTableIdx = table_idx;

    if ((previous_flags & ImGuiTableFlags_Reorderable) && (flags & ImGuiTableFlags_Reorderable) == 0)
        table->IsResetDisplayOrderRequest = true;

    // Mark as used to avoid GC
    if (table_idx >= g.TablesLastTimeActive.Size)
        g.TablesLastTimeActive.resize(table_idx + 1, -1.0f);
    g.TablesLastTimeActive[table_idx] = (float)g.Time;
    temp_data->LastTimeActive = (float)g.Time;
    table->MemoryCompacted = false;

    // Setup memory buffer (clear data if columns count changed)
    ImGuiTableColumn* old_columns_to_preserve = NULL;
    void* old_columns_raw_data = NULL;
    const int old_columns_count = table->Columns.size();
    if (old_columns_count != 0 && old_columns_count != columns_count)
    {
        // Attempt to preserve width on column count change (#4046)
        old_columns_to_preserve = table->Columns.Data;
        old_columns_raw_data = table->RawData;
        table->RawData = NULL;
    }
    if (table->RawData == NULL)
    {
        TableBeginInitMemory(table, columns_count);
        table->IsInitializing = table->IsSettingsRequestLoad = true;
    }
    if (table->IsResetAllRequest)
        TableResetSettings(table);
    if (table->IsInitializing)
    {
        // Initialize
        table->SettingsOffset = -1;
        table->IsSortSpecsDirty = true;
        table->IsSettingsDirty = true; // Records itself into .ini file even when in default state (#7934)
        table->InstanceInteracted = -1;
        table->ContextPopupColumn = -1;
        table->ReorderColumn = table->ResizedColumn = table->LastResizedColumn = -1;
        table->AutoFitSingleColumn = -1;
        table->HoveredColumnBody = table->HoveredColumnBorder = -1;
        for (int n = 0; n < columns_count; n++)
        {
            ImGuiTableColumn* column = &table->Columns[n];
            if (old_columns_to_preserve && n < old_columns_count)
            {
                // FIXME: We don't attempt to preserve column order in this path.
                *column = old_columns_to_preserve[n];
            }
            else
            {
                float width_auto = column->WidthAuto;
                *column = ImGuiTableColumn();
                column->WidthAuto = width_auto;
                column->IsPreserveWidthAuto = true; // Preserve WidthAuto when reinitializing a live table: not technically necessary but remove a visible flicker
                column->IsEnabled = column->IsUserEnabled = column->IsUserEnabledNextFrame = true;
            }
            column->DisplayOrder = table->DisplayOrderToIndex[n] = (ImGuiTableColumnIdx)n;
        }
    }
    if (old_columns_raw_data)
        IM_FREE(old_columns_raw_data);

    // Load settings
    if (table->IsSettingsRequestLoad)
        TableLoadSettings(table);

    // Handle DPI/font resize
    // This is designed to facilitate DPI changes with the assumption that e.g. style.CellPadding has been scaled as well.
    // It will also react to changing fonts with mixed results. It doesn't need to be perfect but merely provide a decent transition.
    // FIXME-DPI: Provide consistent standards for reference size. Perhaps using g.CurrentDpiScale would be more self explanatory.
    // This is will lead us to non-rounded WidthRequest in columns, which should work but is a poorly tested path.
    const float new_ref_scale_unit = g.FontSize; // g.Font->GetCharAdvance('A') ?
    if (table->RefScale != 0.0f && table->RefScale != new_ref_scale_unit)
    {
        const float scale_factor = new_ref_scale_unit / table->RefScale;
        //IMGUI_DEBUG_PRINT("[table] %08X RefScaleUnit %.3f -> %.3f, scaling width by %.3f\n", table->ID, table->RefScaleUnit, new_ref_scale_unit, scale_factor);
        for (int n = 0; n < columns_count; n++)
            table->Columns[n].WidthRequest = table->Columns[n].WidthRequest * scale_factor;
    }
    table->RefScale = new_ref_scale_unit;

    // Disable output until user calls TableNextRow() or TableNextColumn() leading to the TableUpdateLayout() call..
    // This is not strictly necessary but will reduce cases were "out of table" output will be misleading to the user.
    // Because we cannot safely assert in EndTable() when no rows have been created, this seems like our best option.
    inner_window->SkipItems = true;

    // Clear names
    // At this point the ->NameOffset field of each column will be invalid until TableUpdateLayout() or the first call to TableSetupColumn()
    if (table->ColumnsNames.Buf.Size > 0)
        table->ColumnsNames.Buf.resize(0);

    // Apply queued resizing/reordering/hiding requests
    TableBeginApplyRequests(table);

    return true;
}

// For reference, the average total _allocation count_ for a table is:
// + 0 (for ImGuiTable instance, we are pooling allocations in g.Tables[])
// + 1 (for table->RawData allocated below)
// + 1 (for table->ColumnsNames, if names are used)
// Shared allocations for the maximum number of simultaneously nested tables (generally a very small number)
// + 1 (for table->Splitter._Channels)
// + 2 * active_channels_count (for ImDrawCmd and ImDrawIdx buffers inside channels)
// Where active_channels_count is variable but often == columns_count or == columns_count + 1, see TableSetupDrawChannels() for details.
// Unused channels don't perform their +2 allocations.
void ImGui::TableBeginInitMemory(ImGuiTable* table, int columns_count)
{
    // Allocate single buffer for our arrays
    const int columns_bit_array_size = (int)ImBitArrayGetStorageSizeInBytes(columns_count);
    ImSpanAllocator<6> span_allocator;
    span_allocator.Reserve(0, columns_count * sizeof(ImGuiTableColumn));
    span_allocator.Reserve(1, columns_count * sizeof(ImGuiTableColumnIdx));
    span_allocator.Reserve(2, columns_count * sizeof(ImGuiTableCellData), 4);
    for (int n = 3; n < 6; n++)
        span_allocator.Reserve(n, columns_bit_array_size);
    table->RawData = IM_ALLOC(span_allocator.GetArenaSizeInBytes());
    memset(table->RawData, 0, span_allocator.GetArenaSizeInBytes());
    span_allocator.SetArenaBasePtr(table->RawData);
    span_allocator.GetSpan(0, &table->Columns);
    span_allocator.GetSpan(1, &table->DisplayOrderToIndex);
    span_allocator.GetSpan(2, &table->RowCellData);
    table->EnabledMaskByDisplayOrder = (ImU32*)span_allocator.GetSpanPtrBegin(3);
    table->EnabledMaskByIndex = (ImU32*)span_allocator.GetSpanPtrBegin(4);
    table->VisibleMaskByIndex = (ImU32*)span_allocator.GetSpanPtrBegin(5);
}

// Apply queued resizing/reordering/hiding requests
void ImGui::TableBeginApplyRequests(ImGuiTable* table)
{
    // Handle resizing request
    // (We process this in the TableBegin() of the first instance of each table)
    // FIXME-TABLE: Contains columns if our work area doesn't allow for scrolling?
    if (table->InstanceCurrent == 0)
    {
        if (table->ResizedColumn != -1 && table->ResizedColumnNextWidth != FLT_MAX)
            TableSetColumnWidth(table->ResizedColumn, table->ResizedColumnNextWidth);
        table->LastResizedColumn = table->ResizedColumn;
        table->ResizedColumnNextWidth = FLT_MAX;
        table->ResizedColumn = -1;

        // Process auto-fit for single column, which is a special case for stretch columns and fixed columns with FixedSame policy.
        // FIXME-TABLE: Would be nice to redistribute available stretch space accordingly to other weights, instead of giving it all to siblings.
        if (table->AutoFitSingleColumn != -1)
        {
            TableSetColumnWidth(table->AutoFitSingleColumn, table->Columns[table->AutoFitSingleColumn].WidthAuto);
            table->AutoFitSingleColumn = -1;
        }
    }

    // Handle reordering request
    // Note: we don't clear ReorderColumn after handling the request.
    if (table->InstanceCurrent == 0)
    {
        if (table->HeldHeaderColumn == -1 && table->ReorderColumn != -1)
            table->ReorderColumn = -1;
        table->HeldHeaderColumn = -1;
        if (table->ReorderColumn != -1 && table->ReorderColumnDir != 0)
        {
            // We need to handle reordering across hidden columns.
            // In the configuration below, moving C to the right of E will lead to:
            //    ... C [D] E  --->  ... [D] E  C   (Column name/index)
            //    ... 2  3  4        ...  2  3  4   (Display order)
            const int reorder_dir = table->ReorderColumnDir;
            IM_ASSERT(reorder_dir == -1 || reorder_dir == +1);
            IM_ASSERT(table->Flags & ImGuiTableFlags_Reorderable);
            ImGuiTableColumn* src_column = &table->Columns[table->ReorderColumn];
            ImGuiTableColumn* dst_column = &table->Columns[(reorder_dir == -1) ? src_column->PrevEnabledColumn : src_column->NextEnabledColumn];
            IM_UNUSED(dst_column);
            const int src_order = src_column->DisplayOrder;
            const int dst_order = dst_column->DisplayOrder;
            src_column->DisplayOrder = (ImGuiTableColumnIdx)dst_order;
            for (int order_n = src_order + reorder_dir; order_n != dst_order + reorder_dir; order_n += reorder_dir)
                table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder -= (ImGuiTableColumnIdx)reorder_dir;
            IM_ASSERT(dst_column->DisplayOrder == dst_order - reorder_dir);

            // Display order is stored in both columns->IndexDisplayOrder and table->DisplayOrder[]. Rebuild later from the former.
            for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
                table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;
            table->ReorderColumnDir = 0;
            table->IsSettingsDirty = true;
        }
    }

    // Handle display order reset request
    if (table->IsResetDisplayOrderRequest)
    {
        for (int n = 0; n < table->ColumnsCount; n++)
            table->DisplayOrderToIndex[n] = table->Columns[n].DisplayOrder = (ImGuiTableColumnIdx)n;
        table->IsResetDisplayOrderRequest = false;
        table->IsSettingsDirty = true;
    }
}

// Adjust flags: default width mode + stretch columns are not allowed when auto extending
static void TableSetupColumnFlags(ImGuiTable* table, ImGuiTableColumn* column, ImGuiTableColumnFlags flags_in)
{
    ImGuiTableColumnFlags flags = flags_in;

    // Sizing Policy
    if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0)
    {
        const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);
        if (table_sizing_policy == ImGuiTableFlags_SizingFixedFit || table_sizing_policy == ImGuiTableFlags_SizingFixedSame)
            flags |= ImGuiTableColumnFlags_WidthFixed;
        else
            flags |= ImGuiTableColumnFlags_WidthStretch;
    }
    else
    {
        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_WidthMask_)); // Check that only 1 of each set is used.
    }

    // Resize
    if ((table->Flags & ImGuiTableFlags_Resizable) == 0)
        flags |= ImGuiTableColumnFlags_NoResize;

    // Sorting
    if ((flags & ImGuiTableColumnFlags_NoSortAscending) && (flags & ImGuiTableColumnFlags_NoSortDescending))
        flags |= ImGuiTableColumnFlags_NoSort;

    // Indentation
    if ((flags & ImGuiTableColumnFlags_IndentMask_) == 0)
        flags |= (table->Columns.index_from_ptr(column) == 0) ? ImGuiTableColumnFlags_IndentEnable : ImGuiTableColumnFlags_IndentDisable;

    // Alignment
    //if ((flags & ImGuiTableColumnFlags_AlignMask_) == 0)
    //    flags |= ImGuiTableColumnFlags_AlignCenter;
    //IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_AlignMask_)); // Check that only 1 of each set is used.

    // Preserve status flags
    column->Flags = flags | (column->Flags & ImGuiTableColumnFlags_StatusMask_);

    // Build an ordered list of available sort directions
    column->SortDirectionsAvailCount = column->SortDirectionsAvailMask = column->SortDirectionsAvailList = 0;
    if (table->Flags & ImGuiTableFlags_Sortable)
    {
        int count = 0, mask = 0, list = 0;
        if ((flags & ImGuiTableColumnFlags_PreferSortAscending)  != 0 && (flags & ImGuiTableColumnFlags_NoSortAscending)  == 0) { mask |= 1 << ImGuiSortDirection_Ascending;  list |= ImGuiSortDirection_Ascending  << (count << 1); count++; }
        if ((flags & ImGuiTableColumnFlags_PreferSortDescending) != 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) { mask |= 1 << ImGuiSortDirection_Descending; list |= ImGuiSortDirection_Descending << (count << 1); count++; }
        if ((flags & ImGuiTableColumnFlags_PreferSortAscending)  == 0 && (flags & ImGuiTableColumnFlags_NoSortAscending)  == 0) { mask |= 1 << ImGuiSortDirection_Ascending;  list |= ImGuiSortDirection_Ascending  << (count << 1); count++; }
        if ((flags & ImGuiTableColumnFlags_PreferSortDescending) == 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) { mask |= 1 << ImGuiSortDirection_Descending; list |= ImGuiSortDirection_Descending << (count << 1); count++; }
        if ((table->Flags & ImGuiTableFlags_SortTristate) || count == 0) { mask |= 1 << ImGuiSortDirection_None; count++; }
        column->SortDirectionsAvailList = (ImU8)list;
        column->SortDirectionsAvailMask = (ImU8)mask;
        column->SortDirectionsAvailCount = (ImU8)count;
        ImGui::TableFixColumnSortDirection(table, column);
    }
}

// Layout columns for the frame. This is in essence the followup to BeginTable() and this is our largest function.
// Runs on the first call to TableNextRow(), to give a chance for TableSetupColumn() and other TableSetupXXXXX() functions to be called first.
// FIXME-TABLE: Our width (and therefore our WorkRect) will be minimal in the first frame for _WidthAuto columns.
// Increase feedback side-effect with widgets relying on WorkRect.Max.x... Maybe provide a default distribution for _WidthAuto columns?
void ImGui::TableUpdateLayout(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(table->IsLayoutLocked == false);

    const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);
    table->IsDefaultDisplayOrder = true;
    table->ColumnsEnabledCount = 0;
    ImBitArrayClearAllBits(table->EnabledMaskByIndex, table->ColumnsCount);
    ImBitArrayClearAllBits(table->EnabledMaskByDisplayOrder, table->ColumnsCount);
    table->LeftMostEnabledColumn = -1;
    table->MinColumnWidth = ImMax(1.0f, g.Style.FramePadding.x * 1.0f); // g.Style.ColumnsMinSpacing; // FIXME-TABLE

    // [Part 1] Apply/lock Enabled and Order states. Calculate auto/ideal width for columns. Count fixed/stretch columns.
    // Process columns in their visible orders as we are building the Prev/Next indices.
    int count_fixed = 0;                // Number of columns that have fixed sizing policies
    int count_stretch = 0;              // Number of columns that have stretch sizing policies
    int prev_visible_column_idx = -1;
    bool has_auto_fit_request = false;
    bool has_resizable = false;
    float stretch_sum_width_auto = 0.0f;
    float fixed_max_width_auto = 0.0f;
    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
    {
        const int column_n = table->DisplayOrderToIndex[order_n];
        if (column_n != order_n)
            table->IsDefaultDisplayOrder = false;
        ImGuiTableColumn* column = &table->Columns[column_n];

        // Clear column setup if not submitted by user. Currently we make it mandatory to call TableSetupColumn() every frame.
        // It would easily work without but we're not ready to guarantee it since e.g. names need resubmission anyway.
        // We take a slight shortcut but in theory we could be calling TableSetupColumn() here with dummy values, it should yield the same effect.
        if (table->DeclColumnsCount <= column_n)
        {
            TableSetupColumnFlags(table, column, ImGuiTableColumnFlags_None);
            column->NameOffset = -1;
            column->UserID = 0;
            column->InitStretchWeightOrWidth = -1.0f;
        }

        // Update Enabled state, mark settings and sort specs dirty
        if (!(table->Flags & ImGuiTableFlags_Hideable) || (column->Flags & ImGuiTableColumnFlags_NoHide))
            column->IsUserEnabledNextFrame = true;
        if (column->IsUserEnabled != column->IsUserEnabledNextFrame)
        {
            column->IsUserEnabled = column->IsUserEnabledNextFrame;
            table->IsSettingsDirty = true;
        }
        column->IsEnabled = column->IsUserEnabled && (column->Flags & ImGuiTableColumnFlags_Disabled) == 0;

        if (column->SortOrder != -1 && !column->IsEnabled)
            table->IsSortSpecsDirty = true;
        if (column->SortOrder > 0 && !(table->Flags & ImGuiTableFlags_SortMulti))
            table->IsSortSpecsDirty = true;

        // Auto-fit unsized columns
        const bool start_auto_fit = (column->Flags & ImGuiTableColumnFlags_WidthFixed) ? (column->WidthRequest < 0.0f) : (column->StretchWeight < 0.0f);
        if (start_auto_fit)
            column->AutoFitQueue = column->CannotSkipItemsQueue = (1 << 3) - 1; // Fit for three frames

        if (!column->IsEnabled)
        {
            column->IndexWithinEnabledSet = -1;
            continue;
        }

        // Mark as enabled and link to previous/next enabled column
        column->PrevEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;
        column->NextEnabledColumn = -1;
        if (prev_visible_column_idx != -1)
            table->Columns[prev_visible_column_idx].NextEnabledColumn = (ImGuiTableColumnIdx)column_n;
        else
            table->LeftMostEnabledColumn = (ImGuiTableColumnIdx)column_n;
        column->IndexWithinEnabledSet = table->ColumnsEnabledCount++;
        ImBitArraySetBit(table->EnabledMaskByIndex, column_n);
        ImBitArraySetBit(table->EnabledMaskByDisplayOrder, column->DisplayOrder);
        prev_visible_column_idx = column_n;
        IM_ASSERT(column->IndexWithinEnabledSet <= column->DisplayOrder);

        // Calculate ideal/auto column width (that's the width required for all contents to be visible without clipping)
        // Combine width from regular rows + width from headers unless requested not to.
        if (!column->IsPreserveWidthAuto && table->InstanceCurrent == 0)
            column->WidthAuto = TableGetColumnWidthAuto(table, column);

        // Non-resizable columns keep their requested width (apply user value regardless of IsPreserveWidthAuto)
        const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;
        if (column_is_resizable)
            has_resizable = true;
        if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f && !column_is_resizable)
            column->WidthAuto = column->InitStretchWeightOrWidth;

        if (column->AutoFitQueue != 0x00)
            has_auto_fit_request = true;
        if (column->Flags & ImGuiTableColumnFlags_WidthStretch)
        {
            stretch_sum_width_auto += column->WidthAuto;
            count_stretch++;
        }
        else
        {
            fixed_max_width_auto = ImMax(fixed_max_width_auto, column->WidthAuto);
            count_fixed++;
        }
    }
    if ((table->Flags & ImGuiTableFlags_Sortable) && table->SortSpecsCount == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))
        table->IsSortSpecsDirty = true;
    table->RightMostEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;
    IM_ASSERT(table->LeftMostEnabledColumn >= 0 && table->RightMostEnabledColumn >= 0);

    // [Part 2] Disable child window clipping while fitting columns. This is not strictly necessary but makes it possible to avoid
    // the column fitting having to wait until the first visible frame of the child container (may or not be a good thing). Also see #6510.
    // FIXME-TABLE: for always auto-resizing columns may not want to do that all the time.
    if (has_auto_fit_request && table->OuterWindow != table->InnerWindow)
        table->InnerWindow->SkipItems = false;
    if (has_auto_fit_request)
        table->IsSettingsDirty = true;

    // [Part 3] Fix column flags and record a few extra information.
    float sum_width_requests = 0.0f;    // Sum of all width for fixed and auto-resize columns, excluding width contributed by Stretch columns but including spacing/padding.
    float stretch_sum_weights = 0.0f;   // Sum of all weights for stretch columns.
    table->LeftMostStretchedColumn = table->RightMostStretchedColumn = -1;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
            continue;
        ImGuiTableColumn* column = &table->Columns[column_n];

        const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;
        if (column->Flags & ImGuiTableColumnFlags_WidthFixed)
        {
            // Apply same widths policy
            float width_auto = column->WidthAuto;
            if (table_sizing_policy == ImGuiTableFlags_SizingFixedSame && (column->AutoFitQueue != 0x00 || !column_is_resizable))
                width_auto = fixed_max_width_auto;

            // Apply automatic width
            // Latch initial size for fixed columns and update it constantly for auto-resizing column (unless clipped!)
            if (column->AutoFitQueue != 0x00)
                column->WidthRequest = width_auto;
            else if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !column_is_resizable && column->IsRequestOutput)
                column->WidthRequest = width_auto;

            // FIXME-TABLE: Increase minimum size during init frame to avoid biasing auto-fitting widgets
            // (e.g. TextWrapped) too much. Otherwise what tends to happen is that TextWrapped would output a very
            // large height (= first frame scrollbar display very off + clipper would skip lots of items).
            // This is merely making the side-effect less extreme, but doesn't properly fixes it.
            // FIXME: Move this to ->WidthGiven to avoid temporary lossyless?
            // FIXME: This break IsPreserveWidthAuto from not flickering if the stored WidthAuto was smaller.
            if (column->AutoFitQueue > 0x01 && table->IsInitializing && !column->IsPreserveWidthAuto)
                column->WidthRequest = ImMax(column->WidthRequest, table->MinColumnWidth * 4.0f); // FIXME-TABLE: Another constant/scale?
            sum_width_requests += column->WidthRequest;
        }
        else
        {
            // Initialize stretch weight
            if (column->AutoFitQueue != 0x00 || column->StretchWeight < 0.0f || !column_is_resizable)
            {
                if (column->InitStretchWeightOrWidth > 0.0f)
                    column->StretchWeight = column->InitStretchWeightOrWidth;
                else if (table_sizing_policy == ImGuiTableFlags_SizingStretchProp)
                    column->StretchWeight = (column->WidthAuto / stretch_sum_width_auto) * count_stretch;
                else
                    column->StretchWeight = 1.0f;
            }

            stretch_sum_weights += column->StretchWeight;
            if (table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder > column->DisplayOrder)
                table->LeftMostStretchedColumn = (ImGuiTableColumnIdx)column_n;
            if (table->RightMostStretchedColumn == -1 || table->Columns[table->RightMostStretchedColumn].DisplayOrder < column->DisplayOrder)
                table->RightMostStretchedColumn = (ImGuiTableColumnIdx)column_n;
        }
        column->IsPreserveWidthAuto = false;
        sum_width_requests += table->CellPaddingX * 2.0f;
    }
    table->ColumnsEnabledFixedCount = (ImGuiTableColumnIdx)count_fixed;
    table->ColumnsStretchSumWeights = stretch_sum_weights;

    // [Part 4] Apply final widths based on requested widths
    const ImRect work_rect = table->WorkRect;
    const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);
    const float width_removed = (table->HasScrollbarYPrev && !table->InnerWindow->ScrollbarY) ? g.Style.ScrollbarSize : 0.0f; // To synchronize decoration width of synced tables with mismatching scrollbar state (#5920)
    const float width_avail = ImMax(1.0f, (((table->Flags & ImGuiTableFlags_ScrollX) && table->InnerWidth == 0.0f) ? table->InnerClipRect.GetWidth() : work_rect.GetWidth()) - width_removed);
    const float width_avail_for_stretched_columns = width_avail - width_spacings - sum_width_requests;
    float width_remaining_for_stretched_columns = width_avail_for_stretched_columns;
    table->ColumnsGivenWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
            continue;
        ImGuiTableColumn* column = &table->Columns[column_n];

        // Allocate width for stretched/weighted columns (StretchWeight gets converted into WidthRequest)
        if (column->Flags & ImGuiTableColumnFlags_WidthStretch)
        {
            float weight_ratio = column->StretchWeight / stretch_sum_weights;
            column->WidthRequest = IM_TRUNC(ImMax(width_avail_for_stretched_columns * weight_ratio, table->MinColumnWidth) + 0.01f);
            width_remaining_for_stretched_columns -= column->WidthRequest;
        }

        // [Resize Rule 1] The right-most Visible column is not resizable if there is at least one Stretch column
        // See additional comments in TableSetColumnWidth().
        if (column->NextEnabledColumn == -1 && table->LeftMostStretchedColumn != -1)
            column->Flags |= ImGuiTableColumnFlags_NoDirectResize_;

        // Assign final width, record width in case we will need to shrink
        column->WidthGiven = ImTrunc(ImMax(column->WidthRequest, table->MinColumnWidth));
        table->ColumnsGivenWidth += column->WidthGiven;
    }

    // [Part 5] Redistribute stretch remainder width due to rounding (remainder width is < 1.0f * number of Stretch column).
    // Using right-to-left distribution (more likely to match resizing cursor).
    if (width_remaining_for_stretched_columns >= 1.0f && !(table->Flags & ImGuiTableFlags_PreciseWidths))
        for (int order_n = table->ColumnsCount - 1; stretch_sum_weights > 0.0f && width_remaining_for_stretched_columns >= 1.0f && order_n >= 0; order_n--)
        {
            if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
                continue;
            ImGuiTableColumn* column = &table->Columns[table->DisplayOrderToIndex[order_n]];
            if (!(column->Flags & ImGuiTableColumnFlags_WidthStretch))
                continue;
            column->WidthRequest += 1.0f;
            column->WidthGiven += 1.0f;
            width_remaining_for_stretched_columns -= 1.0f;
        }

    // Determine if table is hovered which will be used to flag columns as hovered.
    // - In principle we'd like to use the equivalent of IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),
    //   but because our item is partially submitted at this point we use ItemHoverable() and a workaround (temporarily
    //   clear ActiveId, which is equivalent to the change provided by _AllowWhenBLockedByActiveItem).
    // - This allows columns to be marked as hovered when e.g. clicking a button inside the column, or using drag and drop.
    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    table_instance->HoveredRowLast = table_instance->HoveredRowNext;
    table_instance->HoveredRowNext = -1;
    table->HoveredColumnBody = table->HoveredColumnBorder = -1;
    const ImRect mouse_hit_rect(table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.Max.x, ImMax(table->OuterRect.Max.y, table->OuterRect.Min.y + table_instance->LastOuterHeight));
    const ImGuiID backup_active_id = g.ActiveId;
    g.ActiveId = 0;
    const bool is_hovering_table = ItemHoverable(mouse_hit_rect, 0, ImGuiItemFlags_None);
    g.ActiveId = backup_active_id;

    // Determine skewed MousePos.x to support angled headers.
    float mouse_skewed_x = g.IO.MousePos.x;
    if (table->AngledHeadersHeight > 0.0f)
        if (g.IO.MousePos.y >= table->OuterRect.Min.y && g.IO.MousePos.y <= table->OuterRect.Min.y + table->AngledHeadersHeight)
            mouse_skewed_x += ImTrunc((table->OuterRect.Min.y + table->AngledHeadersHeight - g.IO.MousePos.y) * table->AngledHeadersSlope);

    // [Part 6] Setup final position, offset, skip/clip states and clipping rectangles, detect hovered column
    // Process columns in their visible orders as we are comparing the visible order and adjusting host_clip_rect while looping.
    int visible_n = 0;
    bool has_at_least_one_column_requesting_output = false;
    bool offset_x_frozen = (table->FreezeColumnsCount > 0);
    float offset_x = ((table->FreezeColumnsCount > 0) ? table->OuterRect.Min.x : work_rect.Min.x) + table->OuterPaddingX - table->CellSpacingX1;
    ImRect host_clip_rect = table->InnerClipRect;
    //host_clip_rect.Max.x += table->CellPaddingX + table->CellSpacingX2;
    ImBitArrayClearAllBits(table->VisibleMaskByIndex, table->ColumnsCount);
    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
    {
        const int column_n = table->DisplayOrderToIndex[order_n];
        ImGuiTableColumn* column = &table->Columns[column_n];

        // Initial nav layer: using FreezeRowsCount, NOT FreezeRowsRequest, so Header line changes layer when frozen
        column->NavLayerCurrent = (ImS8)(table->FreezeRowsCount > 0 ? ImGuiNavLayer_Menu : (ImGuiNavLayer)table->NavLayer);

        if (offset_x_frozen && table->FreezeColumnsCount == visible_n)
        {
            offset_x += work_rect.Min.x - table->OuterRect.Min.x;
            offset_x_frozen = false;
        }

        // Clear status flags
        column->Flags &= ~ImGuiTableColumnFlags_StatusMask_;

        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
        {
            // Hidden column: clear a few fields and we are done with it for the remainder of the function.
            // We set a zero-width clip rect but set Min.y/Max.y properly to not interfere with the clipper.
            column->MinX = column->MaxX = column->WorkMinX = column->ClipRect.Min.x = column->ClipRect.Max.x = offset_x;
            column->WidthGiven = 0.0f;
            column->ClipRect.Min.y = work_rect.Min.y;
            column->ClipRect.Max.y = FLT_MAX;
            column->ClipRect.ClipWithFull(host_clip_rect);
            column->IsVisibleX = column->IsVisibleY = column->IsRequestOutput = false;
            column->IsSkipItems = true;
            column->ItemWidth = 1.0f;
            continue;
        }

        // Lock start position
        column->MinX = offset_x;

        // Lock width based on start position and minimum/maximum width for this position
        column->WidthMax = TableCalcMaxColumnWidth(table, column_n);
        column->WidthGiven = ImMin(column->WidthGiven, column->WidthMax);
        column->WidthGiven = ImMax(column->WidthGiven, ImMin(column->WidthRequest, table->MinColumnWidth));
        column->MaxX = offset_x + column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;

        // Lock other positions
        // - ClipRect.Min.x: Because merging draw commands doesn't compare min boundaries, we make ClipRect.Min.x match left bounds to be consistent regardless of merging.
        // - ClipRect.Max.x: using WorkMaxX instead of MaxX (aka including padding) makes things more consistent when resizing down, tho slightly detrimental to visibility in very-small column.
        // - ClipRect.Max.x: using MaxX makes it easier for header to receive hover highlight with no discontinuity and display sorting arrow.
        // - FIXME-TABLE: We want equal width columns to have equal (ClipRect.Max.x - WorkMinX) width, which means ClipRect.max.x cannot stray off host_clip_rect.Max.x else right-most column may appear shorter.
        const float previous_instance_work_min_x = column->WorkMinX;
        column->WorkMinX = column->MinX + table->CellPaddingX + table->CellSpacingX1;
        column->WorkMaxX = column->MaxX - table->CellPaddingX - table->CellSpacingX2; // Expected max
        column->ItemWidth = ImTrunc(column->WidthGiven * 0.65f);
        column->ClipRect.Min.x = column->MinX;
        column->ClipRect.Min.y = work_rect.Min.y;
        column->ClipRect.Max.x = column->MaxX; //column->WorkMaxX;
        column->ClipRect.Max.y = FLT_MAX;
        column->ClipRect.ClipWithFull(host_clip_rect);

        // Mark column as Clipped (not in sight)
        // Note that scrolling tables (where inner_window != outer_window) handle Y clipped earlier in BeginTable() so IsVisibleY really only applies to non-scrolling tables.
        // FIXME-TABLE: Because InnerClipRect.Max.y is conservatively ==outer_window->ClipRect.Max.y, we never can mark columns _Above_ the scroll line as not IsVisibleY.
        // Taking advantage of LastOuterHeight would yield good results there...
        // FIXME-TABLE: Y clipping is disabled because it effectively means not submitting will reduce contents width which is fed to outer_window->DC.CursorMaxPos.x,
        // and this may be used (e.g. typically by outer_window using AlwaysAutoResize or outer_window's horizontal scrollbar, but could be something else).
        // Possible solution to preserve last known content width for clipped column. Test 'table_reported_size' fails when enabling Y clipping and window is resized small.
        column->IsVisibleX = (column->ClipRect.Max.x > column->ClipRect.Min.x);
        column->IsVisibleY = true; // (column->ClipRect.Max.y > column->ClipRect.Min.y);
        const bool is_visible = column->IsVisibleX; //&& column->IsVisibleY;
        if (is_visible)
            ImBitArraySetBit(table->VisibleMaskByIndex, column_n);

        // Mark column as requesting output from user. Note that fixed + non-resizable sets are auto-fitting at all times and therefore always request output.
        column->IsRequestOutput = is_visible || column->AutoFitQueue != 0 || column->CannotSkipItemsQueue != 0;

        // Mark column as SkipItems (ignoring all items/layout)
        // (table->HostSkipItems is a copy of inner_window->SkipItems before we cleared it above in Part 2)
        column->IsSkipItems = !column->IsEnabled || table->HostSkipItems;
        if (column->IsSkipItems)
            IM_ASSERT(!is_visible);
        if (column->IsRequestOutput && !column->IsSkipItems)
            has_at_least_one_column_requesting_output = true;

        // Update status flags
        column->Flags |= ImGuiTableColumnFlags_IsEnabled;
        if (is_visible)
            column->Flags |= ImGuiTableColumnFlags_IsVisible;
        if (column->SortOrder != -1)
            column->Flags |= ImGuiTableColumnFlags_IsSorted;

        // Detect hovered column
        if (is_hovering_table && mouse_skewed_x >= column->ClipRect.Min.x && mouse_skewed_x < column->ClipRect.Max.x)
        {
            column->Flags |= ImGuiTableColumnFlags_IsHovered;
            table->HoveredColumnBody = (ImGuiTableColumnIdx)column_n;
        }

        // Alignment
        // FIXME-TABLE: This align based on the whole column width, not per-cell, and therefore isn't useful in
        // many cases (to be able to honor this we might be able to store a log of cells width, per row, for
        // visible rows, but nav/programmatic scroll would have visible artifacts.)
        //if (column->Flags & ImGuiTableColumnFlags_AlignRight)
        //    column->WorkMinX = ImMax(column->WorkMinX, column->MaxX - column->ContentWidthRowsUnfrozen);
        //else if (column->Flags & ImGuiTableColumnFlags_AlignCenter)
        //    column->WorkMinX = ImLerp(column->WorkMinX, ImMax(column->StartX, column->MaxX - column->ContentWidthRowsUnfrozen), 0.5f);

        // Reset content width variables
        if (table->InstanceCurrent == 0)
        {
            column->ContentMaxXFrozen = column->WorkMinX;
            column->ContentMaxXUnfrozen = column->WorkMinX;
            column->ContentMaxXHeadersUsed = column->WorkMinX;
            column->ContentMaxXHeadersIdeal = column->WorkMinX;
        }
        else
        {
            // As we store an absolute value to make per-cell updates faster, we need to offset values used for width computation.
            const float offset_from_previous_instance = column->WorkMinX - previous_instance_work_min_x;
            column->ContentMaxXFrozen += offset_from_previous_instance;
            column->ContentMaxXUnfrozen += offset_from_previous_instance;
            column->ContentMaxXHeadersUsed += offset_from_previous_instance;
            column->ContentMaxXHeadersIdeal += offset_from_previous_instance;
        }

        // Don't decrement auto-fit counters until container window got a chance to submit its items
        if (table->HostSkipItems == false && table->InstanceCurrent == 0)
        {
            column->AutoFitQueue >>= 1;
            column->CannotSkipItemsQueue >>= 1;
        }

        if (visible_n < table->FreezeColumnsCount)
            host_clip_rect.Min.x = ImClamp(column->MaxX + TABLE_BORDER_SIZE, host_clip_rect.Min.x, host_clip_rect.Max.x);

        offset_x += column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;
        visible_n++;
    }

    // In case the table is visible (e.g. decorations) but all columns clipped, we keep a column visible.
    // Else if give no chance to a clipper-savy user to submit rows and therefore total contents height used by scrollbar.
    if (has_at_least_one_column_requesting_output == false)
    {
        table->Columns[table->LeftMostEnabledColumn].IsRequestOutput = true;
        table->Columns[table->LeftMostEnabledColumn].IsSkipItems = false;
    }

    // [Part 7] Detect/store when we are hovering the unused space after the right-most column (so e.g. context menus can react on it)
    // Clear Resizable flag if none of our column are actually resizable (either via an explicit _NoResize flag, either
    // because of using _WidthAuto/_WidthStretch). This will hide the resizing option from the context menu.
    const float unused_x1 = ImMax(table->WorkRect.Min.x, table->Columns[table->RightMostEnabledColumn].ClipRect.Max.x);
    if (is_hovering_table && table->HoveredColumnBody == -1)
        if (mouse_skewed_x >= unused_x1)
            table->HoveredColumnBody = (ImGuiTableColumnIdx)table->ColumnsCount;
    if (has_resizable == false && (table->Flags & ImGuiTableFlags_Resizable))
        table->Flags &= ~ImGuiTableFlags_Resizable;

    table->IsActiveIdAliveBeforeTable = (g.ActiveIdIsAlive != 0);

    // [Part 8] Lock actual OuterRect/WorkRect right-most position.
    // This is done late to handle the case of fixed-columns tables not claiming more widths that they need.
    // Because of this we are careful with uses of WorkRect and InnerClipRect before this point.
    if (table->RightMostStretchedColumn != -1)
        table->Flags &= ~ImGuiTableFlags_NoHostExtendX;
    if (table->Flags & ImGuiTableFlags_NoHostExtendX)
    {
        table->OuterRect.Max.x = table->WorkRect.Max.x = unused_x1;
        table->InnerClipRect.Max.x = ImMin(table->InnerClipRect.Max.x, unused_x1);
    }
    table->InnerWindow->ParentWorkRect = table->WorkRect;
    table->BorderX1 = table->InnerClipRect.Min.x;
    table->BorderX2 = table->InnerClipRect.Max.x;

    // Setup window's WorkRect.Max.y for GetContentRegionAvail(). Other values will be updated in each TableBeginCell() call.
    float window_content_max_y;
    if (table->Flags & ImGuiTableFlags_NoHostExtendY)
        window_content_max_y = table->OuterRect.Max.y;
    else
        window_content_max_y = ImMax(table->InnerWindow->ContentRegionRect.Max.y, (table->Flags & ImGuiTableFlags_ScrollY) ? 0.0f : table->OuterRect.Max.y);
    table->InnerWindow->WorkRect.Max.y = ImClamp(window_content_max_y - g.Style.CellPadding.y, table->InnerWindow->WorkRect.Min.y, table->InnerWindow->WorkRect.Max.y);

    // [Part 9] Allocate draw channels and setup background cliprect
    TableSetupDrawChannels(table);

    // [Part 10] Hit testing on borders
    if (table->Flags & ImGuiTableFlags_Resizable)
        TableUpdateBorders(table);
    table_instance->LastTopHeadersRowHeight = 0.0f;
    table->IsLayoutLocked = true;
    table->IsUsingHeaders = false;

    // Highlight header
    table->HighlightColumnHeader = -1;
    if (table->IsContextPopupOpen && table->ContextPopupColumn != -1 && table->InstanceInteracted == table->InstanceCurrent)
        table->HighlightColumnHeader = table->ContextPopupColumn;
    else if ((table->Flags & ImGuiTableFlags_HighlightHoveredColumn) && table->HoveredColumnBody != -1 && table->HoveredColumnBody != table->ColumnsCount && table->HoveredColumnBorder == -1)
        if (g.ActiveId == 0 || (table->IsActiveIdInTable || g.DragDropActive))
            table->HighlightColumnHeader = table->HoveredColumnBody;

    // [Part 11] Default context menu
    // - To append to this menu: you can call TableBeginContextMenuPopup()/.../EndPopup().
    // - To modify or replace this: set table->IsContextPopupNoDefaultContents = true, then call TableBeginContextMenuPopup()/.../EndPopup().
    // - You may call TableDrawDefaultContextMenu() with selected flags to display specific sections of the default menu,
    //   e.g. TableDrawDefaultContextMenu(table, table->Flags & ~ImGuiTableFlags_Hideable) will display everything EXCEPT columns visibility options.
    if (table->DisableDefaultContextMenu == false && TableBeginContextMenuPopup(table))
    {
        TableDrawDefaultContextMenu(table, table->Flags);
        EndPopup();
    }

    // [Part 12] Sanitize and build sort specs before we have a chance to use them for display.
    // This path will only be exercised when sort specs are modified before header rows (e.g. init or visibility change)
    if (table->IsSortSpecsDirty && (table->Flags & ImGuiTableFlags_Sortable))
        TableSortSpecsBuild(table);

    // [Part 13] Setup inner window decoration size (for scrolling / nav tracking to properly take account of frozen rows/columns)
    if (table->FreezeColumnsRequest > 0)
        table->InnerWindow->DecoInnerSizeX1 = table->Columns[table->DisplayOrderToIndex[table->FreezeColumnsRequest - 1]].MaxX - table->OuterRect.Min.x;
    if (table->FreezeRowsRequest > 0)
        table->InnerWindow->DecoInnerSizeY1 = table_instance->LastFrozenHeight;
    table_instance->LastFrozenHeight = 0.0f;

    // Initial state
    ImGuiWindow* inner_window = table->InnerWindow;
    if (table->Flags & ImGuiTableFlags_NoClip)
        table->DrawSplitter->SetCurrentChannel(inner_window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);
    else
        inner_window->DrawList->PushClipRect(inner_window->InnerClipRect.Min, inner_window->InnerClipRect.Max, false); // FIXME: use table->InnerClipRect?
}

// Process hit-testing on resizing borders. Actual size change will be applied in EndTable()
// - Set table->HoveredColumnBorder with a short delay/timer to reduce visual feedback noise.
void ImGui::TableUpdateBorders(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(table->Flags & ImGuiTableFlags_Resizable);

    // At this point OuterRect height may be zero or under actual final height, so we rely on temporal coherency and
    // use the final height from last frame. Because this is only affecting _interaction_ with columns, it is not
    // really problematic (whereas the actual visual will be displayed in EndTable() and using the current frame height).
    // Actual columns highlight/render will be performed in EndTable() and not be affected.
    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    const float hit_half_width = ImTrunc(TABLE_RESIZE_SEPARATOR_HALF_THICKNESS * g.CurrentDpiScale);
    const float hit_y1 = (table->FreezeRowsCount >= 1 ? table->OuterRect.Min.y : table->WorkRect.Min.y) + table->AngledHeadersHeight;
    const float hit_y2_body = ImMax(table->OuterRect.Max.y, hit_y1 + table_instance->LastOuterHeight - table->AngledHeadersHeight);
    const float hit_y2_head = hit_y1 + table_instance->LastTopHeadersRowHeight;

    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
    {
        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
            continue;

        const int column_n = table->DisplayOrderToIndex[order_n];
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_))
            continue;

        // ImGuiTableFlags_NoBordersInBodyUntilResize will be honored in TableDrawBorders()
        const float border_y2_hit = (table->Flags & ImGuiTableFlags_NoBordersInBody) ? hit_y2_head : hit_y2_body;
        if ((table->Flags & ImGuiTableFlags_NoBordersInBody) && table->IsUsingHeaders == false)
            continue;

        if (!column->IsVisibleX && table->LastResizedColumn != column_n)
            continue;

        ImGuiID column_id = TableGetColumnResizeID(table, column_n, table->InstanceCurrent);
        ImRect hit_rect(column->MaxX - hit_half_width, hit_y1, column->MaxX + hit_half_width, border_y2_hit);
        ItemAdd(hit_rect, column_id, NULL, ImGuiItemFlags_NoNav);
        //GetForegroundDrawList()->AddRect(hit_rect.Min, hit_rect.Max, IM_COL32(255, 0, 0, 100));

        bool hovered = false, held = false;
        bool pressed = ButtonBehavior(hit_rect, column_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_NoNavFocus);
        if (pressed && IsMouseDoubleClicked(0))
        {
            TableSetColumnWidthAutoSingle(table, column_n);
            ClearActiveID();
            held = false;
        }
        if (held)
        {
            if (table->LastResizedColumn == -1)
                table->ResizeLockMinContentsX2 = table->RightMostEnabledColumn != -1 ? table->Columns[table->RightMostEnabledColumn].MaxX : -FLT_MAX;
            table->ResizedColumn = (ImGuiTableColumnIdx)column_n;
            table->InstanceInteracted = table->InstanceCurrent;
        }
        if ((hovered && g.HoveredIdTimer > TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER) || held)
        {
            table->HoveredColumnBorder = (ImGuiTableColumnIdx)column_n;
            SetMouseCursor(ImGuiMouseCursor_ResizeEW);
        }
    }
}

void    ImGui::EndTable()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (table == NULL)
    {
        IM_ASSERT_USER_ERROR(table != NULL, "EndTable() call should only be done while in BeginTable() scope!");
        return;
    }

    // This assert would be very useful to catch a common error... unfortunately it would probably trigger in some
    // cases, and for consistency user may sometimes output empty tables (and still benefit from e.g. outer border)
    //IM_ASSERT(table->IsLayoutLocked && "Table unused: never called TableNextRow(), is that the intent?");

    // If the user never got to call TableNextRow() or TableNextColumn(), we call layout ourselves to ensure all our
    // code paths are consistent (instead of just hoping that TableBegin/TableEnd will work), get borders drawn, etc.
    if (!table->IsLayoutLocked)
        TableUpdateLayout(table);

    const ImGuiTableFlags flags = table->Flags;
    ImGuiWindow* inner_window = table->InnerWindow;
    ImGuiWindow* outer_window = table->OuterWindow;
    ImGuiTableTempData* temp_data = table->TempData;
    IM_ASSERT(inner_window == g.CurrentWindow);
    IM_ASSERT(outer_window == inner_window || outer_window == inner_window->ParentWindow);

    if (table->IsInsideRow)
        TableEndRow(table);

    // Context menu in columns body
    if (flags & ImGuiTableFlags_ContextMenuInBody)
        if (table->HoveredColumnBody != -1 && !IsAnyItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))
            TableOpenContextMenu((int)table->HoveredColumnBody);

    // Finalize table height
    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    inner_window->DC.PrevLineSize = temp_data->HostBackupPrevLineSize;
    inner_window->DC.CurrLineSize = temp_data->HostBackupCurrLineSize;
    inner_window->DC.CursorMaxPos = temp_data->HostBackupCursorMaxPos;
    const float inner_content_max_y = table->RowPosY2;
    IM_ASSERT(table->RowPosY2 == inner_window->DC.CursorPos.y);
    if (inner_window != outer_window)
        inner_window->DC.CursorMaxPos.y = inner_content_max_y;
    else if (!(flags & ImGuiTableFlags_NoHostExtendY))
        table->OuterRect.Max.y = table->InnerRect.Max.y = ImMax(table->OuterRect.Max.y, inner_content_max_y); // Patch OuterRect/InnerRect height
    table->WorkRect.Max.y = ImMax(table->WorkRect.Max.y, table->OuterRect.Max.y);
    table_instance->LastOuterHeight = table->OuterRect.GetHeight();

    // Setup inner scrolling range
    // FIXME: This ideally should be done earlier, in BeginTable() SetNextWindowContentSize call, just like writing to inner_window->DC.CursorMaxPos.y,
    // but since the later is likely to be impossible to do we'd rather update both axes together.
    if (table->Flags & ImGuiTableFlags_ScrollX)
    {
        const float outer_padding_for_border = (table->Flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;
        float max_pos_x = table->InnerWindow->DC.CursorMaxPos.x;
        if (table->RightMostEnabledColumn != -1)
            max_pos_x = ImMax(max_pos_x, table->Columns[table->RightMostEnabledColumn].WorkMaxX + table->CellPaddingX + table->OuterPaddingX - outer_padding_for_border);
        if (table->ResizedColumn != -1)
            max_pos_x = ImMax(max_pos_x, table->ResizeLockMinContentsX2);
        table->InnerWindow->DC.CursorMaxPos.x = max_pos_x + table->TempData->AngledHeadersExtraWidth;
    }

    // Pop clipping rect
    if (!(flags & ImGuiTableFlags_NoClip))
        inner_window->DrawList->PopClipRect();
    inner_window->ClipRect = inner_window->DrawList->_ClipRectStack.back();

    // Draw borders
    if ((flags & ImGuiTableFlags_Borders) != 0)
        TableDrawBorders(table);

#if 0
    // Strip out dummy channel draw calls
    // We have no way to prevent user submitting direct ImDrawList calls into a hidden column (but ImGui:: calls will be clipped out)
    // Pros: remove draw calls which will have no effect. since they'll have zero-size cliprect they may be early out anyway.
    // Cons: making it harder for users watching metrics/debugger to spot the wasted vertices.
    if (table->DummyDrawChannel != (ImGuiTableColumnIdx)-1)
    {
        ImDrawChannel* dummy_channel = &table->DrawSplitter._Channels[table->DummyDrawChannel];
        dummy_channel->_CmdBuffer.resize(0);
        dummy_channel->_IdxBuffer.resize(0);
    }
#endif

    // Flatten channels and merge draw calls
    ImDrawListSplitter* splitter = table->DrawSplitter;
    splitter->SetCurrentChannel(inner_window->DrawList, 0);
    if ((table->Flags & ImGuiTableFlags_NoClip) == 0)
        TableMergeDrawChannels(table);
    splitter->Merge(inner_window->DrawList);

    // Update ColumnsAutoFitWidth to get us ahead for host using our size to auto-resize without waiting for next BeginTable()
    float auto_fit_width_for_fixed = 0.0f;
    float auto_fit_width_for_stretched = 0.0f;
    float auto_fit_width_for_stretched_min = 0.0f;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
        {
            ImGuiTableColumn* column = &table->Columns[column_n];
            float column_width_request = ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !(column->Flags & ImGuiTableColumnFlags_NoResize)) ? column->WidthRequest : TableGetColumnWidthAuto(table, column);
            if (column->Flags & ImGuiTableColumnFlags_WidthFixed)
                auto_fit_width_for_fixed += column_width_request;
            else
                auto_fit_width_for_stretched += column_width_request;
            if ((column->Flags & ImGuiTableColumnFlags_WidthStretch) && (column->Flags & ImGuiTableColumnFlags_NoResize) != 0)
                auto_fit_width_for_stretched_min = ImMax(auto_fit_width_for_stretched_min, column_width_request / (column->StretchWeight / table->ColumnsStretchSumWeights));
        }
    const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);
    table->ColumnsAutoFitWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount + auto_fit_width_for_fixed + ImMax(auto_fit_width_for_stretched, auto_fit_width_for_stretched_min);

    // Update scroll
    if ((table->Flags & ImGuiTableFlags_ScrollX) == 0 && inner_window != outer_window)
    {
        inner_window->Scroll.x = 0.0f;
    }
    else if (table->LastResizedColumn != -1 && table->ResizedColumn == -1 && inner_window->ScrollbarX && table->InstanceInteracted == table->InstanceCurrent)
    {
        // When releasing a column being resized, scroll to keep the resulting column in sight
        const float neighbor_width_to_keep_visible = table->MinColumnWidth + table->CellPaddingX * 2.0f;
        ImGuiTableColumn* column = &table->Columns[table->LastResizedColumn];
        if (column->MaxX < table->InnerClipRect.Min.x)
            SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x - neighbor_width_to_keep_visible, 1.0f);
        else if (column->MaxX > table->InnerClipRect.Max.x)
            SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x + neighbor_width_to_keep_visible, 1.0f);
    }

    // Apply resizing/dragging at the end of the frame
    if (table->ResizedColumn != -1 && table->InstanceCurrent == table->InstanceInteracted)
    {
        ImGuiTableColumn* column = &table->Columns[table->ResizedColumn];
        const float new_x2 = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + ImTrunc(TABLE_RESIZE_SEPARATOR_HALF_THICKNESS * g.CurrentDpiScale));
        const float new_width = ImTrunc(new_x2 - column->MinX - table->CellSpacingX1 - table->CellPaddingX * 2.0f);
        table->ResizedColumnNextWidth = new_width;
    }

    table->IsActiveIdInTable = (g.ActiveIdIsAlive != 0 && table->IsActiveIdAliveBeforeTable == false);

    // Pop from id stack
    IM_ASSERT_USER_ERROR(inner_window->IDStack.back() == table_instance->TableInstanceID, "Mismatching PushID/PopID!");
    IM_ASSERT_USER_ERROR(outer_window->DC.ItemWidthStack.Size >= temp_data->HostBackupItemWidthStackSize, "Too many PopItemWidth!");
    if (table->InstanceCurrent > 0)
        PopID();
    PopID();

    // Restore window data that we modified
    const ImVec2 backup_outer_max_pos = outer_window->DC.CursorMaxPos;
    inner_window->WorkRect = temp_data->HostBackupWorkRect;
    inner_window->ParentWorkRect = temp_data->HostBackupParentWorkRect;
    inner_window->SkipItems = table->HostSkipItems;
    outer_window->DC.CursorPos = table->OuterRect.Min;
    outer_window->DC.ItemWidth = temp_data->HostBackupItemWidth;
    outer_window->DC.ItemWidthStack.Size = temp_data->HostBackupItemWidthStackSize;
    outer_window->DC.ColumnsOffset = temp_data->HostBackupColumnsOffset;

    // Layout in outer window
    // (FIXME: To allow auto-fit and allow desirable effect of SameLine() we dissociate 'used' vs 'ideal' size by overriding
    // CursorPosPrevLine and CursorMaxPos manually. That should be a more general layout feature, see same problem e.g. #3414)
    if (inner_window != outer_window)
    {
        short backup_nav_layers_active_mask = inner_window->DC.NavLayersActiveMask;
        inner_window->DC.NavLayersActiveMask |= 1 << table->NavLayer; // So empty table don't appear to navigate differently.
        g.CurrentTable = NULL; // To avoid error recovery recursing
        EndChild();
        g.CurrentTable = table;
        inner_window->DC.NavLayersActiveMask = backup_nav_layers_active_mask;
    }
    else
    {
        ItemSize(table->OuterRect.GetSize());
        ItemAdd(table->OuterRect, 0);
    }

    // Override declared contents width/height to enable auto-resize while not needlessly adding a scrollbar
    if (table->Flags & ImGuiTableFlags_NoHostExtendX)
    {
        // FIXME-TABLE: Could we remove this section?
        // ColumnsAutoFitWidth may be one frame ahead here since for Fixed+NoResize is calculated from latest contents
        IM_ASSERT((table->Flags & ImGuiTableFlags_ScrollX) == 0);
        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Min.x + table->ColumnsAutoFitWidth);
    }
    else if (temp_data->UserOuterSize.x <= 0.0f)
    {
        // Some references for this: #7651 + tests "table_reported_size", "table_reported_size_outer" equivalent Y block
        // - Checking for ImGuiTableFlags_ScrollX/ScrollY flag makes us a frame ahead when disabling those flags.
        // - FIXME-TABLE: Would make sense to pre-compute expected scrollbar visibility/sizes to generally save a frame of feedback.
        const float inner_content_max_x = table->OuterRect.Min.x + table->ColumnsAutoFitWidth; // Slightly misleading name but used for code symmetry with inner_content_max_y
        const float decoration_size = table->TempData->AngledHeadersExtraWidth + ((table->Flags & ImGuiTableFlags_ScrollY) ? inner_window->ScrollbarSizes.x : 0.0f);
        outer_window->DC.IdealMaxPos.x = ImMax(outer_window->DC.IdealMaxPos.x, inner_content_max_x + decoration_size - temp_data->UserOuterSize.x);
        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, ImMin(table->OuterRect.Max.x, inner_content_max_x + decoration_size));
    }
    else
    {
        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Max.x);
    }
    if (temp_data->UserOuterSize.y <= 0.0f)
    {
        const float decoration_size = (table->Flags & ImGuiTableFlags_ScrollX) ? inner_window->ScrollbarSizes.y : 0.0f;
        outer_window->DC.IdealMaxPos.y = ImMax(outer_window->DC.IdealMaxPos.y, inner_content_max_y + decoration_size - temp_data->UserOuterSize.y);
        outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, ImMin(table->OuterRect.Max.y, inner_content_max_y + decoration_size));
    }
    else
    {
        // OuterRect.Max.y may already have been pushed downward from the initial value (unless ImGuiTableFlags_NoHostExtendY is set)
        outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, table->OuterRect.Max.y);
    }

    // Save settings
    if (table->IsSettingsDirty)
        TableSaveSettings(table);
    table->IsInitializing = false;

    // Clear or restore current table, if any
    IM_ASSERT(g.CurrentWindow == outer_window && g.CurrentTable == table);
    IM_ASSERT(g.TablesTempDataStacked > 0);
    temp_data = (--g.TablesTempDataStacked > 0) ? &g.TablesTempData[g.TablesTempDataStacked - 1] : NULL;
    g.CurrentTable = temp_data ? g.Tables.GetByIndex(temp_data->TableIndex) : NULL;
    if (g.CurrentTable)
    {
        g.CurrentTable->TempData = temp_data;
        g.CurrentTable->DrawSplitter = &temp_data->DrawSplitter;
    }
    outer_window->DC.CurrentTableIdx = g.CurrentTable ? g.Tables.GetIndex(g.CurrentTable) : -1;
    NavUpdateCurrentWindowIsScrollPushableX();
}

// Called in TableSetupColumn() when initializing and in TableLoadSettings() for defaults before applying stored settings.
// 'init_mask' specify which fields to initialize.
static void TableInitColumnDefaults(ImGuiTable* table, ImGuiTableColumn* column, ImGuiTableColumnFlags init_mask)
{
    ImGuiTableColumnFlags flags = column->Flags;
    if (init_mask & ImGuiTableFlags_Resizable)
    {
        float init_width_or_weight = column->InitStretchWeightOrWidth;
        column->WidthRequest = ((flags & ImGuiTableColumnFlags_WidthFixed) && init_width_or_weight > 0.0f) ? init_width_or_weight : -1.0f;
        column->StretchWeight = (init_width_or_weight > 0.0f && (flags & ImGuiTableColumnFlags_WidthStretch)) ? init_width_or_weight : -1.0f;
        if (init_width_or_weight > 0.0f) // Disable auto-fit if an explicit width/weight has been specified
            column->AutoFitQueue = 0x00;
    }
    if (init_mask & ImGuiTableFlags_Reorderable)
        column->DisplayOrder = (ImGuiTableColumnIdx)table->Columns.index_from_ptr(column);
    if (init_mask & ImGuiTableFlags_Hideable)
        column->IsUserEnabled = column->IsUserEnabledNextFrame = (flags & ImGuiTableColumnFlags_DefaultHide) ? 0 : 1;
    if (init_mask & ImGuiTableFlags_Sortable)
    {
        // Multiple columns using _DefaultSort will be reassigned unique SortOrder values when building the sort specs.
        column->SortOrder = (flags & ImGuiTableColumnFlags_DefaultSort) ? 0 : -1;
        column->SortDirection = (flags & ImGuiTableColumnFlags_DefaultSort) ? ((flags & ImGuiTableColumnFlags_PreferSortDescending) ? (ImS8)ImGuiSortDirection_Descending : (ImU8)(ImGuiSortDirection_Ascending)) : (ImS8)ImGuiSortDirection_None;
    }
}

// See "COLUMNS SIZING POLICIES" comments at the top of this file
// If (init_width_or_weight <= 0.0f) it is ignored
void ImGui::TableSetupColumn(const char* label, ImGuiTableColumnFlags flags, float init_width_or_weight, ImGuiID user_id)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (table == NULL)
    {
        IM_ASSERT_USER_ERROR(table != NULL, "Call should only be done while in BeginTable() scope!");
        return;
    }
    IM_ASSERT(table->IsLayoutLocked == false && "Need to call TableSetupColumn() before first row!");
    IM_ASSERT((flags & ImGuiTableColumnFlags_StatusMask_) == 0 && "Illegal to pass StatusMask values to TableSetupColumn()");
    if (table->DeclColumnsCount >= table->ColumnsCount)
    {
        IM_ASSERT_USER_ERROR(table->DeclColumnsCount < table->ColumnsCount, "Called TableSetupColumn() too many times!");
        return;
    }

    ImGuiTableColumn* column = &table->Columns[table->DeclColumnsCount];
    table->DeclColumnsCount++;

    // Assert when passing a width or weight if policy is entirely left to default, to avoid storing width into weight and vice-versa.
    // Give a grace to users of ImGuiTableFlags_ScrollX.
    if (table->IsDefaultSizingPolicy && (flags & ImGuiTableColumnFlags_WidthMask_) == 0 && (flags & ImGuiTableFlags_ScrollX) == 0)
        IM_ASSERT(init_width_or_weight <= 0.0f && "Can only specify width/weight if sizing policy is set explicitly in either Table or Column.");

    // When passing a width automatically enforce WidthFixed policy
    // (whereas TableSetupColumnFlags would default to WidthAuto if table is not resizable)
    if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0 && init_width_or_weight > 0.0f)
        if ((table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedFit || (table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)
            flags |= ImGuiTableColumnFlags_WidthFixed;
    if (flags & ImGuiTableColumnFlags_AngledHeader)
    {
        flags |= ImGuiTableColumnFlags_NoHeaderLabel;
        table->AngledHeadersCount++;
    }

    TableSetupColumnFlags(table, column, flags);
    column->UserID = user_id;
    flags = column->Flags;

    // Initialize defaults
    column->InitStretchWeightOrWidth = init_width_or_weight;
    if (table->IsInitializing)
    {
        ImGuiTableFlags init_flags = ~table->SettingsLoadedFlags;
        if (column->WidthRequest < 0.0f && column->StretchWeight < 0.0f)
            init_flags |= ImGuiTableFlags_Resizable;
        TableInitColumnDefaults(table, column, init_flags);
    }

    // Store name (append with zero-terminator in contiguous buffer)
    // FIXME: If we recorded the number of \n in names we could compute header row height
    column->NameOffset = -1;
    if (label != NULL && label[0] != 0)
    {
        column->NameOffset = (ImS16)table->ColumnsNames.size();
        table->ColumnsNames.append(label, label + ImStrlen(label) + 1);
    }
}

// [Public]
void ImGui::TableSetupScrollFreeze(int columns, int rows)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (table == NULL)
    {
        IM_ASSERT_USER_ERROR(table != NULL, "Call should only be done while in BeginTable() scope!");
        return;
    }
    IM_ASSERT(table->IsLayoutLocked == false && "Need to call TableSetupColumn() before first row!");
    IM_ASSERT(columns >= 0 && columns < IMGUI_TABLE_MAX_COLUMNS);
    IM_ASSERT(rows >= 0 && rows < 128); // Arbitrary limit

    table->FreezeColumnsRequest = (table->Flags & ImGuiTableFlags_ScrollX) ? (ImGuiTableColumnIdx)ImMin(columns, table->ColumnsCount) : 0;
    table->FreezeColumnsCount = (table->InnerWindow->Scroll.x != 0.0f) ? table->FreezeColumnsRequest : 0;
    table->FreezeRowsRequest = (table->Flags & ImGuiTableFlags_ScrollY) ? (ImGuiTableColumnIdx)rows : 0;
    table->FreezeRowsCount = (table->InnerWindow->Scroll.y != 0.0f) ? table->FreezeRowsRequest : 0;
    table->IsUnfrozenRows = (table->FreezeRowsCount == 0); // Make sure this is set before TableUpdateLayout() so ImGuiListClipper can benefit from it.b

    // Ensure frozen columns are ordered in their section. We still allow multiple frozen columns to be reordered.
    // FIXME-TABLE: This work for preserving 2143 into 21|43. How about 4321 turning into 21|43? (preserve relative order in each section)
    for (int column_n = 0; column_n < table->FreezeColumnsRequest; column_n++)
    {
        int order_n = table->DisplayOrderToIndex[column_n];
        if (order_n != column_n && order_n >= table->FreezeColumnsRequest)
        {
            ImSwap(table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder, table->Columns[table->DisplayOrderToIndex[column_n]].DisplayOrder);
            ImSwap(table->DisplayOrderToIndex[order_n], table->DisplayOrderToIndex[column_n]);
        }
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Tables: Simple accessors
//-----------------------------------------------------------------------------
// - TableGetColumnCount()
// - TableGetColumnName()
// - TableGetColumnName() [Internal]
// - TableSetColumnEnabled()
// - TableGetColumnFlags()
// - TableGetCellBgRect() [Internal]
// - TableGetColumnResizeID() [Internal]
// - TableGetHoveredColumn() [Internal]
// - TableGetHoveredRow() [Internal]
// - TableSetBgColor()
//-----------------------------------------------------------------------------

int ImGui::TableGetColumnCount()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    return table ? table->ColumnsCount : 0;
}

const char* ImGui::TableGetColumnName(int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return NULL;
    if (column_n < 0)
        column_n = table->CurrentColumn;
    return TableGetColumnName(table, column_n);
}

const char* ImGui::TableGetColumnName(const ImGuiTable* table, int column_n)
{
    if (table->IsLayoutLocked == false && column_n >= table->DeclColumnsCount)
        return ""; // NameOffset is invalid at this point
    const ImGuiTableColumn* column = &table->Columns[column_n];
    if (column->NameOffset == -1)
        return "";
    return &table->ColumnsNames.Buf[column->NameOffset];
}

// Change user accessible enabled/disabled state of a column (often perceived as "showing/hiding" from users point of view)
// Note that end-user can use the context menu to change this themselves (right-click in headers, or right-click in columns body with ImGuiTableFlags_ContextMenuInBody)
// - Require table to have the ImGuiTableFlags_Hideable flag because we are manipulating user accessible state.
// - Request will be applied during next layout, which happens on the first call to TableNextRow() after BeginTable().
// - For the getter you can test (TableGetColumnFlags() & ImGuiTableColumnFlags_IsEnabled) != 0.
// - Alternative: the ImGuiTableColumnFlags_Disabled is an overriding/master disable flag which will also hide the column from context menu.
void ImGui::TableSetColumnEnabled(int column_n, bool enabled)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (table == NULL)
    {
        IM_ASSERT_USER_ERROR(table != NULL, "Call should only be done while in BeginTable() scope!");
        return;
    }
    IM_ASSERT(table->Flags & ImGuiTableFlags_Hideable); // See comments above
    if (column_n < 0)
        column_n = table->CurrentColumn;
    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
    ImGuiTableColumn* column = &table->Columns[column_n];
    column->IsUserEnabledNextFrame = enabled;
}

// We allow querying for an extra column in order to poll the IsHovered state of the right-most section
ImGuiTableColumnFlags ImGui::TableGetColumnFlags(int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return ImGuiTableColumnFlags_None;
    if (column_n < 0)
        column_n = table->CurrentColumn;
    if (column_n == table->ColumnsCount)
        return (table->HoveredColumnBody == column_n) ? ImGuiTableColumnFlags_IsHovered : ImGuiTableColumnFlags_None;
    return table->Columns[column_n].Flags;
}

// Return the cell rectangle based on currently known height.
// - Important: we generally don't know our row height until the end of the row, so Max.y will be incorrect in many situations.
//   The only case where this is correct is if we provided a min_row_height to TableNextRow() and don't go below it, or in TableEndRow() when we locked that height.
// - Important: if ImGuiTableFlags_PadOuterX is set but ImGuiTableFlags_PadInnerX is not set, the outer-most left and right
//   columns report a small offset so their CellBgRect can extend up to the outer border.
//   FIXME: But the rendering code in TableEndRow() nullifies that with clamping required for scrolling.
ImRect ImGui::TableGetCellBgRect(const ImGuiTable* table, int column_n)
{
    const ImGuiTableColumn* column = &table->Columns[column_n];
    float x1 = column->MinX;
    float x2 = column->MaxX;
    //if (column->PrevEnabledColumn == -1)
    //    x1 -= table->OuterPaddingX;
    //if (column->NextEnabledColumn == -1)
    //    x2 += table->OuterPaddingX;
    x1 = ImMax(x1, table->WorkRect.Min.x);
    x2 = ImMin(x2, table->WorkRect.Max.x);
    return ImRect(x1, table->RowPosY1, x2, table->RowPosY2);
}

// Return the resizing ID for the right-side of the given column.
ImGuiID ImGui::TableGetColumnResizeID(ImGuiTable* table, int column_n, int instance_no)
{
    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
    ImGuiID instance_id = TableGetInstanceID(table, instance_no);
    return instance_id + 1 + column_n; // FIXME: #6140: still not ideal
}

// Return -1 when table is not hovered. return columns_count if hovering the unused space at the right of the right-most visible column.
int ImGui::TableGetHoveredColumn()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return -1;
    return (int)table->HoveredColumnBody;
}

// Return -1 when table is not hovered. Return maxrow+1 if in table but below last submitted row.
// *IMPORTANT* Unlike TableGetHoveredColumn(), this has a one frame latency in updating the value.
// This difference with is the reason why this is not public yet.
int ImGui::TableGetHoveredRow()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return -1;
    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    return (int)table_instance->HoveredRowLast;
}

void ImGui::TableSetBgColor(ImGuiTableBgTarget target, ImU32 color, int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(target != ImGuiTableBgTarget_None);

    if (color == IM_COL32_DISABLE)
        color = 0;

    // We cannot draw neither the cell or row background immediately as we don't know the row height at this point in time.
    switch (target)
    {
    case ImGuiTableBgTarget_CellBg:
    {
        if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard
            return;
        if (column_n == -1)
            column_n = table->CurrentColumn;
        if (!IM_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))
            return;
        if (table->RowCellDataCurrent < 0 || table->RowCellData[table->RowCellDataCurrent].Column != column_n)
            table->RowCellDataCurrent++;
        ImGuiTableCellData* cell_data = &table->RowCellData[table->RowCellDataCurrent];
        cell_data->BgColor = color;
        cell_data->Column = (ImGuiTableColumnIdx)column_n;
        break;
    }
    case ImGuiTableBgTarget_RowBg0:
    case ImGuiTableBgTarget_RowBg1:
    {
        if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard
            return;
        IM_ASSERT(column_n == -1);
        int bg_idx = (target == ImGuiTableBgTarget_RowBg1) ? 1 : 0;
        table->RowBgColor[bg_idx] = color;
        break;
    }
    default:
        IM_ASSERT(0);
    }
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Row changes
//-------------------------------------------------------------------------
// - TableGetRowIndex()
// - TableNextRow()
// - TableBeginRow() [Internal]
// - TableEndRow() [Internal]
//-------------------------------------------------------------------------

// [Public] Note: for row coloring we use ->RowBgColorCounter which is the same value without counting header rows
int ImGui::TableGetRowIndex()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return 0;
    return table->CurrentRow;
}

// [Public] Starts into the first cell of a new row
void ImGui::TableNextRow(ImGuiTableRowFlags row_flags, float row_min_height)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;

    if (!table->IsLayoutLocked)
        TableUpdateLayout(table);
    if (table->IsInsideRow)
        TableEndRow(table);

    table->LastRowFlags = table->RowFlags;
    table->RowFlags = row_flags;
    table->RowCellPaddingY = g.Style.CellPadding.y;
    table->RowMinHeight = row_min_height;
    TableBeginRow(table);

    // We honor min_row_height requested by user, but cannot guarantee per-row maximum height,
    // because that would essentially require a unique clipping rectangle per-cell.
    table->RowPosY2 += table->RowCellPaddingY * 2.0f;
    table->RowPosY2 = ImMax(table->RowPosY2, table->RowPosY1 + row_min_height);

    // Disable output until user calls TableNextColumn()
    table->InnerWindow->SkipItems = true;
}

// [Internal] Only called by TableNextRow()
void ImGui::TableBeginRow(ImGuiTable* table)
{
    ImGuiWindow* window = table->InnerWindow;
    IM_ASSERT(!table->IsInsideRow);

    // New row
    table->CurrentRow++;
    table->CurrentColumn = -1;
    table->RowBgColor[0] = table->RowBgColor[1] = IM_COL32_DISABLE;
    table->RowCellDataCurrent = -1;
    table->IsInsideRow = true;

    // Begin frozen rows
    float next_y1 = table->RowPosY2;
    if (table->CurrentRow == 0 && table->FreezeRowsCount > 0)
        next_y1 = window->DC.CursorPos.y = table->OuterRect.Min.y;

    table->RowPosY1 = table->RowPosY2 = next_y1;
    table->RowTextBaseline = 0.0f;
    table->RowIndentOffsetX = window->DC.Indent.x - table->HostIndentX; // Lock indent

    window->DC.PrevLineTextBaseOffset = 0.0f;
    window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x, window->DC.CursorPos.y + table->RowCellPaddingY); // This allows users to call SameLine() to share LineSize between columns.
    window->DC.PrevLineSize = window->DC.CurrLineSize = ImVec2(0.0f, 0.0f); // This allows users to call SameLine() to share LineSize between columns, and to call it from first column too.
    window->DC.IsSameLine = window->DC.IsSetPos = false;
    window->DC.CursorMaxPos.y = next_y1;

    // Making the header BG color non-transparent will allow us to overlay it multiple times when handling smooth dragging.
    if (table->RowFlags & ImGuiTableRowFlags_Headers)
    {
        TableSetBgColor(ImGuiTableBgTarget_RowBg0, GetColorU32(ImGuiCol_TableHeaderBg));
        if (table->CurrentRow == 0)
            table->IsUsingHeaders = true;
    }
}

// [Internal] Called by TableNextRow()
void ImGui::TableEndRow(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(window == table->InnerWindow);
    IM_ASSERT(table->IsInsideRow);

    if (table->CurrentColumn != -1)
        TableEndCell(table);

    // Logging
    if (g.LogEnabled)
        LogRenderedText(NULL, "|");

    // Position cursor at the bottom of our row so it can be used for e.g. clipping calculation. However it is
    // likely that the next call to TableBeginCell() will reposition the cursor to take account of vertical padding.
    window->DC.CursorPos.y = table->RowPosY2;

    // Row background fill
    const float bg_y1 = table->RowPosY1;
    const float bg_y2 = table->RowPosY2;
    const bool unfreeze_rows_actual = (table->CurrentRow + 1 == table->FreezeRowsCount);
    const bool unfreeze_rows_request = (table->CurrentRow + 1 == table->FreezeRowsRequest);
    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    if ((table->RowFlags & ImGuiTableRowFlags_Headers) && (table->CurrentRow == 0 || (table->LastRowFlags & ImGuiTableRowFlags_Headers)))
        table_instance->LastTopHeadersRowHeight += bg_y2 - bg_y1;

    const bool is_visible = (bg_y2 >= table->InnerClipRect.Min.y && bg_y1 <= table->InnerClipRect.Max.y);
    if (is_visible)
    {
        // Update data for TableGetHoveredRow()
        if (table->HoveredColumnBody != -1 && g.IO.MousePos.y >= bg_y1 && g.IO.MousePos.y < bg_y2 && table_instance->HoveredRowNext < 0)
            table_instance->HoveredRowNext = table->CurrentRow;

        // Decide of background color for the row
        ImU32 bg_col0 = 0;
        ImU32 bg_col1 = 0;
        if (table->RowBgColor[0] != IM_COL32_DISABLE)
            bg_col0 = table->RowBgColor[0];
        else if (table->Flags & ImGuiTableFlags_RowBg)
            bg_col0 = GetColorU32((table->RowBgColorCounter & 1) ? ImGuiCol_TableRowBgAlt : ImGuiCol_TableRowBg);
        if (table->RowBgColor[1] != IM_COL32_DISABLE)
            bg_col1 = table->RowBgColor[1];

        // Decide of top border color
        ImU32 top_border_col = 0;
        const float border_size = TABLE_BORDER_SIZE;
        if (table->CurrentRow > 0 && (table->Flags & ImGuiTableFlags_BordersInnerH))
            top_border_col = (table->LastRowFlags & ImGuiTableRowFlags_Headers) ? table->BorderColorStrong : table->BorderColorLight;

        const bool draw_cell_bg_color = table->RowCellDataCurrent >= 0;
        const bool draw_strong_bottom_border = unfreeze_rows_actual;
        if ((bg_col0 | bg_col1 | top_border_col) != 0 || draw_strong_bottom_border || draw_cell_bg_color)
        {
            // In theory we could call SetWindowClipRectBeforeSetChannel() but since we know TableEndRow() is
            // always followed by a change of clipping rectangle we perform the smallest overwrite possible here.
            if ((table->Flags & ImGuiTableFlags_NoClip) == 0)
                window->DrawList->_CmdHeader.ClipRect = table->Bg0ClipRectForDrawCmd.ToVec4();
            table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_BG0);
        }

        // Draw row background
        // We soft/cpu clip this so all backgrounds and borders can share the same clipping rectangle
        if (bg_col0 || bg_col1)
        {
            ImRect row_rect(table->WorkRect.Min.x, bg_y1, table->WorkRect.Max.x, bg_y2);
            row_rect.ClipWith(table->BgClipRect);
            if (bg_col0 != 0 && row_rect.Min.y < row_rect.Max.y)
                window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col0);
            if (bg_col1 != 0 && row_rect.Min.y < row_rect.Max.y)
                window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col1);
        }

        // Draw cell background color
        if (draw_cell_bg_color)
        {
            ImGuiTableCellData* cell_data_end = &table->RowCellData[table->RowCellDataCurrent];
            for (ImGuiTableCellData* cell_data = &table->RowCellData[0]; cell_data <= cell_data_end; cell_data++)
            {
                // As we render the BG here we need to clip things (for layout we would not)
                // FIXME: This cancels the OuterPadding addition done by TableGetCellBgRect(), need to keep it while rendering correctly while scrolling.
                const ImGuiTableColumn* column = &table->Columns[cell_data->Column];
                ImRect cell_bg_rect = TableGetCellBgRect(table, cell_data->Column);
                cell_bg_rect.ClipWith(table->BgClipRect);
                cell_bg_rect.Min.x = ImMax(cell_bg_rect.Min.x, column->ClipRect.Min.x);     // So that first column after frozen one gets clipped when scrolling
                cell_bg_rect.Max.x = ImMin(cell_bg_rect.Max.x, column->MaxX);
                if (cell_bg_rect.Min.y < cell_bg_rect.Max.y)
                    window->DrawList->AddRectFilled(cell_bg_rect.Min, cell_bg_rect.Max, cell_data->BgColor);
            }
        }

        // Draw top border
        if (top_border_col && bg_y1 >= table->BgClipRect.Min.y && bg_y1 < table->BgClipRect.Max.y)
            window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y1), ImVec2(table->BorderX2, bg_y1), top_border_col, border_size);

        // Draw bottom border at the row unfreezing mark (always strong)
        if (draw_strong_bottom_border && bg_y2 >= table->BgClipRect.Min.y && bg_y2 < table->BgClipRect.Max.y)
            window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y2), ImVec2(table->BorderX2, bg_y2), table->BorderColorStrong, border_size);
    }

    // End frozen rows (when we are past the last frozen row line, teleport cursor and alter clipping rectangle)
    // We need to do that in TableEndRow() instead of TableBeginRow() so the list clipper can mark end of row and
    // get the new cursor position.
    if (unfreeze_rows_request)
    {
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
            table->Columns[column_n].NavLayerCurrent = table->NavLayer;
        const float y0 = ImMax(table->RowPosY2 + 1, table->InnerClipRect.Min.y);
        table_instance->LastFrozenHeight = y0 - table->OuterRect.Min.y;

        if (unfreeze_rows_actual)
        {
            IM_ASSERT(table->IsUnfrozenRows == false);
            table->IsUnfrozenRows = true;

            // BgClipRect starts as table->InnerClipRect, reduce it now and make BgClipRectForDrawCmd == BgClipRect
            table->BgClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y = ImMin(y0, table->InnerClipRect.Max.y);
            table->BgClipRect.Max.y = table->Bg2ClipRectForDrawCmd.Max.y = table->InnerClipRect.Max.y;
            table->Bg2DrawChannelCurrent = table->Bg2DrawChannelUnfrozen;
            IM_ASSERT(table->Bg2ClipRectForDrawCmd.Min.y <= table->Bg2ClipRectForDrawCmd.Max.y);

            float row_height = table->RowPosY2 - table->RowPosY1;
            table->RowPosY2 = window->DC.CursorPos.y = table->WorkRect.Min.y + table->RowPosY2 - table->OuterRect.Min.y;
            table->RowPosY1 = table->RowPosY2 - row_height;
            for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
            {
                ImGuiTableColumn* column = &table->Columns[column_n];
                column->DrawChannelCurrent = column->DrawChannelUnfrozen;
                column->ClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y;
            }

            // Update cliprect ahead of TableBeginCell() so clipper can access to new ClipRect->Min.y
            SetWindowClipRectBeforeSetChannel(window, table->Columns[0].ClipRect);
            table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Columns[0].DrawChannelCurrent);
        }
    }

    if (!(table->RowFlags & ImGuiTableRowFlags_Headers))
        table->RowBgColorCounter++;
    table->IsInsideRow = false;
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Columns changes
//-------------------------------------------------------------------------
// - TableGetColumnIndex()
// - TableSetColumnIndex()
// - TableNextColumn()
// - TableBeginCell() [Internal]
// - TableEndCell() [Internal]
//-------------------------------------------------------------------------

int ImGui::TableGetColumnIndex()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return 0;
    return table->CurrentColumn;
}

// [Public] Append into a specific column
bool ImGui::TableSetColumnIndex(int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return false;

    if (table->CurrentColumn != column_n)
    {
        if (table->CurrentColumn != -1)
            TableEndCell(table);
        if ((column_n >= 0 && column_n < table->ColumnsCount) == false)
        {
            IM_ASSERT_USER_ERROR(column_n >= 0 && column_n < table->ColumnsCount, "TableSetColumnIndex() invalid column index!");
            return false;
        }
        TableBeginCell(table, column_n);
    }

    // Return whether the column is visible. User may choose to skip submitting items based on this return value,
    // however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
    return table->Columns[column_n].IsRequestOutput;
}

// [Public] Append into the next column, wrap and create a new row when already on last column
bool ImGui::TableNextColumn()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return false;

    if (table->IsInsideRow && table->CurrentColumn + 1 < table->ColumnsCount)
    {
        if (table->CurrentColumn != -1)
            TableEndCell(table);
        TableBeginCell(table, table->CurrentColumn + 1);
    }
    else
    {
        TableNextRow();
        TableBeginCell(table, 0);
    }

    // Return whether the column is visible. User may choose to skip submitting items based on this return value,
    // however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
    return table->Columns[table->CurrentColumn].IsRequestOutput;
}


// [Internal] Called by TableSetColumnIndex()/TableNextColumn()
// This is called very frequently, so we need to be mindful of unnecessary overhead.
// FIXME-TABLE FIXME-OPT: Could probably shortcut some things for non-active or clipped columns.
void ImGui::TableBeginCell(ImGuiTable* table, int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTableColumn* column = &table->Columns[column_n];
    ImGuiWindow* window = table->InnerWindow;
    table->CurrentColumn = column_n;

    // Start position is roughly ~~ CellRect.Min + CellPadding + Indent
    float start_x = column->WorkMinX;
    if (column->Flags & ImGuiTableColumnFlags_IndentEnable)
        start_x += table->RowIndentOffsetX; // ~~ += window.DC.Indent.x - table->HostIndentX, except we locked it for the row.

    window->DC.CursorPos.x = start_x;
    window->DC.CursorPos.y = table->RowPosY1 + table->RowCellPaddingY;
    window->DC.CursorMaxPos.x = window->DC.CursorPos.x;
    window->DC.ColumnsOffset.x = start_x - window->Pos.x - window->DC.Indent.x; // FIXME-WORKRECT
    window->DC.CursorPosPrevLine.x = window->DC.CursorPos.x; // PrevLine.y is preserved. This allows users to call SameLine() to share LineSize between columns.
    window->DC.CurrLineTextBaseOffset = table->RowTextBaseline;
    window->DC.NavLayerCurrent = (ImGuiNavLayer)column->NavLayerCurrent;

    // Note how WorkRect.Max.y is only set once during layout
    window->WorkRect.Min.y = window->DC.CursorPos.y;
    window->WorkRect.Min.x = column->WorkMinX;
    window->WorkRect.Max.x = column->WorkMaxX;
    window->DC.ItemWidth = column->ItemWidth;

    window->SkipItems = column->IsSkipItems;
    if (column->IsSkipItems)
    {
        g.LastItemData.ID = 0;
        g.LastItemData.StatusFlags = 0;
    }

    if (table->Flags & ImGuiTableFlags_NoClip)
    {
        // FIXME: if we end up drawing all borders/bg in EndTable, could remove this and just assert that channel hasn't changed.
        table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);
        //IM_ASSERT(table->DrawSplitter._Current == TABLE_DRAW_CHANNEL_NOCLIP);
    }
    else
    {
        // FIXME-TABLE: Could avoid this if draw channel is dummy channel?
        SetWindowClipRectBeforeSetChannel(window, column->ClipRect);
        table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);
    }

    // Logging
    if (g.LogEnabled && !column->IsSkipItems)
    {
        LogRenderedText(&window->DC.CursorPos, "|");
        g.LogLinePosY = FLT_MAX;
    }
}

// [Internal] Called by TableNextRow()/TableSetColumnIndex()/TableNextColumn()
void ImGui::TableEndCell(ImGuiTable* table)
{
    ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];
    ImGuiWindow* window = table->InnerWindow;

    if (window->DC.IsSetPos)
        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();

    // Report maximum position so we can infer content size per column.
    float* p_max_pos_x;
    if (table->RowFlags & ImGuiTableRowFlags_Headers)
        p_max_pos_x = &column->ContentMaxXHeadersUsed;  // Useful in case user submit contents in header row that is not a TableHeader() call
    else
        p_max_pos_x = table->IsUnfrozenRows ? &column->ContentMaxXUnfrozen : &column->ContentMaxXFrozen;
    *p_max_pos_x = ImMax(*p_max_pos_x, window->DC.CursorMaxPos.x);
    if (column->IsEnabled)
        table->RowPosY2 = ImMax(table->RowPosY2, window->DC.CursorMaxPos.y + table->RowCellPaddingY);
    column->ItemWidth = window->DC.ItemWidth;

    // Propagate text baseline for the entire row
    // FIXME-TABLE: Here we propagate text baseline from the last line of the cell.. instead of the first one.
    table->RowTextBaseline = ImMax(table->RowTextBaseline, window->DC.PrevLineTextBaseOffset);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Columns width management
//-------------------------------------------------------------------------
// - TableGetMaxColumnWidth() [Internal]
// - TableGetColumnWidthAuto() [Internal]
// - TableSetColumnWidth()
// - TableSetColumnWidthAutoSingle() [Internal]
// - TableSetColumnWidthAutoAll() [Internal]
// - TableUpdateColumnsWeightFromWidth() [Internal]
//-------------------------------------------------------------------------
// Note that actual columns widths are computed in TableUpdateLayout().
//-------------------------------------------------------------------------

// Maximum column content width given current layout. Use column->MinX so this value differs on a per-column basis.
float ImGui::TableCalcMaxColumnWidth(const ImGuiTable* table, int column_n)
{
    const ImGuiTableColumn* column = &table->Columns[column_n];
    float max_width = FLT_MAX;
    const float min_column_distance = table->MinColumnWidth + table->CellPaddingX * 2.0f + table->CellSpacingX1 + table->CellSpacingX2;
    if (table->Flags & ImGuiTableFlags_ScrollX)
    {
        // Frozen columns can't reach beyond visible width else scrolling will naturally break.
        // (we use DisplayOrder as within a set of multiple frozen column reordering is possible)
        if (column->DisplayOrder < table->FreezeColumnsRequest)
        {
            max_width = (table->InnerClipRect.Max.x - (table->FreezeColumnsRequest - column->DisplayOrder) * min_column_distance) - column->MinX;
            max_width = max_width - table->OuterPaddingX - table->CellPaddingX - table->CellSpacingX2;
        }
    }
    else if ((table->Flags & ImGuiTableFlags_NoKeepColumnsVisible) == 0)
    {
        // If horizontal scrolling if disabled, we apply a final lossless shrinking of columns in order to make
        // sure they are all visible. Because of this we also know that all of the columns will always fit in
        // table->WorkRect and therefore in table->InnerRect (because ScrollX is off)
        // FIXME-TABLE: This is solved incorrectly but also quite a difficult problem to fix as we also want ClipRect width to match.
        // See "table_width_distrib" and "table_width_keep_visible" tests
        max_width = table->WorkRect.Max.x - (table->ColumnsEnabledCount - column->IndexWithinEnabledSet - 1) * min_column_distance - column->MinX;
        //max_width -= table->CellSpacingX1;
        max_width -= table->CellSpacingX2;
        max_width -= table->CellPaddingX * 2.0f;
        max_width -= table->OuterPaddingX;
    }
    return max_width;
}

// Note this is meant to be stored in column->WidthAuto, please generally use the WidthAuto field
float ImGui::TableGetColumnWidthAuto(ImGuiTable* table, ImGuiTableColumn* column)
{
    const float content_width_body = ImMax(column->ContentMaxXFrozen, column->ContentMaxXUnfrozen) - column->WorkMinX;
    const float content_width_headers = column->ContentMaxXHeadersIdeal - column->WorkMinX;
    float width_auto = content_width_body;
    if (!(column->Flags & ImGuiTableColumnFlags_NoHeaderWidth))
        width_auto = ImMax(width_auto, content_width_headers);

    // Non-resizable fixed columns preserve their requested width
    if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f)
        if (!(table->Flags & ImGuiTableFlags_Resizable) || (column->Flags & ImGuiTableColumnFlags_NoResize))
            width_auto = column->InitStretchWeightOrWidth;

    return ImMax(width_auto, table->MinColumnWidth);
}

// 'width' = inner column width, without padding
void ImGui::TableSetColumnWidth(int column_n, float width)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL && table->IsLayoutLocked == false);
    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
    ImGuiTableColumn* column_0 = &table->Columns[column_n];
    float column_0_width = width;

    // Apply constraints early
    // Compare both requested and actual given width to avoid overwriting requested width when column is stuck (minimum size, bounded)
    IM_ASSERT(table->MinColumnWidth > 0.0f);
    const float min_width = table->MinColumnWidth;
    const float max_width = ImMax(min_width, column_0->WidthMax); // Don't use TableCalcMaxColumnWidth() here as it would rely on MinX from last instance (#7933)
    column_0_width = ImClamp(column_0_width, min_width, max_width);
    if (column_0->WidthGiven == column_0_width || column_0->WidthRequest == column_0_width)
        return;

    //IMGUI_DEBUG_PRINT("TableSetColumnWidth(%d, %.1f->%.1f)\n", column_0_idx, column_0->WidthGiven, column_0_width);
    ImGuiTableColumn* column_1 = (column_0->NextEnabledColumn != -1) ? &table->Columns[column_0->NextEnabledColumn] : NULL;

    // In this surprisingly not simple because of how we support mixing Fixed and multiple Stretch columns.
    // - All fixed: easy.
    // - All stretch: easy.
    // - One or more fixed + one stretch: easy.
    // - One or more fixed + more than one stretch: tricky.
    // Qt when manual resize is enabled only supports a single _trailing_ stretch column, we support more cases here.

    // When forwarding resize from Wn| to Fn+1| we need to be considerate of the _NoResize flag on Fn+1.
    // FIXME-TABLE: Find a way to rewrite all of this so interactions feel more consistent for the user.
    // Scenarios:
    // - F1 F2 F3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. Subsequent columns will be offset.
    // - F1 F2 F3  resize from F3|          --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered.
    // - F1 F2 W3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered, but it doesn't make much sense as the Stretch column will always be minimal size.
    // - F1 F2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
    // - W1 W2 W3  resize from W1| or W2|   --> ok
    // - W1 W2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
    // - W1 F2 F3  resize from F3|          --> ok: no-op (disabled by Resize Rule 1)
    // - W1 F2     resize from F2|          --> ok: no-op (disabled by Resize Rule 1)
    // - W1 W2 F3  resize from W1| or W2|   --> ok
    // - W1 F2 W3  resize from W1| or F2|   --> ok
    // - F1 W2 F3  resize from W2|          --> ok
    // - F1 W3 F2  resize from W3|          --> ok
    // - W1 F2 F3  resize from W1|          --> ok: equivalent to resizing |F2. F3 will not move.
    // - W1 F2 F3  resize from F2|          --> ok
    // All resizes from a Wx columns are locking other columns.

    // Possible improvements:
    // - W1 W2 W3  resize W1|               --> to not be stuck, both W2 and W3 would stretch down. Seems possible to fix. Would be most beneficial to simplify resize of all-weighted columns.
    // - W3 F1 F2  resize W3|               --> to not be stuck past F1|, both F1 and F2 would need to stretch down, which would be lossy or ambiguous. Seems hard to fix.

    // [Resize Rule 1] Can't resize from right of right-most visible column if there is any Stretch column. Implemented in TableUpdateLayout().

    // If we have all Fixed columns OR resizing a Fixed column that doesn't come after a Stretch one, we can do an offsetting resize.
    // This is the preferred resize path
    if (column_0->Flags & ImGuiTableColumnFlags_WidthFixed)
        if (!column_1 || table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder >= column_0->DisplayOrder)
        {
            column_0->WidthRequest = column_0_width;
            table->IsSettingsDirty = true;
            return;
        }

    // We can also use previous column if there's no next one (this is used when doing an auto-fit on the right-most stretch column)
    if (column_1 == NULL)
        column_1 = (column_0->PrevEnabledColumn != -1) ? &table->Columns[column_0->PrevEnabledColumn] : NULL;
    if (column_1 == NULL)
        return;

    // Resizing from right-side of a Stretch column before a Fixed column forward sizing to left-side of fixed column.
    // (old_a + old_b == new_a + new_b) --> (new_a == old_a + old_b - new_b)
    float column_1_width = ImMax(column_1->WidthRequest - (column_0_width - column_0->WidthRequest), min_width);
    column_0_width = column_0->WidthRequest + column_1->WidthRequest - column_1_width;
    IM_ASSERT(column_0_width > 0.0f && column_1_width > 0.0f);
    column_0->WidthRequest = column_0_width;
    column_1->WidthRequest = column_1_width;
    if ((column_0->Flags | column_1->Flags) & ImGuiTableColumnFlags_WidthStretch)
        TableUpdateColumnsWeightFromWidth(table);
    table->IsSettingsDirty = true;
}

// Disable clipping then auto-fit, will take 2 frames
// (we don't take a shortcut for unclipped columns to reduce inconsistencies when e.g. resizing multiple columns)
void ImGui::TableSetColumnWidthAutoSingle(ImGuiTable* table, int column_n)
{
    // Single auto width uses auto-fit
    ImGuiTableColumn* column = &table->Columns[column_n];
    if (!column->IsEnabled)
        return;
    column->CannotSkipItemsQueue = (1 << 0);
    table->AutoFitSingleColumn = (ImGuiTableColumnIdx)column_n;
}

void ImGui::TableSetColumnWidthAutoAll(ImGuiTable* table)
{
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (!column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_WidthStretch)) // Cannot reset weight of hidden stretch column
            continue;
        column->CannotSkipItemsQueue = (1 << 0);
        column->AutoFitQueue = (1 << 1);
    }
}

void ImGui::TableUpdateColumnsWeightFromWidth(ImGuiTable* table)
{
    IM_ASSERT(table->LeftMostStretchedColumn != -1 && table->RightMostStretchedColumn != -1);

    // Measure existing quantities
    float visible_weight = 0.0f;
    float visible_width = 0.0f;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))
            continue;
        IM_ASSERT(column->StretchWeight > 0.0f);
        visible_weight += column->StretchWeight;
        visible_width += column->WidthRequest;
    }
    IM_ASSERT(visible_weight > 0.0f && visible_width > 0.0f);

    // Apply new weights
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))
            continue;
        column->StretchWeight = (column->WidthRequest / visible_width) * visible_weight;
        IM_ASSERT(column->StretchWeight > 0.0f);
    }
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Drawing
//-------------------------------------------------------------------------
// - TablePushBackgroundChannel() [Internal]
// - TablePopBackgroundChannel() [Internal]
// - TableSetupDrawChannels() [Internal]
// - TableMergeDrawChannels() [Internal]
// - TableGetColumnBorderCol() [Internal]
// - TableDrawBorders() [Internal]
//-------------------------------------------------------------------------

// Bg2 is used by Selectable (and possibly other widgets) to render to the background.
// Unlike our Bg0/1 channel which we uses for RowBg/CellBg/Borders and where we guarantee all shapes to be CPU-clipped, the Bg2 channel being widgets-facing will rely on regular ClipRect.
void ImGui::TablePushBackgroundChannel()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiTable* table = g.CurrentTable;

    // Optimization: avoid SetCurrentChannel() + PushClipRect()
    table->HostBackupInnerClipRect = window->ClipRect;
    SetWindowClipRectBeforeSetChannel(window, table->Bg2ClipRectForDrawCmd);
    table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Bg2DrawChannelCurrent);
}

void ImGui::TablePopBackgroundChannel()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiTable* table = g.CurrentTable;
    ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];

    // Optimization: avoid PopClipRect() + SetCurrentChannel()
    SetWindowClipRectBeforeSetChannel(window, table->HostBackupInnerClipRect);
    table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);
}

// Allocate draw channels. Called by TableUpdateLayout()
// - We allocate them following storage order instead of display order so reordering columns won't needlessly
//   increase overall dormant memory cost.
// - We isolate headers draw commands in their own channels instead of just altering clip rects.
//   This is in order to facilitate merging of draw commands.
// - After crossing FreezeRowsCount, all columns see their current draw channel changed to a second set of channels.
// - We only use the dummy draw channel so we can push a null clipping rectangle into it without affecting other
//   channels, while simplifying per-row/per-cell overhead. It will be empty and discarded when merged.
// - We allocate 1 or 2 background draw channels. This is because we know TablePushBackgroundChannel() is only used for
//   horizontal spanning. If we allowed vertical spanning we'd need one background draw channel per merge group (1-4).
// Draw channel allocation (before merging):
// - NoClip                       --> 2+D+1 channels: bg0/1 + bg2 + foreground (same clip rect == always 1 draw call)
// - Clip                         --> 2+D+N channels
// - FreezeRows                   --> 2+D+N*2 (unless scrolling value is zero)
// - FreezeRows || FreezeColunns  --> 3+D+N*2 (unless scrolling value is zero)
// Where D is 1 if any column is clipped or hidden (dummy channel) otherwise 0.
void ImGui::TableSetupDrawChannels(ImGuiTable* table)
{
    const int freeze_row_multiplier = (table->FreezeRowsCount > 0) ? 2 : 1;
    const int channels_for_row = (table->Flags & ImGuiTableFlags_NoClip) ? 1 : table->ColumnsEnabledCount;
    const int channels_for_bg = 1 + 1 * freeze_row_multiplier;
    const int channels_for_dummy = (table->ColumnsEnabledCount < table->ColumnsCount || (memcmp(table->VisibleMaskByIndex, table->EnabledMaskByIndex, ImBitArrayGetStorageSizeInBytes(table->ColumnsCount)) != 0)) ? +1 : 0;
    const int channels_total = channels_for_bg + (channels_for_row * freeze_row_multiplier) + channels_for_dummy;
    table->DrawSplitter->Split(table->InnerWindow->DrawList, channels_total);
    table->DummyDrawChannel = (ImGuiTableDrawChannelIdx)((channels_for_dummy > 0) ? channels_total - 1 : -1);
    table->Bg2DrawChannelCurrent = TABLE_DRAW_CHANNEL_BG2_FROZEN;
    table->Bg2DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)((table->FreezeRowsCount > 0) ? 2 + channels_for_row : TABLE_DRAW_CHANNEL_BG2_FROZEN);

    int draw_channel_current = 2;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (column->IsVisibleX && column->IsVisibleY)
        {
            column->DrawChannelFrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current);
            column->DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current + (table->FreezeRowsCount > 0 ? channels_for_row + 1 : 0));
            if (!(table->Flags & ImGuiTableFlags_NoClip))
                draw_channel_current++;
        }
        else
        {
            column->DrawChannelFrozen = column->DrawChannelUnfrozen = table->DummyDrawChannel;
        }
        column->DrawChannelCurrent = column->DrawChannelFrozen;
    }

    // Initial draw cmd starts with a BgClipRect that matches the one of its host, to facilitate merge draw commands by default.
    // All our cell highlight are manually clipped with BgClipRect. When unfreezing it will be made smaller to fit scrolling rect.
    // (This technically isn't part of setting up draw channels, but is reasonably related to be done here)
    table->BgClipRect = table->InnerClipRect;
    table->Bg0ClipRectForDrawCmd = table->OuterWindow->ClipRect;
    table->Bg2ClipRectForDrawCmd = table->HostClipRect;
    IM_ASSERT(table->BgClipRect.Min.y <= table->BgClipRect.Max.y);
}

// This function reorder draw channels based on matching clip rectangle, to facilitate merging them. Called by EndTable().
// For simplicity we call it TableMergeDrawChannels() but in fact it only reorder channels + overwrite ClipRect,
// actual merging is done by table->DrawSplitter.Merge() which is called right after TableMergeDrawChannels().
//
// Columns where the contents didn't stray off their local clip rectangle can be merged. To achieve
// this we merge their clip rect and make them contiguous in the channel list, so they can be merged
// by the call to DrawSplitter.Merge() following to the call to this function.
// We reorder draw commands by arranging them into a maximum of 4 distinct groups:
//
//   1 group:               2 groups:              2 groups:              4 groups:
//   [ 0. ] no freeze       [ 0. ] row freeze      [ 01 ] col freeze      [ 01 ] row+col freeze
//   [ .. ]  or no scroll   [ 2. ]  and v-scroll   [ .. ]  and h-scroll   [ 23 ]  and v+h-scroll
//
// Each column itself can use 1 channel (row freeze disabled) or 2 channels (row freeze enabled).
// When the contents of a column didn't stray off its limit, we move its channels into the corresponding group
// based on its position (within frozen rows/columns groups or not).
// At the end of the operation our 1-4 groups will each have a ImDrawCmd using the same ClipRect.
// This function assume that each column are pointing to a distinct draw channel,
// otherwise merge_group->ChannelsCount will not match set bit count of merge_group->ChannelsMask.
//
// Column channels will not be merged into one of the 1-4 groups in the following cases:
// - The contents stray off its clipping rectangle (we only compare the MaxX value, not the MinX value).
//   Direct ImDrawList calls won't be taken into account by default, if you use them make sure the ImGui:: bounds
//   matches, by e.g. calling SetCursorScreenPos().
// - The channel uses more than one draw command itself. We drop all our attempt at merging stuff here..
//   we could do better but it's going to be rare and probably not worth the hassle.
// Columns for which the draw channel(s) haven't been merged with other will use their own ImDrawCmd.
//
// This function is particularly tricky to understand.. take a breath.
void ImGui::TableMergeDrawChannels(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    ImDrawListSplitter* splitter = table->DrawSplitter;
    const bool has_freeze_v = (table->FreezeRowsCount > 0);
    const bool has_freeze_h = (table->FreezeColumnsCount > 0);
    IM_ASSERT(splitter->_Current == 0);

    // Track which groups we are going to attempt to merge, and which channels goes into each group.
    struct MergeGroup
    {
        ImRect          ClipRect;
        int             ChannelsCount = 0;
        ImBitArrayPtr   ChannelsMask = NULL;
    };
    int merge_group_mask = 0x00;
    MergeGroup merge_groups[4];

    // Use a reusable temp buffer for the merge masks as they are dynamically sized.
    const int max_draw_channels = (4 + table->ColumnsCount * 2);
    const int size_for_masks_bitarrays_one = (int)ImBitArrayGetStorageSizeInBytes(max_draw_channels);
    g.TempBuffer.reserve(size_for_masks_bitarrays_one * 5);
    memset(g.TempBuffer.Data, 0, size_for_masks_bitarrays_one * 5);
    for (int n = 0; n < IM_ARRAYSIZE(merge_groups); n++)
        merge_groups[n].ChannelsMask = (ImBitArrayPtr)(void*)(g.TempBuffer.Data + (size_for_masks_bitarrays_one * n));
    ImBitArrayPtr remaining_mask = (ImBitArrayPtr)(void*)(g.TempBuffer.Data + (size_for_masks_bitarrays_one * 4));

    // 1. Scan channels and take note of those which can be merged
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        if (!IM_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))
            continue;
        ImGuiTableColumn* column = &table->Columns[column_n];

        const int merge_group_sub_count = has_freeze_v ? 2 : 1;
        for (int merge_group_sub_n = 0; merge_group_sub_n < merge_group_sub_count; merge_group_sub_n++)
        {
            const int channel_no = (merge_group_sub_n == 0) ? column->DrawChannelFrozen : column->DrawChannelUnfrozen;

            // Don't attempt to merge if there are multiple draw calls within the column
            ImDrawChannel* src_channel = &splitter->_Channels[channel_no];
            if (src_channel->_CmdBuffer.Size > 0 && src_channel->_CmdBuffer.back().ElemCount == 0 && src_channel->_CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()
                src_channel->_CmdBuffer.pop_back();
            if (src_channel->_CmdBuffer.Size != 1)
                continue;

            // Find out the width of this merge group and check if it will fit in our column
            // (note that we assume that rendering didn't stray on the left direction. we should need a CursorMinPos to detect it)
            if (!(column->Flags & ImGuiTableColumnFlags_NoClip))
            {
                float content_max_x;
                if (!has_freeze_v)
                    content_max_x = ImMax(column->ContentMaxXUnfrozen, column->ContentMaxXHeadersUsed); // No row freeze
                else if (merge_group_sub_n == 0)
                    content_max_x = ImMax(column->ContentMaxXFrozen, column->ContentMaxXHeadersUsed);   // Row freeze: use width before freeze
                else
                    content_max_x = column->ContentMaxXUnfrozen;                                        // Row freeze: use width after freeze
                if (content_max_x > column->ClipRect.Max.x)
                    continue;
            }

            const int merge_group_n = (has_freeze_h && column_n < table->FreezeColumnsCount ? 0 : 1) + (has_freeze_v && merge_group_sub_n == 0 ? 0 : 2);
            IM_ASSERT(channel_no < max_draw_channels);
            MergeGroup* merge_group = &merge_groups[merge_group_n];
            if (merge_group->ChannelsCount == 0)
                merge_group->ClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
            ImBitArraySetBit(merge_group->ChannelsMask, channel_no);
            merge_group->ChannelsCount++;
            merge_group->ClipRect.Add(src_channel->_CmdBuffer[0].ClipRect);
            merge_group_mask |= (1 << merge_group_n);
        }

        // Invalidate current draw channel
        // (we don't clear DrawChannelFrozen/DrawChannelUnfrozen solely to facilitate debugging/later inspection of data)
        column->DrawChannelCurrent = (ImGuiTableDrawChannelIdx)-1;
    }

    // [DEBUG] Display merge groups
#if 0
    if (g.IO.KeyShift)
        for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++)
        {
            MergeGroup* merge_group = &merge_groups[merge_group_n];
            if (merge_group->ChannelsCount == 0)
                continue;
            char buf[32];
            ImFormatString(buf, 32, "MG%d:%d", merge_group_n, merge_group->ChannelsCount);
            ImVec2 text_pos = merge_group->ClipRect.Min + ImVec2(4, 4);
            ImVec2 text_size = CalcTextSize(buf, NULL);
            GetForegroundDrawList()->AddRectFilled(text_pos, text_pos + text_size, IM_COL32(0, 0, 0, 255));
            GetForegroundDrawList()->AddText(text_pos, IM_COL32(255, 255, 0, 255), buf, NULL);
            GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 255, 0, 255));
        }
#endif

    // 2. Rewrite channel list in our preferred order
    if (merge_group_mask != 0)
    {
        // We skip channel 0 (Bg0/Bg1) and 1 (Bg2 frozen) from the shuffling since they won't move - see channels allocation in TableSetupDrawChannels().
        const int LEADING_DRAW_CHANNELS = 2;
        g.DrawChannelsTempMergeBuffer.resize(splitter->_Count - LEADING_DRAW_CHANNELS); // Use shared temporary storage so the allocation gets amortized
        ImDrawChannel* dst_tmp = g.DrawChannelsTempMergeBuffer.Data;
        ImBitArraySetBitRange(remaining_mask, LEADING_DRAW_CHANNELS, splitter->_Count);
        ImBitArrayClearBit(remaining_mask, table->Bg2DrawChannelUnfrozen);
        IM_ASSERT(has_freeze_v == false || table->Bg2DrawChannelUnfrozen != TABLE_DRAW_CHANNEL_BG2_FROZEN);
        int remaining_count = splitter->_Count - (has_freeze_v ? LEADING_DRAW_CHANNELS + 1 : LEADING_DRAW_CHANNELS);
        //ImRect host_rect = (table->InnerWindow == table->OuterWindow) ? table->InnerClipRect : table->HostClipRect;
        ImRect host_rect = table->HostClipRect;
        for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++)
        {
            if (int merge_channels_count = merge_groups[merge_group_n].ChannelsCount)
            {
                MergeGroup* merge_group = &merge_groups[merge_group_n];
                ImRect merge_clip_rect = merge_group->ClipRect;

                // Extend outer-most clip limits to match those of host, so draw calls can be merged even if
                // outer-most columns have some outer padding offsetting them from their parent ClipRect.
                // The principal cases this is dealing with are:
                // - On a same-window table (not scrolling = single group), all fitting columns ClipRect -> will extend and match host ClipRect -> will merge
                // - Columns can use padding and have left-most ClipRect.Min.x and right-most ClipRect.Max.x != from host ClipRect -> will extend and match host ClipRect -> will merge
                // FIXME-TABLE FIXME-WORKRECT: We are wasting a merge opportunity on tables without scrolling if column doesn't fit
                // within host clip rect, solely because of the half-padding difference between window->WorkRect and window->InnerClipRect.
                if ((merge_group_n & 1) == 0 || !has_freeze_h)
                    merge_clip_rect.Min.x = ImMin(merge_clip_rect.Min.x, host_rect.Min.x);
                if ((merge_group_n & 2) == 0 || !has_freeze_v)
                    merge_clip_rect.Min.y = ImMin(merge_clip_rect.Min.y, host_rect.Min.y);
                if ((merge_group_n & 1) != 0)
                    merge_clip_rect.Max.x = ImMax(merge_clip_rect.Max.x, host_rect.Max.x);
                if ((merge_group_n & 2) != 0 && (table->Flags & ImGuiTableFlags_NoHostExtendY) == 0)
                    merge_clip_rect.Max.y = ImMax(merge_clip_rect.Max.y, host_rect.Max.y);
                //GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 0, 0, 200), 0.0f, 0, 1.0f); // [DEBUG]
                //GetForegroundDrawList()->AddLine(merge_group->ClipRect.Min, merge_clip_rect.Min, IM_COL32(255, 100, 0, 200));
                //GetForegroundDrawList()->AddLine(merge_group->ClipRect.Max, merge_clip_rect.Max, IM_COL32(255, 100, 0, 200));
                remaining_count -= merge_group->ChannelsCount;
                for (int n = 0; n < (size_for_masks_bitarrays_one >> 2); n++)
                    remaining_mask[n] &= ~merge_group->ChannelsMask[n];
                for (int n = 0; n < splitter->_Count && merge_channels_count != 0; n++)
                {
                    // Copy + overwrite new clip rect
                    if (!IM_BITARRAY_TESTBIT(merge_group->ChannelsMask, n))
                        continue;
                    IM_BITARRAY_CLEARBIT(merge_group->ChannelsMask, n);
                    merge_channels_count--;

                    ImDrawChannel* channel = &splitter->_Channels[n];
                    IM_ASSERT(channel->_CmdBuffer.Size == 1 && merge_clip_rect.Contains(ImRect(channel->_CmdBuffer[0].ClipRect)));
                    channel->_CmdBuffer[0].ClipRect = merge_clip_rect.ToVec4();
                    memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));
                }
            }

            // Make sure Bg2DrawChannelUnfrozen appears in the middle of our groups (whereas Bg0/Bg1 and Bg2 frozen are fixed to 0 and 1)
            if (merge_group_n == 1 && has_freeze_v)
                memcpy(dst_tmp++, &splitter->_Channels[table->Bg2DrawChannelUnfrozen], sizeof(ImDrawChannel));
        }

        // Append unmergeable channels that we didn't reorder at the end of the list
        for (int n = 0; n < splitter->_Count && remaining_count != 0; n++)
        {
            if (!IM_BITARRAY_TESTBIT(remaining_mask, n))
                continue;
            ImDrawChannel* channel = &splitter->_Channels[n];
            memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));
            remaining_count--;
        }
        IM_ASSERT(dst_tmp == g.DrawChannelsTempMergeBuffer.Data + g.DrawChannelsTempMergeBuffer.Size);
        memcpy(splitter->_Channels.Data + LEADING_DRAW_CHANNELS, g.DrawChannelsTempMergeBuffer.Data, (splitter->_Count - LEADING_DRAW_CHANNELS) * sizeof(ImDrawChannel));
    }
}

static ImU32 TableGetColumnBorderCol(ImGuiTable* table, int order_n, int column_n)
{
    const bool is_hovered = (table->HoveredColumnBorder == column_n);
    const bool is_resized = (table->ResizedColumn == column_n) && (table->InstanceInteracted == table->InstanceCurrent);
    const bool is_frozen_separator = (table->FreezeColumnsCount == order_n + 1);
    if (is_resized || is_hovered)
        return ImGui::GetColorU32(is_resized ? ImGuiCol_SeparatorActive : ImGuiCol_SeparatorHovered);
    if (is_frozen_separator || (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)))
        return table->BorderColorStrong;
    return table->BorderColorLight;
}

// FIXME-TABLE: This is a mess, need to redesign how we render borders (as some are also done in TableEndRow)
void ImGui::TableDrawBorders(ImGuiTable* table)
{
    ImGuiWindow* inner_window = table->InnerWindow;
    if (!table->OuterWindow->ClipRect.Overlaps(table->OuterRect))
        return;

    ImDrawList* inner_drawlist = inner_window->DrawList;
    table->DrawSplitter->SetCurrentChannel(inner_drawlist, TABLE_DRAW_CHANNEL_BG0);
    inner_drawlist->PushClipRect(table->Bg0ClipRectForDrawCmd.Min, table->Bg0ClipRectForDrawCmd.Max, false);

    // Draw inner border and resizing feedback
    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    const float border_size = TABLE_BORDER_SIZE;
    const float draw_y1 = ImMax(table->InnerRect.Min.y, (table->FreezeRowsCount >= 1 ? table->InnerRect.Min.y : table->WorkRect.Min.y) + table->AngledHeadersHeight) + ((table->Flags & ImGuiTableFlags_BordersOuterH) ? 1.0f : 0.0f);
    const float draw_y2_body = table->InnerRect.Max.y;
    const float draw_y2_head = table->IsUsingHeaders ? ImMin(table->InnerRect.Max.y, (table->FreezeRowsCount >= 1 ? table->InnerRect.Min.y : table->WorkRect.Min.y) + table_instance->LastTopHeadersRowHeight) : draw_y1;
    if (table->Flags & ImGuiTableFlags_BordersInnerV)
    {
        for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
        {
            if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
                continue;

            const int column_n = table->DisplayOrderToIndex[order_n];
            ImGuiTableColumn* column = &table->Columns[column_n];
            const bool is_hovered = (table->HoveredColumnBorder == column_n);
            const bool is_resized = (table->ResizedColumn == column_n) && (table->InstanceInteracted == table->InstanceCurrent);
            const bool is_resizable = (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_)) == 0;
            const bool is_frozen_separator = (table->FreezeColumnsCount == order_n + 1);
            if (column->MaxX > table->InnerClipRect.Max.x && !is_resized)
                continue;

            // Decide whether right-most column is visible
            if (column->NextEnabledColumn == -1 && !is_resizable)
                if ((table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame || (table->Flags & ImGuiTableFlags_NoHostExtendX))
                    continue;
            if (column->MaxX <= column->ClipRect.Min.x) // FIXME-TABLE FIXME-STYLE: Assume BorderSize==1, this is problematic if we want to increase the border size..
                continue;

            // Draw in outer window so right-most column won't be clipped
            // Always draw full height border when being resized/hovered, or on the delimitation of frozen column scrolling.
            float draw_y2 = (is_hovered || is_resized || is_frozen_separator || (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)) == 0) ? draw_y2_body : draw_y2_head;
            if (draw_y2 > draw_y1)
                inner_drawlist->AddLine(ImVec2(column->MaxX, draw_y1), ImVec2(column->MaxX, draw_y2), TableGetColumnBorderCol(table, order_n, column_n), border_size);
        }
    }

    // Draw outer border
    // FIXME: could use AddRect or explicit VLine/HLine helper?
    if (table->Flags & ImGuiTableFlags_BordersOuter)
    {
        // Display outer border offset by 1 which is a simple way to display it without adding an extra draw call
        // (Without the offset, in outer_window it would be rendered behind cells, because child windows are above their
        // parent. In inner_window, it won't reach out over scrollbars. Another weird solution would be to display part
        // of it in inner window, and the part that's over scrollbars in the outer window..)
        // Either solution currently won't allow us to use a larger border size: the border would clipped.
        const ImRect outer_border = table->OuterRect;
        const ImU32 outer_col = table->BorderColorStrong;
        if ((table->Flags & ImGuiTableFlags_BordersOuter) == ImGuiTableFlags_BordersOuter)
        {
            inner_drawlist->AddRect(outer_border.Min, outer_border.Max, outer_col, 0.0f, 0, border_size);
        }
        else if (table->Flags & ImGuiTableFlags_BordersOuterV)
        {
            inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Min.x, outer_border.Max.y), outer_col, border_size);
            inner_drawlist->AddLine(ImVec2(outer_border.Max.x, outer_border.Min.y), outer_border.Max, outer_col, border_size);
        }
        else if (table->Flags & ImGuiTableFlags_BordersOuterH)
        {
            inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Max.x, outer_border.Min.y), outer_col, border_size);
            inner_drawlist->AddLine(ImVec2(outer_border.Min.x, outer_border.Max.y), outer_border.Max, outer_col, border_size);
        }
    }
    if ((table->Flags & ImGuiTableFlags_BordersInnerH) && table->RowPosY2 < table->OuterRect.Max.y)
    {
        // Draw bottom-most row border between it is above outer border.
        const float border_y = table->RowPosY2;
        if (border_y >= table->BgClipRect.Min.y && border_y < table->BgClipRect.Max.y)
            inner_drawlist->AddLine(ImVec2(table->BorderX1, border_y), ImVec2(table->BorderX2, border_y), table->BorderColorLight, border_size);
    }

    inner_drawlist->PopClipRect();
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Sorting
//-------------------------------------------------------------------------
// - TableGetSortSpecs()
// - TableFixColumnSortDirection() [Internal]
// - TableGetColumnNextSortDirection() [Internal]
// - TableSetColumnSortDirection() [Internal]
// - TableSortSpecsSanitize() [Internal]
// - TableSortSpecsBuild() [Internal]
//-------------------------------------------------------------------------

// Return NULL if no sort specs (most often when ImGuiTableFlags_Sortable is not set)
// When 'sort_specs->SpecsDirty == true' you should sort your data. It will be true when sorting specs have
// changed since last call, or the first time. Make sure to set 'SpecsDirty = false' after sorting,
// else you may wastefully sort your data every frame!
// Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable()!
ImGuiTableSortSpecs* ImGui::TableGetSortSpecs()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL);

    if (!(table->Flags & ImGuiTableFlags_Sortable))
        return NULL;

    // Require layout (in case TableHeadersRow() hasn't been called) as it may alter IsSortSpecsDirty in some paths.
    if (!table->IsLayoutLocked)
        TableUpdateLayout(table);

    TableSortSpecsBuild(table);
    return &table->SortSpecs;
}

static inline ImGuiSortDirection TableGetColumnAvailSortDirection(ImGuiTableColumn* column, int n)
{
    IM_ASSERT(n < column->SortDirectionsAvailCount);
    return (ImGuiSortDirection)((column->SortDirectionsAvailList >> (n << 1)) & 0x03);
}

// Fix sort direction if currently set on a value which is unavailable (e.g. activating NoSortAscending/NoSortDescending)
void ImGui::TableFixColumnSortDirection(ImGuiTable* table, ImGuiTableColumn* column)
{
    if (column->SortOrder == -1 || (column->SortDirectionsAvailMask & (1 << column->SortDirection)) != 0)
        return;
    column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);
    table->IsSortSpecsDirty = true;
}

// Calculate next sort direction that would be set after clicking the column
// - If the PreferSortDescending flag is set, we will default to a Descending direction on the first click.
// - Note that the PreferSortAscending flag is never checked, it is essentially the default and therefore a no-op.
IM_STATIC_ASSERT(ImGuiSortDirection_None == 0 && ImGuiSortDirection_Ascending == 1 && ImGuiSortDirection_Descending == 2);
ImGuiSortDirection ImGui::TableGetColumnNextSortDirection(ImGuiTableColumn* column)
{
    IM_ASSERT(column->SortDirectionsAvailCount > 0);
    if (column->SortOrder == -1)
        return TableGetColumnAvailSortDirection(column, 0);
    for (int n = 0; n < 3; n++)
        if (column->SortDirection == TableGetColumnAvailSortDirection(column, n))
            return TableGetColumnAvailSortDirection(column, (n + 1) % column->SortDirectionsAvailCount);
    IM_ASSERT(0);
    return ImGuiSortDirection_None;
}

// Note that the NoSortAscending/NoSortDescending flags are processed in TableSortSpecsSanitize(), and they may change/revert
// the value of SortDirection. We could technically also do it here but it would be unnecessary and duplicate code.
void ImGui::TableSetColumnSortDirection(int column_n, ImGuiSortDirection sort_direction, bool append_to_sort_specs)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;

    if (!(table->Flags & ImGuiTableFlags_SortMulti))
        append_to_sort_specs = false;
    if (!(table->Flags & ImGuiTableFlags_SortTristate))
        IM_ASSERT(sort_direction != ImGuiSortDirection_None);

    ImGuiTableColumnIdx sort_order_max = 0;
    if (append_to_sort_specs)
        for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)
            sort_order_max = ImMax(sort_order_max, table->Columns[other_column_n].SortOrder);

    ImGuiTableColumn* column = &table->Columns[column_n];
    column->SortDirection = (ImU8)sort_direction;
    if (column->SortDirection == ImGuiSortDirection_None)
        column->SortOrder = -1;
    else if (column->SortOrder == -1 || !append_to_sort_specs)
        column->SortOrder = append_to_sort_specs ? sort_order_max + 1 : 0;

    for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)
    {
        ImGuiTableColumn* other_column = &table->Columns[other_column_n];
        if (other_column != column && !append_to_sort_specs)
            other_column->SortOrder = -1;
        TableFixColumnSortDirection(table, other_column);
    }
    table->IsSettingsDirty = true;
    table->IsSortSpecsDirty = true;
}

void ImGui::TableSortSpecsSanitize(ImGuiTable* table)
{
    IM_ASSERT(table->Flags & ImGuiTableFlags_Sortable);

    // Clear SortOrder from hidden column and verify that there's no gap or duplicate.
    int sort_order_count = 0;
    ImU64 sort_order_mask = 0x00;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (column->SortOrder != -1 && !column->IsEnabled)
            column->SortOrder = -1;
        if (column->SortOrder == -1)
            continue;
        sort_order_count++;
        sort_order_mask |= ((ImU64)1 << column->SortOrder);
        IM_ASSERT(sort_order_count < (int)sizeof(sort_order_mask) * 8);
    }

    const bool need_fix_linearize = ((ImU64)1 << sort_order_count) != (sort_order_mask + 1);
    const bool need_fix_single_sort_order = (sort_order_count > 1) && !(table->Flags & ImGuiTableFlags_SortMulti);
    if (need_fix_linearize || need_fix_single_sort_order)
    {
        ImU64 fixed_mask = 0x00;
        for (int sort_n = 0; sort_n < sort_order_count; sort_n++)
        {
            // Fix: Rewrite sort order fields if needed so they have no gap or duplicate.
            // (e.g. SortOrder 0 disappeared, SortOrder 1..2 exists --> rewrite then as SortOrder 0..1)
            int column_with_smallest_sort_order = -1;
            for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
                if ((fixed_mask & ((ImU64)1 << (ImU64)column_n)) == 0 && table->Columns[column_n].SortOrder != -1)
                    if (column_with_smallest_sort_order == -1 || table->Columns[column_n].SortOrder < table->Columns[column_with_smallest_sort_order].SortOrder)
                        column_with_smallest_sort_order = column_n;
            IM_ASSERT(column_with_smallest_sort_order != -1);
            fixed_mask |= ((ImU64)1 << column_with_smallest_sort_order);
            table->Columns[column_with_smallest_sort_order].SortOrder = (ImGuiTableColumnIdx)sort_n;

            // Fix: Make sure only one column has a SortOrder if ImGuiTableFlags_MultiSortable is not set.
            if (need_fix_single_sort_order)
            {
                sort_order_count = 1;
                for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
                    if (column_n != column_with_smallest_sort_order)
                        table->Columns[column_n].SortOrder = -1;
                break;
            }
        }
    }

    // Fallback default sort order (if no column with the ImGuiTableColumnFlags_DefaultSort flag)
    if (sort_order_count == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        {
            ImGuiTableColumn* column = &table->Columns[column_n];
            if (column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_NoSort))
            {
                sort_order_count = 1;
                column->SortOrder = 0;
                column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);
                break;
            }
        }

    table->SortSpecsCount = (ImGuiTableColumnIdx)sort_order_count;
}

void ImGui::TableSortSpecsBuild(ImGuiTable* table)
{
    bool dirty = table->IsSortSpecsDirty;
    if (dirty)
    {
        TableSortSpecsSanitize(table);
        table->SortSpecsMulti.resize(table->SortSpecsCount <= 1 ? 0 : table->SortSpecsCount);
        table->SortSpecs.SpecsDirty = true; // Mark as dirty for user
        table->IsSortSpecsDirty = false; // Mark as not dirty for us
    }

    // Write output
    // May be able to move all SortSpecs data from table (48 bytes) to ImGuiTableTempData if we decide to write it back on every BeginTable()
    ImGuiTableColumnSortSpecs* sort_specs = (table->SortSpecsCount == 0) ? NULL : (table->SortSpecsCount == 1) ? &table->SortSpecsSingle : table->SortSpecsMulti.Data;
    if (dirty && sort_specs != NULL)
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        {
            ImGuiTableColumn* column = &table->Columns[column_n];
            if (column->SortOrder == -1)
                continue;
            IM_ASSERT(column->SortOrder < table->SortSpecsCount);
            ImGuiTableColumnSortSpecs* sort_spec = &sort_specs[column->SortOrder];
            sort_spec->ColumnUserID = column->UserID;
            sort_spec->ColumnIndex = (ImGuiTableColumnIdx)column_n;
            sort_spec->SortOrder = (ImGuiTableColumnIdx)column->SortOrder;
            sort_spec->SortDirection = (ImGuiSortDirection)column->SortDirection;
        }

    table->SortSpecs.Specs = sort_specs;
    table->SortSpecs.SpecsCount = table->SortSpecsCount;
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Headers
//-------------------------------------------------------------------------
// - TableGetHeaderRowHeight() [Internal]
// - TableGetHeaderAngledMaxLabelWidth() [Internal]
// - TableHeadersRow()
// - TableHeader()
// - TableAngledHeadersRow()
// - TableAngledHeadersRowEx() [Internal]
//-------------------------------------------------------------------------

float ImGui::TableGetHeaderRowHeight()
{
    // Caring for a minor edge case:
    // Calculate row height, for the unlikely case that some labels may be taller than others.
    // If we didn't do that, uneven header height would highlight but smaller one before the tallest wouldn't catch input for all height.
    // In your custom header row you may omit this all together and just call TableNextRow() without a height...
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    float row_height = g.FontSize;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
            if ((table->Columns[column_n].Flags & ImGuiTableColumnFlags_NoHeaderLabel) == 0)
                row_height = ImMax(row_height, CalcTextSize(TableGetColumnName(table, column_n)).y);
    return row_height + g.Style.CellPadding.y * 2.0f;
}

float ImGui::TableGetHeaderAngledMaxLabelWidth()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    float width = 0.0f;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
            if (table->Columns[column_n].Flags & ImGuiTableColumnFlags_AngledHeader)
                width = ImMax(width, CalcTextSize(TableGetColumnName(table, column_n), NULL, true).x);
    return width + g.Style.CellPadding.y * 2.0f; // Swap padding
}

// [Public] This is a helper to output TableHeader() calls based on the column names declared in TableSetupColumn().
// The intent is that advanced users willing to create customized headers would not need to use this helper
// and can create their own! For example: TableHeader() may be preceded by Checkbox() or other custom widgets.
// See 'Demo->Tables->Custom headers' for a demonstration of implementing a custom version of this.
// This code is intentionally written to not make much use of internal functions, to give you better direction
// if you need to write your own.
// FIXME-TABLE: TableOpenContextMenu() and TableGetHeaderRowHeight() are not public.
void ImGui::TableHeadersRow()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (table == NULL)
    {
        IM_ASSERT_USER_ERROR(table != NULL, "Call should only be done while in BeginTable() scope!");
        return;
    }

    // Call layout if not already done. This is automatically done by TableNextRow: we do it here _only_ to make
    // it easier to debug-step in TableUpdateLayout(). Your own version of this function doesn't need this.
    if (!table->IsLayoutLocked)
        TableUpdateLayout(table);

    // Open row
    const float row_height = TableGetHeaderRowHeight();
    TableNextRow(ImGuiTableRowFlags_Headers, row_height);
    const float row_y1 = GetCursorScreenPos().y;
    if (table->HostSkipItems) // Merely an optimization, you may skip in your own code.
        return;

    const int columns_count = TableGetColumnCount();
    for (int column_n = 0; column_n < columns_count; column_n++)
    {
        if (!TableSetColumnIndex(column_n))
            continue;

        // Push an id to allow empty/unnamed headers. This is also idiomatic as it ensure there is a consistent ID path to access columns (for e.g. automation)
        const char* name = (TableGetColumnFlags(column_n) & ImGuiTableColumnFlags_NoHeaderLabel) ? "" : TableGetColumnName(column_n);
        PushID(column_n);
        TableHeader(name);
        PopID();
    }

    // Allow opening popup from the right-most section after the last column.
    ImVec2 mouse_pos = ImGui::GetMousePos();
    if (IsMouseReleased(1) && TableGetHoveredColumn() == columns_count)
        if (mouse_pos.y >= row_y1 && mouse_pos.y < row_y1 + row_height)
            TableOpenContextMenu(columns_count); // Will open a non-column-specific popup.
}

// Emit a column header (text + optional sort order)
// We cpu-clip text here so that all columns headers can be merged into a same draw call.
// Note that because of how we cpu-clip and display sorting indicators, you _cannot_ use SameLine() after a TableHeader()
void ImGui::TableHeader(const char* label)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    ImGuiTable* table = g.CurrentTable;
    if (table == NULL)
    {
        IM_ASSERT_USER_ERROR(table != NULL, "Call should only be done while in BeginTable() scope!");
        return;
    }

    IM_ASSERT(table->CurrentColumn != -1);
    const int column_n = table->CurrentColumn;
    ImGuiTableColumn* column = &table->Columns[column_n];

    // Label
    if (label == NULL)
        label = "";
    const char* label_end = FindRenderedTextEnd(label);
    ImVec2 label_size = CalcTextSize(label, label_end, true);
    ImVec2 label_pos = window->DC.CursorPos;

    // If we already got a row height, there's use that.
    // FIXME-TABLE: Padding problem if the correct outer-padding CellBgRect strays off our ClipRect?
    ImRect cell_r = TableGetCellBgRect(table, column_n);
    float label_height = ImMax(label_size.y, table->RowMinHeight - table->RowCellPaddingY * 2.0f);

    // Calculate ideal size for sort order arrow
    float w_arrow = 0.0f;
    float w_sort_text = 0.0f;
    bool sort_arrow = false;
    char sort_order_suf[4] = "";
    const float ARROW_SCALE = 0.65f;
    if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort))
    {
        w_arrow = ImTrunc(g.FontSize * ARROW_SCALE + g.Style.FramePadding.x);
        if (column->SortOrder != -1)
            sort_arrow = true;
        if (column->SortOrder > 0)
        {
            ImFormatString(sort_order_suf, IM_ARRAYSIZE(sort_order_suf), "%d", column->SortOrder + 1);
            w_sort_text = g.Style.ItemInnerSpacing.x + CalcTextSize(sort_order_suf).x;
        }
    }

    // We feed our unclipped width to the column without writing on CursorMaxPos, so that column is still considered for merging.
    float max_pos_x = label_pos.x + label_size.x + w_sort_text + w_arrow;
    column->ContentMaxXHeadersUsed = ImMax(column->ContentMaxXHeadersUsed, sort_arrow ? cell_r.Max.x : ImMin(max_pos_x, cell_r.Max.x));
    column->ContentMaxXHeadersIdeal = ImMax(column->ContentMaxXHeadersIdeal, max_pos_x);

    // Keep header highlighted when context menu is open.
    ImGuiID id = window->GetID(label);
    ImRect bb(cell_r.Min.x, cell_r.Min.y, cell_r.Max.x, ImMax(cell_r.Max.y, cell_r.Min.y + label_height + g.Style.CellPadding.y * 2.0f));
    ItemSize(ImVec2(0.0f, label_height)); // Don't declare unclipped width, it'll be fed ContentMaxPosHeadersIdeal
    if (!ItemAdd(bb, id))
        return;

    //GetForegroundDrawList()->AddRect(cell_r.Min, cell_r.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]
    //GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]

    // Using AllowOverlap mode because we cover the whole cell, and we want user to be able to submit subsequent items.
    const bool highlight = (table->HighlightColumnHeader == column_n);
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_AllowOverlap);
    if (held || hovered || highlight)
    {
        const ImU32 col = GetColorU32(held ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
        //RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
        TableSetBgColor(ImGuiTableBgTarget_CellBg, col, table->CurrentColumn);
    }
    else
    {
        // Submit single cell bg color in the case we didn't submit a full header row
        if ((table->RowFlags & ImGuiTableRowFlags_Headers) == 0)
            TableSetBgColor(ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol_TableHeaderBg), table->CurrentColumn);
    }
    RenderNavCursor(bb, id, ImGuiNavRenderCursorFlags_Compact | ImGuiNavRenderCursorFlags_NoRounding);
    if (held)
        table->HeldHeaderColumn = (ImGuiTableColumnIdx)column_n;
    window->DC.CursorPos.y -= g.Style.ItemSpacing.y * 0.5f;

    // Drag and drop to re-order columns.
    // FIXME-TABLE: Scroll request while reordering a column and it lands out of the scrolling zone.
    if (held && (table->Flags & ImGuiTableFlags_Reorderable) && IsMouseDragging(0) && !g.DragDropActive)
    {
        // While moving a column it will jump on the other side of the mouse, so we also test for MouseDelta.x
        table->ReorderColumn = (ImGuiTableColumnIdx)column_n;
        table->InstanceInteracted = table->InstanceCurrent;

        // We don't reorder: through the frozen<>unfrozen line, or through a column that is marked with ImGuiTableColumnFlags_NoReorder.
        if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < cell_r.Min.x)
            if (ImGuiTableColumn* prev_column = (column->PrevEnabledColumn != -1) ? &table->Columns[column->PrevEnabledColumn] : NULL)
                if (!((column->Flags | prev_column->Flags) & ImGuiTableColumnFlags_NoReorder))
                    if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (prev_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))
                        table->ReorderColumnDir = -1;
        if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > cell_r.Max.x)
            if (ImGuiTableColumn* next_column = (column->NextEnabledColumn != -1) ? &table->Columns[column->NextEnabledColumn] : NULL)
                if (!((column->Flags | next_column->Flags) & ImGuiTableColumnFlags_NoReorder))
                    if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (next_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))
                        table->ReorderColumnDir = +1;
    }

    // Sort order arrow
    const float ellipsis_max = ImMax(cell_r.Max.x - w_arrow - w_sort_text, label_pos.x);
    if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort))
    {
        if (column->SortOrder != -1)
        {
            float x = ImMax(cell_r.Min.x, cell_r.Max.x - w_arrow - w_sort_text);
            float y = label_pos.y;
            if (column->SortOrder > 0)
            {
                PushStyleColor(ImGuiCol_Text, GetColorU32(ImGuiCol_Text, 0.70f));
                RenderText(ImVec2(x + g.Style.ItemInnerSpacing.x, y), sort_order_suf);
                PopStyleColor();
                x += w_sort_text;
            }
            RenderArrow(window->DrawList, ImVec2(x, y), GetColorU32(ImGuiCol_Text), column->SortDirection == ImGuiSortDirection_Ascending ? ImGuiDir_Up : ImGuiDir_Down, ARROW_SCALE);
        }

        // Handle clicking on column header to adjust Sort Order
        if (pressed && table->ReorderColumn != column_n)
        {
            ImGuiSortDirection sort_direction = TableGetColumnNextSortDirection(column);
            TableSetColumnSortDirection(column_n, sort_direction, g.IO.KeyShift);
        }
    }

    // Render clipped label. Clipping here ensure that in the majority of situations, all our header cells will
    // be merged into a single draw call.
    //window->DrawList->AddCircleFilled(ImVec2(ellipsis_max, label_pos.y), 40, IM_COL32_WHITE);
    RenderTextEllipsis(window->DrawList, label_pos, ImVec2(ellipsis_max, label_pos.y + label_height + g.Style.FramePadding.y), ellipsis_max, ellipsis_max, label, label_end, &label_size);

    const bool text_clipped = label_size.x > (ellipsis_max - label_pos.x);
    if (text_clipped && hovered && g.ActiveId == 0)
        SetItemTooltip("%.*s", (int)(label_end - label), label);

    // We don't use BeginPopupContextItem() because we want the popup to stay up even after the column is hidden
    if (IsMouseReleased(1) && IsItemHovered())
        TableOpenContextMenu(column_n);
}

// Unlike TableHeadersRow() it is not expected that you can reimplement or customize this with custom widgets.
// FIXME: No hit-testing/button on the angled header.
void ImGui::TableAngledHeadersRow()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    ImGuiTableTempData* temp_data = table->TempData;
    temp_data->AngledHeadersRequests.resize(0);
    temp_data->AngledHeadersRequests.reserve(table->ColumnsEnabledCount);

    // Which column needs highlight?
    const ImGuiID row_id = GetID("##AngledHeaders");
    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    int highlight_column_n = table->HighlightColumnHeader;
    if (highlight_column_n == -1 && table->HoveredColumnBody != -1)
        if (table_instance->HoveredRowLast == 0 && table->HoveredColumnBorder == -1 && (g.ActiveId == 0 || g.ActiveId == row_id || (table->IsActiveIdInTable || g.DragDropActive)))
            highlight_column_n = table->HoveredColumnBody;

    // Build up request
    ImU32 col_header_bg = GetColorU32(ImGuiCol_TableHeaderBg);
    ImU32 col_text = GetColorU32(ImGuiCol_Text);
    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
        if (IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
        {
            const int column_n = table->DisplayOrderToIndex[order_n];
            ImGuiTableColumn* column = &table->Columns[column_n];
            if ((column->Flags & ImGuiTableColumnFlags_AngledHeader) == 0) // Note: can't rely on ImGuiTableColumnFlags_IsVisible test here.
                continue;
            ImGuiTableHeaderData request = { (ImGuiTableColumnIdx)column_n, col_text, col_header_bg, (column_n == highlight_column_n) ? GetColorU32(ImGuiCol_Header) : 0 };
            temp_data->AngledHeadersRequests.push_back(request);
        }

    // Render row
    TableAngledHeadersRowEx(row_id, g.Style.TableAngledHeadersAngle, 0.0f, temp_data->AngledHeadersRequests.Data, temp_data->AngledHeadersRequests.Size);
}

// Important: data must be fed left to right
void ImGui::TableAngledHeadersRowEx(ImGuiID row_id, float angle, float max_label_width, const ImGuiTableHeaderData* data, int data_count)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    ImGuiWindow* window = g.CurrentWindow;
    ImDrawList* draw_list = window->DrawList;
    if (table == NULL)
    {
        IM_ASSERT_USER_ERROR(table != NULL, "Call should only be done while in BeginTable() scope!");
        return;
    }
    IM_ASSERT(table->CurrentRow == -1 && "Must be first row");

    if (max_label_width == 0.0f)
        max_label_width = TableGetHeaderAngledMaxLabelWidth();

    // Angle argument expressed in (-IM_PI/2 .. +IM_PI/2) as it is easier to think about for user.
    const bool flip_label = (angle < 0.0f);
    angle -= IM_PI * 0.5f;
    const float cos_a = ImCos(angle);
    const float sin_a = ImSin(angle);
    const float label_cos_a = flip_label ? ImCos(angle + IM_PI) : cos_a;
    const float label_sin_a = flip_label ? ImSin(angle + IM_PI) : sin_a;
    const ImVec2 unit_right = ImVec2(cos_a, sin_a);

    // Calculate our base metrics and set angled headers data _before_ the first call to TableNextRow()
    // FIXME-STYLE: Would it be better for user to submit 'max_label_width' or 'row_height' ? One can be derived from the other.
    const float header_height = g.FontSize + g.Style.CellPadding.x * 2.0f;
    const float row_height = ImTrunc(ImFabs(ImRotate(ImVec2(max_label_width, flip_label ? +header_height : -header_height), cos_a, sin_a).y));
    table->AngledHeadersHeight = row_height;
    table->AngledHeadersSlope = (sin_a != 0.0f) ? (cos_a / sin_a) : 0.0f;
    const ImVec2 header_angled_vector = unit_right * (row_height / -sin_a); // vector from bottom-left to top-left, and from bottom-right to top-right

    // Declare row, override and draw our own background
    TableNextRow(ImGuiTableRowFlags_Headers, row_height);
    TableNextColumn();
    const ImRect row_r(table->WorkRect.Min.x, table->BgClipRect.Min.y, table->WorkRect.Max.x, table->RowPosY2);
    table->DrawSplitter->SetCurrentChannel(draw_list, TABLE_DRAW_CHANNEL_BG0);
    float clip_rect_min_x = table->BgClipRect.Min.x;
    if (table->FreezeColumnsCount > 0)
        clip_rect_min_x = ImMax(clip_rect_min_x, table->Columns[table->FreezeColumnsCount - 1].MaxX);
    TableSetBgColor(ImGuiTableBgTarget_RowBg0, 0); // Cancel
    PushClipRect(table->BgClipRect.Min, table->BgClipRect.Max, false); // Span all columns
    draw_list->AddRectFilled(ImVec2(table->BgClipRect.Min.x, row_r.Min.y), ImVec2(table->BgClipRect.Max.x, row_r.Max.y), GetColorU32(ImGuiCol_TableHeaderBg, 0.25f)); // FIXME-STYLE: Change row background with an arbitrary color.
    PushClipRect(ImVec2(clip_rect_min_x, table->BgClipRect.Min.y), table->BgClipRect.Max, true); // Span all columns

    ButtonBehavior(row_r, row_id, NULL, NULL);
    KeepAliveID(row_id);

    const float ascent_scaled = g.Font->Ascent * g.FontScale; // FIXME: Standardize those scaling factors better
    const float line_off_for_ascent_x = (ImMax((g.FontSize - ascent_scaled) * 0.5f, 0.0f) / -sin_a) * (flip_label ? -1.0f : 1.0f);
    const ImVec2 padding = g.Style.CellPadding; // We will always use swapped component
    const ImVec2 align = g.Style.TableAngledHeadersTextAlign;

    // Draw background and labels in first pass, then all borders.
    float max_x = -FLT_MAX;
    for (int pass = 0; pass < 2; pass++)
        for (int order_n = 0; order_n < data_count; order_n++)
        {
            const ImGuiTableHeaderData* request = &data[order_n];
            const int column_n = request->Index;
            ImGuiTableColumn* column = &table->Columns[column_n];

            ImVec2 bg_shape[4];
            bg_shape[0] = ImVec2(column->MaxX, row_r.Max.y);
            bg_shape[1] = ImVec2(column->MinX, row_r.Max.y);
            bg_shape[2] = bg_shape[1] + header_angled_vector;
            bg_shape[3] = bg_shape[0] + header_angled_vector;
            if (pass == 0)
            {
                // Draw shape
                draw_list->AddQuadFilled(bg_shape[0], bg_shape[1], bg_shape[2], bg_shape[3], request->BgColor0);
                draw_list->AddQuadFilled(bg_shape[0], bg_shape[1], bg_shape[2], bg_shape[3], request->BgColor1); // Optional highlight
                max_x = ImMax(max_x, bg_shape[3].x);

                // Draw label
                // - First draw at an offset where RenderTextXXX() function won't meddle with applying current ClipRect, then transform to final offset.
                // - Handle multiple lines manually, as we want each lines to follow on the horizontal border, rather than see a whole block rotated.
                const char* label_name = TableGetColumnName(table, column_n);
                const char* label_name_end = FindRenderedTextEnd(label_name);
                const float line_off_step_x = (g.FontSize / -sin_a);
                const int label_lines = ImTextCountLines(label_name, label_name_end);

                // Left<>Right alignment
                float line_off_curr_x = flip_label ? (label_lines - 1) * line_off_step_x : 0.0f;
                float line_off_for_align_x = ImMax((((column->MaxX - column->MinX) - padding.x * 2.0f) - (label_lines * line_off_step_x)), 0.0f) * align.x;
                line_off_curr_x += line_off_for_align_x - line_off_for_ascent_x;

                // Register header width
                column->ContentMaxXHeadersUsed = column->ContentMaxXHeadersIdeal = column->WorkMinX + ImCeil(label_lines * line_off_step_x - line_off_for_align_x);

                while (label_name < label_name_end)
                {
                    const char* label_name_eol = strchr(label_name, '\n');
                    if (label_name_eol == NULL)
                        label_name_eol = label_name_end;

                    // FIXME: Individual line clipping for right-most column is broken for negative angles.
                    ImVec2 label_size = CalcTextSize(label_name, label_name_eol);
                    float clip_width = max_label_width - padding.y; // Using padding.y*2.0f would be symmetrical but hide more text.
                    float clip_height = ImMin(label_size.y, column->ClipRect.Max.x - column->WorkMinX - line_off_curr_x);
                    ImRect clip_r(window->ClipRect.Min, window->ClipRect.Min + ImVec2(clip_width, clip_height));
                    int vtx_idx_begin = draw_list->_VtxCurrentIdx;
                    PushStyleColor(ImGuiCol_Text, request->TextColor);
                    RenderTextEllipsis(draw_list, clip_r.Min, clip_r.Max, clip_r.Max.x, clip_r.Max.x, label_name, label_name_eol, &label_size);
                    PopStyleColor();
                    int vtx_idx_end = draw_list->_VtxCurrentIdx;

                    // Up<>Down alignment
                    const float available_space = ImMax(clip_width - label_size.x + ImAbs(padding.x * cos_a) * 2.0f - ImAbs(padding.y * sin_a) * 2.0f, 0.0f);
                    const float vertical_offset = available_space * align.y * (flip_label ? -1.0f : 1.0f);

                    // Rotate and offset label
                    ImVec2 pivot_in = ImVec2(window->ClipRect.Min.x - vertical_offset, window->ClipRect.Min.y + label_size.y);
                    ImVec2 pivot_out = ImVec2(column->WorkMinX, row_r.Max.y);
                    line_off_curr_x += flip_label ? -line_off_step_x : line_off_step_x;
                    pivot_out += unit_right * padding.y;
                    if (flip_label)
                        pivot_out += unit_right * (clip_width - ImMax(0.0f, clip_width - label_size.x));
                    pivot_out.x += flip_label ? line_off_curr_x + line_off_step_x : line_off_curr_x;
                    ShadeVertsTransformPos(draw_list, vtx_idx_begin, vtx_idx_end, pivot_in, label_cos_a, label_sin_a, pivot_out); // Rotate and offset
                    //if (g.IO.KeyShift) { ImDrawList* fg_dl = GetForegroundDrawList(); vtx_idx_begin = fg_dl->_VtxCurrentIdx; fg_dl->AddRect(clip_r.Min, clip_r.Max, IM_COL32(0, 255, 0, 255), 0.0f, 0, 1.0f); ShadeVertsTransformPos(fg_dl, vtx_idx_begin, fg_dl->_VtxCurrentIdx, pivot_in, label_cos_a, label_sin_a, pivot_out); }

                    label_name = label_name_eol + 1;
                }
            }
            if (pass == 1)
            {
                // Draw border
                draw_list->AddLine(bg_shape[0], bg_shape[3], TableGetColumnBorderCol(table, order_n, column_n));
            }
        }
    PopClipRect();
    PopClipRect();
    table->TempData->AngledHeadersExtraWidth = ImMax(0.0f, max_x - table->Columns[table->RightMostEnabledColumn].MaxX);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Context Menu
//-------------------------------------------------------------------------
// - TableOpenContextMenu() [Internal]
// - TableBeginContextMenuPopup() [Internal]
// - TableDrawDefaultContextMenu() [Internal]
//-------------------------------------------------------------------------

// Use -1 to open menu not specific to a given column.
void ImGui::TableOpenContextMenu(int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (column_n == -1 && table->CurrentColumn != -1)   // When called within a column automatically use this one (for consistency)
        column_n = table->CurrentColumn;
    if (column_n == table->ColumnsCount)                // To facilitate using with TableGetHoveredColumn()
        column_n = -1;
    IM_ASSERT(column_n >= -1 && column_n < table->ColumnsCount);
    if (table->Flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable))
    {
        table->IsContextPopupOpen = true;
        table->ContextPopupColumn = (ImGuiTableColumnIdx)column_n;
        table->InstanceInteracted = table->InstanceCurrent;
        const ImGuiID context_menu_id = ImHashStr("##ContextMenu", 0, table->ID);
        OpenPopupEx(context_menu_id, ImGuiPopupFlags_None);
    }
}

bool ImGui::TableBeginContextMenuPopup(ImGuiTable* table)
{
    if (!table->IsContextPopupOpen || table->InstanceCurrent != table->InstanceInteracted)
        return false;
    const ImGuiID context_menu_id = ImHashStr("##ContextMenu", 0, table->ID);
    if (BeginPopupEx(context_menu_id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings))
        return true;
    table->IsContextPopupOpen = false;
    return false;
}

// Output context menu into current window (generally a popup)
// FIXME-TABLE: Ideally this should be writable by the user. Full programmatic access to that data?
// Sections to display are pulled from 'flags_for_section_to_display', which is typically == table->Flags.
// - ImGuiTableFlags_Resizable   -> display Sizing menu items
// - ImGuiTableFlags_Reorderable -> display "Reset Order"
////- ImGuiTableFlags_Sortable   -> display sorting options (disabled)
// - ImGuiTableFlags_Hideable    -> display columns visibility menu items
// It means if you have a custom context menus you can call this section and omit some sections, and add your own.
void ImGui::TableDrawDefaultContextMenu(ImGuiTable* table, ImGuiTableFlags flags_for_section_to_display)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    bool want_separator = false;
    const int column_n = (table->ContextPopupColumn >= 0 && table->ContextPopupColumn < table->ColumnsCount) ? table->ContextPopupColumn : -1;
    ImGuiTableColumn* column = (column_n != -1) ? &table->Columns[column_n] : NULL;

    // Sizing
    if (flags_for_section_to_display & ImGuiTableFlags_Resizable)
    {
        if (column != NULL)
        {
            const bool can_resize = !(column->Flags & ImGuiTableColumnFlags_NoResize) && column->IsEnabled;
            if (MenuItem(LocalizeGetMsg(ImGuiLocKey_TableSizeOne), NULL, false, can_resize)) // "###SizeOne"
                TableSetColumnWidthAutoSingle(table, column_n);
        }

        const char* size_all_desc;
        if (table->ColumnsEnabledFixedCount == table->ColumnsEnabledCount && (table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame)
            size_all_desc = LocalizeGetMsg(ImGuiLocKey_TableSizeAllFit);        // "###SizeAll" All fixed
        else
            size_all_desc = LocalizeGetMsg(ImGuiLocKey_TableSizeAllDefault);    // "###SizeAll" All stretch or mixed
        if (MenuItem(size_all_desc, NULL))
            TableSetColumnWidthAutoAll(table);
        want_separator = true;
    }

    // Ordering
    if (flags_for_section_to_display & ImGuiTableFlags_Reorderable)
    {
        if (MenuItem(LocalizeGetMsg(ImGuiLocKey_TableResetOrder), NULL, false, !table->IsDefaultDisplayOrder))
            table->IsResetDisplayOrderRequest = true;
        want_separator = true;
    }

    // Reset all (should work but seems unnecessary/noisy to expose?)
    //if (MenuItem("Reset all"))
    //    table->IsResetAllRequest = true;

    // Sorting
    // (modify TableOpenContextMenu() to add _Sortable flag if enabling this)
#if 0
    if ((flags_for_section_to_display & ImGuiTableFlags_Sortable) && column != NULL && (column->Flags & ImGuiTableColumnFlags_NoSort) == 0)
    {
        if (want_separator)
            Separator();
        want_separator = true;

        bool append_to_sort_specs = g.IO.KeyShift;
        if (MenuItem("Sort in Ascending Order", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Ascending, (column->Flags & ImGuiTableColumnFlags_NoSortAscending) == 0))
            TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Ascending, append_to_sort_specs);
        if (MenuItem("Sort in Descending Order", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Descending, (column->Flags & ImGuiTableColumnFlags_NoSortDescending) == 0))
            TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Descending, append_to_sort_specs);
    }
#endif

    // Hiding / Visibility
    if (flags_for_section_to_display & ImGuiTableFlags_Hideable)
    {
        if (want_separator)
            Separator();
        want_separator = true;

        PushItemFlag(ImGuiItemFlags_AutoClosePopups, false);
        for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)
        {
            ImGuiTableColumn* other_column = &table->Columns[other_column_n];
            if (other_column->Flags & ImGuiTableColumnFlags_Disabled)
                continue;

            const char* name = TableGetColumnName(table, other_column_n);
            if (name == NULL || name[0] == 0)
                name = "<Unknown>";

            // Make sure we can't hide the last active column
            bool menu_item_active = (other_column->Flags & ImGuiTableColumnFlags_NoHide) ? false : true;
            if (other_column->IsUserEnabled && table->ColumnsEnabledCount <= 1)
                menu_item_active = false;
            if (MenuItem(name, NULL, other_column->IsUserEnabled, menu_item_active))
                other_column->IsUserEnabledNextFrame = !other_column->IsUserEnabled;
        }
        PopItemFlag();
    }
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Settings (.ini data)
//-------------------------------------------------------------------------
// FIXME: The binding/finding/creating flow are too confusing.
//-------------------------------------------------------------------------
// - TableSettingsInit() [Internal]
// - TableSettingsCalcChunkSize() [Internal]
// - TableSettingsCreate() [Internal]
// - TableSettingsFindByID() [Internal]
// - TableGetBoundSettings() [Internal]
// - TableResetSettings()
// - TableSaveSettings() [Internal]
// - TableLoadSettings() [Internal]
// - TableSettingsHandler_ClearAll() [Internal]
// - TableSettingsHandler_ApplyAll() [Internal]
// - TableSettingsHandler_ReadOpen() [Internal]
// - TableSettingsHandler_ReadLine() [Internal]
// - TableSettingsHandler_WriteAll() [Internal]
// - TableSettingsInstallHandler() [Internal]
//-------------------------------------------------------------------------
// [Init] 1: TableSettingsHandler_ReadXXXX()   Load and parse .ini file into TableSettings.
// [Main] 2: TableLoadSettings()               When table is created, bind Table to TableSettings, serialize TableSettings data into Table.
// [Main] 3: TableSaveSettings()               When table properties are modified, serialize Table data into bound or new TableSettings, mark .ini as dirty.
// [Main] 4: TableSettingsHandler_WriteAll()   When .ini file is dirty (which can come from other source), save TableSettings into .ini file.
//-------------------------------------------------------------------------

// Clear and initialize empty settings instance
static void TableSettingsInit(ImGuiTableSettings* settings, ImGuiID id, int columns_count, int columns_count_max)
{
    IM_PLACEMENT_NEW(settings) ImGuiTableSettings();
    ImGuiTableColumnSettings* settings_column = settings->GetColumnSettings();
    for (int n = 0; n < columns_count_max; n++, settings_column++)
        IM_PLACEMENT_NEW(settings_column) ImGuiTableColumnSettings();
    settings->ID = id;
    settings->ColumnsCount = (ImGuiTableColumnIdx)columns_count;
    settings->ColumnsCountMax = (ImGuiTableColumnIdx)columns_count_max;
    settings->WantApply = true;
}

static size_t TableSettingsCalcChunkSize(int columns_count)
{
    return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);
}

ImGuiTableSettings* ImGui::TableSettingsCreate(ImGuiID id, int columns_count)
{
    ImGuiContext& g = *GImGui;
    ImGuiTableSettings* settings = g.SettingsTables.alloc_chunk(TableSettingsCalcChunkSize(columns_count));
    TableSettingsInit(settings, id, columns_count, columns_count);
    return settings;
}

// Find existing settings
ImGuiTableSettings* ImGui::TableSettingsFindByID(ImGuiID id)
{
    // FIXME-OPT: Might want to store a lookup map for this?
    ImGuiContext& g = *GImGui;
    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
        if (settings->ID == id)
            return settings;
    return NULL;
}

// Get settings for a given table, NULL if none
ImGuiTableSettings* ImGui::TableGetBoundSettings(ImGuiTable* table)
{
    if (table->SettingsOffset != -1)
    {
        ImGuiContext& g = *GImGui;
        ImGuiTableSettings* settings = g.SettingsTables.ptr_from_offset(table->SettingsOffset);
        IM_ASSERT(settings->ID == table->ID);
        if (settings->ColumnsCountMax >= table->ColumnsCount)
            return settings; // OK
        settings->ID = 0; // Invalidate storage, we won't fit because of a count change
    }
    return NULL;
}

// Restore initial state of table (with or without saved settings)
void ImGui::TableResetSettings(ImGuiTable* table)
{
    table->IsInitializing = table->IsSettingsDirty = true;
    table->IsResetAllRequest = false;
    table->IsSettingsRequestLoad = false;                   // Don't reload from ini
    table->SettingsLoadedFlags = ImGuiTableFlags_None;      // Mark as nothing loaded so our initialized data becomes authoritative
}

void ImGui::TableSaveSettings(ImGuiTable* table)
{
    table->IsSettingsDirty = false;
    if (table->Flags & ImGuiTableFlags_NoSavedSettings)
        return;

    // Bind or create settings data
    ImGuiContext& g = *GImGui;
    ImGuiTableSettings* settings = TableGetBoundSettings(table);
    if (settings == NULL)
    {
        settings = TableSettingsCreate(table->ID, table->ColumnsCount);
        table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);
    }
    settings->ColumnsCount = (ImGuiTableColumnIdx)table->ColumnsCount;

    // Serialize ImGuiTable/ImGuiTableColumn into ImGuiTableSettings/ImGuiTableColumnSettings
    IM_ASSERT(settings->ID == table->ID);
    IM_ASSERT(settings->ColumnsCount == table->ColumnsCount && settings->ColumnsCountMax >= settings->ColumnsCount);
    ImGuiTableColumn* column = table->Columns.Data;
    ImGuiTableColumnSettings* column_settings = settings->GetColumnSettings();

    bool save_ref_scale = false;
    settings->SaveFlags = ImGuiTableFlags_None;
    for (int n = 0; n < table->ColumnsCount; n++, column++, column_settings++)
    {
        const float width_or_weight = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? column->StretchWeight : column->WidthRequest;
        column_settings->WidthOrWeight = width_or_weight;
        column_settings->Index = (ImGuiTableColumnIdx)n;
        column_settings->DisplayOrder = column->DisplayOrder;
        column_settings->SortOrder = column->SortOrder;
        column_settings->SortDirection = column->SortDirection;
        column_settings->IsEnabled = column->IsUserEnabled;
        column_settings->IsStretch = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? 1 : 0;
        if ((column->Flags & ImGuiTableColumnFlags_WidthStretch) == 0)
            save_ref_scale = true;

        // We skip saving some data in the .ini file when they are unnecessary to restore our state.
        // Note that fixed width where initial width was derived from auto-fit will always be saved as InitStretchWeightOrWidth will be 0.0f.
        // FIXME-TABLE: We don't have logic to easily compare SortOrder to DefaultSortOrder yet so it's always saved when present.
        if (width_or_weight != column->InitStretchWeightOrWidth)
            settings->SaveFlags |= ImGuiTableFlags_Resizable;
        if (column->DisplayOrder != n)
            settings->SaveFlags |= ImGuiTableFlags_Reorderable;
        if (column->SortOrder != -1)
            settings->SaveFlags |= ImGuiTableFlags_Sortable;
        if (column->IsUserEnabled != ((column->Flags & ImGuiTableColumnFlags_DefaultHide) == 0))
            settings->SaveFlags |= ImGuiTableFlags_Hideable;
    }
    settings->SaveFlags &= table->Flags;
    settings->RefScale = save_ref_scale ? table->RefScale : 0.0f;

    MarkIniSettingsDirty();
}

void ImGui::TableLoadSettings(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    table->IsSettingsRequestLoad = false;
    if (table->Flags & ImGuiTableFlags_NoSavedSettings)
        return;

    // Bind settings
    ImGuiTableSettings* settings;
    if (table->SettingsOffset == -1)
    {
        settings = TableSettingsFindByID(table->ID);
        if (settings == NULL)
            return;
        if (settings->ColumnsCount != table->ColumnsCount) // Allow settings if columns count changed. We could otherwise decide to return...
            table->IsSettingsDirty = true;
        table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);
    }
    else
    {
        settings = TableGetBoundSettings(table);
    }

    table->SettingsLoadedFlags = settings->SaveFlags;
    table->RefScale = settings->RefScale;

    // Initialize default columns settings
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        TableInitColumnDefaults(table, column, ~0);
        column->AutoFitQueue = 0x00;
    }

    // Serialize ImGuiTableSettings/ImGuiTableColumnSettings into ImGuiTable/ImGuiTableColumn
    ImGuiTableColumnSettings* column_settings = settings->GetColumnSettings();
    ImU64 display_order_mask = 0;
    for (int data_n = 0; data_n < settings->ColumnsCount; data_n++, column_settings++)
    {
        int column_n = column_settings->Index;
        if (column_n < 0 || column_n >= table->ColumnsCount)
            continue;

        ImGuiTableColumn* column = &table->Columns[column_n];
        if (settings->SaveFlags & ImGuiTableFlags_Resizable)
        {
            if (column_settings->IsStretch)
                column->StretchWeight = column_settings->WidthOrWeight;
            else
                column->WidthRequest = column_settings->WidthOrWeight;
        }
        if (settings->SaveFlags & ImGuiTableFlags_Reorderable)
            column->DisplayOrder = column_settings->DisplayOrder;
        display_order_mask |= (ImU64)1 << column->DisplayOrder;
        if ((settings->SaveFlags & ImGuiTableFlags_Hideable) && column_settings->IsEnabled != -1)
            column->IsUserEnabled = column->IsUserEnabledNextFrame = column_settings->IsEnabled == 1;
        column->SortOrder = column_settings->SortOrder;
        column->SortDirection = column_settings->SortDirection;
    }

    // Validate and fix invalid display order data
    const ImU64 expected_display_order_mask = (settings->ColumnsCount == 64) ? ~0 : ((ImU64)1 << settings->ColumnsCount) - 1;
    if (display_order_mask != expected_display_order_mask)
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
            table->Columns[column_n].DisplayOrder = (ImGuiTableColumnIdx)column_n;

    // Rebuild index
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;
}

static void TableSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
{
    ImGuiContext& g = *ctx;
    for (int i = 0; i != g.Tables.GetMapSize(); i++)
        if (ImGuiTable* table = g.Tables.TryGetMapData(i))
            table->SettingsOffset = -1;
    g.SettingsTables.clear();
}

// Apply to existing windows (if any)
static void TableSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
{
    ImGuiContext& g = *ctx;
    for (int i = 0; i != g.Tables.GetMapSize(); i++)
        if (ImGuiTable* table = g.Tables.TryGetMapData(i))
        {
            table->IsSettingsRequestLoad = true;
            table->SettingsOffset = -1;
        }
}

static void* TableSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
{
    ImGuiID id = 0;
    int columns_count = 0;
    if (sscanf(name, "0x%08X,%d", &id, &columns_count) < 2)
        return NULL;

    if (ImGuiTableSettings* settings = ImGui::TableSettingsFindByID(id))
    {
        if (settings->ColumnsCountMax >= columns_count)
        {
            TableSettingsInit(settings, id, columns_count, settings->ColumnsCountMax); // Recycle
            return settings;
        }
        settings->ID = 0; // Invalidate storage, we won't fit because of a count change
    }
    return ImGui::TableSettingsCreate(id, columns_count);
}

static void TableSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)
{
    // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
    ImGuiTableSettings* settings = (ImGuiTableSettings*)entry;
    float f = 0.0f;
    int column_n = 0, r = 0, n = 0;

    if (sscanf(line, "RefScale=%f", &f) == 1) { settings->RefScale = f; return; }

    if (sscanf(line, "Column %d%n", &column_n, &r) == 1)
    {
        if (column_n < 0 || column_n >= settings->ColumnsCount)
            return;
        line = ImStrSkipBlank(line + r);
        char c = 0;
        ImGuiTableColumnSettings* column = settings->GetColumnSettings() + column_n;
        column->Index = (ImGuiTableColumnIdx)column_n;
        if (sscanf(line, "UserID=0x%08X%n", (ImU32*)&n, &r)==1) { line = ImStrSkipBlank(line + r); column->UserID = (ImGuiID)n; }
        if (sscanf(line, "Width=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->WidthOrWeight = (float)n; column->IsStretch = 0; settings->SaveFlags |= ImGuiTableFlags_Resizable; }
        if (sscanf(line, "Weight=%f%n", &f, &r) == 1)           { line = ImStrSkipBlank(line + r); column->WidthOrWeight = f; column->IsStretch = 1; settings->SaveFlags |= ImGuiTableFlags_Resizable; }
        if (sscanf(line, "Visible=%d%n", &n, &r) == 1)          { line = ImStrSkipBlank(line + r); column->IsEnabled = (ImU8)n; settings->SaveFlags |= ImGuiTableFlags_Hideable; }
        if (sscanf(line, "Order=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->DisplayOrder = (ImGuiTableColumnIdx)n; settings->SaveFlags |= ImGuiTableFlags_Reorderable; }
        if (sscanf(line, "Sort=%d%c%n", &n, &c, &r) == 2)       { line = ImStrSkipBlank(line + r); column->SortOrder = (ImGuiTableColumnIdx)n; column->SortDirection = (c == '^') ? ImGuiSortDirection_Descending : ImGuiSortDirection_Ascending; settings->SaveFlags |= ImGuiTableFlags_Sortable; }
    }
}

static void TableSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
{
    ImGuiContext& g = *ctx;
    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
    {
        if (settings->ID == 0) // Skip ditched settings
            continue;

        // TableSaveSettings() may clear some of those flags when we establish that the data can be stripped
        // (e.g. Order was unchanged)
        const bool save_size    = (settings->SaveFlags & ImGuiTableFlags_Resizable) != 0;
        const bool save_visible = (settings->SaveFlags & ImGuiTableFlags_Hideable) != 0;
        const bool save_order   = (settings->SaveFlags & ImGuiTableFlags_Reorderable) != 0;
        const bool save_sort    = (settings->SaveFlags & ImGuiTableFlags_Sortable) != 0;
        // We need to save the [Table] entry even if all the bools are false, since this records a table with "default settings".

        buf->reserve(buf->size() + 30 + settings->ColumnsCount * 50); // ballpark reserve
        buf->appendf("[%s][0x%08X,%d]\n", handler->TypeName, settings->ID, settings->ColumnsCount);
        if (settings->RefScale != 0.0f)
            buf->appendf("RefScale=%g\n", settings->RefScale);
        ImGuiTableColumnSettings* column = settings->GetColumnSettings();
        for (int column_n = 0; column_n < settings->ColumnsCount; column_n++, column++)
        {
            // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
            bool save_column = column->UserID != 0 || save_size || save_visible || save_order || (save_sort && column->SortOrder != -1);
            if (!save_column)
                continue;
            buf->appendf("Column %-2d", column_n);
            if (column->UserID != 0)                    { buf->appendf(" UserID=%08X", column->UserID); }
            if (save_size && column->IsStretch)         { buf->appendf(" Weight=%.4f", column->WidthOrWeight); }
            if (save_size && !column->IsStretch)        { buf->appendf(" Width=%d", (int)column->WidthOrWeight); }
            if (save_visible)                           { buf->appendf(" Visible=%d", column->IsEnabled); }
            if (save_order)                             { buf->appendf(" Order=%d", column->DisplayOrder); }
            if (save_sort && column->SortOrder != -1)   { buf->appendf(" Sort=%d%c", column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? 'v' : '^'); }
            buf->append("\n");
        }
        buf->append("\n");
    }
}

void ImGui::TableSettingsAddSettingsHandler()
{
    ImGuiSettingsHandler ini_handler;
    ini_handler.TypeName = "Table";
    ini_handler.TypeHash = ImHashStr("Table");
    ini_handler.ClearAllFn = TableSettingsHandler_ClearAll;
    ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;
    ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;
    ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll;
    ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;
    AddSettingsHandler(&ini_handler);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Garbage Collection
//-------------------------------------------------------------------------
// - TableRemove() [Internal]
// - TableGcCompactTransientBuffers() [Internal]
// - TableGcCompactSettings() [Internal]
//-------------------------------------------------------------------------

// Remove Table (currently only used by TestEngine)
void ImGui::TableRemove(ImGuiTable* table)
{
    //IMGUI_DEBUG_PRINT("TableRemove() id=0x%08X\n", table->ID);
    ImGuiContext& g = *GImGui;
    int table_idx = g.Tables.GetIndex(table);
    //memset(table->RawData.Data, 0, table->RawData.size_in_bytes());
    //memset(table, 0, sizeof(ImGuiTable));
    g.Tables.Remove(table->ID, table);
    g.TablesLastTimeActive[table_idx] = -1.0f;
}

// Free up/compact internal Table buffers for when it gets unused
void ImGui::TableGcCompactTransientBuffers(ImGuiTable* table)
{
    //IMGUI_DEBUG_PRINT("TableGcCompactTransientBuffers() id=0x%08X\n", table->ID);
    ImGuiContext& g = *GImGui;
    IM_ASSERT(table->MemoryCompacted == false);
    table->SortSpecs.Specs = NULL;
    table->SortSpecsMulti.clear();
    table->IsSortSpecsDirty = true; // FIXME: In theory shouldn't have to leak into user performing a sort on resume.
    table->ColumnsNames.clear();
    table->MemoryCompacted = true;
    for (int n = 0; n < table->ColumnsCount; n++)
        table->Columns[n].NameOffset = -1;
    g.TablesLastTimeActive[g.Tables.GetIndex(table)] = -1.0f;
}

void ImGui::TableGcCompactTransientBuffers(ImGuiTableTempData* temp_data)
{
    temp_data->DrawSplitter.ClearFreeMemory();
    temp_data->LastTimeActive = -1.0f;
}

// Compact and remove unused settings data (currently only used by TestEngine)
void ImGui::TableGcCompactSettings()
{
    ImGuiContext& g = *GImGui;
    int required_memory = 0;
    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
        if (settings->ID != 0)
            required_memory += (int)TableSettingsCalcChunkSize(settings->ColumnsCount);
    if (required_memory == g.SettingsTables.Buf.Size)
        return;
    ImChunkStream<ImGuiTableSettings> new_chunk_stream;
    new_chunk_stream.Buf.reserve(required_memory);
    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
        if (settings->ID != 0)
            memcpy(new_chunk_stream.alloc_chunk(TableSettingsCalcChunkSize(settings->ColumnsCount)), settings, TableSettingsCalcChunkSize(settings->ColumnsCount));
    g.SettingsTables.swap(new_chunk_stream);
}


//-------------------------------------------------------------------------
// [SECTION] Tables: Debugging
//-------------------------------------------------------------------------
// - DebugNodeTable() [Internal]
//-------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_DEBUG_TOOLS

static const char* DebugNodeTableGetSizingPolicyDesc(ImGuiTableFlags sizing_policy)
{
    sizing_policy &= ImGuiTableFlags_SizingMask_;
    if (sizing_policy == ImGuiTableFlags_SizingFixedFit)    { return "FixedFit"; }
    if (sizing_policy == ImGuiTableFlags_SizingFixedSame)   { return "FixedSame"; }
    if (sizing_policy == ImGuiTableFlags_SizingStretchProp) { return "StretchProp"; }
    if (sizing_policy == ImGuiTableFlags_SizingStretchSame) { return "StretchSame"; }
    return "N/A";
}

void ImGui::DebugNodeTable(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    const bool is_active = (table->LastFrameActive >= g.FrameCount - 2); // Note that fully clipped early out scrolling tables will appear as inactive here.
    if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }
    bool open = TreeNode(table, "Table 0x%08X (%d columns, in '%s')%s", table->ID, table->ColumnsCount, table->OuterWindow->Name, is_active ? "" : " *Inactive*");
    if (!is_active) { PopStyleColor(); }
    if (IsItemHovered())
        GetForegroundDrawList()->AddRect(table->OuterRect.Min, table->OuterRect.Max, IM_COL32(255, 255, 0, 255));
    if (IsItemVisible() && table->HoveredColumnBody != -1)
        GetForegroundDrawList()->AddRect(GetItemRectMin(), GetItemRectMax(), IM_COL32(255, 255, 0, 255));
    if (!open)
        return;
    if (table->InstanceCurrent > 0)
        Text("** %d instances of same table! Some data below will refer to last instance.", table->InstanceCurrent + 1);
    if (g.IO.ConfigDebugIsDebuggerPresent)
    {
        if (DebugBreakButton("**DebugBreak**", "in BeginTable()"))
            g.DebugBreakInTable = table->ID;
        SameLine();
    }

    bool clear_settings = SmallButton("Clear settings");
    BulletText("OuterRect: Pos: (%.1f,%.1f) Size: (%.1f,%.1f) Sizing: '%s'", table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.GetWidth(), table->OuterRect.GetHeight(), DebugNodeTableGetSizingPolicyDesc(table->Flags));
    BulletText("ColumnsGivenWidth: %.1f, ColumnsAutoFitWidth: %.1f, InnerWidth: %.1f%s", table->ColumnsGivenWidth, table->ColumnsAutoFitWidth, table->InnerWidth, table->InnerWidth == 0.0f ? " (auto)" : "");
    BulletText("CellPaddingX: %.1f, CellSpacingX: %.1f/%.1f, OuterPaddingX: %.1f", table->CellPaddingX, table->CellSpacingX1, table->CellSpacingX2, table->OuterPaddingX);
    BulletText("HoveredColumnBody: %d, HoveredColumnBorder: %d", table->HoveredColumnBody, table->HoveredColumnBorder);
    BulletText("ResizedColumn: %d, ReorderColumn: %d, HeldHeaderColumn: %d", table->ResizedColumn, table->ReorderColumn, table->HeldHeaderColumn);
    for (int n = 0; n < table->InstanceCurrent + 1; n++)
    {
        ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, n);
        BulletText("Instance %d: HoveredRow: %d, LastOuterHeight: %.2f", n, table_instance->HoveredRowLast, table_instance->LastOuterHeight);
    }
    //BulletText("BgDrawChannels: %d/%d", 0, table->BgDrawChannelUnfrozen);
    float sum_weights = 0.0f;
    for (int n = 0; n < table->ColumnsCount; n++)
        if (table->Columns[n].Flags & ImGuiTableColumnFlags_WidthStretch)
            sum_weights += table->Columns[n].StretchWeight;
    for (int n = 0; n < table->ColumnsCount; n++)
    {
        ImGuiTableColumn* column = &table->Columns[n];
        const char* name = TableGetColumnName(table, n);
        char buf[512];
        ImFormatString(buf, IM_ARRAYSIZE(buf),
            "Column %d order %d '%s': offset %+.2f to %+.2f%s\n"
            "Enabled: %d, VisibleX/Y: %d/%d, RequestOutput: %d, SkipItems: %d, DrawChannels: %d,%d\n"
            "WidthGiven: %.1f, Request/Auto: %.1f/%.1f, StretchWeight: %.3f (%.1f%%)\n"
            "MinX: %.1f, MaxX: %.1f (%+.1f), ClipRect: %.1f to %.1f (+%.1f)\n"
            "ContentWidth: %.1f,%.1f, HeadersUsed/Ideal %.1f/%.1f\n"
            "Sort: %d%s, UserID: 0x%08X, Flags: 0x%04X: %s%s%s..",
            n, column->DisplayOrder, name, column->MinX - table->WorkRect.Min.x, column->MaxX - table->WorkRect.Min.x, (n < table->FreezeColumnsRequest) ? " (Frozen)" : "",
            column->IsEnabled, column->IsVisibleX, column->IsVisibleY, column->IsRequestOutput, column->IsSkipItems, column->DrawChannelFrozen, column->DrawChannelUnfrozen,
            column->WidthGiven, column->WidthRequest, column->WidthAuto, column->StretchWeight, column->StretchWeight > 0.0f ? (column->StretchWeight / sum_weights) * 100.0f : 0.0f,
            column->MinX, column->MaxX, column->MaxX - column->MinX, column->ClipRect.Min.x, column->ClipRect.Max.x, column->ClipRect.Max.x - column->ClipRect.Min.x,
            column->ContentMaxXFrozen - column->WorkMinX, column->ContentMaxXUnfrozen - column->WorkMinX, column->ContentMaxXHeadersUsed - column->WorkMinX, column->ContentMaxXHeadersIdeal - column->WorkMinX,
            column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? " (Asc)" : (column->SortDirection == ImGuiSortDirection_Descending) ? " (Des)" : "", column->UserID, column->Flags,
            (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? "WidthStretch " : "",
            (column->Flags & ImGuiTableColumnFlags_WidthFixed) ? "WidthFixed " : "",
            (column->Flags & ImGuiTableColumnFlags_NoResize) ? "NoResize " : "");
        Bullet();
        Selectable(buf);
        if (IsItemHovered())
        {
            ImRect r(column->MinX, table->OuterRect.Min.y, column->MaxX, table->OuterRect.Max.y);
            GetForegroundDrawList()->AddRect(r.Min, r.Max, IM_COL32(255, 255, 0, 255));
        }
    }
    if (ImGuiTableSettings* settings = TableGetBoundSettings(table))
        DebugNodeTableSettings(settings);
    if (clear_settings)
        table->IsResetAllRequest = true;
    TreePop();
}

void ImGui::DebugNodeTableSettings(ImGuiTableSettings* settings)
{
    if (!TreeNode((void*)(intptr_t)settings->ID, "Settings 0x%08X (%d columns)", settings->ID, settings->ColumnsCount))
        return;
    BulletText("SaveFlags: 0x%08X", settings->SaveFlags);
    BulletText("ColumnsCount: %d (max %d)", settings->ColumnsCount, settings->ColumnsCountMax);
    for (int n = 0; n < settings->ColumnsCount; n++)
    {
        ImGuiTableColumnSettings* column_settings = &settings->GetColumnSettings()[n];
        ImGuiSortDirection sort_dir = (column_settings->SortOrder != -1) ? (ImGuiSortDirection)column_settings->SortDirection : ImGuiSortDirection_None;
        BulletText("Column %d Order %d SortOrder %d %s Vis %d %s %7.3f UserID 0x%08X",
            n, column_settings->DisplayOrder, column_settings->SortOrder,
            (sort_dir == ImGuiSortDirection_Ascending) ? "Asc" : (sort_dir == ImGuiSortDirection_Descending) ? "Des" : "---",
            column_settings->IsEnabled, column_settings->IsStretch ? "Weight" : "Width ", column_settings->WidthOrWeight, column_settings->UserID);
    }
    TreePop();
}

#else // #ifndef IMGUI_DISABLE_DEBUG_TOOLS

void ImGui::DebugNodeTable(ImGuiTable*) {}
void ImGui::DebugNodeTableSettings(ImGuiTableSettings*) {}

#endif


//-------------------------------------------------------------------------
// [SECTION] Columns, BeginColumns, EndColumns, etc.
// (This is a legacy API, prefer using BeginTable/EndTable!)
//-------------------------------------------------------------------------
// FIXME: sizing is lossy when columns width is very small (default width may turn negative etc.)
//-------------------------------------------------------------------------
// - SetWindowClipRectBeforeSetChannel() [Internal]
// - GetColumnIndex()
// - GetColumnsCount()
// - GetColumnOffset()
// - GetColumnWidth()
// - SetColumnOffset()
// - SetColumnWidth()
// - PushColumnClipRect() [Internal]
// - PushColumnsBackground() [Internal]
// - PopColumnsBackground() [Internal]
// - FindOrCreateColumns() [Internal]
// - GetColumnsID() [Internal]
// - BeginColumns()
// - NextColumn()
// - EndColumns()
// - Columns()
//-------------------------------------------------------------------------

// [Internal] Small optimization to avoid calls to PopClipRect/SetCurrentChannel/PushClipRect in sequences,
// they would meddle many times with the underlying ImDrawCmd.
// Instead, we do a preemptive overwrite of clipping rectangle _without_ altering the command-buffer and let
// the subsequent single call to SetCurrentChannel() does it things once.
void ImGui::SetWindowClipRectBeforeSetChannel(ImGuiWindow* window, const ImRect& clip_rect)
{
    ImVec4 clip_rect_vec4 = clip_rect.ToVec4();
    window->ClipRect = clip_rect;
    window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;
    window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;
}

int ImGui::GetColumnIndex()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Current : 0;
}

int ImGui::GetColumnsCount()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Count : 1;
}

float ImGui::GetColumnOffsetFromNorm(const ImGuiOldColumns* columns, float offset_norm)
{
    return offset_norm * (columns->OffMaxX - columns->OffMinX);
}

float ImGui::GetColumnNormFromOffset(const ImGuiOldColumns* columns, float offset)
{
    return offset / (columns->OffMaxX - columns->OffMinX);
}

static const float COLUMNS_HIT_RECT_HALF_THICKNESS = 4.0f;

static float GetDraggedColumnOffset(ImGuiOldColumns* columns, int column_index)
{
    // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
    // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
    IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));

    float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + ImTrunc(COLUMNS_HIT_RECT_HALF_THICKNESS * g.CurrentDpiScale) - window->Pos.x;
    x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);
    if ((columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths))
        x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

    return x;
}

float ImGui::GetColumnOffset(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns == NULL)
        return 0.0f;

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const float t = columns->Columns[column_index].OffsetNorm;
    const float x_offset = ImLerp(columns->OffMinX, columns->OffMaxX, t);
    return x_offset;
}

static float GetColumnWidthEx(ImGuiOldColumns* columns, int column_index, bool before_resize = false)
{
    if (column_index < 0)
        column_index = columns->Current;

    float offset_norm;
    if (before_resize)
        offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;
    else
        offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;
    return ImGui::GetColumnOffsetFromNorm(columns, offset_norm);
}

float ImGui::GetColumnWidth(int column_index)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns == NULL)
        return GetContentRegionAvail().x;

    if (column_index < 0)
        column_index = columns->Current;
    return GetColumnOffsetFromNorm(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);
}

void ImGui::SetColumnOffset(int column_index, float offset)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const bool preserve_width = !(columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths) && (column_index < columns->Count - 1);
    const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

    if (!(columns->Flags & ImGuiOldColumnFlags_NoForceWithinWindow))
        offset = ImMin(offset, columns->OffMaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));
    columns->Columns[column_index].OffsetNorm = GetColumnNormFromOffset(columns, offset - columns->OffMinX);

    if (preserve_width)
        SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));
}

void ImGui::SetColumnWidth(int column_index, float width)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);
}

void ImGui::PushColumnClipRect(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (column_index < 0)
        column_index = columns->Current;

    ImGuiOldColumnData* column = &columns->Columns[column_index];
    PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);
}

// Get into the columns background draw command (which is generally the same draw command as before we called BeginColumns)
void ImGui::PushColumnsBackground()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns->Count == 1)
        return;

    // Optimization: avoid SetCurrentChannel() + PushClipRect()
    columns->HostBackupClipRect = window->ClipRect;
    SetWindowClipRectBeforeSetChannel(window, columns->HostInitialClipRect);
    columns->Splitter.SetCurrentChannel(window->DrawList, 0);
}

void ImGui::PopColumnsBackground()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns->Count == 1)
        return;

    // Optimization: avoid PopClipRect() + SetCurrentChannel()
    SetWindowClipRectBeforeSetChannel(window, columns->HostBackupClipRect);
    columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);
}

ImGuiOldColumns* ImGui::FindOrCreateColumns(ImGuiWindow* window, ImGuiID id)
{
    // We have few columns per window so for now we don't need bother much with turning this into a faster lookup.
    for (int n = 0; n < window->ColumnsStorage.Size; n++)
        if (window->ColumnsStorage[n].ID == id)
            return &window->ColumnsStorage[n];

    window->ColumnsStorage.push_back(ImGuiOldColumns());
    ImGuiOldColumns* columns = &window->ColumnsStorage.back();
    columns->ID = id;
    return columns;
}

ImGuiID ImGui::GetColumnsID(const char* str_id, int columns_count)
{
    ImGuiWindow* window = GetCurrentWindow();

    // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
    // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
    PushID(0x11223347 + (str_id ? 0 : columns_count));
    ImGuiID id = window->GetID(str_id ? str_id : "columns");
    PopID();

    return id;
}

void ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiOldColumnFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    IM_ASSERT(columns_count >= 1);
    IM_ASSERT(window->DC.CurrentColumns == NULL);   // Nested columns are currently not supported

    // Acquire storage for the columns set
    ImGuiID id = GetColumnsID(str_id, columns_count);
    ImGuiOldColumns* columns = FindOrCreateColumns(window, id);
    IM_ASSERT(columns->ID == id);
    columns->Current = 0;
    columns->Count = columns_count;
    columns->Flags = flags;
    window->DC.CurrentColumns = columns;
    window->DC.NavIsScrollPushableX = false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();

    columns->HostCursorPosY = window->DC.CursorPos.y;
    columns->HostCursorMaxPosX = window->DC.CursorMaxPos.x;
    columns->HostInitialClipRect = window->ClipRect;
    columns->HostBackupParentWorkRect = window->ParentWorkRect;
    window->ParentWorkRect = window->WorkRect;

    // Set state for first column
    // We aim so that the right-most column will have the same clipping width as other after being clipped by parent ClipRect
    const float column_padding = g.Style.ItemSpacing.x;
    const float half_clip_extend_x = ImTrunc(ImMax(window->WindowPadding.x * 0.5f, window->WindowBorderSize));
    const float max_1 = window->WorkRect.Max.x + column_padding - ImMax(column_padding - window->WindowPadding.x, 0.0f);
    const float max_2 = window->WorkRect.Max.x + half_clip_extend_x;
    columns->OffMinX = window->DC.Indent.x - column_padding + ImMax(column_padding - window->WindowPadding.x, 0.0f);
    columns->OffMaxX = ImMax(ImMin(max_1, max_2) - window->Pos.x, columns->OffMinX + 1.0f);
    columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;

    // Clear data if columns count changed
    if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)
        columns->Columns.resize(0);

    // Initialize default widths
    columns->IsFirstFrame = (columns->Columns.Size == 0);
    if (columns->Columns.Size == 0)
    {
        columns->Columns.reserve(columns_count + 1);
        for (int n = 0; n < columns_count + 1; n++)
        {
            ImGuiOldColumnData column;
            column.OffsetNorm = n / (float)columns_count;
            columns->Columns.push_back(column);
        }
    }

    for (int n = 0; n < columns_count; n++)
    {
        // Compute clipping rectangle
        ImGuiOldColumnData* column = &columns->Columns[n];
        float clip_x1 = IM_ROUND(window->Pos.x + GetColumnOffset(n));
        float clip_x2 = IM_ROUND(window->Pos.x + GetColumnOffset(n + 1) - 1.0f);
        column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);
        column->ClipRect.ClipWithFull(window->ClipRect);
    }

    if (columns->Count > 1)
    {
        columns->Splitter.Split(window->DrawList, 1 + columns->Count);
        columns->Splitter.SetCurrentChannel(window->DrawList, 1);
        PushColumnClipRect(0);
    }

    // We don't generally store Indent.x inside ColumnsOffset because it may be manipulated by the user.
    float offset_0 = GetColumnOffset(columns->Current);
    float offset_1 = GetColumnOffset(columns->Current + 1);
    float width = offset_1 - offset_0;
    PushItemWidth(width * 0.65f);
    window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);
    window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
    window->WorkRect.Max.y = window->ContentRegionRect.Max.y;
}

void ImGui::NextColumn()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems || window->DC.CurrentColumns == NULL)
        return;

    ImGuiContext& g = *GImGui;
    ImGuiOldColumns* columns = window->DC.CurrentColumns;

    if (columns->Count == 1)
    {
        window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
        IM_ASSERT(columns->Current == 0);
        return;
    }

    // Next column
    if (++columns->Current == columns->Count)
        columns->Current = 0;

    PopItemWidth();

    // Optimization: avoid PopClipRect() + SetCurrentChannel() + PushClipRect()
    // (which would needlessly attempt to update commands in the wrong channel, then pop or overwrite them),
    ImGuiOldColumnData* column = &columns->Columns[columns->Current];
    SetWindowClipRectBeforeSetChannel(window, column->ClipRect);
    columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);

    const float column_padding = g.Style.ItemSpacing.x;
    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    if (columns->Current > 0)
    {
        // Columns 1+ ignore IndentX (by canceling it out)
        // FIXME-COLUMNS: Unnecessary, could be locked?
        window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + column_padding;
    }
    else
    {
        // New row/line: column 0 honor IndentX.
        window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);
        window->DC.IsSameLine = false;
        columns->LineMinY = columns->LineMaxY;
    }
    window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->DC.CursorPos.y = columns->LineMinY;
    window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);
    window->DC.CurrLineTextBaseOffset = 0.0f;

    // FIXME-COLUMNS: Share code with BeginColumns() - move code on columns setup.
    float offset_0 = GetColumnOffset(columns->Current);
    float offset_1 = GetColumnOffset(columns->Current + 1);
    float width = offset_1 - offset_0;
    PushItemWidth(width * 0.65f);
    window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
}

void ImGui::EndColumns()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    PopItemWidth();
    if (columns->Count > 1)
    {
        PopClipRect();
        columns->Splitter.Merge(window->DrawList);
    }

    const ImGuiOldColumnFlags flags = columns->Flags;
    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    window->DC.CursorPos.y = columns->LineMaxY;
    if (!(flags & ImGuiOldColumnFlags_GrowParentContentsSize))
        window->DC.CursorMaxPos.x = columns->HostCursorMaxPosX;  // Restore cursor max pos, as columns don't grow parent

    // Draw columns borders and handle resize
    // The IsBeingResized flag ensure we preserve pre-resize columns width so back-and-forth are not lossy
    bool is_being_resized = false;
    if (!(flags & ImGuiOldColumnFlags_NoBorder) && !window->SkipItems)
    {
        // We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.
        const float y1 = ImMax(columns->HostCursorPosY, window->ClipRect.Min.y);
        const float y2 = ImMin(window->DC.CursorPos.y, window->ClipRect.Max.y);
        int dragging_column = -1;
        for (int n = 1; n < columns->Count; n++)
        {
            ImGuiOldColumnData* column = &columns->Columns[n];
            float x = window->Pos.x + GetColumnOffset(n);
            const ImGuiID column_id = columns->ID + ImGuiID(n);
            const float column_hit_hw = ImTrunc(COLUMNS_HIT_RECT_HALF_THICKNESS * g.CurrentDpiScale);
            const ImRect column_hit_rect(ImVec2(x - column_hit_hw, y1), ImVec2(x + column_hit_hw, y2));
            if (!ItemAdd(column_hit_rect, column_id, NULL, ImGuiItemFlags_NoNav))
                continue;

            bool hovered = false, held = false;
            if (!(flags & ImGuiOldColumnFlags_NoResize))
            {
                ButtonBehavior(column_hit_rect, column_id, &hovered, &held);
                if (hovered || held)
                    SetMouseCursor(ImGuiMouseCursor_ResizeEW);
                if (held && !(column->Flags & ImGuiOldColumnFlags_NoResize))
                    dragging_column = n;
            }

            // Draw column
            const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
            const float xi = IM_TRUNC(x);
            window->DrawList->AddLine(ImVec2(xi, y1 + 1.0f), ImVec2(xi, y2), col);
        }

        // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
        if (dragging_column != -1)
        {
            if (!columns->IsBeingResized)
                for (int n = 0; n < columns->Count + 1; n++)
                    columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;
            columns->IsBeingResized = is_being_resized = true;
            float x = GetDraggedColumnOffset(columns, dragging_column);
            SetColumnOffset(dragging_column, x);
        }
    }
    columns->IsBeingResized = is_being_resized;

    window->WorkRect = window->ParentWorkRect;
    window->ParentWorkRect = columns->HostBackupParentWorkRect;
    window->DC.CurrentColumns = NULL;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorPos.x = IM_TRUNC(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    NavUpdateCurrentWindowIsScrollPushableX();
}

void ImGui::Columns(int columns_count, const char* id, bool borders)
{
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(columns_count >= 1);

    ImGuiOldColumnFlags flags = (borders ? 0 : ImGuiOldColumnFlags_NoBorder);
    //flags |= ImGuiOldColumnFlags_NoPreserveWidths; // NB: Legacy behavior
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)
        return;

    if (columns != NULL)
        EndColumns();

    if (columns_count != 1)
        BeginColumns(id, columns_count, flags);
}

//-------------------------------------------------------------------------

#endif // #ifndef IMGUI_DISABLE



================================================
FILE: ImGui/imstb_rectpack.h
================================================
// [DEAR IMGUI]
// This is a slightly modified version of stb_rect_pack.h 1.01.
// Grep for [DEAR IMGUI] to find the changes.
// 
// stb_rect_pack.h - v1.01 - public domain - rectangle packing
// Sean Barrett 2014
//
// Useful for e.g. packing rectangular textures into an atlas.
// Does not do rotation.
//
// Before #including,
//
//    #define STB_RECT_PACK_IMPLEMENTATION
//
// in the file that you want to have the implementation.
//
// Not necessarily the awesomest packing method, but better than
// the totally naive one in stb_truetype (which is primarily what
// this is meant to replace).
//
// Has only had a few tests run, may have issues.
//
// More docs to come.
//
// No memory allocations; uses qsort() and assert() from stdlib.
// Can override those by defining STBRP_SORT and STBRP_ASSERT.
//
// This library currently uses the Skyline Bottom-Left algorithm.
//
// Please note: better rectangle packers are welcome! Please
// implement them to the same API, but with a different init
// function.
//
// Credits
//
//  Library
//    Sean Barrett
//  Minor features
//    Martins Mozeiko
//    github:IntellectualKitty
//
//  Bugfixes / warning fixes
//    Jeremy Jaussaud
//    Fabian Giesen
//
// Version history:
//
//     1.01  (2021-07-11)  always use large rect mode, expose STBRP__MAXVAL in public section
//     1.00  (2019-02-25)  avoid small space waste; gracefully fail too-wide rectangles
//     0.99  (2019-02-07)  warning fixes
//     0.11  (2017-03-03)  return packing success/fail result
//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings
//     0.09  (2016-08-27)  fix compiler warnings
//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)
//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)
//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort
//     0.05:  added STBRP_ASSERT to allow replacing assert
//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support
//     0.01:  initial release
//
// LICENSE
//
//   See end of file for license information.

//////////////////////////////////////////////////////////////////////////////
//
//       INCLUDE SECTION
//

#ifndef STB_INCLUDE_STB_RECT_PACK_H
#define STB_INCLUDE_STB_RECT_PACK_H

#define STB_RECT_PACK_VERSION  1

#ifdef STBRP_STATIC
#define STBRP_DEF static
#else
#define STBRP_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct stbrp_context stbrp_context;
typedef struct stbrp_node    stbrp_node;
typedef struct stbrp_rect    stbrp_rect;

typedef int            stbrp_coord;

#define STBRP__MAXVAL  0x7fffffff
// Mostly for internal use, but this is the maximum supported coordinate value.

STBRP_DEF int stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);
// Assign packed locations to rectangles. The rectangles are of type
// 'stbrp_rect' defined below, stored in the array 'rects', and there
// are 'num_rects' many of them.
//
// Rectangles which are successfully packed have the 'was_packed' flag
// set to a non-zero value and 'x' and 'y' store the minimum location
// on each axis (i.e. bottom-left in cartesian coordinates, top-left
// if you imagine y increasing downwards). Rectangles which do not fit
// have the 'was_packed' flag set to 0.
//
// You should not try to access the 'rects' array from another thread
// while this function is running, as the function temporarily reorders
// the array while it executes.
//
// To pack into another rectangle, you need to call stbrp_init_target
// again. To continue packing into the same rectangle, you can call
// this function again. Calling this multiple times with multiple rect
// arrays will probably produce worse packing results than calling it
// a single time with the full rectangle array, but the option is
// available.
//
// The function returns 1 if all of the rectangles were successfully
// packed and 0 otherwise.

struct stbrp_rect
{
   // reserved for your use:
   int            id;

   // input:
   stbrp_coord    w, h;

   // output:
   stbrp_coord    x, y;
   int            was_packed;  // non-zero if valid packing

}; // 16 bytes, nominally


STBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);
// Initialize a rectangle packer to:
//    pack a rectangle that is 'width' by 'height' in dimensions
//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long
//
// You must call this function every time you start packing into a new target.
//
// There is no "shutdown" function. The 'nodes' memory must stay valid for
// the following stbrp_pack_rects() call (or calls), but can be freed after
// the call (or calls) finish.
//
// Note: to guarantee best results, either:
//       1. make sure 'num_nodes' >= 'width'
//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'
//
// If you don't do either of the above things, widths will be quantized to multiples
// of small integers to guarantee the algorithm doesn't run out of temporary storage.
//
// If you do #2, then the non-quantized algorithm will be used, but the algorithm
// may run out of temporary storage and be unable to pack some rectangles.

STBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);
// Optionally call this function after init but before doing any packing to
// change the handling of the out-of-temp-memory scenario, described above.
// If you call init again, this will be reset to the default (false).


STBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);
// Optionally select which packing heuristic the library should use. Different
// heuristics will produce better/worse results for different data sets.
// If you call init again, this will be reset to the default.

enum
{
   STBRP_HEURISTIC_Skyline_default=0,
   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,
   STBRP_HEURISTIC_Skyline_BF_sortHeight
};


//////////////////////////////////////////////////////////////////////////////
//
// the details of the following structures don't matter to you, but they must
// be visible so you can handle the memory allocations for them

struct stbrp_node
{
   stbrp_coord  x,y;
   stbrp_node  *next;
};

struct stbrp_context
{
   int width;
   int height;
   int align;
   int init_mode;
   int heuristic;
   int num_nodes;
   stbrp_node *active_head;
   stbrp_node *free_head;
   stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'
};

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////
//
//     IMPLEMENTATION SECTION
//

#ifdef STB_RECT_PACK_IMPLEMENTATION
#ifndef STBRP_SORT
#include <stdlib.h>
#define STBRP_SORT qsort
#endif

#ifndef STBRP_ASSERT
#include <assert.h>
#define STBRP_ASSERT assert
#endif

#ifdef _MSC_VER
#define STBRP__NOTUSED(v)  (void)(v)
#define STBRP__CDECL       __cdecl
#else
#define STBRP__NOTUSED(v)  (void)sizeof(v)
#define STBRP__CDECL
#endif

enum
{
   STBRP__INIT_skyline = 1
};

STBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)
{
   switch (context->init_mode) {
      case STBRP__INIT_skyline:
         STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);
         context->heuristic = heuristic;
         break;
      default:
         STBRP_ASSERT(0);
   }
}

STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)
{
   if (allow_out_of_mem)
      // if it's ok to run out of memory, then don't bother aligning them;
      // this gives better packing, but may fail due to OOM (even though
      // the rectangles easily fit). @TODO a smarter approach would be to only
      // quantize once we've hit OOM, then we could get rid of this parameter.
      context->align = 1;
   else {
      // if it's not ok to run out of memory, then quantize the widths
      // so that num_nodes is always enough nodes.
      //
      // I.e. num_nodes * align >= width
      //                  align >= width / num_nodes
      //                  align = ceil(width/num_nodes)

      context->align = (context->width + context->num_nodes-1) / context->num_nodes;
   }
}

STBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)
{
   int i;

   for (i=0; i < num_nodes-1; ++i)
      nodes[i].next = &nodes[i+1];
   nodes[i].next = NULL;
   context->init_mode = STBRP__INIT_skyline;
   context->heuristic = STBRP_HEURISTIC_Skyline_default;
   context->free_head = &nodes[0];
   context->active_head = &context->extra[0];
   context->width = width;
   context->height = height;
   context->num_nodes = num_nodes;
   stbrp_setup_allow_out_of_mem(context, 0);

   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
   context->extra[0].x = 0;
   context->extra[0].y = 0;
   context->extra[0].next = &context->extra[1];
   context->extra[1].x = (stbrp_coord) width;
   context->extra[1].y = (1<<30);
   context->extra[1].next = NULL;
}

// find minimum y position if it starts at x1
static int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)
{
   stbrp_node *node = first;
   int x1 = x0 + width;
   int min_y, visited_width, waste_area;

   STBRP__NOTUSED(c);

   STBRP_ASSERT(first->x <= x0);

   #if 0
   // skip in case we're past the node
   while (node->next->x <= x0)
      ++node;
   #else
   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
   #endif

   STBRP_ASSERT(node->x <= x0);

   min_y = 0;
   waste_area = 0;
   visited_width = 0;
   while (node->x < x1) {
      if (node->y > min_y) {
         // raise min_y higher.
         // we've accounted for all waste up to min_y,
         // but we'll now add more waste for everything we've visted
         waste_area += visited_width * (node->y - min_y);
         min_y = node->y;
         // the first time through, visited_width might be reduced
         if (node->x < x0)
            visited_width += node->next->x - x0;
         else
            visited_width += node->next->x - node->x;
      } else {
         // add waste area
         int under_width = node->next->x - node->x;
         if (under_width + visited_width > width)
            under_width = width - visited_width;
         waste_area += under_width * (min_y - node->y);
         visited_width += under_width;
      }
      node = node->next;
   }

   *pwaste = waste_area;
   return min_y;
}

typedef struct
{
   int x,y;
   stbrp_node **prev_link;
} stbrp__findresult;

static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)
{
   int best_waste = (1<<30), best_x, best_y = (1 << 30);
   stbrp__findresult fr;
   stbrp_node **prev, *node, *tail, **best = NULL;

   // align to multiple of c->align
   width = (width + c->align - 1);
   width -= width % c->align;
   STBRP_ASSERT(width % c->align == 0);

   // if it can't possibly fit, bail immediately
   if (width > c->width || height > c->height) {
      fr.prev_link = NULL;
      fr.x = fr.y = 0;
      return fr;
   }

   node = c->active_head;
   prev = &c->active_head;
   while (node->x + width <= c->width) {
      int y,waste;
      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);
      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL
         // bottom left
         if (y < best_y) {
            best_y = y;
            best = prev;
         }
      } else {
         // best-fit
         if (y + height <= c->height) {
            // can only use it if it first vertically
            if (y < best_y || (y == best_y && waste < best_waste)) {
               best_y = y;
               best_waste = waste;
               best = prev;
            }
         }
      }
      prev = &node->next;
      node = node->next;
   }

   best_x = (best == NULL) ? 0 : (*best)->x;

   // if doing best-fit (BF), we also have to try aligning right edge to each node position
   //
   // e.g, if fitting
   //
   //     ____________________
   //    |____________________|
   //
   //            into
   //
   //   |                         |
   //   |             ____________|
   //   |____________|
   //
   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
   //
   // This makes BF take about 2x the time

   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
      tail = c->active_head;
      node = c->active_head;
      prev = &c->active_head;
      // find first node that's admissible
      while (tail->x < width)
         tail = tail->next;
      while (tail) {
         int xpos = tail->x - width;
         int y,waste;
         STBRP_ASSERT(xpos >= 0);
         // find the left position that matches this
         while (node->next->x <= xpos) {
            prev = &node->next;
            node = node->next;
         }
         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);
         if (y + height <= c->height) {
            if (y <= best_y) {
               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {
                  best_x = xpos;
                  //STBRP_ASSERT(y <= best_y); [DEAR IMGUI]
                  best_y = y;
                  best_waste = waste;
                  best = prev;
               }
            }
         }
         tail = tail->next;
      }
   }

   fr.prev_link = best;
   fr.x = best_x;
   fr.y = best_y;
   return fr;
}

static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)
{
   // find best position according to heuristic
   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);
   stbrp_node *node, *cur;

   // bail if:
   //    1. it failed
   //    2. the best node doesn't fit (we don't always check this)
   //    3. we're out of memory
   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {
      res.prev_link = NULL;
      return res;
   }

   // on success, create new node
   node = context->free_head;
   node->x = (stbrp_coord) res.x;
   node->y = (stbrp_coord) (res.y + height);

   context->free_head = node->next;

   // insert the new node into the right starting point, and
   // let 'cur' point to the remaining nodes needing to be
   // stiched back in

   cur = *res.prev_link;
   if (cur->x < res.x) {
      // preserve the existing one, so start testing with the next one
      stbrp_node *next = cur->next;
      cur->next = node;
      cur = next;
   } else {
      *res.prev_link = node;
   }

   // from here, traverse cur and free the nodes, until we get to one
   // that shouldn't be freed
   while (cur->next && cur->next->x <= res.x + width) {
      stbrp_node *next = cur->next;
      // move the current node to the free list
      cur->next = context->free_head;
      context->free_head = cur;
      cur = next;
   }

   // stitch the list back in
   node->next = cur;

   if (cur->x < res.x + width)
      cur->x = (stbrp_coord) (res.x + width);

#ifdef _DEBUG
   cur = context->active_head;
   while (cur->x < context->width) {
      STBRP_ASSERT(cur->x < cur->next->x);
      cur = cur->next;
   }
   STBRP_ASSERT(cur->next == NULL);

   {
      int count=0;
      cur = context->active_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      cur = context->free_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      STBRP_ASSERT(count == context->num_nodes+2);
   }
#endif

   return res;
}

static int STBRP__CDECL rect_height_compare(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   if (p->h > q->h)
      return -1;
   if (p->h < q->h)
      return  1;
   return (p->w > q->w) ? -1 : (p->w < q->w);
}

static int STBRP__CDECL rect_original_order(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
}

STBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)
{
   int i, all_rects_packed = 1;

   // we use the 'was_packed' field internally to allow sorting/unsorting
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = i;
   }

   // sort according to heuristic
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

   for (i=0; i < num_rects; ++i) {
      if (rects[i].w == 0 || rects[i].h == 0) {
         rects[i].x = rects[i].y = 0;  // empty rect needs no space
      } else {
         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
         if (fr.prev_link) {
            rects[i].x = (stbrp_coord) fr.x;
            rects[i].y = (stbrp_coord) fr.y;
         } else {
            rects[i].x = rects[i].y = STBRP__MAXVAL;
         }
      }
   }

   // unsort
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);

   // set was_packed flags and all_rects_packed status
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
      if (!rects[i].was_packed)
         all_rects_packed = 0;
   }

   // return the all_rects_packed status
   return all_rects_packed;
}
#endif

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/



================================================
FILE: ImGui/imstb_textedit.h
================================================
// [DEAR IMGUI]
// This is a slightly modified version of stb_textedit.h 1.14.
// Those changes would need to be pushed into nothings/stb:
// - Fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)
// - Fix in stb_textedit_find_charpos to handle last line (see https://github.com/ocornut/imgui/issues/6000 + #6783)
// - Added name to struct or it may be forward declared in our code.
// - Added UTF-8 support (see https://github.com/nothings/stb/issues/188 + https://github.com/ocornut/imgui/pull/7925)
// Grep for [DEAR IMGUI] to find the changes.
// - Also renamed macros used or defined outside of IMSTB_TEXTEDIT_IMPLEMENTATION block from STB_TEXTEDIT_* to IMSTB_TEXTEDIT_*

// stb_textedit.h - v1.14  - public domain - Sean Barrett
// Development of this library was sponsored by RAD Game Tools
//
// This C header file implements the guts of a multi-line text-editing
// widget; you implement display, word-wrapping, and low-level string
// insertion/deletion, and stb_textedit will map user inputs into
// insertions & deletions, plus updates to the cursor position,
// selection state, and undo state.
//
// It is intended for use in games and other systems that need to build
// their own custom widgets and which do not have heavy text-editing
// requirements (this library is not recommended for use for editing large
// texts, as its performance does not scale and it has limited undo).
//
// Non-trivial behaviors are modelled after Windows text controls.
//
//
// LICENSE
//
// See end of file for license information.
//
//
// DEPENDENCIES
//
// Uses the C runtime function 'memmove', which you can override
// by defining IMSTB_TEXTEDIT_memmove before the implementation.
// Uses no other functions. Performs no runtime allocations.
//
//
// VERSION HISTORY
//
//   1.14 (2021-07-11) page up/down, various fixes
//   1.13 (2019-02-07) fix bug in undo size management
//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash
//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield
//   1.10 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.9  (2016-08-27) customizable move-by-word
//   1.8  (2016-04-02) better keyboard handling when mouse button is down
//   1.7  (2015-09-13) change y range handling in case baseline is non-0
//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove
//   1.5  (2014-09-10) add support for secondary keys for OS X
//   1.4  (2014-08-17) fix signed/unsigned warnings
//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary
//   1.2  (2014-05-27) fix some RAD types that had crept into the new code
//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )
//   1.0  (2012-07-26) improve documentation, initial public release
//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode
//   0.2  (2011-11-28) fixes to undo/redo
//   0.1  (2010-07-08) initial version
//
// ADDITIONAL CONTRIBUTORS
//
//   Ulf Winklemann: move-by-word in 1.1
//   Fabian Giesen: secondary key inputs in 1.5
//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6
//   Louis Schnellbach: page up/down in 1.14
//
//   Bugfixes:
//      Scott Graham
//      Daniel Keller
//      Omar Cornut
//      Dan Thompson
//
// USAGE
//
// This file behaves differently depending on what symbols you define
// before including it.
//
//
// Header-file mode:
//
//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,
//   it will operate in "header file" mode. In this mode, it declares a
//   single public symbol, STB_TexteditState, which encapsulates the current
//   state of a text widget (except for the string, which you will store
//   separately).
//
//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a
//   primitive type that defines a single character (e.g. char, wchar_t, etc).
//
//   To save space or increase undo-ability, you can optionally define the
//   following things that are used by the undo system:
//
//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position
//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
//   If you don't define these, they are set to permissive types and
//   moderate sizes. The undo system does no memory allocations, so
//   it grows STB_TexteditState by the worst-case storage which is (in bytes):
//
//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATECOUNT
//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHARCOUNT
//
//
// Implementation mode:
//
//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it
//   will compile the implementation of the text edit widget, depending
//   on a large number of symbols which must be defined before the include.
//
//   The implementation is defined only as static functions. You will then
//   need to provide your own APIs in the same file which will access the
//   static functions.
//
//   The basic concept is that you provide a "string" object which
//   behaves like an array of characters. stb_textedit uses indices to
//   refer to positions in the string, implicitly representing positions
//   in the displayed textedit. This is true for both plain text and
//   rich text; even with rich text stb_truetype interacts with your
//   code as if there was an array of all the displayed characters.
//
// Symbols that must be the same in header-file and implementation mode:
//
//     STB_TEXTEDIT_CHARTYPE             the character type
//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position
//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
// Symbols you must define for implementation mode:
//
//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,
//                                      typically this is a wrapper object with other data you need
//
//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))
//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters
//                                        starting from character #n (see discussion below)
//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character
//                                        to the xpos of the i+1'th char for a line of characters
//                                        starting at character #n (i.e. accounts for kerning
//                                        with previous char)
//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character
//                                        (return type is int, -1 means not valid to insert)
//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based
//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize
//                                        as manually wordwrapping for end-of-line positioning
//
//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i
//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)
//
//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key
//
//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left
//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right
//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up
//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down
//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page
//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME
//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END
//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME
//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END
//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor
//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor
//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo
//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo
//
// Optional:
//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode
//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),
//                                          required for default WORDLEFT/WORDRIGHT handlers
//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to
//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to
//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT
//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT
//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line
//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line
//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text
//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text
//
// Keyboard input must be encoded as a single integer value; e.g. a character code
// and some bitflags that represent shift states. to simplify the interface, SHIFT must
// be a bitflag, so we can test the shifted state of cursor movements to allow selection,
// i.e. (STB_TEXTEDIT_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.
//
// You can encode other things, such as CONTROL or ALT, in additional bits, and
// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,
// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN
// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,
// and I pass both WM_KEYDOWN and WM_CHAR events to the "key" function in the
// API below. The control keys will only match WM_KEYDOWN events because of the
// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN
// bit so it only decodes WM_CHAR events.
//
// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed
// row of characters assuming they start on the i'th character--the width and
// the height and the number of characters consumed. This allows this library
// to traverse the entire layout incrementally. You need to compute word-wrapping
// here.
//
// Each textfield keeps its own insert mode state, which is not how normal
// applications work. To keep an app-wide insert mode, update/copy the
// "insert_mode" field of STB_TexteditState before/after calling API functions.
//
// API
//
//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
//
//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)
//    void stb_textedit_text(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int text_len)
//
//    Each of these functions potentially updates the string and updates the
//    state.
//
//      initialize_state:
//          set the textedit state to a known good default state when initially
//          constructing the textedit.
//
//      click:
//          call this with the mouse x,y on a mouse down; it will update the cursor
//          and reset the selection start/end to the cursor point. the x,y must
//          be relative to the text widget, with (0,0) being the top left.
//
//      drag:
//          call this with the mouse x,y on a mouse drag/up; it will update the
//          cursor and the selection end point
//
//      cut:
//          call this to delete the current selection; returns true if there was
//          one. you should FIRST copy the current selection to the system paste buffer.
//          (To copy, just copy the current selection out of the string yourself.)
//
//      paste:
//          call this to paste text at the current cursor point or over the current
//          selection if there is one.
//
//      key:
//          call this for keyboard inputs sent to the textfield. you can use it
//          for "key down" events or for "translated" key events. if you need to
//          do both (as in Win32), or distinguish Unicode characters from control
//          inputs, set a high bit to distinguish the two; then you can define the
//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit
//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is
//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to
//          anything other type you want before including.
//          if the STB_TEXTEDIT_KEYTOTEXT function is defined, selected keys are
//          transformed into text and stb_textedit_text() is automatically called.
//
//      text: [DEAR IMGUI] added 2024-09
//          call this to text inputs sent to the textfield.
//
//
//   When rendering, you can read the cursor position and selection state from
//   the STB_TexteditState.
//
//
// Notes:
//
// This is designed to be usable in IMGUI, so it allows for the possibility of
// running in an IMGUI that has NOT cached the multi-line layout. For this
// reason, it provides an interface that is compatible with computing the
// layout incrementally--we try to make sure we make as few passes through
// as possible. (For example, to locate the mouse pointer in the text, we
// could define functions that return the X and Y positions of characters
// and binary search Y and then X, but if we're doing dynamic layout this
// will run the layout algorithm many times, so instead we manually search
// forward in one pass. Similar logic applies to e.g. up-arrow and
// down-arrow movement.)
//
// If it's run in a widget that *has* cached the layout, then this is less
// efficient, but it's not horrible on modern computers. But you wouldn't
// want to edit million-line files with it.


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Header-file mode
////
////

#ifndef INCLUDE_IMSTB_TEXTEDIT_H
#define INCLUDE_IMSTB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////
//
//     STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
//

#ifndef IMSTB_TEXTEDIT_UNDOSTATECOUNT
#define IMSTB_TEXTEDIT_UNDOSTATECOUNT   99
#endif
#ifndef IMSTB_TEXTEDIT_UNDOCHARCOUNT
#define IMSTB_TEXTEDIT_UNDOCHARCOUNT   999
#endif
#ifndef IMSTB_TEXTEDIT_CHARTYPE
#define IMSTB_TEXTEDIT_CHARTYPE        int
#endif
#ifndef IMSTB_TEXTEDIT_POSITIONTYPE
#define IMSTB_TEXTEDIT_POSITIONTYPE    int
#endif

typedef struct
{
   // private data
   IMSTB_TEXTEDIT_POSITIONTYPE  where;
   IMSTB_TEXTEDIT_POSITIONTYPE  insert_length;
   IMSTB_TEXTEDIT_POSITIONTYPE  delete_length;
   int                        char_storage;
} StbUndoRecord;

typedef struct
{
   // private data
   StbUndoRecord          undo_rec [IMSTB_TEXTEDIT_UNDOSTATECOUNT];
   IMSTB_TEXTEDIT_CHARTYPE  undo_char[IMSTB_TEXTEDIT_UNDOCHARCOUNT];
   short undo_point, redo_point;
   int undo_char_point, redo_char_point;
} StbUndoState;

typedef struct STB_TexteditState
{
   /////////////////////
   //
   // public data
   //

   int cursor;
   // position of the text cursor within the string

   int select_start;          // selection start point
   int select_end;
   // selection start and end point in characters; if equal, no selection.
   // note that start may be less than or greater than end (e.g. when
   // dragging the mouse, start is where the initial click was, and you
   // can drag in either direction)

   unsigned char insert_mode;
   // each textfield keeps its own insert mode state. to keep an app-wide
   // insert mode, copy this value in/out of the app state

   int row_count_per_page;
   // page size in number of row.
   // this value MUST be set to >0 for pageup or pagedown in multilines documents.

   /////////////////////
   //
   // private data
   //
   unsigned char cursor_at_end_of_line; // not implemented yet
   unsigned char initialized;
   unsigned char has_preferred_x;
   unsigned char single_line;
   unsigned char padding1, padding2, padding3;
   float preferred_x; // this determines where the cursor up/down tries to seek to along x
   StbUndoState undostate;
} STB_TexteditState;


////////////////////////////////////////////////////////////////////////
//
//     StbTexteditRow
//
// Result of layout query, used by stb_textedit to determine where
// the text in each row is.

// result of layout query
typedef struct
{
   float x0,x1;             // starting x location, end x location (allows for align=right, etc)
   float baseline_y_delta;  // position of baseline relative to previous row's baseline
   float ymin,ymax;         // height of row above and below baseline
   int num_chars;
} StbTexteditRow;
#endif //INCLUDE_IMSTB_TEXTEDIT_H


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Implementation mode
////
////


// implementation isn't include-guarded, since it might have indirectly
// included just the "header" portion
#ifdef IMSTB_TEXTEDIT_IMPLEMENTATION

#ifndef IMSTB_TEXTEDIT_memmove
#include <string.h>
#define IMSTB_TEXTEDIT_memmove memmove
#endif


/////////////////////////////////////////////////////////////////////////////
//
//      Mouse input handling
//

// traverse the layout to locate the nearest character to a display position
static int stb_text_locate_coord(IMSTB_TEXTEDIT_STRING *str, float x, float y)
{
   StbTexteditRow r;
   int n = STB_TEXTEDIT_STRINGLEN(str);
   float base_y = 0, prev_x;
   int i=0, k;

   r.x0 = r.x1 = 0;
   r.ymin = r.ymax = 0;
   r.num_chars = 0;

   // search rows to find one that straddles 'y'
   while (i < n) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (r.num_chars <= 0)
         return n;

      if (i==0 && y < base_y + r.ymin)
         return 0;

      if (y < base_y + r.ymax)
         break;

      i += r.num_chars;
      base_y += r.baseline_y_delta;
   }

   // below all text, return 'after' last character
   if (i >= n)
      return n;

   // check if it's before the beginning of the line
   if (x < r.x0)
      return i;

   // check if it's before the end of the line
   if (x < r.x1) {
      // search characters in row for one that straddles 'x'
      prev_x = r.x0;
      for (k=0; k < r.num_chars; k = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, i + k) - i) {
         float w = STB_TEXTEDIT_GETWIDTH(str, i, k);
         if (x < prev_x+w) {
            if (x < prev_x+w/2)
               return k+i;
            else
               return IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, i + k);
         }
         prev_x += w;
      }
      // shouldn't happen, but if it does, fall through to end-of-line case
   }

   // if the last character is a newline, return that. otherwise return 'after' the last character
   if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)
      return i+r.num_chars-1;
   else
      return i+r.num_chars;
}

// API click: on mouse down, move the cursor to the clicked location, and reset the selection
static void stb_textedit_click(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   state->cursor = stb_text_locate_coord(str, x, y);
   state->select_start = state->cursor;
   state->select_end = state->cursor;
   state->has_preferred_x = 0;
}

// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location
static void stb_textedit_drag(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   int p = 0;

   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   if (state->select_start == state->select_end)
      state->select_start = state->cursor;

   p = stb_text_locate_coord(str, x, y);
   state->cursor = state->select_end = p;
}

/////////////////////////////////////////////////////////////////////////////
//
//      Keyboard input handling
//

// forward declarations
static void stb_text_undo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_redo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_makeundo_delete(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_replace(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);

typedef struct
{
   float x,y;    // position of n'th character
   float height; // height of line
   int first_char, length; // first char of row, and length
   int prev_first;  // first char of previous row
} StbFindState;

// find the x/y location of a character, and remember info about the previous row in
// case we get a move-up event (for page up, we'll have to rescan)
static void stb_textedit_find_charpos(StbFindState *find, IMSTB_TEXTEDIT_STRING *str, int n, int single_line)
{
   StbTexteditRow r;
   int prev_start = 0;
   int z = STB_TEXTEDIT_STRINGLEN(str);
   int i=0, first;

   if (n == z && single_line) {
      // special case if it's at the end (may not be needed?)
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      find->y = 0;
      find->first_char = 0;
      find->length = z;
      find->height = r.ymax - r.ymin;
      find->x = r.x1;
      return;
   }

   // search rows to find the one that straddles character n
   find->y = 0;

   for(;;) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (n < i + r.num_chars)
         break;
      if (i + r.num_chars == z && z > 0 && STB_TEXTEDIT_GETCHAR(str, z - 1) != STB_TEXTEDIT_NEWLINE)  // [DEAR IMGUI] special handling for last line
         break;   // [DEAR IMGUI]
      prev_start = i;
      i += r.num_chars;
      find->y += r.baseline_y_delta;
      if (i == z) // [DEAR IMGUI]
      {
         r.num_chars = 0; // [DEAR IMGUI]
         break;   // [DEAR IMGUI]
      }
   }

   find->first_char = first = i;
   find->length = r.num_chars;
   find->height = r.ymax - r.ymin;
   find->prev_first = prev_start;

   // now scan to find xpos
   find->x = r.x0;
   for (i=0; first+i < n; i = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, first + i) - first)
      find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);
}

#define STB_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)

// make the selection/cursor state valid if client altered the string
static void stb_textedit_clamp(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   int n = STB_TEXTEDIT_STRINGLEN(str);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start > n) state->select_start = n;
      if (state->select_end   > n) state->select_end = n;
      // if clamping forced them to be equal, move the cursor to match
      if (state->select_start == state->select_end)
         state->cursor = state->select_start;
   }
   if (state->cursor > n) state->cursor = n;
}

// delete characters while updating undo
static void stb_textedit_delete(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)
{
   stb_text_makeundo_delete(str, state, where, len);
   STB_TEXTEDIT_DELETECHARS(str, where, len);
   state->has_preferred_x = 0;
}

// delete the section
static void stb_textedit_delete_selection(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   stb_textedit_clamp(str, state);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start < state->select_end) {
         stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);
         state->select_end = state->cursor = state->select_start;
      } else {
         stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);
         state->select_start = state->cursor = state->select_end;
      }
      state->has_preferred_x = 0;
   }
}

// canoncialize the selection so start <= end
static void stb_textedit_sortselection(STB_TexteditState *state)
{
   if (state->select_end < state->select_start) {
      int temp = state->select_end;
      state->select_end = state->select_start;
      state->select_start = temp;
   }
}

// move cursor to first character of selection
static void stb_textedit_move_to_first(STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      state->cursor = state->select_start;
      state->select_end = state->select_start;
      state->has_preferred_x = 0;
   }
}

// move cursor to last character of selection
static void stb_textedit_move_to_last(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      stb_textedit_clamp(str, state);
      state->cursor = state->select_end;
      state->select_start = state->select_end;
      state->has_preferred_x = 0;
   }
}

// [DEAR IMGUI]
// Functions must be implemented for UTF8 support
// Code in this file that uses those functions is modified for [DEAR IMGUI] and deviates from the original stb_textedit.
// There is not necessarily a '[DEAR IMGUI]' at the usage sites.
#ifndef IMSTB_TEXTEDIT_GETPREVCHARINDEX
#define IMSTB_TEXTEDIT_GETPREVCHARINDEX(obj, idx) (idx - 1)
#endif
#ifndef IMSTB_TEXTEDIT_GETNEXTCHARINDEX
#define IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx) (idx + 1)
#endif

#ifdef STB_TEXTEDIT_IS_SPACE
static int is_word_boundary( IMSTB_TEXTEDIT_STRING *str, int idx )
{
   return idx > 0 ? (STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str,idx-1) ) && !STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str, idx) ) ) : 1;
}

#ifndef STB_TEXTEDIT_MOVEWORDLEFT
static int stb_textedit_move_to_word_previous( IMSTB_TEXTEDIT_STRING *str, int c )
{
   --c; // always move at least one character
   while( c >= 0 && !is_word_boundary( str, c ) )
      --c;

   if( c < 0 )
      c = 0;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous
#endif

#ifndef STB_TEXTEDIT_MOVEWORDRIGHT
static int stb_textedit_move_to_word_next( IMSTB_TEXTEDIT_STRING *str, int c )
{
   const int len = STB_TEXTEDIT_STRINGLEN(str);
   ++c; // always move at least one character
   while( c < len && !is_word_boundary( str, c ) )
      ++c;

   if( c > len )
      c = len;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next
#endif

#endif

// update selection and cursor to match each other
static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)
{
   if (!STB_TEXT_HAS_SELECTION(state))
      state->select_start = state->select_end = state->cursor;
   else
      state->cursor = state->select_end;
}

// API cut: delete selection
static int stb_textedit_cut(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_delete_selection(str,state); // implicitly clamps
      state->has_preferred_x = 0;
      return 1;
   }
   return 0;
}

// API paste: replace existing selection with passed-in text
static int stb_textedit_paste_internal(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, IMSTB_TEXTEDIT_CHARTYPE *text, int len)
{
   // if there's a selection, the paste should delete it
   stb_textedit_clamp(str, state);
   stb_textedit_delete_selection(str,state);
   // try to insert the characters
   if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {
      stb_text_makeundo_insert(state, state->cursor, len);
      state->cursor += len;
      state->has_preferred_x = 0;
      return 1;
   }
   // note: paste failure will leave deleted selection, may be restored with an undo (see https://github.com/nothings/stb/issues/734 for details)
   return 0;
}

#ifndef STB_TEXTEDIT_KEYTYPE
#define STB_TEXTEDIT_KEYTYPE int
#endif

// [DEAR IMGUI] Added stb_textedit_text(), extracted out and called by stb_textedit_key() for backward compatibility.
static void stb_textedit_text(IMSTB_TEXTEDIT_STRING* str, STB_TexteditState* state, const IMSTB_TEXTEDIT_CHARTYPE* text, int text_len)
{
   // can't add newline in single-line mode
   if (text[0] == '\n' && state->single_line)
      return;

   if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {
      stb_text_makeundo_replace(str, state, state->cursor, 1, 1);
      STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);
      if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, text_len)) {
         state->cursor += text_len;
         state->has_preferred_x = 0;
      }
   }
   else {
      stb_textedit_delete_selection(str, state); // implicitly clamps
      if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, text_len)) {
         stb_text_makeundo_insert(state, state->cursor, text_len);
         state->cursor += text_len;
         state->has_preferred_x = 0;
      }
   }
}

// API key: process a keyboard input
static void stb_textedit_key(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key)
{
retry:
   switch (key) {
      default: {
#ifdef STB_TEXTEDIT_KEYTOTEXT
         int c = STB_TEXTEDIT_KEYTOTEXT(key);
         if (c > 0) {
            IMSTB_TEXTEDIT_CHARTYPE ch = (IMSTB_TEXTEDIT_CHARTYPE)c;
            stb_textedit_text(str, state, &ch, 1);
         }
#endif
         break;
      }

#ifdef STB_TEXTEDIT_K_INSERT
      case STB_TEXTEDIT_K_INSERT:
         state->insert_mode = !state->insert_mode;
         break;
#endif

      case STB_TEXTEDIT_K_UNDO:
         stb_text_undo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_REDO:
         stb_text_redo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT:
         // if currently there's a selection, move cursor to start of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else
            if (state->cursor > 0)
               state->cursor = IMSTB_TEXTEDIT_GETPREVCHARINDEX(str, state->cursor);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_RIGHT:
         // if currently there's a selection, move cursor to end of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str, state);
         else
            state->cursor = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state->cursor);
         stb_textedit_clamp(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         // move selection left
         if (state->select_end > 0)
            state->select_end = IMSTB_TEXTEDIT_GETPREVCHARINDEX(str, state->select_end);
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_MOVEWORDLEFT
      case STB_TEXTEDIT_K_WORDLEFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

#ifdef STB_TEXTEDIT_MOVEWORDRIGHT
      case STB_TEXTEDIT_K_WORDRIGHT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str, state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

      case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         // move selection right
         state->select_end = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state->select_end);
         stb_textedit_clamp(str, state);
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_DOWN:
      case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT:
      case STB_TEXTEDIT_K_PGDOWN:
      case STB_TEXTEDIT_K_PGDOWN | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, j, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;
         int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGDOWN;
         int row_count = is_page ? state->row_count_per_page : 1;

         if (!is_page && state->single_line) {
            // on windows, up&down in single-line behave like left&right
            key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str, state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         for (j = 0; j < row_count; ++j) {
            float x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;
            int start = find.first_char + find.length;

            if (find.length == 0)
               break;

            // [DEAR IMGUI]
            // going down while being on the last line shouldn't bring us to that line end
            if (STB_TEXTEDIT_GETCHAR(str, find.first_char + find.length - 1) != STB_TEXTEDIT_NEWLINE)
               break;

            // now find character position down a row
            state->cursor = start;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);
               #ifdef IMSTB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == IMSTB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               state->cursor = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state->cursor);
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;

            // go to next line
            find.first_char = find.first_char + find.length;
            find.length = row.num_chars;
         }
         break;
      }

      case STB_TEXTEDIT_K_UP:
      case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT:
      case STB_TEXTEDIT_K_PGUP:
      case STB_TEXTEDIT_K_PGUP | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, j, prev_scan, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;
         int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGUP;
         int row_count = is_page ? state->row_count_per_page : 1;

         if (!is_page && state->single_line) {
            // on windows, up&down become left&right
            key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         for (j = 0; j < row_count; ++j) {
            float  x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;

            // can only go up if there's a previous row
            if (find.prev_first == find.first_char)
               break;

            // now find character position up a row
            state->cursor = find.prev_first;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);
               #ifdef IMSTB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == IMSTB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               state->cursor = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state->cursor);
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;

            // go to previous line
            // (we need to scan previous line the hard way. maybe we could expose this as a new API function?)
            prev_scan = find.prev_first > 0 ? find.prev_first - 1 : 0;
            while (prev_scan > 0 && STB_TEXTEDIT_GETCHAR(str, prev_scan - 1) != STB_TEXTEDIT_NEWLINE)
               --prev_scan;
            find.first_char = find.prev_first;
            find.prev_first = prev_scan;
         }
         break;
      }

      case STB_TEXTEDIT_K_DELETE:
      case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            int n = STB_TEXTEDIT_STRINGLEN(str);
            if (state->cursor < n)
               stb_textedit_delete(str, state, state->cursor, IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state->cursor) - state->cursor);
         }
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_BACKSPACE:
      case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            stb_textedit_clamp(str, state);
            if (state->cursor > 0) {
               int prev = IMSTB_TEXTEDIT_GETPREVCHARINDEX(str, state->cursor);
               stb_textedit_delete(str, state, prev, state->cursor - prev);
               state->cursor = prev;
            }
         }
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2:
#endif
      case STB_TEXTEDIT_K_TEXTSTART:
         state->cursor = state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2:
#endif
      case STB_TEXTEDIT_K_TEXTEND:
         state->cursor = STB_TEXTEDIT_STRINGLEN(str);
         state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);
         state->has_preferred_x = 0;
         break;


#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2:
#endif
      case STB_TEXTEDIT_K_LINESTART:
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2:
#endif
      case STB_TEXTEDIT_K_LINEEND: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
             ++state->cursor;
         state->has_preferred_x = 0;
         break;
      }

#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
            ++state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
//
//      Undo processing
//
// @OPTIMIZE: the undo/redo buffer should be circular

static void stb_textedit_flush_redo(StbUndoState *state)
{
   state->redo_point = IMSTB_TEXTEDIT_UNDOSTATECOUNT;
   state->redo_char_point = IMSTB_TEXTEDIT_UNDOCHARCOUNT;
}

// discard the oldest entry in the undo list
static void stb_textedit_discard_undo(StbUndoState *state)
{
   if (state->undo_point > 0) {
      // if the 0th undo state has characters, clean those up
      if (state->undo_rec[0].char_storage >= 0) {
         int n = state->undo_rec[0].insert_length, i;
         // delete n characters from all other records
         state->undo_char_point -= n;
         IMSTB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(IMSTB_TEXTEDIT_CHARTYPE)));
         for (i=0; i < state->undo_point; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it
      }
      --state->undo_point;
      IMSTB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));
   }
}

// discard the oldest entry in the redo list--it's bad if this
// ever happens, but because undo & redo have to store the actual
// characters in different cases, the redo character buffer can
// fill up even though the undo buffer didn't
static void stb_textedit_discard_redo(StbUndoState *state)
{
   int k = IMSTB_TEXTEDIT_UNDOSTATECOUNT-1;

   if (state->redo_point <= k) {
      // if the k'th undo state has characters, clean those up
      if (state->undo_rec[k].char_storage >= 0) {
         int n = state->undo_rec[k].insert_length, i;
         // move the remaining redo character data to the end of the buffer
         state->redo_char_point += n;
         IMSTB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((IMSTB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(IMSTB_TEXTEDIT_CHARTYPE)));
         // adjust the position of all the other records to account for above memmove
         for (i=state->redo_point; i < k; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage += n;
      }
      // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
      // [DEAR IMGUI]
      size_t move_size = (size_t)((IMSTB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1) * sizeof(state->undo_rec[0]));
      const char* buf_begin = (char*)state->undo_rec; (void)buf_begin;
      const char* buf_end   = (char*)state->undo_rec + sizeof(state->undo_rec); (void)buf_end;
      IM_ASSERT(((char*)(state->undo_rec + state->redo_point)) >= buf_begin);
      IM_ASSERT(((char*)(state->undo_rec + state->redo_point + 1) + move_size) <= buf_end);
      IMSTB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, move_size);

      // now move redo_point to point to the new one
      ++state->redo_point;
   }
}

static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)
{
   // any time we create a new undo record, we discard redo
   stb_textedit_flush_redo(state);

   // if we have no free records, we have to make room, by sliding the
   // existing records down
   if (state->undo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT)
      stb_textedit_discard_undo(state);

   // if the characters to store won't possibly fit in the buffer, we can't undo
   if (numchars > IMSTB_TEXTEDIT_UNDOCHARCOUNT) {
      state->undo_point = 0;
      state->undo_char_point = 0;
      return NULL;
   }

   // if we don't have enough free characters in the buffer, we have to make room
   while (state->undo_char_point + numchars > IMSTB_TEXTEDIT_UNDOCHARCOUNT)
      stb_textedit_discard_undo(state);

   return &state->undo_rec[state->undo_point++];
}

static IMSTB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)
{
   StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);
   if (r == NULL)
      return NULL;

   r->where = pos;
   r->insert_length = (IMSTB_TEXTEDIT_POSITIONTYPE) insert_len;
   r->delete_length = (IMSTB_TEXTEDIT_POSITIONTYPE) delete_len;

   if (insert_len == 0) {
      r->char_storage = -1;
      return NULL;
   } else {
      r->char_storage = state->undo_char_point;
      state->undo_char_point += insert_len;
      return &state->undo_char[r->char_storage];
   }
}

static void stb_text_undo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord u, *r;
   if (s->undo_point == 0)
      return;

   // we need to do two things: apply the undo record, and create a redo record
   u = s->undo_rec[s->undo_point-1];
   r = &s->undo_rec[s->redo_point-1];
   r->char_storage = -1;

   r->insert_length = u.delete_length;
   r->delete_length = u.insert_length;
   r->where = u.where;

   if (u.delete_length) {
      // if the undo record says to delete characters, then the redo record will
      // need to re-insert the characters that get deleted, so we need to store
      // them.

      // there are three cases:
      //    there's enough room to store the characters
      //    characters stored for *redoing* don't leave room for redo
      //    characters stored for *undoing* don't leave room for redo
      // if the last is true, we have to bail

      if (s->undo_char_point + u.delete_length >= IMSTB_TEXTEDIT_UNDOCHARCOUNT) {
         // the undo records take up too much character space; there's no space to store the redo characters
         r->insert_length = 0;
      } else {
         int i;

         // there's definitely room to store the characters eventually
         while (s->undo_char_point + u.delete_length > s->redo_char_point) {
            // should never happen:
            if (s->redo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT)
               return;
            // there's currently not enough room, so discard a redo record
            stb_textedit_discard_redo(s);
         }
         r = &s->undo_rec[s->redo_point-1];

         r->char_storage = s->redo_char_point - u.delete_length;
         s->redo_char_point = s->redo_char_point - u.delete_length;

         // now save the characters
         for (i=0; i < u.delete_length; ++i)
            s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);
      }

      // now we can carry out the deletion
      STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);
   }

   // check type of recorded action:
   if (u.insert_length) {
      // easy case: was a deletion, so we need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);
      s->undo_char_point -= u.insert_length;
   }

   state->cursor = u.where + u.insert_length;

   s->undo_point--;
   s->redo_point--;
}

static void stb_text_redo(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord *u, r;
   if (s->redo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT)
      return;

   // we need to do two things: apply the redo record, and create an undo record
   u = &s->undo_rec[s->undo_point];
   r = s->undo_rec[s->redo_point];

   // we KNOW there must be room for the undo record, because the redo record
   // was derived from an undo record

   u->delete_length = r.insert_length;
   u->insert_length = r.delete_length;
   u->where = r.where;
   u->char_storage = -1;

   if (r.delete_length) {
      // the redo record requires us to delete characters, so the undo record
      // needs to store the characters

      if (s->undo_char_point + u->insert_length > s->redo_char_point) {
         u->insert_length = 0;
         u->delete_length = 0;
      } else {
         int i;
         u->char_storage = s->undo_char_point;
         s->undo_char_point = s->undo_char_point + u->insert_length;

         // now save the characters
         for (i=0; i < u->insert_length; ++i)
            s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);
      }

      STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);
   }

   if (r.insert_length) {
      // easy case: need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);
      s->redo_char_point += r.insert_length;
   }

   state->cursor = r.where + r.insert_length;

   s->undo_point++;
   s->redo_point++;
}

static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)
{
   stb_text_createundo(&state->undostate, where, 0, length);
}

static void stb_text_makeundo_delete(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)
{
   int i;
   IMSTB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);
   if (p) {
      for (i=0; i < length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

static void stb_text_makeundo_replace(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)
{
   int i;
   IMSTB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);
   if (p) {
      for (i=0; i < old_length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

// reset the state to default
static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)
{
   state->undostate.undo_point = 0;
   state->undostate.undo_char_point = 0;
   state->undostate.redo_point = IMSTB_TEXTEDIT_UNDOSTATECOUNT;
   state->undostate.redo_char_point = IMSTB_TEXTEDIT_UNDOCHARCOUNT;
   state->select_end = state->select_start = 0;
   state->cursor = 0;
   state->has_preferred_x = 0;
   state->preferred_x = 0;
   state->cursor_at_end_of_line = 0;
   state->initialized = 1;
   state->single_line = (unsigned char) is_single_line;
   state->insert_mode = 0;
   state->row_count_per_page = 0;
}

// API initialize
static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
{
   stb_textedit_clear_state(state, is_single_line);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

static int stb_textedit_paste(IMSTB_TEXTEDIT_STRING *str, STB_TexteditState *state, IMSTB_TEXTEDIT_CHARTYPE const *ctext, int len)
{
   return stb_textedit_paste_internal(str, state, (IMSTB_TEXTEDIT_CHARTYPE *) ctext, len);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif//IMSTB_TEXTEDIT_IMPLEMENTATION

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/



================================================
FILE: ImGui/imstb_truetype.h
================================================
// [DEAR IMGUI]
// This is a slightly modified version of stb_truetype.h 1.26.
// Mostly fixing for compiler and static analyzer warnings.
// Grep for [DEAR IMGUI] to find the changes.

// stb_truetype.h - v1.26 - public domain
// authored from 2009-2021 by Sean Barrett / RAD Game Tools
//
// =======================================================================
//
//    NO SECURITY GUARANTEE -- DO NOT USE THIS ON UNTRUSTED FONT FILES
//
// This library does no range checking of the offsets found in the file,
// meaning an attacker can use it to read arbitrary memory.
//
// =======================================================================
//
//   This library processes TrueType files:
//        parse files
//        extract glyph metrics
//        extract glyph shapes
//        render glyphs to one-channel bitmaps with antialiasing (box filter)
//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)
//
//   Todo:
//        non-MS cmaps
//        crashproof on bad data
//        hinting? (no longer patented)
//        cleartype-style AA?
//        optimize: use simple memory allocator for intermediates
//        optimize: build edge-list directly from curves
//        optimize: rasterize directly from curves?
//
// ADDITIONAL CONTRIBUTORS
//
//   Mikko Mononen: compound shape support, more cmap formats
//   Tor Andersson: kerning, subpixel rendering
//   Dougall Johnson: OpenType / Type 2 font handling
//   Daniel Ribeiro Maciel: basic GPOS-based kerning
//
//   Misc other:
//       Ryan Gordon
//       Simon Glass
//       github:IntellectualKitty
//       Imanol Celaya
//       Daniel Ribeiro Maciel
//
//   Bug/warning reports/fixes:
//       "Zer" on mollyrocket       Fabian "ryg" Giesen   github:NiLuJe
//       Cass Everitt               Martins Mozeiko       github:aloucks
//       stoiko (Haemimont Games)   Cap Petschulat        github:oyvindjam
//       Brian Hook                 Omar Cornut           github:vassvik
//       Walter van Niftrik         Ryan Griege
//       David Gow                  Peter LaValle
//       David Given                Sergey Popov
//       Ivan-Assen Ivanov          Giumo X. Clanjor
//       Anthony Pesch              Higor Euripedes
//       Johan Duparc               Thomas Fields
//       Hou Qiming                 Derek Vinyard
//       Rob Loach                  Cort Stratton
//       Kenney Phillis Jr.         Brian Costabile
//       Ken Voskuil (kaesve)
//
// VERSION HISTORY
//
//   1.26 (2021-08-28) fix broken rasterizer
//   1.25 (2021-07-11) many fixes
//   1.24 (2020-02-05) fix warning
//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)
//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined
//   1.21 (2019-02-25) fix warning
//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()
//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     variant PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//
//   Full history can be found at the end of this file.
//
// LICENSE
//
//   See end of file for license information.
//
// USAGE
//
//   Include this file in whatever places need to refer to it. In ONE C/C++
//   file, write:
//      #define STB_TRUETYPE_IMPLEMENTATION
//   before the #include of this file. This expands out the actual
//   implementation into that C/C++ file.
//
//   To make the implementation private to the file that generates the implementation,
//      #define STBTT_STATIC
//
//   Simple 3D API (don't ship this, but it's fine for tools and quick start)
//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture
//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char
//
//   Improved 3D API (more shippable):
//           #include "stb_rect_pack.h"           -- optional, but you really want it
//           stbtt_PackBegin()
//           stbtt_PackSetOversampling()          -- for improved quality on small fonts
//           stbtt_PackFontRanges()               -- pack and renders
//           stbtt_PackEnd()
//           stbtt_GetPackedQuad()
//
//   "Load" a font file from a memory buffer (you have to keep the buffer loaded)
//           stbtt_InitFont()
//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections
//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections
//
//   Render a unicode codepoint to a bitmap
//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap
//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide
//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be
//
//   Character advance/positioning
//           stbtt_GetCodepointHMetrics()
//           stbtt_GetFontVMetrics()
//           stbtt_GetFontVMetricsOS2()
//           stbtt_GetCodepointKernAdvance()
//
//   Starting with version 1.06, the rasterizer was replaced with a new,
//   faster and generally-more-precise rasterizer. The new rasterizer more
//   accurately measures pixel coverage for anti-aliasing, except in the case
//   where multiple shapes overlap, in which case it overestimates the AA pixel
//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If
//   this turns out to be a problem, you can re-enable the old rasterizer with
//        #define STBTT_RASTERIZER_VERSION 1
//   which will incur about a 15% speed hit.
//
// ADDITIONAL DOCUMENTATION
//
//   Immediately after this block comment are a series of sample programs.
//
//   After the sample programs is the "header file" section. This section
//   includes documentation for each API function.
//
//   Some important concepts to understand to use this library:
//
//      Codepoint
//         Characters are defined by unicode codepoints, e.g. 65 is
//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is
//         the hiragana for "ma".
//
//      Glyph
//         A visual character shape (every codepoint is rendered as
//         some glyph)
//
//      Glyph index
//         A font-specific integer ID representing a glyph
//
//      Baseline
//         Glyph shapes are defined relative to a baseline, which is the
//         bottom of uppercase characters. Characters extend both above
//         and below the baseline.
//
//      Current Point
//         As you draw text to the screen, you keep track of a "current point"
//         which is the origin of each character. The current point's vertical
//         position is the baseline. Even "baked fonts" use this model.
//
//      Vertical Font Metrics
//         The vertical qualities of the font, used to vertically position
//         and space the characters. See docs for stbtt_GetFontVMetrics.
//
//      Font Size in Pixels or Points
//         The preferred interface for specifying font sizes in stb_truetype
//         is to specify how tall the font's vertical extent should be in pixels.
//         If that sounds good enough, skip the next paragraph.
//
//         Most font APIs instead use "points", which are a common typographic
//         measurement for describing font size, defined as 72 points per inch.
//         stb_truetype provides a point API for compatibility. However, true
//         "per inch" conventions don't make much sense on computer displays
//         since different monitors have different number of pixels per
//         inch. For example, Windows traditionally uses a convention that
//         there are 96 pixels per inch, thus making 'inch' measurements have
//         nothing to do with inches, and thus effectively defining a point to
//         be 1.333 pixels. Additionally, the TrueType font data provides
//         an explicit scale factor to scale a given font's glyphs to points,
//         but the author has observed that this scale factor is often wrong
//         for non-commercial fonts, thus making fonts scaled in points
//         according to the TrueType spec incoherently sized in practice.
//
// DETAILED USAGE:
//
//  Scale:
//    Select how high you want the font to be, in points or pixels.
//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute
//    a scale factor SF that will be used by all other functions.
//
//  Baseline:
//    You need to select a y-coordinate that is the baseline of where
//    your text will appear. Call GetFontBoundingBox to get the baseline-relative
//    bounding box for all characters. SF*-y0 will be the distance in pixels
//    that the worst-case character could extend above the baseline, so if
//    you want the top edge of characters to appear at the top of the
//    screen where y=0, then you would set the baseline to SF*-y0.
//
//  Current point:
//    Set the current point where the first character will appear. The
//    first character could extend left of the current point; this is font
//    dependent. You can either choose a current point that is the leftmost
//    point and hope, or add some padding, or check the bounding box or
//    left-side-bearing of the first character to be displayed and set
//    the current point based on that.
//
//  Displaying a character:
//    Compute the bounding box of the character. It will contain signed values
//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,
//    then the character should be displayed in the rectangle from
//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).
//
//  Advancing for the next character:
//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.
//
//
// ADVANCED USAGE
//
//   Quality:
//
//    - Use the functions with Subpixel at the end to allow your characters
//      to have subpixel positioning. Since the font is anti-aliased, not
//      hinted, this is very import for quality. (This is not possible with
//      baked fonts.)
//
//    - Kerning is now supported, and if you're supporting subpixel rendering
//      then kerning is worth using to give your text a polished look.
//
//   Performance:
//
//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;
//      if you don't do this, stb_truetype is forced to do the conversion on
//      every call.
//
//    - There are a lot of memory allocations. We should modify it to take
//      a temp buffer and allocate from the temp buffer (without freeing),
//      should help performance a lot.
//
// NOTES
//
//   The system uses the raw data found in the .ttf file without changing it
//   and without building auxiliary data structures. This is a bit inefficient
//   on little-endian systems (the data is big-endian), but assuming you're
//   caching the bitmaps or glyph shapes this shouldn't be a big deal.
//
//   It appears to be very hard to programmatically determine what font a
//   given file is in a general way. I provide an API for this, but I don't
//   recommend it.
//
//
// PERFORMANCE MEASUREMENTS FOR 1.06:
//
//                      32-bit     64-bit
//   Previous release:  8.83 s     7.68 s
//   Pool allocations:  7.72 s     6.34 s
//   Inline sort     :  6.54 s     5.65 s
//   New rasterizer  :  5.63 s     5.00 s

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////  SAMPLE PROGRAMS
////
//
//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless.
//  See "tests/truetype_demo_win32.c" for a complete version.
#if 0
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

unsigned char ttf_buffer[1<<20];
unsigned char temp_bitmap[512*512];

stbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs
GLuint ftex;

void my_stbtt_initfont(void)
{
   fread(ttf_buffer, 1, 1<<20, fopen("c:/windows/fonts/times.ttf", "rb"));
   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); // no guarantee this fits!
   // can free ttf_buffer at this point
   glGenTextures(1, &ftex);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);
   // can free temp_bitmap at this point
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
}

void my_stbtt_print(float x, float y, char *text)
{
   // assume orthographic projection with units = screen pixels, origin at top left
   glEnable(GL_BLEND);
   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_TEXTURE_2D);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glBegin(GL_QUADS);
   while (*text) {
      if (*text >= 32 && *text < 128) {
         stbtt_aligned_quad q;
         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);//1=opengl & d3d10+,0=d3d9
         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y0);
         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y0);
         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y1);
         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y1);
      }
      ++text;
   }
   glEnd();
}
#endif
//
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program (this compiles): get a single bitmap, print as ASCII art
//
#if 0
#include <stdio.h>
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

char ttf_buffer[1<<25];

int main(int argc, char **argv)
{
   stbtt_fontinfo font;
   unsigned char *bitmap;
   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);

   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : "c:/windows/fonts/arialbd.ttf", "rb"));

   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));
   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);

   for (j=0; j < h; ++j) {
      for (i=0; i < w; ++i)
         putchar(" .:ioVM@"[bitmap[j*w+i]>>5]);
      putchar('\n');
   }
   return 0;
}
#endif
//
// Output:
//
//     .ii.
//    @@@@@@.
//   V@Mio@@o
//   :i.  V@V
//     :oM@@M
//   :@@@MM@M
//   @@o  o@M
//  :@@.  M@M
//   @@@o@@@@
//   :M@@V:@@.
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program: print "Hello World!" banner, with bugs
//
#if 0
char buffer[24<<20];
unsigned char screen[20][79];

int main(int arg, char **argv)
{
   stbtt_fontinfo font;
   int i,j,ascent,baseline,ch=0;
   float scale, xpos=2; // leave a little padding in case the character extends left
   char *text = "Heljo World!"; // intentionally misspelled to show 'lj' brokenness

   fread(buffer, 1, 1000000, fopen("c:/windows/fonts/arialbd.ttf", "rb"));
   stbtt_InitFont(&font, buffer, 0);

   scale = stbtt_ScaleForPixelHeight(&font, 15);
   stbtt_GetFontVMetrics(&font, &ascent,0,0);
   baseline = (int) (ascent*scale);

   while (text[ch]) {
      int advance,lsb,x0,y0,x1,y1;
      float x_shift = xpos - (float) floor(xpos);
      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);
      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);
      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);
      // note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong
      // because this API is really for baking character bitmaps into textures. if you want to render
      // a sequence of characters, you really need to render each bitmap to a temp buffer, then
      // "alpha blend" that into the working buffer
      xpos += (advance * scale);
      if (text[ch+1])
         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);
      ++ch;
   }

   for (j=0; j < 20; ++j) {
      for (i=0; i < 78; ++i)
         putchar(" .:ioVM@"[screen[j][i]>>5]);
      putchar('\n');
   }

   return 0;
}
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////   INTEGRATION WITH YOUR CODEBASE
////
////   The following sections allow you to supply alternate definitions
////   of C library functions used by stb_truetype, e.g. if you don't
////   link with the C runtime library.

#ifdef STB_TRUETYPE_IMPLEMENTATION
   // #define your own (u)stbtt_int8/16/32 before including to override this
   #ifndef stbtt_uint8
   typedef unsigned char   stbtt_uint8;
   typedef signed   char   stbtt_int8;
   typedef unsigned short  stbtt_uint16;
   typedef signed   short  stbtt_int16;
   typedef unsigned int    stbtt_uint32;
   typedef signed   int    stbtt_int32;
   #endif

   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];
   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];

   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h
   #ifndef STBTT_ifloor
   #include <math.h>
   #define STBTT_ifloor(x)   ((int) floor(x))
   #define STBTT_iceil(x)    ((int) ceil(x))
   #endif

   #ifndef STBTT_sqrt
   #include <math.h>
   #define STBTT_sqrt(x)      sqrt(x)
   #define STBTT_pow(x,y)     pow(x,y)
   #endif

   #ifndef STBTT_fmod
   #include <math.h>
   #define STBTT_fmod(x,y)    fmod(x,y)
   #endif

   #ifndef STBTT_cos
   #include <math.h>
   #define STBTT_cos(x)       cos(x)
   #define STBTT_acos(x)      acos(x)
   #endif

   #ifndef STBTT_fabs
   #include <math.h>
   #define STBTT_fabs(x)      fabs(x)
   #endif

   // #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
   #ifndef STBTT_malloc
   #include <stdlib.h>
   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))
   #define STBTT_free(x,u)    ((void)(u),free(x))
   #endif

   #ifndef STBTT_assert
   #include <assert.h>
   #define STBTT_assert(x)    assert(x)
   #endif

   #ifndef STBTT_strlen
   #include <string.h>
   #define STBTT_strlen(x)    strlen(x)
   #endif

   #ifndef STBTT_memcpy
   #include <string.h>
   #define STBTT_memcpy       memcpy
   #define STBTT_memset       memset
   #endif
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   INTERFACE
////
////

#ifndef __STB_INCLUDE_STB_TRUETYPE_H__
#define __STB_INCLUDE_STB_TRUETYPE_H__

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

// private structure
typedef struct
{
   unsigned char *data;
   int cursor;
   int size;
} stbtt__buf;

//////////////////////////////////////////////////////////////////////////////
//
// TEXTURE BAKING API
//
// If you use this API, you only have to call two functions ever.
//

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
} stbtt_bakedchar;

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long
// if return is positive, the first unused row of the bitmap
// if return is negative, returns the negative of the number of characters that fit
// if return is 0, no characters fit and no rows were used
// This uses a very crappy packing.

typedef struct
{
   float x0,y0,s0,t0; // top-left
   float x1,y1,s1,t1; // bottom-right
} stbtt_aligned_quad;

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier
// Call GetBakedQuad with char_index = 'character - first_char', and it
// creates the quad you need to draw and advances the current position.
//
// The coordinate system used assumes y increases downwards.
//
// Characters will extend both above and below the current position;
// see discussion of "BASELINE" above.
//
// It's inefficient; you might want to c&p it and optimize it.

STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap);
// Query the font vertical metrics without having to create a font first.


//////////////////////////////////////////////////////////////////////////////
//
// NEW TEXTURE BAKING API
//
// This provides options for packing multiple fonts into one atlas, not
// perfectly but better than nothing.

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
   float xoff2,yoff2;
} stbtt_packedchar;

typedef struct stbtt_pack_context stbtt_pack_context;
typedef struct stbtt_fontinfo stbtt_fontinfo;
#ifndef STB_RECT_PACK_VERSION
typedef struct stbrp_rect stbrp_rect;
#endif

STBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);
// Initializes a packing context stored in the passed-in stbtt_pack_context.
// Future calls using this context will pack characters into the bitmap passed
// in here: a 1-channel bitmap that is width * height. stride_in_bytes is
// the distance from one row to the next (or 0 to mean they are packed tightly
// together). "padding" is the amount of padding to leave between each
// character (normally you want '1' for bitmaps you'll use as textures with
// bilinear filtering).
//
// Returns 0 on failure, 1 on success.

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);
// Cleans up the packing context and frees all memory.

#define STBTT_POINT_SIZE(x)   (-(x))

STBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);
// Creates character bitmaps from the font_index'th font found in fontdata (use
// font_index=0 if you don't know what that is). It creates num_chars_in_range
// bitmaps for characters with unicode values starting at first_unicode_char_in_range
// and increasing. Data for how to render them is stored in chardata_for_range;
// pass these to stbtt_GetPackedQuad to get back renderable quads.
//
// font_size is the full height of the character from ascender to descender,
// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed
// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()
// and pass that result as 'font_size':
//       ...,                  20 , ... // font max minus min y is 20 pixels tall
//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall

typedef struct
{
   float font_size;
   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint
   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints
   int num_chars;
   stbtt_packedchar *chardata_for_range; // output
   unsigned char h_oversample, v_oversample; // don't set these, they're used internally
} stbtt_pack_range;

STBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);
// Creates character bitmaps from multiple ranges of characters stored in
// ranges. This will usually create a better-packed bitmap than multiple
// calls to stbtt_PackFontRange. Note that you can call this multiple
// times within a single PackBegin/PackEnd.

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);
// Oversampling a font increases the quality by allowing higher-quality subpixel
// positioning, and is especially valuable at smaller text sizes.
//
// This function sets the amount of oversampling for all following calls to
// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given
// pack context. The default (no oversampling) is achieved by h_oversample=1
// and v_oversample=1. The total number of pixels required is
// h_oversample*v_oversample larger than the default; for example, 2x2
// oversampling requires 4x the storage of 1x1. For best results, render
// oversampled textures with bilinear filtering. Look at the readme in
// stb/tests/oversample for information about oversampled fonts
//
// To use with PackFontRangesGather etc., you must set it before calls
// call to PackFontRangesGatherRects.

STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip);
// If skip != 0, this tells stb_truetype to skip any codepoints for which
// there is no corresponding glyph. If skip=0, which is the default, then
// codepoints without a glyph received the font's "missing character" glyph,
// typically an empty box by convention.

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int align_to_integer);

STBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);
STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
// Calling these functions in sequence is roughly equivalent to calling
// stbtt_PackFontRanges(). If you more control over the packing of multiple
// fonts, or if you want to pack custom data into a font texture, take a look
// at the source to of stbtt_PackFontRanges() and create a custom version
// using these functions, e.g. call GatherRects multiple times,
// building up a single array of rects, then call PackRects once,
// then call RenderIntoRects repeatedly. This may result in a
// better packing than calling PackFontRanges multiple times
// (or it may not).

// this is an opaque structure that you shouldn't mess with which holds
// all the context needed from PackBegin to PackEnd.
struct stbtt_pack_context {
   void *user_allocator_context;
   void *pack_info;
   int   width;
   int   height;
   int   stride_in_bytes;
   int   padding;
   int   skip_missing;
   unsigned int   h_oversample, v_oversample;
   unsigned char *pixels;
   void  *nodes;
};

//////////////////////////////////////////////////////////////////////////////
//
// FONT LOADING
//
//

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);
// This function will determine the number of fonts in a font file.  TrueType
// collection (.ttc) files may contain multiple fonts, while TrueType font
// (.ttf) files only contain one font. The number of fonts can be used for
// indexing with the previous function where the index is between zero and one
// less than the total fonts. If an error occurs, -1 is returned.

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);
// Each .ttf/.ttc file may have more than one font. Each font has a sequential
// index number starting from 0. Call this function to get the font offset for
// a given index; it returns -1 if the index is out of range. A regular .ttf
// file will only define one font and it always be at offset 0, so it will
// return '0' for index 0, and -1 for all other indices.

// The following structure is defined publicly so you can declare one on
// the stack or as a global or etc, but you should treat it as opaque.
struct stbtt_fontinfo
{
   void           * userdata;
   unsigned char  * data;              // pointer to .ttf file
   int              fontstart;         // offset of start of font

   int numGlyphs;                     // number of glyphs, needed for range checking

   int loca,head,glyf,hhea,hmtx,kern,gpos,svg; // table locations as offset from start of .ttf
   int index_map;                     // a cmap mapping for our chosen character encoding
   int indexToLocFormat;              // format needed to map from glyph index to glyph

   stbtt__buf cff;                    // cff font data
   stbtt__buf charstrings;            // the charstring index
   stbtt__buf gsubrs;                 // global charstring subroutines index
   stbtt__buf subrs;                  // private charstring subroutines index
   stbtt__buf fontdicts;              // array of font dicts
   stbtt__buf fdselect;               // map from glyph to fontdict
};

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);
// Given an offset into the file that defines a font, this function builds
// the necessary cached info for the rest of the system. You must allocate
// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't
// need to do anything special to free it, because the contents are pure
// value data with no additional data structures. Returns 0 on failure.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER TO GLYPH-INDEX CONVERSIOn

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);
// If you're going to perform multiple operations on the same character
// and you want a speed-up, call this function with the character you're
// going to process, then use glyph-based functions instead of the
// codepoint-based functions.
// Returns 0 if the character codepoint is not defined in the font.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER PROPERTIES
//

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose "height" is 'pixels' tall.
// Height is measured as the distance from the highest ascender to the lowest
// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics
// and computing:
//       scale = pixels / (ascent - descent)
// so if you prefer to measure height by the ascent only, use a similar calculation.

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose EM size is mapped to
// 'pixels' tall. This is probably what traditional APIs compute, but
// I'm not positive.

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);
// ascent is the coordinate above the baseline the font extends; descent
// is the coordinate below the baseline the font extends (i.e. it is typically negative)
// lineGap is the spacing between one row's descent and the next row's ascent...
// so you should advance the vertical position by "*ascent - *descent + *lineGap"
//   these are expressed in unscaled coordinates, so you must multiply by
//   the scale factor for a given size

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);
// analogous to GetFontVMetrics, but returns the "typographic" values from the OS/2
// table (specific to MS/Windows TTF files).
//
// Returns 1 on success (table present), 0 on failure.

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);
// the bounding box around all possible characters

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);
// leftSideBearing is the offset from the current horizontal position to the left edge of the character
// advanceWidth is the offset from the current horizontal position to the next horizontal position
//   these are expressed in unscaled coordinates

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);
// an additional amount to add to the 'advance' value between ch1 and ch2

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);
// Gets the bounding box of the visible part of the glyph, in unscaled coordinates

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);
STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);
STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
// as above, but takes one or more glyph indices for greater efficiency

typedef struct stbtt_kerningentry
{
   int glyph1; // use stbtt_FindGlyphIndex
   int glyph2;
   int advance;
} stbtt_kerningentry;

STBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info);
STBTT_DEF int  stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length);
// Retrieves a complete list of all of the kerning pairs provided by the font
// stbtt_GetKerningTable never writes more than table_length entries and returns how many entries it did write.
// The table will be sorted by (a.glyph1 == b.glyph1)?(a.glyph2 < b.glyph2):(a.glyph1 < b.glyph1)

//////////////////////////////////////////////////////////////////////////////
//
// GLYPH SHAPES (you probably don't need these, but they have to go before
// the bitmaps for C declaration-order reasons)
//

#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
   enum {
      STBTT_vmove=1,
      STBTT_vline,
      STBTT_vcurve,
      STBTT_vcubic
   };
#endif

#ifndef stbtt_vertex // you can predefine this to use different values
                   // (we share this with other code at RAD)
   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
   typedef struct
   {
      stbtt_vertex_type x,y,cx,cy,cx1,cy1;
      unsigned char type,padding;
   } stbtt_vertex;
#endif

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);
// returns non-zero if nothing is drawn for this glyph

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);
STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);
// returns # of vertices and fills *vertices with the pointer to them
//   these are expressed in "unscaled" coordinates
//
// The shape is a series of contours. Each one starts with
// a STBTT_moveto, then consists of a series of mixed
// STBTT_lineto and STBTT_curveto segments. A lineto
// draws a line from previous endpoint to its x,y; a curveto
// draws a quadratic bezier from previous endpoint to
// its x,y, using cx,cy as the bezier control point.

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);
// frees the data allocated above

STBTT_DEF unsigned char *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl);
STBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg);
STBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg);
// fills svg with the character's SVG data.
// returns data size or 0 if SVG not found.

//////////////////////////////////////////////////////////////////////////////
//
// BITMAP RENDERING
//

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);
// frees the bitmap allocated below

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// allocates a large-enough single-channel 8bpp bitmap and renders the
// specified character/glyph at the specified scale into it, with
// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).
// *width & *height are filled out with the width & height of the bitmap,
// which is stored left-to-right, top-to-bottom.
//
// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);
// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap
// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap
// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the
// width and height and positioning info for it first.

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);
// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);
// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering
// is performed (see stbtt_PackSetOversampling)

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
// get the bbox of the bitmap centered around the glyph origin; so the
// bitmap width is ix1-ix0, height is iy1-iy0, and location to place
// the bitmap top left is (leftSideBearing*scale,iy0).
// (Note that the bitmap uses y-increases-down, but the shape uses
// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);
// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel
// shift for the character

// the following functions are equivalent to the above functions, but operate
// on glyph indices instead of Unicode codepoints (for efficiency)
STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);
STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);


// @TODO: don't expose this structure
typedef struct
{
   int w,h,stride;
   unsigned char *pixels;
} stbtt__bitmap;

// rasterize a shape with quadratic beziers into a bitmap
STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into
                               float flatness_in_pixels,     // allowable error of curve in pixels
                               stbtt_vertex *vertices,       // array of vertices defining shape
                               int num_verts,                // number of vertices in above array
                               float scale_x, float scale_y, // scale applied to input vertices
                               float shift_x, float shift_y, // translation applied to input vertices
                               int x_off, int y_off,         // another translation applied to input
                               int invert,                   // if non-zero, vertically flip shape
                               void *userdata);              // context for to STBTT_MALLOC

//////////////////////////////////////////////////////////////////////////////
//
// Signed Distance Function (or Field) rendering

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);
// frees the SDF bitmap allocated below

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
// These functions compute a discretized SDF field for a single character, suitable for storing
// in a single-channel texture, sampling with bilinear filtering, and testing against
// larger than some threshold to produce scalable fonts.
//        info              --  the font
//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap
//        glyph/codepoint   --  the character to generate the SDF for
//        padding           --  extra "pixels" around the character which are filled with the distance to the character (not 0),
//                                 which allows effects like bit outlines
//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)
//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF "pixel" away from the edge (on the 0..255 scale)
//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside
//        width,height      --  output height & width of the SDF bitmap (including padding)
//        xoff,yoff         --  output origin of the character
//        return value      --  a 2D array of bytes 0..255, width*height in size
//
// pixel_dist_scale & onedge_value are a scale & bias that allows you to make
// optimal use of the limited 0..255 for your application, trading off precision
// and special effects. SDF values outside the range 0..255 are clamped to 0..255.
//
// Example:
//      scale = stbtt_ScaleForPixelHeight(22)
//      padding = 5
//      onedge_value = 180
//      pixel_dist_scale = 180/5.0 = 36.0
//
//      This will create an SDF bitmap in which the character is about 22 pixels
//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled
//      shape, sample the SDF at each pixel and fill the pixel if the SDF value
//      is greater than or equal to 180/255. (You'll actually want to antialias,
//      which is beyond the scope of this example.) Additionally, you can compute
//      offset outlines (e.g. to stroke the character border inside & outside,
//      or only outside). For example, to fill outside the character up to 3 SDF
//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above
//      choice of variables maps a range from 5 pixels outside the shape to
//      2 pixels inside the shape to 0..255; this is intended primarily for apply
//      outside effects only (the interior range is needed to allow proper
//      antialiasing of the font at *smaller* sizes)
//
// The function computes the SDF analytically at each SDF pixel, not by e.g.
// building a higher-res bitmap and approximating it. In theory the quality
// should be as high as possible for an SDF of this size & representation, but
// unclear if this is true in practice (perhaps building a higher-res bitmap
// and computing from that can allow drop-out prevention).
//
// The algorithm has not been optimized at all, so expect it to be slow
// if computing lots of characters or very large sizes.



//////////////////////////////////////////////////////////////////////////////
//
// Finding the right font...
//
// You should really just solve this offline, keep your own tables
// of what font is what, and don't try to get it out of the .ttf file.
// That's because getting it out of the .ttf file is really hard, because
// the names in the file can appear in many possible encodings, in many
// possible languages, and e.g. if you need a case-insensitive comparison,
// the details of that depend on the encoding & language in a complex way
// (actually underspecified in truetype, but also gigantic).
//
// But you can use the provided functions in two possible ways:
//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on
//             unicode-encoded names to try to find the font you want;
//             you can run this before calling stbtt_InitFont()
//
//     stbtt_GetFontNameString() lets you get any of the various strings
//             from the file yourself and do your own comparisons on them.
//             You have to have called stbtt_InitFont() first.


STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);
// returns the offset (not index) of the font that matches, or -1 if none
//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like "Arial Bold".
//   if you use any other flag, use a font name like "Arial"; this checks
//     the 'macStyle' header field; i don't know if fonts set this consistently
#define STBTT_MACSTYLE_DONTCARE     0
#define STBTT_MACSTYLE_BOLD         1
#define STBTT_MACSTYLE_ITALIC       2
#define STBTT_MACSTYLE_UNDERSCORE   4
#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);
// returns 1/0 whether the first string interpreted as utf8 is identical to
// the second string interpreted as big-endian utf16... useful for strings from next func

STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);
// returns the string (which may be big-endian double byte, e.g. for unicode)
// and puts the length in bytes in *length.
//
// some of the values for the IDs are below; for more see the truetype spec:
//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html
//     http://www.microsoft.com/typography/otspec/name.htm

enum { // platformID
   STBTT_PLATFORM_ID_UNICODE   =0,
   STBTT_PLATFORM_ID_MAC       =1,
   STBTT_PLATFORM_ID_ISO       =2,
   STBTT_PLATFORM_ID_MICROSOFT =3
};

enum { // encodingID for STBTT_PLATFORM_ID_UNICODE
   STBTT_UNICODE_EID_UNICODE_1_0    =0,
   STBTT_UNICODE_EID_UNICODE_1_1    =1,
   STBTT_UNICODE_EID_ISO_10646      =2,
   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,
   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4
};

enum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT
   STBTT_MS_EID_SYMBOL        =0,
   STBTT_MS_EID_UNICODE_BMP   =1,
   STBTT_MS_EID_SHIFTJIS      =2,
   STBTT_MS_EID_UNICODE_FULL  =10
};

enum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,
   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,
   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,
   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7
};

enum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,
   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,
   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,
   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,
   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,
   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D
};

enum { // languageID for STBTT_PLATFORM_ID_MAC
   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,
   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,
   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,
   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,
   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,
   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,
   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19
};

#ifdef __cplusplus
}
#endif

#endif // __STB_INCLUDE_STB_TRUETYPE_H__

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   IMPLEMENTATION
////
////

#ifdef STB_TRUETYPE_IMPLEMENTATION

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

//////////////////////////////////////////////////////////////////////////
//
// stbtt__buf helpers to parse data from file
//

static stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor++];
}

static stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor];
}

static void stbtt__buf_seek(stbtt__buf *b, int o)
{
   STBTT_assert(!(o > b->size || o < 0));
   b->cursor = (o > b->size || o < 0) ? b->size : o;
}

static void stbtt__buf_skip(stbtt__buf *b, int o)
{
   stbtt__buf_seek(b, b->cursor + o);
}

static stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)
{
   stbtt_uint32 v = 0;
   int i;
   STBTT_assert(n >= 1 && n <= 4);
   for (i = 0; i < n; i++)
      v = (v << 8) | stbtt__buf_get8(b);
   return v;
}

static stbtt__buf stbtt__new_buf(const void *p, size_t size)
{
   stbtt__buf r;
   STBTT_assert(size < 0x40000000);
   r.data = (stbtt_uint8*) p;
   r.size = (int) size;
   r.cursor = 0;
   return r;
}

#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)

static stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)
{
   stbtt__buf r = stbtt__new_buf(NULL, 0);
   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
   r.data = b->data + o;
   r.size = s;
   return r;
}

static stbtt__buf stbtt__cff_get_index(stbtt__buf *b)
{
   int count, start, offsize;
   start = b->cursor;
   count = stbtt__buf_get16(b);
   if (count) {
      offsize = stbtt__buf_get8(b);
      STBTT_assert(offsize >= 1 && offsize <= 4);
      stbtt__buf_skip(b, offsize * count);
      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
   }
   return stbtt__buf_range(b, start, b->cursor - start);
}

static stbtt_uint32 stbtt__cff_int(stbtt__buf *b)
{
   int b0 = stbtt__buf_get8(b);
   if (b0 >= 32 && b0 <= 246)       return b0 - 139;
   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;
   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;
   else if (b0 == 28)               return stbtt__buf_get16(b);
   else if (b0 == 29)               return stbtt__buf_get32(b);
   STBTT_assert(0);
   return 0;
}

static void stbtt__cff_skip_operand(stbtt__buf *b) {
   int v, b0 = stbtt__buf_peek8(b);
   STBTT_assert(b0 >= 28);
   if (b0 == 30) {
      stbtt__buf_skip(b, 1);
      while (b->cursor < b->size) {
         v = stbtt__buf_get8(b);
         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)
            break;
      }
   } else {
      stbtt__cff_int(b);
   }
}

static stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)
{
   stbtt__buf_seek(b, 0);
   while (b->cursor < b->size) {
      int start = b->cursor, end, op;
      while (stbtt__buf_peek8(b) >= 28)
         stbtt__cff_skip_operand(b);
      end = b->cursor;
      op = stbtt__buf_get8(b);
      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;
      if (op == key) return stbtt__buf_range(b, start, end-start);
   }
   return stbtt__buf_range(b, 0, 0);
}

static void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)
{
   int i;
   stbtt__buf operands = stbtt__dict_get(b, key);
   for (i = 0; i < outcount && operands.cursor < operands.size; i++)
      out[i] = stbtt__cff_int(&operands);
}

static int stbtt__cff_index_count(stbtt__buf *b)
{
   stbtt__buf_seek(b, 0);
   return stbtt__buf_get16(b);
}

static stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)
{
   int count, offsize, start, end;
   stbtt__buf_seek(&b, 0);
   count = stbtt__buf_get16(&b);
   offsize = stbtt__buf_get8(&b);
   STBTT_assert(i >= 0 && i < count);
   STBTT_assert(offsize >= 1 && offsize <= 4);
   stbtt__buf_skip(&b, i*offsize);
   start = stbtt__buf_get(&b, offsize);
   end = stbtt__buf_get(&b, offsize);
   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);
}

//////////////////////////////////////////////////////////////////////////
//
// accessors to parse data from file
//

// on platforms that don't allow misaligned reads, if we want to allow
// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE

#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
#define ttCHAR(p)     (* (stbtt_int8 *) (p))
#define ttFixed(p)    ttLONG(p)

static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])

static int stbtt__isfont(stbtt_uint8 *font)
{
   // check the version number
   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
   if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
   if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
   if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
   return 0;
}

// @OPTIMIZE: binary search
static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
{
   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
   stbtt_uint32 tabledir = fontstart + 12;
   stbtt_int32 i;
   for (i=0; i < num_tables; ++i) {
      stbtt_uint32 loc = tabledir + 16*i;
      if (stbtt_tag(data+loc+0, tag))
         return ttULONG(data+loc+8);
   }
   return 0;
}

static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)
{
   // if it's just a font, there's only one valid index
   if (stbtt__isfont(font_collection))
      return index == 0 ? 0 : -1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         stbtt_int32 n = ttLONG(font_collection+8);
         if (index >= n)
            return -1;
         return ttULONG(font_collection+12+index*4);
      }
   }
   return -1;
}

static int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)
{
   // if it's just a font, there's only one valid font
   if (stbtt__isfont(font_collection))
      return 1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         return ttLONG(font_collection+8);
      }
   }
   return 0;
}

static stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)
{
   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };
   stbtt__buf pdict;
   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);
   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);
   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
   if (!subrsoff) return stbtt__new_buf(NULL, 0);
   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);
   return stbtt__cff_get_index(&cff);
}

// since most people won't use this, find this table the first time it's needed
static int stbtt__get_svg(stbtt_fontinfo *info)
{
   stbtt_uint32 t;
   if (info->svg < 0) {
      t = stbtt__find_table(info->data, info->fontstart, "SVG ");
      if (t) {
         stbtt_uint32 offset = ttULONG(info->data + t + 2);
         info->svg = t + offset;
      } else {
         info->svg = 0;
      }
   }
   return info->svg;
}

static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)
{
   stbtt_uint32 cmap, t;
   stbtt_int32 i,numTables;

   info->data = data;
   info->fontstart = fontstart;
   info->cff = stbtt__new_buf(NULL, 0);

   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
   info->head = stbtt__find_table(data, fontstart, "head"); // required
   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

   if (!cmap || !info->head || !info->hhea || !info->hmtx)
      return 0;
   if (info->glyf) {
      // required for truetype
      if (!info->loca) return 0;
   } else {
      // initialization for CFF / Type2 fonts (OTF)
      stbtt__buf b, topdict, topdictidx;
      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
      stbtt_uint32 cff;

      cff = stbtt__find_table(data, fontstart, "CFF ");
      if (!cff) return 0;

      info->fontdicts = stbtt__new_buf(NULL, 0);
      info->fdselect = stbtt__new_buf(NULL, 0);

      // @TODO this should use size from table (not 512MB)
      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
      b = info->cff;

      // read the header
      stbtt__buf_skip(&b, 2);
      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

      // @TODO the name INDEX could list multiple fonts,
      // but we just use the first one.
      stbtt__cff_get_index(&b);  // name INDEX
      topdictidx = stbtt__cff_get_index(&b);
      topdict = stbtt__cff_index_get(topdictidx, 0);
      stbtt__cff_get_index(&b);  // string INDEX
      info->gsubrs = stbtt__cff_get_index(&b);

      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
      info->subrs = stbtt__get_subrs(b, topdict);

      // we only support Type 2 charstrings
      if (cstype != 2) return 0;
      if (charstrings == 0) return 0;

      if (fdarrayoff) {
         // looks like a CID font
         if (!fdselectoff) return 0;
         stbtt__buf_seek(&b, fdarrayoff);
         info->fontdicts = stbtt__cff_get_index(&b);
         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
      }

      stbtt__buf_seek(&b, charstrings);
      info->charstrings = stbtt__cff_get_index(&b);
   }

   t = stbtt__find_table(data, fontstart, "maxp");
   if (t)
      info->numGlyphs = ttUSHORT(data+t+4);
   else
      info->numGlyphs = 0xffff;

   info->svg = -1;

   // find a cmap encoding table we understand *now* to avoid searching
   // later. (todo: could make this installable)
   // the same regardless of glyph.
   numTables = ttUSHORT(data + cmap + 2);
   info->index_map = 0;
   for (i=0; i < numTables; ++i) {
      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
      // find an encoding we understand:
      switch(ttUSHORT(data+encoding_record)) {
         case STBTT_PLATFORM_ID_MICROSOFT:
            switch (ttUSHORT(data+encoding_record+2)) {
               case STBTT_MS_EID_UNICODE_BMP:
               case STBTT_MS_EID_UNICODE_FULL:
                  // MS/Unicode
                  info->index_map = cmap + ttULONG(data+encoding_record+4);
                  break;
            }
            break;
        case STBTT_PLATFORM_ID_UNICODE:
            // Mac/iOS has these
            // all the encodingIDs are unicode, so we don't bother to check it
            info->index_map = cmap + ttULONG(data+encoding_record+4);
            break;
      }
   }
   if (info->index_map == 0)
      return 0;

   info->indexToLocFormat = ttUSHORT(data+info->head + 50);
   return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)
{
   stbtt_uint8 *data = info->data;
   stbtt_uint32 index_map = info->index_map;

   stbtt_uint16 format = ttUSHORT(data + index_map + 0);
   if (format == 0) { // apple byte encoding
      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
      if (unicode_codepoint < bytes-6)
         return ttBYTE(data + index_map + 6 + unicode_codepoint);
      return 0;
   } else if (format == 6) {
      stbtt_uint32 first = ttUSHORT(data + index_map + 6);
      stbtt_uint32 count = ttUSHORT(data + index_map + 8);
      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
      return 0;
   } else if (format == 2) {
      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
      return 0;
   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

      // do a binary search of the segments
      stbtt_uint32 endCount = index_map + 14;
      stbtt_uint32 search = endCount;

      if (unicode_codepoint > 0xffff)
         return 0;

      // they lie from endCount .. endCount + segCount
      // but searchRange is the nearest power of two, so...
      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
         search += rangeShift*2;

      // now decrement to bias correctly to find smallest
      search -= 2;
      while (entrySelector) {
         stbtt_uint16 end;
         searchRange >>= 1;
         end = ttUSHORT(data + search + searchRange*2);
         if (unicode_codepoint > end)
            search += searchRange*2;
         --entrySelector;
      }
      search += 2;

      {
         stbtt_uint16 offset, start, last;
         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);

         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
         last = ttUSHORT(data + endCount + 2*item);
         if (unicode_codepoint < start || unicode_codepoint > last)
            return 0;

         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
         if (offset == 0)
            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
      }
   } else if (format == 12 || format == 13) {
      stbtt_uint32 ngroups = ttULONG(data+index_map+12);
      stbtt_int32 low,high;
      low = 0; high = (stbtt_int32)ngroups;
      // Binary search the right group.
      while (low < high) {
         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);
         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
         if ((stbtt_uint32) unicode_codepoint < start_char)
            high = mid;
         else if ((stbtt_uint32) unicode_codepoint > end_char)
            low = mid+1;
         else {
            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
            if (format == 12)
               return start_glyph + unicode_codepoint-start_char;
            else // format == 13
               return start_glyph;
         }
      }
      return 0; // not found
   }
   // @TODO
   STBTT_assert(0);
   return 0;
}

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
{
   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);
}

static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
{
   v->type = type;
   v->x = (stbtt_int16) x;
   v->y = (stbtt_int16) y;
   v->cx = (stbtt_int16) cx;
   v->cy = (stbtt_int16) cy;
}

static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
{
   int g1,g2;

   STBTT_assert(!info->cff.size);

   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

   if (info->indexToLocFormat == 0) {
      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
   } else {
      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
   }

   return g1==g2 ? -1 : g1; // if length is 0, return -1
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);

STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   if (info->cff.size) {
      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
   } else {
      int g = stbtt__GetGlyfOffset(info, glyph_index);
      if (g < 0) return 0;

      if (x0) *x0 = ttSHORT(info->data + g + 2);
      if (y0) *y0 = ttSHORT(info->data + g + 4);
      if (x1) *x1 = ttSHORT(info->data + g + 6);
      if (y1) *y1 = ttSHORT(info->data + g + 8);
   }
   return 1;
}

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
{
   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);
}

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt_int16 numberOfContours;
   int g;
   if (info->cff.size)
      return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;
   g = stbtt__GetGlyfOffset(info, glyph_index);
   if (g < 0) return 1;
   numberOfContours = ttSHORT(info->data + g);
   return numberOfContours == 0;
}

static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
{
   if (start_off) {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
   } else {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
      else
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
   }
   return num_vertices;
}

static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   stbtt_int16 numberOfContours;
   stbtt_uint8 *endPtsOfContours;
   stbtt_uint8 *data = info->data;
   stbtt_vertex *vertices=0;
   int num_vertices=0;
   int g = stbtt__GetGlyfOffset(info, glyph_index);

   *pvertices = NULL;

   if (g < 0) return 0;

   numberOfContours = ttSHORT(data + g);

   if (numberOfContours > 0) {
      stbtt_uint8 flags=0,flagcount;
      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
      stbtt_uint8 *points;
      endPtsOfContours = (data + g + 10);
      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
      points = data + g + 10 + numberOfContours * 2 + 2 + ins;

      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
      if (vertices == 0)
         return 0;

      next_move = 0;
      flagcount=0;

      // in first pass, we load uninterpreted data into the allocated array
      // above, shifted to the end of the array so we won't overwrite it when
      // we create our final data starting from the front

      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

      // first load flags

      for (i=0; i < n; ++i) {
         if (flagcount == 0) {
            flags = *points++;
            if (flags & 8)
               flagcount = *points++;
         } else
            --flagcount;
         vertices[off+i].type = flags;
      }

      // now load x coordinates
      x=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 2) {
            stbtt_int16 dx = *points++;
            x += (flags & 16) ? dx : -dx; // ???
         } else {
            if (!(flags & 16)) {
               x = x + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].x = (stbtt_int16) x;
      }

      // now load y coordinates
      y=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 4) {
            stbtt_int16 dy = *points++;
            y += (flags & 32) ? dy : -dy; // ???
         } else {
            if (!(flags & 32)) {
               y = y + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].y = (stbtt_int16) y;
      }

      // now convert them to our format
      num_vertices=0;
      sx = sy = cx = cy = scx = scy = 0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         x     = (stbtt_int16) vertices[off+i].x;
         y     = (stbtt_int16) vertices[off+i].y;

         if (next_move == i) {
            if (i != 0)
               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

            // now start the new one
            start_off = !(flags & 1);
            if (start_off) {
               // if we start off with an off-curve point, then when we need to find a point on the curve
               // where we can start, and we need to save some state for when we wraparound.
               scx = x;
               scy = y;
               if (!(vertices[off+i+1].type & 1)) {
                  // next point is also a curve point, so interpolate an on-point curve
                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
               } else {
                  // otherwise just use the next point as our start point
                  sx = (stbtt_int32) vertices[off+i+1].x;
                  sy = (stbtt_int32) vertices[off+i+1].y;
                  ++i; // we're using point i+1 as the starting point, so skip it
               }
            } else {
               sx = x;
               sy = y;
            }
            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
            was_off = 0;
            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
            ++j;
         } else {
            if (!(flags & 1)) { // if it's a curve
               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
               cx = x;
               cy = y;
               was_off = 1;
            } else {
               if (was_off)
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
               else
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
               was_off = 0;
            }
         }
      }
      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
   } else if (numberOfContours < 0) {
      // Compound shapes.
      int more = 1;
      stbtt_uint8 *comp = data + g + 10;
      num_vertices = 0;
      vertices = 0;
      while (more) {
         stbtt_uint16 flags, gidx;
         int comp_num_verts = 0, i;
         stbtt_vertex *comp_verts = 0, *tmp = 0;
         float mtx[6] = {1,0,0,1,0,0}, m, n;

         flags = ttSHORT(comp); comp+=2;
         gidx = ttSHORT(comp); comp+=2;

         if (flags & 2) { // XY values
            if (flags & 1) { // shorts
               mtx[4] = ttSHORT(comp); comp+=2;
               mtx[5] = ttSHORT(comp); comp+=2;
            } else {
               mtx[4] = ttCHAR(comp); comp+=1;
               mtx[5] = ttCHAR(comp); comp+=1;
            }
         }
         else {
            // @TODO handle matching point
            STBTT_assert(0);
         }
         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         }

         // Find transformation scales.
         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

         // Get indexed glyph.
         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
         if (comp_num_verts > 0) {
            // Transform vertices.
            for (i = 0; i < comp_num_verts; ++i) {
               stbtt_vertex* v = &comp_verts[i];
               stbtt_vertex_type x,y;
               x=v->x; y=v->y;
               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
               x=v->cx; y=v->cy;
               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
            }
            // Append vertices.
            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
            if (!tmp) {
               if (vertices) STBTT_free(vertices, info->userdata);
               if (comp_verts) STBTT_free(comp_verts, info->userdata);
               return 0;
            }
            if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
            if (vertices) STBTT_free(vertices, info->userdata);
            vertices = tmp;
            STBTT_free(comp_verts, info->userdata);
            num_vertices += comp_num_verts;
         }
         // More components ?
         more = flags & (1<<5);
      }
   } else {
      // numberOfCounters == 0, do nothing
   }

   *pvertices = vertices;
   return num_vertices;
}

typedef struct
{
   int bounds;
   int started;
   float first_x, first_y;
   float x, y;
   stbtt_int32 min_x, max_x, min_y, max_y;

   stbtt_vertex *pvertices;
   int num_vertices;
} stbtt__csctx;

#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}

static void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)
{
   if (x > c->max_x || !c->started) c->max_x = x;
   if (y > c->max_y || !c->started) c->max_y = y;
   if (x < c->min_x || !c->started) c->min_x = x;
   if (y < c->min_y || !c->started) c->min_y = y;
   c->started = 1;
}

static void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)
{
   if (c->bounds) {
      stbtt__track_vertex(c, x, y);
      if (type == STBTT_vcubic) {
         stbtt__track_vertex(c, cx, cy);
         stbtt__track_vertex(c, cx1, cy1);
      }
   } else {
      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);
      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;
      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;
   }
   c->num_vertices++;
}

static void stbtt__csctx_close_shape(stbtt__csctx *ctx)
{
   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)
      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);
}

static void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)
{
   stbtt__csctx_close_shape(ctx);
   ctx->first_x = ctx->x = ctx->x + dx;
   ctx->first_y = ctx->y = ctx->y + dy;
   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)
{
   ctx->x += dx;
   ctx->y += dy;
   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
{
   float cx1 = ctx->x + dx1;
   float cy1 = ctx->y + dy1;
   float cx2 = cx1 + dx2;
   float cy2 = cy1 + dy2;
   ctx->x = cx2 + dx3;
   ctx->y = cy2 + dy3;
   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);
}

static stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)
{
   int count = stbtt__cff_index_count(&idx);
   int bias = 107;
   if (count >= 33900)
      bias = 32768;
   else if (count >= 1240)
      bias = 1131;
   n += bias;
   if (n < 0 || n >= count)
      return stbtt__new_buf(NULL, 0);
   return stbtt__cff_index_get(idx, n);
}

static stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt__buf fdselect = info->fdselect;
   int nranges, start, end, v, fmt, fdselector = -1, i;

   stbtt__buf_seek(&fdselect, 0);
   fmt = stbtt__buf_get8(&fdselect);
   if (fmt == 0) {
      // untested
      stbtt__buf_skip(&fdselect, glyph_index);
      fdselector = stbtt__buf_get8(&fdselect);
   } else if (fmt == 3) {
      nranges = stbtt__buf_get16(&fdselect);
      start = stbtt__buf_get16(&fdselect);
      for (i = 0; i < nranges; i++) {
         v = stbtt__buf_get8(&fdselect);
         end = stbtt__buf_get16(&fdselect);
         if (glyph_index >= start && glyph_index < end) {
            fdselector = v;
            break;
         }
         start = end;
      }
   }
   if (fdselector == -1) return stbtt__new_buf(NULL, 0); // [DEAR IMGUI] fixed, see #6007 and nothings/stb#1422
   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));
}

static int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)
{
   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
   int has_subrs = 0, clear_stack;
   float s[48];
   stbtt__buf subr_stack[10], subrs = info->subrs, b;
   float f;

#define STBTT__CSERR(s) (0)

   // this currently ignores the initial width value, which isn't needed if we have hmtx
   b = stbtt__cff_index_get(info->charstrings, glyph_index);
   while (b.cursor < b.size) {
      i = 0;
      clear_stack = 1;
      b0 = stbtt__buf_get8(&b);
      switch (b0) {
      // @TODO implement hinting
      case 0x13: // hintmask
      case 0x14: // cntrmask
         if (in_header)
            maskbits += (sp / 2); // implicit "vstem"
         in_header = 0;
         stbtt__buf_skip(&b, (maskbits + 7) / 8);
         break;

      case 0x01: // hstem
      case 0x03: // vstem
      case 0x12: // hstemhm
      case 0x17: // vstemhm
         maskbits += (sp / 2);
         break;

      case 0x15: // rmoveto
         in_header = 0;
         if (sp < 2) return STBTT__CSERR("rmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);
         break;
      case 0x04: // vmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("vmoveto stack");
         stbtt__csctx_rmove_to(c, 0, s[sp-1]);
         break;
      case 0x16: // hmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("hmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-1], 0);
         break;

      case 0x05: // rlineto
         if (sp < 2) return STBTT__CSERR("rlineto stack");
         for (; i + 1 < sp; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
      // starting from a different place.

      case 0x07: // vlineto
         if (sp < 1) return STBTT__CSERR("vlineto stack");
         goto vlineto;
      case 0x06: // hlineto
         if (sp < 1) return STBTT__CSERR("hlineto stack");
         for (;;) {
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, s[i], 0);
            i++;
      vlineto:
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, 0, s[i]);
            i++;
         }
         break;

      case 0x1F: // hvcurveto
         if (sp < 4) return STBTT__CSERR("hvcurveto stack");
         goto hvcurveto;
      case 0x1E: // vhcurveto
         if (sp < 4) return STBTT__CSERR("vhcurveto stack");
         for (;;) {
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);
            i += 4;
      hvcurveto:
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);
            i += 4;
         }
         break;

      case 0x08: // rrcurveto
         if (sp < 6) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x18: // rcurveline
         if (sp < 8) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp - 2; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");
         stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      case 0x19: // rlinecurve
         if (sp < 8) return STBTT__CSERR("rlinecurve stack");
         for (; i + 1 < sp - 6; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");
         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x1A: // vvcurveto
      case 0x1B: // hhcurveto
         if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");
         f = 0.0;
         if (sp & 1) { f = s[i]; i++; }
         for (; i + 3 < sp; i += 4) {
            if (b0 == 0x1B)
               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);
            else
               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);
            f = 0.0;
         }
         break;

      case 0x0A: // callsubr
         if (!has_subrs) {
            if (info->fdselect.size)
               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
            has_subrs = 1;
         }
         // FALLTHROUGH
      case 0x1D: // callgsubr
         if (sp < 1) return STBTT__CSERR("call(g|)subr stack");
         v = (int) s[--sp];
         if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");
         subr_stack[subr_stack_height++] = b;
         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);
         if (b.size == 0) return STBTT__CSERR("subr not found");
         b.cursor = 0;
         clear_stack = 0;
         break;

      case 0x0B: // return
         if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");
         b = subr_stack[--subr_stack_height];
         clear_stack = 0;
         break;

      case 0x0E: // endchar
         stbtt__csctx_close_shape(c);
         return 1;

      case 0x0C: { // two-byte escape
         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
         float dx, dy;
         int b1 = stbtt__buf_get8(&b);
         switch (b1) {
         // @TODO These "flex" implementations ignore the flex-depth and resolution,
         // and always draw beziers.
         case 0x22: // hflex
            if (sp < 7) return STBTT__CSERR("hflex stack");
            dx1 = s[0];
            dx2 = s[1];
            dy2 = s[2];
            dx3 = s[3];
            dx4 = s[4];
            dx5 = s[5];
            dx6 = s[6];
            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
            break;

         case 0x23: // flex
            if (sp < 13) return STBTT__CSERR("flex stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = s[10];
            dy6 = s[11];
            //fd is s[12]
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         case 0x24: // hflex1
            if (sp < 9) return STBTT__CSERR("hflex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dx4 = s[5];
            dx5 = s[6];
            dy5 = s[7];
            dx6 = s[8];
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));
            break;

         case 0x25: // flex1
            if (sp < 11) return STBTT__CSERR("flex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = dy6 = s[10];
            dx = dx1+dx2+dx3+dx4+dx5;
            dy = dy1+dy2+dy3+dy4+dy5;
            if (STBTT_fabs(dx) > STBTT_fabs(dy))
               dy6 = -dy;
            else
               dx6 = -dx;
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         default:
            return STBTT__CSERR("unimplemented");
         }
      } break;

      default:
         if (b0 != 255 && b0 != 28 && b0 < 32)
            return STBTT__CSERR("reserved operator");

         // push immediate
         if (b0 == 255) {
            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;
         } else {
            stbtt__buf_skip(&b, -1);
            f = (float)(stbtt_int16)stbtt__cff_int(&b);
         }
         if (sp >= 48) return STBTT__CSERR("push stack overflow");
         s[sp++] = f;
         clear_stack = 0;
         break;
      }
      if (clear_stack) sp = 0;
   }
   return STBTT__CSERR("no endchar");

#undef STBTT__CSERR
}

static int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   // runs the charstring twice, once to count and once to output (to avoid realloc)
   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {
      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);
      output_ctx.pvertices = *pvertices;
      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {
         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
         return output_ctx.num_vertices;
      }
   }
   *pvertices = NULL;
   return 0;
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   stbtt__csctx c = STBTT__CSCTX_INIT(1);
   int r = stbtt__run_charstring(info, glyph_index, &c);
   if (x0)  *x0 = r ? c.min_x : 0;
   if (y0)  *y0 = r ? c.min_y : 0;
   if (x1)  *x1 = r ? c.max_x : 0;
   if (y1)  *y1 = r ? c.max_y : 0;
   return r ? c.num_vertices : 0;
}

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   if (!info->cff.size)
      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
   else
      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
}

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
{
   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
   if (glyph_index < numOfLongHorMetrics) {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
   } else {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
   }
}

STBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info)
{
   stbtt_uint8 *data = info->data + info->kern;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   return ttUSHORT(data+10);
}

STBTT_DEF int stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length)
{
   stbtt_uint8 *data = info->data + info->kern;
   int k, length;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   length = ttUSHORT(data+10);
   if (table_length < length)
      length = table_length;

   for (k = 0; k < length; k++)
   {
      table[k].glyph1 = ttUSHORT(data+18+(k*6));
      table[k].glyph2 = ttUSHORT(data+20+(k*6));
      table[k].advance = ttSHORT(data+22+(k*6));
   }

   return length;
}

static int stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   stbtt_uint8 *data = info->data + info->kern;
   stbtt_uint32 needle, straw;
   int l, r, m;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   l = 0;
   r = ttUSHORT(data+10) - 1;
   needle = glyph1 << 16 | glyph2;
   while (l <= r) {
      m = (l + r) >> 1;
      straw = ttULONG(data+18+(m*6)); // note: unaligned read
      if (needle < straw)
         r = m - 1;
      else if (needle > straw)
         l = m + 1;
      else
         return ttSHORT(data+22+(m*6));
   }
   return 0;
}

static stbtt_int32 stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)
{
   stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);
   switch (coverageFormat) {
      case 1: {
         stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);

         // Binary search.
         stbtt_int32 l=0, r=glyphCount-1, m;
         int straw, needle=glyph;
         while (l <= r) {
            stbtt_uint8 *glyphArray = coverageTable + 4;
            stbtt_uint16 glyphID;
            m = (l + r) >> 1;
            glyphID = ttUSHORT(glyphArray + 2 * m);
            straw = glyphID;
            if (needle < straw)
               r = m - 1;
            else if (needle > straw)
               l = m + 1;
            else {
               return m;
            }
         }
         break;
      }

      case 2: {
         stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);
         stbtt_uint8 *rangeArray = coverageTable + 4;

         // Binary search.
         stbtt_int32 l=0, r=rangeCount-1, m;
         int strawStart, strawEnd, needle=glyph;
         while (l <= r) {
            stbtt_uint8 *rangeRecord;
            m = (l + r) >> 1;
            rangeRecord = rangeArray + 6 * m;
            strawStart = ttUSHORT(rangeRecord);
            strawEnd = ttUSHORT(rangeRecord + 2);
            if (needle < strawStart)
               r = m - 1;
            else if (needle > strawEnd)
               l = m + 1;
            else {
               stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);
               return startCoverageIndex + glyph - strawStart;
            }
         }
         break;
      }

      default: return -1; // unsupported
   }

   return -1;
}

static stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)
{
   stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);
   switch (classDefFormat)
   {
      case 1: {
         stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);
         stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);
         stbtt_uint8 *classDef1ValueArray = classDefTable + 6;

         if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)
            return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));
         break;
      }

      case 2: {
         stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);
         stbtt_uint8 *classRangeRecords = classDefTable + 4;

         // Binary search.
         stbtt_int32 l=0, r=classRangeCount-1, m;
         int strawStart, strawEnd, needle=glyph;
         while (l <= r) {
            stbtt_uint8 *classRangeRecord;
            m = (l + r) >> 1;
            classRangeRecord = classRangeRecords + 6 * m;
            strawStart = ttUSHORT(classRangeRecord);
            strawEnd = ttUSHORT(classRangeRecord + 2);
            if (needle < strawStart)
               r = m - 1;
            else if (needle > strawEnd)
               l = m + 1;
            else
               return (stbtt_int32)ttUSHORT(classRangeRecord + 4);
         }
         break;
      }

      default:
         return -1; // Unsupported definition type, return an error.
   }

   // "All glyphs not assigned to a class fall into class 0". (OpenType spec)
   return 0;
}

// Define to STBTT_assert(x) if you want to break on unimplemented formats.
#define STBTT_GPOS_TODO_assert(x)

static stbtt_int32 stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   stbtt_uint16 lookupListOffset;
   stbtt_uint8 *lookupList;
   stbtt_uint16 lookupCount;
   stbtt_uint8 *data;
   stbtt_int32 i, sti;

   if (!info->gpos) return 0;

   data = info->data + info->gpos;

   if (ttUSHORT(data+0) != 1) return 0; // Major version 1
   if (ttUSHORT(data+2) != 0) return 0; // Minor version 0

   lookupListOffset = ttUSHORT(data+8);
   lookupList = data + lookupListOffset;
   lookupCount = ttUSHORT(lookupList);

   for (i=0; i<lookupCount; ++i) {
      stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);
      stbtt_uint8 *lookupTable = lookupList + lookupOffset;

      stbtt_uint16 lookupType = ttUSHORT(lookupTable);
      stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);
      stbtt_uint8 *subTableOffsets = lookupTable + 6;
      if (lookupType != 2) // Pair Adjustment Positioning Subtable
         continue;

      for (sti=0; sti<subTableCount; sti++) {
         stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);
         stbtt_uint8 *table = lookupTable + subtableOffset;
         stbtt_uint16 posFormat = ttUSHORT(table);
         stbtt_uint16 coverageOffset = ttUSHORT(table + 2);
         stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);
         if (coverageIndex == -1) continue;

         switch (posFormat) {
            case 1: {
               stbtt_int32 l, r, m;
               int straw, needle;
               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?
                  stbtt_int32 valueRecordPairSizeInBytes = 2;
                  stbtt_uint16 pairSetCount = ttUSHORT(table + 8);
                  stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);
                  stbtt_uint8 *pairValueTable = table + pairPosOffset;
                  stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);
                  stbtt_uint8 *pairValueArray = pairValueTable + 2;

                  if (coverageIndex >= pairSetCount) return 0;

                  needle=glyph2;
                  r=pairValueCount-1;
                  l=0;

                  // Binary search.
                  while (l <= r) {
                     stbtt_uint16 secondGlyph;
                     stbtt_uint8 *pairValue;
                     m = (l + r) >> 1;
                     pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;
                     secondGlyph = ttUSHORT(pairValue);
                     straw = secondGlyph;
                     if (needle < straw)
                        r = m - 1;
                     else if (needle > straw)
                        l = m + 1;
                     else {
                        stbtt_int16 xAdvance = ttSHORT(pairValue + 2);
                        return xAdvance;
                     }
                  }
               } else
                  return 0;
               break;
            }

            case 2: {
               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?
                  stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);
                  stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);
                  int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);
                  int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);

                  stbtt_uint16 class1Count = ttUSHORT(table + 12);
                  stbtt_uint16 class2Count = ttUSHORT(table + 14);
                  stbtt_uint8 *class1Records, *class2Records;
                  stbtt_int16 xAdvance;

                  if (glyph1class < 0 || glyph1class >= class1Count) return 0; // malformed
                  if (glyph2class < 0 || glyph2class >= class2Count) return 0; // malformed

                  class1Records = table + 16;
                  class2Records = class1Records + 2 * (glyph1class * class2Count);
                  xAdvance = ttSHORT(class2Records + 2 * glyph2class);
                  return xAdvance;
               } else
                  return 0;
               break;
            }

            default:
               return 0; // Unsupported position format
         }
      }
   }

   return 0;
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)
{
   int xAdvance = 0;

   if (info->gpos)
      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);
   else if (info->kern)
      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);

   return xAdvance;
}

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)
{
   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs
      return 0;
   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));
}

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
{
   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);
}

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
{
   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
}

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)
{
   int tab = stbtt__find_table(info->data, info->fontstart, "OS/2");
   if (!tab)
      return 0;
   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);
   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);
   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);
   return 1;
}

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
{
   *x0 = ttSHORT(info->data + info->head + 36);
   *y0 = ttSHORT(info->data + info->head + 38);
   *x1 = ttSHORT(info->data + info->head + 40);
   *y1 = ttSHORT(info->data + info->head + 42);
}

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)
{
   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
   return (float) height / fheight;
}

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)
{
   int unitsPerEm = ttUSHORT(info->data + info->head + 18);
   return pixels / unitsPerEm;
}

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)
{
   STBTT_free(v, info->userdata);
}

STBTT_DEF stbtt_uint8 *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl)
{
   int i;
   stbtt_uint8 *data = info->data;
   stbtt_uint8 *svg_doc_list = data + stbtt__get_svg((stbtt_fontinfo *) info);

   int numEntries = ttUSHORT(svg_doc_list);
   stbtt_uint8 *svg_docs = svg_doc_list + 2;

   for(i=0; i<numEntries; i++) {
      stbtt_uint8 *svg_doc = svg_docs + (12 * i);
      if ((gl >= ttUSHORT(svg_doc)) && (gl <= ttUSHORT(svg_doc + 2)))
         return svg_doc;
   }
   return 0;
}

STBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg)
{
   stbtt_uint8 *data = info->data;
   stbtt_uint8 *svg_doc;

   if (info->svg == 0)
      return 0;

   svg_doc = stbtt_FindSVGDoc(info, gl);
   if (svg_doc != NULL) {
      *svg = (char *) data + info->svg + ttULONG(svg_doc + 4);
      return ttULONG(svg_doc + 8);
   } else {
      return 0;
   }
}

STBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg)
{
   return stbtt_GetGlyphSVG(info, stbtt_FindGlyphIndex(info, unicode_codepoint), svg);
}

//////////////////////////////////////////////////////////////////////////////
//
// antialiasing software rasterizer
//

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
      // e.g. space character
      if (ix0) *ix0 = 0;
      if (iy0) *iy0 = 0;
      if (ix1) *ix1 = 0;
      if (iy1) *iy1 = 0;
   } else {
      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
   }
}

STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Rasterizer

typedef struct stbtt__hheap_chunk
{
   struct stbtt__hheap_chunk *next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
   struct stbtt__hheap_chunk *head;
   void   *first_free;
   int    num_remaining_in_head_chunk;
} stbtt__hheap;

static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
{
   if (hh->first_free) {
      void *p = hh->first_free;
      hh->first_free = * (void **) p;
      return p;
   } else {
      if (hh->num_remaining_in_head_chunk == 0) {
         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
         if (c == NULL)
            return NULL;
         c->next = hh->head;
         hh->head = c;
         hh->num_remaining_in_head_chunk = count;
      }
      --hh->num_remaining_in_head_chunk;
      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
   }
}

static void stbtt__hheap_free(stbtt__hheap *hh, void *p)
{
   *(void **) p = hh->first_free;
   hh->first_free = p;
}

static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
{
   stbtt__hheap_chunk *c = hh->head;
   while (c) {
      stbtt__hheap_chunk *n = c->next;
      STBTT_free(c, userdata);
      c = n;
   }
}

typedef struct stbtt__edge {
   float x0,y0, x1,y1;
   int invert;
} stbtt__edge;


typedef struct stbtt__active_edge
{
   struct stbtt__active_edge *next;
   #if STBTT_RASTERIZER_VERSION==1
   int x,dx;
   float ey;
   int direction;
   #elif STBTT_RASTERIZER_VERSION==2
   float fx,fdx,fdy;
   float direction;
   float sy;
   float ey;
   #else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
   #endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   if (!z) return z;

   // round dx down to avoid overshooting
   if (dxdy < 0)
      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);
   else
      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);

   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount
   z->x -= off_x * STBTT_FIX;

   z->ey = e->y1;
   z->next = 0;
   z->direction = e->invert ? 1 : -1;
   return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   //STBTT_assert(e->y0 <= start_point);
   if (!z) return z;
   z->fdx = dxdy;
   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
   z->fx = e->x0 + dxdy * (start_point - e->y0);
   z->fx -= off_x;
   z->direction = e->invert ? 1.0f : -1.0f;
   z->sy = e->y0;
   z->ey = e->y1;
   z->next = 0;
   return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1
// note: this routine clips fills that extend off the edges... ideally this
// wouldn't happen, but it could happen if the truetype glyph bounding boxes
// are wrong, or if the user supplies a too-small bitmap
static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
{
   // non-zero winding fill
   int x0=0, w=0;

   while (e) {
      if (w == 0) {
         // if we're currently at zero, we need to record the edge start point
         x0 = e->x; w += e->direction;
      } else {
         int x1 = e->x; w += e->direction;
         // if we went to zero, we need to draw
         if (w == 0) {
            int i = x0 >> STBTT_FIXSHIFT;
            int j = x1 >> STBTT_FIXSHIFT;

            if (i < len && j >= 0) {
               if (i == j) {
                  // x0,x1 are the same pixel, so compute combined coverage
                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
               } else {
                  if (i >= 0) // add antialiasing for x0
                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     i = -1; // clip

                  if (j < len) // add antialiasing for x1
                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     j = len; // clip

                  for (++i; i < j; ++i) // fill pixels between x0 and x1
                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;
               }
            }
         }
      }

      e = e->next;
   }
}

static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0;
   int max_weight = (255 / vsubsample);  // weight per vertical scanline
   int s; // vertical subsample index
   unsigned char scanline_data[512], *scanline;

   if (result->w > 512)
      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);
   else
      scanline = scanline_data;

   y = off_y * vsubsample;
   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;

   while (j < result->h) {
      STBTT_memset(scanline, 0, result->w);
      for (s=0; s < vsubsample; ++s) {
         // find center of pixel for this scanline
         float scan_y = y + 0.5f;
         stbtt__active_edge **step = &active;

         // update all active edges;
         // remove all active edges that terminate before the center of this scanline
         while (*step) {
            stbtt__active_edge * z = *step;
            if (z->ey <= scan_y) {
               *step = z->next; // delete from list
               STBTT_assert(z->direction);
               z->direction = 0;
               stbtt__hheap_free(&hh, z);
            } else {
               z->x += z->dx; // advance to position for current scanline
               step = &((*step)->next); // advance through list
            }
         }

         // resort the list if needed
         for(;;) {
            int changed=0;
            step = &active;
            while (*step && (*step)->next) {
               if ((*step)->x > (*step)->next->x) {
                  stbtt__active_edge *t = *step;
                  stbtt__active_edge *q = t->next;

                  t->next = q->next;
                  q->next = t;
                  *step = q;
                  changed = 1;
               }
               step = &(*step)->next;
            }
            if (!changed) break;
         }

         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
         while (e->y0 <= scan_y) {
            if (e->y1 > scan_y) {
               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
               if (z != NULL) {
                  // find insertion point
                  if (active == NULL)
                     active = z;
                  else if (z->x < active->x) {
                     // insert at front
                     z->next = active;
                     active = z;
                  } else {
                     // find thing to insert AFTER
                     stbtt__active_edge *p = active;
                     while (p->next && p->next->x < z->x)
                        p = p->next;
                     // at this point, p->next->x is NOT < z->x
                     z->next = p->next;
                     p->next = z;
                  }
               }
            }
            ++e;
         }

         // now process all active edges in XOR fashion
         if (active)
            stbtt__fill_active_edges(scanline, result->w, active, max_weight);

         ++y;
      }
      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}

#elif STBTT_RASTERIZER_VERSION == 2

// the edge passed in here does not cross the vertical line at x or the vertical line at x+1
// (i.e. it has already been clipped to those)
static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
{
   if (y0 == y1) return;
   STBTT_assert(y0 < y1);
   STBTT_assert(e->sy <= e->ey);
   if (y0 > e->ey) return;
   if (y1 < e->sy) return;
   if (y0 < e->sy) {
      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
      y0 = e->sy;
   }
   if (y1 > e->ey) {
      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
      y1 = e->ey;
   }

   if (x0 == x)
      STBTT_assert(x1 <= x+1);
   else if (x0 == x+1)
      STBTT_assert(x1 >= x);
   else if (x0 <= x)
      STBTT_assert(x1 <= x);
   else if (x0 >= x+1)
      STBTT_assert(x1 >= x+1);
   else
      STBTT_assert(x1 >= x && x1 <= x+1);

   if (x0 <= x && x1 <= x)
      scanline[x] += e->direction * (y1-y0);
   else if (x0 >= x+1 && x1 >= x+1)
      ;
   else {
      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
   }
}

static float stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width)
{
   STBTT_assert(top_width >= 0);
   STBTT_assert(bottom_width >= 0);
   return (top_width + bottom_width) / 2.0f * height;
}

static float stbtt__position_trapezoid_area(float height, float tx0, float tx1, float bx0, float bx1)
{
   return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);
}

static float stbtt__sized_triangle_area(float height, float width)
{
   return height * width / 2;
}

static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
{
   float y_bottom = y_top+1;

   while (e) {
      // brute force every pixel

      // compute intersection points with top & bottom
      STBTT_assert(e->ey >= y_top);

      if (e->fdx == 0) {
         float x0 = e->fx;
         if (x0 < len) {
            if (x0 >= 0) {
               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
            } else {
               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
            }
         }
      } else {
         float x0 = e->fx;
         float dx = e->fdx;
         float xb = x0 + dx;
         float x_top, x_bottom;
         float sy0,sy1;
         float dy = e->fdy;
         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);

         // compute endpoints of line segment clipped to this scanline (if the
         // line segment starts on this scanline. x0 is the intersection of the
         // line with y_top, but that may be off the line segment.
         if (e->sy > y_top) {
            x_top = x0 + dx * (e->sy - y_top);
            sy0 = e->sy;
         } else {
            x_top = x0;
            sy0 = y_top;
         }
         if (e->ey < y_bottom) {
            x_bottom = x0 + dx * (e->ey - y_top);
            sy1 = e->ey;
         } else {
            x_bottom = xb;
            sy1 = y_bottom;
         }

         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
            // from here on, we don't have to range check x values

            if ((int) x_top == (int) x_bottom) {
               float height;
               // simple case, only spans one pixel
               int x = (int) x_top;
               height = (sy1 - sy0) * e->direction;
               STBTT_assert(x >= 0 && x < len);
               scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);
               scanline_fill[x] += height; // everything right of this pixel is filled
            } else {
               int x,x1,x2;
               float y_crossing, y_final, step, sign, area;
               // covers 2+ pixels
               if (x_top > x_bottom) {
                  // flip scanline vertically; signed area is the same
                  float t;
                  sy0 = y_bottom - (sy0 - y_top);
                  sy1 = y_bottom - (sy1 - y_top);
                  t = sy0, sy0 = sy1, sy1 = t;
                  t = x_bottom, x_bottom = x_top, x_top = t;
                  dx = -dx;
                  dy = -dy;
                  t = x0, x0 = xb, xb = t;
               }
               STBTT_assert(dy >= 0);
               STBTT_assert(dx >= 0);

               x1 = (int) x_top;
               x2 = (int) x_bottom;
               // compute intersection with y axis at x1+1
               y_crossing = y_top + dy * (x1+1 - x0);

               // compute intersection with y axis at x2
               y_final = y_top + dy * (x2 - x0);

               //           x1    x_top                            x2    x_bottom
               //     y_top  +------|-----+------------+------------+--------|---+------------+
               //            |            |            |            |            |            |
               //            |            |            |            |            |            |
               //       sy0  |      Txxxxx|............|............|............|............|
               // y_crossing |            *xxxxx.......|............|............|............|
               //            |            |     xxxxx..|............|............|............|
               //            |            |     /-   xx*xxxx........|............|............|
               //            |            | dy <       |    xxxxxx..|............|............|
               //   y_final  |            |     \-     |          xx*xxx.........|............|
               //       sy1  |            |            |            |   xxxxxB...|............|
               //            |            |            |            |            |            |
               //            |            |            |            |            |            |
               //  y_bottom  +------------+------------+------------+------------+------------+
               //
               // goal is to measure the area covered by '.' in each pixel

               // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057
               // @TODO: maybe test against sy1 rather than y_bottom?
               if (y_crossing > y_bottom)
                  y_crossing = y_bottom;

               sign = e->direction;

               // area of the rectangle covered from sy0..y_crossing
               area = sign * (y_crossing-sy0);

               // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)
               scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);

               // check if final y_crossing is blown up; no test case for this
               if (y_final > y_bottom) {
                  int denom = (x2 - (x1+1));
                  y_final = y_bottom;
                  if (denom != 0) { // [DEAR IMGUI] Avoid div by zero (https://github.com/nothings/stb/issues/1316)
                     dy = (y_final - y_crossing ) / denom; // if denom=0, y_final = y_crossing, so y_final <= y_bottom
                  }
               }

               // in second pixel, area covered by line segment found in first pixel
               // is always a rectangle 1 wide * the height of that line segment; this
               // is exactly what the variable 'area' stores. it also gets a contribution
               // from the line segment within it. the THIRD pixel will get the first
               // pixel's rectangle contribution, the second pixel's rectangle contribution,
               // and its own contribution. the 'own contribution' is the same in every pixel except
               // the leftmost and rightmost, a trapezoid that slides down in each pixel.
               // the second pixel's contribution to the third pixel will be the
               // rectangle 1 wide times the height change in the second pixel, which is dy.

               step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,
               // which multiplied by 1-pixel-width is how much pixel area changes for each step in x
               // so the area advances by 'step' every time

               for (x = x1+1; x < x2; ++x) {
                  scanline[x] += area + step/2; // area of trapezoid is 1*step/2
                  area += step;
               }
               STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down
               STBTT_assert(sy1 > y_final-0.01f);

               // area covered in the last pixel is the rectangle from all the pixels to the left,
               // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
               scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);

               // the rest of the line is filled based on the total height of the line segment in this pixel
               scanline_fill[x2] += sign * (sy1-sy0);
            }
         } else {
            // if edge goes outside of box we're drawing, we require
            // clipping logic. since this does not match the intended use
            // of this library, we use a different, very slow brute
            // force implementation
            // note though that this does happen some of the time because
            // x_top and x_bottom can be extrapolated at the top & bottom of
            // the shape and actually lie outside the bounding box
            int x;
            for (x=0; x < len; ++x) {
               // cases:
               //
               // there can be up to two intersections with the pixel. any intersection
               // with left or right edges can be handled by splitting into two (or three)
               // regions. intersections with top & bottom do not necessitate case-wise logic.
               //
               // the old way of doing this found the intersections with the left & right edges,
               // then used some simple logic to produce up to three segments in sorted order
               // from top-to-bottom. however, this had a problem: if an x edge was epsilon
               // across the x border, then the corresponding y position might not be distinct
               // from the other y segment, and it might ignored as an empty segment. to avoid
               // that, we need to explicitly produce segments based on x positions.

               // rename variables to clearly-defined pairs
               float y0 = y_top;
               float x1 = (float) (x);
               float x2 = (float) (x+1);
               float x3 = xb;
               float y3 = y_bottom;

               // x = e->x + e->dx * (y-y_top)
               // (y-y_top) = (x - e->x) / e->dx
               // y = (x - e->x) / e->dx + y_top
               float y1 = (x - x0) / dx + y_top;
               float y2 = (x+1 - x0) / dx + y_top;

               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else {  // one segment
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
               }
            }
         }
      }
      e = e->next;
   }
}

// directly AA rasterize edges w/o supersampling
static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0, i;
   float scanline_data[129], *scanline, *scanline2;

   STBTT__NOTUSED(vsubsample);

   if (result->w > 64)
      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
   else
      scanline = scanline_data;

   scanline2 = scanline + result->w;

   y = off_y;
   e[n].y0 = (float) (off_y + result->h) + 1;

   while (j < result->h) {
      // find center of pixel for this scanline
      float scan_y_top    = y + 0.0f;
      float scan_y_bottom = y + 1.0f;
      stbtt__active_edge **step = &active;

      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

      // update all active edges;
      // remove all active edges that terminate before the top of this scanline
      while (*step) {
         stbtt__active_edge * z = *step;
         if (z->ey <= scan_y_top) {
            *step = z->next; // delete from list
            STBTT_assert(z->direction);
            z->direction = 0;
            stbtt__hheap_free(&hh, z);
         } else {
            step = &((*step)->next); // advance through list
         }
      }

      // insert all edges that start before the bottom of this scanline
      while (e->y0 <= scan_y_bottom) {
         if (e->y0 != e->y1) {
            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
            if (z != NULL) {
               if (j == 0 && off_y != 0) {
                  if (z->ey < scan_y_top) {
                     // this can happen due to subpixel positioning and some kind of fp rounding error i think
                     z->ey = scan_y_top;
                  }
               }
               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
               // insert at front
               z->next = active;
               active = z;
            }
         }
         ++e;
      }

      // now process all active edges
      if (active)
         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

      {
         float sum = 0;
         for (i=0; i < result->w; ++i) {
            float k;
            int m;
            sum += scanline2[i];
            k = scanline[i] + sum;
            k = (float) STBTT_fabs(k)*255 + 0.5f;
            m = (int) k;
            if (m > 255) m = 255;
            result->pixels[j*result->stride + i] = (unsigned char) m;
         }
      }
      // advance all the edges
      step = &active;
      while (*step) {
         stbtt__active_edge *z = *step;
         z->fx += z->fdx; // advance to position for current scanline
         step = &((*step)->next); // advance through list
      }

      ++y;
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
{
   int i,j;
   for (i=1; i < n; ++i) {
      stbtt__edge t = p[i], *a = &t;
      j = i;
      while (j > 0) {
         stbtt__edge *b = &p[j-1];
         int c = STBTT__COMPARE(a,b);
         if (!c) break;
         p[j] = p[j-1];
         --j;
      }
      if (i != j)
         p[j] = t;
   }
}

static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
{
   /* threshold for transitioning to insertion sort */
   while (n > 12) {
      stbtt__edge t;
      int c01,c12,c,m,i,j;

      /* compute median of three */
      m = n >> 1;
      c01 = STBTT__COMPARE(&p[0],&p[m]);
      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
      if (c01 != c12) {
         /* otherwise, we'll need to swap something else to middle */
         int z;
         c = STBTT__COMPARE(&p[0],&p[n-1]);
         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
         z = (c == c12) ? 0 : n-1;
         t = p[z];
         p[z] = p[m];
         p[m] = t;
      }
      /* now p[m] is the median-of-three */
      /* swap it to the beginning so it won't move around */
      t = p[0];
      p[0] = p[m];
      p[m] = t;

      /* partition loop */
      i=1;
      j=n-1;
      for(;;) {
         /* handling of equality is crucial here */
         /* for sentinels & efficiency with duplicates */
         for (;;++i) {
            if (!STBTT__COMPARE(&p[i], &p[0])) break;
         }
         for (;;--j) {
            if (!STBTT__COMPARE(&p[0], &p[j])) break;
         }
         /* make sure we haven't crossed */
         if (i >= j) break;
         t = p[i];
         p[i] = p[j];
         p[j] = t;

         ++i;
         --j;
      }
      /* recurse on smaller side, iterate on larger */
      if (j < (n-i)) {
         stbtt__sort_edges_quicksort(p,j);
         p = p+i;
         n = n-i;
      } else {
         stbtt__sort_edges_quicksort(p+i, n-i);
         n = j;
      }
   }
}

static void stbtt__sort_edges(stbtt__edge *p, int n)
{
   stbtt__sort_edges_quicksort(p, n);
   stbtt__sort_edges_ins_sort(p, n);
}

typedef struct
{
   float x,y;
} stbtt__point;

static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
{
   float y_scale_inv = invert ? -scale_y : scale_y;
   stbtt__edge *e;
   int n,i,j,k,m;
#if STBTT_RASTERIZER_VERSION == 1
   int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
   int vsubsample = 1;
#else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity

   // now we have to blow out the windings into explicit edge lists
   n = 0;
   for (i=0; i < windings; ++i)
      n += wcount[i];

   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
   if (e == 0) return;
   n = 0;

   m=0;
   for (i=0; i < windings; ++i) {
      stbtt__point *p = pts + m;
      m += wcount[i];
      j = wcount[i]-1;
      for (k=0; k < wcount[i]; j=k++) {
         int a=k,b=j;
         // skip the edge if horizontal
         if (p[j].y == p[k].y)
            continue;
         // add edge from j to k to the list
         e[n].invert = 0;
         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
            e[n].invert = 1;
            a=j,b=k;
         }
         e[n].x0 = p[a].x * scale_x + shift_x;
         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
         e[n].x1 = p[b].x * scale_x + shift_x;
         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
         ++n;
      }
   }

   // now sort the edges by their highest point (should snap to integer, and then by x)
   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
   stbtt__sort_edges(e, n);

   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

   STBTT_free(e, userdata);
}

static void stbtt__add_point(stbtt__point *points, int n, float x, float y)
{
   if (!points) return; // during first pass, it's unallocated
   points[n].x = x;
   points[n].y = y;
}

// tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching
static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
{
   // midpoint
   float mx = (x0 + 2*x1 + x2)/4;
   float my = (y0 + 2*y1 + y2)/4;
   // versus directly drawn line
   float dx = (x0+x2)/2 - mx;
   float dy = (y0+y2)/2 - my;
   if (n > 16) // 65536 segments on one curve better be enough!
      return 1;
   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x2,y2);
      *num_points = *num_points+1;
   }
   return 1;
}

static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
{
   // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
   float dx0 = x1-x0;
   float dy0 = y1-y0;
   float dx1 = x2-x1;
   float dy1 = y2-y1;
   float dx2 = x3-x2;
   float dy2 = y3-y2;
   float dx = x3-x0;
   float dy = y3-y0;
   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));
   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);
   float flatness_squared = longlen*longlen-shortlen*shortlen;

   if (n > 16) // 65536 segments on one curve better be enough!
      return;

   if (flatness_squared > objspace_flatness_squared) {
      float x01 = (x0+x1)/2;
      float y01 = (y0+y1)/2;
      float x12 = (x1+x2)/2;
      float y12 = (y1+y2)/2;
      float x23 = (x2+x3)/2;
      float y23 = (y2+y3)/2;

      float xa = (x01+x12)/2;
      float ya = (y01+y12)/2;
      float xb = (x12+x23)/2;
      float yb = (y12+y23)/2;

      float mx = (xa+xb)/2;
      float my = (ya+yb)/2;

      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x3,y3);
      *num_points = *num_points+1;
   }
}

// returns number of contours
static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
{
   stbtt__point *points=0;
   int num_points=0;

   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
   int i,n=0,start=0, pass;

   // count how many "moves" there are to get the contour count
   for (i=0; i < num_verts; ++i)
      if (vertices[i].type == STBTT_vmove)
         ++n;

   *num_contours = n;
   if (n == 0) return 0;

   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

   if (*contour_lengths == 0) {
      *num_contours = 0;
      return 0;
   }

   // make two passes through the points so we don't need to realloc
   for (pass=0; pass < 2; ++pass) {
      float x=0,y=0;
      if (pass == 1) {
         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
         if (points == NULL) goto error;
      }
      num_points = 0;
      n= -1;
      for (i=0; i < num_verts; ++i) {
         switch (vertices[i].type) {
            case STBTT_vmove:
               // start the next contour
               if (n >= 0)
                  (*contour_lengths)[n] = num_points - start;
               ++n;
               start = num_points;

               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x,y);
               break;
            case STBTT_vline:
               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x, y);
               break;
            case STBTT_vcurve:
               stbtt__tesselate_curve(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
            case STBTT_vcubic:
               stbtt__tesselate_cubic(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].cx1, vertices[i].cy1,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
         }
      }
      (*contour_lengths)[n] = num_points - start;
   }

   return points;
error:
   STBTT_free(points, userdata);
   STBTT_free(*contour_lengths, userdata);
   *contour_lengths = 0;
   *num_contours = 0;
   return NULL;
}

STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
{
   float scale            = scale_x > scale_y ? scale_y : scale_x;
   int winding_count      = 0;
   int *winding_lengths   = NULL;
   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
   if (windings) {
      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
      STBTT_free(winding_lengths, userdata);
      STBTT_free(windings, userdata);
   }
}

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   int ix0,iy0,ix1,iy1;
   stbtt__bitmap gbm;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) {
         STBTT_free(vertices, info->userdata);
         return NULL;
      }
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);

   // now we get the size
   gbm.w = (ix1 - ix0);
   gbm.h = (iy1 - iy0);
   gbm.pixels = NULL; // in case we error

   if (width ) *width  = gbm.w;
   if (height) *height = gbm.h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   if (gbm.w && gbm.h) {
      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);
      if (gbm.pixels) {
         gbm.stride = gbm.w;

         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
      }
   }
   STBTT_free(vertices, info->userdata);
   return gbm.pixels;
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
{
   int ix0,iy0;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
   stbtt__bitmap gbm;

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
   gbm.pixels = output;
   gbm.w = out_w;
   gbm.h = out_h;
   gbm.stride = out_stride;

   if (gbm.w && gbm.h)
      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);

   STBTT_free(vertices, info->userdata);
}

STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);
}

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
{
   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);
}

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-CRAPPY packing to keep source code small

static int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata)
{
   float scale;
   int x,y,bottom_y, i;
   stbtt_fontinfo f;
   f.userdata = NULL;
   if (!stbtt_InitFont(&f, data, offset))
      return -1;
   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
   x=y=1;
   bottom_y = 1;

   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);

   for (i=0; i < num_chars; ++i) {
      int advance, lsb, x0,y0,x1,y1,gw,gh;
      int g = stbtt_FindGlyphIndex(&f, first_char + i);
      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);
      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);
      gw = x1-x0;
      gh = y1-y0;
      if (x + gw + 1 >= pw)
         y = bottom_y, x = 1; // advance to next row
      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row
         return -i;
      STBTT_assert(x+gw < pw);
      STBTT_assert(y+gh < ph);
      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);
      chardata[i].x0 = (stbtt_int16) x;
      chardata[i].y0 = (stbtt_int16) y;
      chardata[i].x1 = (stbtt_int16) (x + gw);
      chardata[i].y1 = (stbtt_int16) (y + gh);
      chardata[i].xadvance = scale * advance;
      chardata[i].xoff     = (float) x0;
      chardata[i].yoff     = (float) y0;
      x = x + gw + 1;
      if (y+gh+1 > bottom_y)
         bottom_y = y+gh+1;
   }
   return bottom_y;
}

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
{
   float d3d_bias = opengl_fillrule ? 0 : -0.5f;
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_bakedchar *b = chardata + char_index;
   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);
   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);

   q->x0 = round_x + d3d_bias;
   q->y0 = round_y + d3d_bias;
   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;
   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// rectangle packing replacement routines if you don't have stb_rect_pack.h
//

#ifndef STB_RECT_PACK_VERSION

typedef int stbrp_coord;

////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//                                                                                //
// COMPILER WARNING ?!?!?                                                         //
//                                                                                //
//                                                                                //
// if you get a compile warning due to these symbols being defined more than      //
// once, move #include "stb_rect_pack.h" before #include "stb_truetype.h"         //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
   int width,height;
   int x,y,bottom_y;
} stbrp_context;

typedef struct
{
   unsigned char x;
} stbrp_node;

struct stbrp_rect
{
   stbrp_coord x,y;
   int id,w,h,was_packed;
};

static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)
{
   con->width  = pw;
   con->height = ph;
   con->x = 0;
   con->y = 0;
   con->bottom_y = 0;
   STBTT__NOTUSED(nodes);
   STBTT__NOTUSED(num_nodes);
}

static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)
{
   int i;
   for (i=0; i < num_rects; ++i) {
      if (con->x + rects[i].w > con->width) {
         con->x = 0;
         con->y = con->bottom_y;
      }
      if (con->y + rects[i].h > con->height)
         break;
      rects[i].x = con->x;
      rects[i].y = con->y;
      rects[i].was_packed = 1;
      con->x += rects[i].w;
      if (con->y + rects[i].h > con->bottom_y)
         con->bottom_y = con->y + rects[i].h;
   }
   for (   ; i < num_rects; ++i)
      rects[i].was_packed = 0;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.

STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
{
   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
   int            num_nodes = pw - padding;
   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

   if (context == NULL || nodes == NULL) {
      if (context != NULL) STBTT_free(context, alloc_context);
      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
      return 0;
   }

   spc->user_allocator_context = alloc_context;
   spc->width = pw;
   spc->height = ph;
   spc->pixels = pixels;
   spc->pack_info = context;
   spc->nodes = nodes;
   spc->padding = padding;
   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
   spc->h_oversample = 1;
   spc->v_oversample = 1;
   spc->skip_missing = 0;

   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

   if (pixels)
      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels

   return 1;
}

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)
{
   STBTT_free(spc->nodes    , spc->user_allocator_context);
   STBTT_free(spc->pack_info, spc->user_allocator_context);
}

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
{
   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
   if (h_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->h_oversample = h_oversample;
   if (v_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->v_oversample = v_oversample;
}

STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)
{
   spc->skip_missing = skip;
}

#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)

static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_w = w - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < h; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < w; ++i) {
         STBTT_assert(pixels[i] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i] = (unsigned char) (total / kernel_width);
      }

      pixels += stride_in_bytes;
   }
}

static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_h = h - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < w; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < h; ++i) {
         STBTT_assert(pixels[i*stride_in_bytes] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
      }

      pixels += 1;
   }
}

static float stbtt__oversample_shift(int oversample)
{
   if (!oversample)
      return 0.0f;

   // The prefilter is a box filter of width "oversample",
   // which shifts phase by (oversample - 1)/2 pixels in
   // oversampled space. We want to shift in the opposite
   // direction to counter this.
   return (float)-(oversample - 1) / (2.0f * (float)oversample);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k;
   int missing_glyph_added = 0;

   k=0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      ranges[i].h_oversample = (unsigned char) spc->h_oversample;
      ranges[i].v_oversample = (unsigned char) spc->v_oversample;
      for (j=0; j < ranges[i].num_chars; ++j) {
         int x0,y0,x1,y1;
         int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
         int glyph = stbtt_FindGlyphIndex(info, codepoint);
         if (glyph == 0 && (spc->skip_missing || missing_glyph_added)) {
            rects[k].w = rects[k].h = 0;
         } else {
            stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,
                                            scale * spc->h_oversample,
                                            scale * spc->v_oversample,
                                            0,0,
                                            &x0,&y0,&x1,&y1);
            rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);
            rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);
            if (glyph == 0)
               missing_glyph_added = 1;
         }
         ++k;
      }
   }

   return k;
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info,
                                 output,
                                 out_w - (prefilter_x - 1),
                                 out_h - (prefilter_y - 1),
                                 out_stride,
                                 scale_x,
                                 scale_y,
                                 shift_x,
                                 shift_y,
                                 glyph);

   if (prefilter_x > 1)
      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);

   if (prefilter_y > 1)
      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);

   *sub_x = stbtt__oversample_shift(prefilter_x);
   *sub_y = stbtt__oversample_shift(prefilter_y);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k, missing_glyph = -1, return_value = 1;

   // save current values
   int old_h_over = spc->h_oversample;
   int old_v_over = spc->v_oversample;

   k = 0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      float recip_h,recip_v,sub_x,sub_y;
      spc->h_oversample = ranges[i].h_oversample;
      spc->v_oversample = ranges[i].v_oversample;
      recip_h = 1.0f / spc->h_oversample;
      recip_v = 1.0f / spc->v_oversample;
      sub_x = stbtt__oversample_shift(spc->h_oversample);
      sub_y = stbtt__oversample_shift(spc->v_oversample);
      for (j=0; j < ranges[i].num_chars; ++j) {
         stbrp_rect *r = &rects[k];
         if (r->was_packed && r->w != 0 && r->h != 0) {
            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
            int advance, lsb, x0,y0,x1,y1;
            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
            int glyph = stbtt_FindGlyphIndex(info, codepoint);
            stbrp_coord pad = (stbrp_coord) spc->padding;

            // pad on left and top
            r->x += pad;
            r->y += pad;
            r->w -= pad;
            r->h -= pad;
            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
            stbtt_GetGlyphBitmapBox(info, glyph,
                                    scale * spc->h_oversample,
                                    scale * spc->v_oversample,
                                    &x0,&y0,&x1,&y1);
            stbtt_MakeGlyphBitmapSubpixel(info,
                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                          r->w - spc->h_oversample+1,
                                          r->h - spc->v_oversample+1,
                                          spc->stride_in_bytes,
                                          scale * spc->h_oversample,
                                          scale * spc->v_oversample,
                                          0,0,
                                          glyph);

            if (spc->h_oversample > 1)
               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->h_oversample);

            if (spc->v_oversample > 1)
               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->v_oversample);

            bc->x0       = (stbtt_int16)  r->x;
            bc->y0       = (stbtt_int16)  r->y;
            bc->x1       = (stbtt_int16) (r->x + r->w);
            bc->y1       = (stbtt_int16) (r->y + r->h);
            bc->xadvance =                scale * advance;
            bc->xoff     =       (float)  x0 * recip_h + sub_x;
            bc->yoff     =       (float)  y0 * recip_v + sub_y;
            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;

            if (glyph == 0)
               missing_glyph = j;
         } else if (spc->skip_missing) {
            return_value = 0;
         } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {
            ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];
         } else {
            return_value = 0; // if any fail, report failure
         }

         ++k;
      }
   }

   // restore original values
   spc->h_oversample = old_h_over;
   spc->v_oversample = old_v_over;

   return return_value;
}

STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
{
   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);
}

STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
{
   stbtt_fontinfo info;
   int i, j, n, return_value; // [DEAR IMGUI] removed = 1;
   //stbrp_context *context = (stbrp_context *) spc->pack_info;
   stbrp_rect    *rects;

   // flag all characters as NOT packed
   for (i=0; i < num_ranges; ++i)
      for (j=0; j < ranges[i].num_chars; ++j)
         ranges[i].chardata_for_range[j].x0 =
         ranges[i].chardata_for_range[j].y0 =
         ranges[i].chardata_for_range[j].x1 =
         ranges[i].chardata_for_range[j].y1 = 0;

   n = 0;
   for (i=0; i < num_ranges; ++i)
      n += ranges[i].num_chars;

   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);
   if (rects == NULL)
      return 0;

   info.userdata = spc->user_allocator_context;
   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));

   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);

   stbtt_PackFontRangesPackRects(spc, rects, n);

   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);

   STBTT_free(rects, spc->user_allocator_context);
   return return_value;
}

STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
{
   stbtt_pack_range range;
   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;
   range.array_of_unicode_codepoints = NULL;
   range.num_chars                   = num_chars_in_range;
   range.chardata_for_range          = chardata_for_range;
   range.font_size                   = font_size;
   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);
}

STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)
{
   int i_ascent, i_descent, i_lineGap;
   float scale;
   stbtt_fontinfo info;
   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));
   scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);
   stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);
   *ascent  = (float) i_ascent  * scale;
   *descent = (float) i_descent * scale;
   *lineGap = (float) i_lineGap * scale;
}

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
{
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_packedchar *b = chardata + char_index;

   if (align_to_integer) {
      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
      q->x0 = x;
      q->y0 = y;
      q->x1 = x + b->xoff2 - b->xoff;
      q->y1 = y + b->yoff2 - b->yoff;
   } else {
      q->x0 = *xpos + b->xoff;
      q->y0 = *ypos + b->yoff;
      q->x1 = *xpos + b->xoff2;
      q->y1 = *ypos + b->yoff2;
   }

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// sdf computation
//

#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))
#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))

static int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])
{
   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];
   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];
   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];
   float roperp = orig[1]*ray[0] - orig[0]*ray[1];

   float a = q0perp - 2*q1perp + q2perp;
   float b = q1perp - q0perp;
   float c = q0perp - roperp;

   float s0 = 0., s1 = 0.;
   int num_s = 0;

   if (a != 0.0) {
      float discr = b*b - a*c;
      if (discr > 0.0) {
         float rcpna = -1 / a;
         float d = (float) STBTT_sqrt(discr);
         s0 = (b+d) * rcpna;
         s1 = (b-d) * rcpna;
         if (s0 >= 0.0 && s0 <= 1.0)
            num_s = 1;
         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {
            if (num_s == 0) s0 = s1;
            ++num_s;
         }
      }
   } else {
      // 2*b*s + c = 0
      // s = -c / (2*b)
      s0 = c / (-2 * b);
      if (s0 >= 0.0 && s0 <= 1.0)
         num_s = 1;
   }

   if (num_s == 0)
      return 0;
   else {
      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);
      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;

      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;
      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;
      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;
      float rod = orig[0]*rayn_x + orig[1]*rayn_y;

      float q10d = q1d - q0d;
      float q20d = q2d - q0d;
      float q0rd = q0d - rod;

      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;
      hits[0][1] = a*s0+b;

      if (num_s > 1) {
         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;
         hits[1][1] = a*s1+b;
         return 2;
      } else {
         return 1;
      }
   }
}

static int equal(float *a, float *b)
{
   return (a[0] == b[0] && a[1] == b[1]);
}

static int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)
{
   int i;
   float orig[2], ray[2] = { 1, 0 };
   float y_frac;
   int winding = 0;

   // make sure y never passes through a vertex of the shape
   y_frac = (float) STBTT_fmod(y, 1.0f);
   if (y_frac < 0.01f)
      y += 0.01f;
   else if (y_frac > 0.99f)
      y -= 0.01f;

   orig[0] = x;
   orig[1] = y;

   // test a ray from (-infinity,y) to (x,y)
   for (i=0; i < nverts; ++i) {
      if (verts[i].type == STBTT_vline) {
         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;
         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;
         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
            if (x_inter < x)
               winding += (y0 < y1) ? 1 : -1;
         }
      }
      if (verts[i].type == STBTT_vcurve) {
         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;
         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;
         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;
         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));
         int by = STBTT_max(y0,STBTT_max(y1,y2));
         if (y > ay && y < by && x > ax) {
            float q0[2],q1[2],q2[2];
            float hits[2][2];
            q0[0] = (float)x0;
            q0[1] = (float)y0;
            q1[0] = (float)x1;
            q1[1] = (float)y1;
            q2[0] = (float)x2;
            q2[1] = (float)y2;
            if (equal(q0,q1) || equal(q1,q2)) {
               x0 = (int)verts[i-1].x;
               y0 = (int)verts[i-1].y;
               x1 = (int)verts[i  ].x;
               y1 = (int)verts[i  ].y;
               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
                  if (x_inter < x)
                     winding += (y0 < y1) ? 1 : -1;
               }
            } else {
               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);
               if (num_hits >= 1)
                  if (hits[0][0] < 0)
                     winding += (hits[0][1] < 0 ? -1 : 1);
               if (num_hits >= 2)
                  if (hits[1][0] < 0)
                     winding += (hits[1][1] < 0 ? -1 : 1);
            }
         }
      }
   }
   return winding;
}

static float stbtt__cuberoot( float x )
{
   if (x<0)
      return -(float) STBTT_pow(-x,1.0f/3.0f);
   else
      return  (float) STBTT_pow( x,1.0f/3.0f);
}

// x^3 + a*x^2 + b*x + c = 0
static int stbtt__solve_cubic(float a, float b, float c, float* r)
{
   float s = -a / 3;
   float p = b - a*a / 3;
   float q = a * (2*a*a - 9*b) / 27 + c;
   float p3 = p*p*p;
   float d = q*q + 4*p3 / 27;
   if (d >= 0) {
      float z = (float) STBTT_sqrt(d);
      float u = (-q + z) / 2;
      float v = (-q - z) / 2;
      u = stbtt__cuberoot(u);
      v = stbtt__cuberoot(v);
      r[0] = s + u + v;
      return 1;
   } else {
      float u = (float) STBTT_sqrt(-p/3);
      float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative
      float m = (float) STBTT_cos(v);
      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;
      r[0] = s + u * 2 * m;
      r[1] = s - u * (m + n);
      r[2] = s - u * (m - n);

      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?
      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);
      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);
      return 3;
   }
}

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   float scale_x = scale, scale_y = scale;
   int ix0,iy0,ix1,iy1;
   int w,h;
   unsigned char *data;

   if (scale == 0) return NULL;

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);

   // if empty, return NULL
   if (ix0 == ix1 || iy0 == iy1)
      return NULL;

   ix0 -= padding;
   iy0 -= padding;
   ix1 += padding;
   iy1 += padding;

   w = (ix1 - ix0);
   h = (iy1 - iy0);

   if (width ) *width  = w;
   if (height) *height = h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   // invert for y-downwards bitmaps
   scale_y = -scale_y;

   {
      int x,y,i,j;
      float *precompute;
      stbtt_vertex *verts;
      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);
      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);
      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);

      for (i=0,j=num_verts-1; i < num_verts; j=i++) {
         if (verts[i].type == STBTT_vline) {
            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;
            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;
            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));
            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;
         } else if (verts[i].type == STBTT_vcurve) {
            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;
            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;
            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;
            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
            float len2 = bx*bx + by*by;
            if (len2 != 0.0f)
               precompute[i] = 1.0f / (bx*bx + by*by);
            else
               precompute[i] = 0.0f;
         } else
            precompute[i] = 0.0f;
      }

      for (y=iy0; y < iy1; ++y) {
         for (x=ix0; x < ix1; ++x) {
            float val;
            float min_dist = 999999.0f;
            float sx = (float) x + 0.5f;
            float sy = (float) y + 0.5f;
            float x_gspace = (sx / scale_x);
            float y_gspace = (sy / scale_y);

            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path

            for (i=0; i < num_verts; ++i) {
               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;

               if (verts[i].type == STBTT_vline && precompute[i] != 0.0f) {
                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;

                  float dist,dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);
                  if (dist2 < min_dist*min_dist)
                     min_dist = (float) STBTT_sqrt(dist2);

                  // coarse culling against bbox
                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&
                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)
                  dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];
                  STBTT_assert(i != 0);
                  if (dist < min_dist) {
                     // check position along line
                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)
                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)
                     float dx = x1-x0, dy = y1-y0;
                     float px = x0-sx, py = y0-sy;
                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy
                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve
                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);
                     if (t >= 0.0f && t <= 1.0f)
                        min_dist = dist;
                  }
               } else if (verts[i].type == STBTT_vcurve) {
                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;
                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;
                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);
                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);
                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);
                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);
                  // coarse culling against bbox to avoid computing cubic unnecessarily
                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {
                     int num=0;
                     float ax = x1-x0, ay = y1-y0;
                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
                     float mx = x0 - sx, my = y0 - sy;
                     float res[3] = {0.f,0.f,0.f};
                     float px,py,t,it,dist2;
                     float a_inv = precompute[i];
                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula
                        float a = 3*(ax*bx + ay*by);
                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);
                        float c = mx*ax+my*ay;
                        if (a == 0.0) { // if a is 0, it's linear
                           if (b != 0.0) {
                              res[num++] = -c/b;
                           }
                        } else {
                           float discriminant = b*b - 4*a*c;
                           if (discriminant < 0)
                              num = 0;
                           else {
                              float root = (float) STBTT_sqrt(discriminant);
                              res[0] = (-b - root)/(2*a);
                              res[1] = (-b + root)/(2*a);
                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work
                           }
                        }
                     } else {
                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point
                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;
                        float d = (mx*ax+my*ay) * a_inv;
                        num = stbtt__solve_cubic(b, c, d, res);
                     }
                     dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);
                     if (dist2 < min_dist*min_dist)
                        min_dist = (float) STBTT_sqrt(dist2);

                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {
                        t = res[0], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {
                        t = res[1], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {
                        t = res[2], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                  }
               }
            }
            if (winding == 0)
               min_dist = -min_dist;  // if outside the shape, value is negative
            val = onedge_value + pixel_dist_scale * min_dist;
            if (val < 0)
               val = 0;
            else if (val > 255)
               val = 255;
            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;
         }
      }
      STBTT_free(precompute, info->userdata);
      STBTT_free(verts, info->userdata);
   }
   return data;
}

STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

//////////////////////////////////////////////////////////////////////////////
//
// font name matching -- recommended not to use this
//

// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string
static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2)
{
   stbtt_int32 i=0;

   // convert utf16 to utf8 and compare the results while converting
   while (len2) {
      stbtt_uint16 ch = s2[0]*256 + s2[1];
      if (ch < 0x80) {
         if (i >= len1) return -1;
         if (s1[i++] != ch) return -1;
      } else if (ch < 0x800) {
         if (i+1 >= len1) return -1;
         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;
         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;
      } else if (ch >= 0xd800 && ch < 0xdc00) {
         stbtt_uint32 c;
         stbtt_uint16 ch2 = s2[2]*256 + s2[3];
         if (i+3 >= len1) return -1;
         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;
         if (s1[i++] != 0xf0 + (c >> 18)) return -1;
         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;
         s2 += 2; // plus another 2 below
         len2 -= 2;
      } else if (ch >= 0xdc00 && ch < 0xe000) {
         return -1;
      } else {
         if (i+2 >= len1) return -1;
         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;
         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;
      }
      s2 += 2;
      len2 -= 2;
   }
   return i;
}

static int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2)
{
   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);
}

// returns results in whatever encoding you request... but note that 2-byte encodings
// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare
STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
{
   stbtt_int32 i,count,stringOffset;
   stbtt_uint8 *fc = font->data;
   stbtt_uint32 offset = font->fontstart;
   stbtt_uint32 nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return NULL;

   count = ttUSHORT(fc+nm+2);
   stringOffset = nm + ttUSHORT(fc+nm+4);
   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)
          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {
         *length = ttUSHORT(fc+loc+8);
         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));
      }
   }
   return NULL;
}

static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)
{
   stbtt_int32 i;
   stbtt_int32 count = ttUSHORT(fc+nm+2);
   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);

   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      stbtt_int32 id = ttUSHORT(fc+loc+6);
      if (id == target_id) {
         // find the encoding
         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);

         // is this a Unicode encoding?
         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {
            stbtt_int32 slen = ttUSHORT(fc+loc+8);
            stbtt_int32 off = ttUSHORT(fc+loc+10);

            // check if there's a prefix match
            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);
            if (matchlen >= 0) {
               // check for target_id+1 immediately following, with same encoding & language
               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {
                  slen = ttUSHORT(fc+loc+12+8);
                  off = ttUSHORT(fc+loc+12+10);
                  if (slen == 0) {
                     if (matchlen == nlen)
                        return 1;
                  } else if (matchlen < nlen && name[matchlen] == ' ') {
                     ++matchlen;
                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))
                        return 1;
                  }
               } else {
                  // if nothing immediately following
                  if (matchlen == nlen)
                     return 1;
               }
            }
         }

         // @TODO handle other encodings
      }
   }
   return 0;
}

static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)
{
   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);
   stbtt_uint32 nm,hd;
   if (!stbtt__isfont(fc+offset)) return 0;

   // check italics/bold/underline flags in macStyle...
   if (flags) {
      hd = stbtt__find_table(fc, offset, "head");
      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;
   }

   nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return 0;

   if (flags) {
      // if we checked the macStyle flags, then just check the family and ignore the subfamily
      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   } else {
      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   }

   return 0;
}

static int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)
{
   stbtt_int32 i;
   for (i=0;;++i) {
      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);
      if (off < 0) return off;
      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))
         return off;
   }
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,
                                float pixel_height, unsigned char *pixels, int pw, int ph,
                                int first_char, int num_chars, stbtt_bakedchar *chardata)
{
   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);
}

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)
{
   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);
}

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)
{
   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);
}

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)
{
   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
}

STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)
{
   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);
}

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)
{
   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif // STB_TRUETYPE_IMPLEMENTATION


// FULL VERSION HISTORY
//
//   1.25 (2021-07-11) many fixes
//   1.24 (2020-02-05) fix warning
//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)
//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined
//   1.21 (2019-02-25) fix warning
//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()
//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) allow user-defined fabs() replacement
//                     fix memory leak if fontsize=0.0
//                     fix warning from duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     allow PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)
//                     also more precise AA rasterizer, except if shapes overlap
//                     remove need for STBTT_sort
//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC
//   1.04 (2015-04-15) typo in example
//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes
//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++
//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match
//                        non-oversampled; STBTT_POINT_SIZE for packed case only
//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling
//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)
//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID
//   0.8b (2014-07-07) fix a warning
//   0.8  (2014-05-25) fix a few more warnings
//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back
//   0.6c (2012-07-24) improve documentation
//   0.6b (2012-07-20) fix a few more warnings
//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,
//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty
//   0.5  (2011-12-09) bugfixes:
//                        subpixel glyph renderer computed wrong bounding box
//                        first vertex of shape can be off-curve (FreeSans)
//   0.4b (2011-12-03) fixed an error in the font baking example
//   0.4  (2011-12-01) kerning, subpixel rendering (tor)
//                    bugfixes for:
//                        codepoint-to-glyph conversion using table fmt=12
//                        codepoint-to-glyph conversion using table fmt=4
//                        stbtt_GetBakedQuad with non-square texture (Zer)
//                    updated Hello World! sample to use kerning and subpixel
//                    fixed some warnings
//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)
//                    userdata, malloc-from-userdata, non-zero fill (stb)
//   0.2  (2009-03-11) Fix unsigned/signed char warnings
//   0.1  (2009-03-09) First public release
//

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/



================================================
FILE: Utils/CallStack-Spoofer.h
================================================
﻿#pragma once
#ifdef _KERNEL_MODE
#include <ntddk.h>
#include <ntdef.h>
#include <xtr1common> 
#else
#include <Windows.h>
#include <utility>
#endif
#include  <Intrin.h> 

#if defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-local-typedef"
#endif

/*
 *  Copyright 2022 Barracudach
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 // === FAQ === documentation is available at https://github.com/Barracudach
//Supports 2 modes: kernelmode and usermode(x64)
//For kernel- disable Control Flow Guard (CFG) /guard:cf 
//usermode c++17 and above
//kernelmode c++14 and above


#ifndef NDEBUG
#define SPOOF_FUNC
#define SPOOF_CALL(name) (name)
#else
#define SPOOF_FUNC CallSpoofer::SpoofFunction spoof(_AddressOfReturnAddress());
#ifdef _KERNEL_MODE
#define SPOOF_CALL(ret_type,name) (CallSpoofer::SafeCall<ret_type,std::remove_reference_t<decltype(*name)>>(name))
#else
#define SPOOF_CALL(name) (CallSpoofer::SafeCall(name))
#endif
#endif

#define MAX_FUNC_BUFFERED 100
#define SHELLCODE_GENERATOR_SIZE 500

namespace CallSpoofer
{
#ifdef _KERNEL_MODE
	typedef unsigned __int64  uintptr_t, size_t;
#pragma region std::forward
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
		using _Const_thru_ref_type = const _Ty;
	};
	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	template <class>
	constexpr bool is_lvalue_reference_v = false; // determine whether type argument is an lvalue reference

	template <class _Ty>
	constexpr bool is_lvalue_reference_v<_Ty&> = true;

	template <class _Ty>
	constexpr _Ty&& forward(
		remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue
		return static_cast<_Ty&&>(_Arg);
	}

	template <class _Ty>
	constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept { // forward an rvalue as an rvalue
		static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
		return static_cast<_Ty&&>(_Arg);
	}
#pragma endregion 

#else
	using namespace std;
#endif

}


namespace CallSpoofer
{
	class SpoofFunction
	{
	public:
		uintptr_t temp = 0;
		const uintptr_t xor_key = 0xff00ff00ff00ff00;
		void* ret_addr_in_stack = 0;

		SpoofFunction(void* addr) :ret_addr_in_stack(addr)
		{
			temp = *(uintptr_t*)ret_addr_in_stack;
			temp ^= xor_key;
			*(uintptr_t*)ret_addr_in_stack = 0;
		}
		~SpoofFunction()
		{
			temp ^= xor_key;
			*(uintptr_t*)ret_addr_in_stack = temp;
		}
	};

#ifdef _KERNEL_MODE
	__forceinline PVOID LocateShellCode(PVOID func, size_t size = 500)
	{
		void* addr = ExAllocatePoolWithTag(NonPagedPool, size, (ULONG)"File");
		if (!addr)
			return nullptr;
		return memcpy(addr, func, size);
	}
#else
	__forceinline PVOID LocateShellCode(PVOID func, size_t size = SHELLCODE_GENERATOR_SIZE)
	{
		void* addr = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
		if (!addr)
			return nullptr;
		return memcpy(addr, func, size);
	}
#endif

#ifdef _KERNEL_MODE
	template <typename RetType, typename Func, typename ...Args>
	RetType
#else
	template <typename Func, typename ...Args>
	typename std::invoke_result<Func, Args...>::type
#endif
		__declspec(safebuffers)ShellCodeGenerator(Func f, Args&... args)
	{
#ifdef _KERNEL_MODE
		using this_func_type = decltype(ShellCodeGenerator<RetType, Func, Args&...>);
		using return_type = RetType;
#else
		using this_func_type = decltype(ShellCodeGenerator<Func, Args&...>);
		using return_type = typename std::invoke_result<Func, Args...>::type;
#endif
		const uintptr_t xor_key = 0xff00ff00ff00ff00;
		void* ret_addr_in_stack = _AddressOfReturnAddress();
		uintptr_t temp = *(uintptr_t*)ret_addr_in_stack;
		temp ^= xor_key;
		*(uintptr_t*)ret_addr_in_stack = 0;

		if constexpr (std::is_same<return_type, void>::value)
		{
			f(args...);
			temp ^= xor_key;
			*(uintptr_t*)ret_addr_in_stack = temp;
		}
		else
		{
			return_type&& ret = f(args...);
			temp ^= xor_key;
			*(uintptr_t*)ret_addr_in_stack = temp;
			return ret;
		}
	}



#ifdef _KERNEL_MODE
	template<typename RetType, class Func>
#else
	template<class Func >
#endif
	class SafeCall
	{

		Func* funcPtr;

	public:
		SafeCall(Func* func) :funcPtr(func) {}


		template<typename... Args>
		__forceinline decltype(auto) operator()(Args&&... args)
		{
			SPOOF_FUNC;

#ifdef _KERNEL_MODE
			using return_type = RetType;
			using p_shell_code_generator_type = decltype(&ShellCodeGenerator<RetType, Func*, Args...>);
			PVOID self_addr = static_cast<PVOID>(&ShellCodeGenerator<RetType, Func*, Args&&...>);
#else	
			using return_type = typename std::invoke_result<Func, Args...>::type;
			using p_shell_code_generator_type = decltype(&ShellCodeGenerator<Func*, Args...>);
			p_shell_code_generator_type self_addr = static_cast<p_shell_code_generator_type>(&ShellCodeGenerator<Func*, Args&&...>);
#endif

			p_shell_code_generator_type p_shellcode{};

			static size_t count{};
			static p_shell_code_generator_type orig_generator[MAX_FUNC_BUFFERED]{};
			static p_shell_code_generator_type alloc_generator[MAX_FUNC_BUFFERED]{};

			unsigned index{};
			while (orig_generator[index])
			{
				if (orig_generator[index] == self_addr)
				{
#ifdef _KERNEL_MODE
					//DbgPrint("Found allocated generator");
#else
					//std::cout << "Found allocated generator" << std::endl;
#endif

					p_shellcode = alloc_generator[index];
					break;
				}
				index++;
			}

			if (!p_shellcode)
			{
#ifdef _KERNEL_MODE
				//DbgPrint("Alloc generator");
#else	
				//std::cout << "Alloc generator" << std::endl;
#endif

				p_shellcode = reinterpret_cast<p_shell_code_generator_type>( LocateShellCode(self_addr));
				orig_generator[count] = self_addr;
				alloc_generator[count] = p_shellcode;
				count++;
			}

			if (!p_shellcode)
			{
				//DbgPrint("!p_shellcode");
			}

			return p_shellcode(funcPtr, args...);
		}
	};
}



================================================
FILE: Utils/miniz.h
================================================
#ifndef MINIZ_EXPORT
#define MINIZ_EXPORT
#endif
/* miniz.c 3.0.0 - public domain deflate/inflate, zlib-subset, ZIP reading/writing/appending, PNG writing
   See "unlicense" statement at the end of this file.
   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013
   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951: http://www.ietf.org/rfc/rfc1951.txt

   Most API's defined in miniz.c are optional. For example, to disable the archive related functions just define
   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO (see the list below for more macros).

   * Low-level Deflate/Inflate implementation notes:

     Compression: Use the "tdefl" API's. The compressor supports raw, static, and dynamic blocks, lazy or
     greedy parsing, match length filtering, RLE-only, and Huffman-only streams. It performs and compresses
     approximately as well as zlib.

     Decompression: Use the "tinfl" API's. The entire decompressor is implemented as a single function
     coroutine: see tinfl_decompress(). It supports decompression into a 32KB (or larger power of 2) wrapping buffer, or into a memory
     block large enough to hold the entire file.

     The low-level tdefl/tinfl API's do not make any use of dynamic memory allocation.

   * zlib-style API notes:

     miniz.c implements a fairly large subset of zlib. There's enough functionality present for it to be a drop-in
     zlib replacement in many apps:
        The z_stream struct, optional memory allocation callbacks
        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound
        inflateInit/inflateInit2/inflate/inflateReset/inflateEnd
        compress, compress2, compressBound, uncompress
        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly routines.
        Supports raw deflate streams or standard zlib streams with adler-32 checking.

     Limitations:
      The callback API's are not implemented yet. No support for gzip headers or zlib static dictionaries.
      I've tried to closely emulate zlib's various flavors of stream flushing and return status codes, but
      there are no guarantees that miniz.c pulls this off perfectly.

   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function, originally written by
     Alex Evans. Supports 1-4 bytes/pixel images.

   * ZIP archive API notes:

     The ZIP archive API's where designed with simplicity and efficiency in mind, with just enough abstraction to
     get the job done with minimal fuss. There are simple API's to retrieve file information, read files from
     existing archives, create new archives, append new files to existing archives, or clone archive data from
     one archive to another. It supports archives located in memory or the heap, on disk (using stdio.h),
     or you can specify custom file read/write callbacks.

     - Archive reading: Just call this function to read a single file from a disk archive:

      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name,
        size_t *pSize, mz_uint zip_flags);

     For more complex cases, use the "mz_zip_reader" functions. Upon opening an archive, the entire central
     directory is located and read as-is into memory, and subsequent file access only occurs when reading individual files.

     - Archives file scanning: The simple way is to use this function to scan a loaded archive for a specific file:

     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);

     The locate operation can optionally check file comments too, which (as one example) can be used to identify
     multiple versions of the same file in an archive. This function uses a simple linear search through the central
     directory, so it's not very fast.

     Alternately, you can iterate through all the files in an archive (using mz_zip_reader_get_num_files()) and
     retrieve detailed info on each file by calling mz_zip_reader_file_stat().

     - Archive creation: Use the "mz_zip_writer" functions. The ZIP writer immediately writes compressed file data
     to disk and builds an exact image of the central directory in memory. The central directory image is written
     all at once at the end of the archive file when the archive is finalized.

     The archive writer can optionally align each file's local header and file data to any power of 2 alignment,
     which can be useful when the archive will be read from optical media. Also, the writer supports placing
     arbitrary data blobs at the very beginning of ZIP archives. Archives written using either feature are still
     readable by any ZIP tool.

     - Archive appending: The simple way to add a single file to an archive is to call this function:

      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name,
        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

     The archive will be created if it doesn't already exist, otherwise it'll be appended to.
     Note the appending is done in-place and is not an atomic operation, so if something goes wrong
     during the operation it's possible the archive could be left without a central directory (although the local
     file headers and file data will be fine, so the archive will be recoverable).

     For more complex archive modification scenarios:
     1. The safest way is to use a mz_zip_reader to read the existing archive, cloning only those bits you want to
     preserve into a new archive using using the mz_zip_writer_add_from_zip_reader() function (which compiles the
     compressed file data as-is). When you're done, delete the old archive and rename the newly written archive, and
     you're done. This is safe but requires a bunch of temporary disk space or heap memory.

     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using mz_zip_writer_init_from_reader(),
     append new files as needed, then finalize the archive which will write an updated central directory to the
     original archive. (This is basically what mz_zip_add_mem_to_archive_file_in_place() does.) There's a
     possibility that the archive's central directory could be lost with this method if anything goes wrong, though.

     - ZIP archive support limitations:
     No spanning support. Extraction functions can only handle unencrypted, stored or deflated files.
     Requires streams capable of seeking.

   * This is a header file library, like stb_image.c. To get only a header file, either cut and paste the
     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then include miniz.c from it.

   * Important: For best perf. be sure to customize the below macros for your target platform:
     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
     #define MINIZ_LITTLE_ENDIAN 1
     #define MINIZ_HAS_64BIT_REGISTERS 1

   * On platforms using glibc, Be sure to "#define _LARGEFILE64_SOURCE 1" before including miniz.c to ensure miniz
     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be able to process large files
     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).
*/
#pragma once



/* Defines to completely disable specific portions of miniz.c: 
   If all macros here are defined the only functionality remaining will be CRC-32 and adler-32. */

/* Define MINIZ_NO_STDIO to disable all usage and any functions which rely on stdio for file I/O. */
/*#define MINIZ_NO_STDIO */

/* If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able to get the current time, or */
/* get/set file times, and the C run-time funcs that get/set times won't be called. */
/* The current downside is the times written to your archives will be from 1979. */
/*#define MINIZ_NO_TIME */

/* Define MINIZ_NO_DEFLATE_APIS to disable all compression API's. */
/*#define MINIZ_NO_DEFLATE_APIS */

/* Define MINIZ_NO_INFLATE_APIS to disable all decompression API's. */
/*#define MINIZ_NO_INFLATE_APIS */

/* Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's. */
/*#define MINIZ_NO_ARCHIVE_APIS */

/* Define MINIZ_NO_ARCHIVE_WRITING_APIS to disable all writing related ZIP archive API's. */
/*#define MINIZ_NO_ARCHIVE_WRITING_APIS */

/* Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression API's. */
/*#define MINIZ_NO_ZLIB_APIS */

/* Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent conflicts against stock zlib. */
/*#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES */

/* Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc. 
   Note if MINIZ_NO_MALLOC is defined then the user must always provide custom user alloc/free/realloc
   callbacks to the zlib and archive API's, and a few stand-alone helper API's which don't provide custom user
   functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won't work. */
/*#define MINIZ_NO_MALLOC */

#ifdef MINIZ_NO_INFLATE_APIS
#define MINIZ_NO_ARCHIVE_APIS
#endif

#ifdef MINIZ_NO_DEFLATE_APIS
#define MINIZ_NO_ARCHIVE_WRITING_APIS
#endif

#if defined(__TINYC__) && (defined(__linux) || defined(__linux__))
/* TODO: Work around "error: include file 'sys\utime.h' when compiling with tcc on Linux */
#define MINIZ_NO_TIME
#endif

#include <stddef.h>

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)
#include <time.h>
#endif

#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) || defined(__ia64__) || defined(__x86_64__)
/* MINIZ_X86_OR_X64_CPU is only used to help set the below macros. */
#define MINIZ_X86_OR_X64_CPU 1
#else
#define MINIZ_X86_OR_X64_CPU 0
#endif

/* Set MINIZ_LITTLE_ENDIAN only if not set */
#if !defined(MINIZ_LITTLE_ENDIAN)
#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__)

#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
/* Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian. */
#define MINIZ_LITTLE_ENDIAN 1
#else
#define MINIZ_LITTLE_ENDIAN 0
#endif

#else

#if MINIZ_X86_OR_X64_CPU
#define MINIZ_LITTLE_ENDIAN 1
#else
#define MINIZ_LITTLE_ENDIAN 0
#endif

#endif
#endif

/* Using unaligned loads and stores causes errors when using UBSan */
#if defined(__has_feature)
#if __has_feature(undefined_behavior_sanitizer)
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#endif
#endif

/* Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES only if not set */
#if !defined(MINIZ_USE_UNALIGNED_LOADS_AND_STORES)
#if MINIZ_X86_OR_X64_CPU
/* Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient integer loads and stores from unaligned addresses. */
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#define MINIZ_UNALIGNED_USE_MEMCPY
#else
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#endif
#endif

#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__) || defined(__ia64__) || defined(__x86_64__)
/* Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are reasonably fast (and don't involve compiler generated calls to helper functions). */
#define MINIZ_HAS_64BIT_REGISTERS 1
#else
#define MINIZ_HAS_64BIT_REGISTERS 0
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- zlib-style API Definitions. */

/* For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits! */
typedef unsigned long mz_ulong;

/* mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you've modified the MZ_MALLOC macro) to release a block allocated from the heap. */
MINIZ_EXPORT void mz_free(void *p);

#define MZ_ADLER32_INIT (1)
/* mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL. */
MINIZ_EXPORT mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);

#define MZ_CRC32_INIT (0)
/* mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL. */
MINIZ_EXPORT mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);

/* Compression strategies. */
enum
{
    MZ_DEFAULT_STRATEGY = 0,
    MZ_FILTERED = 1,
    MZ_HUFFMAN_ONLY = 2,
    MZ_RLE = 3,
    MZ_FIXED = 4
};

/* Method */
#define MZ_DEFLATED 8

/* Heap allocation callbacks.
Note that mz_alloc_func parameter types purposely differ from zlib's: items/size is size_t, not unsigned long. */
typedef void *(*mz_alloc_func)(void *opaque, size_t items, size_t size);
typedef void (*mz_free_func)(void *opaque, void *address);
typedef void *(*mz_realloc_func)(void *opaque, void *address, size_t items, size_t size);

/* Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL. */
enum
{
    MZ_NO_COMPRESSION = 0,
    MZ_BEST_SPEED = 1,
    MZ_BEST_COMPRESSION = 9,
    MZ_UBER_COMPRESSION = 10,
    MZ_DEFAULT_LEVEL = 6,
    MZ_DEFAULT_COMPRESSION = -1
};

#define MZ_VERSION "11.0.2"
#define MZ_VERNUM 0xB002
#define MZ_VER_MAJOR 11
#define MZ_VER_MINOR 2
#define MZ_VER_REVISION 0
#define MZ_VER_SUBREVISION 0

#ifndef MINIZ_NO_ZLIB_APIS

/* Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer to the zlib docs). */
enum
{
    MZ_NO_FLUSH = 0,
    MZ_PARTIAL_FLUSH = 1,
    MZ_SYNC_FLUSH = 2,
    MZ_FULL_FLUSH = 3,
    MZ_FINISH = 4,
    MZ_BLOCK = 5
};

/* Return status codes. MZ_PARAM_ERROR is non-standard. */
enum
{
    MZ_OK = 0,
    MZ_STREAM_END = 1,
    MZ_NEED_DICT = 2,
    MZ_ERRNO = -1,
    MZ_STREAM_ERROR = -2,
    MZ_DATA_ERROR = -3,
    MZ_MEM_ERROR = -4,
    MZ_BUF_ERROR = -5,
    MZ_VERSION_ERROR = -6,
    MZ_PARAM_ERROR = -10000
};

/* Window bits */
#define MZ_DEFAULT_WINDOW_BITS 15

struct mz_internal_state;

/* Compression/decompression stream struct. */
typedef struct mz_stream_s
{
    const unsigned char *next_in; /* pointer to next byte to read */
    unsigned int avail_in;        /* number of bytes available at next_in */
    mz_ulong total_in;            /* total number of bytes consumed so far */

    unsigned char *next_out; /* pointer to next byte to write */
    unsigned int avail_out;  /* number of bytes that can be written to next_out */
    mz_ulong total_out;      /* total number of bytes produced so far */

    char *msg;                       /* error msg (unused) */
    struct mz_internal_state *state; /* internal state, allocated by zalloc/zfree */

    mz_alloc_func zalloc; /* optional heap allocation function (defaults to malloc) */
    mz_free_func zfree;   /* optional heap free function (defaults to free) */
    void *opaque;         /* heap alloc function user pointer */

    int data_type;     /* data_type (unused) */
    mz_ulong adler;    /* adler32 of the source or uncompressed data */
    mz_ulong reserved; /* not used */
} mz_stream;

typedef mz_stream *mz_streamp;

/* Returns the version string of miniz.c. */
MINIZ_EXPORT const char *mz_version(void);

#ifndef MINIZ_NO_DEFLATE_APIS

/* mz_deflateInit() initializes a compressor with default options: */
/* Parameters: */
/*  pStream must point to an initialized mz_stream struct. */
/*  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION]. */
/*  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio. */
/*  (This special func. is currently only enabled when MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.) */
/* Return values: */
/*  MZ_OK on success. */
/*  MZ_STREAM_ERROR if the stream is bogus. */
/*  MZ_PARAM_ERROR if the input parameters are bogus. */
/*  MZ_MEM_ERROR on out of memory. */
MINIZ_EXPORT int mz_deflateInit(mz_streamp pStream, int level);

/* mz_deflateInit2() is like mz_deflate(), except with more control: */
/* Additional parameters: */
/*   method must be MZ_DEFLATED */
/*   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no header or footer) */
/*   mem_level must be between [1, 9] (it's checked but ignored by miniz.c) */
MINIZ_EXPORT int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);

/* Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2(). */
MINIZ_EXPORT int mz_deflateReset(mz_streamp pStream);

/* mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible. */
/* Parameters: */
/*   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. */
/*   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or MZ_FINISH. */
/* Return values: */
/*   MZ_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full). */
/*   MZ_STREAM_END if all input has been consumed and all output bytes have been written. Don't call mz_deflate() on the stream anymore. */
/*   MZ_STREAM_ERROR if the stream is bogus. */
/*   MZ_PARAM_ERROR if one of the parameters is invalid. */
/*   MZ_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.) */
MINIZ_EXPORT int mz_deflate(mz_streamp pStream, int flush);

/* mz_deflateEnd() deinitializes a compressor: */
/* Return values: */
/*  MZ_OK on success. */
/*  MZ_STREAM_ERROR if the stream is bogus. */
MINIZ_EXPORT int mz_deflateEnd(mz_streamp pStream);

/* mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH. */
MINIZ_EXPORT mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);

/* Single-call compression functions mz_compress() and mz_compress2(): */
/* Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure. */
MINIZ_EXPORT int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
MINIZ_EXPORT int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level);

/* mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress(). */
MINIZ_EXPORT mz_ulong mz_compressBound(mz_ulong source_len);

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS

/* Initializes a decompressor. */
MINIZ_EXPORT int mz_inflateInit(mz_streamp pStream);

/* mz_inflateInit2() is like mz_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer: */
/* window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate). */
MINIZ_EXPORT int mz_inflateInit2(mz_streamp pStream, int window_bits);

/* Quickly resets a compressor without having to reallocate anything. Same as calling mz_inflateEnd() followed by mz_inflateInit()/mz_inflateInit2(). */
MINIZ_EXPORT int mz_inflateReset(mz_streamp pStream);

/* Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible. */
/* Parameters: */
/*   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. */
/*   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH. */
/*   On the first call, if flush is MZ_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster). */
/*   MZ_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data. */
/* Return values: */
/*   MZ_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full. */
/*   MZ_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified. */
/*   MZ_STREAM_ERROR if the stream is bogus. */
/*   MZ_DATA_ERROR if the deflate stream is invalid. */
/*   MZ_PARAM_ERROR if one of the parameters is invalid. */
/*   MZ_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call mz_inflate() again */
/*   with more input data, or with more room in the output buffer (except when using single call decompression, described above). */
MINIZ_EXPORT int mz_inflate(mz_streamp pStream, int flush);

/* Deinitializes a decompressor. */
MINIZ_EXPORT int mz_inflateEnd(mz_streamp pStream);

/* Single-call decompression. */
/* Returns MZ_OK on success, or one of the error codes from mz_inflate() on failure. */
MINIZ_EXPORT int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
MINIZ_EXPORT int mz_uncompress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong *pSource_len);
#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

/* Returns a string description of the specified error code, or NULL if the error code is invalid. */
MINIZ_EXPORT const char *mz_error(int err);

/* Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used as a drop-in replacement for the subset of zlib that miniz.c supports. */
/* Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project. */
#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
typedef unsigned char Byte;
typedef unsigned int uInt;
typedef mz_ulong uLong;
typedef Byte Bytef;
typedef uInt uIntf;
typedef char charf;
typedef int intf;
typedef void *voidpf;
typedef uLong uLongf;
typedef void *voidp;
typedef void *const voidpc;
#define Z_NULL 0
#define Z_NO_FLUSH MZ_NO_FLUSH
#define Z_PARTIAL_FLUSH MZ_PARTIAL_FLUSH
#define Z_SYNC_FLUSH MZ_SYNC_FLUSH
#define Z_FULL_FLUSH MZ_FULL_FLUSH
#define Z_FINISH MZ_FINISH
#define Z_BLOCK MZ_BLOCK
#define Z_OK MZ_OK
#define Z_STREAM_END MZ_STREAM_END
#define Z_NEED_DICT MZ_NEED_DICT
#define Z_ERRNO MZ_ERRNO
#define Z_STREAM_ERROR MZ_STREAM_ERROR
#define Z_DATA_ERROR MZ_DATA_ERROR
#define Z_MEM_ERROR MZ_MEM_ERROR
#define Z_BUF_ERROR MZ_BUF_ERROR
#define Z_VERSION_ERROR MZ_VERSION_ERROR
#define Z_PARAM_ERROR MZ_PARAM_ERROR
#define Z_NO_COMPRESSION MZ_NO_COMPRESSION
#define Z_BEST_SPEED MZ_BEST_SPEED
#define Z_BEST_COMPRESSION MZ_BEST_COMPRESSION
#define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION
#define Z_DEFAULT_STRATEGY MZ_DEFAULT_STRATEGY
#define Z_FILTERED MZ_FILTERED
#define Z_HUFFMAN_ONLY MZ_HUFFMAN_ONLY
#define Z_RLE MZ_RLE
#define Z_FIXED MZ_FIXED
#define Z_DEFLATED MZ_DEFLATED
#define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS
#define alloc_func mz_alloc_func
#define free_func mz_free_func
#define internal_state mz_internal_state
#define z_stream mz_stream

#ifndef MINIZ_NO_DEFLATE_APIS
#define deflateInit mz_deflateInit
#define deflateInit2 mz_deflateInit2
#define deflateReset mz_deflateReset
#define deflate mz_deflate
#define deflateEnd mz_deflateEnd
#define deflateBound mz_deflateBound
#define compress mz_compress
#define compress2 mz_compress2
#define compressBound mz_compressBound
#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS
#define inflateInit mz_inflateInit
#define inflateInit2 mz_inflateInit2
#define inflateReset mz_inflateReset
#define inflate mz_inflate
#define inflateEnd mz_inflateEnd
#define uncompress mz_uncompress
#define uncompress2 mz_uncompress2
#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

#define crc32 mz_crc32
#define adler32 mz_adler32
#define MAX_WBITS 15
#define MAX_MEM_LEVEL 9
#define zError mz_error
#define ZLIB_VERSION MZ_VERSION
#define ZLIB_VERNUM MZ_VERNUM
#define ZLIB_VER_MAJOR MZ_VER_MAJOR
#define ZLIB_VER_MINOR MZ_VER_MINOR
#define ZLIB_VER_REVISION MZ_VER_REVISION
#define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION
#define zlibVersion mz_version
#define zlib_version mz_version()
#endif /* #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES */

#endif /* MINIZ_NO_ZLIB_APIS */

#ifdef __cplusplus
}
#endif





#pragma once
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>



/* ------------------- Types and macros */
typedef unsigned char mz_uint8;
typedef signed short mz_int16;
typedef unsigned short mz_uint16;
typedef unsigned int mz_uint32;
typedef unsigned int mz_uint;
typedef int64_t mz_int64;
typedef uint64_t mz_uint64;
typedef int mz_bool;

#define MZ_FALSE (0)
#define MZ_TRUE (1)

/* Works around MSVC's spammy "warning C4127: conditional expression is constant" message. */
#ifdef _MSC_VER
#define MZ_MACRO_END while (0, 0)
#else
#define MZ_MACRO_END while (0)
#endif

#ifdef MINIZ_NO_STDIO
#define MZ_FILE void *
#else
#include <stdio.h>
#define MZ_FILE FILE
#endif /* #ifdef MINIZ_NO_STDIO */

#ifdef MINIZ_NO_TIME
typedef struct mz_dummy_time_t_tag
{
    mz_uint32 m_dummy1;
    mz_uint32 m_dummy2;
} mz_dummy_time_t;
#define MZ_TIME_T mz_dummy_time_t
#else
#define MZ_TIME_T time_t
#endif

#define MZ_ASSERT(x) assert(x)

#ifdef MINIZ_NO_MALLOC
#define MZ_MALLOC(x) NULL
#define MZ_FREE(x) (void)x, ((void)0)
#define MZ_REALLOC(p, x) NULL
#else
#define MZ_MALLOC(x) malloc(x)
#define MZ_FREE(x) free(x)
#define MZ_REALLOC(p, x) realloc(p, x)
#endif

#define MZ_MAX(a, b) (((a) > (b)) ? (a) : (b))
#define MZ_MIN(a, b) (((a) < (b)) ? (a) : (b))
#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))
#define MZ_CLEAR_ARR(obj) memset((obj), 0, sizeof(obj))
#define MZ_CLEAR_PTR(obj) memset((obj), 0, sizeof(*obj))

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
#define MZ_READ_LE16(p) *((const mz_uint16 *)(p))
#define MZ_READ_LE32(p) *((const mz_uint32 *)(p))
#else
#define MZ_READ_LE16(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))
#define MZ_READ_LE32(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) | ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) | ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))
#endif

#define MZ_READ_LE64(p) (((mz_uint64)MZ_READ_LE32(p)) | (((mz_uint64)MZ_READ_LE32((const mz_uint8 *)(p) + sizeof(mz_uint32))) << 32U))

#ifdef _MSC_VER
#define MZ_FORCEINLINE __forceinline
#elif defined(__GNUC__)
#define MZ_FORCEINLINE __inline__ __attribute__((__always_inline__))
#else
#define MZ_FORCEINLINE inline
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern MINIZ_EXPORT void *miniz_def_alloc_func(void *opaque, size_t items, size_t size);
extern MINIZ_EXPORT void miniz_def_free_func(void *opaque, void *address);
extern MINIZ_EXPORT void *miniz_def_realloc_func(void *opaque, void *address, size_t items, size_t size);

#define MZ_UINT16_MAX (0xFFFFU)
#define MZ_UINT32_MAX (0xFFFFFFFFU)

#ifdef __cplusplus
}
#endif
 #pragma once


#ifndef MINIZ_NO_DEFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif
/* ------------------- Low-level Compression API Definitions */

/* Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly slower, and raw/dynamic blocks will be output more frequently). */
#define TDEFL_LESS_MEMORY 0

/* tdefl_init() compression flags logically OR'd together (low 12 bits contain the max. number of probes per dictionary search): */
/* TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression). */
enum
{
    TDEFL_HUFFMAN_ONLY = 0,
    TDEFL_DEFAULT_MAX_PROBES = 128,
    TDEFL_MAX_PROBES_MASK = 0xFFF
};

/* TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you'll get raw deflate data. */
/* TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers). */
/* TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing. */
/* TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory). */
/* TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1) */
/* TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled. */
/* TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables. */
/* TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks. */
/* The low 12 bits are reserved to control the max # of hash probes per dictionary lookup (see TDEFL_MAX_PROBES_MASK). */
enum
{
    TDEFL_WRITE_ZLIB_HEADER = 0x01000,
    TDEFL_COMPUTE_ADLER32 = 0x02000,
    TDEFL_GREEDY_PARSING_FLAG = 0x04000,
    TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
    TDEFL_RLE_MATCHES = 0x10000,
    TDEFL_FILTER_MATCHES = 0x20000,
    TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,
    TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000
};

/* High level compression functions: */
/* tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc(). */
/* On entry: */
/*  pSrc_buf, src_buf_len: Pointer and size of source block to compress. */
/*  flags: The max match finder probes (default is 128) logically OR'd against the above flags. Higher probes are slower but improve compression. */
/* On return: */
/*  Function returns a pointer to the compressed data, or NULL on failure. */
/*  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data. */
/*  The caller must free() the returned block when it's no longer needed. */
MINIZ_EXPORT void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

/* tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory. */
/* Returns 0 on failure. */
MINIZ_EXPORT size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

/* Compresses an image to a compressed PNG file in memory. */
/* On entry: */
/*  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4. */
/*  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory. */
/*  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL */
/*  If flip is true, the image will be flipped on the Y axis (useful for OpenGL apps). */
/* On return: */
/*  Function returns a pointer to the compressed data, or NULL on failure. */
/*  *pLen_out will be set to the size of the PNG image file. */
/*  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it's no longer needed. */
MINIZ_EXPORT void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip);
MINIZ_EXPORT void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out);

/* Output stream interface. The compressor uses this interface to write compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time. */
typedef mz_bool (*tdefl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);

/* tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally. */
MINIZ_EXPORT mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

enum
{
    TDEFL_MAX_HUFF_TABLES = 3,
    TDEFL_MAX_HUFF_SYMBOLS_0 = 288,
    TDEFL_MAX_HUFF_SYMBOLS_1 = 32,
    TDEFL_MAX_HUFF_SYMBOLS_2 = 19,
    TDEFL_LZ_DICT_SIZE = 32768,
    TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,
    TDEFL_MIN_MATCH_LEN = 3,
    TDEFL_MAX_MATCH_LEN = 258
};

/* TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes). */
#if TDEFL_LESS_MEMORY
enum
{
    TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024,
    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
    TDEFL_MAX_HUFF_SYMBOLS = 288,
    TDEFL_LZ_HASH_BITS = 12,
    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
#else
enum
{
    TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,
    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
    TDEFL_MAX_HUFF_SYMBOLS = 288,
    TDEFL_LZ_HASH_BITS = 15,
    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
#endif

/* The low-level tdefl functions below may be used directly if the above helper functions aren't flexible enough. The low-level functions don't make any heap allocations, unlike the above helper functions. */
typedef enum {
    TDEFL_STATUS_BAD_PARAM = -2,
    TDEFL_STATUS_PUT_BUF_FAILED = -1,
    TDEFL_STATUS_OKAY = 0,
    TDEFL_STATUS_DONE = 1
} tdefl_status;

/* Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums */
typedef enum {
    TDEFL_NO_FLUSH = 0,
    TDEFL_SYNC_FLUSH = 2,
    TDEFL_FULL_FLUSH = 3,
    TDEFL_FINISH = 4
} tdefl_flush;

/* tdefl's compression state structure. */
typedef struct
{
    tdefl_put_buf_func_ptr m_pPut_buf_func;
    void *m_pPut_buf_user;
    mz_uint m_flags, m_max_probes[2];
    int m_greedy_parsing;
    mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;
    mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;
    mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;
    mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index, m_wants_to_finish;
    tdefl_status m_prev_return_status;
    const void *m_pIn_buf;
    void *m_pOut_buf;
    size_t *m_pIn_buf_size, *m_pOut_buf_size;
    tdefl_flush m_flush;
    const mz_uint8 *m_pSrc;
    size_t m_src_buf_left, m_out_buf_ofs;
    mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];
    mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
    mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
    mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
    mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];
    mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];
    mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];
    mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];
} tdefl_compressor;

/* Initializes the compressor. */
/* There is no corresponding deinit() function because the tdefl API's do not dynamically allocate memory. */
/* pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression. */
/* If pBut_buf_func is NULL the user should always call the tdefl_compress() API. */
/* flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.) */
MINIZ_EXPORT tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

/* Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible. */
MINIZ_EXPORT tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);

/* tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr. */
/* tdefl_compress_buffer() always consumes the entire input buffer. */
MINIZ_EXPORT tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush);

MINIZ_EXPORT tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);
MINIZ_EXPORT mz_uint32 tdefl_get_adler32(tdefl_compressor *d);

/* Create tdefl_compress() flags given zlib-style compression parameters. */
/* level may range from [0,10] (where 10 is absolute max compression, but may be much slower on some files) */
/* window_bits may be -15 (raw deflate) or 15 (zlib) */
/* strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY, MZ_RLE, or MZ_FIXED */
MINIZ_EXPORT mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy);

#ifndef MINIZ_NO_MALLOC
/* Allocate the tdefl_compressor structure in C so that */
/* non-C language bindings to tdefl_ API don't need to worry about */
/* structure size and allocation mechanism. */
MINIZ_EXPORT tdefl_compressor *tdefl_compressor_alloc(void);
MINIZ_EXPORT void tdefl_compressor_free(tdefl_compressor *pComp);
#endif

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/
 #pragma once

/* ------------------- Low-level Decompression API Definitions */

#ifndef MINIZ_NO_INFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif
/* Decompression flags used by tinfl_decompress(). */
/* TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the input is a raw deflate stream. */
/* TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input. */
/* TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB). */
/* TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes. */
enum
{
    TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
    TINFL_FLAG_HAS_MORE_INPUT = 2,
    TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
    TINFL_FLAG_COMPUTE_ADLER32 = 8
};

/* High level decompression functions: */
/* tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc(). */
/* On entry: */
/*  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress. */
/* On return: */
/*  Function returns a pointer to the decompressed data, or NULL on failure. */
/*  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data. */
/*  The caller must call mz_free() on the returned block when it's no longer needed. */
MINIZ_EXPORT void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

/* tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory. */
/* Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success. */
#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))
MINIZ_EXPORT size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

/* tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer. */
/* Returns 1 on success or 0 on failure. */
typedef int (*tinfl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);
MINIZ_EXPORT int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

struct tinfl_decompressor_tag;
typedef struct tinfl_decompressor_tag tinfl_decompressor;

#ifndef MINIZ_NO_MALLOC
/* Allocate the tinfl_decompressor structure in C so that */
/* non-C language bindings to tinfl_ API don't need to worry about */
/* structure size and allocation mechanism. */
MINIZ_EXPORT tinfl_decompressor *tinfl_decompressor_alloc(void);
MINIZ_EXPORT void tinfl_decompressor_free(tinfl_decompressor *pDecomp);
#endif

/* Max size of LZ dictionary. */
#define TINFL_LZ_DICT_SIZE 32768

/* Return status. */
typedef enum {
    /* This flags indicates the inflator needs 1 or more input bytes to make forward progress, but the caller is indicating that no more are available. The compressed data */
    /* is probably corrupted. If you call the inflator again with more bytes it'll try to continue processing the input but this is a BAD sign (either the data is corrupted or you called it incorrectly). */
    /* If you call it again with no input you'll just get TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS again. */
    TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS = -4,

    /* This flag indicates that one or more of the input parameters was obviously bogus. (You can try calling it again, but if you get this error the calling code is wrong.) */
    TINFL_STATUS_BAD_PARAM = -3,

    /* This flags indicate the inflator is finished but the adler32 check of the uncompressed data didn't match. If you call it again it'll return TINFL_STATUS_DONE. */
    TINFL_STATUS_ADLER32_MISMATCH = -2,

    /* This flags indicate the inflator has somehow failed (bad code, corrupted input, etc.). If you call it again without resetting via tinfl_init() it it'll just keep on returning the same status failure code. */
    TINFL_STATUS_FAILED = -1,

    /* Any status code less than TINFL_STATUS_DONE must indicate a failure. */

    /* This flag indicates the inflator has returned every byte of uncompressed data that it can, has consumed every byte that it needed, has successfully reached the end of the deflate stream, and */
    /* if zlib headers and adler32 checking enabled that it has successfully checked the uncompressed data's adler32. If you call it again you'll just get TINFL_STATUS_DONE over and over again. */
    TINFL_STATUS_DONE = 0,

    /* This flag indicates the inflator MUST have more input data (even 1 byte) before it can make any more forward progress, or you need to clear the TINFL_FLAG_HAS_MORE_INPUT */
    /* flag on the next call if you don't have any more source data. If the source data was somehow corrupted it's also possible (but unlikely) for the inflator to keep on demanding input to */
    /* proceed, so be sure to properly set the TINFL_FLAG_HAS_MORE_INPUT flag. */
    TINFL_STATUS_NEEDS_MORE_INPUT = 1,

    /* This flag indicates the inflator definitely has 1 or more bytes of uncompressed data available, but it cannot write this data into the output buffer. */
    /* Note if the source compressed data was corrupted it's possible for the inflator to return a lot of uncompressed data to the caller. I've been assuming you know how much uncompressed data to expect */
    /* (either exact or worst case) and will stop calling the inflator and fail after receiving too much. In pure streaming scenarios where you have no idea how many bytes to expect this may not be possible */
    /* so I may need to add some code to address this. */
    TINFL_STATUS_HAS_MORE_OUTPUT = 2
} tinfl_status;

/* Initializes the decompressor to its initial state. */
#define tinfl_init(r)     \
    do                    \
    {                     \
        (r)->m_state = 0; \
    }                     \
    MZ_MACRO_END
#define tinfl_get_adler32(r) (r)->m_check_adler32

/* Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability. */
/* This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output. */
MINIZ_EXPORT tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags);

/* Internal/private bits follow. */
enum
{
    TINFL_MAX_HUFF_TABLES = 3,
    TINFL_MAX_HUFF_SYMBOLS_0 = 288,
    TINFL_MAX_HUFF_SYMBOLS_1 = 32,
    TINFL_MAX_HUFF_SYMBOLS_2 = 19,
    TINFL_FAST_LOOKUP_BITS = 10,
    TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
};

#if MINIZ_HAS_64BIT_REGISTERS
#define TINFL_USE_64BIT_BITBUF 1
#else
#define TINFL_USE_64BIT_BITBUF 0
#endif

#if TINFL_USE_64BIT_BITBUF
typedef mz_uint64 tinfl_bit_buf_t;
#define TINFL_BITBUF_SIZE (64)
#else
typedef mz_uint32 tinfl_bit_buf_t;
#define TINFL_BITBUF_SIZE (32)
#endif

struct tinfl_decompressor_tag
{
    mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];
    tinfl_bit_buf_t m_bit_buf;
    size_t m_dist_from_out_buf_start;
    mz_int16 m_look_up[TINFL_MAX_HUFF_TABLES][TINFL_FAST_LOOKUP_SIZE];
    mz_int16 m_tree_0[TINFL_MAX_HUFF_SYMBOLS_0 * 2];
    mz_int16 m_tree_1[TINFL_MAX_HUFF_SYMBOLS_1 * 2];
    mz_int16 m_tree_2[TINFL_MAX_HUFF_SYMBOLS_2 * 2];
    mz_uint8 m_code_size_0[TINFL_MAX_HUFF_SYMBOLS_0];
    mz_uint8 m_code_size_1[TINFL_MAX_HUFF_SYMBOLS_1];
    mz_uint8 m_code_size_2[TINFL_MAX_HUFF_SYMBOLS_2];
    mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];
};

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/
 
#pragma once


/* ------------------- ZIP archive reading/writing */

#ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef __cplusplus
extern "C" {
#endif

enum
{
    /* Note: These enums can be reduced as needed to save memory or stack space - they are pretty conservative. */
    MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,
    MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 512,
    MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 512
};

typedef struct
{
    /* Central directory file index. */
    mz_uint32 m_file_index;

    /* Byte offset of this entry in the archive's central directory. Note we currently only support up to UINT_MAX or less bytes in the central dir. */
    mz_uint64 m_central_dir_ofs;

    /* These fields are copied directly from the zip's central dir. */
    mz_uint16 m_version_made_by;
    mz_uint16 m_version_needed;
    mz_uint16 m_bit_flag;
    mz_uint16 m_method;

    /* CRC-32 of uncompressed data. */
    mz_uint32 m_crc32;

    /* File's compressed size. */
    mz_uint64 m_comp_size;

    /* File's uncompressed size. Note, I've seen some old archives where directory entries had 512 bytes for their uncompressed sizes, but when you try to unpack them you actually get 0 bytes. */
    mz_uint64 m_uncomp_size;

    /* Zip internal and external file attributes. */
    mz_uint16 m_internal_attr;
    mz_uint32 m_external_attr;

    /* Entry's local header file offset in bytes. */
    mz_uint64 m_local_header_ofs;

    /* Size of comment in bytes. */
    mz_uint32 m_comment_size;

    /* MZ_TRUE if the entry appears to be a directory. */
    mz_bool m_is_directory;

    /* MZ_TRUE if the entry uses encryption/strong encryption (which miniz_zip doesn't support) */
    mz_bool m_is_encrypted;

    /* MZ_TRUE if the file is not encrypted, a patch file, and if it uses a compression method we support. */
    mz_bool m_is_supported;

    /* Filename. If string ends in '/' it's a subdirectory entry. */
    /* Guaranteed to be zero terminated, may be truncated to fit. */
    char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];

    /* Comment field. */
    /* Guaranteed to be zero terminated, may be truncated to fit. */
    char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];

#ifdef MINIZ_NO_TIME
    MZ_TIME_T m_padding;
#else
    MZ_TIME_T m_time;
#endif
} mz_zip_archive_file_stat;

typedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n);
typedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n);
typedef mz_bool (*mz_file_needs_keepalive)(void *pOpaque);

struct mz_zip_internal_state_tag;
typedef struct mz_zip_internal_state_tag mz_zip_internal_state;

typedef enum {
    MZ_ZIP_MODE_INVALID = 0,
    MZ_ZIP_MODE_READING = 1,
    MZ_ZIP_MODE_WRITING = 2,
    MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
} mz_zip_mode;

typedef enum {
    MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,
    MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,
    MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,
    MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800,
    MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG = 0x1000, /* if enabled, mz_zip_reader_locate_file() will be called on each file as its validated to ensure the func finds the file in the central dir (intended for testing) */
    MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY = 0x2000,     /* validate the local headers, but don't decompress the entire file and check the crc32 */
    MZ_ZIP_FLAG_WRITE_ZIP64 = 0x4000,               /* always use the zip64 file format, instead of the original zip file format with automatic switch to zip64. Use as flags parameter with mz_zip_writer_init*_v2 */
    MZ_ZIP_FLAG_WRITE_ALLOW_READING = 0x8000,
    MZ_ZIP_FLAG_ASCII_FILENAME = 0x10000,
    /*After adding a compressed file, seek back
    to local file header and set the correct sizes*/
    MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE = 0x20000
} mz_zip_flags;

typedef enum {
    MZ_ZIP_TYPE_INVALID = 0,
    MZ_ZIP_TYPE_USER,
    MZ_ZIP_TYPE_MEMORY,
    MZ_ZIP_TYPE_HEAP,
    MZ_ZIP_TYPE_FILE,
    MZ_ZIP_TYPE_CFILE,
    MZ_ZIP_TOTAL_TYPES
} mz_zip_type;

/* miniz error codes. Be sure to update mz_zip_get_error_string() if you add or modify this enum. */
typedef enum {
    MZ_ZIP_NO_ERROR = 0,
    MZ_ZIP_UNDEFINED_ERROR,
    MZ_ZIP_TOO_MANY_FILES,
    MZ_ZIP_FILE_TOO_LARGE,
    MZ_ZIP_UNSUPPORTED_METHOD,
    MZ_ZIP_UNSUPPORTED_ENCRYPTION,
    MZ_ZIP_UNSUPPORTED_FEATURE,
    MZ_ZIP_FAILED_FINDING_CENTRAL_DIR,
    MZ_ZIP_NOT_AN_ARCHIVE,
    MZ_ZIP_INVALID_HEADER_OR_CORRUPTED,
    MZ_ZIP_UNSUPPORTED_MULTIDISK,
    MZ_ZIP_DECOMPRESSION_FAILED,
    MZ_ZIP_COMPRESSION_FAILED,
    MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE,
    MZ_ZIP_CRC_CHECK_FAILED,
    MZ_ZIP_UNSUPPORTED_CDIR_SIZE,
    MZ_ZIP_ALLOC_FAILED,
    MZ_ZIP_FILE_OPEN_FAILED,
    MZ_ZIP_FILE_CREATE_FAILED,
    MZ_ZIP_FILE_WRITE_FAILED,
    MZ_ZIP_FILE_READ_FAILED,
    MZ_ZIP_FILE_CLOSE_FAILED,
    MZ_ZIP_FILE_SEEK_FAILED,
    MZ_ZIP_FILE_STAT_FAILED,
    MZ_ZIP_INVALID_PARAMETER,
    MZ_ZIP_INVALID_FILENAME,
    MZ_ZIP_BUF_TOO_SMALL,
    MZ_ZIP_INTERNAL_ERROR,
    MZ_ZIP_FILE_NOT_FOUND,
    MZ_ZIP_ARCHIVE_TOO_LARGE,
    MZ_ZIP_VALIDATION_FAILED,
    MZ_ZIP_WRITE_CALLBACK_FAILED,
    MZ_ZIP_TOTAL_ERRORS
} mz_zip_error;

typedef struct
{
    mz_uint64 m_archive_size;
    mz_uint64 m_central_directory_file_ofs;

    /* We only support up to UINT32_MAX files in zip64 mode. */
    mz_uint32 m_total_files;
    mz_zip_mode m_zip_mode;
    mz_zip_type m_zip_type;
    mz_zip_error m_last_error;

    mz_uint64 m_file_offset_alignment;

    mz_alloc_func m_pAlloc;
    mz_free_func m_pFree;
    mz_realloc_func m_pRealloc;
    void *m_pAlloc_opaque;

    mz_file_read_func m_pRead;
    mz_file_write_func m_pWrite;
    mz_file_needs_keepalive m_pNeeds_keepalive;
    void *m_pIO_opaque;

    mz_zip_internal_state *m_pState;

} mz_zip_archive;

typedef struct
{
    mz_zip_archive *pZip;
    mz_uint flags;

    int status;

    mz_uint64 read_buf_size, read_buf_ofs, read_buf_avail, comp_remaining, out_buf_ofs, cur_file_ofs;
    mz_zip_archive_file_stat file_stat;
    void *pRead_buf;
    void *pWrite_buf;

    size_t out_blk_remain;

    tinfl_decompressor inflator;

#ifdef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
    mz_uint padding;
#else
    mz_uint file_crc32;
#endif

} mz_zip_reader_extract_iter_state;

/* -------- ZIP reading */

/* Inits a ZIP archive reader. */
/* These functions read and validate the archive's central directory. */
MINIZ_EXPORT mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags);

MINIZ_EXPORT mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint flags);

#ifndef MINIZ_NO_STDIO
/* Read a archive from a disk file. */
/* file_start_ofs is the file offset where the archive actually begins, or 0. */
/* actual_archive_size is the true total size of the archive, which may be smaller than the file's actual size on disk. If zero the entire file is treated as the archive. */
MINIZ_EXPORT mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags);
MINIZ_EXPORT mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size);

/* Read an archive from an already opened FILE, beginning at the current file position. */
/* The archive is assumed to be archive_size bytes long. If archive_size is 0, then the entire rest of the file is assumed to contain the archive. */
/* The FILE will NOT be closed when mz_zip_reader_end() is called. */
MINIZ_EXPORT mz_bool mz_zip_reader_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags);
#endif

/* Ends archive reading, freeing all allocations, and closing the input archive file if mz_zip_reader_init_file() was used. */
MINIZ_EXPORT mz_bool mz_zip_reader_end(mz_zip_archive *pZip);

/* -------- ZIP reading or writing */

/* Clears a mz_zip_archive struct to all zeros. */
/* Important: This must be done before passing the struct to any mz_zip functions. */
MINIZ_EXPORT void mz_zip_zero_struct(mz_zip_archive *pZip);

MINIZ_EXPORT mz_zip_mode mz_zip_get_mode(mz_zip_archive *pZip);
MINIZ_EXPORT mz_zip_type mz_zip_get_type(mz_zip_archive *pZip);

/* Returns the total number of files in the archive. */
MINIZ_EXPORT mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);

MINIZ_EXPORT mz_uint64 mz_zip_get_archive_size(mz_zip_archive *pZip);
MINIZ_EXPORT mz_uint64 mz_zip_get_archive_file_start_offset(mz_zip_archive *pZip);
MINIZ_EXPORT MZ_FILE *mz_zip_get_cfile(mz_zip_archive *pZip);

/* Reads n bytes of raw archive data, starting at file offset file_ofs, to pBuf. */
MINIZ_EXPORT size_t mz_zip_read_archive_data(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n);

/* All mz_zip funcs set the m_last_error field in the mz_zip_archive struct. These functions retrieve/manipulate this field. */
/* Note that the m_last_error functionality is not thread safe. */
MINIZ_EXPORT mz_zip_error mz_zip_set_last_error(mz_zip_archive *pZip, mz_zip_error err_num);
MINIZ_EXPORT mz_zip_error mz_zip_peek_last_error(mz_zip_archive *pZip);
MINIZ_EXPORT mz_zip_error mz_zip_clear_last_error(mz_zip_archive *pZip);
MINIZ_EXPORT mz_zip_error mz_zip_get_last_error(mz_zip_archive *pZip);
MINIZ_EXPORT const char *mz_zip_get_error_string(mz_zip_error mz_err);

/* MZ_TRUE if the archive file entry is a directory entry. */
MINIZ_EXPORT mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index);

/* MZ_TRUE if the file is encrypted/strong encrypted. */
MINIZ_EXPORT mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index);

/* MZ_TRUE if the compression method is supported, and the file is not encrypted, and the file is not a compressed patch file. */
MINIZ_EXPORT mz_bool mz_zip_reader_is_file_supported(mz_zip_archive *pZip, mz_uint file_index);

/* Retrieves the filename of an archive file entry. */
/* Returns the number of bytes written to pFilename, or if filename_buf_size is 0 this function returns the number of bytes needed to fully store the filename. */
MINIZ_EXPORT mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size);

/* Attempts to locates a file in the archive's central directory. */
/* Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH */
/* Returns -1 if the file cannot be found. */
MINIZ_EXPORT int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *file_index);

/* Returns detailed information about an archive file entry. */
MINIZ_EXPORT mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat);

/* MZ_TRUE if the file is in zip64 format. */
/* A file is considered zip64 if it contained a zip64 end of central directory marker, or if it contained any zip64 extended file information fields in the central directory. */
MINIZ_EXPORT mz_bool mz_zip_is_zip64(mz_zip_archive *pZip);

/* Returns the total central directory size in bytes. */
/* The current max supported size is <= MZ_UINT32_MAX. */
MINIZ_EXPORT size_t mz_zip_get_central_dir_size(mz_zip_archive *pZip);

/* Extracts a archive file to a memory buffer using no memory allocation. */
/* There must be at least enough room on the stack to store the inflator's state (~34KB or so). */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);

/* Extracts a archive file to a memory buffer. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags);

/* Extracts a archive file to a dynamically allocated heap buffer. */
/* The memory will be allocated via the mz_zip_archive's alloc/realloc functions. */
/* Returns NULL and sets the last error on failure. */
MINIZ_EXPORT void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags);
MINIZ_EXPORT void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags);

/* Extracts a archive file using a callback function to output the file's data. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);

/* Extract a file iteratively */
MINIZ_EXPORT mz_zip_reader_extract_iter_state* mz_zip_reader_extract_iter_new(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);
MINIZ_EXPORT mz_zip_reader_extract_iter_state* mz_zip_reader_extract_file_iter_new(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);
MINIZ_EXPORT size_t mz_zip_reader_extract_iter_read(mz_zip_reader_extract_iter_state* pState, void* pvBuf, size_t buf_size);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_iter_free(mz_zip_reader_extract_iter_state* pState);

#ifndef MINIZ_NO_STDIO
/* Extracts a archive file to a disk file and sets its last accessed and modified times. */
/* This function only extracts files, not archive directory records. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags);

/* Extracts a archive file starting at the current position in the destination FILE stream. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_cfile(mz_zip_archive *pZip, mz_uint file_index, MZ_FILE *File, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pArchive_filename, MZ_FILE *pFile, mz_uint flags);
#endif

#if 0
/* TODO */
	typedef void *mz_zip_streaming_extract_state_ptr;
	mz_zip_streaming_extract_state_ptr mz_zip_streaming_extract_begin(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);
	mz_uint64 mz_zip_streaming_extract_get_size(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
	mz_uint64 mz_zip_streaming_extract_get_cur_ofs(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
	mz_bool mz_zip_streaming_extract_seek(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState, mz_uint64 new_ofs);
	size_t mz_zip_streaming_extract_read(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState, void *pBuf, size_t buf_size);
	mz_bool mz_zip_streaming_extract_end(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
#endif

/* This function compares the archive's local headers, the optional local zip64 extended information block, and the optional descriptor following the compressed data vs. the data in the central directory. */
/* It also validates that each file can be successfully uncompressed unless the MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY is specified. */
MINIZ_EXPORT mz_bool mz_zip_validate_file(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);

/* Validates an entire archive by calling mz_zip_validate_file() on each file. */
MINIZ_EXPORT mz_bool mz_zip_validate_archive(mz_zip_archive *pZip, mz_uint flags);

/* Misc utils/helpers, valid for ZIP reading or writing */
MINIZ_EXPORT mz_bool mz_zip_validate_mem_archive(const void *pMem, size_t size, mz_uint flags, mz_zip_error *pErr);
#ifndef MINIZ_NO_STDIO
MINIZ_EXPORT mz_bool mz_zip_validate_file_archive(const char *pFilename, mz_uint flags, mz_zip_error *pErr);
#endif

/* Universal end function - calls either mz_zip_reader_end() or mz_zip_writer_end(). */
MINIZ_EXPORT mz_bool mz_zip_end(mz_zip_archive *pZip);

/* -------- ZIP writing */

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

/* Inits a ZIP archive writer. */
/*Set pZip->m_pWrite (and pZip->m_pIO_opaque) before calling mz_zip_writer_init or mz_zip_writer_init_v2*/
/*The output is streamable, i.e. file_ofs in mz_file_write_func always increases only by n*/
MINIZ_EXPORT mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);
MINIZ_EXPORT mz_bool mz_zip_writer_init_v2(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags);

MINIZ_EXPORT mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size);
MINIZ_EXPORT mz_bool mz_zip_writer_init_heap_v2(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size, mz_uint flags);

#ifndef MINIZ_NO_STDIO
MINIZ_EXPORT mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning);
MINIZ_EXPORT mz_bool mz_zip_writer_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint flags);
#endif

/* Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive. */
/* For archives opened using mz_zip_reader_init_file, pFilename must be the archive's filename so it can be reopened for writing. If the file can't be reopened, mz_zip_reader_end() will be called. */
/* For archives opened using mz_zip_reader_init_mem, the memory block must be growable using the realloc callback (which defaults to realloc unless you've overridden it). */
/* Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's user provided m_pWrite function cannot be NULL. */
/* Note: In-place archive modification is not recommended unless you know what you're doing, because if execution stops or something goes wrong before */
/* the archive is finalized the file's central directory will be hosed. */
MINIZ_EXPORT mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename);
MINIZ_EXPORT mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);

/* Adds the contents of a memory buffer to an archive. These functions record the current local time into the archive. */
/* To add a directory entry, call this method with an archive name ending in a forwardslash with an empty buffer. */
/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags);

/* Like mz_zip_writer_add_mem(), except you can specify a file comment field, and optionally supply the function with already compressed data. */
/* uncomp_size/uncomp_crc32 are only used if the MZ_ZIP_FLAG_COMPRESSED_DATA flag is specified. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                              mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);

MINIZ_EXPORT mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                                 mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
                                                 const char *user_extra_data_central, mz_uint user_extra_data_central_len);

/* Adds the contents of a file to an archive. This function also records the disk file's modified time into the archive. */
/* File data is supplied via a read callback function. User mz_zip_writer_add_(c)file to add a file directly.*/
MINIZ_EXPORT mz_bool mz_zip_writer_add_read_buf_callback(mz_zip_archive *pZip, const char *pArchive_name, mz_file_read_func read_callback, void* callback_opaque, mz_uint64 max_size,
	const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
	const char *user_extra_data_central, mz_uint user_extra_data_central_len);


#ifndef MINIZ_NO_STDIO
/* Adds the contents of a disk file to an archive. This function also records the disk file's modified time into the archive. */
/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

/* Like mz_zip_writer_add_file(), except the file data is read from the specified FILE stream. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 max_size,
                                const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
                                const char *user_extra_data_central, mz_uint user_extra_data_central_len);
#endif

/* Adds a file to an archive by fully cloning the data from another archive. */
/* This function fully clones the source file's compressed data (no recompression), along with its full filename, extra data (it may add or modify the zip64 local header extra data field), and the optional descriptor following the compressed data. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint src_file_index);

/* Finalizes the archive by writing the central directory records followed by the end of central directory record. */
/* After an archive is finalized, the only valid call on the mz_zip_archive struct is mz_zip_writer_end(). */
/* An archive must be manually finalized by calling this function for it to be valid. */
MINIZ_EXPORT mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);

/* Finalizes a heap archive, returning a pointer to the heap block and its size. */
/* The heap block will be allocated using the mz_zip_archive's alloc/realloc callbacks. */
MINIZ_EXPORT mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **ppBuf, size_t *pSize);

/* Ends archive writing, freeing all allocations, and closing the output file if mz_zip_writer_init_file() was used. */
/* Note for the archive to be valid, it *must* have been finalized before ending (this function will not do it for you). */
MINIZ_EXPORT mz_bool mz_zip_writer_end(mz_zip_archive *pZip);

/* -------- Misc. high-level helper functions: */

/* mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically) appends a memory blob to a ZIP archive. */
/* Note this is NOT a fully safe operation. If it crashes or dies in some way your archive can be left in a screwed up state (without a central directory). */
/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
/* TODO: Perhaps add an option to leave the existing central dir in place in case the add dies? We could then truncate the file (so the old central dir would be at the end) if something goes wrong. */
MINIZ_EXPORT mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
MINIZ_EXPORT mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr);

#ifndef MINIZ_NO_STDIO
/* Reads a single file from an archive into a heap block. */
/* If pComment is not NULL, only the file with the specified comment will be extracted. */
/* Returns NULL on failure. */
MINIZ_EXPORT void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags);
MINIZ_EXPORT void *mz_zip_extract_archive_file_to_heap_v2(const char *pZip_filename, const char *pArchive_name, const char *pComment, size_t *pSize, mz_uint flags, mz_zip_error *pErr);
#endif

#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */

#ifdef __cplusplus
}
#endif

#endif /* MINIZ_NO_ARCHIVE_APIS */



================================================
FILE: Utils/mouse_input_injection.h
================================================
#pragma once
#include <Windows.h>

#include <iostream>
#include "CallStack-Spoofer.h"
struct InjectedInputMouseInfo {
  int move_direction_x;
  int move_direction_y;
  DWORD mouse_data;
  DWORD mouse_options;
  unsigned int time_offset;
  ULONG_PTR extra_info;
};

class MouseInterface {
 private:
  bool (*nt_user_inject_mouse_input_)(InjectedInputMouseInfo*, int) = nullptr;

 public:
  MouseInterface() {
    HMODULE win32u_module = LoadLibraryW(L"win32u.dll");
    if (!win32u_module) {
      std::cerr << "[-] Could not load win32u.dll\n";
      return;
    }
    nt_user_inject_mouse_input_ =
        reinterpret_cast<bool (*)(InjectedInputMouseInfo*, int)>(
            GetProcAddress(win32u_module, "NtUserInjectMouseInput"));
    if (!nt_user_inject_mouse_input_) {
      std::cerr << "[-] Could not locate NtUserInjectMouseInput\n";
    }
  }

  inline bool sendEvent(const InjectedInputMouseInfo& info) {
    if (nt_user_inject_mouse_input_) {
      SPOOF_FUNC;
      return SPOOF_CALL(nt_user_inject_mouse_input_)(
          const_cast<InjectedInputMouseInfo*>(&info), 1);
    }
    return false;
  }
};

inline void my_mouse_event(DWORD dw_flags, DWORD dx, DWORD dy, DWORD dw_data,
                           ULONG_PTR dw_extra_info) {
  static MouseInterface mouse_interface;

  InjectedInputMouseInfo event = {};
  event.move_direction_x = static_cast<int>(dx);
  event.move_direction_y = static_cast<int>(dy);
  event.mouse_data = dw_data;
  event.mouse_options = dw_flags;
  event.extra_info = dw_extra_info;

  mouse_interface.sendEvent(event);
}



================================================
FILE: Utils/uiaccess.c
================================================
﻿#include "uiaccess.h"

#ifdef __cplusplus
extern "C" {
#endif
static DWORD DuplicateWinloginToken(DWORD dwSessionId, DWORD dwDesiredAccess,
                                    PHANDLE phToken) {
  DWORD dwErr;
  PRIVILEGE_SET ps;

  ps.PrivilegeCount = 1;
  ps.Control = PRIVILEGE_SET_ALL_NECESSARY;

  if (LookupPrivilegeValue(NULL, SE_TCB_NAME, &ps.Privilege[0].Luid)) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE != hSnapshot) {
      BOOL bCont, bFound = FALSE;
      PROCESSENTRY32 pe;

      pe.dwSize = sizeof(pe);
      dwErr = ERROR_NOT_FOUND;

      for (bCont = Process32First(hSnapshot, &pe); bCont;
           bCont = Process32Next(hSnapshot, &pe)) {
        HANDLE hProcess;

        if (0 != _tcsicmp(pe.szExeFile, TEXT("winlogon.exe"))) {
          continue;
        }

        hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE,
                               pe.th32ProcessID);
        if (hProcess) {
          HANDLE hToken;
          DWORD dwRetLen, sid;

          if (OpenProcessToken(hProcess, TOKEN_QUERY | TOKEN_DUPLICATE,
                               &hToken)) {
            BOOL fTcb;

            if (PrivilegeCheck(hToken, &ps, &fTcb) && fTcb) {
              if (GetTokenInformation(hToken, TokenSessionId, &sid, sizeof(sid),
                                      &dwRetLen) &&
                  sid == dwSessionId) {
                bFound = TRUE;
                if (DuplicateTokenEx(hToken, dwDesiredAccess, NULL,
                                     SecurityImpersonation, TokenImpersonation,
                                     phToken)) {
                  dwErr = ERROR_SUCCESS;
                } else {
                  dwErr = GetLastError();
                }
              }
            }
            CloseHandle(hToken);
          }
          CloseHandle(hProcess);
        }

        if (bFound) break;
      }

      CloseHandle(hSnapshot);
    } else {
      dwErr = GetLastError();
    }
  } else {
    dwErr = GetLastError();
  }

  return dwErr;
}

static DWORD CreateUIAccessToken(PHANDLE phToken) {
  DWORD dwErr;
  HANDLE hTokenSelf;

  if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_DUPLICATE,
                       &hTokenSelf)) {
    DWORD dwSessionId, dwRetLen;

    if (GetTokenInformation(hTokenSelf, TokenSessionId, &dwSessionId,
                            sizeof(dwSessionId), &dwRetLen)) {
      HANDLE hTokenSystem;

      dwErr =
          DuplicateWinloginToken(dwSessionId, TOKEN_IMPERSONATE, &hTokenSystem);
      if (ERROR_SUCCESS == dwErr) {
        if (SetThreadToken(NULL, hTokenSystem)) {
          if (DuplicateTokenEx(hTokenSelf,
                               TOKEN_QUERY | TOKEN_DUPLICATE |
                                   TOKEN_ASSIGN_PRIMARY | TOKEN_ADJUST_DEFAULT,
                               NULL, SecurityAnonymous, TokenPrimary,
                               phToken)) {
            BOOL bUIAccess = TRUE;

            if (!SetTokenInformation(*phToken, TokenUIAccess, &bUIAccess,
                                     sizeof(bUIAccess))) {
              dwErr = GetLastError();
              CloseHandle(*phToken);
            }
          } else {
            dwErr = GetLastError();
          }
          RevertToSelf();
        } else {
          dwErr = GetLastError();
        }
        CloseHandle(hTokenSystem);
      }
    } else {
      dwErr = GetLastError();
    }

    CloseHandle(hTokenSelf);
  } else {
    dwErr = GetLastError();
  }

  return dwErr;
}

static BOOL CheckForUIAccess(DWORD *pdwErr, DWORD *pfUIAccess) {
  BOOL result = FALSE;
  HANDLE hToken;

  if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
    DWORD dwRetLen;

    if (GetTokenInformation(hToken, TokenUIAccess, pfUIAccess,
                            sizeof(*pfUIAccess), &dwRetLen)) {
      result = TRUE;
    } else {
      *pdwErr = GetLastError();
    }
    CloseHandle(hToken);
  } else {
    *pdwErr = GetLastError();
  }

  return result;
}

DWORD PrepareForUIAccess() {
  DWORD dwErr;
  HANDLE hTokenUIAccess;
  BOOL fUIAccess;

  if (CheckForUIAccess(&dwErr, (DWORD *)&fUIAccess)) {
    if (fUIAccess) {
      dwErr = ERROR_SUCCESS;
    } else {
      dwErr = CreateUIAccessToken(&hTokenUIAccess);
      if (ERROR_SUCCESS == dwErr) {
        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        GetStartupInfo(&si);
        if (CreateProcessAsUser(hTokenUIAccess, NULL, GetCommandLine(), NULL,
                                NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
          CloseHandle(pi.hProcess), CloseHandle(pi.hThread);
          ExitProcess(0);
        } else {
          dwErr = GetLastError();
        }

        CloseHandle(hTokenUIAccess);
      }
    }
  }

  return dwErr;
}
#ifdef __cplusplus
}
#endif


================================================
FILE: Utils/uiaccess.h
================================================
﻿#pragma once
#include <windows.h>
#ifdef __cplusplus
extern "C" {
#endif
#ifdef _DEBUG
#include <stdio.h>
#define dbgstart()               \
  do {                           \
    AllocConsole();              \
    freopen("CON", "r", stdin);  \
    freopen("CON", "w", stdout); \
    freopen("CON", "w", stderr); \
  } while (0)
#define dbgend() FreeConsole()
#define dbg(...) printf(__VA_ARGS__)
#else
#define dbgstart() ((void)0)
#define dbgend() FALSE
#define dbg(...) (-1)
#endif

// Return win32 error code
EXTERN_C DWORD PrepareForUIAccess();

#ifdef __cplusplus
}
#endif


================================================
FILE: Utils/XorStr.h
================================================
﻿#pragma once
#include <string>
#include <array>
#include <cstdarg>

#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored \
    "-Wunknown-warning-option"  // warning: unknown warning group 'xxx' // not
                                // all warnings are known by all Clang versions
                                // and they tend to be rename-happy.. so
                                // ignoring warnings triggers new warnings on
                                // some configuration. Great!
#endif
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-function"
#endif

#define BEGIN_NAMESPACE( x ) namespace x {
#define END_NAMESPACE }

BEGIN_NAMESPACE(XorCompileTime)
#define XorStr( s ) ( XorCompileTime::XorString< sizeof( s ) - 1, __COUNTER__ >( s, std::make_index_sequence< sizeof( s ) - 1>() ).decrypt() )
constexpr auto time = __TIME__;
constexpr auto seed = static_cast<int>(time[7]) + static_cast<int>(time[6]) * 10 + static_cast<int>(time[4]) * 60 + static_cast<int>(time[3]) * 600 + static_cast<int>(time[1]) * 3600 + static_cast<int>(time[0]) * 36000;

template <int N>
struct RandomGenerator
{
private:
	static constexpr unsigned a = 16807; // 7^5
	static constexpr unsigned m = 2147483647; // 2^31 - 1

	static constexpr unsigned s = RandomGenerator<N - 1>::value;
	static constexpr unsigned lo = a * (s & 0xFFFF); // Multiply lower 16 bits by 16807
	static constexpr unsigned hi = a * (s >> 16); // Multiply higher 16 bits by 16807
	static constexpr unsigned lo2 = lo + ((hi & 0x7FFF) << 16); // Combine lower 15 bits of hi with lo's upper bits
	static constexpr unsigned hi2 = hi >> 15; // Discard lower 15 bits of hi
	static constexpr unsigned lo3 = lo2 + hi;

public:
	static constexpr unsigned max = m;
	static constexpr unsigned value = lo3 > m ? lo3 - m : lo3;
};

template <>
struct RandomGenerator<0>
{
	static constexpr unsigned value = seed;
};

template <int N, int M>
struct RandomInt
{
	static constexpr auto value = RandomGenerator<N + 1>::value % M;
};

template <int N>
struct RandomChar
{
	static const char value = static_cast<char>(1 + RandomInt<N, 0x7F - 1>::value);
};

template <size_t N, int K>
struct XorString
{
private:
	const char _key;
	std::array<char, N + 1> _encrypted;

	constexpr char enc(char c) const
	{
		return c ^ _key;
	}

	char dec(char c) const
	{
		return c ^ _key;
	}

public:
	template <size_t... Is>
	constexpr __forceinline XorString(const char* str, std::index_sequence<Is...>) : _key(RandomChar<K>::value), _encrypted{ enc(str[Is])... }
	{
	}

	__forceinline decltype(auto) decrypt(void)
	{
		for (size_t i = 0; i < N; ++i)
		{
			_encrypted[i] = dec(_encrypted[i]);
		}
		_encrypted[N] = '\0';
		return _encrypted.data();
	}
};

static auto w_printf = [](const char* fmt, ...)
	{
		va_list args;
		va_start(args, fmt);
		vprintf_s(fmt, args);
		va_end(args);
	};

static auto w_printf_s = [](const char* fmt, ...)
	{
		va_list args;
		va_start(args, fmt);
		vprintf_s(fmt, args);
		va_end(args);
	};

static auto w_sprintf = [](char* buf, const char* fmt, ...)
	{
		va_list args;
		va_start(args, fmt);
		vsprintf(buf, fmt, args);
		va_end(args);
	};

static auto w_sprintf_s = [](char* buf, size_t buf_size, const char* fmt, ...)
	{
		va_list args;
		va_start(args, fmt);
		vsprintf_s(buf, buf_size, fmt, args);
		va_end(args);
	};
static bool w_strcmp(const char* str1, const char* str2)
{
	return strcmp(str1, str2);
};

#define XorStr( s ) ( XorCompileTime::XorString< sizeof( s ) - 1, __COUNTER__ >( s, std::make_index_sequence< sizeof( s ) - 1>() ).decrypt() )

END_NAMESPACE


================================================
FILE: Utils/nlohmann/json_fwd.hpp
================================================
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_
#define INCLUDE_NLOHMANN_JSON_FWD_HPP_

#include <cstdint> // int64_t, uint64_t
#include <map> // map
#include <memory> // allocator
#include <string> // string
#include <vector> // vector

// #include <nlohmann/detail/abi_macros.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// This file contains all macro definitions affecting or depending on the ABI

#ifndef JSON_SKIP_LIBRARY_VERSION_CHECK
    #if defined(NLOHMANN_JSON_VERSION_MAJOR) && defined(NLOHMANN_JSON_VERSION_MINOR) && defined(NLOHMANN_JSON_VERSION_PATCH)
        #if NLOHMANN_JSON_VERSION_MAJOR != 3 || NLOHMANN_JSON_VERSION_MINOR != 12 || NLOHMANN_JSON_VERSION_PATCH != 0
            #warning "Already included a different version of the library!"
        #endif
    #endif
#endif

#define NLOHMANN_JSON_VERSION_MAJOR 3   // NOLINT(modernize-macro-to-enum)
#define NLOHMANN_JSON_VERSION_MINOR 12  // NOLINT(modernize-macro-to-enum)
#define NLOHMANN_JSON_VERSION_PATCH 0   // NOLINT(modernize-macro-to-enum)

#ifndef JSON_DIAGNOSTICS
    #define JSON_DIAGNOSTICS 0
#endif

#ifndef JSON_DIAGNOSTIC_POSITIONS
    #define JSON_DIAGNOSTIC_POSITIONS 0
#endif

#ifndef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
    #define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON 0
#endif

#if JSON_DIAGNOSTICS
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS _diag
#else
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS
#endif

#if JSON_DIAGNOSTIC_POSITIONS
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTIC_POSITIONS _dp
#else
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTIC_POSITIONS
#endif

#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
    #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON _ldvcmp
#else
    #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON
#endif

#ifndef NLOHMANN_JSON_NAMESPACE_NO_VERSION
    #define NLOHMANN_JSON_NAMESPACE_NO_VERSION 0
#endif

// Construct the namespace ABI tags component
#define NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b, c) json_abi ## a ## b ## c
#define NLOHMANN_JSON_ABI_TAGS_CONCAT(a, b, c) \
    NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b, c)

#define NLOHMANN_JSON_ABI_TAGS                                       \
    NLOHMANN_JSON_ABI_TAGS_CONCAT(                                   \
            NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS,                       \
            NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON, \
            NLOHMANN_JSON_ABI_TAG_DIAGNOSTIC_POSITIONS)

// Construct the namespace version component
#define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch) \
    _v ## major ## _ ## minor ## _ ## patch
#define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(major, minor, patch) \
    NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch)

#if NLOHMANN_JSON_NAMESPACE_NO_VERSION
#define NLOHMANN_JSON_NAMESPACE_VERSION
#else
#define NLOHMANN_JSON_NAMESPACE_VERSION                                 \
    NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(NLOHMANN_JSON_VERSION_MAJOR, \
                                           NLOHMANN_JSON_VERSION_MINOR, \
                                           NLOHMANN_JSON_VERSION_PATCH)
#endif

// Combine namespace components
#define NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b) a ## b
#define NLOHMANN_JSON_NAMESPACE_CONCAT(a, b) \
    NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b)

#ifndef NLOHMANN_JSON_NAMESPACE
#define NLOHMANN_JSON_NAMESPACE               \
    nlohmann::NLOHMANN_JSON_NAMESPACE_CONCAT( \
            NLOHMANN_JSON_ABI_TAGS,           \
            NLOHMANN_JSON_NAMESPACE_VERSION)
#endif

#ifndef NLOHMANN_JSON_NAMESPACE_BEGIN
#define NLOHMANN_JSON_NAMESPACE_BEGIN                \
    namespace nlohmann                               \
    {                                                \
    inline namespace NLOHMANN_JSON_NAMESPACE_CONCAT( \
                NLOHMANN_JSON_ABI_TAGS,              \
                NLOHMANN_JSON_NAMESPACE_VERSION)     \
    {
#endif

#ifndef NLOHMANN_JSON_NAMESPACE_END
#define NLOHMANN_JSON_NAMESPACE_END                                     \
    }  /* namespace (inline namespace) NOLINT(readability/namespace) */ \
    }  // namespace nlohmann
#endif


/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
NLOHMANN_JSON_NAMESPACE_BEGIN

/*!
@brief default JSONSerializer template argument

This serializer ignores the template arguments and uses ADL
([argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl))
for serialization.
*/
template<typename T = void, typename SFINAE = void>
struct adl_serializer;

/// a class to store JSON values
/// @sa https://json.nlohmann.me/api/basic_json/
template<template<typename U, typename V, typename... Args> class ObjectType =
         std::map,
         template<typename U, typename... Args> class ArrayType = std::vector,
         class StringType = std::string, class BooleanType = bool,
         class NumberIntegerType = std::int64_t,
         class NumberUnsignedType = std::uint64_t,
         class NumberFloatType = double,
         template<typename U> class AllocatorType = std::allocator,
         template<typename T, typename SFINAE = void> class JSONSerializer =
         adl_serializer,
         class BinaryType = std::vector<std::uint8_t>, // cppcheck-suppress syntaxError
         class CustomBaseClass = void>
class basic_json;

/// @brief JSON Pointer defines a string syntax for identifying a specific value within a JSON document
/// @sa https://json.nlohmann.me/api/json_pointer/
template<typename RefStringType>
class json_pointer;

/*!
@brief default specialization
@sa https://json.nlohmann.me/api/json/
*/
using json = basic_json<>;

/// @brief a minimal map-like container that preserves insertion order
/// @sa https://json.nlohmann.me/api/ordered_map/
template<class Key, class T, class IgnoredLess, class Allocator>
struct ordered_map;

/// @brief specialization that maintains the insertion order of object keys
/// @sa https://json.nlohmann.me/api/ordered_json/
using ordered_json = basic_json<nlohmann::ordered_map>;

NLOHMANN_JSON_NAMESPACE_END

#endif  // INCLUDE_NLOHMANN_JSON_FWD_HPP_



================================================
FILE: Utils/vphys_parser/ray_trace.h
================================================
﻿#include "pch.h"
#include "./vector.h"
// credits tni & learn_more (www.unknowncheats.me/forum/3868338-post34.html)
#define INRANGE(x, a, b) (x >= a && x <= b)
#define getBits(x) \
  (INRANGE(x, '0', '9') ? (x - '0') : ((x & (~0x20)) - 'A' + 0xa))
#define get_byte(x) (getBits(x[0]) << 4 | getBits(x[1]))

struct BoundingBox {
  Vector min, max;

  bool intersect(const Vector& ray_origin,
                 const Vector& ray_end) const {  // Slabs method
    Vector dir = ray_end - ray_origin;
    dir = dir.Normalize();  // 确保方向向量是单位向量

    float t1 = (min.x - ray_origin.x) / dir.x;
    float t2 = (max.x - ray_origin.x) / dir.x;
    float t3 = (min.y - ray_origin.y) / dir.y;
    float t4 = (max.y - ray_origin.y) / dir.y;
    float t5 = (min.z - ray_origin.z) / dir.z;
    float t6 = (max.z - ray_origin.z) / dir.z;

    float tmin = (std::max)((std::max)((std::min)(t1, t2), (std::min)(t3, t4)),
                            (std::min)(t5, t6));
    float tmax = (std::min)((std::min)((std::max)(t1, t2), (std::max)(t3, t4)),
                            (std::max)(t5, t6));

    // 如果 tmax < 0，光线与盒子相交在光线的反方向上，所以不相交
    if (tmax < 0) {
      return false;
    }

    // 如果 tmin > tmax，光线不会穿过盒子，所以不相交
    if (tmin > tmax) {
      return false;
    }

    return true;
  }
};

struct Triangle {
  Vector p1, p2, p3;

  bool intersect(Vector ray_origin, Vector ray_end) const {
    const float EPSILON = 0.0000001f;
    Vector edge1, edge2, h, s, q;
    float a, f, u, v, t;
    edge1 = p2 - p1;
    edge2 = p3 - p1;
    h = CrossProduct(ray_end - ray_origin, edge2);
    a = edge1.Dot(h);

    if (a > -EPSILON && a < EPSILON) return false;  // 光线与三角形平行，不相交

    f = 1.f / a;
    s = ray_origin - p1;
    u = f * s.Dot(h);

    if (u < 0.0 || u > 1.0) return false;

    q = CrossProduct(s, edge1);
    v = f * (ray_end - ray_origin).Dot(q);

    if (v < 0.0 || u + v > 1.0) return false;

    // 计算 t 来找到交点
    t = f * edge2.Dot(q);

    if (t > EPSILON && t < 1.0)  // 确保 t 在 0 和 1 之间，表示交点在线段上
      return true;

    return false;  // 这意味着光线与三角形不相交或者在三角形的边界上
  }
};

struct KDNode {
  BoundingBox bbox;
  std::vector<Triangle> triangle;
  KDNode *left, *right = nullptr;
  int axis;

  void deleteKDTree(KDNode* node) {
    if (node == nullptr) return;

    // 递归地删除子节点
    deleteKDTree(node->left);
    deleteKDTree(node->right);

    // 删除当前节点
    delete node;
  }
};

bool rayIntersectsKDTree(KDNode* node, const Vector& ray_origin,
                         const Vector& ray_end) {
  if (node == nullptr) return false;

  if (!node->bbox.intersect(ray_origin, ray_end)) {
    return false;
  }

  if (node->triangle.size() > 0) {
    bool hit = false;

    for (const auto& tri : node->triangle) {
      if (tri.intersect(ray_origin, ray_end)) {
        hit = true;
      }
    }
    return hit;
  }

  bool hit_left = rayIntersectsKDTree(node->left, ray_origin, ray_end);
  bool hit_right = rayIntersectsKDTree(node->right, ray_origin, ray_end);

  return hit_left || hit_right;
}

BoundingBox calculateBoundingBox(const std::vector<Triangle>& triangles) {
  BoundingBox box;
  // 初始化为第一个三角形的第一个点
  box.min = box.max = triangles[0].p1;
  for (const auto& tri : triangles) {
    for (const auto& p : {tri.p1, tri.p2, tri.p3}) {
      box.min.x = (std::min)(box.min.x, p.x);
      box.min.y = (std::min)(box.min.y, p.y);
      box.min.z = (std::min)(box.min.z, p.z);
      box.max.x = (std::max)(box.max.x, p.x);
      box.max.y = (std::max)(box.max.y, p.y);
      box.max.z = (std::max)(box.max.z, p.z);
    }
  }
  return box;
}

KDNode* buildKDTree(std::vector<Triangle>& triangles, int depth = 0) {
  if (triangles.empty()) return nullptr;

  KDNode* node = new KDNode();
  node->bbox = calculateBoundingBox(triangles);
  node->axis = depth % 3;  // 分割轴是根据深度选择的

  if (triangles.size() <= 3) {
    node->triangle = triangles;
    return node;
  }

  auto comparator = [axis = node->axis](const Triangle& a, const Triangle& b) {
    // 比较函数使用 node->axis 来获取当前的分割轴
    float a_center, b_center;
    switch (axis) {
      case 0:
        a_center = (a.p1.x + a.p2.x + a.p3.x) / 3;
        b_center = (b.p1.x + b.p2.x + b.p3.x) / 3;
        break;
      case 1:
        a_center = (a.p1.y + a.p2.y + a.p3.y) / 3;
        b_center = (b.p1.y + b.p2.y + b.p3.y) / 3;
        break;
      case 2:
        a_center = (a.p1.z + a.p2.z + a.p3.z) / 3;
        b_center = (b.p1.z + b.p2.z + b.p3.z) / 3;
        break;
    }
    return a_center < b_center;
  };

  std::nth_element(triangles.begin(), triangles.begin() + triangles.size() / 2,
                   triangles.end(), comparator);

  std::vector<Triangle> left_triangles(
      triangles.begin(), triangles.begin() + triangles.size() / 2);
  std::vector<Triangle> right_triangles(
      triangles.begin() + triangles.size() / 2, triangles.end());

  node->left = buildKDTree(left_triangles, depth + 1);
  node->right = buildKDTree(right_triangles, depth + 1);

  return node;
}

class map_loader {
 public:
  std::vector<Triangle> triangles;
  KDNode* kd_tree;
  std::mutex mtx;

  void unload() {
    std::lock_guard<std::mutex> lock(mtx);
    if (kd_tree) kd_tree->deleteKDTree(kd_tree);
    kd_tree = nullptr;
  }

  void load_map(std::string map_name) {
    std::lock_guard<std::mutex> lock(mtx);
    auto begin = std::chrono::steady_clock::now();

    std::ifstream in(map_name + ".tri.minz", std::ios::in | std::ios::binary);
    if (!in) {
      throw std::runtime_error("无法打开文件: " + map_name + ".tri");
    }

    // 读取原始数据大小（8字节）
    uint64_t orig_size = 0;
    in.read(reinterpret_cast<char*>(&orig_size), sizeof(orig_size));
    if (in.gcount() != sizeof(orig_size)) {
      throw std::runtime_error("读取原始大小失败: " + map_name + ".tri");
    }

    // 读取压缩数据
    in.seekg(0, std::ios::end);
    std::streamsize fileSize = in.tellg();
    std::streamsize compressed_size = fileSize - sizeof(orig_size);
    in.seekg(sizeof(orig_size), std::ios::beg);

    std::vector<uint8_t> compressed_data(compressed_size);
    if (!in.read(reinterpret_cast<char*>(compressed_data.data()),
                 compressed_size)) {
      throw std::runtime_error("读取压缩数据失败: " + map_name + ".tri");
    }
    in.close();

    // 解压缩
    std::vector<Triangle> temp_triangles(orig_size / sizeof(Triangle));
    uLongf dest_len = static_cast<uLongf>(orig_size);
    int status = uncompress(reinterpret_cast<Bytef*>(temp_triangles.data()),
                            &dest_len, compressed_data.data(),
                            static_cast<uLongf>(compressed_size));
    if (status != Z_OK) {
      throw std::runtime_error("解压缩失败: " + std::to_string(status));
    }

    triangles = std::move(temp_triangles);

    kd_tree = buildKDTree(triangles);
    std::vector<Triangle>().swap(triangles);

    auto i_end = std::chrono::steady_clock::now();
    std::cout
        << "[MAP] Loaded {" << map_name << "} "
        << std::chrono::duration<double, std::milli>(i_end - begin).count()
        << "ms" << std::endl;
  }

  bool is_visible(Vector ray_origin, Vector ray_end) {
    std::lock_guard<std::mutex> lock(mtx);
    return kd_tree ? !rayIntersectsKDTree(kd_tree, ray_origin, ray_end) : false;
  }
};



================================================
FILE: Utils/vphys_parser/vector.h
================================================
﻿#pragma once

#include "pch.h"

#define Assert(_exp) ((void)0)

#define FastSqrt(x) (sqrt)(x)

#define M_PI 3.14159265358979323846 // matches value in gcc v2 math.h

#define M_PI_F ((float)(M_PI)) // Shouldn't collide with anything.

#define M_PHI 1.61803398874989484820 // golden ratio

// NJS: Inlined to prevent floats from being autopromoted to doubles, as with
// the old system.
#ifndef RAD2DEG
#define RAD2DEG(x) ((float)(x) * (float)(180.f / M_PI_F))
#endif

#ifndef DEG2RAD
#define DEG2RAD(x) ((float)(x) * (float)(M_PI_F / 180.f))
#endif

// MOVEMENT INFO
enum {
    PITCH = 0, // up / down
    YAW,       // left / right
    ROLL       // fall over
};

// decls for aligning data

#define DECL_ALIGN(x) __attribute__((aligned(x)))

#define ALIGN16 DECL_ALIGN(16)
#define VALVE_RAND_MAX 0x7fff
#define VectorExpand(v) (v).x, (v).y, (v).z

struct matrix3x4_t {
    matrix3x4_t() {}
    matrix3x4_t(float m00, float m01, float m02, float m03, float m10, float m11,
        float m12, float m13, float m20, float m21, float m22,
        float m23) {
        m_flMatVal[0][0] = m00;
        m_flMatVal[0][1] = m01;
        m_flMatVal[0][2] = m02;
        m_flMatVal[0][3] = m03;
        m_flMatVal[1][0] = m10;
        m_flMatVal[1][1] = m11;
        m_flMatVal[1][2] = m12;
        m_flMatVal[1][3] = m13;
        m_flMatVal[2][0] = m20;
        m_flMatVal[2][1] = m21;
        m_flMatVal[2][2] = m22;
        m_flMatVal[2][3] = m23;
    }

    float* operator[](int i) {
        Assert((i >= 0) && (i < 3));
        return m_flMatVal[i];
    }
    const float* operator[](int i) const {
        Assert((i >= 0) && (i < 3));
        return m_flMatVal[i];
    }
    float* Base() { return &m_flMatVal[0][0]; }
    const float* Base() const { return &m_flMatVal[0][0]; }

    float m_flMatVal[3][4];
};

class VMatrix {
public:
    VMatrix() {}
    VMatrix(float m00, float m01, float m02, float m03, float m10, float m11,
        float m12, float m13, float m20, float m21, float m22, float m23,
        float m30, float m31, float m32, float m33) {
        m[0][0] = m00;
        m[0][1] = m01;
        m[0][2] = m02;
        m[0][3] = m03;

        m[1][0] = m10;
        m[1][1] = m11;
        m[1][2] = m12;
        m[1][3] = m13;

        m[2][0] = m20;
        m[2][1] = m21;
        m[2][2] = m22;
        m[2][3] = m23;

        m[3][0] = m30;
        m[3][1] = m31;
        m[3][2] = m32;
        m[3][3] = m33;
    }

    // array access
    inline float* operator[](int i) { return m[i]; }

    inline const float* operator[](int i) const { return m[i]; }

    // Get a pointer to m[0][0]
    inline float* Base() { return &m[0][0]; }

    inline const float* Base() const { return &m[0][0]; }

public:
    // The matrix.
    float m[4][4];
};

class Vector {
public:
    float x, y, z;
    Vector(void);
    Vector(float X, float Y, float Z);
    void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f);
    bool IsValid() const;
    float operator[](int i) const;
    float& operator[](int i);
    inline void Zero();
    bool operator==(const Vector& v) const;
    bool operator!=(const Vector& v) const;
    inline Vector& operator+=(const Vector& v);
    inline Vector& operator-=(const Vector& v);
    inline Vector& operator*=(const Vector& v);
    inline Vector& operator*=(float s);
    inline Vector& operator/=(const Vector& v);
    inline Vector& operator/=(float s);
    inline Vector& operator+=(float fl);
    inline Vector& operator-=(float fl);
    inline float Length() const;
    inline float LengthSqr(void) const { return (x * x + y * y + z * z); }
    bool IsZero(float tolerance = 0.01f) const {
        return (x > -tolerance && x < tolerance && y > -tolerance &&
            y < tolerance && z > -tolerance && z < tolerance);
    }
    Vector Normalize();
    void NormalizeInPlace();
    inline float DistTo(const Vector& vOther) const;
    inline float DistToSqr(const Vector& vOther) const;
    float Dot(const Vector& vOther) const;
    float Length2D(void) const;
    float Length2DSqr(void) const;
    Vector& operator=(const Vector& vOther);
    Vector operator-(void) const;
    Vector operator+(const Vector& v) const;
    Vector operator-(const Vector& v) const;
    Vector operator*(const Vector& v) const;
    Vector operator/(const Vector& v) const;
    Vector operator*(float fl) const;
    Vector operator/(float fl) const;
    // Base address...
    float* Base();
    float const* Base() const;
};

//===============================================
inline void Vector::Init(float ix, float iy, float iz) {
    x = ix;
    y = iy;
    z = iz;
}
//===============================================
inline Vector::Vector(float X, float Y, float Z) {
    x = X;
    y = Y;
    z = Z;
}
//===============================================
inline Vector::Vector(void) { Zero(); }
//===============================================
inline void Vector::Zero() { x = y = z = 0.0f; }
//===============================================
inline void VectorClear(Vector& a) { a.x = a.y = a.z = 0.0f; }
//===============================================
inline Vector& Vector::operator=(const Vector& vOther) {
    x = vOther.x;
    y = vOther.y;
    z = vOther.z;
    return *this;
}
//===============================================
inline float& Vector::operator[](int i) {
    Assert((i >= 0) && (i < 3));
    return ((float*)this)[i];
}
//===============================================
inline float Vector::operator[](int i) const {
    Assert((i >= 0) && (i < 3));
    return ((float*)this)[i];
}
//===============================================
inline bool Vector::operator==(const Vector& src) const {
    return (src.x == x) && (src.y == y) && (src.z == z);
}
//===============================================
inline bool Vector::operator!=(const Vector& src) const {
    return (src.x != x) || (src.y != y) || (src.z != z);
}
//===============================================
inline void VectorCopy(const Vector& src, Vector& dst) {
    dst.x = src.x;
    dst.y = src.y;
    dst.z = src.z;
}
//===============================================
inline Vector& Vector::operator+=(const Vector& v) {
    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}
//===============================================
inline Vector& Vector::operator-=(const Vector& v) {
    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}
//===============================================
inline Vector& Vector::operator*=(float fl) {
    x *= fl;
    y *= fl;
    z *= fl;

    return *this;
}
//===============================================
inline Vector& Vector::operator*=(const Vector& v) {
    x *= v.x;
    y *= v.y;
    z *= v.z;

    return *this;
}
//===============================================
inline Vector& Vector::operator+=(float fl) {
    x += fl;
    y += fl;
    z += fl;

    return *this;
}
//===============================================
inline Vector& Vector::operator-=(float fl) {
    x -= fl;
    y -= fl;
    z -= fl;

    return *this;
}
//===============================================
inline Vector& Vector::operator/=(float fl) {
    Assert(fl != 0.0f);
    float oofl = 1.0f / fl;
    x *= oofl;
    y *= oofl;
    z *= oofl;

    return *this;
}
//===============================================
inline Vector& Vector::operator/=(const Vector& v) {
    Assert(v.x != 0.0f && v.y != 0.0f && v.z != 0.0f);
    x /= v.x;
    y /= v.y;
    z /= v.z;

    return *this;
}
//===============================================
inline float Vector::Length(void) const {

    float root = 0.0f;

    float sqsr = x * x + y * y + z * z;

    root = sqrt(sqsr);

    return root;
}
//===============================================
inline float Vector::Length2D(void) const {
    float root = 0.0f;

    float sqst = x * x + y * y;

    root = sqrt(sqst);

    return root;
}
//===============================================
inline float Vector::Length2DSqr(void) const { return (x * x + y * y); }
//===============================================
inline Vector CrossProduct(const Vector& a, const Vector& b) {
    return Vector(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x);
}
//===============================================
float Vector::DistTo(const Vector& vOther) const {
    Vector delta;

    delta.x = x - vOther.x;
    delta.y = y - vOther.y;
    delta.z = z - vOther.z;

    return delta.Length();
}
float Vector::DistToSqr(const Vector& vOther) const {
    Vector delta;

    delta.x = x - vOther.x;
    delta.y = y - vOther.y;
    delta.z = z - vOther.z;

    return delta.LengthSqr();
}
//===============================================
inline Vector Vector::Normalize() {
    Vector vector;
    float length = this->Length();

    if (length != 0) {
        vector.x = x / length;
        vector.y = y / length;
        vector.z = z / length;
    }
    else {
        vector.x = vector.y = 0.0f;
        vector.z = 1.0f;
    }

    return vector;
}
//===============================================
inline void Vector::NormalizeInPlace() {
    Vector& v = *this;

    float iradius = 1.f / (this->Length() + 1.192092896e-07F); // FLT_EPSILON

    v.x *= iradius;
    v.y *= iradius;
    v.z *= iradius;
}
//===============================================
inline float VectorNormalize(Vector& v) {
    Assert(v.IsValid());
    float l = v.Length();
    if (l != 0.0f) {
        v /= l;
    }
    else {
        // FIXME:
        // Just copying the existing implemenation; shouldn't res.z == 0?
        v.x = v.y = 0.0f;
        v.z = 1.0f;
    }
    return l;
}
//===============================================
inline float VectorNormalize(float* v) {
    return VectorNormalize(*(reinterpret_cast<Vector*>(v)));
}
//===============================================
inline Vector Vector::operator+(const Vector& v) const {
    Vector res;
    res.x = x + v.x;
    res.y = y + v.y;
    res.z = z + v.z;
    return res;
}

//===============================================
inline Vector Vector::operator-(const Vector& v) const {
    Vector res;
    res.x = x - v.x;
    res.y = y - v.y;
    res.z = z - v.z;
    return res;
}
//===============================================
inline Vector Vector::operator*(float fl) const {
    Vector res;
    res.x = x * fl;
    res.y = y * fl;
    res.z = z * fl;
    return res;
}
//===============================================
inline Vector Vector::operator*(const Vector& v) const {
    Vector res;
    res.x = x * v.x;
    res.y = y * v.y;
    res.z = z * v.z;
    return res;
}
//===============================================
inline Vector Vector::operator/(float fl) const {
    Vector res;
    res.x = x / fl;
    res.y = y / fl;
    res.z = z / fl;
    return res;
}
//===============================================
inline Vector Vector::operator/(const Vector& v) const {
    Vector res;
    res.x = x / v.x;
    res.y = y / v.y;
    res.z = z / v.z;
    return res;
}
inline float Vector::Dot(const Vector& vOther) const {
    const Vector& a = *this;

    return (a.x * vOther.x + a.y * vOther.y + a.z * vOther.z);
}

//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------

inline float VectorLength(const Vector& v) {

    return (float)FastSqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

// VECTOR SUBTRAC
inline void VectorSubtract(const Vector& a, const Vector& b, Vector& c) {

    c.x = a.x - b.x;
    c.y = a.y - b.y;
    c.z = a.z - b.z;
}

// VECTORADD
inline void VectorAdd(const Vector& a, const Vector& b, Vector& c) {

    c.x = a.x + b.x;
    c.y = a.y + b.y;
    c.z = a.z + b.z;
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------
inline float* Vector::Base() { return (float*)this; }

inline float const* Vector::Base() const { return (float const*)this; }

inline void VectorMAInline(const float* start, float scale,
    const float* direction, float* dest) {
    dest[0] = start[0] + direction[0] * scale;
    dest[1] = start[1] + direction[1] * scale;
    dest[2] = start[2] + direction[2] * scale;
}

inline void VectorMAInline(const Vector& start, float scale,
    const Vector& direction, Vector& dest) {
    dest.x = start.x + direction.x * scale;
    dest.y = start.y + direction.y * scale;
    dest.z = start.z + direction.z * scale;
}

inline void VectorMA(const Vector& start, float scale, const Vector& direction,
    Vector& dest) {
    VectorMAInline(start, scale, direction, dest);
}

inline void VectorMA(const float* start, float scale, const float* direction,
    float* dest) {
    VectorMAInline(start, scale, direction, dest);
}

inline unsigned long& FloatBits(float& f) {
    return *reinterpret_cast<unsigned long*>(&f);
}

inline bool IsFinite(float f) {
    return ((FloatBits(f) & 0x7F800000) != 0x7F800000);
}

//=========================================================
// 2D Vector2D
//=========================================================

class Vector2D {
public:
    // Members
    float x, y;

    // Construction/destruction
    Vector2D(void);
    Vector2D(float X, float Y);
    Vector2D(const float* pFloat);

    // Initialization
    void Init(float ix = 0.0f, float iy = 0.0f);

    // Got any nasty NAN's?
    bool IsValid() const;

    // array access...
    float operator[](int i) const;
    float& operator[](int i);

    // Base address...
    float* Base();
    float const* Base() const;

    // Initialization methods
    void Random(float minVal, float maxVal);

    // equality
    bool operator==(const Vector2D& v) const;
    bool operator!=(const Vector2D& v) const;

    // arithmetic operations
    Vector2D& operator+=(const Vector2D& v);
    Vector2D& operator-=(const Vector2D& v);
    Vector2D& operator*=(const Vector2D& v);
    Vector2D& operator*=(float s);
    Vector2D& operator/=(const Vector2D& v);
    Vector2D& operator/=(float s);

    // negate the Vector2D components
    void Negate();

    // Get the Vector2D's magnitude.
    float Length() const;

    // Get the Vector2D's magnitude squared.
    float LengthSqr(void) const;

    // return true if this vector is (0,0) within tolerance
    bool IsZero(float tolerance = 0.01f) const {
        return (x > -tolerance && x < tolerance && y > -tolerance && y < tolerance);
    }

    float Normalize();

    // Normalize in place and return the old length.
    float NormalizeInPlace();

    // Compare length.
    bool IsLengthGreaterThan(float val) const;
    bool IsLengthLessThan(float val) const;

    // Get the distance from this Vector2D to the other one.
    float DistTo(const Vector2D& vOther) const;

    // Get the distance from this Vector2D to the other one squared.
    float DistToSqr(const Vector2D& vOther) const;

    // Copy
    void CopyToArray(float* rgfl) const;

    // Multiply, add, and assign to this (ie: *this = a + b * scalar). This
    // is about 12% faster than the actual Vector2D equation (because it's done
    // per-component rather than per-Vector2D).
    void MulAdd(const Vector2D& a, const Vector2D& b, float scalar);

    // Dot product.
    float Dot(const Vector2D& vOther) const;

    // assignment
    Vector2D& operator=(const Vector2D& vOther);

#ifndef VECTOR_NO_SLOW_OPERATIONS
    // copy constructors
    Vector2D(const Vector2D& vOther);

    // arithmetic operations
    Vector2D operator-(void) const;

    Vector2D operator+(const Vector2D& v) const;
    Vector2D operator-(const Vector2D& v) const;
    Vector2D operator*(const Vector2D& v) const;
    Vector2D operator/(const Vector2D& v) const;
    Vector2D operator*(float fl) const;
    Vector2D operator/(float fl) const;

    // Cross product between two vectors.
    Vector2D Cross(const Vector2D& vOther) const;

    // Returns a Vector2D with the min or max in X, Y, and Z.
    Vector2D Min(const Vector2D& vOther) const;
    Vector2D Max(const Vector2D& vOther) const;

#else

private:
    // No copy constructors allowed if we're in optimal mode
    Vector2D(const Vector2D& vOther);
#endif
};

//-----------------------------------------------------------------------------

const Vector2D vec2_origin(0, 0);
// const Vector2D vec2_invalid(3.40282347E+38F, 3.40282347E+38F);

//-----------------------------------------------------------------------------
// Vector2D related operations
//-----------------------------------------------------------------------------

// Vector2D clear
void Vector2DClear(Vector2D& a);

// Copy
void Vector2DCopy(const Vector2D& src, Vector2D& dst);

// Vector2D arithmetic
void Vector2DAdd(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DSubtract(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DMultiply(const Vector2D& a, float b, Vector2D& result);
void Vector2DMultiply(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DDivide(const Vector2D& a, float b, Vector2D& result);
void Vector2DDivide(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DMA(const Vector2D& start, float s, const Vector2D& dir,
    Vector2D& result);

// Store the min or max of each of x, y, and z into the result.
void Vector2DMin(const Vector2D& a, const Vector2D& b, Vector2D& result);
void Vector2DMax(const Vector2D& a, const Vector2D& b, Vector2D& result);

#define Vector2DExpand(v) (v).x, (v).y

// Normalization
float Vector2DNormalize(Vector2D& v);

// Length
float Vector2DLength(const Vector2D& v);

// Dot Product
float DotProduct2D(const Vector2D& a, const Vector2D& b);

// Linearly interpolate between two vectors
void Vector2DLerp(const Vector2D& src1, const Vector2D& src2, float t,
    Vector2D& dest);

//-----------------------------------------------------------------------------
//
// Inlined Vector2D methods
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// constructors
//-----------------------------------------------------------------------------

inline Vector2D::Vector2D(void) {
#ifdef _DEBUG
    // Initialize to NAN to catch errors
    // x = y = float_NAN;
#endif
}

inline Vector2D::Vector2D(float X, float Y) {
    x = X;
    y = Y;
    Assert(IsValid());
}

inline Vector2D::Vector2D(const float* pFloat) {
    Assert(pFloat);
    x = pFloat[0];
    y = pFloat[1];
    Assert(IsValid());
}

//-----------------------------------------------------------------------------
// copy constructor
//-----------------------------------------------------------------------------

inline Vector2D::Vector2D(const Vector2D& vOther) {
    Assert(vOther.IsValid());
    x = vOther.x;
    y = vOther.y;
}

//-----------------------------------------------------------------------------
// initialization
//-----------------------------------------------------------------------------

inline void Vector2D::Init(float ix, float iy) {
    x = ix;
    y = iy;
    Assert(IsValid());
}

inline void Vector2D::Random(float minVal, float maxVal) {
    x = minVal + ((float)rand() / VALVE_RAND_MAX) * (maxVal - minVal);
    y = minVal + ((float)rand() / VALVE_RAND_MAX) * (maxVal - minVal);
}

inline void Vector2DClear(Vector2D& a) { a.x = a.y = 0.0f; }

//-----------------------------------------------------------------------------
// assignment
//-----------------------------------------------------------------------------

inline Vector2D& Vector2D::operator=(const Vector2D& vOther) {
    Assert(vOther.IsValid());
    x = vOther.x;
    y = vOther.y;
    return *this;
}

//-----------------------------------------------------------------------------
// Array access
//-----------------------------------------------------------------------------

inline float& Vector2D::operator[](int i) {
    Assert((i >= 0) && (i < 2));
    return ((float*)this)[i];
}

inline float Vector2D::operator[](int i) const {
    Assert((i >= 0) && (i < 2));
    return ((float*)this)[i];
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------

inline float* Vector2D::Base() { return (float*)this; }

inline float const* Vector2D::Base() const { return (float const*)this; }

//-----------------------------------------------------------------------------
// IsValid?
//-----------------------------------------------------------------------------

inline bool Vector2D::IsValid() const { return IsFinite(x) && IsFinite(y); }

//-----------------------------------------------------------------------------
// comparison
//-----------------------------------------------------------------------------

inline bool Vector2D::operator==(const Vector2D& src) const {
    Assert(src.IsValid() && IsValid());
    return (src.x == x) && (src.y == y);
}

inline bool Vector2D::operator!=(const Vector2D& src) const {
    Assert(src.IsValid() && IsValid());
    return (src.x != x) || (src.y != y);
}

//-----------------------------------------------------------------------------
// Copy
//-----------------------------------------------------------------------------

inline void Vector2DCopy(const Vector2D& src, Vector2D& dst) {
    Assert(src.IsValid());
    dst.x = src.x;
    dst.y = src.y;
}

inline void Vector2D::CopyToArray(float* rgfl) const {
    Assert(IsValid());
    Assert(rgfl);
    rgfl[0] = x;
    rgfl[1] = y;
}

//-----------------------------------------------------------------------------
// standard math operations
//-----------------------------------------------------------------------------

inline void Vector2D::Negate() {
    Assert(IsValid());
    x = -x;
    y = -y;
}

inline Vector2D& Vector2D::operator+=(const Vector2D& v) {
    Assert(IsValid() && v.IsValid());
    x += v.x;
    y += v.y;
    return *this;
}

inline Vector2D& Vector2D::operator-=(const Vector2D& v) {
    Assert(IsValid() && v.IsValid());
    x -= v.x;
    y -= v.y;
    return *this;
}

inline Vector2D& Vector2D::operator*=(float fl) {
    x *= fl;
    y *= fl;
    Assert(IsValid());
    return *this;
}

inline Vector2D& Vector2D::operator*=(const Vector2D& v) {
    x *= v.x;
    y *= v.y;
    Assert(IsValid());
    return *this;
}

inline Vector2D& Vector2D::operator/=(float fl) {
    Assert(fl != 0.0f);
    float oofl = 1.0f / fl;
    x *= oofl;
    y *= oofl;
    Assert(IsValid());
    return *this;
}

inline Vector2D& Vector2D::operator/=(const Vector2D& v) {
    Assert(v.x != 0.0f && v.y != 0.0f);
    x /= v.x;
    y /= v.y;
    Assert(IsValid());
    return *this;
}

inline void Vector2DAdd(const Vector2D& a, const Vector2D& b, Vector2D& c) {
    Assert(a.IsValid() && b.IsValid());
    c.x = a.x + b.x;
    c.y = a.y + b.y;
}

inline void Vector2DSubtract(const Vector2D& a, const Vector2D& b,
    Vector2D& c) {
    Assert(a.IsValid() && b.IsValid());
    c.x = a.x - b.x;
    c.y = a.y - b.y;
}

inline void Vector2DMultiply(const Vector2D& a, float b, Vector2D& c) {
    Assert(a.IsValid() && IsFinite(b));
    c.x = a.x * b;
    c.y = a.y * b;
}

inline void Vector2DMultiply(const Vector2D& a, const Vector2D& b,
    Vector2D& c) {
    Assert(a.IsValid() && b.IsValid());
    c.x = a.x * b.x;
    c.y = a.y * b.y;
}

inline void Vector2DDivide(const Vector2D& a, float b, Vector2D& c) {
    Assert(a.IsValid());
    Assert(b != 0.0f);
    float oob = 1.0f / b;
    c.x = a.x * oob;
    c.y = a.y * oob;
}

inline void Vector2DDivide(const Vector2D& a, const Vector2D& b, Vector2D& c) {
    Assert(a.IsValid());
    Assert((b.x != 0.0f) && (b.y != 0.0f));
    c.x = a.x / b.x;
    c.y = a.y / b.y;
}

inline void Vector2DMA(const Vector2D& start, float s, const Vector2D& dir,
    Vector2D& result) {
    Assert(start.IsValid() && IsFinite(s) && dir.IsValid());
    result.x = start.x + s * dir.x;
    result.y = start.y + s * dir.y;
}

// FIXME: Remove
// For backwards compatability
inline void Vector2D::MulAdd(const Vector2D& a, const Vector2D& b,
    float scalar) {
    x = a.x + b.x * scalar;
    y = a.y + b.y * scalar;
}

inline void Vector2DLerp(const Vector2D& src1, const Vector2D& src2, float t,
    Vector2D& dest) {
    dest[0] = src1[0] + (src2[0] - src1[0]) * t;
    dest[1] = src1[1] + (src2[1] - src1[1]) * t;
}

//-----------------------------------------------------------------------------
// dot, cross
//-----------------------------------------------------------------------------
inline float DotProduct2D(const Vector2D& a, const Vector2D& b) {
    Assert(a.IsValid() && b.IsValid());
    return (a.x * b.x + a.y * b.y);
}

// for backwards compatability
inline float Vector2D::Dot(const Vector2D& vOther) const {
    return DotProduct2D(*this, vOther);
}

//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------
inline float Vector2DLength(const Vector2D& v) {
    Assert(v.IsValid());
    return (float)FastSqrt(v.x * v.x + v.y * v.y);
}

inline float Vector2D::LengthSqr(void) const {
    Assert(IsValid());
    return (x * x + y * y);
}

inline float Vector2D::NormalizeInPlace() { return Vector2DNormalize(*this); }

inline bool Vector2D::IsLengthGreaterThan(float val) const {
    return LengthSqr() > val * val;
}

inline bool Vector2D::IsLengthLessThan(float val) const {
    return LengthSqr() < val * val;
}

inline float Vector2D::Length(void) const { return Vector2DLength(*this); }

inline void Vector2DMin(const Vector2D& a, const Vector2D& b,
    Vector2D& result) {
    result.x = (a.x < b.x) ? a.x : b.x;
    result.y = (a.y < b.y) ? a.y : b.y;
}

inline void Vector2DMax(const Vector2D& a, const Vector2D& b,
    Vector2D& result) {
    result.x = (a.x > b.x) ? a.x : b.x;
    result.y = (a.y > b.y) ? a.y : b.y;
}

//-----------------------------------------------------------------------------
// Normalization
//-----------------------------------------------------------------------------
inline float Vector2DNormalize(Vector2D& v) {
    Assert(v.IsValid());
    float l = v.Length();
    if (l != 0.0f) {
        v /= l;
    }
    else {
        v.x = v.y = 0.0f;
    }
    return l;
}

//-----------------------------------------------------------------------------
// Get the distance from this Vector2D to the other one
//-----------------------------------------------------------------------------
inline float Vector2D::DistTo(const Vector2D& vOther) const {
    Vector2D delta;
    Vector2DSubtract(*this, vOther, delta);
    return delta.Length();
}

inline float Vector2D::DistToSqr(const Vector2D& vOther) const {
    Vector2D delta;
    Vector2DSubtract(*this, vOther, delta);
    return delta.LengthSqr();
}

//-----------------------------------------------------------------------------
// Computes the closest point to vecTarget no farther than flMaxDist from
// vecStart
//-----------------------------------------------------------------------------
inline void ComputeClosestPoint2D(const Vector2D& vecStart, float flMaxDist,
    const Vector2D& vecTarget,
    Vector2D* pResult) {
    Vector2D vecDelta;
    Vector2DSubtract(vecTarget, vecStart, vecDelta);
    float flDistSqr = vecDelta.LengthSqr();
    if (flDistSqr <= flMaxDist * flMaxDist) {
        *pResult = vecTarget;
    }
    else {
        vecDelta /= FastSqrt(flDistSqr);
        Vector2DMA(vecStart, flMaxDist, vecDelta, *pResult);
    }
}

//-----------------------------------------------------------------------------
//
// Slow methods
//
//-----------------------------------------------------------------------------

#ifndef VECTOR_NO_SLOW_OPERATIONS
#endif
//-----------------------------------------------------------------------------
// Returns a Vector2D with the min or max in X, Y, and Z.
//-----------------------------------------------------------------------------

inline Vector2D Vector2D::Min(const Vector2D& vOther) const {
    return Vector2D(x < vOther.x ? x : vOther.x, y < vOther.y ? y : vOther.y);
}

inline Vector2D Vector2D::Max(const Vector2D& vOther) const {
    return Vector2D(x > vOther.x ? x : vOther.x, y > vOther.y ? y : vOther.y);
}

//-----------------------------------------------------------------------------
// arithmetic operations
//-----------------------------------------------------------------------------

inline Vector2D Vector2D::operator-(void) const { return Vector2D(-x, -y); }

inline Vector2D Vector2D::operator+(const Vector2D& v) const {
    Vector2D res;
    Vector2DAdd(*this, v, res);
    return res;
}

inline Vector2D Vector2D::operator-(const Vector2D& v) const {
    Vector2D res;
    Vector2DSubtract(*this, v, res);
    return res;
}

inline Vector2D Vector2D::operator*(float fl) const {
    Vector2D res;
    Vector2DMultiply(*this, fl, res);
    return res;
}

inline Vector2D Vector2D::operator*(const Vector2D& v) const {
    Vector2D res;
    Vector2DMultiply(*this, v, res);
    return res;
}

inline Vector2D Vector2D::operator/(float fl) const {
    Vector2D res;
    Vector2DDivide(*this, fl, res);
    return res;
}

inline Vector2D Vector2D::operator/(const Vector2D& v) const {
    Vector2D res;
    Vector2DDivide(*this, v, res);
    return res;
}

inline Vector2D operator*(float fl, const Vector2D& v) { return v * fl; }

class QAngleByValue;
class QAngle {
public:
    // Members
    float x, y, z;

    // Construction/destruction
    QAngle(void);
    QAngle(float X, float Y, float Z);
    //      QAngle(RadianEuler const &angles);      // evil auto type promotion!!!

    // Allow pass-by-value
    operator QAngleByValue& () { return *((QAngleByValue*)(this)); }
    operator const QAngleByValue& () const {
        return *((const QAngleByValue*)(this));
    }

    // Initialization
    void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f);
    void Random(float minVal, float maxVal);

    // Got any nasty NAN's?
    bool IsValid() const;
    void Invalidate();

    // array access...
    float operator[](int i) const;
    float& operator[](int i);

    // Base address...
    float* Base();
    float const* Base() const;

    // equality
    bool operator==(const QAngle& v) const;
    bool operator!=(const QAngle& v) const;

    bool IsZero(float tolerance = 0.01f) const {
        return (x > -tolerance && x < tolerance && y > -tolerance &&
            y < tolerance && z > -tolerance && z < tolerance);
    }

    // arithmetic operations
    QAngle& operator+=(const QAngle& v);
    QAngle& operator-=(const QAngle& v);
    QAngle& operator*=(float s);
    QAngle& operator/=(float s);

    // Get the vector's magnitude.
    float Length() const;
    float LengthSqr() const;

    // negate the QAngle components
    // void  Negate();

    // No assignment operators either...
    QAngle& operator=(const QAngle& src);

#ifndef VECTOR_NO_SLOW_OPERATIONS
    // copy constructors

    // arithmetic operations
    QAngle operator-(void) const;

    QAngle operator+(const QAngle& v) const;
    QAngle operator-(const QAngle& v) const;
    QAngle operator*(float fl) const;
    QAngle operator/(float fl) const;
#else

private:
    // No copy constructors allowed if we're in optimal mode
    QAngle(const QAngle& vOther);

#endif
};

//-----------------------------------------------------------------------------
// constructors
//-----------------------------------------------------------------------------
inline QAngle::QAngle(void) {
#ifdef _DEBUG
#ifdef VECTOR_PARANOIA
    // Initialize to NAN to catch errors
    x = y = z = VEC_T_NAN;
#endif
#endif
}

inline QAngle::QAngle(float X, float Y, float Z) {
    x = X;
    y = Y;
    z = Z;
}

//-----------------------------------------------------------------------------
// initialization
//-----------------------------------------------------------------------------
inline void QAngle::Init(float ix, float iy, float iz) {
    x = ix;
    y = iy;
    z = iz;
}

inline void QAngle::Random(float minVal, float maxVal) {
    x = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
    y = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
    z = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
}

//-----------------------------------------------------------------------------
// assignment
//-----------------------------------------------------------------------------
inline QAngle& QAngle::operator=(const QAngle& vOther) {

    x = vOther.x;
    y = vOther.y;
    z = vOther.z;
    return *this;
}

//-----------------------------------------------------------------------------
// comparison
//-----------------------------------------------------------------------------
inline bool QAngle::operator==(const QAngle& src) const {

    return (src.x == x) && (src.y == y) && (src.z == z);
}

inline bool QAngle::operator!=(const QAngle& src) const {

    return (src.x != x) || (src.y != y) || (src.z != z);
}

//-----------------------------------------------------------------------------
// standard math operations
//-----------------------------------------------------------------------------
inline QAngle& QAngle::operator+=(const QAngle& v) {

    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}

inline QAngle& QAngle::operator-=(const QAngle& v) {

    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}

inline QAngle& QAngle::operator*=(float fl) {
    x *= fl;
    y *= fl;
    z *= fl;

    return *this;
}

inline QAngle& QAngle::operator/=(float fl) {
    Assert(fl != 0.0f);
    float oofl = 1.0f / fl;
    x *= oofl;
    y *= oofl;
    z *= oofl;

    return *this;
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------
inline float* QAngle::Base() { return (float*)this; }

inline float const* QAngle::Base() const { return (float const*)this; }

//-----------------------------------------------------------------------------
// Array access
//-----------------------------------------------------------------------------
inline float& QAngle::operator[](int i) {
    Assert((i >= 0) && (i < 3));
    return ((float*)this)[i];
}

inline float QAngle::operator[](int i) const {
    Assert((i >= 0) && (i < 3));
    return ((float*)this)[i];
}

//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------
inline float QAngle::Length() const { return (float)FastSqrt(LengthSqr()); }

inline float QAngle::LengthSqr() const { return x * x + y * y + z * z; }

//-----------------------------------------------------------------------------
// arithmetic operations (SLOW!!)
//-----------------------------------------------------------------------------
#ifndef VECTOR_NO_SLOW_OPERATIONS

inline QAngle QAngle::operator-(void) const { return QAngle(-x, -y, -z); }

inline QAngle QAngle::operator+(const QAngle& v) const {
    QAngle res;
    res.x = x + v.x;
    res.y = y + v.y;
    res.z = z + v.z;
    return res;
}

inline QAngle QAngle::operator-(const QAngle& v) const {
    QAngle res;
    res.x = x - v.x;
    res.y = y - v.y;
    res.z = z - v.z;
    return res;
}

inline QAngle QAngle::operator*(float fl) const {
    QAngle res;
    res.x = x * fl;
    res.y = y * fl;
    res.z = z * fl;
    return res;
}

inline QAngle QAngle::operator/(float fl) const {
    QAngle res;
    res.x = x / fl;
    res.y = y / fl;
    res.z = z / fl;
    return res;
}

inline QAngle operator*(float fl, const QAngle& v) { return v * fl; }

#endif // VECTOR_NO_SLOW_OPERATIONS

// QANGLE SUBTRAC
inline void QAngleSubtract(const QAngle& a, const QAngle& b, QAngle& c) {

    c.x = a.x - b.x;
    c.y = a.y - b.y;
    c.z = a.z - b.z;
}

// QANGLEADD
inline void QAngleAdd(const QAngle& a, const QAngle& b, QAngle& c) {

    c.x = a.x + b.x;
    c.y = a.y + b.y;
    c.z = a.z + b.z;
}


================================================
FILE: Utils/yaml-cpp/anchor.h
================================================
#ifndef ANCHOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define ANCHOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <cstddef>

namespace YAML {
using anchor_t = std::size_t;
const anchor_t NullAnchor = 0;
}

#endif  // ANCHOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/binary.h
================================================
﻿#ifndef BASE64_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define BASE64_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <string>
#include <vector>

#include "../yaml-cpp/dll.h"

namespace YAML {
YAML_CPP_API std::string EncodeBase64(const unsigned char *data,
                                      std::size_t size);
YAML_CPP_API std::vector<unsigned char> DecodeBase64(const std::string &input);

class YAML_CPP_API Binary {
 public:
  Binary(const unsigned char *data_, std::size_t size_)
      : m_data{}, m_unownedData(data_), m_unownedSize(size_) {}
  Binary() : Binary(nullptr, 0) {}
  Binary(const Binary &) = default;
  Binary(Binary &&) = default;
  Binary &operator=(const Binary &) = default;
  Binary &operator=(Binary &&) = default;

  bool owned() const { return !m_unownedData; }
  std::size_t size() const { return owned() ? m_data.size() : m_unownedSize; }
  const unsigned char *data() const {
    return owned() ? &m_data[0] : m_unownedData;
  }

  void swap(std::vector<unsigned char> &rhs) {
    if (m_unownedData) {
      m_data.swap(rhs);
      rhs.clear();
      rhs.resize(m_unownedSize);
      std::copy(m_unownedData, m_unownedData + m_unownedSize, rhs.begin());
      m_unownedData = nullptr;
      m_unownedSize = 0;
    } else {
      m_data.swap(rhs);
    }
  }

  bool operator==(const Binary &rhs) const {
    const std::size_t s = size();
    if (s != rhs.size())
      return false;
    const unsigned char *d1 = data();
    const unsigned char *d2 = rhs.data();
    for (std::size_t i = 0; i < s; i++) {
      if (*d1++ != *d2++)
        return false;
    }
    return true;
  }

  bool operator!=(const Binary &rhs) const { return !(*this == rhs); }

 private:
  std::vector<unsigned char> m_data;
  const unsigned char *m_unownedData;
  std::size_t m_unownedSize;
};
}  // namespace YAML

#endif  // BASE64_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/depthguard.h
================================================
#ifndef DEPTH_GUARD_H_00000000000000000000000000000000000000000000000000000000
#define DEPTH_GUARD_H_00000000000000000000000000000000000000000000000000000000

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "exceptions.h"

namespace YAML {

/**
 * @brief The DeepRecursion class
 *  An exception class which is thrown by DepthGuard. Ideally it should be
 * a member of DepthGuard. However, DepthGuard is a templated class which means
 * that any catch points would then need to know the template parameters. It is
 * simpler for clients to not have to know at the catch point what was the
 * maximum depth.
 */
class DeepRecursion : public ParserException {
public:
  virtual ~DeepRecursion() = default;

  DeepRecursion(int depth, const Mark& mark_, const std::string& msg_);

  // Returns the recursion depth when the exception was thrown
  int depth() const {
    return m_depth;
  }

private:
  int m_depth = 0;
};

/**
 * @brief The DepthGuard class
 *  DepthGuard takes a reference to an integer. It increments the integer upon
 * construction of DepthGuard and decrements the integer upon destruction.
 *
 * If the integer would be incremented past max_depth, then an exception is
 * thrown. This is ideally geared toward guarding against deep recursion.
 *
 * @param max_depth
 *  compile-time configurable maximum depth.
 */
template <int max_depth = 2000>
class DepthGuard final {
public:
  DepthGuard(int & depth_, const Mark& mark_, const std::string& msg_) : m_depth(depth_) {
    ++m_depth;
    if ( max_depth <= m_depth ) {
        throw DeepRecursion{m_depth, mark_, msg_};
    }
  }

  DepthGuard(const DepthGuard & copy_ctor) = delete;
  DepthGuard(DepthGuard && move_ctor) = delete;
  DepthGuard & operator=(const DepthGuard & copy_assign) = delete;
  DepthGuard & operator=(DepthGuard && move_assign) = delete;

  ~DepthGuard() {
    --m_depth;
  }

  int current_depth() const {
    return m_depth;
  }

private:
    int & m_depth;
};

} // namespace YAML

#endif // DEPTH_GUARD_H_00000000000000000000000000000000000000000000000000000000



================================================
FILE: Utils/yaml-cpp/dll.h
================================================
#ifndef DLL_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define DLL_H_62B23520_7C8E_11DE_8A39_0800200C9A66

// Definition YAML_CPP_STATIC_DEFINE using to building YAML-CPP as static
// library (definition created by CMake or defined manually)

// Definition yaml_cpp_EXPORTS using to building YAML-CPP as dll/so library
// (definition created by CMake or defined manually)

#ifdef YAML_CPP_STATIC_DEFINE
#  define YAML_CPP_API
#  define YAML_CPP_NO_EXPORT
#else
#  if defined(_MSC_VER) || defined(__MINGW32__) || defined(__MINGW64__)
#    ifndef YAML_CPP_API
#      ifdef yaml_cpp_EXPORTS
         /* We are building this library */
#        pragma message( "Defining YAML_CPP_API for DLL export" )
#        define YAML_CPP_API __declspec(dllexport)
#      else
         /* We are using this library */
#        pragma message( "Defining YAML_CPP_API for DLL import" )
#        define YAML_CPP_API //__declspec(dllimport)
#      endif
#    endif
#    ifndef YAML_CPP_NO_EXPORT
#      define YAML_CPP_NO_EXPORT
#    endif
#  else /* No _MSC_VER */
#    ifndef YAML_CPP_API
#      ifdef yaml_cpp_EXPORTS
         /* We are building this library */
#        define YAML_CPP_API __attribute__((visibility("default")))
#      else
         /* We are using this library */
#        define YAML_CPP_API __attribute__((visibility("default")))
#      endif
#    endif
#    ifndef YAML_CPP_NO_EXPORT
#      define YAML_CPP_NO_EXPORT __attribute__((visibility("hidden")))
#    endif
#  endif /* _MSC_VER */
#endif   /* YAML_CPP_STATIC_DEFINE */

#ifndef YAML_CPP_DEPRECATED
#  ifdef _MSC_VER
#    define YAML_CPP_DEPRECATED __declspec(deprecated)
#  else
#    define YAML_CPP_DEPRECATED __attribute__ ((__deprecated__))
#  endif
#endif

#ifndef YAML_CPP_DEPRECATED_EXPORT
#  define YAML_CPP_DEPRECATED_EXPORT YAML_CPP_API YAML_CPP_DEPRECATED
#endif

#ifndef YAML_CPP_DEPRECATED_NO_EXPORT
#  define YAML_CPP_DEPRECATED_NO_EXPORT YAML_CPP_NO_EXPORT YAML_CPP_DEPRECATED
#endif

#endif /* DLL_H_62B23520_7C8E_11DE_8A39_0800200C9A66 */



================================================
FILE: Utils/yaml-cpp/emitfromevents.h
================================================
#ifndef EMITFROMEVENTS_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EMITFROMEVENTS_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <stack>

#include "yaml-cpp/anchor.h"
#include "yaml-cpp/emitterstyle.h"
#include "yaml-cpp/eventhandler.h"

namespace YAML {
struct Mark;
}  // namespace YAML

namespace YAML {
class Emitter;

class EmitFromEvents : public EventHandler {
 public:
  EmitFromEvents(Emitter& emitter);

  void OnDocumentStart(const Mark& mark) override;
  void OnDocumentEnd() override;

  void OnNull(const Mark& mark, anchor_t anchor) override;
  void OnAlias(const Mark& mark, anchor_t anchor) override;
  void OnScalar(const Mark& mark, const std::string& tag,
                        anchor_t anchor, const std::string& value) override;

  void OnSequenceStart(const Mark& mark, const std::string& tag,
                               anchor_t anchor, EmitterStyle::value style) override;
  void OnSequenceEnd() override;

  void OnMapStart(const Mark& mark, const std::string& tag,
                          anchor_t anchor, EmitterStyle::value style) override;
  void OnMapEnd() override;

 private:
  void BeginNode();
  void EmitProps(const std::string& tag, anchor_t anchor);

 private:
  Emitter& m_emitter;

  struct State {
    enum value { WaitingForSequenceEntry, WaitingForKey, WaitingForValue };
  };
  std::stack<State::value> m_stateStack;
};
}

#endif  // EMITFROMEVENTS_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/emitter.h
================================================
﻿#ifndef EMITTER_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EMITTER_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <cmath>
#include <cstddef>
#include <limits>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>

#include "../yaml-cpp/binary.h"
#include "../yaml-cpp/dll.h"
#include "../yaml-cpp/emitterdef.h"
#include "../yaml-cpp/emittermanip.h"
#include "../yaml-cpp/null.h"
#include "../yaml-cpp/ostream_wrapper.h"

namespace YAML {
class Binary;
struct _Null;
}  // namespace YAML

namespace YAML {
class EmitterState;

class YAML_CPP_API Emitter {
 public:
  Emitter();
  explicit Emitter(std::ostream& stream);
  Emitter(const Emitter&) = delete;
  Emitter& operator=(const Emitter&) = delete;
  ~Emitter();

  // output
  const char* c_str() const;
  std::size_t size() const;

  // state checking
  bool good() const;
  const std::string GetLastError() const;

  // global setters
  bool SetOutputCharset(EMITTER_MANIP value);
  bool SetStringFormat(EMITTER_MANIP value);
  bool SetBoolFormat(EMITTER_MANIP value);
  bool SetNullFormat(EMITTER_MANIP value);
  bool SetIntBase(EMITTER_MANIP value);
  bool SetSeqFormat(EMITTER_MANIP value);
  bool SetMapFormat(EMITTER_MANIP value);
  bool SetIndent(std::size_t n);
  bool SetPreCommentIndent(std::size_t n);
  bool SetPostCommentIndent(std::size_t n);
  bool SetFloatPrecision(std::size_t n);
  bool SetDoublePrecision(std::size_t n);
  void RestoreGlobalModifiedSettings();

  // local setters
  Emitter& SetLocalValue(EMITTER_MANIP value);
  Emitter& SetLocalIndent(const _Indent& indent);
  Emitter& SetLocalPrecision(const _Precision& precision);

  // overloads of write
  Emitter& Write(const std::string& str);
  Emitter& Write(bool b);
  Emitter& Write(char ch);
  Emitter& Write(const _Alias& alias);
  Emitter& Write(const _Anchor& anchor);
  Emitter& Write(const _Tag& tag);
  Emitter& Write(const _Comment& comment);
  Emitter& Write(const _Null& n);
  Emitter& Write(const Binary& binary);

  template <typename T>
  Emitter& WriteIntegralType(T value);

  template <typename T>
  Emitter& WriteStreamable(T value);

 private:
  template <typename T>
  void SetStreamablePrecision(std::stringstream&) {}
  std::size_t GetFloatPrecision() const;
  std::size_t GetDoublePrecision() const;

  void PrepareIntegralStream(std::stringstream& stream) const;
  void StartedScalar();

 private:
  void EmitBeginDoc();
  void EmitEndDoc();
  void EmitBeginSeq();
  void EmitEndSeq();
  void EmitBeginMap();
  void EmitEndMap();
  void EmitNewline();
  void EmitKindTag();
  void EmitTag(bool verbatim, const _Tag& tag);

  void PrepareNode(EmitterNodeType::value child);
  void PrepareTopNode(EmitterNodeType::value child);
  void FlowSeqPrepareNode(EmitterNodeType::value child);
  void BlockSeqPrepareNode(EmitterNodeType::value child);

  void FlowMapPrepareNode(EmitterNodeType::value child);

  void FlowMapPrepareLongKey(EmitterNodeType::value child);
  void FlowMapPrepareLongKeyValue(EmitterNodeType::value child);
  void FlowMapPrepareSimpleKey(EmitterNodeType::value child);
  void FlowMapPrepareSimpleKeyValue(EmitterNodeType::value child);

  void BlockMapPrepareNode(EmitterNodeType::value child);

  void BlockMapPrepareLongKey(EmitterNodeType::value child);
  void BlockMapPrepareLongKeyValue(EmitterNodeType::value child);
  void BlockMapPrepareSimpleKey(EmitterNodeType::value child);
  void BlockMapPrepareSimpleKeyValue(EmitterNodeType::value child);

  void SpaceOrIndentTo(bool requireSpace, std::size_t indent);

  const char* ComputeFullBoolName(bool b) const;
  const char* ComputeNullName() const;
  bool CanEmitNewline() const;

 private:
  std::unique_ptr<EmitterState> m_pState;
  ostream_wrapper m_stream;
};

template <typename T>
inline Emitter& Emitter::WriteIntegralType(T value) {
  if (!good())
    return *this;

  PrepareNode(EmitterNodeType::Scalar);

  std::stringstream stream;
  PrepareIntegralStream(stream);
  stream << value;
  m_stream << stream.str();

  StartedScalar();

  return *this;
}

template <typename T>
inline Emitter& Emitter::WriteStreamable(T value) {
  if (!good())
    return *this;

  PrepareNode(EmitterNodeType::Scalar);

  std::stringstream stream;
  SetStreamablePrecision<T>(stream);

  bool special = false;
  if (std::is_floating_point<T>::value) {
    if ((std::numeric_limits<T>::has_quiet_NaN ||
         std::numeric_limits<T>::has_signaling_NaN) &&
        std::isnan(value)) {
      special = true;
      stream << ".nan";
    } else if (std::numeric_limits<T>::has_infinity && std::isinf(value)) {
      special = true;
      if (std::signbit(value)) {
        stream << "-.inf";
      } else {
        stream << ".inf";
      }
    }
  }

  if (!special) {
    stream << value;
  }
  m_stream << stream.str();

  StartedScalar();

  return *this;
}

template <>
inline void Emitter::SetStreamablePrecision<float>(std::stringstream& stream) {
  stream.precision(static_cast<std::streamsize>(GetFloatPrecision()));
}

template <>
inline void Emitter::SetStreamablePrecision<double>(std::stringstream& stream) {
  stream.precision(static_cast<std::streamsize>(GetDoublePrecision()));
}

// overloads of insertion
inline Emitter& operator<<(Emitter& emitter, const std::string& v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, bool v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, char v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, unsigned char v) {
  return emitter.Write(static_cast<char>(v));
}
inline Emitter& operator<<(Emitter& emitter, const _Alias& v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, const _Anchor& v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, const _Tag& v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, const _Comment& v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, const _Null& v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, const Binary& b) {
  return emitter.Write(b);
}

inline Emitter& operator<<(Emitter& emitter, const char* v) {
  return emitter.Write(std::string(v));
}

inline Emitter& operator<<(Emitter& emitter, int v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, unsigned int v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, short v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, unsigned short v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, long v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, unsigned long v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, long long v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, unsigned long long v) {
  return emitter.WriteIntegralType(v);
}

inline Emitter& operator<<(Emitter& emitter, float v) {
  return emitter.WriteStreamable(v);
}
inline Emitter& operator<<(Emitter& emitter, double v) {
  return emitter.WriteStreamable(v);
}

inline Emitter& operator<<(Emitter& emitter, EMITTER_MANIP value) {
  return emitter.SetLocalValue(value);
}

inline Emitter& operator<<(Emitter& emitter, _Indent indent) {
  return emitter.SetLocalIndent(indent);
}

inline Emitter& operator<<(Emitter& emitter, _Precision precision) {
  return emitter.SetLocalPrecision(precision);
}
}  // namespace YAML

#endif  // EMITTER_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/emitterdef.h
================================================
#ifndef EMITTERDEF_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EMITTERDEF_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

namespace YAML {
struct EmitterNodeType {
  enum value { NoType, Property, Scalar, FlowSeq, BlockSeq, FlowMap, BlockMap };
};
}

#endif  // EMITTERDEF_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/emittermanip.h
================================================
#ifndef EMITTERMANIP_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EMITTERMANIP_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <string>

namespace YAML {
enum EMITTER_MANIP {
  // general manipulators
  Auto,
  TagByKind,
  Newline,

  // output character set
  EmitNonAscii,
  EscapeNonAscii,
  EscapeAsJson,

  // string manipulators
  // Auto, // duplicate
  SingleQuoted,
  DoubleQuoted,
  Literal,

  // null manipulators
  LowerNull,
  UpperNull,
  CamelNull,
  TildeNull,

  // bool manipulators
  YesNoBool,      // yes, no
  TrueFalseBool,  // true, false
  OnOffBool,      // on, off
  UpperCase,      // TRUE, N
  LowerCase,      // f, yes
  CamelCase,      // No, Off
  LongBool,       // yes, On
  ShortBool,      // y, t

  // int manipulators
  Dec,
  Hex,
  Oct,

  // document manipulators
  BeginDoc,
  EndDoc,

  // sequence manipulators
  BeginSeq,
  EndSeq,
  Flow,
  Block,

  // map manipulators
  BeginMap,
  EndMap,
  Key,
  Value,
  // Flow, // duplicate
  // Block, // duplicate
  // Auto, // duplicate
  LongKey
};

struct _Indent {
  _Indent(int value_) : value(value_) {}
  int value;
};

inline _Indent Indent(int value) { return _Indent(value); }

struct _Alias {
  _Alias(const std::string& content_) : content(content_) {}
  std::string content;
};

inline _Alias Alias(const std::string& content) { return _Alias(content); }

struct _Anchor {
  _Anchor(const std::string& content_) : content(content_) {}
  std::string content;
};

inline _Anchor Anchor(const std::string& content) { return _Anchor(content); }

struct _Tag {
  struct Type {
    enum value { Verbatim, PrimaryHandle, NamedHandle };
  };

  explicit _Tag(const std::string& prefix_, const std::string& content_,
                Type::value type_)
      : prefix(prefix_), content(content_), type(type_) {}
  std::string prefix;
  std::string content;
  Type::value type;
};

inline _Tag VerbatimTag(const std::string& content) {
  return _Tag("", content, _Tag::Type::Verbatim);
}

inline _Tag LocalTag(const std::string& content) {
  return _Tag("", content, _Tag::Type::PrimaryHandle);
}

inline _Tag LocalTag(const std::string& prefix, const std::string content) {
  return _Tag(prefix, content, _Tag::Type::NamedHandle);
}

inline _Tag SecondaryTag(const std::string& content) {
  return _Tag("", content, _Tag::Type::NamedHandle);
}

struct _Comment {
  _Comment(const std::string& content_) : content(content_) {}
  std::string content;
};

inline _Comment Comment(const std::string& content) { return _Comment(content); }

struct _Precision {
  _Precision(int floatPrecision_, int doublePrecision_)
      : floatPrecision(floatPrecision_), doublePrecision(doublePrecision_) {}

  int floatPrecision;
  int doublePrecision;
};

inline _Precision FloatPrecision(int n) { return _Precision(n, -1); }

inline _Precision DoublePrecision(int n) { return _Precision(-1, n); }

inline _Precision Precision(int n) { return _Precision(n, n); }
}

#endif  // EMITTERMANIP_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/emitterstyle.h
================================================
#ifndef EMITTERSTYLE_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EMITTERSTYLE_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

namespace YAML {
struct EmitterStyle {
  enum value { Default, Block, Flow };
};
}

#endif  // EMITTERSTYLE_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/eventhandler.h
================================================
#ifndef EVENTHANDLER_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EVENTHANDLER_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <string>

#include "yaml-cpp/anchor.h"
#include "yaml-cpp/emitterstyle.h"

namespace YAML {
struct Mark;

class EventHandler {
 public:
  virtual ~EventHandler() = default;

  virtual void OnDocumentStart(const Mark& mark) = 0;
  virtual void OnDocumentEnd() = 0;

  virtual void OnNull(const Mark& mark, anchor_t anchor) = 0;
  virtual void OnAlias(const Mark& mark, anchor_t anchor) = 0;
  virtual void OnScalar(const Mark& mark, const std::string& tag,
                        anchor_t anchor, const std::string& value) = 0;

  virtual void OnSequenceStart(const Mark& mark, const std::string& tag,
                               anchor_t anchor, EmitterStyle::value style) = 0;
  virtual void OnSequenceEnd() = 0;

  virtual void OnMapStart(const Mark& mark, const std::string& tag,
                          anchor_t anchor, EmitterStyle::value style) = 0;
  virtual void OnMapEnd() = 0;

  virtual void OnAnchor(const Mark& /*mark*/,
                        const std::string& /*anchor_name*/) {
    // empty default implementation for compatibility
  }
};
}  // namespace YAML

#endif  // EVENTHANDLER_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/exceptions.h
================================================
﻿#ifndef EXCEPTIONS_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EXCEPTIONS_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "../yaml-cpp/mark.h"
#include "../yaml-cpp/noexcept.h"
#include "../yaml-cpp/traits.h"
#include <sstream>
#include <stdexcept>
#include <string>

namespace YAML {
// error messages
namespace ErrorMsg {
const char* const YAML_DIRECTIVE_ARGS =
    "YAML directives must have exactly one argument";
const char* const YAML_VERSION = "bad YAML version: ";
const char* const YAML_MAJOR_VERSION = "YAML major version too large";
const char* const REPEATED_YAML_DIRECTIVE = "repeated YAML directive";
const char* const TAG_DIRECTIVE_ARGS =
    "TAG directives must have exactly two arguments";
const char* const REPEATED_TAG_DIRECTIVE = "repeated TAG directive";
const char* const CHAR_IN_TAG_HANDLE =
    "illegal character found while scanning tag handle";
const char* const TAG_WITH_NO_SUFFIX = "tag handle with no suffix";
const char* const END_OF_VERBATIM_TAG = "end of verbatim tag not found";
const char* const END_OF_MAP = "end of map not found";
const char* const END_OF_MAP_FLOW = "end of map flow not found";
const char* const END_OF_SEQ = "end of sequence not found";
const char* const END_OF_SEQ_FLOW = "end of sequence flow not found";
const char* const MULTIPLE_TAGS =
    "cannot assign multiple tags to the same node";
const char* const MULTIPLE_ANCHORS =
    "cannot assign multiple anchors to the same node";
const char* const MULTIPLE_ALIASES =
    "cannot assign multiple aliases to the same node";
const char* const ALIAS_CONTENT =
    "aliases can't have any content, *including* tags";
const char* const INVALID_HEX = "bad character found while scanning hex number";
const char* const INVALID_UNICODE = "invalid unicode: ";
const char* const INVALID_ESCAPE = "unknown escape character: ";
const char* const UNKNOWN_TOKEN = "unknown token";
const char* const DOC_IN_SCALAR = "illegal document indicator in scalar";
const char* const EOF_IN_SCALAR = "illegal EOF in scalar";
const char* const CHAR_IN_SCALAR = "illegal character in scalar";
const char* const TAB_IN_INDENTATION =
    "illegal tab when looking for indentation";
const char* const FLOW_END = "illegal flow end";
const char* const BLOCK_ENTRY = "illegal block entry";
const char* const MAP_KEY = "illegal map key";
const char* const MAP_VALUE = "illegal map value";
const char* const ALIAS_NOT_FOUND = "alias not found after *";
const char* const ANCHOR_NOT_FOUND = "anchor not found after &";
const char* const CHAR_IN_ALIAS =
    "illegal character found while scanning alias";
const char* const CHAR_IN_ANCHOR =
    "illegal character found while scanning anchor";
const char* const ZERO_INDENT_IN_BLOCK =
    "cannot set zero indentation for a block scalar";
const char* const CHAR_IN_BLOCK = "unexpected character in block scalar";
const char* const AMBIGUOUS_ANCHOR =
    "cannot assign the same alias to multiple nodes";
const char* const UNKNOWN_ANCHOR = "the referenced anchor is not defined: ";

const char* const INVALID_NODE =
    "invalid node; this may result from using a map iterator as a sequence "
    "iterator, or vice-versa";
const char* const INVALID_SCALAR = "invalid scalar";
const char* const KEY_NOT_FOUND = "key not found";
const char* const BAD_CONVERSION = "bad conversion";
const char* const BAD_DEREFERENCE = "bad dereference";
const char* const BAD_SUBSCRIPT = "operator[] call on a scalar";
const char* const BAD_PUSHBACK = "appending to a non-sequence";
const char* const BAD_INSERT = "inserting in a non-convertible-to-map";

const char* const UNMATCHED_GROUP_TAG = "unmatched group tag";
const char* const UNEXPECTED_END_SEQ = "unexpected end sequence token";
const char* const UNEXPECTED_END_MAP = "unexpected end map token";
const char* const SINGLE_QUOTED_CHAR =
    "invalid character in single-quoted string";
const char* const INVALID_ANCHOR = "invalid anchor";
const char* const INVALID_ALIAS = "invalid alias";
const char* const INVALID_TAG = "invalid tag";
const char* const BAD_FILE = "bad file";

template <typename T>
inline const std::string KEY_NOT_FOUND_WITH_KEY(
    const T&, typename disable_if<is_numeric<T>>::type* = 0) {
  return KEY_NOT_FOUND;
}

inline const std::string KEY_NOT_FOUND_WITH_KEY(const std::string& key) {
  std::stringstream stream;
  stream << KEY_NOT_FOUND << ": " << key;
  return stream.str();
}

inline const std::string KEY_NOT_FOUND_WITH_KEY(const char* key) {
  std::stringstream stream;
  stream << KEY_NOT_FOUND << ": " << key;
  return stream.str();
}

template <typename T>
inline const std::string KEY_NOT_FOUND_WITH_KEY(
    const T& key, typename enable_if<is_numeric<T>>::type* = 0) {
  std::stringstream stream;
  stream << KEY_NOT_FOUND << ": " << key;
  return stream.str();
}

template <typename T>
inline const std::string BAD_SUBSCRIPT_WITH_KEY(
    const T&, typename disable_if<is_numeric<T>>::type* = nullptr) {
  return BAD_SUBSCRIPT;
}

inline const std::string BAD_SUBSCRIPT_WITH_KEY(const std::string& key) {
  std::stringstream stream;
  stream << BAD_SUBSCRIPT << " (key: \"" << key << "\")";
  return stream.str();
}

inline const std::string BAD_SUBSCRIPT_WITH_KEY(const char* key) {
  std::stringstream stream;
  stream << BAD_SUBSCRIPT << " (key: \"" << key << "\")";
  return stream.str();
}

template <typename T>
inline const std::string BAD_SUBSCRIPT_WITH_KEY(
    const T& key, typename enable_if<is_numeric<T>>::type* = nullptr) {
  std::stringstream stream;
  stream << BAD_SUBSCRIPT << " (key: \"" << key << "\")";
  return stream.str();
}

inline const std::string INVALID_NODE_WITH_KEY(const std::string& key) {
  std::stringstream stream;
  if (key.empty()) {
    return INVALID_NODE;
  }
  stream << "invalid node; first invalid key: \"" << key << "\"";
  return stream.str();
}
}  // namespace ErrorMsg

class YAML_CPP_API Exception : public std::runtime_error {
 public:
  Exception(const Mark& mark_, const std::string& msg_)
      : std::runtime_error(build_what(mark_, msg_)), mark(mark_), msg(msg_) {}
  ~Exception() YAML_CPP_NOEXCEPT override;

  Exception(const Exception&) = default;

  Mark mark;
  std::string msg;

 private:
  static const std::string build_what(const Mark& mark,
                                      const std::string& msg) {
    if (mark.is_null()) {
      return msg;
    }

    std::stringstream output;
    output << "yaml-cpp: error at line " << mark.line + 1 << ", column "
           << mark.column + 1 << ": " << msg;
    return output.str();
  }
};

class YAML_CPP_API ParserException : public Exception {
 public:
  ParserException(const Mark& mark_, const std::string& msg_)
      : Exception(mark_, msg_) {}
  ParserException(const ParserException&) = default;
  ~ParserException() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API RepresentationException : public Exception {
 public:
  RepresentationException(const Mark& mark_, const std::string& msg_)
      : Exception(mark_, msg_) {}
  RepresentationException(const RepresentationException&) = default;
  ~RepresentationException() YAML_CPP_NOEXCEPT override;
};

// representation exceptions
class YAML_CPP_API InvalidScalar : public RepresentationException {
 public:
  InvalidScalar(const Mark& mark_)
      : RepresentationException(mark_, ErrorMsg::INVALID_SCALAR) {}
  InvalidScalar(const InvalidScalar&) = default;
  ~InvalidScalar() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API KeyNotFound : public RepresentationException {
 public:
  template <typename T>
  KeyNotFound(const Mark& mark_, const T& key_)
      : RepresentationException(mark_, ErrorMsg::KEY_NOT_FOUND_WITH_KEY(key_)) {
  }
  KeyNotFound(const KeyNotFound&) = default;
  ~KeyNotFound() YAML_CPP_NOEXCEPT override;
};

template <typename T>
class YAML_CPP_API TypedKeyNotFound : public KeyNotFound {
 public:
  TypedKeyNotFound(const Mark& mark_, const T& key_)
      : KeyNotFound(mark_, key_), key(key_) {}
  ~TypedKeyNotFound() YAML_CPP_NOEXCEPT override = default;

  T key;
};

template <typename T>
inline TypedKeyNotFound<T> MakeTypedKeyNotFound(const Mark& mark,
                                                const T& key) {
  return TypedKeyNotFound<T>(mark, key);
}

class YAML_CPP_API InvalidNode : public RepresentationException {
 public:
  InvalidNode(const std::string& key)
      : RepresentationException(Mark::null_mark(),
                                ErrorMsg::INVALID_NODE_WITH_KEY(key)) {}
  InvalidNode(const InvalidNode&) = default;
  ~InvalidNode() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API BadConversion : public RepresentationException {
 public:
  explicit BadConversion(const Mark& mark_)
      : RepresentationException(mark_, ErrorMsg::BAD_CONVERSION) {}
  BadConversion(const BadConversion&) = default;
  ~BadConversion() YAML_CPP_NOEXCEPT override;
};

template <typename T>
class TypedBadConversion : public BadConversion {
 public:
  explicit TypedBadConversion(const Mark& mark_) : BadConversion(mark_) {}
};

class YAML_CPP_API BadDereference : public RepresentationException {
 public:
  BadDereference()
      : RepresentationException(Mark::null_mark(), ErrorMsg::BAD_DEREFERENCE) {}
  BadDereference(const BadDereference&) = default;
  ~BadDereference() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API BadSubscript : public RepresentationException {
 public:
  template <typename Key>
  BadSubscript(const Mark& mark_, const Key& key)
      : RepresentationException(mark_, ErrorMsg::BAD_SUBSCRIPT_WITH_KEY(key)) {}
  BadSubscript(const BadSubscript&) = default;
  ~BadSubscript() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API BadPushback : public RepresentationException {
 public:
  BadPushback()
      : RepresentationException(Mark::null_mark(), ErrorMsg::BAD_PUSHBACK) {}
  BadPushback(const BadPushback&) = default;
  ~BadPushback() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API BadInsert : public RepresentationException {
 public:
  BadInsert()
      : RepresentationException(Mark::null_mark(), ErrorMsg::BAD_INSERT) {}
  BadInsert(const BadInsert&) = default;
  ~BadInsert() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API EmitterException : public Exception {
 public:
  EmitterException(const std::string& msg_)
      : Exception(Mark::null_mark(), msg_) {}
  EmitterException(const EmitterException&) = default;
  ~EmitterException() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API BadFile : public Exception {
 public:
  explicit BadFile(const std::string& filename)
      : Exception(Mark::null_mark(),
                  std::string(ErrorMsg::BAD_FILE) + ": " + filename) {}
  BadFile(const BadFile&) = default;
  ~BadFile() YAML_CPP_NOEXCEPT override;
};
}  // namespace YAML

#endif  // EXCEPTIONS_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/mark.h
================================================
﻿#ifndef MARK_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define MARK_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "../yaml-cpp/dll.h"

namespace YAML {
struct YAML_CPP_API Mark {
  Mark() : pos(0), line(0), column(0) {}

  static const Mark null_mark() { return Mark(-1, -1, -1); }

  bool is_null() const { return pos == -1 && line == -1 && column == -1; }

  int pos;
  int line, column;

 private:
  Mark(int pos_, int line_, int column_)
      : pos(pos_), line(line_), column(column_) {}
};
}

#endif  // MARK_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/noexcept.h
================================================
#ifndef NOEXCEPT_H_768872DA_476C_11EA_88B8_90B11C0C0FF8
#define NOEXCEPT_H_768872DA_476C_11EA_88B8_90B11C0C0FF8

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

// This is here for compatibility with older versions of Visual Studio
// which don't support noexcept.
#if defined(_MSC_VER) && _MSC_VER < 1900
    #define YAML_CPP_NOEXCEPT _NOEXCEPT
#else
    #define YAML_CPP_NOEXCEPT noexcept
#endif

#endif



================================================
FILE: Utils/yaml-cpp/null.h
================================================
﻿#ifndef NULL_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NULL_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "../yaml-cpp/dll.h"
#include <string>

namespace YAML {
class Node;

struct YAML_CPP_API _Null {};
inline bool operator==(const _Null&, const _Null&) { return true; }
inline bool operator!=(const _Null&, const _Null&) { return false; }

YAML_CPP_API bool IsNull(const Node& node);  // old API only
YAML_CPP_API bool IsNullString(const std::string& str);

extern YAML_CPP_API _Null Null;
}

#endif  // NULL_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/ostream_wrapper.h
================================================
﻿#ifndef OSTREAM_WRAPPER_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define OSTREAM_WRAPPER_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <string>
#include <vector>

#include "../yaml-cpp/dll.h"

namespace YAML {
class YAML_CPP_API ostream_wrapper {
 public:
  ostream_wrapper();
  explicit ostream_wrapper(std::ostream& stream);
  ostream_wrapper(const ostream_wrapper&) = delete;
  ostream_wrapper(ostream_wrapper&&) = delete;
  ostream_wrapper& operator=(const ostream_wrapper&) = delete;
  ostream_wrapper& operator=(ostream_wrapper&&) = delete;
  ~ostream_wrapper();

  void write(const std::string& str);
  void write(const char* str, std::size_t size);

  void set_comment() { m_comment = true; }

  const char* str() const {
    if (m_pStream) {
      return nullptr;
    } else {
      m_buffer[m_pos] = '\0';
      return &m_buffer[0];
    }
  }

  std::size_t row() const { return m_row; }
  std::size_t col() const { return m_col; }
  std::size_t pos() const { return m_pos; }
  bool comment() const { return m_comment; }

 private:
  void update_pos(char ch);

 private:
  mutable std::vector<char> m_buffer;
  std::ostream* const m_pStream;

  std::size_t m_pos;
  std::size_t m_row, m_col;
  bool m_comment;
};

template <std::size_t N>
inline ostream_wrapper& operator<<(ostream_wrapper& stream,
                                   const char (&str)[N]) {
  stream.write(str, N - 1);
  return stream;
}

inline ostream_wrapper& operator<<(ostream_wrapper& stream,
                                   const std::string& str) {
  stream.write(str);
  return stream;
}

inline ostream_wrapper& operator<<(ostream_wrapper& stream, char ch) {
  stream.write(&ch, 1);
  return stream;
}
}  // namespace YAML

#endif  // OSTREAM_WRAPPER_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/parser.h
================================================
﻿#ifndef PARSER_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define PARSER_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <ios>
#include <memory>

#include "../yaml-cpp/dll.h"

namespace YAML {
class EventHandler;
class Node;
class Scanner;
struct Directives;
struct Token;

/**
 * A parser turns a stream of bytes into one stream of "events" per YAML
 * document in the input stream.
 */
class YAML_CPP_API Parser {
 public:
  /** Constructs an empty parser (with no input. */
  Parser();

  Parser(const Parser&) = delete;
  Parser(Parser&&) = delete;
  Parser& operator=(const Parser&) = delete;
  Parser& operator=(Parser&&) = delete;

  /**
   * Constructs a parser from the given input stream. The input stream must
   * live as long as the parser.
   */
  explicit Parser(std::istream& in);

  ~Parser();

  /** Evaluates to true if the parser has some valid input to be read. */
  explicit operator bool() const;

  /**
   * Resets the parser with the given input stream. Any existing state is
   * erased.
   */
  void Load(std::istream& in);

  /**
   * Handles the next document by calling events on the {@code eventHandler}.
   *
   * @throw a ParserException on error.
   * @return false if there are no more documents
   */
  bool HandleNextDocument(EventHandler& eventHandler);

  void PrintTokens(std::ostream& out);

 private:
  /**
   * Reads any directives that are next in the queue, setting the internal
   * {@code m_pDirectives} state.
   */
  void ParseDirectives();

  void HandleDirective(const Token& token);

  /**
   * Handles a "YAML" directive, which should be of the form 'major.minor' (like
   * a version number).
   */
  void HandleYamlDirective(const Token& token);

  /**
   * Handles a "TAG" directive, which should be of the form 'handle prefix',
   * where 'handle' is converted to 'prefix' in the file.
   */
  void HandleTagDirective(const Token& token);

 private:
  std::unique_ptr<Scanner> m_pScanner;
  std::unique_ptr<Directives> m_pDirectives;
};
}  // namespace YAML

#endif  // PARSER_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/stlemitter.h
================================================
#ifndef STLEMITTER_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define STLEMITTER_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <vector>
#include <list>
#include <set>
#include <map>

namespace YAML {
template <typename Seq>
inline Emitter& EmitSeq(Emitter& emitter, const Seq& seq) {
  emitter << BeginSeq;
  for (const auto& v : seq)
    emitter << v;
  emitter << EndSeq;
  return emitter;
}

template <typename T>
inline Emitter& operator<<(Emitter& emitter, const std::vector<T>& v) {
  return EmitSeq(emitter, v);
}

template <typename T>
inline Emitter& operator<<(Emitter& emitter, const std::list<T>& v) {
  return EmitSeq(emitter, v);
}

template <typename T>
inline Emitter& operator<<(Emitter& emitter, const std::set<T>& v) {
  return EmitSeq(emitter, v);
}

template <typename K, typename V>
inline Emitter& operator<<(Emitter& emitter, const std::map<K, V>& m) {
  emitter << BeginMap;
  for (const auto& v : m)
    emitter << Key << v.first << Value << v.second;
  emitter << EndMap;
  return emitter;
}
}

#endif  // STLEMITTER_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/traits.h
================================================
#ifndef TRAITS_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define TRAITS_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <type_traits>
#include <utility>
#include <string>
#include <sstream>

namespace YAML {
template <typename>
struct is_numeric {
  enum { value = false };
};

template <>
struct is_numeric<char> {
  enum { value = true };
};
template <>
struct is_numeric<unsigned char> {
  enum { value = true };
};
template <>
struct is_numeric<int> {
  enum { value = true };
};
template <>
struct is_numeric<unsigned int> {
  enum { value = true };
};
template <>
struct is_numeric<long int> {
  enum { value = true };
};
template <>
struct is_numeric<unsigned long int> {
  enum { value = true };
};
template <>
struct is_numeric<short int> {
  enum { value = true };
};
template <>
struct is_numeric<unsigned short int> {
  enum { value = true };
};
#if defined(_MSC_VER) && (_MSC_VER < 1310)
template <>
struct is_numeric<__int64> {
  enum { value = true };
};
template <>
struct is_numeric<unsigned __int64> {
  enum { value = true };
};
#else
template <>
struct is_numeric<long long> {
  enum { value = true };
};
template <>
struct is_numeric<unsigned long long> {
  enum { value = true };
};
#endif
template <>
struct is_numeric<float> {
  enum { value = true };
};
template <>
struct is_numeric<double> {
  enum { value = true };
};
template <>
struct is_numeric<long double> {
  enum { value = true };
};

template <bool, class T = void>
struct enable_if_c {
  using type = T;
};

template <class T>
struct enable_if_c<false, T> {};

template <class Cond, class T = void>
struct enable_if : public enable_if_c<Cond::value, T> {};

template <bool, class T = void>
struct disable_if_c {
  using type = T;
};

template <class T>
struct disable_if_c<true, T> {};

template <class Cond, class T = void>
struct disable_if : public disable_if_c<Cond::value, T> {};
}

template <typename S, typename T>
struct is_streamable {
  template <typename StreamT, typename ValueT>
  static auto test(int)
      -> decltype(std::declval<StreamT&>() << std::declval<ValueT>(), std::true_type());

  template <typename, typename>
  static auto test(...) -> std::false_type;

  static const bool value = decltype(test<S, T>(0))::value;
};

template<typename Key, bool Streamable>
struct streamable_to_string {
  static std::string impl(const Key& key) {
    std::stringstream ss;
    ss << key;
    return ss.str();
  }
};

template<typename Key>
struct streamable_to_string<Key, false> {
  static std::string impl(const Key&) {
    return "";
  }
};
#endif  // TRAITS_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/yaml.h
================================================
﻿#ifndef YAML_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define YAML_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "../yaml-cpp/parser.h"
#include "../yaml-cpp/emitter.h"
#include "../yaml-cpp/emitterstyle.h"
#include "../yaml-cpp/stlemitter.h"
#include "../yaml-cpp/exceptions.h"

#include "../yaml-cpp/node/node.h"
#include "../yaml-cpp/node/impl.h"
#include "../yaml-cpp/node/convert.h"
#include "../yaml-cpp/node/iterator.h"
#include "../yaml-cpp/node/detail/impl.h"
#include "../yaml-cpp/node/parse.h"
#include "../yaml-cpp/node/emit.h"

#endif  // YAML_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/contrib/anchordict.h
================================================
#ifndef ANCHORDICT_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define ANCHORDICT_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <vector>

#include "../anchor.h"

namespace YAML {
/**
 * An object that stores and retrieves values correlating to {@link anchor_t}
 * values.
 *
 * <p>Efficient implementation that can make assumptions about how
 * {@code anchor_t} values are assigned by the {@link Parser} class.
 */
template <class T>
class AnchorDict {
 public:
  AnchorDict() : m_data{} {}
  void Register(anchor_t anchor, T value) {
    if (anchor > m_data.size()) {
      m_data.resize(anchor);
    }
    m_data[anchor - 1] = value;
  }

  T Get(anchor_t anchor) const { return m_data[anchor - 1]; }

 private:
  std::vector<T> m_data;
};
}  // namespace YAML

#endif  // ANCHORDICT_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/contrib/graphbuilder.h
================================================
#ifndef GRAPHBUILDER_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define GRAPHBUILDER_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/mark.h"
#include <string>

namespace YAML {
class Parser;

// GraphBuilderInterface
// . Abstraction of node creation
// . pParentNode is always nullptr or the return value of one of the NewXXX()
//   functions.
class GraphBuilderInterface {
 public:
  virtual ~GraphBuilderInterface() = 0;

  // Create and return a new node with a null value.
  virtual void *NewNull(const Mark &mark, void *pParentNode) = 0;

  // Create and return a new node with the given tag and value.
  virtual void *NewScalar(const Mark &mark, const std::string &tag,
                          void *pParentNode, const std::string &value) = 0;

  // Create and return a new sequence node
  virtual void *NewSequence(const Mark &mark, const std::string &tag,
                            void *pParentNode) = 0;

  // Add pNode to pSequence.  pNode was created with one of the NewXxx()
  // functions and pSequence with NewSequence().
  virtual void AppendToSequence(void *pSequence, void *pNode) = 0;

  // Note that no moew entries will be added to pSequence
  virtual void SequenceComplete(void *pSequence) { (void)pSequence; }

  // Create and return a new map node
  virtual void *NewMap(const Mark &mark, const std::string &tag,
                       void *pParentNode) = 0;

  // Add the pKeyNode => pValueNode mapping to pMap.  pKeyNode and pValueNode
  // were created with one of the NewXxx() methods and pMap with NewMap().
  virtual void AssignInMap(void *pMap, void *pKeyNode, void *pValueNode) = 0;

  // Note that no more assignments will be made in pMap
  virtual void MapComplete(void *pMap) { (void)pMap; }

  // Return the node that should be used in place of an alias referencing
  // pNode (pNode by default)
  virtual void *AnchorReference(const Mark &mark, void *pNode) {
    (void)mark;
    return pNode;
  }
};

// Typesafe wrapper for GraphBuilderInterface.  Assumes that Impl defines
// Node, Sequence, and Map types.  Sequence and Map must derive from Node
// (unless Node is defined as void).  Impl must also implement function with
// all of the same names as the virtual functions in GraphBuilderInterface
// -- including the ones with default implementations -- but with the
// prototypes changed to accept an explicit Node*, Sequence*, or Map* where
// appropriate.
template <class Impl>
class GraphBuilder : public GraphBuilderInterface {
 public:
  typedef typename Impl::Node Node;
  typedef typename Impl::Sequence Sequence;
  typedef typename Impl::Map Map;

  GraphBuilder(Impl &impl) : m_impl(impl) {
    Map *pMap = nullptr;
    Sequence *pSeq = nullptr;
    Node *pNode = nullptr;

    // Type consistency checks
    pNode = pMap;
    pNode = pSeq;
  }

  GraphBuilderInterface &AsBuilderInterface() { return *this; }

  virtual void *NewNull(const Mark &mark, void *pParentNode) {
    return CheckType<Node>(m_impl.NewNull(mark, AsNode(pParentNode)));
  }

  virtual void *NewScalar(const Mark &mark, const std::string &tag,
                          void *pParentNode, const std::string &value) {
    return CheckType<Node>(
        m_impl.NewScalar(mark, tag, AsNode(pParentNode), value));
  }

  virtual void *NewSequence(const Mark &mark, const std::string &tag,
                            void *pParentNode) {
    return CheckType<Sequence>(
        m_impl.NewSequence(mark, tag, AsNode(pParentNode)));
  }
  virtual void AppendToSequence(void *pSequence, void *pNode) {
    m_impl.AppendToSequence(AsSequence(pSequence), AsNode(pNode));
  }
  virtual void SequenceComplete(void *pSequence) {
    m_impl.SequenceComplete(AsSequence(pSequence));
  }

  virtual void *NewMap(const Mark &mark, const std::string &tag,
                       void *pParentNode) {
    return CheckType<Map>(m_impl.NewMap(mark, tag, AsNode(pParentNode)));
  }
  virtual void AssignInMap(void *pMap, void *pKeyNode, void *pValueNode) {
    m_impl.AssignInMap(AsMap(pMap), AsNode(pKeyNode), AsNode(pValueNode));
  }
  virtual void MapComplete(void *pMap) { m_impl.MapComplete(AsMap(pMap)); }

  virtual void *AnchorReference(const Mark &mark, void *pNode) {
    return CheckType<Node>(m_impl.AnchorReference(mark, AsNode(pNode)));
  }

 private:
  Impl &m_impl;

  // Static check for pointer to T
  template <class T, class U>
  static T *CheckType(U *p) {
    return p;
  }

  static Node *AsNode(void *pNode) { return static_cast<Node *>(pNode); }
  static Sequence *AsSequence(void *pSeq) {
    return static_cast<Sequence *>(pSeq);
  }
  static Map *AsMap(void *pMap) { return static_cast<Map *>(pMap); }
};

void *BuildGraphOfNextDocument(Parser &parser,
                               GraphBuilderInterface &graphBuilder);

template <class Impl>
typename Impl::Node *BuildGraphOfNextDocument(Parser &parser, Impl &impl) {
  GraphBuilder<Impl> graphBuilder(impl);
  return static_cast<typename Impl::Node *>(
      BuildGraphOfNextDocument(parser, graphBuilder));
}
}

#endif  // GRAPHBUILDER_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/convert.h
================================================
﻿#ifndef NODE_CONVERT_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NODE_CONVERT_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <array>
#include <cmath>
#include <limits>
#include <list>
#include <map>
#include <unordered_map>
#include <sstream>
#include <type_traits>
#include <valarray>
#include <vector>

#if __cplusplus >= 201703L
#include <string_view>
#endif

#include "../binary.h"
#include "../node/impl.h"
#include "../node/iterator.h"
#include "../node/node.h"
#include "../node/type.h"
#include "../null.h"


namespace YAML {
class Binary;
struct _Null;
template <typename T>
struct convert;
}  // namespace YAML

namespace YAML {
namespace conversion {
inline bool IsInfinity(const std::string& input) {
  return input == ".inf" || input == ".Inf" || input == ".INF" ||
         input == "+.inf" || input == "+.Inf" || input == "+.INF";
}

inline bool IsNegativeInfinity(const std::string& input) {
  return input == "-.inf" || input == "-.Inf" || input == "-.INF";
}

inline bool IsNaN(const std::string& input) {
  return input == ".nan" || input == ".NaN" || input == ".NAN";
}
}

// Node
template <>
struct convert<Node> {
  static Node encode(const Node& rhs) { return rhs; }

  static bool decode(const Node& node, Node& rhs) {
    rhs.reset(node);
    return true;
  }
};

// std::string
template <>
struct convert<std::string> {
  static Node encode(const std::string& rhs) { return Node(rhs); }

  static bool decode(const Node& node, std::string& rhs) {
    if (!node.IsScalar())
      return false;
    rhs = node.Scalar();
    return true;
  }
};

// C-strings can only be encoded
template <>
struct convert<const char*> {
  static Node encode(const char* rhs) { return Node(rhs); }
};

template <>
struct convert<char*> {
  static Node encode(const char* rhs) { return Node(rhs); }
};

template <std::size_t N>
struct convert<char[N]> {
  static Node encode(const char* rhs) { return Node(rhs); }
};

#if __cplusplus >= 201703L
template <>
struct convert<std::string_view> {
  static Node encode(std::string_view rhs) { return Node(std::string(rhs)); }

  static bool decode(const Node& node, std::string_view& rhs) {
    if (!node.IsScalar())
      return false;
    rhs = node.Scalar();
    return true;
  }
};
#endif

template <>
struct convert<_Null> {
  static Node encode(const _Null& /* rhs */) { return Node(); }

  static bool decode(const Node& node, _Null& /* rhs */) {
    return node.IsNull();
  }
};

namespace conversion {
template <typename T>
typename std::enable_if< std::is_floating_point<T>::value, void>::type
inner_encode(const T& rhs, std::stringstream& stream){
  if (std::isnan(rhs)) {
    stream << ".nan";
  } else if (std::isinf(rhs)) {
    if (std::signbit(rhs)) {
      stream << "-.inf";
    } else {
      stream << ".inf";
    }
  } else {
    stream << rhs;
  }
}

template <typename T>
typename std::enable_if<!std::is_floating_point<T>::value, void>::type
inner_encode(const T& rhs, std::stringstream& stream){
  stream << rhs;
}

template <typename T>
typename std::enable_if<(std::is_same<T, unsigned char>::value ||
                         std::is_same<T, signed char>::value), bool>::type
ConvertStreamTo(std::stringstream& stream, T& rhs) {
  int num;
  if ((stream >> std::noskipws >> num) && (stream >> std::ws).eof()) {
    if (num >= (std::numeric_limits<T>::min)() &&
        num <= (std::numeric_limits<T>::max)()) {
      rhs = static_cast<T>(num);
      return true;
    }
  }
  return false;
}

template <typename T>
typename std::enable_if<!(std::is_same<T, unsigned char>::value ||
                          std::is_same<T, signed char>::value), bool>::type
ConvertStreamTo(std::stringstream& stream, T& rhs) {
  if ((stream >> std::noskipws >> rhs) && (stream >> std::ws).eof()) {
    return true;
  }
  return false;
}
}

#define YAML_DEFINE_CONVERT_STREAMABLE(type, negative_op)                  \
  template <>                                                              \
  struct convert<type> {                                                   \
                                                                           \
    static Node encode(const type& rhs) {                                  \
      std::stringstream stream;                                            \
      stream.precision(std::numeric_limits<type>::max_digits10);           \
      conversion::inner_encode(rhs, stream);                               \
      return Node(stream.str());                                           \
    }                                                                      \
                                                                           \
    static bool decode(const Node& node, type& rhs) {                      \
      if (node.Type() != NodeType::Scalar) {                               \
        return false;                                                      \
      }                                                                    \
      const std::string& input = node.Scalar();                            \
      std::stringstream stream(input);                                     \
      stream.unsetf(std::ios::dec);                                        \
      if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
        return false;                                                      \
      }                                                                    \
      if (conversion::ConvertStreamTo(stream, rhs)) {                      \
        return true;                                                       \
      }                                                                    \
      if (std::numeric_limits<type>::has_infinity) {                       \
        if (conversion::IsInfinity(input)) {                               \
          rhs = std::numeric_limits<type>::infinity();                     \
          return true;                                                     \
        } else if (conversion::IsNegativeInfinity(input)) {                \
          rhs = negative_op std::numeric_limits<type>::infinity();         \
          return true;                                                     \
        }                                                                  \
      }                                                                    \
                                                                           \
      if (std::numeric_limits<type>::has_quiet_NaN) {                      \
        if (conversion::IsNaN(input)) {                                    \
          rhs = std::numeric_limits<type>::quiet_NaN();                    \
          return true;                                                     \
        }                                                                  \
      }                                                                    \
                                                                           \
      return false;                                                        \
    }                                                                      \
  }

#define YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(type) \
  YAML_DEFINE_CONVERT_STREAMABLE(type, -)

#define YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(type) \
  YAML_DEFINE_CONVERT_STREAMABLE(type, +)

YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(int);
YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(short);
YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long);
YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long long);
YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned);
YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned short);
YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned long);
YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned long long);

YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(char);
YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(signed char);
YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned char);

YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(float);
YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(double);
YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long double);

#undef YAML_DEFINE_CONVERT_STREAMABLE_SIGNED
#undef YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED
#undef YAML_DEFINE_CONVERT_STREAMABLE

// bool
template <>
struct convert<bool> {
  static Node encode(bool rhs) { return rhs ? Node("true") : Node("false"); }

  YAML_CPP_API static bool decode(const Node& node, bool& rhs);
};

// std::map
template <typename K, typename V, typename C, typename A>
struct convert<std::map<K, V, C, A>> {
  static Node encode(const std::map<K, V, C, A>& rhs) {
    Node node(NodeType::Map);
    for (const auto& element : rhs)
      node.force_insert(element.first, element.second);
    return node;
  }

  static bool decode(const Node& node, std::map<K, V, C, A>& rhs) {
    if (!node.IsMap())
      return false;

    rhs.clear();
    for (const auto& element : node)
#if defined(__GNUC__) && __GNUC__ < 4
      // workaround for GCC 3:
      rhs[element.first.template as<K>()] = element.second.template as<V>();
#else
      rhs[element.first.as<K>()] = element.second.as<V>();
#endif
    return true;
  }
};

// std::unordered_map
template <typename K, typename V, typename H, typename P, typename A>
struct convert<std::unordered_map<K, V, H, P, A>> {
  static Node encode(const std::unordered_map<K, V, H, P, A>& rhs) {
    Node node(NodeType::Map);
    for (const auto& element : rhs)
      node.force_insert(element.first, element.second);
    return node;
  }

  static bool decode(const Node& node, std::unordered_map<K, V, H, P, A>& rhs) {
    if (!node.IsMap())
      return false;

    rhs.clear();
    for (const auto& element : node)
#if defined(__GNUC__) && __GNUC__ < 4
      // workaround for GCC 3:
      rhs[element.first.template as<K>()] = element.second.template as<V>();
#else
      rhs[element.first.as<K>()] = element.second.as<V>();
#endif
    return true;
  }
};

// std::vector
template <typename T, typename A>
struct convert<std::vector<T, A>> {
  static Node encode(const std::vector<T, A>& rhs) {
    Node node(NodeType::Sequence);
    for (const auto& element : rhs)
      node.push_back(element);
    return node;
  }

  static bool decode(const Node& node, std::vector<T, A>& rhs) {
    if (!node.IsSequence())
      return false;

    rhs.clear();
    for (const auto& element : node)
#if defined(__GNUC__) && __GNUC__ < 4
      // workaround for GCC 3:
      rhs.push_back(element.template as<T>());
#else
      rhs.push_back(element.as<T>());
#endif
    return true;
  }
};

// std::list
template <typename T, typename A>
struct convert<std::list<T,A>> {
  static Node encode(const std::list<T,A>& rhs) {
    Node node(NodeType::Sequence);
    for (const auto& element : rhs)
      node.push_back(element);
    return node;
  }

  static bool decode(const Node& node, std::list<T,A>& rhs) {
    if (!node.IsSequence())
      return false;

    rhs.clear();
    for (const auto& element : node)
#if defined(__GNUC__) && __GNUC__ < 4
      // workaround for GCC 3:
      rhs.push_back(element.template as<T>());
#else
      rhs.push_back(element.as<T>());
#endif
    return true;
  }
};

// std::array
template <typename T, std::size_t N>
struct convert<std::array<T, N>> {
  static Node encode(const std::array<T, N>& rhs) {
    Node node(NodeType::Sequence);
    for (const auto& element : rhs) {
      node.push_back(element);
    }
    return node;
  }

  static bool decode(const Node& node, std::array<T, N>& rhs) {
    if (!isNodeValid(node)) {
      return false;
    }

    for (auto i = 0u; i < node.size(); ++i) {
#if defined(__GNUC__) && __GNUC__ < 4
      // workaround for GCC 3:
      rhs[i] = node[i].template as<T>();
#else
      rhs[i] = node[i].as<T>();
#endif
    }
    return true;
  }

 private:
  static bool isNodeValid(const Node& node) {
    return node.IsSequence() && node.size() == N;
  }
};


// std::valarray
template <typename T>
struct convert<std::valarray<T>> {
  static Node encode(const std::valarray<T>& rhs) {
    Node node(NodeType::Sequence);
    for (const auto& element : rhs) {
      node.push_back(element);
    }
    return node;
  }

  static bool decode(const Node& node, std::valarray<T>& rhs) {
    if (!node.IsSequence()) {
      return false;
    }

    rhs.resize(node.size());
    for (auto i = 0u; i < node.size(); ++i) {
#if defined(__GNUC__) && __GNUC__ < 4
      // workaround for GCC 3:
      rhs[i] = node[i].template as<T>();
#else
      rhs[i] = node[i].as<T>();
#endif
    }
    return true;
  }
};


// std::pair
template <typename T, typename U>
struct convert<std::pair<T, U>> {
  static Node encode(const std::pair<T, U>& rhs) {
    Node node(NodeType::Sequence);
    node.push_back(rhs.first);
    node.push_back(rhs.second);
    return node;
  }

  static bool decode(const Node& node, std::pair<T, U>& rhs) {
    if (!node.IsSequence())
      return false;
    if (node.size() != 2)
      return false;

#if defined(__GNUC__) && __GNUC__ < 4
    // workaround for GCC 3:
    rhs.first = node[0].template as<T>();
#else
    rhs.first = node[0].as<T>();
#endif
#if defined(__GNUC__) && __GNUC__ < 4
    // workaround for GCC 3:
    rhs.second = node[1].template as<U>();
#else
    rhs.second = node[1].as<U>();
#endif
    return true;
  }
};

// binary
template <>
struct convert<Binary> {
  static Node encode(const Binary& rhs) {
    return Node(EncodeBase64(rhs.data(), rhs.size()));
  }

  static bool decode(const Node& node, Binary& rhs) {
    if (!node.IsScalar())
      return false;

    std::vector<unsigned char> data = DecodeBase64(node.Scalar());
    if (data.empty() && !node.Scalar().empty())
      return false;

    rhs.swap(data);
    return true;
  }
};
}

#endif  // NODE_CONVERT_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/emit.h
================================================
﻿#ifndef NODE_EMIT_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NODE_EMIT_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <string>
#include <iosfwd>

#include "../../yaml-cpp/dll.h"

namespace YAML {
class Emitter;
class Node;

/**
 * Emits the node to the given {@link Emitter}. If there is an error in writing,
 * {@link Emitter#good} will return false.
 */
YAML_CPP_API Emitter& operator<<(Emitter& out, const Node& node);

/** Emits the node to the given output stream. */
YAML_CPP_API std::ostream& operator<<(std::ostream& out, const Node& node);

/** Converts the node to a YAML string. */
YAML_CPP_API std::string Dump(const Node& node);
}  // namespace YAML

#endif  // NODE_EMIT_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/impl.h
================================================
﻿#ifndef NODE_IMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NODE_IMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "../exceptions.h"
#include "../node/detail/memory.h"
#include "../node/detail/node.h"
#include "../node/iterator.h"
#include "../node/node.h"
#include <sstream>
#include <string>

namespace YAML {
inline Node::Node()
    : m_isValid(true), m_invalidKey{}, m_pMemory(nullptr), m_pNode(nullptr) {}

inline Node::Node(NodeType::value type)
    : m_isValid(true),
      m_invalidKey{},
      m_pMemory(new detail::memory_holder),
      m_pNode(&m_pMemory->create_node()) {
  m_pNode->set_type(type);
}

template <typename T>
inline Node::Node(const T& rhs)
    : m_isValid(true),
      m_invalidKey{},
      m_pMemory(new detail::memory_holder),
      m_pNode(&m_pMemory->create_node()) {
  Assign(rhs);
}

inline Node::Node(const detail::iterator_value& rhs)
    : m_isValid(rhs.m_isValid),
      m_invalidKey(rhs.m_invalidKey),
      m_pMemory(rhs.m_pMemory),
      m_pNode(rhs.m_pNode) {}

inline Node::Node(const Node&) = default;

inline Node::Node(Zombie)
    : m_isValid(false), m_invalidKey{}, m_pMemory{}, m_pNode(nullptr) {}

inline Node::Node(Zombie, const std::string& key)
    : m_isValid(false), m_invalidKey(key), m_pMemory{}, m_pNode(nullptr) {}

inline Node::Node(detail::node& node, detail::shared_memory_holder pMemory)
    : m_isValid(true), m_invalidKey{}, m_pMemory(pMemory), m_pNode(&node) {}

inline Node::~Node() = default;

inline void Node::EnsureNodeExists() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  if (!m_pNode) {
    m_pMemory.reset(new detail::memory_holder);
    m_pNode = &m_pMemory->create_node();
    m_pNode->set_null();
  }
}

inline bool Node::IsDefined() const {
  if (!m_isValid) {
    return false;
  }
  return m_pNode ? m_pNode->is_defined() : true;
}

inline Mark Node::Mark() const {
  if (!m_isValid) {
    throw InvalidNode(m_invalidKey);
  }
  return m_pNode ? m_pNode->mark() : Mark::null_mark();
}

inline NodeType::value Node::Type() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  return m_pNode ? m_pNode->type() : NodeType::Null;
}

// access

// template helpers
template <typename T, typename S>
struct as_if {
  explicit as_if(const Node& node_) : node(node_) {}
  const Node& node;

  T operator()(const S& fallback) const {
    if (!node.m_pNode)
      return fallback;

    T t;
    if (convert<T>::decode(node, t))
      return t;
    return fallback;
  }
};

template <typename S>
struct as_if<std::string, S> {
  explicit as_if(const Node& node_) : node(node_) {}
  const Node& node;

  std::string operator()(const S& fallback) const {
    if (node.Type() == NodeType::Null)
      return "null";
    if (node.Type() != NodeType::Scalar)
      return fallback;
    return node.Scalar();
  }
};

template <typename T>
struct as_if<T, void> {
  explicit as_if(const Node& node_) : node(node_) {}
  const Node& node;

  T operator()() const {
    if (!node.m_pNode)
      throw TypedBadConversion<T>(node.Mark());

    T t;
    if (convert<T>::decode(node, t))
      return t;
    throw TypedBadConversion<T>(node.Mark());
  }
};

template <>
struct as_if<std::string, void> {
  explicit as_if(const Node& node_) : node(node_) {}
  const Node& node;

  std::string operator()() const {
    if (node.Type() == NodeType::Null)
      return "null";
    if (node.Type() != NodeType::Scalar)
      throw TypedBadConversion<std::string>(node.Mark());
    return node.Scalar();
  }
};

// access functions
template <typename T>
inline T Node::as() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  return as_if<T, void>(*this)();
}

template <typename T, typename S>
inline T Node::as(const S& fallback) const {
  if (!m_isValid)
    return fallback;
  return as_if<T, S>(*this)(fallback);
}

inline const std::string& Node::Scalar() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  return m_pNode ? m_pNode->scalar() : detail::node_data::empty_scalar();
}

inline const std::string& Node::Tag() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  return m_pNode ? m_pNode->tag() : detail::node_data::empty_scalar();
}

inline void Node::SetTag(const std::string& tag) {
  EnsureNodeExists();
  m_pNode->set_tag(tag);
}

inline EmitterStyle::value Node::Style() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  return m_pNode ? m_pNode->style() : EmitterStyle::Default;
}

inline void Node::SetStyle(EmitterStyle::value style) {
  EnsureNodeExists();
  m_pNode->set_style(style);
}

// assignment
inline bool Node::is(const Node& rhs) const {
  if (!m_isValid || !rhs.m_isValid)
    throw InvalidNode(m_invalidKey);
  if (!m_pNode || !rhs.m_pNode)
    return false;
  return m_pNode->is(*rhs.m_pNode);
}

template <typename T>
inline Node& Node::operator=(const T& rhs) {
  Assign(rhs);
  return *this;
}

inline Node& Node::operator=(const Node& rhs) {
  if (is(rhs))
    return *this;
  AssignNode(rhs);
  return *this;
}

inline void Node::reset(const YAML::Node& rhs) {
  if (!m_isValid || !rhs.m_isValid)
    throw InvalidNode(m_invalidKey);
  m_pMemory = rhs.m_pMemory;
  m_pNode = rhs.m_pNode;
}

template <typename T>
inline void Node::Assign(const T& rhs) {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  AssignData(convert<T>::encode(rhs));
}

template <>
inline void Node::Assign(const std::string& rhs) {
  EnsureNodeExists();
  m_pNode->set_scalar(rhs);
}

inline void Node::Assign(const char* rhs) {
  EnsureNodeExists();
  m_pNode->set_scalar(rhs);
}

inline void Node::Assign(char* rhs) {
  EnsureNodeExists();
  m_pNode->set_scalar(rhs);
}

inline void Node::AssignData(const Node& rhs) {
  EnsureNodeExists();
  rhs.EnsureNodeExists();

  m_pNode->set_data(*rhs.m_pNode);
  m_pMemory->merge(*rhs.m_pMemory);
}

inline void Node::AssignNode(const Node& rhs) {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  rhs.EnsureNodeExists();

  if (!m_pNode) {
    m_pNode = rhs.m_pNode;
    m_pMemory = rhs.m_pMemory;
    return;
  }

  m_pNode->set_ref(*rhs.m_pNode);
  m_pMemory->merge(*rhs.m_pMemory);
  m_pNode = rhs.m_pNode;
}

// size/iterator
inline std::size_t Node::size() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  return m_pNode ? m_pNode->size() : 0;
}

inline const_iterator Node::begin() const {
  if (!m_isValid)
    return const_iterator();
  return m_pNode ? const_iterator(m_pNode->begin(), m_pMemory)
                 : const_iterator();
}

inline iterator Node::begin() {
  if (!m_isValid)
    return iterator();
  return m_pNode ? iterator(m_pNode->begin(), m_pMemory) : iterator();
}

inline const_iterator Node::end() const {
  if (!m_isValid)
    return const_iterator();
  return m_pNode ? const_iterator(m_pNode->end(), m_pMemory) : const_iterator();
}

inline iterator Node::end() {
  if (!m_isValid)
    return iterator();
  return m_pNode ? iterator(m_pNode->end(), m_pMemory) : iterator();
}

// sequence
template <typename T>
inline void Node::push_back(const T& rhs) {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  push_back(Node(rhs));
}

inline void Node::push_back(const Node& rhs) {
  EnsureNodeExists();
  rhs.EnsureNodeExists();

  m_pNode->push_back(*rhs.m_pNode, m_pMemory);
  m_pMemory->merge(*rhs.m_pMemory);
}

template<typename Key>
std::string key_to_string(const Key& key) {
  return streamable_to_string<Key, is_streamable<std::stringstream, Key>::value>().impl(key);
}

// indexing
template <typename Key>
inline const Node Node::operator[](const Key& key) const {
  EnsureNodeExists();
  detail::node* value =
      static_cast<const detail::node&>(*m_pNode).get(key, m_pMemory);
  if (!value) {
    return Node(ZombieNode, key_to_string(key));
  }
  return Node(*value, m_pMemory);
}

template <typename Key>
inline Node Node::operator[](const Key& key) {
  EnsureNodeExists();
  detail::node& value = m_pNode->get(key, m_pMemory);
  return Node(value, m_pMemory);
}

template <typename Key>
inline bool Node::remove(const Key& key) {
  EnsureNodeExists();
  return m_pNode->remove(key, m_pMemory);
}

inline const Node Node::operator[](const Node& key) const {
  EnsureNodeExists();
  key.EnsureNodeExists();
  m_pMemory->merge(*key.m_pMemory);
  detail::node* value =
      static_cast<const detail::node&>(*m_pNode).get(*key.m_pNode, m_pMemory);
  if (!value) {
    return Node(ZombieNode, key_to_string(key));
  }
  return Node(*value, m_pMemory);
}

inline Node Node::operator[](const Node& key) {
  EnsureNodeExists();
  key.EnsureNodeExists();
  m_pMemory->merge(*key.m_pMemory);
  detail::node& value = m_pNode->get(*key.m_pNode, m_pMemory);
  return Node(value, m_pMemory);
}

inline bool Node::remove(const Node& key) {
  EnsureNodeExists();
  key.EnsureNodeExists();
  return m_pNode->remove(*key.m_pNode, m_pMemory);
}

// map
template <typename Key, typename Value>
inline void Node::force_insert(const Key& key, const Value& value) {
  EnsureNodeExists();
  m_pNode->force_insert(key, value, m_pMemory);
}

// free functions
inline bool operator==(const Node& lhs, const Node& rhs) { return lhs.is(rhs); }
}  // namespace YAML

#endif  // NODE_IMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/iterator.h
================================================
﻿#ifndef VALUE_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "../dll.h"
#include "../node/node.h"
#include "../node/detail/iterator_fwd.h"
#include "../node/detail/iterator.h"
#include <list>
#include <utility>
#include <vector>

// Assert in place so gcc + libc++ combination properly builds
static_assert(std::is_constructible<YAML::Node, const YAML::Node&>::value, "Node must be copy constructable");

namespace YAML {
namespace detail {
struct iterator_value : public Node, std::pair<Node, Node> {
  iterator_value() = default;
  explicit iterator_value(const Node& rhs)
      : Node(rhs),
        std::pair<Node, Node>(Node(Node::ZombieNode), Node(Node::ZombieNode)) {}
  explicit iterator_value(const Node& key, const Node& value)
      : Node(Node::ZombieNode), std::pair<Node, Node>(key, value) {}
};
}
}

#endif  // VALUE_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/node.h
================================================
﻿#ifndef NODE_NODE_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NODE_NODE_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <stdexcept>
#include <string>

#include "../dll.h"
#include "../emitterstyle.h"
#include "../mark.h"
#include "../node/detail/iterator_fwd.h"
#include "../node/ptr.h"
#include "../node/type.h"

namespace YAML {
namespace detail {
class node;
class node_data;
struct iterator_value;
}  // namespace detail
}  // namespace YAML

namespace YAML {
class YAML_CPP_API Node {
 public:
  friend class NodeBuilder;
  friend class NodeEvents;
  friend struct detail::iterator_value;
  friend class detail::node;
  friend class detail::node_data;
  template <typename>
  friend class detail::iterator_base;
  template <typename T, typename S>
  friend struct as_if;

  using iterator = YAML::iterator;
  using const_iterator = YAML::const_iterator;

  Node();
  explicit Node(NodeType::value type);
  template <typename T>
  explicit Node(const T& rhs);
  explicit Node(const detail::iterator_value& rhs);
  Node(const Node& rhs);
  ~Node();

  YAML::Mark Mark() const;
  NodeType::value Type() const;
  bool IsDefined() const;
  bool IsNull() const { return Type() == NodeType::Null; }
  bool IsScalar() const { return Type() == NodeType::Scalar; }
  bool IsSequence() const { return Type() == NodeType::Sequence; }
  bool IsMap() const { return Type() == NodeType::Map; }

  // bool conversions
  explicit operator bool() const { return IsDefined(); }
  bool operator!() const { return !IsDefined(); }

  // access
  template <typename T>
  T as() const;
  template <typename T, typename S>
  T as(const S& fallback) const;
  const std::string& Scalar() const;

  const std::string& Tag() const;
  void SetTag(const std::string& tag);

  // style
  // WARNING: This API might change in future releases.
  EmitterStyle::value Style() const;
  void SetStyle(EmitterStyle::value style);

  // assignment
  bool is(const Node& rhs) const;
  template <typename T>
  Node& operator=(const T& rhs);
  Node& operator=(const Node& rhs);
  void reset(const Node& rhs = Node());

  // size/iterator
  std::size_t size() const;

  const_iterator begin() const;
  iterator begin();

  const_iterator end() const;
  iterator end();

  // sequence
  template <typename T>
  void push_back(const T& rhs);
  void push_back(const Node& rhs);

  // indexing
  template <typename Key>
  const Node operator[](const Key& key) const;
  template <typename Key>
  Node operator[](const Key& key);
  template <typename Key>
  bool remove(const Key& key);

  const Node operator[](const Node& key) const;
  Node operator[](const Node& key);
  bool remove(const Node& key);

  // map
  template <typename Key, typename Value>
  void force_insert(const Key& key, const Value& value);

 private:
  enum Zombie { ZombieNode };
  explicit Node(Zombie);
  explicit Node(Zombie, const std::string&);
  explicit Node(detail::node& node, detail::shared_memory_holder pMemory);

  void EnsureNodeExists() const;

  template <typename T>
  void Assign(const T& rhs);
  void Assign(const char* rhs);
  void Assign(char* rhs);

  void AssignData(const Node& rhs);
  void AssignNode(const Node& rhs);

 private:
  bool m_isValid;
  // String representation of invalid key, if the node is invalid.
  std::string m_invalidKey;
  mutable detail::shared_memory_holder m_pMemory;
  mutable detail::node* m_pNode;
};

YAML_CPP_API bool operator==(const Node& lhs, const Node& rhs);

YAML_CPP_API Node Clone(const Node& node);

template <typename T>
struct convert;
}

#endif  // NODE_NODE_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/parse.h
================================================
﻿#ifndef VALUE_PARSE_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_PARSE_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <iosfwd>
#include <string>
#include <vector>

#include "../../yaml-cpp/dll.h"

namespace YAML {
class Node;

/**
 * Loads the input string as a single YAML document.
 *
 * @throws {@link ParserException} if it is malformed.
 */
YAML_CPP_API Node Load(const std::string& input);

/**
 * Loads the input string as a single YAML document.
 *
 * @throws {@link ParserException} if it is malformed.
 */
YAML_CPP_API Node Load(const char* input);

/**
 * Loads the input stream as a single YAML document.
 *
 * @throws {@link ParserException} if it is malformed.
 */
YAML_CPP_API Node Load(std::istream& input);

/**
 * Loads the input file as a single YAML document.
 *
 * @throws {@link ParserException} if it is malformed.
 * @throws {@link BadFile} if the file cannot be loaded.
 */
YAML_CPP_API Node LoadFile(const std::string& filename);

/**
 * Loads the input string as a list of YAML documents.
 *
 * @throws {@link ParserException} if it is malformed.
 */
YAML_CPP_API std::vector<Node> LoadAll(const std::string& input);

/**
 * Loads the input string as a list of YAML documents.
 *
 * @throws {@link ParserException} if it is malformed.
 */
YAML_CPP_API std::vector<Node> LoadAll(const char* input);

/**
 * Loads the input stream as a list of YAML documents.
 *
 * @throws {@link ParserException} if it is malformed.
 */
YAML_CPP_API std::vector<Node> LoadAll(std::istream& input);

/**
 * Loads the input file as a list of YAML documents.
 *
 * @throws {@link ParserException} if it is malformed.
 * @throws {@link BadFile} if the file cannot be loaded.
 */
YAML_CPP_API std::vector<Node> LoadAllFromFile(const std::string& filename);
}  // namespace YAML

#endif  // VALUE_PARSE_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/ptr.h
================================================
#ifndef VALUE_PTR_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_PTR_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <memory>

namespace YAML {
namespace detail {
class node;
class node_ref;
class node_data;
class memory;
class memory_holder;

using shared_node = std::shared_ptr<node>;
using shared_node_ref = std::shared_ptr<node_ref>;
using shared_node_data = std::shared_ptr<node_data>;
using shared_memory_holder = std::shared_ptr<memory_holder>;
using shared_memory = std::shared_ptr<memory>;
}
}

#endif  // VALUE_PTR_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/type.h
================================================
#ifndef VALUE_TYPE_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_TYPE_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

namespace YAML {
struct NodeType {
  enum value { Undefined, Null, Scalar, Sequence, Map };
};
}

#endif  // VALUE_TYPE_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/detail/impl.h
================================================
﻿#ifndef NODE_DETAIL_IMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NODE_DETAIL_IMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "../../node/detail/node.h"
#include "../../node/detail/node_data.h"

#include <algorithm>
#include <type_traits>

namespace YAML {
namespace detail {
template <typename Key, typename Enable = void>
struct get_idx {
  static node* get(const std::vector<node*>& /* sequence */,
                   const Key& /* key */, shared_memory_holder /* pMemory */) {
    return nullptr;
  }
};

template <typename Key>
struct get_idx<Key,
               typename std::enable_if<std::is_unsigned<Key>::value &&
                                       !std::is_same<Key, bool>::value>::type> {
  static node* get(const std::vector<node*>& sequence, const Key& key,
                   shared_memory_holder /* pMemory */) {
    return key < sequence.size() ? sequence[key] : nullptr;
  }

  static node* get(std::vector<node*>& sequence, const Key& key,
                   shared_memory_holder pMemory) {
    if (key > sequence.size() || (key > 0 && !sequence[key - 1]->is_defined()))
      return nullptr;
    if (key == sequence.size())
      sequence.push_back(&pMemory->create_node());
    return sequence[key];
  }
};

template <typename Key>
struct get_idx<Key, typename std::enable_if<std::is_signed<Key>::value>::type> {
  static node* get(const std::vector<node*>& sequence, const Key& key,
                   shared_memory_holder pMemory) {
    return key >= 0 ? get_idx<std::size_t>::get(
                          sequence, static_cast<std::size_t>(key), pMemory)
                    : nullptr;
  }
  static node* get(std::vector<node*>& sequence, const Key& key,
                   shared_memory_holder pMemory) {
    return key >= 0 ? get_idx<std::size_t>::get(
                          sequence, static_cast<std::size_t>(key), pMemory)
                    : nullptr;
  }
};

template <typename Key, typename Enable = void>
struct remove_idx {
  static bool remove(std::vector<node*>&, const Key&, std::size_t&) {
    return false;
  }
};

template <typename Key>
struct remove_idx<
    Key, typename std::enable_if<std::is_unsigned<Key>::value &&
                                 !std::is_same<Key, bool>::value>::type> {

  static bool remove(std::vector<node*>& sequence, const Key& key,
                     std::size_t& seqSize) {
    if (key >= sequence.size()) {
      return false;
    } else {
      sequence.erase(sequence.begin() + key);
      if (seqSize > key) {
          --seqSize;
      }
      return true;
    }
  }
};

template <typename Key>
struct remove_idx<Key,
                  typename std::enable_if<std::is_signed<Key>::value>::type> {

  static bool remove(std::vector<node*>& sequence, const Key& key,
                     std::size_t& seqSize) {
    return key >= 0 ? remove_idx<std::size_t>::remove(
                          sequence, static_cast<std::size_t>(key), seqSize)
                    : false;
  }
};

template <typename T>
inline bool node::equals(const T& rhs, shared_memory_holder pMemory) {
  T lhs;
  if (convert<T>::decode(Node(*this, pMemory), lhs)) {
    return lhs == rhs;
  }
  return false;
}

inline bool node::equals(const char* rhs, shared_memory_holder pMemory) {
  std::string lhs;
  if (convert<std::string>::decode(Node(*this, std::move(pMemory)), lhs)) {
    return lhs == rhs;
  }
  return false;
}

// indexing
template <typename Key>
inline node* node_data::get(const Key& key,
                            shared_memory_holder pMemory) const {
  switch (m_type) {
    case NodeType::Map:
      break;
    case NodeType::Undefined:
    case NodeType::Null:
      return nullptr;
    case NodeType::Sequence:
      if (node* pNode = get_idx<Key>::get(m_sequence, key, pMemory))
        return pNode;
      return nullptr;
    case NodeType::Scalar:
      throw BadSubscript(m_mark, key);
  }

  auto it = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
    return m.first->equals(key, pMemory);
  });

  return it != m_map.end() ? it->second : nullptr;
}

template <typename Key>
inline node& node_data::get(const Key& key, shared_memory_holder pMemory) {
  switch (m_type) {
    case NodeType::Map:
      break;
    case NodeType::Undefined:
    case NodeType::Null:
    case NodeType::Sequence:
      if (node* pNode = get_idx<Key>::get(m_sequence, key, pMemory)) {
        m_type = NodeType::Sequence;
        return *pNode;
      }

      convert_to_map(pMemory);
      break;
    case NodeType::Scalar:
      throw BadSubscript(m_mark, key);
  }

  auto it = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
    return m.first->equals(key, pMemory);
  });

  if (it != m_map.end()) {
    return *it->second;
  }

  node& k = convert_to_node(key, pMemory);
  node& v = pMemory->create_node();
  insert_map_pair(k, v);
  return v;
}

template <typename Key>
inline bool node_data::remove(const Key& key, shared_memory_holder pMemory) {
  if (m_type == NodeType::Sequence) {
    return remove_idx<Key>::remove(m_sequence, key, m_seqSize);
  }

  if (m_type == NodeType::Map) {
    kv_pairs::iterator it = m_undefinedPairs.begin();
    while (it != m_undefinedPairs.end()) {
      kv_pairs::iterator jt = std::next(it);
      if (it->first->equals(key, pMemory)) {
        m_undefinedPairs.erase(it);
      }
      it = jt;
    }

    auto iter = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
      return m.first->equals(key, pMemory);
    });

    if (iter != m_map.end()) {
      m_map.erase(iter);
      return true;
    }
  }

  return false;
}

// map
template <typename Key, typename Value>
inline void node_data::force_insert(const Key& key, const Value& value,
                                    shared_memory_holder pMemory) {
  switch (m_type) {
    case NodeType::Map:
      break;
    case NodeType::Undefined:
    case NodeType::Null:
    case NodeType::Sequence:
      convert_to_map(pMemory);
      break;
    case NodeType::Scalar:
      throw BadInsert();
  }

  node& k = convert_to_node(key, pMemory);
  node& v = convert_to_node(value, pMemory);
  insert_map_pair(k, v);
}

template <typename T>
inline node& node_data::convert_to_node(const T& rhs,
                                        shared_memory_holder pMemory) {
  Node value = convert<T>::encode(rhs);
  value.EnsureNodeExists();
  pMemory->merge(*value.m_pMemory);
  return *value.m_pNode;
}
}
}

#endif  // NODE_DETAIL_IMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/detail/iterator.h
================================================
﻿#ifndef VALUE_DETAIL_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_DETAIL_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "../../dll.h"
#include "../../node/detail/node_iterator.h"
#include "../../node/node.h"
#include "../../node/ptr.h"
#include <cstddef>
#include <iterator>


namespace YAML {
namespace detail {
struct iterator_value;

template <typename V>
class iterator_base {

 private:
  template <typename>
  friend class iterator_base;
  struct enabler {};
  using base_type = node_iterator;

  struct proxy {
    explicit proxy(const V& x) : m_ref(x) {}
    V* operator->() { return std::addressof(m_ref); }
    operator V*() { return std::addressof(m_ref); }

    V m_ref;
  };

 public:
  using iterator_category = std::forward_iterator_tag;
  using value_type = V;
  using difference_type = std::ptrdiff_t;
  using pointer = V*;
  using reference = V;

 public:
  iterator_base() : m_iterator(), m_pMemory() {}
  explicit iterator_base(base_type rhs, shared_memory_holder pMemory)
      : m_iterator(rhs), m_pMemory(pMemory) {}

  template <class W>
  iterator_base(const iterator_base<W>& rhs,
                typename std::enable_if<std::is_convertible<W*, V*>::value,
                                        enabler>::type = enabler())
      : m_iterator(rhs.m_iterator), m_pMemory(rhs.m_pMemory) {}

  iterator_base<V>& operator++() {
    ++m_iterator;
    return *this;
  }

  iterator_base<V> operator++(int) {
    iterator_base<V> iterator_pre(*this);
    ++(*this);
    return iterator_pre;
  }

  template <typename W>
  bool operator==(const iterator_base<W>& rhs) const {
    return m_iterator == rhs.m_iterator;
  }

  template <typename W>
  bool operator!=(const iterator_base<W>& rhs) const {
    return m_iterator != rhs.m_iterator;
  }

  value_type operator*() const {
    const typename base_type::value_type& v = *m_iterator;
    if (v.pNode)
      return value_type(Node(*v, m_pMemory));
    if (v.first && v.second)
      return value_type(Node(*v.first, m_pMemory), Node(*v.second, m_pMemory));
    return value_type();
  }

  proxy operator->() const { return proxy(**this); }

 private:
  base_type m_iterator;
  shared_memory_holder m_pMemory;
};
}  // namespace detail
}  // namespace YAML

#endif  // VALUE_DETAIL_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/detail/iterator_fwd.h
================================================
﻿#ifndef VALUE_DETAIL_ITERATOR_FWD_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_DETAIL_ITERATOR_FWD_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "../../dll.h"
#include <list>
#include <utility>
#include <vector>

namespace YAML {

namespace detail {
struct iterator_value;
template <typename V>
class iterator_base;
}

using iterator = detail::iterator_base<detail::iterator_value>;
using const_iterator = detail::iterator_base<const detail::iterator_value>;
}

#endif  // VALUE_DETAIL_ITERATOR_FWD_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/detail/memory.h
================================================
﻿#ifndef VALUE_DETAIL_MEMORY_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_DETAIL_MEMORY_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <set>

#include "../../dll.h"
#include "../../node/ptr.h"

namespace YAML {
namespace detail {
class node;
}  // namespace detail
}  // namespace YAML

namespace YAML {
namespace detail {
class YAML_CPP_API memory {
 public:
  memory() : m_nodes{} {}
  node& create_node();
  void merge(const memory& rhs);

 private:
  using Nodes = std::set<shared_node>;
  Nodes m_nodes;
};

class YAML_CPP_API memory_holder {
 public:
  memory_holder() : m_pMemory(new memory) {}

  node& create_node() { return m_pMemory->create_node(); }
  void merge(memory_holder& rhs);

 private:
  shared_memory m_pMemory;
};
}  // namespace detail
}  // namespace YAML

#endif  // VALUE_DETAIL_MEMORY_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/detail/node.h
================================================
﻿#ifndef NODE_DETAIL_NODE_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NODE_DETAIL_NODE_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "../../dll.h"
#include "../../emitterstyle.h"
#include "../../node/detail/node_ref.h"
#include "../../node/ptr.h"
#include "../../node/type.h"
#include <set>
#include <atomic>

namespace YAML {
namespace detail {
class node {
 private:
  struct less {
    bool operator ()(const node* l, const node* r) const {return l->m_index < r->m_index;}
  };

 public:
  node() : m_pRef(new node_ref), m_dependencies{}, m_index{} {}
  node(const node&) = delete;
  node& operator=(const node&) = delete;

  bool is(const node& rhs) const { return m_pRef == rhs.m_pRef; }
  const node_ref* ref() const { return m_pRef.get(); }

  bool is_defined() const { return m_pRef->is_defined(); }
  const Mark& mark() const { return m_pRef->mark(); }
  NodeType::value type() const { return m_pRef->type(); }

  const std::string& scalar() const { return m_pRef->scalar(); }
  const std::string& tag() const { return m_pRef->tag(); }
  EmitterStyle::value style() const { return m_pRef->style(); }

  template <typename T>
  bool equals(const T& rhs, shared_memory_holder pMemory);
  bool equals(const char* rhs, shared_memory_holder pMemory);

  void mark_defined() {
    if (is_defined())
      return;

    m_pRef->mark_defined();
    for (node* dependency : m_dependencies)
      dependency->mark_defined();
    m_dependencies.clear();
  }

  void add_dependency(node& rhs) {
    if (is_defined())
      rhs.mark_defined();
    else
      m_dependencies.insert(&rhs);
  }

  void set_ref(const node& rhs) {
    if (rhs.is_defined())
      mark_defined();
    m_pRef = rhs.m_pRef;
  }
  void set_data(const node& rhs) {
    if (rhs.is_defined())
      mark_defined();
    m_pRef->set_data(*rhs.m_pRef);
  }

  void set_mark(const Mark& mark) { m_pRef->set_mark(mark); }

  void set_type(NodeType::value type) {
    if (type != NodeType::Undefined)
      mark_defined();
    m_pRef->set_type(type);
  }
  void set_null() {
    mark_defined();
    m_pRef->set_null();
  }
  void set_scalar(const std::string& scalar) {
    mark_defined();
    m_pRef->set_scalar(scalar);
  }
  void set_tag(const std::string& tag) {
    mark_defined();
    m_pRef->set_tag(tag);
  }

  // style
  void set_style(EmitterStyle::value style) {
    mark_defined();
    m_pRef->set_style(style);
  }

  // size/iterator
  std::size_t size() const { return m_pRef->size(); }

  const_node_iterator begin() const {
    return static_cast<const node_ref&>(*m_pRef).begin();
  }
  node_iterator begin() { return m_pRef->begin(); }

  const_node_iterator end() const {
    return static_cast<const node_ref&>(*m_pRef).end();
  }
  node_iterator end() { return m_pRef->end(); }

  // sequence
  void push_back(node& input, shared_memory_holder pMemory) {
    m_pRef->push_back(input, pMemory);
    input.add_dependency(*this);
    m_index = m_amount.fetch_add(1);
  }
  void insert(node& key, node& value, shared_memory_holder pMemory) {
    m_pRef->insert(key, value, pMemory);
    key.add_dependency(*this);
    value.add_dependency(*this);
  }

  // indexing
  template <typename Key>
  node* get(const Key& key, shared_memory_holder pMemory) const {
    // NOTE: this returns a non-const node so that the top-level Node can wrap
    // it, and returns a pointer so that it can be nullptr (if there is no such
    // key).
    return static_cast<const node_ref&>(*m_pRef).get(key, pMemory);
  }
  template <typename Key>
  node& get(const Key& key, shared_memory_holder pMemory) {
    node& value = m_pRef->get(key, pMemory);
    value.add_dependency(*this);
    return value;
  }
  template <typename Key>
  bool remove(const Key& key, shared_memory_holder pMemory) {
    return m_pRef->remove(key, pMemory);
  }

  node* get(node& key, shared_memory_holder pMemory) const {
    // NOTE: this returns a non-const node so that the top-level Node can wrap
    // it, and returns a pointer so that it can be nullptr (if there is no such
    // key).
    return static_cast<const node_ref&>(*m_pRef).get(key, pMemory);
  }
  node& get(node& key, shared_memory_holder pMemory) {
    node& value = m_pRef->get(key, pMemory);
    key.add_dependency(*this);
    value.add_dependency(*this);
    return value;
  }
  bool remove(node& key, shared_memory_holder pMemory) {
    return m_pRef->remove(key, pMemory);
  }

  // map
  template <typename Key, typename Value>
  void force_insert(const Key& key, const Value& value,
                    shared_memory_holder pMemory) {
    m_pRef->force_insert(key, value, pMemory);
  }

 private:
  shared_node_ref m_pRef;
  using nodes = std::set<node*, less>;
  nodes m_dependencies;
  size_t m_index;
  static YAML_CPP_API std::atomic<size_t> m_amount;
};
}  // namespace detail
}  // namespace YAML

#endif  // NODE_DETAIL_NODE_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/detail/node_data.h
================================================
﻿#ifndef VALUE_DETAIL_NODE_DATA_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_DETAIL_NODE_DATA_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <list>
#include <map>
#include <string>
#include <utility>
#include <vector>

#include "../../dll.h"
#include "../../node/detail/node_iterator.h"
#include "../../node/iterator.h"
#include "../../node/ptr.h"
#include "../../node/type.h"

namespace YAML {
namespace detail {
class node;
}  // namespace detail
}  // namespace YAML

namespace YAML {
namespace detail {
class YAML_CPP_API node_data {
 public:
  node_data();
  node_data(const node_data&) = delete;
  node_data& operator=(const node_data&) = delete;

  void mark_defined();
  void set_mark(const Mark& mark);
  void set_type(NodeType::value type);
  void set_tag(const std::string& tag);
  void set_null();
  void set_scalar(const std::string& scalar);
  void set_style(EmitterStyle::value style);

  bool is_defined() const { return m_isDefined; }
  const Mark& mark() const { return m_mark; }
  NodeType::value type() const {
    return m_isDefined ? m_type : NodeType::Undefined;
  }
  const std::string& scalar() const { return m_scalar; }
  const std::string& tag() const { return m_tag; }
  EmitterStyle::value style() const { return m_style; }

  // size/iterator
  std::size_t size() const;

  const_node_iterator begin() const;
  node_iterator begin();

  const_node_iterator end() const;
  node_iterator end();

  // sequence
  void push_back(node& node, const shared_memory_holder& pMemory);
  void insert(node& key, node& value, const shared_memory_holder& pMemory);

  // indexing
  template <typename Key>
  node* get(const Key& key, shared_memory_holder pMemory) const;
  template <typename Key>
  node& get(const Key& key, shared_memory_holder pMemory);
  template <typename Key>
  bool remove(const Key& key, shared_memory_holder pMemory);

  node* get(node& key, const shared_memory_holder& pMemory) const;
  node& get(node& key, const shared_memory_holder& pMemory);
  bool remove(node& key, const shared_memory_holder& pMemory);

  // map
  template <typename Key, typename Value>
  void force_insert(const Key& key, const Value& value,
                    shared_memory_holder pMemory);

 public:
  static const std::string& empty_scalar();

 private:
  void compute_seq_size() const;
  void compute_map_size() const;

  void reset_sequence();
  void reset_map();

  void insert_map_pair(node& key, node& value);
  void convert_to_map(const shared_memory_holder& pMemory);
  void convert_sequence_to_map(const shared_memory_holder& pMemory);

  template <typename T>
  static node& convert_to_node(const T& rhs, shared_memory_holder pMemory);

 private:
  bool m_isDefined;
  Mark m_mark;
  NodeType::value m_type;
  std::string m_tag;
  EmitterStyle::value m_style;

  // scalar
  std::string m_scalar;

  // sequence
  using node_seq = std::vector<node *>;
  node_seq m_sequence;

  mutable std::size_t m_seqSize;

  // map
  using node_map = std::vector<std::pair<node*, node*>>;
  node_map m_map;

  using kv_pair = std::pair<node*, node*>;
  using kv_pairs = std::list<kv_pair>;
  mutable kv_pairs m_undefinedPairs;
};
}
}

#endif  // VALUE_DETAIL_NODE_DATA_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/detail/node_iterator.h
================================================
﻿#ifndef VALUE_DETAIL_NODE_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_DETAIL_NODE_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "../../dll.h"
#include "../../node/ptr.h"
#include <cstddef>
#include <iterator>
#include <memory>
#include <map>
#include <utility>
#include <vector>

namespace YAML {
namespace detail {
struct iterator_type {
  enum value { NoneType, Sequence, Map };
};

template <typename V>
struct node_iterator_value : public std::pair<V*, V*> {
  using kv = std::pair<V*, V*>;

  node_iterator_value() : kv(), pNode(nullptr) {}
  explicit node_iterator_value(V& rhs) : kv(), pNode(&rhs) {}
  explicit node_iterator_value(V& key, V& value) : kv(&key, &value), pNode(nullptr) {}

  V& operator*() const { return *pNode; }
  V& operator->() const { return *pNode; }

  V* pNode;
};

using node_seq = std::vector<node *>;
using node_map = std::vector<std::pair<node*, node*>>;

template <typename V>
struct node_iterator_type {
  using seq = node_seq::iterator;
  using map = node_map::iterator;
};

template <typename V>
struct node_iterator_type<const V> {
  using seq = node_seq::const_iterator;
  using map = node_map::const_iterator;
};

template <typename V>
class node_iterator_base {
 private:
  struct enabler {};

  struct proxy {
    explicit proxy(const node_iterator_value<V>& x) : m_ref(x) {}
    node_iterator_value<V>* operator->() { return std::addressof(m_ref); }
    operator node_iterator_value<V>*() { return std::addressof(m_ref); }

    node_iterator_value<V> m_ref;
  };

 public:
  using iterator_category = std::forward_iterator_tag;
  using value_type = node_iterator_value<V>;
  using difference_type = std::ptrdiff_t;
  using pointer = node_iterator_value<V>*;
  using reference = node_iterator_value<V>;
  using SeqIter = typename node_iterator_type<V>::seq;
  using MapIter = typename node_iterator_type<V>::map;

  node_iterator_base()
      : m_type(iterator_type::NoneType), m_seqIt(), m_mapIt(), m_mapEnd() {}
  explicit node_iterator_base(SeqIter seqIt)
      : m_type(iterator_type::Sequence),
        m_seqIt(seqIt),
        m_mapIt(),
        m_mapEnd() {}
  explicit node_iterator_base(MapIter mapIt, MapIter mapEnd)
      : m_type(iterator_type::Map),
        m_seqIt(),
        m_mapIt(mapIt),
        m_mapEnd(mapEnd) {
    m_mapIt = increment_until_defined(m_mapIt);
  }

  template <typename W>
  node_iterator_base(const node_iterator_base<W>& rhs,
                     typename std::enable_if<std::is_convertible<W*, V*>::value,
                                             enabler>::type = enabler())
      : m_type(rhs.m_type),
        m_seqIt(rhs.m_seqIt),
        m_mapIt(rhs.m_mapIt),
        m_mapEnd(rhs.m_mapEnd) {}

  template <typename>
  friend class node_iterator_base;

  template <typename W>
  bool operator==(const node_iterator_base<W>& rhs) const {
    if (m_type != rhs.m_type)
      return false;

    switch (m_type) {
      case iterator_type::NoneType:
        return true;
      case iterator_type::Sequence:
        return m_seqIt == rhs.m_seqIt;
      case iterator_type::Map:
        return m_mapIt == rhs.m_mapIt;
    }
    return true;
  }

  template <typename W>
  bool operator!=(const node_iterator_base<W>& rhs) const {
    return !(*this == rhs);
  }

  node_iterator_base<V>& operator++() {
    switch (m_type) {
      case iterator_type::NoneType:
        break;
      case iterator_type::Sequence:
        ++m_seqIt;
        break;
      case iterator_type::Map:
        ++m_mapIt;
        m_mapIt = increment_until_defined(m_mapIt);
        break;
    }
    return *this;
  }

  node_iterator_base<V> operator++(int) {
    node_iterator_base<V> iterator_pre(*this);
    ++(*this);
    return iterator_pre;
  }

  value_type operator*() const {
    switch (m_type) {
      case iterator_type::NoneType:
        return value_type();
      case iterator_type::Sequence:
        return value_type(**m_seqIt);
      case iterator_type::Map:
        return value_type(*m_mapIt->first, *m_mapIt->second);
    }
    return value_type();
  }

  proxy operator->() const { return proxy(**this); }

  MapIter increment_until_defined(MapIter it) {
    while (it != m_mapEnd && !is_defined(it))
      ++it;
    return it;
  }

  bool is_defined(MapIter it) const {
    return it->first->is_defined() && it->second->is_defined();
  }

 private:
  typename iterator_type::value m_type;

  SeqIter m_seqIt;
  MapIter m_mapIt, m_mapEnd;
};

using node_iterator = node_iterator_base<node>;
using const_node_iterator = node_iterator_base<const node>;
}
}

#endif  // VALUE_DETAIL_NODE_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Utils/yaml-cpp/node/detail/node_ref.h
================================================
﻿#ifndef VALUE_DETAIL_NODE_REF_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_DETAIL_NODE_REF_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "../../dll.h"
#include "../../node/type.h"
#include "../../node/ptr.h"
#include "../../node/detail/node_data.h"

namespace YAML {
namespace detail {
class node_ref {
 public:
  node_ref() : m_pData(new node_data) {}
  node_ref(const node_ref&) = delete;
  node_ref& operator=(const node_ref&) = delete;

  bool is_defined() const { return m_pData->is_defined(); }
  const Mark& mark() const { return m_pData->mark(); }
  NodeType::value type() const { return m_pData->type(); }
  const std::string& scalar() const { return m_pData->scalar(); }
  const std::string& tag() const { return m_pData->tag(); }
  EmitterStyle::value style() const { return m_pData->style(); }

  void mark_defined() { m_pData->mark_defined(); }
  void set_data(const node_ref& rhs) { m_pData = rhs.m_pData; }

  void set_mark(const Mark& mark) { m_pData->set_mark(mark); }
  void set_type(NodeType::value type) { m_pData->set_type(type); }
  void set_tag(const std::string& tag) { m_pData->set_tag(tag); }
  void set_null() { m_pData->set_null(); }
  void set_scalar(const std::string& scalar) { m_pData->set_scalar(scalar); }
  void set_style(EmitterStyle::value style) { m_pData->set_style(style); }

  // size/iterator
  std::size_t size() const { return m_pData->size(); }

  const_node_iterator begin() const {
    return static_cast<const node_data&>(*m_pData).begin();
  }
  node_iterator begin() { return m_pData->begin(); }

  const_node_iterator end() const {
    return static_cast<const node_data&>(*m_pData).end();
  }
  node_iterator end() { return m_pData->end(); }

  // sequence
  void push_back(node& node, shared_memory_holder pMemory) {
    m_pData->push_back(node, pMemory);
  }
  void insert(node& key, node& value, shared_memory_holder pMemory) {
    m_pData->insert(key, value, pMemory);
  }

  // indexing
  template <typename Key>
  node* get(const Key& key, shared_memory_holder pMemory) const {
    return static_cast<const node_data&>(*m_pData).get(key, pMemory);
  }
  template <typename Key>
  node& get(const Key& key, shared_memory_holder pMemory) {
    return m_pData->get(key, pMemory);
  }
  template <typename Key>
  bool remove(const Key& key, shared_memory_holder pMemory) {
    return m_pData->remove(key, pMemory);
  }

  node* get(node& key, shared_memory_holder pMemory) const {
    return static_cast<const node_data&>(*m_pData).get(key, pMemory);
  }
  node& get(node& key, shared_memory_holder pMemory) {
    return m_pData->get(key, pMemory);
  }
  bool remove(node& key, shared_memory_holder pMemory) {
    return m_pData->remove(key, pMemory);
  }

  // map
  template <typename Key, typename Value>
  void force_insert(const Key& key, const Value& value,
                    shared_memory_holder pMemory) {
    m_pData->force_insert(key, value, pMemory);
  }

 private:
  shared_node_data m_pData;
};
}
}

#endif  // VALUE_DETAIL_NODE_REF_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: .github/CODE_OF_CONDUCT.md
================================================
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual
identity and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the overall
  community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or advances of
  any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email address,
  without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official email address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
quq[at]outlook.it.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series of
actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or permanent
ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within the
community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.1, available at
[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].

Community Impact Guidelines were inspired by
[Mozilla's code of conduct enforcement ladder][Mozilla CoC].

For answers to common questions about this code of conduct, see the FAQ at
[https://www.contributor-covenant.org/faq][FAQ]. Translations are available at
[https://www.contributor-covenant.org/translations][translations].

[homepage]: https://www.contributor-covenant.org
[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html
[Mozilla CoC]: https://github.com/mozilla/diversity
[FAQ]: https://www.contributor-covenant.org/faq
[translations]: https://www.contributor-covenant.org/translations



================================================
FILE: .github/CONTRIBUTING.md
================================================
# Contribution Guidelines

Thank you for your interest in contributing to this project! I truly appreciate all
the contributions from the community, whether it's proposing features, identifying bugs, or fixing mistakes! To ensure
that our collaboration is efficient and effective, please follow these guidelines.

Feel free to discuss or suggest improvements to this document
[by submitting a pull request](https://github.com/M3351AN/UkiaCS2/pulls).

## Ways to Contribute

There are multiple ways to contribute.

### Reporting an issue

Please [create an issue](https://github.com/M3351AN/UkiaCS2/issues/new/), assuming one does not already exist, and
describe your concern. Note you need a [GitHub account](https://github.com/signup/free) for this.

Clearly describe the issue:

- If it is a bug, please describe how to **reproduce** it. If possible, attach a _complete example_ which demonstrates
  the error. Please also state what you **expected** to happen instead of the error.
- If you propose a change or addition, try to give an **example** what the improved code could look like or how to use
  it.
- If you found a compilation error, please tell us which **compiler** (version and operating system) you used and paste
  the (relevant part of) the error messages to the ticket.

### Reporting a security vulnerability

You can report a security vulnerability according to our
[security policy](https://github.com/M3351AN/UkiaCS2/security/policy).

### Discussing a new feature

For questions, feature or support requests, please
[open a discussion](https://github.com/M3351AN/UkiaCS2/discussions/new). If you find a proposed answer satisfactory,
please use the "Mark as answer" button to make it easier for readers to see what helped and for the community to filter
for open questions.

### Proposing a fix or an improvement

Join an ongoing discussion or comment on an existing issue before starting to code. This can help to avoid duplicate
efforts or other frustration during the later review.

Create a [pull request](https://github.com/M3351AN/UkiaCS2/pulls)and follow the pull request template below.

- describe the changes in detail, both the what and why,
- reference existing issues where applicable,

We describe all points in detail below.

All contributions (including pull requests) must agree to the
[Developer Certificate of Origin (DCO) version 1.1](https://developercertificate.org). This is exactly the same one
created and used by the Linux kernel developers and posted on http://developercertificate.org/. This is a developer's
certification that he or she has the right to submit the patch for inclusion into the project.

## How to...

### Describe your changes

This library is primarily maintained as a spare-time project. As such, I cannot make any guarantee how quickly changes
are merged and released. Therefore, it is very important to make the review as smooth as possible by explaining not only
_what_ you changed, but _why_. This rationale can be very valuable down the road when improvements or bugs are discussed
years later.

### Reference an existing issue

[Link a pull request to an issue](https://docs.github.com/en/issues/tracking-your-work-with-issues/using-issues/linking-a-pull-request-to-an-issue)
to clarify that a fix is forthcoming and which issue can be closed after merging. Only a few cases (e.g., fixing typos)
do not require prior discussions.

## Recommended documentation

- The library’s [README file](README.md) is an excellent starting point to
  understand its functionality.

## Please don't...

Certain contributions are not helpful.

### Break C++23 language conformance

This software is designed to work with C++23 and later. This means that any compiler that support C++23 should compile
the software without problems. Some compilers like GCC 10 (and earlier), Clang 15 (and earlier), or MSVC 16.3.1 (and earlier) are known not to work due to missing or incomplete C++23 support.

Please do not add features that do not work with the mentioned supported compilers.

## Wanted

The following areas really need contribution and are always welcomed:

- New features/functions
- Improving performance

We look forward to your contributions and collaboration to enhance the software!



================================================
FILE: .github/FUNDING.yml
================================================
# These are supported funding model platforms

github: [M3351AN]
patreon: # Replace with a single Patreon username
open_collective: # Replace with a single Open Collective username
ko_fi: # Replace with a single Ko-fi username
tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel
community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with a single Liberapay username
issuehunt: # Replace with a single IssueHunt username
lfx_crowdfunding: # Replace with a single LFX Crowdfunding project-name e.g., cloud-foundry
polar: # Replace with a single Polar username
buy_me_a_coffee: # Replace with a single Buy Me a Coffee username
thanks_dev: # Replace with a single thanks.dev username
custom: ['https://www.unicef.org/']



================================================
FILE: .github/SECURITY.MD
================================================
# Security Policy

## Supported Versions

Security updates are applied only to the latest release.

## Reporting a Vulnerability

If you have discovered a security vulnerability in this project, please report it privately. **Do not disclose it as a public issue.** This gives us time to work with you to fix the issue before public exposure, reducing the chance that the exploit will be used before a patch is released.

Please disclose it **PRIVATELY** to **zuiun1337[at]gmail.com** / **quq[at]outlook.it**

This project is maintained by a team of volunteers on a reasonable-effort basis. As such, vulnerabilities will be disclosed in a best effort base.



================================================
FILE: .github/workflows/CI.yml
================================================
name: CI

on: 
  workflow_dispatch: ~

permissions:
  contents: read

jobs:
  msbuild:
    runs-on: windows-2022
    strategy:
      matrix:
        toolset: [ClangCL, MSVC]
        configuration: [Debug, Ring0, Ring3]
    steps:
    - uses: actions/checkout@v4
    - name: Add msbuild to PATH
      uses: microsoft/setup-msbuild@v2
    - name: Set toolset
      if: matrix.toolset == 'ClangCL'
      run: echo "toolset=/p:PlatformToolset=${{ matrix.toolset }}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
    - name: Build
      shell: cmd
      run: msbuild Samidare.sln /p:Platform=x64 /p:Configuration=${{ matrix.configuration }} /p:OutDir=${{ github.workspace }}\x64\${{ matrix.configuration }}
    - name: Rename EXE
      run: |
          ren Samidare-${{ matrix.configuration }}.exe Samidare-${{ matrix.toolset }}-${{ matrix.configuration }}-${{github.sha}}.exe
      working-directory: ${{ github.workspace }}\x64\${{ matrix.configuration }}


    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: CI--${{ matrix.toolset }}-${{ matrix.configuration }}-${{github.sha}}
        path: ${{ github.workspace }}\x64\${{ matrix.configuration }}



================================================
FILE: .github/workflows/windows.yml
================================================
name: Windows

on: [push, pull_request]

permissions:
  contents: read

jobs:
  msbuild:
    runs-on: windows-2022
    strategy:
      matrix:
        toolset: [ClangCL, MSVC]
        configuration: [Debug, Ring0, Ring3]
    steps:
    - uses: actions/checkout@v4
    - name: Add msbuild to PATH
      uses: microsoft/setup-msbuild@v2
    - name: Set toolset
      if: matrix.toolset == 'ClangCL'
      run: echo "toolset=/p:PlatformToolset=${{ matrix.toolset }}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
    - name: Build
      shell: cmd
      run: msbuild Samidare.sln /p:Platform=x64 /p:Configuration=${{ matrix.configuration }} ${{ env.toolset }}