Project Path: arc_M3351AN_Usugumo_ewlnsug3

Source Tree:

```txt
arc_M3351AN_Usugumo_ewlnsug3
├── Dispatches.c
├── Dispatches.h
├── Examples
│   ├── CallDriver.cc
│   ├── Target.cc
│   ├── build.bat
│   └── includes
│       ├── keybd_input_injection.h
│       ├── mouse_input_injection.h
│       ├── native.h
│       ├── operation.h
│       └── usugumo.h
├── LICENSE
├── README.md
├── Usugumo C.sln
├── Usugumo C.vcxproj
├── Usugumo C.vcxproj.filters
├── Usugumo.c
├── UsugumoC.inf
├── anti_capture.c
├── anti_capture.h
├── common.h
├── defines.h
├── helper_utils.asm
├── helpers.c
├── helpers.h
├── imports.h
├── ke_reimpl.asm
├── keybd_operation.c
├── keybd_operation.h
├── kmem.asm
├── mouse.asm
├── mouse_operation.c
├── mouse_operation.h
├── process.c
├── process.h
├── reimpl.c
├── reimpl.h
├── request_handler.h
├── requst_handler.c
├── rtl_reimpl.asm
└── usugumo_request_define.h

```

`Dispatches.c`:

```c
#include "./common.h"

NTSTATUS DefaultDispatch(PDEVICE_OBJECT device_obj, PIRP irp) {
  UNREFERENCED_PARAMETER(device_obj);
  UNREFERENCED_PARAMETER(irp);
  irp->IoStatus.Status = STATUS_SUCCESS;
  irp->IoStatus.Information = 0;
  IoCompleteRequest(irp, IO_NO_INCREMENT);
  return STATUS_SUCCESS;
}

NTSTATUS WriteDispatch(PDEVICE_OBJECT device_obj, PIRP irp) {
  UNREFERENCED_PARAMETER(device_obj);
  PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(irp);
  ULONG write_len = stack->Parameters.Write.Length;

  irp->IoStatus.Status = STATUS_SUCCESS;
  irp->IoStatus.Information = 0;

  PMDL pMdl = irp->MdlAddress;
  if (pMdl == NULL) {
    irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return irp->IoStatus.Status;
  }

  PRequests pRequest =
      (PRequests)MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);
  if (pRequest == NULL) {
    irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return irp->IoStatus.Status;
  }

  if (write_len >= sizeof(Requests)) {
    if (RequestHandler(pRequest)) {
      irp->IoStatus.Information = sizeof(Requests);
      irp->IoStatus.Status = STATUS_SUCCESS;
    } else {
      irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    }
  } else {
    irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
  }

  IoCompleteRequest(irp, IO_NO_INCREMENT);
  return irp->IoStatus.Status;
}

NTSTATUS ReadDispatch(PDEVICE_OBJECT device_obj, PIRP irp) {
  UNREFERENCED_PARAMETER(device_obj);
  PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(irp);
  ULONG read_len = stack->Parameters.Read.Length;

  irp->IoStatus.Status = STATUS_SUCCESS;
  irp->IoStatus.Information = 0;

  PMDL pMdl = irp->MdlAddress;
  if (pMdl == NULL) {
    irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return irp->IoStatus.Status;
  }

  PRequests pRequest =
      (PRequests)MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);
  if (pRequest == NULL) {
    irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return irp->IoStatus.Status;
  }

  if (read_len >= sizeof(Requests)) {
    irp->IoStatus.Information = sizeof(Requests);
    irp->IoStatus.Status = STATUS_SUCCESS;
  } else {
    irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
  }

  IoCompleteRequest(irp, IO_NO_INCREMENT);
  return irp->IoStatus.Status;
}

```

`Dispatches.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _DISPATCHES_H_
#define _DISPATCHES_H_
#include "./imports.h"

NTSTATUS DefaultDispatch(PDEVICE_OBJECT, PIRP);

NTSTATUS WriteDispatch(PDEVICE_OBJECT, PIRP);

NTSTATUS ReadDispatch(PDEVICE_OBJECT, PIRP);

#endif

```

`Examples/CallDriver.cc`:

```cc
// Copyright (c) 2026 渟雲. All rights reserved.
#include <Windows.h>
#include <string>
#include <iostream>
#include <thread>
#include <atomic>
#include <memory>
#include <string_view>

#include "./includes/operation.h"

using WindowHandle = HWND;
using ThreadHandle = HANDLE;
using EventHandle = HANDLE;
using Address = uintptr_t;
using SizeType = size_t;

constexpr inline DWORD WINDOW_CREATION_TIMEOUT = 5000u;
constexpr inline DWORD THREAD_WAIT_TIMEOUT = 1000u;
constexpr inline DWORD DESTROY_WINDOW_TIMEOUT = 5000u;
constexpr inline UINT WINDOW_WIDTH = 200u;
constexpr inline UINT WINDOW_HEIGHT = 150u;
constexpr inline Address TEST_MEMORY_ADDR = 0xDEAD0000ULL;
constexpr inline uint64_t TEST_WRITE_VALUE = 0x1919810ULL;
constexpr inline std::string_view WINDOW_CLASS_NAME = "TestWindowClass";
constexpr inline std::string_view WINDOW_TITLE = "Test";
constexpr inline std::wstring_view TARGET_PROCESS_NAME = L"Target.exe";
constexpr inline std::string_view SCAN_PATTERN = "AA BB CC DD ?? ?? ?? ?? 11 22 33 44";

struct HandleDeleter {
    void operator()(HANDLE h) const noexcept {
        if (h != nullptr && h != INVALID_HANDLE_VALUE) {
            CloseHandle(h);
        }
    }
};

using UniqueThreadPtr = std::unique_ptr<void, HandleDeleter>;
using UniqueEventPtr = std::unique_ptr<void, HandleDeleter>;

struct WindowData {
    WindowHandle hwnd = nullptr;
    std::atomic<bool> windowReady{false};
    std::atomic<bool> windowRunning{true};
    UniqueEventPtr windowReadyEvent;
};

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    WindowData* windowData = reinterpret_cast<WindowData*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));

    switch (uMsg) {
        case WM_CREATE: {
            CREATESTRUCT* createStruct = reinterpret_cast<CREATESTRUCT*>(lParam);
            WindowData* data = reinterpret_cast<WindowData*>(createStruct->lpCreateParams);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(data));
            return 0;
        }

        case WM_SYSCOMMAND: {
            if (wParam == SC_CLOSE) {
                if (windowData && windowData->windowRunning.load()) {
                    return 0;
                }
            }
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }

        case WM_CLOSE: {
            if (windowData && windowData->windowRunning.load()) {
                return 0;
            }
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }

        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;

        case WM_PAINT: {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);
            FillRect(hdc, &ps.rcPaint, (HBRUSH)(COLOR_WINDOW + 1));
            EndPaint(hwnd, &ps);
            return 0;
        }

        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

DWORD WINAPI WindowThreadProc(LPVOID lpParameter) noexcept {
    WindowData* windowData = static_cast<WindowData*>(lpParameter);
    if (!windowData) {
        return 1;
    }

    WNDCLASSA wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = WINDOW_CLASS_NAME.data();
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    
    if (!RegisterClassA(&wc)) {
        printf("Failed to register window class in thread. Error: %lu\n", GetLastError());
        windowData->windowReady = false;
        if (windowData->windowReadyEvent) {
            SetEvent(windowData->windowReadyEvent.get());
        }
        return 1;
    }
    
    WindowHandle hwnd = CreateWindowExA(
        0,
        WINDOW_CLASS_NAME.data(),
        WINDOW_TITLE.data(),
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, WINDOW_WIDTH, WINDOW_HEIGHT,
        NULL,
        NULL,
        GetModuleHandle(NULL),
        windowData
    );
    
    if (!hwnd) {
        printf("Failed to create window in thread. Error: %lu\n", GetLastError());
        windowData->windowReady = false;
        if (windowData->windowReadyEvent) {
            SetEvent(windowData->windowReadyEvent.get());
        }
        return 1;
    }
    
    windowData->hwnd = hwnd;
    windowData->windowReady = true;
    if (windowData->windowReadyEvent) {
        SetEvent(windowData->windowReadyEvent.get());
    }
    
    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);
    
    MSG msg;
    while (windowData->windowRunning) {
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            if (msg.message == WM_QUIT) {
                break;
            }
            
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        else {
            Sleep(1);
        }
    }
    
    if (IsWindow(hwnd)) {
        DestroyWindow(hwnd);
    }

    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    
    UnregisterClassA(WINDOW_CLASS_NAME.data(), GetModuleHandle(NULL));
    
    return 0;
}

UniqueThreadPtr CreateWindowThread(WindowData& windowData) noexcept {
    windowData.windowReadyEvent = UniqueEventPtr(
        CreateEvent(NULL, TRUE, FALSE, NULL),
        HandleDeleter()
    );
    if (!windowData.windowReadyEvent) {
        printf("Failed to create window ready event. Error: %lu\n", GetLastError());
        return nullptr;
    }
    
    DWORD threadId;
    ThreadHandle threadHandle = CreateThread(
        NULL,
        0,
        WindowThreadProc,
        &windowData,
        0,
        &threadId
    );
    
    if (!threadHandle) {
        printf("Failed to create window thread. Error: %lu\n", GetLastError());
        windowData.windowReadyEvent.reset();
        return nullptr;
    }
    
    WaitForSingleObject(windowData.windowReadyEvent.get(), WINDOW_CREATION_TIMEOUT);
    
    if (!windowData.windowReady) {
        printf("Window creation failed or timeout.\n");
        windowData.windowRunning = false;
        WaitForSingleObject(threadHandle, THREAD_WAIT_TIMEOUT);
        CloseHandle(threadHandle);
        windowData.windowReadyEvent.reset();
        return nullptr;
    }
    
    printf("Window created successfully in thread. HWND: 0x%p\n", windowData.hwnd);
    
    return UniqueThreadPtr(threadHandle, HandleDeleter());
}

int main() {
    WindowData windowData;
    
    UniqueThreadPtr windowThread = CreateWindowThread(windowData);
    if (!windowThread) {
        printf("Failed to create window thread.\n");
        system("pause");
        return 1;
    }
    
    Operation op;
    
#ifdef USING_USUGUMO
    if (!op.DriverProbe()) {
        printf("Driver probe failed\n");
        windowData.windowRunning = false;
        DWORD threadId = GetThreadId(reinterpret_cast<HANDLE>(windowThread.get()));
        if (threadId != 0) {
            PostThreadMessage(threadId, WM_QUIT, 0, 0);
        }
        WaitForSingleObject(windowThread.get(), THREAD_WAIT_TIMEOUT);
        system("pause");
        return 1;
    }
    printf("Driver probe success\n");
#else
    printf("Using native api\n");
#endif

    if (!op.Init(TARGET_PROCESS_NAME)) {
        printf("Failed to initialize\n");
        windowData.windowRunning = false;
        DWORD threadId = GetThreadId(reinterpret_cast<HANDLE>(windowThread.get()));
        if (threadId != 0) {
            PostThreadMessage(threadId, WM_QUIT, 0, 0);
        }
        WaitForSingleObject(windowThread.get(), THREAD_WAIT_TIMEOUT);
        system("pause");
        return 1;
    }
#ifdef USING_USUGUMO
    printf("Driver handle created 0x%p\n", op.GetDriverHandle());
#else
    printf("Process handle created 0x%p\n", op.GetProcessHandle());
#endif
    std::string targetProcessNameNarrow(TARGET_PROCESS_NAME.begin(), TARGET_PROCESS_NAME.end());
    uint64_t base_address = 0;
    uint64_t module_size = 0;
    if (!op.GetModuleInfo(targetProcessNameNarrow.c_str(), &base_address, &module_size)) {
        printf("Failed to get module info\n");
        windowData.windowRunning = false;
        DWORD threadId = GetThreadId(reinterpret_cast<HANDLE>(windowThread.get()));
        if (threadId != 0) {
            PostThreadMessage(threadId, WM_QUIT, 0, 0);
        }
        WaitForSingleObject(windowThread.get(), THREAD_WAIT_TIMEOUT);
        system("pause");
        return 1;
    }
    
    printf("Module base: 0x%llX, size: 0x%llX\n", base_address, module_size);

    Address found = op.PatternScanSize(base_address, module_size, SCAN_PATTERN.data());
    printf("Pattern '%s' found at: 0x%llX\n", SCAN_PATTERN.data(), found);

    uint64_t target_var = 0;
    if (!op.Read<uint64_t>(TEST_MEMORY_ADDR, &target_var)) {
        printf("Failed to read memory\n");
    } else {
        printf("Read target_var = 0x%llX at 0x%llX\n", target_var, TEST_MEMORY_ADDR);
    }
    
    if (!op.Write<uint64_t>(TEST_MEMORY_ADDR, TEST_WRITE_VALUE, sizeof(uint64_t))) {
        printf("Failed to write memory\n");
    } else {
        printf("Written 0x%llX to 0x%llX\n", TEST_WRITE_VALUE, TEST_MEMORY_ADDR);
    }
    
    if (op.Read<uint64_t>(TEST_MEMORY_ADDR, &target_var)) {
        printf("Read back target_var = 0x%llX\n", target_var);
    }
    
    printf("Waiting 3 second then mouse left down...\n");
    Sleep(3000);
    
    op.MouseLeftDown();
    printf("Waiting 1 second then mouse left up...\n");
    Sleep(1000);
    op.MouseLeftUp();
    
    printf("Waiting 3 second then move mouse (100, -100)...\n");
    Sleep(3000);
    op.MouseMove(100, -100);
    
    printf("Waiting 3 second then set cursor position (500, 500)...\n");
    Sleep(3000);
    op.SetCursorPos(500, 500);

    printf("Waiting 1 second then press VK_LWIN...\n");
    Sleep(1000);
    op.KeybdEvent(VK_LWIN, 0, 0, 0);
    Sleep(100);
    op.KeybdEvent(VK_LWIN, 0, KEYEVENTF_KEYUP, 0);

    printf("Waiting 1 second then anti capture test window...\n");
    Sleep(1000);
    
    if (windowData.hwnd && IsWindow(windowData.hwnd)) {
        op.AntiCapture(windowData.hwnd);
        printf("Anti capture applied to window.\n");
    } else {
        printf("Window handle is invalid.\n");
    }

    printf("Waiting input then undo anti capture test window...\n");
    system("pause");
    
    if (windowData.hwnd && IsWindow(windowData.hwnd)) {
        op.AntiCapture(windowData.hwnd, false);
        printf("Anti capture removed from window.\n");
    }

    printf("Waiting 3 second then destroy test window...\n");
    Sleep(3000);
    
    windowData.windowRunning = false;
    if (windowData.hwnd && IsWindow(windowData.hwnd)) {
        PostMessage(windowData.hwnd, WM_CLOSE, 0, 0);
    }
    
    WaitForSingleObject(windowThread.get(), DESTROY_WINDOW_TIMEOUT);
    
    printf("Done\n");
    
    system("pause");
    return 0;
}

```

`Examples/Target.cc`:

```cc
// Copyright (c) 2026 渟雲. All rights reserved.
#include <windows.h>
#include <iostream>
#include <iomanip>
#include <cstring>
#include <memory>

using Address = uintptr_t;
using SizeType = size_t;
using Dword64 = DWORD64;
using VolatileDword64Ptr = volatile Dword64*;

constexpr inline Address TARGET_BASE_ADDRESS = 0xDEAD0000ULL;
constexpr inline SizeType ALLOC_MEM_SIZE = sizeof(Dword64);
constexpr inline Dword64 INIT_VAR_VALUE = 0x114514ULL;
constexpr inline SizeType PATTERN_LENGTH = 12u;
constexpr inline DWORD MEM_PROTECTION = PAGE_READWRITE;
constexpr inline DWORD MEM_ALLOC_FLAGS = MEM_COMMIT | MEM_RESERVE;

struct VirtualMemDeleter {
    void operator()(BYTE* p) const noexcept {
        if (p != nullptr) {
            VirtualFree(p, 0, MEM_RELEASE);
        }
    }
};

using UniqueVirtualMemPtr = std::unique_ptr<BYTE, VirtualMemDeleter>;

int main() {
    UniqueVirtualMemPtr allocatedMem(
        reinterpret_cast<BYTE*>(
            VirtualAlloc(
                reinterpret_cast<LPVOID>(TARGET_BASE_ADDRESS),
                ALLOC_MEM_SIZE,
                MEM_ALLOC_FLAGS,
                MEM_PROTECTION
            )
        ),
        VirtualMemDeleter()
    );

    if (!allocatedMem) {
        std::cerr << "Failed to allocate first memory block" << std::endl;
        system("pause");
        return 1;
    }

    VolatileDword64Ptr fixedVar = reinterpret_cast<VolatileDword64Ptr>(allocatedMem.get());
    *fixedVar = INIT_VAR_VALUE;

    static const unsigned char pattern[PATTERN_LENGTH] = {
        0xAA, 0xBB, 0xCC, 0xDD, 0xDE, 0xAD,
        0xBE, 0xFF, 0x11, 0x22, 0x33, 0x44
    };

    std::cout << "\nTarget var at 0x" << std::hex << std::uppercase
              << reinterpret_cast<Address>(fixedVar)
              << " = 0x" << *fixedVar
              << std::nouppercase << std::dec << std::endl;

    std::cout << "Target pattern at 0x" << std::hex << std::uppercase
              << reinterpret_cast<Address>(&pattern)
              << " = ";
    for (SizeType i = 0; i < PATTERN_LENGTH; i++) {
        std::cout << std::setw(2) << std::setfill('0') << std::hex << std::uppercase
                  << static_cast<int>(pattern[i]) << " ";
    }
    std::cout << std::nouppercase << std::dec << std::endl;

    while (true) {
        std::cout << "\nTarget var at 0x" << std::hex << std::uppercase
                  << reinterpret_cast<Address>(fixedVar)
                  << " = 0x" << *fixedVar
                  << std::nouppercase << std::dec << std::endl;

        system("pause");
    }

    return 0;
}

```

`Examples/build.bat`:

```bat
call g++ -static -O2 -std=c++23 Target.cc -o Target.exe
call g++ -static -O2 -std=c++23 -DUSING_USUGUMO -I. CallDriver.cc -o CallDriver.exe -lwinmm -lgdi32
call g++ -static -O2 -std=c++23 -I. CallDriver.cc -o Native.exe -lwinmm -lgdi32
```

`Examples/includes/keybd_input_injection.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _KEYBD_INPUT_INJECTION_H_
#define _KEYBD_INPUT_INJECTION_H_
#include <Windows.h>

#include <iostream>

class KeyboardInterface {
 private:
  using NtUserInjectKeyboardInput_t = void(WINAPI*)(KEYBDINPUT*, int);
  NtUserInjectKeyboardInput_t nt_user_inject_keyboard_input_ = nullptr;

 public:
  KeyboardInterface() {
    LoadLibraryW(L"user32.dll");
    HMODULE win32u_module = LoadLibraryW(L"win32u.dll");
    if (!win32u_module) {
      std::cerr << "[-] Could not load win32u.dll\n";
      return;
    }
    nt_user_inject_keyboard_input_ =
        reinterpret_cast<NtUserInjectKeyboardInput_t>(
            GetProcAddress(win32u_module, "NtUserInjectKeyboardInput"));
    if (!nt_user_inject_keyboard_input_) {
      std::cerr << "[-] Could not locate NtUserInjectKeyboardInput\n";
    }
  }

  inline bool sendEvent(const KEYBDINPUT& info) {
    if (nt_user_inject_keyboard_input_) {
      nt_user_inject_keyboard_input_(const_cast<KEYBDINPUT*>(&info), 1);
      return true;
    }
    return false;
  }
};

inline void my_keybd_event(BYTE vk, BYTE scan, DWORD flags,
                           ULONG_PTR dw_extra_info) {
  static KeyboardInterface keyboard_interface;

  KEYBDINPUT event = {};
  event.wVk = vk;
  event.wScan = scan;
  event.dwFlags = flags;
  event.time = 0;
  event.dwExtraInfo = dw_extra_info;

  keyboard_interface.sendEvent(event);
}
#endif

```

`Examples/includes/mouse_input_injection.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _MOUSE_INPUT_INJECTION_H_
#define _MOUSE_INPUT_INJECTION_H_
#include <Windows.h>
#include <iostream>

class MouseInterface {
private:
    using NtUserInjectMouseInput_t = bool (*)(MOUSEINPUT*, int);
    NtUserInjectMouseInput_t nt_user_inject_mouse_input_ = nullptr;

public:
    MouseInterface() {
        LoadLibraryW(L"user32.dll");
        HMODULE win32u_module = LoadLibraryW(L"win32u.dll");
        if (!win32u_module) {
            std::cerr << "[-] Could not load win32u.dll\n";
            return;
        }
        nt_user_inject_mouse_input_ =
            reinterpret_cast<NtUserInjectMouseInput_t>(
                GetProcAddress(win32u_module, "NtUserInjectMouseInput"));
        if (!nt_user_inject_mouse_input_) {
            std::cerr << "[-] Could not locate NtUserInjectMouseInput\n";
        }
    }

    inline bool sendEvent(const MOUSEINPUT& info) {
        if (nt_user_inject_mouse_input_) {
            return nt_user_inject_mouse_input_(
                const_cast<MOUSEINPUT*>(&info), 1);
        }
        return false;
    }
};

inline void my_mouse_event(DWORD dw_flags, LONG dx, LONG dy, DWORD dw_data,
                           ULONG_PTR dw_extra_info) {
    static MouseInterface mouse_interface;

    MOUSEINPUT event = {};
    event.dx = dx;
    event.dy = dy;
    event.mouseData = dw_data;
    event.dwFlags = dw_flags;
    event.time = 0;
    event.dwExtraInfo = dw_extra_info;

    mouse_interface.sendEvent(event);
}
#endif

```

`Examples/includes/native.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _NATIVE_H_
#define _NATIVE_H_
#include <Windows.h>

#include <cstdint>
#include <string>
#include <algorithm>
#include <string_view>
#include <memory>
#include <unordered_map>
#include <type_traits>

#include "./mouse_input_injection.h"
#include "./keybd_input_injection.h"
#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif
#ifndef STATUS_UNSUCCESSFUL
#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)
#endif
#ifndef STATUS_INFO_LENGTH_MISMATCH
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)
#endif

constexpr inline size_t kIndirectSyscallSize = 22uz;
constexpr inline size_t kSNtFuncMaxSize = 64uz; // usually wont exceed 64 bytes
constexpr inline ULONG kDefaultBufferSize = 0x10000u;

typedef struct _UNICODE_STRING UNICODE_STRING, *PUNICODE_STRING;
typedef struct _CLIENT_ID CLIENT_ID, *PCLIENT_ID;
typedef struct _OBJECT_ATTRIBUTES OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;
typedef struct _PROCESS_BASIC_INFORMATION PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;
typedef struct _PEB_LDR_DATA PEB_LDR_DATA, *PPEB_LDR_DATA;
typedef struct _LDR_DATA_TABLE_ENTRY LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;
typedef struct _PEB PEB, *PPEB;
typedef struct _SYSTEM_PROCESS_INFORMATION SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

struct SyscallInfo {
    ULONG syscallNum;
    uintptr_t syscallAddr;
    void* funcPtr;
};

typedef NTSTATUS(WINAPI* pNtAllocateVirtualMemory)(
    HANDLE ProcessHandle,
    PVOID* BaseAddress,
    ULONG ZeroBits,
    PSIZE_T RegionSize,
    ULONG AllocationType,
    ULONG Protect
);
static pNtAllocateVirtualMemory pfnNtAllocateVirtualMemory = nullptr;

typedef NTSTATUS(WINAPI* pNtProtectVirtualMemory)(
    HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T NumberOfBytesToProtect,
    ULONG NewAccessProtection, PULONG OldAccessProtection);
static pNtProtectVirtualMemory pfnNtProtectVirtualMemory = nullptr;

typedef NTSTATUS(WINAPI* pNtFreeVirtualMemory)(
    HANDLE ProcessHandle, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
static pNtFreeVirtualMemory pfnNtFreeVirtualMemory = nullptr;


typedef NTSTATUS(NTAPI* _NtOpenProcess)(PHANDLE ProcessHandle,
                                        ACCESS_MASK DesiredAccess,
                                        POBJECT_ATTRIBUTES ObjectAttributes,
                                        PCLIENT_ID ClientId);
static _NtOpenProcess pfnNtOpenProcess = nullptr;

typedef NTSTATUS(WINAPI* pNtReadVirtualMemory)(HANDLE ProcessHandle,
                                               PVOID BaseAddress, PVOID Buffer,
                                               ULONG NumberOfBytesToRead,
                                               PULONG NumberOfBytesRead);
static pNtReadVirtualMemory pfnNtReadVirtualMemory = nullptr;

typedef NTSTATUS(WINAPI* pNtWriteVirtualMemory)(HANDLE ProcessHandle,
                                                PVOID BaseAddress, PVOID Buffer,
                                                ULONG NumberOfBytesToWrite,
                                                PULONG NumberOfBytesWritten);
static pNtWriteVirtualMemory pfnNtWriteVirtualMemory = nullptr;

constexpr PROCESS_INFORMATION_CLASS ProcessBasicInformation = (PROCESS_INFORMATION_CLASS)0;  // retarded
typedef NTSTATUS(WINAPI* pNtQueryInformationProcess)(
    HANDLE ProcessHandle,
    PROCESS_INFORMATION_CLASS ProcessInformationClass,
    PVOID ProcessInformation,
    ULONG ProcessInformationLength,
    PULONG ReturnLength
);
static pNtQueryInformationProcess pfnNtQueryInformationProcess = nullptr;

typedef NTSTATUS(WINAPI* pNtQuerySystemInformation)(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);
static pNtQuerySystemInformation pfnNtQuerySystemInformation = nullptr;

typedef BOOL(WINAPI* pNtUserSetWindowDisplayAffinity)(
    HWND hWnd, DWORD dwAffinity
);
static pNtUserSetWindowDisplayAffinity pfnNtUserSetWindowDisplayAffinity = nullptr;

/* 
.text:0000000180162070 ; Exported entry 451. NtOpenProcess
.text:0000000180162070 ; Exported entry 2098. ZwOpenProcess
.text:0000000180162070
.text:0000000180162070 ; =============== S U B R O U T I N E =======================================
.text:0000000180162070
.text:0000000180162070 ; Alternative name is 'NtOpenProcess'
.text:0000000180162070
.text:0000000180162070 ; __int64 NtOpenProcess()
.text:0000000180162070                 public NtOpenProcess
.text:0000000180162070 NtOpenProcess   proc near               ; CODE XREF: RtlQueryProcessDebugInformation+17A↑p
.text:0000000180162070                                         ; RtlQueryProcessDebugInformation+22F↑p ...
.text:0000000180162070                 mov     r10, rcx        ; NtOpenProcess
.text:0000000180162073                 mov     eax, 26h ; '&'
.text:0000000180162078                 test    byte ptr ds:7FFE0308h, 1
.text:0000000180162080                 jnz     short loc_180162085
.text:0000000180162082                 syscall                 ; Low latency system call
.text:0000000180162084                 retn
.text:0000000180162085 ; ---------------------------------------------------------------------------
.text:0000000180162085
.text:0000000180162085 loc_180162085:                          ; CODE XREF: NtOpenProcess+10↑j
.text:0000000180162085                 int     2Eh             ; DOS 2+ internal - EXECUTE COMMAND
.text:0000000180162085                                         ; DS:SI -> counted CR-terminated command string
.text:0000000180162087                 retn
.text:0000000180162087 NtOpenProcess   endp
 */
static const BYTE g_IndirectSyscallTemplate[] = {
    // here we construct our syscall
    0x4C, 0x8B, 0xD1,       // mov r10, rcx
    0xB8, 0x00, 0x00, 0x00, 0x00, // mov eax, SSN (4 bytes)
    // here we jump to syscall in the function
    0xFF, 0x25, 0x00, 0x00, 0x00, 0x00, // jmp [rip] (6 bytes)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // syscall addr (8 bytes)
};

struct _UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWCH Buffer;
};

struct _CLIENT_ID {
  PVOID UniqueProcess;
  PVOID UniqueThread;
};

struct _OBJECT_ATTRIBUTES {
  ULONG Length;
  HANDLE RootDirectory;
  PUNICODE_STRING ObjectName;
  ULONG Attributes;
  PVOID SecurityDescriptor;
  PVOID SecurityQualityOfService;
};

struct _PROCESS_BASIC_INFORMATION {
    PVOID Reserved1;
    PVOID PebBaseAddress;
    PVOID Reserved2[2];
    ULONG_PTR UniqueProcessId;
    PVOID Reserved3;
};

struct _PEB_LDR_DATA {
    ULONG Length;
    BOOLEAN Initialized;
    PVOID SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
};

struct _LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    WORD LoadCount;
    WORD TlsIndex;
    LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
};

struct _PEB {
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    BOOLEAN Spare;
    PVOID Mutant;
    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
};

struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    ULONG_PTR WorkingSetPrivateSize;
    ULONG HardFaultCount;
    ULONG NumberOfThreadsHighWatermark;
    ULONGLONG CycleTime;
    ULONG_PTR CreateTime;
    ULONG_PTR UserTime;
    ULONG_PTR KernelTime;
    UNICODE_STRING ImageName;
    ULONG BasePriority;
    HANDLE ProcessId;
    HANDLE InheritedFromProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR PageDirectoryBase;
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
};

#define XXH_ROTL64(x, r) ((x) << (r)) | ((x) >> (64 - (r)))

inline constexpr std::uint32_t xxh3_32_core(const char* data, std::size_t len, std::uint32_t seed) noexcept {
  constexpr std::uint64_t P1 = 0x9E3779B185EBCA87ULL;
  constexpr std::uint64_t P2 = 0xC2B2AE3D27D4EB4FULL;
  constexpr std::uint64_t P3 = 0x165667B19E3779F9ULL;
  constexpr std::uint64_t P4 = 0x85EBCA77C2B2AE63ULL;

  std::uint64_t h = (static_cast<std::uint64_t>(seed) * P3) + static_cast<std::uint64_t>(len) + P4;

  for (std::size_t i = 0; i < len; ++i) {
    std::uint64_t byte_val = static_cast<std::uint64_t>(static_cast<unsigned char>(data[i]));
    std::uint64_t mix_val = h + (byte_val * P2);
    mix_val = XXH_ROTL64(mix_val, 31);
    mix_val *= P1;

    h ^= mix_val;
    h = XXH_ROTL64(h, 27) * P1 + P4;
  }

  h ^= static_cast<std::uint64_t>(len);
  h *= P1;
  h ^= h >> 33;
  h *= P1;
  h ^= h >> 29;

  return static_cast<std::uint32_t>(h) ^ static_cast<std::uint32_t>(h >> 32);
}

inline consteval std::uint32_t xxh3_32(const char* data, std::size_t len, std::uint32_t seed = 0) noexcept {
  return xxh3_32_core(data, len, seed);
}

inline std::uint32_t xxh3_32_rt(const char* data, std::size_t len, std::uint32_t seed = 0) noexcept {
  return xxh3_32_core(data, len, seed);
}

#define HASH_STR(s) xxh3_32(s, sizeof(s) - 1)

#undef XXH_ROTL64

static std::unordered_map<uint32_t, SyscallInfo> g_SyscallInfoMap;

using Address = uintptr_t;
using SizeType = size_t;
using ProcessId = DWORD;
using ProcessHandle = HANDLE;
using SyscallNum = ULONG;

struct VirtualMemDeleter {
    void operator()(PBYTE p) const noexcept {
        if (p != nullptr) {
            // Use NtFreeVirtualMemory if available, otherwise use VirtualFree
            if (pfnNtFreeVirtualMemory) {
                pfnNtFreeVirtualMemory(GetCurrentProcess(), &p, 0, MEM_RELEASE);
            } else {
                VirtualFree(p, 0, MEM_RELEASE);
            }
        }
    }
};

using UniqueVirtualMemPtr = std::unique_ptr<BYTE, VirtualMemDeleter>;

using UniqueLdrEntryPtr = std::unique_ptr<LDR_DATA_TABLE_ENTRY>;

static bool FindSyscallInstruction(PBYTE pFuncBytes, ULONG funcSearchSize, uintptr_t& syscallAddr) noexcept
{
    if (!pFuncBytes || funcSearchSize < 2)
        return false;

    for (ULONG i = 0; i <= funcSearchSize - 2; i++)
    {
        if (pFuncBytes[i] == 0x0F && pFuncBytes[i+1] == 0x05)
        {
            syscallAddr = reinterpret_cast<uintptr_t>(pFuncBytes + i);
            return true;
        }
    }
    return false;
}

static bool IsFunctionHooked(PBYTE pFuncBytes) noexcept
{
    if (!pFuncBytes) return false;
    
    if (pFuncBytes[0] == 0xE9) { // jmp
        return true;
    }
    
    if (pFuncBytes[0] == 0xFF && pFuncBytes[1] == 0x25) { // jmp [rip+imm32]
        return true;
    }
    
    return false;
}

template <typename FuncPtr>
static FuncPtr ConstructIndirectSyscall(ULONG syscallNum, uintptr_t syscallAddr) noexcept
{
    // here we direct called VirtualAlloc/Protect
    // any way better but wont cause DEP issue?
    if (syscallNum == 0 || syscallAddr == 0) {
        return nullptr;
    }

    PVOID pAllocBase = nullptr;
    SIZE_T allocSize = sizeof(g_IndirectSyscallTemplate);
    NTSTATUS allocStatus = STATUS_UNSUCCESSFUL;
    if (pfnNtAllocateVirtualMemory)
    {
        allocStatus = pfnNtAllocateVirtualMemory(
            GetCurrentProcess(),
            &pAllocBase,
            0,
            &allocSize,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE
        );
    } else {
    // fall back to VirtualAlloc for construct NtAllocateVirtualMemory it self.
        pAllocBase = VirtualAlloc(nullptr, sizeof(g_IndirectSyscallTemplate), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!pAllocBase) {
            return nullptr;
        }
    }

    UniqueVirtualMemPtr pMem((PBYTE)pAllocBase);
    if (!pMem) {
        return nullptr;
    }

    memcpy(pMem.get(), g_IndirectSyscallTemplate, sizeof(g_IndirectSyscallTemplate));
    
    memcpy(pMem.get() + 4, &syscallNum, 4);
    
    memcpy(pMem.get() + 14, &syscallAddr, 8);
    
    DWORD oldProtect = 0;
    PVOID pProtectBase = pMem.get();
    SIZE_T protectSize = sizeof(g_IndirectSyscallTemplate);
    NTSTATUS protectStatus = STATUS_UNSUCCESSFUL;
    if (pfnNtProtectVirtualMemory)
    {
        protectStatus = pfnNtProtectVirtualMemory(
            GetCurrentProcess(),
            &pProtectBase,
            &protectSize,
            PAGE_EXECUTE_READ,
            &oldProtect
        );
    } else {
    // fall back to VirtualProtect for construct NtProtectVirtualMemory it self.
        if (!VirtualProtect(pMem.get(), sizeof(g_IndirectSyscallTemplate), PAGE_EXECUTE_READ, &oldProtect)) {
            return nullptr;
        }
    }
    
    FlushInstructionCache(GetCurrentProcess(), pMem.get(), sizeof(g_IndirectSyscallTemplate));
    
    return reinterpret_cast<FuncPtr>(pMem.release());
}

static void ParseModuleForSyscalls(HMODULE hModule) noexcept
{
    if (!hModule) {
        return;
    }

    PBYTE pModuleBase = reinterpret_cast<PBYTE>(hModule);

    PIMAGE_DOS_HEADER pDosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(pModuleBase);
    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        return;
    }

    PIMAGE_NT_HEADERS pNtHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(pModuleBase + pDosHeader->e_lfanew);
    if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
        return;
    }

    IMAGE_DATA_DIRECTORY exportDir = pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
    if (exportDir.VirtualAddress == 0 || exportDir.Size == 0) {
        return;
    }

    PIMAGE_EXPORT_DIRECTORY pExportDir = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(pModuleBase + exportDir.VirtualAddress);

    PDWORD pFuncNames = reinterpret_cast<PDWORD>(pModuleBase + pExportDir->AddressOfNames);
    PDWORD pFuncAddrs = reinterpret_cast<PDWORD>(pModuleBase + pExportDir->AddressOfFunctions);
    PWORD pFuncOrdinals = reinterpret_cast<PWORD>(pModuleBase + pExportDir->AddressOfNameOrdinals);

    for (DWORD i = 0; i < pExportDir->NumberOfNames; i++) {
        const char* pFuncName = reinterpret_cast<const char*>(pModuleBase + pFuncNames[i]);
        // Nt or Zw is 100% same in user mode, 
        // but we only care about Nt functions
        // skip just for performance
        // there are not "Zw only" functions in user mode
        // but there are "Nt only" functions, yes
        if (strncmp(pFuncName, "Nt", 2) != 0 || strncmp(pFuncName, "Zw", 2) == 0) {
            continue;
        }

        DWORD funcRVA = pFuncAddrs[pFuncOrdinals[i]];
        if (funcRVA == 0) {
            continue;
        }

        PBYTE pFuncBytes = pModuleBase + funcRVA;

        if (IsFunctionHooked(pFuncBytes)) {
            // incase of hooked, skip this function
            // anyway, usermode EDR/AV/AC should cant hook these functions
            continue;
        }

        // mov r10, rcx; mov eax, syscallNum
        if (pFuncBytes[0] != 0x4C || pFuncBytes[1] != 0x8B || pFuncBytes[2] != 0xD1 || pFuncBytes[3] != 0xB8) {
            continue;
        }

        ULONG syscallNum = *reinterpret_cast<ULONG*>(pFuncBytes + 4);
        if (syscallNum == 0) {
            continue;
        }

        uintptr_t syscallAddr = 0;
        if (!FindSyscallInstruction(pFuncBytes, kSNtFuncMaxSize, syscallAddr)) {
            continue;
        }

        SyscallInfo info;
        info.syscallNum = syscallNum;
        info.syscallAddr = syscallAddr;
        info.funcPtr = nullptr;

        uint32_t funcHash = xxh3_32_rt(pFuncName, strlen(pFuncName));
        g_SyscallInfoMap[funcHash] = info;
    }
}

static void ManualSysCall_Init() noexcept
{
    HMODULE hNtdll = GetModuleHandleW(L"ntdll.dll");
    ParseModuleForSyscalls(hNtdll);

    HMODULE hWin32u = GetModuleHandleW(L"win32u.dll");
    if (!hWin32u) {
        // If win32u.dll is not loaded, we will try to load it manually.
        // for applications with window, this should be always loaded
        hWin32u = LoadLibraryW(L"win32u.dll");
        ParseModuleForSyscalls(hWin32u);
        FreeLibrary(hWin32u);
    } else {
        ParseModuleForSyscalls(hWin32u);
    }

    // NtAllocateVirtualMemory and NtProtectVirtualMemory
    {
        auto it = g_SyscallInfoMap.find(HASH_STR("NtAllocateVirtualMemory"));
        if (it != g_SyscallInfoMap.end()) {
            pfnNtAllocateVirtualMemory = ConstructIndirectSyscall<pNtAllocateVirtualMemory>(
                it->second.syscallNum, it->second.syscallAddr);
            it->second.funcPtr = reinterpret_cast<void*>(pfnNtAllocateVirtualMemory);
        }
    }

    {
        auto it = g_SyscallInfoMap.find(HASH_STR("NtProtectVirtualMemory"));
        if (it != g_SyscallInfoMap.end()) {
            pfnNtProtectVirtualMemory = ConstructIndirectSyscall<pNtProtectVirtualMemory>(
                it->second.syscallNum, it->second.syscallAddr);
            it->second.funcPtr = reinterpret_cast<void*>(pfnNtProtectVirtualMemory);
        }
    }
    // if we cant find NtAllocateVirtualMemory or NtProtectVirtualMemory, 
    // we cant construct other syscalls
    if (!pfnNtAllocateVirtualMemory || !pfnNtProtectVirtualMemory) {
        return;
    }

    // NtOpenProcess
    {
        auto it = g_SyscallInfoMap.find(HASH_STR("NtOpenProcess"));
        if (it != g_SyscallInfoMap.end()) {
            pfnNtOpenProcess = ConstructIndirectSyscall<_NtOpenProcess>(
                it->second.syscallNum, it->second.syscallAddr);
            it->second.funcPtr = reinterpret_cast<void*>(pfnNtOpenProcess);
        }
    }

    // NtReadVirtualMemory
    {
        auto it = g_SyscallInfoMap.find(HASH_STR("NtReadVirtualMemory"));
        if (it != g_SyscallInfoMap.end()) {
            pfnNtReadVirtualMemory = ConstructIndirectSyscall<pNtReadVirtualMemory>(
                it->second.syscallNum, it->second.syscallAddr);
            it->second.funcPtr = reinterpret_cast<void*>(pfnNtReadVirtualMemory);
        }
    }

    // NtWriteVirtualMemory
    {
        auto it = g_SyscallInfoMap.find(HASH_STR("NtWriteVirtualMemory"));
        if (it != g_SyscallInfoMap.end()) {
            pfnNtWriteVirtualMemory = ConstructIndirectSyscall<pNtWriteVirtualMemory>(
                it->second.syscallNum, it->second.syscallAddr);
            it->second.funcPtr = reinterpret_cast<void*>(pfnNtWriteVirtualMemory);
        }
    }

    // NtQueryInformationProcess
    {
        auto it = g_SyscallInfoMap.find(HASH_STR("NtQueryInformationProcess"));
        if (it != g_SyscallInfoMap.end()) {
            pfnNtQueryInformationProcess = ConstructIndirectSyscall<pNtQueryInformationProcess>(
                it->second.syscallNum, it->second.syscallAddr);
            it->second.funcPtr = reinterpret_cast<void*>(pfnNtQueryInformationProcess);
        }
    }

    // NtQuerySystemInformation
    {
        auto it = g_SyscallInfoMap.find(HASH_STR("NtQuerySystemInformation"));
        if (it != g_SyscallInfoMap.end()) {
            pfnNtQuerySystemInformation = ConstructIndirectSyscall<pNtQuerySystemInformation>(
                it->second.syscallNum, it->second.syscallAddr);
            it->second.funcPtr = reinterpret_cast<void*>(pfnNtQuerySystemInformation);
        }
    }

    // NtUserSetWindowDisplayAffinity
    {
        auto it = g_SyscallInfoMap.find(HASH_STR("NtUserSetWindowDisplayAffinity"));
        if (it != g_SyscallInfoMap.end()) {
            pfnNtUserSetWindowDisplayAffinity = ConstructIndirectSyscall<pNtUserSetWindowDisplayAffinity>(
                it->second.syscallNum, it->second.syscallAddr);
            it->second.funcPtr = reinterpret_cast<void*>(pfnNtUserSetWindowDisplayAffinity);
        }
    }

    // NtFreeVirtualMemory
    {
        auto it = g_SyscallInfoMap.find(HASH_STR("NtFreeVirtualMemory"));
        if (it != g_SyscallInfoMap.end()) {
            pfnNtFreeVirtualMemory = ConstructIndirectSyscall<pNtFreeVirtualMemory>(
                it->second.syscallNum, it->second.syscallAddr);
            it->second.funcPtr = reinterpret_cast<void*>(pfnNtFreeVirtualMemory);
        }
    }

    // fail openprocess, nosense to use other these syscalls
    if (!pfnNtOpenProcess) {
        pfnNtReadVirtualMemory = nullptr;
        pfnNtWriteVirtualMemory = nullptr;
        pfnNtProtectVirtualMemory = nullptr;
        pfnNtQueryInformationProcess = nullptr;
        pfnNtQuerySystemInformation = nullptr;
    }

}

static bool g_ManualSysCallInited = []() noexcept {
    ManualSysCall_Init();
    return true;
}();

#undef HASH_STR

inline static OBJECT_ATTRIBUTES InitObjectAttributes(
    PUNICODE_STRING name, ULONG attributes, HANDLE hRoot,
    PSECURITY_DESCRIPTOR security) noexcept {
  OBJECT_ATTRIBUTES object;

  object.Length = sizeof(OBJECT_ATTRIBUTES);
  object.ObjectName = name;
  object.Attributes = attributes;
  object.RootDirectory = hRoot;
  object.SecurityDescriptor = security;

  return object;
}

inline static ProcessHandle NtOpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle,
                                   ProcessId dwProcessId) noexcept {
  ProcessHandle hProcess = 0;
  CLIENT_ID clientId = {(PVOID)(ULONG_PTR)dwProcessId, NULL};
  OBJECT_ATTRIBUTES objAttr = InitObjectAttributes(NULL, 0, NULL, NULL);
  if (pfnNtOpenProcess)
  {
      pfnNtOpenProcess(&hProcess, dwDesiredAccess, &objAttr, &clientId);
  }
  return hProcess;
}

inline static pNtReadVirtualMemory NtReadVirtualMemory = []() noexcept {
  return pfnNtReadVirtualMemory;
}();
inline static pNtWriteVirtualMemory NtWriteVirtualMemory = []() noexcept {
  return pfnNtWriteVirtualMemory;
}();
inline static pNtProtectVirtualMemory NtProtectVirtualMemory = []() noexcept {
  return pfnNtProtectVirtualMemory;
}();
inline static pNtQueryInformationProcess NtQueryInformationProcess = []() noexcept {
  return pfnNtQueryInformationProcess;
}();
inline static pNtQuerySystemInformation NtQuerySystemInformation = []() noexcept {
  return pfnNtQuerySystemInformation;
}();

class Native {
 public:
  Native() noexcept : target_process_handle_(nullptr), target_process_id_(0), dpi_(0) {}

  ~Native() noexcept {
    if (target_process_handle_) {
      CloseHandle(target_process_handle_);
    }
  }

  Native(const Native&) = delete;
  Native& operator=(const Native&) = delete;

  Native(Native&& other) noexcept {
    *this = std::move(other);
  }

  Native& operator=(Native&& other) noexcept {
    if (this != &other) {
      target_process_handle_ = other.target_process_handle_;
      target_process_id_ = other.target_process_id_;
      dpi_ = other.dpi_;

      other.target_process_handle_ = nullptr;
      other.target_process_id_ = 0;
      other.dpi_ = 0;
    }
    return *this;
  }

  bool Initialize(uint64_t process_id,
                  DWORD desired_access = PROCESS_ALL_ACCESS) noexcept {
    target_process_id_ = static_cast<ProcessId>(process_id);
    target_process_handle_ =
        NtOpenProcess(desired_access, FALSE, target_process_id_);
    return target_process_handle_ != nullptr;
  }

  bool Initialize(std::wstring_view process_name,
                  DWORD desired_access = PROCESS_ALL_ACCESS) noexcept {
    ProcessId pid = GetProcessIdByName(process_name);
    if (pid == 0) {
      return false;
    }
    return Initialize(static_cast<uint64_t>(pid), desired_access);
  }
  // dont askme why, ni idea. but hate this
  struct SafeULONG {
    ULONG value;
    ULONG reserved;
  };

  bool ReadMemoryNt(Address address, void* buffer, SizeType size) noexcept {
    if (!target_process_handle_ || !buffer || size == 0) return false;

    alignas(8) SafeULONG bytes_wrapper = {0, 0};
    NTSTATUS status = NtReadVirtualMemory(
        target_process_handle_, reinterpret_cast<PVOID>(address), buffer,
        static_cast<ULONG>(size), &(bytes_wrapper.value));
    return NT_SUCCESS(status) &&
           static_cast<SizeType>(bytes_wrapper.value) == size;
  }

  bool WriteMemoryNt(Address address, const void* buffer, SizeType size) noexcept {
    if (!target_process_handle_ || !buffer || size == 0) {
      return false;
    }

    PVOID pBaseAddr = reinterpret_cast<PVOID>(address);
    SIZE_T sSize = static_cast<SIZE_T>(size);
    ULONG oldProtect = 0;

    NTSTATUS status_protect =
        NtProtectVirtualMemory(target_process_handle_, &pBaseAddr, &sSize,
                               PAGE_READWRITE, &oldProtect);

    if (!NT_SUCCESS(status_protect)) {
      return false;
    }

    alignas(8) SafeULONG bytes_wrapper = {0, 0};
    NTSTATUS status_write = NtWriteVirtualMemory(
        target_process_handle_, reinterpret_cast<PVOID>(address),
        const_cast<PVOID>(buffer), static_cast<ULONG>(size),
        &(bytes_wrapper.value));

    ULONG temp = 0;
    NtProtectVirtualMemory(target_process_handle_, &pBaseAddr, &sSize,
                           oldProtect, &temp);

    return NT_SUCCESS(status_write) &&
           static_cast<SizeType>(bytes_wrapper.value) == size;
  }

  uint64_t GetDllBaseAddress(const char* dll_name) noexcept {
    if (!target_process_handle_) return 0;

    UniqueLdrEntryPtr pLdrEntry;
    if (!GetLdrDataTableEntryByName(dll_name, pLdrEntry)) {
        return 0;
    }

    return reinterpret_cast<uint64_t>(pLdrEntry->DllBase);
  }

  uint64_t GetDllSize(const char* dll_name) noexcept {
    if (!target_process_handle_) return 0;

    UniqueLdrEntryPtr pLdrEntry;
    if (!GetLdrDataTableEntryByName(dll_name, pLdrEntry)) {
        return 0;
    }

    return static_cast<uint64_t>(pLdrEntry->SizeOfImage);
  }

  void MouseEvent(DWORD flags, DWORD x, DWORD y, DWORD data,
                  ULONG_PTR extra_info) noexcept {
    LONG dx = (LONG)x;
    LONG dy = (LONG)y;

    my_mouse_event(flags, dx, dy, data, extra_info);
  }

  void MouseLeftDown() noexcept { MouseEvent(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0); }

  void MouseLeftUp() noexcept { MouseEvent(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0); }

  void MouseMove(DWORD x, DWORD y) noexcept {
    if (dpi_ == 0) dpi_ = GetSystemDPI();
    DWORD dx = (x * 100u + dpi_ / 2) / dpi_;
    DWORD dy = (y * 100u + dpi_ / 2) / dpi_;
    MouseEvent(MOUSEEVENTF_MOVE, dx, dy, 0, 0);
  }

  void SetCursorPos(DWORD x, DWORD y) noexcept {
    int screen_width = GetSystemMetrics(SM_CXSCREEN) - 1;
    int screen_height = GetSystemMetrics(SM_CYSCREEN) - 1;
    int virtual_x = (x * 65535u) / screen_width;
    int virtual_y = (y * 65535u) / screen_height;
    MouseEvent(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, virtual_x, virtual_y, 0,
               0);
  }

  void KeybdEvent(BYTE vk, BYTE scan, DWORD flags,
                           ULONG_PTR extra_info) noexcept {
    my_keybd_event(vk, scan, flags, extra_info);
  }

  void AntiCapture(HWND window_handle, bool status = true) noexcept {
    pfnNtUserSetWindowDisplayAffinity(window_handle, status ? WDA_EXCLUDEFROMCAPTURE : WDA_NONE);

    static std::unordered_map<HWND, LONG_PTR> old_ex_style;

    if (old_ex_style.find(window_handle) == old_ex_style.end()) {
        old_ex_style[window_handle] = GetWindowLongPtr(window_handle, GWL_EXSTYLE);
    }

    if (!status) {
        SetWindowLongPtr(window_handle, GWL_EXSTYLE, old_ex_style[window_handle]);
    }
    else {
        LONG_PTR ex_style = GetWindowLongPtr(window_handle, GWL_EXSTYLE);

        ex_style |= WS_EX_TOOLWINDOW;
        ex_style &= ~WS_EX_APPWINDOW;
        SetWindowLongPtr(window_handle, GWL_EXSTYLE, ex_style);
    }
    // force redraw
    SetWindowPos(window_handle, NULL, 0, 0, 0, 0,
        SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
  }

  ProcessHandle GetProcessHandle() const noexcept { return target_process_handle_; }
  ProcessId GetProcessId() const noexcept { return target_process_id_; }

 private:
  ProcessHandle target_process_handle_;
  ProcessId target_process_id_;
  int dpi_;

  static int GetSystemDPI() noexcept {
    if (HDC hdc = GetDC(nullptr); hdc != nullptr) {
      int dpi = GetDeviceCaps(hdc, LOGPIXELSX);
      ReleaseDC(nullptr, hdc);
      return dpi;
    }
    return 96;
  }

  static ProcessId GetProcessIdByName(std::wstring_view process_name) noexcept {
    if (!pfnNtQuerySystemInformation || process_name.empty())
        return 0;

    ProcessId dwPid = 0;
    ULONG ulBufferSize = kDefaultBufferSize;
    UniqueVirtualMemPtr pBuffer(
        (PBYTE)VirtualAlloc(nullptr, ulBufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)
    );
    if (!pBuffer)
        return 0;

    NTSTATUS status = STATUS_INFO_LENGTH_MISMATCH;
    while (status == STATUS_INFO_LENGTH_MISMATCH)
    {
        status = pfnNtQuerySystemInformation(5, pBuffer.get(), ulBufferSize, nullptr);
        if (status == STATUS_INFO_LENGTH_MISMATCH)
        {
            ulBufferSize *= 2;
            pBuffer.reset(
                (PBYTE)VirtualAlloc(nullptr, ulBufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)
            );
            if (!pBuffer)
                return 0;
        }
    }

    if (!NT_SUCCESS(status))
    {
        return 0;
    }

    PSYSTEM_PROCESS_INFORMATION pSPI = (PSYSTEM_PROCESS_INFORMATION)pBuffer.get();
    while (true)
    {
        if (pSPI->ImageName.Buffer && pSPI->ProcessId != nullptr)
        {
            if (_wcsicmp(pSPI->ImageName.Buffer, process_name.data()) == 0)
            {
                dwPid = (ProcessId)(ULONG_PTR)pSPI->ProcessId;
                break;
            }
        }

        if (pSPI->NextEntryOffset == 0)
            break;
        pSPI = (PSYSTEM_PROCESS_INFORMATION)((Address)pSPI + pSPI->NextEntryOffset);
    }

    return dwPid;
  }

  bool GetLdrDataTableEntryByName(const char* dll_name, UniqueLdrEntryPtr& pOutLdrEntry) noexcept {
    if (!target_process_handle_ || !dll_name) {
        return false;
    }

    pOutLdrEntry = std::make_unique<LDR_DATA_TABLE_ENTRY>();
    PROCESS_BASIC_INFORMATION pbi = {0};
    ULONG returnLength = 0;

    NTSTATUS status = NtQueryInformationProcess(
        target_process_handle_,
        ProcessBasicInformation,
        &pbi,
        sizeof(PROCESS_BASIC_INFORMATION),
        &returnLength
    );

    if (!NT_SUCCESS(status)) {
        pOutLdrEntry.reset();
        return false;
    }

    PEB peb = {0};
    if (!ReadMemoryNt(reinterpret_cast<Address>(pbi.PebBaseAddress), &peb, sizeof(PEB))) {
        pOutLdrEntry.reset();
        return false;
    }

    PEB_LDR_DATA ldrData = {0};
    if (!ReadMemoryNt(reinterpret_cast<Address>(peb.Ldr), &ldrData, sizeof(PEB_LDR_DATA))) {
        pOutLdrEntry.reset();
        return false;
    }

    PLIST_ENTRY pModuleListHead = &ldrData.InLoadOrderModuleList;
    PLIST_ENTRY pCurrentListEntry = pModuleListHead->Flink;

    wchar_t dllNameWide[MAX_PATH] = {0};
    MultiByteToWideChar(CP_ACP, 0, dll_name, -1, dllNameWide, MAX_PATH);

    while (true) {
        PLDR_DATA_TABLE_ENTRY pRemoteLdrEntry = CONTAINING_RECORD(pCurrentListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        if (!ReadMemoryNt(reinterpret_cast<Address>(pRemoteLdrEntry), pOutLdrEntry.get(), sizeof(LDR_DATA_TABLE_ENTRY))) {
            break;
        }

        wchar_t baseDllName[MAX_PATH] = {0};
        if (pOutLdrEntry->BaseDllName.Buffer && pOutLdrEntry->BaseDllName.Length > 0) {
            SizeType len1 = static_cast<SizeType>(pOutLdrEntry->BaseDllName.Length);
            SizeType len2 = sizeof(baseDllName) - sizeof(wchar_t);
            ReadMemoryNt(
                reinterpret_cast<Address>(pOutLdrEntry->BaseDllName.Buffer),
                baseDllName,
                std::min(len1, len2)
            );
        }

        if (_wcsicmp(baseDllName, dllNameWide) == 0) {
            return true;
        }

        pCurrentListEntry = pOutLdrEntry->InLoadOrderLinks.Flink;
        if (pCurrentListEntry == pModuleListHead) {
            break;
        }
    }

    pOutLdrEntry.reset();
    return false;
  }
};

#endif

```

`Examples/includes/operation.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _OPERATION_H_
#define _OPERATION_H_

#include <algorithm>
#include <cstdint>
#include <memory>
#include <sstream>
#include <string>
#include <string_view>
#include <vector>
#ifdef USING_USUGUMO
#include "./usugumo.h"
#else
#include "./native.h"
#endif

class PatternScanner {
 public:
  struct PatternByte {
    uint8_t value;
    bool wildcard;
  };

  static std::vector<PatternByte> ParsePattern(const std::string& pattern) noexcept {
    std::vector<PatternByte> bytes;
    std::istringstream iss(pattern);
    std::string token;

    while (iss >> token) {
      PatternByte pb;
      if (token == "??" || token == "?") {
        pb.value = 0;
        pb.wildcard = true;
      } else {
        pb.value = static_cast<uint8_t>(std::stoul(token, nullptr, 16));
        pb.wildcard = false;
      }
      bytes.push_back(pb);
    }

    return bytes;
  }

  static std::vector<PatternByte> ParsePattern(std::string_view pattern) noexcept {
    std::vector<PatternByte> bytes;
    std::string token;
    size_t pos = 0;
    size_t len = pattern.size();

    while (pos < len) {
      while (pos < len && isspace(static_cast<unsigned char>(pattern[pos]))) {
        pos++;
      }
      if (pos >= len) {
        break;
      }
      size_t end_pos = pos;
      while (end_pos < len && !isspace(static_cast<unsigned char>(pattern[end_pos]))) {
        end_pos++;
      }
      token = std::string(pattern.substr(pos, end_pos - pos));
      pos = end_pos;

      PatternByte pb;
      if (token == "??" || token == "?") {
        pb.value = 0;
        pb.wildcard = true;
      } else {
        pb.value = static_cast<uint8_t>(std::stoul(token, nullptr, 16));
        pb.wildcard = false;
      }
      bytes.push_back(pb);
    }

    return bytes;
  }

  static void ConvertPatternToBytesAndMask(
      const std::vector<PatternByte>& pattern,
      std::vector<uint8_t>& pattern_bytes, std::vector<bool>& mask) noexcept {
    pattern_bytes.clear();
    mask.clear();

    for (const auto& pb : pattern) {
      pattern_bytes.push_back(pb.value);
      mask.push_back(!pb.wildcard);
    }
  }

  static bool MemoryCompare(const uint8_t* data, const uint8_t* pattern,
                            const std::vector<bool>& mask, size_t length) noexcept {
    for (size_t i = 0; i < length; i++) {
      if (mask[i] && data[i] != pattern[i]) {
        return false;
      }
    }
    return true;
  }
};

constexpr inline size_t CHUNK_SIZE = 4096uz;
using Address = uintptr_t;
using SizeType = size_t;

#ifdef USING_USUGUMO

class Operation : public UsugumoDriver {
 public:
  bool Init(uint64_t process_id) noexcept { return Initialize(process_id); }
  bool Init(std::wstring_view process_name) noexcept { return Initialize(process_name); }

  template <typename T>
  bool Read(Address address, T* value) noexcept {
    return ReadMemoryKm(address, value, sizeof(T));
  }

  bool ReadSize(Address address, void* buffer, SizeType size) noexcept {
    return ReadMemoryKm(address, buffer, size);
  }

  template <typename T>
  bool Write(Address address, const T& value, int size) noexcept {
    return WriteMemoryKm(address, &value, size);
  }

  bool GetModuleInfo(std::string_view module_name, uint64_t* base_address,
                     uint64_t* module_size) noexcept {
    uint64_t base = GetDllBaseAddress(module_name.data());
    uint64_t size = GetDllSize(module_name.data());

    if (base_address) *base_address = base;
    if (module_size) *module_size = size;

    return (base != 0 && size != 0);
  }

  Address PatternScan(Address start, Address end,
                      std::string_view pattern) noexcept {
    if (start >= end) return 0;

    auto pattern_bytes = PatternScanner::ParsePattern(pattern);
    if (pattern_bytes.empty()) return 0;

    SizeType pattern_length = pattern_bytes.size();
    SizeType size = end - start;

    std::unique_ptr<uint8_t[]> buffer(
        new uint8_t[CHUNK_SIZE + pattern_length - 1]);

    std::vector<uint8_t> pattern_data;
    std::vector<bool> mask;
    PatternScanner::ConvertPatternToBytesAndMask(pattern_bytes, pattern_data,
                                                 mask);

    for (SizeType offset = 0; offset < size; offset += CHUNK_SIZE) {
      SizeType bytes_to_read =
          std::min(CHUNK_SIZE + pattern_length - 1, size - offset);
      Address current_address = start + offset;

      if (!ReadSize(current_address, buffer.get(), bytes_to_read)) {
        continue;
      }

      SizeType search_limit = bytes_to_read - pattern_length;
      for (SizeType i = 0; i <= search_limit; i++) {
        if (PatternScanner::MemoryCompare(buffer.get() + i, pattern_data.data(),
                                          mask, pattern_length)) {
          return current_address + i;
        }
      }
    }

    return 0;
  }

  Address PatternScanSize(Address start, SizeType size,
                          std::string_view pattern) noexcept {
    return PatternScan(start, start + size, pattern);
  }

  Address PatternScanMultiple(Address start, Address end,
                              const std::vector<std::string>& patterns) noexcept {
    for (const auto& pattern : patterns) {
      Address result = PatternScan(start, end, pattern);
      if (result != 0) {
        return result;
      }
    }
    return 0;
  }

};

#else

class Operation : public Native {
 public:
  bool Init(uint64_t process_id) noexcept { return Initialize(process_id); }
  bool Init(std::wstring_view process_name) noexcept {
    return Initialize(process_name.data(), PROCESS_VM_OPERATION | PROCESS_VM_READ |
                                        PROCESS_VM_WRITE |
                                        PROCESS_QUERY_INFORMATION);
  }

  template <typename T>
  bool Read(Address address, T* value) noexcept {
    return ReadMemoryNt(address, value, sizeof(T));
  }

  bool ReadSize(Address address, void* buffer, SizeType size) noexcept {
    return ReadMemoryNt(address, buffer, size);
  }

  template <typename T>
  bool Write(Address address, const T& value, int size) noexcept {
    return WriteMemoryNt(address, &value, size);
  }

  bool GetModuleInfo(std::string_view module_name, uint64_t* base_address,
                     uint64_t* module_size) noexcept {
    uint64_t base = GetDllBaseAddress(module_name.data());
    uint64_t size = GetDllSize(module_name.data());

    if (base_address) *base_address = base;
    if (module_size) *module_size = size;

    return (base != 0 && size != 0);
  }

  Address PatternScan(Address start, Address end,
                      std::string_view pattern) noexcept {
    if (start >= end) return 0;

    auto pattern_bytes = PatternScanner::ParsePattern(pattern);
    if (pattern_bytes.empty()) return 0;

    SizeType pattern_length = pattern_bytes.size();
    SizeType size = end - start;

    std::unique_ptr<uint8_t[]> buffer(
        new uint8_t[CHUNK_SIZE + pattern_length - 1]);

    std::vector<uint8_t> pattern_data;
    std::vector<bool> mask;
    PatternScanner::ConvertPatternToBytesAndMask(pattern_bytes, pattern_data,
                                                 mask);

    for (SizeType offset = 0; offset < size; offset += CHUNK_SIZE) {
      SizeType bytes_to_read =
          std::min(CHUNK_SIZE + pattern_length - 1, size - offset);

      if (bytes_to_read < pattern_length) {
        continue;
      }

      Address current_address = start + offset;

      if (!ReadSize(current_address, buffer.get(), bytes_to_read)) {
        continue;
      }

      SizeType search_limit = bytes_to_read - pattern_length;
      for (SizeType i = 0; i <= search_limit; i++) {
        if (PatternScanner::MemoryCompare(buffer.get() + i, pattern_data.data(),
                                          mask, pattern_length)) {
          return current_address + i;
        }
      }
    }

    return 0;
  }

  Address PatternScanSize(Address start, SizeType size,
                          std::string_view pattern) noexcept {
    return PatternScan(start, start + size, pattern);
  }

  Address PatternScanMultiple(Address start, Address end,
                              const std::vector<std::string>& patterns) noexcept {
    for (const auto& pattern : patterns) {
      Address result = PatternScan(start, end, pattern);
      if (result != 0) {
        return result;
      }
    }
    return 0;
  }

};

#endif  // USING_USUGUMO

#endif

```

`Examples/includes/usugumo.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _USUGUMO_H_
#define _USUGUMO_H_
#include <Windows.h>

#include <algorithm>
#include <cassert>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <mutex>
#include <optional>
#include <string_view>
#include <vector>
#include <unordered_map>

#include "../../usugumo_request_define.h"

constexpr inline size_t kFixedStr64MaxLength = 64uz;
constexpr inline LPCSTR kDriverDevice = "\\\\.\\%sUsugum0";
constexpr inline uint64_t kSecureKey = 0xBEEFDEADFEEDCAFEULL;

using ProcessId = uint64_t;
using VirtualAddress = uintptr_t;
using MemorySize = size_t;
using DpiValue = int;
using ByteBuffer = std::byte*;
using ConstByteBuffer = const std::byte*;

class UsugumoDriver {
 public:
  UsugumoDriver() noexcept
      : driver_handle_(INVALID_HANDLE_VALUE),
        target_process_id_(0),
        current_process_id_(0),
        dpi_(0) {}

  ~UsugumoDriver() noexcept {
    if (driver_handle_ != INVALID_HANDLE_VALUE) {
      CloseHandle(driver_handle_);
    }
  }

  UsugumoDriver(const UsugumoDriver&) = delete;
  UsugumoDriver& operator=(const UsugumoDriver&) = delete;

  UsugumoDriver(UsugumoDriver&& other) noexcept { *this = std::move(other); }

  UsugumoDriver& operator=(UsugumoDriver&& other) noexcept {
    if (this != &other) {
      driver_handle_ = other.driver_handle_;
      target_process_id_ = other.target_process_id_;
      current_process_id_ = other.current_process_id_;
      dpi_ = other.dpi_;

      other.driver_handle_ = INVALID_HANDLE_VALUE;
      other.target_process_id_ = 0;
      other.current_process_id_ = 0;
      other.dpi_ = 0;
    }
    return *this;
  }

  bool Initialize(ProcessId process_id) noexcept {
    if (!OpenDriverHandle()) {
      return false;
    }

    target_process_id_ = process_id;
    current_process_id_ = GetCurrentProcessId();
    return true;
  }

  bool Initialize(std::wstring_view process_name) noexcept {
    if (!OpenDriverHandle()) {
      return false;
    }

    const auto pid_opt = GetProcessIdByName(process_name);
    if (!pid_opt.has_value()) {
      return false;
    }

    target_process_id_ = *pid_opt;
    current_process_id_ = GetCurrentProcessId();
    return true;
  }

  bool DriverProbe() noexcept {
    if (!OpenDriverHandle()) {
      return false;
    }

    Requests request = {};
    request.request_key = USUGUMO_PROBE;

    SendRequest(request);
    return request.return_value != 0;
  }

  uint64_t GetDllSize(std::string_view dll_name) noexcept {
    return GetDllInfo<USUGUMO_MODULE_SIZE>(dll_name);
  }

  uint64_t GetDllBaseAddress(std::string_view dll_name) noexcept {
    return GetDllInfo<USUGUMO_MODULE_BASE>(dll_name);
  }

  bool ReadMemoryKm(VirtualAddress address, void* buffer,
                    MemorySize size) noexcept {
    return ReadVirtualMemory(target_process_id_, address,
                             reinterpret_cast<VirtualAddress>(buffer), size);
  }

  bool WriteMemoryKm(VirtualAddress address, const void* buffer,
                     MemorySize size) noexcept {
    return WriteVirtualMemory(target_process_id_, address,
                              reinterpret_cast<VirtualAddress>(buffer), size);
  }
  void MouseEvent(DWORD flags, DWORD x, DWORD y, DWORD data,
                  ULONG_PTR extra_info) noexcept {
    LONG dx = (LONG)x;
    LONG dy = (LONG)y;

    Requests request = {};
    request.request_key = USUGUMO_MOUSE;
    request.dwFlags = flags;
    request.dx = dx;
    request.dy = dy;
    request.dwData = data;
    request.dwExtraInfo = extra_info;

    SendRequest(request);
  }

  void MouseLeftDown() noexcept {
    MouseEvent(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
  }

  void MouseLeftUp() noexcept { MouseEvent(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0); }

  void MouseMove(DWORD x, DWORD y) noexcept {
    if (dpi_ == 0) {
      dpi_ = GetSystemDPI();
    }
    const DWORD dx = (x * 100u + dpi_ / 2) / dpi_;
    const DWORD dy = (y * 100u + dpi_ / 2) / dpi_;
    MouseEvent(MOUSEEVENTF_MOVE, dx, dy, 0, 0);
  }

  void SetCursorPos(DWORD x, DWORD y) noexcept {
    const int screen_width = GetSystemMetrics(SM_CXSCREEN) - 1;
    const int screen_height = GetSystemMetrics(SM_CYSCREEN) - 1;
    const int virtual_x = (x * 65535u) / screen_width;
    const int virtual_y = (y * 65535u) / screen_height;
    MouseEvent(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, virtual_x, virtual_y, 0,
               0);
  }

  void KeybdEvent(BYTE vk, BYTE scan, DWORD flags,
                  ULONG_PTR extra_info) noexcept {
    Requests request = {};
    request.request_key = USUGUMO_KEYBD;
    request.bVK = vk;
    request.bScan = scan;
    request.dwFlags = flags;
    request.dwExtraInfo = extra_info;

    SendRequest(request);
  }

  void AntiCapture(HWND window_handle, bool status = true) noexcept {
    Requests request = {};
    request.request_key = USUGUMO_ANTI_CAPTURE;
    request.window_handle = window_handle;
    request.protect_flags = status ? 0xFFFFFFFFu : 0x00000000u;

    SendRequest(request);
    // user-mode operations
    static std::unordered_map<HWND, LONG_PTR> old_ex_style;
    if (old_ex_style.find(window_handle) == old_ex_style.end()) {
        old_ex_style[window_handle] = GetWindowLongPtr(window_handle, GWL_EXSTYLE);
    }

    if (!status) {
        SetWindowLongPtr(window_handle, GWL_EXSTYLE, old_ex_style[window_handle]);
    }
    else {
        LONG_PTR ex_style = GetWindowLongPtr(window_handle, GWL_EXSTYLE);
        ex_style |= WS_EX_TOOLWINDOW;
        ex_style &= ~WS_EX_APPWINDOW;
        SetWindowLongPtr(window_handle, GWL_EXSTYLE, ex_style);
    }
    SetWindowPos(window_handle, NULL, 0, 0, 0, 0,
        SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
  }

  HANDLE GetDriverHandle() const noexcept { return driver_handle_; }
  ProcessId GetProcessId() const noexcept { return target_process_id_; }

 private:
  HANDLE driver_handle_;
  ProcessId target_process_id_;
  ProcessId current_process_id_;
  DpiValue dpi_;
  char driver_device_path_[256] = {0};

  unsigned __int64 CalculateRequestsChecksum(Requests* pRequest) {
    if (pRequest == NULL) {
      return 0;
    }
    // CRC64-ECMA
    const unsigned __int64 CRC64_POLYNOMIAL = 0x42F0E1EBA9EA3693ULL;
    static unsigned __int64 crc64_table[256] = {0};
    static BOOLEAN table_initialized = FALSE;

    if (!table_initialized) {
      for (unsigned int i = 0; i < 256; i++) {
        unsigned __int64 crc = (unsigned __int64)i;
        for (int j = 0; j < 8; j++) {
          if (crc & 1) {
            crc = (crc >> 1) ^ CRC64_POLYNOMIAL;
          } else {
            crc >>= 1;
          }
        }
        crc64_table[i] = crc;
      }
      table_initialized = TRUE;
    }

    unsigned __int64 validDataLen =
        sizeof(Requests) - sizeof(pRequest->check_sum);
    const unsigned char* pData = (const unsigned char*)pRequest;

    unsigned __int64 crc64 = 0xFFFFFFFFFFFFFFFFULL;
    for (unsigned __int64 i = 0; i < validDataLen; i++) {
      crc64 = crc64_table[(crc64 ^ pData[i]) & 0xFF] ^ (crc64 >> 8);
    }
    crc64 ^= 0xFFFFFFFFFFFFFFFFULL;
    return crc64;
  }

  void SendRequest(Requests& request) noexcept {
    if (driver_handle_ == INVALID_HANDLE_VALUE) {
      return;
    }
    request.time_stamp = GetTimestamp();
    request.secure_key = kSecureKey;
    request.check_sum = CalculateRequestsChecksum(&request);
    
    DWORD dwWritten = 0, dwRead = 0;
    WriteFile(driver_handle_, &request, sizeof(Requests), &dwWritten, nullptr);
    if (dwWritten == sizeof(Requests)) {
      ReadFile(driver_handle_, &request, sizeof(Requests), &dwRead, nullptr);
    }
  }

  template <uint64_t RequestKey>
  uint64_t GetDllInfo(std::string_view dll_name) noexcept {
    if (driver_handle_ == INVALID_HANDLE_VALUE) {
      return 0;
    }

    Requests request = {};
    request.request_key = RequestKey;
    request.target_pid = target_process_id_;

    const auto name_len =
        std::clamp(dll_name.size(), 0uz, kFixedStr64MaxLength);
    request.name_length = name_len;

    FixedStr64 fixed_str;
    EncodeFixedStr64(dll_name, &fixed_str);
    request.name_str = fixed_str;

    SendRequest(request);
    return request.return_value;
  }

  BOOLEAN GetMachineGuid(char* id_buf, size_t buf_len) {
    if (!id_buf || buf_len < 64) return FALSE;

    HKEY hKey = NULL;
    WCHAR wszId[64] = {0};
    DWORD dwDataLen = sizeof(wszId);

    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Cryptography",
                      0, KEY_READ, &hKey) != ERROR_SUCCESS) {
      return FALSE;
    }

    if (RegQueryValueExW(hKey, L"MachineGuid", NULL, NULL, (LPBYTE)wszId,
                         &dwDataLen) != ERROR_SUCCESS) {
      RegCloseKey(hKey);
      return FALSE;
    }

    WideCharToMultiByte(CP_ACP, 0, wszId, -1, id_buf, (int)buf_len, NULL, NULL);
    RegCloseKey(hKey);
    return TRUE;
  }

  bool OpenDriverHandle() noexcept {
    if (driver_handle_ != INVALID_HANDLE_VALUE) {
      return true;
    }

    char guid_buf[64] = {0};
    if (!GetMachineGuid(guid_buf, ARRAYSIZE(guid_buf))) {
      return false;
    }

    sprintf_s(driver_device_path_, ARRAYSIZE(driver_device_path_),
        kDriverDevice, guid_buf);

    driver_handle_ = CreateFileA(driver_device_path_, 
        GENERIC_READ | GENERIC_WRITE, 
        0, nullptr, OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING, nullptr);
    return driver_handle_ != INVALID_HANDLE_VALUE;
  }

  static DpiValue GetSystemDPI() noexcept {
    if (HDC hdc = GetDC(nullptr); hdc != nullptr) {
      const DpiValue dpi = GetDeviceCaps(hdc, LOGPIXELSX);
      ReleaseDC(nullptr, hdc);
      return dpi;
    }
    return 96;
  }

  void EncodeFixedStr64(std::string_view str, FixedStr64* fixed_str) noexcept {
    assert(fixed_str != nullptr);

    const auto str_len = std::clamp(str.size(), 0uz, kFixedStr64MaxLength);
    std::memset(fixed_str->blocks, 0, sizeof(fixed_str->blocks));

    for (size_t i = 0; i < str_len; ++i) {
      const size_t block_index = i / 8uz;
      const size_t pos_in_block = i % 8uz;
      const int shift = 8 * (7 - static_cast<int>(pos_in_block));
      const uint64_t char_val =
          static_cast<uint64_t>(static_cast<unsigned char>(str[i]));
      fixed_str->blocks[block_index] |= (char_val << shift);
    }
  }

  bool ReadVirtualMemory(ProcessId target_pid, VirtualAddress target_addr,
                         VirtualAddress request_addr,
                         MemorySize size) noexcept {
    if (target_pid == 0 || target_addr == 0 || size == 0) {
      return false;
    }

    Requests request = {};
    request.request_key = USUGUMO_READ;
    request.request_pid = current_process_id_;
    request.request_addr = request_addr;
    request.target_pid = target_pid;
    request.target_addr = target_addr;
    request.mem_size = size;

    SendRequest(request);
    return request.return_value != 0;
  }

  bool WriteVirtualMemory(ProcessId target_pid, VirtualAddress target_addr,
                          VirtualAddress request_addr,
                          MemorySize size) noexcept {
    if (target_pid == 0 || target_addr == 0 || size == 0) {
      return false;
    }

    Requests request = {};
    request.request_key = USUGUMO_WRITE;
    request.request_pid = current_process_id_;
    request.request_addr = request_addr;
    request.target_pid = target_pid;
    request.target_addr = target_addr;
    request.mem_size = size;

    SendRequest(request);
    return request.return_value != 0;
  }

  std::optional<DWORD> GetProcessIdByName(
      std::wstring_view process_name) noexcept {
    char ansi_process_name[MAX_PATH] = {0};
    WideCharToMultiByte(CP_ACP, 0, process_name.data(),
                        static_cast<int>(process_name.size()),
                        ansi_process_name, MAX_PATH, nullptr, nullptr);

    Requests request = {};
    request.request_key = USUGUMO_PID;

    const auto name_len =
        std::clamp(strlen(ansi_process_name), 0uz, kFixedStr64MaxLength);
    request.name_length = name_len;

    FixedStr64 fixed_str;
    EncodeFixedStr64(ansi_process_name, &fixed_str);
    request.name_str = fixed_str;

    SendRequest(request);
    const DWORD pid = static_cast<DWORD>(request.return_value);
    return pid != 0 ? std::optional<DWORD>(pid) : std::nullopt;
  }
};

#endif

```

`LICENSE`:

```
TOSSUCU License 2025.9

Copyright (c) 2025 渟雲

Definitions / 定义 
Any first-person pronouns (such as "I", "Me"), "right holder", and "author" in this License refer to the above-mentioned right holder (in this copy of license, specifically 渟雲). 
本许可证中的第一人称代词（如 “我”）、“权利人”、“作者”均指上述权利人（在本许可证副本中，特指 渟雲）。 
"Software" refers to this software and its associated documentation files. 
“软件”指本软件及其相关文档文件。

Permission / 授权 
Permission is hereby granted, free of charge, to any person obtaining a copy of the Software, to deal in the Software without restriction, including but not limited to: Use, Copy, Modify, Merge, Publish, Distribute, Sublicense, Sell. And to permit persons to whom the Software is furnished to do so. 
在满足以下条件的前提下，任何获得本软件副本的人均可免费、无限制地使用本软件，包括但不限于：使用、复制、修改、合并、发布、分发、再许可、出售。并允许被提供本软件的人同样享有上述权利。

Conditions / 条件 
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. 
在所有本软件的副本或重要部分中，必须包含上述版权声明和本许可声明。

Disclaimer / 免责声明 
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO: MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
本软件按“现状”提供，不附带任何形式的明示或暗示担保，包括但不限于：适销性、特定用途适用性、非侵权性。 在任何情况下，作者或版权持有人均不对因使用本软件或与本软件相关的行为而产生的任何索赔、损害或其他责任负责，无论其基于合同、侵权行为或其他原因。

Updates and Adjustments / 更新与调整 
The right holder may publish updated versions of this License. Each project or release shall specify the adjustments made to the License, clearly indicating the modified sections, if any. Unless explicitly stated, the terms of the License attached to the project, including its specified adjustments, shall govern. The right holder may choose to continue using older versions. The applicable version shall be the one attached to the obtained copy. 
权利人可以发布本许可证的更新版本。 每个项目或发行版应当明确说明对许可证所作的调整，并清晰标注被修改的部分（如有修改）。 除非另有明确说明，项目所附带的许可证（包括其指明的调整部分）应当优先适用。 权利人可以选择继续使用旧版本，版本以所获得的副本所附带的为准。

Compatibility with Referenced Software / 与引用软件的兼容性 
If the restrictions of this License conflict with the license of the referenced software, the referenced portion (INCLUDING BUT NOT LIMITED TO: modules, text, images, audio, source code, compiled binary fragments) shall be subject to the license of the referenced software, and the rest of the content shall still be subject to this License. 
如果本许可证的限制与所引用软件的许可证发生冲突，则引用部分（包括但不限于：模块、文本、图像、音频、源代码、已编译的二进制片段）应当遵循引用软件的许可证，其余部分仍然适用本许可证。

Legal Liability / 法律责任 
If any provision of this License is violated, directly or indirectly causing damage to the legitimate rights of the right holder, the right holder has the right to pursue legal liability in accordance with the laws of the country or region where the right holder is located. 
如有违反本许可证的条款，直接或间接导致权利人合法权利受损的，权利人有权依据其所在国家或地区的法律追究法律责任。

Language Versions / 语言版本 
This License may have multiple language translations. In case of conflict between translations, the English version shall prevail. 
此许可证可能有多种语言翻译，如有条目冲突，以英文版为准。

```

`README.md`:

```md
# Usugumo

A Windows kernel-mode driver that proxies RPM/WPM/mouse_event/keybd_event .etc operations, handling user-mode process requests via DIRECT_IO IRP

> [!WARNING]
> This project IS NOT designed to combat AC/AV/EDR or sth like that.
> 
> And no matter what purpose you use it for, I DO NOT guarantee anything about it and assume ALL RISKS at your own risk
> 
> Unless strictly tested and appropriately modified, in principle, DO NOT directly use any code from this project for production environments

---

## Features

- Handling user-mode process requests via DIRECT_IO IRP
- Kernel-mode RPM/WPM
- Kernel-mode fetch module info(base, size)
- Kernel-mode get PID via name
- Kernel-mode mouse input
- Kernel-mode keyboard input
- Kernel-mode anti capture

## KnownIssues

- Currently only works on x64 windows (other arch, no quiero)
- Current implementation does not take into account CR3 encryption, kernel-mode memory protection, etc., and is only used as a PoC
- This is just a PoC, which is why you may find my approach relatively elegant in some places, while overly ghetto in others
- For the purpose of anti-paste, I unnecessarily rewrote many functions using MASM. However, doing so should not affect the actual functionality.

## Usage

See [Examples](./Examples)

There‘s also an alternative example that utilizes Native API, which is not a best practice, but better than most user-mode pasta.

## License

This project is licensed under [**TOSSUCU License 2025.9**](LICENSE).

For most development purposes, it can be considered a variant of MIT or BSD.

## Credits

- [ekknod/MouseClassServiceCallbackMeme](https://github.com/ekknod/MouseClassServiceCallbackMeme/)
- [reactos](https://github.com/reactos/reactos/) BSD Licensed part
- [danielkrupinski/Osiris](https://github.com/danielkrupinski/Osiris/)
- [oakboat/GsDriver-ring3](https://github.com/oakboat/GsDriver-ring3/)

```

`Usugumo C.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36121.58
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Usugumo C", "Usugumo C.vcxproj", "{A760B5B3-9C9E-9B82-35A0-A8F759B87E86}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A760B5B3-9C9E-9B82-35A0-A8F759B87E86}.Debug|x64.ActiveCfg = Debug|x64
		{A760B5B3-9C9E-9B82-35A0-A8F759B87E86}.Debug|x64.Build.0 = Debug|x64
		{A760B5B3-9C9E-9B82-35A0-A8F759B87E86}.Debug|x64.Deploy.0 = Debug|x64
		{A760B5B3-9C9E-9B82-35A0-A8F759B87E86}.Release|x64.ActiveCfg = Release|x64
		{A760B5B3-9C9E-9B82-35A0-A8F759B87E86}.Release|x64.Build.0 = Release|x64
		{A760B5B3-9C9E-9B82-35A0-A8F759B87E86}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {6A686485-8729-425E-94BF-A09822499149}
	EndGlobalSection
EndGlobal

```

`Usugumo C.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{A760B5B3-9C9E-9B82-35A0-A8F759B87E86}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>Usugumo_C</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.26100.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(WindowsSdkDir)include\$(WindowsTargetPlatformVersion)\km;$(IncludePath)</IncludePath>
    <EnableInf2cat>false</EnableInf2cat>
    <LibraryPath>$(WindowsSdkDir)Lib\$(WindowsTargetPlatformVersion)\km\;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(WindowsSdkDir)include\$(WindowsTargetPlatformVersion)\km;$(IncludePath)</IncludePath>
    <EnableInf2cat>false</EnableInf2cat>
    <LibraryPath>$(WindowsSdkDir)Lib\$(WindowsTargetPlatformVersion)\km\;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <ClCompile>
      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
    </ClCompile>
    <ClCompile>
      <IntelJCCErratum>true</IntelJCCErratum>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <DisableSpecificWarnings>4819;4748;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <LargeAddressAware>true</LargeAddressAware>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <AdditionalDependencies>cng.lib;Wdmsec.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <GenerateMapFile>true</GenerateMapFile>
      <EntryPointSymbol>UsugumoEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>SHA256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <ClCompile>
      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
    </ClCompile>
    <ClCompile>
      <IntelJCCErratum>true</IntelJCCErratum>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <DisableSpecificWarnings>4819;4603;4627;4986;4987;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
    </ClCompile>
    <Link>
      <LargeAddressAware>true</LargeAddressAware>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <AdditionalDependencies>cng.lib;Wdmsec.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <GenerateMapFile>true</GenerateMapFile>
      <MergeSections>_TEXT=.vmp;_PAGE=.tmd</MergeSections>
      <EntryPointSymbol>UsugumoEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="UsugumoC.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="anti_capture.c" />
    <ClCompile Include="dispatches.c" />
    <ClInclude Include="keybd_operation.h" />
    <ClCompile Include="keybd_operation.c" />
    <ClCompile Include="process.c" />
    <ClCompile Include="helpers.c" />
    <ClCompile Include="mouse_operation.c" />
    <ClCompile Include="reimpl.c" />
    <ClCompile Include="requst_handler.c" />
    <ClCompile Include="Usugumo.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="anti_capture.h" />
    <ClInclude Include="common.h" />
    <ClInclude Include="defines.h" />
    <ClInclude Include="dispatches.h" />
    <ClInclude Include="process.h" />
    <ClInclude Include="helpers.h" />
    <ClInclude Include="imports.h" />
    <ClInclude Include="mouse_operation.h" />
    <ClInclude Include="reimpl.h" />
    <ClInclude Include="request_handler.h" />
    <ClInclude Include="usugumo_request_define.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="helper_utils.asm" />
    <MASM Include="ke_reimpl.asm" />
    <MASM Include="kmem.asm" />
    <MASM Include="mouse.asm" />
    <MASM Include="rtl_reimpl.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`Usugumo C.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="UsugumoC.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Usugumo.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dispatches.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="process.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="requst_handler.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mouse_operation.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="helpers.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="anti_capture.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="reimpl.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="keybd_operation.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defines.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="imports.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dispatches.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="process.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="request_handler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mouse_operation.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="helpers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="usugumo_request_define.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="anti_capture.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="reimpl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="keybd_operation.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="mouse.asm">
      <Filter>Source Files</Filter>
    </MASM>
    <MASM Include="ke_reimpl.asm">
      <Filter>Source Files</Filter>
    </MASM>
    <MASM Include="kmemmove.asm">
      <Filter>Source Files</Filter>
    </MASM>
    <MASM Include="rtl_reimpl.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`Usugumo.c`:

```c
// Copyright (c) 2026 渟雲. All rights reserved.
#include "./common.h"
UNICODE_STRING g_symbolic_link_name = {0};

VOID DriverUnload(_In_ struct _DRIVER_OBJECT* DriverObject) {
  UNREFERENCED_PARAMETER(DriverObject);
  MdlPoolDestroy();
  if (DriverObject->DeviceObject) {
    if (g_symbolic_link_name.Buffer != NULL) {
      IoDeleteSymbolicLink(&g_symbolic_link_name);
      ExFreePool(g_symbolic_link_name.Buffer);
    }
    IoDeleteDevice(DriverObject->DeviceObject);
  }
}

NTSTATUS DriverInit(_In_ PDRIVER_OBJECT DriverObject,
                    _In_ PUNICODE_STRING RegistryPath) {
  UNREFERENCED_PARAMETER(DriverObject);
  UNREFERENCED_PARAMETER(RegistryPath);
  /* Microsoft compiler is sometimes retarded, thats why we have to do this non
   * sense */
  /* It would otherwise generate wrapper functions around, and it would cause
   * system BSOD */
  _KeAcquireSpinLockAtDpcLevel = (QWORD)KeAcquireSpinLockAtDpcLevel;
  _KeReleaseSpinLockFromDpcLevel = (QWORD)KeReleaseSpinLockFromDpcLevel;
  _IofCompleteRequest = (QWORD)IofCompleteRequest;
  _IoReleaseRemoveLockEx = (QWORD)IoReleaseRemoveLockEx;

  LARGE_INTEGER perf_counter;
  KeQueryPerformanceCounter(&perf_counter);
  ULONG ramdon_seed =
      (ULONG)perf_counter.LowPart ^ (ULONG)perf_counter.HighPart;
  WCHAR random_device_name_buf[256];
  kmemset(random_device_name_buf, 0, sizeof(random_device_name_buf));
  UNICODE_STRING device_name;
  RtlStringCbPrintfW(random_device_name_buf,
                     sizeof(random_device_name_buf) / sizeof(WCHAR),
                     L"\\Device\\%04X", RtlRandomEx(&ramdon_seed));
  RtlInitUnicodeString(&device_name, random_device_name_buf);

  WCHAR guid_buf[64];
  kmemset(guid_buf, 0, sizeof(guid_buf));
  NTSTATUS status = GetMachineGuid(guid_buf, ARRAYSIZE(guid_buf));
  if (status != STATUS_SUCCESS) return status;

  WCHAR sym_link_buf[256];
  kmemset(sym_link_buf, 0, sizeof(sym_link_buf));
  RtlStringCbPrintfW(sym_link_buf, sizeof(sym_link_buf),
                     L"\\DosDevices\\Global\\%sUsugum0", guid_buf);
  RtlInitUnicodeString(&g_symbolic_link_name, sym_link_buf);

  UNICODE_STRING sddl_string = RTL_CONSTANT_STRING(SDDL_STRING);
  PDEVICE_OBJECT device_object;

  status = IoCreateDeviceSecure(DriverObject, 0, &device_name,
                                FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN,
                                FALSE, &sddl_string, NULL, &device_object);

  if (status != STATUS_SUCCESS) return status;

  status = IoCreateSymbolicLink(&g_symbolic_link_name, &device_name);
  if (status != STATUS_SUCCESS) return status;

  status = MdlPoolInitialize();
  if (status != STATUS_SUCCESS) return status;

  KeyboardSpinLockInit();
  status = SearchKdbServiceCallBack();
  if (status != STATUS_SUCCESS) return status;

  if (!InitGreProtectSpriteContent()) {
    return STATUS_ABANDONED;
    // NOT HANDLE. RETURN
  }

  SetFlag(device_object->Flags, DO_DIRECT_IO);
  // just in case.
  ClearFlag(device_object->Flags, DO_BUFFERED_IO);

  DriverObject->MajorFunction[IRP_MJ_CREATE] = DefaultDispatch;
  DriverObject->MajorFunction[IRP_MJ_CLOSE] = DefaultDispatch;
  DriverObject->MajorFunction[IRP_MJ_READ] = ReadDispatch;
  DriverObject->MajorFunction[IRP_MJ_WRITE] = WriteDispatch;
  DriverObject->DriverUnload = DriverUnload;

  ClearFlag(device_object->Flags, DO_DEVICE_INITIALIZING);
  return status;
}

NTSTATUS UsugumoEntry(_In_ PDRIVER_OBJECT DriverObject,
                      _In_ PUNICODE_STRING RegistryPath) {
  UNREFERENCED_PARAMETER(DriverObject);
  UNREFERENCED_PARAMETER(RegistryPath);
  // So it's kdmapper able
  return IoCreateDriver(NULL, DriverInit);
}

```

`UsugumoC.inf`:

```inf
;
; UsugumoC.inf
;

[Version]
Signature   = "$WINDOWS NT$"
Class       = UsugumoC ; TODO: specify appropriate Class
ClassGuid   = {8cd360e0-1b8c-cf3d-8f6c-5fde97e2b9fc}
Provider    = %ManufacturerName%
CatalogFile = UsugumoC.cat
DriverVer   = 0
PnpLockdown = 1

[DestinationDirs]
DefaultDestDir = 13

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
UsugumoC.sys = 1,,

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName% = Standard,NT$ARCH$.10.0...16299 ; %13% support introduced in build 16299

[Standard.NT$ARCH$.10.0...16299]
%UsugumoC.DeviceDesc% = UsugumoC_Device, Root\UsugumoC ; TODO: edit hw-id

[UsugumoC_Device.NT]
CopyFiles = File_Copy

[File_Copy]
UsugumoC.sys

;-------------- Service installation
[UsugumoC_Device.NT.Services]
AddService = UsugumoC,%SPSVCINST_ASSOCSERVICE%, UsugumoC_Service_Inst

; -------------- UsugumoC driver install sections
[UsugumoC_Service_Inst]
DisplayName    = %UsugumoC.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %13%\UsugumoC.sys

[UsugumoC_Device.NT.Wdf]
KmdfService = UsugumoC, UsugumoC_wdfsect

[UsugumoC_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE = 0x00000002
ManufacturerName = "EURL tkm Mecha"
DiskName = "UsugumoC Installation Disk"
UsugumoC.DeviceDesc = "UsugumoC Device"
UsugumoC.SVCDESC = "UsugumoC Service"

```

`anti_capture.c`:

```c
// Copyright (c) 2026 渟雲. All rights reserved.
#include "./common.h"

extern PLIST_ENTRY PsLoadedModuleList;
static GreProtectSpriteContentFn GreProtectSpriteContent = NULL;

static PVOID GetWin32kBase() {
  if (!PsLoadedModuleList) return NULL;
  for (PLIST_ENTRY Entry = PsLoadedModuleList->Flink;
       Entry != PsLoadedModuleList; Entry = Entry->Flink) {
    PLDR_DATA_TABLE_ENTRY Module =
        CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

    if (Module->BaseDllName.Buffer &&
        kwcsicmp(Module->BaseDllName.Buffer, L"win32kfull.sys") == 0) {
      return Module->DllBase;
    }
  }

  return NULL;
}

BOOLEAN InitGreProtectSpriteContent() {
  if (!GreProtectSpriteContent) {
    PVOID ModuleBase = GetWin32kBase();
    if (!ModuleBase) return FALSE;

    UCHAR Pattern[] = {0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B,
                       0xCC, 0x85, 0xC0, 0x75, 0x0E};
    CHAR Mask[] = "x????x?xxxx";

    PVOID FoundAddress =
        SearchSignForImage(ModuleBase, Pattern, Mask, sizeof(Pattern));
    if (!FoundAddress) return FALSE;

    GreProtectSpriteContent =
        (GreProtectSpriteContentFn)ResolveRelativeAddress(FoundAddress, 1);
    if (!GreProtectSpriteContent) return FALSE;
  }
  return TRUE;  
}

BOOLEAN ZwProtectWindow(HWND hWnd, UINT Flags) {
  if (!GreProtectSpriteContent) {
    if (!InitGreProtectSpriteContent()) return FALSE;
  }

  return GreProtectSpriteContent(NULL, hWnd, TRUE, Flags) ? TRUE : FALSE;
}

BOOLEAN HandleAntiCapture(Requests* request) {
  if (!request) return FALSE;

  HWND hWnd = request->window_handle;
  UINT Flags = request->protect_flags;

  return ZwProtectWindow(hWnd, Flags);
}

```

`anti_capture.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _ANTI_CAPTURE_H_
#define _ANTI_CAPTURE_H_

BOOLEAN InitGreProtectSpriteContent();

BOOLEAN HandleAntiCapture(Requests*);

#endif

```

`common.h`:

```h
#pragma once
#ifndef _COMMON_H_
#define _COMMON_H_


#include <ntifs.h>
#include <wdmsec.h>

#include <ntimage.h>
#include <ntstrsafe.h>
#include <ntddk.h> 
#include <bcrypt.h>
#include <windef.h>

#include "./usugumo_request_define.h"
#include "./defines.h"

#include "./reimpl.h"
#include "./dispatches.h"
#include "./helpers.h"
#include "./imports.h"
#include "./mouse_operation.h"
#include "./keybd_operation.h"
#include "./process.h"
#include "./anti_capture.h"
#include "./request_handler.h"

#endif

```

`defines.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _DEFINES_H_
#define _DEFINES_H_
#include <windef.h>

typedef int BOOL;
typedef ULONG_PTR QWORD;

#define RAISE_IRQL(a, b) *(b) = KfRaiseIrql(a)
#define SDDL_STRING L"D:P(A;;GA;;;WD)"

#define MOUSEEVENTF_ABSOLUTE 0x8000
#define MOUSEEVENTF_HWHEEL 0x01000
#define MOUSEEVENTF_MOVE 0x0001
#define MOUSEEVENTF_MOVE_NOCOALESCE 0x2000
#define MOUSEEVENTF_LEFTDOWN 0x0002
#define MOUSEEVENTF_LEFTUP 0x0004
#define MOUSEEVENTF_RIGHTDOWN 0x0008
#define MOUSEEVENTF_RIGHTUP 0x0010
#define MOUSEEVENTF_MIDDLEDOWN 0x0020
#define MOUSEEVENTF_MIDDLEUP 0x0040
#define MOUSEEVENTF_VIRTUALDESK 0x4000
#define MOUSEEVENTF_WHEEL 0x0800
#define MOUSEEVENTF_XDOWN 0x0080
#define MOUSEEVENTF_XUP 0x0100

#define MOUSE_MOVE_RELATIVE 0x0000
#define MOUSE_MOVE_ABSOLUTE 0x0001
#define MOUSE_VIRTUAL_DESKTOP 0x0002

#define MDL_HDR_SIZE                                                          \
  (FIELD_OFFSET(MDL, MdlFlags) + sizeof(ULONG) + FIELD_OFFSET(MDL, StartVa) - \
   FIELD_OFFSET(MDL, Next))

#define MDL_POOL_SIZE 16
#define MDL_MAX_BUFFER_SIZE 0x80000  // 512kb

typedef struct _MDL_POOL_ITEM {
  BOOLEAN IsAvailable;
  PMDL Mdl;
  SIZE_T MaxBufferSize;
} MDL_POOL_ITEM, *PMDL_POOL_ITEM;

typedef struct _MDL_POOL {
  KSPIN_LOCK Lock;
  MDL_POOL_ITEM Items[MDL_POOL_SIZE];
  SIZE_T MaxSingleMdlSize;
} MDL_POOL, *PMDL_POOL;

typedef struct _PEB_LDR_DATA {
  ULONG Length;
  UCHAR Initialized;
  PVOID SsHandle;
  LIST_ENTRY InLoadOrderModuleList;
  LIST_ENTRY InMemoryOrderModuleList;
  LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
  BYTE Reserved1[16];
  PVOID Reserved2[10];
  UNICODE_STRING ImagePathName;
  UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB {
  UCHAR InheritedAddressSpace;
  UCHAR ReadImageFileExecOptions;
  UCHAR BeingDebugged;
  UCHAR BitField;
  PVOID Mutant;
  PVOID ImageBaseAddress;
  PPEB_LDR_DATA Ldr;
  PVOID ProcessParameters;
  PVOID SubSystemData;
  PVOID ProcessHeap;
  PVOID FastPebLock;
  PVOID AtlThunkSListPtr;
  PVOID IFEOKey;
  PVOID CrossProcessFlags;
  PVOID KernelCallbackTable;
  ULONG SystemReserved;
  ULONG AtlThunkSListPtr32;
  PVOID ApiSetMap;
} PEB, *PPEB;

typedef struct _LDR_DATA_TABLE_ENTRY {
  LIST_ENTRY InLoadOrderLinks;
  LIST_ENTRY InMemoryOrderLinks;
  LIST_ENTRY InInitializationOrderLinks;
  PVOID DllBase;
  PVOID EntryPoint;
  ULONG SizeOfImage;
  UNICODE_STRING FullDllName;
  UNICODE_STRING BaseDllName;
  ULONG Flags;
  USHORT LoadCount;
  USHORT TlsIndex;
  LIST_ENTRY HashLinks;
  ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

#pragma warning(disable : 4201)
typedef struct _MOUSE_INPUT_DATA {
  USHORT UnitId;
  USHORT Flags;
  union {
    ULONG Buttons;
    struct {
      USHORT ButtonFlags;
      USHORT ButtonData;
    };
  };
  ULONG RawButtons;
  LONG LastX;
  LONG LastY;
  ULONG ExtraInformation;
} MOUSE_INPUT_DATA, *PMOUSE_INPUT_DATA;

typedef VOID (*MouseClassServiceCallbackFn)(PDEVICE_OBJECT DeviceObject,
                                            PMOUSE_INPUT_DATA InputDataStart,
                                            PMOUSE_INPUT_DATA InputDataEnd,
                                            PULONG InputDataConsumed);

typedef struct _MOUSE_OBJECT {
  PDEVICE_OBJECT mouse_device;
  MouseClassServiceCallbackFn service_callback;
  BOOL use_mouse;
} MOUSE_OBJECT, *PMOUSE_OBJECT;

typedef struct _KEYBOARD_INPUT_DATA {
  USHORT UnitId;
  USHORT MakeCode;
  USHORT Flags;
  USHORT Reserved;
  ULONG ExtraInformation;
} KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA;

typedef VOID (*KeyboardClassServiceCallbackFn)(PDEVICE_OBJECT DeviceObject,
                                    PKEYBOARD_INPUT_DATA InputDataStart,
                                    PKEYBOARD_INPUT_DATA InputDataEnd,
                                    PULONG InputDataConsumed);

typedef struct _KEYBOARD_OBJECT {
  PDEVICE_OBJECT keyboard_device;
  KeyboardClassServiceCallbackFn service_callback;
  BOOLEAN use_keyboard;
} KEYBOARD_OBJECT, *PKEYBOARD_OBJECT;

typedef BOOL(__fastcall *GreProtectSpriteContentFn)(PVOID, HWND, INT, UINT);

typedef NTSTATUS(NTAPI* fn_ObReferenceObjectByName)(PUNICODE_STRING, ULONG,
                                                    PACCESS_STATE, ACCESS_MASK,
                                                    POBJECT_TYPE,
                                                    KPROCESSOR_MODE, LPVOID,
                                                    PDRIVER_OBJECT*);

#endif

```

`helper_utils.asm`:

```asm
; Copyright (c) 2026 渟雲. All rights reserved.
.data
table_initialized db 0
crc64_table dq 256 dup(0)

.code
CalculateRequestsChecksum proc
    push rbx
    push rdi
    mov r9, rcx
    test rcx, rcx
    jnz loc_continue
    xor eax, eax
    jmp loc_exit

loc_continue:
    cmp table_initialized, 0
    lea rdi, crc64_table
    jne loc_calculate_crc
    mov rcx, 0
    mov rdx, rdi
    mov r11d, 100h

loc_init_table_outer:
    mov rax, rcx
    mov r10d, 8

loc_init_table_inner:
    test al, 1
    jz loc_shift_only
    mov rbx, 85E1C3D753D46D27h
    xor rax, rbx

loc_shift_only:
    shr rax, 1
    sub r10, 1
    jnz loc_init_table_inner
    mov [rdx], rax
    inc rcx
    add rdx, 8
    sub r11, 1
    jnz loc_init_table_outer
    mov table_initialized, 1

loc_calculate_crc:
    mov rax, 0FFFFFFFFFFFFFFFFh
    xor r8, r8

loc_crc_loop:
    movzx ecx, byte ptr [r9+r8]
    inc r8
    xor rax, rcx
    movzx edx, al
    shr rax, 8
    xor rax, [rdi+rdx*8]
    cmp r8, 0B8h
    jb loc_crc_loop
    not rax

loc_exit:
    pop rdi
    pop rbx
    ret
CalculateRequestsChecksum endp

ResolveRelativeAddress proc
xor     eax, eax
test    rcx, rcx
jz      short loc_fin
mov     eax, edx
movsxd  rdx, dword ptr [rax+rcx]
add     rax, 4
add     rax, rdx
add     rax, rcx

loc_fin:
ret
ResolveRelativeAddress endp

END

```

`helpers.c`:

```c
// Copyright (c) 2026 渟雲. All rights reserved.
#include "./common.h"


VOID DecodeFixedStr64(const FixedStr64* fs, char* output, SIZE_T origLen) {
  size_t idx = 0;
  for (size_t block = 0; block < 8; block++) {
    for (int i = 0; i < 8; i++) {
      if (idx >= origLen) {
        break;
      }
      int shift = 8 * (7 - i);
      output[idx++] = (char)((fs->blocks[block] >> shift) & 0xFF);
    }
  }
  output[origLen] = '\0';
}

PWSTR ConvertToPWSTR(const char* ascii_str) {
  SIZE_T len = 0;

  while (ascii_str[len] != '\0') {
    len++;
  }

  wchar_t* w_str = (wchar_t*)ExAllocatePool2(POOL_FLAG_NON_PAGED,
                                             (len + 1) * sizeof(WCHAR), 'NtFs');
  if (!w_str) {
    return NULL;
  }

  for (SIZE_T i = 0; i < len; i++) {
    w_str[i] = (WCHAR)ascii_str[i];
  }
  w_str[len] = L'\0';

  return w_str;
}

PVOID SearchSignForImage(PVOID ImageBase, PUCHAR Pattern, PCHAR Mask,
                                ULONG PatternSize) {
  PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeaderMeme(ImageBase);
  if (!NtHeaders) return NULL;

  PIMAGE_SECTION_HEADER Section = IMAGE_FIRST_SECTION(NtHeaders);
  for (ULONG i = 0; i < NtHeaders->FileHeader.NumberOfSections;
       i++, Section++) {
    if (kstricmp((PCHAR)Section->Name, ".text") == 0 ||
        (Section->Characteristics & IMAGE_SCN_CNT_CODE)) {
      PUCHAR Start = (PUCHAR)ImageBase + Section->VirtualAddress;
      ULONG Size = Section->Misc.VirtualSize;

      for (ULONG j = 0; j <= Size - PatternSize; j++) {
        BOOLEAN Found = TRUE;

        for (ULONG k = 0; k < PatternSize; k++) {
          if (Mask[k] == 'x' && Start[j + k] != Pattern[k]) {
            Found = FALSE;
            break;
          }
        }

        if (Found) return Start + j;
      }
    }
  }

  return NULL;
}

NTSTATUS ZwReferenceObjectByName(PUNICODE_STRING ObjectName, ULONG Attributes,
                                 PACCESS_STATE PassedAccessState,
                                 ACCESS_MASK DesiredAccess,
                                 POBJECT_TYPE ObjectType,
                                 KPROCESSOR_MODE AccessMode,
                                 LPVOID ParseContext, PDRIVER_OBJECT* Object) {
  static fn_ObReferenceObjectByName _ObReferenceObjectByName = NULL;
  NTSTATUS Status = STATUS_UNSUCCESSFUL;

  if (_ObReferenceObjectByName == NULL) {
    UNICODE_STRING FuncName = RTL_CONSTANT_STRING(L"ObReferenceObjectByName");
    _ObReferenceObjectByName =
        (fn_ObReferenceObjectByName)MmGetSystemRoutineAddress(&FuncName);
  }

  if (_ObReferenceObjectByName != NULL) {
    Status = _ObReferenceObjectByName(ObjectName, Attributes, PassedAccessState,
                                      DesiredAccess, ObjectType, AccessMode,
                                      ParseContext, Object);
  }

  return Status;
}

NTSTATUS GetMachineGuid(WCHAR* guid_buf, size_t buf_len) {
  if (!guid_buf || buf_len < 64) {
    return STATUS_INVALID_PARAMETER;
  }

  UNICODE_STRING key_path = RTL_CONSTANT_STRING(
      L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Cryptography");
  UNICODE_STRING value_name = RTL_CONSTANT_STRING(L"MachineGuid");
  HANDLE hKey = NULL;
  NTSTATUS status = STATUS_SUCCESS;
  ULONG data_len = 0;
  PKEY_VALUE_PARTIAL_INFORMATION pInfo = NULL;

  OBJECT_ATTRIBUTES obj_attr;
  InitializeObjectAttributes(
      &obj_attr,
      &key_path,
      OBJ_CASE_INSENSITIVE,
      NULL,
      NULL
  );

  status = ZwOpenKey(&hKey, KEY_READ, &obj_attr);
  if (!NT_SUCCESS(status)) {
    return status;
  }

  status = ZwQueryValueKey(hKey, &value_name, KeyValuePartialInformation, NULL,
                           0, &data_len);
  if (status != STATUS_BUFFER_TOO_SMALL) {
    ZwClose(hKey);
    return status;
  }

  pInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ExAllocatePool2(POOL_FLAG_PAGED,
                                                          data_len, 'File');
  if (!pInfo) {
    ZwClose(hKey);
    return STATUS_INSUFFICIENT_RESOURCES;
  }

  status = ZwQueryValueKey(hKey, &value_name, KeyValuePartialInformation, pInfo,
                           data_len, &data_len);
  if (NT_SUCCESS(status)) {
    size_t copy_len = min((size_t)data_len, buf_len - 1);
    kmemmove(guid_buf, pInfo->Data, copy_len * sizeof(WCHAR));
    guid_buf[copy_len] = L'\0';
  }

  if (pInfo) ExFreePool(pInfo);
  ZwClose(hKey);
  return status;
}

```

`helpers.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _HELPERS_H_
#define _HELPERS_H_

VOID DecodeFixedStr64(const FixedStr64*, char*, SIZE_T);

PWSTR ConvertToPWSTR(const char*);

PVOID SearchSignForImage(PVOID, PUCHAR, PCHAR, ULONG);

LPBYTE ResolveRelativeAddress(PVOID, ULONG);

NTSTATUS ZwReferenceObjectByName(PUNICODE_STRING, ULONG, PACCESS_STATE,
                                 ACCESS_MASK, POBJECT_TYPE, KPROCESSOR_MODE,
                                 LPVOID, PDRIVER_OBJECT*);

unsigned __int64 CalculateRequestsChecksum(Requests*);

NTSTATUS GetMachineGuid(WCHAR*, SIZE_T);

#endif

```

`imports.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _IMPORTS_H_
#define _IMPORTS_H_
#include <ntifs.h>
#include <wdmsec.h>

#include "./defines.h"

QWORD _KeAcquireSpinLockAtDpcLevel;
QWORD _KeReleaseSpinLockFromDpcLevel;
QWORD _IofCompleteRequest;
QWORD _IoReleaseRemoveLockEx;

NTKERNELAPI NTSTATUS
IoCreateDriver(_In_ PUNICODE_STRING DriverName,
               _In_ PDRIVER_INITIALIZE InitializationFunction);

NTSYSAPI PPEB PsGetProcessPeb(PEPROCESS);

NTSYSCALLAPI
POBJECT_TYPE* IoDriverObjectType;

NTSYSCALLAPI
NTSTATUS
ObReferenceObjectByName(__in PUNICODE_STRING ObjectName, __in ULONG Attributes,
                        __in_opt PACCESS_STATE AccessState,
                        __in_opt ACCESS_MASK DesiredAccess,
                        __in POBJECT_TYPE ObjectType,
                        __in KPROCESSOR_MODE AccessMode,
                        __inout_opt PVOID ParseContext, __out PVOID* Object);

NTSYSAPI
NTSTATUS
NTAPI
ZwProtectVirtualMemory(IN HANDLE ProcessHandle, IN OUT PVOID* BaseAddress,
                       IN OUT PSIZE_T RegionSize, IN ULONG NewProtect,
                       OUT PULONG OldProtect);

NTSYSAPI PCHAR PsGetProcessImageFileName(PEPROCESS Process);

#endif

```

`ke_reimpl.asm`:

```asm
; Copyright (c) 2026 渟雲. All rights reserved.
.code

KeGetCurrentIrqlMeme proc
mov     rax, cr8
ret
KeGetCurrentIrqlMeme endp

END

```

`keybd_operation.c`:

```c
// Copyright (c) 2026 渟雲. All rights reserved.
// https://github.com/oakboat/GsDriver-ring3/
#include "./common.h"

KSPIN_LOCK g_KeyboardSpinLock;
KEYBOARD_OBJECT gKeyboardObject = {0};

VOID KeyboardSpinLockInit() { KeInitializeSpinLock(&g_KeyboardSpinLock); }

NTSTATUS SearchServiceFromKdbExt(PDRIVER_OBJECT KbdDriverObject,
                                 PDEVICE_OBJECT pPortDev) {
  NTSTATUS Status = STATUS_UNSUCCESSFUL;
  PDEVICE_OBJECT pTargetDeviceObject = NULL;
  UCHAR* DeviceExt = NULL;
  PVOID KbdDriverStart = NULL;
  ULONG KbdDriverSize = 0;
  PDEVICE_OBJECT pTmpDev = NULL;
  UNICODE_STRING kbdDriName = RTL_CONSTANT_STRING(L"\\Driver\\kbdclass");
  ULONG_PTR i = 0;
  ULONG_PTR DeviceExtSize = 0;
  KIRQL Irql;

  KbdDriverStart = KbdDriverObject->DriverStart;
  KbdDriverSize = KbdDriverObject->DriverSize;

  pTmpDev = pPortDev;
  while (pTmpDev->AttachedDevice != NULL) {
    if (RtlCompareUnicodeString(
            &pTmpDev->AttachedDevice->DriverObject->DriverName, &kbdDriName,
            TRUE)) {
      pTmpDev = pTmpDev->AttachedDevice;
    } else {
      break;
    }
  }

  if (pTmpDev->AttachedDevice != NULL) {
    pTargetDeviceObject = KbdDriverObject->DeviceObject;
    while (pTargetDeviceObject) {
      if (pTmpDev->AttachedDevice != pTargetDeviceObject) {
        pTargetDeviceObject = pTargetDeviceObject->NextDevice;
        continue;
      }

      DeviceExt = (UCHAR*)pTmpDev->DeviceExtension;
      DeviceExtSize = (ULONG_PTR)pTmpDev->DeviceObjectExtension -
                      (ULONG_PTR)pTmpDev->DeviceExtension;
      if (DeviceExtSize == 0 || DeviceExtSize > PAGE_SIZE) {
        DeviceExtSize = PAGE_SIZE;
      }

      KeAcquireSpinLock(&g_KeyboardSpinLock, &Irql);
      gKeyboardObject.keyboard_device = NULL;
      gKeyboardObject.service_callback = NULL;
      KeReleaseSpinLock(&g_KeyboardSpinLock, Irql);

      for (i = 0; i < DeviceExtSize; i++, DeviceExt++) {
        if (MmIsAddressValid(DeviceExt) &&
            MmIsAddressValid((PVOID*)DeviceExt)) {
          PVOID pTemp = *(PVOID*)DeviceExt;

          KeAcquireSpinLock(&g_KeyboardSpinLock, &Irql);
          if (gKeyboardObject.keyboard_device &&
              gKeyboardObject.service_callback) {
            KeReleaseSpinLock(&g_KeyboardSpinLock, Irql);
            Status = STATUS_SUCCESS;
            break;
          }
          KeReleaseSpinLock(&g_KeyboardSpinLock, Irql);

          if (pTemp == pTargetDeviceObject) {
            KeAcquireSpinLock(&g_KeyboardSpinLock, &Irql);
            gKeyboardObject.keyboard_device = pTargetDeviceObject;
            KeReleaseSpinLock(&g_KeyboardSpinLock, Irql);
            continue;
          }

          if (pTemp > KbdDriverStart &&
              pTemp < (PVOID)((UCHAR*)KbdDriverStart + KbdDriverSize) &&
              MmIsAddressValid(pTemp)) {
            KeAcquireSpinLock(&g_KeyboardSpinLock, &Irql);
            gKeyboardObject.service_callback =
                (KeyboardClassServiceCallbackFn)pTemp;
            KeReleaseSpinLock(&g_KeyboardSpinLock, Irql);
          }
        } else {
          break;
        }
      }

      if (Status == STATUS_SUCCESS) {
        break;
      }

      pTargetDeviceObject = pTargetDeviceObject->NextDevice;
    }
  }

  return Status;
}

NTSTATUS SearchKdbServiceCallBack(void) {
  NTSTATUS Status = STATUS_UNSUCCESSFUL;
  PDRIVER_OBJECT ClassObject = NULL;
  PDRIVER_OBJECT DriverObject = NULL;
  PDEVICE_OBJECT DeviceObject = NULL;
  UNICODE_STRING DeviceName[] = {RTL_CONSTANT_STRING(L"\\Driver\\kbdhid"),
                                 RTL_CONSTANT_STRING(L"\\Driver\\i8042prt")};
  size_t i = 0;
  UNICODE_STRING ClassName = RTL_CONSTANT_STRING(L"\\Driver\\kbdclass");

  for (i = 0; i < ARRAYSIZE(DeviceName); i++) {
    Status = ZwReferenceObjectByName(&DeviceName[i], OBJ_CASE_INSENSITIVE, NULL,
                                     0, *IoDriverObjectType, KernelMode, NULL,
                                     (PDRIVER_OBJECT*)&DriverObject);
    if (NT_SUCCESS(Status)) {
      break;
    }
  }

  if (DriverObject != NULL) {
    Status = ZwReferenceObjectByName(&ClassName, OBJ_CASE_INSENSITIVE, NULL, 0,
                                     *IoDriverObjectType, KernelMode, NULL,
                                     (PDRIVER_OBJECT*)&ClassObject);
    if (NT_SUCCESS(Status)) {
      DeviceObject = DriverObject->DeviceObject;
      while (DeviceObject) {
        Status = SearchServiceFromKdbExt(ClassObject, DeviceObject);
        if (!NT_SUCCESS(Status)) {
          DeviceObject = DeviceObject->NextDevice;
        } else {
          break;
        }
      }
      ObfDereferenceObject(ClassObject);
    }
    ObfDereferenceObject(DriverObject);
  }

  return Status;
}

inline BOOL KeyboardOpen(void) {
  NTSTATUS Status = STATUS_UNSUCCESSFUL;
  KIRQL Irql;

  KeAcquireSpinLock(&g_KeyboardSpinLock, &Irql);
  if (gKeyboardObject.use_keyboard && gKeyboardObject.keyboard_device &&
      gKeyboardObject.service_callback) {
    KeReleaseSpinLock(&g_KeyboardSpinLock, Irql);
    return TRUE;
  }
  KeReleaseSpinLock(&g_KeyboardSpinLock, Irql);

  Status = SearchKdbServiceCallBack();

  KeAcquireSpinLock(&g_KeyboardSpinLock, &Irql);
  if (NT_SUCCESS(Status) && gKeyboardObject.keyboard_device &&
      gKeyboardObject.service_callback) {
    gKeyboardObject.use_keyboard = 1;
    KeReleaseSpinLock(&g_KeyboardSpinLock, Irql);
    return TRUE;
  } else {
    KeReleaseSpinLock(&g_KeyboardSpinLock, Irql);
    return FALSE;
  }
}

inline void KeyboardCall(USHORT make_code, USHORT flags, ULONG extra_info) {
  KIRQL irql;
  ULONG input_data = 0;
  KEYBOARD_INPUT_DATA kbd = {0};

  if (!KeyboardOpen()) {
    return;
  }

  kbd.UnitId = 0;
  kbd.MakeCode = make_code;
  kbd.Flags = flags;
  kbd.Reserved = 0;
  kbd.ExtraInformation = extra_info;

  RAISE_IRQL(DISPATCH_LEVEL, &irql);
  gKeyboardObject.service_callback(gKeyboardObject.keyboard_device, &kbd,
                                   &kbd + 1, &input_data);
  KeLowerIrql(irql);
}

VOID HandleKeybdEvent(Requests* request) {
  if (!request) return;

  DWORD dwFlags = request->dwFlags;
  ULONG extra_info = (ULONG)request->dwExtraInfo;

  // NOTE: untested.
  if (dwFlags & 0x0004) {
    WCHAR unicode_char = (WCHAR)request->bVK;
    KeyboardCall((USHORT)unicode_char, 0x0006, extra_info);
    KeyboardCall((USHORT)unicode_char, 0x0007, extra_info);

    request->return_value = TRUE;
    return;
  }

  USHORT make_code = dwFlags & 0x0008 ? request->bScan : request->bVK;

  USHORT final_flags = dwFlags & 0x0002 ? 0x0007 : 0x0006;

  if (dwFlags & 0x0001) {
    final_flags |= 0x0001;
  }

  KeyboardCall(make_code, final_flags, extra_info);

  request->return_value = TRUE;
}

```

`keybd_operation.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _KEYBD_OPERATION_H_
#define _KEYBD_OPERATION_H_

NTSTATUS SearchKdbServiceCallBack(void);

VOID HandleKeybdEvent(Requests*);

VOID KeyboardSpinLockInit();

#endif

```

`kmem.asm`:

```asm
; Copyright (c) 2026 渟雲. All rights reserved.
EXTERNDEF __cpu_features_init:PROC

__isa_info_t STRUC
    info    BYTE ?
            BYTE 63 DUP(?)
__isa_info_t ENDS

EXTERN __isa_info:__isa_info_t

.code

kmemmove proc
    mov     rax, rcx
    cmp     r8, 8
    jb      short loc_1406B6F80
    cmp     r8, 10h
    ja      short loc_1406B6F60
    mov     r11, [rdx]
    mov     rdx, [rdx+r8-8]
    mov     [rcx], r11
    mov     [rcx+r8-8], rdx
    ret

loc_1406B6F60:
    cmp     r8, 20h
    ja      short loc_1406B6FC0
    movups  xmm0, xmmword ptr [rdx]
    movups  xmm1, xmmword ptr [rdx+r8-10h]
    movups  xmmword ptr [rcx], xmm0
    movups  xmmword ptr [rcx+r8-10h], xmm1
    ret

    align 10h
loc_1406B6F80:
    test    r8, r8
    jz      short locret_1406B6F9A
    sub     rdx, rcx
    jb      short loc_1406B6FA0

loc_1406B6F8A:
    mov     r11b, [rcx+rdx]
    inc     rcx
    dec     r8
    mov     [rcx-1], r11b
    jnz     short loc_1406B6F8A

locret_1406B6F9A:
    ret

    align 10h
loc_1406B6FA0:
    add     rcx, r8

loc_1406B6FA3:
    mov     r11b, [rcx+rdx-1]
    dec     rcx
    dec     r8
    mov     [rcx], r11b
    jnz     short loc_1406B6FA3
    ret

    align 10h
loc_1406B6FC0:
    lea     r11, [rdx+r8]
    sub     rdx, rcx
    jnb     short loc_1406B6FD2
    cmp     r11, rcx
    ja      loc_1406B7140

loc_1406B6FD2:
    movups  xmm0, xmmword ptr [rcx+rdx]
    add     rcx, 10h
    test    cl, 0Fh
    jz      short loc_1406B6FF1
    and     rcx, 0FFFFFFFFFFFFFFF0h
    movups  xmm1, xmmword ptr [rcx+rdx]
    movups  xmmword ptr [rax], xmm0
    movaps  xmm0, xmm1
    add     rcx, 10h

loc_1406B6FF1:
    add     r8, rax
    sub     r8, rcx
    mov     r9, r8
    shr     r9, 6
    jz      short loc_1406B706F
    cmp     r9, 1000h
    ja      loc_1406B70C0
    and     r8, 3Fh
    jmp     short loc_1406B7040

    align 10h
loc_1406B7040:
    movups  xmm1, xmmword ptr [rcx+rdx]
    movups  xmm2, xmmword ptr [rcx+rdx+10h]
    movups  xmm3, xmmword ptr [rcx+rdx+20h]
    movups  xmm4, xmmword ptr [rcx+rdx+30h]
    movaps  xmmword ptr [rcx-10h], xmm0
    add     rcx, 40h
    dec     r9
    movaps  xmmword ptr [rcx-40h], xmm1
    movaps  xmmword ptr [rcx-30h], xmm2
    movaps  xmmword ptr [rcx-20h], xmm3
    movaps  xmm0, xmm4
    jnz     short loc_1406B7040

loc_1406B706F:
    mov     r9, r8
    shr     r9, 4
    jz      short loc_1406B7091
    nop     dword ptr [rax+rax+00000000h]

loc_1406B7080:
    movaps  xmmword ptr [rcx-10h], xmm0
    movups  xmm0, xmmword ptr [rcx+rdx]
    add     rcx, 10h
    dec     r9
    jnz     short loc_1406B7080

loc_1406B7091:
    and     r8, 0Fh
    jz      short loc_1406B70A5
    lea     r11, [rcx+r8-10h]
    movups  xmm1, xmmword ptr [r11+rdx]
    movups  xmmword ptr [r11], xmm1

loc_1406B70A5:
    movaps  xmmword ptr [rcx-10h], xmm0
    ret

    align 10h
loc_1406B70C0:
    mov     r9, r8
    shr     r9, 6
    and     r8, 3Fh
    prefetchnta byte ptr [rcx+rdx+40h]
    jmp     short loc_1406B7100

    align 10h
loc_1406B7100:
    movups  xmm1, xmmword ptr [rcx+rdx]
    movups  xmm2, xmmword ptr [rcx+rdx+10h]
    movups  xmm3, xmmword ptr [rcx+rdx+20h]
    movups  xmm4, xmmword ptr [rcx+rdx+30h]
    movntps xmmword ptr [rcx-10h], xmm0
    add     rcx, 40h
    prefetchnta byte ptr [rcx+rdx+40h]
    dec     r9
    movntps xmmword ptr [rcx-40h], xmm1
    movntps xmmword ptr [rcx-30h], xmm2
    movntps xmmword ptr [rcx-20h], xmm3
    movaps  xmm0, xmm4
    jnz     short loc_1406B7100
    sfence
    jmp     loc_1406B706F

    align 10h
loc_1406B7140:
    add     rcx, r8
    movups  xmm0, xmmword ptr [rcx+rdx-10h]
    sub     rcx, 10h
    sub     r8, 10h
    test    cl, 0Fh
    jz      short loc_1406B716D
    mov     r11, rcx
    and     rcx, 0FFFFFFFFFFFFFFF0h
    movups  xmm1, xmmword ptr [rcx+rdx]
    movups  xmmword ptr [r11], xmm0
    movaps  xmm0, xmm1
    mov     r8, rcx
    sub     r8, rax

loc_1406B716D:
    mov     r9, r8
    shr     r9, 6
    jz      short loc_1406B71AF
    and     r8, 3Fh
    jmp     short loc_1406B7180

    align 10h
loc_1406B7180:
    movups  xmm1, xmmword ptr [rcx+rdx-10h]
    movups  xmm2, xmmword ptr [rcx+rdx-20h]
    movups  xmm3, xmmword ptr [rcx+rdx-30h]
    movups  xmm4, xmmword ptr [rcx+rdx-40h]
    movaps  xmmword ptr [rcx], xmm0
    sub     rcx, 40h
    dec     r9
    movaps  xmmword ptr [rcx+30h], xmm1
    movaps  xmmword ptr [rcx+20h], xmm2
    movaps  xmmword ptr [rcx+10h], xmm3
    movaps  xmm0, xmm4
    jnz     short loc_1406B7180

loc_1406B71AF:
    mov     r9, r8
    shr     r9, 4
    jz      short loc_1406B71D1
    nop     dword ptr [rax+rax+00000000h]

loc_1406B71C0:
    movaps  xmmword ptr [rcx], xmm0
    movups  xmm0, xmmword ptr [rcx+rdx-10h]
    sub     rcx, 10h
    dec     r9
    jnz     short loc_1406B71C0

loc_1406B71D1:
    and     r8, 0Fh
    jz      short loc_1406B71E6
    mov     r11, rcx
    sub     r11, r8
    movups  xmm1, xmmword ptr [r11+rdx]
    movups  xmmword ptr [r11], xmm1

loc_1406B71E6:
    movaps  xmmword ptr [rcx], xmm0
    ret
kmemmove endp

__kmemset_query proc

var_38= xmmword ptr -38h

push    r9
push    r8
push    rdx
push    rcx
push    rax
sub     rsp, 30h
movaps  [rsp+58h+var_38], xmm0
call    __cpu_features_init
movaps  xmm0, [rsp+58h+var_38]
add     rsp, 30h
pop     rax
pop     rcx
pop     rdx
pop     r8
pop     r9
ret
__kmemset_query endp

__kmemset_repmovs proc
push    rdi
test    __isa_info.info, 1
jz      short repmovs20

repmovs10:
mov     rdi, rcx
add     r8, rcx
movups  xmmword ptr [rcx], xmm0
add     rdi, 40h ; '@'
movups  xmmword ptr [rcx+10h], xmm0
and     rdi, 0FFFFFFFFFFFFFFC0h
movups  xmmword ptr [rcx+20h], xmm0
sub     r8, rdi
movups  xmmword ptr [rcx+30h], xmm0
mov     rcx, r8
mov     r9, rax
movq    rax, xmm0
rep stosb
mov     rax, r9
pop     rdi
ret

repmovs20:
call    __kmemset_query
jmp     short repmovs10
__kmemset_repmovs endp

kmemset proc
mov     rax, rcx
movzx   edx, dl
mov     r9, 101010101010101h
imul    rdx, r9
movq    xmm0, rdx
movlhps xmm0, xmm0
cmp     r8, 40h ; '@'
jb      short mset45

mset10:
test    __isa_info.info, 2
jz      short mset20
cmp     r8, 320h
jnb     __kmemset_repmovs

mset20:
movups  xmmword ptr [rcx], xmm0
add     r8, rcx
add     rcx, 10h
and     rcx, 0FFFFFFFFFFFFFFF0h
sub     r8, rcx
cmp     r8, 40h ; '@'
jb      short mset46
lea     rdx, [rcx+r8-10h]
lea     r9, [rcx+r8-30h]
and     r9, 0FFFFFFFFFFFFFFF0h
shr     r8, 6

mset30:
movaps  xmmword ptr [rcx], xmm0
movaps  xmmword ptr [rcx+10h], xmm0
add     rcx, 40h ; '@'
dec     r8
movaps  xmmword ptr [rcx-20h], xmm0
movaps  xmmword ptr [rcx-10h], xmm0
jnz     short mset30
movaps  xmmword ptr [r9], xmm0
movaps  xmmword ptr [r9+10h], xmm0
movaps  xmmword ptr [r9+20h], xmm0
movups  xmmword ptr [rdx], xmm0
ret
align 10h

mset45:
cmp     r8, 10h
jb      short mset47

mset46:
lea     r9, [r8+rcx-10h]
and     r8, 20h
movups  xmmword ptr [rcx], xmm0
shr     r8, 1
movups  xmmword ptr [r9], xmm0
movups  xmmword ptr [rcx+r8], xmm0
neg     r8
movups  xmmword ptr [r9+r8], xmm0
ret
align 10h

mset47:
cmp     r8, 4
jb      short mset48
lea     r9, [r8+rcx-4]
and     r8, 8
mov     [rcx], edx
shr     r8, 1
mov     [r9], edx
mov     [rcx+r8], edx
neg     r8
mov     [r9+r8], edx
ret
align 10h

mset48:
test    r8, r8
jz      short mset50
mov     [rcx], dl
lea     r9, [rcx+r8-2]
cmp     r8, 1
jz      short mset50
mov     [r9], dx

mset50:
ret
kmemset endp

END

```

`mouse.asm`:

```asm
EXTERNDEF _KeAcquireSpinLockAtDpcLevel:PROC
EXTERNDEF _KeReleaseSpinLockFromDpcLevel:PROC
EXTERNDEF _IofCompleteRequest:PROC
EXTERNDEF _IoReleaseRemoveLockEx:PROC
EXTERNDEF kmemmove:PROC
.data
WPP_RECORDER_INITIALIZED dq 0;
WPP_GLOBAL_Control dq 0;
.code

WPP_RECORDER_SFMeme proc
	ret
WPP_RECORDER_SFMeme endp

MouseClassReadCopyDataMeme proc
	mov    r11,rsp
	mov    QWORD PTR [r11+8h],rbx
	mov    QWORD PTR [r11+10h],rbp
	mov    QWORD PTR [r11+18h],rsi
	push   rdi
	push   r12
	push   r13
	push   r14
	push   r15
	sub    rsp,50h
	inc    DWORD PTR [rcx+0a8h]
	mov    rsi,rdx
	mov    eax,DWORD PTR [rcx+54h]
	mov    rdi,rcx
	mov    r13,QWORD PTR [rdx+0b8h]
	lea    ebp,[rax+rax*2]
	mov    ebx,DWORD PTR [r13+8h]
	shl    ebp,3h
	mov    edx,DWORD PTR [rdi+88h]
	cmp    ebp,ebx
	cmovae ebp,ebx
	sub    edx,DWORD PTR [rdi+78h]
	add    edx,DWORD PTR [rdi+68h]
	mov    r12d,ebp
	cmp    ebp,edx
	cmovae r12d,edx
	mov    r14,QWORD PTR [rsi+18h]
	mov    rdx,QWORD PTR [rdi+78h]
	mov    rcx,r14
	mov    r8d,r12d
	mov    r15d,r12d
	call   kmemmove
	add    r14,r15
	mov    ebx,ebp
	sub    ebx,r12d
	je     J1A5
	mov    rdx,QWORD PTR [rdi+68h]
	mov    r8,rbx
	mov    rcx,r14
	call   kmemmove
	mov    rcx,QWORD PTR [rdi+68h]
	add    rcx,rbx
	mov    QWORD PTR [rdi+78h],rcx
	jmp    J1B0
J1A5:
	add    QWORD PTR [rdi+78h],r15
J1B0:
	mov    ebx,ebp
	mov    rax,0aaaaaaaaaaaaaaabh
	mul    rbx
	shr    rdx,4h
	sub    DWORD PTR [rdi+54h],edx
	jne    J1FF
	mov    BYTE PTR [rdi+42h],1h
J1FF:
	mov    QWORD PTR [rsi+38h],rbx
	lea    r11,[rsp+50h]
	mov    rbx,QWORD PTR [r11+30h]
	xor    eax,eax
	mov    rsi,QWORD PTR [r11+40h]
	mov    DWORD PTR [r13+8h],ebp
	mov    rbp,QWORD PTR [r11+38h]
	mov    rsp,r11
	pop    r15
	pop    r14
	pop    r13
	pop    r12
	pop    rdi
	ret
MouseClassReadCopyDataMeme endp




MouseClassDequeueReadMeme proc
	xor    edx,edx
	lea    r8,[rcx+98h]
J9:
	mov    rcx,QWORD PTR [r8]
	cmp    rcx,r8
	je     J47
	cmp    QWORD PTR [rcx+8h],r8
	jne    J4C
	mov    rax,QWORD PTR [rcx]
	cmp    QWORD PTR [rax+8h],rcx
	jne    J4C
	mov    QWORD PTR [r8],rax
	lea    rdx,[rcx-0a8h]
	mov    QWORD PTR [rax+8h],r8
	xor    eax,eax
	xchg   QWORD PTR [rdx+68h],rax
	test   rax,rax
	jne    J42
	mov    QWORD PTR [rcx+8h],rcx
	xor    edx,edx
	mov    QWORD PTR [rcx],rcx
J42:
	test   rdx,rdx
	je     J9
J47:
	mov    rax,rdx
	ret
	int    3
J4C:
	mov    ecx,3h
	int    29h
MouseClassDequeueReadMeme endp


MouseClassServiceCallbackMeme proc
	mov    rax,rsp
	mov    QWORD PTR [rax+8h],rbx
	mov    QWORD PTR [rax+10h],rsi
	mov    QWORD PTR [rax+18h],rdi
	mov    QWORD PTR [rax+20h],r9
	push   rbp
	push   r12
	push   r13
	push   r14
	push   r15
	mov    rbp,rsp
	sub    rsp,70h
	mov    r13,r9
	mov    rbx,r8
	mov    r14,rdx
	mov    r15,rcx



	
	lea    rax, WPP_RECORDER_INITIALIZED
	xor    esi,esi
	cmp    WPP_RECORDER_INITIALIZED, rax
	jne    J61
	mov    rcx,QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],si
	je     J61
	mov    rcx,QWORD PTR [rcx+40h]
	lea    r9d,[rsi+32h]
	lea    r8d,[rsi+3h]
	mov    dl,5h
	call   WPP_RECORDER_SFMeme

J61:


	mov    rdi,QWORD PTR [r15+40h]
	sub    ebx,r14d
	mov    r12d,esi
	mov    DWORD PTR [r13+0h],esi
	lea    rcx,[rdi+90h]
	call   QWORD PTR _KeAcquireSpinLockAtDpcLevel
	nop    DWORD PTR [rax+rax*1+0h]
	lea    rax,[rbp-10h]
	mov    rcx,rdi
	mov    QWORD PTR [rbp-8h],rax
	lea    rax,[rbp-10h]
	mov    QWORD PTR [rbp-10h],rax
	call   MouseClassDequeueReadMeme
	mov    rsi,rax
	xor    r9d,r9d
	mov    rax,0aaaaaaaaaaaaaaabh
	test   rsi,rsi
	je     J1aa
	mov    r13,QWORD PTR [rsi+0b8h]
	mov    r12d,ebx
	mov    r8d,DWORD PTR [r13+8h]
	cmp    ebx,r8d
	cmovae r12d,r8d
	mul    r12
	mov    rax,QWORD PTR [rbp+48h]
	shr    rdx,4h
	add    DWORD PTR [rax],edx
	lea    rax, WPP_RECORDER_INITIALIZED
	cmp    WPP_RECORDER_INITIALIZED,rax
	jne    J11d
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],r9w
	je     J11d
	mov    rax,QWORD PTR [rsi+18h]
	mov    rcx,QWORD PTR [rcx+40h]
	mov    QWORD PTR [rsp+50h],rax
	mov    QWORD PTR [rsp+48h],r14
	mov    DWORD PTR [rsp+40h],r8d
	mov    DWORD PTR [rsp+38h],ebx
	mov    QWORD PTR [rsp+30h],rsi
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SFMeme

J11d:

	mov    rax,0fffff78000000014h
	mov    rax,QWORD PTR [rax]
	lea    rdx,WPP_RECORDER_INITIALIZED
	cmp    WPP_RECORDER_INITIALIZED,rdx
	jne    J15e
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	mov    DWORD PTR [rsp+40h],r12d
	mov    QWORD PTR [rsp+38h],rax
	mov    QWORD PTR [rsp+30h],rsi
	mov    rcx,QWORD PTR [rcx+40h]
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SFMeme

J15e:

	mov    rcx,QWORD PTR [rsi+18h]
	mov    r8,r12
	mov    rdx,r14
	call   kmemmove
	mov    QWORD PTR [rsi+38h],r12
	lea    rcx,[rbp-10h]
	xor    r8d,r8d
	mov    DWORD PTR [rsi+30h],r8d
	add    rsi,0a8h
	mov    DWORD PTR [r13+8h],r12d
	mov    rax,QWORD PTR [rbp-8h]
	cmp    QWORD PTR [rax],rcx
	jne    J495
	mov    r13,QWORD PTR [rbp+48h]
	lea    rcx,[rbp-10h]
	mov    QWORD PTR [rsi],rcx
	mov    QWORD PTR [rsi+8h],rax
	mov    QWORD PTR [rax],rsi
	mov    QWORD PTR [rbp-8h],rsi

J1aa:

	mov    eax,r12d
	add    r14,rax
	sub    ebx,r12d
	lea    r12,WPP_RECORDER_INITIALIZED
	xor    esi,esi
	cmp    WPP_RECORDER_INITIALIZED,r12
	jne    J1e4
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],si
	je     J1e4
	mov    rcx,QWORD PTR [rcx+40h]
	mov    DWORD PTR [rsp+30h],ebx
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SFMeme

J1e4:

	test   ebx,ebx
	je     J41d
	cmp    WPP_RECORDER_INITIALIZED,r12
	jne    J22f
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],si
	je     J22f
	mov    eax,DWORD PTR [rdi+54h]
	mov    r9d,36h
	mov    rcx,QWORD PTR [rcx+40h]
	mov    DWORD PTR [rsp+38h],ebx
	lea    edx,[rax+rax*2]
	mov    eax,DWORD PTR [rdi+88h]
	shl    edx,3h
	sub    eax,edx
	mov    DWORD PTR [rsp+30h],eax
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SFMeme

J22f:

	mov    ecx,DWORD PTR [rdi+88h]
	cmp    ecx,ebx
	mov    r12d,ecx
	cmovae r12d,ebx
	sub    ecx,DWORD PTR [rdi+70h]
	mov    ebx,DWORD PTR [rdi+68h]
	add    ebx,ecx
	lea    rax,WPP_RECORDER_INITIALIZED
	cmp    WPP_RECORDER_INITIALIZED,rax
	jne    J287
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],si
	je     J287
	mov    rcx,QWORD PTR [rcx+40h]
	mov    r9d,38h
	mov    DWORD PTR [rsp+38h],ebx
	mov    DWORD PTR [rsp+30h],r12d
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SFMeme
	lea    rax,WPP_RECORDER_INITIALIZED

J287:

	cmp    r12d,ebx
	mov    esi,r12d
	cmovae esi,ebx
	cmp    WPP_RECORDER_INITIALIZED,rax
	jne    J2cc
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	xor    eax,eax
	cmp    WORD PTR [rcx+48h],ax
	je     J2cc
	mov    rcx,QWORD PTR [rcx+40h]
	lea    r9d,[rax+39h]
	mov    rax,QWORD PTR [rdi+70h]
	mov    QWORD PTR [rsp+40h],rax
	mov    QWORD PTR [rsp+38h],r14
	mov    DWORD PTR [rsp+30h],esi
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SFMeme

J2cc:

	mov    rcx,QWORD PTR [rdi+70h]
	mov    rdx,r14
	mov    r8d,esi
	mov    ebx,esi
	call   kmemmove
	add    QWORD PTR [rdi+70h],rbx
	add    r14,rbx
	mov    rdx,QWORD PTR [rdi+68h]
	mov    eax,DWORD PTR [rdi+88h]
	mov    rcx,QWORD PTR [rdi+70h]
	add    rax,rdx
	cmp    rcx,rax
	jb     J301
	mov    QWORD PTR [rdi+70h],rdx
	mov    rcx,rdx

J301:

	mov    ebx,r12d
	sub    ebx,esi
	je     J362
	lea    rdx,WPP_RECORDER_INITIALIZED
	mov    rax,rcx
	cmp    WPP_RECORDER_INITIALIZED,rdx
	jne    J350
	mov    rdx, QWORD PTR WPP_GLOBAL_Control
	xor    r8d,r8d
	cmp    WORD PTR [rdx+48h],r8w
	je     J350
	mov    QWORD PTR [rsp+40h],rcx
	lea    r9d,[r8+03ah]
	mov    rcx,QWORD PTR [rdx+40h]
	mov    QWORD PTR [rsp+38h],r14
	mov    DWORD PTR [rsp+30h],ebx
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SFMeme
	mov    rax,QWORD PTR [rdi+70h]

J350:

	mov    r8,rbx
	mov    rdx,r14
	mov    rcx,rax
	call   kmemmove
	add    QWORD PTR [rdi+70h],rbx

J362:

	mov    ecx,r12d
	mov    rax,0aaaaaaaaaaaaaaabh
	mul    rcx
	shr    rdx,4h
	add    DWORD PTR [rdi+54h],edx
	mov    ecx,DWORD PTR [r13+0h]
	add    ecx,edx
	mov    eax,ecx
	mov    DWORD PTR [r13+0h],ecx
	lea    r12,WPP_RECORDER_INITIALIZED
	xor    esi,esi
	cmp    WPP_RECORDER_INITIALIZED,r12
	jne    J41d
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],si
	je     J41d
	mov    rcx,QWORD PTR [rcx+40h]
	mov    DWORD PTR [rsp+48h],eax
	mov    rax,QWORD PTR [rdi+78h]
	mov    QWORD PTR [rsp+40h],rax
	mov    rax,QWORD PTR [rdi+70h]
	mov    QWORD PTR [rsp+38h],rax
	mov    eax,DWORD PTR [rdi+54h]
	mov    DWORD PTR [rsp+30h],eax
	mov    QWORD PTR [rsp+28h],r15
	call   WPP_RECORDER_SFMeme
	jmp    J41d

J3d5:

	mov    rcx,rdi
	call   MouseClassDequeueReadMeme
	mov    rbx,rax
	test   rax,rax
	je     J422
	mov    rdx,rax
	mov    rcx,rdi
	call   MouseClassReadCopyDataMeme
	mov    DWORD PTR [rbx+30h],eax
	lea    rcx,[rbp-10h]
	mov    rdx,QWORD PTR [rbp-8h]
	lea    rax,[rbx+0a8h]
	cmp    QWORD PTR [rdx],rcx
	jne    J495
	mov    QWORD PTR [rax+8h],rdx
	lea    rcx,[rbp-10h]
	mov    QWORD PTR [rax],rcx
	mov    QWORD PTR [rdx],rax
	mov    QWORD PTR [rbp-8h],rax

J41d:

	cmp    DWORD PTR [rdi+54h],esi


	ja     J3d5

J422:

	lea    rcx,[rdi+90h]
	call   QWORD PTR _KeReleaseSpinLockFromDpcLevel
	nop    DWORD PTR [rax+rax*1+0h]

J435:

	mov    rbx,QWORD PTR [rbp-10h]
	lea    rax,[rbp-10h]
	cmp    rbx,rax
	je     J49c
	lea    rax,[rbp-10h]
	cmp    QWORD PTR [rbx+8h],rax
	jne    J495
	mov    rax,QWORD PTR [rbx]
	cmp    QWORD PTR [rax+8h],rbx
	jne    J495
	lea    rcx,[rbp-10h]
	mov    QWORD PTR [rbp-10h],rax
	mov    QWORD PTR [rax+8h],rcx
	mov    dl,6h
	lea    rcx,[rbx-0a8h]
	call   QWORD PTR _IofCompleteRequest
	nop    DWORD PTR [rax+rax*1+0h]
	lea    rcx,[rdi+20h]
	mov    r8d,20h
	lea    rdx,[rbx-0a8h]
	call   QWORD PTR _IoReleaseRemoveLockEx
	nop    DWORD PTR [rax+rax*1+0h]
	jmp    J435

J495:

	mov    ecx,3h
	int    29h

J49C:

	cmp    WPP_RECORDER_INITIALIZED,r12
	jne    J4c7
	mov    rcx, QWORD PTR WPP_GLOBAL_Control
	cmp    WORD PTR [rcx+48h],si
	je     J4c7
	mov    rcx,QWORD PTR [rcx+40h]
	mov    r9d,3ch
	mov    dl,5h
	lea    r8d,[r9-39h]
	call   WPP_RECORDER_SFMeme

J4c7:

	lea    r11,[rsp+70h]
	mov    rbx,QWORD PTR [r11+30h]
	mov    rsi,QWORD PTR [r11+38h]
	mov    rdi,QWORD PTR [r11+40h]
	mov    rsp,r11
	pop    r15
	pop    r14
	pop    r13
	pop    r12
	pop    rbp
	ret
MouseClassServiceCallbackMeme endp

end


```

`mouse_operation.c`:

```c
// Copyright (c) 2026 渟雲. All rights reserved.
#include "./common.h"
MOUSE_OBJECT gMouseObject = {0};

inline BOOL MouseOpen(void) {
  // https://github.com/nbqofficial/norsefire
  // https://github.com/ekknod/MouseClassServiceCallbackMeme

  if (gMouseObject.use_mouse == 0) {
    UNICODE_STRING class_string = RTL_CONSTANT_STRING(L"\\Driver\\MouClass");
    UNICODE_STRING mouse_driver_names[] = {
        RTL_CONSTANT_STRING(L"\\Driver\\MouHID"),
        RTL_CONSTANT_STRING(L"\\Driver\\i8042prt")};

    PDRIVER_OBJECT class_driver_object = NULL;
    PDRIVER_OBJECT hid_driver_object = NULL;
    PDEVICE_OBJECT hid_device_object = NULL;
    PDEVICE_OBJECT class_device_object = NULL;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    size_t driver_idx = 0;

    status = ObReferenceObjectByName(&class_string, OBJ_CASE_INSENSITIVE, NULL,
                                     0, *IoDriverObjectType, KernelMode, NULL,
                                     (PVOID*)&class_driver_object);
    if (!NT_SUCCESS(status)) {
      gMouseObject.use_mouse = 0;
      return FALSE;
    }

    for (driver_idx = 0; driver_idx < ARRAYSIZE(mouse_driver_names);
         driver_idx++) {
      status = ObReferenceObjectByName(
          &mouse_driver_names[driver_idx], OBJ_CASE_INSENSITIVE, NULL, 0,
          *IoDriverObjectType, KernelMode, NULL, (PVOID*)&hid_driver_object);
      if (NT_SUCCESS(status)) {
        break;
      }
    }

    if (!NT_SUCCESS(status) || hid_driver_object == NULL) {
      ObfDereferenceObject(class_driver_object);
      gMouseObject.use_mouse = 0;
      return FALSE;
    }

    hid_device_object = hid_driver_object->DeviceObject;
    gMouseObject.service_callback = NULL;
    gMouseObject.mouse_device = NULL;

    while (hid_device_object && !gMouseObject.service_callback) {
      class_device_object = class_driver_object->DeviceObject;
      while (class_device_object && !gMouseObject.service_callback) {
        if (!gMouseObject.mouse_device && !class_device_object->NextDevice) {
          gMouseObject.mouse_device = class_device_object;
        }

        PULONG_PTR device_extension =
            (PULONG_PTR)hid_device_object->DeviceExtension;
        ULONG_PTR device_ext_size =
            ((ULONG_PTR)hid_device_object->DeviceObjectExtension -
             (ULONG_PTR)hid_device_object->DeviceExtension) /
            4;

        for (ULONG_PTR i = 0; i < device_ext_size; i++) {
          if (device_extension[i] == (ULONG_PTR)class_device_object &&
              device_extension[i + 1] > (ULONG_PTR)class_driver_object) {
            gMouseObject.service_callback =
                (MouseClassServiceCallbackFn)(device_extension[i + 1]);
            break;
          }
        }
        class_device_object = class_device_object->NextDevice;
      }
      hid_device_object = hid_device_object->AttachedDevice;
    }

    if (!gMouseObject.mouse_device) {
      PDEVICE_OBJECT target_device_object = class_driver_object->DeviceObject;
      while (target_device_object) {
        if (!target_device_object->NextDevice) {
          gMouseObject.mouse_device = target_device_object;
          break;
        }
        target_device_object = target_device_object->NextDevice;
      }
    }

    ObfDereferenceObject(class_driver_object);
    ObfDereferenceObject(hid_driver_object);

    gMouseObject.use_mouse =
        (gMouseObject.mouse_device && gMouseObject.service_callback) ? 1 : 0;
  }

  return (gMouseObject.mouse_device != NULL) &&
         (gMouseObject.service_callback != NULL);
}

inline void MouseCall(long x, long y, unsigned short button_flags,
                      unsigned short flags) {
  KIRQL irql;
  ULONG input_data;
  MOUSE_INPUT_DATA mid = {0};
  mid.LastX = x;
  mid.LastY = y;
  mid.ButtonFlags = button_flags;
  mid.Flags = flags;
  if (!MouseOpen()) {
    return;
  }
  mid.UnitId = 1;
  RAISE_IRQL(DISPATCH_LEVEL, &irql);
  MouseClassServiceCallbackMeme(gMouseObject.mouse_device, &mid,
                            (PMOUSE_INPUT_DATA)&mid + 1, &input_data);
  KeLowerIrql(irql);
}

VOID HandleMouseEvent(Requests* request) {
  if (!request) return;

  DWORD dwFlags = request->dwFlags;
  LONG dx = request->dx;
  LONG dy = request->dy;

  long x = 0, y = 0;
  unsigned short button_flags = 0;
  unsigned short flags = MOUSE_MOVE_RELATIVE;

  if (dwFlags & MOUSEEVENTF_MOVE) {
    x = dx;
    y = dy;

    if (dwFlags & MOUSEEVENTF_ABSOLUTE) {
      flags = MOUSE_MOVE_ABSOLUTE;

      if (dwFlags & MOUSEEVENTF_VIRTUALDESK) {
        flags |= MOUSE_VIRTUAL_DESKTOP;
      }

      x = max(0, min(65535, dx));
      y = max(0, min(65535, dy));
    }
  }

  if (dwFlags & MOUSEEVENTF_LEFTDOWN) button_flags |= 0x0001;
  if (dwFlags & MOUSEEVENTF_LEFTUP) button_flags |= 0x0002;
  if (dwFlags & MOUSEEVENTF_RIGHTDOWN) button_flags |= 0x0004;
  if (dwFlags & MOUSEEVENTF_RIGHTUP) button_flags |= 0x0008;
  if (dwFlags & MOUSEEVENTF_MIDDLEDOWN) button_flags |= 0x0010;
  if (dwFlags & MOUSEEVENTF_MIDDLEUP) button_flags |= 0x0020;
  if (dwFlags & MOUSEEVENTF_XDOWN) button_flags |= 0x0040;
  if (dwFlags & MOUSEEVENTF_XUP) button_flags |= 0x0080;

  MouseCall(x, y, button_flags, flags);

  request->return_value = TRUE;
}

```

`mouse_operation.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _MOUSE_OPERATION_H_
#define _MOUSE_OPERATION_H_

VOID MouseClassServiceCallbackMeme(PDEVICE_OBJECT DeviceObject,
                               PMOUSE_INPUT_DATA InputDataStart,
                               PMOUSE_INPUT_DATA InputDataEnd,
                               PULONG InputDataConsumed);

VOID HandleMouseEvent(Requests*);

#endif

```

`process.c`:

```c
// Copyright (c) 2026 渟雲. All rights reserved.
#include "./common.h"

NTSTATUS MmCopyProtectVirtualMemory(PEPROCESS fromProcess, PVOID fromAddress,
                                    PEPROCESS toProcess, PVOID toAddress,
                                    SIZE_T bufferSize,
                                    KPROCESSOR_MODE previousMode,
                                    PSIZE_T bytesCopied) {
  if (!fromProcess || !fromAddress || !toProcess || !toAddress ||
      !bytesCopied || bufferSize == 0) {
    return STATUS_INVALID_PARAMETER;
  }
  if (KeGetCurrentIrqlMeme() > PASSIVE_LEVEL) {
    return STATUS_INVALID_DEVICE_REQUEST;
  }

  NTSTATUS status = STATUS_SUCCESS;
  KAPC_STATE apcState = {0};
  ULONG oldProtect = 0;
  PVOID alignedAddress = NULL;
  SIZE_T alignedSize = 0;
  BOOLEAN protectionChanged = FALSE;
  BOOLEAN attached = FALSE;

  *bytesCopied = 0;

  if (PsGetProcessExitStatus(fromProcess) != STATUS_PENDING) {
    return STATUS_PROCESS_IS_TERMINATING;
  }

  if (PsGetProcessExitStatus(toProcess) != STATUS_PENDING) {
    return STATUS_PROCESS_IS_TERMINATING;
  }

  __try {
    ULONG_PTR start = (ULONG_PTR)toAddress;
    ULONG_PTR end = start + bufferSize;
    if (end < start) {
      status = STATUS_INVALID_PARAMETER;
      __leave;
    }

    KeStackAttachProcess(toProcess, &apcState);
    attached = TRUE;

    alignedAddress = (PVOID)(start & ~(PAGE_SIZE - 1));
    alignedSize =
        ((end + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1)) - (ULONG_PTR)alignedAddress;

    status = ZwProtectVirtualMemory(NtCurrentProcess(), &alignedAddress,
                                    &alignedSize, PAGE_READWRITE, &oldProtect);
    if (!NT_SUCCESS(status)) {
      __leave;
    }
    protectionChanged = TRUE;

    status = DriverCopyVirtualMemory(fromProcess, fromAddress, toProcess, toAddress,
                                 bufferSize, previousMode, bytesCopied);

  } __except (EXCEPTION_EXECUTE_HANDLER) {
    status = STATUS_ACCESS_VIOLATION;
  }

  if (protectionChanged) {
    ULONG tempProtect;
    ZwProtectVirtualMemory(NtCurrentProcess(), &alignedAddress, &alignedSize,
                           oldProtect, &tempProtect);
  }

  if (attached) {
    KeUnstackDetachProcess(&apcState);
  }

  return status;
}

BOOLEAN ReadVM(Requests* in) {
  if (KeGetCurrentIrqlMeme() > PASSIVE_LEVEL) {
    return FALSE;
  }

  PEPROCESS from_process = NULL;
  PEPROCESS to_process = NULL;
  if (in->request_pid == 0 || in->target_pid == 0) return FALSE;

  NTSTATUS status =
      PsLookupProcessByProcessId((HANDLE)in->request_pid, &to_process);
  if (!NT_SUCCESS(status)) {
    return FALSE;
  }

  status = PsLookupProcessByProcessId((HANDLE)in->target_pid, &from_process);
  if (!NT_SUCCESS(status)) {
    ObDereferenceObject(to_process);
    return FALSE;
  }

    if (PsGetProcessExitStatus(from_process) != STATUS_PENDING) {
    ObDereferenceObject(from_process);
    ObDereferenceObject(to_process);
    return FALSE;
  }

  SIZE_T memsize = 0;
  __try {
    status = DriverCopyVirtualMemory(from_process, (void*)in->target_addr,
                                 to_process, (void*)in->request_addr,
                                 in->mem_size, KernelMode, &memsize);
  } __except (EXCEPTION_EXECUTE_HANDLER) {
    status = STATUS_ACCESS_VIOLATION;
  }

  ObDereferenceObject(from_process);
  ObDereferenceObject(to_process);
  return NT_SUCCESS(status);
}

BOOLEAN WriteVM(Requests* in) {
  if (KeGetCurrentIrqlMeme() > PASSIVE_LEVEL) {
    return FALSE;
  }

  PEPROCESS from_process = NULL;
  PEPROCESS to_process = NULL;
  if (in->request_pid == 0 || in->target_pid == 0) return FALSE;

  NTSTATUS status =
      PsLookupProcessByProcessId((HANDLE)in->request_pid, &from_process);
  if (!NT_SUCCESS(status)) {
    return FALSE;
  }

  status = PsLookupProcessByProcessId((HANDLE)in->target_pid, &to_process);
  if (!NT_SUCCESS(status)) {
    ObDereferenceObject(from_process);
    return FALSE;
  }

  if (PsGetProcessExitStatus(to_process) != STATUS_PENDING) {
    ObDereferenceObject(from_process);
    ObDereferenceObject(to_process);
    return FALSE;
  }

  SIZE_T memsize = 0;
  __try {
    status = MmCopyProtectVirtualMemory(from_process, (void*)in->request_addr,
                                        to_process, (void*)in->target_addr,
                                        in->mem_size, KernelMode, &memsize);
  } __except (EXCEPTION_EXECUTE_HANDLER) {
    status = STATUS_ACCESS_VIOLATION;
  }

  ObDereferenceObject(from_process);
  ObDereferenceObject(to_process);
  return NT_SUCCESS(status);
}

UINT64 GetModuleBasex64(PEPROCESS proc, UNICODE_STRING module_name,
                        BOOL get_size) {
  if (!proc) return 0;
  if (KeGetCurrentIrqlMeme() > PASSIVE_LEVEL) {
    return 0;
  }

  PPEB pPeb = NULL;
  KAPC_STATE state;
  KeStackAttachProcess(proc, &state);

  UINT64 result = 0;
  __try {
    pPeb = (PPEB)PsGetProcessPeb(proc);
    if (!pPeb) {
      KeUnstackDetachProcess(&state);
      return 0;
    }

    PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)pPeb->Ldr;
    if (!pLdr) {
      KeUnstackDetachProcess(&state);
      return 0;
    }

    for (PLIST_ENTRY list = (PLIST_ENTRY)pLdr->InLoadOrderModuleList.Flink;
         list != &pLdr->InLoadOrderModuleList;
         list = (PLIST_ENTRY)list->Flink) {
      PLDR_DATA_TABLE_ENTRY pEntry =
          CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

      if (RtlCompareUnicodeString(&pEntry->BaseDllName, &module_name, TRUE) ==
          0) {
        result =
            get_size ? (UINT64)pEntry->SizeOfImage : (UINT64)pEntry->DllBase;
        break;
      }
    }
  } __except (EXCEPTION_EXECUTE_HANDLER) {
    result = 0;
  }

  KeUnstackDetachProcess(&state);
  return result;
}

UINT64 GetDllAddress(Requests* in) {
  if (in->target_pid == 0) return 0;
  if (KeGetCurrentIrqlMeme() > PASSIVE_LEVEL) {
    return 0;
  }

  PEPROCESS source_process = NULL;
  NTSTATUS status =
      PsLookupProcessByProcessId((HANDLE)in->target_pid, &source_process);
  if (!NT_SUCCESS(status)) return 0;

  if (PsGetProcessExitStatus(source_process) != STATUS_PENDING) {
    ObDereferenceObject(source_process);
    return 0;
  }

  char decoded[65];
  kmemset(decoded, 0, sizeof(decoded));
  DecodeFixedStr64(&in->name_str, decoded, in->name_length);
  PWSTR wStr = ConvertToPWSTR(decoded);
  if (!wStr) {
    ObDereferenceObject(source_process);
    return 0;
  }

  UNICODE_STRING moduleName;
  RtlInitUnicodeString(&moduleName, wStr);
  ULONG64 base_address = 0;

  __try {
    base_address = GetModuleBasex64(source_process, moduleName, FALSE);
  } __except (EXCEPTION_EXECUTE_HANDLER) {
    base_address = 0;
  }

  ExFreePoolWithTag(wStr, 'NtFs');
  ObDereferenceObject(source_process);
  return base_address;
}

UINT64 GetDllSize(Requests* in) {
  if (in->target_pid == 0) return 0;
  if (KeGetCurrentIrqlMeme() > PASSIVE_LEVEL) {
    return 0;
  }

  PEPROCESS source_process = NULL;
  NTSTATUS status =
      PsLookupProcessByProcessId((HANDLE)in->target_pid, &source_process);
  if (!NT_SUCCESS(status)) return 0;

  if (PsGetProcessExitStatus(source_process) != STATUS_PENDING) {
    ObDereferenceObject(source_process);
    return 0;
  }

  char decoded[65];
  kmemset(decoded, 0, sizeof(decoded));
  DecodeFixedStr64(&in->name_str, decoded, in->name_length);
  PWSTR wStr = ConvertToPWSTR(decoded);
  if (!wStr) {
    ObDereferenceObject(source_process);
    return 0;
  }

  UNICODE_STRING moduleName;
  RtlInitUnicodeString(&moduleName, wStr);
  ULONG64 module_size = 0;

  __try {
    module_size = GetModuleBasex64(source_process, moduleName, TRUE);
  } __except (EXCEPTION_EXECUTE_HANDLER) {
    module_size = 0;
  }

  ExFreePoolWithTag(wStr, 'NtFs');
  ObDereferenceObject(source_process);
  return module_size;
}

ULONG g_ActiveProcessLinksOffset = 0;

BOOLEAN InitOffsetsByVersion() {
  RTL_OSVERSIONINFOW ver = {0};
  ver.dwOSVersionInfoSize = sizeof(ver);
  if (!NT_SUCCESS(RtlGetVersion(&ver))) {
    return FALSE;
  }

  if (ver.dwMajorVersion == 10 && ver.dwMinorVersion == 0) {
    if (ver.dwBuildNumber >= 26000) {
      g_ActiveProcessLinksOffset = 0x1d8;
    } else {
      g_ActiveProcessLinksOffset = 0x448;
    }
    return TRUE;
  }
  return FALSE;
}

UINT64 GetProcessIdByName(Requests* in) {
  if (!in || in->name_length == 0 || in->name_length > 64) return 0;
  if (KeGetCurrentIrqlMeme() > PASSIVE_LEVEL) {
    return 0;
  }

  if (g_ActiveProcessLinksOffset == 0) {
    if (!InitOffsetsByVersion()) {
      return 0;
    }
  }

  char targetName[65];
  kmemset(targetName, 0, sizeof(targetName));
  DecodeFixedStr64(&in->name_str, targetName, in->name_length);

  PEPROCESS startProcess = NULL;
  if (!NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)4, &startProcess)))
    return 0;

  PEPROCESS currentProcess = startProcess;
  ObReferenceObject(currentProcess);
  UINT64 foundPid = 0;
  ULONG processCount = 0;

  while (currentProcess && processCount < 1000) {
    processCount++;
    HANDLE currentPid = PsGetProcessId(currentProcess);
    PCHAR imageName = NULL;

    __try {
      imageName = PsGetProcessImageFileName(currentProcess);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
      break;
    }

    if (imageName && imageName[0]) {
      if (kstricmp(targetName, imageName) == 0) {
        foundPid = (UINT64)currentPid;
        break;
      }
    }

    PLIST_ENTRY listEntry = NULL;
    __try {
      listEntry =
          (PLIST_ENTRY)((ULONG_PTR)currentProcess + g_ActiveProcessLinksOffset);
      if (!listEntry->Flink || listEntry->Flink == listEntry) break;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
      break;
    }

    ULONG_PTR nextAddr =
        (ULONG_PTR)listEntry->Flink - g_ActiveProcessLinksOffset;
    PEPROCESS nextProcess = (PEPROCESS)nextAddr;
    HANDLE nextPid = NULL;

    __try {
      nextPid = PsGetProcessId(nextProcess);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
      break;
    }

    PEPROCESS nextSafe = NULL;

    if (nextPid && NT_SUCCESS(PsLookupProcessByProcessId(nextPid, &nextSafe))) {
      if (nextSafe == startProcess) {
        ObDereferenceObject(nextSafe);
        break;
      }
      ObDereferenceObject(currentProcess);
      currentProcess = nextSafe;
    } else {
      break;
    }
  }

  if (currentProcess && currentProcess != startProcess)
    ObDereferenceObject(currentProcess);
  if (startProcess) ObDereferenceObject(startProcess);

  return foundPid;
}

```

`process.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _FUNCTIONS_H_
#define _FUNCTIONS_H_

BOOLEAN ReadVM(Requests*);

BOOLEAN WriteVM(Requests*);

UINT64 GetDllAddress(Requests*);

UINT64 GetDllSize(Requests*);

UINT64 GetProcessIdByName(Requests*);

#endif

```

`reimpl.c`:

```c
// Copyright (c) 2026 渟雲. All rights reserved.
#include "./common.h"

MDL_POOL g_MdlPool = {0};

__int64 _kascii_stricmp(const char* a1, const char* a2) {
  int v4;  // r8d
  int v5;  // edx
  int v6;  // r9d
  int v7;  // eax

  do {
    v4 = *a1++;
    v5 = *a2;
    v6 = v4 + 32;
    if ((unsigned int)(v4 - 65) > 0x19) v6 = v4;
    v7 = v5 + 32;
    ++a2;
    if ((unsigned int)(v5 - 65) > 0x19) v7 = v5;
  } while (v6 && v6 == v7);
  return (unsigned int)(v6 - v7);
}

int kstricmp(const char* Str1, const char* Str2) {
  return (int)_kascii_stricmp(Str1, Str2);
}

int kwcsicmp(const wchar_t* Str1, const wchar_t* Str2) {
  const wchar_t* v2;    // r10
  signed __int64 v3;    // r9
  unsigned __int16 v4;  // r8
  unsigned __int16 v5;  // cx
  unsigned __int16 v6;  // dx
  unsigned __int16 v7;  // r8

  v2 = Str2;
  v3 = (char*)Str1 - (char*)Str2;
  do {
    v4 = *(const wchar_t*)((char*)v2 + v3);
    v5 = *v2++;
    v6 = v4 + 32;
    if ((unsigned __int16)(v4 - 65) > 0x19u) v6 = v4;
    v7 = v5 + 32;
    if ((unsigned __int16)(v5 - 65) > 0x19u) v7 = v5;
  } while (v6 && v6 == v7);
  return v6 - v7;
}

NTSTATUS MdlPoolInitialize() {
  NTSTATUS status = STATUS_SUCCESS;

  KeInitializeSpinLock(&g_MdlPool.Lock);
  g_MdlPool.MaxSingleMdlSize = MDL_MAX_BUFFER_SIZE;

  for (INT i = 0; i < MDL_POOL_SIZE; i++) {
    g_MdlPool.Items[i].Mdl =
        IoAllocateMdl(NULL,
                      (ULONG)MDL_MAX_BUFFER_SIZE,
                      FALSE,
                      FALSE,
                      NULL
        );

    if (!g_MdlPool.Items[i].Mdl) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto Cleanup;
    }

    g_MdlPool.Items[i].IsAvailable = TRUE;
    g_MdlPool.Items[i].MaxBufferSize = MDL_MAX_BUFFER_SIZE;
  }

  return status;

Cleanup:
  for (INT i = 0; i < MDL_POOL_SIZE; i++) {
    if (g_MdlPool.Items[i].Mdl) {
      IoFreeMdl(g_MdlPool.Items[i].Mdl);
      g_MdlPool.Items[i].Mdl = NULL;
    }
    g_MdlPool.Items[i].IsAvailable = FALSE;
  }
  return status;
}

PMDL MdlPoolAcquire(SIZE_T BufferSize) {
  if (BufferSize == 0 || BufferSize > g_MdlPool.MaxSingleMdlSize)
    return NULL;

  KIRQL oldIrql = 0;
  PMDL mdl = NULL;

  KeAcquireSpinLock(&g_MdlPool.Lock, &oldIrql);

  for (INT i = 0; i < MDL_POOL_SIZE; i++) {
    if (g_MdlPool.Items[i].IsAvailable &&
        g_MdlPool.Items[i].MaxBufferSize >= BufferSize) {
      g_MdlPool.Items[i].IsAvailable = FALSE;
      mdl = g_MdlPool.Items[i].Mdl;
      break;
    }
  }

  KeReleaseSpinLock(&g_MdlPool.Lock, oldIrql);

  return mdl;
}

VOID MdlPoolRelease(PMDL Mdl) {
  if (!Mdl) return;

  KIRQL oldIrql = 0;

  KeAcquireSpinLock(&g_MdlPool.Lock, &oldIrql);

  for (INT i = 0; i < MDL_POOL_SIZE; i++) {
    if (g_MdlPool.Items[i].Mdl == Mdl) {
      Mdl->Next = NULL;
      Mdl->Size = MDL_HDR_SIZE + (CSHORT)g_MdlPool.Items[i].MaxBufferSize;
      Mdl->MdlFlags = 0;
      Mdl->StartVa = NULL;
      Mdl->ByteOffset = 0;
      Mdl->ByteCount = 0;

      g_MdlPool.Items[i].IsAvailable = TRUE;
      break;
    }
  }

  KeReleaseSpinLock(&g_MdlPool.Lock, oldIrql);
}

VOID MdlPoolDestroy() {
  for (INT i = 0; i < MDL_POOL_SIZE; i++) {
    if (g_MdlPool.Items[i].Mdl) {
      IoFreeMdl(g_MdlPool.Items[i].Mdl);
      g_MdlPool.Items[i].Mdl = NULL;
    }
    g_MdlPool.Items[i].IsAvailable = FALSE;
  }
}

NTSTATUS
MiDoMappedCopy(_In_ PEPROCESS SourceProcess, _In_ PVOID SourceAddress,
               _In_ PEPROCESS TargetProcess, _Out_ PVOID TargetAddress,
               _In_ SIZE_T BufferSize, _In_ KPROCESSOR_MODE PreviousMode,
               _Out_ PSIZE_T ReturnSize) {
  KAPC_STATE ApcState;
  NTSTATUS Status = STATUS_SUCCESS;
  PMDL SourceMdl = NULL;
  PMDL TargetMdl = NULL;
  PVOID SourceMappedAddr = NULL;
  PVOID TargetMappedAddr = NULL;
  BOOLEAN bSourceMdlFromPool = FALSE;
  BOOLEAN bTargetMdlFromPool = FALSE;

  if (ReturnSize != NULL) {
    *ReturnSize = 0;
  }

  if (SourceProcess == NULL || SourceAddress == NULL || TargetProcess == NULL ||
      TargetAddress == NULL || BufferSize == 0) {
    return STATUS_INVALID_PARAMETER;
  }

  SourceMdl = MdlPoolAcquire(BufferSize);
  if (SourceMdl) {
    bSourceMdlFromPool = TRUE;
    MmInitializeMdl(SourceMdl, SourceAddress, (ULONG)BufferSize);
  } else {
    KeStackAttachProcess((PRKPROCESS)SourceProcess, &ApcState);
    SourceMdl =
        IoAllocateMdl(SourceAddress, (ULONG)BufferSize, FALSE, FALSE, NULL);
    KeUnstackDetachProcess(&ApcState);

    if (SourceMdl == NULL) {
      Status = STATUS_INSUFFICIENT_RESOURCES;
      goto Exit;
    }
  }

  KeStackAttachProcess((PRKPROCESS)SourceProcess, &ApcState);
  __try {
    MmProbeAndLockPages(SourceMdl, PreviousMode, IoReadAccess);
  } __except (EXCEPTION_EXECUTE_HANDLER) {
    Status = GetExceptionCode();
    if (bSourceMdlFromPool)
      MdlPoolRelease(SourceMdl);
    else
      IoFreeMdl(SourceMdl);
    SourceMdl = NULL;
    KeUnstackDetachProcess(&ApcState);
    goto Exit;
  }
  KeUnstackDetachProcess(&ApcState);

  SourceMappedAddr = MmMapLockedPagesSpecifyCache(
      SourceMdl, PreviousMode, MmNonCached, NULL, FALSE, NormalPagePriority);
  if (SourceMappedAddr == NULL) {
    Status = STATUS_INSUFFICIENT_RESOURCES;
    goto Exit;
  }

  TargetMdl = MdlPoolAcquire(BufferSize);
  if (TargetMdl) {
    bTargetMdlFromPool = TRUE;
    MmInitializeMdl(TargetMdl, TargetAddress, (ULONG)BufferSize);
  } else {
    KeStackAttachProcess((PRKPROCESS)TargetProcess, &ApcState);
    TargetMdl =
        IoAllocateMdl(TargetAddress, (ULONG)BufferSize, FALSE, FALSE, NULL);
    KeUnstackDetachProcess(&ApcState);

    if (TargetMdl == NULL) {
      Status = STATUS_INSUFFICIENT_RESOURCES;
      goto Exit;
    }
  }

  KeStackAttachProcess((PRKPROCESS)TargetProcess, &ApcState);
  __try {
    MmProbeAndLockPages(TargetMdl, PreviousMode, IoWriteAccess);
  } __except (EXCEPTION_EXECUTE_HANDLER) {
    Status = GetExceptionCode();
    if (bTargetMdlFromPool)
      MdlPoolRelease(TargetMdl);
    else
      IoFreeMdl(TargetMdl);
    TargetMdl = NULL;
    KeUnstackDetachProcess(&ApcState);
    goto Exit;
  }
  KeUnstackDetachProcess(&ApcState);

  TargetMappedAddr = MmMapLockedPagesSpecifyCache(
      TargetMdl, PreviousMode, MmNonCached, NULL, FALSE, NormalPagePriority);
  if (TargetMappedAddr == NULL) {
    Status = STATUS_INSUFFICIENT_RESOURCES;
    goto Exit;
  }

  kmemmove(TargetMappedAddr, SourceMappedAddr, BufferSize);

  if (ReturnSize != NULL) {
    *ReturnSize = BufferSize;
  }

Exit:
  if (TargetMappedAddr != NULL) {
    MmUnmapLockedPages(TargetMappedAddr, TargetMdl);
    TargetMappedAddr = NULL;
  }
  if (TargetMdl != NULL) {
    MmUnlockPages(TargetMdl);
    if (bTargetMdlFromPool)
      MdlPoolRelease(TargetMdl);
    else
      IoFreeMdl(TargetMdl);
    TargetMdl = NULL;
  }
  if (SourceMappedAddr != NULL) {
    MmUnmapLockedPages(SourceMappedAddr, SourceMdl);
    SourceMappedAddr = NULL;
  }
  if (SourceMdl != NULL) {
    MmUnlockPages(SourceMdl);
    if (bSourceMdlFromPool)
      MdlPoolRelease(SourceMdl);
    else
      IoFreeMdl(SourceMdl);
    SourceMdl = NULL;
  }

  return Status;
}

NTSTATUS
DriverCopyVirtualMemory(IN PEPROCESS SourceProcess, IN PVOID SourceAddress,
                        IN PEPROCESS TargetProcess, OUT PVOID TargetAddress,
                        IN SIZE_T BufferSize, IN KPROCESSOR_MODE PreviousMode,
                        OUT PSIZE_T ReturnSize) {
  NTSTATUS Status;

  if (SourceProcess == NULL || TargetProcess == NULL || SourceAddress == NULL ||
      TargetAddress == NULL) {
    if (ReturnSize != NULL) {
      *ReturnSize = 0;
    }
    return STATUS_INVALID_PARAMETER;
  }

  if (BufferSize == 0) {
    if (ReturnSize) *ReturnSize = 0;
    return STATUS_SUCCESS;
  }

  Status = MiDoMappedCopy(SourceProcess, SourceAddress, TargetProcess,
                          TargetAddress, BufferSize, PreviousMode, ReturnSize);

  return Status;
}

```

`reimpl.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _REIMPL_H_
#define _REIMPL_H_

extern MDL_POOL g_MdlPool;

int __cdecl kstricmp(const char* Str1, const char* Str2);

int __cdecl kwcsicmp(const wchar_t* Str1, const wchar_t* Str2);

void* __cdecl kmemmove(void*, const void*, size_t);

void* __cdecl kmemset(void*, int, size_t);

NTSTATUS MdlPoolInitialize();
VOID MdlPoolRelease(PMDL);
PMDL MdlPoolAcquire(SIZE_T);
VOID MdlPoolDestroy();

NTSTATUS
DriverCopyVirtualMemory(IN PEPROCESS SourceProcess, IN PVOID SourceAddress,
                        IN PEPROCESS TargetProcess, OUT PVOID TargetAddress,
                        IN SIZE_T BufferSize, IN KPROCESSOR_MODE PreviousMode,
                        OUT PSIZE_T ReturnSize);

KIRQL KeGetCurrentIrqlMeme(void);

PIMAGE_NT_HEADERS RtlImageNtHeaderMeme(PVOID Base);

SIZE_T RtlCompareMemoryMeme(const void*, const void*, SIZE_T);

#endif

```

`request_handler.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _REQUEST_HANDLER_H_
#define _REQUEST_HANDLER_H_

BOOLEAN RequestHandler(Requests*);

#endif

```

`requst_handler.c`:

```c
// Copyright (c) 2026 渟雲. All rights reserved.
#include "./common.h"
#define CHECKSUM_ALGORITHM BCRYPT_SHA256_ALGORITHM
#define CHECKSUM_SIZE 32

// 0xBEEFDEADFEEDCAFE
const UCHAR PUBLIC_KEY[CHECKSUM_SIZE] = {
    0x29, 0x51, 0x35, 0x8E, 0x6F, 0x85, 0xA5, 0xDA, 0xE0, 0x8E, 0x60,
    0x3E, 0x94, 0x6E, 0xE9, 0xBD, 0x49, 0xA1, 0x67, 0xE1, 0x02, 0xA3,
    0xA0, 0x61, 0x4E, 0x55, 0x24, 0x5C, 0x0A, 0x16, 0xD6, 0xD0
};

BOOLEAN VerifySecureKey(UINT64 SecureKey) {
  BCRYPT_ALG_HANDLE hAlg = NULL;
  BCRYPT_HASH_HANDLE hHash = NULL;
  UCHAR localChecksum[CHECKSUM_SIZE];
  kmemset(localChecksum, 0, sizeof(localChecksum));
  NTSTATUS status = STATUS_SUCCESS;
  BOOLEAN bPass = FALSE;

  status = BCryptOpenAlgorithmProvider(&hAlg, CHECKSUM_ALGORITHM, NULL, 0);
  if (NT_SUCCESS(status))
    status = BCryptCreateHash(hAlg, &hHash, NULL, 0, NULL, 0, 0);

  if (NT_SUCCESS(status))
    status = BCryptHashData(hHash, (PBYTE)&SecureKey, sizeof(UINT64), 0);
  if (NT_SUCCESS(status))
    status = BCryptFinishHash(hHash, localChecksum, CHECKSUM_SIZE, 0);

  if (NT_SUCCESS(status)) {
    bPass = (RtlCompareMemoryMeme(localChecksum, PUBLIC_KEY,
                              CHECKSUM_SIZE) == CHECKSUM_SIZE);
  }

  if (hHash) BCryptDestroyHash(hHash);
  if (hAlg) BCryptCloseAlgorithmProvider(hAlg, 0);

  return bPass;
}

BOOLEAN RequestHandler(Requests* pstruct) {
  if (!pstruct) {
    return FALSE;
  }
  if (!IsTimestampValid(pstruct->time_stamp, 1)) {  // +-1s
    return FALSE;
  }
  if (pstruct->check_sum != CalculateRequestsChecksum(pstruct)) {
    return FALSE;
  }
  if (!VerifySecureKey(pstruct->secure_key)) {
    return FALSE;
  }
  switch (pstruct->request_key) {
    case USUGUMO_PROBE: {
      pstruct->return_value = TRUE;
      break;
    }
    case USUGUMO_READ: {
      pstruct->return_value = ReadVM(pstruct);
      break;
    }
    case USUGUMO_WRITE: {
      pstruct->return_value = WriteVM(pstruct);
      break;
    }
    case USUGUMO_MOUSE: {
      HandleMouseEvent(pstruct);
      pstruct->return_value = TRUE;
      break;
    }
    case USUGUMO_KEYBD: {
      HandleKeybdEvent(pstruct);
      pstruct->return_value = TRUE;
      break;
    }
    case USUGUMO_MODULE_BASE: {
      pstruct->return_value = GetDllAddress(pstruct);
      break;
    }
    case USUGUMO_MODULE_SIZE: {
      pstruct->return_value = GetDllSize(pstruct);
      break;
    }
    case USUGUMO_PID: {
      pstruct->return_value = GetProcessIdByName(pstruct);
      break;
    }
    case USUGUMO_ANTI_CAPTURE: {
      pstruct->return_value = HandleAntiCapture(pstruct);
      break;
    }
    default: {
      pstruct->return_value = FALSE;
      break;
    }
  }

  return TRUE;
}

```

`rtl_reimpl.asm`:

```asm
; Copyright (c) 2026 渟雲. All rights reserved.
.code

RtlImageNtHeaderMeme proc
xor     r8d, r8d
lea     rax, [rcx-1]
cmp     rax, 0FFFFFFFFFFFFFFFDh
ja      short loc_14043D71B
mov     eax, 5A4Dh
cmp     [rcx], ax
jnz     short loc_14043D71B
mov     eax, [rcx+3Ch]
add     rax, rcx
cmp     rax, rcx
jb      short loc_14043D71B
mov     rdx, 7FFFFFFEFFFFh
cmp     rcx, rdx
jbe     short loc_14043D720

loc_14043D711:
cmp     dword ptr [rax], 4550h
cmovz   r8, rax

loc_14043D71B:
mov     rax, r8
ret
align 10h

loc_14043D720:
lea     rcx, [rax+107h]
cmp     rcx, rax
jb      short loc_14043D71B
cmp     rcx, rdx
jbe     short loc_14043D711
jmp     short loc_14043D71B
RtlImageNtHeaderMeme endp

RtlCompareMemoryMeme proc
push    rsi
push    rdi
push    rbx
push    rbp
mov     rsi, rcx
mov     rdi, rdx
mov     rbx, r8
xor     edx, ecx
and     edx, 7
jnz     short loc_1406AADB2
cmp     rbx, 8
jb      short loc_1406AADB2
mov     r9, rdi
neg     ecx
and     ecx, 7
jz      short loc_1406AAD76
sub     rbx, rcx
repe cmpsb
jnz     short loc_1406AADA6

loc_1406AAD76:
mov     rcx, rbx
and     rcx, 0FFFFFFFFFFFFFFF8h
jz      short loc_1406AAD9A
sub     rbx, rcx
shr     rcx, 3
repe cmpsq
jz      short loc_1406AAD9A
inc     rcx
sub     rsi, 8
sub     rdi, 8
shl     rcx, 3

loc_1406AAD9A:
add     rbx, rcx
jz      short loc_1406AADA9
mov     rcx, rbx
repe cmpsb
jz      short loc_1406AADA9

loc_1406AADA6:
dec     rdi

loc_1406AADA9:
sub     rdi, r9
mov     rax, rdi
pop     rbp
pop     rbx
pop     rdi
pop     rsi
ret

loc_1406AADB2:
test    rbx, rbx
jz      short loc_1406AADC4
mov     rcx, rbx
repe cmpsb
jz      short loc_1406AADC4
inc     rcx
sub     rbx, rcx

loc_1406AADC4:
mov     rax, rbx
pop     rbp
pop     rbx
pop     rdi
pop     rsi
ret
RtlCompareMemoryMeme endp

END

```

`usugumo_request_define.h`:

```h
// Copyright (c) 2026 渟雲. All rights reserved.
#pragma once
#ifndef _USUGUMO_REQUEST_DEFINE_H_
#define _USUGUMO_REQUEST_DEFINE_H_
#ifdef __cplusplus
extern "C" {
#endif
#ifndef CTL_CODE
#include <winioctl.h>
#endif  // !CTL_CODE

#define USUGUMO_PROBE 0x0CAFEFEED
#define USUGUMO_READ 0x1CAFEFEED
#define USUGUMO_WRITE 0x2CAFEFEED
#define USUGUMO_MOUSE 0x3CAFEFEED
#define USUGUMO_KEYBD 0x4CAFEFEED
#define USUGUMO_MODULE_BASE 0x5CAFEFEED
#define USUGUMO_MODULE_SIZE 0x6CAFEFEED
#define USUGUMO_PID 0x7CAFEFEED
#define USUGUMO_ANTI_CAPTURE 0x8CAFEFEED

static const unsigned long kIoctlCallDriver =
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x721, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);

#ifdef _KERNEL_MODE
#include <ntddk.h>
#include <wdm.h>
#else
#include <windows.h>
#endif

#define TICKS_PER_SECOND 10000000LL  // 100NS

__forceinline unsigned __int64 GetTimestamp(void) {
#ifdef _KERNEL_MODE
  LARGE_INTEGER time;
  KeQuerySystemTime(&time);
  return time.QuadPart;
#else
  FILETIME ft;
  GetSystemTimeAsFileTime(&ft);
  return ((LONGLONG)ft.dwHighDateTime << 32) | ft.dwLowDateTime;
#endif
}

__forceinline BOOLEAN IsTimestampValid(unsigned __int64 ts,
                                       LONGLONG tolerance_seconds) {
  unsigned __int64 current = GetTimestamp();
  unsigned __int64 tolerance_ticks = tolerance_seconds * TICKS_PER_SECOND;

  if (ts > current) {
    return (ts - current) <= tolerance_ticks;
  } else {
    return (current - ts) <= tolerance_ticks;
  }
}

#pragma pack(push, 1)
typedef struct _FixedStr64 {
  unsigned __int64 blocks[8];
} FixedStr64;
#pragma pack(pop)
#pragma pack(push, 1)
typedef struct _Requests {
  // function requests
  unsigned __int64 request_key;

  // return value
  unsigned __int64 return_value;

  // memory read/write
  unsigned __int64 request_pid;
  unsigned __int64 request_addr;
  unsigned __int64 target_pid;
  unsigned __int64 target_addr;
  unsigned __int64 mem_size;

  // mouse_event
  unsigned long dwFlags;
  unsigned long dx;
  unsigned long dy;
  unsigned long dwData;
  unsigned __int64 dwExtraInfo;

  // keybd_event
  unsigned short bVK;
  unsigned short bScan;

  // base/pid request
  unsigned __int64 name_length;
  FixedStr64 name_str;

  // anti capture
  HWND window_handle;
  unsigned int protect_flags;

  unsigned __int64 time_stamp;
  unsigned __int64 secure_key;
  unsigned __int64 check_sum;
} Requests, *PRequests;
#pragma pack(pop)

#ifdef __cplusplus
}  // extern "C"
#endif
#endif

```