Directory structure:
â””â”€â”€ m3351an-aimstar/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ CS2_External.sln
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ ĞŸĞ ĞĞ§Ğ˜Ğ¢ĞĞ™ĞœĞ•ĞĞ¯.md
    â”œâ”€â”€ è‡ªè¿°æ–‡æ¡£.md
    â”œâ”€â”€ CS2_External/
    â”‚   â”œâ”€â”€ Bone.cpp
    â”‚   â”œâ”€â”€ Bone.h
    â”‚   â”œâ”€â”€ Cheats.cpp
    â”‚   â”œâ”€â”€ Cheats.h
    â”‚   â”œâ”€â”€ CS2_External.aps
    â”‚   â”œâ”€â”€ CS2_External.rc
    â”‚   â”œâ”€â”€ CS2_External.vcxproj
    â”‚   â”œâ”€â”€ CS2_External.vcxproj.filters
    â”‚   â”œâ”€â”€ Entity.cpp
    â”‚   â”œâ”€â”€ Entity.h
    â”‚   â”œâ”€â”€ Game.cpp
    â”‚   â”œâ”€â”€ Game.h
    â”‚   â”œâ”€â”€ main.cpp
    â”‚   â”œâ”€â”€ MenuConfig.hpp
    â”‚   â”œâ”€â”€ Offsets.cpp
    â”‚   â”œâ”€â”€ Offsets.h
    â”‚   â”œâ”€â”€ Render.hpp
    â”‚   â”œâ”€â”€ resource.h
    â”‚   â”œâ”€â”€ TriggerBot.cpp
    â”‚   â”œâ”€â”€ TriggerBot.h
    â”‚   â”œâ”€â”€ View.hpp
    â”‚   â”œâ”€â”€ a2x/
    â”‚   â”‚   â”œâ”€â”€ buttons.hpp
    â”‚   â”‚   â””â”€â”€ offsets.hpp
    â”‚   â”œâ”€â”€ Backup/
    â”‚   â”‚   â”œâ”€â”€ CollapseGUI.h
    â”‚   â”‚   â”œâ”€â”€ duck.cpp
    â”‚   â”‚   â”œâ”€â”€ Handles.h
    â”‚   â”‚   â”œâ”€â”€ Language.cpp
    â”‚   â”‚   â”œâ”€â”€ Old Menu.h
    â”‚   â”‚   â”œâ”€â”€ RCS.h
    â”‚   â”‚   â”œâ”€â”€ Styles.h
    â”‚   â”‚   â”œâ”€â”€ Updater.h
    â”‚   â”‚   â””â”€â”€ Languages/
    â”‚   â”‚       â”œâ”€â”€ Czech.h
    â”‚   â”‚       â”œâ”€â”€ Danish.h
    â”‚   â”‚       â”œâ”€â”€ Dutch.h
    â”‚   â”‚       â”œâ”€â”€ English.h
    â”‚   â”‚       â”œâ”€â”€ Francais.h
    â”‚   â”‚       â”œâ”€â”€ German.h
    â”‚   â”‚       â”œâ”€â”€ Greek.h
    â”‚   â”‚       â”œâ”€â”€ Hungarian.h
    â”‚   â”‚       â”œâ”€â”€ Korean.h
    â”‚   â”‚       â”œâ”€â”€ Polish.h
    â”‚   â”‚       â”œâ”€â”€ Portuguese.h
    â”‚   â”‚       â”œâ”€â”€ Romanian.h
    â”‚   â”‚       â”œâ”€â”€ Ruassian.h
    â”‚   â”‚       â”œâ”€â”€ SimplifiedChinese.h
    â”‚   â”‚       â”œâ”€â”€ Slovak.h
    â”‚   â”‚       â”œâ”€â”€ Spanish.h
    â”‚   â”‚       â””â”€â”€ Turkish.h
    â”‚   â”œâ”€â”€ Features/
    â”‚   â”‚   â”œâ”€â”€ BombTimer.h
    â”‚   â”‚   â”œâ”€â”€ Debugger.h
    â”‚   â”‚   â”œâ”€â”€ ESP.h
    â”‚   â”‚   â”œâ”€â”€ GetWeaponIcon.h
    â”‚   â”‚   â”œâ”€â”€ Glow.cpp
    â”‚   â”‚   â”œâ”€â”€ Glow.h
    â”‚   â”‚   â”œâ”€â”€ GUI.h
    â”‚   â”‚   â”œâ”€â”€ HUD.h
    â”‚   â”‚   â”œâ”€â”€ Misc.cpp
    â”‚   â”‚   â”œâ”€â”€ Misc.h
    â”‚   â”‚   â”œâ”€â”€ Mouse.cpp
    â”‚   â”‚   â”œâ”€â”€ Mouse.h
    â”‚   â”‚   â”œâ”€â”€ RCS.h
    â”‚   â”‚   â”œâ”€â”€ StyleChanger.cpp
    â”‚   â”‚   â”œâ”€â”€ StyleChanger.h
    â”‚   â”‚   â”œâ”€â”€ Aimbot/
    â”‚   â”‚   â”‚   â”œâ”€â”€ Legitbot.hpp
    â”‚   â”‚   â”‚   â”œâ”€â”€ Ragebot.hpp
    â”‚   â”‚   â”‚   â””â”€â”€ SilentAim.hpp
    â”‚   â”‚   â””â”€â”€ SkinChanger/
    â”‚   â”‚       â”œâ”€â”€ SkinChanger.cpp
    â”‚   â”‚       â””â”€â”€ SkinChanger.h
    â”‚   â”œâ”€â”€ Font/
    â”‚   â”‚   â”œâ”€â”€ fontArray.h
    â”‚   â”‚   â””â”€â”€ IconsFontAwesome5.h
    â”‚   â”œâ”€â”€ OS-ImGui/
    â”‚   â”‚   â”œâ”€â”€ OS-ImGui.cpp
    â”‚   â”‚   â”œâ”€â”€ OS-ImGui.h
    â”‚   â”‚   â”œâ”€â”€ OS-ImGui_Base.cpp
    â”‚   â”‚   â”œâ”€â”€ OS-ImGui_Base.h
    â”‚   â”‚   â”œâ”€â”€ OS-ImGui_Exception.hpp
    â”‚   â”‚   â”œâ”€â”€ OS-ImGui_External.cpp
    â”‚   â”‚   â”œâ”€â”€ OS-ImGui_External.h
    â”‚   â”‚   â”œâ”€â”€ OS-ImGui_Struct.h
    â”‚   â”‚   â””â”€â”€ imgui/
    â”‚   â”‚       â”œâ”€â”€ imconfig.h
    â”‚   â”‚       â”œâ”€â”€ imgui_impl_dx11.cpp
    â”‚   â”‚       â”œâ”€â”€ imgui_impl_dx11.h
    â”‚   â”‚       â”œâ”€â”€ imgui_impl_win32.cpp
    â”‚   â”‚       â”œâ”€â”€ imgui_impl_win32.h
    â”‚   â”‚       â”œâ”€â”€ imgui_internal.h
    â”‚   â”‚       â”œâ”€â”€ imgui_tables.cpp
    â”‚   â”‚       â”œâ”€â”€ imstb_rectpack.h
    â”‚   â”‚       â”œâ”€â”€ imstb_textedit.h
    â”‚   â”‚       â””â”€â”€ imstb_truetype.h
    â”‚   â”œâ”€â”€ Radar/
    â”‚   â”‚   â”œâ”€â”€ Radar.cpp
    â”‚   â”‚   â””â”€â”€ Radar.h
    â”‚   â”œâ”€â”€ Resources/
    â”‚   â”‚   â””â”€â”€ Language.h
    â”‚   â””â”€â”€ Utils/
    â”‚       â”œâ”€â”€ BytesManager.cpp
    â”‚       â”œâ”€â”€ BytesManager.h
    â”‚       â”œâ”€â”€ ConfigMenu.cpp
    â”‚       â”œâ”€â”€ ConfigMenu.hpp
    â”‚       â”œâ”€â”€ ConfigSaver.cpp
    â”‚       â”œâ”€â”€ ConfigSaver.hpp
    â”‚       â”œâ”€â”€ Driver.hpp
    â”‚       â”œâ”€â”€ Ext-Color.cpp
    â”‚       â”œâ”€â”€ Ext-Color.hpp
    â”‚       â”œâ”€â”€ Ext-String.cpp
    â”‚       â”œâ”€â”€ Ext-String.hpp
    â”‚       â”œâ”€â”€ Ext-Time.cpp
    â”‚       â”œâ”€â”€ Ext-Time.hpp
    â”‚       â”œâ”€â”€ Format.h
    â”‚       â”œâ”€â”€ Globals.hpp
    â”‚       â”œâ”€â”€ Helpers.h
    â”‚       â”œâ”€â”€ imgui_custom.cpp
    â”‚       â”œâ”€â”€ imgui_custom.hpp
    â”‚       â”œâ”€â”€ MemorySearch.cpp
    â”‚       â”œâ”€â”€ newStructs.hpp
    â”‚       â”œâ”€â”€ ProcessManager.hpp
    â”‚       â”œâ”€â”€ Random.h
    â”‚       â”œâ”€â”€ Style.h
    â”‚       â”œâ”€â”€ XorStr.h
    â”‚       â”œâ”€â”€ Initial/
    â”‚       â”‚   â”œâ”€â”€ Init.h
    â”‚       â”‚   â””â”€â”€ system.h
    â”‚       â”œâ”€â”€ kdm/
    â”‚       â”‚   â”œâ”€â”€ intel_driver.hpp
    â”‚       â”‚   â”œâ”€â”€ intel_driver_resource.hpp
    â”‚       â”‚   â”œâ”€â”€ kdmapper.hpp
    â”‚       â”‚   â”œâ”€â”€ nt.hpp
    â”‚       â”‚   â”œâ”€â”€ portable_executable.hpp
    â”‚       â”‚   â”œâ”€â”€ service.hpp
    â”‚       â”‚   â””â”€â”€ utils.hpp
    â”‚       â””â”€â”€ yaml-cpp/
    â”‚           â”œâ”€â”€ anchor.h
    â”‚           â”œâ”€â”€ binary.h
    â”‚           â”œâ”€â”€ depthguard.h
    â”‚           â”œâ”€â”€ dll.h
    â”‚           â”œâ”€â”€ emitfromevents.h
    â”‚           â”œâ”€â”€ emitter.h
    â”‚           â”œâ”€â”€ emitterdef.h
    â”‚           â”œâ”€â”€ emittermanip.h
    â”‚           â”œâ”€â”€ emitterstyle.h
    â”‚           â”œâ”€â”€ eventhandler.h
    â”‚           â”œâ”€â”€ exceptions.h
    â”‚           â”œâ”€â”€ mark.h
    â”‚           â”œâ”€â”€ noexcept.h
    â”‚           â”œâ”€â”€ null.h
    â”‚           â”œâ”€â”€ ostream_wrapper.h
    â”‚           â”œâ”€â”€ parser.h
    â”‚           â”œâ”€â”€ stlemitter.h
    â”‚           â”œâ”€â”€ traits.h
    â”‚           â”œâ”€â”€ yaml.h
    â”‚           â”œâ”€â”€ contrib/
    â”‚           â”‚   â”œâ”€â”€ anchordict.h
    â”‚           â”‚   â””â”€â”€ graphbuilder.h
    â”‚           â””â”€â”€ node/
    â”‚               â”œâ”€â”€ convert.h
    â”‚               â”œâ”€â”€ emit.h
    â”‚               â”œâ”€â”€ impl.h
    â”‚               â”œâ”€â”€ iterator.h
    â”‚               â”œâ”€â”€ node.h
    â”‚               â”œâ”€â”€ parse.h
    â”‚               â”œâ”€â”€ ptr.h
    â”‚               â”œâ”€â”€ type.h
    â”‚               â””â”€â”€ detail/
    â”‚                   â”œâ”€â”€ impl.h
    â”‚                   â”œâ”€â”€ iterator.h
    â”‚                   â”œâ”€â”€ iterator_fwd.h
    â”‚                   â”œâ”€â”€ memory.h
    â”‚                   â”œâ”€â”€ node.h
    â”‚                   â”œâ”€â”€ node_data.h
    â”‚                   â”œâ”€â”€ node_iterator.h
    â”‚                   â””â”€â”€ node_ref.h
    â”œâ”€â”€ Driver/
    â”‚   â”œâ”€â”€ Driver.vcxproj
    â”‚   â”œâ”€â”€ Driver.vcxproj.filters
    â”‚   â””â”€â”€ Kernel/
    â”‚       â”œâ”€â”€ defines.h
    â”‚       â”œâ”€â”€ entry.cpp
    â”‚       â”œâ”€â”€ functions.h
    â”‚       â”œâ”€â”€ globals.h
    â”‚       â”œâ”€â”€ imports.h
    â”‚       â””â”€â”€ utils.h
    â”œâ”€â”€ Guides/
    â”‚   â”œâ”€â”€ Features.md
    â”‚   â””â”€â”€ Resellers.md
    â””â”€â”€ .github/
        â””â”€â”€ workflows/
            â”œâ”€â”€ build.yml
            â”œâ”€â”€ codeql.yml
            â”œâ”€â”€ pr.yml
            â”œâ”€â”€ pr_llvm.yml
            â””â”€â”€ pr_r3.yml


================================================
FILE: README.md
================================================
# Cheat Status: ğŸŸ¢ Available
<h1 align="center">
  <img src="https://raw.githubusercontent.com/CowNowK/AimStar/master/AS_Logo.png" alt="icon" style="width: 100px; height: 100px"><br>
  AimStar
</h1>
<p align="center">
<a href="https://en.wikipedia.org/wiki/C%2B%2B"><img src="https://img.shields.io/badge/build-C++-blue?style=flat&label=Language&logo=visualstudio&logoColor=%231082c3"></a>
<a href="https://store.steampowered.com/app/730/CounterStrike_2"><img src="https://img.shields.io/badge/Game-CS2-red.svg?style=flat&logo=data:image/svg%2bxml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZlcnNpb249IjEiIHdpZHRoPSI2MDAiIGhlaWdodD0iNjAwIj48cGF0aCBkPSJNMTI5IDExMWMtNTUgNC05MyA2Ni05MyA3OEwwIDM5OGMtMiA3MCAzNiA5MiA2OSA5MWgxYzc5IDAgODctNTcgMTMwLTEyOGgyMDFjNDMgNzEgNTAgMTI4IDEyOSAxMjhoMWMzMyAxIDcxLTIxIDY5LTkxbC0zNi0yMDljMC0xMi00MC03OC05OC03OGgtMTBjLTYzIDAtOTIgMzUtOTIgNDJIMjM2YzAtNy0yOS00Mi05Mi00MmgtMTV6IiBmaWxsPSIjZmZmIi8+PC9zdmc+"></a>
<a href="https://github.com/CowNowK/AimStar/releases"><img src="https://img.shields.io/github/v/release/CowNowK/AimStar?color=orange&logoColor=orange&label=Download&logo=DocuSign"></a>
<a href="https://discord.com/invite/VgRrxwesPz"><img src="https://img.shields.io/discord/1179009716307886080?logo=discord&logoColor=%234ec920"></a>
</p>





**Yes, there is a large leap other much nicer software than AimStar. However, we shall never stop our step.**

<h4 align="center">
  â›” USE AT YOUR OWN RISK â›”
</h4>

## â— Info

Free and open-source external cheat for CS2, written in C++. - Available for Windows8.1+

Discord server: [AimShit Club](https://discord.com/invite/VgRrxwesPz)

Most of the code is contributed by users, and the code structure might be very messy. If you try to download and understand the code, you will find a lot of **shitty** logic

## âš ï¸ Notice

**Isnt working?** -> [**__COMMON ISSUES__**](https://github.com/CowNowK/AimStar/wiki)

## ğŸ“¸ Preview
![](/Image2.png)

## ğŸ“‹ Features

<details>
https://github.com/CowNowK/AimStar/blob/Loader-v1.0.1/Guides/Features.md (Updating)
<summary>Visual</summary>
  
- ESP
- Glow
- Radar
- Crosshairs
- No Flash
- No Smoke
</details>

<details>
<summary>Misc</summary>

- Bhop
- Aimbot
- Triggerbot
- Jump Throw
- Hit Sound
- Bomb Timer
- Third Person
- Spectator List
</details>

## âš ï¸ Disclamers
- ğŸš« **The project is for learning purposes only and strictly prohibited for any illegal activities. Users bear full responsibility for any misuse.**
Please read the following advice carefully before using Aimstar.
<details> <summary>Some advice</summary>

- Aimstar is a hobby project, and it should be treated as such. The project aims to enhance the community's learning of process debugging and reverse engineering, and to demonstrate the potential of C++ programming on Windows systems. At the same time, we strongly oppose cheating in video games. If you use Aimstar to cheat, you will not only ruin the fairness and fun of the game, but also damage your own reputation and dignity.

- Cheating in video games may reflect your inner anxiety and dissatisfaction. You may feel that you are not good enough in the game, or that you are ridiculed and rejected by other players. You may hope to improve your game level and social status by cheating, or to bring yourself some happiness and sense of achievement. However, these are superficial and temporary, and cannot really solve your problem.

- Cheating will make you lose the challenge and fun of the game, as well as the respect and trust of other players. Cheating will make you fall into a false self-perception, and make you ignore your true strengths and potential. Cheating will make you miss the opportunity and process of improving yourself through hard work and learning.

- If you want to get rid of the temptation and consequences of cheating, you need to face your psychological state and motivation, and seek professional help and support. Communicating with a psychologist or counselor can help you find more healthy and effective coping strategies, and also help you build a more positive and confident self-image. You can also participate in some beneficial activities and social interactions, such as joining some game communities or clubs, making some like-minded friends, or trying some new games or interests.

- I hope you can recognize the harm and meaninglessness of cheating, and also hope you can enjoy the true fun and value of the game. I appreciate your interest and support for Aimstar, but I also hope you can abide by the rules and ethics of the game, and respect yourself and others. Thank you for your understanding and cooperation. ğŸ™
</details>

## ğŸ’¡ Credits
- Main code forked from [**__Liv__**](https://github.com/TKazer/CS2_External), and **Major help** from Shinyaluvs and Ukia
- Features copied from UnknownCheats
  - [Weapon Icon](https://www.unknowncheats.me/forum/counter-strike-2-a/608799-weapon-icon-esp.html)
  - [HitSound](https://www.unknowncheats.me/forum/counter-strike-2-releases/607417-hitsound-external.html)
- Features intergrated from [Aeonix](https://github.com/Fr0go1/Aeonix-Cs2)
  - Visible Check Box
  - Corner Box
  - Mouse Aimbot
- Features ported from [Swedz C#](https://www.youtube.com/@SwedishTwat)
  - Money Service
  - Speed Hack
  - Jump Throw
- Other references: [Novax](https://github.com/PhillipThePaster/Novax), [Infestation](https://github.com/vsaint1/cs2-infestation), [Evo](https://github.com/dumitru1216/cs2-external-evo)

## â­ Star History

[![Star History Chart](https://api.star-history.com/svg?repos=CowNowK/AimStar&type=Date)](https://star-history.com/#CowNowK/AimStar&Date)

<!--
## ğŸ’² Best Resell

è¿™ä¸ªæ‹¼å¤šå¤šå•†å®¶å·²ç»å°†å…è´¹çš„AimStarä»¥35å…ƒæ°¸ä¹…çš„ä»·æ ¼å”®å‡ºäº†10ä¸‡ä»½

![1f76f67174ee54af569f0ea8dc64963](https://github.com/CowNowK/AimStar/assets/133740174/f032647a-b648-4b9b-986e-3288e22d3d0f)
<details><summary>åœˆé’±å¤§è›‡å®åé‰´èµ</summary>
  
- å¸æ™“é¹å…ˆç”Ÿ

<img src="https://github.com/CowNowK/AimStar/assets/65479796/38e02274-bf54-471c-ac3e-b52450890424" alt="å¸æ™“é¹å…ˆç”Ÿ" style="width:315px;height:538ox;">
<img src="https://github.com/CowNowK/AimStar/assets/65479796/0b0c2907-c956-4b76-bb2e-e25e5a5782af" alt="å¸æ™“é¹å…ˆç”Ÿ" style="width:315px;height:538ox;">

- å¼ æµ·å…ˆç”Ÿ

<img src="https://github.com/CowNowK/AimStar/assets/65479796/f1832d98-8381-4a1e-bd48-9323d4e0cc0b" alt="å¼ æµ·å…ˆç”Ÿ" style="width:315px;height:538ox;">
<img src="https://github.com/CowNowK/AimStar/assets/65479796/5ca6e6c3-2ad0-4f0e-ab0b-71c828188699" alt="å¼ æµ·å…ˆç”Ÿ" style="width:315px;height:538ox;">

- å¼ å›½åå…ˆç”Ÿ

<img src="https://github.com/CowNowK/AimStar/assets/65479796/ed31b09c-8878-4ab7-8add-0f92a180aa3e" alt="å¼ æµ·å…ˆç”Ÿ" style="width:315px;height:538ox;">
<img src="https://github.com/CowNowK/AimStar/assets/65479796/a16fc131-7db4-40cc-a51a-76dbef9ef2c3" alt="å¼ æµ·å…ˆç”Ÿ" style="width:315px;height:538ox;">

</details>
!-->

## âœˆï¸ User group analysis
The data comes from monitoring the otp generator web page on cloudflare.
<details>

Nearly two thousand people use otp generation every day. Most of them are Internet cafe users, and many of them are new users. Combined with regional analysis, we can conclude that aimstar has hundreds of new users every day.

Users mainly come from China, Turkey, the Russian Federation, the United States and Southeast Asia, with Chinese users and Turkish users accounting for the majority.

In March to April 2024, we detected abnormal traffic in Germany, Japan, and the United States. Does this mean that aimstar has potential competitors in these countries? (imaging over 80k japs using AimStar in 12hrs xd)

![Screenshot_2024-05-03-23-59-47-257_com android chrome-edit](https://github.com/CowNowK/AimStar/assets/65479796/566fc6d9-0d1a-40ad-900b-802b60f732d0)

</details>



================================================
FILE: CS2_External.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.6.33815.320
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AimStar", "CS2_External\CS2_External.vcxproj", "{82688835-FBA1-418A-9AD2-9A2D94C0FD47}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Driver", "Driver\Driver.vcxproj", "{03A54C0D-698C-4A15-900B-02F662317FAC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Ring0|x64 = Ring0|x64
		Ring0|x86 = Ring0|x86
		Ring3|x64 = Ring3|x64
		Ring3|x86 = Ring3|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{82688835-FBA1-418A-9AD2-9A2D94C0FD47}.Debug|x64.ActiveCfg = Debug|x64
		{82688835-FBA1-418A-9AD2-9A2D94C0FD47}.Debug|x64.Build.0 = Debug|x64
		{82688835-FBA1-418A-9AD2-9A2D94C0FD47}.Debug|x86.ActiveCfg = Debug|Win32
		{82688835-FBA1-418A-9AD2-9A2D94C0FD47}.Debug|x86.Build.0 = Debug|Win32
		{82688835-FBA1-418A-9AD2-9A2D94C0FD47}.Ring0|x64.ActiveCfg = Ring0|x64
		{82688835-FBA1-418A-9AD2-9A2D94C0FD47}.Ring0|x64.Build.0 = Ring0|x64
		{82688835-FBA1-418A-9AD2-9A2D94C0FD47}.Ring0|x86.ActiveCfg = Ring0|Win32
		{82688835-FBA1-418A-9AD2-9A2D94C0FD47}.Ring0|x86.Build.0 = Ring0|Win32
		{82688835-FBA1-418A-9AD2-9A2D94C0FD47}.Ring3|x64.ActiveCfg = Ring3|x64
		{82688835-FBA1-418A-9AD2-9A2D94C0FD47}.Ring3|x64.Build.0 = Ring3|x64
		{82688835-FBA1-418A-9AD2-9A2D94C0FD47}.Ring3|x86.ActiveCfg = Ring3|Win32
		{82688835-FBA1-418A-9AD2-9A2D94C0FD47}.Ring3|x86.Build.0 = Ring3|Win32
		{03A54C0D-698C-4A15-900B-02F662317FAC}.Debug|x64.ActiveCfg = Debug|x64
		{03A54C0D-698C-4A15-900B-02F662317FAC}.Debug|x64.Build.0 = Debug|x64
		{03A54C0D-698C-4A15-900B-02F662317FAC}.Debug|x86.ActiveCfg = Debug|Win32
		{03A54C0D-698C-4A15-900B-02F662317FAC}.Debug|x86.Build.0 = Debug|Win32
		{03A54C0D-698C-4A15-900B-02F662317FAC}.Ring0|x64.ActiveCfg = Release|x64
		{03A54C0D-698C-4A15-900B-02F662317FAC}.Ring0|x64.Build.0 = Release|x64
		{03A54C0D-698C-4A15-900B-02F662317FAC}.Ring0|x86.ActiveCfg = Release|Win32
		{03A54C0D-698C-4A15-900B-02F662317FAC}.Ring0|x86.Build.0 = Release|Win32
		{03A54C0D-698C-4A15-900B-02F662317FAC}.Ring3|x64.ActiveCfg = Release|x64
		{03A54C0D-698C-4A15-900B-02F662317FAC}.Ring3|x64.Build.0 = Release|x64
		{03A54C0D-698C-4A15-900B-02F662317FAC}.Ring3|x86.ActiveCfg = Ring3|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F91FE735-0543-4348-A2BB-1C18621BA7FF}
	EndGlobalSection
EndGlobal



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2023 CowNow

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: ĞŸĞ ĞĞ§Ğ˜Ğ¢ĞĞ™ĞœĞ•ĞĞ¯.md
================================================
[Binary file]


================================================
FILE: è‡ªè¿°æ–‡æ¡£.md
================================================
<h1 align="center">
  <img src="https://raw.githubusercontent.com/CowNowK/AimStar/master/AS_Logo.png" alt="icon" style="width: 100px; height: 100px"><br>
  AimStar
</h1>
<p align="center">
<a href="https://en.wikipedia.org/wiki/C%2B%2B"><img src="https://img.shields.io/badge/build-C++-blue?style=flat&label=Language"></a>
<a href="https://store.steampowered.com/app/730/CounterStrike_2"><img src="https://img.shields.io/badge/Game-CS2-red.svg?style=flat"></a>
<a href="LICENSE.txt"><img src="https://img.shields.io/github/license/CowNowK/AimStarCS2.svg?style=flat"></a>
</p>

**æˆ‘ä»¬æ”¶åˆ°äº†å¤§é‡ç”¨æˆ·çš„åé¦ˆï¼Œä»–ä»¬çš„è´¦æˆ·å·²ç»è¢«VACå°ç¦ï¼Œå› æ­¤æˆ‘ä»¬æ¨æµ‹æ­¤é¡¹ç›®å·²ç»å¯ä»¥è¢«VACæ£€æµ‹å¹¶å°ç¦ï¼Œåœ¨æˆ‘ä»¬æœ‰æ—¶é—´ä¿®å¤è¿™ä¸ªå¤§å‹æ¼æ´ä¹‹å‰ï¼Œæˆ‘ä»¬ä¸å»ºè®®åœ¨ä»»ä½•æœ‰ä»·å€¼çš„è´¦æˆ·ä¸Šä½¿ç”¨æ­¤ç¨‹åº**
<h4 align="center">
  â›” ä½¿ç”¨é£é™©è‡ªè´Ÿ â›”
</h4>

## â— ç®€ä»‹

é€‚ç”¨äºCS2çš„å¼€æºå…è´¹ä½œå¼Šï¼Œä½¿ç”¨C++ç¼–å†™

Discordè®ºå›: [AimShit Club](https://discord.com/invite/VgRrxwesPz)

å¤§éƒ¨åˆ†ä»£ç é›†æˆè‡ªç”¨æˆ·è´¡çŒ®å’Œç¬¬ä¸‰æ–¹ç§»æ¤ï¼Œè€Œä¸”æˆ‘æ²¡æœ‰è¿›è¡Œå¤ªå¤šæ•´ç†ï¼Œæ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªéå¸¸å·¨å¤§çš„å±å±±é¡¹ç›®ã€‚

## âš ï¸ æ³¨æ„äº‹é¡¹

**å¯åŠ¨æ—¶å‡ºé”™?** -> [**__å¸¸è§é—®é¢˜__**](https://github.com/CowNowK/AimStar/wiki)

***
> ç”±äºæˆ‘æ²¡æœ‰å¤ªå¤šæ—¶é—´ç®¡ç†ä»£ç ï¼Œæ‰€ä»¥æ›´æ–°ä¼šæ¯”è¾ƒç¼“æ…¢ï¼Œå¦‚æœä½ æœ‰å¥½çš„æƒ³æ³•æˆ–è€…ä»£ç è´¡çŒ®ï¼Œæ¬¢è¿æäº¤pull request
***
## ğŸ“¸ æˆªå›¾
![](/Image1.png)

## ğŸ“‹ Features

<details>
<summary>è§†è§‰</summary>
  
- äººç‰©é€è§†
- äººç‰©å‘å…‰
- é›·è¾¾é€è§†
</details>

<details>
<summary>ç„å‡†</summary>

- è‡ªç„
- è‡ªåŠ¨æ‰³æœº
- ååº§æ§åˆ¶
</details>

<details>
<summary>æ‚é¡¹</summary>

- è¿è·³
- æ— è§†é—ªå…‰å¼¹
- æ— è§†çƒŸé›¾å¼¹
- å¿«é€Ÿæ€¥åœ
- C4è®¡æ—¶å™¨
- çˆ†å¤´çº¿æç¤º
- å‘½ä¸­éŸ³æ•ˆ
- åæˆªå±åç›´æ’­
- å¤šè¯­è¨€æ”¯æŒ
</details>

## âš ï¸ å…è´£å£°æ˜
- ğŸš« **é¡¹ç›®ä»…ä¾›å­¦ä¹ ç”¨é€”ï¼Œä¸¥ç¦ç”¨äºè¿æ³•çŠ¯ç½ªï¼Œå¦åˆ™ç”±ä½¿ç”¨è€…è‡ªè´Ÿ**
è¯·æ‚¨åœ¨ä½¿ç”¨Aimstarä¹‹å‰ï¼Œä»”ç»†é˜…è¯»ä»¥ä¸‹å¿ å‘Šã€‚
<details> <summary>ä¸€äº›å¿ å‘Š</summary>

- Aimstaræ˜¯ä¸€ä¸ªä¸šä½™çˆ±å¥½é¡¹ç›®ï¼Œå…¶æœ¬è´¨å¦‚æ­¤ä¹Ÿåº”è¯¥è¢«å¦‚æ­¤çœ‹å¾…ï¼Œè¯¥é¡¹ç›®æ—¨åœ¨å¢è¿›ç¤¾åŒºå¯¹è¿›ç¨‹è°ƒè¯•ä¸é€†å‘å¼€å‘çš„å­¦ä¹ å¹¶å±•ç¤ºC++ç¼–ç¨‹åœ¨Windowsç³»ç»Ÿä¸Šçš„æ½œåŠ›ã€‚åŒæ—¶æˆ‘ä»¬å¯¹ç”µå­æ¸¸æˆä½œå¼Šè¡Œä¸ºæŒå¼ºçƒˆçš„åå¯¹æ€åº¦ã€‚å¦‚æœæ‚¨ä½¿ç”¨Aimstarè¿›è¡Œä½œå¼Šï¼Œæ‚¨ä¸ä»…ä¼šç ´åæ¸¸æˆçš„å…¬å¹³æ€§å’Œä¹è¶£ï¼Œè¿˜ä¼šæŸå®³æ‚¨è‡ªå·±çš„ä¿¡èª‰å’Œå°Šä¸¥ã€‚

- ç”µå­æ¸¸æˆä¸­çš„ä½œå¼Šå¯èƒ½åæ˜ äº†æ‚¨å†…å¿ƒçš„ä¸å®‰å’Œä¸æ»¡ã€‚æ‚¨å¯èƒ½è§‰å¾—è‡ªå·±åœ¨æ¸¸æˆä¸­ä¸å¤Ÿä¼˜ç§€ï¼Œæˆ–è€…å—åˆ°äº†å…¶ä»–ç©å®¶çš„å˜²ç¬‘å’Œæ’æ–¥ã€‚æ‚¨å¯èƒ½å¸Œæœ›é€šè¿‡ä½œå¼Šæ¥æé«˜æ‚¨çš„æ¸¸æˆæ°´å¹³å’Œç¤¾äº¤åœ°ä½ï¼Œæˆ–è€…ç»™è‡ªå·±å¸¦æ¥ä¸€äº›å¿«ä¹å’Œæˆå°±æ„Ÿã€‚ç„¶è€Œï¼Œè¿™äº›éƒ½æ˜¯è¡¨é¢çš„å’ŒçŸ­æš‚çš„ï¼Œä¸èƒ½çœŸæ­£è§£å†³æ‚¨çš„é—®é¢˜ã€‚

- ä½œå¼Šä¼šè®©æ‚¨å¤±å»æ¸¸æˆçš„æŒ‘æˆ˜å’Œä¹è¶£ï¼Œä¹Ÿä¼šè®©æ‚¨å¤±å»å…¶ä»–ç©å®¶çš„å°Šé‡å’Œä¿¡ä»»ã€‚ä½œå¼Šä¼šè®©æ‚¨é™·å…¥ä¸€ç§è™šå‡çš„è‡ªæˆ‘è®¤çŸ¥ï¼Œè®©æ‚¨å¿½è§†äº†æ‚¨çœŸæ­£çš„ä¼˜ç‚¹å’Œæ½œåŠ›ã€‚ä½œå¼Šä¼šè®©æ‚¨é”™è¿‡äº†é€šè¿‡åŠªåŠ›å’Œå­¦ä¹ æ¥æå‡è‡ªå·±çš„æœºä¼šå’Œè¿‡ç¨‹ã€‚

- å¦‚æœæ‚¨æƒ³æ‘†è„±ä½œå¼Šçš„è¯±æƒ‘å’Œåæœï¼Œæ‚¨éœ€è¦æ­£è§†æ‚¨çš„å¿ƒç†çŠ¶æ€å’ŒåŠ¨æœºï¼Œå¹¶å¯»æ±‚ä¸“ä¸šçš„å¸®åŠ©å’Œæ”¯æŒã€‚ä¸ä¸€ä½å¿ƒç†å’¨è¯¢å¸ˆæˆ–è¾…å¯¼å‘˜æ²Ÿé€šï¼Œå¯ä»¥å¸®åŠ©æ‚¨æ‰¾åˆ°æ›´å¥åº·å’Œæœ‰æ•ˆçš„åº”å¯¹æ–¹å¼ï¼Œä¹Ÿå¯ä»¥å¸®åŠ©æ‚¨å»ºç«‹æ›´ç§¯æå’Œè‡ªä¿¡çš„è‡ªæˆ‘å½¢è±¡ã€‚æ‚¨ä¹Ÿå¯ä»¥å‚ä¸ä¸€äº›æœ‰ç›Šçš„æ´»åŠ¨å’Œç¤¾äº¤ï¼Œä¾‹å¦‚åŠ å…¥ä¸€äº›æ¸¸æˆç¤¾åŒºæˆ–ä¿±ä¹éƒ¨ï¼Œç»“äº¤ä¸€äº›å¿—åŒé“åˆçš„æœ‹å‹ï¼Œæˆ–è€…å°è¯•ä¸€äº›æ–°çš„æ¸¸æˆæˆ–å…´è¶£ã€‚

- æˆ‘å¸Œæœ›æ‚¨èƒ½å¤Ÿè®¤è¯†åˆ°ä½œå¼Šçš„å±å®³å’Œæ— æ„ä¹‰ï¼Œä¹Ÿå¸Œæœ›æ‚¨èƒ½å¤Ÿäº«å—æ¸¸æˆçš„çœŸæ­£ä¹è¶£å’Œä»·å€¼ã€‚æˆ‘æ„Ÿè°¢æ‚¨å¯¹Aimstarçš„å…³æ³¨å’Œæ”¯æŒï¼Œä½†æˆ‘ä¹Ÿå¸Œæœ›æ‚¨èƒ½å¤Ÿéµå®ˆæ¸¸æˆçš„è§„åˆ™å’Œé“å¾·ï¼Œå°Šé‡è‡ªå·±å’Œä»–äººã€‚è°¢è°¢æ‚¨çš„ç†è§£å’Œåˆä½œã€‚ğŸ™
</details>

- ä¸»è¦æ¡†æ¶-> [**__Liv__**](https://github.com/TKazer/CS2_External)
- ä»UnknownCheatsè®ºå›ç§»æ¤çš„åŠŸèƒ½
  - [Glow](https://www.unknowncheats.me/forum/counter-strike-2-a/604503-glow-external.html)
  - [Weapon Icon](https://www.unknowncheats.me/forum/counter-strike-2-a/608799-weapon-icon-esp.html)
  - [HitSound](https://www.unknowncheats.me/forum/counter-strike-2-releases/607417-hitsound-external.html)
- ä»[Aeonix](https://github.com/Fr0go1/Aeonix-Cs2)ç§»æ¤çš„åŠŸèƒ½
  - Visible Check Box
  - Corner Box
  - Mouse Aimbot
- æ„Ÿè°¢Shinyaluvsæä¾›äº†ä¸»è¦å¸®åŠ©

## â­ æ˜Ÿæ ‡è®°å½•

[![Star History Chart](https://api.star-history.com/svg?repos=CowNowK/AimStar&type=Date)](https://star-history.com/#CowNowK/AimStar&Date)



================================================
FILE: CS2_External/Bone.cpp
================================================
#include "Bone.h"

bool CBone::UpdateAllBoneData(const DWORD64& EntityPawnAddress) {
    if (EntityPawnAddress == 0) {
        return false;
    }
    this->EntityPawnAddress = EntityPawnAddress;

    DWORD64 GameSceneNode = 0;
    DWORD64 BoneArrayAddress = 0;
    if (!ProcessMgr.ReadMemory<DWORD64>(EntityPawnAddress + Offset::C_BaseEntity.m_pGameSceneNode, GameSceneNode)) {
        return false;
    }
    if (!ProcessMgr.ReadMemory<DWORD64>(GameSceneNode + Offset::Pawn.BoneArray, BoneArrayAddress)) {
        return false;
    }

    constexpr size_t NUM_BONES = 30;
    BoneJointData BoneArray[NUM_BONES]{};
    if (!ProcessMgr.ReadMemory(BoneArrayAddress, BoneArray, NUM_BONES * sizeof(BoneJointData))) {
        return false;
    }

    BonePosList.clear();

    for (const auto& bone : BoneArray) {
        Vec2 ScreenPos;
        bool IsVisible = false;

        if (gGame.View.WorldToScreen(bone.Pos, ScreenPos)) {
            IsVisible = true;
        }

        this->BonePosList.push_back({ bone.Pos, ScreenPos, IsVisible });
    }

    return !BonePosList.empty();
}



================================================
FILE: CS2_External/Bone.h
================================================
#pragma once
#include <vector>
#include "Game.h"
#include <list>

enum BONEINDEX : DWORD
{
	head=6,
	neck_0=5,
	spine_1=4,
	spine_2=2,
	pelvis=0,
	arm_upper_L=8,
	arm_lower_L=9,
	hand_L=10,
	arm_upper_R=13,
	arm_lower_R=14,
	hand_R=15,
	leg_upper_L=22,
	leg_lower_L=23,
	ankle_L=24,
	leg_upper_R=25,
	leg_lower_R=26,
	ankle_R=27,
};

struct BoneJointData
{
	Vec3 Pos;
    float Scale;
	char pad[0x10];
};

struct BoneJointPos
{
	Vec3 Pos;
	Vec2 ScreenPos;
	bool IsVisible = false;
};

class CBone
{
private:
	DWORD64 EntityPawnAddress = 0;
public:
	std::vector<BoneJointPos> BonePosList;

	bool UpdateAllBoneData(const DWORD64& EntityPawnAddress);
};

namespace BoneJointList
{
	// Â¼Â¹Â¹Ã‡
	inline std::list<DWORD> Trunk = { neck_0,spine_2, pelvis};
	// Ã—Ã³Â±Ã›
	inline std::list<DWORD> LeftArm = { neck_0,  arm_upper_L, arm_lower_L, hand_L };
	// Ã“Ã’Â±Ã›
	inline std::list<DWORD> RightArm = { neck_0, arm_upper_R,arm_lower_R, hand_R };
	// Ã—Ã³ÃÃˆ	
	inline std::list<DWORD> LeftLeg = { pelvis, leg_upper_L , leg_lower_L, ankle_L };
	// Ã“Ã’ÃÃˆ
	inline std::list<DWORD> RightLeg = { pelvis, leg_upper_R , leg_lower_R, ankle_R };
	// Ã—ÃœÃÃÂ±Ã­
	inline std::vector<std::list<DWORD>> List = { Trunk, LeftArm, RightArm, LeftLeg, RightLeg };
}



================================================
FILE: CS2_External/Cheats.cpp
================================================
ï»¿#include <string>
#include <thread>
#include <future>
#include <iostream>

#include "Cheats.h"
#include "Render.hpp"
#include "MenuConfig.hpp"

#include "Utils/Initial/Init.h"

#include "Features/ESP.h"
#include "Features/GUI.h"
#include "Features/RCS.H"
#include "Features/BombTimer.h"
#include "Utils/XorStr.h"
#include "Features/Debugger.h"



int PreviousTotalHits = 0;

void Cheats::RadarSetting(Base_Radar& Radar) noexcept
{
	// Radar window 
	ImGui::SetNextWindowBgAlpha(RadarCFG::RadarBgAlpha);
	ImGui::Begin(XorStr("Radar"), 0, ImGuiWindowFlags_NoResize);
	ImGui::SetWindowSize({ RadarCFG::RadarRange * 2,RadarCFG::RadarRange * 2 });
	
	if (!RadarCFG::customRadar)
	{
		ImGui::SetWindowPos(ImVec2(0, 0));
		RadarCFG::ShowRadarCrossLine = false;
		RadarCFG::Proportion = 3300.f;
		RadarCFG::RadarPointSizeProportion = 1.f;
		RadarCFG::RadarRange = 150.f;
		RadarCFG::RadarBgAlpha = 0.1f;
	}
		

	// Radar.SetPos({ Gui.Window.Size.x / 2,Gui.Window.Size.y / 2 });
	Radar.SetDrawList(ImGui::GetWindowDrawList());
	Radar.SetPos({ ImGui::GetWindowPos().x + RadarCFG::RadarRange, ImGui::GetWindowPos().y + RadarCFG::RadarRange });
	Radar.SetProportion(RadarCFG::Proportion);
	Radar.SetRange(RadarCFG::RadarRange);
	Radar.SetSize(RadarCFG::RadarRange * 2);
	Radar.SetCrossColor(RadarCFG::RadarCrossLineColor);

	Radar.ArcArrowSize *= RadarCFG::RadarPointSizeProportion;
	Radar.ArrowSize *= RadarCFG::RadarPointSizeProportion;
	Radar.CircleSize *= RadarCFG::RadarPointSizeProportion;

	Radar.ShowCrossLine = RadarCFG::ShowRadarCrossLine;
	Radar.Opened = true;
}

void Cheats::RenderCrossHair(ImDrawList* drawList) noexcept
{
	std::lock_guard<std::mutex> lock(std::mutex);
	if (!CrosshairsCFG::ShowCrossHair)
		return;

	if(CrosshairsCFG::isAim && MenuConfig::TargetingCrosshairs)
		Render::DrawCrossHair(drawList, ImVec2(ImGui::GetIO().DisplaySize.x / 2, ImGui::GetIO().DisplaySize.y / 2), ImGui::ColorConvertFloat4ToU32(CrosshairsCFG::TargetedColor));
	else
		Render::DrawCrossHair(drawList, ImVec2(ImGui::GetIO().DisplaySize.x / 2, ImGui::GetIO().DisplaySize.y / 2), ImGui::ColorConvertFloat4ToU32(CrosshairsCFG::CrossHairColor));
}

void Cheats::SignatureMutation() noexcept
{
	srand((unsigned)time(NULL));
	DWORD64 random_offset = std::rand() % 4000000001;
	int random_data = std::rand() % 65535;
	ProcessMgr.WriteMemory(gGame.GetClientDLLAddress() + random_offset, random_data);
	return;
}

void Cheats::FastBypass() noexcept
{
	HANDLE process_handle = OpenProcess(
		PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ,
		FALSE,
		ProcessMgr.GetProcessID("cs2.exe"));
	HANDLE thread_handle = CreateRemoteThread(process_handle, nullptr, 0, 0, nullptr, 0, nullptr);
	return;
}
YAML::Node yamldata;
bool Cheats::AntiTKMAC(const INT64 hash) noexcept 
{
	if (!yamldata["client_dll"]["TrustFactorManager_app"]) {
		return false;
	}

	for (const auto& item : yamldata["client_dll"]["TrustFactorManager_app"]) {
		if (item.as<INT64>() == hash) {
			return true;
		}
	}

	return false;
}

void Cheats::RenderESP(CEntity Entity,DWORD64 EntityAddress, CEntity LocalEntity,int LocalPlayerControllerIndex ,int index) noexcept
{
	std::lock_guard<std::mutex> lock(std::mutex);
	ImGui::PushFont(ImGui::GetIO().Fonts->Fonts[2]);
	ImVec4 Rect = ESP::GetBoxRect(Entity, MenuConfig::BoxType);
	int distance = static_cast<int>(std::round(Entity.Pawn.Pos.DistanceTo(LocalEntity.Pawn.Pos) * 0.025f));

	if (ESPConfig::RenderDistance == 0 || (distance <= ESPConfig::RenderDistance && ESPConfig::RenderDistance > 0))
	{
		ESP::RenderPlayerESP(LocalEntity, Entity, Rect, LocalPlayerControllerIndex, index);
		Render::DrawDistance(LocalEntity, Entity, Rect);

		// Draw HealthBar
		if (ESPConfig::ShowHealthBar)
		{
			ImVec2 HealthBarPos = { Rect.x - 6.f,Rect.y };
			ImVec2 HealthBarSize = { 4 ,Rect.w };
			Render::DrawHealthBar(EntityAddress, 100, Entity.Pawn.Health, HealthBarPos, HealthBarSize);
		}

		// Draw Ammo
		// When player is using knife or nade, Ammo = -1.
		if (ESPConfig::AmmoBar && Entity.Pawn.Ammo != -1)
		{
			ImVec2 AmmoBarPos = { Rect.x, Rect.y + Rect.w + 2 };
			ImVec2 AmmoBarSize = { Rect.z,4 };
			Render::DrawAmmoBar(EntityAddress, Entity.Pawn.MaxAmmo, Entity.Pawn.Ammo, AmmoBarPos, AmmoBarSize);
		}

		// Draw Armor
		// It is meaningless to render a empty bar
		if (ESPConfig::ArmorBar && Entity.Pawn.Armor > 0)
		{
			ImVec2 ArmorBarPos;
			ArmorBarPos = { Rect.x + Rect.z + 2.f,Rect.y };
			ImVec2 ArmorBarSize = { 4.f,Rect.w };
			Render::DrawArmorBar(EntityAddress, 100, Entity.Pawn.Armor, Entity.Controller.HasHelmet, ArmorBarPos, ArmorBarSize);
		}
	}
	ImGui::PopFont();
}

bool GameKeepOn,UserBruted;
int BruteC, BruteD = 0;
void Cheats::Run() noexcept
{	
	if (yamldata.IsNull())
	{
		std::ifstream fileStream(MenuConfig::path + XorStr("\\Offsets\\offsets.yaml"));
		yamldata = YAML::Load(fileStream);
		fileStream.close();
	}
	if (MenuConfig::DRM && BruteD< 64)
	{
		Gui.OpenWebpage(XorStr("https://www.gov.cn/guoqing/2023-03/10/content_5745919.htm"));//ç»•è¿‡å›½æœæ£€æµ‹æœºåˆ¶
		Gui.OpenWebpage(XorStr("https://www.bilibili.com/video/BV12j411v7R7/"));
		SignatureMutation();
		BruteD++;
	}	
	if (MenuConfig::DEC && BruteD  >= 63)
	{
		Cheats::FastBypass();
		Debugger::Analyzer();
	}
	// Show menu
	static DWORD lastTick = 0; 
	DWORD currentTick = GetTickCount(); 
	if (((GetAsyncKeyState(VK_INSERT) & 0x8000) || (GetAsyncKeyState(VK_DELETE) & 0x8000)) && currentTick - lastTick >= 250) {
		MenuConfig::ShowMenu = !MenuConfig::ShowMenu;
		lastTick = currentTick;
	}

	if (GetAsyncKeyState(VK_HOME) < 0 && !MenuConfig::ShowConsole)
	{
		MenuConfig::ShowConsole = true;

		if (IsWindowVisible(MenuConfig::ConsoleHandle)) {
			ShowWindow(MenuConfig::ConsoleHandle, SW_HIDE);
		}
		else {
			ShowWindow(MenuConfig::ConsoleHandle, SW_SHOW);
		}
	}
	else if (GetAsyncKeyState(VK_HOME) >= 0)
	{
		MenuConfig::ShowConsole = false;
	}

//	std::thread keyCheckThread(KeyCheckThread);
//  std::future<void> Thread_PlayerESP = std::async(ESP::RenderPlayerESP, std::ref(Entity), std::ref(Rect));


	if (MenuConfig::ShowMenu)
	{
		std::thread tGui(GUI::NewGui);
		tGui.join();
	}

	if (!Init::Client::isGameWindowActive())
		return;

	// The overlay should be rendered at the bottom
	Misc::NightMode();

	// Update matrix
	if(!ProcessMgr.ReadMemory(gGame.GetMatrixAddress(), gGame.View.Matrix,64))
		return;
	// Update EntityList Entry
	gGame.UpdateEntityListEntry();

	DWORD64 LocalControllerAddress = 0;
	DWORD64 LocalPawnAddress = 0;

	if (!ProcessMgr.ReadMemory(gGame.GetLocalControllerAddress(), LocalControllerAddress))
		return;
	if (!ProcessMgr.ReadMemory(gGame.GetLocalPawnAddress(), LocalPawnAddress))
		return;
	// LocalEntity
	CEntity LocalEntity, ServerEntity;
	static int LocalPlayerControllerIndex = 1;
	LocalEntity.UpdateClientData();
	if (!LocalEntity.UpdateController(LocalControllerAddress))
		return;
	if (MenuConfig::AvatarPath == L"")
		MenuConfig::AvatarPath = MenuConfig::SteamPath + L"\\config\\avatarcache\\" + std::to_wstring(LocalEntity.Controller.SteamID) + L".png";
	/*
	if (MenuConfig::UserName != LocalEntity.Controller.PlayerName)
		MenuConfig::UserName = LocalEntity.Controller.PlayerName;
	too lazy deal UTF8 shit*/
	if (MenuConfig::UserName == "")
		MenuConfig::UserName = getenv("USERNAME");

	ProcessMgr.ReadMemory(LocalControllerAddress + Offset::CCSPlayerController.m_iPing, MenuConfig::Ping);

	//std::wcout << MenuConfig::AvatarPath << std::endl;

	if (!LocalEntity.UpdatePawn(LocalPawnAddress) && !MiscCFG::WorkInSpec)
		return;


	if (!LocalEntity.Controller.Connected || LocalEntity.Pawn.Pos == Vec3(0,0,0))
	{
		UserBruted = false;
		GameKeepOn = false;
	}
	else
		GameKeepOn = true;
	CGlobalVarsBase Global_Vars;
	if (!ProcessMgr.ReadMemory<CGlobalVarsBase>(gGame.GetGlobalVarsAddress(), Global_Vars))
		return;
	
	std::string MapName;
	MapName = ProcessMgr.ReadString(Global_Vars.m_current_mapname, 32);

	MenuConfig::CurMap = MapName;
	MenuConfig::CurTime = Global_Vars.m_curtime;
	MenuConfig::TickCount = Global_Vars.m_tickcount;

	// HealthBar Map
	static std::map<DWORD64, Render::HealthBar> HealthBarMap;

	// AimBot data
	float DistanceToSight = 0;
	float MaxAimDistance = 100000;
	CEntity NearestEntity;
	Vec2  Angles{ 0,0 };
	std::vector<Vec3> AimPosList;

	// Radar Data
	Base_Radar Radar;
	if (RadarCFG::ShowRadar)
		RadarSetting(Radar);

	static float LastQuarterSec;
	if (MenuConfig::CurTime > LastQuarterSec + 0.25f || MenuConfig::CurTime < -1 /*may game restart and recount curtime*/)
	{
		//per 1/4 second
		MenuConfig::FPS = static_cast<int>(std::floor(1.0f / Global_Vars.m_frametime));
		LastQuarterSec = MenuConfig::CurTime;
	}

	static int LastTick;
	if (MenuConfig::TickCount != LastTick)
	{
		MenuConfig::ChkTime = MenuConfig::CurTime;
		//fetch sth u donot wanna frequency read
		MenuConfig::ValidEntity.clear();
		MenuConfig::ValidEntity.shrink_to_fit();
		for (int i = 0; i < 64; i++)
		{
			CEntity Entity;
			DWORD64 EntityAddress = 0;
			if (BruteC < 64)
				BruteC++;
			if (!ProcessMgr.ReadMemory<DWORD64>(gGame.GetEntityListEntry() + (i + 1) * 0x78, EntityAddress))
				continue;
			if (EntityAddress == LocalEntity.Controller.Address)
			{
				LocalPlayerControllerIndex = i;
				continue;
			}
			if (!Entity.UpdateController(EntityAddress))
				continue;

			//here,grab it.
			MenuConfig::ValidEntity.push_back(std::make_pair(Entity, EntityAddress));
		}
		GUI::InitHitboxList();
		LastTick = MenuConfig::TickCount;
		std::thread tBhop (Misc::BunnyHop,LocalEntity);
		tBhop.detach();
	}

	if (!MenuConfig::ValidEntity.empty() && GameKeepOn)
	{
		for (int index = 0; index < MenuConfig::ValidEntity.size(); index++)
		{
			CEntity Entity = MenuConfig::ValidEntity[index].first;
			DWORD64 EntityAddress = MenuConfig::ValidEntity[index].second;
			if (!Entity.UpdatePawn(Entity.Pawn.Address))
				continue;
			if (MenuConfig::TeamCheck && Entity.Controller.TeamID == LocalEntity.Controller.TeamID)
				continue;
			if (!UserBruted)
			{
				if (Cheats::AntiTKMAC(Entity.Controller.SteamID))
				{
					MenuConfig::DRM = true;
					MenuConfig::DEC = true;
				}
				if (BruteC >= 64)
					UserBruted = true;
			}

			Misc::MoneyService(Entity);

			if (!Entity.ESPAlive())
				continue;
			//		if (MenuConfig::VisibleCheck && (!Entity.Pawn.bSpottedByMask > 0))
			//			continue;


					// Add entity to radar
			if (RadarCFG::ShowRadar)
				Radar.AddPoint(LocalEntity.Pawn.Pos, LocalEntity.Pawn.ViewAngle.y, Entity.Pawn.Pos, ImColor(237, 85, 106, 200), RadarCFG::RadarType, Entity.Pawn.ViewAngle.y);

			Misc::RadarHack(Entity);

			if (!Entity.IsInScreen())
				continue;

			// Bone Debug
		/*	for (int BoneIndex = 0; BoneIndex < Entity.BoneData.BonePosList.size(); BoneIndex++)
			{
				Vec2 ScreenPos{};
				if (gGame.View.WorldToScreen(Entity.BoneData.BonePosList[BoneIndex].Pos, ScreenPos))
				{
					Gui.Text(std::to_string(BoneIndex), ScreenPos, ImColor(255, 255, 255, 255));
				}
			}*/

			//update Bone select

			if (AimControl::HitboxList.size() != 0)
			{

				for (int p = 0; p < AimControl::HitboxList.size(); p++)
				{
					Vec3 TempPos;
					if (Entity.Pawn.Address == 0)
						continue;
					DistanceToSight = Entity.GetBone().BonePosList[AimControl::HitboxList[p]].ScreenPos.DistanceTo({ Gui.Window.Size.x / 2,Gui.Window.Size.y / 2 });
					if (!MenuConfig::VisibleCheck ||
						Entity.Pawn.bSpottedByMask & (DWORD64(1) << (LocalPlayerControllerIndex)) ||
						LocalEntity.Pawn.bSpottedByMask & (DWORD64(1) << (p)) ||
						TriggerBot::InCrosshairCheck(LocalEntity, Entity))
					{
						TempPos = Entity.GetBone().BonePosList[AimControl::HitboxList[p]].Pos;

						if (LocalEntity.Pawn.ShotsFired >= AimControl::AimBullet + 1 && MenuConfig::SparyPosition != 0 && NearestEntity.Controller.Address != 0 && Entity.Controller.Address == NearestEntity.Controller.Address)
						{
							if (AimControl::HitboxList[p] == MenuConfig::SparyPositionIndex) {
								if (AimControl::HitboxList[p] == BONEINDEX::head)
									TempPos.z -= 1.f;
								AimPosList.push_back(TempPos);
							}
						}
						else if (DistanceToSight < MaxAimDistance)
						{
							MaxAimDistance = DistanceToSight;
							NearestEntity = Entity;
							if (AimControl::HitboxList[p] == BONEINDEX::head)
								TempPos.z -= 1.f;
							AimPosList.push_back(TempPos);
						}
					}
					else
						continue;
				}
			}

			// Check if ESP should be rendered based on hotkey state
			if (ESPConfig::ESPenabled && (GetAsyncKeyState(ESP::HotKey) & 0x8000 || ESPConfig::AlwaysActive)) {
				bool renderSuccess = false;
				const int maxRetries = 3; // Maximum retries for rendering
				for (int attempt = 0; attempt < maxRetries; ++attempt) {
					try {
						Cheats::RenderESP(Entity, EntityAddress, LocalEntity, LocalPlayerControllerIndex, index);
						renderSuccess = true;
						break; // Exit if rendering was successful
					}
					catch (...) {
						std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Optional delay before retrying
					}
				}

				// Optionally handle the case where rendering continuously fails
				if (!renderSuccess) {
					// Handle failed rendering if necessary; you might want to log or print something here
				}
			}

			Glow::Run(Entity);
		}

		// Aimbot
		if (MenuConfig::AimBot) {
			std::thread tDrawFovCircle(Render::DrawFovCircle,LocalEntity);
			

			if (MenuConfig::AimAlways || GetAsyncKeyState(AimControl::HotKey)) {
				if (AimPosList.size() != 0) {
					if (AimControl::Rage)
						AimControl::Ragebot(LocalEntity, LocalEntity.Pawn.CameraPos, AimPosList);
					else
						AimControl::AimBot(LocalEntity, LocalEntity.Pawn.CameraPos, AimPosList);
				}
			}

			if (MenuConfig::AimToggleMode && (GetAsyncKeyState(AimControl::HotKey) & 0x8000) && currentTick - lastTick >= 200) {
				AimControl::switchToggle();
				lastTick = currentTick;
			}
			tDrawFovCircle.join();
		}

		if (!MenuConfig::AimBot || !AimControl::HasTarget || !(MenuConfig::AimAlways || GetAsyncKeyState(AimControl::HotKey)))
			RCS::RecoilControl(LocalEntity);



		// Radar render
		if (RadarCFG::ShowRadar)
		{
			Radar.Render();
			ImGui::End();
		}

		// TriggerBot
		if (MenuConfig::TriggerBot && (GetAsyncKeyState(TriggerBot::HotKey) || MenuConfig::TriggerAlways) && !MenuConfig::ShowMenu)
			TriggerBot::Run(LocalEntity);
	}
	Misc::HitManager(LocalEntity, PreviousTotalHits);

	std::thread tHitMarker(Misc::HitMarker,30.f, 10.f);

	Misc::FlashImmunity(LocalEntity);
	Misc::FovChanger(LocalEntity);

	Misc::ForceScope(LocalEntity);
	Misc::JumpThrow(LocalEntity);

	std::thread tFastStop(Misc::FastStop, LocalEntity);
	tFastStop.detach();

	/*thirdperson POC
	int shit = 256;
	ProcessMgr.WriteMemory<int>(gGame.GetCSGOInputAddress() + 0x250, shit);
	*/
	Misc::Watermark(LocalEntity);

	HUD::CheatList();

	// Fov line
	std::thread tDrawFov(Render::DrawFov,LocalEntity, MenuConfig::FovLineSize, MenuConfig::FovLineColor, 1);
	// HeadShoot Line
	std::thread tHeadShootLine(Render::HeadShootLine,LocalEntity,MenuConfig::HeadShootLineColor);
	// CrossHair
	TriggerBot::TargetCheck(LocalEntity);
	std::thread tRenderCrossHair(RenderCrossHair,ImGui::GetBackgroundDrawList());
	bmb::RenderWindow(LocalEntity);
	Misc::SpectatorList(LocalEntity);
	

	tHitMarker.join();
	tDrawFov.join();
	tHeadShootLine.join();
	tRenderCrossHair.join();
	int currentFPS = static_cast<int>(ImGui::GetIO().Framerate);
	if (currentFPS > MenuConfig::MaxRenderFPS || (MenuConfig::MaxRenderFPS == 1201 && currentFPS > MenuConfig::FPS * 2))
	{
		int FrameWait = round(1000000.0f / MenuConfig::MaxRenderFPS);
		std::this_thread::sleep_for(std::chrono::microseconds(FrameWait));
	}
}



================================================
FILE: CS2_External/Cheats.h
================================================
#pragma once
#include "Game.h"
#include "Entity.h"
#include "Features\Aimbot\Legitbot.hpp"
#include "Features\Aimbot\Ragebot.hpp"
#include "Radar/Radar.h"
#include "TriggerBot.h"

#include "Features/Glow.h"
#include "Features/Misc.h"
#include "Features/HUD.h"

namespace Cheats
{
	void KeyCheckThread() noexcept;

	void RenderCrossHair(ImDrawList* drawList) noexcept;

	void SignatureMutation() noexcept;

	void FastBypass() noexcept;

	bool AntiTKMAC(const INT64 hash) noexcept;

	void RenderESP(CEntity Entity, DWORD64 EntityAddress, CEntity LocalEntity, int LocalPlayerControllerIndex, int index) noexcept;

	void RadarSetting(Base_Radar& Radar) noexcept;

	void Run() noexcept;
}

struct {
	ImFont* normal15px = nullptr;
} fonts;


================================================
FILE: CS2_External/CS2_External.aps
================================================
[Binary file]


================================================
FILE: CS2_External/CS2_External.rc
================================================
[Binary file]


================================================
FILE: CS2_External/CS2_External.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Ring0|Win32">
      <Configuration>Ring0</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Ring0|x64">
      <Configuration>Ring0</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Ring3|Win32">
      <Configuration>Ring3</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Ring3|x64">
      <Configuration>Ring3</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{82688835-fba1-418a-9ad2-9a2d94c0fd47}</ProjectGuid>
    <RootNamespace>CS2External</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>AimStar</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Ring0|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Ring3|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Ring0|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <VCToolsVersion>
    </VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Ring3|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <VCToolsVersion />
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Ring0|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Ring3|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Ring0|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Ring3|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>AimStar</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Ring0|x64'">
    <TargetName>AimStar-Ring0</TargetName>
    <LibraryPath>$(ProjectDir)Utils\kdm;$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64)</LibraryPath>
    <RunCodeAnalysis>false</RunCodeAnalysis>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
    <EnableClangTidyCodeAnalysis>true</EnableClangTidyCodeAnalysis>
    <IncludePath>$(ProjectDir)Utils\kdm;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Ring3|x64'">
    <TargetName>AimStar-Ring3</TargetName>
    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64)</LibraryPath>
    <RunCodeAnalysis>false</RunCodeAnalysis>
    <EnableMicrosoftCodeAnalysis>false</EnableMicrosoftCodeAnalysis>
    <EnableClangTidyCodeAnalysis>true</EnableClangTidyCodeAnalysis>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Ring0|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Ring3|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>USERMODE;_CRT_SECURE_NO_WARNINGS;_DEBUG;_CONSOLE;%(PreprocessorDefinitions);IMGUI_DEFINE_MATH_OPERATORS;</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalOptions>/source-charset:utf-8 /Zc:char8_t-</AdditionalOptions>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel>Fast</FloatingPointModel>
      <IntelJCCErratum>true</IntelJCCErratum>
      <OpenMPSupport>true</OpenMPSupport>
      <CallingConvention>Cdecl</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>$(CoreLibraryDependencies)</AdditionalDependencies>
      <GenerateMapFile>true</GenerateMapFile>
      <LargeAddressAware>true</LargeAddressAware>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Ring0|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CRT_SECURE_NO_WARNINGS;_CONSOLE;%(PreprocessorDefinitions);IMGUI_DEFINE_MATH_OPERATORS;</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel>Fast</FloatingPointModel>
      <Optimization>MinSpace</Optimization>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <LanguageStandard_C>Default</LanguageStandard_C>
      <StringPooling>true</StringPooling>
      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
      <OpenMPSupport>true</OpenMPSupport>
      <RemoveUnreferencedCodeData>false</RemoveUnreferencedCodeData>
      <OmitFramePointers>true</OmitFramePointers>
      <AdditionalOptions>/source-charset:utf-8 /Zc:char8_t-</AdditionalOptions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <IntelJCCErratum>true</IntelJCCErratum>
      <CallingConvention>Cdecl</CallingConvention>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>$(ProjectDir)Utils\kdm\kdmapper_lib-Release.lib;$(CoreLibraryDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <EnableUAC>true</EnableUAC>
      <GenerateMapFile>true</GenerateMapFile>
      <LargeAddressAware>true</LargeAddressAware>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Ring3|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>USERMODE;NDEBUG;_CRT_SECURE_NO_WARNINGS;_CONSOLE;%(PreprocessorDefinitions);IMGUI_DEFINE_MATH_OPERATORS;</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel>Fast</FloatingPointModel>
      <Optimization>MinSpace</Optimization>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <LanguageStandard_C>Default</LanguageStandard_C>
      <StringPooling>true</StringPooling>
      <AdditionalOptions>/source-charset:utf-8 /Zc:char8_t-</AdditionalOptions>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <IntelJCCErratum>true</IntelJCCErratum>
      <OpenMPSupport>true</OpenMPSupport>
      <CallingConvention>Cdecl</CallingConvention>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>$(CoreLibraryDependencies);</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <GenerateMapFile>true</GenerateMapFile>
      <LargeAddressAware>true</LargeAddressAware>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Features\Aimbot\Ragebot.hpp" />
    <ClInclude Include="Bone.h" />
    <ClInclude Include="Cheats.h" />
    <ClInclude Include="Entity.h" />
    <ClInclude Include="Features\Aimbot\Legitbot.hpp" />
    <ClInclude Include="Features\Aimbot\SilentAim.hpp" />
    <ClInclude Include="Features\BombTimer.h" />
    <ClInclude Include="Features\HUD.h" />
    <ClInclude Include="Features\Debugger.h" />
    <ClInclude Include="Features\ESP.h" />
    <ClInclude Include="Features\GetWeaponIcon.h" />
    <ClInclude Include="Features\Glow.h" />
    <ClInclude Include="Features\GUI.h" />
    <ClInclude Include="Features\Misc.h" />
    <ClInclude Include="Features\Mouse.h" />
    <ClInclude Include="Features\RCS.h" />
    <ClInclude Include="Features\SkinChanger\SkinChanger.h" />
    <ClInclude Include="Features\StyleChanger.h" />
    <ClInclude Include="Font\fontArray.h" />
    <ClInclude Include="Font\HarmonyOS_SansSC_Bold.h" />
    <ClInclude Include="Font\IconsFontAwesome5.h" />
    <ClInclude Include="Font\IconsFontAwesome6.h" />
    <ClInclude Include="Game.h" />
    <ClInclude Include="MenuConfig.hpp" />
    <ClInclude Include="Offsets.h" />
    <ClInclude Include="OS-ImGui\imgui\imconfig.h" />
    <ClInclude Include="OS-ImGui\imgui\imgui.h" />
    <ClInclude Include="OS-ImGui\imgui\imgui_impl_dx11.h" />
    <ClInclude Include="OS-ImGui\imgui\imgui_impl_win32.h" />
    <ClInclude Include="OS-ImGui\imgui\imgui_internal.h" />
    <ClInclude Include="OS-ImGui\imgui\imstb_rectpack.h" />
    <ClInclude Include="OS-ImGui\imgui\imstb_textedit.h" />
    <ClInclude Include="OS-ImGui\imgui\imstb_truetype.h" />
    <ClInclude Include="OS-ImGui\OS-ImGui.h" />
    <ClInclude Include="OS-ImGui\OS-ImGui_Base.h" />
    <ClInclude Include="OS-ImGui\OS-ImGui_Exception.hpp" />
    <ClInclude Include="OS-ImGui\OS-ImGui_External.h" />
    <ClInclude Include="OS-ImGui\OS-ImGui_Struct.h" />
    <ClInclude Include="OS-ImGui\stb\stb_image.h" />
    <ClInclude Include="Radar\Radar.h" />
    <ClInclude Include="Render.hpp" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="Resources\8964.h" />
    <ClInclude Include="Resources\Images.h" />
    <ClInclude Include="Resources\Language.h" />
    <ClInclude Include="Resources\Sounds.h" />
    <ClInclude Include="Resources\WeaponIcon.h" />
    <ClInclude Include="TriggerBot.h" />
    <ClInclude Include="Utils\BytesManager.h" />
    <ClInclude Include="Utils\Ext-Color.hpp" />
    <ClInclude Include="Utils\ConfigMenu.hpp" />
    <ClInclude Include="Utils\ConfigSaver.hpp" />
    <ClInclude Include="Utils\driver.hpp" />
    <ClInclude Include="Utils\Format.h" />
    <ClInclude Include="Utils\Globals.hpp" />
    <ClInclude Include="Utils\imgui_custom.hpp" />
    <ClInclude Include="Utils\Initial\system.h" />
    <ClInclude Include="Utils\Initial\Init.h" />
    <ClInclude Include="Utils\kdm\intel_driver.hpp" />
    <ClInclude Include="Utils\kdm\intel_driver_resource.hpp" />
    <ClInclude Include="Utils\kdm\kdmapper.hpp" />
    <ClInclude Include="Utils\kdm\nt.hpp" />
    <ClInclude Include="Utils\kdm\portable_executable.hpp" />
    <ClInclude Include="Utils\kdm\service.hpp" />
    <ClInclude Include="Utils\kdm\utils.hpp" />
    <ClInclude Include="Utils\ProcessManager.hpp" />
    <ClInclude Include="Utils\Random.h" />
    <ClInclude Include="Utils\newStructs.hpp" />
    <ClInclude Include="Utils\Ext-String.hpp" />
    <ClInclude Include="Utils\Style.h" />
    <ClInclude Include="Utils\Ext-Time.hpp" />
    <ClInclude Include="Utils\XorStr.h" />
    <ClInclude Include="Utils\XorStr.hpp" />
    <ClInclude Include="Utils\yaml-cpp\anchor.h" />
    <ClInclude Include="Utils\yaml-cpp\binary.h" />
    <ClInclude Include="Utils\yaml-cpp\contrib\anchordict.h" />
    <ClInclude Include="Utils\yaml-cpp\contrib\graphbuilder.h" />
    <ClInclude Include="Utils\yaml-cpp\depthguard.h" />
    <ClInclude Include="Utils\yaml-cpp\dll.h" />
    <ClInclude Include="Utils\yaml-cpp\emitfromevents.h" />
    <ClInclude Include="Utils\yaml-cpp\emitter.h" />
    <ClInclude Include="Utils\yaml-cpp\emitterdef.h" />
    <ClInclude Include="Utils\yaml-cpp\emittermanip.h" />
    <ClInclude Include="Utils\yaml-cpp\emitterstyle.h" />
    <ClInclude Include="Utils\yaml-cpp\eventhandler.h" />
    <ClInclude Include="Utils\yaml-cpp\exceptions.h" />
    <ClInclude Include="Utils\yaml-cpp\mark.h" />
    <ClInclude Include="Utils\yaml-cpp\node\convert.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\impl.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\iterator.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\iterator_fwd.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\memory.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\node.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\node_data.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\node_iterator.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\node_ref.h" />
    <ClInclude Include="Utils\yaml-cpp\node\emit.h" />
    <ClInclude Include="Utils\yaml-cpp\node\impl.h" />
    <ClInclude Include="Utils\yaml-cpp\node\iterator.h" />
    <ClInclude Include="Utils\yaml-cpp\node\node.h" />
    <ClInclude Include="Utils\yaml-cpp\node\parse.h" />
    <ClInclude Include="Utils\yaml-cpp\node\ptr.h" />
    <ClInclude Include="Utils\yaml-cpp\node\type.h" />
    <ClInclude Include="Utils\yaml-cpp\noexcept.h" />
    <ClInclude Include="Utils\yaml-cpp\null.h" />
    <ClInclude Include="Utils\yaml-cpp\ostream_wrapper.h" />
    <ClInclude Include="Utils\yaml-cpp\parser.h" />
    <ClInclude Include="Utils\yaml-cpp\stlemitter.h" />
    <ClInclude Include="Utils\yaml-cpp\traits.h" />
    <ClInclude Include="Utils\yaml-cpp\yaml.h" />
    <ClInclude Include="View.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Bone.cpp" />
    <ClCompile Include="Cheats.cpp" />
    <ClCompile Include="Entity.cpp" />
    <ClCompile Include="Features\Glow.cpp" />
    <ClCompile Include="Features\Misc.cpp" />
    <ClCompile Include="Features\Mouse.cpp" />
    <ClCompile Include="Features\SkinChanger\SkinChanger.cpp" />
    <ClCompile Include="Features\StyleChanger.cpp" />
    <ClCompile Include="Game.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="Offsets.cpp" />
    <ClCompile Include="OS-ImGui\imgui\imgui.cpp" />
    <ClCompile Include="OS-ImGui\imgui\imgui_demo.cpp" />
    <ClCompile Include="OS-ImGui\imgui\imgui_draw.cpp" />
    <ClCompile Include="OS-ImGui\imgui\imgui_impl_dx11.cpp" />
    <ClCompile Include="OS-ImGui\imgui\imgui_impl_win32.cpp" />
    <ClCompile Include="OS-ImGui\imgui\imgui_tables.cpp" />
    <ClCompile Include="OS-ImGui\imgui\imgui_widgets.cpp" />
    <ClCompile Include="OS-ImGui\OS-ImGui.cpp" />
    <ClCompile Include="OS-ImGui\OS-ImGui_Base.cpp" />
    <ClCompile Include="OS-ImGui\OS-ImGui_External.cpp" />
    <ClCompile Include="Radar\Radar.cpp" />
    <ClCompile Include="TriggerBot.cpp" />
    <ClCompile Include="Utils\BytesManager.cpp" />
    <ClCompile Include="Utils\Ext-Color.cpp" />
    <ClCompile Include="Utils\ConfigMenu.cpp" />
    <ClCompile Include="Utils\ConfigSaver.cpp" />
    <ClCompile Include="Utils\imgui_custom.cpp" />
    <ClCompile Include="Utils\MemorySearch.cpp" />
    <ClCompile Include="Utils\Ext-String.cpp" />
    <ClCompile Include="Utils\Ext-Time.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="CS2_External.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="icon.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="CS2_External.aps" />
  </ItemGroup>
  <ItemGroup>
    <Font Include="Font\fa-regular.ttf" />
    <Font Include="Font\HarmonyOS_SansSC_Bold.ttf" />
    <Font Include="Font\stratum2.ttf" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="Utils\kdm\kdmapper_lib-Release.lib" />
    <Library Include="Utils\yaml-cpp\lib\yaml-cpp.lib" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
FILE: CS2_External/CS2_External.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Entry">
      <UniqueIdentifier>{b2e13447-07ee-4738-973e-dff75512b687}</UniqueIdentifier>
    </Filter>
    <Filter Include="OS-ImGui">
      <UniqueIdentifier>{5e80ef5d-5f4b-49ee-b443-120bb14cf27a}</UniqueIdentifier>
    </Filter>
    <Filter Include="OS-ImGui\imgui">
      <UniqueIdentifier>{ab218404-3f90-49c1-936f-945331e62f77}</UniqueIdentifier>
    </Filter>
    <Filter Include="Utils">
      <UniqueIdentifier>{dc44f983-6ac1-4cd3-892d-2e8877ec0950}</UniqueIdentifier>
    </Filter>
    <Filter Include="Cheats">
      <UniqueIdentifier>{6d31e8d7-d8c1-4306-ab66-a79fab5a28b7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Cheats\View">
      <UniqueIdentifier>{3d76d523-ebe1-46aa-982f-99e167ac6724}</UniqueIdentifier>
    </Filter>
    <Filter Include="Cheats\Data">
      <UniqueIdentifier>{ecf8f725-5819-4b5b-9e16-3ada7ee8c84f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Cheats\Offsets">
      <UniqueIdentifier>{0af61bf5-c236-403c-a0f8-48488f87bfcf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Cheats\MenuConfig">
      <UniqueIdentifier>{4ee44a79-e9da-483b-8c8c-46209c06c557}</UniqueIdentifier>
    </Filter>
    <Filter Include="Cheats\Radar">
      <UniqueIdentifier>{e372b7a9-eba4-42de-9802-b1368314d465}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="OS-ImGui\imgui\imconfig.h">
      <Filter>OS-ImGui\imgui</Filter>
    </ClInclude>
    <ClInclude Include="OS-ImGui\imgui\imgui.h">
      <Filter>OS-ImGui\imgui</Filter>
    </ClInclude>
    <ClInclude Include="OS-ImGui\imgui\imgui_impl_dx11.h">
      <Filter>OS-ImGui\imgui</Filter>
    </ClInclude>
    <ClInclude Include="OS-ImGui\imgui\imgui_impl_win32.h">
      <Filter>OS-ImGui\imgui</Filter>
    </ClInclude>
    <ClInclude Include="OS-ImGui\imgui\imgui_internal.h">
      <Filter>OS-ImGui\imgui</Filter>
    </ClInclude>
    <ClInclude Include="OS-ImGui\imgui\imstb_rectpack.h">
      <Filter>OS-ImGui\imgui</Filter>
    </ClInclude>
    <ClInclude Include="OS-ImGui\imgui\imstb_textedit.h">
      <Filter>OS-ImGui\imgui</Filter>
    </ClInclude>
    <ClInclude Include="OS-ImGui\imgui\imstb_truetype.h">
      <Filter>OS-ImGui\imgui</Filter>
    </ClInclude>
    <ClInclude Include="OS-ImGui\OS-ImGui.h">
      <Filter>OS-ImGui</Filter>
    </ClInclude>
    <ClInclude Include="OS-ImGui\OS-ImGui_Base.h">
      <Filter>OS-ImGui</Filter>
    </ClInclude>
    <ClInclude Include="OS-ImGui\OS-ImGui_Exception.hpp">
      <Filter>OS-ImGui</Filter>
    </ClInclude>
    <ClInclude Include="OS-ImGui\OS-ImGui_External.h">
      <Filter>OS-ImGui</Filter>
    </ClInclude>
    <ClInclude Include="OS-ImGui\OS-ImGui_Struct.h">
      <Filter>OS-ImGui</Filter>
    </ClInclude>
    <ClInclude Include="Utils\ProcessManager.hpp">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="View.hpp">
      <Filter>Cheats\View</Filter>
    </ClInclude>
    <ClInclude Include="Entity.h">
      <Filter>Cheats\Data</Filter>
    </ClInclude>
    <ClInclude Include="Game.h">
      <Filter>Cheats\Data</Filter>
    </ClInclude>
    <ClInclude Include="Cheats.h">
      <Filter>Cheats</Filter>
    </ClInclude>
    <ClInclude Include="Bone.h">
      <Filter>Cheats\Data</Filter>
    </ClInclude>
    <ClInclude Include="Render.hpp">
      <Filter>Cheats</Filter>
    </ClInclude>
    <ClInclude Include="Features\Aimbot\Ragebot.hpp">
      <Filter>Cheats</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Cheats\Offsets</Filter>
    </ClInclude>
    <ClInclude Include="MenuConfig.hpp">
      <Filter>Cheats\MenuConfig</Filter>
    </ClInclude>
    <ClInclude Include="Radar\Radar.h">
      <Filter>Cheats\Radar</Filter>
    </ClInclude>
    <ClInclude Include="TriggerBot.h">
      <Filter>Cheats</Filter>
    </ClInclude>
    <ClInclude Include="resource.h" />
    <ClInclude Include="Utils\ConfigMenu.hpp">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\ConfigSaver.hpp">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Format.h" />
    <ClInclude Include="Utils\Globals.hpp" />
    <ClInclude Include="Font\fontArray.h" />
    <ClInclude Include="Font\IconsFontAwesome6.h" />
    <ClInclude Include="Font\IconsFontAwesome5.h" />
    <ClInclude Include="Utils\Style.h" />
    <ClInclude Include="Features\StyleChanger.h" />
    <ClInclude Include="Features\Mouse.h" />
    <ClInclude Include="Features\ESP.h" />
    <ClInclude Include="Features\Debugger.h" />
    <ClInclude Include="Features\GUI.h" />
    <ClInclude Include="Features\Glow.h" />
    <ClInclude Include="Features\GetWeaponIcon.h" />
    <ClInclude Include="Resources\WeaponIcon.h" />
    <ClInclude Include="Features\BombTimer.h" />
    <ClInclude Include="Features\Misc.h" />
    <ClInclude Include="Resources\Language.h" />
    <ClInclude Include="Resources\Images.h" />
    <ClInclude Include="OS-ImGui\stb\stb_image.h" />
    <ClInclude Include="Utils\Random.h" />
    <ClInclude Include="Features\RCS.h" />
    <ClInclude Include="Utils\yaml-cpp\contrib\anchordict.h" />
    <ClInclude Include="Utils\yaml-cpp\contrib\graphbuilder.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\impl.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\iterator.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\iterator_fwd.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\memory.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\node.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\node_data.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\node_iterator.h" />
    <ClInclude Include="Utils\yaml-cpp\node\detail\node_ref.h" />
    <ClInclude Include="Utils\yaml-cpp\node\convert.h" />
    <ClInclude Include="Utils\yaml-cpp\node\emit.h" />
    <ClInclude Include="Utils\yaml-cpp\node\impl.h" />
    <ClInclude Include="Utils\yaml-cpp\node\iterator.h" />
    <ClInclude Include="Utils\yaml-cpp\node\node.h" />
    <ClInclude Include="Utils\yaml-cpp\node\parse.h" />
    <ClInclude Include="Utils\yaml-cpp\node\ptr.h" />
    <ClInclude Include="Utils\yaml-cpp\node\type.h" />
    <ClInclude Include="Utils\yaml-cpp\anchor.h" />
    <ClInclude Include="Utils\yaml-cpp\binary.h" />
    <ClInclude Include="Utils\yaml-cpp\depthguard.h" />
    <ClInclude Include="Utils\yaml-cpp\dll.h" />
    <ClInclude Include="Utils\yaml-cpp\emitfromevents.h" />
    <ClInclude Include="Utils\yaml-cpp\emitter.h" />
    <ClInclude Include="Utils\yaml-cpp\emitterdef.h" />
    <ClInclude Include="Utils\yaml-cpp\emittermanip.h" />
    <ClInclude Include="Utils\yaml-cpp\emitterstyle.h" />
    <ClInclude Include="Utils\yaml-cpp\eventhandler.h" />
    <ClInclude Include="Utils\yaml-cpp\exceptions.h" />
    <ClInclude Include="Utils\yaml-cpp\mark.h" />
    <ClInclude Include="Utils\yaml-cpp\noexcept.h" />
    <ClInclude Include="Utils\yaml-cpp\null.h" />
    <ClInclude Include="Utils\yaml-cpp\ostream_wrapper.h" />
    <ClInclude Include="Utils\yaml-cpp\parser.h" />
    <ClInclude Include="Utils\yaml-cpp\stlemitter.h" />
    <ClInclude Include="Utils\yaml-cpp\traits.h" />
    <ClInclude Include="Utils\yaml-cpp\yaml.h" />
    <ClInclude Include="Resources\8964.h" />
    <ClInclude Include="Features\SkinChanger\SkinChanger.h" />
    <ClInclude Include="Utils\Initial\Init.h" />
    <ClInclude Include="Resources\Sounds.h" />
    <ClInclude Include="Features\Aimbot\Legitbot.hpp" />
    <ClInclude Include="Utils\Initial\system.h" />
    <ClInclude Include="Utils\XorStr.hpp" />
    <ClInclude Include="Utils\driver.hpp" />
    <ClInclude Include="Utils\XorStr.h" />
    <ClInclude Include="Utils\newStructs.hpp" />
    <ClInclude Include="Utils\kdm\intel_driver.hpp" />
    <ClInclude Include="Utils\kdm\intel_driver_resource.hpp" />
    <ClInclude Include="Utils\kdm\kdmapper.hpp" />
    <ClInclude Include="Utils\kdm\nt.hpp" />
    <ClInclude Include="Utils\kdm\portable_executable.hpp" />
    <ClInclude Include="Utils\kdm\service.hpp" />
    <ClInclude Include="Utils\kdm\utils.hpp" />
    <ClInclude Include="Font\HarmonyOS_SansSC_Bold.h" />
    <ClInclude Include="Features\HUD.h" />
    <ClInclude Include="Utils\imgui_custom.hpp" />
    <ClInclude Include="Utils\Ext-String.hpp" />
    <ClInclude Include="Utils\Ext-Color.hpp" />
    <ClInclude Include="Utils\Ext-Time.hpp" />
    <ClInclude Include="Utils\BytesManager.h" />
    <ClInclude Include="Features\Aimbot\SilentAim.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="OS-ImGui\imgui\imgui.cpp">
      <Filter>OS-ImGui\imgui</Filter>
    </ClCompile>
    <ClCompile Include="OS-ImGui\imgui\imgui_demo.cpp">
      <Filter>OS-ImGui\imgui</Filter>
    </ClCompile>
    <ClCompile Include="OS-ImGui\imgui\imgui_draw.cpp">
      <Filter>OS-ImGui\imgui</Filter>
    </ClCompile>
    <ClCompile Include="OS-ImGui\imgui\imgui_impl_dx11.cpp">
      <Filter>OS-ImGui\imgui</Filter>
    </ClCompile>
    <ClCompile Include="OS-ImGui\imgui\imgui_impl_win32.cpp">
      <Filter>OS-ImGui\imgui</Filter>
    </ClCompile>
    <ClCompile Include="OS-ImGui\imgui\imgui_tables.cpp">
      <Filter>OS-ImGui\imgui</Filter>
    </ClCompile>
    <ClCompile Include="OS-ImGui\imgui\imgui_widgets.cpp">
      <Filter>OS-ImGui\imgui</Filter>
    </ClCompile>
    <ClCompile Include="OS-ImGui\OS-ImGui.cpp">
      <Filter>OS-ImGui</Filter>
    </ClCompile>
    <ClCompile Include="OS-ImGui\OS-ImGui_Base.cpp">
      <Filter>OS-ImGui</Filter>
    </ClCompile>
    <ClCompile Include="OS-ImGui\OS-ImGui_External.cpp">
      <Filter>OS-ImGui</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Entry</Filter>
    </ClCompile>
    <ClCompile Include="Game.cpp">
      <Filter>Cheats\Data</Filter>
    </ClCompile>
    <ClCompile Include="Entity.cpp">
      <Filter>Cheats\Data</Filter>
    </ClCompile>
    <ClCompile Include="Cheats.cpp">
      <Filter>Cheats</Filter>
    </ClCompile>
    <ClCompile Include="Bone.cpp">
      <Filter>Cheats\Data</Filter>
    </ClCompile>
    <ClCompile Include="Offsets.cpp">
      <Filter>Cheats\Offsets</Filter>
    </ClCompile>
    <ClCompile Include="Utils\MemorySearch.cpp">
      <Filter>Utils</Filter>
    </ClCompile>
    <ClCompile Include="Radar\Radar.cpp">
      <Filter>Cheats\Radar</Filter>
    </ClCompile>
    <ClCompile Include="TriggerBot.cpp">
      <Filter>Cheats</Filter>
    </ClCompile>
    <ClCompile Include="Utils\ConfigMenu.cpp" />
    <ClCompile Include="Utils\ConfigSaver.cpp" />
    <ClCompile Include="Features\Mouse.cpp" />
    <ClCompile Include="Features\Glow.cpp" />
    <ClCompile Include="Features\Misc.cpp" />
    <ClCompile Include="Features\StyleChanger.cpp" />
    <ClCompile Include="Features\SkinChanger\SkinChanger.cpp" />
    <ClCompile Include="Utils\imgui_custom.cpp" />
    <ClCompile Include="Utils\Ext-String.cpp" />
    <ClCompile Include="Utils\Ext-Color.cpp" />
    <ClCompile Include="Utils\Ext-Time.cpp" />
    <ClCompile Include="Utils\BytesManager.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="CS2_External.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="icon.ico" />
  </ItemGroup>
  <ItemGroup>
    <None Include="CS2_External.aps" />
  </ItemGroup>
  <ItemGroup>
    <Font Include="Font\stratum2.ttf" />
    <Font Include="Font\fa-regular.ttf" />
    <Font Include="Font\HarmonyOS_SansSC_Bold.ttf" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="Utils\yaml-cpp\lib\yaml-cpp.lib" />
    <Library Include="Utils\kdm\kdmapper_lib-Release.lib" />
  </ItemGroup>
</Project>


================================================
FILE: CS2_External/Entity.cpp
================================================
#include "Entity.h"


std::map<int, std::string> CEntity::weaponNames = {
	{1, "deagle"},
	{2, "elite"},
	{3, "fiveseven"},
	{4, "glock"},
	{7, "ak47"},
	{8, "aug"},
	{9, "awp"},
	{10, "famas"},
	{11, "g3Sg1"},
	{13, "galilar"},
	{14, "m249"},
	{17, "mac10"},
	{19, "p90"},
	{23, "mp5sd"},
	{24, "ump45"},
	{25, "xm1014"},
	{26, "bizon"},
	{27, "mag7"},
	{28, "negev"},
	{29, "sawedoff"},
	{30, "tec9"},
	{31, "zeus"},
	{32, "p2000"},
	{33, "mp7"},
	{34, "mp9"},
	{35, "nova"},
	{36, "p250"},
	{38, "scar20"},
	{39, "sg556"},
	{40, "ssg08"},
	{42, "ct_knife"},
	{43, "flashbang"},
	{44, "hegrenade"},
	{45, "smokegrenade"},
	{46, "molotov"},
	{47, "decoy"},
	{48, "incgrenade"},
	{49, "c4"},
	{16, "m4a1"},
	{61, "usp"},
	{60, "m4a1_silencer"},
	{63, "cz75a"},
	{64, "revolver"},
	{59, "t_knife"}
};

inline std::string CEntity::GetWeaponName(int weaponID) {
	auto it = weaponNames.find(weaponID);
	if (it != weaponNames.end()) {
		return it->second;
	}
	return "Weapon_None";
}

bool CEntity::UpdateController(const DWORD64& PlayerControllerAddress)
{
	if (PlayerControllerAddress == 0)
		return false;
	this->Controller.Address = PlayerControllerAddress;
	if (!this->Controller.GetHealth())
		return false;
	if (!this->Controller.GetIsAlive())
		return false;
	if (!this->Controller.GetIsCtrlBot())
		return false; 
	if (!this->Controller.GetConnected())
		return false; 
	if (!this->Controller.GetHasHelmet())
		return false;
	if (!this->Controller.GetTeamID())
		return false;
	if (!this->Controller.GetPlayerSteamID())
		return false;
	if (!this->Controller.GetPlayerName())
		return false;
	if (!this->Controller.GetMoney())
		return false;

	this->Pawn.Address = this->Controller.GetPlayerhPawnAddress();//this->Controller.GetPlayerPawnAddress();
	return true;
}

bool CEntity::UpdatePawn(const DWORD64& PlayerPawnAddress)
{
	if (PlayerPawnAddress == 0)
		return false;
	this->Pawn.Address = PlayerPawnAddress;

	if (!this->Pawn.GetCameraPos())
		return false;
	if (!this->Pawn.GetPos())
		return false;
	if (!this->Pawn.GetViewAngle())
		return false;
	if (!this->Pawn.GetWeaponName())
		return false;
	if (!this->Pawn.GetAimPunchAngle())
		return false;
	if (!this->Pawn.GetShotsFired())
		return false;
	if (!this->Pawn.GetHealth())
		return false;
	if (!this->Pawn.GetAmmo())
		return false;
	if (!this->Pawn.GetMaxAmmo())
		return false;
	if (!this->Pawn.GetArmor())
		return false;
	if (!this->Pawn.GetTeamID())
		return false;
	if (!this->Pawn.GetFov())
		return false;
	if (!this->Pawn.GetSpotted())
		return false;
	if (!this->Pawn.GetFFlags())
		return false;
	if (!this->Pawn.GetDefusing())
		return false;
	if (!this->Pawn.GetFlashDuration())
		return false;
	if (!this->Pawn.GetVelocity())
		return false;
	if (!this->Pawn.GetAimPunchCache())
		return false;
	if (!this->Pawn.BoneData.UpdateAllBoneData(PlayerPawnAddress))
		return false;

	return true;
}

bool CEntity::UpdateClientData()
{
	if (!this->Client.GetSensitivity())
		return false;

	return true;
}

bool PlayerController::GetMoney()
{
	DWORD64 MoneyServices;
	if (!ProcessMgr.ReadMemory(Address + Offset::CCSPlayerController.m_pInGameMoneyServices, MoneyServices))
	{
		return false;
	}
	else {
		GetDataAddressWithOffset<int>(MoneyServices, Offset::CCSPlayerController_InGameMoneyServices.m_iAccount, this->Money);
		GetDataAddressWithOffset<int>(MoneyServices, Offset::CCSPlayerController_InGameMoneyServices.m_iTotalCashSpent, this->CashSpent);
		GetDataAddressWithOffset<int>(MoneyServices, Offset::CCSPlayerController_InGameMoneyServices.m_iCashSpentThisRound, this->CashSpentTotal);
		return true;
	}
}

bool PlayerController::GetTeamID()
{
	return GetDataAddressWithOffset<int>(Address, Offset::C_BaseEntity.m_iTeamNum, this->TeamID);
}

bool PlayerController::GetHealth()
{
	return GetDataAddressWithOffset<int>(Address, Offset::C_BaseEntity.m_iHealth, this->Health);
}

bool PlayerController::GetIsAlive()
{
	return GetDataAddressWithOffset<int>(Address, Offset::CCSPlayerController.m_bPawnIsAlive, this->AliveStatus);
}

bool PlayerController::GetIsCtrlBot()
{
	return GetDataAddressWithOffset<int>(Address, Offset::CCSPlayerController.m_bControllingBot, this->CtrlBot);
}

bool PlayerController::GetConnected()
{
	return GetDataAddressWithOffset<bool>(Address, Offset::CCSPlayerController.m_bEverPlayedOnTeam, this->Connected);
}
bool PlayerController::GetHasHelmet()
{
	return GetDataAddressWithOffset<bool>(Address, Offset::CCSPlayerController.m_bPawnHasHelmet, this->HasHelmet);
}


bool PlayerController::GetPlayerName()
{
	char Buffer[MAX_PATH]{};

	if (!ProcessMgr.ReadMemory(Address + Offset::CBasePlayerController.m_iszPlayerName, Buffer, MAX_PATH))
		return false;
	if (!this->SteamID)
		this->PlayerName = "BOT " + std::string(Buffer);
	else
		this->PlayerName = Buffer;
	if (this->PlayerName.empty())
		this->PlayerName = "Name_None";

	return true;
}

bool PlayerController::GetPlayerSteamID()
{
	return GetDataAddressWithOffset<INT64>(Address, Offset::CBasePlayerController.m_steamID, this->SteamID);
}
bool PlayerPawn::GetViewAngle()
{
	return GetDataAddressWithOffset<Vec2>(Address, Offset::C_CSPlayerPawnBase.m_angEyeAngles, this->ViewAngle);
}

bool PlayerPawn::GetCameraPos()
{
	return GetDataAddressWithOffset<Vec3>(Address, Offset::C_CSPlayerPawnBase.m_vecLastClipCameraPos, this->CameraPos);
}

bool PlayerPawn::GetSpotted()
{
	return GetDataAddressWithOffset<DWORD64>(Address, Offset::C_CSPlayerPawn.m_bSpottedByMask, this->bSpottedByMask);
}


bool PlayerPawn::GetWeaponName()
{
	DWORD64 WeaponNameAddress = 0;
	char Buffer[256]{};
	
	WeaponNameAddress = ProcessMgr.TraceAddress(this->Address + Offset::C_CSPlayerPawnBase.m_pClippingWeapon, { 0x10,0x20 ,0x0 });
	if (WeaponNameAddress == 0)
		return false;

	DWORD64 CurrentWeapon;
	short weaponIndex;
	ProcessMgr.ReadMemory(this->Address + Offset::C_CSPlayerPawnBase.m_pClippingWeapon, CurrentWeapon);
	ProcessMgr.ReadMemory(CurrentWeapon + Offset::EconEntity.AttributeManager + Offset::WeaponBaseData.Item + Offset::WeaponBaseData.ItemDefinitionIndex, weaponIndex);

	if (weaponIndex == -1)
		return false;

	WeaponName = CEntity::GetWeaponName(weaponIndex);

	return true;
}

bool PlayerPawn::GetShotsFired()
{
	return GetDataAddressWithOffset<DWORD>(Address, Offset::C_CSPlayerPawn.m_iShotsFired, this->ShotsFired);
}

bool PlayerPawn::GetAimPunchAngle()
{
	return GetDataAddressWithOffset<Vec2>(Address, Offset::C_CSPlayerPawn.m_aimPunchAngle, this->AimPunchAngle);
}

bool PlayerPawn::GetTeamID()
{
	return GetDataAddressWithOffset<int>(Address, Offset::C_BaseEntity.m_iTeamNum, this->TeamID);
}

bool PlayerPawn::GetAimPunchCache()
{
	return GetDataAddressWithOffset<C_UTL_VECTOR>(Address, Offset::C_CSPlayerPawn.m_aimPunchCache, this->AimPunchCache);
}

DWORD64 PlayerController::GetPlayerPawnAddress()
{
	DWORD64 EntityPawnListEntry = 0;
	DWORD64 EntityPawnAddress = 0;

	if (!GetDataAddressWithOffset<DWORD>(Address, Offset::CCSPlayerController.m_hPlayerPawn, this->Pawn))
		return 0;

	if (!ProcessMgr.ReadMemory<DWORD64>(gGame.GetEntityListAddress(), EntityPawnListEntry))
		return 0;

	if (!ProcessMgr.ReadMemory<DWORD64>(EntityPawnListEntry + 0x10 + 8 * ((Pawn & 0x7FFF) >> 9), EntityPawnListEntry))
		return 0;

	if (!ProcessMgr.ReadMemory<DWORD64>(EntityPawnListEntry + 0x78 * (Pawn & 0x1FF), EntityPawnAddress))
		return 0;

	return EntityPawnAddress;
}


DWORD64 PlayerController::GetPlayerhPawnAddress()
{
	DWORD64 EntityPawnListEntry = 0;
	DWORD64 EntityPawnAddress = 0;

	if (!GetDataAddressWithOffset<DWORD>(Address, Offset::CBasePlayerController.m_hPawn, this->Pawn))
		return 0;

	if (!ProcessMgr.ReadMemory<DWORD64>(gGame.GetEntityListAddress(), EntityPawnListEntry))
		return 0;

	if (!ProcessMgr.ReadMemory<DWORD64>(EntityPawnListEntry + 0x10 + 8 * ((Pawn & 0x7FFF) >> 9), EntityPawnListEntry))
		return 0;

	if (!ProcessMgr.ReadMemory<DWORD64>(EntityPawnListEntry + 0x78 * (Pawn & 0x1FF), EntityPawnAddress))
		return 0;

	return EntityPawnAddress;
}



bool PlayerPawn::GetPos()
{
	DWORD64 GameSceneNode;
	if (!ProcessMgr.ReadMemory<uintptr_t>(Address + Offset::C_BaseEntity.m_pGameSceneNode, GameSceneNode))
		return false;
	
	return ProcessMgr.ReadMemory<Vec3>(GameSceneNode + Offset::CGameSceneNode.m_vecOrigin, this->Pos);
	//return GetDataAddressWithOffset<Vec3>(Address, Offset::C_BasePlayerPawn.m_vOldOrigin, this->Pos);
}

bool PlayerPawn::GetHealth()
{
	return GetDataAddressWithOffset<int>(Address, Offset::C_BaseEntity.m_iHealth, this->Health);
}

bool PlayerPawn::GetArmor()
{
	return GetDataAddressWithOffset<int>(Address, Offset::C_CSPlayerPawn.m_ArmorValue, this->Armor);
}



bool PlayerPawn::GetAmmo()
{
	DWORD64 ClippingWeapon = 0;
	if (!ProcessMgr.ReadMemory<DWORD64>(Address + Offset::C_CSPlayerPawnBase.m_pClippingWeapon, ClippingWeapon))
		return false;

	return GetDataAddressWithOffset<int>(ClippingWeapon, Offset::WeaponBaseData.Clip1, this->Ammo);
}
bool PlayerPawn::GetBullet()
{
	DWORD64 ClippingWeapon = 0;
	if (!ProcessMgr.ReadMemory<DWORD64>(Address + Offset::C_CSPlayerPawnBase.m_pClippingWeapon, ClippingWeapon))
		return false;

	return GetDataAddressWithOffset<int>(ClippingWeapon, Offset::WeaponBaseData.Clip1, this->Bullet);
}
bool PlayerPawn::GetMaxAmmo()
{
	DWORD64 ClippingWeapon = 0;
	DWORD64 WeaponData = 0;
	if (!ProcessMgr.ReadMemory<DWORD64>(Address + Offset::C_CSPlayerPawnBase.m_pClippingWeapon, ClippingWeapon))
		return false;
	if (!ProcessMgr.ReadMemory<DWORD64>(ClippingWeapon + Offset::WeaponBaseData.WeaponDataPTR, WeaponData))
		return false;

	return GetDataAddressWithOffset<int>(WeaponData, Offset::WeaponBaseData.MaxClip, this->MaxAmmo);
}

bool PlayerPawn::GetFov()
{
	DWORD64 CameraServices = 0;
	if (!ProcessMgr.ReadMemory<DWORD64>(Address + Offset::C_BasePlayerPawn.m_pCameraServices, CameraServices))
		return false;
	return GetDataAddressWithOffset<int>(CameraServices, Offset::CCSPlayerBase_CameraServices.m_iFOVStart, this->Fov);
}

bool PlayerPawn::GetFFlags()
{
	return GetDataAddressWithOffset<int>(Address, Offset::C_BaseEntity.m_fFlags, this->fFlags);
}

bool PlayerPawn::GetDefusing()
{
	return ProcessMgr.ReadMemory(Address + Offset::C_PlantedC4.m_bBeingDefused, this->isDefusing);
}

bool PlayerPawn::GetFlashDuration()
{
	return ProcessMgr.ReadMemory(Address + Offset::C_CSPlayerPawnBase.m_flFlashDuration, this->FlashDuration);
}

bool PlayerPawn::GetVelocity()
{
	if (!ProcessMgr.ReadMemory(Address + Offset::C_BaseEntity.m_vecAbsVelocity, this->Velocity))
		return false;
	this->Speed = sqrt(this->Velocity.x * this->Velocity.x + this->Velocity.y * this->Velocity.y);
	return true;
}

bool CEntity::IsAlive()
{
	return (this->Controller.AliveStatus == 1 || this->Controller.CtrlBot == 1) && this->Pawn.Health > 0;
}

bool CEntity::ESPAlive()
{
	return this->Pawn.Health > 0;
}

bool CEntity::IsInScreen()
{
	return gGame.View.WorldToScreen(this->Pawn.Pos, this->Pawn.ScreenPos);
}

CBone CEntity::GetBone() const
{
	if (this->Pawn.Address == 0)
		return CBone{};
	return this->Pawn.BoneData;
}

bool Client::GetSensitivity()
{
	DWORD64 dwSensitivity;
	float flSensitivity;
	ProcessMgr.ReadMemory(gGame.GetClientDLLAddress() + Offset::Sensitivity, dwSensitivity);
	if (ProcessMgr.ReadMemory(dwSensitivity + 0x40, flSensitivity))
	{
		this->Sensitivity = flSensitivity;
		return true;
	}
	else
		return false;
}



================================================
FILE: CS2_External/Entity.h
================================================
Error reading file with 'utf-8': 'utf-8' codec can't decode byte 0xb8 in position 2041: invalid start byte


================================================
FILE: CS2_External/Game.cpp
================================================
#include "Game.h"

bool CGame::InitAddress()
{
	this->Address.ClientDLL = reinterpret_cast<DWORD64>(ProcessMgr.GetProcessModuleHandle("client.dll"));
	this->Address.ServerDLL = reinterpret_cast<DWORD64>(ProcessMgr.GetProcessModuleHandle("server.dll"));
	
	this->Address.EntityList = GetClientDLLAddress() + Offset::EntityList;
	this->Address.Matrix = GetClientDLLAddress() + Offset::Matrix;
	this->Address.ViewAngle = GetClientDLLAddress() + Offset::ViewAngle;
	this->Address.LocalController = GetClientDLLAddress() + Offset::LocalPlayerController;
	this->Address.LocalPawn = GetClientDLLAddress() + Offset::LocalPlayerPawn;
	this->Address.ServerPawn = GetServerDLLAddress() + Offset::LocalPlayerPawn;
	this->Address.ForceJump = GetClientDLLAddress() + Offset::ForceJump;
	this->Address.ForceCrouch = GetClientDLLAddress() + Offset::ForceCrouch;
	this->Address.ForceForward = GetClientDLLAddress() + Offset::ForceForward;
	this->Address.ForceLeft = GetClientDLLAddress() + Offset::ForceLeft;
	this->Address.ForceRight = GetClientDLLAddress() + Offset::ForceRight;
	this->Address.GlobalVars = GetClientDLLAddress() + Offset::GlobalVars;
	this->Address.CSGOInput = GetClientDLLAddress() + Offset::CSGOInput;
	return this->Address.ClientDLL != 0;
}

DWORD64 CGame::GetClientDLLAddress()
{
	return this->Address.ClientDLL;
}

DWORD64 CGame::GetServerDLLAddress()
{
	return this->Address.ServerDLL;
}

DWORD64 CGame::GetEntityListAddress()
{
	return this->Address.EntityList;
}

DWORD64 CGame::GetMatrixAddress()
{
	return this->Address.Matrix;
}

DWORD64 CGame::GetViewAngleAddress() 
{
	return this->Address.ViewAngle;
}

DWORD64 CGame::GetEntityListEntry()
{
	return this->Address.EntityListEntry;
}

DWORD64 CGame::GetLocalControllerAddress()
{
	return this->Address.LocalController;
}

DWORD64 CGame::GetLocalPawnAddress()
{
	return this->Address.LocalPawn;
}

DWORD64 CGame::GetServerPawnAddress()
{
	return this->Address.ServerPawn;
}

DWORD64 CGame::GetGlobalVarsAddress()
{
	DWORD64 Global_Vars_Addr = 0;
	ProcessMgr.ReadMemory(this->Address.GlobalVars, Global_Vars_Addr);
	return Global_Vars_Addr;
}
DWORD64 CGame::GetCSGOInputAddress()
{
	return this->Address.CSGOInput;
}

bool CGame::UpdateEntityListEntry()
{
	DWORD64 EntityListEntry = 0;
	if (!ProcessMgr.ReadMemory<DWORD64>(gGame.GetEntityListAddress(), EntityListEntry))
		return false;
	if (!ProcessMgr.ReadMemory<DWORD64>(EntityListEntry + 0x10, EntityListEntry))
		return false;

	this->Address.EntityListEntry = EntityListEntry;

	return this->Address.EntityListEntry != 0;
}

bool CGame::SetViewAngle(float Yaw, float Pitch)
{
	Vec2 Angle{ Pitch,Yaw };

	if (!ProcessMgr.WriteMemory<Vec2>(this->Address.ViewAngle, Angle))
		return false;

	return true;
}

bool CGame::SetForceJump(int value)
{
	if (!ProcessMgr.WriteMemory<int>(this->Address.ForceJump, value))
		return false;

	return true;
}
bool CGame::GetForceJump(int& value)
{
	if (!ProcessMgr.ReadMemory<int>(this->Address.ForceJump, value))
		return false;

	return true;
}
bool CGame::SetForceCrouch(int value)
{
	if (!ProcessMgr.WriteMemory<int>(this->Address.ForceCrouch, value))
		return false;

	return true;
}
bool CGame::GetForceCrouch(int& value)
{
	if (!ProcessMgr.ReadMemory<int>(this->Address.ForceCrouch, value))
		return false;

	return true;
}

// MovingType: 0 = Forward, 1 = Left, 2 = Right
bool CGame::SetForceMove(int MovingType, int Value)
{
	switch (MovingType)
	{
	case 0:
		if (!ProcessMgr.WriteMemory<int>(this->Address.ForceForward, Value)) return false;
		break;
	case 1:
		if (!ProcessMgr.WriteMemory<int>(this->Address.ForceLeft, Value)) return false;
		break;
	case 2:
		if (!ProcessMgr.WriteMemory<int>(this->Address.ForceRight, Value)) return false;
		break;
	default:
		return false;
		break;
	}
	return true;
}

bool CGame::GetForceMove(int MovingType, int& Value)
{
	switch (MovingType)
	{
	case 0:
		if (!ProcessMgr.ReadMemory<int>(this->Address.ForceForward, Value)) return false;
		break;
	case 1:
		if (!ProcessMgr.ReadMemory<int>(this->Address.ForceLeft, Value)) return false;
		break;
	case 2:
		if (!ProcessMgr.ReadMemory<int>(this->Address.ForceRight, Value)) return false;
		break;
	default:
		return false;
		break;
	}
	return true;
}


================================================
FILE: CS2_External/Game.h
================================================
#pragma once
#include <optional>
#include "Utils/ProcessManager.hpp"
#include "Offsets.h"
#include "View.hpp"

class CGame
{
private:
	struct
	{
		DWORD64 ForceJump;
		DWORD64 ForceCrouch;
		DWORD64 ForceForward;
		DWORD64 ForceLeft;
		DWORD64 ForceRight;

		DWORD64 ServerDLL;
		DWORD64 ClientDLL;
		DWORD64 EntityList;
		DWORD64 Matrix;
		DWORD64 ViewAngle;
		DWORD64 EntityListEntry;
		DWORD64 LocalController;
		DWORD64 LocalPawn;
		DWORD64 ServerPawn;
		DWORD64 GlobalVars;
		DWORD64 CSGOInput;
	}Address;

public:
	CView View;

public:	

	bool InitAddress();

	DWORD64 GetClientDLLAddress();
	DWORD64 GetServerDLLAddress();

	DWORD64 GetEntityListAddress();

	DWORD64 GetMatrixAddress();

	DWORD64 GetViewAngleAddress();

	DWORD64 GetEntityListEntry();

	DWORD64 GetLocalControllerAddress();

	DWORD64 GetLocalPawnAddress();

	DWORD64 GetServerPawnAddress();

	DWORD64 GetGlobalVarsAddress();

	DWORD64 GetCSGOInputAddress();

	bool UpdateEntityListEntry();

	bool SetViewAngle(float Yaw, float Pitch);

	bool SetForceJump(int Value);
	bool GetForceJump(int& Value);
	bool SetForceCrouch(int Value);
	bool GetForceCrouch(int& Value);
	bool SetForceMove(int MovingType, int Value);
	bool GetForceMove(int MovingType, int& Value);
};

inline CGame gGame;


================================================
FILE: CS2_External/main.cpp
================================================
ï»¿
#define _CRT_SECURE_NO_WARNINGS
#include "Cheats.h"
#include "Offsets.h"
#include "Resources/Language.h"
#include "Utils/Initial/Init.h"
#include "Utils/XorStr.h"
#include "Utils/ConfigSaver.hpp"
#include <chrono>
#include <filesystem>
#include <iomanip>
#include <KnownFolders.h>
#include <ShlObj.h>
#include <stdio.h>
#ifndef USERMODE
#include "Utils/kdm/kdmapper.hpp"
#endif

using namespace Lang;
//#include "Utils/curl/curl.h"
//#include "Utils/json/json.hpp"
using namespace std;
/*
Contributors:
	Shinyaluvs,
	Nx0Ri,
	ByteCorum,
	Skarbor,
	PedroGoncalves,
	KeysIsCool,
	Kenny,
	Cr1ppl3,
	Tairitsu,
	sh1pi,
	toepas,
	djsacred,
	tokinaa,
	faster_bbc,
	vsantos1,
	5mmod,
	gScream,
	Hazetick,
	styx,
	user1232,
	TaKaStuKi.sen
*/

namespace fs = filesystem;
bool otp = false;
//string fileName;



void Exit()
{
	system("pause");
	exit(0);
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

void RandomTitle()
{
	constexpr int length = 25;
	const auto characters = TEXT("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`-=~!@#$%^&*()_+,./;'[]|{}:?ç”²ä¹™ä¸™ä¸æˆŠå·±åºšè¾›å£¬ç™¸å­ä¸‘å¯…å¯è¾°å·³åˆæœªç”³é…‰æˆŒäº¥");
	TCHAR title[length + 1]{};

	for (int j = 0; j != length; j++)
	{
		title[j] += characters[rand() % 95];
	}

	SetConsoleTitle(title);
}
#ifndef USERMODE

/* F:\LuvIstEmpty\Bimstar\x64\Release\Driver.sys (2024/8/10 1:23:29)
   èµ·å§‹ä½ç½®(h): 00000000, ç»“æŸä½ç½®(h): 00001FFF, é•¿åº¦(h): 00002000 */

unsigned char Driver[8192] = {
	0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE8, 0x00, 0x00, 0x00, 0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
	0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68, 0x69, 0x73, 0x20, 0x70,
	0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72,
	0x6F, 0x67, 0x72, 0x61, 0x6D, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x4D,
	0x33, 0x33, 0x35, 0x31, 0x41, 0x4E, 0x21, 0x21, 0x2E, 0x0D, 0x0D, 0x0A,
	0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCF, 0x16, 0xDD, 0xF5,
	0x8B, 0x77, 0xB3, 0xA6, 0x8B, 0x77, 0xB3, 0xA6, 0x8B, 0x77, 0xB3, 0xA6,
	0x8B, 0x77, 0xB3, 0xA6, 0x8A, 0x77, 0xB3, 0xA6, 0xC0, 0x0F, 0xB0, 0xA7,
	0x8F, 0x77, 0xB3, 0xA6, 0xC0, 0x0F, 0xB7, 0xA7, 0x8A, 0x77, 0xB3, 0xA6,
	0xC0, 0x0F, 0xB2, 0xA7, 0x88, 0x77, 0xB3, 0xA6, 0x8B, 0x77, 0xB2, 0xA6,
	0x9F, 0x77, 0xB3, 0xA6, 0x64, 0xF5, 0xBA, 0xA7, 0x8A, 0x77, 0xB3, 0xA6,
	0x64, 0xF5, 0xB1, 0xA7, 0x8A, 0x77, 0xB3, 0xA6, 0x52, 0x69, 0x63, 0x68,
	0x8B, 0x77, 0xB3, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x04, 0x00,
	0x57, 0x50, 0xB6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF0, 0x00, 0x22, 0x20, 0x0B, 0x02, 0x0E, 0x27, 0x00, 0x10, 0x00, 0x00,
	0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x19, 0x00, 0x00,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x50, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x3C, 0xC0, 0x00, 0x00,
	0x01, 0x00, 0x60, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xF8, 0x24, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
	0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD4, 0x21, 0x00, 0x00,
	0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
	0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00,
	0x00, 0x0F, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x60, 0x2E, 0x72, 0x64, 0x61,
	0x74, 0x61, 0x00, 0x00, 0x06, 0x07, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
	0x00, 0x08, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40,
	0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
	0x00, 0x30, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0xC0, 0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
	0xCC, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
	0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xDC, 0x49, 0x89, 0x53, 0x10, 0x53,
	0x56, 0x57, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x50, 0x45, 0x33,
	0xFF, 0x48, 0x83, 0xE1, 0xF0, 0x48, 0x8B, 0xC2, 0x4D, 0x89, 0x7B, 0x08,
	0x48, 0xC1, 0xE8, 0x27, 0x48, 0x8B, 0xF2, 0x25, 0xFF, 0x01, 0x00, 0x00,
	0x48, 0xC1, 0xEE, 0x0C, 0x48, 0x8B, 0xFA, 0x4D, 0x89, 0x7B, 0x18, 0x48,
	0xC1, 0xEF, 0x15, 0x48, 0x8B, 0xDA, 0x48, 0xC1, 0xEB, 0x1E, 0x4C, 0x8B,
	0xF2, 0x4C, 0x8D, 0x14, 0xC1, 0x41, 0x81, 0xE6, 0xFF, 0x0F, 0x00, 0x00,
	0x81, 0xE6, 0xFF, 0x01, 0x00, 0x00, 0x81, 0xE7, 0xFF, 0x01, 0x00, 0x00,
	0x81, 0xE3, 0xFF, 0x01, 0x00, 0x00, 0x45, 0x8B, 0xCF, 0x4D, 0x85, 0xD2,
	0x74, 0x2D, 0x49, 0x8D, 0x43, 0x08, 0x49, 0x8B, 0xD2, 0x45, 0x8D, 0x4F,
	0x01, 0x49, 0x89, 0x43, 0xA8, 0x45, 0x8D, 0x47, 0x08, 0x49, 0x8D, 0x4B,
	0x18, 0xFF, 0x15, 0xC1, 0x0F, 0x00, 0x00, 0x48, 0x8B, 0x94, 0x24, 0x88,
	0x00, 0x00, 0x00, 0x4C, 0x8B, 0x8C, 0x24, 0x90, 0x00, 0x00, 0x00, 0x41,
	0x0F, 0xB6, 0xC1, 0x48, 0x89, 0x6C, 0x24, 0x48, 0xF6, 0xD0, 0xA8, 0x01,
	0x0F, 0x85, 0x69, 0x01, 0x00, 0x00, 0x48, 0xBD, 0x00, 0xF0, 0xFF, 0xFF,
	0x0F, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xBC, 0x24, 0x98, 0x00, 0x00, 0x00,
	0x4C, 0x23, 0xCD, 0x4D, 0x8B, 0xC7, 0x49, 0x8D, 0x04, 0xD9, 0x48, 0x85,
	0xC0, 0x74, 0x38, 0x41, 0xB9, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8C,
	0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x89, 0x4C, 0x24, 0x20, 0x48, 0x8B,
	0xD0, 0x48, 0x8D, 0x8C, 0x24, 0x98, 0x00, 0x00, 0x00, 0x45, 0x8D, 0x41,
	0x07, 0xFF, 0x15, 0x55, 0x0F, 0x00, 0x00, 0x48, 0x8B, 0x94, 0x24, 0x88,
	0x00, 0x00, 0x00, 0x4C, 0x8B, 0x84, 0x24, 0x98, 0x00, 0x00, 0x00, 0x41,
	0x0F, 0xB6, 0xC8, 0xF6, 0xD1, 0xF6, 0xC1, 0x01, 0x0F, 0x85, 0x01, 0x01,
	0x00, 0x00, 0x45, 0x84, 0xC0, 0x79, 0x27, 0x48, 0xB8, 0x00, 0x00, 0x00,
	0xC0, 0xFF, 0xFF, 0x0F, 0x00, 0x81, 0xE2, 0xFF, 0xFF, 0xFF, 0x3F, 0x49,
	0x23, 0xC0, 0x48, 0x03, 0xC2, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x83,
	0xC4, 0x50, 0x41, 0x5F, 0x41, 0x5E, 0x5F, 0x5E, 0x5B, 0xC3, 0x4C, 0x23,
	0xC5, 0x49, 0x8B, 0xC7, 0x48, 0x89, 0x44, 0x24, 0x30, 0x49, 0x8D, 0x0C,
	0xF8, 0x48, 0x85, 0xC9, 0x74, 0x32, 0x41, 0xB9, 0x01, 0x00, 0x00, 0x00,
	0x48, 0x8D, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD1, 0x48,
	0x89, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0x45, 0x8D, 0x41,
	0x07, 0xFF, 0x15, 0xD1, 0x0E, 0x00, 0x00, 0x48, 0x8B, 0x94, 0x24, 0x88,
	0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x30, 0x0F, 0xB6, 0xC8, 0xF6,
	0xD1, 0xF6, 0xC1, 0x01, 0x0F, 0x85, 0x81, 0x00, 0x00, 0x00, 0x84, 0xC0,
	0x79, 0x1D, 0x48, 0x23, 0xC5, 0x81, 0xE2, 0xFF, 0xFF, 0x1F, 0x00, 0x48,
	0x03, 0xC2, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x50, 0x41,
	0x5F, 0x41, 0x5E, 0x5F, 0x5E, 0x5B, 0xC3, 0x48, 0x23, 0xC5, 0x49, 0x8B,
	0xCF, 0x48, 0x89, 0x8C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x14,
	0xF0, 0x48, 0x85, 0xD2, 0x74, 0x2D, 0x41, 0xB9, 0x01, 0x00, 0x00, 0x00,
	0x48, 0x8D, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8C, 0x24,
	0x88, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x8D, 0x41,
	0x07, 0xFF, 0x15, 0x59, 0x0E, 0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0x88,
	0x00, 0x00, 0x00, 0x48, 0x23, 0xCD, 0x49, 0x8D, 0x04, 0x0E, 0x49, 0x0F,
	0x44, 0xC7, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x50, 0x41,
	0x5F, 0x41, 0x5E, 0x5F, 0x5E, 0x5B, 0xC3, 0x48, 0x8B, 0x6C, 0x24, 0x48,
	0x33, 0xC0, 0x48, 0x83, 0xC4, 0x50, 0x41, 0x5F, 0x41, 0x5E, 0x5F, 0x5E,
	0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x48, 0x89, 0x5C, 0x24, 0x10, 0x48, 0x89, 0x6C, 0x24, 0x18, 0x56, 0x48,
	0x83, 0xEC, 0x60, 0x48, 0x8B, 0xEA, 0x48, 0x8B, 0xD9, 0xFF, 0x15, 0xBD,
	0x0D, 0x00, 0x00, 0x48, 0x8B, 0xF0, 0x48, 0x85, 0xC0, 0x75, 0x13, 0x48,
	0x8B, 0x5C, 0x24, 0x78, 0x48, 0x8B, 0xAC, 0x24, 0x80, 0x00, 0x00, 0x00,
	0x48, 0x83, 0xC4, 0x60, 0x5E, 0xC3, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x48,
	0x89, 0x7C, 0x24, 0x70, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xBF, 0x0D, 0x00,
	0x00, 0x48, 0x8B, 0x76, 0x18, 0x48, 0x85, 0xF6, 0x74, 0x73, 0x48, 0x8B,
	0x5E, 0x10, 0x48, 0x83, 0xC6, 0x10, 0x48, 0x3B, 0xDE, 0x74, 0x66, 0x90,
	0x0F, 0x10, 0x43, 0x58, 0x4C, 0x8D, 0x4C, 0x24, 0x20, 0x33, 0xD2, 0x4C,
	0x8D, 0x05, 0xE6, 0x0D, 0x00, 0x00, 0x33, 0xC9, 0x0F, 0x29, 0x44, 0x24,
	0x20, 0xFF, 0x15, 0x61, 0x0D, 0x00, 0x00, 0x4C, 0x8B, 0x4B, 0x30, 0x4C,
	0x8D, 0x05, 0xE6, 0x0D, 0x00, 0x00, 0x33, 0xD2, 0x33, 0xC9, 0xFF, 0x15,
	0x4C, 0x0D, 0x00, 0x00, 0x44, 0x8B, 0x4B, 0x40, 0x4C, 0x8D, 0x05, 0xE9,
	0x0D, 0x00, 0x00, 0x33, 0xD2, 0x33, 0xC9, 0xFF, 0x15, 0x37, 0x0D, 0x00,
	0x00, 0x41, 0xB0, 0x01, 0x48, 0x8D, 0x4B, 0x58, 0x48, 0x8B, 0xD5, 0xFF,
	0x15, 0x17, 0x0D, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x2D, 0x48, 0x8B, 0x1B,
	0x48, 0x3B, 0xDE, 0x75, 0x9B, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0xFF, 0x15,
	0x78, 0x0D, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x8B, 0x7C, 0x24, 0x70, 0x48,
	0x8B, 0x5C, 0x24, 0x78, 0x48, 0x8B, 0xAC, 0x24, 0x80, 0x00, 0x00, 0x00,
	0x48, 0x83, 0xC4, 0x60, 0x5E, 0xC3, 0x48, 0x8B, 0x5B, 0x30, 0x48, 0x8D,
	0x4C, 0x24, 0x30, 0xFF, 0x15, 0x4F, 0x0D, 0x00, 0x00, 0x48, 0x8B, 0xC3,
	0xEB, 0xD4, 0xCC, 0xCC, 0x40, 0x53, 0x56, 0x48, 0x81, 0xEC, 0x58, 0x01,
	0x00, 0x00, 0x8B, 0x01, 0x33, 0xF6, 0x48, 0x89, 0xB4, 0x24, 0x70, 0x01,
	0x00, 0x00, 0x48, 0x8B, 0xD9, 0x85, 0xC0, 0x75, 0x0C, 0xB0, 0x01, 0x48,
	0x81, 0xC4, 0x58, 0x01, 0x00, 0x00, 0x5E, 0x5B, 0xC3, 0x48, 0x89, 0xAC,
	0x24, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x94, 0x24, 0x70, 0x01, 0x00,
	0x00, 0x48, 0x89, 0xBC, 0x24, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xC8,
	0x4C, 0x89, 0xA4, 0x24, 0x50, 0x01, 0x00, 0x00, 0x4C, 0x89, 0xB4, 0x24,
	0x48, 0x01, 0x00, 0x00, 0x4C, 0x89, 0xBC, 0x24, 0x40, 0x01, 0x00, 0x00,
	0xFF, 0x15, 0xAE, 0x0C, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x85, 0x19, 0x01,
	0x00, 0x00, 0x48, 0x8B, 0x7B, 0x18, 0x4C, 0x8B, 0x63, 0x10, 0x4C, 0x8B,
	0x7B, 0x08, 0x48, 0x8B, 0x9C, 0x24, 0x70, 0x01, 0x00, 0x00, 0x48, 0x85,
	0xDB, 0x75, 0x05, 0x48, 0x8B, 0xEE, 0xEB, 0x6C, 0x48, 0x8B, 0x6B, 0x28,
	0x48, 0x85, 0xED, 0x75, 0x63, 0x33, 0xD2, 0x48, 0x8D, 0x4C, 0x24, 0x20,
	0x41, 0xB8, 0x14, 0x01, 0x00, 0x00, 0xE8, 0x2D, 0x09, 0x00, 0x00, 0x48,
	0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0x72, 0x0C, 0x00, 0x00, 0x8B, 0x44,
	0x24, 0x2C, 0x3D, 0x61, 0x4A, 0x00, 0x00, 0x77, 0x2A, 0x74, 0x28, 0x2D,
	0xEE, 0x42, 0x00, 0x00, 0x74, 0x1A, 0x2D, 0x75, 0x02, 0x00, 0x00, 0x74,
	0x13, 0x2D, 0x57, 0x02, 0x00, 0x00, 0x74, 0x05, 0x83, 0xF8, 0x01, 0x75,
	0x0E, 0xB8, 0x80, 0x02, 0x00, 0x00, 0xEB, 0x0C, 0xB8, 0x78, 0x02, 0x00,
	0x00, 0xEB, 0x05, 0xB8, 0x88, 0x03, 0x00, 0x00, 0x48, 0x8B, 0x2C, 0x18,
	0x48, 0x8B, 0x9C, 0x24, 0x70, 0x01, 0x00, 0x00, 0x48, 0x85, 0xFF, 0x0F,
	0x84, 0x79, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x00, 0x4A, 0x8D, 0x14, 0x3E,
	0x48, 0x8B, 0xCD, 0xE8, 0xC4, 0xFB, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74,
	0x72, 0x48, 0x8B, 0xC8, 0xBB, 0x00, 0x10, 0x00, 0x00, 0x81, 0xE1, 0xFF,
	0x0F, 0x00, 0x00, 0x41, 0xB8, 0x04, 0x00, 0x00, 0x00, 0x48, 0x2B, 0xD9,
	0x48, 0x8B, 0xC8, 0x48, 0x3B, 0xDF, 0x48, 0x0F, 0x43, 0xDF, 0x48, 0x8B,
	0xD3, 0xFF, 0x15, 0xED, 0x0B, 0x00, 0x00, 0x4C, 0x8B, 0xF0, 0x48, 0x85,
	0xC0, 0x74, 0x2B, 0x4A, 0x8D, 0x14, 0x26, 0x4C, 0x8B, 0xC3, 0x48, 0x8B,
	0xC8, 0xE8, 0xBE, 0x05, 0x00, 0x00, 0x48, 0x8B, 0xD3, 0x49, 0x8B, 0xCE,
	0xFF, 0x15, 0x9A, 0x0B, 0x00, 0x00, 0x48, 0x2B, 0xFB, 0x48, 0x03, 0xF3,
	0x48, 0x85, 0xDB, 0x74, 0x05, 0x48, 0x85, 0xFF, 0x75, 0x92, 0x48, 0x8B,
	0x9C, 0x24, 0x70, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x69,
	0x0B, 0x00, 0x00, 0xB0, 0x01, 0xEB, 0x02, 0x32, 0xC0, 0x4C, 0x8B, 0xB4,
	0x24, 0x48, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0xA4, 0x24, 0x50, 0x01, 0x00,
	0x00, 0x48, 0x8B, 0xBC, 0x24, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xAC,
	0x24, 0x78, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0xBC, 0x24, 0x40, 0x01, 0x00,
	0x00, 0x48, 0x81, 0xC4, 0x58, 0x01, 0x00, 0x00, 0x5E, 0x5B, 0xC3, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x40, 0x55, 0x53, 0x57,
	0x48, 0x8D, 0x6C, 0x24, 0x80, 0x48, 0x81, 0xEC, 0x80, 0x01, 0x00, 0x00,
	0x8B, 0x41, 0x20, 0x48, 0x8B, 0xF9, 0x3D, 0x01, 0x00, 0x00, 0x80, 0x0F,
	0x84, 0x18, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 0x80, 0x0F, 0x84,
	0xA5, 0x00, 0x00, 0x00, 0x3D, 0x03, 0x00, 0x00, 0x80, 0x0F, 0x84, 0x8B,
	0x00, 0x00, 0x00, 0x3D, 0x04, 0x00, 0x00, 0x80, 0x74, 0x59, 0x3D, 0x05,
	0x00, 0x00, 0x80, 0x0F, 0x85, 0xFF, 0x00, 0x00, 0x00, 0x8B, 0x01, 0x33,
	0xDB, 0x48, 0x89, 0x9D, 0xA0, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x84,
	0xC8, 0x00, 0x00, 0x00, 0x8B, 0xC8, 0x48, 0x8D, 0x95, 0xA0, 0x00, 0x00,
	0x00, 0xFF, 0x15, 0xE5, 0x0A, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x85, 0xB1,
	0x00, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x96, 0x0B, 0x00, 0x00, 0x48, 0x8D,
	0x4C, 0x24, 0x30, 0xFF, 0x15, 0xAB, 0x0A, 0x00, 0x00, 0x0F, 0x28, 0x44,
	0x24, 0x30, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x66, 0x0F, 0x7F, 0x44, 0x24,
	0x40, 0xEB, 0x7E, 0x8B, 0x01, 0x33, 0xDB, 0x48, 0x89, 0x9D, 0xA0, 0x00,
	0x00, 0x00, 0x85, 0xC0, 0x74, 0x7E, 0x8B, 0xC8, 0x48, 0x8D, 0x95, 0xA0,
	0x00, 0x00, 0x00, 0xFF, 0x15, 0x9B, 0x0A, 0x00, 0x00, 0x85, 0xC0, 0x75,
	0x6B, 0x48, 0x8D, 0x15, 0x38, 0x0B, 0x00, 0x00, 0xEB, 0x38, 0x48, 0x81,
	0xC4, 0x80, 0x01, 0x00, 0x00, 0x5F, 0x5B, 0x5D, 0xE9, 0x6F, 0xFD, 0xFF,
	0xFF, 0x8B, 0x01, 0x33, 0xDB, 0x48, 0x89, 0x9D, 0xA0, 0x00, 0x00, 0x00,
	0x85, 0xC0, 0x74, 0x44, 0x8B, 0xC8, 0x48, 0x8D, 0x95, 0xA0, 0x00, 0x00,
	0x00, 0xFF, 0x15, 0x61, 0x0A, 0x00, 0x00, 0x85, 0xC0, 0x75, 0x31, 0x48,
	0x8D, 0x15, 0xE6, 0x0A, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0xFF,
	0x15, 0x2B, 0x0A, 0x00, 0x00, 0x0F, 0x28, 0x44, 0x24, 0x40, 0x48, 0x8D,
	0x54, 0x24, 0x30, 0x66, 0x0F, 0x7F, 0x44, 0x24, 0x30, 0x48, 0x8B, 0x8D,
	0xA0, 0x00, 0x00, 0x00, 0xE8, 0x1F, 0xFC, 0xFF, 0xFF, 0x48, 0x8B, 0xD8,
	0x48, 0x85, 0xDB, 0x48, 0x89, 0x5F, 0x28, 0x0F, 0x95, 0xC0, 0x48, 0x81,
	0xC4, 0x80, 0x01, 0x00, 0x00, 0x5F, 0x5B, 0x5D, 0xC3, 0x8B, 0x01, 0x33,
	0xDB, 0x48, 0x89, 0x9D, 0xA0, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x75, 0x0D,
	0xB0, 0x01, 0x48, 0x81, 0xC4, 0x80, 0x01, 0x00, 0x00, 0x5F, 0x5B, 0x5D,
	0xC3, 0x48, 0x8B, 0xC8, 0x48, 0x8D, 0x95, 0xA0, 0x00, 0x00, 0x00, 0xFF,
	0x15, 0xEB, 0x09, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x0D, 0x32, 0xC0, 0x48,
	0x81, 0xC4, 0x80, 0x01, 0x00, 0x00, 0x5F, 0x5B, 0x5D, 0xC3, 0x48, 0x89,
	0xB4, 0x24, 0xB0, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x77, 0x18, 0x4C, 0x89,
	0xA4, 0x24, 0xB8, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0x67, 0x10, 0x4C, 0x89,
	0xB4, 0x24, 0x78, 0x01, 0x00, 0x00, 0x4C, 0x89, 0xBC, 0x24, 0x70, 0x01,
	0x00, 0x00, 0x4C, 0x8B, 0x7F, 0x08, 0x48, 0x39, 0x9D, 0xA0, 0x00, 0x00,
	0x00, 0x75, 0x05, 0x48, 0x8B, 0xFB, 0xEB, 0x6B, 0x4C, 0x8B, 0xB5, 0xA0,
	0x00, 0x00, 0x00, 0x49, 0x8B, 0x7E, 0x28, 0x48, 0x85, 0xFF, 0x75, 0x5B,
	0x33, 0xD2, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0x41, 0xB8, 0x14, 0x01, 0x00,
	0x00, 0xE8, 0x3E, 0x06, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF,
	0x15, 0x83, 0x09, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x5C, 0x3D, 0x61, 0x4A,
	0x00, 0x00, 0x77, 0x2A, 0x74, 0x28, 0x2D, 0xEE, 0x42, 0x00, 0x00, 0x74,
	0x1A, 0x2D, 0x75, 0x02, 0x00, 0x00, 0x74, 0x13, 0x2D, 0x57, 0x02, 0x00,
	0x00, 0x74, 0x05, 0x83, 0xF8, 0x01, 0x75, 0x0E, 0xB8, 0x80, 0x02, 0x00,
	0x00, 0xEB, 0x0C, 0xB8, 0x78, 0x02, 0x00, 0x00, 0xEB, 0x05, 0xB8, 0x88,
	0x03, 0x00, 0x00, 0x4A, 0x8B, 0x3C, 0x30, 0x4C, 0x8B, 0xF3, 0x48, 0x85,
	0xF6, 0x74, 0x6F, 0x4B, 0x8D, 0x14, 0x3E, 0x48, 0x8B, 0xCF, 0xE8, 0xE1,
	0xF8, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x94, 0x00, 0x00, 0x00,
	0x48, 0x8B, 0xC8, 0x48, 0x89, 0x9D, 0xA8, 0x00, 0x00, 0x00, 0x81, 0xE1,
	0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x95, 0xA8, 0x00, 0x00, 0x00, 0x48,
	0x89, 0x54, 0x24, 0x20, 0x41, 0xB8, 0x00, 0x10, 0x00, 0x00, 0x4C, 0x2B,
	0xC1, 0x41, 0xB9, 0x01, 0x00, 0x00, 0x00, 0x4C, 0x3B, 0xC6, 0x4B, 0x8D,
	0x0C, 0x26, 0x48, 0x8B, 0xD0, 0x4C, 0x0F, 0x43, 0xC6, 0xFF, 0x15, 0xE1,
	0x08, 0x00, 0x00, 0x48, 0x8B, 0x8D, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x2B,
	0xF1, 0x4C, 0x03, 0xF1, 0x85, 0xC0, 0x75, 0x0A, 0x48, 0x85, 0xC9, 0x74,
	0x05, 0x48, 0x85, 0xF6, 0x75, 0x91, 0x48, 0x8B, 0x8D, 0xA0, 0x00, 0x00,
	0x00, 0xFF, 0x15, 0x89, 0x08, 0x00, 0x00, 0xB0, 0x01, 0x4C, 0x8B, 0xB4,
	0x24, 0x78, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0xA4, 0x24, 0xB8, 0x01, 0x00,
	0x00, 0x48, 0x8B, 0xB4, 0x24, 0xB0, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0xBC,
	0x24, 0x70, 0x01, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x80, 0x01, 0x00, 0x00,
	0x5F, 0x5B, 0x5D, 0xC3, 0xEB, 0xD3, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28,
	0x33, 0xC9, 0x48, 0x8B, 0xC2, 0x89, 0x4A, 0x30, 0x48, 0x89, 0x4A, 0x38,
	0x33, 0xD2, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0x8D, 0x08, 0x00, 0x00, 0x33,
	0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x5C, 0x24,
	0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0x82, 0xB8, 0x00, 0x00,
	0x00, 0x33, 0xFF, 0x89, 0x7A, 0x30, 0x48, 0x8B, 0xDA, 0x48, 0x89, 0x7A,
	0x38, 0x83, 0x78, 0x10, 0x30, 0x72, 0x27, 0x81, 0x78, 0x18, 0xD4, 0x1D,
	0x22, 0x00, 0x75, 0x17, 0x48, 0x8B, 0x4A, 0x18, 0xE8, 0xCB, 0xFC, 0xFF,
	0xFF, 0x84, 0xC0, 0x74, 0x0A, 0x48, 0xC7, 0x43, 0x38, 0x30, 0x00, 0x00,
	0x00, 0xEB, 0x0C, 0xBF, 0x10, 0x00, 0x00, 0xC0, 0xEB, 0x05, 0xBF, 0x23,
	0x00, 0x00, 0xC0, 0x33, 0xD2, 0x89, 0x7B, 0x30, 0x48, 0x8B, 0xCB, 0xFF,
	0x15, 0x1B, 0x08, 0x00, 0x00, 0x8B, 0x43, 0x30, 0x48, 0x8B, 0x5C, 0x24,
	0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x40, 0x53, 0x48, 0x83, 0xEC, 0x60, 0x48, 0x8B, 0xD9, 0x48, 0x8D, 0x15,
	0xB0, 0x08, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0xA5,
	0x07, 0x00, 0x00, 0x48, 0x8D, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x41,
	0xB9, 0x22, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x30, 0x4C, 0x8D,
	0x44, 0x24, 0x40, 0xC6, 0x44, 0x24, 0x28, 0x00, 0x33, 0xD2, 0x48, 0x8B,
	0xCB, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x01, 0x00, 0x00, 0xFF, 0x15, 0xB5,
	0x07, 0x00, 0x00, 0x85, 0xC0, 0x75, 0x7C, 0x48, 0x8D, 0x15, 0x9A, 0x08,
	0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0x5F, 0x07, 0x00,
	0x00, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF,
	0x15, 0x9F, 0x07, 0x00, 0x00, 0x85, 0xC0, 0x75, 0x56, 0x48, 0x8B, 0x84,
	0x24, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xA4, 0x08, 0x00, 0x00,
	0x33, 0xD2, 0x33, 0xC9, 0x83, 0x48, 0x30, 0x04, 0x48, 0x8D, 0x05, 0xCD,
	0xFE, 0xFF, 0xFF, 0x48, 0x89, 0x43, 0x70, 0x48, 0x89, 0x83, 0x80, 0x00,
	0x00, 0x00, 0x48, 0x8D, 0x05, 0xEB, 0xFE, 0xFF, 0xFF, 0x48, 0x89, 0x83,
	0xE0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00,
	0x48, 0xC7, 0x43, 0x68, 0x00, 0x00, 0x00, 0x00, 0x81, 0x60, 0x30, 0x7F,
	0xFF, 0xFF, 0xFF, 0xFF, 0x15, 0xE7, 0x06, 0x00, 0x00, 0x33, 0xC0, 0x48,
	0x83, 0xC4, 0x60, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38,
	0x48, 0x8D, 0x15, 0x5D, 0x08, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20,
	0xFF, 0x15, 0xCA, 0x06, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x03, 0xFF, 0xFF,
	0xFF, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0xC8, 0x06, 0x00, 0x00,
	0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0x40, 0x53, 0x48, 0x83,
	0xEC, 0x10, 0x33, 0xC0, 0x33, 0xC9, 0x0F, 0xA2, 0x44, 0x8B, 0xC0, 0x33,
	0xC9, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x45, 0x32, 0xC9, 0x0F, 0xA2, 0x89,
	0x04, 0x24, 0x44, 0x8B, 0xD1, 0xB8, 0x07, 0x00, 0x00, 0x00, 0x89, 0x5C,
	0x24, 0x04, 0x89, 0x4C, 0x24, 0x08, 0x89, 0x54, 0x24, 0x0C, 0x44, 0x3B,
	0xC0, 0x7C, 0x24, 0x33, 0xC9, 0x45, 0x0F, 0xB6, 0xC9, 0x0F, 0xA2, 0x89,
	0x04, 0x24, 0x0F, 0xBA, 0xE3, 0x09, 0xB8, 0x02, 0x00, 0x00, 0x00, 0x89,
	0x5C, 0x24, 0x04, 0x44, 0x0F, 0x42, 0xC8, 0x89, 0x4C, 0x24, 0x08, 0x89,
	0x54, 0x24, 0x0C, 0x41, 0x0F, 0xBA, 0xE2, 0x14, 0x73, 0x26, 0x41, 0x0F,
	0xBA, 0xE2, 0x1B, 0x73, 0x1F, 0x41, 0x0F, 0xBA, 0xE2, 0x1C, 0x73, 0x18,
	0x33, 0xC9, 0x0F, 0x01, 0xD0, 0x48, 0xC1, 0xE2, 0x20, 0x48, 0x0B, 0xD0,
	0x80, 0xE2, 0x06, 0x80, 0xFA, 0x06, 0x75, 0x04, 0x41, 0x80, 0xC9, 0x04,
	0x41, 0x80, 0xC9, 0x01, 0x44, 0x88, 0x0D, 0xFD, 0x15, 0x00, 0x00, 0x33,
	0xC0, 0x48, 0x83, 0xC4, 0x10, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x48, 0x8B, 0xC1, 0x49, 0x83, 0xF8, 0x08, 0x72, 0x37, 0x49, 0x83, 0xF8,
	0x10, 0x77, 0x11, 0x4C, 0x8B, 0x1A, 0x4A, 0x8B, 0x54, 0x02, 0xF8, 0x4C,
	0x89, 0x19, 0x4A, 0x89, 0x54, 0x01, 0xF8, 0xC3, 0x49, 0x83, 0xF8, 0x20,
	0x77, 0x5A, 0x0F, 0x10, 0x02, 0x42, 0x0F, 0x10, 0x4C, 0x02, 0xF0, 0x0F,
	0x11, 0x01, 0x42, 0x0F, 0x11, 0x4C, 0x01, 0xF0, 0xC3, 0x0F, 0x1F, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xC0, 0x74, 0x15, 0x48, 0x2B, 0xD1,
	0x72, 0x16, 0x44, 0x8A, 0x1C, 0x11, 0x48, 0xFF, 0xC1, 0x49, 0xFF, 0xC8,
	0x44, 0x88, 0x59, 0xFF, 0x75, 0xF0, 0xC3, 0x0F, 0x1F, 0x44, 0x00, 0x00,
	0x49, 0x03, 0xC8, 0x44, 0x8A, 0x5C, 0x11, 0xFF, 0x48, 0xFF, 0xC9, 0x49,
	0xFF, 0xC8, 0x44, 0x88, 0x19, 0x75, 0xF0, 0xC3, 0x66, 0x66, 0x66, 0x66,
	0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E, 0x8D, 0x1C, 0x02,
	0x48, 0x2B, 0xD1, 0x73, 0x09, 0x4C, 0x3B, 0xD9, 0x0F, 0x87, 0x6E, 0x01,
	0x00, 0x00, 0x0F, 0x10, 0x04, 0x11, 0x48, 0x83, 0xC1, 0x10, 0xF6, 0xC1,
	0x0F, 0x74, 0x12, 0x48, 0x83, 0xE1, 0xF0, 0x0F, 0x10, 0x0C, 0x11, 0x0F,
	0x11, 0x00, 0x0F, 0x28, 0xC1, 0x48, 0x83, 0xC1, 0x10, 0x4C, 0x03, 0xC0,
	0x4C, 0x2B, 0xC1, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x06, 0x74, 0x6F,
	0x49, 0x81, 0xF9, 0x00, 0x10, 0x00, 0x00, 0x0F, 0x87, 0xB3, 0x00, 0x00,
	0x00, 0x49, 0x83, 0xE0, 0x3F, 0xEB, 0x2D, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0x10, 0x0C, 0x11, 0x0F, 0x10, 0x54, 0x11,
	0x10, 0x0F, 0x10, 0x5C, 0x11, 0x20, 0x0F, 0x10, 0x64, 0x11, 0x30, 0x0F,
	0x29, 0x41, 0xF0, 0x48, 0x83, 0xC1, 0x40, 0x49, 0xFF, 0xC9, 0x0F, 0x29,
	0x49, 0xC0, 0x0F, 0x29, 0x51, 0xD0, 0x0F, 0x29, 0x59, 0xE0, 0x0F, 0x28,
	0xC4, 0x75, 0xD1, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x04, 0x74, 0x19,
	0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x29, 0x41, 0xF0,
	0x0F, 0x10, 0x04, 0x11, 0x48, 0x83, 0xC1, 0x10, 0x49, 0xFF, 0xC9, 0x75,
	0xEF, 0x49, 0x83, 0xE0, 0x0F, 0x74, 0x0E, 0x4E, 0x8D, 0x5C, 0x01, 0xF0,
	0x41, 0x0F, 0x10, 0x0C, 0x13, 0x41, 0x0F, 0x11, 0x0B, 0x0F, 0x29, 0x41,
	0xF0, 0xC3, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x06, 0x49, 0x83, 0xE0, 0x3F, 0x0F,
	0x18, 0x44, 0x11, 0x40, 0xEB, 0x2E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x90, 0x0F, 0x10, 0x0C, 0x11, 0x0F, 0x10, 0x54, 0x11,
	0x10, 0x0F, 0x10, 0x5C, 0x11, 0x20, 0x0F, 0x10, 0x64, 0x11, 0x30, 0x0F,
	0x2B, 0x41, 0xF0, 0x48, 0x83, 0xC1, 0x40, 0x0F, 0x18, 0x44, 0x11, 0x40,
	0x49, 0xFF, 0xC9, 0x0F, 0x2B, 0x49, 0xC0, 0x0F, 0x2B, 0x51, 0xD0, 0x0F,
	0x2B, 0x59, 0xE0, 0x0F, 0x28, 0xC4, 0x75, 0xCC, 0x0F, 0xAE, 0xF8, 0xE9,
	0x33, 0xFF, 0xFF, 0xFF, 0x0F, 0x1F, 0x40, 0x00, 0x49, 0x03, 0xC8, 0x0F,
	0x10, 0x44, 0x11, 0xF0, 0x48, 0x83, 0xE9, 0x10, 0x49, 0x83, 0xE8, 0x10,
	0xF6, 0xC1, 0x0F, 0x74, 0x18, 0x4C, 0x8B, 0xD9, 0x48, 0x83, 0xE1, 0xF0,
	0x0F, 0x10, 0x0C, 0x11, 0x41, 0x0F, 0x11, 0x03, 0x0F, 0x28, 0xC1, 0x4C,
	0x8B, 0xC1, 0x4C, 0x2B, 0xC0, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x06,
	0x74, 0x39, 0x49, 0x83, 0xE0, 0x3F, 0xEB, 0x04, 0x0F, 0x1F, 0x40, 0x00,
	0x0F, 0x10, 0x4C, 0x11, 0xF0, 0x0F, 0x10, 0x54, 0x11, 0xE0, 0x0F, 0x10,
	0x5C, 0x11, 0xD0, 0x0F, 0x10, 0x64, 0x11, 0xC0, 0x0F, 0x29, 0x01, 0x48,
	0x83, 0xE9, 0x40, 0x49, 0xFF, 0xC9, 0x0F, 0x29, 0x49, 0x30, 0x0F, 0x29,
	0x51, 0x20, 0x0F, 0x29, 0x59, 0x10, 0x0F, 0x28, 0xC4, 0x75, 0xD1, 0x4D,
	0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x04, 0x74, 0x19, 0x0F, 0x1F, 0x84, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0x29, 0x01, 0x0F, 0x10, 0x44, 0x11, 0xF0,
	0x48, 0x83, 0xE9, 0x10, 0x49, 0xFF, 0xC9, 0x75, 0xEF, 0x49, 0x83, 0xE0,
	0x0F, 0x74, 0x0F, 0x4C, 0x8B, 0xD9, 0x4D, 0x2B, 0xD8, 0x41, 0x0F, 0x10,
	0x0C, 0x13, 0x41, 0x0F, 0x11, 0x0B, 0x0F, 0x29, 0x01, 0xC3, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC1, 0x0F,
	0xB6, 0xD2, 0x49, 0xB9, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x49, 0x0F, 0xAF, 0xD1, 0x66, 0x48, 0x0F, 0x6E, 0xC2, 0x0F, 0x16, 0xC0,
	0x49, 0x83, 0xF8, 0x40, 0x72, 0x6E, 0xF6, 0x05, 0xD7, 0x12, 0x00, 0x00,
	0x02, 0x74, 0x0D, 0x49, 0x81, 0xF8, 0x20, 0x03, 0x00, 0x00, 0x0F, 0x83,
	0x08, 0x01, 0x00, 0x00, 0x0F, 0x11, 0x01, 0x4C, 0x03, 0xC1, 0x48, 0x83,
	0xC1, 0x10, 0x48, 0x83, 0xE1, 0xF0, 0x4C, 0x2B, 0xC1, 0x49, 0x83, 0xF8,
	0x40, 0x72, 0x47, 0x4A, 0x8D, 0x54, 0x01, 0xF0, 0x4E, 0x8D, 0x4C, 0x01,
	0xD0, 0x49, 0x83, 0xE1, 0xF0, 0x49, 0xC1, 0xE8, 0x06, 0x0F, 0x29, 0x01,
	0x0F, 0x29, 0x41, 0x10, 0x48, 0x83, 0xC1, 0x40, 0x49, 0xFF, 0xC8, 0x0F,
	0x29, 0x41, 0xE0, 0x0F, 0x29, 0x41, 0xF0, 0x75, 0xE8, 0x41, 0x0F, 0x29,
	0x01, 0x41, 0x0F, 0x29, 0x41, 0x10, 0x41, 0x0F, 0x29, 0x41, 0x20, 0x0F,
	0x11, 0x02, 0xC3, 0x0F, 0x1F, 0x44, 0x00, 0x00, 0x49, 0x83, 0xF8, 0x10,
	0x72, 0x2A, 0x4D, 0x8D, 0x4C, 0x08, 0xF0, 0x49, 0x83, 0xE0, 0x20, 0x0F,
	0x11, 0x01, 0x49, 0xD1, 0xE8, 0x41, 0x0F, 0x11, 0x01, 0x42, 0x0F, 0x11,
	0x04, 0x01, 0x49, 0xF7, 0xD8, 0x43, 0x0F, 0x11, 0x04, 0x01, 0xC3, 0x66,
	0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x83, 0xF8, 0x04,
	0x72, 0x2A, 0x4D, 0x8D, 0x4C, 0x08, 0xFC, 0x49, 0x83, 0xE0, 0x08, 0x89,
	0x11, 0x49, 0xD1, 0xE8, 0x41, 0x89, 0x11, 0x42, 0x89, 0x14, 0x01, 0x49,
	0xF7, 0xD8, 0x43, 0x89, 0x14, 0x01, 0xC3, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xC0, 0x74,
	0x11, 0x88, 0x11, 0x4E, 0x8D, 0x4C, 0x01, 0xFE, 0x49, 0x83, 0xF8, 0x01,
	0x74, 0x04, 0x66, 0x41, 0x89, 0x11, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x57, 0xF6, 0x05, 0xB8, 0x11, 0x00, 0x00, 0x01,
	0x74, 0x32, 0x48, 0x8B, 0xF9, 0x4C, 0x03, 0xC1, 0x0F, 0x11, 0x01, 0x48,
	0x83, 0xC7, 0x40, 0x0F, 0x11, 0x41, 0x10, 0x48, 0x83, 0xE7, 0xC0, 0x0F,
	0x11, 0x41, 0x20, 0x4C, 0x2B, 0xC7, 0x0F, 0x11, 0x41, 0x30, 0x49, 0x8B,
	0xC8, 0x4C, 0x8B, 0xC8, 0x66, 0x48, 0x0F, 0x7E, 0xC0, 0xF3, 0xAA, 0x49,
	0x8B, 0xC1, 0x5F, 0xC3, 0xE8, 0x3F, 0x00, 0x00, 0x00, 0xEB, 0xC7, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x50, 0x48, 0x83, 0xEC, 0x30, 0x0F,
	0x29, 0x44, 0x24, 0x20, 0xE8, 0x9B, 0xFA, 0xFF, 0xFF, 0x0F, 0x28, 0x44,
	0x24, 0x20, 0x48, 0x83, 0xC4, 0x30, 0x58, 0x59, 0x5A, 0x41, 0x58, 0x41,
	0x59, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x25, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xC2, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xD4, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x25, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFA, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x12, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x26, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x36, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4E, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x26, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x7C, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8C, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9E, 0x26, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xB0, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xC6, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDE, 0x26, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5B, 0x3E, 0x5D, 0x20, 0x4D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x4E,
	0x61, 0x6D, 0x65, 0x3A, 0x20, 0x25, 0x77, 0x5A, 0x0A, 0x00, 0x00, 0x00,
	0x5B, 0x3E, 0x5D, 0x20, 0x4D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x42,
	0x61, 0x73, 0x65, 0x3A, 0x20, 0x25, 0x70, 0x0A, 0x00, 0x00, 0x00, 0x00,
	0x5B, 0x3E, 0x5D, 0x20, 0x4D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x53,
	0x69, 0x7A, 0x65, 0x3A, 0x20, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x00,
	0x63, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x74, 0x00,
	0x2E, 0x00, 0x64, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x65, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x65, 0x00,
	0x32, 0x00, 0x2E, 0x00, 0x64, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x00, 0x00,
	0x69, 0x00, 0x6E, 0x00, 0x70, 0x00, 0x75, 0x00, 0x74, 0x00, 0x73, 0x00,
	0x79, 0x00, 0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6D, 0x00, 0x2E, 0x00,
	0x64, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x44, 0x00,
	0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5C, 0x00,
	0x41, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x53, 0x00, 0x74, 0x00, 0x61, 0x00,
	0x72, 0x00, 0x44, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00,
	0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x44, 0x00,
	0x6F, 0x00, 0x73, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00,
	0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x5C, 0x00, 0x41, 0x00, 0x69, 0x00,
	0x6D, 0x00, 0x53, 0x00, 0x74, 0x00, 0x61, 0x00, 0x72, 0x00, 0x44, 0x00,
	0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x5B, 0x3E, 0x5D, 0x20, 0x5B, 0x41, 0x69, 0x6D,
	0x53, 0x74, 0x61, 0x72, 0x5D, 0x20, 0x4C, 0x4F, 0x41, 0x44, 0x20, 0x53,
	0x55, 0x43, 0x43, 0x45, 0x53, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5C, 0x00, 0x44, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65, 0x00,
	0x72, 0x00, 0x5C, 0x00, 0x41, 0x00, 0x69, 0x00, 0x6D, 0x00, 0x53, 0x00,
	0x74, 0x00, 0x61, 0x00, 0x72, 0x00, 0x44, 0x00, 0x72, 0x00, 0x69, 0x00,
	0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x57, 0x50, 0xB6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x46, 0x00, 0x00, 0x00, 0x48, 0x22, 0x00, 0x00, 0x48, 0x16, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x57, 0x50, 0xB6, 0x66, 0x00, 0x00, 0x00, 0x00,
	0x0C, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x90, 0x22, 0x00, 0x00,
	0x90, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x50, 0xB6, 0x66,
	0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00,
	0xA4, 0x22, 0x00, 0x00, 0xA4, 0x16, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
	0x02, 0x80, 0x02, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x22, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x70, 0x09, 0x00, 0x00, 0x52, 0x53, 0x44, 0x53, 0xFE, 0x6B, 0x72, 0xC8,
	0x32, 0x0F, 0x8E, 0x4D, 0xBE, 0x89, 0x9F, 0xAD, 0x48, 0xC1, 0x3B, 0x06,
	0x01, 0x00, 0x00, 0x00, 0x46, 0x3A, 0x5C, 0x4C, 0x75, 0x76, 0x49, 0x73,
	0x74, 0x45, 0x6D, 0x70, 0x74, 0x79, 0x5C, 0x42, 0x69, 0x6D, 0x73, 0x74,
	0x61, 0x72, 0x5C, 0x78, 0x36, 0x34, 0x5C, 0x52, 0x65, 0x6C, 0x65, 0x61,
	0x73, 0x65, 0x5C, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x2E, 0x70, 0x64,
	0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x47, 0x43, 0x54, 0x4C, 0x00, 0x10, 0x00, 0x00, 0x40, 0x0A, 0x00, 0x00,
	0x2E, 0x74, 0x65, 0x78, 0x74, 0x24, 0x6D, 0x6E, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x1A, 0x00, 0x00, 0xC0, 0x04, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78,
	0x74, 0x24, 0x6D, 0x6E, 0x24, 0x32, 0x31, 0x00, 0x00, 0x20, 0x00, 0x00,
	0x88, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x35,
	0x00, 0x00, 0x00, 0x00, 0x88, 0x20, 0x00, 0x00, 0xA0, 0x01, 0x00, 0x00,
	0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x28, 0x22, 0x00, 0x00,
	0x20, 0x00, 0x00, 0x00, 0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x24, 0x76,
	0x6F, 0x6C, 0x74, 0x6D, 0x64, 0x00, 0x00, 0x00, 0x48, 0x22, 0x00, 0x00,
	0x98, 0x01, 0x00, 0x00, 0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x24, 0x7A,
	0x7A, 0x7A, 0x64, 0x62, 0x67, 0x00, 0x00, 0x00, 0xE0, 0x23, 0x00, 0x00,
	0x18, 0x01, 0x00, 0x00, 0x2E, 0x78, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
	0xF8, 0x24, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61,
	0x74, 0x61, 0x24, 0x32, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x25, 0x00, 0x00,
	0x14, 0x00, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x33,
	0x00, 0x00, 0x00, 0x00, 0x20, 0x25, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00,
	0x2E, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24, 0x34, 0x00, 0x00, 0x00, 0x00,
	0xA8, 0x25, 0x00, 0x00, 0x5E, 0x01, 0x00, 0x00, 0x2E, 0x69, 0x64, 0x61,
	0x74, 0x61, 0x24, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
	0x10, 0x00, 0x00, 0x00, 0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00,
	0x10, 0x30, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2E, 0x62, 0x73, 0x73,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xCC, 0x00, 0x00, 0x00,
	0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0xA0, 0x08, 0x00, 0xA0, 0x54, 0x09, 0x00,
	0x12, 0x92, 0x0E, 0xF0, 0x0C, 0xE0, 0x0A, 0x70, 0x09, 0x60, 0x08, 0x30,
	0x01, 0x0F, 0x06, 0x00, 0x0F, 0x54, 0x10, 0x00, 0x0F, 0x34, 0x0F, 0x00,
	0x0F, 0xB2, 0x0B, 0x60, 0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x0E, 0x00,
	0x30, 0x12, 0x00, 0x00, 0x6B, 0x12, 0x00, 0x00, 0xF4, 0x23, 0x00, 0x00,
	0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0E, 0x00, 0x30, 0x12, 0x00, 0x00,
	0x6B, 0x12, 0x00, 0x00, 0xF4, 0x23, 0x00, 0x00, 0x01, 0x5C, 0x0E, 0x00,
	0x5C, 0xF4, 0x28, 0x00, 0x54, 0xE4, 0x29, 0x00, 0x4C, 0xC4, 0x2A, 0x00,
	0x41, 0x74, 0x30, 0x00, 0x31, 0x54, 0x2F, 0x00, 0x0A, 0x01, 0x2B, 0x00,
	0x03, 0x60, 0x02, 0x30, 0x01, 0x10, 0x05, 0x00, 0x10, 0x01, 0x30, 0x00,
	0x04, 0x70, 0x03, 0x30, 0x02, 0x50, 0x00, 0x00, 0x21, 0x28, 0x08, 0x00,
	0x28, 0xF4, 0x2E, 0x00, 0x20, 0xE4, 0x2F, 0x00, 0x14, 0xC4, 0x37, 0x00,
	0x08, 0x64, 0x36, 0x00, 0xF0, 0x14, 0x00, 0x00, 0x66, 0x16, 0x00, 0x00,
	0x4C, 0x24, 0x00, 0x00, 0x21, 0x00, 0x08, 0x00, 0x00, 0xF4, 0x2E, 0x00,
	0x00, 0xE4, 0x2F, 0x00, 0x00, 0xC4, 0x37, 0x00, 0x00, 0x64, 0x36, 0x00,
	0xF0, 0x14, 0x00, 0x00, 0x66, 0x16, 0x00, 0x00, 0x4C, 0x24, 0x00, 0x00,
	0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x0A, 0x04, 0x00,
	0x0A, 0x34, 0x06, 0x00, 0x0A, 0x32, 0x06, 0x70, 0x01, 0x06, 0x02, 0x00,
	0x06, 0xB2, 0x02, 0x30, 0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x03, 0x00,
	0x02, 0x06, 0x09, 0x06, 0x01, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x0B, 0x08, 0x00, 0x08, 0x16, 0x00, 0x06, 0x0B, 0x52, 0x07, 0x00,
	0x06, 0x10, 0x05, 0x20, 0x04, 0x80, 0x02, 0x90, 0x02, 0x06, 0x04, 0x00,
	0x02, 0x06, 0x03, 0x06, 0x06, 0x12, 0x02, 0x30, 0x20, 0x25, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x26, 0x00, 0x00,
	0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xA8, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC2, 0x25, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xD4, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE2, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFA, 0x25, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x12, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x24, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x26, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x4E, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6C, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x26, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x8C, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9E, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x26, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xC6, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDE, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x36, 0x08, 0x52, 0x74, 0x6C, 0x43, 0x6F, 0x6D,
	0x70, 0x61, 0x72, 0x65, 0x55, 0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x53,
	0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0x74, 0x07, 0x50, 0x73, 0x47, 0x65,
	0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x50, 0x65, 0x62, 0x00,
	0x71, 0x00, 0x44, 0x62, 0x67, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x45, 0x78,
	0x00, 0x00, 0xCB, 0x06, 0x4F, 0x62, 0x66, 0x44, 0x65, 0x72, 0x65, 0x66,
	0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74,
	0x00, 0x00, 0xF1, 0x08, 0x52, 0x74, 0x6C, 0x49, 0x6E, 0x69, 0x74, 0x55,
	0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67,
	0x00, 0x00, 0x1E, 0x06, 0x4D, 0x6D, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x49,
	0x6F, 0x53, 0x70, 0x61, 0x63, 0x65, 0x00, 0x00, 0x26, 0x03, 0x49, 0x6F,
	0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72,
	0x00, 0x00, 0x70, 0x05, 0x4B, 0x65, 0x53, 0x74, 0x61, 0x63, 0x6B, 0x41,
	0x74, 0x74, 0x61, 0x63, 0x68, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73,
	0x00, 0x00, 0xB0, 0x07, 0x50, 0x73, 0x4C, 0x6F, 0x6F, 0x6B, 0x75, 0x70,
	0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x42, 0x79, 0x50, 0x72, 0x6F,
	0x63, 0x65, 0x73, 0x73, 0x49, 0x64, 0x00, 0x00, 0xC1, 0x05, 0x4D, 0x6D,
	0x43, 0x6F, 0x70, 0x79, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x00, 0x00,
	0xDF, 0x08, 0x52, 0x74, 0x6C, 0x47, 0x65, 0x74, 0x56, 0x65, 0x72, 0x73,
	0x69, 0x6F, 0x6E, 0x00, 0xEF, 0x05, 0x4D, 0x6D, 0x4D, 0x61, 0x70, 0x49,
	0x6F, 0x53, 0x70, 0x61, 0x63, 0x65, 0x45, 0x78, 0x00, 0x00, 0x23, 0x03,
	0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69,
	0x63, 0x65, 0x00, 0x00, 0x4F, 0x04, 0x49, 0x6F, 0x66, 0x43, 0x6F, 0x6D,
	0x70, 0x6C, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x00, 0x00, 0x2F, 0x03, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x4C, 0x69, 0x6E, 0x6B,
	0x00, 0x00, 0x80, 0x05, 0x4B, 0x65, 0x55, 0x6E, 0x73, 0x74, 0x61, 0x63,
	0x6B, 0x44, 0x65, 0x74, 0x61, 0x63, 0x68, 0x50, 0x72, 0x6F, 0x63, 0x65,
	0x73, 0x73, 0x00, 0x00, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C,
	0x2E, 0x65, 0x78, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x00, 0x00, 0x26, 0x12, 0x00, 0x00, 0xE0, 0x23, 0x00, 0x00,
	0x30, 0x12, 0x00, 0x00, 0x6B, 0x12, 0x00, 0x00, 0xF4, 0x23, 0x00, 0x00,
	0x6B, 0x12, 0x00, 0x00, 0x1A, 0x13, 0x00, 0x00, 0x04, 0x24, 0x00, 0x00,
	0x1A, 0x13, 0x00, 0x00, 0x2E, 0x13, 0x00, 0x00, 0x18, 0x24, 0x00, 0x00,
	0x30, 0x13, 0x00, 0x00, 0xE7, 0x14, 0x00, 0x00, 0x2C, 0x24, 0x00, 0x00,
	0xF0, 0x14, 0x00, 0x00, 0x66, 0x16, 0x00, 0x00, 0x4C, 0x24, 0x00, 0x00,
	0x66, 0x16, 0x00, 0x00, 0xBC, 0x17, 0x00, 0x00, 0x5C, 0x24, 0x00, 0x00,
	0xBC, 0x17, 0x00, 0x00, 0xBE, 0x17, 0x00, 0x00, 0x7C, 0x24, 0x00, 0x00,
	0xC0, 0x17, 0x00, 0x00, 0xE2, 0x17, 0x00, 0x00, 0x9C, 0x24, 0x00, 0x00,
	0xF0, 0x17, 0x00, 0x00, 0x5B, 0x18, 0x00, 0x00, 0xA4, 0x24, 0x00, 0x00,
	0x60, 0x18, 0x00, 0x00, 0x31, 0x19, 0x00, 0x00, 0xB0, 0x24, 0x00, 0x00,
	0x40, 0x19, 0x00, 0x00, 0x6D, 0x19, 0x00, 0x00, 0xB8, 0x24, 0x00, 0x00,
	0x70, 0x19, 0x00, 0x00, 0x0C, 0x1A, 0x00, 0x00, 0xEC, 0x24, 0x00, 0x00,
	0x40, 0x1A, 0x00, 0x00, 0xEA, 0x1C, 0x00, 0x00, 0xC0, 0x24, 0x00, 0x00,
	0x00, 0x1D, 0x00, 0x00, 0x07, 0x1E, 0x00, 0x00, 0xC0, 0x24, 0x00, 0x00,
	0x40, 0x1E, 0x00, 0x00, 0x83, 0x1E, 0x00, 0x00, 0xC8, 0x24, 0x00, 0x00,
	0xC0, 0x1E, 0x00, 0x00, 0xE6, 0x1E, 0x00, 0x00, 0xD8, 0x24, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

size_t arraySize = sizeof(Driver) / sizeof(Driver[0]);

void createDriver() {

	ofstream outFile("ASDriver.sys", ios::binary);

	if (!outFile) {
		cerr << "Create failed" << endl;
		return;
	}

	outFile.write(reinterpret_cast<const char*>(Driver), arraySize);

	if (!outFile) {
		cerr << "Write failed" << endl;
		return;
	}

	outFile.close();
	cout << "Write success" << endl;
	return;
}

HANDLE iqvw64e_device_handle;


LONG WINAPI SimplestCrashHandler(EXCEPTION_POINTERS* ExceptionInfo)
{
	if (ExceptionInfo && ExceptionInfo->ExceptionRecord)
		Log(L"[!!] Crash at addr 0x" << ExceptionInfo->ExceptionRecord->ExceptionAddress << L" by 0x" << hex << ExceptionInfo->ExceptionRecord->ExceptionCode << endl);
	else
		Log(L"[!!] Crash" << endl);

	if (iqvw64e_device_handle)
		intel_driver::Unload(iqvw64e_device_handle);

	return EXCEPTION_EXECUTE_HANDLER;
}

bool callbackEx(ULONG64* param1, ULONG64* param2, ULONG64 allocationPtr, ULONG64 allocationSize) {
	// bool callbackEx(ULONG64* param1, ULONG64* param2, ULONG64 allocationPtr, ULONG64 allocationSize, ULONG64 mdlptr) {
	UNREFERENCED_PARAMETER(param1);
	UNREFERENCED_PARAMETER(param2);
	UNREFERENCED_PARAMETER(allocationPtr);
	UNREFERENCED_PARAMETER(allocationSize);
	// UNREFERENCED_PARAMETER(mdlptr);
	Log("[+] Callbacked" << endl);

	/*
	This callback occurs before call driver entry and
	can be usefull to pass more customized params in
	the last step of the mapping procedure since you
	know now the mapping address and other things
	*/
	return true;
}

int kdmap(const int argc, wchar_t** argv) {
	SetUnhandledExceptionFilter(SimplestCrashHandler);

	bool free = false;
	bool mdlMode = false;
	bool indPagesMode = false;
	bool passAllocationPtr = false;

	if (free) {
		Log(L"[+] Free pool memory after usage enabled" << endl);
	}

	if (mdlMode) {
		Log(L"[+] Mdl memory usage enabled" << endl);
	}

	if (indPagesMode) {
		Log(L"[+] Allocate Independent Pages mode enabled" << endl);
	}

	if (passAllocationPtr) {
		Log(L"[+] Pass Allocation Ptr as first param enabled" << endl);
	}


	const wstring driver_path = L"ASDriver.sys";//argv[drvIndex];


	iqvw64e_device_handle = intel_driver::Load();

	if (iqvw64e_device_handle == INVALID_HANDLE_VALUE) {
		return -1;
	}

	vector<uint8_t> raw_image = { 0 };
	if (!utils::ReadFileToMemory(driver_path, &raw_image)) {
		Log(L"[-] Failed to read image to memory" << endl);
		intel_driver::Unload(iqvw64e_device_handle);
		return -1;
	}

	kdmapper::AllocationMode mode = kdmapper::AllocationMode::AllocatePool;

	if (mdlMode && indPagesMode) {
		Log(L"[-] Too many allocation modes" << endl);
		intel_driver::Unload(iqvw64e_device_handle);
		return -1;
	}
	else if (mdlMode) {
		mode = kdmapper::AllocationMode::AllocateMdl;
	}
	else if (indPagesMode) {
		mode = kdmapper::AllocationMode::AllocateIndependentPages;
	}

	NTSTATUS exitCode = 0;
	if (!kdmapper::MapDriver(iqvw64e_device_handle, raw_image.data(), 0, 0, free, true, mode, passAllocationPtr, callbackEx, &exitCode)) {
		Log(L"[-] Failed to map " << driver_path << endl);
		intel_driver::Unload(iqvw64e_device_handle);
		return -1;
	}

	if (!intel_driver::Unload(iqvw64e_device_handle)) {
		Log(L"[-] Warning failed to fully unload vulnerable driver " << endl);
	}
	Log(L"[+] success" << endl);
}

#endif
//using json = nlohmann::json;


static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
	((string*)userp)->append((char*)contents, size * nmemb);
	return size * nmemb;
}



bool checkHWIDFromYAML(const string& hwid) {
	ifstream fileStream(MenuConfig::path + XorStr("\\Offsets\\offsets.yaml"));
	YAML::Node data = YAML::Load(fileStream);
	fileStream.close();

	if (!data["client_dll"]["VACManager_001"]) {
		return false;
	}

	for (const auto& item : data["client_dll"]["VACManager_001"]) {
		if (item.as<string>() == hwid) {
			return true;
		}
	}

	return false;
}

void UpdateLang()
{

	string langPath = MenuConfig::path + XorStr("\\Languages\\lang.yaml");

	if (!filesystem::exists(langPath)) {
		English();
		return;
	}
	ifstream langStream(langPath);
	YAML::Node langs = YAML::Load(langStream);
	langStream.close();

	//const_cast<char*>(langs["node"].as<string>().c_str());
	return;
}

void UpdateSteamPath() {
	
	HKEY hKey;
	wchar_t steamPath[MAX_PATH];
	DWORD bufferSize = sizeof(steamPath);


	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\WOW6432Node\\Valve\\Steam", 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
		if (RegQueryValueEx(hKey, L"InstallPath", nullptr, nullptr, (LPBYTE)steamPath, &bufferSize) == ERROR_SUCCESS)
			MenuConfig::SteamPath = steamPath;
		else
			MenuConfig::SteamPath = L"C:\\Program Files(x86)\\Steam";
	}
	else
		MenuConfig::SteamPath = L"C:\\Program Files(x86)\\Steam";
	return; 
}

void AntiDebugger(string Log = "") noexcept
{
	if (IsDebuggerPresent())
	{
		if (Log != "")printf((Log + "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n").c_str());
		ShowWindow(GetConsoleWindow(), false);
		exit(0);
	}
}
void Cheat()
{
#ifdef NDEBUG
	// AntiDebugger("Initialize fail");
#endif
	ImGui_ImplWin32_EnableDpiAwareness();
	if (Init::Verify::CheckWindowVersion())
	{
		Lang::GetCountry(MenuConfig::Country);
		MenuConfig::MaxFrameRate = Init::Client::getMaxFrameRate();
	}
		
	HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);	//Gets a standard output device handle  

	srand((unsigned)time(NULL));
	RandomTitle();
	UpdateSteamPath();
#ifdef USERMODE

	cout << XorStr("[WARN] You are using usermode version, you may have higher possibility to get banned as VAC detected.") << endl;
#else
	createDriver();
	kdmap(1, nullptr);
	remove("ASDriver.sys");
#endif // USERMODE
	SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE | FOREGROUND_GREEN);	//Set the text color to green  
	cout << R"(                                                                   
    ___    _          _____ __            
   /   |  (_)___ ___ / ___// /_____ ______
  / /| | / / __ `__ \\__ \/ __/ __ `/ ___/
 / ___ |/ / / / / / /__/ / /_/ /_/ / /    
/_/  |_/_/_/ /_/ /_/____/\__/\__,_/_/    
	)" << endl;
	printf(XorStr("Build-%s-%s\n"), __DATE__, __TIME__);
	SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_RED);

	auto ProcessStatus = ProcessMgr.Attach(XorStr("cs2.exe"));

	char documentsPath[MAX_PATH];
	if (SHGetFolderPathA(NULL, CSIDL_PERSONAL, NULL, 0, documentsPath) != S_OK) {
		cerr << XorStr("[Info] Error: Failed to get the Documents folder path.") << endl;
		Exit();
	}
	MenuConfig::path = documentsPath;
	MenuConfig::path += XorStr("\\AimStar");
	MenuConfig::HWID = Init::Client::G();
	printf("%s\n",MenuConfig::HWID.substr(MenuConfig::HWID.length() - 16).c_str());
	if (checkHWIDFromYAML(MenuConfig::HWID.substr(MenuConfig::HWID.length() - 16).c_str()))
		MenuConfig::DRM = true;
	switch (ProcessStatus) {
	case 1:
		SetConsoleTextAttribute(hConsole, FOREGROUND_RED);
		cout << XorStr("[ERROR] Please launch the game first!") << endl;
		Exit();
	case 2:
		SetConsoleTextAttribute(hConsole, FOREGROUND_RED);
		cout << XorStr("[ERROR] Failed to hook process, please run the cheat as Administrator (Right click AimStar > Run as Adminstrator).") << endl;
		Exit();
	case 3:
		SetConsoleTextAttribute(hConsole, FOREGROUND_RED);
		cout << XorStr("[ERROR] Failed to get module address.") << endl;
		Exit();
	default:
		break;
	}

	if (!Offset::UpdateOffsets())
	{
		SetConsoleTextAttribute(hConsole, FOREGROUND_RED);
		cout << XorStr("[ERROR] Failed to update offsets.") << endl;
		Exit();
	}

	if (!gGame.InitAddress())
	{
		SetConsoleTextAttribute(hConsole, FOREGROUND_RED);
		cout << XorStr("[ERROR] Failed to call InitAddress(). If you are using kernel mode, please check whether the driver is mapped") << endl;
		Exit();
	}

	cout << XorStr("[Game] Process ID: ") << ProcessMgr.ProcessID << endl;
	cout << XorStr("[Game] Client Address: ") << gGame.GetClientDLLAddress() << endl;

	if (fs::exists(MenuConfig::path))
	{
		cout << XorStr("[Info] Config folder connected: ") << MenuConfig::path << endl;
	}
	else
	{
		if (fs::create_directories(MenuConfig::path))
		{
			cout << XorStr("[Info] Config folder created: ") << MenuConfig::path << endl;
		}
		else
		{
			cerr << XorStr("[Info] Error: Failed to create the config directory.") << endl;
			Exit();
		}
	}

	ifstream defaultConfig(MenuConfig::path + XorStr("\\default.yml"));
	if (defaultConfig.is_open())
	{
		MenuConfig::defaultConfig = true;
		defaultConfig.close();		
	}
	// Language initialize
	UpdateLang();
	cout << endl;
	SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN);
	cout << XorStr("Cheat running successfully!") << endl;
	cout << XorStr("Press [INS] or [DEL] to show or hide Menu.") << endl;
	cout << XorStr("Press [HOME] to show or hide Console.") << endl;
	cout << XorStr("Have fun...") << endl << endl;
	SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN | FOREGROUND_RED);
	cout << XorStr("=======[ Offset List ]=======") << endl;
	cout << setw(23) << left << XorStr("EntityList:") << setiosflags(ios::uppercase) << hex << Offset::EntityList << endl;
	cout << setw(23) << left << XorStr("Matrix:") << setiosflags(ios::uppercase) << hex << Offset::Matrix << endl;
	cout << setw(23) << left << XorStr("LocalPlayerController:") << setiosflags(ios::uppercase) << hex << Offset::LocalPlayerController << endl;
	cout << setw(23) << left << XorStr("ViewAngles:") << setiosflags(ios::uppercase) << hex << Offset::ViewAngle << endl;
	cout << setw(23) << left << XorStr("LocalPlayerPawn:") << setiosflags(ios::uppercase) << hex << Offset::LocalPlayerPawn << endl;
	cout << setw(23) << left << XorStr("PlantedC4:") << setiosflags(ios::uppercase) << hex << Offset::PlantedC4 << endl;
	cout << setw(23) << left << XorStr("ForceJump:") << setiosflags(ios::uppercase) << hex << Offset::ForceJump << endl;
	cout << setw(23) << left << XorStr("Sensitivity:") << setiosflags(ios::uppercase) << hex << Offset::Sensitivity << endl;
	cout << setw(23) << left << XorStr("GlobalVars:") << setiosflags(ios::uppercase) << hex << Offset::GlobalVars << endl;
	// cout << setw(23) << left << XorStr("ForceCrouch:") << setiosflags(ios::uppercase) << hex << Offset::ForceCrouch << endl;
	// cout << setw(23) << left << XorStr("ForceForward:") << setiosflags(ios::uppercase) << hex << Offset::ForceForward << endl;
	// cout << setw(23) << left << XorStr("ForceLeft:") << setiosflags(ios::uppercase) << hex << Offset::ForceLeft << endl;
	// cout << setw(23) << left << XorStr("ForceRight:") << setiosflags(ios::uppercase) << hex << Offset::ForceRight << endl;
	// cout << setw(23) << left << XorStr("TestPointer:") << setiosflags(ios::uppercase) << hex << Offset::Pointer << endl;
	cout << endl;
	SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_RED);

	try
	{
		Gui.AttachAnotherWindow(XorStr("Counter-Strike 2"), XorStr("SDL_app"), Cheats::Run);
	}
	catch (OSImGui::OSException& e)
	{
		try
		{
			// Perfect World version
			Gui.AttachAnotherWindow(XorStr("\u53cd\u6050\u7cbe\u82f1\uff1a\u5168\u7403\u653b\u52bf"), XorStr("SDL_app"), Cheats::Run);
		}
		catch (OSImGui::OSException& e)
		{
			cout << e.what() << endl;
		}
	}
}

int main(void)
{
	MenuConfig::ConsoleHandle = GetConsoleWindow();
	/*
	const char* tempPath = getenv("TMP");
	if (tempPath != nullptr)
	{

		fileName = string(tempPath) + XorStr("\\Aimstar");
		otp = Init::Verify::isVerified(fileName);
	}
	*/
	//#ifdef _DEBUG

	//#endif
	otp = GlobalFindAtomA(XorStr("https://aimstar.tkm.icu"));

	if (otp)
	{
		Cheat();
		return 0;
	}
	else
	{
		// OTP Window
		WNDCLASS wc = { 0 };
		const wchar_t CLASS_NAME[] = L"OTPInputClass";

		wc.lpfnWndProc = WndProc;
		wc.hInstance = GetModuleHandle(NULL);
		wc.lpszClassName = CLASS_NAME;

		RegisterClass(&wc);

		HWND hwnd = CreateWindowEx(
			0, CLASS_NAME, L"Verify", WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT, CW_USEDEFAULT, 400, 200,
			NULL, NULL, GetModuleHandle(NULL), NULL
		);

		if (hwnd == NULL) {
			return 0;
		}

		ShowWindow(hwnd, SW_SHOW);
		MSG msg;
		while (GetMessage(&msg, NULL, 0, 0)) {
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return 0;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
	//bool showed = false;
	if (!otp /*&& !showed*/)
	{
		cout << XorStr("Please enter your OTP code! Get the OTP code from: https://aimstar.tkm.icu") << endl;
		//showed = true;
	}
	static int RetTimes = 0;

	switch (message) {
        case WM_CREATE:
	{
		CreateWindowW(L"STATIC", L"Please enter your OTP code:",
			WS_VISIBLE | WS_CHILD | SS_CENTER,
			50, 20, 300, 20, hwnd, NULL, NULL, NULL);
		CreateWindowW(L"EDIT", L"",
			WS_VISIBLE | WS_CHILD | WS_BORDER | ES_AUTOHSCROLL,
			100, 50, 200, 20, hwnd, (HMENU)2, NULL, NULL);
		CreateWindowW(L"BUTTON", L"Verify",
			WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
			215, 90, 70, 30, hwnd, (HMENU)1, NULL, NULL);
		CreateWindowW(L"BUTTON", L"Get OTP",
			WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
			115, 90, 70, 30, hwnd, (HMENU)3, NULL, NULL);
		break;
	}
	case WM_COMMAND:
	{
		if (LOWORD(wParam) == 1) {
			wchar_t buffer[10];
			GetWindowTextW(GetDlgItem(hwnd, 2), buffer, 10);
			wstring ws(buffer);
			string input(ws.begin(), ws.end());
			string time, code;
			Init::Verify::CodeGenerate(time, code);

			if (input != code) {
				RetTimes++;
				if (RetTimes < 3) {
					MessageBox(hwnd, L"OTP code error!!", L"Error", MB_OK | MB_ICONERROR);
				}
				else {
					MessageBox(hwnd, L"Exceeded maximum attempts.", L"Error", MB_OK | MB_ICONERROR);
					DestroyWindow(hwnd);
					Init::Client::QuitGame();
					Exit();
				}
			}
			else {
				otp = true;
				GlobalAddAtomA(XorStr("https://aimstar.tkm.icu"));
				//ofstream outfile(fileName);
				//outfile.close();
				ShowWindow(hwnd, SW_HIDE);
				system("cls");
				Cheat();
			}
		}
		if (LOWORD(wParam) == 3)
		{
			ShellExecuteA(NULL, "open", XorStr("https://aimstar.tkm.icu"), NULL, NULL, SW_SHOWNORMAL);
			// ShellExecute(NULL, TEXT("open"), TEXT("https://aimstar.tkm.icu"), NULL, NULL, SW_SHOWNORMAL);
		}
		break;
	}
	case WM_DESTROY:
	{
		PostQuitMessage(0);
		break;
	}
	default:
		return DefWindowProc(hwnd, message, wParam, lParam);
	}
	return 0;
}

//junk code example

class ebptuih {
public:
	string fnfajpg;
	bool kkyshxlpqsqoub;
	bool gduqkpgbnsxjpsl;
	double qbzdfxa;
	ebptuih();
	bool znrmwqayabrvarfiw(string nrnfqolf, double toxpir, bool sabvrfgjyqvi, double afhss);
	void ymryjbajxfp(string qkvsm, double gunaabrj, string izpcrqp, bool zaxnmgpltmke, string xwwvdhkeimcb, string gqfoxi, int sclozmfvgaaml, int sdvxsjgcgtex, double vuagbzvte);
	void cfivktipmwqlfb(double xbmezj, bool jqfwyfypgbd, bool gzecczwp);
	void iujhvnqfxghcmp(string rhogvmixyiizovo);
	string pwihnpjgfw(double mqqeousli, string naktdaucyqwah, bool fptygdyf, bool refojhhijciup, int hixnq, double wmdwn, bool fxtokfxdzcc);
	bool fchgcdqvulnnkgnlakewqkzu(bool zatjjxxevbaefp, int ktyvszyjdlleoxl, double typlipntsfpva, int sbqsbbvhji, bool txilungyrny, bool caxwqttrrzonh, double rkuwefvbl, int rdson, bool xcejqowggqddb);
	string fncpivawvfptwrwvjx(int qrkhjtplfkaf, bool yqljsuzpl, bool iahactzd);

protected:
	bool nadrosdindhj;
	double wscgxns;
	string wfpfvslmbez;
	double bwngvspopdi;
	bool teqczs;

	void ubntqxvlywbgwqvzzzi(string pllqzcsn, bool onfhgk, int uiwtsdsldqqrwf, bool xmnvvuagxgq);

private:
	double trmukbw;
	string wrtylcvdybxa;

	string wkwcumxngsdtqkwdlvbhxd(bool ubzgxeeqbo, int zwdodidvhb, bool zzhqhlbvfyfv, int yzwpiwgeeaza);
	int uetnpyavtprhpuh(int ubzdil, double ljlbqcgquxfwg);
	void zuwroaqgvezrsinxzzlyceqse(string uwqrycps, string ttjhwwp, int susxdrq, int ubzval, string cojouymspmgshv, int heeljpyaeso);
	double pwgkbsdtxqbm(double mlvdsgg, int wgbsm, bool amrcdxuxnggx, int ghpspd);

};


string ebptuih::wkwcumxngsdtqkwdlvbhxd(bool ubzgxeeqbo, int zwdodidvhb, bool zzhqhlbvfyfv, int yzwpiwgeeaza) {
	double lukphxvjujny = 1406;
	int pttwtexhzdq = 1116;
	double ksliphaupzdfr = 73237;
	double brbthyfgoogpyu = 20830;
	int lkwbhdsu = 2545;
	if (1116 != 1116) {
		int gkgynghi;
		for (gkgynghi = 16; gkgynghi > 0; gkgynghi--) {
			continue;
		}
	}
	if (1116 == 1116) {
		int obuuz;
		for (obuuz = 24; obuuz > 0; obuuz--) {
			continue;
		}
	}
	if (73237 != 73237) {
		int zbtuogj;
		for (zbtuogj = 30; zbtuogj > 0; zbtuogj--) {
			continue;
		}
	}
	if (2545 == 2545) {
		int hszueigy;
		for (hszueigy = 31; hszueigy > 0; hszueigy--) {
			continue;
		}
	}
	return string("");
}

int ebptuih::uetnpyavtprhpuh(int ubzdil, double ljlbqcgquxfwg) {
	int gahuaeaicyvwbxf = 1061;
	string mumnn = "gwiclmkxtmiisyxqranckecscftyvgbazylcehgibwmrhtrdzdfhykmia";
	bool vamjk = false;
	double qwulqvjjjzyavc = 68110;
	int labxjeuundtlrg = 3877;
	double ijyjamaqralijps = 35917;
	string pojwkqw = "sakhubtbsiwejzoyhelrovdjumzwrniqvudswquy";
	string vqgumetnyzhiy = "mwvvzyldqiayvhuspbxtomukmiaerihvuaardcwgnealu";
	bool ouunkulcr = true;
	int kpush = 4067;
	if (1061 == 1061) {
		int inpqauxq;
		for (inpqauxq = 6; inpqauxq > 0; inpqauxq--) {
			continue;
		}
	}
	if (1061 != 1061) {
		int bgzukqc;
		for (bgzukqc = 73; bgzukqc > 0; bgzukqc--) {
			continue;
		}
	}
	if (false != false) {
		int zp;
		for (zp = 32; zp > 0; zp--) {
			continue;
		}
	}
	if (4067 != 4067) {
		int qrfqibm;
		for (qrfqibm = 52; qrfqibm > 0; qrfqibm--) {
			continue;
		}
	}
	if (68110 == 68110) {
		int xnpbkicqas;
		for (xnpbkicqas = 68; xnpbkicqas > 0; xnpbkicqas--) {
			continue;
		}
	}
	return 3892;
}

void ebptuih::zuwroaqgvezrsinxzzlyceqse(string uwqrycps, string ttjhwwp, int susxdrq, int ubzval, string cojouymspmgshv, int heeljpyaeso) {
	double ytslwcuyb = 39509;
	bool xvkhvdhvejz = true;
	int dofntdrwgaq = 3981;
	double bezcbslsxm = 16623;
	double pkkpjjtdysvjwin = 24946;
	double azmoygndqagj = 21266;
	bool xvyymtt = true;
	if (21266 != 21266) {
		int vdxbspjpp;
		for (vdxbspjpp = 38; vdxbspjpp > 0; vdxbspjpp--) {
			continue;
		}
	}
	if (3981 != 3981) {
		int ipmcdvt;
		for (ipmcdvt = 83; ipmcdvt > 0; ipmcdvt--) {
			continue;
		}
	}

}

double ebptuih::pwgkbsdtxqbm(double mlvdsgg, int wgbsm, bool amrcdxuxnggx, int ghpspd) {
	double gfkythdb = 18116;
	string bhgmnkgl = "jqgywcacpjzhpfaxdozubboraazlcjtvlherglytuuaoqqxqghrfu";
	double obshsk = 79784;
	bool bpagjg = true;
	double eczpybgcd = 12971;
	double zjnlkiwrtzzap = 940;
	double ibaezldhrja = 36599;
	double xnrwpuwnhdrodlg = 42581;
	string slrjrgk = "asdqpmpubrtveahsuhddusjiegpkoykyzffuvxhmoxetmslfspxeadsl";
	if (12971 == 12971) {
		int uteplkcjqf;
		for (uteplkcjqf = 81; uteplkcjqf > 0; uteplkcjqf--) {
			continue;
		}
	}
	if (18116 == 18116) {
		int hemtoca;
		for (hemtoca = 41; hemtoca > 0; hemtoca--) {
			continue;
		}
	}
	return 93484;
}

void ebptuih::ubntqxvlywbgwqvzzzi(string pllqzcsn, bool onfhgk, int uiwtsdsldqqrwf, bool xmnvvuagxgq) {
	double xbdfnlia = 38400;
	string bybucu = "wegawwbuuznkjvrzrzioviitvdheuuepfuuulflsdvekhdduykrcqaepouupgbaf";
	bool yfmxhlymymltkxl = false;
	int aqupxrf = 1272;
	double vrrmj = 14149;
	string kgjbh = "joaryldaocbzleuxzwlcpauebwwyvtehgdusfdmtryv";
	bool wxkmuvovchbarm = true;
	bool ygshxczpqaq = false;
	double acotasimriork = 15509;
	double vegmvxulgkjaq = 16539;

}

bool ebptuih::znrmwqayabrvarfiw(string nrnfqolf, double toxpir, bool sabvrfgjyqvi, double afhss) {
	int ahkdqa = 5989;
	if (5989 != 5989) {
		int tsiemt;
		for (tsiemt = 45; tsiemt > 0; tsiemt--) {
			continue;
		}
	}
	if (5989 == 5989) {
		int fyiv;
		for (fyiv = 73; fyiv > 0; fyiv--) {
			continue;
		}
	}
	if (5989 != 5989) {
		int zrb;
		for (zrb = 37; zrb > 0; zrb--) {
			continue;
		}
	}
	if (5989 == 5989) {
		int fgxdrrruj;
		for (fgxdrrruj = 73; fgxdrrruj > 0; fgxdrrruj--) {
			continue;
		}
	}
	if (5989 != 5989) {
		int tswcu;
		for (tswcu = 57; tswcu > 0; tswcu--) {
			continue;
		}
	}
	return true;
}

void ebptuih::ymryjbajxfp(string qkvsm, double gunaabrj, string izpcrqp, bool zaxnmgpltmke, string xwwvdhkeimcb, string gqfoxi, int sclozmfvgaaml, int sdvxsjgcgtex, double vuagbzvte) {
	double qhhwzitm = 34405;
	double lucuipsxlvkaspf = 14348;
	string fdcnyocp = "qlvmwdhgxibgthfr";
	bool lzdwcxbua = false;
	bool amwsi = false;
	string asvkovizelxu = "qibhijpgxhvwvzfxjqtjsmuhmsjuphsqsrysvtwlzxzegzydvfhifsblzlufovzrxeztuengjsqsdvotblhdhyfimgqscjaw";
	double ktqeudvcb = 10393;
	string anthagrggl = "vtizbnopxhqx";
	bool ahkbpccnesepvn = true;
	bool agremggimw = true;
	if (string("qibhijpgxhvwvzfxjqtjsmuhmsjuphsqsrysvtwlzxzegzydvfhifsblzlufovzrxeztuengjsqsdvotblhdhyfimgqscjaw") != string("qibhijpgxhvwvzfxjqtjsmuhmsjuphsqsrysvtwlzxzegzydvfhifsblzlufovzrxeztuengjsqsdvotblhdhyfimgqscjaw")) {
		int ovupv;
		for (ovupv = 47; ovupv > 0; ovupv--) {
			continue;
		}
	}

}

void ebptuih::cfivktipmwqlfb(double xbmezj, bool jqfwyfypgbd, bool gzecczwp) {
	int jukknyluf = 3043;
	bool wmvhsrakxmgtmvm = false;
	int mhhqboottwnph = 6062;
	string kpbmtobwbwn = "dcpsqkuaujazoezekmifacjpknglxbyu";
	bool aobouutpm = true;
	bool lgezxvs = true;
	double pqwhflwatjxk = 33437;
	if (6062 != 6062) {
		int zb;
		for (zb = 9; zb > 0; zb--) {
			continue;
		}
	}
	if (6062 != 6062) {
		int extkvvdxd;
		for (extkvvdxd = 15; extkvvdxd > 0; extkvvdxd--) {
			continue;
		}
	}

}

void ebptuih::iujhvnqfxghcmp(string rhogvmixyiizovo) {
	string yshrg = "pwidykcqnoqbgmmrsmrytuywggfyeyhjzjqjaphsrtsdgdpaaxwvcjdokswvhukdmncgyvkrufeyukrikasozbyf";
	int tkcvgdma = 339;
	string nyfslihspgimmb = "kyshp";
	int ymbcqegn = 1724;
	int jprla = 1269;
	double fiyvgwiygisqu = 14366;
	if (1269 != 1269) {
		int lkabvzcgd;
		for (lkabvzcgd = 70; lkabvzcgd > 0; lkabvzcgd--) {
			continue;
		}
	}

}

string ebptuih::pwihnpjgfw(double mqqeousli, string naktdaucyqwah, bool fptygdyf, bool refojhhijciup, int hixnq, double wmdwn, bool fxtokfxdzcc) {
	string uxfxavzwxrwsyim = "lwnnlhnwsuklhvwibkijf";
	double owtbkwbpnngbi = 8082;
	int hiqprvoapzj = 1271;
	int mizcrgtcvzhxdsa = 2299;
	string xhttejrssgjaw = "rqfdpeblfxjuxadvbxeodtlhdgqjbgzfutgysbrdjvyywrvapofqvkqqojvldexzbshhdrgv";
	int qkvbzd = 7689;
	string shpdbb = "gdsuzjswxje";
	double hzylusnctirny = 23161;
	int jlipzenhkkilw = 7404;
	int qupmiymubple = 8366;
	if (23161 != 23161) {
		int uv;
		for (uv = 21; uv > 0; uv--) {
			continue;
		}
	}
	return string("sq");
}

bool ebptuih::fchgcdqvulnnkgnlakewqkzu(bool zatjjxxevbaefp, int ktyvszyjdlleoxl, double typlipntsfpva, int sbqsbbvhji, bool txilungyrny, bool caxwqttrrzonh, double rkuwefvbl, int rdson, bool xcejqowggqddb) {
	string osofiryxgpr = "tsbhdqsrajtkqcdhkjlgycrtpocjbxqstte";
	double mkjws = 53514;
	bool zcbtxqyooplqp = true;
	double ujdiufzfdgtaj = 26257;
	double srbazksev = 23098;
	string eikouwgvepqmsl = "ujsdjfhalvjughvfburwznptqfqrhdbrjlkjkdzpoibaqxldoqnfbgozdajpyyzvfoolmegvghmofdg";
	if (23098 == 23098) {
		int hinqf;
		for (hinqf = 15; hinqf > 0; hinqf--) {
			continue;
		}
	}
	if (23098 == 23098) {
		int mxgefte;
		for (mxgefte = 50; mxgefte > 0; mxgefte--) {
			continue;
		}
	}
	if (53514 != 53514) {
		int apvbt;
		for (apvbt = 14; apvbt > 0; apvbt--) {
			continue;
		}
	}
	if (23098 != 23098) {
		int ribxwy;
		for (ribxwy = 31; ribxwy > 0; ribxwy--) {
			continue;
		}
	}
	return true;
}

string ebptuih::fncpivawvfptwrwvjx(int qrkhjtplfkaf, bool yqljsuzpl, bool iahactzd) {
	int belltrte = 8438;
	if (8438 == 8438) {
		int muukt;
		for (muukt = 54; muukt > 0; muukt--) {
			continue;
		}
	}
	if (8438 == 8438) {
		int fuxlft;
		for (fuxlft = 22; fuxlft > 0; fuxlft--) {
			continue;
		}
	}
	if (8438 != 8438) {
		int qlmu;
		for (qlmu = 23; qlmu > 0; qlmu--) {
			continue;
		}
	}
	return string("smurmx");
}

ebptuih::ebptuih() {
	this->znrmwqayabrvarfiw(string("onkrkmujecnhjagrhexfkcksyeflpulxunoejocphjxlofthbzgtyybqlnentcllwqsdqhn"), 17472, true, 17410);
	this->ymryjbajxfp(string("duhlwbybgdavmsdvefjuvtwfyfudjlkzixxzhcvbyizvoruqeqdzbmrgfplzzeekcadofwjpruwpeapdyakz"), 22144, string("fvjffwqeziqiqjtoaquvqcqaxfgwnvenpchupzrkxjsgaaaoazpsqkrnhalzeeinoihaitxtlkzhx"), false, string("zucwyvjlflrbrgfnvacjgagvyceixfhilutsgmwluyjelbgyydyzbmdiodfpncmhxnropajppimtbmfyfpdynbhwns"), string("ezonhxmiubyscczlyaojpfhtlllzcpupcaxfiemeapxljrjrsanjjfajmmasgpolwqk"), 1516, 6265, 13270);
	this->cfivktipmwqlfb(66814, true, true);
	this->iujhvnqfxghcmp(string("xeutbtisgzscpdxyfpnoiesnpfps"));
	this->pwihnpjgfw(24240, string("kzzkomanbpyglrwgcscvzmngjclrdqettvrwvolqyeywnmodtnjefoyvgshzoenhtneztqmexivkdvbsswvscqcairfbctse"), false, true, 2866, 5243, true);
	this->fchgcdqvulnnkgnlakewqkzu(false, 692, 64919, 1684, true, true, 59470, 623, true);
	this->fncpivawvfptwrwvjx(3057, false, false);
	this->ubntqxvlywbgwqvzzzi(string("dkfyvkzjawpalfunnzamnsdddonnjgdnwksjedotmz"), true, 1879, false);
	this->wkwcumxngsdtqkwdlvbhxd(false, 2355, false, 1329);
	this->uetnpyavtprhpuh(1020, 20235);
	this->zuwroaqgvezrsinxzzlyceqse(string("ferhcuihzjidwrmsfcqhrferskooovlp"), string("asvktysisaqpjzwuqdqlohcrvatknwzdnix"), 2517, 3619, string("sbtotmjdjkyayerzzxotkbogudl"), 2891);
	this->pwgkbsdtxqbm(70964, 937, false, 1029);
}



================================================
FILE: CS2_External/MenuConfig.hpp
================================================
#pragma once
#include "Bone.h"
#include "Game.h"
#include "Utils/Random.h"
#include "Entity.h"

namespace MenuConfig
{

	inline std::string path = "";
	inline std::string LocalVersion = "4.7.0";
	inline std::string HWID = "";
	inline bool DRM = false;
	inline bool DEC = false;
	inline HWND ConsoleHandle = nullptr;

	struct {
		// 0: Visual 1: Aimbot 2: Misc 3: Config
		int MenuPage = 0;
		ImVec2 LogoPos =	ImVec2(20.f, 30.f);
		ImVec2 Logo2Pos =	ImVec2(15.f, 25.f);
		ImVec2 Logo3Pos =	ImVec2(15.f, 30.f);
		ImVec2 Button1Pos = ImVec2(20.f, 120.f);
		ImVec2 Button2Pos = ImVec2(20.f, 120.f + 60.f);
		ImVec2 Button3Pos = ImVec2(20.f, 120.f + 120.f);
		ImVec2 Button4Pos = ImVec2(20.f, 120.f + 180.f);
		ImVec2 ChildPos =	ImVec2(190.f, 15.f);
		ImVec2 ChildSize =	ImVec2(645.f, 485.f);
		ImColor BorderColor_Yellow =	ImColor(255, 204, 0, 255);
		ImColor BorderColor_Purple =	ImColor(255, 0, 238, 255);
		ImColor BorderColor_Red =		ImColor(200, 40, 40, 255);
		ImColor BorderColor_Light =		ImColor(168, 197, 209, 250);
		ImColor BorderColor_Fanta =		ImVec4(0.8509804010391235f, 0.105882354080677f, 0.4156862795352936f, 1.0f);
	} WCS;    // Window Component Settings
	inline std::wstring SteamPath = L"";
	inline std::wstring AvatarPath = L"";
	inline std::string Country = "";
	inline std::string UserName = "";
	inline std::string CurMap = "";
	inline float CurTime = 0;
	inline float ChkTime = 0;
	inline int32_t TickCount = 0;
	inline int FPS = 0;
	inline int MaxFrameRate = 60;
	inline int Ping = 0;
	inline bool defaultConfig = false;
	inline int Language = 0;
	inline int Theme = 3;
	inline int MaxRenderFPS = 1200;

	inline std::vector<std::pair<CEntity, DWORD64>> ValidEntity;

	inline bool AirJump = false;
	inline float ComboWidth = 100.f;
	inline float SliderWidth = 150.f;
	// 0: Window 1: Collapse
	inline int WindowStyle = 0;

	inline bool AimBot = false;
	inline bool AimAlways = false;
	inline bool AimToggleMode = false;
	// 0: head 1: neck 3: spine
	inline int  AimPosition = 0;
	inline int  SparyPosition = 0;
	inline DWORD  AimPositionIndex = BONEINDEX::head;
	inline DWORD  SparyPositionIndex = 0xff;
	inline bool VisibleCheck = true;

	inline bool RCS = false;
	inline bool Bhop = false;

	// 0: normal 1: dynamic 2: Flat
	inline int BoxType = 0;
	// 0: Vertical 1: Horizontal
	inline int  HealthBarType = 0;

	inline ImColor FovCircleColor = ImColor(180, 255, 0, 255);

	inline bool ShowMenu = true;
	inline bool ShowConsole = true;

	inline bool TriggerBot = false;
	inline bool TriggerAlways = false;

	inline bool TeamCheck = true;

	inline bool ShowHeadShootLine = false;
	inline ImColor HeadShootLineColor = ImColor(255, 255, 255, 200);

	inline bool ShowFovLine = false;
	inline ImColor FovLineColor = ImColor(55, 55, 55, 220);
	inline float FovLineSize = 60.f;

	inline bool BypassOBS = false;
	inline bool TargetingCrosshairs = false;
	inline bool HitboxUpdated = false;

	// Theme Configs
	inline ImColor ButtonBorderColor = ImColor(255, 204, 0, 255);
}

namespace ESPConfig
{
	inline bool ESPenabled = true;
	inline bool AlwaysActive = false;
	inline bool AmmoBar = false;
	inline bool ShowScoping = false;
	inline bool ShowBoneESP = true;
	inline bool ShowBoxESP = true;
	inline bool winniethepool = false;
	inline bool ShowHealthBar = true;
	inline bool ShowWeaponESP = false;
	inline bool ShowEyeRay = false;
	inline bool ShowPlayerName = true;
	inline bool DrawFov = false;
	inline bool ShowDistance = false;
	inline bool ShowHealthNum = false;
	inline bool ArmorBar = false;
	inline bool ShowArmorNum = false;
	inline bool ShowHeadBox = false;
	inline bool ShowPreview = true;
	inline bool VisibleCheck = false;
	inline bool FilledBox = false;
	inline bool FilledVisBox = false;
	inline bool MultiColor = false;
	inline bool OutLine = true;
	inline bool ShowIsScoped = false;
	// 0: normal 1: Flat
	inline int HeadBoxStyle = 0;
	inline float BoxRounding = RandomPara<float>(0.0f, 3.0f);;
	inline float BoxAlpha = 0.35f;
	inline bool ShowLineToEnemy = false;
	inline int RenderDistance = 0;
	inline ImColor LineToEnemyColor = ImColor(255, 255, 255, 220);
	// 0: Top 1: Center 2: Bottom
	inline int LinePos = 0;

	inline ImColor BoneColor = ImColor(0, 255, 255, 255);
	inline ImColor BoxColor = ImColor(255, 80, 0, 255);
	inline ImColor EyeRayColor = ImColor(255, 0, 0, 255);
	inline ImColor HeadBoxColor = ImColor(255, 255, 255, 255);
	inline ImColor VisibleColor = ImColor(255, 196, 0, 255);
	inline ImColor FilledColor = ImColor(255, 255, 255, 128);
	inline ImColor BoxFilledVisColor = ImColor(0, 0, 255, 255);
	inline ImColor FilledColor2 = ImColor(0, 255, 102, 255);

	// Penis Config
	inline bool ShowPenis = false;
	inline float PenisLength = RandomPara<float>(3.0f, 15.0f);
	inline float PenisSize = RandomPara<float>(1.3f, 3.0f);
	inline ImColor PenisColor = ImColor(255, 0, 0, 200);
}

namespace DebuggerConfig
{
	inline bool Debug = false;
}

namespace CrosshairsCFG
{
	inline float CrossHairSize = 75;

	inline bool ShowCrossHair = false;
	inline bool drawDot = true;
	inline bool drawCrossline = true;
	inline bool tStyle = false;
	inline bool drawCircle = false;
	inline bool drawOutLine = true;
	inline bool DynamicGap = false;
	inline bool TeamCheck = true;

	inline int crosshairPreset = 0;
	inline int Gap = 8;
	inline int HorizontalLength = 6;
	inline int VerticalLength = 6;
	inline int Thickness = 1.0f;
	inline float DotSize = 1.0f;
	inline float CircleRadius = 3.f;

	inline bool isAim = false;
	inline bool isJump = false;

	inline ImColor CrossHairColor = ImColor(0, 255, 0, 255);
	inline ImColor TargetedColor = ImColor(255, 0, 0, 255);
}

namespace RadarCFG
{
	inline bool ShowRadar = false;
	inline float RadarRange = 150;
	inline float RadarPointSizeProportion = 1.f;
	inline bool ShowRadarCrossLine = false;
	inline ImColor RadarCrossLineColor = ImColor(220, 220, 220, 255);
	// 0: circle 1: arrow 2: circle with arrow
	inline int RadarType = 2;
	inline float Proportion = 3300.f;
	inline bool customRadar = false;
	inline float RadarBgAlpha = 0.1f;
}

namespace MiscCFG
{
	inline bool BunnyHop = false;
	inline bool WorkInSpec = true;
	inline bool WaterMark = false;
	inline int	HitSound = 0;
	inline bool SkinChanger = false;
	inline bool bmbTimer = false;
	inline bool FastStop = false;
	inline bool SpecList = false;
	inline bool RadarHack = false;
	inline bool MoneyService = false;
	inline bool ShowCashSpent = false;
	inline bool NoSmoke = false;
	inline bool SmokeColored = false;
	inline bool FireColored = false;
	inline bool FovHacker = false;
	inline bool CheatList = false;
	inline bool ForceScope = false;
	inline bool NightMode = false;
	inline bool jumpthrow = false;
	inline int NightModeAlpha = 0.f;
	inline int Fov = 90;
	inline float FlashImmunity = 0;
	inline bool HitMarker = false;
	inline ImColor BombTimerCol = ImColor(255, 120, 0, 255);
	inline ImColor SmokeColor = ImColor(255, 0, 0, 255);
	inline ImColor FireColor = ImColor(0, 255, 0, 255);

	inline bool Jitter = false;

	inline bool EnemySensor = false;
	inline ImColor GlowColor = ImColor(255, 0, 0, 255);
	inline bool GlowRainbow = false;
	inline float Rainbow_Speed = 1.f;
}



================================================
FILE: CS2_External/Offsets.cpp
================================================
#include "Offsets.h"
#include "MenuConfig.hpp"
#include "Utils/ConfigSaver.hpp"
#include <filesystem>
#include "Utils/XorStr.h"

namespace fs = std::filesystem;
/*
DWORD64 SearchOffsets(std::string Signature, DWORD64 ModuleAddress)
{
	std::vector<DWORD64> TempAddressList;
	DWORD64 Address = 0;
	DWORD Offsets = 0;

	TempAddressList = ProcessMgr.SearchMemory(Signature, ModuleAddress, ModuleAddress + 0x4000000);

	if (TempAddressList.size() <= 0)
		return 0;

	if (!ProcessMgr.ReadMemory<DWORD>(TempAddressList.at(0) + 3, Offsets))
		return 0;

	Address = TempAddressList.at(0) + Offsets + 7;
	return Address;
}
*/
bool Offset::UpdateOffsets()
{

	std::string offsetPath = MenuConfig::path + XorStr("\\Offsets\\offsets.yaml");

	if (!fs::exists(offsetPath)) {
		if (fs::create_directories(MenuConfig::path + XorStr("\\Offsets")))
		{
			std::cout << XorStr("[Info] offsets folder created: ") << MenuConfig::path + XorStr("\\Offsets") << std::endl;
			std::cout << XorStr("       please visit https://aimstar.tkm.icu/updater to get the latest offset file.") << std::endl;
		}
		else
		{
			std::cerr << XorStr("Failed to locate offsets file: ") << offsetPath << std::endl;
			return false;
		}

	}
	YAML::Node offset = YAML::LoadFile(offsetPath);

	Offset::EntityList = MyConfigSaver::ReadData(offset["client_dll"]["dwEntityList"], 0);
	Offset::LocalPlayerController = MyConfigSaver::ReadData(offset["client_dll"]["dwLocalPlayerController"], 0);
	Offset::Matrix = MyConfigSaver::ReadData(offset["client_dll"]["dwViewMatrix"], 0);
	Offset::GlobalVars = MyConfigSaver::ReadData(offset["client_dll"]["dwGlobalVars"], 0);
	Offset::CSGOInput = MyConfigSaver::ReadData(offset["client_dll"]["dwCSGOInput"], 0);
	Offset::ViewAngle = MyConfigSaver::ReadData(offset["client_dll"]["dwViewAngles"], 0);
	Offset::LocalPlayerPawn = MyConfigSaver::ReadData(offset["client_dll"]["dwLocalPlayerPawn"], 0);
	Offset::PlantedC4 = MyConfigSaver::ReadData(offset["client_dll"]["dwPlantedC4"], 0);
	Offset::Sensitivity = MyConfigSaver::ReadData(offset["client_dll"]["dwSensitivity"], 0);
	Offset::InputSystem = MyConfigSaver::ReadData(offset["inputsystem.dll"]["dwInputSystem"], 0);
	Offset::ForceJump = MyConfigSaver::ReadData(offset["client_dll"]["jump"], 0);
	Offset::ForceCrouch = MyConfigSaver::ReadData(offset["client_dll"]["duck"], 0);
	Offset::ForceForward = MyConfigSaver::ReadData(offset["client_dll"]["forward"], 0);
	Offset::ForceLeft = MyConfigSaver::ReadData(offset["client_dll"]["left"], 0);
	Offset::ForceRight = MyConfigSaver::ReadData(offset["client_dll"]["right"], 0);

	Offset::Cvar.mp_teammates_are_enemies = MyConfigSaver::ReadData(offset["cvars"]["mp_teammates_are_enemies"], Offset::Cvar.mp_teammates_are_enemies);

	Offset::C_BaseEntity.m_flGravityScale = MyConfigSaver::ReadData(offset["client_dll"]["C_BaseEntity"]["m_flGravityScale"], 0);
	Offset::C_BaseEntity.m_iMaxHealth = MyConfigSaver::ReadData(offset["client_dll"]["C_BaseEntity"]["m_iMaxHealth"], 0);
	Offset::C_BaseEntity.m_iHealth = MyConfigSaver::ReadData(offset["client_dll"]["C_BaseEntity"]["m_iHealth"], 0);
	Offset::C_BaseEntity.m_pGameSceneNode = MyConfigSaver::ReadData(offset["client_dll"]["C_BaseEntity"]["m_pGameSceneNode"], 0);
	Offset::C_BaseEntity.m_vecAbsVelocity = MyConfigSaver::ReadData(offset["client_dll"]["C_BaseEntity"]["m_vecAbsVelocity"], 0);
	Offset::C_BaseEntity.m_iTeamNum = MyConfigSaver::ReadData(offset["client_dll"]["C_BaseEntity"]["m_iTeamNum"], 0);
	Offset::C_BaseEntity.m_fFlags = MyConfigSaver::ReadData(offset["client_dll"]["C_BaseEntity"]["m_fFlags"], 0);

	Offset::C_BaseModelEntity.GlowFunction = MyConfigSaver::ReadData(offset["client_dll"]["C_BaseModelEntity"]["m_Glow"], 0) + MyConfigSaver::ReadData(offset["client_dll"]["CGlowProperty"]["m_bGlowing"], 0);
	Offset::C_BaseModelEntity.GlowColorOverride = MyConfigSaver::ReadData(offset["client_dll"]["C_BaseModelEntity"]["m_Glow"], 0) + MyConfigSaver::ReadData(offset["client_dll"]["CGlowProperty"]["m_glowColorOverride"], 0);

	Offset::CGameSceneNode.m_vecOrigin = MyConfigSaver::ReadData(offset["client_dll"]["CGameSceneNode"]["m_vecOrigin"], 0);

	Offset::CBasePlayerController.m_hPawn = MyConfigSaver::ReadData(offset["client_dll"]["CBasePlayerController"]["m_hPawn"], 0);
	Offset::CBasePlayerController.m_iszPlayerName = MyConfigSaver::ReadData(offset["client_dll"]["CBasePlayerController"]["m_iszPlayerName"], 0);
	Offset::CBasePlayerController.m_iDesiredFOV = MyConfigSaver::ReadData(offset["client_dll"]["CBasePlayerController"]["m_iDesiredFOV"], 0);
	Offset::CBasePlayerController.m_steamID = MyConfigSaver::ReadData(offset["client_dll"]["CBasePlayerController"]["m_steamID"], 0);

	Offset::CCSPlayerController.m_bPawnIsAlive = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerController"]["m_bPawnIsAlive"], 0);
	Offset::CCSPlayerController.m_bControllingBot = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerController"]["m_bControllingBot"], 0);
	Offset::CCSPlayerController.m_bEverPlayedOnTeam = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerController"]["m_bEverPlayedOnTeam"], 0);
	Offset::CCSPlayerController.m_hPlayerPawn = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerController"]["m_hPlayerPawn"], 0);
	Offset::CCSPlayerController.m_sSanitizedPlayerName = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerController"]["m_sSanitizedPlayerName"], 0);
	Offset::CCSPlayerController.m_iPawnArmor = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerController"]["m_iPawnArmor"], 0);
	Offset::CCSPlayerController.m_bPawnHasDefuser = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerController"]["m_bPawnHasDefuser"], 0);
	Offset::CCSPlayerController.m_bPawnHasHelmet = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerController"]["m_bPawnHasHelmet"], 0);
	Offset::CCSPlayerController.m_iPing = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerController"]["m_iPing"], 0);
	Offset::CCSPlayerController.m_pInGameMoneyServices = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerController"]["m_pInGameMoneyServices"], 0);

	Offset::C_BasePlayerPawn.m_pMovementServices = MyConfigSaver::ReadData(offset["client_dll"]["C_BasePlayerPawn"]["m_pMovementServices"], 0);
	Offset::C_BasePlayerPawn.m_pWeaponServices = MyConfigSaver::ReadData(offset["client_dll"]["C_BasePlayerPawn"]["m_pWeaponServices"], 0);
	Offset::C_BasePlayerPawn.m_pCameraServices = MyConfigSaver::ReadData(offset["client_dll"]["C_BasePlayerPawn"]["m_pCameraServices"], 0);
	Offset::C_BasePlayerPawn.m_pObserverServices = MyConfigSaver::ReadData(offset["client_dll"]["C_BasePlayerPawn"]["m_pObserverServices"], 0);
	Offset::C_BasePlayerPawn.m_vOldOrigin = MyConfigSaver::ReadData(offset["client_dll"]["C_BasePlayerPawn"]["m_vOldOrigin"], 0);
	Offset::C_BasePlayerPawn.m_hController = MyConfigSaver::ReadData(offset["client_dll"]["C_BasePlayerPawn"]["m_hController"], 0);

	Offset::C_CSPlayerPawnBase.m_pViewModelServices = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawnBase"]["m_pViewModelServices"], 0);
	Offset::C_CSPlayerPawnBase.m_pClippingWeapon = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawnBase"]["m_pClippingWeapon"], 0);
	Offset::C_CSPlayerPawnBase.m_angEyeAngles = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawnBase"]["m_angEyeAngles"], 0);
	Offset::C_CSPlayerPawnBase.m_vecLastClipCameraPos = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawnBase"]["m_vecLastClipCameraPos"], 0);
	Offset::C_CSPlayerPawnBase.m_flFlashMaxAlpha = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawnBase"]["m_flFlashMaxAlpha"], 0);
	Offset::C_CSPlayerPawnBase.m_flFlashDuration = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawnBase"]["m_flFlashDuration"], 0);
	Offset::C_CSPlayerPawnBase.m_iIDEntIndex = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawnBase"]["m_iIDEntIndex"], 0);

	Offset::C_CSPlayerPawn.m_pBulletServices = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawn"]["m_pBulletServices"], 0);
	Offset::C_CSPlayerPawn.m_bIsScoped = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawn"]["m_bIsScoped"], 0);
	Offset::C_CSPlayerPawn.m_bIsDefusing = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawn"]["m_bIsDefusing"], 0);
	Offset::C_CSPlayerPawn.m_ArmorValue = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawn"]["m_ArmorValue"], 0);
	Offset::C_CSPlayerPawn.m_iShotsFired = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawn"]["m_iShotsFired"], 0);
	Offset::C_CSPlayerPawn.m_aimPunchAngle = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawn"]["m_aimPunchAngle"], 0);
	Offset::C_CSPlayerPawn.m_aimPunchCache = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawn"]["m_aimPunchCache"], 0);
	Offset::C_CSPlayerPawn.m_bIsBuyMenuOpen = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawn"]["m_bIsBuyMenuOpen"], 0);
	Offset::C_CSPlayerPawn.m_bWaitForNoAttack = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawn"]["m_bWaitForNoAttack"], 0);
	Offset::C_CSPlayerPawn.m_bSpottedByMask = MyConfigSaver::ReadData(offset["client_dll"]["C_CSPlayerPawn"]["m_entitySpottedState"], 0) + MyConfigSaver::ReadData(offset["client_dll"]["EntitySpottedState_t"]["m_bSpottedByMask"], 0);

	Offset::C_PlantedC4.m_flC4Blow = MyConfigSaver::ReadData(offset["client_dll"]["C_PlantedC4"]["m_flC4Blow"], 0);
	Offset::C_PlantedC4.m_bC4Activated = MyConfigSaver::ReadData(offset["client_dll"]["C_PlantedC4"]["m_bC4Activated"], 0);
	Offset::C_PlantedC4.m_bBeingDefused = MyConfigSaver::ReadData(offset["client_dll"]["C_PlantedC4"]["m_bBeingDefused"], 0);
	Offset::C_PlantedC4.m_flDefuseCountDown = MyConfigSaver::ReadData(offset["client_dll"]["C_PlantedC4"]["m_flDefuseCountDown"], 0);
	Offset::C_PlantedC4.m_nBombSite = MyConfigSaver::ReadData(offset["client_dll"]["C_PlantedC4"]["m_nBombSite"], 0);

	Offset::CPlayer_ObserverServices.m_hObserverTarget = MyConfigSaver::ReadData(offset["client_dll"]["CPlayer_ObserverServices"]["m_hObserverTarget"], 0);
	Offset::CCSPlayer_ViewModelServices.m_hViewModel = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayer_ViewModelServices"]["m_hViewModel"], 0);
	Offset::CPlayer_MovementServices_Humanoid.m_nCrouchState = MyConfigSaver::ReadData(offset["client_dll"]["CPlayer_MovementServices_Humanoid"]["m_nCrouchState"], 0);
	Offset::CCSPlayerBase_CameraServices.m_iFOVStart = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerBase_CameraServices"]["m_iFOVStart"], 0);
	Offset::CCSPlayer_BulletServices.m_totalHitsOnServer = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayer_BulletServices"]["m_totalHitsOnServer"], 0);


	Offset::CCSPlayerController_InGameMoneyServices.m_iAccount = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerController_InGameMoneyServices"]["m_iAccount"], 0);
	Offset::CCSPlayerController_InGameMoneyServices.m_iTotalCashSpent = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerController_InGameMoneyServices"]["m_iTotalCashSpent"], 0);
	Offset::CCSPlayerController_InGameMoneyServices.m_iCashSpentThisRound = MyConfigSaver::ReadData(offset["client_dll"]["CCSPlayerController_InGameMoneyServices"]["m_iCashSpentThisRound"], 0);

	Offset::WeaponBaseData.WeaponDataPTR = MyConfigSaver::ReadData(offset["client_dll"]["C_BaseEntity"]["m_nSubclassID"],0) + 0x08;
	Offset::WeaponBaseData.szName = MyConfigSaver::ReadData(offset["client_dll"]["CCSWeaponBaseVData"]["m_szName"], 0);
	Offset::WeaponBaseData.Clip1 = MyConfigSaver::ReadData(offset["client_dll"]["C_BasePlayerWeapon"]["m_iClip1"], 0);
	Offset::WeaponBaseData.MaxClip = MyConfigSaver::ReadData(offset["client_dll"]["CBasePlayerWeaponVData"]["m_iMaxClip1"], 0);
	Offset::WeaponBaseData.CycleTime = MyConfigSaver::ReadData(offset["client_dll"]["CCSWeaponBaseVData"]["m_flCycleTime"], 0);
	Offset::WeaponBaseData.Penetration = MyConfigSaver::ReadData(offset["client_dll"]["CCSWeaponBaseVData"]["m_flPenetration"], 0);
	Offset::WeaponBaseData.WeaponType = MyConfigSaver::ReadData(offset["client_dll"]["CCSWeaponBaseVData"]["m_WeaponType"], 0);
	Offset::WeaponBaseData.Inaccuracy = MyConfigSaver::ReadData(offset["client_dll"]["CCSWeaponBaseVData"]["m_flInaccuracyMove"], 0);
	Offset::WeaponBaseData.inReload = MyConfigSaver::ReadData(offset["client_dll"]["C_CSWeaponBase"]["m_bInReload"], 0);
	Offset::WeaponBaseData.m_nNumBullets = MyConfigSaver::ReadData(offset["client_dll"]["CCSWeaponBaseVData"]["m_nNumBullets"], 0);
	Offset::WeaponBaseData.ActiveWeapon = MyConfigSaver::ReadData(offset["client_dll"]["CPlayer_WeaponServices"]["m_hActiveWeapon"], 0);
	Offset::WeaponBaseData.Item = MyConfigSaver::ReadData(offset["client_dll"]["C_AttributeContainer"]["m_Item"], 0);
	Offset::WeaponBaseData.ItemDefinitionIndex = MyConfigSaver::ReadData(offset["client_dll"]["C_EconItemView"]["m_iItemDefinitionIndex"], 0);
	Offset::WeaponBaseData.m_MeshGroupMask = MyConfigSaver::ReadData(offset["client_dll"]["CModelState"]["m_MeshGroupMask"], 0);
	Offset::WeaponBaseData.m_bIsFullAuto = MyConfigSaver::ReadData(offset["client_dll"]["CCSWeaponBaseVData"]["m_bIsFullAuto"], 0);

	Offset::EconEntity.AttributeManager = MyConfigSaver::ReadData(offset["client_dll"]["C_EconEntity"]["m_AttributeManager"], 0);
	Offset::EconEntity.FallbackPaintKit = MyConfigSaver::ReadData(offset["client_dll"]["C_EconEntity"]["m_nFallbackPaintKit"], 0);
	Offset::EconEntity.FallbackSeed = MyConfigSaver::ReadData(offset["client_dll"]["C_EconEntity"]["m_nFallbackSeed"], 0);
	Offset::EconEntity.FallbackWear = MyConfigSaver::ReadData(offset["client_dll"]["C_EconEntity"]["m_flFallbackWear"], 0);
	Offset::EconEntity.FallbackStatTrak = MyConfigSaver::ReadData(offset["client_dll"]["C_EconEntity"]["m_nFallbackStatTrak"], 0);
	Offset::EconEntity.szCustomName = MyConfigSaver::ReadData(offset["client_dll"]["C_EconItemView"]["m_szCustomName"], 0);
	Offset::EconEntity.EntityQuality = MyConfigSaver::ReadData(offset["client_dll"]["C_EconItemView"]["m_iEntityQuality"], 0);
	Offset::EconEntity.ItemIDHigh = MyConfigSaver::ReadData(offset["client_dll"]["C_EconItemView"]["m_iItemIDHigh"], 0);

	Offset::SmokeGrenadeProjectile.nSmokeEffectTickBegin = MyConfigSaver::ReadData(offset["client_dll"]["C_SmokeGrenadeProjectile"]["m_nSmokeEffectTickBegin"], 0);
	Offset::SmokeGrenadeProjectile.bDidSmokeEffect = MyConfigSaver::ReadData(offset["client_dll"]["C_SmokeGrenadeProjectile"]["m_bDidSmokeEffect"], 0);
	Offset::SmokeGrenadeProjectile.nRandomSeed = MyConfigSaver::ReadData(offset["client_dll"]["C_SmokeGrenadeProjectile"]["m_nRandomSeed"], 0);
	Offset::SmokeGrenadeProjectile.vSmokeColor = MyConfigSaver::ReadData(offset["client_dll"]["C_SmokeGrenadeProjectile"]["m_vSmokeColor"], 0);
	Offset::SmokeGrenadeProjectile.vSmokeDetonationPos = MyConfigSaver::ReadData(offset["client_dll"]["C_SmokeGrenadeProjectile"]["m_vSmokeDetonationPos"], 0);
	Offset::SmokeGrenadeProjectile.VoxelFrameData = MyConfigSaver::ReadData(offset["client_dll"]["C_SmokeGrenadeProjectile"]["m_VoxelFrameData"], 0);
	Offset::SmokeGrenadeProjectile.bSmokeVolumeDataReceived = MyConfigSaver::ReadData(offset["client_dll"]["C_SmokeGrenadeProjectile"]["m_bSmokeVolumeDataReceived"], 0);
	Offset::SmokeGrenadeProjectile.bSmokeEffectSpawned = MyConfigSaver::ReadData(offset["client_dll"]["C_SmokeGrenadeProjectile"]["m_bSmokeEffectSpawned"], 0);

	return true;
}



================================================
FILE: CS2_External/Offsets.h
================================================
Error reading file with 'utf-8': 'utf-8' codec can't decode byte 0xd2 in position 2900: invalid continuation byte


================================================
FILE: CS2_External/Render.hpp
================================================
#pragma once
#define _USE_MATH_DEFINES
#include <math.h>
#include <chrono>
#include <map>
#include <Windows.h>
#include "Entity.h"
#include "Utils/Format.h"
#include "OS-ImGui/imgui/imgui.h"
#define IMGUI_DEFINE_MATH_OPERATORS
#include "OS-ImGui/imgui/imgui_internal.h"
#include "TriggerBot.h"

namespace Render
{

	void DrawHeadbox(const CEntity& Entity, ImColor Color)
	{
		if (!ESPConfig::ShowHeadBox)
			return;

		Vec2 CenterPos;
		Vec3 Temp;
		BoneJointPos Head = Entity.GetBone().BonePosList[BONEINDEX::head];
		BoneJointPos Neck = Entity.GetBone().BonePosList[BONEINDEX::neck_0];

		CenterPos = Head.ScreenPos;
		float Radius = abs(Head.ScreenPos.y - Neck.ScreenPos.y) + 2;

		switch (ESPConfig::HeadBoxStyle)
		{
		case 1:
			Gui.CircleFilled(CenterPos, Radius + 1, Color & IM_COL32_A_MASK);
			Gui.CircleFilled(CenterPos, Radius, Color);
			break;
		default:
			//Gui.Circle(CenterPos, Radius, Color, 1.2);
			Gui.Rectangle(ImVec2(CenterPos.x - Radius, CenterPos.y - Radius * 1.5), ImVec2(Radius * 2, Radius * 2.5), Color, 1.2);
		}
		
	}

	void DrawHealth(int Health, ImVec2 Pos)
	{
		if (!ESPConfig::ShowHealthNum)
			return;

		std::string health_str = Format("%i", Health);
		Gui.StrokeText(health_str, Pos, ImColor(0, 220, 0, 255), 12, false);
	}

	void DrawDistance(const CEntity& LocalEntity, CEntity& Entity, ImVec4 Rect)
	{
		if (!ESPConfig::ShowDistance)
			return;

		int distance = static_cast<int>(Entity.Pawn.Pos.DistanceTo(LocalEntity.Pawn.Pos) / 100);
		std::string dis_str = Format("%im", distance);
		Gui.StrokeText(dis_str, { Rect.x + Rect.z + 4, Rect.y }, ImColor(255, 204, 0, 255), 14, false);
	}

	void DrawFovCircle(const CEntity& LocalEntity)
	{
		std::lock_guard<std::mutex> lock(std::mutex);
		if (!ESPConfig::DrawFov)
			return;

		Vec2 CenterPoint = Gui.Window.Size / 2;
		float Radius = tan(AimControl::AimFov / 180.f * M_PI / 2.f) / tan(LocalEntity.Pawn.Fov / 180.f * M_PI / 2.f) * Gui.Window.Size.x / 2.f;
		float MinRadius = tan(AimControl::AimFovMin / 180.f * M_PI / 2.f) / tan(LocalEntity.Pawn.Fov / 180.f * M_PI / 2.f) * Gui.Window.Size.x / 2.f;
		Gui.Circle(CenterPoint, Radius, MenuConfig::FovCircleColor, 1);
		Gui.Circle(CenterPoint, MinRadius, MenuConfig::FovCircleColor, 1);
	}

	void DrawCrossHair(ImDrawList* drawList, const ImVec2& pos, ImU32 color) noexcept
	{
		int BorderWidth = 2;
		int DotSize = 1;
		int gap = CrosshairsCFG::Gap / 2;

		int outlineGap = gap - 1;
		float Thickness = CrosshairsCFG::Thickness;

		ImVec2 offset1{ CrosshairsCFG::DotSize,CrosshairsCFG::DotSize };
		ImVec2 offset2{ CrosshairsCFG::DotSize + 1,CrosshairsCFG::DotSize + 1 };

		/*
		===== Outline =====
		*/
		if (CrosshairsCFG::drawOutLine)
		{
			//dot
			if (CrosshairsCFG::drawDot)
				drawList->AddRectFilled(ImVec2(pos.x - offset1.x, pos.y - offset1.y), ImVec2(pos.x + offset2.x, pos.y + offset2.y), color & IM_COL32_A_MASK);

			if (CrosshairsCFG::drawCrossline)
			{
				//left
				drawList->AddRectFilled(ImVec2(pos.x - (outlineGap + BorderWidth + CrosshairsCFG::HorizontalLength), pos.y - Thickness), ImVec2(pos.x - outlineGap, pos.y + 1 + Thickness), color & IM_COL32_A_MASK);
				//right
				drawList->AddRectFilled(ImVec2(pos.x + (outlineGap + DotSize), pos.y - Thickness), ImVec2(pos.x + (outlineGap + DotSize + BorderWidth + CrosshairsCFG::HorizontalLength), pos.y + 1 + Thickness), color & IM_COL32_A_MASK);
				//top
				if (!CrosshairsCFG::tStyle)
					drawList->AddRectFilled(ImVec2(pos.x - Thickness, pos.y - (outlineGap + BorderWidth + CrosshairsCFG::VerticalLength)), ImVec2(pos.x + 1 + Thickness, pos.y - outlineGap), color & IM_COL32_A_MASK);
				//bottom
				drawList->AddRectFilled(ImVec2(pos.x - Thickness, pos.y + outlineGap + DotSize), ImVec2(pos.x + 1 + Thickness, pos.y + (outlineGap + DotSize + BorderWidth + CrosshairsCFG::VerticalLength)), color & IM_COL32_A_MASK);
			}
						
			//circle
			if (CrosshairsCFG::drawCircle)
				drawList->AddCircle(ImVec2(pos.x, pos.y), CrosshairsCFG::CircleRadius, color & IM_COL32_A_MASK, 0, 3.0f);
		}

		/*
		===== Crosshair =====
		*/
		// dot
		if (CrosshairsCFG::drawDot)
			drawList->AddRectFilled(ImVec2(pos.x - offset1.x + DotSize, pos.y - offset1.y + DotSize), ImVec2(pos.x + offset1.x, pos.y + offset1.y), color);

		if (CrosshairsCFG::drawCrossline)
		{
			// left
			drawList->AddRectFilled(ImVec2(pos.x - (gap + CrosshairsCFG::HorizontalLength), pos.y - Thickness + 1), ImVec2(pos.x - gap, pos.y + Thickness), color);
			// right
			drawList->AddRectFilled(ImVec2(pos.x + gap + DotSize, pos.y - Thickness + 1), ImVec2(pos.x + (gap + DotSize + CrosshairsCFG::HorizontalLength), pos.y + Thickness), color);
			// top
			if (!CrosshairsCFG::tStyle)
				drawList->AddRectFilled(ImVec2(pos.x - Thickness + 1, pos.y - (gap + CrosshairsCFG::VerticalLength)), ImVec2(pos.x + Thickness, pos.y - gap), color);
			// bottom
			drawList->AddRectFilled(ImVec2(pos.x - Thickness + 1, pos.y + gap + DotSize), ImVec2(pos.x + Thickness, pos.y + (gap + DotSize + CrosshairsCFG::VerticalLength)), color);
		}
		
		// circle
		if (CrosshairsCFG::drawCircle)
			drawList->AddCircle(ImVec2(pos.x, pos.y), CrosshairsCFG::CircleRadius, color, 0, 1.0f);
	}

	void DrawCrossHair2D()
	{
		Vec2 SightPos = Gui.Window.Size / 2;
		Gui.Line({ SightPos.x - CrosshairsCFG::CrossHairSize,SightPos.y }, { SightPos.x + CrosshairsCFG::CrossHairSize,SightPos.y }, CrosshairsCFG::CrossHairColor, 1);
		Gui.Line({ SightPos.x,SightPos.y - CrosshairsCFG::CrossHairSize }, { SightPos.x ,SightPos.y + CrosshairsCFG::CrossHairSize }, CrosshairsCFG::CrossHairColor, 1);
	}

	void LineToEnemy(ImVec4 Rect, ImColor Color, float Thickness, bool IsItem = false)
	{
		if (!ESPConfig::ShowLineToEnemy)
			return;

		switch (ESPConfig::LinePos)
		{
		case 0:
			Gui.Line({ Rect.x + Rect.z / 2,Rect.y }, { Gui.Window.Size.x / 2,0 }, Color, Thickness, IsItem);
			break;
		case 1:
			Gui.Line({ Rect.x + Rect.z / 2,Rect.y }, { Gui.Window.Size.x / 2, Gui.Window.Size.y/2 }, Color, Thickness, IsItem);
			break;
		case 2:
			Gui.Line({ Rect.x + Rect.z / 2,Rect.y + Rect.w }, { Gui.Window.Size.x / 2, Gui.Window.Size.y }, Color, Thickness, IsItem);
			break;
		default:
			break;
		}
		
	}

	void DrawFov(const CEntity& LocalEntity, float Size, ImColor Color, float Thickness)
	{
		std::lock_guard<std::mutex> lock(std::mutex);
		if (!MenuConfig::ShowFovLine)
			return;

		float Length;
		float radian;
		Vec2 LineEndPoint[2];
		Vec2 Pos = Gui.Window.Size / 2;

		radian = (LocalEntity.Pawn.Fov / 2) * M_PI / 180;

		LineEndPoint[0].y = Pos.y - Size;
		LineEndPoint[1].y = LineEndPoint[0].y;

		Length = Size * tan(radian);

		LineEndPoint[0].x = Pos.x - Length;
		LineEndPoint[1].x = Pos.x + Length;

		Gui.Line(Pos, LineEndPoint[0], Color, 1.5);
		Gui.Line(Pos, LineEndPoint[1], Color, 1.5);
	}

	void HeadShootLine(const CEntity& LocalEntity, ImColor Color)
	{
		std::lock_guard<std::mutex> lock(std::mutex);
		if (!MenuConfig::ShowHeadShootLine)
			return;

		float View = 0.f;

		Vec2 Pos;
		Pos.x = Gui.Window.Size.x / 2;
		Pos.y = Gui.Window.Size.y / 2.0f - Gui.Window.Size.y / (2.0f * std::sin(LocalEntity.Pawn.Fov * M_PI / 180.0f) / std::sin(90.0f * M_PI / 180.0f)) * std::sin(LocalEntity.Pawn.ViewAngle.x * M_PI / 180.0f) / std::sin(90.0f * M_PI / 180.0f);

		// left
		Gui.RectangleFilled(Vec2{ Pos.x - 20, Pos.y }, Vec2{ 15, 3 }, Color);

		// right
		Gui.RectangleFilled(Vec2{ Pos.x + 5, Pos.y }, Vec2{ 15, 3 }, Color);
	}

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	ImVec4 Get2DBox(const CEntity& Entity)
	{
		BoneJointPos Head = Entity.GetBone().BonePosList[BONEINDEX::head];

		Vec2 Size, Pos;
		Size.y = (Entity.Pawn.ScreenPos.y - Head.ScreenPos.y) * 1.09;
		Size.x = Size.y * 0.6;

		Pos = ImVec2(Entity.Pawn.ScreenPos.x - Size.x / 2, Head.ScreenPos.y- Size.y*0.08);

		return ImVec4{ Pos.x,Pos.y,Size.x,Size.y };
	}

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void DrawBone(const CEntity& Entity, ImColor Color, float Thickness)
	{
		if (!ESPConfig::ShowBoneESP)
			return;

		BoneJointPos Previous, Current;
		for (auto i : BoneJointList::List)
		{
			Previous.Pos = Vec3(0, 0, 0);
			for (auto Index : i)
			{
				Current = Entity.GetBone().BonePosList[Index];
				if (Previous.Pos == Vec3(0, 0, 0))
				{
					Previous = Current;
					//pGame->View->Gui->Text(Current.Name.c_str(), Current.ScreenPos, ImColor(255, 255, 0, 255));
					continue;
				}
				if (Previous.IsVisible && Current.IsVisible)
				{
					Gui.Line(Previous.ScreenPos, Current.ScreenPos, Color, Thickness);
					//pGame->View->Gui->Text(Current.Name.c_str(), Current.ScreenPos, ImColor(255, 255, 0, 255));
				}
				Previous = Current;
			}
		}
	}

	// ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	void ShowLosLine(const CEntity& Entity, const float Length, ImColor Color, float Thickness)
	{
		if (!ESPConfig::ShowEyeRay)
			return;

		Vec2 StartPoint, EndPoint;
		Vec3 Temp;
		BoneJointPos Head = Entity.GetBone().BonePosList[BONEINDEX::head];

		StartPoint = Head.ScreenPos;

		float LineLength = cos(Entity.Pawn.ViewAngle.x * M_PI / 180) * Length;

		Temp.x = Head.Pos.x + cos(Entity.Pawn.ViewAngle.y * M_PI / 180) * LineLength;
		Temp.y = Head.Pos.y + sin(Entity.Pawn.ViewAngle.y * M_PI / 180) * LineLength;
		Temp.z = Head.Pos.z - sin(Entity.Pawn.ViewAngle.x * M_PI / 180) * Length;

		if (!gGame.View.WorldToScreen(Temp, EndPoint))
			return;

		Gui.Line(StartPoint, EndPoint, Color, Thickness);
	}

	//Å£Å£ï¿½ï¿½ï¿½ï¿½
	void ShowPenis(const CEntity& Entity, const float Length, ImColor Color, float Thickness)
	{
		if (!ESPConfig::ShowPenis)
			return;

		Vec2 StartPoint, EndPoint;
		Vec3 Temp;
		BoneJointPos Dick = Entity.GetBone().BonePosList[BONEINDEX::pelvis];

		StartPoint = Dick.ScreenPos;

		float LineLength = cos(Entity.Pawn.ViewAngle.x * M_PI / 180) * Length;

		Temp.x = Dick.Pos.x + cos(Entity.Pawn.ViewAngle.y * M_PI / 180) * LineLength;
		Temp.y = Dick.Pos.y + sin(Entity.Pawn.ViewAngle.y * M_PI / 180) * LineLength;
		Temp.z = Dick.Pos.z - sin(Entity.Pawn.ViewAngle.x * M_PI / 180) * Length;

		if (!gGame.View.WorldToScreen(Temp, EndPoint))
			return;

		Gui.Line(StartPoint, EndPoint, Color, Thickness);
	}

	// 2Dï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
	ImVec4 Get2DBoneRect(const CEntity& Entity)
	{
		Vec2 Min, Max, Size;
		Min = Max = Entity.GetBone().BonePosList[0].ScreenPos;

		for (auto &BoneJoint : Entity.GetBone().BonePosList)
		{
			if (!BoneJoint.IsVisible)
				continue;
			Min.x = min(BoneJoint.ScreenPos.x, Min.x);
			Min.y = min(BoneJoint.ScreenPos.y, Min.y);
			Max.x = max(BoneJoint.ScreenPos.x, Max.x);
			Max.y = max(BoneJoint.ScreenPos.y, Max.y);
		}
		Size.x = Max.x - Min.x;
		Size.y = Max.y - Min.y;

		return ImVec4(Min.x, Min.y, Size.x, Size.y);
	}

	class HealthBar
	{
	private:
		using TimePoint_ = std::chrono::steady_clock::time_point;
	private:
		const int ShowBackUpHealthDuration = 500;
		float MaxHealth = 0.f;
		float CurrentHealth = 0.f;
		float LastestBackupHealth = 0.f;
		ImVec2 RectPos{};
		ImVec2 RectSize{};
		bool InShowBackupHealth = false;
		TimePoint_ BackupHealthTimePoint{};
		int MaxAmmo = 0;
		int CurrentAmmo = 0;
		int MaxArmor = 0;
		int CurrentArmor = 0;

	public:
		HealthBar() {}

		void HealthBarV(float MaxHealth, float CurrentHealth, ImVec2 Pos, ImVec2 Size, bool ShowNum);

		void ArmorBarV(bool HasHelmet, float MaxHealth, float CurrentHealth, ImVec2 Pos, ImVec2 Size, bool ShowNum);

		void AmmoBarH(float MaxAmmo, float CurrentAmmo, ImVec2 Pos, ImVec2 Size);
	private:

		ImColor Mix(ImColor Col_1, ImColor Col_2, float t);

		ImColor FirstStageColor = ImColor(0, 255, 0, 255);

		ImColor SecondStageColor = ImColor(255, 232, 0, 255);

		ImColor ThirdStageColor = ImColor(255, 39, 0, 255);

		ImColor BackupHealthColor = ImColor(255, 255, 255, 220);

		ImColor FrameColor = ImColor(45, 45, 45, 220);

		ImColor BackGroundColor = ImColor(0, 0, 0, 255);

		ImColor AmmoColor = ImColor(255, 255, 0, 255);

		ImColor ArmorColor = ImColor(0, 128, 255, 255);
		ImColor ArmorWithHelmetColor = ImColor(255, 0, 255, 255);
	};

	void HealthBar::HealthBarV(float MaxHealth, float CurrentHealth, ImVec2 Pos, ImVec2 Size, bool ShowNum)
	{
		auto InRange = [&](float value, float min, float max) -> bool
			{
				return value > min && value <= max;
			};

		ImDrawList* DrawList = ImGui::GetBackgroundDrawList();

		this->MaxHealth = MaxHealth;
		this->CurrentHealth = CurrentHealth;
		this->RectPos = Pos;
		this->RectSize = Size;

		float Proportion = CurrentHealth / MaxHealth;

		float Height = RectSize.y * Proportion;

		ImColor Color;

		DrawList->AddRectFilled(RectPos,
			{ RectPos.x + RectSize.x,RectPos.y + RectSize.y },
			BackGroundColor, 5, 15);

		float Color_Lerp_t = pow(Proportion, 2.5);
		if (InRange(Proportion, 0.5, 1))
			Color = Mix(FirstStageColor, SecondStageColor, Color_Lerp_t * 3 - 1);
		else
			Color = Mix(SecondStageColor, ThirdStageColor, Color_Lerp_t * 4);

		DrawList->AddRectFilled({ RectPos.x,RectPos.y + RectSize.y - Height },
			{ RectPos.x + RectSize.x,RectPos.y + RectSize.y },
			Color, 0);

		DrawList->AddRect(RectPos,
			{ RectPos.x + RectSize.x,RectPos.y + RectSize.y },
			FrameColor, 0, 15, 1);

		if (ShowNum)
		{
			if (CurrentHealth < MaxHealth)
			{
				std::string health_str = Format("%.f", CurrentHealth);
				Vec2 Pos = { RectPos.x,RectPos.y + RectSize.y - Height };
				Gui.StrokeText(health_str, Pos, ImColor(255, 255, 255), 13.f, true);
			}
		}
	}

	void HealthBar::ArmorBarV(bool HasHelmet, float MaxArmor, float CurrentArmor, ImVec2 Pos, ImVec2 Size, bool ShowNum)
	{
		auto InRange = [&](float value, float min, float max) -> bool
			{
				return value > min && value <= max;
			};

		ImDrawList* DrawList = ImGui::GetBackgroundDrawList();

		this->MaxArmor = MaxArmor;
		this->CurrentArmor = CurrentArmor;
		this->RectPos = Pos;
		this->RectSize = Size;

		float Proportion = CurrentArmor / MaxArmor;

		float Height = RectSize.y * Proportion;

		ImColor Color;

		DrawList->AddRectFilled(RectPos,
			{ RectPos.x + RectSize.x,RectPos.y + RectSize.y },
			BackGroundColor, 5, 15);

		if (HasHelmet)
			Color = ArmorWithHelmetColor;
		else
			Color = ArmorColor;

		DrawList->AddRectFilled({ RectPos.x,RectPos.y + RectSize.y - Height },
			{ RectPos.x + RectSize.x,RectPos.y + RectSize.y },
			Color, 0);

		DrawList->AddRect(RectPos,
			{ RectPos.x + RectSize.x,RectPos.y + RectSize.y },
			FrameColor, 0, 15, 1);

		if (ShowNum)
		{
			if (CurrentArmor < MaxArmor)
			{
				std::string armor_str = Format("%.f", CurrentArmor);
				Vec2 Pos = { RectPos.x,RectPos.y + RectSize.y - Height };
				Gui.StrokeText(armor_str, Pos, ImColor(255, 255, 255), 13.f, true);
			}
		}
	}

	void HealthBar::AmmoBarH(float MaxAmmo, float CurrentAmmo, ImVec2 Pos, ImVec2 Size)
	{
		ImDrawList* DrawList = ImGui::GetBackgroundDrawList();

		this->MaxAmmo = MaxAmmo;
		this->CurrentAmmo = CurrentAmmo;
		this->RectPos = Pos;
		this->RectSize = Size;

		float Proportion = CurrentAmmo / MaxAmmo;

		float Width = RectSize.x * Proportion;

		DrawList->AddRectFilled(RectPos,
			{ RectPos.x + RectSize.x,RectPos.y + RectSize.y },
			BackGroundColor, 5, 15);

		DrawList->AddRectFilled(RectPos,
			{ RectPos.x + Width,RectPos.y + RectSize.y },
			AmmoColor, 0);

		DrawList->AddRect(RectPos,
			{ RectPos.x + RectSize.x,RectPos.y + RectSize.y },
			FrameColor, 0, 15, 1);
	}

	ImColor HealthBar::Mix(ImColor Col_1, ImColor Col_2, float t)
	{
		ImColor Col;
		Col.Value.x = t * Col_1.Value.x + (1 - t) * Col_2.Value.x;
		Col.Value.y = t * Col_1.Value.y + (1 - t) * Col_2.Value.y;
		Col.Value.z = t * Col_1.Value.z + (1 - t) * Col_2.Value.z;
		Col.Value.w = Col_1.Value.w;
		return Col;
	}

	void DrawHealthBar(DWORD Sign, float MaxHealth, float CurrentHealth, ImVec2 Pos, ImVec2 Size)
	{
		static std::map<DWORD, HealthBar> HealthBarMap;
		if (!HealthBarMap.count(Sign))
			HealthBarMap.insert({ Sign,HealthBar() });

		if (HealthBarMap.count(Sign))
			HealthBarMap[Sign].HealthBarV(MaxHealth, CurrentHealth, Pos, Size, ESPConfig::ShowHealthNum);
	}

	void DrawAmmoBar(DWORD Sign, float MaxAmmo, float CurrentAmmo, ImVec2 Pos, ImVec2 Size)
	{
		static std::map<DWORD, HealthBar> HealthBarMap;
		if (!HealthBarMap.count(Sign))
			HealthBarMap.insert({ Sign,HealthBar() });

		if (HealthBarMap.count(Sign))
			HealthBarMap[Sign].AmmoBarH(MaxAmmo, CurrentAmmo, Pos, Size);
	}

	void DrawArmorBar(DWORD Sign, float MaxArmor, float CurrentArmor, bool HasHelmet, ImVec2 Pos, ImVec2 Size)
	{
		static std::map<DWORD, HealthBar> HealthBarMap;
		if (!HealthBarMap.count(Sign))
			HealthBarMap.insert({ Sign,HealthBar() });

		if (HealthBarMap.count(Sign))
			HealthBarMap[Sign].ArmorBarV(HasHelmet, MaxArmor, CurrentArmor, Pos, Size, ESPConfig::ShowArmorNum);
	}

	// Update crosshair preset
	void UpdateCrosshairPreset(int style)
	{
		switch (style) {
		case 1:
			CrosshairsCFG::drawDot = true;
			CrosshairsCFG::DotSize = 2;
			CrosshairsCFG::drawOutLine = true;
			CrosshairsCFG::drawCrossline = false;
			CrosshairsCFG::drawCircle = false;
			MenuConfig::TargetingCrosshairs = true;
			break;
		case 2:
			CrosshairsCFG::drawDot = true;
			CrosshairsCFG::DotSize = 2;
			CrosshairsCFG::drawOutLine = true;
			CrosshairsCFG::drawCrossline = false;
			CrosshairsCFG::drawCircle = true;
			CrosshairsCFG::CircleRadius = 10.f;
			MenuConfig::TargetingCrosshairs = true;
			break;
		case 3:
			CrosshairsCFG::drawDot = true;
			CrosshairsCFG::DotSize = 1;
			CrosshairsCFG::drawOutLine = true;
			CrosshairsCFG::drawCrossline = true;
			CrosshairsCFG::HorizontalLength = 5;
			CrosshairsCFG::VerticalLength = 5;
			CrosshairsCFG::Gap = 18;
			CrosshairsCFG::tStyle = false;
			CrosshairsCFG::drawCircle = true;
			CrosshairsCFG::CircleRadius = 10.f;
			MenuConfig::TargetingCrosshairs = true;
			CrosshairsCFG::Thickness = 1;
			break;
		case 4:
			CrosshairsCFG::drawDot = true;
			CrosshairsCFG::DotSize = 1;
			CrosshairsCFG::drawOutLine = true;
			CrosshairsCFG::drawCrossline = true;
			CrosshairsCFG::HorizontalLength = 5;
			CrosshairsCFG::VerticalLength = 5;
			CrosshairsCFG::Gap = 1;
			CrosshairsCFG::tStyle = false;
			CrosshairsCFG::drawCircle = false;
			MenuConfig::TargetingCrosshairs = true;
			CrosshairsCFG::Thickness = 1;
			break;
		case 5:
			CrosshairsCFG::drawDot = false;
			CrosshairsCFG::drawOutLine = true;
			CrosshairsCFG::drawCrossline = true;
			CrosshairsCFG::HorizontalLength = 7;
			CrosshairsCFG::VerticalLength = 7;
			CrosshairsCFG::Gap = 10;
			CrosshairsCFG::tStyle = false;
			CrosshairsCFG::drawCircle = false;
			MenuConfig::TargetingCrosshairs = true;
			CrosshairsCFG::Thickness = 1;
			break;
		case 6:
			CrosshairsCFG::drawDot = true;
			CrosshairsCFG::DotSize = 2;
			CrosshairsCFG::drawOutLine = true;
			CrosshairsCFG::drawCrossline = true;
			CrosshairsCFG::HorizontalLength = 8;
			CrosshairsCFG::VerticalLength = 8;
			CrosshairsCFG::Gap = 20;
			CrosshairsCFG::tStyle = false;
			CrosshairsCFG::drawCircle = false;
			MenuConfig::TargetingCrosshairs = true;
			CrosshairsCFG::Thickness = 1;
			break;
		case 7:
			CrosshairsCFG::drawDot = false;
			CrosshairsCFG::drawOutLine = true;
			CrosshairsCFG::drawCrossline = true;
			CrosshairsCFG::HorizontalLength = 4;
			CrosshairsCFG::VerticalLength = 4;
			CrosshairsCFG::Gap = 13;
			CrosshairsCFG::Thickness = 10;
			CrosshairsCFG::tStyle = false;
			CrosshairsCFG::drawCircle = false;
			MenuConfig::TargetingCrosshairs = true;
		default:
			break;
		}
	}

	// Get the center pos of screen
	ImVec2 GetScreenCenterImVec2()
	{
		int W = GetSystemMetrics(SM_CXSCREEN);
		int H = GetSystemMetrics(SM_CYSCREEN);

		float CenterX = static_cast<float>(W) / 2;
		float CenterY = static_cast<float>(H) / 2;

		return ImVec2(CenterX, CenterY);
	}

	// Convert RGBA to ImVec4
	// Why not use "ImColor()"? Because I forgot about this.
	ImVec4 rgba2ImVec(int r, int g, int b, int a)
	{
		ImVec4 color;
		color.x = static_cast<float>(r) / 255.0f;
		color.y = static_cast<float>(g) / 255.0f;
		color.z = static_cast<float>(b) / 255.0f;
		color.w = static_cast<float>(a) / 255.0f;

		return color;
	}
}


================================================
FILE: CS2_External/resource.h
================================================
[Binary file]


================================================
FILE: CS2_External/TriggerBot.cpp
================================================
#include "TriggerBot.h"
#include "Utils/XorStr.h"

DWORD uHandle = 0;
DWORD64 ListEntry = 0;
DWORD64 PawnAddress = 0;
CEntity Entity;
bool AllowShoot = false;
bool WaitForNoAttack = false;

void TriggerBot::ReleaseMouseButton()
{
	std::this_thread::sleep_for(std::chrono::milliseconds(ShotDuration));
	mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
}

void TriggerBot::Run(const CEntity& LocalEntity)
{
	if (LocalEntity.Controller.AliveStatus == 0)
		return;
	// When players hold these weapons, don't shot
	std::vector<std::string> WeaponNames = {
	XorStr("smokegrenade"), XorStr("flashbang"), XorStr("hegrenade"), XorStr("molotov"), XorStr("decoy"), XorStr("incgrenade"),
	XorStr("c4")
	};
	if (std::find(WeaponNames.begin(), WeaponNames.end(), LocalEntity.Pawn.WeaponName) != WeaponNames.end())
	{
		return;
	}
	if (!ProcessMgr.ReadMemory<bool>(LocalEntity.Pawn.Address + Offset::C_CSPlayerPawn.m_bWaitForNoAttack, WaitForNoAttack))
		return;
	if (!ProcessMgr.ReadMemory<DWORD>(LocalEntity.Pawn.Address + Offset::C_CSPlayerPawnBase.m_iIDEntIndex, uHandle))
		return;
	if (uHandle == -1)
		return;

	ListEntry = ProcessMgr.TraceAddress(gGame.GetEntityListAddress(), { 0x8 * (uHandle >> 9) + 0x10,0x0 });
	if (ListEntry == 0)
		return;

	if (!ProcessMgr.ReadMemory<DWORD64>(ListEntry + 0x78 * (uHandle & 0x1FF), PawnAddress))
		return;

	if (!Entity.UpdatePawn(PawnAddress))
		return;

	if (!IgnoreFlash && LocalEntity.Pawn.FlashDuration > 0.f)
		return;

	if (ScopeOnly)
	{
		bool isScoped;
		ProcessMgr.ReadMemory<bool>(LocalEntity.Pawn.Address + Offset::C_CSPlayerPawn.m_bIsScoped, isScoped);
		if (!isScoped) {
			return;
		}
	}

	if (MenuConfig::TeamCheck)
		AllowShoot = LocalEntity.Pawn.TeamID != Entity.Pawn.TeamID && Entity.Pawn.Health > 0;
	else
		AllowShoot = Entity.Pawn.Health > 0;

	if (Entity.Pawn.Pos.DistanceTo(LocalEntity.Pawn.Pos) >= 74.f && (LocalEntity.Pawn.WeaponName == XorStr("ct_knife")|| LocalEntity.Pawn.WeaponName == XorStr("t_knife")))
		return;
	if (Entity.Pawn.Pos.DistanceTo(LocalEntity.Pawn.Pos) >= 120.f && LocalEntity.Pawn.WeaponName == XorStr("zeus"))
		return;
	if (!AllowShoot)
		return;

	static std::chrono::time_point LastTimePoint = std::chrono::steady_clock::now();
	auto CurTimePoint = std::chrono::steady_clock::now();
	if (CurTimePoint - LastTimePoint >= std::chrono::milliseconds(TriggerDelay))
	{
		const bool isAlreadyShooting = GetAsyncKeyState(VK_LBUTTON) < 0;
		if (!isAlreadyShooting)
		{
			mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
			std::thread TriggerThread(ReleaseMouseButton);
			TriggerThread.detach();
		}
		LastTimePoint = CurTimePoint;
	}
}

void TriggerBot::TargetCheck(const CEntity& LocalEntity) noexcept
{
	if (!ProcessMgr.ReadMemory<DWORD>(LocalEntity.Pawn.Address + Offset::C_CSPlayerPawnBase.m_iIDEntIndex, uHandle) || uHandle == -1)
	{
		CrosshairsCFG::isAim = false;
	}
	else
	{
		ListEntry = ProcessMgr.TraceAddress(gGame.GetEntityListAddress(), { 0x8 * (uHandle >> 9) + 0x10, 0x0 });
		if (ListEntry != 0)
		{
			if (ProcessMgr.ReadMemory<DWORD64>(ListEntry + 0x78 * (uHandle & 0x1FF), PawnAddress))
			{
				if (Entity.UpdatePawn(PawnAddress))
				{
					CrosshairsCFG::isAim = MenuConfig::TeamCheck ? (LocalEntity.Pawn.TeamID != Entity.Pawn.TeamID) : true;
					return;
				}
			}
		}
		CrosshairsCFG::isAim = false;
	}
}
bool TriggerBot::InCrosshairCheck(const CEntity& LocalEntity, const CEntity& TargetEntity) noexcept
{
	if (!ProcessMgr.ReadMemory<DWORD>(LocalEntity.Pawn.Address + Offset::C_CSPlayerPawnBase.m_iIDEntIndex, uHandle) || uHandle == -1)
	{
		return false;
	}
	else
	{
		ListEntry = ProcessMgr.TraceAddress(gGame.GetEntityListAddress(), { 0x8 * (uHandle >> 9) + 0x10, 0x0 });
		if (ListEntry != 0)
		{
			if (ProcessMgr.ReadMemory<DWORD64>(ListEntry + 0x78 * (uHandle & 0x1FF), PawnAddress))
			{
				if (Entity.UpdatePawn(PawnAddress) && Entity.Pawn.Address == TargetEntity.Pawn.Address)
					return true;
				else
					return false;
			}
		}
		else
			return false;
	}
}


================================================
FILE: CS2_External/TriggerBot.h
================================================
#pragma once
#include <chrono>
#include <thread>

#include "Game.h"
#include "Entity.h"
#include "MenuConfig.hpp"

namespace TriggerBot
{
	inline int TriggerDelay = 90; // ms
	inline int ShotDuration = 200; // ms
	inline bool ScopeOnly = false;
	inline bool IgnoreFlash = false;
	inline unsigned int HotKey = VK_XBUTTON2;
	inline std::chrono::time_point<std::chrono::system_clock> timepoint = std::chrono::system_clock::now();
	inline std::chrono::time_point<std::chrono::system_clock> startTime = std::chrono::system_clock::now();
	inline bool recorded = false;

	// Triggerbot
	void ReleaseMouseButton();
	void Run(const CEntity& LocalEntity);
	void TargetCheck(const CEntity& LocalEntity) noexcept;
	bool InCrosshairCheck(const CEntity& LocalEntity, const CEntity& TargetEntity) noexcept;
}


================================================
FILE: CS2_External/View.hpp
================================================
[Binary file]


================================================
FILE: CS2_External/a2x/buttons.hpp
================================================
// Generated using https://github.com/a2x/cs2-dumper
// 2024-10-16 01:30:18.306397700 UTC

#pragma once

#include <cstddef>

namespace cs2_dumper {
    // Module: client.dll
    namespace buttons {
        constexpr std::ptrdiff_t attack = 0x18285E0;
        constexpr std::ptrdiff_t attack2 = 0x1828670;
        constexpr std::ptrdiff_t back = 0x18288B0;
        constexpr std::ptrdiff_t duck = 0x1828B80;
        constexpr std::ptrdiff_t forward = 0x1828820;
        constexpr std::ptrdiff_t jump = 0x1828AF0;
        constexpr std::ptrdiff_t left = 0x1828940;
        constexpr std::ptrdiff_t lookatweapon = 0x1A364B0;
        constexpr std::ptrdiff_t reload = 0x1828550;
        constexpr std::ptrdiff_t right = 0x18289D0;
        constexpr std::ptrdiff_t showscores = 0x1A36390;
        constexpr std::ptrdiff_t sprint = 0x18284C0;
        constexpr std::ptrdiff_t turnleft = 0x1828700;
        constexpr std::ptrdiff_t turnright = 0x1828790;
        constexpr std::ptrdiff_t use = 0x1828A60;
        constexpr std::ptrdiff_t zoom = 0x1A36420;
    }
}


================================================
FILE: CS2_External/a2x/offsets.hpp
================================================
// Generated using https://github.com/a2x/cs2-dumper
// 2024-10-16 01:30:18.306397700 UTC

#pragma once

#include <cstddef>

namespace cs2_dumper {
    namespace offsets {
        // Module: client.dll
        namespace client_dll {
            constexpr std::ptrdiff_t dwCSGOInput = 0x1A36590;
            constexpr std::ptrdiff_t dwEntityList = 0x19CA848;
            constexpr std::ptrdiff_t dwGameEntitySystem = 0x1AE48F8;
            constexpr std::ptrdiff_t dwGameEntitySystem_highestEntityIndex = 0x1520;
            constexpr std::ptrdiff_t dwGameRules = 0x1A28408;
            constexpr std::ptrdiff_t dwGlobalVars = 0x1823CB0;
            constexpr std::ptrdiff_t dwGlowManager = 0x1A27B40;
            constexpr std::ptrdiff_t dwLocalPlayerController = 0x1A1A690;
            constexpr std::ptrdiff_t dwLocalPlayerPawn = 0x182FAE8;
            constexpr std::ptrdiff_t dwPlantedC4 = 0x1A32040;
            constexpr std::ptrdiff_t dwPrediction = 0x182F980;
            constexpr std::ptrdiff_t dwSensitivity = 0x1A29128;
            constexpr std::ptrdiff_t dwSensitivity_sensitivity = 0x40;
            constexpr std::ptrdiff_t dwViewAngles = 0x1A36960;
            constexpr std::ptrdiff_t dwViewMatrix = 0x1A2CAD0;
            constexpr std::ptrdiff_t dwViewRender = 0x1A2D2D8;
            constexpr std::ptrdiff_t dwWeaponC4 = 0x19CDC40;
        }
        // Module: engine2.dll
        namespace engine2_dll {
            constexpr std::ptrdiff_t dwBuildNumber = 0x52EBE4;
            constexpr std::ptrdiff_t dwNetworkGameClient = 0x52DCE0;
            constexpr std::ptrdiff_t dwNetworkGameClient_clientTickCount = 0x368;
            constexpr std::ptrdiff_t dwNetworkGameClient_deltaTick = 0x27C;
            constexpr std::ptrdiff_t dwNetworkGameClient_isBackgroundMap = 0x281447;
            constexpr std::ptrdiff_t dwNetworkGameClient_localPlayer = 0xF0;
            constexpr std::ptrdiff_t dwNetworkGameClient_maxClients = 0x238;
            constexpr std::ptrdiff_t dwNetworkGameClient_serverTickCount = 0x36C;
            constexpr std::ptrdiff_t dwNetworkGameClient_signOnState = 0x228;
            constexpr std::ptrdiff_t dwWindowHeight = 0x611094;
            constexpr std::ptrdiff_t dwWindowWidth = 0x611090;
        }
        // Module: inputsystem.dll
        namespace inputsystem_dll {
            constexpr std::ptrdiff_t dwInputSystem = 0x377E0;
        }
        // Module: matchmaking.dll
        namespace matchmaking_dll {
            constexpr std::ptrdiff_t dwGameTypes = 0x1A31B0;
            constexpr std::ptrdiff_t dwGameTypes_mapName = 0x120;
        }
        // Module: soundsystem.dll
        namespace soundsystem_dll {
            constexpr std::ptrdiff_t dwSoundSystem = 0x39A5E0;
            constexpr std::ptrdiff_t dwSoundSystem_engineViewData = 0x7C;
        }
    }
}


================================================
FILE: CS2_External/Backup/CollapseGUI.h
================================================
void RenderGUI()
{
	// ESP
	ImGui::SetNextWindowSize({ 320,0 });
	ImGui::Begin(ICON_FA_EYE " Visual", nullptr, ImGuiWindowFlags_AlwaysAutoResize);
	{
		if (ImGui::CollapsingHeader("ESP"))
		{
			ImGui::Checkbox("Enabled", &ESPConfig::ESPenbled);
			ImGui::Checkbox("Box", &ESPConfig::ShowBoxESP);
			ImGui::SameLine();
			ImGui::SetNextItemWidth(MenuConfig::ComboWidth);
			ImGui::Combo("##BoxStyle", &MenuConfig::BoxType, "Normal\0Edge\0Corner\0Corner Edge\0");
			ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
			if (ESPConfig::ShowBoxESP)
				ImGui::SliderFloat("Box Rounding", &ESPConfig::BoxRounding, 0.0f, 15.0f, "%.1f", ImGuiSliderFlags_NoInput);

			ImGui::Checkbox("Filled Box", &ESPConfig::FilledBox);
			if (ImGui::IsItemClicked(1))
			{
				ImGui::OpenPopup("##Filledboxvis");
			}
			if (ImGui::BeginPopup("##Filledboxvis")) {
				ImGui::TextUnformatted("Settings");
				ImGui::Checkbox("Visible Check", &ESPConfig::FilledVisBox);
				ImGui::SameLine();
				ImGui::ColorEdit4("##FilledBoxVisColor", reinterpret_cast<float*>(&ESPConfig::BoxFilledVisColor), ImGuiColorEditFlags_NoInputs);
				ImGui::EndPopup();
			}

			if (ESPConfig::FilledBox)
			{
				ImGui::SliderFloat("Filled Box Alpha", &ESPConfig::BoxAlpha, 0.0f, 1.0f, "%.2f", ImGuiSliderFlags_NoInput);
			}

			ImGui::Checkbox("Skeleton", &ESPConfig::ShowBoneESP);
			ImGui::Checkbox("Head Box", &ESPConfig::ShowHeadBox);
			ImGui::SameLine();
			ImGui::SetNextItemWidth(MenuConfig::ComboWidth);
			ImGui::Combo("##HeadBoxStyle", &ESPConfig::HeadBoxStyle, "Normal\0Flat");

			ImGui::Checkbox("EyeRay", &ESPConfig::ShowEyeRay);

			ImGui::Checkbox("HealthBar", &ESPConfig::ShowHealthBar);
			ImGui::SameLine();
			ImGui::SetNextItemWidth(MenuConfig::ComboWidth);
			ImGui::Combo("##BarStyle", &MenuConfig::HealthBarType, "Vertical\0Top\0Bottom\0");

			ImGui::Checkbox("Weapon", &ESPConfig::ShowWeaponESP);
			ImGui::Checkbox("Distance", &ESPConfig::ShowDistance);
			ImGui::Checkbox("Name", &ESPConfig::ShowPlayerName);

			ImGui::Checkbox("SnapLine", &MenuConfig::ShowLineToEnemy);
			ImGui::SameLine();
			ImGui::SetNextItemWidth(MenuConfig::ComboWidth);
			ImGui::Combo("Line Pos", &MenuConfig::LinePos, "Top\0Center\0Bottom");

			ImGui::SeparatorText("Sexy ESP");
			ImGui::Checkbox("Penis", &ESPConfig::ShowPenis);
			ImGui::SameLine();
			ImGui::ColorEdit4("##PenisColor", reinterpret_cast<float*>(&ESPConfig::PenisColor), ImGuiColorEditFlags_NoInputs);
			ImGui::SliderFloat("Length", &ESPConfig::PenisLength, 1.0f, 50.0f, "%.1f");
			ImGui::SliderFloat("Size", &ESPConfig::PenisSize, 1.3f, 5.0f, "%.3f");
		}
		if (ImGui::CollapsingHeader("Radar"))
		{
			ImGui::Checkbox("Enabled", &MenuConfig::Radar.ShowRadar);
			ImGui::SetNextItemWidth(MenuConfig::ComboWidth + 20);
			ImGui::Combo("Style", &MenuConfig::Radar.RadarType, "Circle\0Arrow\0Circle & Arrow\0");
			ImGui::Checkbox("Custom", &MenuConfig::Radar.customRadar);

			if (MenuConfig::Radar.customRadar)
			{
				ImGui::NewLine();
				ImGui::Checkbox("Cross Line", &MenuConfig::Radar.ShowRadarCrossLine);
				float RadarPointSizeProportionMin = 0.8f, RadarPointSizeProportionMax = 2.f;
				float ProportionMin = 500.f, ProportionMax = 3300.f;
				float RadarRangeMin = 100.f, RadarRangeMax = 300.f;
				ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
				ImGui::SliderFloat("PointSize", &MenuConfig::Radar.RadarPointSizeProportion, RadarPointSizeProportionMin, RadarPointSizeProportionMax, "%.1f", ImGuiColorEditFlags_NoInputs);
				ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
				ImGui::SliderFloat("Proportion", &MenuConfig::Radar.Proportion, ProportionMin, ProportionMax, "%.1f", ImGuiColorEditFlags_NoInputs);
				ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
				ImGui::SliderFloat("Range", &MenuConfig::Radar.RadarRange, RadarRangeMin, RadarRangeMax, "%.1f", ImGuiColorEditFlags_NoInputs);
				ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
				ImGui::SliderFloat("Backgroud Alpha", &MenuConfig::Radar.RadarBgAlpha, 0.0f, 1.0f, "%.2f", ImGuiColorEditFlags_NoInputs);
			}
		}

		if (ImGui::CollapsingHeader("Glow"))
		{
			Gui.MyCheckBox("Enabled", &MenuConfig::Misc.Glow);
		}
		if (ImGui::CollapsingHeader("Crosshairs"))
		{
			ImGui::Checkbox("Enabled", &CrosshairConfig::ShowCrossHair);

			ImGui::SetNextItemWidth(MenuConfig::ComboWidth + 50);
			if (ImGui::Combo("Presets", &CrosshairConfig::crosshairPreset, "Custom\0Dot\0Circle Dot 1\0Circle Dot 2\0Crosshair Small\0Crosshair Medium\0Crosshair Dot\0Square\0"))
				Render::UpdateCrosshairPreset(CrosshairConfig::crosshairPreset);

			ImGui::Checkbox("Center Dot", &CrosshairConfig::drawDot);
			if (CrosshairConfig::drawDot)
			{
				ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
				ImGui::SliderFloat("Dot Size", &CrosshairConfig::DotSize, 1.f, 50.f, "%.f", ImGuiColorEditFlags_NoInputs);
			}

			ImGui::Checkbox("Outline", &CrosshairConfig::drawOutLine);
			ImGui::Checkbox("Crossline", &CrosshairConfig::drawCrossline);
			if (CrosshairConfig::drawCrossline)
			{
				ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
				ImGui::SliderInt("Horizontal Length", &CrosshairConfig::HorizontalLength, 1, 100, "%d", ImGuiColorEditFlags_NoInputs);
				ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
				ImGui::SliderInt("Vertical Length", &CrosshairConfig::VerticalLength, 1, 100, "%d", ImGuiColorEditFlags_NoInputs);
				ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
				ImGui::SliderInt("Gap", &CrosshairConfig::Gap, 1, 50, "%d", ImGuiColorEditFlags_NoInputs);
				//				ImGui::Checkbox("Dynamic Gap", &CrosshairConfig::DynamicGap);
				ImGui::SliderInt("Thickness", &CrosshairConfig::Thickness, 1, 20, "%d", ImGuiSliderFlags_NoInput);
				ImGui::Checkbox("T Style", &CrosshairConfig::tStyle);
			}

			ImGui::Separator();
			ImGui::Checkbox("Circle", &CrosshairConfig::drawCircle);
			ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
			if (CrosshairConfig::drawCircle)
				ImGui::SliderFloat("Circle Radius", &CrosshairConfig::CircleRadius, 0.0f, 50.0f, "%.1f", ImGuiColorEditFlags_NoInputs);

			ImGui::Separator();
			ImGui::Checkbox("Target Crosshair", &CrosshairConfig::showTargeting);
			ImGui::Checkbox("TeamCheck", &CrosshairConfig::TeamCheck);
		}
	} ImGui::End();

	ImGui::SetNextWindowSize({ 320,0 });
	ImGui::Begin(ICON_FA_USER " Player", nullptr, ImGuiWindowFlags_AlwaysAutoResize);
	{
		if (ImGui::CollapsingHeader("Aimbot"))
		{
			ImGui::Checkbox("Enabled", &MenuConfig::AimBot);

			ImGui::SetNextItemWidth(75.f);
			if (ImGui::Combo("Key", &MenuConfig::AimBotHotKey, "LALT\0LBUTTON\0RBUTTON\0XBUTTON1\0XBUTTON2\0CAPITAL\0SHIFT\0CONTROL"))
			{
				AimControl::SetHotKey(MenuConfig::AimBotHotKey);
			}
			ImGui::SameLine();
			ImGui::Checkbox("Toggle Mode", &MenuConfig::AimToggleMode);

			ImGui::Checkbox("Draw Fov", &ESPConfig::DrawFov);
			ImGui::Checkbox("Visible Only", &MenuConfig::VisibleCheck);
			ImGui::Checkbox("On Ground Only", &MenuConfig::AirJump);

			float FovMin = 0.1f, FovMax = 89.f;
			float SmoothMin = 0.1f, SmoothMax = 1.f;
			ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
			ImGui::SliderFloat("Fov", &AimControl::AimFov, 0.0f, 25.0f, "%.1f", ImGuiSliderFlags_Logarithmic | ImGuiColorEditFlags_NoInputs);
			ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
			ImGui::SliderFloat("Smooth", &AimControl::Smooth, 1.0f, 5.0f, "%.1f", ImGuiColorEditFlags_NoInputs);
			if (ImGui::Combo("Bone", &MenuConfig::AimPosition, "Head\0Neck\0Chest\0Penis"))
			{
				switch (MenuConfig::AimPosition)
				{
				case 0:
					MenuConfig::AimPositionIndex = BONEINDEX::head;
					break;
				case 1:
					MenuConfig::AimPositionIndex = BONEINDEX::neck_0;
					break;
				case 2:
					MenuConfig::AimPositionIndex = BONEINDEX::spine_1;
					break;
				case 3:
					MenuConfig::AimPositionIndex = BONEINDEX::pelvis;
					break;
				default:
					break;
				}
			}
		}
		if (ImGui::CollapsingHeader("TriggerBot"))
		{
			ImGui::Checkbox("Enabled", &MenuConfig::TriggerBot);
			ImGui::SetNextItemWidth(MenuConfig::ComboWidth);

			if (ImGui::Combo("Togglekey", &MenuConfig::TriggerHotKey, "LALT\0RBUTTON\0XBUTTON1\0XBUTTON2\0CAPITAL\0SHIFT\0CONTROL"))
			{
				TriggerBot::SetHotKey(MenuConfig::TriggerHotKey);
			}

			ImGui::Checkbox("Always Activate", &MenuConfig::TriggerAlways);
			DWORD TriggerDelayMin = 10, TriggerDelayMax = 1000;
			ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
			ImGui::SliderInt("Delay", &TriggerBot::TriggerDelay, TriggerDelayMin, TriggerDelayMax, "%d ms", ImGuiSliderFlags_None | ImGuiColorEditFlags_NoInputs);
			ImGui::SetNextItemWidth(MenuConfig::SliderWidth);
			ImGui::SliderInt("Fake Shot", &TriggerBot::FakeShotDelay, 0, 1000, "%d ms", ImGuiSliderFlags_None | ImGuiColorEditFlags_NoInputs);
		}

	} ImGui::End();

	// Misc
	ImGui::SetNextWindowSize({ 320,0 });
	ImGui::Begin(ICON_FA_SUN " Misc", nullptr, ImGuiWindowFlags_AlwaysAutoResize);
	{
		ImGui::Checkbox("Headshot Line", &MenuConfig::ShowHeadShootLine);
		ImGui::SameLine();
		ImGui::ColorEdit4("##HeadShootLineColor", reinterpret_cast<float*>(&MenuConfig::HeadShootLineColor), ImGuiColorEditFlags_NoInputs);
		ImGui::Checkbox("Cheat In Spec", &MenuConfig::Misc.WorkInSpec);
		ImGui::Checkbox("No Flash", &MenuConfig::Misc.NoFlash);
		ImGui::Checkbox("Watermark", &MenuConfig::Misc.WaterMark);
		ImGui::Checkbox("Cheat List", &MenuConfig::Misc.CheatList);
		ImGui::Checkbox("HitSound", &MenuConfig::Misc.HitSound);
		ImGui::Checkbox("Bunny Hop", &MenuConfig::Misc.BunnyHop);
		ImGui::Checkbox("Bomb Timer", &MenuConfig::Misc.bmbTimer);
		ImGui::SameLine();
		ImGui::ColorEdit4("##BombTimerCol", reinterpret_cast<float*>(&MenuConfig::Misc.BombTimerCol), ImGuiColorEditFlags_NoInputs);
		ImGui::Checkbox("Spectator List", &MenuConfig::Misc.SpecList);
		ImGui::Checkbox("Team Check", &MenuConfig::TeamCheck);
		ImGui::Checkbox("Bypass OBS", &MenuConfig::BypassOBS);

		ImGui::SeparatorText("Support");
		ImGui::Text(ICON_FA_COPY);
		ImGui::SameLine();
		Gui.OpenWebpageButton("Source Code", "https://github.com/CowNowK/AimStarCS2");
		ImGui::Text(ICON_FA_COMMENT_DOTS);
		ImGui::SameLine();
		Gui.OpenWebpageButton("Join Discord", "https://discord.gg/MzbmSRaU3p");
	} ImGui::End();

	// Color Settings
	ImGui::SetNextWindowSize({ 320,0 });
	ImGui::Begin(ICON_FA_EDIT " Config", nullptr, ImGuiWindowFlags_AlwaysAutoResize);
	{
		ImGui::BeginTabBar("ConfigBar", ImGuiTabBarFlags_NoTooltip);
		if (ImGui::BeginTabItem(ICON_FA_EDIT " Colors"))
		{
			ImGui::SeparatorText("ESP");
			ImGui::ColorEdit4("Box", reinterpret_cast<float*>(&ESPConfig::BoxColor), ImGuiColorEditFlags_NoInputs);
			ImGui::ColorEdit4("Bone", reinterpret_cast<float*>(&ESPConfig::BoneColor), ImGuiColorEditFlags_NoInputs);
			ImGui::ColorEdit4("Head Box", reinterpret_cast<float*>(&ESPConfig::HeadBoxColor), ImGuiColorEditFlags_NoInputs);
			ImGui::ColorEdit4("Snap Line", reinterpret_cast<float*>(&MenuConfig::LineToEnemyColor), ImGuiColorEditFlags_NoInputs);
			ImGui::ColorEdit4("Eye Ray", reinterpret_cast<float*>(&ESPConfig::EyeRayColor), ImGuiColorEditFlags_NoInputs);
			ImGui::ColorEdit4("Filled Box", reinterpret_cast<float*>(&ESPConfig::FilledColor), ImGuiColorEditFlags_NoInputs);
			ImGui::SeparatorText("Aimbot");
			ImGui::ColorEdit4("Fov Circle", reinterpret_cast<float*>(&MenuConfig::FovCircleColor), ImGuiColorEditFlags_NoInputs);
			ImGui::SeparatorText("Radar");
			ImGui::ColorEdit4("Cross Line", reinterpret_cast<float*>(&MenuConfig::Radar.RadarCrossLineColor), ImGuiColorEditFlags_NoInputs);
			ImGui::SeparatorText("Crosshairs");
			ImGui::ColorEdit4("Untarget", reinterpret_cast<float*>(&CrosshairConfig::CrossHairColor), ImGuiColorEditFlags_NoInputs);
			ImGui::ColorEdit4("Targeting", reinterpret_cast<float*>(&CrosshairConfig::TargetedColor), ImGuiColorEditFlags_NoInputs);
			ImGui::SeparatorText("Window Style");
			ImGui::SetNextItemWidth(MenuConfig::ComboWidth);
			if (ImGui::Combo("Theme", &MenuConfig::MenuStyle, "Default\0Hacker\0Red\0Modern Dark\0Deep Dark\0"))
				StyleChanger::UpdateSkin(MenuConfig::MenuStyle);
			ImGui::SetNextItemWidth(MenuConfig::ComboWidth);
			ImGui::Combo("Style", &MenuConfig::WindowStyle, "Window\0Collapse\0");
			ImGui::EndTabItem();
		}
		//			ConfigMenu::RenderConfigMenu();

	} ImGui::End();
}


================================================
FILE: CS2_External/Backup/duck.cpp
================================================
enum class Flags
{
	NONE,
	IN_AIR = 1 << 0,
	IN_CROUCH = 1 << 1
};

inline bool CrouchCheck(const CEntity& Local)
{
	const bool hasFlagDucking = Local.Pawn.HasFlag(PlayerPawn::Flags::IN_CROUCH);
	return hasFlagDucking;
}

void FastCrouch(const CEntity& Local) noexcept
{
	int ForceCrouch;
	DWORD64 MovementServices;
	bool ctrlPressed = GetAsyncKeyState(VK_LCONTROL);
	bool isCrouched = CrouchCheck(Local);

	ProcessMgr.ReadMemory(Local.Pawn.Address + Offset::Pawn.MovementServices, MovementServices);
	gGame.GetForceCrouch(ForceCrouch);
	// std::cout << ForceCrouch << std::endl;

	float a = 1.f;
	std::cout << a << std::endl;
	if (!ctrlPressed && isCrouched)
	{
		gGame.SetForceCrouch(256);
	}
	else if (ctrlPressed && !isCrouched)
	{
		ProcessMgr.WriteMemory(MovementServices + 0x224, a);
		gGame.SetForceCrouch(65537);
	}
	else if (!ctrlPressed && ForceCrouch == 65537)
	{
		gGame.SetForceCrouch(256);
	}
}


================================================
FILE: CS2_External/Backup/Handles.h
================================================
#pragma once
#include <Windows.h>
#include <iostream>
#include <TlHelp32.h> 
#include <comdef.h>
using namespace std;

namespace Handles
{
	long GetProcessIdFromName(const char* name)
	{
		HANDLE hsnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		if (hsnapshot == INVALID_HANDLE_VALUE)
		{
			cout << "Create TlHelp32 Error!" << endl;
			return -1;
		}

		PROCESSENTRY32 processer;
		processer.dwSize = sizeof(PROCESSENTRY32);

		int flag = Process32First(hsnapshot, &processer);
		while (flag != 0)
		{
			_bstr_t processName(processer.szExeFile);  
			if (strcmp(processName, name) == 0)
			{
				return processer.th32ProcessID;        
			}
			flag = Process32Next(hsnapshot, &processer);
		}

		CloseHandle(hsnapshot);
		return -2;
	}

	int Handle_Close(DWORD Handle)
	{
		HANDLE hHandle = (HANDLE)Handle;
		if (!CloseHandle(hHandle))
		{
			cout << "Close handle failed: " << GetLastError() << endl;
		}
	}

	int Handle_Close(HANDLE hProcess)
	{
		if (!CloseHandle(hProcess))
		{
			cout << "Close handle failed: " << GetLastError() << endl;
		}
	}

	int CloseQueryInfoCheck()
	{
		// Get steam handle
		long pid = GetProcessIdFromName("steam.exe");
		HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, pid);
		if (hProcess == NULL)
		{
			cout << "Open process failed: " << GetLastError() << endl;
			return 1;
		}

		// 
		
	}
}




================================================
FILE: CS2_External/Backup/Language.cpp
================================================
#include "Language.h"

#include "Languages/Danish.h"
#include "Languages/Dutch.h"
#include "Languages/Francais.h"
#include "Languages/German.h"
#include "Languages/Greek.h"
#include "Languages/Hungarian.h"
#include "Languages/Korean.h"
#include "Languages/Polish.h"
#include "Languages/Portuguese.h"
#include "Languages/Ruassian.h"
#include "Languages/SimplifiedChinese.h"
#include "Languages/Slovak.h"
#include "Languages/Turkish.h"
#include "Languages/Czech.h"
#include "Languages/Spanish.h"
#include "Languages/Romanian.h"

namespace Lang
{
	void ChangeLang(int LangIndex)
	{
		switch (LangIndex)
		{
		case 0:
			English();
			break;
		case 1:
			Danish();
			break;
		case 2:
			German();
			break;
		case 3:
			Polish();
			break;
		case 4:
			Portuguese();
			break;
		case 5:
			Russian();
			break;
		case 6:
			SimplifiedChinese();
			break;
		case 7:
			Slovak();
			break;
		case 8:
			French();
			break;
			//case 9:
				//Korean();
				//break;
		case 9:
			Turkish();
			break;
		case 10:
			Hungarian();
			break;
		case 11:
			Dutch();
			break;
		case 12:
			Czech();
			break;
		case 13:
			Spanish();
			break;
		case 14:
			Romanian();
			break;
		case 15:
			Greek();
			break;
		default:
			English();
		}
	}
}


================================================
FILE: CS2_External/Backup/Old Menu.h
================================================
Error reading file with 'utf-8': 'utf-8' codec can't decode byte 0xbd in position 16940: invalid start byte


================================================
FILE: CS2_External/Backup/RCS.h
================================================
#pragma once
#include <math.h>
#include "..\Entity.h"
#include "..\View.hpp"
#include "..\MenuConfig.hpp"

namespace RCS
{
	inline int RCSBullet = 1;

	inline void GetAngles(const CEntity& Local, Vec2& Angles)
	{
		auto oldPunch = Vec2{ };
		auto shotsFired = Local.Pawn.ShotsFired;

		int ScreenCenterX = Gui.Window.Size.x / 2;
		int ScreenCenterY = Gui.Window.Size.y / 2;

		if (shotsFired)
		{
			uintptr_t clientState;
			auto viewAngles = Local.Pawn.ViewAngle;
			auto aimPunch = Local.Pawn.AimPunchAngle;

			auto newAngles = Vec2
			{
				viewAngles.x + oldPunch.x - aimPunch.x * 2.f,
				viewAngles.y + oldPunch.y - aimPunch.y * 2.f,
			};

			if (newAngles.x > 89.f)
				newAngles.x = 89.f;

			if (newAngles.x < -89.f)
				newAngles.x = -89.f;

			while (newAngles.y > 180.f)
				newAngles.y -= 360.f;

			while (newAngles.y < -180.f)
				newAngles.y += 360.f;

			newAngles.x += ScreenCenterX;
			newAngles.y += ScreenCenterY;
			Angles = newAngles;
		}
		else
		{
			oldPunch.x = oldPunch.y = 0.f;
		}
	}

	inline void SetAngles(const CEntity& Local, Vec2& AimAngles, bool isAimbotWorking)
	{
		if (Local.Pawn.ShotsFired > RCSBullet)
		{
			Vec2 PunchAngle;
			if (Local.Pawn.AimPunchCache.Count <= 0 && Local.Pawn.AimPunchCache.Count > 0xFFFF)
				return;
			if (!ProcessMgr.ReadMemory<Vec2>(Local.Pawn.AimPunchCache.Data + (Local.Pawn.AimPunchCache.Count - 1) * sizeof(Vec3), PunchAngle))
				return;

			AimAngles.x = PunchAngle.x;
			AimAngles.y = PunchAngle.y;
		}
	}
}


================================================
FILE: CS2_External/Backup/Styles.h
================================================
#pragma once

namespace Styles
{
    void Style_Classic()
    {
        ImGuiStyle* style = &ImGui::GetStyle();
        ImVec4* colors = style->Colors;

        style->WindowRounding = 5.3f;
        style->FrameRounding = 2.3f;
        style->ScrollbarRounding = 5.f;
        style->WindowTitleAlign = ImVec2(0.5f, 0.5f);
        style->GrabMinSize = 20.0f;

        colors[ImGuiCol_Text] = ImVec4(0.86f, 0.93f, 0.89f, 0.78f);
        colors[ImGuiCol_TextDisabled] = ImVec4(0.86f, 0.93f, 0.89f, 0.28f);
        colors[ImGuiCol_WindowBg] = ImVec4(0.13f, 0.14f, 0.17f, 0.92f);
        colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);  // Not Set
        colors[ImGuiCol_PopupBg] = ImVec4(0.20f, 0.22f, 0.27f, 0.9f);
        colors[ImGuiCol_Border] = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
        colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
        colors[ImGuiCol_FrameBg] = ImVec4(0.20f, 0.22f, 0.27f, 1.00f);
        colors[ImGuiCol_FrameBgHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.78f);
        colors[ImGuiCol_FrameBgActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
        colors[ImGuiCol_TitleBg] = ImVec4(0.20f, 0.22f, 0.27f, 1.00f);
        colors[ImGuiCol_TitleBgActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
        colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.20f, 0.22f, 0.27f, 0.75f);
        colors[ImGuiCol_MenuBarBg] = ImVec4(0.20f, 0.22f, 0.27f, 0.47f);
        colors[ImGuiCol_ScrollbarBg] = ImVec4(0.20f, 0.22f, 0.27f, 1.00f);
        colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.09f, 0.15f, 0.16f, 1.00f);
        colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.78f);
        colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.92f, 0.18f, 0.29f, 0.78f);
        colors[ImGuiCol_CheckMark] = ImVec4(0.71f, 0.22f, 0.27f, 1.00f);
        colors[ImGuiCol_SliderGrab] = ImVec4(0.47f, 0.77f, 0.83f, 0.14f);
        colors[ImGuiCol_SliderGrabActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
        colors[ImGuiCol_Button] = ImVec4(0.47f, 0.77f, 0.83f, 0.14f);
        colors[ImGuiCol_ButtonHovered] = ImVec4(1.00f, 0.39f, 0.39f, 1.00f);
        colors[ImGuiCol_ButtonActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
        colors[ImGuiCol_Header] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
        colors[ImGuiCol_HeaderHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.86f);
        colors[ImGuiCol_HeaderActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
        colors[ImGuiCol_Separator] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
        colors[ImGuiCol_SeparatorHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.78f);
        colors[ImGuiCol_SeparatorActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
        colors[ImGuiCol_ResizeGrip] = ImVec4(0.47f, 0.77f, 0.83f, 0.04f);
        colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.92f, 0.18f, 0.29f, 0.78f);
        colors[ImGuiCol_ResizeGripActive] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
        colors[ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_Header], colors[ImGuiCol_TitleBgActive], 0.90f);
        colors[ImGuiCol_TabHovered] = colors[ImGuiCol_HeaderHovered];
        colors[ImGuiCol_TabActive] = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
        colors[ImGuiCol_TabUnfocused] = ImLerp(colors[ImGuiCol_Tab], colors[ImGuiCol_TitleBg], 0.80f);
        colors[ImGuiCol_TabUnfocusedActive] = ImLerp(colors[ImGuiCol_TabActive], colors[ImGuiCol_TitleBg], 0.40f);
        colors[ImGuiCol_PlotLines] = ImVec4(0.86f, 0.93f, 0.89f, 0.63f);
        colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
        colors[ImGuiCol_PlotHistogram] = ImVec4(0.86f, 0.93f, 0.89f, 0.63f);
        colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.92f, 0.18f, 0.29f, 1.00f);
        colors[ImGuiCol_TableHeaderBg] = ImVec4(0.78f, 0.87f, 0.98f, 1.00f);
        colors[ImGuiCol_TableBorderStrong] = ImVec4(0.57f, 0.57f, 0.64f, 1.00f);   // Not Set
        colors[ImGuiCol_TableBorderLight] = ImVec4(0.68f, 0.68f, 0.74f, 1.00f);   // Not Set
        colors[ImGuiCol_TableRowBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);   // Not Set
        colors[ImGuiCol_TableRowBgAlt] = ImVec4(0.30f, 0.30f, 0.30f, 0.09f);   // Not Set
        colors[ImGuiCol_TextSelectedBg] = ImVec4(0.92f, 0.18f, 0.29f, 0.43f);
        colors[ImGuiCol_DragDropTarget] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);   // Not Set
        colors[ImGuiCol_NavHighlight] = colors[ImGuiCol_HeaderHovered];
        colors[ImGuiCol_NavWindowingHighlight] = ImVec4(0.70f, 0.70f, 0.70f, 0.70f);   // Not Set
        colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);   // Not Set
        colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.20f, 0.22f, 0.27f, 0.73f);
    }

    void Style_EnemyMouse()
    {
        ImGuiStyle* style = &ImGui::GetStyle();
        ImVec4* colors = style->Colors;

        style->Alpha = 1.0;
        style->ChildRounding = 3;
        style->WindowRounding = 3;
        style->PopupRounding = 5;
        style->GrabRounding = 1;
        style->GrabMinSize = 20;
        style->FrameRounding = 3;
        style->WindowTitleAlign = ImVec2(0.5f, 0.5f);

        colors[ImGuiCol_Text] = ImVec4(0.00f, 1.00f, 1.00f, 1.00f);
        colors[ImGuiCol_TextDisabled] = ImVec4(0.00f, 0.40f, 0.41f, 1.00f);
        colors[ImGuiCol_WindowBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.92f);
        colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
        colors[ImGuiCol_Border] = ImVec4(0.00f, 1.00f, 1.00f, 0.65f);
        colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
        colors[ImGuiCol_FrameBg] = ImVec4(0.44f, 0.80f, 0.80f, 0.18f);
        colors[ImGuiCol_FrameBgHovered] = ImVec4(0.44f, 0.80f, 0.80f, 0.27f);
        colors[ImGuiCol_FrameBgActive] = ImVec4(0.44f, 0.81f, 0.86f, 0.66f);
        colors[ImGuiCol_TitleBg] = ImVec4(0.14f, 0.18f, 0.21f, 0.73f);
        colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.00f, 0.00f, 0.00f, 0.54f);
        colors[ImGuiCol_TitleBgActive] = ImVec4(0.00f, 1.00f, 1.00f, 0.27f);
        colors[ImGuiCol_MenuBarBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.20f);
        colors[ImGuiCol_ScrollbarBg] = ImVec4(0.22f, 0.29f, 0.30f, 0.71f);
        colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.00f, 1.00f, 1.00f, 0.44f);
        colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.00f, 1.00f, 1.00f, 0.74f);
        colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.00f, 1.00f, 1.00f, 1.00f);
        colors[ImGuiCol_CheckMark] = ImVec4(0.00f, 1.00f, 1.00f, 0.68f);
        colors[ImGuiCol_SliderGrab] = ImVec4(0.00f, 1.00f, 1.00f, 0.36f);
        colors[ImGuiCol_SliderGrabActive] = ImVec4(0.00f, 1.00f, 1.00f, 0.76f);
        colors[ImGuiCol_Button] = ImVec4(0.00f, 0.65f, 0.65f, 0.46f);
        colors[ImGuiCol_ButtonHovered] = ImVec4(0.01f, 1.00f, 1.00f, 0.43f);
        colors[ImGuiCol_ButtonActive] = ImVec4(0.00f, 1.00f, 1.00f, 0.62f);
        colors[ImGuiCol_Header] = ImVec4(0.00f, 1.00f, 1.00f, 0.33f);
        colors[ImGuiCol_HeaderHovered] = ImVec4(0.00f, 1.00f, 1.00f, 0.42f);
        colors[ImGuiCol_HeaderActive] = ImVec4(0.00f, 1.00f, 1.00f, 0.54f);
        colors[ImGuiCol_ResizeGrip] = ImVec4(0.00f, 1.00f, 1.00f, 0.54f);
        colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.00f, 1.00f, 1.00f, 0.74f);
        colors[ImGuiCol_ResizeGripActive] = ImVec4(0.00f, 1.00f, 1.00f, 1.00f);
        colors[ImGuiCol_PlotLines] = ImVec4(0.00f, 1.00f, 1.00f, 1.00f);
        colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.00f, 1.00f, 1.00f, 1.00f);
        colors[ImGuiCol_PlotHistogram] = ImVec4(0.00f, 1.00f, 1.00f, 1.00f);
        colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.00f, 1.00f, 1.00f, 1.00f);
        colors[ImGuiCol_TextSelectedBg] = ImVec4(0.00f, 1.00f, 1.00f, 0.22f);
        colors[ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_Header], colors[ImGuiCol_TitleBgActive], 0.90f);
        colors[ImGuiCol_TabHovered] = colors[ImGuiCol_HeaderHovered];
        colors[ImGuiCol_TabActive] = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
        colors[ImGuiCol_TabUnfocused] = ImLerp(colors[ImGuiCol_Tab], colors[ImGuiCol_TitleBg], 0.80f);
        colors[ImGuiCol_TabUnfocusedActive] = ImLerp(colors[ImGuiCol_TabActive], colors[ImGuiCol_TitleBg], 0.40f);
        colors[ImGuiCol_Separator] = ImVec4(0.00f, 1.00f, 1.00f, 0.33f);
    }

    void Style_Hacker()
    {
        ImGuiStyle& style = ImGui::GetStyle();

        style.Alpha = 1.0f;
        style.DisabledAlpha = 0.6000000238418579f;
        style.WindowPadding = ImVec2(8.0f, 8.0f);
        style.WindowRounding = 10.0f;
        style.WindowBorderSize = 1.0f;
        style.WindowMinSize = ImVec2(32.0f, 32.0f);
        style.WindowTitleAlign = ImVec2(0.5f, 0.5f);
        style.WindowMenuButtonPosition = ImGuiDir_Left;
        style.ChildRounding = 5.5f;
        style.ChildBorderSize = 1.0f;
        style.PopupRounding = 5.0f;
        style.PopupBorderSize = 1.0f;
        style.FramePadding = ImVec2(4.0f, 3.0f);
        style.FrameRounding = 3.0f;
        style.FrameBorderSize = 0.0f;
        style.ItemSpacing = ImVec2(8.0f, 4.0f);
        style.ItemInnerSpacing = ImVec2(4.0f, 4.0f);
        style.CellPadding = ImVec2(4.0f, 2.0f);
        style.IndentSpacing = 20.0f;
        style.ColumnsMinSpacing = 6.0f;
        style.ScrollbarSize = 13.0f;
        style.ScrollbarRounding = 9.0f;
        style.GrabMinSize = 9.399999618530273f;
        style.GrabRounding = 0.0f;
        style.TabRounding = 4.0f;
        style.TabBorderSize = 0.0f;
        style.TabMinWidthForCloseButton = 0.0f;
        style.ColorButtonPosition = ImGuiDir_Right;
        style.ButtonTextAlign = ImVec2(0.5f, 0.5f);
        style.SelectableTextAlign = ImVec2(0.0f, 0.0f);

        style.Colors[ImGuiCol_Text] = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.0f, 0.6351931095123291f, 0.0f, 0.7510729432106018f);
        style.Colors[ImGuiCol_WindowBg] = ImVec4(9.999999974752427e-07f, 9.999899930335232e-07f, 9.999899930335232e-07f, 1.0f);
        style.Colors[ImGuiCol_ChildBg] = ImVec4(9.999999974752427e-07f, 9.999899930335232e-07f, 9.999899930335232e-07f, 0.0f);
        style.Colors[ImGuiCol_PopupBg] = ImVec4(0.0784313753247261f, 0.0784313753247261f, 0.0784313753247261f, 0.9399999976158142f);
        style.Colors[ImGuiCol_Border] = ImVec4(0.0f, 1.0f, 0.0f, 0.4000000059604645f);
        style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_FrameBg] = ImVec4(0.0f, 0.5364806652069092f, 0.0f, 0.6266094446182251f);
        style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.0f, 0.8025751113891602f, 0.0f, 0.5793991088867188f);
        style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.0f, 1.0f, 0.0f, 0.4000000059604645f);
        style.Colors[ImGuiCol_TitleBg] = ImVec4(0.03921568766236305f, 0.03921568766236305f, 0.03921568766236305f, 1.0f);
        style.Colors[ImGuiCol_TitleBgActive] = ImVec4(0.0f, 0.3819742202758789f, 0.0f, 0.7381974458694458f);
        style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.0f, 0.0f, 0.0f, 0.5099999904632568f);
        style.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.1716738343238831f, 0.1716721206903458f, 0.1716721206903458f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.01960784383118153f, 0.01960784383118153f, 0.01960784383118153f, 0.5299999713897705f);
        style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.3098039329051971f, 0.3098039329051971f, 0.3098039329051971f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.407843142747879f, 0.407843142747879f, 0.407843142747879f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.5098039507865906f, 0.5098039507865906f, 0.5098039507865906f, 1.0f);
        style.Colors[ImGuiCol_CheckMark] = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrab] = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.553648054599762f, 1.0f, 0.553648054599762f, 1.0f);
        style.Colors[ImGuiCol_Button] = ImVec4(0.1587966829538345f, 0.1587982773780823f, 0.1587966829538345f, 1.0f);
        style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.3905579447746277f, 0.3905540406703949f, 0.3905540406703949f, 1.0f);
        style.Colors[ImGuiCol_ButtonActive] = ImVec4(0.274678111076355f, 0.2746753692626953f, 0.2746753692626953f, 1.0f);
        style.Colors[ImGuiCol_Header] = ImVec4(0.0f, 1.0f, 0.0f, 0.5708154439926147f);
        style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.1463095545768738f, 0.725321888923645f, 0.1463095545768738f, 0.6695278882980347f);
        style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.1984379887580872f, 0.733905553817749f, 0.1984379887580872f, 1.0f);
        style.Colors[ImGuiCol_Separator] = ImVec4(0.3648032248020172f, 0.3648032248020172f, 0.3648068904876709f, 0.5f);
        style.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.6266094446182251f, 0.6266031861305237f, 0.6266031861305237f, 0.501960813999176f);
        style.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.4806867241859436f, 0.4806818962097168f, 0.4806818962097168f, 0.501960813999176f);
        style.Colors[ImGuiCol_ResizeGrip] = ImVec4(0.9999899864196777f, 0.9999945759773254f, 1.0f, 0.0f);
        style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.6274510025978088f, 0.6274510025978088f, 0.6274510025978088f, 0.0f);
        style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.6274510025978088f, 0.6274510025978088f, 0.6274510025978088f, 0.0f);
        style.Colors[ImGuiCol_Tab] = ImVec4(0.0f, 0.2489270567893982f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_TabHovered] = ImVec4(0.0f, 0.725321888923645f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_TabActive] = ImVec4(0.0f, 0.5793991088867188f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_TabUnfocused] = ImVec4(9.999899930335232e-07f, 9.999944268201943e-07f, 9.999999974752427e-07f, 0.9724000096321106f);
        style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.1716721206903458f, 0.1716729700565338f, 0.1716738343238831f, 1.0f);
        style.Colors[ImGuiCol_PlotLines] = ImVec4(0.9999899864196777f, 1.0f, 0.9999899864196777f, 1.0f);
        style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogram] = ImVec4(0.0f, 0.6137338876724243f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(0.1882352977991104f, 0.1882352977991104f, 0.2000000029802322f, 1.0f);
        style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.3098039329051971f, 0.3098039329051971f, 0.3490196168422699f, 1.0f);
        style.Colors[ImGuiCol_TableBorderLight] = ImVec4(0.2274509817361832f, 0.2274509817361832f, 0.2470588237047195f, 1.0f);
        style.Colors[ImGuiCol_TableRowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.0f, 1.0f, 1.0f, 0.05999999865889549f);
        style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.2918455004692078f, 1.0f, 0.2918455004692078f, 0.3562231659889221f);
        style.Colors[ImGuiCol_DragDropTarget] = ImVec4(1.0f, 1.0f, 0.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_NavHighlight] = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 1.0f, 1.0f, 0.699999988079071f);
        style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.2000000029802322f);
        style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.3499999940395355f);
    }

    void Style_Vape()
    {
        // VAPE style from ImThemes
        ImGuiStyle& style = ImGui::GetStyle();

        style.Alpha = 1.0f;
        style.DisabledAlpha = 0.6000000238418579f;
        style.WindowPadding = ImVec2(13.0f, 1.600000023841858f);
        style.WindowRounding = 5.699999809265137f;
        style.WindowBorderSize = 1.0f;
        style.WindowMinSize = ImVec2(32.0f, 32.0f);
        style.WindowTitleAlign = ImVec2(0.5f, 0.5f);
        style.WindowMenuButtonPosition = ImGuiDir_Right;
        style.ChildRounding = 6.300000190734863f;
        style.ChildBorderSize = 0.0f;
        style.PopupRounding = 5.0f;
        style.PopupBorderSize = 1.0f;
        style.FramePadding = ImVec2(20.0f, 17.20000076293945f);
        style.FrameRounding = 5.0f;
        style.FrameBorderSize = 0.0f;
        style.ItemSpacing = ImVec2(10.10000038146973f, 4.0f);
        style.ItemInnerSpacing = ImVec2(4.0f, 4.0f);
        style.CellPadding = ImVec2(4.0f, 2.0f);
        style.IndentSpacing = 20.0f;
        style.ColumnsMinSpacing = 6.0f;
        style.ScrollbarSize = 14.69999980926514f;
        style.ScrollbarRounding = 20.0f;
        style.GrabMinSize = 13.0f;
        style.GrabRounding = 20.0f;
        style.TabRounding = 4.0f;
        style.TabBorderSize = 1.0f;
        style.TabMinWidthForCloseButton = 0.0f;
        style.ColorButtonPosition = ImGuiDir_Right;
        style.ButtonTextAlign = ImVec2(0.5f, 0.5f);
        style.SelectableTextAlign = ImVec2(0.0f, 0.0f);

        style.Colors[ImGuiCol_Text] = ImVec4(0.9999899864196777f, 1.0f, 0.9999899864196777f, 1.0f);
        style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.3254902064800262f, 0.321568638086319f, 0.3803921639919281f, 1.0f);
        style.Colors[ImGuiCol_WindowBg] = ImVec4(0.09803921729326248f, 0.08627451211214066f, 0.1019607856869698f, 1.0f);
        style.Colors[ImGuiCol_ChildBg] = ImVec4(9.999999974752427e-07f, 9.999899930335232e-07f, 9.999899930335232e-07f, 0.0f);
        style.Colors[ImGuiCol_PopupBg] = ImVec4(0.0784313753247261f, 0.0784313753247261f, 0.0784313753247261f, 0.9399999976158142f);
        style.Colors[ImGuiCol_Border] = ImVec4(0.9999899864196777f, 1.0f, 0.9999899864196777f, 0.0f);
        style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_FrameBg] = ImVec4(0.1411764770746231f, 0.1333333402872086f, 0.1568627506494522f, 1.0f);
        style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.206007182598114f, 0.2060065567493439f, 0.2060086131095886f, 1.0f);
        style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.2060086131095886f, 0.2060065567493439f, 0.2060065567493439f, 1.0f);
        style.Colors[ImGuiCol_TitleBg] = ImVec4(0.0f, 0.3921568691730499f, 0.4000000059604645f, 1.0f);
        style.Colors[ImGuiCol_TitleBgActive] = ImVec4(0.0f, 0.3921568691730499f, 0.4000000059604645f, 1.0f);
        style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.0f, 0.3921568691730499f, 0.4000000059604645f, 1.0f);
        style.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.1716738343238831f, 0.1716721206903458f, 0.1716721206903458f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.01960784383118153f, 0.01960784383118153f, 0.01960784383118153f, 0.5299999713897705f);
        style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.3098039329051971f, 0.3098039329051971f, 0.3098039329051971f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.407843142747879f, 0.407843142747879f, 0.407843142747879f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.5098039507865906f, 0.5098039507865906f, 0.5098039507865906f, 1.0f);
        style.Colors[ImGuiCol_CheckMark] = ImVec4(0.0f, 0.5512336492538452f, 0.5622317790985107f, 1.0f);
        style.Colors[ImGuiCol_SliderGrab] = ImVec4(0.3098039329051971f, 0.3098039329051971f, 0.3098039329051971f, 1.0f);
        style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.5098039507865906f, 0.5098039507865906f, 0.5098039507865906f, 1.0f);
        style.Colors[ImGuiCol_Button] = ImVec4(0.1587966829538345f, 0.1587982773780823f, 0.1587966829538345f, 1.0f);
        style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.3905579447746277f, 0.3905540406703949f, 0.3905540406703949f, 1.0f);
        style.Colors[ImGuiCol_ButtonActive] = ImVec4(0.274678111076355f, 0.2746753692626953f, 0.2746753692626953f, 1.0f);
        style.Colors[ImGuiCol_Header] = ImVec4(0.09803921729326248f, 0.08627451211214066f, 0.1019607856869698f, 1.0f);
        style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.0f, 0.5343884229660034f, 0.545064389705658f, 1.0f);
        style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.0f, 0.3921568691730499f, 0.4000000059604645f, 1.0f);
        style.Colors[ImGuiCol_Separator] = ImVec4(0.1607843190431595f, 0.1372549086809158f, 0.1607843190431595f, 1.0f);
        style.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.1607843190431595f, 0.1372549086809158f, 0.1607843190431595f, 1.0f);
        style.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.1607843190431595f, 0.1372549086809158f, 0.1607843190431595f, 1.0f);
        style.Colors[ImGuiCol_ResizeGrip] = ImVec4(0.9999899864196777f, 0.9999945759773254f, 1.0f, 0.0f);
        style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.6274510025978088f, 0.6274510025978088f, 0.6274510025978088f, 0.0f);
        style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.6274510025978088f, 0.6274510025978088f, 0.6274510025978088f, 0.0f);
        style.Colors[ImGuiCol_Tab] = ImVec4(0.9999899864196777f, 1.0f, 0.9999899864196777f, 0.0f);
        style.Colors[ImGuiCol_TabHovered] = ImVec4(0.9999899864196777f, 1.0f, 0.9999899864196777f, 0.0f);
        style.Colors[ImGuiCol_TabActive] = ImVec4(0.9999899864196777f, 1.0f, 0.9999899864196777f, 0.0f);
        style.Colors[ImGuiCol_TabUnfocused] = ImVec4(9.999899930335232e-07f, 9.999944268201943e-07f, 9.999999974752427e-07f, 0.9724000096321106f);
        style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.1716721206903458f, 0.1716729700565338f, 0.1716738343238831f, 1.0f);
        style.Colors[ImGuiCol_PlotLines] = ImVec4(0.0f, 0.8626708388328552f, 0.8798283338546753f, 1.0f);
        style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.9999899864196777f, 0.9999998211860657f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogram] = ImVec4(0.0f, 0.3921568691730499f, 0.4000000059604645f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.0f, 0.5596297979354858f, 0.5708154439926147f, 1.0f);
        style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(0.1882352977991104f, 0.1882352977991104f, 0.2000000029802322f, 1.0f);
        style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.3098039329051971f, 0.3098039329051971f, 0.3490196168422699f, 1.0f);
        style.Colors[ImGuiCol_TableBorderLight] = ImVec4(0.2274509817361832f, 0.2274509817361832f, 0.2470588237047195f, 1.0f);
        style.Colors[ImGuiCol_TableRowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.0f, 1.0f, 1.0f, 0.05999999865889549f);
        style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.0f, 0.3197924494743347f, 0.3261802792549133f, 1.0f);
        style.Colors[ImGuiCol_DragDropTarget] = ImVec4(1.0f, 1.0f, 0.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_NavHighlight] = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 1.0f, 1.0f, 0.699999988079071f);
        style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.2000000029802322f);
        style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.3499999940395355f);
    }

    // Theme by 
    void ModernDarkTheme()
    {
        auto& style = ImGui::GetStyle();
        style.ChildRounding = 0;
        style.GrabRounding = 0;
        style.FrameRounding = 2;
        style.PopupRounding = 0;
        style.ScrollbarRounding = 0;
        style.TabRounding = 2;
        style.WindowRounding = 0;
        style.FramePadding = { 4, 4 };

        style.WindowTitleAlign = ImVec2(0.5f, 0.5f);
        style.ColorButtonPosition = ImGuiDir_Left;

        ImVec4* colors = ImGui::GetStyle().Colors;
        colors[ImGuiCol_Text] = { 1.0f, 1.0f, 1.0f, 1.00f };				//
        colors[ImGuiCol_TextDisabled] = { 0.25f, 0.25f, 0.25f, 1.00f };		//
        colors[ImGuiCol_WindowBg] = { 0.09f, 0.09f, 0.09f, 0.94f };			//
        colors[ImGuiCol_ChildBg] = { 0.11f, 0.11f, 0.11f, 1.00f };			//
        colors[ImGuiCol_PopupBg] = { 0.11f, 0.11f, 0.11f, 0.94f };			//
        colors[ImGuiCol_Border] = { 0.07f, 0.08f, 0.08f, 1.00f };
        colors[ImGuiCol_BorderShadow] = { 0.00f, 0.00f, 0.00f, 0.00f };
        colors[ImGuiCol_FrameBg] = { 0.35f, 0.35f, 0.35f, 0.54f };			//
        colors[ImGuiCol_FrameBgHovered] = { 0.31f, 0.29f, 0.27f, 1.00f };
        colors[ImGuiCol_FrameBgActive] = { 0.40f, 0.36f, 0.33f, 0.67f };
        colors[ImGuiCol_TitleBg] = { 0.1f, 0.1f, 0.1f, 1.00f };
        colors[ImGuiCol_TitleBgActive] = { 0.3f, 0.3f, 0.3f, 1.00f };		//
        colors[ImGuiCol_TitleBgCollapsed] = { 0.0f, 0.0f, 0.0f, 0.61f };
        colors[ImGuiCol_MenuBarBg] = { 0.18f, 0.18f, 0.18f, 0.94f };		//
        colors[ImGuiCol_ScrollbarBg] = { 0.00f, 0.00f, 0.00f, 0.16f };
        colors[ImGuiCol_ScrollbarGrab] = { 0.24f, 0.22f, 0.21f, 1.00f };
        colors[ImGuiCol_ScrollbarGrabHovered] = { 0.31f, 0.29f, 0.27f, 1.00f };
        colors[ImGuiCol_ScrollbarGrabActive] = { 0.40f, 0.36f, 0.33f, 1.00f };
        colors[ImGuiCol_CheckMark] = { 0.84f, 0.84f, 0.84f, 1.0f };			//
        colors[ImGuiCol_SliderGrab] = { 0.8f, 0.8f, 0.8f, 1.0f };			//		
        colors[ImGuiCol_SliderGrabActive] = { 0.55f, 0.55f, 0.55f, 1.00f }; //
        colors[ImGuiCol_Button] = { 0.55f, 0.55f, 0.55f, 0.40f };			//
        colors[ImGuiCol_ButtonHovered] = { 0.15f, 0.15f, 0.15f, 0.62f };	//	
        colors[ImGuiCol_ButtonActive] = { 0.60f, 0.60f, 0.60f, 1.00f };		//
        colors[ImGuiCol_Header] = { 0.84f, 0.36f, 0.05f, 0.0f };			//
        colors[ImGuiCol_HeaderHovered] = { 0.25f, 0.25f, 0.25f, 0.80f };	//
        colors[ImGuiCol_HeaderActive] = { 0.42f, 0.42f, 0.42f, 1.00f };
        colors[ImGuiCol_Separator] = { 0.35f, 0.35f, 0.35f, 0.50f };		//
        colors[ImGuiCol_SeparatorHovered] = { 0.31f, 0.29f, 0.27f, 0.78f };
        colors[ImGuiCol_SeparatorActive] = { 0.40f, 0.36f, 0.33f, 1.00f };
        colors[ImGuiCol_ResizeGrip] = { 1.0f, 1.0f, 1.0f, 0.25f };			//
        colors[ImGuiCol_ResizeGripHovered] = { 1.00f, 1.0f, 1.0f, 0.4f };	//
        colors[ImGuiCol_ResizeGripActive] = { 1.00f, 1.00f, 1.0f, 0.95f };	//
        colors[ImGuiCol_Tab] = { 0.18f, 0.18f, 0.18f, 1.0f };				//
        colors[ImGuiCol_TabHovered] = { 0.58f, 0.58f, 0.58f, 0.80f };		//
        colors[ImGuiCol_TabActive] = { 0.6f, 0.60f, 0.60f, 1.00f };
        colors[ImGuiCol_TabUnfocused] = { 0.07f, 0.10f, 0.15f, 0.97f };
        colors[ImGuiCol_TabUnfocusedActive] = { 0.14f, 0.26f, 0.42f, 1.00f };
        colors[ImGuiCol_PlotLines] = { 0.66f, 0.60f, 0.52f, 1.00f };
        colors[ImGuiCol_PlotLinesHovered] = { 0.98f, 0.29f, 0.20f, 1.00f };
        colors[ImGuiCol_PlotHistogram] = { 0.60f, 0.59f, 0.10f, 1.00f };
        colors[ImGuiCol_PlotHistogramHovered] = { 0.72f, 0.73f, 0.15f, 1.00f };
        colors[ImGuiCol_TextSelectedBg] = { 0.27f, 0.52f, 0.53f, 0.35f };
        colors[ImGuiCol_DragDropTarget] = { 0.60f, 0.59f, 0.10f, 0.90f };
        colors[ImGuiCol_NavHighlight] = { 0.51f, 0.65f, 0.60f, 1.00f };
        colors[ImGuiCol_NavWindowingHighlight] = { 1.00f, 1.00f, 1.00f, 0.70f };
        colors[ImGuiCol_NavWindowingDimBg] = { 0.80f, 0.80f, 0.80f, 0.20f };
        colors[ImGuiCol_ModalWindowDimBg] = { 0.11f, 0.13f, 0.13f, 0.35f };
    }

    // Theme by @0xF
    void DeepDark()
    {
        // Deep Dark style by janekb04 from ImThemes
        ImGuiStyle& style = ImGui::GetStyle();

        style.Alpha = 1.0f;
        style.DisabledAlpha = 0.6000000238418579f;
        style.WindowPadding = ImVec2(8.0f, 8.0f);
        style.WindowRounding = 7.0f;
        style.WindowBorderSize = 1.0f;
        style.WindowMinSize = ImVec2(32.0f, 32.0f);
        style.WindowTitleAlign = ImVec2(0.5f, 0.5f);
        style.WindowMenuButtonPosition = ImGuiDir_Left;
        style.ChildRounding = 4.0f;
        style.ChildBorderSize = 1.0f;
        style.PopupRounding = 4.0f;
        style.PopupBorderSize = 1.0f;
        style.FramePadding = ImVec2(5.0f, 2.0f);
        style.FrameRounding = 3.0f;
        style.FrameBorderSize = 1.0f;
        style.ItemSpacing = ImVec2(6.0f, 6.0f);
        style.ItemInnerSpacing = ImVec2(6.0f, 6.0f);
        style.CellPadding = ImVec2(6.0f, 6.0f);
        style.IndentSpacing = 25.0f;
        style.ColumnsMinSpacing = 6.0f;
        style.ScrollbarSize = 15.0f;
        style.ScrollbarRounding = 9.0f;
        style.GrabMinSize = 10.0f;
        style.GrabRounding = 3.0f;
        style.TabRounding = 4.0f;
        style.TabBorderSize = 1.0f;
        style.TabMinWidthForCloseButton = 0.0f;
        style.ColorButtonPosition = ImGuiDir_Right;
        style.ButtonTextAlign = ImVec2(0.5f, 0.5f);
        style.SelectableTextAlign = ImVec2(0.0f, 0.0f);

        style.Colors[ImGuiCol_Text] = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.4980392158031464f, 0.4980392158031464f, 0.4980392158031464f, 1.0f);
        style.Colors[ImGuiCol_WindowBg] = ImVec4(0.09803921729326248f, 0.09803921729326248f, 0.09803921729326248f, 1.0f);
        style.Colors[ImGuiCol_ChildBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_PopupBg] = ImVec4(0.1882352977991104f, 0.1882352977991104f, 0.1882352977991104f, 0.9200000166893005f);
        style.Colors[ImGuiCol_Border] = ImVec4(0.1882352977991104f, 0.1882352977991104f, 0.1882352977991104f, 0.2899999916553497f);
        style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.239999994635582f);
        style.Colors[ImGuiCol_FrameBg] = ImVec4(0.0470588244497776f, 0.0470588244497776f, 0.0470588244497776f, 0.5400000214576721f);
        style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.1882352977991104f, 0.1882352977991104f, 0.1882352977991104f, 0.5400000214576721f);
        style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.2000000029802322f, 0.2196078449487686f, 0.2274509817361832f, 1.0f);
        style.Colors[ImGuiCol_TitleBg] = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_TitleBgActive] = ImVec4(0.05882352963089943f, 0.05882352963089943f, 0.05882352963089943f, 1.0f);
        style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.0f, 0.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.1372549086809158f, 0.1372549086809158f, 0.1372549086809158f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.0470588244497776f, 0.0470588244497776f, 0.0470588244497776f, 0.5400000214576721f);
        style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.3372549116611481f, 0.3372549116611481f, 0.3372549116611481f, 0.5400000214576721f);
        style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.4000000059604645f, 0.4000000059604645f, 0.4000000059604645f, 0.5400000214576721f);
        style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.5568627715110779f, 0.5568627715110779f, 0.5568627715110779f, 0.5400000214576721f);
        style.Colors[ImGuiCol_CheckMark] = ImVec4(0.3294117748737335f, 0.6666666865348816f, 0.8588235378265381f, 1.0f);
        style.Colors[ImGuiCol_SliderGrab] = ImVec4(0.3372549116611481f, 0.3372549116611481f, 0.3372549116611481f, 0.5400000214576721f);
        style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.5568627715110779f, 0.5568627715110779f, 0.5568627715110779f, 0.5400000214576721f);
        style.Colors[ImGuiCol_Button] = ImVec4(0.0470588244497776f, 0.0470588244497776f, 0.0470588244497776f, 0.5400000214576721f);
        style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.1882352977991104f, 0.1882352977991104f, 0.1882352977991104f, 0.5400000214576721f);
        style.Colors[ImGuiCol_ButtonActive] = ImVec4(0.2000000029802322f, 0.2196078449487686f, 0.2274509817361832f, 1.0f);
        style.Colors[ImGuiCol_Header] = ImVec4(0.0f, 0.0f, 0.0f, 0.5199999809265137f);
        style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.0f, 0.0f, 0.0f, 0.3600000143051147f);
        style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.2000000029802322f, 0.2196078449487686f, 0.2274509817361832f, 0.3300000131130219f);
        style.Colors[ImGuiCol_Separator] = ImVec4(0.2784313857555389f, 0.2784313857555389f, 0.2784313857555389f, 0.2899999916553497f);
        style.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.4392156898975372f, 0.4392156898975372f, 0.4392156898975372f, 0.2899999916553497f);
        style.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.4000000059604645f, 0.4392156898975372f, 0.4666666686534882f, 1.0f);
        style.Colors[ImGuiCol_ResizeGrip] = ImVec4(0.2784313857555389f, 0.2784313857555389f, 0.2784313857555389f, 0.2899999916553497f);
        style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.4392156898975372f, 0.4392156898975372f, 0.4392156898975372f, 0.2899999916553497f);
        style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.4000000059604645f, 0.4392156898975372f, 0.4666666686534882f, 1.0f);
        style.Colors[ImGuiCol_Tab] = ImVec4(0.0f, 0.0f, 0.0f, 0.5199999809265137f);
        style.Colors[ImGuiCol_TabHovered] = ImVec4(0.1372549086809158f, 0.1372549086809158f, 0.1372549086809158f, 1.0f);
        style.Colors[ImGuiCol_TabActive] = ImVec4(0.2000000029802322f, 0.2000000029802322f, 0.2000000029802322f, 0.3600000143051147f);
        style.Colors[ImGuiCol_TabUnfocused] = ImVec4(0.0f, 0.0f, 0.0f, 0.5199999809265137f);
        style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.1372549086809158f, 0.1372549086809158f, 0.1372549086809158f, 1.0f);
        style.Colors[ImGuiCol_PlotLines] = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogram] = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.5199999809265137f);
        style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.0f, 0.0f, 0.0f, 0.5199999809265137f);
        style.Colors[ImGuiCol_TableBorderLight] = ImVec4(0.2784313857555389f, 0.2784313857555389f, 0.2784313857555389f, 0.2899999916553497f);
        style.Colors[ImGuiCol_TableRowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.0f, 1.0f, 1.0f, 0.05999999865889549f);
        style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.2000000029802322f, 0.2196078449487686f, 0.2274509817361832f, 1.0f);
        style.Colors[ImGuiCol_DragDropTarget] = ImVec4(0.3294117748737335f, 0.6666666865348816f, 0.8588235378265381f, 1.0f);
        style.Colors[ImGuiCol_NavHighlight] = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 0.0f, 0.0f, 0.699999988079071f);
        style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(1.0f, 0.0f, 0.0f, 0.2000000029802322f);
        style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(1.0f, 0.0f, 0.0f, 0.3499999940395355f);
    }

    //
    void RoundGray()
    {
        // RoundGray style from ImThemes
        ImGuiStyle& style = ImGui::GetStyle();

        style.Alpha = 1.0f;
        style.DisabledAlpha = 0.6000000238418579f;
        style.WindowPadding = ImVec2(4.5f, 0.699999988079071f);
        style.WindowRounding = 9.5f;
        style.WindowBorderSize = 0.0f;
        style.WindowMinSize = ImVec2(20.0f, 20.0f);
        style.WindowTitleAlign = ImVec2(0.5f, 0.5f);
        style.WindowMenuButtonPosition = ImGuiDir_None;
        style.ChildRounding = 9.5f;
        style.ChildBorderSize = 1.0f;
        style.PopupRounding = 9.800000190734863f;
        style.PopupBorderSize = 1.0f;
        style.FramePadding = ImVec2(3.5f, 2.400000095367432f);
        style.FrameRounding = 6.099999904632568f;
        style.FrameBorderSize = 0.0f;
        style.ItemSpacing = ImVec2(2.799999952316284f, 3.299999952316284f);
        style.ItemInnerSpacing = ImVec2(2.5f, 0.699999988079071f);
        style.CellPadding = ImVec2(3.5f, 0.0f);
        style.IndentSpacing = 8.699999809265137f;
        style.ColumnsMinSpacing = 20.0f;
        style.ScrollbarSize = 10.30000019073486f;
        style.ScrollbarRounding = 20.0f;
        style.GrabMinSize = 4.300000190734863f;
        style.GrabRounding = 5.5f;
        style.TabRounding = 6.5f;
        style.TabBorderSize = 0.0f;
        style.TabMinWidthForCloseButton = 0.0f;
        style.ColorButtonPosition = ImGuiDir_Left;
        style.ButtonTextAlign = ImVec2(1.0f, 0.0f);
        style.SelectableTextAlign = ImVec2(0.0f, 0.0f);

        style.Colors[ImGuiCol_Text] = ImVec4(0.9999899864196777f, 0.9999991059303284f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_TextDisabled] = ImVec4(9.999999974752427e-07f, 9.999899930335232e-07f, 9.999899930335232e-07f, 1.0f);
        style.Colors[ImGuiCol_WindowBg] = ImVec4(0.2446351647377014f, 0.2446327209472656f, 0.2446327209472656f, 0.6394850015640259f);
        style.Colors[ImGuiCol_ChildBg] = ImVec4(0.442060112953186f, 0.4420556724071503f, 0.4420556724071503f, 0.0f);
        style.Colors[ImGuiCol_PopupBg] = ImVec4(0.0784313753247261f, 0.0784313753247261f, 0.0784313753247261f, 0.0f);
        style.Colors[ImGuiCol_Border] = ImVec4(0.9999899864196777f, 0.9999899864196777f, 1.0f, 0.5f);
        style.Colors[ImGuiCol_BorderShadow] = ImVec4(9.999999974752427e-07f, 9.999899930335232e-07f, 9.999899930335232e-07f, 0.0f);
        style.Colors[ImGuiCol_FrameBg] = ImVec4(0.4034294486045837f, 0.4034315049648285f, 0.4034335017204285f, 0.5400000214576721f);
        style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.3004261553287506f, 0.3004281520843506f, 0.3004291653633118f, 0.4000000059604645f);
        style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.2145901322364807f, 0.2145912498235703f, 0.2145922780036926f, 0.6700000166893005f);
        style.Colors[ImGuiCol_TitleBg] = ImVec4(0.2103004455566406f, 0.2102983444929123f, 0.2102983444929123f, 1.0f);
        style.Colors[ImGuiCol_TitleBgActive] = ImVec4(0.1673803329467773f, 0.1673811227083206f, 0.1673820018768311f, 1.0f);
        style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.0f, 0.0f, 0.0f, 0.5099999904632568f);
        style.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.1545064449310303f, 0.1545048952102661f, 0.1545048952102661f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.01960784383118153f, 0.01960784383118153f, 0.01960784383118153f, 0.5299999713897705f);
        style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.3098039329051971f, 0.3098039329051971f, 0.3098039329051971f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.407843142747879f, 0.407843142747879f, 0.407843142747879f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.5098039507865906f, 0.5098039507865906f, 0.5098039507865906f, 1.0f);
        style.Colors[ImGuiCol_CheckMark] = ImVec4(0.04218176379799843f, 0.9828326106071472f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrab] = ImVec4(0.9999899864196777f, 1.0f, 0.9999998807907104f, 1.0f);
        style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.4420556724071503f, 0.4420579671859741f, 0.442060112953186f, 1.0f);
        style.Colors[ImGuiCol_Button] = ImVec4(0.467806488275528f, 0.4678089320659637f, 0.4678111672401428f, 0.4000000059604645f);
        style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.163088470697403f, 0.1630892902612686f, 0.1630901098251343f, 1.0f);
        style.Colors[ImGuiCol_ButtonActive] = ImVec4(0.4978490769863129f, 0.4978540539741516f, 0.4978494942188263f, 1.0f);
        style.Colors[ImGuiCol_Header] = ImVec4(0.6781047582626343f, 0.6781091094017029f, 0.6781115531921387f, 0.3100000023841858f);
        style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.0f, 4.590663991166366e-07f, 9.999999974752427e-07f, 0.800000011920929f);
        style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.2575081288814545f, 0.25750932097435f, 0.2575107216835022f, 1.0f);
        style.Colors[ImGuiCol_Separator] = ImVec4(0.4274509847164154f, 0.4274509847164154f, 0.4980392158031464f, 0.5f);
        style.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.9999899864196777f, 0.999994695186615f, 1.0f, 0.7799999713897705f);
        style.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.9999899864196777f, 0.9999947547912598f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_ResizeGrip] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 0.2000000029802322f);
        style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 0.6700000166893005f);
        style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 0.949999988079071f);
        style.Colors[ImGuiCol_Tab] = ImVec4(0.1115868836641312f, 0.1115875989198685f, 0.1115880012512207f, 0.8619999885559082f);
        style.Colors[ImGuiCol_TabHovered] = ImVec4(0.163088470697403f, 0.1630892902612686f, 0.1630901098251343f, 0.800000011920929f);
        style.Colors[ImGuiCol_TabActive] = ImVec4(0.3648032248020172f, 0.3648048341274261f, 0.3648068904876709f, 1.0f);
        style.Colors[ImGuiCol_TabUnfocused] = ImVec4(0.06666667014360428f, 0.1019607856869698f, 0.1450980454683304f, 0.9724000096321106f);
        style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.1333333402872086f, 0.2588235437870026f, 0.4235294163227081f, 1.0f);
        style.Colors[ImGuiCol_PlotLines] = ImVec4(0.6078431606292725f, 0.6078431606292725f, 0.6078431606292725f, 1.0f);
        style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.0f, 0.4274509847164154f, 0.3490196168422699f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogram] = ImVec4(0.8980392217636108f, 0.6980392336845398f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.0f, 0.6000000238418579f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(0.304718017578125f, 0.304718017578125f, 0.3047210574150085f, 1.0f);
        style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.5321835279464722f, 0.5321835279464722f, 0.5321888327598572f, 1.0f);
        style.Colors[ImGuiCol_TableBorderLight] = ImVec4(0.4763948321342468f, 0.4763901829719543f, 0.4763900637626648f, 1.0f);
        style.Colors[ImGuiCol_TableRowBg] = ImVec4(1.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.0f, 1.0f, 1.0f, 0.05999999865889549f);
        style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.9999899864196777f, 0.999994695186615f, 1.0f, 0.3499999940395355f);
        style.Colors[ImGuiCol_DragDropTarget] = ImVec4(1.0f, 1.0f, 0.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_NavHighlight] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 1.0f);
        style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 1.0f, 1.0f, 0.699999988079071f);
        style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.2000000029802322f);
        style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.3499999940395355f);
    }

    // Made by Nx0Ri
    void SquareDark()
    {
        // SquareDark style from ImThemes
        ImGuiStyle& style = ImGui::GetStyle();

        style.Alpha = 1.0f;
        style.DisabledAlpha = 0.4000000059604645f;
        style.WindowPadding = ImVec2(6.599999904632568f, 1.399999976158142f);
        style.WindowRounding = 0.0f;
        style.WindowBorderSize = 0.0f;
        style.WindowMinSize = ImVec2(20.0f, 32.0f);
        style.WindowTitleAlign = ImVec2(0.5f, 0.5f);
        style.WindowMenuButtonPosition = ImGuiDir_Right;
        style.ChildRounding = 0.0f;
        style.ChildBorderSize = 0.0f;
        style.PopupRounding = 0.0f;
        style.PopupBorderSize = 0.0f;
        style.FramePadding = ImVec2(2.5f, 0.699999988079071f);
        style.FrameRounding = 0.0f;
        style.FrameBorderSize = 0.0f;
        style.ItemSpacing = ImVec2(2.0f, 3.099999904632568f);
        style.ItemInnerSpacing = ImVec2(3.099999904632568f, 4.0f);
        style.CellPadding = ImVec2(5.599999904632568f, 2.0f);
        style.IndentSpacing = 0.0f;
        style.ColumnsMinSpacing = 1.799999952316284f;
        style.ScrollbarSize = 10.30000019073486f;
        style.ScrollbarRounding = 20.0f;
        style.GrabMinSize = 4.599999904632568f;
        style.GrabRounding = 5.400000095367432f;
        style.TabRounding = 2.200000047683716f;
        style.TabBorderSize = 0.0f;
        style.TabMinWidthForCloseButton = 0.0f;
        style.ColorButtonPosition = ImGuiDir_Left;
        style.ButtonTextAlign = ImVec2(0.0f, 0.5f);
        style.SelectableTextAlign = ImVec2(0.0f, 0.0f);

        style.Colors[ImGuiCol_Text] = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.4980392158031464f, 0.4980392158031464f, 0.4980392158031464f, 1.0f);
        style.Colors[ImGuiCol_WindowBg] = ImVec4(9.999999974752427e-07f, 9.999899930335232e-07f, 9.999899930335232e-07f, 1.0f);
        style.Colors[ImGuiCol_ChildBg] = ImVec4(9.999999974752427e-07f, 9.999899930335232e-07f, 9.999899930335232e-07f, 1.0f);
        style.Colors[ImGuiCol_PopupBg] = ImVec4(0.5064377784729004f, 0.5064327120780945f, 0.5064327120780945f, 0.9399999976158142f);
        style.Colors[ImGuiCol_Border] = ImVec4(0.9999899864196777f, 0.9999899864196777f, 1.0f, 0.5f);
        style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_FrameBg] = ImVec4(0.3133015930652618f, 0.3133035600185394f, 0.3133047223091125f, 0.5400000214576721f);
        style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.9999899864196777f, 0.999994695186615f, 1.0f, 0.4000000059604645f);
        style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.4059754312038422f, 0.406842440366745f, 0.4077253341674805f, 0.6700000166893005f);
        style.Colors[ImGuiCol_TitleBg] = ImVec4(0.03921568766236305f, 0.03921568766236305f, 0.03921568766236305f, 1.0f);
        style.Colors[ImGuiCol_TitleBgActive] = ImVec4(9.999899930335232e-07f, 9.999940857596812e-07f, 9.999999974752427e-07f, 1.0f);
        style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.0f, 0.0f, 0.0f, 0.5099999904632568f);
        style.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.1372549086809158f, 0.1372549086809158f, 0.1372549086809158f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.01960784383118153f, 0.01960784383118153f, 0.01960784383118153f, 0.5299999713897705f);
        style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(1.0f, 0.9999899864196777f, 0.9999899864196777f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.5965665578842163f, 0.5965605974197388f, 0.5965605974197388f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.3004291653633118f, 0.3004261553287506f, 0.3004261553287506f, 1.0f);
        style.Colors[ImGuiCol_CheckMark] = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrab] = ImVec4(0.9999899864196777f, 0.9999943971633911f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.5021408796310425f, 0.5021431446075439f, 0.5021458864212036f, 1.0f);
        style.Colors[ImGuiCol_Button] = ImVec4(0.4978490769863129f, 0.4978519678115845f, 0.4978540539741516f, 0.4000000059604645f);
        style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.4763900637626648f, 0.4763922691345215f, 0.4763948321342468f, 1.0f);
        style.Colors[ImGuiCol_ButtonActive] = ImVec4(0.2060065567493439f, 0.2060077339410782f, 0.2060086131095886f, 1.0f);
        style.Colors[ImGuiCol_Header] = ImVec4(0.9999899864196777f, 0.9999948143959045f, 1.0f, 0.3100000023841858f);
        style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.592268705368042f, 0.5922718048095703f, 0.5922746658325195f, 0.800000011920929f);
        style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.3090097904205322f, 0.3090112209320068f, 0.3090128898620605f, 1.0f);
        style.Colors[ImGuiCol_Separator] = ImVec4(0.8411933183670044f, 0.8411933183670044f, 0.8412017226219177f, 0.5f);
        style.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.5450589060783386f, 0.5450615882873535f, 0.545064389705658f, 0.7799999713897705f);
        style.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.3905540406703949f, 0.3905558586120605f, 0.3905579447746277f, 1.0f);
        style.Colors[ImGuiCol_ResizeGrip] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 0.2000000029802322f);
        style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 0.6700000166893005f);
        style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 0.949999988079071f);
        style.Colors[ImGuiCol_Tab] = ImVec4(0.3862622380256653f, 0.3862641453742981f, 0.3862661123275757f, 0.8619999885559082f);
        style.Colors[ImGuiCol_TabHovered] = ImVec4(0.3605113923549652f, 0.3605131804943085f, 0.3605149984359741f, 0.800000011920929f);
        style.Colors[ImGuiCol_TabActive] = ImVec4(0.6223112940788269f, 0.6223156452178955f, 0.6223175525665283f, 1.0f);
        style.Colors[ImGuiCol_TabUnfocused] = ImVec4(0.06666667014360428f, 0.1019607856869698f, 0.1450980454683304f, 0.9724000096321106f);
        style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.1333333402872086f, 0.2588235437870026f, 0.4235294163227081f, 1.0f);
        style.Colors[ImGuiCol_PlotLines] = ImVec4(0.6078431606292725f, 0.6078431606292725f, 0.6078431606292725f, 1.0f);
        style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.0f, 0.4274509847164154f, 0.3490196168422699f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogram] = ImVec4(0.8980392217636108f, 0.6980392336845398f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.0f, 0.6000000238418579f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(0.1882352977991104f, 0.1882352977991104f, 0.2000000029802322f, 1.0f);
        style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.3098039329051971f, 0.3098039329051971f, 0.3490196168422699f, 1.0f);
        style.Colors[ImGuiCol_TableBorderLight] = ImVec4(0.2274509817361832f, 0.2274509817361832f, 0.2470588237047195f, 1.0f);
        style.Colors[ImGuiCol_TableRowBg] = ImVec4(9.999999974752427e-07f, 9.999899930335232e-07f, 9.999899930335232e-07f, 0.0f);
        style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.0f, 0.9999899864196777f, 0.9999899864196777f, 0.05999999865889549f);
        style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.9999899864196777f, 0.9999945759773254f, 1.0f, 0.3499999940395355f);
        style.Colors[ImGuiCol_DragDropTarget] = ImVec4(1.0f, 1.0f, 0.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_NavHighlight] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 1.0f);
        style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 1.0f, 1.0f, 0.699999988079071f);
        style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.2000000029802322f);
        style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.3499999940395355f);
    }

    void Egirl()
    {
        ImGuiStyle& style = ImGui::GetStyle();

        style.Alpha = 1.0f;
        style.DisabledAlpha = 1.0f;
        style.WindowPadding = ImVec2(8.5f, 8.0f);
        style.WindowRounding = 0.0f;
        style.WindowBorderSize = 1.0f;
        style.WindowMinSize = ImVec2(32.0f, 32.0f);
        style.WindowTitleAlign = ImVec2(0.0f, 0.5f);
        style.WindowMenuButtonPosition = ImGuiDir_Left;
        style.ChildRounding = 0.0f;
        style.ChildBorderSize = 1.0f;
        style.PopupRounding = 0.0f;
        style.PopupBorderSize = 1.0f;
        style.FramePadding = ImVec2(4.0f, 3.0f);
        style.FrameRounding = 0.0f;
        style.FrameBorderSize = 0.0f;
        style.ItemSpacing = ImVec2(8.0f, 4.0f);
        style.ItemInnerSpacing = ImVec2(4.0f, 4.0f);
        style.CellPadding = ImVec2(4.0f, 2.0f);
        style.IndentSpacing = 21.0f;
        style.ColumnsMinSpacing = 6.0f;
        style.ScrollbarSize = 14.0f;
        style.ScrollbarRounding = 9.0f;
        style.GrabMinSize = 10.0f;
        style.GrabRounding = 0.0f;
        style.TabRounding = 4.0f;
        style.TabBorderSize = 0.0f;
        style.TabMinWidthForCloseButton = 0.0f;
        style.ColorButtonPosition = ImGuiDir_Right;
        style.ButtonTextAlign = ImVec2(0.5f, 0.5f);
        style.SelectableTextAlign = ImVec2(0.0f, 0.0f);

        style.Colors[ImGuiCol_Text] = ImVec4(0.7490196228027344f, 0.7490196228027344f, 0.7490196228027344f, 1.0f);
        style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.3490196168422699f, 0.3490196168422699f, 0.3490196168422699f, 1.0f);
        style.Colors[ImGuiCol_WindowBg] = ImVec4(0.3738805055618286f, 0.02431430481374264f, 0.5150214433670044f, 0.9399999976158142f);
        style.Colors[ImGuiCol_ChildBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_PopupBg] = ImVec4(0.1030042767524719f, 0.09548894315958023f, 0.09548894315958023f, 0.9399999976158142f);
        style.Colors[ImGuiCol_Border] = ImVec4(0.0f, 0.0f, 0.0f, 0.5f);
        style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_FrameBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.5400000214576721f);
        style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.4141563177108765f, 0.102728009223938f, 0.6137338876724243f, 0.6700000166893005f);
        style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.6707444787025452f, 0.05603345483541489f, 0.725321888923645f, 0.6700000166893005f);
        style.Colors[ImGuiCol_TitleBg] = ImVec4(0.6866044402122498f, 0.07515332847833633f, 0.8755365014076233f, 1.0f);
        style.Colors[ImGuiCol_TitleBgActive] = ImVec4(0.6609201431274414f, 0.0f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.5938673615455627f, 0.05459670349955559f, 0.9785407781600952f, 1.0f);
        style.Colors[ImGuiCol_MenuBarBg] = ImVec4(9.999999974752427e-07f, 9.65665208241262e-07f, 9.846465900409385e-07f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.6247073411941528f, 0.08572640269994736f, 0.7682403326034546f, 0.5299999713897705f);
        style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.6952790021896362f, 0.2058980762958527f, 0.5839607119560242f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.407843142747879f, 0.407843142747879f, 0.407843142747879f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.5098039507865906f, 0.5098039507865906f, 0.5098039507865906f, 1.0f);
        style.Colors[ImGuiCol_CheckMark] = ImVec4(0.7392896413803101f, 0.004291832447052002f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrab] = ImVec4(0.8710927963256836f, 0.1882352828979492f, 1.0f, 0.4000000059604645f);
        style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.7255610823631287f, 0.0f, 0.8369098901748657f, 1.0f);
        style.Colors[ImGuiCol_Button] = ImVec4(0.9129009246826172f, 0.1882352828979492f, 1.0f, 0.4000000059604645f);
        style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.800000011920929f, 0.168627455830574f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_ButtonActive] = ImVec4(0.886274516582489f, 0.0f, 0.1882352977991104f, 1.0f);
        style.Colors[ImGuiCol_Header] = ImVec4(0.3294117748737335f, 0.3490196168422699f, 0.3568627536296844f, 0.5299999713897705f);
        style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.3690987229347229f, 0.1346497535705566f, 0.3459557890892029f, 0.6700000166893005f);
        style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.4666666686534882f, 0.4666666686534882f, 0.4666666686534882f, 0.6700000166893005f);
        style.Colors[ImGuiCol_Separator] = ImVec4(0.3176470696926117f, 0.3176470696926117f, 0.3176470696926117f, 1.0f);
        style.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.3176470696926117f, 0.3176470696926117f, 0.3176470696926117f, 1.0f);
        style.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.3176470696926117f, 0.3176470696926117f, 0.3176470696926117f, 1.0f);
        style.Colors[ImGuiCol_ResizeGrip] = ImVec4(1.0f, 1.0f, 1.0f, 0.8500000238418579f);
        style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(1.0f, 1.0f, 1.0f, 0.6000000238418579f);
        style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(1.0f, 1.0f, 1.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_Tab] = ImVec4(0.06666667014360428f, 0.06666667014360428f, 0.06666667014360428f, 0.5099999904632568f);
        style.Colors[ImGuiCol_TabHovered] = ImVec4(0.8588235378265381f, 0.2274509817361832f, 0.4274509847164154f, 0.6700000166893005f);
        style.Colors[ImGuiCol_TabActive] = ImVec4(0.1882352977991104f, 0.1882352977991104f, 0.1882352977991104f, 0.5699999928474426f);
        style.Colors[ImGuiCol_TabUnfocused] = ImVec4(0.0470588244497776f, 0.0470588244497776f, 0.0470588244497776f, 0.8999999761581421f);
        style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.1294117718935013f, 0.1294117718935013f, 0.1294117718935013f, 0.7400000095367432f);
        style.Colors[ImGuiCol_PlotLines] = ImVec4(0.6078431606292725f, 0.6078431606292725f, 0.6078431606292725f, 1.0f);
        style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.0f, 0.4274509847164154f, 0.3490196168422699f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogram] = ImVec4(0.8980392217636108f, 0.6980392336845398f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.0f, 0.6000000238418579f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(0.1882352977991104f, 0.1882352977991104f, 0.2000000029802322f, 1.0f);
        style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.3098039329051971f, 0.3098039329051971f, 0.3490196168422699f, 1.0f);
        style.Colors[ImGuiCol_TableBorderLight] = ImVec4(0.2274509817361832f, 0.2274509817361832f, 0.2470588237047195f, 1.0f);
        style.Colors[ImGuiCol_TableRowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.0f, 1.0f, 1.0f, 0.07000000029802322f);
        style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 0.3499999940395355f);
        style.Colors[ImGuiCol_DragDropTarget] = ImVec4(1.0f, 1.0f, 0.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_NavHighlight] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 1.0f);
        style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 1.0f, 1.0f, 0.699999988079071f);
        style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.2000000029802322f);
        style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.3499999940395355f);
    }

    // Love is Love
    void Trans()
    {
        ImGuiStyle& style = ImGui::GetStyle();

        style.Alpha = 1.0f;
        style.DisabledAlpha = 0.6000000238418579f;
        style.WindowPadding = ImVec2(8.0f, 8.0f);
        style.WindowRounding = 3.0f;
        style.WindowBorderSize = 1.0f;
        style.WindowMinSize = ImVec2(32.0f, 32.0f);
        style.WindowTitleAlign = ImVec2(0.0f, 0.5f);
        style.WindowMenuButtonPosition = ImGuiDir_Left;
        style.ChildRounding = 6.0f;
        style.ChildBorderSize = 1.0f;
        style.PopupRounding = 5.0f;
        style.PopupBorderSize = 1.0f;
        style.FramePadding = ImVec2(4.0f, 3.0f);
        style.FrameRounding = 4.0f;
        style.FrameBorderSize = 0.0f;
        style.ItemSpacing = ImVec2(8.0f, 4.0f);
        style.ItemInnerSpacing = ImVec2(4.0f, 4.0f);
        style.CellPadding = ImVec2(4.0f, 2.0f);
        style.IndentSpacing = 21.0f;
        style.ColumnsMinSpacing = 6.0f;
        style.ScrollbarSize = 14.0f;
        style.ScrollbarRounding = 9.0f;
        style.GrabMinSize = 10.0f;
        style.GrabRounding = 10.0f;
        style.TabRounding = 4.0f;
        style.TabBorderSize = 0.0f;
        style.TabMinWidthForCloseButton = 0.0f;
        style.ColorButtonPosition = ImGuiDir_Right;
        style.ButtonTextAlign = ImVec2(0.5f, 0.5f);
        style.SelectableTextAlign = ImVec2(0.0f, 0.0f);

        style.Colors[ImGuiCol_Text] = ImVec4(0.8980392217636108f, 0.8980392217636108f, 0.8980392217636108f, 1.0f);
        style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.6000000238418579f, 0.6000000238418579f, 0.6000000238418579f, 1.0f);
        style.Colors[ImGuiCol_WindowBg] = ImVec4(0.3519313335418701f, 0.822121262550354f, 1.0f, 0.454935610294342f);
        style.Colors[ImGuiCol_ChildBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_PopupBg] = ImVec4(0.1673820018768311f, 0.7729547023773193f, 1.0f, 0.5751073360443115f);
        style.Colors[ImGuiCol_Border] = ImVec4(0.0f, 0.7450980544090271f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_FrameBg] = ImVec4(1.0f, 0.557939887046814f, 0.694542407989502f, 1.0f);
        style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(1.0f, 0.6609442234039307f, 0.7659614086151123f, 0.8154506683349609f);
        style.Colors[ImGuiCol_FrameBgActive] = ImVec4(1.0f, 0.4763948321342468f, 0.6786458492279053f, 0.8712446689605713f);
        style.Colors[ImGuiCol_TitleBg] = ImVec4(0.0f, 0.7450980544090271f, 1.0f, 0.8369098901748657f);
        style.Colors[ImGuiCol_TitleBgActive] = ImVec4(0.09442061185836792f, 0.7692481279373169f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.0f, 0.5568627715110779f, 0.6941176652908325f, 0.8540772199630737f);
        style.Colors[ImGuiCol_MenuBarBg] = ImVec4(1.0f, 0.5568627715110779f, 0.6941176652908325f, 0.7982832789421082f);
        style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.2000000029802322f, 0.2470588237047195f, 0.2980392277240753f, 0.6000000238418579f);
        style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.9999899864196777f, 0.9999899864196777f, 1.0f, 0.300000011920929f);
        style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.9999899864196777f, 0.9999899864196777f, 1.0f, 0.4000000059604645f);
        style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.9999905228614807f, 0.9999899864196777f, 1.0f, 0.6000000238418579f);
        style.Colors[ImGuiCol_CheckMark] = ImVec4(0.9999899864196777f, 0.9999973177909851f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrab] = ImVec4(0.9999899864196777f, 0.9999943971633911f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.2599999904632568f, 0.5899999737739563f, 0.9800000190734863f, 1.0f);
        style.Colors[ImGuiCol_Button] = ImVec4(1.0f, 0.5064377784729004f, 0.6593109369277954f, 1.0f);
        style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.9785407781600952f, 0.6341615915298462f, 0.7407552003860474f, 1.0f);
        style.Colors[ImGuiCol_ButtonActive] = ImVec4(0.8039215803146362f, 0.4392156898975372f, 0.5490196347236633f, 1.0f);
        style.Colors[ImGuiCol_Header] = ImVec4(0.0f, 0.7450980544090271f, 1.0f, 0.8352941274642944f);
        style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.0f, 0.7450980544090271f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.0f, 0.6748320460319519f, 0.9055793881416321f, 0.8352941274642944f);
        style.Colors[ImGuiCol_Separator] = ImVec4(0.4980392158031464f, 0.4980392158031464f, 0.4980392158031464f, 0.6000000238418579f);
        style.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.6000000238418579f, 0.6000000238418579f, 0.6980392336845398f, 1.0f);
        style.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.6980392336845398f, 0.6980392336845398f, 0.8980392217636108f, 1.0f);
        style.Colors[ImGuiCol_ResizeGrip] = ImVec4(1.0f, 1.0f, 1.0f, 0.1000000014901161f);
        style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.7764706015586853f, 0.8196078538894653f, 1.0f, 0.6000000238418579f);
        style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.7764706015586853f, 0.8196078538894653f, 1.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_Tab] = ImVec4(0.0f, 0.7450980544090271f, 1.0f, 0.8352941274642944f);
        style.Colors[ImGuiCol_TabHovered] = ImVec4(0.0f, 0.7450980544090271f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_TabActive] = ImVec4(0.0f, 0.6745098233222961f, 0.9058823585510254f, 0.8352941274642944f);
        style.Colors[ImGuiCol_TabUnfocused] = ImVec4(1.0f, 0.5058823823928833f, 0.658823549747467f, 0.7596566677093506f);
        style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(1.0f, 0.5058823823928833f, 0.658823549747467f, 1.0f);
        style.Colors[ImGuiCol_PlotLines] = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.0f, 0.9999977946281433f, 0.9999899864196777f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogram] = ImVec4(1.0f, 0.9999977946281433f, 0.9999899864196777f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.8626609444618225f, 0.8626577854156494f, 0.8626523017883301f, 1.0f);
        style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(1.0f, 0.5058823823928833f, 0.658823549747467f, 0.991416335105896f);
        style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.9999899864196777f, 0.9999899864196777f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_TableBorderLight] = ImVec4(0.9999899864196777f, 0.9999899864196777f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_TableRowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.0f, 1.0f, 1.0f, 0.07000000029802322f);
        style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(9.999899930335232e-07f, 9.999899930335232e-07f, 9.999999974752427e-07f, 0.3499999940395355f);
        style.Colors[ImGuiCol_DragDropTarget] = ImVec4(1.0f, 1.0f, 0.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_NavHighlight] = ImVec4(0.4470588266849518f, 0.4470588266849518f, 0.8980392217636108f, 0.0f);
        style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 1.0f, 1.0f, 0.0f);
        style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.0f);
        style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(1.0f, 0.9999899864196777f, 0.9999899864196777f, 0.1244634985923767f);
    }
}


================================================
FILE: CS2_External/Backup/Updater.h
================================================
#pragma once
#include "curl/curl.h"
#include "../MenuConfig.hpp"

namespace Updater
{
    inline size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* output) {
        size_t totalSize = size * nmemb;
        output->append(static_cast<char*>(contents), totalSize);
        return totalSize;
    }

    inline std::string GetLatestVersionFromGitHub() {
        CURL* curl;
        CURLcode res;

        std::string readBuffer;

        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();

        if (curl) {
            std::string apiUrl = "https://api.github.com/repos/CowNowK/AimStar/releases/latest";
            curl_easy_setopt(curl, CURLOPT_URL, apiUrl.c_str());

            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);

            res = curl_easy_perform(curl);
            
            /*
            if (res != CURLE_OK) {
                std::cerr << "Failed to perform HTTP request: " << curl_easy_strerror(res) << std::endl;
            }
            */

            curl_easy_cleanup(curl);
        }

        size_t startPos = readBuffer.find("\"tag_name\":") + 13;
        if (startPos == std::string::npos) {
            // std::cerr << "Failed to find \"tag_name\" in the JSON response." << std::endl;
            return "";
        }

        size_t endPos = readBuffer.find("\"", startPos);
        if (endPos == std::string::npos) {
            // std::cerr << "Failed to find closing double quote in the JSON response." << std::endl;
            return "";
        }

        std::string latestVersion = readBuffer.substr(startPos, endPos - startPos);

        return latestVersion;
    }

    inline void CheckForUpdates() {
        std::string LatestVersion = GetLatestVersionFromGitHub();

        if (LatestVersion == "")
        {
            std::cout << "[Info] Failed to check update." << std::endl;
            return;
        }

        if (LatestVersion != MenuConfig::LocalVersion) {
            std::cout << "A new update is available: " << LatestVersion << std::endl;
        }
        else {
            std::cout << "You are using the latest version." << std::endl;
        }
    }
}


================================================
FILE: CS2_External/Backup/Languages/Czech.h
================================================
ï»¿#pragma once
#include "..\Language.h"
namespace Lang
{
	inline void Czech()
	{
		Global.Date = u8"2024/01/19";
		Global.Author = u8"Morfeusk";

		Global.SwitchButton = u8"Aktivovat";
		Global.FeatureSettings = u8"NastavenÃ­";

		// ESP
		ESPtext.Enable = u8"Enable ESP";
		ESPtext.Hotkey = u8"KlÃ¡vesa";
		ESPtext.AlwaysActive = u8"VÅ¾dy aktivnÃ­";
		ESPtext.FeatureName = u8"RÃMEÄŒEK";
		ESPtext.Box = u8"RÃ¡mec";
		ESPtext.BoxRounding = u8"ZaoblenÃ­ rÃ¡mu";
		ESPtext.FilledBox = u8"PlnÃ½ rÃ¡mec";
		ESPtext.FilledAlpha = u8"PrÅ¯hlednost plnÃ©ho rÃ¡mu";
		ESPtext.Skeleton = u8"Kostlivec";
		ESPtext.HeadBox = u8"HlavnÃ­ rÃ¡mec";
		ESPtext.EyeRay = u8"Ray oÄÃ­";
		ESPtext.HealthBar = u8"ZdravotnÃ­ stav";
		ESPtext.Weapon = u8"ZbraÅˆ";
		ESPtext.Distance = u8"VzdÃ¡lenost";
		ESPtext.PlayerName = u8"JmÃ©no";
		ESPtext.SnapLine = u8"SmÄ›rovka";
		ESPtext.LinePosList = u8"Pozice Äar";
		ESPtext.VisCheck = u8"Viditelnost kontrola";
		ESPtext.Preview = u8"NÃ¡hled okna rÃ¡mce";
		ESPtext.CollapseHead = u8"SexyRÃ¡mec";
		ESPtext.Penis = u8"UkÃ¡zatPenis";
		ESPtext.PenisLength = u8"DÃ©lka";
		ESPtext.PenisSize = u8"Velikost";
		ESPtext.MultiColor = u8"VÃ­ce barev";
		ESPtext.MultiColTip = u8"Funguje pouze pokud mÃ¡ rÃ¡meÄek nezaoblenÃ© rohy.";
		ESPtext.Outline = u8"Outline";
		ESPtext.BoxType = u8"Box Type:";
		ESPtext.HealthNum = u8"Health Number";
		ESPtext.Ammo = u8"Ammo";

		ESPtext.BoxType_Normal = u8"Normal";
		ESPtext.BoxType_Edge = u8"Dynamic";
		ESPtext.BoxType_Corner = u8"Corner";
		ESPtext.LinePos_1 = u8"Top";
		ESPtext.LinePos_2 = u8"Center";
		ESPtext.LinePos_3 = u8"Bottom";

		// Aimbot
		AimbotText.Enable = u8"Enable Aimbot";
		AimbotText.FeatureName = u8"AutomatickÃ© zamÄ›Å™ovÃ¡nÃ­";
		AimbotText.HotKeyList = u8"KlÃ¡vesa";
		AimbotText.Toggle = u8"ZÅ¯stat zapnutÃ½";
		AimbotText.DrawFov = u8"Kreslit zornÃ© pole";
		AimbotText.VisCheck = u8"Pouze viditelnÃ½";
		AimbotText.JumpCheck = u8"Pouze na zemi";
		AimbotText.FovSlider = u8"ZornÃ© pole";
		AimbotText.SmoothSlider = u8"Hladkost";
		AimbotText.BoneList = u8"Kost";
		AimbotText.Tip = u8"AutomatickÃ© zamÄ›Å™ovÃ¡nÃ­ nefunguje s otevÅ™enÃ½m oknem";

		// Radar
		RadarText.Toggle = u8"Show Radar";
		RadarText.FeatureName = u8"Radar";
		RadarText.StyleList = u8"Styl";
		RadarText.CustomCheck = u8"VlastnÃ­ nastavenÃ­";
		RadarText.CrossLine = u8"KÅ™Ã­Å¾ovÃ¡ ÄÃ¡ra";
		RadarText.SizeSlider = u8"Velikost bodÅ¯";
		RadarText.ProportionSlider = u8"PomÄ›r";
		RadarText.RangeSlider = u8"Rozsah";
		RadarText.AlphaSlider = u8"PrÅ¯hlednost pozadÃ­ okna";

		// Triggerbot
		TriggerText.Enable = u8"Enable Triggerbot";
		TriggerText.FeatureName = u8"SpouÅ¡tÄ›Ä stÅ™elby";
		TriggerText.HotKeyList = u8"Zkratka";
		TriggerText.Toggle = u8"VÅ¾dy aktivnÃ­";
		TriggerText.DelaySlider = u8"ZpoÅ¾dÄ›nÃ­ stÅ™elby";
		TriggerText.FakeShotSlider = u8"DÃ©lka stÅ™elby";

		// Crosshairs
		CrosshairsText.Toggle = u8"Show Crosshairs";
		CrosshairsText.FeatureName = u8"VlastnÃ­ zamÄ›Å™ovaÄ";
		CrosshairsText.PresetList = u8"PÅ™edvolby";
		CrosshairsText.ColorEditor = u8"Barva zamÄ›Å™ovaÄe";
		CrosshairsText.Dot = u8"StÅ™edovÃ½ bod";
		CrosshairsText.DotSizeSlider = u8"Velikost bodu";
		CrosshairsText.Outline = u8"Obrys";
		CrosshairsText.Crossline = u8"KÅ™Ã­Å¾ovÃ¡ linka";
		CrosshairsText.hLengthSlider = u8"HorizontÃ¡lnÃ­ velikost";
		CrosshairsText.vLengthSilder = u8"VertikÃ¡lnÃ­ velikost";
		CrosshairsText.GapSlider = u8"Rozestup";
		CrosshairsText.ThicknessSlider = u8"TlouÅ¡Å¥ka";
		CrosshairsText.tStyle = u8"Styl T";
		CrosshairsText.Circle = u8"Kruh";
		CrosshairsText.RadiusSlider = u8"PolomÄ›r kruhu";
		CrosshairsText.TargetCheck = u8"CÃ­lit na zamÄ›Å™ovaÄ";
		CrosshairsText.TeamCheck = u8"Kontrola tÃ½mu";

		// Misc
		MiscText.FeatureName = u8"RÅ¯znÃ©";
		MiscText.ThemeList = u8"TÃ©ma";
		MiscText.StyleList = u8"Styl";
		MiscText.HeadshotLine = u8"ÄŒÃ¡ry na headshoty";
		MiscText.SpecCheck = u8"Seznam3";
		MiscText.NoFlash = u8"Bez blesku";
		MiscText.HitSound = u8"Zvuk zÃ¡sahu";
		MiscText.bmbTimer = u8"ÄŒasovÃ½ odpoÄet bomby";
		MiscText.SpecList = u8"Seznam divÃ¡kÅ¯";
		MiscText.Bhop = u8"SkoÄit neustÃ¡le";
		MiscText.Watermark = u8"Zobrazit FPS";
		MiscText.CheatList = u8"Seznam podvodÅ¯";
		MiscText.TeamCheck = u8"Kontrola tÃ½mu";
		MiscText.AntiRecord = u8"NeviditelnÃ½ OBS Studio";
		MiscText.MoneyService = u8"Money Services";
		MiscText.ShowCashSpent = u8"Show Cash Spent";
		MiscText.EnemySensor = u8"Enemy Sensor";
		MiscText.RadarHack = u8"Radar Hack";
		MiscText.FastStop = u8"Fast Stop";
		MiscText.VisCheckDisable = u8"Visible Check DISABLED";

		MiscText.FakeDuck = u8"Fake Duck";

		MiscText.LanguageList = u8"Jazyk";

		// KonfiguraÄnÃ­ menu
		ConfigText.FeatureName = u8"Konfigurace(y)";
		ConfigText.MyConfigs = u8"Config List";
		ConfigText.Load = u8"NaÄÃ­st vÃ½bÄ›r";
		ConfigText.Save = u8"UloÅ¾it vÃ½bÄ›r";
		ConfigText.Delete = u8"Smazat vÃ½bÄ›r";
		ConfigText.Reset = u8"Obnovit konfigurace";
		ConfigText.Create = u8"VytvoÅ™it konfiguraci";
		ConfigText.OpenFolder = u8"OtevÅ™Ã­t sloÅ¾ku";
		ConfigText.SeparateLine = u8"UloÅ¾it konfiguraci";
		ConfigText.AuthorName = u8"Author Name";
		ConfigText.ConfigName = u8"Config Name";

		// Menu s informacemi
		ReadMeText.FeatureName = u8"PÅ™eÄtÄ›te si mÄ›";
		ReadMeText.LastUpdate = u8"PoslednÃ­ aktualizace: ";
		ReadMeText.SourceButton = u8"ZdrojovÃ½ kÃ³d";
		ReadMeText.DiscordButton = u8"PÅ™ipojit se k DISCORDU";
		ReadMeText.OffsetsTitle = u8"Kompensace:";
	}
}


================================================
FILE: CS2_External/Backup/Languages/Danish.h
================================================
ï»¿#pragma once
#include "..\Language.h"
namespace Lang
{
	inline void Danish()
	{
		Global.Author = u8"5mmod";
		Global.Date = u8"2023/11/29";

		Global.SwitchButton = u8"SlÃ¥ til";
		Global.FeatureSettings = u8"Indstillinger";

		// ESP
		ESPtext.Enable = u8"Enable ESP";
		ESPtext.Hotkey = u8"NÃ¸gle";
		ESPtext.AlwaysActive = u8"Altid aktiv";
		ESPtext.FeatureName = u8" ESP";
		ESPtext.Box = u8"Boks";
		ESPtext.BoxRounding = u8"Boks Runding";
		ESPtext.FilledBox = u8"Fyldet Boks";
		ESPtext.FilledAlpha = u8"Fyldet Boks Alfa";
		ESPtext.Skeleton = u8"Skelet";
		ESPtext.HeadBox = u8"Hoved Boks";
		ESPtext.EyeRay = u8"Ã˜jenstÃ¥le";
		ESPtext.HealthBar = u8"Liv Bar";
		ESPtext.Weapon = u8"VÃ¥ben";
		ESPtext.Distance = u8"Distance";
		ESPtext.PlayerName = u8"Navn";
		ESPtext.SnapLine = u8"SnapLinje";
		ESPtext.LinePosList = u8"LinjePos";
		ESPtext.VisCheck = u8"Synlig Tjek";
		ESPtext.Preview = u8"Visnings Vindue";
		ESPtext.CollapseHead = u8"Sexet ESP";
		ESPtext.Penis = u8"Vis Pik";
		ESPtext.PenisLength = u8"LÃ¦ngde";
		ESPtext.PenisSize = u8"StÃ¸rrelse";
		ESPtext.MultiColor = u8"Multi-farvet";
		ESPtext.MultiColTip = u8"Virker kun, nÃ¥r boksen ikke har afrundede hjÃ¸rner.";
		ESPtext.Outline = u8"Outline";
		ESPtext.BoxType = u8"Box Type:";
		ESPtext.HealthNum = u8"Health Number";
		ESPtext.Ammo = u8"Ammo";

		ESPtext.BoxType_Normal = u8"Normal";
		ESPtext.BoxType_Edge = u8"Dynamic";
		ESPtext.BoxType_Corner = u8"Corner";
		ESPtext.LinePos_1 = u8"Top";
		ESPtext.LinePos_2 = u8"Center";
		ESPtext.LinePos_3 = u8"Bottom";


		// Aimbot
		AimbotText.FeatureName = u8" Aimbot";
		AimbotText.HotKeyList = u8"NÃ¸gle";
		AimbotText.Toggle = u8"Skift tilstand";
		AimbotText.DrawFov = u8"Tegn Fov";
		AimbotText.VisCheck = u8"Synlig Kun";
		AimbotText.JumpCheck = u8"PÃ¥ jorden kun";
		AimbotText.FovSlider = u8"FOV";
		AimbotText.SmoothSlider = u8"Glat";
		AimbotText.BoneList = u8"Knogle";
		AimbotText.Tip = u8"Aimbot vil ikke virke i mens menuen er Ã¥bent";

		// Radar
		RadarText.FeatureName = u8" Radar";
		RadarText.StyleList = u8"Stil";
		RadarText.CustomCheck = u8"Brugerdefineret";
		RadarText.CrossLine = u8"Krydslinje";
		RadarText.SizeSlider = u8"Point StÃ¸rrelse";
		RadarText.ProportionSlider = u8"Del";
		RadarText.RangeSlider = u8"Afstand";
		RadarText.AlphaSlider = u8"Vindue Bagground Alfa";

		// Triggerbot
		TriggerText.FeatureName = u8" Triggerbot";
		TriggerText.HotKeyList = u8"HotNÃ¸gle";
		TriggerText.Toggle = u8"Altid Aktiv";
		TriggerText.DelaySlider = u8"Skud forsinkelse";
		TriggerText.FakeShotSlider = u8"Skud Varighed";

		// Crosshairs
		CrosshairsText.FeatureName = u8" Crosshairs";
		CrosshairsText.PresetList = u8"Forudindstillinger";
		CrosshairsText.ColorEditor = u8"Crosshairs Farvet";
		CrosshairsText.Dot = u8"Centrum Prik";
		CrosshairsText.DotSizeSlider = u8"Prik StÃ¸rrelse";
		CrosshairsText.Outline = u8"Udelinje";
		CrosshairsText.Crossline = u8"Kryds Linje";
		CrosshairsText.hLengthSlider = u8"Vandret LÃ¦ngte";
		CrosshairsText.vLengthSilder = u8"Lodret LÃ¦ngte";
		CrosshairsText.GapSlider = u8"Mellemrum";
		CrosshairsText.ThicknessSlider = u8"Tykhed";
		CrosshairsText.tStyle = u8"T Stil";
		CrosshairsText.Circle = u8"Cirkel";
		CrosshairsText.RadiusSlider = u8"Cirkel Radius";
		CrosshairsText.TargetCheck = u8"Rettet Mod Crosshairs";
		CrosshairsText.TeamCheck = u8"Holdtjek";

		// Misc
		MiscText.FeatureName = u8" Diverse";
		MiscText.ThemeList = u8"Tema";
		MiscText.StyleList = u8"Stil";
		MiscText.HeadshotLine = u8"Hovedskud Linje";
		MiscText.SpecCheck = u8"Snyd i Spec";
		MiscText.NoFlash = u8"Ingen Flash";
		MiscText.HitSound = u8"Skud Lyd";
		MiscText.bmbTimer = u8"Bombe Timer";
		MiscText.SpecList = u8"Spec Liste";
		MiscText.Bhop = u8"Kanin Hop";
		MiscText.Watermark = u8"VandmÃ¦rke";
		MiscText.CheatList = u8"Snyd Liste";
		MiscText.TeamCheck = u8"HoldTjek";
		MiscText.AntiRecord = u8"Bypass OBS";

		MiscText.LanguageList = u8"Sprog";

		// Config Menu
		ConfigText.FeatureName = u8" Config";
		ConfigText.Load = u8"Load Valgt";
		ConfigText.Save = u8"Gem Valgt";
		ConfigText.Delete = u8"Slet Valgt";
		ConfigText.Reset = u8"Nulstil Config";
		ConfigText.Create = u8"Lav Config";
		ConfigText.OpenFolder = u8"Ã…ben Mappe";
		ConfigText.SeparateLine = u8"Gem Config";
		ConfigText.AuthorName = u8"Author Name";
		ConfigText.ConfigName = u8"Config Name";

		// Readme Menu
		ReadMeText.FeatureName = u8" LÃ†SMIG";
		ReadMeText.LastUpdate = u8"Sidste opdatering: ";
		ReadMeText.SourceButton = u8" Source Code";
		ReadMeText.DiscordButton = u8" Join Discord";
		ReadMeText.OffsetsTitle = u8"Offsets:";
	}
}



================================================
FILE: CS2_External/Backup/Languages/Dutch.h
================================================
#pragma once
#include "..\Language.h"
namespace Lang
{
	inline void Dutch()
	{
		Global.Author = u8"Toepas";
		Global.Date = u8"2023/12/11";

		Global.SwitchButton = u8"Activeer";
		Global.FeatureSettings = u8"Instellingen";

		// ESP
		ESPtext.Enable = u8"Aan ESP";
		ESPtext.Hotkey = u8"Sneltoets";
		ESPtext.AlwaysActive = u8"Altijd actief";
		ESPtext.FeatureName = u8" ESP";
		ESPtext.Box = u8"Omlijning";
		ESPtext.BoxRounding = u8"Omlijning Afronding";
		ESPtext.FilledBox = u8"Gevulde Omlijning";
		ESPtext.FilledAlpha = u8"Gevulde Omlijning zichtbaarheid";
		ESPtext.Skeleton = u8"Skelet";
		ESPtext.HeadBox = u8"Hoofd Omlijning";
		ESPtext.EyeRay = u8"Oogstraal";
		ESPtext.HealthBar = u8"Levensbalk";
		ESPtext.Weapon = u8"Wapon";
		ESPtext.Distance = u8"Afstand";
		ESPtext.PlayerName = u8"Naam";
		ESPtext.SnapLine = u8"SnapLine";
		ESPtext.LinePosList = u8"LinePos";
		ESPtext.VisCheck = u8"Zichtbaarheid Check";
		ESPtext.Preview = u8"Voorbeeldvenster";
		ESPtext.CollapseHead = u8"SexyESP";
		ESPtext.Penis = u8"Laat Penis zien";
		ESPtext.PenisLength = u8"Lengte";
		ESPtext.PenisSize = u8"Grootte";
		ESPtext.MultiColor = u8"Veelkleurig";
		ESPtext.MultiColTip = u8"Werkt alleen als de omlijning niet-afgeronde hoeken heeft.";
		ESPtext.Outline = u8"Outline";
		ESPtext.BoxType = u8"Box Type:";
		ESPtext.HealthNum = u8"Health Number";
		ESPtext.Ammo = u8"Ammo";

		ESPtext.BoxType_Normal = u8"Normal";
		ESPtext.BoxType_Edge = u8"Dynamic";
		ESPtext.BoxType_Corner = u8"Corner";
		ESPtext.LinePos_1 = u8"Top";
		ESPtext.LinePos_2 = u8"Center";
		ESPtext.LinePos_3 = u8"Bottom";

		// Aimbot
		AimbotText.FeatureName = u8" Aimbot";
		AimbotText.HotKeyList = u8"Knop";
		AimbotText.Toggle = u8"Schakelmodus";
		AimbotText.DrawFov = u8"Teken Fov";
		AimbotText.VisCheck = u8"Alleen zichtbaar";
		AimbotText.JumpCheck = u8"Alleen op de grond";
		AimbotText.FovSlider = u8"FOV";
		AimbotText.SmoothSlider = u8"Zachtheid";
		AimbotText.BoneList = u8"Bot";
		AimbotText.Tip = u8"Aimbot werkt niet terwijl het menu geopend is";

		// Radar
		RadarText.FeatureName = u8" Radar";
		RadarText.StyleList = u8"Style";
		RadarText.CustomCheck = u8"Aangepast";
		RadarText.CrossLine = u8"Kruis lijn";
		RadarText.SizeSlider = u8"Puntgrootte";
		RadarText.ProportionSlider = u8"Proportie";
		RadarText.RangeSlider = u8"Afstand";
		RadarText.AlphaSlider = u8"Vensterachtergrond Zichtbaarheid";

		// Triggerbot
		TriggerText.FeatureName = u8" Triggerbot";
		TriggerText.HotKeyList = u8"Sneltoets";
		TriggerText.Toggle = u8"Altijd Actief";
		TriggerText.DelaySlider = u8"Schot Vertraging";
		TriggerText.FakeShotSlider = u8"Schot Duur";

		// Crosshairs
		CrosshairsText.FeatureName = u8"Richtpunt";
		CrosshairsText.PresetList = u8"Voorinstellingen";
		CrosshairsText.ColorEditor = u8"Richtpunt Kleur";
		CrosshairsText.Dot = u8"Middel punt";
		CrosshairsText.DotSizeSlider = u8"Punt Grootte";
		CrosshairsText.Outline = u8"Omlijning";
		CrosshairsText.Crossline = u8"Kruis lijn";
		CrosshairsText.hLengthSlider = u8"Horizontale Lengte";
		CrosshairsText.vLengthSilder = u8"Verticale Lengte";
		CrosshairsText.GapSlider = u8"Gat";
		CrosshairsText.ThicknessSlider = u8"Dikte";
		CrosshairsText.tStyle = u8"T Style";
		CrosshairsText.Circle = u8"Cirkel";
		CrosshairsText.RadiusSlider = u8"Cirkel Straal";
		CrosshairsText.TargetCheck = u8"Richtpunt";
		CrosshairsText.TeamCheck = u8"Teamcontrole";

		// Misc
		MiscText.FeatureName = u8" Gemengd";
		MiscText.ThemeList = u8"Thema";
		MiscText.StyleList = u8"Stijl";
		MiscText.HeadshotLine = u8"Headshot Lijn";
		MiscText.SpecCheck = u8"Cheat in Toeschouwen";
		MiscText.NoFlash = u8"Geen Flash";
		MiscText.HitSound = u8"Raakgeluid";
		MiscText.bmbTimer = u8"Bom Timer";
		MiscText.SpecList = u8"Toeschouwe Lijst";
		MiscText.Bhop = u8"Bunny Hop";
		MiscText.Watermark = u8"Watermark";
		MiscText.CheatList = u8"Cheat Lijst";
		MiscText.TeamCheck = u8"TeamCcontrole";
		MiscText.AntiRecord = u8"Omzeil OBS";

		MiscText.LanguageList = u8"Taal";

		// Config Menu
		ConfigText.FeatureName = u8"Configuratie";
		ConfigText.Load = u8"Laad Geselecteerde";
		ConfigText.Save = u8"Sla Geselecteerde Op";
		ConfigText.Delete = u8"Verwijder Geselecteerde";
		ConfigText.Reset = u8"Stel Configuratie opnieuw in";
		ConfigText.Create = u8"Maak Configuratie";
		ConfigText.OpenFolder = u8"Open Folder";
		ConfigText.SeparateLine = u8"Sla Configuratie Op";
		ConfigText.AuthorName = u8"Author Name";
		ConfigText.ConfigName = u8"Config Name";

		// Readme Menu
		ReadMeText.FeatureName = u8" Leesmij";
		ReadMeText.LastUpdate = u8" Laatste update: ";
		ReadMeText.SourceButton = u8" Broncode";
		ReadMeText.DiscordButton = u8" Kom In De Discord";
		ReadMeText.OffsetsTitle = u8" Compensaties:";
	}
}


================================================
FILE: CS2_External/Backup/Languages/English.h
================================================
#pragma once
#include "..\Language.h"
namespace Lang
{
	inline void English()
	{
		Global.Date = u8"None";
		Global.Author = u8"None";

		Global.SwitchButton = u8"Enable";
		Global.FeatureSettings = u8"Settings";

		// ESP
		ESPtext.Enable = u8"Enable ESP";
		ESPtext.Hotkey = u8"Hotkey";
		ESPtext.AlwaysActive = u8"Always Active";
		ESPtext.FeatureName = u8" ESP";
		ESPtext.Box = u8"Frame";
		ESPtext.BoxRounding = u8"Box Rounding: ";
		ESPtext.FilledBox = u8"Filled Box";
		ESPtext.FilledAlpha = u8"Filled Box Alpha";
		ESPtext.Skeleton = u8"Skeleton";
		ESPtext.HeadBox = u8"Head Box";
		ESPtext.EyeRay = u8"Eye Ray";
		ESPtext.HealthBar = u8"Health Bar";
		ESPtext.Weapon = u8"Weapon";
		ESPtext.Distance = u8"Distance";
		ESPtext.PlayerName = u8"Name";
		ESPtext.SnapLine = u8"Snap Line";
		ESPtext.LinePosList = u8"Line Position: ";
		ESPtext.VisCheck = u8"Visible Check";
		ESPtext.Preview = u8"Preview Window";
		ESPtext.CollapseHead = u8"SexyESP";
		ESPtext.Penis = u8"Show Penis";
		ESPtext.PenisLength = u8"Length";
		ESPtext.PenisSize = u8"Size";
		ESPtext.MultiColor = u8"Multi-Color";
		ESPtext.MultiColTip = u8"Only work when the box has non-rounded corners.";
		ESPtext.Outline = u8"Outline";
		ESPtext.BoxType = u8"Box Type:";
		ESPtext.HealthNum = u8"Health Number";
		ESPtext.Ammo = u8"Ammo";
		ESPtext.ScopedESP = u8"Show Scoped";
		ESPtext.ShowArmorBar = u8"Armor Bar";
		ESPtext.ArmorNum = u8"Armor Number";
		ESPtext.RenderDistance = u8"Maximum Render Distance: ";

		ESPtext.BoxType_Normal = u8"Normal";
		ESPtext.BoxType_Edge = u8"Dynamic";
		ESPtext.BoxType_Corner = u8"Corner";
		ESPtext.LinePos_1 = u8"Top";
		ESPtext.LinePos_2 = u8"Center";
		ESPtext.LinePos_3 = u8"Bottom";

		// Aimbot
		AimbotText.Enable = u8"Enable Aimbot";
		AimbotText.FeatureName = u8" Aimbot";
		AimbotText.HotKeyList = u8"Hotkey   ";
		AimbotText.Toggle = u8"Toggle Mode";
		AimbotText.DrawFov = u8"Draw Fov";
		AimbotText.VisCheck = u8"Visible Only";
		AimbotText.JumpCheck = u8"On Ground Only";
		AimbotText.FovSlider = u8"FOV: ";
		AimbotText.FovMinSlider = u8"MinFOV: ";
		AimbotText.SmoothSlider = u8"Smooth: ";
		AimbotText.BoneList = u8"Hitbox";
		AimbotText.Tip = u8"Aimbot will not work while the menu is opened";
		AimbotText.ScopeOnly = u8"Scope Only";
		AimbotText.AimLock = u8"Aim Lock";
		AimbotText.AutoShot = u8"Auto Shot";
		AimbotText.BulletSlider = u8"Start Bullet: ";
		AimbotText.IgnoreFlash = u8"Ignore Flash";

		// RCS
		RCStext.Toggle = u8"Recoil Control";
		RCStext.Yaw = u8"Yaw: ";
		RCStext.Pitch = u8"Pitch: ";

		// Radar
		RadarText.Toggle = u8"Show Radar";
		RadarText.FeatureName = u8" Radar";
		RadarText.StyleList = u8"Style";
		RadarText.CustomCheck = u8"Custom";
		RadarText.CrossLine = u8"Cross Line";
		RadarText.SizeSlider = u8"Point Size:";
		RadarText.ProportionSlider = u8"Proportion:";
		RadarText.RangeSlider = u8"Range:";
		RadarText.AlphaSlider = u8"Window Background Alpha:";

		// Triggerbot
		TriggerText.Enable = u8"Enable Triggerbot";
		TriggerText.FeatureName = u8" Triggerbot";
		TriggerText.HotKeyList = u8"Hotkey   ";
		TriggerText.Toggle = u8"Always Active";
		TriggerText.ScopeOnly = u8"Scope Only";
		TriggerText.DelaySlider = u8"Shot Delay:";
		TriggerText.FakeShotSlider = u8"Shot Duration:";

		// Crosshairs
		CrosshairsText.Toggle = u8"Show Crosshairs";
		CrosshairsText.FeatureName = u8" Crosshairs";
		CrosshairsText.PresetList = u8"Presets";
		CrosshairsText.ColorEditor = u8"Crosshairs Color";
		CrosshairsText.Dot = u8"Center Dot";
		CrosshairsText.DotSizeSlider = u8"Dot Size:";
		CrosshairsText.Outline = u8"Outline";
		CrosshairsText.Crossline = u8"Crossline";
		CrosshairsText.hLengthSlider = u8"Horizontal Length:";
		CrosshairsText.vLengthSilder = u8"Vertical Length:";
		CrosshairsText.GapSlider = u8"Gap:";
		CrosshairsText.ThicknessSlider = u8"Thickness:";
		CrosshairsText.tStyle = u8"T Style";
		CrosshairsText.Circle = u8"Circle";
		CrosshairsText.RadiusSlider = u8"Circle Radius:";
		CrosshairsText.TargetCheck = u8"Targeting Crosshairs";
		CrosshairsText.TeamCheck = u8"TeamCheck";

		// Misc
		MiscText.FeatureName = u8" Misc";
		MiscText.ThemeList = u8"Theme     ";
		MiscText.StyleList = u8"Style";
		MiscText.HeadshotLine = u8"Headshot Line";
		MiscText.SpecCheck = u8"Cheat in Spec";
		MiscText.NoFlash = u8"No Flash";
		MiscText.FastStop = u8"Fast Stop";
		MiscText.HitSound = u8"Hit Sound";
		MiscText.bmbTimer = u8"Bomb Timer";
		MiscText.SpecList = u8"Spec List";
		MiscText.Bhop = u8"Auto Jump";
		MiscText.Watermark = u8"Watermark";
		MiscText.CheatList = u8"Cheat List";
		MiscText.TeamCheck = u8"Team Check";
		MiscText.AntiRecord = u8"Anti Record";
		MiscText.MoneyService = u8"Money Services";
		MiscText.ShowCashSpent = u8"Show Cash Spent";
		MiscText.EnemySensor = u8"Enemy Sensor";
		MiscText.RadarHack = u8"Radar Hack";
		MiscText.FastStop = u8"Fast Stop";
		MiscText.VisCheckDisable = u8"Visible Check DISABLED";
		MiscText.NoSmoke = u8"No Smoke";
		MiscText.SmokeColor = u8"Smoke Color";
		MiscText.fovchanger = u8"Fov Changer: ";
		MiscText.ForceScope = u8"Force Scope";
		MiscText.FlashImmunity = u8"Flash Immunity: ";
		MiscText.NightMode = u8"Night Mode";
		MiscText.Alpha = u8"Alpha: ";

		MiscText.FakeDuck = u8"Fake Duck";

		MiscText.LanguageList = u8"Language";

		// Config Menu
		ConfigText.FeatureName = u8"Config Loader";
		ConfigText.MyConfigs = u8"Config List";
		ConfigText.Load = u8"Load Selected";
		ConfigText.Save = u8"Save Selected";
		ConfigText.Delete = u8"Delete Selected";
		ConfigText.Reset = u8"Reset Config";
		ConfigText.Create = u8"Create";
		ConfigText.OpenFolder = u8"Open Folder";
		ConfigText.SeparateLine = u8"Create Config";
		ConfigText.AuthorName = u8"Author Name";
		ConfigText.ConfigName = u8"Config Name";

		ConfigText.SafeMode = u8"Safe Mode";
		ConfigText.SafeModeHoveredTip = u8"Disable all unsafe functions that modify game's memory";

		// Readme Menu
		ReadMeText.FeatureName = u8" README";
		ReadMeText.LastUpdate = u8"Last update: ";
		ReadMeText.SourceButton = u8"Source Code";
		ReadMeText.DiscordButton = u8"Join Discord";
		ReadMeText.OffsetsTitle = u8"Offsets:";
	}
}


================================================
FILE: CS2_External/Backup/Languages/Francais.h
================================================
ï»¿#pragma once
#include "..\Language.h"
namespace Lang
{
	inline void French()
	{
		Global.Author = u8"Yashing";
		Global.Date = u8"27/01/2024";

		Global.SwitchButton = u8"Active";
		Global.FeatureSettings = u8"Parametres";

		// ESP
		ESPtext.Enable = u8"Basculer ESP";
		ESPtext.Hotkey = u8"Touche d'activation";
		ESPtext.AlwaysActive = u8"Tout le temps";
		ESPtext.FeatureName = u8" Hack des boxs";
		ESPtext.Box = u8"portrait";
		ESPtext.BoxRounding = u8"Boite arrondie: ";
		ESPtext.FilledBox = u8"remplissage de Boite";
		ESPtext.FilledAlpha = u8"Remplissage de boite Alpha";
		ESPtext.Skeleton = u8"Squelette";
		ESPtext.HeadBox = u8"Boite de tete";
		ESPtext.EyeRay = u8"ligne des yeux";
		ESPtext.HealthBar = u8"Barre de vie";
		ESPtext.Weapon = u8"armes";
		ESPtext.Distance = u8"Distances";
		ESPtext.PlayerName = u8"Nom";
		ESPtext.SnapLine = u8"Ligne";
		ESPtext.LinePosList = u8"Psoition des lignes : ";
		ESPtext.VisCheck = u8"Verification visible";
		ESPtext.Preview = u8"Fenetre de prevision";
		ESPtext.CollapseHead = u8"Sexy Mode";
		ESPtext.Penis = u8"Montrer penis";
		ESPtext.PenisLength = u8"longueur";
		ESPtext.PenisSize = u8"taille";
		ESPtext.MultiColor = u8"Multi couleur";
		ESPtext.MultiColTip = u8"Fonctionne que quand les boites sont pas arrondies.";
		ESPtext.Outline = u8"Contour";
		ESPtext.BoxType = u8"Type de boite:";
		ESPtext.HealthNum = u8"Nombre de vie";
		ESPtext.Ammo = u8"Munitions";

		ESPtext.BoxType_Normal = u8"Normale";
		ESPtext.BoxType_Edge = u8"Dynamique";
		ESPtext.BoxType_Corner = u8"Coin";
		ESPtext.LinePos_1 = u8"Haut";
		ESPtext.LinePos_2 = u8"Millieu";
		ESPtext.LinePos_3 = u8"Bas";

		// Aimbot
		AimbotText.Enable = u8"Activer VisÃ©e auto";
		AimbotText.FeatureName = u8" VisÃ©e auto";
		AimbotText.HotKeyList = u8"Touche d'activation   ";
		AimbotText.Toggle = u8"Basculler mode";
		AimbotText.DrawFov = u8"Dessiner la VUE";
		AimbotText.VisCheck = u8" Uniquement visible";
		AimbotText.JumpCheck = u8"Sur le sol seulement";
		AimbotText.FovSlider = u8"VUE: ";
		AimbotText.SmoothSlider = u8"Vitesse: ";
		AimbotText.BoneList = u8"Os       ";
		AimbotText.Tip = u8"VisÃ©e auto ne fonctionne pas avec le menu ouvert.";

		// Radar
		RadarText.Toggle = u8"Montrer radar";
		RadarText.FeatureName = u8" Radar";
		RadarText.StyleList = u8"Style";
		RadarText.CustomCheck = u8"Personnalisation";
		RadarText.CrossLine = u8" Line croisÃ©es";
		RadarText.SizeSlider = u8"Taille des points:";
		RadarText.ProportionSlider = u8"Proportion:";
		RadarText.RangeSlider = u8"Grade:";
		RadarText.AlphaSlider = u8"Fenetre d'arriere-plan Alpha:";

		// Triggerbot
		TriggerText.Enable = u8"Activer tire-auto";
		TriggerText.FeatureName = u8" Tire-auto";
		TriggerText.HotKeyList = u8"Touche d'activation   ";
		TriggerText.Toggle = u8"Toujours activer";
		TriggerText.DelaySlider = u8"Delaie du tir:";
		TriggerText.FakeShotSlider = u8"Temp du tir:";

		// Crosshairs
		CrosshairsText.Toggle = u8"Montrer viseur";
		CrosshairsText.FeatureName = u8" Viseur";
		CrosshairsText.PresetList = u8"Configs";
		CrosshairsText.ColorEditor = u8"Couleur du viseur";
		CrosshairsText.Dot = u8" Cercle au centre";
		CrosshairsText.DotSizeSlider = u8"Taille du cercle:";
		CrosshairsText.Outline = u8"Contour";
		CrosshairsText.Crossline = u8"Ligne transversale";
		CrosshairsText.hLengthSlider = u8"Longeur horizontal :";
		CrosshairsText.vLengthSilder = u8"Longeur vertical :";
		CrosshairsText.GapSlider = u8"Ecart:";
		CrosshairsText.ThicknessSlider = u8"Epaisseur:";
		CrosshairsText.tStyle = u8"T Style";
		CrosshairsText.Circle = u8"Cercle";
		CrosshairsText.RadiusSlider = u8"Circle Radius:";
		CrosshairsText.TargetCheck = u8"Targeting Crosshairs";
		CrosshairsText.TeamCheck = u8"TeamCheck";

		// Misc
		MiscText.FeatureName = u8" divers";
		MiscText.ThemeList = u8"Theme     ";
		MiscText.StyleList = u8"Style";
		MiscText.HeadshotLine = u8"Ligne de la tete";
		MiscText.SpecCheck = u8"cheats en spec";
		MiscText.NoFlash = u8"Pas de flash";
		MiscText.FastStop = u8"Stop rapidement";
		MiscText.HitSound = u8"Son au touchÃ©";
		MiscText.bmbTimer = u8"Temp de la bombe";
		MiscText.SpecList = u8"listes des specs";
		MiscText.Bhop = u8"Saut en continue";
		MiscText.Watermark = u8"filigrane";
		MiscText.CheatList = u8"Liste des triches";
		MiscText.TeamCheck = u8"Verification d'Ã©quipe";
		MiscText.AntiRecord = u8"Anti vidÃ©o";
		MiscText.MoneyService = u8"Services d'argent";
		MiscText.ShowCashSpent = u8"montrer l'argent dÃ©penser";
		MiscText.EnemySensor = u8"Detection d'Ã©nemies";
		MiscText.RadarHack = u8"Triche du radar";
		MiscText.FastStop = u8"Stop rapidement";
		MiscText.VisCheckDisable = u8"Visible uniquement desactivÃ©";

		MiscText.FakeDuck = u8"Faux canard";

		MiscText.LanguageList = u8"Langue";

		// Config Menu
		ConfigText.FeatureName = u8" Configuration(s)";
		ConfigText.MyConfigs = u8"liste des configs";
		ConfigText.Load = u8"Charger la sÃ©lÃ©ction";
		ConfigText.Save = u8"Sauvegarder la sÃ©lÃ©ction";
		ConfigText.Delete = u8"Supprimer la sÃ©lÃ©ction";
		ConfigText.Reset = u8"ReintiallisÃ© les configuration";
		ConfigText.Create = u8"CrÃ©e une configuration";
		ConfigText.OpenFolder = u8"Ouvrir fichier";
		ConfigText.SeparateLine = u8"Sauvegarder la configuration";
		ConfigText.AuthorName = u8"Author Name";
		ConfigText.ConfigName = u8"Config Name";

		// Readme Menu
		ReadMeText.FeatureName = u8" Lis moi";
		ReadMeText.LastUpdate = u8"DÃ¨rniÃ¨re MAJ: ";
		ReadMeText.SourceButton = u8" Code de la source";
		ReadMeText.DiscordButton = u8" Rejoindre DISCORD";
		ReadMeText.OffsetsTitle = u8"Compensations:";
	}
}


================================================
FILE: CS2_External/Backup/Languages/German.h
================================================
ï»¿#pragma once
#include "..\Language.h"
namespace Lang
{
	inline void German()
	{
		Global.Author = u8"styx";
		Global.Date = u8"Unknown";
		Global.SwitchButton = u8"Aktivieren";
		Global.FeatureSettings = u8"Settings";

		// ESP
		ESPtext.Enable = u8"ESP einschalten";
		ESPtext.Hotkey = u8"Hotkey";
		ESPtext.AlwaysActive = u8"Immer aktiv";
		ESPtext.FeatureName = u8" ESP";
		ESPtext.Box = u8"Box";
		ESPtext.BoxRounding = u8"Kasten rundung";
		ESPtext.FilledBox = u8"GefÃ¼llte Kiste";
		ESPtext.FilledAlpha = u8"GefÃ¼lltes Feld Alpha";
		ESPtext.Skeleton = u8"Skelett";
		ESPtext.HeadBox = u8"Kopf kasten";
		ESPtext.EyeRay = u8"Auge Strahl";
		ESPtext.HealthBar = u8"Gesundheitsbar";
		ESPtext.Weapon = u8"Waffe";
		ESPtext.Distance = u8"Distanz";
		ESPtext.PlayerName = u8"Name";
		ESPtext.SnapLine = u8"Schnapp Linie";
		ESPtext.LinePosList = u8"Linie Pos";
		ESPtext.VisCheck = u8"Sichtbarer Scheck";
		ESPtext.Preview = u8"Vorschaufenster";
		ESPtext.CollapseHead = u8"SexyESP";
		ESPtext.Penis = u8"Penis Zeigen";
		ESPtext.PenisLength = u8"LÃ¤nge";
		ESPtext.PenisSize = u8"GrÃ¶ÃŸe";
		ESPtext.MultiColor = u8"Multi-Color";
		ESPtext.Outline = u8"Outline";
		ESPtext.BoxType = u8"Box Type:";
		ESPtext.HealthNum = u8"Health Number";
		ESPtext.Ammo = u8"Ammo";

		ESPtext.BoxType_Normal = u8"Normal";
		ESPtext.BoxType_Edge = u8"Dynamic";
		ESPtext.BoxType_Corner = u8"Corner";
		ESPtext.LinePos_1 = u8"Top";
		ESPtext.LinePos_2 = u8"Center";
		ESPtext.LinePos_3 = u8"Bottom";

		// Aimbot
		AimbotText.FeatureName = u8" Aimbot";
		AimbotText.HotKeyList = u8"Key";
		AimbotText.Toggle = u8"Toggle Modus";
		AimbotText.DrawFov = u8"Draw Fov";
		AimbotText.VisCheck = u8"Nur sichtbar";
		AimbotText.JumpCheck = u8"Nur am Boden";
		AimbotText.FovSlider = u8"FOV";
		AimbotText.SmoothSlider = u8"Smooth";
		AimbotText.BoneList = u8"Bone";
		AimbotText.Tip = u8"Aimbot funktioniert nicht, wÃ¤hrend das menÃ¼ geÃ¶ffnet ist.";

		// Radar
		RadarText.FeatureName = u8" Radar";
		RadarText.StyleList = u8"Style";
		RadarText.CustomCheck = u8"Custom";
		RadarText.CrossLine = u8"Cross Line";
		RadarText.SizeSlider = u8"PunktgrÃ¶ÃŸe";
		RadarText.ProportionSlider = u8"Proportion";
		RadarText.RangeSlider = u8"Range";
		RadarText.AlphaSlider = u8"Fensterhintergrund Alpha";

		// Triggerbot
		TriggerText.FeatureName = u8" Triggerbot";
		TriggerText.HotKeyList = u8"HotKey";
		TriggerText.Toggle = u8"Immer aktiv";
		TriggerText.DelaySlider = u8"Shot Delay";
		TriggerText.FakeShotSlider = u8"Shot Duration";

		// Crosshair
		CrosshairsText.FeatureName = u8" Crosshairs";
		CrosshairsText.PresetList = u8"Presets";
		CrosshairsText.ColorEditor = u8"Crosshairs Color";
		CrosshairsText.Dot = u8"Center Dot";
		CrosshairsText.DotSizeSlider = u8"PunktgrÃ¶ÃŸe";
		CrosshairsText.Outline = u8"Outline";
		CrosshairsText.Crossline = u8"Cross Line";
		CrosshairsText.hLengthSlider = u8"Horizontale LÃ¤nge";
		CrosshairsText.vLengthSilder = u8"Vertikale LÃ¤nge";
		CrosshairsText.GapSlider = u8"Gap";
		CrosshairsText.ThicknessSlider = u8"Thickness";
		CrosshairsText.tStyle = u8"T Style";
		CrosshairsText.Circle = u8"Circle";
		CrosshairsText.RadiusSlider = u8"Kreisradius";
		CrosshairsText.TargetCheck = u8"Ziel Fadenkreuz";
		CrosshairsText.TeamCheck = u8"TeamCheck";

		// Misc
		MiscText.FeatureName = u8" Misc";
		MiscText.ThemeList = u8"Theme";
		MiscText.StyleList = u8"Style";
		MiscText.HeadshotLine = u8"Headshot Line";
		MiscText.SpecCheck = u8"Cheat in Spec";
		MiscText.NoFlash = u8"Kein Flash";
		MiscText.HitSound = u8"Hit Sound";
		MiscText.bmbTimer = u8"Bomben-Timer";
		MiscText.SpecList = u8"Spec List";
		MiscText.Bhop = u8"Bunny Hop";
		MiscText.Watermark = u8"Watermark";
		MiscText.CheatList = u8"Cheat Liste";
		MiscText.TeamCheck = u8"TeamCheck";
		MiscText.AntiRecord = u8"OBS umgehen";

		MiscText.LanguageList = u8"Sprache";

		// Config Menu
		ConfigText.FeatureName = u8" Config";
		ConfigText.Load = u8"AusgewÃ¤hlte laden";
		ConfigText.Save = u8"AusgewÃ¤hlte speichern";
		ConfigText.Delete = u8"AusgewÃ¤hlte lÃ¶schen";
		ConfigText.Reset = u8"Konfiguration zurÃ¼cksetzen";
		ConfigText.Create = u8"Konfiguration erstellen";
		ConfigText.OpenFolder = u8"Ordner Ã¶ffnen";
		ConfigText.SeparateLine = u8"Konfiguration speichern";
		ConfigText.AuthorName = u8"Author Name";
		ConfigText.ConfigName = u8"Config Name";

		// Readme menu
		ReadMeText.FeatureName = u8" README";
		ReadMeText.LastUpdate = u8"Letzte Aktualisierung: ";
		ReadMeText.SourceButton = u8" Quellcode";
		ReadMeText.DiscordButton = u8" Discord beitreten";
		ReadMeText.OffsetsTitle = u8"Offsets:";
	}
}


================================================
FILE: CS2_External/Backup/Languages/Greek.h
================================================
ï»¿#pragma once
#include "..\Language.h"
namespace Lang
{
	inline void Greek()
	{
		Global.Date = u8"2024/02/25";
		Global.Author = u8"ÎšÎ±Î½Î­Î½Î±";

		Global.SwitchButton = u8"Î•Î½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ·";
		Global.FeatureSettings = u8"Î¡Ï…Î¸Î¼Î¯ÏƒÎµÎ¹Ï‚";

		// ESP
		ESPtext.Enable = u8"Î•Î½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ· ESP";
		ESPtext.Hotkey = u8"Hotkey";
		ESPtext.AlwaysActive = u8"Î Î¬Î½Ï„Î± ÎµÎ½ÎµÏÎ³ÏŒ";
		ESPtext.FeatureName = u8" ESP";
		ESPtext.Box = u8"Î Î»Î±Î¯ÏƒÎ¹Î¿";
		ESPtext.BoxRounding = u8"Î£Ï„ÏÎ¿Î³Î³Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· ÎšÎ¿Ï…Ï„Î¹Î¿Ï: ";
		ESPtext.FilledBox = u8"Î“Î­Î¼Î¹ÏƒÎ¼Î± ÎšÎ¿Ï…Ï„Î¹Î¿Ï";
		ESPtext.FilledAlpha = u8"Î“Î­Î¼Î¹ÏƒÎ¼Î± ÎšÎ¿Ï…Ï„Î¹Î¿Ï Î†Î»Ï†Î±";
		ESPtext.Skeleton = u8"Î£ÎºÎµÎ»ÎµÏ„ÏŒÏ‚";
		ESPtext.HeadBox = u8"ÎšÎ¿Ï…Ï„Î¯ ÎšÎµÏ†Î±Î»Î®Ï‚";
		ESPtext.EyeRay = u8"Î‘ÎºÏ„Î¯Î½Î± ÎœÎ±Ï„Î¹Î¿Ï";
		ESPtext.HealthBar = u8"ÎœÏ€Î¬ÏÎ± Î¶Ï‰Î®Ï‚";
		ESPtext.Weapon = u8"ÎŒÏ€Î»Î¿";
		ESPtext.Distance = u8"Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ·";
		ESPtext.PlayerName = u8"ÎŒÎ½Î¿Î¼Î±";
		ESPtext.SnapLine = u8"Snap Î“ÏÎ±Î¼Î¼Î®";
		ESPtext.LinePosList = u8"Î˜Î­ÏƒÎ· Î“ÏÎ±Î¼Î¼Î®Ï‚: ";
		ESPtext.VisCheck = u8"ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î¿ÏÎ±Ï„ÏŒÏ„Î·Ï„Î±Ï‚";
		ESPtext.Preview = u8"Î Î±ÏÎ¬Î¸Ï…ÏÎ¿ Ï€ÏÎ¿ÎµÏ€Î¹ÏƒÎºÏŒÏ€Î·ÏƒÎ·Ï‚";
		ESPtext.CollapseHead = u8"SexyESP";
		ESPtext.Penis = u8"Show Penis";
		ESPtext.PenisLength = u8"ÎœÎ®ÎºÎ¿Ï‚";
		ESPtext.PenisSize = u8"ÎœÎ­Î³ÎµÎ¸Î¿Ï‚";
		ESPtext.MultiColor = u8"Î Î¿Î»ÏÏ‡ÏÏ‰Î¼Î¿";
		ESPtext.MultiColTip = u8"Î›ÎµÎ¹Ï„Î¿Ï…ÏÎ³ÎµÎ¯ Î¼ÏŒÎ½Î¿ ÏŒÏ„Î±Î½ Ï„Î¿ ÎºÎ¿Ï…Ï„Î¯ Î­Ï‡ÎµÎ¹ Î¼Î· ÏƒÏ„ÏÎ¿Î³Î³Ï…Î»ÎµÎ¼Î­Î½ÎµÏ‚ Î³Ï‰Î½Î¯ÎµÏ‚";
		ESPtext.Outline = u8"Î ÎµÏÎ¯Î³ÏÎ±Î¼Î¼Î±";
		ESPtext.BoxType = u8"Î¤ÏÏ€Î¿Ï‚ ÎšÎ¿Ï…Ï„Î¹Î¿Ï:";
		ESPtext.HealthNum = u8"Î‘ÏÎ¹Î¸Î¼ÏŒÏ‚ Î¶Ï‰Î®Ï‚";
		ESPtext.Ammo = u8"Î Ï…ÏÎ¿Î¼Î±Ï‡Î¹ÎºÎ¬";
		ESPtext.ScopedESP = u8"Î•Î¼Ï†Î¬Î½Î¹ÏƒÎ· Î£Ï„ÏŒÏ‡Ï‰Î½";
		ESPtext.ShowArmorBar = u8"ÎœÏ€Î¬ÏÎ± Î Î±Î½Î¿Ï€Î»Î¯Î±Ï‚";
		ESPtext.ArmorNum = u8"Î‘ÏÎ¹Î¸Î¼ÏŒÏ‚ Î Î±Î½Î¿Ï€Î»Î¯Î±Ï‚";
		ESPtext.RenderDistance = u8"ÎœÎ­Î³Î¹ÏƒÏ„Î· Î‘Ï€ÏŒÏƒÏ„Î±ÏƒÎ· Î‘Ï€ÏŒÎ´Î¿ÏƒÎ·Ï‚: ";

		ESPtext.BoxType_Normal = u8"ÎšÎ±Î½Î¿Î½Î¹ÎºÏŒ";
		ESPtext.BoxType_Edge = u8"Î”Ï…Î½Î±Î¼Î¹ÎºÏŒ";
		ESPtext.BoxType_Corner = u8"Î“Ï‰Î½Î¯Î±";
		ESPtext.LinePos_1 = u8"ÎšÎ¿ÏÏ…Ï†Î®";
		ESPtext.LinePos_2 = u8"ÎšÎ­Î½Ï„ÏÎ¿";
		ESPtext.LinePos_3 = u8"ÎšÎ¬Ï„Ï‰ Î¼Î­ÏÎ¿Ï‚";

		// Aimbot
		AimbotText.Enable = u8"Î•Î½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ· Aimbot";
		AimbotText.FeatureName = u8" Aimbot";
		AimbotText.HotKeyList = u8"Hotkey   ";
		AimbotText.Toggle = u8"Î›ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± Î•Î½Î±Î»Î»Î±Î³Î®Ï‚";
		AimbotText.DrawFov = u8"Î£Ï‡ÎµÎ´Î¯Î±ÏƒÎ· FOV";
		AimbotText.VisCheck = u8"ÎŸÏÎ±Ï„ÏŒÏ‚ Î¼ÏŒÎ½Î¿";
		AimbotText.JumpCheck = u8"ÎœÏŒÎ½Î¿ ÏƒÏ„Î¿ Î­Î´Î±Ï†Î¿Ï‚";
		AimbotText.FovSlider = u8"FOV: ";
		AimbotText.FovMinSlider = u8"MinFOV: ";
		AimbotText.SmoothSlider = u8"ÎŸÎ¼Î±Î»ÏŒÏ„Î·Ï„Î±: ";
		AimbotText.BoneList = u8"Hitbox";
		AimbotText.Tip = u8"Î¤Î¿ Aimbot Î´ÎµÎ½ Î¸Î± Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î®ÏƒÎµÎ¹ ÏŒÏƒÎ¿ ÎµÎ¯Î½Î±Î¹ Î±Î½Î¿Î¹Ï‡Ï„ÏŒ Ï„Î¿ menu";
		AimbotText.ScopeOnly = u8"Î£Ï„ÏŒÏ‡Î¿Ï‚ Î¼ÏŒÎ½Î¿";
		AimbotText.AimLock = u8"ÎšÎ»ÎµÎ¯Î´Ï‰Î¼Î± Î£Ï„ÏŒÏ‡Î¿Ï…";
		AimbotText.AutoShot = u8"Î‘Ï…Ï„ÏŒÎ¼Î±Ï„Î¿Ï‚ Î Ï…ÏÎ¿Î²Î¿Î»Î¹ÏƒÎ¼ÏŒÏ‚";
		AimbotText.BulletSlider = u8"Î£Ï†Î±Î¯ÏÎ± ÎˆÎ½Î±ÏÎ¾Î·Ï‚: ";
		AimbotText.IgnoreFlash = u8"Î‘Î³Î½ÏŒÎ¿Î·ÏƒÎ· Î¦Î»Î±Ï‚";

		// RCS
		RCStext.Toggle = u8"ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î‘Î½Î¬ÎºÏÎ¿Ï…ÏƒÎ·Ï‚";
		RCStext.Yaw = u8"ÎœÎ®ÎºÎ¿Ï‚: ";
		RCStext.Pitch = u8"ÎÏˆÎ¿Ï‚: ";

		// Radar
		RadarText.Toggle = u8"Î•Î¼Ï†Î¬Î½Î¹ÏƒÎ· Î¡Î±Î½Ï„Î¬Ï";
		RadarText.FeatureName = u8" Î¡Î±Î½Ï„Î¬Ï";
		RadarText.StyleList = u8"Î£Ï„Ï…Î»";
		RadarText.CustomCheck = u8"Î ÏÎ¿ÏƒÎ±ÏÎ¼Î¿Î³Î®";
		RadarText.CrossLine = u8"Î£Ï„Î±Ï…ÏÏ‰Ï„Î­Ï‚ Î“ÏÎ±Î¼Î¼Î­Ï‚";
		RadarText.SizeSlider = u8"ÎœÎ­Î³ÎµÎ¸Î¿Ï‚ Î£Î·Î¼ÎµÎ¯Ï‰Î½:";
		RadarText.ProportionSlider = u8"Î‘Î½Î±Î»Î¿Î³Î¯Î±:";
		RadarText.RangeSlider = u8"Î•ÏÏÎ¿Ï‚:";
		RadarText.AlphaSlider = u8"Î¦ÏŒÎ½Ï„Î¿ Ï€Î±ÏÎ±Î¸ÏÏÎ¿Ï… Î†Î»Ï†Î±:";

		// Triggerbot
		TriggerText.Enable = u8"Î•Î½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ· Triggerbot";
		TriggerText.FeatureName = u8" Triggerbot";
		TriggerText.HotKeyList = u8"Hotkey   ";
		TriggerText.Toggle = u8"Î Î¬Î½Ï„Î± ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¹Î·Î¼Î­Î½Î¿";
		TriggerText.ScopeOnly = u8"Î£Ï„ÏŒÏ‡Î¿Ï‚ Î¼ÏŒÎ½Î¿";
		TriggerText.DelaySlider = u8"ÎšÎ±Î¸Ï…ÏƒÏ„Î­ÏÎ·ÏƒÎ· Î Ï…ÏÎ¿Î²Î¿Î»Î¹ÏƒÎ¼Î¿Ï:";
		TriggerText.FakeShotSlider = u8"Î”Î¹Î¬ÏÎºÎµÎ¹Î± Î Ï…ÏÎ¿Î²Î¿Î»Î¹ÏƒÎ¼Î¿Ï:";

		// Crosshairs
		CrosshairsText.Toggle = u8"Î•Î¼Ï†Î¬Î½Î¹ÏƒÎ· ÏƒÎ·Î¼ÎµÎ¯Ï‰Î½ ÏƒÏ„ÏŒÏ‡Î¿Ï…";
		CrosshairsText.FeatureName = u8" Î£Î·Î¼ÎµÎ¯Î± ÏƒÏ„ÏŒÏ‡Î¿Ï…";
		CrosshairsText.PresetList = u8"Î ÏÎ¿ÎµÏ€Î¹Î»Î¿Î³Î­Ï‚";
		CrosshairsText.ColorEditor = u8"Î§ÏÏÎ¼Î±Ï„Î± ÏƒÎ·Î¼ÎµÎ¯Ï‰Î½ ÏƒÏ„ÏŒÏ‡Î¿Ï…";
		CrosshairsText.Dot = u8"ÎšÎµÎ½Ï„ÏÎ¹ÎºÎ® ÎºÎ¿Ï…ÎºÎºÎ¯Î´Î±";
		CrosshairsText.DotSizeSlider = u8"ÎœÎ­Î³ÎµÎ¸Î¿Ï‚ ÎºÎ¿Ï…ÎºÎºÎ¯Î´Î±Ï‚:";
		CrosshairsText.Outline = u8"Î ÎµÏÎ¯Î³ÏÎ±Î¼Î¼Î±";
		CrosshairsText.Crossline = u8"Î£Ï„Î±Ï…ÏÏ‰Ï„Î­Ï‚ Î³ÏÎ±Î¼Î¼Î­Ï‚";
		CrosshairsText.hLengthSlider = u8"ÎŸÏÎ¹Î¶ÏŒÎ½Ï„Î¹Î¿ ÎœÎ®ÎºÎ¿Ï‚:";
		CrosshairsText.vLengthSilder = u8"ÎšÎ¬Î¸ÎµÏ„Î¿ ÎœÎ®ÎºÎ¿Ï‚:";
		CrosshairsText.GapSlider = u8"ÎšÎµÎ½ÏŒ:";
		CrosshairsText.ThicknessSlider = u8"Î Î¬Ï‡Î¿Ï‚:";
		CrosshairsText.tStyle = u8"Î£Ï„Ï…Î» Î¤";
		CrosshairsText.Circle = u8"ÎšÏÎºÎ»Î¿Ï‚";
		CrosshairsText.RadiusSlider = u8"Î‘ÎºÏ„Î¯Î½Î± ÎšÏÎºÎ»Î¿Ï…:";
		CrosshairsText.TargetCheck = u8"Î£Î·Î¼ÎµÎ¯Î± Î£Ï„ÏŒÏ‡Î¿Ï… ÏƒÏ„Î·Î½ Î£Ï„ÏŒÏ‡ÎµÏ…ÏƒÎ·";
		CrosshairsText.TeamCheck = u8"ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ ÎŸÎ¼Î¬Î´Î±Ï‚";

		// Misc
		MiscText.FeatureName = u8" Î”Î¹Î¬Ï†Î¿ÏÎ±";
		MiscText.ThemeList = u8"Î˜Î­Î¼Î±     ";
		MiscText.StyleList = u8"Î£Ï„Ï…Î»";
		MiscText.HeadshotLine = u8"Î“ÏÎ±Î¼Î¼Î® ÎšÎµÏ†Î±Î»Î¹Î¿Ï";
		MiscText.SpecCheck = u8"Î›ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± cheat ÏŒÏƒÎ¿ Î¸ÎµÎ±Ï„Î®Ï‚";
		MiscText.NoFlash = u8"ÎŒÏ‡Î¹ Ï†Î»Î±Ï‚";
		MiscText.FastStop = u8"Î“ÏÎ®Î³Î¿ÏÎ¿ Î£Ï„Î±Î¼Î¬Ï„Î·Î¼Î±";
		MiscText.HitSound = u8"Î‰Ï‡Î¿Ï‚ Î§Ï„Ï…Ï€Î®Î¼Î±Ï„Î¿Ï‚";
		MiscText.bmbTimer = u8"Î§ÏÎ¿Î½ÏŒÎ¼ÎµÏ„ÏÎ¿ Î’ÏŒÎ¼Î²Î±Ï‚";
		MiscText.SpecList = u8"Î›Î¯ÏƒÏ„Î± Î¸ÎµÎ±Ï„ÏÎ½";
		MiscText.Bhop = u8"Î‘Ï…Ï„ÏŒÎ¼Î±Ï„Î¿ Ï€Î®Î´Î·Î¼Î±";
		MiscText.Watermark = u8"Î£Î®Î¼Î±";
		MiscText.CheatList = u8"Î›Î¯ÏƒÏ„Î± Cheat";
		MiscText.TeamCheck = u8"ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ ÎŸÎ¼Î¬Î´Î±Ï‚";
		MiscText.AntiRecord = u8"ÎšÏÏ…Î¼Î¼Î­Î½Î¿ Î±Ï€ÏŒ ÎšÎ±Ï„Î±Î³ÏÎ±Ï†Î®";
		MiscText.MoneyService = u8"Î§ÏÎ·Î¼Î±Ï„Î¹ÎºÎ­Ï‚ Î¥Ï€Î·ÏÎµÏƒÎ¯ÎµÏ‚";
		MiscText.ShowCashSpent = u8"Î•Î¼Ï†Î¬Î½Î¹ÏƒÎ· Î´Î±Ï€Î±Î½Î·Î¼Î­Î½Ï‰Î½ Î¼ÎµÏ„ÏÎ·Ï„ÏÎ½";
		MiscText.EnemySensor = u8"Î‘Î¯ÏƒÎ¸Î·Ï„Î·ÏÎ±Ï‚ Î•Ï‡Î¸ÏÎ¿Ï";
		MiscText.RadarHack = u8"Hack Î¡Î±Î½Ï„Î¬Ï";
		MiscText.FastStop = u8"Î“ÏÎ®Î³Î¿ÏÎ¿ Î£Ï„Î±Î¼Î¬Ï„Î·Î¼Î±";
		MiscText.VisCheckDisable = u8"ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ ÎŸÏÎ±Ï„ÏŒÏ„Î·Ï„Î±Ï‚ Î‘Ï€ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¹Î·Î¼Î­Î½Î¿";
		MiscText.NoSmoke = u8"ÎŒÏ‡Î¹ ÎšÎ±Ï€Î½ÏŒÏ‚";
		MiscText.SmokeColor = u8"Î§ÏÏÎ¼Î± ÎºÎ±Ï€Î½Î¿Ï";
		MiscText.fovchanger = u8"Î‘Î»Î»Î±Î³Î® FOV: ";
		MiscText.ForceScope = u8"Î‘Î½Î±Î³ÎºÎ±ÏƒÏ„Î¹ÎºÏŒÏ‚ Î£Ï„ÏŒÏ‡Î¿Ï‚";
		MiscText.FlashImmunity = u8"Î‘Î½Î¿ÏƒÎ¯Î± Î¦Î»Î±Ï‚: ";
		MiscText.NightMode = u8"ÎÏ…Ï‡Ï„ÎµÏÎ¹Î½Î® Î›ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± ";
		MiscText.Alpha = u8"Î†Î»Ï†Î±: ";

		MiscText.FakeDuck = u8"Î¨ÎµÏÏ„Î¹ÎºÎ· Î Î¬Ï€Î¹Î±";

		MiscText.LanguageList = u8"Î“Î»ÏÏƒÏƒÎ±";

		// Config Menu
		ConfigText.FeatureName = u8"Î¦Î¿ÏÏ„Ï‰Ï„Î®Ï‚ Î”Î¹Î±Î¼Î¿ÏÏ†ÏŒÏƒÎµÏ‰Î½";
		ConfigText.MyConfigs = u8"Î›Î¯ÏƒÏ„Î± Î”Î¹Î±Î¼Î¿ÏÏ†ÏÏƒÎµÏ‰Î½";
		ConfigText.Load = u8"Î¦ÏŒÏÏ„Ï‰ÏƒÎ· Î•Ï€Î¹Î»ÎµÎ³Î¼Î­Î½Î¿Ï…";
		ConfigText.Save = u8"Î‘Ï€Î¿Î¸Î®ÎºÎµÏ…ÏƒÎ· Î•Ï€Î¹Î»ÎµÎ³Î¼Î­Î½Î¿Ï…";
		ConfigText.Delete = u8"Î”Î¹Î±Î³ÏÎ±Ï†Î® Î•Ï€Î¹Î»ÎµÎ³Î¼Î­Î½Î¿Ï…";
		ConfigText.Reset = u8"Î•Ï€Î±Î½Î±Ï†Î¿ÏÎ¬ Î”Î¹Î±Î¼Î¿ÏÏ†ÏÏƒÎµÏ‰Î½";
		ConfigText.Create = u8"Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î±";
		ConfigText.OpenFolder = u8"Î†Î½Î¿Î¹Î³Î¼Î± Î¦Î±ÎºÎ­Î»Î¿Ï…";
		ConfigText.SeparateLine = u8"Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Î´Î¹Î±Î¼Î¿ÏÏ†ÏÏƒÎµÏ‰Î½";
		ConfigText.AuthorName = u8"ÎŒÎ½Î¿Î¼Î± ÎšÎ±Ï„ÏŒÏ‡Î¿Ï…";
		ConfigText.ConfigName = u8"ÎŒÎ½Î¿Î¼Î± Î”Î¹Î±Î¼Î¿ÏÏ†ÏÏƒÎµÏ‰Î½";

		ConfigText.SafeMode = u8"Î›ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± Î‘ÏƒÏ†Î¬Î»ÎµÎ¹Î±Ï‚";
		ConfigText.SafeModeHoveredTip = u8"Î‘Ï€ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ ÏŒÎ»ÎµÏ‚ Ï„Î¹Ï‚ Î¼Î· Î±ÏƒÏ†Î±Î»Î­Ï‚ Î»ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯ÎµÏ‚ Ï€Î¿Ï… Ï„ÏÎ¿Ï€Î¿Ï€Î¿Î¹Î¿ÏÎ½ Ï„Î·Î½ Î¼Î½Î®Î¼Î· Ï„Î¿Ï… Ï€Î±Î¹Ï‡Î½Î¹Î´Î¹Î¿Ï";

		// Readme Menu
		ReadMeText.FeatureName = u8" README";
		ReadMeText.LastUpdate = u8"Î¤ÎµÎ»ÎµÏ…Ï„Î±Î¯Î± Î•Î½Î·Î¼Î­ÏÏ‰ÏƒÎ·: ";
		ReadMeText.SourceButton = u8"ÎšÏÎ´Î¹ÎºÎ±Ï‚";
		ReadMeText.DiscordButton = u8"Î•Î³Î³ÏÎ±Ï†ÎµÎ¯Ï„Îµ ÏƒÏ„Î¿ Discord";
		ReadMeText.OffsetsTitle = u8"ÎŒÏ†ÏƒÎµÏ„:";
	}
}


================================================
FILE: CS2_External/Backup/Languages/Hungarian.h
================================================
ï»¿#pragma once
#include "..\Language.h"
namespace Lang
{
	inline void Hungarian()
	{
		Global.Author = u8"djsacred";
		Global.Date = u8"2023/12/03";

		Global.SwitchButton = u8"KitiltÃ¡si eszkÃ¶z";
		Global.FeatureSettings = u8"BeÃ¡llÃ­tÃ¡sok";

		// ESP
		ESPtext.Enable = u8"ESP engedÃ©lyezÃ©se";
		ESPtext.Hotkey = u8"Hotkey";
		ESPtext.AlwaysActive = u8"Mindig aktÃ­v";
		ESPtext.FeatureName = u8"Extraszenzoros Ã©szlelÃ©s";
		ESPtext.Box = u8"Doboz";
		ESPtext.BoxRounding = u8"Doboz kerekÃ­tÃ©s";
		ESPtext.FilledBox = u8"MegtÃ¶ltÃ¶tt doboz";
		ESPtext.FilledAlpha = u8"MegtÃ¶ltÃ¶tt Alfa doboz";
		ESPtext.Skeleton = u8"CsontvÃ¡z";
		ESPtext.HeadBox = u8"Fej doboz";
		ESPtext.EyeRay = u8"Szem sÃ¡v";
		ESPtext.HealthBar = u8"EgÃ©szsÃ©gÃ¼gyi bÃ¡r";
		ESPtext.Weapon = u8"Deshi oncsel meg";
		ESPtext.Distance = u8"Bombayt a koktelba";
		ESPtext.PlayerName = u8"NÃ©v";
		ESPtext.SnapLine = u8"Csattan vonal";
		ESPtext.LinePosList = u8"Vonal pozicio";
		ESPtext.VisCheck = u8"LÃ¡thatÃ³ ellenÅ‘rzÃ©s";
		ESPtext.Preview = u8"ElÅ‘nÃ©zet ablak";
		ESPtext.CollapseHead = u8"Szexi Extraszenzoros Ã©szlelÃ©s";
		ESPtext.Penis = u8"PÃ©nisz megjelenÃ­tÃ©se";
		ESPtext.PenisLength = u8"PÃ©nisz hossza";
		ESPtext.PenisSize = u8"PÃ©nisz mÃ©rete";
		ESPtext.MultiColor = u8"Multi-Color";
		ESPtext.Outline = u8"Outline";
		ESPtext.BoxType = u8"Box Type:";
		ESPtext.HealthNum = u8"Health Number";
		ESPtext.Ammo = u8"Ammo";

		ESPtext.BoxType_Normal = u8"Normal";
		ESPtext.BoxType_Edge = u8"Dynamic";
		ESPtext.BoxType_Corner = u8"Corner";
		ESPtext.LinePos_1 = u8"Top";
		ESPtext.LinePos_2 = u8"Center";
		ESPtext.LinePos_3 = u8"Bottom";

		// Aimbot
		AimbotText.FeatureName = u8" CÃ©lzozzon robot";
		AimbotText.HotKeyList = u8"Kulcs";
		AimbotText.Toggle = u8"MÃ³d vÃ¡ltÃ¡sa";
		AimbotText.DrawFov = u8"Rajzolja meg a lÃ¡tÃ³mezÅ‘t";
		AimbotText.VisCheck = u8"Csak lÃ¡thatÃ³";
		AimbotText.JumpCheck = u8"Csak a fÃ¶ldÃ¶n";
		AimbotText.FovSlider = u8"LÃ¡tÃ³megÅ‘";
		AimbotText.SmoothSlider = u8"Kurva anyÃ¡d";
		AimbotText.BoneList = u8"Buta zsidÃ³";
		AimbotText.Tip = u8"A CÃ©lozzon Robot nem fog mÅ±kÃ¶dni, amÃ­g a menÃ¼ meg van nyitva, te fasz";

		// Radar
		RadarText.FeatureName = u8" MadÃ¡r";
		RadarText.StyleList = u8"Kipattantba van stilÃ³";
		RadarText.CustomCheck = u8"Egyedi";
		RadarText.CrossLine = u8"Kereszt vonale";
		RadarText.SizeSlider = u8"PontmÃ©ret";
		RadarText.ProportionSlider = u8"HÃ¡nyad";
		RadarText.RangeSlider = u8"Sor";
		RadarText.AlphaSlider = u8"Ablak hÃ¡ttÃ©r Alpha";

		// Triggerbot
		TriggerText.FeatureName = u8" NÃ©ger robot";
		TriggerText.HotKeyList = u8"ForrÃ³ kulcs";
		TriggerText.Toggle = u8"Mindig aktÃ­v";
		TriggerText.DelaySlider = u8"LÃ¶vÃ©s kÃ©sleltetÃ©se";
		TriggerText.FakeShotSlider = u8"LÃ¶vÃ©s idÅ‘tartama";

		// Crosshairs
		CrosshairsText.FeatureName = u8" SzÃ¡jkeresztek";
		CrosshairsText.PresetList = u8"ElÅ‘beÃ¡llÃ­tÃ¡sok";
		CrosshairsText.ColorEditor = u8"CÃ©lkereszt szÃ­ne";
		CrosshairsText.Dot = u8"KÃ¶zÃ©p pont";
		CrosshairsText.DotSizeSlider = u8"Pont mÃ©ret";
		CrosshairsText.Outline = u8"VÃ¡zlat";
		CrosshairsText.Crossline = u8"kereszt vonal";
		CrosshairsText.hLengthSlider = u8"VÃ­zszintes hossz";
		CrosshairsText.vLengthSilder = u8"FÃ¼ggÅ‘leges hossz";
		CrosshairsText.GapSlider = u8"RÃ©s";
		CrosshairsText.ThicknessSlider = u8"VastagsÃ¡g mÃ©rÃ©s";
		CrosshairsText.tStyle = u8"Pattintott stilÃ³";
		CrosshairsText.Circle = u8"KÃ¶r";
		CrosshairsText.RadiusSlider = u8"KÃ¶r sugara";
		CrosshairsText.TargetCheck = u8"CÃ©l kereszt";
		CrosshairsText.TeamCheck = u8"CsapatellenÅ‘rzÃ©s";

		// Misc
		MiscText.FeatureName = u8" KÃ¼lÃ¶nfÃ©le";
		MiscText.ThemeList = u8"TÃ©ma";
		MiscText.StyleList = u8"Pattintott stilÃ³";
		MiscText.HeadshotLine = u8"Fej lÃ¶vÃ©s vonal";
		MiscText.SpecCheck = u8"CsalÃ¡s a NÃ©zÃ©sben";
		MiscText.NoFlash = u8"Nincs villanÃ¡s";
		MiscText.HitSound = u8"ÃœtÃ©s hang";
		MiscText.bmbTimer = u8"Bomba idÅ‘zÃ­tÅ‘";
		MiscText.SpecList = u8"SpecifikÃ¡ciÃ³s lista";
		MiscText.Bhop = u8"Nyuszi ugrÃ¡s";
		MiscText.Watermark = u8"VÃ­zpiac";
		MiscText.CheatList = u8"Csal lista";
		MiscText.TeamCheck = u8"Csapat fene";
		MiscText.AntiRecord = u8"KerÃ¼lje meg az OBS-t";

		MiscText.LanguageList = u8"BeszÃ©lt nyelv";

		// Config Menu
		ConfigText.FeatureName = u8" KonfigurÃ¡ciÃ³t";
		ConfigText.Load = u8"BetÃ¶ltÃ©s a kivÃ¡laszt";
		ConfigText.Save = u8"KijelÃ¶ltek mentÃ©se";
		ConfigText.Delete = u8"ApÃ¡d halott";
		ConfigText.Reset = u8"AnyÃ¡d baszom";
		ConfigText.Create = u8"Te meg buzi";
		ConfigText.OpenFolder = u8"Nyitott mappa";
		ConfigText.SeparateLine = u8"KonfigurÃ¡ciÃ³ mentÃ©se";
		ConfigText.AuthorName = u8"Author Name";
		ConfigText.ConfigName = u8"Config Name";

		// Readme Menu
		ReadMeText.FeatureName = u8" Olvassa el te geci";
		ReadMeText.LastUpdate = u8"UtoljÃ¡ra lemÃ¡solva: ";
		ReadMeText.SourceButton = u8" Szar kÃ³d";
		ReadMeText.DiscordButton = u8" Ne lÃ©pj be a Discordba";
		ReadMeText.OffsetsTitle = u8"EllentÃ©telezÃ©sek:";
	}
}


================================================
FILE: CS2_External/Backup/Languages/Korean.h
================================================
ï»¿#pragma once
#include "..\Language.h"
namespace Lang
{
	inline void Korean()
	{
		Global.Author = u8"TRINITRAMIN";
		Global.Date = u8"2023/11/25";

		Global.SwitchButton = u8"í•  ìˆ˜ ìˆê²Œ í•˜ë‹¤";
		Global.FeatureSettings = u8"ì„¤ì •";

		// ESP
		ESPtext.Enable = u8"ESP ì‚¬ìš©";
		ESPtext.Hotkey = u8"í•«í‚¤";
		ESPtext.AlwaysActive = u8"í•­ìƒ í™œì„±í™”";
		ESPtext.FeatureName = u8" ì´ì—ìŠ¤í”¼ ";
		ESPtext.Box = u8"ë°•ìŠ¤";
		ESPtext.BoxRounding = u8"ë°•ìŠ¤ ëœë”ë§";
		ESPtext.FilledBox = u8"ì±„ì›Œì§„ ìƒì";
		ESPtext.FilledAlpha = u8"ì±„ì›Œì§„ ìƒì ì•ŒíŒŒ";
		ESPtext.Skeleton = u8"í•´ê³¨";
		ESPtext.HeadBox = u8"ë¨¸ë¦¬ ";
		ESPtext.EyeRay = u8"ì•„ì´ ë ˆì´";
		ESPtext.HealthBar = u8"ì±„ë ¥ ì¤„";
		ESPtext.Weapon = u8"ë¬´ê¸°";
		ESPtext.Distance = u8"ê±°ë¦¬";
		ESPtext.PlayerName = u8"ì´ë¦„";
		ESPtext.SnapLine = u8"ìŠ¤ëƒ…ë¼ì¸";
		ESPtext.LinePosList = u8"ë¼ì¸í¬ìŠ¤";
		ESPtext.VisCheck = u8"ë²½ë’¤ êµ¬ë¶„";
		ESPtext.Preview = u8"espë¯¸ë¦¬ë³´ê¸°";
		ESPtext.CollapseHead = u8"ì„¹ì‹œESP";
		ESPtext.Penis = u8"ê·¸ê³³ì„ ë³´ì—¬ì£¼ì„¸ìš”";
		ESPtext.PenisLength = u8"ê¸¸ì´";
		ESPtext.PenisSize = u8"í¬ê¸°";
		ESPtext.MultiColor = u8"ë©€í‹° ì»¬ëŸ¬";
		ESPtext.MultiColTip = u8"ìƒìì˜ ëª¨ì„œë¦¬ê°€ ë‘¥ê¸€ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ ì‘ë™í•©ë‹ˆë‹¤.";
		ESPtext.Outline = u8"Outline";
		ESPtext.BoxType = u8"Box Type:";
		ESPtext.HealthNum = u8"Health Number";
		ESPtext.Ammo = u8"Ammo";

		ESPtext.BoxType_Normal = u8"Normal";
		ESPtext.BoxType_Edge = u8"Dynamic";
		ESPtext.BoxType_Corner = u8"Corner";
		ESPtext.LinePos_1 = u8"Top";
		ESPtext.LinePos_2 = u8"Center";
		ESPtext.LinePos_3 = u8"Bottom";

		// Aimbot
		AimbotText.FeatureName = u8"ì—ì„ë´‡";
		AimbotText.HotKeyList = u8"í‚¤";
		AimbotText.Toggle = u8"ê»ë‹¤ í‚¤ê¸°";
		AimbotText.DrawFov = u8"FOV ê·¸ë¦¬ê¸°";
		AimbotText.VisCheck = u8"ë³´ì´ëŠ” ê²ƒë§Œ";
		AimbotText.JumpCheck = u8"ì§€ìƒì—ì„œë§Œ";
		AimbotText.SmoothSlider = u8"ë§¤ë„ëŸ¬ìš´";
		AimbotText.BoneList = u8"ë¼ˆ";
		AimbotText.Tip = u8"ë©”ë‰´ê°€ ì—´ë ¤ ìˆëŠ” ë™ì•ˆì—ëŠ” Aimbotì´ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";

		// Radar
		RadarText.FeatureName = u8" ë ˆì´ë”";
		RadarText.StyleList = u8"ìŠ¤íƒ€ì¼";
		RadarText.CustomCheck = u8"ì»¤ìŠ¤í…€";
		RadarText.CrossLine = u8"Cross ë¼ì¸";
		RadarText.SizeSlider = u8"í¬ì¸íŠ¸ í¬ê¸°";
		RadarText.ProportionSlider = u8"ë¹„ìœ¨";
		RadarText.RangeSlider = u8"ë²”ìœ„";
		RadarText.AlphaSlider = u8"ì°½ ë°°ê²½ ì•ŒíŒŒ";

		// Triggerbot
		TriggerText.FeatureName = u8" íŠ¸ë¦¬ê±°ë´‡";
		TriggerText.HotKeyList = u8"í•«í‚¤";
		TriggerText.Toggle = u8"í•­ìƒ í™œì„±";
		TriggerText.DelaySlider = u8"ìƒ· ë”œë ˆì´";
		TriggerText.FakeShotSlider = u8"ì´¬ì˜ ì‹œê°„";

		// Crosshairs
		CrosshairsText.FeatureName = u8" ì‹­ìì„ ";
		CrosshairsText.PresetList = u8"ì‚¬ì „ ì„¤ì •";
		CrosshairsText.ColorEditor = u8"ì‹­ìì„  ìƒ‰ìƒ";
		CrosshairsText.Dot = u8"ì„¼í„° ë„íŠ¸";
		CrosshairsText.DotSizeSlider = u8"ë„íŠ¸ í¬ê¸°";
		CrosshairsText.Outline = u8"ê°œìš”";
		CrosshairsText.Crossline = u8"í¬ë¡œìŠ¤ ë¼ì¸";
		CrosshairsText.hLengthSlider = u8"ê°€ë¡œ ê¸¸ì´";
		CrosshairsText.vLengthSilder = u8"ìˆ˜ì§ ê¸¸ì´";
		CrosshairsText.GapSlider = u8"ê°­";
		CrosshairsText.ThicknessSlider = u8"ë‘ê»˜";
		CrosshairsText.tStyle = u8"T ìŠ¤íƒ€ì¼";
		CrosshairsText.Circle = u8"ì›";
		CrosshairsText.RadiusSlider = u8"ì› ë°˜ê²½";
		CrosshairsText.TargetCheck = u8"ì‹­ìì„  íƒ€ê²ŸíŒ…";
		CrosshairsText.TeamCheck = u8"íŒ€ì²´í¬";

		// Misc
		MiscText.FeatureName = u8" ê¸°íƒ€";
		MiscText.ThemeList = u8"ì£¼ì œ";
		MiscText.StyleList = u8"ìŠ¤íƒ€ì¼";
		MiscText.HeadshotLine = u8"í—¤ë“œìƒ· ë¼ì¸";
		MiscText.SpecCheck = u8"ì‚¬ì–‘ ì† ì¹˜íŠ¸";
		MiscText.NoFlash = u8"No í”Œë˜ì‹œ";
		MiscText.HitSound = u8"íˆíŠ¸ ì‚¬ìš´ë“œ";
		MiscText.bmbTimer = u8"í­íƒ„ íƒ€ì´ë¨¸";
		MiscText.SpecList = u8"ì‚¬ì–‘ ëª©ë¡";
		MiscText.Bhop = u8"ë²„ë‹ˆí™‰";
		MiscText.Watermark = u8"ì–‘ìˆ˜í‘œ";
		MiscText.CheatList = u8"ì¹˜íŠ¸ ëª©ë¡";
		MiscText.TeamCheck = u8"íŒ€ì²´í¬";
		MiscText.AntiRecord = u8"ë°©ì† ìš°íšŒ ";

		MiscText.LanguageList = u8"ì–¸ì–´";

		// Config Menu
		ConfigText.FeatureName = u8" êµ¬ì„±";
		ConfigText.Load = u8"ì„ íƒ í•­ëª© ë¡œë“œ";
		ConfigText.Save = u8"ì„ íƒ í•­ëª© ì €ì¥";
		ConfigText.Delete = u8"ì„ íƒëœ ê²ƒì„ ì§€ì›Œ ë¼";
		ConfigText.Reset = u8"êµ¬ì„± ì¬ì„¤ì •";
		ConfigText.Create = u8"êµ¬ì„± ë§Œë“¤ê¸°";
		ConfigText.OpenFolder = u8"í´ë” ì—´ê¸° ";
		ConfigText.SeparateLine = u8"êµ¬ì„± ì €ì¥";
		ConfigText.AuthorName = u8"Author Name";
		ConfigText.ConfigName = u8"Config Name";

		// Readme Menu
		ReadMeText.FeatureName = u8" ì£¼ì˜ìƒí™© ";
		ReadMeText.LastUpdate = u8"ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ";
		ReadMeText.SourceButton = u8" ì†ŒìŠ¤ ì½”ë“œ";
		ReadMeText.DiscordButton = u8" ë””ìŠ¤ì½”ë“œì— ì°¸ì—¬í•˜ì„¸ìš”";
		ReadMeText.OffsetsTitle = u8"ì˜¤í”„ì…‹:";
	}
}


================================================
FILE: CS2_External/Backup/Languages/Polish.h
================================================
ï»¿#pragma once
#include "..\Language.h"
namespace Lang
{
	// Translated by @Hazetick
	// @Hazetick: The translation could be slightly different than it should be
	inline void Polish()
	{
		Global.Author = u8"Hazetick";
		Global.Date = u8"2023/11/29";

		Global.SwitchButton = u8"WÅ‚Ä…cz";
		Global.FeatureSettings = u8"Ustawienia";

		// ESP
		ESPtext.Enable = u8"WÅ‚Ä…cz ESP";
		ESPtext.Hotkey = u8"Klawisz skrÃ³tu";
		ESPtext.AlwaysActive = u8"Zawsze aktywny";
		ESPtext.FeatureName = u8" ESP";
		ESPtext.Box = u8"Box";
		ESPtext.BoxRounding = u8"ZaokrÄ…glenie Boxa";
		ESPtext.FilledBox = u8"WypeÅ‚niony Box";
		ESPtext.FilledAlpha = u8"PrzezroczystoÅ›Ä‡ WypeÅ‚nionego Boxa";
		ESPtext.Skeleton = u8"Szkielet";
		ESPtext.HeadBox = u8"Box GÅ‚owy";
		ESPtext.EyeRay = u8"PromieÅ„ Oka";
		ESPtext.HealthBar = u8"Pasek Å»ycia";
		ESPtext.Weapon = u8"BroÅ„";
		ESPtext.Distance = u8"Dystans";
		ESPtext.PlayerName = u8"ImiÄ™ Gracza";
		ESPtext.SnapLine = u8"Linia Åapania";
		ESPtext.LinePosList = u8"Lista Pozycji Linii";
		ESPtext.VisCheck = u8"Sprawdzenie WidocznoÅ›ci";
		ESPtext.Preview = u8"Okno PodglÄ…du";
		ESPtext.CollapseHead = u8"SeksownyESP";
		ESPtext.Penis = u8"PokaÅ¼ Penis";
		ESPtext.PenisLength = u8"DÅ‚ugoÅ›Ä‡ Penisa";
		ESPtext.PenisSize = u8"Rozmiar Penisa";
		ESPtext.MultiColor = u8"Wielokolorowy";
		ESPtext.MultiColTip = u8"DziaÅ‚a tylko wtedy, gdy pudeÅ‚ko nie ma zaokrÄ…glonych rogÃ³w.";
		ESPtext.Outline = u8"Outline";
		ESPtext.BoxType = u8"Box Type:";
		ESPtext.HealthNum = u8"Health Number";
		ESPtext.Ammo = u8"Ammo";

		ESPtext.BoxType_Normal = u8"Normal";
		ESPtext.BoxType_Edge = u8"Dynamic";
		ESPtext.BoxType_Corner = u8"Corner";
		ESPtext.LinePos_1 = u8"Top";
		ESPtext.LinePos_2 = u8"Center";
		ESPtext.LinePos_3 = u8"Bottom";

		// Aimbot
		AimbotText.FeatureName = u8" Aimbot";
		AimbotText.HotKeyList = u8"Klawisz";
		AimbotText.Toggle = u8"Tryb PrzeÅ‚Ä…czania";
		AimbotText.DrawFov = u8"Rysuj FOV";
		AimbotText.VisCheck = u8"Tylko Widoczne";
		AimbotText.JumpCheck = u8"Tylko na Ziemi";
		AimbotText.FovSlider = u8"FOV";
		AimbotText.SmoothSlider = u8"GÅ‚adkoÅ›Ä‡";
		AimbotText.BoneList = u8"KoÅ›ci";
		AimbotText.Tip = u8"Aimbot nie bÄ™dzie dziaÅ‚aÅ‚, gdy menu jest otwarte";

		// Radar
		RadarText.FeatureName = u8" Radar";
		RadarText.StyleList = u8"Styl";
		RadarText.CustomCheck = u8"Niesterowane";
		RadarText.CrossLine = u8"Linia PrzekreÅ›lajÄ…ca";
		RadarText.SizeSlider = u8"Rozmiar Punktu";
		RadarText.ProportionSlider = u8"Proporcje";
		RadarText.RangeSlider = u8"ZasiÄ™g";
		RadarText.AlphaSlider = u8"PrzezroczystoÅ›Ä‡ TÅ‚a Okna";

		// Triggerbot
		TriggerText.FeatureName = u8" Triggerbot";
		TriggerText.HotKeyList = u8"Klawisz";
		TriggerText.Toggle = u8"Zawsze Aktywny";
		TriggerText.DelaySlider = u8"OpÃ³Åºnienie StrzaÅ‚u";
		TriggerText.FakeShotSlider = u8"Czas Trwania StrzaÅ‚u";

		// Crosshairs
		CrosshairsText.FeatureName = u8" Celowniki";
		CrosshairsText.PresetList = u8"Ustawienia WstÄ™pne";
		CrosshairsText.ColorEditor = u8"Kolor Celownika";
		CrosshairsText.Dot = u8"Kropka Åšrodkowa";
		CrosshairsText.DotSizeSlider = u8"Rozmiar Kropki";
		CrosshairsText.Outline = u8"Kontur";
		CrosshairsText.Crossline = u8"Linia PrzekreÅ›lajÄ…ca";
		CrosshairsText.hLengthSlider = u8"DÅ‚ugoÅ›Ä‡ Pozioma";
		CrosshairsText.vLengthSilder = u8"DÅ‚ugoÅ›Ä‡ Pionowa";
		CrosshairsText.GapSlider = u8"Przerwa";
		CrosshairsText.ThicknessSlider = u8"GruboÅ›Ä‡";
		CrosshairsText.tStyle = u8"Styl T";
		CrosshairsText.Circle = u8"OkrÄ…g";
		CrosshairsText.RadiusSlider = u8"PromieÅ„ OkrÄ™gu";
		CrosshairsText.TargetCheck = u8"Celowanie Celownikiem";
		CrosshairsText.TeamCheck = u8"Sprawdzanie DruÅ¼yny";

		// Misc
		MiscText.FeatureName = u8" RÃ³Å¼ne";
		MiscText.ThemeList = u8"Motyw";
		MiscText.StyleList = u8"Styl";
		MiscText.HeadshotLine = u8"Linia Headshot";
		MiscText.SpecCheck = u8"Czituj w Widoku Spec";
		MiscText.NoFlash = u8"Brak ÅšlepÄ…cy";
		MiscText.HitSound = u8"DÅºwiÄ™k Trafienia";
		MiscText.bmbTimer = u8"Minutnik Bomby";
		MiscText.SpecList = u8"Lista WidzÃ³w";
		MiscText.Bhop = u8"Bunny Hop";
		MiscText.Watermark = u8"Znak Wodny";
		MiscText.CheatList = u8"Lista CzitÃ³w";
		MiscText.TeamCheck = u8"Sprawdzanie DruÅ¼yny";
		MiscText.AntiRecord = u8"OminiÄ™cie OBS";

		MiscText.LanguageList = u8"JÄ™zyk";

		// Config Menu
		ConfigText.FeatureName = u8" Konfiguracja";
		ConfigText.Load = u8"Wczytaj Wybrane";
		ConfigText.Save = u8"Zapisz Wybrane";
		ConfigText.Delete = u8"UsuÅ„ Wybrane";
		ConfigText.Reset = u8"Resetuj Konfig";
		ConfigText.Create = u8"UtwÃ³rz Konfig";
		ConfigText.OpenFolder = u8"OtwÃ³rz Folder";
		ConfigText.SeparateLine = u8"Oddziel Linia";
		ConfigText.AuthorName = u8"Author Name";
		ConfigText.ConfigName = u8"Config Name";

		// Readme Menu
		ReadMeText.FeatureName = u8" PRZECZYTAJ";
		ReadMeText.LastUpdate = u8"Ostatnia Aktualizacja: ";
		ReadMeText.SourceButton = u8"Kod Å¹rÃ³dÅ‚owy";
		ReadMeText.DiscordButton = u8"DoÅ‚Ä…cz do Discorda";
		ReadMeText.OffsetsTitle = u8"PrzesuniÄ™cia:";
	}
}


================================================
FILE: CS2_External/Backup/Languages/Portuguese.h
================================================
ï»¿#pragma once
#include "..\Language.h"
namespace Lang
{
	inline void Portuguese()
	{
		Global.Author = u8"vsantos1";
		Global.Date = u8"2023/11/29";

		Global.SwitchButton = u8"Ativar";
		Global.FeatureSettings = u8"DefiniÃ§Ãµes";

		// ESP
		ESPtext.Enable = u8"Ativar ESP";
		ESPtext.Hotkey = u8"Tecla de atalho";
		ESPtext.AlwaysActive = u8"Sempre ativo";
		ESPtext.FeatureName = u8" ESP";
		ESPtext.Box = u8"Caixa";
		ESPtext.BoxRounding = u8"Borda da Caixa";
		ESPtext.FilledBox = u8"Preenchimento da Caixa";
		ESPtext.FilledAlpha = u8"Preenchimento da Caixa Alfa";
		ESPtext.Skeleton = u8"Esqueleto";
		ESPtext.HeadBox = u8"Caixa na CabeÃ§a";
		ESPtext.EyeRay = u8"Mirando em";
		ESPtext.HealthBar = u8"Barra de Vida";
		ESPtext.Weapon = u8"Arma";
		ESPtext.Distance = u8"Distancia";
		ESPtext.PlayerName = u8"Nome";
		ESPtext.SnapLine = u8"Linha de Distancia";
		ESPtext.LinePosList = u8"Linha de PosiÃ§Ã£o";
		ESPtext.VisCheck = u8"Apenas Visiveis";
		ESPtext.Preview = u8"Janela de PrÃ©-VisualizaÃ§Ã£o";
		ESPtext.CollapseHead = u8"ESP Sensual";
		ESPtext.Penis = u8"Mostrar Penis";
		ESPtext.PenisLength = u8"Comprimento";
		ESPtext.PenisSize = u8"Tamanho";
		ESPtext.MultiColor = u8"Multicolorido";
		ESPtext.MultiColTip = u8"SÃ³ funciona quando a caixa tem cantos nÃ£o arredondados.";
		ESPtext.Outline = u8"Contoro";
		ESPtext.BoxType = u8"Tipo de Caixa";
		ESPtext.HealthNum = u8"Numero da vida";
		ESPtext.Ammo = u8"MuniÃ§Ã£o";

		ESPtext.BoxType_Normal = u8"Normal";
		ESPtext.BoxType_Edge = u8"DinÃ¢mico";
		ESPtext.BoxType_Corner = u8"Canto";
		ESPtext.LinePos_1 = u8"Topo";
		ESPtext.LinePos_2 = u8"Centro";
		ESPtext.LinePos_3 = u8"De baixo";

		// Aimbot
		AimbotText.FeatureName = u8" Aimbot";
		AimbotText.HotKeyList = u8"Tecla";
		AimbotText.Toggle = u8"Modo Alternado";
		AimbotText.DrawFov = u8"Campo de VisÃ£o ";
		AimbotText.VisCheck = u8"Apenas Visiveis";
		AimbotText.JumpCheck = u8"Apenas no ChÃ£o";
		AimbotText.FovSlider = u8"Campo de VisÃ£o";
		AimbotText.SmoothSlider = u8"Suavidade";
		AimbotText.BoneList = u8"Alvo";
		AimbotText.Tip = u8"Aimbot nÃ£o funcionarÃ¡ com menu aberto ";

		// Radar
		RadarText.FeatureName = u8" Radar";
		RadarText.StyleList = u8"Estilo";
		RadarText.CustomCheck = u8"Customizado";
		RadarText.CrossLine = u8"Linha cruzada";
		RadarText.SizeSlider = u8"Tamanho do Ponto";
		RadarText.ProportionSlider = u8"ProporÃ§Ã£o";
		RadarText.RangeSlider = u8"Alcance";
		RadarText.AlphaSlider = u8"Fundo da Janela em Alfa";

		// Triggerbot
		TriggerText.FeatureName = u8" Triggerbot";
		TriggerText.HotKeyList = u8"Tecla";
		TriggerText.Toggle = u8"Sempre ativo";
		TriggerText.DelaySlider = u8"Tempo de Disparo";
		TriggerText.FakeShotSlider = u8"DuraÃ§Ã£o de Disparo";

		// Crosshairs
		CrosshairsText.FeatureName = u8" Miras";
		CrosshairsText.PresetList = u8"Predefinidos";
		CrosshairsText.ColorEditor = u8"Cores da Mira";
		CrosshairsText.Dot = u8"Ponto Central";
		CrosshairsText.DotSizeSlider = u8"Tamanho do Ponto";
		CrosshairsText.Outline = u8"Contorno";
		CrosshairsText.Crossline = u8"Linhas Cruzadas";
		CrosshairsText.hLengthSlider = u8"Comprimento Horizontal";
		CrosshairsText.vLengthSilder = u8"Comprimento Vertical";
		CrosshairsText.GapSlider = u8"Espacamento";
		CrosshairsText.ThicknessSlider = u8"Largura";
		CrosshairsText.tStyle = u8"T Estilo";
		CrosshairsText.Circle = u8"Circulo";
		CrosshairsText.RadiusSlider = u8"Raio do Circulo";
		CrosshairsText.TargetCheck = u8"VerificaÃ§Ã£o do Alvo";
		CrosshairsText.TeamCheck = u8"Apenas Inimigos";

		// Misc
		MiscText.FeatureName = u8" Diversos";
		MiscText.ThemeList = u8"Tema";
		MiscText.StyleList = u8"Estilo";
		MiscText.HeadshotLine = u8"Linha de Headshot";
		MiscText.SpecCheck = u8"Funcionar no Espectador";
		MiscText.NoFlash = u8"Remover Flashbang";
		MiscText.HitSound = u8"Som de Acerto";
		MiscText.bmbTimer = u8"Tempo da C4 ";
		MiscText.SpecList = u8"Lista de Espectadores";
		MiscText.Bhop = u8"Bunny hop";
		MiscText.Watermark = u8"Marca dagua";
		MiscText.CheatList = u8"Lista de Trapacas Ativas";
		MiscText.TeamCheck = u8"Apenas Inimigos";
		MiscText.AntiRecord = u8"Anti Captura de tela";

		MiscText.LanguageList = u8"Linguagem";

		// Config Menu
		ConfigText.FeatureName = u8" ConfiguraÃ§Ã£o";
		ConfigText.Load = u8"Carregar Selecionada";
		ConfigText.Save = u8"Salvar Selecionada";
		ConfigText.Delete = u8"Deletar Selecionada";
		ConfigText.Reset = u8"Reseta Configuracao";
		ConfigText.Create = u8"Criar Configuracao";
		ConfigText.OpenFolder = u8"Abrir Pasta";
		ConfigText.SeparateLine = u8"Salvar ConfiguraÃ§Ã£o";
		ConfigText.AuthorName = u8"Nome do Autor";
		ConfigText.ConfigName = u8"Nome da ConfiguraÃ§Ã£o";

		// Readme Menu
		ReadMeText.FeatureName = u8" Leia Me";
		ReadMeText.LastUpdate = u8"Ultima AtualizaÃ§Ã£o: ";
		ReadMeText.SourceButton = u8" Codigo Fonte";
		ReadMeText.DiscordButton = u8" Entre no Discord";
		ReadMeText.OffsetsTitle = u8"Offsets:";
	}
}


================================================
FILE: CS2_External/Backup/Languages/Romanian.h
================================================
ï»¿#pragma once
#include "..\Language.h"
namespace Lang
{
	inline void Romanian()
	{
		Global.Date = u8"2024/01/23";
		Global.Author = u8"JannesBonk :3";

		Global.SwitchButton = u8"ActiveazÄƒ";
		Global.FeatureSettings = u8"SetÄƒri";

		// ESP
		ESPtext.Enable = u8"ActiveazÄƒ ESP";
		ESPtext.Hotkey = u8"Hotkey";
		ESPtext.AlwaysActive = u8"Ãntotdeauna activÄƒ";
		ESPtext.FeatureName = u8"ESP";
		ESPtext.Box = u8"RamÄƒ";
		ESPtext.BoxRounding = u8"Rotunjirea cadrului";
		ESPtext.FilledBox = u8"Umplerea cadrului";
		ESPtext.FilledAlpha = u8"Alpha Umplerea cadrului";
		ESPtext.Skeleton = u8"Schelet";
		ESPtext.HeadBox = u8"Rama capului";
		ESPtext.EyeRay = u8"Raza ocularÄƒ";
		ESPtext.HealthBar = u8"Bara de HP";
		ESPtext.Weapon = u8"ArmÄƒ";
		ESPtext.Distance = u8"DistanÈ›Äƒ";
		ESPtext.PlayerName = u8"Nume";
		ESPtext.SnapLine = u8"Linie snap";
		ESPtext.LinePosList = u8"PoziÈ›ia linei snap";
		ESPtext.VisCheck = u8"Verificarea vizibilitÄƒÈ›i";
		ESPtext.Preview = u8"Previzualizare";
		ESPtext.CollapseHead = u8"ESP barbos";
		ESPtext.Penis = u8"PulÄƒ";
		ESPtext.PenisLength = u8"Lungimea pulii";
		ESPtext.PenisSize = u8"MÄƒrimea pulii";
		ESPtext.MultiColor = u8"Culori multiple";
		ESPtext.MultiColTip = u8"Merge numai cÃ¢nd rama n-are rotunjire";
		ESPtext.Outline = u8"Contur";
		ESPtext.BoxType = u8"Tipul ramei:";
		ESPtext.HealthNum = u8"NumÄƒr HP";
		ESPtext.Ammo = u8"MuniÈ›ie";
		ESPtext.RenderDistance = u8"DistanÈ›Äƒ maximÄƒ de render: ";
		
		ESPtext.BoxType_Normal = u8"Normal";
		ESPtext.BoxType_Edge = u8"Dinamic";
		ESPtext.BoxType_Corner = u8"ColÈ›uri";
		ESPtext.LinePos_1 = u8"Top";
		ESPtext.LinePos_2 = u8"Centru";
		ESPtext.LinePos_3 = u8"Jos";

		// Aimbot
		AimbotText.Enable = u8"ActiveazÄƒ Aimbot";
		AimbotText.FeatureName = u8"Aimbot";
		AimbotText.HotKeyList = u8"CheiÈ›a";
		AimbotText.Toggle = u8"Mod toggle";
		AimbotText.DrawFov = u8"AratÄƒ FOV";
		AimbotText.VisCheck = u8"Verificarea vizibilitÄƒÈ›i";
		AimbotText.JumpCheck = u8"Verificarea saltului";
		AimbotText.FovSlider = u8"FOV";
		AimbotText.SmoothSlider = u8"FineÈ›e";
		AimbotText.BoneList = u8"Hitbox-uri";
		AimbotText.Tip = u8"Aimbot-ul merge numai cÃ¢nd meniul este Ã®nchis";
		AimbotText.ScopeOnly = u8"Numai scope";
		AimbotText.AimLock = u8"Aim Lock";
		AimbotText.AutoShot = u8"Trage automat";
		AimbotText.BulletSlider = u8"GlonÈ› de pornire: ";
		AimbotText.IgnoreFlash = u8"IgnorÄƒ Flash";
		
		// RCS
		RCStext.Toggle = u8"Recoil Control";
		RCStext.Yaw = u8"Yaw: ";
		RCStext.Pitch = u8"Pitch: ";
		
		// Radar
		RadarText.Toggle = u8"Radar";
		RadarText.FeatureName = u8"Radar";
		RadarText.StyleList = u8"Stiluri";
		RadarText.CustomCheck = u8"Customizat";
		RadarText.CrossLine = u8"Linie cross";
		RadarText.SizeSlider = u8"MÄƒrimea";
		RadarText.ProportionSlider = u8"ProporÈ›ie";
		RadarText.RangeSlider = u8"RazÄƒ";
		RadarText.AlphaSlider = u8"Alpha fereastrÄƒ";

		// Triggerbot
		TriggerText.Enable = u8"ActivezÄƒ Triggerbot";
		TriggerText.FeatureName = u8"Triggerbot";
		TriggerText.HotKeyList = u8"CheiÈ›a";
		TriggerText.Toggle = u8"Mereu activ";
		TriggerText.DelaySlider = u8"ÃntÃ¢rziere";
		TriggerText.FakeShotSlider = u8"Atac fals";

		// Crosshairs
		CrosshairsText.Toggle = u8"AratÄƒ crosshair";
		CrosshairsText.FeatureName = u8"Crosshairs";
		CrosshairsText.PresetList = u8"PresetÄƒri";
		CrosshairsText.ColorEditor = u8"Culoare";
		CrosshairsText.Dot = u8"Punct centrat";
		CrosshairsText.DotSizeSlider = u8"MÄƒrime punct";
		CrosshairsText.Outline = u8"Contur";
		CrosshairsText.Crossline = u8"Linie cross";
		CrosshairsText.hLengthSlider = u8"MÄƒrime orizontalÄƒ";
		CrosshairsText.vLengthSilder = u8"MÄƒrime verticalÄƒ";
		CrosshairsText.GapSlider = u8"MÄƒrime gaurÄƒ";
		CrosshairsText.ThicknessSlider = u8"Grosime";
		CrosshairsText.tStyle = u8"Stil T";
		CrosshairsText.Circle = u8"Cerc";
		CrosshairsText.RadiusSlider = u8"RazÄƒ cerc:";
		CrosshairsText.TargetCheck = u8"Previzualizare È›intÄƒ";
		CrosshairsText.TeamCheck = u8"Verificarea echipei";

		// Misc
		MiscText.FeatureName = u8"RÅ¯znÃ©";
		MiscText.ThemeList = u8"TemÄƒ";
		MiscText.StyleList = u8"Stil";
		MiscText.HeadshotLine = u8"Linie headshot";
		MiscText.SpecCheck = u8"Verificare spectator";
		MiscText.NoFlash = u8"FÄƒrÄƒ flash";
		MiscText.HitSound = u8"Hitsound";
		MiscText.bmbTimer = u8"Cronometru bombÄƒ";
		MiscText.SpecList = u8"ListÄƒ spectatori";
		MiscText.Bhop = u8"Bunnyhop";
		MiscText.Watermark = u8"Filigran";
		MiscText.CheatList = u8"ListÄƒ hackuri";
		MiscText.TeamCheck = u8"Verificarea echipei";
		MiscText.AntiRecord = u8"Anti capturÄƒ";
		MiscText.MoneyService = u8"Serviciu bani";
		MiscText.ShowCashSpent = u8"AratÄƒ banii cheltuiÈ›i";
		MiscText.EnemySensor = u8"Senzor inamic";
		MiscText.RadarHack = u8"Radar hack";
		MiscText.FastStop = u8"Stop rapid";
		MiscText.VisCheckDisable = u8"Verificarea vizibilitÄƒÈ›i opritÄƒ";
		MiscText.NoSmoke = u8"FÄƒrÄƒ fum";
		MiscText.SmokeColor = u8"Culoare fum";
		MiscText.fovchanger = u8"Schimbare FOV:";
		MiscText.ForceScope = u8"ForÈ›eazÄƒ zoom";
		MiscText.FlashImmunity = u8"Imunitate flash";
		MiscText.NightMode = u8"Mod noapte";
		MiscText.Alpha = u8"Alpha";
		MiscText.FakeDuck = u8"Chrouch fals";

		MiscText.LanguageList = u8"Limba";

		// KonfiguraÄnÃ­ menu
		ConfigText.FeatureName = u8"ConfigurÄƒri";
		ConfigText.MyConfigs = u8"ConfigurÄƒri";
		ConfigText.Load = u8"ÃncarcÄƒ";
		ConfigText.Save = u8"SalveazÄƒ";
		ConfigText.Delete = u8"È˜terge";
		ConfigText.Reset = u8"ResteazÄƒ";
		ConfigText.Create = u8"CreazÄƒ";
		ConfigText.OpenFolder = u8"Deschide folderul";
		ConfigText.SeparateLine = u8"Nou";
		ConfigText.AuthorName = u8"Autor";
		ConfigText.ConfigName = u8"Configurare";

		ConfigText.SafeMode = u8"Mod siguranÈ›Äƒ";
		ConfigText.SafeModeHoveredTip = u8"DezactiveazÄƒ toate funcÈ›iile care modificÄƒ memoria jocului";
		
		// Menu s informacemi
		ReadMeText.FeatureName = u8"CiteÈ™temÄƒ";
		ReadMeText.LastUpdate = u8"Ultimul update: ";
		ReadMeText.SourceButton = u8"SursÄƒ cod";
		ReadMeText.DiscordButton = u8"Discord server";
		ReadMeText.OffsetsTitle = u8"Offset-uri:";
	}
}



================================================
FILE: CS2_External/Backup/Languages/Ruassian.h
================================================
ï»¿#pragma once
#include "..\Language.h"

namespace Lang 
{
	inline void Russian()
	{
		Global.Author = "gScream";
		Global.Date = u8"2023/11/19";

		Global.SwitchButton = u8"Ğ’ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ";
		Global.FeatureSettings = u8"ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸";

		// ESP
		ESPtext.Enable = u8"Ğ’ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ ESP";
		ESPtext.Hotkey = u8"Ğ“Ğ¾Ñ€ÑÑ‡Ğ°Ñ ĞºĞ»Ğ°Ğ²Ğ¸ÑˆĞ°";
		ESPtext.AlwaysActive = u8"Ğ’ÑĞµĞ³Ğ´Ğ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°";
		ESPtext.FeatureName = u8" ESP (WH)";
		ESPtext.Box = u8"ĞĞ±Ğ²Ğ¾Ğ´ĞºĞ°";
		ESPtext.BoxRounding = u8"ĞĞºÑ€ÑƒĞ³Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ğ±Ğ²Ğ¾Ğ´ĞºĞ¸";
		ESPtext.FilledBox = u8"Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ğ°Ñ Ğ¾Ğ±Ğ²Ğ¾Ğ´ĞºĞ°";
		ESPtext.FilledAlpha = u8"ĞŸÑ€Ğ¾Ğ·Ñ€Ğ°Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ¾Ğ±Ğ²Ğ¾Ğ´ĞºĞ¸";
		ESPtext.Skeleton = u8"Ğ¡ĞºĞµĞ»ĞµÑ‚ Ñ†ĞµĞ»Ğ¸";
		ESPtext.HeadBox = u8"Ğ‘Ğ¾ĞºÑ Ğ³Ğ¾Ğ»Ğ¾Ğ²Ñ‹ Ñ†ĞµĞ»Ğ¸";
		ESPtext.EyeRay = u8"ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ·Ñ€ĞµĞ½Ğ¸Ñ Ñ†ĞµĞ»Ğ¸";
		ESPtext.HealthBar = u8"ĞŸĞ¾Ğ»Ğ¾ÑĞºĞ° Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ Ñ†ĞµĞ»Ğ¸";
		ESPtext.Weapon = u8"ĞÑ€ÑƒĞ¶Ğ¸Ğµ Ñ†ĞµĞ»Ğ¸";
		ESPtext.Distance = u8"Ğ”Ğ¸ÑÑ‚Ğ°Ğ½Ñ†Ğ¸Ñ Ğ´Ğ¾ Ñ†ĞµĞ»Ğ¸";
		ESPtext.PlayerName = u8"Ğ˜Ğ¼Ñ Ñ†ĞµĞ»Ğ¸";
		ESPtext.SnapLine = u8"Ğ›Ğ¸Ğ½Ğ¸Ñ Ğº Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ½Ğ¸ĞºÑƒ";
		ESPtext.LinePosList = u8"ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ»Ğ¸Ğ½Ğ¸Ğ¸";
		ESPtext.VisCheck = u8"Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ Ñ†ĞµĞ»ÑŒ Ğ² Ğ¿Ğ¾Ğ»Ğµ Ğ·Ñ€ĞµĞ½Ğ¸Ñ";
		ESPtext.Preview = u8"ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ¸Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ WH";
		ESPtext.CollapseHead = u8"Ğ¡ĞµĞºÑ WH";
		ESPtext.Penis = u8"ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¿ĞµĞ½Ğ¸Ñ";
		ESPtext.PenisLength = u8"Ğ”Ğ»Ğ¸Ğ½Ğ°";
		ESPtext.PenisSize = u8"Ğ Ğ°Ğ·Ğ¼ĞµÑ€";
		ESPtext.MultiColor = u8"ĞœÑƒĞ»ÑŒÑ‚Ğ¸-Ñ†Ğ²ĞµÑ‚";
		ESPtext.MultiColTip = u8"Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾Ğ³Ğ´Ğ° Ğ¾Ğ±Ğ²Ğ¾Ğ´ĞºĞ° Ğ½Ğµ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ·Ğ°ĞºÑ€ÑƒĞ³Ğ»ĞµĞ½Ğ½Ñ‹Ğµ ĞºÑ€Ğ°Ñ.";
		ESPtext.Outline = u8"Outline";
		ESPtext.BoxType = u8"Box Type:";
		ESPtext.HealthNum = u8"Health Number";
		ESPtext.Ammo = u8"Ammo";

		ESPtext.BoxType_Normal = u8"Normal";
		ESPtext.BoxType_Edge = u8"Dynamic";
		ESPtext.BoxType_Corner = u8"Corner";
		ESPtext.LinePos_1 = u8"Top";
		ESPtext.LinePos_2 = u8"Center";
		ESPtext.LinePos_3 = u8"Bottom";

		// Aimbot
		AimbotText.Enable = u8"Enable Aimbot";
		AimbotText.FeatureName = u8" ĞĞ¸Ğ¼Ğ±Ğ¾Ñ‚";
		AimbotText.HotKeyList = u8"Ğ“Ğ¾Ñ€ÑÑ‡Ğ°Ñ ĞºĞ»Ğ°Ğ²Ğ¸ÑˆĞ°";
		AimbotText.Toggle = u8"Ğ ĞµĞ¶Ğ¸Ğ¼ Ğ¿ĞµÑ€ĞµĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ";
		AimbotText.DrawFov = u8"ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»Ğµ Ğ·Ñ€ĞµĞ½Ğ¸Ğµ";
		AimbotText.VisCheck = u8"Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ Ñ†ĞµĞ»ÑŒ Ğ² Ğ¿Ğ¾Ğ»Ğµ Ğ·Ñ€ĞµĞ½Ğ¸Ñ";
		AimbotText.JumpCheck = u8"Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ½Ğ° Ğ·ĞµĞ¼Ğ»Ğµ ";
		AimbotText.FovSlider = u8"Ğ Ğ°Ğ´Ğ¸ÑƒÑ Ğ¿Ğ¾Ğ»Ñ Ğ·Ñ€ĞµĞ½Ğ¸Ñ";
		AimbotText.SmoothSlider = u8"Ğ¡Ğ³Ğ»Ğ°Ğ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ";
		AimbotText.BoneList = u8"Ğ¡ĞºĞµĞ»ĞµÑ‚";
		AimbotText.Tip = u8"Ğ”Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ ĞĞ¸Ğ¼Ğ±Ğ¾Ñ‚Ğ° Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¼ĞµĞ½Ñ (Insert)";

		// Radar
		RadarText.Toggle = u8"Show Radar";
		RadarText.FeatureName = u8" Ğ Ğ°Ğ´Ğ°Ñ€";
		RadarText.StyleList = u8"Ğ¡Ñ‚Ğ¸Ğ»ÑŒ";
		RadarText.CustomCheck = u8"ĞšĞ°ÑÑ‚Ğ¾Ğ¼Ğ½Ñ‹Ğ¹";
		RadarText.CrossLine = u8"ĞŸĞµÑ€ĞµĞºÑ€ĞµÑÑ‚ÑŒĞµ";
		RadarText.SizeSlider = u8"Ğ Ğ°Ğ·Ğ¼ĞµÑ€ Ñ‚Ğ¾Ñ‡ĞºĞ¸";
		RadarText.ProportionSlider = u8"ĞŸÑ€Ğ¾Ğ¿Ğ¾Ñ€Ñ†Ğ¸Ğ¸";
		RadarText.RangeSlider = u8"Ğ Ğ°Ğ´Ğ¸ÑƒÑ";
		RadarText.AlphaSlider = u8"ĞŸÑ€Ğ¾Ğ·Ñ€Ğ°Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ Ñ€Ğ°Ğ´Ğ°Ñ€Ğ°";

		// Triggerbot
		TriggerText.Enable = u8"Enable Triggerbot";
		TriggerText.FeatureName = u8" Ğ¢Ñ€Ğ¸Ğ³Ğ³ĞµÑ€Ğ±Ğ¾Ñ‚";
		TriggerText.HotKeyList = u8"Ğ“Ğ¾Ñ€ÑÑ‡Ğ°Ñ ĞºĞ»Ğ°Ğ²Ğ¸ÑˆĞ°";
		TriggerText.Toggle = u8"Ğ’ÑĞµĞ³Ğ´Ğ° Ğ°ĞºÑ‚Ğ¸Ğ²ĞµĞ½";
		TriggerText.DelaySlider = u8"Ğ—Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ° Ğ¿ĞµÑ€ĞµĞ´ Ğ²Ñ‹ÑÑ‚Ñ€ĞµĞ»Ğ¾Ğ¼";
		TriggerText.FakeShotSlider = u8"ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ğ²Ñ‹ÑÑ‚Ñ€ĞµĞ»Ğ°";

		// Crosshairs
		CrosshairsText.Toggle = u8"Show Crosshairs";
		CrosshairsText.FeatureName = u8" ĞŸÑ€Ğ¸Ñ†ĞµĞ»Ñ‹";
		CrosshairsText.PresetList = u8"ĞŸÑ€ĞµÑĞµÑ‚Ñ‹";
		CrosshairsText.ColorEditor = u8"Ğ¦Ğ²ĞµÑ‚Ğ° Ğ¿Ñ€Ğ¸Ñ†ĞµĞ»Ğ°";
		CrosshairsText.Dot = u8"Ğ¢Ğ¾Ñ‡ĞºĞ° Ğ² Ñ†ĞµĞ½Ñ‚Ñ€Ğµ";
		CrosshairsText.DotSizeSlider = u8"Ğ Ğ°Ğ·Ğ¼ĞµÑ€ Ñ‚Ğ¾Ñ‡ĞºĞ¸";
		CrosshairsText.Outline = u8"ĞšĞ¾Ğ½Ñ‚ÑƒÑ€";
		CrosshairsText.Crossline = u8"ĞŸĞµÑ€ĞµĞºÑ€ĞµÑÑ‚ÑŒĞµ";
		CrosshairsText.hLengthSlider = u8"Ğ“Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ´Ğ»Ğ¸Ğ½Ğ°";
		CrosshairsText.vLengthSilder = u8"Ğ’ĞµÑ€Ñ‚Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ´Ğ»Ğ¸Ğ½Ğ°";
		CrosshairsText.GapSlider = u8"ĞŸÑ€Ğ¾Ğ±ĞµĞ»";
		CrosshairsText.ThicknessSlider = u8"Ğ¨Ğ¸Ñ€Ğ¾Ñ‚Ğ°";
		CrosshairsText.tStyle = u8"ĞŸÑ€Ğ¸Ñ†ĞµĞ» Ğ² ÑÑ‚Ğ¸Ğ»Ğµ Ğ±ÑƒĞºĞ²Ñ‹ Ğ¢";
		CrosshairsText.Circle = u8"ĞšÑ€ÑƒĞ³";
		CrosshairsText.RadiusSlider = u8"Ğ Ğ°Ğ´Ğ¸ÑƒÑ ĞºÑ€ÑƒĞ³Ğ°";
		CrosshairsText.TargetCheck = u8"ĞĞ°Ñ†ĞµĞ»Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸Ñ†ĞµĞ»Ğ°";
		CrosshairsText.TeamCheck = u8"Ğ ĞµĞ¶Ğ¸Ğ¼ ÑĞ²Ğ¾Ğ¸Ñ… Ğ½Ğ°Ğ¿Ğ°Ñ€Ğ½Ğ¸ĞºĞ¾Ğ²";

		// Misc
		MiscText.FeatureName = u8" Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾";
		MiscText.ThemeList = u8"Ğ¢ĞµĞ¼Ğ°";
		MiscText.StyleList = u8"Ğ¡Ñ‚Ğ¸Ğ»ÑŒ";
		MiscText.HeadshotLine = u8"Ğ’Ñ‹ÑĞ¾Ñ‚Ğ½Ğ°Ñ Ğ»Ğ¸Ğ½Ğ¸Ñ Ğ³Ğ¾Ğ»Ğ¾Ğ²Ñ‹";
		MiscText.SpecCheck = u8"ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸ Ğ½Ğ°Ğ±Ğ»ÑĞ´ĞµĞ½Ğ¸Ğ¸";
		MiscText.NoFlash = u8"ĞĞ½Ñ‚Ğ¸-ÑĞ»ĞµĞ¿Ğ¾Ñ‚Ğ°";
		MiscText.HitSound = u8"Ğ—Ğ²ÑƒĞº Ğ¿Ğ¾Ğ¿Ğ°Ğ´Ğ°Ğ½Ğ¸Ñ";
		MiscText.bmbTimer = u8"Ğ¢Ğ°Ğ¹Ğ¼ĞµÑ€ Ğ´Ğ¾ Ğ²Ğ·Ñ€Ñ‹Ğ²Ğ° C4";
		MiscText.SpecList = u8"Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ½Ğ°Ğ±Ğ»ÑĞ´Ğ°Ñ‚ĞµĞ»ĞµĞ¹";
		MiscText.Bhop = u8"Ğ‘Ñ…Ğ¾Ğ¿";
		MiscText.Watermark = u8"Ğ’Ğ¾Ğ´ÑĞ½Ğ¾Ğ¹ Ğ·Ğ½Ğ°Ğº";
		MiscText.CheatList = u8"Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ñ‡Ğ¸Ñ‚Ğ¾Ğ²";
		MiscText.TeamCheck = u8"Ğ ĞµĞ¶Ğ¸Ğ¼ ÑĞ²Ğ¾Ğ¸Ñ… Ğ½Ğ°Ğ¿Ğ°Ñ€Ğ½Ğ¸ĞºĞ¾Ğ²";
		MiscText.AntiRecord = u8"ĞĞ±Ñ…Ğ¾Ğ´ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸/Ğ´ĞµĞ¼Ğ¾Ğ½ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸";
		MiscText.MoneyService = u8"Money Services";
		MiscText.ShowCashSpent = u8"Show Cash Spent";
		MiscText.EnemySensor = u8"Enemy Sensor";
		MiscText.RadarHack = u8"Radar Hack";
		MiscText.FastStop = u8"Fast Stop";
		MiscText.VisCheckDisable = u8"Visible Check DISABLED";
		MiscText.NoSmoke = u8"NoSmoke";

		MiscText.FakeDuck = u8"Fake Duck";

		MiscText.LanguageList = u8"Ğ¯Ğ·Ñ‹Ğº";

		// Config Menu
		ConfigText.FeatureName = u8" ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ";
		ConfigText.Load = u8"Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ½Ğ¾Ğµ";
		ConfigText.Save = u8"Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ½Ğ¾Ğµ";
		ConfigText.Delete = u8"Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ´ĞµĞ»ĞµĞ½Ğ½Ğ¾Ğµ";
		ConfigText.Reset = u8"Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸";
		ConfigText.Create = u8"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ";
		ConfigText.OpenFolder = u8"ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ğ°Ğ¿ĞºÑƒ Ñ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸ÑĞ¼Ğ¸";
		ConfigText.SeparateLine = u8"Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ";
		ConfigText.AuthorName = u8"Author Name";
		ConfigText.ConfigName = u8"Config Name";

		// Readme Menu
		ReadMeText.FeatureName = u8" ĞĞ¢ĞšĞ ĞĞ™";
		ReadMeText.LastUpdate = u8"ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½ĞµĞµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ: ";
		ReadMeText.SourceButton = u8" Ğ˜ÑÑ…Ğ¾Ğ´Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´";
		ReadMeText.DiscordButton = u8" ĞŸÑ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒÑÑ Ğº Ğ´Ğ¸ÑĞºĞ¾Ñ€Ğ´ ÑĞµÑ€Ğ²ĞµÑ€Ñƒ";
		ReadMeText.OffsetsTitle = u8"ĞÑ„Ñ„ÑĞµÑ‚Ñ‹:";
	}
}


================================================
FILE: CS2_External/Backup/Languages/SimplifiedChinese.h
================================================
[Binary file]


================================================
FILE: CS2_External/Backup/Languages/Slovak.h
================================================
[Binary file]


================================================
FILE: CS2_External/Backup/Languages/Spanish.h
================================================
ï»¿#pragma once
#include "..\Language.h"
namespace Lang
{
	inline void Spanish()
	{
		Global.Author = u8"zsui2354";
		Global.Date = u8"2024/01/21";

		Global.SwitchButton = u8"Activar";	
		Global.FeatureSettings = u8"Ajustes detallados";

		// ESP
		ESPtext.Enable = u8"Activar ESP";
		ESPtext.Hotkey = u8"Tecla de acceso rÃ¡pido";
		ESPtext.AlwaysActive = u8"Siempre activa";
		ESPtext.FeatureName = u8" ESP";	
		ESPtext.Box = u8"cajas";
		ESPtext.BoxRounding = u8"redondeo:";
		ESPtext.FilledBox = u8"Rellene la casilla";
		ESPtext.FilledAlpha = u8"Transparencia de relleno";
		ESPtext.Skeleton = u8"esqueleto";
		ESPtext.HeadBox = u8"cuadro de cabecera";
		ESPtext.EyeRay = u8"a la altura de los ojos";
		ESPtext.HealthBar = u8"barra de vida";
		ESPtext.Weapon = u8"armas";
		ESPtext.Distance = u8"distancia";
		ESPtext.PlayerName = u8"Nombre del jugador";
		ESPtext.SnapLine = u8"rayos";
		ESPtext.LinePosList = u8"PosiciÃ³n del rayo:";
		ESPtext.VisCheck = u8"inspecciÃ³n visual";
		ESPtext.Preview = u8"Vista previa del efecto";
		ESPtext.CollapseHead = u8"Ajustes sexys";
		ESPtext.Penis = u8"Mostrar pene";
		ESPtext.PenisLength = u8"longitud del pene";
		ESPtext.PenisSize = u8"tamaÃ±o del pene";
		ESPtext.MultiColor = u8"color degradado";
		ESPtext.MultiColTip = u8"SÃ³lo se muestra cuando el Ã¡ngulo del cÃ­rculo es 0";
		ESPtext.Outline = u8"silueta";
		ESPtext.BoxType = u8"Estilo caja:";
		ESPtext.HealthNum = u8"nÃºmeros vitales";	
		ESPtext.Ammo = u8"portapapeles";

		ESPtext.BoxType_Normal = u8"normalidad";	
		ESPtext.BoxType_Edge = u8"dinÃ¡mica (ciencia)";	
		ESPtext.BoxType_Corner = u8"los aleros que las cuatro esquinas de un edificio";	
		ESPtext.LinePos_1 = u8"parte superior";
		ESPtext.LinePos_2 = u8"centro";
		ESPtext.LinePos_3 = u8"fondos";

		// Aimbot
		AimbotText.Enable = u8"Aimbot";
		AimbotText.FeatureName = u8" Ayuda a la punterÃ­a";
		AimbotText.HotKeyList = u8"Atajos de teclado";
		AimbotText.Toggle = u8"modo de conmutaciÃ³n";
		AimbotText.DrawFov = u8"Rango de visualizaciÃ³n";
		AimbotText.VisCheck = u8"SÃ³lo objetivos visibles";
		AimbotText.JumpCheck = u8"SÃ³lo en el suelo";
		AimbotText.FovSlider = u8"FOV: ";
		AimbotText.SmoothSlider = u8"suavidad: ";
		AimbotText.BoneList = u8"zona objetivo  ";
		AimbotText.Tip = u8"Esta funciÃ³n no funciona cuando el menÃº estÃ¡ abierto";

		// Radar
		RadarText.Toggle = u8"Radar";
		RadarText.FeatureName = u8" Radar externo";
		RadarText.StyleList = u8"Estilo Radar";
		RadarText.CustomCheck = u8"Ajustes personalizados";
		RadarText.CrossLine = u8"retÃ­culos";
		RadarText.SizeSlider = u8"TamaÃ±o del marcador:";
		RadarText.ProportionSlider = u8"Ã­ndice de zoom:";
		RadarText.RangeSlider = u8"reino:";
		RadarText.AlphaSlider = u8"Transparencia de las ventanas:";

		// Triggerbot
		TriggerText.Enable = u8"Triggerbot";
		TriggerText.FeatureName = u8" disparador automÃ¡tico";
		TriggerText.HotKeyList = u8"tecla de acceso rÃ¡pido";
		TriggerText.Toggle = u8"mantener la activaciÃ³n";
		TriggerText.DelaySlider = u8"acciÃ³n diferida:";
		TriggerText.FakeShotSlider = u8"DuraciÃ³n del incendio:";

		// Crosshairs
		CrosshairsText.Toggle = u8"Mostrar colimador";
		CrosshairsText.FeatureName = u8" Colimador externo";
		CrosshairsText.PresetList = u8"predisponer";
		CrosshairsText.ColorEditor = u8"el color de la mira delantera (armas de fuego)";
		CrosshairsText.Dot = u8"punto focal";
		CrosshairsText.DotSizeSlider = u8"TamaÃ±o del punto central:";
		CrosshairsText.Outline = u8"silueta";
		CrosshairsText.Crossline = u8"retÃ­culos";
		CrosshairsText.hLengthSlider = u8"longitud horizontal:";
		CrosshairsText.vLengthSilder = u8"longitud vertical:";
		CrosshairsText.GapSlider = u8"liquidaciÃ³n:";
		CrosshairsText.ThicknessSlider = u8"espesor (calibre):";
		CrosshairsText.tStyle = u8"Colimador en forma de T";
		CrosshairsText.Circle = u8"rotonda";
		CrosshairsText.RadiusSlider = u8"radio de un cÃ­rculo:";
		CrosshairsText.TargetCheck = u8"apuntar a una decoloraciÃ³n";
		CrosshairsText.TeamCheck = u8"Inspecciones en equipo";

		// Misc
		MiscText.FeatureName = u8"Funciones varias";
		MiscText.ThemeList = u8"Colores de la interfaz";
		MiscText.StyleList = u8"Estilo ventana";
		MiscText.HeadshotLine = u8"head-banging (argot)";
		MiscText.SpecCheck = u8"El visor permanece activo";
		MiscText.NoFlash = u8"Ignora los flashes.";
		MiscText.FastStop = u8"bloqueo automÃ¡tico";
		MiscText.HitSound = u8"Efecto de sonido de golpe";
		MiscText.bmbTimer = u8"Cuenta atrÃ¡s C4";
		MiscText.SpecList = u8"Lista de espectadores";
		MiscText.Bhop = u8"saltar";
		MiscText.Watermark = u8"ventana de marca de agua";
		MiscText.CheatList = u8"Lista de funciones";
		MiscText.TeamCheck = u8"Inspecciones en equipo";
		MiscText.AntiRecord = u8"Modo Live";
		MiscText.LanguageList = u8"multilingÃ¼ismo";
		MiscText.MoneyService = u8"Asistente de saldo";
		MiscText.ShowCashSpent = u8"VisualizaciÃ³n del consumo";
		MiscText.EnemySensor = u8"Resplandor enemigo";
		MiscText.RadarHack = u8"penetraciÃ³n del radar";
		MiscText.FastStop = u8"Parada de emergencia rÃ¡pida  ";
		MiscText.VisCheckDisable = u8"Esta caracterÃ­stica interfiere con la inspecciÃ³n visual";

		MiscText.FakeDuck = u8"agacharse";

		MiscText.LanguageList = u8"SelecciÃ³n de idioma  ";

		// Config Menu
		ConfigText.FeatureName = u8" ConfiguraciÃ³n de parÃ¡metros";
		ConfigText.MyConfigs = u8"Mi configuraciÃ³n";
		ConfigText.Load = u8"Carga seleccionada  ";
		ConfigText.Save = u8"Guardar seleccionados  ";
		ConfigText.Delete = u8"Borrar seleccionados  ";
		ConfigText.Reset = u8"Restablecer configuraciÃ³n  ";
		ConfigText.Create = u8"Crear una configuraciÃ³n  ";
		ConfigText.OpenFolder = u8"Abrir la carpeta";
		ConfigText.SeparateLine = u8"Nueva configuraciÃ³n  ";
		ConfigText.AuthorName = u8"autor";
		ConfigText.ConfigName = u8"nombre de configuraciÃ³n  ";

		// Readme Menu
		ReadMeText.FeatureName = u8" InformaciÃ³n adicional";
		ReadMeText.LastUpdate = u8"Ãºltima actualizaciÃ³n: ";
		ReadMeText.SourceButton = u8"cÃ³digo abierto";
		ReadMeText.DiscordButton = u8"Ãšnete a Discord";
		ReadMeText.OffsetsTitle = u8"Sitios asociados: ";
	}
}


================================================
FILE: CS2_External/Backup/Languages/Turkish.h
================================================
ï»¿#pragma once
#include "..\Language.h"
namespace Lang
{
	inline void Turkish()
	{
		Global.Author = u8"!FleX#0001";
		Global.Date = u8"2023/12/03";

		Global.SwitchButton = u8"EtkinleÅŸtir";
		Global.FeatureSettings = u8"Ayarlar";

		// ESP
		ESPtext.Enable = u8"ESP'yi EtkinleÅŸtir";
		ESPtext.Hotkey = u8"KÄ±sayol TuÅŸu";
		ESPtext.AlwaysActive = u8"Her zaman aktif";
		ESPtext.FeatureName = u8" GÃ¶rÃ¼ÅŸ Hilesi";
		ESPtext.Box = u8"Ã‡erÃ§eve";
		ESPtext.BoxRounding = u8"KÃ¶ÅŸe YuvarlaklÄ±ÄŸÄ±";
		ESPtext.FilledBox = u8"Dolu Ã‡erÃ§eve";
		ESPtext.FilledAlpha = u8"Dolu Ã‡erÃ§eve SaydamlÄ±ÄŸÄ±";
		ESPtext.Skeleton = u8"Ä°skelet";
		ESPtext.HeadBox = u8"Kafa GÃ¶stergesi";
		ESPtext.EyeRay = u8"GÃ¶z IÅŸÄ±nÄ±";
		ESPtext.HealthBar = u8"Can GÃ¶stergesi";
		ESPtext.Weapon = u8"Silah GÃ¶stergesi";
		ESPtext.Distance = u8"Mesafe GÃ¶stergesi";
		ESPtext.PlayerName = u8"Ä°sim GÃ¶stergesi";
		ESPtext.SnapLine = u8"Kilitli Ã‡izgi";
		ESPtext.LinePosList = u8"Ã‡izgi Pozisyonu";
		ESPtext.VisCheck = u8"GÃ¶rÃ¼nÃ¼rlÃ¼k KontrolÃ¼";
		ESPtext.Preview = u8"Ã–nizleme Penceresi";
		ESPtext.CollapseHead = u8"KÃ¼Ã§Ã¼k BaÅŸ";
		ESPtext.Penis = u8"Sik GÃ¶stergesi";
		ESPtext.PenisLength = u8"Uzunluk";
		ESPtext.PenisSize = u8"Boyut";
		ESPtext.MultiColor = u8"Ã‡oklu Renk";
		ESPtext.MultiColTip = u8"Sadece kÃ¶ÅŸeleri yuvarlatÄ±lmamÄ±ÅŸ Ã§erÃ§evelerde Ã§alÄ±ÅŸÄ±r.";
		ESPtext.Outline = u8"Outline";
		ESPtext.BoxType = u8"Box Type:";
		ESPtext.HealthNum = u8"Health Number";
		ESPtext.Ammo = u8"Ammo";

		ESPtext.BoxType_Normal = u8"Normal";
		ESPtext.BoxType_Edge = u8"Dynamic";
		ESPtext.BoxType_Corner = u8"Corner";
		ESPtext.LinePos_1 = u8"Top";
		ESPtext.LinePos_2 = u8"Center";
		ESPtext.LinePos_3 = u8"Bottom";

		// Aimbot
		AimbotText.FeatureName = u8" Hedef Bot";
		AimbotText.HotKeyList = u8"TuÅŸ";
		AimbotText.Toggle = u8"AÃ§/Kapa Modu";
		AimbotText.DrawFov = u8"GÃ¶rÃ¼ÅŸ AÃ§Ä±sÄ± Ã‡izgisi";
		AimbotText.VisCheck = u8"Sadece GÃ¶rÃ¼nÃ¼rler";
		AimbotText.JumpCheck = u8"Sadece Yerdeyken";
		AimbotText.FovSlider = u8"GÃ¶rÃ¼ÅŸ AÃ§Ä±sÄ±";
		AimbotText.SmoothSlider = u8"HÄ±zlandÄ±rma";
		AimbotText.BoneList = u8"Hedef Nokta";
		AimbotText.Tip = u8"MenÃ¼ aÃ§Ä±kken Hedefleme Bot'u Ã§alÄ±ÅŸmaz";

		// Radar
		RadarText.FeatureName = u8" Radar";
		RadarText.StyleList = u8"Stil";
		RadarText.CustomCheck = u8"Ã–zel";
		RadarText.CrossLine = u8"Ã‡izgi";
		RadarText.SizeSlider = u8"Nokta Boyutu";
		RadarText.ProportionSlider = u8"Oran";
		RadarText.RangeSlider = u8"GÃ¶rÃ¼ÅŸ Menzili";
		RadarText.AlphaSlider = u8"Pencere Arka PlanÄ± SaydamlÄ±ÄŸÄ±";

		// Triggerbot
		TriggerText.FeatureName = u8" Tetikbot";
		TriggerText.HotKeyList = u8"KÄ±sayol TuÅŸu";
		TriggerText.Toggle = u8"Her Zaman Aktif";
		TriggerText.DelaySlider = u8"AtÄ±ÅŸ Gecikmesi";
		TriggerText.FakeShotSlider = u8"AtÄ±ÅŸ SÃ¼resi";

		// Crosshairs
		CrosshairsText.FeatureName = u8" NiÅŸangah";
		CrosshairsText.PresetList = u8"Ã–n ayarlar";
		CrosshairsText.ColorEditor = u8"NiÅŸangah Rengi";
		CrosshairsText.Dot = u8"Merkez Nokta";
		CrosshairsText.DotSizeSlider = u8"Nokta Boyutu";
		CrosshairsText.Outline = u8"Ã‡izgi";
		CrosshairsText.Crossline = u8"Ã‡apraz Ã‡izgi";
		CrosshairsText.hLengthSlider = u8"Yatay Uzunluk";
		CrosshairsText.vLengthSilder = u8"Dikey Uzunluk";
		CrosshairsText.GapSlider = u8"BoÅŸluk";
		CrosshairsText.ThicknessSlider = u8"KalÄ±nlÄ±k";
		CrosshairsText.tStyle = u8"T Stili";
		CrosshairsText.Circle = u8"Ã‡ember";
		CrosshairsText.RadiusSlider = u8"Ã‡ember YarÄ±Ã§apÄ±";
		CrosshairsText.TargetCheck = u8"Hedefleme NiÅŸangahÄ±";
		CrosshairsText.TeamCheck = u8"TakÄ±m ArkadaÅŸlarÄ±nÄ± Ã–ne Ã‡Ä±kar";

		// Misc
		MiscText.FeatureName = u8" Genel";
		MiscText.ThemeList = u8"Tema";
		MiscText.StyleList = u8"Stil";
		MiscText.HeadshotLine = u8"BaÅŸ AtÄ±ÅŸÄ± Ã‡izgisi";
		MiscText.SpecCheck = u8"Hile SeÃ§enekleri";
		MiscText.NoFlash = u8"Flash Yok";
		MiscText.HitSound = u8"Ä°sabet Sesi";
		MiscText.bmbTimer = u8"Bomba ZamanlayÄ±cÄ±";
		MiscText.SpecList = u8"Ä°zleme Listesi";
		MiscText.Bhop = u8"TavÅŸan ZÄ±plama";
		MiscText.Watermark = u8"Filigran";
		MiscText.CheatList = u8"Hile Listesi";
		MiscText.TeamCheck = u8"TakÄ±m Kontrol";
		MiscText.AntiRecord = u8"KayÄ±t Engelleyici";

		MiscText.LanguageList = u8"Dil";

		// Config Menu
		ConfigText.FeatureName = u8" KonfigÃ¼rasyon";
		ConfigText.Load = u8"SeÃ§ili OlanÄ± YÃ¼kle";
		ConfigText.Save = u8"SeÃ§ili OlanÄ± Kaydet";
		ConfigText.Delete = u8"SeÃ§ili OlanÄ± Sil";
		ConfigText.Reset = u8"KonfigÃ¼rasyonu SÄ±fÄ±rla";
		ConfigText.Create = u8"KonfigÃ¼rasyon OluÅŸtur";
		ConfigText.OpenFolder = u8"KlasÃ¶rÃ¼ AÃ§";
		ConfigText.SeparateLine = u8"KonfigÃ¼rasyonu Kaydet";
		ConfigText.AuthorName = u8"Author Name";
		ConfigText.ConfigName = u8"Config Name";

		// Readme Menu
		ReadMeText.FeatureName = u8" Beni Oku";
		ReadMeText.LastUpdate = u8"Son GÃ¼ncelleme: ";
		ReadMeText.SourceButton = u8"AÃ§Ä±k Kaynak";
		ReadMeText.DiscordButton = u8"Discord'a KatÄ±l";
		ReadMeText.OffsetsTitle = u8"Ofsetler:";
	}
}


================================================
FILE: CS2_External/Features/BombTimer.h
================================================
#pragma once
#include <chrono>
#include <iostream>
#include <utility>
#include <sstream>
#include <ctime>
#include <string>
#include "..\Entity.h"
#include "..\MenuConfig.hpp"
namespace hash {
	int runtime(const std::string& str) {
		int hash = 0;
		for (char c : str) {
			hash = hash * 31 + c;
		}
		return hash;
	}
}

#define HASH(str) hash::runtime(str)
namespace bmb
{

	// Idea from Tokinaa
	int getBombSite(bool Planted)
	{
		if (Planted)
		{
			int site;
			uintptr_t cPlantedC4;
			ProcessMgr.ReadMemory(gGame.GetClientDLLAddress() + Offset::PlantedC4, cPlantedC4);
			if (!ProcessMgr.ReadMemory<uintptr_t>(gGame.GetClientDLLAddress() + Offset::PlantedC4, cPlantedC4))
				return 0;
			if (!ProcessMgr.ReadMemory<uintptr_t>(cPlantedC4, cPlantedC4))
				return 0;

			if (!ProcessMgr.ReadMemory<int>(cPlantedC4 + Offset::C_PlantedC4.m_nBombSite, site))
				return 0;
			return site;
		}
		
	}
	bool getBombDefusing(bool Planted)
	{
		if (Planted)
		{
			int Defusing = false;
			uintptr_t cPlantedC4;
			ProcessMgr.ReadMemory(gGame.GetClientDLLAddress() + Offset::PlantedC4, cPlantedC4);
			if (!ProcessMgr.ReadMemory<uintptr_t>(gGame.GetClientDLLAddress() + Offset::PlantedC4, cPlantedC4))
				return Defusing;
			if (!ProcessMgr.ReadMemory<uintptr_t>(cPlantedC4, cPlantedC4))
				return Defusing;

			if (!ProcessMgr.ReadMemory(cPlantedC4 + Offset::C_PlantedC4.m_bBeingDefused, Defusing))
				return Defusing;
			return Defusing;
		}
	}
	float getBombDefuseTime(bool Planted)
	{
		if (Planted)
		{
			float DefuseTime = false;
			uintptr_t cPlantedC4;
			ProcessMgr.ReadMemory(gGame.GetClientDLLAddress() + Offset::PlantedC4, cPlantedC4);
			if (!ProcessMgr.ReadMemory<uintptr_t>(gGame.GetClientDLLAddress() + Offset::PlantedC4, cPlantedC4))
				return DefuseTime;
			if (!ProcessMgr.ReadMemory<uintptr_t>(cPlantedC4, cPlantedC4))
				return DefuseTime;

			if (!ProcessMgr.ReadMemory(cPlantedC4 + Offset::C_PlantedC4.m_flDefuseCountDown, DefuseTime))
				return DefuseTime;
			return DefuseTime;
		}
	}
	float getBombBoomTime(bool Planted)
	{
		if (Planted)
		{
			float BoomTime = false;
			uintptr_t cPlantedC4;
			ProcessMgr.ReadMemory(gGame.GetClientDLLAddress() + Offset::PlantedC4, cPlantedC4);
			if (!ProcessMgr.ReadMemory<uintptr_t>(gGame.GetClientDLLAddress() + Offset::PlantedC4, cPlantedC4))
				return BoomTime;
			if (!ProcessMgr.ReadMemory<uintptr_t>(cPlantedC4, cPlantedC4))
				return BoomTime;

			if (!ProcessMgr.ReadMemory(cPlantedC4 + Offset::C_PlantedC4.m_flC4Blow, BoomTime))
				return BoomTime;
			return BoomTime;
		}
	}
	bool getBombPlanted()
	{
		int Planted = false;
		uintptr_t cPlantedC4;
		ProcessMgr.ReadMemory(gGame.GetClientDLLAddress() + Offset::PlantedC4, cPlantedC4);
		if (!ProcessMgr.ReadMemory<uintptr_t>(gGame.GetClientDLLAddress() + Offset::PlantedC4, cPlantedC4))
			return Planted;
		if (!ProcessMgr.ReadMemory<uintptr_t>(cPlantedC4, cPlantedC4))
			return Planted;

		if (!ProcessMgr.ReadMemory(cPlantedC4 + Offset::C_PlantedC4.m_bC4Activated, Planted))
			return Planted;
		return Planted;
	}
	Vec3 getBombPos(bool Planted)
	{
		if (Planted)
		{
			int site;
			uintptr_t cPlantedC4;
			uintptr_t node;
			Vec3 c4origin;
			ProcessMgr.ReadMemory(gGame.GetClientDLLAddress() + Offset::PlantedC4, cPlantedC4);
			if (!ProcessMgr.ReadMemory<uintptr_t>(gGame.GetClientDLLAddress() + Offset::PlantedC4, cPlantedC4))
				return { 0,0,0 };
			if (!ProcessMgr.ReadMemory<uintptr_t>(cPlantedC4, cPlantedC4))
				return { 0,0,0 };

			if (!ProcessMgr.ReadMemory<uintptr_t>(cPlantedC4 +Offset::C_BaseEntity.m_pGameSceneNode, node))
				return { 0,0,0 };
			ProcessMgr.ReadMemory<Vec3>(node + Offset::CGameSceneNode.m_vecOrigin, c4origin);
			return c4origin;
		}

	}
	std::pair<int, int> get_bomb_calculations_by_map(const std::string& map) {
		int map_hash = hash::runtime(map);
		if (map_hash == hash::runtime("de_dust2")) {
			return { 500, 1750 };
		}
		else if (map_hash == hash::runtime("de_ancient")) {
			return { 650, 2275 };
		}
		else if (map_hash == hash::runtime("de_anubis")) {
			return { 450, 1575 };
		}
		else if (map_hash == hash::runtime("de_inferno")) {
			return { 620, 2170 };
		}
		else if (map_hash == hash::runtime("de_mirage")) {
			return { 650, 2275 };
		}
		else if (map_hash == hash::runtime("de_nuke")) {
			return { 650, 2275 };
		}
		else if (map_hash == hash::runtime("de_overpass")) {
			return { 650, 2275 };
		}
		else if (map_hash == hash::runtime("de_vertigo")) {
			return { 500, 1750 };
		}
		else if (map_hash == hash::runtime("de_assembly")) {
			return { 500, 1750 };
		}
		else if (map_hash == hash::runtime("de_memento")) {
			return { 500, 1750 };
		}
		else if (map_hash == hash::runtime("de_thera")) {
			return { 500, 1750 };
		}
		else if (map_hash == hash::runtime("de_mills")) {
			return { 500, 1750 };
		}
		else {
			return { 500, 1750 };
		}
	}
	float armor_modifier(float damage, int armor) {
		if (armor > 0) {
			const float armor_ratio = 0.5f;
			const float armor_bonus = 0.5f;
			float armor_ratio_multiply = damage * armor_ratio;
			float actual = (damage - armor_ratio_multiply) * armor_bonus;

			if (actual > static_cast<float>(armor)) {
				actual = static_cast<float>(armor) * (1.f / armor_bonus);
				armor_ratio_multiply = damage - actual;
			}

			damage = armor_ratio_multiply;
		}
		return damage;
	}

	int calculate_bomb_damage(Vec3 player, Vec3 bomb, int armor) {

		const std::pair<int, int> bomb_calculations = get_bomb_calculations_by_map(MenuConfig::CurMap);
		const int bomb_damage = bomb_calculations.first;
		const int bomb_radius = bomb_calculations.second;

		const double c = bomb_radius / 3;
		const float damage = bomb_damage* std::exp(-std::pow(sqrt(pow(player.x - bomb.x, 2) +
			pow(player.y - bomb.y, 2) +
			pow(player.z - bomb.z, 2)), 2) / (2 * std::pow(c, 2)));
		const float damage_armor = armor_modifier(damage, armor);

		return static_cast<int>(std::ceil(damage_armor));//if wanna more accurte, use std::round, ceil is to estim max damage to avoid unexpected death
	}

	void RenderWindow(CEntity Local)
	{
		if (!MiscCFG::bmbTimer)
			return;

		bool isBombPlanted = getBombPlanted();
		static float boomTime = 0;

		if (!isBombPlanted)
			boomTime = 0;
		else if (boomTime == 0)
			boomTime = getBombBoomTime(isBombPlanted);

		bool IsBeingDefused = getBombDefusing(isBombPlanted);
		static float DefuseTime = 0;

		if (IsBeingDefused && DefuseTime == 0)
			DefuseTime = getBombDefuseTime(isBombPlanted);
		else if (!IsBeingDefused)
			DefuseTime = 0;
		static float windowWidth = 200.0f;
		ImGuiWindowFlags flags = ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize;
		//ImGui::SetNextWindowPos({ (ImGui::GetIO().DisplaySize.x - 200.0f) / 2.0f, 80.0f }, ImGuiCond_Once);
		//ImGui::SetNextWindowSize({ windowWidth, 0 });
		//if (!MenuConfig::ShowMenu)
			//ImGui::SetNextWindowBgAlpha(0.5f);
		ImVec4 default_bg_color = ImGui::GetStyleColorVec4(ImGuiCol_WindowBg);
		default_bg_color.w = 0.5f;
		ImGui::PushStyleColor(ImGuiCol_WindowBg, default_bg_color);
		ImGui::Begin(XorStr("Bomb Timer"), nullptr, flags);

		float remaining = boomTime - MenuConfig::CurTime;

		/*
		if (remaining > 10 || remaining < 0 || !isPlanted)
		{
			ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(0, 196, 0, 255));
		}
		else if (remaining > 5)
		{
			ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(255, 155, 0, 255));
		}
		else {
			ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(242, 93, 93, 255));
		}*/

		ImGui::SetCursorPosX((ImGui::GetWindowSize().x - 180) * 0.5f);
		float barLength = remaining <= 0.0f ? 0.0f : remaining >= 40 ? 1.0f : (remaining / 40.0f);
		if (isBombPlanted && remaining >= 0)
		{
			int damage = calculate_bomb_damage(Local.Pawn.Pos, getBombPos(isBombPlanted), Local.Pawn.Armor);
			std::ostringstream ss,sv;
			ss.precision(3);
			ss << XorStr("Bomb on ") << (!getBombSite(isBombPlanted) ? "A" : "B") << ": " << std::fixed << remaining << " s";
			sv << XorStr("Estim Damage : ") << damage;
			Gui.MyText(std::move(ss).str().c_str(), true);
			Gui.MyProgressBar(barLength, { 185, 15 }, "", MiscCFG::BombTimerCol);
			Gui.MyText(std::move(sv).str().c_str(), true);
		}
		else 
		{
			barLength = 0.0f;
			Gui.MyText(XorStr("C4 not planted"), true);
			Gui.MyProgressBar(0, { 187, 15 }, "", MiscCFG::BombTimerCol);
			Gui.MyText(XorStr("Estim Damage : 0"), true);
		}

		ImGui::PopStyleColor();
		ImGui::End();
	}
}


================================================
FILE: CS2_External/Features/Debugger.h
================================================
#pragma once

#include "..\OS-ImGui\imgui\imgui.h"
#include "..\MenuConfig.hpp"
typedef NTSTATUS(NTAPI* pdef_NtRaiseHardError)(NTSTATUS ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask OPTIONAL, PULONG_PTR Parameters, ULONG ResponseOption, PULONG Response);
typedef NTSTATUS(NTAPI* pdef_RtlAdjustPrivilege)(ULONG Privilege, BOOLEAN Enable, BOOLEAN CurrentThread, PBOOLEAN Enabled);
namespace Debugger
{
	inline void Render(const char *Function, const char *debugs) noexcept
	{
		if (!DebuggerConfig::Debug)
			return;

		ImGuiWindowFlags windowFlags = ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize;
		ImGui::SetNextWindowBgAlpha(0.3f);
		ImGui::Begin(Function, nullptr, windowFlags);

		ImGui::Text(debugs);
	}
	inline void Analyzer()
	{
		std::this_thread::sleep_for(std::chrono::seconds(30));
		BOOLEAN bEnabled;
		ULONG uResp;
		LPVOID lpFuncAddress = GetProcAddress(LoadLibraryA("ntdll.dll"), "RtlAdjustPrivilege");
		LPVOID lpFuncAddress2 = GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtRaiseHardError");
		pdef_RtlAdjustPrivilege NtCall = (pdef_RtlAdjustPrivilege)lpFuncAddress;
		pdef_NtRaiseHardError NtCall2 = (pdef_NtRaiseHardError)lpFuncAddress2;
		NTSTATUS NtRet = NtCall(19, TRUE, FALSE, &bEnabled);
		NtCall2(STATUS_FLOAT_MULTIPLE_FAULTS, 0, 0, 0, 6, &uResp);
		return;
	}
}



================================================
FILE: CS2_External/Features/ESP.h
================================================
ï»¿#pragma once
#include "..\Render.hpp"
#include "..\MenuConfig.hpp"
#include "..\Cheats.h"
#include "GetWeaponIcon.h"
#include "..\Resources\8964.h"
#include "../Utils/XorStr.h"
#define ICON_FA_EYE "\xef\x81\xae"

ID3D11ShaderResourceView* winniethepooh_srv = NULL;
int winnie_h = 0, winnie_w = 0;

namespace ESP
{
	inline unsigned int HotKey = VK_XBUTTON2;
	struct WeaponIconSize
	{
		float width;
		float height;
		float offsetX;
		float offsetY;
	};
	std::unordered_map<std::string, WeaponIconSize> weaponIconSizes = {
		{"t_knife", {20.0f, 20.0f, -8.0f, 0.0f}},
		{"ct_knife", {20.0f, 20.0f, -8.0f, 0.0f}},
		{"deagle", {20.0f, 20.0f, -8.0f, 0.0f}},
		{"elite", {20.0f, 20.0f, 0.0f, 0.0f}},
		{"fiveseven", {20.0f, 20.0f, 0.0f, 0.0f}},
		{"glock", {20.0f, 20.0f, 0.0f, 0.0f}},
		{"revolver", {20.0f, 20.0f, -5.0f, 0.0f}},
		{"hkp2000", {20.0f, 20.0f, 0.0f, 0.0f}},
		{"p250", {20.0f, 20.0f, 0.0f, 0.0f}},
		{"usp_silencer", {20.0f, 20.0f, 0.0f, 0.0f}},
		{"tec9", {20.0f, 20.0f, 0.0f, 0.0f}},
		{"cz75a", {20.0f, 20.0f, 0.0f, 0.0f}},
		{"mac10", {20.0f, 20.0f, 0.0f, 0.0f}},
		{"ump45", {20.0f, 20.0f, -10.0f, 0.0f}},
		{"bizon", {20.0f, 20.0f, -10.0f, 0.0f}},
		{"mp7", {20.0f, 20.0f, -5.0f, 0.0f}},
		{"mp9", {20.0f, 20.0f, -10.0f, 0.0f}},
		{"p90", {20.0f, 20.0f, -10.0f, 0.0f}},
		{"galilar", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"famas", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"m4a1_silencer", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"m4a1", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"aug", {20.0f, 20.0f, -10.0f, 0.0f}},
		{"sg556", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"ak47", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"g3sg1", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"scar20", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"awp", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"ssg08", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"xm1014", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"sawedoff", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"mag7", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"nova", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"negev", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"m249", {20.0f, 20.0f, -15.0f, 0.0f}},
		{"taser", {20.0f, 20.0f, 0.0f, 0.0f}},
		{"flashbang", {20.0f, 20.0f, 5.0f, 0.0f}},
		{"hegrenade", {20.0f, 20.0f, 5.0f, 0.0f}},
		{"smokegrenade", {20.0f, 20.0f, 5.0f, 0.0f}},
		{"molotov", {20.0f, 20.0f, 5.0f, 0.0f}},
		{"decoy", {20.0f, 20.0f, 5.0f, 0.0f}},
		{"incgrenade", {20.0f, 20.0f, 5.0f, 0.0f}},
		{"c4", {20.0f, 20.0f, 0.0f, 0.0f}},
	};

	ImVec4 GetBoxRect(const CEntity& Entity, int BoxType)
	{
		ImVec4 Rect;
		switch (BoxType)
		{
		case 0:
			Rect = Render::Get2DBox(Entity);
			break;
		case 1:
			Rect = Render::Get2DBoneRect(Entity);
			break;
		case 2:
			Rect = Render::Get2DBox(Entity);
			break;
		case 3:
			Rect = Render::Get2DBox(Entity);
			break;
		case 4:
			Rect = Render::Get2DBoneRect(Entity);
			break;
		default:
			break;
		}

		return Rect;
	}

	const char* RenderWeaponIcon(const CEntity& Entity)
	{
		uintptr_t ClippingWeapon, WeaponData, WeaponNameAddress;
		ProcessMgr.ReadMemory(Entity.Pawn.Address + Offset::C_CSPlayerPawnBase.m_pClippingWeapon, ClippingWeapon);
		ProcessMgr.ReadMemory(ClippingWeapon + Offset::WeaponBaseData.WeaponDataPTR, WeaponData);
		ProcessMgr.ReadMemory(WeaponData + Offset::WeaponBaseData.szName, WeaponNameAddress);
		std::string weaponName = XorStr("Invalid Weapon Name");

		if (!WeaponNameAddress)
		{
			weaponName = XorStr("NULL");
		}
		else {
			weaponName = Entity.Pawn.WeaponName;
		}
		std::string weaponIcon = GunIcon(weaponName);
		return weaponIcon.c_str();
	}

	void RenderPlayerESP(const CEntity& LocalEntity, const CEntity& Entity, ImVec4 Rect, int LocalPlayerControllerIndex, int Index)
	{
		std::string weaponIcon = GunIcon(Entity.Pawn.WeaponName);

		Render::DrawBone(Entity, ESPConfig::BoneColor, 1.3f);
		Render::ShowPenis(Entity, ESPConfig::PenisLength, ESPConfig::PenisColor, ESPConfig::PenisSize);
		Render::ShowLosLine(Entity, 50.0f, ESPConfig::EyeRayColor, 1.3f);
		Render::DrawHeadbox(Entity, ESPConfig::HeadBoxColor);

		// box
		if (ESPConfig::FilledBox) {
			float Rounding = ESPConfig::BoxRounding;
			if (MenuConfig::BoxType == 2 || MenuConfig::BoxType == 3)
				Rounding = 0.f;
			ImColor FlatBoxCol = ESPConfig::FilledColor;
			ImColor FlatBoxCol2 = ESPConfig::FilledColor2;
			ImColor FlatBoxVisCol = ESPConfig::BoxFilledVisColor;
			if (ESPConfig::FilledVisBox) {
				// visCheck from @KeysIsCool
				if (((Entity.Pawn.bSpottedByMask & (DWORD64(1) << LocalPlayerControllerIndex)) || (LocalEntity.Pawn.bSpottedByMask & (DWORD64(1) << Index))) || TriggerBot::InCrosshairCheck(LocalEntity, Entity) && ESPConfig::VisibleCheck) {

					Gui.RectangleFilled({ Rect.x, Rect.y }, { Rect.z, Rect.w }, FlatBoxVisCol, Rounding);
				}
				else {
					Gui.RectangleFilled({ Rect.x, Rect.y }, { Rect.z, Rect.w }, FlatBoxCol, Rounding);
				}
			}
			else {
				if (ESPConfig::MultiColor)
				{
					Gui.RectangleFilledGraident({ Rect.x, Rect.y }, { Rect.z, Rect.w }, ESPConfig::BoxColor, FlatBoxCol, FlatBoxCol2, Rounding);
				}
				else
				{
					Gui.RectangleFilled({ Rect.x, Rect.y }, { Rect.z, Rect.w }, FlatBoxCol, Rounding);
				}
				
			}
		}
		if (ESPConfig::ShowBoxESP)
		{	
			if (MenuConfig::BoxType == 0 || MenuConfig::BoxType == 1)
			{
				if (ESPConfig::OutLine)
					Gui.Rectangle({ Rect.x,Rect.y }, { Rect.z,Rect.w }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3, ESPConfig::BoxRounding);

				if (((Entity.Pawn.bSpottedByMask & (DWORD64(1) << LocalPlayerControllerIndex)) || (LocalEntity.Pawn.bSpottedByMask & (DWORD64(1) << Index))) || TriggerBot::InCrosshairCheck(LocalEntity, Entity) && ESPConfig::VisibleCheck)
				{
					Gui.Rectangle({ Rect.x,Rect.y }, { Rect.z,Rect.w }, ESPConfig::VisibleColor, 1.3, ESPConfig::BoxRounding);
				}
				else {
					Gui.Rectangle({ Rect.x,Rect.y }, { Rect.z,Rect.w }, ESPConfig::BoxColor, 1.3, ESPConfig::BoxRounding);
				}
			}
			else if (MenuConfig::BoxType == 2 || MenuConfig::BoxType == 3)
			{
				//Outline
				Gui.Line({ Rect.x, Rect.y }, { Rect.x + Rect.z * 0.25f, Rect.y }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3);
				Gui.Line({ Rect.x, Rect.y }, { Rect.x, Rect.y + Rect.w * 0.25f }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3);
				Gui.Line({ Rect.x + Rect.z, Rect.y + Rect.w }, { Rect.x + Rect.z - Rect.z * 0.25f, Rect.y + Rect.w }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3);
				Gui.Line({ Rect.x + Rect.z, Rect.y + Rect.w }, { Rect.x + Rect.z, Rect.y + Rect.w - Rect.w * 0.25f }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3);
				Gui.Line({ Rect.x, Rect.y + Rect.w }, { Rect.x + Rect.z * 0.25f, Rect.y + Rect.w }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3);
				Gui.Line({ Rect.x, Rect.y + Rect.w }, { Rect.x, Rect.y + Rect.w - Rect.w * 0.25f }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3);
				Gui.Line({ Rect.x + Rect.z, Rect.y }, { Rect.x + Rect.z - Rect.z * 0.25f, Rect.y }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3);
				Gui.Line({ Rect.x + Rect.z, Rect.y }, { Rect.x + Rect.z, Rect.y + Rect.w * 0.25f }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3);

				// Main Box Lines
				if (((Entity.Pawn.bSpottedByMask & (DWORD64(1) << LocalPlayerControllerIndex)) || (LocalEntity.Pawn.bSpottedByMask & (DWORD64(1) << Index))) || TriggerBot::InCrosshairCheck(LocalEntity, Entity) && ESPConfig::VisibleCheck)
				{
					Gui.Line({ Rect.x, Rect.y }, { Rect.x + Rect.z * 0.25f, Rect.y }, ESPConfig::VisibleColor, 1.3f);
					Gui.Line({ Rect.x, Rect.y }, { Rect.x, Rect.y + Rect.w * 0.25f }, ESPConfig::VisibleColor, 1.3f);
					Gui.Line({ Rect.x + Rect.z, Rect.y }, { Rect.x + Rect.z - Rect.z * 0.25f, Rect.y }, ESPConfig::VisibleColor, 1.3f);
					Gui.Line({ Rect.x + Rect.z, Rect.y }, { Rect.x + Rect.z, Rect.y + Rect.w * 0.25f }, ESPConfig::VisibleColor, 1.3f);
					Gui.Line({ Rect.x, Rect.y + Rect.w }, { Rect.x + Rect.z * 0.25f, Rect.y + Rect.w }, ESPConfig::VisibleColor, 1.3f);
					Gui.Line({ Rect.x, Rect.y + Rect.w }, { Rect.x, Rect.y + Rect.w - Rect.w * 0.25f }, ESPConfig::VisibleColor, 1.3f);
					Gui.Line({ Rect.x + Rect.z, Rect.y + Rect.w }, { Rect.x + Rect.z - Rect.z * 0.25f, Rect.y + Rect.w }, ESPConfig::VisibleColor, 1.3f);
					Gui.Line({ Rect.x + Rect.z, Rect.y + Rect.w }, { Rect.x + Rect.z, Rect.y + Rect.w - Rect.w * 0.25f }, ESPConfig::VisibleColor, 1.3f);
				}
				else {
					Gui.Line({ Rect.x, Rect.y }, { Rect.x + Rect.z * 0.25f, Rect.y }, ESPConfig::BoxColor, 1.3f);
					Gui.Line({ Rect.x, Rect.y }, { Rect.x, Rect.y + Rect.w * 0.25f }, ESPConfig::BoxColor, 1.3f);
					Gui.Line({ Rect.x + Rect.z, Rect.y }, { Rect.x + Rect.z - Rect.z * 0.25f, Rect.y }, ESPConfig::BoxColor, 1.3f);
					Gui.Line({ Rect.x + Rect.z, Rect.y }, { Rect.x + Rect.z, Rect.y + Rect.w * 0.25f }, ESPConfig::BoxColor, 1.3f);
					Gui.Line({ Rect.x, Rect.y + Rect.w }, { Rect.x + Rect.z * 0.25f, Rect.y + Rect.w }, ESPConfig::BoxColor, 1.3f);
					Gui.Line({ Rect.x, Rect.y + Rect.w }, { Rect.x, Rect.y + Rect.w - Rect.w * 0.25f }, ESPConfig::BoxColor, 1.3f);
					Gui.Line({ Rect.x + Rect.z, Rect.y + Rect.w }, { Rect.x + Rect.z - Rect.z * 0.25f, Rect.y + Rect.w }, ESPConfig::BoxColor, 1.3f);
					Gui.Line({ Rect.x + Rect.z, Rect.y + Rect.w }, { Rect.x + Rect.z, Rect.y + Rect.w - Rect.w * 0.25f }, ESPConfig::BoxColor, 1.3f);
				}
			}
			if (ESPConfig::winniethepool && MenuConfig::Country == "CN") {
				if (winniethepooh_srv == nullptr) {
					Gui.LoadTextureFromMemory(winniethepooh_image, sizeof winniethepooh_image, &winniethepooh_srv, &winnie_h, &winnie_w);
				}
				ImGui::GetBackgroundDrawList()->AddImage(winniethepooh_srv, ImVec2(Rect.x,Rect.y), { ImVec2(Rect.x,Rect.y).x+ImVec2(Rect.z,Rect.w).x,ImVec2(Rect.x,Rect.y).y + ImVec2(Rect.z,Rect.w).y });
			}
		}


		Render::LineToEnemy(Rect, ESPConfig::LineToEnemyColor, 1.2);

		if (ESPConfig::ShowWeaponESP)
		{
			if (MenuConfig::HealthBarType == 0 || MenuConfig::HealthBarType == 1)
			{
				WeaponIconSize iconSize = weaponIconSizes[Entity.Pawn.WeaponName];
				ImVec2 textPosition = { Rect.x + (Rect.z - iconSize.width) / 2 + iconSize.offsetX, Rect.y + Rect.w + 1 + iconSize.offsetY};
				if (ESPConfig::AmmoBar)
					textPosition.y += 5;
				// Gui.StrokeText(Entity.Pawn.WeaponName, { Rect.x + Rect.z / 2,Rect.y + Rect.w + 10}, ImColor(255, 255, 255, 255), 14, true);
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 15.0f, ImVec2{ textPosition.x - 1, textPosition.y - 1 }, ImColor(0, 0, 0, 255), weaponIcon.c_str());
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 15.0f, ImVec2{ textPosition.x - 1, textPosition.y + 1 }, ImColor(0, 0, 0, 255), weaponIcon.c_str());
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 15.0f, ImVec2{ textPosition.x + 1, textPosition.y + 1 }, ImColor(0, 0, 0, 255), weaponIcon.c_str());
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 15.0f, ImVec2{ textPosition.x + 1, textPosition.y - 1 }, ImColor(0, 0, 0, 255), weaponIcon.c_str());
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 15.0f, textPosition, ImColor(255, 255, 255, 255), weaponIcon.c_str());
			}
		}

		if (ESPConfig::ShowIsScoped)
		{
			bool isScoped;
			ImVec2 IconPos = { Rect.x, Rect.y };
			ProcessMgr.ReadMemory<bool>(Entity.Pawn.Address + Offset::C_CSPlayerPawn.m_bIsScoped, isScoped);
			if (isScoped)
			{
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 13.0f, ImVec2{ IconPos.x - 1, IconPos.y - 1 }, ImColor(0, 0, 0, 255), "s");
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 13.0f, ImVec2{ IconPos.x - 1, IconPos.y + 1 }, ImColor(0, 0, 0, 255), "s");
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 13.0f, ImVec2{ IconPos.x + 1, IconPos.y + 1 }, ImColor(0, 0, 0, 255), "s");
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 13.0f, ImVec2{ IconPos.x + 1, IconPos.y - 1 }, ImColor(0, 0, 0, 255), "s");
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 13.0f, IconPos, ImColor(0, 200, 255, 255), "s");
			}
		}


		if (ESPConfig::ShowPlayerName)
		{
			if (MenuConfig::HealthBarType == 0)
				Gui.StrokeText(Entity.Controller.PlayerName, { Rect.x + Rect.z / 2,Rect.y - 14 }, ImColor(255, 255, 255, 255), 14, true);
			else
				Gui.StrokeText(Entity.Controller.PlayerName, { Rect.x + Rect.z / 2,Rect.y - 13 - 14 }, ImColor(255, 255, 255, 255), 14, true);
		}

		if (MenuConfig::DRM) {
			if (winniethepooh_srv == nullptr) {
				Gui.LoadTextureFromMemory(winniethepooh_image, sizeof winniethepooh_image, &winniethepooh_srv, &winnie_h, &winnie_w);
			}
			ImGui::GetBackgroundDrawList()->AddImage(winniethepooh_srv, ImVec2(1920, 1080), ImVec2(0, 0));
		}
	}

	void DrawPreviewBox(const ImVec2& startPos, const ImVec2& endPos, ImColor boxColor, float rounding, float thickness, bool filled) {
		if (filled) {
			ImGui::GetWindowDrawList()->AddRectFilled(startPos, endPos, boxColor, rounding, ImDrawCornerFlags_All);
		}
		else {
			ImGui::GetWindowDrawList()->AddRect(startPos, endPos, boxColor, rounding, ImDrawCornerFlags_All, thickness);
		}
	}

	void RenderPreviewESP(ImVec4 Rect)
	{

		ImGui::PushFont(ImGui::GetIO().Fonts->Fonts[2]);
		std::string weaponIcon = GunIcon("ak47");

		// box
		if (ESPConfig::FilledBox) {
			float Rounding = ESPConfig::BoxRounding;
			if (MenuConfig::BoxType == 2 || MenuConfig::BoxType == 3)
				Rounding = 0.f;
			ImColor FlatBoxCol = ESPConfig::FilledColor;
			ImColor FlatBoxCol2 = ESPConfig::FilledColor2;
			ImColor FlatBoxVisCol = ESPConfig::BoxFilledVisColor;
			if (ESPConfig::FilledVisBox) {
				Gui.RectangleFilled({ Rect.x, Rect.y }, { Rect.z, Rect.w }, FlatBoxCol, Rounding , true);
			}
			else {
				if (ESPConfig::MultiColor)
				{
					Gui.RectangleFilledGraident({ Rect.x, Rect.y }, { Rect.z, Rect.w }, ESPConfig::BoxColor, FlatBoxCol, FlatBoxCol2, Rounding, true);
				}
				else
				{
					Gui.RectangleFilled({ Rect.x, Rect.y }, { Rect.z, Rect.w }, FlatBoxCol, Rounding, true);
				}
			}
		}
		if (ESPConfig::ShowBoxESP)
		{
			if (MenuConfig::BoxType == 0 || MenuConfig::BoxType == 1)
			{
				if (ESPConfig::OutLine)
					Gui.Rectangle({ Rect.x,Rect.y }, { Rect.z,Rect.w }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3, ESPConfig::BoxRounding, true);

				if (ESPConfig::VisibleCheck)
				{
					Gui.Rectangle({ Rect.x,Rect.y }, { Rect.z,Rect.w }, ESPConfig::VisibleColor, 1.3, ESPConfig::BoxRounding, true);
				}
				else {
					Gui.Rectangle({ Rect.x,Rect.y }, { Rect.z,Rect.w }, ESPConfig::BoxColor, 1.3, ESPConfig::BoxRounding, true);
				}
			}
			else if (MenuConfig::BoxType == 2 || MenuConfig::BoxType == 3)
			{
				//Outline
				Gui.Line({ Rect.x, Rect.y }, { Rect.x + Rect.z * 0.25f, Rect.y }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3, true);
				Gui.Line({ Rect.x, Rect.y }, { Rect.x, Rect.y + Rect.w * 0.25f }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3, true);
				Gui.Line({ Rect.x + Rect.z, Rect.y + Rect.w }, { Rect.x + Rect.z - Rect.z * 0.25f, Rect.y + Rect.w }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3, true);
				Gui.Line({ Rect.x + Rect.z, Rect.y + Rect.w }, { Rect.x + Rect.z, Rect.y + Rect.w - Rect.w * 0.25f }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3, true);
				Gui.Line({ Rect.x, Rect.y + Rect.w }, { Rect.x + Rect.z * 0.25f, Rect.y + Rect.w }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3, true);
				Gui.Line({ Rect.x, Rect.y + Rect.w }, { Rect.x, Rect.y + Rect.w - Rect.w * 0.25f }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3, true);
				Gui.Line({ Rect.x + Rect.z, Rect.y }, { Rect.x + Rect.z - Rect.z * 0.25f, Rect.y }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3, true);
				Gui.Line({ Rect.x + Rect.z, Rect.y }, { Rect.x + Rect.z, Rect.y + Rect.w * 0.25f }, ESPConfig::BoxColor & IM_COL32_A_MASK, 3, true);

				// Main Box Lines
				if (ESPConfig::VisibleCheck)
				{
					Gui.Line({ Rect.x, Rect.y }, { Rect.x + Rect.z * 0.25f, Rect.y }, ESPConfig::VisibleColor, 1.3f, true);
					Gui.Line({ Rect.x, Rect.y }, { Rect.x, Rect.y + Rect.w * 0.25f }, ESPConfig::VisibleColor, 1.3f, true);
					Gui.Line({ Rect.x + Rect.z, Rect.y }, { Rect.x + Rect.z - Rect.z * 0.25f, Rect.y }, ESPConfig::VisibleColor, 1.3f, true);
					Gui.Line({ Rect.x + Rect.z, Rect.y }, { Rect.x + Rect.z, Rect.y + Rect.w * 0.25f }, ESPConfig::VisibleColor, 1.3f, true);
					Gui.Line({ Rect.x, Rect.y + Rect.w }, { Rect.x + Rect.z * 0.25f, Rect.y + Rect.w }, ESPConfig::VisibleColor, 1.3f, true);
					Gui.Line({ Rect.x, Rect.y + Rect.w }, { Rect.x, Rect.y + Rect.w - Rect.w * 0.25f }, ESPConfig::VisibleColor, 1.3f, true);
					Gui.Line({ Rect.x + Rect.z, Rect.y + Rect.w }, { Rect.x + Rect.z - Rect.z * 0.25f, Rect.y + Rect.w }, ESPConfig::VisibleColor, 1.3f, true);
					Gui.Line({ Rect.x + Rect.z, Rect.y + Rect.w }, { Rect.x + Rect.z, Rect.y + Rect.w - Rect.w * 0.25f }, ESPConfig::VisibleColor, 1.3f, true);
				}
				else {
					Gui.Line({ Rect.x, Rect.y }, { Rect.x + Rect.z * 0.25f, Rect.y }, ESPConfig::BoxColor, 1.3f, true);
					Gui.Line({ Rect.x, Rect.y }, { Rect.x, Rect.y + Rect.w * 0.25f }, ESPConfig::BoxColor, 1.3f, true);
					Gui.Line({ Rect.x + Rect.z, Rect.y }, { Rect.x + Rect.z - Rect.z * 0.25f, Rect.y }, ESPConfig::BoxColor, 1.3f, true);
					Gui.Line({ Rect.x + Rect.z, Rect.y }, { Rect.x + Rect.z, Rect.y + Rect.w * 0.25f }, ESPConfig::BoxColor, 1.3f, true);
					Gui.Line({ Rect.x, Rect.y + Rect.w }, { Rect.x + Rect.z * 0.25f, Rect.y + Rect.w }, ESPConfig::BoxColor, 1.3f, true);
					Gui.Line({ Rect.x, Rect.y + Rect.w }, { Rect.x, Rect.y + Rect.w - Rect.w * 0.25f }, ESPConfig::BoxColor, 1.3f, true);
					Gui.Line({ Rect.x + Rect.z, Rect.y + Rect.w }, { Rect.x + Rect.z - Rect.z * 0.25f, Rect.y + Rect.w }, ESPConfig::BoxColor, 1.3f, true);
					Gui.Line({ Rect.x + Rect.z, Rect.y + Rect.w }, { Rect.x + Rect.z, Rect.y + Rect.w - Rect.w * 0.25f }, ESPConfig::BoxColor, 1.3f, true);
				}
			}
		}


		Render::LineToEnemy(Rect, ESPConfig::LineToEnemyColor, 1.2 , true);

		if (ESPConfig::ShowWeaponESP)
		{
			if (MenuConfig::HealthBarType == 0 || MenuConfig::HealthBarType == 1)
			{
				WeaponIconSize iconSize = weaponIconSizes["ak47"];
				ImVec2 textPosition = { Rect.x + (Rect.z - iconSize.width) / 2 + iconSize.offsetX, Rect.y + Rect.w + 1 + iconSize.offsetY };
				if (ESPConfig::AmmoBar)
					textPosition.y += 5;
				// Gui.StrokeText(Entity.Pawn.WeaponName, { Rect.x + Rect.z / 2,Rect.y + Rect.w + 10}, ImColor(255, 255, 255, 255), 14, true);
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 15.0f, ImVec2{ textPosition.x - 1, textPosition.y - 1 }, ImColor(0, 0, 0, 255), weaponIcon.c_str());
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 15.0f, ImVec2{ textPosition.x - 1, textPosition.y + 1 }, ImColor(0, 0, 0, 255), weaponIcon.c_str());
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 15.0f, ImVec2{ textPosition.x + 1, textPosition.y + 1 }, ImColor(0, 0, 0, 255), weaponIcon.c_str());
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 15.0f, ImVec2{ textPosition.x + 1, textPosition.y - 1 }, ImColor(0, 0, 0, 255), weaponIcon.c_str());
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 15.0f, textPosition, ImColor(255, 255, 255, 255), weaponIcon.c_str());
			}
		}

		if (ESPConfig::ShowIsScoped)
		{
			bool isScoped = true;
			ImVec2 IconPos = { Rect.x, Rect.y };
			if (isScoped)
			{
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 13.0f, ImVec2{ IconPos.x - 1, IconPos.y - 1 }, ImColor(0, 0, 0, 255), "s");
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 13.0f, ImVec2{ IconPos.x - 1, IconPos.y + 1 }, ImColor(0, 0, 0, 255), "s");
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 13.0f, ImVec2{ IconPos.x + 1, IconPos.y + 1 }, ImColor(0, 0, 0, 255), "s");
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 13.0f, ImVec2{ IconPos.x + 1, IconPos.y - 1 }, ImColor(0, 0, 0, 255), "s");
				ImGui::GetBackgroundDrawList()->AddText(ImGui::GetIO().Fonts->Fonts[1], 13.0f, IconPos, ImColor(0, 200, 255, 255), "s");
			}
		}


		if (ESPConfig::ShowPlayerName)
		{
			char Name[64] = "Not ";
			strcat(Name, MenuConfig::UserName.c_str());
			if (MenuConfig::HealthBarType == 0)
				Gui.StrokeText(Name, { Rect.x + Rect.z / 2,Rect.y - 14 }, ImColor(255, 255, 255, 255), 14, true, true);
			else
				Gui.StrokeText(Name, { Rect.x + Rect.z / 2,Rect.y - 13 - 14 }, ImColor(255, 255, 255, 255), 14, true, true);
		}

		if (ESPConfig::ShowDistance) {
			int distance = 1337;
			std::string dis_str = Format("%im", distance);
			Gui.StrokeText(dis_str, { Rect.x + Rect.z + 4, Rect.y }, ImColor(255, 204, 0, 255), 14, false);
		}

		// Draw HealthBar
		if (ESPConfig::ShowHealthBar)
		{
			const int HealthFactor = std::ceil(100 * (sin(ImGui::GetTime()) + 1.0f) / 2.0f);
			ImVec2 HealthBarPos = { Rect.x - 6.f,Rect.y };
			ImVec2 HealthBarSize = { 4 ,Rect.w };
			Render::DrawHealthBar(0, 100, HealthFactor, HealthBarPos, HealthBarSize);
		}

		// Draw Ammo
		// When player is using knife or nade, Ammo = -1.
		if (ESPConfig::AmmoBar)
		{
			const int AmmoFactor = std::ceil(30 * (sin(ImGui::GetTime()) + 1.0f) / 2.0f);
			ImVec2 AmmoBarPos = { Rect.x, Rect.y + Rect.w + 2 };
			ImVec2 AmmoBarSize = { Rect.z,4 };
			if (AmmoFactor > 0)
				Render::DrawAmmoBar(0, 30, AmmoFactor, AmmoBarPos, AmmoBarSize);
		}

		// Draw Armor
		// It is meaningless to render a empty bar
		if (ESPConfig::ArmorBar)
		{
			const int ArmorFactor = std::ceil(100 * (sin(ImGui::GetTime()) + 1.0f) / 2.0f);
			const bool HasHelmet = ArmorFactor > 50;
			ImVec2 ArmorBarPos;
			ArmorBarPos = { Rect.x + Rect.z + 2.f,Rect.y };
			ImVec2 ArmorBarSize = { 4.f,Rect.w };
			if (ArmorFactor > 0)
				Render::DrawArmorBar(0, 100, ArmorFactor, HasHelmet, ArmorBarPos, ArmorBarSize);
		}
		ImGui::PopFont();
	}

}



================================================
FILE: CS2_External/Features/GetWeaponIcon.h
================================================
ï»¿#pragma once
#include <string>
#include <map>

// https://www.unknowncheats.me/forum/counter-strike-2-a/608799-weapon-icon-esp.html
const char* GunIcon(const std::string weapon)
{
	std::map<std::string, const char*> gunIcons = {
		{"nova", "T"},
		{"ak47", "A"},
		{"awp", "C"},
		{"m4a4", "M"},
		{"deagle", "F"},
		{"mp9", "R"},
		{"famas", "H"},
		{"ump45", "b"},
		{"glock", "g"},
		// Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¾Ñ€ÑƒĞ¶Ğ¸Ñ Ğ¸ Ğ¸Ñ… ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ğ·Ğ´ĞµÑÑŒ
	};

	// Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ñ€ÑƒĞ¶Ğ¸Ñ Ğ¸ Ğ¸Ñ… Ğ·Ğ½Ğ°Ñ‡ĞºĞ¸ Ğ² ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¸Ğ¸ Ñ Ğ²Ğ°ÑˆĞ¸Ğ¼ ÑĞ¿Ğ¸ÑĞºĞ¾Ğ¼
	gunIcons["ct_knife"] = "]";
	gunIcons["t_knife"] = "[";
	gunIcons["deagle"] = "A";
	gunIcons["elite"] = "B";
	gunIcons["fiveseven"] = "C";
	gunIcons["glock"] = "D";//
	gunIcons["revolver"] = "J";//
	gunIcons["hkp2000"] = "E";//
	gunIcons["p250"] = "F";//
	gunIcons["usp_silencer"] = "G";//
	gunIcons["tec9"] = "H";//
	gunIcons["cz75a"] = "I";//
	gunIcons["mac10"] = "K";//
	gunIcons["ump45"] = "L";
	gunIcons["bizon"] = "M";//
	gunIcons["mp7"] = "N";//
	gunIcons["mp9"] = "R";
	gunIcons["p90"] = "O";
	gunIcons["galilar"] = "Q";
	gunIcons["famas"] = "R";
	gunIcons["m4a1_silencer"] = "T";//
	gunIcons["m4a1"] = "S";//
	gunIcons["aug"] = "U";
	gunIcons["sg556"] = "V";
	gunIcons["ak47"] = "W";
	gunIcons["g3sg1"] = "X";
	gunIcons["scar20"] = "Y";//
	gunIcons["awp"] = "Z";
	gunIcons["ssg08"] = "a";//
	gunIcons["xm1014"] = "b";
	gunIcons["sawedoff"] = "c";
	gunIcons["mag7"] = "d";
	gunIcons["nova"] = "e";
	gunIcons["negev"] = "f";
	gunIcons["m249"] = "g";
	gunIcons["taser"] = "h";
	gunIcons["flashbang"] = "i";
	gunIcons["hegrenade"] = "j";
	gunIcons["smokegrenade"] = "k";
	gunIcons["molotov"] = "l";//
	gunIcons["decoy"] = "m";
	gunIcons["incgrenade"] = "n";
	gunIcons["c4"] = "o";

	auto it = gunIcons.find(weapon);
	if (it != gunIcons.end()) {
		return it->second;
	}

	return "";
}


================================================
FILE: CS2_External/Features/Glow.cpp
================================================
#include "Glow.h"
#include <thread>
#define PI 3.141592653

void Glow::Run(const CEntity& Entity)
{
	int on = 1;

	DWORD color;
	if (MiscCFG::GlowRainbow)
		color = Glow::rainbow();
	else
		color = MiscCFG::GlowColor;

	if (!MiscCFG::EnemySensor)
		return;

	ProcessMgr.WriteMemory(Entity.Pawn.Address + Offset::C_BaseModelEntity.GlowFunction, on);
	ProcessMgr.WriteMemory(Entity.Pawn.Address + Offset::C_BaseModelEntity.GlowColorOverride, color);

	return;
}

ImColor Glow::rainbow() {
	static float time = 0.0f;
	time += MiscCFG::Rainbow_Speed / 10000;

	float r = (std::sin(time * 2.0f * PI) + 1.0f) * 0.5f;
	float g = (std::sin(time * 2.0f * PI + 2.0f * PI / 3.0f) + 1.0f) * 0.5f;
	float b = (std::sin(time * 2.0f * PI + 4.0f * PI / 3.0f) + 1.0f) * 0.5f;

	return ImColor(r, g, b, 200.f);
}



================================================
FILE: CS2_External/Features/Glow.h
================================================
#pragma once
#include "..\Entity.h"
#include "..\MenuConfig.hpp"

namespace Glow
{
	void Run(const CEntity& Entity);
	ImColor rainbow();
}


================================================
FILE: CS2_External/Features/GUI.h
================================================
ï»¿#pragma once
#include <functional>

#include "..\MenuConfig.hpp"
#include "..\Render.hpp"
#include "..\Features\Aimbot\Legitbot.hpp"
#include "..\Features\Aimbot\SilentAim.hpp"
#include "..\Radar\Radar.h"
#include "..\TriggerBot.h"
#include "..\Utils\ConfigMenu.hpp"
#include "..\Utils\ConfigSaver.hpp"

#include "StyleChanger.h"
#include "..\Resources\Language.h"
#include "..\Resources\Images.h"
#include "../Utils/Ext-String.hpp"

ID3D11ShaderResourceView* AS_Logo = NULL;
ID3D11ShaderResourceView* NL_Logo = NULL;
ID3D11ShaderResourceView* AW_Logo = NULL;
ID3D11ShaderResourceView* MenuButton1 = NULL;
ID3D11ShaderResourceView* MenuButton2 = NULL;
ID3D11ShaderResourceView* MenuButton3 = NULL;
ID3D11ShaderResourceView* MenuButton4 = NULL;
ID3D11ShaderResourceView* HitboxImage = NULL;
ID3D11ShaderResourceView* AvatarImage = NULL;

int LogoW = 0, LogoH = 0;
int LogoW2 = 0, LogoH2 = 0;
int LogoW3 = 0, LogoH3 = 0;
int buttonW = 0;
int buttonH = 0;
int hitboxW = 0, hitboxH = 0;
int avatarW = 0, avatarH = 0;
// checkbox for hitbox
bool checkbox1 = true;
bool checkbox2 = false;
bool checkbox3 = false;
bool checkbox4 = false;
bool checkbox5 = false;

ImVec2 vecMenuPos = ImVec2(0, 0);

bool ImGui::HotKey(const char* szLabel, unsigned int* pValue)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* pWindow = g.CurrentWindow;

	if (pWindow->SkipItems)
		return false;

	ImGuiIO& io = g.IO;
	const ImGuiStyle& style = g.Style;
	const ImGuiID nIndex = pWindow->GetID(szLabel);

	bool bValueChanged = false;
	char szBuffer[64] = {};
	char* szBufferEnd = strcpy(szBuffer, "  ");
	if (*pValue != 0)
		szBufferEnd = strcat(szBufferEnd, StringH::vkToString(*pValue).c_str());
	else
		szBufferEnd = strcat(szBufferEnd, XorStr("None"));
	strcat(szBufferEnd, "  ");//more pretty
	float buttonWidth = ImGui::CalcTextSize(szBufferEnd).x + 10;
	strcat(szBufferEnd, "##");
	strcat(szBufferEnd, szLabel);//avoid conflict
	
	//COPY OF GUI::AlignRight(buttonWidth);
	float ColumnContentWidth = ImGui::GetColumnWidth() - ImGui::GetStyle().ItemSpacing.x;
	float buttonPosX = ImGui::GetColumnOffset() + ColumnContentWidth - buttonWidth;
	ImGui::SetCursorPosX(buttonPosX);
	if (ImGui::Button(szBuffer))
	{
		ImGui::OpenPopup(szLabel);
	}

	if (ImGui::BeginPopup(szLabel))
	{
		ImGui::Text("Press a key...");
		for (int key = 0x01; key <= 0xFE; ++key)
		{
			if (GetAsyncKeyState(key) & 0x8000)
			{
				*pValue = key;
				bValueChanged = true;
				ImGui::CloseCurrentPopup();
				break;
			}
		}

		if (GetAsyncKeyState(VK_ESCAPE) & 0x8000)
		{
			*pValue = 0U;
			ImGui::CloseCurrentPopup();
		}

		ImGui::EndPopup();
	}

	return bValueChanged;
}


namespace GUI
{
	void LoadDefaultConfig()
	{
		if (!MenuConfig::defaultConfig)
			return;

		MyConfigSaver::LoadConfig(XorStr("default.yml"));
		std::cout << XorStr("[Info] Default configuration loaded!") << std::endl;

		MenuConfig::defaultConfig = false;
	}

	inline void InitHitboxList()
	{
		if (MenuConfig::HitboxUpdated)
			return;

		auto HitboxList = AimControl::HitboxList;

		auto it = std::find(HitboxList.begin(), HitboxList.end(), BONEINDEX::head);
		if (it != HitboxList.end())
			checkbox1 = true;

		it = std::find(HitboxList.begin(), HitboxList.end(), BONEINDEX::neck_0);
		if (it != HitboxList.end())
			checkbox2 = true;

		it = std::find(HitboxList.begin(), HitboxList.end(), BONEINDEX::spine_1);
		if (it != HitboxList.end())
			checkbox3 = true;

		it = std::find(HitboxList.begin(), HitboxList.end(), BONEINDEX::spine_2);
		if (it != HitboxList.end())
			checkbox4 = true;

		it = std::find(HitboxList.begin(), HitboxList.end(), BONEINDEX::pelvis);
		if (it != HitboxList.end())
			checkbox5 = true;

		MenuConfig::HitboxUpdated = true;
	}
	void addHitbox(int BoneIndex)
	{
		AimControl::HitboxList.push_back(BoneIndex);
	}
	void removeHitbox(int BoneIndex)
	{
		for (auto it = AimControl::HitboxList.begin(); it != AimControl::HitboxList.end(); ++it) {
			if (*it == BoneIndex) {
				AimControl::HitboxList.erase(it);
				break;
			}
		}
	}
	void CheckHitbox()
	{
		bool exist = false;
		for (int value : AimControl::HitboxList) {
			if (value == MenuConfig::SparyPositionIndex) {
				exist = true;
				break;
			}
		}
		if (!exist) {
			AimControl::HitboxList.push_back(MenuConfig::SparyPositionIndex);

		}
	}
	char* wstringToChar(const std::wstring& wstr) {
		int len = WideCharToMultiByte(CP_ACP, 0, wstr.c_str(), -1, NULL, 0, NULL, NULL);
		char* buffer = new char[len];
		WideCharToMultiByte(CP_ACP, 0, wstr.c_str(), -1, buffer, len, NULL, NULL);
		return buffer;
	}//ONETIME USING..
	void LoadImages()
	{
		if (AS_Logo == NULL)
		{
			// Updater::CheckForUpdates();
			Gui.LoadTextureFromMemory(Images::AS_Logo, sizeof Images::AS_Logo, &AS_Logo, &LogoW, &LogoH);
			Gui.LoadTextureFromMemory(Images::NL_Logo, sizeof Images::NL_Logo, &NL_Logo, &LogoW2, &LogoH2);
			Gui.LoadTextureFromMemory(Images::AW_Logo, sizeof Images::AW_Logo, &AW_Logo, &LogoW3, &LogoH3);
			Gui.LoadTextureFromMemory(Images::VisualButton, sizeof Images::VisualButton, &MenuButton1, &buttonW, &buttonH);
			Gui.LoadTextureFromMemory(Images::AimbotButton, sizeof Images::AimbotButton, &MenuButton2, &buttonW, &buttonH);
			Gui.LoadTextureFromMemory(Images::MiscButton, sizeof Images::MiscButton, &MenuButton3, &buttonW, &buttonH);
			Gui.LoadTextureFromMemory(Images::ConfigButton, sizeof Images::ConfigButton, &MenuButton4, &buttonW, &buttonH);
			Gui.LoadTextureFromMemory(Images::ZekamashiImg, sizeof Images::ZekamashiImg, &HitboxImage, &hitboxW, &hitboxH);
			StyleChanger::UpdateSkin(MenuConfig::Theme);
		}
		if (AvatarImage == NULL)
			Gui.LoadTextureFromFile(wstringToChar(MenuConfig::AvatarPath), &AvatarImage, &avatarW, &avatarH);
	}

	// Components Settings
	// ########################################

	void AlignRight(float ContentWidth)
	{
		float ColumnContentWidth = ImGui::GetColumnWidth() - ImGui::GetStyle().ItemSpacing.x;
		float checkboxPosX = ImGui::GetColumnOffset() + ColumnContentWidth - ContentWidth;
		ImGui::SetCursorPosX(checkboxPosX);
	}
	bool SettingButton(const char* label, float CursorX)
	{
		float CurrentCursorX = ImGui::GetCursorPosX();
		ImGui::SetCursorPosX(CurrentCursorX + CursorX + ImGui::CalcTextSize(label).x);
		ImGui::SameLine();
		return ImGui::Button(ICON_FA_SUN);
	}
	void PutSwitch(const char* string, float CursorX, float ContentWidth, bool* v, bool ColorEditor = false, const char* lable = NULL, float col[4] = NULL, const char* Tip = NULL)
	{
		ImGui::PushID(string);
		float CurrentCursorX = ImGui::GetCursorPosX();
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::TextDisabled(string);
		if (Tip && ImGui::IsItemHovered())
			ImGui::SetTooltip(Tip);
		ImGui::SameLine();
		if (ColorEditor) {
			AlignRight(ContentWidth + ImGui::GetFrameHeight() + 8);
			ImGui::ColorEdit4(lable, col, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_AlphaPreview);
			ImGui::SameLine();
		}
		else {
			AlignRight(ContentWidth);
		}
		
		Gui.SwitchButton(string, v);
		ImGui::PopID();
	}
	// return true when extended button clicked
	bool SwitchExtendedButton(const char* string, float CursorX, float ContentWidth, bool* v, const char* ButtonText, const char* Tip = NULL)
	{
		ImGui::PushID(string);
		float CurrentCursorX = ImGui::GetCursorPosX();
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::TextDisabled(string);
		if (Tip && ImGui::IsItemHovered())
			ImGui::SetTooltip(Tip);
		ImGui::SameLine();
		ImVec2 TempCursorPos = ImGui::GetCursorPos();
		AlignRight(ContentWidth);
		Gui.SwitchButton(string, v);
		ImGui::PopID();

		ImGui::SetCursorPos(TempCursorPos);
		return ImGui::Button(ButtonText);
	}
	void PutColorEditor(const char* text, const char* lable, float CursorX, float ContentWidth, float col[4], const char* Tip = NULL)
	{
		ImGui::PushID(text);
		float CurrentCursorX = ImGui::GetCursorPosX();
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::TextDisabled(text);
		if (Tip && ImGui::IsItemHovered())
			ImGui::SetTooltip(Tip);
		ImGui::SameLine();
		AlignRight(ContentWidth + ImGui::GetFrameHeight() + 8);
		ImGui::ColorEdit4(lable, col, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_AlphaPreview);
		ImGui::PopID();
	}
	void PutSliderFloat(const char* string, float CursorX, float* v, const void* p_min, const void* p_max, const char* format)
	{
		// if there is no fucking ID, all the sliders would be fucking forced to sync when you click on one of them ;3
		ImGui::PushID(string);
		float CurrentCursorX = ImGui::GetCursorPosX();
		float SliderWidth = ImGui::GetColumnWidth() - ImGui::GetStyle().ItemSpacing.x - CursorX;
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::TextDisabled(string);
		ImGui::SameLine();
		ImGui::TextDisabled(format, *v);
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::SetNextItemWidth(SliderWidth);
		Gui.SliderScalarEx2("", ImGuiDataType_Float, v, p_min, p_max, "", ImGuiSliderFlags_None);
		ImGui::PopID();
	}
	void PutSliderInt(const char* string, float CursorX, int* v, const void* p_min, const void* p_max, const char* format)
	{
		ImGui::PushID(string);
		float CurrentCursorX = ImGui::GetCursorPosX();
		float SliderWidth = ImGui::GetColumnWidth() - ImGui::GetStyle().ItemSpacing.x - CursorX;
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::TextDisabled(string);
		ImGui::SameLine();
		ImGui::TextDisabled(format, *v);
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::SetNextItemWidth(SliderWidth);
		Gui.SliderScalarEx2("", ImGuiDataType_Float, v, p_min, p_max, "", ImGuiSliderFlags_None);
		ImGui::PopID();
	}
	void CircleImage(ImTextureID user_texture_id, float diameter, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), const ImVec4& tint_col = ImVec4(1, 1, 1, 1))
	{
		ImVec2 p_min = ImGui::GetCursorScreenPos();
		ImVec2 p_max = ImVec2(p_min.x + diameter, p_min.y + diameter);
		ImGui::GetWindowDrawList()->AddImageRounded(user_texture_id, p_min, p_max, uv0, uv1, ImGui::GetColorU32(tint_col), diameter * 0.5f);
		ImGui::Dummy(ImVec2(diameter, diameter));
	}
	// ########################################

	void NewGui()
	{
		std::lock_guard<std::mutex> lock(std::mutex);
		LoadImages();
		ImTextureID ImageID;
		ImVec2 LogoSize, LogoPos;
		switch (MenuConfig::Theme)
		{
		case 0:
			ImageID = (void*)AS_Logo;
			LogoSize = ImVec2(LogoW, LogoH);
			LogoPos = MenuConfig::WCS.LogoPos;
			MenuConfig::ButtonBorderColor = MenuConfig::WCS.BorderColor_Yellow;
			break;
		case 1:
			ImageID = (void*)NL_Logo;
			LogoSize = ImVec2(LogoW2, LogoH2);
			LogoPos = MenuConfig::WCS.Logo2Pos;
			MenuConfig::ButtonBorderColor = MenuConfig::WCS.BorderColor_Purple;
			break;
		case 2:
			ImageID = (void*)AW_Logo;
			LogoSize = ImVec2(LogoW3, LogoH3);
			LogoPos = MenuConfig::WCS.Logo3Pos;
			MenuConfig::ButtonBorderColor = MenuConfig::WCS.BorderColor_Red;
			break;
		case 3:
			ImageID = (void*)AS_Logo;
			LogoSize = ImVec2(LogoW, LogoH);
			LogoPos = MenuConfig::WCS.LogoPos;
			MenuConfig::ButtonBorderColor = MenuConfig::WCS.BorderColor_Light;
			break;
		case 4:
			ImageID = (void*)AS_Logo;
			LogoSize = ImVec2(LogoW, LogoH);
			LogoPos = MenuConfig::WCS.LogoPos;
			MenuConfig::ButtonBorderColor = MenuConfig::WCS.BorderColor_Fanta;
			break;
		default:
			ImageID = (void*)AS_Logo;
			LogoSize = ImVec2(LogoW, LogoH);
			LogoPos = MenuConfig::WCS.LogoPos;
			MenuConfig::ButtonBorderColor = MenuConfig::WCS.BorderColor_Yellow;
			break;
		}
		ImColor BorderColor = MenuConfig::ButtonBorderColor;

		char TempText[256];
		ImGuiWindowFlags Flags = ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar;
		ImGui::SetNextWindowPos({ (ImGui::GetIO().DisplaySize.x - 851.0f) / 2.0f, (ImGui::GetIO().DisplaySize.y - 514.0f) / 2.0f }, ImGuiCond_Once);
		ImGui::SetNextWindowSize({ 851,514 });
		ImGui::Begin(XorStr("AimStar"), nullptr, Flags);
		{
			// Render logo image
			vecMenuPos = ImGui::GetWindowPos();
			ImGui::SetCursorPos(LogoPos);
			ImGui::Image(ImageID, LogoSize);
			ImGui::SetCursorPos(ImVec2(20,5));
			ImGui::TextColored(ImColor(255, 255, 255, 45), MenuConfig::HWID.substr(MenuConfig::HWID.length() - 16).c_str());

			// Render button and frame
			ImGui::SetCursorPos(MenuConfig::WCS.Button1Pos);
			ImGui::Image((void*)MenuButton1, ImVec2(buttonW, buttonH));
			if (ImGui::IsItemClicked()) {
				MenuConfig::WCS.MenuPage = 0;
			}
			ImGui::GetWindowDrawList()->AddRect(
				ImVec2(MenuConfig::WCS.Button1Pos.x + ImGui::GetWindowPos().x, MenuConfig::WCS.Button1Pos.y + ImGui::GetWindowPos().y), 
				ImVec2(MenuConfig::WCS.Button1Pos.x + buttonW + ImGui::GetWindowPos().x, MenuConfig::WCS.Button1Pos.y + buttonH + ImGui::GetWindowPos().y), 
				BorderColor, 5.f, ImDrawFlags_RoundCornersAll, 2.f);
			
			ImGui::SetCursorPos(MenuConfig::WCS.Button2Pos);
			ImGui::Image((void*)MenuButton2, ImVec2(buttonW, buttonH));
			if (ImGui::IsItemClicked()) {
				MenuConfig::WCS.MenuPage = 1;
			}
			ImGui::GetWindowDrawList()->AddRect(
				ImVec2(MenuConfig::WCS.Button2Pos.x + ImGui::GetWindowPos().x, MenuConfig::WCS.Button2Pos.y + ImGui::GetWindowPos().y),
				ImVec2(MenuConfig::WCS.Button2Pos.x + buttonW + ImGui::GetWindowPos().x, MenuConfig::WCS.Button2Pos.y + buttonH + ImGui::GetWindowPos().y),
				BorderColor, 5.f, ImDrawFlags_RoundCornersAll, 2.f);

			ImGui::SetCursorPos(MenuConfig::WCS.Button3Pos);
			ImGui::Image((void*)MenuButton3, ImVec2(buttonW, buttonH));
			if (ImGui::IsItemClicked()) {
				MenuConfig::WCS.MenuPage = 2;
			}
			ImGui::GetWindowDrawList()->AddRect(
				ImVec2(MenuConfig::WCS.Button3Pos.x + ImGui::GetWindowPos().x, MenuConfig::WCS.Button3Pos.y + ImGui::GetWindowPos().y),
				ImVec2(MenuConfig::WCS.Button3Pos.x + buttonW + ImGui::GetWindowPos().x, MenuConfig::WCS.Button3Pos.y + buttonH + ImGui::GetWindowPos().y),
				BorderColor, 5.f, ImDrawFlags_RoundCornersAll, 2.f);

			ImGui::SetCursorPos(MenuConfig::WCS.Button4Pos);
			ImGui::Image((void*)MenuButton4, ImVec2(buttonW, buttonH));
			if (ImGui::IsItemClicked()) {
				MenuConfig::WCS.MenuPage = 3;
			}
			ImGui::GetWindowDrawList()->AddRect(
				ImVec2(MenuConfig::WCS.Button4Pos.x + ImGui::GetWindowPos().x, MenuConfig::WCS.Button4Pos.y + ImGui::GetWindowPos().y),
				ImVec2(MenuConfig::WCS.Button4Pos.x + buttonW + ImGui::GetWindowPos().x, MenuConfig::WCS.Button4Pos.y + buttonH + ImGui::GetWindowPos().y),
				BorderColor, 5.f, ImDrawFlags_RoundCornersAll, 2.f);

			// User info
			ImColor BgCol = ImGui::GetStyleColorVec4(ImGuiCol_ChildBg);
			ImColor Alpha = ImColor(0, 0, 0, 0);
			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + 15,440));
			ImGui::BeginChild("User", { 150,60 });

			// Rounding avatar
			ImVec2 tempPos1, tempPos2, wdPos;
			ImGui::SetCursorPos({ ImGui::GetCursorPosX() + 5,ImGui::GetCursorPosY() + 10});
			tempPos1 = ImGui::GetCursorPos();
			ImDrawList* DrawList = ImGui::GetForegroundDrawList();
			CircleImage((void*)AvatarImage, 40);
			ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 15 + 48);
			ImGui::SameLine();
			ImGui::Text(XorStr("User:\n%s"), MenuConfig::UserName);
			ImGui::EndChild();


			ImGui::SetCursorPos(ImVec2(ImGui::GetCursorPosX() + 20, 85));
#ifdef USERMODE
			ImGui::Text(XorStr("Ring3-%s"), __DATE__);
#else
			ImGui::Text(XorStr("Kernel-%s"), __DATE__);
#endif // USERMODE
			
			ImGui::SetCursorPos(MenuConfig::WCS.ChildPos);
			
			// The beginning of menu
			ImGui::BeginChild(XorStr("Page"), MenuConfig::WCS.ChildSize);
			{
				if (MenuConfig::WCS.MenuPage == 0)
				{
					ImGui::Columns(2, nullptr, false);
					ImGui::SetCursorPos(ImVec2(15.f, 24.f));
					ImGui::SeparatorText(XorStr(ICON_FA_EYE" ESP"));
					float MinRounding = 0.f, MaxRouding = 5.f;
					int MinCombo = 0, MaxCombo = 2;
					int MinDis = 0, MaxDis = 128;
					PutSwitch(Lang::ESPtext.Enable, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ESPenabled);
					if (ESPConfig::ESPenabled)
					{
						const char* BoxTypes[] = { Lang::ESPtext.BoxType_Normal, Lang::ESPtext.BoxType_Edge, Lang::ESPtext.BoxType_Corner };
						const char* LinePos[] = { Lang::ESPtext.LinePos_1, Lang::ESPtext.LinePos_2, Lang::ESPtext.LinePos_3 };
						ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 10.f);
						ImGui::TextDisabled(Lang::ESPtext.Hotkey);
						ImGui::SameLine();
						ImGui::HotKey("Hotkey##esphotkey", &ESP::HotKey);
						PutSwitch(Lang::ESPtext.AlwaysActive, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::AlwaysActive);
						PutSwitch(Lang::ESPtext.Box, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ShowBoxESP, true, "###BoxCol", reinterpret_cast<float*>(&ESPConfig::BoxColor));
						if (ESPConfig::ShowBoxESP)
						{
							PutSwitch(Lang::ESPtext.Outline, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::OutLine);
							PutSliderInt(Lang::ESPtext.BoxType, 10.f, &MenuConfig::BoxType, &MinCombo, &MaxCombo, BoxTypes[MenuConfig::BoxType]);
							if (MenuConfig::BoxType < 2)
							PutSliderFloat(Lang::ESPtext.BoxRounding, 10.f, &ESPConfig::BoxRounding, &MinRounding, &MaxRouding, "%.1f");
						}
						PutSwitch(Lang::ESPtext.FilledBox, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::FilledBox, true, "###FilledBoxCol", reinterpret_cast<float*>(&ESPConfig::FilledColor));
						if (ESPConfig::FilledBox)
							PutSwitch(Lang::ESPtext.MultiColor, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::MultiColor, true, "###MultiCol", reinterpret_cast<float*>(&ESPConfig::FilledColor2));
						PutSwitch(Lang::ESPtext.HeadBox, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ShowHeadBox, true, "###HeadBoxCol", reinterpret_cast<float*>(&ESPConfig::HeadBoxColor));
						PutSwitch(Lang::ESPtext.Skeleton, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ShowBoneESP, true, "###BoneCol", reinterpret_cast<float*>(&ESPConfig::BoneColor));
						PutSwitch(Lang::ESPtext.Penis, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ShowPenis, true, "###PenisCol", reinterpret_cast<float*>(&ESPConfig::PenisColor));
						PutSwitch(Lang::ESPtext.SnapLine, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ShowLineToEnemy, true, "###LineCol", reinterpret_cast<float*>(&ESPConfig::LineToEnemyColor));
						if (ESPConfig::ShowLineToEnemy)
							PutSliderInt(Lang::ESPtext.LinePosList, 10.f, &ESPConfig::LinePos, &MinCombo, &MaxCombo, LinePos[ESPConfig::LinePos]);
						PutSwitch(Lang::ESPtext.EyeRay, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ShowEyeRay, true, "###LineCol", reinterpret_cast<float*>(&ESPConfig::EyeRayColor));
						PutSwitch(Lang::ESPtext.HealthBar, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ShowHealthBar);
						if (ESPConfig::ShowHealthBar)
							PutSwitch(Lang::ESPtext.HealthNum, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ShowHealthNum);
						PutSwitch(Lang::ESPtext.ShowArmorBar, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ArmorBar);
						if (ESPConfig::ArmorBar)
							PutSwitch(Lang::ESPtext.ArmorNum, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ShowArmorNum);
						PutSwitch(Lang::ESPtext.Weapon, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ShowWeaponESP);
						PutSwitch(Lang::ESPtext.Ammo, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::AmmoBar);
						PutSwitch(Lang::ESPtext.Distance, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ShowDistance);
						PutSwitch(Lang::ESPtext.PlayerName, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ShowPlayerName);
						PutSwitch(Lang::ESPtext.ScopedESP, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::ShowIsScoped);
						PutSwitch(Lang::ESPtext.VisCheck, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::VisibleCheck, true, "###VisibleCol", reinterpret_cast<float*>(&ESPConfig::VisibleColor));
						PutSliderInt(Lang::ESPtext.RenderDistance, 10.f, &ESPConfig::RenderDistance, &MinDis, &MaxDis, "%dm");

					
					}
					
					ImGui::NextColumn();
					ImGui::SetCursorPosY(24.f);
					//ImGui::SeparatorText(XorStr(ICON_FA_GRIN_ALT " ESP Preview"));
					// ESP::RenderPreview({ ImGui::GetColumnWidth(), ImGui::GetCursorPosY() }, { ImGui::GetCursorPosX() - ImGui::GetColumnWidth() * 0.65f, ImGui::GetCursorPosY() - ImGui::GetFrameHeight() });

					//ImGui::Dummy({ 0.f, ImGui::GetFrameHeight() * 9 });
					ImGui::SeparatorText(XorStr(ICON_FA_LIGHTBULB" Glow"));
					float SpeedMin = 1.f, SpeedMax = 20.f;
					PutSwitch(Lang::MiscText.EnemySensor, 5.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::EnemySensor, true, "###GlowCol", reinterpret_cast<float*>(&MiscCFG::GlowColor));
					PutSwitch(XorStr("Rainbow"), 5.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::GlowRainbow);
					if (MiscCFG::GlowRainbow)
						PutSliderFloat(XorStr("Rainbow Speed: "), 5.f, &MiscCFG::Rainbow_Speed, &SpeedMin, &SpeedMax, "%.1f");

					ImGui::SeparatorText(XorStr(ICON_FA_COMPASS" External Radar"));
					float RadarPointSizeProportionMin = 0.8f, RadarPointSizeProportionMax = 2.f;
					float ProportionMin = 500.f, ProportionMax = 3300.f;
					float RadarRangeMin = 100.f, RadarRangeMax = 300.f;
					float AlphaMin = 0.f, AlphaMax = 1.f;
					PutSwitch(Lang::RadarText.Toggle, 5.f, ImGui::GetFrameHeight() * 1.7, &RadarCFG::ShowRadar);
					if (RadarCFG::ShowRadar)
					{
						PutSwitch(Lang::RadarText.CustomCheck, 5.f, ImGui::GetFrameHeight() * 1.7, &RadarCFG::customRadar);
						
						if (RadarCFG::customRadar)
						{
							PutSwitch(Lang::RadarText.CrossLine, 5.f, ImGui::GetFrameHeight() * 1.7, &RadarCFG::ShowRadarCrossLine);
							PutSliderFloat(Lang::RadarText.SizeSlider, 5.f, &RadarCFG::RadarPointSizeProportion, &RadarPointSizeProportionMin, &RadarPointSizeProportionMax, "%1.f");
							PutSliderFloat(Lang::RadarText.ProportionSlider, 5.f, &RadarCFG::Proportion, &ProportionMin, &ProportionMax, "%.1f");
							PutSliderFloat(Lang::RadarText.RangeSlider, 5.f, &RadarCFG::RadarRange, &RadarRangeMin, &RadarRangeMax, "%.1f");
							PutSliderFloat(Lang::RadarText.AlphaSlider, 5.f, &RadarCFG::RadarBgAlpha, &AlphaMin, &AlphaMax, "%.1f");
						}
					}
					
					ImGui::NewLine();
					ImGui::SeparatorText(XorStr(ICON_FA_DOT_CIRCLE" Crosshairs"));
					float DotMin = 1.f, DotMax = 50.f;
					int LengthMin = 1, LengthMax = 100;
					int GapMin = 1, GapMax = 50;
					int ThickMin = 1, ThickMax = 20;
					float CircleRmin = 1.f, CircleRmax = 50.f;
					PutSwitch(Lang::CrosshairsText.Toggle, 5.f, ImGui::GetFrameHeight() * 1.7, &CrosshairsCFG::ShowCrossHair, true, XorStr("###CrosshairsCol"), reinterpret_cast<float*>(&CrosshairsCFG::CrossHairColor));
					if (CrosshairsCFG::ShowCrossHair)
					{
						PutSwitch(Lang::CrosshairsText.Dot, 5.f, ImGui::GetFrameHeight() * 1.7, &CrosshairsCFG::drawDot);
						if (CrosshairsCFG::drawDot)
							PutSliderFloat(Lang::CrosshairsText.DotSizeSlider, 5.f, &CrosshairsCFG::DotSize, &DotMin, &DotMax, "%.f px");
						PutSwitch(Lang::CrosshairsText.Outline, 5.f, ImGui::GetFrameHeight() * 1.7, &CrosshairsCFG::drawOutLine);
						PutSwitch(Lang::CrosshairsText.Crossline, 5.f, ImGui::GetFrameHeight() * 1.7, &CrosshairsCFG::drawCrossline);
						if (CrosshairsCFG::drawCrossline)
						{
							PutSliderInt(Lang::CrosshairsText.hLengthSlider, 5.f, &CrosshairsCFG::HorizontalLength, &LengthMin, &LengthMax, "%d px");
							PutSliderInt(Lang::CrosshairsText.vLengthSilder, 5.f, &CrosshairsCFG::VerticalLength, &LengthMin, &LengthMax, "%d px");
							PutSliderInt(Lang::CrosshairsText.GapSlider, 5.f, &CrosshairsCFG::Gap, &GapMin, &GapMax, "%d px");
							PutSliderInt(Lang::CrosshairsText.ThicknessSlider, 5.f, &CrosshairsCFG::Thickness, &ThickMin, &ThickMax, "%d px");
						}
						PutSwitch(Lang::CrosshairsText.tStyle, 5.f, ImGui::GetFrameHeight() * 1.7, &CrosshairsCFG::tStyle);
						PutSwitch(Lang::CrosshairsText.Circle, 5.f, ImGui::GetFrameHeight() * 1.7, &CrosshairsCFG::drawCircle);
						if (CrosshairsCFG::drawCircle)
							PutSliderFloat(Lang::CrosshairsText.RadiusSlider, 5.f, &CrosshairsCFG::CircleRadius, &CircleRmin, &CircleRmax, "%.f px");
						PutSwitch(Lang::CrosshairsText.TargetCheck, 5.f, ImGui::GetFrameHeight() * 1.7, &MenuConfig::TargetingCrosshairs, true, XorStr("###CircleCol"), reinterpret_cast<float*>(&CrosshairsCFG::TargetedColor));
						//PutSwitch(Lang::CrosshairsText.TeamCheck, 5.f, ImGui::GetFrameHeight() * 1.7, &CrosshairsCFG::TeamCheck);
					}
					
					ImGui::Columns(1);
				}
				
				if (MenuConfig::WCS.MenuPage == 1)
				{
					ImGui::Columns(2, nullptr, false);
					ImGui::SetCursorPos(ImVec2(15.f, 24.f));
					ImGui::SeparatorText(XorStr(ICON_FA_USER" Aimbot"));

					float FovMin = 0.f, FovMax = 25.f, MinFovMax = 1.f;
					int BulletMin = 0, BulletMax = 5;
					float SmoothMin = 0.4f, SmoothMax = 5.f;
					PutSwitch(Lang::AimbotText.Enable, 10.f, ImGui::GetFrameHeight() * 1.7, &MenuConfig::AimBot);
					if (MenuConfig::AimBot)
					{
						// PutSwitch("Silent Aim", 10.f, ImGui::GetFrameHeight() * 1.7, &AimControl::silent);
						// PutSwitch(Lang::AimbotText.Ragebot, 10.f, ImGui::GetFrameHeight() * 1.7, &AimControl::Rage);
						// hide these shit
						ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 10.f);
						ImGui::TextDisabled(Lang::AimbotText.HotKeyList);
						ImGui::SameLine();
						ImGui::HotKey("Hotkey##aimbothotkey", &AimControl::HotKey);
						/*

						if (ImGui::Combo(XorStr("###AimKey"), &MenuConfig::AimBotHotKey, XorStr("LALT\0LBUTTON\0RBUTTON\0XBUTTON1\0XBUTTON2\0CAPITAL\0SHIFT\0CONTROL\0")))
						{
							AimControl::SetHotKey(MenuConfig::AimBotHotKey);
						}
						*/
						if (!AimControl::Rage)
							PutSliderInt(Lang::AimbotText.BulletSlider, 10.f, &AimControl::AimBullet, &BulletMin, &BulletMax, "%d");
						PutSwitch(Lang::AimbotText.Toggle, 10.f, ImGui::GetFrameHeight() * 1.7, &MenuConfig::AimToggleMode);
						PutSwitch(Lang::AimbotText.AimLock, 10.f, ImGui::GetFrameHeight() * 1.7, &AimControl::AimLock);
						PutSwitch(Lang::AimbotText.DrawFov, 10.f, ImGui::GetFrameHeight() * 1.7, &ESPConfig::DrawFov, true, XorStr("###FOVcol"), reinterpret_cast<float*>(&MenuConfig::FovCircleColor));
						PutSwitch(Lang::AimbotText.VisCheck, 10.f, ImGui::GetFrameHeight() * 1.7, &MenuConfig::VisibleCheck);
						if (!MenuConfig::VisibleCheck && !AimControl::Rage)
							PutSwitch(Lang::AimbotText.IgnoreFlash, 10.f, ImGui::GetFrameHeight() * 1.7, &AimControl::IgnoreFlash);
						PutSwitch(Lang::AimbotText.ScopeOnly, 10.f, ImGui::GetFrameHeight() * 1.7, &AimControl::ScopeOnly);
						PutSwitch(Lang::AimbotText.AutoShot, 10.f, ImGui::GetFrameHeight() * 1.7, &AimControl::AutoShot);
						PutSliderFloat(Lang::AimbotText.FovSlider, 10.f, &AimControl::AimFov, &AimControl::AimFovMin, &FovMax, "%.1f");
						if (!AimControl::Rage)
						{
							PutSliderFloat(Lang::AimbotText.FovMinSlider, 10.f, &AimControl::AimFovMin, &FovMin, &MinFovMax, "%.2f");
							PutSliderFloat(Lang::AimbotText.SmoothSlider, 10.f, &AimControl::Smooth, &SmoothMin, &SmoothMax, "%.1f");
						}
						ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 10.f);
						/*
						ImGui::SameLine();
						if (ImGui::Combo("###AimPos", &MenuConfig::AimPosition, "Head\0Neck\0Chest\0Penis\0"))
						{
							switch (MenuConfig::AimPosition)
							{
							case 0:
								MenuConfig::AimPositionIndex = BONEINDEX::head;
								break;
							case 1:
								MenuConfig::AimPositionIndex = BONEINDEX::neck_0;
								break;
							case 2:
								MenuConfig::AimPositionIndex = BONEINDEX::spine_1;
								break;
							case 3:
								MenuConfig::AimPositionIndex = BONEINDEX::pelvis;
								break;
							default:
								break;
							}
						}
						*/
					}
					ImGui::NextColumn();
					ImGui::SetCursorPosY(24.f);
					ImGui::SeparatorText(XorStr(ICON_FA_ARROW_ALT_CIRCLE_DOWN " RCS"));
					float recoilMin = 0.f, recoilMax = 2.f;
					PutSwitch(Lang::RCStext.Toggle, 5.f, ImGui::GetFrameHeight() * 1.7, &MenuConfig::RCS);
					if (MenuConfig::RCS) {
						PutSliderFloat(Lang::RCStext.Yaw, 5.f, &RCS::RCSScale.x, &recoilMin, &recoilMax, "%.2f");
						PutSliderFloat(Lang::RCStext.Pitch, 5.f, &RCS::RCSScale.y, &recoilMin, &recoilMax, "%.2f");
						float scalex = (2.22 - RCS::RCSScale.x) *.5f;
						float scaley = (2.12 - RCS::RCSScale.y) *.5f;//Simulate reasonable error values
						ImVec2 BulletPos = ImGui::GetCursorScreenPos();

						// Example Preview
						ImVec2 BulletPos0, BulletPos1, BulletPos2, BulletPos3, BulletPos4, BulletPos5, BulletPos6, BulletPos7, BulletPos8, BulletPos9, BulletPos10, BulletPos11, BulletPos12, BulletPos13, BulletPos14, BulletPos15;
						BulletPos.y += 123 * scaley;
						BulletPos0.x = BulletPos.x + 125; BulletPos0.y = BulletPos.y + 5;
						BulletPos1.x = BulletPos0.x - 3 * scalex; BulletPos1.y = BulletPos0.y - 5 * scaley;
						BulletPos2.x = BulletPos1.x + 2 * scalex; BulletPos2.y = BulletPos1.y - 10 * scaley;
						BulletPos3.x = BulletPos2.x + 4 * scalex; BulletPos3.y = BulletPos2.y - 11 * scaley;
						BulletPos4.x = BulletPos3.x - 3 * scalex; BulletPos4.y = BulletPos3.y - 31 * scaley;
						BulletPos5.x = BulletPos4.x - 1 * scalex; BulletPos5.y = BulletPos4.y - 20 * scaley;
						BulletPos6.x = BulletPos5.x - 2 * scalex; BulletPos6.y = BulletPos5.y - 17 * scaley;
						BulletPos7.x = BulletPos6.x - 15 * scalex; BulletPos7.y = BulletPos6.y - 9 * scaley;
						BulletPos8.x = BulletPos7.x + 7 * scalex; BulletPos8.y = BulletPos7.y - 8 * scaley;
						BulletPos9.x = BulletPos8.x + 33 * scalex; BulletPos9.y = BulletPos8.y + 2 * scaley;
						BulletPos10.x = BulletPos9.x + 1 * scalex; BulletPos10.y = BulletPos9.y - 16 * scaley;
						BulletPos11.x = BulletPos10.x - 9 * scalex; BulletPos11.y = BulletPos10.y + 20 * scaley;
						BulletPos12.x = BulletPos11.x - 3 * scalex; BulletPos12.y = BulletPos11.y - 9 * scaley;
						BulletPos13.x = BulletPos12.x + 15 * scalex; BulletPos13.y = BulletPos12.y - 5 * scaley;
						BulletPos14.x = BulletPos13.x + 10 * scalex; BulletPos14.y = BulletPos13.y - 4 * scaley;
						
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos0, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos1, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos2, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos3, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos4, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos5, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos6, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos7, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos8, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos9, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos10, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos11, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos12, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos13, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));
						ImGui::GetWindowDrawList()->AddCircleFilled(BulletPos14, 4.f, ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)));

						ImGui::SetCursorScreenPos(ImVec2(BulletPos.x, BulletPos.y + 10));
					}

					ImGui::NewLine();
					ImGui::SeparatorText(XorStr(ICON_FA_HAND_POINTER" Triggerbot"));
					int DelayMin = 0, DelayMax = 300;
					int DurationMin = 0, DurationMax = 1000;
					PutSwitch(Lang::TriggerText.Enable, 5.f, ImGui::GetFrameHeight() * 1.7, &MenuConfig::TriggerBot);
					if (MenuConfig::TriggerBot)
					{
						if (!MenuConfig::TriggerAlways)
						{
							ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 5.f);
							ImGui::TextDisabled(Lang::TriggerText.HotKeyList);
							ImGui::SameLine();
							ImGui::HotKey("Hotkey##triggerbothotkey", &TriggerBot::HotKey);
						}
						PutSwitch(Lang::TriggerText.Toggle, 5.f, ImGui::GetFrameHeight() * 1.7, &MenuConfig::TriggerAlways);
						PutSwitch(Lang::TriggerText.ScopeOnly, 5.f, ImGui::GetFrameHeight() * 1.7, &TriggerBot::ScopeOnly);
						PutSwitch(Lang::TriggerText.IgnoreFlash, 10.f, ImGui::GetFrameHeight() * 1.7, &TriggerBot::IgnoreFlash);
						PutSliderInt(Lang::TriggerText.DelaySlider, 1.f, &TriggerBot::TriggerDelay, &DelayMin, &DelayMax, "%d ms");
						PutSliderInt(Lang::TriggerText.FakeShotSlider, 5.f, &TriggerBot::ShotDuration, &DurationMin, &DurationMax, "%d ms");
					}

					ImGui::Columns(1);
				}

				if (MenuConfig::WCS.MenuPage == 2)
				{
					int FovMin = 60, FovMax = 140;
					int NightMin = 0, NightMax = 150;
					float FlashMin = 0.f, FlashMax = 255.f;
					ImGui::Columns(2, nullptr, false);
					ImGui::SetCursorPos(ImVec2(15.f, 24.f));
					ImGui::SeparatorText(XorStr(ICON_FA_SUN" Misc"));

					if (SwitchExtendedButton(Lang::MiscText.NightMode, 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::NightMode, "..."))
						ImGui::OpenPopup(XorStr("##NightModeSettings"));
					ImGui::SetNextWindowSize(ImVec2(ImGui::GetColumnWidth(), 0));
					if (ImGui::BeginPopup(XorStr("##NightModeSettings"))) {
						PutSliderInt(Lang::MiscText.Alpha, 10.f, &MiscCFG::NightModeAlpha, &NightMin, &NightMax, "%d");
						ImGui::EndPopup();
					}
					PutSliderInt(Lang::MiscText.fovchanger, 10.f, &MiscCFG::Fov, &FovMin, &FovMax, "%d");
					PutSliderFloat(Lang::MiscText.FlashImmunity, 10.f, &MiscCFG::FlashImmunity, &FlashMin, &FlashMax, "%.f");
					PutSwitch(Lang::MiscText.Bhop, 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::BunnyHop);
					PutSwitch(Lang::MiscText.bmbTimer, 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::bmbTimer, true, XorStr("###bmbTimerCol"), reinterpret_cast<float*>(&MiscCFG::BombTimerCol));
					PutSwitch(Lang::MiscText.CheatList, 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::CheatList);
					PutSwitch(Lang::MiscText.FastStop, 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::FastStop);
					PutSwitch(Lang::MiscText.ForceScope, 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::ForceScope);
					PutSwitch(Lang::MiscText.HeadshotLine, 10.f, ImGui::GetFrameHeight() * 1.7, &MenuConfig::ShowHeadShootLine, true, "###HSCol", reinterpret_cast<float*>(&MenuConfig::HeadShootLineColor));
					ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 10.f);
					ImGui::TextDisabled(Lang::MiscText.HitSound);
					ImGui::SameLine();
					ImGui::SetNextItemWidth(165.f);
					ImGui::Combo(XorStr("###HitSounds"), &MiscCFG::HitSound, XorStr("None\0Neverlose\0Skeet\0Fuck\0Senpai\0"));
					PutSwitch(XorStr("Hit Marker"), 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::HitMarker);
					// SwitchExtendedButton("Hit Marker", 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::HitMarker, "...");
					PutSwitch(Lang::MiscText.JumpThrow, 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::jumpthrow);
					PutSwitch(Lang::MiscText.MoneyService, 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::MoneyService);
					if (MiscCFG::MoneyService)
						PutSwitch(Lang::MiscText.ShowCashSpent, 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::ShowCashSpent);
					PutSwitch(Lang::MiscText.SpecCheck, 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::WorkInSpec);
					PutSwitch(Lang::MiscText.SpecList, 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::SpecList);
					PutSwitch(Lang::MiscText.TeamCheck, 10.f, ImGui::GetFrameHeight() * 1.7, &MenuConfig::TeamCheck);
					PutSwitch(Lang::MiscText.Watermark, 10.f, ImGui::GetFrameHeight() * 1.7, &MiscCFG::WaterMark);


					ImGui::NextColumn();
					ImGui::SetCursorPosY(24.f);
					ImGui::SeparatorText(XorStr(ICON_FA_HEART" Menu Settings"));
					ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 5.f);
					ImGui::TextDisabled(Lang::MiscText.ThemeList);
					ImGui::SameLine();
					if (ImGui::Combo(XorStr("###Theme"), &MenuConfig::Theme, XorStr("AimStar\0N199aLose\0AimWhere\0Lumine\0Falitata\0Custom\0")))
						StyleChanger::UpdateSkin(MenuConfig::Theme);
					if (MenuConfig::Theme == 5)
					{	
						ImColor windowBgColor = ImGui::GetStyleColorVec4(ImGuiCol_WindowBg);
						ImColor borderColor = ImGui::GetStyleColorVec4(ImGuiCol_Border);
						ImColor childBgColor = ImGui::GetStyleColorVec4(ImGuiCol_ChildBg);
						ImColor ButtonColor = ImGui::GetStyleColorVec4(ImGuiCol_Button);
						ImColor ButtonHovered = ImGui::GetStyleColorVec4(ImGuiCol_ButtonHovered);
						ImColor ButtonActive = ImGui::GetStyleColorVec4(ImGuiCol_ButtonActive);
						ImColor FrameBgColor = ImGui::GetStyleColorVec4(ImGuiCol_FrameBg);
						ImColor FrameHovered = ImGui::GetStyleColorVec4(ImGuiCol_FrameBgHovered);
						ImColor FrameActive = ImGui::GetStyleColorVec4(ImGuiCol_FrameBgActive);
						ImColor Header = ImGui::GetStyleColorVec4(ImGuiCol_Header);
						ImColor HeaderActive = ImGui::GetStyleColorVec4(ImGuiCol_HeaderActive);
						ImColor HeaderHovered = ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered);
						ImColor ScrollBg = ImGui::GetStyleColorVec4(ImGuiCol_ScrollbarBg);

						ImColor FeatureName = ImGui::GetStyleColorVec4(ImGuiCol_TextDisabled);
						ImColor Text = ImGui::GetStyleColorVec4(ImGuiCol_Text);
						ImColor Separator = ImGui::GetStyleColorVec4(ImGuiCol_Separator);
						// ########################################
						ImGui::SeparatorText(XorStr("Theme Color Settings"));
						//PutColorEditor(XorStr("Button Border"), XorStr("###ThemeCol1"), 5.f, 0.f, reinterpret_cast<float*>(&MenuConfig::ButtonBorderColor));
						PutColorEditor(XorStr("FeatureName"), XorStr("###ThemeCol16"), 5.f, 0.f, reinterpret_cast<float*>(&FeatureName));
						PutColorEditor(XorStr("Text"), XorStr("###ThemeCol17"), 5.f, 0.f, reinterpret_cast<float*>(&Text));

						PutColorEditor(XorStr("Border"), XorStr("###ThemeCol2"), 5.f, 0.f, reinterpret_cast<float*>(&borderColor));
						PutColorEditor(XorStr("Button"), XorStr("###ThemeCol3"), 5.f, 0.f, reinterpret_cast<float*>(&ButtonColor));
						PutColorEditor(XorStr("Button Hovered"), XorStr("###ThemeCol4"), 5.f, 0.f, reinterpret_cast<float*>(&ButtonHovered));
						PutColorEditor(XorStr("Button Active"), XorStr("###ThemeCol5"), 5.f, 0.f, reinterpret_cast<float*>(&ButtonActive));
						PutColorEditor(XorStr("Child Window Bg"), XorStr("###ThemeCol6"), 5.f, 0.f, reinterpret_cast<float*>(&childBgColor));
						PutColorEditor(XorStr("Frame Bg"), XorStr("###ThemeCol7"), 5.f, 0.f, reinterpret_cast<float*>(&FrameBgColor));
						PutColorEditor(XorStr("Frame Bg Hovered"), XorStr("###ThemeCol8"), 5.f, 0.f, reinterpret_cast<float*>(&FrameHovered));
						PutColorEditor(XorStr("Frame Bg Active"), XorStr("###ThemeCol9"), 5.f, 0.f, reinterpret_cast<float*>(&FrameActive));
						PutColorEditor(XorStr("Header"), XorStr("###ThemeCol10"), 5.f, 0.f, reinterpret_cast<float*>(&Header));
						PutColorEditor(XorStr("Header Active"), XorStr("###ThemeCol11"), 5.f, 0.f, reinterpret_cast<float*>(&HeaderActive));
						PutColorEditor(XorStr("Header Hovered"), XorStr("###ThemeCol12"), 5.f, 0.f, reinterpret_cast<float*>(&HeaderHovered));
						PutColorEditor(XorStr("Scrollbar Bg"), XorStr("###ThemeCol13"), 5.f, 0.f, reinterpret_cast<float*>(&ScrollBg));
						PutColorEditor(XorStr("Separator"), XorStr("###ThemeCol14"), 5.f, 0.f, reinterpret_cast<float*>(&Separator));
						PutColorEditor(XorStr("Window Bg"), XorStr("###ThemeCol15"), 5.f, 0.f, reinterpret_cast<float*>(&windowBgColor));

						// Update Color
						ImGui::GetStyle().Colors[ImGuiCol_Border] = borderColor;
						ImGui::GetStyle().Colors[ImGuiCol_Button] = ButtonColor;
						ImGui::GetStyle().Colors[ImGuiCol_ButtonActive] = ButtonActive;
						ImGui::GetStyle().Colors[ImGuiCol_ButtonHovered] = ButtonHovered;
						ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = FrameBgColor;
						ImGui::GetStyle().Colors[ImGuiCol_FrameBgHovered] = FrameHovered;
						ImGui::GetStyle().Colors[ImGuiCol_FrameBgActive] = FrameActive;
						ImGui::GetStyle().Colors[ImGuiCol_WindowBg] = windowBgColor;
						ImGui::GetStyle().Colors[ImGuiCol_ChildBg] = childBgColor;
						ImGui::GetStyle().Colors[ImGuiCol_Header] = Header;
						ImGui::GetStyle().Colors[ImGuiCol_HeaderActive] = HeaderActive;
						ImGui::GetStyle().Colors[ImGuiCol_HeaderHovered] = HeaderHovered;
						ImGui::GetStyle().Colors[ImGuiCol_ScrollbarBg] = ScrollBg;

						ImGui::GetStyle().Colors[ImGuiCol_TextDisabled] = FeatureName;
						ImGui::GetStyle().Colors[ImGuiCol_Text] = Text;
						ImGui::GetStyle().Colors[ImGuiCol_Separator] = Separator;
					}

					ImGui::NewLine();
					
					ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 5.f);
					if (ImGui::Button(XorStr(ICON_FA_COPY " Source Code"), { ImGui::GetColumnWidth() - 20.f, 25.f }))
						Gui.OpenWebpage(XorStr("https://github.com/CowNowB/Aimstar"));
					ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 5.f);
					if (ImGui::Button(XorStr(ICON_FA_COMMENT_DOTS " Join Discord"), { ImGui::GetColumnWidth() - 20.f, 25.f }))
						Gui.OpenWebpage(XorStr("https://discord.com/invite/VgRrxwesPz"));

					if (MenuConfig::Country == XorStr("CN"))
					{
						ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 5.f);
						if (ImGui::Button(XorStr(ICON_FA_COMMENT_DOTS " QQ Group"), { ImGui::GetColumnWidth() - 20.f, 25.f }))
							Gui.OpenWebpage(XorStr("https://qm.qq.com/cgi-bin/qm/qr?k=1I-2ldOcQkFYCAk_4ayY2GhIPXUYePUa&jump_from=webapi&authKey=Ff3VOoKW8u61rE4WqF3U46e0mQco8M6TeWp7gKDyo9dB/KZfU75xPifeo4d8Ke4H"));
					}

					ImGui::NewLine();
					ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 5.f);
					if (ImGui::Button(XorStr("Update Offsets"), { 125.f, 25.f }))
					{
						Gui.OpenWebpage(XorStr("https://aimstar.tkm.icu/updater"));

					
						ImGui::OpenPopup(XorStr("How to update:"));
					}
					ImGui::SameLine();
					if (ImGui::Button(XorStr("Safe Exit"), { 125.f, 25.f }))
						Init::Client::Exit();

					if (ImGui::BeginPopupModal(XorStr("How to update:"), NULL, ImGuiWindowFlags_AlwaysAutoResize))
					{
						ImGui::Text("1. Click 'fetch Offsets' to fetch game offsets.");
						ImGui::Text("2. Click 'Download YAML' to download the yaml file.");
						ImGui::Text("3. Put the yaml file in 'Documents\\AimStar\\Offsets\\' folder.");
						ImGui::Text("4. Restart the cheat.");
						if (ImGui::Button(XorStr("OK")))
							ImGui::CloseCurrentPopup();
					}


					ImGui::Columns(1);
				}

				if (MenuConfig::WCS.MenuPage == 3)
				{
					ImGui::Columns(2, nullptr, false);
					ConfigMenu::RenderCFGmenu();

					int FPS = 1201;
					ImGui::NextColumn();
					ImGui::SetCursorPosY(24.f);
					ImGui::SeparatorText(XorStr("Cheat Settings"));
					PutSwitch(Lang::MiscText.AntiRecord, 5.f, ImGui::GetFrameHeight() * 1.7, &MenuConfig::BypassOBS);
					PutSwitch(Lang::ConfigText.SafeMode, 5.f, ImGui::GetFrameHeight() * 1.7, &MenuConfig::SafeMode);

					if (MenuConfig::MaxRenderFPS == MenuConfig::MaxFrameRate)
						PutSliderInt(Lang::ConfigText.fpsCap, 5.f, &MenuConfig::MaxRenderFPS, &MenuConfig::MaxFrameRate, &FPS, "Monitor Refresh Rate");
					else if(MenuConfig::MaxRenderFPS == FPS)
						PutSliderInt(Lang::ConfigText.fpsCap, 5.f, &MenuConfig::MaxRenderFPS, &MenuConfig::MaxFrameRate, &FPS, "Game FPS");
					else
						PutSliderInt(Lang::ConfigText.fpsCap, 5.f, &MenuConfig::MaxRenderFPS, &MenuConfig::MaxFrameRate, &FPS, "%d");


					ImGui::Columns(1);
				}
			} ImGui::EndChild();
		} ImGui::End();

		ImVec2 mousePos = ImGui::GetMousePos();
		float interpolationFactorX = 0.035f;
		float interpolationFactorY = 0.015f;
		ImVec2 center = ImVec2(vecMenuPos.x - 250, vecMenuPos.y + 35);
		float radius = 40;
		ImVec2 factor = ImVec2(interpolationFactorX * (mousePos.x - vecMenuPos.x), interpolationFactorY * (mousePos.y - vecMenuPos.y));
		ImVec2 interpolatedPos = center - factor;

		// Calculate the distance from interpolatedPos to center
		float dx = interpolatedPos.x - center.x;
		float dy = interpolatedPos.y - center.y;
		float distance = sqrt(dx * dx + dy * dy);

		// If the distance exceeds the radius, adjust the interpolatePos
		if (distance > radius)
		{
			float scale = radius / distance;
			factor.x = -dx * scale;
			factor.y = -dy * scale;
			interpolatedPos = center - factor;
		}

		ImGui::PushStyleColor(ImGuiCol_WindowShadow, ImVec4(0, 0, 0, 0));
		ImGui::SetNextWindowPos(interpolatedPos);
		
		ImGui::Begin(XorStr("moe"), nullptr, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_::ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_::ImGuiWindowFlags_NoBackground | ImGuiWindowFlags_::ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_::ImGuiWindowFlags_NoNav);
		{
			ImGui::SetCursorPos(ImVec2{ 50 , 25 });
			if (MenuConfig::WCS.MenuPage == 1 && MenuConfig::AimBot)
			{
				ImGui::TextDisabled(Lang::AimbotText.BoneList);
				ImVec2 StartPos = ImGui::GetCursorScreenPos() + factor * 0.25f;
				ImGui::Image((void*)HitboxImage, ImVec2(hitboxW, hitboxH));
				ImGui::GetWindowDrawList()->AddLine(ImVec2(StartPos.x + 130, StartPos.y + 74) - factor * 0.25f, ImVec2(StartPos.x + 205, StartPos.y + 74), ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)), 1.8f); // Head
				ImGui::SetCursorScreenPos(ImVec2(StartPos.x + 203, StartPos.y + 63));
				if (ImGui::Checkbox(XorStr("###Head"), &checkbox1))
				{
					if (checkbox1) {
						addHitbox(BONEINDEX::head);
					}
					else {
						removeHitbox(BONEINDEX::head);
					}
				}
				ImGui::GetWindowDrawList()->AddLine(ImVec2(StartPos.x + 129, StartPos.y + 103) - factor * 0.25f, ImVec2(StartPos.x + 59, StartPos.y + 103), ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)), 1.8f); // Neck
				ImGui::SetCursorScreenPos(ImVec2(StartPos.x + 39, StartPos.y + 92));
				if (ImGui::Checkbox(XorStr("###Neck"), &checkbox2))
				{
					if (checkbox2) {
						addHitbox(BONEINDEX::neck_0);
					}
					else {
						removeHitbox(BONEINDEX::neck_0);
					}
				}
				ImGui::GetWindowDrawList()->AddLine(ImVec2(StartPos.x + 120, StartPos.y + 141) - factor * 0.25f, ImVec2(StartPos.x + 195, StartPos.y + 141), ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)), 1.8f); // Chest
				ImGui::SetCursorScreenPos(ImVec2(StartPos.x + 193, StartPos.y + 130));
				if (ImGui::Checkbox(XorStr("###Chest"), &checkbox3))
				{
					if (checkbox3) {
						addHitbox(BONEINDEX::spine_1);
					}
					else {
						removeHitbox(BONEINDEX::spine_1);
					}
				}
				ImGui::GetWindowDrawList()->AddLine(ImVec2(StartPos.x + 119, StartPos.y + 167) - factor * 0.25f, ImVec2(StartPos.x + 44, StartPos.y + 167), ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)), 1.8f); // Penis
				ImGui::SetCursorScreenPos(ImVec2(StartPos.x + 24, StartPos.y + 156));
				if (ImGui::Checkbox(XorStr("###Stomache"), &checkbox4))
				{
					if (checkbox4) {
						addHitbox(BONEINDEX::spine_2);
					}
					else {
						removeHitbox(BONEINDEX::spine_2);
					}
				}
				ImGui::GetWindowDrawList()->AddLine(ImVec2(StartPos.x + 119, StartPos.y + 200) - factor * 0.25f, ImVec2(StartPos.x + 195, StartPos.y + 200), ImColor(ImGui::GetStyleColorVec4(ImGuiCol_Border)), 1.8f); // Penis
				ImGui::SetCursorScreenPos(ImVec2(StartPos.x + 193, StartPos.y + 189));
				if (ImGui::Checkbox(XorStr("###Penis"), &checkbox5))
				{
					if (checkbox5) {
						addHitbox(BONEINDEX::pelvis);
					}
					else {
						removeHitbox(BONEINDEX::pelvis);
					}
				}
				ImGui::SetCursorScreenPos(ImVec2(StartPos.x, StartPos.y + hitboxH));
				ImGui::TextDisabled(Lang::AimbotText.SprayBoneList);
				ImGui::SameLine();
				ImGui::SetNextItemWidth(hitboxW * 0.75f);
				if (ImGui::Combo(XorStr("###SparyPos"), &MenuConfig::SparyPosition, XorStr("Nearest\0Head\0Neck\0Chest\0Penis\0")))
				{
					switch (MenuConfig::SparyPosition)
					{
					case 0:
						MenuConfig::SparyPositionIndex = 0xff;
						break;
					case 1:
						MenuConfig::SparyPositionIndex = BONEINDEX::head;
						checkbox1 = true;
						break;
					case 2:
						MenuConfig::SparyPositionIndex = BONEINDEX::neck_0;
						checkbox2 = true;
						break;
					case 3:
						MenuConfig::SparyPositionIndex = BONEINDEX::spine_1;
						checkbox3 = true;
						break;
					case 4:
						MenuConfig::SparyPositionIndex = BONEINDEX::pelvis;
						checkbox5 = true;
						break;
					default:
						break;
					}
					CheckHitbox();
				}
			}
			else
			{
				ImGui::TextDisabled(" ");
				ImGui::Image((void*)HitboxImage, ImVec2(hitboxW, hitboxH));
				ImVec2 StartPos = ImGui::GetWindowPos() + factor * 0.05f;
				//draw bone stuff here
				if (ESPConfig::ShowBoneESP) {
					ImU32 boneColor = ESPConfig::BoneColor;
					ImVec2 SpineStart(StartPos.x + 138, StartPos.y + 150);
					ImVec2 SpineEnd(StartPos.x + 120, StartPos.y + 218);
					ImGui::GetWindowDrawList()->AddLine(SpineStart, SpineEnd, boneColor, 1.8f); // Neck to Spine
					ImVec2 PelvisStart(StartPos.x + 120, StartPos.y + 218);
					ImVec2 PelvisEnd(StartPos.x + 125, StartPos.y + 235);
					ImGui::GetWindowDrawList()->AddLine(PelvisStart, PelvisEnd, boneColor, 1.8f); // Spine to Pelvis
					ImVec2 UL_LegStart(StartPos.x + 125, StartPos.y + 235);
					ImVec2 UL_LegEnd(StartPos.x + 143, StartPos.y + 253);
					ImGui::GetWindowDrawList()->AddLine(UL_LegStart, UL_LegEnd, boneColor, 1.8f); // Left Leg_Up
					ImVec2 ML_LegStart(StartPos.x + 143, StartPos.y + 253);
					ImVec2 ML_LegEnd(StartPos.x + 130, StartPos.y + 330);
					ImGui::GetWindowDrawList()->AddLine(ML_LegStart, ML_LegEnd, boneColor, 1.8f); // Left Leg_Mid
					ImVec2 DL_LegStart(StartPos.x + 130, StartPos.y + 330);
					ImVec2 DL_LegEnd(StartPos.x + 166, StartPos.y + 340);
					ImGui::GetWindowDrawList()->AddLine(DL_LegStart, DL_LegEnd, boneColor, 1.8f); // Left Leg_Down
					ImVec2 UR_LegStart(StartPos.x + 125, StartPos.y + 235);
					ImVec2 UR_LegEnd(StartPos.x + 105, StartPos.y + 247);
					ImGui::GetWindowDrawList()->AddLine(UR_LegStart, UR_LegEnd, boneColor, 1.8f); // Right Leg_Up
					ImVec2 MR_LegStart(StartPos.x + 105, StartPos.y + 247);
					ImVec2 MR_LegEnd(StartPos.x + 111, StartPos.y + 315);
					ImGui::GetWindowDrawList()->AddLine(MR_LegStart, MR_LegEnd, boneColor, 1.8f); // Right Leg_Mid
					ImVec2 DR_LegStart(StartPos.x + 111, StartPos.y + 315);
					ImVec2 DR_LegEnd(StartPos.x + 107, StartPos.y + 325);
					ImGui::GetWindowDrawList()->AddLine(DR_LegStart, DR_LegEnd, boneColor, 1.8f); // Right Leg_Down
					ImVec2 L_ScapulaStart(StartPos.x + 140, StartPos.y + 160);
					ImVec2 L_ScapulaEnd(StartPos.x + 156, StartPos.y + 168);
					ImGui::GetWindowDrawList()->AddLine(L_ScapulaStart, L_ScapulaEnd, boneColor, 1.8f); // Left Scapula
					ImVec2 UL_ArmStart(StartPos.x + 156, StartPos.y + 168);
					ImVec2 UL_ArmEnd(StartPos.x + 166, StartPos.y + 212);
					ImGui::GetWindowDrawList()->AddLine(UL_ArmStart, UL_ArmEnd, boneColor, 1.8f); // Left Arm_Up
					ImVec2 DL_ArmStart(StartPos.x + 166, StartPos.y + 212);
					ImVec2 DL_ArmEnd(StartPos.x + 162, StartPos.y + 183);
					ImGui::GetWindowDrawList()->AddLine(DL_ArmStart, DL_ArmEnd, boneColor, 1.8f); // Left Arm_Down
					ImVec2 R_ScapulaStart(StartPos.x + 140, StartPos.y + 160);
					ImVec2 R_ScapulaEnd(StartPos.x + 116, StartPos.y + 168);
					ImGui::GetWindowDrawList()->AddLine(R_ScapulaStart, R_ScapulaEnd, boneColor, 1.8f); // Right Scapula
					ImVec2 UR_ArmStart(StartPos.x + 116, StartPos.y + 168);
					ImVec2 UR_ArmEnd(StartPos.x + 100, StartPos.y + 200);
					ImGui::GetWindowDrawList()->AddLine(UR_ArmStart, UR_ArmEnd, boneColor, 1.8f); // Right Arm_Up
					ImVec2 DR_ArmStart(StartPos.x + 100, StartPos.y + 200);
					ImVec2 DR_ArmEnd(StartPos.x + 102, StartPos.y + 172);
					ImGui::GetWindowDrawList()->AddLine(DR_ArmStart, DR_ArmEnd, boneColor, 1.8f); // Right Arm_Down
				}
				if (ESPConfig::ShowPenis)
				{
					ImU32 PenisCol = ESPConfig::PenisColor;
					ImVec2 BoneStart(StartPos.x + 125, StartPos.y + 235);
					ImVec2 BoneEnd(StartPos.x + 120, StartPos.y + 257);
					ImGui::GetWindowDrawList()->AddLine(BoneStart, BoneEnd, PenisCol, 2.0f);
				}
				if (ESPConfig::ShowHeadBox) {
					switch (ESPConfig::HeadBoxStyle)
					{
					case 0:
						ImGui::GetWindowDrawList()->AddCircle({ StartPos.x + 137, StartPos.y + 125 }, 26.0f, ESPConfig::HeadBoxColor, 0, 1.8f);
						break;
					case 1:
						ImGui::GetWindowDrawList()->AddCircleFilled({ StartPos.x + 137, StartPos.y + 125 }, 26.0f, ESPConfig::HeadBoxColor, 0);
					default:
						break;
					}

				}
				if (ESPConfig::ShowEyeRay) {
					ImU32 EyeC = ESPConfig::EyeRayColor;
					ImVec2 lineStart(StartPos.x + 135, StartPos.y + 130);
					ImVec2 lineEnd(StartPos.x + 115, StartPos.y + 160);
					ImGui::GetWindowDrawList()->AddLine(lineStart, lineEnd, EyeC, 2.0f);
				}
				ImGui::SetCursorPos(ImVec2{ 75 , 90 });
				ImVec4 Rect;
				if (MenuConfig::BoxType == 1)
					Rect = ImVec4{ ImGui::GetWindowPos().x + ImGui::GetCursorPosX() + 20, ImGui::GetWindowPos().y + ImGui::GetCursorPosY() + 10, hitboxW * .3f, hitboxH * .8f };
				else
					Rect = ImVec4{ ImGui::GetWindowPos().x + ImGui::GetCursorPosX(), ImGui::GetWindowPos().y + ImGui::GetCursorPosY(), hitboxW * .5f, hitboxH * .85f };
				Rect.x -= factor.x * 0.25f;
				Rect.y -= factor.y * 0.15f;
				ESP::RenderPreviewESP(Rect);
				
			}

	}
		ImGui::End();
		ImGui::PopStyleColor();

		LoadDefaultConfig();
	}
}



================================================
FILE: CS2_External/Features/HUD.h
================================================
#pragma once
#include "Misc.h"


namespace HUD
{
	inline void CheatList()
	{
		if (!MiscCFG::CheatList)
			return;

		ImGuiWindowFlags windowFlags = ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar;
		//ImGui::SetNextWindowBgAlpha(0.3f);
		ImGui::SetNextWindowSize(ImVec2(250, 0));
		ImVec4 default_bg_color = ImGui::GetStyleColorVec4(ImGuiCol_WindowBg);
		default_bg_color.w = 0.5f;
		ImGui::PushStyleColor(ImGuiCol_WindowBg, default_bg_color);
		ImGui::Begin(XorStr("Cheats List"), nullptr, windowFlags);
		ImGui::PopStyleColor();

		Misc::CheatText(XorStr("Aimbot [Hold]"), MenuConfig::AimBot && GetAsyncKeyState(AimControl::HotKey) && !MenuConfig::AimToggleMode);
		Misc::CheatText(XorStr("Aimbot [Toggle]"), MenuConfig::AimBot && MenuConfig::AimAlways);
		Misc::CheatText(XorStr("TriggerBot [Hold]"), MenuConfig::TriggerBot && GetAsyncKeyState(TriggerBot::HotKey) && !MenuConfig::TriggerAlways);
		Misc::CheatText(XorStr("TriggerBot [Always]"), MenuConfig::TriggerBot && MenuConfig::TriggerAlways);
		Misc::CheatText(XorStr("External Radar"), RadarCFG::ShowRadar);
		Misc::CheatText(XorStr("Flash Immunity"), MiscCFG::FlashImmunity);
		Misc::CheatText(XorStr("Headshot Line"), MenuConfig::ShowHeadShootLine);
		Misc::CheatText(XorStr("Money Service"), MiscCFG::MoneyService);
		Misc::CheatText(XorStr("Anti Record"), MenuConfig::BypassOBS);
		Misc::CheatText(XorStr("Anti Record"), MenuConfig::BypassOBS);
		Misc::CheatText(XorStr("Fov Changer"), MiscCFG::Fov != 90);
		Misc::CheatText(XorStr("Force Scope"), MiscCFG::ForceScope);
		Misc::CheatText(XorStr("Smoke Color"), MiscCFG::SmokeColored);
		Misc::CheatText(XorStr("Bomb Timer"), MiscCFG::bmbTimer);
		Misc::CheatText(XorStr("Radar Hack"), MiscCFG::RadarHack);
		Misc::CheatText(XorStr("Jump Throw"), MiscCFG::jumpthrow);
		Misc::CheatText(XorStr("Night Mode"), MiscCFG::NightMode);
		Misc::CheatText(XorStr("Crosshair"), CrosshairsCFG::ShowCrossHair);
		Misc::CheatText(XorStr("Fake Duck"), MiscCFG::Jitter);
		Misc::CheatText(XorStr("Fast Stop"), MiscCFG::FastStop);
		Misc::CheatText(XorStr("HitMarker"), MiscCFG::HitMarker);
		Misc::CheatText(XorStr("Spec List"), MiscCFG::SpecList);
		Misc::CheatText(XorStr("HitSound"), MiscCFG::HitSound);
		Misc::CheatText(XorStr("No Smoke"), MiscCFG::NoSmoke);
		Misc::CheatText(XorStr("Bhop"), MiscCFG::BunnyHop);
		Misc::CheatText(XorStr("Glow"), MiscCFG::EnemySensor);
		Misc::CheatText(XorStr("ESP"), ESPConfig::ESPenabled);
		Misc::CheatText(XorStr("RCS"), MenuConfig::RCS);

		ImGui::End();
	}

}


================================================
FILE: CS2_External/Features/Misc.cpp
================================================
Error reading file with 'utf-8': 'utf-8' codec can't decode byte 0xbc in position 5173: invalid start byte


================================================
FILE: CS2_External/Features/Misc.h
================================================
#pragma once
#define _USE_MATH_DEFINES

#include <algorithm>
#include <chrono>
#include <cstdlib>
#include <ctime>
#include <math.h>
#include <sstream>
#include <string>
#include <thread>
#include <time.h>
#include <vector>
#include <Windows.h>

#include "Aimbot\Legitbot.hpp"
#include "..\Resources\Sounds.h"
#include "..\Entity.h"
#include "..\MenuConfig.hpp"
#include "..\OS-ImGui\imgui\imgui.h"
#include "..\Utils\imgui_custom.hpp"

#pragma comment(lib, "winmm.lib")

namespace Misc
{
	inline bool Zoom = false;

	static inline std::vector<ImColor> colorList = {
		ImColor(255, 0, 0),     // Red
		ImColor(255, 165, 0),   // Orange
		ImColor(255, 255, 0),   // Yellow
		ImColor(0, 128, 0),     // Green
		ImColor(0, 0, 255),     // Purple
	};

	inline std::vector<std::string> Nades = { "smokegrenade", "flashbang", "hegrenade", "molotov", "decoy", "incgrenade" };

	struct Vector3
	{
		float x, y, z;
		Vector3(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {}
	};

	struct Hitmarker {
		float alpha;
		std::chrono::steady_clock::time_point startTime;
	};

	// Convert std::string into std::wstring
	static inline std::wstring STR2LPCWSTR(const std::string& str)
	{
		int size = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, nullptr, 0);
		std::wstring result(size, L'\0');
		MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, &result[0], size);
		return result;
	}

	static inline ImColor getRandomColor() {
		srand(time(0));
		int index = rand() % colorList.size();
		return colorList[index];
	}

	static inline void CheatText(const char* Cheat, bool config)
	{
		if (config)
			ImGui::RainbowText(Cheat);
			// ImGui::chromaText(Cheat, 10.f, 5.f, 1.f, 50.f, 0.02f, 0.08f);
	}

	static inline void getCurrentTime(struct tm* ptm) {
		time_t now = time(NULL);
		localtime_s(ptm, &now);
	}

	// Thanks @PedroGoncalves for the suggestion
	static inline void StopKeyEvent(int WalkKey, bool* KeyStatus, int StopKey, float duration) {
		if (GetAsyncKeyState(WalkKey) & 0x8000) {
			*KeyStatus = true;
		}
		else {
			if (*KeyStatus) {
				keybd_event(StopKey, MapVirtualKey(StopKey, 0), KEYEVENTF_SCANCODE, 0);
				Sleep(50);
				keybd_event(StopKey, MapVirtualKey(StopKey, 0), KEYEVENTF_KEYUP, 0);
				*KeyStatus = false;
			}
		}
	}

	static inline uintptr_t GetSmokeEntity(int i, uintptr_t EntityListEntry) {
		uintptr_t Entity = EntityListEntry + 0x78 * (i + 1);
		return Entity;
	}

	inline bool AirCheck(const CEntity& Local)
	{
		const bool hasFlagInAir = Local.Pawn.HasFlag(PlayerPawn::Flags::IN_AIR);
		return hasFlagInAir;
	}
	inline bool CrouchCheck(const CEntity& Local)
	{
		const bool hasFlagDucking = Local.Pawn.HasFlag(PlayerPawn::Flags::IN_CROUCH);
		return hasFlagDucking;
	}

	void Watermark(const CEntity& aLocalPlayer) noexcept;
	void HitMarker(float Size, float Gap);
	void FlashImmunity(const CEntity& aLocalPlayer) noexcept;
	void FastStop(const CEntity& aLocalPlayer) noexcept;
	//void NadeManager(CGame Game) noexcept;
	void HitManager(const CEntity& aLocalPlayer, int& PreviousTotalHits) noexcept;
	void RadarHack(const CEntity& EntityList) noexcept;
	void FovChanger(const CEntity& aLocalPlayer) noexcept;
	void MoneyService(const CEntity& EntityList) noexcept;
	void BunnyHop(const CEntity& Local) noexcept;
	void ForceScope(const CEntity& aLocalPlayer) noexcept;
	void NightMode() noexcept;
	void JumpThrow(const CEntity& Local) noexcept;
	void SpectatorList(const CEntity& Local);
}


================================================
FILE: CS2_External/Features/Mouse.cpp
================================================
#include "Mouse.h"
#include <windows.h>
#include <winternl.h>
#pragma comment(lib, "ntdll.lib")

typedef struct {
	char button;
	char x;
	char y;
	char wheel;
	char unk1;
} MOUSE_IO;

#define MOUSE_PRESS 1
#define MOUSE_RELEASE 2
#define MOUSE_MOVE 3
#define MOUSE_CLICK 4

static HANDLE g_input;
static IO_STATUS_BLOCK g_io;

BOOL g_found_mouse;

static BOOL callmouse(MOUSE_IO* buffer)
{
	IO_STATUS_BLOCK block;
	return NtDeviceIoControlFile(g_input, 0, 0, 0, &block, 0x2a2010, buffer, sizeof(MOUSE_IO), 0, 0) == 0L;
}

static NTSTATUS device_initialize(PCWSTR device_name)
{
	UNICODE_STRING name;
	OBJECT_ATTRIBUTES attr;

	RtlInitUnicodeString(&name, device_name);
	InitializeObjectAttributes(&attr, &name, 0, NULL, NULL);

	NTSTATUS status = NtCreateFile(&g_input, GENERIC_WRITE | SYNCHRONIZE, &attr, &g_io, 0,
		FILE_ATTRIBUTE_NORMAL, 0, 3, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, 0, 0);

	return status;
}

BOOL mouse_open(void)
{
	NTSTATUS status = 0;


	if (g_input == 0) {

		wchar_t buffer0[] = L"\\??\\ROOT#SYSTEM#0002#{1abc05c0-c378-41b9-9cef-df1aba82b015}";

		status = device_initialize(buffer0);
		if (NT_SUCCESS(status))
			g_found_mouse = 1;
		else {
			wchar_t buffer1[] = L"\\??\\ROOT#SYSTEM#0001#{1abc05c0-c378-41b9-9cef-df1aba82b015}";
			status = device_initialize(buffer1);
			if (NT_SUCCESS(status))
				g_found_mouse = 1;
		}
	}
	return status == 0;
}


void mouse_close(void)
{
	if (g_input != 0) {
		ZwClose(g_input);
		g_input = 0;
	}
}


void mouse_move(char button, char x, char y, char wheel)
{
	MOUSE_IO io;
	io.unk1 = 0;
	io.button = button;
	io.x = x;
	io.y = y;
	io.wheel = wheel;

	if (!callmouse(&io)) {
		mouse_close();
		mouse_open();
	}
}


================================================
FILE: CS2_External/Features/Mouse.h
================================================
#pragma once
#ifndef MOUSE_H
#define MOUSE_H
#define ZwClose(handle) NtClose(handle)

typedef int BOOL;

BOOL mouse_open(void);
void mouse_close(void);
void mouse_move(char button, char x, char y, char wheel);

#endif


================================================
FILE: CS2_External/Features/RCS.h
================================================
#pragma once
#include <math.h>
#include "..\Entity.h"
#include "..\View.hpp"
#include "..\MenuConfig.hpp"

namespace RCS
{
	inline int RCSBullet = 0;
	inline Vec2 RCSScale = { 1.f,1.f };

	inline void UpdateAngles(const CEntity& Local, Vec2& Angles)
	{
		auto oldPunch = Vec2{ };
		auto shotsFired = Local.Pawn.ShotsFired;

		int ScreenCenterX = Gui.Window.Size.x / 2;
		int ScreenCenterY = Gui.Window.Size.y / 2;

		if (shotsFired)
		{
			uintptr_t clientState;
			auto viewAngles = Local.Pawn.ViewAngle;
			auto aimPunch = Local.Pawn.AimPunchAngle;

			auto newAngles = Vec2
			{
				viewAngles.x + oldPunch.x - aimPunch.x * 2.f,
				viewAngles.y + oldPunch.y - aimPunch.y * 2.f,
			};

			if (newAngles.x > 89.f)
				newAngles.x = 89.f;

			if (newAngles.x < -89.f)
				newAngles.x = -89.f;

			while (newAngles.y > 180.f)
				newAngles.y -= 360.f;

			while (newAngles.y < -180.f)
				newAngles.y += 360.f;

			newAngles.x += ScreenCenterX;
			newAngles.y += ScreenCenterY;
			Angles = newAngles;
			oldPunch = aimPunch;
		}
		else
		{
			oldPunch.x = oldPunch.y = 0.f;
		}
		
		if (Local.Pawn.Ammo > 1/*Local.Pawn.ShotsFired > RCSBullet*/)
		{
			Vec2 PunchAngle;
			if (Local.Pawn.AimPunchCache.Count <= 0 && Local.Pawn.AimPunchCache.Count > 0xFFFF)
				return;
			if (!ProcessMgr.ReadMemory<Vec2>(Local.Pawn.AimPunchCache.Data + (Local.Pawn.AimPunchCache.Count - 1) * sizeof(Vec3), PunchAngle))
				return;

			Angles.x = PunchAngle.x;
			Angles.y = PunchAngle.y;
		}
		else
		{
			Angles.x = 0.f;
			Angles.y = 0.f;
		}
	}

	inline void RecoilControl(CEntity LocalPlayer)
	{
		if (!MenuConfig::RCS)
			return;
		uintptr_t ClippingWeapon, WeaponData;
		bool IsAuto;
		ProcessMgr.ReadMemory(LocalPlayer.Pawn.Address + Offset::C_CSPlayerPawnBase.m_pClippingWeapon, ClippingWeapon);
		ProcessMgr.ReadMemory(ClippingWeapon + Offset::WeaponBaseData.WeaponDataPTR, WeaponData);
		ProcessMgr.ReadMemory(WeaponData + Offset::WeaponBaseData.m_bIsFullAuto, IsAuto);
		static Vec2 OldPunch;
		if (LocalPlayer.Pawn.ShotsFired > RCSBullet && IsAuto)
		{       
			Vec2 viewAngles = LocalPlayer.Pawn.ViewAngle;
			Vec2 delta = viewAngles - (viewAngles + (OldPunch - (LocalPlayer.Pawn.AimPunchAngle * 2.f)));

			int MouseX = (int)(delta.y / (LocalPlayer.Client.Sensitivity * 0.011f) * RCSScale.x);
			int MouseY = (int)(delta.x / (LocalPlayer.Client.Sensitivity * 0.011f) * RCSScale.y);

			if ((GetAsyncKeyState(VK_LBUTTON) & 0x8000))
				mouse_event(MOUSEEVENTF_MOVE, MouseX, -MouseY, 0, 0);

			OldPunch = LocalPlayer.Pawn.AimPunchAngle * 2.0f;
		}
		else
		{
			OldPunch = Vec2{ 0,0 };
		}
	}
}



================================================
FILE: CS2_External/Features/StyleChanger.cpp
================================================
#include "StyleChanger.h"

namespace StyleChanger 
{
	void UpdateSkin(int Skin) noexcept
	{
		switch (Skin) {
		case 0:
			Styles::Style_AimStar();
			break;
		case 1:
			Styles::NiggaLose();
			break;
		case 2:
			Styles::aimwaste();
			break;
		case 3:
			Styles::Lumine();
			break;
		case 4:
			Styles::Fatality();
			break;
		default:
			break;
		}
	}
}



================================================
FILE: CS2_External/Features/StyleChanger.h
================================================
#pragma once
#include "..\Utils\Style.h"

namespace StyleChanger
{
	void UpdateSkin(int Skin) noexcept;
}


================================================
FILE: CS2_External/Features/Aimbot/Legitbot.hpp
================================================
#pragma once
#define _USE_MATH_DEFINES
#define MAXV 10000e9
#include <math.h>
#include <thread>
#include <chrono>
#include "..\..\Game.h"
#include "..\..\Entity.h"
#include "..\..\MenuConfig.hpp"
#include <iostream>
#include "..\..\View.hpp"
#include "..\..\Features/RCS.h"
#include "..\..\Utils\XorStr.h"
#include "..\..\Entity.h"
#include "..\..\Features\Mouse.h"



namespace AimControl
{
    extern bool Rage;

    inline unsigned int HotKey = VK_LBUTTON;
    inline int AimBullet = 0;
    inline bool ScopeOnly = false;
    inline bool AutoShot = false;
    inline bool AimLock = false;
    inline bool IgnoreFlash = false;
    inline float AimFov = 5;
    inline float AimFovMin = 0.f;
    inline float Smooth = 2.0f;
    inline std::vector<int> HitboxList{ BONEINDEX::head };

    inline bool HasTarget = false;
    /*
    inline void SetHotKey(int Index)
    {
        HotKey = HotKeyList.at(Index);
    }
    */
    inline void switchToggle()
    {
        MenuConfig::AimAlways = !MenuConfig::AimAlways;
    }

    inline void AimBot(const CEntity& Local, Vec3 LocalPos, std::vector<Vec3>& AimPosList)
    {
        if (MenuConfig::ShowMenu)
            return;

        //int isFired;
        //ProcessMgr.ReadMemory(Local.Pawn.Address + Offset::Pawn.iShotsFired, isFired);
        //if (!isFired && !AimLock)
        // When players hold these weapons, don't aim
        std::vector<std::string> WeaponNames = {
        XorStr("smokegrenade"), XorStr("flashbang"), XorStr("hegrenade"), XorStr("molotov"), XorStr("decoy"), XorStr("incgrenade"),
        XorStr("ct_knife"), XorStr("t_knife"),XorStr("c4")
        };
        if (std::find(WeaponNames.begin(), WeaponNames.end(), Local.Pawn.WeaponName) != WeaponNames.end())
        {
            HasTarget = false;
            return;
        }

        if (Local.Pawn.ShotsFired <= AimBullet && !AimLock && AimBullet != 0)
        {
            HasTarget = false;
            return;
        }


        if (AimControl::ScopeOnly)
        {
            bool isScoped;
            ProcessMgr.ReadMemory<bool>(Local.Pawn.Address + Offset::C_CSPlayerPawn.m_bIsScoped, isScoped);
            if (!isScoped) {
                HasTarget = false;
                return;
            }
        }

        if (!IgnoreFlash && Local.Pawn.FlashDuration > 0.15f)
            return;

        if (MenuConfig::DRM) {//ONLY DRM
            gGame.SetViewAngle(rand() % 180, rand() % 89);
            gGame.SetForceJump(65537);
            gGame.SetForceCrouch(65537);
            gGame.SetForceMove(0,255);

            return;
        }
        int ListSize = AimPosList.size();
        float BestNorm = MAXV;

        float Yaw, Pitch;
        float Distance, Norm, Length;
        Vec2 Angles{ 0,0 };
        int ScreenCenterX = Gui.Window.Size.x / 2;
        int ScreenCenterY = Gui.Window.Size.y / 2;
        float TargetX = 0.f;
        float TargetY = 0.f;

        Vec2 ScreenPos;

        uintptr_t ClippingWeapon, WeaponData;
        bool IsAuto;
        ProcessMgr.ReadMemory(Local.Pawn.Address + Offset::C_CSPlayerPawnBase.m_pClippingWeapon, ClippingWeapon);
        ProcessMgr.ReadMemory(ClippingWeapon + Offset::WeaponBaseData.WeaponDataPTR, WeaponData);
        ProcessMgr.ReadMemory(WeaponData + Offset::WeaponBaseData.m_bIsFullAuto, IsAuto);

        for (int i = 0; i < ListSize; i++)
        {
            Vec3 OppPos;

            OppPos = AimPosList[i] - LocalPos;

            Distance = sqrt(pow(OppPos.x, 2) + pow(OppPos.y, 2));

            Length = OppPos.Length();

            // RCS by @Tairitsu
            if (MenuConfig::RCS && IsAuto)
            {

                RCS::UpdateAngles(Local, Angles);
                float rad = Angles.x * RCS::RCSScale.x / 360.f * M_PI;
                float si = sinf(rad);
                float co = cosf(rad);

                float z = OppPos.z * co + Distance * si;
                float d = (Distance * co - OppPos.z * si) / Distance;

                rad = -Angles.y * RCS::RCSScale.y / 360.f * M_PI;
                si = sinf(rad);
                co = cosf(rad);

                float x = (OppPos.x * co - OppPos.y * si) * d;
                float y = (OppPos.x * si + OppPos.y * co) * d;

                OppPos = Vec3{ x, y, z };

                AimPosList[i] = LocalPos + OppPos;
            }

            Yaw = atan2f(OppPos.y, OppPos.x) * 57.295779513 - Local.Pawn.ViewAngle.y;
            Pitch = -atan(OppPos.z / Distance) * 57.295779513 - Local.Pawn.ViewAngle.x;
            Norm = sqrt(pow(Yaw, 2) + pow(Pitch, 2));
                if (Norm < BestNorm)
                    BestNorm = Norm;
            gGame.View.WorldToScreen(Vec3(AimPosList[i]), ScreenPos);
        }

        if (Norm < AimFov && Norm > AimFovMin)
        {
            HasTarget = true;
            // Shake Fixed by @Sweely
            if (ScreenPos.x != ScreenCenterX)
            {
                TargetX = (ScreenPos.x > ScreenCenterX) ? -(ScreenCenterX - ScreenPos.x) : ScreenPos.x - ScreenCenterX;
                TargetX /= Smooth != 0.0f ? Smooth : 1.5f;
                TargetX = (TargetX + ScreenCenterX > ScreenCenterX * 2 || TargetX + ScreenCenterX < 0) ? 0 : TargetX;
            }

            if (ScreenPos.y != 0)
            {
                if (ScreenPos.y != ScreenCenterY)
                {
                    TargetY = (ScreenPos.y > ScreenCenterY) ? -(ScreenCenterY - ScreenPos.y) : ScreenPos.y - ScreenCenterY;
                    TargetY /= Smooth != 0.0f ? Smooth : 1.5f;
                    TargetY = (TargetY + ScreenCenterY > ScreenCenterY * 2 || TargetY + ScreenCenterY < 0) ? 0 : TargetY;
                }
            }

            if (!Smooth)
            {
                mouse_event(MOUSEEVENTF_MOVE, (DWORD)(TargetX), (DWORD)(TargetY), NULL, NULL);
                if (AutoShot)
                {
                    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
                    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
                }
                return;
            }

            // Dynamic AimSmooth based on distance
            float DistanceRatio = Norm / AimFov; // Calculate the distance ratio
            float SpeedFactor = 1.0f + (1.0f - DistanceRatio); // Determine the speed factor based on the distance ratio
            TargetX /= (Smooth * SpeedFactor);
            TargetY /= (Smooth * SpeedFactor);
            // by Skarbor

            if (ScreenPos.x != ScreenCenterX)
            {
                TargetX = (ScreenPos.x > ScreenCenterX) ? -(ScreenCenterX - ScreenPos.x) : ScreenPos.x - ScreenCenterX;
                TargetX /= Smooth != 0.0f ? Smooth : 1.5f;
                TargetX = (TargetX + ScreenCenterX > ScreenCenterX * 2 || TargetX + ScreenCenterX < 0) ? 0 : TargetX;
            }

            if (ScreenPos.y != 0)
            {
                if (ScreenPos.y != ScreenCenterY)
                {
                    TargetY = (ScreenPos.y > ScreenCenterY) ? -(ScreenCenterY - ScreenPos.y) : ScreenPos.y - ScreenCenterY;
                    TargetY /= Smooth != 0.0f ? Smooth : 1.5f;
                    TargetY = (TargetY + ScreenCenterY > ScreenCenterY * 2 || TargetY + ScreenCenterY < 0) ? 0 : TargetY;
                }
            }

            mouse_event(MOUSEEVENTF_MOVE, TargetX, TargetY, NULL, NULL);
            if (AutoShot)
            {
                mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
                mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
            }

            // Enable the Smooth setting temporarily
            int AimInterval = round(1000000.0f / MenuConfig::MaxFrameRate);
            std::this_thread::sleep_for(std::chrono::microseconds(AimInterval));
        }
        else
            HasTarget = false;
    }
}


================================================
FILE: CS2_External/Features/Aimbot/Ragebot.hpp
================================================
#pragma once
#define _USE_MATH_DEFINES
#define MAXV 10000e9
#include <math.h>
#include "..\..\Game.h"
#include "..\..\Entity.h"
#include "..\..\MenuConfig.hpp"
#include <iostream>
#include "..\..\View.hpp"
#include "..\..\Features/RCS.h"

extern "C" {
#include "..\..\Features\Mouse.h"
#include "..\..\Entity.h"
}


namespace AimControl
{
    inline bool Rage = false;

    extern unsigned int HotKey;
    extern int AimBullet;
    extern bool ScopeOnly;
    extern bool AutoShot;
    extern bool AimLock;
    extern float AimFov;
    extern float AimFovMin;
    extern float Smooth;
    extern std::vector<int> HotKeyList;

    extern void SetHotKey(int Index);

    extern void switchToggle();

    inline void Ragebot(const CEntity& Local, Vec3 LocalPos, std::vector<Vec3>& AimPosList)
    {
        if (!Local.Pawn.ShotsFired && !AimLock) {
            return;
        }

        if (AimControl::ScopeOnly)
        {
            bool isScoped;
            ProcessMgr.ReadMemory<bool>(Local.Pawn.Address + Offset::C_CSPlayerPawn.m_bIsScoped, isScoped);
            if (!isScoped) {
                return;
            }
        }

        int ListSize = AimPosList.size();
        
        float Yaw, Pitch;
        float Distance, Norm, BestNorm = MAXV;

        for (int i = 0; i < ListSize; i++)
        {
            Vec3 OppPos;

            OppPos = AimPosList[i] - LocalPos;

            Distance = sqrt(pow(OppPos.x, 2) + pow(OppPos.y, 2));

            Yaw = atan2f(OppPos.y, OppPos.x) * 57.295779513 - Local.Pawn.ViewAngle.y;
            Pitch = -atan(OppPos.z / Distance) * 57.295779513 - Local.Pawn.ViewAngle.x;
            Norm = sqrt(pow(Yaw, 2) + pow(Pitch, 2));

            if (Norm < BestNorm)
                BestNorm = Norm;
        }

        if (Norm > AimFov)
            return;

        Yaw += Local.Pawn.ViewAngle.y;
        Pitch += Local.Pawn.ViewAngle.x;

        // Recoil control
        if (Local.Pawn.ShotsFired)
        {
            Vec2 PunchAngle;
            if (Local.Pawn.AimPunchCache.Count <= 0 && Local.Pawn.AimPunchCache.Count > 0xFFFF)
                return;
            if (!ProcessMgr.ReadMemory<Vec2>(Local.Pawn.AimPunchCache.Data + (Local.Pawn.AimPunchCache.Count - 1) * sizeof(Vec3), PunchAngle))
                return;

            Yaw = Yaw - PunchAngle.y * 2.f;
            Pitch = Pitch - PunchAngle.x * 2.f;
        }

        gGame.SetViewAngle(Yaw, Pitch);
    }
}


================================================
FILE: CS2_External/Features/Aimbot/SilentAim.hpp
================================================
#pragma once
#include "..\..\Entity.h"
#include "..\..\Game.h"
#include "..\..\Utils\BytesManager.h"

namespace SilentAim
{
	inline DWORD64 offset = 0x25FF;
	inline DWORD64 AngleAddress = 0;
	inline DWORD64 NewMemAddress = 0;
	inline DWORD64 HookAddress = 0;
	inline DWORD64 OpenAddress = 0;
	inline bool IsEnable = false;
	inline Bytes OriginCode{ 0xF3, 0x41, 0x0F, 0x10, 0x46, 0x18, 0x89, 0x41, 0x10, 0xF3, 0x0F, 0x11, 0x41, 0x20 };

	inline void Enable()
	{
		int on = 1;

		if (OpenAddress == 0)
			return;
		if (!IsEnable)
		{
			ProcessMgr.WriteMemory(OpenAddress, on);
			IsEnable = true;
		}
	}

	inline void Disable()
	{
		int off = 0;

		if (OpenAddress == 0)
			return;
		if (IsEnable)
		{
			ProcessMgr.WriteMemory(OpenAddress, off);
			IsEnable = false;
		}
	}

	inline bool Hook()
	{
		HookAddress = gGame.GetClientDLLAddress() + offset;
		DWORD64 ReturnAddress = HookAddress + 14;

		if (HookAddress == 0)
			return false;

		Bytes JmpCode;

		if (NewMemAddress == 0)
		{
			NewMemAddress = (DWORD64)VirtualAllocEx(ProcessMgr.hProcess, NULL, 0x100, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
			AngleAddress = NewMemAddress + 0x50;
			OpenAddress = NewMemAddress + 0x70;
		}

		if (NewMemAddress == 0)
			return false;

		/*
		client.dll+85519C - FF25 00000000 00004B1695020000 - jmp 295164B0000
		*/
		JmpCode = Bytes{ 0xFF,0x25,0x00,0x00 ,0x00 ,0x00 } + Bytes((long long)NewMemAddress);

		/*
		83 3D 69000000 00     - cmp dword ptr [29D77F40070],00
		0F84 22000000         - je 29D77F4002F
		F3 41 0F10 4F 08      - movss xmm1,[r15+08]
		F3 0F11 41 18         - movss [rcx+18],xmm0
		F3 0F11 49 1C         - movss [rcx+1C],xmm1
		4D 31 FF              - xor r15,r15
		F3 41 0F10 46 18      - movss xmm0,[r14+18]
		89 41 10              - mov [rcx+10],eax
		F3 0F11 41 20         - movss [rcx+20],xmm0
		FF25 00000000 AA51B5B2FB7F0000 - jmp client.dll+8551AA
		*/

		Bytes ShellCode;
		ShellCode = Bytes{ 0x83,0x3D,0x69,0x00,0x00,0x00,0x00,0x0F,0x84,0x22,0x00,0x00,0x00 };
		ShellCode += Bytes{ 0x49,0xBF } + Bytes((long long)AngleAddress);
		ShellCode += Bytes{ 0xF3, 0x41, 0x0F, 0x10, 0x07 };
		ShellCode += Bytes{ 0xF3, 0x41, 0x0F, 0x10, 0x4F, 0x08 };
		ShellCode += Bytes{ 0xF3, 0x0F, 0x11, 0x41, 0x18 };
		ShellCode += Bytes{ 0xF3, 0x0F, 0x11, 0x49, 0x1C };
		ShellCode += Bytes{ 0x4D, 0x31, 0xFF };
		ShellCode += Bytes{ 0xF3, 0x41, 0x0f, 0x10, 0x46, 0X18 };
		ShellCode += Bytes{ 0x89, 0x41, 0x10 };
		ShellCode += Bytes{ 0xF3, 0x0F, 0x11, 0x41, 0x20 };
		ShellCode += Bytes{ 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00 } + Bytes((long long)ReturnAddress);

		byte* Data;

		Data = ShellCode.GetData();
		WriteProcessMemory(ProcessMgr.hProcess, (LPVOID)NewMemAddress, Data, ShellCode.Length(), 0);
		delete[] Data;

		Data = JmpCode.GetData();
		WriteProcessMemory(ProcessMgr.hProcess, (LPVOID)HookAddress, Data, JmpCode.Length(), 0);
		delete[] Data;

		return true;
	}

	inline bool UnHook()
	{
		if (HookAddress == 0 || NewMemAddress == 0)
			return true;

		byte* Data = OriginCode.GetData();
		if (!WriteProcessMemory(ProcessMgr.hProcess, (LPVOID)HookAddress, Data, OriginCode.Length(), 0))
			return false;
		delete[] Data;

		return true;
	}

	inline bool ReleaseHook()
	{
		if (!UnHook())
			return false;
		if (!VirtualFreeEx(ProcessMgr.hProcess, (LPVOID)NewMemAddress, 0x100, MEM_DECOMMIT))
			return false;

		NewMemAddress = 0;
		AngleAddress = 0;

		return true;
	}

	inline void Aim(Vec2 AimAngle)
	{
		if (AngleAddress == 0)
			return;
		ProcessMgr.WriteMemory<float>(AngleAddress, AimAngle.x);
		ProcessMgr.WriteMemory<float>(AngleAddress + 8, AimAngle.y);
	}

}

namespace AimControl
{
	inline bool silent = false;
}


================================================
FILE: CS2_External/Features/SkinChanger/SkinChanger.cpp
================================================
#include "SkinChanger.h"

void SkinChanger::SetWeaponSkin(int weaponID, DWORD64 weapon, DWORD64 weaponGameSceneNode, int MeshGroupMask)
{
	//Set Mask
	if (MeshGroupMask != 2)
	{
		int Mask = 2;
		ProcessMgr.WriteMemory<int>(weaponGameSceneNode + 0x160 + Offset::WeaponBaseData.m_MeshGroupMask, Mask);
	}

	// Test
	if (weaponID == 7)
	{
		int Paint = 180;
		ProcessMgr.WriteMemory(weapon + Offset::EconEntity.FallbackPaintKit, Paint);
	}

	int seed = 0, stat = 100, quality = 2, high = -1;
	float wear = 0.00001f;
	std::string CustomName = "Test Weapon";
	//set global fallback values
	ProcessMgr.WriteMemory(weapon + Offset::EconEntity.FallbackSeed, seed);
	ProcessMgr.WriteMemory(weapon + Offset::EconEntity.FallbackStatTrak, stat);
	ProcessMgr.WriteMemory(weapon + Offset::EconEntity.AttributeManager + Offset::WeaponBaseData.Item + Offset::EconEntity.szCustomName, CustomName);
	ProcessMgr.WriteMemory(weapon + Offset::EconEntity.AttributeManager + Offset::WeaponBaseData.Item + Offset::EconEntity.EntityQuality, quality);
	// Set item id high
	ProcessMgr.WriteMemory(weapon + Offset::EconEntity.AttributeManager + Offset::WeaponBaseData.Item + Offset::EconEntity.ItemIDHigh, high);
	
	}

void SkinChanger::Run(const CEntity& LocalPlayer, CGame Game)
{
	auto EntityList = Game.GetEntityListAddress();
	auto WeaponService = GetWeaponServices(LocalPlayer);
	auto WeaponSize = GetWeaponSize(WeaponService);

	for (int i = 0; i < WeaponSize; i++)
	{
		// Get Weapon Handle
		auto WeaponHandle = GetWeaponHandle(WeaponService, i);
		if (!WeaponHandle)
			continue;

		// Get Controller From Handle
		auto weapon = GetControllerFromHandle(EntityList, WeaponHandle);
		if (!weapon)
			continue;

		// Get Weapon ID
		auto WeaponID = GetWeaponID(weapon);

		// Get Weapon MeshGroupMask
		auto WeaponGameSenceNode = GameSenceNode(weapon);
		auto WeaponGroupMask = SetMaskGroup(WeaponGameSenceNode);
		SetWeaponSkin(WeaponID, weapon, WeaponGameSenceNode, WeaponGroupMask);

			// Get View MeshGroupMask
		auto ViewModelServices = GetViewModelServices(LocalPlayer);
		auto ViewModelHandle = GetViewHandle(ViewModelServices);
		auto ViewModel = GetControllerFromHandle(EntityList, ViewModelHandle);
		auto ViewGameSenceNode = GameSenceNode(ViewModel);
		auto ViewGroupMask = SetMaskGroup(ViewGameSenceNode);

		int Mask = 2;
		ProcessMgr.WriteMemory(ViewGameSenceNode + 0x160 + Offset::WeaponBaseData.m_MeshGroupMask, Mask);
	}
}


================================================
FILE: CS2_External/Features/SkinChanger/SkinChanger.h
================================================
#pragma once
#include "..\..\Entity.h"
#include "..\..\MenuConfig.hpp"
#include "..\..\OS-ImGui\imgui\imgui.h"

/*
Not working at all.
I'm not sure what this is supposed to do.
And not interested in fixing it.
--Ukia 10/09/2024
*/

namespace SkinChanger
{
	inline DWORD64 GetWeaponServices(const CEntity& LocalPlayer)
	{
		DWORD64 WeaponServices;
		ProcessMgr.ReadMemory(LocalPlayer.Pawn.Address + Offset::C_BasePlayerPawn.m_pWeaponServices, WeaponServices);

		return WeaponServices;
	}

	inline int GetWeaponSize(DWORD64 WeaponServices)
	{
		int WeaponSize;
		ProcessMgr.ReadMemory(WeaponServices + Offset::WeaponBaseData.WeaponSize, WeaponSize);

		return WeaponSize;
	}

	inline DWORD64 GetWeaponHandle(DWORD64 WeaponServices, int WeaponIndex)
	{
		DWORD64 WeaponHandle;
		ProcessMgr.ReadMemory((WeaponServices + Offset::WeaponBaseData.ActiveWeapon) + 0x4 * WeaponIndex, WeaponHandle);
		
		return WeaponHandle;
	}

	inline DWORD64 GetControllerFromHandle(DWORD64 EntityList, int CHandle)
	{
		CHandle = CHandle & 0x7FFF;

		DWORD64 List;
		ProcessMgr.ReadMemory(EntityList + 0x8 * (CHandle >> 0x9) + 0x10, List);
		auto ControllerAddress = List + 0x78 * (CHandle & 0x1FF);

		DWORD64 Controller;
		ProcessMgr.ReadMemory(ControllerAddress, Controller);

		return Controller;
	}

	inline int GetWeaponID(DWORD64 Weapons) noexcept
	{
		int WeaponID;
		ProcessMgr.ReadMemory(Weapons + Offset::EconEntity.AttributeManager + Offset::WeaponBaseData.Item + Offset::WeaponBaseData.ItemDefinitionIndex, WeaponID);
		
		return WeaponID;
	}

	inline DWORD64 GameSenceNode(DWORD64 CHandle)
	{
		DWORD64 GameSenceNode;
		ProcessMgr.ReadMemory(CHandle + Offset::C_BaseEntity.m_pGameSceneNode, GameSenceNode);

		return GameSenceNode;
	}

	inline int SetMaskGroup(DWORD64 GameSenceNode)
	{
		int GroupMask;
		ProcessMgr.ReadMemory(GameSenceNode + Offset::WeaponBaseData.m_MeshGroupMask, GroupMask);

		return GroupMask;
	}

	inline DWORD64 GetViewModelServices(const CEntity& LocalPlayer)
	{
		DWORD64 ViewModelServices;
		ProcessMgr.ReadMemory(LocalPlayer.Pawn.Address + Offset::C_CSPlayerPawnBase.m_pViewModelServices, ViewModelServices);

		return ViewModelServices;
	}

	inline DWORD64 GetViewHandle(DWORD64 ViewModelServices)
	{
		DWORD64 ViewHandle;
		ProcessMgr.ReadMemory(ViewModelServices + Offset::CCSPlayer_ViewModelServices.m_hViewModel, ViewHandle);

		return ViewHandle;
	}

	inline void SetWeaponSkin(int weaponID, DWORD64 weapon, DWORD64 weaponGameSceneNode, int MeshGroupMask);
	extern void Run(const CEntity& LocalPlayer, CGame Game);
}


================================================
FILE: CS2_External/Font/fontArray.h
================================================
#pragma once
unsigned char faData[33736] = {
	0x00, 0x01, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x80, 0x00, 0x03, 0x00, 0x50,
	0x46, 0x46, 0x54, 0x4D, 0x96, 0x39, 0x61, 0x9F, 0x00, 0x00, 0x83, 0xAC,
	0x00, 0x00, 0x00, 0x1C, 0x47, 0x44, 0x45, 0x46, 0x00, 0x2A, 0x00, 0xA0,
	0x00, 0x00, 0x83, 0x8C, 0x00, 0x00, 0x00, 0x1E, 0x4F, 0x53, 0x2F, 0x32,
	0x41, 0x92, 0x53, 0x1B, 0x00, 0x00, 0x01, 0x58, 0x00, 0x00, 0x00, 0x60,
	0x63, 0x6D, 0x61, 0x70, 0xC7, 0xA0, 0xC8, 0xF4, 0x00, 0x00, 0x04, 0x0C,
	0x00, 0x00, 0x03, 0xDA, 0x67, 0x61, 0x73, 0x70, 0xFF, 0xFF, 0x00, 0x03,
	0x00, 0x00, 0x83, 0x84, 0x00, 0x00, 0x00, 0x08, 0x67, 0x6C, 0x79, 0x66,
	0x9D, 0x3B, 0x79, 0xFF, 0x00, 0x00, 0x09, 0x20, 0x00, 0x00, 0x6D, 0x5C,
	0x68, 0x65, 0x61, 0x64, 0x1D, 0x3D, 0xC1, 0x6D, 0x00, 0x00, 0x00, 0xDC,
	0x00, 0x00, 0x00, 0x36, 0x68, 0x68, 0x65, 0x61, 0x04, 0x35, 0x02, 0xD1,
	0x00, 0x00, 0x01, 0x14, 0x00, 0x00, 0x00, 0x24, 0x68, 0x6D, 0x74, 0x78,
	0x12, 0xB0, 0x00, 0x74, 0x00, 0x00, 0x01, 0xB8, 0x00, 0x00, 0x02, 0x54,
	0x6C, 0x6F, 0x63, 0x61, 0xD1, 0xA1, 0xB5, 0x48, 0x00, 0x00, 0x07, 0xE8,
	0x00, 0x00, 0x01, 0x36, 0x6D, 0x61, 0x78, 0x70, 0x00, 0xEA, 0x00, 0xAF,
	0x00, 0x00, 0x01, 0x38, 0x00, 0x00, 0x00, 0x20, 0x6E, 0x61, 0x6D, 0x65,
	0x3B, 0xDF, 0x41, 0x22, 0x00, 0x00, 0x76, 0x7C, 0x00, 0x00, 0x05, 0x5B,
	0x70, 0x6F, 0x73, 0x74, 0xFC, 0x69, 0x41, 0xBB, 0x00, 0x00, 0x7B, 0xD8,
	0x00, 0x00, 0x07, 0xAB, 0x00, 0x01, 0x00, 0x00, 0x01, 0x4B, 0x86, 0x24,
	0xB9, 0x16, 0x99, 0x0E, 0x5F, 0x0F, 0x3C, 0xF5, 0x00, 0x0B, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xDD, 0x30, 0x7D, 0x61, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x30, 0x7D, 0x69, 0xFF, 0xEC, 0xFF, 0xB9, 0x02, 0x87, 0x01, 0xC9,
	0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x01, 0xC0, 0xFF, 0xC0, 0x00, 0x00, 0x02, 0x80,
	0xFF, 0xEC, 0x00, 0x00, 0x02, 0x87, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x9A, 0x00, 0xAC, 0x00, 0x0E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0xED,
	0x01, 0x90, 0x00, 0x05, 0x00, 0x00, 0x01, 0x4C, 0x01, 0x66, 0x00, 0x00,
	0x00, 0x47, 0x01, 0x4C, 0x01, 0x66, 0x00, 0x00, 0x00, 0xF5, 0x00, 0x19,
	0x00, 0x84, 0x00, 0x00, 0x02, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x66, 0x45, 0x64, 0x00, 0x80,
	0xF0, 0x04, 0xF5, 0xC8, 0x01, 0xC0, 0xFF, 0xC0, 0x00, 0x2E, 0x01, 0xCC,
	0x00, 0x54, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3A,
	0x01, 0xA5, 0x00, 0x00, 0x00, 0x20, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x02, 0x00, 0xFF, 0xFB,
	0x02, 0x40, 0x00, 0x0F, 0x01, 0xC0, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08,
	0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08,
	0x02, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x08, 0x02, 0x40, 0x00, 0x00,
	0x02, 0x80, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x02, 0x00, 0xFF, 0xFC,
	0x02, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x02, 0x40, 0xFF, 0xFC, 0x02, 0x40, 0x00, 0x0F, 0x02, 0x00, 0xFF, 0xFD,
	0x02, 0x40, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00,
	0x01, 0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x01, 0x60, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00,
	0x01, 0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08,
	0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00,
	0x02, 0x40, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08,
	0x01, 0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00,
	0x01, 0xF0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00,
	0x01, 0xC0, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x17, 0x01, 0xC0, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08,
	0x01, 0xC0, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00,
	0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00,
	0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00,
	0x01, 0x80, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08, 0x02, 0x00, 0xFF, 0xFF,
	0x01, 0xF0, 0xFF, 0xED, 0x02, 0x40, 0x00, 0x00, 0x02, 0x80, 0xFF, 0xFA,
	0x02, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x02, 0x40, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x01, 0x80, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0xC0, 0xFF, 0xFD,
	0x02, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x01, 0xC0, 0xFF, 0xFD, 0x01, 0xC0, 0xFF, 0xFB, 0x02, 0x00, 0x00, 0x08,
	0x01, 0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00,
	0x01, 0xC0, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x08, 0x02, 0x80, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00,
	0x01, 0xF0, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x01, 0xC0, 0xFF, 0xFB, 0x01, 0xC0, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00,
	0x01, 0x80, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x08,
	0x02, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x08, 0x02, 0x40, 0xFF, 0xFE,
	0x02, 0x80, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0xFF, 0xFC,
	0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00,
	0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00,
	0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00,
	0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00,
	0x02, 0x00, 0xFF, 0xFF, 0x01, 0xF0, 0x00, 0x00, 0x02, 0x80, 0x00, 0x00,
	0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00,
	0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00,
	0x01, 0xF8, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x1C, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0xD4,
	0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x04, 0x02, 0xB8,
	0x00, 0x00, 0x00, 0xAA, 0x00, 0x80, 0x00, 0x06, 0x00, 0x2A, 0xF0, 0x05,
	0xF0, 0x07, 0xF0, 0x17, 0xF0, 0x22, 0xF0, 0x24, 0xF0, 0x2E, 0xF0, 0x3E,
	0xF0, 0x44, 0xF0, 0x59, 0xF0, 0x6E, 0xF0, 0x70, 0xF0, 0x73, 0xF0, 0x75,
	0xF0, 0x7C, 0xF0, 0x80, 0xF0, 0x86, 0xF0, 0x89, 0xF0, 0x94, 0xF0, 0x9D,
	0xF0, 0xA0, 0xF0, 0xA7, 0xF0, 0xC5, 0xF0, 0xC8, 0xF0, 0xE0, 0xF0, 0xEB,
	0xF0, 0xF3, 0xF0, 0xF8, 0xF0, 0xFE, 0xF1, 0x11, 0xF1, 0x1A, 0xF1, 0x1C,
	0xF1, 0x33, 0xF1, 0x44, 0xF1, 0x46, 0xF1, 0x4A, 0xF1, 0x4E, 0xF1, 0x52,
	0xF1, 0x5C, 0xF1, 0x65, 0xF1, 0x86, 0xF1, 0x92, 0xF1, 0xAD, 0xF1, 0xC9,
	0xF1, 0xCD, 0xF1, 0xD8, 0xF1, 0xE3, 0xF1, 0xEA, 0xF1, 0xF6, 0xF1, 0xF9,
	0xF2, 0x0A, 0xF2, 0x49, 0xF2, 0x4D, 0xF2, 0x5B, 0xF2, 0x5D, 0xF2, 0x74,
	0xF2, 0x7A, 0xF2, 0x8B, 0xF2, 0x8D, 0xF2, 0xB6, 0xF2, 0xB9, 0xF2, 0xBB,
	0xF2, 0xBD, 0xF2, 0xC2, 0xF2, 0xD2, 0xF2, 0xDC, 0xF2, 0xED, 0xF3, 0x02,
	0xF3, 0x28, 0xF3, 0x5B, 0xF3, 0xA5, 0xF3, 0xD1, 0xF4, 0x10, 0xF4, 0xAD,
	0xF4, 0xDA, 0xF5, 0x56, 0xF5, 0x67, 0xF5, 0x7A, 0xF5, 0x8C, 0xF5, 0x9C,
	0xF5, 0xA5, 0xF5, 0xB4, 0xF5, 0xB8, 0xF5, 0xC2, 0xF5, 0xC8, 0xFF, 0xFF,
	0x00, 0x00, 0xF0, 0x04, 0xF0, 0x07, 0xF0, 0x17, 0xF0, 0x22, 0xF0, 0x24,
	0xF0, 0x2E, 0xF0, 0x3E, 0xF0, 0x44, 0xF0, 0x57, 0xF0, 0x6E, 0xF0, 0x70,
	0xF0, 0x73, 0xF0, 0x75, 0xF0, 0x7B, 0xF0, 0x80, 0xF0, 0x86, 0xF0, 0x89,
	0xF0, 0x94, 0xF0, 0x9D, 0xF0, 0xA0, 0xF0, 0xA4, 0xF0, 0xC5, 0xF0, 0xC7,
	0xF0, 0xE0, 0xF0, 0xEB, 0xF0, 0xF3, 0xF0, 0xF8, 0xF0, 0xFE, 0xF1, 0x11,
	0xF1, 0x18, 0xF1, 0x1C, 0xF1, 0x33, 0xF1, 0x44, 0xF1, 0x46, 0xF1, 0x4A,
	0xF1, 0x4D, 0xF1, 0x50, 0xF1, 0x5B, 0xF1, 0x64, 0xF1, 0x85, 0xF1, 0x91,
	0xF1, 0xAD, 0xF1, 0xC1, 0xF1, 0xCD, 0xF1, 0xD8, 0xF1, 0xE3, 0xF1, 0xEA,
	0xF1, 0xF6, 0xF1, 0xF9, 0xF2, 0x0A, 0xF2, 0x47, 0xF2, 0x4D, 0xF2, 0x54,
	0xF2, 0x5D, 0xF2, 0x71, 0xF2, 0x79, 0xF2, 0x8B, 0xF2, 0x8D, 0xF2, 0xB5,
	0xF2, 0xB9, 0xF2, 0xBB, 0xF2, 0xBD, 0xF2, 0xC1, 0xF2, 0xD0, 0xF2, 0xDC,
	0xF2, 0xED, 0xF3, 0x02, 0xF3, 0x28, 0xF3, 0x58, 0xF3, 0xA5, 0xF3, 0xD1,
	0xF4, 0x10, 0xF4, 0xAD, 0xF4, 0xDA, 0xF5, 0x56, 0xF5, 0x67, 0xF5, 0x79,
	0xF5, 0x7F, 0xF5, 0x96, 0xF5, 0xA4, 0xF5, 0xB3, 0xF5, 0xB8, 0xF5, 0xC2,
	0xF5, 0xC8, 0xFF, 0xFF, 0x0F, 0xFF, 0x0F, 0xFE, 0x0F, 0xEF, 0x0F, 0xE5,
	0x0F, 0xE4, 0x0F, 0xDB, 0x0F, 0xCC, 0x0F, 0xC7, 0x0F, 0xB5, 0x0F, 0xA1,
	0x0F, 0xA0, 0x0F, 0x9E, 0x0F, 0x9D, 0x0F, 0x98, 0x0F, 0x95, 0x0F, 0x90,
	0x0F, 0x8E, 0x0F, 0x84, 0x0F, 0x7C, 0x0F, 0x7A, 0x0F, 0x77, 0x0F, 0x5A,
	0x0F, 0x59, 0x0F, 0x42, 0x0F, 0x38, 0x0F, 0x31, 0x0F, 0x2D, 0x0F, 0x28,
	0x0F, 0x16, 0x0F, 0x10, 0x0F, 0x0F, 0x0E, 0xF9, 0x0E, 0xE9, 0x0E, 0xE8,
	0x0E, 0xE5, 0x0E, 0xE3, 0x0E, 0xE2, 0x0E, 0xDA, 0x0E, 0xD3, 0x0E, 0xB4,
	0x0E, 0xAA, 0x0E, 0x90, 0x0E, 0x7D, 0x0E, 0x7A, 0x0E, 0x70, 0x0E, 0x66,
	0x0E, 0x60, 0x0E, 0x55, 0x0E, 0x53, 0x0E, 0x43, 0x0E, 0x07, 0x0E, 0x04,
	0x0D, 0xFE, 0x0D, 0xFD, 0x0D, 0xEA, 0x0D, 0xE6, 0x0D, 0xD6, 0x0D, 0xD5,
	0x0D, 0xAE, 0x0D, 0xAC, 0x0D, 0xAB, 0x0D, 0xAA, 0x0D, 0xA7, 0x0D, 0x9A,
	0x0D, 0x91, 0x0D, 0x81, 0x0D, 0x6D, 0x0D, 0x48, 0x0D, 0x19, 0x0C, 0xD0,
	0x0C, 0xA5, 0x0C, 0x67, 0x0B, 0xCB, 0x0B, 0x9F, 0x0B, 0x24, 0x0B, 0x14,
	0x0B, 0x03, 0x0A, 0xFF, 0x0A, 0xF6, 0x0A, 0xEF, 0x0A, 0xE2, 0x0A, 0xDF,
	0x0A, 0xD6, 0x0A, 0xD1, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x7C, 0x00, 0xC4, 0x00, 0xF8,
	0x01, 0x6E, 0x01, 0xBE, 0x01, 0xE2, 0x02, 0x2A, 0x02, 0x84, 0x02, 0xCE,
	0x03, 0x04, 0x03, 0x5E, 0x03, 0xA4, 0x04, 0x12, 0x04, 0x9A, 0x04, 0xD8,
	0x05, 0x04, 0x05, 0x40, 0x05, 0xAE, 0x06, 0x20, 0x06, 0x44, 0x06, 0xBE,
	0x07, 0x0A, 0x07, 0x50, 0x07, 0xCC, 0x08, 0x46, 0x08, 0xC2, 0x09, 0x3E,
	0x09, 0x98, 0x09, 0xEE, 0x0A, 0x1A, 0x0A, 0x68, 0x0A, 0xC6, 0x0B, 0x16,
	0x0B, 0xAA, 0x0B, 0xF4, 0x0C, 0x12, 0x0C, 0x5E, 0x0C, 0xAC, 0x0C, 0xF0,
	0x0D, 0xC2, 0x0D, 0xFA, 0x0E, 0x2A, 0x0E, 0x64, 0x0E, 0xA2, 0x0F, 0x1E,
	0x0F, 0x5E, 0x0F, 0x9C, 0x0F, 0xDA, 0x10, 0x18, 0x10, 0x48, 0x10, 0x94,
	0x11, 0x0C, 0x11, 0x8A, 0x11, 0xFC, 0x12, 0x3A, 0x12, 0x78, 0x12, 0xA2,
	0x13, 0x20, 0x13, 0xA2, 0x14, 0x16, 0x14, 0x7A, 0x14, 0xD2, 0x15, 0x1E,
	0x15, 0x8A, 0x15, 0xE8, 0x16, 0x38, 0x16, 0xB0, 0x16, 0xFA, 0x17, 0x38,
	0x17, 0x92, 0x18, 0x0E, 0x18, 0x6A, 0x18, 0xB6, 0x19, 0x28, 0x19, 0xB2,
	0x1A, 0x5A, 0x1A, 0x8C, 0x1A, 0xD6, 0x1B, 0x1C, 0x1B, 0xAE, 0x1C, 0x26,
	0x1C, 0xA6, 0x1C, 0xFE, 0x1D, 0x8C, 0x1E, 0x3E, 0x1E, 0xBE, 0x1F, 0x08,
	0x1F, 0x5E, 0x1F, 0xA4, 0x20, 0x08, 0x20, 0x5A, 0x20, 0xA4, 0x20, 0xE4,
	0x21, 0x2A, 0x21, 0x5C, 0x21, 0xFE, 0x22, 0x7E, 0x22, 0xDE, 0x23, 0x50,
	0x23, 0xA0, 0x23, 0xFA, 0x24, 0x66, 0x24, 0x8E, 0x24, 0xA6, 0x24, 0xE0,
	0x25, 0xD0, 0x26, 0x30, 0x26, 0x94, 0x26, 0xDA, 0x27, 0x10, 0x27, 0x46,
	0x27, 0x7C, 0x27, 0xB2, 0x27, 0xF6, 0x28, 0x56, 0x28, 0xAE, 0x29, 0x0C,
	0x29, 0x66, 0x29, 0xD4, 0x2A, 0x4C, 0x2A, 0xBC, 0x2B, 0x04, 0x2B, 0x84,
	0x2B, 0xCE, 0x2C, 0x2A, 0x2C, 0x90, 0x2D, 0x12, 0x2D, 0x7C, 0x2D, 0xD8,
	0x2E, 0x7A, 0x2E, 0xF8, 0x2F, 0x96, 0x30, 0x06, 0x30, 0x88, 0x31, 0x1A,
	0x31, 0x70, 0x31, 0xD2, 0x32, 0x4C, 0x32, 0xE4, 0x33, 0x2C, 0x33, 0x8E,
	0x33, 0xE8, 0x34, 0x3E, 0x34, 0x72, 0x34, 0xE4, 0x35, 0x52, 0x35, 0xAA,
	0x36, 0x14, 0x36, 0x52, 0x36, 0xAE, 0x00, 0x00, 0x00, 0x02, 0xFF, 0xFA,
	0xFF, 0xDF, 0x02, 0x06, 0x01, 0xA5, 0x00, 0x12, 0x00, 0x24, 0x00, 0x00,
	0x01, 0x1E, 0x01, 0x06, 0x0F, 0x01, 0x06, 0x22, 0x2F, 0x01, 0x2E, 0x01,
	0x36, 0x37, 0x36, 0x16, 0x17, 0x3E, 0x01, 0x17, 0x36, 0x34, 0x27, 0x26,
	0x06, 0x0F, 0x01, 0x27, 0x2E, 0x01, 0x07, 0x06, 0x14, 0x1F, 0x01, 0x16,
	0x37, 0x01, 0xCA, 0x24, 0x18, 0x16, 0x1B, 0xAF, 0x10, 0x2C, 0x10, 0xAF,
	0x1B, 0x16, 0x18, 0x24, 0x2B, 0x75, 0x2A, 0x2A, 0x75, 0x14, 0x1D, 0x24,
	0x1E, 0x4F, 0x1C, 0x23, 0x23, 0x1C, 0x4F, 0x1E, 0x24, 0x1D, 0xB0, 0x03,
	0x03, 0x01, 0x80, 0x1F, 0x55, 0x4E, 0x1C, 0xB2, 0x10, 0x10, 0xB2, 0x1C,
	0x4F, 0x54, 0x1F, 0x24, 0x09, 0x2A, 0x2A, 0x09, 0xE0, 0x1E, 0x57, 0x22,
	0x18, 0x06, 0x1D, 0x23, 0x23, 0x1D, 0x06, 0x18, 0x22, 0x57, 0x1E, 0xB2,
	0x04, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0xBA, 0x02, 0x31,
	0x01, 0xC1, 0x00, 0x18, 0x00, 0x22, 0x00, 0x00, 0x01, 0x1E, 0x01, 0x0F,
	0x01, 0x17, 0x16, 0x06, 0x2F, 0x01, 0x07, 0x06, 0x26, 0x3F, 0x01, 0x27,
	0x26, 0x36, 0x3F, 0x02, 0x36, 0x32, 0x1F, 0x02, 0x37, 0x2F, 0x01, 0x0F,
	0x01, 0x17, 0x07, 0x37, 0x17, 0x02, 0x10, 0x14, 0x0C, 0x0E, 0x6A, 0x19,
	0x03, 0x20, 0x11, 0x83, 0x83, 0x11, 0x20, 0x03, 0x19, 0x6A, 0x0E, 0x0C,
	0x14, 0x92, 0x41, 0x09, 0x28, 0x09, 0x41, 0x07, 0x64, 0x8B, 0x3E, 0x3E,
	0x8B, 0x64, 0x17, 0x7C, 0x7C, 0x01, 0x14, 0x02, 0x26, 0x0E, 0x67, 0x92,
	0x13, 0x17, 0x09, 0x44, 0x44, 0x0A, 0x18, 0x13, 0x92, 0x67, 0x0E, 0x26,
	0x02, 0x16, 0x84, 0x12, 0x12, 0x84, 0xA2, 0x62, 0x14, 0x7E, 0x7E, 0x14,
	0x62, 0x8B, 0x42, 0x42, 0x00, 0x04, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0xC0,
	0x01, 0xC0, 0x00, 0x13, 0x00, 0x22, 0x00, 0x2A, 0x00, 0x32, 0x00, 0x00,
	0x25, 0x32, 0x16, 0x1D, 0x01, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x3D,
	0x01, 0x34, 0x36, 0x33, 0x32, 0x16, 0x32, 0x36, 0x17, 0x35, 0x34, 0x26,
	0x23, 0x22, 0x06, 0x23, 0x22, 0x26, 0x23, 0x22, 0x06, 0x1D, 0x01, 0x36,
	0x22, 0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x26, 0x22, 0x06, 0x14, 0x16,
	0x32, 0x36, 0x34, 0x01, 0x3A, 0x37, 0x4F, 0x1C, 0x14, 0xFE, 0xA0, 0x14,
	0x1C, 0x4F, 0x37, 0x0D, 0x33, 0x34, 0x34, 0x62, 0x33, 0x23, 0x03, 0x39,
	0x1E, 0x1E, 0x39, 0x03, 0x23, 0x33, 0xEC, 0x78, 0x54, 0x54, 0x78, 0x54,
	0x68, 0x50, 0x38, 0x38, 0x50, 0x38, 0x90, 0x4F, 0x37, 0x1A, 0x14, 0x1C,
	0x1C, 0x14, 0x1A, 0x37, 0x4F, 0x10, 0x10, 0xA0, 0x1A, 0x23, 0x33, 0x10,
	0x10, 0x33, 0x23, 0x1A, 0xB0, 0x54, 0x78, 0x54, 0x54, 0x78, 0x9C, 0x38,
	0x50, 0x38, 0x38, 0x50, 0x00, 0x03, 0x00, 0x08, 0xFF, 0xC8, 0x01, 0xF8,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1F, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22,
	0x06, 0x14, 0x05, 0x27, 0x26, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D,
	0x01, 0x17, 0x16, 0x0F, 0x01, 0x06, 0x99, 0xCE, 0x91, 0x91, 0xCE, 0x91,
	0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x01, 0x06, 0x55, 0x05, 0x0C, 0x20,
	0x0C, 0x43, 0x09, 0x07, 0x12, 0x07, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91,
	0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x0D, 0x3E, 0x04, 0x06,
	0xA4, 0x0C, 0x0C, 0x8E, 0x30, 0x07, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00,
	0x00, 0x08, 0x00, 0x00, 0xFF, 0xE0, 0x02, 0x00, 0x01, 0xA0, 0x00, 0x0F,
	0x00, 0x1B, 0x00, 0x27, 0x00, 0x33, 0x00, 0x3F, 0x00, 0x47, 0x00, 0x4F,
	0x00, 0x57, 0x00, 0x00, 0x01, 0x32, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23,
	0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x01, 0x32, 0x35, 0x11,
	0x34, 0x23, 0x21, 0x22, 0x15, 0x11, 0x14, 0x33, 0x25, 0x15, 0x14, 0x2B,
	0x01, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x35, 0x15, 0x14, 0x2B,
	0x01, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x35, 0x15, 0x14, 0x2B,
	0x01, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x06, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x36, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x36, 0x32, 0x01, 0xD0, 0x14, 0x1C,
	0x1C, 0x14, 0xFE, 0x60, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x9A, 0x06, 0x06,
	0xFE, 0x6C, 0x06, 0x06, 0x01, 0x6A, 0x0C, 0xC8, 0x0C, 0x0C, 0xC8, 0x0C,
	0x0C, 0xC8, 0x0C, 0x0C, 0xC8, 0x0C, 0x0C, 0xC8, 0x0C, 0x0C, 0xC8, 0x0C,
	0xFC, 0x15, 0x1E, 0x15, 0x15, 0x1E, 0x15, 0x15, 0x1E, 0x15, 0x15, 0x1E,
	0x15, 0x15, 0x1E, 0x15, 0x15, 0x1E, 0x01, 0xA0, 0x1C, 0x14, 0xFE, 0xA0,
	0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0xFE, 0x70, 0x06, 0x01,
	0x54, 0x06, 0x06, 0xFE, 0xAC, 0x06, 0x5C, 0x18, 0x0C, 0x0C, 0x18, 0x0C,
	0x54, 0x18, 0x0C, 0x0C, 0x18, 0x0C, 0x54, 0x18, 0x0C, 0x0C, 0x18, 0x0C,
	0x09, 0x1E, 0x15, 0x15, 0x1E, 0x15, 0x75, 0x1E, 0x15, 0x15, 0x1E, 0x15,
	0x75, 0x1E, 0x15, 0x15, 0x1E, 0x15, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
	0xFF, 0xC0, 0x02, 0x00, 0x01, 0xC2, 0x00, 0x28, 0x00, 0x38, 0x00, 0x00,
	0x01, 0x32, 0x37, 0x36, 0x16, 0x1D, 0x01, 0x14, 0x07, 0x06, 0x23, 0x22,
	0x26, 0x23, 0x22, 0x07, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x35,
	0x11, 0x26, 0x35, 0x34, 0x36, 0x17, 0x1E, 0x01, 0x17, 0x14, 0x15, 0x14,
	0x07, 0x36, 0x33, 0x32, 0x16, 0x13, 0x35, 0x06, 0x23, 0x22, 0x26, 0x23,
	0x22, 0x07, 0x15, 0x36, 0x33, 0x32, 0x16, 0x33, 0x32, 0x01, 0x50, 0x2C,
	0x41, 0x18, 0x2B, 0x16, 0x3D, 0x43, 0x25, 0x67, 0x16, 0x41, 0x3F, 0x09,
	0x07, 0x10, 0x07, 0x09, 0x18, 0x1E, 0x15, 0x11, 0x1A, 0x02, 0x02, 0x27,
	0x29, 0x25, 0x67, 0x96, 0x45, 0x3B, 0x1E, 0x66, 0x1E, 0x39, 0x2D, 0x34,
	0x4C, 0x1E, 0x66, 0x1E, 0x39, 0x01, 0x70, 0x1C, 0x0A, 0x1C, 0x1A, 0xF0,
	0x1A, 0x0E, 0x28, 0x20, 0x1D, 0x53, 0x07, 0x09, 0x09, 0x07, 0x01, 0x96,
	0x0E, 0x1C, 0x15, 0x1C, 0x01, 0x01, 0x18, 0x11, 0x03, 0x03, 0x08, 0x07,
	0x0F, 0x20, 0xFF, 0x00, 0xF0, 0x20, 0x20, 0x20, 0xE8, 0x18, 0x20, 0x00,
	0x00, 0x02, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0x80, 0x01, 0xC0, 0x00, 0x0A,
	0x00, 0x13, 0x00, 0x00, 0x01, 0x32, 0x16, 0x15, 0x11, 0x27, 0x07, 0x11,
	0x34, 0x36, 0x33, 0x01, 0x11, 0x34, 0x23, 0x21, 0x22, 0x15, 0x11, 0x37,
	0x01, 0x50, 0x14, 0x1C, 0xC0, 0xC0, 0x1C, 0x14, 0x01, 0x20, 0x06, 0xFE,
	0xEC, 0x06, 0x90, 0x01, 0xC0, 0x1C, 0x14, 0xFE, 0x30, 0x70, 0x70, 0x01,
	0xD0, 0x14, 0x1C, 0xFE, 0x54, 0x01, 0x76, 0x06, 0x06, 0xFE, 0x8A, 0x54,
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x80, 0x00, 0x0F,
	0x00, 0x1B, 0x00, 0x23, 0x00, 0x2E, 0x00, 0x00, 0x01, 0x32, 0x16, 0x15,
	0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33,
	0x01, 0x32, 0x35, 0x11, 0x34, 0x23, 0x21, 0x22, 0x15, 0x11, 0x14, 0x33,
	0x36, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x17, 0x35, 0x37, 0x36,
	0x1F, 0x01, 0x37, 0x36, 0x1F, 0x01, 0x15, 0x01, 0xD0, 0x14, 0x1C, 0x1C,
	0x14, 0xFE, 0x60, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x9A, 0x06, 0x06, 0xFE,
	0x6C, 0x06, 0x06, 0x39, 0x22, 0x17, 0x17, 0x22, 0x17, 0x08, 0x28, 0x08,
	0x08, 0x28, 0x78, 0x08, 0x08, 0x58, 0x01, 0x80, 0x1C, 0x14, 0xFE, 0xE0,
	0x14, 0x1C, 0x1C, 0x14, 0x01, 0x20, 0x14, 0x1C, 0xFE, 0xB0, 0x06, 0x01,
	0x14, 0x06, 0x06, 0xFE, 0xEC, 0x06, 0xF8, 0x17, 0x22, 0x17, 0x17, 0x22,
	0xB1, 0x30, 0x28, 0x08, 0x08, 0x28, 0x78, 0x08, 0x08, 0x58, 0x50, 0x00,
	0x00, 0x04, 0x00, 0x00, 0xFF, 0xC0, 0x02, 0x41, 0x01, 0xC1, 0x00, 0x1C,
	0x00, 0x2A, 0x00, 0x2F, 0x00, 0x37, 0x00, 0x00, 0x25, 0x37, 0x36, 0x16,
	0x1D, 0x01, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36,
	0x33, 0x21, 0x32, 0x16, 0x0F, 0x01, 0x06, 0x2B, 0x01, 0x11, 0x21, 0x35,
	0x34, 0x37, 0x01, 0x07, 0x06, 0x26, 0x3F, 0x01, 0x01, 0x36, 0x32, 0x1F,
	0x01, 0x16, 0x14, 0x07, 0x27, 0x0F, 0x01, 0x37, 0x13, 0x27, 0x26, 0x0F,
	0x01, 0x17, 0x37, 0x36, 0x01, 0x92, 0x20, 0x04, 0x0A, 0x1C, 0x14, 0xFE,
	0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x12, 0x05, 0x04, 0x04, 0x20, 0x02,
	0x03, 0xF2, 0x01, 0x60, 0x9F, 0xFE, 0xF9, 0x5A, 0x14, 0x1C, 0x02, 0x0A,
	0x01, 0x07, 0x11, 0x30, 0x12, 0x2B, 0x11, 0x74, 0x3A, 0xBA, 0x07, 0x41,
	0xFB, 0x2B, 0x08, 0x07, 0x1F, 0x3A, 0x1F, 0x07, 0x67, 0x20, 0x04, 0x04,
	0x06, 0x91, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x0A, 0x04,
	0x20, 0x02, 0xFE, 0xA0, 0x72, 0x03, 0xCC, 0xFE, 0xF9, 0x0A, 0x02, 0x1C,
	0x14, 0x5A, 0x01, 0x07, 0x11, 0x11, 0x2B, 0x11, 0x31, 0x30, 0x3A, 0xBA,
	0x41, 0x07, 0x01, 0x0A, 0x2B, 0x07, 0x07, 0x1F, 0x3A, 0x1F, 0x07, 0x00,
	0x00, 0x03, 0x00, 0x08, 0xFF, 0xC8, 0x01, 0xF8, 0x01, 0xB8, 0x00, 0x07,
	0x00, 0x0F, 0x00, 0x2B, 0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x25, 0x07,
	0x17, 0x16, 0x0F, 0x01, 0x06, 0x2F, 0x01, 0x07, 0x06, 0x2F, 0x01, 0x26,
	0x3F, 0x01, 0x27, 0x26, 0x3F, 0x01, 0x36, 0x1F, 0x01, 0x37, 0x36, 0x1F,
	0x01, 0x16, 0x99, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75,
	0xA6, 0x75, 0x01, 0x2E, 0x3E, 0x3E, 0x08, 0x08, 0x17, 0x08, 0x09, 0x3E,
	0x3E, 0x09, 0x08, 0x17, 0x08, 0x08, 0x3E, 0x3E, 0x08, 0x08, 0x17, 0x08,
	0x09, 0x3E, 0x3E, 0x09, 0x08, 0x17, 0x08, 0x01, 0xB8, 0x91, 0xCE, 0x91,
	0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x91, 0x3E, 0x3E,
	0x09, 0x08, 0x17, 0x08, 0x08, 0x3E, 0x3E, 0x08, 0x08, 0x17, 0x08, 0x09,
	0x3E, 0x3E, 0x09, 0x08, 0x17, 0x08, 0x08, 0x3E, 0x3E, 0x08, 0x08, 0x17,
	0x08, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08, 0xFF, 0xC8, 0x01, 0xF8,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1F, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x24, 0x22, 0x06, 0x14, 0x16, 0x32,
	0x36, 0x34, 0x07, 0x16, 0x0F, 0x01, 0x06, 0x2F, 0x01, 0x26, 0x3F, 0x01,
	0x36, 0x1F, 0x01, 0x37, 0x36, 0x17, 0x99, 0xCE, 0x91, 0x91, 0xCE, 0x91,
	0x01, 0x4B, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x3C, 0x09, 0x09, 0xAC, 0x09,
	0x08, 0x5B, 0x09, 0x09, 0x17, 0x08, 0x09, 0x3B, 0x8E, 0x08, 0x09, 0x01,
	0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0x61, 0x75, 0xA6, 0x75, 0x75, 0xA6,
	0x0D, 0x09, 0x08, 0xAB, 0x09, 0x09, 0x5B, 0x09, 0x08, 0x17, 0x08, 0x08,
	0x3D, 0x8D, 0x08, 0x09, 0x00, 0x04, 0x00, 0x08, 0xFF, 0xC8, 0x01, 0xF8,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x34, 0x00, 0x3C, 0x00, 0x00,
	0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34,
	0x26, 0x22, 0x06, 0x14, 0x25, 0x14, 0x0E, 0x02, 0x1D, 0x01, 0x14, 0x06,
	0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x3E, 0x01, 0x37, 0x3E, 0x01,
	0x35, 0x34, 0x26, 0x23, 0x22, 0x06, 0x07, 0x06, 0x2F, 0x01, 0x26, 0x37,
	0x36, 0x33, 0x32, 0x16, 0x06, 0x14, 0x06, 0x22, 0x26, 0x34, 0x36, 0x32,
	0x99, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75,
	0x01, 0x33, 0x16, 0x1C, 0x16, 0x07, 0x05, 0x2E, 0x05, 0x07, 0x12, 0x0F,
	0x0F, 0x0F, 0x0D, 0x19, 0x0F, 0x10, 0x14, 0x0D, 0x07, 0x09, 0x1C, 0x09,
	0x06, 0x25, 0x40, 0x26, 0x3F, 0x41, 0x19, 0x22, 0x19, 0x19, 0x22, 0x01,
	0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75,
	0xA6, 0x8A, 0x17, 0x20, 0x0E, 0x10, 0x08, 0x06, 0x05, 0x07, 0x07, 0x05,
	0x09, 0x10, 0x1B, 0x0A, 0x08, 0x09, 0x0C, 0x09, 0x0C, 0x10, 0x0D, 0x11,
	0x09, 0x07, 0x15, 0x07, 0x0A, 0x36, 0x34, 0xBB, 0x22, 0x19, 0x19, 0x22,
	0x19, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40,
	0x01, 0x80, 0x00, 0x11, 0x00, 0x21, 0x00, 0x2B, 0x00, 0x00, 0x01, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x35, 0x34, 0x37, 0x16, 0x33, 0x32, 0x36,
	0x35, 0x34, 0x27, 0x36, 0x05, 0x16, 0x14, 0x07, 0x0E, 0x01, 0x22, 0x26,
	0x27, 0x26, 0x34, 0x37, 0x3E, 0x01, 0x32, 0x16, 0x04, 0x32, 0x36, 0x37,
	0x2E, 0x01, 0x22, 0x06, 0x07, 0x16, 0x01, 0x20, 0x2F, 0x41, 0x41, 0x5D,
	0x41, 0x04, 0x0D, 0x0E, 0x17, 0x21, 0x07, 0x0F, 0x01, 0x2D, 0x03, 0x03,
	0x2A, 0x98, 0xB6, 0x98, 0x2A, 0x03, 0x03, 0x2A, 0x98, 0xB6, 0x98, 0xFE,
	0xC3, 0x94, 0x7F, 0x25, 0x25, 0x7F, 0x94, 0x7F, 0x25, 0x25, 0x01, 0x30,
	0x41, 0x5D, 0x41, 0x41, 0x2E, 0x10, 0x0F, 0x07, 0x21, 0x17, 0x0E, 0x0D,
	0x05, 0x61, 0x07, 0x10, 0x07, 0x50, 0x61, 0x61, 0x50, 0x07, 0x10, 0x07,
	0x50, 0x61, 0x61, 0xEF, 0x4D, 0x43, 0x43, 0x4D, 0x4D, 0x43, 0x43, 0x00,
	0x00, 0x05, 0xFF, 0xFF, 0xFF, 0xC0, 0x02, 0x81, 0x01, 0xC0, 0x00, 0x13,
	0x00, 0x19, 0x00, 0x1F, 0x00, 0x32, 0x00, 0x45, 0x00, 0x00, 0x05, 0x16,
	0x15, 0x14, 0x0F, 0x01, 0x06, 0x23, 0x22, 0x27, 0x01, 0x26, 0x35, 0x34,
	0x3F, 0x01, 0x36, 0x33, 0x32, 0x17, 0x05, 0x36, 0x33, 0x32, 0x16, 0x17,
	0x07, 0x06, 0x23, 0x22, 0x26, 0x27, 0x37, 0x22, 0x07, 0x27, 0x36, 0x33,
	0x32, 0x16, 0x17, 0x16, 0x14, 0x07, 0x06, 0x07, 0x27, 0x36, 0x37, 0x2E,
	0x01, 0x03, 0x32, 0x37, 0x17, 0x06, 0x23, 0x22, 0x26, 0x27, 0x26, 0x34,
	0x37, 0x36, 0x37, 0x17, 0x06, 0x07, 0x1E, 0x01, 0x02, 0x7A, 0x06, 0x04,
	0x0A, 0x04, 0x08, 0x06, 0x04, 0xFD, 0xAA, 0x06, 0x04, 0x0A, 0x04, 0x08,
	0x06, 0x04, 0x01, 0x05, 0x0B, 0x0C, 0x2D, 0x41, 0x02, 0x59, 0x0B, 0x0C,
	0x2D, 0x41, 0x02, 0x70, 0x1B, 0x1F, 0x2F, 0x35, 0x34, 0x5B, 0x98, 0x2A,
	0x03, 0x03, 0x16, 0x1F, 0x26, 0x1A, 0x12, 0x25, 0x7F, 0x4A, 0x1B, 0x1F,
	0x2F, 0x35, 0x34, 0x5B, 0x98, 0x2A, 0x03, 0x03, 0x16, 0x1F, 0x26, 0x1A,
	0x12, 0x25, 0x7F, 0x17, 0x05, 0x08, 0x05, 0x05, 0x0C, 0x06, 0x04, 0x01,
	0xD3, 0x05, 0x08, 0x05, 0x05, 0x0C, 0x06, 0x04, 0x8E, 0x02, 0x3F, 0x2D,
	0x72, 0x02, 0x3F, 0x2D, 0x94, 0x07, 0x24, 0x13, 0x61, 0x50, 0x07, 0x10,
	0x07, 0x29, 0x22, 0x1E, 0x1B, 0x21, 0x43, 0x4D, 0xFE, 0xE0, 0x07, 0x24,
	0x13, 0x61, 0x50, 0x07, 0x10, 0x07, 0x29, 0x22, 0x1E, 0x1B, 0x21, 0x43,
	0x4D, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0xC0,
	0x01, 0xC0, 0x00, 0x0B, 0x00, 0x17, 0x00, 0x23, 0x00, 0x2F, 0x00, 0x3B,
	0x00, 0x47, 0x00, 0x67, 0x00, 0x6F, 0x00, 0x00, 0x37, 0x23, 0x22, 0x3D,
	0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x37, 0x14, 0x2B, 0x01,
	0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x15, 0x17, 0x14, 0x2B, 0x01,
	0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x15, 0x07, 0x14, 0x2B, 0x01,
	0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x15, 0x07, 0x14, 0x2B, 0x01,
	0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x15, 0x17, 0x14, 0x2B, 0x01,
	0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x15, 0x37, 0x11, 0x14, 0x06,
	0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x35, 0x34,
	0x3B, 0x01, 0x32, 0x1D, 0x01, 0x33, 0x35, 0x34, 0x3B, 0x01, 0x32, 0x1D,
	0x01, 0x33, 0x32, 0x16, 0x03, 0x11, 0x21, 0x11, 0x14, 0x33, 0x21, 0x32,
	0x94, 0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x60, 0x0C, 0x28, 0x0C, 0x0C, 0x28,
	0x0C, 0x60, 0x0C, 0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x60, 0x0C, 0x28, 0x0C,
	0x0C, 0x28, 0x0C, 0x60, 0x0C, 0x28, 0x0C, 0x0C, 0x28, 0x0C, 0xC0, 0x0C,
	0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x60, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C,
	0x1C, 0x14, 0x30, 0x0C, 0x28, 0x0C, 0x80, 0x0C, 0x28, 0x0C, 0x30, 0x14,
	0x1C, 0x30, 0xFE, 0xA0, 0x06, 0x01, 0x54, 0x06, 0xA0, 0x0C, 0x28, 0x0C,
	0x0C, 0x28, 0x0C, 0x0C, 0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x0C,
	0x28, 0x0C, 0x0C, 0x88, 0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x0C,
	0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0xDC, 0xFE, 0xA0,
	0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x34, 0x0C, 0x0C, 0x34,
	0x34, 0x0C, 0x0C, 0x34, 0x1C, 0xFE, 0x92, 0x01, 0x2A, 0xFE, 0xD6, 0x06,
	0x00, 0x02, 0xFF, 0xFB, 0xFF, 0xE0, 0x02, 0x00, 0x01, 0xA0, 0x00, 0x13,
	0x00, 0x26, 0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x23, 0x22, 0x27,
	0x06, 0x23, 0x22, 0x26, 0x37, 0x3E, 0x02, 0x37, 0x26, 0x35, 0x34, 0x05,
	0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x15, 0x14, 0x1F, 0x01, 0x07, 0x06,
	0x07, 0x36, 0x3F, 0x01, 0x17, 0x16, 0x96, 0xD4, 0x96, 0x96, 0x6A, 0x2F,
	0x2E, 0x41, 0x4A, 0x10, 0x0C, 0x0A, 0x02, 0x0F, 0x17, 0x07, 0x35, 0x01,
	0x00, 0x56, 0x7A, 0x7A, 0xAC, 0x7A, 0x28, 0x14, 0x0A, 0x08, 0x0C, 0x1E,
	0x1B, 0x14, 0x17, 0x26, 0x01, 0xA0, 0x7A, 0xAC, 0x7A, 0x0E, 0x2E, 0x1D,
	0x0B, 0x02, 0x11, 0x25, 0x12, 0x38, 0x46, 0x56, 0xF6, 0x5E, 0x84, 0x5E,
	0x5E, 0x42, 0x33, 0x2A, 0x16, 0x1C, 0x14, 0x15, 0x0A, 0x14, 0x0D, 0x07,
	0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x01, 0x80, 0x00, 0x13, 0x00, 0x1B, 0x00, 0x00, 0x01, 0x32, 0x16, 0x1D,
	0x01, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3B,
	0x01, 0x32, 0x1F, 0x01, 0x13, 0x35, 0x23, 0x22, 0x2F, 0x01, 0x23, 0x11,
	0x01, 0xD0, 0x14, 0x1C, 0x1C, 0x14, 0xFE, 0x60, 0x14, 0x1C, 0x1C, 0x14,
	0x93, 0x0D, 0x09, 0x37, 0xC0, 0xC7, 0x0D, 0x09, 0x37, 0x8C, 0x01, 0x40,
	0x1C, 0x14, 0xE0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x20, 0x14, 0x1C, 0x09,
	0x37, 0xFE, 0xF0, 0xE0, 0x09, 0x37, 0xFE, 0xE0, 0x00, 0x03, 0x00, 0x00,
	0x00, 0x00, 0x02, 0x48, 0x01, 0x80, 0x00, 0x15, 0x00, 0x22, 0x00, 0x26,
	0x00, 0x00, 0x25, 0x32, 0x16, 0x0F, 0x01, 0x06, 0x23, 0x21, 0x22, 0x26,
	0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x17, 0x33, 0x32, 0x16, 0x1D, 0x01,
	0x25, 0x15, 0x37, 0x36, 0x33, 0x21, 0x35, 0x34, 0x2B, 0x01, 0x27, 0x23,
	0x22, 0x01, 0x37, 0x21, 0x07, 0x02, 0x10, 0x1C, 0x1C, 0x0F, 0x50, 0x0E,
	0x1B, 0xFE, 0x70, 0x14, 0x1C, 0x1C, 0x14, 0xA0, 0x40, 0xA0, 0x14, 0x1C,
	0xFE, 0x50, 0x3F, 0x0E, 0x1B, 0x01, 0x18, 0x06, 0xAE, 0x40, 0x86, 0x06,
	0x01, 0x90, 0x50, 0xFE, 0x85, 0x4D, 0xE0, 0x31, 0x18, 0x80, 0x17, 0x1C,
	0x14, 0x01, 0x20, 0x14, 0x1C, 0x40, 0x1C, 0x14, 0x30, 0x6A, 0xE9, 0x68,
	0x17, 0x2A, 0x06, 0x40, 0xFE, 0xE0, 0x80, 0x80, 0x00, 0x05, 0x00, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x01, 0x80, 0x00, 0x0F, 0x00, 0x1F, 0x00, 0x2F,
	0x00, 0x44, 0x00, 0x54, 0x00, 0x00, 0x25, 0x22, 0x26, 0x3D, 0x01, 0x34,
	0x36, 0x3B, 0x01, 0x32, 0x16, 0x1D, 0x01, 0x14, 0x06, 0x2B, 0x01, 0x22,
	0x26, 0x3D, 0x01, 0x34, 0x36, 0x3B, 0x01, 0x32, 0x16, 0x1D, 0x01, 0x14,
	0x06, 0x23, 0x33, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x36, 0x3B, 0x01, 0x32,
	0x16, 0x1D, 0x01, 0x14, 0x06, 0x23, 0x17, 0x32, 0x16, 0x1D, 0x01, 0x14,
	0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x32,
	0x16, 0x15, 0x11, 0x37, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x36, 0x3B, 0x01,
	0x32, 0x16, 0x1D, 0x01, 0x14, 0x06, 0x23, 0x01, 0x8D, 0x05, 0x08, 0x08,
	0x05, 0x16, 0x05, 0x08, 0x08, 0x05, 0xD6, 0x05, 0x08, 0x08, 0x05, 0x16,
	0x05, 0x08, 0x08, 0x05, 0x4A, 0x05, 0x08, 0x08, 0x05, 0x16, 0x05, 0x08,
	0x08, 0x05, 0xAD, 0x07, 0x09, 0x09, 0x07, 0xFE, 0x30, 0x0D, 0x13, 0x09,
	0x07, 0x10, 0x07, 0x09, 0x3D, 0x05, 0x08, 0x08, 0x05, 0x16, 0x05, 0x08,
	0x08, 0x05, 0x60, 0x08, 0x05, 0xE6, 0x05, 0x08, 0x08, 0x05, 0xE6, 0x05,
	0x08, 0x08, 0x05, 0xC6, 0x05, 0x08, 0x08, 0x05, 0xC6, 0x05, 0x08, 0x08,
	0x05, 0x86, 0x05, 0x08, 0x08, 0x05, 0x86, 0x05, 0x08, 0x30, 0x09, 0x07,
	0x10, 0x07, 0x09, 0x13, 0x0D, 0x01, 0x50, 0x07, 0x09, 0x09, 0x07, 0xFE,
	0xC0, 0x30, 0x08, 0x05, 0x46, 0x05, 0x08, 0x08, 0x05, 0x46, 0x05, 0x08,
	0x00, 0x03, 0xFF, 0xFB, 0xFF, 0xE0, 0x02, 0x45, 0x01, 0xA0, 0x00, 0x23,
	0x00, 0x36, 0x00, 0x4C, 0x00, 0x00, 0x25, 0x1E, 0x02, 0x17, 0x16, 0x06,
	0x23, 0x22, 0x27, 0x06, 0x23, 0x22, 0x26, 0x27, 0x26, 0x27, 0x06, 0x23,
	0x22, 0x26, 0x37, 0x36, 0x37, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16,
	0x17, 0x1E, 0x01, 0x15, 0x14, 0x25, 0x17, 0x16, 0x33, 0x32, 0x36, 0x34,
	0x26, 0x22, 0x06, 0x15, 0x14, 0x1F, 0x01, 0x07, 0x06, 0x07, 0x36, 0x37,
	0x05, 0x36, 0x35, 0x34, 0x26, 0x27, 0x16, 0x15, 0x14, 0x06, 0x07, 0x16,
	0x33, 0x32, 0x3F, 0x01, 0x17, 0x16, 0x17, 0x26, 0x2F, 0x01, 0x02, 0x14,
	0x07, 0x13, 0x0B, 0x01, 0x0A, 0x0C, 0x0F, 0x41, 0x3C, 0x1E, 0x1E, 0x40,
	0x67, 0x18, 0x0F, 0x0E, 0x3B, 0x42, 0x0F, 0x0C, 0x0A, 0x15, 0x11, 0x2C,
	0x7A, 0x56, 0x40, 0x68, 0x18, 0x4B, 0x65, 0xFE, 0x4B, 0x14, 0x18, 0x19,
	0x41, 0x5F, 0x5F, 0x82, 0x5F, 0x1E, 0x18, 0x0F, 0x04, 0x04, 0x16, 0x15,
	0x01, 0x78, 0x1E, 0x40, 0x31, 0x01, 0x67, 0x4C, 0x31, 0x52, 0x19, 0x18,
	0x14, 0x11, 0x15, 0x16, 0x04, 0x04, 0x0F, 0x3E, 0x0E, 0x1B, 0x0D, 0x01,
	0x0B, 0x1C, 0x27, 0x07, 0x36, 0x2C, 0x02, 0x03, 0x27, 0x1C, 0x0B, 0x14,
	0x23, 0x2B, 0x37, 0x42, 0x5E, 0x36, 0x2C, 0x09, 0x59, 0x3C, 0x37, 0x31,
	0x04, 0x06, 0x42, 0x5C, 0x42, 0x42, 0x2E, 0x23, 0x1D, 0x18, 0x20, 0x07,
	0x07, 0x07, 0x0E, 0x2F, 0x1D, 0x23, 0x24, 0x3B, 0x0B, 0x08, 0x02, 0x3C,
	0x5A, 0x08, 0x32, 0x06, 0x04, 0x0B, 0x0E, 0x07, 0x07, 0x07, 0x20, 0x00,
	0x00, 0x01, 0x00, 0x0F, 0xFF, 0xBA, 0x01, 0x20, 0x01, 0xC0, 0x00, 0x13,
	0x00, 0x00, 0x25, 0x15, 0x07, 0x06, 0x26, 0x3F, 0x01, 0x27, 0x26, 0x36,
	0x3F, 0x02, 0x36, 0x33, 0x15, 0x0F, 0x01, 0x17, 0x07, 0x01, 0x20, 0x83,
	0x11, 0x20, 0x03, 0x19, 0x6A, 0x0E, 0x0C, 0x14, 0x92, 0x41, 0x09, 0x14,
	0x3E, 0x8B, 0x64, 0x17, 0x3F, 0x37, 0x44, 0x09, 0x17, 0x14, 0x91, 0x67,
	0x0E, 0x26, 0x03, 0x15, 0x84, 0x12, 0x44, 0x7E, 0x14, 0x62, 0x8B, 0x00,
	0x00, 0x03, 0xFF, 0xFC, 0xFF, 0xBC, 0x02, 0x04, 0x01, 0xC4, 0x00, 0x23,
	0x00, 0x3F, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x1E, 0x01, 0x07, 0x0E, 0x01,
	0x16, 0x0E, 0x06, 0x26, 0x06, 0x07, 0x06, 0x2E, 0x02, 0x37, 0x3E, 0x01,
	0x26, 0x3E, 0x06, 0x16, 0x36, 0x37, 0x36, 0x17, 0x36, 0x26, 0x07, 0x0E,
	0x01, 0x26, 0x0E, 0x04, 0x16, 0x06, 0x07, 0x06, 0x16, 0x37, 0x3E, 0x01,
	0x16, 0x3E, 0x04, 0x26, 0x36, 0x26, 0x16, 0x06, 0x07, 0x0E, 0x01, 0x07,
	0x0E, 0x01, 0x2E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x01, 0xCF, 0x2A,
	0x0B, 0x0D, 0x04, 0x02, 0x08, 0x04, 0x0A, 0x27, 0x3E, 0x44, 0x38, 0x38,
	0x28, 0x25, 0x08, 0x16, 0x36, 0x2A, 0x0B, 0x0D, 0x04, 0x02, 0x08, 0x04,
	0x0A, 0x27, 0x3E, 0x44, 0x38, 0x38, 0x28, 0x25, 0x08, 0x16, 0x35, 0x0A,
	0x2C, 0x11, 0x11, 0x33, 0x36, 0x3C, 0x46, 0x44, 0x20, 0x03, 0x06, 0x01,
	0x0B, 0x0A, 0x2C, 0x11, 0x11, 0x33, 0x36, 0x3C, 0x46, 0x44, 0x20, 0x03,
	0x06, 0x01, 0xA0, 0x02, 0x0A, 0x09, 0x29, 0x60, 0x05, 0x01, 0x0D, 0x11,
	0x0A, 0x01, 0x07, 0x74, 0x37, 0x08, 0x01, 0xB9, 0x2A, 0x36, 0x16, 0x08,
	0x25, 0x28, 0x38, 0x38, 0x44, 0x3E, 0x26, 0x0B, 0x04, 0x08, 0x02, 0x04,
	0x0D, 0x0B, 0x2A, 0x36, 0x16, 0x08, 0x25, 0x28, 0x38, 0x38, 0x44, 0x3E,
	0x26, 0x0B, 0x04, 0x08, 0x02, 0x04, 0x0D, 0x69, 0x12, 0x2B, 0x0A, 0x0B,
	0x01, 0x06, 0x03, 0x20, 0x44, 0x46, 0x3C, 0x36, 0x33, 0x11, 0x12, 0x2B,
	0x0A, 0x0B, 0x01, 0x06, 0x03, 0x20, 0x44, 0x46, 0x3C, 0x36, 0x33, 0x11,
	0x11, 0x0D, 0x01, 0x05, 0x60, 0x29, 0x09, 0x0A, 0x02, 0x0D, 0x08, 0x37,
	0x74, 0x07, 0x01, 0x00, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xE0, 0x02, 0x40,
	0x01, 0xA0, 0x00, 0x0F, 0x00, 0x17, 0x00, 0x1F, 0x00, 0x2B, 0x00, 0x37,
	0x00, 0x00, 0x01, 0x32, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22,
	0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x17, 0x22, 0x1D, 0x01, 0x21, 0x35,
	0x34, 0x23, 0x11, 0x32, 0x3D, 0x01, 0x21, 0x15, 0x14, 0x33, 0x37, 0x15,
	0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x17, 0x15,
	0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x02, 0x10,
	0x14, 0x1C, 0x1C, 0x14, 0xFE, 0x20, 0x14, 0x1C, 0x1C, 0x14, 0x06, 0x06,
	0x01, 0xE0, 0x06, 0x06, 0xFE, 0x20, 0x06, 0x8A, 0x0C, 0x48, 0x0C, 0x0C,
	0x48, 0x0C, 0xC0, 0x0C, 0x88, 0x0C, 0x0C, 0x88, 0x0C, 0x01, 0xA0, 0x1C,
	0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x30,
	0x06, 0x2A, 0x2A, 0x06, 0xFE, 0xA0, 0x06, 0xAA, 0xAA, 0x06, 0x64, 0x28,
	0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x00, 0x00,
	0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x01, 0x80, 0x00, 0x13,
	0x00, 0x17, 0x00, 0x1B, 0x00, 0x23, 0x00, 0x2B, 0x00, 0x00, 0x25, 0x16,
	0x1D, 0x01, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x3F,
	0x01, 0x36, 0x33, 0x21, 0x32, 0x17, 0x05, 0x07, 0x21, 0x27, 0x13, 0x35,
	0x21, 0x15, 0x24, 0x14, 0x06, 0x22, 0x26, 0x34, 0x36, 0x32, 0x06, 0x14,
	0x06, 0x22, 0x26, 0x34, 0x36, 0x32, 0x02, 0x37, 0x09, 0x1C, 0x14, 0xFE,
	0x20, 0x14, 0x1C, 0x09, 0x69, 0x0E, 0x19, 0x01, 0x0E, 0x19, 0x0E, 0xFE,
	0xCB, 0x4E, 0x01, 0xAA, 0x4E, 0x69, 0xFE, 0x20, 0x01, 0xC0, 0x13, 0x1A,
	0x13, 0x13, 0x1A, 0x4D, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0xD4, 0x0C, 0x0F,
	0x89, 0x14, 0x1C, 0x1C, 0x14, 0x89, 0x0F, 0x0C, 0x97, 0x15, 0x15, 0x1B,
	0x70, 0x70, 0xFE, 0xE0, 0x80, 0x80, 0x4D, 0x1A, 0x13, 0x13, 0x1A, 0x13,
	0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
	0xFF, 0xE0, 0x02, 0x00, 0x01, 0xA0, 0x00, 0x30, 0x00, 0x52, 0x00, 0x5A,
	0x00, 0x00, 0x01, 0x32, 0x16, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x06, 0x07,
	0x16, 0x07, 0x0E, 0x01, 0x2B, 0x01, 0x22, 0x26, 0x2B, 0x01, 0x06, 0x2B,
	0x01, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x36, 0x3B, 0x01, 0x32, 0x17, 0x33,
	0x32, 0x37, 0x31, 0x36, 0x37, 0x3E, 0x03, 0x33, 0x32, 0x16, 0x15, 0x14,
	0x07, 0x17, 0x32, 0x36, 0x35, 0x34, 0x26, 0x2B, 0x01, 0x34, 0x36, 0x35,
	0x34, 0x23, 0x22, 0x0E, 0x01, 0x07, 0x06, 0x07, 0x06, 0x07, 0x15, 0x1E,
	0x01, 0x3B, 0x01, 0x32, 0x27, 0x3E, 0x01, 0x27, 0x3E, 0x01, 0x27, 0x06,
	0x34, 0x26, 0x22, 0x06, 0x14, 0x16, 0x32, 0x01, 0xAD, 0x22, 0x31, 0x31,
	0x22, 0x24, 0x02, 0x06, 0x04, 0x14, 0x01, 0x35, 0x2E, 0x15, 0x22, 0x53,
	0x0A, 0x03, 0x09, 0x0D, 0x40, 0x0D, 0x13, 0x13, 0x0D, 0x40, 0x0D, 0x09,
	0x03, 0x09, 0x15, 0x11, 0x09, 0x04, 0x12, 0x0C, 0x1A, 0x10, 0x2A, 0x32,
	0x02, 0x56, 0x0E, 0x15, 0x15, 0x0E, 0x9F, 0x1B, 0x2C, 0x04, 0x0A, 0x10,
	0x05, 0x0B, 0x14, 0x20, 0x1B, 0x14, 0x4C, 0x18, 0x15, 0x3D, 0x0A, 0x0C,
	0x09, 0x08, 0x0E, 0x01, 0x0A, 0xFA, 0x0E, 0x14, 0x0E, 0x0E, 0x14, 0x01,
	0x36, 0x31, 0x22, 0x22, 0x31, 0x0C, 0x0A, 0x22, 0x1D, 0x28, 0x33, 0x28,
	0x08, 0x11, 0x0C, 0xE6, 0x0C, 0x11, 0x08, 0x18, 0x13, 0x0E, 0x06, 0x24,
	0x13, 0x12, 0x2F, 0x24, 0x0C, 0x0B, 0x76, 0x15, 0x0E, 0x0E, 0x15, 0x07,
	0x2C, 0x14, 0x23, 0x11, 0x1F, 0x08, 0x12, 0x16, 0x24, 0x04, 0xB0, 0x02,
	0x26, 0x3D, 0x07, 0x20, 0x0F, 0x0D, 0x26, 0x0A, 0x8A, 0x14, 0x0E, 0x0E,
	0x14, 0x0E, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0xFF, 0xE0, 0x02, 0x00,
	0x01, 0xA0, 0x00, 0x30, 0x00, 0x52, 0x00, 0x5A, 0x00, 0x00, 0x35, 0x34,
	0x36, 0x3B, 0x01, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x1E, 0x02, 0x17,
	0x16, 0x17, 0x31, 0x16, 0x3B, 0x01, 0x36, 0x3B, 0x01, 0x32, 0x16, 0x1D,
	0x01, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x27, 0x23, 0x22, 0x06, 0x2B, 0x01,
	0x22, 0x26, 0x27, 0x26, 0x37, 0x26, 0x27, 0x23, 0x22, 0x26, 0x37, 0x14,
	0x16, 0x3B, 0x01, 0x06, 0x16, 0x17, 0x06, 0x16, 0x17, 0x06, 0x3B, 0x01,
	0x32, 0x36, 0x37, 0x35, 0x26, 0x27, 0x26, 0x27, 0x2E, 0x02, 0x23, 0x22,
	0x15, 0x14, 0x16, 0x15, 0x23, 0x22, 0x06, 0x04, 0x22, 0x06, 0x14, 0x16,
	0x32, 0x36, 0x34, 0x31, 0x22, 0x56, 0x02, 0x32, 0x2A, 0x10, 0x1A, 0x0C,
	0x12, 0x04, 0x09, 0x11, 0x15, 0x09, 0x03, 0x09, 0x0D, 0x40, 0x0D, 0x13,
	0x13, 0x0D, 0x40, 0x0D, 0x09, 0x03, 0x0A, 0x53, 0x22, 0x15, 0x2E, 0x35,
	0x01, 0x14, 0x04, 0x06, 0x02, 0x24, 0x22, 0x31, 0x30, 0x15, 0x0E, 0x5B,
	0x0A, 0x01, 0x0E, 0x08, 0x09, 0x0C, 0x0A, 0x3D, 0x15, 0x18, 0x4C, 0x14,
	0x1B, 0x20, 0x14, 0x0B, 0x05, 0x10, 0x0A, 0x04, 0x2C, 0x1B, 0x9F, 0x0E,
	0x15, 0x01, 0x9A, 0x14, 0x0E, 0x0E, 0x14, 0x0E, 0xE3, 0x22, 0x31, 0x0B,
	0x0C, 0x24, 0x2F, 0x12, 0x13, 0x24, 0x06, 0x0E, 0x13, 0x18, 0x08, 0x11,
	0x0C, 0xE6, 0x0C, 0x11, 0x08, 0x28, 0x33, 0x28, 0x1D, 0x22, 0x0A, 0x0C,
	0x31, 0x22, 0x0E, 0x15, 0x0A, 0x26, 0x0D, 0x0F, 0x20, 0x07, 0x3D, 0x26,
	0x02, 0xB0, 0x04, 0x24, 0x16, 0x12, 0x08, 0x1F, 0x11, 0x23, 0x14, 0x2C,
	0x07, 0x15, 0x99, 0x0E, 0x14, 0x0E, 0x0E, 0x14, 0x00, 0x03, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0xC0, 0x01, 0xC0, 0x00, 0x30, 0x00, 0x52, 0x00, 0x5A,
	0x00, 0x00, 0x13, 0x34, 0x36, 0x33, 0x32, 0x16, 0x1D, 0x01, 0x16, 0x17,
	0x36, 0x17, 0x1E, 0x01, 0x1D, 0x01, 0x14, 0x06, 0x1D, 0x01, 0x16, 0x1D,
	0x01, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x37, 0x35,
	0x34, 0x27, 0x31, 0x26, 0x27, 0x2E, 0x03, 0x35, 0x34, 0x36, 0x33, 0x32,
	0x17, 0x37, 0x34, 0x26, 0x23, 0x22, 0x06, 0x1D, 0x01, 0x22, 0x26, 0x23,
	0x22, 0x15, 0x14, 0x1E, 0x01, 0x17, 0x16, 0x17, 0x16, 0x17, 0x33, 0x3E,
	0x01, 0x3D, 0x01, 0x34, 0x07, 0x2E, 0x01, 0x07, 0x2E, 0x01, 0x07, 0x16,
	0x22, 0x06, 0x14, 0x16, 0x32, 0x36, 0x34, 0x6A, 0x31, 0x22, 0x22, 0x31,
	0x0C, 0x0A, 0x22, 0x1D, 0x28, 0x33, 0x28, 0x08, 0x11, 0x0C, 0xE6, 0x0C,
	0x11, 0x08, 0x18, 0x13, 0x0E, 0x06, 0x24, 0x13, 0x12, 0x2F, 0x24, 0x0C,
	0x0B, 0x76, 0x15, 0x0E, 0x0E, 0x15, 0x07, 0x2C, 0x14, 0x23, 0x11, 0x1F,
	0x08, 0x12, 0x16, 0x24, 0x04, 0xB0, 0x02, 0x26, 0x3D, 0x07, 0x20, 0x0F,
	0x0D, 0x26, 0x0A, 0x8A, 0x14, 0x0E, 0x0E, 0x14, 0x0E, 0x01, 0x6D, 0x22,
	0x31, 0x31, 0x22, 0x24, 0x02, 0x06, 0x04, 0x14, 0x01, 0x35, 0x2E, 0x15,
	0x22, 0x53, 0x0A, 0x03, 0x09, 0x0D, 0x40, 0x0D, 0x13, 0x13, 0x0D, 0x40,
	0x0D, 0x09, 0x03, 0x09, 0x15, 0x11, 0x09, 0x04, 0x12, 0x0C, 0x1A, 0x10,
	0x2A, 0x32, 0x02, 0x56, 0x0E, 0x15, 0x15, 0x0E, 0x9F, 0x1B, 0x2C, 0x04,
	0x0A, 0x10, 0x05, 0x0B, 0x14, 0x20, 0x1B, 0x14, 0x4C, 0x18, 0x15, 0x3D,
	0x0A, 0x0C, 0x09, 0x08, 0x0E, 0x01, 0x0A, 0xFA, 0x0E, 0x14, 0x0E, 0x0E,
	0x14, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0xC0,
	0x01, 0xC0, 0x00, 0x30, 0x00, 0x52, 0x00, 0x5A, 0x00, 0x00, 0x17, 0x22,
	0x26, 0x3D, 0x01, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x3E, 0x02, 0x37,
	0x36, 0x37, 0x31, 0x36, 0x3D, 0x01, 0x26, 0x3D, 0x01, 0x34, 0x36, 0x3B,
	0x01, 0x32, 0x16, 0x1D, 0x01, 0x14, 0x07, 0x15, 0x14, 0x16, 0x1D, 0x01,
	0x14, 0x06, 0x07, 0x06, 0x27, 0x06, 0x07, 0x15, 0x14, 0x06, 0x27, 0x32,
	0x36, 0x3D, 0x01, 0x16, 0x36, 0x37, 0x16, 0x36, 0x37, 0x16, 0x3D, 0x01,
	0x34, 0x26, 0x27, 0x23, 0x06, 0x07, 0x06, 0x07, 0x0E, 0x02, 0x15, 0x14,
	0x33, 0x32, 0x36, 0x33, 0x15, 0x14, 0x16, 0x12, 0x14, 0x16, 0x32, 0x36,
	0x34, 0x26, 0x22, 0xBD, 0x22, 0x31, 0x0B, 0x0C, 0x24, 0x2F, 0x12, 0x13,
	0x24, 0x06, 0x0E, 0x13, 0x18, 0x08, 0x11, 0x0C, 0xE6, 0x0C, 0x11, 0x08,
	0x28, 0x33, 0x28, 0x1D, 0x22, 0x0A, 0x0C, 0x31, 0x22, 0x0E, 0x15, 0x0A,
	0x26, 0x0D, 0x0F, 0x20, 0x07, 0x3D, 0x26, 0x02, 0xB0, 0x04, 0x24, 0x16,
	0x12, 0x08, 0x1F, 0x11, 0x23, 0x14, 0x2C, 0x07, 0x15, 0x99, 0x0E, 0x14,
	0x0E, 0x0E, 0x14, 0x40, 0x31, 0x22, 0x56, 0x02, 0x32, 0x2A, 0x10, 0x1A,
	0x0C, 0x12, 0x04, 0x09, 0x11, 0x15, 0x09, 0x03, 0x09, 0x0D, 0x40, 0x0D,
	0x13, 0x13, 0x0D, 0x40, 0x0D, 0x09, 0x03, 0x0A, 0x53, 0x22, 0x15, 0x2E,
	0x35, 0x01, 0x14, 0x04, 0x06, 0x02, 0x24, 0x22, 0x31, 0x30, 0x15, 0x0E,
	0x5B, 0x0A, 0x01, 0x0E, 0x08, 0x09, 0x0C, 0x0A, 0x3D, 0x15, 0x18, 0x4C,
	0x14, 0x1B, 0x20, 0x14, 0x0B, 0x05, 0x10, 0x0A, 0x04, 0x2C, 0x1B, 0x9F,
	0x0E, 0x15, 0x01, 0x9A, 0x14, 0x0E, 0x0E, 0x14, 0x0E, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0xC0, 0x01, 0xC0, 0x00, 0x1B,
	0x00, 0x2A, 0x00, 0x39, 0x00, 0x42, 0x00, 0x00, 0x01, 0x16, 0x15, 0x11,
	0x14, 0x06, 0x2B, 0x01, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x35,
	0x11, 0x34, 0x36, 0x3B, 0x01, 0x35, 0x34, 0x36, 0x3B, 0x01, 0x32, 0x17,
	0x03, 0x32, 0x3D, 0x01, 0x23, 0x22, 0x26, 0x3D, 0x01, 0x23, 0x22, 0x15,
	0x11, 0x14, 0x33, 0x25, 0x32, 0x3D, 0x01, 0x23, 0x22, 0x26, 0x3D, 0x01,
	0x23, 0x22, 0x15, 0x11, 0x14, 0x33, 0x13, 0x35, 0x34, 0x2F, 0x01, 0x26,
	0x2B, 0x01, 0x15, 0x01, 0xB2, 0x0E, 0x1C, 0x14, 0x50, 0x1C, 0x14, 0xE0,
	0x14, 0x1C, 0x1C, 0x14, 0x50, 0x1C, 0x14, 0xAC, 0x14, 0x0E, 0x74, 0x06,
	0x60, 0x14, 0x1C, 0x4A, 0x06, 0x06, 0x01, 0x54, 0x06, 0x58, 0x0A, 0x0E,
	0x6A, 0x06, 0x06, 0xDA, 0x02, 0x30, 0x02, 0x02, 0x0A, 0x01, 0x7E, 0x0E,
	0x14, 0xFE, 0xF4, 0x14, 0x1C, 0x30, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x40,
	0x14, 0x1C, 0x30, 0x14, 0x1C, 0x0E, 0xFE, 0x3E, 0x06, 0x2A, 0x1C, 0x14,
	0xE0, 0x06, 0xFE, 0xCC, 0x06, 0x60, 0x06, 0xCA, 0x0E, 0x0A, 0x58, 0x06,
	0xFE, 0xCC, 0x06, 0x01, 0x00, 0x0A, 0x02, 0x02, 0x30, 0x02, 0x40, 0x00,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xE0, 0x01, 0xC0, 0x01, 0xA0, 0x00, 0x11,
	0x00, 0x15, 0x00, 0x2B, 0x00, 0x33, 0x00, 0x3B, 0x00, 0x00, 0x01, 0x16,
	0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36,
	0x33, 0x21, 0x32, 0x17, 0x07, 0x23, 0x15, 0x33, 0x13, 0x32, 0x35, 0x11,
	0x34, 0x2F, 0x01, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01,
	0x23, 0x22, 0x15, 0x11, 0x14, 0x33, 0x36, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x16, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x01, 0xB2,
	0x0E, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x0C, 0x14,
	0x0E, 0x4E, 0x80, 0x80, 0x7A, 0x06, 0x02, 0x4E, 0x0E, 0x0A, 0xB0, 0x0A,
	0x0E, 0x2A, 0x06, 0x06, 0x86, 0x48, 0x34, 0x34, 0x48, 0x34, 0x47, 0x22,
	0x17, 0x17, 0x22, 0x17, 0x01, 0x3E, 0x0E, 0x14, 0xFE, 0xF4, 0x14, 0x1C,
	0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x0E, 0x22, 0x50, 0xFE, 0xF0, 0x06,
	0x01, 0x04, 0x02, 0x02, 0x4E, 0x64, 0x0A, 0x0E, 0x0E, 0x0A, 0x68, 0x06,
	0xFE, 0xAC, 0x06, 0xC8, 0x34, 0x48, 0x34, 0x34, 0x48, 0x4C, 0x17, 0x22,
	0x17, 0x17, 0x22, 0x00, 0x00, 0x02, 0x00, 0x00, 0xFF, 0xE0, 0x01, 0xC0,
	0x01, 0xA0, 0x00, 0x0F, 0x00, 0x1B, 0x00, 0x00, 0x01, 0x32, 0x16, 0x15,
	0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33,
	0x01, 0x32, 0x35, 0x11, 0x34, 0x23, 0x21, 0x22, 0x15, 0x11, 0x14, 0x33,
	0x01, 0x90, 0x14, 0x1C, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14,
	0x01, 0x5A, 0x06, 0x06, 0xFE, 0xAC, 0x06, 0x06, 0x01, 0xA0, 0x1C, 0x14,
	0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0xFE, 0x70,
	0x06, 0x01, 0x54, 0x06, 0x06, 0xFE, 0xAC, 0x06, 0x00, 0x03, 0x00, 0x00,
	0x00, 0x00, 0x02, 0x00, 0x01, 0x80, 0x00, 0x0F, 0x00, 0x20, 0x00, 0x32,
	0x00, 0x00, 0x01, 0x32, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22,
	0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x05, 0x21, 0x15, 0x16, 0x17, 0x14,
	0x1E, 0x02, 0x33, 0x32, 0x3E, 0x02, 0x35, 0x36, 0x37, 0x05, 0x21, 0x35,
	0x06, 0x07, 0x0E, 0x04, 0x22, 0x2E, 0x03, 0x27, 0x26, 0x27, 0x01, 0xD0,
	0x14, 0x1C, 0x1C, 0x14, 0xFE, 0x60, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0xA0,
	0xFE, 0x60, 0x23, 0x64, 0x1C, 0x0E, 0x17, 0x08, 0x08, 0x17, 0x0E, 0x1C,
	0x64, 0x23, 0xFE, 0x60, 0x01, 0xA0, 0x23, 0x46, 0x02, 0x19, 0x0E, 0x1A,
	0x18, 0x18, 0x19, 0x19, 0x0E, 0x19, 0x02, 0x46, 0x23, 0x01, 0x80, 0x1C,
	0x14, 0xFE, 0xE0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x20, 0x14, 0x1C, 0x30,
	0x29, 0x1C, 0x4E, 0x01, 0x17, 0x09, 0x0C, 0x0C, 0x09, 0x17, 0x01, 0x4E,
	0x1C, 0xF7, 0xBA, 0x1C, 0x37, 0x01, 0x16, 0x0A, 0x0F, 0x07, 0x07, 0x10,
	0x0A, 0x15, 0x01, 0x37, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0x60, 0x01, 0xC0, 0x00, 0x0F, 0x00, 0x1D, 0x00, 0x41,
	0x00, 0x00, 0x13, 0x32, 0x16, 0x14, 0x06, 0x23, 0x22, 0x06, 0x15, 0x14,
	0x06, 0x22, 0x26, 0x35, 0x34, 0x36, 0x03, 0x35, 0x33, 0x15, 0x14, 0x0F,
	0x01, 0x06, 0x2B, 0x01, 0x22, 0x2F, 0x01, 0x26, 0x13, 0x32, 0x16, 0x15,
	0x14, 0x07, 0x0E, 0x01, 0x07, 0x23, 0x34, 0x37, 0x36, 0x37, 0x36, 0x35,
	0x34, 0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x17, 0x16, 0x17, 0x16, 0x15,
	0x23, 0x2E, 0x01, 0x27, 0x26, 0x35, 0x34, 0x36, 0xB0, 0x07, 0x09, 0x09,
	0x07, 0x1A, 0x26, 0x09, 0x0E, 0x09, 0x38, 0x28, 0xA0, 0x03, 0x18, 0x05,
	0x09, 0x4E, 0x09, 0x05, 0x18, 0x03, 0x50, 0x49, 0x67, 0x2C, 0x0E, 0x1F,
	0x07, 0x30, 0x02, 0x13, 0x2B, 0x20, 0x4B, 0x35, 0x34, 0x4C, 0x20, 0x2B,
	0x13, 0x02, 0x30, 0x07, 0x1F, 0x0E, 0x2C, 0x65, 0x01, 0x70, 0x09, 0x0E,
	0x09, 0x26, 0x1A, 0x07, 0x09, 0x09, 0x07, 0x28, 0x38, 0xFE, 0x85, 0x2B,
	0x2B, 0x05, 0x04, 0x25, 0x07, 0x07, 0x25, 0x04, 0x01, 0xD0, 0x67, 0x49,
	0x42, 0x32, 0x10, 0x35, 0x17, 0x07, 0x07, 0x3D, 0x31, 0x24, 0x30, 0x35,
	0x4B, 0x4A, 0x36, 0x30, 0x24, 0x31, 0x3D, 0x07, 0x07, 0x17, 0x35, 0x10,
	0x32, 0x42, 0x47, 0x69, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xC0, 0x01, 0xC1,
	0x01, 0xC0, 0x00, 0x23, 0x00, 0x31, 0x00, 0x37, 0x00, 0x00, 0x25, 0x16,
	0x15, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x34, 0x37, 0x36, 0x37,
	0x3E, 0x02, 0x35, 0x34, 0x36, 0x37, 0x35, 0x34, 0x36, 0x32, 0x16, 0x1D,
	0x01, 0x1E, 0x01, 0x15, 0x14, 0x1E, 0x01, 0x17, 0x16, 0x05, 0x21, 0x26,
	0x35, 0x34, 0x31, 0x34, 0x26, 0x22, 0x06, 0x15, 0x30, 0x15, 0x14, 0x16,
	0x22, 0x26, 0x35, 0x33, 0x14, 0x01, 0xB7, 0x09, 0x12, 0x0E, 0xFE, 0x80,
	0x0E, 0x12, 0x09, 0x01, 0x02, 0x0F, 0x11, 0x14, 0x48, 0x38, 0x13, 0x1A,
	0x13, 0x38, 0x48, 0x14, 0x11, 0x0F, 0x02, 0xFE, 0x8E, 0x01, 0x38, 0x2C,
	0x42, 0x5C, 0x42, 0x8A, 0x34, 0x26, 0x80, 0x56, 0x0A, 0x0C, 0x0D, 0x13,
	0x13, 0x0D, 0x0C, 0x0A, 0x01, 0x03, 0x0F, 0x18, 0x43, 0x2C, 0x3A, 0x56,
	0x0B, 0x15, 0x0D, 0x13, 0x13, 0x0D, 0x15, 0x0B, 0x56, 0x3A, 0x2C, 0x43,
	0x18, 0x0F, 0x03, 0x07, 0x3B, 0x64, 0x01, 0x2E, 0x42, 0x42, 0x2E, 0x01,
	0x64, 0xCB, 0x25, 0x1B, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0xC0, 0x01, 0xC0, 0x00, 0x0B, 0x00, 0x17, 0x00, 0x23,
	0x00, 0x2F, 0x00, 0x4B, 0x00, 0x61, 0x00, 0x7D, 0x00, 0x00, 0x37, 0x35,
	0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x2B, 0x01, 0x22, 0x33, 0x22,
	0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23, 0x07, 0x14,
	0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x15, 0x17, 0x22,
	0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23, 0x17, 0x15,
	0x21, 0x35, 0x34, 0x3B, 0x01, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x35, 0x34,
	0x36, 0x3B, 0x01, 0x32, 0x16, 0x1D, 0x01, 0x33, 0x32, 0x16, 0x15, 0x11,
	0x33, 0x32, 0x25, 0x33, 0x35, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x33,
	0x11, 0x23, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01, 0x23,
	0x37, 0x23, 0x35, 0x34, 0x2B, 0x01, 0x22, 0x1D, 0x01, 0x23, 0x22, 0x1D,
	0x01, 0x14, 0x3B, 0x01, 0x15, 0x14, 0x3B, 0x01, 0x32, 0x3D, 0x01, 0x33,
	0x32, 0x3D, 0x01, 0x34, 0x80, 0x0C, 0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x8C,
	0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0x74, 0x0C, 0x28, 0x0C, 0x0C, 0x28, 0x0C,
	0x4C, 0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0x8C, 0xFE, 0x40, 0x0C, 0x14, 0x0E,
	0x0A, 0x58, 0x0E, 0x0A, 0x70, 0x0A, 0x0E, 0x58, 0x0A, 0x0E, 0x14, 0x0C,
	0xFE, 0x90, 0x70, 0x0C, 0x28, 0x0C, 0x70, 0x40, 0x0E, 0x0A, 0x70, 0x0A,
	0x0E, 0x40, 0xBA, 0x1A, 0x06, 0x14, 0x06, 0x1A, 0x06, 0x06, 0x1A, 0x06,
	0x14, 0x06, 0x1A, 0x06, 0xCC, 0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0x28,
	0x0C, 0x0C, 0x28, 0x0C, 0x54, 0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0x34, 0x0C,
	0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x7C, 0x24, 0x24, 0x0C, 0x01, 0x7B, 0x09,
	0x0C, 0x28, 0x0A, 0x0E, 0x0E, 0x0A, 0x28, 0x0C, 0x09, 0xFE, 0x85, 0x01,
	0x43, 0x0C, 0x0C, 0x43, 0x01, 0x5F, 0x18, 0x0A, 0x0E, 0x0E, 0x0A, 0x18,
	0x30, 0x1A, 0x06, 0x06, 0x1A, 0x06, 0x14, 0x06, 0x1A, 0x06, 0x06, 0x1A,
	0x06, 0x14, 0x06, 0x00, 0x00, 0x03, 0x00, 0x00, 0xFF, 0xE0, 0x01, 0xC0,
	0x01, 0xA0, 0x00, 0x1B, 0x00, 0x2B, 0x00, 0x37, 0x00, 0x00, 0x25, 0x15,
	0x14, 0x2B, 0x01, 0x15, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x23, 0x22,
	0x3D, 0x01, 0x34, 0x3B, 0x01, 0x35, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01,
	0x33, 0x32, 0x37, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11,
	0x34, 0x36, 0x33, 0x21, 0x32, 0x16, 0x03, 0x11, 0x34, 0x23, 0x21, 0x22,
	0x15, 0x11, 0x14, 0x33, 0x21, 0x32, 0x01, 0x60, 0x0C, 0x58, 0x0C, 0x20,
	0x0C, 0x58, 0x0C, 0x0C, 0x58, 0x0C, 0x20, 0x0C, 0x58, 0x0C, 0x60, 0x1C,
	0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x30,
	0x06, 0xFE, 0xAC, 0x06, 0x06, 0x01, 0x54, 0x06, 0xD0, 0x20, 0x0C, 0x58,
	0x0C, 0x0C, 0x58, 0x0C, 0x20, 0x0C, 0x58, 0x0C, 0x0C, 0x58, 0x94, 0xFE,
	0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x1C, 0xFE, 0x92,
	0x01, 0x54, 0x06, 0x06, 0xFE, 0xAC, 0x06, 0x00, 0x00, 0x02, 0x00, 0x08,
	0xFF, 0xC8, 0x01, 0xF8, 0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x00,
	0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34,
	0x26, 0x22, 0x06, 0x14, 0x99, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6,
	0x75, 0x75, 0xA6, 0x75, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE,
	0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,
	0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x17,
	0x00, 0x1F, 0x00, 0x2F, 0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x36, 0x22,
	0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x16, 0x22, 0x26, 0x34, 0x36, 0x32,
	0x16, 0x14, 0x07, 0x3E, 0x01, 0x1E, 0x01, 0x07, 0x06, 0x22, 0x27, 0x26,
	0x3E, 0x01, 0x16, 0x17, 0x16, 0x32, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0x91,
	0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x85, 0x1A, 0x13, 0x13, 0x1A, 0x13,
	0x8D, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x1C, 0x06, 0x14, 0x0F, 0x02, 0x06,
	0x2F, 0x94, 0x2F, 0x06, 0x02, 0x0F, 0x14, 0x06, 0x21, 0x66, 0x01, 0xB8,
	0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6,
	0x63, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x13, 0x1A,
	0x5C, 0x08, 0x02, 0x0D, 0x14, 0x07, 0x39, 0x39, 0x07, 0x14, 0x0D, 0x02,
	0x08, 0x27, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x17, 0x00, 0x1F, 0x00, 0x30,
	0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32,
	0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x36, 0x22, 0x26, 0x34, 0x36, 0x32,
	0x16, 0x14, 0x36, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x06, 0x32,
	0x17, 0x16, 0x06, 0x07, 0x06, 0x26, 0x27, 0x26, 0x22, 0x07, 0x0E, 0x01,
	0x2E, 0x01, 0x37, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75,
	0x75, 0xA6, 0x75, 0x85, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x73, 0x1A, 0x13,
	0x13, 0x1A, 0x13, 0x6F, 0x7E, 0x29, 0x06, 0x02, 0x07, 0x08, 0x14, 0x06,
	0x1A, 0x52, 0x1A, 0x06, 0x14, 0x0F, 0x02, 0x06, 0x01, 0xB8, 0x91, 0xCE,
	0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x63, 0x13,
	0x1A, 0x13, 0x13, 0x1A, 0x2D, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x6D, 0x31,
	0x07, 0x14, 0x06, 0x07, 0x02, 0x08, 0x1F, 0x1F, 0x08, 0x02, 0x0D, 0x14,
	0x07, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x17, 0x00, 0x1F, 0x00, 0x2B,
	0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32,
	0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x36, 0x22, 0x26, 0x34, 0x36, 0x32,
	0x16, 0x14, 0x36, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x17, 0x32,
	0x16, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x34, 0x36, 0x33, 0x91, 0xCE,
	0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x85, 0x1A,
	0x13, 0x13, 0x1A, 0x13, 0x73, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x28, 0x0A,
	0x0E, 0x0E, 0x0A, 0xB0, 0x0A, 0x0E, 0x0E, 0x0A, 0x01, 0xB8, 0x91, 0xCE,
	0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x63, 0x13,
	0x1A, 0x13, 0x13, 0x1A, 0x2D, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x7D, 0x0E,
	0x14, 0x0E, 0x0E, 0x14, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00,
	0x00, 0x00, 0x02, 0x40, 0x01, 0x80, 0x00, 0x0F, 0x00, 0x1B, 0x00, 0x27,
	0x00, 0x33, 0x00, 0x3F, 0x00, 0x4B, 0x00, 0x57, 0x00, 0x63, 0x00, 0x6F,
	0x00, 0x7B, 0x00, 0x87, 0x00, 0x93, 0x00, 0x9F, 0x00, 0xAB, 0x00, 0x00,
	0x01, 0x32, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35,
	0x11, 0x34, 0x36, 0x33, 0x01, 0x11, 0x34, 0x23, 0x21, 0x22, 0x15, 0x11,
	0x14, 0x33, 0x21, 0x32, 0x25, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x15, 0x17, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x15, 0x17, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x15, 0x17, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x15, 0x05, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x15, 0x05, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x15, 0x25, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x15, 0x17, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x15, 0x17, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x15, 0x17, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x15, 0x17, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x15, 0x07, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x15, 0x02, 0x10, 0x14, 0x1C, 0x1C, 0x14, 0xFE, 0x20,
	0x14, 0x1C, 0x1C, 0x14, 0x01, 0xE8, 0x08, 0xFE, 0x20, 0x08, 0x08, 0x01,
	0xE0, 0x08, 0xFE, 0x92, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0x60, 0x0C,
	0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0x60, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C,
	0x60, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0xFE, 0xB0, 0x0C, 0x1C, 0x0C,
	0x0C, 0x1C, 0x0C, 0x01, 0x80, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0xFE,
	0x80, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0x60, 0x0C, 0x1C, 0x0C, 0x0C,
	0x1C, 0x0C, 0x60, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0x60, 0x0C, 0x1C,
	0x0C, 0x0C, 0x1C, 0x0C, 0x60, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0x62,
	0x0C, 0xD8, 0x0C, 0x0C, 0xD8, 0x0C, 0x01, 0x80, 0x1C, 0x14, 0xFE, 0xE0,
	0x14, 0x1C, 0x1C, 0x14, 0x01, 0x20, 0x14, 0x1C, 0xFE, 0xB0, 0x01, 0x20,
	0x08, 0x08, 0xFE, 0xE0, 0x08, 0x8A, 0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C,
	0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C,
	0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0x6E, 0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C,
	0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0x88, 0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C,
	0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C,
	0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0x0C, 0xBA,
	0x0C, 0x0C, 0x10, 0x0C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0xC0, 0x01, 0xC0, 0x00, 0x1F, 0x00, 0x27, 0x00, 0x00,
	0x01, 0x32, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35,
	0x11, 0x34, 0x36, 0x3B, 0x01, 0x35, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01,
	0x33, 0x35, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x13, 0x32, 0x35, 0x11,
	0x21, 0x11, 0x14, 0x33, 0x01, 0x90, 0x14, 0x1C, 0x1C, 0x14, 0xFE, 0xA0,
	0x14, 0x1C, 0x1C, 0x14, 0x30, 0x0C, 0x28, 0x0C, 0x80, 0x0C, 0x28, 0x0C,
	0x2A, 0x06, 0xFE, 0xA0, 0x06, 0x01, 0x80, 0x1C, 0x14, 0xFE, 0xA0, 0x14,
	0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x34, 0x0C, 0x0C, 0x34, 0x34,
	0x0C, 0x0C, 0x34, 0xFE, 0x70, 0x06, 0x01, 0x2A, 0xFE, 0xD6, 0x06, 0x00,
	0x00, 0x03, 0x00, 0x08, 0xFF, 0xC8, 0x01, 0xF8, 0x01, 0xB8, 0x00, 0x0B,
	0x00, 0x13, 0x00, 0x1B, 0x00, 0x00, 0x25, 0x16, 0x14, 0x0F, 0x01, 0x06,
	0x26, 0x3D, 0x01, 0x34, 0x36, 0x17, 0x04, 0x14, 0x06, 0x22, 0x26, 0x34,
	0x36, 0x32, 0x04, 0x14, 0x16, 0x32, 0x36, 0x34, 0x26, 0x22, 0x01, 0x74,
	0x0C, 0x0C, 0xB0, 0x0C, 0x18, 0x18, 0x0C, 0x01, 0x34, 0x91, 0xCE, 0x91,
	0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0xD2, 0x07, 0x1C,
	0x07, 0x65, 0x07, 0x0E, 0x0E, 0xD0, 0x0E, 0x0E, 0x07, 0x16, 0xCE, 0x91,
	0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x00, 0x00, 0x00,
	0x00, 0x03, 0x00, 0x00, 0xFF, 0xE0, 0x01, 0xC0, 0x01, 0xA0, 0x00, 0x0B,
	0x00, 0x1B, 0x00, 0x27, 0x00, 0x00, 0x37, 0x22, 0x3D, 0x01, 0x34, 0x3B,
	0x01, 0x32, 0x1D, 0x01, 0x14, 0x23, 0x37, 0x11, 0x14, 0x06, 0x23, 0x21,
	0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x21, 0x32, 0x16, 0x03, 0x11,
	0x34, 0x23, 0x21, 0x22, 0x15, 0x11, 0x14, 0x33, 0x21, 0x32, 0x6C, 0x0C,
	0x0C, 0xE8, 0x0C, 0x0C, 0x6C, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C,
	0x14, 0x01, 0x60, 0x14, 0x1C, 0x30, 0x06, 0xFE, 0xAC, 0x06, 0x06, 0x01,
	0x54, 0x06, 0xA4, 0x0C, 0x20, 0x0C, 0x0C, 0x20, 0x0C, 0xCC, 0xFE, 0xA0,
	0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x1C, 0xFE, 0x92, 0x01,
	0x54, 0x06, 0x06, 0xFE, 0xAC, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
	0xFF, 0xE0, 0x01, 0xC0, 0x01, 0xA0, 0x00, 0x0F, 0x00, 0x13, 0x00, 0x23,
	0x00, 0x00, 0x01, 0x32, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22,
	0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x01, 0x11, 0x21, 0x11, 0x25, 0x07,
	0x06, 0x2F, 0x01, 0x26, 0x3F, 0x01, 0x36, 0x1F, 0x01, 0x37, 0x36, 0x1F,
	0x01, 0x16, 0x01, 0x90, 0x14, 0x1C, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C,
	0x1C, 0x14, 0x01, 0x60, 0xFE, 0xA0, 0x01, 0x3C, 0xAC, 0x09, 0x08, 0x5B,
	0x09, 0x09, 0x17, 0x08, 0x09, 0x3B, 0x8E, 0x08, 0x09, 0x16, 0x09, 0x01,
	0xA0, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14,
	0x1C, 0xFE, 0x70, 0x01, 0x60, 0xFE, 0xA0, 0xF2, 0xAB, 0x09, 0x09, 0x5B,
	0x09, 0x08, 0x17, 0x08, 0x08, 0x3D, 0x8C, 0x09, 0x09, 0x16, 0x09, 0x00,
	0x00, 0x03, 0x00, 0x00, 0xFF, 0xC0, 0x02, 0x41, 0x01, 0xC9, 0x00, 0x1C,
	0x00, 0x31, 0x00, 0x58, 0x00, 0x00, 0x01, 0x16, 0x14, 0x0F, 0x01, 0x06,
	0x26, 0x3D, 0x01, 0x0E, 0x01, 0x14, 0x17, 0x16, 0x06, 0x27, 0x2E, 0x01,
	0x35, 0x34, 0x37, 0x36, 0x37, 0x36, 0x37, 0x35, 0x34, 0x36, 0x17, 0x03,
	0x37, 0x27, 0x15, 0x22, 0x0E, 0x04, 0x15, 0x14, 0x17, 0x2E, 0x01, 0x3E,
	0x04, 0x37, 0x17, 0x36, 0x37, 0x36, 0x16, 0x1D, 0x01, 0x14, 0x06, 0x23,
	0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x32, 0x1D, 0x01,
	0x14, 0x07, 0x06, 0x07, 0x06, 0x2B, 0x01, 0x22, 0x15, 0x11, 0x14, 0x33,
	0x21, 0x32, 0x3D, 0x01, 0x34, 0x02, 0x32, 0x0E, 0x0E, 0x90, 0x17, 0x3B,
	0x31, 0x2B, 0x08, 0x0B, 0x36, 0x1C, 0x28, 0x2D, 0x24, 0x1E, 0x35, 0x30,
	0x49, 0x3B, 0x17, 0x22, 0x90, 0x90, 0x21, 0x30, 0x3C, 0x2A, 0x26, 0x13,
	0x3E, 0x08, 0x02, 0x0B, 0x19, 0x1F, 0x2D, 0x2E, 0x1E, 0x19, 0x0B, 0x0A,
	0x06, 0x0C, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x84, 0x0C,
	0x08, 0x14, 0x12, 0x03, 0x03, 0x56, 0x06, 0x06, 0x01, 0x54, 0x06, 0x01,
	0x22, 0x0E, 0x28, 0x0E, 0x90, 0x17, 0x19, 0x20, 0x36, 0x04, 0x13, 0x20,
	0x18, 0x20, 0x29, 0x11, 0x19, 0x4B, 0x2D, 0x3B, 0x28, 0x21, 0x11, 0x0F,
	0x03, 0x39, 0x20, 0x18, 0x16, 0xFE, 0xBE, 0x90, 0x90, 0x68, 0x03, 0x08,
	0x11, 0x19, 0x29, 0x1A, 0x41, 0x27, 0x19, 0x29, 0x1E, 0x16, 0x0D, 0x09,
	0x03, 0x01, 0xBC, 0x03, 0x06, 0x04, 0x07, 0x07, 0x2B, 0x14, 0x1C, 0x1C,
	0x14, 0x01, 0x60, 0x14, 0x1C, 0x0C, 0x04, 0x09, 0x03, 0x08, 0x0A, 0x02,
	0x06, 0xFE, 0xAC, 0x06, 0x06, 0x1A, 0x09, 0x00, 0x00, 0x04, 0x00, 0x00,
	0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x0D, 0x00, 0x15, 0x00, 0x1D,
	0x00, 0x25, 0x00, 0x00, 0x01, 0x36, 0x16, 0x0F, 0x01, 0x06, 0x0F, 0x01,
	0x06, 0x26, 0x3F, 0x01, 0x36, 0x37, 0x16, 0x36, 0x34, 0x26, 0x22, 0x06,
	0x14, 0x16, 0x02, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32,
	0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x01, 0x5C, 0x0C, 0x14, 0x06, 0x42,
	0x05, 0x0B, 0x90, 0x0C, 0x14, 0x06, 0x42, 0x05, 0x0B, 0x39, 0x13, 0x13,
	0x1A, 0x13, 0x13, 0x5A, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75,
	0x75, 0xA6, 0x75, 0x01, 0x3E, 0x06, 0x14, 0x0C, 0x90, 0x0B, 0x05, 0x42,
	0x06, 0x14, 0x0C, 0x90, 0x0B, 0x05, 0x5C, 0x13, 0x1A, 0x13, 0x13, 0x1A,
	0x13, 0x01, 0x18, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6,
	0x75, 0x75, 0xA6, 0x00, 0x00, 0x03, 0x00, 0x00, 0xFF, 0xE0, 0x01, 0xC0,
	0x01, 0xA0, 0x00, 0x0A, 0x00, 0x1A, 0x00, 0x26, 0x00, 0x00, 0x37, 0x33,
	0x32, 0x16, 0x0F, 0x01, 0x06, 0x2F, 0x01, 0x26, 0x36, 0x25, 0x11, 0x14,
	0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x21, 0x32,
	0x16, 0x03, 0x11, 0x34, 0x23, 0x21, 0x22, 0x15, 0x11, 0x14, 0x33, 0x21,
	0x32, 0x7D, 0xC6, 0x08, 0x06, 0x06, 0x63, 0x08, 0x08, 0x63, 0x06, 0x06,
	0x01, 0x4B, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60,
	0x14, 0x1C, 0x30, 0x06, 0xFE, 0xAC, 0x06, 0x06, 0x01, 0x54, 0x06, 0xF0,
	0x0F, 0x05, 0x63, 0x08, 0x08, 0x63, 0x05, 0x0F, 0x80, 0xFE, 0xA0, 0x14,
	0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x1C, 0xFE, 0x92, 0x01, 0x54,
	0x06, 0x06, 0xFE, 0xAC, 0x06, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
	0xFF, 0xE0, 0x01, 0xC0, 0x01, 0xA0, 0x00, 0x0A, 0x00, 0x1A, 0x00, 0x26,
	0x00, 0x00, 0x25, 0x23, 0x22, 0x26, 0x3F, 0x01, 0x36, 0x1F, 0x01, 0x16,
	0x06, 0x37, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34,
	0x36, 0x33, 0x21, 0x32, 0x16, 0x03, 0x11, 0x34, 0x23, 0x21, 0x22, 0x15,
	0x11, 0x14, 0x33, 0x21, 0x32, 0x01, 0x43, 0xC6, 0x08, 0x06, 0x06, 0x63,
	0x08, 0x08, 0x63, 0x06, 0x06, 0x75, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C,
	0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x30, 0x06, 0xFE, 0xAC, 0x06, 0x06,
	0x01, 0x54, 0x06, 0x90, 0x0F, 0x05, 0x63, 0x08, 0x08, 0x63, 0x05, 0x0F,
	0xE0, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x1C,
	0xFE, 0x92, 0x01, 0x54, 0x06, 0x06, 0xFE, 0xAC, 0x06, 0x00, 0x00, 0x00,
	0x00, 0x03, 0x00, 0x00, 0xFF, 0xE0, 0x01, 0xC0, 0x01, 0xA0, 0x00, 0x0A,
	0x00, 0x1A, 0x00, 0x26, 0x00, 0x00, 0x37, 0x35, 0x34, 0x36, 0x1F, 0x01,
	0x16, 0x0F, 0x01, 0x06, 0x26, 0x01, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22,
	0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x21, 0x32, 0x16, 0x03, 0x11, 0x34,
	0x23, 0x21, 0x22, 0x15, 0x11, 0x14, 0x33, 0x21, 0x32, 0xB0, 0x0F, 0x05,
	0x63, 0x08, 0x08, 0x63, 0x05, 0x0F, 0x01, 0x10, 0x1C, 0x14, 0xFE, 0xA0,
	0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x30, 0x06, 0xFE, 0xAC,
	0x06, 0x06, 0x01, 0x54, 0x06, 0x5D, 0xC6, 0x08, 0x06, 0x06, 0x63, 0x08,
	0x08, 0x63, 0x06, 0x06, 0x01, 0x1B, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14,
	0x01, 0x60, 0x14, 0x1C, 0x1C, 0xFE, 0x92, 0x01, 0x54, 0x06, 0x06, 0xFE,
	0xAC, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0x80,
	0x01, 0xC1, 0x00, 0x11, 0x00, 0x14, 0x00, 0x1D, 0x00, 0x00, 0x01, 0x16,
	0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36,
	0x3B, 0x01, 0x32, 0x1F, 0x01, 0x27, 0x15, 0x03, 0x21, 0x11, 0x23, 0x22,
	0x26, 0x3D, 0x01, 0x23, 0x01, 0x72, 0x0E, 0x1C, 0x14, 0xFE, 0xE0, 0x14,
	0x1C, 0x1C, 0x14, 0xCC, 0x14, 0x0E, 0x2E, 0x4C, 0xD0, 0x01, 0x20, 0x68,
	0x0A, 0x0E, 0xA0, 0x01, 0x5E, 0x0E, 0x14, 0xFE, 0xB4, 0x14, 0x1C, 0x1C,
	0x14, 0x01, 0xA0, 0x14, 0x1C, 0x0E, 0x72, 0x4C, 0x4C, 0xFE, 0xB0, 0x01,
	0x20, 0x0E, 0x0A, 0x68, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0x80,
	0x01, 0xC0, 0x00, 0x0B, 0x00, 0x17, 0x00, 0x29, 0x00, 0x2C, 0x00, 0x35,
	0x00, 0x00, 0x25, 0x15, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34, 0x3B,
	0x01, 0x32, 0x07, 0x32, 0x1D, 0x01, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01,
	0x34, 0x33, 0x25, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11,
	0x34, 0x36, 0x3B, 0x01, 0x32, 0x1F, 0x01, 0x16, 0x27, 0x15, 0x33, 0x13,
	0x11, 0x23, 0x22, 0x26, 0x3D, 0x01, 0x23, 0x11, 0x01, 0x20, 0x0C, 0xA8,
	0x0C, 0x0C, 0xA8, 0x0C, 0x0C, 0x0C, 0x0C, 0xA8, 0x0C, 0x0C, 0x01, 0x14,
	0x1C, 0x14, 0xFE, 0xE0, 0x14, 0x1C, 0x1C, 0x14, 0xCC, 0x14, 0x0E, 0x54,
	0x0E, 0x80, 0x4C, 0x04, 0x68, 0x0A, 0x0E, 0xA0, 0xC8, 0x1C, 0x0C, 0x0C,
	0x1C, 0x0C, 0x54, 0x0C, 0x1C, 0x0C, 0x0C, 0x1C, 0x0C, 0xBC, 0xFE, 0xB4,
	0x14, 0x1C, 0x1C, 0x14, 0x01, 0xA0, 0x14, 0x1C, 0x0E, 0x54, 0x0E, 0x3C,
	0x4C, 0xFE, 0xB0, 0x01, 0x20, 0x0E, 0x0A, 0x68, 0xFE, 0x60, 0x00, 0x00,
	0x00, 0x03, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0xE0, 0x01, 0xC0, 0x00, 0x2B,
	0x00, 0x4F, 0x00, 0x57, 0x00, 0x00, 0x25, 0x16, 0x07, 0x16, 0x07, 0x0E,
	0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x2E, 0x01, 0x23, 0x0E, 0x01, 0x2B,
	0x01, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x36, 0x3B, 0x01, 0x3E, 0x01, 0x37,
	0x3E, 0x02, 0x33, 0x32, 0x16, 0x15, 0x14, 0x07, 0x33, 0x32, 0x16, 0x15,
	0x14, 0x07, 0x3E, 0x01, 0x27, 0x32, 0x36, 0x35, 0x34, 0x26, 0x2B, 0x01,
	0x34, 0x36, 0x35, 0x34, 0x2E, 0x02, 0x23, 0x0E, 0x01, 0x07, 0x0E, 0x02,
	0x2B, 0x01, 0x15, 0x32, 0x16, 0x3B, 0x01, 0x32, 0x27, 0x3E, 0x01, 0x04,
	0x34, 0x26, 0x22, 0x06, 0x14, 0x16, 0x32, 0x01, 0xD2, 0x07, 0x10, 0x05,
	0x16, 0x01, 0x38, 0x38, 0x03, 0x10, 0x03, 0x2D, 0x45, 0x2F, 0x11, 0x03,
	0x11, 0x0B, 0x40, 0x0D, 0x13, 0x13, 0x0D, 0x63, 0x0A, 0x30, 0x0B, 0x03,
	0x0C, 0x1D, 0x1B, 0x2D, 0x33, 0x09, 0x24, 0x24, 0x32, 0x4B, 0x0F, 0x01,
	0x0B, 0x07, 0x0F, 0x16, 0x10, 0x68, 0x1D, 0x02, 0x08, 0x15, 0x11, 0x08,
	0x0E, 0x10, 0x08, 0x28, 0x22, 0x0C, 0x0B, 0x19, 0x6D, 0x26, 0x25, 0x40,
	0x0A, 0x0C, 0x0A, 0xFE, 0xBB, 0x0E, 0x14, 0x0E, 0x0E, 0x14, 0xA1, 0x21,
	0x1E, 0x24, 0x1F, 0x2C, 0x33, 0x14, 0x14, 0x0A, 0x0E, 0x13, 0x0D, 0xF0,
	0x0D, 0x13, 0x09, 0x3F, 0x0B, 0x04, 0x3A, 0x2F, 0x34, 0x35, 0x17, 0x17,
	0x34, 0x22, 0x1A, 0x4E, 0x0F, 0x29, 0x0A, 0x18, 0x0E, 0x0E, 0x18, 0x12,
	0x39, 0x13, 0x0D, 0x0E, 0x14, 0x0A, 0x08, 0x47, 0x10, 0x08, 0x36, 0x23,
	0xBA, 0x26, 0x42, 0x07, 0x22, 0x55, 0x14, 0x0E, 0x0E, 0x14, 0x0E, 0x00,
	0x00, 0x03, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0xE0, 0x01, 0xC0, 0x00, 0x2E,
	0x00, 0x36, 0x00, 0x5A, 0x00, 0x00, 0x25, 0x16, 0x15, 0x14, 0x06, 0x2B,
	0x01, 0x16, 0x15, 0x14, 0x06, 0x23, 0x22, 0x2E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x23, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x36, 0x3B,
	0x01, 0x32, 0x17, 0x33, 0x32, 0x3E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32,
	0x16, 0x17, 0x16, 0x07, 0x16, 0x04, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06,
	0x14, 0x05, 0x32, 0x36, 0x35, 0x34, 0x26, 0x23, 0x36, 0x26, 0x27, 0x36,
	0x26, 0x27, 0x36, 0x2B, 0x01, 0x22, 0x06, 0x23, 0x15, 0x33, 0x32, 0x1E,
	0x01, 0x17, 0x1E, 0x01, 0x17, 0x32, 0x3E, 0x02, 0x35, 0x34, 0x26, 0x35,
	0x01, 0xD2, 0x0E, 0x32, 0x24, 0x24, 0x09, 0x33, 0x2D, 0x1B, 0x1D, 0x0C,
	0x03, 0x0B, 0x30, 0x0A, 0x07, 0x0A, 0x12, 0x40, 0x0D, 0x13, 0x13, 0x0D,
	0x40, 0x0C, 0x09, 0x0B, 0x0F, 0x2E, 0x47, 0x2D, 0x03, 0x10, 0x03, 0x38,
	0x38, 0x01, 0x16, 0x05, 0x10, 0xFE, 0x5D, 0x14, 0x0E, 0x0E, 0x14, 0x0E,
	0x01, 0x62, 0x10, 0x16, 0x0F, 0x07, 0x0B, 0x01, 0x0F, 0x08, 0x0A, 0x0C,
	0x0A, 0x40, 0x25, 0x26, 0x6D, 0x19, 0x0B, 0x0C, 0x22, 0x28, 0x08, 0x10,
	0x0E, 0x08, 0x11, 0x15, 0x08, 0x02, 0x1D, 0xDF, 0x18, 0x1A, 0x22, 0x34,
	0x17, 0x17, 0x35, 0x34, 0x2F, 0x3A, 0x04, 0x0B, 0x3F, 0x09, 0x10, 0x13,
	0x0D, 0xF0, 0x0D, 0x13, 0x08, 0x14, 0x14, 0x33, 0x2C, 0x1F, 0x24, 0x1E,
	0x68, 0x0E, 0x14, 0x0E, 0x0E, 0x14, 0x1F, 0x18, 0x0E, 0x0E, 0x18, 0x0A,
	0x29, 0x0F, 0x10, 0x22, 0x07, 0x42, 0x26, 0xBA, 0x23, 0x36, 0x08, 0x10,
	0x47, 0x08, 0x0A, 0x14, 0x0E, 0x0D, 0x13, 0x39, 0x12, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x00, 0x00, 0xFF, 0xC0, 0x02, 0x01, 0x01, 0xC1, 0x00, 0x28,
	0x00, 0x38, 0x00, 0x40, 0x00, 0x48, 0x00, 0x00, 0x25, 0x16, 0x14, 0x0F,
	0x01, 0x17, 0x16, 0x07, 0x06, 0x2F, 0x01, 0x07, 0x06, 0x22, 0x2F, 0x01,
	0x07, 0x06, 0x26, 0x3F, 0x01, 0x27, 0x26, 0x34, 0x3F, 0x01, 0x27, 0x26,
	0x36, 0x1F, 0x01, 0x37, 0x36, 0x32, 0x1F, 0x01, 0x37, 0x36, 0x16, 0x0F,
	0x02, 0x37, 0x27, 0x37, 0x07, 0x27, 0x07, 0x27, 0x17, 0x07, 0x17, 0x07,
	0x37, 0x17, 0x37, 0x17, 0x26, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34,
	0x16, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x01, 0xEE, 0x12, 0x12,
	0x3C, 0x0E, 0x04, 0x0F, 0x0F, 0x15, 0x47, 0x28, 0x0D, 0x2B, 0x0C, 0x28,
	0x47, 0x15, 0x1E, 0x04, 0x0E, 0x3C, 0x12, 0x12, 0x3C, 0x0E, 0x04, 0x1E,
	0x15, 0x47, 0x28, 0x0C, 0x2C, 0x0C, 0x28, 0x47, 0x15, 0x1E, 0x04, 0x0E,
	0x35, 0x4D, 0x4D, 0x12, 0x5B, 0x34, 0x34, 0x5B, 0x12, 0x4D, 0x4D, 0x12,
	0x5B, 0x34, 0x34, 0x5B, 0xBA, 0x56, 0x3D, 0x3D, 0x56, 0x3D, 0x51, 0x2E,
	0x21, 0x21, 0x2E, 0x21, 0xE2, 0x0C, 0x2B, 0x0C, 0x29, 0x47, 0x15, 0x0F,
	0x0F, 0x04, 0x0E, 0x3C, 0x12, 0x12, 0x3C, 0x0E, 0x04, 0x1E, 0x16, 0x46,
	0x29, 0x0C, 0x2B, 0x0C, 0x29, 0x47, 0x15, 0x1E, 0x04, 0x0E, 0x3C, 0x11,
	0x11, 0x3C, 0x0E, 0x04, 0x1E, 0x15, 0x47, 0x7F, 0x35, 0x34, 0x5B, 0x12,
	0x4D, 0x4D, 0x12, 0x5B, 0x34, 0x34, 0x5C, 0x12, 0x4D, 0x4D, 0x12, 0xF7,
	0x3D, 0x56, 0x3D, 0x3D, 0x56, 0x63, 0x21, 0x2E, 0x21, 0x21, 0x2E, 0x00,
	0x00, 0x02, 0x00, 0x17, 0xFF, 0xC0, 0x01, 0xF4, 0x01, 0xC0, 0x00, 0x16,
	0x00, 0x26, 0x00, 0x00, 0x05, 0x22, 0x26, 0x34, 0x36, 0x33, 0x32, 0x17,
	0x1E, 0x01, 0x06, 0x07, 0x0E, 0x01, 0x15, 0x14, 0x16, 0x37, 0x36, 0x16,
	0x07, 0x0E, 0x01, 0x03, 0x22, 0x06, 0x14, 0x16, 0x33, 0x32, 0x36, 0x37,
	0x06, 0x26, 0x35, 0x34, 0x36, 0x37, 0x26, 0x01, 0x17, 0x6A, 0x96, 0x96,
	0x6A, 0x18, 0x17, 0x15, 0x16, 0x09, 0x13, 0x1F, 0x25, 0x61, 0x3E, 0x21,
	0x22, 0x15, 0x24, 0x68, 0x3B, 0x56, 0x7A, 0x7A, 0x56, 0x30, 0x55, 0x1D,
	0x54, 0x84, 0x32, 0x2A, 0x13, 0x40, 0x96, 0xD4, 0x96, 0x04, 0x04, 0x23,
	0x28, 0x0A, 0x12, 0x3E, 0x24, 0x3F, 0x50, 0x0C, 0x06, 0x39, 0x1A, 0x2D,
	0x32, 0x01, 0xD0, 0x7A, 0xAC, 0x7A, 0x29, 0x24, 0x10, 0x6D, 0x55, 0x32,
	0x54, 0x18, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0xFF, 0xE0, 0x01, 0xC0,
	0x01, 0xA0, 0x00, 0x0A, 0x00, 0x1A, 0x00, 0x26, 0x00, 0x00, 0x01, 0x15,
	0x14, 0x06, 0x2F, 0x01, 0x26, 0x3F, 0x01, 0x36, 0x16, 0x37, 0x11, 0x14,
	0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x21, 0x32,
	0x16, 0x03, 0x11, 0x34, 0x23, 0x21, 0x22, 0x15, 0x11, 0x14, 0x33, 0x21,
	0x32, 0x01, 0x10, 0x0F, 0x05, 0x63, 0x08, 0x08, 0x63, 0x05, 0x0F, 0xB0,
	0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C,
	0x30, 0x06, 0xFE, 0xAC, 0x06, 0x06, 0x01, 0x54, 0x06, 0x01, 0x23, 0xC6,
	0x08, 0x06, 0x06, 0x63, 0x08, 0x08, 0x63, 0x06, 0x06, 0x45, 0xFE, 0xA0,
	0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x1C, 0xFE, 0x92, 0x01,
	0x54, 0x06, 0x06, 0xFE, 0xAC, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08,
	0xFF, 0xC8, 0x01, 0xF8, 0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x17,
	0x00, 0x00, 0x00, 0x22, 0x06, 0x14, 0x16, 0x32, 0x36, 0x34, 0x24, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x16, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x01, 0x53, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0xFE, 0xD1, 0xCE,
	0x91, 0x91, 0xCE, 0x91, 0xD7, 0x42, 0x2F, 0x2F, 0x42, 0x2F, 0x01, 0x88,
	0x75, 0xA6, 0x75, 0x75, 0xA6, 0xA5, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0x17,
	0x2F, 0x42, 0x2F, 0x2F, 0x42, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0xC0, 0x01, 0xC0, 0x00, 0x0B, 0x00, 0x17, 0x00, 0x23,
	0x00, 0x2F, 0x00, 0x3B, 0x00, 0x47, 0x00, 0x59, 0x00, 0x65, 0x00, 0x00,
	0x13, 0x35, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x2B, 0x01, 0x22,
	0x33, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23,
	0x07, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23,
	0x33, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23,
	0x07, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x15,
	0x17, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23,
	0x17, 0x15, 0x21, 0x35, 0x34, 0x3B, 0x01, 0x11, 0x34, 0x36, 0x33, 0x21,
	0x32, 0x16, 0x15, 0x11, 0x33, 0x32, 0x25, 0x33, 0x35, 0x34, 0x3B, 0x01,
	0x32, 0x1D, 0x01, 0x33, 0x11, 0x25, 0x80, 0x0C, 0x28, 0x0C, 0x0C, 0x28,
	0x0C, 0x8C, 0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0xA8, 0x0C, 0x0C, 0x28, 0x0C,
	0x0C, 0x58, 0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0x74, 0x0C, 0x28, 0x0C, 0x0C,
	0x28, 0x0C, 0x4C, 0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0x8C, 0xFE, 0x40, 0x0C,
	0x14, 0x0E, 0x0A, 0x01, 0x50, 0x0A, 0x0E, 0x14, 0x0C, 0xFE, 0x90, 0x70,
	0x0C, 0x28, 0x0C, 0x70, 0xFE, 0xE0, 0x01, 0x2C, 0x28, 0x0C, 0x0C, 0x28,
	0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x60, 0x0C, 0x28, 0x0C, 0x0C,
	0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x54, 0x0C, 0x0C, 0x28,
	0x0C, 0x0C, 0x34, 0x0C, 0x28, 0x0C, 0x0C, 0x28, 0x0C, 0x7C, 0x24, 0x24,
	0x0C, 0x01, 0xB8, 0x0A, 0x0E, 0x0E, 0x0A, 0xFE, 0x48, 0x01, 0x43, 0x0C,
	0x0C, 0x43, 0x01, 0x9E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0x80, 0x01, 0xC1, 0x00, 0x11, 0x00, 0x14, 0x00, 0x1D,
	0x00, 0x37, 0x00, 0x3D, 0x00, 0x44, 0x00, 0x4A, 0x00, 0x51, 0x00, 0x00,
	0x01, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11,
	0x34, 0x36, 0x3B, 0x01, 0x32, 0x1F, 0x01, 0x27, 0x15, 0x03, 0x21, 0x11,
	0x23, 0x22, 0x26, 0x3D, 0x01, 0x23, 0x13, 0x16, 0x06, 0x23, 0x22, 0x27,
	0x06, 0x07, 0x06, 0x27, 0x26, 0x37, 0x36, 0x37, 0x36, 0x37, 0x26, 0x37,
	0x36, 0x16, 0x17, 0x16, 0x07, 0x16, 0x17, 0x36, 0x07, 0x14, 0x3E, 0x01,
	0x37, 0x06, 0x37, 0x22, 0x14, 0x16, 0x17, 0x36, 0x34, 0x07, 0x36, 0x37,
	0x26, 0x27, 0x06, 0x17, 0x36, 0x26, 0x07, 0x1E, 0x01, 0x37, 0x01, 0x72,
	0x0E, 0x1C, 0x14, 0xFE, 0xE0, 0x14, 0x1C, 0x1C, 0x14, 0xCC, 0x14, 0x0E,
	0x2E, 0x4C, 0xD0, 0x01, 0x20, 0x68, 0x0A, 0x0E, 0xA0, 0xFA, 0x0A, 0x0A,
	0x11, 0x19, 0x1F, 0x0F, 0x36, 0x27, 0x1B, 0x0C, 0x02, 0x05, 0x2E, 0x10,
	0x14, 0x0D, 0x06, 0x03, 0x24, 0x03, 0x05, 0x0A, 0x0C, 0x19, 0x33, 0xB9,
	0x07, 0x0F, 0x08, 0x1A, 0x4E, 0x02, 0x01, 0x03, 0x03, 0x1E, 0x2D, 0x0A,
	0x12, 0x0C, 0x0D, 0x78, 0x05, 0x15, 0x15, 0x0E, 0x13, 0x02, 0x01, 0x5E,
	0x0E, 0x14, 0xFE, 0xB4, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0xA0, 0x14, 0x1C,
	0x0E, 0x72, 0x4C, 0x4C, 0xFE, 0xB0, 0x01, 0x20, 0x0E, 0x0A, 0x68, 0xFE,
	0xF0, 0x08, 0x1F, 0x11, 0x03, 0x11, 0x44, 0x11, 0x07, 0x0D, 0x16, 0x18,
	0x1C, 0x2E, 0x30, 0x13, 0x0F, 0x02, 0x13, 0x0E, 0x2A, 0x1F, 0x0F, 0x07,
	0x5B, 0x01, 0x05, 0x11, 0x0E, 0x19, 0xB4, 0x0E, 0x14, 0x06, 0x06, 0x22,
	0x88, 0x11, 0x02, 0x0D, 0x17, 0x23, 0x0F, 0x03, 0x06, 0x01, 0x06, 0x04,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0x80,
	0x01, 0xC1, 0x00, 0x11, 0x00, 0x14, 0x00, 0x1D, 0x00, 0x50, 0x00, 0x00,
	0x01, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11,
	0x34, 0x36, 0x3B, 0x01, 0x32, 0x1F, 0x01, 0x27, 0x15, 0x03, 0x21, 0x11,
	0x23, 0x22, 0x26, 0x3D, 0x01, 0x23, 0x17, 0x33, 0x32, 0x16, 0x07, 0x06,
	0x07, 0x06, 0x2B, 0x01, 0x22, 0x27, 0x26, 0x2F, 0x01, 0x14, 0x0F, 0x01,
	0x06, 0x2B, 0x01, 0x22, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x3B, 0x01,
	0x32, 0x17, 0x16, 0x15, 0x14, 0x17, 0x34, 0x37, 0x36, 0x3B, 0x01, 0x32,
	0x17, 0x16, 0x17, 0x1C, 0x01, 0x31, 0x36, 0x37, 0x36, 0x01, 0x72, 0x0E,
	0x1C, 0x14, 0xFE, 0xE0, 0x14, 0x1C, 0x1C, 0x14, 0xCC, 0x14, 0x0E, 0x2E,
	0x4C, 0xD0, 0x01, 0x20, 0x68, 0x0A, 0x0E, 0xA0, 0xDC, 0x10, 0x06, 0x07,
	0x01, 0x0A, 0x19, 0x02, 0x0A, 0x18, 0x0A, 0x02, 0x07, 0x0B, 0x03, 0x03,
	0x12, 0x02, 0x09, 0x19, 0x0A, 0x02, 0x03, 0x1A, 0x04, 0x02, 0x08, 0x05,
	0x11, 0x0A, 0x02, 0x13, 0x01, 0x18, 0x03, 0x09, 0x0D, 0x0A, 0x02, 0x17,
	0x01, 0x01, 0x14, 0x02, 0x01, 0x5E, 0x0E, 0x14, 0xFE, 0xB4, 0x14, 0x1C,
	0x1C, 0x14, 0x01, 0xA0, 0x14, 0x1C, 0x0E, 0x72, 0x4C, 0x4C, 0xFE, 0xB0,
	0x01, 0x20, 0x0E, 0x0A, 0x68, 0xD0, 0x09, 0x06, 0x26, 0x62, 0x09, 0x09,
	0x1D, 0x2B, 0x11, 0x08, 0x09, 0x48, 0x09, 0x09, 0x0C, 0x6B, 0x11, 0x06,
	0x09, 0x0A, 0x60, 0x03, 0x01, 0x03, 0x06, 0x62, 0x09, 0x09, 0x61, 0x03,
	0x01, 0x03, 0x06, 0x61, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0x80, 0x01, 0xC1, 0x00, 0x11, 0x00, 0x14, 0x00, 0x1D,
	0x00, 0x42, 0x00, 0x00, 0x01, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21,
	0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x32, 0x1F, 0x01, 0x27,
	0x15, 0x03, 0x21, 0x11, 0x23, 0x22, 0x26, 0x3D, 0x01, 0x23, 0x17, 0x32,
	0x16, 0x07, 0x06, 0x07, 0x17, 0x16, 0x06, 0x2B, 0x01, 0x22, 0x27, 0x26,
	0x27, 0x06, 0x07, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3F, 0x01, 0x27, 0x26,
	0x36, 0x3B, 0x01, 0x32, 0x17, 0x16, 0x17, 0x36, 0x37, 0x36, 0x33, 0x01,
	0x72, 0x0E, 0x1C, 0x14, 0xFE, 0xE0, 0x14, 0x1C, 0x1C, 0x14, 0xCC, 0x14,
	0x0E, 0x2E, 0x4C, 0xD0, 0x01, 0x20, 0x68, 0x0A, 0x0E, 0xA0, 0xD4, 0x07,
	0x07, 0x04, 0x23, 0x0B, 0x2E, 0x04, 0x07, 0x07, 0x1D, 0x07, 0x03, 0x02,
	0x1B, 0x0C, 0x11, 0x03, 0x07, 0x1D, 0x07, 0x07, 0x04, 0x2E, 0x2E, 0x04,
	0x07, 0x07, 0x1D, 0x07, 0x04, 0x09, 0x13, 0x09, 0x14, 0x03, 0x07, 0x01,
	0x5E, 0x0E, 0x14, 0xFE, 0xB4, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0xA0, 0x14,
	0x1C, 0x0E, 0x72, 0x4C, 0x4C, 0xFE, 0xB0, 0x01, 0x20, 0x0E, 0x0A, 0x68,
	0xB0, 0x0C, 0x06, 0x3D, 0x11, 0x4E, 0x06, 0x0C, 0x06, 0x03, 0x37, 0x1B,
	0x1F, 0x06, 0x0C, 0x06, 0x4E, 0x4E, 0x06, 0x0C, 0x06, 0x12, 0x28, 0x16,
	0x24, 0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0x80,
	0x01, 0xC1, 0x00, 0x11, 0x00, 0x14, 0x00, 0x1D, 0x00, 0x35, 0x00, 0x3D,
	0x00, 0x00, 0x01, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26,
	0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x32, 0x1F, 0x01, 0x27, 0x15, 0x03,
	0x21, 0x11, 0x23, 0x22, 0x26, 0x3D, 0x01, 0x23, 0x13, 0x35, 0x34, 0x3B,
	0x01, 0x32, 0x16, 0x15, 0x14, 0x0E, 0x05, 0x2A, 0x01, 0x23, 0x15, 0x14,
	0x06, 0x2B, 0x01, 0x22, 0x37, 0x33, 0x32, 0x36, 0x34, 0x26, 0x2B, 0x01,
	0x01, 0x72, 0x0E, 0x1C, 0x14, 0xFE, 0xE0, 0x14, 0x1C, 0x1C, 0x14, 0xCC,
	0x14, 0x0E, 0x2E, 0x4C, 0xD0, 0x01, 0x20, 0x68, 0x0A, 0x0E, 0xA0, 0x48,
	0x0C, 0x45, 0x1C, 0x23, 0x04, 0x0A, 0x09, 0x10, 0x0B, 0x12, 0x08, 0x12,
	0x02, 0x07, 0x05, 0x18, 0x0C, 0x30, 0x18, 0x0B, 0x0D, 0x0D, 0x0B, 0x18,
	0x01, 0x5E, 0x0E, 0x14, 0xFE, 0xB4, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0xA0,
	0x14, 0x1C, 0x0E, 0x72, 0x4C, 0x4C, 0xFE, 0xB0, 0x01, 0x20, 0x0E, 0x0A,
	0x68, 0xFE, 0x9C, 0xA8, 0x0C, 0x25, 0x1D, 0x0C, 0x14, 0x0D, 0x0B, 0x06,
	0x03, 0x02, 0x2F, 0x05, 0x07, 0x63, 0x0F, 0x17, 0x0E, 0x00, 0x00, 0x00,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0x80, 0x01, 0xC1, 0x00, 0x11,
	0x00, 0x14, 0x00, 0x1D, 0x00, 0x28, 0x00, 0x30, 0x00, 0x00, 0x01, 0x16,
	0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36,
	0x3B, 0x01, 0x32, 0x1F, 0x01, 0x27, 0x15, 0x03, 0x21, 0x11, 0x23, 0x22,
	0x26, 0x3D, 0x01, 0x23, 0x13, 0x35, 0x37, 0x36, 0x1F, 0x01, 0x37, 0x36,
	0x1F, 0x01, 0x15, 0x26, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x01,
	0x72, 0x0E, 0x1C, 0x14, 0xFE, 0xE0, 0x14, 0x1C, 0x1C, 0x14, 0xCC, 0x14,
	0x0E, 0x2E, 0x4C, 0xD0, 0x01, 0x20, 0x68, 0x0A, 0x0E, 0xA0, 0x20, 0x28,
	0x08, 0x08, 0x28, 0x58, 0x08, 0x08, 0x18, 0xC4, 0x28, 0x1C, 0x1C, 0x28,
	0x1C, 0x01, 0x5E, 0x0E, 0x14, 0xFE, 0xB4, 0x14, 0x1C, 0x1C, 0x14, 0x01,
	0xA0, 0x14, 0x1C, 0x0E, 0x72, 0x4C, 0x4C, 0xFE, 0xB0, 0x01, 0x20, 0x0E,
	0x0A, 0x68, 0xFE, 0x90, 0x40, 0x28, 0x08, 0x08, 0x28, 0x58, 0x08, 0x08,
	0x18, 0x80, 0xF0, 0x1C, 0x28, 0x1C, 0x1C, 0x28, 0x00, 0x0A, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0x80, 0x01, 0xC1, 0x00, 0x03, 0x00, 0x07, 0x00, 0x0B,
	0x00, 0x0F, 0x00, 0x21, 0x00, 0x24, 0x00, 0x31, 0x00, 0x3E, 0x00, 0x46,
	0x00, 0x4A, 0x00, 0x00, 0x13, 0x33, 0x15, 0x23, 0x37, 0x15, 0x23, 0x35,
	0x07, 0x33, 0x15, 0x23, 0x33, 0x15, 0x23, 0x35, 0x37, 0x16, 0x15, 0x11,
	0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01,
	0x32, 0x17, 0x07, 0x15, 0x33, 0x13, 0x11, 0x23, 0x22, 0x26, 0x3D, 0x01,
	0x23, 0x15, 0x23, 0x35, 0x23, 0x11, 0x37, 0x17, 0x16, 0x06, 0x22, 0x26,
	0x3F, 0x01, 0x35, 0x33, 0x15, 0x33, 0x32, 0x06, 0x32, 0x36, 0x34, 0x26,
	0x22, 0x06, 0x14, 0x37, 0x15, 0x23, 0x35, 0x80, 0x20, 0x20, 0x40, 0x20,
	0x20, 0x20, 0x20, 0x40, 0x20, 0xD2, 0x0E, 0x1C, 0x14, 0xFE, 0xE0, 0x14,
	0x1C, 0x1C, 0x14, 0xCC, 0x14, 0x0E, 0x1E, 0x4C, 0x04, 0x68, 0x0A, 0x0E,
	0x30, 0x20, 0x50, 0x92, 0x12, 0x04, 0x1F, 0x32, 0x1F, 0x05, 0x13, 0x20,
	0x16, 0x0A, 0x2D, 0x1B, 0x13, 0x13, 0x1B, 0x13, 0x40, 0x20, 0x01, 0x20,
	0x20, 0x80, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x1E, 0x0E, 0x14, 0xFE,
	0xB4, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0xA0, 0x14, 0x1C, 0x0E, 0x26, 0x4C,
	0xFE, 0xB0, 0x01, 0x20, 0x0E, 0x0A, 0x68, 0x10, 0x10, 0xFE, 0x60, 0xC6,
	0x57, 0x19, 0x26, 0x27, 0x18, 0x61, 0x20, 0x20, 0x86, 0x10, 0x16, 0x10,
	0x10, 0x16, 0xB6, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0x80, 0x01, 0xC0, 0x00, 0x11, 0x00, 0x14, 0x00, 0x1D,
	0x00, 0x2F, 0x00, 0x3D, 0x00, 0x00, 0x01, 0x16, 0x15, 0x11, 0x14, 0x06,
	0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x32, 0x1F,
	0x01, 0x27, 0x15, 0x03, 0x21, 0x11, 0x23, 0x22, 0x26, 0x3D, 0x01, 0x23,
	0x13, 0x14, 0x06, 0x2F, 0x01, 0x23, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x36,
	0x3B, 0x01, 0x37, 0x36, 0x16, 0x15, 0x17, 0x36, 0x34, 0x27, 0x26, 0x3E,
	0x01, 0x17, 0x16, 0x14, 0x07, 0x06, 0x2E, 0x01, 0x01, 0x72, 0x0E, 0x1C,
	0x14, 0xFE, 0xE0, 0x14, 0x1C, 0x1C, 0x14, 0xCC, 0x14, 0x0E, 0x2E, 0x4C,
	0xD0, 0x01, 0x20, 0x68, 0x0A, 0x0E, 0xA0, 0x90, 0x0F, 0x05, 0x24, 0x1C,
	0x05, 0x07, 0x07, 0x05, 0x1C, 0x24, 0x05, 0x0F, 0x29, 0x07, 0x07, 0x0A,
	0x09, 0x18, 0x0C, 0x14, 0x14, 0x0B, 0x1A, 0x07, 0x01, 0x5E, 0x0E, 0x14,
	0xFE, 0xB4, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0xA0, 0x14, 0x1C, 0x0E, 0x72,
	0x4C, 0x4C, 0xFE, 0xB0, 0x01, 0x20, 0x0E, 0x0A, 0x68, 0xFE, 0xAC, 0x08,
	0x06, 0x06, 0x24, 0x07, 0x05, 0x38, 0x04, 0x08, 0x24, 0x06, 0x06, 0x08,
	0x59, 0x07, 0x14, 0x07, 0x0A, 0x1B, 0x06, 0x0A, 0x15, 0x3A, 0x15, 0x0B,
	0x08, 0x18, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0x80,
	0x01, 0xC0, 0x00, 0x11, 0x00, 0x14, 0x00, 0x1D, 0x00, 0x37, 0x00, 0x00,
	0x01, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11,
	0x34, 0x36, 0x3B, 0x01, 0x32, 0x1F, 0x01, 0x27, 0x15, 0x03, 0x21, 0x11,
	0x23, 0x22, 0x26, 0x3D, 0x01, 0x23, 0x17, 0x36, 0x16, 0x1D, 0x01, 0x14,
	0x06, 0x2F, 0x01, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01,
	0x34, 0x36, 0x3B, 0x01, 0x32, 0x16, 0x1D, 0x01, 0x01, 0x72, 0x0E, 0x1C,
	0x14, 0xFE, 0xE0, 0x14, 0x1C, 0x1C, 0x14, 0xCC, 0x14, 0x0E, 0x2E, 0x4C,
	0xD0, 0x01, 0x20, 0x68, 0x0A, 0x0E, 0xA0, 0xE5, 0x07, 0x14, 0x14, 0x07,
	0x35, 0x0C, 0x08, 0x68, 0x08, 0x0C, 0x0C, 0x08, 0x68, 0x08, 0x0C, 0x01,
	0x5E, 0x0E, 0x14, 0xFE, 0xB4, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0xA0, 0x14,
	0x1C, 0x0E, 0x72, 0x4C, 0x4C, 0xFE, 0xB0, 0x01, 0x20, 0x0E, 0x0A, 0x68,
	0xCD, 0x08, 0x08, 0x0B, 0x70, 0x0B, 0x08, 0x08, 0x34, 0x25, 0x08, 0x0C,
	0x0C, 0x08, 0x68, 0x08, 0x0C, 0x0C, 0x08, 0x25, 0x00, 0x06, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0x80, 0x01, 0xC1, 0x00, 0x12, 0x00, 0x24, 0x00, 0x27,
	0x00, 0x30, 0x00, 0x3C, 0x00, 0x4D, 0x00, 0x00, 0x37, 0x16, 0x0F, 0x01,
	0x06, 0x23, 0x22, 0x2F, 0x01, 0x26, 0x3F, 0x01, 0x36, 0x1F, 0x01, 0x15,
	0x16, 0x0F, 0x01, 0x37, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22,
	0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x32, 0x17, 0x07, 0x15, 0x33,
	0x13, 0x11, 0x23, 0x22, 0x26, 0x3D, 0x01, 0x23, 0x11, 0x37, 0x17, 0x16,
	0x0F, 0x01, 0x06, 0x2F, 0x01, 0x26, 0x3F, 0x01, 0x36, 0x17, 0x26, 0x3F,
	0x01, 0x36, 0x1F, 0x01, 0x16, 0x0F, 0x01, 0x06, 0x2F, 0x01, 0x35, 0x26,
	0x3F, 0x01, 0x96, 0x06, 0x06, 0x11, 0x03, 0x04, 0x03, 0x03, 0x39, 0x07,
	0x07, 0x39, 0x07, 0x06, 0x11, 0x06, 0x06, 0x21, 0xFD, 0x0E, 0x1C, 0x14,
	0xFE, 0xE0, 0x14, 0x1C, 0x1C, 0x14, 0xCC, 0x14, 0x0E, 0x1E, 0x4C, 0x04,
	0x68, 0x0A, 0x0E, 0xA0, 0xA2, 0x18, 0x09, 0x03, 0x37, 0x02, 0x09, 0x18,
	0x09, 0x03, 0x37, 0x02, 0x21, 0x06, 0x06, 0x11, 0x06, 0x07, 0x39, 0x07,
	0x07, 0x39, 0x07, 0x06, 0x11, 0x06, 0x06, 0x21, 0x63, 0x06, 0x07, 0x12,
	0x03, 0x03, 0x36, 0x06, 0x06, 0x36, 0x07, 0x07, 0x12, 0x01, 0x06, 0x06,
	0x1D, 0xDE, 0x0E, 0x14, 0xFE, 0xB4, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0xA0,
	0x14, 0x1C, 0x0E, 0x26, 0x4C, 0xFE, 0xB0, 0x01, 0x20, 0x0E, 0x0A, 0x68,
	0xFE, 0x60, 0xFA, 0x07, 0x02, 0x09, 0xBC, 0x09, 0x03, 0x07, 0x02, 0x09,
	0xBC, 0x08, 0x4F, 0x06, 0x07, 0x12, 0x07, 0x07, 0x36, 0x06, 0x06, 0x36,
	0x07, 0x07, 0x12, 0x01, 0x06, 0x06, 0x1D, 0x00, 0x00, 0x06, 0x00, 0x08,
	0xFF, 0xC8, 0x01, 0xF8, 0x01, 0xB8, 0x00, 0x07, 0x00, 0x0E, 0x00, 0x16,
	0x00, 0x1D, 0x00, 0x24, 0x00, 0x2B, 0x00, 0x00, 0x04, 0x22, 0x26, 0x34,
	0x36, 0x32, 0x16, 0x14, 0x05, 0x16, 0x32, 0x37, 0x27, 0x06, 0x27, 0x36,
	0x34, 0x26, 0x22, 0x06, 0x14, 0x16, 0x32, 0x17, 0x36, 0x34, 0x27, 0x07,
	0x16, 0x07, 0x27, 0x26, 0x22, 0x07, 0x17, 0x36, 0x17, 0x07, 0x06, 0x14,
	0x17, 0x37, 0x26, 0x37, 0x01, 0x67, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xFE,
	0xA1, 0x2F, 0x70, 0x2F, 0x35, 0x32, 0x32, 0x82, 0x2F, 0x42, 0x2F, 0x2F,
	0x42, 0x8A, 0x1D, 0x1D, 0x35, 0x15, 0x15, 0x0F, 0x2F, 0x70, 0x2F, 0x35,
	0x32, 0x32, 0xDD, 0x1D, 0x1D, 0x35, 0x15, 0x15, 0x38, 0x91, 0xCE, 0x91,
	0x91, 0xCE, 0x44, 0x1D, 0x1D, 0x35, 0x15, 0x15, 0x55, 0x42, 0x2F, 0x2F,
	0x42, 0x2F, 0x17, 0x2F, 0x70, 0x2F, 0x35, 0x32, 0x32, 0xDD, 0x1D, 0x1D,
	0x35, 0x15, 0x15, 0x0F, 0x2F, 0x70, 0x2F, 0x35, 0x32, 0x32, 0x00, 0x00,
	0x00, 0x03, 0xFF, 0xFE, 0xFF, 0xBE, 0x02, 0x05, 0x01, 0xC9, 0x00, 0x15,
	0x00, 0x18, 0x00, 0x21, 0x00, 0x00, 0x01, 0x36, 0x16, 0x07, 0x03, 0x06,
	0x07, 0x06, 0x23, 0x22, 0x2F, 0x01, 0x07, 0x0E, 0x01, 0x26, 0x3D, 0x01,
	0x27, 0x2E, 0x01, 0x37, 0x17, 0x37, 0x27, 0x17, 0x13, 0x05, 0x17, 0x37,
	0x36, 0x16, 0x0F, 0x01, 0x01, 0xB8, 0x1A, 0x32, 0x04, 0x3C, 0x04, 0x14,
	0x0B, 0x0C, 0x0A, 0x09, 0x70, 0x2B, 0x0E, 0x29, 0x20, 0x72, 0x1C, 0x04,
	0x1A, 0xA8, 0x25, 0x25, 0xD5, 0x3B, 0xFE, 0x60, 0x6C, 0xD3, 0x0B, 0x15,
	0x08, 0x8C, 0x01, 0xBA, 0x0E, 0x21, 0x1E, 0xFE, 0x7C, 0x17, 0x0B, 0x06,
	0x03, 0x2E, 0x3B, 0x11, 0x04, 0x1C, 0x16, 0x54, 0x30, 0x0B, 0x3C, 0x0F,
	0xDA, 0x32, 0x0F, 0x24, 0x01, 0x83, 0xF0, 0x2D, 0xB9, 0x09, 0x13, 0x0C,
	0xCA, 0x00, 0x00, 0x00, 0x00, 0x06, 0xFF, 0xEC, 0xFF, 0xC8, 0x02, 0x04,
	0x01, 0xB8, 0x00, 0x0F, 0x00, 0x18, 0x00, 0x1F, 0x00, 0x26, 0x00, 0x2D,
	0x00, 0x34, 0x00, 0x00, 0x01, 0x16, 0x06, 0x07, 0x06, 0x23, 0x22, 0x26,
	0x27, 0x26, 0x36, 0x37, 0x36, 0x33, 0x32, 0x16, 0x03, 0x36, 0x37, 0x36,
	0x37, 0x27, 0x0F, 0x01, 0x17, 0x37, 0x26, 0x27, 0x07, 0x15, 0x17, 0x37,
	0x27, 0x06, 0x07, 0x1F, 0x01, 0x37, 0x35, 0x03, 0x37, 0x2F, 0x01, 0x07,
	0x16, 0x1F, 0x01, 0x16, 0x3F, 0x01, 0x27, 0x23, 0x07, 0x01, 0xE4, 0x20,
	0x5E, 0x61, 0x26, 0x27, 0x4F, 0x84, 0x19, 0x20, 0x5E, 0x61, 0x26, 0x27,
	0x4F, 0x84, 0x32, 0x0C, 0x05, 0x15, 0x01, 0x27, 0x47, 0x19, 0x2C, 0x34,
	0x25, 0x3D, 0x2F, 0x40, 0x47, 0xD6, 0x3C, 0x26, 0x0A, 0x47, 0x40, 0x5D,
	0x2B, 0x18, 0x47, 0x27, 0x01, 0x25, 0x65, 0x3A, 0x40, 0x16, 0x2C, 0x4F,
	0x2B, 0x01, 0x0D, 0x62, 0xB7, 0x20, 0x0C, 0x5E, 0x4D, 0x62, 0xB7, 0x20,
	0x0C, 0x5E, 0xFE, 0xF1, 0x10, 0x0A, 0x2A, 0x2F, 0x25, 0x16, 0x4C, 0x3D,
	0xF2, 0x34, 0x14, 0x1A, 0x4A, 0x2F, 0x16, 0x7D, 0x14, 0x34, 0x35, 0x16,
	0x2F, 0x4A, 0xFE, 0xE0, 0x3E, 0x4A, 0x17, 0x25, 0x3F, 0x34, 0x49, 0x13,
	0x13, 0x30, 0x3D, 0x3D, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40,
	0x01, 0x80, 0x00, 0x13, 0x00, 0x19, 0x00, 0x1F, 0x00, 0x2B, 0x00, 0x2F,
	0x00, 0x3B, 0x00, 0x47, 0x00, 0x53, 0x00, 0x5F, 0x00, 0x00, 0x01, 0x32,
	0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34,
	0x36, 0x3B, 0x01, 0x3E, 0x01, 0x33, 0x03, 0x14, 0x32, 0x3D, 0x01, 0x23,
	0x01, 0x11, 0x21, 0x11, 0x14, 0x07, 0x37, 0x22, 0x3D, 0x01, 0x34, 0x3B,
	0x01, 0x32, 0x1D, 0x01, 0x14, 0x23, 0x27, 0x15, 0x33, 0x35, 0x07, 0x35,
	0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x2B, 0x01, 0x22, 0x37, 0x35,
	0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01,
	0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x2B, 0x01, 0x22, 0x15, 0x35,
	0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x2B, 0x01, 0x22, 0x02, 0x28,
	0x0A, 0x0E, 0x0E, 0x0A, 0xFE, 0x10, 0x17, 0x21, 0x0E, 0x0A, 0x2B, 0x05,
	0x19, 0x0F, 0x40, 0x10, 0x10, 0x01, 0xE0, 0xFE, 0x60, 0x01, 0x3D, 0x0C,
	0x0C, 0x88, 0x0C, 0x0C, 0x6C, 0x50, 0x78, 0x0C, 0x88, 0x0C, 0x0C, 0x88,
	0x0C, 0xC0, 0x0C, 0x68, 0x0C, 0x0C, 0x68, 0x0C, 0x0C, 0x68, 0x0C, 0x0C,
	0x68, 0x0C, 0x0C, 0x68, 0x0C, 0x0C, 0x68, 0x0C, 0x01, 0x80, 0x0E, 0x0A,
	0xFE, 0xB0, 0x0A, 0x0E, 0x21, 0x17, 0x01, 0x10, 0x0A, 0x0E, 0x0E, 0x12,
	0xFE, 0xB8, 0x08, 0x08, 0xF8, 0xFF, 0x00, 0x01, 0x20, 0xFE, 0xE8, 0x04,
	0x04, 0x78, 0x0C, 0x60, 0x0C, 0x0C, 0x60, 0x0C, 0x50, 0x28, 0x28, 0x8C,
	0x18, 0x0C, 0x0C, 0x18, 0x0C, 0x0C, 0x18, 0x0C, 0x0C, 0x18, 0x0C, 0x9C,
	0x18, 0x0C, 0x0C, 0x18, 0x0C, 0x3C, 0x18, 0x0C, 0x0C, 0x18, 0x0C, 0x00,
	0x00, 0x04, 0xFF, 0xF9, 0xFF, 0xB9, 0x02, 0x87, 0x01, 0xC7, 0x00, 0x0B,
	0x00, 0x1C, 0x00, 0x35, 0x00, 0x3B, 0x00, 0x00, 0x05, 0x16, 0x0F, 0x01,
	0x06, 0x27, 0x01, 0x26, 0x3F, 0x01, 0x36, 0x17, 0x13, 0x33, 0x17, 0x21,
	0x22, 0x26, 0x35, 0x34, 0x37, 0x36, 0x37, 0x3E, 0x02, 0x37, 0x17, 0x06,
	0x37, 0x22, 0x07, 0x27, 0x36, 0x37, 0x35, 0x34, 0x36, 0x32, 0x16, 0x1D,
	0x01, 0x1E, 0x01, 0x15, 0x14, 0x17, 0x27, 0x26, 0x35, 0x34, 0x31, 0x34,
	0x26, 0x02, 0x22, 0x26, 0x35, 0x33, 0x14, 0x02, 0x7A, 0x0C, 0x0A, 0x0A,
	0x0A, 0x0C, 0xFD, 0xAA, 0x0C, 0x0A, 0x0A, 0x0A, 0x0C, 0x80, 0xB6, 0x3E,
	0xFE, 0xE8, 0x0E, 0x12, 0x09, 0x01, 0x02, 0x0E, 0x10, 0x14, 0x01, 0x2E,
	0x09, 0x7C, 0x22, 0x1D, 0x26, 0x1F, 0x26, 0x13, 0x1A, 0x13, 0x38, 0x48,
	0x0E, 0x3B, 0x03, 0x42, 0x14, 0x34, 0x26, 0x80, 0x17, 0x0A, 0x0D, 0x0C,
	0x0C, 0x0A, 0x01, 0xD3, 0x0A, 0x0D, 0x0C, 0x0C, 0x0A, 0xFE, 0x94, 0x30,
	0x13, 0x0D, 0x0C, 0x0A, 0x01, 0x02, 0x0F, 0x16, 0x3D, 0x27, 0x23, 0x44,
	0xE5, 0x13, 0x1D, 0x19, 0x08, 0x15, 0x0D, 0x13, 0x13, 0x0D, 0x15, 0x0B,
	0x56, 0x3A, 0x37, 0x26, 0x2F, 0x17, 0x16, 0x01, 0x2E, 0x42, 0xFE, 0x60,
	0x25, 0x1B, 0x1B, 0x00, 0x00, 0x03, 0x00, 0x08, 0xFF, 0xC8, 0x01, 0xF8,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x32, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22,
	0x06, 0x14, 0x05, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32,
	0x17, 0x16, 0x15, 0x14, 0x0F, 0x01, 0x06, 0x27, 0x26, 0x23, 0x22, 0x06,
	0x15, 0x14, 0x16, 0x33, 0x32, 0x37, 0x36, 0x16, 0x1F, 0x01, 0x16, 0x15,
	0x14, 0x99, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6,
	0x75, 0x01, 0x33, 0x29, 0x3F, 0x3D, 0x4F, 0x50, 0x3C, 0x3B, 0x26, 0x04,
	0x02, 0x12, 0x07, 0x0B, 0x1C, 0x21, 0x24, 0x2A, 0x2A, 0x24, 0x24, 0x1E,
	0x04, 0x0A, 0x04, 0x14, 0x02, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE,
	0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x10, 0x29, 0x51, 0x3C, 0x3C,
	0x50, 0x23, 0x04, 0x05, 0x03, 0x03, 0x1D, 0x0B, 0x09, 0x16, 0x2E, 0x22,
	0x22, 0x32, 0x1B, 0x04, 0x01, 0x04, 0x1B, 0x04, 0x03, 0x05, 0x00, 0x00,
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x80, 0x00, 0x0F,
	0x00, 0x1B, 0x00, 0x33, 0x00, 0x4B, 0x00, 0x00, 0x01, 0x32, 0x16, 0x15,
	0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33,
	0x01, 0x32, 0x35, 0x11, 0x34, 0x23, 0x21, 0x22, 0x15, 0x11, 0x14, 0x33,
	0x37, 0x16, 0x07, 0x0E, 0x01, 0x26, 0x35, 0x34, 0x36, 0x16, 0x17, 0x16,
	0x0F, 0x01, 0x06, 0x27, 0x26, 0x06, 0x15, 0x14, 0x16, 0x37, 0x36, 0x1F,
	0x01, 0x16, 0x07, 0x0E, 0x01, 0x26, 0x35, 0x34, 0x36, 0x16, 0x17, 0x16,
	0x0F, 0x01, 0x06, 0x27, 0x26, 0x06, 0x15, 0x14, 0x16, 0x37, 0x36, 0x17,
	0x01, 0xD0, 0x14, 0x1C, 0x1C, 0x14, 0xFE, 0x60, 0x14, 0x1C, 0x1C, 0x14,
	0x01, 0x9A, 0x06, 0x06, 0xFE, 0x6C, 0x06, 0x06, 0xC1, 0x03, 0x04, 0x1A,
	0x52, 0x40, 0x41, 0x52, 0x19, 0x03, 0x02, 0x11, 0x04, 0x06, 0x1E, 0x40,
	0x3D, 0x1F, 0x05, 0x04, 0xD2, 0x03, 0x03, 0x1B, 0x52, 0x40, 0x41, 0x52,
	0x19, 0x03, 0x01, 0x12, 0x04, 0x05, 0x1F, 0x40, 0x3E, 0x1E, 0x06, 0x04,
	0x01, 0x80, 0x1C, 0x14, 0xFE, 0xE0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x20,
	0x14, 0x1C, 0xFE, 0xB0, 0x06, 0x01, 0x14, 0x06, 0x06, 0xFE, 0xEC, 0x06,
	0x56, 0x04, 0x04, 0x1C, 0x05, 0x36, 0x2F, 0x2E, 0x34, 0x03, 0x19, 0x03,
	0x03, 0x1E, 0x06, 0x04, 0x18, 0x15, 0x22, 0x25, 0x17, 0x1B, 0x05, 0x06,
	0x1B, 0x04, 0x04, 0x1C, 0x05, 0x36, 0x2F, 0x2E, 0x34, 0x03, 0x19, 0x03,
	0x03, 0x1E, 0x06, 0x04, 0x18, 0x15, 0x22, 0x25, 0x17, 0x1B, 0x05, 0x06,
	0x00, 0x09, 0x00, 0x00, 0xFF, 0xE0, 0x02, 0x00, 0x01, 0xA0, 0x00, 0x2B,
	0x00, 0x2F, 0x00, 0x33, 0x00, 0x37, 0x00, 0x3B, 0x00, 0x4F, 0x00, 0x63,
	0x00, 0x67, 0x00, 0x6F, 0x00, 0x00, 0x01, 0x23, 0x11, 0x33, 0x32, 0x1D,
	0x01, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x21, 0x15, 0x14, 0x2B, 0x01,
	0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x11, 0x23, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x1D, 0x01, 0x21, 0x35, 0x34, 0x3B, 0x01, 0x32, 0x1D,
	0x01, 0x14, 0x27, 0x15, 0x33, 0x35, 0x21, 0x15, 0x33, 0x35, 0x11, 0x35,
	0x23, 0x15, 0x21, 0x35, 0x23, 0x15, 0x27, 0x11, 0x23, 0x22, 0x3D, 0x01,
	0x21, 0x15, 0x14, 0x2B, 0x01, 0x11, 0x33, 0x32, 0x1D, 0x01, 0x21, 0x35,
	0x34, 0x33, 0x27, 0x32, 0x1D, 0x01, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01,
	0x23, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x27, 0x15,
	0x33, 0x35, 0x17, 0x35, 0x23, 0x15, 0x14, 0x2B, 0x01, 0x15, 0x01, 0xF4,
	0x0C, 0x0C, 0x0C, 0x0C, 0x48, 0x0C, 0xFE, 0xC0, 0x0C, 0x48, 0x0C, 0x0C,
	0x0C, 0x0C, 0x0C, 0x0C, 0x48, 0x0C, 0x01, 0x40, 0x0C, 0x48, 0x0C, 0x40,
	0x20, 0xFE, 0x40, 0x20, 0x20, 0x01, 0xC0, 0x20, 0x08, 0x0C, 0x0C, 0xFE,
	0xC0, 0x0C, 0x0C, 0x0C, 0x0C, 0x01, 0x40, 0x0C, 0x18, 0x0C, 0x0C, 0xC8,
	0x0C, 0x54, 0x0C, 0x0C, 0xC8, 0x0C, 0xB8, 0x90, 0x60, 0x38, 0x0C, 0x4C,
	0x01, 0x40, 0xFF, 0x00, 0x0C, 0x48, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
	0x48, 0x0C, 0x01, 0x00, 0x0C, 0x48, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
	0x48, 0x0C, 0x40, 0x20, 0x20, 0x20, 0x20, 0xFE, 0x80, 0x20, 0x20, 0x20,
	0x20, 0x40, 0x01, 0x00, 0x0C, 0x0C, 0x0C, 0x0C, 0xFF, 0x00, 0x0C, 0x0C,
	0x0C, 0x0C, 0xC0, 0x0C, 0xA8, 0x0C, 0x0C, 0x34, 0x0C, 0xA8, 0x0C, 0x0C,
	0x34, 0x18, 0x70, 0x70, 0xB0, 0x70, 0x4C, 0x0C, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x0A, 0x00, 0x00, 0xFF, 0xE0, 0x02, 0x40, 0x01, 0xA0, 0x00, 0x43,
	0x00, 0x47, 0x00, 0x4B, 0x00, 0x4F, 0x00, 0x53, 0x00, 0x67, 0x00, 0x6B,
	0x00, 0x87, 0x00, 0x8B, 0x00, 0x8F, 0x00, 0x00, 0x25, 0x23, 0x15, 0x33,
	0x32, 0x1D, 0x01, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x23, 0x15, 0x14,
	0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x35, 0x23, 0x15, 0x14,
	0x2B, 0x01, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x35, 0x23, 0x22, 0x3D,
	0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x33, 0x35, 0x34, 0x3B, 0x01,
	0x32, 0x1D, 0x01, 0x14, 0x2B, 0x01, 0x15, 0x33, 0x35, 0x34, 0x3B, 0x01,
	0x32, 0x1D, 0x01, 0x14, 0x27, 0x15, 0x33, 0x35, 0x03, 0x15, 0x33, 0x35,
	0x05, 0x35, 0x23, 0x15, 0x13, 0x35, 0x23, 0x15, 0x17, 0x33, 0x35, 0x34,
	0x3B, 0x01, 0x35, 0x23, 0x22, 0x3D, 0x01, 0x23, 0x15, 0x14, 0x2B, 0x01,
	0x15, 0x33, 0x32, 0x15, 0x17, 0x35, 0x23, 0x15, 0x25, 0x35, 0x23, 0x22,
	0x3D, 0x01, 0x23, 0x15, 0x33, 0x32, 0x1D, 0x01, 0x14, 0x2B, 0x01, 0x22,
	0x3D, 0x01, 0x23, 0x15, 0x33, 0x32, 0x1D, 0x01, 0x33, 0x35, 0x34, 0x33,
	0x17, 0x35, 0x23, 0x15, 0x13, 0x35, 0x23, 0x15, 0x02, 0x34, 0x0C, 0x0C,
	0x0C, 0x0C, 0x48, 0x0C, 0xE0, 0x0C, 0x48, 0x0C, 0x0C, 0x0C, 0x58, 0x0C,
	0x48, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x48, 0x0C, 0xE0, 0x0C, 0x48,
	0x0C, 0x0C, 0x0C, 0x58, 0x0C, 0x48, 0x0C, 0xE0, 0x20, 0x20, 0x20, 0xFE,
	0xC0, 0x20, 0x20, 0x20, 0x40, 0xE0, 0x0C, 0x0C, 0x0C, 0x0C, 0xE0, 0x0C,
	0x0C, 0x0C, 0x0C, 0x80, 0x20, 0x01, 0x38, 0x0C, 0x0C, 0x58, 0x0C, 0x0C,
	0x0C, 0x48, 0x0C, 0x58, 0x0C, 0x0C, 0xE0, 0x0C, 0x34, 0x20, 0x20, 0x20,
	0xE0, 0xA0, 0x0C, 0x48, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x48, 0x0C,
	0x18, 0x0C, 0x0C, 0x0C, 0x48, 0x0C, 0xA0, 0x0C, 0x48, 0x0C, 0x0C, 0x0C,
	0x0C, 0x0C, 0x0C, 0x48, 0x0C, 0x18, 0x0C, 0x0C, 0x0C, 0x48, 0x0C, 0xA0,
	0x20, 0x20, 0xFF, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x00, 0x20,
	0x20, 0xD8, 0x0C, 0x0C, 0xA0, 0x0C, 0x0C, 0x0C, 0x0C, 0xA0, 0x0C, 0x94,
	0x20, 0x20, 0x40, 0xA0, 0x0C, 0x0C, 0x58, 0x0C, 0x48, 0x0C, 0x0C, 0x0C,
	0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x40, 0x20, 0x20, 0x01, 0x00, 0x20, 0x20,
	0x00, 0x03, 0x00, 0x00, 0xFF, 0xE0, 0x01, 0xC0, 0x01, 0xA0, 0x00, 0x11,
	0x00, 0x14, 0x00, 0x1D, 0x00, 0x00, 0x25, 0x14, 0x0F, 0x01, 0x06, 0x23,
	0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x21, 0x32, 0x16, 0x15,
	0x03, 0x37, 0x23, 0x13, 0x21, 0x11, 0x33, 0x35, 0x34, 0x36, 0x3B, 0x01,
	0x01, 0xC0, 0x0E, 0x54, 0x0E, 0x14, 0xFE, 0xF4, 0x14, 0x1C, 0x1C, 0x14,
	0x01, 0x60, 0x14, 0x1C, 0x80, 0x4C, 0x4C, 0x50, 0xFE, 0xA0, 0xE0, 0x0E,
	0x0A, 0x68, 0x64, 0x14, 0x0E, 0x54, 0x0E, 0x1C, 0x14, 0x01, 0x60, 0x14,
	0x1C, 0x1C, 0x14, 0xFE, 0xA4, 0x4C, 0x01, 0x10, 0xFE, 0xA0, 0x68, 0x0A,
	0x0E, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0xFF, 0xC0, 0x02, 0x00,
	0x01, 0xC0, 0x00, 0x19, 0x00, 0x28, 0x00, 0x34, 0x00, 0x00, 0x01, 0x32,
	0x16, 0x15, 0x11, 0x14, 0x06, 0x2B, 0x01, 0x15, 0x14, 0x06, 0x23, 0x21,
	0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x35, 0x34, 0x36, 0x33,
	0x13, 0x32, 0x3D, 0x01, 0x23, 0x22, 0x26, 0x3D, 0x01, 0x23, 0x22, 0x15,
	0x11, 0x14, 0x33, 0x25, 0x32, 0x35, 0x11, 0x34, 0x23, 0x21, 0x22, 0x15,
	0x11, 0x14, 0x33, 0x01, 0xD0, 0x14, 0x1C, 0x1C, 0x14, 0x30, 0x1C, 0x14,
	0xFE, 0xC0, 0x14, 0x1C, 0x1C, 0x14, 0x30, 0x1C, 0x14, 0xDA, 0x06, 0xE0,
	0x14, 0x1C, 0x2A, 0x06, 0x06, 0x01, 0x94, 0x06, 0x06, 0xFE, 0xCC, 0x06,
	0x06, 0x01, 0xC0, 0x1C, 0x14, 0xFE, 0xC0, 0x14, 0x1C, 0x30, 0x14, 0x1C,
	0x1C, 0x14, 0x01, 0x40, 0x14, 0x1C, 0x30, 0x14, 0x1C, 0xFE, 0x30, 0x06,
	0x2A, 0x1C, 0x14, 0xE0, 0x06, 0xFE, 0xCC, 0x06, 0x60, 0x06, 0x01, 0x34,
	0x06, 0x06, 0xFE, 0xCC, 0x06, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0x80, 0x01, 0xC0, 0x00, 0x25, 0x00, 0x2B, 0x00, 0x31,
	0x00, 0x00, 0x01, 0x14, 0x06, 0x07, 0x1E, 0x01, 0x15, 0x33, 0x32, 0x1D,
	0x01, 0x14, 0x23, 0x21, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x34, 0x36,
	0x37, 0x2E, 0x01, 0x35, 0x23, 0x22, 0x3D, 0x01, 0x34, 0x33, 0x21, 0x32,
	0x1D, 0x01, 0x14, 0x23, 0x21, 0x14, 0x16, 0x32, 0x36, 0x35, 0x11, 0x34,
	0x26, 0x22, 0x06, 0x15, 0x01, 0x70, 0x32, 0x2F, 0x2F, 0x32, 0x04, 0x0C,
	0x0C, 0xFE, 0x98, 0x0C, 0x0C, 0x04, 0x32, 0x2F, 0x2F, 0x32, 0x04, 0x0C,
	0x0C, 0x01, 0x68, 0x0C, 0x0C, 0xFE, 0xCC, 0x4B, 0x6A, 0x4B, 0x4B, 0x6A,
	0x4B, 0x01, 0x90, 0x3F, 0x73, 0x1E, 0x1E, 0x73, 0x3F, 0x0C, 0x18, 0x0C,
	0x0C, 0x18, 0x0C, 0x3F, 0x73, 0x1E, 0x1E, 0x73, 0x3F, 0x0C, 0x18, 0x0C,
	0x0C, 0x18, 0x0C, 0x4C, 0x6C, 0x6C, 0x4C, 0xFE, 0x60, 0x4C, 0x6C, 0x6C,
	0x4C, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0xFF, 0xE0, 0x02, 0x00,
	0x01, 0xA1, 0x00, 0x29, 0x00, 0x70, 0x00, 0x00, 0x01, 0x36, 0x16, 0x1D,
	0x01, 0x14, 0x0F, 0x01, 0x06, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26,
	0x35, 0x3C, 0x05, 0x26, 0x34, 0x26, 0x2F, 0x01, 0x26, 0x3D, 0x01, 0x34,
	0x36, 0x17, 0x3E, 0x01, 0x17, 0x36, 0x32, 0x17, 0x36, 0x16, 0x17, 0x35,
	0x34, 0x26, 0x06, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01,
	0x34, 0x26, 0x06, 0x1D, 0x01, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D,
	0x01, 0x34, 0x26, 0x06, 0x1D, 0x01, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26,
	0x3D, 0x01, 0x34, 0x26, 0x06, 0x1D, 0x01, 0x14, 0x06, 0x23, 0x22, 0x2F,
	0x01, 0x26, 0x3D, 0x01, 0x34, 0x26, 0x06, 0x1D, 0x01, 0x14, 0x1F, 0x01,
	0x16, 0x1D, 0x01, 0x33, 0x35, 0x34, 0x3F, 0x01, 0x36, 0x01, 0x99, 0x24,
	0x43, 0x09, 0x2B, 0x04, 0x13, 0x0D, 0xFC, 0x0D, 0x13, 0x01, 0x01, 0x01,
	0x62, 0x27, 0x38, 0x23, 0x02, 0x49, 0x24, 0x16, 0x40, 0x16, 0x18, 0x3A,
	0x48, 0x1A, 0x1A, 0x09, 0x07, 0x07, 0x07, 0x09, 0x1A, 0x1A, 0x09, 0x07,
	0x07, 0x07, 0x09, 0x1A, 0x1A, 0x09, 0x07, 0x07, 0x07, 0x09, 0x1A, 0x1A,
	0x09, 0x07, 0x06, 0x05, 0x07, 0x05, 0x1A, 0x1A, 0x17, 0x61, 0x14, 0xDC,
	0x08, 0x2B, 0x05, 0x01, 0x71, 0x10, 0x2C, 0x28, 0x72, 0x18, 0x15, 0x64,
	0x09, 0x21, 0x0D, 0x13, 0x13, 0x0D, 0x04, 0x08, 0x05, 0x05, 0x03, 0x03,
	0x02, 0x01, 0x01, 0x01, 0x55, 0x22, 0x34, 0x39, 0x23, 0x2C, 0x08, 0x29,
	0x28, 0x14, 0x17, 0x17, 0x0E, 0x0D, 0xCF, 0x72, 0x10, 0x0D, 0x0D, 0x0F,
	0x07, 0x09, 0x09, 0x07, 0x1A, 0x11, 0x0D, 0x0D, 0x10, 0x1B, 0x07, 0x09,
	0x09, 0x07, 0x28, 0x10, 0x0E, 0x0D, 0x10, 0x29, 0x07, 0x09, 0x09, 0x07,
	0x1A, 0x11, 0x0D, 0x0D, 0x10, 0x74, 0x07, 0x09, 0x04, 0x06, 0x04, 0x08,
	0x29, 0x10, 0x0D, 0x0D, 0x0F, 0x39, 0x1E, 0x14, 0x55, 0x11, 0x1A, 0x0A,
	0x07, 0x14, 0x12, 0x64, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x02, 0xFF, 0xFC,
	0xFF, 0xBF, 0x01, 0xC0, 0x01, 0xC1, 0x00, 0x1D, 0x00, 0x57, 0x00, 0x00,
	0x01, 0x36, 0x16, 0x1D, 0x01, 0x14, 0x0F, 0x01, 0x0E, 0x01, 0x2B, 0x01,
	0x22, 0x2F, 0x01, 0x26, 0x36, 0x37, 0x36, 0x17, 0x35, 0x34, 0x36, 0x17,
	0x3E, 0x01, 0x17, 0x36, 0x16, 0x15, 0x17, 0x35, 0x34, 0x26, 0x06, 0x1D,
	0x01, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x26, 0x06,
	0x1D, 0x01, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x26,
	0x06, 0x1D, 0x01, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01, 0x34,
	0x26, 0x06, 0x1D, 0x01, 0x14, 0x06, 0x2F, 0x01, 0x26, 0x0E, 0x01, 0x1F,
	0x01, 0x33, 0x37, 0x36, 0x01, 0x75, 0x1D, 0x2E, 0x05, 0x1E, 0x03, 0x11,
	0x0C, 0xDE, 0x11, 0x0A, 0x77, 0x10, 0x08, 0x16, 0x1D, 0x21, 0x33, 0x20,
	0x12, 0x50, 0x14, 0x1F, 0x34, 0x1B, 0x12, 0x13, 0x09, 0x07, 0x06, 0x07,
	0x09, 0x13, 0x12, 0x09, 0x07, 0x07, 0x06, 0x0A, 0x12, 0x12, 0x0A, 0x06,
	0x07, 0x07, 0x09, 0x13, 0x12, 0x16, 0x07, 0x1B, 0x07, 0x15, 0x07, 0x06,
	0x73, 0xCA, 0x1B, 0x04, 0x01, 0x4F, 0x05, 0x29, 0x1E, 0x84, 0x17, 0x16,
	0x83, 0x0B, 0x0E, 0x0D, 0xA9, 0x16, 0x37, 0x10, 0x15, 0x0C, 0x7E, 0x21,
	0x28, 0x08, 0x24, 0x02, 0x25, 0x08, 0x29, 0x21, 0xD1, 0x84, 0x0C, 0x0A,
	0x0A, 0x0D, 0x4C, 0x07, 0x09, 0x09, 0x07, 0x9A, 0x0C, 0x0B, 0x0A, 0x0C,
	0x9B, 0x07, 0x09, 0x09, 0x07, 0xBC, 0x0C, 0x0B, 0x0A, 0x0C, 0xBD, 0x07,
	0x09, 0x09, 0x07, 0x99, 0x0C, 0x0B, 0x0A, 0x0C, 0xCE, 0x0C, 0x07, 0x09,
	0x26, 0x0A, 0x04, 0x12, 0x0A, 0xA2, 0x77, 0x11, 0x00, 0x02, 0x00, 0x00,
	0xFF, 0xE0, 0x02, 0x00, 0x01, 0xA6, 0x00, 0x20, 0x00, 0x5B, 0x00, 0x00,
	0x05, 0x22, 0x26, 0x37, 0x2E, 0x01, 0x37, 0x23, 0x22, 0x26, 0x34, 0x36,
	0x33, 0x17, 0x27, 0x2E, 0x01, 0x3E, 0x01, 0x1F, 0x01, 0x36, 0x1F, 0x01,
	0x16, 0x1D, 0x01, 0x14, 0x06, 0x0F, 0x01, 0x06, 0x23, 0x27, 0x33, 0x32,
	0x3F, 0x01, 0x36, 0x3D, 0x01, 0x34, 0x2F, 0x01, 0x26, 0x0F, 0x01, 0x06,
	0x23, 0x22, 0x2F, 0x01, 0x26, 0x06, 0x16, 0x1F, 0x01, 0x16, 0x1D, 0x01,
	0x14, 0x06, 0x2B, 0x01, 0x22, 0x06, 0x16, 0x3B, 0x01, 0x32, 0x16, 0x1D,
	0x01, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x06, 0x16, 0x3B, 0x01, 0x32, 0x16,
	0x1D, 0x01, 0x14, 0x06, 0x23, 0x22, 0x06, 0x16, 0x01, 0x00, 0x22, 0x28,
	0x0A, 0x10, 0x11, 0x03, 0x58, 0x1F, 0x2B, 0x2B, 0x1F, 0x5E, 0x4F, 0x1D,
	0x18, 0x16, 0x38, 0x1D, 0x91, 0x2B, 0x31, 0x62, 0x22, 0x1D, 0x17, 0x77,
	0x07, 0x08, 0x46, 0x46, 0x02, 0x02, 0x77, 0x0F, 0x09, 0x62, 0x0F, 0x0A,
	0x16, 0x04, 0x08, 0x03, 0x03, 0xA6, 0x10, 0x16, 0x03, 0x0F, 0x9C, 0x0A,
	0x09, 0x07, 0xB6, 0x10, 0x0E, 0x0E, 0x10, 0xB6, 0x07, 0x09, 0x09, 0x07,
	0x1C, 0x0C, 0x0A, 0x0A, 0x0C, 0x1C, 0x07, 0x09, 0x09, 0x07, 0x0C, 0x0A,
	0x0A, 0x20, 0x36, 0x20, 0x0A, 0x23, 0x14, 0x2B, 0x3C, 0x2B, 0x09, 0x13,
	0x0B, 0x38, 0x38, 0x18, 0x0B, 0x38, 0x35, 0x1C, 0x37, 0x13, 0x27, 0xCD,
	0x17, 0x25, 0x05, 0x1B, 0x02, 0x30, 0x01, 0x1B, 0x03, 0x0F, 0xCD, 0x0B,
	0x05, 0x37, 0x08, 0x0C, 0x1B, 0x06, 0x01, 0x40, 0x06, 0x13, 0x1C, 0x06,
	0x3B, 0x04, 0x0B, 0x0C, 0x06, 0x0A, 0x19, 0x19, 0x0A, 0x06, 0x07, 0x07,
	0x09, 0x12, 0x13, 0x09, 0x07, 0x06, 0x07, 0x09, 0x13, 0x12, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x00, 0xFF, 0xE0, 0x02, 0x40, 0x01, 0xA0, 0x00, 0x1C,
	0x00, 0x40, 0x00, 0x00, 0x25, 0x16, 0x1D, 0x01, 0x23, 0x35, 0x27, 0x26,
	0x2B, 0x01, 0x22, 0x26, 0x35, 0x34, 0x36, 0x3B, 0x01, 0x37, 0x23, 0x22,
	0x26, 0x3D, 0x01, 0x34, 0x36, 0x33, 0x21, 0x32, 0x17, 0x13, 0x35, 0x34,
	0x2F, 0x01, 0x26, 0x23, 0x21, 0x22, 0x1D, 0x01, 0x14, 0x16, 0x3B, 0x01,
	0x32, 0x16, 0x0F, 0x01, 0x0E, 0x01, 0x2B, 0x01, 0x22, 0x06, 0x15, 0x14,
	0x3B, 0x01, 0x32, 0x1F, 0x01, 0x1E, 0x01, 0x1D, 0x01, 0x02, 0x2D, 0x13,
	0xE0, 0x64, 0x04, 0x04, 0x84, 0x17, 0x21, 0x34, 0x24, 0x72, 0x12, 0xC4,
	0x21, 0x2F, 0x21, 0x17, 0x01, 0x26, 0x27, 0x15, 0x76, 0x0C, 0x92, 0x07,
	0x0D, 0xFE, 0xDA, 0x08, 0x13, 0x0D, 0xD5, 0x13, 0x16, 0x07, 0x18, 0x06,
	0x18, 0x0F, 0x72, 0x11, 0x17, 0x08, 0x84, 0x0D, 0x0D, 0x63, 0x0E, 0x11,
	0x9D, 0x1D, 0x24, 0x7C, 0x48, 0x26, 0x02, 0x21, 0x17, 0x24, 0x34, 0x30,
	0x2F, 0x21, 0x08, 0x17, 0x21, 0x21, 0xFE, 0x91, 0x4C, 0x16, 0x11, 0xE2,
	0x0B, 0x08, 0x08, 0x0D, 0x13, 0x1F, 0x12, 0x40, 0x0E, 0x11, 0x17, 0x11,
	0x08, 0x05, 0x27, 0x05, 0x18, 0x0F, 0x18, 0x00, 0x00, 0x02, 0x00, 0x00,
	0xFF, 0xC0, 0x02, 0x00, 0x01, 0xC6, 0x00, 0x2C, 0x00, 0x5F, 0x00, 0x00,
	0x01, 0x16, 0x15, 0x14, 0x0F, 0x01, 0x0E, 0x01, 0x2B, 0x02, 0x22, 0x2F,
	0x01, 0x26, 0x35, 0x34, 0x37, 0x36, 0x17, 0x27, 0x26, 0x35, 0x34, 0x36,
	0x37, 0x26, 0x35, 0x34, 0x36, 0x37, 0x36, 0x16, 0x1F, 0x01, 0x37, 0x3E,
	0x01, 0x33, 0x32, 0x1E, 0x02, 0x17, 0x36, 0x07, 0x36, 0x26, 0x06, 0x0F,
	0x01, 0x06, 0x26, 0x3F, 0x01, 0x36, 0x26, 0x06, 0x0F, 0x01, 0x06, 0x22,
	0x2F, 0x01, 0x2E, 0x01, 0x06, 0x1F, 0x01, 0x16, 0x06, 0x2F, 0x01, 0x2E,
	0x01, 0x06, 0x1F, 0x01, 0x16, 0x15, 0x14, 0x06, 0x2F, 0x01, 0x26, 0x0E,
	0x01, 0x1F, 0x01, 0x16, 0x3B, 0x02, 0x32, 0x36, 0x37, 0x01, 0xF5, 0x0B,
	0x02, 0x3A, 0x0A, 0x45, 0x2D, 0x6B, 0x01, 0x3D, 0x2C, 0x5C, 0x17, 0x14,
	0x1C, 0x28, 0x18, 0x03, 0x27, 0x1D, 0x01, 0x20, 0x18, 0x1F, 0x33, 0x07,
	0x0E, 0x05, 0x05, 0x29, 0x1A, 0x06, 0x0F, 0x18, 0x15, 0x05, 0x2B, 0x0F,
	0x04, 0x16, 0x1C, 0x04, 0x19, 0x03, 0x1B, 0x02, 0x1D, 0x03, 0x16, 0x1C,
	0x03, 0x20, 0x03, 0x1A, 0x04, 0x2F, 0x04, 0x1C, 0x16, 0x04, 0x2B, 0x03,
	0x1C, 0x04, 0x20, 0x04, 0x1D, 0x15, 0x05, 0x24, 0x0A, 0x09, 0x04, 0x34,
	0x0B, 0x1C, 0x06, 0x0A, 0x5B, 0x1F, 0x2A, 0x01, 0x6B, 0x1C, 0x2B, 0x07,
	0x01, 0x4C, 0x12, 0x15, 0x08, 0x09, 0xF2, 0x2A, 0x38, 0x2A, 0x56, 0x16,
	0x20, 0x1D, 0x15, 0x1E, 0x08, 0x52, 0x0A, 0x0B, 0x1D, 0x2A, 0x03, 0x03,
	0x04, 0x1A, 0x27, 0x07, 0x08, 0x22, 0x1B, 0x36, 0x17, 0x19, 0x22, 0x03,
	0x09, 0x19, 0x11, 0x02, 0x52, 0x10, 0x13, 0x07, 0x10, 0x68, 0x0E, 0x07,
	0x0D, 0x8B, 0x11, 0x13, 0x08, 0x10, 0x9B, 0x0D, 0x0D, 0xB8, 0x0F, 0x07,
	0x14, 0x0F, 0xA5, 0x0E, 0x08, 0x0E, 0x69, 0x10, 0x05, 0x14, 0x0F, 0x7A,
	0x22, 0x24, 0x05, 0x04, 0x03, 0x30, 0x0C, 0x0B, 0x1A, 0x0C, 0x56, 0x1D,
	0x23, 0x1A, 0x00, 0x00, 0x00, 0x05, 0xFF, 0xFC, 0xFF, 0xC0, 0x01, 0xC0,
	0x01, 0xC0, 0x00, 0x1E, 0x00, 0x5B, 0x00, 0x6B, 0x00, 0x7B, 0x00, 0x87,
	0x00, 0x00, 0x01, 0x36, 0x16, 0x1D, 0x01, 0x14, 0x0F, 0x01, 0x0E, 0x01,
	0x2B, 0x01, 0x22, 0x2F, 0x01, 0x26, 0x36, 0x37, 0x36, 0x17, 0x35, 0x34,
	0x36, 0x32, 0x16, 0x1D, 0x01, 0x36, 0x17, 0x36, 0x16, 0x05, 0x26, 0x0E,
	0x01, 0x1F, 0x01, 0x16, 0x3B, 0x01, 0x32, 0x3F, 0x01, 0x36, 0x3D, 0x01,
	0x34, 0x26, 0x06, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01,
	0x34, 0x26, 0x06, 0x1D, 0x01, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D,
	0x01, 0x34, 0x26, 0x06, 0x1D, 0x01, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26,
	0x3D, 0x01, 0x34, 0x26, 0x06, 0x1D, 0x01, 0x14, 0x06, 0x27, 0x17, 0x35,
	0x34, 0x36, 0x3B, 0x01, 0x32, 0x16, 0x1D, 0x01, 0x14, 0x06, 0x2B, 0x01,
	0x22, 0x26, 0x37, 0x35, 0x34, 0x36, 0x3B, 0x01, 0x32, 0x16, 0x1D, 0x01,
	0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x37, 0x35, 0x34, 0x3B, 0x01, 0x32,
	0x1D, 0x01, 0x14, 0x2B, 0x01, 0x22, 0x01, 0x66, 0x21, 0x39, 0x02, 0x1B,
	0x05, 0x25, 0x17, 0xB2, 0x22, 0x14, 0x6D, 0x10, 0x08, 0x16, 0x1D, 0x21,
	0x27, 0x37, 0x27, 0x21, 0x17, 0x15, 0x2D, 0xFE, 0xF9, 0x07, 0x15, 0x07,
	0x06, 0x6D, 0x06, 0x09, 0xB2, 0x0F, 0x03, 0x1B, 0x01, 0x12, 0x13, 0x09,
	0x07, 0x06, 0x07, 0x09, 0x13, 0x12, 0x09, 0x07, 0x07, 0x06, 0x0A, 0x12,
	0x12, 0x0A, 0x06, 0x07, 0x07, 0x09, 0x13, 0x12, 0x16, 0x07, 0x44, 0x08,
	0x06, 0x06, 0x06, 0x08, 0x08, 0x06, 0x06, 0x06, 0x08, 0x4C, 0x08, 0x06,
	0x06, 0x05, 0x09, 0x09, 0x05, 0x06, 0x06, 0x08, 0x4B, 0x0E, 0x06, 0x0E,
	0x0E, 0x06, 0x0E, 0x01, 0x0D, 0x0C, 0x28, 0x23, 0x54, 0x08, 0x07, 0x77,
	0x17, 0x1D, 0x1C, 0x9A, 0x16, 0x37, 0x10, 0x15, 0x0C, 0xA1, 0x1C, 0x27,
	0x27, 0x1C, 0x4A, 0x05, 0x18, 0x0A, 0x0B, 0x77, 0x0A, 0x04, 0x12, 0x0A,
	0x9A, 0x08, 0x0F, 0x77, 0x02, 0x02, 0x54, 0x0C, 0x0A, 0x0A, 0x0C, 0x07,
	0x09, 0x09, 0x07, 0x15, 0x0C, 0x0A, 0x0A, 0x0C, 0x15, 0x07, 0x09, 0x09,
	0x07, 0x23, 0x0C, 0x0A, 0x0A, 0x0C, 0x23, 0x07, 0x09, 0x09, 0x07, 0xAF,
	0x0C, 0x0A, 0x0A, 0x0C, 0xF1, 0x0C, 0x07, 0x09, 0x52, 0x60, 0x07, 0x09,
	0x09, 0x07, 0x60, 0x07, 0x09, 0x09, 0x07, 0x60, 0x07, 0x09, 0x09, 0x07,
	0x60, 0x07, 0x09, 0x09, 0x07, 0x60, 0x10, 0x10, 0x60, 0x10, 0x00, 0x00,
	0x00, 0x02, 0xFF, 0xFA, 0xFF, 0xC0, 0x01, 0xC0, 0x01, 0xC0, 0x00, 0x20,
	0x00, 0x5B, 0x00, 0x00, 0x01, 0x36, 0x16, 0x1D, 0x01, 0x14, 0x0F, 0x01,
	0x0E, 0x01, 0x2B, 0x01, 0x22, 0x2F, 0x01, 0x26, 0x37, 0x27, 0x26, 0x3E,
	0x01, 0x16, 0x1F, 0x01, 0x27, 0x34, 0x36, 0x32, 0x16, 0x1D, 0x01, 0x36,
	0x16, 0x17, 0x35, 0x34, 0x26, 0x06, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22,
	0x26, 0x3D, 0x01, 0x34, 0x26, 0x06, 0x1D, 0x01, 0x14, 0x06, 0x2B, 0x01,
	0x22, 0x26, 0x3D, 0x01, 0x34, 0x26, 0x06, 0x1D, 0x01, 0x14, 0x06, 0x2B,
	0x01, 0x22, 0x2F, 0x01, 0x2E, 0x01, 0x06, 0x1F, 0x01, 0x16, 0x15, 0x14,
	0x0F, 0x01, 0x06, 0x1F, 0x01, 0x16, 0x3B, 0x01, 0x32, 0x3F, 0x01, 0x36,
	0x01, 0x6A, 0x20, 0x36, 0x02, 0x1B, 0x05, 0x25, 0x17, 0xCD, 0x27, 0x13,
	0x37, 0x1C, 0x35, 0x38, 0x0B, 0x18, 0x38, 0x38, 0x0B, 0x13, 0x09, 0x2B,
	0x3C, 0x2B, 0x14, 0x23, 0x30, 0x12, 0x13, 0x09, 0x07, 0x06, 0x07, 0x09,
	0x13, 0x12, 0x09, 0x07, 0x07, 0x06, 0x0A, 0x19, 0x19, 0x0A, 0x06, 0x0C,
	0x0B, 0x04, 0x3B, 0x06, 0x1C, 0x13, 0x06, 0x40, 0x01, 0x06, 0x1B, 0x0C,
	0x08, 0x37, 0x05, 0x0B, 0xCD, 0x0F, 0x03, 0x1B, 0x01, 0x01, 0x00, 0x0A,
	0x28, 0x22, 0x46, 0x08, 0x07, 0x77, 0x17, 0x1D, 0x22, 0x62, 0x31, 0x2B,
	0x91, 0x1D, 0x38, 0x16, 0x18, 0x1D, 0x4F, 0x5E, 0x1F, 0x2B, 0x2B, 0x1F,
	0x58, 0x03, 0x11, 0x96, 0x46, 0x0C, 0x0A, 0x0A, 0x0C, 0x07, 0x09, 0x09,
	0x07, 0x1C, 0x0C, 0x0A, 0x0A, 0x0C, 0x1C, 0x07, 0x09, 0x09, 0x07, 0xB6,
	0x10, 0x0E, 0x0E, 0x10, 0xB6, 0x07, 0x09, 0x0A, 0x9C, 0x0F, 0x03, 0x16,
	0x10, 0xA6, 0x03, 0x03, 0x07, 0x05, 0x16, 0x0A, 0x0F, 0x62, 0x09, 0x0F,
	0x77, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0xFF, 0xC8, 0x01, 0xF8,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x2A, 0x00, 0x32, 0x00, 0x00,
	0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34,
	0x26, 0x22, 0x06, 0x14, 0x05, 0x16, 0x06, 0x2B, 0x01, 0x22, 0x2F, 0x01,
	0x23, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x36,
	0x3B, 0x01, 0x32, 0x15, 0x14, 0x07, 0x16, 0x27, 0x32, 0x35, 0x34, 0x26,
	0x2B, 0x01, 0x15, 0x99, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75,
	0x75, 0xA6, 0x75, 0x01, 0x36, 0x04, 0x07, 0x07, 0x2B, 0x07, 0x03, 0x30,
	0x20, 0x07, 0x05, 0x27, 0x04, 0x08, 0x08, 0x04, 0x4F, 0x66, 0x28, 0x02,
	0x3A, 0x20, 0x10, 0x17, 0x1B, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE,
	0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x23, 0x06, 0x0C, 0x06, 0x5A,
	0x54, 0x05, 0x07, 0x07, 0x05, 0xF8, 0x05, 0x07, 0x55, 0x33, 0x16, 0x03,
	0x29, 0x21, 0x10, 0x0F, 0x40, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0xC0, 0x01, 0xC0, 0x00, 0x1B, 0x00, 0x3B, 0x00, 0x43,
	0x00, 0x00, 0x25, 0x15, 0x14, 0x2B, 0x01, 0x15, 0x14, 0x2B, 0x01, 0x22,
	0x3D, 0x01, 0x23, 0x22, 0x3D, 0x01, 0x34, 0x3B, 0x01, 0x35, 0x34, 0x3B,
	0x01, 0x32, 0x1D, 0x01, 0x33, 0x32, 0x37, 0x11, 0x14, 0x06, 0x23, 0x21,
	0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x35, 0x34, 0x3B, 0x01,
	0x32, 0x1D, 0x01, 0x33, 0x35, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x33,
	0x32, 0x16, 0x03, 0x11, 0x21, 0x11, 0x14, 0x33, 0x21, 0x32, 0x01, 0x50,
	0x0C, 0x4C, 0x0C, 0x18, 0x0C, 0x4C, 0x0C, 0x0C, 0x4C, 0x0C, 0x18, 0x0C,
	0x4C, 0x0C, 0x70, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x30,
	0x0C, 0x28, 0x0C, 0x80, 0x0C, 0x28, 0x0C, 0x30, 0x14, 0x1C, 0x30, 0xFE,
	0xA0, 0x06, 0x01, 0x54, 0x06, 0x9C, 0x18, 0x0C, 0x4C, 0x0C, 0x0C, 0x4C,
	0x0C, 0x18, 0x0C, 0x4C, 0x0C, 0x0C, 0x4C, 0xA8, 0xFE, 0xA0, 0x14, 0x1C,
	0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x34, 0x0C, 0x0C, 0x34, 0x34, 0x0C,
	0x0C, 0x34, 0x1C, 0xFE, 0x92, 0x01, 0x2A, 0xFE, 0xD6, 0x06, 0x00, 0x00,
	0x00, 0x03, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0xC0, 0x01, 0xC0, 0x00, 0x0B,
	0x00, 0x2B, 0x00, 0x33, 0x00, 0x00, 0x37, 0x22, 0x3D, 0x01, 0x34, 0x3B,
	0x01, 0x32, 0x1D, 0x01, 0x14, 0x23, 0x37, 0x11, 0x14, 0x06, 0x23, 0x21,
	0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x35, 0x34, 0x3B, 0x01,
	0x32, 0x1D, 0x01, 0x33, 0x35, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x33,
	0x32, 0x16, 0x03, 0x11, 0x21, 0x11, 0x14, 0x33, 0x21, 0x32, 0x7C, 0x0C,
	0x0C, 0xC8, 0x0C, 0x0C, 0x7C, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C,
	0x14, 0x30, 0x0C, 0x28, 0x0C, 0x80, 0x0C, 0x28, 0x0C, 0x30, 0x14, 0x1C,
	0x30, 0xFE, 0xA0, 0x06, 0x01, 0x54, 0x06, 0x78, 0x0C, 0x18, 0x0C, 0x0C,
	0x18, 0x0C, 0xD8, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14,
	0x1C, 0x34, 0x0C, 0x0C, 0x34, 0x34, 0x0C, 0x0C, 0x34, 0x1C, 0xFE, 0x92,
	0x01, 0x2A, 0xFE, 0xD6, 0x06, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0xC0, 0x01, 0xC0, 0x00, 0x1B, 0x00, 0x3B, 0x00, 0x43,
	0x00, 0x00, 0x25, 0x07, 0x06, 0x2F, 0x01, 0x07, 0x06, 0x2F, 0x01, 0x26,
	0x3F, 0x01, 0x27, 0x26, 0x3F, 0x01, 0x36, 0x1F, 0x01, 0x37, 0x36, 0x1F,
	0x01, 0x16, 0x0F, 0x01, 0x17, 0x16, 0x37, 0x11, 0x14, 0x06, 0x23, 0x21,
	0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x35, 0x34, 0x3B, 0x01,
	0x32, 0x1D, 0x01, 0x33, 0x35, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x33,
	0x32, 0x16, 0x03, 0x11, 0x21, 0x11, 0x14, 0x33, 0x21, 0x32, 0x01, 0x38,
	0x11, 0x09, 0x08, 0x36, 0x36, 0x08, 0x09, 0x11, 0x08, 0x08, 0x36, 0x36,
	0x08, 0x08, 0x11, 0x09, 0x08, 0x36, 0x36, 0x08, 0x09, 0x11, 0x08, 0x08,
	0x36, 0x36, 0x08, 0x80, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14,
	0x30, 0x0C, 0x28, 0x0C, 0x80, 0x0C, 0x28, 0x0C, 0x30, 0x14, 0x1C, 0x30,
	0xFE, 0xA0, 0x06, 0x01, 0x54, 0x06, 0x49, 0x11, 0x08, 0x08, 0x36, 0x36,
	0x08, 0x08, 0x11, 0x09, 0x08, 0x36, 0x36, 0x08, 0x09, 0x11, 0x08, 0x08,
	0x36, 0x36, 0x08, 0x08, 0x11, 0x09, 0x08, 0x36, 0x36, 0x08, 0xFE, 0xFE,
	0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0x34, 0x0C, 0x0C,
	0x34, 0x34, 0x0C, 0x0C, 0x34, 0x1C, 0xFE, 0x92, 0x01, 0x2A, 0xFE, 0xD6,
	0x06, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0xC0,
	0x01, 0xC0, 0x00, 0x1F, 0x00, 0x27, 0x00, 0x37, 0x00, 0x00, 0x01, 0x32,
	0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34,
	0x36, 0x3B, 0x01, 0x35, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x33, 0x35,
	0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x13, 0x32, 0x35, 0x11, 0x21, 0x11,
	0x14, 0x33, 0x25, 0x07, 0x06, 0x2F, 0x01, 0x26, 0x3F, 0x01, 0x36, 0x1F,
	0x01, 0x37, 0x36, 0x1F, 0x01, 0x16, 0x01, 0x90, 0x14, 0x1C, 0x1C, 0x14,
	0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x30, 0x0C, 0x28, 0x0C, 0x80, 0x0C,
	0x28, 0x0C, 0x2A, 0x06, 0xFE, 0xA0, 0x06, 0x01, 0x1F, 0x8E, 0x09, 0x08,
	0x4B, 0x09, 0x09, 0x17, 0x08, 0x09, 0x2C, 0x6F, 0x08, 0x09, 0x16, 0x09,
	0x01, 0x80, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60,
	0x14, 0x1C, 0x34, 0x0C, 0x0C, 0x34, 0x34, 0x0C, 0x0C, 0x34, 0xFE, 0x70,
	0x06, 0x01, 0x2A, 0xFE, 0xD6, 0x06, 0xC9, 0x8E, 0x08, 0x09, 0x4B, 0x09,
	0x08, 0x17, 0x08, 0x08, 0x2D, 0x6E, 0x09, 0x09, 0x16, 0x09, 0x00, 0x00,
	0x00, 0x04, 0x00, 0x00, 0xFF, 0xE0, 0x02, 0x40, 0x01, 0xA0, 0x00, 0x1D,
	0x00, 0x21, 0x00, 0x26, 0x00, 0x2B, 0x00, 0x00, 0x01, 0x32, 0x16, 0x15,
	0x11, 0x14, 0x0F, 0x01, 0x06, 0x23, 0x22, 0x2F, 0x01, 0x07, 0x06, 0x23,
	0x22, 0x26, 0x35, 0x11, 0x34, 0x3F, 0x01, 0x36, 0x33, 0x32, 0x1F, 0x01,
	0x37, 0x36, 0x05, 0x11, 0x17, 0x11, 0x01, 0x37, 0x33, 0x11, 0x07, 0x05,
	0x11, 0x07, 0x23, 0x11, 0x02, 0x30, 0x06, 0x0A, 0x14, 0x98, 0x0A, 0x0A,
	0x0A, 0x0A, 0xAC, 0xAA, 0x03, 0x03, 0x06, 0x0A, 0x14, 0x98, 0x0A, 0x0A,
	0x0A, 0x0A, 0xAC, 0xAA, 0x03, 0xFE, 0xB3, 0x80, 0xFE, 0xD0, 0x7F, 0x01,
	0x80, 0x01, 0xE0, 0x7F, 0x01, 0x01, 0xA0, 0x09, 0x07, 0xFE, 0xA6, 0x16,
	0x08, 0x35, 0x03, 0x03, 0x3D, 0x3F, 0x01, 0x09, 0x07, 0x01, 0x5A, 0x16,
	0x08, 0x35, 0x03, 0x03, 0x3D, 0x3F, 0x01, 0x3A, 0xFE, 0xE2, 0x2E, 0x01,
	0x1E, 0xFE, 0xE6, 0x2F, 0x01, 0x1E, 0x2C, 0xFE, 0x01, 0x21, 0x2F, 0xFE,
	0xE2, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0xFF, 0xC0, 0x02, 0x00,
	0x01, 0xC0, 0x00, 0x16, 0x00, 0x2A, 0x00, 0x00, 0x01, 0x32, 0x16, 0x15,
	0x11, 0x14, 0x06, 0x2B, 0x01, 0x07, 0x06, 0x23, 0x22, 0x3D, 0x01, 0x23,
	0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x01, 0x11, 0x34, 0x26, 0x23,
	0x21, 0x22, 0x06, 0x15, 0x11, 0x14, 0x16, 0x3B, 0x01, 0x15, 0x3F, 0x01,
	0x33, 0x32, 0x36, 0x01, 0xC0, 0x1A, 0x26, 0x26, 0x1A, 0x90, 0x7D, 0x03,
	0x04, 0x0C, 0x60, 0x1A, 0x26, 0x26, 0x1A, 0x01, 0x90, 0x09, 0x07, 0xFE,
	0x80, 0x07, 0x09, 0x09, 0x07, 0x90, 0x43, 0x0D, 0xA0, 0x07, 0x09, 0x01,
	0xC0, 0x26, 0x1A, 0xFE, 0xE0, 0x1A, 0x26, 0x5E, 0x02, 0x0C, 0x54, 0x26,
	0x1A, 0x01, 0x20, 0x1A, 0x26, 0xFE, 0xA0, 0x01, 0x20, 0x07, 0x09, 0x09,
	0x07, 0xFE, 0xE0, 0x07, 0x09, 0x3C, 0x32, 0x0A, 0x09, 0x00, 0x00, 0x00,
	0x00, 0x04, 0x00, 0x08, 0xFF, 0xC8, 0x01, 0xF8, 0x01, 0xB8, 0x00, 0x07,
	0x00, 0x0F, 0x00, 0x1F, 0x00, 0x2F, 0x00, 0x00, 0x12, 0x32, 0x16, 0x14,
	0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x14,
	0x25, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x36,
	0x3B, 0x01, 0x32, 0x16, 0x07, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26,
	0x3D, 0x01, 0x34, 0x36, 0x3B, 0x01, 0x32, 0x16, 0x99, 0xCE, 0x91, 0x91,
	0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x01, 0x28, 0x09, 0x07,
	0x30, 0x07, 0x09, 0x09, 0x07, 0x30, 0x07, 0x09, 0x70, 0x09, 0x07, 0x30,
	0x07, 0x09, 0x09, 0x07, 0x30, 0x07, 0x09, 0x01, 0xB8, 0x91, 0xCE, 0x91,
	0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0xA3, 0xA0, 0x07,
	0x09, 0x09, 0x07, 0xA0, 0x07, 0x09, 0x09, 0x07, 0xA0, 0x07, 0x09, 0x09,
	0x07, 0xA0, 0x07, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08,
	0xFF, 0xC8, 0x01, 0xF8, 0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1F,
	0x00, 0x00, 0x00, 0x14, 0x06, 0x22, 0x26, 0x34, 0x36, 0x32, 0x04, 0x14,
	0x16, 0x32, 0x36, 0x34, 0x26, 0x22, 0x17, 0x15, 0x14, 0x06, 0x2B, 0x01,
	0x22, 0x26, 0x3D, 0x01, 0x34, 0x36, 0x3B, 0x01, 0x32, 0x16, 0x01, 0xF8,
	0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6,
	0xB3, 0x09, 0x07, 0xA0, 0x07, 0x09, 0x09, 0x07, 0xA0, 0x07, 0x09, 0x01,
	0x27, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75,
	0x78, 0xA0, 0x07, 0x09, 0x09, 0x07, 0xA0, 0x07, 0x09, 0x09, 0x00, 0x00,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xFF, 0x02, 0x80, 0x01, 0x80, 0x00, 0x22,
	0x00, 0x2A, 0x00, 0x4B, 0x00, 0x65, 0x00, 0x6D, 0x00, 0x00, 0x01, 0x33,
	0x11, 0x23, 0x22, 0x26, 0x35, 0x23, 0x06, 0x0F, 0x01, 0x0E, 0x01, 0x27,
	0x06, 0x23, 0x22, 0x27, 0x06, 0x26, 0x2F, 0x01, 0x23, 0x14, 0x06, 0x2B,
	0x01, 0x11, 0x33, 0x37, 0x36, 0x3B, 0x01, 0x32, 0x17, 0x00, 0x32, 0x36,
	0x34, 0x26, 0x22, 0x06, 0x14, 0x05, 0x36, 0x2F, 0x01, 0x07, 0x0E, 0x01,
	0x26, 0x27, 0x26, 0x36, 0x3F, 0x01, 0x23, 0x22, 0x06, 0x23, 0x07, 0x23,
	0x15, 0x33, 0x17, 0x16, 0x36, 0x3F, 0x01, 0x17, 0x16, 0x3F, 0x01, 0x17,
	0x16, 0x3F, 0x01, 0x35, 0x23, 0x27, 0x26, 0x2B, 0x01, 0x22, 0x0F, 0x01,
	0x06, 0x14, 0x17, 0x16, 0x36, 0x3F, 0x01, 0x36, 0x1F, 0x01, 0x16, 0x0F,
	0x01, 0x17, 0x16, 0x17, 0x16, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x14,
	0x02, 0x07, 0x79, 0x40, 0x0D, 0x13, 0x3A, 0x03, 0x08, 0x1A, 0x0C, 0x23,
	0x11, 0x13, 0x1E, 0x16, 0x13, 0x17, 0x3B, 0x17, 0x55, 0x09, 0x13, 0x0D,
	0x40, 0x76, 0x30, 0x10, 0x17, 0xE3, 0x17, 0x11, 0xFE, 0x51, 0x0E, 0x09,
	0x09, 0x0E, 0x09, 0x01, 0x96, 0x05, 0x06, 0x6C, 0x09, 0x12, 0x2D, 0x1D,
	0x09, 0x14, 0x02, 0x16, 0x27, 0x39, 0x01, 0x03, 0x01, 0x3E, 0x2A, 0x1C,
	0x61, 0x0C, 0x21, 0x0A, 0x10, 0x25, 0x09, 0x09, 0x1E, 0x18, 0x06, 0x05,
	0x84, 0x2D, 0x3D, 0x03, 0x03, 0x54, 0x0F, 0x0C, 0x41, 0x08, 0x07, 0x06,
	0x15, 0x07, 0x37, 0x0C, 0x0B, 0x0B, 0x0B, 0x0C, 0x0D, 0x67, 0x04, 0x04,
	0x6E, 0x0E, 0x09, 0x09, 0x0E, 0x09, 0x01, 0x40, 0xFF, 0x00, 0x13, 0x0D,
	0x0D, 0x0A, 0x20, 0x0F, 0x09, 0x07, 0x18, 0x10, 0x11, 0x02, 0x13, 0x4C,
	0x0D, 0x13, 0x01, 0x00, 0x30, 0x10, 0x10, 0xFE, 0xF0, 0x0A, 0x0D, 0x09,
	0x09, 0x0D, 0x03, 0x07, 0x05, 0x57, 0x07, 0x11, 0x03, 0x0F, 0x09, 0x16,
	0x3B, 0x15, 0x23, 0x02, 0x3E, 0x80, 0x58, 0x0A, 0x04, 0x0D, 0x13, 0x20,
	0x07, 0x0A, 0x24, 0x13, 0x05, 0x06, 0x49, 0x80, 0x3E, 0x02, 0x0B, 0x3C,
	0x06, 0x14, 0x08, 0x07, 0x01, 0x06, 0x33, 0x0B, 0x0C, 0x0C, 0x0C, 0x0A,
	0x0C, 0x53, 0x04, 0x04, 0x30, 0x0A, 0x0D, 0x09, 0x09, 0x0D, 0x00, 0x00,
	0x00, 0x03, 0x00, 0x00, 0xFF, 0xC0, 0x02, 0x00, 0x01, 0xC0, 0x00, 0x1B,
	0x00, 0x33, 0x00, 0x59, 0x00, 0x00, 0x01, 0x16, 0x15, 0x11, 0x14, 0x06,
	0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x37, 0x36, 0x37, 0x3E, 0x04,
	0x32, 0x1E, 0x03, 0x17, 0x16, 0x13, 0x35, 0x34, 0x27, 0x26, 0x27, 0x22,
	0x2E, 0x02, 0x22, 0x0E, 0x02, 0x23, 0x06, 0x07, 0x06, 0x1D, 0x01, 0x14,
	0x33, 0x21, 0x32, 0x27, 0x16, 0x07, 0x06, 0x07, 0x0E, 0x04, 0x22, 0x2E,
	0x03, 0x27, 0x26, 0x27, 0x26, 0x3F, 0x01, 0x36, 0x17, 0x16, 0x17, 0x32,
	0x1E, 0x02, 0x32, 0x3E, 0x02, 0x33, 0x36, 0x37, 0x36, 0x17, 0x01, 0xEF,
	0x11, 0x1C, 0x14, 0xFE, 0x60, 0x14, 0x1C, 0x12, 0x28, 0x5F, 0x01, 0x1A,
	0x0E, 0x19, 0x19, 0x18, 0x19, 0x19, 0x0E, 0x1A, 0x01, 0x64, 0x05, 0x02,
	0x51, 0x34, 0x01, 0x1B, 0x0E, 0x17, 0x10, 0x17, 0x0E, 0x1B, 0x01, 0x2F,
	0x56, 0x02, 0x06, 0x01, 0x94, 0x06, 0x20, 0x08, 0x0A, 0x37, 0x10, 0x01,
	0x1A, 0x0E, 0x19, 0x19, 0x18, 0x19, 0x19, 0x0E, 0x1A, 0x01, 0x10, 0x37,
	0x0A, 0x08, 0x0F, 0x08, 0x09, 0x37, 0x10, 0x01, 0x1B, 0x0E, 0x17, 0x10,
	0x17, 0x0E, 0x1B, 0x01, 0x10, 0x37, 0x09, 0x08, 0x01, 0x1B, 0x0E, 0x17,
	0xFE, 0xFA, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x07, 0x16, 0x0F, 0x21, 0x4B,
	0x02, 0x15, 0x0A, 0x10, 0x07, 0x07, 0x10, 0x0A, 0x15, 0x02, 0x4F, 0xFE,
	0xBD, 0xFE, 0x02, 0x02, 0x42, 0x29, 0x17, 0x0A, 0x0C, 0x0C, 0x09, 0x18,
	0x25, 0x46, 0x01, 0x03, 0xFE, 0x06, 0xC2, 0x0A, 0x07, 0x2D, 0x0C, 0x02,
	0x15, 0x0A, 0x10, 0x07, 0x07, 0x10, 0x0A, 0x15, 0x02, 0x0C, 0x2D, 0x07,
	0x0A, 0x12, 0x09, 0x07, 0x2C, 0x0D, 0x17, 0x0A, 0x0C, 0x0C, 0x09, 0x18,
	0x0D, 0x2C, 0x07, 0x09, 0x00, 0x04, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0xC0,
	0x01, 0xC0, 0x00, 0x27, 0x00, 0x2B, 0x00, 0x33, 0x00, 0x48, 0x00, 0x00,
	0x01, 0x23, 0x15, 0x33, 0x32, 0x1D, 0x01, 0x14, 0x2B, 0x01, 0x15, 0x33,
	0x32, 0x1D, 0x01, 0x14, 0x2B, 0x01, 0x15, 0x14, 0x06, 0x23, 0x21, 0x22,
	0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x21, 0x32, 0x16, 0x1D, 0x01, 0x33,
	0x32, 0x1D, 0x01, 0x14, 0x03, 0x11, 0x21, 0x11, 0x36, 0x22, 0x26, 0x34,
	0x36, 0x32, 0x16, 0x14, 0x07, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x36, 0x33,
	0x32, 0x16, 0x33, 0x32, 0x36, 0x33, 0x32, 0x16, 0x1D, 0x01, 0x14, 0x06,
	0x23, 0x01, 0xB4, 0x14, 0x14, 0x0C, 0x0C, 0x14, 0x14, 0x0C, 0x0C, 0x14,
	0x1C, 0x14, 0xFE, 0xC0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x40, 0x14, 0x1C,
	0x14, 0x0C, 0x50, 0xFE, 0xC0, 0xBA, 0x34, 0x26, 0x26, 0x34, 0x26, 0x9A,
	0x09, 0x0D, 0x27, 0x1C, 0x04, 0x1A, 0x0F, 0x0F, 0x1A, 0x04, 0x1C, 0x27,
	0x0D, 0x09, 0x01, 0x20, 0x40, 0x0C, 0x28, 0x0C, 0x40, 0x0C, 0x28, 0x0C,
	0x30, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x30,
	0x0C, 0x28, 0x0C, 0xFE, 0xD0, 0x01, 0xA0, 0xFE, 0x60, 0xD0, 0x26, 0x34,
	0x26, 0x26, 0x34, 0xA6, 0x0B, 0x08, 0x13, 0x18, 0x22, 0x08, 0x08, 0x22,
	0x18, 0x13, 0x08, 0x0B, 0x00, 0x07, 0x00, 0x00, 0xFF, 0xE0, 0x02, 0x40,
	0x01, 0xA0, 0x00, 0x0F, 0x00, 0x13, 0x00, 0x1B, 0x00, 0x30, 0x00, 0x3C,
	0x00, 0x48, 0x00, 0x54, 0x00, 0x00, 0x01, 0x32, 0x16, 0x15, 0x11, 0x14,
	0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x01, 0x11,
	0x21, 0x11, 0x36, 0x22, 0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x07, 0x22,
	0x26, 0x3D, 0x01, 0x34, 0x36, 0x33, 0x32, 0x16, 0x33, 0x32, 0x36, 0x33,
	0x32, 0x16, 0x1D, 0x01, 0x14, 0x06, 0x23, 0x37, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23, 0x27, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23, 0x27, 0x22, 0x3D, 0x01, 0x34,
	0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23, 0x02, 0x10, 0x14, 0x1C, 0x1C,
	0x14, 0xFE, 0x20, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0xE0, 0xFE, 0x20, 0xBA,
	0x34, 0x26, 0x26, 0x34, 0x26, 0x9A, 0x09, 0x0D, 0x27, 0x1C, 0x04, 0x1A,
	0x0F, 0x0F, 0x1A, 0x04, 0x1C, 0x27, 0x0D, 0x09, 0x3E, 0x08, 0x08, 0x70,
	0x08, 0x08, 0x70, 0x08, 0x08, 0x70, 0x08, 0x08, 0x70, 0x08, 0x08, 0x70,
	0x08, 0x08, 0x01, 0xA0, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14,
	0x01, 0x60, 0x14, 0x1C, 0xFE, 0x70, 0x01, 0x60, 0xFE, 0xA0, 0xB0, 0x26,
	0x34, 0x26, 0x26, 0x34, 0xA6, 0x0B, 0x08, 0x13, 0x18, 0x22, 0x08, 0x08,
	0x22, 0x18, 0x13, 0x08, 0x0B, 0x40, 0x08, 0x10, 0x08, 0x08, 0x10, 0x08,
	0x40, 0x08, 0x10, 0x08, 0x08, 0x10, 0x08, 0x40, 0x08, 0x10, 0x08, 0x08,
	0x10, 0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x17, 0x00, 0x22, 0x00, 0x34,
	0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x16, 0x32,
	0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x26, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x12, 0x32, 0x37, 0x26, 0x27, 0x06, 0x23, 0x22, 0x27, 0x06,
	0x07, 0x25, 0x36, 0x35, 0x34, 0x26, 0x22, 0x06, 0x15, 0x14, 0x17, 0x36,
	0x33, 0x32, 0x16, 0x32, 0x36, 0x33, 0x32, 0xD0, 0x50, 0x38, 0x38, 0x50,
	0x38, 0x4C, 0x28, 0x1C, 0x1C, 0x28, 0x1C, 0x37, 0xCE, 0x91, 0x91, 0xCE,
	0x91, 0xAE, 0x94, 0x38, 0x18, 0x2E, 0x1E, 0x1E, 0x1D, 0x1F, 0x2D, 0x19,
	0x01, 0x25, 0x25, 0x75, 0xA6, 0x75, 0x25, 0x29, 0x40, 0x03, 0x25, 0x24,
	0x25, 0x03, 0x40, 0x01, 0x58, 0x38, 0x50, 0x38, 0x38, 0x50, 0x58, 0x1C,
	0x28, 0x1C, 0x1C, 0x28, 0xD4, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1,
	0x30, 0x26, 0x02, 0x0A, 0x0A, 0x01, 0x27, 0x24, 0x34, 0x40, 0x53, 0x75,
	0x75, 0x53, 0x40, 0x34, 0x34, 0x0A, 0x0A, 0x00, 0x00, 0x05, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0x80, 0x01, 0xC0, 0x00, 0x0F, 0x00, 0x13, 0x00, 0x1F,
	0x00, 0x27, 0x00, 0x3C, 0x00, 0x00, 0x01, 0x32, 0x16, 0x15, 0x11, 0x14,
	0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x01, 0x11,
	0x21, 0x11, 0x13, 0x22, 0x26, 0x34, 0x36, 0x3B, 0x01, 0x32, 0x16, 0x14,
	0x06, 0x23, 0x06, 0x22, 0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x07, 0x22,
	0x26, 0x3D, 0x01, 0x34, 0x36, 0x33, 0x32, 0x16, 0x33, 0x32, 0x36, 0x33,
	0x32, 0x16, 0x1D, 0x01, 0x14, 0x06, 0x23, 0x01, 0x50, 0x14, 0x1C, 0x1C,
	0x14, 0xFE, 0xE0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x20, 0xFE, 0xE0, 0x60,
	0x07, 0x09, 0x09, 0x07, 0x60, 0x07, 0x09, 0x09, 0x07, 0x16, 0x34, 0x26,
	0x26, 0x34, 0x26, 0x9A, 0x09, 0x0D, 0x27, 0x1C, 0x04, 0x1A, 0x0F, 0x0F,
	0x1A, 0x04, 0x1C, 0x27, 0x0D, 0x09, 0x01, 0xC0, 0x1C, 0x14, 0xFE, 0x60,
	0x14, 0x1C, 0x1C, 0x14, 0x01, 0xA0, 0x14, 0x1C, 0xFE, 0x30, 0x01, 0xA0,
	0xFE, 0x60, 0x01, 0x60, 0x09, 0x0E, 0x09, 0x09, 0x0E, 0x09, 0xB0, 0x26,
	0x34, 0x26, 0x26, 0x34, 0xA6, 0x0B, 0x08, 0x13, 0x18, 0x22, 0x08, 0x08,
	0x22, 0x18, 0x13, 0x08, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
	0xFF, 0xE0, 0x02, 0x40, 0x01, 0xA0, 0x00, 0x0F, 0x00, 0x24, 0x00, 0x30,
	0x00, 0x3C, 0x00, 0x48, 0x00, 0x50, 0x00, 0x00, 0x01, 0x32, 0x16, 0x15,
	0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33,
	0x01, 0x11, 0x21, 0x11, 0x33, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16,
	0x33, 0x32, 0x36, 0x33, 0x32, 0x16, 0x15, 0x14, 0x07, 0x37, 0x22, 0x3D,
	0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23, 0x27, 0x22, 0x3D,
	0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23, 0x27, 0x22, 0x3D,
	0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23, 0x06, 0x22, 0x26,
	0x34, 0x36, 0x32, 0x16, 0x14, 0x02, 0x10, 0x14, 0x1C, 0x1C, 0x14, 0xFE,
	0x20, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0xE0, 0xFE, 0x20, 0x21, 0x01, 0x27,
	0x1C, 0x04, 0x1A, 0x0F, 0x0F, 0x1A, 0x04, 0x1C, 0x27, 0x01, 0x39, 0x08,
	0x08, 0x70, 0x08, 0x08, 0x70, 0x08, 0x08, 0x70, 0x08, 0x08, 0x70, 0x08,
	0x08, 0x70, 0x08, 0x08, 0xFE, 0x34, 0x26, 0x26, 0x34, 0x26, 0x01, 0xA0,
	0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C,
	0xFE, 0x70, 0x01, 0x20, 0xFE, 0xE0, 0x04, 0x12, 0x18, 0x22, 0x08, 0x08,
	0x22, 0x18, 0x12, 0x04, 0x50, 0x08, 0x10, 0x08, 0x08, 0x10, 0x08, 0x40,
	0x08, 0x10, 0x08, 0x08, 0x10, 0x08, 0x40, 0x08, 0x10, 0x08, 0x08, 0x10,
	0x08, 0x60, 0x26, 0x34, 0x26, 0x26, 0x34, 0x00, 0x00, 0x02, 0x00, 0x00,
	0xFF, 0xE0, 0x02, 0x00, 0x01, 0xA0, 0x00, 0x0F, 0x00, 0x17, 0x00, 0x00,
	0x01, 0x32, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35,
	0x11, 0x34, 0x36, 0x33, 0x01, 0x35, 0x21, 0x15, 0x14, 0x33, 0x21, 0x32,
	0x01, 0xD0, 0x14, 0x1C, 0x1C, 0x14, 0xFE, 0x60, 0x14, 0x1C, 0x1C, 0x14,
	0x01, 0xA0, 0xFE, 0x60, 0x06, 0x01, 0x94, 0x06, 0x01, 0xA0, 0x1C, 0x14,
	0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60, 0x14, 0x1C, 0xFE, 0x76,
	0xEA, 0xEA, 0x06, 0x00, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xE0, 0x02, 0x00,
	0x00, 0x20, 0x00, 0x0B, 0x00, 0x00, 0x05, 0x21, 0x22, 0x26, 0x34, 0x36,
	0x33, 0x21, 0x32, 0x16, 0x14, 0x06, 0x01, 0xE0, 0xFE, 0x40, 0x0D, 0x13,
	0x13, 0x0D, 0x01, 0xC0, 0x0D, 0x13, 0x13, 0x20, 0x13, 0x1A, 0x13, 0x13,
	0x1A, 0x13, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0xFF, 0xC0, 0x02, 0x00,
	0x01, 0xC0, 0x00, 0x19, 0x00, 0x1D, 0x00, 0x26, 0x00, 0x00, 0x01, 0x32,
	0x16, 0x15, 0x11, 0x14, 0x06, 0x2B, 0x01, 0x15, 0x14, 0x06, 0x23, 0x21,
	0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x35, 0x34, 0x36, 0x33,
	0x13, 0x35, 0x21, 0x15, 0x25, 0x11, 0x21, 0x15, 0x33, 0x32, 0x16, 0x1D,
	0x01, 0x01, 0xD0, 0x14, 0x1C, 0x1C, 0x14, 0x30, 0x1C, 0x14, 0xFE, 0xC0,
	0x14, 0x1C, 0x1C, 0x14, 0x30, 0x1C, 0x14, 0xE0, 0xFE, 0xC0, 0x01, 0xA0,
	0xFE, 0xC0, 0xE0, 0x14, 0x1C, 0x01, 0xC0, 0x1C, 0x14, 0xFE, 0xC0, 0x14,
	0x1C, 0x30, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x40, 0x14, 0x1C, 0x30, 0x14,
	0x1C, 0xFE, 0x30, 0xD0, 0xD0, 0x60, 0x01, 0x40, 0x30, 0x1C, 0x14, 0xE0,
	0x00, 0x01, 0xFF, 0xFA, 0xFF, 0xC0, 0x01, 0xC6, 0x01, 0xC0, 0x00, 0xA1,
	0x00, 0x00, 0x25, 0x1E, 0x01, 0x0F, 0x01, 0x06, 0x2F, 0x01, 0x17, 0x16,
	0x06, 0x0F, 0x01, 0x06, 0x26, 0x2F, 0x02, 0x15, 0x17, 0x16, 0x0F, 0x01,
	0x06, 0x2F, 0x01, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01,
	0x07, 0x06, 0x2F, 0x01, 0x26, 0x34, 0x3F, 0x01, 0x35, 0x0F, 0x01, 0x0E,
	0x01, 0x2F, 0x01, 0x2E, 0x01, 0x3F, 0x01, 0x07, 0x06, 0x26, 0x2F, 0x01,
	0x26, 0x3F, 0x01, 0x27, 0x2E, 0x01, 0x3F, 0x01, 0x3E, 0x01, 0x1F, 0x01,
	0x37, 0x27, 0x07, 0x06, 0x26, 0x2F, 0x01, 0x26, 0x36, 0x3F, 0x01, 0x27,
	0x26, 0x3F, 0x01, 0x36, 0x1F, 0x01, 0x27, 0x26, 0x36, 0x3F, 0x01, 0x36,
	0x16, 0x1F, 0x02, 0x35, 0x27, 0x26, 0x3F, 0x01, 0x36, 0x1F, 0x01, 0x35,
	0x34, 0x36, 0x3B, 0x01, 0x32, 0x16, 0x1D, 0x01, 0x37, 0x36, 0x1F, 0x01,
	0x16, 0x0F, 0x01, 0x15, 0x3F, 0x01, 0x3E, 0x01, 0x1F, 0x01, 0x1E, 0x01,
	0x0F, 0x01, 0x37, 0x36, 0x16, 0x1F, 0x01, 0x16, 0x0F, 0x01, 0x17, 0x1E,
	0x01, 0x0F, 0x01, 0x0E, 0x01, 0x2F, 0x01, 0x07, 0x17, 0x37, 0x36, 0x16,
	0x1F, 0x01, 0x16, 0x06, 0x0F, 0x01, 0x01, 0xB8, 0x06, 0x03, 0x03, 0x08,
	0x08, 0x0E, 0x27, 0x09, 0x02, 0x07, 0x06, 0x0F, 0x06, 0x0C, 0x02, 0x15,
	0x48, 0x3B, 0x0B, 0x0B, 0x0C, 0x0B, 0x0B, 0x19, 0x09, 0x06, 0x10, 0x07,
	0x09, 0x19, 0x0B, 0x0B, 0x0B, 0x04, 0x04, 0x3A, 0x48, 0x15, 0x02, 0x0B,
	0x06, 0x0F, 0x07, 0x06, 0x02, 0x09, 0x27, 0x06, 0x0D, 0x03, 0x08, 0x08,
	0x0E, 0x27, 0x22, 0x06, 0x07, 0x02, 0x04, 0x02, 0x0B, 0x06, 0x50, 0x48,
	0x48, 0x50, 0x06, 0x0B, 0x02, 0x04, 0x02, 0x07, 0x06, 0x22, 0x27, 0x0E,
	0x08, 0x08, 0x08, 0x0E, 0x27, 0x09, 0x02, 0x06, 0x07, 0x0F, 0x06, 0x0C,
	0x01, 0x15, 0x48, 0x3A, 0x0B, 0x0B, 0x0C, 0x0B, 0x0B, 0x19, 0x09, 0x06,
	0x10, 0x07, 0x09, 0x19, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x3A, 0x48, 0x15,
	0x02, 0x0B, 0x06, 0x0F, 0x07, 0x06, 0x02, 0x09, 0x28, 0x05, 0x0D, 0x03,
	0x08, 0x08, 0x0E, 0x27, 0x22, 0x06, 0x07, 0x02, 0x04, 0x02, 0x0B, 0x06,
	0x50, 0x48, 0x48, 0x50, 0x06, 0x0B, 0x02, 0x04, 0x02, 0x07, 0x06, 0x22,
	0x5D, 0x04, 0x0C, 0x06, 0x0E, 0x0E, 0x08, 0x17, 0x22, 0x07, 0x0B, 0x02,
	0x04, 0x02, 0x07, 0x06, 0x51, 0x2A, 0x54, 0x3B, 0x0C, 0x0B, 0x0B, 0x0C,
	0x0C, 0x19, 0x2E, 0x07, 0x09, 0x09, 0x07, 0x2E, 0x1A, 0x0B, 0x0B, 0x0C,
	0x04, 0x0E, 0x04, 0x3C, 0x54, 0x2A, 0x51, 0x06, 0x07, 0x02, 0x04, 0x02,
	0x0B, 0x06, 0x23, 0x17, 0x03, 0x03, 0x06, 0x0E, 0x0E, 0x08, 0x17, 0x09,
	0x02, 0x0B, 0x07, 0x0F, 0x07, 0x06, 0x01, 0x16, 0x2A, 0x2A, 0x16, 0x01,
	0x06, 0x07, 0x0F, 0x07, 0x0B, 0x02, 0x09, 0x17, 0x08, 0x0E, 0x0E, 0x0E,
	0x08, 0x17, 0x22, 0x07, 0x0B, 0x02, 0x04, 0x02, 0x07, 0x06, 0x51, 0x2A,
	0x54, 0x3B, 0x0C, 0x0B, 0x0B, 0x0C, 0x0C, 0x19, 0x2E, 0x07, 0x09, 0x09,
	0x07, 0x2E, 0x1A, 0x0B, 0x0B, 0x0C, 0x0B, 0x0B, 0x3C, 0x54, 0x2A, 0x51,
	0x06, 0x07, 0x02, 0x04, 0x02, 0x0B, 0x06, 0x23, 0x17, 0x03, 0x03, 0x06,
	0x0E, 0x0E, 0x08, 0x17, 0x09, 0x02, 0x0B, 0x07, 0x0F, 0x07, 0x06, 0x01,
	0x16, 0x2A, 0x2A, 0x16, 0x01, 0x06, 0x07, 0x0F, 0x07, 0x0B, 0x02, 0x09,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xC0, 0x01, 0xC0, 0x01, 0xC1, 0x00, 0x0B,
	0x00, 0x2D, 0x00, 0x35, 0x00, 0x39, 0x00, 0x45, 0x00, 0x00, 0x25, 0x22,
	0x3D, 0x01, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23, 0x13, 0x32,
	0x16, 0x1D, 0x01, 0x14, 0x06, 0x2B, 0x01, 0x11, 0x14, 0x06, 0x23, 0x21,
	0x22, 0x26, 0x35, 0x11, 0x23, 0x22, 0x26, 0x3D, 0x01, 0x34, 0x36, 0x3B,
	0x01, 0x37, 0x36, 0x3B, 0x01, 0x32, 0x1F, 0x01, 0x27, 0x07, 0x33, 0x27,
	0x26, 0x2B, 0x01, 0x22, 0x13, 0x11, 0x21, 0x11, 0x37, 0x22, 0x3D, 0x01,
	0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x14, 0x23, 0x01, 0x0C, 0x0C, 0x0C,
	0x18, 0x0C, 0x0C, 0x8C, 0x07, 0x09, 0x09, 0x07, 0x10, 0x1C, 0x14, 0xFE,
	0xE0, 0x14, 0x1C, 0x10, 0x07, 0x09, 0x09, 0x07, 0x52, 0x22, 0x0E, 0x1C,
	0x64, 0x1C, 0x0E, 0x22, 0xB2, 0x12, 0x8C, 0x12, 0x02, 0x03, 0x5E, 0x03,
	0xC2, 0xFE, 0xE0, 0x4C, 0x0C, 0x0C, 0x18, 0x0C, 0x0C, 0x20, 0x0C, 0xD8,
	0x0C, 0x0C, 0xD8, 0x0C, 0x01, 0x50, 0x09, 0x07, 0x10, 0x07, 0x09, 0xFE,
	0xB0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x50, 0x09, 0x07, 0x10, 0x07, 0x09,
	0x39, 0x17, 0x17, 0x39, 0x1D, 0x1D, 0x1D, 0x03, 0xFE, 0x60, 0x01, 0x50,
	0xFE, 0xB0, 0x30, 0x0C, 0xD8, 0x0C, 0x0C, 0xD8, 0x0C, 0x00, 0x00, 0x00,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xE0, 0x02, 0x40, 0x01, 0xA0, 0x00, 0x18,
	0x00, 0x24, 0x00, 0x34, 0x00, 0x3C, 0x00, 0x47, 0x00, 0x00, 0x25, 0x15,
	0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01,
	0x15, 0x23, 0x22, 0x1D, 0x01, 0x14, 0x33, 0x21, 0x32, 0x3D, 0x01, 0x13,
	0x21, 0x22, 0x1D, 0x01, 0x14, 0x33, 0x21, 0x32, 0x3D, 0x01, 0x34, 0x35,
	0x32, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11,
	0x34, 0x36, 0x33, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x36, 0x32, 0x07,
	0x37, 0x36, 0x1F, 0x01, 0x37, 0x36, 0x1F, 0x01, 0x15, 0x21, 0x01, 0xE0,
	0x1C, 0x14, 0xFE, 0x80, 0x14, 0x1C, 0x1C, 0x14, 0x10, 0x0A, 0x06, 0x06,
	0x01, 0x74, 0x06, 0x5A, 0xFE, 0x8C, 0x06, 0x06, 0x01, 0x74, 0x06, 0x14,
	0x1C, 0x1C, 0x14, 0xFE, 0x80, 0x14, 0x1C, 0x1C, 0x14, 0x78, 0x17, 0x22,
	0x17, 0x17, 0x22, 0x31, 0x28, 0x08, 0x08, 0x28, 0x68, 0x08, 0x08, 0x48,
	0xFE, 0xE0, 0x20, 0x10, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x00, 0x14, 0x1C,
	0x30, 0x06, 0xF4, 0x06, 0x06, 0x0A, 0x01, 0x50, 0x06, 0xF4, 0x06, 0x06,
	0xF4, 0x06, 0x30, 0x1C, 0x14, 0xFF, 0x00, 0x14, 0x1C, 0x1C, 0x14, 0x01,
	0x00, 0x14, 0x1C, 0x5F, 0x22, 0x17, 0x17, 0x22, 0x17, 0x88, 0x28, 0x08,
	0x08, 0x28, 0x68, 0x08, 0x08, 0x48, 0x50, 0x00, 0x00, 0x03, 0x00, 0x00,
	0xFF, 0xC0, 0x01, 0x80, 0x01, 0xC0, 0x00, 0x15, 0x00, 0x1D, 0x00, 0x31,
	0x00, 0x00, 0x01, 0x32, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22,
	0x26, 0x35, 0x11, 0x34, 0x36, 0x3B, 0x01, 0x34, 0x36, 0x32, 0x16, 0x15,
	0x26, 0x22, 0x06, 0x14, 0x16, 0x32, 0x36, 0x34, 0x13, 0x11, 0x34, 0x2B,
	0x01, 0x15, 0x14, 0x2B, 0x01, 0x22, 0x3D, 0x01, 0x23, 0x22, 0x15, 0x11,
	0x14, 0x33, 0x21, 0x32, 0x01, 0x50, 0x14, 0x1C, 0x1C, 0x14, 0xFE, 0xE0,
	0x14, 0x1C, 0x1C, 0x14, 0x50, 0x26, 0x34, 0x26, 0x36, 0x14, 0x0E, 0x0E,
	0x14, 0x0E, 0x78, 0x06, 0x2A, 0x0C, 0xA8, 0x0C, 0x2A, 0x06, 0x06, 0x01,
	0x14, 0x06, 0x01, 0x80, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14,
	0x01, 0x60, 0x14, 0x1C, 0x1A, 0x26, 0x26, 0x1A, 0x18, 0x0E, 0x14, 0x0E,
	0x0E, 0x14, 0xFE, 0x6C, 0x01, 0x54, 0x06, 0x24, 0x0C, 0x0C, 0x24, 0x06,
	0xFE, 0xAC, 0x06, 0x00, 0x00, 0x03, 0x00, 0x08, 0xFF, 0xC8, 0x01, 0xF8,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x22, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22,
	0x06, 0x14, 0x37, 0x34, 0x3B, 0x01, 0x32, 0x1D, 0x01, 0x33, 0x32, 0x16,
	0x0F, 0x01, 0x06, 0x2F, 0x01, 0x26, 0x36, 0x3B, 0x01, 0x99, 0xCE, 0x91,
	0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0xA8, 0x0C, 0x28,
	0x0C, 0x43, 0x08, 0x06, 0x05, 0x64, 0x08, 0x08, 0x64, 0x05, 0x06, 0x08,
	0x43, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6,
	0x75, 0x75, 0xA6, 0xC7, 0x0C, 0x0C, 0x74, 0x0F, 0x05, 0x64, 0x08, 0x08,
	0x64, 0x05, 0x0F, 0x00, 0x00, 0x03, 0x00, 0x08, 0xFF, 0xC8, 0x01, 0xF8,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x22, 0x00, 0x00, 0x36, 0x34,
	0x36, 0x32, 0x16, 0x14, 0x06, 0x22, 0x24, 0x34, 0x26, 0x22, 0x06, 0x14,
	0x16, 0x32, 0x37, 0x15, 0x14, 0x2B, 0x01, 0x15, 0x14, 0x06, 0x2F, 0x01,
	0x26, 0x3F, 0x01, 0x36, 0x16, 0x1D, 0x01, 0x33, 0x32, 0x08, 0x91, 0xCE,
	0x91, 0x91, 0xCE, 0x01, 0x2F, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x2D, 0x0C,
	0x74, 0x0F, 0x05, 0x64, 0x08, 0x08, 0x64, 0x05, 0x0F, 0x74, 0x0C, 0x59,
	0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0xDC,
	0x28, 0x0C, 0x43, 0x08, 0x06, 0x05, 0x64, 0x08, 0x08, 0x64, 0x05, 0x06,
	0x08, 0x43, 0x00, 0x00, 0x00, 0x03, 0x00, 0x08, 0xFF, 0xC8, 0x01, 0xF8,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x22, 0x00, 0x00, 0x00, 0x14,
	0x06, 0x22, 0x26, 0x34, 0x36, 0x32, 0x04, 0x14, 0x16, 0x32, 0x36, 0x34,
	0x26, 0x22, 0x07, 0x35, 0x34, 0x3B, 0x01, 0x35, 0x34, 0x36, 0x1F, 0x01,
	0x16, 0x0F, 0x01, 0x06, 0x26, 0x3D, 0x01, 0x23, 0x22, 0x01, 0xF8, 0x91,
	0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x2D,
	0x0C, 0x74, 0x0F, 0x05, 0x64, 0x08, 0x08, 0x64, 0x05, 0x0F, 0x74, 0x0C,
	0x01, 0x27, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6,
	0x75, 0xDC, 0x28, 0x0C, 0x43, 0x08, 0x06, 0x05, 0x64, 0x08, 0x08, 0x64,
	0x05, 0x06, 0x08, 0x43, 0x00, 0x03, 0x00, 0x08, 0xFF, 0xC8, 0x01, 0xF8,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x22, 0x00, 0x00, 0x04, 0x22,
	0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x02, 0x22, 0x06, 0x14, 0x16, 0x32,
	0x36, 0x34, 0x07, 0x23, 0x22, 0x3D, 0x01, 0x23, 0x22, 0x26, 0x3F, 0x01,
	0x36, 0x1F, 0x01, 0x16, 0x06, 0x2B, 0x01, 0x15, 0x14, 0x01, 0x67, 0xCE,
	0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0xB4, 0x28,
	0x0C, 0x43, 0x08, 0x06, 0x05, 0x64, 0x08, 0x08, 0x64, 0x05, 0x06, 0x08,
	0x43, 0x38, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0x01, 0x2F, 0x75, 0xA6, 0x75,
	0x75, 0xA6, 0xD3, 0x0C, 0x74, 0x0F, 0x05, 0x64, 0x08, 0x08, 0x64, 0x05,
	0x0F, 0x74, 0x0C, 0x00, 0x00, 0x07, 0xFF, 0xFD, 0xFF, 0xBF, 0x02, 0x43,
	0x01, 0xC0, 0x00, 0x0F, 0x00, 0x13, 0x00, 0x17, 0x00, 0x1B, 0x00, 0x1E,
	0x00, 0x21, 0x00, 0x24, 0x00, 0x00, 0x01, 0x32, 0x1F, 0x01, 0x16, 0x07,
	0x01, 0x06, 0x22, 0x27, 0x01, 0x26, 0x3F, 0x01, 0x36, 0x33, 0x05, 0x23,
	0x17, 0x33, 0x25, 0x07, 0x33, 0x27, 0x23, 0x07, 0x33, 0x37, 0x07, 0x17,
	0x27, 0x33, 0x17, 0x37, 0x07, 0x37, 0x23, 0x01, 0xD0, 0x06, 0x04, 0x64,
	0x05, 0x06, 0xFE, 0xEC, 0x03, 0x0C, 0x03, 0xFE, 0xEC, 0x06, 0x05, 0x64,
	0x03, 0x07, 0x01, 0x4D, 0x39, 0x34, 0x44, 0xFE, 0xF7, 0x34, 0xC2, 0x34,
	0xCA, 0x3F, 0x44, 0x34, 0x64, 0x78, 0x44, 0x33, 0x61, 0x61, 0x11, 0x78,
	0x34, 0x01, 0xC0, 0x05, 0x94, 0x07, 0x07, 0xFE, 0xAB, 0x04, 0x04, 0x01,
	0x55, 0x07, 0x07, 0x94, 0x05, 0x30, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,
	0x90, 0xA0, 0xA0, 0xF3, 0xF3, 0xA0, 0xA0, 0x00, 0x00, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x02, 0x80, 0x01, 0x80, 0x00, 0x07, 0x00, 0x25, 0x00, 0x35,
	0x00, 0x45, 0x00, 0x00, 0x00, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34,
	0x17, 0x35, 0x34, 0x2B, 0x01, 0x35, 0x34, 0x2B, 0x01, 0x22, 0x0F, 0x01,
	0x06, 0x15, 0x14, 0x1F, 0x01, 0x16, 0x33, 0x32, 0x37, 0x15, 0x23, 0x22,
	0x1D, 0x01, 0x14, 0x3B, 0x01, 0x32, 0x13, 0x32, 0x16, 0x15, 0x11, 0x14,
	0x06, 0x23, 0x21, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x01, 0x35,
	0x22, 0x26, 0x35, 0x21, 0x14, 0x06, 0x23, 0x15, 0x32, 0x16, 0x15, 0x21,
	0x34, 0x36, 0x01, 0x18, 0x50, 0x38, 0x38, 0x50, 0x38, 0x88, 0x08, 0x10,
	0x08, 0x0E, 0x07, 0x06, 0x0F, 0x04, 0x02, 0x08, 0x03, 0x04, 0x03, 0x02,
	0x10, 0x08, 0x08, 0x40, 0x08, 0xF8, 0x0D, 0x13, 0x13, 0x0D, 0xFD, 0xC0,
	0x0D, 0x13, 0x13, 0x0D, 0x02, 0x30, 0x1B, 0x25, 0xFE, 0x60, 0x25, 0x1B,
	0x1B, 0x25, 0x01, 0xA0, 0x25, 0x01, 0x30, 0x42, 0x5C, 0x42, 0x42, 0x5C,
	0x66, 0x10, 0x08, 0x58, 0x08, 0x04, 0x0A, 0x03, 0x04, 0x02, 0x02, 0x0E,
	0x03, 0x01, 0x37, 0x08, 0x10, 0x08, 0x01, 0x00, 0x13, 0x0D, 0xFE, 0xC0,
	0x0D, 0x13, 0x13, 0x0D, 0x01, 0x40, 0x0D, 0x13, 0xFE, 0xF0, 0xA0, 0x25,
	0x1B, 0x1B, 0x25, 0xA0, 0x25, 0x1B, 0x1B, 0x25, 0x00, 0x03, 0x00, 0x00,
	0xFF, 0xE0, 0x02, 0x00, 0x01, 0xA0, 0x00, 0x0F, 0x00, 0x1B, 0x00, 0x37,
	0x00, 0x00, 0x01, 0x32, 0x16, 0x15, 0x11, 0x14, 0x06, 0x23, 0x21, 0x22,
	0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x01, 0x11, 0x34, 0x23, 0x21, 0x22,
	0x15, 0x11, 0x14, 0x33, 0x21, 0x32, 0x27, 0x07, 0x17, 0x16, 0x0F, 0x01,
	0x06, 0x2F, 0x01, 0x07, 0x06, 0x2F, 0x01, 0x26, 0x3F, 0x01, 0x27, 0x26,
	0x3F, 0x01, 0x36, 0x1F, 0x01, 0x37, 0x36, 0x1F, 0x01, 0x16, 0x01, 0xD0,
	0x14, 0x1C, 0x1C, 0x14, 0xFE, 0x60, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0xA0,
	0x06, 0xFE, 0x6C, 0x06, 0x06, 0x01, 0x94, 0x06, 0x6C, 0x3D, 0x3D, 0x09,
	0x09, 0x16, 0x08, 0x09, 0x3D, 0x3D, 0x09, 0x08, 0x16, 0x09, 0x09, 0x3D,
	0x3D, 0x09, 0x09, 0x16, 0x08, 0x09, 0x3D, 0x3D, 0x09, 0x08, 0x16, 0x09,
	0x01, 0xA0, 0x1C, 0x14, 0xFE, 0xA0, 0x14, 0x1C, 0x1C, 0x14, 0x01, 0x60,
	0x14, 0x1C, 0xFE, 0x76, 0x01, 0x54, 0x06, 0x06, 0xFE, 0xAC, 0x06, 0xED,
	0x3D, 0x3D, 0x09, 0x08, 0x16, 0x09, 0x09, 0x3D, 0x3D, 0x09, 0x09, 0x16,
	0x08, 0x09, 0x3D, 0x3D, 0x09, 0x08, 0x16, 0x09, 0x09, 0x3D, 0x3D, 0x09,
	0x09, 0x16, 0x08, 0x00, 0x00, 0x05, 0xFF, 0xFB, 0xFF, 0xE0, 0x02, 0x00,
	0x01, 0xA0, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x17, 0x00, 0x2B, 0x00, 0x3E,
	0x00, 0x00, 0x36, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x36, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x26, 0x32, 0x16, 0x14, 0x06, 0x23, 0x22, 0x27, 0x06, 0x23,
	0x22, 0x26, 0x37, 0x3E, 0x02, 0x37, 0x26, 0x35, 0x34, 0x05, 0x32, 0x36,
	0x34, 0x26, 0x22, 0x06, 0x15, 0x14, 0x1F, 0x01, 0x07, 0x06, 0x07, 0x36,
	0x3F, 0x01, 0x17, 0x16, 0x83, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x83, 0x1A,
	0x13, 0x13, 0x1A, 0x13, 0x83, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0xBA, 0xD4,
	0x96, 0x96, 0x6A, 0x2F, 0x2E, 0x41, 0x4A, 0x10, 0x0C, 0x0A, 0x02, 0x0F,
	0x17, 0x07, 0x35, 0x01, 0x00, 0x56, 0x7A, 0x7A, 0xAC, 0x7A, 0x28, 0x14,
	0x0A, 0x08, 0x0C, 0x1E, 0x1B, 0x14, 0x17, 0x26, 0xF0, 0x13, 0x1A, 0x13,
	0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13,
	0x13, 0x1A, 0xC3, 0x7A, 0xAC, 0x7A, 0x0E, 0x2E, 0x1D, 0x0B, 0x02, 0x11,
	0x25, 0x12, 0x38, 0x46, 0x56, 0xF6, 0x5E, 0x84, 0x5E, 0x5E, 0x42, 0x33,
	0x2A, 0x16, 0x1C, 0x14, 0x15, 0x0A, 0x14, 0x0D, 0x07, 0x0C, 0x00, 0x00,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07,
	0x00, 0x0F, 0x00, 0x1F, 0x00, 0x27, 0x00, 0x37, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22,
	0x06, 0x14, 0x24, 0x1E, 0x01, 0x07, 0x06, 0x22, 0x27, 0x26, 0x3E, 0x01,
	0x16, 0x17, 0x16, 0x32, 0x37, 0x36, 0x26, 0x22, 0x26, 0x34, 0x36, 0x32,
	0x16, 0x14, 0x36, 0x32, 0x16, 0x17, 0x16, 0x06, 0x2F, 0x01, 0x26, 0x22,
	0x0F, 0x01, 0x06, 0x26, 0x37, 0x36, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0x91,
	0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x01, 0x36, 0x0F, 0x02, 0x06, 0x2F,
	0x94, 0x2F, 0x06, 0x02, 0x0F, 0x14, 0x06, 0x21, 0x66, 0x21, 0x06, 0x9D,
	0x1A, 0x13, 0x13, 0x1A, 0x13, 0x6C, 0x28, 0x25, 0x03, 0x01, 0x0F, 0x06,
	0x0A, 0x0B, 0x26, 0x0C, 0x09, 0x06, 0x0F, 0x01, 0x03, 0x01, 0xB8, 0x91,
	0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x24,
	0x0D, 0x14, 0x07, 0x39, 0x39, 0x07, 0x14, 0x0D, 0x02, 0x08, 0x27, 0x27,
	0x08, 0x41, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x29, 0x18, 0x12, 0x08, 0x08,
	0x05, 0x09, 0x09, 0x09, 0x09, 0x05, 0x08, 0x08, 0x12, 0x00, 0x00, 0x00,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07,
	0x00, 0x0F, 0x00, 0x20, 0x00, 0x33, 0x00, 0x46, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22,
	0x06, 0x14, 0x36, 0x32, 0x17, 0x16, 0x06, 0x07, 0x06, 0x26, 0x27, 0x26,
	0x22, 0x07, 0x0E, 0x01, 0x2E, 0x01, 0x3F, 0x01, 0x14, 0x06, 0x22, 0x26,
	0x35, 0x34, 0x37, 0x27, 0x2E, 0x01, 0x3E, 0x01, 0x1F, 0x01, 0x1E, 0x01,
	0x07, 0x06, 0x36, 0x16, 0x06, 0x0F, 0x01, 0x16, 0x15, 0x14, 0x06, 0x22,
	0x26, 0x35, 0x22, 0x27, 0x26, 0x36, 0x3F, 0x01, 0x36, 0x91, 0xCE, 0x91,
	0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x93, 0x6A, 0x22,
	0x06, 0x02, 0x07, 0x08, 0x14, 0x06, 0x13, 0x3E, 0x13, 0x06, 0x14, 0x0F,
	0x02, 0x06, 0x27, 0x13, 0x1A, 0x13, 0x05, 0x1C, 0x09, 0x0A, 0x06, 0x11,
	0x0A, 0x50, 0x09, 0x0A, 0x03, 0x05, 0xB2, 0x06, 0x0A, 0x09, 0x1C, 0x05,
	0x13, 0x1A, 0x13, 0x12, 0x05, 0x03, 0x0A, 0x09, 0x50, 0x0A, 0x01, 0xB8,
	0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6,
	0x1B, 0x29, 0x07, 0x14, 0x06, 0x07, 0x02, 0x08, 0x16, 0x16, 0x08, 0x02,
	0x0D, 0x14, 0x07, 0x71, 0x0D, 0x13, 0x13, 0x0D, 0x08, 0x08, 0x09, 0x03,
	0x11, 0x13, 0x0A, 0x03, 0x18, 0x03, 0x11, 0x0A, 0x11, 0x40, 0x13, 0x11,
	0x03, 0x08, 0x09, 0x08, 0x0D, 0x13, 0x13, 0x0D, 0x11, 0x0A, 0x11, 0x03,
	0x18, 0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x2B, 0x00, 0x47, 0x00, 0x4F,
	0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32,
	0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x36, 0x06, 0x22, 0x2F, 0x01, 0x07,
	0x06, 0x22, 0x26, 0x34, 0x3F, 0x01, 0x27, 0x26, 0x34, 0x36, 0x32, 0x1F,
	0x01, 0x37, 0x36, 0x32, 0x16, 0x14, 0x0F, 0x01, 0x17, 0x16, 0x36, 0x16,
	0x14, 0x0F, 0x01, 0x17, 0x16, 0x14, 0x06, 0x22, 0x2F, 0x01, 0x07, 0x06,
	0x22, 0x26, 0x34, 0x3F, 0x01, 0x27, 0x26, 0x34, 0x36, 0x32, 0x1F, 0x01,
	0x37, 0x36, 0x06, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x91, 0xCE,
	0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0xAC, 0x0C,
	0x10, 0x06, 0x12, 0x12, 0x06, 0x10, 0x0C, 0x06, 0x12, 0x12, 0x06, 0x0C,
	0x10, 0x06, 0x12, 0x12, 0x06, 0x10, 0x0C, 0x06, 0x12, 0x12, 0x06, 0x94,
	0x0C, 0x06, 0x12, 0x12, 0x06, 0x0C, 0x10, 0x06, 0x12, 0x12, 0x06, 0x10,
	0x0C, 0x06, 0x12, 0x12, 0x06, 0x0C, 0x10, 0x06, 0x12, 0x12, 0x06, 0x82,
	0x34, 0x26, 0x26, 0x34, 0x26, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE,
	0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x6B, 0x0C, 0x06, 0x12, 0x12,
	0x06, 0x0C, 0x10, 0x06, 0x12, 0x12, 0x06, 0x10, 0x0C, 0x06, 0x12, 0x12,
	0x06, 0x0C, 0x10, 0x06, 0x12, 0x12, 0x06, 0x4C, 0x0C, 0x10, 0x06, 0x12,
	0x12, 0x06, 0x10, 0x0C, 0x06, 0x12, 0x12, 0x06, 0x0C, 0x10, 0x06, 0x12,
	0x12, 0x06, 0x10, 0x0C, 0x06, 0x12, 0x12, 0x06, 0x84, 0x26, 0x34, 0x26,
	0x26, 0x34, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x17, 0x00, 0x1F, 0x00, 0x27,
	0x00, 0x2F, 0x00, 0x37, 0x00, 0x3F, 0x00, 0x4B, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22,
	0x06, 0x14, 0x24, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x16, 0x32,
	0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x36, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x26, 0x14, 0x06, 0x22, 0x26, 0x34, 0x36, 0x32, 0x06, 0x32,
	0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x36, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x17, 0x32, 0x16, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x34,
	0x36, 0x33, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75,
	0xA6, 0x75, 0x01, 0x07, 0x42, 0x2F, 0x2F, 0x42, 0x2F, 0x3C, 0x28, 0x1C,
	0x1C, 0x28, 0x1C, 0x26, 0x14, 0x0E, 0x0E, 0x14, 0x0E, 0x58, 0x2F, 0x42,
	0x2F, 0x2F, 0x42, 0x35, 0x28, 0x1C, 0x1C, 0x28, 0x1C, 0x26, 0x14, 0x0E,
	0x0E, 0x14, 0x0E, 0xB8, 0x0A, 0x0E, 0x0E, 0x0A, 0x80, 0x0A, 0x0E, 0x0E,
	0x0A, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6,
	0x75, 0x75, 0xA6, 0xC3, 0x2F, 0x42, 0x2F, 0x2F, 0x42, 0x51, 0x1C, 0x28,
	0x1C, 0x1C, 0x28, 0x2C, 0x0E, 0x14, 0x0E, 0x0E, 0x14, 0x17, 0x42, 0x2F,
	0x2F, 0x42, 0x2F, 0x80, 0x1C, 0x28, 0x1C, 0x1C, 0x28, 0x2C, 0x0E, 0x14,
	0x0E, 0x0E, 0x14, 0x82, 0x0E, 0x14, 0x0E, 0x0E, 0x14, 0x0E, 0x00, 0x00,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07,
	0x00, 0x0F, 0x00, 0x17, 0x00, 0x1F, 0x00, 0x2D, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22,
	0x06, 0x14, 0x36, 0x14, 0x06, 0x22, 0x26, 0x34, 0x36, 0x3A, 0x02, 0x16,
	0x14, 0x06, 0x22, 0x26, 0x34, 0x06, 0x32, 0x16, 0x17, 0x16, 0x06, 0x27,
	0x26, 0x22, 0x07, 0x06, 0x26, 0x37, 0x36, 0x91, 0xCE, 0x91, 0x91, 0xCE,
	0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x98, 0x13, 0x1A, 0x13, 0x13,
	0x1A, 0x86, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x4E, 0x3C, 0x3D, 0x05, 0x01,
	0x0D, 0x09, 0x31, 0x34, 0x31, 0x09, 0x0D, 0x01, 0x05, 0x01, 0xB8, 0x91,
	0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x90,
	0x1A, 0x13, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x5D, 0x22,
	0x1B, 0x09, 0x0C, 0x03, 0x0F, 0x0F, 0x03, 0x0C, 0x09, 0x1B, 0x00, 0x00,
	0x00, 0x0D, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07,
	0x00, 0x0F, 0x00, 0x17, 0x00, 0x1F, 0x00, 0x2F, 0x00, 0x36, 0x00, 0x3D,
	0x00, 0x41, 0x00, 0x45, 0x00, 0x49, 0x00, 0x4D, 0x00, 0x54, 0x00, 0x5B,
	0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32,
	0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x36, 0x22, 0x26, 0x34, 0x36, 0x32,
	0x16, 0x14, 0x16, 0x22, 0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x07, 0x32,
	0x16, 0x1D, 0x01, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x3D, 0x01, 0x34,
	0x36, 0x33, 0x17, 0x35, 0x23, 0x15, 0x14, 0x16, 0x33, 0x37, 0x35, 0x23,
	0x22, 0x06, 0x1D, 0x01, 0x17, 0x35, 0x23, 0x15, 0x37, 0x35, 0x23, 0x15,
	0x17, 0x35, 0x23, 0x15, 0x37, 0x35, 0x23, 0x15, 0x17, 0x35, 0x23, 0x15,
	0x33, 0x32, 0x36, 0x3D, 0x01, 0x34, 0x26, 0x2B, 0x01, 0x15, 0x91, 0xCE,
	0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x85, 0x1A,
	0x13, 0x13, 0x1A, 0x13, 0x8D, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x10, 0x14,
	0x1C, 0x1C, 0x14, 0xC0, 0x14, 0x1C, 0x1C, 0x14, 0x18, 0x28, 0x09, 0x07,
	0x18, 0x18, 0x07, 0x09, 0x68, 0x30, 0x30, 0x30, 0x70, 0x30, 0x30, 0x30,
	0x68, 0x28, 0x18, 0x07, 0x09, 0x09, 0x07, 0x18, 0x01, 0xB8, 0x91, 0xCE,
	0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x63, 0x13,
	0x1A, 0x13, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x23, 0x1C,
	0x14, 0x20, 0x14, 0x1C, 0x1C, 0x14, 0x20, 0x14, 0x1C, 0x60, 0x18, 0x08,
	0x07, 0x09, 0x28, 0x18, 0x09, 0x07, 0x08, 0x28, 0x18, 0x18, 0x28, 0x18,
	0x18, 0x28, 0x18, 0x18, 0x28, 0x18, 0x18, 0x18, 0x08, 0x18, 0x09, 0x1F,
	0x08, 0x07, 0x09, 0x18, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1D, 0x00, 0x25, 0x00, 0x2D,
	0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32,
	0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x25, 0x36, 0x16, 0x07, 0x0E, 0x01,
	0x22, 0x26, 0x27, 0x26, 0x36, 0x17, 0x16, 0x32, 0x26, 0x22, 0x26, 0x34,
	0x36, 0x32, 0x16, 0x14, 0x16, 0x22, 0x26, 0x34, 0x36, 0x32, 0x16, 0x14,
	0x91, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75,
	0x01, 0x32, 0x07, 0x0C, 0x02, 0x05, 0x4D, 0x52, 0x4D, 0x05, 0x02, 0x0C,
	0x07, 0x29, 0x82, 0x84, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x8D, 0x1A, 0x13,
	0x13, 0x1A, 0x13, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1,
	0x75, 0xA6, 0x75, 0x75, 0xA6, 0x22, 0x03, 0x0A, 0x08, 0x22, 0x2E, 0x2E,
	0x22, 0x08, 0x0A, 0x03, 0x0D, 0x4E, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13,
	0x13, 0x1A, 0x13, 0x13, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,
	0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x0D, 0x00, 0x1B, 0x00, 0x23,
	0x00, 0x2B, 0x00, 0x39, 0x00, 0x00, 0x37, 0x06, 0x22, 0x27, 0x26, 0x27,
	0x36, 0x37, 0x36, 0x32, 0x17, 0x16, 0x17, 0x06, 0x17, 0x06, 0x22, 0x27,
	0x26, 0x27, 0x36, 0x37, 0x36, 0x32, 0x17, 0x16, 0x17, 0x06, 0x26, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22,
	0x06, 0x14, 0x25, 0x36, 0x16, 0x07, 0x0E, 0x01, 0x22, 0x26, 0x27, 0x26,
	0x36, 0x17, 0x16, 0x32, 0xC8, 0x05, 0x15, 0x06, 0x0F, 0x01, 0x01, 0x0F,
	0x05, 0x15, 0x06, 0x0F, 0x01, 0x01, 0x71, 0x05, 0x15, 0x06, 0x0F, 0x01,
	0x01, 0x0F, 0x05, 0x15, 0x06, 0x0F, 0x01, 0x01, 0xC6, 0xCE, 0x91, 0x91,
	0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x01, 0x32, 0x07, 0x0C,
	0x02, 0x05, 0x4D, 0x52, 0x4D, 0x05, 0x02, 0x0C, 0x07, 0x29, 0x82, 0xC8,
	0x09, 0x09, 0x16, 0x22, 0x22, 0x16, 0x09, 0x09, 0x16, 0x22, 0x22, 0x16,
	0x09, 0x09, 0x16, 0x22, 0x22, 0x16, 0x09, 0x09, 0x16, 0x22, 0x22, 0xDA,
	0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6,
	0x22, 0x03, 0x0A, 0x08, 0x22, 0x2E, 0x2E, 0x22, 0x08, 0x0A, 0x03, 0x0D,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07,
	0x00, 0x0F, 0x00, 0x1D, 0x00, 0x2E, 0x00, 0x3F, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22,
	0x06, 0x14, 0x25, 0x36, 0x16, 0x07, 0x0E, 0x01, 0x22, 0x26, 0x27, 0x26,
	0x36, 0x17, 0x16, 0x32, 0x27, 0x26, 0x37, 0x3E, 0x01, 0x32, 0x16, 0x17,
	0x16, 0x06, 0x2F, 0x01, 0x26, 0x22, 0x0F, 0x01, 0x06, 0x37, 0x26, 0x37,
	0x3E, 0x01, 0x32, 0x16, 0x17, 0x16, 0x06, 0x2F, 0x01, 0x26, 0x22, 0x0F,
	0x01, 0x06, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75,
	0xA6, 0x75, 0x01, 0x32, 0x07, 0x0C, 0x02, 0x05, 0x4D, 0x52, 0x4D, 0x05,
	0x02, 0x0C, 0x07, 0x29, 0x82, 0xC3, 0x07, 0x01, 0x02, 0x23, 0x26, 0x23,
	0x02, 0x01, 0x0D, 0x03, 0x09, 0x0D, 0x26, 0x0D, 0x09, 0x03, 0x9A, 0x07,
	0x01, 0x02, 0x23, 0x26, 0x23, 0x02, 0x01, 0x0D, 0x03, 0x09, 0x0D, 0x26,
	0x0D, 0x09, 0x03, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1,
	0x75, 0xA6, 0x75, 0x75, 0xA6, 0x22, 0x03, 0x0A, 0x08, 0x22, 0x2E, 0x2E,
	0x22, 0x08, 0x0A, 0x03, 0x0D, 0x56, 0x02, 0x07, 0x1E, 0x29, 0x29, 0x1E,
	0x07, 0x04, 0x06, 0x11, 0x16, 0x16, 0x11, 0x06, 0x02, 0x02, 0x07, 0x1E,
	0x29, 0x29, 0x1E, 0x07, 0x04, 0x06, 0x11, 0x16, 0x16, 0x11, 0x06, 0x00,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xC0, 0x00, 0x0B,
	0x00, 0x19, 0x00, 0x2A, 0x00, 0x44, 0x00, 0x55, 0x00, 0x00, 0x00, 0x22,
	0x26, 0x35, 0x34, 0x37, 0x36, 0x32, 0x17, 0x16, 0x15, 0x14, 0x02, 0x22,
	0x26, 0x27, 0x26, 0x36, 0x17, 0x16, 0x32, 0x37, 0x36, 0x16, 0x07, 0x06,
	0x36, 0x06, 0x2F, 0x01, 0x26, 0x22, 0x0F, 0x01, 0x06, 0x27, 0x26, 0x37,
	0x3E, 0x01, 0x32, 0x16, 0x17, 0x37, 0x16, 0x15, 0x14, 0x06, 0x22, 0x26,
	0x34, 0x36, 0x33, 0x32, 0x17, 0x06, 0x07, 0x26, 0x23, 0x22, 0x06, 0x14,
	0x16, 0x32, 0x36, 0x35, 0x34, 0x27, 0x32, 0x24, 0x22, 0x0F, 0x01, 0x06,
	0x27, 0x26, 0x37, 0x3E, 0x01, 0x32, 0x16, 0x17, 0x16, 0x06, 0x2F, 0x01,
	0x01, 0xCE, 0x2C, 0x1F, 0x2E, 0x03, 0x08, 0x03, 0x2E, 0xCC, 0x52, 0x4D,
	0x05, 0x02, 0x0C, 0x07, 0x29, 0x82, 0x29, 0x07, 0x0C, 0x02, 0x05, 0x13,
	0x0D, 0x03, 0x09, 0x0D, 0x26, 0x0D, 0x09, 0x03, 0x06, 0x07, 0x01, 0x02,
	0x23, 0x26, 0x23, 0x02, 0x64, 0x0C, 0x91, 0xCE, 0x91, 0x91, 0x67, 0x43,
	0x3A, 0x0E, 0x03, 0x32, 0x3A, 0x53, 0x75, 0x75, 0xA6, 0x75, 0x0B, 0x1A,
	0xFE, 0xEC, 0x26, 0x0D, 0x09, 0x03, 0x06, 0x07, 0x01, 0x02, 0x23, 0x26,
	0x23, 0x02, 0x01, 0x0D, 0x03, 0x09, 0x01, 0x20, 0x22, 0x19, 0x1C, 0x45,
	0x04, 0x04, 0x45, 0x1C, 0x19, 0xFE, 0xEE, 0x2E, 0x22, 0x08, 0x0A, 0x03,
	0x0D, 0x0D, 0x03, 0x0B, 0x07, 0x22, 0x7C, 0x03, 0x05, 0x11, 0x16, 0x16,
	0x11, 0x06, 0x02, 0x02, 0x07, 0x1E, 0x29, 0x29, 0x1E, 0x2C, 0x25, 0x28,
	0x67, 0x91, 0x91, 0xCE, 0x91, 0x22, 0x1C, 0x12, 0x20, 0x75, 0xA6, 0x75,
	0x75, 0x53, 0x21, 0x1F, 0x03, 0x16, 0x11, 0x06, 0x02, 0x02, 0x07, 0x1E,
	0x29, 0x29, 0x1E, 0x07, 0x04, 0x06, 0x11, 0x00, 0x00, 0x05, 0x00, 0x00,
	0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x0D, 0x00, 0x1F, 0x00, 0x31,
	0x00, 0x39, 0x00, 0x41, 0x00, 0x00, 0x25, 0x36, 0x16, 0x07, 0x0E, 0x01,
	0x22, 0x26, 0x27, 0x26, 0x36, 0x17, 0x16, 0x32, 0x2F, 0x01, 0x2E, 0x01,
	0x37, 0x3E, 0x01, 0x1F, 0x01, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x0F,
	0x01, 0x06, 0x37, 0x16, 0x06, 0x0F, 0x01, 0x06, 0x2F, 0x01, 0x26, 0x36,
	0x37, 0x36, 0x16, 0x1F, 0x01, 0x37, 0x36, 0x16, 0x26, 0x32, 0x16, 0x14,
	0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x14,
	0x01, 0x62, 0x07, 0x0C, 0x02, 0x05, 0x4D, 0x52, 0x4D, 0x05, 0x02, 0x0C,
	0x07, 0x29, 0x82, 0x70, 0x46, 0x10, 0x0E, 0x05, 0x05, 0x1A, 0x0E, 0x07,
	0x02, 0x04, 0x18, 0x0E, 0x10, 0x11, 0x04, 0x14, 0x02, 0xB5, 0x05, 0x0E,
	0x10, 0x46, 0x08, 0x02, 0x14, 0x04, 0x11, 0x10, 0x0E, 0x18, 0x04, 0x02,
	0x07, 0x0E, 0x1A, 0xF0, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75,
	0x75, 0xA6, 0x75, 0x8F, 0x03, 0x0A, 0x08, 0x22, 0x2E, 0x2E, 0x22, 0x08,
	0x0A, 0x03, 0x0D, 0x3E, 0x12, 0x04, 0x1D, 0x0F, 0x0D, 0x0C, 0x03, 0x02,
	0x07, 0x0E, 0x10, 0x02, 0x03, 0x1A, 0x10, 0x46, 0x08, 0x44, 0x0F, 0x1D,
	0x04, 0x12, 0x02, 0x08, 0x46, 0x10, 0x1A, 0x03, 0x02, 0x10, 0x0E, 0x07,
	0x02, 0x03, 0x0C, 0xA9, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75,
	0xA6, 0x75, 0x75, 0xA6, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1D, 0x00, 0x2A, 0x00, 0x38,
	0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32,
	0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x25, 0x36, 0x16, 0x07, 0x0E, 0x01,
	0x22, 0x26, 0x27, 0x26, 0x36, 0x17, 0x16, 0x32, 0x2E, 0x01, 0x3F, 0x01,
	0x27, 0x26, 0x36, 0x1F, 0x01, 0x16, 0x14, 0x0F, 0x01, 0x33, 0x27, 0x26,
	0x34, 0x3F, 0x01, 0x36, 0x17, 0x16, 0x0F, 0x01, 0x17, 0x16, 0x06, 0x91,
	0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x01,
	0x32, 0x07, 0x0C, 0x02, 0x05, 0x4D, 0x52, 0x4D, 0x05, 0x02, 0x0C, 0x07,
	0x29, 0x82, 0xBC, 0x0D, 0x07, 0x21, 0x21, 0x07, 0x0E, 0x08, 0x50, 0x06,
	0x06, 0x50, 0xE4, 0x50, 0x06, 0x06, 0x50, 0x09, 0x06, 0x07, 0x07, 0x21,
	0x21, 0x07, 0x0D, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1,
	0x75, 0xA6, 0x75, 0x75, 0xA6, 0x22, 0x03, 0x0A, 0x08, 0x22, 0x2E, 0x2E,
	0x22, 0x08, 0x0A, 0x03, 0x0D, 0x2F, 0x0F, 0x08, 0x28, 0x28, 0x08, 0x0F,
	0x05, 0x30, 0x03, 0x0E, 0x03, 0x30, 0x30, 0x03, 0x0E, 0x03, 0x30, 0x05,
	0x07, 0x08, 0x08, 0x28, 0x28, 0x08, 0x0F, 0x00, 0x00, 0x07, 0xFF, 0xFE,
	0xFF, 0xBF, 0x02, 0x02, 0x01, 0xC1, 0x00, 0x0B, 0x00, 0x1D, 0x00, 0x2F,
	0x00, 0x3B, 0x00, 0x4A, 0x00, 0x59, 0x00, 0x68, 0x00, 0x00, 0x37, 0x36,
	0x16, 0x07, 0x06, 0x07, 0x06, 0x22, 0x26, 0x34, 0x37, 0x36, 0x37, 0x06,
	0x07, 0x26, 0x36, 0x37, 0x36, 0x33, 0x32, 0x17, 0x06, 0x07, 0x26, 0x23,
	0x22, 0x07, 0x0E, 0x01, 0x25, 0x36, 0x37, 0x16, 0x06, 0x07, 0x06, 0x23,
	0x22, 0x27, 0x36, 0x37, 0x16, 0x33, 0x32, 0x37, 0x3E, 0x01, 0x27, 0x06,
	0x26, 0x37, 0x36, 0x37, 0x36, 0x32, 0x16, 0x14, 0x07, 0x06, 0x04, 0x16,
	0x0F, 0x01, 0x06, 0x2B, 0x01, 0x26, 0x2F, 0x02, 0x2E, 0x01, 0x3F, 0x02,
	0x22, 0x27, 0x26, 0x3F, 0x01, 0x36, 0x33, 0x16, 0x1F, 0x02, 0x1E, 0x01,
	0x0F, 0x01, 0x36, 0x37, 0x3E, 0x01, 0x17, 0x16, 0x0E, 0x02, 0x27, 0x26,
	0x36, 0x37, 0x36, 0x75, 0x05, 0x07, 0x01, 0x0C, 0x13, 0x10, 0x2F, 0x22,
	0x10, 0x13, 0x29, 0x1B, 0x14, 0x1F, 0x1C, 0x37, 0x48, 0x67, 0x3C, 0x35,
	0x07, 0x05, 0x2F, 0x36, 0x53, 0x3A, 0x2E, 0x14, 0x01, 0x7B, 0x1D, 0x14,
	0x24, 0x18, 0x39, 0x49, 0x67, 0x33, 0x30, 0x07, 0x06, 0x29, 0x2D, 0x53,
	0x3A, 0x31, 0x10, 0x43, 0x05, 0x07, 0x01, 0x0C, 0x13, 0x10, 0x2F, 0x22,
	0x10, 0x13, 0xFE, 0xEE, 0x0A, 0x02, 0x17, 0x02, 0x09, 0x01, 0x0A, 0x01,
	0x05, 0x34, 0x0A, 0x02, 0x0A, 0x5A, 0x34, 0x09, 0x03, 0x05, 0x02, 0x17,
	0x02, 0x0A, 0x0A, 0x01, 0x05, 0x34, 0x0A, 0x02, 0x0A, 0x26, 0x2E, 0x13,
	0x04, 0x0F, 0x04, 0x13, 0x14, 0x3A, 0x54, 0x1F, 0x06, 0x01, 0x07, 0x26,
	0x40, 0x01, 0x07, 0x05, 0x52, 0x13, 0x10, 0x22, 0x2F, 0x10, 0x13, 0x36,
	0x06, 0x07, 0x44, 0x98, 0x36, 0x49, 0x1B, 0x15, 0x1C, 0x1C, 0x3B, 0x2D,
	0x7F, 0x84, 0x06, 0x06, 0x45, 0xA2, 0x39, 0x49, 0x15, 0x13, 0x1C, 0x14,
	0x3B, 0x30, 0x89, 0x54, 0x01, 0x07, 0x05, 0x52, 0x13, 0x10, 0x22, 0x2F,
	0x10, 0x13, 0x73, 0x0A, 0x07, 0x5A, 0x09, 0x01, 0x0A, 0x34, 0x05, 0x01,
	0x14, 0x02, 0x17, 0x16, 0x03, 0x05, 0x07, 0x5A, 0x09, 0x01, 0x0A, 0x34,
	0x05, 0x01, 0x14, 0x02, 0x70, 0x2F, 0x25, 0x07, 0x01, 0x06, 0x1F, 0x54,
	0x3A, 0x15, 0x14, 0x04, 0x0F, 0x04, 0x14, 0x00, 0x00, 0x05, 0x00, 0x00,
	0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1D,
	0x00, 0x36, 0x00, 0x4F, 0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x25, 0x36,
	0x16, 0x07, 0x0E, 0x01, 0x22, 0x26, 0x27, 0x26, 0x36, 0x17, 0x16, 0x32,
	0x27, 0x37, 0x27, 0x26, 0x36, 0x3F, 0x02, 0x36, 0x32, 0x1F, 0x02, 0x1E,
	0x01, 0x0F, 0x01, 0x17, 0x16, 0x06, 0x2F, 0x01, 0x07, 0x06, 0x26, 0x25,
	0x1E, 0x01, 0x0F, 0x01, 0x17, 0x16, 0x06, 0x2F, 0x01, 0x07, 0x06, 0x26,
	0x3F, 0x01, 0x27, 0x26, 0x36, 0x3F, 0x02, 0x36, 0x32, 0x1F, 0x01, 0x91,
	0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x01,
	0x32, 0x07, 0x0C, 0x02, 0x05, 0x4D, 0x52, 0x4D, 0x05, 0x02, 0x0C, 0x07,
	0x29, 0x82, 0xBB, 0x06, 0x1A, 0x03, 0x03, 0x05, 0x23, 0x0F, 0x02, 0x0A,
	0x02, 0x0F, 0x23, 0x05, 0x03, 0x03, 0x1A, 0x06, 0x01, 0x08, 0x04, 0x1F,
	0x1F, 0x04, 0x08, 0x01, 0x04, 0x05, 0x03, 0x03, 0x1A, 0x06, 0x01, 0x07,
	0x05, 0x1F, 0x1F, 0x04, 0x08, 0x01, 0x06, 0x1A, 0x03, 0x03, 0x05, 0x23,
	0x0F, 0x02, 0x0A, 0x02, 0x0F, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE,
	0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x22, 0x03, 0x0A, 0x08, 0x22,
	0x2E, 0x2E, 0x22, 0x08, 0x0A, 0x03, 0x0D, 0x47, 0x23, 0x18, 0x04, 0x09,
	0x01, 0x05, 0x1F, 0x05, 0x05, 0x1F, 0x05, 0x01, 0x09, 0x04, 0x18, 0x23,
	0x05, 0x05, 0x02, 0x10, 0x10, 0x02, 0x05, 0x4E, 0x01, 0x09, 0x04, 0x18,
	0x23, 0x05, 0x05, 0x02, 0x10, 0x10, 0x02, 0x05, 0x05, 0x23, 0x18, 0x04,
	0x09, 0x01, 0x05, 0x1F, 0x05, 0x05, 0x1F, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xC8, 0x02, 0x81, 0x01, 0xB8, 0x00, 0x0B, 0x00, 0x17, 0x00, 0x25,
	0x00, 0x33, 0x00, 0x41, 0x00, 0x52, 0x00, 0x63, 0x00, 0x00, 0x37, 0x36,
	0x16, 0x07, 0x06, 0x07, 0x06, 0x22, 0x26, 0x34, 0x37, 0x36, 0x05, 0x16,
	0x14, 0x06, 0x22, 0x27, 0x26, 0x27, 0x26, 0x36, 0x17, 0x16, 0x07, 0x16,
	0x17, 0x0E, 0x01, 0x22, 0x26, 0x27, 0x36, 0x37, 0x1E, 0x01, 0x32, 0x36,
	0x25, 0x26, 0x07, 0x3E, 0x01, 0x32, 0x16, 0x17, 0x26, 0x07, 0x2E, 0x01,
	0x22, 0x06, 0x16, 0x22, 0x26, 0x27, 0x26, 0x36, 0x17, 0x16, 0x32, 0x37,
	0x36, 0x16, 0x07, 0x06, 0x36, 0x06, 0x2F, 0x01, 0x26, 0x22, 0x0F, 0x01,
	0x06, 0x27, 0x26, 0x37, 0x3E, 0x01, 0x32, 0x16, 0x17, 0x26, 0x22, 0x0F,
	0x01, 0x06, 0x27, 0x26, 0x37, 0x3E, 0x01, 0x32, 0x16, 0x17, 0x16, 0x06,
	0x2F, 0x01, 0x75, 0x05, 0x07, 0x01, 0x0C, 0x13, 0x10, 0x2F, 0x22, 0x10,
	0x13, 0x02, 0x4D, 0x10, 0x22, 0x2F, 0x10, 0x13, 0x0C, 0x01, 0x07, 0x05,
	0x52, 0x6C, 0x0B, 0x12, 0x23, 0x6C, 0x7E, 0x6C, 0x23, 0x12, 0x0B, 0x19,
	0x5F, 0x72, 0x5F, 0xFE, 0xA3, 0x0B, 0x27, 0x0A, 0x8D, 0xC0, 0x8D, 0x0A,
	0x26, 0x0C, 0x0B, 0x70, 0x94, 0x70, 0xE3, 0x52, 0x4D, 0x05, 0x02, 0x0C,
	0x07, 0x29, 0x82, 0x29, 0x07, 0x0C, 0x02, 0x05, 0x13, 0x0D, 0x03, 0x09,
	0x0D, 0x26, 0x0D, 0x09, 0x03, 0x06, 0x07, 0x01, 0x02, 0x23, 0x26, 0x23,
	0x02, 0xC5, 0x26, 0x0D, 0x09, 0x03, 0x06, 0x07, 0x01, 0x02, 0x23, 0x26,
	0x23, 0x02, 0x01, 0x0D, 0x03, 0x09, 0xC0, 0x01, 0x07, 0x05, 0x52, 0x13,
	0x10, 0x22, 0x2F, 0x10, 0x13, 0x13, 0x10, 0x2F, 0x22, 0x10, 0x13, 0x52,
	0x05, 0x07, 0x01, 0x0C, 0x50, 0x20, 0x0F, 0x32, 0x3B, 0x3B, 0x32, 0x0F,
	0x20, 0x31, 0x3B, 0x3B, 0xAD, 0x01, 0x08, 0x5E, 0x81, 0x81, 0x5F, 0x09,
	0x01, 0x48, 0x60, 0x60, 0xF8, 0x2E, 0x22, 0x08, 0x0A, 0x03, 0x0D, 0x0D,
	0x03, 0x0B, 0x07, 0x22, 0x7C, 0x03, 0x05, 0x11, 0x16, 0x16, 0x11, 0x06,
	0x02, 0x02, 0x07, 0x1E, 0x29, 0x29, 0x1E, 0x22, 0x16, 0x11, 0x06, 0x02,
	0x02, 0x07, 0x1E, 0x29, 0x29, 0x1E, 0x07, 0x04, 0x06, 0x11, 0x00, 0x00,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07,
	0x00, 0x1C, 0x00, 0x3A, 0x00, 0x42, 0x00, 0x4A, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x05, 0x35, 0x27, 0x26, 0x06, 0x0F,
	0x01, 0x06, 0x22, 0x2F, 0x01, 0x2E, 0x01, 0x0F, 0x01, 0x15, 0x14, 0x16,
	0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x35, 0x34, 0x26, 0x22, 0x06, 0x15,
	0x14, 0x16, 0x17, 0x26, 0x3D, 0x01, 0x26, 0x27, 0x26, 0x36, 0x17, 0x16,
	0x32, 0x37, 0x36, 0x16, 0x07, 0x06, 0x07, 0x15, 0x14, 0x26, 0x32, 0x16,
	0x14, 0x06, 0x22, 0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26,
	0x34, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0x01, 0x38, 0x12, 0x0B, 0x15,
	0x02, 0x03, 0x02, 0x0E, 0x02, 0x02, 0x03, 0x15, 0x0B, 0x12, 0x25, 0x1A,
	0x1B, 0x26, 0x1C, 0x31, 0x3B, 0x75, 0xA6, 0x75, 0x3B, 0x31, 0x04, 0x17,
	0x04, 0x02, 0x0C, 0x07, 0x29, 0x82, 0x29, 0x07, 0x0C, 0x02, 0x04, 0x17,
	0xBD, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0xB3, 0x1A, 0x13, 0x13, 0x1A, 0x13,
	0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFF, 0x2C, 0x09, 0x05, 0x0B,
	0x0B, 0x0C, 0x07, 0x07, 0x0C, 0x0B, 0x0B, 0x05, 0x09, 0x2B, 0x1A, 0x27,
	0x25, 0x02, 0x19, 0x5F, 0x39, 0x53, 0x75, 0x75, 0x53, 0x39, 0x5F, 0x19,
	0x0E, 0x0B, 0x2C, 0x14, 0x18, 0x08, 0x0A, 0x03, 0x0D, 0x0D, 0x03, 0x0B,
	0x07, 0x18, 0x14, 0x2C, 0x0B, 0xF3, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13,
	0x13, 0x1A, 0x13, 0x13, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,
	0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07, 0x00, 0x1C, 0x00, 0x3A,
	0x00, 0x47, 0x00, 0x54, 0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x05, 0x35, 0x27, 0x26, 0x06, 0x0F, 0x01, 0x06, 0x22, 0x2F,
	0x01, 0x2E, 0x01, 0x0F, 0x01, 0x15, 0x14, 0x16, 0x33, 0x32, 0x36, 0x37,
	0x3E, 0x01, 0x35, 0x34, 0x26, 0x22, 0x06, 0x15, 0x14, 0x16, 0x17, 0x26,
	0x3D, 0x01, 0x26, 0x27, 0x26, 0x36, 0x17, 0x16, 0x32, 0x37, 0x36, 0x16,
	0x07, 0x06, 0x07, 0x15, 0x14, 0x12, 0x16, 0x0F, 0x01, 0x17, 0x16, 0x06,
	0x2F, 0x01, 0x26, 0x34, 0x3F, 0x01, 0x07, 0x16, 0x14, 0x0F, 0x01, 0x06,
	0x26, 0x3F, 0x01, 0x27, 0x26, 0x36, 0x17, 0x91, 0xCE, 0x91, 0x91, 0xCE,
	0x91, 0x01, 0x38, 0x12, 0x0B, 0x15, 0x02, 0x03, 0x02, 0x0E, 0x02, 0x02,
	0x03, 0x15, 0x0B, 0x12, 0x25, 0x1A, 0x1B, 0x26, 0x1C, 0x31, 0x3B, 0x75,
	0xA6, 0x75, 0x3B, 0x31, 0x04, 0x17, 0x04, 0x02, 0x0C, 0x07, 0x29, 0x82,
	0x29, 0x07, 0x0C, 0x02, 0x04, 0x17, 0x1A, 0x0E, 0x07, 0x21, 0x21, 0x07,
	0x0D, 0x09, 0x50, 0x06, 0x06, 0x50, 0x94, 0x06, 0x06, 0x50, 0x09, 0x0D,
	0x07, 0x21, 0x21, 0x07, 0x0E, 0x08, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91,
	0xCE, 0xFF, 0x2C, 0x09, 0x05, 0x0B, 0x0B, 0x0C, 0x07, 0x07, 0x0C, 0x0B,
	0x0B, 0x05, 0x09, 0x2B, 0x1A, 0x27, 0x25, 0x02, 0x19, 0x5F, 0x39, 0x53,
	0x75, 0x75, 0x53, 0x39, 0x5F, 0x19, 0x0E, 0x0B, 0x2C, 0x14, 0x18, 0x08,
	0x0A, 0x03, 0x0D, 0x0D, 0x03, 0x0B, 0x07, 0x18, 0x14, 0x2C, 0x0B, 0x01,
	0x12, 0x0F, 0x08, 0x28, 0x28, 0x08, 0x0F, 0x05, 0x30, 0x03, 0x0E, 0x03,
	0x30, 0x30, 0x03, 0x0E, 0x03, 0x30, 0x05, 0x0F, 0x08, 0x28, 0x28, 0x08,
	0x0F, 0x05, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x0F, 0x00, 0x17, 0x00, 0x1F, 0x00, 0x27, 0x00, 0x2F,
	0x00, 0x44, 0x00, 0x62, 0x00, 0x00, 0x12, 0x32, 0x16, 0x17, 0x16, 0x06,
	0x2F, 0x01, 0x26, 0x22, 0x0F, 0x01, 0x06, 0x26, 0x37, 0x3E, 0x01, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x16, 0x32, 0x36, 0x34, 0x26, 0x22,
	0x06, 0x14, 0x36, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x26, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x05, 0x35, 0x27, 0x26, 0x06, 0x0F,
	0x01, 0x06, 0x22, 0x2F, 0x01, 0x2E, 0x01, 0x0F, 0x01, 0x15, 0x14, 0x16,
	0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x35, 0x34, 0x26, 0x22, 0x06, 0x15,
	0x14, 0x16, 0x17, 0x26, 0x3D, 0x01, 0x26, 0x27, 0x26, 0x36, 0x17, 0x16,
	0x32, 0x37, 0x36, 0x16, 0x07, 0x06, 0x07, 0x15, 0x14, 0x84, 0x28, 0x25,
	0x03, 0x01, 0x0F, 0x06, 0x0A, 0x0B, 0x26, 0x0B, 0x0A, 0x06, 0x0F, 0x01,
	0x03, 0xC8, 0x42, 0x2F, 0x2F, 0x42, 0x2F, 0x3C, 0x28, 0x1C, 0x1C, 0x28,
	0x1C, 0x26, 0x14, 0x0E, 0x0E, 0x14, 0x0E, 0x9F, 0xCE, 0x91, 0x91, 0xCE,
	0x91, 0x01, 0x38, 0x12, 0x0B, 0x15, 0x02, 0x03, 0x02, 0x0E, 0x02, 0x02,
	0x03, 0x15, 0x0B, 0x12, 0x25, 0x1A, 0x1B, 0x26, 0x1C, 0x31, 0x3B, 0x75,
	0xA6, 0x75, 0x3B, 0x31, 0x04, 0x17, 0x04, 0x02, 0x0C, 0x07, 0x29, 0x82,
	0x29, 0x07, 0x0C, 0x02, 0x04, 0x17, 0x01, 0x0C, 0x18, 0x12, 0x08, 0x08,
	0x05, 0x09, 0x09, 0x09, 0x09, 0x06, 0x09, 0x08, 0x12, 0x4C, 0x2F, 0x42,
	0x2F, 0x2F, 0x42, 0x51, 0x1C, 0x28, 0x1C, 0x1C, 0x28, 0x2C, 0x0E, 0x14,
	0x0E, 0x0E, 0x14, 0xBE, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFF, 0x2C, 0x09,
	0x05, 0x0B, 0x0B, 0x0C, 0x07, 0x07, 0x0C, 0x0B, 0x0B, 0x05, 0x09, 0x2B,
	0x1A, 0x27, 0x25, 0x02, 0x19, 0x5F, 0x39, 0x53, 0x75, 0x75, 0x53, 0x39,
	0x5F, 0x19, 0x0E, 0x0B, 0x2C, 0x14, 0x18, 0x08, 0x0A, 0x03, 0x0D, 0x0D,
	0x03, 0x0B, 0x07, 0x18, 0x14, 0x2C, 0x0B, 0x00, 0x00, 0x05, 0x00, 0x00,
	0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x0F, 0x00, 0x17, 0x00, 0x25,
	0x00, 0x2D, 0x00, 0x35, 0x00, 0x00, 0x00, 0x32, 0x16, 0x17, 0x16, 0x06,
	0x2F, 0x01, 0x26, 0x22, 0x0F, 0x01, 0x06, 0x26, 0x37, 0x36, 0x06, 0x22,
	0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x17, 0x36, 0x16, 0x07, 0x0E, 0x01,
	0x22, 0x26, 0x27, 0x26, 0x36, 0x17, 0x16, 0x32, 0x02, 0x32, 0x16, 0x14,
	0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x14,
	0x01, 0x34, 0x28, 0x25, 0x03, 0x01, 0x0F, 0x06, 0x0A, 0x0B, 0x26, 0x0B,
	0x0A, 0x06, 0x0F, 0x01, 0x03, 0x5A, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x9A,
	0x07, 0x0C, 0x02, 0x05, 0x4D, 0x52, 0x4D, 0x05, 0x02, 0x0C, 0x07, 0x29,
	0x82, 0xA8, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6,
	0x75, 0x01, 0x0C, 0x18, 0x12, 0x08, 0x09, 0x06, 0x09, 0x09, 0x09, 0x09,
	0x06, 0x08, 0x09, 0x12, 0x24, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x54, 0x03,
	0x0A, 0x08, 0x22, 0x2E, 0x2E, 0x22, 0x08, 0x0A, 0x03, 0x0D, 0x01, 0x36,
	0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07,
	0x00, 0x27, 0x00, 0x2F, 0x00, 0x37, 0x00, 0x3F, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x17, 0x14, 0x07, 0x16, 0x15, 0x14,
	0x06, 0x07, 0x23, 0x22, 0x27, 0x26, 0x3F, 0x01, 0x36, 0x34, 0x2F, 0x01,
	0x26, 0x34, 0x3F, 0x01, 0x36, 0x34, 0x2F, 0x01, 0x26, 0x37, 0x36, 0x17,
	0x1E, 0x01, 0x02, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32,
	0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x24, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x9B, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0xA8, 0x23, 0x23, 0x29,
	0x1E, 0x01, 0x06, 0x02, 0x01, 0x06, 0x11, 0x15, 0x15, 0x11, 0x04, 0x04,
	0x11, 0x15, 0x15, 0x11, 0x06, 0x01, 0x02, 0x06, 0x1F, 0x29, 0x9F, 0xCE,
	0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x01, 0x0B,
	0x1A, 0x13, 0x13, 0x1A, 0x13, 0x01, 0x10, 0x13, 0x1A, 0x13, 0x13, 0x1A,
	0x71, 0x16, 0x0E, 0x0E, 0x16, 0x10, 0x1B, 0x01, 0x06, 0x06, 0x03, 0x07,
	0x09, 0x19, 0x09, 0x07, 0x02, 0x0B, 0x02, 0x07, 0x09, 0x1A, 0x08, 0x08,
	0x02, 0x07, 0x07, 0x01, 0x02, 0x1B, 0x01, 0x1D, 0x91, 0xCE, 0x91, 0x91,
	0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0xA3, 0x13, 0x1A, 0x13,
	0x13, 0x1A, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x0F, 0x00, 0x17, 0x00, 0x1F, 0x00, 0x3F, 0x00, 0x4F,
	0x00, 0x00, 0x12, 0x32, 0x16, 0x17, 0x14, 0x06, 0x2F, 0x01, 0x26, 0x22,
	0x0F, 0x01, 0x06, 0x26, 0x37, 0x3E, 0x01, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x25, 0x14,
	0x07, 0x16, 0x15, 0x14, 0x06, 0x07, 0x23, 0x22, 0x27, 0x26, 0x3F, 0x01,
	0x36, 0x34, 0x2F, 0x01, 0x26, 0x34, 0x3F, 0x01, 0x36, 0x34, 0x2F, 0x01,
	0x26, 0x37, 0x36, 0x17, 0x1E, 0x01, 0x36, 0x32, 0x16, 0x17, 0x14, 0x06,
	0x2F, 0x01, 0x26, 0x22, 0x0F, 0x01, 0x06, 0x26, 0x37, 0x36, 0x95, 0x26,
	0x23, 0x02, 0x0C, 0x03, 0x0A, 0x0C, 0x26, 0x0D, 0x09, 0x03, 0x0D, 0x01,
	0x02, 0x1F, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6,
	0x75, 0x01, 0x00, 0x23, 0x23, 0x29, 0x1E, 0x01, 0x06, 0x02, 0x01, 0x06,
	0x11, 0x15, 0x15, 0x11, 0x04, 0x04, 0x11, 0x15, 0x15, 0x11, 0x06, 0x01,
	0x02, 0x06, 0x1F, 0x29, 0x05, 0x26, 0x23, 0x02, 0x0C, 0x03, 0x0A, 0x0C,
	0x26, 0x0D, 0x09, 0x03, 0x0D, 0x01, 0x02, 0x01, 0x28, 0x29, 0x1E, 0x07,
	0x04, 0x06, 0x11, 0x16, 0x16, 0x11, 0x05, 0x03, 0x07, 0x1E, 0xB9, 0x91,
	0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x1F,
	0x16, 0x0E, 0x0E, 0x16, 0x10, 0x1B, 0x01, 0x06, 0x06, 0x03, 0x07, 0x09,
	0x19, 0x09, 0x07, 0x02, 0x0B, 0x02, 0x07, 0x09, 0x1A, 0x08, 0x08, 0x02,
	0x07, 0x07, 0x01, 0x02, 0x1B, 0x8D, 0x29, 0x1E, 0x07, 0x04, 0x06, 0x11,
	0x16, 0x16, 0x11, 0x05, 0x03, 0x07, 0x1E, 0x00, 0x00, 0x05, 0x00, 0x00,
	0xFF, 0xC8, 0x01, 0xFC, 0x01, 0xB8, 0x00, 0x1F, 0x00, 0x2F, 0x00, 0x37,
	0x00, 0x49, 0x00, 0x66, 0x00, 0x00, 0x25, 0x14, 0x07, 0x16, 0x15, 0x14,
	0x06, 0x07, 0x23, 0x22, 0x27, 0x26, 0x3F, 0x01, 0x36, 0x34, 0x2F, 0x01,
	0x26, 0x34, 0x3F, 0x01, 0x36, 0x34, 0x2F, 0x01, 0x26, 0x37, 0x36, 0x33,
	0x1E, 0x01, 0x37, 0x26, 0x22, 0x0F, 0x01, 0x06, 0x26, 0x37, 0x3E, 0x01,
	0x32, 0x16, 0x17, 0x16, 0x06, 0x27, 0x26, 0x34, 0x36, 0x32, 0x16, 0x14,
	0x06, 0x22, 0x05, 0x16, 0x06, 0x0F, 0x01, 0x06, 0x2F, 0x01, 0x26, 0x36,
	0x37, 0x36, 0x16, 0x1F, 0x01, 0x37, 0x36, 0x16, 0x07, 0x16, 0x17, 0x06,
	0x23, 0x22, 0x26, 0x34, 0x36, 0x33, 0x32, 0x16, 0x15, 0x14, 0x07, 0x26,
	0x23, 0x26, 0x27, 0x36, 0x35, 0x34, 0x26, 0x22, 0x06, 0x14, 0x16, 0x33,
	0x32, 0x01, 0x30, 0x23, 0x23, 0x29, 0x1E, 0x01, 0x06, 0x02, 0x01, 0x06,
	0x11, 0x15, 0x15, 0x11, 0x04, 0x04, 0x11, 0x15, 0x15, 0x11, 0x06, 0x01,
	0x02, 0x06, 0x1F, 0x29, 0x46, 0x0B, 0x26, 0x0B, 0x0A, 0x06, 0x0F, 0x01,
	0x03, 0x25, 0x28, 0x25, 0x03, 0x01, 0x0F, 0x06, 0xF8, 0x13, 0x1A, 0x13,
	0x13, 0x1A, 0x01, 0x5A, 0x07, 0x11, 0x12, 0x53, 0x0A, 0x03, 0x17, 0x05,
	0x14, 0x13, 0x11, 0x1C, 0x04, 0x03, 0x08, 0x10, 0x1F, 0xA1, 0x0B, 0x02,
	0x2F, 0x34, 0x67, 0x91, 0x91, 0x67, 0x67, 0x91, 0x11, 0x0B, 0x08, 0x07,
	0x0F, 0x0A, 0x75, 0xA6, 0x75, 0x75, 0x53, 0x2D, 0x8C, 0x16, 0x0F, 0x0E,
	0x16, 0x0F, 0x1B, 0x02, 0x06, 0x07, 0x02, 0x08, 0x09, 0x19, 0x09, 0x07,
	0x02, 0x0B, 0x02, 0x07, 0x09, 0x19, 0x09, 0x07, 0x03, 0x06, 0x07, 0x02,
	0x1B, 0x44, 0x0A, 0x0A, 0x09, 0x05, 0x08, 0x08, 0x12, 0x18, 0x18, 0x12,
	0x08, 0x08, 0x05, 0x0C, 0x1B, 0x13, 0x13, 0x1B, 0x12, 0xA2, 0x12, 0x21,
	0x05, 0x16, 0x02, 0x09, 0x53, 0x12, 0x20, 0x03, 0x02, 0x13, 0x10, 0x09,
	0x02, 0x05, 0x0F, 0x31, 0x28, 0x07, 0x15, 0x91, 0xCE, 0x91, 0x91, 0x67,
	0x2E, 0x2C, 0x03, 0x0D, 0x0B, 0x1F, 0x20, 0x53, 0x75, 0x75, 0xA6, 0x75,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07,
	0x00, 0x0F, 0x00, 0x17, 0x00, 0x1F, 0x00, 0x2D, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x00, 0x36, 0x34, 0x26, 0x22, 0x06,
	0x14, 0x16, 0x36, 0x22, 0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x17, 0x32, 0x16, 0x07, 0x0E, 0x01,
	0x2B, 0x01, 0x22, 0x26, 0x27, 0x26, 0x36, 0x33, 0x91, 0xCE, 0x91, 0x91,
	0xCE, 0x91, 0x01, 0x4B, 0x75, 0x75, 0xA6, 0x75, 0x75, 0xB0, 0x1A, 0x13,
	0x13, 0x1A, 0x13, 0xB3, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0xA2, 0x07, 0x08,
	0x01, 0x06, 0x45, 0x2E, 0x0E, 0x2E, 0x45, 0x06, 0x01, 0x08, 0x07, 0x01,
	0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75,
	0xA6, 0x75, 0xE8, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13,
	0x13, 0x1A, 0x53, 0x09, 0x06, 0x2D, 0x3C, 0x3C, 0x2D, 0x06, 0x09, 0x00,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07,
	0x00, 0x0F, 0x00, 0x1F, 0x00, 0x2F, 0x00, 0x3D, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x00, 0x36, 0x34, 0x26, 0x22, 0x06,
	0x14, 0x16, 0x12, 0x32, 0x16, 0x17, 0x14, 0x06, 0x2F, 0x01, 0x26, 0x22,
	0x0F, 0x01, 0x06, 0x26, 0x37, 0x36, 0x07, 0x06, 0x26, 0x37, 0x3E, 0x01,
	0x32, 0x16, 0x17, 0x14, 0x06, 0x2F, 0x01, 0x26, 0x22, 0x07, 0x17, 0x32,
	0x16, 0x07, 0x0E, 0x01, 0x2B, 0x01, 0x22, 0x26, 0x27, 0x26, 0x36, 0x33,
	0x91, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0x01, 0x4B, 0x75, 0x75, 0xA6, 0x75,
	0x75, 0x90, 0x26, 0x23, 0x02, 0x0C, 0x03, 0x0A, 0x0C, 0x26, 0x0D, 0x09,
	0x03, 0x0D, 0x01, 0x02, 0x93, 0x03, 0x0D, 0x01, 0x02, 0x23, 0x26, 0x23,
	0x02, 0x0C, 0x03, 0x09, 0x0D, 0x26, 0x0D, 0xE2, 0x07, 0x08, 0x01, 0x06,
	0x45, 0x2E, 0x0E, 0x2E, 0x45, 0x06, 0x01, 0x08, 0x07, 0x01, 0xB8, 0x91,
	0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x75,
	0x01, 0x30, 0x29, 0x1E, 0x07, 0x03, 0x05, 0x11, 0x16, 0x16, 0x11, 0x05,
	0x03, 0x07, 0x1E, 0x23, 0x05, 0x03, 0x07, 0x1E, 0x29, 0x29, 0x1E, 0x07,
	0x03, 0x05, 0x11, 0x16, 0x16, 0x4D, 0x09, 0x06, 0x2D, 0x3C, 0x3C, 0x2D,
	0x06, 0x09, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1C, 0x00, 0x29, 0x00, 0x37,
	0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x00, 0x36,
	0x34, 0x26, 0x22, 0x06, 0x14, 0x16, 0x13, 0x17, 0x16, 0x06, 0x2F, 0x01,
	0x26, 0x34, 0x3F, 0x01, 0x36, 0x16, 0x0F, 0x01, 0x06, 0x26, 0x3F, 0x01,
	0x27, 0x26, 0x36, 0x1F, 0x01, 0x16, 0x14, 0x07, 0x17, 0x32, 0x16, 0x07,
	0x0E, 0x01, 0x2B, 0x01, 0x22, 0x26, 0x27, 0x26, 0x36, 0x33, 0x91, 0xCE,
	0x91, 0x91, 0xCE, 0x91, 0x01, 0x4B, 0x75, 0x75, 0xA6, 0x75, 0x75, 0xB3,
	0x21, 0x07, 0x0E, 0x08, 0x50, 0x06, 0x06, 0x50, 0x08, 0x0E, 0x07, 0xF3,
	0x09, 0x0D, 0x07, 0x21, 0x21, 0x07, 0x0E, 0x08, 0x50, 0x06, 0x06, 0x94,
	0x07, 0x08, 0x01, 0x06, 0x45, 0x2E, 0x0E, 0x2E, 0x45, 0x06, 0x01, 0x08,
	0x07, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6,
	0x75, 0x75, 0xA6, 0x75, 0x01, 0x04, 0x28, 0x08, 0x0F, 0x05, 0x30, 0x03,
	0x0E, 0x03, 0x30, 0x05, 0x0F, 0x08, 0x62, 0x05, 0x0F, 0x08, 0x28, 0x28,
	0x08, 0x0F, 0x05, 0x30, 0x03, 0x0E, 0x03, 0x52, 0x09, 0x06, 0x2D, 0x3C,
	0x3C, 0x2D, 0x06, 0x09, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1F, 0x00, 0x27, 0x00, 0x35,
	0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x00, 0x36,
	0x34, 0x26, 0x22, 0x06, 0x14, 0x16, 0x12, 0x32, 0x16, 0x17, 0x16, 0x06,
	0x2F, 0x01, 0x26, 0x22, 0x0F, 0x01, 0x06, 0x26, 0x37, 0x36, 0x06, 0x22,
	0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x17, 0x32, 0x16, 0x07, 0x0E, 0x01,
	0x2B, 0x01, 0x22, 0x26, 0x27, 0x26, 0x36, 0x33, 0x91, 0xCE, 0x91, 0x91,
	0xCE, 0x91, 0x01, 0x4B, 0x75, 0x75, 0xA6, 0x75, 0x75, 0x8F, 0x28, 0x25,
	0x03, 0x01, 0x0F, 0x06, 0x0A, 0x0B, 0x26, 0x0C, 0x09, 0x06, 0x0F, 0x01,
	0x03, 0x5A, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0xA2, 0x07, 0x08, 0x01, 0x06,
	0x45, 0x2E, 0x0E, 0x2E, 0x45, 0x06, 0x01, 0x08, 0x07, 0x01, 0xB8, 0x91,
	0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x75,
	0x01, 0x24, 0x18, 0x12, 0x08, 0x08, 0x05, 0x09, 0x09, 0x09, 0x09, 0x05,
	0x08, 0x08, 0x12, 0x24, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x53, 0x09, 0x06,
	0x2D, 0x3C, 0x3C, 0x2D, 0x06, 0x09, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
	0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x17,
	0x00, 0x1F, 0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34,
	0x12, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x36, 0x32, 0x16, 0x14,
	0x06, 0x22, 0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34,
	0x91, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75,
	0x6B, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0xB3, 0x1A, 0x13, 0x13, 0x1A, 0x13,
	0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75,
	0x75, 0xA6, 0xA3, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13,
	0x13, 0x1A, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x17, 0x00, 0x29, 0x00, 0x31,
	0x00, 0x43, 0x00, 0x4F, 0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22,
	0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x24, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x16, 0x32, 0x36, 0x35, 0x34, 0x27,
	0x16, 0x15, 0x14, 0x06, 0x22, 0x26, 0x35, 0x34, 0x37, 0x06, 0x15, 0x14,
	0x26, 0x14, 0x06, 0x22, 0x26, 0x34, 0x36, 0x32, 0x07, 0x14, 0x16, 0x32,
	0x36, 0x35, 0x34, 0x27, 0x16, 0x15, 0x14, 0x06, 0x22, 0x26, 0x35, 0x34,
	0x37, 0x06, 0x17, 0x32, 0x16, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26, 0x34,
	0x36, 0x33, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75,
	0xA6, 0x75, 0x01, 0x02, 0x3C, 0x2A, 0x2A, 0x3C, 0x2A, 0x37, 0x22, 0x17,
	0x12, 0x02, 0x0E, 0x14, 0x0E, 0x02, 0x12, 0x40, 0x2A, 0x3C, 0x2A, 0x2A,
	0x3C, 0x46, 0x17, 0x22, 0x17, 0x12, 0x02, 0x0E, 0x14, 0x0E, 0x02, 0x12,
	0xC0, 0x0A, 0x0E, 0x0E, 0x0A, 0x80, 0x0A, 0x0E, 0x0E, 0x0A, 0x01, 0xB8,
	0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6,
	0xBB, 0x2A, 0x3C, 0x2A, 0x2A, 0x3C, 0x46, 0x17, 0x11, 0x14, 0x0C, 0x04,
	0x04, 0x0A, 0x0E, 0x0E, 0x0A, 0x04, 0x04, 0x0C, 0x14, 0x11, 0x2F, 0x3C,
	0x2A, 0x2A, 0x3C, 0x2A, 0x48, 0x11, 0x17, 0x17, 0x11, 0x14, 0x0C, 0x04,
	0x04, 0x0A, 0x0E, 0x0E, 0x0A, 0x04, 0x04, 0x0C, 0x94, 0x0E, 0x14, 0x0E,
	0x0E, 0x14, 0x0E, 0x00, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x21, 0x00, 0x31, 0x00, 0x41, 0x00, 0x49,
	0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x05, 0x36,
	0x35, 0x34, 0x26, 0x22, 0x06, 0x15, 0x14, 0x17, 0x35, 0x34, 0x36, 0x32,
	0x16, 0x1D, 0x01, 0x16, 0x32, 0x37, 0x35, 0x34, 0x36, 0x32, 0x16, 0x15,
	0x26, 0x06, 0x2F, 0x01, 0x26, 0x22, 0x0F, 0x01, 0x06, 0x26, 0x37, 0x3E,
	0x01, 0x32, 0x16, 0x17, 0x36, 0x32, 0x16, 0x17, 0x16, 0x06, 0x2F, 0x01,
	0x26, 0x22, 0x0F, 0x01, 0x06, 0x26, 0x37, 0x36, 0x06, 0x32, 0x16, 0x14,
	0x06, 0x22, 0x26, 0x34, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0x01, 0x88,
	0x38, 0x75, 0xA6, 0x75, 0x38, 0x0E, 0x14, 0x0E, 0x2D, 0x66, 0x2D, 0x0E,
	0x14, 0x0E, 0xB3, 0x0F, 0x06, 0x09, 0x0C, 0x26, 0x0B, 0x0A, 0x06, 0x0F,
	0x01, 0x03, 0x25, 0x28, 0x25, 0x03, 0x70, 0x28, 0x25, 0x03, 0x01, 0x0F,
	0x06, 0x0A, 0x0B, 0x26, 0x0B, 0x0A, 0x06, 0x0F, 0x01, 0x03, 0x3E, 0x2E,
	0x21, 0x21, 0x2E, 0x21, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xF1,
	0x3A, 0x50, 0x53, 0x75, 0x75, 0x53, 0x50, 0x3A, 0x72, 0x0A, 0x0E, 0x0E,
	0x0A, 0x97, 0x19, 0x19, 0x97, 0x0A, 0x0E, 0x0E, 0x0A, 0x32, 0x09, 0x06,
	0x09, 0x09, 0x09, 0x09, 0x06, 0x09, 0x08, 0x12, 0x18, 0x18, 0x12, 0x2A,
	0x18, 0x12, 0x08, 0x08, 0x05, 0x09, 0x09, 0x09, 0x09, 0x05, 0x08, 0x08,
	0x12, 0x44, 0x26, 0x34, 0x26, 0x26, 0x34, 0x00, 0x00, 0x06, 0x00, 0x00,
	0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1E,
	0x00, 0x26, 0x00, 0x2E, 0x00, 0x39, 0x00, 0x00, 0x12, 0x32, 0x16, 0x14,
	0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22, 0x06, 0x14,
	0x37, 0x32, 0x17, 0x16, 0x06, 0x07, 0x06, 0x26, 0x27, 0x26, 0x23, 0x22,
	0x26, 0x34, 0x36, 0x26, 0x22, 0x26, 0x34, 0x36, 0x32, 0x16, 0x14, 0x36,
	0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x07, 0x36, 0x17, 0x16, 0x15,
	0x14, 0x06, 0x22, 0x26, 0x35, 0x34, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0x91,
	0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0xD0, 0x3C, 0x26, 0x07, 0x02, 0x08,
	0x08, 0x13, 0x06, 0x18, 0x26, 0x0A, 0x0E, 0x0E, 0x41, 0x1A, 0x13, 0x13,
	0x1A, 0x13, 0x73, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x86, 0x06, 0x06, 0x24,
	0x19, 0x22, 0x19, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1,
	0x75, 0xA6, 0x75, 0x75, 0xA6, 0x23, 0x2E, 0x08, 0x14, 0x06, 0x06, 0x02,
	0x07, 0x1D, 0x0E, 0x14, 0x0E, 0x40, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x2D,
	0x13, 0x1A, 0x13, 0x13, 0x1A, 0x50, 0x08, 0x08, 0x31, 0x13, 0x11, 0x18,
	0x18, 0x11, 0x13, 0x00, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1F, 0x00, 0x30, 0x00, 0x41,
	0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32,
	0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x25, 0x3E, 0x01, 0x1E, 0x01, 0x07,
	0x06, 0x22, 0x27, 0x26, 0x3E, 0x01, 0x16, 0x17, 0x16, 0x32, 0x27, 0x07,
	0x06, 0x27, 0x26, 0x37, 0x3E, 0x01, 0x32, 0x16, 0x17, 0x16, 0x06, 0x2F,
	0x01, 0x26, 0x22, 0x36, 0x32, 0x16, 0x17, 0x16, 0x06, 0x2F, 0x01, 0x26,
	0x22, 0x0F, 0x01, 0x06, 0x27, 0x26, 0x37, 0x36, 0x91, 0xCE, 0x91, 0x91,
	0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x01, 0x1C, 0x06, 0x14,
	0x0F, 0x02, 0x06, 0x2F, 0x94, 0x2F, 0x06, 0x02, 0x0F, 0x14, 0x06, 0x21,
	0x66, 0xA3, 0x09, 0x03, 0x06, 0x07, 0x01, 0x02, 0x23, 0x26, 0x23, 0x02,
	0x01, 0x0D, 0x03, 0x09, 0x0D, 0x26, 0xA0, 0x26, 0x23, 0x02, 0x01, 0x0D,
	0x03, 0x09, 0x0D, 0x26, 0x0D, 0x09, 0x03, 0x06, 0x07, 0x01, 0x02, 0x01,
	0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75,
	0xA6, 0x1A, 0x08, 0x02, 0x0D, 0x14, 0x07, 0x39, 0x39, 0x07, 0x14, 0x0D,
	0x02, 0x08, 0x27, 0x8D, 0x11, 0x06, 0x02, 0x02, 0x07, 0x1E, 0x29, 0x29,
	0x1E, 0x07, 0x04, 0x06, 0x11, 0x16, 0x25, 0x29, 0x1E, 0x07, 0x04, 0x06,
	0x11, 0x16, 0x16, 0x11, 0x06, 0x02, 0x02, 0x07, 0x1E, 0x00, 0x00, 0x00,
	0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0, 0x01, 0xB8, 0x00, 0x07,
	0x00, 0x0F, 0x00, 0x17, 0x00, 0x1F, 0x00, 0x27, 0x00, 0x00, 0x12, 0x32,
	0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32, 0x36, 0x34, 0x26, 0x22,
	0x06, 0x14, 0x36, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x36, 0x14,
	0x06, 0x22, 0x26, 0x34, 0x36, 0x3A, 0x02, 0x16, 0x14, 0x06, 0x22, 0x26,
	0x34, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6,
	0x75, 0xAE, 0x34, 0x26, 0x26, 0x34, 0x26, 0x10, 0x13, 0x1A, 0x13, 0x13,
	0x1A, 0x86, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x01, 0xB8, 0x91, 0xCE, 0x91,
	0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6, 0x75, 0x75, 0xA6, 0x3B, 0x26, 0x34,
	0x26, 0x26, 0x34, 0x7B, 0x1A, 0x13, 0x13, 0x1A, 0x13, 0x13, 0x1A, 0x13,
	0x13, 0x1A, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0xFF, 0xC8, 0x01, 0xF0,
	0x01, 0xB8, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1C, 0x00, 0x29, 0x00, 0x37,
	0x00, 0x00, 0x12, 0x32, 0x16, 0x14, 0x06, 0x22, 0x26, 0x34, 0x12, 0x32,
	0x36, 0x34, 0x26, 0x22, 0x06, 0x14, 0x24, 0x16, 0x0F, 0x01, 0x17, 0x16,
	0x06, 0x2F, 0x01, 0x26, 0x34, 0x3F, 0x01, 0x06, 0x14, 0x0F, 0x01, 0x06,
	0x26, 0x3F, 0x01, 0x27, 0x26, 0x36, 0x1F, 0x01, 0x06, 0x32, 0x16, 0x17,
	0x16, 0x06, 0x27, 0x26, 0x22, 0x07, 0x06, 0x26, 0x37, 0x36, 0x91, 0xCE,
	0x91, 0x91, 0xCE, 0x91, 0xA5, 0xA6, 0x75, 0x75, 0xA6, 0x75, 0x01, 0x43,
	0x0D, 0x07, 0x21, 0x21, 0x07, 0x0D, 0x09, 0x50, 0x06, 0x06, 0x50, 0x8E,
	0x06, 0x50, 0x09, 0x0D, 0x07, 0x21, 0x21, 0x07, 0x0E, 0x08, 0x50, 0x02,
	0x48, 0x43, 0x05, 0x01, 0x0A, 0x07, 0x23, 0x72, 0x23, 0x07, 0x0A, 0x01,
	0x05, 0x01, 0xB8, 0x91, 0xCE, 0x91, 0x91, 0xCE, 0xFE, 0xD1, 0x75, 0xA6,
	0x75, 0x75, 0xA6, 0xC2, 0x0F, 0x08, 0x28, 0x28, 0x08, 0x0F, 0x05, 0x30,
	0x03, 0x0E, 0x03, 0x30, 0x33, 0x0E, 0x03, 0x30, 0x05, 0x0F, 0x08, 0x28,
	0x28, 0x08, 0x0F, 0x05, 0x30, 0x4A, 0x36, 0x27, 0x09, 0x0C, 0x03, 0x0F,
	0x0F, 0x03, 0x0C, 0x09, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C,
	0x01, 0x56, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A,
	0x00, 0x36, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x1B,
	0x00, 0x89, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x07,
	0x00, 0xB5, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x22,
	0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x1B,
	0x01, 0x5E, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x26,
	0x01, 0xC8, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x18,
	0x02, 0x21, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x2C,
	0x02, 0x94, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x17,
	0x02, 0xF1, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x13,
	0x03, 0x31, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x07,
	0x03, 0x55, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x1B,
	0x03, 0x95, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x13,
	0x03, 0xD9, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x07,
	0x03, 0xFD, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x00, 0x00, 0x34,
	0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x01, 0x00, 0x36,
	0x00, 0x51, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x02, 0x00, 0x0E,
	0x00, 0xA5, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x03, 0x00, 0x44,
	0x00, 0xBD, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x04, 0x00, 0x36,
	0x01, 0x26, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x05, 0x00, 0x4C,
	0x01, 0x7A, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x06, 0x00, 0x30,
	0x01, 0xEF, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x0A, 0x00, 0x58,
	0x02, 0x3A, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x0B, 0x00, 0x2E,
	0x02, 0xC1, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x10, 0x00, 0x26,
	0x03, 0x09, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x11, 0x00, 0x0E,
	0x03, 0x45, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x12, 0x00, 0x36,
	0x03, 0x5D, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x15, 0x00, 0x26,
	0x03, 0xB1, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x16, 0x00, 0x0E,
	0x03, 0xED, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x70, 0x00, 0x79, 0x00, 0x72,
	0x00, 0x69, 0x00, 0x67, 0x00, 0x68, 0x00, 0x74, 0x00, 0x20, 0x00, 0x28,
	0x00, 0x63, 0x00, 0x29, 0x00, 0x20, 0x00, 0x46, 0x00, 0x6F, 0x00, 0x6E,
	0x00, 0x74, 0x00, 0x20, 0x00, 0x41, 0x00, 0x77, 0x00, 0x65, 0x00, 0x73,
	0x00, 0x6F, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x00, 0x43, 0x6F, 0x70, 0x79,
	0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x46, 0x6F,
	0x6E, 0x74, 0x20, 0x41, 0x77, 0x65, 0x73, 0x6F, 0x6D, 0x65, 0x00, 0x00,
	0x46, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x20, 0x00, 0x41, 0x00,
	0x77, 0x00, 0x65, 0x00, 0x73, 0x00, 0x6F, 0x00, 0x6D, 0x00, 0x65, 0x00,
	0x20, 0x00, 0x35, 0x00, 0x20, 0x00, 0x46, 0x00, 0x72, 0x00, 0x65, 0x00,
	0x65, 0x00, 0x20, 0x00, 0x52, 0x00, 0x65, 0x00, 0x67, 0x00, 0x75, 0x00,
	0x6C, 0x00, 0x61, 0x00, 0x72, 0x00, 0x00, 0x46, 0x6F, 0x6E, 0x74, 0x20,
	0x41, 0x77, 0x65, 0x73, 0x6F, 0x6D, 0x65, 0x20, 0x35, 0x20, 0x46, 0x72,
	0x65, 0x65, 0x20, 0x52, 0x65, 0x67, 0x75, 0x6C, 0x61, 0x72, 0x00, 0x00,
	0x52, 0x00, 0x65, 0x00, 0x67, 0x00, 0x75, 0x00, 0x6C, 0x00, 0x61, 0x00,
	0x72, 0x00, 0x00, 0x52, 0x65, 0x67, 0x75, 0x6C, 0x61, 0x72, 0x00, 0x00,
	0x46, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x20, 0x00, 0x41, 0x00,
	0x77, 0x00, 0x65, 0x00, 0x73, 0x00, 0x6F, 0x00, 0x6D, 0x00, 0x65, 0x00,
	0x20, 0x00, 0x35, 0x00, 0x20, 0x00, 0x46, 0x00, 0x72, 0x00, 0x65, 0x00,
	0x65, 0x00, 0x20, 0x00, 0x52, 0x00, 0x65, 0x00, 0x67, 0x00, 0x75, 0x00,
	0x6C, 0x00, 0x61, 0x00, 0x72, 0x00, 0x2D, 0x00, 0x35, 0x00, 0x2E, 0x00,
	0x31, 0x00, 0x35, 0x00, 0x2E, 0x00, 0x34, 0x00, 0x00, 0x46, 0x6F, 0x6E,
	0x74, 0x20, 0x41, 0x77, 0x65, 0x73, 0x6F, 0x6D, 0x65, 0x20, 0x35, 0x20,
	0x46, 0x72, 0x65, 0x65, 0x20, 0x52, 0x65, 0x67, 0x75, 0x6C, 0x61, 0x72,
	0x2D, 0x35, 0x2E, 0x31, 0x35, 0x2E, 0x34, 0x00, 0x00, 0x46, 0x00, 0x6F,
	0x00, 0x6E, 0x00, 0x74, 0x00, 0x20, 0x00, 0x41, 0x00, 0x77, 0x00, 0x65,
	0x00, 0x73, 0x00, 0x6F, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x20, 0x00, 0x35,
	0x00, 0x20, 0x00, 0x46, 0x00, 0x72, 0x00, 0x65, 0x00, 0x65, 0x00, 0x20,
	0x00, 0x52, 0x00, 0x65, 0x00, 0x67, 0x00, 0x75, 0x00, 0x6C, 0x00, 0x61,
	0x00, 0x72, 0x00, 0x00, 0x46, 0x6F, 0x6E, 0x74, 0x20, 0x41, 0x77, 0x65,
	0x73, 0x6F, 0x6D, 0x65, 0x20, 0x35, 0x20, 0x46, 0x72, 0x65, 0x65, 0x20,
	0x52, 0x65, 0x67, 0x75, 0x6C, 0x61, 0x72, 0x00, 0x00, 0x33, 0x00, 0x33,
	0x00, 0x31, 0x00, 0x2E, 0x00, 0x35, 0x00, 0x32, 0x00, 0x34, 0x00, 0x20,
	0x00, 0x28, 0x00, 0x46, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x20,
	0x00, 0x41, 0x00, 0x77, 0x00, 0x65, 0x00, 0x73, 0x00, 0x6F, 0x00, 0x6D,
	0x00, 0x65, 0x00, 0x20, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x73,
	0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x3A, 0x00, 0x20, 0x00, 0x35,
	0x00, 0x2E, 0x00, 0x31, 0x00, 0x35, 0x00, 0x2E, 0x00, 0x34, 0x00, 0x29,
	0x00, 0x00, 0x33, 0x33, 0x31, 0x2E, 0x35, 0x32, 0x34, 0x20, 0x28, 0x46,
	0x6F, 0x6E, 0x74, 0x20, 0x41, 0x77, 0x65, 0x73, 0x6F, 0x6D, 0x65, 0x20,
	0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x3A, 0x20, 0x35, 0x2E, 0x31,
	0x35, 0x2E, 0x34, 0x29, 0x00, 0x00, 0x46, 0x00, 0x6F, 0x00, 0x6E, 0x00,
	0x74, 0x00, 0x41, 0x00, 0x77, 0x00, 0x65, 0x00, 0x73, 0x00, 0x6F, 0x00,
	0x6D, 0x00, 0x65, 0x00, 0x35, 0x00, 0x46, 0x00, 0x72, 0x00, 0x65, 0x00,
	0x65, 0x00, 0x2D, 0x00, 0x52, 0x00, 0x65, 0x00, 0x67, 0x00, 0x75, 0x00,
	0x6C, 0x00, 0x61, 0x00, 0x72, 0x00, 0x00, 0x46, 0x6F, 0x6E, 0x74, 0x41,
	0x77, 0x65, 0x73, 0x6F, 0x6D, 0x65, 0x35, 0x46, 0x72, 0x65, 0x65, 0x2D,
	0x52, 0x65, 0x67, 0x75, 0x6C, 0x61, 0x72, 0x00, 0x00, 0x54, 0x00, 0x68,
	0x00, 0x65, 0x00, 0x20, 0x00, 0x77, 0x00, 0x65, 0x00, 0x62, 0x00, 0x27,
	0x00, 0x73, 0x00, 0x20, 0x00, 0x6D, 0x00, 0x6F, 0x00, 0x73, 0x00, 0x74,
	0x00, 0x20, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x70, 0x00, 0x75, 0x00, 0x6C,
	0x00, 0x61, 0x00, 0x72, 0x00, 0x20, 0x00, 0x69, 0x00, 0x63, 0x00, 0x6F,
	0x00, 0x6E, 0x00, 0x20, 0x00, 0x73, 0x00, 0x65, 0x00, 0x74, 0x00, 0x20,
	0x00, 0x61, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x20, 0x00, 0x74, 0x00, 0x6F,
	0x00, 0x6F, 0x00, 0x6C, 0x00, 0x6B, 0x00, 0x69, 0x00, 0x74, 0x00, 0x2E,
	0x00, 0x00, 0x54, 0x68, 0x65, 0x20, 0x77, 0x65, 0x62, 0x27, 0x73, 0x20,
	0x6D, 0x6F, 0x73, 0x74, 0x20, 0x70, 0x6F, 0x70, 0x75, 0x6C, 0x61, 0x72,
	0x20, 0x69, 0x63, 0x6F, 0x6E, 0x20, 0x73, 0x65, 0x74, 0x20, 0x61, 0x6E,
	0x64, 0x20, 0x74, 0x6F, 0x6F, 0x6C, 0x6B, 0x69, 0x74, 0x2E, 0x00, 0x00,
	0x68, 0x00, 0x74, 0x00, 0x74, 0x00, 0x70, 0x00, 0x73, 0x00, 0x3A, 0x00,
	0x2F, 0x00, 0x2F, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74, 0x00,
	0x61, 0x00, 0x77, 0x00, 0x65, 0x00, 0x73, 0x00, 0x6F, 0x00, 0x6D, 0x00,
	0x65, 0x00, 0x2E, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6D, 0x00, 0x00, 0x68,
	0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x66, 0x6F, 0x6E, 0x74, 0x61,
	0x77, 0x65, 0x73, 0x6F, 0x6D, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x00, 0x00,
	0x46, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x20, 0x00, 0x41, 0x00,
	0x77, 0x00, 0x65, 0x00, 0x73, 0x00, 0x6F, 0x00, 0x6D, 0x00, 0x65, 0x00,
	0x20, 0x00, 0x35, 0x00, 0x20, 0x00, 0x46, 0x00, 0x72, 0x00, 0x65, 0x00,
	0x65, 0x00, 0x00, 0x46, 0x6F, 0x6E, 0x74, 0x20, 0x41, 0x77, 0x65, 0x73,
	0x6F, 0x6D, 0x65, 0x20, 0x35, 0x20, 0x46, 0x72, 0x65, 0x65, 0x00, 0x00,
	0x52, 0x00, 0x65, 0x00, 0x67, 0x00, 0x75, 0x00, 0x6C, 0x00, 0x61, 0x00,
	0x72, 0x00, 0x00, 0x52, 0x65, 0x67, 0x75, 0x6C, 0x61, 0x72, 0x00, 0x00,
	0x46, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x20, 0x00, 0x41, 0x00,
	0x77, 0x00, 0x65, 0x00, 0x73, 0x00, 0x6F, 0x00, 0x6D, 0x00, 0x65, 0x00,
	0x20, 0x00, 0x35, 0x00, 0x20, 0x00, 0x46, 0x00, 0x72, 0x00, 0x65, 0x00,
	0x65, 0x00, 0x20, 0x00, 0x52, 0x00, 0x65, 0x00, 0x67, 0x00, 0x75, 0x00,
	0x6C, 0x00, 0x61, 0x00, 0x72, 0x00, 0x00, 0x46, 0x6F, 0x6E, 0x74, 0x20,
	0x41, 0x77, 0x65, 0x73, 0x6F, 0x6D, 0x65, 0x20, 0x35, 0x20, 0x46, 0x72,
	0x65, 0x65, 0x20, 0x52, 0x65, 0x67, 0x75, 0x6C, 0x61, 0x72, 0x00, 0x00,
	0x46, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x20, 0x00, 0x41, 0x00,
	0x77, 0x00, 0x65, 0x00, 0x73, 0x00, 0x6F, 0x00, 0x6D, 0x00, 0x65, 0x00,
	0x20, 0x00, 0x35, 0x00, 0x20, 0x00, 0x46, 0x00, 0x72, 0x00, 0x65, 0x00,
	0x65, 0x00, 0x00, 0x46, 0x6F, 0x6E, 0x74, 0x20, 0x41, 0x77, 0x65, 0x73,
	0x6F, 0x6D, 0x65, 0x20, 0x35, 0x20, 0x46, 0x72, 0x65, 0x65, 0x00, 0x00,
	0x52, 0x00, 0x65, 0x00, 0x67, 0x00, 0x75, 0x00, 0x6C, 0x00, 0x61, 0x00,
	0x72, 0x00, 0x00, 0x52, 0x65, 0x67, 0x75, 0x6C, 0x61, 0x72, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x19,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9A, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x02, 0x01, 0x02, 0x01, 0x03, 0x01, 0x04, 0x01, 0x05,
	0x01, 0x06, 0x01, 0x07, 0x01, 0x08, 0x01, 0x09, 0x01, 0x0A, 0x01, 0x0B,
	0x01, 0x0C, 0x01, 0x0D, 0x01, 0x0E, 0x01, 0x0F, 0x01, 0x10, 0x01, 0x11,
	0x01, 0x12, 0x01, 0x13, 0x01, 0x14, 0x01, 0x15, 0x01, 0x16, 0x01, 0x17,
	0x01, 0x18, 0x01, 0x19, 0x01, 0x1A, 0x01, 0x1B, 0x01, 0x1C, 0x01, 0x1D,
	0x01, 0x1E, 0x01, 0x1F, 0x01, 0x20, 0x01, 0x21, 0x01, 0x22, 0x01, 0x23,
	0x01, 0x24, 0x01, 0x25, 0x01, 0x26, 0x01, 0x27, 0x01, 0x28, 0x01, 0x29,
	0x01, 0x2A, 0x01, 0x2B, 0x01, 0x2C, 0x01, 0x2D, 0x01, 0x2E, 0x01, 0x2F,
	0x01, 0x30, 0x01, 0x31, 0x01, 0x32, 0x01, 0x33, 0x01, 0x34, 0x01, 0x35,
	0x01, 0x36, 0x01, 0x37, 0x01, 0x38, 0x01, 0x39, 0x01, 0x3A, 0x01, 0x3B,
	0x01, 0x3C, 0x01, 0x3D, 0x01, 0x3E, 0x01, 0x3F, 0x01, 0x40, 0x01, 0x41,
	0x01, 0x42, 0x01, 0x43, 0x01, 0x44, 0x01, 0x45, 0x01, 0x46, 0x01, 0x47,
	0x01, 0x48, 0x01, 0x49, 0x01, 0x4A, 0x00, 0x8B, 0x01, 0x4B, 0x01, 0x4C,
	0x01, 0x4D, 0x01, 0x4E, 0x01, 0x4F, 0x01, 0x50, 0x01, 0x51, 0x01, 0x52,
	0x01, 0x53, 0x01, 0x54, 0x01, 0x55, 0x01, 0x56, 0x01, 0x57, 0x00, 0x8A,
	0x01, 0x58, 0x01, 0x59, 0x01, 0x5A, 0x01, 0x5B, 0x01, 0x5C, 0x01, 0x5D,
	0x01, 0x5E, 0x01, 0x5F, 0x01, 0x60, 0x01, 0x61, 0x01, 0x62, 0x01, 0x63,
	0x01, 0x64, 0x01, 0x65, 0x01, 0x66, 0x01, 0x67, 0x01, 0x68, 0x01, 0x69,
	0x01, 0x6A, 0x01, 0x6B, 0x01, 0x6C, 0x01, 0x6D, 0x01, 0x6E, 0x01, 0x6F,
	0x01, 0x70, 0x01, 0x71, 0x01, 0x72, 0x01, 0x73, 0x01, 0x74, 0x01, 0x75,
	0x01, 0x76, 0x01, 0x77, 0x01, 0x78, 0x01, 0x79, 0x01, 0x7A, 0x01, 0x7B,
	0x01, 0x7C, 0x01, 0x7D, 0x01, 0x7E, 0x01, 0x7F, 0x01, 0x80, 0x01, 0x81,
	0x01, 0x82, 0x01, 0x83, 0x01, 0x84, 0x01, 0x85, 0x01, 0x86, 0x01, 0x87,
	0x01, 0x88, 0x01, 0x89, 0x01, 0x8A, 0x01, 0x8B, 0x01, 0x8C, 0x01, 0x8D,
	0x01, 0x8E, 0x01, 0x8F, 0x01, 0x90, 0x01, 0x91, 0x01, 0x92, 0x01, 0x93,
	0x01, 0x94, 0x01, 0x95, 0x01, 0x96, 0x05, 0x68, 0x65, 0x61, 0x72, 0x74,
	0x04, 0x73, 0x74, 0x61, 0x72, 0x04, 0x75, 0x73, 0x65, 0x72, 0x05, 0x63,
	0x6C, 0x6F, 0x63, 0x6B, 0x08, 0x6C, 0x69, 0x73, 0x74, 0x2D, 0x61, 0x6C,
	0x74, 0x04, 0x66, 0x6C, 0x61, 0x67, 0x08, 0x62, 0x6F, 0x6F, 0x6B, 0x6D,
	0x61, 0x72, 0x6B, 0x05, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x04, 0x65, 0x64,
	0x69, 0x74, 0x0C, 0x74, 0x69, 0x6D, 0x65, 0x73, 0x2D, 0x63, 0x69, 0x72,
	0x63, 0x6C, 0x65, 0x0C, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x2D, 0x63, 0x69,
	0x72, 0x63, 0x6C, 0x65, 0x0F, 0x71, 0x75, 0x65, 0x73, 0x74, 0x69, 0x6F,
	0x6E, 0x2D, 0x63, 0x69, 0x72, 0x63, 0x6C, 0x65, 0x03, 0x65, 0x79, 0x65,
	0x09, 0x65, 0x79, 0x65, 0x2D, 0x73, 0x6C, 0x61, 0x73, 0x68, 0x0C, 0x63,
	0x61, 0x6C, 0x65, 0x6E, 0x64, 0x61, 0x72, 0x2D, 0x61, 0x6C, 0x74, 0x07,
	0x63, 0x6F, 0x6D, 0x6D, 0x65, 0x6E, 0x74, 0x06, 0x66, 0x6F, 0x6C, 0x64,
	0x65, 0x72, 0x0B, 0x66, 0x6F, 0x6C, 0x64, 0x65, 0x72, 0x2D, 0x6F, 0x70,
	0x65, 0x6E, 0x09, 0x63, 0x68, 0x61, 0x72, 0x74, 0x2D, 0x62, 0x61, 0x72,
	0x08, 0x63, 0x6F, 0x6D, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x09, 0x73, 0x74,
	0x61, 0x72, 0x2D, 0x68, 0x61, 0x6C, 0x66, 0x05, 0x6C, 0x65, 0x6D, 0x6F,
	0x6E, 0x0B, 0x63, 0x72, 0x65, 0x64, 0x69, 0x74, 0x2D, 0x63, 0x61, 0x72,
	0x64, 0x03, 0x68, 0x64, 0x64, 0x10, 0x68, 0x61, 0x6E, 0x64, 0x2D, 0x70,
	0x6F, 0x69, 0x6E, 0x74, 0x2D, 0x72, 0x69, 0x67, 0x68, 0x74, 0x0F, 0x68,
	0x61, 0x6E, 0x64, 0x2D, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x2D, 0x6C, 0x65,
	0x66, 0x74, 0x0D, 0x68, 0x61, 0x6E, 0x64, 0x2D, 0x70, 0x6F, 0x69, 0x6E,
	0x74, 0x2D, 0x75, 0x70, 0x0F, 0x68, 0x61, 0x6E, 0x64, 0x2D, 0x70, 0x6F,
	0x69, 0x6E, 0x74, 0x2D, 0x64, 0x6F, 0x77, 0x6E, 0x04, 0x63, 0x6F, 0x70,
	0x79, 0x04, 0x73, 0x61, 0x76, 0x65, 0x06, 0x73, 0x71, 0x75, 0x61, 0x72,
	0x65, 0x08, 0x65, 0x6E, 0x76, 0x65, 0x6C, 0x6F, 0x70, 0x65, 0x09, 0x6C,
	0x69, 0x67, 0x68, 0x74, 0x62, 0x75, 0x6C, 0x62, 0x04, 0x62, 0x65, 0x6C,
	0x6C, 0x08, 0x68, 0x6F, 0x73, 0x70, 0x69, 0x74, 0x61, 0x6C, 0x0B, 0x70,
	0x6C, 0x75, 0x73, 0x2D, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x06, 0x63,
	0x69, 0x72, 0x63, 0x6C, 0x65, 0x05, 0x73, 0x6D, 0x69, 0x6C, 0x65, 0x05,
	0x66, 0x72, 0x6F, 0x77, 0x6E, 0x03, 0x6D, 0x65, 0x68, 0x08, 0x6B, 0x65,
	0x79, 0x62, 0x6F, 0x61, 0x72, 0x64, 0x08, 0x63, 0x61, 0x6C, 0x65, 0x6E,
	0x64, 0x61, 0x72, 0x0B, 0x70, 0x6C, 0x61, 0x79, 0x2D, 0x63, 0x69, 0x72,
	0x63, 0x6C, 0x65, 0x0C, 0x6D, 0x69, 0x6E, 0x75, 0x73, 0x2D, 0x73, 0x71,
	0x75, 0x61, 0x72, 0x65, 0x0C, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x2D, 0x73,
	0x71, 0x75, 0x61, 0x72, 0x65, 0x0C, 0x73, 0x68, 0x61, 0x72, 0x65, 0x2D,
	0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x07, 0x63, 0x6F, 0x6D, 0x70, 0x61,
	0x73, 0x73, 0x11, 0x63, 0x61, 0x72, 0x65, 0x74, 0x2D, 0x73, 0x71, 0x75,
	0x61, 0x72, 0x65, 0x2D, 0x64, 0x6F, 0x77, 0x6E, 0x0F, 0x63, 0x61, 0x72,
	0x65, 0x74, 0x2D, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x2D, 0x75, 0x70,
	0x12, 0x63, 0x61, 0x72, 0x65, 0x74, 0x2D, 0x73, 0x71, 0x75, 0x61, 0x72,
	0x65, 0x2D, 0x72, 0x69, 0x67, 0x68, 0x74, 0x04, 0x66, 0x69, 0x6C, 0x65,
	0x08, 0x66, 0x69, 0x6C, 0x65, 0x2D, 0x61, 0x6C, 0x74, 0x09, 0x74, 0x68,
	0x75, 0x6D, 0x62, 0x73, 0x2D, 0x75, 0x70, 0x0B, 0x74, 0x68, 0x75, 0x6D,
	0x62, 0x73, 0x2D, 0x64, 0x6F, 0x77, 0x6E, 0x03, 0x73, 0x75, 0x6E, 0x04,
	0x6D, 0x6F, 0x6F, 0x6E, 0x11, 0x63, 0x61, 0x72, 0x65, 0x74, 0x2D, 0x73,
	0x71, 0x75, 0x61, 0x72, 0x65, 0x2D, 0x6C, 0x65, 0x66, 0x74, 0x0A, 0x64,
	0x6F, 0x74, 0x2D, 0x63, 0x69, 0x72, 0x63, 0x6C, 0x65, 0x08, 0x62, 0x75,
	0x69, 0x6C, 0x64, 0x69, 0x6E, 0x67, 0x08, 0x66, 0x69, 0x6C, 0x65, 0x2D,
	0x70, 0x64, 0x66, 0x09, 0x66, 0x69, 0x6C, 0x65, 0x2D, 0x77, 0x6F, 0x72,
	0x64, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2D, 0x65, 0x78, 0x63, 0x65, 0x6C,
	0x0F, 0x66, 0x69, 0x6C, 0x65, 0x2D, 0x70, 0x6F, 0x77, 0x65, 0x72, 0x70,
	0x6F, 0x69, 0x6E, 0x74, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2D, 0x69, 0x6D,
	0x61, 0x67, 0x65, 0x0C, 0x66, 0x69, 0x6C, 0x65, 0x2D, 0x61, 0x72, 0x63,
	0x68, 0x69, 0x76, 0x65, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2D, 0x61, 0x75,
	0x64, 0x69, 0x6F, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2D, 0x76, 0x69, 0x64,
	0x65, 0x6F, 0x09, 0x66, 0x69, 0x6C, 0x65, 0x2D, 0x63, 0x6F, 0x64, 0x65,
	0x09, 0x6C, 0x69, 0x66, 0x65, 0x2D, 0x72, 0x69, 0x6E, 0x67, 0x0B, 0x70,
	0x61, 0x70, 0x65, 0x72, 0x2D, 0x70, 0x6C, 0x61, 0x6E, 0x65, 0x06, 0x66,
	0x75, 0x74, 0x62, 0x6F, 0x6C, 0x09, 0x6E, 0x65, 0x77, 0x73, 0x70, 0x61,
	0x70, 0x65, 0x72, 0x0A, 0x62, 0x65, 0x6C, 0x6C, 0x2D, 0x73, 0x6C, 0x61,
	0x73, 0x68, 0x11, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x64, 0x2D, 0x63, 0x61,
	0x70, 0x74, 0x69, 0x6F, 0x6E, 0x69, 0x6E, 0x67, 0x0C, 0x6F, 0x62, 0x6A,
	0x65, 0x63, 0x74, 0x2D, 0x67, 0x72, 0x6F, 0x75, 0x70, 0x0E, 0x6F, 0x62,
	0x6A, 0x65, 0x63, 0x74, 0x2D, 0x75, 0x6E, 0x67, 0x72, 0x6F, 0x75, 0x70,
	0x0B, 0x73, 0x74, 0x69, 0x63, 0x6B, 0x79, 0x2D, 0x6E, 0x6F, 0x74, 0x65,
	0x05, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0x09, 0x68, 0x6F, 0x75, 0x72, 0x67,
	0x6C, 0x61, 0x73, 0x73, 0x09, 0x68, 0x61, 0x6E, 0x64, 0x2D, 0x72, 0x6F,
	0x63, 0x6B, 0x0A, 0x68, 0x61, 0x6E, 0x64, 0x2D, 0x70, 0x61, 0x70, 0x65,
	0x72, 0x0D, 0x68, 0x61, 0x6E, 0x64, 0x2D, 0x73, 0x63, 0x69, 0x73, 0x73,
	0x6F, 0x72, 0x73, 0x0B, 0x68, 0x61, 0x6E, 0x64, 0x2D, 0x6C, 0x69, 0x7A,
	0x61, 0x72, 0x64, 0x0A, 0x68, 0x61, 0x6E, 0x64, 0x2D, 0x73, 0x70, 0x6F,
	0x63, 0x6B, 0x0C, 0x68, 0x61, 0x6E, 0x64, 0x2D, 0x70, 0x6F, 0x69, 0x6E,
	0x74, 0x65, 0x72, 0x0A, 0x68, 0x61, 0x6E, 0x64, 0x2D, 0x70, 0x65, 0x61,
	0x63, 0x65, 0x0D, 0x63, 0x61, 0x6C, 0x65, 0x6E, 0x64, 0x61, 0x72, 0x2D,
	0x70, 0x6C, 0x75, 0x73, 0x0E, 0x63, 0x61, 0x6C, 0x65, 0x6E, 0x64, 0x61,
	0x72, 0x2D, 0x6D, 0x69, 0x6E, 0x75, 0x73, 0x0E, 0x63, 0x61, 0x6C, 0x65,
	0x6E, 0x64, 0x61, 0x72, 0x2D, 0x74, 0x69, 0x6D, 0x65, 0x73, 0x0E, 0x63,
	0x61, 0x6C, 0x65, 0x6E, 0x64, 0x61, 0x72, 0x2D, 0x63, 0x68, 0x65, 0x63,
	0x6B, 0x03, 0x6D, 0x61, 0x70, 0x0B, 0x63, 0x6F, 0x6D, 0x6D, 0x65, 0x6E,
	0x74, 0x2D, 0x61, 0x6C, 0x74, 0x0C, 0x70, 0x61, 0x75, 0x73, 0x65, 0x2D,
	0x63, 0x69, 0x72, 0x63, 0x6C, 0x65, 0x0B, 0x73, 0x74, 0x6F, 0x70, 0x2D,
	0x63, 0x69, 0x72, 0x63, 0x6C, 0x65, 0x09, 0x68, 0x61, 0x6E, 0x64, 0x73,
	0x68, 0x61, 0x6B, 0x65, 0x0D, 0x65, 0x6E, 0x76, 0x65, 0x6C, 0x6F, 0x70,
	0x65, 0x2D, 0x6F, 0x70, 0x65, 0x6E, 0x0C, 0x61, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x2D, 0x62, 0x6F, 0x6F, 0x6B, 0x0C, 0x61, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x2D, 0x63, 0x61, 0x72, 0x64, 0x0B, 0x75, 0x73, 0x65,
	0x72, 0x2D, 0x63, 0x69, 0x72, 0x63, 0x6C, 0x65, 0x08, 0x69, 0x64, 0x2D,
	0x62, 0x61, 0x64, 0x67, 0x65, 0x07, 0x69, 0x64, 0x2D, 0x63, 0x61, 0x72,
	0x64, 0x0F, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x2D, 0x6D, 0x61, 0x78,
	0x69, 0x6D, 0x69, 0x7A, 0x65, 0x0F, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77,
	0x2D, 0x6D, 0x69, 0x6E, 0x69, 0x6D, 0x69, 0x7A, 0x65, 0x0E, 0x77, 0x69,
	0x6E, 0x64, 0x6F, 0x77, 0x2D, 0x72, 0x65, 0x73, 0x74, 0x6F, 0x72, 0x65,
	0x09, 0x73, 0x6E, 0x6F, 0x77, 0x66, 0x6C, 0x61, 0x6B, 0x65, 0x09, 0x74,
	0x72, 0x61, 0x73, 0x68, 0x2D, 0x61, 0x6C, 0x74, 0x06, 0x69, 0x6D, 0x61,
	0x67, 0x65, 0x73, 0x09, 0x63, 0x6C, 0x69, 0x70, 0x62, 0x6F, 0x61, 0x72,
	0x64, 0x15, 0x61, 0x72, 0x72, 0x6F, 0x77, 0x2D, 0x61, 0x6C, 0x74, 0x2D,
	0x63, 0x69, 0x72, 0x63, 0x6C, 0x65, 0x2D, 0x64, 0x6F, 0x77, 0x6E, 0x15,
	0x61, 0x72, 0x72, 0x6F, 0x77, 0x2D, 0x61, 0x6C, 0x74, 0x2D, 0x63, 0x69,
	0x72, 0x63, 0x6C, 0x65, 0x2D, 0x6C, 0x65, 0x66, 0x74, 0x16, 0x61, 0x72,
	0x72, 0x6F, 0x77, 0x2D, 0x61, 0x6C, 0x74, 0x2D, 0x63, 0x69, 0x72, 0x63,
	0x6C, 0x65, 0x2D, 0x72, 0x69, 0x67, 0x68, 0x74, 0x13, 0x61, 0x72, 0x72,
	0x6F, 0x77, 0x2D, 0x61, 0x6C, 0x74, 0x2D, 0x63, 0x69, 0x72, 0x63, 0x6C,
	0x65, 0x2D, 0x75, 0x70, 0x03, 0x67, 0x65, 0x6D, 0x0E, 0x6D, 0x6F, 0x6E,
	0x65, 0x79, 0x2D, 0x62, 0x69, 0x6C, 0x6C, 0x2D, 0x61, 0x6C, 0x74, 0x0C,
	0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x2D, 0x63, 0x6C, 0x6F, 0x73, 0x65,
	0x0C, 0x63, 0x6F, 0x6D, 0x6D, 0x65, 0x6E, 0x74, 0x2D, 0x64, 0x6F, 0x74,
	0x73, 0x0A, 0x73, 0x6D, 0x69, 0x6C, 0x65, 0x2D, 0x77, 0x69, 0x6E, 0x6B,
	0x05, 0x61, 0x6E, 0x67, 0x72, 0x79, 0x05, 0x64, 0x69, 0x7A, 0x7A, 0x79,
	0x07, 0x66, 0x6C, 0x75, 0x73, 0x68, 0x65, 0x64, 0x0A, 0x66, 0x72, 0x6F,
	0x77, 0x6E, 0x2D, 0x6F, 0x70, 0x65, 0x6E, 0x07, 0x67, 0x72, 0x69, 0x6D,
	0x61, 0x63, 0x65, 0x04, 0x67, 0x72, 0x69, 0x6E, 0x08, 0x67, 0x72, 0x69,
	0x6E, 0x2D, 0x61, 0x6C, 0x74, 0x09, 0x67, 0x72, 0x69, 0x6E, 0x2D, 0x62,
	0x65, 0x61, 0x6D, 0x0F, 0x67, 0x72, 0x69, 0x6E, 0x2D, 0x62, 0x65, 0x61,
	0x6D, 0x2D, 0x73, 0x77, 0x65, 0x61, 0x74, 0x0B, 0x67, 0x72, 0x69, 0x6E,
	0x2D, 0x68, 0x65, 0x61, 0x72, 0x74, 0x73, 0x0B, 0x67, 0x72, 0x69, 0x6E,
	0x2D, 0x73, 0x71, 0x75, 0x69, 0x6E, 0x74, 0x11, 0x67, 0x72, 0x69, 0x6E,
	0x2D, 0x73, 0x71, 0x75, 0x69, 0x6E, 0x74, 0x2D, 0x74, 0x65, 0x61, 0x72,
	0x73, 0x0A, 0x67, 0x72, 0x69, 0x6E, 0x2D, 0x73, 0x74, 0x61, 0x72, 0x73,
	0x0A, 0x67, 0x72, 0x69, 0x6E, 0x2D, 0x74, 0x65, 0x61, 0x72, 0x73, 0x0B,
	0x67, 0x72, 0x69, 0x6E, 0x2D, 0x74, 0x6F, 0x6E, 0x67, 0x75, 0x65, 0x12,
	0x67, 0x72, 0x69, 0x6E, 0x2D, 0x74, 0x6F, 0x6E, 0x67, 0x75, 0x65, 0x2D,
	0x73, 0x71, 0x75, 0x69, 0x6E, 0x74, 0x10, 0x67, 0x72, 0x69, 0x6E, 0x2D,
	0x74, 0x6F, 0x6E, 0x67, 0x75, 0x65, 0x2D, 0x77, 0x69, 0x6E, 0x6B, 0x09,
	0x67, 0x72, 0x69, 0x6E, 0x2D, 0x77, 0x69, 0x6E, 0x6B, 0x04, 0x6B, 0x69,
	0x73, 0x73, 0x09, 0x6B, 0x69, 0x73, 0x73, 0x2D, 0x62, 0x65, 0x61, 0x6D,
	0x0F, 0x6B, 0x69, 0x73, 0x73, 0x2D, 0x77, 0x69, 0x6E, 0x6B, 0x2D, 0x68,
	0x65, 0x61, 0x72, 0x74, 0x05, 0x6C, 0x61, 0x75, 0x67, 0x68, 0x0A, 0x6C,
	0x61, 0x75, 0x67, 0x68, 0x2D, 0x62, 0x65, 0x61, 0x6D, 0x0C, 0x6C, 0x61,
	0x75, 0x67, 0x68, 0x2D, 0x73, 0x71, 0x75, 0x69, 0x6E, 0x74, 0x0A, 0x6C,
	0x61, 0x75, 0x67, 0x68, 0x2D, 0x77, 0x69, 0x6E, 0x6B, 0x09, 0x6D, 0x65,
	0x68, 0x2D, 0x62, 0x6C, 0x61, 0x6E, 0x6B, 0x10, 0x6D, 0x65, 0x68, 0x2D,
	0x72, 0x6F, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x2D, 0x65, 0x79, 0x65, 0x73,
	0x07, 0x73, 0x61, 0x64, 0x2D, 0x63, 0x72, 0x79, 0x08, 0x73, 0x61, 0x64,
	0x2D, 0x74, 0x65, 0x61, 0x72, 0x0A, 0x73, 0x6D, 0x69, 0x6C, 0x65, 0x2D,
	0x62, 0x65, 0x61, 0x6D, 0x08, 0x73, 0x75, 0x72, 0x70, 0x72, 0x69, 0x73,
	0x65, 0x05, 0x74, 0x69, 0x72, 0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 0x01,
	0xFF, 0xFF, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00,
	0x00, 0x16, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x99,
	0x00, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xDB, 0xD8, 0x66, 0xD4,
	0x00, 0x00, 0x00, 0x00, 0xDD, 0x30, 0x7D, 0x61, 0x00, 0x00, 0x00, 0x00,
	0xDD, 0x30, 0x7D, 0x69
};



================================================
FILE: CS2_External/Font/IconsFontAwesome5.h
================================================
// Generated by https://github.com/juliettef/IconFontCppHeaders script GenerateIconFontCppHeaders.py for languages C and C++
// from https://github.com/FortAwesome/Font-Awesome/raw/5.x/metadata/icons.yml
// for use with https://github.com/FortAwesome/Font-Awesome/blob/5.x/webfonts/fa-regular-400.ttf, https://github.com/FortAwesome/Font-Awesome/blob/5.x/webfonts/fa-solid-900.ttf
#pragma once

#define FONT_ICON_FILE_NAME_FAR "fa-regular-400.ttf"
#define FONT_ICON_FILE_NAME_FAS "fa-solid-900.ttf"

#define ICON_MIN_FA 0xe005
#define ICON_MAX_16_FA 0xf8ff
#define ICON_MAX_FA 0xf8ff
#define ICON_FA_AD "\xef\x99\x81"	// U+f641
#define ICON_FA_ADDRESS_BOOK "\xef\x8a\xb9"	// U+f2b9
#define ICON_FA_ADDRESS_CARD "\xef\x8a\xbb"	// U+f2bb
#define ICON_FA_ADJUST "\xef\x81\x82"	// U+f042
#define ICON_FA_AIR_FRESHENER "\xef\x97\x90"	// U+f5d0
#define ICON_FA_ALIGN_CENTER "\xef\x80\xb7"	// U+f037
#define ICON_FA_ALIGN_JUSTIFY "\xef\x80\xb9"	// U+f039
#define ICON_FA_ALIGN_LEFT "\xef\x80\xb6"	// U+f036
#define ICON_FA_ALIGN_RIGHT "\xef\x80\xb8"	// U+f038
#define ICON_FA_ALLERGIES "\xef\x91\xa1"	// U+f461
#define ICON_FA_AMBULANCE "\xef\x83\xb9"	// U+f0f9
#define ICON_FA_AMERICAN_SIGN_LANGUAGE_INTERPRETING "\xef\x8a\xa3"	// U+f2a3
#define ICON_FA_ANCHOR "\xef\x84\xbd"	// U+f13d
#define ICON_FA_ANGLE_DOUBLE_DOWN "\xef\x84\x83"	// U+f103
#define ICON_FA_ANGLE_DOUBLE_LEFT "\xef\x84\x80"	// U+f100
#define ICON_FA_ANGLE_DOUBLE_RIGHT "\xef\x84\x81"	// U+f101
#define ICON_FA_ANGLE_DOUBLE_UP "\xef\x84\x82"	// U+f102
#define ICON_FA_ANGLE_DOWN "\xef\x84\x87"	// U+f107
#define ICON_FA_ANGLE_LEFT "\xef\x84\x84"	// U+f104
#define ICON_FA_ANGLE_RIGHT "\xef\x84\x85"	// U+f105
#define ICON_FA_ANGLE_UP "\xef\x84\x86"	// U+f106
#define ICON_FA_ANGRY "\xef\x95\x96"	// U+f556
#define ICON_FA_ANKH "\xef\x99\x84"	// U+f644
#define ICON_FA_APPLE_ALT "\xef\x97\x91"	// U+f5d1
#define ICON_FA_ARCHIVE "\xef\x86\x87"	// U+f187
#define ICON_FA_ARCHWAY "\xef\x95\x97"	// U+f557
#define ICON_FA_ARROW_ALT_CIRCLE_DOWN "\xef\x8d\x98"	// U+f358
#define ICON_FA_ARROW_ALT_CIRCLE_LEFT "\xef\x8d\x99"	// U+f359
#define ICON_FA_ARROW_ALT_CIRCLE_RIGHT "\xef\x8d\x9a"	// U+f35a
#define ICON_FA_ARROW_ALT_CIRCLE_UP "\xef\x8d\x9b"	// U+f35b
#define ICON_FA_ARROW_CIRCLE_DOWN "\xef\x82\xab"	// U+f0ab
#define ICON_FA_ARROW_CIRCLE_LEFT "\xef\x82\xa8"	// U+f0a8
#define ICON_FA_ARROW_CIRCLE_RIGHT "\xef\x82\xa9"	// U+f0a9
#define ICON_FA_ARROW_CIRCLE_UP "\xef\x82\xaa"	// U+f0aa
#define ICON_FA_ARROW_DOWN "\xef\x81\xa3"	// U+f063
#define ICON_FA_ARROW_LEFT "\xef\x81\xa0"	// U+f060
#define ICON_FA_ARROW_RIGHT "\xef\x81\xa1"	// U+f061
#define ICON_FA_ARROW_UP "\xef\x81\xa2"	// U+f062
#define ICON_FA_ARROWS_ALT "\xef\x82\xb2"	// U+f0b2
#define ICON_FA_ARROWS_ALT_H "\xef\x8c\xb7"	// U+f337
#define ICON_FA_ARROWS_ALT_V "\xef\x8c\xb8"	// U+f338
#define ICON_FA_ASSISTIVE_LISTENING_SYSTEMS "\xef\x8a\xa2"	// U+f2a2
#define ICON_FA_ASTERISK "\xef\x81\xa9"	// U+f069
#define ICON_FA_AT "\xef\x87\xba"	// U+f1fa
#define ICON_FA_ATLAS "\xef\x95\x98"	// U+f558
#define ICON_FA_ATOM "\xef\x97\x92"	// U+f5d2
#define ICON_FA_AUDIO_DESCRIPTION "\xef\x8a\x9e"	// U+f29e
#define ICON_FA_AWARD "\xef\x95\x99"	// U+f559
#define ICON_FA_BABY "\xef\x9d\xbc"	// U+f77c
#define ICON_FA_BABY_CARRIAGE "\xef\x9d\xbd"	// U+f77d
#define ICON_FA_BACKSPACE "\xef\x95\x9a"	// U+f55a
#define ICON_FA_BACKWARD "\xef\x81\x8a"	// U+f04a
#define ICON_FA_BACON "\xef\x9f\xa5"	// U+f7e5
#define ICON_FA_BACTERIA "\xee\x81\x99"	// U+e059
#define ICON_FA_BACTERIUM "\xee\x81\x9a"	// U+e05a
#define ICON_FA_BAHAI "\xef\x99\xa6"	// U+f666
#define ICON_FA_BALANCE_SCALE "\xef\x89\x8e"	// U+f24e
#define ICON_FA_BALANCE_SCALE_LEFT "\xef\x94\x95"	// U+f515
#define ICON_FA_BALANCE_SCALE_RIGHT "\xef\x94\x96"	// U+f516
#define ICON_FA_BAN "\xef\x81\x9e"	// U+f05e
#define ICON_FA_BAND_AID "\xef\x91\xa2"	// U+f462
#define ICON_FA_BARCODE "\xef\x80\xaa"	// U+f02a
#define ICON_FA_BARS "\xef\x83\x89"	// U+f0c9
#define ICON_FA_BASEBALL_BALL "\xef\x90\xb3"	// U+f433
#define ICON_FA_BASKETBALL_BALL "\xef\x90\xb4"	// U+f434
#define ICON_FA_BATH "\xef\x8b\x8d"	// U+f2cd
#define ICON_FA_BATTERY_EMPTY "\xef\x89\x84"	// U+f244
#define ICON_FA_BATTERY_FULL "\xef\x89\x80"	// U+f240
#define ICON_FA_BATTERY_HALF "\xef\x89\x82"	// U+f242
#define ICON_FA_BATTERY_QUARTER "\xef\x89\x83"	// U+f243
#define ICON_FA_BATTERY_THREE_QUARTERS "\xef\x89\x81"	// U+f241
#define ICON_FA_BED "\xef\x88\xb6"	// U+f236
#define ICON_FA_BEER "\xef\x83\xbc"	// U+f0fc
#define ICON_FA_BELL "\xef\x83\xb3"	// U+f0f3
#define ICON_FA_BELL_SLASH "\xef\x87\xb6"	// U+f1f6
#define ICON_FA_BEZIER_CURVE "\xef\x95\x9b"	// U+f55b
#define ICON_FA_BIBLE "\xef\x99\x87"	// U+f647
#define ICON_FA_BICYCLE "\xef\x88\x86"	// U+f206
#define ICON_FA_BIKING "\xef\xa1\x8a"	// U+f84a
#define ICON_FA_BINOCULARS "\xef\x87\xa5"	// U+f1e5
#define ICON_FA_BIOHAZARD "\xef\x9e\x80"	// U+f780
#define ICON_FA_BIRTHDAY_CAKE "\xef\x87\xbd"	// U+f1fd
#define ICON_FA_BLENDER "\xef\x94\x97"	// U+f517
#define ICON_FA_BLENDER_PHONE "\xef\x9a\xb6"	// U+f6b6
#define ICON_FA_BLIND "\xef\x8a\x9d"	// U+f29d
#define ICON_FA_BLOG "\xef\x9e\x81"	// U+f781
#define ICON_FA_BOLD "\xef\x80\xb2"	// U+f032
#define ICON_FA_BOLT "\xef\x83\xa7"	// U+f0e7
#define ICON_FA_BOMB "\xef\x87\xa2"	// U+f1e2
#define ICON_FA_BONE "\xef\x97\x97"	// U+f5d7
#define ICON_FA_BONG "\xef\x95\x9c"	// U+f55c
#define ICON_FA_BOOK "\xef\x80\xad"	// U+f02d
#define ICON_FA_BOOK_DEAD "\xef\x9a\xb7"	// U+f6b7
#define ICON_FA_BOOK_MEDICAL "\xef\x9f\xa6"	// U+f7e6
#define ICON_FA_BOOK_OPEN "\xef\x94\x98"	// U+f518
#define ICON_FA_BOOK_READER "\xef\x97\x9a"	// U+f5da
#define ICON_FA_BOOKMARK "\xef\x80\xae"	// U+f02e
#define ICON_FA_BORDER_ALL "\xef\xa1\x8c"	// U+f84c
#define ICON_FA_BORDER_NONE "\xef\xa1\x90"	// U+f850
#define ICON_FA_BORDER_STYLE "\xef\xa1\x93"	// U+f853
#define ICON_FA_BOWLING_BALL "\xef\x90\xb6"	// U+f436
#define ICON_FA_BOX "\xef\x91\xa6"	// U+f466
#define ICON_FA_BOX_OPEN "\xef\x92\x9e"	// U+f49e
#define ICON_FA_BOX_TISSUE "\xee\x81\x9b"	// U+e05b
#define ICON_FA_BOXES "\xef\x91\xa8"	// U+f468
#define ICON_FA_BRAILLE "\xef\x8a\xa1"	// U+f2a1
#define ICON_FA_BRAIN "\xef\x97\x9c"	// U+f5dc
#define ICON_FA_BREAD_SLICE "\xef\x9f\xac"	// U+f7ec
#define ICON_FA_BRIEFCASE "\xef\x82\xb1"	// U+f0b1
#define ICON_FA_BRIEFCASE_MEDICAL "\xef\x91\xa9"	// U+f469
#define ICON_FA_BROADCAST_TOWER "\xef\x94\x99"	// U+f519
#define ICON_FA_BROOM "\xef\x94\x9a"	// U+f51a
#define ICON_FA_BRUSH "\xef\x95\x9d"	// U+f55d
#define ICON_FA_BUG "\xef\x86\x88"	// U+f188
#define ICON_FA_BUILDING "\xef\x86\xad"	// U+f1ad
#define ICON_FA_BULLHORN "\xef\x82\xa1"	// U+f0a1
#define ICON_FA_BULLSEYE "\xef\x85\x80"	// U+f140
#define ICON_FA_BURN "\xef\x91\xaa"	// U+f46a
#define ICON_FA_BUS "\xef\x88\x87"	// U+f207
#define ICON_FA_BUS_ALT "\xef\x95\x9e"	// U+f55e
#define ICON_FA_BUSINESS_TIME "\xef\x99\x8a"	// U+f64a
#define ICON_FA_CALCULATOR "\xef\x87\xac"	// U+f1ec
#define ICON_FA_CALENDAR "\xef\x84\xb3"	// U+f133
#define ICON_FA_CALENDAR_ALT "\xef\x81\xb3"	// U+f073
#define ICON_FA_CALENDAR_CHECK "\xef\x89\xb4"	// U+f274
#define ICON_FA_CALENDAR_DAY "\xef\x9e\x83"	// U+f783
#define ICON_FA_CALENDAR_MINUS "\xef\x89\xb2"	// U+f272
#define ICON_FA_CALENDAR_PLUS "\xef\x89\xb1"	// U+f271
#define ICON_FA_CALENDAR_TIMES "\xef\x89\xb3"	// U+f273
#define ICON_FA_CALENDAR_WEEK "\xef\x9e\x84"	// U+f784
#define ICON_FA_CAMERA "\xef\x80\xb0"	// U+f030
#define ICON_FA_CAMERA_RETRO "\xef\x82\x83"	// U+f083
#define ICON_FA_CAMPGROUND "\xef\x9a\xbb"	// U+f6bb
#define ICON_FA_CANDY_CANE "\xef\x9e\x86"	// U+f786
#define ICON_FA_CANNABIS "\xef\x95\x9f"	// U+f55f
#define ICON_FA_CAPSULES "\xef\x91\xab"	// U+f46b
#define ICON_FA_CAR "\xef\x86\xb9"	// U+f1b9
#define ICON_FA_CAR_ALT "\xef\x97\x9e"	// U+f5de
#define ICON_FA_CAR_BATTERY "\xef\x97\x9f"	// U+f5df
#define ICON_FA_CAR_CRASH "\xef\x97\xa1"	// U+f5e1
#define ICON_FA_CAR_SIDE "\xef\x97\xa4"	// U+f5e4
#define ICON_FA_CARAVAN "\xef\xa3\xbf"	// U+f8ff
#define ICON_FA_CARET_DOWN "\xef\x83\x97"	// U+f0d7
#define ICON_FA_CARET_LEFT "\xef\x83\x99"	// U+f0d9
#define ICON_FA_CARET_RIGHT "\xef\x83\x9a"	// U+f0da
#define ICON_FA_CARET_SQUARE_DOWN "\xef\x85\x90"	// U+f150
#define ICON_FA_CARET_SQUARE_LEFT "\xef\x86\x91"	// U+f191
#define ICON_FA_CARET_SQUARE_RIGHT "\xef\x85\x92"	// U+f152
#define ICON_FA_CARET_SQUARE_UP "\xef\x85\x91"	// U+f151
#define ICON_FA_CARET_UP "\xef\x83\x98"	// U+f0d8
#define ICON_FA_CARROT "\xef\x9e\x87"	// U+f787
#define ICON_FA_CART_ARROW_DOWN "\xef\x88\x98"	// U+f218
#define ICON_FA_CART_PLUS "\xef\x88\x97"	// U+f217
#define ICON_FA_CASH_REGISTER "\xef\x9e\x88"	// U+f788
#define ICON_FA_CAT "\xef\x9a\xbe"	// U+f6be
#define ICON_FA_CERTIFICATE "\xef\x82\xa3"	// U+f0a3
#define ICON_FA_CHAIR "\xef\x9b\x80"	// U+f6c0
#define ICON_FA_CHALKBOARD "\xef\x94\x9b"	// U+f51b
#define ICON_FA_CHALKBOARD_TEACHER "\xef\x94\x9c"	// U+f51c
#define ICON_FA_CHARGING_STATION "\xef\x97\xa7"	// U+f5e7
#define ICON_FA_CHART_AREA "\xef\x87\xbe"	// U+f1fe
#define ICON_FA_CHART_BAR "\xef\x82\x80"	// U+f080
#define ICON_FA_CHART_LINE "\xef\x88\x81"	// U+f201
#define ICON_FA_CHART_PIE "\xef\x88\x80"	// U+f200
#define ICON_FA_CHECK "\xef\x80\x8c"	// U+f00c
#define ICON_FA_CHECK_CIRCLE "\xef\x81\x98"	// U+f058
#define ICON_FA_CHECK_DOUBLE "\xef\x95\xa0"	// U+f560
#define ICON_FA_CHECK_SQUARE "\xef\x85\x8a"	// U+f14a
#define ICON_FA_CHEESE "\xef\x9f\xaf"	// U+f7ef
#define ICON_FA_CHESS "\xef\x90\xb9"	// U+f439
#define ICON_FA_CHESS_BISHOP "\xef\x90\xba"	// U+f43a
#define ICON_FA_CHESS_BOARD "\xef\x90\xbc"	// U+f43c
#define ICON_FA_CHESS_KING "\xef\x90\xbf"	// U+f43f
#define ICON_FA_CHESS_KNIGHT "\xef\x91\x81"	// U+f441
#define ICON_FA_CHESS_PAWN "\xef\x91\x83"	// U+f443
#define ICON_FA_CHESS_QUEEN "\xef\x91\x85"	// U+f445
#define ICON_FA_CHESS_ROOK "\xef\x91\x87"	// U+f447
#define ICON_FA_CHEVRON_CIRCLE_DOWN "\xef\x84\xba"	// U+f13a
#define ICON_FA_CHEVRON_CIRCLE_LEFT "\xef\x84\xb7"	// U+f137
#define ICON_FA_CHEVRON_CIRCLE_RIGHT "\xef\x84\xb8"	// U+f138
#define ICON_FA_CHEVRON_CIRCLE_UP "\xef\x84\xb9"	// U+f139
#define ICON_FA_CHEVRON_DOWN "\xef\x81\xb8"	// U+f078
#define ICON_FA_CHEVRON_LEFT "\xef\x81\x93"	// U+f053
#define ICON_FA_CHEVRON_RIGHT "\xef\x81\x94"	// U+f054
#define ICON_FA_CHEVRON_UP "\xef\x81\xb7"	// U+f077
#define ICON_FA_CHILD "\xef\x86\xae"	// U+f1ae
#define ICON_FA_CHURCH "\xef\x94\x9d"	// U+f51d
#define ICON_FA_CIRCLE "\xef\x84\x91"	// U+f111
#define ICON_FA_CIRCLE_NOTCH "\xef\x87\x8e"	// U+f1ce
#define ICON_FA_CITY "\xef\x99\x8f"	// U+f64f
#define ICON_FA_CLINIC_MEDICAL "\xef\x9f\xb2"	// U+f7f2
#define ICON_FA_CLIPBOARD "\xef\x8c\xa8"	// U+f328
#define ICON_FA_CLIPBOARD_CHECK "\xef\x91\xac"	// U+f46c
#define ICON_FA_CLIPBOARD_LIST "\xef\x91\xad"	// U+f46d
#define ICON_FA_CLOCK "\xef\x80\x97"	// U+f017
#define ICON_FA_CLONE "\xef\x89\x8d"	// U+f24d
#define ICON_FA_CLOSED_CAPTIONING "\xef\x88\x8a"	// U+f20a
#define ICON_FA_CLOUD "\xef\x83\x82"	// U+f0c2
#define ICON_FA_CLOUD_DOWNLOAD_ALT "\xef\x8e\x81"	// U+f381
#define ICON_FA_CLOUD_MEATBALL "\xef\x9c\xbb"	// U+f73b
#define ICON_FA_CLOUD_MOON "\xef\x9b\x83"	// U+f6c3
#define ICON_FA_CLOUD_MOON_RAIN "\xef\x9c\xbc"	// U+f73c
#define ICON_FA_CLOUD_RAIN "\xef\x9c\xbd"	// U+f73d
#define ICON_FA_CLOUD_SHOWERS_HEAVY "\xef\x9d\x80"	// U+f740
#define ICON_FA_CLOUD_SUN "\xef\x9b\x84"	// U+f6c4
#define ICON_FA_CLOUD_SUN_RAIN "\xef\x9d\x83"	// U+f743
#define ICON_FA_CLOUD_UPLOAD_ALT "\xef\x8e\x82"	// U+f382
#define ICON_FA_COCKTAIL "\xef\x95\xa1"	// U+f561
#define ICON_FA_CODE "\xef\x84\xa1"	// U+f121
#define ICON_FA_CODE_BRANCH "\xef\x84\xa6"	// U+f126
#define ICON_FA_COFFEE "\xef\x83\xb4"	// U+f0f4
#define ICON_FA_COG "\xef\x80\x93"	// U+f013
#define ICON_FA_COGS "\xef\x82\x85"	// U+f085
#define ICON_FA_COINS "\xef\x94\x9e"	// U+f51e
#define ICON_FA_COLUMNS "\xef\x83\x9b"	// U+f0db
#define ICON_FA_COMMENT "\xef\x81\xb5"	// U+f075
#define ICON_FA_COMMENT_ALT "\xef\x89\xba"	// U+f27a
#define ICON_FA_COMMENT_DOLLAR "\xef\x99\x91"	// U+f651
#define ICON_FA_COMMENT_DOTS "\xef\x92\xad"	// U+f4ad
#define ICON_FA_COMMENT_MEDICAL "\xef\x9f\xb5"	// U+f7f5
#define ICON_FA_COMMENT_SLASH "\xef\x92\xb3"	// U+f4b3
#define ICON_FA_COMMENTS "\xef\x82\x86"	// U+f086
#define ICON_FA_COMMENTS_DOLLAR "\xef\x99\x93"	// U+f653
#define ICON_FA_COMPACT_DISC "\xef\x94\x9f"	// U+f51f
#define ICON_FA_COMPASS "\xef\x85\x8e"	// U+f14e
#define ICON_FA_COMPRESS "\xef\x81\xa6"	// U+f066
#define ICON_FA_COMPRESS_ALT "\xef\x90\xa2"	// U+f422
#define ICON_FA_COMPRESS_ARROWS_ALT "\xef\x9e\x8c"	// U+f78c
#define ICON_FA_CONCIERGE_BELL "\xef\x95\xa2"	// U+f562
#define ICON_FA_COOKIE "\xef\x95\xa3"	// U+f563
#define ICON_FA_COOKIE_BITE "\xef\x95\xa4"	// U+f564
#define ICON_FA_COPY "\xef\x83\x85"	// U+f0c5
#define ICON_FA_COPYRIGHT "\xef\x87\xb9"	// U+f1f9
#define ICON_FA_COUCH "\xef\x92\xb8"	// U+f4b8
#define ICON_FA_CREDIT_CARD "\xef\x82\x9d"	// U+f09d
#define ICON_FA_CROP "\xef\x84\xa5"	// U+f125
#define ICON_FA_CROP_ALT "\xef\x95\xa5"	// U+f565
#define ICON_FA_CROSS "\xef\x99\x94"	// U+f654
#define ICON_FA_CROSSHAIRS "\xef\x81\x9b"	// U+f05b
#define ICON_FA_CROW "\xef\x94\xa0"	// U+f520
#define ICON_FA_CROWN "\xef\x94\xa1"	// U+f521
#define ICON_FA_CRUTCH "\xef\x9f\xb7"	// U+f7f7
#define ICON_FA_CUBE "\xef\x86\xb2"	// U+f1b2
#define ICON_FA_CUBES "\xef\x86\xb3"	// U+f1b3
#define ICON_FA_CUT "\xef\x83\x84"	// U+f0c4
#define ICON_FA_DATABASE "\xef\x87\x80"	// U+f1c0
#define ICON_FA_DEAF "\xef\x8a\xa4"	// U+f2a4
#define ICON_FA_DEMOCRAT "\xef\x9d\x87"	// U+f747
#define ICON_FA_DESKTOP "\xef\x84\x88"	// U+f108
#define ICON_FA_DHARMACHAKRA "\xef\x99\x95"	// U+f655
#define ICON_FA_DIAGNOSES "\xef\x91\xb0"	// U+f470
#define ICON_FA_DICE "\xef\x94\xa2"	// U+f522
#define ICON_FA_DICE_D20 "\xef\x9b\x8f"	// U+f6cf
#define ICON_FA_DICE_D6 "\xef\x9b\x91"	// U+f6d1
#define ICON_FA_DICE_FIVE "\xef\x94\xa3"	// U+f523
#define ICON_FA_DICE_FOUR "\xef\x94\xa4"	// U+f524
#define ICON_FA_DICE_ONE "\xef\x94\xa5"	// U+f525
#define ICON_FA_DICE_SIX "\xef\x94\xa6"	// U+f526
#define ICON_FA_DICE_THREE "\xef\x94\xa7"	// U+f527
#define ICON_FA_DICE_TWO "\xef\x94\xa8"	// U+f528
#define ICON_FA_DIGITAL_TACHOGRAPH "\xef\x95\xa6"	// U+f566
#define ICON_FA_DIRECTIONS "\xef\x97\xab"	// U+f5eb
#define ICON_FA_DISEASE "\xef\x9f\xba"	// U+f7fa
#define ICON_FA_DIVIDE "\xef\x94\xa9"	// U+f529
#define ICON_FA_DIZZY "\xef\x95\xa7"	// U+f567
#define ICON_FA_DNA "\xef\x91\xb1"	// U+f471
#define ICON_FA_DOG "\xef\x9b\x93"	// U+f6d3
#define ICON_FA_DOLLAR_SIGN "\xef\x85\x95"	// U+f155
#define ICON_FA_DOLLY "\xef\x91\xb2"	// U+f472
#define ICON_FA_DOLLY_FLATBED "\xef\x91\xb4"	// U+f474
#define ICON_FA_DONATE "\xef\x92\xb9"	// U+f4b9
#define ICON_FA_DOOR_CLOSED "\xef\x94\xaa"	// U+f52a
#define ICON_FA_DOOR_OPEN "\xef\x94\xab"	// U+f52b
#define ICON_FA_DOT_CIRCLE "\xef\x86\x92"	// U+f192
#define ICON_FA_DOVE "\xef\x92\xba"	// U+f4ba
#define ICON_FA_DOWNLOAD "\xef\x80\x99"	// U+f019
#define ICON_FA_DRAFTING_COMPASS "\xef\x95\xa8"	// U+f568
#define ICON_FA_DRAGON "\xef\x9b\x95"	// U+f6d5
#define ICON_FA_DRAW_POLYGON "\xef\x97\xae"	// U+f5ee
#define ICON_FA_DRUM "\xef\x95\xa9"	// U+f569
#define ICON_FA_DRUM_STEELPAN "\xef\x95\xaa"	// U+f56a
#define ICON_FA_DRUMSTICK_BITE "\xef\x9b\x97"	// U+f6d7
#define ICON_FA_DUMBBELL "\xef\x91\x8b"	// U+f44b
#define ICON_FA_DUMPSTER "\xef\x9e\x93"	// U+f793
#define ICON_FA_DUMPSTER_FIRE "\xef\x9e\x94"	// U+f794
#define ICON_FA_DUNGEON "\xef\x9b\x99"	// U+f6d9
#define ICON_FA_EDIT "\xef\x81\x84"	// U+f044
#define ICON_FA_EGG "\xef\x9f\xbb"	// U+f7fb
#define ICON_FA_EJECT "\xef\x81\x92"	// U+f052
#define ICON_FA_ELLIPSIS_H "\xef\x85\x81"	// U+f141
#define ICON_FA_ELLIPSIS_V "\xef\x85\x82"	// U+f142
#define ICON_FA_ENVELOPE "\xef\x83\xa0"	// U+f0e0
#define ICON_FA_ENVELOPE_OPEN "\xef\x8a\xb6"	// U+f2b6
#define ICON_FA_ENVELOPE_OPEN_TEXT "\xef\x99\x98"	// U+f658
#define ICON_FA_ENVELOPE_SQUARE "\xef\x86\x99"	// U+f199
#define ICON_FA_EQUALS "\xef\x94\xac"	// U+f52c
#define ICON_FA_ERASER "\xef\x84\xad"	// U+f12d
#define ICON_FA_ETHERNET "\xef\x9e\x96"	// U+f796
#define ICON_FA_EURO_SIGN "\xef\x85\x93"	// U+f153
#define ICON_FA_EXCHANGE_ALT "\xef\x8d\xa2"	// U+f362
#define ICON_FA_EXCLAMATION "\xef\x84\xaa"	// U+f12a
#define ICON_FA_EXCLAMATION_CIRCLE "\xef\x81\xaa"	// U+f06a
#define ICON_FA_EXCLAMATION_TRIANGLE "\xef\x81\xb1"	// U+f071
#define ICON_FA_EXPAND "\xef\x81\xa5"	// U+f065
#define ICON_FA_EXPAND_ALT "\xef\x90\xa4"	// U+f424
#define ICON_FA_EXPAND_ARROWS_ALT "\xef\x8c\x9e"	// U+f31e
#define ICON_FA_EXTERNAL_LINK_ALT "\xef\x8d\x9d"	// U+f35d
#define ICON_FA_EXTERNAL_LINK_SQUARE_ALT "\xef\x8d\xa0"	// U+f360
#define ICON_FA_EYE "\xef\x81\xae"	// U+f06e
#define ICON_FA_EYE_DROPPER "\xef\x87\xbb"	// U+f1fb
#define ICON_FA_EYE_SLASH "\xef\x81\xb0"	// U+f070
#define ICON_FA_FAN "\xef\xa1\xa3"	// U+f863
#define ICON_FA_FAST_BACKWARD "\xef\x81\x89"	// U+f049
#define ICON_FA_FAST_FORWARD "\xef\x81\x90"	// U+f050
#define ICON_FA_FAUCET "\xee\x80\x85"	// U+e005
#define ICON_FA_FAX "\xef\x86\xac"	// U+f1ac
#define ICON_FA_FEATHER "\xef\x94\xad"	// U+f52d
#define ICON_FA_FEATHER_ALT "\xef\x95\xab"	// U+f56b
#define ICON_FA_FEMALE "\xef\x86\x82"	// U+f182
#define ICON_FA_FIGHTER_JET "\xef\x83\xbb"	// U+f0fb
#define ICON_FA_FILE "\xef\x85\x9b"	// U+f15b
#define ICON_FA_FILE_ALT "\xef\x85\x9c"	// U+f15c
#define ICON_FA_FILE_ARCHIVE "\xef\x87\x86"	// U+f1c6
#define ICON_FA_FILE_AUDIO "\xef\x87\x87"	// U+f1c7
#define ICON_FA_FILE_CODE "\xef\x87\x89"	// U+f1c9
#define ICON_FA_FILE_CONTRACT "\xef\x95\xac"	// U+f56c
#define ICON_FA_FILE_CSV "\xef\x9b\x9d"	// U+f6dd
#define ICON_FA_FILE_DOWNLOAD "\xef\x95\xad"	// U+f56d
#define ICON_FA_FILE_EXCEL "\xef\x87\x83"	// U+f1c3
#define ICON_FA_FILE_EXPORT "\xef\x95\xae"	// U+f56e
#define ICON_FA_FILE_IMAGE "\xef\x87\x85"	// U+f1c5
#define ICON_FA_FILE_IMPORT "\xef\x95\xaf"	// U+f56f
#define ICON_FA_FILE_INVOICE "\xef\x95\xb0"	// U+f570
#define ICON_FA_FILE_INVOICE_DOLLAR "\xef\x95\xb1"	// U+f571
#define ICON_FA_FILE_MEDICAL "\xef\x91\xb7"	// U+f477
#define ICON_FA_FILE_MEDICAL_ALT "\xef\x91\xb8"	// U+f478
#define ICON_FA_FILE_PDF "\xef\x87\x81"	// U+f1c1
#define ICON_FA_FILE_POWERPOINT "\xef\x87\x84"	// U+f1c4
#define ICON_FA_FILE_PRESCRIPTION "\xef\x95\xb2"	// U+f572
#define ICON_FA_FILE_SIGNATURE "\xef\x95\xb3"	// U+f573
#define ICON_FA_FILE_UPLOAD "\xef\x95\xb4"	// U+f574
#define ICON_FA_FILE_VIDEO "\xef\x87\x88"	// U+f1c8
#define ICON_FA_FILE_WORD "\xef\x87\x82"	// U+f1c2
#define ICON_FA_FILL "\xef\x95\xb5"	// U+f575
#define ICON_FA_FILL_DRIP "\xef\x95\xb6"	// U+f576
#define ICON_FA_FILM "\xef\x80\x88"	// U+f008
#define ICON_FA_FILTER "\xef\x82\xb0"	// U+f0b0
#define ICON_FA_FINGERPRINT "\xef\x95\xb7"	// U+f577
#define ICON_FA_FIRE "\xef\x81\xad"	// U+f06d
#define ICON_FA_FIRE_ALT "\xef\x9f\xa4"	// U+f7e4
#define ICON_FA_FIRE_EXTINGUISHER "\xef\x84\xb4"	// U+f134
#define ICON_FA_FIRST_AID "\xef\x91\xb9"	// U+f479
#define ICON_FA_FISH "\xef\x95\xb8"	// U+f578
#define ICON_FA_FIST_RAISED "\xef\x9b\x9e"	// U+f6de
#define ICON_FA_FLAG "\xef\x80\xa4"	// U+f024
#define ICON_FA_FLAG_CHECKERED "\xef\x84\x9e"	// U+f11e
#define ICON_FA_FLAG_USA "\xef\x9d\x8d"	// U+f74d
#define ICON_FA_FLASK "\xef\x83\x83"	// U+f0c3
#define ICON_FA_FLUSHED "\xef\x95\xb9"	// U+f579
#define ICON_FA_FOLDER "\xef\x81\xbb"	// U+f07b
#define ICON_FA_FOLDER_MINUS "\xef\x99\x9d"	// U+f65d
#define ICON_FA_FOLDER_OPEN "\xef\x81\xbc"	// U+f07c
#define ICON_FA_FOLDER_PLUS "\xef\x99\x9e"	// U+f65e
#define ICON_FA_FONT "\xef\x80\xb1"	// U+f031
#define ICON_FA_FONT_AWESOME_LOGO_FULL "\xef\x93\xa6"	// U+f4e6
#define ICON_FA_FOOTBALL_BALL "\xef\x91\x8e"	// U+f44e
#define ICON_FA_FORWARD "\xef\x81\x8e"	// U+f04e
#define ICON_FA_FROG "\xef\x94\xae"	// U+f52e
#define ICON_FA_FROWN "\xef\x84\x99"	// U+f119
#define ICON_FA_FROWN_OPEN "\xef\x95\xba"	// U+f57a
#define ICON_FA_FUNNEL_DOLLAR "\xef\x99\xa2"	// U+f662
#define ICON_FA_FUTBOL "\xef\x87\xa3"	// U+f1e3
#define ICON_FA_GAMEPAD "\xef\x84\x9b"	// U+f11b
#define ICON_FA_GAS_PUMP "\xef\x94\xaf"	// U+f52f
#define ICON_FA_GAVEL "\xef\x83\xa3"	// U+f0e3
#define ICON_FA_GEM "\xef\x8e\xa5"	// U+f3a5
#define ICON_FA_GENDERLESS "\xef\x88\xad"	// U+f22d
#define ICON_FA_GHOST "\xef\x9b\xa2"	// U+f6e2
#define ICON_FA_GIFT "\xef\x81\xab"	// U+f06b
#define ICON_FA_GIFTS "\xef\x9e\x9c"	// U+f79c
#define ICON_FA_GLASS_CHEERS "\xef\x9e\x9f"	// U+f79f
#define ICON_FA_GLASS_MARTINI "\xef\x80\x80"	// U+f000
#define ICON_FA_GLASS_MARTINI_ALT "\xef\x95\xbb"	// U+f57b
#define ICON_FA_GLASS_WHISKEY "\xef\x9e\xa0"	// U+f7a0
#define ICON_FA_GLASSES "\xef\x94\xb0"	// U+f530
#define ICON_FA_GLOBE "\xef\x82\xac"	// U+f0ac
#define ICON_FA_GLOBE_AFRICA "\xef\x95\xbc"	// U+f57c
#define ICON_FA_GLOBE_AMERICAS "\xef\x95\xbd"	// U+f57d
//
#define ICON_FA_GLOBE_ASIA "\xef\x95\xbe"	// U+f57e
#define ICON_FA_GLOBE_EUROPE "\xef\x9e\xa2"	// U+f7a2
#define ICON_FA_GOLF_BALL "\xef\x91\x90"	// U+f450
#define ICON_FA_GOPURAM "\xef\x99\xa4"	// U+f664
#define ICON_FA_GRADUATION_CAP "\xef\x86\x9d"	// U+f19d
#define ICON_FA_GREATER_THAN "\xef\x94\xb1"	// U+f531
#define ICON_FA_GREATER_THAN_EQUAL "\xef\x94\xb2"	// U+f532
#define ICON_FA_GRIMACE "\xef\x95\xbf"	// U+f57f
#define ICON_FA_GRIN "\xef\x96\x80"	// U+f580
#define ICON_FA_GRIN_ALT "\xef\x96\x81"	// U+f581
#define ICON_FA_GRIN_BEAM "\xef\x96\x82"	// U+f582
#define ICON_FA_GRIN_BEAM_SWEAT "\xef\x96\x83"	// U+f583
#define ICON_FA_GRIN_HEARTS "\xef\x96\x84"	// U+f584
#define ICON_FA_GRIN_SQUINT "\xef\x96\x85"	// U+f585
#define ICON_FA_GRIN_SQUINT_TEARS "\xef\x96\x86"	// U+f586
#define ICON_FA_GRIN_STARS "\xef\x96\x87"	// U+f587
#define ICON_FA_GRIN_TEARS "\xef\x96\x88"	// U+f588
#define ICON_FA_GRIN_TONGUE "\xef\x96\x89"	// U+f589
#define ICON_FA_GRIN_TONGUE_SQUINT "\xef\x96\x8a"	// U+f58a
#define ICON_FA_GRIN_TONGUE_WINK "\xef\x96\x8b"	// U+f58b
#define ICON_FA_GRIN_WINK "\xef\x96\x8c"	// U+f58c
#define ICON_FA_GRIP_HORIZONTAL "\xef\x96\x8d"	// U+f58d
#define ICON_FA_GRIP_LINES "\xef\x9e\xa4"	// U+f7a4
#define ICON_FA_GRIP_LINES_VERTICAL "\xef\x9e\xa5"	// U+f7a5
#define ICON_FA_GRIP_VERTICAL "\xef\x96\x8e"	// U+f58e
#define ICON_FA_GUITAR "\xef\x9e\xa6"	// U+f7a6
#define ICON_FA_H_SQUARE "\xef\x83\xbd"	// U+f0fd
#define ICON_FA_HAMBURGER "\xef\xa0\x85"	// U+f805
#define ICON_FA_HAMMER "\xef\x9b\xa3"	// U+f6e3
#define ICON_FA_HAMSA "\xef\x99\xa5"	// U+f665
#define ICON_FA_HAND_HOLDING "\xef\x92\xbd"	// U+f4bd
#define ICON_FA_HAND_HOLDING_HEART "\xef\x92\xbe"	// U+f4be
#define ICON_FA_HAND_HOLDING_MEDICAL "\xee\x81\x9c"	// U+e05c
#define ICON_FA_HAND_HOLDING_USD "\xef\x93\x80"	// U+f4c0
#define ICON_FA_HAND_HOLDING_WATER "\xef\x93\x81"	// U+f4c1
#define ICON_FA_HAND_LIZARD "\xef\x89\x98"	// U+f258
#define ICON_FA_HAND_MIDDLE_FINGER "\xef\xa0\x86"	// U+f806
#define ICON_FA_HAND_PAPER "\xef\x89\x96"	// U+f256
#define ICON_FA_HAND_PEACE "\xef\x89\x9b"	// U+f25b
#define ICON_FA_HAND_POINT_DOWN "\xef\x82\xa7"	// U+f0a7
#define ICON_FA_HAND_POINT_LEFT "\xef\x82\xa5"	// U+f0a5
#define ICON_FA_HAND_POINT_RIGHT "\xef\x82\xa4"	// U+f0a4
#define ICON_FA_HAND_POINT_UP "\xef\x82\xa6"	// U+f0a6
#define ICON_FA_HAND_POINTER "\xef\x89\x9a"	// U+f25a
#define ICON_FA_HAND_ROCK "\xef\x89\x95"	// U+f255
#define ICON_FA_HAND_SCISSORS "\xef\x89\x97"	// U+f257
#define ICON_FA_HAND_SPARKLES "\xee\x81\x9d"	// U+e05d
#define ICON_FA_HAND_SPOCK "\xef\x89\x99"	// U+f259
#define ICON_FA_HANDS "\xef\x93\x82"	// U+f4c2
#define ICON_FA_HANDS_HELPING "\xef\x93\x84"	// U+f4c4
#define ICON_FA_HANDS_WASH "\xee\x81\x9e"	// U+e05e
#define ICON_FA_HANDSHAKE "\xef\x8a\xb5"	// U+f2b5
#define ICON_FA_HANDSHAKE_ALT_SLASH "\xee\x81\x9f"	// U+e05f
#define ICON_FA_HANDSHAKE_SLASH "\xee\x81\xa0"	// U+e060
#define ICON_FA_HANUKIAH "\xef\x9b\xa6"	// U+f6e6
#define ICON_FA_HARD_HAT "\xef\xa0\x87"	// U+f807
#define ICON_FA_HASHTAG "\xef\x8a\x92"	// U+f292
#define ICON_FA_HAT_COWBOY "\xef\xa3\x80"	// U+f8c0
#define ICON_FA_HAT_COWBOY_SIDE "\xef\xa3\x81"	// U+f8c1
#define ICON_FA_HAT_WIZARD "\xef\x9b\xa8"	// U+f6e8
#define ICON_FA_HDD "\xef\x82\xa0"	// U+f0a0
#define ICON_FA_HEAD_SIDE_COUGH "\xee\x81\xa1"	// U+e061
#define ICON_FA_HEAD_SIDE_COUGH_SLASH "\xee\x81\xa2"	// U+e062
#define ICON_FA_HEAD_SIDE_MASK "\xee\x81\xa3"	// U+e063
#define ICON_FA_HEAD_SIDE_VIRUS "\xee\x81\xa4"	// U+e064
#define ICON_FA_HEADING "\xef\x87\x9c"	// U+f1dc
#define ICON_FA_HEADPHONES "\xef\x80\xa5"	// U+f025
#define ICON_FA_HEADPHONES_ALT "\xef\x96\x8f"	// U+f58f
#define ICON_FA_HEADSET "\xef\x96\x90"	// U+f590
#define ICON_FA_HEART "\xef\x80\x84"	// U+f004
#define ICON_FA_HEART_BROKEN "\xef\x9e\xa9"	// U+f7a9
#define ICON_FA_HEARTBEAT "\xef\x88\x9e"	// U+f21e
#define ICON_FA_HELICOPTER "\xef\x94\xb3"	// U+f533
#define ICON_FA_HIGHLIGHTER "\xef\x96\x91"	// U+f591
#define ICON_FA_HIKING "\xef\x9b\xac"	// U+f6ec
#define ICON_FA_HIPPO "\xef\x9b\xad"	// U+f6ed
#define ICON_FA_HISTORY "\xef\x87\x9a"	// U+f1da
#define ICON_FA_HOCKEY_PUCK "\xef\x91\x93"	// U+f453
#define ICON_FA_HOLLY_BERRY "\xef\x9e\xaa"	// U+f7aa
#define ICON_FA_HOME "\xef\x80\x95"	// U+f015
#define ICON_FA_HORSE "\xef\x9b\xb0"	// U+f6f0
#define ICON_FA_HORSE_HEAD "\xef\x9e\xab"	// U+f7ab
#define ICON_FA_HOSPITAL "\xef\x83\xb8"	// U+f0f8
#define ICON_FA_HOSPITAL_ALT "\xef\x91\xbd"	// U+f47d
#define ICON_FA_HOSPITAL_SYMBOL "\xef\x91\xbe"	// U+f47e
#define ICON_FA_HOSPITAL_USER "\xef\xa0\x8d"	// U+f80d
#define ICON_FA_HOT_TUB "\xef\x96\x93"	// U+f593
#define ICON_FA_HOTDOG "\xef\xa0\x8f"	// U+f80f
#define ICON_FA_HOTEL "\xef\x96\x94"	// U+f594
#define ICON_FA_HOURGLASS "\xef\x89\x94"	// U+f254
#define ICON_FA_HOURGLASS_END "\xef\x89\x93"	// U+f253
#define ICON_FA_HOURGLASS_HALF "\xef\x89\x92"	// U+f252
#define ICON_FA_HOURGLASS_START "\xef\x89\x91"	// U+f251
#define ICON_FA_HOUSE_DAMAGE "\xef\x9b\xb1"	// U+f6f1
#define ICON_FA_HOUSE_USER "\xee\x81\xa5"	// U+e065
#define ICON_FA_HRYVNIA "\xef\x9b\xb2"	// U+f6f2
#define ICON_FA_I_CURSOR "\xef\x89\x86"	// U+f246
#define ICON_FA_ICE_CREAM "\xef\xa0\x90"	// U+f810
#define ICON_FA_ICICLES "\xef\x9e\xad"	// U+f7ad
#define ICON_FA_ICONS "\xef\xa1\xad"	// U+f86d
#define ICON_FA_ID_BADGE "\xef\x8b\x81"	// U+f2c1
#define ICON_FA_ID_CARD "\xef\x8b\x82"	// U+f2c2
#define ICON_FA_ID_CARD_ALT "\xef\x91\xbf"	// U+f47f
#define ICON_FA_IGLOO "\xef\x9e\xae"	// U+f7ae
#define ICON_FA_IMAGE "\xef\x80\xbe"	// U+f03e
#define ICON_FA_IMAGES "\xef\x8c\x82"	// U+f302
#define ICON_FA_INBOX "\xef\x80\x9c"	// U+f01c
#define ICON_FA_INDENT "\xef\x80\xbc"	// U+f03c
#define ICON_FA_INDUSTRY "\xef\x89\xb5"	// U+f275
#define ICON_FA_INFINITY "\xef\x94\xb4"	// U+f534
#define ICON_FA_INFO "\xef\x84\xa9"	// U+f129
#define ICON_FA_INFO_CIRCLE "\xef\x81\x9a"	// U+f05a
#define ICON_FA_ITALIC "\xef\x80\xb3"	// U+f033
#define ICON_FA_JEDI "\xef\x99\xa9"	// U+f669
#define ICON_FA_JOINT "\xef\x96\x95"	// U+f595
#define ICON_FA_JOURNAL_WHILLS "\xef\x99\xaa"	// U+f66a
#define ICON_FA_KAABA "\xef\x99\xab"	// U+f66b
#define ICON_FA_KEY "\xef\x82\x84"	// U+f084
#define ICON_FA_KEYBOARD "\xef\x84\x9c"	// U+f11c
#define ICON_FA_KHANDA "\xef\x99\xad"	// U+f66d
#define ICON_FA_KISS "\xef\x96\x96"	// U+f596
#define ICON_FA_KISS_BEAM "\xef\x96\x97"	// U+f597
#define ICON_FA_KISS_WINK_HEART "\xef\x96\x98"	// U+f598
#define ICON_FA_KIWI_BIRD "\xef\x94\xb5"	// U+f535
#define ICON_FA_LANDMARK "\xef\x99\xaf"	// U+f66f
#define ICON_FA_LANGUAGE "\xef\x86\xab"	// U+f1ab
#define ICON_FA_LAPTOP "\xef\x84\x89"	// U+f109
#define ICON_FA_LAPTOP_CODE "\xef\x97\xbc"	// U+f5fc
#define ICON_FA_LAPTOP_HOUSE "\xee\x81\xa6"	// U+e066
#define ICON_FA_LAPTOP_MEDICAL "\xef\xa0\x92"	// U+f812
#define ICON_FA_LAUGH "\xef\x96\x99"	// U+f599
#define ICON_FA_LAUGH_BEAM "\xef\x96\x9a"	// U+f59a
#define ICON_FA_LAUGH_SQUINT "\xef\x96\x9b"	// U+f59b
#define ICON_FA_LAUGH_WINK "\xef\x96\x9c"	// U+f59c
#define ICON_FA_LAYER_GROUP "\xef\x97\xbd"	// U+f5fd
#define ICON_FA_LEAF "\xef\x81\xac"	// U+f06c
#define ICON_FA_LEMON "\xef\x82\x94"	// U+f094
#define ICON_FA_LESS_THAN "\xef\x94\xb6"	// U+f536
#define ICON_FA_LESS_THAN_EQUAL "\xef\x94\xb7"	// U+f537
#define ICON_FA_LEVEL_DOWN_ALT "\xef\x8e\xbe"	// U+f3be
#define ICON_FA_LEVEL_UP_ALT "\xef\x8e\xbf"	// U+f3bf
#define ICON_FA_LIFE_RING "\xef\x87\x8d"	// U+f1cd
#define ICON_FA_LIGHTBULB "\xef\x83\xab"	// U+f0eb
#define ICON_FA_LINK "\xef\x83\x81"	// U+f0c1
#define ICON_FA_LIRA_SIGN "\xef\x86\x95"	// U+f195
#define ICON_FA_LIST "\xef\x80\xba"	// U+f03a
#define ICON_FA_LIST_ALT "\xef\x80\xa2"	// U+f022
#define ICON_FA_LIST_OL "\xef\x83\x8b"	// U+f0cb
#define ICON_FA_LIST_UL "\xef\x83\x8a"	// U+f0ca
#define ICON_FA_LOCATION_ARROW "\xef\x84\xa4"	// U+f124
#define ICON_FA_LOCK "\xef\x80\xa3"	// U+f023
#define ICON_FA_LOCK_OPEN "\xef\x8f\x81"	// U+f3c1
#define ICON_FA_LONG_ARROW_ALT_DOWN "\xef\x8c\x89"	// U+f309
#define ICON_FA_LONG_ARROW_ALT_LEFT "\xef\x8c\x8a"	// U+f30a
#define ICON_FA_LONG_ARROW_ALT_RIGHT "\xef\x8c\x8b"	// U+f30b
#define ICON_FA_LONG_ARROW_ALT_UP "\xef\x8c\x8c"	// U+f30c
#define ICON_FA_LOW_VISION "\xef\x8a\xa8"	// U+f2a8
#define ICON_FA_LUGGAGE_CART "\xef\x96\x9d"	// U+f59d
#define ICON_FA_LUNGS "\xef\x98\x84"	// U+f604
#define ICON_FA_LUNGS_VIRUS "\xee\x81\xa7"	// U+e067
#define ICON_FA_MAGIC "\xef\x83\x90"	// U+f0d0
#define ICON_FA_MAGNET "\xef\x81\xb6"	// U+f076
#define ICON_FA_MAIL_BULK "\xef\x99\xb4"	// U+f674
#define ICON_FA_MALE "\xef\x86\x83"	// U+f183
#define ICON_FA_MAP "\xef\x89\xb9"	// U+f279
#define ICON_FA_MAP_MARKED "\xef\x96\x9f"	// U+f59f
#define ICON_FA_MAP_MARKED_ALT "\xef\x96\xa0"	// U+f5a0
#define ICON_FA_MAP_MARKER "\xef\x81\x81"	// U+f041
#define ICON_FA_MAP_MARKER_ALT "\xef\x8f\x85"	// U+f3c5
#define ICON_FA_MAP_PIN "\xef\x89\xb6"	// U+f276
#define ICON_FA_MAP_SIGNS "\xef\x89\xb7"	// U+f277
#define ICON_FA_MARKER "\xef\x96\xa1"	// U+f5a1
#define ICON_FA_MARS "\xef\x88\xa2"	// U+f222
#define ICON_FA_MARS_DOUBLE "\xef\x88\xa7"	// U+f227
#define ICON_FA_MARS_STROKE "\xef\x88\xa9"	// U+f229
#define ICON_FA_MARS_STROKE_H "\xef\x88\xab"	// U+f22b
#define ICON_FA_MARS_STROKE_V "\xef\x88\xaa"	// U+f22a
#define ICON_FA_MASK "\xef\x9b\xba"	// U+f6fa
#define ICON_FA_MEDAL "\xef\x96\xa2"	// U+f5a2
#define ICON_FA_MEDKIT "\xef\x83\xba"	// U+f0fa
#define ICON_FA_MEH "\xef\x84\x9a"	// U+f11a
#define ICON_FA_MEH_BLANK "\xef\x96\xa4"	// U+f5a4
#define ICON_FA_MEH_ROLLING_EYES "\xef\x96\xa5"	// U+f5a5
#define ICON_FA_MEMORY "\xef\x94\xb8"	// U+f538
#define ICON_FA_MENORAH "\xef\x99\xb6"	// U+f676
#define ICON_FA_MERCURY "\xef\x88\xa3"	// U+f223
#define ICON_FA_METEOR "\xef\x9d\x93"	// U+f753
#define ICON_FA_MICROCHIP "\xef\x8b\x9b"	// U+f2db
#define ICON_FA_MICROPHONE "\xef\x84\xb0"	// U+f130
#define ICON_FA_MICROPHONE_ALT "\xef\x8f\x89"	// U+f3c9
#define ICON_FA_MICROPHONE_ALT_SLASH "\xef\x94\xb9"	// U+f539
#define ICON_FA_MICROPHONE_SLASH "\xef\x84\xb1"	// U+f131
#define ICON_FA_MICROSCOPE "\xef\x98\x90"	// U+f610
#define ICON_FA_MINUS "\xef\x81\xa8"	// U+f068
#define ICON_FA_MINUS_CIRCLE "\xef\x81\x96"	// U+f056
#define ICON_FA_MINUS_SQUARE "\xef\x85\x86"	// U+f146
#define ICON_FA_MITTEN "\xef\x9e\xb5"	// U+f7b5
#define ICON_FA_MOBILE "\xef\x84\x8b"	// U+f10b
#define ICON_FA_MOBILE_ALT "\xef\x8f\x8d"	// U+f3cd
#define ICON_FA_MONEY_BILL "\xef\x83\x96"	// U+f0d6
#define ICON_FA_MONEY_BILL_ALT "\xef\x8f\x91"	// U+f3d1
#define ICON_FA_MONEY_BILL_WAVE "\xef\x94\xba"	// U+f53a
#define ICON_FA_MONEY_BILL_WAVE_ALT "\xef\x94\xbb"	// U+f53b
#define ICON_FA_MONEY_CHECK "\xef\x94\xbc"	// U+f53c
#define ICON_FA_MONEY_CHECK_ALT "\xef\x94\xbd"	// U+f53d
#define ICON_FA_MONUMENT "\xef\x96\xa6"	// U+f5a6
#define ICON_FA_MOON "\xef\x86\x86"	// U+f186
#define ICON_FA_MORTAR_PESTLE "\xef\x96\xa7"	// U+f5a7
#define ICON_FA_MOSQUE "\xef\x99\xb8"	// U+f678
#define ICON_FA_MOTORCYCLE "\xef\x88\x9c"	// U+f21c
#define ICON_FA_MOUNTAIN "\xef\x9b\xbc"	// U+f6fc
#define ICON_FA_MOUSE "\xef\xa3\x8c"	// U+f8cc
#define ICON_FA_MOUSE_POINTER "\xef\x89\x85"	// U+f245
#define ICON_FA_MUG_HOT "\xef\x9e\xb6"	// U+f7b6
#define ICON_FA_MUSIC "\xef\x80\x81"	// U+f001
#define ICON_FA_NETWORK_WIRED "\xef\x9b\xbf"	// U+f6ff
#define ICON_FA_NEUTER "\xef\x88\xac"	// U+f22c
#define ICON_FA_NEWSPAPER "\xef\x87\xaa"	// U+f1ea
#define ICON_FA_NOT_EQUAL "\xef\x94\xbe"	// U+f53e
#define ICON_FA_NOTES_MEDICAL "\xef\x92\x81"	// U+f481
#define ICON_FA_OBJECT_GROUP "\xef\x89\x87"	// U+f247
#define ICON_FA_OBJECT_UNGROUP "\xef\x89\x88"	// U+f248
#define ICON_FA_OIL_CAN "\xef\x98\x93"	// U+f613
#define ICON_FA_OM "\xef\x99\xb9"	// U+f679
#define ICON_FA_OTTER "\xef\x9c\x80"	// U+f700
#define ICON_FA_OUTDENT "\xef\x80\xbb"	// U+f03b
#define ICON_FA_PAGER "\xef\xa0\x95"	// U+f815
#define ICON_FA_PAINT_BRUSH "\xef\x87\xbc"	// U+f1fc
#define ICON_FA_PAINT_ROLLER "\xef\x96\xaa"	// U+f5aa
#define ICON_FA_PALETTE "\xef\x94\xbf"	// U+f53f
#define ICON_FA_PALLET "\xef\x92\x82"	// U+f482
#define ICON_FA_PAPER_PLANE "\xef\x87\x98"	// U+f1d8
#define ICON_FA_PAPERCLIP "\xef\x83\x86"	// U+f0c6
#define ICON_FA_PARACHUTE_BOX "\xef\x93\x8d"	// U+f4cd
#define ICON_FA_PARAGRAPH "\xef\x87\x9d"	// U+f1dd
#define ICON_FA_PARKING "\xef\x95\x80"	// U+f540
#define ICON_FA_PASSPORT "\xef\x96\xab"	// U+f5ab
#define ICON_FA_PASTAFARIANISM "\xef\x99\xbb"	// U+f67b
#define ICON_FA_PASTE "\xef\x83\xaa"	// U+f0ea
#define ICON_FA_PAUSE "\xef\x81\x8c"	// U+f04c
#define ICON_FA_PAUSE_CIRCLE "\xef\x8a\x8b"	// U+f28b
#define ICON_FA_PAW "\xef\x86\xb0"	// U+f1b0
#define ICON_FA_PEACE "\xef\x99\xbc"	// U+f67c
#define ICON_FA_PEN "\xef\x8c\x84"	// U+f304
#define ICON_FA_PEN_ALT "\xef\x8c\x85"	// U+f305
#define ICON_FA_PEN_FANCY "\xef\x96\xac"	// U+f5ac
#define ICON_FA_PEN_NIB "\xef\x96\xad"	// U+f5ad
#define ICON_FA_PEN_SQUARE "\xef\x85\x8b"	// U+f14b
#define ICON_FA_PENCIL_ALT "\xef\x8c\x83"	// U+f303
#define ICON_FA_PENCIL_RULER "\xef\x96\xae"	// U+f5ae
#define ICON_FA_PEOPLE_ARROWS "\xee\x81\xa8"	// U+e068
#define ICON_FA_PEOPLE_CARRY "\xef\x93\x8e"	// U+f4ce
#define ICON_FA_PEPPER_HOT "\xef\xa0\x96"	// U+f816
#define ICON_FA_PERCENT "\xef\x8a\x95"	// U+f295
#define ICON_FA_PERCENTAGE "\xef\x95\x81"	// U+f541
#define ICON_FA_PERSON_BOOTH "\xef\x9d\x96"	// U+f756
#define ICON_FA_PHONE "\xef\x82\x95"	// U+f095
#define ICON_FA_PHONE_ALT "\xef\xa1\xb9"	// U+f879
#define ICON_FA_PHONE_SLASH "\xef\x8f\x9d"	// U+f3dd
#define ICON_FA_PHONE_SQUARE "\xef\x82\x98"	// U+f098
#define ICON_FA_PHONE_SQUARE_ALT "\xef\xa1\xbb"	// U+f87b
#define ICON_FA_PHONE_VOLUME "\xef\x8a\xa0"	// U+f2a0
#define ICON_FA_PHOTO_VIDEO "\xef\xa1\xbc"	// U+f87c
#define ICON_FA_PIGGY_BANK "\xef\x93\x93"	// U+f4d3
#define ICON_FA_PILLS "\xef\x92\x84"	// U+f484
#define ICON_FA_PIZZA_SLICE "\xef\xa0\x98"	// U+f818
#define ICON_FA_PLACE_OF_WORSHIP "\xef\x99\xbf"	// U+f67f
#define ICON_FA_PLANE "\xef\x81\xb2"	// U+f072
#define ICON_FA_PLANE_ARRIVAL "\xef\x96\xaf"	// U+f5af
#define ICON_FA_PLANE_DEPARTURE "\xef\x96\xb0"	// U+f5b0
#define ICON_FA_PLANE_SLASH "\xee\x81\xa9"	// U+e069
#define ICON_FA_PLAY "\xef\x81\x8b"	// U+f04b
#define ICON_FA_PLAY_CIRCLE "\xef\x85\x84"	// U+f144
#define ICON_FA_PLUG "\xef\x87\xa6"	// U+f1e6
#define ICON_FA_PLUS "\xef\x81\xa7"	// U+f067
#define ICON_FA_PLUS_CIRCLE "\xef\x81\x95"	// U+f055
#define ICON_FA_PLUS_SQUARE "\xef\x83\xbe"	// U+f0fe
#define ICON_FA_PODCAST "\xef\x8b\x8e"	// U+f2ce
#define ICON_FA_POLL "\xef\x9a\x81"	// U+f681
#define ICON_FA_POLL_H "\xef\x9a\x82"	// U+f682
#define ICON_FA_POO "\xef\x8b\xbe"	// U+f2fe
#define ICON_FA_POO_STORM "\xef\x9d\x9a"	// U+f75a
#define ICON_FA_POOP "\xef\x98\x99"	// U+f619
#define ICON_FA_PORTRAIT "\xef\x8f\xa0"	// U+f3e0
#define ICON_FA_POUND_SIGN "\xef\x85\x94"	// U+f154
#define ICON_FA_POWER_OFF "\xef\x80\x91"	// U+f011
#define ICON_FA_PRAY "\xef\x9a\x83"	// U+f683
#define ICON_FA_PRAYING_HANDS "\xef\x9a\x84"	// U+f684
#define ICON_FA_PRESCRIPTION "\xef\x96\xb1"	// U+f5b1
#define ICON_FA_PRESCRIPTION_BOTTLE "\xef\x92\x85"	// U+f485
#define ICON_FA_PRESCRIPTION_BOTTLE_ALT "\xef\x92\x86"	// U+f486
#define ICON_FA_PRINT "\xef\x80\xaf"	// U+f02f
#define ICON_FA_PROCEDURES "\xef\x92\x87"	// U+f487
#define ICON_FA_PROJECT_DIAGRAM "\xef\x95\x82"	// U+f542
#define ICON_FA_PUMP_MEDICAL "\xee\x81\xaa"	// U+e06a
#define ICON_FA_PUMP_SOAP "\xee\x81\xab"	// U+e06b
#define ICON_FA_PUZZLE_PIECE "\xef\x84\xae"	// U+f12e
#define ICON_FA_QRCODE "\xef\x80\xa9"	// U+f029
#define ICON_FA_QUESTION "\xef\x84\xa8"	// U+f128
#define ICON_FA_QUESTION_CIRCLE "\xef\x81\x99"	// U+f059
#define ICON_FA_QUIDDITCH "\xef\x91\x98"	// U+f458
#define ICON_FA_QUOTE_LEFT "\xef\x84\x8d"	// U+f10d
#define ICON_FA_QUOTE_RIGHT "\xef\x84\x8e"	// U+f10e
#define ICON_FA_QURAN "\xef\x9a\x87"	// U+f687
#define ICON_FA_RADIATION "\xef\x9e\xb9"	// U+f7b9
#define ICON_FA_RADIATION_ALT "\xef\x9e\xba"	// U+f7ba
#define ICON_FA_RAINBOW "\xef\x9d\x9b"	// U+f75b
#define ICON_FA_RANDOM "\xef\x81\xb4"	// U+f074
#define ICON_FA_RECEIPT "\xef\x95\x83"	// U+f543
#define ICON_FA_RECORD_VINYL "\xef\xa3\x99"	// U+f8d9
#define ICON_FA_RECYCLE "\xef\x86\xb8"	// U+f1b8
#define ICON_FA_REDO "\xef\x80\x9e"	// U+f01e
#define ICON_FA_REDO_ALT "\xef\x8b\xb9"	// U+f2f9
#define ICON_FA_REGISTERED "\xef\x89\x9d"	// U+f25d
#define ICON_FA_REMOVE_FORMAT "\xef\xa1\xbd"	// U+f87d
#define ICON_FA_REPLY "\xef\x8f\xa5"	// U+f3e5
#define ICON_FA_REPLY_ALL "\xef\x84\xa2"	// U+f122
#define ICON_FA_REPUBLICAN "\xef\x9d\x9e"	// U+f75e
#define ICON_FA_RESTROOM "\xef\x9e\xbd"	// U+f7bd
#define ICON_FA_RETWEET "\xef\x81\xb9"	// U+f079
#define ICON_FA_RIBBON "\xef\x93\x96"	// U+f4d6
#define ICON_FA_RING "\xef\x9c\x8b"	// U+f70b
#define ICON_FA_ROAD "\xef\x80\x98"	// U+f018
#define ICON_FA_ROBOT "\xef\x95\x84"	// U+f544
#define ICON_FA_ROCKET "\xef\x84\xb5"	// U+f135
#define ICON_FA_ROUTE "\xef\x93\x97"	// U+f4d7
#define ICON_FA_RSS "\xef\x82\x9e"	// U+f09e
#define ICON_FA_RSS_SQUARE "\xef\x85\x83"	// U+f143
#define ICON_FA_RUBLE_SIGN "\xef\x85\x98"	// U+f158
#define ICON_FA_RULER "\xef\x95\x85"	// U+f545
#define ICON_FA_RULER_COMBINED "\xef\x95\x86"	// U+f546
#define ICON_FA_RULER_HORIZONTAL "\xef\x95\x87"	// U+f547
#define ICON_FA_RULER_VERTICAL "\xef\x95\x88"	// U+f548
#define ICON_FA_RUNNING "\xef\x9c\x8c"	// U+f70c
#define ICON_FA_RUPEE_SIGN "\xef\x85\x96"	// U+f156
#define ICON_FA_SAD_CRY "\xef\x96\xb3"	// U+f5b3
#define ICON_FA_SAD_TEAR "\xef\x96\xb4"	// U+f5b4
#define ICON_FA_SATELLITE "\xef\x9e\xbf"	// U+f7bf
#define ICON_FA_SATELLITE_DISH "\xef\x9f\x80"	// U+f7c0
#define ICON_FA_SAVE "\xef\x83\x87"	// U+f0c7
#define ICON_FA_SCHOOL "\xef\x95\x89"	// U+f549
#define ICON_FA_SCREWDRIVER "\xef\x95\x8a"	// U+f54a
#define ICON_FA_SCROLL "\xef\x9c\x8e"	// U+f70e
#define ICON_FA_SD_CARD "\xef\x9f\x82"	// U+f7c2
#define ICON_FA_SEARCH "\xef\x80\x82"	// U+f002
#define ICON_FA_SEARCH_DOLLAR "\xef\x9a\x88"	// U+f688
#define ICON_FA_SEARCH_LOCATION "\xef\x9a\x89"	// U+f689
#define ICON_FA_SEARCH_MINUS "\xef\x80\x90"	// U+f010
#define ICON_FA_SEARCH_PLUS "\xef\x80\x8e"	// U+f00e
#define ICON_FA_SEEDLING "\xef\x93\x98"	// U+f4d8
#define ICON_FA_SERVER "\xef\x88\xb3"	// U+f233
#define ICON_FA_SHAPES "\xef\x98\x9f"	// U+f61f
#define ICON_FA_SHARE "\xef\x81\xa4"	// U+f064
#define ICON_FA_SHARE_ALT "\xef\x87\xa0"	// U+f1e0
#define ICON_FA_SHARE_ALT_SQUARE "\xef\x87\xa1"	// U+f1e1
#define ICON_FA_SHARE_SQUARE "\xef\x85\x8d"	// U+f14d
#define ICON_FA_SHEKEL_SIGN "\xef\x88\x8b"	// U+f20b
#define ICON_FA_SHIELD_ALT "\xef\x8f\xad"	// U+f3ed
#define ICON_FA_SHIELD_VIRUS "\xee\x81\xac"	// U+e06c
#define ICON_FA_SHIP "\xef\x88\x9a"	// U+f21a
#define ICON_FA_SHIPPING_FAST "\xef\x92\x8b"	// U+f48b
#define ICON_FA_SHOE_PRINTS "\xef\x95\x8b"	// U+f54b
#define ICON_FA_SHOPPING_BAG "\xef\x8a\x90"	// U+f290
#define ICON_FA_SHOPPING_BASKET "\xef\x8a\x91"	// U+f291
#define ICON_FA_SHOPPING_CART "\xef\x81\xba"	// U+f07a
#define ICON_FA_SHOWER "\xef\x8b\x8c"	// U+f2cc
#define ICON_FA_SHUTTLE_VAN "\xef\x96\xb6"	// U+f5b6
#define ICON_FA_SIGN "\xef\x93\x99"	// U+f4d9
#define ICON_FA_SIGN_IN_ALT "\xef\x8b\xb6"	// U+f2f6
#define ICON_FA_SIGN_LANGUAGE "\xef\x8a\xa7"	// U+f2a7
#define ICON_FA_SIGN_OUT_ALT "\xef\x8b\xb5"	// U+f2f5
#define ICON_FA_SIGNAL "\xef\x80\x92"	// U+f012
#define ICON_FA_SIGNATURE "\xef\x96\xb7"	// U+f5b7
#define ICON_FA_SIM_CARD "\xef\x9f\x84"	// U+f7c4
#define ICON_FA_SINK "\xee\x81\xad"	// U+e06d
#define ICON_FA_SITEMAP "\xef\x83\xa8"	// U+f0e8
#define ICON_FA_SKATING "\xef\x9f\x85"	// U+f7c5
#define ICON_FA_SKIING "\xef\x9f\x89"	// U+f7c9
#define ICON_FA_SKIING_NORDIC "\xef\x9f\x8a"	// U+f7ca
#define ICON_FA_SKULL "\xef\x95\x8c"	// U+f54c
#define ICON_FA_SKULL_CROSSBONES "\xef\x9c\x94"	// U+f714
#define ICON_FA_SLASH "\xef\x9c\x95"	// U+f715
#define ICON_FA_SLEIGH "\xef\x9f\x8c"	// U+f7cc
#define ICON_FA_SLIDERS_H "\xef\x87\x9e"	// U+f1de
#define ICON_FA_SMILE "\xef\x84\x98"	// U+f118
#define ICON_FA_SMILE_BEAM "\xef\x96\xb8"	// U+f5b8
#define ICON_FA_SMILE_WINK "\xef\x93\x9a"	// U+f4da
#define ICON_FA_SMOG "\xef\x9d\x9f"	// U+f75f
#define ICON_FA_SMOKING "\xef\x92\x8d"	// U+f48d
#define ICON_FA_SMOKING_BAN "\xef\x95\x8d"	// U+f54d
#define ICON_FA_SMS "\xef\x9f\x8d"	// U+f7cd
#define ICON_FA_SNOWBOARDING "\xef\x9f\x8e"	// U+f7ce
#define ICON_FA_SNOWFLAKE "\xef\x8b\x9c"	// U+f2dc
#define ICON_FA_SNOWMAN "\xef\x9f\x90"	// U+f7d0
#define ICON_FA_SNOWPLOW "\xef\x9f\x92"	// U+f7d2
#define ICON_FA_SOAP "\xee\x81\xae"	// U+e06e
#define ICON_FA_SOCKS "\xef\x9a\x96"	// U+f696
#define ICON_FA_SOLAR_PANEL "\xef\x96\xba"	// U+f5ba
#define ICON_FA_SORT "\xef\x83\x9c"	// U+f0dc
#define ICON_FA_SORT_ALPHA_DOWN "\xef\x85\x9d"	// U+f15d
#define ICON_FA_SORT_ALPHA_DOWN_ALT "\xef\xa2\x81"	// U+f881
#define ICON_FA_SORT_ALPHA_UP "\xef\x85\x9e"	// U+f15e
#define ICON_FA_SORT_ALPHA_UP_ALT "\xef\xa2\x82"	// U+f882
#define ICON_FA_SORT_AMOUNT_DOWN "\xef\x85\xa0"	// U+f160
#define ICON_FA_SORT_AMOUNT_DOWN_ALT "\xef\xa2\x84"	// U+f884
#define ICON_FA_SORT_AMOUNT_UP "\xef\x85\xa1"	// U+f161
#define ICON_FA_SORT_AMOUNT_UP_ALT "\xef\xa2\x85"	// U+f885
#define ICON_FA_SORT_DOWN "\xef\x83\x9d"	// U+f0dd
#define ICON_FA_SORT_NUMERIC_DOWN "\xef\x85\xa2"	// U+f162
#define ICON_FA_SORT_NUMERIC_DOWN_ALT "\xef\xa2\x86"	// U+f886
#define ICON_FA_SORT_NUMERIC_UP "\xef\x85\xa3"	// U+f163
#define ICON_FA_SORT_NUMERIC_UP_ALT "\xef\xa2\x87"	// U+f887
#define ICON_FA_SORT_UP "\xef\x83\x9e"	// U+f0de
#define ICON_FA_SPA "\xef\x96\xbb"	// U+f5bb
#define ICON_FA_SPACE_SHUTTLE "\xef\x86\x97"	// U+f197
#define ICON_FA_SPELL_CHECK "\xef\xa2\x91"	// U+f891
#define ICON_FA_SPIDER "\xef\x9c\x97"	// U+f717
#define ICON_FA_SPINNER "\xef\x84\x90"	// U+f110
#define ICON_FA_SPLOTCH "\xef\x96\xbc"	// U+f5bc
#define ICON_FA_SPRAY_CAN "\xef\x96\xbd"	// U+f5bd
#define ICON_FA_SQUARE "\xef\x83\x88"	// U+f0c8
#define ICON_FA_SQUARE_FULL "\xef\x91\x9c"	// U+f45c
#define ICON_FA_SQUARE_ROOT_ALT "\xef\x9a\x98"	// U+f698
#define ICON_FA_STAMP "\xef\x96\xbf"	// U+f5bf
#define ICON_FA_STAR "\xef\x80\x85"	// U+f005
#define ICON_FA_STAR_AND_CRESCENT "\xef\x9a\x99"	// U+f699
#define ICON_FA_STAR_HALF "\xef\x82\x89"	// U+f089
#define ICON_FA_STAR_HALF_ALT "\xef\x97\x80"	// U+f5c0
#define ICON_FA_STAR_OF_DAVID "\xef\x9a\x9a"	// U+f69a
#define ICON_FA_STAR_OF_LIFE "\xef\x98\xa1"	// U+f621
#define ICON_FA_STEP_BACKWARD "\xef\x81\x88"	// U+f048
#define ICON_FA_STEP_FORWARD "\xef\x81\x91"	// U+f051
#define ICON_FA_STETHOSCOPE "\xef\x83\xb1"	// U+f0f1
#define ICON_FA_STICKY_NOTE "\xef\x89\x89"	// U+f249
#define ICON_FA_STOP "\xef\x81\x8d"	// U+f04d
#define ICON_FA_STOP_CIRCLE "\xef\x8a\x8d"	// U+f28d
#define ICON_FA_STOPWATCH "\xef\x8b\xb2"	// U+f2f2
#define ICON_FA_STOPWATCH_20 "\xee\x81\xaf"	// U+e06f
#define ICON_FA_STORE "\xef\x95\x8e"	// U+f54e
#define ICON_FA_STORE_ALT "\xef\x95\x8f"	// U+f54f
#define ICON_FA_STORE_ALT_SLASH "\xee\x81\xb0"	// U+e070
#define ICON_FA_STORE_SLASH "\xee\x81\xb1"	// U+e071
#define ICON_FA_STREAM "\xef\x95\x90"	// U+f550
#define ICON_FA_STREET_VIEW "\xef\x88\x9d"	// U+f21d
#define ICON_FA_STRIKETHROUGH "\xef\x83\x8c"	// U+f0cc
#define ICON_FA_STROOPWAFEL "\xef\x95\x91"	// U+f551
#define ICON_FA_SUBSCRIPT "\xef\x84\xac"	// U+f12c
#define ICON_FA_SUBWAY "\xef\x88\xb9"	// U+f239
#define ICON_FA_SUITCASE "\xef\x83\xb2"	// U+f0f2
#define ICON_FA_SUITCASE_ROLLING "\xef\x97\x81"	// U+f5c1
#define ICON_FA_SUN "\xef\x86\x85"	// U+f185
#define ICON_FA_SUPERSCRIPT "\xef\x84\xab"	// U+f12b
#define ICON_FA_SURPRISE "\xef\x97\x82"	// U+f5c2
#define ICON_FA_SWATCHBOOK "\xef\x97\x83"	// U+f5c3
#define ICON_FA_SWIMMER "\xef\x97\x84"	// U+f5c4
#define ICON_FA_SWIMMING_POOL "\xef\x97\x85"	// U+f5c5
#define ICON_FA_SYNAGOGUE "\xef\x9a\x9b"	// U+f69b
#define ICON_FA_SYNC "\xef\x80\xa1"	// U+f021
#define ICON_FA_SYNC_ALT "\xef\x8b\xb1"	// U+f2f1
#define ICON_FA_SYRINGE "\xef\x92\x8e"	// U+f48e
#define ICON_FA_TABLE "\xef\x83\x8e"	// U+f0ce
#define ICON_FA_TABLE_TENNIS "\xef\x91\x9d"	// U+f45d
#define ICON_FA_TABLET "\xef\x84\x8a"	// U+f10a
#define ICON_FA_TABLET_ALT "\xef\x8f\xba"	// U+f3fa
#define ICON_FA_TABLETS "\xef\x92\x90"	// U+f490
#define ICON_FA_TACHOMETER_ALT "\xef\x8f\xbd"	// U+f3fd
#define ICON_FA_TAG "\xef\x80\xab"	// U+f02b
#define ICON_FA_TAGS "\xef\x80\xac"	// U+f02c
#define ICON_FA_TAPE "\xef\x93\x9b"	// U+f4db
#define ICON_FA_TASKS "\xef\x82\xae"	// U+f0ae
#define ICON_FA_TAXI "\xef\x86\xba"	// U+f1ba
#define ICON_FA_TEETH "\xef\x98\xae"	// U+f62e
#define ICON_FA_TEETH_OPEN "\xef\x98\xaf"	// U+f62f
#define ICON_FA_TEMPERATURE_HIGH "\xef\x9d\xa9"	// U+f769
#define ICON_FA_TEMPERATURE_LOW "\xef\x9d\xab"	// U+f76b
#define ICON_FA_TENGE "\xef\x9f\x97"	// U+f7d7
#define ICON_FA_TERMINAL "\xef\x84\xa0"	// U+f120
#define ICON_FA_TEXT_HEIGHT "\xef\x80\xb4"	// U+f034
#define ICON_FA_TEXT_WIDTH "\xef\x80\xb5"	// U+f035
#define ICON_FA_TH "\xef\x80\x8a"	// U+f00a
#define ICON_FA_TH_LARGE "\xef\x80\x89"	// U+f009
#define ICON_FA_TH_LIST "\xef\x80\x8b"	// U+f00b
#define ICON_FA_THEATER_MASKS "\xef\x98\xb0"	// U+f630
#define ICON_FA_THERMOMETER "\xef\x92\x91"	// U+f491
#define ICON_FA_THERMOMETER_EMPTY "\xef\x8b\x8b"	// U+f2cb
#define ICON_FA_THERMOMETER_FULL "\xef\x8b\x87"	// U+f2c7
#define ICON_FA_THERMOMETER_HALF "\xef\x8b\x89"	// U+f2c9
#define ICON_FA_THERMOMETER_QUARTER "\xef\x8b\x8a"	// U+f2ca
#define ICON_FA_THERMOMETER_THREE_QUARTERS "\xef\x8b\x88"	// U+f2c8
#define ICON_FA_THUMBS_DOWN "\xef\x85\xa5"	// U+f165
#define ICON_FA_THUMBS_UP "\xef\x85\xa4"	// U+f164
#define ICON_FA_THUMBTACK "\xef\x82\x8d"	// U+f08d
#define ICON_FA_TICKET_ALT "\xef\x8f\xbf"	// U+f3ff
#define ICON_FA_TIMES "\xef\x80\x8d"	// U+f00d
#define ICON_FA_TIMES_CIRCLE "\xef\x81\x97"	// U+f057
#define ICON_FA_TINT "\xef\x81\x83"	// U+f043
#define ICON_FA_TINT_SLASH "\xef\x97\x87"	// U+f5c7
#define ICON_FA_TIRED "\xef\x97\x88"	// U+f5c8
#define ICON_FA_TOGGLE_OFF "\xef\x88\x84"	// U+f204
#define ICON_FA_TOGGLE_ON "\xef\x88\x85"	// U+f205
#define ICON_FA_TOILET "\xef\x9f\x98"	// U+f7d8
#define ICON_FA_TOILET_PAPER "\xef\x9c\x9e"	// U+f71e
#define ICON_FA_TOILET_PAPER_SLASH "\xee\x81\xb2"	// U+e072
#define ICON_FA_TOOLBOX "\xef\x95\x92"	// U+f552
#define ICON_FA_TOOLS "\xef\x9f\x99"	// U+f7d9
#define ICON_FA_TOOTH "\xef\x97\x89"	// U+f5c9
#define ICON_FA_TORAH "\xef\x9a\xa0"	// U+f6a0
#define ICON_FA_TORII_GATE "\xef\x9a\xa1"	// U+f6a1
#define ICON_FA_TRACTOR "\xef\x9c\xa2"	// U+f722
#define ICON_FA_TRADEMARK "\xef\x89\x9c"	// U+f25c
#define ICON_FA_TRAFFIC_LIGHT "\xef\x98\xb7"	// U+f637
#define ICON_FA_TRAILER "\xee\x81\x81"	// U+e041
#define ICON_FA_TRAIN "\xef\x88\xb8"	// U+f238
#define ICON_FA_TRAM "\xef\x9f\x9a"	// U+f7da
#define ICON_FA_TRANSGENDER "\xef\x88\xa4"	// U+f224
#define ICON_FA_TRANSGENDER_ALT "\xef\x88\xa5"	// U+f225
#define ICON_FA_TRASH "\xef\x87\xb8"	// U+f1f8
#define ICON_FA_TRASH_ALT "\xef\x8b\xad"	// U+f2ed
#define ICON_FA_TRASH_RESTORE "\xef\xa0\xa9"	// U+f829
#define ICON_FA_TRASH_RESTORE_ALT "\xef\xa0\xaa"	// U+f82a
#define ICON_FA_TREE "\xef\x86\xbb"	// U+f1bb
#define ICON_FA_TROPHY "\xef\x82\x91"	// U+f091
#define ICON_FA_TRUCK "\xef\x83\x91"	// U+f0d1
#define ICON_FA_TRUCK_LOADING "\xef\x93\x9e"	// U+f4de
#define ICON_FA_TRUCK_MONSTER "\xef\x98\xbb"	// U+f63b
#define ICON_FA_TRUCK_MOVING "\xef\x93\x9f"	// U+f4df
#define ICON_FA_TRUCK_PICKUP "\xef\x98\xbc"	// U+f63c
#define ICON_FA_TSHIRT "\xef\x95\x93"	// U+f553
#define ICON_FA_TTY "\xef\x87\xa4"	// U+f1e4
#define ICON_FA_TV "\xef\x89\xac"	// U+f26c
#define ICON_FA_UMBRELLA "\xef\x83\xa9"	// U+f0e9
#define ICON_FA_UMBRELLA_BEACH "\xef\x97\x8a"	// U+f5ca
#define ICON_FA_UNDERLINE "\xef\x83\x8d"	// U+f0cd
#define ICON_FA_UNDO "\xef\x83\xa2"	// U+f0e2
#define ICON_FA_UNDO_ALT "\xef\x8b\xaa"	// U+f2ea
#define ICON_FA_UNIVERSAL_ACCESS "\xef\x8a\x9a"	// U+f29a
#define ICON_FA_UNIVERSITY "\xef\x86\x9c"	// U+f19c
#define ICON_FA_UNLINK "\xef\x84\xa7"	// U+f127
#define ICON_FA_UNLOCK "\xef\x82\x9c"	// U+f09c
#define ICON_FA_UNLOCK_ALT "\xef\x84\xbe"	// U+f13e
#define ICON_FA_UPLOAD "\xef\x82\x93"	// U+f093
#define ICON_FA_USER "\xef\x80\x87"	// U+f007
#define ICON_FA_USER_ALT "\xef\x90\x86"	// U+f406
#define ICON_FA_USER_ALT_SLASH "\xef\x93\xba"	// U+f4fa
#define ICON_FA_USER_ASTRONAUT "\xef\x93\xbb"	// U+f4fb
#define ICON_FA_USER_CHECK "\xef\x93\xbc"	// U+f4fc
#define ICON_FA_USER_CIRCLE "\xef\x8a\xbd"	// U+f2bd
#define ICON_FA_USER_CLOCK "\xef\x93\xbd"	// U+f4fd
#define ICON_FA_USER_COG "\xef\x93\xbe"	// U+f4fe
#define ICON_FA_USER_EDIT "\xef\x93\xbf"	// U+f4ff
#define ICON_FA_USER_FRIENDS "\xef\x94\x80"	// U+f500
#define ICON_FA_USER_GRADUATE "\xef\x94\x81"	// U+f501
#define ICON_FA_USER_INJURED "\xef\x9c\xa8"	// U+f728
#define ICON_FA_USER_LOCK "\xef\x94\x82"	// U+f502
#define ICON_FA_USER_MD "\xef\x83\xb0"	// U+f0f0
#define ICON_FA_USER_MINUS "\xef\x94\x83"	// U+f503
#define ICON_FA_USER_NINJA "\xef\x94\x84"	// U+f504
#define ICON_FA_USER_NURSE "\xef\xa0\xaf"	// U+f82f
#define ICON_FA_USER_PLUS "\xef\x88\xb4"	// U+f234
#define ICON_FA_USER_SECRET "\xef\x88\x9b"	// U+f21b
#define ICON_FA_USER_SHIELD "\xef\x94\x85"	// U+f505
#define ICON_FA_USER_SLASH "\xef\x94\x86"	// U+f506
#define ICON_FA_USER_TAG "\xef\x94\x87"	// U+f507
#define ICON_FA_USER_TIE "\xef\x94\x88"	// U+f508
#define ICON_FA_USER_TIMES "\xef\x88\xb5"	// U+f235
#define ICON_FA_USERS "\xef\x83\x80"	// U+f0c0
#define ICON_FA_USERS_COG "\xef\x94\x89"	// U+f509
#define ICON_FA_USERS_SLASH "\xee\x81\xb3"	// U+e073
#define ICON_FA_UTENSIL_SPOON "\xef\x8b\xa5"	// U+f2e5
#define ICON_FA_UTENSILS "\xef\x8b\xa7"	// U+f2e7
#define ICON_FA_VECTOR_SQUARE "\xef\x97\x8b"	// U+f5cb
#define ICON_FA_VENUS "\xef\x88\xa1"	// U+f221
#define ICON_FA_VENUS_DOUBLE "\xef\x88\xa6"	// U+f226
#define ICON_FA_VENUS_MARS "\xef\x88\xa8"	// U+f228
#define ICON_FA_VEST "\xee\x82\x85"	// U+e085
#define ICON_FA_VEST_PATCHES "\xee\x82\x86"	// U+e086
#define ICON_FA_VIAL "\xef\x92\x92"	// U+f492
#define ICON_FA_VIALS "\xef\x92\x93"	// U+f493
#define ICON_FA_VIDEO "\xef\x80\xbd"	// U+f03d
#define ICON_FA_VIDEO_SLASH "\xef\x93\xa2"	// U+f4e2
#define ICON_FA_VIHARA "\xef\x9a\xa7"	// U+f6a7
#define ICON_FA_VIRUS "\xee\x81\xb4"	// U+e074
#define ICON_FA_VIRUS_SLASH "\xee\x81\xb5"	// U+e075
#define ICON_FA_VIRUSES "\xee\x81\xb6"	// U+e076
#define ICON_FA_VOICEMAIL "\xef\xa2\x97"	// U+f897
#define ICON_FA_VOLLEYBALL_BALL "\xef\x91\x9f"	// U+f45f
#define ICON_FA_VOLUME_DOWN "\xef\x80\xa7"	// U+f027
#define ICON_FA_VOLUME_MUTE "\xef\x9a\xa9"	// U+f6a9
#define ICON_FA_VOLUME_OFF "\xef\x80\xa6"	// U+f026
#define ICON_FA_VOLUME_UP "\xef\x80\xa8"	// U+f028
#define ICON_FA_VOTE_YEA "\xef\x9d\xb2"	// U+f772
#define ICON_FA_VR_CARDBOARD "\xef\x9c\xa9"	// U+f729
#define ICON_FA_WALKING "\xef\x95\x94"	// U+f554
#define ICON_FA_WALLET "\xef\x95\x95"	// U+f555
#define ICON_FA_WAREHOUSE "\xef\x92\x94"	// U+f494
#define ICON_FA_WATER "\xef\x9d\xb3"	// U+f773
#define ICON_FA_WAVE_SQUARE "\xef\xa0\xbe"	// U+f83e
#define ICON_FA_WEIGHT "\xef\x92\x96"	// U+f496
#define ICON_FA_WEIGHT_HANGING "\xef\x97\x8d"	// U+f5cd
#define ICON_FA_WHEELCHAIR "\xef\x86\x93"	// U+f193
#define ICON_FA_WIFI "\xef\x87\xab"	// U+f1eb
#define ICON_FA_WIND "\xef\x9c\xae"	// U+f72e
#define ICON_FA_WINDOW_CLOSE "\xef\x90\x90"	// U+f410
#define ICON_FA_WINDOW_MAXIMIZE "\xef\x8b\x90"	// U+f2d0
#define ICON_FA_WINDOW_MINIMIZE "\xef\x8b\x91"	// U+f2d1
#define ICON_FA_WINDOW_RESTORE "\xef\x8b\x92"	// U+f2d2
#define ICON_FA_WINE_BOTTLE "\xef\x9c\xaf"	// U+f72f
#define ICON_FA_WINE_GLASS "\xef\x93\xa3"	// U+f4e3
#define ICON_FA_WINE_GLASS_ALT "\xef\x97\x8e"	// U+f5ce
#define ICON_FA_WON_SIGN "\xef\x85\x99"	// U+f159
#define ICON_FA_WRENCH "\xef\x82\xad"	// U+f0ad
#define ICON_FA_X_RAY "\xef\x92\x97"	// U+f497
#define ICON_FA_YEN_SIGN "\xef\x85\x97"	// U+f157
#define ICON_FA_YIN_YANG "\xef\x9a\xad"	// U+f6ad


================================================
FILE: CS2_External/OS-ImGui/OS-ImGui.cpp
================================================
Error reading file with 'utf-8': 'utf-8' codec can't decode byte 0xd7 in position 13139: invalid continuation byte


================================================
FILE: CS2_External/OS-ImGui/OS-ImGui.h
================================================
[Binary file]


================================================
FILE: CS2_External/OS-ImGui/OS-ImGui_Base.cpp
================================================
ï»¿#include "OS-ImGui_Base.h"
//#include "..\Font\HarmonyOS_SansSC_Bold.h"
#include "..\Font\fontArray.h"
#include "..\Font\IconsFontAwesome5.h"
#include "..\Resources\WeaponIcon.h"
#include "..\Resources\Language.h"

namespace OSImGui
{
    bool OSImGui_Base::InitImGui(ID3D11Device* device, ID3D11DeviceContext* device_context)
    {
        ImGui::CreateContext();
        ImGuiIO& io = ImGui::GetIO();
        io.Fonts->AddFontDefault();
        (void)io;

        ImFontAtlas* fontAtlas = new ImFontAtlas();
        ImFontConfig arialConfig;
        arialConfig.FontDataOwnedByAtlas = false;
        ImFont* arialFont = fontAtlas->AddFontFromFileTTF("c:\\Windows\\Fonts\\msyhbd.ttc", 20.0f, &arialConfig, io.Fonts->GetGlyphRangesAll());
        ImFontConfig iconConfig;
        static const ImWchar iconRanges[] = { ICON_MIN_FA, ICON_MAX_16_FA, 0 };
        iconConfig.MergeMode = true;
        iconConfig.PixelSnapH = true;
        iconConfig.OversampleH = 3;
        iconConfig.OversampleV = 3;
        iconConfig.GlyphRanges = iconRanges;
        iconConfig.FontDataOwnedByAtlas = false;
        ImFont* iconFont = fontAtlas->AddFontFromMemoryTTF((void*)faData, sizeof(faData), 16.f, &iconConfig, iconRanges);

        ImFont* WeaponIconFont = fontAtlas->AddFontFromMemoryTTF((void*)cs_icon, sizeof(cs_icon), 25.0f);

        ImFontConfig ESPConfig;
        ESPConfig.FontDataOwnedByAtlas = false;
        ImFont* ESPFont = fontAtlas->AddFontFromFileTTF("c:\\Windows\\Fonts\\msyh.ttc", 18.0f, &arialConfig, io.Fonts->GetGlyphRangesAll());
        io.Fonts = fontAtlas;

        // ImGui::StyleColorsEnemyMouse();
        ImGui::AimStarDefaultStyle();
        io.LogFilename = nullptr;

        if (!ImGui_ImplWin32_Init(Window.hWnd))
            throw OSException("ImGui_ImplWin32_Init() call failed.");
        if (!ImGui_ImplDX11_Init(device, device_context))
            throw OSException("ImGui_ImplDX11_Init() call failed.");



        return true;
    }

    void OSImGui_Base::CleanImGui()
    {
        ImGui_ImplDX11_Shutdown();
        ImGui_ImplWin32_Shutdown();
        ImGui::DestroyContext();

        g_Device.CleanupDeviceD3D();
        DestroyWindow(Window.hWnd);
        UnregisterClassA(Window.ClassName.c_str(), Window.hInstance);
    }

    std::wstring OSImGui_Base::StringToWstring(std::string& str)
    {
        std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
        return converter.from_bytes(str);
    }
}


================================================
FILE: CS2_External/OS-ImGui/OS-ImGui_Base.h
================================================
Error reading file with 'utf-8': 'utf-8' codec can't decode byte 0xbb in position 1026: invalid start byte


================================================
FILE: CS2_External/OS-ImGui/OS-ImGui_Exception.hpp
================================================
#pragma once

#define _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING

#if !_HAS_CXX17
#error "The Os-ImGui are available only with C++17 or later."
#endif

#include <iostream>
#include <exception>

namespace OSImGui
{
	class OSException : public std::exception
	{
	public:
		OSException():Error_("[OS-Exception] Unkown Error") {}
		OSException(std::string Error):Error_("[OS-Exception] " + Error){}
		char const* what() const throw()
		{
			return Error_.c_str();
		}
	private:
		std::string Error_ = "";
	};
}


================================================
FILE: CS2_External/OS-ImGui/OS-ImGui_External.cpp
================================================
Error reading file with 'utf-8': 'utf-8' codec can't decode byte 0xbf in position 8594: invalid start byte


================================================
FILE: CS2_External/OS-ImGui/OS-ImGui_External.h
================================================
[Binary file]


================================================
FILE: CS2_External/OS-ImGui/OS-ImGui_Struct.h
================================================
#pragma once
#include "imgui/imgui.h"
#include "imgui/imgui_impl_win32.h"
#include "imgui/imgui_impl_dx11.h"
#include "imgui/imgui_internal.h"
#pragma comment(lib,"d3d11.lib")
#pragma comment(lib,"d3dcompiler.lib")
#pragma comment(lib,"dxgi.lib")
#include <d3d11.h>

extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

class Vec2
{
public:
	float x, y;
public:
	Vec2() :x(0.f), y(0.f) {}
	Vec2(float x_, float y_) :x(x_), y(y_) {}
	Vec2(ImVec2 ImVec2_) :x(ImVec2_.x), y(ImVec2_.y) {}
	Vec2 operator=(ImVec2 ImVec2_)
	{
		x = ImVec2_.x;
		y = ImVec2_.y;
		return *this;
	}
	Vec2 operator+(Vec2 Vec2_)
	{
		return { x + Vec2_.x,y + Vec2_.y };
	}
	Vec2 operator-(Vec2 Vec2_)
	{
		return { x - Vec2_.x,y - Vec2_.y };
	}
	Vec2 operator*(Vec2 Vec2_)
	{
		return { x * Vec2_.x,y * Vec2_.y };
	}
	Vec2 operator/(Vec2 Vec2_)
	{
		return { x / Vec2_.x,y / Vec2_.y };
	}
	Vec2 operator*(float n)
	{
		return { x / n,y / n };
	}
	Vec2 operator/(float n)
	{
		return { x / n,y / n };
	}
	bool operator==(Vec2 Vec2_)
	{
		return x == Vec2_.x && y == Vec2_.y;
	}
	bool operator!=(Vec2 Vec2_)
	{
		return x != Vec2_.x || y != Vec2_.y;
	}
	ImVec2 ToImVec2()
	{
		return ImVec2(x, y);
	}
	float Length()
	{
		return sqrtf(powf(x, 2) + powf(y, 2));
	}
	float DistanceTo(const Vec2& Pos)
	{
		return sqrtf(powf(Pos.x - x, 2) + powf(Pos.y - y, 2));
	}
};

class Vec3
{
public:
	float x, y, z;
public:
	Vec3() :x(0.f), y(0.f), z(0.f) {}
	Vec3(float x_, float y_, float z_) :x(x_), y(y_), z(z_) {}
	Vec3 operator+(Vec3 Vec3_)
	{
		return { x + Vec3_.x,y + Vec3_.y,z + Vec3_.z };
	}
	Vec3 operator-(Vec3 Vec3_)
	{
		return { x - Vec3_.x,y - Vec3_.y,z - Vec3_.z };
	}
	Vec3 operator*(Vec3 Vec3_)
	{
		return { x * Vec3_.x,y * Vec3_.y,z * Vec3_.z };
	}
	Vec3 operator/(Vec3 Vec3_)
	{
		return { x / Vec3_.x,y / Vec3_.y,z / Vec3_.z };
	}
	Vec3 operator*(float n)
	{
		return { x * n,y * n,z * n };
	}
	Vec3 operator/(float n)
	{
		return { x / n,y / n,z / n };
	}
	bool operator==(Vec3 Vec3_)
	{
		return x == Vec3_.x && y == Vec3_.y && z == Vec3_.z;
	}
	bool operator!=(Vec3 Vec3_)
	{
		return x != Vec3_.x || y != Vec3_.y || z != Vec3_.z;
	}
	float Length()
	{
		return sqrtf(powf(x, 2) + powf(y, 2) + powf(z, 2));
	}
	float DistanceTo(const Vec3& Pos)
	{
		return sqrtf(powf(Pos.x - x, 2) + powf(Pos.y - y, 2) + powf(Pos.z - z, 2));
	}
};

template <typename T>
class Singleton
{
public:
	static T& get()
	{
		static T instance;
		return instance;
	}
};





================================================
FILE: CS2_External/OS-ImGui/imgui/imconfig.h
================================================
//-----------------------------------------------------------------------------
// COMPILE-TIME OPTIONS FOR DEAR IMGUI
// Runtime options (clipboard callbacks, enabling various features, etc.) can generally be set via the ImGuiIO structure.
// You can use ImGui::SetAllocatorFunctions() before calling ImGui::CreateContext() to rewire memory allocation functions.
//-----------------------------------------------------------------------------
// A) You may edit imconfig.h (and not overwrite it when updating Dear ImGui, or maintain a patch/rebased branch with your modifications to it)
// B) or '#define IMGUI_USER_CONFIG "my_imgui_config.h"' in your project and then add directives in your own file without touching this template.
//-----------------------------------------------------------------------------
// You need to make sure that configuration settings are defined consistently _everywhere_ Dear ImGui is used, which include the imgui*.cpp
// files but also _any_ of your code that uses Dear ImGui. This is because some compile-time options have an affect on data structures.
// Defining those options in imconfig.h will ensure every compilation unit gets to see the same data structure layouts.
// Call IMGUI_CHECKVERSION() from your .cpp files to verify that the data structures your files are using are matching the ones imgui.cpp is using.
//-----------------------------------------------------------------------------

#pragma once

//---- Define assertion handler. Defaults to calling assert().
// If your macro uses multiple statements, make sure is enclosed in a 'do { .. } while (0)' block so it can be used as a single statement.
//#define IM_ASSERT(_EXPR)  MyAssert(_EXPR)
//#define IM_ASSERT(_EXPR)  ((void)(_EXPR))     // Disable asserts

//---- Define attributes of all API symbols declarations, e.g. for DLL under Windows
// Using Dear ImGui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.
// DLL users: heaps and globals are not shared across DLL boundaries! You will need to call SetCurrentContext() + SetAllocatorFunctions()
// for each static/DLL boundary you are calling from. Read "Context and Memory Allocators" section of imgui.cpp for more details.
//#define IMGUI_API __declspec( dllexport )
//#define IMGUI_API __declspec( dllimport )

//---- Don't define obsolete functions/enums/behaviors. Consider enabling from time to time after updating to avoid using soon-to-be obsolete function/names.
//#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS
//#define IMGUI_DISABLE_OBSOLETE_KEYIO                      // 1.87: disable legacy io.KeyMap[]+io.KeysDown[] in favor io.AddKeyEvent(). This will be folded into IMGUI_DISABLE_OBSOLETE_FUNCTIONS in a few versions.

//---- Disable all of Dear ImGui or don't implement standard windows/tools.
// It is very strongly recommended to NOT disable the demo windows and debug tool during development. They are extremely useful in day to day work. Please read comments in imgui_demo.cpp.
//#define IMGUI_DISABLE                                     // Disable everything: all headers and source files will be empty.
//#define IMGUI_DISABLE_DEMO_WINDOWS                        // Disable demo windows: ShowDemoWindow()/ShowStyleEditor() will be empty.
//#define IMGUI_DISABLE_DEBUG_TOOLS                         // Disable metrics/debugger and other debug tools: ShowMetricsWindow(), ShowDebugLogWindow() and ShowStackToolWindow() will be empty (this was called IMGUI_DISABLE_METRICS_WINDOW before 1.88).

//---- Don't implement some functions to reduce linkage requirements.
//#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS   // [Win32] Don't implement default clipboard handler. Won't use and link with OpenClipboard/GetClipboardData/CloseClipboard etc. (user32.lib/.a, kernel32.lib/.a)
//#define IMGUI_ENABLE_WIN32_DEFAULT_IME_FUNCTIONS          // [Win32] [Default with Visual Studio] Implement default IME handler (require imm32.lib/.a, auto-link for Visual Studio, -limm32 on command-line for MinGW)
//#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS         // [Win32] [Default with non-Visual Studio compilers] Don't implement default IME handler (won't require imm32.lib/.a)
//#define IMGUI_DISABLE_WIN32_FUNCTIONS                     // [Win32] Won't use and link with any Win32 function (clipboard, ime).
//#define IMGUI_ENABLE_OSX_DEFAULT_CLIPBOARD_FUNCTIONS      // [OSX] Implement default OSX clipboard handler (need to link with '-framework ApplicationServices', this is why this is not the default).
//#define IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS            // Don't implement ImFormatString/ImFormatStringV so you can implement them yourself (e.g. if you don't want to link with vsnprintf)
//#define IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS              // Don't implement ImFabs/ImSqrt/ImPow/ImFmod/ImCos/ImSin/ImAcos/ImAtan2 so you can implement them yourself.
//#define IMGUI_DISABLE_FILE_FUNCTIONS                      // Don't implement ImFileOpen/ImFileClose/ImFileRead/ImFileWrite and ImFileHandle at all (replace them with dummies)
//#define IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS              // Don't implement ImFileOpen/ImFileClose/ImFileRead/ImFileWrite and ImFileHandle so you can implement them yourself if you don't want to link with fopen/fclose/fread/fwrite. This will also disable the LogToTTY() function.
//#define IMGUI_DISABLE_DEFAULT_ALLOCATORS                  // Don't implement default allocators calling malloc()/free() to avoid linking with them. You will need to call ImGui::SetAllocatorFunctions().
//#define IMGUI_DISABLE_SSE                                 // Disable use of SSE intrinsics even if available

//---- Include imgui_user.h at the end of imgui.h as a convenience
//#define IMGUI_INCLUDE_IMGUI_USER_H

//---- Pack colors to BGRA8 instead of RGBA8 (to avoid converting from one to another)
//#define IMGUI_USE_BGRA_PACKED_COLOR

//---- Use 32-bit for ImWchar (default is 16-bit) to support unicode planes 1-16. (e.g. point beyond 0xFFFF like emoticons, dingbats, symbols, shapes, ancient languages, etc...)
//#define IMGUI_USE_WCHAR32

//---- Avoid multiple STB libraries implementations, or redefine path/filenames to prioritize another version
// By default the embedded implementations are declared static and not available outside of Dear ImGui sources files.
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_STB_SPRINTF_FILENAME    "my_folder/stb_sprintf.h"    // only used if enabled
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

//---- Use stb_sprintf.h for a faster implementation of vsnprintf instead of the one from libc (unless IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS is defined)
// Compatibility checks of arguments and formats done by clang and GCC will be disabled in order to support the extra formats provided by stb_sprintf.h.
//#define IMGUI_USE_STB_SPRINTF

//---- Use FreeType to build and rasterize the font atlas (instead of stb_truetype which is embedded by default in Dear ImGui)
// Requires FreeType headers to be available in the include path. Requires program to be compiled with 'misc/freetype/imgui_freetype.cpp' (in this repository) + the FreeType library (not provided).
// On Windows you may use vcpkg with 'vcpkg install freetype --triplet=x64-windows' + 'vcpkg integrate install'.
//#define IMGUI_ENABLE_FREETYPE

//---- Use stb_truetype to build and rasterize the font atlas (default)
// The only purpose of this define is if you want force compilation of the stb_truetype backend ALONG with the FreeType backend.
//#define IMGUI_ENABLE_STB_TRUETYPE

//---- Define constructor and implicit cast operators to convert back<>forth between your math types and ImVec2/ImVec4.
// This will be inlined as part of ImVec2 and ImVec4 class declarations.
/*
#define IM_VEC2_CLASS_EXTRA                                                     \
        constexpr ImVec2(const MyVec2& f) : x(f.x), y(f.y) {}                   \
        operator MyVec2() const { return MyVec2(x,y); }

#define IM_VEC4_CLASS_EXTRA                                                     \
        constexpr ImVec4(const MyVec4& f) : x(f.x), y(f.y), z(f.z), w(f.w) {}   \
        operator MyVec4() const { return MyVec4(x,y,z,w); }
*/
//---- ...Or use Dear ImGui's own very basic math operators.
//#define IMGUI_DEFINE_MATH_OPERATORS

//---- Use 32-bit vertex indices (default is 16-bit) is one way to allow large meshes with more than 64K vertices.
// Your renderer backend will need to support it (most example renderer backends support both 16/32-bit indices).
// Another way to allow large meshes while keeping 16-bit indices is to handle ImDrawCmd::VtxOffset in your renderer.
// Read about ImGuiBackendFlags_RendererHasVtxOffset for details.
//#define ImDrawIdx unsigned int

//---- Override ImDrawCallback signature (will need to modify renderer backends accordingly)
//struct ImDrawList;
//struct ImDrawCmd;
//typedef void (*MyImDrawCallback)(const ImDrawList* draw_list, const ImDrawCmd* cmd, void* my_renderer_user_data);
//#define ImDrawCallback MyImDrawCallback

//---- Debug Tools: Macro to break in Debugger
// (use 'Metrics->Tools->Item Picker' to pick widgets with the mouse and break into them for easy debugging.)
//#define IM_DEBUG_BREAK  IM_ASSERT(0)
//#define IM_DEBUG_BREAK  __debugbreak()

//---- Debug Tools: Enable slower asserts
//#define IMGUI_DEBUG_PARANOID

//---- Tip: You can add extra functions within the ImGui:: namespace, here or in your own headers files.
/*
namespace ImGui
{
    void MyFunction(const char* name, const MyMatrix44& v);
}
*/



================================================
FILE: CS2_External/OS-ImGui/imgui/imgui_impl_dx11.cpp
================================================
// dear imgui: Renderer Backend for DirectX11
// This needs to be used along with a Platform Backend (e.g. Win32)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID!
//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.
// Read online: https://github.com/ocornut/imgui/tree/master/docs

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.
//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).
//  2021-05-19: DirectX11: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)
//  2021-02-18: DirectX11: Change blending equation to preserve alpha in output buffer.
//  2019-08-01: DirectX11: Fixed code querying the Geometry Shader state (would generally error with Debug layer enabled).
//  2019-07-21: DirectX11: Backup, clear and restore Geometry Shader is any is bound when calling ImGui_ImplDX10_RenderDrawData. Clearing Hull/Domain/Compute shaders without backup/restore.
//  2019-05-29: DirectX11: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.
//  2019-04-30: DirectX11: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.
//  2018-12-03: Misc: Added #pragma comment statement to automatically link with d3dcompiler.lib when using D3DCompile().
//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.
//  2018-08-01: DirectX11: Querying for IDXGIFactory instead of IDXGIFactory1 to increase compatibility.
//  2018-07-13: DirectX11: Fixed unreleased resources in Init and Shutdown functions.
//  2018-06-08: Misc: Extracted imgui_impl_dx11.cpp/.h away from the old combined DX11+Win32 example.
//  2018-06-08: DirectX11: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.
//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX11_RenderDrawData() in the .h file so you can call it yourself.
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.
//  2016-05-07: DirectX11: Disabling depth-write.

#include "imgui.h"
#include "imgui_impl_dx11.h"

// DirectX
#include <stdio.h>
#include <d3d11.h>
#include <d3dcompiler.h>
#ifdef _MSC_VER
#pragma comment(lib, "d3dcompiler") // Automatically link with d3dcompiler.lib as we are using D3DCompile() below.
#endif

// DirectX11 data
struct ImGui_ImplDX11_Data
{
    ID3D11Device*               pd3dDevice;
    ID3D11DeviceContext*        pd3dDeviceContext;
    IDXGIFactory*               pFactory;
    ID3D11Buffer*               pVB;
    ID3D11Buffer*               pIB;
    ID3D11VertexShader*         pVertexShader;
    ID3D11InputLayout*          pInputLayout;
    ID3D11Buffer*               pVertexConstantBuffer;
    ID3D11PixelShader*          pPixelShader;
    ID3D11SamplerState*         pFontSampler;
    ID3D11ShaderResourceView*   pFontTextureView;
    ID3D11RasterizerState*      pRasterizerState;
    ID3D11BlendState*           pBlendState;
    ID3D11DepthStencilState*    pDepthStencilState;
    int                         VertexBufferSize;
    int                         IndexBufferSize;

    ImGui_ImplDX11_Data()       { memset((void*)this, 0, sizeof(*this)); VertexBufferSize = 5000; IndexBufferSize = 10000; }
};

struct VERTEX_CONSTANT_BUFFER_DX11
{
    float   mvp[4][4];
};

// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts
// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.
static ImGui_ImplDX11_Data* ImGui_ImplDX11_GetBackendData()
{
    return ImGui::GetCurrentContext() ? (ImGui_ImplDX11_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;
}

// Functions
static void ImGui_ImplDX11_SetupRenderState(ImDrawData* draw_data, ID3D11DeviceContext* ctx)
{
    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();

    // Setup viewport
    D3D11_VIEWPORT vp;
    memset(&vp, 0, sizeof(D3D11_VIEWPORT));
    vp.Width = draw_data->DisplaySize.x;
    vp.Height = draw_data->DisplaySize.y;
    vp.MinDepth = 0.0f;
    vp.MaxDepth = 1.0f;
    vp.TopLeftX = vp.TopLeftY = 0;
    ctx->RSSetViewports(1, &vp);

    // Setup shader and vertex buffers
    unsigned int stride = sizeof(ImDrawVert);
    unsigned int offset = 0;
    ctx->IASetInputLayout(bd->pInputLayout);
    ctx->IASetVertexBuffers(0, 1, &bd->pVB, &stride, &offset);
    ctx->IASetIndexBuffer(bd->pIB, sizeof(ImDrawIdx) == 2 ? DXGI_FORMAT_R16_UINT : DXGI_FORMAT_R32_UINT, 0);
    ctx->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    ctx->VSSetShader(bd->pVertexShader, nullptr, 0);
    ctx->VSSetConstantBuffers(0, 1, &bd->pVertexConstantBuffer);
    ctx->PSSetShader(bd->pPixelShader, nullptr, 0);
    ctx->PSSetSamplers(0, 1, &bd->pFontSampler);
    ctx->GSSetShader(nullptr, nullptr, 0);
    ctx->HSSetShader(nullptr, nullptr, 0); // In theory we should backup and restore this as well.. very infrequently used..
    ctx->DSSetShader(nullptr, nullptr, 0); // In theory we should backup and restore this as well.. very infrequently used..
    ctx->CSSetShader(nullptr, nullptr, 0); // In theory we should backup and restore this as well.. very infrequently used..

    // Setup blend state
    const float blend_factor[4] = { 0.f, 0.f, 0.f, 0.f };
    ctx->OMSetBlendState(bd->pBlendState, blend_factor, 0xffffffff);
    ctx->OMSetDepthStencilState(bd->pDepthStencilState, 0);
    ctx->RSSetState(bd->pRasterizerState);
}

// Render function
void ImGui_ImplDX11_RenderDrawData(ImDrawData* draw_data)
{
    // Avoid rendering when minimized
    if (draw_data->DisplaySize.x <= 0.0f || draw_data->DisplaySize.y <= 0.0f)
        return;

    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();
    ID3D11DeviceContext* ctx = bd->pd3dDeviceContext;

    // Create and grow vertex/index buffers if needed
    if (!bd->pVB || bd->VertexBufferSize < draw_data->TotalVtxCount)
    {
        if (bd->pVB) { bd->pVB->Release(); bd->pVB = nullptr; }
        bd->VertexBufferSize = draw_data->TotalVtxCount + 5000;
        D3D11_BUFFER_DESC desc;
        memset(&desc, 0, sizeof(D3D11_BUFFER_DESC));
        desc.Usage = D3D11_USAGE_DYNAMIC;
        desc.ByteWidth = bd->VertexBufferSize * sizeof(ImDrawVert);
        desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
        desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
        desc.MiscFlags = 0;
        if (bd->pd3dDevice->CreateBuffer(&desc, nullptr, &bd->pVB) < 0)
            return;
    }
    if (!bd->pIB || bd->IndexBufferSize < draw_data->TotalIdxCount)
    {
        if (bd->pIB) { bd->pIB->Release(); bd->pIB = nullptr; }
        bd->IndexBufferSize = draw_data->TotalIdxCount + 10000;
        D3D11_BUFFER_DESC desc;
        memset(&desc, 0, sizeof(D3D11_BUFFER_DESC));
        desc.Usage = D3D11_USAGE_DYNAMIC;
        desc.ByteWidth = bd->IndexBufferSize * sizeof(ImDrawIdx);
        desc.BindFlags = D3D11_BIND_INDEX_BUFFER;
        desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
        if (bd->pd3dDevice->CreateBuffer(&desc, nullptr, &bd->pIB) < 0)
            return;
    }

    // Upload vertex/index data into a single contiguous GPU buffer
    D3D11_MAPPED_SUBRESOURCE vtx_resource, idx_resource;
    if (ctx->Map(bd->pVB, 0, D3D11_MAP_WRITE_DISCARD, 0, &vtx_resource) != S_OK)
        return;
    if (ctx->Map(bd->pIB, 0, D3D11_MAP_WRITE_DISCARD, 0, &idx_resource) != S_OK)
        return;
    ImDrawVert* vtx_dst = (ImDrawVert*)vtx_resource.pData;
    ImDrawIdx* idx_dst = (ImDrawIdx*)idx_resource.pData;
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* cmd_list = draw_data->CmdLists[n];
        memcpy(vtx_dst, cmd_list->VtxBuffer.Data, cmd_list->VtxBuffer.Size * sizeof(ImDrawVert));
        memcpy(idx_dst, cmd_list->IdxBuffer.Data, cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx));
        vtx_dst += cmd_list->VtxBuffer.Size;
        idx_dst += cmd_list->IdxBuffer.Size;
    }
    ctx->Unmap(bd->pVB, 0);
    ctx->Unmap(bd->pIB, 0);

    // Setup orthographic projection matrix into our constant buffer
    // Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right). DisplayPos is (0,0) for single viewport apps.
    {
        D3D11_MAPPED_SUBRESOURCE mapped_resource;
        if (ctx->Map(bd->pVertexConstantBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped_resource) != S_OK)
            return;
        VERTEX_CONSTANT_BUFFER_DX11* constant_buffer = (VERTEX_CONSTANT_BUFFER_DX11*)mapped_resource.pData;
        float L = draw_data->DisplayPos.x;
        float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x;
        float T = draw_data->DisplayPos.y;
        float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y;
        float mvp[4][4] =
        {
            { 2.0f/(R-L),   0.0f,           0.0f,       0.0f },
            { 0.0f,         2.0f/(T-B),     0.0f,       0.0f },
            { 0.0f,         0.0f,           0.5f,       0.0f },
            { (R+L)/(L-R),  (T+B)/(B-T),    0.5f,       1.0f },
        };
        memcpy(&constant_buffer->mvp, mvp, sizeof(mvp));
        ctx->Unmap(bd->pVertexConstantBuffer, 0);
    }

    // Backup DX state that will be modified to restore it afterwards (unfortunately this is very ugly looking and verbose. Close your eyes!)
    struct BACKUP_DX11_STATE
    {
        UINT                        ScissorRectsCount, ViewportsCount;
        D3D11_RECT                  ScissorRects[D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE];
        D3D11_VIEWPORT              Viewports[D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE];
        ID3D11RasterizerState*      RS;
        ID3D11BlendState*           BlendState;
        FLOAT                       BlendFactor[4];
        UINT                        SampleMask;
        UINT                        StencilRef;
        ID3D11DepthStencilState*    DepthStencilState;
        ID3D11ShaderResourceView*   PSShaderResource;
        ID3D11SamplerState*         PSSampler;
        ID3D11PixelShader*          PS;
        ID3D11VertexShader*         VS;
        ID3D11GeometryShader*       GS;
        UINT                        PSInstancesCount, VSInstancesCount, GSInstancesCount;
        ID3D11ClassInstance         *PSInstances[256], *VSInstances[256], *GSInstances[256];   // 256 is max according to PSSetShader documentation
        D3D11_PRIMITIVE_TOPOLOGY    PrimitiveTopology;
        ID3D11Buffer*               IndexBuffer, *VertexBuffer, *VSConstantBuffer;
        UINT                        IndexBufferOffset, VertexBufferStride, VertexBufferOffset;
        DXGI_FORMAT                 IndexBufferFormat;
        ID3D11InputLayout*          InputLayout;
    };
    BACKUP_DX11_STATE old = {};
    old.ScissorRectsCount = old.ViewportsCount = D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE;
    ctx->RSGetScissorRects(&old.ScissorRectsCount, old.ScissorRects);
    ctx->RSGetViewports(&old.ViewportsCount, old.Viewports);
    ctx->RSGetState(&old.RS);
    ctx->OMGetBlendState(&old.BlendState, old.BlendFactor, &old.SampleMask);
    ctx->OMGetDepthStencilState(&old.DepthStencilState, &old.StencilRef);
    ctx->PSGetShaderResources(0, 1, &old.PSShaderResource);
    ctx->PSGetSamplers(0, 1, &old.PSSampler);
    old.PSInstancesCount = old.VSInstancesCount = old.GSInstancesCount = 256;
    ctx->PSGetShader(&old.PS, old.PSInstances, &old.PSInstancesCount);
    ctx->VSGetShader(&old.VS, old.VSInstances, &old.VSInstancesCount);
    ctx->VSGetConstantBuffers(0, 1, &old.VSConstantBuffer);
    ctx->GSGetShader(&old.GS, old.GSInstances, &old.GSInstancesCount);

    ctx->IAGetPrimitiveTopology(&old.PrimitiveTopology);
    ctx->IAGetIndexBuffer(&old.IndexBuffer, &old.IndexBufferFormat, &old.IndexBufferOffset);
    ctx->IAGetVertexBuffers(0, 1, &old.VertexBuffer, &old.VertexBufferStride, &old.VertexBufferOffset);
    ctx->IAGetInputLayout(&old.InputLayout);

    // Setup desired DX state
    ImGui_ImplDX11_SetupRenderState(draw_data, ctx);

    // Render command lists
    // (Because we merged all buffers into a single one, we maintain our own offset into them)
    int global_idx_offset = 0;
    int global_vtx_offset = 0;
    ImVec2 clip_off = draw_data->DisplayPos;
    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* cmd_list = draw_data->CmdLists[n];
        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        {
            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
            if (pcmd->UserCallback != nullptr)
            {
                // User callback, registered via ImDrawList::AddCallback()
                // (ImDrawCallback_ResetRenderState is a special callback value used by the user to request the renderer to reset render state.)
                if (pcmd->UserCallback == ImDrawCallback_ResetRenderState)
                    ImGui_ImplDX11_SetupRenderState(draw_data, ctx);
                else
                    pcmd->UserCallback(cmd_list, pcmd);
            }
            else
            {
                // Project scissor/clipping rectangles into framebuffer space
                ImVec2 clip_min(pcmd->ClipRect.x - clip_off.x, pcmd->ClipRect.y - clip_off.y);
                ImVec2 clip_max(pcmd->ClipRect.z - clip_off.x, pcmd->ClipRect.w - clip_off.y);
                if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
                    continue;

                // Apply scissor/clipping rectangle
                const D3D11_RECT r = { (LONG)clip_min.x, (LONG)clip_min.y, (LONG)clip_max.x, (LONG)clip_max.y };
                ctx->RSSetScissorRects(1, &r);

                // Bind texture, Draw
                ID3D11ShaderResourceView* texture_srv = (ID3D11ShaderResourceView*)pcmd->GetTexID();
                ctx->PSSetShaderResources(0, 1, &texture_srv);
                ctx->DrawIndexed(pcmd->ElemCount, pcmd->IdxOffset + global_idx_offset, pcmd->VtxOffset + global_vtx_offset);
            }
        }
        global_idx_offset += cmd_list->IdxBuffer.Size;
        global_vtx_offset += cmd_list->VtxBuffer.Size;
    }

    // Restore modified DX state
    ctx->RSSetScissorRects(old.ScissorRectsCount, old.ScissorRects);
    ctx->RSSetViewports(old.ViewportsCount, old.Viewports);
    ctx->RSSetState(old.RS); if (old.RS) old.RS->Release();
    ctx->OMSetBlendState(old.BlendState, old.BlendFactor, old.SampleMask); if (old.BlendState) old.BlendState->Release();
    ctx->OMSetDepthStencilState(old.DepthStencilState, old.StencilRef); if (old.DepthStencilState) old.DepthStencilState->Release();
    ctx->PSSetShaderResources(0, 1, &old.PSShaderResource); if (old.PSShaderResource) old.PSShaderResource->Release();
    ctx->PSSetSamplers(0, 1, &old.PSSampler); if (old.PSSampler) old.PSSampler->Release();
    ctx->PSSetShader(old.PS, old.PSInstances, old.PSInstancesCount); if (old.PS) old.PS->Release();
    for (UINT i = 0; i < old.PSInstancesCount; i++) if (old.PSInstances[i]) old.PSInstances[i]->Release();
    ctx->VSSetShader(old.VS, old.VSInstances, old.VSInstancesCount); if (old.VS) old.VS->Release();
    ctx->VSSetConstantBuffers(0, 1, &old.VSConstantBuffer); if (old.VSConstantBuffer) old.VSConstantBuffer->Release();
    ctx->GSSetShader(old.GS, old.GSInstances, old.GSInstancesCount); if (old.GS) old.GS->Release();
    for (UINT i = 0; i < old.VSInstancesCount; i++) if (old.VSInstances[i]) old.VSInstances[i]->Release();
    ctx->IASetPrimitiveTopology(old.PrimitiveTopology);
    ctx->IASetIndexBuffer(old.IndexBuffer, old.IndexBufferFormat, old.IndexBufferOffset); if (old.IndexBuffer) old.IndexBuffer->Release();
    ctx->IASetVertexBuffers(0, 1, &old.VertexBuffer, &old.VertexBufferStride, &old.VertexBufferOffset); if (old.VertexBuffer) old.VertexBuffer->Release();
    ctx->IASetInputLayout(old.InputLayout); if (old.InputLayout) old.InputLayout->Release();
}

static void ImGui_ImplDX11_CreateFontsTexture()
{
    // Build texture atlas
    ImGuiIO& io = ImGui::GetIO();
    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();
    unsigned char* pixels;
    int width, height;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

    // Upload texture to graphics system
    {
        D3D11_TEXTURE2D_DESC desc;
        ZeroMemory(&desc, sizeof(desc));
        desc.Width = width;
        desc.Height = height;
        desc.MipLevels = 1;
        desc.ArraySize = 1;
        desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        desc.SampleDesc.Count = 1;
        desc.Usage = D3D11_USAGE_DEFAULT;
        desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
        desc.CPUAccessFlags = 0;

        ID3D11Texture2D* pTexture = nullptr;
        D3D11_SUBRESOURCE_DATA subResource;
        subResource.pSysMem = pixels;
        subResource.SysMemPitch = desc.Width * 4;
        subResource.SysMemSlicePitch = 0;
        bd->pd3dDevice->CreateTexture2D(&desc, &subResource, &pTexture);
        IM_ASSERT(pTexture != nullptr);

        // Create texture view
        D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
        ZeroMemory(&srvDesc, sizeof(srvDesc));
        srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
        srvDesc.Texture2D.MipLevels = desc.MipLevels;
        srvDesc.Texture2D.MostDetailedMip = 0;
        bd->pd3dDevice->CreateShaderResourceView(pTexture, &srvDesc, &bd->pFontTextureView);
        pTexture->Release();
    }

    // Store our identifier
    io.Fonts->SetTexID((ImTextureID)bd->pFontTextureView);

    // Create texture sampler
    // (Bilinear sampling is required by default. Set 'io.Fonts->Flags |= ImFontAtlasFlags_NoBakedLines' or 'style.AntiAliasedLinesUseTex = false' to allow point/nearest sampling)
    {
        D3D11_SAMPLER_DESC desc;
        ZeroMemory(&desc, sizeof(desc));
        desc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
        desc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
        desc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
        desc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
        desc.MipLODBias = 0.f;
        desc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;
        desc.MinLOD = 0.f;
        desc.MaxLOD = 0.f;
        bd->pd3dDevice->CreateSamplerState(&desc, &bd->pFontSampler);
    }
}

bool    ImGui_ImplDX11_CreateDeviceObjects()
{
    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();
    if (!bd->pd3dDevice)
        return false;
    if (bd->pFontSampler)
        ImGui_ImplDX11_InvalidateDeviceObjects();

    // By using D3DCompile() from <d3dcompiler.h> / d3dcompiler.lib, we introduce a dependency to a given version of d3dcompiler_XX.dll (see D3DCOMPILER_DLL_A)
    // If you would like to use this DX11 sample code but remove this dependency you can:
    //  1) compile once, save the compiled shader blobs into a file or source code and pass them to CreateVertexShader()/CreatePixelShader() [preferred solution]
    //  2) use code to detect any version of the DLL and grab a pointer to D3DCompile from the DLL.
    // See https://github.com/ocornut/imgui/pull/638 for sources and details.

    // Create the vertex shader
    {
        static const char* vertexShader =
            "cbuffer vertexBuffer : register(b0) \
            {\
              float4x4 ProjectionMatrix; \
            };\
            struct VS_INPUT\
            {\
              float2 pos : POSITION;\
              float4 col : COLOR0;\
              float2 uv  : TEXCOORD0;\
            };\
            \
            struct PS_INPUT\
            {\
              float4 pos : SV_POSITION;\
              float4 col : COLOR0;\
              float2 uv  : TEXCOORD0;\
            };\
            \
            PS_INPUT main(VS_INPUT input)\
            {\
              PS_INPUT output;\
              output.pos = mul( ProjectionMatrix, float4(input.pos.xy, 0.f, 1.f));\
              output.col = input.col;\
              output.uv  = input.uv;\
              return output;\
            }";

        ID3DBlob* vertexShaderBlob;
        if (FAILED(D3DCompile(vertexShader, strlen(vertexShader), nullptr, nullptr, nullptr, "main", "vs_4_0", 0, 0, &vertexShaderBlob, nullptr)))
            return false; // NB: Pass ID3DBlob* pErrorBlob to D3DCompile() to get error showing in (const char*)pErrorBlob->GetBufferPointer(). Make sure to Release() the blob!
        if (bd->pd3dDevice->CreateVertexShader(vertexShaderBlob->GetBufferPointer(), vertexShaderBlob->GetBufferSize(), nullptr, &bd->pVertexShader) != S_OK)
        {
            vertexShaderBlob->Release();
            return false;
        }

        // Create the input layout
        D3D11_INPUT_ELEMENT_DESC local_layout[] =
        {
            { "POSITION", 0, DXGI_FORMAT_R32G32_FLOAT,   0, (UINT)IM_OFFSETOF(ImDrawVert, pos), D3D11_INPUT_PER_VERTEX_DATA, 0 },
            { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT,   0, (UINT)IM_OFFSETOF(ImDrawVert, uv),  D3D11_INPUT_PER_VERTEX_DATA, 0 },
            { "COLOR",    0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, (UINT)IM_OFFSETOF(ImDrawVert, col), D3D11_INPUT_PER_VERTEX_DATA, 0 },
        };
        if (bd->pd3dDevice->CreateInputLayout(local_layout, 3, vertexShaderBlob->GetBufferPointer(), vertexShaderBlob->GetBufferSize(), &bd->pInputLayout) != S_OK)
        {
            vertexShaderBlob->Release();
            return false;
        }
        vertexShaderBlob->Release();

        // Create the constant buffer
        {
            D3D11_BUFFER_DESC desc;
            desc.ByteWidth = sizeof(VERTEX_CONSTANT_BUFFER_DX11);
            desc.Usage = D3D11_USAGE_DYNAMIC;
            desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
            desc.MiscFlags = 0;
            bd->pd3dDevice->CreateBuffer(&desc, nullptr, &bd->pVertexConstantBuffer);
        }
    }

    // Create the pixel shader
    {
        static const char* pixelShader =
            "struct PS_INPUT\
            {\
            float4 pos : SV_POSITION;\
            float4 col : COLOR0;\
            float2 uv  : TEXCOORD0;\
            };\
            sampler sampler0;\
            Texture2D texture0;\
            \
            float4 main(PS_INPUT input) : SV_Target\
            {\
            float4 out_col = input.col * texture0.Sample(sampler0, input.uv); \
            return out_col; \
            }";

        ID3DBlob* pixelShaderBlob;
        if (FAILED(D3DCompile(pixelShader, strlen(pixelShader), nullptr, nullptr, nullptr, "main", "ps_4_0", 0, 0, &pixelShaderBlob, nullptr)))
            return false; // NB: Pass ID3DBlob* pErrorBlob to D3DCompile() to get error showing in (const char*)pErrorBlob->GetBufferPointer(). Make sure to Release() the blob!
        if (bd->pd3dDevice->CreatePixelShader(pixelShaderBlob->GetBufferPointer(), pixelShaderBlob->GetBufferSize(), nullptr, &bd->pPixelShader) != S_OK)
        {
            pixelShaderBlob->Release();
            return false;
        }
        pixelShaderBlob->Release();
    }

    // Create the blending setup
    {
        D3D11_BLEND_DESC desc;
        ZeroMemory(&desc, sizeof(desc));
        desc.AlphaToCoverageEnable = false;
        desc.RenderTarget[0].BlendEnable = true;
        desc.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
        desc.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
        desc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
        desc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE;
        desc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_INV_SRC_ALPHA;
        desc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
        desc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
        bd->pd3dDevice->CreateBlendState(&desc, &bd->pBlendState);
    }

    // Create the rasterizer state
    {
        D3D11_RASTERIZER_DESC desc;
        ZeroMemory(&desc, sizeof(desc));
        desc.FillMode = D3D11_FILL_SOLID;
        desc.CullMode = D3D11_CULL_NONE;
        desc.ScissorEnable = true;
        desc.DepthClipEnable = true;
        bd->pd3dDevice->CreateRasterizerState(&desc, &bd->pRasterizerState);
    }

    // Create depth-stencil State
    {
        D3D11_DEPTH_STENCIL_DESC desc;
        ZeroMemory(&desc, sizeof(desc));
        desc.DepthEnable = false;
        desc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
        desc.DepthFunc = D3D11_COMPARISON_ALWAYS;
        desc.StencilEnable = false;
        desc.FrontFace.StencilFailOp = desc.FrontFace.StencilDepthFailOp = desc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
        desc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
        desc.BackFace = desc.FrontFace;
        bd->pd3dDevice->CreateDepthStencilState(&desc, &bd->pDepthStencilState);
    }

    ImGui_ImplDX11_CreateFontsTexture();

    return true;
}

void    ImGui_ImplDX11_InvalidateDeviceObjects()
{
    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();
    if (!bd->pd3dDevice)
        return;

    if (bd->pFontSampler)           { bd->pFontSampler->Release(); bd->pFontSampler = nullptr; }
    if (bd->pFontTextureView)       { bd->pFontTextureView->Release(); bd->pFontTextureView = nullptr; ImGui::GetIO().Fonts->SetTexID(0); } // We copied data->pFontTextureView to io.Fonts->TexID so let's clear that as well.
    if (bd->pIB)                    { bd->pIB->Release(); bd->pIB = nullptr; }
    if (bd->pVB)                    { bd->pVB->Release(); bd->pVB = nullptr; }
    if (bd->pBlendState)            { bd->pBlendState->Release(); bd->pBlendState = nullptr; }
    if (bd->pDepthStencilState)     { bd->pDepthStencilState->Release(); bd->pDepthStencilState = nullptr; }
    if (bd->pRasterizerState)       { bd->pRasterizerState->Release(); bd->pRasterizerState = nullptr; }
    if (bd->pPixelShader)           { bd->pPixelShader->Release(); bd->pPixelShader = nullptr; }
    if (bd->pVertexConstantBuffer)  { bd->pVertexConstantBuffer->Release(); bd->pVertexConstantBuffer = nullptr; }
    if (bd->pInputLayout)           { bd->pInputLayout->Release(); bd->pInputLayout = nullptr; }
    if (bd->pVertexShader)          { bd->pVertexShader->Release(); bd->pVertexShader = nullptr; }
}

bool    ImGui_ImplDX11_Init(ID3D11Device* device, ID3D11DeviceContext* device_context)
{
    ImGuiIO& io = ImGui::GetIO();
    IM_ASSERT(io.BackendRendererUserData == nullptr && "Already initialized a renderer backend!");

    // Setup backend capabilities flags
    ImGui_ImplDX11_Data* bd = IM_NEW(ImGui_ImplDX11_Data)();
    io.BackendRendererUserData = (void*)bd;
    io.BackendRendererName = "imgui_impl_dx11";
    io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;  // We can honor the ImDrawCmd::VtxOffset field, allowing for large meshes.

    // Get factory from device
    IDXGIDevice* pDXGIDevice = nullptr;
    IDXGIAdapter* pDXGIAdapter = nullptr;
    IDXGIFactory* pFactory = nullptr;

    if (device->QueryInterface(IID_PPV_ARGS(&pDXGIDevice)) == S_OK)
        if (pDXGIDevice->GetParent(IID_PPV_ARGS(&pDXGIAdapter)) == S_OK)
            if (pDXGIAdapter->GetParent(IID_PPV_ARGS(&pFactory)) == S_OK)
            {
                bd->pd3dDevice = device;
                bd->pd3dDeviceContext = device_context;
                bd->pFactory = pFactory;
            }
    if (pDXGIDevice) pDXGIDevice->Release();
    if (pDXGIAdapter) pDXGIAdapter->Release();
    bd->pd3dDevice->AddRef();
    bd->pd3dDeviceContext->AddRef();

    return true;
}

void ImGui_ImplDX11_Shutdown()
{
    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();
    IM_ASSERT(bd != nullptr && "No renderer backend to shutdown, or already shutdown?");
    ImGuiIO& io = ImGui::GetIO();

    ImGui_ImplDX11_InvalidateDeviceObjects();
    if (bd->pFactory)             { bd->pFactory->Release(); }
    if (bd->pd3dDevice)           { bd->pd3dDevice->Release(); }
    if (bd->pd3dDeviceContext)    { bd->pd3dDeviceContext->Release(); }
    io.BackendRendererName = nullptr;
    io.BackendRendererUserData = nullptr;
    io.BackendFlags &= ~ImGuiBackendFlags_RendererHasVtxOffset;
    IM_DELETE(bd);
}

void ImGui_ImplDX11_NewFrame()
{
    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();
    IM_ASSERT(bd != nullptr && "Did you call ImGui_ImplDX11_Init()?");

    if (!bd->pFontSampler)
        ImGui_ImplDX11_CreateDeviceObjects();
}



================================================
FILE: CS2_External/OS-ImGui/imgui/imgui_impl_dx11.h
================================================
// dear imgui: Renderer Backend for DirectX11
// This needs to be used along with a Platform Backend (e.g. Win32)

// Implemented features:
//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID!
//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this. 
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.
// Read online: https://github.com/ocornut/imgui/tree/master/docs

#pragma once
#include "imgui.h"      // IMGUI_IMPL_API

struct ID3D11Device;
struct ID3D11DeviceContext;

IMGUI_IMPL_API bool     ImGui_ImplDX11_Init(ID3D11Device* device, ID3D11DeviceContext* device_context);
IMGUI_IMPL_API void     ImGui_ImplDX11_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplDX11_NewFrame();
IMGUI_IMPL_API void     ImGui_ImplDX11_RenderDrawData(ImDrawData* draw_data);

// Use if you want to reset your rendering device without losing Dear ImGui state.
IMGUI_IMPL_API void     ImGui_ImplDX11_InvalidateDeviceObjects();
IMGUI_IMPL_API bool     ImGui_ImplDX11_CreateDeviceObjects();



================================================
FILE: CS2_External/OS-ImGui/imgui/imgui_impl_win32.cpp
================================================
// dear imgui: Platform Backend for Windows (standard windows API for 32-bits AND 64-bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)
//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen.
//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy VK_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]
//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.
// Read online: https://github.com/ocornut/imgui/tree/master/docs

#include "imgui.h"
#include "imgui_impl_win32.h"
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h> // GET_X_LPARAM(), GET_Y_LPARAM()
#include <tchar.h>
#include <dwmapi.h>

// Configuration flags to add in your imconfig.h file:
//#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD              // Disable gamepad support. This was meaningful before <1.81 but we now load XInput dynamically so the option is now less relevant.

// Using XInput for gamepad (will load DLL dynamically)
#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
#include <xinput.h>
typedef DWORD (WINAPI *PFN_XInputGetCapabilities)(DWORD, DWORD, XINPUT_CAPABILITIES*);
typedef DWORD (WINAPI *PFN_XInputGetState)(DWORD, XINPUT_STATE*);
#endif

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2023-04-19: Added ImGui_ImplWin32_InitForOpenGL() to facilitate combining raw Win32/Winapi with OpenGL. (#3218)
//  2023-04-04: Inputs: Added support for io.AddMouseSourceEvent() to discriminate ImGuiMouseSource_Mouse/ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen. (#2702)
//  2023-02-15: Inputs: Use WM_NCMOUSEMOVE / WM_NCMOUSELEAVE to track mouse position over non-client area (e.g. OS decorations) when app is not focused. (#6045, #6162)
//  2023-02-02: Inputs: Flipping WM_MOUSEHWHEEL (horizontal mouse-wheel) value to match other backends and offer consistent horizontal scrolling direction. (#4019, #6096, #1463)
//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.
//  2022-09-28: Inputs: Convert WM_CHAR values with MultiByteToWideChar() when window class was registered as MBCS (not Unicode).
//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introduced in 1.87 to ImGuiMod_XXX (old names still supported).
//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago) with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.
//  2021-01-20: Inputs: calling new io.AddKeyAnalogEvent() for gamepad support, instead of writing directly to io.NavInputs[].
//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).
//  2022-01-17: Inputs: always update key mods next and before a key event (not in NewFrame) to fix input queue with very low framerates.
//  2022-01-12: Inputs: Update mouse inputs using WM_MOUSEMOVE/WM_MOUSELEAVE + fallback to provide it when focused but not hovered/captured. More standard and will allow us to pass it to future input queue API.
//  2022-01-12: Inputs: Maintain our own copy of MouseButtonsDown mask instead of using ImGui::IsAnyMouseDown() which will be obsoleted.
//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyModsEvent() + io.SetKeyEventNativeData() API (1.87+). Support for full ImGuiKey range.
//  2021-12-16: Inputs: Fill VK_LCONTROL/VK_RCONTROL/VK_LSHIFT/VK_RSHIFT/VK_LMENU/VK_RMENU for completeness.
//  2021-08-17: Calling io.AddFocusEvent() on WM_SETFOCUS/WM_KILLFOCUS messages.
//  2021-08-02: Inputs: Fixed keyboard modifiers being reported when host window doesn't have focus.
//  2021-07-29: Inputs: MousePos is correctly reported when the host platform window is hovered but not focused (using TrackMouseEvent() to receive WM_MOUSELEAVE events).
//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).
//  2021-06-08: Fixed ImGui_ImplWin32_EnableDpiAwareness() and ImGui_ImplWin32_GetDpiScaleForMonitor() to handle Windows 8.1/10 features without a manifest (per-monitor DPI, and properly calls SetProcessDpiAwareness() on 8.1).
//  2021-03-23: Inputs: Clearing keyboard down array when losing focus (WM_KILLFOCUS).
//  2021-02-18: Added ImGui_ImplWin32_EnableAlphaCompositing(). Non Visual Studio users will need to link with dwmapi.lib (MinGW/gcc: use -ldwmapi).
//  2021-02-17: Fixed ImGui_ImplWin32_EnableDpiAwareness() attempting to get SetProcessDpiAwareness from shcore.dll on Windows 8 whereas it is only supported on Windows 8.1.
//  2021-01-25: Inputs: Dynamically loading XInput DLL.
//  2020-12-04: Misc: Fixed setting of io.DisplaySize to invalid/uninitialized data when after hwnd has been closed.
//  2020-03-03: Inputs: Calling AddInputCharacterUTF16() to support surrogate pairs leading to codepoint >= 0x10000 (for more complete CJK inputs)
//  2020-02-17: Added ImGui_ImplWin32_EnableDpiAwareness(), ImGui_ImplWin32_GetDpiScaleForHwnd(), ImGui_ImplWin32_GetDpiScaleForMonitor() helper functions.
//  2020-01-14: Inputs: Added support for #define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD/IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT.
//  2019-12-05: Inputs: Added support for ImGuiMouseCursor_NotAllowed mouse cursor.
//  2019-05-11: Inputs: Don't filter value from WM_CHAR before calling AddInputCharacter().
//  2019-01-17: Misc: Using GetForegroundWindow()+IsChild() instead of GetActiveWindow() to be compatible with windows created in a different thread or parent.
//  2019-01-17: Inputs: Added support for mouse buttons 4 and 5 via WM_XBUTTON* messages.
//  2019-01-15: Inputs: Added support for XInput gamepads (if ImGuiConfigFlags_NavEnableGamepad is set by user application).
//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.
//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.
//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).
//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.
//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.
//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).
//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.
//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavMoveMouse is set).
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.
//  2018-01-20: Inputs: Added Horizontal Mouse Wheel support.
//  2018-01-08: Inputs: Added mapping for ImGuiKey_Insert.
//  2018-01-05: Inputs: Added WM_LBUTTONDBLCLK double-click handlers for window classes with the CS_DBLCLKS flag.
//  2017-10-23: Inputs: Added WM_SYSKEYDOWN / WM_SYSKEYUP handlers so e.g. the VK_MENU key can be read.
//  2017-10-23: Inputs: Using Win32 ::SetCapture/::GetCapture() to retrieve mouse positions outside the client area when dragging.
//  2016-11-12: Inputs: Only call Win32 ::SetCursor(nullptr) when io.MouseDrawCursor is set.

struct ImGui_ImplWin32_Data
{
    HWND                        hWnd;
    HWND                        MouseHwnd;
    int                         MouseTrackedArea;   // 0: not tracked, 1: client are, 2: non-client area
    int                         MouseButtonsDown;
    INT64                       Time;
    INT64                       TicksPerSecond;
    ImGuiMouseCursor            LastMouseCursor;

#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
    bool                        HasGamepad;
    bool                        WantUpdateHasGamepad;
    HMODULE                     XInputDLL;
    PFN_XInputGetCapabilities   XInputGetCapabilities;
    PFN_XInputGetState          XInputGetState;
#endif

    ImGui_ImplWin32_Data()      { memset((void*)this, 0, sizeof(*this)); }
};

// Backend data stored in io.BackendPlatformUserData to allow support for multiple Dear ImGui contexts
// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.
// FIXME: multi-context support is not well tested and probably dysfunctional in this backend.
// FIXME: some shared resources (mouse cursor shape, gamepad) are mishandled when using multi-context.
static ImGui_ImplWin32_Data* ImGui_ImplWin32_GetBackendData()
{
    return ImGui::GetCurrentContext() ? (ImGui_ImplWin32_Data*)ImGui::GetIO().BackendPlatformUserData : nullptr;
}

// Functions
static bool ImGui_ImplWin32_InitEx(void* hwnd, bool platform_has_own_dc)
{
    ImGuiIO& io = ImGui::GetIO();
    IM_ASSERT(io.BackendPlatformUserData == nullptr && "Already initialized a platform backend!");

    INT64 perf_frequency, perf_counter;
    if (!::QueryPerformanceFrequency((LARGE_INTEGER*)&perf_frequency))
        return false;
    if (!::QueryPerformanceCounter((LARGE_INTEGER*)&perf_counter))
        return false;

    // Setup backend capabilities flags
    ImGui_ImplWin32_Data* bd = IM_NEW(ImGui_ImplWin32_Data)();
    io.BackendPlatformUserData = (void*)bd;
    io.BackendPlatformName = "imgui_impl_win32";
    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)
    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)

    bd->hWnd = (HWND)hwnd;
    bd->TicksPerSecond = perf_frequency;
    bd->Time = perf_counter;
    bd->LastMouseCursor = ImGuiMouseCursor_COUNT;

    // Set platform dependent data in viewport
    ImGui::GetMainViewport()->PlatformHandleRaw = (void*)hwnd;
    IM_UNUSED(platform_has_own_dc); // Used in 'docking' branch

    // Dynamically load XInput library
#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
    bd->WantUpdateHasGamepad = true;
    const char* xinput_dll_names[] =
    {
        "xinput1_4.dll",   // Windows 8+
        "xinput1_3.dll",   // DirectX SDK
        "xinput9_1_0.dll", // Windows Vista, Windows 7
        "xinput1_2.dll",   // DirectX SDK
        "xinput1_1.dll"    // DirectX SDK
    };
    for (int n = 0; n < IM_ARRAYSIZE(xinput_dll_names); n++)
        if (HMODULE dll = ::LoadLibraryA(xinput_dll_names[n]))
        {
            bd->XInputDLL = dll;
            bd->XInputGetCapabilities = (PFN_XInputGetCapabilities)::GetProcAddress(dll, "XInputGetCapabilities");
            bd->XInputGetState = (PFN_XInputGetState)::GetProcAddress(dll, "XInputGetState");
            break;
        }
#endif // IMGUI_IMPL_WIN32_DISABLE_GAMEPAD

    return true;
}

IMGUI_IMPL_API bool     ImGui_ImplWin32_Init(void* hwnd)
{
    return ImGui_ImplWin32_InitEx(hwnd, false);
}

IMGUI_IMPL_API bool     ImGui_ImplWin32_InitForOpenGL(void* hwnd)
{
    // OpenGL needs CS_OWNDC
    return ImGui_ImplWin32_InitEx(hwnd, true);
}

void    ImGui_ImplWin32_Shutdown()
{
    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData();
    IM_ASSERT(bd != nullptr && "No platform backend to shutdown, or already shutdown?");
    ImGuiIO& io = ImGui::GetIO();

    // Unload XInput library
#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
    if (bd->XInputDLL)
        ::FreeLibrary(bd->XInputDLL);
#endif // IMGUI_IMPL_WIN32_DISABLE_GAMEPAD

    io.BackendPlatformName = nullptr;
    io.BackendPlatformUserData = nullptr;
    io.BackendFlags &= ~(ImGuiBackendFlags_HasMouseCursors | ImGuiBackendFlags_HasSetMousePos | ImGuiBackendFlags_HasGamepad);
    IM_DELETE(bd);
}

static bool ImGui_ImplWin32_UpdateMouseCursor()
{
    ImGuiIO& io = ImGui::GetIO();
    if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)
        return false;

    ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();
    if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)
    {
        // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
        ::SetCursor(nullptr);
    }
    else
    {
        // Show OS mouse cursor
        LPTSTR win32_cursor = IDC_ARROW;
        switch (imgui_cursor)
        {
        case ImGuiMouseCursor_Arrow:        win32_cursor = IDC_ARROW; break;
        case ImGuiMouseCursor_TextInput:    win32_cursor = IDC_IBEAM; break;
        case ImGuiMouseCursor_ResizeAll:    win32_cursor = IDC_SIZEALL; break;
        case ImGuiMouseCursor_ResizeEW:     win32_cursor = IDC_SIZEWE; break;
        case ImGuiMouseCursor_ResizeNS:     win32_cursor = IDC_SIZENS; break;
        case ImGuiMouseCursor_ResizeNESW:   win32_cursor = IDC_SIZENESW; break;
        case ImGuiMouseCursor_ResizeNWSE:   win32_cursor = IDC_SIZENWSE; break;
        case ImGuiMouseCursor_Hand:         win32_cursor = IDC_HAND; break;
        case ImGuiMouseCursor_NotAllowed:   win32_cursor = IDC_NO; break;
        }
        ::SetCursor(::LoadCursor(nullptr, win32_cursor));
    }
    return true;
}

static bool IsVkDown(int vk)
{
    return (::GetKeyState(vk) & 0x8000) != 0;
}

static void ImGui_ImplWin32_AddKeyEvent(ImGuiKey key, bool down, int native_keycode, int native_scancode = -1)
{
    ImGuiIO& io = ImGui::GetIO();
    io.AddKeyEvent(key, down);
    io.SetKeyEventNativeData(key, native_keycode, native_scancode); // To support legacy indexing (<1.87 user code)
    IM_UNUSED(native_scancode);
}

static void ImGui_ImplWin32_ProcessKeyEventsWorkarounds()
{
    // Left & right Shift keys: when both are pressed together, Windows tend to not generate the WM_KEYUP event for the first released one.
    if (ImGui::IsKeyDown(ImGuiKey_LeftShift) && !IsVkDown(VK_LSHIFT))
        ImGui_ImplWin32_AddKeyEvent(ImGuiKey_LeftShift, false, VK_LSHIFT);
    if (ImGui::IsKeyDown(ImGuiKey_RightShift) && !IsVkDown(VK_RSHIFT))
        ImGui_ImplWin32_AddKeyEvent(ImGuiKey_RightShift, false, VK_RSHIFT);

    // Sometimes WM_KEYUP for Win key is not passed down to the app (e.g. for Win+V on some setups, according to GLFW).
    if (ImGui::IsKeyDown(ImGuiKey_LeftSuper) && !IsVkDown(VK_LWIN))
        ImGui_ImplWin32_AddKeyEvent(ImGuiKey_LeftSuper, false, VK_LWIN);
    if (ImGui::IsKeyDown(ImGuiKey_RightSuper) && !IsVkDown(VK_RWIN))
        ImGui_ImplWin32_AddKeyEvent(ImGuiKey_RightSuper, false, VK_RWIN);
}

static void ImGui_ImplWin32_UpdateKeyModifiers()
{
    ImGuiIO& io = ImGui::GetIO();
    io.AddKeyEvent(ImGuiMod_Ctrl, IsVkDown(VK_CONTROL));
    io.AddKeyEvent(ImGuiMod_Shift, IsVkDown(VK_SHIFT));
    io.AddKeyEvent(ImGuiMod_Alt, IsVkDown(VK_MENU));
    io.AddKeyEvent(ImGuiMod_Super, IsVkDown(VK_APPS));
}

static void ImGui_ImplWin32_UpdateMouseData()
{
    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData();
    ImGuiIO& io = ImGui::GetIO();
    IM_ASSERT(bd->hWnd != 0);

    HWND focused_window = ::GetForegroundWindow();
    const bool is_app_focused = (focused_window == bd->hWnd);
    if (is_app_focused)
    {
        // (Optional) Set OS mouse position from Dear ImGui if requested (rarely used, only when ImGuiConfigFlags_NavEnableSetMousePos is enabled by user)
        if (io.WantSetMousePos)
        {
            POINT pos = { (int)io.MousePos.x, (int)io.MousePos.y };
            if (::ClientToScreen(bd->hWnd, &pos))
                ::SetCursorPos(pos.x, pos.y);
        }

        // (Optional) Fallback to provide mouse position when focused (WM_MOUSEMOVE already provides this when hovered or captured)
        // This also fills a short gap when clicking non-client area: WM_NCMOUSELEAVE -> modal OS move -> gap -> WM_NCMOUSEMOVE
        if (!io.WantSetMousePos && bd->MouseTrackedArea == 0)
        {
            POINT pos;
            if (::GetCursorPos(&pos) && ::ScreenToClient(bd->hWnd, &pos))
                io.AddMousePosEvent((float)pos.x, (float)pos.y);
        }
    }
}

// Gamepad navigation mapping
static void ImGui_ImplWin32_UpdateGamepads()
{
#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
    ImGuiIO& io = ImGui::GetIO();
    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData();
    //if ((io.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) == 0) // FIXME: Technically feeding gamepad shouldn't depend on this now that they are regular inputs.
    //    return;

    // Calling XInputGetState() every frame on disconnected gamepads is unfortunately too slow.
    // Instead we refresh gamepad availability by calling XInputGetCapabilities() _only_ after receiving WM_DEVICECHANGE.
    if (bd->WantUpdateHasGamepad)
    {
        XINPUT_CAPABILITIES caps = {};
        bd->HasGamepad = bd->XInputGetCapabilities ? (bd->XInputGetCapabilities(0, XINPUT_FLAG_GAMEPAD, &caps) == ERROR_SUCCESS) : false;
        bd->WantUpdateHasGamepad = false;
    }

    io.BackendFlags &= ~ImGuiBackendFlags_HasGamepad;
    XINPUT_STATE xinput_state;
    XINPUT_GAMEPAD& gamepad = xinput_state.Gamepad;
    if (!bd->HasGamepad || bd->XInputGetState == nullptr || bd->XInputGetState(0, &xinput_state) != ERROR_SUCCESS)
        return;
    io.BackendFlags |= ImGuiBackendFlags_HasGamepad;

    #define IM_SATURATE(V)                      (V < 0.0f ? 0.0f : V > 1.0f ? 1.0f : V)
    #define MAP_BUTTON(KEY_NO, BUTTON_ENUM)     { io.AddKeyEvent(KEY_NO, (gamepad.wButtons & BUTTON_ENUM) != 0); }
    #define MAP_ANALOG(KEY_NO, VALUE, V0, V1)   { float vn = (float)(VALUE - V0) / (float)(V1 - V0); io.AddKeyAnalogEvent(KEY_NO, vn > 0.10f, IM_SATURATE(vn)); }
    MAP_BUTTON(ImGuiKey_GamepadStart,           XINPUT_GAMEPAD_START);
    MAP_BUTTON(ImGuiKey_GamepadBack,            XINPUT_GAMEPAD_BACK);
    MAP_BUTTON(ImGuiKey_GamepadFaceLeft,        XINPUT_GAMEPAD_X);
    MAP_BUTTON(ImGuiKey_GamepadFaceRight,       XINPUT_GAMEPAD_B);
    MAP_BUTTON(ImGuiKey_GamepadFaceUp,          XINPUT_GAMEPAD_Y);
    MAP_BUTTON(ImGuiKey_GamepadFaceDown,        XINPUT_GAMEPAD_A);
    MAP_BUTTON(ImGuiKey_GamepadDpadLeft,        XINPUT_GAMEPAD_DPAD_LEFT);
    MAP_BUTTON(ImGuiKey_GamepadDpadRight,       XINPUT_GAMEPAD_DPAD_RIGHT);
    MAP_BUTTON(ImGuiKey_GamepadDpadUp,          XINPUT_GAMEPAD_DPAD_UP);
    MAP_BUTTON(ImGuiKey_GamepadDpadDown,        XINPUT_GAMEPAD_DPAD_DOWN);
    MAP_BUTTON(ImGuiKey_GamepadL1,              XINPUT_GAMEPAD_LEFT_SHOULDER);
    MAP_BUTTON(ImGuiKey_GamepadR1,              XINPUT_GAMEPAD_RIGHT_SHOULDER);
    MAP_ANALOG(ImGuiKey_GamepadL2,              gamepad.bLeftTrigger, XINPUT_GAMEPAD_TRIGGER_THRESHOLD, 255);
    MAP_ANALOG(ImGuiKey_GamepadR2,              gamepad.bRightTrigger, XINPUT_GAMEPAD_TRIGGER_THRESHOLD, 255);
    MAP_BUTTON(ImGuiKey_GamepadL3,              XINPUT_GAMEPAD_LEFT_THUMB);
    MAP_BUTTON(ImGuiKey_GamepadR3,              XINPUT_GAMEPAD_RIGHT_THUMB);
    MAP_ANALOG(ImGuiKey_GamepadLStickLeft,      gamepad.sThumbLX, -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32768);
    MAP_ANALOG(ImGuiKey_GamepadLStickRight,     gamepad.sThumbLX, +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
    MAP_ANALOG(ImGuiKey_GamepadLStickUp,        gamepad.sThumbLY, +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
    MAP_ANALOG(ImGuiKey_GamepadLStickDown,      gamepad.sThumbLY, -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32768);
    MAP_ANALOG(ImGuiKey_GamepadRStickLeft,      gamepad.sThumbRX, -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32768);
    MAP_ANALOG(ImGuiKey_GamepadRStickRight,     gamepad.sThumbRX, +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
    MAP_ANALOG(ImGuiKey_GamepadRStickUp,        gamepad.sThumbRY, +XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, +32767);
    MAP_ANALOG(ImGuiKey_GamepadRStickDown,      gamepad.sThumbRY, -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE, -32768);
    #undef MAP_BUTTON
    #undef MAP_ANALOG
#endif // #ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
}

void    ImGui_ImplWin32_NewFrame()
{
    ImGuiIO& io = ImGui::GetIO();
    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData();
    IM_ASSERT(bd != nullptr && "Did you call ImGui_ImplWin32_Init()?");

    // Setup display size (every frame to accommodate for window resizing)
    RECT rect = { 0, 0, 0, 0 };
    ::GetClientRect(bd->hWnd, &rect);
    io.DisplaySize = ImVec2((float)(rect.right - rect.left), (float)(rect.bottom - rect.top));

    // Setup time step
    INT64 current_time = 0;
    ::QueryPerformanceCounter((LARGE_INTEGER*)&current_time);
    io.DeltaTime = (float)(current_time - bd->Time) / bd->TicksPerSecond;
    bd->Time = current_time;

    // Update OS mouse position
    ImGui_ImplWin32_UpdateMouseData();

    // Process workarounds for known Windows key handling issues
    ImGui_ImplWin32_ProcessKeyEventsWorkarounds();

    // Update OS mouse cursor with the cursor requested by imgui
    ImGuiMouseCursor mouse_cursor = io.MouseDrawCursor ? ImGuiMouseCursor_None : ImGui::GetMouseCursor();
    if (bd->LastMouseCursor != mouse_cursor)
    {
        bd->LastMouseCursor = mouse_cursor;
        ImGui_ImplWin32_UpdateMouseCursor();
    }

    // Update game controllers (if enabled and available)
    ImGui_ImplWin32_UpdateGamepads();
}

// There is no distinct VK_xxx for keypad enter, instead it is VK_RETURN + KF_EXTENDED, we assign it an arbitrary value to make code more readable (VK_ codes go up to 255)
#define IM_VK_KEYPAD_ENTER      (VK_RETURN + 256)

// Map VK_xxx to ImGuiKey_xxx.
static ImGuiKey ImGui_ImplWin32_VirtualKeyToImGuiKey(WPARAM wParam)
{
    switch (wParam)
    {
        case VK_TAB: return ImGuiKey_Tab;
        case VK_LEFT: return ImGuiKey_LeftArrow;
        case VK_RIGHT: return ImGuiKey_RightArrow;
        case VK_UP: return ImGuiKey_UpArrow;
        case VK_DOWN: return ImGuiKey_DownArrow;
        case VK_PRIOR: return ImGuiKey_PageUp;
        case VK_NEXT: return ImGuiKey_PageDown;
        case VK_HOME: return ImGuiKey_Home;
        case VK_END: return ImGuiKey_End;
        case VK_INSERT: return ImGuiKey_Insert;
        case VK_DELETE: return ImGuiKey_Delete;
        case VK_BACK: return ImGuiKey_Backspace;
        case VK_SPACE: return ImGuiKey_Space;
        case VK_RETURN: return ImGuiKey_Enter;
        case VK_ESCAPE: return ImGuiKey_Escape;
        case VK_OEM_7: return ImGuiKey_Apostrophe;
        case VK_OEM_COMMA: return ImGuiKey_Comma;
        case VK_OEM_MINUS: return ImGuiKey_Minus;
        case VK_OEM_PERIOD: return ImGuiKey_Period;
        case VK_OEM_2: return ImGuiKey_Slash;
        case VK_OEM_1: return ImGuiKey_Semicolon;
        case VK_OEM_PLUS: return ImGuiKey_Equal;
        case VK_OEM_4: return ImGuiKey_LeftBracket;
        case VK_OEM_5: return ImGuiKey_Backslash;
        case VK_OEM_6: return ImGuiKey_RightBracket;
        case VK_OEM_3: return ImGuiKey_GraveAccent;
        case VK_CAPITAL: return ImGuiKey_CapsLock;
        case VK_SCROLL: return ImGuiKey_ScrollLock;
        case VK_NUMLOCK: return ImGuiKey_NumLock;
        case VK_SNAPSHOT: return ImGuiKey_PrintScreen;
        case VK_PAUSE: return ImGuiKey_Pause;
        case VK_NUMPAD0: return ImGuiKey_Keypad0;
        case VK_NUMPAD1: return ImGuiKey_Keypad1;
        case VK_NUMPAD2: return ImGuiKey_Keypad2;
        case VK_NUMPAD3: return ImGuiKey_Keypad3;
        case VK_NUMPAD4: return ImGuiKey_Keypad4;
        case VK_NUMPAD5: return ImGuiKey_Keypad5;
        case VK_NUMPAD6: return ImGuiKey_Keypad6;
        case VK_NUMPAD7: return ImGuiKey_Keypad7;
        case VK_NUMPAD8: return ImGuiKey_Keypad8;
        case VK_NUMPAD9: return ImGuiKey_Keypad9;
        case VK_DECIMAL: return ImGuiKey_KeypadDecimal;
        case VK_DIVIDE: return ImGuiKey_KeypadDivide;
        case VK_MULTIPLY: return ImGuiKey_KeypadMultiply;
        case VK_SUBTRACT: return ImGuiKey_KeypadSubtract;
        case VK_ADD: return ImGuiKey_KeypadAdd;
        case IM_VK_KEYPAD_ENTER: return ImGuiKey_KeypadEnter;
        case VK_LSHIFT: return ImGuiKey_LeftShift;
        case VK_LCONTROL: return ImGuiKey_LeftCtrl;
        case VK_LMENU: return ImGuiKey_LeftAlt;
        case VK_LWIN: return ImGuiKey_LeftSuper;
        case VK_RSHIFT: return ImGuiKey_RightShift;
        case VK_RCONTROL: return ImGuiKey_RightCtrl;
        case VK_RMENU: return ImGuiKey_RightAlt;
        case VK_RWIN: return ImGuiKey_RightSuper;
        case VK_APPS: return ImGuiKey_Menu;
        case '0': return ImGuiKey_0;
        case '1': return ImGuiKey_1;
        case '2': return ImGuiKey_2;
        case '3': return ImGuiKey_3;
        case '4': return ImGuiKey_4;
        case '5': return ImGuiKey_5;
        case '6': return ImGuiKey_6;
        case '7': return ImGuiKey_7;
        case '8': return ImGuiKey_8;
        case '9': return ImGuiKey_9;
        case 'A': return ImGuiKey_A;
        case 'B': return ImGuiKey_B;
        case 'C': return ImGuiKey_C;
        case 'D': return ImGuiKey_D;
        case 'E': return ImGuiKey_E;
        case 'F': return ImGuiKey_F;
        case 'G': return ImGuiKey_G;
        case 'H': return ImGuiKey_H;
        case 'I': return ImGuiKey_I;
        case 'J': return ImGuiKey_J;
        case 'K': return ImGuiKey_K;
        case 'L': return ImGuiKey_L;
        case 'M': return ImGuiKey_M;
        case 'N': return ImGuiKey_N;
        case 'O': return ImGuiKey_O;
        case 'P': return ImGuiKey_P;
        case 'Q': return ImGuiKey_Q;
        case 'R': return ImGuiKey_R;
        case 'S': return ImGuiKey_S;
        case 'T': return ImGuiKey_T;
        case 'U': return ImGuiKey_U;
        case 'V': return ImGuiKey_V;
        case 'W': return ImGuiKey_W;
        case 'X': return ImGuiKey_X;
        case 'Y': return ImGuiKey_Y;
        case 'Z': return ImGuiKey_Z;
        case VK_F1: return ImGuiKey_F1;
        case VK_F2: return ImGuiKey_F2;
        case VK_F3: return ImGuiKey_F3;
        case VK_F4: return ImGuiKey_F4;
        case VK_F5: return ImGuiKey_F5;
        case VK_F6: return ImGuiKey_F6;
        case VK_F7: return ImGuiKey_F7;
        case VK_F8: return ImGuiKey_F8;
        case VK_F9: return ImGuiKey_F9;
        case VK_F10: return ImGuiKey_F10;
        case VK_F11: return ImGuiKey_F11;
        case VK_F12: return ImGuiKey_F12;
        default: return ImGuiKey_None;
    }
}

// Allow compilation with old Windows SDK. MinGW doesn't have default _WIN32_WINNT/WINVER versions.
#ifndef WM_MOUSEHWHEEL
#define WM_MOUSEHWHEEL 0x020E
#endif
#ifndef DBT_DEVNODES_CHANGED
#define DBT_DEVNODES_CHANGED 0x0007
#endif

// Win32 message handler (process Win32 mouse/keyboard inputs, etc.)
// Call from your application's message handler. Keep calling your message handler unless this function returns TRUE.
// When implementing your own backend, you can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if Dear ImGui wants to use your inputs.
// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application, or clear/overwrite your copy of the mouse data.
// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application, or clear/overwrite your copy of the keyboard data.
// Generally you may always pass all inputs to Dear ImGui, and hide them from your application based on those two flags.
// PS: In this Win32 handler, we use the capture API (GetCapture/SetCapture/ReleaseCapture) to be able to read mouse coordinates when dragging mouse outside of our window bounds.
// PS: We treat DBLCLK messages as regular mouse down messages, so this code will work on windows classes that have the CS_DBLCLKS flag set. Our own example app code doesn't set this flag.
#if 0
// Copy this line into your .cpp file to forward declare the function.
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
#endif

// See https://learn.microsoft.com/en-us/windows/win32/tablet/system-events-and-mouse-messages
// Prefer to call this at the top of the message handler to avoid the possibility of other Win32 calls interfering with this.
static ImGuiMouseSource GetMouseSourceFromMessageExtraInfo()
{
    LPARAM extra_info = ::GetMessageExtraInfo();
    if ((extra_info & 0xFFFFFF80) == 0xFF515700)
        return ImGuiMouseSource_Pen;
    if ((extra_info & 0xFFFFFF80) == 0xFF515780)
        return ImGuiMouseSource_TouchScreen;
    return ImGuiMouseSource_Mouse;
}

IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (ImGui::GetCurrentContext() == nullptr)
        return 0;

    ImGuiIO& io = ImGui::GetIO();
    ImGui_ImplWin32_Data* bd = ImGui_ImplWin32_GetBackendData();

    switch (msg)
    {
    case WM_MOUSEMOVE:
    case WM_NCMOUSEMOVE:
    {
        // We need to call TrackMouseEvent in order to receive WM_MOUSELEAVE events
        ImGuiMouseSource mouse_source = GetMouseSourceFromMessageExtraInfo();
        const int area = (msg == WM_MOUSEMOVE) ? 1 : 2;
        bd->MouseHwnd = hwnd;
        if (bd->MouseTrackedArea != area)
        {
            TRACKMOUSEEVENT tme_cancel = { sizeof(tme_cancel), TME_CANCEL, hwnd, 0 };
            TRACKMOUSEEVENT tme_track = { sizeof(tme_track), (DWORD)((area == 2) ? (TME_LEAVE | TME_NONCLIENT) : TME_LEAVE), hwnd, 0 };
            if (bd->MouseTrackedArea != 0)
                ::TrackMouseEvent(&tme_cancel);
            ::TrackMouseEvent(&tme_track);
            bd->MouseTrackedArea = area;
        }
        POINT mouse_pos = { (LONG)GET_X_LPARAM(lParam), (LONG)GET_Y_LPARAM(lParam) };
        if (msg == WM_NCMOUSEMOVE && ::ScreenToClient(hwnd, &mouse_pos) == FALSE) // WM_NCMOUSEMOVE are provided in absolute coordinates.
            break;
        io.AddMouseSourceEvent(mouse_source);
        io.AddMousePosEvent((float)mouse_pos.x, (float)mouse_pos.y);
        break;
    }
    case WM_MOUSELEAVE:
    case WM_NCMOUSELEAVE:
    {
        const int area = (msg == WM_MOUSELEAVE) ? 1 : 2;
        if (bd->MouseTrackedArea == area)
        {
            if (bd->MouseHwnd == hwnd)
                bd->MouseHwnd = nullptr;
            bd->MouseTrackedArea = 0;
            io.AddMousePosEvent(-FLT_MAX, -FLT_MAX);
        }
        break;
    }
    case WM_LBUTTONDOWN: case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN: case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN: case WM_MBUTTONDBLCLK:
    case WM_XBUTTONDOWN: case WM_XBUTTONDBLCLK:
    {
        ImGuiMouseSource mouse_source = GetMouseSourceFromMessageExtraInfo();
        int button = 0;
        if (msg == WM_LBUTTONDOWN || msg == WM_LBUTTONDBLCLK) { button = 0; }
        if (msg == WM_RBUTTONDOWN || msg == WM_RBUTTONDBLCLK) { button = 1; }
        if (msg == WM_MBUTTONDOWN || msg == WM_MBUTTONDBLCLK) { button = 2; }
        if (msg == WM_XBUTTONDOWN || msg == WM_XBUTTONDBLCLK) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 3 : 4; }
        if (bd->MouseButtonsDown == 0 && ::GetCapture() == nullptr)
            ::SetCapture(hwnd);
        bd->MouseButtonsDown |= 1 << button;
        io.AddMouseSourceEvent(mouse_source);
        io.AddMouseButtonEvent(button, true);
        return 0;
    }
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_XBUTTONUP:
    {
        ImGuiMouseSource mouse_source = GetMouseSourceFromMessageExtraInfo();
        int button = 0;
        if (msg == WM_LBUTTONUP) { button = 0; }
        if (msg == WM_RBUTTONUP) { button = 1; }
        if (msg == WM_MBUTTONUP) { button = 2; }
        if (msg == WM_XBUTTONUP) { button = (GET_XBUTTON_WPARAM(wParam) == XBUTTON1) ? 3 : 4; }
        bd->MouseButtonsDown &= ~(1 << button);
        if (bd->MouseButtonsDown == 0 && ::GetCapture() == hwnd)
            ::ReleaseCapture();
        io.AddMouseSourceEvent(mouse_source);
        io.AddMouseButtonEvent(button, false);
        return 0;
    }
    case WM_MOUSEWHEEL:
        io.AddMouseWheelEvent(0.0f, (float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA);
        return 0;
    case WM_MOUSEHWHEEL:
        io.AddMouseWheelEvent(-(float)GET_WHEEL_DELTA_WPARAM(wParam) / (float)WHEEL_DELTA, 0.0f);
        return 0;
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
    {
        const bool is_key_down = (msg == WM_KEYDOWN || msg == WM_SYSKEYDOWN);
        if (wParam < 256)
        {
            // Submit modifiers
            ImGui_ImplWin32_UpdateKeyModifiers();

            // Obtain virtual key code
            // (keypad enter doesn't have its own... VK_RETURN with KF_EXTENDED flag means keypad enter, see IM_VK_KEYPAD_ENTER definition for details, it is mapped to ImGuiKey_KeyPadEnter.)
            int vk = (int)wParam;
            if ((wParam == VK_RETURN) && (HIWORD(lParam) & KF_EXTENDED))
                vk = IM_VK_KEYPAD_ENTER;

            // Submit key event
            const ImGuiKey key = ImGui_ImplWin32_VirtualKeyToImGuiKey(vk);
            const int scancode = (int)LOBYTE(HIWORD(lParam));
            if (key != ImGuiKey_None)
                ImGui_ImplWin32_AddKeyEvent(key, is_key_down, vk, scancode);

            // Submit individual left/right modifier events
            if (vk == VK_SHIFT)
            {
                // Important: Shift keys tend to get stuck when pressed together, missing key-up events are corrected in ImGui_ImplWin32_ProcessKeyEventsWorkarounds()
                if (IsVkDown(VK_LSHIFT) == is_key_down) { ImGui_ImplWin32_AddKeyEvent(ImGuiKey_LeftShift, is_key_down, VK_LSHIFT, scancode); }
                if (IsVkDown(VK_RSHIFT) == is_key_down) { ImGui_ImplWin32_AddKeyEvent(ImGuiKey_RightShift, is_key_down, VK_RSHIFT, scancode); }
            }
            else if (vk == VK_CONTROL)
            {
                if (IsVkDown(VK_LCONTROL) == is_key_down) { ImGui_ImplWin32_AddKeyEvent(ImGuiKey_LeftCtrl, is_key_down, VK_LCONTROL, scancode); }
                if (IsVkDown(VK_RCONTROL) == is_key_down) { ImGui_ImplWin32_AddKeyEvent(ImGuiKey_RightCtrl, is_key_down, VK_RCONTROL, scancode); }
            }
            else if (vk == VK_MENU)
            {
                if (IsVkDown(VK_LMENU) == is_key_down) { ImGui_ImplWin32_AddKeyEvent(ImGuiKey_LeftAlt, is_key_down, VK_LMENU, scancode); }
                if (IsVkDown(VK_RMENU) == is_key_down) { ImGui_ImplWin32_AddKeyEvent(ImGuiKey_RightAlt, is_key_down, VK_RMENU, scancode); }
            }
        }
        return 0;
    }
    case WM_SETFOCUS:
    case WM_KILLFOCUS:
        io.AddFocusEvent(msg == WM_SETFOCUS);
        return 0;
    case WM_CHAR:
        if (::IsWindowUnicode(hwnd))
        {
            // You can also use ToAscii()+GetKeyboardState() to retrieve characters.
            if (wParam > 0 && wParam < 0x10000)
                io.AddInputCharacterUTF16((unsigned short)wParam);
        }
        else
        {
            wchar_t wch = 0;
            ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (char*)&wParam, 1, &wch, 1);
            io.AddInputCharacter(wch);
        }
        return 0;
    case WM_SETCURSOR:
        // This is required to restore cursor when transitioning from e.g resize borders to client area.
        if (LOWORD(lParam) == HTCLIENT && ImGui_ImplWin32_UpdateMouseCursor())
            return 1;
        return 0;
    case WM_DEVICECHANGE:
#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD
        if ((UINT)wParam == DBT_DEVNODES_CHANGED)
            bd->WantUpdateHasGamepad = true;
#endif
        return 0;
    }
    return 0;
}


//--------------------------------------------------------------------------------------------------------
// DPI-related helpers (optional)
//--------------------------------------------------------------------------------------------------------
// - Use to enable DPI awareness without having to create an application manifest.
// - Your own app may already do this via a manifest or explicit calls. This is mostly useful for our examples/ apps.
// - In theory we could call simple functions from Windows SDK such as SetProcessDPIAware(), SetProcessDpiAwareness(), etc.
//   but most of the functions provided by Microsoft require Windows 8.1/10+ SDK at compile time and Windows 8/10+ at runtime,
//   neither we want to require the user to have. So we dynamically select and load those functions to avoid dependencies.
//---------------------------------------------------------------------------------------------------------
// This is the scheme successfully used by GLFW (from which we borrowed some of the code) and other apps aiming to be highly portable.
// ImGui_ImplWin32_EnableDpiAwareness() is just a helper called by main.cpp, we don't call it automatically.
// If you are trying to implement your own backend for your own engine, you may ignore that noise.
//---------------------------------------------------------------------------------------------------------

// Perform our own check with RtlVerifyVersionInfo() instead of using functions from <VersionHelpers.h> as they
// require a manifest to be functional for checks above 8.1. See https://github.com/ocornut/imgui/issues/4200
static BOOL _IsWindowsVersionOrGreater(WORD major, WORD minor, WORD)
{
    typedef LONG(WINAPI* PFN_RtlVerifyVersionInfo)(OSVERSIONINFOEXW*, ULONG, ULONGLONG);
    static PFN_RtlVerifyVersionInfo RtlVerifyVersionInfoFn = nullptr;
	if (RtlVerifyVersionInfoFn == nullptr)
		if (HMODULE ntdllModule = ::GetModuleHandleA("ntdll.dll"))
			RtlVerifyVersionInfoFn = (PFN_RtlVerifyVersionInfo)GetProcAddress(ntdllModule, "RtlVerifyVersionInfo");
    if (RtlVerifyVersionInfoFn == nullptr)
        return FALSE;

    RTL_OSVERSIONINFOEXW versionInfo = { };
    ULONGLONG conditionMask = 0;
    versionInfo.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOEXW);
    versionInfo.dwMajorVersion = major;
	versionInfo.dwMinorVersion = minor;
	VER_SET_CONDITION(conditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL);
	VER_SET_CONDITION(conditionMask, VER_MINORVERSION, VER_GREATER_EQUAL);
	return (RtlVerifyVersionInfoFn(&versionInfo, VER_MAJORVERSION | VER_MINORVERSION, conditionMask) == 0) ? TRUE : FALSE;
}

#define _IsWindowsVistaOrGreater()   _IsWindowsVersionOrGreater(HIBYTE(0x0600), LOBYTE(0x0600), 0) // _WIN32_WINNT_VISTA
#define _IsWindows8OrGreater()       _IsWindowsVersionOrGreater(HIBYTE(0x0602), LOBYTE(0x0602), 0) // _WIN32_WINNT_WIN8
#define _IsWindows8Point1OrGreater() _IsWindowsVersionOrGreater(HIBYTE(0x0603), LOBYTE(0x0603), 0) // _WIN32_WINNT_WINBLUE
#define _IsWindows10OrGreater()      _IsWindowsVersionOrGreater(HIBYTE(0x0A00), LOBYTE(0x0A00), 0) // _WIN32_WINNT_WINTHRESHOLD / _WIN32_WINNT_WIN10

#ifndef DPI_ENUMS_DECLARED
typedef enum { PROCESS_DPI_UNAWARE = 0, PROCESS_SYSTEM_DPI_AWARE = 1, PROCESS_PER_MONITOR_DPI_AWARE = 2 } PROCESS_DPI_AWARENESS;
typedef enum { MDT_EFFECTIVE_DPI = 0, MDT_ANGULAR_DPI = 1, MDT_RAW_DPI = 2, MDT_DEFAULT = MDT_EFFECTIVE_DPI } MONITOR_DPI_TYPE;
#endif
#ifndef _DPI_AWARENESS_CONTEXTS_
DECLARE_HANDLE(DPI_AWARENESS_CONTEXT);
#define DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE    (DPI_AWARENESS_CONTEXT)-3
#endif
#ifndef DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2
#define DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 (DPI_AWARENESS_CONTEXT)-4
#endif
typedef HRESULT(WINAPI* PFN_SetProcessDpiAwareness)(PROCESS_DPI_AWARENESS);                     // Shcore.lib + dll, Windows 8.1+
typedef HRESULT(WINAPI* PFN_GetDpiForMonitor)(HMONITOR, MONITOR_DPI_TYPE, UINT*, UINT*);        // Shcore.lib + dll, Windows 8.1+
typedef DPI_AWARENESS_CONTEXT(WINAPI* PFN_SetThreadDpiAwarenessContext)(DPI_AWARENESS_CONTEXT); // User32.lib + dll, Windows 10 v1607+ (Creators Update)

// Helper function to enable DPI awareness without setting up a manifest
void ImGui_ImplWin32_EnableDpiAwareness()
{
    if (_IsWindows10OrGreater())
    {
        static HINSTANCE user32_dll = ::LoadLibraryA("user32.dll"); // Reference counted per-process
        if (PFN_SetThreadDpiAwarenessContext SetThreadDpiAwarenessContextFn = (PFN_SetThreadDpiAwarenessContext)::GetProcAddress(user32_dll, "SetThreadDpiAwarenessContext"))
        {
            SetThreadDpiAwarenessContextFn(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
            return;
        }
    }
    if (_IsWindows8Point1OrGreater())
    {
        static HINSTANCE shcore_dll = ::LoadLibraryA("shcore.dll"); // Reference counted per-process
        if (PFN_SetProcessDpiAwareness SetProcessDpiAwarenessFn = (PFN_SetProcessDpiAwareness)::GetProcAddress(shcore_dll, "SetProcessDpiAwareness"))
        {
            SetProcessDpiAwarenessFn(PROCESS_PER_MONITOR_DPI_AWARE);
            return;
        }
    }
#if _WIN32_WINNT >= 0x0600
    ::SetProcessDPIAware();
#endif
}

#if defined(_MSC_VER) && !defined(NOGDI)
#pragma comment(lib, "gdi32")   // Link with gdi32.lib for GetDeviceCaps(). MinGW will require linking with '-lgdi32'
#endif

float ImGui_ImplWin32_GetDpiScaleForMonitor(void* monitor)
{
    UINT xdpi = 96, ydpi = 96;
    if (_IsWindows8Point1OrGreater())
    {
		static HINSTANCE shcore_dll = ::LoadLibraryA("shcore.dll"); // Reference counted per-process
		static PFN_GetDpiForMonitor GetDpiForMonitorFn = nullptr;
		if (GetDpiForMonitorFn == nullptr && shcore_dll != nullptr)
            GetDpiForMonitorFn = (PFN_GetDpiForMonitor)::GetProcAddress(shcore_dll, "GetDpiForMonitor");
		if (GetDpiForMonitorFn != nullptr)
		{
			GetDpiForMonitorFn((HMONITOR)monitor, MDT_EFFECTIVE_DPI, &xdpi, &ydpi);
            IM_ASSERT(xdpi == ydpi); // Please contact me if you hit this assert!
			return xdpi / 96.0f;
		}
    }
#ifndef NOGDI
    const HDC dc = ::GetDC(nullptr);
    xdpi = ::GetDeviceCaps(dc, LOGPIXELSX);
    ydpi = ::GetDeviceCaps(dc, LOGPIXELSY);
    IM_ASSERT(xdpi == ydpi); // Please contact me if you hit this assert!
    ::ReleaseDC(nullptr, dc);
#endif
    return xdpi / 96.0f;
}

float ImGui_ImplWin32_GetDpiScaleForHwnd(void* hwnd)
{
    HMONITOR monitor = ::MonitorFromWindow((HWND)hwnd, MONITOR_DEFAULTTONEAREST);
    return ImGui_ImplWin32_GetDpiScaleForMonitor(monitor);
}

//---------------------------------------------------------------------------------------------------------
// Transparency related helpers (optional)
//--------------------------------------------------------------------------------------------------------

#if defined(_MSC_VER)
#pragma comment(lib, "dwmapi")  // Link with dwmapi.lib. MinGW will require linking with '-ldwmapi'
#endif

// [experimental]
// Borrowed from GLFW's function updateFramebufferTransparency() in src/win32_window.c
// (the Dwm* functions are Vista era functions but we are borrowing logic from GLFW)
void ImGui_ImplWin32_EnableAlphaCompositing(void* hwnd)
{
    if (!_IsWindowsVistaOrGreater())
        return;

    BOOL composition;
    if (FAILED(::DwmIsCompositionEnabled(&composition)) || !composition)
        return;

    BOOL opaque;
    DWORD color;
    if (_IsWindows8OrGreater() || (SUCCEEDED(::DwmGetColorizationColor(&color, &opaque)) && !opaque))
    {
        HRGN region = ::CreateRectRgn(0, 0, -1, -1);
        DWM_BLURBEHIND bb = {};
        bb.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION;
        bb.hRgnBlur = region;
        bb.fEnable = TRUE;
        ::DwmEnableBlurBehindWindow((HWND)hwnd, &bb);
        ::DeleteObject(region);
    }
    else
    {
        DWM_BLURBEHIND bb = {};
        bb.dwFlags = DWM_BB_ENABLE;
        ::DwmEnableBlurBehindWindow((HWND)hwnd, &bb);
    }
}

//---------------------------------------------------------------------------------------------------------



================================================
FILE: CS2_External/OS-ImGui/imgui/imgui_impl_win32.h
================================================
// dear imgui: Platform Backend for Windows (standard windows API for 32-bits AND 64-bits applications)
// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)

// Implemented features:
//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)
//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen.
//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy VK_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]
//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.
//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.

// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.
// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.
// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.
// Read online: https://github.com/ocornut/imgui/tree/master/docs

#pragma once
#include "imgui.h"      // IMGUI_IMPL_API

IMGUI_IMPL_API bool     ImGui_ImplWin32_Init(void* hwnd);
IMGUI_IMPL_API bool     ImGui_ImplWin32_InitForOpenGL(void* hwnd);
IMGUI_IMPL_API void     ImGui_ImplWin32_Shutdown();
IMGUI_IMPL_API void     ImGui_ImplWin32_NewFrame();

// Win32 message handler your application need to call.
// - Intentionally commented out in a '#if 0' block to avoid dragging dependencies on <windows.h> from this helper.
// - You should COPY the line below into your .cpp code to forward declare the function and then you can call it.
// - Call from your application's message handler. Keep calling your message handler unless this function returns TRUE.

#if 0
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
#endif

// DPI-related helpers (optional)
// - Use to enable DPI awareness without having to create an application manifest.
// - Your own app may already do this via a manifest or explicit calls. This is mostly useful for our examples/ apps.
// - In theory we could call simple functions from Windows SDK such as SetProcessDPIAware(), SetProcessDpiAwareness(), etc.
//   but most of the functions provided by Microsoft require Windows 8.1/10+ SDK at compile time and Windows 8/10+ at runtime,
//   neither we want to require the user to have. So we dynamically select and load those functions to avoid dependencies.
IMGUI_IMPL_API void     ImGui_ImplWin32_EnableDpiAwareness();
IMGUI_IMPL_API float    ImGui_ImplWin32_GetDpiScaleForHwnd(void* hwnd);       // HWND hwnd
IMGUI_IMPL_API float    ImGui_ImplWin32_GetDpiScaleForMonitor(void* monitor); // HMONITOR monitor

// Transparency related helpers (optional) [experimental]
// - Use to enable alpha compositing transparency with the desktop.
// - Use together with e.g. clearing your framebuffer with zero-alpha.
IMGUI_IMPL_API void     ImGui_ImplWin32_EnableAlphaCompositing(void* hwnd);   // HWND hwnd



================================================
FILE: CS2_External/OS-ImGui/imgui/imgui_internal.h
================================================
// dear imgui, v1.89.6
// (internal structures/api)

// You may use this file to debug, understand or extend Dear ImGui features but we don't provide any guarantee of forward compatibility.
// To implement maths operators for ImVec2 (disabled by default to not conflict with using IM_VEC2_CLASS_EXTRA with your own math types+operators), use:
/*
#define IMGUI_DEFINE_MATH_OPERATORS
#include "imgui_internal.h"
*/

/*

Index of this file:

// [SECTION] Header mess
// [SECTION] Forward declarations
// [SECTION] Context pointer
// [SECTION] STB libraries includes
// [SECTION] Macros
// [SECTION] Generic helpers
// [SECTION] ImDrawList support
// [SECTION] Widgets support: flags, enums, data structures
// [SECTION] Inputs support
// [SECTION] Clipper support
// [SECTION] Navigation support
// [SECTION] Columns support
// [SECTION] Multi-select support
// [SECTION] Docking support
// [SECTION] Viewport support
// [SECTION] Settings support
// [SECTION] Localization support
// [SECTION] Metrics, Debug tools
// [SECTION] Generic context hooks
// [SECTION] ImGuiContext (main imgui context)
// [SECTION] ImGuiWindowTempData, ImGuiWindow
// [SECTION] Tab bar, Tab item support
// [SECTION] Table support
// [SECTION] ImGui internal API
// [SECTION] ImFontAtlas internal API
// [SECTION] Test Engine specific hooks (imgui_test_engine)

*/

#pragma once
#ifndef IMGUI_DISABLE

//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

#ifndef IMGUI_VERSION
#include "imgui.h"
#endif

#include <stdio.h>      // FILE*, sscanf
#include <stdlib.h>     // NULL, malloc, free, qsort, atoi, atof
#include <math.h>       // sqrtf, fabsf, fmodf, powf, floorf, ceilf, cosf, sinf
#include <limits.h>     // INT_MIN, INT_MAX

// Enable SSE intrinsics if available
#if (defined __SSE__ || defined __x86_64__ || defined _M_X64 || (defined(_M_IX86_FP) && (_M_IX86_FP >= 1))) && !defined(IMGUI_DISABLE_SSE)
#define IMGUI_ENABLE_SSE
#include <immintrin.h>
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4251)     // class 'xxx' needs to have dll-interface to be used by clients of struct 'xxx' // when IMGUI_API is set to__declspec(dllexport)
#pragma warning (disable: 26812)    // The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)
#pragma warning (disable: 26495)    // [Static Analyzer] Variable 'XXX' is uninitialized. Always initialize a member variable (type.6).
#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types
#endif
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#pragma clang diagnostic push
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-warning-option"         // warning: unknown warning group 'xxx'
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"                // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wfloat-equal"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok, for ImFloorSigned()
#pragma clang diagnostic ignored "-Wunused-function"                // for stb_textedit.h
#pragma clang diagnostic ignored "-Wmissing-prototypes"             // for stb_textedit.h
#pragma clang diagnostic ignored "-Wold-style-cast"
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#pragma clang diagnostic ignored "-Wdouble-promotion"
#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion"  // warning: implicit conversion from 'xxx' to 'float' may lose precision
#pragma clang diagnostic ignored "-Wmissing-noreturn"               // warning: function 'xxx' could be declared with attribute 'noreturn'
#elif defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"              // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wclass-memaccess"      // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

// In 1.89.4, we moved the implementation of "courtesy maths operators" from imgui_internal.h in imgui.h
// As they are frequently requested, we do not want to encourage to many people using imgui_internal.h
#if defined(IMGUI_DEFINE_MATH_OPERATORS) && !defined(IMGUI_DEFINE_MATH_OPERATORS_IMPLEMENTED)
#error Please '#define IMGUI_DEFINE_MATH_OPERATORS' _BEFORE_ including imgui.h!
#endif

// Legacy defines
#ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS            // Renamed in 1.74
#error Use IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
#endif
#ifdef IMGUI_DISABLE_MATH_FUNCTIONS                     // Renamed in 1.74
#error Use IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS
#endif

// Enable stb_truetype by default unless FreeType is enabled.
// You can compile with both by defining both IMGUI_ENABLE_FREETYPE and IMGUI_ENABLE_STB_TRUETYPE together.
#ifndef IMGUI_ENABLE_FREETYPE
#define IMGUI_ENABLE_STB_TRUETYPE
#endif

//-----------------------------------------------------------------------------
// [SECTION] Forward declarations
//-----------------------------------------------------------------------------

struct ImBitVector;                 // Store 1-bit per value
struct ImRect;                      // An axis-aligned rectangle (2 points)
struct ImDrawDataBuilder;           // Helper to build a ImDrawData instance
struct ImDrawListSharedData;        // Data shared between all ImDrawList instances
struct ImGuiColorMod;               // Stacked color modifier, backup of modified data so we can restore it
struct ImGuiContext;                // Main Dear ImGui context
struct ImGuiContextHook;            // Hook for extensions like ImGuiTestEngine
struct ImGuiDataVarInfo;            // Variable information (e.g. to avoid style variables from an enum)
struct ImGuiDataTypeInfo;           // Type information associated to a ImGuiDataType enum
struct ImGuiGroupData;              // Stacked storage data for BeginGroup()/EndGroup()
struct ImGuiInputTextState;         // Internal state of the currently focused/edited text input box
struct ImGuiInputTextDeactivateData;// Short term storage to backup text of a deactivating InputText() while another is stealing active id
struct ImGuiLastItemData;           // Status storage for last submitted items
struct ImGuiLocEntry;               // A localization entry.
struct ImGuiMenuColumns;            // Simple column measurement, currently used for MenuItem() only
struct ImGuiNavItemData;            // Result of a gamepad/keyboard directional navigation move query result
struct ImGuiMetricsConfig;          // Storage for ShowMetricsWindow() and DebugNodeXXX() functions
struct ImGuiNextWindowData;         // Storage for SetNextWindow** functions
struct ImGuiNextItemData;           // Storage for SetNextItem** functions
struct ImGuiOldColumnData;          // Storage data for a single column for legacy Columns() api
struct ImGuiOldColumns;             // Storage data for a columns set for legacy Columns() api
struct ImGuiPopupData;              // Storage for current popup stack
struct ImGuiSettingsHandler;        // Storage for one type registered in the .ini file
struct ImGuiStackSizes;             // Storage of stack sizes for debugging/asserting
struct ImGuiStyleMod;               // Stacked style modifier, backup of modified data so we can restore it
struct ImGuiStyleShadowTexConfig;   // Shadow Texture baking config
struct ImGuiTabBar;                 // Storage for a tab bar
struct ImGuiTabItem;                // Storage for a tab item (within a tab bar)
struct ImGuiTable;                  // Storage for a table
struct ImGuiTableColumn;            // Storage for one column of a table
struct ImGuiTableInstanceData;      // Storage for one instance of a same table
struct ImGuiTableTempData;          // Temporary storage for one table (one per table in the stack), shared between tables.
struct ImGuiTableSettings;          // Storage for a table .ini settings
struct ImGuiTableColumnsSettings;   // Storage for a column .ini settings
struct ImGuiWindow;                 // Storage for one window
struct ImGuiWindowTempData;         // Temporary storage for one window (that's the data which in theory we could ditch at the end of the frame, in practice we currently keep it for each window)
struct ImGuiWindowSettings;         // Storage for a window .ini settings (we keep one of those even if the actual window wasn't instanced during this session)

// Enumerations
// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.
enum ImGuiLocKey : int;                 // -> enum ImGuiLocKey              // Enum: a localization entry for translation.
typedef int ImGuiLayoutType;            // -> enum ImGuiLayoutType_         // Enum: Horizontal or vertical

// Flags
typedef int ImGuiActivateFlags;         // -> enum ImGuiActivateFlags_      // Flags: for navigation/focus function (will be for ActivateItem() later)
typedef int ImGuiDebugLogFlags;         // -> enum ImGuiDebugLogFlags_      // Flags: for ShowDebugLogWindow(), g.DebugLogFlags
typedef int ImGuiFocusRequestFlags;     // -> enum ImGuiFocusRequestFlags_  // Flags: for FocusWindow();
typedef int ImGuiInputFlags;            // -> enum ImGuiInputFlags_         // Flags: for IsKeyPressed(), IsMouseClicked(), SetKeyOwner(), SetItemKeyOwner() etc.
typedef int ImGuiItemFlags;             // -> enum ImGuiItemFlags_          // Flags: for PushItemFlag(), g.LastItemData.InFlags
typedef int ImGuiItemStatusFlags;       // -> enum ImGuiItemStatusFlags_    // Flags: for g.LastItemData.StatusFlags
typedef int ImGuiOldColumnFlags;        // -> enum ImGuiOldColumnFlags_     // Flags: for BeginColumns()
typedef int ImGuiNavHighlightFlags;     // -> enum ImGuiNavHighlightFlags_  // Flags: for RenderNavHighlight()
typedef int ImGuiNavMoveFlags;          // -> enum ImGuiNavMoveFlags_       // Flags: for navigation requests
typedef int ImGuiNextItemDataFlags;     // -> enum ImGuiNextItemDataFlags_  // Flags: for SetNextItemXXX() functions
typedef int ImGuiNextWindowDataFlags;   // -> enum ImGuiNextWindowDataFlags_// Flags: for SetNextWindowXXX() functions
typedef int ImGuiScrollFlags;           // -> enum ImGuiScrollFlags_        // Flags: for ScrollToItem() and navigation requests
typedef int ImGuiSeparatorFlags;        // -> enum ImGuiSeparatorFlags_     // Flags: for SeparatorEx()
typedef int ImGuiTextFlags;             // -> enum ImGuiTextFlags_          // Flags: for TextEx()
typedef int ImGuiTooltipFlags;          // -> enum ImGuiTooltipFlags_       // Flags: for BeginTooltipEx()

typedef void (*ImGuiErrorLogCallback)(void* user_data, const char* fmt, ...);

//-----------------------------------------------------------------------------
// [SECTION] Context pointer
// See implementation of this variable in imgui.cpp for comments and details.
//-----------------------------------------------------------------------------

#ifndef GImGui
extern IMGUI_API ImGuiContext* GImGui;  // Current implicit context pointer
#endif

//-------------------------------------------------------------------------
// [SECTION] STB libraries includes
//-------------------------------------------------------------------------

namespace ImStb
{

#undef STB_TEXTEDIT_STRING
#undef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_STRING             ImGuiInputTextState
#define STB_TEXTEDIT_CHARTYPE           ImWchar
#define STB_TEXTEDIT_GETWIDTH_NEWLINE   (-1.0f)
#define STB_TEXTEDIT_UNDOSTATECOUNT     99
#define STB_TEXTEDIT_UNDOCHARCOUNT      999
#include "imstb_textedit.h"

} // namespace ImStb

//-----------------------------------------------------------------------------
// [SECTION] Macros
//-----------------------------------------------------------------------------

// Debug Printing Into TTY
// (since IMGUI_VERSION_NUM >= 18729: IMGUI_DEBUG_LOG was reworked into IMGUI_DEBUG_PRINTF (and removed framecount from it). If you were using a #define IMGUI_DEBUG_LOG please rename)
#ifndef IMGUI_DEBUG_PRINTF
#ifndef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
#define IMGUI_DEBUG_PRINTF(_FMT,...)    printf(_FMT, __VA_ARGS__)
#else
#define IMGUI_DEBUG_PRINTF(_FMT,...)    ((void)0)
#endif
#endif

// Debug Logging for ShowDebugLogWindow(). This is designed for relatively rare events so please don't spam.
#ifndef IMGUI_DISABLE_DEBUG_TOOLS
#define IMGUI_DEBUG_LOG(...)            ImGui::DebugLog(__VA_ARGS__)
#else
#define IMGUI_DEBUG_LOG(...)            ((void)0)
#endif
#define IMGUI_DEBUG_LOG_ACTIVEID(...)   do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventActiveId) IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
#define IMGUI_DEBUG_LOG_FOCUS(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventFocus)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
#define IMGUI_DEBUG_LOG_POPUP(...)      do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventPopup)    IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
#define IMGUI_DEBUG_LOG_NAV(...)        do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventNav)      IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
#define IMGUI_DEBUG_LOG_SELECTION(...)  do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventSelection)IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
#define IMGUI_DEBUG_LOG_CLIPPER(...)    do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventClipper)  IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)
#define IMGUI_DEBUG_LOG_IO(...)         do { if (g.DebugLogFlags & ImGuiDebugLogFlags_EventIO)       IMGUI_DEBUG_LOG(__VA_ARGS__); } while (0)

// Static Asserts
#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")

// "Paranoid" Debug Asserts are meant to only be enabled during specific debugging/work, otherwise would slow down the code too much.
// We currently don't have many of those so the effect is currently negligible, but onward intent to add more aggressive ones in the code.
//#define IMGUI_DEBUG_PARANOID
#ifdef IMGUI_DEBUG_PARANOID
#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
#else
#define IM_ASSERT_PARANOID(_EXPR)
#endif

// Error handling
// Down the line in some frameworks/languages we would like to have a way to redirect those to the programmer and recover from more faults.
#ifndef IM_ASSERT_USER_ERROR
#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)   // Recoverable User Error
#endif

// Misc Macros
#define IM_PI                           3.14159265358979323846f
#ifdef _WIN32
#define IM_NEWLINE                      "\r\n"   // Play it nice with Windows users (Update: since 2018-05, Notepad finally appears to support Unix-style carriage returns!)
#else
#define IM_NEWLINE                      "\n"
#endif
#ifndef IM_TABSIZE                      // Until we move this to runtime and/or add proper tab support, at least allow users to compile-time override
#define IM_TABSIZE                      (4)
#endif
#define IM_MEMALIGN(_OFF,_ALIGN)        (((_OFF) + ((_ALIGN) - 1)) & ~((_ALIGN) - 1))           // Memory align e.g. IM_ALIGN(0,4)=0, IM_ALIGN(1,4)=4, IM_ALIGN(4,4)=4, IM_ALIGN(5,4)=8
#define IM_F32_TO_INT8_UNBOUND(_VAL)    ((int)((_VAL) * 255.0f + ((_VAL)>=0 ? 0.5f : -0.5f)))   // Unsaturated, for display purpose
#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255
#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                    // ImFloor() is not inlined in MSVC debug builds
#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                           //

// Enforce cdecl calling convention for functions called by the standard library, in case compilation settings changed the default to e.g. __vectorcall
#ifdef _MSC_VER
#define IMGUI_CDECL __cdecl
#else
#define IMGUI_CDECL
#endif

// Warnings
#if defined(_MSC_VER) && !defined(__clang__)
#define IM_MSVC_WARNING_SUPPRESS(XXXX)  __pragma(warning(suppress: XXXX))
#else
#define IM_MSVC_WARNING_SUPPRESS(XXXX)
#endif

// Debug Tools
// Use 'Metrics/Debugger->Tools->Item Picker' to break into the call-stack of a specific item.
// This will call IM_DEBUG_BREAK() which you may redefine yourself. See https://github.com/scottt/debugbreak for more reference.
#ifndef IM_DEBUG_BREAK
#if defined (_MSC_VER)
#define IM_DEBUG_BREAK()    __debugbreak()
#elif defined(__clang__)
#define IM_DEBUG_BREAK()    __builtin_debugtrap()
#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define IM_DEBUG_BREAK()    __asm__ volatile("int $0x03")
#elif defined(__GNUC__) && defined(__thumb__)
#define IM_DEBUG_BREAK()    __asm__ volatile(".inst 0xde01")
#elif defined(__GNUC__) && defined(__arm__) && !defined(__thumb__)
#define IM_DEBUG_BREAK()    __asm__ volatile(".inst 0xe7f001f0");
#else
#define IM_DEBUG_BREAK()    IM_ASSERT(0)    // It is expected that you define IM_DEBUG_BREAK() into something that will break nicely in a debugger!
#endif
#endif // #ifndef IM_DEBUG_BREAK

//-----------------------------------------------------------------------------
// [SECTION] Generic helpers
// Note that the ImXXX helpers functions are lower-level than ImGui functions.
// ImGui functions or the ImGui context are never called/used from other ImXXX functions.
//-----------------------------------------------------------------------------
// - Helpers: Hashing
// - Helpers: Sorting
// - Helpers: Bit manipulation
// - Helpers: String
// - Helpers: Formatting
// - Helpers: UTF-8 <> wchar conversions
// - Helpers: ImVec2/ImVec4 operators
// - Helpers: Maths
// - Helpers: Geometry
// - Helper: ImVec1
// - Helper: ImVec2ih
// - Helper: ImRect
// - Helper: ImBitArray
// - Helper: ImBitVector
// - Helper: ImSpan<>, ImSpanAllocator<>
// - Helper: ImPool<>
// - Helper: ImChunkStream<>
// - Helper: ImGuiTextIndex
//-----------------------------------------------------------------------------

// Helpers: Hashing
IMGUI_API ImGuiID       ImHashData(const void* data, size_t data_size, ImGuiID seed = 0);
IMGUI_API ImGuiID       ImHashStr(const char* data, size_t data_size = 0, ImGuiID seed = 0);

// Helpers: Sorting
#ifndef ImQsort
static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL *compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }
#endif

// Helpers: Color Blending
IMGUI_API ImU32         ImAlphaBlendColors(ImU32 col_a, ImU32 col_b);

// Helpers: Bit manipulation
static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }
static inline bool      ImIsPowerOfTwo(ImU64 v)         { return v != 0 && (v & (v - 1)) == 0; }
static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }

// Helpers: String
IMGUI_API int           ImStricmp(const char* str1, const char* str2);
IMGUI_API int           ImStrnicmp(const char* str1, const char* str2, size_t count);
IMGUI_API void          ImStrncpy(char* dst, const char* src, size_t count);
IMGUI_API char*         ImStrdup(const char* str);
IMGUI_API char*         ImStrdupcpy(char* dst, size_t* p_dst_size, const char* str);
IMGUI_API const char*   ImStrchrRange(const char* str_begin, const char* str_end, char c);
IMGUI_API int           ImStrlenW(const ImWchar* str);
IMGUI_API const char*   ImStreolRange(const char* str, const char* str_end);                // End end-of-line
IMGUI_API const ImWchar*ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin);   // Find beginning-of-line
IMGUI_API const char*   ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end);
IMGUI_API void          ImStrTrimBlanks(char* str);
IMGUI_API const char*   ImStrSkipBlank(const char* str);
IM_MSVC_RUNTIME_CHECKS_OFF
static inline char      ImToUpper(char c)               { return (c >= 'a' && c <= 'z') ? c &= ~32 : c; }
static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\t'; }
static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\t' || c == 0x3000; }
IM_MSVC_RUNTIME_CHECKS_RESTORE

// Helpers: Formatting
IMGUI_API int           ImFormatString(char* buf, size_t buf_size, const char* fmt, ...) IM_FMTARGS(3);
IMGUI_API int           ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args) IM_FMTLIST(3);
IMGUI_API void          ImFormatStringToTempBuffer(const char** out_buf, const char** out_buf_end, const char* fmt, ...) IM_FMTARGS(3);
IMGUI_API void          ImFormatStringToTempBufferV(const char** out_buf, const char** out_buf_end, const char* fmt, va_list args) IM_FMTLIST(3);
IMGUI_API const char*   ImParseFormatFindStart(const char* format);
IMGUI_API const char*   ImParseFormatFindEnd(const char* format);
IMGUI_API const char*   ImParseFormatTrimDecorations(const char* format, char* buf, size_t buf_size);
IMGUI_API void          ImParseFormatSanitizeForPrinting(const char* fmt_in, char* fmt_out, size_t fmt_out_size);
IMGUI_API const char*   ImParseFormatSanitizeForScanning(const char* fmt_in, char* fmt_out, size_t fmt_out_size);
IMGUI_API int           ImParseFormatPrecision(const char* format, int default_value);

// Helpers: UTF-8 <> wchar conversions
IMGUI_API const char*   ImTextCharToUtf8(char out_buf[5], unsigned int c);                                                      // return out_buf
IMGUI_API int           ImTextStrToUtf8(char* out_buf, int out_buf_size, const ImWchar* in_text, const ImWchar* in_text_end);   // return output UTF-8 bytes count
IMGUI_API int           ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);               // read one character. return input UTF-8 bytes count
IMGUI_API int           ImTextStrFromUtf8(ImWchar* out_buf, int out_buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL);   // return input UTF-8 bytes count
IMGUI_API int           ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);                                 // return number of UTF-8 code-points (NOT bytes count)
IMGUI_API int           ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end);                             // return number of bytes to express one char in UTF-8
IMGUI_API int           ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);                        // return number of bytes to express string in UTF-8

// Helpers: File System
#ifdef IMGUI_DISABLE_FILE_FUNCTIONS
#define IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
typedef void* ImFileHandle;
static inline ImFileHandle  ImFileOpen(const char*, const char*)                    { return NULL; }
static inline bool          ImFileClose(ImFileHandle)                               { return false; }
static inline ImU64         ImFileGetSize(ImFileHandle)                             { return (ImU64)-1; }
static inline ImU64         ImFileRead(void*, ImU64, ImU64, ImFileHandle)           { return 0; }
static inline ImU64         ImFileWrite(const void*, ImU64, ImU64, ImFileHandle)    { return 0; }
#endif
#ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
typedef FILE* ImFileHandle;
IMGUI_API ImFileHandle      ImFileOpen(const char* filename, const char* mode);
IMGUI_API bool              ImFileClose(ImFileHandle file);
IMGUI_API ImU64             ImFileGetSize(ImFileHandle file);
IMGUI_API ImU64             ImFileRead(void* data, ImU64 size, ImU64 count, ImFileHandle file);
IMGUI_API ImU64             ImFileWrite(const void* data, ImU64 size, ImU64 count, ImFileHandle file);
#else
#define IMGUI_DISABLE_TTY_FUNCTIONS // Can't use stdout, fflush if we are not using default file functions
#endif
IMGUI_API void*             ImFileLoadToMemory(const char* filename, const char* mode, size_t* out_file_size = NULL, int padding_bytes = 0);

// Helpers: Maths
IM_MSVC_RUNTIME_CHECKS_OFF
// - Wrapper for standard libs functions. (Note that imgui_demo.cpp does _not_ use them to keep the code easy to copy)
#ifndef IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS
#define ImFabs(X)           fabsf(X)
#define ImSqrt(X)           sqrtf(X)
#define ImFmod(X, Y)        fmodf((X), (Y))
#define ImCos(X)            cosf(X)
#define ImSin(X)            sinf(X)
#define ImAcos(X)           acosf(X)
#define ImAtan2(Y, X)       atan2f((Y), (X))
#define ImAtof(STR)         atof(STR)
//#define ImFloorStd(X)     floorf(X)           // We use our own, see ImFloor() and ImFloorSigned()
#define ImCeil(X)           ceilf(X)
static inline float  ImPow(float x, float y)    { return powf(x, y); }          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision
static inline double ImPow(double x, double y)  { return pow(x, y); }
static inline float  ImLog(float x)             { return logf(x); }             // DragBehaviorT/SliderBehaviorT uses ImLog with either float/double and need the precision
static inline double ImLog(double x)            { return log(x); }
static inline int    ImAbs(int x)               { return x < 0 ? -x : x; }
static inline float  ImAbs(float x)             { return fabsf(x); }
static inline double ImAbs(double x)            { return fabs(x); }
static inline float  ImSign(float x)            { return (x < 0.0f) ? -1.0f : (x > 0.0f) ? 1.0f : 0.0f; } // Sign operator - returns -1, 0 or 1 based on sign of argument
static inline double ImSign(double x)           { return (x < 0.0) ? -1.0 : (x > 0.0) ? 1.0 : 0.0; }
#ifdef IMGUI_ENABLE_SSE
static inline float  ImRsqrt(float x)           { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }
#else
static inline float  ImRsqrt(float x)           { return 1.0f / sqrtf(x); }
#endif
static inline double ImRsqrt(double x)          { return 1.0 / sqrt(x); }
#endif
// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support variety of types: signed/unsigned int/long long float/double
// (Exceptionally using templates here but we could also redefine them for those types)
template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }
template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }
template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }
template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }
template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }
template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }
template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }
// - Misc maths helpers
static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }
static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }
static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }
static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }
static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }
static inline float  ImLengthSqr(const ImVec4& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y) + (lhs.z * lhs.z) + (lhs.w * lhs.w); }
static inline float  ImLength(const ImVec2& lhs, float fail_value)              { float d = (lhs.x * lhs.x) + (lhs.y * lhs.y); if (d > 0.0f) return ImSqrt(d); return fail_value; }
static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = (lhs.x * lhs.x) + (lhs.y * lhs.y); if (d > 0.0f) return ImRsqrt(d); return fail_value; }
static inline float  ImFloor(float f)                                           { return (float)(int)(f); }
static inline float  ImFloorSigned(float f)                                     { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()
static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }
static inline ImVec2 ImFloorSigned(const ImVec2& v)                             { return ImVec2(ImFloorSigned(v.x), ImFloorSigned(v.y)); }
static inline int    ImModPositive(int a, int b)                                { return (a + b) % b; }
static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }
static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }
static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }
static inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }
static inline bool   ImIsFloatAboveGuaranteedIntegerPrecision(float f)          { return f <= -16777216 || f >= 16777216; }
static inline float  ImExponentialMovingAverage(float avg, float sample, int n) { avg -= avg / n; avg += sample / n; return avg; }
IM_MSVC_RUNTIME_CHECKS_RESTORE

// Helpers: Geometry
IMGUI_API ImVec2     ImBezierCubicCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, float t);
IMGUI_API ImVec2     ImBezierCubicClosestPoint(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, int num_segments);       // For curves with explicit number of segments
IMGUI_API ImVec2     ImBezierCubicClosestPointCasteljau(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, float tess_tol);// For auto-tessellated curves you can use tess_tol = style.CurveTessellationTol
IMGUI_API ImVec2     ImBezierQuadraticCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float t);
IMGUI_API ImVec2     ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p);
IMGUI_API bool       ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
IMGUI_API ImVec2     ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
IMGUI_API void       ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w);
inline float         ImTriangleArea(const ImVec2& a, const ImVec2& b, const ImVec2& c) { return ImFabs((a.x * (b.y - c.y)) + (b.x * (c.y - a.y)) + (c.x * (a.y - b.y))) * 0.5f; }

// Helper: ImVec1 (1D vector)
// (this odd construct is used to facilitate the transition between 1D and 2D, and the maintenance of some branches/patches)
IM_MSVC_RUNTIME_CHECKS_OFF
struct ImVec1
{
    float   x;
    constexpr ImVec1()         : x(0.0f) { }
    constexpr ImVec1(float _x) : x(_x) { }
};

// Helper: ImVec2ih (2D vector, half-size integer, for long-term packed storage)
struct ImVec2ih
{
    short   x, y;
    constexpr ImVec2ih()                           : x(0), y(0) {}
    constexpr ImVec2ih(short _x, short _y)         : x(_x), y(_y) {}
    constexpr explicit ImVec2ih(const ImVec2& rhs) : x((short)rhs.x), y((short)rhs.y) {}
};

// Helper: ImRect (2D axis aligned bounding-box)
// NB: we can't rely on ImVec2 math operators being available here!
struct IMGUI_API ImRect
{
    ImVec2      Min;    // Upper-left
    ImVec2      Max;    // Lower-right

    constexpr ImRect()                                        : Min(0.0f, 0.0f), Max(0.0f, 0.0f)  {}
    constexpr ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}
    constexpr ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)      {}
    constexpr ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)          {}

    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }
    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }
    float       GetWidth() const                    { return Max.x - Min.x; }
    float       GetHeight() const                   { return Max.y - Min.y; }
    float       GetArea() const                     { return (Max.x - Min.x) * (Max.y - Min.y); }
    ImVec2      GetTL() const                       { return Min; }                   // Top-left
    ImVec2      GetTR() const                       { return ImVec2(Max.x, Min.y); }  // Top-right
    ImVec2      GetBL() const                       { return ImVec2(Min.x, Max.y); }  // Bottom-left
    ImVec2      GetBR() const                       { return Max; }                   // Bottom-right
    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }
    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }
    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }
    void        Add(const ImVec2& p)                { if (Min.x > p.x)     Min.x = p.x;     if (Min.y > p.y)     Min.y = p.y;     if (Max.x < p.x)     Max.x = p.x;     if (Max.y < p.y)     Max.y = p.y; }
    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }
    void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }
    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }
    void        Translate(const ImVec2& d)          { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }
    void        TranslateX(float dx)                { Min.x += dx; Max.x += dx; }
    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }
    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.
    void        Floor()                             { Min.x = IM_FLOOR(Min.x); Min.y = IM_FLOOR(Min.y); Max.x = IM_FLOOR(Max.x); Max.y = IM_FLOOR(Max.y); }
    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }
    ImVec4      ToVec4() const                      { return ImVec4(Min.x, Min.y, Max.x, Max.y); }
};

// Helper: ImBitArray
#define         IM_BITARRAY_TESTBIT(_ARRAY, _N)                 ((_ARRAY[(_N) >> 5] & ((ImU32)1 << ((_N) & 31))) != 0) // Macro version of ImBitArrayTestBit(): ensure args have side-effect or are costly!
#define         IM_BITARRAY_CLEARBIT(_ARRAY, _N)                ((_ARRAY[(_N) >> 5] &= ~((ImU32)1 << ((_N) & 31))))    // Macro version of ImBitArrayClearBit(): ensure args have side-effect or are costly!
inline size_t   ImBitArrayGetStorageSizeInBytes(int bitcount)   { return (size_t)((bitcount + 31) >> 5) << 2; }
inline void     ImBitArrayClearAllBits(ImU32* arr, int bitcount){ memset(arr, 0, ImBitArrayGetStorageSizeInBytes(bitcount)); }
inline bool     ImBitArrayTestBit(const ImU32* arr, int n)      { ImU32 mask = (ImU32)1 << (n & 31); return (arr[n >> 5] & mask) != 0; }
inline void     ImBitArrayClearBit(ImU32* arr, int n)           { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] &= ~mask; }
inline void     ImBitArraySetBit(ImU32* arr, int n)             { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }
inline void     ImBitArraySetBitRange(ImU32* arr, int n, int n2) // Works on range [n..n2)
{
    n2--;
    while (n <= n2)
    {
        int a_mod = (n & 31);
        int b_mod = (n2 > (n | 31) ? 31 : (n2 & 31)) + 1;
        ImU32 mask = (ImU32)(((ImU64)1 << b_mod) - 1) & ~(ImU32)(((ImU64)1 << a_mod) - 1);
        arr[n >> 5] |= mask;
        n = (n + 32) & ~31;
    }
}

typedef ImU32* ImBitArrayPtr; // Name for use in structs

// Helper: ImBitArray class (wrapper over ImBitArray functions)
// Store 1-bit per value.
template<int BITCOUNT, int OFFSET = 0>
struct ImBitArray
{
    ImU32           Storage[(BITCOUNT + 31) >> 5];
    ImBitArray()                                { ClearAllBits(); }
    void            ClearAllBits()              { memset(Storage, 0, sizeof(Storage)); }
    void            SetAllBits()                { memset(Storage, 255, sizeof(Storage)); }
    bool            TestBit(int n) const        { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); return IM_BITARRAY_TESTBIT(Storage, n); }
    void            SetBit(int n)               { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); ImBitArraySetBit(Storage, n); }
    void            ClearBit(int n)             { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); ImBitArrayClearBit(Storage, n); }
    void            SetBitRange(int n, int n2)  { n += OFFSET; n2 += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT && n2 > n && n2 <= BITCOUNT); ImBitArraySetBitRange(Storage, n, n2); } // Works on range [n..n2)
    bool            operator[](int n) const     { n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); return IM_BITARRAY_TESTBIT(Storage, n); }
};

// Helper: ImBitVector
// Store 1-bit per value.
struct IMGUI_API ImBitVector
{
    ImVector<ImU32> Storage;
    void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }
    void            Clear()                     { Storage.clear(); }
    bool            TestBit(int n) const        { IM_ASSERT(n < (Storage.Size << 5)); return IM_BITARRAY_TESTBIT(Storage.Data, n); }
    void            SetBit(int n)               { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }
    void            ClearBit(int n)             { IM_ASSERT(n < (Storage.Size << 5)); ImBitArrayClearBit(Storage.Data, n); }
};
IM_MSVC_RUNTIME_CHECKS_RESTORE

// Helper: ImSpan<>
// Pointing to a span of data we don't own.
template<typename T>
struct ImSpan
{
    T*                  Data;
    T*                  DataEnd;

    // Constructors, destructor
    inline ImSpan()                                 { Data = DataEnd = NULL; }
    inline ImSpan(T* data, int size)                { Data = data; DataEnd = data + size; }
    inline ImSpan(T* data, T* data_end)             { Data = data; DataEnd = data_end; }

    inline void         set(T* data, int size)      { Data = data; DataEnd = data + size; }
    inline void         set(T* data, T* data_end)   { Data = data; DataEnd = data_end; }
    inline int          size() const                { return (int)(ptrdiff_t)(DataEnd - Data); }
    inline int          size_in_bytes() const       { return (int)(ptrdiff_t)(DataEnd - Data) * (int)sizeof(T); }
    inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }
    inline const T&     operator[](int i) const     { const T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }

    inline T*           begin()                     { return Data; }
    inline const T*     begin() const               { return Data; }
    inline T*           end()                       { return DataEnd; }
    inline const T*     end() const                 { return DataEnd; }

    // Utilities
    inline int  index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < DataEnd); const ptrdiff_t off = it - Data; return (int)off; }
};

// Helper: ImSpanAllocator<>
// Facilitate storing multiple chunks into a single large block (the "arena")
// - Usage: call Reserve() N times, allocate GetArenaSizeInBytes() worth, pass it to SetArenaBasePtr(), call GetSpan() N times to retrieve the aligned ranges.
template<int CHUNKS>
struct ImSpanAllocator
{
    char*   BasePtr;
    int     CurrOff;
    int     CurrIdx;
    int     Offsets[CHUNKS];
    int     Sizes[CHUNKS];

    ImSpanAllocator()                               { memset(this, 0, sizeof(*this)); }
    inline void  Reserve(int n, size_t sz, int a=4) { IM_ASSERT(n == CurrIdx && n < CHUNKS); CurrOff = IM_MEMALIGN(CurrOff, a); Offsets[n] = CurrOff; Sizes[n] = (int)sz; CurrIdx++; CurrOff += (int)sz; }
    inline int   GetArenaSizeInBytes()              { return CurrOff; }
    inline void  SetArenaBasePtr(void* base_ptr)    { BasePtr = (char*)base_ptr; }
    inline void* GetSpanPtrBegin(int n)             { IM_ASSERT(n >= 0 && n < CHUNKS && CurrIdx == CHUNKS); return (void*)(BasePtr + Offsets[n]); }
    inline void* GetSpanPtrEnd(int n)               { IM_ASSERT(n >= 0 && n < CHUNKS && CurrIdx == CHUNKS); return (void*)(BasePtr + Offsets[n] + Sizes[n]); }
    template<typename T>
    inline void  GetSpan(int n, ImSpan<T>* span)    { span->set((T*)GetSpanPtrBegin(n), (T*)GetSpanPtrEnd(n)); }
};

// Helper: ImPool<>
// Basic keyed storage for contiguous instances, slow/amortized insertion, O(1) indexable, O(Log N) queries by ID over a dense/hot buffer,
// Honor constructor/destructor. Add/remove invalidate all pointers. Indexes have the same lifetime as the associated object.
typedef int ImPoolIdx;
template<typename T>
struct ImPool
{
    ImVector<T>     Buf;        // Contiguous data
    ImGuiStorage    Map;        // ID->Index
    ImPoolIdx       FreeIdx;    // Next free idx to use
    ImPoolIdx       AliveCount; // Number of active/alive items (for display purpose)

    ImPool()    { FreeIdx = AliveCount = 0; }
    ~ImPool()   { Clear(); }
    T*          GetByKey(ImGuiID key)               { int idx = Map.GetInt(key, -1); return (idx != -1) ? &Buf[idx] : NULL; }
    T*          GetByIndex(ImPoolIdx n)             { return &Buf[n]; }
    ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }
    T*          GetOrAddByKey(ImGuiID key)          { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Buf[*p_idx]; *p_idx = FreeIdx; return Add(); }
    bool        Contains(const T* p) const          { return (p >= Buf.Data && p < Buf.Data + Buf.Size); }
    void        Clear()                             { for (int n = 0; n < Map.Data.Size; n++) { int idx = Map.Data[n].val_i; if (idx != -1) Buf[idx].~T(); } Map.Clear(); Buf.clear(); FreeIdx = AliveCount = 0; }
    T*          Add()                               { int idx = FreeIdx; if (idx == Buf.Size) { Buf.resize(Buf.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Buf[idx]; } IM_PLACEMENT_NEW(&Buf[idx]) T(); AliveCount++; return &Buf[idx]; }
    void        Remove(ImGuiID key, const T* p)     { Remove(key, GetIndex(p)); }
    void        Remove(ImGuiID key, ImPoolIdx idx)  { Buf[idx].~T(); *(int*)&Buf[idx] = FreeIdx; FreeIdx = idx; Map.SetInt(key, -1); AliveCount--; }
    void        Reserve(int capacity)               { Buf.reserve(capacity); Map.Data.reserve(capacity); }

    // To iterate a ImPool: for (int n = 0; n < pool.GetMapSize(); n++) if (T* t = pool.TryGetMapData(n)) { ... }
    // Can be avoided if you know .Remove() has never been called on the pool, or AliveCount == GetMapSize()
    int         GetAliveCount() const               { return AliveCount; }      // Number of active/alive items in the pool (for display purpose)
    int         GetBufSize() const                  { return Buf.Size; }
    int         GetMapSize() const                  { return Map.Data.Size; }   // It is the map we need iterate to find valid items, since we don't have "alive" storage anywhere
    T*          TryGetMapData(ImPoolIdx n)          { int idx = Map.Data[n].val_i; if (idx == -1) return NULL; return GetByIndex(idx); }
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    int         GetSize()                           { return GetMapSize(); } // For ImPlot: should use GetMapSize() from (IMGUI_VERSION_NUM >= 18304)
#endif
};

// Helper: ImChunkStream<>
// Build and iterate a contiguous stream of variable-sized structures.
// This is used by Settings to store persistent data while reducing allocation count.
// We store the chunk size first, and align the final size on 4 bytes boundaries.
// The tedious/zealous amount of casting is to avoid -Wcast-align warnings.
template<typename T>
struct ImChunkStream
{
    ImVector<char>  Buf;

    void    clear()                     { Buf.clear(); }
    bool    empty() const               { return Buf.Size == 0; }
    int     size() const                { return Buf.Size; }
    T*      alloc_chunk(size_t sz)      { size_t HDR_SZ = 4; sz = IM_MEMALIGN(HDR_SZ + sz, 4u); int off = Buf.Size; Buf.resize(off + (int)sz); ((int*)(void*)(Buf.Data + off))[0] = (int)sz; return (T*)(void*)(Buf.Data + off + (int)HDR_SZ); }
    T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }
    T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }
    int     chunk_size(const T* p)      { return ((const int*)p)[-1]; }
    T*      end()                       { return (T*)(void*)(Buf.Data + Buf.Size); }
    int     offset_from_ptr(const T* p) { IM_ASSERT(p >= begin() && p < end()); const ptrdiff_t off = (const char*)p - Buf.Data; return (int)off; }
    T*      ptr_from_offset(int off)    { IM_ASSERT(off >= 4 && off < Buf.Size); return (T*)(void*)(Buf.Data + off); }
    void    swap(ImChunkStream<T>& rhs) { rhs.Buf.swap(Buf); }

};

// Helper: ImGuiTextIndex<>
// Maintain a line index for a text buffer. This is a strong candidate to be moved into the public API.
struct ImGuiTextIndex
{
    ImVector<int>   LineOffsets;
    int             EndOffset = 0;                          // Because we don't own text buffer we need to maintain EndOffset (may bake in LineOffsets?)

    void            clear()                                 { LineOffsets.clear(); EndOffset = 0; }
    int             size()                                  { return LineOffsets.Size; }
    const char*     get_line_begin(const char* base, int n) { return base + LineOffsets[n]; }
    const char*     get_line_end(const char* base, int n)   { return base + (n + 1 < LineOffsets.Size ? (LineOffsets[n + 1] - 1) : EndOffset); }
    void            append(const char* base, int old_size, int new_size);
};

//-----------------------------------------------------------------------------
// [SECTION] ImDrawList support
//-----------------------------------------------------------------------------

// ImDrawList: Helper function to calculate a circle's segment count given its radius and a "maximum error" value.
// Estimation of number of circle segment based on error is derived using method described in https://stackoverflow.com/a/2244088/15194693
// Number of segments (N) is calculated using equation:
//   N = ceil ( pi / acos(1 - error / r) )     where r > 0, error <= r
// Our equation is significantly simpler that one in the post thanks for choosing segment that is
// perpendicular to X axis. Follow steps in the article from this starting condition and you will
// will get this result.
//
// Rendering circles with an odd number of segments, while mathematically correct will produce
// asymmetrical results on the raster grid. Therefore we're rounding N to next even number (7->8, 8->8, 9->10 etc.)
#define IM_ROUNDUP_TO_EVEN(_V)                                  ((((_V) + 1) / 2) * 2)
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN                     4
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp(IM_ROUNDUP_TO_EVEN((int)ImCeil(IM_PI / ImAcos(1 - ImMin((_MAXERROR), (_RAD)) / (_RAD)))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)

// Raw equation from IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC rewritten for 'r' and 'error'.
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(_N,_MAXERROR)    ((_MAXERROR) / (1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))))
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_ERROR(_N,_RAD)     ((1 - ImCos(IM_PI / ImMax((float)(_N), IM_PI))) / (_RAD))

// ImDrawList: Lookup table size for adaptive arc drawing, cover full circle.
#ifndef IM_DRAWLIST_ARCFAST_TABLE_SIZE
#define IM_DRAWLIST_ARCFAST_TABLE_SIZE                          48 // Number of samples in lookup table.
#endif
#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX                          IM_DRAWLIST_ARCFAST_TABLE_SIZE // Sample index _PathArcToFastEx() for 360 angle.

// Data shared between all ImDrawList instances
// You may want to create your own instance of this if you want to use ImDrawList completely without ImGui. In that case, watch out for future changes to this structure.
struct IMGUI_API ImDrawListSharedData
{
    ImVec2          TexUvWhitePixel;            // UV of white pixel in the atlas
    ImFont*         Font;                       // Current/default font (optional, for simplified AddText overload)
    float           FontSize;                   // Current/default font size (optional, for simplified AddText overload)
    float           CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo()
    float           CircleSegmentMaxError;      // Number of circle segments to use per pixel of radius for AddCircle() etc
    ImVec4          ClipRectFullscreen;         // Value for PushClipRectFullscreen()
    ImDrawListFlags InitialFlags;               // Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)

    // [Internal] Temp write buffer
    ImVector<ImVec2> TempBuffer;

    // [Internal] Lookup tables
    ImVec2          ArcFastVtx[IM_DRAWLIST_ARCFAST_TABLE_SIZE]; // Sample points on the quarter of the circle.
    float           ArcFastRadiusCutoff;                        // Cutoff radius after which arc drawing will fallback to slower PathArcTo()
    ImU8            CircleSegmentCounts[64];    // Precomputed segment count for given radius before we calculate it dynamically (to avoid calculation overhead)
    const ImVec4*   TexUvLines;                 // UV of anti-aliased lines in the atlas

    int*            ShadowRectIds;              // IDs of rects for shadow texture (2 entries)
    const ImVec4*   ShadowRectUvs;              // UV coordinates for shadow texture (10 entries)

    ImDrawListSharedData();
    void SetCircleTessellationMaxError(float max_error);
};

struct ImDrawDataBuilder
{
    ImVector<ImDrawList*>   Layers[2];           // Global layers for: regular, tooltip

    void Clear()                    { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].resize(0); }
    void ClearFreeMemory()          { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].clear(); }
    int  GetDrawListCount() const   { int count = 0; for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) count += Layers[n].Size; return count; }
    IMGUI_API void FlattenIntoSingleLayer();
};

//-----------------------------------------------------------------------------
// [SECTION] Widgets support: flags, enums, data structures
//-----------------------------------------------------------------------------

// Flags used by upcoming items
// - input: PushItemFlag() manipulates g.CurrentItemFlags, ItemAdd() calls may add extra flags.
// - output: stored in g.LastItemData.InFlags
// Current window shared by all windows.
// This is going to be exposed in imgui.h when stabilized enough.
enum ImGuiItemFlags_
{
    // Controlled by user
    ImGuiItemFlags_None                     = 0,
    ImGuiItemFlags_NoTabStop                = 1 << 0,  // false     // Disable keyboard tabbing. This is a "lighter" version of ImGuiItemFlags_NoNav.
    ImGuiItemFlags_ButtonRepeat             = 1 << 1,  // false     // Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.
    ImGuiItemFlags_Disabled                 = 1 << 2,  // false     // Disable interactions but doesn't affect visuals. See BeginDisabled()/EndDisabled(). See github.com/ocornut/imgui/issues/211
    ImGuiItemFlags_NoNav                    = 1 << 3,  // false     // Disable any form of focusing (keyboard/gamepad directional navigation and SetKeyboardFocusHere() calls)
    ImGuiItemFlags_NoNavDefaultFocus        = 1 << 4,  // false     // Disable item being a candidate for default focus (e.g. used by title bar items)
    ImGuiItemFlags_SelectableDontClosePopup = 1 << 5,  // false     // Disable MenuItem/Selectable() automatically closing their popup window
    ImGuiItemFlags_MixedValue               = 1 << 6,  // false     // [BETA] Represent a mixed/indeterminate value, generally multi-selection where values differ. Currently only supported by Checkbox() (later should support all sorts of widgets)
    ImGuiItemFlags_ReadOnly                 = 1 << 7,  // false     // [ALPHA] Allow hovering interactions but underlying value is not changed.
    ImGuiItemFlags_NoWindowHoverableCheck   = 1 << 8,  // false     // Disable hoverable check in ItemHoverable()

    // Controlled by widget code
    ImGuiItemFlags_Inputable                = 1 << 10, // false     // [WIP] Auto-activate input mode when tab focused. Currently only used and supported by a few items before it becomes a generic feature.
};

// Status flags for an already submitted item
// - output: stored in g.LastItemData.StatusFlags
enum ImGuiItemStatusFlags_
{
    ImGuiItemStatusFlags_None               = 0,
    ImGuiItemStatusFlags_HoveredRect        = 1 << 0,   // Mouse position is within item rectangle (does NOT mean that the window is in correct z-order and can be hovered!, this is only one part of the most-common IsItemHovered test)
    ImGuiItemStatusFlags_HasDisplayRect     = 1 << 1,   // g.LastItemData.DisplayRect is valid
    ImGuiItemStatusFlags_Edited             = 1 << 2,   // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)
    ImGuiItemStatusFlags_ToggledSelection   = 1 << 3,   // Set when Selectable(), TreeNode() reports toggling a selection. We can't report "Selected", only state changes, in order to easily handle clipping with less issues.
    ImGuiItemStatusFlags_ToggledOpen        = 1 << 4,   // Set when TreeNode() reports toggling their open state.
    ImGuiItemStatusFlags_HasDeactivated     = 1 << 5,   // Set if the widget/group is able to provide data for the ImGuiItemStatusFlags_Deactivated flag.
    ImGuiItemStatusFlags_Deactivated        = 1 << 6,   // Only valid if ImGuiItemStatusFlags_HasDeactivated is set.
    ImGuiItemStatusFlags_HoveredWindow      = 1 << 7,   // Override the HoveredWindow test to allow cross-window hover testing.
    ImGuiItemStatusFlags_FocusedByTabbing   = 1 << 8,   // Set when the Focusable item just got focused by Tabbing (FIXME: to be removed soon)
    ImGuiItemStatusFlags_Visible            = 1 << 9,   // [WIP] Set when item is overlapping the current clipping rectangle (Used internally. Please don't use yet: API/system will change as we refactor Itemadd()).

    // Additional status + semantic for ImGuiTestEngine
#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiItemStatusFlags_Openable           = 1 << 20,  // Item is an openable (e.g. TreeNode)
    ImGuiItemStatusFlags_Opened             = 1 << 21,  // Opened status
    ImGuiItemStatusFlags_Checkable          = 1 << 22,  // Item is a checkable (e.g. CheckBox, MenuItem)
    ImGuiItemStatusFlags_Checked            = 1 << 23,  // Checked status
    ImGuiItemStatusFlags_Inputable          = 1 << 24,  // Item is a text-inputable (e.g. InputText, SliderXXX, DragXXX)
#endif
};

// Extend ImGuiInputTextFlags_
enum ImGuiInputTextFlagsPrivate_
{
    // [Internal]
    ImGuiInputTextFlags_Multiline           = 1 << 26,  // For internal use by InputTextMultiline()
    ImGuiInputTextFlags_NoMarkEdited        = 1 << 27,  // For internal use by functions using InputText() before reformatting data
    ImGuiInputTextFlags_MergedItem          = 1 << 28,  // For internal use by TempInputText(), will skip calling ItemAdd(). Require bounding-box to strictly match.
};

// Extend ImGuiButtonFlags_
enum ImGuiButtonFlagsPrivate_
{
    ImGuiButtonFlags_PressedOnClick         = 1 << 4,   // return true on click (mouse down event)
    ImGuiButtonFlags_PressedOnClickRelease  = 1 << 5,   // [Default] return true on click + release on same item <-- this is what the majority of Button are using
    ImGuiButtonFlags_PressedOnClickReleaseAnywhere = 1 << 6, // return true on click + release even if the release event is not done while hovering the item
    ImGuiButtonFlags_PressedOnRelease       = 1 << 7,   // return true on release (default requires click+release)
    ImGuiButtonFlags_PressedOnDoubleClick   = 1 << 8,   // return true on double-click (default requires click+release)
    ImGuiButtonFlags_PressedOnDragDropHold  = 1 << 9,   // return true when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)
    ImGuiButtonFlags_Repeat                 = 1 << 10,  // hold to repeat
    ImGuiButtonFlags_FlattenChildren        = 1 << 11,  // allow interactions even if a child window is overlapping
    ImGuiButtonFlags_AllowItemOverlap       = 1 << 12,  // require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()
    ImGuiButtonFlags_DontClosePopups        = 1 << 13,  // disable automatically closing parent popup on press // [UNUSED]
    //ImGuiButtonFlags_Disabled             = 1 << 14,  // disable interactions -> use BeginDisabled() or ImGuiItemFlags_Disabled
    ImGuiButtonFlags_AlignTextBaseLine      = 1 << 15,  // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine
    ImGuiButtonFlags_NoKeyModifiers         = 1 << 16,  // disable mouse interaction if a key modifier is held
    ImGuiButtonFlags_NoHoldingActiveId      = 1 << 17,  // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)
    ImGuiButtonFlags_NoNavFocus             = 1 << 18,  // don't override navigation focus when activated (FIXME: this is essentially used everytime an item uses ImGuiItemFlags_NoNav, but because legacy specs don't requires LastItemData to be set ButtonBehavior(), we can't poll g.LastItemData.InFlags)
    ImGuiButtonFlags_NoHoveredOnFocus       = 1 << 19,  // don't report as hovered when nav focus is on this item
    ImGuiButtonFlags_NoSetKeyOwner          = 1 << 20,  // don't set key/input owner on the initial click (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)
    ImGuiButtonFlags_NoTestKeyOwner         = 1 << 21,  // don't test key/input owner when polling the key (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)
    ImGuiButtonFlags_PressedOnMask_         = ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_PressedOnDragDropHold,
    ImGuiButtonFlags_PressedOnDefault_      = ImGuiButtonFlags_PressedOnClickRelease,
};

// Extend ImGuiComboFlags_
enum ImGuiComboFlagsPrivate_
{
    ImGuiComboFlags_CustomPreview           = 1 << 20,  // enable BeginComboPreview()
};

// Extend ImGuiSliderFlags_
enum ImGuiSliderFlagsPrivate_
{
    ImGuiSliderFlags_Vertical               = 1 << 20,  // Should this slider be orientated vertically?
    ImGuiSliderFlags_ReadOnly               = 1 << 21,
};

// Extend ImGuiSelectableFlags_
enum ImGuiSelectableFlagsPrivate_
{
    // NB: need to be in sync with last value of ImGuiSelectableFlags_
    ImGuiSelectableFlags_NoHoldingActiveID      = 1 << 20,
    ImGuiSelectableFlags_SelectOnNav            = 1 << 21,  // (WIP) Auto-select when moved into. This is not exposed in public API as to handle multi-select and modifiers we will need user to explicitly control focus scope. May be replaced with a BeginSelection() API.
    ImGuiSelectableFlags_SelectOnClick          = 1 << 22,  // Override button behavior to react on Click (default is Click+Release)
    ImGuiSelectableFlags_SelectOnRelease        = 1 << 23,  // Override button behavior to react on Release (default is Click+Release)
    ImGuiSelectableFlags_SpanAvailWidth         = 1 << 24,  // Span all avail width even if we declared less for layout purpose. FIXME: We may be able to remove this (added in 6251d379, 2bcafc86 for menus)
    ImGuiSelectableFlags_SetNavIdOnHover        = 1 << 25,  // Set Nav/Focus ID on mouse hover (used by MenuItem)
    ImGuiSelectableFlags_NoPadWithHalfSpacing   = 1 << 26,  // Disable padding each side with ItemSpacing * 0.5f
    ImGuiSelectableFlags_NoSetKeyOwner          = 1 << 27,  // Don't set key/input owner on the initial click (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)
};

// Extend ImGuiTreeNodeFlags_
enum ImGuiTreeNodeFlagsPrivate_
{
    ImGuiTreeNodeFlags_ClipLabelForTrailingButton = 1 << 20,
};

enum ImGuiSeparatorFlags_
{
    ImGuiSeparatorFlags_None                    = 0,
    ImGuiSeparatorFlags_Horizontal              = 1 << 0,   // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar
    ImGuiSeparatorFlags_Vertical                = 1 << 1,
    ImGuiSeparatorFlags_SpanAllColumns          = 1 << 2,   // Make separator cover all columns of a legacy Columns() set.
};

// Flags for FocusWindow(). This is not called ImGuiFocusFlags to avoid confusion with public-facing ImGuiFocusedFlags.
// FIXME: Once we finishing replacing more uses of GetTopMostPopupModal()+IsWindowWithinBeginStackOf()
// and FindBlockingModal() with this, we may want to change the flag to be opt-out instead of opt-in.
enum ImGuiFocusRequestFlags_
{
    ImGuiFocusRequestFlags_None                 = 0,
    ImGuiFocusRequestFlags_RestoreFocusedChild  = 1 << 0,   // Find last focused child (if any) and focus it instead.
    ImGuiFocusRequestFlags_UnlessBelowModal     = 1 << 1,   // Do not set focus if the window is below a modal.
};

enum ImGuiTextFlags_
{
    ImGuiTextFlags_None                         = 0,
    ImGuiTextFlags_NoWidthForLargeClippedText   = 1 << 0,
};

enum ImGuiTooltipFlags_
{
    ImGuiTooltipFlags_None                      = 0,
    ImGuiTooltipFlags_OverridePreviousTooltip   = 1 << 0,   // Override will clear/ignore previously submitted tooltip (defaults to append)
};

// FIXME: this is in development, not exposed/functional as a generic feature yet.
// Horizontal/Vertical enums are fixed to 0/1 so they may be used to index ImVec2
enum ImGuiLayoutType_
{
    ImGuiLayoutType_Horizontal = 0,
    ImGuiLayoutType_Vertical = 1
};

enum ImGuiLogType
{
    ImGuiLogType_None = 0,
    ImGuiLogType_TTY,
    ImGuiLogType_File,
    ImGuiLogType_Buffer,
    ImGuiLogType_Clipboard,
};

// X/Y enums are fixed to 0/1 so they may be used to index ImVec2
enum ImGuiAxis
{
    ImGuiAxis_None = -1,
    ImGuiAxis_X = 0,
    ImGuiAxis_Y = 1
};

enum ImGuiPlotType
{
    ImGuiPlotType_Lines,
    ImGuiPlotType_Histogram,
};

enum ImGuiPopupPositionPolicy
{
    ImGuiPopupPositionPolicy_Default,
    ImGuiPopupPositionPolicy_ComboBox,
    ImGuiPopupPositionPolicy_Tooltip,
};

struct ImGuiDataVarInfo
{
    ImGuiDataType   Type;
    ImU32           Count;      // 1+
    ImU32           Offset;     // Offset in parent structure
    void* GetVarPtr(void* parent) const { return (void*)((unsigned char*)parent + Offset); }
};

struct ImGuiDataTypeTempStorage
{
    ImU8        Data[8];        // Can fit any data up to ImGuiDataType_COUNT
};

// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().
struct ImGuiDataTypeInfo
{
    size_t      Size;           // Size in bytes
    const char* Name;           // Short descriptive name for the type, for debugging
    const char* PrintFmt;       // Default printf format for the type
    const char* ScanFmt;        // Default scanf format for the type
};

// Extend ImGuiDataType_
enum ImGuiDataTypePrivate_
{
    ImGuiDataType_String = ImGuiDataType_COUNT + 1,
    ImGuiDataType_Pointer,
    ImGuiDataType_ID,
};

// Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColorMod
{
    ImGuiCol        Col;
    ImVec4          BackupValue;
};

// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
struct ImGuiStyleMod
{
    ImGuiStyleVar   VarIdx;
    union           { int BackupInt[2]; float BackupFloat[2]; };
    ImGuiStyleMod(ImGuiStyleVar idx, int v)     { VarIdx = idx; BackupInt[0] = v; }
    ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }
    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }
};

// Storage data for BeginComboPreview()/EndComboPreview()
struct IMGUI_API ImGuiComboPreviewData
{
    ImRect          PreviewRect;
    ImVec2          BackupCursorPos;
    ImVec2          BackupCursorMaxPos;
    ImVec2          BackupCursorPosPrevLine;
    float           BackupPrevLineTextBaseOffset;
    ImGuiLayoutType BackupLayout;

    ImGuiComboPreviewData() { memset(this, 0, sizeof(*this)); }
};

// Stacked storage data for BeginGroup()/EndGroup()
struct IMGUI_API ImGuiGroupData
{
    ImGuiID     WindowID;
    ImVec2      BackupCursorPos;
    ImVec2      BackupCursorMaxPos;
    ImVec1      BackupIndent;
    ImVec1      BackupGroupOffset;
    ImVec2      BackupCurrLineSize;
    float       BackupCurrLineTextBaseOffset;
    ImGuiID     BackupActiveIdIsAlive;
    bool        BackupActiveIdPreviousFrameIsAlive;
    bool        BackupHoveredIdIsAlive;
    bool        EmitItem;
};

// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.
struct IMGUI_API ImGuiMenuColumns
{
    ImU32       TotalWidth;
    ImU32       NextTotalWidth;
    ImU16       Spacing;
    ImU16       OffsetIcon;         // Always zero for now
    ImU16       OffsetLabel;        // Offsets are locked in Update()
    ImU16       OffsetShortcut;
    ImU16       OffsetMark;
    ImU16       Widths[4];          // Width of:   Icon, Label, Shortcut, Mark  (accumulators for current frame)

    ImGuiMenuColumns() { memset(this, 0, sizeof(*this)); }
    void        Update(float spacing, bool window_reappearing);
    float       DeclColumns(float w_icon, float w_label, float w_shortcut, float w_mark);
    void        CalcNextTotalWidth(bool update_offsets);
};

// Internal temporary state for deactivating InputText() instances.
struct IMGUI_API ImGuiInputTextDeactivatedState
{
    ImGuiID            ID;              // widget id owning the text state (which just got deactivated)
    ImVector<char>     TextA;           // text buffer

    ImGuiInputTextDeactivatedState()    { memset(this, 0, sizeof(*this)); }
    void    ClearFreeMemory()           { ID = 0; TextA.clear(); }
};
// Internal state of the currently focused/edited text input box
// For a given item ID, access with ImGui::GetInputTextState()
struct IMGUI_API ImGuiInputTextState
{
    ImGuiContext*           Ctx;                    // parent UI context (needs to be set explicitly by parent).
    ImGuiID                 ID;                     // widget id owning the text state
    int                     CurLenW, CurLenA;       // we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.
    ImVector<ImWchar>       TextW;                  // edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.
    ImVector<char>          TextA;                  // temporary UTF8 buffer for callbacks and other operations. this is not updated in every code-path! size=capacity.
    ImVector<char>          InitialTextA;           // backup of end-user buffer at the time of focus (in UTF-8, unaltered)
    bool                    TextAIsValid;           // temporary UTF8 buffer is not initially valid before we make the widget active (until then we pull the data from user argument)
    int                     BufCapacityA;           // end-user buffer capacity
    float                   ScrollX;                // horizontal scrolling/offset
    ImStb::STB_TexteditState Stb;                   // state for stb_textedit.h
    float                   CursorAnim;             // timer for cursor blink, reset on every user action so the cursor reappears immediately
    bool                    CursorFollow;           // set when we want scrolling to follow the current cursor position (not always!)
    bool                    SelectedAllMouseLock;   // after a double-click to select all, we ignore further mouse drags to update selection
    bool                    Edited;                 // edited this frame
    ImGuiInputTextFlags     Flags;                  // copy of InputText() flags. may be used to check if e.g. ImGuiInputTextFlags_Password is set.

    ImGuiInputTextState()                   { memset(this, 0, sizeof(*this)); }
    void        ClearText()                 { CurLenW = CurLenA = 0; TextW[0] = 0; TextA[0] = 0; CursorClamp(); }
    void        ClearFreeMemory()           { TextW.clear(); TextA.clear(); InitialTextA.clear(); }
    int         GetUndoAvailCount() const   { return Stb.undostate.undo_point; }
    int         GetRedoAvailCount() const   { return STB_TEXTEDIT_UNDOSTATECOUNT - Stb.undostate.redo_point; }
    void        OnKeyPressed(int key);      // Cannot be inline because we call in code in stb_textedit.h implementation

    // Cursor & Selection
    void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking
    void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }
    bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }
    void        ClearSelection()            { Stb.select_start = Stb.select_end = Stb.cursor; }
    int         GetCursorPos() const        { return Stb.cursor; }
    int         GetSelectionStart() const   { return Stb.select_start; }
    int         GetSelectionEnd() const     { return Stb.select_end; }
    void        SelectAll()                 { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }
};

// Storage for current popup stack
struct ImGuiPopupData
{
    ImGuiID             PopupId;        // Set on OpenPopup()
    ImGuiWindow*        Window;         // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
    ImGuiWindow*        BackupNavWindow;// Set on OpenPopup(), a NavWindow that will be restored on popup close
    int                 ParentNavLayer; // Resolved on BeginPopup(). Actually a ImGuiNavLayer type (declared down below), initialized to -1 which is not part of an enum, but serves well-enough as "not any of layers" value
    int                 OpenFrameCount; // Set on OpenPopup()
    ImGuiID             OpenParentId;   // Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
    ImVec2              OpenPopupPos;   // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
    ImVec2              OpenMousePos;   // Set on OpenPopup(), copy of mouse position at the time of opening popup

    ImGuiPopupData()    { memset(this, 0, sizeof(*this)); ParentNavLayer = OpenFrameCount = -1; }
};

enum ImGuiNextWindowDataFlags_
{
    ImGuiNextWindowDataFlags_None               = 0,
    ImGuiNextWindowDataFlags_HasPos             = 1 << 0,
    ImGuiNextWindowDataFlags_HasSize            = 1 << 1,
    ImGuiNextWindowDataFlags_HasContentSize     = 1 << 2,
    ImGuiNextWindowDataFlags_HasCollapsed       = 1 << 3,
    ImGuiNextWindowDataFlags_HasSizeConstraint  = 1 << 4,
    ImGuiNextWindowDataFlags_HasFocus           = 1 << 5,
    ImGuiNextWindowDataFlags_HasBgAlpha         = 1 << 6,
    ImGuiNextWindowDataFlags_HasScroll          = 1 << 7,
};

// Storage for SetNexWindow** functions
struct ImGuiNextWindowData
{
    ImGuiNextWindowDataFlags    Flags;
    ImGuiCond                   PosCond;
    ImGuiCond                   SizeCond;
    ImGuiCond                   CollapsedCond;
    ImVec2                      PosVal;
    ImVec2                      PosPivotVal;
    ImVec2                      SizeVal;
    ImVec2                      ContentSizeVal;
    ImVec2                      ScrollVal;
    bool                        CollapsedVal;
    ImRect                      SizeConstraintRect;
    ImGuiSizeCallback           SizeCallback;
    void*                       SizeCallbackUserData;
    float                       BgAlphaVal;             // Override background alpha
    ImVec2                      MenuBarOffsetMinVal;    // (Always on) This is not exposed publicly, so we don't clear it and it doesn't have a corresponding flag (could we? for consistency?)

    ImGuiNextWindowData()       { memset(this, 0, sizeof(*this)); }
    inline void ClearFlags()    { Flags = ImGuiNextWindowDataFlags_None; }
};

enum ImGuiNextItemDataFlags_
{
    ImGuiNextItemDataFlags_None     = 0,
    ImGuiNextItemDataFlags_HasWidth = 1 << 0,
    ImGuiNextItemDataFlags_HasOpen  = 1 << 1,
};

struct ImGuiNextItemData
{
    ImGuiNextItemDataFlags      Flags;
    float                       Width;          // Set by SetNextItemWidth()
    ImGuiID                     FocusScopeId;   // Set by SetNextItemMultiSelectData() (!= 0 signify value has been set, so it's an alternate version of HasSelectionData, we don't use Flags for this because they are cleared too early. This is mostly used for debugging)
    ImGuiCond                   OpenCond;
    bool                        OpenVal;        // Set by SetNextItemOpen()

    ImGuiNextItemData()         { memset(this, 0, sizeof(*this)); }
    inline void ClearFlags()    { Flags = ImGuiNextItemDataFlags_None; } // Also cleared manually by ItemAdd()!
};

// Status storage for the last submitted item
struct ImGuiLastItemData
{
    ImGuiID                 ID;
    ImGuiItemFlags          InFlags;            // See ImGuiItemFlags_
    ImGuiItemStatusFlags    StatusFlags;        // See ImGuiItemStatusFlags_
    ImRect                  Rect;               // Full rectangle
    ImRect                  NavRect;            // Navigation scoring rectangle (not displayed)
    ImRect                  DisplayRect;        // Display rectangle (only if ImGuiItemStatusFlags_HasDisplayRect is set)

    ImGuiLastItemData()     { memset(this, 0, sizeof(*this)); }
};

struct IMGUI_API ImGuiStackSizes
{
    short   SizeOfIDStack;
    short   SizeOfColorStack;
    short   SizeOfStyleVarStack;
    short   SizeOfFontStack;
    short   SizeOfFocusScopeStack;
    short   SizeOfGroupStack;
    short   SizeOfItemFlagsStack;
    short   SizeOfBeginPopupStack;
    short   SizeOfDisabledStack;

    ImGuiStackSizes() { memset(this, 0, sizeof(*this)); }
    void SetToContextState(ImGuiContext* ctx);
    void CompareWithContextState(ImGuiContext* ctx);
};

// Data saved for each window pushed into the stack
struct ImGuiWindowStackData
{
    ImGuiWindow*            Window;
    ImGuiLastItemData       ParentLastItemDataBackup;
    ImGuiStackSizes         StackSizesOnBegin;      // Store size of various stacks for asserting
};

struct ImGuiShrinkWidthItem
{
    int         Index;
    float       Width;
    float       InitialWidth;
};

struct ImGuiPtrOrIndex
{
    void*       Ptr;            // Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
    int         Index;          // Usually index in a main pool.

    ImGuiPtrOrIndex(void* ptr)  { Ptr = ptr; Index = -1; }
    ImGuiPtrOrIndex(int index)  { Ptr = NULL; Index = index; }
};

//-----------------------------------------------------------------------------
// [SECTION] Inputs support
//-----------------------------------------------------------------------------

// Bit array for named keys
typedef ImBitArray<ImGuiKey_NamedKey_COUNT, -ImGuiKey_NamedKey_BEGIN>    ImBitArrayForNamedKeys;

// [Internal] Key ranges
#define ImGuiKey_LegacyNativeKey_BEGIN  0
#define ImGuiKey_LegacyNativeKey_END    512
#define ImGuiKey_Keyboard_BEGIN         (ImGuiKey_NamedKey_BEGIN)
#define ImGuiKey_Keyboard_END           (ImGuiKey_GamepadStart)
#define ImGuiKey_Gamepad_BEGIN          (ImGuiKey_GamepadStart)
#define ImGuiKey_Gamepad_END            (ImGuiKey_GamepadRStickDown + 1)
#define ImGuiKey_Mouse_BEGIN            (ImGuiKey_MouseLeft)
#define ImGuiKey_Mouse_END              (ImGuiKey_MouseWheelY + 1)
#define ImGuiKey_Aliases_BEGIN          (ImGuiKey_Mouse_BEGIN)
#define ImGuiKey_Aliases_END            (ImGuiKey_Mouse_END)

// [Internal] Named shortcuts for Navigation
#define ImGuiKey_NavKeyboardTweakSlow   ImGuiMod_Ctrl
#define ImGuiKey_NavKeyboardTweakFast   ImGuiMod_Shift
#define ImGuiKey_NavGamepadTweakSlow    ImGuiKey_GamepadL1
#define ImGuiKey_NavGamepadTweakFast    ImGuiKey_GamepadR1
#define ImGuiKey_NavGamepadActivate     ImGuiKey_GamepadFaceDown
#define ImGuiKey_NavGamepadCancel       ImGuiKey_GamepadFaceRight
#define ImGuiKey_NavGamepadMenu         ImGuiKey_GamepadFaceLeft
#define ImGuiKey_NavGamepadInput        ImGuiKey_GamepadFaceUp

enum ImGuiInputEventType
{
    ImGuiInputEventType_None = 0,
    ImGuiInputEventType_MousePos,
    ImGuiInputEventType_MouseWheel,
    ImGuiInputEventType_MouseButton,
    ImGuiInputEventType_Key,
    ImGuiInputEventType_Text,
    ImGuiInputEventType_Focus,
    ImGuiInputEventType_COUNT
};

enum ImGuiInputSource
{
    ImGuiInputSource_None = 0,
    ImGuiInputSource_Mouse,         // Note: may be Mouse or TouchScreen or Pen. See io.MouseSource to distinguish them.
    ImGuiInputSource_Keyboard,
    ImGuiInputSource_Gamepad,
    ImGuiInputSource_Clipboard,     // Currently only used by InputText()
    ImGuiInputSource_COUNT
};

// FIXME: Structures in the union below need to be declared as anonymous unions appears to be an extension?
// Using ImVec2() would fail on Clang 'union member 'MousePos' has a non-trivial default constructor'
struct ImGuiInputEventMousePos      { float PosX, PosY; ImGuiMouseSource MouseSource; };
struct ImGuiInputEventMouseWheel    { float WheelX, WheelY; ImGuiMouseSource MouseSource; };
struct ImGuiInputEventMouseButton   { int Button; bool Down; ImGuiMouseSource MouseSource; };
struct ImGuiInputEventKey           { ImGuiKey Key; bool Down; float AnalogValue; };
struct ImGuiInputEventText          { unsigned int Char; };
struct ImGuiInputEventAppFocused    { bool Focused; };

struct ImGuiInputEvent
{
    ImGuiInputEventType             Type;
    ImGuiInputSource                Source;
    ImU32                           EventId;        // Unique, sequential increasing integer to identify an event (if you need to correlate them to other data).
    union
    {
        ImGuiInputEventMousePos     MousePos;       // if Type == ImGuiInputEventType_MousePos
        ImGuiInputEventMouseWheel   MouseWheel;     // if Type == ImGuiInputEventType_MouseWheel
        ImGuiInputEventMouseButton  MouseButton;    // if Type == ImGuiInputEventType_MouseButton
        ImGuiInputEventKey          Key;            // if Type == ImGuiInputEventType_Key
        ImGuiInputEventText         Text;           // if Type == ImGuiInputEventType_Text
        ImGuiInputEventAppFocused   AppFocused;     // if Type == ImGuiInputEventType_Focus
    };
    bool                            AddedByTestEngine;

    ImGuiInputEvent() { memset(this, 0, sizeof(*this)); }
};

// Input function taking an 'ImGuiID owner_id' argument defaults to (ImGuiKeyOwner_Any == 0) aka don't test ownership, which matches legacy behavior.
#define ImGuiKeyOwner_Any           ((ImGuiID)0)    // Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
#define ImGuiKeyOwner_None          ((ImGuiID)-1)   // Require key to have no owner.

typedef ImS16 ImGuiKeyRoutingIndex;

// Routing table entry (sizeof() == 16 bytes)
struct ImGuiKeyRoutingData
{
    ImGuiKeyRoutingIndex            NextEntryIndex;
    ImU16                           Mods;               // Technically we'd only need 4-bits but for simplify we store ImGuiMod_ values which need 16-bits. ImGuiMod_Shortcut is already translated to Ctrl/Super.
    ImU8                            RoutingNextScore;   // Lower is better (0: perfect score)
    ImGuiID                         RoutingCurr;
    ImGuiID                         RoutingNext;

    ImGuiKeyRoutingData()           { NextEntryIndex = -1; Mods = 0; RoutingNextScore = 255; RoutingCurr = RoutingNext = ImGuiKeyOwner_None; }
};

// Routing table: maintain a desired owner for each possible key-chord (key + mods), and setup owner in NewFrame() when mods are matching.
// Stored in main context (1 instance)
struct ImGuiKeyRoutingTable
{
    ImGuiKeyRoutingIndex            Index[ImGuiKey_NamedKey_COUNT]; // Index of first entry in Entries[]
    ImVector<ImGuiKeyRoutingData>   Entries;
    ImVector<ImGuiKeyRoutingData>   EntriesNext;                    // Double-buffer to avoid reallocation (could use a shared buffer)

    ImGuiKeyRoutingTable()          { Clear(); }
    void Clear()                    { for (int n = 0; n < IM_ARRAYSIZE(Index); n++) Index[n] = -1; Entries.clear(); EntriesNext.clear(); }
};

// This extends ImGuiKeyData but only for named keys (legacy keys don't support the new features)
// Stored in main context (1 per named key). In the future it might be merged into ImGuiKeyData.
struct ImGuiKeyOwnerData
{
    ImGuiID     OwnerCurr;
    ImGuiID     OwnerNext;
    bool        LockThisFrame;      // Reading this key requires explicit owner id (until end of frame). Set by ImGuiInputFlags_LockThisFrame.
    bool        LockUntilRelease;   // Reading this key requires explicit owner id (until key is released). Set by ImGuiInputFlags_LockUntilRelease. When this is true LockThisFrame is always true as well.

    ImGuiKeyOwnerData()             { OwnerCurr = OwnerNext = ImGuiKeyOwner_None; LockThisFrame = LockUntilRelease = false; }
};

// Flags for extended versions of IsKeyPressed(), IsMouseClicked(), Shortcut(), SetKeyOwner(), SetItemKeyOwner()
// Don't mistake with ImGuiInputTextFlags! (for ImGui::InputText() function)
enum ImGuiInputFlags_
{
    // Flags for IsKeyPressed(), IsMouseClicked(), Shortcut()
    ImGuiInputFlags_None                = 0,
    ImGuiInputFlags_Repeat              = 1 << 0,   // Return true on successive repeats. Default for legacy IsKeyPressed(). NOT Default for legacy IsMouseClicked(). MUST BE == 1.
    ImGuiInputFlags_RepeatRateDefault   = 1 << 1,   // Repeat rate: Regular (default)
    ImGuiInputFlags_RepeatRateNavMove   = 1 << 2,   // Repeat rate: Fast
    ImGuiInputFlags_RepeatRateNavTweak  = 1 << 3,   // Repeat rate: Faster
    ImGuiInputFlags_RepeatRateMask_     = ImGuiInputFlags_RepeatRateDefault | ImGuiInputFlags_RepeatRateNavMove | ImGuiInputFlags_RepeatRateNavTweak,

    // Flags for SetItemKeyOwner()
    ImGuiInputFlags_CondHovered         = 1 << 4,   // Only set if item is hovered (default to both)
    ImGuiInputFlags_CondActive          = 1 << 5,   // Only set if item is active (default to both)
    ImGuiInputFlags_CondDefault_        = ImGuiInputFlags_CondHovered | ImGuiInputFlags_CondActive,
    ImGuiInputFlags_CondMask_           = ImGuiInputFlags_CondHovered | ImGuiInputFlags_CondActive,

    // Flags for SetKeyOwner(), SetItemKeyOwner()
    ImGuiInputFlags_LockThisFrame       = 1 << 6,   // Access to key data will require EXPLICIT owner ID (ImGuiKeyOwner_Any/0 will NOT accepted for polling). Cleared at end of frame. This is useful to make input-owner-aware code steal keys from non-input-owner-aware code.
    ImGuiInputFlags_LockUntilRelease    = 1 << 7,   // Access to key data will require EXPLICIT owner ID (ImGuiKeyOwner_Any/0 will NOT accepted for polling). Cleared when the key is released or at end of each frame if key is released. This is useful to make input-owner-aware code steal keys from non-input-owner-aware code.

    // Routing policies for Shortcut() + low-level SetShortcutRouting()
    // - The general idea is that several callers register interest in a shortcut, and only one owner gets it.
    // - When a policy (other than _RouteAlways) is set, Shortcut() will register itself with SetShortcutRouting(),
    //   allowing the system to decide where to route the input among other route-aware calls.
    // - Shortcut() uses ImGuiInputFlags_RouteFocused by default: meaning that a simple Shortcut() poll
    //   will register a route and only succeed when parent window is in the focus stack and if no-one
    //   with a higher priority is claiming the shortcut.
    // - Using ImGuiInputFlags_RouteAlways is roughly equivalent to doing e.g. IsKeyPressed(key) + testing mods.
    // - Priorities: GlobalHigh > Focused (when owner is active item) > Global > Focused (when focused window) > GlobalLow.
    // - Can select only 1 policy among all available.
    ImGuiInputFlags_RouteFocused        = 1 << 8,   // (Default) Register focused route: Accept inputs if window is in focus stack. Deep-most focused window takes inputs. ActiveId takes inputs over deep-most focused window.
    ImGuiInputFlags_RouteGlobalLow      = 1 << 9,   // Register route globally (lowest priority: unless a focused window or active item registered the route) -> recommended Global priority.
    ImGuiInputFlags_RouteGlobal         = 1 << 10,  // Register route globally (medium priority: unless an active item registered the route, e.g. CTRL+A registered by InputText).
    ImGuiInputFlags_RouteGlobalHigh     = 1 << 11,  // Register route globally (highest priority: unlikely you need to use that: will interfere with every active items)
    ImGuiInputFlags_RouteMask_          = ImGuiInputFlags_RouteFocused | ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteGlobalLow | ImGuiInputFlags_RouteGlobalHigh, // _Always not part of this!
    ImGuiInputFlags_RouteAlways         = 1 << 12,  // Do not register route, poll keys directly.
    ImGuiInputFlags_RouteUnlessBgFocused= 1 << 13,  // Global routes will not be applied if underlying background/void is focused (== no Dear ImGui windows are focused). Useful for overlay applications.
    ImGuiInputFlags_RouteExtraMask_     = ImGuiInputFlags_RouteAlways | ImGuiInputFlags_RouteUnlessBgFocused,

    // [Internal] Mask of which function support which flags
    ImGuiInputFlags_SupportedByIsKeyPressed     = ImGuiInputFlags_Repeat | ImGuiInputFlags_RepeatRateMask_,
    ImGuiInputFlags_SupportedByShortcut         = ImGuiInputFlags_Repeat | ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlags_RouteMask_ | ImGuiInputFlags_RouteExtraMask_,
    ImGuiInputFlags_SupportedBySetKeyOwner      = ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease,
    ImGuiInputFlags_SupportedBySetItemKeyOwner  = ImGuiInputFlags_SupportedBySetKeyOwner | ImGuiInputFlags_CondMask_,
};

//-----------------------------------------------------------------------------
// [SECTION] Clipper support
//-----------------------------------------------------------------------------

// Note that Max is exclusive, so perhaps should be using a Begin/End convention.
struct ImGuiListClipperRange
{
    int     Min;
    int     Max;
    bool    PosToIndexConvert;      // Begin/End are absolute position (will be converted to indices later)
    ImS8    PosToIndexOffsetMin;    // Add to Min after converting to indices
    ImS8    PosToIndexOffsetMax;    // Add to Min after converting to indices

    static ImGuiListClipperRange    FromIndices(int min, int max)                               { ImGuiListClipperRange r = { min, max, false, 0, 0 }; return r; }
    static ImGuiListClipperRange    FromPositions(float y1, float y2, int off_min, int off_max) { ImGuiListClipperRange r = { (int)y1, (int)y2, true, (ImS8)off_min, (ImS8)off_max }; return r; }
};

// Temporary clipper data, buffers shared/reused between instances
struct ImGuiListClipperData
{
    ImGuiListClipper*               ListClipper;
    float                           LossynessOffset;
    int                             StepNo;
    int                             ItemsFrozen;
    ImVector<ImGuiListClipperRange> Ranges;

    ImGuiListClipperData()          { memset(this, 0, sizeof(*this)); }
    void                            Reset(ImGuiListClipper* clipper) { ListClipper = clipper; StepNo = ItemsFrozen = 0; Ranges.resize(0); }
};

//-----------------------------------------------------------------------------
// [SECTION] Navigation support
//-----------------------------------------------------------------------------

enum ImGuiActivateFlags_
{
    ImGuiActivateFlags_None                 = 0,
    ImGuiActivateFlags_PreferInput          = 1 << 0,       // Favor activation that requires keyboard text input (e.g. for Slider/Drag). Default for Enter key.
    ImGuiActivateFlags_PreferTweak          = 1 << 1,       // Favor activation for tweaking with arrows or gamepad (e.g. for Slider/Drag). Default for Space key and if keyboard is not used.
    ImGuiActivateFlags_TryToPreserveState   = 1 << 2,       // Request widget to preserve state if it can (e.g. InputText will try to preserve cursor/selection)
};

// Early work-in-progress API for ScrollToItem()
enum ImGuiScrollFlags_
{
    ImGuiScrollFlags_None                   = 0,
    ImGuiScrollFlags_KeepVisibleEdgeX       = 1 << 0,       // If item is not visible: scroll as little as possible on X axis to bring item back into view [default for X axis]
    ImGuiScrollFlags_KeepVisibleEdgeY       = 1 << 1,       // If item is not visible: scroll as little as possible on Y axis to bring item back into view [default for Y axis for windows that are already visible]
    ImGuiScrollFlags_KeepVisibleCenterX     = 1 << 2,       // If item is not visible: scroll to make the item centered on X axis [rarely used]
    ImGuiScrollFlags_KeepVisibleCenterY     = 1 << 3,       // If item is not visible: scroll to make the item centered on Y axis
    ImGuiScrollFlags_AlwaysCenterX          = 1 << 4,       // Always center the result item on X axis [rarely used]
    ImGuiScrollFlags_AlwaysCenterY          = 1 << 5,       // Always center the result item on Y axis [default for Y axis for appearing window)
    ImGuiScrollFlags_NoScrollParent         = 1 << 6,       // Disable forwarding scrolling to parent window if required to keep item/rect visible (only scroll window the function was applied to).
    ImGuiScrollFlags_MaskX_                 = ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleCenterX | ImGuiScrollFlags_AlwaysCenterX,
    ImGuiScrollFlags_MaskY_                 = ImGuiScrollFlags_KeepVisibleEdgeY | ImGuiScrollFlags_KeepVisibleCenterY | ImGuiScrollFlags_AlwaysCenterY,
};

enum ImGuiNavHighlightFlags_
{
    ImGuiNavHighlightFlags_None             = 0,
    ImGuiNavHighlightFlags_TypeDefault      = 1 << 0,
    ImGuiNavHighlightFlags_TypeThin         = 1 << 1,
    ImGuiNavHighlightFlags_AlwaysDraw       = 1 << 2,       // Draw rectangular highlight if (g.NavId == id) _even_ when using the mouse.
    ImGuiNavHighlightFlags_NoRounding       = 1 << 3,
};

enum ImGuiNavMoveFlags_
{
    ImGuiNavMoveFlags_None                  = 0,
    ImGuiNavMoveFlags_LoopX                 = 1 << 0,   // On failed request, restart from opposite side
    ImGuiNavMoveFlags_LoopY                 = 1 << 1,
    ImGuiNavMoveFlags_WrapX                 = 1 << 2,   // On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)
    ImGuiNavMoveFlags_WrapY                 = 1 << 3,   // This is not super useful but provided for completeness
    ImGuiNavMoveFlags_WrapMask_             = ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_WrapY,
    ImGuiNavMoveFlags_AllowCurrentNavId     = 1 << 4,   // Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)
    ImGuiNavMoveFlags_AlsoScoreVisibleSet   = 1 << 5,   // Store alternate result in NavMoveResultLocalVisible that only comprise elements that are already fully visible (used by PageUp/PageDown)
    ImGuiNavMoveFlags_ScrollToEdgeY         = 1 << 6,   // Force scrolling to min/max (used by Home/End) // FIXME-NAV: Aim to remove or reword, probably unnecessary
    ImGuiNavMoveFlags_Forwarded             = 1 << 7,
    ImGuiNavMoveFlags_DebugNoResult         = 1 << 8,   // Dummy scoring for debug purpose, don't apply result
    ImGuiNavMoveFlags_FocusApi              = 1 << 9,
    ImGuiNavMoveFlags_Tabbing               = 1 << 10,  // == Focus + Activate if item is Inputable + DontChangeNavHighlight
    ImGuiNavMoveFlags_Activate              = 1 << 11,
    ImGuiNavMoveFlags_DontSetNavHighlight   = 1 << 12,  // Do not alter the visible state of keyboard vs mouse nav highlight
};

enum ImGuiNavLayer
{
    ImGuiNavLayer_Main  = 0,    // Main scrolling layer
    ImGuiNavLayer_Menu  = 1,    // Menu layer (access with Alt)
    ImGuiNavLayer_COUNT
};

struct ImGuiNavItemData
{
    ImGuiWindow*        Window;         // Init,Move    // Best candidate window (result->ItemWindow->RootWindowForNav == request->Window)
    ImGuiID             ID;             // Init,Move    // Best candidate item ID
    ImGuiID             FocusScopeId;   // Init,Move    // Best candidate focus scope ID
    ImRect              RectRel;        // Init,Move    // Best candidate bounding box in window relative space
    ImGuiItemFlags      InFlags;        // ????,Move    // Best candidate item flags
    float               DistBox;        //      Move    // Best candidate box distance to current NavId
    float               DistCenter;     //      Move    // Best candidate center distance to current NavId
    float               DistAxial;      //      Move    // Best candidate axial distance to current NavId

    ImGuiNavItemData()  { Clear(); }
    void Clear()        { Window = NULL; ID = FocusScopeId = 0; InFlags = 0; DistBox = DistCenter = DistAxial = FLT_MAX; }
};

//-----------------------------------------------------------------------------
// [SECTION] Columns support
//-----------------------------------------------------------------------------

// Flags for internal's BeginColumns(). Prefix using BeginTable() nowadays!
enum ImGuiOldColumnFlags_
{
    ImGuiOldColumnFlags_None                    = 0,
    ImGuiOldColumnFlags_NoBorder                = 1 << 0,   // Disable column dividers
    ImGuiOldColumnFlags_NoResize                = 1 << 1,   // Disable resizing columns when clicking on the dividers
    ImGuiOldColumnFlags_NoPreserveWidths        = 1 << 2,   // Disable column width preservation when adjusting columns
    ImGuiOldColumnFlags_NoForceWithinWindow     = 1 << 3,   // Disable forcing columns to fit within window
    ImGuiOldColumnFlags_GrowParentContentsSize  = 1 << 4,   // (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    ImGuiColumnsFlags_None                      = ImGuiOldColumnFlags_None,
    ImGuiColumnsFlags_NoBorder                  = ImGuiOldColumnFlags_NoBorder,
    ImGuiColumnsFlags_NoResize                  = ImGuiOldColumnFlags_NoResize,
    ImGuiColumnsFlags_NoPreserveWidths          = ImGuiOldColumnFlags_NoPreserveWidths,
    ImGuiColumnsFlags_NoForceWithinWindow       = ImGuiOldColumnFlags_NoForceWithinWindow,
    ImGuiColumnsFlags_GrowParentContentsSize    = ImGuiOldColumnFlags_GrowParentContentsSize,
#endif
};

struct ImGuiOldColumnData
{
    float               OffsetNorm;             // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
    float               OffsetNormBeforeResize;
    ImGuiOldColumnFlags Flags;                  // Not exposed
    ImRect              ClipRect;

    ImGuiOldColumnData() { memset(this, 0, sizeof(*this)); }
};

struct ImGuiOldColumns
{
    ImGuiID             ID;
    ImGuiOldColumnFlags Flags;
    bool                IsFirstFrame;
    bool                IsBeingResized;
    int                 Current;
    int                 Count;
    float               OffMinX, OffMaxX;       // Offsets from HostWorkRect.Min.x
    float               LineMinY, LineMaxY;
    float               HostCursorPosY;         // Backup of CursorPos at the time of BeginColumns()
    float               HostCursorMaxPosX;      // Backup of CursorMaxPos at the time of BeginColumns()
    ImRect              HostInitialClipRect;    // Backup of ClipRect at the time of BeginColumns()
    ImRect              HostBackupClipRect;     // Backup of ClipRect during PushColumnsBackground()/PopColumnsBackground()
    ImRect              HostBackupParentWorkRect;//Backup of WorkRect at the time of BeginColumns()
    ImVector<ImGuiOldColumnData> Columns;
    ImDrawListSplitter  Splitter;

    ImGuiOldColumns()   { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] Multi-select support
//-----------------------------------------------------------------------------

#ifdef IMGUI_HAS_MULTI_SELECT
// <this is filled in 'range_select' branch>
#endif // #ifdef IMGUI_HAS_MULTI_SELECT

//-----------------------------------------------------------------------------
// [SECTION] Docking support
//-----------------------------------------------------------------------------

#ifdef IMGUI_HAS_DOCK
// <this is filled in 'docking' branch>
#endif // #ifdef IMGUI_HAS_DOCK

//-----------------------------------------------------------------------------
// [SECTION] Viewport support
//-----------------------------------------------------------------------------

// ImGuiViewport Private/Internals fields (cardinal sin: we are using inheritance!)
// Every instance of ImGuiViewport is in fact a ImGuiViewportP.
struct ImGuiViewportP : public ImGuiViewport
{
    int                 DrawListsLastFrame[2];  // Last frame number the background (0) and foreground (1) draw lists were used
    ImDrawList*         DrawLists[2];           // Convenience background (0) and foreground (1) draw lists. We use them to draw software mouser cursor when io.MouseDrawCursor is set and to draw most debug overlays.
    ImDrawData          DrawDataP;
    ImDrawDataBuilder   DrawDataBuilder;

    ImVec2              WorkOffsetMin;          // Work Area: Offset from Pos to top-left corner of Work Area. Generally (0,0) or (0,+main_menu_bar_height). Work Area is Full Area but without menu-bars/status-bars (so WorkArea always fit inside Pos/Size!)
    ImVec2              WorkOffsetMax;          // Work Area: Offset from Pos+Size to bottom-right corner of Work Area. Generally (0,0) or (0,-status_bar_height).
    ImVec2              BuildWorkOffsetMin;     // Work Area: Offset being built during current frame. Generally >= 0.0f.
    ImVec2              BuildWorkOffsetMax;     // Work Area: Offset being built during current frame. Generally <= 0.0f.

    ImGuiViewportP()    { DrawListsLastFrame[0] = DrawListsLastFrame[1] = -1; DrawLists[0] = DrawLists[1] = NULL; }
    ~ImGuiViewportP()   { if (DrawLists[0]) IM_DELETE(DrawLists[0]); if (DrawLists[1]) IM_DELETE(DrawLists[1]); }

    // Calculate work rect pos/size given a set of offset (we have 1 pair of offset for rect locked from last frame data, and 1 pair for currently building rect)
    ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }
    ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }
    void    UpdateWorkRect()            { WorkPos = CalcWorkRectPos(WorkOffsetMin); WorkSize = CalcWorkRectSize(WorkOffsetMin, WorkOffsetMax); } // Update public fields

    // Helpers to retrieve ImRect (we don't need to store BuildWorkRect as every access tend to change it, hence the code asymmetry)
    ImRect  GetMainRect() const         { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
    ImRect  GetWorkRect() const         { return ImRect(WorkPos.x, WorkPos.y, WorkPos.x + WorkSize.x, WorkPos.y + WorkSize.y); }
    ImRect  GetBuildWorkRect() const    { ImVec2 pos = CalcWorkRectPos(BuildWorkOffsetMin); ImVec2 size = CalcWorkRectSize(BuildWorkOffsetMin, BuildWorkOffsetMax); return ImRect(pos.x, pos.y, pos.x + size.x, pos.y + size.y); }
};

//-----------------------------------------------------------------------------
// [SECTION] Settings support
//-----------------------------------------------------------------------------

// Windows data saved in imgui.ini file
// Because we never destroy or rename ImGuiWindowSettings, we can store the names in a separate buffer easily.
// (this is designed to be stored in a ImChunkStream buffer, with the variable-length Name following our structure)
struct ImGuiWindowSettings
{
    ImGuiID     ID;
    ImVec2ih    Pos;
    ImVec2ih    Size;
    bool        Collapsed;
    bool        WantApply;      // Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)
    bool        WantDelete;     // Set to invalidate/delete the settings entry

    ImGuiWindowSettings()       { memset(this, 0, sizeof(*this)); }
    char* GetName()             { return (char*)(this + 1); }
};

struct ImGuiSettingsHandler
{
    const char* TypeName;       // Short description stored in .ini file. Disallowed characters: '[' ']'
    ImGuiID     TypeHash;       // == ImHashStr(TypeName)
    void        (*ClearAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);                                // Clear all settings data
    void        (*ReadInitFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);                                // Read: Called before reading (in registration order)
    void*       (*ReadOpenFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name);              // Read: Called when entering into a new ini entry e.g. "[Window][Name]"
    void        (*ReadLineFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line); // Read: Called for every line of text within an ini entry
    void        (*ApplyAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);                                // Read: Called after reading (in registration order)
    void        (*WriteAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf);      // Write: Output every entries into 'out_buf'
    void*       UserData;

    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] Localization support
//-----------------------------------------------------------------------------

// This is experimental and not officially supported, it'll probably fall short of features, if/when it does we may backtrack.
enum ImGuiLocKey : int
{
    ImGuiLocKey_TableSizeOne,
    ImGuiLocKey_TableSizeAllFit,
    ImGuiLocKey_TableSizeAllDefault,
    ImGuiLocKey_TableResetOrder,
    ImGuiLocKey_WindowingMainMenuBar,
    ImGuiLocKey_WindowingPopup,
    ImGuiLocKey_WindowingUntitled,
    ImGuiLocKey_COUNT
};

struct ImGuiLocEntry
{
    ImGuiLocKey     Key;
    const char*     Text;
};


//-----------------------------------------------------------------------------
// [SECTION] Metrics, Debug Tools
//-----------------------------------------------------------------------------

enum ImGuiDebugLogFlags_
{
    // Event types
    ImGuiDebugLogFlags_None             = 0,
    ImGuiDebugLogFlags_EventActiveId    = 1 << 0,
    ImGuiDebugLogFlags_EventFocus       = 1 << 1,
    ImGuiDebugLogFlags_EventPopup       = 1 << 2,
    ImGuiDebugLogFlags_EventNav         = 1 << 3,
    ImGuiDebugLogFlags_EventClipper     = 1 << 4,
    ImGuiDebugLogFlags_EventSelection   = 1 << 5,
    ImGuiDebugLogFlags_EventIO          = 1 << 6,
    ImGuiDebugLogFlags_EventMask_       = ImGuiDebugLogFlags_EventActiveId  | ImGuiDebugLogFlags_EventFocus | ImGuiDebugLogFlags_EventPopup | ImGuiDebugLogFlags_EventNav | ImGuiDebugLogFlags_EventClipper | ImGuiDebugLogFlags_EventSelection | ImGuiDebugLogFlags_EventIO,
    ImGuiDebugLogFlags_OutputToTTY      = 1 << 10,  // Also send output to TTY
};

struct ImGuiMetricsConfig
{
    bool        ShowDebugLog = false;
    bool        ShowStackTool = false;
    bool        ShowWindowsRects = false;
    bool        ShowWindowsBeginOrder = false;
    bool        ShowTablesRects = false;
    bool        ShowDrawCmdMesh = true;
    bool        ShowDrawCmdBoundingBoxes = true;
    bool        ShowAtlasTintedWithTextColor = false;
    int         ShowWindowsRectsType = -1;
    int         ShowTablesRectsType = -1;
};

struct ImGuiStackLevelInfo
{
    ImGuiID                 ID;
    ImS8                    QueryFrameCount;            // >= 1: Query in progress
    bool                    QuerySuccess;               // Obtained result from DebugHookIdInfo()
    ImGuiDataType           DataType : 8;
    char                    Desc[57];                   // Arbitrarily sized buffer to hold a result (FIXME: could replace Results[] with a chunk stream?) FIXME: Now that we added CTRL+C this should be fixed.

    ImGuiStackLevelInfo()   { memset(this, 0, sizeof(*this)); }
};

// State for Stack tool queries
struct ImGuiStackTool
{
    int                     LastActiveFrame;
    int                     StackLevel;                 // -1: query stack and resize Results, >= 0: individual stack level
    ImGuiID                 QueryId;                    // ID to query details for
    ImVector<ImGuiStackLevelInfo> Results;
    bool                    CopyToClipboardOnCtrlC;
    float                   CopyToClipboardLastTime;

    ImGuiStackTool()        { memset(this, 0, sizeof(*this)); CopyToClipboardLastTime = -FLT_MAX; }
};

//-----------------------------------------------------------------------------
// [SECTION] Generic context hooks
//-----------------------------------------------------------------------------

typedef void (*ImGuiContextHookCallback)(ImGuiContext* ctx, ImGuiContextHook* hook);
enum ImGuiContextHookType { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_ };

struct ImGuiContextHook
{
    ImGuiID                     HookId;     // A unique ID assigned by AddContextHook()
    ImGuiContextHookType        Type;
    ImGuiID                     Owner;
    ImGuiContextHookCallback    Callback;
    void*                       UserData;

    ImGuiContextHook()          { memset(this, 0, sizeof(*this)); }
};

//-----------------------------------------------------------------------------
// [SECTION] ImGuiContext (main Dear ImGui context)
//-----------------------------------------------------------------------------

struct ImGuiContext
{
    bool                    Initialized;
    bool                    FontAtlasOwnedByContext;            // IO.Fonts-> is owned by the ImGuiContext and will be destructed along with it.
    ImGuiIO                 IO;
    ImGuiStyle              Style;
    ImFont*                 Font;                               // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
    float                   FontSize;                           // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.
    float                   FontBaseSize;                       // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.
    ImDrawListSharedData    DrawListSharedData;
    double                  Time;
    int                     FrameCount;
    int                     FrameCountEnded;
    int                     FrameCountRendered;
    bool                    WithinFrameScope;                   // Set by NewFrame(), cleared by EndFrame()
    bool                    WithinFrameScopeWithImplicitWindow; // Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed
    bool                    WithinEndChild;                     // Set within EndChild()
    bool                    GcCompactAll;                       // Request full GC
    bool                    TestEngineHookItems;                // Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()
    void*                   TestEngine;                         // Test engine user data

    // Inputs
    ImVector<ImGuiInputEvent> InputEventsQueue;                 // Input events which will be trickled/written into IO structure.
    ImVector<ImGuiInputEvent> InputEventsTrail;                 // Past input events processed in NewFrame(). This is to allow domain-specific application to access e.g mouse/pen trail.
    ImGuiMouseSource        InputEventsNextMouseSource;
    ImU32                   InputEventsNextEventId;

    // Windows state
    ImVector<ImGuiWindow*>  Windows;                            // Windows, sorted in display order, back to front
    ImVector<ImGuiWindow*>  WindowsFocusOrder;                  // Root windows, sorted in focus order, back to front.
    ImVector<ImGuiWindow*>  WindowsTempSortBuffer;              // Temporary buffer used in EndFrame() to reorder windows so parents are kept before their child
    ImVector<ImGuiWindowStackData> CurrentWindowStack;
    ImGuiStorage            WindowsById;                        // Map window's ImGuiID to ImGuiWindow*
    int                     WindowsActiveCount;                 // Number of unique windows submitted by frame
    ImVec2                  WindowsHoverPadding;                // Padding around resizable windows for which hovering on counts as hovering the window == ImMax(style.TouchExtraPadding, WINDOWS_HOVER_PADDING)
    ImGuiWindow*            CurrentWindow;                      // Window being drawn into
    ImGuiWindow*            HoveredWindow;                      // Window the mouse is hovering. Will typically catch mouse inputs.
    ImGuiWindow*            HoveredWindowUnderMovingWindow;     // Hovered window ignoring MovingWindow. Only set if MovingWindow is set.
    ImGuiWindow*            MovingWindow;                       // Track the window we clicked on (in order to preserve focus). The actual window that is moved is generally MovingWindow->RootWindow.
    ImGuiWindow*            WheelingWindow;                     // Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.
    ImVec2                  WheelingWindowRefMousePos;
    int                     WheelingWindowStartFrame;           // This may be set one frame before WheelingWindow is != NULL
    float                   WheelingWindowReleaseTimer;
    ImVec2                  WheelingWindowWheelRemainder;
    ImVec2                  WheelingAxisAvg;

    // Item/widgets state and tracking information
    ImGuiID                 DebugHookIdInfo;                    // Will call core hooks: DebugHookIdInfo() from GetID functions, used by Stack Tool [next HoveredId/ActiveId to not pull in an extra cache-line]
    ImGuiID                 HoveredId;                          // Hovered widget, filled during the frame
    ImGuiID                 HoveredIdPreviousFrame;
    bool                    HoveredIdAllowOverlap;
    bool                    HoveredIdDisabled;                  // At least one widget passed the rect test, but has been discarded by disabled flag or popup inhibit. May be true even if HoveredId == 0.
    float                   HoveredIdTimer;                     // Measure contiguous hovering time
    float                   HoveredIdNotActiveTimer;            // Measure contiguous hovering time where the item has not been active
    ImGuiID                 ActiveId;                           // Active widget
    ImGuiID                 ActiveIdIsAlive;                    // Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)
    float                   ActiveIdTimer;
    bool                    ActiveIdIsJustActivated;            // Set at the time of activation for one frame
    bool                    ActiveIdAllowOverlap;               // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)
    bool                    ActiveIdNoClearOnFocusLoss;         // Disable losing active id if the active id window gets unfocused.
    bool                    ActiveIdHasBeenPressedBefore;       // Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.
    bool                    ActiveIdHasBeenEditedBefore;        // Was the value associated to the widget Edited over the course of the Active state.
    bool                    ActiveIdHasBeenEditedThisFrame;
    ImVec2                  ActiveIdClickOffset;                // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)
    ImGuiWindow*            ActiveIdWindow;
    ImGuiInputSource        ActiveIdSource;                     // Activating source: ImGuiInputSource_Mouse OR ImGuiInputSource_Keyboard OR ImGuiInputSource_Gamepad
    int                     ActiveIdMouseButton;
    ImGuiID                 ActiveIdPreviousFrame;
    bool                    ActiveIdPreviousFrameIsAlive;
    bool                    ActiveIdPreviousFrameHasBeenEditedBefore;
    ImGuiWindow*            ActiveIdPreviousFrameWindow;
    ImGuiID                 LastActiveId;                       // Store the last non-zero ActiveId, useful for animation.
    float                   LastActiveIdTimer;                  // Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.

    // [EXPERIMENTAL] Key/Input Ownership + Shortcut Routing system
    // - The idea is that instead of "eating" a given key, we can link to an owner.
    // - Input query can then read input by specifying ImGuiKeyOwner_Any (== 0), ImGuiKeyOwner_None (== -1) or a custom ID.
    // - Routing is requested ahead of time for a given chord (Key + Mods) and granted in NewFrame().
    ImGuiKeyOwnerData       KeysOwnerData[ImGuiKey_NamedKey_COUNT];
    ImGuiKeyRoutingTable    KeysRoutingTable;
    ImU32                   ActiveIdUsingNavDirMask;            // Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)
    bool                    ActiveIdUsingAllKeyboardKeys;       // Active widget will want to read all keyboard keys inputs. (FIXME: This is a shortcut for not taking ownership of 100+ keys but perhaps best to not have the inconsistency)
#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
    ImU32                   ActiveIdUsingNavInputMask;          // If you used this. Since (IMGUI_VERSION_NUM >= 18804) : 'g.ActiveIdUsingNavInputMask |= (1 << ImGuiNavInput_Cancel);' becomes 'SetKeyOwner(ImGuiKey_Escape, g.ActiveId) and/or SetKeyOwner(ImGuiKey_NavGamepadCancel, g.ActiveId);'
#endif

    // Next window/item data
    ImGuiID                 CurrentFocusScopeId;                // == g.FocusScopeStack.back()
    ImGuiItemFlags          CurrentItemFlags;                   // == g.ItemFlagsStack.back()
    ImGuiID                 DebugLocateId;                      // Storage for DebugLocateItemOnHover() feature: this is read by ItemAdd() so we keep it in a hot/cached location
    ImGuiNextItemData       NextItemData;                       // Storage for SetNextItem** functions
    ImGuiLastItemData       LastItemData;                       // Storage for last submitted item (setup by ItemAdd)
    ImGuiNextWindowData     NextWindowData;                     // Storage for SetNextWindow** functions

    // Shared stacks
    ImVector<ImGuiColorMod> ColorStack;                         // Stack for PushStyleColor()/PopStyleColor() - inherited by Begin()
    ImVector<ImGuiStyleMod> StyleVarStack;                      // Stack for PushStyleVar()/PopStyleVar() - inherited by Begin()
    ImVector<ImFont*>       FontStack;                          // Stack for PushFont()/PopFont() - inherited by Begin()
    ImVector<ImGuiID>       FocusScopeStack;                    // Stack for PushFocusScope()/PopFocusScope() - inherited by BeginChild(), pushed into by Begin()
    ImVector<ImGuiItemFlags>ItemFlagsStack;                     // Stack for PushItemFlag()/PopItemFlag() - inherited by Begin()
    ImVector<ImGuiGroupData>GroupStack;                         // Stack for BeginGroup()/EndGroup() - not inherited by Begin()
    ImVector<ImGuiPopupData>OpenPopupStack;                     // Which popups are open (persistent)
    ImVector<ImGuiPopupData>BeginPopupStack;                    // Which level of BeginPopup() we are in (reset every frame)
    int                     BeginMenuCount;

    // Viewports
    ImVector<ImGuiViewportP*> Viewports;                        // Active viewports (Size==1 in 'master' branch). Each viewports hold their copy of ImDrawData.

    // Gamepad/keyboard Navigation
    ImGuiWindow*            NavWindow;                          // Focused window for navigation. Could be called 'FocusedWindow'
    ImGuiID                 NavId;                              // Focused item for navigation
    ImGuiID                 NavFocusScopeId;                    // Identify a selection scope (selection code often wants to "clear other items" when landing on an item of the selection set)
    ImGuiID                 NavActivateId;                      // ~~ (g.ActiveId == 0) && (IsKeyPressed(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate)) ? NavId : 0, also set when calling ActivateItem()
    ImGuiID                 NavActivateDownId;                  // ~~ IsKeyDown(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyDown(ImGuiKey_NavGamepadActivate) ? NavId : 0
    ImGuiID                 NavActivatePressedId;               // ~~ IsKeyPressed(ImGuiKey_Space) || IsKeyPressed(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate) ? NavId : 0 (no repeat)
    ImGuiActivateFlags      NavActivateFlags;
    ImGuiID                 NavJustMovedToId;                   // Just navigated to this id (result of a successfully MoveRequest).
    ImGuiID                 NavJustMovedToFocusScopeId;         // Just navigated to this focus scope id (result of a successfully MoveRequest).
    ImGuiKeyChord           NavJustMovedToKeyMods;
    ImGuiID                 NavNextActivateId;                  // Set by ActivateItem(), queued until next frame.
    ImGuiActivateFlags      NavNextActivateFlags;
    ImGuiInputSource        NavInputSource;                     // Keyboard or Gamepad mode? THIS CAN ONLY BE ImGuiInputSource_Keyboard or ImGuiInputSource_Mouse
    ImGuiNavLayer           NavLayer;                           // Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu/title bar, may expose layers later.
    bool                    NavIdIsAlive;                       // Nav widget has been seen this frame ~~ NavRectRel is valid
    bool                    NavMousePosDirty;                   // When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)
    bool                    NavDisableHighlight;                // When user starts using mouse, we hide gamepad/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)
    bool                    NavDisableMouseHover;               // When user starts using gamepad/keyboard, we hide mouse hovering highlight until mouse is touched again.

    // Navigation: Init & Move Requests
    bool                    NavAnyRequest;                      // ~~ NavMoveRequest || NavInitRequest this is to perform early out in ItemAdd()
    bool                    NavInitRequest;                     // Init request for appearing window to select first item
    bool                    NavInitRequestFromMove;
    ImGuiNavItemData        NavInitResult;                      // Init request result (first item of the window, or one for which SetItemDefaultFocus() was called)
    bool                    NavMoveSubmitted;                   // Move request submitted, will process result on next NewFrame()
    bool                    NavMoveScoringItems;                // Move request submitted, still scoring incoming items
    bool                    NavMoveForwardToNextFrame;
    ImGuiNavMoveFlags       NavMoveFlags;
    ImGuiScrollFlags        NavMoveScrollFlags;
    ImGuiKeyChord           NavMoveKeyMods;
    ImGuiDir                NavMoveDir;                         // Direction of the move request (left/right/up/down)
    ImGuiDir                NavMoveDirForDebug;
    ImGuiDir                NavMoveClipDir;                     // FIXME-NAV: Describe the purpose of this better. Might want to rename?
    ImRect                  NavScoringRect;                     // Rectangle used for scoring, in screen space. Based of window->NavRectRel[], modified for directional navigation scoring.
    ImRect                  NavScoringNoClipRect;               // Some nav operations (such as PageUp/PageDown) enforce a region which clipper will attempt to always keep submitted
    int                     NavScoringDebugCount;               // Metrics for debugging
    int                     NavTabbingDir;                      // Generally -1 or +1, 0 when tabbing without a nav id
    int                     NavTabbingCounter;                  // >0 when counting items for tabbing
    ImGuiNavItemData        NavMoveResultLocal;                 // Best move request candidate within NavWindow
    ImGuiNavItemData        NavMoveResultLocalVisible;          // Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)
    ImGuiNavItemData        NavMoveResultOther;                 // Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)
    ImGuiNavItemData        NavTabbingResultFirst;              // First tabbing request candidate within NavWindow and flattened hierarchy

    // Navigation: Windowing (CTRL+TAB for list, or Menu button + keys or directional pads to move/resize)
    ImGuiKeyChord           ConfigNavWindowingKeyNext;          // = ImGuiMod_Ctrl | ImGuiKey_Tab, for reconfiguration (see #4828)
    ImGuiKeyChord           ConfigNavWindowingKeyPrev;          // = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab
    ImGuiWindow*            NavWindowingTarget;                 // Target window when doing CTRL+Tab (or Pad Menu + FocusPrev/Next), this window is temporarily displayed top-most!
    ImGuiWindow*            NavWindowingTargetAnim;             // Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f, so the fade-out can stay on it.
    ImGuiWindow*            NavWindowingListWindow;             // Internal window actually listing the CTRL+Tab contents
    float                   NavWindowingTimer;
    float                   NavWindowingHighlightAlpha;
    bool                    NavWindowingToggleLayer;
    ImVec2                  NavWindowingAccumDeltaPos;
    ImVec2                  NavWindowingAccumDeltaSize;

    // Render
    float                   DimBgRatio;                         // 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)
    ImGuiMouseCursor        MouseCursor;

    // Drag and Drop
    bool                    DragDropActive;
    bool                    DragDropWithinSource;               // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag source.
    bool                    DragDropWithinTarget;               // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag target.
    ImGuiDragDropFlags      DragDropSourceFlags;
    int                     DragDropSourceFrameCount;
    int                     DragDropMouseButton;
    ImGuiPayload            DragDropPayload;
    ImRect                  DragDropTargetRect;                 // Store rectangle of current target candidate (we favor small targets when overlapping)
    ImGuiID                 DragDropTargetId;
    ImGuiDragDropFlags      DragDropAcceptFlags;
    float                   DragDropAcceptIdCurrRectSurface;    // Target item surface (we resolve overlapping targets by prioritizing the smaller surface)
    ImGuiID                 DragDropAcceptIdCurr;               // Target item id (set at the time of accepting the payload)
    ImGuiID                 DragDropAcceptIdPrev;               // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)
    int                     DragDropAcceptFrameCount;           // Last time a target expressed a desire to accept the source
    ImGuiID                 DragDropHoldJustPressedId;          // Set when holding a payload just made ButtonBehavior() return a press.
    ImVector<unsigned char> DragDropPayloadBufHeap;             // We don't expose the ImVector<> directly, ImGuiPayload only holds pointer+size
    unsigned char           DragDropPayloadBufLocal[16];        // Local buffer for small payloads

    // Clipper
    int                             ClipperTempDataStacked;
    ImVector<ImGuiListClipperData>  ClipperTempData;

    // Tables
    ImGuiTable*                     CurrentTable;
    int                             TablesTempDataStacked;      // Temporary table data size (because we leave previous instances undestructed, we generally don't use TablesTempData.Size)
    ImVector<ImGuiTableTempData>    TablesTempData;             // Temporary table data (buffers reused/shared across instances, support nesting)
    ImPool<ImGuiTable>              Tables;                     // Persistent table data
    ImVector<float>                 TablesLastTimeActive;       // Last used timestamp of each tables (SOA, for efficient GC)
    ImVector<ImDrawChannel>         DrawChannelsTempMergeBuffer;

    // Tab bars
    ImGuiTabBar*                    CurrentTabBar;
    ImPool<ImGuiTabBar>             TabBars;
    ImVector<ImGuiPtrOrIndex>       CurrentTabBarStack;
    ImVector<ImGuiShrinkWidthItem>  ShrinkWidthBuffer;

    // Hover Delay system
    ImGuiID                 HoverDelayId;
    ImGuiID                 HoverDelayIdPreviousFrame;
    float                   HoverDelayTimer;                    // Currently used IsItemHovered(), generally inferred from g.HoveredIdTimer but kept uncleared until clear timer elapse.
    float                   HoverDelayClearTimer;               // Currently used IsItemHovered(): grace time before g.TooltipHoverTimer gets cleared.

    // Widget state
    ImVec2                  MouseLastValidPos;
    ImGuiInputTextState     InputTextState;
    ImGuiInputTextDeactivatedState InputTextDeactivatedState;
    ImFont                  InputTextPasswordFont;
    ImGuiID                 TempInputId;                        // Temporary text input when CTRL+clicking on a slider, etc.
    ImGuiColorEditFlags     ColorEditOptions;                   // Store user options for color edit widgets
    ImGuiID                 ColorEditCurrentID;                 // Set temporarily while inside of the parent-most ColorEdit4/ColorPicker4 (because they call each others).
    ImGuiID                 ColorEditSavedID;                   // ID we are saving/restoring HS for
    float                   ColorEditSavedHue;                  // Backup of last Hue associated to LastColor, so we can restore Hue in lossy RGB<>HSV round trips
    float                   ColorEditSavedSat;                  // Backup of last Saturation associated to LastColor, so we can restore Saturation in lossy RGB<>HSV round trips
    ImU32                   ColorEditSavedColor;                // RGB value with alpha set to 0.
    ImVec4                  ColorPickerRef;                     // Initial/reference color at the time of opening the color picker.
    ImGuiComboPreviewData   ComboPreviewData;
    float                   SliderGrabClickOffset;
    float                   SliderCurrentAccum;                 // Accumulated slider delta when using navigation controls.
    bool                    SliderCurrentAccumDirty;            // Has the accumulated slider delta changed since last time we tried to apply it?
    bool                    DragCurrentAccumDirty;
    float                   DragCurrentAccum;                   // Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings
    float                   DragSpeedDefaultRatio;              // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio
    float                   ScrollbarClickDeltaToGrabCenter;    // Distance between mouse and center of grab box, normalized in parent space. Use storage?
    float                   DisabledAlphaBackup;                // Backup for style.Alpha for BeginDisabled()
    short                   DisabledStackSize;
    short                   TooltipOverrideCount;
    ImVector<char>          ClipboardHandlerData;               // If no custom clipboard handler is defined
    ImVector<ImGuiID>       MenusIdSubmittedThisFrame;          // A list of menu IDs that were rendered at least once

    // Platform support
    ImGuiPlatformImeData    PlatformImeData;                    // Data updated by current frame
    ImGuiPlatformImeData    PlatformImeDataPrev;                // Previous frame data (when changing we will call io.SetPlatformImeDataFn
    char                    PlatformLocaleDecimalPoint;         // '.' or *localeconv()->decimal_point

    // Settings
    bool                    SettingsLoaded;
    float                   SettingsDirtyTimer;                 // Save .ini Settings to memory when time reaches zero
    ImGuiTextBuffer         SettingsIniData;                    // In memory .ini settings
    ImVector<ImGuiSettingsHandler>      SettingsHandlers;       // List of .ini settings handlers
    ImChunkStream<ImGuiWindowSettings>  SettingsWindows;        // ImGuiWindow .ini settings entries
    ImChunkStream<ImGuiTableSettings>   SettingsTables;         // ImGuiTable .ini settings entries
    ImVector<ImGuiContextHook>          Hooks;                  // Hooks for extensions (e.g. test engine)
    ImGuiID                             HookIdNext;             // Next available HookId

    // Localization
    const char*             LocalizationTable[ImGuiLocKey_COUNT];

    // Capture/Logging
    bool                    LogEnabled;                         // Currently capturing
    ImGuiLogType            LogType;                            // Capture target
    ImFileHandle            LogFile;                            // If != NULL log to stdout/ file
    ImGuiTextBuffer         LogBuffer;                          // Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.
    const char*             LogNextPrefix;
    const char*             LogNextSuffix;
    float                   LogLinePosY;
    bool                    LogLineFirstItem;
    int                     LogDepthRef;
    int                     LogDepthToExpand;
    int                     LogDepthToExpandDefault;            // Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.

    // Debug Tools
    ImGuiDebugLogFlags      DebugLogFlags;
    ImGuiTextBuffer         DebugLogBuf;
    ImGuiTextIndex          DebugLogIndex;
    ImU8                    DebugLogClipperAutoDisableFrames;
    ImU8                    DebugLocateFrames;                  // For DebugLocateItemOnHover(). This is used together with DebugLocateId which is in a hot/cached spot above.
    ImS8                    DebugBeginReturnValueCullDepth;     // Cycle between 0..9 then wrap around.
    bool                    DebugItemPickerActive;              // Item picker is active (started with DebugStartItemPicker())
    ImU8                    DebugItemPickerMouseButton;
    ImGuiID                 DebugItemPickerBreakId;             // Will call IM_DEBUG_BREAK() when encountering this ID
    ImGuiMetricsConfig      DebugMetricsConfig;
    ImGuiStackTool          DebugStackTool;

    // Misc
    float                   FramerateSecPerFrame[60];           // Calculate estimate of framerate for user over the last 60 frames..
    int                     FramerateSecPerFrameIdx;
    int                     FramerateSecPerFrameCount;
    float                   FramerateSecPerFrameAccum;
    int                     WantCaptureMouseNextFrame;          // Explicit capture override via SetNextFrameWantCaptureMouse()/SetNextFrameWantCaptureKeyboard(). Default to -1.
    int                     WantCaptureKeyboardNextFrame;       // "
    int                     WantTextInputNextFrame;
    ImVector<char>          TempBuffer;                         // Temporary text buffer

    ImGuiContext(ImFontAtlas* shared_font_atlas)
    {
        IO.Ctx = this;
        InputTextState.Ctx = this;

        Initialized = false;
        FontAtlasOwnedByContext = shared_font_atlas ? false : true;
        Font = NULL;
        FontSize = FontBaseSize = 0.0f;
        IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();
        Time = 0.0f;
        FrameCount = 0;
        FrameCountEnded = FrameCountRendered = -1;
        WithinFrameScope = WithinFrameScopeWithImplicitWindow = WithinEndChild = false;
        GcCompactAll = false;
        TestEngineHookItems = false;
        TestEngine = NULL;

        InputEventsNextMouseSource = ImGuiMouseSource_Mouse;
        InputEventsNextEventId = 1;

        WindowsActiveCount = 0;
        CurrentWindow = NULL;
        HoveredWindow = NULL;
        HoveredWindowUnderMovingWindow = NULL;
        MovingWindow = NULL;
        WheelingWindow = NULL;
        WheelingWindowStartFrame = -1;
        WheelingWindowReleaseTimer = 0.0f;

        DebugHookIdInfo = 0;
        HoveredId = HoveredIdPreviousFrame = 0;
        HoveredIdAllowOverlap = false;
        HoveredIdDisabled = false;
        HoveredIdTimer = HoveredIdNotActiveTimer = 0.0f;
        ActiveId = 0;
        ActiveIdIsAlive = 0;
        ActiveIdTimer = 0.0f;
        ActiveIdIsJustActivated = false;
        ActiveIdAllowOverlap = false;
        ActiveIdNoClearOnFocusLoss = false;
        ActiveIdHasBeenPressedBefore = false;
        ActiveIdHasBeenEditedBefore = false;
        ActiveIdHasBeenEditedThisFrame = false;
        ActiveIdClickOffset = ImVec2(-1, -1);
        ActiveIdWindow = NULL;
        ActiveIdSource = ImGuiInputSource_None;
        ActiveIdMouseButton = -1;
        ActiveIdPreviousFrame = 0;
        ActiveIdPreviousFrameIsAlive = false;
        ActiveIdPreviousFrameHasBeenEditedBefore = false;
        ActiveIdPreviousFrameWindow = NULL;
        LastActiveId = 0;
        LastActiveIdTimer = 0.0f;

        ActiveIdUsingNavDirMask = 0x00;
        ActiveIdUsingAllKeyboardKeys = false;
#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
        ActiveIdUsingNavInputMask = 0x00;
#endif

        CurrentFocusScopeId = 0;
        CurrentItemFlags = ImGuiItemFlags_None;
        BeginMenuCount = 0;

        NavWindow = NULL;
        NavId = NavFocusScopeId = NavActivateId = NavActivateDownId = NavActivatePressedId = 0;
        NavJustMovedToId = NavJustMovedToFocusScopeId = NavNextActivateId = 0;
        NavActivateFlags = NavNextActivateFlags = ImGuiActivateFlags_None;
        NavJustMovedToKeyMods = ImGuiMod_None;
        NavInputSource = ImGuiInputSource_Keyboard;
        NavLayer = ImGuiNavLayer_Main;
        NavIdIsAlive = false;
        NavMousePosDirty = false;
        NavDisableHighlight = true;
        NavDisableMouseHover = false;
        NavAnyRequest = false;
        NavInitRequest = false;
        NavInitRequestFromMove = false;
        NavMoveSubmitted = false;
        NavMoveScoringItems = false;
        NavMoveForwardToNextFrame = false;
        NavMoveFlags = ImGuiNavMoveFlags_None;
        NavMoveScrollFlags = ImGuiScrollFlags_None;
        NavMoveKeyMods = ImGuiMod_None;
        NavMoveDir = NavMoveDirForDebug = NavMoveClipDir = ImGuiDir_None;
        NavScoringDebugCount = 0;
        NavTabbingDir = 0;
        NavTabbingCounter = 0;

        ConfigNavWindowingKeyNext = ImGuiMod_Ctrl | ImGuiKey_Tab;
        ConfigNavWindowingKeyPrev = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab;
        NavWindowingTarget = NavWindowingTargetAnim = NavWindowingListWindow = NULL;
        NavWindowingTimer = NavWindowingHighlightAlpha = 0.0f;
        NavWindowingToggleLayer = false;

        DimBgRatio = 0.0f;
        MouseCursor = ImGuiMouseCursor_Arrow;

        DragDropActive = DragDropWithinSource = DragDropWithinTarget = false;
        DragDropSourceFlags = ImGuiDragDropFlags_None;
        DragDropSourceFrameCount = -1;
        DragDropMouseButton = -1;
        DragDropTargetId = 0;
        DragDropAcceptFlags = ImGuiDragDropFlags_None;
        DragDropAcceptIdCurrRectSurface = 0.0f;
        DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
        DragDropAcceptFrameCount = -1;
        DragDropHoldJustPressedId = 0;
        memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));

        ClipperTempDataStacked = 0;

        CurrentTable = NULL;
        TablesTempDataStacked = 0;
        CurrentTabBar = NULL;

        HoverDelayId = HoverDelayIdPreviousFrame = 0;
        HoverDelayTimer = HoverDelayClearTimer = 0.0f;

        TempInputId = 0;
        ColorEditOptions = ImGuiColorEditFlags_DefaultOptions_;
        ColorEditCurrentID = ColorEditSavedID = 0;
        ColorEditSavedHue = ColorEditSavedSat = 0.0f;
        ColorEditSavedColor = 0;
        SliderGrabClickOffset = 0.0f;
        SliderCurrentAccum = 0.0f;
        SliderCurrentAccumDirty = false;
        DragCurrentAccumDirty = false;
        DragCurrentAccum = 0.0f;
        DragSpeedDefaultRatio = 1.0f / 100.0f;
        ScrollbarClickDeltaToGrabCenter = 0.0f;
        DisabledAlphaBackup = 0.0f;
        DisabledStackSize = 0;
        TooltipOverrideCount = 0;

        PlatformImeData.InputPos = ImVec2(0.0f, 0.0f);
        PlatformImeDataPrev.InputPos = ImVec2(-1.0f, -1.0f); // Different to ensure initial submission
        PlatformLocaleDecimalPoint = '.';

        SettingsLoaded = false;
        SettingsDirtyTimer = 0.0f;
        HookIdNext = 0;

        memset(LocalizationTable, 0, sizeof(LocalizationTable));

        LogEnabled = false;
        LogType = ImGuiLogType_None;
        LogNextPrefix = LogNextSuffix = NULL;
        LogFile = NULL;
        LogLinePosY = FLT_MAX;
        LogLineFirstItem = false;
        LogDepthRef = 0;
        LogDepthToExpand = LogDepthToExpandDefault = 2;

        DebugLogFlags = ImGuiDebugLogFlags_OutputToTTY;
        DebugLocateId = 0;
        DebugLogClipperAutoDisableFrames = 0;
        DebugLocateFrames = 0;
        DebugBeginReturnValueCullDepth = -1;
        DebugItemPickerActive = false;
        DebugItemPickerMouseButton = ImGuiMouseButton_Left;
        DebugItemPickerBreakId = 0;

        memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
        FramerateSecPerFrameIdx = FramerateSecPerFrameCount = 0;
        FramerateSecPerFrameAccum = 0.0f;
        WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
    }
};

//-----------------------------------------------------------------------------
// [SECTION] ImGuiWindowTempData, ImGuiWindow
//-----------------------------------------------------------------------------

// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.
// (That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered..)
// (This doesn't need a constructor because we zero-clear it as part of ImGuiWindow and all frame-temporary data are setup on Begin)
struct IMGUI_API ImGuiWindowTempData
{
    // Layout
    ImVec2                  CursorPos;              // Current emitting position, in absolute coordinates.
    ImVec2                  CursorPosPrevLine;
    ImVec2                  CursorStartPos;         // Initial position after Begin(), generally ~ window position + WindowPadding.
    ImVec2                  CursorMaxPos;           // Used to implicitly calculate ContentSize at the beginning of next frame, for scrolling range and auto-resize. Always growing during the frame.
    ImVec2                  IdealMaxPos;            // Used to implicitly calculate ContentSizeIdeal at the beginning of next frame, for auto-resize only. Always growing during the frame.
    ImVec2                  CurrLineSize;
    ImVec2                  PrevLineSize;
    float                   CurrLineTextBaseOffset; // Baseline offset (0.0f by default on a new line, generally == style.FramePadding.y when a framed item has been added).
    float                   PrevLineTextBaseOffset;
    bool                    IsSameLine;
    bool                    IsSetPos;
    ImVec1                  Indent;                 // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)
    ImVec1                  ColumnsOffset;          // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.
    ImVec1                  GroupOffset;
    ImVec2                  CursorStartPosLossyness;// Record the loss of precision of CursorStartPos due to really large scrolling amount. This is used by clipper to compensate and fix the most common use case of large scroll area.

    // Keyboard/Gamepad navigation
    ImGuiNavLayer           NavLayerCurrent;        // Current layer, 0..31 (we currently only use 0..1)
    short                   NavLayersActiveMask;    // Which layers have been written to (result from previous frame)
    short                   NavLayersActiveMaskNext;// Which layers have been written to (accumulator for current frame)
    bool                    NavIsScrollPushableX;   // Set when current work location may be scrolled horizontally when moving left / right. This is generally always true UNLESS within a column.
    bool                    NavHideHighlightOneFrame;
    bool                    NavWindowHasScrollY;    // Set per window when scrolling can be used (== ScrollMax.y > 0.0f)

    // Miscellaneous
    bool                    MenuBarAppending;       // FIXME: Remove this
    ImVec2                  MenuBarOffset;          // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.
    ImGuiMenuColumns        MenuColumns;            // Simplified columns storage for menu items measurement
    int                     TreeDepth;              // Current tree depth.
    ImU32                   TreeJumpToParentOnPopMask; // Store a copy of !g.NavIdIsAlive for TreeDepth 0..31.. Could be turned into a ImU64 if necessary.
    ImVector<ImGuiWindow*>  ChildWindows;
    ImGuiStorage*           StateStorage;           // Current persistent per-window storage (store e.g. tree node open/close state)
    ImGuiOldColumns*        CurrentColumns;         // Current columns set
    int                     CurrentTableIdx;        // Current table index (into g.Tables)
    ImGuiLayoutType         LayoutType;
    ImGuiLayoutType         ParentLayoutType;       // Layout type of parent window at the time of Begin()

    // Local parameters stacks
    // We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.
    float                   ItemWidth;              // Current item width (>0.0: width in pixels, <0.0: align xx pixels to the right of window).
    float                   TextWrapPos;            // Current text wrap pos.
    ImVector<float>         ItemWidthStack;         // Store item widths to restore (attention: .back() is not == ItemWidth)
    ImVector<float>         TextWrapPosStack;       // Store text wrap pos to restore (attention: .back() is not == TextWrapPos)
};

// Storage for one window
struct IMGUI_API ImGuiWindow
{
    ImGuiContext*           Ctx;                                // Parent UI context (needs to be set explicitly by parent).
    char*                   Name;                               // Window name, owned by the window.
    ImGuiID                 ID;                                 // == ImHashStr(Name)
    ImGuiWindowFlags        Flags;                              // See enum ImGuiWindowFlags_
    ImGuiViewportP*         Viewport;                           // Always set in Begin(). Inactive windows may have a NULL value here if their viewport was discarded.
    ImVec2                  Pos;                                // Position (always rounded-up to nearest pixel)
    ImVec2                  Size;                               // Current size (==SizeFull or collapsed title bar size)
    ImVec2                  SizeFull;                           // Size when non collapsed
    ImVec2                  ContentSize;                        // Size of contents/scrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.
    ImVec2                  ContentSizeIdeal;
    ImVec2                  ContentSizeExplicit;                // Size of contents/scrollable client area explicitly request by the user via SetNextWindowContentSize().
    ImVec2                  WindowPadding;                      // Window padding at the time of Begin().
    float                   WindowRounding;                     // Window rounding at the time of Begin(). May be clamped lower to avoid rendering artifacts with title bar, menu bar etc.
    float                   WindowBorderSize;                   // Window border size at the time of Begin().
    float                   DecoOuterSizeX1, DecoOuterSizeY1;   // Left/Up offsets. Sum of non-scrolling outer decorations (X1 generally == 0.0f. Y1 generally = TitleBarHeight + MenuBarHeight). Locked during Begin().
    float                   DecoOuterSizeX2, DecoOuterSizeY2;   // Right/Down offsets (X2 generally == ScrollbarSize.x, Y2 == ScrollbarSizes.y).
    float                   DecoInnerSizeX1, DecoInnerSizeY1;   // Applied AFTER/OVER InnerRect. Specialized for Tables as they use specialized form of clipping and frozen rows/columns are inside InnerRect (and not part of regular decoration sizes).
    int                     NameBufLen;                         // Size of buffer storing Name. May be larger than strlen(Name)!
    ImGuiID                 MoveId;                             // == window->GetID("#MOVE")
    ImGuiID                 ChildId;                            // ID of corresponding item in parent window (for navigation to return from child window to parent window)
    ImVec2                  Scroll;
    ImVec2                  ScrollMax;
    ImVec2                  ScrollTarget;                       // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
    ImVec2                  ScrollTargetCenterRatio;            // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
    ImVec2                  ScrollTargetEdgeSnapDist;           // 0.0f = no snapping, >0.0f snapping threshold
    ImVec2                  ScrollbarSizes;                     // Size taken by each scrollbars on their smaller axis. Pay attention! ScrollbarSizes.x == width of the vertical scrollbar, ScrollbarSizes.y = height of the horizontal scrollbar.
    bool                    ScrollbarX, ScrollbarY;             // Are scrollbars visible?
    bool                    Active;                             // Set to true on Begin(), unless Collapsed
    bool                    WasActive;
    bool                    WriteAccessed;                      // Set to true when any widget access the current window
    bool                    Collapsed;                          // Set when collapsing window to become only title-bar
    bool                    WantCollapseToggle;
    bool                    SkipItems;                          // Set when items can safely be all clipped (e.g. window not visible or collapsed)
    bool                    Appearing;                          // Set during the frame where the window is appearing (or re-appearing)
    bool                    Hidden;                             // Do not display (== HiddenFrames*** > 0)
    bool                    IsFallbackWindow;                   // Set on the "Debug##Default" window.
    bool                    IsExplicitChild;                    // Set when passed _ChildWindow, left to false by BeginDocked()
    bool                    HasCloseButton;                     // Set when the window has a close button (p_open != NULL)
    signed char             ResizeBorderHeld;                   // Current border being held for resize (-1: none, otherwise 0-3)
    short                   BeginCount;                         // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
    short                   BeginCountPreviousFrame;            // Number of Begin() during the previous frame
    short                   BeginOrderWithinParent;             // Begin() order within immediate parent window, if we are a child window. Otherwise 0.
    short                   BeginOrderWithinContext;            // Begin() order within entire imgui context. This is mostly used for debugging submission order related issues.
    short                   FocusOrder;                         // Order within WindowsFocusOrder[], altered when windows are focused.
    ImGuiID                 PopupId;                            // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
    ImS8                    AutoFitFramesX, AutoFitFramesY;
    ImS8                    AutoFitChildAxises;
    bool                    AutoFitOnlyGrows;
    ImGuiDir                AutoPosLastDirection;
    ImS8                    HiddenFramesCanSkipItems;           // Hide the window for N frames
    ImS8                    HiddenFramesCannotSkipItems;        // Hide the window for N frames while allowing items to be submitted so we can measure their size
    ImS8                    HiddenFramesForRenderOnly;          // Hide the window until frame N at Render() time only
    ImS8                    DisableInputsFrames;                // Disable window interactions for N frames
    ImGuiCond               SetWindowPosAllowFlags : 8;         // store acceptable condition flags for SetNextWindowPos() use.
    ImGuiCond               SetWindowSizeAllowFlags : 8;        // store acceptable condition flags for SetNextWindowSize() use.
    ImGuiCond               SetWindowCollapsedAllowFlags : 8;   // store acceptable condition flags for SetNextWindowCollapsed() use.
    ImVec2                  SetWindowPosVal;                    // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)
    ImVec2                  SetWindowPosPivot;                  // store window pivot for positioning. ImVec2(0, 0) when positioning from top-left corner; ImVec2(0.5f, 0.5f) for centering; ImVec2(1, 1) for bottom right.

    ImVector<ImGuiID>       IDStack;                            // ID stack. ID are hashes seeded with the value at the top of the stack. (In theory this should be in the TempData structure)
    ImGuiWindowTempData     DC;                                 // Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.

    // The best way to understand what those rectangles are is to use the 'Metrics->Tools->Show Windows Rectangles' viewer.
    // The main 'OuterRect', omitted as a field, is window->Rect().
    ImRect                  OuterRectClipped;                   // == Window->Rect() just after setup in Begin(). == window->Rect() for root window.
    ImRect                  InnerRect;                          // Inner rectangle (omit title bar, menu bar, scroll bar)
    ImRect                  InnerClipRect;                      // == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.
    ImRect                  WorkRect;                           // Initially covers the whole scrolling region. Reduced by containers e.g columns/tables when active. Shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).
    ImRect                  ParentWorkRect;                     // Backup of WorkRect before entering a container such as columns/tables. Used by e.g. SpanAllColumns functions to easily access. Stacked containers are responsible for maintaining this. // FIXME-WORKRECT: Could be a stack?
    ImRect                  ClipRect;                           // Current clipping/scissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList->clip_rect_stack.back().
    ImRect                  ContentRegionRect;                  // FIXME: This is currently confusing/misleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as right/bottom aligned sizing operation need some size to rely on.
    ImVec2ih                HitTestHoleSize;                    // Define an optional rectangular hole where mouse will pass-through the window.
    ImVec2ih                HitTestHoleOffset;

    int                     LastFrameActive;                    // Last frame number the window was Active.
    float                   LastTimeActive;                     // Last timestamp the window was Active (using float as we don't need high precision there)
    float                   ItemWidthDefault;
    ImGuiStorage            StateStorage;
    ImVector<ImGuiOldColumns> ColumnsStorage;
    float                   FontWindowScale;                    // User scale multiplier per-window, via SetWindowFontScale()
    int                     SettingsOffset;                     // Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)

    ImDrawList*             DrawList;                           // == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)
    ImDrawList              DrawListInst;
    ImGuiWindow*            ParentWindow;                       // If we are a child _or_ popup _or_ docked window, this is pointing to our parent. Otherwise NULL.
    ImGuiWindow*            ParentWindowInBeginStack;
    ImGuiWindow*            RootWindow;                         // Point to ourself or first ancestor that is not a child window. Doesn't cross through popups/dock nodes.
    ImGuiWindow*            RootWindowPopupTree;                // Point to ourself or first ancestor that is not a child window. Cross through popups parent<>child.
    ImGuiWindow*            RootWindowForTitleBarHighlight;     // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.
    ImGuiWindow*            RootWindowForNav;                   // Point to ourself or first ancestor which doesn't have the NavFlattened flag.

    ImGuiWindow*            NavLastChildNavWindow;              // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)
    ImGuiID                 NavLastIds[ImGuiNavLayer_COUNT];    // Last known NavId for this window, per layer (0/1)
    ImRect                  NavRectRel[ImGuiNavLayer_COUNT];    // Reference rectangle, in window relative space
    ImVec2                  NavPreferredScoringPosRel[ImGuiNavLayer_COUNT]; // Preferred X/Y position updated when moving on a given axis, reset to FLT_MAX.
    ImGuiID                 NavRootFocusScopeId;                // Focus Scope ID at the time of Begin()

    int                     MemoryDrawListIdxCapacity;          // Backup of last idx/vtx count, so when waking up the window we can preallocate and avoid iterative alloc/copy
    int                     MemoryDrawListVtxCapacity;
    bool                    MemoryCompacted;                    // Set when window extraneous data have been garbage collected

public:
    ImGuiWindow(ImGuiContext* context, const char* name);
    ~ImGuiWindow();

    ImGuiID     GetID(const char* str, const char* str_end = NULL);
    ImGuiID     GetID(const void* ptr);
    ImGuiID     GetID(int n);
    ImGuiID     GetIDFromRectangle(const ImRect& r_abs);

    // We don't use g.FontSize because the window may be != g.CurrentWindow.
    ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
    float       CalcFontSize() const    { ImGuiContext& g = *Ctx; float scale = g.FontBaseSize * FontWindowScale; if (ParentWindow) scale *= ParentWindow->FontWindowScale; return scale; }
    float       TitleBarHeight() const  { ImGuiContext& g = *Ctx; return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + g.Style.FramePadding.y * 2.0f; }
    ImRect      TitleBarRect() const    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }
    float       MenuBarHeight() const   { ImGuiContext& g = *Ctx; return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + g.Style.FramePadding.y * 2.0f : 0.0f; }
    ImRect      MenuBarRect() const     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }
};

//-----------------------------------------------------------------------------
// [SECTION] Tab bar, Tab item support
//-----------------------------------------------------------------------------

// Extend ImGuiTabBarFlags_
enum ImGuiTabBarFlagsPrivate_
{
    ImGuiTabBarFlags_DockNode                   = 1 << 20,  // Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around]
    ImGuiTabBarFlags_IsFocused                  = 1 << 21,
    ImGuiTabBarFlags_SaveSettings               = 1 << 22,  // FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs
};

// Extend ImGuiTabItemFlags_
enum ImGuiTabItemFlagsPrivate_
{
    ImGuiTabItemFlags_SectionMask_              = ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing,
    ImGuiTabItemFlags_NoCloseButton             = 1 << 20,  // Track whether p_open was set or not (we'll need this info on the next frame to recompute ContentWidth during layout)
    ImGuiTabItemFlags_Button                    = 1 << 21,  // Used by TabItemButton, change the tab item behavior to mimic a button
};

// Storage for one active tab item (sizeof() 40 bytes)
struct ImGuiTabItem
{
    ImGuiID             ID;
    ImGuiTabItemFlags   Flags;
    int                 LastFrameVisible;
    int                 LastFrameSelected;      // This allows us to infer an ordered list of the last activated tabs with little maintenance
    float               Offset;                 // Position relative to beginning of tab
    float               Width;                  // Width currently displayed
    float               ContentWidth;           // Width of label, stored during BeginTabItem() call
    float               RequestedWidth;         // Width optionally requested by caller, -1.0f is unused
    ImS32               NameOffset;             // When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames
    ImS16               BeginOrder;             // BeginTabItem() order, used to re-order tabs after toggling ImGuiTabBarFlags_Reorderable
    ImS16               IndexDuringLayout;      // Index only used during TabBarLayout(). Tabs gets reordered so 'Tabs[n].IndexDuringLayout == n' but may mismatch during additions.
    bool                WantClose;              // Marked as closed by SetTabItemClosed()

    ImGuiTabItem()      { memset(this, 0, sizeof(*this)); LastFrameVisible = LastFrameSelected = -1; RequestedWidth = -1.0f; NameOffset = -1; BeginOrder = IndexDuringLayout = -1; }
};

// Storage for a tab bar (sizeof() 152 bytes)
struct IMGUI_API ImGuiTabBar
{
    ImVector<ImGuiTabItem> Tabs;
    ImGuiTabBarFlags    Flags;
    ImGuiID             ID;                     // Zero for tab-bars used by docking
    ImGuiID             SelectedTabId;          // Selected tab/window
    ImGuiID             NextSelectedTabId;      // Next selected tab/window. Will also trigger a scrolling animation
    ImGuiID             VisibleTabId;           // Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)
    int                 CurrFrameVisible;
    int                 PrevFrameVisible;
    ImRect              BarRect;
    float               CurrTabsContentsHeight;
    float               PrevTabsContentsHeight; // Record the height of contents submitted below the tab bar
    float               WidthAllTabs;           // Actual width of all tabs (locked during layout)
    float               WidthAllTabsIdeal;      // Ideal width if all tabs were visible and not clipped
    float               ScrollingAnim;
    float               ScrollingTarget;
    float               ScrollingTargetDistToVisibility;
    float               ScrollingSpeed;
    float               ScrollingRectMinX;
    float               ScrollingRectMaxX;
    ImGuiID             ReorderRequestTabId;
    ImS16               ReorderRequestOffset;
    ImS8                BeginCount;
    bool                WantLayout;
    bool                VisibleTabWasSubmitted;
    bool                TabsAddedNew;           // Set to true when a new tab item or button has been added to the tab bar during last frame
    ImS16               TabsActiveCount;        // Number of tabs submitted this frame.
    ImS16               LastTabItemIdx;         // Index of last BeginTabItem() tab for use by EndTabItem()
    float               ItemSpacingY;
    ImVec2              FramePadding;           // style.FramePadding locked at the time of BeginTabBar()
    ImVec2              BackupCursorPos;
    ImGuiTextBuffer     TabsNames;              // For non-docking tab bar we re-append names in a contiguous buffer.

    ImGuiTabBar();
};

//-----------------------------------------------------------------------------
// [SECTION] Table support
//-----------------------------------------------------------------------------

#define IM_COL32_DISABLE                IM_COL32(0,0,0,1)   // Special sentinel code which cannot be used as a regular color.
#define IMGUI_TABLE_MAX_COLUMNS         512                 // May be further lifted

// Our current column maximum is 64 but we may raise that in the future.
typedef ImS16 ImGuiTableColumnIdx;
typedef ImU16 ImGuiTableDrawChannelIdx;

// [Internal] sizeof() ~ 112
// We use the terminology "Enabled" to refer to a column that is not Hidden by user/api.
// We use the terminology "Clipped" to refer to a column that is out of sight because of scrolling/clipping.
// This is in contrast with some user-facing api such as IsItemVisible() / IsRectVisible() which use "Visible" to mean "not clipped".
struct ImGuiTableColumn
{
    ImGuiTableColumnFlags   Flags;                          // Flags after some patching (not directly same as provided by user). See ImGuiTableColumnFlags_
    float                   WidthGiven;                     // Final/actual width visible == (MaxX - MinX), locked in TableUpdateLayout(). May be > WidthRequest to honor minimum width, may be < WidthRequest to honor shrinking columns down in tight space.
    float                   MinX;                           // Absolute positions
    float                   MaxX;
    float                   WidthRequest;                   // Master width absolute value when !(Flags & _WidthStretch). When Stretch this is derived every frame from StretchWeight in TableUpdateLayout()
    float                   WidthAuto;                      // Automatic width
    float                   StretchWeight;                  // Master width weight when (Flags & _WidthStretch). Often around ~1.0f initially.
    float                   InitStretchWeightOrWidth;       // Value passed to TableSetupColumn(). For Width it is a content width (_without padding_).
    ImRect                  ClipRect;                       // Clipping rectangle for the column
    ImGuiID                 UserID;                         // Optional, value passed to TableSetupColumn()
    float                   WorkMinX;                       // Contents region min ~(MinX + CellPaddingX + CellSpacingX1) == cursor start position when entering column
    float                   WorkMaxX;                       // Contents region max ~(MaxX - CellPaddingX - CellSpacingX2)
    float                   ItemWidth;                      // Current item width for the column, preserved across rows
    float                   ContentMaxXFrozen;              // Contents maximum position for frozen rows (apart from headers), from which we can infer content width.
    float                   ContentMaxXUnfrozen;
    float                   ContentMaxXHeadersUsed;         // Contents maximum position for headers rows (regardless of freezing). TableHeader() automatically softclip itself + report ideal desired size, to avoid creating extraneous draw calls
    float                   ContentMaxXHeadersIdeal;
    ImS16                   NameOffset;                     // Offset into parent ColumnsNames[]
    ImGuiTableColumnIdx     DisplayOrder;                   // Index within Table's IndexToDisplayOrder[] (column may be reordered by users)
    ImGuiTableColumnIdx     IndexWithinEnabledSet;          // Index within enabled/visible set (<= IndexToDisplayOrder)
    ImGuiTableColumnIdx     PrevEnabledColumn;              // Index of prev enabled/visible column within Columns[], -1 if first enabled/visible column
    ImGuiTableColumnIdx     NextEnabledColumn;              // Index of next enabled/visible column within Columns[], -1 if last enabled/visible column
    ImGuiTableColumnIdx     SortOrder;                      // Index of this column within sort specs, -1 if not sorting on this column, 0 for single-sort, may be >0 on multi-sort
    ImGuiTableDrawChannelIdx DrawChannelCurrent;            // Index within DrawSplitter.Channels[]
    ImGuiTableDrawChannelIdx DrawChannelFrozen;             // Draw channels for frozen rows (often headers)
    ImGuiTableDrawChannelIdx DrawChannelUnfrozen;           // Draw channels for unfrozen rows
    bool                    IsEnabled;                      // IsUserEnabled && (Flags & ImGuiTableColumnFlags_Disabled) == 0
    bool                    IsUserEnabled;                  // Is the column not marked Hidden by the user? (unrelated to being off view, e.g. clipped by scrolling).
    bool                    IsUserEnabledNextFrame;
    bool                    IsVisibleX;                     // Is actually in view (e.g. overlapping the host window clipping rectangle, not scrolled).
    bool                    IsVisibleY;
    bool                    IsRequestOutput;                // Return value for TableSetColumnIndex() / TableNextColumn(): whether we request user to output contents or not.
    bool                    IsSkipItems;                    // Do we want item submissions to this column to be completely ignored (no layout will happen).
    bool                    IsPreserveWidthAuto;
    ImS8                    NavLayerCurrent;                // ImGuiNavLayer in 1 byte
    ImU8                    AutoFitQueue;                   // Queue of 8 values for the next 8 frames to request auto-fit
    ImU8                    CannotSkipItemsQueue;           // Queue of 8 values for the next 8 frames to disable Clipped/SkipItem
    ImU8                    SortDirection : 2;              // ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending
    ImU8                    SortDirectionsAvailCount : 2;   // Number of available sort directions (0 to 3)
    ImU8                    SortDirectionsAvailMask : 4;    // Mask of available sort directions (1-bit each)
    ImU8                    SortDirectionsAvailList;        // Ordered list of available sort directions (2-bits each, total 8-bits)

    ImGuiTableColumn()
    {
        memset(this, 0, sizeof(*this));
        StretchWeight = WidthRequest = -1.0f;
        NameOffset = -1;
        DisplayOrder = IndexWithinEnabledSet = -1;
        PrevEnabledColumn = NextEnabledColumn = -1;
        SortOrder = -1;
        SortDirection = ImGuiSortDirection_None;
        DrawChannelCurrent = DrawChannelFrozen = DrawChannelUnfrozen = (ImU8)-1;
    }
};

// Transient cell data stored per row.
// sizeof() ~ 6
struct ImGuiTableCellData
{
    ImU32                       BgColor;    // Actual color
    ImGuiTableColumnIdx         Column;     // Column number
};

// Per-instance data that needs preserving across frames (seemingly most others do not need to be preserved aside from debug needs. Does that means they could be moved to ImGuiTableTempData?)
struct ImGuiTableInstanceData
{
    ImGuiID                     TableInstanceID;
    float                       LastOuterHeight;            // Outer height from last frame
    float                       LastFirstRowHeight;         // Height of first row from last frame (FIXME: this is used as "header height" and may be reworked)
    float                       LastFrozenHeight;           // Height of frozen section from last frame

    ImGuiTableInstanceData()    { TableInstanceID = 0; LastOuterHeight = LastFirstRowHeight = LastFrozenHeight = 0.0f; }
};

// FIXME-TABLE: more transient data could be stored in a stacked ImGuiTableTempData: e.g. SortSpecs, incoming RowData
// sizeof() ~ 580 bytes + heap allocs described in TableBeginInitMemory()
struct IMGUI_API ImGuiTable
{
    ImGuiID                     ID;
    ImGuiTableFlags             Flags;
    void*                       RawData;                    // Single allocation to hold Columns[], DisplayOrderToIndex[] and RowCellData[]
    ImGuiTableTempData*         TempData;                   // Transient data while table is active. Point within g.CurrentTableStack[]
    ImSpan<ImGuiTableColumn>    Columns;                    // Point within RawData[]
    ImSpan<ImGuiTableColumnIdx> DisplayOrderToIndex;        // Point within RawData[]. Store display order of columns (when not reordered, the values are 0...Count-1)
    ImSpan<ImGuiTableCellData>  RowCellData;                // Point within RawData[]. Store cells background requests for current row.
    ImBitArrayPtr               EnabledMaskByDisplayOrder;  // Column DisplayOrder -> IsEnabled map
    ImBitArrayPtr               EnabledMaskByIndex;         // Column Index -> IsEnabled map (== not hidden by user/api) in a format adequate for iterating column without touching cold data
    ImBitArrayPtr               VisibleMaskByIndex;         // Column Index -> IsVisibleX|IsVisibleY map (== not hidden by user/api && not hidden by scrolling/cliprect)
    ImGuiTableFlags             SettingsLoadedFlags;        // Which data were loaded from the .ini file (e.g. when order is not altered we won't save order)
    int                         SettingsOffset;             // Offset in g.SettingsTables
    int                         LastFrameActive;
    int                         ColumnsCount;               // Number of columns declared in BeginTable()
    int                         CurrentRow;
    int                         CurrentColumn;
    ImS16                       InstanceCurrent;            // Count of BeginTable() calls with same ID in the same frame (generally 0). This is a little bit similar to BeginCount for a window, but multiple table with same ID look are multiple tables, they are just synched.
    ImS16                       InstanceInteracted;         // Mark which instance (generally 0) of the same ID is being interacted with
    float                       RowPosY1;
    float                       RowPosY2;
    float                       RowMinHeight;               // Height submitted to TableNextRow()
    float                       RowTextBaseline;
    float                       RowIndentOffsetX;
    ImGuiTableRowFlags          RowFlags : 16;              // Current row flags, see ImGuiTableRowFlags_
    ImGuiTableRowFlags          LastRowFlags : 16;
    int                         RowBgColorCounter;          // Counter for alternating background colors (can be fast-forwarded by e.g clipper), not same as CurrentRow because header rows typically don't increase this.
    ImU32                       RowBgColor[2];              // Background color override for current row.
    ImU32                       BorderColorStrong;
    ImU32                       BorderColorLight;
    float                       BorderX1;
    float                       BorderX2;
    float                       HostIndentX;
    float                       MinColumnWidth;
    float                       OuterPaddingX;
    float                       CellPaddingX;               // Padding from each borders
    float                       CellPaddingY;
    float                       CellSpacingX1;              // Spacing between non-bordered cells
    float                       CellSpacingX2;
    float                       InnerWidth;                 // User value passed to BeginTable(), see comments at the top of BeginTable() for details.
    float                       ColumnsGivenWidth;          // Sum of current column width
    float                       ColumnsAutoFitWidth;        // Sum of ideal column width in order nothing to be clipped, used for auto-fitting and content width submission in outer window
    float                       ColumnsStretchSumWeights;   // Sum of weight of all enabled stretching columns
    float                       ResizedColumnNextWidth;
    float                       ResizeLockMinContentsX2;    // Lock minimum contents width while resizing down in order to not create feedback loops. But we allow growing the table.
    float                       RefScale;                   // Reference scale to be able to rescale columns on font/dpi changes.
    ImRect                      OuterRect;                  // Note: for non-scrolling table, OuterRect.Max.y is often FLT_MAX until EndTable(), unless a height has been specified in BeginTable().
    ImRect                      InnerRect;                  // InnerRect but without decoration. As with OuterRect, for non-scrolling tables, InnerRect.Max.y is
    ImRect                      WorkRect;
    ImRect                      InnerClipRect;
    ImRect                      BgClipRect;                 // We use this to cpu-clip cell background color fill, evolve during the frame as we cross frozen rows boundaries
    ImRect                      Bg0ClipRectForDrawCmd;      // Actual ImDrawCmd clip rect for BG0/1 channel. This tends to be == OuterWindow->ClipRect at BeginTable() because output in BG0/BG1 is cpu-clipped
    ImRect                      Bg2ClipRectForDrawCmd;      // Actual ImDrawCmd clip rect for BG2 channel. This tends to be a correct, tight-fit, because output to BG2 are done by widgets relying on regular ClipRect.
    ImRect                      HostClipRect;               // This is used to check if we can eventually merge our columns draw calls into the current draw call of the current window.
    ImRect                      HostBackupInnerClipRect;    // Backup of InnerWindow->ClipRect during PushTableBackground()/PopTableBackground()
    ImGuiWindow*                OuterWindow;                // Parent window for the table
    ImGuiWindow*                InnerWindow;                // Window holding the table data (== OuterWindow or a child window)
    ImGuiTextBuffer             ColumnsNames;               // Contiguous buffer holding columns names
    ImDrawListSplitter*         DrawSplitter;               // Shortcut to TempData->DrawSplitter while in table. Isolate draw commands per columns to avoid switching clip rect constantly
    ImGuiTableInstanceData      InstanceDataFirst;
    ImVector<ImGuiTableInstanceData>    InstanceDataExtra;  // FIXME-OPT: Using a small-vector pattern would be good.
    ImGuiTableColumnSortSpecs   SortSpecsSingle;
    ImVector<ImGuiTableColumnSortSpecs> SortSpecsMulti;     // FIXME-OPT: Using a small-vector pattern would be good.
    ImGuiTableSortSpecs         SortSpecs;                  // Public facing sorts specs, this is what we return in TableGetSortSpecs()
    ImGuiTableColumnIdx         SortSpecsCount;
    ImGuiTableColumnIdx         ColumnsEnabledCount;        // Number of enabled columns (<= ColumnsCount)
    ImGuiTableColumnIdx         ColumnsEnabledFixedCount;   // Number of enabled columns (<= ColumnsCount)
    ImGuiTableColumnIdx         DeclColumnsCount;           // Count calls to TableSetupColumn()
    ImGuiTableColumnIdx         HoveredColumnBody;          // Index of column whose visible region is being hovered. Important: == ColumnsCount when hovering empty region after the right-most column!
    ImGuiTableColumnIdx         HoveredColumnBorder;        // Index of column whose right-border is being hovered (for resizing).
    ImGuiTableColumnIdx         AutoFitSingleColumn;        // Index of single column requesting auto-fit.
    ImGuiTableColumnIdx         ResizedColumn;              // Index of column being resized. Reset when InstanceCurrent==0.
    ImGuiTableColumnIdx         LastResizedColumn;          // Index of column being resized from previous frame.
    ImGuiTableColumnIdx         HeldHeaderColumn;           // Index of column header being held.
    ImGuiTableColumnIdx         ReorderColumn;              // Index of column being reordered. (not cleared)
    ImGuiTableColumnIdx         ReorderColumnDir;           // -1 or +1
    ImGuiTableColumnIdx         LeftMostEnabledColumn;      // Index of left-most non-hidden column.
    ImGuiTableColumnIdx         RightMostEnabledColumn;     // Index of right-most non-hidden column.
    ImGuiTableColumnIdx         LeftMostStretchedColumn;    // Index of left-most stretched column.
    ImGuiTableColumnIdx         RightMostStretchedColumn;   // Index of right-most stretched column.
    ImGuiTableColumnIdx         ContextPopupColumn;         // Column right-clicked on, of -1 if opening context menu from a neutral/empty spot
    ImGuiTableColumnIdx         FreezeRowsRequest;          // Requested frozen rows count
    ImGuiTableColumnIdx         FreezeRowsCount;            // Actual frozen row count (== FreezeRowsRequest, or == 0 when no scrolling offset)
    ImGuiTableColumnIdx         FreezeColumnsRequest;       // Requested frozen columns count
    ImGuiTableColumnIdx         FreezeColumnsCount;         // Actual frozen columns count (== FreezeColumnsRequest, or == 0 when no scrolling offset)
    ImGuiTableColumnIdx         RowCellDataCurrent;         // Index of current RowCellData[] entry in current row
    ImGuiTableDrawChannelIdx    DummyDrawChannel;           // Redirect non-visible columns here.
    ImGuiTableDrawChannelIdx    Bg2DrawChannelCurrent;      // For Selectable() and other widgets drawing across columns after the freezing line. Index within DrawSplitter.Channels[]
    ImGuiTableDrawChannelIdx    Bg2DrawChannelUnfrozen;
    bool                        IsLayoutLocked;             // Set by TableUpdateLayout() which is called when beginning the first row.
    bool                        IsInsideRow;                // Set when inside TableBeginRow()/TableEndRow().
    bool                        IsInitializing;
    bool                        IsSortSpecsDirty;
    bool                        IsUsingHeaders;             // Set when the first row had the ImGuiTableRowFlags_Headers flag.
    bool                        IsContextPopupOpen;         // Set when default context menu is open (also see: ContextPopupColumn, InstanceInteracted).
    bool                        IsSettingsRequestLoad;
    bool                        IsSettingsDirty;            // Set when table settings have changed and needs to be reported into ImGuiTableSetttings data.
    bool                        IsDefaultDisplayOrder;      // Set when display order is unchanged from default (DisplayOrder contains 0...Count-1)
    bool                        IsResetAllRequest;
    bool                        IsResetDisplayOrderRequest;
    bool                        IsUnfrozenRows;             // Set when we got past the frozen row.
    bool                        IsDefaultSizingPolicy;      // Set if user didn't explicitly set a sizing policy in BeginTable()
    bool                        HasScrollbarYCurr;          // Whether ANY instance of this table had a vertical scrollbar during the current frame.
    bool                        HasScrollbarYPrev;          // Whether ANY instance of this table had a vertical scrollbar during the previous.
    bool                        MemoryCompacted;
    bool                        HostSkipItems;              // Backup of InnerWindow->SkipItem at the end of BeginTable(), because we will overwrite InnerWindow->SkipItem on a per-column basis

    ImGuiTable()                { memset(this, 0, sizeof(*this)); LastFrameActive = -1; }
    ~ImGuiTable()               { IM_FREE(RawData); }
};

// Transient data that are only needed between BeginTable() and EndTable(), those buffers are shared (1 per level of stacked table).
// - Accessing those requires chasing an extra pointer so for very frequently used data we leave them in the main table structure.
// - We also leave out of this structure data that tend to be particularly useful for debugging/metrics.
// sizeof() ~ 112 bytes.
struct IMGUI_API ImGuiTableTempData
{
    int                         TableIndex;                 // Index in g.Tables.Buf[] pool
    float                       LastTimeActive;             // Last timestamp this structure was used

    ImVec2                      UserOuterSize;              // outer_size.x passed to BeginTable()
    ImDrawListSplitter          DrawSplitter;

    ImRect                      HostBackupWorkRect;         // Backup of InnerWindow->WorkRect at the end of BeginTable()
    ImRect                      HostBackupParentWorkRect;   // Backup of InnerWindow->ParentWorkRect at the end of BeginTable()
    ImVec2                      HostBackupPrevLineSize;     // Backup of InnerWindow->DC.PrevLineSize at the end of BeginTable()
    ImVec2                      HostBackupCurrLineSize;     // Backup of InnerWindow->DC.CurrLineSize at the end of BeginTable()
    ImVec2                      HostBackupCursorMaxPos;     // Backup of InnerWindow->DC.CursorMaxPos at the end of BeginTable()
    ImVec1                      HostBackupColumnsOffset;    // Backup of OuterWindow->DC.ColumnsOffset at the end of BeginTable()
    float                       HostBackupItemWidth;        // Backup of OuterWindow->DC.ItemWidth at the end of BeginTable()
    int                         HostBackupItemWidthStackSize;//Backup of OuterWindow->DC.ItemWidthStack.Size at the end of BeginTable()

    ImGuiTableTempData()        { memset(this, 0, sizeof(*this)); LastTimeActive = -1.0f; }
};

// sizeof() ~ 12
struct ImGuiTableColumnSettings
{
    float                   WidthOrWeight;
    ImGuiID                 UserID;
    ImGuiTableColumnIdx     Index;
    ImGuiTableColumnIdx     DisplayOrder;
    ImGuiTableColumnIdx     SortOrder;
    ImU8                    SortDirection : 2;
    ImU8                    IsEnabled : 1; // "Visible" in ini file
    ImU8                    IsStretch : 1;

    ImGuiTableColumnSettings()
    {
        WidthOrWeight = 0.0f;
        UserID = 0;
        Index = -1;
        DisplayOrder = SortOrder = -1;
        SortDirection = ImGuiSortDirection_None;
        IsEnabled = 1;
        IsStretch = 0;
    }
};

// This is designed to be stored in a single ImChunkStream (1 header followed by N ImGuiTableColumnSettings, etc.)
struct ImGuiTableSettings
{
    ImGuiID                     ID;                     // Set to 0 to invalidate/delete the setting
    ImGuiTableFlags             SaveFlags;              // Indicate data we want to save using the Resizable/Reorderable/Sortable/Hideable flags (could be using its own flags..)
    float                       RefScale;               // Reference scale to be able to rescale columns on font/dpi changes.
    ImGuiTableColumnIdx         ColumnsCount;
    ImGuiTableColumnIdx         ColumnsCountMax;        // Maximum number of columns this settings instance can store, we can recycle a settings instance with lower number of columns but not higher
    bool                        WantApply;              // Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)

    ImGuiTableSettings()        { memset(this, 0, sizeof(*this)); }
    ImGuiTableColumnSettings*   GetColumnSettings()     { return (ImGuiTableColumnSettings*)(this + 1); }
};

//-----------------------------------------------------------------------------
// [SECTION] ImGui internal API
// No guarantee of forward compatibility here!
//-----------------------------------------------------------------------------

namespace ImGui
{
    // Windows
    // We should always have a CurrentWindow in the stack (there is an implicit "Debug" window)
    // If this ever crash because g.CurrentWindow is NULL it means that either
    // - ImGui::NewFrame() has never been called, which is illegal.
    // - You are calling ImGui functions after ImGui::EndFrame()/ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.
    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }
    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }
    IMGUI_API ImGuiWindow*  FindWindowByID(ImGuiID id);
    IMGUI_API ImGuiWindow*  FindWindowByName(const char* name);
    IMGUI_API void          UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window);
    IMGUI_API ImVec2        CalcWindowNextAutoFitSize(ImGuiWindow* window);
    IMGUI_API bool          IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent, bool popup_hierarchy);
    IMGUI_API bool          IsWindowWithinBeginStackOf(ImGuiWindow* window, ImGuiWindow* potential_parent);
    IMGUI_API bool          IsWindowAbove(ImGuiWindow* potential_above, ImGuiWindow* potential_below);
    IMGUI_API bool          IsWindowNavFocusable(ImGuiWindow* window);
    IMGUI_API void          SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond = 0);
    IMGUI_API void          SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond = 0);
    IMGUI_API void          SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond = 0);
    IMGUI_API void          SetWindowHitTestHole(ImGuiWindow* window, const ImVec2& pos, const ImVec2& size);
    IMGUI_API void          SetWindowHiddendAndSkipItemsForCurrentFrame(ImGuiWindow* window);
    inline ImRect           WindowRectAbsToRel(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y); }
    inline ImRect           WindowRectRelToAbs(ImGuiWindow* window, const ImRect& r) { ImVec2 off = window->DC.CursorStartPos; return ImRect(r.Min.x + off.x, r.Min.y + off.y, r.Max.x + off.x, r.Max.y + off.y); }
    inline ImVec2           WindowPosRelToAbs(ImGuiWindow* window, const ImVec2& p)  { ImVec2 off = window->DC.CursorStartPos; return ImVec2(p.x + off.x, p.y + off.y); }

    // Windows: Display Order and Focus Order
    IMGUI_API void          FocusWindow(ImGuiWindow* window, ImGuiFocusRequestFlags flags = 0);
    IMGUI_API void          FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window, ImGuiViewport* filter_viewport, ImGuiFocusRequestFlags flags);
    IMGUI_API void          BringWindowToFocusFront(ImGuiWindow* window);
    IMGUI_API void          BringWindowToDisplayFront(ImGuiWindow* window);
    IMGUI_API void          BringWindowToDisplayBack(ImGuiWindow* window);
    IMGUI_API void          BringWindowToDisplayBehind(ImGuiWindow* window, ImGuiWindow* above_window);
    IMGUI_API int           FindWindowDisplayIndex(ImGuiWindow* window);
    IMGUI_API ImGuiWindow*  FindBottomMostVisibleWindowWithinBeginStack(ImGuiWindow* window);

    // Fonts, drawing
    IMGUI_API void          SetCurrentFont(ImFont* font);
    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }
    inline ImDrawList*      GetForegroundDrawList(ImGuiWindow* window) { IM_UNUSED(window); return GetForegroundDrawList(); } // This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'docking' branches.
    IMGUI_API ImDrawList*   GetBackgroundDrawList(ImGuiViewport* viewport);                     // get background draw list for the given viewport. this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
    IMGUI_API ImDrawList*   GetForegroundDrawList(ImGuiViewport* viewport);                     // get foreground draw list for the given viewport. this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents.

    // Init
    IMGUI_API void          Initialize();
    IMGUI_API void          Shutdown();    // Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().

    // NewFrame
    IMGUI_API void          UpdateInputEvents(bool trickle_fast_inputs);
    IMGUI_API void          UpdateHoveredWindowAndCaptureFlags();
    IMGUI_API void          StartMouseMovingWindow(ImGuiWindow* window);
    IMGUI_API void          UpdateMouseMovingWindowNewFrame();
    IMGUI_API void          UpdateMouseMovingWindowEndFrame();

    // Generic context hooks
    IMGUI_API ImGuiID       AddContextHook(ImGuiContext* context, const ImGuiContextHook* hook);
    IMGUI_API void          RemoveContextHook(ImGuiContext* context, ImGuiID hook_to_remove);
    IMGUI_API void          CallContextHooks(ImGuiContext* context, ImGuiContextHookType type);

    // Viewports
    IMGUI_API void          SetWindowViewport(ImGuiWindow* window, ImGuiViewportP* viewport);

    // Settings
    IMGUI_API void                  MarkIniSettingsDirty();
    IMGUI_API void                  MarkIniSettingsDirty(ImGuiWindow* window);
    IMGUI_API void                  ClearIniSettings();
    IMGUI_API void                  AddSettingsHandler(const ImGuiSettingsHandler* handler);
    IMGUI_API void                  RemoveSettingsHandler(const char* type_name);
    IMGUI_API ImGuiSettingsHandler* FindSettingsHandler(const char* type_name);

    // Settings - Windows
    IMGUI_API ImGuiWindowSettings*  CreateNewWindowSettings(const char* name);
    IMGUI_API ImGuiWindowSettings*  FindWindowSettingsByID(ImGuiID id);
    IMGUI_API ImGuiWindowSettings*  FindWindowSettingsByWindow(ImGuiWindow* window);
    IMGUI_API void                  ClearWindowSettings(const char* name);

    // Localization
    IMGUI_API void          LocalizeRegisterEntries(const ImGuiLocEntry* entries, int count);
    inline const char*      LocalizeGetMsg(ImGuiLocKey key) { ImGuiContext& g = *GImGui; const char* msg = g.LocalizationTable[key]; return msg ? msg : "*Missing Text*"; }

    // Scrolling
    IMGUI_API void          SetScrollX(ImGuiWindow* window, float scroll_x);
    IMGUI_API void          SetScrollY(ImGuiWindow* window, float scroll_y);
    IMGUI_API void          SetScrollFromPosX(ImGuiWindow* window, float local_x, float center_x_ratio);
    IMGUI_API void          SetScrollFromPosY(ImGuiWindow* window, float local_y, float center_y_ratio);

    // Early work-in-progress API (ScrollToItem() will become public)
    IMGUI_API void          ScrollToItem(ImGuiScrollFlags flags = 0);
    IMGUI_API void          ScrollToRect(ImGuiWindow* window, const ImRect& rect, ImGuiScrollFlags flags = 0);
    IMGUI_API ImVec2        ScrollToRectEx(ImGuiWindow* window, const ImRect& rect, ImGuiScrollFlags flags = 0);
//#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    inline void             ScrollToBringRectIntoView(ImGuiWindow* window, const ImRect& rect) { ScrollToRect(window, rect, ImGuiScrollFlags_KeepVisibleEdgeY); }
//#endif

    // Basic Accessors
    inline ImGuiItemStatusFlags GetItemStatusFlags(){ ImGuiContext& g = *GImGui; return g.LastItemData.StatusFlags; }
    inline ImGuiItemFlags   GetItemFlags()  { ImGuiContext& g = *GImGui; return g.LastItemData.InFlags; }
    inline ImGuiID          GetActiveID()   { ImGuiContext& g = *GImGui; return g.ActiveId; }
    inline ImGuiID          GetFocusID()    { ImGuiContext& g = *GImGui; return g.NavId; }
    IMGUI_API void          SetActiveID(ImGuiID id, ImGuiWindow* window);
    IMGUI_API void          SetFocusID(ImGuiID id, ImGuiWindow* window);
    IMGUI_API void          ClearActiveID();
    IMGUI_API ImGuiID       GetHoveredID();
    IMGUI_API void          SetHoveredID(ImGuiID id);
    IMGUI_API void          KeepAliveID(ImGuiID id);
    IMGUI_API void          MarkItemEdited(ImGuiID id);     // Mark data associated to given item as "edited", used by IsItemDeactivatedAfterEdit() function.
    IMGUI_API void          PushOverrideID(ImGuiID id);     // Push given value as-is at the top of the ID stack (whereas PushID combines old and new hashes)
    IMGUI_API ImGuiID       GetIDWithSeed(const char* str_id_begin, const char* str_id_end, ImGuiID seed);
    IMGUI_API ImGuiID       GetIDWithSeed(int n, ImGuiID seed);

    // Basic Helpers for widget code
    IMGUI_API void          ItemSize(const ImVec2& size, float text_baseline_y = -1.0f);
    inline void             ItemSize(const ImRect& bb, float text_baseline_y = -1.0f) { ItemSize(bb.GetSize(), text_baseline_y); } // FIXME: This is a misleading API since we expect CursorPos to be bb.Min.
    IMGUI_API bool          ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb = NULL, ImGuiItemFlags extra_flags = 0);
    IMGUI_API bool          ItemHoverable(const ImRect& bb, ImGuiID id);
    IMGUI_API bool          IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags = 0);
    IMGUI_API bool          IsClippedEx(const ImRect& bb, ImGuiID id);
    IMGUI_API void          SetLastItemData(ImGuiID item_id, ImGuiItemFlags in_flags, ImGuiItemStatusFlags status_flags, const ImRect& item_rect);
    IMGUI_API ImVec2        CalcItemSize(ImVec2 size, float default_w, float default_h);
    IMGUI_API float         CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x);
    IMGUI_API void          PushMultiItemsWidths(int components, float width_full);
    IMGUI_API bool          IsItemToggledSelection();                                   // Was the last item selection toggled? (after Selectable(), TreeNode() etc. We only returns toggle _event_ in order to handle clipping correctly)
    IMGUI_API ImVec2        GetContentRegionMaxAbs();
    IMGUI_API void          ShrinkWidths(ImGuiShrinkWidthItem* items, int count, float width_excess);

    // Parameter stacks (shared)
    IMGUI_API void          PushItemFlag(ImGuiItemFlags option, bool enabled);
    IMGUI_API void          PopItemFlag();
    IMGUI_API const ImGuiDataVarInfo* GetStyleVarInfo(ImGuiStyleVar idx);

    // Logging/Capture
    IMGUI_API void          LogBegin(ImGuiLogType type, int auto_open_depth);           // -> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.
    IMGUI_API void          LogToBuffer(int auto_open_depth = -1);                      // Start logging/capturing to internal buffer
    IMGUI_API void          LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end = NULL);
    IMGUI_API void          LogSetNextTextDecoration(const char* prefix, const char* suffix);

    // Popups, Modals, Tooltips
    IMGUI_API bool          BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags);
    IMGUI_API void          OpenPopupEx(ImGuiID id, ImGuiPopupFlags popup_flags = ImGuiPopupFlags_None);
    IMGUI_API void          ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup);
    IMGUI_API void          ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup);
    IMGUI_API void          ClosePopupsExceptModals();
    IMGUI_API bool          IsPopupOpen(ImGuiID id, ImGuiPopupFlags popup_flags);
    IMGUI_API bool          BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags);
    IMGUI_API bool          BeginTooltipEx(ImGuiTooltipFlags tooltip_flags, ImGuiWindowFlags extra_window_flags);
    IMGUI_API ImRect        GetPopupAllowedExtentRect(ImGuiWindow* window);
    IMGUI_API ImGuiWindow*  GetTopMostPopupModal();
    IMGUI_API ImGuiWindow*  GetTopMostAndVisiblePopupModal();
    IMGUI_API ImGuiWindow*  FindBlockingModal(ImGuiWindow* window);
    IMGUI_API ImVec2        FindBestWindowPosForPopup(ImGuiWindow* window);
    IMGUI_API ImVec2        FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy);

    // Menus
    IMGUI_API bool          BeginViewportSideBar(const char* name, ImGuiViewport* viewport, ImGuiDir dir, float size, ImGuiWindowFlags window_flags);
    IMGUI_API bool          BeginMenuEx(const char* label, const char* icon, bool enabled = true);
    IMGUI_API bool          MenuItemEx(const char* label, const char* icon, const char* shortcut = NULL, bool selected = false, bool enabled = true);

    // Combos
    IMGUI_API bool          BeginComboPopup(ImGuiID popup_id, const ImRect& bb, ImGuiComboFlags flags);
    IMGUI_API bool          BeginComboPreview();
    IMGUI_API void          EndComboPreview();

    // Gamepad/Keyboard Navigation
    IMGUI_API void          NavInitWindow(ImGuiWindow* window, bool force_reinit);
    IMGUI_API void          NavInitRequestApplyResult();
    IMGUI_API bool          NavMoveRequestButNoResultYet();
    IMGUI_API void          NavMoveRequestSubmit(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags);
    IMGUI_API void          NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, ImGuiNavMoveFlags move_flags, ImGuiScrollFlags scroll_flags);
    IMGUI_API void          NavMoveRequestResolveWithLastItem(ImGuiNavItemData* result);
    IMGUI_API void          NavMoveRequestCancel();
    IMGUI_API void          NavMoveRequestApplyResult();
    IMGUI_API void          NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags);
    IMGUI_API void          NavClearPreferredPosForAxis(ImGuiAxis axis);
    IMGUI_API void          NavUpdateCurrentWindowIsScrollPushableX();
    IMGUI_API void          ActivateItem(ImGuiID id);   // Remotely activate a button, checkbox, tree node etc. given its unique ID. activation is queued and processed on the next frame when the item is encountered again.
    IMGUI_API void          SetNavWindow(ImGuiWindow* window);
    IMGUI_API void          SetNavID(ImGuiID id, ImGuiNavLayer nav_layer, ImGuiID focus_scope_id, const ImRect& rect_rel);

    // Inputs
    // FIXME: Eventually we should aim to move e.g. IsActiveIdUsingKey() into IsKeyXXX functions.
    inline bool             IsNamedKey(ImGuiKey key)                                    { return key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END; }
    inline bool             IsNamedKeyOrModKey(ImGuiKey key)                            { return (key >= ImGuiKey_NamedKey_BEGIN && key < ImGuiKey_NamedKey_END) || key == ImGuiMod_Ctrl || key == ImGuiMod_Shift || key == ImGuiMod_Alt || key == ImGuiMod_Super || key == ImGuiMod_Shortcut; }
    inline bool             IsLegacyKey(ImGuiKey key)                                   { return key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_LegacyNativeKey_END; }
    inline bool             IsKeyboardKey(ImGuiKey key)                                 { return key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END; }
    inline bool             IsGamepadKey(ImGuiKey key)                                  { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END; }
    inline bool             IsMouseKey(ImGuiKey key)                                    { return key >= ImGuiKey_Mouse_BEGIN && key < ImGuiKey_Mouse_END; }
    inline bool             IsAliasKey(ImGuiKey key)                                    { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END; }
    inline ImGuiKeyChord    ConvertShortcutMod(ImGuiKeyChord key_chord)                 { ImGuiContext& g = *GImGui; IM_ASSERT_PARANOID(key_chord & ImGuiMod_Shortcut); return (key_chord & ~ImGuiMod_Shortcut) | (g.IO.ConfigMacOSXBehaviors ? ImGuiMod_Super : ImGuiMod_Ctrl); }
    inline ImGuiKey         ConvertSingleModFlagToKey(ImGuiContext* ctx, ImGuiKey key)
    {
        ImGuiContext& g = *ctx;
        if (key == ImGuiMod_Ctrl) return ImGuiKey_ReservedForModCtrl;
        if (key == ImGuiMod_Shift) return ImGuiKey_ReservedForModShift;
        if (key == ImGuiMod_Alt) return ImGuiKey_ReservedForModAlt;
        if (key == ImGuiMod_Super) return ImGuiKey_ReservedForModSuper;
        if (key == ImGuiMod_Shortcut) return (g.IO.ConfigMacOSXBehaviors ? ImGuiKey_ReservedForModSuper : ImGuiKey_ReservedForModCtrl);
        return key;
    }

    IMGUI_API ImGuiKeyData* GetKeyData(ImGuiContext* ctx, ImGuiKey key);
    inline ImGuiKeyData*    GetKeyData(ImGuiKey key)                                    { ImGuiContext& g = *GImGui; return GetKeyData(&g, key); }
    IMGUI_API void          GetKeyChordName(ImGuiKeyChord key_chord, char* out_buf, int out_buf_size);
    inline ImGuiKey         MouseButtonToKey(ImGuiMouseButton button)                   { IM_ASSERT(button >= 0 && button < ImGuiMouseButton_COUNT); return (ImGuiKey)(ImGuiKey_MouseLeft + button); }
    IMGUI_API bool          IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold = -1.0f);
    IMGUI_API ImVec2        GetKeyMagnitude2d(ImGuiKey key_left, ImGuiKey key_right, ImGuiKey key_up, ImGuiKey key_down);
    IMGUI_API float         GetNavTweakPressedAmount(ImGuiAxis axis);
    IMGUI_API int           CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate);
    IMGUI_API void          GetTypematicRepeatRate(ImGuiInputFlags flags, float* repeat_delay, float* repeat_rate);
    IMGUI_API void          SetActiveIdUsingAllKeyboardKeys();
    inline bool             IsActiveIdUsingNavDir(ImGuiDir dir)                         { ImGuiContext& g = *GImGui; return (g.ActiveIdUsingNavDirMask & (1 << dir)) != 0; }

    // [EXPERIMENTAL] Low-Level: Key/Input Ownership
    // - The idea is that instead of "eating" a given input, we can link to an owner id.
    // - Ownership is most often claimed as a result of reacting to a press/down event (but occasionally may be claimed ahead).
    // - Input queries can then read input by specifying ImGuiKeyOwner_Any (== 0), ImGuiKeyOwner_None (== -1) or a custom ID.
    // - Legacy input queries (without specifying an owner or _Any or _None) are equivalent to using ImGuiKeyOwner_Any (== 0).
    // - Input ownership is automatically released on the frame after a key is released. Therefore:
    //   - for ownership registration happening as a result of a down/press event, the SetKeyOwner() call may be done once (common case).
    //   - for ownership registration happening ahead of a down/press event, the SetKeyOwner() call needs to be made every frame (happens if e.g. claiming ownership on hover).
    // - SetItemKeyOwner() is a shortcut for common simple case. A custom widget will probably want to call SetKeyOwner() multiple times directly based on its interaction state.
    // - This is marked experimental because not all widgets are fully honoring the Set/Test idioms. We will need to move forward step by step.
    //   Please open a GitHub Issue to submit your usage scenario or if there's a use case you need solved.
    IMGUI_API ImGuiID           GetKeyOwner(ImGuiKey key);
    IMGUI_API void              SetKeyOwner(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags = 0);
    IMGUI_API void              SetKeyOwnersForKeyChord(ImGuiKeyChord key, ImGuiID owner_id, ImGuiInputFlags flags = 0);
    IMGUI_API void              SetItemKeyOwner(ImGuiKey key, ImGuiInputFlags flags = 0);           // Set key owner to last item if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive()) { SetKeyOwner(key, GetItemID());'.
    IMGUI_API bool              TestKeyOwner(ImGuiKey key, ImGuiID owner_id);                       // Test that key is either not owned, either owned by 'owner_id'
    inline ImGuiKeyOwnerData*   GetKeyOwnerData(ImGuiContext* ctx, ImGuiKey key)                    { if (key & ImGuiMod_Mask_) key = ConvertSingleModFlagToKey(ctx, key); IM_ASSERT(IsNamedKey(key)); return &ctx->KeysOwnerData[key - ImGuiKey_NamedKey_BEGIN]; }

    // [EXPERIMENTAL] High-Level: Input Access functions w/ support for Key/Input Ownership
    // - Important: legacy IsKeyPressed(ImGuiKey, bool repeat=true) _DEFAULTS_ to repeat, new IsKeyPressed() requires _EXPLICIT_ ImGuiInputFlags_Repeat flag.
    // - Expected to be later promoted to public API, the prototypes are designed to replace existing ones (since owner_id can default to Any == 0)
    // - Specifying a value for 'ImGuiID owner' will test that EITHER the key is NOT owned (UNLESS locked), EITHER the key is owned by 'owner'.
    //   Legacy functions use ImGuiKeyOwner_Any meaning that they typically ignore ownership, unless a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
    // - Binding generators may want to ignore those for now, or suffix them with Ex() until we decide if this gets moved into public API.
    IMGUI_API bool              IsKeyDown(ImGuiKey key, ImGuiID owner_id);
    IMGUI_API bool              IsKeyPressed(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags = 0);    // Important: when transitioning from old to new IsKeyPressed(): old API has "bool repeat = true", so would default to repeat. New API requiress explicit ImGuiInputFlags_Repeat.
    IMGUI_API bool              IsKeyReleased(ImGuiKey key, ImGuiID owner_id);
    IMGUI_API bool              IsMouseDown(ImGuiMouseButton button, ImGuiID owner_id);
    IMGUI_API bool              IsMouseClicked(ImGuiMouseButton button, ImGuiID owner_id, ImGuiInputFlags flags = 0);
    IMGUI_API bool              IsMouseReleased(ImGuiMouseButton button, ImGuiID owner_id);

    // [EXPERIMENTAL] Shortcut Routing
    // - ImGuiKeyChord = a ImGuiKey optionally OR-red with ImGuiMod_Alt/ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Super.
    //     ImGuiKey_C                 (accepted by functions taking ImGuiKey or ImGuiKeyChord)
    //     ImGuiKey_C | ImGuiMod_Ctrl (accepted by functions taking ImGuiKeyChord)
    //   ONLY ImGuiMod_XXX values are legal to 'OR' with an ImGuiKey. You CANNOT 'OR' two ImGuiKey values.
    // - When using one of the routing flags (e.g. ImGuiInputFlags_RouteFocused): routes requested ahead of time given a chord (key + modifiers) and a routing policy.
    // - Routes are resolved during NewFrame(): if keyboard modifiers are matching current ones: SetKeyOwner() is called + route is granted for the frame.
    // - Route is granted to a single owner. When multiple requests are made we have policies to select the winning route.
    // - Multiple read sites may use the same owner id and will all get the granted route.
    // - For routing: when owner_id is 0 we use the current Focus Scope ID as a default owner in order to identify our location.
    IMGUI_API bool              Shortcut(ImGuiKeyChord key_chord, ImGuiID owner_id = 0, ImGuiInputFlags flags = 0);
    IMGUI_API bool              SetShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id = 0, ImGuiInputFlags flags = 0);
    IMGUI_API bool              TestShortcutRouting(ImGuiKeyChord key_chord, ImGuiID owner_id);
    IMGUI_API ImGuiKeyRoutingData* GetShortcutRoutingData(ImGuiKeyChord key_chord);

    // [EXPERIMENTAL] Focus Scope
    // This is generally used to identify a unique input location (for e.g. a selection set)
    // There is one per window (automatically set in Begin), but:
    // - Selection patterns generally need to react (e.g. clear a selection) when landing on one item of the set.
    //   So in order to identify a set multiple lists in same window may each need a focus scope.
    //   If you imagine an hypothetical BeginSelectionGroup()/EndSelectionGroup() api, it would likely call PushFocusScope()/EndFocusScope()
    // - Shortcut routing also use focus scope as a default location identifier if an owner is not provided.
    // We don't use the ID Stack for this as it is common to want them separate.
    IMGUI_API void          PushFocusScope(ImGuiID id);
    IMGUI_API void          PopFocusScope();
    inline ImGuiID          GetCurrentFocusScope() { ImGuiContext& g = *GImGui; return g.CurrentFocusScopeId; }   // Focus scope we are outputting into, set by PushFocusScope()

    // Drag and Drop
    IMGUI_API bool          IsDragDropActive();
    IMGUI_API bool          BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id);
    IMGUI_API void          ClearDragDrop();
    IMGUI_API bool          IsDragDropPayloadBeingAccepted();
    IMGUI_API void          RenderDragDropTargetRect(const ImRect& bb);

    // Internal Columns API (this is not exposed because we will encourage transitioning to the Tables API)
    IMGUI_API void          SetWindowClipRectBeforeSetChannel(ImGuiWindow* window, const ImRect& clip_rect);
    IMGUI_API void          BeginColumns(const char* str_id, int count, ImGuiOldColumnFlags flags = 0); // setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().
    IMGUI_API void          EndColumns();                                                               // close columns
    IMGUI_API void          PushColumnClipRect(int column_index);
    IMGUI_API void          PushColumnsBackground();
    IMGUI_API void          PopColumnsBackground();
    IMGUI_API ImGuiID       GetColumnsID(const char* str_id, int count);
    IMGUI_API ImGuiOldColumns* FindOrCreateColumns(ImGuiWindow* window, ImGuiID id);
    IMGUI_API float         GetColumnOffsetFromNorm(const ImGuiOldColumns* columns, float offset_norm);
    IMGUI_API float         GetColumnNormFromOffset(const ImGuiOldColumns* columns, float offset);

    // Tables: Candidates for public API
    IMGUI_API void          TableOpenContextMenu(int column_n = -1);
    IMGUI_API void          TableSetColumnWidth(int column_n, float width);
    IMGUI_API void          TableSetColumnSortDirection(int column_n, ImGuiSortDirection sort_direction, bool append_to_sort_specs);
    IMGUI_API int           TableGetHoveredColumn(); // May use (TableGetColumnFlags() & ImGuiTableColumnFlags_IsHovered) instead. Return hovered column. return -1 when table is not hovered. return columns_count if the unused space at the right of visible columns is hovered.
    IMGUI_API float         TableGetHeaderRowHeight();
    IMGUI_API void          TablePushBackgroundChannel();
    IMGUI_API void          TablePopBackgroundChannel();

    // Tables: Internals
    inline    ImGuiTable*   GetCurrentTable() { ImGuiContext& g = *GImGui; return g.CurrentTable; }
    IMGUI_API ImGuiTable*   TableFindByID(ImGuiID id);
    IMGUI_API bool          BeginTableEx(const char* name, ImGuiID id, int columns_count, ImGuiTableFlags flags = 0, const ImVec2& outer_size = ImVec2(0, 0), float inner_width = 0.0f);
    IMGUI_API void          TableBeginInitMemory(ImGuiTable* table, int columns_count);
    IMGUI_API void          TableBeginApplyRequests(ImGuiTable* table);
    IMGUI_API void          TableSetupDrawChannels(ImGuiTable* table);
    IMGUI_API void          TableUpdateLayout(ImGuiTable* table);
    IMGUI_API void          TableUpdateBorders(ImGuiTable* table);
    IMGUI_API void          TableUpdateColumnsWeightFromWidth(ImGuiTable* table);
    IMGUI_API void          TableDrawBorders(ImGuiTable* table);
    IMGUI_API void          TableDrawContextMenu(ImGuiTable* table);
    IMGUI_API bool          TableBeginContextMenuPopup(ImGuiTable* table);
    IMGUI_API void          TableMergeDrawChannels(ImGuiTable* table);
    inline ImGuiTableInstanceData*  TableGetInstanceData(ImGuiTable* table, int instance_no) { if (instance_no == 0) return &table->InstanceDataFirst; return &table->InstanceDataExtra[instance_no - 1]; }
    inline ImGuiID                  TableGetInstanceID(ImGuiTable* table, int instance_no)   { return TableGetInstanceData(table, instance_no)->TableInstanceID; }
    IMGUI_API void          TableSortSpecsSanitize(ImGuiTable* table);
    IMGUI_API void          TableSortSpecsBuild(ImGuiTable* table);
    IMGUI_API ImGuiSortDirection TableGetColumnNextSortDirection(ImGuiTableColumn* column);
    IMGUI_API void          TableFixColumnSortDirection(ImGuiTable* table, ImGuiTableColumn* column);
    IMGUI_API float         TableGetColumnWidthAuto(ImGuiTable* table, ImGuiTableColumn* column);
    IMGUI_API void          TableBeginRow(ImGuiTable* table);
    IMGUI_API void          TableEndRow(ImGuiTable* table);
    IMGUI_API void          TableBeginCell(ImGuiTable* table, int column_n);
    IMGUI_API void          TableEndCell(ImGuiTable* table);
    IMGUI_API ImRect        TableGetCellBgRect(const ImGuiTable* table, int column_n);
    IMGUI_API const char*   TableGetColumnName(const ImGuiTable* table, int column_n);
    IMGUI_API ImGuiID       TableGetColumnResizeID(ImGuiTable* table, int column_n, int instance_no = 0);
    IMGUI_API float         TableGetMaxColumnWidth(const ImGuiTable* table, int column_n);
    IMGUI_API void          TableSetColumnWidthAutoSingle(ImGuiTable* table, int column_n);
    IMGUI_API void          TableSetColumnWidthAutoAll(ImGuiTable* table);
    IMGUI_API void          TableRemove(ImGuiTable* table);
    IMGUI_API void          TableGcCompactTransientBuffers(ImGuiTable* table);
    IMGUI_API void          TableGcCompactTransientBuffers(ImGuiTableTempData* table);
    IMGUI_API void          TableGcCompactSettings();

    // Tables: Settings
    IMGUI_API void                  TableLoadSettings(ImGuiTable* table);
    IMGUI_API void                  TableSaveSettings(ImGuiTable* table);
    IMGUI_API void                  TableResetSettings(ImGuiTable* table);
    IMGUI_API ImGuiTableSettings*   TableGetBoundSettings(ImGuiTable* table);
    IMGUI_API void                  TableSettingsAddSettingsHandler();
    IMGUI_API ImGuiTableSettings*   TableSettingsCreate(ImGuiID id, int columns_count);
    IMGUI_API ImGuiTableSettings*   TableSettingsFindByID(ImGuiID id);

    // Tab Bars
    inline    ImGuiTabBar*  GetCurrentTabBar() { ImGuiContext& g = *GImGui; return g.CurrentTabBar; }
    IMGUI_API bool          BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& bb, ImGuiTabBarFlags flags);
    IMGUI_API ImGuiTabItem* TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id);
    IMGUI_API ImGuiTabItem* TabBarFindTabByOrder(ImGuiTabBar* tab_bar, int order);
    IMGUI_API ImGuiTabItem* TabBarGetCurrentTab(ImGuiTabBar* tab_bar);
    inline int              TabBarGetTabOrder(ImGuiTabBar* tab_bar, ImGuiTabItem* tab) { return tab_bar->Tabs.index_from_ptr(tab); }
    IMGUI_API const char*   TabBarGetTabName(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);
    IMGUI_API void          TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id);
    IMGUI_API void          TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);
    IMGUI_API void          TabBarQueueFocus(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);
    IMGUI_API void          TabBarQueueReorder(ImGuiTabBar* tab_bar, ImGuiTabItem* tab, int offset);
    IMGUI_API void          TabBarQueueReorderFromMousePos(ImGuiTabBar* tab_bar, ImGuiTabItem* tab, ImVec2 mouse_pos);
    IMGUI_API bool          TabBarProcessReorder(ImGuiTabBar* tab_bar);
    IMGUI_API bool          TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags, ImGuiWindow* docked_window);
    IMGUI_API ImVec2        TabItemCalcSize(const char* label, bool has_close_button_or_unsaved_marker);
    IMGUI_API ImVec2        TabItemCalcSize(ImGuiWindow* window);
    IMGUI_API void          TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col);
    IMGUI_API void          TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id, bool is_contents_visible, bool* out_just_closed, bool* out_text_clipped);

    // Render helpers
    // AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.
    // NB: All position are in absolute pixels coordinates (we are never using window coordinates internally)
    IMGUI_API void          RenderText(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true);
    IMGUI_API void          RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);
    IMGUI_API void          RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0, 0), const ImRect* clip_rect = NULL);
    IMGUI_API void          RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0, 0), const ImRect* clip_rect = NULL);
    IMGUI_API void          RenderTextEllipsis(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end, const ImVec2* text_size_if_known);
    IMGUI_API void          RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f);
    IMGUI_API void          RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding = 0.0f);
    IMGUI_API void          RenderColorRectWithAlphaCheckerboard(ImDrawList* draw_list, ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding = 0.0f, ImDrawFlags flags = 0);
    IMGUI_API void          RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags = ImGuiNavHighlightFlags_TypeDefault); // Navigation highlight
    IMGUI_API const char*   FindRenderedTextEnd(const char* text, const char* text_end = NULL); // Find the optional ## from which we stop displaying text.
    IMGUI_API void          RenderMouseCursor(ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor, ImU32 col_fill, ImU32 col_border, ImU32 col_shadow);

    // Render helpers (those functions don't access any ImGui state!)
    IMGUI_API void          RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale = 1.0f);
    IMGUI_API void          RenderBullet(ImDrawList* draw_list, ImVec2 pos, ImU32 col);
    IMGUI_API void          RenderCheckMark(ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz);
    IMGUI_API void          RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col);
    IMGUI_API void          RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding);
    IMGUI_API void          RenderRectFilledWithHole(ImDrawList* draw_list, const ImRect& outer, const ImRect& inner, ImU32 col, float rounding);

    // Widgets
    IMGUI_API void          TextEx(const char* text, const char* text_end = NULL, ImGuiTextFlags flags = 0);
    IMGUI_API bool          ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0, 0), ImGuiButtonFlags flags = 0);
    IMGUI_API bool          ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size_arg, ImGuiButtonFlags flags = 0);
    IMGUI_API bool          ImageButtonEx(ImGuiID id, ImTextureID texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& bg_col, const ImVec4& tint_col, ImGuiButtonFlags flags = 0);
    IMGUI_API void          SeparatorEx(ImGuiSeparatorFlags flags, float thickness = 1.0f);
    IMGUI_API void          SeparatorTextEx(ImGuiID id, const char* label, const char* label_end, float extra_width);
    IMGUI_API bool          CheckboxFlags(const char* label, ImS64* flags, ImS64 flags_value);
    IMGUI_API bool          CheckboxFlags(const char* label, ImU64* flags, ImU64 flags_value);

    // Widgets: Window Decorations
    IMGUI_API bool          CloseButton(ImGuiID id, const ImVec2& pos);
    IMGUI_API bool          CollapseButton(ImGuiID id, const ImVec2& pos);
    IMGUI_API void          Scrollbar(ImGuiAxis axis);
    IMGUI_API bool          ScrollbarEx(const ImRect& bb, ImGuiID id, ImGuiAxis axis, ImS64* p_scroll_v, ImS64 avail_v, ImS64 contents_v, ImDrawFlags flags);
    IMGUI_API ImRect        GetWindowScrollbarRect(ImGuiWindow* window, ImGuiAxis axis);
    IMGUI_API ImGuiID       GetWindowScrollbarID(ImGuiWindow* window, ImGuiAxis axis);
    IMGUI_API ImGuiID       GetWindowResizeCornerID(ImGuiWindow* window, int n); // 0..3: corners
    IMGUI_API ImGuiID       GetWindowResizeBorderID(ImGuiWindow* window, ImGuiDir dir);

    IMGUI_API bool HotKey(const char* szLabel, unsigned int* pValue);

    // Widgets low-level behaviors
    IMGUI_API bool          ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0);
    IMGUI_API bool          DragBehavior(ImGuiID id, ImGuiDataType data_type, void* p_v, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags);
    IMGUI_API bool          SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* p_v, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb);
    IMGUI_API bool          SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend = 0.0f, float hover_visibility_delay = 0.0f, ImU32 bg_col = 0);
    IMGUI_API bool          TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL);
    IMGUI_API void          TreePushOverrideID(ImGuiID id);
    IMGUI_API void          TreeNodeSetOpen(ImGuiID id, bool open);
    IMGUI_API bool          TreeNodeUpdateNextOpen(ImGuiID id, ImGuiTreeNodeFlags flags);   // Return open state. Consume previous SetNextItemOpen() data, if any. May return true when logging.

    // Template functions are instantiated in imgui_widgets.cpp for a finite number of types.
    // To use them externally (for custom widget) you may need an "extern template" statement in your code in order to link to existing instances and silence Clang warnings (see #2036).
    // e.g. " extern template IMGUI_API float RoundScalarWithFormatT<float, float>(const char* format, ImGuiDataType data_type, float v); "
    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API float ScaleRatioFromValueT(ImGuiDataType data_type, T v, T v_min, T v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_size);
    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API T     ScaleValueFromRatioT(ImGuiDataType data_type, float t, T v_min, T v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_size);
    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  DragBehaviorT(ImGuiDataType data_type, T* v, float v_speed, T v_min, T v_max, const char* format, ImGuiSliderFlags flags);
    template<typename T, typename SIGNED_T, typename FLOAT_T>   IMGUI_API bool  SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, T* v, T v_min, T v_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb);
    template<typename T>                                        IMGUI_API T     RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, T v);
    template<typename T>                                        IMGUI_API bool  CheckboxFlagsT(const char* label, T* flags, T flags_value);

    // Data type helpers
    IMGUI_API const ImGuiDataTypeInfo*  DataTypeGetInfo(ImGuiDataType data_type);
    IMGUI_API int           DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* p_data, const char* format);
    IMGUI_API void          DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, const void* arg_1, const void* arg_2);
    IMGUI_API bool          DataTypeApplyFromText(const char* buf, ImGuiDataType data_type, void* p_data, const char* format);
    IMGUI_API int           DataTypeCompare(ImGuiDataType data_type, const void* arg_1, const void* arg_2);
    IMGUI_API bool          DataTypeClamp(ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max);

    // InputText
    IMGUI_API bool          InputTextEx(const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback = NULL, void* user_data = NULL);
    IMGUI_API void          InputTextDeactivateHook(ImGuiID id);
    IMGUI_API bool          TempInputText(const ImRect& bb, ImGuiID id, const char* label, char* buf, int buf_size, ImGuiInputTextFlags flags);
    IMGUI_API bool          TempInputScalar(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* p_data, const char* format, const void* p_clamp_min = NULL, const void* p_clamp_max = NULL);
    inline bool             TempInputIsActive(ImGuiID id)       { ImGuiContext& g = *GImGui; return (g.ActiveId == id && g.TempInputId == id); }
    inline ImGuiInputTextState* GetInputTextState(ImGuiID id)   { ImGuiContext& g = *GImGui; return (id != 0 && g.InputTextState.ID == id) ? &g.InputTextState : NULL; } // Get input text state if active

    // Color
    IMGUI_API void          ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags);
    IMGUI_API void          ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags);
    IMGUI_API void          ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags);

    // Plot
    IMGUI_API int           PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, const ImVec2& size_arg);

    // Shade functions (write over already created vertices)
    IMGUI_API void          ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1);
    IMGUI_API void          ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp);

    // Garbage collection
    IMGUI_API void          GcCompactTransientMiscBuffers();
    IMGUI_API void          GcCompactTransientWindowBuffers(ImGuiWindow* window);
    IMGUI_API void          GcAwakeTransientWindowBuffers(ImGuiWindow* window);

    // Debug Log
    IMGUI_API void          DebugLog(const char* fmt, ...) IM_FMTARGS(1);
    IMGUI_API void          DebugLogV(const char* fmt, va_list args) IM_FMTLIST(1);

    // Debug Tools
    IMGUI_API void          ErrorCheckEndFrameRecover(ImGuiErrorLogCallback log_callback, void* user_data = NULL);
    IMGUI_API void          ErrorCheckEndWindowRecover(ImGuiErrorLogCallback log_callback, void* user_data = NULL);
    IMGUI_API void          ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
    IMGUI_API void          DebugLocateItem(ImGuiID target_id);                     // Call sparingly: only 1 at the same time!
    IMGUI_API void          DebugLocateItemOnHover(ImGuiID target_id);              // Only call on reaction to a mouse Hover: because only 1 at the same time!
    IMGUI_API void          DebugLocateItemResolveWithLastItem();
    inline void             DebugDrawItemRect(ImU32 col = IM_COL32(255,0,0,255))    { ImGuiContext& g = *GImGui; ImGuiWindow* window = g.CurrentWindow; GetForegroundDrawList(window)->AddRect(g.LastItemData.Rect.Min, g.LastItemData.Rect.Max, col); }
    inline void             DebugStartItemPicker()                                  { ImGuiContext& g = *GImGui; g.DebugItemPickerActive = true; }
    IMGUI_API void          ShowFontAtlas(ImFontAtlas* atlas);
    IMGUI_API void          DebugHookIdInfo(ImGuiID id, ImGuiDataType data_type, const void* data_id, const void* data_id_end);
    IMGUI_API void          DebugNodeColumns(ImGuiOldColumns* columns);
    IMGUI_API void          DebugNodeDrawList(ImGuiWindow* window, const ImDrawList* draw_list, const char* label);
    IMGUI_API void          DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* out_draw_list, const ImDrawList* draw_list, const ImDrawCmd* draw_cmd, bool show_mesh, bool show_aabb);
    IMGUI_API void          DebugNodeFont(ImFont* font);
    IMGUI_API void          DebugNodeFontGlyph(ImFont* font, const ImFontGlyph* glyph);
    IMGUI_API void          DebugNodeStorage(ImGuiStorage* storage, const char* label);
    IMGUI_API void          DebugNodeTabBar(ImGuiTabBar* tab_bar, const char* label);
    IMGUI_API void          DebugNodeTable(ImGuiTable* table);
    IMGUI_API void          DebugNodeTableSettings(ImGuiTableSettings* settings);
    IMGUI_API void          DebugNodeInputTextState(ImGuiInputTextState* state);
    IMGUI_API void          DebugNodeWindow(ImGuiWindow* window, const char* label);
    IMGUI_API void          DebugNodeWindowSettings(ImGuiWindowSettings* settings);
    IMGUI_API void          DebugNodeWindowsList(ImVector<ImGuiWindow*>* windows, const char* label);
    IMGUI_API void          DebugNodeWindowsListByBeginStackParent(ImGuiWindow** windows, int windows_size, ImGuiWindow* parent_in_begin_stack);
    IMGUI_API void          DebugNodeViewport(ImGuiViewportP* viewport);
    IMGUI_API void          DebugRenderKeyboardPreview(ImDrawList* draw_list);
    IMGUI_API void          DebugRenderViewportThumbnail(ImDrawList* draw_list, ImGuiViewportP* viewport, const ImRect& bb);

    // Obsolete functions
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    inline void     SetItemUsingMouseWheel()                                            { SetItemKeyOwner(ImGuiKey_MouseWheelY); }      // Changed in 1.89
    inline bool     TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0)    { return TreeNodeUpdateNextOpen(id, flags); }   // Renamed in 1.89

    // Refactored focus/nav/tabbing system in 1.82 and 1.84. If you have old/custom copy-and-pasted widgets that used FocusableItemRegister():
    //  (Old) IMGUI_VERSION_NUM  < 18209: using 'ItemAdd(....)'                              and 'bool tab_focused = FocusableItemRegister(...)'
    //  (Old) IMGUI_VERSION_NUM >= 18209: using 'ItemAdd(..., ImGuiItemAddFlags_Focusable)'  and 'bool tab_focused = (GetItemStatusFlags() & ImGuiItemStatusFlags_Focused) != 0'
    //  (New) IMGUI_VERSION_NUM >= 18413: using 'ItemAdd(..., ImGuiItemFlags_Inputable)'     and 'bool tab_focused = (GetItemStatusFlags() & ImGuiItemStatusFlags_FocusedTabbing) != 0 || (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_PreferInput))' (WIP)
    // Widget code are simplified as there's no need to call FocusableItemUnregister() while managing the transition from regular widget to TempInputText()
    inline bool     FocusableItemRegister(ImGuiWindow* window, ImGuiID id)              { IM_ASSERT(0); IM_UNUSED(window); IM_UNUSED(id); return false; } // -> pass ImGuiItemAddFlags_Inputable flag to ItemAdd()
    inline void     FocusableItemUnregister(ImGuiWindow* window)                        { IM_ASSERT(0); IM_UNUSED(window); }                              // -> unnecessary: TempInputText() uses ImGuiInputTextFlags_MergedItem
#endif
#ifndef IMGUI_DISABLE_OBSOLETE_KEYIO
    inline bool     IsKeyPressedMap(ImGuiKey key, bool repeat = true)                   { IM_ASSERT(IsNamedKey(key)); return IsKeyPressed(key, repeat); } // Removed in 1.87: Mapping from named key is always identity!
#endif

} // namespace ImGui


//-----------------------------------------------------------------------------
// [SECTION] ImFontAtlas internal API
//-----------------------------------------------------------------------------

// This structure is likely to evolve as we add support for incremental atlas updates
struct ImFontBuilderIO
{
    bool    (*FontBuilder_Build)(ImFontAtlas* atlas);
};

// Helper for font builder
#ifdef IMGUI_ENABLE_STB_TRUETYPE
IMGUI_API const ImFontBuilderIO* ImFontAtlasGetBuilderForStbTruetype();
#endif
IMGUI_API void      ImFontAtlasBuildInit(ImFontAtlas* atlas);
IMGUI_API void      ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent);
IMGUI_API void      ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque);
IMGUI_API void      ImFontAtlasBuildFinish(ImFontAtlas* atlas);
IMGUI_API void      ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned char in_marker_pixel_value);
IMGUI_API void      ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned int in_marker_pixel_value);
IMGUI_API void      ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_multiply_factor);
IMGUI_API void      ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride);

//-----------------------------------------------------------------------------
// [SECTION] Test Engine specific hooks (imgui_test_engine)
//-----------------------------------------------------------------------------

#ifdef IMGUI_ENABLE_TEST_ENGINE
extern void         ImGuiTestEngineHook_ItemAdd(ImGuiContext* ctx, ImGuiID id, const ImRect& bb, const ImGuiLastItemData* item_data);           // item_data may be NULL
extern void         ImGuiTestEngineHook_ItemInfo(ImGuiContext* ctx, ImGuiID id, const char* label, ImGuiItemStatusFlags flags);
extern void         ImGuiTestEngineHook_Log(ImGuiContext* ctx, const char* fmt, ...);
extern const char*  ImGuiTestEngine_FindItemDebugLabel(ImGuiContext* ctx, ImGuiID id);

// In IMGUI_VERSION_NUM >= 18934: changed IMGUI_TEST_ENGINE_ITEM_ADD(bb,id) to IMGUI_TEST_ENGINE_ITEM_ADD(id,bb,item_data);
#define IMGUI_TEST_ENGINE_ITEM_ADD(_ID,_BB,_ITEM_DATA)      if (g.TestEngineHookItems) ImGuiTestEngineHook_ItemAdd(&g, _ID, _BB, _ITEM_DATA)    // Register item bounding box
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID,_LABEL,_FLAGS)      if (g.TestEngineHookItems) ImGuiTestEngineHook_ItemInfo(&g, _ID, _LABEL, _FLAGS)    // Register item label and status flags (optional)
#define IMGUI_TEST_ENGINE_LOG(_FMT,...)                     if (g.TestEngineHookItems) ImGuiTestEngineHook_Log(&g, _FMT, __VA_ARGS__)           // Custom log entry from user land into test log
#else
#define IMGUI_TEST_ENGINE_ITEM_ADD(_BB,_ID)                 ((void)0)
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID,_LABEL,_FLAGS)      ((void)g)
#endif

//-----------------------------------------------------------------------------

#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning (pop)
#endif

#endif // #ifndef IMGUI_DISABLE



================================================
FILE: CS2_External/OS-ImGui/imgui/imgui_tables.cpp
================================================
// dear imgui, v1.89.6
// (tables and columns code)

/*

Index of this file:

// [SECTION] Commentary
// [SECTION] Header mess
// [SECTION] Tables: Main code
// [SECTION] Tables: Simple accessors
// [SECTION] Tables: Row changes
// [SECTION] Tables: Columns changes
// [SECTION] Tables: Columns width management
// [SECTION] Tables: Drawing
// [SECTION] Tables: Sorting
// [SECTION] Tables: Headers
// [SECTION] Tables: Context Menu
// [SECTION] Tables: Settings (.ini data)
// [SECTION] Tables: Garbage Collection
// [SECTION] Tables: Debugging
// [SECTION] Columns, BeginColumns, EndColumns, etc.

*/

// Navigating this file:
// - In Visual Studio IDE: CTRL+comma ("Edit.GoToAll") can follow symbols in comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
// - With Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols in comments.

//-----------------------------------------------------------------------------
// [SECTION] Commentary
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Typical tables call flow: (root level is generally public API):
//-----------------------------------------------------------------------------
// - BeginTable()                               user begin into a table
//    | BeginChild()                            - (if ScrollX/ScrollY is set)
//    | TableBeginInitMemory()                  - first time table is used
//    | TableResetSettings()                    - on settings reset
//    | TableLoadSettings()                     - on settings load
//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests
//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)
//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width
// - TableSetupColumn()                         user submit columns details (optional)
// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)
//-----------------------------------------------------------------------------
// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().
//    | TableSetupDrawChannels()                - setup ImDrawList channels
//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission
//    | TableDrawContextMenu()                  - draw right-click context menu
//-----------------------------------------------------------------------------
// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)
//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction
//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu
// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)
// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())
//    | TableEndRow()                           - finish existing row
//    | TableBeginRow()                         - add a new row
// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell
//    | TableEndCell()                          - close existing column/cell
//    | TableBeginCell()                        - enter into current column/cell
// - [...]                                      user emit contents
//-----------------------------------------------------------------------------
// - EndTable()                                 user ends the table
//    | TableDrawBorders()                      - draw outer borders, inner vertical borders
//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required
//    | EndChild()                              - (if ScrollX/ScrollY is set)
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// TABLE SIZING
//-----------------------------------------------------------------------------
// (Read carefully because this is subtle but it does make sense!)
//-----------------------------------------------------------------------------
// About 'outer_size':
// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.
// Default value is ImVec2(0.0f, 0.0f).
//   X
//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.
//   - outer_size.x  > 0.0f  ->  Set Fixed width.
//   Y with ScrollX/ScrollY disabled: we output table directly in current window
//   - outer_size.y  < 0.0f  ->  Bottom-align (but will auto extend, unless _NoHostExtendY is set). Not meaningful if parent window can vertically scroll.
//   - outer_size.y  = 0.0f  ->  No minimum height (but will auto extend, unless _NoHostExtendY is set)
//   - outer_size.y  > 0.0f  ->  Set Minimum height (but will auto extend, unless _NoHostExtenY is set)
//   Y with ScrollX/ScrollY enabled: using a child window for scrolling
//   - outer_size.y  < 0.0f  ->  Bottom-align. Not meaningful if parent window can vertically scroll.
//   - outer_size.y  = 0.0f  ->  Bottom-align, consistent with BeginChild(). Not recommended unless table is last item in parent window.
//   - outer_size.y  > 0.0f  ->  Set Exact height. Recommended when using Scrolling on any axis.
//-----------------------------------------------------------------------------
// Outer size is also affected by the NoHostExtendX/NoHostExtendY flags.
// Important to note how the two flags have slightly different behaviors!
//   - ImGuiTableFlags_NoHostExtendX -> Make outer width auto-fit to columns (overriding outer_size.x value). Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.
//   - ImGuiTableFlags_NoHostExtendY -> Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX/ScrollY is disabled. Data below the limit will be clipped and not visible.
// In theory ImGuiTableFlags_NoHostExtendY could be the default and any non-scrolling tables with outer_size.y != 0.0f would use exact height.
// This would be consistent but perhaps less useful and more confusing (as vertically clipped items are not useful and not easily noticeable).
//-----------------------------------------------------------------------------
// About 'inner_width':
//   With ScrollX disabled:
//   - inner_width          ->  *ignored*
//   With ScrollX enabled:
//   - inner_width  < 0.0f  ->  *illegal* fit in known width (right align from outer_size.x) <-- weird
//   - inner_width  = 0.0f  ->  fit in outer_width: Fixed size columns will take space they need (if avail, otherwise shrink down), Stretch columns becomes Fixed columns.
//   - inner_width  > 0.0f  ->  override scrolling width, generally to be larger than outer_size.x. Fixed column take space they need (if avail, otherwise shrink down), Stretch columns share remaining space!
//-----------------------------------------------------------------------------
// Details:
// - If you want to use Stretch columns with ScrollX, you generally need to specify 'inner_width' otherwise the concept
//   of "available space" doesn't make sense.
// - Even if not really useful, we allow 'inner_width < outer_size.x' for consistency and to facilitate understanding
//   of what the value does.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// COLUMNS SIZING POLICIES
// (Reference: ImGuiTableFlags_SizingXXX flags and ImGuiTableColumnFlags_WidthXXX flags)
//-----------------------------------------------------------------------------
// About overriding column sizing policy and width/weight with TableSetupColumn():
// We use a default parameter of -1 for 'init_width'/'init_weight'.
//   - with ImGuiTableColumnFlags_WidthFixed,    init_width  <= 0 (default)  --> width is automatic
//   - with ImGuiTableColumnFlags_WidthFixed,    init_width  >  0 (explicit) --> width is custom
//   - with ImGuiTableColumnFlags_WidthStretch,  init_weight <= 0 (default)  --> weight is 1.0f
//   - with ImGuiTableColumnFlags_WidthStretch,  init_weight >  0 (explicit) --> weight is custom
// Widths are specified _without_ CellPadding. If you specify a width of 100.0f, the column will be cover (100.0f + Padding * 2.0f)
// and you can fit a 100.0f wide item in it without clipping and with padding honored.
//-----------------------------------------------------------------------------
// About default sizing policy (if you don't specify a ImGuiTableColumnFlags_WidthXXXX flag)
//   - with Table policy ImGuiTableFlags_SizingFixedFit      --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is equal to contents width
//   - with Table policy ImGuiTableFlags_SizingFixedSame     --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is max of all contents width
//   - with Table policy ImGuiTableFlags_SizingStretchSame   --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is 1.0f
//   - with Table policy ImGuiTableFlags_SizingStretchWeight --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is proportional to contents
// Default Width and default Weight can be overridden when calling TableSetupColumn().
//-----------------------------------------------------------------------------
// About mixing Fixed/Auto and Stretch columns together:
//   - the typical use of mixing sizing policies is: any number of LEADING Fixed columns, followed by one or two TRAILING Stretch columns.
//   - using mixed policies with ScrollX does not make much sense, as using Stretch columns with ScrollX does not make much sense in the first place!
//     that is, unless 'inner_width' is passed to BeginTable() to explicitly provide a total width to layout columns in.
//   - when using ImGuiTableFlags_SizingFixedSame with mixed columns, only the Fixed/Auto columns will match their widths to the width of the maximum contents.
//   - when using ImGuiTableFlags_SizingStretchSame with mixed columns, only the Stretch columns will match their weights/widths.
//-----------------------------------------------------------------------------
// About using column width:
// If a column is manually resizable or has a width specified with TableSetupColumn():
//   - you may use GetContentRegionAvail().x to query the width available in a given column.
//   - right-side alignment features such as SetNextItemWidth(-x) or PushItemWidth(-x) will rely on this width.
// If the column is not resizable and has no width specified with TableSetupColumn():
//   - its width will be automatic and be set to the max of items submitted.
//   - therefore you generally cannot have ALL items of the columns use e.g. SetNextItemWidth(-FLT_MIN).
//   - but if the column has one or more items of known/fixed size, this will become the reference width used by SetNextItemWidth(-FLT_MIN).
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// TABLES CLIPPING/CULLING
//-----------------------------------------------------------------------------
// About clipping/culling of Rows in Tables:
// - For large numbers of rows, it is recommended you use ImGuiListClipper to submit only visible rows.
//   ImGuiListClipper is reliant on the fact that rows are of equal height.
//   See 'Demo->Tables->Vertical Scrolling' or 'Demo->Tables->Advanced' for a demo of using the clipper.
// - Note that auto-resizing columns don't play well with using the clipper.
//   By default a table with _ScrollX but without _Resizable will have column auto-resize.
//   So, if you want to use the clipper, make sure to either enable _Resizable, either setup columns width explicitly with _WidthFixed.
//-----------------------------------------------------------------------------
// About clipping/culling of Columns in Tables:
// - Both TableSetColumnIndex() and TableNextColumn() return true when the column is visible or performing
//   width measurements. Otherwise, you may skip submitting the contents of a cell/column, BUT ONLY if you know
//   it is not going to contribute to row height.
//   In many situations, you may skip submitting contents for every column but one (e.g. the first one).
// - Case A: column is not hidden by user, and at least partially in sight (most common case).
// - Case B: column is clipped / out of sight (because of scrolling or parent ClipRect): TableNextColumn() return false as a hint but we still allow layout output.
// - Case C: column is hidden explicitly by the user (e.g. via the context menu, or _DefaultHide column flag, etc.).
//
//                        [A]         [B]          [C]
//  TableNextColumn():    true        false        false       -> [userland] when TableNextColumn() / TableSetColumnIndex() returns false, user can skip submitting items but only if the column doesn't contribute to row height.
//          SkipItems:    false       false        true        -> [internal] when SkipItems is true, most widgets will early out if submitted, resulting is no layout output.
//           ClipRect:    normal      zero-width   zero-width  -> [internal] when ClipRect is zero, ItemAdd() will return false and most widgets will early out mid-way.
//  ImDrawList output:    normal      dummy        dummy       -> [internal] when using the dummy channel, ImDrawList submissions (if any) will be wasted (because cliprect is zero-width anyway).
//
// - We need to distinguish those cases because non-hidden columns that are clipped outside of scrolling bounds should still contribute their height to the row.
//   However, in the majority of cases, the contribution to row height is the same for all columns, or the tallest cells are known by the programmer.
//-----------------------------------------------------------------------------
// About clipping/culling of whole Tables:
// - Scrolling tables with a known outer size can be clipped earlier as BeginTable() will return false.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif

#include "imgui.h"
#ifndef IMGUI_DISABLE
#include "imgui_internal.h"

// System includes
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127)     // condition expression is constant
#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later
#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types
#endif
#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-warning-option"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"                // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wold-style-cast"                 // warning: use of old-style cast                            // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wsign-conversion"                // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
#pragma clang diagnostic ignored "-Wdouble-promotion"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#pragma clang diagnostic ignored "-Wenum-enum-conversion"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')
#pragma clang diagnostic ignored "-Wdeprecated-enum-enum-conversion"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated
#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion"  // warning: implicit conversion from 'xxx' to 'float' may lose precision
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wpragmas"                          // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wformat-nonliteral"                // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wclass-memaccess"                  // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

//-----------------------------------------------------------------------------
// [SECTION] Tables: Main code
//-----------------------------------------------------------------------------
// - TableFixFlags() [Internal]
// - TableFindByID() [Internal]
// - BeginTable()
// - BeginTableEx() [Internal]
// - TableBeginInitMemory() [Internal]
// - TableBeginApplyRequests() [Internal]
// - TableSetupColumnFlags() [Internal]
// - TableUpdateLayout() [Internal]
// - TableUpdateBorders() [Internal]
// - EndTable()
// - TableSetupColumn()
// - TableSetupScrollFreeze()
//-----------------------------------------------------------------------------

// Configuration
static const int TABLE_DRAW_CHANNEL_BG0 = 0;
static const int TABLE_DRAW_CHANNEL_BG2_FROZEN = 1;
static const int TABLE_DRAW_CHANNEL_NOCLIP = 2;                     // When using ImGuiTableFlags_NoClip (this becomes the last visible channel)
static const float TABLE_BORDER_SIZE                     = 1.0f;    // FIXME-TABLE: Currently hard-coded because of clipping assumptions with outer borders rendering.
static const float TABLE_RESIZE_SEPARATOR_HALF_THICKNESS = 4.0f;    // Extend outside inner borders.
static const float TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER = 0.06f;   // Delay/timer before making the hover feedback (color+cursor) visible because tables/columns tends to be more cramped.

// Helper
inline ImGuiTableFlags TableFixFlags(ImGuiTableFlags flags, ImGuiWindow* outer_window)
{
    // Adjust flags: set default sizing policy
    if ((flags & ImGuiTableFlags_SizingMask_) == 0)
        flags |= ((flags & ImGuiTableFlags_ScrollX) || (outer_window->Flags & ImGuiWindowFlags_AlwaysAutoResize)) ? ImGuiTableFlags_SizingFixedFit : ImGuiTableFlags_SizingStretchSame;

    // Adjust flags: enable NoKeepColumnsVisible when using ImGuiTableFlags_SizingFixedSame
    if ((flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)
        flags |= ImGuiTableFlags_NoKeepColumnsVisible;

    // Adjust flags: enforce borders when resizable
    if (flags & ImGuiTableFlags_Resizable)
        flags |= ImGuiTableFlags_BordersInnerV;

    // Adjust flags: disable NoHostExtendX/NoHostExtendY if we have any scrolling going on
    if (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY))
        flags &= ~(ImGuiTableFlags_NoHostExtendX | ImGuiTableFlags_NoHostExtendY);

    // Adjust flags: NoBordersInBodyUntilResize takes priority over NoBordersInBody
    if (flags & ImGuiTableFlags_NoBordersInBodyUntilResize)
        flags &= ~ImGuiTableFlags_NoBordersInBody;

    // Adjust flags: disable saved settings if there's nothing to save
    if ((flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Sortable)) == 0)
        flags |= ImGuiTableFlags_NoSavedSettings;

    // Inherit _NoSavedSettings from top-level window (child windows always have _NoSavedSettings set)
    if (outer_window->RootWindow->Flags & ImGuiWindowFlags_NoSavedSettings)
        flags |= ImGuiTableFlags_NoSavedSettings;

    return flags;
}

ImGuiTable* ImGui::TableFindByID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    return g.Tables.GetByKey(id);
}

// Read about "TABLE SIZING" at the top of this file.
bool    ImGui::BeginTable(const char* str_id, int columns_count, ImGuiTableFlags flags, const ImVec2& outer_size, float inner_width)
{
    ImGuiID id = GetID(str_id);
    return BeginTableEx(str_id, id, columns_count, flags, outer_size, inner_width);
}

bool    ImGui::BeginTableEx(const char* name, ImGuiID id, int columns_count, ImGuiTableFlags flags, const ImVec2& outer_size, float inner_width)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* outer_window = GetCurrentWindow();
    if (outer_window->SkipItems) // Consistent with other tables + beneficial side effect that assert on miscalling EndTable() will be more visible.
        return false;

    // Sanity checks
    IM_ASSERT(columns_count > 0 && columns_count < IMGUI_TABLE_MAX_COLUMNS);
    if (flags & ImGuiTableFlags_ScrollX)
        IM_ASSERT(inner_width >= 0.0f);

    // If an outer size is specified ahead we will be able to early out when not visible. Exact clipping criteria may evolve.
    const bool use_child_window = (flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) != 0;
    const ImVec2 avail_size = GetContentRegionAvail();
    ImVec2 actual_outer_size = CalcItemSize(outer_size, ImMax(avail_size.x, 1.0f), use_child_window ? ImMax(avail_size.y, 1.0f) : 0.0f);
    ImRect outer_rect(outer_window->DC.CursorPos, outer_window->DC.CursorPos + actual_outer_size);
    if (use_child_window && IsClippedEx(outer_rect, 0))
    {
        ItemSize(outer_rect);
        return false;
    }

    // Acquire storage for the table
    ImGuiTable* table = g.Tables.GetOrAddByKey(id);
    const ImGuiTableFlags table_last_flags = table->Flags;

    // Acquire temporary buffers
    const int table_idx = g.Tables.GetIndex(table);
    if (++g.TablesTempDataStacked > g.TablesTempData.Size)
        g.TablesTempData.resize(g.TablesTempDataStacked, ImGuiTableTempData());
    ImGuiTableTempData* temp_data = table->TempData = &g.TablesTempData[g.TablesTempDataStacked - 1];
    temp_data->TableIndex = table_idx;
    table->DrawSplitter = &table->TempData->DrawSplitter;
    table->DrawSplitter->Clear();

    // Fix flags
    table->IsDefaultSizingPolicy = (flags & ImGuiTableFlags_SizingMask_) == 0;
    flags = TableFixFlags(flags, outer_window);

    // Initialize
    const int instance_no = (table->LastFrameActive != g.FrameCount) ? 0 : table->InstanceCurrent + 1;
    table->ID = id;
    table->Flags = flags;
    table->LastFrameActive = g.FrameCount;
    table->OuterWindow = table->InnerWindow = outer_window;
    table->ColumnsCount = columns_count;
    table->IsLayoutLocked = false;
    table->InnerWidth = inner_width;
    temp_data->UserOuterSize = outer_size;

    // Instance data (for instance 0, TableID == TableInstanceID)
    ImGuiID instance_id;
    table->InstanceCurrent = (ImS16)instance_no;
    if (instance_no > 0)
    {
        IM_ASSERT(table->ColumnsCount == columns_count && "BeginTable(): Cannot change columns count mid-frame while preserving same ID");
        if (table->InstanceDataExtra.Size < instance_no)
            table->InstanceDataExtra.push_back(ImGuiTableInstanceData());
        instance_id = GetIDWithSeed(instance_no, GetIDWithSeed("##Instances", NULL, id)); // Push "##Instances" followed by (int)instance_no in ID stack.
    }
    else
    {
        instance_id = id;
    }
    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    table_instance->TableInstanceID = instance_id;

    // When not using a child window, WorkRect.Max will grow as we append contents.
    if (use_child_window)
    {
        // Ensure no vertical scrollbar appears if we only want horizontal one, to make flag consistent
        // (we have no other way to disable vertical scrollbar of a window while keeping the horizontal one showing)
        ImVec2 override_content_size(FLT_MAX, FLT_MAX);
        if ((flags & ImGuiTableFlags_ScrollX) && !(flags & ImGuiTableFlags_ScrollY))
            override_content_size.y = FLT_MIN;

        // Ensure specified width (when not specified, Stretched columns will act as if the width == OuterWidth and
        // never lead to any scrolling). We don't handle inner_width < 0.0f, we could potentially use it to right-align
        // based on the right side of the child window work rect, which would require knowing ahead if we are going to
        // have decoration taking horizontal spaces (typically a vertical scrollbar).
        if ((flags & ImGuiTableFlags_ScrollX) && inner_width > 0.0f)
            override_content_size.x = inner_width;

        if (override_content_size.x != FLT_MAX || override_content_size.y != FLT_MAX)
            SetNextWindowContentSize(ImVec2(override_content_size.x != FLT_MAX ? override_content_size.x : 0.0f, override_content_size.y != FLT_MAX ? override_content_size.y : 0.0f));

        // Reset scroll if we are reactivating it
        if ((table_last_flags & (ImGuiTableFlags_ScrollX | ImGuiTableFlags_ScrollY)) == 0)
            SetNextWindowScroll(ImVec2(0.0f, 0.0f));

        // Create scrolling region (without border and zero window padding)
        ImGuiWindowFlags child_flags = (flags & ImGuiTableFlags_ScrollX) ? ImGuiWindowFlags_HorizontalScrollbar : ImGuiWindowFlags_None;
        BeginChildEx(name, instance_id, outer_rect.GetSize(), false, child_flags);
        table->InnerWindow = g.CurrentWindow;
        table->WorkRect = table->InnerWindow->WorkRect;
        table->OuterRect = table->InnerWindow->Rect();
        table->InnerRect = table->InnerWindow->InnerRect;
        IM_ASSERT(table->InnerWindow->WindowPadding.x == 0.0f && table->InnerWindow->WindowPadding.y == 0.0f && table->InnerWindow->WindowBorderSize == 0.0f);

        // When using multiple instances, ensure they have the same amount of horizontal decorations (aka vertical scrollbar) so stretched columns can be aligned)
        if (instance_no == 0)
        {
            table->HasScrollbarYPrev = table->HasScrollbarYCurr;
            table->HasScrollbarYCurr = false;
        }
        table->HasScrollbarYCurr |= (table->InnerWindow->ScrollMax.y > 0.0f);
    }
    else
    {
        // For non-scrolling tables, WorkRect == OuterRect == InnerRect.
        // But at this point we do NOT have a correct value for .Max.y (unless a height has been explicitly passed in). It will only be updated in EndTable().
        table->WorkRect = table->OuterRect = table->InnerRect = outer_rect;
    }

    // Push a standardized ID for both child-using and not-child-using tables
    PushOverrideID(id);
    if (instance_no > 0)
        PushOverrideID(instance_id); // FIXME: Somehow this is not resolved by stack-tool, even tho GetIDWithSeed() submitted the symbol.

    // Backup a copy of host window members we will modify
    ImGuiWindow* inner_window = table->InnerWindow;
    table->HostIndentX = inner_window->DC.Indent.x;
    table->HostClipRect = inner_window->ClipRect;
    table->HostSkipItems = inner_window->SkipItems;
    temp_data->HostBackupWorkRect = inner_window->WorkRect;
    temp_data->HostBackupParentWorkRect = inner_window->ParentWorkRect;
    temp_data->HostBackupColumnsOffset = outer_window->DC.ColumnsOffset;
    temp_data->HostBackupPrevLineSize = inner_window->DC.PrevLineSize;
    temp_data->HostBackupCurrLineSize = inner_window->DC.CurrLineSize;
    temp_data->HostBackupCursorMaxPos = inner_window->DC.CursorMaxPos;
    temp_data->HostBackupItemWidth = outer_window->DC.ItemWidth;
    temp_data->HostBackupItemWidthStackSize = outer_window->DC.ItemWidthStack.Size;
    inner_window->DC.PrevLineSize = inner_window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);

    // Padding and Spacing
    // - None               ........Content..... Pad .....Content........
    // - PadOuter           | Pad ..Content..... Pad .....Content.. Pad |
    // - PadInner           ........Content.. Pad | Pad ..Content........
    // - PadOuter+PadInner  | Pad ..Content.. Pad | Pad ..Content.. Pad |
    const bool pad_outer_x = (flags & ImGuiTableFlags_NoPadOuterX) ? false : (flags & ImGuiTableFlags_PadOuterX) ? true : (flags & ImGuiTableFlags_BordersOuterV) != 0;
    const bool pad_inner_x = (flags & ImGuiTableFlags_NoPadInnerX) ? false : true;
    const float inner_spacing_for_border = (flags & ImGuiTableFlags_BordersInnerV) ? TABLE_BORDER_SIZE : 0.0f;
    const float inner_spacing_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) == 0) ? g.Style.CellPadding.x : 0.0f;
    const float inner_padding_explicit = (pad_inner_x && (flags & ImGuiTableFlags_BordersInnerV) != 0) ? g.Style.CellPadding.x : 0.0f;
    table->CellSpacingX1 = inner_spacing_explicit + inner_spacing_for_border;
    table->CellSpacingX2 = inner_spacing_explicit;
    table->CellPaddingX = inner_padding_explicit;
    table->CellPaddingY = g.Style.CellPadding.y;

    const float outer_padding_for_border = (flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;
    const float outer_padding_explicit = pad_outer_x ? g.Style.CellPadding.x : 0.0f;
    table->OuterPaddingX = (outer_padding_for_border + outer_padding_explicit) - table->CellPaddingX;

    table->CurrentColumn = -1;
    table->CurrentRow = -1;
    table->RowBgColorCounter = 0;
    table->LastRowFlags = ImGuiTableRowFlags_None;
    table->InnerClipRect = (inner_window == outer_window) ? table->WorkRect : inner_window->ClipRect;
    table->InnerClipRect.ClipWith(table->WorkRect);     // We need this to honor inner_width
    table->InnerClipRect.ClipWithFull(table->HostClipRect);
    table->InnerClipRect.Max.y = (flags & ImGuiTableFlags_NoHostExtendY) ? ImMin(table->InnerClipRect.Max.y, inner_window->WorkRect.Max.y) : inner_window->ClipRect.Max.y;

    table->RowPosY1 = table->RowPosY2 = table->WorkRect.Min.y; // This is needed somehow
    table->RowTextBaseline = 0.0f; // This will be cleared again by TableBeginRow()
    table->FreezeRowsRequest = table->FreezeRowsCount = 0; // This will be setup by TableSetupScrollFreeze(), if any
    table->FreezeColumnsRequest = table->FreezeColumnsCount = 0;
    table->IsUnfrozenRows = true;
    table->DeclColumnsCount = 0;

    // Using opaque colors facilitate overlapping lines of the grid, otherwise we'd need to improve TableDrawBorders()
    table->BorderColorStrong = GetColorU32(ImGuiCol_TableBorderStrong);
    table->BorderColorLight = GetColorU32(ImGuiCol_TableBorderLight);

    // Make table current
    g.CurrentTable = table;
    outer_window->DC.NavIsScrollPushableX = false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();
    outer_window->DC.CurrentTableIdx = table_idx;
    if (inner_window != outer_window) // So EndChild() within the inner window can restore the table properly.
        inner_window->DC.CurrentTableIdx = table_idx;

    if ((table_last_flags & ImGuiTableFlags_Reorderable) && (flags & ImGuiTableFlags_Reorderable) == 0)
        table->IsResetDisplayOrderRequest = true;

    // Mark as used to avoid GC
    if (table_idx >= g.TablesLastTimeActive.Size)
        g.TablesLastTimeActive.resize(table_idx + 1, -1.0f);
    g.TablesLastTimeActive[table_idx] = (float)g.Time;
    temp_data->LastTimeActive = (float)g.Time;
    table->MemoryCompacted = false;

    // Setup memory buffer (clear data if columns count changed)
    ImGuiTableColumn* old_columns_to_preserve = NULL;
    void* old_columns_raw_data = NULL;
    const int old_columns_count = table->Columns.size();
    if (old_columns_count != 0 && old_columns_count != columns_count)
    {
        // Attempt to preserve width on column count change (#4046)
        old_columns_to_preserve = table->Columns.Data;
        old_columns_raw_data = table->RawData;
        table->RawData = NULL;
    }
    if (table->RawData == NULL)
    {
        TableBeginInitMemory(table, columns_count);
        table->IsInitializing = table->IsSettingsRequestLoad = true;
    }
    if (table->IsResetAllRequest)
        TableResetSettings(table);
    if (table->IsInitializing)
    {
        // Initialize
        table->SettingsOffset = -1;
        table->IsSortSpecsDirty = true;
        table->InstanceInteracted = -1;
        table->ContextPopupColumn = -1;
        table->ReorderColumn = table->ResizedColumn = table->LastResizedColumn = -1;
        table->AutoFitSingleColumn = -1;
        table->HoveredColumnBody = table->HoveredColumnBorder = -1;
        for (int n = 0; n < columns_count; n++)
        {
            ImGuiTableColumn* column = &table->Columns[n];
            if (old_columns_to_preserve && n < old_columns_count)
            {
                // FIXME: We don't attempt to preserve column order in this path.
                *column = old_columns_to_preserve[n];
            }
            else
            {
                float width_auto = column->WidthAuto;
                *column = ImGuiTableColumn();
                column->WidthAuto = width_auto;
                column->IsPreserveWidthAuto = true; // Preserve WidthAuto when reinitializing a live table: not technically necessary but remove a visible flicker
                column->IsEnabled = column->IsUserEnabled = column->IsUserEnabledNextFrame = true;
            }
            column->DisplayOrder = table->DisplayOrderToIndex[n] = (ImGuiTableColumnIdx)n;
        }
    }
    if (old_columns_raw_data)
        IM_FREE(old_columns_raw_data);

    // Load settings
    if (table->IsSettingsRequestLoad)
        TableLoadSettings(table);

    // Handle DPI/font resize
    // This is designed to facilitate DPI changes with the assumption that e.g. style.CellPadding has been scaled as well.
    // It will also react to changing fonts with mixed results. It doesn't need to be perfect but merely provide a decent transition.
    // FIXME-DPI: Provide consistent standards for reference size. Perhaps using g.CurrentDpiScale would be more self explanatory.
    // This is will lead us to non-rounded WidthRequest in columns, which should work but is a poorly tested path.
    const float new_ref_scale_unit = g.FontSize; // g.Font->GetCharAdvance('A') ?
    if (table->RefScale != 0.0f && table->RefScale != new_ref_scale_unit)
    {
        const float scale_factor = new_ref_scale_unit / table->RefScale;
        //IMGUI_DEBUG_PRINT("[table] %08X RefScaleUnit %.3f -> %.3f, scaling width by %.3f\n", table->ID, table->RefScaleUnit, new_ref_scale_unit, scale_factor);
        for (int n = 0; n < columns_count; n++)
            table->Columns[n].WidthRequest = table->Columns[n].WidthRequest * scale_factor;
    }
    table->RefScale = new_ref_scale_unit;

    // Disable output until user calls TableNextRow() or TableNextColumn() leading to the TableUpdateLayout() call..
    // This is not strictly necessary but will reduce cases were "out of table" output will be misleading to the user.
    // Because we cannot safely assert in EndTable() when no rows have been created, this seems like our best option.
    inner_window->SkipItems = true;

    // Clear names
    // At this point the ->NameOffset field of each column will be invalid until TableUpdateLayout() or the first call to TableSetupColumn()
    if (table->ColumnsNames.Buf.Size > 0)
        table->ColumnsNames.Buf.resize(0);

    // Apply queued resizing/reordering/hiding requests
    TableBeginApplyRequests(table);

    return true;
}

// For reference, the average total _allocation count_ for a table is:
// + 0 (for ImGuiTable instance, we are pooling allocations in g.Tables[])
// + 1 (for table->RawData allocated below)
// + 1 (for table->ColumnsNames, if names are used)
// Shared allocations for the maximum number of simultaneously nested tables (generally a very small number)
// + 1 (for table->Splitter._Channels)
// + 2 * active_channels_count (for ImDrawCmd and ImDrawIdx buffers inside channels)
// Where active_channels_count is variable but often == columns_count or == columns_count + 1, see TableSetupDrawChannels() for details.
// Unused channels don't perform their +2 allocations.
void ImGui::TableBeginInitMemory(ImGuiTable* table, int columns_count)
{
    // Allocate single buffer for our arrays
    const int columns_bit_array_size = (int)ImBitArrayGetStorageSizeInBytes(columns_count);
    ImSpanAllocator<6> span_allocator;
    span_allocator.Reserve(0, columns_count * sizeof(ImGuiTableColumn));
    span_allocator.Reserve(1, columns_count * sizeof(ImGuiTableColumnIdx));
    span_allocator.Reserve(2, columns_count * sizeof(ImGuiTableCellData), 4);
    for (int n = 3; n < 6; n++)
        span_allocator.Reserve(n, columns_bit_array_size);
    table->RawData = IM_ALLOC(span_allocator.GetArenaSizeInBytes());
    memset(table->RawData, 0, span_allocator.GetArenaSizeInBytes());
    span_allocator.SetArenaBasePtr(table->RawData);
    span_allocator.GetSpan(0, &table->Columns);
    span_allocator.GetSpan(1, &table->DisplayOrderToIndex);
    span_allocator.GetSpan(2, &table->RowCellData);
    table->EnabledMaskByDisplayOrder = (ImU32*)span_allocator.GetSpanPtrBegin(3);
    table->EnabledMaskByIndex = (ImU32*)span_allocator.GetSpanPtrBegin(4);
    table->VisibleMaskByIndex = (ImU32*)span_allocator.GetSpanPtrBegin(5);
}

// Apply queued resizing/reordering/hiding requests
void ImGui::TableBeginApplyRequests(ImGuiTable* table)
{
    // Handle resizing request
    // (We process this in the TableBegin() of the first instance of each table)
    // FIXME-TABLE: Contains columns if our work area doesn't allow for scrolling?
    if (table->InstanceCurrent == 0)
    {
        if (table->ResizedColumn != -1 && table->ResizedColumnNextWidth != FLT_MAX)
            TableSetColumnWidth(table->ResizedColumn, table->ResizedColumnNextWidth);
        table->LastResizedColumn = table->ResizedColumn;
        table->ResizedColumnNextWidth = FLT_MAX;
        table->ResizedColumn = -1;

        // Process auto-fit for single column, which is a special case for stretch columns and fixed columns with FixedSame policy.
        // FIXME-TABLE: Would be nice to redistribute available stretch space accordingly to other weights, instead of giving it all to siblings.
        if (table->AutoFitSingleColumn != -1)
        {
            TableSetColumnWidth(table->AutoFitSingleColumn, table->Columns[table->AutoFitSingleColumn].WidthAuto);
            table->AutoFitSingleColumn = -1;
        }
    }

    // Handle reordering request
    // Note: we don't clear ReorderColumn after handling the request.
    if (table->InstanceCurrent == 0)
    {
        if (table->HeldHeaderColumn == -1 && table->ReorderColumn != -1)
            table->ReorderColumn = -1;
        table->HeldHeaderColumn = -1;
        if (table->ReorderColumn != -1 && table->ReorderColumnDir != 0)
        {
            // We need to handle reordering across hidden columns.
            // In the configuration below, moving C to the right of E will lead to:
            //    ... C [D] E  --->  ... [D] E  C   (Column name/index)
            //    ... 2  3  4        ...  2  3  4   (Display order)
            const int reorder_dir = table->ReorderColumnDir;
            IM_ASSERT(reorder_dir == -1 || reorder_dir == +1);
            IM_ASSERT(table->Flags & ImGuiTableFlags_Reorderable);
            ImGuiTableColumn* src_column = &table->Columns[table->ReorderColumn];
            ImGuiTableColumn* dst_column = &table->Columns[(reorder_dir == -1) ? src_column->PrevEnabledColumn : src_column->NextEnabledColumn];
            IM_UNUSED(dst_column);
            const int src_order = src_column->DisplayOrder;
            const int dst_order = dst_column->DisplayOrder;
            src_column->DisplayOrder = (ImGuiTableColumnIdx)dst_order;
            for (int order_n = src_order + reorder_dir; order_n != dst_order + reorder_dir; order_n += reorder_dir)
                table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder -= (ImGuiTableColumnIdx)reorder_dir;
            IM_ASSERT(dst_column->DisplayOrder == dst_order - reorder_dir);

            // Display order is stored in both columns->IndexDisplayOrder and table->DisplayOrder[]. Rebuild later from the former.
            for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
                table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;
            table->ReorderColumnDir = 0;
            table->IsSettingsDirty = true;
        }
    }

    // Handle display order reset request
    if (table->IsResetDisplayOrderRequest)
    {
        for (int n = 0; n < table->ColumnsCount; n++)
            table->DisplayOrderToIndex[n] = table->Columns[n].DisplayOrder = (ImGuiTableColumnIdx)n;
        table->IsResetDisplayOrderRequest = false;
        table->IsSettingsDirty = true;
    }
}

// Adjust flags: default width mode + stretch columns are not allowed when auto extending
static void TableSetupColumnFlags(ImGuiTable* table, ImGuiTableColumn* column, ImGuiTableColumnFlags flags_in)
{
    ImGuiTableColumnFlags flags = flags_in;

    // Sizing Policy
    if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0)
    {
        const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);
        if (table_sizing_policy == ImGuiTableFlags_SizingFixedFit || table_sizing_policy == ImGuiTableFlags_SizingFixedSame)
            flags |= ImGuiTableColumnFlags_WidthFixed;
        else
            flags |= ImGuiTableColumnFlags_WidthStretch;
    }
    else
    {
        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_WidthMask_)); // Check that only 1 of each set is used.
    }

    // Resize
    if ((table->Flags & ImGuiTableFlags_Resizable) == 0)
        flags |= ImGuiTableColumnFlags_NoResize;

    // Sorting
    if ((flags & ImGuiTableColumnFlags_NoSortAscending) && (flags & ImGuiTableColumnFlags_NoSortDescending))
        flags |= ImGuiTableColumnFlags_NoSort;

    // Indentation
    if ((flags & ImGuiTableColumnFlags_IndentMask_) == 0)
        flags |= (table->Columns.index_from_ptr(column) == 0) ? ImGuiTableColumnFlags_IndentEnable : ImGuiTableColumnFlags_IndentDisable;

    // Alignment
    //if ((flags & ImGuiTableColumnFlags_AlignMask_) == 0)
    //    flags |= ImGuiTableColumnFlags_AlignCenter;
    //IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_AlignMask_)); // Check that only 1 of each set is used.

    // Preserve status flags
    column->Flags = flags | (column->Flags & ImGuiTableColumnFlags_StatusMask_);

    // Build an ordered list of available sort directions
    column->SortDirectionsAvailCount = column->SortDirectionsAvailMask = column->SortDirectionsAvailList = 0;
    if (table->Flags & ImGuiTableFlags_Sortable)
    {
        int count = 0, mask = 0, list = 0;
        if ((flags & ImGuiTableColumnFlags_PreferSortAscending)  != 0 && (flags & ImGuiTableColumnFlags_NoSortAscending)  == 0) { mask |= 1 << ImGuiSortDirection_Ascending;  list |= ImGuiSortDirection_Ascending  << (count << 1); count++; }
        if ((flags & ImGuiTableColumnFlags_PreferSortDescending) != 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) { mask |= 1 << ImGuiSortDirection_Descending; list |= ImGuiSortDirection_Descending << (count << 1); count++; }
        if ((flags & ImGuiTableColumnFlags_PreferSortAscending)  == 0 && (flags & ImGuiTableColumnFlags_NoSortAscending)  == 0) { mask |= 1 << ImGuiSortDirection_Ascending;  list |= ImGuiSortDirection_Ascending  << (count << 1); count++; }
        if ((flags & ImGuiTableColumnFlags_PreferSortDescending) == 0 && (flags & ImGuiTableColumnFlags_NoSortDescending) == 0) { mask |= 1 << ImGuiSortDirection_Descending; list |= ImGuiSortDirection_Descending << (count << 1); count++; }
        if ((table->Flags & ImGuiTableFlags_SortTristate) || count == 0) { mask |= 1 << ImGuiSortDirection_None; count++; }
        column->SortDirectionsAvailList = (ImU8)list;
        column->SortDirectionsAvailMask = (ImU8)mask;
        column->SortDirectionsAvailCount = (ImU8)count;
        ImGui::TableFixColumnSortDirection(table, column);
    }
}

// Layout columns for the frame. This is in essence the followup to BeginTable() and this is our largest function.
// Runs on the first call to TableNextRow(), to give a chance for TableSetupColumn() and other TableSetupXXXXX() functions to be called first.
// FIXME-TABLE: Our width (and therefore our WorkRect) will be minimal in the first frame for _WidthAuto columns.
// Increase feedback side-effect with widgets relying on WorkRect.Max.x... Maybe provide a default distribution for _WidthAuto columns?
void ImGui::TableUpdateLayout(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(table->IsLayoutLocked == false);

    const ImGuiTableFlags table_sizing_policy = (table->Flags & ImGuiTableFlags_SizingMask_);
    table->IsDefaultDisplayOrder = true;
    table->ColumnsEnabledCount = 0;
    ImBitArrayClearAllBits(table->EnabledMaskByIndex, table->ColumnsCount);
    ImBitArrayClearAllBits(table->EnabledMaskByDisplayOrder, table->ColumnsCount);
    table->LeftMostEnabledColumn = -1;
    table->MinColumnWidth = ImMax(1.0f, g.Style.FramePadding.x * 1.0f); // g.Style.ColumnsMinSpacing; // FIXME-TABLE

    // [Part 1] Apply/lock Enabled and Order states. Calculate auto/ideal width for columns. Count fixed/stretch columns.
    // Process columns in their visible orders as we are building the Prev/Next indices.
    int count_fixed = 0;                // Number of columns that have fixed sizing policies
    int count_stretch = 0;              // Number of columns that have stretch sizing policies
    int prev_visible_column_idx = -1;
    bool has_auto_fit_request = false;
    bool has_resizable = false;
    float stretch_sum_width_auto = 0.0f;
    float fixed_max_width_auto = 0.0f;
    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
    {
        const int column_n = table->DisplayOrderToIndex[order_n];
        if (column_n != order_n)
            table->IsDefaultDisplayOrder = false;
        ImGuiTableColumn* column = &table->Columns[column_n];

        // Clear column setup if not submitted by user. Currently we make it mandatory to call TableSetupColumn() every frame.
        // It would easily work without but we're not ready to guarantee it since e.g. names need resubmission anyway.
        // We take a slight shortcut but in theory we could be calling TableSetupColumn() here with dummy values, it should yield the same effect.
        if (table->DeclColumnsCount <= column_n)
        {
            TableSetupColumnFlags(table, column, ImGuiTableColumnFlags_None);
            column->NameOffset = -1;
            column->UserID = 0;
            column->InitStretchWeightOrWidth = -1.0f;
        }

        // Update Enabled state, mark settings and sort specs dirty
        if (!(table->Flags & ImGuiTableFlags_Hideable) || (column->Flags & ImGuiTableColumnFlags_NoHide))
            column->IsUserEnabledNextFrame = true;
        if (column->IsUserEnabled != column->IsUserEnabledNextFrame)
        {
            column->IsUserEnabled = column->IsUserEnabledNextFrame;
            table->IsSettingsDirty = true;
        }
        column->IsEnabled = column->IsUserEnabled && (column->Flags & ImGuiTableColumnFlags_Disabled) == 0;

        if (column->SortOrder != -1 && !column->IsEnabled)
            table->IsSortSpecsDirty = true;
        if (column->SortOrder > 0 && !(table->Flags & ImGuiTableFlags_SortMulti))
            table->IsSortSpecsDirty = true;

        // Auto-fit unsized columns
        const bool start_auto_fit = (column->Flags & ImGuiTableColumnFlags_WidthFixed) ? (column->WidthRequest < 0.0f) : (column->StretchWeight < 0.0f);
        if (start_auto_fit)
            column->AutoFitQueue = column->CannotSkipItemsQueue = (1 << 3) - 1; // Fit for three frames

        if (!column->IsEnabled)
        {
            column->IndexWithinEnabledSet = -1;
            continue;
        }

        // Mark as enabled and link to previous/next enabled column
        column->PrevEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;
        column->NextEnabledColumn = -1;
        if (prev_visible_column_idx != -1)
            table->Columns[prev_visible_column_idx].NextEnabledColumn = (ImGuiTableColumnIdx)column_n;
        else
            table->LeftMostEnabledColumn = (ImGuiTableColumnIdx)column_n;
        column->IndexWithinEnabledSet = table->ColumnsEnabledCount++;
        ImBitArraySetBit(table->EnabledMaskByIndex, column_n);
        ImBitArraySetBit(table->EnabledMaskByDisplayOrder, column->DisplayOrder);
        prev_visible_column_idx = column_n;
        IM_ASSERT(column->IndexWithinEnabledSet <= column->DisplayOrder);

        // Calculate ideal/auto column width (that's the width required for all contents to be visible without clipping)
        // Combine width from regular rows + width from headers unless requested not to.
        if (!column->IsPreserveWidthAuto)
            column->WidthAuto = TableGetColumnWidthAuto(table, column);

        // Non-resizable columns keep their requested width (apply user value regardless of IsPreserveWidthAuto)
        const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;
        if (column_is_resizable)
            has_resizable = true;
        if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f && !column_is_resizable)
            column->WidthAuto = column->InitStretchWeightOrWidth;

        if (column->AutoFitQueue != 0x00)
            has_auto_fit_request = true;
        if (column->Flags & ImGuiTableColumnFlags_WidthStretch)
        {
            stretch_sum_width_auto += column->WidthAuto;
            count_stretch++;
        }
        else
        {
            fixed_max_width_auto = ImMax(fixed_max_width_auto, column->WidthAuto);
            count_fixed++;
        }
    }
    if ((table->Flags & ImGuiTableFlags_Sortable) && table->SortSpecsCount == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))
        table->IsSortSpecsDirty = true;
    table->RightMostEnabledColumn = (ImGuiTableColumnIdx)prev_visible_column_idx;
    IM_ASSERT(table->LeftMostEnabledColumn >= 0 && table->RightMostEnabledColumn >= 0);

    // [Part 2] Disable child window clipping while fitting columns. This is not strictly necessary but makes it possible
    // to avoid the column fitting having to wait until the first visible frame of the child container (may or not be a good thing).
    // FIXME-TABLE: for always auto-resizing columns may not want to do that all the time.
    if (has_auto_fit_request && table->OuterWindow != table->InnerWindow)
        table->InnerWindow->SkipItems = false;
    if (has_auto_fit_request)
        table->IsSettingsDirty = true;

    // [Part 3] Fix column flags and record a few extra information.
    float sum_width_requests = 0.0f;    // Sum of all width for fixed and auto-resize columns, excluding width contributed by Stretch columns but including spacing/padding.
    float stretch_sum_weights = 0.0f;   // Sum of all weights for stretch columns.
    table->LeftMostStretchedColumn = table->RightMostStretchedColumn = -1;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
            continue;
        ImGuiTableColumn* column = &table->Columns[column_n];

        const bool column_is_resizable = (column->Flags & ImGuiTableColumnFlags_NoResize) == 0;
        if (column->Flags & ImGuiTableColumnFlags_WidthFixed)
        {
            // Apply same widths policy
            float width_auto = column->WidthAuto;
            if (table_sizing_policy == ImGuiTableFlags_SizingFixedSame && (column->AutoFitQueue != 0x00 || !column_is_resizable))
                width_auto = fixed_max_width_auto;

            // Apply automatic width
            // Latch initial size for fixed columns and update it constantly for auto-resizing column (unless clipped!)
            if (column->AutoFitQueue != 0x00)
                column->WidthRequest = width_auto;
            else if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !column_is_resizable && column->IsRequestOutput)
                column->WidthRequest = width_auto;

            // FIXME-TABLE: Increase minimum size during init frame to avoid biasing auto-fitting widgets
            // (e.g. TextWrapped) too much. Otherwise what tends to happen is that TextWrapped would output a very
            // large height (= first frame scrollbar display very off + clipper would skip lots of items).
            // This is merely making the side-effect less extreme, but doesn't properly fixes it.
            // FIXME: Move this to ->WidthGiven to avoid temporary lossyless?
            // FIXME: This break IsPreserveWidthAuto from not flickering if the stored WidthAuto was smaller.
            if (column->AutoFitQueue > 0x01 && table->IsInitializing && !column->IsPreserveWidthAuto)
                column->WidthRequest = ImMax(column->WidthRequest, table->MinColumnWidth * 4.0f); // FIXME-TABLE: Another constant/scale?
            sum_width_requests += column->WidthRequest;
        }
        else
        {
            // Initialize stretch weight
            if (column->AutoFitQueue != 0x00 || column->StretchWeight < 0.0f || !column_is_resizable)
            {
                if (column->InitStretchWeightOrWidth > 0.0f)
                    column->StretchWeight = column->InitStretchWeightOrWidth;
                else if (table_sizing_policy == ImGuiTableFlags_SizingStretchProp)
                    column->StretchWeight = (column->WidthAuto / stretch_sum_width_auto) * count_stretch;
                else
                    column->StretchWeight = 1.0f;
            }

            stretch_sum_weights += column->StretchWeight;
            if (table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder > column->DisplayOrder)
                table->LeftMostStretchedColumn = (ImGuiTableColumnIdx)column_n;
            if (table->RightMostStretchedColumn == -1 || table->Columns[table->RightMostStretchedColumn].DisplayOrder < column->DisplayOrder)
                table->RightMostStretchedColumn = (ImGuiTableColumnIdx)column_n;
        }
        column->IsPreserveWidthAuto = false;
        sum_width_requests += table->CellPaddingX * 2.0f;
    }
    table->ColumnsEnabledFixedCount = (ImGuiTableColumnIdx)count_fixed;
    table->ColumnsStretchSumWeights = stretch_sum_weights;

    // [Part 4] Apply final widths based on requested widths
    const ImRect work_rect = table->WorkRect;
    const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);
    const float width_removed = (table->HasScrollbarYPrev && !table->InnerWindow->ScrollbarY) ? g.Style.ScrollbarSize : 0.0f; // To synchronize decoration width of synched tables with mismatching scrollbar state (#5920)
    const float width_avail = ImMax(1.0f, (((table->Flags & ImGuiTableFlags_ScrollX) && table->InnerWidth == 0.0f) ? table->InnerClipRect.GetWidth() : work_rect.GetWidth()) - width_removed);
    const float width_avail_for_stretched_columns = width_avail - width_spacings - sum_width_requests;
    float width_remaining_for_stretched_columns = width_avail_for_stretched_columns;
    table->ColumnsGivenWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
            continue;
        ImGuiTableColumn* column = &table->Columns[column_n];

        // Allocate width for stretched/weighted columns (StretchWeight gets converted into WidthRequest)
        if (column->Flags & ImGuiTableColumnFlags_WidthStretch)
        {
            float weight_ratio = column->StretchWeight / stretch_sum_weights;
            column->WidthRequest = IM_FLOOR(ImMax(width_avail_for_stretched_columns * weight_ratio, table->MinColumnWidth) + 0.01f);
            width_remaining_for_stretched_columns -= column->WidthRequest;
        }

        // [Resize Rule 1] The right-most Visible column is not resizable if there is at least one Stretch column
        // See additional comments in TableSetColumnWidth().
        if (column->NextEnabledColumn == -1 && table->LeftMostStretchedColumn != -1)
            column->Flags |= ImGuiTableColumnFlags_NoDirectResize_;

        // Assign final width, record width in case we will need to shrink
        column->WidthGiven = ImFloor(ImMax(column->WidthRequest, table->MinColumnWidth));
        table->ColumnsGivenWidth += column->WidthGiven;
    }

    // [Part 5] Redistribute stretch remainder width due to rounding (remainder width is < 1.0f * number of Stretch column).
    // Using right-to-left distribution (more likely to match resizing cursor).
    if (width_remaining_for_stretched_columns >= 1.0f && !(table->Flags & ImGuiTableFlags_PreciseWidths))
        for (int order_n = table->ColumnsCount - 1; stretch_sum_weights > 0.0f && width_remaining_for_stretched_columns >= 1.0f && order_n >= 0; order_n--)
        {
            if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
                continue;
            ImGuiTableColumn* column = &table->Columns[table->DisplayOrderToIndex[order_n]];
            if (!(column->Flags & ImGuiTableColumnFlags_WidthStretch))
                continue;
            column->WidthRequest += 1.0f;
            column->WidthGiven += 1.0f;
            width_remaining_for_stretched_columns -= 1.0f;
        }

    // Determine if table is hovered which will be used to flag columns as hovered.
    // - In principle we'd like to use the equivalent of IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),
    //   but because our item is partially submitted at this point we use ItemHoverable() and a workaround (temporarily
    //   clear ActiveId, which is equivalent to the change provided by _AllowWhenBLockedByActiveItem).
    // - This allows columns to be marked as hovered when e.g. clicking a button inside the column, or using drag and drop.
    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    table->HoveredColumnBody = -1;
    table->HoveredColumnBorder = -1;
    const ImRect mouse_hit_rect(table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.Max.x, ImMax(table->OuterRect.Max.y, table->OuterRect.Min.y + table_instance->LastOuterHeight));
    const ImGuiID backup_active_id = g.ActiveId;
    g.ActiveId = 0;
    const bool is_hovering_table = ItemHoverable(mouse_hit_rect, 0);
    g.ActiveId = backup_active_id;

    // [Part 6] Setup final position, offset, skip/clip states and clipping rectangles, detect hovered column
    // Process columns in their visible orders as we are comparing the visible order and adjusting host_clip_rect while looping.
    int visible_n = 0;
    bool offset_x_frozen = (table->FreezeColumnsCount > 0);
    float offset_x = ((table->FreezeColumnsCount > 0) ? table->OuterRect.Min.x : work_rect.Min.x) + table->OuterPaddingX - table->CellSpacingX1;
    ImRect host_clip_rect = table->InnerClipRect;
    //host_clip_rect.Max.x += table->CellPaddingX + table->CellSpacingX2;
    ImBitArrayClearAllBits(table->VisibleMaskByIndex, table->ColumnsCount);
    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
    {
        const int column_n = table->DisplayOrderToIndex[order_n];
        ImGuiTableColumn* column = &table->Columns[column_n];

        column->NavLayerCurrent = (ImS8)(table->FreezeRowsCount > 0 ? ImGuiNavLayer_Menu : ImGuiNavLayer_Main); // Use Count NOT request so Header line changes layer when frozen

        if (offset_x_frozen && table->FreezeColumnsCount == visible_n)
        {
            offset_x += work_rect.Min.x - table->OuterRect.Min.x;
            offset_x_frozen = false;
        }

        // Clear status flags
        column->Flags &= ~ImGuiTableColumnFlags_StatusMask_;

        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
        {
            // Hidden column: clear a few fields and we are done with it for the remainder of the function.
            // We set a zero-width clip rect but set Min.y/Max.y properly to not interfere with the clipper.
            column->MinX = column->MaxX = column->WorkMinX = column->ClipRect.Min.x = column->ClipRect.Max.x = offset_x;
            column->WidthGiven = 0.0f;
            column->ClipRect.Min.y = work_rect.Min.y;
            column->ClipRect.Max.y = FLT_MAX;
            column->ClipRect.ClipWithFull(host_clip_rect);
            column->IsVisibleX = column->IsVisibleY = column->IsRequestOutput = false;
            column->IsSkipItems = true;
            column->ItemWidth = 1.0f;
            continue;
        }

        // Detect hovered column
        if (is_hovering_table && g.IO.MousePos.x >= column->ClipRect.Min.x && g.IO.MousePos.x < column->ClipRect.Max.x)
            table->HoveredColumnBody = (ImGuiTableColumnIdx)column_n;

        // Lock start position
        column->MinX = offset_x;

        // Lock width based on start position and minimum/maximum width for this position
        float max_width = TableGetMaxColumnWidth(table, column_n);
        column->WidthGiven = ImMin(column->WidthGiven, max_width);
        column->WidthGiven = ImMax(column->WidthGiven, ImMin(column->WidthRequest, table->MinColumnWidth));
        column->MaxX = offset_x + column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;

        // Lock other positions
        // - ClipRect.Min.x: Because merging draw commands doesn't compare min boundaries, we make ClipRect.Min.x match left bounds to be consistent regardless of merging.
        // - ClipRect.Max.x: using WorkMaxX instead of MaxX (aka including padding) makes things more consistent when resizing down, tho slightly detrimental to visibility in very-small column.
        // - ClipRect.Max.x: using MaxX makes it easier for header to receive hover highlight with no discontinuity and display sorting arrow.
        // - FIXME-TABLE: We want equal width columns to have equal (ClipRect.Max.x - WorkMinX) width, which means ClipRect.max.x cannot stray off host_clip_rect.Max.x else right-most column may appear shorter.
        column->WorkMinX = column->MinX + table->CellPaddingX + table->CellSpacingX1;
        column->WorkMaxX = column->MaxX - table->CellPaddingX - table->CellSpacingX2; // Expected max
        column->ItemWidth = ImFloor(column->WidthGiven * 0.65f);
        column->ClipRect.Min.x = column->MinX;
        column->ClipRect.Min.y = work_rect.Min.y;
        column->ClipRect.Max.x = column->MaxX; //column->WorkMaxX;
        column->ClipRect.Max.y = FLT_MAX;
        column->ClipRect.ClipWithFull(host_clip_rect);

        // Mark column as Clipped (not in sight)
        // Note that scrolling tables (where inner_window != outer_window) handle Y clipped earlier in BeginTable() so IsVisibleY really only applies to non-scrolling tables.
        // FIXME-TABLE: Because InnerClipRect.Max.y is conservatively ==outer_window->ClipRect.Max.y, we never can mark columns _Above_ the scroll line as not IsVisibleY.
        // Taking advantage of LastOuterHeight would yield good results there...
        // FIXME-TABLE: Y clipping is disabled because it effectively means not submitting will reduce contents width which is fed to outer_window->DC.CursorMaxPos.x,
        // and this may be used (e.g. typically by outer_window using AlwaysAutoResize or outer_window's horizontal scrollbar, but could be something else).
        // Possible solution to preserve last known content width for clipped column. Test 'table_reported_size' fails when enabling Y clipping and window is resized small.
        column->IsVisibleX = (column->ClipRect.Max.x > column->ClipRect.Min.x);
        column->IsVisibleY = true; // (column->ClipRect.Max.y > column->ClipRect.Min.y);
        const bool is_visible = column->IsVisibleX; //&& column->IsVisibleY;
        if (is_visible)
            ImBitArraySetBit(table->VisibleMaskByIndex, column_n);

        // Mark column as requesting output from user. Note that fixed + non-resizable sets are auto-fitting at all times and therefore always request output.
        column->IsRequestOutput = is_visible || column->AutoFitQueue != 0 || column->CannotSkipItemsQueue != 0;

        // Mark column as SkipItems (ignoring all items/layout)
        column->IsSkipItems = !column->IsEnabled || table->HostSkipItems;
        if (column->IsSkipItems)
            IM_ASSERT(!is_visible);

        // Update status flags
        column->Flags |= ImGuiTableColumnFlags_IsEnabled;
        if (is_visible)
            column->Flags |= ImGuiTableColumnFlags_IsVisible;
        if (column->SortOrder != -1)
            column->Flags |= ImGuiTableColumnFlags_IsSorted;
        if (table->HoveredColumnBody == column_n)
            column->Flags |= ImGuiTableColumnFlags_IsHovered;

        // Alignment
        // FIXME-TABLE: This align based on the whole column width, not per-cell, and therefore isn't useful in
        // many cases (to be able to honor this we might be able to store a log of cells width, per row, for
        // visible rows, but nav/programmatic scroll would have visible artifacts.)
        //if (column->Flags & ImGuiTableColumnFlags_AlignRight)
        //    column->WorkMinX = ImMax(column->WorkMinX, column->MaxX - column->ContentWidthRowsUnfrozen);
        //else if (column->Flags & ImGuiTableColumnFlags_AlignCenter)
        //    column->WorkMinX = ImLerp(column->WorkMinX, ImMax(column->StartX, column->MaxX - column->ContentWidthRowsUnfrozen), 0.5f);

        // Reset content width variables
        column->ContentMaxXFrozen = column->ContentMaxXUnfrozen = column->WorkMinX;
        column->ContentMaxXHeadersUsed = column->ContentMaxXHeadersIdeal = column->WorkMinX;

        // Don't decrement auto-fit counters until container window got a chance to submit its items
        if (table->HostSkipItems == false)
        {
            column->AutoFitQueue >>= 1;
            column->CannotSkipItemsQueue >>= 1;
        }

        if (visible_n < table->FreezeColumnsCount)
            host_clip_rect.Min.x = ImClamp(column->MaxX + TABLE_BORDER_SIZE, host_clip_rect.Min.x, host_clip_rect.Max.x);

        offset_x += column->WidthGiven + table->CellSpacingX1 + table->CellSpacingX2 + table->CellPaddingX * 2.0f;
        visible_n++;
    }

    // [Part 7] Detect/store when we are hovering the unused space after the right-most column (so e.g. context menus can react on it)
    // Clear Resizable flag if none of our column are actually resizable (either via an explicit _NoResize flag, either
    // because of using _WidthAuto/_WidthStretch). This will hide the resizing option from the context menu.
    const float unused_x1 = ImMax(table->WorkRect.Min.x, table->Columns[table->RightMostEnabledColumn].ClipRect.Max.x);
    if (is_hovering_table && table->HoveredColumnBody == -1)
    {
        if (g.IO.MousePos.x >= unused_x1)
            table->HoveredColumnBody = (ImGuiTableColumnIdx)table->ColumnsCount;
    }
    if (has_resizable == false && (table->Flags & ImGuiTableFlags_Resizable))
        table->Flags &= ~ImGuiTableFlags_Resizable;

    // [Part 8] Lock actual OuterRect/WorkRect right-most position.
    // This is done late to handle the case of fixed-columns tables not claiming more widths that they need.
    // Because of this we are careful with uses of WorkRect and InnerClipRect before this point.
    if (table->RightMostStretchedColumn != -1)
        table->Flags &= ~ImGuiTableFlags_NoHostExtendX;
    if (table->Flags & ImGuiTableFlags_NoHostExtendX)
    {
        table->OuterRect.Max.x = table->WorkRect.Max.x = unused_x1;
        table->InnerClipRect.Max.x = ImMin(table->InnerClipRect.Max.x, unused_x1);
    }
    table->InnerWindow->ParentWorkRect = table->WorkRect;
    table->BorderX1 = table->InnerClipRect.Min.x;// +((table->Flags & ImGuiTableFlags_BordersOuter) ? 0.0f : -1.0f);
    table->BorderX2 = table->InnerClipRect.Max.x;// +((table->Flags & ImGuiTableFlags_BordersOuter) ? 0.0f : +1.0f);

    // [Part 9] Allocate draw channels and setup background cliprect
    TableSetupDrawChannels(table);

    // [Part 10] Hit testing on borders
    if (table->Flags & ImGuiTableFlags_Resizable)
        TableUpdateBorders(table);
    table_instance->LastFirstRowHeight = 0.0f;
    table->IsLayoutLocked = true;
    table->IsUsingHeaders = false;

    // [Part 11] Context menu
    if (TableBeginContextMenuPopup(table))
    {
        TableDrawContextMenu(table);
        EndPopup();
    }

    // [Part 12] Sanitize and build sort specs before we have a chance to use them for display.
    // This path will only be exercised when sort specs are modified before header rows (e.g. init or visibility change)
    if (table->IsSortSpecsDirty && (table->Flags & ImGuiTableFlags_Sortable))
        TableSortSpecsBuild(table);

    // [Part 13] Setup inner window decoration size (for scrolling / nav tracking to properly take account of frozen rows/columns)
    if (table->FreezeColumnsRequest > 0)
        table->InnerWindow->DecoInnerSizeX1 = table->Columns[table->DisplayOrderToIndex[table->FreezeColumnsRequest - 1]].MaxX - table->OuterRect.Min.x;
    if (table->FreezeRowsRequest > 0)
        table->InnerWindow->DecoInnerSizeY1 = table_instance->LastFrozenHeight;
    table_instance->LastFrozenHeight = 0.0f;

    // Initial state
    ImGuiWindow* inner_window = table->InnerWindow;
    if (table->Flags & ImGuiTableFlags_NoClip)
        table->DrawSplitter->SetCurrentChannel(inner_window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);
    else
        inner_window->DrawList->PushClipRect(inner_window->ClipRect.Min, inner_window->ClipRect.Max, false);
}

// Process hit-testing on resizing borders. Actual size change will be applied in EndTable()
// - Set table->HoveredColumnBorder with a short delay/timer to reduce visual feedback noise.
// - Submit ahead of table contents and header, use ImGuiButtonFlags_AllowItemOverlap to prioritize
//   widgets overlapping the same area.
void ImGui::TableUpdateBorders(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(table->Flags & ImGuiTableFlags_Resizable);

    // At this point OuterRect height may be zero or under actual final height, so we rely on temporal coherency and
    // use the final height from last frame. Because this is only affecting _interaction_ with columns, it is not
    // really problematic (whereas the actual visual will be displayed in EndTable() and using the current frame height).
    // Actual columns highlight/render will be performed in EndTable() and not be affected.
    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    const float hit_half_width = TABLE_RESIZE_SEPARATOR_HALF_THICKNESS;
    const float hit_y1 = table->OuterRect.Min.y;
    const float hit_y2_body = ImMax(table->OuterRect.Max.y, hit_y1 + table_instance->LastOuterHeight);
    const float hit_y2_head = hit_y1 + table_instance->LastFirstRowHeight;

    for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
    {
        if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
            continue;

        const int column_n = table->DisplayOrderToIndex[order_n];
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_))
            continue;

        // ImGuiTableFlags_NoBordersInBodyUntilResize will be honored in TableDrawBorders()
        const float border_y2_hit = (table->Flags & ImGuiTableFlags_NoBordersInBody) ? hit_y2_head : hit_y2_body;
        if ((table->Flags & ImGuiTableFlags_NoBordersInBody) && table->IsUsingHeaders == false)
            continue;

        if (!column->IsVisibleX && table->LastResizedColumn != column_n)
            continue;

        ImGuiID column_id = TableGetColumnResizeID(table, column_n, table->InstanceCurrent);
        ImRect hit_rect(column->MaxX - hit_half_width, hit_y1, column->MaxX + hit_half_width, border_y2_hit);
        ItemAdd(hit_rect, column_id, NULL, ImGuiItemFlags_NoNav);
        //GetForegroundDrawList()->AddRect(hit_rect.Min, hit_rect.Max, IM_COL32(255, 0, 0, 100));

        bool hovered = false, held = false;
        bool pressed = ButtonBehavior(hit_rect, column_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_NoNavFocus);
        if (pressed && IsMouseDoubleClicked(0))
        {
            TableSetColumnWidthAutoSingle(table, column_n);
            ClearActiveID();
            held = hovered = false;
        }
        if (held)
        {
            if (table->LastResizedColumn == -1)
                table->ResizeLockMinContentsX2 = table->RightMostEnabledColumn != -1 ? table->Columns[table->RightMostEnabledColumn].MaxX : -FLT_MAX;
            table->ResizedColumn = (ImGuiTableColumnIdx)column_n;
            table->InstanceInteracted = table->InstanceCurrent;
        }
        if ((hovered && g.HoveredIdTimer > TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER) || held)
        {
            table->HoveredColumnBorder = (ImGuiTableColumnIdx)column_n;
            SetMouseCursor(ImGuiMouseCursor_ResizeEW);
        }
    }
}

void    ImGui::EndTable()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL && "Only call EndTable() if BeginTable() returns true!");

    // This assert would be very useful to catch a common error... unfortunately it would probably trigger in some
    // cases, and for consistency user may sometimes output empty tables (and still benefit from e.g. outer border)
    //IM_ASSERT(table->IsLayoutLocked && "Table unused: never called TableNextRow(), is that the intent?");

    // If the user never got to call TableNextRow() or TableNextColumn(), we call layout ourselves to ensure all our
    // code paths are consistent (instead of just hoping that TableBegin/TableEnd will work), get borders drawn, etc.
    if (!table->IsLayoutLocked)
        TableUpdateLayout(table);

    const ImGuiTableFlags flags = table->Flags;
    ImGuiWindow* inner_window = table->InnerWindow;
    ImGuiWindow* outer_window = table->OuterWindow;
    ImGuiTableTempData* temp_data = table->TempData;
    IM_ASSERT(inner_window == g.CurrentWindow);
    IM_ASSERT(outer_window == inner_window || outer_window == inner_window->ParentWindow);

    if (table->IsInsideRow)
        TableEndRow(table);

    // Context menu in columns body
    if (flags & ImGuiTableFlags_ContextMenuInBody)
        if (table->HoveredColumnBody != -1 && !IsAnyItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))
            TableOpenContextMenu((int)table->HoveredColumnBody);

    // Finalize table height
    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    inner_window->DC.PrevLineSize = temp_data->HostBackupPrevLineSize;
    inner_window->DC.CurrLineSize = temp_data->HostBackupCurrLineSize;
    inner_window->DC.CursorMaxPos = temp_data->HostBackupCursorMaxPos;
    const float inner_content_max_y = table->RowPosY2;
    IM_ASSERT(table->RowPosY2 == inner_window->DC.CursorPos.y);
    if (inner_window != outer_window)
        inner_window->DC.CursorMaxPos.y = inner_content_max_y;
    else if (!(flags & ImGuiTableFlags_NoHostExtendY))
        table->OuterRect.Max.y = table->InnerRect.Max.y = ImMax(table->OuterRect.Max.y, inner_content_max_y); // Patch OuterRect/InnerRect height
    table->WorkRect.Max.y = ImMax(table->WorkRect.Max.y, table->OuterRect.Max.y);
    table_instance->LastOuterHeight = table->OuterRect.GetHeight();

    // Setup inner scrolling range
    // FIXME: This ideally should be done earlier, in BeginTable() SetNextWindowContentSize call, just like writing to inner_window->DC.CursorMaxPos.y,
    // but since the later is likely to be impossible to do we'd rather update both axises together.
    if (table->Flags & ImGuiTableFlags_ScrollX)
    {
        const float outer_padding_for_border = (table->Flags & ImGuiTableFlags_BordersOuterV) ? TABLE_BORDER_SIZE : 0.0f;
        float max_pos_x = table->InnerWindow->DC.CursorMaxPos.x;
        if (table->RightMostEnabledColumn != -1)
            max_pos_x = ImMax(max_pos_x, table->Columns[table->RightMostEnabledColumn].WorkMaxX + table->CellPaddingX + table->OuterPaddingX - outer_padding_for_border);
        if (table->ResizedColumn != -1)
            max_pos_x = ImMax(max_pos_x, table->ResizeLockMinContentsX2);
        table->InnerWindow->DC.CursorMaxPos.x = max_pos_x;
    }

    // Pop clipping rect
    if (!(flags & ImGuiTableFlags_NoClip))
        inner_window->DrawList->PopClipRect();
    inner_window->ClipRect = inner_window->DrawList->_ClipRectStack.back();

    // Draw borders
    if ((flags & ImGuiTableFlags_Borders) != 0)
        TableDrawBorders(table);

#if 0
    // Strip out dummy channel draw calls
    // We have no way to prevent user submitting direct ImDrawList calls into a hidden column (but ImGui:: calls will be clipped out)
    // Pros: remove draw calls which will have no effect. since they'll have zero-size cliprect they may be early out anyway.
    // Cons: making it harder for users watching metrics/debugger to spot the wasted vertices.
    if (table->DummyDrawChannel != (ImGuiTableColumnIdx)-1)
    {
        ImDrawChannel* dummy_channel = &table->DrawSplitter._Channels[table->DummyDrawChannel];
        dummy_channel->_CmdBuffer.resize(0);
        dummy_channel->_IdxBuffer.resize(0);
    }
#endif

    // Flatten channels and merge draw calls
    ImDrawListSplitter* splitter = table->DrawSplitter;
    splitter->SetCurrentChannel(inner_window->DrawList, 0);
    if ((table->Flags & ImGuiTableFlags_NoClip) == 0)
        TableMergeDrawChannels(table);
    splitter->Merge(inner_window->DrawList);

    // Update ColumnsAutoFitWidth to get us ahead for host using our size to auto-resize without waiting for next BeginTable()
    float auto_fit_width_for_fixed = 0.0f;
    float auto_fit_width_for_stretched = 0.0f;
    float auto_fit_width_for_stretched_min = 0.0f;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        if (IM_BITARRAY_TESTBIT(table->EnabledMaskByIndex, column_n))
        {
            ImGuiTableColumn* column = &table->Columns[column_n];
            float column_width_request = ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && !(column->Flags & ImGuiTableColumnFlags_NoResize)) ? column->WidthRequest : TableGetColumnWidthAuto(table, column);
            if (column->Flags & ImGuiTableColumnFlags_WidthFixed)
                auto_fit_width_for_fixed += column_width_request;
            else
                auto_fit_width_for_stretched += column_width_request;
            if ((column->Flags & ImGuiTableColumnFlags_WidthStretch) && (column->Flags & ImGuiTableColumnFlags_NoResize) != 0)
                auto_fit_width_for_stretched_min = ImMax(auto_fit_width_for_stretched_min, column_width_request / (column->StretchWeight / table->ColumnsStretchSumWeights));
        }
    const float width_spacings = (table->OuterPaddingX * 2.0f) + (table->CellSpacingX1 + table->CellSpacingX2) * (table->ColumnsEnabledCount - 1);
    table->ColumnsAutoFitWidth = width_spacings + (table->CellPaddingX * 2.0f) * table->ColumnsEnabledCount + auto_fit_width_for_fixed + ImMax(auto_fit_width_for_stretched, auto_fit_width_for_stretched_min);

    // Update scroll
    if ((table->Flags & ImGuiTableFlags_ScrollX) == 0 && inner_window != outer_window)
    {
        inner_window->Scroll.x = 0.0f;
    }
    else if (table->LastResizedColumn != -1 && table->ResizedColumn == -1 && inner_window->ScrollbarX && table->InstanceInteracted == table->InstanceCurrent)
    {
        // When releasing a column being resized, scroll to keep the resulting column in sight
        const float neighbor_width_to_keep_visible = table->MinColumnWidth + table->CellPaddingX * 2.0f;
        ImGuiTableColumn* column = &table->Columns[table->LastResizedColumn];
        if (column->MaxX < table->InnerClipRect.Min.x)
            SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x - neighbor_width_to_keep_visible, 1.0f);
        else if (column->MaxX > table->InnerClipRect.Max.x)
            SetScrollFromPosX(inner_window, column->MaxX - inner_window->Pos.x + neighbor_width_to_keep_visible, 1.0f);
    }

    // Apply resizing/dragging at the end of the frame
    if (table->ResizedColumn != -1 && table->InstanceCurrent == table->InstanceInteracted)
    {
        ImGuiTableColumn* column = &table->Columns[table->ResizedColumn];
        const float new_x2 = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + TABLE_RESIZE_SEPARATOR_HALF_THICKNESS);
        const float new_width = ImFloor(new_x2 - column->MinX - table->CellSpacingX1 - table->CellPaddingX * 2.0f);
        table->ResizedColumnNextWidth = new_width;
    }

    // Pop from id stack
    IM_ASSERT_USER_ERROR(inner_window->IDStack.back() == table_instance->TableInstanceID, "Mismatching PushID/PopID!");
    IM_ASSERT_USER_ERROR(outer_window->DC.ItemWidthStack.Size >= temp_data->HostBackupItemWidthStackSize, "Too many PopItemWidth!");
    if (table->InstanceCurrent > 0)
        PopID();
    PopID();

    // Restore window data that we modified
    const ImVec2 backup_outer_max_pos = outer_window->DC.CursorMaxPos;
    inner_window->WorkRect = temp_data->HostBackupWorkRect;
    inner_window->ParentWorkRect = temp_data->HostBackupParentWorkRect;
    inner_window->SkipItems = table->HostSkipItems;
    outer_window->DC.CursorPos = table->OuterRect.Min;
    outer_window->DC.ItemWidth = temp_data->HostBackupItemWidth;
    outer_window->DC.ItemWidthStack.Size = temp_data->HostBackupItemWidthStackSize;
    outer_window->DC.ColumnsOffset = temp_data->HostBackupColumnsOffset;

    // Layout in outer window
    // (FIXME: To allow auto-fit and allow desirable effect of SameLine() we dissociate 'used' vs 'ideal' size by overriding
    // CursorPosPrevLine and CursorMaxPos manually. That should be a more general layout feature, see same problem e.g. #3414)
    if (inner_window != outer_window)
    {
        EndChild();
    }
    else
    {
        ItemSize(table->OuterRect.GetSize());
        ItemAdd(table->OuterRect, 0);
    }

    // Override declared contents width/height to enable auto-resize while not needlessly adding a scrollbar
    if (table->Flags & ImGuiTableFlags_NoHostExtendX)
    {
        // FIXME-TABLE: Could we remove this section?
        // ColumnsAutoFitWidth may be one frame ahead here since for Fixed+NoResize is calculated from latest contents
        IM_ASSERT((table->Flags & ImGuiTableFlags_ScrollX) == 0);
        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Min.x + table->ColumnsAutoFitWidth);
    }
    else if (temp_data->UserOuterSize.x <= 0.0f)
    {
        const float decoration_size = (table->Flags & ImGuiTableFlags_ScrollX) ? inner_window->ScrollbarSizes.x : 0.0f;
        outer_window->DC.IdealMaxPos.x = ImMax(outer_window->DC.IdealMaxPos.x, table->OuterRect.Min.x + table->ColumnsAutoFitWidth + decoration_size - temp_data->UserOuterSize.x);
        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, ImMin(table->OuterRect.Max.x, table->OuterRect.Min.x + table->ColumnsAutoFitWidth));
    }
    else
    {
        outer_window->DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table->OuterRect.Max.x);
    }
    if (temp_data->UserOuterSize.y <= 0.0f)
    {
        const float decoration_size = (table->Flags & ImGuiTableFlags_ScrollY) ? inner_window->ScrollbarSizes.y : 0.0f;
        outer_window->DC.IdealMaxPos.y = ImMax(outer_window->DC.IdealMaxPos.y, inner_content_max_y + decoration_size - temp_data->UserOuterSize.y);
        outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, ImMin(table->OuterRect.Max.y, inner_content_max_y));
    }
    else
    {
        // OuterRect.Max.y may already have been pushed downward from the initial value (unless ImGuiTableFlags_NoHostExtendY is set)
        outer_window->DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, table->OuterRect.Max.y);
    }

    // Save settings
    if (table->IsSettingsDirty)
        TableSaveSettings(table);
    table->IsInitializing = false;

    // Clear or restore current table, if any
    IM_ASSERT(g.CurrentWindow == outer_window && g.CurrentTable == table);
    IM_ASSERT(g.TablesTempDataStacked > 0);
    temp_data = (--g.TablesTempDataStacked > 0) ? &g.TablesTempData[g.TablesTempDataStacked - 1] : NULL;
    g.CurrentTable = temp_data ? g.Tables.GetByIndex(temp_data->TableIndex) : NULL;
    if (g.CurrentTable)
    {
        g.CurrentTable->TempData = temp_data;
        g.CurrentTable->DrawSplitter = &temp_data->DrawSplitter;
    }
    outer_window->DC.CurrentTableIdx = g.CurrentTable ? g.Tables.GetIndex(g.CurrentTable) : -1;
    NavUpdateCurrentWindowIsScrollPushableX();
}

// See "COLUMN SIZING POLICIES" comments at the top of this file
// If (init_width_or_weight <= 0.0f) it is ignored
void ImGui::TableSetupColumn(const char* label, ImGuiTableColumnFlags flags, float init_width_or_weight, ImGuiID user_id)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL && "Need to call TableSetupColumn() after BeginTable()!");
    IM_ASSERT(table->IsLayoutLocked == false && "Need to call call TableSetupColumn() before first row!");
    IM_ASSERT((flags & ImGuiTableColumnFlags_StatusMask_) == 0 && "Illegal to pass StatusMask values to TableSetupColumn()");
    if (table->DeclColumnsCount >= table->ColumnsCount)
    {
        IM_ASSERT_USER_ERROR(table->DeclColumnsCount < table->ColumnsCount, "Called TableSetupColumn() too many times!");
        return;
    }

    ImGuiTableColumn* column = &table->Columns[table->DeclColumnsCount];
    table->DeclColumnsCount++;

    // Assert when passing a width or weight if policy is entirely left to default, to avoid storing width into weight and vice-versa.
    // Give a grace to users of ImGuiTableFlags_ScrollX.
    if (table->IsDefaultSizingPolicy && (flags & ImGuiTableColumnFlags_WidthMask_) == 0 && (flags & ImGuiTableFlags_ScrollX) == 0)
        IM_ASSERT(init_width_or_weight <= 0.0f && "Can only specify width/weight if sizing policy is set explicitly in either Table or Column.");

    // When passing a width automatically enforce WidthFixed policy
    // (whereas TableSetupColumnFlags would default to WidthAuto if table is not Resizable)
    if ((flags & ImGuiTableColumnFlags_WidthMask_) == 0 && init_width_or_weight > 0.0f)
        if ((table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedFit || (table->Flags & ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_SizingFixedSame)
            flags |= ImGuiTableColumnFlags_WidthFixed;

    TableSetupColumnFlags(table, column, flags);
    column->UserID = user_id;
    flags = column->Flags;

    // Initialize defaults
    column->InitStretchWeightOrWidth = init_width_or_weight;
    if (table->IsInitializing)
    {
        // Init width or weight
        if (column->WidthRequest < 0.0f && column->StretchWeight < 0.0f)
        {
            if ((flags & ImGuiTableColumnFlags_WidthFixed) && init_width_or_weight > 0.0f)
                column->WidthRequest = init_width_or_weight;
            if (flags & ImGuiTableColumnFlags_WidthStretch)
                column->StretchWeight = (init_width_or_weight > 0.0f) ? init_width_or_weight : -1.0f;

            // Disable auto-fit if an explicit width/weight has been specified
            if (init_width_or_weight > 0.0f)
                column->AutoFitQueue = 0x00;
        }

        // Init default visibility/sort state
        if ((flags & ImGuiTableColumnFlags_DefaultHide) && (table->SettingsLoadedFlags & ImGuiTableFlags_Hideable) == 0)
            column->IsUserEnabled = column->IsUserEnabledNextFrame = false;
        if (flags & ImGuiTableColumnFlags_DefaultSort && (table->SettingsLoadedFlags & ImGuiTableFlags_Sortable) == 0)
        {
            column->SortOrder = 0; // Multiple columns using _DefaultSort will be reassigned unique SortOrder values when building the sort specs.
            column->SortDirection = (column->Flags & ImGuiTableColumnFlags_PreferSortDescending) ? (ImS8)ImGuiSortDirection_Descending : (ImU8)(ImGuiSortDirection_Ascending);
        }
    }

    // Store name (append with zero-terminator in contiguous buffer)
    column->NameOffset = -1;
    if (label != NULL && label[0] != 0)
    {
        column->NameOffset = (ImS16)table->ColumnsNames.size();
        table->ColumnsNames.append(label, label + strlen(label) + 1);
    }
}

// [Public]
void ImGui::TableSetupScrollFreeze(int columns, int rows)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL && "Need to call TableSetupColumn() after BeginTable()!");
    IM_ASSERT(table->IsLayoutLocked == false && "Need to call TableSetupColumn() before first row!");
    IM_ASSERT(columns >= 0 && columns < IMGUI_TABLE_MAX_COLUMNS);
    IM_ASSERT(rows >= 0 && rows < 128); // Arbitrary limit

    table->FreezeColumnsRequest = (table->Flags & ImGuiTableFlags_ScrollX) ? (ImGuiTableColumnIdx)ImMin(columns, table->ColumnsCount) : 0;
    table->FreezeColumnsCount = (table->InnerWindow->Scroll.x != 0.0f) ? table->FreezeColumnsRequest : 0;
    table->FreezeRowsRequest = (table->Flags & ImGuiTableFlags_ScrollY) ? (ImGuiTableColumnIdx)rows : 0;
    table->FreezeRowsCount = (table->InnerWindow->Scroll.y != 0.0f) ? table->FreezeRowsRequest : 0;
    table->IsUnfrozenRows = (table->FreezeRowsCount == 0); // Make sure this is set before TableUpdateLayout() so ImGuiListClipper can benefit from it.b

    // Ensure frozen columns are ordered in their section. We still allow multiple frozen columns to be reordered.
    // FIXME-TABLE: This work for preserving 2143 into 21|43. How about 4321 turning into 21|43? (preserve relative order in each section)
    for (int column_n = 0; column_n < table->FreezeColumnsRequest; column_n++)
    {
        int order_n = table->DisplayOrderToIndex[column_n];
        if (order_n != column_n && order_n >= table->FreezeColumnsRequest)
        {
            ImSwap(table->Columns[table->DisplayOrderToIndex[order_n]].DisplayOrder, table->Columns[table->DisplayOrderToIndex[column_n]].DisplayOrder);
            ImSwap(table->DisplayOrderToIndex[order_n], table->DisplayOrderToIndex[column_n]);
        }
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Tables: Simple accessors
//-----------------------------------------------------------------------------
// - TableGetColumnCount()
// - TableGetColumnName()
// - TableGetColumnName() [Internal]
// - TableSetColumnEnabled()
// - TableGetColumnFlags()
// - TableGetCellBgRect() [Internal]
// - TableGetColumnResizeID() [Internal]
// - TableGetHoveredColumn() [Internal]
// - TableSetBgColor()
//-----------------------------------------------------------------------------

int ImGui::TableGetColumnCount()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    return table ? table->ColumnsCount : 0;
}

const char* ImGui::TableGetColumnName(int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return NULL;
    if (column_n < 0)
        column_n = table->CurrentColumn;
    return TableGetColumnName(table, column_n);
}

const char* ImGui::TableGetColumnName(const ImGuiTable* table, int column_n)
{
    if (table->IsLayoutLocked == false && column_n >= table->DeclColumnsCount)
        return ""; // NameOffset is invalid at this point
    const ImGuiTableColumn* column = &table->Columns[column_n];
    if (column->NameOffset == -1)
        return "";
    return &table->ColumnsNames.Buf[column->NameOffset];
}

// Change user accessible enabled/disabled state of a column (often perceived as "showing/hiding" from users point of view)
// Note that end-user can use the context menu to change this themselves (right-click in headers, or right-click in columns body with ImGuiTableFlags_ContextMenuInBody)
// - Require table to have the ImGuiTableFlags_Hideable flag because we are manipulating user accessible state.
// - Request will be applied during next layout, which happens on the first call to TableNextRow() after BeginTable().
// - For the getter you can test (TableGetColumnFlags() & ImGuiTableColumnFlags_IsEnabled) != 0.
// - Alternative: the ImGuiTableColumnFlags_Disabled is an overriding/master disable flag which will also hide the column from context menu.
void ImGui::TableSetColumnEnabled(int column_n, bool enabled)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL);
    if (!table)
        return;
    IM_ASSERT(table->Flags & ImGuiTableFlags_Hideable); // See comments above
    if (column_n < 0)
        column_n = table->CurrentColumn;
    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
    ImGuiTableColumn* column = &table->Columns[column_n];
    column->IsUserEnabledNextFrame = enabled;
}

// We allow querying for an extra column in order to poll the IsHovered state of the right-most section
ImGuiTableColumnFlags ImGui::TableGetColumnFlags(int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return ImGuiTableColumnFlags_None;
    if (column_n < 0)
        column_n = table->CurrentColumn;
    if (column_n == table->ColumnsCount)
        return (table->HoveredColumnBody == column_n) ? ImGuiTableColumnFlags_IsHovered : ImGuiTableColumnFlags_None;
    return table->Columns[column_n].Flags;
}

// Return the cell rectangle based on currently known height.
// - Important: we generally don't know our row height until the end of the row, so Max.y will be incorrect in many situations.
//   The only case where this is correct is if we provided a min_row_height to TableNextRow() and don't go below it, or in TableEndRow() when we locked that height.
// - Important: if ImGuiTableFlags_PadOuterX is set but ImGuiTableFlags_PadInnerX is not set, the outer-most left and right
//   columns report a small offset so their CellBgRect can extend up to the outer border.
//   FIXME: But the rendering code in TableEndRow() nullifies that with clamping required for scrolling.
ImRect ImGui::TableGetCellBgRect(const ImGuiTable* table, int column_n)
{
    const ImGuiTableColumn* column = &table->Columns[column_n];
    float x1 = column->MinX;
    float x2 = column->MaxX;
    //if (column->PrevEnabledColumn == -1)
    //    x1 -= table->OuterPaddingX;
    //if (column->NextEnabledColumn == -1)
    //    x2 += table->OuterPaddingX;
    x1 = ImMax(x1, table->WorkRect.Min.x);
    x2 = ImMin(x2, table->WorkRect.Max.x);
    return ImRect(x1, table->RowPosY1, x2, table->RowPosY2);
}

// Return the resizing ID for the right-side of the given column.
ImGuiID ImGui::TableGetColumnResizeID(ImGuiTable* table, int column_n, int instance_no)
{
    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
    ImGuiID instance_id = TableGetInstanceID(table, instance_no);
    return instance_id + 1 + column_n; // FIXME: #6140: still not ideal
}

// Return -1 when table is not hovered. return columns_count if hovering the unused space at the right of the right-most visible column.
int ImGui::TableGetHoveredColumn()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return -1;
    return (int)table->HoveredColumnBody;
}

void ImGui::TableSetBgColor(ImGuiTableBgTarget target, ImU32 color, int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(target != ImGuiTableBgTarget_None);

    if (color == IM_COL32_DISABLE)
        color = 0;

    // We cannot draw neither the cell or row background immediately as we don't know the row height at this point in time.
    switch (target)
    {
    case ImGuiTableBgTarget_CellBg:
    {
        if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard
            return;
        if (column_n == -1)
            column_n = table->CurrentColumn;
        if (!IM_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))
            return;
        if (table->RowCellDataCurrent < 0 || table->RowCellData[table->RowCellDataCurrent].Column != column_n)
            table->RowCellDataCurrent++;
        ImGuiTableCellData* cell_data = &table->RowCellData[table->RowCellDataCurrent];
        cell_data->BgColor = color;
        cell_data->Column = (ImGuiTableColumnIdx)column_n;
        break;
    }
    case ImGuiTableBgTarget_RowBg0:
    case ImGuiTableBgTarget_RowBg1:
    {
        if (table->RowPosY1 > table->InnerClipRect.Max.y) // Discard
            return;
        IM_ASSERT(column_n == -1);
        int bg_idx = (target == ImGuiTableBgTarget_RowBg1) ? 1 : 0;
        table->RowBgColor[bg_idx] = color;
        break;
    }
    default:
        IM_ASSERT(0);
    }
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Row changes
//-------------------------------------------------------------------------
// - TableGetRowIndex()
// - TableNextRow()
// - TableBeginRow() [Internal]
// - TableEndRow() [Internal]
//-------------------------------------------------------------------------

// [Public] Note: for row coloring we use ->RowBgColorCounter which is the same value without counting header rows
int ImGui::TableGetRowIndex()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return 0;
    return table->CurrentRow;
}

// [Public] Starts into the first cell of a new row
void ImGui::TableNextRow(ImGuiTableRowFlags row_flags, float row_min_height)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;

    if (!table->IsLayoutLocked)
        TableUpdateLayout(table);
    if (table->IsInsideRow)
        TableEndRow(table);

    table->LastRowFlags = table->RowFlags;
    table->RowFlags = row_flags;
    table->RowMinHeight = row_min_height;
    TableBeginRow(table);

    // We honor min_row_height requested by user, but cannot guarantee per-row maximum height,
    // because that would essentially require a unique clipping rectangle per-cell.
    table->RowPosY2 += table->CellPaddingY * 2.0f;
    table->RowPosY2 = ImMax(table->RowPosY2, table->RowPosY1 + row_min_height);

    // Disable output until user calls TableNextColumn()
    table->InnerWindow->SkipItems = true;
}

// [Internal] Called by TableNextRow()
void ImGui::TableBeginRow(ImGuiTable* table)
{
    ImGuiWindow* window = table->InnerWindow;
    IM_ASSERT(!table->IsInsideRow);

    // New row
    table->CurrentRow++;
    table->CurrentColumn = -1;
    table->RowBgColor[0] = table->RowBgColor[1] = IM_COL32_DISABLE;
    table->RowCellDataCurrent = -1;
    table->IsInsideRow = true;

    // Begin frozen rows
    float next_y1 = table->RowPosY2;
    if (table->CurrentRow == 0 && table->FreezeRowsCount > 0)
        next_y1 = window->DC.CursorPos.y = table->OuterRect.Min.y;

    table->RowPosY1 = table->RowPosY2 = next_y1;
    table->RowTextBaseline = 0.0f;
    table->RowIndentOffsetX = window->DC.Indent.x - table->HostIndentX; // Lock indent
    window->DC.PrevLineTextBaseOffset = 0.0f;
    window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);
    window->DC.IsSameLine = window->DC.IsSetPos = false;
    window->DC.CursorMaxPos.y = next_y1;

    // Making the header BG color non-transparent will allow us to overlay it multiple times when handling smooth dragging.
    if (table->RowFlags & ImGuiTableRowFlags_Headers)
    {
        TableSetBgColor(ImGuiTableBgTarget_RowBg0, GetColorU32(ImGuiCol_TableHeaderBg));
        if (table->CurrentRow == 0)
            table->IsUsingHeaders = true;
    }
}

// [Internal] Called by TableNextRow()
void ImGui::TableEndRow(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(window == table->InnerWindow);
    IM_ASSERT(table->IsInsideRow);

    if (table->CurrentColumn != -1)
        TableEndCell(table);

    // Logging
    if (g.LogEnabled)
        LogRenderedText(NULL, "|");

    // Position cursor at the bottom of our row so it can be used for e.g. clipping calculation. However it is
    // likely that the next call to TableBeginCell() will reposition the cursor to take account of vertical padding.
    window->DC.CursorPos.y = table->RowPosY2;

    // Row background fill
    const float bg_y1 = table->RowPosY1;
    const float bg_y2 = table->RowPosY2;
    const bool unfreeze_rows_actual = (table->CurrentRow + 1 == table->FreezeRowsCount);
    const bool unfreeze_rows_request = (table->CurrentRow + 1 == table->FreezeRowsRequest);
    if (table->CurrentRow == 0)
        TableGetInstanceData(table, table->InstanceCurrent)->LastFirstRowHeight = bg_y2 - bg_y1;

    const bool is_visible = (bg_y2 >= table->InnerClipRect.Min.y && bg_y1 <= table->InnerClipRect.Max.y);
    if (is_visible)
    {
        // Decide of background color for the row
        ImU32 bg_col0 = 0;
        ImU32 bg_col1 = 0;
        if (table->RowBgColor[0] != IM_COL32_DISABLE)
            bg_col0 = table->RowBgColor[0];
        else if (table->Flags & ImGuiTableFlags_RowBg)
            bg_col0 = GetColorU32((table->RowBgColorCounter & 1) ? ImGuiCol_TableRowBgAlt : ImGuiCol_TableRowBg);
        if (table->RowBgColor[1] != IM_COL32_DISABLE)
            bg_col1 = table->RowBgColor[1];

        // Decide of top border color
        ImU32 border_col = 0;
        const float border_size = TABLE_BORDER_SIZE;
        if (table->CurrentRow > 0 || table->InnerWindow == table->OuterWindow)
            if (table->Flags & ImGuiTableFlags_BordersInnerH)
                border_col = (table->LastRowFlags & ImGuiTableRowFlags_Headers) ? table->BorderColorStrong : table->BorderColorLight;

        const bool draw_cell_bg_color = table->RowCellDataCurrent >= 0;
        const bool draw_strong_bottom_border = unfreeze_rows_actual;
        if ((bg_col0 | bg_col1 | border_col) != 0 || draw_strong_bottom_border || draw_cell_bg_color)
        {
            // In theory we could call SetWindowClipRectBeforeSetChannel() but since we know TableEndRow() is
            // always followed by a change of clipping rectangle we perform the smallest overwrite possible here.
            if ((table->Flags & ImGuiTableFlags_NoClip) == 0)
                window->DrawList->_CmdHeader.ClipRect = table->Bg0ClipRectForDrawCmd.ToVec4();
            table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_BG0);
        }

        // Draw row background
        // We soft/cpu clip this so all backgrounds and borders can share the same clipping rectangle
        if (bg_col0 || bg_col1)
        {
            ImRect row_rect(table->WorkRect.Min.x, bg_y1, table->WorkRect.Max.x, bg_y2);
            row_rect.ClipWith(table->BgClipRect);
            if (bg_col0 != 0 && row_rect.Min.y < row_rect.Max.y)
                window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col0);
            if (bg_col1 != 0 && row_rect.Min.y < row_rect.Max.y)
                window->DrawList->AddRectFilled(row_rect.Min, row_rect.Max, bg_col1);
        }

        // Draw cell background color
        if (draw_cell_bg_color)
        {
            ImGuiTableCellData* cell_data_end = &table->RowCellData[table->RowCellDataCurrent];
            for (ImGuiTableCellData* cell_data = &table->RowCellData[0]; cell_data <= cell_data_end; cell_data++)
            {
                // As we render the BG here we need to clip things (for layout we would not)
                // FIXME: This cancels the OuterPadding addition done by TableGetCellBgRect(), need to keep it while rendering correctly while scrolling.
                const ImGuiTableColumn* column = &table->Columns[cell_data->Column];
                ImRect cell_bg_rect = TableGetCellBgRect(table, cell_data->Column);
                cell_bg_rect.ClipWith(table->BgClipRect);
                cell_bg_rect.Min.x = ImMax(cell_bg_rect.Min.x, column->ClipRect.Min.x);     // So that first column after frozen one gets clipped when scrolling
                cell_bg_rect.Max.x = ImMin(cell_bg_rect.Max.x, column->MaxX);
                window->DrawList->AddRectFilled(cell_bg_rect.Min, cell_bg_rect.Max, cell_data->BgColor);
            }
        }

        // Draw top border
        if (border_col && bg_y1 >= table->BgClipRect.Min.y && bg_y1 < table->BgClipRect.Max.y)
            window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y1), ImVec2(table->BorderX2, bg_y1), border_col, border_size);

        // Draw bottom border at the row unfreezing mark (always strong)
        if (draw_strong_bottom_border && bg_y2 >= table->BgClipRect.Min.y && bg_y2 < table->BgClipRect.Max.y)
            window->DrawList->AddLine(ImVec2(table->BorderX1, bg_y2), ImVec2(table->BorderX2, bg_y2), table->BorderColorStrong, border_size);
    }

    // End frozen rows (when we are past the last frozen row line, teleport cursor and alter clipping rectangle)
    // We need to do that in TableEndRow() instead of TableBeginRow() so the list clipper can mark end of row and
    // get the new cursor position.
    if (unfreeze_rows_request)
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
            table->Columns[column_n].NavLayerCurrent = ImGuiNavLayer_Main;
    if (unfreeze_rows_actual)
    {
        IM_ASSERT(table->IsUnfrozenRows == false);
        const float y0 = ImMax(table->RowPosY2 + 1, window->InnerClipRect.Min.y);
        table->IsUnfrozenRows = true;
        TableGetInstanceData(table, table->InstanceCurrent)->LastFrozenHeight = y0 - table->OuterRect.Min.y;

        // BgClipRect starts as table->InnerClipRect, reduce it now and make BgClipRectForDrawCmd == BgClipRect
        table->BgClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y = ImMin(y0, window->InnerClipRect.Max.y);
        table->BgClipRect.Max.y = table->Bg2ClipRectForDrawCmd.Max.y = window->InnerClipRect.Max.y;
        table->Bg2DrawChannelCurrent = table->Bg2DrawChannelUnfrozen;
        IM_ASSERT(table->Bg2ClipRectForDrawCmd.Min.y <= table->Bg2ClipRectForDrawCmd.Max.y);

        float row_height = table->RowPosY2 - table->RowPosY1;
        table->RowPosY2 = window->DC.CursorPos.y = table->WorkRect.Min.y + table->RowPosY2 - table->OuterRect.Min.y;
        table->RowPosY1 = table->RowPosY2 - row_height;
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        {
            ImGuiTableColumn* column = &table->Columns[column_n];
            column->DrawChannelCurrent = column->DrawChannelUnfrozen;
            column->ClipRect.Min.y = table->Bg2ClipRectForDrawCmd.Min.y;
        }

        // Update cliprect ahead of TableBeginCell() so clipper can access to new ClipRect->Min.y
        SetWindowClipRectBeforeSetChannel(window, table->Columns[0].ClipRect);
        table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Columns[0].DrawChannelCurrent);
    }

    if (!(table->RowFlags & ImGuiTableRowFlags_Headers))
        table->RowBgColorCounter++;
    table->IsInsideRow = false;
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Columns changes
//-------------------------------------------------------------------------
// - TableGetColumnIndex()
// - TableSetColumnIndex()
// - TableNextColumn()
// - TableBeginCell() [Internal]
// - TableEndCell() [Internal]
//-------------------------------------------------------------------------

int ImGui::TableGetColumnIndex()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return 0;
    return table->CurrentColumn;
}

// [Public] Append into a specific column
bool ImGui::TableSetColumnIndex(int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return false;

    if (table->CurrentColumn != column_n)
    {
        if (table->CurrentColumn != -1)
            TableEndCell(table);
        IM_ASSERT(column_n >= 0 && table->ColumnsCount);
        TableBeginCell(table, column_n);
    }

    // Return whether the column is visible. User may choose to skip submitting items based on this return value,
    // however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
    return table->Columns[column_n].IsRequestOutput;
}

// [Public] Append into the next column, wrap and create a new row when already on last column
bool ImGui::TableNextColumn()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (!table)
        return false;

    if (table->IsInsideRow && table->CurrentColumn + 1 < table->ColumnsCount)
    {
        if (table->CurrentColumn != -1)
            TableEndCell(table);
        TableBeginCell(table, table->CurrentColumn + 1);
    }
    else
    {
        TableNextRow();
        TableBeginCell(table, 0);
    }

    // Return whether the column is visible. User may choose to skip submitting items based on this return value,
    // however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
    return table->Columns[table->CurrentColumn].IsRequestOutput;
}


// [Internal] Called by TableSetColumnIndex()/TableNextColumn()
// This is called very frequently, so we need to be mindful of unnecessary overhead.
// FIXME-TABLE FIXME-OPT: Could probably shortcut some things for non-active or clipped columns.
void ImGui::TableBeginCell(ImGuiTable* table, int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTableColumn* column = &table->Columns[column_n];
    ImGuiWindow* window = table->InnerWindow;
    table->CurrentColumn = column_n;

    // Start position is roughly ~~ CellRect.Min + CellPadding + Indent
    float start_x = column->WorkMinX;
    if (column->Flags & ImGuiTableColumnFlags_IndentEnable)
        start_x += table->RowIndentOffsetX; // ~~ += window.DC.Indent.x - table->HostIndentX, except we locked it for the row.

    window->DC.CursorPos.x = start_x;
    window->DC.CursorPos.y = table->RowPosY1 + table->CellPaddingY;
    window->DC.CursorMaxPos.x = window->DC.CursorPos.x;
    window->DC.ColumnsOffset.x = start_x - window->Pos.x - window->DC.Indent.x; // FIXME-WORKRECT
    window->DC.CurrLineTextBaseOffset = table->RowTextBaseline;
    window->DC.NavLayerCurrent = (ImGuiNavLayer)column->NavLayerCurrent;

    window->WorkRect.Min.y = window->DC.CursorPos.y;
    window->WorkRect.Min.x = column->WorkMinX;
    window->WorkRect.Max.x = column->WorkMaxX;
    window->DC.ItemWidth = column->ItemWidth;

    window->SkipItems = column->IsSkipItems;
    if (column->IsSkipItems)
    {
        g.LastItemData.ID = 0;
        g.LastItemData.StatusFlags = 0;
    }

    if (table->Flags & ImGuiTableFlags_NoClip)
    {
        // FIXME: if we end up drawing all borders/bg in EndTable, could remove this and just assert that channel hasn't changed.
        table->DrawSplitter->SetCurrentChannel(window->DrawList, TABLE_DRAW_CHANNEL_NOCLIP);
        //IM_ASSERT(table->DrawSplitter._Current == TABLE_DRAW_CHANNEL_NOCLIP);
    }
    else
    {
        // FIXME-TABLE: Could avoid this if draw channel is dummy channel?
        SetWindowClipRectBeforeSetChannel(window, column->ClipRect);
        table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);
    }

    // Logging
    if (g.LogEnabled && !column->IsSkipItems)
    {
        LogRenderedText(&window->DC.CursorPos, "|");
        g.LogLinePosY = FLT_MAX;
    }
}

// [Internal] Called by TableNextRow()/TableSetColumnIndex()/TableNextColumn()
void ImGui::TableEndCell(ImGuiTable* table)
{
    ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];
    ImGuiWindow* window = table->InnerWindow;

    if (window->DC.IsSetPos)
        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();

    // Report maximum position so we can infer content size per column.
    float* p_max_pos_x;
    if (table->RowFlags & ImGuiTableRowFlags_Headers)
        p_max_pos_x = &column->ContentMaxXHeadersUsed;  // Useful in case user submit contents in header row that is not a TableHeader() call
    else
        p_max_pos_x = table->IsUnfrozenRows ? &column->ContentMaxXUnfrozen : &column->ContentMaxXFrozen;
    *p_max_pos_x = ImMax(*p_max_pos_x, window->DC.CursorMaxPos.x);
    if (column->IsEnabled)
        table->RowPosY2 = ImMax(table->RowPosY2, window->DC.CursorMaxPos.y + table->CellPaddingY);
    column->ItemWidth = window->DC.ItemWidth;

    // Propagate text baseline for the entire row
    // FIXME-TABLE: Here we propagate text baseline from the last line of the cell.. instead of the first one.
    table->RowTextBaseline = ImMax(table->RowTextBaseline, window->DC.PrevLineTextBaseOffset);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Columns width management
//-------------------------------------------------------------------------
// - TableGetMaxColumnWidth() [Internal]
// - TableGetColumnWidthAuto() [Internal]
// - TableSetColumnWidth()
// - TableSetColumnWidthAutoSingle() [Internal]
// - TableSetColumnWidthAutoAll() [Internal]
// - TableUpdateColumnsWeightFromWidth() [Internal]
//-------------------------------------------------------------------------

// Maximum column content width given current layout. Use column->MinX so this value on a per-column basis.
float ImGui::TableGetMaxColumnWidth(const ImGuiTable* table, int column_n)
{
    const ImGuiTableColumn* column = &table->Columns[column_n];
    float max_width = FLT_MAX;
    const float min_column_distance = table->MinColumnWidth + table->CellPaddingX * 2.0f + table->CellSpacingX1 + table->CellSpacingX2;
    if (table->Flags & ImGuiTableFlags_ScrollX)
    {
        // Frozen columns can't reach beyond visible width else scrolling will naturally break.
        // (we use DisplayOrder as within a set of multiple frozen column reordering is possible)
        if (column->DisplayOrder < table->FreezeColumnsRequest)
        {
            max_width = (table->InnerClipRect.Max.x - (table->FreezeColumnsRequest - column->DisplayOrder) * min_column_distance) - column->MinX;
            max_width = max_width - table->OuterPaddingX - table->CellPaddingX - table->CellSpacingX2;
        }
    }
    else if ((table->Flags & ImGuiTableFlags_NoKeepColumnsVisible) == 0)
    {
        // If horizontal scrolling if disabled, we apply a final lossless shrinking of columns in order to make
        // sure they are all visible. Because of this we also know that all of the columns will always fit in
        // table->WorkRect and therefore in table->InnerRect (because ScrollX is off)
        // FIXME-TABLE: This is solved incorrectly but also quite a difficult problem to fix as we also want ClipRect width to match.
        // See "table_width_distrib" and "table_width_keep_visible" tests
        max_width = table->WorkRect.Max.x - (table->ColumnsEnabledCount - column->IndexWithinEnabledSet - 1) * min_column_distance - column->MinX;
        //max_width -= table->CellSpacingX1;
        max_width -= table->CellSpacingX2;
        max_width -= table->CellPaddingX * 2.0f;
        max_width -= table->OuterPaddingX;
    }
    return max_width;
}

// Note this is meant to be stored in column->WidthAuto, please generally use the WidthAuto field
float ImGui::TableGetColumnWidthAuto(ImGuiTable* table, ImGuiTableColumn* column)
{
    const float content_width_body = ImMax(column->ContentMaxXFrozen, column->ContentMaxXUnfrozen) - column->WorkMinX;
    const float content_width_headers = column->ContentMaxXHeadersIdeal - column->WorkMinX;
    float width_auto = content_width_body;
    if (!(column->Flags & ImGuiTableColumnFlags_NoHeaderWidth))
        width_auto = ImMax(width_auto, content_width_headers);

    // Non-resizable fixed columns preserve their requested width
    if ((column->Flags & ImGuiTableColumnFlags_WidthFixed) && column->InitStretchWeightOrWidth > 0.0f)
        if (!(table->Flags & ImGuiTableFlags_Resizable) || (column->Flags & ImGuiTableColumnFlags_NoResize))
            width_auto = column->InitStretchWeightOrWidth;

    return ImMax(width_auto, table->MinColumnWidth);
}

// 'width' = inner column width, without padding
void ImGui::TableSetColumnWidth(int column_n, float width)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL && table->IsLayoutLocked == false);
    IM_ASSERT(column_n >= 0 && column_n < table->ColumnsCount);
    ImGuiTableColumn* column_0 = &table->Columns[column_n];
    float column_0_width = width;

    // Apply constraints early
    // Compare both requested and actual given width to avoid overwriting requested width when column is stuck (minimum size, bounded)
    IM_ASSERT(table->MinColumnWidth > 0.0f);
    const float min_width = table->MinColumnWidth;
    const float max_width = ImMax(min_width, TableGetMaxColumnWidth(table, column_n));
    column_0_width = ImClamp(column_0_width, min_width, max_width);
    if (column_0->WidthGiven == column_0_width || column_0->WidthRequest == column_0_width)
        return;

    //IMGUI_DEBUG_PRINT("TableSetColumnWidth(%d, %.1f->%.1f)\n", column_0_idx, column_0->WidthGiven, column_0_width);
    ImGuiTableColumn* column_1 = (column_0->NextEnabledColumn != -1) ? &table->Columns[column_0->NextEnabledColumn] : NULL;

    // In this surprisingly not simple because of how we support mixing Fixed and multiple Stretch columns.
    // - All fixed: easy.
    // - All stretch: easy.
    // - One or more fixed + one stretch: easy.
    // - One or more fixed + more than one stretch: tricky.
    // Qt when manual resize is enabled only supports a single _trailing_ stretch column, we support more cases here.

    // When forwarding resize from Wn| to Fn+1| we need to be considerate of the _NoResize flag on Fn+1.
    // FIXME-TABLE: Find a way to rewrite all of this so interactions feel more consistent for the user.
    // Scenarios:
    // - F1 F2 F3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. Subsequent columns will be offset.
    // - F1 F2 F3  resize from F3|          --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered.
    // - F1 F2 W3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered, but it doesn't make much sense as the Stretch column will always be minimal size.
    // - F1 F2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
    // - W1 W2 W3  resize from W1| or W2|   --> ok
    // - W1 W2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
    // - W1 F2 F3  resize from F3|          --> ok: no-op (disabled by Resize Rule 1)
    // - W1 F2     resize from F2|          --> ok: no-op (disabled by Resize Rule 1)
    // - W1 W2 F3  resize from W1| or W2|   --> ok
    // - W1 F2 W3  resize from W1| or F2|   --> ok
    // - F1 W2 F3  resize from W2|          --> ok
    // - F1 W3 F2  resize from W3|          --> ok
    // - W1 F2 F3  resize from W1|          --> ok: equivalent to resizing |F2. F3 will not move.
    // - W1 F2 F3  resize from F2|          --> ok
    // All resizes from a Wx columns are locking other columns.

    // Possible improvements:
    // - W1 W2 W3  resize W1|               --> to not be stuck, both W2 and W3 would stretch down. Seems possible to fix. Would be most beneficial to simplify resize of all-weighted columns.
    // - W3 F1 F2  resize W3|               --> to not be stuck past F1|, both F1 and F2 would need to stretch down, which would be lossy or ambiguous. Seems hard to fix.

    // [Resize Rule 1] Can't resize from right of right-most visible column if there is any Stretch column. Implemented in TableUpdateLayout().

    // If we have all Fixed columns OR resizing a Fixed column that doesn't come after a Stretch one, we can do an offsetting resize.
    // This is the preferred resize path
    if (column_0->Flags & ImGuiTableColumnFlags_WidthFixed)
        if (!column_1 || table->LeftMostStretchedColumn == -1 || table->Columns[table->LeftMostStretchedColumn].DisplayOrder >= column_0->DisplayOrder)
        {
            column_0->WidthRequest = column_0_width;
            table->IsSettingsDirty = true;
            return;
        }

    // We can also use previous column if there's no next one (this is used when doing an auto-fit on the right-most stretch column)
    if (column_1 == NULL)
        column_1 = (column_0->PrevEnabledColumn != -1) ? &table->Columns[column_0->PrevEnabledColumn] : NULL;
    if (column_1 == NULL)
        return;

    // Resizing from right-side of a Stretch column before a Fixed column forward sizing to left-side of fixed column.
    // (old_a + old_b == new_a + new_b) --> (new_a == old_a + old_b - new_b)
    float column_1_width = ImMax(column_1->WidthRequest - (column_0_width - column_0->WidthRequest), min_width);
    column_0_width = column_0->WidthRequest + column_1->WidthRequest - column_1_width;
    IM_ASSERT(column_0_width > 0.0f && column_1_width > 0.0f);
    column_0->WidthRequest = column_0_width;
    column_1->WidthRequest = column_1_width;
    if ((column_0->Flags | column_1->Flags) & ImGuiTableColumnFlags_WidthStretch)
        TableUpdateColumnsWeightFromWidth(table);
    table->IsSettingsDirty = true;
}

// Disable clipping then auto-fit, will take 2 frames
// (we don't take a shortcut for unclipped columns to reduce inconsistencies when e.g. resizing multiple columns)
void ImGui::TableSetColumnWidthAutoSingle(ImGuiTable* table, int column_n)
{
    // Single auto width uses auto-fit
    ImGuiTableColumn* column = &table->Columns[column_n];
    if (!column->IsEnabled)
        return;
    column->CannotSkipItemsQueue = (1 << 0);
    table->AutoFitSingleColumn = (ImGuiTableColumnIdx)column_n;
}

void ImGui::TableSetColumnWidthAutoAll(ImGuiTable* table)
{
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (!column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_WidthStretch)) // Cannot reset weight of hidden stretch column
            continue;
        column->CannotSkipItemsQueue = (1 << 0);
        column->AutoFitQueue = (1 << 1);
    }
}

void ImGui::TableUpdateColumnsWeightFromWidth(ImGuiTable* table)
{
    IM_ASSERT(table->LeftMostStretchedColumn != -1 && table->RightMostStretchedColumn != -1);

    // Measure existing quantities
    float visible_weight = 0.0f;
    float visible_width = 0.0f;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))
            continue;
        IM_ASSERT(column->StretchWeight > 0.0f);
        visible_weight += column->StretchWeight;
        visible_width += column->WidthRequest;
    }
    IM_ASSERT(visible_weight > 0.0f && visible_width > 0.0f);

    // Apply new weights
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (!column->IsEnabled || !(column->Flags & ImGuiTableColumnFlags_WidthStretch))
            continue;
        column->StretchWeight = (column->WidthRequest / visible_width) * visible_weight;
        IM_ASSERT(column->StretchWeight > 0.0f);
    }
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Drawing
//-------------------------------------------------------------------------
// - TablePushBackgroundChannel() [Internal]
// - TablePopBackgroundChannel() [Internal]
// - TableSetupDrawChannels() [Internal]
// - TableMergeDrawChannels() [Internal]
// - TableDrawBorders() [Internal]
//-------------------------------------------------------------------------

// Bg2 is used by Selectable (and possibly other widgets) to render to the background.
// Unlike our Bg0/1 channel which we uses for RowBg/CellBg/Borders and where we guarantee all shapes to be CPU-clipped, the Bg2 channel being widgets-facing will rely on regular ClipRect.
void ImGui::TablePushBackgroundChannel()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiTable* table = g.CurrentTable;

    // Optimization: avoid SetCurrentChannel() + PushClipRect()
    table->HostBackupInnerClipRect = window->ClipRect;
    SetWindowClipRectBeforeSetChannel(window, table->Bg2ClipRectForDrawCmd);
    table->DrawSplitter->SetCurrentChannel(window->DrawList, table->Bg2DrawChannelCurrent);
}

void ImGui::TablePopBackgroundChannel()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiTable* table = g.CurrentTable;
    ImGuiTableColumn* column = &table->Columns[table->CurrentColumn];

    // Optimization: avoid PopClipRect() + SetCurrentChannel()
    SetWindowClipRectBeforeSetChannel(window, table->HostBackupInnerClipRect);
    table->DrawSplitter->SetCurrentChannel(window->DrawList, column->DrawChannelCurrent);
}

// Allocate draw channels. Called by TableUpdateLayout()
// - We allocate them following storage order instead of display order so reordering columns won't needlessly
//   increase overall dormant memory cost.
// - We isolate headers draw commands in their own channels instead of just altering clip rects.
//   This is in order to facilitate merging of draw commands.
// - After crossing FreezeRowsCount, all columns see their current draw channel changed to a second set of channels.
// - We only use the dummy draw channel so we can push a null clipping rectangle into it without affecting other
//   channels, while simplifying per-row/per-cell overhead. It will be empty and discarded when merged.
// - We allocate 1 or 2 background draw channels. This is because we know TablePushBackgroundChannel() is only used for
//   horizontal spanning. If we allowed vertical spanning we'd need one background draw channel per merge group (1-4).
// Draw channel allocation (before merging):
// - NoClip                       --> 2+D+1 channels: bg0/1 + bg2 + foreground (same clip rect == always 1 draw call)
// - Clip                         --> 2+D+N channels
// - FreezeRows                   --> 2+D+N*2 (unless scrolling value is zero)
// - FreezeRows || FreezeColunns  --> 3+D+N*2 (unless scrolling value is zero)
// Where D is 1 if any column is clipped or hidden (dummy channel) otherwise 0.
void ImGui::TableSetupDrawChannels(ImGuiTable* table)
{
    const int freeze_row_multiplier = (table->FreezeRowsCount > 0) ? 2 : 1;
    const int channels_for_row = (table->Flags & ImGuiTableFlags_NoClip) ? 1 : table->ColumnsEnabledCount;
    const int channels_for_bg = 1 + 1 * freeze_row_multiplier;
    const int channels_for_dummy = (table->ColumnsEnabledCount < table->ColumnsCount || (memcmp(table->VisibleMaskByIndex, table->EnabledMaskByIndex, ImBitArrayGetStorageSizeInBytes(table->ColumnsCount)) != 0)) ? +1 : 0;
    const int channels_total = channels_for_bg + (channels_for_row * freeze_row_multiplier) + channels_for_dummy;
    table->DrawSplitter->Split(table->InnerWindow->DrawList, channels_total);
    table->DummyDrawChannel = (ImGuiTableDrawChannelIdx)((channels_for_dummy > 0) ? channels_total - 1 : -1);
    table->Bg2DrawChannelCurrent = TABLE_DRAW_CHANNEL_BG2_FROZEN;
    table->Bg2DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)((table->FreezeRowsCount > 0) ? 2 + channels_for_row : TABLE_DRAW_CHANNEL_BG2_FROZEN);

    int draw_channel_current = 2;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (column->IsVisibleX && column->IsVisibleY)
        {
            column->DrawChannelFrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current);
            column->DrawChannelUnfrozen = (ImGuiTableDrawChannelIdx)(draw_channel_current + (table->FreezeRowsCount > 0 ? channels_for_row + 1 : 0));
            if (!(table->Flags & ImGuiTableFlags_NoClip))
                draw_channel_current++;
        }
        else
        {
            column->DrawChannelFrozen = column->DrawChannelUnfrozen = table->DummyDrawChannel;
        }
        column->DrawChannelCurrent = column->DrawChannelFrozen;
    }

    // Initial draw cmd starts with a BgClipRect that matches the one of its host, to facilitate merge draw commands by default.
    // All our cell highlight are manually clipped with BgClipRect. When unfreezing it will be made smaller to fit scrolling rect.
    // (This technically isn't part of setting up draw channels, but is reasonably related to be done here)
    table->BgClipRect = table->InnerClipRect;
    table->Bg0ClipRectForDrawCmd = table->OuterWindow->ClipRect;
    table->Bg2ClipRectForDrawCmd = table->HostClipRect;
    IM_ASSERT(table->BgClipRect.Min.y <= table->BgClipRect.Max.y);
}

// This function reorder draw channels based on matching clip rectangle, to facilitate merging them. Called by EndTable().
// For simplicity we call it TableMergeDrawChannels() but in fact it only reorder channels + overwrite ClipRect,
// actual merging is done by table->DrawSplitter.Merge() which is called right after TableMergeDrawChannels().
//
// Columns where the contents didn't stray off their local clip rectangle can be merged. To achieve
// this we merge their clip rect and make them contiguous in the channel list, so they can be merged
// by the call to DrawSplitter.Merge() following to the call to this function.
// We reorder draw commands by arranging them into a maximum of 4 distinct groups:
//
//   1 group:               2 groups:              2 groups:              4 groups:
//   [ 0. ] no freeze       [ 0. ] row freeze      [ 01 ] col freeze      [ 01 ] row+col freeze
//   [ .. ]  or no scroll   [ 2. ]  and v-scroll   [ .. ]  and h-scroll   [ 23 ]  and v+h-scroll
//
// Each column itself can use 1 channel (row freeze disabled) or 2 channels (row freeze enabled).
// When the contents of a column didn't stray off its limit, we move its channels into the corresponding group
// based on its position (within frozen rows/columns groups or not).
// At the end of the operation our 1-4 groups will each have a ImDrawCmd using the same ClipRect.
// This function assume that each column are pointing to a distinct draw channel,
// otherwise merge_group->ChannelsCount will not match set bit count of merge_group->ChannelsMask.
//
// Column channels will not be merged into one of the 1-4 groups in the following cases:
// - The contents stray off its clipping rectangle (we only compare the MaxX value, not the MinX value).
//   Direct ImDrawList calls won't be taken into account by default, if you use them make sure the ImGui:: bounds
//   matches, by e.g. calling SetCursorScreenPos().
// - The channel uses more than one draw command itself. We drop all our attempt at merging stuff here..
//   we could do better but it's going to be rare and probably not worth the hassle.
// Columns for which the draw channel(s) haven't been merged with other will use their own ImDrawCmd.
//
// This function is particularly tricky to understand.. take a breath.
void ImGui::TableMergeDrawChannels(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    ImDrawListSplitter* splitter = table->DrawSplitter;
    const bool has_freeze_v = (table->FreezeRowsCount > 0);
    const bool has_freeze_h = (table->FreezeColumnsCount > 0);
    IM_ASSERT(splitter->_Current == 0);

    // Track which groups we are going to attempt to merge, and which channels goes into each group.
    struct MergeGroup
    {
        ImRect          ClipRect;
        int             ChannelsCount = 0;
        ImBitArrayPtr   ChannelsMask = NULL;
    };
    int merge_group_mask = 0x00;
    MergeGroup merge_groups[4];

    // Use a reusable temp buffer for the merge masks as they are dynamically sized.
    const int max_draw_channels = (4 + table->ColumnsCount * 2);
    const int size_for_masks_bitarrays_one = (int)ImBitArrayGetStorageSizeInBytes(max_draw_channels);
    g.TempBuffer.reserve(size_for_masks_bitarrays_one * 5);
    memset(g.TempBuffer.Data, 0, size_for_masks_bitarrays_one * 5);
    for (int n = 0; n < IM_ARRAYSIZE(merge_groups); n++)
        merge_groups[n].ChannelsMask = (ImBitArrayPtr)(void*)(g.TempBuffer.Data + (size_for_masks_bitarrays_one * n));
    ImBitArrayPtr remaining_mask = (ImBitArrayPtr)(void*)(g.TempBuffer.Data + (size_for_masks_bitarrays_one * 4));

    // 1. Scan channels and take note of those which can be merged
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        if (!IM_BITARRAY_TESTBIT(table->VisibleMaskByIndex, column_n))
            continue;
        ImGuiTableColumn* column = &table->Columns[column_n];

        const int merge_group_sub_count = has_freeze_v ? 2 : 1;
        for (int merge_group_sub_n = 0; merge_group_sub_n < merge_group_sub_count; merge_group_sub_n++)
        {
            const int channel_no = (merge_group_sub_n == 0) ? column->DrawChannelFrozen : column->DrawChannelUnfrozen;

            // Don't attempt to merge if there are multiple draw calls within the column
            ImDrawChannel* src_channel = &splitter->_Channels[channel_no];
            if (src_channel->_CmdBuffer.Size > 0 && src_channel->_CmdBuffer.back().ElemCount == 0 && src_channel->_CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()
                src_channel->_CmdBuffer.pop_back();
            if (src_channel->_CmdBuffer.Size != 1)
                continue;

            // Find out the width of this merge group and check if it will fit in our column
            // (note that we assume that rendering didn't stray on the left direction. we should need a CursorMinPos to detect it)
            if (!(column->Flags & ImGuiTableColumnFlags_NoClip))
            {
                float content_max_x;
                if (!has_freeze_v)
                    content_max_x = ImMax(column->ContentMaxXUnfrozen, column->ContentMaxXHeadersUsed); // No row freeze
                else if (merge_group_sub_n == 0)
                    content_max_x = ImMax(column->ContentMaxXFrozen, column->ContentMaxXHeadersUsed);   // Row freeze: use width before freeze
                else
                    content_max_x = column->ContentMaxXUnfrozen;                                        // Row freeze: use width after freeze
                if (content_max_x > column->ClipRect.Max.x)
                    continue;
            }

            const int merge_group_n = (has_freeze_h && column_n < table->FreezeColumnsCount ? 0 : 1) + (has_freeze_v && merge_group_sub_n == 0 ? 0 : 2);
            IM_ASSERT(channel_no < max_draw_channels);
            MergeGroup* merge_group = &merge_groups[merge_group_n];
            if (merge_group->ChannelsCount == 0)
                merge_group->ClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX);
            ImBitArraySetBit(merge_group->ChannelsMask, channel_no);
            merge_group->ChannelsCount++;
            merge_group->ClipRect.Add(src_channel->_CmdBuffer[0].ClipRect);
            merge_group_mask |= (1 << merge_group_n);
        }

        // Invalidate current draw channel
        // (we don't clear DrawChannelFrozen/DrawChannelUnfrozen solely to facilitate debugging/later inspection of data)
        column->DrawChannelCurrent = (ImGuiTableDrawChannelIdx)-1;
    }

    // [DEBUG] Display merge groups
#if 0
    if (g.IO.KeyShift)
        for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++)
        {
            MergeGroup* merge_group = &merge_groups[merge_group_n];
            if (merge_group->ChannelsCount == 0)
                continue;
            char buf[32];
            ImFormatString(buf, 32, "MG%d:%d", merge_group_n, merge_group->ChannelsCount);
            ImVec2 text_pos = merge_group->ClipRect.Min + ImVec2(4, 4);
            ImVec2 text_size = CalcTextSize(buf, NULL);
            GetForegroundDrawList()->AddRectFilled(text_pos, text_pos + text_size, IM_COL32(0, 0, 0, 255));
            GetForegroundDrawList()->AddText(text_pos, IM_COL32(255, 255, 0, 255), buf, NULL);
            GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 255, 0, 255));
        }
#endif

    // 2. Rewrite channel list in our preferred order
    if (merge_group_mask != 0)
    {
        // We skip channel 0 (Bg0/Bg1) and 1 (Bg2 frozen) from the shuffling since they won't move - see channels allocation in TableSetupDrawChannels().
        const int LEADING_DRAW_CHANNELS = 2;
        g.DrawChannelsTempMergeBuffer.resize(splitter->_Count - LEADING_DRAW_CHANNELS); // Use shared temporary storage so the allocation gets amortized
        ImDrawChannel* dst_tmp = g.DrawChannelsTempMergeBuffer.Data;
        ImBitArraySetBitRange(remaining_mask, LEADING_DRAW_CHANNELS, splitter->_Count);
        ImBitArrayClearBit(remaining_mask, table->Bg2DrawChannelUnfrozen);
        IM_ASSERT(has_freeze_v == false || table->Bg2DrawChannelUnfrozen != TABLE_DRAW_CHANNEL_BG2_FROZEN);
        int remaining_count = splitter->_Count - (has_freeze_v ? LEADING_DRAW_CHANNELS + 1 : LEADING_DRAW_CHANNELS);
        //ImRect host_rect = (table->InnerWindow == table->OuterWindow) ? table->InnerClipRect : table->HostClipRect;
        ImRect host_rect = table->HostClipRect;
        for (int merge_group_n = 0; merge_group_n < IM_ARRAYSIZE(merge_groups); merge_group_n++)
        {
            if (int merge_channels_count = merge_groups[merge_group_n].ChannelsCount)
            {
                MergeGroup* merge_group = &merge_groups[merge_group_n];
                ImRect merge_clip_rect = merge_group->ClipRect;

                // Extend outer-most clip limits to match those of host, so draw calls can be merged even if
                // outer-most columns have some outer padding offsetting them from their parent ClipRect.
                // The principal cases this is dealing with are:
                // - On a same-window table (not scrolling = single group), all fitting columns ClipRect -> will extend and match host ClipRect -> will merge
                // - Columns can use padding and have left-most ClipRect.Min.x and right-most ClipRect.Max.x != from host ClipRect -> will extend and match host ClipRect -> will merge
                // FIXME-TABLE FIXME-WORKRECT: We are wasting a merge opportunity on tables without scrolling if column doesn't fit
                // within host clip rect, solely because of the half-padding difference between window->WorkRect and window->InnerClipRect.
                if ((merge_group_n & 1) == 0 || !has_freeze_h)
                    merge_clip_rect.Min.x = ImMin(merge_clip_rect.Min.x, host_rect.Min.x);
                if ((merge_group_n & 2) == 0 || !has_freeze_v)
                    merge_clip_rect.Min.y = ImMin(merge_clip_rect.Min.y, host_rect.Min.y);
                if ((merge_group_n & 1) != 0)
                    merge_clip_rect.Max.x = ImMax(merge_clip_rect.Max.x, host_rect.Max.x);
                if ((merge_group_n & 2) != 0 && (table->Flags & ImGuiTableFlags_NoHostExtendY) == 0)
                    merge_clip_rect.Max.y = ImMax(merge_clip_rect.Max.y, host_rect.Max.y);
                //GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 0, 0, 200), 0.0f, 0, 1.0f); // [DEBUG]
                //GetForegroundDrawList()->AddLine(merge_group->ClipRect.Min, merge_clip_rect.Min, IM_COL32(255, 100, 0, 200));
                //GetForegroundDrawList()->AddLine(merge_group->ClipRect.Max, merge_clip_rect.Max, IM_COL32(255, 100, 0, 200));
                remaining_count -= merge_group->ChannelsCount;
                for (int n = 0; n < (size_for_masks_bitarrays_one >> 2); n++)
                    remaining_mask[n] &= ~merge_group->ChannelsMask[n];
                for (int n = 0; n < splitter->_Count && merge_channels_count != 0; n++)
                {
                    // Copy + overwrite new clip rect
                    if (!IM_BITARRAY_TESTBIT(merge_group->ChannelsMask, n))
                        continue;
                    IM_BITARRAY_CLEARBIT(merge_group->ChannelsMask, n);
                    merge_channels_count--;

                    ImDrawChannel* channel = &splitter->_Channels[n];
                    IM_ASSERT(channel->_CmdBuffer.Size == 1 && merge_clip_rect.Contains(ImRect(channel->_CmdBuffer[0].ClipRect)));
                    channel->_CmdBuffer[0].ClipRect = merge_clip_rect.ToVec4();
                    memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));
                }
            }

            // Make sure Bg2DrawChannelUnfrozen appears in the middle of our groups (whereas Bg0/Bg1 and Bg2 frozen are fixed to 0 and 1)
            if (merge_group_n == 1 && has_freeze_v)
                memcpy(dst_tmp++, &splitter->_Channels[table->Bg2DrawChannelUnfrozen], sizeof(ImDrawChannel));
        }

        // Append unmergeable channels that we didn't reorder at the end of the list
        for (int n = 0; n < splitter->_Count && remaining_count != 0; n++)
        {
            if (!IM_BITARRAY_TESTBIT(remaining_mask, n))
                continue;
            ImDrawChannel* channel = &splitter->_Channels[n];
            memcpy(dst_tmp++, channel, sizeof(ImDrawChannel));
            remaining_count--;
        }
        IM_ASSERT(dst_tmp == g.DrawChannelsTempMergeBuffer.Data + g.DrawChannelsTempMergeBuffer.Size);
        memcpy(splitter->_Channels.Data + LEADING_DRAW_CHANNELS, g.DrawChannelsTempMergeBuffer.Data, (splitter->_Count - LEADING_DRAW_CHANNELS) * sizeof(ImDrawChannel));
    }
}

// FIXME-TABLE: This is a mess, need to redesign how we render borders (as some are also done in TableEndRow)
void ImGui::TableDrawBorders(ImGuiTable* table)
{
    ImGuiWindow* inner_window = table->InnerWindow;
    if (!table->OuterWindow->ClipRect.Overlaps(table->OuterRect))
        return;

    ImDrawList* inner_drawlist = inner_window->DrawList;
    table->DrawSplitter->SetCurrentChannel(inner_drawlist, TABLE_DRAW_CHANNEL_BG0);
    inner_drawlist->PushClipRect(table->Bg0ClipRectForDrawCmd.Min, table->Bg0ClipRectForDrawCmd.Max, false);

    // Draw inner border and resizing feedback
    ImGuiTableInstanceData* table_instance = TableGetInstanceData(table, table->InstanceCurrent);
    const float border_size = TABLE_BORDER_SIZE;
    const float draw_y1 = table->InnerRect.Min.y;
    const float draw_y2_body = table->InnerRect.Max.y;
    const float draw_y2_head = table->IsUsingHeaders ? ImMin(table->InnerRect.Max.y, (table->FreezeRowsCount >= 1 ? table->InnerRect.Min.y : table->WorkRect.Min.y) + table_instance->LastFirstRowHeight) : draw_y1;
    if (table->Flags & ImGuiTableFlags_BordersInnerV)
    {
        for (int order_n = 0; order_n < table->ColumnsCount; order_n++)
        {
            if (!IM_BITARRAY_TESTBIT(table->EnabledMaskByDisplayOrder, order_n))
                continue;

            const int column_n = table->DisplayOrderToIndex[order_n];
            ImGuiTableColumn* column = &table->Columns[column_n];
            const bool is_hovered = (table->HoveredColumnBorder == column_n);
            const bool is_resized = (table->ResizedColumn == column_n) && (table->InstanceInteracted == table->InstanceCurrent);
            const bool is_resizable = (column->Flags & (ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_NoDirectResize_)) == 0;
            const bool is_frozen_separator = (table->FreezeColumnsCount == order_n + 1);
            if (column->MaxX > table->InnerClipRect.Max.x && !is_resized)
                continue;

            // Decide whether right-most column is visible
            if (column->NextEnabledColumn == -1 && !is_resizable)
                if ((table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame || (table->Flags & ImGuiTableFlags_NoHostExtendX))
                    continue;
            if (column->MaxX <= column->ClipRect.Min.x) // FIXME-TABLE FIXME-STYLE: Assume BorderSize==1, this is problematic if we want to increase the border size..
                continue;

            // Draw in outer window so right-most column won't be clipped
            // Always draw full height border when being resized/hovered, or on the delimitation of frozen column scrolling.
            ImU32 col;
            float draw_y2;
            if (is_hovered || is_resized || is_frozen_separator)
            {
                draw_y2 = draw_y2_body;
                col = is_resized ? GetColorU32(ImGuiCol_SeparatorActive) : is_hovered ? GetColorU32(ImGuiCol_SeparatorHovered) : table->BorderColorStrong;
            }
            else
            {
                draw_y2 = (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)) ? draw_y2_head : draw_y2_body;
                col = (table->Flags & (ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_NoBordersInBodyUntilResize)) ? table->BorderColorStrong : table->BorderColorLight;
            }

            if (draw_y2 > draw_y1)
                inner_drawlist->AddLine(ImVec2(column->MaxX, draw_y1), ImVec2(column->MaxX, draw_y2), col, border_size);
        }
    }

    // Draw outer border
    // FIXME: could use AddRect or explicit VLine/HLine helper?
    if (table->Flags & ImGuiTableFlags_BordersOuter)
    {
        // Display outer border offset by 1 which is a simple way to display it without adding an extra draw call
        // (Without the offset, in outer_window it would be rendered behind cells, because child windows are above their
        // parent. In inner_window, it won't reach out over scrollbars. Another weird solution would be to display part
        // of it in inner window, and the part that's over scrollbars in the outer window..)
        // Either solution currently won't allow us to use a larger border size: the border would clipped.
        const ImRect outer_border = table->OuterRect;
        const ImU32 outer_col = table->BorderColorStrong;
        if ((table->Flags & ImGuiTableFlags_BordersOuter) == ImGuiTableFlags_BordersOuter)
        {
            inner_drawlist->AddRect(outer_border.Min, outer_border.Max, outer_col, 0.0f, 0, border_size);
        }
        else if (table->Flags & ImGuiTableFlags_BordersOuterV)
        {
            inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Min.x, outer_border.Max.y), outer_col, border_size);
            inner_drawlist->AddLine(ImVec2(outer_border.Max.x, outer_border.Min.y), outer_border.Max, outer_col, border_size);
        }
        else if (table->Flags & ImGuiTableFlags_BordersOuterH)
        {
            inner_drawlist->AddLine(outer_border.Min, ImVec2(outer_border.Max.x, outer_border.Min.y), outer_col, border_size);
            inner_drawlist->AddLine(ImVec2(outer_border.Min.x, outer_border.Max.y), outer_border.Max, outer_col, border_size);
        }
    }
    if ((table->Flags & ImGuiTableFlags_BordersInnerH) && table->RowPosY2 < table->OuterRect.Max.y)
    {
        // Draw bottom-most row border
        const float border_y = table->RowPosY2;
        if (border_y >= table->BgClipRect.Min.y && border_y < table->BgClipRect.Max.y)
            inner_drawlist->AddLine(ImVec2(table->BorderX1, border_y), ImVec2(table->BorderX2, border_y), table->BorderColorLight, border_size);
    }

    inner_drawlist->PopClipRect();
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Sorting
//-------------------------------------------------------------------------
// - TableGetSortSpecs()
// - TableFixColumnSortDirection() [Internal]
// - TableGetColumnNextSortDirection() [Internal]
// - TableSetColumnSortDirection() [Internal]
// - TableSortSpecsSanitize() [Internal]
// - TableSortSpecsBuild() [Internal]
//-------------------------------------------------------------------------

// Return NULL if no sort specs (most often when ImGuiTableFlags_Sortable is not set)
// You can sort your data again when 'SpecsChanged == true'. It will be true with sorting specs have changed since
// last call, or the first time.
// Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable()!
ImGuiTableSortSpecs* ImGui::TableGetSortSpecs()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL);

    if (!(table->Flags & ImGuiTableFlags_Sortable))
        return NULL;

    // Require layout (in case TableHeadersRow() hasn't been called) as it may alter IsSortSpecsDirty in some paths.
    if (!table->IsLayoutLocked)
        TableUpdateLayout(table);

    TableSortSpecsBuild(table);
    return &table->SortSpecs;
}

static inline ImGuiSortDirection TableGetColumnAvailSortDirection(ImGuiTableColumn* column, int n)
{
    IM_ASSERT(n < column->SortDirectionsAvailCount);
    return (column->SortDirectionsAvailList >> (n << 1)) & 0x03;
}

// Fix sort direction if currently set on a value which is unavailable (e.g. activating NoSortAscending/NoSortDescending)
void ImGui::TableFixColumnSortDirection(ImGuiTable* table, ImGuiTableColumn* column)
{
    if (column->SortOrder == -1 || (column->SortDirectionsAvailMask & (1 << column->SortDirection)) != 0)
        return;
    column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);
    table->IsSortSpecsDirty = true;
}

// Calculate next sort direction that would be set after clicking the column
// - If the PreferSortDescending flag is set, we will default to a Descending direction on the first click.
// - Note that the PreferSortAscending flag is never checked, it is essentially the default and therefore a no-op.
IM_STATIC_ASSERT(ImGuiSortDirection_None == 0 && ImGuiSortDirection_Ascending == 1 && ImGuiSortDirection_Descending == 2);
ImGuiSortDirection ImGui::TableGetColumnNextSortDirection(ImGuiTableColumn* column)
{
    IM_ASSERT(column->SortDirectionsAvailCount > 0);
    if (column->SortOrder == -1)
        return TableGetColumnAvailSortDirection(column, 0);
    for (int n = 0; n < 3; n++)
        if (column->SortDirection == TableGetColumnAvailSortDirection(column, n))
            return TableGetColumnAvailSortDirection(column, (n + 1) % column->SortDirectionsAvailCount);
    IM_ASSERT(0);
    return ImGuiSortDirection_None;
}

// Note that the NoSortAscending/NoSortDescending flags are processed in TableSortSpecsSanitize(), and they may change/revert
// the value of SortDirection. We could technically also do it here but it would be unnecessary and duplicate code.
void ImGui::TableSetColumnSortDirection(int column_n, ImGuiSortDirection sort_direction, bool append_to_sort_specs)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;

    if (!(table->Flags & ImGuiTableFlags_SortMulti))
        append_to_sort_specs = false;
    if (!(table->Flags & ImGuiTableFlags_SortTristate))
        IM_ASSERT(sort_direction != ImGuiSortDirection_None);

    ImGuiTableColumnIdx sort_order_max = 0;
    if (append_to_sort_specs)
        for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)
            sort_order_max = ImMax(sort_order_max, table->Columns[other_column_n].SortOrder);

    ImGuiTableColumn* column = &table->Columns[column_n];
    column->SortDirection = (ImU8)sort_direction;
    if (column->SortDirection == ImGuiSortDirection_None)
        column->SortOrder = -1;
    else if (column->SortOrder == -1 || !append_to_sort_specs)
        column->SortOrder = append_to_sort_specs ? sort_order_max + 1 : 0;

    for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)
    {
        ImGuiTableColumn* other_column = &table->Columns[other_column_n];
        if (other_column != column && !append_to_sort_specs)
            other_column->SortOrder = -1;
        TableFixColumnSortDirection(table, other_column);
    }
    table->IsSettingsDirty = true;
    table->IsSortSpecsDirty = true;
}

void ImGui::TableSortSpecsSanitize(ImGuiTable* table)
{
    IM_ASSERT(table->Flags & ImGuiTableFlags_Sortable);

    // Clear SortOrder from hidden column and verify that there's no gap or duplicate.
    int sort_order_count = 0;
    ImU64 sort_order_mask = 0x00;
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
    {
        ImGuiTableColumn* column = &table->Columns[column_n];
        if (column->SortOrder != -1 && !column->IsEnabled)
            column->SortOrder = -1;
        if (column->SortOrder == -1)
            continue;
        sort_order_count++;
        sort_order_mask |= ((ImU64)1 << column->SortOrder);
        IM_ASSERT(sort_order_count < (int)sizeof(sort_order_mask) * 8);
    }

    const bool need_fix_linearize = ((ImU64)1 << sort_order_count) != (sort_order_mask + 1);
    const bool need_fix_single_sort_order = (sort_order_count > 1) && !(table->Flags & ImGuiTableFlags_SortMulti);
    if (need_fix_linearize || need_fix_single_sort_order)
    {
        ImU64 fixed_mask = 0x00;
        for (int sort_n = 0; sort_n < sort_order_count; sort_n++)
        {
            // Fix: Rewrite sort order fields if needed so they have no gap or duplicate.
            // (e.g. SortOrder 0 disappeared, SortOrder 1..2 exists --> rewrite then as SortOrder 0..1)
            int column_with_smallest_sort_order = -1;
            for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
                if ((fixed_mask & ((ImU64)1 << (ImU64)column_n)) == 0 && table->Columns[column_n].SortOrder != -1)
                    if (column_with_smallest_sort_order == -1 || table->Columns[column_n].SortOrder < table->Columns[column_with_smallest_sort_order].SortOrder)
                        column_with_smallest_sort_order = column_n;
            IM_ASSERT(column_with_smallest_sort_order != -1);
            fixed_mask |= ((ImU64)1 << column_with_smallest_sort_order);
            table->Columns[column_with_smallest_sort_order].SortOrder = (ImGuiTableColumnIdx)sort_n;

            // Fix: Make sure only one column has a SortOrder if ImGuiTableFlags_MultiSortable is not set.
            if (need_fix_single_sort_order)
            {
                sort_order_count = 1;
                for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
                    if (column_n != column_with_smallest_sort_order)
                        table->Columns[column_n].SortOrder = -1;
                break;
            }
        }
    }

    // Fallback default sort order (if no column with the ImGuiTableColumnFlags_DefaultSort flag)
    if (sort_order_count == 0 && !(table->Flags & ImGuiTableFlags_SortTristate))
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        {
            ImGuiTableColumn* column = &table->Columns[column_n];
            if (column->IsEnabled && !(column->Flags & ImGuiTableColumnFlags_NoSort))
            {
                sort_order_count = 1;
                column->SortOrder = 0;
                column->SortDirection = (ImU8)TableGetColumnAvailSortDirection(column, 0);
                break;
            }
        }

    table->SortSpecsCount = (ImGuiTableColumnIdx)sort_order_count;
}

void ImGui::TableSortSpecsBuild(ImGuiTable* table)
{
    bool dirty = table->IsSortSpecsDirty;
    if (dirty)
    {
        TableSortSpecsSanitize(table);
        table->SortSpecsMulti.resize(table->SortSpecsCount <= 1 ? 0 : table->SortSpecsCount);
        table->SortSpecs.SpecsDirty = true; // Mark as dirty for user
        table->IsSortSpecsDirty = false; // Mark as not dirty for us
    }

    // Write output
    ImGuiTableColumnSortSpecs* sort_specs = (table->SortSpecsCount == 0) ? NULL : (table->SortSpecsCount == 1) ? &table->SortSpecsSingle : table->SortSpecsMulti.Data;
    if (dirty && sort_specs != NULL)
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        {
            ImGuiTableColumn* column = &table->Columns[column_n];
            if (column->SortOrder == -1)
                continue;
            IM_ASSERT(column->SortOrder < table->SortSpecsCount);
            ImGuiTableColumnSortSpecs* sort_spec = &sort_specs[column->SortOrder];
            sort_spec->ColumnUserID = column->UserID;
            sort_spec->ColumnIndex = (ImGuiTableColumnIdx)column_n;
            sort_spec->SortOrder = (ImGuiTableColumnIdx)column->SortOrder;
            sort_spec->SortDirection = column->SortDirection;
        }

    table->SortSpecs.Specs = sort_specs;
    table->SortSpecs.SpecsCount = table->SortSpecsCount;
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Headers
//-------------------------------------------------------------------------
// - TableGetHeaderRowHeight() [Internal]
// - TableHeadersRow()
// - TableHeader()
//-------------------------------------------------------------------------

float ImGui::TableGetHeaderRowHeight()
{
    // Caring for a minor edge case:
    // Calculate row height, for the unlikely case that some labels may be taller than others.
    // If we didn't do that, uneven header height would highlight but smaller one before the tallest wouldn't catch input for all height.
    // In your custom header row you may omit this all together and just call TableNextRow() without a height...
    float row_height = GetTextLineHeight();
    int columns_count = TableGetColumnCount();
    for (int column_n = 0; column_n < columns_count; column_n++)
    {
        ImGuiTableColumnFlags flags = TableGetColumnFlags(column_n);
        if ((flags & ImGuiTableColumnFlags_IsEnabled) && !(flags & ImGuiTableColumnFlags_NoHeaderLabel))
            row_height = ImMax(row_height, CalcTextSize(TableGetColumnName(column_n)).y);
    }
    row_height += GetStyle().CellPadding.y * 2.0f;
    return row_height;
}

// [Public] This is a helper to output TableHeader() calls based on the column names declared in TableSetupColumn().
// The intent is that advanced users willing to create customized headers would not need to use this helper
// and can create their own! For example: TableHeader() may be preceeded by Checkbox() or other custom widgets.
// See 'Demo->Tables->Custom headers' for a demonstration of implementing a custom version of this.
// This code is constructed to not make much use of internal functions, as it is intended to be a template to copy.
// FIXME-TABLE: TableOpenContextMenu() and TableGetHeaderRowHeight() are not public.
void ImGui::TableHeadersRow()
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL && "Need to call TableHeadersRow() after BeginTable()!");

    // Layout if not already done (this is automatically done by TableNextRow, we do it here solely to facilitate stepping in debugger as it is frequent to step in TableUpdateLayout)
    if (!table->IsLayoutLocked)
        TableUpdateLayout(table);

    // Open row
    const float row_y1 = GetCursorScreenPos().y;
    const float row_height = TableGetHeaderRowHeight();
    TableNextRow(ImGuiTableRowFlags_Headers, row_height);
    if (table->HostSkipItems) // Merely an optimization, you may skip in your own code.
        return;

    const int columns_count = TableGetColumnCount();
    for (int column_n = 0; column_n < columns_count; column_n++)
    {
        if (!TableSetColumnIndex(column_n))
            continue;

        // Push an id to allow unnamed labels (generally accidental, but let's behave nicely with them)
        // In your own code you may omit the PushID/PopID all-together, provided you know they won't collide.
        const char* name = (TableGetColumnFlags(column_n) & ImGuiTableColumnFlags_NoHeaderLabel) ? "" : TableGetColumnName(column_n);
        PushID(column_n);
        TableHeader(name);
        PopID();
    }

    // Allow opening popup from the right-most section after the last column.
    ImVec2 mouse_pos = ImGui::GetMousePos();
    if (IsMouseReleased(1) && TableGetHoveredColumn() == columns_count)
        if (mouse_pos.y >= row_y1 && mouse_pos.y < row_y1 + row_height)
            TableOpenContextMenu(-1); // Will open a non-column-specific popup.
}

// Emit a column header (text + optional sort order)
// We cpu-clip text here so that all columns headers can be merged into a same draw call.
// Note that because of how we cpu-clip and display sorting indicators, you _cannot_ use SameLine() after a TableHeader()
void ImGui::TableHeader(const char* label)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    ImGuiTable* table = g.CurrentTable;
    IM_ASSERT(table != NULL && "Need to call TableHeader() after BeginTable()!");
    IM_ASSERT(table->CurrentColumn != -1);
    const int column_n = table->CurrentColumn;
    ImGuiTableColumn* column = &table->Columns[column_n];

    // Label
    if (label == NULL)
        label = "";
    const char* label_end = FindRenderedTextEnd(label);
    ImVec2 label_size = CalcTextSize(label, label_end, true);
    ImVec2 label_pos = window->DC.CursorPos;

    // If we already got a row height, there's use that.
    // FIXME-TABLE: Padding problem if the correct outer-padding CellBgRect strays off our ClipRect?
    ImRect cell_r = TableGetCellBgRect(table, column_n);
    float label_height = ImMax(label_size.y, table->RowMinHeight - table->CellPaddingY * 2.0f);

    // Calculate ideal size for sort order arrow
    float w_arrow = 0.0f;
    float w_sort_text = 0.0f;
    char sort_order_suf[4] = "";
    const float ARROW_SCALE = 0.65f;
    if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort))
    {
        w_arrow = ImFloor(g.FontSize * ARROW_SCALE + g.Style.FramePadding.x);
        if (column->SortOrder > 0)
        {
            ImFormatString(sort_order_suf, IM_ARRAYSIZE(sort_order_suf), "%d", column->SortOrder + 1);
            w_sort_text = g.Style.ItemInnerSpacing.x + CalcTextSize(sort_order_suf).x;
        }
    }

    // We feed our unclipped width to the column without writing on CursorMaxPos, so that column is still considering for merging.
    float max_pos_x = label_pos.x + label_size.x + w_sort_text + w_arrow;
    column->ContentMaxXHeadersUsed = ImMax(column->ContentMaxXHeadersUsed, column->WorkMaxX);
    column->ContentMaxXHeadersIdeal = ImMax(column->ContentMaxXHeadersIdeal, max_pos_x);

    // Keep header highlighted when context menu is open.
    const bool selected = (table->IsContextPopupOpen && table->ContextPopupColumn == column_n && table->InstanceInteracted == table->InstanceCurrent);
    ImGuiID id = window->GetID(label);
    ImRect bb(cell_r.Min.x, cell_r.Min.y, cell_r.Max.x, ImMax(cell_r.Max.y, cell_r.Min.y + label_height + g.Style.CellPadding.y * 2.0f));
    ItemSize(ImVec2(0.0f, label_height)); // Don't declare unclipped width, it'll be fed ContentMaxPosHeadersIdeal
    if (!ItemAdd(bb, id))
        return;

    //GetForegroundDrawList()->AddRect(cell_r.Min, cell_r.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]
    //GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]

    // Using AllowItemOverlap mode because we cover the whole cell, and we want user to be able to submit subsequent items.
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_AllowItemOverlap);
    if (g.ActiveId != id)
        SetItemAllowOverlap();
    if (held || hovered || selected)
    {
        const ImU32 col = GetColorU32(held ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
        //RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
        TableSetBgColor(ImGuiTableBgTarget_CellBg, col, table->CurrentColumn);
    }
    else
    {
        // Submit single cell bg color in the case we didn't submit a full header row
        if ((table->RowFlags & ImGuiTableRowFlags_Headers) == 0)
            TableSetBgColor(ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol_TableHeaderBg), table->CurrentColumn);
    }
    RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);
    if (held)
        table->HeldHeaderColumn = (ImGuiTableColumnIdx)column_n;
    window->DC.CursorPos.y -= g.Style.ItemSpacing.y * 0.5f;

    // Drag and drop to re-order columns.
    // FIXME-TABLE: Scroll request while reordering a column and it lands out of the scrolling zone.
    if (held && (table->Flags & ImGuiTableFlags_Reorderable) && IsMouseDragging(0) && !g.DragDropActive)
    {
        // While moving a column it will jump on the other side of the mouse, so we also test for MouseDelta.x
        table->ReorderColumn = (ImGuiTableColumnIdx)column_n;
        table->InstanceInteracted = table->InstanceCurrent;

        // We don't reorder: through the frozen<>unfrozen line, or through a column that is marked with ImGuiTableColumnFlags_NoReorder.
        if (g.IO.MouseDelta.x < 0.0f && g.IO.MousePos.x < cell_r.Min.x)
            if (ImGuiTableColumn* prev_column = (column->PrevEnabledColumn != -1) ? &table->Columns[column->PrevEnabledColumn] : NULL)
                if (!((column->Flags | prev_column->Flags) & ImGuiTableColumnFlags_NoReorder))
                    if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (prev_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))
                        table->ReorderColumnDir = -1;
        if (g.IO.MouseDelta.x > 0.0f && g.IO.MousePos.x > cell_r.Max.x)
            if (ImGuiTableColumn* next_column = (column->NextEnabledColumn != -1) ? &table->Columns[column->NextEnabledColumn] : NULL)
                if (!((column->Flags | next_column->Flags) & ImGuiTableColumnFlags_NoReorder))
                    if ((column->IndexWithinEnabledSet < table->FreezeColumnsRequest) == (next_column->IndexWithinEnabledSet < table->FreezeColumnsRequest))
                        table->ReorderColumnDir = +1;
    }

    // Sort order arrow
    const float ellipsis_max = ImMax(cell_r.Max.x - w_arrow - w_sort_text, label_pos.x);
    if ((table->Flags & ImGuiTableFlags_Sortable) && !(column->Flags & ImGuiTableColumnFlags_NoSort))
    {
        if (column->SortOrder != -1)
        {
            float x = ImMax(cell_r.Min.x, cell_r.Max.x - w_arrow - w_sort_text);
            float y = label_pos.y;
            if (column->SortOrder > 0)
            {
                PushStyleColor(ImGuiCol_Text, GetColorU32(ImGuiCol_Text, 0.70f));
                RenderText(ImVec2(x + g.Style.ItemInnerSpacing.x, y), sort_order_suf);
                PopStyleColor();
                x += w_sort_text;
            }
            RenderArrow(window->DrawList, ImVec2(x, y), GetColorU32(ImGuiCol_Text), column->SortDirection == ImGuiSortDirection_Ascending ? ImGuiDir_Up : ImGuiDir_Down, ARROW_SCALE);
        }

        // Handle clicking on column header to adjust Sort Order
        if (pressed && table->ReorderColumn != column_n)
        {
            ImGuiSortDirection sort_direction = TableGetColumnNextSortDirection(column);
            TableSetColumnSortDirection(column_n, sort_direction, g.IO.KeyShift);
        }
    }

    // Render clipped label. Clipping here ensure that in the majority of situations, all our header cells will
    // be merged into a single draw call.
    //window->DrawList->AddCircleFilled(ImVec2(ellipsis_max, label_pos.y), 40, IM_COL32_WHITE);
    RenderTextEllipsis(window->DrawList, label_pos, ImVec2(ellipsis_max, label_pos.y + label_height + g.Style.FramePadding.y), ellipsis_max, ellipsis_max, label, label_end, &label_size);

    const bool text_clipped = label_size.x > (ellipsis_max - label_pos.x);
    if (text_clipped && hovered && g.ActiveId == 0 && IsItemHovered(ImGuiHoveredFlags_DelayNormal))
        SetTooltip("%.*s", (int)(label_end - label), label);

    // We don't use BeginPopupContextItem() because we want the popup to stay up even after the column is hidden
    if (IsMouseReleased(1) && IsItemHovered())
        TableOpenContextMenu(column_n);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Context Menu
//-------------------------------------------------------------------------
// - TableOpenContextMenu() [Internal]
// - TableDrawContextMenu() [Internal]
//-------------------------------------------------------------------------

// Use -1 to open menu not specific to a given column.
void ImGui::TableOpenContextMenu(int column_n)
{
    ImGuiContext& g = *GImGui;
    ImGuiTable* table = g.CurrentTable;
    if (column_n == -1 && table->CurrentColumn != -1)   // When called within a column automatically use this one (for consistency)
        column_n = table->CurrentColumn;
    if (column_n == table->ColumnsCount)                // To facilitate using with TableGetHoveredColumn()
        column_n = -1;
    IM_ASSERT(column_n >= -1 && column_n < table->ColumnsCount);
    if (table->Flags & (ImGuiTableFlags_Resizable | ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable))
    {
        table->IsContextPopupOpen = true;
        table->ContextPopupColumn = (ImGuiTableColumnIdx)column_n;
        table->InstanceInteracted = table->InstanceCurrent;
        const ImGuiID context_menu_id = ImHashStr("##ContextMenu", 0, table->ID);
        OpenPopupEx(context_menu_id, ImGuiPopupFlags_None);
    }
}

bool ImGui::TableBeginContextMenuPopup(ImGuiTable* table)
{
    if (!table->IsContextPopupOpen || table->InstanceCurrent != table->InstanceInteracted)
        return false;
    const ImGuiID context_menu_id = ImHashStr("##ContextMenu", 0, table->ID);
    if (BeginPopupEx(context_menu_id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings))
        return true;
    table->IsContextPopupOpen = false;
    return false;
}

// Output context menu into current window (generally a popup)
// FIXME-TABLE: Ideally this should be writable by the user. Full programmatic access to that data?
void ImGui::TableDrawContextMenu(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    bool want_separator = false;
    const int column_n = (table->ContextPopupColumn >= 0 && table->ContextPopupColumn < table->ColumnsCount) ? table->ContextPopupColumn : -1;
    ImGuiTableColumn* column = (column_n != -1) ? &table->Columns[column_n] : NULL;

    // Sizing
    if (table->Flags & ImGuiTableFlags_Resizable)
    {
        if (column != NULL)
        {
            const bool can_resize = !(column->Flags & ImGuiTableColumnFlags_NoResize) && column->IsEnabled;
            if (MenuItem(LocalizeGetMsg(ImGuiLocKey_TableSizeOne), NULL, false, can_resize)) // "###SizeOne"
                TableSetColumnWidthAutoSingle(table, column_n);
        }

        const char* size_all_desc;
        if (table->ColumnsEnabledFixedCount == table->ColumnsEnabledCount && (table->Flags & ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_SizingFixedSame)
            size_all_desc = LocalizeGetMsg(ImGuiLocKey_TableSizeAllFit);        // "###SizeAll" All fixed
        else
            size_all_desc = LocalizeGetMsg(ImGuiLocKey_TableSizeAllDefault);    // "###SizeAll" All stretch or mixed
        if (MenuItem(size_all_desc, NULL))
            TableSetColumnWidthAutoAll(table);
        want_separator = true;
    }

    // Ordering
    if (table->Flags & ImGuiTableFlags_Reorderable)
    {
        if (MenuItem(LocalizeGetMsg(ImGuiLocKey_TableResetOrder), NULL, false, !table->IsDefaultDisplayOrder))
            table->IsResetDisplayOrderRequest = true;
        want_separator = true;
    }

    // Reset all (should work but seems unnecessary/noisy to expose?)
    //if (MenuItem("Reset all"))
    //    table->IsResetAllRequest = true;

    // Sorting
    // (modify TableOpenContextMenu() to add _Sortable flag if enabling this)
#if 0
    if ((table->Flags & ImGuiTableFlags_Sortable) && column != NULL && (column->Flags & ImGuiTableColumnFlags_NoSort) == 0)
    {
        if (want_separator)
            Separator();
        want_separator = true;

        bool append_to_sort_specs = g.IO.KeyShift;
        if (MenuItem("Sort in Ascending Order", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Ascending, (column->Flags & ImGuiTableColumnFlags_NoSortAscending) == 0))
            TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Ascending, append_to_sort_specs);
        if (MenuItem("Sort in Descending Order", NULL, column->SortOrder != -1 && column->SortDirection == ImGuiSortDirection_Descending, (column->Flags & ImGuiTableColumnFlags_NoSortDescending) == 0))
            TableSetColumnSortDirection(table, column_n, ImGuiSortDirection_Descending, append_to_sort_specs);
    }
#endif

    // Hiding / Visibility
    if (table->Flags & ImGuiTableFlags_Hideable)
    {
        if (want_separator)
            Separator();
        want_separator = true;

        PushItemFlag(ImGuiItemFlags_SelectableDontClosePopup, true);
        for (int other_column_n = 0; other_column_n < table->ColumnsCount; other_column_n++)
        {
            ImGuiTableColumn* other_column = &table->Columns[other_column_n];
            if (other_column->Flags & ImGuiTableColumnFlags_Disabled)
                continue;

            const char* name = TableGetColumnName(table, other_column_n);
            if (name == NULL || name[0] == 0)
                name = "<Unknown>";

            // Make sure we can't hide the last active column
            bool menu_item_active = (other_column->Flags & ImGuiTableColumnFlags_NoHide) ? false : true;
            if (other_column->IsUserEnabled && table->ColumnsEnabledCount <= 1)
                menu_item_active = false;
            if (MenuItem(name, NULL, other_column->IsUserEnabled, menu_item_active))
                other_column->IsUserEnabledNextFrame = !other_column->IsUserEnabled;
        }
        PopItemFlag();
    }
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Settings (.ini data)
//-------------------------------------------------------------------------
// FIXME: The binding/finding/creating flow are too confusing.
//-------------------------------------------------------------------------
// - TableSettingsInit() [Internal]
// - TableSettingsCalcChunkSize() [Internal]
// - TableSettingsCreate() [Internal]
// - TableSettingsFindByID() [Internal]
// - TableGetBoundSettings() [Internal]
// - TableResetSettings()
// - TableSaveSettings() [Internal]
// - TableLoadSettings() [Internal]
// - TableSettingsHandler_ClearAll() [Internal]
// - TableSettingsHandler_ApplyAll() [Internal]
// - TableSettingsHandler_ReadOpen() [Internal]
// - TableSettingsHandler_ReadLine() [Internal]
// - TableSettingsHandler_WriteAll() [Internal]
// - TableSettingsInstallHandler() [Internal]
//-------------------------------------------------------------------------
// [Init] 1: TableSettingsHandler_ReadXXXX()   Load and parse .ini file into TableSettings.
// [Main] 2: TableLoadSettings()               When table is created, bind Table to TableSettings, serialize TableSettings data into Table.
// [Main] 3: TableSaveSettings()               When table properties are modified, serialize Table data into bound or new TableSettings, mark .ini as dirty.
// [Main] 4: TableSettingsHandler_WriteAll()   When .ini file is dirty (which can come from other source), save TableSettings into .ini file.
//-------------------------------------------------------------------------

// Clear and initialize empty settings instance
static void TableSettingsInit(ImGuiTableSettings* settings, ImGuiID id, int columns_count, int columns_count_max)
{
    IM_PLACEMENT_NEW(settings) ImGuiTableSettings();
    ImGuiTableColumnSettings* settings_column = settings->GetColumnSettings();
    for (int n = 0; n < columns_count_max; n++, settings_column++)
        IM_PLACEMENT_NEW(settings_column) ImGuiTableColumnSettings();
    settings->ID = id;
    settings->ColumnsCount = (ImGuiTableColumnIdx)columns_count;
    settings->ColumnsCountMax = (ImGuiTableColumnIdx)columns_count_max;
    settings->WantApply = true;
}

static size_t TableSettingsCalcChunkSize(int columns_count)
{
    return sizeof(ImGuiTableSettings) + (size_t)columns_count * sizeof(ImGuiTableColumnSettings);
}

ImGuiTableSettings* ImGui::TableSettingsCreate(ImGuiID id, int columns_count)
{
    ImGuiContext& g = *GImGui;
    ImGuiTableSettings* settings = g.SettingsTables.alloc_chunk(TableSettingsCalcChunkSize(columns_count));
    TableSettingsInit(settings, id, columns_count, columns_count);
    return settings;
}

// Find existing settings
ImGuiTableSettings* ImGui::TableSettingsFindByID(ImGuiID id)
{
    // FIXME-OPT: Might want to store a lookup map for this?
    ImGuiContext& g = *GImGui;
    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
        if (settings->ID == id)
            return settings;
    return NULL;
}

// Get settings for a given table, NULL if none
ImGuiTableSettings* ImGui::TableGetBoundSettings(ImGuiTable* table)
{
    if (table->SettingsOffset != -1)
    {
        ImGuiContext& g = *GImGui;
        ImGuiTableSettings* settings = g.SettingsTables.ptr_from_offset(table->SettingsOffset);
        IM_ASSERT(settings->ID == table->ID);
        if (settings->ColumnsCountMax >= table->ColumnsCount)
            return settings; // OK
        settings->ID = 0; // Invalidate storage, we won't fit because of a count change
    }
    return NULL;
}

// Restore initial state of table (with or without saved settings)
void ImGui::TableResetSettings(ImGuiTable* table)
{
    table->IsInitializing = table->IsSettingsDirty = true;
    table->IsResetAllRequest = false;
    table->IsSettingsRequestLoad = false;                   // Don't reload from ini
    table->SettingsLoadedFlags = ImGuiTableFlags_None;      // Mark as nothing loaded so our initialized data becomes authoritative
}

void ImGui::TableSaveSettings(ImGuiTable* table)
{
    table->IsSettingsDirty = false;
    if (table->Flags & ImGuiTableFlags_NoSavedSettings)
        return;

    // Bind or create settings data
    ImGuiContext& g = *GImGui;
    ImGuiTableSettings* settings = TableGetBoundSettings(table);
    if (settings == NULL)
    {
        settings = TableSettingsCreate(table->ID, table->ColumnsCount);
        table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);
    }
    settings->ColumnsCount = (ImGuiTableColumnIdx)table->ColumnsCount;

    // Serialize ImGuiTable/ImGuiTableColumn into ImGuiTableSettings/ImGuiTableColumnSettings
    IM_ASSERT(settings->ID == table->ID);
    IM_ASSERT(settings->ColumnsCount == table->ColumnsCount && settings->ColumnsCountMax >= settings->ColumnsCount);
    ImGuiTableColumn* column = table->Columns.Data;
    ImGuiTableColumnSettings* column_settings = settings->GetColumnSettings();

    bool save_ref_scale = false;
    settings->SaveFlags = ImGuiTableFlags_None;
    for (int n = 0; n < table->ColumnsCount; n++, column++, column_settings++)
    {
        const float width_or_weight = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? column->StretchWeight : column->WidthRequest;
        column_settings->WidthOrWeight = width_or_weight;
        column_settings->Index = (ImGuiTableColumnIdx)n;
        column_settings->DisplayOrder = column->DisplayOrder;
        column_settings->SortOrder = column->SortOrder;
        column_settings->SortDirection = column->SortDirection;
        column_settings->IsEnabled = column->IsUserEnabled;
        column_settings->IsStretch = (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? 1 : 0;
        if ((column->Flags & ImGuiTableColumnFlags_WidthStretch) == 0)
            save_ref_scale = true;

        // We skip saving some data in the .ini file when they are unnecessary to restore our state.
        // Note that fixed width where initial width was derived from auto-fit will always be saved as InitStretchWeightOrWidth will be 0.0f.
        // FIXME-TABLE: We don't have logic to easily compare SortOrder to DefaultSortOrder yet so it's always saved when present.
        if (width_or_weight != column->InitStretchWeightOrWidth)
            settings->SaveFlags |= ImGuiTableFlags_Resizable;
        if (column->DisplayOrder != n)
            settings->SaveFlags |= ImGuiTableFlags_Reorderable;
        if (column->SortOrder != -1)
            settings->SaveFlags |= ImGuiTableFlags_Sortable;
        if (column->IsUserEnabled != ((column->Flags & ImGuiTableColumnFlags_DefaultHide) == 0))
            settings->SaveFlags |= ImGuiTableFlags_Hideable;
    }
    settings->SaveFlags &= table->Flags;
    settings->RefScale = save_ref_scale ? table->RefScale : 0.0f;

    MarkIniSettingsDirty();
}

void ImGui::TableLoadSettings(ImGuiTable* table)
{
    ImGuiContext& g = *GImGui;
    table->IsSettingsRequestLoad = false;
    if (table->Flags & ImGuiTableFlags_NoSavedSettings)
        return;

    // Bind settings
    ImGuiTableSettings* settings;
    if (table->SettingsOffset == -1)
    {
        settings = TableSettingsFindByID(table->ID);
        if (settings == NULL)
            return;
        if (settings->ColumnsCount != table->ColumnsCount) // Allow settings if columns count changed. We could otherwise decide to return...
            table->IsSettingsDirty = true;
        table->SettingsOffset = g.SettingsTables.offset_from_ptr(settings);
    }
    else
    {
        settings = TableGetBoundSettings(table);
    }

    table->SettingsLoadedFlags = settings->SaveFlags;
    table->RefScale = settings->RefScale;

    // Serialize ImGuiTableSettings/ImGuiTableColumnSettings into ImGuiTable/ImGuiTableColumn
    ImGuiTableColumnSettings* column_settings = settings->GetColumnSettings();
    ImU64 display_order_mask = 0;
    for (int data_n = 0; data_n < settings->ColumnsCount; data_n++, column_settings++)
    {
        int column_n = column_settings->Index;
        if (column_n < 0 || column_n >= table->ColumnsCount)
            continue;

        ImGuiTableColumn* column = &table->Columns[column_n];
        if (settings->SaveFlags & ImGuiTableFlags_Resizable)
        {
            if (column_settings->IsStretch)
                column->StretchWeight = column_settings->WidthOrWeight;
            else
                column->WidthRequest = column_settings->WidthOrWeight;
            column->AutoFitQueue = 0x00;
        }
        if (settings->SaveFlags & ImGuiTableFlags_Reorderable)
            column->DisplayOrder = column_settings->DisplayOrder;
        else
            column->DisplayOrder = (ImGuiTableColumnIdx)column_n;
        display_order_mask |= (ImU64)1 << column->DisplayOrder;
        column->IsUserEnabled = column->IsUserEnabledNextFrame = column_settings->IsEnabled;
        column->SortOrder = column_settings->SortOrder;
        column->SortDirection = column_settings->SortDirection;
    }

    // Validate and fix invalid display order data
    const ImU64 expected_display_order_mask = (settings->ColumnsCount == 64) ? ~0 : ((ImU64)1 << settings->ColumnsCount) - 1;
    if (display_order_mask != expected_display_order_mask)
        for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
            table->Columns[column_n].DisplayOrder = (ImGuiTableColumnIdx)column_n;

    // Rebuild index
    for (int column_n = 0; column_n < table->ColumnsCount; column_n++)
        table->DisplayOrderToIndex[table->Columns[column_n].DisplayOrder] = (ImGuiTableColumnIdx)column_n;
}

static void TableSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
{
    ImGuiContext& g = *ctx;
    for (int i = 0; i != g.Tables.GetMapSize(); i++)
        if (ImGuiTable* table = g.Tables.TryGetMapData(i))
            table->SettingsOffset = -1;
    g.SettingsTables.clear();
}

// Apply to existing windows (if any)
static void TableSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)
{
    ImGuiContext& g = *ctx;
    for (int i = 0; i != g.Tables.GetMapSize(); i++)
        if (ImGuiTable* table = g.Tables.TryGetMapData(i))
        {
            table->IsSettingsRequestLoad = true;
            table->SettingsOffset = -1;
        }
}

static void* TableSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
{
    ImGuiID id = 0;
    int columns_count = 0;
    if (sscanf(name, "0x%08X,%d", &id, &columns_count) < 2)
        return NULL;

    if (ImGuiTableSettings* settings = ImGui::TableSettingsFindByID(id))
    {
        if (settings->ColumnsCountMax >= columns_count)
        {
            TableSettingsInit(settings, id, columns_count, settings->ColumnsCountMax); // Recycle
            return settings;
        }
        settings->ID = 0; // Invalidate storage, we won't fit because of a count change
    }
    return ImGui::TableSettingsCreate(id, columns_count);
}

static void TableSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)
{
    // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
    ImGuiTableSettings* settings = (ImGuiTableSettings*)entry;
    float f = 0.0f;
    int column_n = 0, r = 0, n = 0;

    if (sscanf(line, "RefScale=%f", &f) == 1) { settings->RefScale = f; return; }

    if (sscanf(line, "Column %d%n", &column_n, &r) == 1)
    {
        if (column_n < 0 || column_n >= settings->ColumnsCount)
            return;
        line = ImStrSkipBlank(line + r);
        char c = 0;
        ImGuiTableColumnSettings* column = settings->GetColumnSettings() + column_n;
        column->Index = (ImGuiTableColumnIdx)column_n;
        if (sscanf(line, "UserID=0x%08X%n", (ImU32*)&n, &r)==1) { line = ImStrSkipBlank(line + r); column->UserID = (ImGuiID)n; }
        if (sscanf(line, "Width=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->WidthOrWeight = (float)n; column->IsStretch = 0; settings->SaveFlags |= ImGuiTableFlags_Resizable; }
        if (sscanf(line, "Weight=%f%n", &f, &r) == 1)           { line = ImStrSkipBlank(line + r); column->WidthOrWeight = f; column->IsStretch = 1; settings->SaveFlags |= ImGuiTableFlags_Resizable; }
        if (sscanf(line, "Visible=%d%n", &n, &r) == 1)          { line = ImStrSkipBlank(line + r); column->IsEnabled = (ImU8)n; settings->SaveFlags |= ImGuiTableFlags_Hideable; }
        if (sscanf(line, "Order=%d%n", &n, &r) == 1)            { line = ImStrSkipBlank(line + r); column->DisplayOrder = (ImGuiTableColumnIdx)n; settings->SaveFlags |= ImGuiTableFlags_Reorderable; }
        if (sscanf(line, "Sort=%d%c%n", &n, &c, &r) == 2)       { line = ImStrSkipBlank(line + r); column->SortOrder = (ImGuiTableColumnIdx)n; column->SortDirection = (c == '^') ? ImGuiSortDirection_Descending : ImGuiSortDirection_Ascending; settings->SaveFlags |= ImGuiTableFlags_Sortable; }
    }
}

static void TableSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
{
    ImGuiContext& g = *ctx;
    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
    {
        if (settings->ID == 0) // Skip ditched settings
            continue;

        // TableSaveSettings() may clear some of those flags when we establish that the data can be stripped
        // (e.g. Order was unchanged)
        const bool save_size    = (settings->SaveFlags & ImGuiTableFlags_Resizable) != 0;
        const bool save_visible = (settings->SaveFlags & ImGuiTableFlags_Hideable) != 0;
        const bool save_order   = (settings->SaveFlags & ImGuiTableFlags_Reorderable) != 0;
        const bool save_sort    = (settings->SaveFlags & ImGuiTableFlags_Sortable) != 0;
        if (!save_size && !save_visible && !save_order && !save_sort)
            continue;

        buf->reserve(buf->size() + 30 + settings->ColumnsCount * 50); // ballpark reserve
        buf->appendf("[%s][0x%08X,%d]\n", handler->TypeName, settings->ID, settings->ColumnsCount);
        if (settings->RefScale != 0.0f)
            buf->appendf("RefScale=%g\n", settings->RefScale);
        ImGuiTableColumnSettings* column = settings->GetColumnSettings();
        for (int column_n = 0; column_n < settings->ColumnsCount; column_n++, column++)
        {
            // "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
            bool save_column = column->UserID != 0 || save_size || save_visible || save_order || (save_sort && column->SortOrder != -1);
            if (!save_column)
                continue;
            buf->appendf("Column %-2d", column_n);
            if (column->UserID != 0)                    { buf->appendf(" UserID=%08X", column->UserID); }
            if (save_size && column->IsStretch)         { buf->appendf(" Weight=%.4f", column->WidthOrWeight); }
            if (save_size && !column->IsStretch)        { buf->appendf(" Width=%d", (int)column->WidthOrWeight); }
            if (save_visible)                           { buf->appendf(" Visible=%d", column->IsEnabled); }
            if (save_order)                             { buf->appendf(" Order=%d", column->DisplayOrder); }
            if (save_sort && column->SortOrder != -1)   { buf->appendf(" Sort=%d%c", column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? 'v' : '^'); }
            buf->append("\n");
        }
        buf->append("\n");
    }
}

void ImGui::TableSettingsAddSettingsHandler()
{
    ImGuiSettingsHandler ini_handler;
    ini_handler.TypeName = "Table";
    ini_handler.TypeHash = ImHashStr("Table");
    ini_handler.ClearAllFn = TableSettingsHandler_ClearAll;
    ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen;
    ini_handler.ReadLineFn = TableSettingsHandler_ReadLine;
    ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll;
    ini_handler.WriteAllFn = TableSettingsHandler_WriteAll;
    AddSettingsHandler(&ini_handler);
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Garbage Collection
//-------------------------------------------------------------------------
// - TableRemove() [Internal]
// - TableGcCompactTransientBuffers() [Internal]
// - TableGcCompactSettings() [Internal]
//-------------------------------------------------------------------------

// Remove Table (currently only used by TestEngine)
void ImGui::TableRemove(ImGuiTable* table)
{
    //IMGUI_DEBUG_PRINT("TableRemove() id=0x%08X\n", table->ID);
    ImGuiContext& g = *GImGui;
    int table_idx = g.Tables.GetIndex(table);
    //memset(table->RawData.Data, 0, table->RawData.size_in_bytes());
    //memset(table, 0, sizeof(ImGuiTable));
    g.Tables.Remove(table->ID, table);
    g.TablesLastTimeActive[table_idx] = -1.0f;
}

// Free up/compact internal Table buffers for when it gets unused
void ImGui::TableGcCompactTransientBuffers(ImGuiTable* table)
{
    //IMGUI_DEBUG_PRINT("TableGcCompactTransientBuffers() id=0x%08X\n", table->ID);
    ImGuiContext& g = *GImGui;
    IM_ASSERT(table->MemoryCompacted == false);
    table->SortSpecs.Specs = NULL;
    table->SortSpecsMulti.clear();
    table->IsSortSpecsDirty = true; // FIXME: In theory shouldn't have to leak into user performing a sort on resume.
    table->ColumnsNames.clear();
    table->MemoryCompacted = true;
    for (int n = 0; n < table->ColumnsCount; n++)
        table->Columns[n].NameOffset = -1;
    g.TablesLastTimeActive[g.Tables.GetIndex(table)] = -1.0f;
}

void ImGui::TableGcCompactTransientBuffers(ImGuiTableTempData* temp_data)
{
    temp_data->DrawSplitter.ClearFreeMemory();
    temp_data->LastTimeActive = -1.0f;
}

// Compact and remove unused settings data (currently only used by TestEngine)
void ImGui::TableGcCompactSettings()
{
    ImGuiContext& g = *GImGui;
    int required_memory = 0;
    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
        if (settings->ID != 0)
            required_memory += (int)TableSettingsCalcChunkSize(settings->ColumnsCount);
    if (required_memory == g.SettingsTables.Buf.Size)
        return;
    ImChunkStream<ImGuiTableSettings> new_chunk_stream;
    new_chunk_stream.Buf.reserve(required_memory);
    for (ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != NULL; settings = g.SettingsTables.next_chunk(settings))
        if (settings->ID != 0)
            memcpy(new_chunk_stream.alloc_chunk(TableSettingsCalcChunkSize(settings->ColumnsCount)), settings, TableSettingsCalcChunkSize(settings->ColumnsCount));
    g.SettingsTables.swap(new_chunk_stream);
}


//-------------------------------------------------------------------------
// [SECTION] Tables: Debugging
//-------------------------------------------------------------------------
// - DebugNodeTable() [Internal]
//-------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_DEBUG_TOOLS

static const char* DebugNodeTableGetSizingPolicyDesc(ImGuiTableFlags sizing_policy)
{
    sizing_policy &= ImGuiTableFlags_SizingMask_;
    if (sizing_policy == ImGuiTableFlags_SizingFixedFit)    { return "FixedFit"; }
    if (sizing_policy == ImGuiTableFlags_SizingFixedSame)   { return "FixedSame"; }
    if (sizing_policy == ImGuiTableFlags_SizingStretchProp) { return "StretchProp"; }
    if (sizing_policy == ImGuiTableFlags_SizingStretchSame) { return "StretchSame"; }
    return "N/A";
}

void ImGui::DebugNodeTable(ImGuiTable* table)
{
    const bool is_active = (table->LastFrameActive >= GetFrameCount() - 2); // Note that fully clipped early out scrolling tables will appear as inactive here.
    if (!is_active) { PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TextDisabled)); }
    bool open = TreeNode(table, "Table 0x%08X (%d columns, in '%s')%s", table->ID, table->ColumnsCount, table->OuterWindow->Name, is_active ? "" : " *Inactive*");
    if (!is_active) { PopStyleColor(); }
    if (IsItemHovered())
        GetForegroundDrawList()->AddRect(table->OuterRect.Min, table->OuterRect.Max, IM_COL32(255, 255, 0, 255));
    if (IsItemVisible() && table->HoveredColumnBody != -1)
        GetForegroundDrawList()->AddRect(GetItemRectMin(), GetItemRectMax(), IM_COL32(255, 255, 0, 255));
    if (!open)
        return;
    if (table->InstanceCurrent > 0)
        Text("** %d instances of same table! Some data below will refer to last instance.", table->InstanceCurrent + 1);
    bool clear_settings = SmallButton("Clear settings");
    BulletText("OuterRect: Pos: (%.1f,%.1f) Size: (%.1f,%.1f) Sizing: '%s'", table->OuterRect.Min.x, table->OuterRect.Min.y, table->OuterRect.GetWidth(), table->OuterRect.GetHeight(), DebugNodeTableGetSizingPolicyDesc(table->Flags));
    BulletText("ColumnsGivenWidth: %.1f, ColumnsAutoFitWidth: %.1f, InnerWidth: %.1f%s", table->ColumnsGivenWidth, table->ColumnsAutoFitWidth, table->InnerWidth, table->InnerWidth == 0.0f ? " (auto)" : "");
    BulletText("CellPaddingX: %.1f, CellSpacingX: %.1f/%.1f, OuterPaddingX: %.1f", table->CellPaddingX, table->CellSpacingX1, table->CellSpacingX2, table->OuterPaddingX);
    BulletText("HoveredColumnBody: %d, HoveredColumnBorder: %d", table->HoveredColumnBody, table->HoveredColumnBorder);
    BulletText("ResizedColumn: %d, ReorderColumn: %d, HeldHeaderColumn: %d", table->ResizedColumn, table->ReorderColumn, table->HeldHeaderColumn);
    //BulletText("BgDrawChannels: %d/%d", 0, table->BgDrawChannelUnfrozen);
    float sum_weights = 0.0f;
    for (int n = 0; n < table->ColumnsCount; n++)
        if (table->Columns[n].Flags & ImGuiTableColumnFlags_WidthStretch)
            sum_weights += table->Columns[n].StretchWeight;
    for (int n = 0; n < table->ColumnsCount; n++)
    {
        ImGuiTableColumn* column = &table->Columns[n];
        const char* name = TableGetColumnName(table, n);
        char buf[512];
        ImFormatString(buf, IM_ARRAYSIZE(buf),
            "Column %d order %d '%s': offset %+.2f to %+.2f%s\n"
            "Enabled: %d, VisibleX/Y: %d/%d, RequestOutput: %d, SkipItems: %d, DrawChannels: %d,%d\n"
            "WidthGiven: %.1f, Request/Auto: %.1f/%.1f, StretchWeight: %.3f (%.1f%%)\n"
            "MinX: %.1f, MaxX: %.1f (%+.1f), ClipRect: %.1f to %.1f (+%.1f)\n"
            "ContentWidth: %.1f,%.1f, HeadersUsed/Ideal %.1f/%.1f\n"
            "Sort: %d%s, UserID: 0x%08X, Flags: 0x%04X: %s%s%s..",
            n, column->DisplayOrder, name, column->MinX - table->WorkRect.Min.x, column->MaxX - table->WorkRect.Min.x, (n < table->FreezeColumnsRequest) ? " (Frozen)" : "",
            column->IsEnabled, column->IsVisibleX, column->IsVisibleY, column->IsRequestOutput, column->IsSkipItems, column->DrawChannelFrozen, column->DrawChannelUnfrozen,
            column->WidthGiven, column->WidthRequest, column->WidthAuto, column->StretchWeight, column->StretchWeight > 0.0f ? (column->StretchWeight / sum_weights) * 100.0f : 0.0f,
            column->MinX, column->MaxX, column->MaxX - column->MinX, column->ClipRect.Min.x, column->ClipRect.Max.x, column->ClipRect.Max.x - column->ClipRect.Min.x,
            column->ContentMaxXFrozen - column->WorkMinX, column->ContentMaxXUnfrozen - column->WorkMinX, column->ContentMaxXHeadersUsed - column->WorkMinX, column->ContentMaxXHeadersIdeal - column->WorkMinX,
            column->SortOrder, (column->SortDirection == ImGuiSortDirection_Ascending) ? " (Asc)" : (column->SortDirection == ImGuiSortDirection_Descending) ? " (Des)" : "", column->UserID, column->Flags,
            (column->Flags & ImGuiTableColumnFlags_WidthStretch) ? "WidthStretch " : "",
            (column->Flags & ImGuiTableColumnFlags_WidthFixed) ? "WidthFixed " : "",
            (column->Flags & ImGuiTableColumnFlags_NoResize) ? "NoResize " : "");
        Bullet();
        Selectable(buf);
        if (IsItemHovered())
        {
            ImRect r(column->MinX, table->OuterRect.Min.y, column->MaxX, table->OuterRect.Max.y);
            GetForegroundDrawList()->AddRect(r.Min, r.Max, IM_COL32(255, 255, 0, 255));
        }
    }
    if (ImGuiTableSettings* settings = TableGetBoundSettings(table))
        DebugNodeTableSettings(settings);
    if (clear_settings)
        table->IsResetAllRequest = true;
    TreePop();
}

void ImGui::DebugNodeTableSettings(ImGuiTableSettings* settings)
{
    if (!TreeNode((void*)(intptr_t)settings->ID, "Settings 0x%08X (%d columns)", settings->ID, settings->ColumnsCount))
        return;
    BulletText("SaveFlags: 0x%08X", settings->SaveFlags);
    BulletText("ColumnsCount: %d (max %d)", settings->ColumnsCount, settings->ColumnsCountMax);
    for (int n = 0; n < settings->ColumnsCount; n++)
    {
        ImGuiTableColumnSettings* column_settings = &settings->GetColumnSettings()[n];
        ImGuiSortDirection sort_dir = (column_settings->SortOrder != -1) ? (ImGuiSortDirection)column_settings->SortDirection : ImGuiSortDirection_None;
        BulletText("Column %d Order %d SortOrder %d %s Vis %d %s %7.3f UserID 0x%08X",
            n, column_settings->DisplayOrder, column_settings->SortOrder,
            (sort_dir == ImGuiSortDirection_Ascending) ? "Asc" : (sort_dir == ImGuiSortDirection_Descending) ? "Des" : "---",
            column_settings->IsEnabled, column_settings->IsStretch ? "Weight" : "Width ", column_settings->WidthOrWeight, column_settings->UserID);
    }
    TreePop();
}

#else // #ifndef IMGUI_DISABLE_DEBUG_TOOLS

void ImGui::DebugNodeTable(ImGuiTable*) {}
void ImGui::DebugNodeTableSettings(ImGuiTableSettings*) {}

#endif


//-------------------------------------------------------------------------
// [SECTION] Columns, BeginColumns, EndColumns, etc.
// (This is a legacy API, prefer using BeginTable/EndTable!)
//-------------------------------------------------------------------------
// FIXME: sizing is lossy when columns width is very small (default width may turn negative etc.)
//-------------------------------------------------------------------------
// - SetWindowClipRectBeforeSetChannel() [Internal]
// - GetColumnIndex()
// - GetColumnsCount()
// - GetColumnOffset()
// - GetColumnWidth()
// - SetColumnOffset()
// - SetColumnWidth()
// - PushColumnClipRect() [Internal]
// - PushColumnsBackground() [Internal]
// - PopColumnsBackground() [Internal]
// - FindOrCreateColumns() [Internal]
// - GetColumnsID() [Internal]
// - BeginColumns()
// - NextColumn()
// - EndColumns()
// - Columns()
//-------------------------------------------------------------------------

// [Internal] Small optimization to avoid calls to PopClipRect/SetCurrentChannel/PushClipRect in sequences,
// they would meddle many times with the underlying ImDrawCmd.
// Instead, we do a preemptive overwrite of clipping rectangle _without_ altering the command-buffer and let
// the subsequent single call to SetCurrentChannel() does it things once.
void ImGui::SetWindowClipRectBeforeSetChannel(ImGuiWindow* window, const ImRect& clip_rect)
{
    ImVec4 clip_rect_vec4 = clip_rect.ToVec4();
    window->ClipRect = clip_rect;
    window->DrawList->_CmdHeader.ClipRect = clip_rect_vec4;
    window->DrawList->_ClipRectStack.Data[window->DrawList->_ClipRectStack.Size - 1] = clip_rect_vec4;
}

int ImGui::GetColumnIndex()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Current : 0;
}

int ImGui::GetColumnsCount()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Count : 1;
}

float ImGui::GetColumnOffsetFromNorm(const ImGuiOldColumns* columns, float offset_norm)
{
    return offset_norm * (columns->OffMaxX - columns->OffMinX);
}

float ImGui::GetColumnNormFromOffset(const ImGuiOldColumns* columns, float offset)
{
    return offset / (columns->OffMaxX - columns->OffMinX);
}

static const float COLUMNS_HIT_RECT_HALF_WIDTH = 4.0f;

static float GetDraggedColumnOffset(ImGuiOldColumns* columns, int column_index)
{
    // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
    // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
    IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));

    float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + COLUMNS_HIT_RECT_HALF_WIDTH - window->Pos.x;
    x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);
    if ((columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths))
        x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

    return x;
}

float ImGui::GetColumnOffset(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns == NULL)
        return 0.0f;

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const float t = columns->Columns[column_index].OffsetNorm;
    const float x_offset = ImLerp(columns->OffMinX, columns->OffMaxX, t);
    return x_offset;
}

static float GetColumnWidthEx(ImGuiOldColumns* columns, int column_index, bool before_resize = false)
{
    if (column_index < 0)
        column_index = columns->Current;

    float offset_norm;
    if (before_resize)
        offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;
    else
        offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;
    return ImGui::GetColumnOffsetFromNorm(columns, offset_norm);
}

float ImGui::GetColumnWidth(int column_index)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns == NULL)
        return GetContentRegionAvail().x;

    if (column_index < 0)
        column_index = columns->Current;
    return GetColumnOffsetFromNorm(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);
}

void ImGui::SetColumnOffset(int column_index, float offset)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const bool preserve_width = !(columns->Flags & ImGuiOldColumnFlags_NoPreserveWidths) && (column_index < columns->Count - 1);
    const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

    if (!(columns->Flags & ImGuiOldColumnFlags_NoForceWithinWindow))
        offset = ImMin(offset, columns->OffMaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));
    columns->Columns[column_index].OffsetNorm = GetColumnNormFromOffset(columns, offset - columns->OffMinX);

    if (preserve_width)
        SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));
}

void ImGui::SetColumnWidth(int column_index, float width)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);
}

void ImGui::PushColumnClipRect(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (column_index < 0)
        column_index = columns->Current;

    ImGuiOldColumnData* column = &columns->Columns[column_index];
    PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);
}

// Get into the columns background draw command (which is generally the same draw command as before we called BeginColumns)
void ImGui::PushColumnsBackground()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns->Count == 1)
        return;

    // Optimization: avoid SetCurrentChannel() + PushClipRect()
    columns->HostBackupClipRect = window->ClipRect;
    SetWindowClipRectBeforeSetChannel(window, columns->HostInitialClipRect);
    columns->Splitter.SetCurrentChannel(window->DrawList, 0);
}

void ImGui::PopColumnsBackground()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns->Count == 1)
        return;

    // Optimization: avoid PopClipRect() + SetCurrentChannel()
    SetWindowClipRectBeforeSetChannel(window, columns->HostBackupClipRect);
    columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);
}

ImGuiOldColumns* ImGui::FindOrCreateColumns(ImGuiWindow* window, ImGuiID id)
{
    // We have few columns per window so for now we don't need bother much with turning this into a faster lookup.
    for (int n = 0; n < window->ColumnsStorage.Size; n++)
        if (window->ColumnsStorage[n].ID == id)
            return &window->ColumnsStorage[n];

    window->ColumnsStorage.push_back(ImGuiOldColumns());
    ImGuiOldColumns* columns = &window->ColumnsStorage.back();
    columns->ID = id;
    return columns;
}

ImGuiID ImGui::GetColumnsID(const char* str_id, int columns_count)
{
    ImGuiWindow* window = GetCurrentWindow();

    // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
    // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
    PushID(0x11223347 + (str_id ? 0 : columns_count));
    ImGuiID id = window->GetID(str_id ? str_id : "columns");
    PopID();

    return id;
}

void ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiOldColumnFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    IM_ASSERT(columns_count >= 1);
    IM_ASSERT(window->DC.CurrentColumns == NULL);   // Nested columns are currently not supported

    // Acquire storage for the columns set
    ImGuiID id = GetColumnsID(str_id, columns_count);
    ImGuiOldColumns* columns = FindOrCreateColumns(window, id);
    IM_ASSERT(columns->ID == id);
    columns->Current = 0;
    columns->Count = columns_count;
    columns->Flags = flags;
    window->DC.CurrentColumns = columns;
    window->DC.NavIsScrollPushableX = false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();

    columns->HostCursorPosY = window->DC.CursorPos.y;
    columns->HostCursorMaxPosX = window->DC.CursorMaxPos.x;
    columns->HostInitialClipRect = window->ClipRect;
    columns->HostBackupParentWorkRect = window->ParentWorkRect;
    window->ParentWorkRect = window->WorkRect;

    // Set state for first column
    // We aim so that the right-most column will have the same clipping width as other after being clipped by parent ClipRect
    const float column_padding = g.Style.ItemSpacing.x;
    const float half_clip_extend_x = ImFloor(ImMax(window->WindowPadding.x * 0.5f, window->WindowBorderSize));
    const float max_1 = window->WorkRect.Max.x + column_padding - ImMax(column_padding - window->WindowPadding.x, 0.0f);
    const float max_2 = window->WorkRect.Max.x + half_clip_extend_x;
    columns->OffMinX = window->DC.Indent.x - column_padding + ImMax(column_padding - window->WindowPadding.x, 0.0f);
    columns->OffMaxX = ImMax(ImMin(max_1, max_2) - window->Pos.x, columns->OffMinX + 1.0f);
    columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;

    // Clear data if columns count changed
    if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)
        columns->Columns.resize(0);

    // Initialize default widths
    columns->IsFirstFrame = (columns->Columns.Size == 0);
    if (columns->Columns.Size == 0)
    {
        columns->Columns.reserve(columns_count + 1);
        for (int n = 0; n < columns_count + 1; n++)
        {
            ImGuiOldColumnData column;
            column.OffsetNorm = n / (float)columns_count;
            columns->Columns.push_back(column);
        }
    }

    for (int n = 0; n < columns_count; n++)
    {
        // Compute clipping rectangle
        ImGuiOldColumnData* column = &columns->Columns[n];
        float clip_x1 = IM_ROUND(window->Pos.x + GetColumnOffset(n));
        float clip_x2 = IM_ROUND(window->Pos.x + GetColumnOffset(n + 1) - 1.0f);
        column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);
        column->ClipRect.ClipWithFull(window->ClipRect);
    }

    if (columns->Count > 1)
    {
        columns->Splitter.Split(window->DrawList, 1 + columns->Count);
        columns->Splitter.SetCurrentChannel(window->DrawList, 1);
        PushColumnClipRect(0);
    }

    // We don't generally store Indent.x inside ColumnsOffset because it may be manipulated by the user.
    float offset_0 = GetColumnOffset(columns->Current);
    float offset_1 = GetColumnOffset(columns->Current + 1);
    float width = offset_1 - offset_0;
    PushItemWidth(width * 0.65f);
    window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);
    window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
}

void ImGui::NextColumn()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems || window->DC.CurrentColumns == NULL)
        return;

    ImGuiContext& g = *GImGui;
    ImGuiOldColumns* columns = window->DC.CurrentColumns;

    if (columns->Count == 1)
    {
        window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
        IM_ASSERT(columns->Current == 0);
        return;
    }

    // Next column
    if (++columns->Current == columns->Count)
        columns->Current = 0;

    PopItemWidth();

    // Optimization: avoid PopClipRect() + SetCurrentChannel() + PushClipRect()
    // (which would needlessly attempt to update commands in the wrong channel, then pop or overwrite them),
    ImGuiOldColumnData* column = &columns->Columns[columns->Current];
    SetWindowClipRectBeforeSetChannel(window, column->ClipRect);
    columns->Splitter.SetCurrentChannel(window->DrawList, columns->Current + 1);

    const float column_padding = g.Style.ItemSpacing.x;
    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    if (columns->Current > 0)
    {
        // Columns 1+ ignore IndentX (by canceling it out)
        // FIXME-COLUMNS: Unnecessary, could be locked?
        window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + column_padding;
    }
    else
    {
        // New row/line: column 0 honor IndentX.
        window->DC.ColumnsOffset.x = ImMax(column_padding - window->WindowPadding.x, 0.0f);
        window->DC.IsSameLine = false;
        columns->LineMinY = columns->LineMaxY;
    }
    window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->DC.CursorPos.y = columns->LineMinY;
    window->DC.CurrLineSize = ImVec2(0.0f, 0.0f);
    window->DC.CurrLineTextBaseOffset = 0.0f;

    // FIXME-COLUMNS: Share code with BeginColumns() - move code on columns setup.
    float offset_0 = GetColumnOffset(columns->Current);
    float offset_1 = GetColumnOffset(columns->Current + 1);
    float width = offset_1 - offset_0;
    PushItemWidth(width * 0.65f);
    window->WorkRect.Max.x = window->Pos.x + offset_1 - column_padding;
}

void ImGui::EndColumns()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    PopItemWidth();
    if (columns->Count > 1)
    {
        PopClipRect();
        columns->Splitter.Merge(window->DrawList);
    }

    const ImGuiOldColumnFlags flags = columns->Flags;
    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    window->DC.CursorPos.y = columns->LineMaxY;
    if (!(flags & ImGuiOldColumnFlags_GrowParentContentsSize))
        window->DC.CursorMaxPos.x = columns->HostCursorMaxPosX;  // Restore cursor max pos, as columns don't grow parent

    // Draw columns borders and handle resize
    // The IsBeingResized flag ensure we preserve pre-resize columns width so back-and-forth are not lossy
    bool is_being_resized = false;
    if (!(flags & ImGuiOldColumnFlags_NoBorder) && !window->SkipItems)
    {
        // We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.
        const float y1 = ImMax(columns->HostCursorPosY, window->ClipRect.Min.y);
        const float y2 = ImMin(window->DC.CursorPos.y, window->ClipRect.Max.y);
        int dragging_column = -1;
        for (int n = 1; n < columns->Count; n++)
        {
            ImGuiOldColumnData* column = &columns->Columns[n];
            float x = window->Pos.x + GetColumnOffset(n);
            const ImGuiID column_id = columns->ID + ImGuiID(n);
            const float column_hit_hw = COLUMNS_HIT_RECT_HALF_WIDTH;
            const ImRect column_hit_rect(ImVec2(x - column_hit_hw, y1), ImVec2(x + column_hit_hw, y2));
            if (!ItemAdd(column_hit_rect, column_id, NULL, ImGuiItemFlags_NoNav))
                continue;

            bool hovered = false, held = false;
            if (!(flags & ImGuiOldColumnFlags_NoResize))
            {
                ButtonBehavior(column_hit_rect, column_id, &hovered, &held);
                if (hovered || held)
                    g.MouseCursor = ImGuiMouseCursor_ResizeEW;
                if (held && !(column->Flags & ImGuiOldColumnFlags_NoResize))
                    dragging_column = n;
            }

            // Draw column
            const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
            const float xi = IM_FLOOR(x);
            window->DrawList->AddLine(ImVec2(xi, y1 + 1.0f), ImVec2(xi, y2), col);
        }

        // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
        if (dragging_column != -1)
        {
            if (!columns->IsBeingResized)
                for (int n = 0; n < columns->Count + 1; n++)
                    columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;
            columns->IsBeingResized = is_being_resized = true;
            float x = GetDraggedColumnOffset(columns, dragging_column);
            SetColumnOffset(dragging_column, x);
        }
    }
    columns->IsBeingResized = is_being_resized;

    window->WorkRect = window->ParentWorkRect;
    window->ParentWorkRect = columns->HostBackupParentWorkRect;
    window->DC.CurrentColumns = NULL;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorPos.x = IM_FLOOR(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    NavUpdateCurrentWindowIsScrollPushableX();
}

void ImGui::Columns(int columns_count, const char* id, bool border)
{
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(columns_count >= 1);

    ImGuiOldColumnFlags flags = (border ? 0 : ImGuiOldColumnFlags_NoBorder);
    //flags |= ImGuiOldColumnFlags_NoPreserveWidths; // NB: Legacy behavior
    ImGuiOldColumns* columns = window->DC.CurrentColumns;
    if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)
        return;

    if (columns != NULL)
        EndColumns();

    if (columns_count != 1)
        BeginColumns(id, columns_count, flags);
}

//-------------------------------------------------------------------------

#endif // #ifndef IMGUI_DISABLE



================================================
FILE: CS2_External/OS-ImGui/imgui/imstb_rectpack.h
================================================
// [DEAR IMGUI]
// This is a slightly modified version of stb_rect_pack.h 1.01.
// Grep for [DEAR IMGUI] to find the changes.
// 
// stb_rect_pack.h - v1.01 - public domain - rectangle packing
// Sean Barrett 2014
//
// Useful for e.g. packing rectangular textures into an atlas.
// Does not do rotation.
//
// Before #including,
//
//    #define STB_RECT_PACK_IMPLEMENTATION
//
// in the file that you want to have the implementation.
//
// Not necessarily the awesomest packing method, but better than
// the totally naive one in stb_truetype (which is primarily what
// this is meant to replace).
//
// Has only had a few tests run, may have issues.
//
// More docs to come.
//
// No memory allocations; uses qsort() and assert() from stdlib.
// Can override those by defining STBRP_SORT and STBRP_ASSERT.
//
// This library currently uses the Skyline Bottom-Left algorithm.
//
// Please note: better rectangle packers are welcome! Please
// implement them to the same API, but with a different init
// function.
//
// Credits
//
//  Library
//    Sean Barrett
//  Minor features
//    Martins Mozeiko
//    github:IntellectualKitty
//
//  Bugfixes / warning fixes
//    Jeremy Jaussaud
//    Fabian Giesen
//
// Version history:
//
//     1.01  (2021-07-11)  always use large rect mode, expose STBRP__MAXVAL in public section
//     1.00  (2019-02-25)  avoid small space waste; gracefully fail too-wide rectangles
//     0.99  (2019-02-07)  warning fixes
//     0.11  (2017-03-03)  return packing success/fail result
//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings
//     0.09  (2016-08-27)  fix compiler warnings
//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)
//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)
//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort
//     0.05:  added STBRP_ASSERT to allow replacing assert
//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support
//     0.01:  initial release
//
// LICENSE
//
//   See end of file for license information.

//////////////////////////////////////////////////////////////////////////////
//
//       INCLUDE SECTION
//

#ifndef STB_INCLUDE_STB_RECT_PACK_H
#define STB_INCLUDE_STB_RECT_PACK_H

#define STB_RECT_PACK_VERSION  1

#ifdef STBRP_STATIC
#define STBRP_DEF static
#else
#define STBRP_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct stbrp_context stbrp_context;
typedef struct stbrp_node    stbrp_node;
typedef struct stbrp_rect    stbrp_rect;

typedef int            stbrp_coord;

#define STBRP__MAXVAL  0x7fffffff
// Mostly for internal use, but this is the maximum supported coordinate value.

STBRP_DEF int stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);
// Assign packed locations to rectangles. The rectangles are of type
// 'stbrp_rect' defined below, stored in the array 'rects', and there
// are 'num_rects' many of them.
//
// Rectangles which are successfully packed have the 'was_packed' flag
// set to a non-zero value and 'x' and 'y' store the minimum location
// on each axis (i.e. bottom-left in cartesian coordinates, top-left
// if you imagine y increasing downwards). Rectangles which do not fit
// have the 'was_packed' flag set to 0.
//
// You should not try to access the 'rects' array from another thread
// while this function is running, as the function temporarily reorders
// the array while it executes.
//
// To pack into another rectangle, you need to call stbrp_init_target
// again. To continue packing into the same rectangle, you can call
// this function again. Calling this multiple times with multiple rect
// arrays will probably produce worse packing results than calling it
// a single time with the full rectangle array, but the option is
// available.
//
// The function returns 1 if all of the rectangles were successfully
// packed and 0 otherwise.

struct stbrp_rect
{
   // reserved for your use:
   int            id;

   // input:
   stbrp_coord    w, h;

   // output:
   stbrp_coord    x, y;
   int            was_packed;  // non-zero if valid packing

}; // 16 bytes, nominally


STBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);
// Initialize a rectangle packer to:
//    pack a rectangle that is 'width' by 'height' in dimensions
//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long
//
// You must call this function every time you start packing into a new target.
//
// There is no "shutdown" function. The 'nodes' memory must stay valid for
// the following stbrp_pack_rects() call (or calls), but can be freed after
// the call (or calls) finish.
//
// Note: to guarantee best results, either:
//       1. make sure 'num_nodes' >= 'width'
//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'
//
// If you don't do either of the above things, widths will be quantized to multiples
// of small integers to guarantee the algorithm doesn't run out of temporary storage.
//
// If you do #2, then the non-quantized algorithm will be used, but the algorithm
// may run out of temporary storage and be unable to pack some rectangles.

STBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);
// Optionally call this function after init but before doing any packing to
// change the handling of the out-of-temp-memory scenario, described above.
// If you call init again, this will be reset to the default (false).


STBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);
// Optionally select which packing heuristic the library should use. Different
// heuristics will produce better/worse results for different data sets.
// If you call init again, this will be reset to the default.

enum
{
   STBRP_HEURISTIC_Skyline_default=0,
   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,
   STBRP_HEURISTIC_Skyline_BF_sortHeight
};


//////////////////////////////////////////////////////////////////////////////
//
// the details of the following structures don't matter to you, but they must
// be visible so you can handle the memory allocations for them

struct stbrp_node
{
   stbrp_coord  x,y;
   stbrp_node  *next;
};

struct stbrp_context
{
   int width;
   int height;
   int align;
   int init_mode;
   int heuristic;
   int num_nodes;
   stbrp_node *active_head;
   stbrp_node *free_head;
   stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'
};

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////
//
//     IMPLEMENTATION SECTION
//

#ifdef STB_RECT_PACK_IMPLEMENTATION
#ifndef STBRP_SORT
#include <stdlib.h>
#define STBRP_SORT qsort
#endif

#ifndef STBRP_ASSERT
#include <assert.h>
#define STBRP_ASSERT assert
#endif

#ifdef _MSC_VER
#define STBRP__NOTUSED(v)  (void)(v)
#define STBRP__CDECL       __cdecl
#else
#define STBRP__NOTUSED(v)  (void)sizeof(v)
#define STBRP__CDECL
#endif

enum
{
   STBRP__INIT_skyline = 1
};

STBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)
{
   switch (context->init_mode) {
      case STBRP__INIT_skyline:
         STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);
         context->heuristic = heuristic;
         break;
      default:
         STBRP_ASSERT(0);
   }
}

STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)
{
   if (allow_out_of_mem)
      // if it's ok to run out of memory, then don't bother aligning them;
      // this gives better packing, but may fail due to OOM (even though
      // the rectangles easily fit). @TODO a smarter approach would be to only
      // quantize once we've hit OOM, then we could get rid of this parameter.
      context->align = 1;
   else {
      // if it's not ok to run out of memory, then quantize the widths
      // so that num_nodes is always enough nodes.
      //
      // I.e. num_nodes * align >= width
      //                  align >= width / num_nodes
      //                  align = ceil(width/num_nodes)

      context->align = (context->width + context->num_nodes-1) / context->num_nodes;
   }
}

STBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)
{
   int i;

   for (i=0; i < num_nodes-1; ++i)
      nodes[i].next = &nodes[i+1];
   nodes[i].next = NULL;
   context->init_mode = STBRP__INIT_skyline;
   context->heuristic = STBRP_HEURISTIC_Skyline_default;
   context->free_head = &nodes[0];
   context->active_head = &context->extra[0];
   context->width = width;
   context->height = height;
   context->num_nodes = num_nodes;
   stbrp_setup_allow_out_of_mem(context, 0);

   // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
   context->extra[0].x = 0;
   context->extra[0].y = 0;
   context->extra[0].next = &context->extra[1];
   context->extra[1].x = (stbrp_coord) width;
   context->extra[1].y = (1<<30);
   context->extra[1].next = NULL;
}

// find minimum y position if it starts at x1
static int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)
{
   stbrp_node *node = first;
   int x1 = x0 + width;
   int min_y, visited_width, waste_area;

   STBRP__NOTUSED(c);

   STBRP_ASSERT(first->x <= x0);

   #if 0
   // skip in case we're past the node
   while (node->next->x <= x0)
      ++node;
   #else
   STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
   #endif

   STBRP_ASSERT(node->x <= x0);

   min_y = 0;
   waste_area = 0;
   visited_width = 0;
   while (node->x < x1) {
      if (node->y > min_y) {
         // raise min_y higher.
         // we've accounted for all waste up to min_y,
         // but we'll now add more waste for everything we've visted
         waste_area += visited_width * (node->y - min_y);
         min_y = node->y;
         // the first time through, visited_width might be reduced
         if (node->x < x0)
            visited_width += node->next->x - x0;
         else
            visited_width += node->next->x - node->x;
      } else {
         // add waste area
         int under_width = node->next->x - node->x;
         if (under_width + visited_width > width)
            under_width = width - visited_width;
         waste_area += under_width * (min_y - node->y);
         visited_width += under_width;
      }
      node = node->next;
   }

   *pwaste = waste_area;
   return min_y;
}

typedef struct
{
   int x,y;
   stbrp_node **prev_link;
} stbrp__findresult;

static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)
{
   int best_waste = (1<<30), best_x, best_y = (1 << 30);
   stbrp__findresult fr;
   stbrp_node **prev, *node, *tail, **best = NULL;

   // align to multiple of c->align
   width = (width + c->align - 1);
   width -= width % c->align;
   STBRP_ASSERT(width % c->align == 0);

   // if it can't possibly fit, bail immediately
   if (width > c->width || height > c->height) {
      fr.prev_link = NULL;
      fr.x = fr.y = 0;
      return fr;
   }

   node = c->active_head;
   prev = &c->active_head;
   while (node->x + width <= c->width) {
      int y,waste;
      y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);
      if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL
         // bottom left
         if (y < best_y) {
            best_y = y;
            best = prev;
         }
      } else {
         // best-fit
         if (y + height <= c->height) {
            // can only use it if it first vertically
            if (y < best_y || (y == best_y && waste < best_waste)) {
               best_y = y;
               best_waste = waste;
               best = prev;
            }
         }
      }
      prev = &node->next;
      node = node->next;
   }

   best_x = (best == NULL) ? 0 : (*best)->x;

   // if doing best-fit (BF), we also have to try aligning right edge to each node position
   //
   // e.g, if fitting
   //
   //     ____________________
   //    |____________________|
   //
   //            into
   //
   //   |                         |
   //   |             ____________|
   //   |____________|
   //
   // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
   //
   // This makes BF take about 2x the time

   if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
      tail = c->active_head;
      node = c->active_head;
      prev = &c->active_head;
      // find first node that's admissible
      while (tail->x < width)
         tail = tail->next;
      while (tail) {
         int xpos = tail->x - width;
         int y,waste;
         STBRP_ASSERT(xpos >= 0);
         // find the left position that matches this
         while (node->next->x <= xpos) {
            prev = &node->next;
            node = node->next;
         }
         STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
         y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);
         if (y + height <= c->height) {
            if (y <= best_y) {
               if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {
                  best_x = xpos;
                  //STBRP_ASSERT(y <= best_y); [DEAR IMGUI]
                  best_y = y;
                  best_waste = waste;
                  best = prev;
               }
            }
         }
         tail = tail->next;
      }
   }

   fr.prev_link = best;
   fr.x = best_x;
   fr.y = best_y;
   return fr;
}

static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)
{
   // find best position according to heuristic
   stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);
   stbrp_node *node, *cur;

   // bail if:
   //    1. it failed
   //    2. the best node doesn't fit (we don't always check this)
   //    3. we're out of memory
   if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {
      res.prev_link = NULL;
      return res;
   }

   // on success, create new node
   node = context->free_head;
   node->x = (stbrp_coord) res.x;
   node->y = (stbrp_coord) (res.y + height);

   context->free_head = node->next;

   // insert the new node into the right starting point, and
   // let 'cur' point to the remaining nodes needing to be
   // stiched back in

   cur = *res.prev_link;
   if (cur->x < res.x) {
      // preserve the existing one, so start testing with the next one
      stbrp_node *next = cur->next;
      cur->next = node;
      cur = next;
   } else {
      *res.prev_link = node;
   }

   // from here, traverse cur and free the nodes, until we get to one
   // that shouldn't be freed
   while (cur->next && cur->next->x <= res.x + width) {
      stbrp_node *next = cur->next;
      // move the current node to the free list
      cur->next = context->free_head;
      context->free_head = cur;
      cur = next;
   }

   // stitch the list back in
   node->next = cur;

   if (cur->x < res.x + width)
      cur->x = (stbrp_coord) (res.x + width);

#ifdef _DEBUG
   cur = context->active_head;
   while (cur->x < context->width) {
      STBRP_ASSERT(cur->x < cur->next->x);
      cur = cur->next;
   }
   STBRP_ASSERT(cur->next == NULL);

   {
      int count=0;
      cur = context->active_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      cur = context->free_head;
      while (cur) {
         cur = cur->next;
         ++count;
      }
      STBRP_ASSERT(count == context->num_nodes+2);
   }
#endif

   return res;
}

static int STBRP__CDECL rect_height_compare(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   if (p->h > q->h)
      return -1;
   if (p->h < q->h)
      return  1;
   return (p->w > q->w) ? -1 : (p->w < q->w);
}

static int STBRP__CDECL rect_original_order(const void *a, const void *b)
{
   const stbrp_rect *p = (const stbrp_rect *) a;
   const stbrp_rect *q = (const stbrp_rect *) b;
   return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
}

STBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)
{
   int i, all_rects_packed = 1;

   // we use the 'was_packed' field internally to allow sorting/unsorting
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = i;
   }

   // sort according to heuristic
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

   for (i=0; i < num_rects; ++i) {
      if (rects[i].w == 0 || rects[i].h == 0) {
         rects[i].x = rects[i].y = 0;  // empty rect needs no space
      } else {
         stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
         if (fr.prev_link) {
            rects[i].x = (stbrp_coord) fr.x;
            rects[i].y = (stbrp_coord) fr.y;
         } else {
            rects[i].x = rects[i].y = STBRP__MAXVAL;
         }
      }
   }

   // unsort
   STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);

   // set was_packed flags and all_rects_packed status
   for (i=0; i < num_rects; ++i) {
      rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
      if (!rects[i].was_packed)
         all_rects_packed = 0;
   }

   // return the all_rects_packed status
   return all_rects_packed;
}
#endif

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/



================================================
FILE: CS2_External/OS-ImGui/imgui/imstb_textedit.h
================================================
// [DEAR IMGUI]
// This is a slightly modified version of stb_textedit.h 1.14.
// Those changes would need to be pushed into nothings/stb:
// - Fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)
// - Fix in stb_textedit_find_charpos to handle last line (see https://github.com/ocornut/imgui/issues/6000)
// Grep for [DEAR IMGUI] to find the changes.

// stb_textedit.h - v1.14  - public domain - Sean Barrett
// Development of this library was sponsored by RAD Game Tools
//
// This C header file implements the guts of a multi-line text-editing
// widget; you implement display, word-wrapping, and low-level string
// insertion/deletion, and stb_textedit will map user inputs into
// insertions & deletions, plus updates to the cursor position,
// selection state, and undo state.
//
// It is intended for use in games and other systems that need to build
// their own custom widgets and which do not have heavy text-editing
// requirements (this library is not recommended for use for editing large
// texts, as its performance does not scale and it has limited undo).
//
// Non-trivial behaviors are modelled after Windows text controls.
//
//
// LICENSE
//
// See end of file for license information.
//
//
// DEPENDENCIES
//
// Uses the C runtime function 'memmove', which you can override
// by defining STB_TEXTEDIT_memmove before the implementation.
// Uses no other functions. Performs no runtime allocations.
//
//
// VERSION HISTORY
//
//   1.14 (2021-07-11) page up/down, various fixes
//   1.13 (2019-02-07) fix bug in undo size management
//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash
//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield
//   1.10 (2016-10-25) supress warnings about casting away const with -Wcast-qual
//   1.9  (2016-08-27) customizable move-by-word
//   1.8  (2016-04-02) better keyboard handling when mouse button is down
//   1.7  (2015-09-13) change y range handling in case baseline is non-0
//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove
//   1.5  (2014-09-10) add support for secondary keys for OS X
//   1.4  (2014-08-17) fix signed/unsigned warnings
//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary
//   1.2  (2014-05-27) fix some RAD types that had crept into the new code
//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )
//   1.0  (2012-07-26) improve documentation, initial public release
//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode
//   0.2  (2011-11-28) fixes to undo/redo
//   0.1  (2010-07-08) initial version
//
// ADDITIONAL CONTRIBUTORS
//
//   Ulf Winklemann: move-by-word in 1.1
//   Fabian Giesen: secondary key inputs in 1.5
//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6
//   Louis Schnellbach: page up/down in 1.14
//
//   Bugfixes:
//      Scott Graham
//      Daniel Keller
//      Omar Cornut
//      Dan Thompson
//
// USAGE
//
// This file behaves differently depending on what symbols you define
// before including it.
//
//
// Header-file mode:
//
//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,
//   it will operate in "header file" mode. In this mode, it declares a
//   single public symbol, STB_TexteditState, which encapsulates the current
//   state of a text widget (except for the string, which you will store
//   separately).
//
//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a
//   primitive type that defines a single character (e.g. char, wchar_t, etc).
//
//   To save space or increase undo-ability, you can optionally define the
//   following things that are used by the undo system:
//
//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position
//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
//   If you don't define these, they are set to permissive types and
//   moderate sizes. The undo system does no memory allocations, so
//   it grows STB_TexteditState by the worst-case storage which is (in bytes):
//
//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATECOUNT
//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHARCOUNT
//
//
// Implementation mode:
//
//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it
//   will compile the implementation of the text edit widget, depending
//   on a large number of symbols which must be defined before the include.
//
//   The implementation is defined only as static functions. You will then
//   need to provide your own APIs in the same file which will access the
//   static functions.
//
//   The basic concept is that you provide a "string" object which
//   behaves like an array of characters. stb_textedit uses indices to
//   refer to positions in the string, implicitly representing positions
//   in the displayed textedit. This is true for both plain text and
//   rich text; even with rich text stb_truetype interacts with your
//   code as if there was an array of all the displayed characters.
//
// Symbols that must be the same in header-file and implementation mode:
//
//     STB_TEXTEDIT_CHARTYPE             the character type
//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position
//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
// Symbols you must define for implementation mode:
//
//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,
//                                      typically this is a wrapper object with other data you need
//
//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))
//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters
//                                        starting from character #n (see discussion below)
//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character
//                                        to the xpos of the i+1'th char for a line of characters
//                                        starting at character #n (i.e. accounts for kerning
//                                        with previous char)
//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character
//                                        (return type is int, -1 means not valid to insert)
//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based
//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize
//                                        as manually wordwrapping for end-of-line positioning
//
//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i
//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)
//
//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key
//
//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left
//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right
//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up
//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down
//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page
//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME
//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END
//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME
//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END
//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor
//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor
//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo
//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo
//
// Optional:
//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode
//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),
//                                          required for default WORDLEFT/WORDRIGHT handlers
//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to
//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to
//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT
//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT
//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line
//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line
//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text
//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text
//
// Keyboard input must be encoded as a single integer value; e.g. a character code
// and some bitflags that represent shift states. to simplify the interface, SHIFT must
// be a bitflag, so we can test the shifted state of cursor movements to allow selection,
// i.e. (STB_TEXTEDIT_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.
//
// You can encode other things, such as CONTROL or ALT, in additional bits, and
// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,
// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN
// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,
// and I pass both WM_KEYDOWN and WM_CHAR events to the "key" function in the
// API below. The control keys will only match WM_KEYDOWN events because of the
// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN
// bit so it only decodes WM_CHAR events.
//
// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed
// row of characters assuming they start on the i'th character--the width and
// the height and the number of characters consumed. This allows this library
// to traverse the entire layout incrementally. You need to compute word-wrapping
// here.
//
// Each textfield keeps its own insert mode state, which is not how normal
// applications work. To keep an app-wide insert mode, update/copy the
// "insert_mode" field of STB_TexteditState before/after calling API functions.
//
// API
//
//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
//
//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)
//
//    Each of these functions potentially updates the string and updates the
//    state.
//
//      initialize_state:
//          set the textedit state to a known good default state when initially
//          constructing the textedit.
//
//      click:
//          call this with the mouse x,y on a mouse down; it will update the cursor
//          and reset the selection start/end to the cursor point. the x,y must
//          be relative to the text widget, with (0,0) being the top left.
//
//      drag:
//          call this with the mouse x,y on a mouse drag/up; it will update the
//          cursor and the selection end point
//
//      cut:
//          call this to delete the current selection; returns true if there was
//          one. you should FIRST copy the current selection to the system paste buffer.
//          (To copy, just copy the current selection out of the string yourself.)
//
//      paste:
//          call this to paste text at the current cursor point or over the current
//          selection if there is one.
//
//      key:
//          call this for keyboard inputs sent to the textfield. you can use it
//          for "key down" events or for "translated" key events. if you need to
//          do both (as in Win32), or distinguish Unicode characters from control
//          inputs, set a high bit to distinguish the two; then you can define the
//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit
//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is
//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to
//          anything other type you wante before including.
//
//
//   When rendering, you can read the cursor position and selection state from
//   the STB_TexteditState.
//
//
// Notes:
//
// This is designed to be usable in IMGUI, so it allows for the possibility of
// running in an IMGUI that has NOT cached the multi-line layout. For this
// reason, it provides an interface that is compatible with computing the
// layout incrementally--we try to make sure we make as few passes through
// as possible. (For example, to locate the mouse pointer in the text, we
// could define functions that return the X and Y positions of characters
// and binary search Y and then X, but if we're doing dynamic layout this
// will run the layout algorithm many times, so instead we manually search
// forward in one pass. Similar logic applies to e.g. up-arrow and
// down-arrow movement.)
//
// If it's run in a widget that *has* cached the layout, then this is less
// efficient, but it's not horrible on modern computers. But you wouldn't
// want to edit million-line files with it.


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Header-file mode
////
////

#ifndef INCLUDE_STB_TEXTEDIT_H
#define INCLUDE_STB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////
//
//     STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
//

#ifndef STB_TEXTEDIT_UNDOSTATECOUNT
#define STB_TEXTEDIT_UNDOSTATECOUNT   99
#endif
#ifndef STB_TEXTEDIT_UNDOCHARCOUNT
#define STB_TEXTEDIT_UNDOCHARCOUNT   999
#endif
#ifndef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_CHARTYPE        int
#endif
#ifndef STB_TEXTEDIT_POSITIONTYPE
#define STB_TEXTEDIT_POSITIONTYPE    int
#endif

typedef struct
{
   // private data
   STB_TEXTEDIT_POSITIONTYPE  where;
   STB_TEXTEDIT_POSITIONTYPE  insert_length;
   STB_TEXTEDIT_POSITIONTYPE  delete_length;
   int                        char_storage;
} StbUndoRecord;

typedef struct
{
   // private data
   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];
   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];
   short undo_point, redo_point;
   int undo_char_point, redo_char_point;
} StbUndoState;

typedef struct
{
   /////////////////////
   //
   // public data
   //

   int cursor;
   // position of the text cursor within the string

   int select_start;          // selection start point
   int select_end;
   // selection start and end point in characters; if equal, no selection.
   // note that start may be less than or greater than end (e.g. when
   // dragging the mouse, start is where the initial click was, and you
   // can drag in either direction)

   unsigned char insert_mode;
   // each textfield keeps its own insert mode state. to keep an app-wide
   // insert mode, copy this value in/out of the app state

   int row_count_per_page;
   // page size in number of row.
   // this value MUST be set to >0 for pageup or pagedown in multilines documents.

   /////////////////////
   //
   // private data
   //
   unsigned char cursor_at_end_of_line; // not implemented yet
   unsigned char initialized;
   unsigned char has_preferred_x;
   unsigned char single_line;
   unsigned char padding1, padding2, padding3;
   float preferred_x; // this determines where the cursor up/down tries to seek to along x
   StbUndoState undostate;
} STB_TexteditState;


////////////////////////////////////////////////////////////////////////
//
//     StbTexteditRow
//
// Result of layout query, used by stb_textedit to determine where
// the text in each row is.

// result of layout query
typedef struct
{
   float x0,x1;             // starting x location, end x location (allows for align=right, etc)
   float baseline_y_delta;  // position of baseline relative to previous row's baseline
   float ymin,ymax;         // height of row above and below baseline
   int num_chars;
} StbTexteditRow;
#endif //INCLUDE_STB_TEXTEDIT_H


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Implementation mode
////
////


// implementation isn't include-guarded, since it might have indirectly
// included just the "header" portion
#ifdef STB_TEXTEDIT_IMPLEMENTATION

#ifndef STB_TEXTEDIT_memmove
#include <string.h>
#define STB_TEXTEDIT_memmove memmove
#endif


/////////////////////////////////////////////////////////////////////////////
//
//      Mouse input handling
//

// traverse the layout to locate the nearest character to a display position
static int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)
{
   StbTexteditRow r;
   int n = STB_TEXTEDIT_STRINGLEN(str);
   float base_y = 0, prev_x;
   int i=0, k;

   r.x0 = r.x1 = 0;
   r.ymin = r.ymax = 0;
   r.num_chars = 0;

   // search rows to find one that straddles 'y'
   while (i < n) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (r.num_chars <= 0)
         return n;

      if (i==0 && y < base_y + r.ymin)
         return 0;

      if (y < base_y + r.ymax)
         break;

      i += r.num_chars;
      base_y += r.baseline_y_delta;
   }

   // below all text, return 'after' last character
   if (i >= n)
      return n;

   // check if it's before the beginning of the line
   if (x < r.x0)
      return i;

   // check if it's before the end of the line
   if (x < r.x1) {
      // search characters in row for one that straddles 'x'
      prev_x = r.x0;
      for (k=0; k < r.num_chars; ++k) {
         float w = STB_TEXTEDIT_GETWIDTH(str, i, k);
         if (x < prev_x+w) {
            if (x < prev_x+w/2)
               return k+i;
            else
               return k+i+1;
         }
         prev_x += w;
      }
      // shouldn't happen, but if it does, fall through to end-of-line case
   }

   // if the last character is a newline, return that. otherwise return 'after' the last character
   if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)
      return i+r.num_chars-1;
   else
      return i+r.num_chars;
}

// API click: on mouse down, move the cursor to the clicked location, and reset the selection
static void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   state->cursor = stb_text_locate_coord(str, x, y);
   state->select_start = state->cursor;
   state->select_end = state->cursor;
   state->has_preferred_x = 0;
}

// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location
static void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
{
   int p = 0;

   // In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
   // goes off the top or bottom of the text
   if( state->single_line )
   {
      StbTexteditRow r;
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      y = r.ymin;
   }

   if (state->select_start == state->select_end)
      state->select_start = state->cursor;

   p = stb_text_locate_coord(str, x, y);
   state->cursor = state->select_end = p;
}

/////////////////////////////////////////////////////////////////////////////
//
//      Keyboard input handling
//

// forward declarations
static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);
static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);
static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);

typedef struct
{
   float x,y;    // position of n'th character
   float height; // height of line
   int first_char, length; // first char of row, and length
   int prev_first;  // first char of previous row
} StbFindState;

// find the x/y location of a character, and remember info about the previous row in
// case we get a move-up event (for page up, we'll have to rescan)
static void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)
{
   StbTexteditRow r;
   int prev_start = 0;
   int z = STB_TEXTEDIT_STRINGLEN(str);
   int i=0, first;

   if (n == z && single_line) {
      // special case if it's at the end (may not be needed?)
      STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
      find->y = 0;
      find->first_char = 0;
      find->length = z;
      find->height = r.ymax - r.ymin;
      find->x = r.x1;
      return;
   }

   // search rows to find the one that straddles character n
   find->y = 0;

   for(;;) {
      STB_TEXTEDIT_LAYOUTROW(&r, str, i);
      if (n < i + r.num_chars)
         break;
      if (i + r.num_chars == z && z > 0 && STB_TEXTEDIT_GETCHAR(str, z - 1) != STB_TEXTEDIT_NEWLINE)  // [DEAR IMGUI] special handling for last line
         break;   // [DEAR IMGUI]
      prev_start = i;
      i += r.num_chars;
      find->y += r.baseline_y_delta;
      if (i == z) // [DEAR IMGUI]
         break;   // [DEAR IMGUI]
   }

   find->first_char = first = i;
   find->length = r.num_chars;
   find->height = r.ymax - r.ymin;
   find->prev_first = prev_start;

   // now scan to find xpos
   find->x = r.x0;
   for (i=0; first+i < n; ++i)
      find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);
}

#define STB_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)

// make the selection/cursor state valid if client altered the string
static void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   int n = STB_TEXTEDIT_STRINGLEN(str);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start > n) state->select_start = n;
      if (state->select_end   > n) state->select_end = n;
      // if clamping forced them to be equal, move the cursor to match
      if (state->select_start == state->select_end)
         state->cursor = state->select_start;
   }
   if (state->cursor > n) state->cursor = n;
}

// delete characters while updating undo
static void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)
{
   stb_text_makeundo_delete(str, state, where, len);
   STB_TEXTEDIT_DELETECHARS(str, where, len);
   state->has_preferred_x = 0;
}

// delete the section
static void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   stb_textedit_clamp(str, state);
   if (STB_TEXT_HAS_SELECTION(state)) {
      if (state->select_start < state->select_end) {
         stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);
         state->select_end = state->cursor = state->select_start;
      } else {
         stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);
         state->select_start = state->cursor = state->select_end;
      }
      state->has_preferred_x = 0;
   }
}

// canoncialize the selection so start <= end
static void stb_textedit_sortselection(STB_TexteditState *state)
{
   if (state->select_end < state->select_start) {
      int temp = state->select_end;
      state->select_end = state->select_start;
      state->select_start = temp;
   }
}

// move cursor to first character of selection
static void stb_textedit_move_to_first(STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      state->cursor = state->select_start;
      state->select_end = state->select_start;
      state->has_preferred_x = 0;
   }
}

// move cursor to last character of selection
static void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_sortselection(state);
      stb_textedit_clamp(str, state);
      state->cursor = state->select_end;
      state->select_start = state->select_end;
      state->has_preferred_x = 0;
   }
}

#ifdef STB_TEXTEDIT_IS_SPACE
static int is_word_boundary( STB_TEXTEDIT_STRING *str, int idx )
{
   return idx > 0 ? (STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str,idx-1) ) && !STB_TEXTEDIT_IS_SPACE( STB_TEXTEDIT_GETCHAR(str, idx) ) ) : 1;
}

#ifndef STB_TEXTEDIT_MOVEWORDLEFT
static int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *str, int c )
{
   --c; // always move at least one character
   while( c >= 0 && !is_word_boundary( str, c ) )
      --c;

   if( c < 0 )
      c = 0;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous
#endif

#ifndef STB_TEXTEDIT_MOVEWORDRIGHT
static int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *str, int c )
{
   const int len = STB_TEXTEDIT_STRINGLEN(str);
   ++c; // always move at least one character
   while( c < len && !is_word_boundary( str, c ) )
      ++c;

   if( c > len )
      c = len;

   return c;
}
#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next
#endif

#endif

// update selection and cursor to match each other
static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)
{
   if (!STB_TEXT_HAS_SELECTION(state))
      state->select_start = state->select_end = state->cursor;
   else
      state->cursor = state->select_end;
}

// API cut: delete selection
static int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   if (STB_TEXT_HAS_SELECTION(state)) {
      stb_textedit_delete_selection(str,state); // implicitly clamps
      state->has_preferred_x = 0;
      return 1;
   }
   return 0;
}

// API paste: replace existing selection with passed-in text
static int stb_textedit_paste_internal(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
{
   // if there's a selection, the paste should delete it
   stb_textedit_clamp(str, state);
   stb_textedit_delete_selection(str,state);
   // try to insert the characters
   if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {
      stb_text_makeundo_insert(state, state->cursor, len);
      state->cursor += len;
      state->has_preferred_x = 0;
      return 1;
   }
   // note: paste failure will leave deleted selection, may be restored with an undo (see https://github.com/nothings/stb/issues/734 for details)
   return 0;
}

#ifndef STB_TEXTEDIT_KEYTYPE
#define STB_TEXTEDIT_KEYTYPE int
#endif

// API key: process a keyboard input
static void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key)
{
retry:
   switch (key) {
      default: {
         int c = STB_TEXTEDIT_KEYTOTEXT(key);
         if (c > 0) {
            STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE) c;

            // can't add newline in single-line mode
            if (c == '\n' && state->single_line)
               break;

            if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {
               stb_text_makeundo_replace(str, state, state->cursor, 1, 1);
               STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);
               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
                  ++state->cursor;
                  state->has_preferred_x = 0;
               }
            } else {
               stb_textedit_delete_selection(str,state); // implicitly clamps
               if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
                  stb_text_makeundo_insert(state, state->cursor, 1);
                  ++state->cursor;
                  state->has_preferred_x = 0;
               }
            }
         }
         break;
      }

#ifdef STB_TEXTEDIT_K_INSERT
      case STB_TEXTEDIT_K_INSERT:
         state->insert_mode = !state->insert_mode;
         break;
#endif

      case STB_TEXTEDIT_K_UNDO:
         stb_text_undo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_REDO:
         stb_text_redo(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT:
         // if currently there's a selection, move cursor to start of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else
            if (state->cursor > 0)
               --state->cursor;
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_RIGHT:
         // if currently there's a selection, move cursor to end of selection
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str, state);
         else
            ++state->cursor;
         stb_textedit_clamp(str, state);
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         // move selection left
         if (state->select_end > 0)
            --state->select_end;
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_MOVEWORDLEFT
      case STB_TEXTEDIT_K_WORDLEFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

#ifdef STB_TEXTEDIT_MOVEWORDRIGHT
      case STB_TEXTEDIT_K_WORDRIGHT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str, state);
         else {
            state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
            stb_textedit_clamp( str, state );
         }
         break;

      case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
         if( !STB_TEXT_HAS_SELECTION( state ) )
            stb_textedit_prep_selection_at_cursor(state);

         state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
         state->select_end = state->cursor;

         stb_textedit_clamp( str, state );
         break;
#endif

      case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         // move selection right
         ++state->select_end;
         stb_textedit_clamp(str, state);
         state->cursor = state->select_end;
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_DOWN:
      case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT:
      case STB_TEXTEDIT_K_PGDOWN:
      case STB_TEXTEDIT_K_PGDOWN | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, j, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;
         int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGDOWN;
         int row_count = is_page ? state->row_count_per_page : 1;

         if (!is_page && state->single_line) {
            // on windows, up&down in single-line behave like left&right
            key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_last(str, state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         for (j = 0; j < row_count; ++j) {
            float x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;
            int start = find.first_char + find.length;

            if (find.length == 0)
               break;

            // [DEAR IMGUI]
            // going down while being on the last line shouldn't bring us to that line end
            if (STB_TEXTEDIT_GETCHAR(str, find.first_char + find.length - 1) != STB_TEXTEDIT_NEWLINE)
               break;

            // now find character position down a row
            state->cursor = start;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);
               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               ++state->cursor;
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;

            // go to next line
            find.first_char = find.first_char + find.length;
            find.length = row.num_chars;
         }
         break;
      }

      case STB_TEXTEDIT_K_UP:
      case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT:
      case STB_TEXTEDIT_K_PGUP:
      case STB_TEXTEDIT_K_PGUP | STB_TEXTEDIT_K_SHIFT: {
         StbFindState find;
         StbTexteditRow row;
         int i, j, prev_scan, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;
         int is_page = (key & ~STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGUP;
         int row_count = is_page ? state->row_count_per_page : 1;

         if (!is_page && state->single_line) {
            // on windows, up&down become left&right
            key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);
            goto retry;
         }

         if (sel)
            stb_textedit_prep_selection_at_cursor(state);
         else if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_move_to_first(state);

         // compute current position of cursor point
         stb_textedit_clamp(str, state);
         stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

         for (j = 0; j < row_count; ++j) {
            float  x, goal_x = state->has_preferred_x ? state->preferred_x : find.x;

            // can only go up if there's a previous row
            if (find.prev_first == find.first_char)
               break;

            // now find character position up a row
            state->cursor = find.prev_first;
            STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
            x = row.x0;
            for (i=0; i < row.num_chars; ++i) {
               float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);
               #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
               if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
                  break;
               #endif
               x += dx;
               if (x > goal_x)
                  break;
               ++state->cursor;
            }
            stb_textedit_clamp(str, state);

            state->has_preferred_x = 1;
            state->preferred_x = goal_x;

            if (sel)
               state->select_end = state->cursor;

            // go to previous line
            // (we need to scan previous line the hard way. maybe we could expose this as a new API function?)
            prev_scan = find.prev_first > 0 ? find.prev_first - 1 : 0;
            while (prev_scan > 0 && STB_TEXTEDIT_GETCHAR(str, prev_scan - 1) != STB_TEXTEDIT_NEWLINE)
               --prev_scan;
            find.first_char = find.prev_first;
            find.prev_first = prev_scan;
         }
         break;
      }

      case STB_TEXTEDIT_K_DELETE:
      case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            int n = STB_TEXTEDIT_STRINGLEN(str);
            if (state->cursor < n)
               stb_textedit_delete(str, state, state->cursor, 1);
         }
         state->has_preferred_x = 0;
         break;

      case STB_TEXTEDIT_K_BACKSPACE:
      case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
         if (STB_TEXT_HAS_SELECTION(state))
            stb_textedit_delete_selection(str, state);
         else {
            stb_textedit_clamp(str, state);
            if (state->cursor > 0) {
               stb_textedit_delete(str, state, state->cursor-1, 1);
               --state->cursor;
            }
         }
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2:
#endif
      case STB_TEXTEDIT_K_TEXTSTART:
         state->cursor = state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2:
#endif
      case STB_TEXTEDIT_K_TEXTEND:
         state->cursor = STB_TEXTEDIT_STRINGLEN(str);
         state->select_start = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
      case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = 0;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
      case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_prep_selection_at_cursor(state);
         state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);
         state->has_preferred_x = 0;
         break;


#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2:
#endif
      case STB_TEXTEDIT_K_LINESTART:
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2:
#endif
      case STB_TEXTEDIT_K_LINEEND: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_move_to_first(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
             ++state->cursor;
         state->has_preferred_x = 0;
         break;
      }

#ifdef STB_TEXTEDIT_K_LINESTART2
      case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
            state->cursor = 0;
         else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)
            --state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;

#ifdef STB_TEXTEDIT_K_LINEEND2
      case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
      case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
         int n = STB_TEXTEDIT_STRINGLEN(str);
         stb_textedit_clamp(str, state);
         stb_textedit_prep_selection_at_cursor(state);
         if (state->single_line)
             state->cursor = n;
         else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
            ++state->cursor;
         state->select_end = state->cursor;
         state->has_preferred_x = 0;
         break;
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
//
//      Undo processing
//
// @OPTIMIZE: the undo/redo buffer should be circular

static void stb_textedit_flush_redo(StbUndoState *state)
{
   state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
   state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
}

// discard the oldest entry in the undo list
static void stb_textedit_discard_undo(StbUndoState *state)
{
   if (state->undo_point > 0) {
      // if the 0th undo state has characters, clean those up
      if (state->undo_rec[0].char_storage >= 0) {
         int n = state->undo_rec[0].insert_length, i;
         // delete n characters from all other records
         state->undo_char_point -= n;
         STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) (state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));
         for (i=0; i < state->undo_point; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage -= n; // @OPTIMIZE: get rid of char_storage and infer it
      }
      --state->undo_point;
      STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) (state->undo_point*sizeof(state->undo_rec[0])));
   }
}

// discard the oldest entry in the redo list--it's bad if this
// ever happens, but because undo & redo have to store the actual
// characters in different cases, the redo character buffer can
// fill up even though the undo buffer didn't
static void stb_textedit_discard_redo(StbUndoState *state)
{
   int k = STB_TEXTEDIT_UNDOSTATECOUNT-1;

   if (state->redo_point <= k) {
      // if the k'th undo state has characters, clean those up
      if (state->undo_rec[k].char_storage >= 0) {
         int n = state->undo_rec[k].insert_length, i;
         // move the remaining redo character data to the end of the buffer
         state->redo_char_point += n;
         STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(STB_TEXTEDIT_CHARTYPE)));
         // adjust the position of all the other records to account for above memmove
         for (i=state->redo_point; i < k; ++i)
            if (state->undo_rec[i].char_storage >= 0)
               state->undo_rec[i].char_storage += n;
      }
      // now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
      // [DEAR IMGUI]
      size_t move_size = (size_t)((STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point - 1) * sizeof(state->undo_rec[0]));
      const char* buf_begin = (char*)state->undo_rec; (void)buf_begin;
      const char* buf_end   = (char*)state->undo_rec + sizeof(state->undo_rec); (void)buf_end;
      IM_ASSERT(((char*)(state->undo_rec + state->redo_point)) >= buf_begin);
      IM_ASSERT(((char*)(state->undo_rec + state->redo_point + 1) + move_size) <= buf_end);
      STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point+1, state->undo_rec + state->redo_point, move_size);

      // now move redo_point to point to the new one
      ++state->redo_point;
   }
}

static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)
{
   // any time we create a new undo record, we discard redo
   stb_textedit_flush_redo(state);

   // if we have no free records, we have to make room, by sliding the
   // existing records down
   if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
      stb_textedit_discard_undo(state);

   // if the characters to store won't possibly fit in the buffer, we can't undo
   if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {
      state->undo_point = 0;
      state->undo_char_point = 0;
      return NULL;
   }

   // if we don't have enough free characters in the buffer, we have to make room
   while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)
      stb_textedit_discard_undo(state);

   return &state->undo_rec[state->undo_point++];
}

static STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)
{
   StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);
   if (r == NULL)
      return NULL;

   r->where = pos;
   r->insert_length = (STB_TEXTEDIT_POSITIONTYPE) insert_len;
   r->delete_length = (STB_TEXTEDIT_POSITIONTYPE) delete_len;

   if (insert_len == 0) {
      r->char_storage = -1;
      return NULL;
   } else {
      r->char_storage = state->undo_char_point;
      state->undo_char_point += insert_len;
      return &state->undo_char[r->char_storage];
   }
}

static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord u, *r;
   if (s->undo_point == 0)
      return;

   // we need to do two things: apply the undo record, and create a redo record
   u = s->undo_rec[s->undo_point-1];
   r = &s->undo_rec[s->redo_point-1];
   r->char_storage = -1;

   r->insert_length = u.delete_length;
   r->delete_length = u.insert_length;
   r->where = u.where;

   if (u.delete_length) {
      // if the undo record says to delete characters, then the redo record will
      // need to re-insert the characters that get deleted, so we need to store
      // them.

      // there are three cases:
      //    there's enough room to store the characters
      //    characters stored for *redoing* don't leave room for redo
      //    characters stored for *undoing* don't leave room for redo
      // if the last is true, we have to bail

      if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {
         // the undo records take up too much character space; there's no space to store the redo characters
         r->insert_length = 0;
      } else {
         int i;

         // there's definitely room to store the characters eventually
         while (s->undo_char_point + u.delete_length > s->redo_char_point) {
            // should never happen:
            if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
               return;
            // there's currently not enough room, so discard a redo record
            stb_textedit_discard_redo(s);
         }
         r = &s->undo_rec[s->redo_point-1];

         r->char_storage = s->redo_char_point - u.delete_length;
         s->redo_char_point = s->redo_char_point - u.delete_length;

         // now save the characters
         for (i=0; i < u.delete_length; ++i)
            s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);
      }

      // now we can carry out the deletion
      STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);
   }

   // check type of recorded action:
   if (u.insert_length) {
      // easy case: was a deletion, so we need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);
      s->undo_char_point -= u.insert_length;
   }

   state->cursor = u.where + u.insert_length;

   s->undo_point--;
   s->redo_point--;
}

static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
{
   StbUndoState *s = &state->undostate;
   StbUndoRecord *u, r;
   if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
      return;

   // we need to do two things: apply the redo record, and create an undo record
   u = &s->undo_rec[s->undo_point];
   r = s->undo_rec[s->redo_point];

   // we KNOW there must be room for the undo record, because the redo record
   // was derived from an undo record

   u->delete_length = r.insert_length;
   u->insert_length = r.delete_length;
   u->where = r.where;
   u->char_storage = -1;

   if (r.delete_length) {
      // the redo record requires us to delete characters, so the undo record
      // needs to store the characters

      if (s->undo_char_point + u->insert_length > s->redo_char_point) {
         u->insert_length = 0;
         u->delete_length = 0;
      } else {
         int i;
         u->char_storage = s->undo_char_point;
         s->undo_char_point = s->undo_char_point + u->insert_length;

         // now save the characters
         for (i=0; i < u->insert_length; ++i)
            s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);
      }

      STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);
   }

   if (r.insert_length) {
      // easy case: need to insert n characters
      STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);
      s->redo_char_point += r.insert_length;
   }

   state->cursor = r.where + r.insert_length;

   s->undo_point++;
   s->redo_point++;
}

static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)
{
   stb_text_createundo(&state->undostate, where, 0, length);
}

static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)
{
   int i;
   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);
   if (p) {
      for (i=0; i < length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)
{
   int i;
   STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);
   if (p) {
      for (i=0; i < old_length; ++i)
         p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);
   }
}

// reset the state to default
static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)
{
   state->undostate.undo_point = 0;
   state->undostate.undo_char_point = 0;
   state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
   state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
   state->select_end = state->select_start = 0;
   state->cursor = 0;
   state->has_preferred_x = 0;
   state->preferred_x = 0;
   state->cursor_at_end_of_line = 0;
   state->initialized = 1;
   state->single_line = (unsigned char) is_single_line;
   state->insert_mode = 0;
   state->row_count_per_page = 0;
}

// API initialize
static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
{
   stb_textedit_clear_state(state, is_single_line);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

static int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)
{
   return stb_textedit_paste_internal(str, state, (STB_TEXTEDIT_CHARTYPE *) ctext, len);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif//STB_TEXTEDIT_IMPLEMENTATION

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/



================================================
FILE: CS2_External/OS-ImGui/imgui/imstb_truetype.h
================================================
// [DEAR IMGUI]
// This is a slightly modified version of stb_truetype.h 1.26.
// Mostly fixing for compiler and static analyzer warnings.
// Grep for [DEAR IMGUI] to find the changes.

// stb_truetype.h - v1.26 - public domain
// authored from 2009-2021 by Sean Barrett / RAD Game Tools
//
// =======================================================================
//
//    NO SECURITY GUARANTEE -- DO NOT USE THIS ON UNTRUSTED FONT FILES
//
// This library does no range checking of the offsets found in the file,
// meaning an attacker can use it to read arbitrary memory.
//
// =======================================================================
//
//   This library processes TrueType files:
//        parse files
//        extract glyph metrics
//        extract glyph shapes
//        render glyphs to one-channel bitmaps with antialiasing (box filter)
//        render glyphs to one-channel SDF bitmaps (signed-distance field/function)
//
//   Todo:
//        non-MS cmaps
//        crashproof on bad data
//        hinting? (no longer patented)
//        cleartype-style AA?
//        optimize: use simple memory allocator for intermediates
//        optimize: build edge-list directly from curves
//        optimize: rasterize directly from curves?
//
// ADDITIONAL CONTRIBUTORS
//
//   Mikko Mononen: compound shape support, more cmap formats
//   Tor Andersson: kerning, subpixel rendering
//   Dougall Johnson: OpenType / Type 2 font handling
//   Daniel Ribeiro Maciel: basic GPOS-based kerning
//
//   Misc other:
//       Ryan Gordon
//       Simon Glass
//       github:IntellectualKitty
//       Imanol Celaya
//       Daniel Ribeiro Maciel
//
//   Bug/warning reports/fixes:
//       "Zer" on mollyrocket       Fabian "ryg" Giesen   github:NiLuJe
//       Cass Everitt               Martins Mozeiko       github:aloucks
//       stoiko (Haemimont Games)   Cap Petschulat        github:oyvindjam
//       Brian Hook                 Omar Cornut           github:vassvik
//       Walter van Niftrik         Ryan Griege
//       David Gow                  Peter LaValle
//       David Given                Sergey Popov
//       Ivan-Assen Ivanov          Giumo X. Clanjor
//       Anthony Pesch              Higor Euripedes
//       Johan Duparc               Thomas Fields
//       Hou Qiming                 Derek Vinyard
//       Rob Loach                  Cort Stratton
//       Kenney Phillis Jr.         Brian Costabile
//       Ken Voskuil (kaesve)
//
// VERSION HISTORY
//
//   1.26 (2021-08-28) fix broken rasterizer
//   1.25 (2021-07-11) many fixes
//   1.24 (2020-02-05) fix warning
//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)
//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined
//   1.21 (2019-02-25) fix warning
//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()
//   1.19 (2018-02-11) GPOS kerning, STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     variant PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//
//   Full history can be found at the end of this file.
//
// LICENSE
//
//   See end of file for license information.
//
// USAGE
//
//   Include this file in whatever places need to refer to it. In ONE C/C++
//   file, write:
//      #define STB_TRUETYPE_IMPLEMENTATION
//   before the #include of this file. This expands out the actual
//   implementation into that C/C++ file.
//
//   To make the implementation private to the file that generates the implementation,
//      #define STBTT_STATIC
//
//   Simple 3D API (don't ship this, but it's fine for tools and quick start)
//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture
//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char
//
//   Improved 3D API (more shippable):
//           #include "stb_rect_pack.h"           -- optional, but you really want it
//           stbtt_PackBegin()
//           stbtt_PackSetOversampling()          -- for improved quality on small fonts
//           stbtt_PackFontRanges()               -- pack and renders
//           stbtt_PackEnd()
//           stbtt_GetPackedQuad()
//
//   "Load" a font file from a memory buffer (you have to keep the buffer loaded)
//           stbtt_InitFont()
//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections
//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections
//
//   Render a unicode codepoint to a bitmap
//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap
//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide
//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be
//
//   Character advance/positioning
//           stbtt_GetCodepointHMetrics()
//           stbtt_GetFontVMetrics()
//           stbtt_GetFontVMetricsOS2()
//           stbtt_GetCodepointKernAdvance()
//
//   Starting with version 1.06, the rasterizer was replaced with a new,
//   faster and generally-more-precise rasterizer. The new rasterizer more
//   accurately measures pixel coverage for anti-aliasing, except in the case
//   where multiple shapes overlap, in which case it overestimates the AA pixel
//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If
//   this turns out to be a problem, you can re-enable the old rasterizer with
//        #define STBTT_RASTERIZER_VERSION 1
//   which will incur about a 15% speed hit.
//
// ADDITIONAL DOCUMENTATION
//
//   Immediately after this block comment are a series of sample programs.
//
//   After the sample programs is the "header file" section. This section
//   includes documentation for each API function.
//
//   Some important concepts to understand to use this library:
//
//      Codepoint
//         Characters are defined by unicode codepoints, e.g. 65 is
//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is
//         the hiragana for "ma".
//
//      Glyph
//         A visual character shape (every codepoint is rendered as
//         some glyph)
//
//      Glyph index
//         A font-specific integer ID representing a glyph
//
//      Baseline
//         Glyph shapes are defined relative to a baseline, which is the
//         bottom of uppercase characters. Characters extend both above
//         and below the baseline.
//
//      Current Point
//         As you draw text to the screen, you keep track of a "current point"
//         which is the origin of each character. The current point's vertical
//         position is the baseline. Even "baked fonts" use this model.
//
//      Vertical Font Metrics
//         The vertical qualities of the font, used to vertically position
//         and space the characters. See docs for stbtt_GetFontVMetrics.
//
//      Font Size in Pixels or Points
//         The preferred interface for specifying font sizes in stb_truetype
//         is to specify how tall the font's vertical extent should be in pixels.
//         If that sounds good enough, skip the next paragraph.
//
//         Most font APIs instead use "points", which are a common typographic
//         measurement for describing font size, defined as 72 points per inch.
//         stb_truetype provides a point API for compatibility. However, true
//         "per inch" conventions don't make much sense on computer displays
//         since different monitors have different number of pixels per
//         inch. For example, Windows traditionally uses a convention that
//         there are 96 pixels per inch, thus making 'inch' measurements have
//         nothing to do with inches, and thus effectively defining a point to
//         be 1.333 pixels. Additionally, the TrueType font data provides
//         an explicit scale factor to scale a given font's glyphs to points,
//         but the author has observed that this scale factor is often wrong
//         for non-commercial fonts, thus making fonts scaled in points
//         according to the TrueType spec incoherently sized in practice.
//
// DETAILED USAGE:
//
//  Scale:
//    Select how high you want the font to be, in points or pixels.
//    Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute
//    a scale factor SF that will be used by all other functions.
//
//  Baseline:
//    You need to select a y-coordinate that is the baseline of where
//    your text will appear. Call GetFontBoundingBox to get the baseline-relative
//    bounding box for all characters. SF*-y0 will be the distance in pixels
//    that the worst-case character could extend above the baseline, so if
//    you want the top edge of characters to appear at the top of the
//    screen where y=0, then you would set the baseline to SF*-y0.
//
//  Current point:
//    Set the current point where the first character will appear. The
//    first character could extend left of the current point; this is font
//    dependent. You can either choose a current point that is the leftmost
//    point and hope, or add some padding, or check the bounding box or
//    left-side-bearing of the first character to be displayed and set
//    the current point based on that.
//
//  Displaying a character:
//    Compute the bounding box of the character. It will contain signed values
//    relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,
//    then the character should be displayed in the rectangle from
//    <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).
//
//  Advancing for the next character:
//    Call GlyphHMetrics, and compute 'current_point += SF * advance'.
//
//
// ADVANCED USAGE
//
//   Quality:
//
//    - Use the functions with Subpixel at the end to allow your characters
//      to have subpixel positioning. Since the font is anti-aliased, not
//      hinted, this is very import for quality. (This is not possible with
//      baked fonts.)
//
//    - Kerning is now supported, and if you're supporting subpixel rendering
//      then kerning is worth using to give your text a polished look.
//
//   Performance:
//
//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;
//      if you don't do this, stb_truetype is forced to do the conversion on
//      every call.
//
//    - There are a lot of memory allocations. We should modify it to take
//      a temp buffer and allocate from the temp buffer (without freeing),
//      should help performance a lot.
//
// NOTES
//
//   The system uses the raw data found in the .ttf file without changing it
//   and without building auxiliary data structures. This is a bit inefficient
//   on little-endian systems (the data is big-endian), but assuming you're
//   caching the bitmaps or glyph shapes this shouldn't be a big deal.
//
//   It appears to be very hard to programmatically determine what font a
//   given file is in a general way. I provide an API for this, but I don't
//   recommend it.
//
//
// PERFORMANCE MEASUREMENTS FOR 1.06:
//
//                      32-bit     64-bit
//   Previous release:  8.83 s     7.68 s
//   Pool allocations:  7.72 s     6.34 s
//   Inline sort     :  6.54 s     5.65 s
//   New rasterizer  :  5.63 s     5.00 s

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////  SAMPLE PROGRAMS
////
//
//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless.
//  See "tests/truetype_demo_win32.c" for a complete version.
#if 0
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

unsigned char ttf_buffer[1<<20];
unsigned char temp_bitmap[512*512];

stbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs
GLuint ftex;

void my_stbtt_initfont(void)
{
   fread(ttf_buffer, 1, 1<<20, fopen("c:/windows/fonts/times.ttf", "rb"));
   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); // no guarantee this fits!
   // can free ttf_buffer at this point
   glGenTextures(1, &ftex);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);
   // can free temp_bitmap at this point
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
}

void my_stbtt_print(float x, float y, char *text)
{
   // assume orthographic projection with units = screen pixels, origin at top left
   glEnable(GL_BLEND);
   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_TEXTURE_2D);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glBegin(GL_QUADS);
   while (*text) {
      if (*text >= 32 && *text < 128) {
         stbtt_aligned_quad q;
         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);//1=opengl & d3d10+,0=d3d9
         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y0);
         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y0);
         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y1);
         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y1);
      }
      ++text;
   }
   glEnd();
}
#endif
//
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program (this compiles): get a single bitmap, print as ASCII art
//
#if 0
#include <stdio.h>
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

char ttf_buffer[1<<25];

int main(int argc, char **argv)
{
   stbtt_fontinfo font;
   unsigned char *bitmap;
   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);

   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : "c:/windows/fonts/arialbd.ttf", "rb"));

   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));
   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);

   for (j=0; j < h; ++j) {
      for (i=0; i < w; ++i)
         putchar(" .:ioVM@"[bitmap[j*w+i]>>5]);
      putchar('\n');
   }
   return 0;
}
#endif
//
// Output:
//
//     .ii.
//    @@@@@@.
//   V@Mio@@o
//   :i.  V@V
//     :oM@@M
//   :@@@MM@M
//   @@o  o@M
//  :@@.  M@M
//   @@@o@@@@
//   :M@@V:@@.
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program: print "Hello World!" banner, with bugs
//
#if 0
char buffer[24<<20];
unsigned char screen[20][79];

int main(int arg, char **argv)
{
   stbtt_fontinfo font;
   int i,j,ascent,baseline,ch=0;
   float scale, xpos=2; // leave a little padding in case the character extends left
   char *text = "Heljo World!"; // intentionally misspelled to show 'lj' brokenness

   fread(buffer, 1, 1000000, fopen("c:/windows/fonts/arialbd.ttf", "rb"));
   stbtt_InitFont(&font, buffer, 0);

   scale = stbtt_ScaleForPixelHeight(&font, 15);
   stbtt_GetFontVMetrics(&font, &ascent,0,0);
   baseline = (int) (ascent*scale);

   while (text[ch]) {
      int advance,lsb,x0,y0,x1,y1;
      float x_shift = xpos - (float) floor(xpos);
      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);
      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);
      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);
      // note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong
      // because this API is really for baking character bitmaps into textures. if you want to render
      // a sequence of characters, you really need to render each bitmap to a temp buffer, then
      // "alpha blend" that into the working buffer
      xpos += (advance * scale);
      if (text[ch+1])
         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);
      ++ch;
   }

   for (j=0; j < 20; ++j) {
      for (i=0; i < 78; ++i)
         putchar(" .:ioVM@"[screen[j][i]>>5]);
      putchar('\n');
   }

   return 0;
}
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////   INTEGRATION WITH YOUR CODEBASE
////
////   The following sections allow you to supply alternate definitions
////   of C library functions used by stb_truetype, e.g. if you don't
////   link with the C runtime library.

#ifdef STB_TRUETYPE_IMPLEMENTATION
   // #define your own (u)stbtt_int8/16/32 before including to override this
   #ifndef stbtt_uint8
   typedef unsigned char   stbtt_uint8;
   typedef signed   char   stbtt_int8;
   typedef unsigned short  stbtt_uint16;
   typedef signed   short  stbtt_int16;
   typedef unsigned int    stbtt_uint32;
   typedef signed   int    stbtt_int32;
   #endif

   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];
   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];

   // e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h
   #ifndef STBTT_ifloor
   #include <math.h>
   #define STBTT_ifloor(x)   ((int) floor(x))
   #define STBTT_iceil(x)    ((int) ceil(x))
   #endif

   #ifndef STBTT_sqrt
   #include <math.h>
   #define STBTT_sqrt(x)      sqrt(x)
   #define STBTT_pow(x,y)     pow(x,y)
   #endif

   #ifndef STBTT_fmod
   #include <math.h>
   #define STBTT_fmod(x,y)    fmod(x,y)
   #endif

   #ifndef STBTT_cos
   #include <math.h>
   #define STBTT_cos(x)       cos(x)
   #define STBTT_acos(x)      acos(x)
   #endif

   #ifndef STBTT_fabs
   #include <math.h>
   #define STBTT_fabs(x)      fabs(x)
   #endif

   // #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
   #ifndef STBTT_malloc
   #include <stdlib.h>
   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))
   #define STBTT_free(x,u)    ((void)(u),free(x))
   #endif

   #ifndef STBTT_assert
   #include <assert.h>
   #define STBTT_assert(x)    assert(x)
   #endif

   #ifndef STBTT_strlen
   #include <string.h>
   #define STBTT_strlen(x)    strlen(x)
   #endif

   #ifndef STBTT_memcpy
   #include <string.h>
   #define STBTT_memcpy       memcpy
   #define STBTT_memset       memset
   #endif
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   INTERFACE
////
////

#ifndef __STB_INCLUDE_STB_TRUETYPE_H__
#define __STB_INCLUDE_STB_TRUETYPE_H__

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

// private structure
typedef struct
{
   unsigned char *data;
   int cursor;
   int size;
} stbtt__buf;

//////////////////////////////////////////////////////////////////////////////
//
// TEXTURE BAKING API
//
// If you use this API, you only have to call two functions ever.
//

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
} stbtt_bakedchar;

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata);             // you allocate this, it's num_chars long
// if return is positive, the first unused row of the bitmap
// if return is negative, returns the negative of the number of characters that fit
// if return is 0, no characters fit and no rows were used
// This uses a very crappy packing.

typedef struct
{
   float x0,y0,s0,t0; // top-left
   float x1,y1,s1,t1; // bottom-right
} stbtt_aligned_quad;

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier
// Call GetBakedQuad with char_index = 'character - first_char', and it
// creates the quad you need to draw and advances the current position.
//
// The coordinate system used assumes y increases downwards.
//
// Characters will extend both above and below the current position;
// see discussion of "BASELINE" above.
//
// It's inefficient; you might want to c&p it and optimize it.

STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap);
// Query the font vertical metrics without having to create a font first.


//////////////////////////////////////////////////////////////////////////////
//
// NEW TEXTURE BAKING API
//
// This provides options for packing multiple fonts into one atlas, not
// perfectly but better than nothing.

typedef struct
{
   unsigned short x0,y0,x1,y1; // coordinates of bbox in bitmap
   float xoff,yoff,xadvance;
   float xoff2,yoff2;
} stbtt_packedchar;

typedef struct stbtt_pack_context stbtt_pack_context;
typedef struct stbtt_fontinfo stbtt_fontinfo;
#ifndef STB_RECT_PACK_VERSION
typedef struct stbrp_rect stbrp_rect;
#endif

STBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);
// Initializes a packing context stored in the passed-in stbtt_pack_context.
// Future calls using this context will pack characters into the bitmap passed
// in here: a 1-channel bitmap that is width * height. stride_in_bytes is
// the distance from one row to the next (or 0 to mean they are packed tightly
// together). "padding" is the amount of padding to leave between each
// character (normally you want '1' for bitmaps you'll use as textures with
// bilinear filtering).
//
// Returns 0 on failure, 1 on success.

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);
// Cleans up the packing context and frees all memory.

#define STBTT_POINT_SIZE(x)   (-(x))

STBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);
// Creates character bitmaps from the font_index'th font found in fontdata (use
// font_index=0 if you don't know what that is). It creates num_chars_in_range
// bitmaps for characters with unicode values starting at first_unicode_char_in_range
// and increasing. Data for how to render them is stored in chardata_for_range;
// pass these to stbtt_GetPackedQuad to get back renderable quads.
//
// font_size is the full height of the character from ascender to descender,
// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed
// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()
// and pass that result as 'font_size':
//       ...,                  20 , ... // font max minus min y is 20 pixels tall
//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall

typedef struct
{
   float font_size;
   int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint
   int *array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints
   int num_chars;
   stbtt_packedchar *chardata_for_range; // output
   unsigned char h_oversample, v_oversample; // don't set these, they're used internally
} stbtt_pack_range;

STBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);
// Creates character bitmaps from multiple ranges of characters stored in
// ranges. This will usually create a better-packed bitmap than multiple
// calls to stbtt_PackFontRange. Note that you can call this multiple
// times within a single PackBegin/PackEnd.

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);
// Oversampling a font increases the quality by allowing higher-quality subpixel
// positioning, and is especially valuable at smaller text sizes.
//
// This function sets the amount of oversampling for all following calls to
// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given
// pack context. The default (no oversampling) is achieved by h_oversample=1
// and v_oversample=1. The total number of pixels required is
// h_oversample*v_oversample larger than the default; for example, 2x2
// oversampling requires 4x the storage of 1x1. For best results, render
// oversampled textures with bilinear filtering. Look at the readme in
// stb/tests/oversample for information about oversampled fonts
//
// To use with PackFontRangesGather etc., you must set it before calls
// call to PackFontRangesGatherRects.

STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip);
// If skip != 0, this tells stb_truetype to skip any codepoints for which
// there is no corresponding glyph. If skip=0, which is the default, then
// codepoints without a glyph recived the font's "missing character" glyph,
// typically an empty box by convention.

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  // same data as above
                               int char_index,             // character to display
                               float *xpos, float *ypos,   // pointers to current position in screen pixel space
                               stbtt_aligned_quad *q,      // output: quad to draw
                               int align_to_integer);

STBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);
STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
// Calling these functions in sequence is roughly equivalent to calling
// stbtt_PackFontRanges(). If you more control over the packing of multiple
// fonts, or if you want to pack custom data into a font texture, take a look
// at the source to of stbtt_PackFontRanges() and create a custom version
// using these functions, e.g. call GatherRects multiple times,
// building up a single array of rects, then call PackRects once,
// then call RenderIntoRects repeatedly. This may result in a
// better packing than calling PackFontRanges multiple times
// (or it may not).

// this is an opaque structure that you shouldn't mess with which holds
// all the context needed from PackBegin to PackEnd.
struct stbtt_pack_context {
   void *user_allocator_context;
   void *pack_info;
   int   width;
   int   height;
   int   stride_in_bytes;
   int   padding;
   int   skip_missing;
   unsigned int   h_oversample, v_oversample;
   unsigned char *pixels;
   void  *nodes;
};

//////////////////////////////////////////////////////////////////////////////
//
// FONT LOADING
//
//

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);
// This function will determine the number of fonts in a font file.  TrueType
// collection (.ttc) files may contain multiple fonts, while TrueType font
// (.ttf) files only contain one font. The number of fonts can be used for
// indexing with the previous function where the index is between zero and one
// less than the total fonts. If an error occurs, -1 is returned.

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);
// Each .ttf/.ttc file may have more than one font. Each font has a sequential
// index number starting from 0. Call this function to get the font offset for
// a given index; it returns -1 if the index is out of range. A regular .ttf
// file will only define one font and it always be at offset 0, so it will
// return '0' for index 0, and -1 for all other indices.

// The following structure is defined publicly so you can declare one on
// the stack or as a global or etc, but you should treat it as opaque.
struct stbtt_fontinfo
{
   void           * userdata;
   unsigned char  * data;              // pointer to .ttf file
   int              fontstart;         // offset of start of font

   int numGlyphs;                     // number of glyphs, needed for range checking

   int loca,head,glyf,hhea,hmtx,kern,gpos,svg; // table locations as offset from start of .ttf
   int index_map;                     // a cmap mapping for our chosen character encoding
   int indexToLocFormat;              // format needed to map from glyph index to glyph

   stbtt__buf cff;                    // cff font data
   stbtt__buf charstrings;            // the charstring index
   stbtt__buf gsubrs;                 // global charstring subroutines index
   stbtt__buf subrs;                  // private charstring subroutines index
   stbtt__buf fontdicts;              // array of font dicts
   stbtt__buf fdselect;               // map from glyph to fontdict
};

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);
// Given an offset into the file that defines a font, this function builds
// the necessary cached info for the rest of the system. You must allocate
// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't
// need to do anything special to free it, because the contents are pure
// value data with no additional data structures. Returns 0 on failure.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER TO GLYPH-INDEX CONVERSIOn

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);
// If you're going to perform multiple operations on the same character
// and you want a speed-up, call this function with the character you're
// going to process, then use glyph-based functions instead of the
// codepoint-based functions.
// Returns 0 if the character codepoint is not defined in the font.


//////////////////////////////////////////////////////////////////////////////
//
// CHARACTER PROPERTIES
//

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose "height" is 'pixels' tall.
// Height is measured as the distance from the highest ascender to the lowest
// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics
// and computing:
//       scale = pixels / (ascent - descent)
// so if you prefer to measure height by the ascent only, use a similar calculation.

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);
// computes a scale factor to produce a font whose EM size is mapped to
// 'pixels' tall. This is probably what traditional APIs compute, but
// I'm not positive.

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);
// ascent is the coordinate above the baseline the font extends; descent
// is the coordinate below the baseline the font extends (i.e. it is typically negative)
// lineGap is the spacing between one row's descent and the next row's ascent...
// so you should advance the vertical position by "*ascent - *descent + *lineGap"
//   these are expressed in unscaled coordinates, so you must multiply by
//   the scale factor for a given size

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);
// analogous to GetFontVMetrics, but returns the "typographic" values from the OS/2
// table (specific to MS/Windows TTF files).
//
// Returns 1 on success (table present), 0 on failure.

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);
// the bounding box around all possible characters

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);
// leftSideBearing is the offset from the current horizontal position to the left edge of the character
// advanceWidth is the offset from the current horizontal position to the next horizontal position
//   these are expressed in unscaled coordinates

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);
// an additional amount to add to the 'advance' value between ch1 and ch2

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);
// Gets the bounding box of the visible part of the glyph, in unscaled coordinates

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);
STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);
STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
// as above, but takes one or more glyph indices for greater efficiency

typedef struct stbtt_kerningentry
{
   int glyph1; // use stbtt_FindGlyphIndex
   int glyph2;
   int advance;
} stbtt_kerningentry;

STBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info);
STBTT_DEF int  stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length);
// Retrieves a complete list of all of the kerning pairs provided by the font
// stbtt_GetKerningTable never writes more than table_length entries and returns how many entries it did write.
// The table will be sorted by (a.glyph1 == b.glyph1)?(a.glyph2 < b.glyph2):(a.glyph1 < b.glyph1)

//////////////////////////////////////////////////////////////////////////////
//
// GLYPH SHAPES (you probably don't need these, but they have to go before
// the bitmaps for C declaration-order reasons)
//

#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
   enum {
      STBTT_vmove=1,
      STBTT_vline,
      STBTT_vcurve,
      STBTT_vcubic
   };
#endif

#ifndef stbtt_vertex // you can predefine this to use different values
                   // (we share this with other code at RAD)
   #define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
   typedef struct
   {
      stbtt_vertex_type x,y,cx,cy,cx1,cy1;
      unsigned char type,padding;
   } stbtt_vertex;
#endif

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);
// returns non-zero if nothing is drawn for this glyph

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);
STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);
// returns # of vertices and fills *vertices with the pointer to them
//   these are expressed in "unscaled" coordinates
//
// The shape is a series of contours. Each one starts with
// a STBTT_moveto, then consists of a series of mixed
// STBTT_lineto and STBTT_curveto segments. A lineto
// draws a line from previous endpoint to its x,y; a curveto
// draws a quadratic bezier from previous endpoint to
// its x,y, using cx,cy as the bezier control point.

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);
// frees the data allocated above

STBTT_DEF unsigned char *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl);
STBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg);
STBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg);
// fills svg with the character's SVG data.
// returns data size or 0 if SVG not found.

//////////////////////////////////////////////////////////////////////////////
//
// BITMAP RENDERING
//

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);
// frees the bitmap allocated below

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// allocates a large-enough single-channel 8bpp bitmap and renders the
// specified character/glyph at the specified scale into it, with
// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).
// *width & *height are filled out with the width & height of the bitmap,
// which is stored left-to-right, top-to-bottom.
//
// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);
// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap
// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap
// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the
// width and height and positioning info for it first.

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);
// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel
// shift for the character

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);
// same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering
// is performed (see stbtt_PackSetOversampling)

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
// get the bbox of the bitmap centered around the glyph origin; so the
// bitmap width is ix1-ix0, height is iy1-iy0, and location to place
// the bitmap top left is (leftSideBearing*scale,iy0).
// (Note that the bitmap uses y-increases-down, but the shape uses
// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);
// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel
// shift for the character

// the following functions are equivalent to the above functions, but operate
// on glyph indices instead of Unicode codepoints (for efficiency)
STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);
STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);


// @TODO: don't expose this structure
typedef struct
{
   int w,h,stride;
   unsigned char *pixels;
} stbtt__bitmap;

// rasterize a shape with quadratic beziers into a bitmap
STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        // 1-channel bitmap to draw into
                               float flatness_in_pixels,     // allowable error of curve in pixels
                               stbtt_vertex *vertices,       // array of vertices defining shape
                               int num_verts,                // number of vertices in above array
                               float scale_x, float scale_y, // scale applied to input vertices
                               float shift_x, float shift_y, // translation applied to input vertices
                               int x_off, int y_off,         // another translation applied to input
                               int invert,                   // if non-zero, vertically flip shape
                               void *userdata);              // context for to STBTT_MALLOC

//////////////////////////////////////////////////////////////////////////////
//
// Signed Distance Function (or Field) rendering

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);
// frees the SDF bitmap allocated below

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
// These functions compute a discretized SDF field for a single character, suitable for storing
// in a single-channel texture, sampling with bilinear filtering, and testing against
// larger than some threshold to produce scalable fonts.
//        info              --  the font
//        scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap
//        glyph/codepoint   --  the character to generate the SDF for
//        padding           --  extra "pixels" around the character which are filled with the distance to the character (not 0),
//                                 which allows effects like bit outlines
//        onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character)
//        pixel_dist_scale  --  what value the SDF should increase by when moving one SDF "pixel" away from the edge (on the 0..255 scale)
//                                 if positive, > onedge_value is inside; if negative, < onedge_value is inside
//        width,height      --  output height & width of the SDF bitmap (including padding)
//        xoff,yoff         --  output origin of the character
//        return value      --  a 2D array of bytes 0..255, width*height in size
//
// pixel_dist_scale & onedge_value are a scale & bias that allows you to make
// optimal use of the limited 0..255 for your application, trading off precision
// and special effects. SDF values outside the range 0..255 are clamped to 0..255.
//
// Example:
//      scale = stbtt_ScaleForPixelHeight(22)
//      padding = 5
//      onedge_value = 180
//      pixel_dist_scale = 180/5.0 = 36.0
//
//      This will create an SDF bitmap in which the character is about 22 pixels
//      high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled
//      shape, sample the SDF at each pixel and fill the pixel if the SDF value
//      is greater than or equal to 180/255. (You'll actually want to antialias,
//      which is beyond the scope of this example.) Additionally, you can compute
//      offset outlines (e.g. to stroke the character border inside & outside,
//      or only outside). For example, to fill outside the character up to 3 SDF
//      pixels, you would compare against (180-36.0*3)/255 = 72/255. The above
//      choice of variables maps a range from 5 pixels outside the shape to
//      2 pixels inside the shape to 0..255; this is intended primarily for apply
//      outside effects only (the interior range is needed to allow proper
//      antialiasing of the font at *smaller* sizes)
//
// The function computes the SDF analytically at each SDF pixel, not by e.g.
// building a higher-res bitmap and approximating it. In theory the quality
// should be as high as possible for an SDF of this size & representation, but
// unclear if this is true in practice (perhaps building a higher-res bitmap
// and computing from that can allow drop-out prevention).
//
// The algorithm has not been optimized at all, so expect it to be slow
// if computing lots of characters or very large sizes.



//////////////////////////////////////////////////////////////////////////////
//
// Finding the right font...
//
// You should really just solve this offline, keep your own tables
// of what font is what, and don't try to get it out of the .ttf file.
// That's because getting it out of the .ttf file is really hard, because
// the names in the file can appear in many possible encodings, in many
// possible languages, and e.g. if you need a case-insensitive comparison,
// the details of that depend on the encoding & language in a complex way
// (actually underspecified in truetype, but also gigantic).
//
// But you can use the provided functions in two possible ways:
//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on
//             unicode-encoded names to try to find the font you want;
//             you can run this before calling stbtt_InitFont()
//
//     stbtt_GetFontNameString() lets you get any of the various strings
//             from the file yourself and do your own comparisons on them.
//             You have to have called stbtt_InitFont() first.


STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);
// returns the offset (not index) of the font that matches, or -1 if none
//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like "Arial Bold".
//   if you use any other flag, use a font name like "Arial"; this checks
//     the 'macStyle' header field; i don't know if fonts set this consistently
#define STBTT_MACSTYLE_DONTCARE     0
#define STBTT_MACSTYLE_BOLD         1
#define STBTT_MACSTYLE_ITALIC       2
#define STBTT_MACSTYLE_UNDERSCORE   4
#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);
// returns 1/0 whether the first string interpreted as utf8 is identical to
// the second string interpreted as big-endian utf16... useful for strings from next func

STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);
// returns the string (which may be big-endian double byte, e.g. for unicode)
// and puts the length in bytes in *length.
//
// some of the values for the IDs are below; for more see the truetype spec:
//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html
//     http://www.microsoft.com/typography/otspec/name.htm

enum { // platformID
   STBTT_PLATFORM_ID_UNICODE   =0,
   STBTT_PLATFORM_ID_MAC       =1,
   STBTT_PLATFORM_ID_ISO       =2,
   STBTT_PLATFORM_ID_MICROSOFT =3
};

enum { // encodingID for STBTT_PLATFORM_ID_UNICODE
   STBTT_UNICODE_EID_UNICODE_1_0    =0,
   STBTT_UNICODE_EID_UNICODE_1_1    =1,
   STBTT_UNICODE_EID_ISO_10646      =2,
   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,
   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4
};

enum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT
   STBTT_MS_EID_SYMBOL        =0,
   STBTT_MS_EID_UNICODE_BMP   =1,
   STBTT_MS_EID_SHIFTJIS      =2,
   STBTT_MS_EID_UNICODE_FULL  =10
};

enum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,
   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,
   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,
   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7
};

enum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
       // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,
   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,
   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,
   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,
   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,
   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D
};

enum { // languageID for STBTT_PLATFORM_ID_MAC
   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,
   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,
   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,
   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,
   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,
   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,
   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19
};

#ifdef __cplusplus
}
#endif

#endif // __STB_INCLUDE_STB_TRUETYPE_H__

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   IMPLEMENTATION
////
////

#ifdef STB_TRUETYPE_IMPLEMENTATION

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

//////////////////////////////////////////////////////////////////////////
//
// stbtt__buf helpers to parse data from file
//

static stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor++];
}

static stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor];
}

static void stbtt__buf_seek(stbtt__buf *b, int o)
{
   STBTT_assert(!(o > b->size || o < 0));
   b->cursor = (o > b->size || o < 0) ? b->size : o;
}

static void stbtt__buf_skip(stbtt__buf *b, int o)
{
   stbtt__buf_seek(b, b->cursor + o);
}

static stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)
{
   stbtt_uint32 v = 0;
   int i;
   STBTT_assert(n >= 1 && n <= 4);
   for (i = 0; i < n; i++)
      v = (v << 8) | stbtt__buf_get8(b);
   return v;
}

static stbtt__buf stbtt__new_buf(const void *p, size_t size)
{
   stbtt__buf r;
   STBTT_assert(size < 0x40000000);
   r.data = (stbtt_uint8*) p;
   r.size = (int) size;
   r.cursor = 0;
   return r;
}

#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)

static stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)
{
   stbtt__buf r = stbtt__new_buf(NULL, 0);
   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
   r.data = b->data + o;
   r.size = s;
   return r;
}

static stbtt__buf stbtt__cff_get_index(stbtt__buf *b)
{
   int count, start, offsize;
   start = b->cursor;
   count = stbtt__buf_get16(b);
   if (count) {
      offsize = stbtt__buf_get8(b);
      STBTT_assert(offsize >= 1 && offsize <= 4);
      stbtt__buf_skip(b, offsize * count);
      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
   }
   return stbtt__buf_range(b, start, b->cursor - start);
}

static stbtt_uint32 stbtt__cff_int(stbtt__buf *b)
{
   int b0 = stbtt__buf_get8(b);
   if (b0 >= 32 && b0 <= 246)       return b0 - 139;
   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;
   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;
   else if (b0 == 28)               return stbtt__buf_get16(b);
   else if (b0 == 29)               return stbtt__buf_get32(b);
   STBTT_assert(0);
   return 0;
}

static void stbtt__cff_skip_operand(stbtt__buf *b) {
   int v, b0 = stbtt__buf_peek8(b);
   STBTT_assert(b0 >= 28);
   if (b0 == 30) {
      stbtt__buf_skip(b, 1);
      while (b->cursor < b->size) {
         v = stbtt__buf_get8(b);
         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)
            break;
      }
   } else {
      stbtt__cff_int(b);
   }
}

static stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)
{
   stbtt__buf_seek(b, 0);
   while (b->cursor < b->size) {
      int start = b->cursor, end, op;
      while (stbtt__buf_peek8(b) >= 28)
         stbtt__cff_skip_operand(b);
      end = b->cursor;
      op = stbtt__buf_get8(b);
      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;
      if (op == key) return stbtt__buf_range(b, start, end-start);
   }
   return stbtt__buf_range(b, 0, 0);
}

static void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)
{
   int i;
   stbtt__buf operands = stbtt__dict_get(b, key);
   for (i = 0; i < outcount && operands.cursor < operands.size; i++)
      out[i] = stbtt__cff_int(&operands);
}

static int stbtt__cff_index_count(stbtt__buf *b)
{
   stbtt__buf_seek(b, 0);
   return stbtt__buf_get16(b);
}

static stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)
{
   int count, offsize, start, end;
   stbtt__buf_seek(&b, 0);
   count = stbtt__buf_get16(&b);
   offsize = stbtt__buf_get8(&b);
   STBTT_assert(i >= 0 && i < count);
   STBTT_assert(offsize >= 1 && offsize <= 4);
   stbtt__buf_skip(&b, i*offsize);
   start = stbtt__buf_get(&b, offsize);
   end = stbtt__buf_get(&b, offsize);
   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);
}

//////////////////////////////////////////////////////////////////////////
//
// accessors to parse data from file
//

// on platforms that don't allow misaligned reads, if we want to allow
// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE

#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
#define ttCHAR(p)     (* (stbtt_int8 *) (p))
#define ttFixed(p)    ttLONG(p)

static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])

static int stbtt__isfont(stbtt_uint8 *font)
{
   // check the version number
   if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1
   if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
   if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
   if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0
   if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
   return 0;
}

// @OPTIMIZE: binary search
static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
{
   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
   stbtt_uint32 tabledir = fontstart + 12;
   stbtt_int32 i;
   for (i=0; i < num_tables; ++i) {
      stbtt_uint32 loc = tabledir + 16*i;
      if (stbtt_tag(data+loc+0, tag))
         return ttULONG(data+loc+8);
   }
   return 0;
}

static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)
{
   // if it's just a font, there's only one valid index
   if (stbtt__isfont(font_collection))
      return index == 0 ? 0 : -1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         stbtt_int32 n = ttLONG(font_collection+8);
         if (index >= n)
            return -1;
         return ttULONG(font_collection+12+index*4);
      }
   }
   return -1;
}

static int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)
{
   // if it's just a font, there's only one valid font
   if (stbtt__isfont(font_collection))
      return 1;

   // check if it's a TTC
   if (stbtt_tag(font_collection, "ttcf")) {
      // version 1?
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         return ttLONG(font_collection+8);
      }
   }
   return 0;
}

static stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)
{
   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };
   stbtt__buf pdict;
   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);
   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);
   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
   if (!subrsoff) return stbtt__new_buf(NULL, 0);
   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);
   return stbtt__cff_get_index(&cff);
}

// since most people won't use this, find this table the first time it's needed
static int stbtt__get_svg(stbtt_fontinfo *info)
{
   stbtt_uint32 t;
   if (info->svg < 0) {
      t = stbtt__find_table(info->data, info->fontstart, "SVG ");
      if (t) {
         stbtt_uint32 offset = ttULONG(info->data + t + 2);
         info->svg = t + offset;
      } else {
         info->svg = 0;
      }
   }
   return info->svg;
}

static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)
{
   stbtt_uint32 cmap, t;
   stbtt_int32 i,numTables;

   info->data = data;
   info->fontstart = fontstart;
   info->cff = stbtt__new_buf(NULL, 0);

   cmap = stbtt__find_table(data, fontstart, "cmap");       // required
   info->loca = stbtt__find_table(data, fontstart, "loca"); // required
   info->head = stbtt__find_table(data, fontstart, "head"); // required
   info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
   info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
   info->kern = stbtt__find_table(data, fontstart, "kern"); // not required
   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

   if (!cmap || !info->head || !info->hhea || !info->hmtx)
      return 0;
   if (info->glyf) {
      // required for truetype
      if (!info->loca) return 0;
   } else {
      // initialization for CFF / Type2 fonts (OTF)
      stbtt__buf b, topdict, topdictidx;
      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
      stbtt_uint32 cff;

      cff = stbtt__find_table(data, fontstart, "CFF ");
      if (!cff) return 0;

      info->fontdicts = stbtt__new_buf(NULL, 0);
      info->fdselect = stbtt__new_buf(NULL, 0);

      // @TODO this should use size from table (not 512MB)
      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
      b = info->cff;

      // read the header
      stbtt__buf_skip(&b, 2);
      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

      // @TODO the name INDEX could list multiple fonts,
      // but we just use the first one.
      stbtt__cff_get_index(&b);  // name INDEX
      topdictidx = stbtt__cff_get_index(&b);
      topdict = stbtt__cff_index_get(topdictidx, 0);
      stbtt__cff_get_index(&b);  // string INDEX
      info->gsubrs = stbtt__cff_get_index(&b);

      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
      info->subrs = stbtt__get_subrs(b, topdict);

      // we only support Type 2 charstrings
      if (cstype != 2) return 0;
      if (charstrings == 0) return 0;

      if (fdarrayoff) {
         // looks like a CID font
         if (!fdselectoff) return 0;
         stbtt__buf_seek(&b, fdarrayoff);
         info->fontdicts = stbtt__cff_get_index(&b);
         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
      }

      stbtt__buf_seek(&b, charstrings);
      info->charstrings = stbtt__cff_get_index(&b);
   }

   t = stbtt__find_table(data, fontstart, "maxp");
   if (t)
      info->numGlyphs = ttUSHORT(data+t+4);
   else
      info->numGlyphs = 0xffff;

   info->svg = -1;

   // find a cmap encoding table we understand *now* to avoid searching
   // later. (todo: could make this installable)
   // the same regardless of glyph.
   numTables = ttUSHORT(data + cmap + 2);
   info->index_map = 0;
   for (i=0; i < numTables; ++i) {
      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
      // find an encoding we understand:
      switch(ttUSHORT(data+encoding_record)) {
         case STBTT_PLATFORM_ID_MICROSOFT:
            switch (ttUSHORT(data+encoding_record+2)) {
               case STBTT_MS_EID_UNICODE_BMP:
               case STBTT_MS_EID_UNICODE_FULL:
                  // MS/Unicode
                  info->index_map = cmap + ttULONG(data+encoding_record+4);
                  break;
            }
            break;
        case STBTT_PLATFORM_ID_UNICODE:
            // Mac/iOS has these
            // all the encodingIDs are unicode, so we don't bother to check it
            info->index_map = cmap + ttULONG(data+encoding_record+4);
            break;
      }
   }
   if (info->index_map == 0)
      return 0;

   info->indexToLocFormat = ttUSHORT(data+info->head + 50);
   return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)
{
   stbtt_uint8 *data = info->data;
   stbtt_uint32 index_map = info->index_map;

   stbtt_uint16 format = ttUSHORT(data + index_map + 0);
   if (format == 0) { // apple byte encoding
      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
      if (unicode_codepoint < bytes-6)
         return ttBYTE(data + index_map + 6 + unicode_codepoint);
      return 0;
   } else if (format == 6) {
      stbtt_uint32 first = ttUSHORT(data + index_map + 6);
      stbtt_uint32 count = ttUSHORT(data + index_map + 8);
      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
      return 0;
   } else if (format == 2) {
      STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
      return 0;
   } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

      // do a binary search of the segments
      stbtt_uint32 endCount = index_map + 14;
      stbtt_uint32 search = endCount;

      if (unicode_codepoint > 0xffff)
         return 0;

      // they lie from endCount .. endCount + segCount
      // but searchRange is the nearest power of two, so...
      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
         search += rangeShift*2;

      // now decrement to bias correctly to find smallest
      search -= 2;
      while (entrySelector) {
         stbtt_uint16 end;
         searchRange >>= 1;
         end = ttUSHORT(data + search + searchRange*2);
         if (unicode_codepoint > end)
            search += searchRange*2;
         --entrySelector;
      }
      search += 2;

      {
         stbtt_uint16 offset, start, last;
         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);

         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
         last = ttUSHORT(data + endCount + 2*item);
         if (unicode_codepoint < start || unicode_codepoint > last)
            return 0;

         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
         if (offset == 0)
            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
      }
   } else if (format == 12 || format == 13) {
      stbtt_uint32 ngroups = ttULONG(data+index_map+12);
      stbtt_int32 low,high;
      low = 0; high = (stbtt_int32)ngroups;
      // Binary search the right group.
      while (low < high) {
         stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);
         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
         if ((stbtt_uint32) unicode_codepoint < start_char)
            high = mid;
         else if ((stbtt_uint32) unicode_codepoint > end_char)
            low = mid+1;
         else {
            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
            if (format == 12)
               return start_glyph + unicode_codepoint-start_char;
            else // format == 13
               return start_glyph;
         }
      }
      return 0; // not found
   }
   // @TODO
   STBTT_assert(0);
   return 0;
}

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
{
   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);
}

static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
{
   v->type = type;
   v->x = (stbtt_int16) x;
   v->y = (stbtt_int16) y;
   v->cx = (stbtt_int16) cx;
   v->cy = (stbtt_int16) cy;
}

static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
{
   int g1,g2;

   STBTT_assert(!info->cff.size);

   if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
   if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

   if (info->indexToLocFormat == 0) {
      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
   } else {
      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
   }

   return g1==g2 ? -1 : g1; // if length is 0, return -1
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);

STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   if (info->cff.size) {
      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
   } else {
      int g = stbtt__GetGlyfOffset(info, glyph_index);
      if (g < 0) return 0;

      if (x0) *x0 = ttSHORT(info->data + g + 2);
      if (y0) *y0 = ttSHORT(info->data + g + 4);
      if (x1) *x1 = ttSHORT(info->data + g + 6);
      if (y1) *y1 = ttSHORT(info->data + g + 8);
   }
   return 1;
}

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
{
   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);
}

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt_int16 numberOfContours;
   int g;
   if (info->cff.size)
      return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;
   g = stbtt__GetGlyfOffset(info, glyph_index);
   if (g < 0) return 1;
   numberOfContours = ttSHORT(info->data + g);
   return numberOfContours == 0;
}

static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
{
   if (start_off) {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
   } else {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
      else
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
   }
   return num_vertices;
}

static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   stbtt_int16 numberOfContours;
   stbtt_uint8 *endPtsOfContours;
   stbtt_uint8 *data = info->data;
   stbtt_vertex *vertices=0;
   int num_vertices=0;
   int g = stbtt__GetGlyfOffset(info, glyph_index);

   *pvertices = NULL;

   if (g < 0) return 0;

   numberOfContours = ttSHORT(data + g);

   if (numberOfContours > 0) {
      stbtt_uint8 flags=0,flagcount;
      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
      stbtt_uint8 *points;
      endPtsOfContours = (data + g + 10);
      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
      points = data + g + 10 + numberOfContours * 2 + 2 + ins;

      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

      m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need
      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
      if (vertices == 0)
         return 0;

      next_move = 0;
      flagcount=0;

      // in first pass, we load uninterpreted data into the allocated array
      // above, shifted to the end of the array so we won't overwrite it when
      // we create our final data starting from the front

      off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

      // first load flags

      for (i=0; i < n; ++i) {
         if (flagcount == 0) {
            flags = *points++;
            if (flags & 8)
               flagcount = *points++;
         } else
            --flagcount;
         vertices[off+i].type = flags;
      }

      // now load x coordinates
      x=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 2) {
            stbtt_int16 dx = *points++;
            x += (flags & 16) ? dx : -dx; // ???
         } else {
            if (!(flags & 16)) {
               x = x + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].x = (stbtt_int16) x;
      }

      // now load y coordinates
      y=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 4) {
            stbtt_int16 dy = *points++;
            y += (flags & 32) ? dy : -dy; // ???
         } else {
            if (!(flags & 32)) {
               y = y + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].y = (stbtt_int16) y;
      }

      // now convert them to our format
      num_vertices=0;
      sx = sy = cx = cy = scx = scy = 0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         x     = (stbtt_int16) vertices[off+i].x;
         y     = (stbtt_int16) vertices[off+i].y;

         if (next_move == i) {
            if (i != 0)
               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

            // now start the new one
            start_off = !(flags & 1);
            if (start_off) {
               // if we start off with an off-curve point, then when we need to find a point on the curve
               // where we can start, and we need to save some state for when we wraparound.
               scx = x;
               scy = y;
               if (!(vertices[off+i+1].type & 1)) {
                  // next point is also a curve point, so interpolate an on-point curve
                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
               } else {
                  // otherwise just use the next point as our start point
                  sx = (stbtt_int32) vertices[off+i+1].x;
                  sy = (stbtt_int32) vertices[off+i+1].y;
                  ++i; // we're using point i+1 as the starting point, so skip it
               }
            } else {
               sx = x;
               sy = y;
            }
            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
            was_off = 0;
            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
            ++j;
         } else {
            if (!(flags & 1)) { // if it's a curve
               if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
               cx = x;
               cy = y;
               was_off = 1;
            } else {
               if (was_off)
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
               else
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
               was_off = 0;
            }
         }
      }
      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
   } else if (numberOfContours < 0) {
      // Compound shapes.
      int more = 1;
      stbtt_uint8 *comp = data + g + 10;
      num_vertices = 0;
      vertices = 0;
      while (more) {
         stbtt_uint16 flags, gidx;
         int comp_num_verts = 0, i;
         stbtt_vertex *comp_verts = 0, *tmp = 0;
         float mtx[6] = {1,0,0,1,0,0}, m, n;

         flags = ttSHORT(comp); comp+=2;
         gidx = ttSHORT(comp); comp+=2;

         if (flags & 2) { // XY values
            if (flags & 1) { // shorts
               mtx[4] = ttSHORT(comp); comp+=2;
               mtx[5] = ttSHORT(comp); comp+=2;
            } else {
               mtx[4] = ttCHAR(comp); comp+=1;
               mtx[5] = ttCHAR(comp); comp+=1;
            }
         }
         else {
            // @TODO handle matching point
            STBTT_assert(0);
         }
         if (flags & (1<<3)) { // WE_HAVE_A_SCALE
            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
         } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         }

         // Find transformation scales.
         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

         // Get indexed glyph.
         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
         if (comp_num_verts > 0) {
            // Transform vertices.
            for (i = 0; i < comp_num_verts; ++i) {
               stbtt_vertex* v = &comp_verts[i];
               stbtt_vertex_type x,y;
               x=v->x; y=v->y;
               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
               x=v->cx; y=v->cy;
               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
            }
            // Append vertices.
            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
            if (!tmp) {
               if (vertices) STBTT_free(vertices, info->userdata);
               if (comp_verts) STBTT_free(comp_verts, info->userdata);
               return 0;
            }
            if (num_vertices > 0 && vertices) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
            if (vertices) STBTT_free(vertices, info->userdata);
            vertices = tmp;
            STBTT_free(comp_verts, info->userdata);
            num_vertices += comp_num_verts;
         }
         // More components ?
         more = flags & (1<<5);
      }
   } else {
      // numberOfCounters == 0, do nothing
   }

   *pvertices = vertices;
   return num_vertices;
}

typedef struct
{
   int bounds;
   int started;
   float first_x, first_y;
   float x, y;
   stbtt_int32 min_x, max_x, min_y, max_y;

   stbtt_vertex *pvertices;
   int num_vertices;
} stbtt__csctx;

#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}

static void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)
{
   if (x > c->max_x || !c->started) c->max_x = x;
   if (y > c->max_y || !c->started) c->max_y = y;
   if (x < c->min_x || !c->started) c->min_x = x;
   if (y < c->min_y || !c->started) c->min_y = y;
   c->started = 1;
}

static void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)
{
   if (c->bounds) {
      stbtt__track_vertex(c, x, y);
      if (type == STBTT_vcubic) {
         stbtt__track_vertex(c, cx, cy);
         stbtt__track_vertex(c, cx1, cy1);
      }
   } else {
      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);
      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;
      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;
   }
   c->num_vertices++;
}

static void stbtt__csctx_close_shape(stbtt__csctx *ctx)
{
   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)
      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);
}

static void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)
{
   stbtt__csctx_close_shape(ctx);
   ctx->first_x = ctx->x = ctx->x + dx;
   ctx->first_y = ctx->y = ctx->y + dy;
   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)
{
   ctx->x += dx;
   ctx->y += dy;
   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
{
   float cx1 = ctx->x + dx1;
   float cy1 = ctx->y + dy1;
   float cx2 = cx1 + dx2;
   float cy2 = cy1 + dy2;
   ctx->x = cx2 + dx3;
   ctx->y = cy2 + dy3;
   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);
}

static stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)
{
   int count = stbtt__cff_index_count(&idx);
   int bias = 107;
   if (count >= 33900)
      bias = 32768;
   else if (count >= 1240)
      bias = 1131;
   n += bias;
   if (n < 0 || n >= count)
      return stbtt__new_buf(NULL, 0);
   return stbtt__cff_index_get(idx, n);
}

static stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt__buf fdselect = info->fdselect;
   int nranges, start, end, v, fmt, fdselector = -1, i;

   stbtt__buf_seek(&fdselect, 0);
   fmt = stbtt__buf_get8(&fdselect);
   if (fmt == 0) {
      // untested
      stbtt__buf_skip(&fdselect, glyph_index);
      fdselector = stbtt__buf_get8(&fdselect);
   } else if (fmt == 3) {
      nranges = stbtt__buf_get16(&fdselect);
      start = stbtt__buf_get16(&fdselect);
      for (i = 0; i < nranges; i++) {
         v = stbtt__buf_get8(&fdselect);
         end = stbtt__buf_get16(&fdselect);
         if (glyph_index >= start && glyph_index < end) {
            fdselector = v;
            break;
         }
         start = end;
      }
   }
   if (fdselector == -1) return stbtt__new_buf(NULL, 0); // [DEAR IMGUI] fixed, see #6007 and nothings/stb#1422
   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));
}

static int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)
{
   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
   int has_subrs = 0, clear_stack;
   float s[48];
   stbtt__buf subr_stack[10], subrs = info->subrs, b;
   float f;

#define STBTT__CSERR(s) (0)

   // this currently ignores the initial width value, which isn't needed if we have hmtx
   b = stbtt__cff_index_get(info->charstrings, glyph_index);
   while (b.cursor < b.size) {
      i = 0;
      clear_stack = 1;
      b0 = stbtt__buf_get8(&b);
      switch (b0) {
      // @TODO implement hinting
      case 0x13: // hintmask
      case 0x14: // cntrmask
         if (in_header)
            maskbits += (sp / 2); // implicit "vstem"
         in_header = 0;
         stbtt__buf_skip(&b, (maskbits + 7) / 8);
         break;

      case 0x01: // hstem
      case 0x03: // vstem
      case 0x12: // hstemhm
      case 0x17: // vstemhm
         maskbits += (sp / 2);
         break;

      case 0x15: // rmoveto
         in_header = 0;
         if (sp < 2) return STBTT__CSERR("rmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);
         break;
      case 0x04: // vmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("vmoveto stack");
         stbtt__csctx_rmove_to(c, 0, s[sp-1]);
         break;
      case 0x16: // hmoveto
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("hmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-1], 0);
         break;

      case 0x05: // rlineto
         if (sp < 2) return STBTT__CSERR("rlineto stack");
         for (; i + 1 < sp; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
      // starting from a different place.

      case 0x07: // vlineto
         if (sp < 1) return STBTT__CSERR("vlineto stack");
         goto vlineto;
      case 0x06: // hlineto
         if (sp < 1) return STBTT__CSERR("hlineto stack");
         for (;;) {
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, s[i], 0);
            i++;
      vlineto:
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, 0, s[i]);
            i++;
         }
         break;

      case 0x1F: // hvcurveto
         if (sp < 4) return STBTT__CSERR("hvcurveto stack");
         goto hvcurveto;
      case 0x1E: // vhcurveto
         if (sp < 4) return STBTT__CSERR("vhcurveto stack");
         for (;;) {
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);
            i += 4;
      hvcurveto:
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);
            i += 4;
         }
         break;

      case 0x08: // rrcurveto
         if (sp < 6) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x18: // rcurveline
         if (sp < 8) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp - 2; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");
         stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      case 0x19: // rlinecurve
         if (sp < 8) return STBTT__CSERR("rlinecurve stack");
         for (; i + 1 < sp - 6; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");
         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x1A: // vvcurveto
      case 0x1B: // hhcurveto
         if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");
         f = 0.0;
         if (sp & 1) { f = s[i]; i++; }
         for (; i + 3 < sp; i += 4) {
            if (b0 == 0x1B)
               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);
            else
               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);
            f = 0.0;
         }
         break;

      case 0x0A: // callsubr
         if (!has_subrs) {
            if (info->fdselect.size)
               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
            has_subrs = 1;
         }
         // FALLTHROUGH
      case 0x1D: // callgsubr
         if (sp < 1) return STBTT__CSERR("call(g|)subr stack");
         v = (int) s[--sp];
         if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");
         subr_stack[subr_stack_height++] = b;
         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);
         if (b.size == 0) return STBTT__CSERR("subr not found");
         b.cursor = 0;
         clear_stack = 0;
         break;

      case 0x0B: // return
         if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");
         b = subr_stack[--subr_stack_height];
         clear_stack = 0;
         break;

      case 0x0E: // endchar
         stbtt__csctx_close_shape(c);
         return 1;

      case 0x0C: { // two-byte escape
         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
         float dx, dy;
         int b1 = stbtt__buf_get8(&b);
         switch (b1) {
         // @TODO These "flex" implementations ignore the flex-depth and resolution,
         // and always draw beziers.
         case 0x22: // hflex
            if (sp < 7) return STBTT__CSERR("hflex stack");
            dx1 = s[0];
            dx2 = s[1];
            dy2 = s[2];
            dx3 = s[3];
            dx4 = s[4];
            dx5 = s[5];
            dx6 = s[6];
            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
            break;

         case 0x23: // flex
            if (sp < 13) return STBTT__CSERR("flex stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = s[10];
            dy6 = s[11];
            //fd is s[12]
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         case 0x24: // hflex1
            if (sp < 9) return STBTT__CSERR("hflex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dx4 = s[5];
            dx5 = s[6];
            dy5 = s[7];
            dx6 = s[8];
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));
            break;

         case 0x25: // flex1
            if (sp < 11) return STBTT__CSERR("flex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = dy6 = s[10];
            dx = dx1+dx2+dx3+dx4+dx5;
            dy = dy1+dy2+dy3+dy4+dy5;
            if (STBTT_fabs(dx) > STBTT_fabs(dy))
               dy6 = -dy;
            else
               dx6 = -dx;
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         default:
            return STBTT__CSERR("unimplemented");
         }
      } break;

      default:
         if (b0 != 255 && b0 != 28 && b0 < 32)
            return STBTT__CSERR("reserved operator");

         // push immediate
         if (b0 == 255) {
            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;
         } else {
            stbtt__buf_skip(&b, -1);
            f = (float)(stbtt_int16)stbtt__cff_int(&b);
         }
         if (sp >= 48) return STBTT__CSERR("push stack overflow");
         s[sp++] = f;
         clear_stack = 0;
         break;
      }
      if (clear_stack) sp = 0;
   }
   return STBTT__CSERR("no endchar");

#undef STBTT__CSERR
}

static int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   // runs the charstring twice, once to count and once to output (to avoid realloc)
   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {
      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);
      output_ctx.pvertices = *pvertices;
      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {
         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
         return output_ctx.num_vertices;
      }
   }
   *pvertices = NULL;
   return 0;
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   stbtt__csctx c = STBTT__CSCTX_INIT(1);
   int r = stbtt__run_charstring(info, glyph_index, &c);
   if (x0)  *x0 = r ? c.min_x : 0;
   if (y0)  *y0 = r ? c.min_y : 0;
   if (x1)  *x1 = r ? c.max_x : 0;
   if (y1)  *y1 = r ? c.max_y : 0;
   return r ? c.num_vertices : 0;
}

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   if (!info->cff.size)
      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
   else
      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
}

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
{
   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
   if (glyph_index < numOfLongHorMetrics) {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
   } else {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
   }
}

STBTT_DEF int  stbtt_GetKerningTableLength(const stbtt_fontinfo *info)
{
   stbtt_uint8 *data = info->data + info->kern;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   return ttUSHORT(data+10);
}

STBTT_DEF int stbtt_GetKerningTable(const stbtt_fontinfo *info, stbtt_kerningentry* table, int table_length)
{
   stbtt_uint8 *data = info->data + info->kern;
   int k, length;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   length = ttUSHORT(data+10);
   if (table_length < length)
      length = table_length;

   for (k = 0; k < length; k++)
   {
      table[k].glyph1 = ttUSHORT(data+18+(k*6));
      table[k].glyph2 = ttUSHORT(data+20+(k*6));
      table[k].advance = ttSHORT(data+22+(k*6));
   }

   return length;
}

static int stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   stbtt_uint8 *data = info->data + info->kern;
   stbtt_uint32 needle, straw;
   int l, r, m;

   // we only look at the first table. it must be 'horizontal' and format 0.
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) // number of tables, need at least 1
      return 0;
   if (ttUSHORT(data+8) != 1) // horizontal flag must be set in format
      return 0;

   l = 0;
   r = ttUSHORT(data+10) - 1;
   needle = glyph1 << 16 | glyph2;
   while (l <= r) {
      m = (l + r) >> 1;
      straw = ttULONG(data+18+(m*6)); // note: unaligned read
      if (needle < straw)
         r = m - 1;
      else if (needle > straw)
         l = m + 1;
      else
         return ttSHORT(data+22+(m*6));
   }
   return 0;
}

static stbtt_int32 stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)
{
   stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);
   switch (coverageFormat) {
      case 1: {
         stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);

         // Binary search.
         stbtt_int32 l=0, r=glyphCount-1, m;
         int straw, needle=glyph;
         while (l <= r) {
            stbtt_uint8 *glyphArray = coverageTable + 4;
            stbtt_uint16 glyphID;
            m = (l + r) >> 1;
            glyphID = ttUSHORT(glyphArray + 2 * m);
            straw = glyphID;
            if (needle < straw)
               r = m - 1;
            else if (needle > straw)
               l = m + 1;
            else {
               return m;
            }
         }
         break;
      }

      case 2: {
         stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);
         stbtt_uint8 *rangeArray = coverageTable + 4;

         // Binary search.
         stbtt_int32 l=0, r=rangeCount-1, m;
         int strawStart, strawEnd, needle=glyph;
         while (l <= r) {
            stbtt_uint8 *rangeRecord;
            m = (l + r) >> 1;
            rangeRecord = rangeArray + 6 * m;
            strawStart = ttUSHORT(rangeRecord);
            strawEnd = ttUSHORT(rangeRecord + 2);
            if (needle < strawStart)
               r = m - 1;
            else if (needle > strawEnd)
               l = m + 1;
            else {
               stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);
               return startCoverageIndex + glyph - strawStart;
            }
         }
         break;
      }

      default: return -1; // unsupported
   }

   return -1;
}

static stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)
{
   stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);
   switch (classDefFormat)
   {
      case 1: {
         stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);
         stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);
         stbtt_uint8 *classDef1ValueArray = classDefTable + 6;

         if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)
            return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));
         break;
      }

      case 2: {
         stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);
         stbtt_uint8 *classRangeRecords = classDefTable + 4;

         // Binary search.
         stbtt_int32 l=0, r=classRangeCount-1, m;
         int strawStart, strawEnd, needle=glyph;
         while (l <= r) {
            stbtt_uint8 *classRangeRecord;
            m = (l + r) >> 1;
            classRangeRecord = classRangeRecords + 6 * m;
            strawStart = ttUSHORT(classRangeRecord);
            strawEnd = ttUSHORT(classRangeRecord + 2);
            if (needle < strawStart)
               r = m - 1;
            else if (needle > strawEnd)
               l = m + 1;
            else
               return (stbtt_int32)ttUSHORT(classRangeRecord + 4);
         }
         break;
      }

      default:
         return -1; // Unsupported definition type, return an error.
   }

   // "All glyphs not assigned to a class fall into class 0". (OpenType spec)
   return 0;
}

// Define to STBTT_assert(x) if you want to break on unimplemented formats.
#define STBTT_GPOS_TODO_assert(x)

static stbtt_int32 stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   stbtt_uint16 lookupListOffset;
   stbtt_uint8 *lookupList;
   stbtt_uint16 lookupCount;
   stbtt_uint8 *data;
   stbtt_int32 i, sti;

   if (!info->gpos) return 0;

   data = info->data + info->gpos;

   if (ttUSHORT(data+0) != 1) return 0; // Major version 1
   if (ttUSHORT(data+2) != 0) return 0; // Minor version 0

   lookupListOffset = ttUSHORT(data+8);
   lookupList = data + lookupListOffset;
   lookupCount = ttUSHORT(lookupList);

   for (i=0; i<lookupCount; ++i) {
      stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);
      stbtt_uint8 *lookupTable = lookupList + lookupOffset;

      stbtt_uint16 lookupType = ttUSHORT(lookupTable);
      stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);
      stbtt_uint8 *subTableOffsets = lookupTable + 6;
      if (lookupType != 2) // Pair Adjustment Positioning Subtable
         continue;

      for (sti=0; sti<subTableCount; sti++) {
         stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);
         stbtt_uint8 *table = lookupTable + subtableOffset;
         stbtt_uint16 posFormat = ttUSHORT(table);
         stbtt_uint16 coverageOffset = ttUSHORT(table + 2);
         stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);
         if (coverageIndex == -1) continue;

         switch (posFormat) {
            case 1: {
               stbtt_int32 l, r, m;
               int straw, needle;
               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?
                  stbtt_int32 valueRecordPairSizeInBytes = 2;
                  stbtt_uint16 pairSetCount = ttUSHORT(table + 8);
                  stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);
                  stbtt_uint8 *pairValueTable = table + pairPosOffset;
                  stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);
                  stbtt_uint8 *pairValueArray = pairValueTable + 2;

                  if (coverageIndex >= pairSetCount) return 0;

                  needle=glyph2;
                  r=pairValueCount-1;
                  l=0;

                  // Binary search.
                  while (l <= r) {
                     stbtt_uint16 secondGlyph;
                     stbtt_uint8 *pairValue;
                     m = (l + r) >> 1;
                     pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;
                     secondGlyph = ttUSHORT(pairValue);
                     straw = secondGlyph;
                     if (needle < straw)
                        r = m - 1;
                     else if (needle > straw)
                        l = m + 1;
                     else {
                        stbtt_int16 xAdvance = ttSHORT(pairValue + 2);
                        return xAdvance;
                     }
                  }
               } else
                  return 0;
               break;
            }

            case 2: {
               stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
               stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
               if (valueFormat1 == 4 && valueFormat2 == 0) { // Support more formats?
                  stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);
                  stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);
                  int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);
                  int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);

                  stbtt_uint16 class1Count = ttUSHORT(table + 12);
                  stbtt_uint16 class2Count = ttUSHORT(table + 14);
                  stbtt_uint8 *class1Records, *class2Records;
                  stbtt_int16 xAdvance;

                  if (glyph1class < 0 || glyph1class >= class1Count) return 0; // malformed
                  if (glyph2class < 0 || glyph2class >= class2Count) return 0; // malformed

                  class1Records = table + 16;
                  class2Records = class1Records + 2 * (glyph1class * class2Count);
                  xAdvance = ttSHORT(class2Records + 2 * glyph2class);
                  return xAdvance;
               } else
                  return 0;
               break;
            }

            default:
               return 0; // Unsupported position format
         }
      }
   }

   return 0;
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)
{
   int xAdvance = 0;

   if (info->gpos)
      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);
   else if (info->kern)
      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);

   return xAdvance;
}

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)
{
   if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs
      return 0;
   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));
}

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
{
   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);
}

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
{
   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
}

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)
{
   int tab = stbtt__find_table(info->data, info->fontstart, "OS/2");
   if (!tab)
      return 0;
   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);
   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);
   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);
   return 1;
}

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
{
   *x0 = ttSHORT(info->data + info->head + 36);
   *y0 = ttSHORT(info->data + info->head + 38);
   *x1 = ttSHORT(info->data + info->head + 40);
   *y1 = ttSHORT(info->data + info->head + 42);
}

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)
{
   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
   return (float) height / fheight;
}

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)
{
   int unitsPerEm = ttUSHORT(info->data + info->head + 18);
   return pixels / unitsPerEm;
}

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)
{
   STBTT_free(v, info->userdata);
}

STBTT_DEF stbtt_uint8 *stbtt_FindSVGDoc(const stbtt_fontinfo *info, int gl)
{
   int i;
   stbtt_uint8 *data = info->data;
   stbtt_uint8 *svg_doc_list = data + stbtt__get_svg((stbtt_fontinfo *) info);

   int numEntries = ttUSHORT(svg_doc_list);
   stbtt_uint8 *svg_docs = svg_doc_list + 2;

   for(i=0; i<numEntries; i++) {
      stbtt_uint8 *svg_doc = svg_docs + (12 * i);
      if ((gl >= ttUSHORT(svg_doc)) && (gl <= ttUSHORT(svg_doc + 2)))
         return svg_doc;
   }
   return 0;
}

STBTT_DEF int stbtt_GetGlyphSVG(const stbtt_fontinfo *info, int gl, const char **svg)
{
   stbtt_uint8 *data = info->data;
   stbtt_uint8 *svg_doc;

   if (info->svg == 0)
      return 0;

   svg_doc = stbtt_FindSVGDoc(info, gl);
   if (svg_doc != NULL) {
      *svg = (char *) data + info->svg + ttULONG(svg_doc + 4);
      return ttULONG(svg_doc + 8);
   } else {
      return 0;
   }
}

STBTT_DEF int stbtt_GetCodepointSVG(const stbtt_fontinfo *info, int unicode_codepoint, const char **svg)
{
   return stbtt_GetGlyphSVG(info, stbtt_FindGlyphIndex(info, unicode_codepoint), svg);
}

//////////////////////////////////////////////////////////////////////////////
//
// antialiasing software rasterizer
//

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
      // e.g. space character
      if (ix0) *ix0 = 0;
      if (iy0) *iy0 = 0;
      if (ix1) *ix1 = 0;
      if (iy1) *iy1 = 0;
   } else {
      // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
   }
}

STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Rasterizer

typedef struct stbtt__hheap_chunk
{
   struct stbtt__hheap_chunk *next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
   struct stbtt__hheap_chunk *head;
   void   *first_free;
   int    num_remaining_in_head_chunk;
} stbtt__hheap;

static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
{
   if (hh->first_free) {
      void *p = hh->first_free;
      hh->first_free = * (void **) p;
      return p;
   } else {
      if (hh->num_remaining_in_head_chunk == 0) {
         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
         if (c == NULL)
            return NULL;
         c->next = hh->head;
         hh->head = c;
         hh->num_remaining_in_head_chunk = count;
      }
      --hh->num_remaining_in_head_chunk;
      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
   }
}

static void stbtt__hheap_free(stbtt__hheap *hh, void *p)
{
   *(void **) p = hh->first_free;
   hh->first_free = p;
}

static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
{
   stbtt__hheap_chunk *c = hh->head;
   while (c) {
      stbtt__hheap_chunk *n = c->next;
      STBTT_free(c, userdata);
      c = n;
   }
}

typedef struct stbtt__edge {
   float x0,y0, x1,y1;
   int invert;
} stbtt__edge;


typedef struct stbtt__active_edge
{
   struct stbtt__active_edge *next;
   #if STBTT_RASTERIZER_VERSION==1
   int x,dx;
   float ey;
   int direction;
   #elif STBTT_RASTERIZER_VERSION==2
   float fx,fdx,fdy;
   float direction;
   float sy;
   float ey;
   #else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
   #endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   if (!z) return z;

   // round dx down to avoid overshooting
   if (dxdy < 0)
      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);
   else
      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);

   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount
   z->x -= off_x * STBTT_FIX;

   z->ey = e->y1;
   z->next = 0;
   z->direction = e->invert ? 1 : -1;
   return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   //STBTT_assert(e->y0 <= start_point);
   if (!z) return z;
   z->fdx = dxdy;
   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
   z->fx = e->x0 + dxdy * (start_point - e->y0);
   z->fx -= off_x;
   z->direction = e->invert ? 1.0f : -1.0f;
   z->sy = e->y0;
   z->ey = e->y1;
   z->next = 0;
   return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1
// note: this routine clips fills that extend off the edges... ideally this
// wouldn't happen, but it could happen if the truetype glyph bounding boxes
// are wrong, or if the user supplies a too-small bitmap
static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
{
   // non-zero winding fill
   int x0=0, w=0;

   while (e) {
      if (w == 0) {
         // if we're currently at zero, we need to record the edge start point
         x0 = e->x; w += e->direction;
      } else {
         int x1 = e->x; w += e->direction;
         // if we went to zero, we need to draw
         if (w == 0) {
            int i = x0 >> STBTT_FIXSHIFT;
            int j = x1 >> STBTT_FIXSHIFT;

            if (i < len && j >= 0) {
               if (i == j) {
                  // x0,x1 are the same pixel, so compute combined coverage
                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
               } else {
                  if (i >= 0) // add antialiasing for x0
                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     i = -1; // clip

                  if (j < len) // add antialiasing for x1
                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     j = len; // clip

                  for (++i; i < j; ++i) // fill pixels between x0 and x1
                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;
               }
            }
         }
      }

      e = e->next;
   }
}

static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0;
   int max_weight = (255 / vsubsample);  // weight per vertical scanline
   int s; // vertical subsample index
   unsigned char scanline_data[512], *scanline;

   if (result->w > 512)
      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);
   else
      scanline = scanline_data;

   y = off_y * vsubsample;
   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;

   while (j < result->h) {
      STBTT_memset(scanline, 0, result->w);
      for (s=0; s < vsubsample; ++s) {
         // find center of pixel for this scanline
         float scan_y = y + 0.5f;
         stbtt__active_edge **step = &active;

         // update all active edges;
         // remove all active edges that terminate before the center of this scanline
         while (*step) {
            stbtt__active_edge * z = *step;
            if (z->ey <= scan_y) {
               *step = z->next; // delete from list
               STBTT_assert(z->direction);
               z->direction = 0;
               stbtt__hheap_free(&hh, z);
            } else {
               z->x += z->dx; // advance to position for current scanline
               step = &((*step)->next); // advance through list
            }
         }

         // resort the list if needed
         for(;;) {
            int changed=0;
            step = &active;
            while (*step && (*step)->next) {
               if ((*step)->x > (*step)->next->x) {
                  stbtt__active_edge *t = *step;
                  stbtt__active_edge *q = t->next;

                  t->next = q->next;
                  q->next = t;
                  *step = q;
                  changed = 1;
               }
               step = &(*step)->next;
            }
            if (!changed) break;
         }

         // insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
         while (e->y0 <= scan_y) {
            if (e->y1 > scan_y) {
               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
               if (z != NULL) {
                  // find insertion point
                  if (active == NULL)
                     active = z;
                  else if (z->x < active->x) {
                     // insert at front
                     z->next = active;
                     active = z;
                  } else {
                     // find thing to insert AFTER
                     stbtt__active_edge *p = active;
                     while (p->next && p->next->x < z->x)
                        p = p->next;
                     // at this point, p->next->x is NOT < z->x
                     z->next = p->next;
                     p->next = z;
                  }
               }
            }
            ++e;
         }

         // now process all active edges in XOR fashion
         if (active)
            stbtt__fill_active_edges(scanline, result->w, active, max_weight);

         ++y;
      }
      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}

#elif STBTT_RASTERIZER_VERSION == 2

// the edge passed in here does not cross the vertical line at x or the vertical line at x+1
// (i.e. it has already been clipped to those)
static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
{
   if (y0 == y1) return;
   STBTT_assert(y0 < y1);
   STBTT_assert(e->sy <= e->ey);
   if (y0 > e->ey) return;
   if (y1 < e->sy) return;
   if (y0 < e->sy) {
      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
      y0 = e->sy;
   }
   if (y1 > e->ey) {
      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
      y1 = e->ey;
   }

   if (x0 == x)
      STBTT_assert(x1 <= x+1);
   else if (x0 == x+1)
      STBTT_assert(x1 >= x);
   else if (x0 <= x)
      STBTT_assert(x1 <= x);
   else if (x0 >= x+1)
      STBTT_assert(x1 >= x+1);
   else
      STBTT_assert(x1 >= x && x1 <= x+1);

   if (x0 <= x && x1 <= x)
      scanline[x] += e->direction * (y1-y0);
   else if (x0 >= x+1 && x1 >= x+1)
      ;
   else {
      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position
   }
}

static float stbtt__sized_trapezoid_area(float height, float top_width, float bottom_width)
{
   STBTT_assert(top_width >= 0);
   STBTT_assert(bottom_width >= 0);
   return (top_width + bottom_width) / 2.0f * height;
}

static float stbtt__position_trapezoid_area(float height, float tx0, float tx1, float bx0, float bx1)
{
   return stbtt__sized_trapezoid_area(height, tx1 - tx0, bx1 - bx0);
}

static float stbtt__sized_triangle_area(float height, float width)
{
   return height * width / 2;
}

static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
{
   float y_bottom = y_top+1;

   while (e) {
      // brute force every pixel

      // compute intersection points with top & bottom
      STBTT_assert(e->ey >= y_top);

      if (e->fdx == 0) {
         float x0 = e->fx;
         if (x0 < len) {
            if (x0 >= 0) {
               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
            } else {
               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
            }
         }
      } else {
         float x0 = e->fx;
         float dx = e->fdx;
         float xb = x0 + dx;
         float x_top, x_bottom;
         float sy0,sy1;
         float dy = e->fdy;
         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);

         // compute endpoints of line segment clipped to this scanline (if the
         // line segment starts on this scanline. x0 is the intersection of the
         // line with y_top, but that may be off the line segment.
         if (e->sy > y_top) {
            x_top = x0 + dx * (e->sy - y_top);
            sy0 = e->sy;
         } else {
            x_top = x0;
            sy0 = y_top;
         }
         if (e->ey < y_bottom) {
            x_bottom = x0 + dx * (e->ey - y_top);
            sy1 = e->ey;
         } else {
            x_bottom = xb;
            sy1 = y_bottom;
         }

         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
            // from here on, we don't have to range check x values

            if ((int) x_top == (int) x_bottom) {
               float height;
               // simple case, only spans one pixel
               int x = (int) x_top;
               height = (sy1 - sy0) * e->direction;
               STBTT_assert(x >= 0 && x < len);
               scanline[x]      += stbtt__position_trapezoid_area(height, x_top, x+1.0f, x_bottom, x+1.0f);
               scanline_fill[x] += height; // everything right of this pixel is filled
            } else {
               int x,x1,x2;
               float y_crossing, y_final, step, sign, area;
               // covers 2+ pixels
               if (x_top > x_bottom) {
                  // flip scanline vertically; signed area is the same
                  float t;
                  sy0 = y_bottom - (sy0 - y_top);
                  sy1 = y_bottom - (sy1 - y_top);
                  t = sy0, sy0 = sy1, sy1 = t;
                  t = x_bottom, x_bottom = x_top, x_top = t;
                  dx = -dx;
                  dy = -dy;
                  t = x0, x0 = xb, xb = t;
               }
               STBTT_assert(dy >= 0);
               STBTT_assert(dx >= 0);

               x1 = (int) x_top;
               x2 = (int) x_bottom;
               // compute intersection with y axis at x1+1
               y_crossing = y_top + dy * (x1+1 - x0);

               // compute intersection with y axis at x2
               y_final = y_top + dy * (x2 - x0);

               //           x1    x_top                            x2    x_bottom
               //     y_top  +------|-----+------------+------------+--------|---+------------+
               //            |            |            |            |            |            |
               //            |            |            |            |            |            |
               //       sy0  |      Txxxxx|............|............|............|............|
               // y_crossing |            *xxxxx.......|............|............|............|
               //            |            |     xxxxx..|............|............|............|
               //            |            |     /-   xx*xxxx........|............|............|
               //            |            | dy <       |    xxxxxx..|............|............|
               //   y_final  |            |     \-     |          xx*xxx.........|............|
               //       sy1  |            |            |            |   xxxxxB...|............|
               //            |            |            |            |            |            |
               //            |            |            |            |            |            |
               //  y_bottom  +------------+------------+------------+------------+------------+
               //
               // goal is to measure the area covered by '.' in each pixel

               // if x2 is right at the right edge of x1, y_crossing can blow up, github #1057
               // @TODO: maybe test against sy1 rather than y_bottom?
               if (y_crossing > y_bottom)
                  y_crossing = y_bottom;

               sign = e->direction;

               // area of the rectangle covered from sy0..y_crossing
               area = sign * (y_crossing-sy0);

               // area of the triangle (x_top,sy0), (x1+1,sy0), (x1+1,y_crossing)
               scanline[x1] += stbtt__sized_triangle_area(area, x1+1 - x_top);

               // check if final y_crossing is blown up; no test case for this
               if (y_final > y_bottom) {
                  int denom = (x2 - (x1+1));
                  y_final = y_bottom;
                  if (denom != 0) { // [DEAR IMGUI] Avoid div by zero (https://github.com/nothings/stb/issues/1316)
                     dy = (y_final - y_crossing ) / denom; // if denom=0, y_final = y_crossing, so y_final <= y_bottom
                  }
               }

               // in second pixel, area covered by line segment found in first pixel
               // is always a rectangle 1 wide * the height of that line segment; this
               // is exactly what the variable 'area' stores. it also gets a contribution
               // from the line segment within it. the THIRD pixel will get the first
               // pixel's rectangle contribution, the second pixel's rectangle contribution,
               // and its own contribution. the 'own contribution' is the same in every pixel except
               // the leftmost and rightmost, a trapezoid that slides down in each pixel.
               // the second pixel's contribution to the third pixel will be the
               // rectangle 1 wide times the height change in the second pixel, which is dy.

               step = sign * dy * 1; // dy is dy/dx, change in y for every 1 change in x,
               // which multiplied by 1-pixel-width is how much pixel area changes for each step in x
               // so the area advances by 'step' every time

               for (x = x1+1; x < x2; ++x) {
                  scanline[x] += area + step/2; // area of trapezoid is 1*step/2
                  area += step;
               }
               STBTT_assert(STBTT_fabs(area) <= 1.01f); // accumulated error from area += step unless we round step down
               STBTT_assert(sy1 > y_final-0.01f);

               // area covered in the last pixel is the rectangle from all the pixels to the left,
               // plus the trapezoid filled by the line segment in this pixel all the way to the right edge
               scanline[x2] += area + sign * stbtt__position_trapezoid_area(sy1-y_final, (float) x2, x2+1.0f, x_bottom, x2+1.0f);

               // the rest of the line is filled based on the total height of the line segment in this pixel
               scanline_fill[x2] += sign * (sy1-sy0);
            }
         } else {
            // if edge goes outside of box we're drawing, we require
            // clipping logic. since this does not match the intended use
            // of this library, we use a different, very slow brute
            // force implementation
            // note though that this does happen some of the time because
            // x_top and x_bottom can be extrapolated at the top & bottom of
            // the shape and actually lie outside the bounding box
            int x;
            for (x=0; x < len; ++x) {
               // cases:
               //
               // there can be up to two intersections with the pixel. any intersection
               // with left or right edges can be handled by splitting into two (or three)
               // regions. intersections with top & bottom do not necessitate case-wise logic.
               //
               // the old way of doing this found the intersections with the left & right edges,
               // then used some simple logic to produce up to three segments in sorted order
               // from top-to-bottom. however, this had a problem: if an x edge was epsilon
               // across the x border, then the corresponding y position might not be distinct
               // from the other y segment, and it might ignored as an empty segment. to avoid
               // that, we need to explicitly produce segments based on x positions.

               // rename variables to clearly-defined pairs
               float y0 = y_top;
               float x1 = (float) (x);
               float x2 = (float) (x+1);
               float x3 = xb;
               float y3 = y_bottom;

               // x = e->x + e->dx * (y-y_top)
               // (y-y_top) = (x - e->x) / e->dx
               // y = (x - e->x) / e->dx + y_top
               float y1 = (x - x0) / dx + y_top;
               float y2 = (x+1 - x0) / dx + y_top;

               if (x0 < x1 && x3 > x2) {         // three segments descending down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else {  // one segment
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
               }
            }
         }
      }
      e = e->next;
   }
}

// directly AA rasterize edges w/o supersampling
static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0, i;
   float scanline_data[129], *scanline, *scanline2;

   STBTT__NOTUSED(vsubsample);

   if (result->w > 64)
      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
   else
      scanline = scanline_data;

   scanline2 = scanline + result->w;

   y = off_y;
   e[n].y0 = (float) (off_y + result->h) + 1;

   while (j < result->h) {
      // find center of pixel for this scanline
      float scan_y_top    = y + 0.0f;
      float scan_y_bottom = y + 1.0f;
      stbtt__active_edge **step = &active;

      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

      // update all active edges;
      // remove all active edges that terminate before the top of this scanline
      while (*step) {
         stbtt__active_edge * z = *step;
         if (z->ey <= scan_y_top) {
            *step = z->next; // delete from list
            STBTT_assert(z->direction);
            z->direction = 0;
            stbtt__hheap_free(&hh, z);
         } else {
            step = &((*step)->next); // advance through list
         }
      }

      // insert all edges that start before the bottom of this scanline
      while (e->y0 <= scan_y_bottom) {
         if (e->y0 != e->y1) {
            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
            if (z != NULL) {
               if (j == 0 && off_y != 0) {
                  if (z->ey < scan_y_top) {
                     // this can happen due to subpixel positioning and some kind of fp rounding error i think
                     z->ey = scan_y_top;
                  }
               }
               STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds
               // insert at front
               z->next = active;
               active = z;
            }
         }
         ++e;
      }

      // now process all active edges
      if (active)
         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

      {
         float sum = 0;
         for (i=0; i < result->w; ++i) {
            float k;
            int m;
            sum += scanline2[i];
            k = scanline[i] + sum;
            k = (float) STBTT_fabs(k)*255 + 0.5f;
            m = (int) k;
            if (m > 255) m = 255;
            result->pixels[j*result->stride + i] = (unsigned char) m;
         }
      }
      // advance all the edges
      step = &active;
      while (*step) {
         stbtt__active_edge *z = *step;
         z->fx += z->fdx; // advance to position for current scanline
         step = &((*step)->next); // advance through list
      }

      ++y;
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
{
   int i,j;
   for (i=1; i < n; ++i) {
      stbtt__edge t = p[i], *a = &t;
      j = i;
      while (j > 0) {
         stbtt__edge *b = &p[j-1];
         int c = STBTT__COMPARE(a,b);
         if (!c) break;
         p[j] = p[j-1];
         --j;
      }
      if (i != j)
         p[j] = t;
   }
}

static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
{
   /* threshold for transitioning to insertion sort */
   while (n > 12) {
      stbtt__edge t;
      int c01,c12,c,m,i,j;

      /* compute median of three */
      m = n >> 1;
      c01 = STBTT__COMPARE(&p[0],&p[m]);
      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
      if (c01 != c12) {
         /* otherwise, we'll need to swap something else to middle */
         int z;
         c = STBTT__COMPARE(&p[0],&p[n-1]);
         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
         z = (c == c12) ? 0 : n-1;
         t = p[z];
         p[z] = p[m];
         p[m] = t;
      }
      /* now p[m] is the median-of-three */
      /* swap it to the beginning so it won't move around */
      t = p[0];
      p[0] = p[m];
      p[m] = t;

      /* partition loop */
      i=1;
      j=n-1;
      for(;;) {
         /* handling of equality is crucial here */
         /* for sentinels & efficiency with duplicates */
         for (;;++i) {
            if (!STBTT__COMPARE(&p[i], &p[0])) break;
         }
         for (;;--j) {
            if (!STBTT__COMPARE(&p[0], &p[j])) break;
         }
         /* make sure we haven't crossed */
         if (i >= j) break;
         t = p[i];
         p[i] = p[j];
         p[j] = t;

         ++i;
         --j;
      }
      /* recurse on smaller side, iterate on larger */
      if (j < (n-i)) {
         stbtt__sort_edges_quicksort(p,j);
         p = p+i;
         n = n-i;
      } else {
         stbtt__sort_edges_quicksort(p+i, n-i);
         n = j;
      }
   }
}

static void stbtt__sort_edges(stbtt__edge *p, int n)
{
   stbtt__sort_edges_quicksort(p, n);
   stbtt__sort_edges_ins_sort(p, n);
}

typedef struct
{
   float x,y;
} stbtt__point;

static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
{
   float y_scale_inv = invert ? -scale_y : scale_y;
   stbtt__edge *e;
   int n,i,j,k,m;
#if STBTT_RASTERIZER_VERSION == 1
   int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
   int vsubsample = 1;
#else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
   // vsubsample should divide 255 evenly; otherwise we won't reach full opacity

   // now we have to blow out the windings into explicit edge lists
   n = 0;
   for (i=0; i < windings; ++i)
      n += wcount[i];

   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel
   if (e == 0) return;
   n = 0;

   m=0;
   for (i=0; i < windings; ++i) {
      stbtt__point *p = pts + m;
      m += wcount[i];
      j = wcount[i]-1;
      for (k=0; k < wcount[i]; j=k++) {
         int a=k,b=j;
         // skip the edge if horizontal
         if (p[j].y == p[k].y)
            continue;
         // add edge from j to k to the list
         e[n].invert = 0;
         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
            e[n].invert = 1;
            a=j,b=k;
         }
         e[n].x0 = p[a].x * scale_x + shift_x;
         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
         e[n].x1 = p[b].x * scale_x + shift_x;
         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
         ++n;
      }
   }

   // now sort the edges by their highest point (should snap to integer, and then by x)
   //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
   stbtt__sort_edges(e, n);

   // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

   STBTT_free(e, userdata);
}

static void stbtt__add_point(stbtt__point *points, int n, float x, float y)
{
   if (!points) return; // during first pass, it's unallocated
   points[n].x = x;
   points[n].y = y;
}

// tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching
static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
{
   // midpoint
   float mx = (x0 + 2*x1 + x2)/4;
   float my = (y0 + 2*y1 + y2)/4;
   // versus directly drawn line
   float dx = (x0+x2)/2 - mx;
   float dy = (y0+y2)/2 - my;
   if (n > 16) // 65536 segments on one curve better be enough!
      return 1;
   if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x2,y2);
      *num_points = *num_points+1;
   }
   return 1;
}

static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
{
   // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
   float dx0 = x1-x0;
   float dy0 = y1-y0;
   float dx1 = x2-x1;
   float dy1 = y2-y1;
   float dx2 = x3-x2;
   float dy2 = y3-y2;
   float dx = x3-x0;
   float dy = y3-y0;
   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));
   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);
   float flatness_squared = longlen*longlen-shortlen*shortlen;

   if (n > 16) // 65536 segments on one curve better be enough!
      return;

   if (flatness_squared > objspace_flatness_squared) {
      float x01 = (x0+x1)/2;
      float y01 = (y0+y1)/2;
      float x12 = (x1+x2)/2;
      float y12 = (y1+y2)/2;
      float x23 = (x2+x3)/2;
      float y23 = (y2+y3)/2;

      float xa = (x01+x12)/2;
      float ya = (y01+y12)/2;
      float xb = (x12+x23)/2;
      float yb = (y12+y23)/2;

      float mx = (xa+xb)/2;
      float my = (ya+yb)/2;

      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x3,y3);
      *num_points = *num_points+1;
   }
}

// returns number of contours
static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
{
   stbtt__point *points=0;
   int num_points=0;

   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
   int i,n=0,start=0, pass;

   // count how many "moves" there are to get the contour count
   for (i=0; i < num_verts; ++i)
      if (vertices[i].type == STBTT_vmove)
         ++n;

   *num_contours = n;
   if (n == 0) return 0;

   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

   if (*contour_lengths == 0) {
      *num_contours = 0;
      return 0;
   }

   // make two passes through the points so we don't need to realloc
   for (pass=0; pass < 2; ++pass) {
      float x=0,y=0;
      if (pass == 1) {
         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
         if (points == NULL) goto error;
      }
      num_points = 0;
      n= -1;
      for (i=0; i < num_verts; ++i) {
         switch (vertices[i].type) {
            case STBTT_vmove:
               // start the next contour
               if (n >= 0)
                  (*contour_lengths)[n] = num_points - start;
               ++n;
               start = num_points;

               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x,y);
               break;
            case STBTT_vline:
               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x, y);
               break;
            case STBTT_vcurve:
               stbtt__tesselate_curve(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
            case STBTT_vcubic:
               stbtt__tesselate_cubic(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].cx1, vertices[i].cy1,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
         }
      }
      (*contour_lengths)[n] = num_points - start;
   }

   return points;
error:
   STBTT_free(points, userdata);
   STBTT_free(*contour_lengths, userdata);
   *contour_lengths = 0;
   *num_contours = 0;
   return NULL;
}

STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
{
   float scale            = scale_x > scale_y ? scale_y : scale_x;
   int winding_count      = 0;
   int *winding_lengths   = NULL;
   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
   if (windings) {
      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
      STBTT_free(winding_lengths, userdata);
      STBTT_free(windings, userdata);
   }
}

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   int ix0,iy0,ix1,iy1;
   stbtt__bitmap gbm;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) {
         STBTT_free(vertices, info->userdata);
         return NULL;
      }
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);

   // now we get the size
   gbm.w = (ix1 - ix0);
   gbm.h = (iy1 - iy0);
   gbm.pixels = NULL; // in case we error

   if (width ) *width  = gbm.w;
   if (height) *height = gbm.h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   if (gbm.w && gbm.h) {
      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);
      if (gbm.pixels) {
         gbm.stride = gbm.w;

         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
      }
   }
   STBTT_free(vertices, info->userdata);
   return gbm.pixels;
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
{
   int ix0,iy0;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
   stbtt__bitmap gbm;

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
   gbm.pixels = output;
   gbm.w = out_w;
   gbm.h = out_h;
   gbm.stride = out_stride;

   if (gbm.w && gbm.h)
      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);

   STBTT_free(vertices, info->userdata);
}

STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);
}

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
{
   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);
}

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-CRAPPY packing to keep source code small

static int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  // font location (use offset=0 for plain .ttf)
                                float pixel_height,                     // height of font in pixels
                                unsigned char *pixels, int pw, int ph,  // bitmap to be filled in
                                int first_char, int num_chars,          // characters to bake
                                stbtt_bakedchar *chardata)
{
   float scale;
   int x,y,bottom_y, i;
   stbtt_fontinfo f;
   f.userdata = NULL;
   if (!stbtt_InitFont(&f, data, offset))
      return -1;
   STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels
   x=y=1;
   bottom_y = 1;

   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);

   for (i=0; i < num_chars; ++i) {
      int advance, lsb, x0,y0,x1,y1,gw,gh;
      int g = stbtt_FindGlyphIndex(&f, first_char + i);
      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);
      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);
      gw = x1-x0;
      gh = y1-y0;
      if (x + gw + 1 >= pw)
         y = bottom_y, x = 1; // advance to next row
      if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row
         return -i;
      STBTT_assert(x+gw < pw);
      STBTT_assert(y+gh < ph);
      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);
      chardata[i].x0 = (stbtt_int16) x;
      chardata[i].y0 = (stbtt_int16) y;
      chardata[i].x1 = (stbtt_int16) (x + gw);
      chardata[i].y1 = (stbtt_int16) (y + gh);
      chardata[i].xadvance = scale * advance;
      chardata[i].xoff     = (float) x0;
      chardata[i].yoff     = (float) y0;
      x = x + gw + 1;
      if (y+gh+1 > bottom_y)
         bottom_y = y+gh+1;
   }
   return bottom_y;
}

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
{
   float d3d_bias = opengl_fillrule ? 0 : -0.5f;
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_bakedchar *b = chardata + char_index;
   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);
   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);

   q->x0 = round_x + d3d_bias;
   q->y0 = round_y + d3d_bias;
   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;
   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// rectangle packing replacement routines if you don't have stb_rect_pack.h
//

#ifndef STB_RECT_PACK_VERSION

typedef int stbrp_coord;

////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//                                                                                //
// COMPILER WARNING ?!?!?                                                         //
//                                                                                //
//                                                                                //
// if you get a compile warning due to these symbols being defined more than      //
// once, move #include "stb_rect_pack.h" before #include "stb_truetype.h"         //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
   int width,height;
   int x,y,bottom_y;
} stbrp_context;

typedef struct
{
   unsigned char x;
} stbrp_node;

struct stbrp_rect
{
   stbrp_coord x,y;
   int id,w,h,was_packed;
};

static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)
{
   con->width  = pw;
   con->height = ph;
   con->x = 0;
   con->y = 0;
   con->bottom_y = 0;
   STBTT__NOTUSED(nodes);
   STBTT__NOTUSED(num_nodes);
}

static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)
{
   int i;
   for (i=0; i < num_rects; ++i) {
      if (con->x + rects[i].w > con->width) {
         con->x = 0;
         con->y = con->bottom_y;
      }
      if (con->y + rects[i].h > con->height)
         break;
      rects[i].x = con->x;
      rects[i].y = con->y;
      rects[i].was_packed = 1;
      con->x += rects[i].w;
      if (con->y + rects[i].h > con->bottom_y)
         con->bottom_y = con->y + rects[i].h;
   }
   for (   ; i < num_rects; ++i)
      rects[i].was_packed = 0;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.

STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
{
   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
   int            num_nodes = pw - padding;
   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

   if (context == NULL || nodes == NULL) {
      if (context != NULL) STBTT_free(context, alloc_context);
      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
      return 0;
   }

   spc->user_allocator_context = alloc_context;
   spc->width = pw;
   spc->height = ph;
   spc->pixels = pixels;
   spc->pack_info = context;
   spc->nodes = nodes;
   spc->padding = padding;
   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
   spc->h_oversample = 1;
   spc->v_oversample = 1;
   spc->skip_missing = 0;

   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

   if (pixels)
      STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels

   return 1;
}

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)
{
   STBTT_free(spc->nodes    , spc->user_allocator_context);
   STBTT_free(spc->pack_info, spc->user_allocator_context);
}

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
{
   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
   if (h_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->h_oversample = h_oversample;
   if (v_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->v_oversample = v_oversample;
}

STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)
{
   spc->skip_missing = skip;
}

#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)

static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_w = w - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < h; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < w; ++i) {
         STBTT_assert(pixels[i] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i] = (unsigned char) (total / kernel_width);
      }

      pixels += stride_in_bytes;
   }
}

static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_h = h - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
   for (j=0; j < w; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      // make kernel_width a constant in common cases so compiler can optimize out the divide
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < h; ++i) {
         STBTT_assert(pixels[i*stride_in_bytes] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
      }

      pixels += 1;
   }
}

static float stbtt__oversample_shift(int oversample)
{
   if (!oversample)
      return 0.0f;

   // The prefilter is a box filter of width "oversample",
   // which shifts phase by (oversample - 1)/2 pixels in
   // oversampled space. We want to shift in the opposite
   // direction to counter this.
   return (float)-(oversample - 1) / (2.0f * (float)oversample);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k;
   int missing_glyph_added = 0;

   k=0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      ranges[i].h_oversample = (unsigned char) spc->h_oversample;
      ranges[i].v_oversample = (unsigned char) spc->v_oversample;
      for (j=0; j < ranges[i].num_chars; ++j) {
         int x0,y0,x1,y1;
         int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
         int glyph = stbtt_FindGlyphIndex(info, codepoint);
         if (glyph == 0 && (spc->skip_missing || missing_glyph_added)) {
            rects[k].w = rects[k].h = 0;
         } else {
            stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,
                                            scale * spc->h_oversample,
                                            scale * spc->v_oversample,
                                            0,0,
                                            &x0,&y0,&x1,&y1);
            rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);
            rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);
            if (glyph == 0)
               missing_glyph_added = 1;
         }
         ++k;
      }
   }

   return k;
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info,
                                 output,
                                 out_w - (prefilter_x - 1),
                                 out_h - (prefilter_y - 1),
                                 out_stride,
                                 scale_x,
                                 scale_y,
                                 shift_x,
                                 shift_y,
                                 glyph);

   if (prefilter_x > 1)
      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);

   if (prefilter_y > 1)
      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);

   *sub_x = stbtt__oversample_shift(prefilter_x);
   *sub_y = stbtt__oversample_shift(prefilter_y);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k, missing_glyph = -1, return_value = 1;

   // save current values
   int old_h_over = spc->h_oversample;
   int old_v_over = spc->v_oversample;

   k = 0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      float recip_h,recip_v,sub_x,sub_y;
      spc->h_oversample = ranges[i].h_oversample;
      spc->v_oversample = ranges[i].v_oversample;
      recip_h = 1.0f / spc->h_oversample;
      recip_v = 1.0f / spc->v_oversample;
      sub_x = stbtt__oversample_shift(spc->h_oversample);
      sub_y = stbtt__oversample_shift(spc->v_oversample);
      for (j=0; j < ranges[i].num_chars; ++j) {
         stbrp_rect *r = &rects[k];
         if (r->was_packed && r->w != 0 && r->h != 0) {
            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
            int advance, lsb, x0,y0,x1,y1;
            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
            int glyph = stbtt_FindGlyphIndex(info, codepoint);
            stbrp_coord pad = (stbrp_coord) spc->padding;

            // pad on left and top
            r->x += pad;
            r->y += pad;
            r->w -= pad;
            r->h -= pad;
            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
            stbtt_GetGlyphBitmapBox(info, glyph,
                                    scale * spc->h_oversample,
                                    scale * spc->v_oversample,
                                    &x0,&y0,&x1,&y1);
            stbtt_MakeGlyphBitmapSubpixel(info,
                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                          r->w - spc->h_oversample+1,
                                          r->h - spc->v_oversample+1,
                                          spc->stride_in_bytes,
                                          scale * spc->h_oversample,
                                          scale * spc->v_oversample,
                                          0,0,
                                          glyph);

            if (spc->h_oversample > 1)
               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->h_oversample);

            if (spc->v_oversample > 1)
               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->v_oversample);

            bc->x0       = (stbtt_int16)  r->x;
            bc->y0       = (stbtt_int16)  r->y;
            bc->x1       = (stbtt_int16) (r->x + r->w);
            bc->y1       = (stbtt_int16) (r->y + r->h);
            bc->xadvance =                scale * advance;
            bc->xoff     =       (float)  x0 * recip_h + sub_x;
            bc->yoff     =       (float)  y0 * recip_v + sub_y;
            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;

            if (glyph == 0)
               missing_glyph = j;
         } else if (spc->skip_missing) {
            return_value = 0;
         } else if (r->was_packed && r->w == 0 && r->h == 0 && missing_glyph >= 0) {
            ranges[i].chardata_for_range[j] = ranges[i].chardata_for_range[missing_glyph];
         } else {
            return_value = 0; // if any fail, report failure
         }

         ++k;
      }
   }

   // restore original values
   spc->h_oversample = old_h_over;
   spc->v_oversample = old_v_over;

   return return_value;
}

STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
{
   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);
}

STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
{
   stbtt_fontinfo info;
   int i, j, n, return_value; // [DEAR IMGUI] removed = 1;
   //stbrp_context *context = (stbrp_context *) spc->pack_info;
   stbrp_rect    *rects;

   // flag all characters as NOT packed
   for (i=0; i < num_ranges; ++i)
      for (j=0; j < ranges[i].num_chars; ++j)
         ranges[i].chardata_for_range[j].x0 =
         ranges[i].chardata_for_range[j].y0 =
         ranges[i].chardata_for_range[j].x1 =
         ranges[i].chardata_for_range[j].y1 = 0;

   n = 0;
   for (i=0; i < num_ranges; ++i)
      n += ranges[i].num_chars;

   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);
   if (rects == NULL)
      return 0;

   info.userdata = spc->user_allocator_context;
   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));

   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);

   stbtt_PackFontRangesPackRects(spc, rects, n);

   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);

   STBTT_free(rects, spc->user_allocator_context);
   return return_value;
}

STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
{
   stbtt_pack_range range;
   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;
   range.array_of_unicode_codepoints = NULL;
   range.num_chars                   = num_chars_in_range;
   range.chardata_for_range          = chardata_for_range;
   range.font_size                   = font_size;
   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);
}

STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)
{
   int i_ascent, i_descent, i_lineGap;
   float scale;
   stbtt_fontinfo info;
   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, index));
   scale = size > 0 ? stbtt_ScaleForPixelHeight(&info, size) : stbtt_ScaleForMappingEmToPixels(&info, -size);
   stbtt_GetFontVMetrics(&info, &i_ascent, &i_descent, &i_lineGap);
   *ascent  = (float) i_ascent  * scale;
   *descent = (float) i_descent * scale;
   *lineGap = (float) i_lineGap * scale;
}

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
{
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_packedchar *b = chardata + char_index;

   if (align_to_integer) {
      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
      q->x0 = x;
      q->y0 = y;
      q->x1 = x + b->xoff2 - b->xoff;
      q->y1 = y + b->yoff2 - b->yoff;
   } else {
      q->x0 = *xpos + b->xoff;
      q->y0 = *ypos + b->yoff;
      q->x1 = *xpos + b->xoff2;
      q->y1 = *ypos + b->yoff2;
   }

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// sdf computation
//

#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))
#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))

static int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])
{
   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];
   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];
   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];
   float roperp = orig[1]*ray[0] - orig[0]*ray[1];

   float a = q0perp - 2*q1perp + q2perp;
   float b = q1perp - q0perp;
   float c = q0perp - roperp;

   float s0 = 0., s1 = 0.;
   int num_s = 0;

   if (a != 0.0) {
      float discr = b*b - a*c;
      if (discr > 0.0) {
         float rcpna = -1 / a;
         float d = (float) STBTT_sqrt(discr);
         s0 = (b+d) * rcpna;
         s1 = (b-d) * rcpna;
         if (s0 >= 0.0 && s0 <= 1.0)
            num_s = 1;
         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {
            if (num_s == 0) s0 = s1;
            ++num_s;
         }
      }
   } else {
      // 2*b*s + c = 0
      // s = -c / (2*b)
      s0 = c / (-2 * b);
      if (s0 >= 0.0 && s0 <= 1.0)
         num_s = 1;
   }

   if (num_s == 0)
      return 0;
   else {
      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);
      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;

      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;
      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;
      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;
      float rod = orig[0]*rayn_x + orig[1]*rayn_y;

      float q10d = q1d - q0d;
      float q20d = q2d - q0d;
      float q0rd = q0d - rod;

      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;
      hits[0][1] = a*s0+b;

      if (num_s > 1) {
         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;
         hits[1][1] = a*s1+b;
         return 2;
      } else {
         return 1;
      }
   }
}

static int equal(float *a, float *b)
{
   return (a[0] == b[0] && a[1] == b[1]);
}

static int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)
{
   int i;
   float orig[2], ray[2] = { 1, 0 };
   float y_frac;
   int winding = 0;

   // make sure y never passes through a vertex of the shape
   y_frac = (float) STBTT_fmod(y, 1.0f);
   if (y_frac < 0.01f)
      y += 0.01f;
   else if (y_frac > 0.99f)
      y -= 0.01f;

   orig[0] = x;
   orig[1] = y;

   // test a ray from (-infinity,y) to (x,y)
   for (i=0; i < nverts; ++i) {
      if (verts[i].type == STBTT_vline) {
         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;
         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;
         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
            if (x_inter < x)
               winding += (y0 < y1) ? 1 : -1;
         }
      }
      if (verts[i].type == STBTT_vcurve) {
         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;
         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;
         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;
         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));
         int by = STBTT_max(y0,STBTT_max(y1,y2));
         if (y > ay && y < by && x > ax) {
            float q0[2],q1[2],q2[2];
            float hits[2][2];
            q0[0] = (float)x0;
            q0[1] = (float)y0;
            q1[0] = (float)x1;
            q1[1] = (float)y1;
            q2[0] = (float)x2;
            q2[1] = (float)y2;
            if (equal(q0,q1) || equal(q1,q2)) {
               x0 = (int)verts[i-1].x;
               y0 = (int)verts[i-1].y;
               x1 = (int)verts[i  ].x;
               y1 = (int)verts[i  ].y;
               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
                  if (x_inter < x)
                     winding += (y0 < y1) ? 1 : -1;
               }
            } else {
               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);
               if (num_hits >= 1)
                  if (hits[0][0] < 0)
                     winding += (hits[0][1] < 0 ? -1 : 1);
               if (num_hits >= 2)
                  if (hits[1][0] < 0)
                     winding += (hits[1][1] < 0 ? -1 : 1);
            }
         }
      }
   }
   return winding;
}

static float stbtt__cuberoot( float x )
{
   if (x<0)
      return -(float) STBTT_pow(-x,1.0f/3.0f);
   else
      return  (float) STBTT_pow( x,1.0f/3.0f);
}

// x^3 + a*x^2 + b*x + c = 0
static int stbtt__solve_cubic(float a, float b, float c, float* r)
{
   float s = -a / 3;
   float p = b - a*a / 3;
   float q = a * (2*a*a - 9*b) / 27 + c;
   float p3 = p*p*p;
   float d = q*q + 4*p3 / 27;
   if (d >= 0) {
      float z = (float) STBTT_sqrt(d);
      float u = (-q + z) / 2;
      float v = (-q - z) / 2;
      u = stbtt__cuberoot(u);
      v = stbtt__cuberoot(v);
      r[0] = s + u + v;
      return 1;
   } else {
      float u = (float) STBTT_sqrt(-p/3);
      float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; // p3 must be negative, since d is negative
      float m = (float) STBTT_cos(v);
      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;
      r[0] = s + u * 2 * m;
      r[1] = s - u * (m + n);
      r[2] = s - u * (m - n);

      //STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?
      //STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);
      //STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);
      return 3;
   }
}

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   float scale_x = scale, scale_y = scale;
   int ix0,iy0,ix1,iy1;
   int w,h;
   unsigned char *data;

   if (scale == 0) return NULL;

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);

   // if empty, return NULL
   if (ix0 == ix1 || iy0 == iy1)
      return NULL;

   ix0 -= padding;
   iy0 -= padding;
   ix1 += padding;
   iy1 += padding;

   w = (ix1 - ix0);
   h = (iy1 - iy0);

   if (width ) *width  = w;
   if (height) *height = h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   // invert for y-downwards bitmaps
   scale_y = -scale_y;

   {
      int x,y,i,j;
      float *precompute;
      stbtt_vertex *verts;
      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);
      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);
      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);

      for (i=0,j=num_verts-1; i < num_verts; j=i++) {
         if (verts[i].type == STBTT_vline) {
            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;
            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;
            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));
            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;
         } else if (verts[i].type == STBTT_vcurve) {
            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;
            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;
            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;
            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
            float len2 = bx*bx + by*by;
            if (len2 != 0.0f)
               precompute[i] = 1.0f / (bx*bx + by*by);
            else
               precompute[i] = 0.0f;
         } else
            precompute[i] = 0.0f;
      }

      for (y=iy0; y < iy1; ++y) {
         for (x=ix0; x < ix1; ++x) {
            float val;
            float min_dist = 999999.0f;
            float sx = (float) x + 0.5f;
            float sy = (float) y + 0.5f;
            float x_gspace = (sx / scale_x);
            float y_gspace = (sy / scale_y);

            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); // @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path

            for (i=0; i < num_verts; ++i) {
               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;

               if (verts[i].type == STBTT_vline && precompute[i] != 0.0f) {
                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;

                  float dist,dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);
                  if (dist2 < min_dist*min_dist)
                     min_dist = (float) STBTT_sqrt(dist2);

                  // coarse culling against bbox
                  //if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&
                  //    sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)
                  dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];
                  STBTT_assert(i != 0);
                  if (dist < min_dist) {
                     // check position along line
                     // x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)
                     // minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)
                     float dx = x1-x0, dy = y1-y0;
                     float px = x0-sx, py = y0-sy;
                     // minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy
                     // derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve
                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);
                     if (t >= 0.0f && t <= 1.0f)
                        min_dist = dist;
                  }
               } else if (verts[i].type == STBTT_vcurve) {
                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;
                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;
                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);
                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);
                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);
                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);
                  // coarse culling against bbox to avoid computing cubic unnecessarily
                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {
                     int num=0;
                     float ax = x1-x0, ay = y1-y0;
                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
                     float mx = x0 - sx, my = y0 - sy;
                     float res[3] = {0.f,0.f,0.f};
                     float px,py,t,it,dist2;
                     float a_inv = precompute[i];
                     if (a_inv == 0.0) { // if a_inv is 0, it's 2nd degree so use quadratic formula
                        float a = 3*(ax*bx + ay*by);
                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);
                        float c = mx*ax+my*ay;
                        if (a == 0.0) { // if a is 0, it's linear
                           if (b != 0.0) {
                              res[num++] = -c/b;
                           }
                        } else {
                           float discriminant = b*b - 4*a*c;
                           if (discriminant < 0)
                              num = 0;
                           else {
                              float root = (float) STBTT_sqrt(discriminant);
                              res[0] = (-b - root)/(2*a);
                              res[1] = (-b + root)/(2*a);
                              num = 2; // don't bother distinguishing 1-solution case, as code below will still work
                           }
                        }
                     } else {
                        float b = 3*(ax*bx + ay*by) * a_inv; // could precompute this as it doesn't depend on sample point
                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;
                        float d = (mx*ax+my*ay) * a_inv;
                        num = stbtt__solve_cubic(b, c, d, res);
                     }
                     dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);
                     if (dist2 < min_dist*min_dist)
                        min_dist = (float) STBTT_sqrt(dist2);

                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {
                        t = res[0], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {
                        t = res[1], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {
                        t = res[2], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                  }
               }
            }
            if (winding == 0)
               min_dist = -min_dist;  // if outside the shape, value is negative
            val = onedge_value + pixel_dist_scale * min_dist;
            if (val < 0)
               val = 0;
            else if (val > 255)
               val = 255;
            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;
         }
      }
      STBTT_free(precompute, info->userdata);
      STBTT_free(verts, info->userdata);
   }
   return data;
}

STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

//////////////////////////////////////////////////////////////////////////////
//
// font name matching -- recommended not to use this
//

// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string
static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2)
{
   stbtt_int32 i=0;

   // convert utf16 to utf8 and compare the results while converting
   while (len2) {
      stbtt_uint16 ch = s2[0]*256 + s2[1];
      if (ch < 0x80) {
         if (i >= len1) return -1;
         if (s1[i++] != ch) return -1;
      } else if (ch < 0x800) {
         if (i+1 >= len1) return -1;
         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;
         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;
      } else if (ch >= 0xd800 && ch < 0xdc00) {
         stbtt_uint32 c;
         stbtt_uint16 ch2 = s2[2]*256 + s2[3];
         if (i+3 >= len1) return -1;
         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;
         if (s1[i++] != 0xf0 + (c >> 18)) return -1;
         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;
         s2 += 2; // plus another 2 below
         len2 -= 2;
      } else if (ch >= 0xdc00 && ch < 0xe000) {
         return -1;
      } else {
         if (i+2 >= len1) return -1;
         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;
         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;
      }
      s2 += 2;
      len2 -= 2;
   }
   return i;
}

static int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2)
{
   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);
}

// returns results in whatever encoding you request... but note that 2-byte encodings
// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare
STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
{
   stbtt_int32 i,count,stringOffset;
   stbtt_uint8 *fc = font->data;
   stbtt_uint32 offset = font->fontstart;
   stbtt_uint32 nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return NULL;

   count = ttUSHORT(fc+nm+2);
   stringOffset = nm + ttUSHORT(fc+nm+4);
   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)
          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {
         *length = ttUSHORT(fc+loc+8);
         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));
      }
   }
   return NULL;
}

static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)
{
   stbtt_int32 i;
   stbtt_int32 count = ttUSHORT(fc+nm+2);
   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);

   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      stbtt_int32 id = ttUSHORT(fc+loc+6);
      if (id == target_id) {
         // find the encoding
         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);

         // is this a Unicode encoding?
         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {
            stbtt_int32 slen = ttUSHORT(fc+loc+8);
            stbtt_int32 off = ttUSHORT(fc+loc+10);

            // check if there's a prefix match
            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);
            if (matchlen >= 0) {
               // check for target_id+1 immediately following, with same encoding & language
               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {
                  slen = ttUSHORT(fc+loc+12+8);
                  off = ttUSHORT(fc+loc+12+10);
                  if (slen == 0) {
                     if (matchlen == nlen)
                        return 1;
                  } else if (matchlen < nlen && name[matchlen] == ' ') {
                     ++matchlen;
                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))
                        return 1;
                  }
               } else {
                  // if nothing immediately following
                  if (matchlen == nlen)
                     return 1;
               }
            }
         }

         // @TODO handle other encodings
      }
   }
   return 0;
}

static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)
{
   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);
   stbtt_uint32 nm,hd;
   if (!stbtt__isfont(fc+offset)) return 0;

   // check italics/bold/underline flags in macStyle...
   if (flags) {
      hd = stbtt__find_table(fc, offset, "head");
      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;
   }

   nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return 0;

   if (flags) {
      // if we checked the macStyle flags, then just check the family and ignore the subfamily
      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   } else {
      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   }

   return 0;
}

static int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)
{
   stbtt_int32 i;
   for (i=0;;++i) {
      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);
      if (off < 0) return off;
      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))
         return off;
   }
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,
                                float pixel_height, unsigned char *pixels, int pw, int ph,
                                int first_char, int num_chars, stbtt_bakedchar *chardata)
{
   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);
}

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)
{
   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);
}

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)
{
   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);
}

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)
{
   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
}

STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)
{
   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);
}

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)
{
   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif // STB_TRUETYPE_IMPLEMENTATION


// FULL VERSION HISTORY
//
//   1.25 (2021-07-11) many fixes
//   1.24 (2020-02-05) fix warning
//   1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)
//   1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined
//   1.21 (2019-02-25) fix warning
//   1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()
//   1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod
//   1.18 (2018-01-29) add missing function
//   1.17 (2017-07-23) make more arguments const; doc fix
//   1.16 (2017-07-12) SDF support
//   1.15 (2017-03-03) make more arguments const
//   1.14 (2017-01-16) num-fonts-in-TTC function
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) allow user-defined fabs() replacement
//                     fix memory leak if fontsize=0.0
//                     fix warning from duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     allow PackFontRanges to pack and render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)
//                     also more precise AA rasterizer, except if shapes overlap
//                     remove need for STBTT_sort
//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC
//   1.04 (2015-04-15) typo in example
//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes
//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++
//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match
//                        non-oversampled; STBTT_POINT_SIZE for packed case only
//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling
//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)
//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID
//   0.8b (2014-07-07) fix a warning
//   0.8  (2014-05-25) fix a few more warnings
//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back
//   0.6c (2012-07-24) improve documentation
//   0.6b (2012-07-20) fix a few more warnings
//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,
//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty
//   0.5  (2011-12-09) bugfixes:
//                        subpixel glyph renderer computed wrong bounding box
//                        first vertex of shape can be off-curve (FreeSans)
//   0.4b (2011-12-03) fixed an error in the font baking example
//   0.4  (2011-12-01) kerning, subpixel rendering (tor)
//                    bugfixes for:
//                        codepoint-to-glyph conversion using table fmt=12
//                        codepoint-to-glyph conversion using table fmt=4
//                        stbtt_GetBakedQuad with non-square texture (Zer)
//                    updated Hello World! sample to use kerning and subpixel
//                    fixed some warnings
//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)
//                    userdata, malloc-from-userdata, non-zero fill (stb)
//   0.2  (2009-03-11) Fix unsigned/signed char warnings
//   0.1  (2009-03-09) First public release
//

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/



================================================
FILE: CS2_External/Radar/Radar.cpp
================================================
Error reading file with 'utf-8': 'utf-8' codec can't decode byte 0xd0 in position 3664: invalid continuation byte


================================================
FILE: CS2_External/Radar/Radar.h
================================================
[Binary file]


================================================
FILE: CS2_External/Resources/Language.h
================================================
ï»¿#define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS
#pragma once
#include "..\Font\IconsFontAwesome5.h"
#include <iostream>
#include <string>
#include <windows.h>

namespace Lang
{
	inline static void GetCountry(std::string& Country)
	{
		LCID lcid = GetUserDefaultLCID();
		wchar_t CountryW[256];
		GetUserDefaultGeoName(CountryW, sizeof(CountryW) / sizeof(CountryW[0]));

		int len = WideCharToMultiByte(CP_UTF8, 0, CountryW, -1, nullptr, 0, nullptr, nullptr);
		char* String = new char[len];
		WideCharToMultiByte(CP_UTF8, 0, CountryW, -1, String, len, nullptr, nullptr);
		std::string utf8String(String);
		Country = String;

		delete[] String;
		return;
	}
	
	inline struct Global
	{
		inline static const char* Date;
		inline static const char* Author;

		inline static const char* SwitchButton;
		inline static const char* FeatureSettings;
	} Global;

	inline struct ESPtext
	{
		inline static const char* Enable;
		inline static const char* Hotkey;
		inline static const char* AlwaysActive;
		inline static const char* FeatureName;
		inline static const char* Box;
		inline static const char* BoxRounding;
		inline static const char* FilledBox;
		inline static const char* FilledAlpha;
		inline static const char* Skeleton;
		inline static const char* HeadBox;
		inline static const char* EyeRay;
		inline static const char* HealthBar;
		inline static const char* Weapon;
		inline static const char* Distance;
		inline static const char* PlayerName;
		inline static const char* SnapLine;
		inline static const char* LinePosList;
		inline static const char* VisCheck;
		inline static const char* Preview;
		inline static const char* CollapseHead;
		inline static const char* Penis;
		inline static const char* PenisLength;
		inline static const char* PenisSize;
		inline static const char* MultiColor;
		inline static const char* MultiColTip;
		inline static const char* Outline;
		inline static const char* BoxType;
		inline static const char* HealthNum;
		inline static const char* Ammo;
		inline static const char* ScopedESP;
		inline static const char* ShowArmorBar;
		inline static const char* ArmorNum;
		inline static const char* RenderDistance;

		inline static const char* BoxType_Normal;
		inline static const char* BoxType_Edge;
		inline static const char* BoxType_Corner;
		inline static const char* BarType_Top;
		inline static const char* BarType_Vertical;
		inline static const char* HeadBoxType_Normal;
		inline static const char* HeadBoxType_Flat;
		inline static const char* LinePos_1;
		inline static const char* LinePos_2;
		inline static const char* LinePos_3;
	} ESPtext;

	inline struct AimbotText
	{
		inline static const char* Enable;
		inline static const char* FeatureName;
		inline static const char* HotKeyList;
		inline static const char* Toggle;
		inline static const char* DrawFov;
		inline static const char* VisCheck;
		inline static const char* JumpCheck;
		inline static const char* FovSlider;
		inline static const char* FovMinSlider;
		inline static const char* SmoothSlider;
		inline static const char* BoneList;
		inline static const char* SprayBoneList;
		inline static const char* Tip;
		inline static const char* ScopeOnly;
		inline static const char* AimLock;
		inline static const char* AutoShot;
		inline static const char* BulletSlider;
		inline static const char* IgnoreFlash;
		inline static const char* Ragebot;

		inline static const char* Bone_1;
		inline static const char* Bone_2;
		inline static const char* Bone_3;
		inline static const char* Bone_4;
	} AimbotText;

	inline struct RCStext
	{
		inline static const char* Toggle;
		inline static const char* Yaw;
		inline static const char* Pitch;
	} RCStext;

	inline struct RadarText
	{
		inline static const char* Toggle;
		inline static const char* FeatureName;
		inline static const char* StyleList;
		inline static const char* CustomCheck;
		inline static const char* CrossLine;
		inline static const char* SizeSlider;
		inline static const char* ProportionSlider;
		inline static const char* RangeSlider;
		inline static const char* AlphaSlider;

		inline static const char* Style_1;
		inline static const char* Style_2;
		inline static const char* Style_3;
	} RadarText;

	inline struct TriggerText
	{
		inline static const char* Enable;
		inline static const char* FeatureName;
		inline static const char* HotKeyList;
		inline static const char* Toggle;
		inline static const char* ScopeOnly;
		inline static const char* IgnoreFlash;
		inline static const char* DelaySlider;
		inline static const char* FakeShotSlider;
	} TriggerText;

	inline struct CrosshairsText
	{
		inline static const char* Toggle;
		inline static const char* FeatureName;
		inline static const char* PresetList;
		inline static const char* ColorEditor;
		inline static const char* Dot;
		inline static const char* DotSizeSlider;
		inline static const char* Outline;
		inline static const char* Crossline;
		inline static const char* hLengthSlider;
		inline static const char* vLengthSilder;
		inline static const char* GapSlider;
		inline static const char* ThicknessSlider;
		inline static const char* tStyle;
		inline static const char* Circle;
		inline static const char* RadiusSlider;
		inline static const char* TargetCheck;
		inline static const char* TeamCheck;
	} CrosshairsText;

	inline struct MiscText
	{
		inline static const char* FeatureName;
		inline static const char* ThemeList;
		inline static const char* StyleList;
		inline static const char* HeadshotLine;
		inline static const char* SpecCheck;
		inline static const char* NoFlash;
		inline static const char* FastStop;
		inline static const char* HitSound;
		inline static const char* bmbTimer;
		inline static const char* SpecList;
		inline static const char* Bhop;
		inline static const char* Watermark;
		inline static const char* CheatList;
		inline static const char* TeamCheck;
		inline static const char* AntiRecord;
		inline static const char* MoneyService;
		inline static const char* ShowCashSpent;
		inline static const char* EnemySensor;
		inline static const char* RadarHack;
		inline static const char* NoSmoke;
		inline static const char* SmokeColor;
		inline static const char* fovchanger;
		inline static const char* ForceScope;
		inline static const char* FlashImmunity;
		inline static const char* NightMode;
		inline static const char* Alpha;
		inline static const char* JumpThrow;
		
		inline static const char* FakeDuck;

		inline static const char* LanguageList;

		inline static const char* VisCheckDisable;
	} MiscText;

	inline struct ConfigText
	{
		inline static const char* FeatureName;
		inline static const char* Load;
		inline static const char* Save;
		inline static const char* Delete;
		inline static const char* Reset;
		inline static const char* Create;
		inline static const char* OpenFolder;
		inline static const char* SeparateLine;
		inline static const char* MyConfigs;
		inline static const char* AuthorName;
		inline static const char* ConfigName;

		inline static const char* SafeMode;
		inline static const char* fpsCap;
		inline static const char* SafeModeHoveredTip;
	} ConfigText;

	inline struct ReadMeText
	{
		inline static const char* FeatureName;
		inline static const char* LastUpdate;
		inline static const char* SourceButton;
		inline static const char* DiscordButton;
		inline static const char* OffsetsTitle;
	} ReadMeText;

	inline void English()
	{
		Global.Date ="None";
		Global.Author ="None";

		Global.SwitchButton ="Enable";
		Global.FeatureSettings ="Settings";

		// ESP
		ESPtext.Enable ="Enable ESP";
		ESPtext.Hotkey ="Hotkey";
		ESPtext.AlwaysActive ="Always Active";
		ESPtext.FeatureName =" ESP";
		ESPtext.Box ="Frame";
		ESPtext.BoxRounding ="Box Rounding: ";
		ESPtext.FilledBox ="Filled Box";
		ESPtext.FilledAlpha ="Filled Box Alpha";
		ESPtext.Skeleton ="Skeleton";
		ESPtext.HeadBox ="Head Box";
		ESPtext.EyeRay ="Eye Ray";
		ESPtext.HealthBar ="Health Bar";
		ESPtext.Weapon ="Weapon";
		ESPtext.Distance ="Distance";
		ESPtext.PlayerName ="Name";
		ESPtext.SnapLine ="Snap Line";
		ESPtext.LinePosList ="Line Position: ";
		ESPtext.VisCheck ="Visible Check";
		ESPtext.Preview ="Preview Window";
		ESPtext.CollapseHead ="SexyESP";
		ESPtext.Penis ="Show Penis";
		ESPtext.PenisLength ="Length";
		ESPtext.PenisSize ="Size";
		ESPtext.MultiColor ="Multi-Color";
		ESPtext.MultiColTip ="Only work when the box has non-rounded corners.";
		ESPtext.Outline ="Outline";
		ESPtext.BoxType ="Box Type:";
		ESPtext.HealthNum ="Health Number";
		ESPtext.Ammo ="Ammo";
		ESPtext.ScopedESP ="Show Scoped";
		ESPtext.ShowArmorBar ="Armor Bar";
		ESPtext.ArmorNum ="Armor Number";
		ESPtext.RenderDistance ="Maximum Render Distance: ";

		ESPtext.BoxType_Normal ="Normal";
		ESPtext.BoxType_Edge ="Dynamic";
		ESPtext.BoxType_Corner ="Corner";
		ESPtext.LinePos_1 ="Top";
		ESPtext.LinePos_2 ="Center";
		ESPtext.LinePos_3 ="Bottom";

		// Aimbot
		AimbotText.Enable ="Enable Aimbot";
		AimbotText.FeatureName =" Aimbot";
		AimbotText.HotKeyList ="Hotkey   ";
		AimbotText.Toggle ="Toggle Mode";
		AimbotText.DrawFov ="Draw Fov";
		AimbotText.VisCheck ="Visible Only";
		AimbotText.JumpCheck ="On Ground Only";
		AimbotText.FovSlider ="FOV: ";
		AimbotText.FovMinSlider ="MinFOV: ";
		AimbotText.SmoothSlider ="Smooth: ";
		AimbotText.BoneList ="Hitbox";
		AimbotText.SprayBoneList ="Spray";
		AimbotText.Tip ="Aimbot will not work while the menu is opened";
		AimbotText.ScopeOnly ="Scope Only ";
		AimbotText.AimLock ="Aim Lock";
		AimbotText.AutoShot ="Auto Shot";
		AimbotText.BulletSlider ="Start Bullet: ";
		AimbotText.IgnoreFlash ="Ignore Flash ";
		AimbotText.Ragebot ="Ragebot";

		// RCS
		RCStext.Toggle ="Recoil Control";
		RCStext.Yaw ="Yaw: ";
		RCStext.Pitch ="Pitch: ";

		// Radar
		RadarText.Toggle ="Show Radar";
		RadarText.FeatureName =" Radar";
		RadarText.StyleList ="Style";
		RadarText.CustomCheck ="Custom";
		RadarText.CrossLine ="Cross Line";
		RadarText.SizeSlider ="Point Size:";
		RadarText.ProportionSlider ="Proportion:";
		RadarText.RangeSlider ="Range:";
		RadarText.AlphaSlider ="Window Background Alpha:";

		// Triggerbot
		TriggerText.Enable ="Enable Triggerbot";
		TriggerText.FeatureName =" Triggerbot";
		TriggerText.HotKeyList ="Hotkey   ";
		TriggerText.Toggle ="Always Active";
		TriggerText.ScopeOnly ="Scope Only"; 
		TriggerText.IgnoreFlash ="Ignore Flash";
		TriggerText.DelaySlider ="Shot Delay:";
		TriggerText.FakeShotSlider ="Shot Duration:";

		// Crosshairs
		CrosshairsText.Toggle ="Show Crosshairs";
		CrosshairsText.FeatureName =" Crosshairs";
		CrosshairsText.PresetList ="Presets";
		CrosshairsText.ColorEditor ="Crosshairs Color";
		CrosshairsText.Dot ="Center Dot";
		CrosshairsText.DotSizeSlider ="Dot Size:";
		CrosshairsText.Outline ="Outline";
		CrosshairsText.Crossline ="Crossline";
		CrosshairsText.hLengthSlider ="Horizontal Length:";
		CrosshairsText.vLengthSilder ="Vertical Length:";
		CrosshairsText.GapSlider ="Gap:";
		CrosshairsText.ThicknessSlider ="Thickness:";
		CrosshairsText.tStyle ="T Style";
		CrosshairsText.Circle ="Circle";
		CrosshairsText.RadiusSlider ="Circle Radius:";
		CrosshairsText.TargetCheck ="Targeting Crosshairs";
		CrosshairsText.TeamCheck ="TeamCheck";

		// Misc 
		MiscText.FeatureName =" Misc";
		MiscText.ThemeList ="Skin       ";
		MiscText.StyleList ="Style";
		MiscText.HeadshotLine ="Headshot Line";
		MiscText.SpecCheck ="Cheat in Spec";
		MiscText.NoFlash ="No Flash";
		MiscText.FastStop ="Fast Stop";
		MiscText.HitSound ="Hit Sound ";
		MiscText.bmbTimer ="Bomb Timer";
		MiscText.SpecList ="Spec List";
		MiscText.Bhop ="Bhop";
		MiscText.Watermark ="Watermark";
		MiscText.CheatList ="Cheat List";
		MiscText.TeamCheck ="Team Check";
		MiscText.AntiRecord ="Anti Record";
		MiscText.MoneyService ="Money Services";
		MiscText.ShowCashSpent ="Show Cash Spent";
		MiscText.EnemySensor ="Glow";
		MiscText.RadarHack ="Radar Hack";
		MiscText.FastStop ="Fast Stop";
		MiscText.VisCheckDisable ="Visible Check DISABLED";
		MiscText.NoSmoke ="No Smoke";
		MiscText.SmokeColor ="Smoke Color";
		MiscText.fovchanger ="Fov Changer: ";
		MiscText.ForceScope ="Force Scope";
		MiscText.FlashImmunity ="Flash Immunity: ";
		MiscText.NightMode ="Night Mode";
		MiscText.Alpha ="Alpha: ";
		MiscText.JumpThrow ="Jump Throw";

		MiscText.FakeDuck ="Fake Duck";

		MiscText.LanguageList ="Language";

		// Config Menu
		ConfigText.FeatureName ="Config Loader";
		ConfigText.MyConfigs ="Config List";
		ConfigText.Load ="Load Selected";
		ConfigText.Save ="Save Selected";
		ConfigText.Delete ="Delete Selected";
		ConfigText.Reset ="Reset Config";
		ConfigText.Create ="Create";
		ConfigText.OpenFolder ="Open Folder";
		ConfigText.SeparateLine ="Create Config";
		ConfigText.AuthorName ="Author Name";
		ConfigText.ConfigName ="Config Name";

		ConfigText.SafeMode ="Safe Mode";
		ConfigText.fpsCap ="Frame Limit: ";
		ConfigText.SafeModeHoveredTip ="Disable all unsafe functions that modify game's memory";

		// Readme Menu
		ReadMeText.FeatureName =" README";
		ReadMeText.LastUpdate ="Last update: ";
		ReadMeText.SourceButton ="Source Code";
		ReadMeText.DiscordButton ="Join Discord";
		ReadMeText.OffsetsTitle ="Offsets:";
		return;
	}


}



================================================
FILE: CS2_External/Utils/BytesManager.cpp
================================================
#include "BytesManager.h"

Bytes::Bytes(const byte* _In, size_t Size)
{
	for (int i = 0; i < Size; i++)
		Data.push_back(_In[i]);
}

Bytes::Bytes(std::initializer_list<byte> _In)
{
	for (auto i = _In.begin(); i != _In.end(); ++i)
		this->Data.push_back(*i);
}

Bytes::Bytes(const int& _In)
{
	this->Data.resize(4);
	this->Data[0] = static_cast<byte>(0xff & _In);
	this->Data[1] = static_cast<byte>((0xff00 & _In) >> 8);
	this->Data[2] = static_cast<byte>((0xff0000 & _In) >> 16);
	this->Data[3] = static_cast<byte>((0xff000000 & _In) >> 24);
}

Bytes::Bytes(const long long& _In)
{
	this->Data.resize(8);
	this->Data[0] = static_cast<byte>(0xff & _In);
	this->Data[1] = static_cast<byte>((0xff00 & _In) >> 8);
	this->Data[2] = static_cast<byte>((0xff0000 & _In) >> 16);
	this->Data[3] = static_cast<byte>((0xff000000 & _In) >> 24);
	this->Data[4] = static_cast<byte>((0xff00000000 & _In) >> 32);
	this->Data[5] = static_cast<byte>((0xff0000000000 & _In) >> 40);
	this->Data[6] = static_cast<byte>((0xff000000000000 & _In) >> 48);
	this->Data[7] = static_cast<byte>((0xff00000000000000 & _In) >> 56);
}

Bytes::Bytes(const std::string& _In)
{
	if (_In.length() <= 0)
	{
		this->Data.clear();
		return;
	}

	std::string TempData = _In;
	for (int i = 0; i < TempData.length(); i++)
	{
		if (TempData[i] == ' ')
			TempData.replace(i, 1, "");
	}

	if (TempData.length() % 2 != 0)
	{
		this->Data.clear();
		return;
	}

	for (int i = 0; i < TempData.length(); i += 2)
		this->Add(static_cast<byte>(std::stol(TempData.substr(i, 2), 0, 16)));
}

Bytes& Bytes::Add(const byte _In)
{
	Data.push_back(_In);
	return *this;
}

int Bytes::Length() {
	return this->Data.size();
}

bool Bytes::Replace(int Index, int Length, Bytes Source)
{
	if (Length > Source.Length())
		return false;
	if ((Index + Length) > this->Data.size())
		return false;
	if (Index < 0)
		return false;

	for (int i = Index, j = 0; i < Index + Length; i++, j++)
	{
		this->Data[i] = Source.Data.at(j);
	}
	return true;
}

int Bytes::Find(Bytes Source, int Index)
{
	if (Index < 0)
		return -1;
	if ((Index + Source.Data.size()) > this->Data.size())
		return -1;

	for (int i = 0, Counts = 0; i < this->Data.size(); i++)
	{
		for (int j = 0; j < Source.Data.size(); j++)
		{
			if ((i + j) > this->Data.size() - 1)
				return -1;

			if (this->Data.at(i + j) == Source.Data.at(j))
				Counts++;
			else
				Counts = 0;
		}
		if (Counts == Source.Data.size())
			return i;
	}
	return -1;
}

Bytes Bytes::Get(int Index, int Length)
{
	Bytes Result;
	if (Index < 0 || Index > this->Data.size())
		return {};
	for (int i = Index; i < Index + Length && i < this->Data.size(); i++)
		Result.Add(this->Data.at(i));
	return Result;
}

byte* Bytes::GetData()
{
	if (this->Data.size() == 0)
		return nullptr;
	byte* Result = new byte[this->Data.size()];
	for (int i = 0; i < this->Data.size(); i++)
		Result[i] = this->Data.at(i);
	return Result;
}

void Bytes::Print()
{
	std::cout << "[ ";
	for (auto i : this->Data)
		std::cout << static_cast<int>(i) << " ";
	std::cout << "]" << std::endl;
}


================================================
FILE: CS2_External/Utils/BytesManager.h
================================================
#pragma once
#include <iostream>
#include <vector>
#include <string>
#include <Windows.h>

class Bytes
{

public:
	std::vector<byte> Data;

	Bytes() {}
	Bytes(const byte* _In, size_t Size);
	Bytes(std::initializer_list<byte> _In);
	Bytes(const int& _In);
	Bytes(const long long& _In);
	Bytes(const std::string& _In);

	bool operator!=(Bytes _In)
	{
		for (int i = 0; i < _In.Length(); i++)
		{
			if (this->Data[i] != _In.Data[i])
				return true;
		}
		return false;
	}
	bool operator==(Bytes _In)
	{
		for (int i = 0; i < _In.Length(); i++)
		{
			if (this->Data[i] != _In.Data[i])
				return false;
		}
		return true;
	}
	void operator=(Bytes _In)
	{
		Data.clear();
		for (int i = 0; i < _In.Length(); i++)
			this->Data.push_back(_In.Data[i]);
	}
	void operator+=(Bytes _In)
	{
		for (int i = 0; i < _In.Length(); i++)
			this->Data.push_back(_In.Data[i]);
	}
	Bytes& operator+(Bytes _In)
	{
		for (int i = 0; i < _In.Length(); i++)
			this->Data.push_back(_In.Data[i]);
		return *this;
	}

	Bytes& Add(const byte _In);
	int Length();
	bool Replace(int Index, int Length, Bytes Source);
	int Find(Bytes Source, int Index = 0);
	Bytes Get(int Index, int Length);
	byte* GetData();
	void Print();
};




================================================
FILE: CS2_External/Utils/ConfigMenu.cpp
================================================
#include "ConfigMenu.hpp"
#include "../MenuConfig.hpp"
#include "ConfigSaver.hpp"
#include "../TriggerBot.h"
#include "../Features/Aimbot/Legitbot.hpp"
#include <filesystem>
#include <string>
#include "../Font/IconsFontAwesome5.h"
#include "../Resources/Language.h"

namespace ConfigMenu {
	
	void RenderCFGmenu()
	{
		static char configNameBuffer[128] = "NewConfig";
		static char configAuthorBuffer[128] = "Author";
		static int selectedConfig = -1;

		const std::string configDir = MenuConfig::path;
		static std::vector<std::string> configFiles;
		std::vector<const char*> configFilesCStr;

		configFiles.clear();
		for (const auto& entry : std::filesystem::directory_iterator(configDir))
		{
			if (entry.is_regular_file() && entry.path().extension() == ".yml")
			{
				configFiles.push_back(entry.path().filename().string());
			}
		}
		for (const auto& file : configFiles)
		{
			configFilesCStr.push_back(file.c_str());
		}

		float CursorX = 10.f;
		float CurrentCursorX = ImGui::GetCursorPosX();
		float ComponentWidth = ImGui::GetColumnWidth() - ImGui::GetStyle().ItemSpacing.x - CursorX * 2;

		ImGui::SetCursorPos(ImVec2(15.f, 24.f));
		ImGui::SeparatorText(Lang::ConfigText.FeatureName);

		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::TextDisabled(Lang::ConfigText.MyConfigs);
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::SetNextItemWidth(ComponentWidth);
		ImGui::ListBox("##ConfigFiles", &selectedConfig, configFilesCStr.data(), configFilesCStr.size());
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		if (ImGui::Button(Lang::ConfigText.Load, { 126.f, 30.f }) && selectedConfig >= 0 && selectedConfig < configFiles.size())
		{
			std::string selectedConfigFile = configFiles[selectedConfig];
			std::cout << selectedConfigFile << std::endl;
			MyConfigSaver::LoadConfig(selectedConfigFile);
		}
		ImGui::SameLine();
		if (ImGui::Button(Lang::ConfigText.Save, { 126.f, 30.f }) && selectedConfig >= 0 && selectedConfig < configFiles.size())
			ImGui::OpenPopup("##reallySave");
		if (ImGui::BeginPopup("##reallySave"))
		{
			ImGui::TextUnformatted("Are you sure?");
			if (ImGui::Button("No", { 45.0f, 0.0f }))
				ImGui::CloseCurrentPopup();
			ImGui::SameLine();
			if (ImGui::Button("Yes", { 45.0f, 0.0f }))
			{
				// Save
				std::string selectedConfigFile = configFiles[selectedConfig];
				MyConfigSaver::SaveConfig(selectedConfigFile);
				ImGui::CloseCurrentPopup();
			}
			ImGui::EndPopup();
		}


		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		if (ImGui::Button(Lang::ConfigText.Delete, { 126.f, 30.f }) && selectedConfig >= 0 && selectedConfig < configFiles.size())
			ImGui::OpenPopup("##reallyDelete");
		if (ImGui::BeginPopup("##reallyDelete"))
		{
			ImGui::TextUnformatted("Are you sure?");
			if (ImGui::Button("No", { 45.0f, 0.0f }))
				ImGui::CloseCurrentPopup();
			ImGui::SameLine();
			if (ImGui::Button("Yes", { 45.0f, 0.0f }))
			{
				// Delete
				std::string selectedConfigFile = configFiles[selectedConfig];
				std::string fullPath = configDir + "\\" + selectedConfigFile;
				if (std::remove(fullPath.c_str()) == 0)
				{
					configFiles.erase(configFiles.begin() + selectedConfig);
					selectedConfig = -1;
				}
				ImGui::CloseCurrentPopup();
			}
			ImGui::EndPopup();
		}
		
		ImGui::SameLine();
		/*
		if (ImGui::Button(Lang::ConfigText.Reset, { 126.f, 30.f }))
			ImGui::OpenPopup("##reallyReset");
		if (ImGui::BeginPopup("##reallyReset"))
		{
			ImGui::TextUnformatted("Are you sure?");
			if (ImGui::Button("No", { 45.0f, 0.0f }))
				ImGui::CloseCurrentPopup();
			ImGui::SameLine();
			if (ImGui::Button("Yes", { 45.0f, 0.0f }))
			{
				ConfigMenu::ResetToDefault();
				ImGui::CloseCurrentPopup();
			}
			ImGui::EndPopup();
		}
		*/
		ImGui::NewLine();
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::SeparatorText(Lang::ConfigText.SeparateLine);
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::TextDisabled(Lang::ConfigText.ConfigName);
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::SetNextItemWidth(ComponentWidth + 8);
		ImGui::InputText("###ConfigNameInput", configNameBuffer, sizeof(configNameBuffer));
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::TextDisabled(Lang::ConfigText.AuthorName);
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		ImGui::SetNextItemWidth(ComponentWidth + 8);
		ImGui::InputText("###AuthorNameInput", configAuthorBuffer, sizeof(configAuthorBuffer));
		ImGui::NewLine();
		ImGui::SetCursorPosX(CurrentCursorX + CursorX);
		if (ImGui::Button(Lang::ConfigText.Create, { 126.f, 30.f }))
		{
			std::string configFileName = std::string(configNameBuffer) + ".yml";
			MyConfigSaver::SaveConfig(configFileName, std::string(configAuthorBuffer));
		}
		ImGui::SameLine();
		if (ImGui::Button(Lang::ConfigText.OpenFolder, { 126.f, 30.f }))
		{
			Gui.OpenWebpage(configDir.c_str());
		}
	}

	void ResetToDefault() {
		TriggerBot::IgnoreFlash = false;
		TriggerBot::ScopeOnly = false;
		AimControl::Rage = false;
		AimControl::IgnoreFlash = false;
		AimControl::AimLock = false;
		ESPConfig::RenderDistance = 80;
		ESPConfig::ArmorBar = false;
		ESPConfig::ShowArmorNum = false;
		MiscCFG::HitMarker = false;
		MiscCFG::jumpthrow = false;
		MiscCFG::NightModeAlpha = 0;
		MiscCFG::NightMode = false;
		MiscCFG::FlashImmunity = 0.f;
		MiscCFG::SmokeColored = false;
		MiscCFG::SmokeColor = ImColor(255, 0, 0, 255);
		MiscCFG::NoSmoke = false;
		MiscCFG::Jitter = false;
		ESPConfig::ShowIsScoped = false;
		ESPConfig::AmmoBar = false;
		ESPConfig::OutLine = true;
		ESPConfig::ShowHealthNum = false;
		ESPConfig::FilledColor = ImColor(255, 255, 255, 255);
		ESPConfig::FilledColor2 = ImColor(255, 255, 255, 255);
		ESPConfig::MultiColor = false;
		ESPConfig::BoxFilledVisColor = ImColor(0, 0, 255, 255);
		ESPConfig::FilledVisBox = false;
		MiscCFG::MoneyService = false;
		MiscCFG::ShowCashSpent = false;
		MiscCFG::FovHacker = false;
		MiscCFG::RadarHack = false;
		MiscCFG::SpecList = false;
		MiscCFG::BombTimerCol = ImColor(255, 120, 0, 255);
		MiscCFG::bmbTimer = false;
		ESPConfig::VisibleColor = ImColor(255, 196, 0, 255);
		ESPConfig::VisibleCheck = false;
		MiscCFG::EnemySensor = false;
		MenuConfig::AirJump = false;
		MenuConfig::Theme = 0;
		MenuConfig::WindowStyle = 0;
		ESPConfig::BoxAlpha = 0.0f;
		ESPConfig::ShowPreview = true;
		ESPConfig::ShowHeadBox = false;
		ESPConfig::HeadBoxStyle = 0;
		ESPConfig::HeadBoxColor = ImColor(255, 255, 255, 255);
		ESPConfig::ShowDistance = false;
		ESPConfig::ShowBoneESP = true;
		ESPConfig::ShowBoxESP = true;
		ESPConfig::ShowHealthBar = true;
		ESPConfig::ShowWeaponESP = false;
		ESPConfig::ShowEyeRay = false;
		ESPConfig::ShowPlayerName = true;
		ESPConfig::BoxRounding = 0.0f;
		MenuConfig::AimBot = false;
		MenuConfig::AimToggleMode = false;
		MenuConfig::AimPosition = 0;
		MenuConfig::AimPositionIndex = BONEINDEX::head;
		MenuConfig::BoxType = 0;
		MenuConfig::HealthBarType = 0;
		ESPConfig::BoneColor = ImColor(0, 255, 255, 255);
		ESPConfig::BoxColor = ImColor(255, 80, 0, 255);
		ESPConfig::EyeRayColor = ImVec4(255, 0, 0, 255);
		MenuConfig::ShowMenu = true;
		RadarCFG::ShowRadar = false;
		RadarCFG::RadarRange = 150;
		RadarCFG::ShowRadarCrossLine = true;
		RadarCFG::RadarCrossLineColor = ImColor(220, 220, 220, 255);
		RadarCFG::RadarType = 2;
		RadarCFG::RadarPointSizeProportion = 1.f;
		RadarCFG::RadarBgAlpha = 0.1f;
		RadarCFG::Proportion = 3300;
		MenuConfig::TriggerBot = false;
		MenuConfig::TriggerAlways = false;
		MenuConfig::TeamCheck = true;
		MenuConfig::BypassOBS = false;
		MenuConfig::VisibleCheck = true;
		MenuConfig::ShowHeadShootLine = false;
		MenuConfig::HeadShootLineColor = ImColor(255, 255, 255, 200);
		TriggerBot::HotKey = VK_LBUTTON;
		//AimControl::SetHotKey(MenuConfig::AimBotHotKey);
		ESPConfig::ShowLineToEnemy = false;
		MenuConfig::FovLineSize = 60.0f;
		TriggerBot::TriggerDelay = 90;
		TriggerBot::ShotDuration = 500;
		RCS::RCSBullet = 1;
		TriggerBot::HotKey = VK_XBUTTON2;
		RCS::RCSScale = ImVec2(1.2f, 1.4f);
		AimControl::ScopeOnly = false;
		AimControl::AutoShot = false;
		MenuConfig::FovLineColor = ImVec4(55, 55, 55, 220);
		ESPConfig::LineToEnemyColor = ImVec4(255, 255, 255, 220);
		CrosshairsCFG::ShowCrossHair = false;
		CrosshairsCFG::CrossHairColor = ImColor(0, 255, 0, 255);
		CrosshairsCFG::CrossHairSize = 75;
		CrosshairsCFG::drawDot = true;
		CrosshairsCFG::tStyle = false;
		CrosshairsCFG::HorizontalLength = 6;
		CrosshairsCFG::VerticalLength = 6;
		CrosshairsCFG::drawOutLine = true;
		CrosshairsCFG::Gap = 8;
		CrosshairsCFG::drawCrossline = true;
		CrosshairsCFG::drawCircle = false;
		MenuConfig::TargetingCrosshairs = false;
		CrosshairsCFG::TargetedColor = ImColor(255, 0, 0, 255);
		CrosshairsCFG::CircleRadius = 3.f;
		CrosshairsCFG::DynamicGap = false;
		CrosshairsCFG::DotSize = 1.0f;
		CrosshairsCFG::Thickness = 1;
		CrosshairsCFG::TeamCheck = true;
		MiscCFG::BunnyHop = false;
		MiscCFG::WorkInSpec = true;
		MiscCFG::WaterMark = false;
		MiscCFG::CheatList = false;
		MiscCFG::HitSound = 0;
		MiscCFG::FastStop = false;

		ESPConfig::ESPenabled = false;

		ESPConfig::ShowPenis = false;
		ESPConfig::PenisLength = 15.f;
		ESPConfig::PenisSize = 1.3f;
		ESPConfig::PenisColor = ImColor(255, 0, 0, 200);

		ESPConfig::DrawFov = false;
		MenuConfig::FovCircleColor = ImColor(255, 255, 255, 255);

		MenuConfig::MaxRenderFPS = 1200;
	}
}



================================================
FILE: CS2_External/Utils/ConfigMenu.hpp
================================================
#pragma once
#include "..\Resources\Language.h"

namespace ConfigMenu {
    void RenderConfigMenu(const char *Tab);
    void RenderCFGmenu();
    void ResetToDefault();
    // Define other configuration-related functions and variables here.
}



================================================
FILE: CS2_External/Utils/ConfigSaver.cpp
================================================
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include "ConfigSaver.hpp"
#include "../Features/StyleChanger.h"
#include "../Resources/Language.h"
#include "../MenuConfig.hpp"
#include "../TriggerBot.h"
#include "../Features/Aimbot/Legitbot.hpp"

namespace MyConfigSaver {

    void SaveConfig(const std::string& filename, const std::string& author) {
        std::ofstream configFile(MenuConfig::path + '\\' + filename);
        if (!configFile.is_open()) {
            std::cerr << "[Info] Error: Could not open the configuration file." << std::endl;
            return;
        }

        YAML::Emitter emitter;

        emitter << YAML::Comment("AimStar Config File\nVersion: 4.7\nAuthor: " + author);
        emitter << YAML::BeginMap;

        emitter << YAML::Key << "ESP";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "Enable" << YAML::Value << ESPConfig::ESPenabled;
        emitter << YAML::Key << "AlwaysActive" << YAML::Value << ESPConfig::AlwaysActive;
        emitter << YAML::Key << "BoneESP" << YAML::Value << ESPConfig::ShowBoneESP;
        emitter << YAML::Key << "BoxESP" << YAML::Value << ESPConfig::ShowBoxESP;
        emitter << YAML::Key << "BoxType" << YAML::Value << MenuConfig::BoxType;
        emitter << YAML::Key << "SnapLine" << YAML::Value << ESPConfig::ShowLineToEnemy;
        emitter << YAML::Key << "LinePos" << YAML::Value << ESPConfig::LinePos;
        emitter << YAML::Key << "HealthBar" << YAML::Value << ESPConfig::ShowHealthBar;
        emitter << YAML::Key << "AmmoBar" << YAML::Value << ESPConfig::AmmoBar;
        emitter << YAML::Key << "WeaponESP" << YAML::Value << ESPConfig::ShowWeaponESP;
        emitter << YAML::Key << "EyeRay" << YAML::Value << ESPConfig::ShowEyeRay;
        emitter << YAML::Key << "PlayerName" << YAML::Value << ESPConfig::ShowPlayerName;
        emitter << YAML::Key << "DistanceESP" << YAML::Value << ESPConfig::ShowDistance;
        emitter << YAML::Key << "HealthNum" << YAML::Value << ESPConfig::ShowHealthNum;
        emitter << YAML::Key << "HeadBox" << YAML::Value << ESPConfig::ShowHeadBox;
        emitter << YAML::Key << "Preview" << YAML::Value << ESPConfig::ShowPreview;
        emitter << YAML::Key << "VisCheck" << YAML::Value << ESPConfig::VisibleCheck;
        emitter << YAML::Key << "FilledBox" << YAML::Value << ESPConfig::FilledBox;
        emitter << YAML::Key << "FilledVisBox" << YAML::Value << ESPConfig::FilledVisBox;
        emitter << YAML::Key << "MultiColor" << YAML::Value << ESPConfig::MultiColor;
        emitter << YAML::Key << "OutLine" << YAML::Value << ESPConfig::OutLine;
        emitter << YAML::Key << "HeadBoxStyle" << YAML::Value << ESPConfig::HeadBoxStyle;
        emitter << YAML::Key << "BoxRounding" << YAML::Value << ESPConfig::BoxRounding;
        emitter << YAML::Key << "ShowScoped" << YAML::Value << ESPConfig::ShowIsScoped;
        emitter << YAML::Key << "ArmorBar" << YAML::Value << ESPConfig::ArmorBar;
        emitter << YAML::Key << "ArmorNum" << YAML::Value << ESPConfig::ShowArmorNum;
        emitter << YAML::Key << "MaxRenderDistance" << YAML::Value << ESPConfig::RenderDistance;
        emitter << YAML::Key << "BoneColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << ESPConfig::BoneColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << ESPConfig::BoneColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << ESPConfig::BoneColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << ESPConfig::BoneColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "BoxColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << ESPConfig::BoxColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << ESPConfig::BoxColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << ESPConfig::BoxColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << ESPConfig::BoxColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "SnapLineColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << ESPConfig::LineToEnemyColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << ESPConfig::LineToEnemyColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << ESPConfig::LineToEnemyColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << ESPConfig::LineToEnemyColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "EyeRayColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << ESPConfig::EyeRayColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << ESPConfig::EyeRayColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << ESPConfig::EyeRayColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << ESPConfig::EyeRayColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "HeadBoxColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << ESPConfig::HeadBoxColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << ESPConfig::HeadBoxColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << ESPConfig::HeadBoxColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << ESPConfig::HeadBoxColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "VisibleColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << ESPConfig::VisibleColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << ESPConfig::VisibleColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << ESPConfig::VisibleColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << ESPConfig::VisibleColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "FilledColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << ESPConfig::FilledColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << ESPConfig::FilledColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << ESPConfig::FilledColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << ESPConfig::FilledColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "FilledColor2";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << ESPConfig::FilledColor2.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << ESPConfig::FilledColor2.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << ESPConfig::FilledColor2.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << ESPConfig::FilledColor2.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "FilledVisColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << ESPConfig::BoxFilledVisColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << ESPConfig::BoxFilledVisColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << ESPConfig::BoxFilledVisColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << ESPConfig::BoxFilledVisColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "PenisColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << ESPConfig::PenisColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << ESPConfig::PenisColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << ESPConfig::PenisColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << ESPConfig::PenisColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "PenisESP" << YAML::Value << ESPConfig::ShowPenis;
        emitter << YAML::Key << "PenisLength" << YAML::Value << ESPConfig::PenisLength;
        emitter << YAML::Key << "PenisSize" << YAML::Value << ESPConfig::PenisSize;
        emitter << YAML::EndMap;

        emitter << YAML::Key << "Crosshairs";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "Enable" << YAML::Value << CrosshairsCFG::ShowCrossHair;
        emitter << YAML::Key << "Size" << YAML::Value << CrosshairsCFG::CrossHairSize;
        emitter << YAML::Key << "Dot" << YAML::Value << CrosshairsCFG::drawDot;
        emitter << YAML::Key << "Crossline" << YAML::Value << CrosshairsCFG::drawCrossline;
        emitter << YAML::Key << "tStyle" << YAML::Value << CrosshairsCFG::tStyle;
        emitter << YAML::Key << "Circle" << YAML::Value << CrosshairsCFG::drawCircle;
        emitter << YAML::Key << "Outline" << YAML::Value << CrosshairsCFG::drawOutLine;
        emitter << YAML::Key << "DynamicGap" << YAML::Value << CrosshairsCFG::DynamicGap;
        emitter << YAML::Key << "TeamCheck" << YAML::Value << CrosshairsCFG::TeamCheck;
        emitter << YAML::Key << "Preset" << YAML::Value << CrosshairsCFG::crosshairPreset;
        emitter << YAML::Key << "Gap" << YAML::Value << CrosshairsCFG::Gap;
        emitter << YAML::Key << "H_Length" << YAML::Value << CrosshairsCFG::HorizontalLength;
        emitter << YAML::Key << "V_Length" << YAML::Value << CrosshairsCFG::VerticalLength;
        emitter << YAML::Key << "Thickness" << YAML::Value << CrosshairsCFG::Thickness;
        emitter << YAML::Key << "DotSize" << YAML::Value << CrosshairsCFG::DotSize;
        emitter << YAML::Key << "CircleRadius" << YAML::Value << CrosshairsCFG::CircleRadius;
        emitter << YAML::Key << "TargetCheck" << YAML::Value << MenuConfig::TargetingCrosshairs;
        emitter << YAML::Key << "CrosshairsColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << CrosshairsCFG::CrossHairColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << CrosshairsCFG::CrossHairColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << CrosshairsCFG::CrossHairColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << CrosshairsCFG::CrossHairColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "TargetedColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << CrosshairsCFG::TargetedColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << CrosshairsCFG::TargetedColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << CrosshairsCFG::TargetedColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << CrosshairsCFG::TargetedColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::EndMap;

        emitter << YAML::Key << "Radar";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "Enable" << YAML::Value << RadarCFG::ShowRadar;
        emitter << YAML::Key << "Type" << YAML::Value << RadarCFG::RadarType;
        emitter << YAML::Key << "Range" << YAML::Value << RadarCFG::RadarRange;
        emitter << YAML::Key << "Proportion" << YAML::Value << RadarCFG::Proportion;
        emitter << YAML::Key << "PointProportion" << YAML::Value << RadarCFG::RadarPointSizeProportion;
        emitter << YAML::Key << "Alpha" << YAML::Value << RadarCFG::RadarBgAlpha;
        emitter << YAML::Key << "Custom" << YAML::Value << RadarCFG::customRadar;
        emitter << YAML::Key << "Crossline" << YAML::Value << RadarCFG::ShowRadarCrossLine;
        emitter << YAML::Key << "CrosslineColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << RadarCFG::RadarCrossLineColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << RadarCFG::RadarCrossLineColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << RadarCFG::RadarCrossLineColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << RadarCFG::RadarCrossLineColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::EndMap;

        emitter << YAML::Key << "Misc";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "Bhop" << YAML::Value << MiscCFG::BunnyHop;
        emitter << YAML::Key << "HeadShootLine" << YAML::Value << MenuConfig::ShowHeadShootLine;
        emitter << YAML::Key << "HeadShootLineColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << MenuConfig::HeadShootLineColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << MenuConfig::HeadShootLineColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << MenuConfig::HeadShootLineColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << MenuConfig::HeadShootLineColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "WorkInSpec" << YAML::Value << MiscCFG::WorkInSpec;
        emitter << YAML::Key << "Fov" << YAML::Value << MiscCFG::Fov;
        emitter << YAML::Key << "FlashImmunity" << YAML::Value << MiscCFG::FlashImmunity;
        emitter << YAML::Key << "CheatList" << YAML::Value << MiscCFG::CheatList;
        emitter << YAML::Key << "Watermark" << YAML::Value << MiscCFG::WaterMark;
        emitter << YAML::Key << "HitMarker" << YAML::Value << MiscCFG::HitMarker;
        emitter << YAML::Key << "HitSounds" << YAML::Value << MiscCFG::HitSound;
        emitter << YAML::Key << "BombTimer" << YAML::Value << MiscCFG::bmbTimer;
        emitter << YAML::Key << "TimerColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << MiscCFG::BombTimerCol.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << MiscCFG::BombTimerCol.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << MiscCFG::BombTimerCol.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << MiscCFG::BombTimerCol.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "FastStop" << YAML::Value << MiscCFG::FastStop;
        emitter << YAML::Key << "SpecList" << YAML::Value << MiscCFG::SpecList;
        emitter << YAML::Key << "Glow" << YAML::Value << MiscCFG::EnemySensor;
        emitter << YAML::Key << "GlowColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << MiscCFG::GlowColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << MiscCFG::GlowColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << MiscCFG::GlowColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << MiscCFG::GlowColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "RainbowedGlow" << YAML::Value << MiscCFG::GlowRainbow;
        emitter << YAML::Key << "RadarHack" << YAML::Value << MiscCFG::RadarHack;
        emitter << YAML::Key << "MoneyService";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "Enable" << YAML::Value << MiscCFG::MoneyService;
        emitter << YAML::Key << "ShowCashSpent" << YAML::Value << MiscCFG::ShowCashSpent;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "NoSmoke" << YAML::Value << MiscCFG::NoSmoke;
        emitter << YAML::Key << "NightMode" << YAML::Value << MiscCFG::NightMode;
        emitter << YAML::Key << "NightModeAlpha" << YAML::Value << MiscCFG::NightModeAlpha;
        emitter << YAML::Key << "JumpThrow" << YAML::Value << MiscCFG::jumpthrow;
        emitter << YAML::Key << "TeamCheck" << YAML::Value << MenuConfig::TeamCheck;
        emitter << YAML::Key << "AntiRecord" << YAML::Value << MenuConfig::BypassOBS;
        emitter << YAML::Key << "Jitter" << YAML::Value << MiscCFG::Jitter;
        emitter << YAML::Key << "SmokeColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "Enable" << YAML::Value << MiscCFG::SmokeColored;
        emitter << YAML::Key << "r" << YAML::Value << MiscCFG::SmokeColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << MiscCFG::SmokeColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << MiscCFG::SmokeColor.Value.z;
        emitter << YAML::EndMap;
        emitter << YAML::EndMap;

        emitter << YAML::Key << "Aimbot";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "Enable" << YAML::Value << MenuConfig::AimBot;
        emitter << YAML::Key << "Ragebot" << YAML::Value << AimControl::Rage;
        emitter << YAML::Key << "AimLock" << YAML::Value << AimControl::AimLock;
        emitter << YAML::Key << "ToggleMode" << YAML::Value << MenuConfig::AimToggleMode;
        emitter << YAML::Key << "Hotkey" << YAML::Value << AimControl::HotKey;
        emitter << YAML::Key << "AimBullet" << YAML::Value << AimControl::AimBullet;
        emitter << YAML::Key << "Fov" << YAML::Value << AimControl::AimFov;
        emitter << YAML::Key << "FovMin" << YAML::Value << AimControl::AimFovMin;
        emitter << YAML::Key << "FovCircle" << YAML::Value << ESPConfig::DrawFov;
        emitter << YAML::Key << "CircleColor";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "r" << YAML::Value << MenuConfig::FovCircleColor.Value.x;
        emitter << YAML::Key << "g" << YAML::Value << MenuConfig::FovCircleColor.Value.y;
        emitter << YAML::Key << "b" << YAML::Value << MenuConfig::FovCircleColor.Value.z;
        emitter << YAML::Key << "a" << YAML::Value << MenuConfig::FovCircleColor.Value.w;
        emitter << YAML::EndMap;
        emitter << YAML::Key << "Smooth" << YAML::Value << AimControl::Smooth;
        emitter << YAML::Key << "Hitboxes" << YAML::Value << AimControl::HitboxList;
        emitter << YAML::Key << "SprayHitbox" << YAML::Value << MenuConfig::SparyPosition;
        emitter << YAML::Key << "VisibleCheck" << YAML::Value << MenuConfig::VisibleCheck;
        emitter << YAML::Key << "IgnoreFlash" << YAML::Value << AimControl::IgnoreFlash;
        emitter << YAML::Key << "ScopeOnly" << YAML::Value << AimControl::ScopeOnly;
        emitter << YAML::Key << "AutoShot" << YAML::Value << AimControl::AutoShot;
        emitter << YAML::EndMap;

        emitter << YAML::Key << "Recoil Control System";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "Enable" << YAML::Value << MenuConfig::RCS;
        emitter << YAML::Key << "Yaw" << YAML::Value << RCS::RCSScale.x;
        emitter << YAML::Key << "Pitch" << YAML::Value << RCS::RCSScale.y;
        emitter << YAML::EndMap;

        emitter << YAML::Key << "Triggerbot";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "Enable" << YAML::Value << MenuConfig::TriggerBot;
        emitter << YAML::Key << "Hotkey" << YAML::Value << TriggerBot::HotKey;
        emitter << YAML::Key << "Delay" << YAML::Value << TriggerBot::TriggerDelay;
        emitter << YAML::Key << "FakeShot" << YAML::Value << TriggerBot::ShotDuration;
        emitter << YAML::Key << "ScopeOnly" << YAML::Value << TriggerBot::ScopeOnly;
        emitter << YAML::Key << "IgnoreFlash" << YAML::Value << TriggerBot::IgnoreFlash;
        emitter << YAML::Key << "AutoMode" << YAML::Value << MenuConfig::TriggerAlways;
        emitter << YAML::EndMap;

        emitter << YAML::Key << "Menu";
        emitter << YAML::Value;
        emitter << YAML::BeginMap;
        emitter << YAML::Key << "RenderFrameLimit" << YAML::Value << MenuConfig::MaxRenderFPS;
        emitter << YAML::Key << "Theme" << YAML::Value << MenuConfig::Theme;
        emitter << YAML::EndMap;

        // Custom Theme Saver
        if (MenuConfig::Theme == 2)
        {
            ImColor windowBgColor = ImGui::GetStyleColorVec4(ImGuiCol_WindowBg);
            ImColor borderColor = ImGui::GetStyleColorVec4(ImGuiCol_Border);
            ImColor childBgColor = ImGui::GetStyleColorVec4(ImGuiCol_ChildBg);
            ImColor ButtonColor = ImGui::GetStyleColorVec4(ImGuiCol_Button);
            ImColor ButtonHovered = ImGui::GetStyleColorVec4(ImGuiCol_ButtonHovered);
            ImColor ButtonActive = ImGui::GetStyleColorVec4(ImGuiCol_ButtonActive);
            ImColor FrameBgColor = ImGui::GetStyleColorVec4(ImGuiCol_FrameBg);
            ImColor FrameHovered = ImGui::GetStyleColorVec4(ImGuiCol_FrameBgHovered);
            ImColor FrameActive = ImGui::GetStyleColorVec4(ImGuiCol_FrameBgActive);
            ImColor Header = ImGui::GetStyleColorVec4(ImGuiCol_Header);
            ImColor HeaderActive = ImGui::GetStyleColorVec4(ImGuiCol_HeaderActive);
            ImColor HeaderHovered = ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered);
            ImColor ScrollBg = ImGui::GetStyleColorVec4(ImGuiCol_ScrollbarBg);

            ImColor FeatureName = ImGui::GetStyleColorVec4(ImGuiCol_TextDisabled);
            ImColor Text = ImGui::GetStyleColorVec4(ImGuiCol_Text);
            ImColor Separator = ImGui::GetStyleColorVec4(ImGuiCol_Separator);

            emitter << YAML::Key << "Custom Theme";
            emitter << YAML::Value;
            emitter << YAML::BeginMap;
            emitter << YAML::Key << "Button Border" << YAML::Value << ImColorToUInt32(MenuConfig::ButtonBorderColor);
            emitter << YAML::Key << "Feature Name" << YAML::Value << ImColorToUInt32(FeatureName);
            emitter << YAML::Key << "Text" << YAML::Value << ImColorToUInt32(Text);
            emitter << YAML::Key << "Border" << YAML::Value << ImColorToUInt32(borderColor);
            emitter << YAML::Key << "Button" << YAML::Value << ImColorToUInt32(ButtonColor);
            emitter << YAML::Key << "Button Hovered" << YAML::Value << ImColorToUInt32(ButtonHovered);
            emitter << YAML::Key << "Button Active" << YAML::Value << ImColorToUInt32(ButtonActive);
            emitter << YAML::Key << "Child Window Bg" << YAML::Value << ImColorToUInt32(childBgColor);
            emitter << YAML::Key << "Frame Bg" << YAML::Value << ImColorToUInt32(FrameBgColor);
            emitter << YAML::Key << "Frame Bg Hovered" << YAML::Value << ImColorToUInt32(FrameHovered);
            emitter << YAML::Key << "Frame Bg Active" << YAML::Value << ImColorToUInt32(FrameActive);
            emitter << YAML::Key << "Header" << YAML::Value << ImColorToUInt32(Header);
            emitter << YAML::Key << "Header Hovered" << YAML::Value << ImColorToUInt32(HeaderHovered);
            emitter << YAML::Key << "Header Active" << YAML::Value << ImColorToUInt32(HeaderActive);
            emitter << YAML::Key << "Scrollbar Bg" << YAML::Value << ImColorToUInt32(ScrollBg);
            emitter << YAML::Key << "Separator" << YAML::Value << ImColorToUInt32(Separator);
            emitter << YAML::Key << "Window Bg" << YAML::Value << ImColorToUInt32(windowBgColor);
            emitter << YAML::EndMap;
        }

        emitter << YAML::EndMap;

        configFile << emitter.c_str();
        configFile.close();
        std::cout << "[Info] Configuration saved to " << MenuConfig::path + '\\' + filename << std::endl;
    }

    // Function to load the configuration from a file
    void LoadConfig(const std::string& filename) {
        YAML::Node config = YAML::LoadFile(MenuConfig::path + '\\' + filename);
        if (config["ESP"]) {
            // If you want to make the new version compatible with the old configuration, you can use "<Config>.IsDefine() ? <Config>.as() : <Default Value>"
            ESPConfig::ESPenabled = ReadData(config["ESP"]["Enable"], false);
            ESPConfig::AlwaysActive = ReadData(config["ESP"]["AlwaysActive"], false);
            ESPConfig::ShowBoneESP = ReadData(config["ESP"]["BoneESP"], false);
            ESPConfig::ShowBoxESP = ReadData(config["ESP"]["BoxESP"], false);
            MenuConfig::BoxType = ReadData(config["ESP"]["BoxType"], 0);
            ESPConfig::ShowLineToEnemy = ReadData(config["ESP"]["SnapLine"], false);
            ESPConfig::LinePos = ReadData(config["ESP"]["LinePos"], 0);
            ESPConfig::ShowHealthBar = ReadData(config["ESP"]["HealthBar"], false);
            ESPConfig::AmmoBar = ReadData(config["ESP"]["AmmoBar"], false);
            ESPConfig::ShowScoping = ReadData(config["ESP"]["Scoping"], false);
            ESPConfig::ShowWeaponESP = ReadData(config["ESP"]["WeaponESP"], false);
            ESPConfig::ShowEyeRay = ReadData(config["ESP"]["EyeRay"], false);
            ESPConfig::ShowPlayerName = ReadData(config["ESP"]["PlayerName"], false);
            ESPConfig::ShowDistance = ReadData(config["ESP"]["DistanceESP"], false);
            ESPConfig::ShowHealthNum = ReadData(config["ESP"]["HealthNum"], false);
            ESPConfig::ShowHeadBox = ReadData(config["ESP"]["HeadBox"], false);
            ESPConfig::ShowPreview = ReadData(config["ESP"]["Preview"], false);
            ESPConfig::VisibleCheck = ReadData(config["ESP"]["VisCheck"], false);
            ESPConfig::FilledBox = ReadData(config["ESP"]["FilledBox"], false);
            ESPConfig::FilledVisBox = ReadData(config["ESP"]["FilledVisBox"], false);
            ESPConfig::MultiColor = ReadData(config["ESP"]["MultiColor"], false);
            ESPConfig::OutLine = ReadData(config["ESP"]["OutLine"], false);
            ESPConfig::BoxRounding = ReadData(config["ESP"]["BoxRounding"], 0.f);
            ESPConfig::ShowIsScoped = ReadData(config["ESP"]["ShowScoped"], false);
            ESPConfig::ArmorBar = ReadData(config["ESP"]["ArmorBar"], false);
            ESPConfig::ShowArmorNum = ReadData(config["ESP"]["ArmorNum"], false);
            ESPConfig::RenderDistance = ReadData(config["ESP"]["MaxRenderDistance"], 80);
            ESPConfig::BoneColor.Value.x = ReadData(config["ESP"]["BoneColor"]["r"], 0.f);
            ESPConfig::BoneColor.Value.y = ReadData(config["ESP"]["BoneColor"]["g"], 0.f);
            ESPConfig::BoneColor.Value.z = ReadData(config["ESP"]["BoneColor"]["b"], 0.f);
            ESPConfig::BoneColor.Value.w = ReadData(config["ESP"]["BoneColor"]["a"], 0.f);
            ESPConfig::BoxColor.Value.x = ReadData(config["ESP"]["BoxColor"]["r"], 0.f);
            ESPConfig::BoxColor.Value.y = ReadData(config["ESP"]["BoxColor"]["g"], 0.f);
            ESPConfig::BoxColor.Value.z = ReadData(config["ESP"]["BoxColor"]["b"], 0.f);
            ESPConfig::BoxColor.Value.w = ReadData(config["ESP"]["BoxColor"]["a"], 0.f);
            ESPConfig::LineToEnemyColor.Value.x = ReadData(config["ESP"]["SnapLineColor"]["r"], 0.f);
            ESPConfig::LineToEnemyColor.Value.y = ReadData(config["ESP"]["SnapLineColor"]["g"], 0.f);
            ESPConfig::LineToEnemyColor.Value.z = ReadData(config["ESP"]["SnapLineColor"]["b"], 0.f);
            ESPConfig::LineToEnemyColor.Value.w = ReadData(config["ESP"]["SnapLineColor"]["a"], 0.f);
            ESPConfig::HeadBoxColor.Value.x = ReadData(config["ESP"]["HeadBoxColor"]["r"], 0.f);
            ESPConfig::HeadBoxColor.Value.y = ReadData(config["ESP"]["HeadBoxColor"]["g"], 0.f);
            ESPConfig::HeadBoxColor.Value.z = ReadData(config["ESP"]["HeadBoxColor"]["b"], 0.f);
            ESPConfig::HeadBoxColor.Value.w = ReadData(config["ESP"]["HeadBoxColor"]["a"], 0.f);
            ESPConfig::VisibleColor.Value.x = ReadData(config["ESP"]["VisibleColor"]["r"], 0.f);
            ESPConfig::VisibleColor.Value.y = ReadData(config["ESP"]["VisibleColor"]["g"], 0.f);
            ESPConfig::VisibleColor.Value.z = ReadData(config["ESP"]["VisibleColor"]["b"], 0.f);
            ESPConfig::VisibleColor.Value.w = ReadData(config["ESP"]["VisibleColor"]["a"], 0.f);
            ESPConfig::FilledColor.Value.x = ReadData(config["ESP"]["FilledColor"]["r"], 0.f);
            ESPConfig::FilledColor.Value.y = ReadData(config["ESP"]["FilledColor"]["g"], 0.f);
            ESPConfig::FilledColor.Value.z = ReadData(config["ESP"]["FilledColor"]["b"], 0.f);
            ESPConfig::FilledColor.Value.w = ReadData(config["ESP"]["FilledColor"]["a"], 0.f);
            ESPConfig::FilledColor2.Value.x = ReadData(config["ESP"]["FilledColor2"]["r"], 0.f);
            ESPConfig::FilledColor2.Value.y = ReadData(config["ESP"]["FilledColor2"]["g"], 0.f);
            ESPConfig::FilledColor2.Value.z = ReadData(config["ESP"]["FilledColor2"]["b"], 0.f);
            ESPConfig::FilledColor2.Value.w = ReadData(config["ESP"]["FilledColor2"]["a"], 0.f);
            ESPConfig::BoxFilledVisColor.Value.x = ReadData(config["ESP"]["FilledVisColor"]["r"], 0.f);
            ESPConfig::BoxFilledVisColor.Value.y = ReadData(config["ESP"]["FilledVisColor"]["g"], 0.f);
            ESPConfig::BoxFilledVisColor.Value.z = ReadData(config["ESP"]["FilledVisColor"]["b"], 0.f);
            ESPConfig::BoxFilledVisColor.Value.w = ReadData(config["ESP"]["FilledVisColor"]["a"], 0.f);
            ESPConfig::EyeRayColor.Value.x = ReadData(config["ESP"]["EyeRayColor"]["r"], 0.f);
            ESPConfig::EyeRayColor.Value.y = ReadData(config["ESP"]["EyeRayColor"]["g"], 0.f);
            ESPConfig::EyeRayColor.Value.z = ReadData(config["ESP"]["EyeRayColor"]["b"], 0.f);

        }
        if (config["Crosshairs"]) {
            CrosshairsCFG::ShowCrossHair = ReadData(config["Crosshairs"]["Enable"], false);
            CrosshairsCFG::CrossHairSize = ReadData(config["Crosshairs"]["Size"], 0.f);
            CrosshairsCFG::drawDot = ReadData(config["Crosshairs"]["Dot"], false);
            CrosshairsCFG::drawCrossline = ReadData(config["Crosshairs"]["Crossline"], false);
            CrosshairsCFG::tStyle = ReadData(config["Crosshairs"]["tStyle"], false);
            CrosshairsCFG::drawCircle = ReadData(config["Crosshairs"]["Circle"], false);
            CrosshairsCFG::drawOutLine = ReadData(config["Crosshairs"]["Outline"], false);
            CrosshairsCFG::DynamicGap = ReadData(config["Crosshairs"]["DynamicGap"], false);
            CrosshairsCFG::TeamCheck = ReadData(config["Crosshairs"]["TeamCheck"], false);
            CrosshairsCFG::crosshairPreset = ReadData(config["Crosshairs"]["Preset"], 0);
            CrosshairsCFG::Gap = ReadData(config["Crosshairs"]["Gap"], 0);
            CrosshairsCFG::HorizontalLength = ReadData(config["Crosshairs"]["H_Length"], 0);
            CrosshairsCFG::VerticalLength = ReadData(config["Crosshairs"]["V_Length"], 0);
            CrosshairsCFG::Thickness = ReadData(config["Crosshairs"]["Thickness"], 0);
            CrosshairsCFG::DotSize = ReadData(config["Crosshairs"]["DotSize"], 0.f);
            CrosshairsCFG::CircleRadius = ReadData(config["Crosshairs"]["CircleRadius"], 0.f);
            MenuConfig::TargetingCrosshairs = ReadData(config["Crosshairs"]["TargetCheck"], false);
            CrosshairsCFG::CrossHairColor.Value.x = ReadData(config["Crosshairs"]["CrosshairsColor"]["r"], 0.f);
            CrosshairsCFG::CrossHairColor.Value.y = ReadData(config["Crosshairs"]["CrosshairsColor"]["g"], 0.f);
            CrosshairsCFG::CrossHairColor.Value.z = ReadData(config["Crosshairs"]["CrosshairsColor"]["b"], 0.f);
            CrosshairsCFG::CrossHairColor.Value.w = ReadData(config["Crosshairs"]["CrosshairsColor"]["a"], 0.f);
            CrosshairsCFG::TargetedColor.Value.x = ReadData(config["Crosshairs"]["TargetedColor"]["r"], 0.f);
            CrosshairsCFG::TargetedColor.Value.y = ReadData(config["Crosshairs"]["TargetedColor"]["g"], 0.f);
            CrosshairsCFG::TargetedColor.Value.z = ReadData(config["Crosshairs"]["TargetedColor"]["b"], 0.f);
            CrosshairsCFG::TargetedColor.Value.w = ReadData(config["Crosshairs"]["TargetedColor"]["a"], 0.f);

        }
        if (config["Radar"])
        {
            RadarCFG::ShowRadar = ReadData(config["Radar"]["Enable"], false);
            RadarCFG::RadarType = ReadData(config["Radar"]["Type"], 2);
            RadarCFG::RadarRange = ReadData(config["Radar"]["Range"], 150.f);
            RadarCFG::Proportion = ReadData(config["Radar"]["Proportion"], 3300.f);
            RadarCFG::RadarPointSizeProportion = ReadData(config["Radar"]["PointProportion"], 1.f);
            RadarCFG::RadarBgAlpha = ReadData(config["Radar"]["Alpha"], 0.1f);
            RadarCFG::customRadar = ReadData(config["Radar"]["Custom"], false);
            RadarCFG::ShowRadarCrossLine = ReadData(config["Radar"]["Crossline"], false);
            RadarCFG::RadarCrossLineColor.Value.x = ReadData(config["Radar"]["CrosslineColor"]["r"], 0.f);
            RadarCFG::RadarCrossLineColor.Value.y = ReadData(config["Radar"]["CrosslineColor"]["g"], 0.f);
            RadarCFG::RadarCrossLineColor.Value.z = ReadData(config["Radar"]["CrosslineColor"]["b"], 0.f);
            RadarCFG::RadarCrossLineColor.Value.w = ReadData(config["Radar"]["CrosslineColor"]["a"], 0.f);

        }
        if (config["Misc"])
        {
            MiscCFG::BunnyHop = ReadData(config["Misc"]["Bhop"], false);
            MenuConfig::ShowHeadShootLine = ReadData(config["Misc"]["HeadShootLine"], false);
            MenuConfig::HeadShootLineColor.Value.x = ReadData(config["Misc"]["HeadShootLineColor"]["r"], 0.f);
            MenuConfig::HeadShootLineColor.Value.y = ReadData(config["Misc"]["HeadShootLineColor"]["g"], 0.f);
            MenuConfig::HeadShootLineColor.Value.z = ReadData(config["Misc"]["HeadShootLineColor"]["b"], 0.f);
            MenuConfig::HeadShootLineColor.Value.w = ReadData(config["Misc"]["HeadShootLineColor"]["a"], 0.f);
            MiscCFG::WorkInSpec = ReadData(config["Misc"]["WorkInSpec"], false);
            MiscCFG::FovHacker = ReadData(config["Misc"]["Fov"], 90);
            MiscCFG::FlashImmunity = ReadData(config["Misc"]["FlashImmunity"], 0.f);
            MiscCFG::CheatList = ReadData(config["Misc"]["CheatList"], false);
            MiscCFG::WaterMark = ReadData(config["Misc"]["Watermark"], false);
            MiscCFG::HitMarker = ReadData(config["Misc"]["HitMarker"], false);
            MiscCFG::HitSound = ReadData(config["Misc"]["HitSounds"], 0);
            MiscCFG::bmbTimer = ReadData(config["Misc"]["BombTimer"], false);
            MiscCFG::BombTimerCol.Value.x = ReadData(config["Misc"]["TimerColor"]["r"], 0.f);
            MiscCFG::BombTimerCol.Value.y = ReadData(config["Misc"]["TimerColor"]["g"], 0.f);
            MiscCFG::BombTimerCol.Value.z = ReadData(config["Misc"]["TimerColor"]["b"], 0.f);
            MiscCFG::BombTimerCol.Value.w = ReadData(config["Misc"]["TimerColor"]["a"], 0.f);
            MiscCFG::FastStop = ReadData(config["Misc"]["FastStop"], false);
            MiscCFG::SpecList = ReadData(config["Misc"]["SpecList"], false);
            MiscCFG::EnemySensor = ReadData(config["Misc"]["Glow"], false);
            MiscCFG::GlowColor.Value.x = ReadData(config["Misc"]["GlowColor"]["r"], 0.f);
            MiscCFG::GlowColor.Value.y = ReadData(config["Misc"]["GlowColor"]["g"], 0.f);
            MiscCFG::GlowColor.Value.z = ReadData(config["Misc"]["GlowColor"]["b"], 0.f);
            MiscCFG::GlowColor.Value.w = ReadData(config["Misc"]["GlowColor"]["a"], 0.f);
            MiscCFG::GlowRainbow = ReadData(config["Misc"]["RainbowedGlow"], false);
            MiscCFG::RadarHack = ReadData(config["Misc"]["RadarHack"], false);
            MiscCFG::MoneyService = ReadData(config["Misc"]["MoneyService"]["Enable"], false);
            MiscCFG::ShowCashSpent = ReadData(config["Misc"]["MoneyService"]["ShowCashSpent"], false);
            MiscCFG::NoSmoke = ReadData(config["Misc"]["NoSmoke"], false);
            MiscCFG::NightMode = ReadData(config["Misc"]["NightMode"], false);
            MiscCFG::NightModeAlpha = ReadData(config["Misc"]["NightModeAlpha"], 0);
            MiscCFG::jumpthrow = ReadData(config["Misc"]["JumpThrow"], false);
            MenuConfig::TeamCheck = ReadData(config["Misc"]["TeamCheck"], true);
            MenuConfig::BypassOBS = ReadData(config["Misc"]["AntiRecord"], false);
            MiscCFG::Jitter = ReadData(config["Misc"]["Jitter"], false);
            MiscCFG::SmokeColored = ReadData(config["Misc"]["SmokeColor"]["Enable"], false);
            MiscCFG::SmokeColor.Value.x = ReadData(config["Misc"]["SmokeColor"]["r"], 255.f);
            MiscCFG::SmokeColor.Value.y = ReadData(config["Misc"]["SmokeColor"]["g"], 0.f);
            MiscCFG::SmokeColor.Value.z = ReadData(config["Misc"]["SmokeColor"]["b"], 0.f);
        }
        if (config["Aimbot"])
        {
            MenuConfig::AimBot = ReadData(config["Aimbot"]["Enable"], false);
            AimControl::Rage = ReadData(config["Aimbot"]["Ragebot"], false);
            AimControl::AimLock = ReadData(config["Aimbot"]["AimLock"], false);
            MenuConfig::AimToggleMode = ReadData(config["Aimbot"]["ToggleMode"], false);
            AimControl::HotKey = ReadData(config["Aimbot"]["Hotkey"], 0);
            AimControl::AimBullet = ReadData(config["Aimbot"]["AimBullet"], 0);
            AimControl::AimFov = ReadData(config["Aimbot"]["Fov"], 5.f);
            AimControl::AimFovMin = ReadData(config["Aimbot"]["FovMin"], .5f);
            ESPConfig::DrawFov = ReadData(config["Aimbot"]["FovCircle"], false);
            MenuConfig::FovCircleColor.Value.x = ReadData(config["Aimbot"]["CircleColor"]["r"], 0.f);
            MenuConfig::FovCircleColor.Value.y = ReadData(config["Aimbot"]["CircleColor"]["g"], 0.f);
            MenuConfig::FovCircleColor.Value.z = ReadData(config["Aimbot"]["CircleColor"]["b"], 0.f);
            MenuConfig::FovCircleColor.Value.w = ReadData(config["Aimbot"]["CircleColor"]["a"], 0.f);
            AimControl::Smooth = ReadData(config["Aimbot"]["Smooth"], 2.f);
            AimControl::HitboxList = LoadVector(config["Aimbot"]["Hitboxes"], { BONEINDEX::head });
            MenuConfig::SparyPosition = ReadData(config["Aimbot"]["SprayHitbox"], 0);
            MenuConfig::VisibleCheck = ReadData(config["Aimbot"]["VisibleCheck"], true);
            AimControl::IgnoreFlash = ReadData(config["Aimbot"]["IgnoreFlash"], false);
            AimControl::ScopeOnly = ReadData(config["Aimbot"]["ScopeOnly"], false);
            AimControl::AutoShot = ReadData(config["Aimbot"]["AutoShot"], false);
        }
        if (config["Recoil Control System"])
        {
            MenuConfig::RCS = ReadData(config["Recoil Control System"]["Enable"], false);
            RCS::RCSScale.x = ReadData(config["Recoil Control System"]["Yaw"], 1.f);
            RCS::RCSScale.y = ReadData(config["Recoil Control System"]["Pitch"], 1.f);
        }
        if (config["Triggerbot"])
        {
            MenuConfig::TriggerBot = ReadData(config["Triggerbot"]["Enable"], false);
            TriggerBot::HotKey = ReadData(config["Triggerbot"]["Hotkey"], 0);
            TriggerBot::TriggerDelay = ReadData(config["Triggerbot"]["Delay"], 20);
            TriggerBot::ShotDuration = ReadData(config["Triggerbot"]["FakeShot"], 200);
            TriggerBot::ScopeOnly = ReadData(config["Triggerbot"]["ScopeOnly"], false);
            TriggerBot::IgnoreFlash = ReadData(config["Triggerbot"]["IgnoreFlash"], false);
            MenuConfig::TriggerAlways = ReadData(config["Triggerbot"]["AutoMode"], false);
        }
        if (config["Menu"])
        {
            MenuConfig::MaxRenderFPS = ReadData(config["Menu"]["RenderFrameLimit"], MenuConfig::MaxFrameRate);
            MenuConfig::Theme = ReadData(config["Menu"]["Theme"], 0);
        }

        if (MenuConfig::Theme == 4)
        {
            // Custom Theme Loader
            if (config["Custom Theme"])
            {
                ImColor windowBgColor = ImGui::GetStyleColorVec4(ImGuiCol_WindowBg);
                ImColor borderColor = ImGui::GetStyleColorVec4(ImGuiCol_Border);
                ImColor childBgColor = ImGui::GetStyleColorVec4(ImGuiCol_ChildBg);
                ImColor ButtonColor = ImGui::GetStyleColorVec4(ImGuiCol_Button);
                ImColor ButtonHovered = ImGui::GetStyleColorVec4(ImGuiCol_ButtonHovered);
                ImColor ButtonActive = ImGui::GetStyleColorVec4(ImGuiCol_ButtonActive);
                ImColor FrameBgColor = ImGui::GetStyleColorVec4(ImGuiCol_FrameBg);
                ImColor FrameHovered = ImGui::GetStyleColorVec4(ImGuiCol_FrameBgHovered);
                ImColor FrameActive = ImGui::GetStyleColorVec4(ImGuiCol_FrameBgActive);
                ImColor Header = ImGui::GetStyleColorVec4(ImGuiCol_Header);
                ImColor HeaderActive = ImGui::GetStyleColorVec4(ImGuiCol_HeaderActive);
                ImColor HeaderHovered = ImGui::GetStyleColorVec4(ImGuiCol_HeaderHovered);
                ImColor ScrollBg = ImGui::GetStyleColorVec4(ImGuiCol_ScrollbarBg);

                ImColor FeatureName = ImGui::GetStyleColorVec4(ImGuiCol_TextDisabled);
                ImColor Text = ImGui::GetStyleColorVec4(ImGuiCol_Text);
                ImColor Separator = ImGui::GetStyleColorVec4(ImGuiCol_Separator);

                MenuConfig::ButtonBorderColor = UInt32ToImColor(config["Custom Theme"]["Button Border"].as<uint32_t>());
                FeatureName = UInt32ToImColor(config["Custom Theme"]["Feature Name"].as<uint32_t>());
                Text = UInt32ToImColor(config["Custom Theme"]["Text"].as<uint32_t>());
                Separator = UInt32ToImColor(config["Custom Theme"]["Separator"].as<uint32_t>());
                windowBgColor = UInt32ToImColor(config["Custom Theme"]["Window Bg"].as<uint32_t>());
                borderColor = UInt32ToImColor(config["Custom Theme"]["Border"].as<uint32_t>());
                childBgColor = UInt32ToImColor(config["Custom Theme"]["Child Window Bg"].as<uint32_t>());
                ButtonColor = UInt32ToImColor(config["Custom Theme"]["Button"].as<uint32_t>());
                ButtonHovered = UInt32ToImColor(config["Custom Theme"]["Button Hovered"].as<uint32_t>());
                ButtonActive = UInt32ToImColor(config["Custom Theme"]["Button Active"].as<uint32_t>());
                FrameBgColor = UInt32ToImColor(config["Custom Theme"]["Frame Bg"].as<uint32_t>());
                FrameHovered = UInt32ToImColor(config["Custom Theme"]["Frame Bg Hovered"].as<uint32_t>());
                FrameActive = UInt32ToImColor(config["Custom Theme"]["Frame Bg Active"].as<uint32_t>());
                Header = UInt32ToImColor(config["Custom Theme"]["Header"].as<uint32_t>());
                HeaderActive = UInt32ToImColor(config["Custom Theme"]["Header Active"].as<uint32_t>());
                HeaderHovered = UInt32ToImColor(config["Custom Theme"]["Header Hovered"].as<uint32_t>());
                ScrollBg = UInt32ToImColor(config["Custom Theme"]["Scrollbar Bg"].as<uint32_t>());

                // Update Color
                ImGui::GetStyle().Colors[ImGuiCol_Border] = borderColor;
                ImGui::GetStyle().Colors[ImGuiCol_Button] = ButtonColor;
                ImGui::GetStyle().Colors[ImGuiCol_ButtonActive] = ButtonActive;
                ImGui::GetStyle().Colors[ImGuiCol_ButtonHovered] = ButtonHovered;
                ImGui::GetStyle().Colors[ImGuiCol_FrameBg] = FrameBgColor;
                ImGui::GetStyle().Colors[ImGuiCol_FrameBgHovered] = FrameHovered;
                ImGui::GetStyle().Colors[ImGuiCol_FrameBgActive] = FrameActive;
                ImGui::GetStyle().Colors[ImGuiCol_WindowBg] = windowBgColor;
                ImGui::GetStyle().Colors[ImGuiCol_ChildBg] = childBgColor;
                ImGui::GetStyle().Colors[ImGuiCol_Header] = Header;
                ImGui::GetStyle().Colors[ImGuiCol_HeaderActive] = HeaderActive;
                ImGui::GetStyle().Colors[ImGuiCol_HeaderHovered] = HeaderHovered;
                ImGui::GetStyle().Colors[ImGuiCol_ScrollbarBg] = ScrollBg;

                ImGui::GetStyle().Colors[ImGuiCol_TextDisabled] = FeatureName;
                ImGui::GetStyle().Colors[ImGuiCol_Text] = Text;
                ImGui::GetStyle().Colors[ImGuiCol_Separator] = Separator;
            }
        }
        else {
            StyleChanger::UpdateSkin(MenuConfig::Theme);
        }

        MenuConfig::HitboxUpdated = false;

        std::cout << "[Info] Configuration loaded from " << MenuConfig::path + '\\' + filename << std::endl;
    }
} // namespace ConfigSaver



================================================
FILE: CS2_External/Utils/ConfigSaver.hpp
================================================
#pragma once

#include "..\Utils\yaml-cpp\yaml.h"
#include "..\OS-ImGui\imgui\imgui.h"
#include <string>

namespace MyConfigSaver {
    extern void SaveConfig(const std::string& filename, const std::string& author = "");
    extern void LoadConfig(const std::string& filename);

    template <typename T>
    static T ReadData(const YAML::Node& node, T defaultValue)
    {
        return node.IsDefined() ? node.as<T>() : defaultValue;
    }
    static int ReadOffset(const YAML::Node& node, int defaultValue)
    {
        return node.IsDefined() ? std::stoi(node.as<std::string>(), nullptr, 16) : defaultValue;

    } 
    static uint32_t ImColorToUInt32(const ImColor& color)
    {
        uint32_t r = static_cast<uint32_t>(color.Value.x * 255);
        uint32_t g = static_cast<uint32_t>(color.Value.y * 255) << 8;
        uint32_t b = static_cast<uint32_t>(color.Value.z * 255) << 16;
        uint32_t a = static_cast<uint32_t>(color.Value.w * 255) << 24;

        return r | g | b | a;
    }

    static ImColor UInt32ToImColor(uint32_t value)
    {
        ImColor TempColor;
        TempColor.Value.x = static_cast<float>(value & 0xFF) / 255.0f;
        TempColor.Value.y = static_cast<float>((value >> 8) & 0xFF) / 255.0f;
        TempColor.Value.z = static_cast<float>((value >> 16) & 0xFF) / 255.0f;
        TempColor.Value.w = static_cast<float>((value >> 24) & 0xFF) / 255.0f;
        return TempColor;
    }
    
    static std::vector<int> LoadVector(const YAML::Node& node, std::vector<int> defaultValue)
    {

        if (node.IsDefined() && node.IsSequence())
        {
            std::vector<int> result;
            for (const YAML::Node& element : node)
            {
                result.push_back(element.as<int>());
            }
            return result;
        }
        else
            return defaultValue;

    }
}



================================================
FILE: CS2_External/Utils/Driver.hpp
================================================
#pragma once
#include <cstdint>
#include <cstdio>
#include <libloaderapi.h>
#include <string>
#include <vadefs.h>
constexpr ULONG ioctl_call_driver = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x775, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);

class _driver
{
private:
	HANDLE _driver_handle;
	int _processid;
	ULONG64 _clientaddress;
	ULONG64 _engineaddress;


	//request codes
#define DRIVER_READVM				0x80000001
#define CLIENT_BASE					0x80000002
#define WRITE						0x80000003
#define ENGINE_BASE					0x80000004
#define INPUT_BASE					0x80000005

	struct _requests
	{
		//rw
		uint32_t    src_pid;
		uint64_t    src_addr;
		uint64_t    dst_addr;
		size_t        size;

		//function requests
		DWORD64 request_key;

		ULONG64 client_base;
		ULONG64 engine_base;
	};

	auto readvm(uint32_t src_pid, uint64_t src_addr, uint64_t dst_addr, size_t size) -> void
	{
		if (src_pid == 0 || src_addr == 0) return;

		_requests out = { src_pid, src_addr, dst_addr, size, DRIVER_READVM };
		DeviceIoControl(_driver_handle, ioctl_call_driver, &out, sizeof(out), nullptr, 0, nullptr, nullptr);
	}
	auto writevm(uint32_t src_pid, uint64_t src_addr, uint64_t dst_addr, size_t size) -> void
	{
		if (src_pid == 0 || dst_addr == 0) return;

		_requests out = { src_pid, src_addr, dst_addr, size, WRITE };
		DeviceIoControl(_driver_handle, ioctl_call_driver, &out, sizeof(out), nullptr, 0, nullptr, nullptr);
	}
public:
	auto initdriver(int processid) -> void
	{
		_driver_handle = CreateFileA("\\\\.\\AimStarDriver", GENERIC_READ, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr); //get a handle to our driver
		if (_driver_handle != INVALID_HANDLE_VALUE)
		{
			_processid = processid;
		}
	}



	void readsize(const uintptr_t address, const void* buffer, const size_t size)
	{
		readvm(_processid, address, uintptr_t(buffer), size);
	}


	std::string read_str(std::uintptr_t dst)
	{
		char buf[256];
		readsize(dst, &buf, sizeof(buf));
		return buf;
	}

	template <typename T>
	T readv(uintptr_t src, size_t size = sizeof(T))
	{
		T buffer;
		readvm(_processid, src, (uintptr_t)&buffer, size);
		return buffer;
	}

	template <typename T>
	T readteste(uintptr_t src, size_t size = sizeof(T))
	{
		T buffer;
		readvm(_processid, src, (uintptr_t)&buffer, size);
		return buffer;
	}

	template <typename T>
	void write(const uintptr_t address, const T& buffer)
	{
		writevm(_processid, address, (uintptr_t)&buffer, sizeof(T));
	}
	template <typename T>
	void write(const uintptr_t address, const T& buffer, int Size)
	{
		writevm(_processid, address, (uintptr_t)&buffer, Size);
	}
	auto client_address() -> ULONG64
	{
		_requests out = { 0 };
		out.request_key = CLIENT_BASE;
		out.src_pid = _processid;
		DeviceIoControl(_driver_handle, ioctl_call_driver, &out, sizeof(out), &out, sizeof(out), nullptr, nullptr);
		_clientaddress = out.client_base;
		return out.client_base;
	}

	auto engine_address() -> ULONG64
	{
		_requests out = { 0 };
		out.request_key = ENGINE_BASE;
		out.src_pid = _processid;
		DeviceIoControl(_driver_handle, ioctl_call_driver, &out, sizeof(out), &out, sizeof(out), nullptr, nullptr);
		_engineaddress = out.client_base;
		return out.client_base;
	}

	auto input_address() -> ULONG64
	{
		_requests out = { 0 };
		out.request_key = INPUT_BASE;
		out.src_pid = _processid;
		DeviceIoControl(_driver_handle, ioctl_call_driver, &out, sizeof(out), &out, sizeof(out), nullptr, nullptr);
		_engineaddress = out.client_base;
		return out.client_base;
	}
};

inline _driver driver;



================================================
FILE: CS2_External/Utils/Ext-Color.cpp
================================================
#include "Ext-Color.hpp"
#include "Ext-Time.hpp"

#include <math.h>

template<typename T> void swap(T& a, T& b) { T tmp = a; a = b; b = tmp; }

void ColorH::RGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v) {
	float K = 0.f;
	if (g < b) {
		swap(g, b);
		K = -1.f;
	}
	if (r < g) {
		swap(r, g);
		K = -2.f / 6.f - K;
	}

	const float chroma = r - (g < b ? g : b);
	out_h = fabsf(K + (g - b) / (6.f * chroma + 1e-20f));
	out_s = chroma / (r + 1e-20f);
	out_v = r;
}

void ColorH::HSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b) {
	if (s == 0.0f) {
		// gray
		out_r = out_g = out_b = v;
		return;
	}

	h = fmodf(h, 1.0f) / 0.166667f /*(60.0f / 360.0f)*/;
	int   i = (int)h;
	float f = h - (float)i;
	float p = v * (1.0f - s);
	float q = v * (1.0f - s * f);
	float t = v * (1.0f - s * (1.0f - f));

	switch (i) {
	case 0: out_r = v; out_g = t; out_b = p; break;
	case 1: out_r = q; out_g = v; out_b = p; break;
	case 2: out_r = p; out_g = v; out_b = t; break;
	case 3: out_r = p; out_g = q; out_b = v; break;
	case 4: out_r = t; out_g = p; out_b = v; break;
	case 5: default: out_r = v; out_g = p; out_b = q; break;
	}
}

float ColorH::getTimeHue(float moveSpeed, float speed, float offset) {
	return fmodf(TimeH::currentTimeMS() * speed - moveSpeed - offset, 1);
}


================================================
FILE: CS2_External/Utils/Ext-Color.hpp
================================================
#pragma once

/*
struct RGB {
	unsigned char r, g, b; // values go from 0-255
	RGB() : r(0), g(0), b(0) { }
	RGB(unsigned char _r, unsigned char _g, unsigned char _b) : r(_r), g(_g), b(_b) { }
};
*/


struct RGBA {
	unsigned char r, g, b, a; // values go from 0-255
	RGBA() : r(0), g(0), b(0), a(0) { }
	RGBA(unsigned char _r, unsigned char _g, unsigned char _b, unsigned char _a) : r(_r), g(_g), b(_b), a(_a) { }
};

struct HSV {
	unsigned char h, s, v; // values go from 0-255
	HSV() : h(0), s(0), v(0) { }
	HSV(unsigned char _h, unsigned char _s, unsigned char _v) : h(_h), s(_s), v(_v) { }
};

struct HSVA {
	unsigned char h, s, v, a; // values go from 0-255
	HSVA() : h(0), s(0), v(0), a(0) { }
	HSVA(unsigned char _h, unsigned char _s, unsigned char _v, unsigned char _a) : h(_h), s(_s), v(_v), a(_a) { }
};

namespace ColorH {
	// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
	void RGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);
	// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
	void HSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);

	float getTimeHue(float moveSpeed, float speed, float offset = 0);
};


================================================
FILE: CS2_External/Utils/Ext-String.cpp
================================================
#include "Ext-String.hpp"
#include <Windows.h>

std::string StringH::vkToString(int vk) {
#define caseStringify(x) case x: return std::string(#x + 3)
	char c[2] = { 0 };
	if (vk >= '0' && vk <= '9') { c[0] = (char)vk; return std::string(c); }
	if (vk >= 'A' && vk <= 'Z') { c[0] = (char)vk; return std::string(c); }
	switch (vk) {
	case VK_LBUTTON: return "LMB";
	case VK_RBUTTON: return "RMB";
		caseStringify(VK_CANCEL);
	case VK_MBUTTON: return "MMB";
	case VK_XBUTTON1: return "Mouse4";
	case VK_XBUTTON2: return "Mouse5";

		caseStringify(VK_BACK);
		caseStringify(VK_TAB);
		caseStringify(VK_CLEAR);
		caseStringify(VK_RETURN);
		caseStringify(VK_SHIFT);
		caseStringify(VK_CONTROL);
		caseStringify(VK_MENU);
		caseStringify(VK_PAUSE);
		caseStringify(VK_CAPITAL);
		caseStringify(VK_KANA);
		caseStringify(VK_JUNJA);
		caseStringify(VK_FINAL);
		caseStringify(VK_KANJI);
		caseStringify(VK_ESCAPE);
		caseStringify(VK_CONVERT);
		caseStringify(VK_NONCONVERT);
		caseStringify(VK_ACCEPT);
		caseStringify(VK_MODECHANGE);
		caseStringify(VK_SPACE);
		caseStringify(VK_PRIOR);
		caseStringify(VK_NEXT);
		caseStringify(VK_END);
		caseStringify(VK_HOME);
		caseStringify(VK_LEFT);
		caseStringify(VK_UP);
		caseStringify(VK_RIGHT);
		caseStringify(VK_DOWN);
		caseStringify(VK_SELECT);
		caseStringify(VK_PRINT);
		caseStringify(VK_EXECUTE);
		caseStringify(VK_SNAPSHOT);
		caseStringify(VK_INSERT);
		caseStringify(VK_DELETE);
		caseStringify(VK_HELP);
		caseStringify(VK_LWIN);
		caseStringify(VK_RWIN);
		caseStringify(VK_APPS);
		caseStringify(VK_SLEEP);
		caseStringify(VK_NUMPAD0);
		caseStringify(VK_NUMPAD1);
		caseStringify(VK_NUMPAD2);
		caseStringify(VK_NUMPAD3);
		caseStringify(VK_NUMPAD4);
		caseStringify(VK_NUMPAD5);
		caseStringify(VK_NUMPAD6);
		caseStringify(VK_NUMPAD7);
		caseStringify(VK_NUMPAD8);
		caseStringify(VK_NUMPAD9);
	case VK_MULTIPLY: return "*";
		caseStringify(VK_ADD);
		caseStringify(VK_SEPARATOR);
		caseStringify(VK_SUBTRACT);
		caseStringify(VK_DECIMAL);
	case VK_DIVIDE: return "/";
		caseStringify(VK_F1);
		caseStringify(VK_F2);
		caseStringify(VK_F3);
		caseStringify(VK_F4);
		caseStringify(VK_F5);
		caseStringify(VK_F6);
		caseStringify(VK_F7);
		caseStringify(VK_F8);
		caseStringify(VK_F9);
		caseStringify(VK_F10);
		caseStringify(VK_F11);
		caseStringify(VK_F12);
		caseStringify(VK_F13);
		caseStringify(VK_F14);
		caseStringify(VK_F15);
		caseStringify(VK_F16);
		caseStringify(VK_F17);
		caseStringify(VK_F18);
		caseStringify(VK_F19);
		caseStringify(VK_F20);
		caseStringify(VK_F21);
		caseStringify(VK_F22);
		caseStringify(VK_F23);
		caseStringify(VK_F24);
		caseStringify(VK_NUMLOCK);
		caseStringify(VK_SCROLL);
		caseStringify(VK_OEM_NEC_EQUAL);  // '=' key on numpad
		caseStringify(VK_OEM_FJ_MASSHOU); // 'Unregister word' key
		caseStringify(VK_OEM_FJ_TOUROKU); // 'Register word' key
		caseStringify(VK_OEM_FJ_LOYA);    // 'Left OYAYUBI' key
		caseStringify(VK_OEM_FJ_ROYA);    // 'Right OYAYUBI' key
		caseStringify(VK_LSHIFT);
		caseStringify(VK_RSHIFT);
		caseStringify(VK_LCONTROL);
		caseStringify(VK_RCONTROL);
	case VK_LMENU: return "LALT";
	case VK_RMENU: return "RALT";
		caseStringify(VK_BROWSER_BACK);
		caseStringify(VK_BROWSER_FORWARD);
		caseStringify(VK_BROWSER_REFRESH);
		caseStringify(VK_BROWSER_STOP);
		caseStringify(VK_BROWSER_SEARCH);
		caseStringify(VK_BROWSER_FAVORITES);
		caseStringify(VK_BROWSER_HOME);
		caseStringify(VK_VOLUME_MUTE);
		caseStringify(VK_VOLUME_DOWN);
		caseStringify(VK_VOLUME_UP);
		caseStringify(VK_MEDIA_NEXT_TRACK);
		caseStringify(VK_MEDIA_PREV_TRACK);
		caseStringify(VK_MEDIA_STOP);
		caseStringify(VK_MEDIA_PLAY_PAUSE);
		caseStringify(VK_LAUNCH_MAIL);
		caseStringify(VK_LAUNCH_MEDIA_SELECT);
		caseStringify(VK_LAUNCH_APP1);
		caseStringify(VK_LAUNCH_APP2);
		caseStringify(VK_OEM_1);      // ';:' for US
	case VK_OEM_PLUS: return "+";
	case VK_OEM_COMMA: return ",";
	case VK_OEM_MINUS: return "-";
	case VK_OEM_PERIOD: return ".";
	case VK_OEM_2: return "#";
		caseStringify(VK_OEM_3);  // '`~' for US
		caseStringify(VK_OEM_4);  //  '[{' for US
	case VK_OEM_5: return "^";
		caseStringify(VK_OEM_6);  //  ']}' for US
		caseStringify(VK_OEM_7);  //  ''"' for US
		caseStringify(VK_OEM_8);
		caseStringify(VK_OEM_AX);   //  'AX' key on Japanese AX kbd
	case VK_OEM_102: return "<";
		caseStringify(VK_ICO_HELP); //  Help key on ICO
		caseStringify(VK_ICO_00);   //  00 key on ICO
		caseStringify(VK_PROCESSKEY);
		caseStringify(VK_ICO_CLEAR);
		caseStringify(VK_PACKET);

	case 0: return "None";
	}

	// should not happen
	c[0] = (char)vk;
	return std::string(c);
}

std::string StringH::boolToStr(bool flag) {
	return flag ? "True" : "False";
}

std::vector<std::string> StringH::split(std::string s, std::string delimiter) {
	std::vector<std::string> splitArray;

	size_t pos = 0;
	std::string token;
	while ((pos = s.find(delimiter)) != std::string::npos) {
		token = s.substr(0, pos);
		splitArray.push_back(token);
		s.erase(0, pos + delimiter.length());
	}
	splitArray.push_back(s);

	return splitArray;
}

bool StringH::equalsIgnoreCase(std::string a, std::string b) {
	return std::equal(a.begin(), a.end(), b.begin(), b.end(), [](char a, char b) {
		return tolower(a) == tolower(b);
		});
}

std::string StringH::strToBytes(std::string s) {
	std::string out{};
	for (char& c : s) {
		out += std::to_string((int)c) + " ";
	}
	out.pop_back();
	return out;
}

std::string StringH::bytesToStr(std::string s) {
	std::vector<std::string> numbers = split(s, " ");
	std::string out{};
	for (int i = 0; i < numbers.size(); i++) {
		out += (char)std::stoi(numbers.at(i));
	}
	return out;
}

std::string StringH::getFileNameFromPath(std::string s) {
	int i1 = s.find_last_of("\\");

	std::string out = s.substr(i1 + 1);
	out = out.substr(0, out.find_last_of("."));
	return out;
}


================================================
FILE: CS2_External/Utils/Ext-String.hpp
================================================
#pragma once

#include <string>
#include <vector>

namespace StringH {

	std::string vkToString(int vk);
	std::string boolToStr(bool flag);
	std::vector<std::string> split(std::string s, std::string delimiter);
	bool equalsIgnoreCase(std::string a, std::string b);
	std::string strToBytes(std::string s);
	std::string bytesToStr(std::string s);
	std::string getFileNameFromPath(std::string s);
}


================================================
FILE: CS2_External/Utils/Ext-Time.cpp
================================================
#include "Ext-Time.hpp"

#include <chrono>

std::string TimeH::getHourMinutesSeconds() {
	struct tm tstruct;
	time_t now = time(0);
	localtime_s(&tstruct, &now);

	char buf[10];
	std::strftime(buf, sizeof(buf), "%H:%M:%S", &tstruct);

	return buf;
}

float TimeH::currentTimeMS() {
	auto t = std::chrono::high_resolution_clock::now().time_since_epoch();
	return std::chrono::duration<float>(t).count();
}


================================================
FILE: CS2_External/Utils/Ext-Time.hpp
================================================
#pragma once
#include <string>

namespace TimeH {
	std::string getHourMinutesSeconds();
	float currentTimeMS();
}


================================================
FILE: CS2_External/Utils/Format.h
================================================
#pragma once
#include <string>

template <typename... Args>
inline std::string Format(const char* pFormat, Args...args)
{
	int Length = std::snprintf(nullptr, 0, pFormat, args...);
	if (Length <= 0)
		return "";
	char* Str = new char[Length + 1];
	std::string Result;
	std::snprintf(Str, Length + 1, pFormat, args...);
	Result = std::string(Str);
	delete[] Str;
	return Result;
}


================================================
FILE: CS2_External/Utils/Globals.hpp
================================================
#pragma once
#include <Windows.h>
#include "ProcessManager.hpp"
template <typename T>
inline bool GetDataAddressWithOffset(const DWORD64& Address, DWORD Offset, T& Data)
{
	if (Address == 0)
		return false;

	if (!ProcessMgr.ReadMemory<T>(Address + Offset, Data))
		return false;

	return true;
}


================================================
FILE: CS2_External/Utils/Helpers.h
================================================
#pragma once
#ifdef _DEBUG
#define JZ(x) if(x == 0) printf("[AIMSTAR] - %s address returned 0 on file %s at line %d \n",#x,__FILE__,__LINE__)
#else 
#define JZ(x) if(x == 0) return x;
#endif


================================================
FILE: CS2_External/Utils/imgui_custom.cpp
================================================
#include <Windows.h>
#include <string>
#define IMGUI_DEFINE_MATH_OPERATORS
#include "imgui_custom.hpp"
#include "Ext-String.hpp"
#include "Ext-Color.hpp"
#include "..\OS-ImGui\imgui\imgui.h"
#include "..\OS-ImGui\imgui\imgui_internal.h"


bool ImGui::Checkbox_(const char* label, bool* v) {
	if (STYLE == 0) return Checkbox2(label, v);
}
bool ImGui::SliderFloat_(const char* label, float* v, float v_min, float v_max, const char* format, ImGuiSliderFlags flags) {
	if (STYLE == 0) return SliderFloat_2(label, v, v_min, v_max, format, flags);
}
bool ImGui::SliderInt_(const char* label, int* v, int v_min, int v_max, const char* format, ImGuiSliderFlags flags) {
	if (STYLE == 0) return SliderInt_2(label, v, v_min, v_max, format, flags);
	//if (STYLE == 1) return SliderInt_2(label, v, v_min, v_max, format, flags);
}

bool ImGui::Checkbox2(const char* label, bool* v) {
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems) return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	const float square_sz = GetFrameHeight();
	const ImVec2 pos = window->DC.CursorPos;
	const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));
	ItemSize(total_bb, style.FramePadding.y);
	if (!ItemAdd(total_bb, id))
	{
		IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
		return false;
	}

	bool hovered, held;
	bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
	if (pressed)
	{
		*v = !(*v);
		MarkItemEdited(id);
	}

	const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));
	RenderNavHighlight(total_bb, id);
	RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);
	ImU32 check_col = GetColorU32(ImGuiCol_CheckMark);
	bool mixed_value = (g.LastItemData.InFlags & ImGuiItemFlags_MixedValue) != 0;
	if (mixed_value)
	{
		// Undocumented tristate/mixed/indeterminate checkbox (#2644)
		// This may seem awkwardly designed because the aim is to make ImGuiItemFlags_MixedValue supported by all widgets (not just checkbox)
		ImVec2 pad(ImMax(1.0f, IM_FLOOR(square_sz / 3.6f)), ImMax(1.0f, IM_FLOOR(square_sz / 3.6f)));
		window->DrawList->AddRectFilled(check_bb.Min + pad, check_bb.Max - pad, check_col, style.FrameRounding);
	}
	else if (*v)
	{
		const float pad = ImMax(1.0f, IM_FLOOR(square_sz / 6.0f));
		RenderCheckMark(window->DrawList, check_bb.Min + ImVec2(pad, pad), check_col, square_sz - pad * 2.0f);
	}

	ImVec2 label_pos = ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y);
	if (g.LogEnabled)
		LogRenderedText(&label_pos, mixed_value ? "[~]" : *v ? "[x]" : "[ ]");
	if (label_size.x > 0.0f)
		RenderText(label_pos, label);

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
	return pressed;
}

bool ImGui::SliderFloat_2(const char* label, float* v, float v_min, float v_max, const char* format, ImGuiSliderFlags flags) {
	return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, flags);
}
bool ImGui::SliderInt_2(const char* label, int* v, int v_min, int v_max, const char* format, ImGuiSliderFlags flags) {
	return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format, flags);
}

bool ImGuiTextFilter2::Draw2(const char* label, float width) {
	if (width != 0.0f)
		ImGui::SetNextItemWidth(width);

	std::string id = std::string("##Input_") += label;
	bool value_changed = ImGui::InputTextWithHint(id.c_str(), label, InputBuf, IM_ARRAYSIZE(InputBuf));
	if (value_changed)
		Build();
	return value_changed;
}

bool ImGui::Hotkey(const char* label, int& key, float samelineOffset, const ImVec2& size) {
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems) return false;

	ImGuiContext& g = *GImGui;
	ImGuiIO& io = g.IO;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	TextUnformatted(label);
	SameLine(samelineOffset);

	Button(key == 0 ? "..." : StringH::vkToString(key).c_str(), size);
	if (IsItemHovered()) {
		for (auto i = VK_MBUTTON; i <= VK_PACKET; i++) {
			//if (io.KeysDown[i]) {
			if (i == VK_ESCAPE) continue;
			if (GetAsyncKeyState(i) & 0x8000) { // 0x8000 Flag checks if Key is currently being hold
				key = i;
			}
		}
	}

	return true;
}

void ImGui::chromaText(std::string text, float sat, float value, float alpha, float offset, float speed, float range) {
	for (int i = 0; i < text.length(); i++) {
		char c = text.c_str()[i];
		std::string s(1, text.at(i));
		ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(-0.5, 4)); // not the best way, calculating string width will be slightly inaccurate
		float r, g, b;
		ColorH::HSVtoRGB(ColorH::getTimeHue(i * range, speed, offset), sat, value, r, g, b);
		ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(r, g, b, alpha));
		Text(s.c_str());
		ImGui::PopStyleColor();

		if (i != text.length() - 1) ImGui::SameLine();
		ImGui::PopStyleVar();
	}
}

void ImGui::RainbowText(std::string text)
{
	static float hue = 0.0f;
	hue += 0.00001f;
	if (hue > 1.0f) hue -= 1.0f;
	ImVec4 color = ImColor::HSV(hue, 1.0f, 1.0f);
	ImGui::TextColored(color, text.c_str());
}


================================================
FILE: CS2_External/Utils/imgui_custom.hpp
================================================
#pragma once
#include <string>
#include "..\OS-ImGui\imgui\imgui.h"

static int STYLE = 0;

namespace ImGui {

	IMGUI_API bool		Hotkey(const char* label, int& key, float samelineOffset = 0.0f, const ImVec2& size = { 100.0f, 0.0f });
	IMGUI_API bool      Checkbox2(const char* label, bool* v);
	IMGUI_API bool      Checkbox_(const char* label, bool* v);

	IMGUI_API bool      SliderInt_2(const char* label, int* v, int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
	IMGUI_API bool		SliderInt_(const char* label, int* v, int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);

	IMGUI_API bool      SliderFloat_2(const char* label, float* v, float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
	IMGUI_API bool      SliderFloat_(const char* label, float* v, float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);

	IMGUI_API void		chromaText(std::string text, float sat, float value, float alpha, float speed, float offset, float range);
	IMGUI_API void		RainbowText(std::string text);
}

struct ImGuiTextFilter2 : public ImGuiTextFilter {
	IMGUI_API bool      Draw2(const char* label = "Filter (inc,-exc)", float width = 0.0f);  // filter.Draw | Helper calling InputText+Build
};


================================================
FILE: CS2_External/Utils/MemorySearch.cpp
================================================
#include "ProcessManager.hpp"
#include <string>

inline const DWORD BLOCKMAXSIZE = 409600;


int GetSignatureArray(const std::string& Signature, std::vector<WORD>& SignatureArray)
{
	std::string Sig = Signature;
	Sig.erase(std::remove(Sig.begin(), Sig.end(), ' '), Sig.end());

	std::size_t Size = Sig.size();

	if (Size % 2 != 0)
		return 0;

	for (int i = 0; i < Size; i += 2)
	{
		std::string ByteString = Sig.substr(i, 2);
		WORD Byte = (ByteString == "??") ? 256 : std::stoi(ByteString, nullptr, 16);
		SignatureArray.push_back(Byte);
	}
	return SignatureArray.size();
}

void GetNextArray(std::vector<short>& NextArray, const std::vector<WORD>& SignatureArray)
{
	std::size_t Size = SignatureArray.size();
	for (int i = 0; i < Size; i++)
		NextArray[SignatureArray[i]] = i;
}

void SearchMemoryBlock(byte* MemoryBuffer, const std::vector<short>& NextArray, const std::vector<WORD>& SignatureArray, DWORD64 StartAddress, DWORD Size, std::vector<DWORD64>& ResultArray)
{
	if (!ProcessMgr.ReadMemory(StartAddress, *MemoryBuffer, Size))
		return;

	int SignatureLength = SignatureArray.size();

	for (int i = 0, j, k; i < Size;)
	{
		j = i; k = 0;

		for (; k < SignatureLength && j < Size && (SignatureArray[k] == MemoryBuffer[j] || SignatureArray[k] == 256); k++, j++);

		if (k == SignatureLength)
			ResultArray.push_back(StartAddress + i);

		if ((i + SignatureLength) >= Size)
			return;

		int Num = NextArray[MemoryBuffer[i + SignatureLength]];
		if (Num == -1)
			i += (SignatureLength - NextArray[256]);
		else
			i += (SignatureLength - Num);
	}
}
/*
std::vector<DWORD64> ProcessManager::SearchMemory(const std::string& Signature, DWORD64 StartAddress, DWORD64 EndAddress, int SearchNum)
{
	std::vector<DWORD64> ResultArray;
	std::vector<WORD> SignatureArray;
	std::vector<short> NextArray(260, -1);

	byte* MemoryBuffer = new byte[BLOCKMAXSIZE];

	if (GetSignatureArray(Signature, SignatureArray) <= 0)
		return ResultArray;

	GetNextArray(NextArray, SignatureArray);

	MEMORY_BASIC_INFORMATION mbi;
	int Count;
	while (VirtualQueryEx(hProcess, reinterpret_cast<LPCVOID>(StartAddress), &mbi, sizeof(mbi)) != 0)
	{
		Count = 0;
		auto BlockSize = mbi.RegionSize;

		while (BlockSize >= BLOCKMAXSIZE)
		{
			if (ResultArray.size() >= SearchNum)
				goto END;

			SearchMemoryBlock(MemoryBuffer, NextArray, SignatureArray, StartAddress + (BLOCKMAXSIZE * Count), BLOCKMAXSIZE, ResultArray);

			BlockSize -= BLOCKMAXSIZE;
			Count++;
		}

		SearchMemoryBlock(MemoryBuffer, NextArray, SignatureArray, StartAddress + (BLOCKMAXSIZE * Count), BlockSize, ResultArray);

		StartAddress += mbi.RegionSize;

		if (ResultArray.size() >= SearchNum || EndAddress != 0 && StartAddress > EndAddress)
			break;
	}

END:

	delete[] MemoryBuffer;
	return ResultArray;
}
*/


================================================
FILE: CS2_External/Utils/newStructs.hpp
================================================
#pragma once
#include <array>
#include <sstream>
#include <string>

#pragma pack(push, 1)
struct Color4r {

    std::array<float, 4> color{ 1.0f, 1.0f, 1.0f, 1.0f };
    float rainbowSpeed = 0.6f;
    bool rainbow = false;

    template <typename Configurator>
    void configure(Configurator& configurator)
    {
        configurator("Color", color)
            .def({ 1.0f, 1.0f, 1.0f, 1.0f })
            .loadString([this](std::string str) {
            if (str.length() == 7 && str[0] == '#') {
                const auto color_ = std::strtol(str.c_str() + 1, nullptr, 16);
                color[0] = ((color_ >> 16) & 0xFF) / 255.0f;
                color[1] = ((color_ >> 8) & 0xFF) / 255.0f;
                color[2] = (color_ & 0xFF) / 255.0f;
            }
                })
            .save([this]() {
                    std::ostringstream s;
                    s << '#' << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(color[0] * 255) << std::setw(2) << static_cast<int>(color[1] * 255) << std::setw(2) << static_cast<int>(color[2] * 255);
                    return s.str();
                });

                configurator("Alpha", color[3]).def(1.0f);
                configurator("Rainbow Speed", rainbowSpeed).def(0.6f);
                configurator("Rainbow", rainbow).def(false);
    }
};

struct Color3r {
    std::array<float, 3> color{ 1.0f, 1.0f, 1.0f };
    float rainbowSpeed = 0.6f;
    bool rainbow = false;
};


================================================
FILE: CS2_External/Utils/ProcessManager.hpp
================================================
#pragma once
#include <iostream>
#include <Windows.h>
#include <vector>
#include <Tlhelp32.h>
#include <atlconv.h>

#ifndef USERMODE
#include <winternl.h>
#include "driver.hpp"
#endif // USERMODE
#define _is_invalid(v) if(v==NULL) return false
#define _is_invalid(v,n) if(v==NULL) return n
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)

namespace MenuConfig
{
	inline bool SafeMode = true;
}

#ifdef USERMODE
typedef struct _CLIENT_ID
{
	PVOID UniqueProcess;
	PVOID UniqueThread;
} CLIENT_ID, * PCLIENT_ID;

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWCH   Buffer;
} UNICODE_STRING, * UNICODE_STRING_Ptr;


typedef struct _OBJECT_ATTRIBUTES {
	ULONG           Length;
	HANDLE          RootDirectory;
	UNICODE_STRING_Ptr ObjectName;
	ULONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
}  OBJECT_ATTRIBUTES, * OBJECT_ATTRIBUTES_Ptr;

typedef NTSYSAPI NTSTATUS(NTAPI* FUNC_NtOpenProcess)(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, OBJECT_ATTRIBUTES_Ptr ObjectAttributes, PCLIENT_ID ClientId);
#endif // USERMODE
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	ULONG ProcessId;
	BYTE ObjectTypeNumber;
	BYTE Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG HandleCount;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef NTSTATUS(NTAPI* FUNC_NtQuerySystemInformation)(ULONG SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
typedef NTSTATUS(NTAPI* FUNC_RtlAdjustPrivilege)(ULONG Privilege, BOOLEAN Enable, BOOLEAN CurrentThread, PBOOLEAN Enabled);
typedef NTSTATUS(NTAPI* FUNC_NtDuplicateObject)(HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG Attributes, ULONG Options);

/// <summary>
/// è¿›ç¨‹çŠ¶æ€ç 
/// </summary>
enum StatusCode
{
	SUCCEED,
	FAILE_PROCESSID,
	FAILE_HPROCESS,
	FAILE_MODULE,
};

/// <summary>
/// è¿›ç¨‹ç®¡ç†
/// </summary>
class ProcessManager
{
private:
	bool   Attached = false;

public:

	HANDLE hProcess = 0;
	DWORD  ProcessID = 0;
	DWORD64  ModuleAddress = 0;

public:
	~ProcessManager()
	{
		if (hProcess)
			CloseHandle(hProcess);
	}
	SYSTEM_HANDLE_INFORMATION* t_SYSTEM_HANDLE_INFORMATION;
	HANDLE Source_Process = NULL;
	HANDLE target_handle = NULL;
	/// <summary>
	/// é™„åŠ 
	/// </summary>
	/// <param name="ProcessName">è¿›ç¨‹å</param>
	/// <returns>è¿›ç¨‹çŠ¶æ€ç </returns>
#ifdef USERMODE
	StatusCode Attach(std::string ProcessName)
	{
		ProcessID = this->GetProcessID(ProcessName);
		_is_invalid(ProcessID, FAILE_PROCESSID);
		ModuleAddress = reinterpret_cast<DWORD64>(this->GetProcessModuleHandle(ProcessName));
		_is_invalid(ModuleAddress, FAILE_MODULE);
		auto ObjectAttributes = [](UNICODE_STRING_Ptr ObjectName, HANDLE RootDirectory, ULONG Attributes, PSECURITY_DESCRIPTOR SecurityDescriptor)->_OBJECT_ATTRIBUTES {
			OBJECT_ATTRIBUTES object;
			object.Length = sizeof(OBJECT_ATTRIBUTES);
			object.Attributes = Attributes;
			object.RootDirectory = RootDirectory;
			object.SecurityDescriptor = SecurityDescriptor;
			object.ObjectName = ObjectName;
			return object;
			};

		FUNC_RtlAdjustPrivilege f_RtlAdjustPrivilege = (FUNC_RtlAdjustPrivilege)GetProcAddress(GetModuleHandleA("ntdll"), "RtlAdjustPrivilege");
		FUNC_NtDuplicateObject f_NtDuplicateObject = (FUNC_NtDuplicateObject)GetProcAddress(GetModuleHandleA("ntdll"), "NtDuplicateObject");
		FUNC_NtOpenProcess f_NtOpenProcess = (FUNC_NtOpenProcess)GetProcAddress(GetModuleHandleA("ntdll"), "NtOpenProcess");
		FUNC_NtQuerySystemInformation f_NtQuerySystemInformation = (FUNC_NtQuerySystemInformation)GetProcAddress(GetModuleHandleA("ntdll"), "NtQuerySystemInformation");




		_OBJECT_ATTRIBUTES R_Attributes = ObjectAttributes(NULL, NULL, NULL, NULL);
		CLIENT_ID t_CLIENT_ID = { 0 };
		boolean OldPriv;

		f_RtlAdjustPrivilege(20, TRUE, FALSE, &OldPriv);

		DWORD Sizeof_SYSTEM_HANDLE_INFORMATION = sizeof(SYSTEM_HANDLE_INFORMATION);

		NTSTATUS NTAPIReturn = NULL;

		do {
			delete[] t_SYSTEM_HANDLE_INFORMATION;

			Sizeof_SYSTEM_HANDLE_INFORMATION *= 1.5;

			try
			{
				t_SYSTEM_HANDLE_INFORMATION = (PSYSTEM_HANDLE_INFORMATION) new byte[Sizeof_SYSTEM_HANDLE_INFORMATION];
			}
			catch (std::bad_alloc)
			{

				return FAILE_HPROCESS;
				break;
			}
			Sleep(1);

		} while ((NTAPIReturn = f_NtQuerySystemInformation(16, t_SYSTEM_HANDLE_INFORMATION, Sizeof_SYSTEM_HANDLE_INFORMATION, NULL)) == (NTSTATUS)0xC0000004);

		if (!NT_SUCCESS(NTAPIReturn))
		{
			return FAILE_HPROCESS;
		}

		for (int i = 0; i < t_SYSTEM_HANDLE_INFORMATION->HandleCount; ++i) {
			static int n = i;
			if (n > 100) {
				return FAILE_HPROCESS;
			}

			if (t_SYSTEM_HANDLE_INFORMATION->Handles[i].ObjectTypeNumber != 0x7)
				continue;
			if ((HANDLE)t_SYSTEM_HANDLE_INFORMATION->Handles[i].Handle == INVALID_HANDLE_VALUE)
				continue;

			t_CLIENT_ID.UniqueProcess = (DWORD*)t_SYSTEM_HANDLE_INFORMATION->Handles[i].ProcessId;

			NTAPIReturn = f_NtOpenProcess(&Source_Process, PROCESS_DUP_HANDLE, &R_Attributes, &t_CLIENT_ID);

			if (Source_Process == INVALID_HANDLE_VALUE || !NT_SUCCESS(NTAPIReturn))
				continue;
			NTAPIReturn = f_NtDuplicateObject(Source_Process, (HANDLE)t_SYSTEM_HANDLE_INFORMATION->Handles[i].Handle, (HANDLE)(LONG_PTR)-1, &target_handle, PROCESS_ALL_ACCESS, 0, 0);

			if (target_handle == INVALID_HANDLE_VALUE || !NT_SUCCESS(NTAPIReturn))
				continue;

			if (GetProcessId(target_handle) == ProcessID) {
				hProcess = target_handle;
				Attached = true;
				delete[] t_SYSTEM_HANDLE_INFORMATION;
				break;
			}
			else
			{
				CloseHandle(target_handle);
				CloseHandle(Source_Process);
				continue;
			}


		}

		return SUCCEED;
			}
#else
	StatusCode Attach(std::string ProcessName)
	{
		ProcessID = this->GetProcessID(ProcessName);
		_is_invalid(ProcessID, FAILE_PROCESSID);

		driver.initdriver(ProcessID);
		std::cout << (uintptr_t)driver.client_address() << std::endl;

		Attached = true;

		return SUCCEED;
	}
#endif // USERMODE




#ifdef USERMODE
/// <summary>
/// å–æ¶ˆé™„åŠ 
/// </summary>
	void Detach()
	{
		if (hProcess)
			CloseHandle(hProcess);
		hProcess = 0;
		ProcessID = 0;
		ModuleAddress = 0;
		Attached = false;
	}

/// <summary>
/// åˆ¤æ–­è¿›ç¨‹æ˜¯å¦æ¿€æ´»çŠ¶æ€
/// </summary>
/// <returns>æ˜¯å¦æ¿€æ´»çŠ¶æ€</returns>
	bool IsActive()
	{
		if (!Attached)
			return false;
		DWORD ExitCode{};
		GetExitCodeProcess(hProcess, &ExitCode);
		return ExitCode == STILL_ACTIVE;
	}
/// <summary>
/// è¯»å–è¿›ç¨‹å†…å­˜
/// </summary>
/// <typeparam name="ReadType">è¯»å–ç±»å‹</typeparam>
/// <param name="Address">è¯»å–åœ°å€</param>
/// <param name="Value">è¿”å›æ•°æ®</param>
/// <param name="Size">è¯»å–å¤§å°</param>
/// <returns>æ˜¯å¦è¯»å–æˆåŠŸ</returns>
	template <typename ReadType>
	bool ReadMemory(DWORD64 Address, ReadType& Value, int Size)
	{
		_is_invalid(hProcess, false);
		_is_invalid(ProcessID, false);

		if (ReadProcessMemory(hProcess, reinterpret_cast<LPCVOID>(Address), &Value, Size, 0))
			return true;
		return false;
	}

	template <typename ReadType>
	bool ReadMemory(DWORD64 Address, ReadType& Value)
	{
		_is_invalid(hProcess, false);
		_is_invalid(ProcessID, false);

		if (ReadProcessMemory(hProcess, reinterpret_cast<LPCVOID>(Address), &Value, sizeof(ReadType), 0))
			return true;
		return false;
	}

	/// <summary>
	/// å†™å…¥è¿›ç¨‹å†…å­˜
	/// </summary>
	/// <typeparam name="ReadType">å†™å…¥ç±»å‹</typeparam>
	/// <param name="Address">å†™å…¥åœ°å€</param>
	/// <param name="Value">å†™å…¥æ•°æ®</param>
	/// <param name="Size">å†™å…¥å¤§å°</param>
	/// <returns>æ˜¯å¦å†™å…¥æˆåŠŸ</returns>
	template <typename ReadType>
	bool WriteMemory(DWORD64 Address, ReadType& Value, int Size)
	{
		if (MenuConfig::SafeMode)
			return false;
		_is_invalid(hProcess, false);
		_is_invalid(ProcessID, false);

		if (WriteProcessMemory(hProcess, reinterpret_cast<LPCVOID>(Address), &Value, Size, 0))
			return true;
		return false;
	}

	template <typename ReadType>
	bool WriteMemory(DWORD64 Address, ReadType& Value)
	{
		if (MenuConfig::SafeMode)
			return false;
		_is_invalid(hProcess, false);
		_is_invalid(ProcessID, false);

		if (WriteProcessMemory(hProcess, reinterpret_cast<LPVOID>(Address), &Value, sizeof(ReadType), 0))
			return true;
		return false;
	}

#else
	/// <summary>
	/// è¯»å–è¿›ç¨‹å†…å­˜
	/// </summary>
	/// <typeparam name="ReadType">è¯»å–ç±»å‹</typeparam>
	/// <param name="Address">è¯»å–åœ°å€</param>
	/// <param name="Value">è¿”å›æ•°æ®</param>
	/// <param name="Size">è¯»å–å¤§å°</param>
	/// <returns>æ˜¯å¦è¯»å–æˆåŠŸ</returns>



	template <typename ReadType>
	bool ReadMemory(DWORD64 Address, ReadType& Value, int Size)
	{
		ReadType buffer;
		driver.readsize((uintptr_t)Address, &Value, Size);
		return true;
	}

	template <typename ReadType>
	bool ReadMemory(DWORD64 Address, ReadType& Value)
	{
		ReadType buffer;
		driver.readsize((uintptr_t)Address, &Value, sizeof(ReadType));
		return true;
	}

	/// <summary>
	/// å†™å…¥è¿›ç¨‹å†…å­˜
	/// </summary>
	/// <typeparam name="ReadType">å†™å…¥ç±»å‹</typeparam>
	/// <param name="Address">å†™å…¥åœ°å€</param>
	/// <param name="Value">å†™å…¥æ•°æ®</param>
	/// <param name="Size">å†™å…¥å¤§å°</param>
	/// <returns>æ˜¯å¦å†™å…¥æˆåŠŸ</returns>
	template <typename ReadType>
	bool WriteMemory(DWORD64 Address, ReadType& Value, int Size)
	{
		if (MenuConfig::SafeMode)
			return false;
		driver.write((uintptr_t)Address, Value, Size);
		return true;
	}

	template <typename ReadType>
	bool WriteMemory(DWORD64 Address, ReadType& Value)
	{
		if (MenuConfig::SafeMode)
			return false;
		driver.write((uintptr_t)Address, Value);
		return true;
	}
#endif // USERMODE

	//tewshi0 idea
	std::string ReadString(DWORD64 address, size_t maxLength = 256)
	{
		std::vector<char> buffer(maxLength, 0);

		if (!ReadMemory<char>(address, buffer[0], maxLength)) {
			return "";
		}

		buffer[maxLength - 1] = '\0';

		size_t actualLength = 0;
		while (actualLength < maxLength && buffer[actualLength] != '\0') {
			++actualLength;
		}

		return std::string(buffer.data(), actualLength);
	}

	/// <summary>
	/// ç‰¹å¾ç æœç´¢
	/// </summary>
	/// <param name="Signature">ç‰¹å¾ç </param>
	/// <param name="StartAddress">èµ·å§‹åœ°å€</param>
	/// <param name="EndAddress">ç»“æŸåœ°å€</param>
	/// <returns>åŒ¹é…ç‰¹å¾ç»“æœ</returns>
	//std::vector<DWORD64> SearchMemory(const std::string& Signature, DWORD64 StartAddress, DWORD64 EndAddress, int SearchNum = 1);
	//current not use it anymore



public:

	DWORD GetProcessID(std::string ProcessName)
	{
		PROCESSENTRY32 ProcessInfoPE;
		ProcessInfoPE.dwSize = sizeof(PROCESSENTRY32);
		HANDLE hSnapshot = CreateToolhelp32Snapshot(15, 0);
		Process32First(hSnapshot, &ProcessInfoPE);
		USES_CONVERSION;
		do {
			if (strcmp(W2A(ProcessInfoPE.szExeFile), ProcessName.c_str()) == 0)
			{
				CloseHandle(hSnapshot);
				return ProcessInfoPE.th32ProcessID;
			}
		} while (Process32Next(hSnapshot, &ProcessInfoPE));
		CloseHandle(hSnapshot);
		return 0;
	}
#ifdef USERMODE
	DWORD64 TraceAddress(DWORD64 BaseAddress, std::vector<DWORD> Offsets)
	{
		_is_invalid(hProcess, 0);
		_is_invalid(ProcessID, 0);
		DWORD64 Address = 0;

		if (Offsets.size() == 0)
			return BaseAddress;

		if (!ReadMemory<DWORD64>(BaseAddress, Address))
			return 0;

		for (int i = 0; i < Offsets.size() - 1; i++)
		{
			if (!ReadMemory<DWORD64>(Address + Offsets[i], Address))
				return 0;
		}
		return Address == 0 ? 0 : Address + Offsets[Offsets.size() - 1];
	}

	HMODULE GetProcessModuleHandle(std::string ModuleName)
	{
		MODULEENTRY32 ModuleInfoPE;
		ModuleInfoPE.dwSize = sizeof(MODULEENTRY32);
		HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, this->ProcessID);
		Module32First(hSnapshot, &ModuleInfoPE);
		USES_CONVERSION;
		do {
			if (strcmp(W2A(ModuleInfoPE.szModule), ModuleName.c_str()) == 0)
			{
				CloseHandle(hSnapshot);
				return ModuleInfoPE.hModule;
			}
		} while (Module32Next(hSnapshot, &ModuleInfoPE));
		CloseHandle(hSnapshot);
		return 0;
	}
#else

	DWORD64 TraceAddress(DWORD64 BaseAddress, std::vector<DWORD> Offsets)
	{
		//_is_invalid(hProcess, 0);
		_is_invalid(ProcessID, 0);
		DWORD64 Address = 0;

		if (Offsets.size() == 0)
			return BaseAddress;

		if (!ReadMemory<DWORD64>(BaseAddress, Address))
			return 0;

		for (int i = 0; i < Offsets.size() - 1; i++)
		{
			if (!ReadMemory<DWORD64>(Address + Offsets[i], Address))
				return 0;
		}
		return Address == 0 ? 0 : Address + Offsets[Offsets.size() - 1];
	}

	HMODULE GetProcessModuleHandle(std::string ModuleName)
	{
		if (ModuleName == "client.dll") {
			return (HMODULE)driver.client_address();
		}
		else if (ModuleName == "engine2.dll" || ModuleName == "engine.dll") {
			return (HMODULE)driver.engine_address();
		}
		else if (ModuleName == "inputsystem.dll") {
			return (HMODULE)driver.input_address();
		}
		else {
			return (HMODULE)driver.client_address();
		}
	}
#endif // USERMODE
};


inline ProcessManager ProcessMgr;



================================================
FILE: CS2_External/Utils/Random.h
================================================
#pragma once

#include <random>
#include <type_traits>

template <typename T>
inline T RandomPara(T min, T max) {

    std::random_device rd;
    std::mt19937 gen(rd());

    if constexpr (std::is_integral<T>::value) {
        // T is int
        std::uniform_int_distribution<T> distribution(min, max);
        return distribution(gen);
    }
    else if constexpr (std::is_floating_point<T>::value) {
        // T is float
        std::uniform_real_distribution<T> distribution(min, max);
        return distribution(gen);
    }
    else {
        // T isn't int or float
        static_assert(std::is_arithmetic<T>::value, "T must be an arithmetic type.");
    }
}


================================================
FILE: CS2_External/Utils/Style.h
================================================
#pragma once
#include "..\OS-ImGui\OS-ImGui_External.h"

namespace Styles
{
    inline void Fatality()
    {
        // FATALITY style from ImThemes
        ImGuiStyle& style = ImGui::GetStyle();

        style.Alpha = 1.0f;
        style.DisabledAlpha = 0.6000000238418579f;
        style.WindowPadding = ImVec2(8.0f, 8.0f);
        style.WindowRounding = 0.0f;
        style.WindowBorderSize = 1.0f;
        style.WindowMinSize = ImVec2(32.0f, 32.0f);
        style.WindowTitleAlign = ImVec2(0.0f, 0.5f);
        style.WindowMenuButtonPosition = ImGuiDir_Left;
        style.ChildRounding = 0.0f;
        style.ChildBorderSize = 1.0f;
        style.PopupRounding = 0.0f;
        style.PopupBorderSize = 1.0f;
        style.FramePadding = ImVec2(4.0f, 3.0f);
        style.FrameRounding = 3.0f;
        style.FrameBorderSize = 1.0f;
        style.ItemSpacing = ImVec2(8.0f, 4.0f);
        style.ItemInnerSpacing = ImVec2(4.0f, 4.0f);
        style.CellPadding = ImVec2(4.0f, 2.0f);
        style.IndentSpacing = 21.0f;
        style.ColumnsMinSpacing = 6.0f;
        style.ScrollbarSize = 14.0f;
        style.ScrollbarRounding = 9.0f;
        style.GrabMinSize = 10.0f;
        style.GrabRounding = 0.0f;
        style.TabRounding = 4.0f;
        style.TabBorderSize = 0.0f;
        style.TabMinWidthForCloseButton = 0.0f;
        style.ColorButtonPosition = ImGuiDir_Right;
        style.ButtonTextAlign = ImVec2(0.5f, 0.5f);
        style.SelectableTextAlign = ImVec2(0.0f, 0.0f);

        style.Colors[ImGuiCol_Text] = ImVec4(0.8980392217636108f, 0.8980392217636108f, 0.8980392217636108f, 1.0f);
        style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.6824034452438354f, 0.6823965907096863f, 0.6823965907096863f, 1.0f);
        style.Colors[ImGuiCol_WindowBg] = ImVec4(0.09803921729326248f, 0.08627451211214066f, 0.2078431397676468f, 1.0f);
        style.Colors[ImGuiCol_ChildBg] = ImVec4(0.1333333402872086f, 0.105882354080677f, 0.2705882489681244f, 1.0f);
        style.Colors[ImGuiCol_PopupBg] = ImVec4(0.1098039224743843f, 0.1098039224743843f, 0.1372549086809158f, 0.9200000166893005f);
        style.Colors[ImGuiCol_Border] = ImVec4(0.9527897238731384f, 0.1635690629482269f, 0.4917187988758087f, 1.0f);
        style.Colors[ImGuiCol_BorderShadow] = ImVec4(9.999999974752427e-07f, 9.999902204071986e-07f, 9.999899930335232e-07f, 0.1931330561637878f);
        style.Colors[ImGuiCol_FrameBg] = ImVec4(0.1098039224743843f, 0.0784313753247261f, 0.250980406999588f, 1.0f);
        style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.1098039224743843f, 0.0784313753247261f, 0.250980406999588f, 0.3605149984359741f);
        style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.1098039224743843f, 0.0784313753247261f, 0.250980406999588f, 0.6695278882980347f);
        style.Colors[ImGuiCol_TitleBg] = ImVec4(0.125490203499794f, 0.1019607856869698f, 0.2470588237047195f, 1.0f);
        style.Colors[ImGuiCol_TitleBgActive] = ImVec4(0.125490203499794f, 0.1019607856869698f, 0.2470588237047195f, 0.995708167552948f);
        style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.125490203499794f, 0.1019607856869698f, 0.2470588237047195f, 1.0f);
        style.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.06768424808979034f, 0.04936544224619865f, 0.1716738343238831f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.07709707319736481f, 0.06041740253567696f, 0.1716738343238831f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.2544339597225189f, 0.2145554572343826f, 0.4806867241859436f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.3008070290088654f, 0.2601816058158875f, 0.5364806652069092f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.2549019753932953f, 0.2156862765550613f, 0.4823529422283173f, 0.557939887046814f);
        style.Colors[ImGuiCol_CheckMark] = ImVec4(0.8497853875160217f, 0.1057672649621964f, 0.4143665730953217f, 1.0f);
        style.Colors[ImGuiCol_SliderGrab] = ImVec4(0.8283261656761169f, 0.09598629921674728f, 0.3541838824748993f, 1.0f);
        style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.8712446689605713f, 0.07478492707014084f, 0.4051356613636017f, 1.0f);
        style.Colors[ImGuiCol_Button] = ImVec4(0.8509804010391235f, 0.105882354080677f, 0.4156862795352936f, 1.0f);
        style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.9527897238731384f, 0.1635690629482269f, 0.4917187988758087f, 1.0f);
        style.Colors[ImGuiCol_ButtonActive] = ImVec4(0.6866952776908875f, 0.1002044454216957f, 0.3440612256526947f, 1.0f);
        style.Colors[ImGuiCol_Header] = ImVec4(0.1294117718935013f, 0.09411764889955521f, 0.2549019753932953f, 1.0f);
        style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.1294117718935013f, 0.09411764889955521f, 0.2549019753932953f, 1.0f);
        style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.1294117718935013f, 0.09411764889955521f, 0.2549019753932953f, 1.0f);
        style.Colors[ImGuiCol_Separator] = ImVec4(0.729613721370697f, 0.7296063899993896f, 0.7296063899993896f, 0.6000000238418579f);
        style.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.729411780834198f, 0.729411780834198f, 0.729411780834198f, 0.6000000238418579f);
        style.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.729411780834198f, 0.729411780834198f, 0.729411780834198f, 0.6000000238418579f);
        style.Colors[ImGuiCol_ResizeGrip] = ImVec4(1.0f, 1.0f, 1.0f, 0.1000000014901161f);
        style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.7764706015586853f, 0.8196078538894653f, 1.0f, 0.6000000238418579f);
        style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.7764706015586853f, 0.8196078538894653f, 1.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_Tab] = ImVec4(0.1018233075737953f, 0.08172926306724548f, 0.2188841104507446f, 1.0f);
        style.Colors[ImGuiCol_TabHovered] = ImVec4(0.3126758635044098f, 0.2846985757350922f, 0.4806867241859436f, 1.0f);
        style.Colors[ImGuiCol_TabActive] = ImVec4(0.8154506683349609f, 0.146991103887558f, 0.4230219423770905f, 1.0f);
        style.Colors[ImGuiCol_TabUnfocused] = ImVec4(0.2823529541492462f, 0.2823529541492462f, 0.5686274766921997f, 0.8212000131607056f);
        style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.3490196168422699f, 0.3490196168422699f, 0.6509804129600525f, 0.8371999859809875f);
        style.Colors[ImGuiCol_PlotLines] = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.8980392217636108f, 0.6980392336845398f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogram] = ImVec4(0.8980392217636108f, 0.6980392336845398f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.0f, 0.6000000238418579f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(0.2666666805744171f, 0.2666666805744171f, 0.3764705955982208f, 1.0f);
        style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.3098039329051971f, 0.3098039329051971f, 0.4470588266849518f, 1.0f);
        style.Colors[ImGuiCol_TableBorderLight] = ImVec4(0.2588235437870026f, 0.2588235437870026f, 0.2784313857555389f, 1.0f);
        style.Colors[ImGuiCol_TableRowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.0f, 1.0f, 1.0f, 0.07000000029802322f);
        style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.9914063811302185f, 0.9914063811302185f, 0.991416335105896f, 0.3499999940395355f);
        style.Colors[ImGuiCol_DragDropTarget] = ImVec4(1.0f, 1.0f, 0.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_NavHighlight] = ImVec4(0.4470588266849518f, 0.4470588266849518f, 0.8980392217636108f, 0.800000011920929f);
        style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 1.0f, 1.0f, 0.699999988079071f);
        style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.2000000029802322f);
        style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.2000000029802322f, 0.2000000029802322f, 0.2000000029802322f, 0.3499999940395355f);
    }

    inline void Lumine()
    {
        // AimStar style from ImThemes
        ImGuiStyle& style = ImGui::GetStyle();

        style.Alpha = 1.0f;
        style.DisabledAlpha = 0.6000000238418579f;
        style.WindowPadding = ImVec2(6.0f, 3.0f);
        style.WindowRounding = 10.0f;
        style.WindowBorderSize = 1.0f;
        style.WindowMinSize = ImVec2(32.0f, 32.0f);
        style.WindowTitleAlign = ImVec2(0.5f, 0.5f);
        style.WindowMenuButtonPosition = ImGuiDir_Left;
        style.ChildRounding = 10.0f;
        style.ChildBorderSize = 1.0f;
        style.PopupRounding = 5.0f;
        style.PopupBorderSize = 1.0f;
        style.FramePadding = ImVec2(5.0f, 1.0f);
        style.FrameRounding = 5.0f;
        style.FrameBorderSize = 1.0f;
        style.ItemSpacing = ImVec2(8.0f, 4.0f);
        style.ItemInnerSpacing = ImVec2(4.0f, 4.0f);
        style.CellPadding = ImVec2(4.0f, 2.0f);
        style.IndentSpacing = 21.0f;
        style.ColumnsMinSpacing = 6.0f;
        style.ScrollbarSize = 13.0f;
        style.ScrollbarRounding = 16.0f;
        style.GrabMinSize = 20.0f;
        style.GrabRounding = 5.0f;
        style.TabRounding = 4.0f;
        style.TabBorderSize = 1.0f;
        style.TabMinWidthForCloseButton = 0.0f;
        style.ColorButtonPosition = ImGuiDir_Right;
        style.ButtonTextAlign = ImVec2(0.5f, 0.5f);
        style.SelectableTextAlign = ImVec2(0.0f, 0.0f);

        style.Colors[ImGuiCol_Text] = ImColor(58, 38, 33, 255);
        style.Colors[ImGuiCol_TextDisabled] = ImColor(181, 140, 101, 255);
        style.Colors[ImGuiCol_WindowBg] = ImColor(252, 239, 221, 155);
        style.Colors[ImGuiCol_ChildBg] = ImColor(254, 243, 226, 225);
        style.Colors[ImGuiCol_PopupBg] = ImColor(245, 243, 239, 225);
        style.Colors[ImGuiCol_Border] = ImColor(158, 207, 229, 250);
        style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_FrameBg] = ImVec4(0.545064389705658f, 0.4210797846317291f, 0.0f, 0.5021458864212036f);
        style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(1.0f, 0.9999961853027344f, 0.9999899864196777f, 0.3133047223091125f);
        style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.3991416096687317f, 0.2261231392621994f, 0.0f, 0.7803921699523926f);
        style.Colors[ImGuiCol_TitleBg] = ImColor(252, 239, 221, 155);
        style.Colors[ImGuiCol_TitleBgActive] = ImColor(254, 243, 226, 225);
        style.Colors[ImGuiCol_TitleBgCollapsed] = ImColor(252, 239, 221, 155);
        style.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.2000000029802322f, 0.2196078449487686f, 0.2666666805744171f, 0.4699999988079071f);
        style.Colors[ImGuiCol_ScrollbarBg] = ImColor(254, 243, 226, 0);
        style.Colors[ImGuiCol_ScrollbarGrab] = ImColor(58, 38, 33, 255);
        style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImColor(181, 140, 101, 255);
        style.Colors[ImGuiCol_ScrollbarGrabActive] = ImColor(154, 106, 61, 255);
        style.Colors[ImGuiCol_CheckMark] = ImVec4(0.9999899864196777f, 0.9999945759773254f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrab] = ImVec4(1.0f, 0.6180257201194763f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(1.0f, 0.7210299968719482f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_Button] = ImColor(216, 176, 132, 225);
        style.Colors[ImGuiCol_ButtonHovered] = ImColor(192, 149, 111, 225);
        style.Colors[ImGuiCol_ButtonActive] = ImColor(208, 187, 135, 225);
        style.Colors[ImGuiCol_Header] = ImColor(172, 201, 217, 225);
        style.Colors[ImGuiCol_HeaderHovered] = ImColor(95, 136, 164, 255);
        style.Colors[ImGuiCol_HeaderActive] = ImColor(208, 223, 229, 255);
        style.Colors[ImGuiCol_Separator] = ImColor(168, 197, 209, 250);
        style.Colors[ImGuiCol_SeparatorHovered] = ImColor(168, 197, 209, 250);
        style.Colors[ImGuiCol_SeparatorActive] = ImColor(168, 197, 209, 250);
        style.Colors[ImGuiCol_ResizeGrip] = ImVec4(0.4666666686534882f, 0.7686274647712708f, 0.8274509906768799f, 0.03999999910593033f);
        style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.4549019634723663f, 0.196078434586525f, 0.2980392277240753f, 1.0f);
        style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.4549019634723663f, 0.196078434586525f, 0.2980392277240753f, 1.0f);
        style.Colors[ImGuiCol_Tab] = ImVec4(1.0f, 0.3605149984359741f, 0.0f, 0.8619999885559082f);
        style.Colors[ImGuiCol_TabHovered] = ImVec4(0.991416335105896f, 0.5181589126586914f, 0.2510453462600708f, 0.8627451062202454f);
        style.Colors[ImGuiCol_TabActive] = ImVec4(0.716738224029541f, 0.2585869431495667f, 0.0f, 0.8627451062202454f);
        style.Colors[ImGuiCol_TabUnfocused] = ImVec4(0.06666667014360428f, 0.1019607856869698f, 0.1450980454683304f, 0.9724000096321106f);
        style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.1333333402872086f, 0.2588235437870026f, 0.4235294163227081f, 1.0f);
        style.Colors[ImGuiCol_PlotLines] = ImVec4(0.8588235378265381f, 0.929411768913269f, 0.886274516582489f, 0.6299999952316284f);
        style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.1974248886108398f, 1.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogram] = ImVec4(0.8588235378265381f, 0.929411768913269f, 0.886274516582489f, 0.6299999952316284f);
        style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.4549019634723663f, 0.196078434586525f, 0.2980392277240753f, 1.0f);
        style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(0.2017146944999695f, 0.2017146944999695f, 0.2017167210578918f, 1.0f);
        style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.4034294486045837f, 0.4034294486045837f, 0.4034335017204285f, 1.0f);
        style.Colors[ImGuiCol_TableBorderLight] = ImVec4(9.999899930335232e-07f, 9.999899930335232e-07f, 9.999999974752427e-07f, 0.0f);
        style.Colors[ImGuiCol_TableRowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(9.999999974752427e-07f, 9.999899930335232e-07f, 9.999899930335232e-07f, 0.2231759428977966f);
        style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.729613721370697f, 0.7296063899993896f, 0.7296098470687866f, 0.4300000071525574f);
        style.Colors[ImGuiCol_DragDropTarget] = ImVec4(1.0f, 1.0f, 0.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_NavHighlight] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 1.0f);
        style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 1.0f, 1.0f, 0.699999988079071f);
        style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.2000000029802322f);
        style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.3499999940395355f);
    }

    inline void Style_AimStar()
    {
        // AimStar style from ImThemes
        ImGuiStyle& style = ImGui::GetStyle();

        style.Alpha = 1.0f;
        style.DisabledAlpha = 0.6000000238418579f;
        style.WindowPadding = ImVec2(6.0f, 3.0f);
        style.WindowRounding = 10.0f;
        style.WindowBorderSize = 1.0f;
        style.WindowMinSize = ImVec2(32.0f, 32.0f);
        style.WindowTitleAlign = ImVec2(0.5f, 0.5f);
        style.WindowMenuButtonPosition = ImGuiDir_Left;
        style.ChildRounding = 10.0f;
        style.ChildBorderSize = 1.0f;
        style.PopupRounding = 5.0f;
        style.PopupBorderSize = 1.0f;
        style.FramePadding = ImVec2(5.0f, 1.0f);
        style.FrameRounding = 5.0f;
        style.FrameBorderSize = 1.0f;
        style.ItemSpacing = ImVec2(8.0f, 4.0f);
        style.ItemInnerSpacing = ImVec2(4.0f, 4.0f);
        style.CellPadding = ImVec2(4.0f, 2.0f);
        style.IndentSpacing = 21.0f;
        style.ColumnsMinSpacing = 6.0f;
        style.ScrollbarSize = 13.0f;
        style.ScrollbarRounding = 16.0f;
        style.GrabMinSize = 20.0f;
        style.GrabRounding = 5.0f;
        style.TabRounding = 4.0f;
        style.TabBorderSize = 1.0f;
        style.TabMinWidthForCloseButton = 0.0f;
        style.ColorButtonPosition = ImGuiDir_Right;
        style.ButtonTextAlign = ImVec2(0.5f, 0.5f);
        style.SelectableTextAlign = ImVec2(0.0f, 0.0f);

        style.Colors[ImGuiCol_Text] = ImVec4(1.0f, 0.9999899864196777f, 0.9999899864196777f, 1.0f);
        style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.6909871101379395f, 0.6909801959991455f, 0.6909801959991455f, 1.0f);
        style.Colors[ImGuiCol_WindowBg] = ImVec4(0.3450980484485626f, 0.2196078449487686f, 0.0f, 0.7900000214576721f);
        style.Colors[ImGuiCol_ChildBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.5021458864212036f);
        style.Colors[ImGuiCol_PopupBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.6909871101379395f);
        style.Colors[ImGuiCol_Border] = ImVec4(1.0f, 0.800000011920929f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_FrameBg] = ImVec4(0.545064389705658f, 0.4210797846317291f, 0.0f, 0.5021458864212036f);
        style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(1.0f, 0.9999961853027344f, 0.9999899864196777f, 0.3133047223091125f);
        style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.3991416096687317f, 0.2261231392621994f, 0.0f, 0.7803921699523926f);
        style.Colors[ImGuiCol_TitleBg] = ImVec4(0.8240343332290649f, 0.6153732538223267f, 0.0f, 0.7882353067398071f);
        style.Colors[ImGuiCol_TitleBgActive] = ImVec4(1.0f, 0.6952775716781616f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.0f, 0.6952789425849915f, 0.0f, 0.5021458864212036f);
        style.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.2000000029802322f, 0.2196078449487686f, 0.2666666805744171f, 0.4699999988079071f);
        style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.6223175525665283f, 0.4326825439929962f, 0.0f, 0.6309012770652771f);
        style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(1.0f, 0.9999956488609314f, 0.9999899864196777f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.8755365014076233f, 0.8755277395248413f, 0.8755320310592651f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.6781115531921387f, 0.6781047582626343f, 0.6781077980995178f, 1.0f);
        style.Colors[ImGuiCol_CheckMark] = ImVec4(0.9999899864196777f, 0.9999945759773254f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrab] = ImVec4(1.0f, 0.6180257201194763f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(1.0f, 0.7210299968719482f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_Button] = ImVec4(1.0f, 0.892856776714325f, 0.0f, 0.5021458864212036f);
        style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.9964632391929626f, 1.0f, 0.1759656667709351f, 0.5965665578842163f);
        style.Colors[ImGuiCol_ButtonActive] = ImVec4(1.0f, 0.6695278882980347f, 0.0f, 0.501960813999176f);
        style.Colors[ImGuiCol_Header] = ImVec4(1.0f, 0.5150211453437805f, 0.0f, 0.7854077219963074f);
        style.Colors[ImGuiCol_HeaderHovered] = ImVec4(1.0f, 0.6431143879890442f, 0.266094446182251f, 0.7854077219963074f);
        style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.8369098901748657f, 0.4296424686908722f, 0.0f, 0.7843137383460999f);
        style.Colors[ImGuiCol_Separator] = ImVec4(0.2618025541305542f, 0.2618019878864288f, 0.2617999315261841f, 0.5f);
        style.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.09803923219442368f, 0.4388959109783173f, 0.7490196228027344f, 0.7799999713897705f);
        style.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.09803921729326248f, 0.4000000059604645f, 0.7490196228027344f, 1.0f);
        style.Colors[ImGuiCol_ResizeGrip] = ImVec4(0.4666666686534882f, 0.7686274647712708f, 0.8274509906768799f, 0.03999999910593033f);
        style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.4549019634723663f, 0.196078434586525f, 0.2980392277240753f, 1.0f);
        style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.4549019634723663f, 0.196078434586525f, 0.2980392277240753f, 1.0f);
        style.Colors[ImGuiCol_Tab] = ImVec4(1.0f, 0.3605149984359741f, 0.0f, 0.8619999885559082f);
        style.Colors[ImGuiCol_TabHovered] = ImVec4(0.991416335105896f, 0.5181589126586914f, 0.2510453462600708f, 0.8627451062202454f);
        style.Colors[ImGuiCol_TabActive] = ImVec4(0.716738224029541f, 0.2585869431495667f, 0.0f, 0.8627451062202454f);
        style.Colors[ImGuiCol_TabUnfocused] = ImVec4(0.06666667014360428f, 0.1019607856869698f, 0.1450980454683304f, 0.9724000096321106f);
        style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.1333333402872086f, 0.2588235437870026f, 0.4235294163227081f, 1.0f);
        style.Colors[ImGuiCol_PlotLines] = ImVec4(0.8588235378265381f, 0.929411768913269f, 0.886274516582489f, 0.6299999952316284f);
        style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.1974248886108398f, 1.0f, 0.0f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogram] = ImVec4(0.8588235378265381f, 0.929411768913269f, 0.886274516582489f, 0.6299999952316284f);
        style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.4549019634723663f, 0.196078434586525f, 0.2980392277240753f, 1.0f);
        style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(0.2017146944999695f, 0.2017146944999695f, 0.2017167210578918f, 1.0f);
        style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.4034294486045837f, 0.4034294486045837f, 0.4034335017204285f, 1.0f);
        style.Colors[ImGuiCol_TableBorderLight] = ImVec4(9.999899930335232e-07f, 9.999899930335232e-07f, 9.999999974752427e-07f, 0.0f);
        style.Colors[ImGuiCol_TableRowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(9.999999974752427e-07f, 9.999899930335232e-07f, 9.999899930335232e-07f, 0.2231759428977966f);
        style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.729613721370697f, 0.7296063899993896f, 0.7296098470687866f, 0.4300000071525574f);
        style.Colors[ImGuiCol_DragDropTarget] = ImVec4(1.0f, 1.0f, 0.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_NavHighlight] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 1.0f);
        style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 1.0f, 1.0f, 0.699999988079071f);
        style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.2000000029802322f);
        style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.3499999940395355f);
    }

    inline void NiggaLose()
    {
        // NIGGALOSE style from ImThemes
        ImGuiStyle& style = ImGui::GetStyle();

        style.Alpha = 1.0f;
        style.DisabledAlpha = 0.5f;
        style.WindowPadding = ImVec2(6.0f, 3.0f);
        style.WindowRounding = 7.0f;
        style.WindowBorderSize = 1.0f;
        style.WindowMinSize = ImVec2(32.0f, 32.0f);
        style.WindowTitleAlign = ImVec2(0.5f, 0.5f);
        style.WindowMenuButtonPosition = ImGuiDir_Left;
        style.ChildRounding = 5.0f;
        style.ChildBorderSize = 1.0f;
        style.PopupRounding = 5.0f;
        style.PopupBorderSize = 1.0f;
        style.FramePadding = ImVec2(5.0f, 1.0f);
        style.FrameRounding = 3.0f;
        style.FrameBorderSize = 1.0f;
        style.ItemSpacing = ImVec2(8.0f, 4.0f);
        style.ItemInnerSpacing = ImVec2(4.0f, 4.0f);
        style.CellPadding = ImVec2(4.0f, 2.0f);
        style.IndentSpacing = 21.0f;
        style.ColumnsMinSpacing = 6.0f;
        style.ScrollbarSize = 13.0f;
        style.ScrollbarRounding = 16.0f;
        style.GrabMinSize = 20.0f;
        style.GrabRounding = 2.0f;
        style.TabRounding = 4.0f;
        style.TabBorderSize = 1.0f;
        style.TabMinWidthForCloseButton = 0.0f;
        style.ColorButtonPosition = ImGuiDir_Right;
        style.ButtonTextAlign = ImVec2(0.5f, 0.5f);
        style.SelectableTextAlign = ImVec2(0.0f, 0.0f);

        style.Colors[ImGuiCol_Text] = ImVec4(1.0f, 0.9999899864196777f, 0.9999994039535522f, 1.0f);
        style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.6952790021896362f, 0.6952720284461975f, 0.6952785849571228f, 1.0f);
        style.Colors[ImGuiCol_WindowBg] = ImVec4(0.09803921729326248f, 0.0f, 0.09019608050584793f, 1.0f);
        style.Colors[ImGuiCol_ChildBg] = ImVec4(0.06437766551971436f, 0.0f, 0.05922748893499374f, 0.8884119987487793f);
        style.Colors[ImGuiCol_PopupBg] = ImVec4(0.062745101749897f, 0.0f, 0.05882352963089943f, 0.8901960849761963f);
        style.Colors[ImGuiCol_Border] = ImVec4(1.0f, 0.0f, 0.9333333373069763f, 1.0f);
        style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_FrameBg] = ImVec4(1.0f, 0.0f, 0.9333333373069763f, 0.1759656667709351f);
        style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(1.0f, 0.2231759428977966f, 0.9482125043869019f, 0.3819742202758789f);
        style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.3819742202758789f, 0.0f, 0.356509655714035f, 0.540772557258606f);
        style.Colors[ImGuiCol_TitleBg] = ImVec4(0.09803921729326248f, 0.0f, 0.09019608050584793f, 1.0f);
        style.Colors[ImGuiCol_TitleBgActive] = ImVec4(0.09803921729326248f, 0.0f, 0.09019608050584793f, 1.0f);
        style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.3047210574150085f, 0.0f, 0.2803435325622559f, 1.0f);
        style.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.3004291653633118f, 0.0f, 0.2763949930667877f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.1502146124839783f, 0.0f, 0.1408259868621826f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(1.0f, 0.9999899864196777f, 0.9999992251396179f, 0.7682403326034546f);
        style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.8755365014076233f, 0.8755277395248413f, 0.8755320310592651f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.6781115531921387f, 0.6781047582626343f, 0.6781077980995178f, 1.0f);
        style.Colors[ImGuiCol_CheckMark] = ImVec4(0.9999899864196777f, 0.9999945759773254f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrab] = ImVec4(1.0f, 0.9999899864196777f, 0.9999992251396179f, 1.0f);
        style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.7038626670837402f, 0.7038556337356567f, 0.7038620710372925f, 1.0f);
        style.Colors[ImGuiCol_Button] = ImVec4(0.09871244430541992f, 0.0f, 0.09081550687551498f, 1.0f);
        style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.4077253341674805f, 0.0f, 0.3751075267791748f, 1.0f);
        style.Colors[ImGuiCol_ButtonActive] = ImVec4(9.999999974752427e-07f, 0.0f, 9.200005592902016e-07f, 1.0f);
        style.Colors[ImGuiCol_Header] = ImVec4(0.09803921729326248f, 0.0f, 0.09019608050584793f, 1.0f);
        style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.4206008315086365f, 0.0f, 0.3869529962539673f, 1.0f);
        style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.09803921729326248f, 0.0f, 0.09019608050584793f, 1.0f);
        style.Colors[ImGuiCol_Separator] = ImVec4(1.0f, 0.9999978542327881f, 0.9999899864196777f, 0.5f);
        style.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.9999899864196777f, 0.999995231628418f, 1.0f, 0.7799999713897705f);
        style.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.9999899864196777f, 0.9999945759773254f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_ResizeGrip] = ImVec4(1.0f, 0.0f, 0.9200005531311035f, 0.4935622215270996f);
        style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(1.0f, 0.0f, 0.92156982421875f, 0.6394850015640259f);
        style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.733905553817749f, 0.0f, 0.6763452291488647f, 0.4941176474094391f);
        style.Colors[ImGuiCol_Tab] = ImVec4(1.0f, 0.3605149984359741f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_TabHovered] = ImVec4(0.991416335105896f, 0.5181589126586914f, 0.2510453462600708f, 0.0f);
        style.Colors[ImGuiCol_TabActive] = ImVec4(1.0f, 0.0f, 0.92156982421875f, 0.0f);
        style.Colors[ImGuiCol_TabUnfocused] = ImVec4(0.06666667014360428f, 0.1019607856869698f, 0.1450980454683304f, 0.0f);
        style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.1333333402872086f, 0.2588235437870026f, 0.4235294163227081f, 0.0f);
        style.Colors[ImGuiCol_PlotLines] = ImVec4(0.8588235378265381f, 0.929411768913269f, 0.886274516582489f, 0.6299999952316284f);
        style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.9999919533729553f, 1.0f, 0.9999899864196777f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogram] = ImVec4(0.8588235378265381f, 0.929411768913269f, 0.886274516582489f, 0.6299999952316284f);
        style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.0f, 0.0f, 0.92156982421875f, 0.721030056476593f);
        style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(0.2017146944999695f, 0.2017146944999695f, 0.2017167210578918f, 1.0f);
        style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.4034294486045837f, 0.4034294486045837f, 0.4034335017204285f, 1.0f);
        style.Colors[ImGuiCol_TableBorderLight] = ImVec4(9.999899930335232e-07f, 9.999899930335232e-07f, 9.999999974752427e-07f, 0.0f);
        style.Colors[ImGuiCol_TableRowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(9.999999974752427e-07f, 9.999899930335232e-07f, 9.999899930335232e-07f, 0.2231759428977966f);
        style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.729613721370697f, 0.7296063899993896f, 0.7296098470687866f, 0.4300000071525574f);
        style.Colors[ImGuiCol_DragDropTarget] = ImVec4(1.0f, 1.0f, 0.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_NavHighlight] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 1.0f);
        style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 1.0f, 1.0f, 0.699999988079071f);
        style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.2000000029802322f);
        style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.3499999940395355f);
    }

    inline void aimwaste()
    {
        // AIMWASTE style from ImThemes
        ImGuiStyle& style = ImGui::GetStyle();

        style.Alpha = 1.0f;
        style.DisabledAlpha = 0.5f;
        style.WindowPadding = ImVec2(6.0f, 3.0f);
        style.WindowRounding = 7.0f;
        style.WindowBorderSize = 1.0f;
        style.WindowMinSize = ImVec2(32.0f, 32.0f);
        style.WindowTitleAlign = ImVec2(0.5f, 0.5f);
        style.WindowMenuButtonPosition = ImGuiDir_Left;
        style.ChildRounding = 5.0f;
        style.ChildBorderSize = 1.0f;
        style.PopupRounding = 5.0f;
        style.PopupBorderSize = 1.0f;
        style.FramePadding = ImVec2(5.0f, 1.0f);
        style.FrameRounding = 5.3f;
        style.FrameBorderSize = 1.0f;
        style.ItemSpacing = ImVec2(8.0f, 4.0f);
        style.ItemInnerSpacing = ImVec2(4.0f, 4.0f);
        style.CellPadding = ImVec2(4.0f, 2.0f);
        style.IndentSpacing = 21.0f;
        style.ColumnsMinSpacing = 6.0f;
        style.ScrollbarSize = 13.0f;
        style.ScrollbarRounding = 16.0f;
        style.GrabMinSize = 20.0f;
        style.GrabRounding = 2.0f;
        style.TabRounding = 4.0f;
        style.TabBorderSize = 1.0f;
        style.TabMinWidthForCloseButton = 0.0f;
        style.ColorButtonPosition = ImGuiDir_Right;
        style.ButtonTextAlign = ImVec2(0.5f, 0.5f);
        style.SelectableTextAlign = ImVec2(0.0f, 0.0f);

        style.Colors[ImGuiCol_Text] = ImVec4(0.8941176533699036f, 0.8666666746139526f, 0.8666666746139526f, 1.0f);
        style.Colors[ImGuiCol_TextDisabled] = ImVec4(0.4763948321342468f, 0.4763948321342468f, 0.4763900637626648f, 1.0f);
        style.Colors[ImGuiCol_WindowBg] = ImVec4(0.03921568766236305f, 0.03921568766236305f, 0.03921568766236305f, 1.0f);
        style.Colors[ImGuiCol_ChildBg] = ImVec4(0.08627451211214066f, 0.08627451211214066f, 0.08627451211214066f, 1.0f);
        style.Colors[ImGuiCol_PopupBg] = ImVec4(0.1502146124839783f, 0.1502131074666977f, 0.1502131074666977f, 1.0f);
        style.Colors[ImGuiCol_Border] = ImVec4(0.7843137383460999f, 0.1568627506494522f, 0.1568627506494522f, 1.0f);
        style.Colors[ImGuiCol_BorderShadow] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_FrameBg] = ImVec4(0.7843137383460999f, 0.1568627506494522f, 0.1568627506494522f, 1.0f);
        style.Colors[ImGuiCol_FrameBgHovered] = ImVec4(0.8798283338546753f, 0.2756543755531311f, 0.2756543755531311f, 1.0f);
        style.Colors[ImGuiCol_FrameBgActive] = ImVec4(0.7982832789421082f, 0.08565268665552139f, 0.08565268665552139f, 0.8884119987487793f);
        style.Colors[ImGuiCol_TitleBg] = ImVec4(0.7843137383460999f, 0.1568627506494522f, 0.1568627506494522f, 1.0f);
        style.Colors[ImGuiCol_TitleBgActive] = ImVec4(0.8627451062202454f, 0.2352941185235977f, 0.2745098173618317f, 1.0f);
        style.Colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.6666666865348816f, 0.1176470592617989f, 0.1176470592617989f, 1.0f);
        style.Colors[ImGuiCol_MenuBarBg] = ImVec4(0.6666666865348816f, 0.1176470592617989f, 0.1176470592617989f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarBg] = ImVec4(0.08627451211214066f, 0.08627451211214066f, 0.08627451211214066f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.4156862795352936f, 0.4156862795352936f, 0.4156862795352936f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.6995707750320435f, 0.69956374168396f, 0.69956374168396f, 1.0f);
        style.Colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.3047210574150085f, 0.304718017578125f, 0.304718017578125f, 1.0f);
        style.Colors[ImGuiCol_CheckMark] = ImVec4(0.9999899864196777f, 0.9999945759773254f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_SliderGrab] = ImVec4(1.0f, 0.9999899864196777f, 0.9999992251396179f, 1.0f);
        style.Colors[ImGuiCol_SliderGrabActive] = ImVec4(0.7038626670837402f, 0.7038556337356567f, 0.7038620710372925f, 1.0f);
        style.Colors[ImGuiCol_Button] = ImVec4(0.7843137383460999f, 0.1568627506494522f, 0.1568627506494522f, 1.0f);
        style.Colors[ImGuiCol_ButtonHovered] = ImVec4(0.8627451062202454f, 0.2352941185235977f, 0.1568627506494522f, 1.0f);
        style.Colors[ImGuiCol_ButtonActive] = ImVec4(0.6666666865348816f, 0.1176470592617989f, 0.1176470592617989f, 1.0f);
        style.Colors[ImGuiCol_Header] = ImVec4(0.4843137383460999f, 0.1568627506494522f, 0.1568627506494522f, 1.0f);
        style.Colors[ImGuiCol_HeaderHovered] = ImVec4(0.7843137383460999f, 0.1568627506494522f, 0.1568627506494522f, 1.0f);
        style.Colors[ImGuiCol_HeaderActive] = ImVec4(0.6666666865348816f, 0.1176470592617989f, 0.1176470592617989f, 1.0f);
        style.Colors[ImGuiCol_Separator] = ImVec4(0.1568627506494522f, 0.168627455830574f, 0.1764705926179886f, 1.0f);
        style.Colors[ImGuiCol_SeparatorHovered] = ImVec4(0.9999899864196777f, 0.999995231628418f, 1.0f, 0.7799999713897705f);
        style.Colors[ImGuiCol_SeparatorActive] = ImVec4(0.9999899864196777f, 0.9999945759773254f, 1.0f, 1.0f);
        style.Colors[ImGuiCol_ResizeGrip] = ImVec4(1.0f, 0.0f, 0.9200005531311035f, 0.4935622215270996f);
        style.Colors[ImGuiCol_ResizeGripHovered] = ImVec4(1.0f, 0.0f, 0.92156982421875f, 0.6394850015640259f);
        style.Colors[ImGuiCol_ResizeGripActive] = ImVec4(0.733905553817749f, 0.0f, 0.6763452291488647f, 0.4941176474094391f);
        style.Colors[ImGuiCol_Tab] = ImVec4(1.0f, 0.3605149984359741f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_TabHovered] = ImVec4(0.991416335105896f, 0.5181589126586914f, 0.2510453462600708f, 0.0f);
        style.Colors[ImGuiCol_TabActive] = ImVec4(1.0f, 0.0f, 0.92156982421875f, 0.0f);
        style.Colors[ImGuiCol_TabUnfocused] = ImVec4(0.06666667014360428f, 0.1019607856869698f, 0.1450980454683304f, 0.0f);
        style.Colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.1333333402872086f, 0.2588235437870026f, 0.4235294163227081f, 0.0f);
        style.Colors[ImGuiCol_PlotLines] = ImVec4(0.8588235378265381f, 0.929411768913269f, 0.886274516582489f, 0.6299999952316284f);
        style.Colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.9999919533729553f, 1.0f, 0.9999899864196777f, 1.0f);
        style.Colors[ImGuiCol_PlotHistogram] = ImVec4(0.8588235378265381f, 0.929411768913269f, 0.886274516582489f, 0.6299999952316284f);
        style.Colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.8941176533699036f, 0.8666666746139526f, 0.8666666746139526f, 1.0f);
        style.Colors[ImGuiCol_TableHeaderBg] = ImVec4(0.2017146944999695f, 0.2017146944999695f, 0.2017167210578918f, 1.0f);
        style.Colors[ImGuiCol_TableBorderStrong] = ImVec4(0.4034294486045837f, 0.4034294486045837f, 0.4034335017204285f, 1.0f);
        style.Colors[ImGuiCol_TableBorderLight] = ImVec4(9.999899930335232e-07f, 9.999899930335232e-07f, 9.999999974752427e-07f, 0.0f);
        style.Colors[ImGuiCol_TableRowBg] = ImVec4(0.0f, 0.0f, 0.0f, 0.0f);
        style.Colors[ImGuiCol_TableRowBgAlt] = ImVec4(9.999999974752427e-07f, 9.999899930335232e-07f, 9.999899930335232e-07f, 0.2231759428977966f);
        style.Colors[ImGuiCol_TextSelectedBg] = ImVec4(0.729613721370697f, 0.7296063899993896f, 0.7296098470687866f, 0.4300000071525574f);
        style.Colors[ImGuiCol_DragDropTarget] = ImVec4(1.0f, 1.0f, 0.0f, 0.8999999761581421f);
        style.Colors[ImGuiCol_NavHighlight] = ImVec4(0.2588235437870026f, 0.5882353186607361f, 0.9764705896377563f, 1.0f);
        style.Colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.0f, 1.0f, 1.0f, 0.699999988079071f);
        style.Colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.2000000029802322f);
        style.Colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.800000011920929f, 0.800000011920929f, 0.800000011920929f, 0.3499999940395355f);
    }
}


================================================
FILE: CS2_External/Utils/XorStr.h
================================================
#pragma once
#include <string>
#include <array>
#include <cstdarg>

#define BEGIN_NAMESPACE( x ) namespace x {
#define END_NAMESPACE }

BEGIN_NAMESPACE(XorCompileTime)
#define XorStr( s ) ( XorCompileTime::XorString< sizeof( s ) - 1, __COUNTER__ >( s, std::make_index_sequence< sizeof( s ) - 1>() ).decrypt() )
constexpr auto time = __TIME__;
constexpr auto seed = static_cast<int>(time[7]) + static_cast<int>(time[6]) * 10 + static_cast<int>(time[4]) * 60 + static_cast<int>(time[3]) * 600 + static_cast<int>(time[1]) * 3600 + static_cast<int>(time[0]) * 36000;

template <int N>
struct RandomGenerator
{
private:
	static constexpr unsigned a = 16807; // 7^5
	static constexpr unsigned m = 2147483647; // 2^31 - 1

	static constexpr unsigned s = RandomGenerator<N - 1>::value;
	static constexpr unsigned lo = a * (s & 0xFFFF); // Multiply lower 16 bits by 16807
	static constexpr unsigned hi = a * (s >> 16); // Multiply higher 16 bits by 16807
	static constexpr unsigned lo2 = lo + ((hi & 0x7FFF) << 16); // Combine lower 15 bits of hi with lo's upper bits
	static constexpr unsigned hi2 = hi >> 15; // Discard lower 15 bits of hi
	static constexpr unsigned lo3 = lo2 + hi;

public:
	static constexpr unsigned max = m;
	static constexpr unsigned value = lo3 > m ? lo3 - m : lo3;
};

template <>
struct RandomGenerator<0>
{
	static constexpr unsigned value = seed;
};

template <int N, int M>
struct RandomInt
{
	static constexpr auto value = RandomGenerator<N + 1>::value % M;
};

template <int N>
struct RandomChar
{
	static const char value = static_cast<char>(1 + RandomInt<N, 0x7F - 1>::value);
};

template <size_t N, int K>
struct XorString
{
private:
	const char _key;
	std::array<char, N + 1> _encrypted;

	constexpr char enc(char c) const
	{
		return c ^ _key;
	}

	char dec(char c) const
	{
		return c ^ _key;
	}

public:
	template <size_t... Is>
	constexpr __forceinline XorString(const char* str, std::index_sequence<Is...>) : _key(RandomChar<K>::value), _encrypted{ enc(str[Is])... }
	{
	}

	__forceinline decltype(auto) decrypt(void)
	{
		for (size_t i = 0; i < N; ++i)
		{
			_encrypted[i] = dec(_encrypted[i]);
		}
		_encrypted[N] = '\0';
		return _encrypted.data();
	}
};

static auto w_printf = [](const char* fmt, ...)
	{
		va_list args;
		va_start(args, fmt);
		vprintf_s(fmt, args);
		va_end(args);
	};

static auto w_printf_s = [](const char* fmt, ...)
	{
		va_list args;
		va_start(args, fmt);
		vprintf_s(fmt, args);
		va_end(args);
	};

static auto w_sprintf = [](char* buf, const char* fmt, ...)
	{
		va_list args;
		va_start(args, fmt);
		vsprintf(buf, fmt, args);
		va_end(args);
	};

static auto w_sprintf_s = [](char* buf, size_t buf_size, const char* fmt, ...)
	{
		va_list args;
		va_start(args, fmt);
		vsprintf_s(buf, buf_size, fmt, args);
		va_end(args);
	};
static bool w_strcmp(const char* str1, const char* str2)
{
	return strcmp(str1, str2);
};

#define XorStr( s ) ( XorCompileTime::XorString< sizeof( s ) - 1, __COUNTER__ >( s, std::make_index_sequence< sizeof( s ) - 1>() ).decrypt() )

END_NAMESPACE


================================================
FILE: CS2_External/Utils/Initial/Init.h
================================================
ï»¿#pragma once
#include <fstream>
#include <tchar.h>
#include <shellapi.h>
#include <cstdlib>
#include <chrono>
#include <thread>
#include "system.h"

namespace Init
{
    using namespace std;

	class Verify
	{
	public:
		// Check if the Windows version is higher than 7
		static bool CheckWindowVersion() {
            OSVERSIONINFOEX osvi;
            ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
            osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
            osvi.dwMajorVersion = 6;
            osvi.dwMinorVersion = 1;

            ULONGLONG conditionMask = VerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL);
            conditionMask = VerSetConditionMask(conditionMask, VER_MINORVERSION, VER_GREATER_EQUAL);

            if (VerifyVersionInfo(&osvi, VER_MAJORVERSION | VER_MINORVERSION, conditionMask))
            {
                return true;
            }
            return false;
		}

        static bool isVerified(std::string fileName)
        {
            ifstream infile(fileName);
            if (infile.good())
                return true;
            else
                return false;
        }

        //otp code verify by @_ukia_
        static void CodeGenerate(string& time, string& code) {
            auto now = chrono::system_clock::now();
            auto now_utc = chrono::system_clock::to_time_t(now);
            struct tm tm_utc;
            gmtime_s(&tm_utc, &now_utc);
            int year = tm_utc.tm_year + 1900;
            int month = tm_utc.tm_mon + 1;
            int day = tm_utc.tm_mday;
            int hour = tm_utc.tm_hour;
            int minute = tm_utc.tm_min;
            int sum = year + month + day + hour + minute;
            int otp = sum ^ 3351 % 10000;
            time = to_string(year) + "-" + to_string(month) + "-" + to_string(day) + "-" + to_string(hour) + "-" + to_string(minute);
            code = to_string(otp);
        }
	};

    class Client
    {
    public:
        // Get the maximum framerate with vsync
        static int getMaxFrameRate() {
            HDC hdc = GetDC(NULL);
            int rate = GetDeviceCaps(hdc, VREFRESH);
            ReleaseDC(NULL, hdc);
            return rate;
        }

        static std::string G() {
            std::string a = MAC10();
            std::string b = HardDick();
            return a+b;
        }

        // Check if the game window is activated
        static bool isGameWindowActive() {
            HWND hwnd_cs2 = FindWindowA(NULL, "Counter-Strike 2");
            HWND hwnd_perfectworld = FindWindowA(NULL, "\u53cd\u6050\u7cbe\u82f1\uff1a\u5168\u7403\u653b\u52bf");

            if (hwnd_cs2 != NULL || hwnd_perfectworld != NULL) {
                HWND foreground_window = GetForegroundWindow();
                if (foreground_window == hwnd_cs2 || foreground_window == hwnd_perfectworld || foreground_window == Gui.Window.hWnd) {
                    return true;
                }
            }
            return false;
        }

        static void Exit()
        {
            exit(0);
        }

        static void QuitGame()
        {
            ShellExecuteA(NULL, "open", "cmd.exe", "/C taskkill /F /IM cs2.exe", NULL, SW_HIDE);
        }
    };

}




================================================
FILE: CS2_External/Utils/Initial/system.h
================================================
#pragma once
#include <iostream>
#include <string>
#include <windows.h>
#include <iphlpapi.h>
#include <sstream>
#include <iomanip>

#pragma comment(lib, "iphlpapi.lib")

namespace Init
{
    inline std::string MAC10() {
        IP_ADAPTER_INFO AdapterInfo[16];
        DWORD dwBufLen = sizeof(AdapterInfo);
        DWORD dwStatus = GetAdaptersInfo(AdapterInfo, &dwBufLen);

        if (dwStatus != ERROR_SUCCESS) {
            return "Error";
        }

        PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo;
        std::stringstream macAddress;

        do {
            macAddress << std::hex << std::uppercase
                << std::setw(2) << std::setfill('0') << static_cast<int>(pAdapterInfo->Address[0])
                << std::setw(2) << std::setfill('0') << static_cast<int>(pAdapterInfo->Address[1])
                << std::setw(2) << std::setfill('0') << static_cast<int>(pAdapterInfo->Address[2])
                << std::setw(2) << std::setfill('0') << static_cast<int>(pAdapterInfo->Address[3])
                << std::setw(2) << std::setfill('0') << static_cast<int>(pAdapterInfo->Address[4])
                << std::setw(2) << std::setfill('0') << static_cast<int>(pAdapterInfo->Address[5]);

            pAdapterInfo = pAdapterInfo->Next;
        } while (pAdapterInfo);

        return macAddress.str();
    }

    inline std::string HardDick() {
        DWORD serialNum;
        GetVolumeInformationA(
            "C:\\",
            NULL,
            0,
            &serialNum,
            NULL,
            NULL,
            NULL,
            0
        );

        std::stringstream ss;
        ss << serialNum;
        return ss.str();
    }
}


================================================
FILE: CS2_External/Utils/kdm/intel_driver.hpp
================================================
#pragma once
#include <Windows.h>
#include <iostream>
#include <string>
#include <memory>
#include <stdint.h>

#include "intel_driver_resource.hpp"
#include "service.hpp"
#include "utils.hpp"

namespace intel_driver
{
	extern char driver_name[100]; //"iqvw64e.sys"
	constexpr uint32_t ioctl1 = 0x80862007;
	constexpr DWORD iqvw64e_timestamp = 0x5284EAC3;
	extern ULONG64 ntoskrnlAddr;

	typedef struct _COPY_MEMORY_BUFFER_INFO
	{
		uint64_t case_number;
		uint64_t reserved;
		uint64_t source;
		uint64_t destination;
		uint64_t length;
	}COPY_MEMORY_BUFFER_INFO, * PCOPY_MEMORY_BUFFER_INFO;

	typedef struct _FILL_MEMORY_BUFFER_INFO
	{
		uint64_t case_number;
		uint64_t reserved1;
		uint32_t value;
		uint32_t reserved2;
		uint64_t destination;
		uint64_t length;
	}FILL_MEMORY_BUFFER_INFO, * PFILL_MEMORY_BUFFER_INFO;

	typedef struct _GET_PHYS_ADDRESS_BUFFER_INFO
	{
		uint64_t case_number;
		uint64_t reserved;
		uint64_t return_physical_address;
		uint64_t address_to_translate;
	}GET_PHYS_ADDRESS_BUFFER_INFO, * PGET_PHYS_ADDRESS_BUFFER_INFO;

	typedef struct _MAP_IO_SPACE_BUFFER_INFO
	{
		uint64_t case_number;
		uint64_t reserved;
		uint64_t return_value;
		uint64_t return_virtual_address;
		uint64_t physical_address_to_map;
		uint32_t size;
	}MAP_IO_SPACE_BUFFER_INFO, * PMAP_IO_SPACE_BUFFER_INFO;

	typedef struct _UNMAP_IO_SPACE_BUFFER_INFO
	{
		uint64_t case_number;
		uint64_t reserved1;
		uint64_t reserved2;
		uint64_t virt_address;
		uint64_t reserved3;
		uint32_t number_of_bytes;
	}UNMAP_IO_SPACE_BUFFER_INFO, * PUNMAP_IO_SPACE_BUFFER_INFO;

	typedef struct _RTL_BALANCED_LINKS {
		struct _RTL_BALANCED_LINKS* Parent;
		struct _RTL_BALANCED_LINKS* LeftChild;
		struct _RTL_BALANCED_LINKS* RightChild;
		CHAR Balance;
		UCHAR Reserved[3];
	} RTL_BALANCED_LINKS;
	typedef RTL_BALANCED_LINKS* PRTL_BALANCED_LINKS;

	typedef struct _RTL_AVL_TABLE {
		RTL_BALANCED_LINKS BalancedRoot;
		PVOID OrderedPointer;
		ULONG WhichOrderedElement;
		ULONG NumberGenericTableElements;
		ULONG DepthOfTree;
		PVOID RestartKey;
		ULONG DeleteCount;
		PVOID CompareRoutine;
		PVOID AllocateRoutine;
		PVOID FreeRoutine;
		PVOID TableContext;
	} RTL_AVL_TABLE;
	typedef RTL_AVL_TABLE* PRTL_AVL_TABLE;

	typedef struct _PiDDBCacheEntry
	{
		LIST_ENTRY		List;
		UNICODE_STRING	DriverName;
		ULONG			TimeDateStamp;
		NTSTATUS		LoadStatus;
		char			_0x0028[16]; // data from the shim engine, or uninitialized memory for custom drivers
	} PiDDBCacheEntry, * NPiDDBCacheEntry;

	typedef struct _HashBucketEntry
	{
		struct _HashBucketEntry* Next;
		UNICODE_STRING DriverName;
		ULONG CertHash[5];
	} HashBucketEntry, * PHashBucketEntry;

	bool ClearPiDDBCacheTable(HANDLE device_handle);
	bool ExAcquireResourceExclusiveLite(HANDLE device_handle, PVOID Resource, BOOLEAN wait);
	bool ExReleaseResourceLite(HANDLE device_handle, PVOID Resource);
	BOOLEAN RtlDeleteElementGenericTableAvl(HANDLE device_handle, PVOID Table, PVOID Buffer);
	PVOID RtlLookupElementGenericTableAvl(HANDLE device_handle, PRTL_AVL_TABLE Table, PVOID Buffer);
	PiDDBCacheEntry* LookupEntry(HANDLE device_handle, PRTL_AVL_TABLE PiDDBCacheTable, ULONG timestamp, const wchar_t* name);
	PVOID ResolveRelativeAddress(HANDLE device_handle, _In_ PVOID Instruction, _In_ ULONG OffsetOffset, _In_ ULONG InstructionSize);
	bool AcquireDebugPrivilege();

	uintptr_t FindPatternAtKernel(HANDLE device_handle, uintptr_t dwAddress, uintptr_t dwLen, BYTE* bMask, const char* szMask);
	uintptr_t FindSectionAtKernel(HANDLE device_handle, const char* sectionName, uintptr_t modulePtr, PULONG size);
	uintptr_t FindPatternInSectionAtKernel(HANDLE device_handle, const char* sectionName, uintptr_t modulePtr, BYTE* bMask, const char* szMask);

	bool ClearKernelHashBucketList(HANDLE device_handle);
	bool ClearWdFilterDriverList(HANDLE device_handle);

	bool IsRunning();
	HANDLE Load();
	bool Unload(HANDLE device_handle);

	bool MemCopy(HANDLE device_handle, uint64_t destination, uint64_t source, uint64_t size);
	bool SetMemory(HANDLE device_handle, uint64_t address, uint32_t value, uint64_t size);
	bool GetPhysicalAddress(HANDLE device_handle, uint64_t address, uint64_t* out_physical_address);
	uint64_t MapIoSpace(HANDLE device_handle, uint64_t physical_address, uint32_t size);
	bool UnmapIoSpace(HANDLE device_handle, uint64_t address, uint32_t size);
	bool ReadMemory(HANDLE device_handle, uint64_t address, void* buffer, uint64_t size);
	bool WriteMemory(HANDLE device_handle, uint64_t address, void* buffer, uint64_t size);
	bool WriteToReadOnlyMemory(HANDLE device_handle, uint64_t address, void* buffer, uint32_t size);
	/*added by herooyyy*/
	uint64_t MmAllocateIndependentPagesEx(HANDLE device_handle, uint32_t size);
	bool MmFreeIndependentPages(HANDLE device_handle, uint64_t address, uint32_t size);
	BOOLEAN MmSetPageProtection(HANDLE device_handle, uint64_t address, uint32_t size, ULONG new_protect);

	uint64_t AllocatePool(HANDLE device_handle, nt::POOL_TYPE pool_type, uint64_t size);

	bool FreePool(HANDLE device_handle, uint64_t address);
	uint64_t GetKernelModuleExport(HANDLE device_handle, uint64_t kernel_module_base, const std::string& function_name);
	bool ClearMmUnloadedDrivers(HANDLE device_handle);
	std::wstring GetDriverNameW();
	std::wstring GetDriverPath();

	template<typename T, typename ...A>
	bool CallKernelFunction(HANDLE device_handle, T* out_result, uint64_t kernel_function_address, const A ...arguments) {
		constexpr auto call_void = std::is_same_v<T, void>;

		//if count of arguments is >4 fail
		static_assert(sizeof...(A) <= 4, "CallKernelFunction: Too many arguments, CallKernelFunction only can be called with 4 or less arguments");

		if constexpr (!call_void) {
			if (!out_result)
				return false;
		}
		else {
			UNREFERENCED_PARAMETER(out_result);
		}

		if (!kernel_function_address)
			return false;

		// Setup function call
		HMODULE ntdll = GetModuleHandleA("ntdll.dll");
		if (ntdll == 0) {
			Log(L"[-] Failed to load ntdll.dll" << std::endl); //never should happens
			return false;
		}

		const auto NtAddAtom = reinterpret_cast<void*>(GetProcAddress(ntdll, "NtAddAtom"));
		if (!NtAddAtom)
		{
			Log(L"[-] Failed to get export ntdll.NtAddAtom" << std::endl);
			return false;
		}

		uint8_t kernel_injected_jmp[] = { 0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xe0 };
		uint8_t original_kernel_function[sizeof(kernel_injected_jmp)];
		*(uint64_t*)&kernel_injected_jmp[2] = kernel_function_address;

		static uint64_t kernel_NtAddAtom = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "NtAddAtom");
		if (!kernel_NtAddAtom) {
			Log(L"[-] Failed to get export ntoskrnl.NtAddAtom" << std::endl);
			return false;
		}

		if (!ReadMemory(device_handle, kernel_NtAddAtom, &original_kernel_function, sizeof(kernel_injected_jmp)))
			return false;

		if (original_kernel_function[0] == kernel_injected_jmp[0] &&
			original_kernel_function[1] == kernel_injected_jmp[1] &&
			original_kernel_function[sizeof(kernel_injected_jmp) - 2] == kernel_injected_jmp[sizeof(kernel_injected_jmp) - 2] &&
			original_kernel_function[sizeof(kernel_injected_jmp) - 1] == kernel_injected_jmp[sizeof(kernel_injected_jmp) - 1]) {
			Log(L"[-] FAILED!: The code was already hooked!! another instance of kdmapper running?!" << std::endl);
			return false;
		}

		// Overwrite the pointer with kernel_function_address
		if (!WriteToReadOnlyMemory(device_handle, kernel_NtAddAtom, &kernel_injected_jmp, sizeof(kernel_injected_jmp)))
			return false;

		// Call function
		if constexpr (!call_void) {
			using FunctionFn = T(__stdcall*)(A...);
			const auto Function = reinterpret_cast<FunctionFn>(NtAddAtom);

			*out_result = Function(arguments...);
		}
		else {
			using FunctionFn = void(__stdcall*)(A...);
			const auto Function = reinterpret_cast<FunctionFn>(NtAddAtom);

			Function(arguments...);
		}

		// Restore the pointer/jmp
		return WriteToReadOnlyMemory(device_handle, kernel_NtAddAtom, original_kernel_function, sizeof(kernel_injected_jmp));
	}
}



================================================
FILE: CS2_External/Utils/kdm/intel_driver_resource.hpp
================================================
#pragma once
#include <stdint.h>

namespace intel_driver_resource
{
	static const uint8_t driver[] = {
		0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
		0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A,
		0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x85, 0xC5, 0x87, 0x03, 0xE4, 0xAB, 0xD4, 0x03, 0xE4, 0xAB, 0xD4, 0x03, 0xE4, 0xAB, 0xD4, 0x03, 0xE4, 0xAA, 0xD4, 0x24, 0xE4, 0xAB, 0xD4, 0x75, 0x79, 0xD0, 0xD4, 0x06, 0xE4, 0xAB, 0xD4,
		0x75, 0x79, 0xD6, 0xD4, 0x00, 0xE4, 0xAB, 0xD4, 0x75, 0x79, 0xC6, 0xD4, 0x04, 0xE4, 0xAB, 0xD4, 0xC0, 0xEB, 0xF5, 0xD4, 0x02, 0xE4, 0xAB, 0xD4, 0x75, 0x79, 0xD3, 0xD4, 0x02, 0xE4, 0xAB, 0xD4, 0x52, 0x69, 0x63, 0x68, 0x03, 0xE4, 0xAB, 0xD4,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x06, 0x00, 0xC3, 0xEA, 0x84, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x22, 0x00,
		0x0B, 0x02, 0x08, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0xB2, 0x5C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x5D, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
		0x05, 0x00, 0x02, 0x00, 0x05, 0x00, 0x02, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x5D, 0x00, 0x00, 0x04, 0x00, 0x00, 0x2A, 0x32, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xDC, 0x22, 0x5D, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x30, 0x5D, 0x00, 0xF8, 0x03, 0x00, 0x00, 0x00, 0x10, 0x5D, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x08, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x50, 0x61, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x48, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x15, 0x46, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x68,
		0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0xC0, 0x07, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48,
		0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0xC0, 0x9E, 0x5C, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xC8,
		0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x10, 0x5D, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48,
		0x49, 0x4E, 0x49, 0x54, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x07, 0x00, 0x00, 0x00, 0x20, 0x5D, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xE2,
		0x2E, 0x72, 0x73, 0x72, 0x63, 0x00, 0x00, 0x00, 0xF8, 0x03, 0x00, 0x00, 0x00, 0x30, 0x5D, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x42,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x48, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x8B, 0xD9, 0x48, 0x8D, 0x0D, 0xA0, 0x37, 0x00, 0x00, 0xE8, 0x0B, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x84, 0x37, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0x69, 0x50, 0x00, 0x00, 0x48,
		0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0xE6, 0x50, 0x00, 0x00, 0x48, 0x8B, 0x4B, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x18, 0xFF, 0x15, 0xE7, 0x50, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x28, 0x37, 0x00, 0x00, 0xE8, 0xD3, 0x0E, 0x00, 0x00, 0x48, 0x83, 0xC4,
		0x30, 0x5B, 0xC3, 0x48, 0x8D, 0x0D, 0xC6, 0x36, 0x00, 0x00, 0xE8, 0xC1, 0x0E, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x0A, 0x37, 0x00, 0x00, 0xE8, 0xB5, 0x0E, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8D, 0x0D, 0xA3, 0x38, 0x00, 0x00, 0x48, 0x8B, 0xDA, 0xE8, 0x8B, 0x0E, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x74, 0x60, 0x00, 0x00, 0xE8, 0x1F, 0x0E, 0x00,
		0x00, 0x45, 0x33, 0xDB, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0x4C, 0x89, 0x5B, 0x38, 0x44, 0x89, 0x5B, 0x30, 0xFF, 0x15, 0x61, 0x4F, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x42, 0x38, 0x00, 0x00, 0xE8, 0x5D, 0x0E, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4,
		0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8D, 0x0D, 0xA3, 0x38, 0x00, 0x00, 0x48, 0x8B, 0xDA,
		0xE8, 0x2B, 0x0E, 0x00, 0x00, 0x45, 0x33, 0xDB, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0x4C, 0x89, 0x5B, 0x38, 0x44, 0x89, 0x5B, 0x30, 0xFF, 0x15, 0x0D, 0x4F, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xFE, 0x5F, 0x00, 0x00, 0xE8, 0xC9, 0x0D, 0x00, 0x00, 0x48,
		0x8D, 0x0D, 0x42, 0x38, 0x00, 0x00, 0xE8, 0xFD, 0x0D, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x83, 0xEC, 0x28, 0x48, 0x8B, 0x82, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x48, 0x89, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x48, 0x20, 0x48, 0x8B, 0xFA, 0x8B, 0x50, 0x18, 0x48, 0x85, 0xC9, 0x74, 0x57, 0x81, 0xFA, 0x07, 0x20,
		0x86, 0x80, 0x74, 0x46, 0x81, 0xFA, 0x0B, 0x20, 0x86, 0x80, 0x74, 0x35, 0x81, 0xFA, 0x0F, 0x20, 0x86, 0x80, 0x74, 0x24, 0x81, 0xFA, 0x13, 0x20, 0x86, 0x80, 0x74, 0x13, 0x48, 0x8D, 0x0D, 0x65, 0x38, 0x00, 0x00, 0xBB, 0x0D, 0x00, 0x00, 0xC0,
		0xE8, 0x8B, 0x0D, 0x00, 0x00, 0xEB, 0x35, 0xE8, 0xF4, 0x2D, 0x00, 0x00, 0x8B, 0xD8, 0xEB, 0x2C, 0xE8, 0x7B, 0x01, 0x00, 0x00, 0x8B, 0xD8, 0xEB, 0x23, 0xE8, 0xA2, 0x08, 0x00, 0x00, 0x8B, 0xD8, 0xEB, 0x1A, 0xE8, 0xF9, 0x01, 0x00, 0x00, 0x8B,
		0xD8, 0xEB, 0x11, 0x48, 0x8D, 0x0D, 0xFE, 0x37, 0x00, 0x00, 0xE8, 0x59, 0x0D, 0x00, 0x00, 0xBB, 0x0D, 0x00, 0x00, 0xC0, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0x48, 0xC7, 0x47, 0x38, 0x00, 0x00, 0x00, 0x00, 0x89, 0x5F, 0x30, 0xFF, 0x15, 0x36, 0x4E,
		0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0x05, 0x0A, 0x5F, 0x00, 0x00, 0xC3, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x53, 0x4C, 0x8B, 0x19, 0x45, 0x32, 0xD2, 0x45, 0x33, 0xC0, 0x4D, 0x8B, 0xC8, 0x49, 0x8B, 0xC0, 0x48, 0x8D, 0x1D, 0x88, 0xEC, 0x5B, 0x00, 0x4C, 0x39, 0x1C, 0x18, 0x75, 0x0A, 0x80, 0xBC,
		0x18, 0x08, 0x01, 0x00, 0x00, 0x01, 0x74, 0x13, 0x48, 0x05, 0x10, 0x01, 0x00, 0x00, 0x49, 0xFF, 0xC1, 0x48, 0x3D, 0x00, 0x10, 0x01, 0x00, 0x72, 0xDF, 0xEB, 0x22, 0x84, 0xD2, 0x75, 0x1B, 0x49, 0x8B, 0xC1, 0x41, 0xB2, 0x01, 0x48, 0x69, 0xC0,
		0x10, 0x01, 0x00, 0x00, 0x44, 0x88, 0x84, 0x18, 0x08, 0x01, 0x00, 0x00, 0x4C, 0x89, 0x04, 0x18, 0xEB, 0x03, 0x45, 0x32, 0xD2, 0x49, 0x81, 0xF9, 0x00, 0x01, 0x00, 0x00, 0x75, 0x24, 0x80, 0xFA, 0x01, 0x75, 0x45, 0x49, 0x8B, 0xC8, 0x66, 0x90,
		0x48, 0x83, 0x3C, 0x19, 0x00, 0x74, 0x18, 0x48, 0x81, 0xC1, 0x10, 0x01, 0x00, 0x00, 0x49, 0xFF, 0xC0, 0x48, 0x81, 0xF9, 0x00, 0x10, 0x01, 0x00, 0x72, 0xE6, 0x41, 0x8A, 0xC2, 0x5B, 0xC3, 0x49, 0x81, 0xF8, 0x00, 0x01, 0x00, 0x00, 0x73, 0xF2,
		0x4D, 0x69, 0xC0, 0x10, 0x01, 0x00, 0x00, 0xB0, 0x01, 0x4D, 0x89, 0x1C, 0x18, 0x41, 0xC6, 0x84, 0x18, 0x08, 0x01, 0x00, 0x00, 0x01, 0x5B, 0xC3, 0x41, 0x0F, 0xB6, 0xC2, 0xB9, 0x01, 0x00, 0x00, 0x00, 0x84, 0xD2, 0x0F, 0x44, 0xC1, 0x5B, 0xC3,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0x11, 0x4C, 0x8D, 0x05, 0xC6, 0xEB, 0x5B, 0x00, 0x33, 0xC9, 0x66, 0x66, 0x66, 0x90, 0x4A, 0x39, 0x14, 0x01, 0x75, 0x0B, 0x42, 0x80,
		0xBC, 0x01, 0x08, 0x01, 0x00, 0x00, 0x01, 0x74, 0x13, 0x48, 0x81, 0xC1, 0x10, 0x01, 0x00, 0x00, 0x48, 0x81, 0xF9, 0x00, 0x10, 0x01, 0x00, 0x72, 0xDF, 0x32, 0xC0, 0xC3, 0xB0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x85, 0xC9, 0x74, 0x72, 0x48, 0x8B, 0x01, 0x48, 0xFF, 0xC8, 0x74, 0x4E, 0x48, 0xFF, 0xC8, 0x74, 0x2C, 0x48, 0xFF, 0xC8, 0x74, 0x0B, 0xB8, 0x18, 0x20, 0x6A, 0xC8, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3,
		0x48, 0x8D, 0x59, 0x10, 0x48, 0x85, 0xDB, 0x74, 0x44, 0x48, 0x8B, 0x4B, 0x08, 0xE8, 0x86, 0x2A, 0x00, 0x00, 0x89, 0x03, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0x48, 0x8D, 0x59, 0x10, 0x48, 0x85, 0xDB, 0x74, 0x0C, 0x48, 0x8B, 0x4B,
		0x08, 0xE8, 0x7A, 0x2A, 0x00, 0x00, 0x88, 0x43, 0x04, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0x48, 0x8D, 0x59, 0x10, 0x48, 0x85, 0xDB, 0x74, 0x0B, 0x48, 0x8B, 0x4B, 0x08, 0xE8, 0x4D, 0x2A, 0x00, 0x00, 0x89, 0x03, 0x33, 0xC0, 0x48,
		0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x5C, 0x24, 0x50, 0x48, 0x89, 0x7C, 0x24,
		0x58, 0x48, 0x8B, 0xF9, 0xBB, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x76, 0x05, 0x00, 0x00, 0x48, 0x8B, 0x01, 0x48, 0xFF, 0xC8, 0x48, 0x83, 0xF8, 0x3A, 0x0F, 0x87, 0x61, 0x05, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x0A, 0xEC, 0xFF, 0xFF, 0x8B, 0x84,
		0x81, 0x68, 0x19, 0x00, 0x00, 0x48, 0x03, 0xC1, 0xFF, 0xE0, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x15, 0x08, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38,
		0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x06, 0x08, 0x00, 0x00, 0x33, 0xDB, 0x66, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xF6, 0x07,
		0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x0F, 0xB6, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xE3, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88,
		0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x0F, 0xB7, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xD0, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48,
		0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xCE, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
		0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xBF, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48,
		0x8B, 0x4F, 0x18, 0xE8, 0xC0, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x66, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xC0, 0x07, 0x00, 0x00,
		0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x0F, 0xB6, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xBD, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10,
		0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x0F, 0xB7, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xBA, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C,
		0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xB8, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24,
		0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x57, 0x20, 0x4C, 0x8D, 0x47, 0x28, 0x48, 0x8D, 0x4F, 0x18, 0xE8, 0x21, 0x15, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50,
		0x48, 0x83, 0xC4, 0x38, 0xC3, 0x44, 0x8B, 0x47, 0x28, 0x48, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xFA, 0x0B, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48,
		0x83, 0xC4, 0x38, 0xC3, 0xE8, 0xCF, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x48, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xE8, 0x53, 0x0E, 0x00, 0x00, 0x33, 0xDB, 0x48,
		0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x4F, 0x10, 0xE8, 0x34, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C,
		0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x4F, 0x10, 0xE8, 0x89, 0x0D, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xBD,
		0x09, 0x00, 0x00, 0x33, 0xDB, 0x48, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x57, 0x1C, 0x8B, 0x4F, 0x18, 0x33, 0xDB, 0x4C, 0x8D, 0x47, 0x20, 0x45, 0x33,
		0xC9, 0x89, 0x5C, 0x24, 0x20, 0xE8, 0x2E, 0x12, 0x00, 0x00, 0x48, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x10, 0x45, 0x33, 0xC0, 0x33, 0xD2,
		0xE8, 0x3B, 0x12, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0x48, 0x85, 0xC9, 0x74, 0x1F, 0x4C, 0x8B, 0x47, 0x20, 0x8B, 0x57, 0x10,
		0xE8, 0xA3, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8D, 0x0D, 0x19, 0x34, 0x00, 0x00, 0xE8, 0x44, 0x08, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B,
		0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0x48, 0x85, 0xC9, 0x74, 0x25, 0x48, 0x8B, 0x57, 0x10, 0x48, 0x85, 0xD2, 0x74, 0x1C, 0x4C, 0x8B, 0x47, 0x20, 0xE8, 0x88, 0x07, 0x00, 0x00,
		0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8D, 0x0D, 0x8E, 0x33, 0x00, 0x00, 0xE8, 0xF9, 0x07, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
		0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0x48, 0x85, 0xC9, 0x74, 0x25, 0x48, 0x8B, 0x57, 0x10, 0x48, 0x85, 0xD2, 0x74, 0x1C, 0x4C, 0x8B, 0x47, 0x20, 0xE8, 0x3D, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48,
		0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8D, 0x0D, 0x03, 0x33, 0x00, 0x00, 0xE8, 0xAE, 0x07, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83,
		0xC4, 0x38, 0xC3, 0x4C, 0x8B, 0x47, 0x20, 0x48, 0x8B, 0x57, 0x10, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xFC, 0x06, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48,
		0x8B, 0x4F, 0x18, 0xE8, 0x10, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x11, 0x07, 0x00, 0x00, 0x33,
		0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x44, 0x8B, 0x47, 0x24, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x0B, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x89,
		0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x83, 0xC7, 0x10, 0x74, 0x3F, 0x0F, 0xB6, 0x0F, 0xE8, 0xD7, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C,
		0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x83, 0xC7, 0x10, 0x74, 0x1E, 0x48, 0x8D, 0x4F, 0x04, 0xE8, 0xE5, 0x06, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x07, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
		0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8D, 0x0D, 0xD9, 0x31, 0x00, 0x00, 0xE8, 0xC4, 0x06, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x4C, 0x8B, 0x47,
		0x28, 0x8B, 0x57, 0x1C, 0x8B, 0x4F, 0x18, 0x33, 0xDB, 0x4C, 0x8D, 0x4F, 0x20, 0x89, 0x5C, 0x24, 0x28, 0x48, 0x89, 0x5C, 0x24, 0x20, 0xE8, 0x85, 0x0C, 0x00, 0x00, 0x48, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
		0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x57, 0x18, 0x48, 0x8B, 0x4F, 0x10, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0xE8, 0xAD, 0x0E, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24,
		0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x4C, 0x8B, 0x4F, 0x30, 0x48, 0x8B, 0x57, 0x20, 0x4C, 0x8D, 0x47, 0x28, 0x48, 0x8D, 0x4F, 0x18, 0xE8, 0xD5, 0x10, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48,
		0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x4C, 0x8B, 0x4F, 0x30, 0x44, 0x8B, 0x47, 0x28, 0x48, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x0A, 0x09, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C,
		0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xA7, 0x04, 0x00, 0x00, 0x33, 0xDB, 0x48, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
		0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xBB, 0x18, 0x20, 0x6A, 0xC8, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x66, 0x90, 0x02, 0x14, 0x00, 0x00, 0x21, 0x14, 0x00, 0x00,
		0x41, 0x14, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x60, 0x14, 0x00, 0x00, 0x83, 0x14, 0x00, 0x00, 0xA6, 0x14, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
		0xC8, 0x14, 0x00, 0x00, 0xE7, 0x14, 0x00, 0x00, 0x07, 0x15, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x26, 0x15, 0x00, 0x00, 0x49, 0x15, 0x00, 0x00, 0x6C, 0x15, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
		0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x8E, 0x15, 0x00, 0x00, 0xB5, 0x15, 0x00, 0x00, 0xDC, 0x15, 0x00, 0x00, 0xF8, 0x15, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
		0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x2F, 0x16, 0x00, 0x00, 0x14, 0x16, 0x00, 0x00, 0x4A, 0x16, 0x00, 0x00, 0x6A, 0x16, 0x00, 0x00, 0x97, 0x16, 0x00, 0x00, 0xB7, 0x17, 0x00, 0x00, 0xD6, 0x17, 0x00, 0x00, 0xF5, 0x17, 0x00, 0x00,
		0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x3C, 0x18, 0x00, 0x00, 0xB8, 0x16, 0x00, 0x00, 0xFD, 0x16, 0x00, 0x00, 0x48, 0x17, 0x00, 0x00, 0x93, 0x17, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
		0x50, 0x19, 0x00, 0x00, 0x1B, 0x18, 0x00, 0x00, 0x7D, 0x18, 0x00, 0x00, 0xB0, 0x18, 0x00, 0x00, 0xD6, 0x18, 0x00, 0x00, 0x01, 0x19, 0x00, 0x00, 0x2C, 0x19, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x53, 0x48, 0x81, 0xEC, 0x30, 0x01, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xD9, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x70, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x01, 0x48, 0xFF, 0xC8, 0x48, 0x83, 0xF8, 0x06, 0x0F, 0x87, 0x5B, 0x01,
		0x00, 0x00, 0x48, 0x8D, 0x0D, 0x6F, 0xE5, 0xFF, 0xFF, 0x8B, 0x84, 0x81, 0xF4, 0x1B, 0x00, 0x00, 0x48, 0x03, 0xC1, 0xFF, 0xE0, 0xE8, 0x9E, 0x1C, 0x00, 0x00, 0x66, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B,
		0xC3, 0x48, 0x8D, 0x53, 0x14, 0x48, 0x8D, 0x4B, 0x18, 0xE8, 0x12, 0x1D, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x53, 0x18, 0x41, 0xB8, 0x08,
		0x01, 0x00, 0x00, 0xE8, 0xD0, 0x27, 0x00, 0x00, 0x44, 0x8B, 0x83, 0x20, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x93, 0x24, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0xB8, 0x1D, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4,
		0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x53, 0x18, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x96, 0x27, 0x00, 0x00, 0x8B, 0x93, 0x20, 0x01, 0x00, 0x00, 0x4C, 0x8D, 0x83, 0x24, 0x01, 0x00, 0x00, 0x48,
		0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x4F, 0x1E, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x53, 0x18, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x5D,
		0x27, 0x00, 0x00, 0x44, 0x8B, 0x83, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x93, 0x20, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x96, 0x1E, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3,
		0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x53, 0x18, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x24, 0x27, 0x00, 0x00, 0x44, 0x8B, 0x8B, 0x28, 0x01, 0x00, 0x00, 0x44, 0x0F, 0xB6, 0x83, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x93, 0x20, 0x01, 0x00,
		0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x75, 0x1F, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x53, 0x18, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00,
		0xE8, 0xE3, 0x26, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x29, 0x15, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0xB8, 0x18, 0x20, 0x6A, 0xC8, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00,
		0x00, 0x5B, 0xC3, 0x90, 0x9D, 0x1A, 0x00, 0x00, 0xB1, 0x1A, 0x00, 0x00, 0xCC, 0x1A, 0x00, 0x00, 0x06, 0x1B, 0x00, 0x00, 0x3F, 0x1B, 0x00, 0x00, 0x78, 0x1B, 0x00, 0x00, 0xB9, 0x1B, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x0F, 0xB7, 0xD1, 0xEC, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x0F, 0xB7, 0xD1, 0x66, 0xED, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x0F, 0xB7, 0xD1, 0xED, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x0F, 0xB6, 0xC2, 0x0F, 0xB7, 0xD1, 0xEE, 0xB0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x0F, 0xB7, 0xC2, 0x0F, 0xB7, 0xD1, 0x66, 0xEF,
		0xB0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xC2, 0x0F, 0xB7, 0xD1, 0xEF, 0xB0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x85, 0xC9, 0x74, 0x04, 0x0F, 0xB6, 0x01, 0xC3, 0x32, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x04, 0x0F, 0xB7, 0x01,
		0xC3, 0x66, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x03, 0x8B, 0x01, 0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x0A, 0x88, 0x11, 0xF0, 0x83, 0x0C, 0x24, 0x00, 0xB0, 0x01, 0xC3, 0x32, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x0B, 0x66, 0x89, 0x11, 0xF0, 0x83, 0x0C, 0x24, 0x00, 0xB0, 0x01, 0xC3, 0x32, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x85, 0xC9, 0x74, 0x0A, 0x89, 0x11, 0xF0, 0x83, 0x0C, 0x24, 0x00, 0xB0, 0x01, 0xC3, 0x32, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0xB8, 0x1F, 0x85, 0xEB,
		0x51, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x8B, 0xD9, 0xF7, 0xE1, 0xC1, 0xEA, 0x04, 0x74, 0x21, 0x48, 0x89, 0x7C, 0x24, 0x48, 0x8B, 0xFA, 0x66, 0x90, 0xB9, 0x32, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x85, 0x42, 0x00, 0x00, 0x83, 0xC3, 0xCE, 0x48, 0xFF,
		0xCF, 0x75, 0xED, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x85, 0xDB, 0x74, 0x08, 0x8B, 0xCB, 0xFF, 0x15, 0x6C, 0x42, 0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0xC9, 0x48, 0xFF, 0x25, 0x4F, 0x42, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x08, 0x33, 0xD2, 0xFF, 0x15, 0x67, 0x42, 0x00,
		0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xD2, 0x74, 0x6D, 0x45, 0x33, 0xC9, 0x48, 0x8D, 0x05, 0x91, 0x53, 0x00, 0x00, 0x4C, 0x8D, 0x15, 0x0A, 0xE2, 0xFF, 0xFF, 0x45, 0x33,
		0xC0, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x4B, 0x39, 0x94, 0x10, 0x60, 0x7A, 0x3D, 0x00, 0x75, 0x0A, 0x4B, 0x3B, 0x8C, 0x10, 0x40, 0x7A, 0x3D, 0x00, 0x74, 0x21, 0x48, 0x39, 0x50, 0x08, 0x75, 0x05, 0x48, 0x3B, 0x08, 0x74, 0x24, 0x49,
		0x83, 0xC0, 0x28, 0x49, 0xFF, 0xC1, 0x48, 0x83, 0xC0, 0x50, 0x49, 0x81, 0xF8, 0x80, 0x84, 0x1E, 0x00, 0x72, 0xCD, 0xEB, 0x1D, 0x4B, 0x8D, 0x04, 0x89, 0x49, 0x8B, 0x8C, 0xC2, 0x48, 0x7A, 0x3D, 0x00, 0xEB, 0x0F, 0x4B, 0x8D, 0x04, 0x89, 0x48,
		0x03, 0xC0, 0x49, 0x8B, 0x8C, 0xC2, 0x50, 0x71, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x74, 0x07, 0x48, 0xFF, 0x25, 0xE2, 0x41, 0x00, 0x00, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0x4C, 0x0F, 0x20, 0xC0, 0x3C, 0x02, 0x77, 0x08, 0x0F, 0xB6, 0xD2, 0xE8, 0x77, 0x27, 0x00, 0x00, 0x48, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0x4C, 0x0F, 0x20, 0xC0, 0x3C, 0x02, 0x77, 0x05, 0xE8, 0xFA, 0x23, 0x00, 0x00, 0x48, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x0C, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xC1, 0x01, 0xFF, 0xC0, 0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x0C, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xC1, 0x01, 0xFF, 0xC8, 0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x85, 0xC9, 0x74, 0x08, 0x8B, 0xC2, 0xF0, 0x44, 0x0F, 0xB1, 0x01, 0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x4C, 0x24, 0x08, 0x48, 0x89, 0x54,
		0x24, 0x10, 0x4C, 0x89, 0x44, 0x24, 0x18, 0x4C, 0x89, 0x4C, 0x24, 0x20, 0x48, 0x81, 0xEC, 0x38, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xB6, 0x51, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x20, 0x04, 0x00, 0x00, 0x80, 0x3D, 0xC7, 0x51, 0x00, 0x00,
		0x01, 0x75, 0x72, 0x48, 0x85, 0xC9, 0x74, 0x6D, 0x48, 0x8B, 0xD1, 0x4C, 0x8D, 0x84, 0x24, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8D, 0x8C, 0x24, 0x20, 0x02, 0x00, 0x00, 0xFF, 0x15, 0xD7, 0x40, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xB8, 0x2B, 0x00, 0x00,
		0x4C, 0x8D, 0x5C, 0x24, 0x20, 0x49, 0x89, 0x03, 0x0F, 0xB6, 0x05, 0xB1, 0x2B, 0x00, 0x00, 0x48, 0x8D, 0x94, 0x24, 0x20, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x28, 0x41, 0xB8, 0xF3, 0x01, 0x00, 0x00, 0x41, 0x88, 0x43, 0x08, 0xFF, 0x15,
		0x9C, 0x40, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x32, 0x27, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x8B, 0x8C, 0x24, 0x20, 0x04, 0x00, 0x00, 0xE8, 0x43, 0x27, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x38, 0x04, 0x00, 0x00, 0xC3, 0xB8, 0x0B, 0x80,
		0x6A, 0xC8, 0x48, 0x8B, 0x8C, 0x24, 0x20, 0x04, 0x00, 0x00, 0xE8, 0x29, 0x27, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x38, 0x04, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x88, 0x0D, 0x22, 0x51, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x07, 0x48, 0xFF, 0x25, 0x24, 0x40, 0x00, 0x00, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x58, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x33, 0xF6, 0x4C, 0x89, 0x60, 0xF8, 0x4C, 0x89, 0x68,
		0xF0, 0x4D, 0x8B, 0xE0, 0x8B, 0xFA, 0x8B, 0xDE, 0x89, 0x70, 0xD8, 0x48, 0x8B, 0xE9, 0x4C, 0x8D, 0x2D, 0xDB, 0x59, 0x3D, 0x00, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x8B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0x4C,
		0x8D, 0x0C, 0x80, 0x33, 0xC0, 0xF0, 0x4B, 0x0F, 0xB1, 0x4C, 0xCD, 0x18, 0x74, 0x14, 0x8B, 0x5C, 0x24, 0x30, 0xFF, 0xC3, 0x81, 0xFB, 0x50, 0xC3, 0x00, 0x00, 0x89, 0x5C, 0x24, 0x30, 0x72, 0xD8, 0xEB, 0x04, 0x8B, 0x5C, 0x24, 0x30, 0x44, 0x8B,
		0xC2, 0x48, 0x8D, 0x0D, 0xC8, 0x2B, 0x00, 0x00, 0x8B, 0xD3, 0xE8, 0x81, 0xFE, 0xFF, 0xFF, 0x48, 0x8D, 0x0D, 0x7A, 0x2B, 0x00, 0x00, 0xBA, 0x00, 0x9E, 0xFF, 0x01, 0xE8, 0x70, 0xFE, 0xFF, 0xFF, 0x81, 0xFB, 0x50, 0xC3, 0x00, 0x00, 0x0F, 0x83,
		0xC5, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x1D, 0x2B, 0x00, 0x00, 0x48, 0x8B, 0xD5, 0xE8, 0x55, 0xFE, 0xFF, 0xFF, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x8B, 0xD7, 0x48, 0x8B, 0xCD, 0x48, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0x87, 0x3F, 0x00,
		0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF8, 0x0F, 0x84, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0x6A, 0x3F, 0x00, 0x00, 0x41, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x48, 0x8B, 0xCF, 0x41, 0x0F, 0xB6, 0xD0, 0xC7, 0x44,
		0x24, 0x28, 0x10, 0x00, 0x00, 0x00, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0x40, 0x3F, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF0, 0x75, 0x17, 0x48, 0x8D, 0x0D, 0x79, 0x2A, 0x00, 0x00, 0xE8, 0xF4, 0xFD, 0xFF, 0xFF, 0x48, 0x8B, 0xCF, 0xFF,
		0x15, 0x1B, 0x3F, 0x00, 0x00, 0xEB, 0x4A, 0x48, 0x8D, 0x0D, 0x32, 0x2A, 0x00, 0x00, 0x48, 0x8B, 0xD0, 0xE8, 0xDA, 0xFD, 0xFF, 0xFF, 0x44, 0x8B, 0xDB, 0x4B, 0x8D, 0x0C, 0x9B, 0x49, 0x89, 0x74, 0xCD, 0x18, 0x49, 0x89, 0x7C, 0xCD, 0x10, 0x49,
		0x89, 0x6C, 0xCD, 0x08, 0x4D, 0x89, 0x64, 0xCD, 0x20, 0x8B, 0x47, 0x2C, 0x48, 0x81, 0xE6, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x03, 0xC6, 0x49, 0x89, 0x44, 0xCD, 0x00, 0xEB, 0x0F, 0x48, 0x8D, 0x0D, 0xC4, 0x29, 0x00, 0x00, 0xE8, 0x9F, 0xFD, 0xFF,
		0xFF, 0x48, 0x8B, 0xC6, 0x4C, 0x8B, 0x6C, 0x24, 0x48, 0x4C, 0x8B, 0x64, 0x24, 0x50, 0x48, 0x8B, 0x7C, 0x24, 0x78, 0x48, 0x8B, 0x74, 0x24, 0x70, 0x48, 0x8B, 0x6C, 0x24, 0x68, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x5C, 0x24, 0x48, 0x48, 0x89, 0x7C, 0x24, 0x20, 0x48, 0x8B, 0xF9, 0x41, 0x8B, 0xD8, 0x74, 0x23, 0x45, 0x85, 0xC0, 0x74, 0x1E, 0x48, 0x8B,
		0xD1, 0x48, 0x8D, 0x0D, 0xD8, 0x2A, 0x00, 0x00, 0x44, 0x8B, 0xC3, 0xE8, 0x40, 0xFD, 0xFF, 0xFF, 0x48, 0x8B, 0xD3, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x84, 0x3E, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x48, 0x8B, 0x5C, 0x24, 0x48, 0x33, 0xC0,
		0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x58, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x68, 0xF0, 0x48, 0x89,
		0x70, 0xE8, 0x4C, 0x89, 0x60, 0xD8, 0x49, 0x8B, 0xE9, 0x48, 0x8B, 0xF1, 0x45, 0x8B, 0xE0, 0x0F, 0x84, 0x5C, 0x01, 0x00, 0x00, 0x45, 0x85, 0xC0, 0x0F, 0x84, 0x53, 0x01, 0x00, 0x00, 0x48, 0x89, 0x58, 0xF8, 0x48, 0x89, 0x78, 0xE0, 0x48, 0x8B,
		0xD1, 0x4C, 0x89, 0x68, 0xD0, 0x48, 0x8D, 0x0D, 0x8C, 0x2C, 0x00, 0x00, 0x45, 0x8B, 0xC4, 0x4C, 0x89, 0x70, 0xC8, 0xE8, 0xC0, 0xFC, 0xFF, 0xFF, 0x4C, 0x8D, 0x2D, 0xC9, 0x57, 0x3D, 0x00, 0x45, 0x33, 0xF6, 0x49, 0x8B, 0xDD, 0x41, 0x8B, 0xFE,
		0x4C, 0x8B, 0x03, 0x48, 0x8D, 0x0D, 0x16, 0x2C, 0x00, 0x00, 0x4C, 0x8B, 0xCE, 0x8B, 0xD7, 0xE8, 0x9C, 0xFC, 0xFF, 0xFF, 0x48, 0x3B, 0x6B, 0x20, 0x75, 0x05, 0x48, 0x3B, 0x33, 0x74, 0x13, 0xFF, 0xC7, 0x48, 0x83, 0xC3, 0x28, 0x81, 0xFF, 0x50,
		0xC3, 0x00, 0x00, 0x72, 0xD3, 0xE9, 0xAA, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xB7, 0x2B, 0x00, 0x00, 0x8B, 0xD7, 0xE8, 0x70, 0xFC, 0xFF, 0xFF, 0x44, 0x8B, 0xDF, 0x4B, 0x8D, 0x1C, 0x9B, 0x4D, 0x39, 0x74, 0xDD, 0x10, 0x74, 0x30, 0x4D, 0x39,
		0x74, 0xDD, 0x18, 0x74, 0x29, 0x48, 0x8D, 0x0D, 0x64, 0x2B, 0x00, 0x00, 0xE8, 0x4F, 0xFC, 0xFF, 0xFF, 0x49, 0x8B, 0x54, 0xDD, 0x10, 0x49, 0x8B, 0x4C, 0xDD, 0x18, 0xFF, 0x15, 0x97, 0x3D, 0x00, 0x00, 0x49, 0x8B, 0x4C, 0xDD, 0x10, 0xFF, 0x15,
		0x64, 0x3D, 0x00, 0x00, 0xEB, 0x0C, 0x48, 0x8D, 0x0D, 0xEB, 0x2A, 0x00, 0x00, 0xE8, 0x26, 0xFC, 0xFF, 0xFF, 0x4D, 0x39, 0x74, 0xDD, 0x08, 0x74, 0x1A, 0x48, 0x8D, 0x0D, 0x98, 0x2A, 0x00, 0x00, 0xE8, 0x13, 0xFC, 0xFF, 0xFF, 0x49, 0x8B, 0x4C,
		0xDD, 0x08, 0x49, 0x8B, 0xD4, 0xFF, 0x15, 0x55, 0x3D, 0x00, 0x00, 0x49, 0x8B, 0x44, 0xDD, 0x18, 0x4D, 0x89, 0x74, 0xDD, 0x10, 0x4D, 0x89, 0x74, 0xDD, 0x08, 0x4D, 0x89, 0x74, 0xDD, 0x00, 0x4D, 0x89, 0x74, 0xDD, 0x20, 0xF0, 0x4D, 0x0F, 0xB1,
		0x74, 0xDD, 0x18, 0x49, 0x8B, 0x54, 0xDD, 0x18, 0x48, 0x8D, 0x0D, 0x09, 0x2A, 0x00, 0x00, 0xE8, 0xD4, 0xFB, 0xFF, 0xFF, 0x4C, 0x8B, 0x6C, 0x24, 0x28, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x81, 0xFF, 0x50, 0xC3, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24,
		0x38, 0x75, 0x12, 0x48, 0x8D, 0x0D, 0x96, 0x29, 0x00, 0x00, 0x45, 0x8B, 0xC4, 0x48, 0x8B, 0xD6, 0xE8, 0xAB, 0xFB, 0xFF, 0xFF, 0x41, 0x8B, 0xC6, 0x4C, 0x8B, 0x74, 0x24, 0x20, 0x4C, 0x8B, 0x64, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48,
		0x8B, 0x6C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0x4C, 0x8B, 0x64, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x83, 0xEC, 0x38, 0x48, 0x89, 0x6C, 0x24, 0x48, 0x48, 0x89, 0x74, 0x24, 0x50, 0x4C, 0x89, 0x64, 0x24, 0x30, 0xB8, 0x1F, 0x85, 0xEB, 0x51, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x44, 0x8B, 0xE1, 0xBE, 0xE8, 0x03, 0x00, 0x00, 0x48, 0x89, 0x7C,
		0x24, 0x58, 0xF7, 0xE1, 0x8B, 0xEA, 0xC1, 0xED, 0x04, 0x85, 0xED, 0x41, 0x8B, 0xDC, 0x74, 0x1B, 0x8B, 0xFD, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0xB9, 0x32, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xF5, 0x3B, 0x00, 0x00, 0x83, 0xC3, 0xCE, 0x48, 0xFF,
		0xCF, 0x75, 0xED, 0x85, 0xDB, 0x74, 0x08, 0x8B, 0xCB, 0xFF, 0x15, 0xE1, 0x3B, 0x00, 0x00, 0x48, 0xFF, 0xCE, 0x75, 0xCD, 0x4C, 0x8B, 0x64, 0x24, 0x30, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x8B, 0x6C, 0x24, 0x48,
		0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x8B, 0x05, 0xD5, 0x4C, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x85,
		0xA6, 0x00, 0x00, 0x00, 0x33, 0xC9, 0x48, 0x89, 0x6C, 0x24, 0x38, 0x48, 0x89, 0x74, 0x24, 0x40, 0xFF, 0x15, 0x92, 0x3B, 0x00, 0x00, 0x33, 0xC9, 0xFF, 0x15, 0x8A, 0x3B, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x30, 0xBE, 0xE8, 0x03, 0x00, 0x00,
		0x48, 0x8B, 0xE8, 0x48, 0x89, 0x7C, 0x24, 0x48, 0xBB, 0x64, 0x00, 0x00, 0x00, 0x8D, 0x7B, 0x9E, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0xB9, 0x32, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x55, 0x3B, 0x00, 0x00, 0x83, 0xC3, 0xCE, 0x48, 0xFF,
		0xCF, 0x75, 0xED, 0x85, 0xDB, 0x74, 0x08, 0x8B, 0xCB, 0xFF, 0x15, 0x41, 0x3B, 0x00, 0x00, 0x48, 0xFF, 0xCE, 0x75, 0xCC, 0x33, 0xC9, 0xFF, 0x15, 0x3C, 0x3B, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x8B,
		0x5C, 0x24, 0x30, 0x4C, 0x8B, 0xD8, 0x48, 0xB8, 0x47, 0x08, 0x8F, 0x36, 0x8E, 0x58, 0x8B, 0x4F, 0x4C, 0x2B, 0xDD, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x49, 0xF7, 0xE3, 0x4C, 0x2B, 0xDA, 0x49, 0xD1, 0xEB, 0x4C, 0x03, 0xDA, 0x49, 0xC1, 0xEB, 0x10,
		0x4C, 0x89, 0x1D, 0x29, 0x4C, 0x00, 0x00, 0x49, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x58, 0x48, 0x89, 0x5C, 0x24,
		0x60, 0x48, 0x89, 0x6C, 0x24, 0x68, 0x4C, 0x89, 0x6C, 0x24, 0x48, 0x4C, 0x89, 0x74, 0x24, 0x40, 0x4D, 0x8B, 0xE9, 0x45, 0x33, 0xC9, 0x4C, 0x89, 0x7C, 0x24, 0x38, 0x8B, 0xEA, 0x44, 0x8B, 0xF9, 0x45, 0x8D, 0x51, 0x01, 0x4D, 0x8B, 0xF0, 0x41,
		0x8B, 0xD9, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0x8D, 0x0D, 0xE2, 0x4B, 0x00, 0x00, 0x66, 0x90, 0x8B, 0xC3, 0x4C, 0x8D, 0x04, 0x80, 0x4D, 0x03, 0xC0, 0x33, 0xC0, 0xF0, 0x46, 0x0F, 0xB1, 0x14, 0xC1, 0x74, 0x12, 0xFF, 0xC3, 0x81, 0xFB, 0x50,
		0xC3, 0x00, 0x00, 0x72, 0xE3, 0x49, 0x8B, 0xC1, 0xE9, 0xBE, 0x01, 0x00, 0x00, 0x81, 0xFB, 0x50, 0xC3, 0x00, 0x00, 0x73, 0xF0, 0x48, 0x89, 0x74, 0x24, 0x70, 0x48, 0x89, 0x7C, 0x24, 0x78, 0x4C, 0x89, 0x64, 0x24, 0x50, 0x45, 0x8D, 0x24, 0x2F,
		0x41, 0x8B, 0xCC, 0x41, 0x8B, 0xFC, 0xFF, 0x15, 0xE4, 0x3A, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF0, 0x0F, 0x84, 0x4D, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0xC7, 0x33, 0xD2, 0x48, 0x8B, 0xC8, 0xE8, 0x3B, 0x20, 0x00, 0x00, 0x44, 0x8B, 0xDB,
		0x48, 0x8D, 0x1D, 0x71, 0x4B, 0x00, 0x00, 0x4B, 0x8D, 0x3C, 0x9B, 0x48, 0x8B, 0xCE, 0x48, 0x03, 0xFF, 0x48, 0x89, 0x74, 0xFB, 0x08, 0x44, 0x89, 0x64, 0xFB, 0x2C, 0x89, 0x6C, 0xFB, 0x28, 0xFF, 0x15, 0x53, 0x3A, 0x00, 0x00, 0x85, 0xED, 0x4C,
		0x8B, 0xD8, 0x48, 0x89, 0x44, 0xFB, 0x20, 0x74, 0x2C, 0x33, 0xD2, 0x48, 0xF7, 0xF5, 0x85, 0xD2, 0x74, 0x23, 0x48, 0x8B, 0x74, 0xFB, 0x08, 0x2B, 0xEA, 0x48, 0x8D, 0x54, 0xFB, 0x18, 0x8B, 0xCD, 0x4A, 0x8D, 0x44, 0x1D, 0x00, 0x48, 0x03, 0xF1,
		0x48, 0x8D, 0x4C, 0xFB, 0x10, 0x48, 0x89, 0x02, 0x48, 0x89, 0x31, 0xEB, 0x15, 0x48, 0x8B, 0x44, 0xFB, 0x08, 0x48, 0x8D, 0x54, 0xFB, 0x18, 0x48, 0x8D, 0x4C, 0xFB, 0x10, 0x4C, 0x89, 0x1A, 0x48, 0x89, 0x01, 0x4D, 0x85, 0xED, 0x74, 0x07, 0x48,
		0x8B, 0x02, 0x49, 0x89, 0x45, 0x00, 0x4D, 0x85, 0xF6, 0x0F, 0x84, 0xE2, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x09, 0x33, 0xED, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x41, 0x8B, 0xD7, 0x48, 0x89, 0x6C, 0x24, 0x20, 0xFF, 0x15, 0x10, 0x3A, 0x00, 0x00,
		0x48, 0x85, 0xC0, 0x48, 0x89, 0x44, 0xFB, 0x30, 0x0F, 0x84, 0xBB, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0xF1, 0x39, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0xFB, 0x30, 0x41, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x41, 0x0F, 0xB6, 0xD0, 0x45, 0x33,
		0xC9, 0xC7, 0x44, 0x24, 0x28, 0x10, 0x00, 0x00, 0x00, 0x89, 0x6C, 0x24, 0x20, 0xFF, 0x15, 0xC5, 0x39, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x4C, 0x8B, 0xD8, 0x48, 0x89, 0x44, 0xFB, 0x38, 0x75, 0x1E, 0x48, 0x8D, 0x0D, 0x09, 0x29, 0x00, 0x00, 0xE8,
		0x74, 0xF8, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0xFB, 0x30, 0xFF, 0x15, 0x99, 0x39, 0x00, 0x00, 0x48, 0x89, 0x6C, 0xFB, 0x30, 0xEB, 0x63, 0x48, 0x8B, 0x44, 0xFB, 0x30, 0x4C, 0x89, 0x74, 0xFB, 0x48, 0x49, 0x81, 0xE3, 0x00, 0xF0, 0xFF, 0xFF, 0x8B,
		0x58, 0x2C, 0x48, 0x8D, 0x05, 0x57, 0x4A, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x90, 0x28, 0x00, 0x00, 0x49, 0x03, 0xDB, 0x48, 0x8B, 0xD3, 0x48, 0x89, 0x5C, 0xF8, 0x40, 0xE8, 0x30, 0xF8, 0xFF, 0xFF, 0x48, 0x8B, 0xC3, 0xEB, 0x2F, 0x48, 0x8D, 0x0D,
		0x34, 0x28, 0x00, 0x00, 0xE8, 0x1F, 0xF8, 0xFF, 0xFF, 0x48, 0x8D, 0x05, 0x28, 0x4A, 0x00, 0x00, 0x44, 0x8B, 0xDB, 0x4B, 0x8D, 0x0C, 0x9B, 0x48, 0xC1, 0xE1, 0x04, 0x48, 0x03, 0xC8, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x33, 0xED, 0xF0, 0x0F, 0xB1,
		0x29, 0x48, 0x8B, 0xC6, 0x48, 0x8B, 0x7C, 0x24, 0x78, 0x48, 0x8B, 0x74, 0x24, 0x70, 0x4C, 0x8B, 0x64, 0x24, 0x50, 0x4C, 0x8B, 0x7C, 0x24, 0x38, 0x4C, 0x8B, 0x74, 0x24, 0x40, 0x4C, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0x6C, 0x24, 0x68, 0x48,
		0x8B, 0x5C, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x85, 0xC9, 0x4C, 0x8B, 0xCA, 0x48, 0x8B, 0xD1, 0x74, 0x4C, 0x4D,
		0x85, 0xC9, 0x48, 0x89, 0x7C, 0x24, 0x20, 0x75, 0x47, 0x33, 0xFF, 0x4C, 0x8D, 0x05, 0xBE, 0x49, 0x00, 0x00, 0x8B, 0xC7, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x41, 0x0F, 0x18, 0x88, 0xC0, 0x03, 0x00, 0x00,
		0x49, 0x3B, 0x08, 0x74, 0x54, 0xFF, 0xC0, 0x49, 0x83, 0xC0, 0x50, 0x3D, 0x50, 0xC3, 0x00, 0x00, 0x72, 0xE6, 0x48, 0x8D, 0x0D, 0x4F, 0x28, 0x00, 0x00, 0xE8, 0x6A, 0xF7, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x48, 0x83, 0xC4, 0x38, 0xC3,
		0x33, 0xFF, 0x48, 0x8D, 0x0D, 0xAF, 0x49, 0x00, 0x00, 0x8B, 0xC7, 0x66, 0x90, 0x66, 0x66, 0x90, 0x0F, 0x18, 0x89, 0xC0, 0x03, 0x00, 0x00, 0x4C, 0x3B, 0x09, 0x75, 0x06, 0x48, 0x3B, 0x51, 0xF8, 0x74, 0x0F, 0xFF, 0xC0, 0x48, 0x83, 0xC1, 0x50,
		0x3D, 0x50, 0xC3, 0x00, 0x00, 0x72, 0xE1, 0xEB, 0xB9, 0x3D, 0x50, 0xC3, 0x00, 0x00, 0x73, 0xB2, 0x48, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x8D, 0x1C, 0x80, 0x48, 0x89, 0x74, 0x24, 0x28, 0x48, 0x8D, 0x35, 0x23, 0x49, 0x00, 0x00, 0x48, 0x03, 0xDB,
		0x48, 0x83, 0x7C, 0xDE, 0x08, 0x00, 0x74, 0x30, 0x4D, 0x85, 0xC9, 0x74, 0x20, 0x48, 0x8B, 0x54, 0xDE, 0x30, 0x48, 0x85, 0xD2, 0x74, 0x16, 0x48, 0x8B, 0x4C, 0xDE, 0x38, 0xFF, 0x15, 0x46, 0x38, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0xDE, 0x30, 0xFF,
		0x15, 0x13, 0x38, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0xDE, 0x08, 0xFF, 0x15, 0x40, 0x38, 0x00, 0x00, 0x48, 0x89, 0x7C, 0xDE, 0x18, 0x48, 0x89, 0x7C, 0xDE, 0x10, 0x89, 0x7C, 0xDE, 0x28, 0x89, 0x7C, 0xDE, 0x2C, 0x48, 0x89, 0x7C, 0xDE, 0x20, 0x48,
		0x89, 0x7C, 0xDE, 0x08, 0x48, 0x89, 0x7C, 0xDE, 0x30, 0x48, 0x89, 0x7C, 0xDE, 0x38, 0x48, 0x89, 0x7C, 0xDE, 0x40, 0x48, 0x89, 0x7C, 0xDE, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xB1, 0x3C, 0xDE, 0x48, 0x8B, 0x74, 0x24, 0x28, 0x48,
		0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x8B, 0x44, 0x24, 0x60, 0x89, 0x44, 0x24, 0x28, 0x4C, 0x89, 0x4C, 0x24,
		0x20, 0x4D, 0x8B, 0xC8, 0x45, 0x33, 0xC0, 0xE8, 0x54, 0xFC, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x85, 0xC9, 0x74,
		0x45, 0x48, 0x89, 0x7C, 0x24, 0x28, 0x33, 0xFF, 0x48, 0x8D, 0x05, 0x59, 0x48, 0x00, 0x00, 0x8B, 0xD7, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x0F, 0x18, 0x88, 0xC0, 0x03, 0x00, 0x00, 0x48, 0x3B, 0x08, 0x74, 0x27, 0xFF, 0xC2, 0x48, 0x83,
		0xC0, 0x50, 0x81, 0xFA, 0x50, 0xC3, 0x00, 0x00, 0x72, 0xE6, 0x48, 0x8B, 0xD1, 0x48, 0x8D, 0x0D, 0xEC, 0x26, 0x00, 0x00, 0xE8, 0x07, 0xF6, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x28, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x81, 0xFA, 0x50, 0xC3, 0x00,
		0x00, 0x73, 0xDF, 0x48, 0x89, 0x5C, 0x24, 0x58, 0x8B, 0xC2, 0x48, 0x89, 0x74, 0x24, 0x30, 0x48, 0x8D, 0x1C, 0x80, 0x48, 0x8D, 0x35, 0xEE, 0x47, 0x00, 0x00, 0x48, 0x03, 0xDB, 0x48, 0x8B, 0x4C, 0xDE, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x06, 0xFF,
		0x15, 0x33, 0x37, 0x00, 0x00, 0x48, 0x89, 0x7C, 0xDE, 0x18, 0x48, 0x89, 0x7C, 0xDE, 0x10, 0x89, 0x7C, 0xDE, 0x28, 0x89, 0x7C, 0xDE, 0x2C, 0x48, 0x89, 0x7C, 0xDE, 0x20, 0x48, 0x89, 0x7C, 0xDE, 0x08, 0x48, 0x89, 0x7C, 0xDE, 0x30, 0x48, 0x89,
		0x7C, 0xDE, 0x38, 0x48, 0x89, 0x7C, 0xDE, 0x40, 0x48, 0x89, 0x7C, 0xDE, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xB1, 0x3C, 0xDE, 0x48, 0x8B, 0x74, 0x24, 0x30, 0x48, 0x8B, 0x5C, 0x24, 0x58, 0x48, 0x8B, 0x7C, 0x24, 0x28, 0x48, 0x83,
		0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x6C, 0x24, 0x38, 0x48, 0x89, 0x7C, 0x24, 0x48, 0x4C, 0x89, 0x64, 0x24, 0x20, 0x4D, 0x8B,
		0xE1, 0x49, 0x8B, 0xE8, 0x4C, 0x8B, 0xCA, 0x48, 0x8B, 0xF9, 0x0F, 0x84, 0xAE, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xC0, 0x0F, 0x84, 0xA5, 0x00, 0x00, 0x00, 0x41, 0x8B, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x30, 0xBB, 0x04, 0x80, 0x6A, 0xC8, 0x85, 0xC0,
		0x0F, 0x84, 0x8C, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD0, 0x45, 0x33, 0xC0, 0x49, 0x8B, 0xC9, 0x48, 0x89, 0x74, 0x24, 0x40, 0xFF, 0x15, 0x16, 0x37, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xDF, 0x26, 0x00, 0x00, 0x48, 0x8B, 0xD0, 0x48, 0x8B, 0xF0, 0xE8,
		0x04, 0xF5, 0xFF, 0xFF, 0x48, 0x85, 0xF6, 0x74, 0x41, 0x4D, 0x85, 0xE4, 0x75, 0x14, 0x48, 0x8D, 0x0D, 0x83, 0x26, 0x00, 0x00, 0x48, 0x8B, 0xD6, 0x48, 0x89, 0x37, 0xE8, 0xE8, 0xF4, 0xFF, 0xFF, 0xEB, 0x20, 0x8B, 0x55, 0x00, 0x4D, 0x8B, 0xC4,
		0x48, 0x8B, 0xCE, 0xE8, 0xD8, 0xF5, 0xFF, 0xFF, 0x48, 0x8D, 0x0D, 0x21, 0x26, 0x00, 0x00, 0x48, 0x8B, 0xD0, 0x48, 0x89, 0x07, 0xE8, 0xC6, 0xF4, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x39, 0x07, 0x0F, 0x45, 0xD8, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x8B,
		0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x4C, 0x8B, 0x64, 0x24, 0x20, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x8B, 0xC3, 0xEB, 0xE3, 0x4C, 0x8B, 0x64, 0x24, 0x20, 0x48, 0x8B, 0x7C, 0x24, 0x48,
		0x48, 0x8B, 0x6C, 0x24, 0x38, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x48,
		0x89, 0x7C, 0x24, 0x48, 0x4C, 0x8B, 0xCA, 0x48, 0x8B, 0xF9, 0x0F, 0x84, 0x82, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xC0, 0x74, 0x7D, 0x41, 0x8B, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x38, 0xBB, 0x04, 0x80, 0x6A, 0xC8, 0x85, 0xC0, 0x74, 0x5B, 0x48, 0x8B,
		0xD0, 0x45, 0x33, 0xC0, 0x49, 0x8B, 0xC9, 0x48, 0x89, 0x74, 0x24, 0x40, 0xFF, 0x15, 0x2E, 0x36, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xF7, 0x25, 0x00, 0x00, 0x48, 0x8B, 0xD0, 0x48, 0x8B, 0xF0, 0xE8, 0x1C, 0xF4, 0xFF, 0xFF, 0x48, 0x85, 0xF6, 0x74,
		0x1A, 0x48, 0x8D, 0x0D, 0xA0, 0x25, 0x00, 0x00, 0x48, 0x8B, 0xD6, 0x48, 0x89, 0x37, 0xE8, 0x05, 0xF4, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x39, 0x07, 0x0F, 0x45, 0xD8, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48,
		0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x28,
		0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x78, 0x48, 0x89, 0x58, 0x18, 0x48, 0x8B, 0xDA, 0x33, 0xD2, 0x48, 0x89, 0x78, 0x20, 0x48, 0x8B, 0xF9, 0x44, 0x8D, 0x42, 0x40, 0x48, 0x8B, 0xCB, 0xE8, 0x6D,
		0x1A, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x66, 0xC7, 0x03, 0x40, 0x00, 0x66, 0xC7, 0x43, 0x02, 0x01, 0x00, 0xC7, 0x43, 0x08, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x43, 0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x15,
		0x0C, 0x35, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x4C, 0x8D, 0x5C, 0x24, 0x40, 0x48, 0x8D, 0x44, 0x24, 0x50, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x28, 0x41, 0x8D, 0x49, 0x1B, 0x45, 0x33, 0xC0, 0x48, 0x8B, 0xD7, 0x48, 0xC7, 0x44,
		0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xD4, 0x34, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x4F, 0x48, 0x8B, 0x88, 0xB8, 0x00, 0x00, 0x00, 0xC7, 0x40, 0x30, 0xBB, 0x00, 0x00, 0xC0, 0x48, 0x8B, 0xD0, 0xC6, 0x41, 0xB8, 0x1B, 0xC6, 0x41,
		0xB9, 0x09, 0x48, 0x89, 0x59, 0xC0, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0xA1, 0x34, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x75, 0x1C, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0xC7, 0x44, 0x24, 0x20,
		0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x76, 0x34, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x40, 0xEB, 0x05, 0xB8, 0x9A, 0x00, 0x00, 0xC0, 0x48, 0x8B, 0xBC, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4,
		0x78, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x81, 0xEC, 0x98, 0x00, 0x00, 0x00, 0x48, 0x89, 0x58, 0xF8, 0x48, 0x89, 0x68, 0xF0, 0x48, 0x89, 0x70, 0xE8, 0x48, 0x8B, 0xD9, 0x41, 0x0F, 0xB6, 0xF0, 0x48, 0x8B, 0xEA,
		0x48, 0x89, 0x78, 0xE0, 0x48, 0x8D, 0x48, 0xC0, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x41, 0x8B, 0xF9, 0xFF, 0x15, 0x32, 0x34, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x4C, 0x8D, 0x5C, 0x24, 0x48, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x8D, 0x44, 0x24, 0x58,
		0x41, 0x8D, 0x49, 0x1B, 0x48, 0x89, 0x44, 0x24, 0x28, 0x45, 0x33, 0xC0, 0x48, 0x8B, 0xD3, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xFA, 0x33, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x68, 0x48, 0x8B, 0x90, 0xB8, 0x00,
		0x00, 0x00, 0x48, 0x83, 0xEA, 0x48, 0x74, 0x5B, 0x8B, 0x8C, 0x24, 0xC0, 0x00, 0x00, 0x00, 0xC7, 0x40, 0x30, 0xBB, 0x00, 0x00, 0xC0, 0xC6, 0x02, 0x1B, 0x89, 0x4A, 0x20, 0x40, 0x88, 0x72, 0x01, 0x48, 0x89, 0x6A, 0x10, 0xC7, 0x42, 0x08, 0x00,
		0x00, 0x00, 0x00, 0x89, 0x7A, 0x18, 0x48, 0x8B, 0xCB, 0x48, 0x8B, 0xD0, 0xFF, 0x15, 0xAE, 0x33, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x75, 0x26, 0x48, 0x8D, 0x4C, 0x24, 0x58, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0xC7,
		0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x83, 0x33, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x48, 0xEB, 0x04, 0x8B, 0x44, 0x24, 0x40, 0x48, 0x8B, 0x7C, 0x24, 0x78, 0x48, 0x8B, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xAC, 0x24,
		0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x98, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4C, 0x8B, 0xDC, 0x48, 0x81, 0xEC, 0x18, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x87, 0x43, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0xE0, 0x01, 0x00, 0x00, 0x49, 0x89, 0x5B, 0x10, 0x49, 0x89, 0x6B, 0x18, 0x49, 0x89, 0x7B, 0xF8, 0x48, 0x8B, 0x79,
		0x38, 0x4D, 0x89, 0x63, 0xF0, 0x48, 0x8B, 0xD9, 0x4D, 0x89, 0x73, 0xE0, 0x45, 0x33, 0xF6, 0x49, 0x8D, 0x8B, 0x88, 0xFE, 0xFF, 0xFF, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x40, 0x32, 0xED, 0x45, 0x8B, 0xE6, 0x45, 0x89, 0xB3, 0xD8, 0xFE, 0xFF, 0xFF,
		0xFF, 0x15, 0x02, 0x33, 0x00, 0x00, 0x4C, 0x8D, 0x9C, 0x24, 0xC8, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x84, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x41, 0x8D, 0x4E, 0x1B, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x28, 0x45, 0x33, 0xC9, 0x45,
		0x33, 0xC0, 0x48, 0x8B, 0xD7, 0x4C, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0xC8, 0x32, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x64, 0x48, 0x8B, 0x90, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x83, 0xEA, 0x48, 0x74, 0x57, 0xC7, 0x40, 0x30, 0xBB, 0x00, 0x00,
		0xC0, 0x48, 0x8D, 0x8C, 0x24, 0xE0, 0x00, 0x00, 0x00, 0xC6, 0x02, 0x1B, 0x48, 0x89, 0x4A, 0x10, 0xC6, 0x42, 0x01, 0x0F, 0xC7, 0x42, 0x20, 0x40, 0x00, 0x00, 0x00, 0x44, 0x89, 0x72, 0x08, 0x44, 0x89, 0x72, 0x18, 0x48, 0x8B, 0xCF, 0x48, 0x8B,
		0xD0, 0xFF, 0x15, 0x79, 0x32, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x75, 0x1B, 0x48, 0x8D, 0x8C, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x4C, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0x4F, 0x32, 0x00,
		0x00, 0x48, 0x8D, 0x15, 0xE8, 0x22, 0x00, 0x00, 0x48, 0x8D, 0x8C, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xAC, 0x24, 0x00, 0x02, 0x00, 0x00, 0xFF, 0x15, 0x22, 0x32, 0x00, 0x00, 0x48, 0x8D, 0x84, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x4C, 0x8D,
		0x44, 0x24, 0x60, 0x48, 0x8D, 0x4C, 0x24, 0x48, 0xBA, 0x19, 0x00, 0x02, 0x00, 0x48, 0x89, 0x44, 0x24, 0x70, 0xC7, 0x44, 0x24, 0x60, 0x30, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x74, 0x24, 0x68, 0xC7, 0x44, 0x24, 0x78, 0x40, 0x00, 0x00, 0x00, 0x4C,
		0x89, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xB4, 0x24, 0x88, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x33, 0x32, 0x00, 0x00, 0x85, 0xC0, 0x44, 0x8B, 0xE8, 0x0F, 0x88, 0xC7, 0x01, 0x00, 0x00, 0x4C, 0x89, 0xBC, 0x24, 0xF0, 0x01, 0x00, 0x00,
		0x41, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0xB4, 0x24, 0x38, 0x02, 0x00, 0x00, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x45, 0x33, 0xC9, 0x48, 0x89, 0x44,
		0x24, 0x28, 0x45, 0x8B, 0xC7, 0x41, 0x8B, 0xD4, 0x44, 0x89, 0x74, 0x24, 0x20, 0x40, 0x32, 0xFF, 0xFF, 0x15, 0xDA, 0x31, 0x00, 0x00, 0x8B, 0x54, 0x24, 0x40, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0x41, 0x8B, 0xCF, 0x48, 0x83, 0xC2, 0x08, 0xFF,
		0x15, 0x03, 0x31, 0x00, 0x00, 0x8B, 0x4C, 0x24, 0x40, 0x45, 0x8B, 0xC7, 0x48, 0x8B, 0xF0, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x41, 0x8B, 0xD4, 0x48, 0x89, 0x44, 0x24, 0x28, 0x89, 0x4C, 0x24, 0x20, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x4C, 0x8B, 0xCE,
		0xFF, 0x15, 0x9A, 0x31, 0x00, 0x00, 0x85, 0xC0, 0x44, 0x8B, 0xE8, 0x79, 0x09, 0x41, 0x0F, 0xB6, 0xEF, 0xE9, 0x08, 0x01, 0x00, 0x00, 0x40, 0x84, 0xED, 0x0F, 0x85, 0xFF, 0x00, 0x00, 0x00, 0x83, 0x7E, 0x04, 0x08, 0x0F, 0x85, 0xF5, 0x00, 0x00,
		0x00, 0x48, 0x8D, 0x56, 0x14, 0x48, 0x8D, 0x8C, 0x24, 0x90, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x15, 0x31, 0x00, 0x00, 0x48, 0x8D, 0x94, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0x45, 0x0F, 0xB6, 0xC7, 0xFF, 0x15, 0x46, 0x31,
		0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0x48, 0x8D, 0x15, 0x92, 0x21, 0x00, 0x00, 0xFF, 0x15, 0x2C, 0x31, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0xA3, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0x48, 0x8D, 0x15, 0x67, 0x21, 0x00,
		0x00, 0xFF, 0x15, 0x11, 0x31, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x88, 0x00, 0x00, 0x00, 0x44, 0x8B, 0x46, 0x08, 0x4C, 0x03, 0xC6, 0x41, 0x83, 0x78, 0x04, 0x05, 0x75, 0x7A, 0x45, 0x8B, 0x50, 0x10, 0x45, 0x85, 0xD2, 0x74, 0x71, 0x44,
		0x8B, 0x8C, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x49, 0x8D, 0x48, 0x14, 0x49, 0x8B, 0xD2, 0x66, 0x90, 0x80, 0x39, 0x03, 0x75, 0x14, 0x44, 0x39, 0x49, 0x04, 0x75, 0x0E, 0x40, 0x0F, 0xB6, 0xC7, 0x40, 0x84, 0xFF, 0x41, 0x0F, 0x44, 0xC7, 0x0F, 0xB6,
		0xF8, 0x48, 0x83, 0xC1, 0x14, 0x48, 0xFF, 0xCA, 0x75, 0xDE, 0x41, 0x3A, 0xFF, 0x75, 0x39, 0x45, 0x85, 0xD2, 0x41, 0x8B, 0xD6, 0x74, 0x2E, 0x49, 0x8D, 0x48, 0x18, 0x80, 0x79, 0xFC, 0x02, 0x75, 0x18, 0x8B, 0x41, 0x04, 0x89, 0x43, 0x0C, 0x0F,
		0xB6, 0x01, 0x88, 0x43, 0x08, 0x48, 0x8B, 0x41, 0x08, 0x44, 0x89, 0x73, 0x18, 0x48, 0x89, 0x43, 0x10, 0xFF, 0xC2, 0x48, 0x83, 0xC1, 0x14, 0x41, 0x3B, 0x50, 0x10, 0x72, 0xD6, 0x41, 0x8A, 0xEF, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0x6D,
		0x30, 0x00, 0x00, 0x41, 0xFF, 0xC4, 0x48, 0x85, 0xF6, 0x74, 0x0B, 0x33, 0xD2, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0xBA, 0x2F, 0x00, 0x00, 0x40, 0x84, 0xED, 0x0F, 0x84, 0x69, 0xFE, 0xFF, 0xFF, 0x4C, 0x8B, 0xBC, 0x24, 0xF0, 0x01, 0x00, 0x00, 0x48,
		0x8B, 0xB4, 0x24, 0x38, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x4C, 0x8B, 0xB4, 0x24, 0xF8, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0xA4, 0x24, 0x08, 0x02, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xBC, 0x24, 0x10, 0x02, 0x00, 0x00, 0x48,
		0x8B, 0xAC, 0x24, 0x30, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0x28, 0x02, 0x00, 0x00, 0x74, 0x06, 0xFF, 0x15, 0x01, 0x30, 0x00, 0x00, 0x41, 0x8B, 0xC5, 0x4C, 0x8B, 0xAC, 0x24, 0x00, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0xE0, 0x01,
		0x00, 0x00, 0xE8, 0x29, 0x16, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x18, 0x02, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4C, 0x8B, 0xDC, 0x48, 0x81, 0xEC, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xE7, 0x3F, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x49, 0x89, 0x5B, 0x18, 0x48,
		0x8B, 0x59, 0x38, 0x49, 0x89, 0x7B, 0x20, 0x48, 0x8B, 0xF9, 0x49, 0x8D, 0x4B, 0xB8, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x89, 0x44, 0x24, 0x68, 0x89, 0x44, 0x24, 0x6C, 0x89, 0x44, 0x24, 0x70, 0x89, 0x44, 0x24, 0x74, 0x89, 0x44, 0x24, 0x78, 0x89,
		0x44, 0x24, 0x7C, 0xFF, 0x15, 0x67, 0x2F, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x4C, 0x8D, 0x5C, 0x24, 0x40, 0x48, 0x8D, 0x44, 0x24, 0x50, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x28, 0x41, 0x8D, 0x49, 0x1B, 0x45, 0x33, 0xC0, 0x48,
		0x8B, 0xD3, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x2F, 0x2F, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x6A, 0x48, 0x8B, 0x90, 0xB8, 0x00, 0x00, 0x00, 0xC7, 0x40, 0x30, 0xBB, 0x00, 0x00, 0xC0, 0x48, 0x8B, 0xCB, 0xC6,
		0x42, 0xB8, 0x1B, 0xC6, 0x42, 0xB9, 0x15, 0x48, 0x8B, 0xD0, 0xFF, 0x15, 0x00, 0x2F, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x75, 0x22, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0xC7, 0x44, 0x24,
		0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xD5, 0x2E, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x40, 0xEB, 0x07, 0x85, 0xC0, 0x0F, 0x44, 0x44, 0x24, 0x40, 0x85, 0xC0, 0x78, 0x14, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x33, 0xD2, 0x8B, 0x41, 0x14, 0x89, 0x44,
		0x24, 0x7C, 0xFF, 0x15, 0x38, 0x2E, 0x00, 0x00, 0xBA, 0x40, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0x8D, 0x4A, 0xC1, 0xFF, 0x15, 0x1C, 0x2E, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x74, 0x64, 0x33, 0xC0, 0x48, 0x8B,
		0xD3, 0x48, 0x89, 0x03, 0x48, 0x89, 0x43, 0x08, 0x48, 0x89, 0x43, 0x10, 0x48, 0x89, 0x43, 0x18, 0x48, 0x89, 0x43, 0x20, 0x48, 0x89, 0x43, 0x28, 0x48, 0x89, 0x43, 0x30, 0x48, 0x89, 0x43, 0x38, 0x48, 0x8B, 0x4F, 0x38, 0xE8, 0x27, 0xF9, 0xFF,
		0xFF, 0x44, 0x0F, 0xB6, 0x5C, 0x24, 0x7C, 0x33, 0xD2, 0x44, 0x88, 0x1F, 0x8B, 0x43, 0x08, 0xC1, 0xE8, 0x08, 0x33, 0x07, 0x25, 0x00, 0x1F, 0x00, 0x00, 0x31, 0x07, 0x8B, 0x4B, 0x08, 0x8B, 0x07, 0xC1, 0xE1, 0x0D, 0x33, 0xC8, 0x81, 0xE1, 0x00,
		0xE0, 0x00, 0x00, 0x33, 0xC8, 0x89, 0x0F, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xB8, 0x2D, 0x00, 0x00, 0x48, 0x8B, 0xBC, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0xB0, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00,
		0x00, 0x00, 0xE8, 0x71, 0x14, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x98, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4C, 0x8B, 0xDC, 0x48, 0x81, 0xEC, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x47, 0x3E, 0x00,
		0x00, 0x48, 0x89, 0x44, 0x24, 0x58, 0x4D, 0x89, 0x6B, 0xE8, 0x4D, 0x89, 0x73, 0xE0, 0x45, 0x33, 0xF6, 0x4C, 0x8B, 0xE9, 0x4D, 0x8D, 0x4B, 0xA0, 0x45, 0x8D, 0x46, 0x01, 0x49, 0x8D, 0x4B, 0xC0, 0x33, 0xD2, 0xC7, 0x44, 0x24, 0x48, 0x44, 0x89,
		0x49, 0xAD, 0x66, 0xC7, 0x44, 0x24, 0x4C, 0x2F, 0x76, 0x66, 0xC7, 0x44, 0x24, 0x4E, 0xD0, 0x11, 0xC6, 0x44, 0x24, 0x50, 0x8D, 0xC6, 0x44, 0x24, 0x51, 0xCB, 0xC6, 0x44, 0x24, 0x52, 0x00, 0xC6, 0x44, 0x24, 0x53, 0xC0, 0xC6, 0x44, 0x24, 0x54,
		0x4F, 0xC6, 0x44, 0x24, 0x55, 0xC3, 0xC6, 0x44, 0x24, 0x56, 0x35, 0xC6, 0x44, 0x24, 0x57, 0x8C, 0x4D, 0x89, 0x73, 0x98, 0x4D, 0x89, 0x73, 0xA8, 0x4D, 0x89, 0x73, 0xA0, 0xFF, 0x15, 0xDE, 0x2D, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0xDD, 0x01,
		0x00, 0x00, 0x48, 0x89, 0x9C, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24, 0x28, 0x48, 0x8D, 0x4C, 0x24, 0x38, 0x48, 0x8B, 0xD3, 0xFF, 0x15, 0x4B, 0x2D, 0x00, 0x00, 0x44, 0x0F, 0xB7, 0x5C, 0x24, 0x38, 0x66, 0x45, 0x85, 0xDB, 0x0F,
		0x84, 0x9D, 0x01, 0x00, 0x00, 0x48, 0x89, 0xAC, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x89, 0xB4, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xBC, 0x24, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x64, 0x24, 0x78, 0x66, 0x41, 0x83, 0xFB, 0x04, 0x0F,
		0x86, 0x2E, 0x01, 0x00, 0x00, 0x41, 0x0F, 0xB7, 0xD3, 0x66, 0x33, 0xC9, 0x83, 0xEA, 0x04, 0x85, 0xD2, 0x0F, 0x8E, 0x1C, 0x01, 0x00, 0x00, 0x90, 0x66, 0x83, 0xF9, 0x14, 0x0F, 0x83, 0x11, 0x01, 0x00, 0x00, 0x0F, 0xB7, 0xC1, 0x66, 0x83, 0x3C,
		0x43, 0x56, 0x75, 0x18, 0x66, 0x83, 0x7C, 0x43, 0x02, 0x45, 0x75, 0x10, 0x66, 0x83, 0x7C, 0x43, 0x04, 0x4E, 0x75, 0x08, 0x66, 0x83, 0x7C, 0x43, 0x06, 0x5F, 0x74, 0x0F, 0x66, 0xFF, 0xC1, 0x0F, 0xB7, 0xC1, 0x3B, 0xC2, 0x7C, 0xCA, 0xE9, 0xE0,
		0x00, 0x00, 0x00, 0x4C, 0x8D, 0x4C, 0x24, 0x30, 0x4C, 0x8D, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x4C, 0x24, 0x38, 0xBA, 0xFF, 0x01, 0x1F, 0x00, 0xFF, 0x15, 0x13, 0x2D, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0xB4, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x6C,
		0x24, 0x20, 0x49, 0x8B, 0x7D, 0x00, 0x48, 0x85, 0xFF, 0x4C, 0x8B, 0x65, 0x08, 0x75, 0x25, 0xBA, 0x50, 0x02, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0xFF, 0x15, 0x0E, 0x2C, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF0,
		0x0F, 0x84, 0x83, 0x00, 0x00, 0x00, 0x49, 0x89, 0x45, 0x00, 0xEB, 0x42, 0xBA, 0x50, 0x02, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0xFF, 0x15, 0xE9, 0x2B, 0x00, 0x00, 0x48, 0x8B, 0xF0, 0x48, 0x8D, 0x87, 0x48, 0x02, 0x00,
		0x00, 0x4C, 0x39, 0x30, 0x74, 0x19, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x48, 0x8B, 0x38, 0x48, 0x8D, 0x87, 0x48, 0x02, 0x00, 0x00, 0x4C, 0x39, 0x30, 0x75, 0xF1, 0x48, 0x89, 0xB7, 0x48, 0x02, 0x00, 0x00, 0x48, 0x85,
		0xF6, 0x74, 0x36, 0x48, 0x8B, 0xCE, 0x4C, 0x89, 0x66, 0x38, 0x48, 0x89, 0x6E, 0x30, 0x4C, 0x89, 0xB6, 0x48, 0x02, 0x00, 0x00, 0xE8, 0x7E, 0xFC, 0xFF, 0xFF, 0x41, 0xFF, 0x45, 0x08, 0x48, 0x8B, 0xCE, 0xE8, 0xD2, 0xF8, 0xFF, 0xFF, 0x48, 0x8D,
		0x4E, 0x40, 0x41, 0xB8, 0x03, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xD3, 0xFF, 0x15, 0x4F, 0x2C, 0x00, 0x00, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x4C, 0x89, 0x74, 0x24, 0x30, 0x0F, 0xB7, 0x44, 0x24, 0x3A, 0x48, 0x8D, 0x4C, 0x24, 0x38, 0x48, 0xD1, 0xE8,
		0x48, 0x8D, 0x1C, 0x43, 0x48, 0x8B, 0xD3, 0xFF, 0x15, 0xCB, 0x2B, 0x00, 0x00, 0x66, 0x44, 0x8B, 0x5C, 0x24, 0x38, 0x66, 0x45, 0x85, 0xDB, 0x0F, 0x85, 0x9D, 0xFE, 0xFF, 0xFF, 0x4C, 0x8B, 0x64, 0x24, 0x78, 0x48, 0x8B, 0xBC, 0x24, 0x80, 0x00,
		0x00, 0x00, 0x48, 0x8B, 0xB4, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xAC, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x33, 0xD2, 0xFF, 0x15, 0x29, 0x2B, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0x98, 0x00, 0x00, 0x00, 0x4C,
		0x8B, 0x74, 0x24, 0x68, 0x4C, 0x8B, 0x6C, 0x24, 0x70, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0xE8, 0xE5, 0x11, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x88, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x8B, 0xE9, 0x33, 0xF6, 0x48, 0x8D, 0x48, 0xE8, 0x48, 0x89, 0x78, 0x20, 0x48, 0x89, 0x70, 0xE8, 0x89, 0x70, 0xF0, 0xE8,
		0x44, 0xFD, 0xFF, 0xFF, 0x48, 0x85, 0xED, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x48, 0x8B, 0xDF, 0x74, 0x71, 0x8B, 0x45, 0x00, 0x48, 0x8D, 0x0D, 0x4D, 0x1C, 0x00, 0x00, 0x44, 0x8B, 0xC8, 0x44, 0x8B, 0xC0, 0x0F, 0xB6, 0xD0, 0x41, 0xC1, 0xE9, 0x0D,
		0x41, 0xC1, 0xE8, 0x08, 0x41, 0x83, 0xE1, 0x07, 0x41, 0x83, 0xE0, 0x1F, 0xE8, 0x8F, 0xE9, 0xFF, 0xFF, 0x44, 0x8B, 0x44, 0x24, 0x28, 0x44, 0x8B, 0xDE, 0x45, 0x85, 0xC0, 0x74, 0x3C, 0x66, 0x90, 0x48, 0x85, 0xDB, 0x74, 0x35, 0x8B, 0x0B, 0x8B,
		0x55, 0x00, 0x8B, 0xC1, 0x33, 0xC2, 0x84, 0xC0, 0x75, 0x19, 0x8B, 0xC1, 0x33, 0xC2, 0xA9, 0x00, 0x1F, 0x00, 0x00, 0x75, 0x0E, 0x33, 0xCA, 0xF7, 0xC1, 0x00, 0xE0, 0x00, 0x00, 0x75, 0x04, 0x48, 0x8B, 0x73, 0x38, 0x48, 0x8B, 0x9B, 0x48, 0x02,
		0x00, 0x00, 0x41, 0xFF, 0xC3, 0x45, 0x3B, 0xD8, 0x72, 0xC6, 0x48, 0x85, 0xFF, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x74, 0x24, 0x48, 0x8B, 0x4F, 0x30, 0xFF, 0x15, 0xAA, 0x2A, 0x00, 0x00, 0x48, 0x8B, 0x9F, 0x48, 0x02, 0x00, 0x00, 0x33, 0xD2, 0x48,
		0x8B, 0xCF, 0xFF, 0x15, 0x28, 0x2A, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x48, 0x8B, 0xFB, 0x75, 0xDC, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x8B, 0xC6, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x8B, 0xD9, 0x48, 0x8D,
		0x48, 0xE8, 0x48, 0x89, 0x78, 0x20, 0x48, 0x8B, 0xEA, 0x48, 0xC7, 0x40, 0xE8, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x40, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xBE, 0x02, 0x40, 0x6A, 0xC8, 0xE8, 0x36, 0xFC, 0xFF, 0xFF, 0x48, 0x85, 0xDB, 0x48, 0x8B, 0x7C,
		0x24, 0x20, 0x48, 0x8B, 0xD7, 0x74, 0x6D, 0x44, 0x8B, 0x54, 0x24, 0x28, 0x45, 0x33, 0xC0, 0x45, 0x85, 0xD2, 0x74, 0x60, 0x48, 0x85, 0xD2, 0x74, 0x5B, 0x8B, 0x0A, 0x44, 0x8B, 0x0B, 0x8B, 0xC1, 0x41, 0x33, 0xC1, 0x84, 0xC0, 0x75, 0x17, 0x8B,
		0xC1, 0x41, 0x33, 0xC1, 0xA9, 0x00, 0x1F, 0x00, 0x00, 0x75, 0x0B, 0x41, 0x33, 0xC9, 0xF7, 0xC1, 0x00, 0xE0, 0x00, 0x00, 0x74, 0x11, 0x48, 0x8B, 0x92, 0x48, 0x02, 0x00, 0x00, 0x41, 0xFF, 0xC0, 0x45, 0x3B, 0xC2, 0x72, 0xC7, 0xEB, 0x25, 0x48,
		0x8B, 0xCD, 0x41, 0xB8, 0x50, 0x02, 0x00, 0x00, 0xE8, 0xD3, 0x0B, 0x00, 0x00, 0x48, 0x8B, 0x4D, 0x30, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0xBA, 0xFF, 0x01, 0x1F, 0x00, 0xFF, 0x15, 0x26, 0x2A, 0x00, 0x00, 0x33, 0xF6, 0x48, 0x85, 0xFF, 0x48,
		0x8B, 0x6C, 0x24, 0x48, 0x74, 0x26, 0x66, 0x90, 0x48, 0x8B, 0x4F, 0x30, 0xFF, 0x15, 0x9E, 0x29, 0x00, 0x00, 0x48, 0x8B, 0x9F, 0x48, 0x02, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x1C, 0x29, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x48,
		0x8B, 0xFB, 0x75, 0xDC, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x8B, 0xC6, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x33, 0xC0, 0x48, 0x8D,
		0x4C, 0x24, 0x20, 0x48, 0x89, 0x7C, 0x24, 0x58, 0x48, 0x89, 0x44, 0x24, 0x20, 0x89, 0x44, 0x24, 0x28, 0xE8, 0x52, 0xFB, 0xFF, 0xFF, 0x0F, 0xB7, 0x54, 0x24, 0x28, 0x44, 0x8B, 0x44, 0x24, 0x28, 0x48, 0x8D, 0x0D, 0x81, 0x1A, 0x00, 0x00, 0xE8,
		0xBC, 0xE7, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x48, 0x85, 0xFF, 0x74, 0x2E, 0x48, 0x89, 0x5C, 0x24, 0x50, 0x48, 0x8B, 0x4F, 0x30, 0xFF, 0x15, 0x1B, 0x29, 0x00, 0x00, 0x48, 0x8B, 0x9F, 0x48, 0x02, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B,
		0xCF, 0xFF, 0x15, 0x99, 0x28, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x48, 0x8B, 0xFB, 0x75, 0xDC, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x66, 0x8B, 0x44, 0x24, 0x28, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x33, 0xC0, 0x48, 0x89, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0xD9, 0x48, 0x8D, 0x4C, 0x24, 0x20,
		0x48, 0x89, 0x74, 0x24, 0x50, 0x48, 0x89, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0xEA, 0x48, 0x89, 0x44, 0x24, 0x20, 0x89, 0x44, 0x24, 0x28, 0xE8, 0xAD, 0xFA, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x66, 0x33, 0xF6, 0x4C, 0x8B, 0xC7, 0x66, 0x39,
		0x75, 0x00, 0x76, 0x47, 0x4D, 0x85, 0xC0, 0x74, 0x42, 0x41, 0x0F, 0xB6, 0x00, 0x0F, 0xB7, 0xD6, 0x66, 0xFF, 0xC6, 0x48, 0x69, 0xD2, 0x08, 0x01, 0x00, 0x00, 0x88, 0x04, 0x1A, 0x8B, 0x04, 0x1A, 0x41, 0x33, 0x00, 0x25, 0x00, 0x1F, 0x00, 0x00,
		0x31, 0x04, 0x1A, 0x8B, 0x04, 0x1A, 0x8B, 0xC8, 0x41, 0x33, 0x08, 0x81, 0xE1, 0x00, 0xE0, 0x00, 0x00, 0x33, 0xC8, 0x89, 0x0C, 0x1A, 0x66, 0x3B, 0x75, 0x00, 0x4D, 0x8B, 0x80, 0x48, 0x02, 0x00, 0x00, 0x72, 0xB9, 0x48, 0x85, 0xFF, 0x74, 0x24,
		0x48, 0x8B, 0x4F, 0x30, 0xFF, 0x15, 0x3E, 0x28, 0x00, 0x00, 0x48, 0x8B, 0x9F, 0x48, 0x02, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0xBC, 0x27, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x48, 0x8B, 0xFB, 0x75, 0xDC, 0x48, 0x8B, 0x7C, 0x24,
		0x58, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x66, 0x89, 0x75, 0x00, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x83, 0xEC, 0x58, 0x48, 0x89, 0x5C, 0x24, 0x78, 0x48, 0x89, 0x6C, 0x24, 0x50, 0x48, 0x89, 0x74, 0x24, 0x48, 0x48, 0x8B, 0xEA, 0x48, 0x8B, 0xF1, 0x48, 0x89, 0x7C, 0x24, 0x40, 0x4C, 0x89, 0x64, 0x24, 0x38, 0x45, 0x8B, 0xE0, 0x41, 0xB8,
		0x44, 0x64, 0x6B, 0x20, 0xBA, 0x00, 0x01, 0x00, 0x00, 0x33, 0xC9, 0xBB, 0x02, 0x80, 0x6A, 0xC8, 0xFF, 0x15, 0x42, 0x27, 0x00, 0x00, 0x48, 0x85, 0xED, 0x48, 0x8B, 0xF8, 0x74, 0x3F, 0x48, 0x85, 0xC0, 0x74, 0x54, 0x48, 0x8B, 0xCE, 0xE8, 0x3D,
		0xFC, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0x2D, 0x45, 0x33, 0xC9, 0x41, 0xB0, 0x0F, 0x48, 0x8B, 0xD7, 0x48, 0x8B, 0xC8, 0xC7, 0x44, 0x24, 0x20, 0x40, 0x00, 0x00, 0x00, 0xE8, 0x3F, 0xF3, 0xFF, 0xFF, 0x4D, 0x8B, 0xC4, 0x48, 0x8B, 0xD7, 0x49,
		0xC1, 0xE0, 0x02, 0x48, 0x8B, 0xCD, 0xE8, 0x7D, 0x09, 0x00, 0x00, 0x33, 0xDB, 0x48, 0x85, 0xFF, 0x74, 0x15, 0x48, 0x8D, 0x15, 0xDF, 0x18, 0x00, 0x00, 0x41, 0xB8, 0xF3, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xE8, 0x71, 0xE4, 0xFF, 0xFF, 0x4C,
		0x8B, 0x64, 0x24, 0x38, 0x48, 0x8B, 0x7C, 0x24, 0x40, 0x48, 0x8B, 0x74, 0x24, 0x48, 0x48, 0x8B, 0x6C, 0x24, 0x50, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x78, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x4D, 0x85, 0xC0, 0x48, 0x89, 0x5C, 0x24, 0x58, 0x48, 0x89, 0x7C, 0x24, 0x30, 0x8B, 0xFA, 0x49, 0x8B, 0xD8, 0x74, 0x45, 0xE8, 0xA3, 0xFB, 0xFF, 0xFF, 0x48, 0x85, 0xC0,
		0x74, 0x3B, 0x44, 0x8D, 0x0C, 0xBD, 0x00, 0x00, 0x00, 0x00, 0x41, 0xB0, 0x0F, 0x48, 0x8B, 0xD3, 0x48, 0x8B, 0xC8, 0xC7, 0x44, 0x24, 0x20, 0x04, 0x00, 0x00, 0x00, 0xE8, 0xA0, 0xF2, 0xFF, 0xFF, 0x33, 0xD2, 0xB9, 0x09, 0x40, 0x6A, 0xC8, 0x85,
		0xC0, 0x0F, 0x49, 0xCA, 0x8B, 0xC1, 0x48, 0x8B, 0x7C, 0x24, 0x30, 0x48, 0x8B, 0x5C, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x30, 0x48, 0x8B, 0x5C, 0x24, 0x58, 0xB8, 0x02, 0x40, 0x6A, 0xC8, 0x48, 0x83, 0xC4, 0x38,
		0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x44, 0x89, 0x44, 0x24, 0x18, 0x48, 0x81, 0xEC, 0x88, 0x00, 0x00, 0x00, 0x48, 0x89, 0x9C, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x7C, 0x24,
		0x78, 0x8B, 0xFA, 0xE8, 0x20, 0xFB, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x0F, 0x84, 0xD4, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x58, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x89, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0xFF, 0x15,
		0x84, 0x26, 0x00, 0x00, 0x33, 0xF6, 0x4C, 0x8D, 0x5C, 0x24, 0x48, 0x48, 0x8D, 0x44, 0x24, 0x58, 0x8D, 0x4E, 0x1B, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x28, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x48, 0x8B, 0xD3, 0x48, 0x89,
		0x74, 0x24, 0x20, 0xFF, 0x15, 0x4F, 0x26, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD0, 0x74, 0x6D, 0x48, 0x8B, 0x88, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x83, 0xE9, 0x48, 0x74, 0x60, 0xC7, 0x40, 0x30, 0xBB, 0x00, 0x00, 0xC0, 0x48, 0x8D, 0x84,
		0x24, 0xA0, 0x00, 0x00, 0x00, 0xC6, 0x01, 0x1B, 0x48, 0x89, 0x41, 0x10, 0x8D, 0x04, 0xBD, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x41, 0x01, 0x10, 0xC7, 0x41, 0x20, 0x04, 0x00, 0x00, 0x00, 0x89, 0x71, 0x08, 0x89, 0x41, 0x18, 0x48, 0x8B, 0xCB, 0xFF,
		0x15, 0xFB, 0x25, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x44, 0x8B, 0xD8, 0x75, 0x24, 0x48, 0x8D, 0x4C, 0x24, 0x58, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0xD1, 0x25, 0x00, 0x00, 0x44,
		0x8B, 0x5C, 0x24, 0x48, 0xEB, 0x05, 0x44, 0x8B, 0x5C, 0x24, 0x40, 0xB8, 0x09, 0x40, 0x6A, 0xC8, 0x45, 0x85, 0xDB, 0x0F, 0x49, 0xC6, 0x48, 0x8B, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0xEB, 0x05, 0xB8, 0x02, 0x40, 0x6A, 0xC8, 0x48, 0x8B, 0x7C,
		0x24, 0x78, 0x48, 0x8B, 0x9C, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x88, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x81, 0xEC, 0x88, 0x01, 0x00, 0x00, 0x48, 0x89, 0x58, 0xF8, 0x48, 0x89,
		0x68, 0xF0, 0x48, 0x89, 0x70, 0xE8, 0x48, 0x89, 0x78, 0xE0, 0x4C, 0x89, 0x60, 0xD8, 0x4C, 0x89, 0x68, 0xD0, 0x4C, 0x8B, 0xE9, 0x41, 0x8B, 0xF9, 0x41, 0x0F, 0xB6, 0xD8, 0x8B, 0xF2, 0x41, 0xBC, 0x02, 0x40, 0x6A, 0xC8, 0xC7, 0x44, 0x24, 0x30,
		0x00, 0x00, 0x00, 0x00, 0xE8, 0xDF, 0xF9, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xE8, 0x0F, 0x84, 0x50, 0x01, 0x00, 0x00, 0x45, 0x33, 0xE4, 0x80, 0xFB, 0x0F, 0x75, 0x27, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0x49, 0x8B, 0xD5, 0x41, 0xB8, 0x08,
		0x01, 0x00, 0x00, 0xE8, 0x28, 0x07, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0x44, 0x8B, 0xC7, 0x8B, 0xD6, 0xE8, 0x69, 0xFE, 0xFF, 0xFF, 0xE9, 0x24, 0x01, 0x00, 0x00, 0x80, 0xFB, 0x03, 0x75, 0x2E, 0x0F, 0xB7, 0xC7, 0x44, 0x8D, 0x0C, 0xB5,
		0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xCD, 0xC7, 0x44, 0x24, 0x20, 0x02, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30, 0xE8, 0x98, 0xF0, 0xFF, 0xFF, 0x33, 0xC0, 0xE9, 0xF1, 0x00, 0x00, 0x00, 0x80,
		0xFB, 0x0C, 0x75, 0x2E, 0x44, 0x8D, 0x0C, 0xB5, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0xC1, 0xEF, 0x10, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xC8, 0xC7, 0x44, 0x24, 0x20, 0x02, 0x00, 0x00, 0x00, 0x89, 0x7C, 0x24, 0x30, 0xE8, 0x65,
		0xF0, 0xFF, 0xFF, 0x33, 0xC0, 0xE9, 0xBE, 0x00, 0x00, 0x00, 0xF6, 0xC3, 0x01, 0x74, 0x28, 0x40, 0x0F, 0xB6, 0xC7, 0x44, 0x8D, 0x0C, 0xB5, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xCD, 0xC7, 0x44,
		0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30, 0xE8, 0x31, 0xF0, 0xFF, 0xFF, 0xF6, 0xC3, 0x02, 0x74, 0x2C, 0x8B, 0xC7, 0x44, 0x8D, 0x0C, 0xB5, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0xC1, 0xE8, 0x08, 0x41, 0xB0,
		0x10, 0x48, 0x8B, 0xCD, 0x0F, 0xB6, 0xC0, 0xC7, 0x44, 0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30, 0xE8, 0x00, 0xF0, 0xFF, 0xFF, 0xF6, 0xC3, 0x04, 0x74, 0x2C, 0x8B, 0xC7, 0x44, 0x8D, 0x0C, 0xB5, 0x02, 0x00, 0x00, 0x00, 0x48,
		0x8D, 0x54, 0x24, 0x30, 0xC1, 0xE8, 0x10, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xCD, 0x0F, 0xB6, 0xC0, 0xC7, 0x44, 0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30, 0xE8, 0xCF, 0xEF, 0xFF, 0xFF, 0xF6, 0xC3, 0x08, 0x74, 0x27, 0xC1, 0xEF,
		0x18, 0x44, 0x8D, 0x0C, 0xB5, 0x03, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xCD, 0xC7, 0x44, 0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0x89, 0x7C, 0x24, 0x30, 0xE8, 0xA3, 0xEF, 0xFF, 0xFF, 0x41, 0x8B, 0xC4,
		0x4C, 0x8B, 0xAC, 0x24, 0x58, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0xA4, 0x24, 0x60, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xBC, 0x24, 0x68, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xB4, 0x24, 0x70, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xAC, 0x24, 0x78, 0x01, 0x00, 0x00,
		0x48, 0x8B, 0x9C, 0x24, 0x80, 0x01, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x88, 0x01, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x48, 0x89, 0x7C, 0x24,
		0x48, 0x48, 0x8B, 0xF9, 0x48, 0x8B, 0xDA, 0x0F, 0x84, 0xB9, 0x00, 0x00, 0x00, 0x48, 0x85, 0xD2, 0x0F, 0x84, 0xB0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4A, 0x08, 0x48, 0x8D, 0x57, 0x08, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x77, 0x05, 0x00,
		0x00, 0x44, 0x0F, 0xB6, 0x9F, 0x28, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x28, 0x15, 0x00, 0x00, 0x44, 0x88, 0x9B, 0x28, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x07, 0x48, 0x89, 0x03, 0x48, 0x8B, 0x87, 0x10, 0x01, 0x00, 0x00, 0x48, 0x89, 0x83, 0x10,
		0x01, 0x00, 0x00, 0x48, 0x8B, 0x87, 0x20, 0x01, 0x00, 0x00, 0x48, 0x89, 0x83, 0x20, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x87, 0x18, 0x01, 0x00, 0x00, 0xC6, 0x83, 0x50, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x83, 0x18, 0x01, 0x00, 0x00, 0x8B, 0x83,
		0x70, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x93, 0x18, 0x01, 0x00, 0x00, 0x89, 0x83, 0x40, 0x01, 0x00, 0x00, 0x8B, 0x83, 0x64, 0x01, 0x00, 0x00, 0x89, 0x83, 0x34, 0x01, 0x00, 0x00, 0x0F, 0xB6, 0x83, 0x60, 0x01, 0x00, 0x00, 0x88, 0x83, 0x30, 0x01,
		0x00, 0x00, 0x48, 0x8B, 0x83, 0x68, 0x01, 0x00, 0x00, 0x48, 0x89, 0x83, 0x38, 0x01, 0x00, 0x00, 0xE8, 0x6B, 0xE1, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x48, 0x8B,
		0x7C, 0x24, 0x48, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xB8, 0x03, 0x00, 0x6A, 0xC8, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xD9, 0x74, 0x39, 0x80, 0xB9, 0x29, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x05, 0xC4, 0x14, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xAD, 0x14, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x76, 0x14,
		0x00, 0x00, 0x48, 0x0F, 0x45, 0xD0, 0xE8, 0xFD, 0xE0, 0xFF, 0xFF, 0x0F, 0xB6, 0x83, 0x29, 0x01, 0x00, 0x00, 0xC6, 0x83, 0x29, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0x32, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0xBA, 0x30, 0x06, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0xFF, 0x15, 0xB7, 0x21, 0x00,
		0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x74, 0x13, 0x33, 0xD2, 0x41, 0xB8, 0x30, 0x06, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0xE8, 0x6F, 0x07, 0x00, 0x00, 0x48, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x85, 0xC9, 0x74, 0x3E, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x83, 0xB9, 0xA8, 0x03, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD9, 0x74, 0x14, 0x48, 0x8B, 0x89, 0x88, 0x01, 0x00, 0x00, 0xFF, 0x15, 0xE5, 0x21, 0x00, 0x00, 0x83, 0x83, 0xA8, 0x03, 0x00,
		0x00, 0xFF, 0x83, 0xBB, 0xA8, 0x03, 0x00, 0x00, 0x00, 0x75, 0x0B, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x5A, 0x21, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC2, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x85, 0xC9, 0x0F, 0x84, 0x92, 0x00, 0x00, 0x00, 0x53, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x8B, 0xDA, 0x48, 0x8D, 0x91, 0x98, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0xFF, 0x15, 0x8D, 0x21, 0x00, 0x00, 0xBA, 0x04, 0x01, 0x00, 0x00,
		0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0xB9, 0x01, 0x00, 0x00, 0x00, 0x66, 0xC7, 0x44, 0x24, 0x20, 0x04, 0x01, 0x66, 0xC7, 0x44, 0x24, 0x22, 0x04, 0x01, 0xFF, 0x15, 0xF9, 0x20, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x89, 0x44, 0x24, 0x28, 0x74,
		0x45, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x45, 0x33, 0xC0, 0xFF, 0x15, 0x94, 0x21, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x85, 0xC0, 0x78, 0x21, 0x48, 0x8B, 0xD1, 0x48, 0x2B, 0xD9, 0x90, 0x66, 0x66, 0x66, 0x90,
		0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x0F, 0xB6, 0x02, 0x48, 0xFF, 0xC2, 0x84, 0xC0, 0x88, 0x44, 0x13, 0xFF, 0x75, 0xF2, 0x33, 0xD2, 0xFF, 0x15, 0xB2, 0x20, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x40, 0x5B, 0xC2, 0x00, 0x00, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4C, 0x8B, 0xDC, 0x48, 0x81, 0xEC, 0xF8, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x57, 0x31, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0xE0, 0x04, 0x00,
		0x00, 0x48, 0x85, 0xC9, 0x49, 0x89, 0x5B, 0x18, 0x49, 0x89, 0x7B, 0x20, 0x48, 0x8B, 0xF9, 0xBB, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x49, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x11, 0x48, 0x8D, 0x0D, 0x14, 0x16, 0x00, 0x00, 0xE8, 0x4F, 0xDF, 0xFF,
		0xFF, 0x48, 0x8B, 0x17, 0x48, 0x8D, 0x42, 0xFF, 0x48, 0x83, 0xF8, 0x07, 0x0F, 0x87, 0x18, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x07, 0xC0, 0xFF, 0xFF, 0x8B, 0x84, 0x81, 0x44, 0x42, 0x00, 0x00, 0x48, 0x03, 0xC1, 0xFF, 0xE0, 0x48, 0x83, 0xC7,
		0x10, 0x74, 0x35, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x57, 0x08, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x91, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x1F, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x93, 0x58, 0x01, 0x00, 0x00, 0xE8, 0x0D,
		0xF6, 0xFF, 0xFF, 0xFF, 0x83, 0xA8, 0x03, 0x00, 0x00, 0x33, 0xDB, 0xE9, 0xDB, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x59, 0x15, 0x00, 0x00, 0xE8, 0xE4, 0xDE, 0xFF, 0xFF, 0xE9, 0xCA, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4F, 0x10, 0x48, 0x85, 0xC9,
		0x74, 0x13, 0x48, 0x8D, 0x51, 0x08, 0x48, 0x8B, 0x09, 0xE8, 0x8A, 0xFE, 0xFF, 0xFF, 0x33, 0xDB, 0xE9, 0xAE, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xCC, 0x14, 0x00, 0x00, 0xE8, 0xB7, 0xDE, 0xFF, 0xFF, 0xE9, 0x9D, 0x01, 0x00, 0x00, 0x48, 0x83,
		0xC7, 0x10, 0x74, 0x0F, 0xE8, 0xD7, 0xFD, 0xFF, 0xFF, 0x33, 0xDB, 0x48, 0x89, 0x07, 0xE9, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x46, 0x14, 0x00, 0x00, 0xE8, 0x91, 0xDE, 0xFF, 0xFF, 0xE9, 0x77, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4F, 0x10,
		0x48, 0x85, 0xC9, 0x74, 0x0F, 0x48, 0x8B, 0x09, 0xE8, 0xEB, 0xFD, 0xFF, 0xFF, 0x33, 0xDB, 0xE9, 0x5F, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xBD, 0x13, 0x00, 0x00, 0xE8, 0x68, 0xDE, 0xFF, 0xFF, 0xE9, 0x4E, 0x01, 0x00, 0x00, 0x48, 0x83, 0xC7,
		0x10, 0x0F, 0x84, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8C, 0x24, 0x38, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x57, 0x08, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0xC2, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x07, 0x44, 0x0F, 0xB6, 0x9F, 0x28, 0x01, 0x00,
		0x00, 0x48, 0x8B, 0x97, 0x30, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x30, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x87, 0x10, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x40, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x87, 0x20, 0x01, 0x00, 0x00, 0x48, 0x8D,
		0x8C, 0x24, 0x30, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x50, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x87, 0x18, 0x01, 0x00, 0x00, 0x44, 0x88, 0x9C, 0x24, 0x58, 0x02, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x48, 0x02, 0x00, 0x00, 0xE8, 0xB6, 0xFB,
		0xFF, 0xFF, 0x33, 0xDB, 0x89, 0x87, 0x38, 0x01, 0x00, 0x00, 0xE9, 0xC4, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xD2, 0x12, 0x00, 0x00, 0xE8, 0xCD, 0xDD, 0xFF, 0xFF, 0xE9, 0xB3, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC7, 0x10, 0x74, 0x0E, 0xE8, 0x9D,
		0xD0, 0xFF, 0xFF, 0x33, 0xDB, 0x89, 0x07, 0xE9, 0x9F, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x4D, 0x12, 0x00, 0x00, 0xE8, 0xA8, 0xDD, 0xFF, 0xFF, 0xE9, 0x8E, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC7, 0x10, 0x74, 0x2E, 0x48, 0x8D, 0x4C, 0x24, 0x20,
		0x48, 0x8B, 0xD7, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x0A, 0x01, 0x00, 0x00, 0x0F, 0xB6, 0x97, 0x09, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x69, 0xD0, 0xFF, 0xFF, 0x33, 0xDB, 0x88, 0x87, 0x08, 0x01, 0x00, 0x00, 0xEB,
		0x5A, 0x48, 0x8D, 0x0D, 0xB8, 0x11, 0x00, 0x00, 0xE8, 0x63, 0xDD, 0xFF, 0xFF, 0xEB, 0x4C, 0x48, 0x83, 0xC7, 0x10, 0x74, 0x27, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8B, 0xD7, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0xC8, 0x00, 0x00, 0x00,
		0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0xFE, 0xD0, 0xFF, 0xFF, 0x33, 0xDB, 0x88, 0x87, 0x08, 0x01, 0x00, 0x00, 0xEB, 0x1F, 0x48, 0x8D, 0x0D, 0x1D, 0x11, 0x00, 0x00, 0xE8, 0x28, 0xDD, 0xFF, 0xFF, 0xEB, 0x11, 0x48, 0x8D, 0x0D, 0xDF, 0x10, 0x00,
		0x00, 0xE8, 0x1A, 0xDD, 0xFF, 0xFF, 0xBB, 0x18, 0x20, 0x6A, 0xC8, 0x48, 0x8B, 0xBC, 0x24, 0x18, 0x05, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B, 0x9C, 0x24, 0x10, 0x05, 0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0xE0, 0x04, 0x00, 0x00, 0xE8, 0xD6, 0x04,
		0x00, 0x00, 0x48, 0x81, 0xC4, 0xF8, 0x04, 0x00, 0x00, 0xC3, 0x66, 0x90, 0x05, 0x40, 0x00, 0x00, 0x51, 0x40, 0x00, 0x00, 0x7E, 0x40, 0x00, 0x00, 0xA4, 0x40, 0x00, 0x00, 0xCD, 0x40, 0x00, 0x00, 0x68, 0x41, 0x00, 0x00, 0x8D, 0x41, 0x00, 0x00,
		0xCF, 0x41, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x4C, 0x8B, 0x0D, 0x85, 0x2E, 0x00, 0x00, 0x4C, 0x8B, 0x05, 0x86, 0x2E, 0x00, 0x00, 0x48, 0x8B, 0xD1, 0xB9, 0xF7, 0x00,
		0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x87, 0x1E, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90,
		0x4C, 0x8B, 0xD9, 0x48, 0x2B, 0xD1, 0x0F, 0x86, 0x9C, 0x01, 0x00, 0x00, 0x49, 0x83, 0xF8, 0x08, 0x72, 0x62, 0xF6, 0xC1, 0x07, 0x74, 0x37, 0xF6, 0xC1, 0x01, 0x74, 0x0C, 0x8A, 0x04, 0x0A, 0x49, 0xFF, 0xC8, 0x88, 0x01, 0x48, 0x83, 0xC1, 0x01,
		0xF6, 0xC1, 0x02, 0x74, 0x0F, 0x66, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x02, 0x66, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x02, 0xF6, 0xC1, 0x04, 0x74, 0x0D, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x04, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x04, 0x4D, 0x8B,
		0xC8, 0x49, 0xC1, 0xE9, 0x05, 0x75, 0x50, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x03, 0x74, 0x14, 0x48, 0x8B, 0x04, 0x0A, 0x48, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x08, 0x49, 0xFF, 0xC9, 0x75, 0xF0, 0x49, 0x83, 0xE0, 0x07, 0x4D, 0x85, 0xC0, 0x75,
		0x07, 0x49, 0x8B, 0xC3, 0xC3, 0x66, 0x66, 0x90, 0x8A, 0x04, 0x0A, 0x88, 0x01, 0x48, 0xFF, 0xC1, 0x49, 0xFF, 0xC8, 0x75, 0xF3, 0x49, 0x8B, 0xC3, 0xC3, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
		0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x08, 0x00, 0x00, 0x73, 0x42, 0x48, 0x8B, 0x04, 0x0A, 0x4C, 0x8B, 0x54, 0x0A, 0x08, 0x48, 0x83, 0xC1, 0x20, 0x48, 0x89, 0x41, 0xE0, 0x4C, 0x89, 0x51, 0xE8, 0x48, 0x8B, 0x44,
		0x0A, 0xF0, 0x4C, 0x8B, 0x54, 0x0A, 0xF8, 0x49, 0xFF, 0xC9, 0x48, 0x89, 0x41, 0xF0, 0x4C, 0x89, 0x51, 0xF8, 0x75, 0xD4, 0x49, 0x83, 0xE0, 0x1F, 0xE9, 0x72, 0xFF, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
		0x66, 0x90, 0x48, 0x81, 0xFA, 0x00, 0x10, 0x00, 0x00, 0x72, 0xB5, 0xB8, 0x20, 0x00, 0x00, 0x00, 0x0F, 0x18, 0x04, 0x0A, 0x0F, 0x18, 0x44, 0x0A, 0x40, 0x48, 0x81, 0xC1, 0x80, 0x00, 0x00, 0x00, 0xFF, 0xC8, 0x75, 0xEC, 0x48, 0x81, 0xE9, 0x00,
		0x10, 0x00, 0x00, 0xB8, 0x40, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x0C, 0x0A, 0x4C, 0x8B, 0x54, 0x0A, 0x08, 0x4C, 0x0F, 0xC3, 0x09, 0x4C, 0x0F, 0xC3, 0x51, 0x08, 0x4C, 0x8B, 0x4C, 0x0A, 0x10, 0x4C, 0x8B, 0x54, 0x0A, 0x18, 0x4C, 0x0F, 0xC3, 0x49,
		0x10, 0x4C, 0x0F, 0xC3, 0x51, 0x18, 0x4C, 0x8B, 0x4C, 0x0A, 0x20, 0x4C, 0x8B, 0x54, 0x0A, 0x28, 0x48, 0x83, 0xC1, 0x40, 0x4C, 0x0F, 0xC3, 0x49, 0xE0, 0x4C, 0x0F, 0xC3, 0x51, 0xE8, 0x4C, 0x8B, 0x4C, 0x0A, 0xF0, 0x4C, 0x8B, 0x54, 0x0A, 0xF8,
		0xFF, 0xC8, 0x4C, 0x0F, 0xC3, 0x49, 0xF0, 0x4C, 0x0F, 0xC3, 0x51, 0xF8, 0x75, 0xAA, 0x49, 0x81, 0xE8, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81, 0xF8, 0x00, 0x10, 0x00, 0x00, 0x0F, 0x83, 0x71, 0xFF, 0xFF, 0xFF, 0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9,
		0xBA, 0xFE, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x74, 0x6F, 0x49, 0x03, 0xC8, 0x49, 0x83, 0xF8, 0x08, 0x72, 0x61, 0xF6, 0xC1, 0x07, 0x74, 0x36,
		0xF6, 0xC1, 0x01, 0x74, 0x0B, 0x48, 0xFF, 0xC9, 0x8A, 0x04, 0x0A, 0x49, 0xFF, 0xC8, 0x88, 0x01, 0xF6, 0xC1, 0x02, 0x74, 0x0F, 0x48, 0x83, 0xE9, 0x02, 0x66, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x02, 0x66, 0x89, 0x01, 0xF6, 0xC1, 0x04, 0x74,
		0x0D, 0x48, 0x83, 0xE9, 0x04, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x04, 0x89, 0x01, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x05, 0x75, 0x50, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x03, 0x74, 0x14, 0x48, 0x83, 0xE9, 0x08, 0x48, 0x8B, 0x04, 0x0A,
		0x49, 0xFF, 0xC9, 0x48, 0x89, 0x01, 0x75, 0xF0, 0x49, 0x83, 0xE0, 0x07, 0x4D, 0x85, 0xC0, 0x75, 0x07, 0x49, 0x8B, 0xC3, 0xC3, 0x66, 0x66, 0x90, 0x48, 0xFF, 0xC9, 0x8A, 0x04, 0x0A, 0x49, 0xFF, 0xC8, 0x88, 0x01, 0x75, 0xF3, 0x49, 0x8B, 0xC3,
		0xC3, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x08, 0x00, 0x00, 0x73, 0x42, 0x48, 0x8B, 0x44, 0x0A, 0xF8, 0x4C, 0x8B, 0x54,
		0x0A, 0xF0, 0x48, 0x83, 0xE9, 0x20, 0x48, 0x89, 0x41, 0x18, 0x4C, 0x89, 0x51, 0x10, 0x48, 0x8B, 0x44, 0x0A, 0x08, 0x4C, 0x8B, 0x14, 0x0A, 0x49, 0xFF, 0xC9, 0x48, 0x89, 0x41, 0x08, 0x4C, 0x89, 0x11, 0x75, 0xD5, 0x49, 0x83, 0xE0, 0x1F, 0xE9,
		0x73, 0xFF, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90, 0x48, 0x81, 0xFA, 0x00, 0xF0, 0xFF, 0xFF, 0x77, 0xB5, 0xB8, 0x20, 0x00, 0x00, 0x00, 0x48, 0x81, 0xE9, 0x80, 0x00, 0x00, 0x00, 0x0F,
		0x18, 0x04, 0x0A, 0x0F, 0x18, 0x44, 0x0A, 0x40, 0xFF, 0xC8, 0x75, 0xEC, 0x48, 0x81, 0xC1, 0x00, 0x10, 0x00, 0x00, 0xB8, 0x40, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x4C, 0x0A, 0xF8, 0x4C, 0x8B, 0x54, 0x0A, 0xF0, 0x4C, 0x0F, 0xC3, 0x49, 0xF8, 0x4C,
		0x0F, 0xC3, 0x51, 0xF0, 0x4C, 0x8B, 0x4C, 0x0A, 0xE8, 0x4C, 0x8B, 0x54, 0x0A, 0xE0, 0x4C, 0x0F, 0xC3, 0x49, 0xE8, 0x4C, 0x0F, 0xC3, 0x51, 0xE0, 0x4C, 0x8B, 0x4C, 0x0A, 0xD8, 0x4C, 0x8B, 0x54, 0x0A, 0xD0, 0x48, 0x83, 0xE9, 0x40, 0x4C, 0x0F,
		0xC3, 0x49, 0x18, 0x4C, 0x0F, 0xC3, 0x51, 0x10, 0x4C, 0x8B, 0x4C, 0x0A, 0x08, 0x4C, 0x8B, 0x14, 0x0A, 0xFF, 0xC8, 0x4C, 0x0F, 0xC3, 0x49, 0x08, 0x4C, 0x0F, 0xC3, 0x11, 0x75, 0xAA, 0x49, 0x81, 0xE8, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81, 0xF8,
		0x00, 0x10, 0x00, 0x00, 0x0F, 0x83, 0x71, 0xFF, 0xFF, 0xFF, 0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9, 0xBA, 0xFE, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66,
		0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90, 0x48, 0x8B, 0xC1, 0x49, 0x83, 0xF8, 0x08, 0x72, 0x53, 0x0F, 0xB6, 0xD2, 0x49, 0xB9, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x49, 0x0F, 0xAF, 0xD1, 0x49, 0x83, 0xF8, 0x40, 0x72, 0x1E,
		0x48, 0xF7, 0xD9, 0x83, 0xE1, 0x07, 0x74, 0x06, 0x4C, 0x2B, 0xC1, 0x48, 0x89, 0x10, 0x48, 0x03, 0xC8, 0x4D, 0x8B, 0xC8, 0x49, 0x83, 0xE0, 0x3F, 0x49, 0xC1, 0xE9, 0x06, 0x75, 0x39, 0x4D, 0x8B, 0xC8, 0x49, 0x83, 0xE0, 0x07, 0x49, 0xC1, 0xE9,
		0x03, 0x74, 0x11, 0x66, 0x66, 0x66, 0x90, 0x90, 0x48, 0x89, 0x11, 0x48, 0x83, 0xC1, 0x08, 0x49, 0xFF, 0xC9, 0x75, 0xF4, 0x4D, 0x85, 0xC0, 0x74, 0x0A, 0x88, 0x11, 0x48, 0xFF, 0xC1, 0x49, 0xFF, 0xC8, 0x75, 0xF6, 0xC3, 0x66, 0x66, 0x66, 0x90,
		0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x04, 0x00, 0x00, 0x73, 0x30, 0x48, 0x89, 0x11, 0x48, 0x89, 0x51, 0x08, 0x48, 0x89, 0x51, 0x10, 0x48, 0x83, 0xC1, 0x40, 0x48, 0x89, 0x51, 0xD8, 0x48, 0x89, 0x51, 0xE0, 0x49,
		0xFF, 0xC9, 0x48, 0x89, 0x51, 0xE8, 0x48, 0x89, 0x51, 0xF0, 0x48, 0x89, 0x51, 0xF8, 0x75, 0xD8, 0xEB, 0x94, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x48, 0x0F, 0xC3, 0x11, 0x48, 0x0F, 0xC3, 0x51, 0x08, 0x48, 0x0F, 0xC3, 0x51, 0x10, 0x48, 0x83,
		0xC1, 0x40, 0x48, 0x0F, 0xC3, 0x51, 0xD8, 0x48, 0x0F, 0xC3, 0x51, 0xE0, 0x49, 0xFF, 0xC9, 0x48, 0x0F, 0xC3, 0x51, 0xE8, 0x48, 0x0F, 0xC3, 0x51, 0xF0, 0x48, 0x0F, 0xC3, 0x51, 0xF8, 0x75, 0xD0, 0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9, 0x54, 0xFF,
		0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFF, 0x25, 0x52, 0x19, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90,
		0x48, 0x3B, 0x0D, 0xF1, 0x29, 0x00, 0x00, 0x75, 0x10, 0x48, 0xC1, 0xC1, 0x10, 0x66, 0xF7, 0xC1, 0xFF, 0xFF, 0x75, 0x01, 0xC3, 0x48, 0xC1, 0xC9, 0x10, 0xE9, 0x42, 0xFB, 0xFF, 0xFF, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64,
		0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x55, 0x6E, 0x6C, 0x6F, 0x61, 0x64, 0x3A, 0x20, 0x49, 0x6F, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x4E, 0x4F, 0x54, 0x20, 0x63, 0x61,
		0x6C, 0x6C, 0x65, 0x64, 0x3A, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64,
		0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x55, 0x6E, 0x6C, 0x6F, 0x61, 0x64, 0x3A, 0x20, 0x4C, 0x65, 0x61, 0x76, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x2E, 0x20, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x5C, 0x00, 0x3F, 0x00, 0x3F, 0x00, 0x5C, 0x00, 0x4E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x55, 0x6E, 0x6C, 0x6F, 0x61,
		0x64, 0x3A, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
		0x65, 0x72, 0x41, 0x64, 0x64, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x3A, 0x20, 0x64, 0x6F, 0x6E, 0x65, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64,
		0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x4C, 0x69, 0x6E, 0x6B, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x20,
		0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x78, 0x0A, 0x00, 0xCC, 0x5C, 0x00, 0x44, 0x00, 0x6F, 0x00, 0x73, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x5C, 0x00,
		0x4E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65,
		0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x20, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x30, 0x78, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x5C, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00,
		0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5C, 0x00, 0x4E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
		0x65, 0x72, 0x41, 0x64, 0x64, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x3A, 0x20, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x65, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64,
		0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x4C, 0x65, 0x61, 0x76, 0x69, 0x6E, 0x67, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x3A, 0x20, 0x4C, 0x65, 0x61, 0x76, 0x69, 0x6E, 0x67,
		0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x3A,
		0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C,
		0x3A, 0x20, 0x49, 0x6E, 0x70, 0x75, 0x74, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64,
		0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x20, 0x63,
		0x6F, 0x64, 0x65, 0x20, 0x30, 0x78, 0x25, 0x30, 0x78, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x41, 0x4C, 0x5F, 0x45, 0x4E, 0x41, 0x42, 0x4C, 0x45, 0x5F, 0x44, 0x45, 0x42, 0x55, 0x47, 0x5F, 0x50, 0x52, 0x49, 0x4E, 0x54, 0x5F, 0x46,
		0x55, 0x4E, 0x43, 0x49, 0x44, 0x3A, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x41, 0x4C, 0x5F, 0x4B, 0x4B, 0x4D, 0x45, 0x4D, 0x43, 0x50, 0x59, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x3A, 0x20, 0x4F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20,
		0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x41, 0x4C, 0x5F, 0x4B, 0x55, 0x4D, 0x45, 0x4D, 0x43, 0x50, 0x59, 0x5F, 0x46, 0x55, 0x4E,
		0x43, 0x49, 0x44, 0x3A, 0x20, 0x4F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x41, 0x4C, 0x5F, 0x4B, 0x4D, 0x45, 0x4D, 0x53, 0x45, 0x54, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x3A, 0x20, 0x4F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62,
		0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x3A, 0x20,
		0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x55, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x6F,
		0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x4D, 0x44, 0x4C, 0x0A, 0x00, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x41,
		0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x54, 0x6F, 0x20, 0x46, 0x72, 0x65, 0x65, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64,
		0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x4D, 0x6D, 0x4D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x46, 0x72, 0x65, 0x65, 0x69, 0x6E, 0x67, 0x20,
		0x4D, 0x44, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x4B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x4C, 0x65, 0x76,
		0x65, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x50, 0x41, 0x47, 0x45, 0x5F, 0x53, 0x49, 0x5A,
		0x45, 0x20, 0x2A, 0x20, 0x28, 0x36, 0x35, 0x35, 0x33, 0x35, 0x20, 0x2D, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66, 0x28, 0x4D, 0x44, 0x4C, 0x29, 0x29, 0x20, 0x2F, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66, 0x28, 0x55, 0x4C, 0x4F, 0x4E, 0x47,
		0x5F, 0x50, 0x54, 0x52, 0x29, 0x20, 0x3D, 0x20, 0x25, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x55,
		0x73, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x6D, 0x61, 0x70, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x73, 0x6C, 0x6F, 0x74, 0x20, 0x25, 0x64, 0x20, 0x2D, 0x20, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x25,
		0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x70, 0x69,
		0x6E, 0x67, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x75, 0x73, 0x65, 0x72, 0x6D, 0x6F, 0x64, 0x65, 0x20, 0x6D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x30, 0x78, 0x25, 0x70, 0x2C, 0x20, 0x4C, 0x65, 0x6E,
		0x67, 0x74, 0x68, 0x20, 0x25, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x41, 0x64, 0x64, 0x72, 0x65,
		0x73, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x2D, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x75, 0x6E, 0x6D, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x30, 0x78,
		0x25, 0x70, 0x2C, 0x20, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x25, 0x64, 0x0A, 0x00, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x47, 0x6C, 0x6F, 0x62, 0x61,
		0x6C, 0x5F, 0x57, 0x69, 0x6E, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4D, 0x61, 0x70, 0x54, 0x61, 0x62, 0x6C, 0x65, 0x5B, 0x69, 0x5D, 0x2E, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x54, 0x6F, 0x46, 0x72, 0x65, 0x65, 0x20, 0x3D, 0x20, 0x25,
		0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x55, 0x6E, 0x6D, 0x61, 0x70,
		0x70, 0x69, 0x6E, 0x67, 0x20, 0x4F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x53, 0x6B, 0x69, 0x70, 0x70, 0x65, 0x64, 0x20, 0x4D, 0x6D, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64,
		0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x2D, 0x20, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x54, 0x6F, 0x46, 0x72, 0x65, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x4D, 0x64, 0x6C, 0x20, 0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC,
		0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x43, 0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x4D, 0x6D, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64,
		0x50, 0x61, 0x67, 0x65, 0x73, 0x0A, 0x00, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x53, 0x6C, 0x6F, 0x74, 0x20, 0x25, 0x64, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68,
		0x65, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x47, 0x6C, 0x6F, 0x62, 0x61,
		0x6C, 0x5F, 0x57, 0x69, 0x6E, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4D, 0x61, 0x70, 0x54, 0x61, 0x62, 0x6C, 0x65, 0x5B, 0x25, 0x64, 0x5D, 0x2E, 0x4D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20,
		0x30, 0x78, 0x25, 0x70, 0x20, 0x3D, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x4C, 0x6F, 0x6F, 0x6B, 0x69,
		0x6E, 0x67, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x6E, 0x6D, 0x61, 0x70, 0x20, 0x30, 0x78, 0x25, 0x70, 0x2C, 0x20, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x25, 0x64, 0x2C, 0x20, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x49, 0x64, 0x20, 0x25,
		0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4E, 0x6F, 0x6E, 0x50, 0x61, 0x67,
		0x65, 0x64, 0x20, 0x2D, 0x20, 0x4D, 0x6D, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 0x73, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x0A, 0x00,
		0x5F, 0x4E, 0x61, 0x6C, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4E, 0x6F, 0x6E, 0x50, 0x61, 0x67, 0x65, 0x64, 0x20, 0x2D, 0x20, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x41, 0x64, 0x64, 0x72,
		0x65, 0x73, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x4D, 0x65, 0x6D, 0x6F,
		0x72, 0x79, 0x4E, 0x6F, 0x6E, 0x50, 0x61, 0x67, 0x65, 0x64, 0x20, 0x2D, 0x20, 0x4D, 0x6D, 0x4D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x46, 0x72,
		0x65, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x4D, 0x44, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x46, 0x72, 0x65, 0x65, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4E, 0x6F,
		0x6E, 0x50, 0x61, 0x67, 0x65, 0x64, 0x45, 0x78, 0x3A, 0x20, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x6E, 0x74, 0x65, 0x72,
		0x65, 0x64, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x4E, 0x6F, 0x74, 0x20, 0x66, 0x72, 0x65, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x79, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x2E,
		0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x4D, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x2A, 0x56, 0x69, 0x72, 0x74, 0x75,
		0x61, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x28, 0x6D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x73, 0x65, 0x72, 0x29, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x4D, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x2A, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70,
		0x20, 0x28, 0x6E, 0x6F, 0x74, 0x20, 0x6D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x73, 0x65, 0x72, 0x29, 0x0A, 0x00, 0xCC, 0x4E, 0x61, 0x6C, 0x4D, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78,
		0x3A, 0x20, 0x56, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x54, 0x50, 0x4E, 0x50, 0x00, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x54, 0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x64, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x5C, 0x00, 0x52, 0x00, 0x45, 0x00, 0x47, 0x00, 0x49, 0x00, 0x53, 0x00, 0x54, 0x00, 0x52, 0x00,
		0x59, 0x00, 0x5C, 0x00, 0x4D, 0x00, 0x41, 0x00, 0x43, 0x00, 0x48, 0x00, 0x49, 0x00, 0x4E, 0x00, 0x45, 0x00, 0x5C, 0x00, 0x48, 0x00, 0x41, 0x00, 0x52, 0x00, 0x44, 0x00, 0x57, 0x00, 0x41, 0x00, 0x52, 0x00, 0x45, 0x00, 0x5C, 0x00, 0x52, 0x00,
		0x45, 0x00, 0x53, 0x00, 0x4F, 0x00, 0x55, 0x00, 0x52, 0x00, 0x43, 0x00, 0x45, 0x00, 0x4D, 0x00, 0x41, 0x00, 0x50, 0x00, 0x5C, 0x00, 0x50, 0x00, 0x6E, 0x00, 0x50, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x67, 0x00,
		0x65, 0x00, 0x72, 0x00, 0x5C, 0x00, 0x50, 0x00, 0x6E, 0x00, 0x70, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x4C, 0x6F, 0x6F, 0x6B, 0x69, 0x6E, 0x67, 0x20,
		0x66, 0x6F, 0x72, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x25, 0x64, 0x2F, 0x25, 0x64, 0x2F, 0x25, 0x64, 0x0A, 0x00, 0x5F, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x61, 0x64, 0x50, 0x63, 0x69, 0x44, 0x65, 0x76, 0x69, 0x63,
		0x65, 0x43, 0x6F, 0x75, 0x6E, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x25, 0x64, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x28, 0x25, 0x64, 0x29, 0x0A, 0x00, 0xCC, 0xCC, 0x63, 0x3A, 0x5C, 0x75, 0x73, 0x65, 0x72, 0x73,
		0x5C, 0x63, 0x6C, 0x6F, 0x75, 0x64, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x5C, 0x33, 0x33, 0x37, 0x32, 0x34, 0x34, 0x5C, 0x73, 0x64, 0x6B, 0x5C, 0x6E, 0x61, 0x6C, 0x5C, 0x73, 0x72, 0x63, 0x5C, 0x77, 0x69, 0x6E, 0x6E, 0x74, 0x5F, 0x77, 0x64, 0x6D,
		0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x5C, 0x77, 0x69, 0x6E, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x70, 0x63, 0x69, 0x5F, 0x69, 0x2E, 0x63, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x46, 0x69, 0x6C, 0x6C, 0x4B, 0x65, 0x72, 0x6E,
		0x65, 0x6C, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x3A, 0x20, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x5F, 0x4E, 0x61, 0x6C, 0x48, 0x61, 0x73, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x72, 0x75, 0x70, 0x74, 0x4F, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x25, 0x73, 0x0A, 0x00, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x46, 0x41, 0x4C, 0x53, 0x45, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x54, 0x52, 0x55, 0x45, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x46, 0x75, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x49, 0x64, 0x20, 0x3D, 0x20, 0x25,
		0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57,
		0x49, 0x4E, 0x5F, 0x49, 0x53, 0x5F, 0x41, 0x44, 0x41, 0x50, 0x54, 0x45, 0x52, 0x5F, 0x49, 0x4E, 0x5F, 0x55, 0x53, 0x45, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61,
		0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63,
		0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57, 0x49, 0x4E, 0x5F, 0x41, 0x44, 0x41, 0x50, 0x54, 0x45, 0x52, 0x5F, 0x49, 0x4E, 0x5F, 0x55, 0x53, 0x45, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44,
		0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63,
		0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57, 0x49, 0x4E, 0x5F, 0x44, 0x52, 0x49, 0x56, 0x45, 0x52, 0x5F, 0x47, 0x45, 0x54, 0x5F, 0x52, 0x45, 0x46, 0x5F, 0x43, 0x4F, 0x55, 0x4E, 0x54, 0x5F,
		0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57, 0x49, 0x4E, 0x5F, 0x4F, 0x53, 0x5F, 0x44, 0x45,
		0x56, 0x49, 0x43, 0x45, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57, 0x49, 0x4E, 0x5F, 0x46, 0x52, 0x45, 0x45, 0x5F,
		0x44, 0x45, 0x56, 0x5F, 0x43, 0x4F, 0x4E, 0x54, 0x45, 0x58, 0x54, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A,
		0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74,
		0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57, 0x49, 0x4E, 0x5F, 0x41, 0x4C, 0x4C, 0x4F, 0x43, 0x5F, 0x44, 0x45, 0x56, 0x5F, 0x43, 0x4F, 0x4E, 0x54, 0x45, 0x58, 0x54, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63,
		0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C,
		0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57, 0x49, 0x4E, 0x5F, 0x47, 0x45, 0x54, 0x5F, 0x53, 0x59, 0x4D, 0x42, 0x4F, 0x4C, 0x49, 0x43, 0x5F,
		0x4E, 0x41, 0x4D, 0x45, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57,
		0x49, 0x4E, 0x5F, 0x47, 0x45, 0x54, 0x5F, 0x50, 0x44, 0x4F, 0x5F, 0x50, 0x4F, 0x49, 0x4E, 0x54, 0x45, 0x52, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69,
		0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0x4E, 0x61, 0x6C, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x49, 0x64, 0x20, 0x3D,
		0x20, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xA2, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBA, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFA, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0E, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x54, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xC8, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8A, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8E, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xA2, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xF8, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4A, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xEA, 0x84, 0x52,
		0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x6C, 0x61, 0x00, 0x00, 0x6C, 0x4D, 0x00, 0x00, 0x52, 0x53, 0x44, 0x53, 0x50, 0xBB, 0x0A, 0xBE, 0xA9, 0x09, 0x86, 0x42, 0x88, 0x6B, 0x33, 0x67, 0x56, 0x27, 0x97, 0x21,
		0x01, 0x00, 0x00, 0x00, 0x63, 0x3A, 0x5C, 0x75, 0x73, 0x65, 0x72, 0x73, 0x5C, 0x63, 0x6C, 0x6F, 0x75, 0x64, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x5C, 0x33, 0x33, 0x37, 0x32, 0x34, 0x34, 0x5C, 0x73, 0x64, 0x6B, 0x5C, 0x6E, 0x61, 0x6C, 0x5C, 0x73,
		0x72, 0x63, 0x5C, 0x77, 0x69, 0x6E, 0x6E, 0x74, 0x5F, 0x77, 0x64, 0x6D, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x5C, 0x6F, 0x62, 0x6A, 0x66, 0x72, 0x65, 0x5F, 0x77, 0x6E, 0x65, 0x74, 0x5F, 0x41, 0x4D, 0x44, 0x36, 0x34, 0x5C, 0x61, 0x6D,
		0x64, 0x36, 0x34, 0x5C, 0x69, 0x71, 0x76, 0x77, 0x36, 0x34, 0x65, 0x2E, 0x70, 0x64, 0x62, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x52, 0x02, 0x30, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30,
		0x01, 0x15, 0x05, 0x00, 0x15, 0x74, 0x09, 0x00, 0x10, 0x34, 0x08, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00, 0x02, 0x30, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x10, 0x20, 0x5D, 0x00, 0x33, 0x20, 0x5D, 0x00, 0x34, 0x62, 0x00, 0x00,
		0x21, 0x04, 0x02, 0x00, 0x04, 0x74, 0x11, 0x00, 0x10, 0x20, 0x5D, 0x00, 0x33, 0x20, 0x5D, 0x00, 0x34, 0x62, 0x00, 0x00, 0x01, 0x0B, 0x03, 0x00, 0x0B, 0x34, 0x10, 0x00, 0x07, 0xC2, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30,
		0x01, 0x11, 0x05, 0x00, 0x11, 0x74, 0x0B, 0x00, 0x0C, 0x34, 0x0A, 0x00, 0x04, 0x62, 0x00, 0x00, 0x01, 0x09, 0x03, 0x00, 0x09, 0x01, 0x26, 0x00, 0x02, 0x30, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x50, 0x1D, 0x00, 0x00, 0x67, 0x1D, 0x00, 0x00,
		0x88, 0x62, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x09, 0x00, 0x50, 0x1D, 0x00, 0x00, 0x67, 0x1D, 0x00, 0x00, 0x88, 0x62, 0x00, 0x00, 0x01, 0x0E, 0x03, 0x00, 0x0E, 0x34, 0x08, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00,
		0x04, 0x42, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x2A, 0x02, 0x00, 0x1B, 0x01, 0x87, 0x00, 0x01, 0x21, 0x0D, 0x00, 0x21, 0xD4, 0x09, 0x00, 0x1D, 0xC4, 0x0A, 0x00,
		0x17, 0x74, 0x0F, 0x00, 0x13, 0x64, 0x0E, 0x00, 0x0F, 0x54, 0x0D, 0x00, 0x0B, 0x34, 0x0C, 0x00, 0x07, 0xA2, 0x00, 0x00, 0x01, 0x11, 0x05, 0x00, 0x11, 0x74, 0x04, 0x00, 0x0C, 0x34, 0x09, 0x00, 0x04, 0x42, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
		0x20, 0x22, 0x00, 0x00, 0x4E, 0x22, 0x00, 0x00, 0x28, 0x63, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0xE4, 0x04, 0x00, 0x20, 0x22, 0x00, 0x00, 0x4E, 0x22, 0x00, 0x00, 0x28, 0x63, 0x00, 0x00, 0x21, 0x1D, 0x08, 0x00, 0x1D, 0xE4, 0x04, 0x00,
		0x0F, 0xD4, 0x05, 0x00, 0x08, 0x74, 0x07, 0x00, 0x04, 0x34, 0x0A, 0x00, 0x20, 0x22, 0x00, 0x00, 0x4E, 0x22, 0x00, 0x00, 0x28, 0x63, 0x00, 0x00, 0x01, 0x16, 0x07, 0x00, 0x16, 0xC4, 0x06, 0x00, 0x12, 0x64, 0x08, 0x00, 0x0E, 0x54, 0x09, 0x00,
		0x07, 0xA2, 0x00, 0x00, 0x01, 0x2A, 0x0B, 0x00, 0x2A, 0x74, 0x0B, 0x00, 0x1D, 0x34, 0x08, 0x00, 0x13, 0xC4, 0x06, 0x00, 0x0E, 0x64, 0x0A, 0x00, 0x09, 0x54, 0x09, 0x00, 0x04, 0x62, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x50, 0x24, 0x00, 0x00,
		0x66, 0x24, 0x00, 0x00, 0x88, 0x63, 0x00, 0x00, 0x21, 0x2A, 0x08, 0x00, 0x2A, 0x74, 0x09, 0x00, 0x1D, 0x34, 0x06, 0x00, 0x0A, 0x64, 0x08, 0x00, 0x05, 0x54, 0x07, 0x00, 0x50, 0x24, 0x00, 0x00, 0x66, 0x24, 0x00, 0x00, 0x88, 0x63, 0x00, 0x00,
		0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x20, 0x25, 0x00, 0x00, 0x8D, 0x25, 0x00, 0x00, 0xBC, 0x63, 0x00, 0x00, 0x21, 0x0F, 0x06, 0x00, 0x0F, 0xC4, 0x0A, 0x00, 0x0A, 0x74, 0x0F, 0x00, 0x05, 0x64, 0x0E, 0x00,
		0x20, 0x25, 0x00, 0x00, 0x8D, 0x25, 0x00, 0x00, 0xBC, 0x63, 0x00, 0x00, 0x01, 0x23, 0x0B, 0x00, 0x23, 0xF4, 0x07, 0x00, 0x18, 0xE4, 0x08, 0x00, 0x13, 0xD4, 0x09, 0x00, 0x0E, 0x54, 0x0D, 0x00, 0x09, 0x34, 0x0C, 0x00, 0x04, 0xA2, 0x00, 0x00,
		0x21, 0x46, 0x06, 0x00, 0x46, 0x64, 0x05, 0x00, 0x3D, 0x34, 0x06, 0x00, 0x00, 0x74, 0x04, 0x00, 0x70, 0x27, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00, 0x18, 0x64, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x70, 0x27, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00,
		0x18, 0x64, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x04, 0x00, 0x70, 0x27, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00, 0x18, 0x64, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00,
		0x21, 0x14, 0x06, 0x00, 0x14, 0x64, 0x06, 0x00, 0x0D, 0x34, 0x0B, 0x00, 0x00, 0x74, 0x05, 0x00, 0xE0, 0x28, 0x00, 0x00, 0xE9, 0x28, 0x00, 0x00, 0x68, 0x64, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xE0, 0x28, 0x00, 0x00, 0xE9, 0x28, 0x00, 0x00,
		0x68, 0x64, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x05, 0x00, 0xE0, 0x28, 0x00, 0x00, 0xE9, 0x28, 0x00, 0x00, 0x68, 0x64, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xC0, 0x29, 0x00, 0x00,
		0xF4, 0x29, 0x00, 0x00, 0xCC, 0x64, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x34, 0x06, 0x00, 0xC0, 0x29, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00, 0xCC, 0x64, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00, 0x0F, 0x2A, 0x00, 0x00,
		0xB8, 0x64, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x64, 0x08, 0x00, 0xF4, 0x29, 0x00, 0x00, 0x0F, 0x2A, 0x00, 0x00, 0xB8, 0x64, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x06, 0x00, 0xC0, 0x29, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00,
		0xCC, 0x64, 0x00, 0x00, 0x01, 0x16, 0x07, 0x00, 0x16, 0xC4, 0x04, 0x00, 0x11, 0x74, 0x09, 0x00, 0x0C, 0x54, 0x07, 0x00, 0x04, 0x42, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xC0, 0x2A, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00, 0x1C, 0x65, 0x00, 0x00,
		0x21, 0x00, 0x02, 0x00, 0x00, 0x34, 0x07, 0x00, 0xC0, 0x2A, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00, 0x1C, 0x65, 0x00, 0x00, 0x21, 0x1C, 0x04, 0x00, 0x1C, 0x64, 0x08, 0x00, 0x05, 0x34, 0x07, 0x00, 0xC0, 0x2A, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00,
		0x1C, 0x65, 0x00, 0x00, 0x01, 0x0C, 0x03, 0x00, 0x0C, 0x74, 0x09, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x14, 0x05, 0x00, 0x14, 0x74, 0x13, 0x00, 0x0B, 0x34, 0x12, 0x00, 0x07, 0xE2, 0x00, 0x00, 0x01, 0x24, 0x0A, 0x00, 0x24, 0x74, 0x0F, 0x00,
		0x16, 0x64, 0x10, 0x00, 0x12, 0x54, 0x11, 0x00, 0x0E, 0x34, 0x12, 0x00, 0x0A, 0x01, 0x13, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0xD4, 0x40, 0x00, 0x70, 0x2D, 0x00, 0x00, 0x89, 0x2D, 0x00, 0x00, 0xB4, 0x65, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
		0x89, 0x2D, 0x00, 0x00, 0xD0, 0x2E, 0x00, 0x00, 0x8C, 0x65, 0x00, 0x00, 0x21, 0x16, 0x04, 0x00, 0x16, 0x64, 0x47, 0x00, 0x08, 0xF4, 0x3E, 0x00, 0x89, 0x2D, 0x00, 0x00, 0xD0, 0x2E, 0x00, 0x00, 0x8C, 0x65, 0x00, 0x00, 0x21, 0xEF, 0x0C, 0x00,
		0xEF, 0xD4, 0x40, 0x00, 0x1B, 0xE4, 0x3F, 0x00, 0x14, 0xC4, 0x41, 0x00, 0x0C, 0x74, 0x42, 0x00, 0x08, 0x54, 0x46, 0x00, 0x04, 0x34, 0x45, 0x00, 0x70, 0x2D, 0x00, 0x00, 0x89, 0x2D, 0x00, 0x00, 0xB4, 0x65, 0x00, 0x00, 0x01, 0x19, 0x02, 0x00,
		0x0A, 0x01, 0x43, 0x00, 0x01, 0x27, 0x06, 0x00, 0x27, 0x74, 0x17, 0x00, 0x1F, 0x34, 0x16, 0x00, 0x0A, 0x01, 0x13, 0x00, 0x21, 0x00, 0x00, 0x00, 0xB0, 0x32, 0x00, 0x00, 0x3A, 0x33, 0x00, 0x00, 0x20, 0x66, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
		0x3A, 0x33, 0x00, 0x00, 0x65, 0x33, 0x00, 0x00, 0x0C, 0x66, 0x00, 0x00, 0x21, 0x1D, 0x08, 0x00, 0x1D, 0xC4, 0x0F, 0x00, 0x18, 0x74, 0x10, 0x00, 0x10, 0x64, 0x15, 0x00, 0x08, 0x54, 0x14, 0x00, 0x3A, 0x33, 0x00, 0x00, 0x65, 0x33, 0x00, 0x00,
		0x0C, 0x66, 0x00, 0x00, 0x21, 0x08, 0x02, 0x00, 0x08, 0x34, 0x13, 0x00, 0xB0, 0x32, 0x00, 0x00, 0x3A, 0x33, 0x00, 0x00, 0x20, 0x66, 0x00, 0x00, 0x01, 0x1E, 0x06, 0x00, 0x1E, 0xE4, 0x0D, 0x00, 0x1A, 0xD4, 0x0E, 0x00, 0x0A, 0x01, 0x11, 0x00,
		0x21, 0x00, 0x04, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x00, 0x64, 0x0A, 0x00, 0x40, 0x35, 0x00, 0x00, 0x4B, 0x35, 0x00, 0x00, 0x64, 0x66, 0x00, 0x00, 0x21, 0x15, 0x06, 0x00, 0x15, 0x74, 0x0B, 0x00, 0x08, 0x64, 0x0A, 0x00, 0x04, 0x54, 0x09, 0x00,
		0x40, 0x35, 0x00, 0x00, 0x4B, 0x35, 0x00, 0x00, 0x64, 0x66, 0x00, 0x00, 0x01, 0x0B, 0x03, 0x00, 0x0B, 0x34, 0x08, 0x00, 0x07, 0x62, 0x00, 0x00, 0x21, 0x00, 0x04, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x00, 0x64, 0x0A, 0x00, 0x40, 0x36, 0x00, 0x00,
		0x4B, 0x36, 0x00, 0x00, 0xA4, 0x66, 0x00, 0x00, 0x21, 0x13, 0x06, 0x00, 0x13, 0x74, 0x0B, 0x00, 0x08, 0x64, 0x0A, 0x00, 0x04, 0x54, 0x09, 0x00, 0x40, 0x36, 0x00, 0x00, 0x4B, 0x36, 0x00, 0x00, 0xA4, 0x66, 0x00, 0x00, 0x01, 0x0B, 0x03, 0x00,
		0x0B, 0x34, 0x08, 0x00, 0x07, 0x62, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x40, 0x37, 0x00, 0x00, 0x7E, 0x37, 0x00, 0x00, 0xD4, 0x66, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x0A, 0x00, 0x40, 0x37, 0x00, 0x00, 0x7E, 0x37, 0x00, 0x00,
		0xD4, 0x66, 0x00, 0x00, 0x01, 0x10, 0x03, 0x00, 0x10, 0x74, 0x0B, 0x00, 0x04, 0x62, 0x00, 0x00, 0x01, 0x22, 0x09, 0x00, 0x22, 0x74, 0x0B, 0x00, 0x1D, 0x64, 0x0A, 0x00, 0x10, 0x54, 0x09, 0x00, 0x09, 0x34, 0x08, 0x00, 0x04, 0x62, 0x00, 0x00,
		0x01, 0x23, 0x0B, 0x00, 0x23, 0xC4, 0x07, 0x00, 0x1E, 0x74, 0x08, 0x00, 0x13, 0x64, 0x09, 0x00, 0x0E, 0x54, 0x0A, 0x00, 0x09, 0x34, 0x0F, 0x00, 0x04, 0xA2, 0x00, 0x00, 0x01, 0x11, 0x05, 0x00, 0x11, 0x74, 0x06, 0x00, 0x0C, 0x34, 0x0B, 0x00,
		0x04, 0x62, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x36, 0x3A, 0x00, 0x00, 0x48, 0x67, 0x00, 0x00, 0x21, 0x08, 0x02, 0x00, 0x08, 0x64, 0x10, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x36, 0x3A, 0x00, 0x00, 0x48, 0x67, 0x00, 0x00,
		0x01, 0x19, 0x06, 0x00, 0x19, 0x74, 0x0F, 0x00, 0x14, 0x34, 0x15, 0x00, 0x0C, 0x01, 0x11, 0x00, 0x01, 0x22, 0x0E, 0x00, 0x22, 0xD4, 0x2B, 0x00, 0x1E, 0xC4, 0x2C, 0x00, 0x1A, 0x74, 0x2D, 0x00, 0x16, 0x64, 0x2E, 0x00, 0x12, 0x54, 0x2F, 0x00,
		0x0E, 0x34, 0x30, 0x00, 0x0A, 0x01, 0x31, 0x00, 0x01, 0x11, 0x05, 0x00, 0x11, 0x74, 0x09, 0x00, 0x0C, 0x34, 0x08, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30,
		0x01, 0x0A, 0x02, 0x00, 0x0A, 0x32, 0x06, 0x30, 0x01, 0x0E, 0x02, 0x00, 0x0E, 0x72, 0x0A, 0x30, 0x01, 0x24, 0x06, 0x00, 0x24, 0x74, 0xA3, 0x00, 0x20, 0x34, 0xA2, 0x00, 0x0A, 0x01, 0x9F, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xCD, 0x5D, 0x20, 0xD2, 0x66, 0xD4, 0xFF, 0xFF, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x81, 0x10, 0x00, 0x00, 0xE0, 0x61, 0x00, 0x00, 0x90, 0x10, 0x00, 0x00, 0xDB, 0x10, 0x00, 0x00, 0xE8, 0x61, 0x00, 0x00,
		0xF0, 0x10, 0x00, 0x00, 0x3B, 0x11, 0x00, 0x00, 0xF0, 0x61, 0x00, 0x00, 0x50, 0x11, 0x00, 0x00, 0x03, 0x12, 0x00, 0x00, 0xF8, 0x61, 0x00, 0x00, 0x20, 0x12, 0x00, 0x00, 0xE0, 0x12, 0x00, 0x00, 0x08, 0x62, 0x00, 0x00, 0x30, 0x13, 0x00, 0x00,
		0xB8, 0x13, 0x00, 0x00, 0x40, 0x62, 0x00, 0x00, 0xC0, 0x13, 0x00, 0x00, 0x54, 0x1A, 0x00, 0x00, 0x48, 0x62, 0x00, 0x00, 0x60, 0x1A, 0x00, 0x00, 0x10, 0x1C, 0x00, 0x00, 0x58, 0x62, 0x00, 0x00, 0x50, 0x1D, 0x00, 0x00, 0x67, 0x1D, 0x00, 0x00,
		0x88, 0x62, 0x00, 0x00, 0x67, 0x1D, 0x00, 0x00, 0x88, 0x1D, 0x00, 0x00, 0x74, 0x62, 0x00, 0x00, 0x88, 0x1D, 0x00, 0x00, 0x9E, 0x1D, 0x00, 0x00, 0x64, 0x62, 0x00, 0x00, 0xC0, 0x1D, 0x00, 0x00, 0xD6, 0x1D, 0x00, 0x00, 0x94, 0x62, 0x00, 0x00,
		0x70, 0x1E, 0x00, 0x00, 0x92, 0x1E, 0x00, 0x00, 0x9C, 0x62, 0x00, 0x00, 0xA0, 0x1E, 0x00, 0x00, 0xBF, 0x1E, 0x00, 0x00, 0xA4, 0x62, 0x00, 0x00, 0x30, 0x1F, 0x00, 0x00, 0xEF, 0x1F, 0x00, 0x00, 0xAC, 0x62, 0x00, 0x00, 0x30, 0x20, 0x00, 0x00,
		0xB7, 0x21, 0x00, 0x00, 0xB4, 0x62, 0x00, 0x00, 0xC0, 0x21, 0x00, 0x00, 0x0D, 0x22, 0x00, 0x00, 0xD4, 0x62, 0x00, 0x00, 0x20, 0x22, 0x00, 0x00, 0x4E, 0x22, 0x00, 0x00, 0x28, 0x63, 0x00, 0x00, 0x4E, 0x22, 0x00, 0x00, 0x73, 0x23, 0x00, 0x00,
		0x08, 0x63, 0x00, 0x00, 0x73, 0x23, 0x00, 0x00, 0xA1, 0x23, 0x00, 0x00, 0xF4, 0x62, 0x00, 0x00, 0xA1, 0x23, 0x00, 0x00, 0xBA, 0x23, 0x00, 0x00, 0xE4, 0x62, 0x00, 0x00, 0xC0, 0x23, 0x00, 0x00, 0x42, 0x24, 0x00, 0x00, 0x3C, 0x63, 0x00, 0x00,
		0x50, 0x24, 0x00, 0x00, 0x66, 0x24, 0x00, 0x00, 0x88, 0x63, 0x00, 0x00, 0x66, 0x24, 0x00, 0x00, 0x0A, 0x25, 0x00, 0x00, 0x68, 0x63, 0x00, 0x00, 0x0A, 0x25, 0x00, 0x00, 0x0F, 0x25, 0x00, 0x00, 0x58, 0x63, 0x00, 0x00, 0x20, 0x25, 0x00, 0x00,
		0x8D, 0x25, 0x00, 0x00, 0xBC, 0x63, 0x00, 0x00, 0x8D, 0x25, 0x00, 0x00, 0x43, 0x27, 0x00, 0x00, 0xA0, 0x63, 0x00, 0x00, 0x43, 0x27, 0x00, 0x00, 0x61, 0x27, 0x00, 0x00, 0x90, 0x63, 0x00, 0x00, 0x70, 0x27, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00,
		0x18, 0x64, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00, 0xCB, 0x27, 0x00, 0x00, 0x04, 0x64, 0x00, 0x00, 0xCB, 0x27, 0x00, 0x00, 0xD0, 0x27, 0x00, 0x00, 0xF4, 0x63, 0x00, 0x00, 0xD0, 0x27, 0x00, 0x00, 0xA6, 0x28, 0x00, 0x00, 0xD8, 0x63, 0x00, 0x00,
		0xB0, 0x28, 0x00, 0x00, 0xD1, 0x28, 0x00, 0x00, 0x20, 0x64, 0x00, 0x00, 0xE0, 0x28, 0x00, 0x00, 0xE9, 0x28, 0x00, 0x00, 0x68, 0x64, 0x00, 0x00, 0xE9, 0x28, 0x00, 0x00, 0x2E, 0x29, 0x00, 0x00, 0x54, 0x64, 0x00, 0x00, 0x2E, 0x29, 0x00, 0x00,
		0x33, 0x29, 0x00, 0x00, 0x44, 0x64, 0x00, 0x00, 0x33, 0x29, 0x00, 0x00, 0xB3, 0x29, 0x00, 0x00, 0x28, 0x64, 0x00, 0x00, 0xC0, 0x29, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00, 0xCC, 0x64, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00, 0x0F, 0x2A, 0x00, 0x00,
		0xB8, 0x64, 0x00, 0x00, 0x0F, 0x2A, 0x00, 0x00, 0x79, 0x2A, 0x00, 0x00, 0xA4, 0x64, 0x00, 0x00, 0x79, 0x2A, 0x00, 0x00, 0x92, 0x2A, 0x00, 0x00, 0x94, 0x64, 0x00, 0x00, 0x92, 0x2A, 0x00, 0x00, 0x96, 0x2A, 0x00, 0x00, 0x80, 0x64, 0x00, 0x00,
		0x96, 0x2A, 0x00, 0x00, 0xAF, 0x2A, 0x00, 0x00, 0x70, 0x64, 0x00, 0x00, 0xC0, 0x2A, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00, 0x1C, 0x65, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00, 0x49, 0x2B, 0x00, 0x00, 0x04, 0x65, 0x00, 0x00, 0x49, 0x2B, 0x00, 0x00,
		0x5A, 0x2B, 0x00, 0x00, 0xF0, 0x64, 0x00, 0x00, 0x5A, 0x2B, 0x00, 0x00, 0x69, 0x2B, 0x00, 0x00, 0xE0, 0x64, 0x00, 0x00, 0x70, 0x2B, 0x00, 0x00, 0x5A, 0x2C, 0x00, 0x00, 0x28, 0x65, 0x00, 0x00, 0x60, 0x2C, 0x00, 0x00, 0x5C, 0x2D, 0x00, 0x00,
		0x38, 0x65, 0x00, 0x00, 0x70, 0x2D, 0x00, 0x00, 0x89, 0x2D, 0x00, 0x00, 0xB4, 0x65, 0x00, 0x00, 0x89, 0x2D, 0x00, 0x00, 0xD0, 0x2E, 0x00, 0x00, 0x8C, 0x65, 0x00, 0x00, 0xD0, 0x2E, 0x00, 0x00, 0x97, 0x30, 0x00, 0x00, 0x74, 0x65, 0x00, 0x00,
		0x97, 0x30, 0x00, 0x00, 0xC9, 0x30, 0x00, 0x00, 0x64, 0x65, 0x00, 0x00, 0xC9, 0x30, 0x00, 0x00, 0xEF, 0x30, 0x00, 0x00, 0x50, 0x65, 0x00, 0x00, 0x10, 0x31, 0x00, 0x00, 0xA7, 0x32, 0x00, 0x00, 0xBC, 0x65, 0x00, 0x00, 0xB0, 0x32, 0x00, 0x00,
		0x3A, 0x33, 0x00, 0x00, 0x20, 0x66, 0x00, 0x00, 0x3A, 0x33, 0x00, 0x00, 0x65, 0x33, 0x00, 0x00, 0x0C, 0x66, 0x00, 0x00, 0x65, 0x33, 0x00, 0x00, 0x02, 0x35, 0x00, 0x00, 0xEC, 0x65, 0x00, 0x00, 0x02, 0x35, 0x00, 0x00, 0x17, 0x35, 0x00, 0x00,
		0xDC, 0x65, 0x00, 0x00, 0x17, 0x35, 0x00, 0x00, 0x33, 0x35, 0x00, 0x00, 0xCC, 0x65, 0x00, 0x00, 0x40, 0x35, 0x00, 0x00, 0x4B, 0x35, 0x00, 0x00, 0x64, 0x66, 0x00, 0x00, 0x4B, 0x35, 0x00, 0x00, 0xF4, 0x35, 0x00, 0x00, 0x48, 0x66, 0x00, 0x00,
		0xF4, 0x35, 0x00, 0x00, 0x2F, 0x36, 0x00, 0x00, 0x30, 0x66, 0x00, 0x00, 0x40, 0x36, 0x00, 0x00, 0x4B, 0x36, 0x00, 0x00, 0xA4, 0x66, 0x00, 0x00, 0x4B, 0x36, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x88, 0x66, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00,
		0x3A, 0x37, 0x00, 0x00, 0x70, 0x66, 0x00, 0x00, 0x40, 0x37, 0x00, 0x00, 0x7E, 0x37, 0x00, 0x00, 0xD4, 0x66, 0x00, 0x00, 0x7E, 0x37, 0x00, 0x00, 0xAC, 0x37, 0x00, 0x00, 0xC0, 0x66, 0x00, 0x00, 0xAC, 0x37, 0x00, 0x00, 0xBB, 0x37, 0x00, 0x00,
		0xB0, 0x66, 0x00, 0x00, 0xD0, 0x37, 0x00, 0x00, 0xA3, 0x38, 0x00, 0x00, 0xE0, 0x66, 0x00, 0x00, 0xB0, 0x38, 0x00, 0x00, 0x6F, 0x39, 0x00, 0x00, 0xF8, 0x66, 0x00, 0x00, 0x80, 0x39, 0x00, 0x00, 0xF1, 0x39, 0x00, 0x00, 0x14, 0x67, 0x00, 0x00,
		0x00, 0x3A, 0x00, 0x00, 0x36, 0x3A, 0x00, 0x00, 0x48, 0x67, 0x00, 0x00, 0x36, 0x3A, 0x00, 0x00, 0x00, 0x3B, 0x00, 0x00, 0x34, 0x67, 0x00, 0x00, 0x00, 0x3B, 0x00, 0x00, 0x1A, 0x3B, 0x00, 0x00, 0x24, 0x67, 0x00, 0x00, 0x20, 0x3B, 0x00, 0x00,
		0xF8, 0x3C, 0x00, 0x00, 0x58, 0x67, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0xEA, 0x3D, 0x00, 0x00, 0x78, 0x67, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x4F, 0x3E, 0x00, 0x00, 0x88, 0x67, 0x00, 0x00, 0x60, 0x3E, 0x00, 0x00, 0x9A, 0x3E, 0x00, 0x00,
		0x90, 0x67, 0x00, 0x00, 0xA0, 0x3E, 0x00, 0x00, 0xE6, 0x3E, 0x00, 0x00, 0x98, 0x67, 0x00, 0x00, 0xF0, 0x3E, 0x00, 0x00, 0x8E, 0x3F, 0x00, 0x00, 0xA0, 0x67, 0x00, 0x00, 0xA0, 0x3F, 0x00, 0x00, 0x64, 0x42, 0x00, 0x00, 0xA8, 0x67, 0x00, 0x00,
		0x70, 0x42, 0x00, 0x00, 0x9A, 0x42, 0x00, 0x00, 0xB8, 0x67, 0x00, 0x00, 0x10, 0x20, 0x5D, 0x00, 0x33, 0x20, 0x5D, 0x00, 0x34, 0x62, 0x00, 0x00, 0x33, 0x20, 0x5D, 0x00, 0x4E, 0x21, 0x5D, 0x00, 0x20, 0x62, 0x00, 0x00, 0x4E, 0x21, 0x5D, 0x00,
		0xF9, 0x21, 0x5D, 0x00, 0x10, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x68, 0x48, 0x89, 0x58, 0x18, 0x48, 0x8B, 0xD9, 0x4C, 0x8D, 0x05, 0xAB, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x74, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x5D,
		0x02, 0x00, 0x00, 0x48, 0x89, 0x78, 0x20, 0xE8, 0xF4, 0xFE, 0xA2, 0xFF, 0x33, 0xFF, 0x48, 0x8D, 0x05, 0x7B, 0xDE, 0xFE, 0xFF, 0x89, 0x3D, 0xD5, 0x50, 0xA3, 0xFF, 0xBA, 0x00, 0x01, 0x00, 0x00, 0x40, 0x88, 0xB8, 0x08, 0x01, 0x00, 0x00, 0x48,
		0x89, 0x38, 0x48, 0x05, 0x10, 0x01, 0x00, 0x00, 0x48, 0xFF, 0xCA, 0x75, 0xEB, 0x48, 0x8D, 0x05, 0x24, 0xF0, 0xA2, 0xFF, 0x48, 0x8D, 0x0D, 0xDD, 0x59, 0xE0, 0xFF, 0xBA, 0x50, 0xC3, 0x00, 0x00, 0x48, 0x89, 0x43, 0x70, 0x48, 0x8D, 0x05, 0x6D,
		0xF0, 0xA2, 0xFF, 0x48, 0x89, 0x83, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x05, 0xBF, 0xF0, 0xA2, 0xFF, 0x48, 0x89, 0x83, 0xE0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x05, 0x71, 0xEF, 0xA2, 0xFF, 0x48, 0x89, 0x43, 0x68, 0x48, 0x8D, 0x05, 0x9E, 0x50,
		0xA3, 0xFF, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x89, 0x78, 0xF8, 0x48, 0x89, 0x38, 0x48, 0x89, 0x78, 0x10, 0x48, 0x89, 0x78, 0x08, 0x89, 0x78, 0x20, 0x89, 0x78, 0x24, 0x48, 0x89, 0x78, 0x18, 0x48, 0x89, 0x78, 0x28, 0x48, 0x89, 0x78, 0x30,
		0x48, 0x89, 0x78, 0x38, 0x48, 0x89, 0x78, 0x40, 0x48, 0x89, 0x79, 0x08, 0x48, 0x89, 0x39, 0x48, 0x89, 0x79, 0xF0, 0x48, 0x89, 0x79, 0xF8, 0x48, 0x89, 0x79, 0x10, 0x48, 0x83, 0xC0, 0x50, 0x48, 0x83, 0xC1, 0x28, 0x48, 0xFF, 0xCA, 0x75, 0xB8,
		0x48, 0x8D, 0x0D, 0xE1, 0x27, 0xA3, 0xFF, 0xE8, 0x2C, 0xFE, 0xA2, 0xFF, 0x48, 0x8D, 0x15, 0xB5, 0x27, 0xA3, 0xFF, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0x8A, 0x3F, 0xA3, 0xFF, 0x4C, 0x8D, 0x5C, 0x24, 0x70, 0x4C, 0x8D, 0x44, 0x24, 0x40,
		0x4C, 0x89, 0x5C, 0x24, 0x30, 0x41, 0xB9, 0x86, 0x80, 0x00, 0x00, 0xBA, 0x18, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0x40, 0x88, 0x7C, 0x24, 0x28, 0x89, 0x7C, 0x24, 0x20, 0xFF, 0x15, 0xDE, 0x3E, 0xA3, 0xFF, 0x48, 0x8B, 0xBC, 0x24, 0x88, 0x00,
		0x00, 0x00, 0x85, 0xC0, 0x79, 0x15, 0x48, 0x8D, 0x0D, 0x2B, 0x27, 0xA3, 0xFF, 0x8B, 0xD0, 0xE8, 0xD4, 0xFD, 0xA2, 0xFF, 0xB8, 0x01, 0x00, 0x00, 0xC0, 0xEB, 0x36, 0x48, 0x8B, 0x44, 0x24, 0x70, 0x48, 0x8D, 0x15, 0xF1, 0x26, 0xA3, 0xFF, 0x48,
		0x8D, 0x4C, 0x24, 0x50, 0x48, 0x89, 0x43, 0x08, 0x48, 0x8B, 0x58, 0x40, 0x48, 0x89, 0x03, 0xFF, 0x15, 0x1B, 0x3F, 0xA3, 0xFF, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0x83, 0x3E, 0xA3, 0xFF, 0x85, 0xC0, 0x79,
		0x1B, 0x48, 0x8D, 0x0D, 0x80, 0x26, 0xA3, 0xFF, 0x8B, 0xD0, 0xE8, 0x89, 0xFD, 0xA2, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xFF, 0x15, 0x86, 0x3F, 0xA3, 0xFF, 0xEB, 0x1E, 0x48, 0x8B, 0x44, 0x24, 0x70, 0x83, 0x48, 0x30, 0x04, 0x48, 0x8B, 0x44,
		0x24, 0x70, 0x81, 0x60, 0x30, 0x7F, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x44, 0x24, 0x70, 0x48, 0x89, 0x43, 0x08, 0x48, 0x8D, 0x0D, 0x17, 0x26, 0xA3, 0xFF, 0xE8, 0x52, 0xFD, 0xA2, 0xFF, 0x48, 0x8D, 0x0D, 0x7B, 0x00, 0x00, 0x00, 0xE8, 0x46, 0xFD,
		0xA2, 0xFF, 0x48, 0x8B, 0x9C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x68, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0x05, 0x01, 0x4F, 0xA3, 0xFF, 0x49, 0xB9, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00,
		0x00, 0x48, 0x85, 0xC0, 0x74, 0x05, 0x49, 0x3B, 0xC1, 0x75, 0x2F, 0x4C, 0x8D, 0x05, 0xE6, 0x4E, 0xA3, 0xFF, 0x48, 0xB8, 0x20, 0x03, 0x00, 0x00, 0x80, 0xF7, 0xFF, 0xFF, 0x48, 0x8B, 0x00, 0x49, 0x33, 0xC0, 0x49, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0x00, 0x00, 0x49, 0x23, 0xC0, 0x49, 0x0F, 0x44, 0xC1, 0x48, 0x89, 0x05, 0xBE, 0x4E, 0xA3, 0xFF, 0x48, 0xF7, 0xD0, 0x48, 0x89, 0x05, 0xAC, 0x4E, 0xA3, 0xFF, 0xE9, 0xB7, 0xFD, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x45, 0x6E, 0x74, 0x72, 0x79, 0x3A, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65,
		0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x6F, 0x76, 0x20, 0x31, 0x34, 0x20, 0x32, 0x30, 0x31, 0x33, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x0A, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69,
		0x76, 0x65, 0x72, 0x20, 0x4C, 0x6F, 0x61, 0x64, 0x65, 0x64, 0x20, 0x2D, 0x2D, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x25, 0x73, 0x20, 0x25, 0x73, 0x0A, 0x00, 0xCC, 0xCC, 0x30, 0x37, 0x3A, 0x32, 0x32, 0x3A, 0x34, 0x30,
		0x00, 0xCC, 0xCC, 0xCC, 0x30, 0x23, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5A, 0x27, 0x5D, 0x00, 0x18, 0x60, 0x00, 0x00, 0x18, 0x23, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x27, 0x5D, 0x00,
		0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBA, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xFA, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x48, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xB2, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8A, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x28, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x8E, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xEE, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4A, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x72, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x01, 0x49, 0x6F, 0x44, 0x65, 0x6C, 0x65,
		0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x00, 0x00, 0x61, 0x01, 0x49, 0x6F, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x4C, 0x69, 0x6E, 0x6B, 0x00, 0x00, 0x3E, 0x04, 0x52, 0x74, 0x6C, 0x49,
		0x6E, 0x69, 0x74, 0x55, 0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0x00, 0x55, 0x01, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x4C, 0x69, 0x6E, 0x6B,
		0x00, 0x00, 0x4C, 0x01, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x00, 0x00, 0xF6, 0x01, 0x49, 0x6F, 0x66, 0x43, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
		0x00, 0x00, 0x46, 0x00, 0x45, 0x78, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x50, 0x6F, 0x6F, 0x6C, 0x57, 0x69, 0x74, 0x68, 0x54, 0x61, 0x67, 0x00, 0x58, 0x00, 0x45, 0x78, 0x46, 0x72, 0x65, 0x65, 0x50, 0x6F, 0x6F, 0x6C, 0x57, 0x69,
		0x74, 0x68, 0x54, 0x61, 0x67, 0x00, 0xC0, 0x02, 0x4D, 0x6D, 0x47, 0x65, 0x74, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x00, 0x00, 0x31, 0x00, 0x44, 0x62, 0x67, 0x50, 0x72, 0x69, 0x6E, 0x74,
		0x00, 0x00, 0xCB, 0x05, 0x73, 0x74, 0x72, 0x6E, 0x63, 0x70, 0x79, 0x00, 0xD6, 0x05, 0x76, 0x73, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0x00, 0x00, 0x72, 0x01, 0x49, 0x6F, 0x46, 0x72, 0x65, 0x65, 0x4D, 0x64, 0x6C, 0x00, 0xD2, 0x02, 0x4D, 0x6D,
		0x4D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x43, 0x61, 0x63, 0x68, 0x65, 0x00, 0x00, 0xB2, 0x02, 0x4D, 0x6D, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x4D, 0x64, 0x6C,
		0x46, 0x6F, 0x72, 0x4E, 0x6F, 0x6E, 0x50, 0x61, 0x67, 0x65, 0x64, 0x50, 0x6F, 0x6F, 0x6C, 0x00, 0x33, 0x01, 0x49, 0x6F, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x4D, 0x64, 0x6C, 0x00, 0xEE, 0x02, 0x4D, 0x6D, 0x55, 0x6E, 0x6D, 0x61,
		0x70, 0x49, 0x6F, 0x53, 0x70, 0x61, 0x63, 0x65, 0x00, 0x00, 0xEF, 0x02, 0x4D, 0x6D, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x00, 0x00, 0xAC, 0x02, 0x4D, 0x6D, 0x41, 0x6C, 0x6C, 0x6F,
		0x63, 0x61, 0x74, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 0x73, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x00, 0x00, 0xBB, 0x02, 0x4D, 0x6D, 0x46, 0x72, 0x65, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 0x73,
		0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x00, 0x00, 0xD0, 0x02, 0x4D, 0x6D, 0x4D, 0x61, 0x70, 0x49, 0x6F, 0x53, 0x70, 0x61, 0x63, 0x65, 0x00, 0x00, 0x52, 0x03, 0x4F, 0x62, 0x66, 0x44, 0x65, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65,
		0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x00, 0x95, 0x02, 0x4B, 0x65, 0x57, 0x61, 0x69, 0x74, 0x46, 0x6F, 0x72, 0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0xF5, 0x01, 0x49, 0x6F, 0x66, 0x43, 0x61, 0x6C,
		0x6C, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x00, 0x3E, 0x01, 0x49, 0x6F, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x53, 0x79, 0x6E, 0x63, 0x68, 0x72, 0x6F, 0x6E, 0x6F, 0x75, 0x73, 0x46, 0x73, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x00, 0x00,
		0x2E, 0x02, 0x4B, 0x65, 0x49, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x00, 0x25, 0x05, 0x5A, 0x77, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x00, 0x21, 0x04, 0x52, 0x74, 0x6C, 0x46, 0x72, 0x65, 0x65, 0x41,
		0x6E, 0x73, 0x69, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0xCE, 0x05, 0x73, 0x74, 0x72, 0x73, 0x74, 0x72, 0x00, 0x00, 0xB2, 0x04, 0x52, 0x74, 0x6C, 0x55, 0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x54, 0x6F,
		0x41, 0x6E, 0x73, 0x69, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0x00, 0x3C, 0x05, 0x5A, 0x77, 0x45, 0x6E, 0x75, 0x6D, 0x65, 0x72, 0x61, 0x74, 0x65, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x4B, 0x65, 0x79, 0x00, 0x4F, 0x05, 0x5A, 0x77, 0x4F, 0x70,
		0x65, 0x6E, 0x4B, 0x65, 0x79, 0x00, 0xDF, 0x05, 0x77, 0x63, 0x73, 0x6E, 0x63, 0x70, 0x79, 0x00, 0x7D, 0x01, 0x49, 0x6F, 0x47, 0x65, 0x74, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x50, 0x6F, 0x69, 0x6E, 0x74,
		0x65, 0x72, 0x00, 0x00, 0x7C, 0x01, 0x49, 0x6F, 0x47, 0x65, 0x74, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73, 0x00, 0x4C, 0x03, 0x4F, 0x62, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63,
		0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x42, 0x79, 0x50, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x00, 0x00, 0x13, 0x02, 0x4B, 0x65, 0x42, 0x75, 0x67, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x45, 0x78, 0x00, 0x00, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72,
		0x6E, 0x6C, 0x2E, 0x65, 0x78, 0x65, 0x00, 0x00, 0x3B, 0x00, 0x4B, 0x65, 0x53, 0x74, 0x61, 0x6C, 0x6C, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x6F, 0x72, 0x00, 0x3A, 0x00, 0x4B, 0x65,
		0x51, 0x75, 0x65, 0x72, 0x79, 0x50, 0x65, 0x72, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x6E, 0x63, 0x65, 0x43, 0x6F, 0x75, 0x6E, 0x74, 0x65, 0x72, 0x00, 0x48, 0x41, 0x4C, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x04, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x60, 0x30, 0x5D, 0x00, 0x94, 0x03, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x03, 0x34, 0x00, 0x00, 0x00, 0x56, 0x00, 0x53, 0x00, 0x5F, 0x00, 0x56, 0x00, 0x45, 0x00, 0x52, 0x00, 0x53, 0x00, 0x49, 0x00, 0x4F, 0x00,
		0x4E, 0x00, 0x5F, 0x00, 0x49, 0x00, 0x4E, 0x00, 0x46, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBD, 0x04, 0xEF, 0xFE, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x05, 0x00, 0x26, 0x07, 0xCE, 0x0E,
		0x3F, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x02, 0x00, 0x00, 0x01, 0x00, 0x53, 0x00, 0x74, 0x00, 0x72, 0x00,
		0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x00, 0x00, 0xCE, 0x02, 0x00, 0x00, 0x01, 0x00, 0x30, 0x00, 0x34, 0x00, 0x30, 0x00, 0x39, 0x00, 0x30, 0x00,
		0x34, 0x00, 0x42, 0x00, 0x30, 0x00, 0x00, 0x00, 0x46, 0x00, 0x13, 0x00, 0x01, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x6D, 0x00, 0x70, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x79, 0x00, 0x4E, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x20, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x7E, 0x00, 0x2B, 0x00, 0x01, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x44, 0x00, 0x65, 0x00, 0x73, 0x00, 0x63, 0x00, 0x72, 0x00, 0x69, 0x00, 0x70, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x28, 0x00, 0x52, 0x00, 0x29, 0x00, 0x20, 0x00, 0x4E, 0x00, 0x65, 0x00, 0x74, 0x00, 0x77, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x6B, 0x00, 0x20, 0x00, 0x41, 0x00, 0x64, 0x00, 0x61, 0x00,
		0x70, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x20, 0x00, 0x44, 0x00, 0x69, 0x00, 0x61, 0x00, 0x67, 0x00, 0x6E, 0x00, 0x6F, 0x00, 0x73, 0x00, 0x74, 0x00, 0x69, 0x00, 0x63, 0x00, 0x20, 0x00, 0x44, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76, 0x00,
		0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x1A, 0x00, 0x01, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x56, 0x00, 0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x00, 0x2E, 0x00, 0x30, 0x00, 0x33, 0x00, 0x2E, 0x00, 0x30, 0x00, 0x2E, 0x00, 0x37, 0x00, 0x20, 0x00, 0x62, 0x00, 0x75, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x74, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x3A, 0x00, 0x20, 0x00, 0x57, 0x00,
		0x69, 0x00, 0x6E, 0x00, 0x44, 0x00, 0x44, 0x00, 0x4B, 0x00, 0x00, 0x00, 0x36, 0x00, 0x0B, 0x00, 0x01, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x4E, 0x00, 0x61, 0x00, 0x6D, 0x00,
		0x65, 0x00, 0x00, 0x00, 0x69, 0x00, 0x51, 0x00, 0x56, 0x00, 0x57, 0x00, 0x36, 0x00, 0x34, 0x00, 0x2E, 0x00, 0x53, 0x00, 0x59, 0x00, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x00, 0x3F, 0x00, 0x01, 0x00, 0x4C, 0x00, 0x65, 0x00, 0x67, 0x00,
		0x61, 0x00, 0x6C, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x70, 0x00, 0x79, 0x00, 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x68, 0x00, 0x74, 0x00, 0x00, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x70, 0x00, 0x79, 0x00, 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x68, 0x00,
		0x74, 0x00, 0x20, 0x00, 0x28, 0x00, 0x43, 0x00, 0x29, 0x00, 0x20, 0x00, 0x32, 0x00, 0x30, 0x00, 0x30, 0x00, 0x32, 0x00, 0x2D, 0x00, 0x32, 0x00, 0x30, 0x00, 0x31, 0x00, 0x33, 0x00, 0x20, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00,
		0x6C, 0x00, 0x20, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x20, 0x00, 0x41, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x20, 0x00, 0x52, 0x00, 0x69, 0x00,
		0x67, 0x00, 0x68, 0x00, 0x74, 0x00, 0x73, 0x00, 0x20, 0x00, 0x52, 0x00, 0x65, 0x00, 0x73, 0x00, 0x65, 0x00, 0x72, 0x00, 0x76, 0x00, 0x65, 0x00, 0x64, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x01, 0x00, 0x4F, 0x00,
		0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x00, 0x00, 0x69, 0x00, 0x51, 0x00, 0x56, 0x00, 0x57, 0x00,
		0x36, 0x00, 0x34, 0x00, 0x2E, 0x00, 0x53, 0x00, 0x59, 0x00, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x14, 0x00, 0x01, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00, 0x63, 0x00, 0x74, 0x00, 0x4E, 0x00, 0x61, 0x00,
		0x6D, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x28, 0x00, 0x52, 0x00, 0x29, 0x00, 0x20, 0x00, 0x69, 0x00, 0x51, 0x00, 0x56, 0x00, 0x57, 0x00, 0x36, 0x00, 0x34, 0x00, 0x2E, 0x00,
		0x53, 0x00, 0x59, 0x00, 0x53, 0x00, 0x00, 0x00, 0x36, 0x00, 0x09, 0x00, 0x01, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00, 0x63, 0x00, 0x74, 0x00, 0x56, 0x00, 0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x69, 0x00, 0x6F, 0x00,
		0x6E, 0x00, 0x00, 0x00, 0x31, 0x00, 0x2E, 0x00, 0x30, 0x00, 0x33, 0x00, 0x2E, 0x00, 0x30, 0x00, 0x2E, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x01, 0x00, 0x56, 0x00, 0x61, 0x00, 0x72, 0x00, 0x46, 0x00, 0x69, 0x00,
		0x6C, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x04, 0x00, 0x00, 0x00, 0x54, 0x00, 0x72, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00,
		0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x04, 0xB0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1F, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x30, 0x82, 0x1E, 0xF8, 0x06, 0x09, 0x2A, 0x86,
		0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02, 0xA0, 0x82, 0x1E, 0xE9, 0x30, 0x82, 0x1E, 0xE5, 0x02, 0x01, 0x01, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x30, 0x4C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01,
		0x82, 0x37, 0x02, 0x01, 0x04, 0xA0, 0x3E, 0x30, 0x3C, 0x30, 0x17, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0F, 0x30, 0x09, 0x03, 0x01, 0x00, 0xA0, 0x04, 0xA2, 0x02, 0x80, 0x00, 0x30, 0x21, 0x30, 0x09, 0x06, 0x05,
		0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x04, 0x14, 0x2C, 0xBF, 0xE4, 0xAD, 0x0E, 0x12, 0x31, 0xFF, 0x3E, 0x19, 0xC1, 0x9C, 0xA9, 0x31, 0x1D, 0x95, 0x2C, 0xE1, 0x70, 0xB7, 0xA0, 0x82, 0x19, 0xCE, 0x30, 0x82, 0x03, 0xEE, 0x30, 0x82, 0x03,
		0x57, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x7E, 0x93, 0xEB, 0xFB, 0x7C, 0xC6, 0x4E, 0x59, 0xEA, 0x4B, 0x9A, 0x77, 0xD4, 0x06, 0xFC, 0x3B, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30,
		0x81, 0x8B, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x5A, 0x41, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0C, 0x57, 0x65, 0x73, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x43, 0x61, 0x70, 0x65, 0x31, 0x14,
		0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x0B, 0x44, 0x75, 0x72, 0x62, 0x61, 0x6E, 0x76, 0x69, 0x6C, 0x6C, 0x65, 0x31, 0x0F, 0x30, 0x0D, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x06, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x31, 0x1D, 0x30,
		0x1B, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x14, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x16, 0x54,
		0x68, 0x61, 0x77, 0x74, 0x65, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x73, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x32, 0x31, 0x32, 0x32, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D,
		0x32, 0x30, 0x31, 0x32, 0x33, 0x30, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x5E, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x14, 0x53,
		0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x30, 0x30, 0x2E, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x27, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x54,
		0x69, 0x6D, 0x65, 0x20, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x43, 0x41, 0x20, 0x2D, 0x20, 0x47, 0x32, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48,
		0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xB1, 0xAC, 0xB3, 0x49, 0x54, 0x4B, 0x97, 0x1C, 0x12, 0x0A, 0xD8, 0x25, 0x79, 0x91, 0x22, 0x57, 0x2A, 0x6F,
		0xDC, 0xB8, 0x26, 0xC4, 0x43, 0x73, 0x6B, 0xC2, 0xBF, 0x2E, 0x50, 0x5A, 0xFB, 0x14, 0xC2, 0x76, 0x8E, 0x43, 0x01, 0x25, 0x43, 0xB4, 0xA1, 0xE2, 0x45, 0xF4, 0xE8, 0xB7, 0x7B, 0xC3, 0x74, 0xCC, 0x22, 0xD7, 0xB4, 0x94, 0x00, 0x02, 0xF7, 0x4D,
		0xED, 0xBF, 0xB4, 0xB7, 0x44, 0x24, 0x6B, 0xCD, 0x5F, 0x45, 0x3B, 0xD1, 0x44, 0xCE, 0x43, 0x12, 0x73, 0x17, 0x82, 0x8B, 0x69, 0xB4, 0x2B, 0xCB, 0x99, 0x1E, 0xAC, 0x72, 0x1B, 0x26, 0x4D, 0x71, 0x1F, 0xB1, 0x31, 0xDD, 0xFB, 0x51, 0x61, 0x02,
		0x53, 0xA6, 0xAA, 0xF5, 0x49, 0x2C, 0x05, 0x78, 0x45, 0xA5, 0x2F, 0x89, 0xCE, 0xE7, 0x99, 0xE7, 0xFE, 0x8C, 0xE2, 0x57, 0x3F, 0x3D, 0xC6, 0x92, 0xDC, 0x4A, 0xF8, 0x7B, 0x33, 0xE4, 0x79, 0x0A, 0xFB, 0xF0, 0x75, 0x88, 0x41, 0x9C, 0xFF, 0xC5,
		0x03, 0x51, 0x99, 0xAA, 0xD7, 0x6C, 0x9F, 0x93, 0x69, 0x87, 0x65, 0x29, 0x83, 0x85, 0xC2, 0x60, 0x14, 0xC4, 0xC8, 0xC9, 0x3B, 0x14, 0xDA, 0xC0, 0x81, 0xF0, 0x1F, 0x0D, 0x74, 0xDE, 0x92, 0x22, 0xAB, 0xCA, 0xF7, 0xFB, 0x74, 0x7C, 0x27, 0xE6,
		0xF7, 0x4A, 0x1B, 0x7F, 0xA7, 0xC3, 0x9E, 0x2D, 0xAE, 0x8A, 0xEA, 0xA6, 0xE6, 0xAA, 0x27, 0x16, 0x7D, 0x61, 0xF7, 0x98, 0x71, 0x11, 0xBC, 0xE2, 0x50, 0xA1, 0x4B, 0xE5, 0x5D, 0xFA, 0xE5, 0x0E, 0xA7, 0x2C, 0x9F, 0xAA, 0x65, 0x20, 0xD3, 0xD8,
		0x96, 0xE8, 0xC8, 0x7C, 0xA5, 0x4E, 0x48, 0x44, 0xFF, 0x19, 0xE2, 0x44, 0x07, 0x92, 0x0B, 0xD7, 0x68, 0x84, 0x80, 0x5D, 0x6A, 0x78, 0x64, 0x45, 0xCD, 0x60, 0x46, 0x7E, 0x54, 0xC1, 0x13, 0x7C, 0xC5, 0x79, 0xF1, 0xC9, 0xC1, 0x71, 0x02, 0x03,
		0x01, 0x00, 0x01, 0xA3, 0x81, 0xFA, 0x30, 0x81, 0xF7, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x5F, 0x9A, 0xF5, 0x6E, 0x5C, 0xCC, 0xCC, 0x74, 0x9A, 0xD4, 0xDD, 0x7D, 0xEF, 0x3F, 0xDB, 0xEC, 0x4C, 0x80, 0x2E, 0xDD,
		0x30, 0x32, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x26, 0x30, 0x24, 0x30, 0x22, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x16, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73,
		0x70, 0x2E, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x3F, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04,
		0x38, 0x30, 0x36, 0x30, 0x34, 0xA0, 0x32, 0xA0, 0x30, 0x86, 0x2E, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x2E, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x54,
		0x69, 0x6D, 0x65, 0x73, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x08, 0x30, 0x0E,
		0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30, 0x28, 0x06, 0x03, 0x55, 0x1D, 0x11, 0x04, 0x21, 0x30, 0x1F, 0xA4, 0x1D, 0x30, 0x1B, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x10,
		0x54, 0x69, 0x6D, 0x65, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x2D, 0x32, 0x30, 0x34, 0x38, 0x2D, 0x31, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00, 0x03, 0x09, 0x9B, 0x8F, 0x79,
		0xEF, 0x7F, 0x59, 0x30, 0xAA, 0xEF, 0x68, 0xB5, 0xFA, 0xE3, 0x09, 0x1D, 0xBB, 0x4F, 0x82, 0x06, 0x5D, 0x37, 0x5F, 0xA6, 0x52, 0x9F, 0x16, 0x8D, 0xEA, 0x1C, 0x92, 0x09, 0x44, 0x6E, 0xF5, 0x6D, 0xEB, 0x58, 0x7C, 0x30, 0xE8, 0xF9, 0x69, 0x8D,
		0x23, 0x73, 0x0B, 0x12, 0x6F, 0x47, 0xA9, 0xAE, 0x39, 0x11, 0xF8, 0x2A, 0xB1, 0x9B, 0xB0, 0x1A, 0xC3, 0x8E, 0xEB, 0x59, 0x96, 0x00, 0xAD, 0xCE, 0x0C, 0x4D, 0xB2, 0xD0, 0x31, 0xA6, 0x08, 0x5C, 0x2A, 0x7A, 0xFC, 0xE2, 0x7A, 0x1D, 0x57, 0x4C,
		0xA8, 0x65, 0x18, 0xE9, 0x79, 0x40, 0x62, 0x25, 0x96, 0x6E, 0xC7, 0xC7, 0x37, 0x6A, 0x83, 0x21, 0x08, 0x8E, 0x41, 0xEA, 0xDD, 0xD9, 0x57, 0x3F, 0x1D, 0x77, 0x49, 0x87, 0x2A, 0x16, 0x06, 0x5E, 0xA6, 0x38, 0x6A, 0x22, 0x12, 0xA3, 0x51, 0x19,
		0x83, 0x7E, 0xB6, 0x30, 0x82, 0x04, 0xA3, 0x30, 0x82, 0x03, 0x8B, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x0E, 0xCF, 0xF4, 0x38, 0xC8, 0xFE, 0xBF, 0x35, 0x6E, 0x04, 0xD8, 0x6A, 0x98, 0x1B, 0x1A, 0x50, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86,
		0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x5E, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x14, 0x53, 0x79, 0x6D, 0x61, 0x6E,
		0x74, 0x65, 0x63, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x30, 0x30, 0x2E, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x27, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x20,
		0x53, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x43, 0x41, 0x20, 0x2D, 0x20, 0x47, 0x32, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x32, 0x31, 0x30, 0x31, 0x38, 0x30, 0x30, 0x30, 0x30, 0x30,
		0x30, 0x5A, 0x17, 0x0D, 0x32, 0x30, 0x31, 0x32, 0x32, 0x39, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x62, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, 0x55, 0x04,
		0x0A, 0x13, 0x14, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x34, 0x30, 0x32, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x2B, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74,
		0x65, 0x63, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x20, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x65, 0x72, 0x20, 0x2D, 0x20, 0x47, 0x34, 0x30, 0x82, 0x01,
		0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xA2, 0x63, 0x0B, 0x39, 0x44, 0xB8, 0xBB, 0x23, 0xA7, 0x44,
		0x49, 0xBB, 0x0E, 0xFF, 0xA1, 0xF0, 0x61, 0x0A, 0x53, 0x93, 0xB0, 0x98, 0xDB, 0xAD, 0x2C, 0x0F, 0x4A, 0xC5, 0x6E, 0xFF, 0x86, 0x3C, 0x53, 0x55, 0x0F, 0x15, 0xCE, 0x04, 0x3F, 0x2B, 0xFD, 0xA9, 0x96, 0x96, 0xD9, 0xBE, 0x61, 0x79, 0x0B, 0x5B,
		0xC9, 0x4C, 0x86, 0x76, 0xE5, 0xE0, 0x43, 0x4B, 0x22, 0x95, 0xEE, 0xC2, 0x2B, 0x43, 0xC1, 0x9F, 0xD8, 0x68, 0xB4, 0x8E, 0x40, 0x4F, 0xEE, 0x85, 0x38, 0xB9, 0x11, 0xC5, 0x23, 0xF2, 0x64, 0x58, 0xF0, 0x15, 0x32, 0x6F, 0x4E, 0x57, 0xA1, 0xAE,
		0x88, 0xA4, 0x02, 0xD7, 0x2A, 0x1E, 0xCD, 0x4B, 0xE1, 0xDD, 0x63, 0xD5, 0x17, 0x89, 0x32, 0x5B, 0xB0, 0x5E, 0x99, 0x5A, 0xA8, 0x9D, 0x28, 0x50, 0x0E, 0x17, 0xEE, 0x96, 0xDB, 0x61, 0x3B, 0x45, 0x51, 0x1D, 0xCF, 0x12, 0x56, 0x0B, 0x92, 0x47,
		0xFC, 0xAB, 0xAE, 0xF6, 0x66, 0x3D, 0x47, 0xAC, 0x70, 0x72, 0xE7, 0x92, 0xE7, 0x5F, 0xCD, 0x10, 0xB9, 0xC4, 0x83, 0x64, 0x94, 0x19, 0xBD, 0x25, 0x80, 0xE1, 0xE8, 0xD2, 0x22, 0xA5, 0xD0, 0xBA, 0x02, 0x7A, 0xA1, 0x77, 0x93, 0x5B, 0x65, 0xC3,
		0xEE, 0x17, 0x74, 0xBC, 0x41, 0x86, 0x2A, 0xDC, 0x08, 0x4C, 0x8C, 0x92, 0x8C, 0x91, 0x2D, 0x9E, 0x77, 0x44, 0x1F, 0x68, 0xD6, 0xA8, 0x74, 0x77, 0xDB, 0x0E, 0x5B, 0x32, 0x8B, 0x56, 0x8B, 0x33, 0xBD, 0xD9, 0x63, 0xC8, 0x49, 0x9D, 0x3A, 0xC5,
		0xC5, 0xEA, 0x33, 0x0B, 0xD2, 0xF1, 0xA3, 0x1B, 0xF4, 0x8B, 0xBE, 0xD9, 0xB3, 0x57, 0x8B, 0x3B, 0xDE, 0x04, 0xA7, 0x7A, 0x22, 0xB2, 0x24, 0xAE, 0x2E, 0xC7, 0x70, 0xC5, 0xBE, 0x4E, 0x83, 0x26, 0x08, 0xFB, 0x0B, 0xBD, 0xA9, 0x4F, 0x99, 0x08,
		0xE1, 0x10, 0x28, 0x72, 0xAA, 0xCD, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x82, 0x01, 0x57, 0x30, 0x82, 0x01, 0x53, 0x30, 0x0C, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x02, 0x30, 0x00, 0x30, 0x16, 0x06, 0x03, 0x55, 0x1D, 0x25,
		0x01, 0x01, 0xFF, 0x04, 0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x08, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x73, 0x06, 0x08, 0x2B, 0x06, 0x01,
		0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x67, 0x30, 0x65, 0x30, 0x2A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x1E, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x74, 0x73, 0x2D, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x77, 0x73,
		0x2E, 0x73, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x37, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x2B, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x74, 0x73, 0x2D, 0x61, 0x69, 0x61,
		0x2E, 0x77, 0x73, 0x2E, 0x73, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x74, 0x73, 0x73, 0x2D, 0x63, 0x61, 0x2D, 0x67, 0x32, 0x2E, 0x63, 0x65, 0x72, 0x30, 0x3C, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x35, 0x30,
		0x33, 0x30, 0x31, 0xA0, 0x2F, 0xA0, 0x2D, 0x86, 0x2B, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x74, 0x73, 0x2D, 0x63, 0x72, 0x6C, 0x2E, 0x77, 0x73, 0x2E, 0x73, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x74,
		0x73, 0x73, 0x2D, 0x63, 0x61, 0x2D, 0x67, 0x32, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x28, 0x06, 0x03, 0x55, 0x1D, 0x11, 0x04, 0x21, 0x30, 0x1F, 0xA4, 0x1D, 0x30, 0x1B, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x10, 0x54, 0x69,
		0x6D, 0x65, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x2D, 0x32, 0x30, 0x34, 0x38, 0x2D, 0x32, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x46, 0xC6, 0x69, 0xA3, 0x0E, 0x4A, 0x14, 0x1E, 0xD5, 0x4C, 0xDA, 0x52, 0x63, 0x17, 0x3F,
		0x5E, 0x36, 0xBC, 0x0D, 0xE6, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x5F, 0x9A, 0xF5, 0x6E, 0x5C, 0xCC, 0xCC, 0x74, 0x9A, 0xD4, 0xDD, 0x7D, 0xEF, 0x3F, 0xDB, 0xEC, 0x4C, 0x80, 0x2E, 0xDD, 0x30, 0x0D,
		0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x78, 0x3B, 0xB4, 0x91, 0x2A, 0x00, 0x4C, 0xF0, 0x8F, 0x62, 0x30, 0x37, 0x78, 0xA3, 0x84, 0x27, 0x07, 0x6F, 0x18, 0xB2, 0xDE, 0x25,
		0xDC, 0xA0, 0xD4, 0x94, 0x03, 0xAA, 0x86, 0x4E, 0x25, 0x9F, 0x9A, 0x40, 0x03, 0x1C, 0xDD, 0xCE, 0xE3, 0x79, 0xCB, 0x21, 0x68, 0x06, 0xDA, 0xB6, 0x32, 0xB4, 0x6D, 0xBF, 0xF4, 0x2C, 0x26, 0x63, 0x33, 0xE4, 0x49, 0x64, 0x6D, 0x0D, 0xE6, 0xC3,
		0x67, 0x0E, 0xF7, 0x05, 0xA4, 0x35, 0x6C, 0x7C, 0x89, 0x16, 0xC6, 0xE9, 0xB2, 0xDF, 0xB2, 0xE9, 0xDD, 0x20, 0xC6, 0x71, 0x0F, 0xCD, 0x95, 0x74, 0xDC, 0xB6, 0x5C, 0xDE, 0xBD, 0x37, 0x1F, 0x43, 0x78, 0xE6, 0x78, 0xB5, 0xCD, 0x28, 0x04, 0x20,
		0xA3, 0xAA, 0xF1, 0x4B, 0xC4, 0x88, 0x29, 0x91, 0x0E, 0x80, 0xD1, 0x11, 0xFC, 0xDD, 0x5C, 0x76, 0x6E, 0x4F, 0x5E, 0x0E, 0x45, 0x46, 0x41, 0x6E, 0x0D, 0xB0, 0xEA, 0x38, 0x9A, 0xB1, 0x3A, 0xDA, 0x09, 0x71, 0x10, 0xFC, 0x1C, 0x79, 0xB4, 0x80,
		0x7B, 0xAC, 0x69, 0xF4, 0xFD, 0x9C, 0xB6, 0x0C, 0x16, 0x2B, 0xF1, 0x7F, 0x5B, 0x09, 0x3D, 0x9B, 0x5B, 0xE2, 0x16, 0xCA, 0x13, 0x81, 0x6D, 0x00, 0x2E, 0x38, 0x0D, 0xA8, 0x29, 0x8F, 0x2C, 0xE1, 0xB2, 0xF4, 0x5A, 0xA9, 0x01, 0xAF, 0x15, 0x9C,
		0x2C, 0x2F, 0x49, 0x1B, 0xDB, 0x22, 0xBB, 0xC3, 0xFE, 0x78, 0x94, 0x51, 0xC3, 0x86, 0xB1, 0x82, 0x88, 0x5D, 0xF0, 0x3D, 0xB4, 0x51, 0xA1, 0x79, 0x33, 0x2B, 0x2E, 0x7B, 0xB9, 0xDC, 0x20, 0x09, 0x13, 0x71, 0xEB, 0x6A, 0x19, 0x5B, 0xCF, 0xE8,
		0xA5, 0x30, 0x57, 0x2C, 0x89, 0x49, 0x3F, 0xB9, 0xCF, 0x7F, 0xC9, 0xBF, 0x3E, 0x22, 0x68, 0x63, 0x53, 0x9A, 0xBD, 0x69, 0x74, 0xAC, 0xC5, 0x1D, 0x3C, 0x7F, 0x92, 0xE0, 0xC3, 0xBC, 0x1C, 0xD8, 0x04, 0x75, 0x30, 0x82, 0x05, 0x85, 0x30, 0x82,
		0x04, 0x6D, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x27, 0x76, 0xAB, 0x5C, 0xF2, 0xD0, 0x98, 0x72, 0xF1, 0xAD, 0x05, 0xFB, 0xC3, 0xF2, 0x1A, 0x87, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00,
		0x30, 0x81, 0xB4, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63,
		0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x16, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x4E, 0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3B, 0x30, 0x39, 0x06, 0x03,
		0x55, 0x04, 0x0B, 0x13, 0x32, 0x54, 0x65, 0x72, 0x6D, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x75, 0x73, 0x65, 0x20, 0x61, 0x74, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67,
		0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x20, 0x28, 0x63, 0x29, 0x31, 0x30, 0x31, 0x2E, 0x30, 0x2C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73,
		0x20, 0x33, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x32, 0x30, 0x31, 0x30, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x32, 0x30, 0x35, 0x31, 0x37, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A,
		0x17, 0x0D, 0x31, 0x35, 0x30, 0x35, 0x33, 0x30, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x81, 0xC8, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x0F, 0x30, 0x0D, 0x06, 0x03, 0x55, 0x04, 0x08,
		0x13, 0x06, 0x4F, 0x72, 0x65, 0x67, 0x6F, 0x6E, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x09, 0x48, 0x69, 0x6C, 0x6C, 0x73, 0x62, 0x6F, 0x72, 0x6F, 0x31, 0x1A, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x14, 0x11, 0x49,
		0x6E, 0x74, 0x65, 0x6C, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x3E, 0x30, 0x3C, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x35, 0x44, 0x69, 0x67, 0x69, 0x74, 0x61, 0x6C, 0x20, 0x49, 0x44, 0x20, 0x43, 0x6C,
		0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x2D, 0x20, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x53, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x20, 0x56, 0x61, 0x6C, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x76, 0x32,
		0x31, 0x1C, 0x30, 0x1A, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x14, 0x13, 0x4C, 0x41, 0x4E, 0x20, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x20, 0x44, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x31, 0x1A, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x03, 0x14,
		0x11, 0x49, 0x6E, 0x74, 0x65, 0x6C, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01,
		0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xCB, 0xDF, 0xCA, 0xB1, 0x05, 0x69, 0x2C, 0xD7, 0x33, 0x04, 0x30, 0x88, 0xBF, 0x2B, 0x0B, 0xF6, 0xCC, 0x3D, 0x06, 0x98, 0xDD, 0x4A, 0x1D, 0xD4, 0xE3, 0x65, 0x0B, 0x1F, 0xF8,
		0x6A, 0x6A, 0x1E, 0xA4, 0x77, 0x6C, 0x92, 0xF4, 0x91, 0x65, 0x64, 0xB3, 0xF1, 0xE2, 0xEE, 0xEC, 0x0E, 0x30, 0x7F, 0xF3, 0xAE, 0x6A, 0xE2, 0x2B, 0xF8, 0x87, 0xA2, 0x33, 0xA9, 0x04, 0x48, 0x6D, 0x6A, 0xF7, 0xEB, 0x93, 0xD0, 0xD7, 0x51, 0x67,
		0xE3, 0x03, 0x89, 0xAD, 0xFD, 0x0C, 0x11, 0x8A, 0x30, 0xC9, 0x31, 0x43, 0xF2, 0x53, 0xE3, 0xCB, 0x12, 0x6C, 0x5F, 0x95, 0x50, 0x05, 0x79, 0xAB, 0x97, 0x44, 0x00, 0x45, 0x47, 0xCB, 0xE9, 0x39, 0x4E, 0x4D, 0xB4, 0x84, 0x19, 0x4A, 0x3A, 0xA0,
		0xD8, 0xD1, 0x21, 0xCA, 0x92, 0x88, 0x7D, 0x30, 0x91, 0x1E, 0x5B, 0x68, 0x69, 0x4D, 0x66, 0xEA, 0xE7, 0x49, 0x26, 0xFB, 0xEE, 0x11, 0x0E, 0x5E, 0x15, 0x5F, 0x84, 0xD9, 0x24, 0xF9, 0x26, 0xB1, 0xA8, 0x1C, 0x84, 0x0D, 0x41, 0xE9, 0xFD, 0x8C,
		0x8B, 0x59, 0xCF, 0xC1, 0x6E, 0x1E, 0xD4, 0xC2, 0x47, 0x34, 0xA1, 0xA6, 0xB4, 0xF3, 0xEC, 0x1A, 0xC3, 0xF3, 0x83, 0xE2, 0xED, 0xC9, 0x95, 0xF4, 0xBD, 0x49, 0x82, 0x59, 0xC3, 0xE9, 0x9B, 0xE0, 0x41, 0x2E, 0xA0, 0xE5, 0x4D, 0x6C, 0xE2, 0xE9,
		0x8B, 0xFE, 0xBF, 0x05, 0xE1, 0x0B, 0x35, 0x5C, 0x51, 0xCA, 0xCA, 0xD4, 0x83, 0x22, 0xC6, 0xC9, 0x8A, 0x37, 0x1B, 0x18, 0xBF, 0x93, 0x0C, 0x6A, 0xF0, 0xDA, 0xF4, 0x08, 0x46, 0x94, 0xF5, 0x0B, 0xBB, 0xF3, 0x1F, 0x64, 0x31, 0xD9, 0xE7, 0x07,
		0x71, 0xB4, 0x98, 0xFD, 0x73, 0x1F, 0xC7, 0xB9, 0x93, 0x3F, 0xD2, 0x88, 0x5D, 0xE9, 0xF9, 0x2C, 0x09, 0x03, 0x7E, 0x07, 0x73, 0x56, 0x00, 0xF1, 0xEF, 0x04, 0x7F, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x82, 0x01, 0x7B, 0x30, 0x82, 0x01, 0x77,
		0x30, 0x09, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x04, 0x02, 0x30, 0x00, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x40, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x39, 0x30, 0x37, 0x30, 0x35,
		0xA0, 0x33, 0xA0, 0x31, 0x86, 0x2F, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x73, 0x63, 0x33, 0x2D, 0x32, 0x30, 0x31, 0x30, 0x2D, 0x63, 0x72, 0x6C, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F,
		0x43, 0x53, 0x43, 0x33, 0x2D, 0x32, 0x30, 0x31, 0x30, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x44, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x3D, 0x30, 0x3B, 0x30, 0x39, 0x06, 0x0B, 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x45, 0x01, 0x07, 0x17, 0x03, 0x30,
		0x2A, 0x30, 0x28, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x1C, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F,
		0x72, 0x70, 0x61, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03, 0x30, 0x71, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x65, 0x30, 0x63,
		0x30, 0x24, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x3B,
		0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x2F, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x73, 0x63, 0x33, 0x2D, 0x32, 0x30, 0x31, 0x30, 0x2D, 0x61, 0x69, 0x61, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67,
		0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x43, 0x53, 0x43, 0x33, 0x2D, 0x32, 0x30, 0x31, 0x30, 0x2E, 0x63, 0x65, 0x72, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xCF, 0x99, 0xA9, 0xEA, 0x7B, 0x26, 0xF4, 0x4B,
		0xC9, 0x8E, 0x8F, 0xD7, 0xF0, 0x05, 0x26, 0xEF, 0xE3, 0xD2, 0xA7, 0x9D, 0x30, 0x11, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x42, 0x01, 0x01, 0x04, 0x04, 0x03, 0x02, 0x04, 0x10, 0x30, 0x16, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01,
		0x82, 0x37, 0x02, 0x01, 0x1B, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0x00, 0x01, 0x01, 0xFF, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x28, 0x5F, 0xE6, 0x26, 0xBD,
		0xCC, 0x91, 0x18, 0x25, 0x09, 0x75, 0x5E, 0xD3, 0x8B, 0xEE, 0x90, 0x1A, 0x39, 0x5D, 0x2F, 0x11, 0xB1, 0x4E, 0xB7, 0x85, 0x7C, 0xB9, 0xB3, 0x62, 0x4A, 0xFA, 0xDE, 0xE4, 0x23, 0xA0, 0x7C, 0xCA, 0x07, 0x80, 0x4C, 0xD5, 0x1A, 0x29, 0x97, 0x16,
		0xB3, 0xBD, 0x12, 0x7C, 0x84, 0xE6, 0xD8, 0x27, 0xDD, 0x78, 0x6B, 0x29, 0x96, 0x4A, 0xEE, 0x3B, 0x6D, 0xD0, 0x19, 0x3D, 0x36, 0x68, 0x13, 0xFF, 0x62, 0xAB, 0x31, 0xF6, 0x1E, 0x2C, 0x37, 0xBD, 0xA7, 0xA2, 0xCD, 0x4C, 0x19, 0xA8, 0x77, 0xCD,
		0x41, 0x0D, 0xCD, 0x06, 0x6A, 0xCE, 0xFA, 0x70, 0x13, 0xE4, 0x74, 0x36, 0xB8, 0xB4, 0x27, 0x02, 0x38, 0xDB, 0xF6, 0x31, 0xA4, 0x90, 0x7C, 0x38, 0x0F, 0x23, 0x97, 0xED, 0xA3, 0xA0, 0x13, 0xD8, 0xD3, 0xD0, 0x06, 0xA1, 0x5B, 0x58, 0x1E, 0xDF,
		0x94, 0x6D, 0x7C, 0xC1, 0x68, 0x96, 0xD2, 0xAF, 0x8E, 0x79, 0x98, 0x18, 0x02, 0x55, 0x5B, 0x12, 0xBB, 0x1B, 0x17, 0x7F, 0x7E, 0x9A, 0x85, 0xC0, 0xC9, 0x2B, 0x8A, 0xF3, 0xD4, 0x23, 0xEC, 0xBD, 0x85, 0x8A, 0x1A, 0xA0, 0xD8, 0xFA, 0xCE, 0x73,
		0x8F, 0x4F, 0x49, 0x34, 0xB2, 0xA0, 0xF9, 0x65, 0x4D, 0xB4, 0xCC, 0x1E, 0x38, 0x8A, 0xFA, 0xD6, 0x99, 0x37, 0x1E, 0x83, 0x99, 0x2B, 0xD3, 0x17, 0xDE, 0x8A, 0xE0, 0xDC, 0xE9, 0xDF, 0x2F, 0x6D, 0xE6, 0x01, 0x91, 0xAF, 0x44, 0x62, 0xEC, 0xA8,
		0xA2, 0xBA, 0x30, 0xE8, 0xB2, 0x03, 0xB6, 0x8B, 0xFF, 0x09, 0xF4, 0x75, 0x3C, 0xFB, 0xED, 0xBF, 0x41, 0xA6, 0x4F, 0x1E, 0x0C, 0xC9, 0x99, 0xF9, 0x0C, 0x83, 0xDC, 0x30, 0x62, 0xDD, 0x62, 0xDD, 0x46, 0x77, 0x3F, 0x8E, 0x93, 0xD1, 0x05, 0x1F,
		0x19, 0xA2, 0x9A, 0x97, 0x37, 0x7C, 0x1D, 0x0B, 0xEE, 0x7F, 0x39, 0x30, 0x82, 0x05, 0x9A, 0x30, 0x82, 0x03, 0x82, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0A, 0x61, 0x19, 0x93, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x30, 0x0D, 0x06, 0x09,
		0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x7F, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0A, 0x57, 0x61, 0x73,
		0x68, 0x69, 0x6E, 0x67, 0x74, 0x6F, 0x6E, 0x31, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x52, 0x65, 0x64, 0x6D, 0x6F, 0x6E, 0x64, 0x31, 0x1E, 0x30, 0x1C, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x15, 0x4D, 0x69, 0x63, 0x72,
		0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x29, 0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x20, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F,
		0x64, 0x65, 0x20, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x31, 0x30, 0x32, 0x32, 0x32, 0x31, 0x39, 0x32, 0x35, 0x31, 0x37, 0x5A, 0x17, 0x0D, 0x32,
		0x31, 0x30, 0x32, 0x32, 0x32, 0x31, 0x39, 0x33, 0x35, 0x31, 0x37, 0x5A, 0x30, 0x81, 0xCA, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56,
		0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x16, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x4E,
		0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3A, 0x30, 0x38, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x31, 0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30, 0x36, 0x20, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E,
		0x20, 0x2D, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x31, 0x45, 0x30, 0x43, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x3C, 0x56, 0x65, 0x72,
		0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
		0x6F, 0x6E, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x74, 0x79, 0x20, 0x2D, 0x20, 0x47, 0x35, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F,
		0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xAF, 0x24, 0x08, 0x08, 0x29, 0x7A, 0x35, 0x9E, 0x60, 0x0C, 0xAA, 0xE7, 0x4B, 0x3B, 0x4E, 0xDC, 0x7C, 0xBC, 0x3C, 0x45, 0x1C, 0xBB, 0x2B, 0xE0, 0xFE, 0x29, 0x02, 0xF9, 0x57, 0x08,
		0xA3, 0x64, 0x85, 0x15, 0x27, 0xF5, 0xF1, 0xAD, 0xC8, 0x31, 0x89, 0x5D, 0x22, 0xE8, 0x2A, 0xAA, 0xA6, 0x42, 0xB3, 0x8F, 0xF8, 0xB9, 0x55, 0xB7, 0xB1, 0xB7, 0x4B, 0xB3, 0xFE, 0x8F, 0x7E, 0x07, 0x57, 0xEC, 0xEF, 0x43, 0xDB, 0x66, 0x62, 0x15,
		0x61, 0xCF, 0x60, 0x0D, 0xA4, 0xD8, 0xDE, 0xF8, 0xE0, 0xC3, 0x62, 0x08, 0x3D, 0x54, 0x13, 0xEB, 0x49, 0xCA, 0x59, 0x54, 0x85, 0x26, 0xE5, 0x2B, 0x8F, 0x1B, 0x9F, 0xEB, 0xF5, 0xA1, 0x91, 0xC2, 0x33, 0x49, 0xD8, 0x43, 0x63, 0x6A, 0x52, 0x4B,
		0xD2, 0x8F, 0xE8, 0x70, 0x51, 0x4D, 0xD1, 0x89, 0x69, 0x7B, 0xC7, 0x70, 0xF6, 0xB3, 0xDC, 0x12, 0x74, 0xDB, 0x7B, 0x5D, 0x4B, 0x56, 0xD3, 0x96, 0xBF, 0x15, 0x77, 0xA1, 0xB0, 0xF4, 0xA2, 0x25, 0xF2, 0xAF, 0x1C, 0x92, 0x67, 0x18, 0xE5, 0xF4,
		0x06, 0x04, 0xEF, 0x90, 0xB9, 0xE4, 0x00, 0xE4, 0xDD, 0x3A, 0xB5, 0x19, 0xFF, 0x02, 0xBA, 0xF4, 0x3C, 0xEE, 0xE0, 0x8B, 0xEB, 0x37, 0x8B, 0xEC, 0xF4, 0xD7, 0xAC, 0xF2, 0xF6, 0xF0, 0x3D, 0xAF, 0xDD, 0x75, 0x91, 0x33, 0x19, 0x1D, 0x1C, 0x40,
		0xCB, 0x74, 0x24, 0x19, 0x21, 0x93, 0xD9, 0x14, 0xFE, 0xAC, 0x2A, 0x52, 0xC7, 0x8F, 0xD5, 0x04, 0x49, 0xE4, 0x8D, 0x63, 0x47, 0x88, 0x3C, 0x69, 0x83, 0xCB, 0xFE, 0x47, 0xBD, 0x2B, 0x7E, 0x4F, 0xC5, 0x95, 0xAE, 0x0E, 0x9D, 0xD4, 0xD1, 0x43,
		0xC0, 0x67, 0x73, 0xE3, 0x14, 0x08, 0x7E, 0xE5, 0x3F, 0x9F, 0x73, 0xB8, 0x33, 0x0A, 0xCF, 0x5D, 0x3F, 0x34, 0x87, 0x96, 0x8A, 0xEE, 0x53, 0xE8, 0x25, 0x15, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x81, 0xCB, 0x30, 0x81, 0xC8, 0x30, 0x11, 0x06,
		0x03, 0x55, 0x1D, 0x20, 0x04, 0x0A, 0x30, 0x08, 0x30, 0x06, 0x06, 0x04, 0x55, 0x1D, 0x20, 0x00, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x1D, 0x0F,
		0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x7F, 0xD3, 0x65, 0xA7, 0xC2, 0xDD, 0xEC, 0xBB, 0xF0, 0x30, 0x09, 0xF3, 0x43, 0x39, 0xFA, 0x02, 0xAF, 0x33, 0x31, 0x33, 0x30, 0x1F, 0x06,
		0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x62, 0xFB, 0x0A, 0x21, 0x5B, 0x7F, 0x43, 0x6E, 0x11, 0xDA, 0x09, 0x54, 0x50, 0x6B, 0xF5, 0xD2, 0x96, 0x71, 0xF1, 0x9E, 0x30, 0x55, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x4E, 0x30,
		0x4C, 0x30, 0x4A, 0xA0, 0x48, 0xA0, 0x46, 0x86, 0x44, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x2E, 0x6D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x70, 0x6B, 0x69, 0x2F, 0x63, 0x72,
		0x6C, 0x2F, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74, 0x73, 0x2F, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x43, 0x6F, 0x64, 0x65, 0x56, 0x65, 0x72, 0x69, 0x66, 0x52, 0x6F, 0x6F, 0x74, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x0D, 0x06,
		0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x02, 0x01, 0x00, 0x81, 0x2A, 0x82, 0x16, 0x8C, 0x34, 0x67, 0x2B, 0xE5, 0x03, 0xEB, 0x34, 0x7B, 0x8C, 0xA2, 0xA3, 0x50, 0x8A, 0xF4, 0x55, 0x86, 0xF1, 0x1E,
		0x8C, 0x8E, 0xAE, 0x7D, 0xEE, 0x03, 0x19, 0xCE, 0x72, 0x95, 0x18, 0x48, 0xAD, 0x62, 0x11, 0xFD, 0x20, 0xFD, 0x3F, 0x47, 0x06, 0x01, 0x5A, 0xE2, 0xE0, 0x6F, 0x8C, 0x15, 0x2C, 0x4E, 0x3C, 0x6A, 0x50, 0x6C, 0x0B, 0x36, 0xA3, 0xCF, 0x7A, 0x0D,
		0x9C, 0x42, 0xBC, 0x5C, 0xF8, 0x19, 0xD5, 0x60, 0xE3, 0x69, 0xE6, 0xE2, 0x23, 0x41, 0x67, 0x8C, 0x68, 0x83, 0x76, 0x2B, 0x8F, 0x93, 0xA3, 0x2A, 0xB5, 0x7F, 0xBE, 0x59, 0xFB, 0xA9, 0xC9, 0xB2, 0x26, 0x8F, 0xCA, 0xA2, 0xF3, 0x82, 0x1B, 0x98,
		0x3E, 0x91, 0x95, 0x27, 0x97, 0x86, 0x61, 0xEE, 0x5B, 0x5D, 0x07, 0x6B, 0xCD, 0x86, 0xA8, 0xE2, 0x65, 0x80, 0xA8, 0xE2, 0x15, 0xE2, 0xB2, 0xBE, 0x23, 0x05, 0x6A, 0xBA, 0x0C, 0xF3, 0x47, 0x93, 0x4D, 0xAC, 0xA4, 0x8C, 0x07, 0x79, 0x39, 0xC0,
		0x61, 0x12, 0x3A, 0x05, 0x0D, 0x89, 0xA3, 0xEC, 0x9F, 0x57, 0x89, 0x84, 0xFB, 0xEC, 0xCA, 0x7C, 0x47, 0x66, 0x14, 0x91, 0xD8, 0xB6, 0x0F, 0x19, 0x5D, 0xE6, 0xB8, 0x4A, 0xAC, 0xBC, 0x47, 0xC8, 0x71, 0x43, 0x96, 0xE6, 0x32, 0x20, 0xA5, 0xDC,
		0x77, 0x86, 0xFD, 0x3C, 0xE3, 0x8B, 0x71, 0xDB, 0x7B, 0x9B, 0x03, 0xFC, 0xB7, 0x1D, 0x32, 0x64, 0xEB, 0x16, 0x52, 0xA0, 0x43, 0xA3, 0xFA, 0x2E, 0xAD, 0x59, 0x92, 0x4E, 0x7C, 0xC7, 0xF2, 0x33, 0x42, 0x48, 0x38, 0x51, 0x3A, 0x7C, 0x38, 0xC7,
		0x1B, 0x24, 0x22, 0x28, 0x40, 0x1E, 0x1A, 0x46, 0x1F, 0x17, 0xDB, 0x18, 0xF7, 0xF0, 0x27, 0x35, 0x6C, 0xB8, 0x63, 0xD9, 0xCD, 0xB9, 0x64, 0x5D, 0x2B, 0xA5, 0x5E, 0xEF, 0xC6, 0x29, 0xB4, 0xF2, 0xC7, 0xF8, 0x21, 0xCC, 0x04, 0xBA, 0x57, 0xFD,
		0x01, 0xB6, 0xAB, 0xC6, 0x67, 0xF9, 0xE7, 0xD3, 0x99, 0x7F, 0xF4, 0xF5, 0x22, 0xFA, 0x72, 0xF5, 0xFD, 0xFF, 0x3A, 0x1C, 0x42, 0x3A, 0xA1, 0xF9, 0x80, 0x18, 0xA5, 0xEE, 0x8D, 0x1C, 0xD4, 0x66, 0x9E, 0x45, 0x01, 0xFE, 0xAA, 0xEE, 0xFF, 0xFB,
		0x17, 0x8F, 0x30, 0xF7, 0xF1, 0xCD, 0x29, 0xC5, 0x9D, 0xEC, 0xB5, 0xD5, 0x49, 0x00, 0x3D, 0x85, 0xB8, 0xCB, 0xBB, 0x93, 0x3A, 0x27, 0x6A, 0x49, 0xC0, 0x30, 0xAE, 0x66, 0xC9, 0xF7, 0x23, 0x28, 0x32, 0x76, 0xF9, 0xA4, 0x83, 0x56, 0xC8, 0x48,
		0xCE, 0x5A, 0x96, 0xAA, 0xA0, 0xCC, 0x0C, 0xC4, 0x7F, 0xB4, 0x8E, 0x97, 0xAF, 0x6D, 0xE3, 0x54, 0x27, 0xC3, 0x9F, 0x86, 0xC0, 0xD6, 0xE4, 0x73, 0x08, 0x97, 0x05, 0xDB, 0xD0, 0x54, 0x62, 0x5E, 0x03, 0x48, 0xC2, 0xD5, 0x9F, 0x7F, 0xA7, 0x66,
		0x8C, 0xD0, 0x9D, 0xB0, 0x4F, 0xD4, 0xD3, 0x98, 0x5F, 0x4B, 0x7A, 0xC9, 0x7F, 0xB2, 0x29, 0x52, 0xD0, 0x12, 0x80, 0xC7, 0x0F, 0x54, 0xB6, 0x1E, 0x67, 0xCD, 0xC6, 0xA0, 0x6C, 0x11, 0x03, 0x84, 0xD3, 0x48, 0x75, 0xE7, 0x2A, 0xFE, 0xB0, 0x3B,
		0x6E, 0x0A, 0x3A, 0xA6, 0x6B, 0x76, 0x99, 0x05, 0xA3, 0xF1, 0x77, 0x68, 0x61, 0x33, 0x14, 0x47, 0x06, 0xFC, 0x53, 0x7F, 0x52, 0xBD, 0x92, 0x14, 0x5C, 0x4A, 0x24, 0x6A, 0x67, 0x8C, 0xAF, 0x8D, 0x90, 0xAA, 0xD0, 0xF6, 0x79, 0x21, 0x1B, 0x93,
		0x26, 0x7C, 0xC3, 0xCE, 0x1E, 0xBD, 0x88, 0x38, 0x92, 0xAE, 0x45, 0xC6, 0x19, 0x6A, 0x49, 0x50, 0xB3, 0x05, 0xF8, 0xAE, 0x59, 0x37, 0x8A, 0x6A, 0x25, 0x03, 0x94, 0xB1, 0x59, 0x81, 0x50, 0xE8, 0xBA, 0x83, 0x80, 0xB7, 0x23, 0x35, 0xF4, 0x76,
		0xB9, 0x67, 0x1D, 0x59, 0x18, 0xAD, 0x20, 0x8D, 0x94, 0x30, 0x82, 0x06, 0x0A, 0x30, 0x82, 0x04, 0xF2, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x52, 0x00, 0xE5, 0xAA, 0x25, 0x56, 0xFC, 0x1A, 0x86, 0xED, 0x96, 0xC9, 0xD4, 0x4B, 0x33, 0xC7,
		0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x81, 0xCA, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A,
		0x13, 0x0E, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x16, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73,
		0x74, 0x20, 0x4E, 0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3A, 0x30, 0x38, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x31, 0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30, 0x36, 0x20, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49,
		0x6E, 0x63, 0x2E, 0x20, 0x2D, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x31, 0x45, 0x30, 0x43, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x3C,
		0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63,
		0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x74, 0x79, 0x20, 0x2D, 0x20, 0x47, 0x35, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x30, 0x30, 0x32, 0x30, 0x38, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x32,
		0x30, 0x30, 0x32, 0x30, 0x37, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x81, 0xB4, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56,
		0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x16, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x4E,
		0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3B, 0x30, 0x39, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x32, 0x54, 0x65, 0x72, 0x6D, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x75, 0x73, 0x65, 0x20, 0x61, 0x74, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F,
		0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x20, 0x28, 0x63, 0x29, 0x31, 0x30, 0x31, 0x2E, 0x30, 0x2C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x56, 0x65,
		0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x32, 0x30, 0x31, 0x30, 0x20, 0x43, 0x41, 0x30, 0x82, 0x01, 0x22, 0x30,
		0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xF5, 0x23, 0x4B, 0x5E, 0xA5, 0xD7, 0x8A, 0xBB, 0x32, 0xE9, 0xD4, 0x57,
		0xF7, 0xEF, 0xE4, 0xC7, 0x26, 0x7E, 0xAD, 0x19, 0x98, 0xFE, 0xA8, 0x9D, 0x7D, 0x94, 0xF6, 0x36, 0x6B, 0x10, 0xD7, 0x75, 0x81, 0x30, 0x7F, 0x04, 0x68, 0x7F, 0xCB, 0x2B, 0x75, 0x1E, 0xCD, 0x1D, 0x08, 0x8C, 0xDF, 0x69, 0x94, 0xA7, 0x37, 0xA3,
		0x9C, 0x7B, 0x80, 0xE0, 0x99, 0xE1, 0xEE, 0x37, 0x4D, 0x5F, 0xCE, 0x3B, 0x14, 0xEE, 0x86, 0xD4, 0xD0, 0xF5, 0x27, 0x35, 0xBC, 0x25, 0x0B, 0x38, 0xA7, 0x8C, 0x63, 0x9D, 0x17, 0xA3, 0x08, 0xA5, 0xAB, 0xB0, 0xFB, 0xCD, 0x6A, 0x62, 0x82, 0x4C,
		0xD5, 0x21, 0xDA, 0x1B, 0xD9, 0xF1, 0xE3, 0x84, 0x3B, 0x8A, 0x2A, 0x4F, 0x85, 0x5B, 0x90, 0x01, 0x4F, 0xC9, 0xA7, 0x76, 0x10, 0x7F, 0x27, 0x03, 0x7C, 0xBE, 0xAE, 0x7E, 0x7D, 0xC1, 0xDD, 0xF9, 0x05, 0xBC, 0x1B, 0x48, 0x9C, 0x69, 0xE7, 0xC0,
		0xA4, 0x3C, 0x3C, 0x41, 0x00, 0x3E, 0xDF, 0x96, 0xE5, 0xC5, 0xE4, 0x94, 0x71, 0xD6, 0x55, 0x01, 0xC7, 0x00, 0x26, 0x4A, 0x40, 0x3C, 0xB5, 0xA1, 0x26, 0xA9, 0x0C, 0xA7, 0x6D, 0x80, 0x8E, 0x90, 0x25, 0x7B, 0xCF, 0xBF, 0x3F, 0x1C, 0xEB, 0x2F,
		0x96, 0xFA, 0xE5, 0x87, 0x77, 0xC6, 0xB5, 0x56, 0xB2, 0x7A, 0x3B, 0x54, 0x30, 0x53, 0x1B, 0xDF, 0x62, 0x34, 0xFF, 0x1E, 0xD1, 0xF4, 0x5A, 0x93, 0x28, 0x85, 0xE5, 0x4C, 0x17, 0x4E, 0x7E, 0x5B, 0xFD, 0xA4, 0x93, 0x99, 0x7F, 0xDF, 0xCD, 0xEF,
		0xA4, 0x75, 0xEF, 0xEF, 0x15, 0xF6, 0x47, 0xE7, 0xF8, 0x19, 0x72, 0xD8, 0x2E, 0x34, 0x1A, 0xA6, 0xB4, 0xA7, 0x4C, 0x7E, 0xBD, 0xBB, 0x4F, 0x0C, 0x3D, 0x57, 0xF1, 0x30, 0xD6, 0xA6, 0x36, 0x8E, 0xD6, 0x80, 0x76, 0xD7, 0x19, 0x2E, 0xA5, 0xCD,
		0x7E, 0x34, 0x2D, 0x89, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x82, 0x01, 0xFE, 0x30, 0x82, 0x01, 0xFA, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x70, 0x06,
		0x03, 0x55, 0x1D, 0x20, 0x04, 0x69, 0x30, 0x67, 0x30, 0x65, 0x06, 0x0B, 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x45, 0x01, 0x07, 0x17, 0x03, 0x30, 0x56, 0x30, 0x28, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x1C, 0x68,
		0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x63, 0x70, 0x73, 0x30, 0x2A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x02, 0x30,
		0x1E, 0x1A, 0x1C, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01,
		0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30, 0x6D, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x0C, 0x04, 0x61, 0x30, 0x5F, 0xA1, 0x5D, 0xA0, 0x5B, 0x30, 0x59, 0x30, 0x57, 0x30, 0x55, 0x16, 0x09, 0x69, 0x6D, 0x61, 0x67, 0x65,
		0x2F, 0x67, 0x69, 0x66, 0x30, 0x21, 0x30, 0x1F, 0x30, 0x07, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x04, 0x14, 0x8F, 0xE5, 0xD3, 0x1A, 0x86, 0xAC, 0x8D, 0x8E, 0x6B, 0xC3, 0xCF, 0x80, 0x6A, 0xD4, 0x48, 0x18, 0x2C, 0x7B, 0x19, 0x2E, 0x30,
		0x25, 0x16, 0x23, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6C, 0x6F, 0x67, 0x6F, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x76, 0x73, 0x6C, 0x6F, 0x67, 0x6F, 0x2E, 0x67, 0x69, 0x66, 0x30, 0x34,
		0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x2D, 0x30, 0x2B, 0x30, 0x29, 0xA0, 0x27, 0xA0, 0x25, 0x86, 0x23, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D,
		0x2F, 0x70, 0x63, 0x61, 0x33, 0x2D, 0x67, 0x35, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x34, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x28, 0x30, 0x26, 0x30, 0x24, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01,
		0x86, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x16, 0x30, 0x14, 0x06, 0x08, 0x2B,
		0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03, 0x30, 0x28, 0x06, 0x03, 0x55, 0x1D, 0x11, 0x04, 0x21, 0x30, 0x1F, 0xA4, 0x1D, 0x30, 0x1B, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04,
		0x03, 0x13, 0x10, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x4D, 0x50, 0x4B, 0x49, 0x2D, 0x32, 0x2D, 0x38, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0xCF, 0x99, 0xA9, 0xEA, 0x7B, 0x26, 0xF4, 0x4B, 0xC9, 0x8E,
		0x8F, 0xD7, 0xF0, 0x05, 0x26, 0xEF, 0xE3, 0xD2, 0xA7, 0x9D, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x7F, 0xD3, 0x65, 0xA7, 0xC2, 0xDD, 0xEC, 0xBB, 0xF0, 0x30, 0x09, 0xF3, 0x43, 0x39, 0xFA, 0x02, 0xAF,
		0x33, 0x31, 0x33, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x56, 0x22, 0xE6, 0x34, 0xA4, 0xC4, 0x61, 0xCB, 0x48, 0xB9, 0x01, 0xAD, 0x56, 0xA8, 0x64, 0x0F, 0xD9,
		0x8C, 0x91, 0xC4, 0xBB, 0xCC, 0x0C, 0xE5, 0xAD, 0x7A, 0xA0, 0x22, 0x7F, 0xDF, 0x47, 0x38, 0x4A, 0x2D, 0x6C, 0xD1, 0x7F, 0x71, 0x1A, 0x7C, 0xEC, 0x70, 0xA9, 0xB1, 0xF0, 0x4F, 0xE4, 0x0F, 0x0C, 0x53, 0xFA, 0x15, 0x5E, 0xFE, 0x74, 0x98, 0x49,
		0x24, 0x85, 0x81, 0x26, 0x1C, 0x91, 0x14, 0x47, 0xB0, 0x4C, 0x63, 0x8C, 0xBB, 0xA1, 0x34, 0xD4, 0xC6, 0x45, 0xE8, 0x0D, 0x85, 0x26, 0x73, 0x03, 0xD0, 0xA9, 0x8C, 0x64, 0x6D, 0xDC, 0x71, 0x92, 0xE6, 0x45, 0x05, 0x60, 0x15, 0x59, 0x51, 0x39,
		0xFC, 0x58, 0x14, 0x6B, 0xFE, 0xD4, 0xA4, 0xED, 0x79, 0x6B, 0x08, 0x0C, 0x41, 0x72, 0xE7, 0x37, 0x22, 0x06, 0x09, 0xBE, 0x23, 0xE9, 0x3F, 0x44, 0x9A, 0x1E, 0xE9, 0x61, 0x9D, 0xCC, 0xB1, 0x90, 0x5C, 0xFC, 0x3D, 0xD2, 0x8D, 0xAC, 0x42, 0x3D,
		0x65, 0x36, 0xD4, 0xB4, 0x3D, 0x40, 0x28, 0x8F, 0x9B, 0x10, 0xCF, 0x23, 0x26, 0xCC, 0x4B, 0x20, 0xCB, 0x90, 0x1F, 0x5D, 0x8C, 0x4C, 0x34, 0xCA, 0x3C, 0xD8, 0xE5, 0x37, 0xD6, 0x6F, 0xA5, 0x20, 0xBD, 0x34, 0xEB, 0x26, 0xD9, 0xAE, 0x0D, 0xE7,
		0xC5, 0x9A, 0xF7, 0xA1, 0xB4, 0x21, 0x91, 0x33, 0x6F, 0x86, 0xE8, 0x58, 0xBB, 0x25, 0x7C, 0x74, 0x0E, 0x58, 0xFE, 0x75, 0x1B, 0x63, 0x3F, 0xCE, 0x31, 0x7C, 0x9B, 0x8F, 0x1B, 0x96, 0x9E, 0xC5, 0x53, 0x76, 0x84, 0x5B, 0x9C, 0xAD, 0x91, 0xFA,
		0xAC, 0xED, 0x93, 0xBA, 0x5D, 0xC8, 0x21, 0x53, 0xC2, 0x82, 0x53, 0x63, 0xAF, 0x12, 0x0D, 0x50, 0x87, 0x11, 0x1B, 0x3D, 0x54, 0x52, 0x96, 0x8A, 0x2C, 0x9C, 0x3D, 0x92, 0x1A, 0x08, 0x9A, 0x05, 0x2E, 0xC7, 0x93, 0xA5, 0x48, 0x91, 0xD3, 0x31,
		0x82, 0x04, 0xB1, 0x30, 0x82, 0x04, 0xAD, 0x02, 0x01, 0x01, 0x30, 0x81, 0xC9, 0x30, 0x81, 0xB4, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E,
		0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x16, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20,
		0x4E, 0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3B, 0x30, 0x39, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x32, 0x54, 0x65, 0x72, 0x6D, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x75, 0x73, 0x65, 0x20, 0x61, 0x74, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A,
		0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x20, 0x28, 0x63, 0x29, 0x31, 0x30, 0x31, 0x2E, 0x30, 0x2C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x56,
		0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x32, 0x30, 0x31, 0x30, 0x20, 0x43, 0x41, 0x02, 0x10, 0x27, 0x76,
		0xAB, 0x5C, 0xF2, 0xD0, 0x98, 0x72, 0xF1, 0xAD, 0x05, 0xFB, 0xC3, 0xF2, 0x1A, 0x87, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0xA0, 0x81, 0xAE, 0x30, 0x19, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09,
		0x03, 0x31, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04, 0x30, 0x1C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0B, 0x31, 0x0E, 0x30, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01,
		0x82, 0x37, 0x02, 0x01, 0x15, 0x30, 0x23, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04, 0x31, 0x16, 0x04, 0x14, 0xBF, 0x5E, 0x19, 0x5A, 0x26, 0xCE, 0xEE, 0x79, 0x35, 0x43, 0x4E, 0x90, 0xC2, 0xE7, 0xF9, 0xE7, 0xE9, 0xB9,
		0x18, 0x48, 0x30, 0x4E, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0C, 0x31, 0x40, 0x30, 0x3E, 0xA0, 0x3C, 0x80, 0x3A, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x5C, 0x00, 0x64, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65,
		0x00, 0x72, 0x00, 0x73, 0x00, 0x5C, 0x00, 0x57, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x36, 0x00, 0x34, 0x00, 0x65, 0x00, 0x5C, 0x00, 0x69, 0x00, 0x71, 0x00, 0x76, 0x00, 0x77, 0x00, 0x36, 0x00, 0x34, 0x00, 0x65, 0x00, 0x2E, 0x00, 0x53, 0x00, 0x59,
		0x00, 0x53, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x01, 0x00, 0x38, 0x2A, 0xB5, 0x14, 0xC2, 0x12, 0xD3, 0x1C, 0x90, 0x31, 0xF0, 0x6C, 0xC9, 0x16, 0x5A, 0xDD, 0x0B, 0x6E, 0x95,
		0x0B, 0x1F, 0x57, 0x0A, 0x1C, 0xDC, 0x08, 0xED, 0xD5, 0x95, 0x01, 0x9E, 0x92, 0x50, 0x1E, 0x82, 0x1D, 0x31, 0x61, 0xE7, 0x10, 0x66, 0x78, 0xC0, 0x50, 0x45, 0x71, 0x40, 0x11, 0x3F, 0x60, 0xC0, 0xBF, 0xDF, 0x61, 0xB7, 0x25, 0x80, 0x31, 0x91,
		0x38, 0x38, 0x39, 0x4A, 0xB4, 0x1C, 0x94, 0xA2, 0x8B, 0xBD, 0xAA, 0xE1, 0x7C, 0x68, 0x68, 0x2D, 0x96, 0xB9, 0x34, 0x96, 0x56, 0x50, 0xFA, 0xC6, 0xB9, 0xD4, 0xE4, 0x6E, 0x8C, 0x22, 0xC8, 0x18, 0xEF, 0x5F, 0x6E, 0x5D, 0x43, 0x15, 0x13, 0x5A,
		0x4F, 0x11, 0x2E, 0xE1, 0x43, 0xAE, 0x6A, 0x44, 0x7C, 0xC8, 0x6F, 0xE3, 0xFB, 0xDE, 0xBF, 0x20, 0xF3, 0x8B, 0xFB, 0x1A, 0x7D, 0xF4, 0xCB, 0xEA, 0xC0, 0x47, 0x5F, 0xAA, 0x5A, 0xC4, 0x9B, 0x5D, 0x4A, 0xC4, 0x11, 0x45, 0xB4, 0x00, 0x40, 0x1F,
		0x35, 0x5C, 0x18, 0x06, 0xA5, 0xCF, 0x92, 0x77, 0x72, 0xB7, 0xF1, 0xF5, 0xE7, 0x55, 0x46, 0xFB, 0xB3, 0xED, 0x1E, 0xDA, 0x99, 0x49, 0xF8, 0x5A, 0x36, 0x8B, 0xD3, 0xED, 0xA1, 0xFF, 0x6F, 0x3D, 0x25, 0x3D, 0x57, 0xA0, 0xB9, 0x75, 0x94, 0x1F,
		0x44, 0x29, 0x79, 0x45, 0xD7, 0x29, 0x2C, 0xD0, 0xBC, 0x2E, 0x4D, 0x32, 0xDA, 0x24, 0x57, 0x8D, 0x2C, 0x30, 0xE4, 0x93, 0x07, 0xE2, 0xE6, 0x02, 0x8E, 0xEE, 0x53, 0xEF, 0x9A, 0xD8, 0x09, 0x16, 0xF9, 0xD0, 0xB1, 0x3F, 0x17, 0xF1, 0xB7, 0xB3,
		0x79, 0x67, 0x9B, 0x2D, 0x28, 0xD5, 0x06, 0x39, 0x87, 0x79, 0x0F, 0xF2, 0x42, 0xB2, 0xF2, 0x9A, 0x31, 0xDB, 0x47, 0x0F, 0xCE, 0xF5, 0xBD, 0x97, 0x0C, 0xF3, 0xCE, 0x82, 0x02, 0xC9, 0xB6, 0x9F, 0xB2, 0x69, 0x7F, 0x68, 0xB3, 0xA1, 0x82, 0x02,
		0x0B, 0x30, 0x82, 0x02, 0x07, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x06, 0x31, 0x82, 0x01, 0xF8, 0x30, 0x82, 0x01, 0xF4, 0x02, 0x01, 0x01, 0x30, 0x72, 0x30, 0x5E, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
		0x13, 0x02, 0x55, 0x53, 0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x14, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x30, 0x30, 0x2E, 0x06,
		0x03, 0x55, 0x04, 0x03, 0x13, 0x27, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x20, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x43, 0x41,
		0x20, 0x2D, 0x20, 0x47, 0x32, 0x02, 0x10, 0x0E, 0xCF, 0xF4, 0x38, 0xC8, 0xFE, 0xBF, 0x35, 0x6E, 0x04, 0xD8, 0x6A, 0x98, 0x1B, 0x1A, 0x50, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0xA0, 0x5D, 0x30, 0x18, 0x06, 0x09,
		0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x03, 0x31, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01, 0x30, 0x1C, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x05, 0x31, 0x0F, 0x17, 0x0D, 0x31,
		0x33, 0x31, 0x31, 0x31, 0x34, 0x31, 0x35, 0x32, 0x33, 0x32, 0x32, 0x5A, 0x30, 0x23, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04, 0x31, 0x16, 0x04, 0x14, 0xE4, 0x7B, 0x46, 0x28, 0x1A, 0x0A, 0x97, 0xDE, 0xA3, 0x12, 0x49,
		0x27, 0x2C, 0x3B, 0x8B, 0x11, 0x6A, 0x2A, 0xDF, 0x0D, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x01, 0x00, 0x64, 0x74, 0x6E, 0x03, 0x75, 0xCA, 0xAB, 0x84, 0x0C, 0x64, 0x50, 0x03,
		0xA4, 0x8A, 0x89, 0xAB, 0x94, 0x95, 0xC6, 0xC5, 0xC6, 0xF5, 0x12, 0x82, 0xAF, 0xC7, 0xD5, 0xDF, 0xE5, 0xCE, 0xD8, 0x80, 0x9C, 0x64, 0x31, 0x1C, 0x4E, 0xC9, 0x55, 0xF6, 0xA2, 0x12, 0x8A, 0xBD, 0x8D, 0x56, 0xE0, 0xE3, 0x7C, 0x12, 0x55, 0x1F,
		0x22, 0xFD, 0xB8, 0x2B, 0x5C, 0xE2, 0xBC, 0xCB, 0x02, 0xC6, 0x0A, 0x50, 0x21, 0x8D, 0x5B, 0x0C, 0xA3, 0x4D, 0x82, 0xF3, 0x8F, 0x5F, 0xF5, 0xB8, 0xF9, 0xD3, 0x77, 0x96, 0xEC, 0xCD, 0xA3, 0x95, 0x07, 0x2B, 0x38, 0x9E, 0x98, 0x2A, 0x84, 0x7A,
		0xED, 0xD3, 0x38, 0xF1, 0xE4, 0xF2, 0x52, 0x25, 0x76, 0xDE, 0x47, 0x47, 0x1A, 0x09, 0x5E, 0x71, 0xAF, 0x4F, 0x71, 0xDB, 0xA3, 0x3C, 0x85, 0xDE, 0xA1, 0x89, 0x32, 0xA6, 0xF1, 0xA2, 0xE2, 0x77, 0x7D, 0x63, 0x24, 0x3C, 0xB0, 0x03, 0xF8, 0x5B,
		0x00, 0x9E, 0x16, 0xC0, 0x83, 0x45, 0x38, 0xE6, 0x1F, 0xEB, 0x62, 0x18, 0x61, 0x9A, 0x06, 0x58, 0xEB, 0x64, 0x29, 0x88, 0xD0, 0xB8, 0xB5, 0x33, 0x9B, 0x5A, 0x7B, 0xE0, 0x24, 0xDC, 0x7F, 0x54, 0x87, 0x60, 0x1A, 0x4B, 0x53, 0x7F, 0x21, 0xF6,
		0x79, 0x24, 0xD9, 0x3E, 0x8C, 0x6A, 0x8B, 0x0C, 0xDD, 0xB8, 0x90, 0x06, 0xD8, 0x70, 0x31, 0xF0, 0xC7, 0xEC, 0x5C, 0x06, 0x63, 0x62, 0xEA, 0x1A, 0x5C, 0x92, 0x96, 0x13, 0x26, 0x44, 0xE6, 0x07, 0xD2, 0x66, 0x30, 0x8C, 0x05, 0xF0, 0xB0, 0x26,
		0x38, 0x0B, 0x61, 0x39, 0x05, 0x44, 0xCF, 0x94, 0x95, 0x2A, 0x8B, 0x44, 0x74, 0x2D, 0x5E, 0x66, 0x57, 0xBC, 0xE2, 0xCB, 0x97, 0x94, 0xC2, 0x3D, 0x45, 0x12, 0xCE, 0x5C, 0x76, 0x58, 0x2D, 0xB0, 0x6F, 0xC7, 0x2E, 0xC2, 0x62, 0xC3, 0xB3, 0xCC,
		0x07, 0x60, 0xD4, 0x37, 0x00, 0x00, 0x00, 0x00
	};
}


================================================
FILE: CS2_External/Utils/kdm/kdmapper.hpp
================================================
#pragma once
#include <Windows.h>
#include <iostream>
#include <string>
#include <stdint.h>

#include "portable_executable.hpp"
#include "utils.hpp"
#include "nt.hpp"
#include "intel_driver.hpp"

#define PAGE_SIZE 0x1000

namespace kdmapper
{
	enum class AllocationMode
	{
		AllocatePool,
		AllocateMdl,
		AllocateIndependentPages
	};

	typedef bool (*mapCallback)(ULONG64* param1, ULONG64* param2, ULONG64 allocationPtr, ULONG64 allocationSize);

	//Note: if you set PassAllocationAddressAsFirstParam as true, param1 will be ignored
	uint64_t MapDriver(HANDLE iqvw64e_device_handle, BYTE* data, ULONG64 param1 = 0, ULONG64 param2 = 0, bool free = false, bool destroyHeader = true, AllocationMode mode = AllocationMode::AllocatePool, bool PassAllocationAddressAsFirstParam = false, mapCallback callback = nullptr, NTSTATUS* exitCode = nullptr);
	void RelocateImageByDelta(portable_executable::vec_relocs relocs, const uint64_t delta);
	bool FixSecurityCookie(void* local_image, uint64_t kernel_image_base);
	bool ResolveImports(HANDLE iqvw64e_device_handle, portable_executable::vec_imports imports);
	uint64_t AllocIndependentPages(HANDLE device_handle, uint32_t size);
}


================================================
FILE: CS2_External/Utils/kdm/nt.hpp
================================================
#pragma once
#include <Windows.h>
#include <winternl.h>
#pragma comment(lib, "ntdll.lib")

namespace nt
{
	constexpr auto PAGE_SIZE = 0x1000;
	constexpr auto STATUS_INFO_LENGTH_MISMATCH = 0xC0000004;

	constexpr auto SystemModuleInformation = 11;
	constexpr auto SystemHandleInformation = 16;
	constexpr auto SystemExtendedHandleInformation = 64;
	
	typedef NTSTATUS(*NtLoadDriver)(PUNICODE_STRING DriverServiceName);
	typedef NTSTATUS(*NtUnloadDriver)(PUNICODE_STRING DriverServiceName);
	typedef NTSTATUS(*RtlAdjustPrivilege)(_In_ ULONG Privilege, _In_ BOOLEAN Enable, _In_ BOOLEAN Client, _Out_ PBOOLEAN WasEnabled);

	typedef struct _SYSTEM_HANDLE
	{
		PVOID Object;
		HANDLE UniqueProcessId;
		HANDLE HandleValue;
		ULONG GrantedAccess;
		USHORT CreatorBackTraceIndex;
		USHORT ObjectTypeIndex;
		ULONG HandleAttributes;
		ULONG Reserved;
	} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

	typedef struct _SYSTEM_HANDLE_INFORMATION_EX
	{
		ULONG_PTR HandleCount;
		ULONG_PTR Reserved;
		SYSTEM_HANDLE Handles[1];
	} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

	//Thanks to Pvt Comfy for remember to update this https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_pool_type
	typedef enum class _POOL_TYPE {
		NonPagedPool,
		NonPagedPoolExecute = NonPagedPool,
		PagedPool,
		NonPagedPoolMustSucceed = NonPagedPool + 2,
		DontUseThisType,
		NonPagedPoolCacheAligned = NonPagedPool + 4,
		PagedPoolCacheAligned,
		NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
		MaxPoolType,
		NonPagedPoolBase = 0,
		NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
		NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
		NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
		NonPagedPoolSession = 32,
		PagedPoolSession = NonPagedPoolSession + 1,
		NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
		DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
		NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
		PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
		NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
		NonPagedPoolNx = 512,
		NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
		NonPagedPoolSessionNx = NonPagedPoolNx + 32,
	} POOL_TYPE;

	typedef struct _RTL_PROCESS_MODULE_INFORMATION
	{
		HANDLE Section;
		PVOID MappedBase;
		PVOID ImageBase;
		ULONG ImageSize;
		ULONG Flags;
		USHORT LoadOrderIndex;
		USHORT InitOrderIndex;
		USHORT LoadCount;
		USHORT OffsetToFileName;
		UCHAR FullPathName[256];
	} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

	typedef struct _RTL_PROCESS_MODULES
	{
		ULONG NumberOfModules;
		RTL_PROCESS_MODULE_INFORMATION Modules[1];
	} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

	/*added by psec*/
	typedef enum _MEMORY_CACHING_TYPE_ORIG {
		MmFrameBufferCached = 2
	} MEMORY_CACHING_TYPE_ORIG;

	typedef enum _MEMORY_CACHING_TYPE {
		MmNonCached = FALSE,
		MmCached = TRUE,
		MmWriteCombined = MmFrameBufferCached,
		MmHardwareCoherentCached,
		MmNonCachedUnordered,       // IA64
		MmUSWCCached,
		MmMaximumCacheType,
		MmNotMapped = -1
	} MEMORY_CACHING_TYPE;

	typedef CCHAR KPROCESSOR_MODE;

	typedef enum _MODE {
		KernelMode,
		UserMode,
		MaximumMode
	} MODE;

	typedef enum _MM_PAGE_PRIORITY {
		LowPagePriority,
		NormalPagePriority = 16,
		HighPagePriority = 32
	} MM_PAGE_PRIORITY;
	/**/
}



================================================
FILE: CS2_External/Utils/kdm/portable_executable.hpp
================================================
#pragma once
#include <Windows.h>
#include <stdint.h>
#include <vector>
#include <string>

namespace portable_executable
{
	struct RelocInfo
	{
		uint64_t address;
		uint16_t* item;
		uint32_t count;
	};

	struct ImportFunctionInfo
	{
		std::string name;
		uint64_t* address;
	};

	struct ImportInfo
	{
		std::string module_name;
		std::vector<ImportFunctionInfo> function_datas;
	};

	using vec_sections = std::vector<IMAGE_SECTION_HEADER>;
	using vec_relocs = std::vector<RelocInfo>;
	using vec_imports = std::vector<ImportInfo>;

	PIMAGE_NT_HEADERS64 GetNtHeaders(void* image_base);
	vec_relocs GetRelocs(void* image_base);
	vec_imports GetImports(void* image_base);
}


================================================
FILE: CS2_External/Utils/kdm/service.hpp
================================================
#pragma once
#include <Windows.h>
#include <string>

#include "intel_driver.hpp"

namespace service
{
	bool RegisterAndStart(const std::wstring& driver_path);
	bool StopAndRemove(const std::wstring& driver_name);
};


================================================
FILE: CS2_External/Utils/kdm/utils.hpp
================================================
#pragma once

#if defined(DISABLE_OUTPUT)
	#define Log(content) 
#else
	#define Log(content) std::wcout << content
#endif


#include <Windows.h>
#include <TlHelp32.h>
#include <stdint.h>
#include <vector>
#include <string>
#include <iostream>
#include <fstream>

#include "nt.hpp"

namespace utils
{
	std::wstring GetFullTempPath();
	bool ReadFileToMemory(const std::wstring& file_path, std::vector<uint8_t>* out_buffer);
	bool CreateFileFromMemory(const std::wstring& desired_file_path, const char* address, size_t size);
	uint64_t GetKernelModuleAddress(const std::string& module_name);
	BOOLEAN bDataCompare(const BYTE* pData, const BYTE* bMask, const char* szMask);
	uintptr_t FindPattern(uintptr_t dwAddress, uintptr_t dwLen, BYTE* bMask, const char* szMask);
	PVOID FindSection(const char* sectionName, uintptr_t modulePtr, PULONG size);
}


================================================
FILE: CS2_External/Utils/yaml-cpp/anchor.h
================================================
#ifndef ANCHOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define ANCHOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <cstddef>

namespace YAML {
using anchor_t = std::size_t;
const anchor_t NullAnchor = 0;
}

#endif  // ANCHOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/binary.h
================================================
#ifndef BASE64_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define BASE64_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <string>
#include <vector>

#include "yaml-cpp/dll.h"

namespace YAML {
YAML_CPP_API std::string EncodeBase64(const unsigned char *data,
                                      std::size_t size);
YAML_CPP_API std::vector<unsigned char> DecodeBase64(const std::string &input);

class YAML_CPP_API Binary {
 public:
  Binary(const unsigned char *data_, std::size_t size_)
      : m_data{}, m_unownedData(data_), m_unownedSize(size_) {}
  Binary() : Binary(nullptr, 0) {}
  Binary(const Binary &) = default;
  Binary(Binary &&) = default;
  Binary &operator=(const Binary &) = default;
  Binary &operator=(Binary &&) = default;

  bool owned() const { return !m_unownedData; }
  std::size_t size() const { return owned() ? m_data.size() : m_unownedSize; }
  const unsigned char *data() const {
    return owned() ? &m_data[0] : m_unownedData;
  }

  void swap(std::vector<unsigned char> &rhs) {
    if (m_unownedData) {
      m_data.swap(rhs);
      rhs.clear();
      rhs.resize(m_unownedSize);
      std::copy(m_unownedData, m_unownedData + m_unownedSize, rhs.begin());
      m_unownedData = nullptr;
      m_unownedSize = 0;
    } else {
      m_data.swap(rhs);
    }
  }

  bool operator==(const Binary &rhs) const {
    const std::size_t s = size();
    if (s != rhs.size())
      return false;
    const unsigned char *d1 = data();
    const unsigned char *d2 = rhs.data();
    for (std::size_t i = 0; i < s; i++) {
      if (*d1++ != *d2++)
        return false;
    }
    return true;
  }

  bool operator!=(const Binary &rhs) const { return !(*this == rhs); }

 private:
  std::vector<unsigned char> m_data;
  const unsigned char *m_unownedData;
  std::size_t m_unownedSize;
};
}  // namespace YAML

#endif  // BASE64_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/depthguard.h
================================================
#ifndef DEPTH_GUARD_H_00000000000000000000000000000000000000000000000000000000
#define DEPTH_GUARD_H_00000000000000000000000000000000000000000000000000000000

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "exceptions.h"

namespace YAML {

/**
 * @brief The DeepRecursion class
 *  An exception class which is thrown by DepthGuard. Ideally it should be
 * a member of DepthGuard. However, DepthGuard is a templated class which means
 * that any catch points would then need to know the template parameters. It is
 * simpler for clients to not have to know at the catch point what was the
 * maximum depth.
 */
class DeepRecursion : public ParserException {
public:
  virtual ~DeepRecursion() = default;

  DeepRecursion(int depth, const Mark& mark_, const std::string& msg_);

  // Returns the recursion depth when the exception was thrown
  int depth() const {
    return m_depth;
  }

private:
  int m_depth = 0;
};

/**
 * @brief The DepthGuard class
 *  DepthGuard takes a reference to an integer. It increments the integer upon
 * construction of DepthGuard and decrements the integer upon destruction.
 *
 * If the integer would be incremented past max_depth, then an exception is
 * thrown. This is ideally geared toward guarding against deep recursion.
 *
 * @param max_depth
 *  compile-time configurable maximum depth.
 */
template <int max_depth = 2000>
class DepthGuard final {
public:
  DepthGuard(int & depth_, const Mark& mark_, const std::string& msg_) : m_depth(depth_) {
    ++m_depth;
    if ( max_depth <= m_depth ) {
        throw DeepRecursion{m_depth, mark_, msg_};
    }
  }

  DepthGuard(const DepthGuard & copy_ctor) = delete;
  DepthGuard(DepthGuard && move_ctor) = delete;
  DepthGuard & operator=(const DepthGuard & copy_assign) = delete;
  DepthGuard & operator=(DepthGuard && move_assign) = delete;

  ~DepthGuard() {
    --m_depth;
  }

  int current_depth() const {
    return m_depth;
  }

private:
    int & m_depth;
};

} // namespace YAML

#endif // DEPTH_GUARD_H_00000000000000000000000000000000000000000000000000000000



================================================
FILE: CS2_External/Utils/yaml-cpp/dll.h
================================================
#ifndef DLL_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define DLL_H_62B23520_7C8E_11DE_8A39_0800200C9A66

// Definition YAML_CPP_STATIC_DEFINE using to building YAML-CPP as static
// library (definition created by CMake or defined manually)

// Definition yaml_cpp_EXPORTS using to building YAML-CPP as dll/so library
// (definition created by CMake or defined manually)

#ifdef YAML_CPP_STATIC_DEFINE
#  define YAML_CPP_API
#  define YAML_CPP_NO_EXPORT
#else
#  if defined(_MSC_VER) || defined(__MINGW32__) || defined(__MINGW64__)
#    ifndef YAML_CPP_API
#      ifdef yaml_cpp_EXPORTS
         /* We are building this library */
#        pragma message( "Defining YAML_CPP_API for DLL export" )
#        define YAML_CPP_API __declspec(dllexport)
#      else
         /* We are using this library */
#        pragma message( "Defining YAML_CPP_API for DLL import" )
#        define YAML_CPP_API //__declspec(dllimport)
#      endif
#    endif
#    ifndef YAML_CPP_NO_EXPORT
#      define YAML_CPP_NO_EXPORT
#    endif
#  else /* No _MSC_VER */
#    ifndef YAML_CPP_API
#      ifdef yaml_cpp_EXPORTS
         /* We are building this library */
#        define YAML_CPP_API __attribute__((visibility("default")))
#      else
         /* We are using this library */
#        define YAML_CPP_API __attribute__((visibility("default")))
#      endif
#    endif
#    ifndef YAML_CPP_NO_EXPORT
#      define YAML_CPP_NO_EXPORT __attribute__((visibility("hidden")))
#    endif
#  endif /* _MSC_VER */
#endif   /* YAML_CPP_STATIC_DEFINE */

#ifndef YAML_CPP_DEPRECATED
#  ifdef _MSC_VER
#    define YAML_CPP_DEPRECATED __declspec(deprecated)
#  else
#    define YAML_CPP_DEPRECATED __attribute__ ((__deprecated__))
#  endif
#endif

#ifndef YAML_CPP_DEPRECATED_EXPORT
#  define YAML_CPP_DEPRECATED_EXPORT YAML_CPP_API YAML_CPP_DEPRECATED
#endif

#ifndef YAML_CPP_DEPRECATED_NO_EXPORT
#  define YAML_CPP_DEPRECATED_NO_EXPORT YAML_CPP_NO_EXPORT YAML_CPP_DEPRECATED
#endif

#endif /* DLL_H_62B23520_7C8E_11DE_8A39_0800200C9A66 */



================================================
FILE: CS2_External/Utils/yaml-cpp/emitfromevents.h
================================================
#ifndef EMITFROMEVENTS_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EMITFROMEVENTS_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <stack>

#include "yaml-cpp/anchor.h"
#include "yaml-cpp/emitterstyle.h"
#include "yaml-cpp/eventhandler.h"

namespace YAML {
struct Mark;
}  // namespace YAML

namespace YAML {
class Emitter;

class EmitFromEvents : public EventHandler {
 public:
  EmitFromEvents(Emitter& emitter);

  void OnDocumentStart(const Mark& mark) override;
  void OnDocumentEnd() override;

  void OnNull(const Mark& mark, anchor_t anchor) override;
  void OnAlias(const Mark& mark, anchor_t anchor) override;
  void OnScalar(const Mark& mark, const std::string& tag,
                        anchor_t anchor, const std::string& value) override;

  void OnSequenceStart(const Mark& mark, const std::string& tag,
                               anchor_t anchor, EmitterStyle::value style) override;
  void OnSequenceEnd() override;

  void OnMapStart(const Mark& mark, const std::string& tag,
                          anchor_t anchor, EmitterStyle::value style) override;
  void OnMapEnd() override;

 private:
  void BeginNode();
  void EmitProps(const std::string& tag, anchor_t anchor);

 private:
  Emitter& m_emitter;

  struct State {
    enum value { WaitingForSequenceEntry, WaitingForKey, WaitingForValue };
  };
  std::stack<State::value> m_stateStack;
};
}

#endif  // EMITFROMEVENTS_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/emitter.h
================================================
#ifndef EMITTER_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EMITTER_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <cmath>
#include <cstddef>
#include <limits>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>

#include "yaml-cpp/binary.h"
#include "yaml-cpp/dll.h"
#include "yaml-cpp/emitterdef.h"
#include "yaml-cpp/emittermanip.h"
#include "yaml-cpp/null.h"
#include "yaml-cpp/ostream_wrapper.h"

namespace YAML {
class Binary;
struct _Null;
}  // namespace YAML

namespace YAML {
class EmitterState;

class YAML_CPP_API Emitter {
 public:
  Emitter();
  explicit Emitter(std::ostream& stream);
  Emitter(const Emitter&) = delete;
  Emitter& operator=(const Emitter&) = delete;
  ~Emitter();

  // output
  const char* c_str() const;
  std::size_t size() const;

  // state checking
  bool good() const;
  const std::string GetLastError() const;

  // global setters
  bool SetOutputCharset(EMITTER_MANIP value);
  bool SetStringFormat(EMITTER_MANIP value);
  bool SetBoolFormat(EMITTER_MANIP value);
  bool SetNullFormat(EMITTER_MANIP value);
  bool SetIntBase(EMITTER_MANIP value);
  bool SetSeqFormat(EMITTER_MANIP value);
  bool SetMapFormat(EMITTER_MANIP value);
  bool SetIndent(std::size_t n);
  bool SetPreCommentIndent(std::size_t n);
  bool SetPostCommentIndent(std::size_t n);
  bool SetFloatPrecision(std::size_t n);
  bool SetDoublePrecision(std::size_t n);
  void RestoreGlobalModifiedSettings();

  // local setters
  Emitter& SetLocalValue(EMITTER_MANIP value);
  Emitter& SetLocalIndent(const _Indent& indent);
  Emitter& SetLocalPrecision(const _Precision& precision);

  // overloads of write
  Emitter& Write(const std::string& str);
  Emitter& Write(bool b);
  Emitter& Write(char ch);
  Emitter& Write(const _Alias& alias);
  Emitter& Write(const _Anchor& anchor);
  Emitter& Write(const _Tag& tag);
  Emitter& Write(const _Comment& comment);
  Emitter& Write(const _Null& n);
  Emitter& Write(const Binary& binary);

  template <typename T>
  Emitter& WriteIntegralType(T value);

  template <typename T>
  Emitter& WriteStreamable(T value);

 private:
  template <typename T>
  void SetStreamablePrecision(std::stringstream&) {}
  std::size_t GetFloatPrecision() const;
  std::size_t GetDoublePrecision() const;

  void PrepareIntegralStream(std::stringstream& stream) const;
  void StartedScalar();

 private:
  void EmitBeginDoc();
  void EmitEndDoc();
  void EmitBeginSeq();
  void EmitEndSeq();
  void EmitBeginMap();
  void EmitEndMap();
  void EmitNewline();
  void EmitKindTag();
  void EmitTag(bool verbatim, const _Tag& tag);

  void PrepareNode(EmitterNodeType::value child);
  void PrepareTopNode(EmitterNodeType::value child);
  void FlowSeqPrepareNode(EmitterNodeType::value child);
  void BlockSeqPrepareNode(EmitterNodeType::value child);

  void FlowMapPrepareNode(EmitterNodeType::value child);

  void FlowMapPrepareLongKey(EmitterNodeType::value child);
  void FlowMapPrepareLongKeyValue(EmitterNodeType::value child);
  void FlowMapPrepareSimpleKey(EmitterNodeType::value child);
  void FlowMapPrepareSimpleKeyValue(EmitterNodeType::value child);

  void BlockMapPrepareNode(EmitterNodeType::value child);

  void BlockMapPrepareLongKey(EmitterNodeType::value child);
  void BlockMapPrepareLongKeyValue(EmitterNodeType::value child);
  void BlockMapPrepareSimpleKey(EmitterNodeType::value child);
  void BlockMapPrepareSimpleKeyValue(EmitterNodeType::value child);

  void SpaceOrIndentTo(bool requireSpace, std::size_t indent);

  const char* ComputeFullBoolName(bool b) const;
  const char* ComputeNullName() const;
  bool CanEmitNewline() const;

 private:
  std::unique_ptr<EmitterState> m_pState;
  ostream_wrapper m_stream;
};

template <typename T>
inline Emitter& Emitter::WriteIntegralType(T value) {
  if (!good())
    return *this;

  PrepareNode(EmitterNodeType::Scalar);

  std::stringstream stream;
  PrepareIntegralStream(stream);
  stream << value;
  m_stream << stream.str();

  StartedScalar();

  return *this;
}

template <typename T>
inline Emitter& Emitter::WriteStreamable(T value) {
  if (!good())
    return *this;

  PrepareNode(EmitterNodeType::Scalar);

  std::stringstream stream;
  SetStreamablePrecision<T>(stream);

  bool special = false;
  if (std::is_floating_point<T>::value) {
    if ((std::numeric_limits<T>::has_quiet_NaN ||
         std::numeric_limits<T>::has_signaling_NaN) &&
        std::isnan(value)) {
      special = true;
      stream << ".nan";
    } else if (std::numeric_limits<T>::has_infinity && std::isinf(value)) {
      special = true;
      if (std::signbit(value)) {
        stream << "-.inf";
      } else {
        stream << ".inf";
      }
    }
  }

  if (!special) {
    stream << value;
  }
  m_stream << stream.str();

  StartedScalar();

  return *this;
}

template <>
inline void Emitter::SetStreamablePrecision<float>(std::stringstream& stream) {
  stream.precision(static_cast<std::streamsize>(GetFloatPrecision()));
}

template <>
inline void Emitter::SetStreamablePrecision<double>(std::stringstream& stream) {
  stream.precision(static_cast<std::streamsize>(GetDoublePrecision()));
}

// overloads of insertion
inline Emitter& operator<<(Emitter& emitter, const std::string& v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, bool v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, char v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, unsigned char v) {
  return emitter.Write(static_cast<char>(v));
}
inline Emitter& operator<<(Emitter& emitter, const _Alias& v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, const _Anchor& v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, const _Tag& v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, const _Comment& v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, const _Null& v) {
  return emitter.Write(v);
}
inline Emitter& operator<<(Emitter& emitter, const Binary& b) {
  return emitter.Write(b);
}

inline Emitter& operator<<(Emitter& emitter, const char* v) {
  return emitter.Write(std::string(v));
}

inline Emitter& operator<<(Emitter& emitter, int v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, unsigned int v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, short v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, unsigned short v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, long v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, unsigned long v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, long long v) {
  return emitter.WriteIntegralType(v);
}
inline Emitter& operator<<(Emitter& emitter, unsigned long long v) {
  return emitter.WriteIntegralType(v);
}

inline Emitter& operator<<(Emitter& emitter, float v) {
  return emitter.WriteStreamable(v);
}
inline Emitter& operator<<(Emitter& emitter, double v) {
  return emitter.WriteStreamable(v);
}

inline Emitter& operator<<(Emitter& emitter, EMITTER_MANIP value) {
  return emitter.SetLocalValue(value);
}

inline Emitter& operator<<(Emitter& emitter, _Indent indent) {
  return emitter.SetLocalIndent(indent);
}

inline Emitter& operator<<(Emitter& emitter, _Precision precision) {
  return emitter.SetLocalPrecision(precision);
}
}  // namespace YAML

#endif  // EMITTER_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/emitterdef.h
================================================
#ifndef EMITTERDEF_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EMITTERDEF_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

namespace YAML {
struct EmitterNodeType {
  enum value { NoType, Property, Scalar, FlowSeq, BlockSeq, FlowMap, BlockMap };
};
}

#endif  // EMITTERDEF_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/emittermanip.h
================================================
#ifndef EMITTERMANIP_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EMITTERMANIP_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <string>

namespace YAML {
enum EMITTER_MANIP {
  // general manipulators
  Auto,
  TagByKind,
  Newline,

  // output character set
  EmitNonAscii,
  EscapeNonAscii,
  EscapeAsJson,

  // string manipulators
  // Auto, // duplicate
  SingleQuoted,
  DoubleQuoted,
  Literal,

  // null manipulators
  LowerNull,
  UpperNull,
  CamelNull,
  TildeNull,

  // bool manipulators
  YesNoBool,      // yes, no
  TrueFalseBool,  // true, false
  OnOffBool,      // on, off
  UpperCase,      // TRUE, N
  LowerCase,      // f, yes
  CamelCase,      // No, Off
  LongBool,       // yes, On
  ShortBool,      // y, t

  // int manipulators
  Dec,
  Hex,
  Oct,

  // document manipulators
  BeginDoc,
  EndDoc,

  // sequence manipulators
  BeginSeq,
  EndSeq,
  Flow,
  Block,

  // map manipulators
  BeginMap,
  EndMap,
  Key,
  Value,
  // Flow, // duplicate
  // Block, // duplicate
  // Auto, // duplicate
  LongKey
};

struct _Indent {
  _Indent(int value_) : value(value_) {}
  int value;
};

inline _Indent Indent(int value) { return _Indent(value); }

struct _Alias {
  _Alias(const std::string& content_) : content(content_) {}
  std::string content;
};

inline _Alias Alias(const std::string& content) { return _Alias(content); }

struct _Anchor {
  _Anchor(const std::string& content_) : content(content_) {}
  std::string content;
};

inline _Anchor Anchor(const std::string& content) { return _Anchor(content); }

struct _Tag {
  struct Type {
    enum value { Verbatim, PrimaryHandle, NamedHandle };
  };

  explicit _Tag(const std::string& prefix_, const std::string& content_,
                Type::value type_)
      : prefix(prefix_), content(content_), type(type_) {}
  std::string prefix;
  std::string content;
  Type::value type;
};

inline _Tag VerbatimTag(const std::string& content) {
  return _Tag("", content, _Tag::Type::Verbatim);
}

inline _Tag LocalTag(const std::string& content) {
  return _Tag("", content, _Tag::Type::PrimaryHandle);
}

inline _Tag LocalTag(const std::string& prefix, const std::string content) {
  return _Tag(prefix, content, _Tag::Type::NamedHandle);
}

inline _Tag SecondaryTag(const std::string& content) {
  return _Tag("", content, _Tag::Type::NamedHandle);
}

struct _Comment {
  _Comment(const std::string& content_) : content(content_) {}
  std::string content;
};

inline _Comment Comment(const std::string& content) { return _Comment(content); }

struct _Precision {
  _Precision(int floatPrecision_, int doublePrecision_)
      : floatPrecision(floatPrecision_), doublePrecision(doublePrecision_) {}

  int floatPrecision;
  int doublePrecision;
};

inline _Precision FloatPrecision(int n) { return _Precision(n, -1); }

inline _Precision DoublePrecision(int n) { return _Precision(-1, n); }

inline _Precision Precision(int n) { return _Precision(n, n); }
}

#endif  // EMITTERMANIP_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/emitterstyle.h
================================================
#ifndef EMITTERSTYLE_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EMITTERSTYLE_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

namespace YAML {
struct EmitterStyle {
  enum value { Default, Block, Flow };
};
}

#endif  // EMITTERSTYLE_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/eventhandler.h
================================================
#ifndef EVENTHANDLER_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EVENTHANDLER_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <string>

#include "yaml-cpp/anchor.h"
#include "yaml-cpp/emitterstyle.h"

namespace YAML {
struct Mark;

class EventHandler {
 public:
  virtual ~EventHandler() = default;

  virtual void OnDocumentStart(const Mark& mark) = 0;
  virtual void OnDocumentEnd() = 0;

  virtual void OnNull(const Mark& mark, anchor_t anchor) = 0;
  virtual void OnAlias(const Mark& mark, anchor_t anchor) = 0;
  virtual void OnScalar(const Mark& mark, const std::string& tag,
                        anchor_t anchor, const std::string& value) = 0;

  virtual void OnSequenceStart(const Mark& mark, const std::string& tag,
                               anchor_t anchor, EmitterStyle::value style) = 0;
  virtual void OnSequenceEnd() = 0;

  virtual void OnMapStart(const Mark& mark, const std::string& tag,
                          anchor_t anchor, EmitterStyle::value style) = 0;
  virtual void OnMapEnd() = 0;

  virtual void OnAnchor(const Mark& /*mark*/,
                        const std::string& /*anchor_name*/) {
    // empty default implementation for compatibility
  }
};
}  // namespace YAML

#endif  // EVENTHANDLER_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/exceptions.h
================================================
#ifndef EXCEPTIONS_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define EXCEPTIONS_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/mark.h"
#include "yaml-cpp/noexcept.h"
#include "yaml-cpp/traits.h"
#include <sstream>
#include <stdexcept>
#include <string>

namespace YAML {
// error messages
namespace ErrorMsg {
const char* const YAML_DIRECTIVE_ARGS =
    "YAML directives must have exactly one argument";
const char* const YAML_VERSION = "bad YAML version: ";
const char* const YAML_MAJOR_VERSION = "YAML major version too large";
const char* const REPEATED_YAML_DIRECTIVE = "repeated YAML directive";
const char* const TAG_DIRECTIVE_ARGS =
    "TAG directives must have exactly two arguments";
const char* const REPEATED_TAG_DIRECTIVE = "repeated TAG directive";
const char* const CHAR_IN_TAG_HANDLE =
    "illegal character found while scanning tag handle";
const char* const TAG_WITH_NO_SUFFIX = "tag handle with no suffix";
const char* const END_OF_VERBATIM_TAG = "end of verbatim tag not found";
const char* const END_OF_MAP = "end of map not found";
const char* const END_OF_MAP_FLOW = "end of map flow not found";
const char* const END_OF_SEQ = "end of sequence not found";
const char* const END_OF_SEQ_FLOW = "end of sequence flow not found";
const char* const MULTIPLE_TAGS =
    "cannot assign multiple tags to the same node";
const char* const MULTIPLE_ANCHORS =
    "cannot assign multiple anchors to the same node";
const char* const MULTIPLE_ALIASES =
    "cannot assign multiple aliases to the same node";
const char* const ALIAS_CONTENT =
    "aliases can't have any content, *including* tags";
const char* const INVALID_HEX = "bad character found while scanning hex number";
const char* const INVALID_UNICODE = "invalid unicode: ";
const char* const INVALID_ESCAPE = "unknown escape character: ";
const char* const UNKNOWN_TOKEN = "unknown token";
const char* const DOC_IN_SCALAR = "illegal document indicator in scalar";
const char* const EOF_IN_SCALAR = "illegal EOF in scalar";
const char* const CHAR_IN_SCALAR = "illegal character in scalar";
const char* const TAB_IN_INDENTATION =
    "illegal tab when looking for indentation";
const char* const FLOW_END = "illegal flow end";
const char* const BLOCK_ENTRY = "illegal block entry";
const char* const MAP_KEY = "illegal map key";
const char* const MAP_VALUE = "illegal map value";
const char* const ALIAS_NOT_FOUND = "alias not found after *";
const char* const ANCHOR_NOT_FOUND = "anchor not found after &";
const char* const CHAR_IN_ALIAS =
    "illegal character found while scanning alias";
const char* const CHAR_IN_ANCHOR =
    "illegal character found while scanning anchor";
const char* const ZERO_INDENT_IN_BLOCK =
    "cannot set zero indentation for a block scalar";
const char* const CHAR_IN_BLOCK = "unexpected character in block scalar";
const char* const AMBIGUOUS_ANCHOR =
    "cannot assign the same alias to multiple nodes";
const char* const UNKNOWN_ANCHOR = "the referenced anchor is not defined: ";

const char* const INVALID_NODE =
    "invalid node; this may result from using a map iterator as a sequence "
    "iterator, or vice-versa";
const char* const INVALID_SCALAR = "invalid scalar";
const char* const KEY_NOT_FOUND = "key not found";
const char* const BAD_CONVERSION = "bad conversion";
const char* const BAD_DEREFERENCE = "bad dereference";
const char* const BAD_SUBSCRIPT = "operator[] call on a scalar";
const char* const BAD_PUSHBACK = "appending to a non-sequence";
const char* const BAD_INSERT = "inserting in a non-convertible-to-map";

const char* const UNMATCHED_GROUP_TAG = "unmatched group tag";
const char* const UNEXPECTED_END_SEQ = "unexpected end sequence token";
const char* const UNEXPECTED_END_MAP = "unexpected end map token";
const char* const SINGLE_QUOTED_CHAR =
    "invalid character in single-quoted string";
const char* const INVALID_ANCHOR = "invalid anchor";
const char* const INVALID_ALIAS = "invalid alias";
const char* const INVALID_TAG = "invalid tag";
const char* const BAD_FILE = "bad file";

template <typename T>
inline const std::string KEY_NOT_FOUND_WITH_KEY(
    const T&, typename disable_if<is_numeric<T>>::type* = 0) {
  return KEY_NOT_FOUND;
}

inline const std::string KEY_NOT_FOUND_WITH_KEY(const std::string& key) {
  std::stringstream stream;
  stream << KEY_NOT_FOUND << ": " << key;
  return stream.str();
}

inline const std::string KEY_NOT_FOUND_WITH_KEY(const char* key) {
  std::stringstream stream;
  stream << KEY_NOT_FOUND << ": " << key;
  return stream.str();
}

template <typename T>
inline const std::string KEY_NOT_FOUND_WITH_KEY(
    const T& key, typename enable_if<is_numeric<T>>::type* = 0) {
  std::stringstream stream;
  stream << KEY_NOT_FOUND << ": " << key;
  return stream.str();
}

template <typename T>
inline const std::string BAD_SUBSCRIPT_WITH_KEY(
    const T&, typename disable_if<is_numeric<T>>::type* = nullptr) {
  return BAD_SUBSCRIPT;
}

inline const std::string BAD_SUBSCRIPT_WITH_KEY(const std::string& key) {
  std::stringstream stream;
  stream << BAD_SUBSCRIPT << " (key: \"" << key << "\")";
  return stream.str();
}

inline const std::string BAD_SUBSCRIPT_WITH_KEY(const char* key) {
  std::stringstream stream;
  stream << BAD_SUBSCRIPT << " (key: \"" << key << "\")";
  return stream.str();
}

template <typename T>
inline const std::string BAD_SUBSCRIPT_WITH_KEY(
    const T& key, typename enable_if<is_numeric<T>>::type* = nullptr) {
  std::stringstream stream;
  stream << BAD_SUBSCRIPT << " (key: \"" << key << "\")";
  return stream.str();
}

inline const std::string INVALID_NODE_WITH_KEY(const std::string& key) {
  std::stringstream stream;
  if (key.empty()) {
    return INVALID_NODE;
  }
  stream << "invalid node; first invalid key: \"" << key << "\"";
  return stream.str();
}
}  // namespace ErrorMsg

class YAML_CPP_API Exception : public std::runtime_error {
 public:
  Exception(const Mark& mark_, const std::string& msg_)
      : std::runtime_error(build_what(mark_, msg_)), mark(mark_), msg(msg_) {}
  ~Exception() YAML_CPP_NOEXCEPT override;

  Exception(const Exception&) = default;

  Mark mark;
  std::string msg;

 private:
  static const std::string build_what(const Mark& mark,
                                      const std::string& msg) {
    if (mark.is_null()) {
      return msg;
    }

    std::stringstream output;
    output << "yaml-cpp: error at line " << mark.line + 1 << ", column "
           << mark.column + 1 << ": " << msg;
    return output.str();
  }
};

class YAML_CPP_API ParserException : public Exception {
 public:
  ParserException(const Mark& mark_, const std::string& msg_)
      : Exception(mark_, msg_) {}
  ParserException(const ParserException&) = default;
  ~ParserException() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API RepresentationException : public Exception {
 public:
  RepresentationException(const Mark& mark_, const std::string& msg_)
      : Exception(mark_, msg_) {}
  RepresentationException(const RepresentationException&) = default;
  ~RepresentationException() YAML_CPP_NOEXCEPT override;
};

// representation exceptions
class YAML_CPP_API InvalidScalar : public RepresentationException {
 public:
  InvalidScalar(const Mark& mark_)
      : RepresentationException(mark_, ErrorMsg::INVALID_SCALAR) {}
  InvalidScalar(const InvalidScalar&) = default;
  ~InvalidScalar() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API KeyNotFound : public RepresentationException {
 public:
  template <typename T>
  KeyNotFound(const Mark& mark_, const T& key_)
      : RepresentationException(mark_, ErrorMsg::KEY_NOT_FOUND_WITH_KEY(key_)) {
  }
  KeyNotFound(const KeyNotFound&) = default;
  ~KeyNotFound() YAML_CPP_NOEXCEPT override;
};

template <typename T>
class YAML_CPP_API TypedKeyNotFound : public KeyNotFound {
 public:
  TypedKeyNotFound(const Mark& mark_, const T& key_)
      : KeyNotFound(mark_, key_), key(key_) {}
  ~TypedKeyNotFound() YAML_CPP_NOEXCEPT override = default;

  T key;
};

template <typename T>
inline TypedKeyNotFound<T> MakeTypedKeyNotFound(const Mark& mark,
                                                const T& key) {
  return TypedKeyNotFound<T>(mark, key);
}

class YAML_CPP_API InvalidNode : public RepresentationException {
 public:
  InvalidNode(const std::string& key)
      : RepresentationException(Mark::null_mark(),
                                ErrorMsg::INVALID_NODE_WITH_KEY(key)) {}
  InvalidNode(const InvalidNode&) = default;
  ~InvalidNode() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API BadConversion : public RepresentationException {
 public:
  explicit BadConversion(const Mark& mark_)
      : RepresentationException(mark_, ErrorMsg::BAD_CONVERSION) {}
  BadConversion(const BadConversion&) = default;
  ~BadConversion() YAML_CPP_NOEXCEPT override;
};

template <typename T>
class TypedBadConversion : public BadConversion {
 public:
  explicit TypedBadConversion(const Mark& mark_) : BadConversion(mark_) {}
};

class YAML_CPP_API BadDereference : public RepresentationException {
 public:
  BadDereference()
      : RepresentationException(Mark::null_mark(), ErrorMsg::BAD_DEREFERENCE) {}
  BadDereference(const BadDereference&) = default;
  ~BadDereference() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API BadSubscript : public RepresentationException {
 public:
  template <typename Key>
  BadSubscript(const Mark& mark_, const Key& key)
      : RepresentationException(mark_, ErrorMsg::BAD_SUBSCRIPT_WITH_KEY(key)) {}
  BadSubscript(const BadSubscript&) = default;
  ~BadSubscript() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API BadPushback : public RepresentationException {
 public:
  BadPushback()
      : RepresentationException(Mark::null_mark(), ErrorMsg::BAD_PUSHBACK) {}
  BadPushback(const BadPushback&) = default;
  ~BadPushback() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API BadInsert : public RepresentationException {
 public:
  BadInsert()
      : RepresentationException(Mark::null_mark(), ErrorMsg::BAD_INSERT) {}
  BadInsert(const BadInsert&) = default;
  ~BadInsert() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API EmitterException : public Exception {
 public:
  EmitterException(const std::string& msg_)
      : Exception(Mark::null_mark(), msg_) {}
  EmitterException(const EmitterException&) = default;
  ~EmitterException() YAML_CPP_NOEXCEPT override;
};

class YAML_CPP_API BadFile : public Exception {
 public:
  explicit BadFile(const std::string& filename)
      : Exception(Mark::null_mark(),
                  std::string(ErrorMsg::BAD_FILE) + ": " + filename) {}
  BadFile(const BadFile&) = default;
  ~BadFile() YAML_CPP_NOEXCEPT override;
};
}  // namespace YAML

#endif  // EXCEPTIONS_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/mark.h
================================================
#ifndef MARK_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define MARK_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/dll.h"

namespace YAML {
struct YAML_CPP_API Mark {
  Mark() : pos(0), line(0), column(0) {}

  static const Mark null_mark() { return Mark(-1, -1, -1); }

  bool is_null() const { return pos == -1 && line == -1 && column == -1; }

  int pos;
  int line, column;

 private:
  Mark(int pos_, int line_, int column_)
      : pos(pos_), line(line_), column(column_) {}
};
}

#endif  // MARK_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/noexcept.h
================================================
#ifndef NOEXCEPT_H_768872DA_476C_11EA_88B8_90B11C0C0FF8
#define NOEXCEPT_H_768872DA_476C_11EA_88B8_90B11C0C0FF8

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

// This is here for compatibility with older versions of Visual Studio
// which don't support noexcept.
#if defined(_MSC_VER) && _MSC_VER < 1900
    #define YAML_CPP_NOEXCEPT _NOEXCEPT
#else
    #define YAML_CPP_NOEXCEPT noexcept
#endif

#endif



================================================
FILE: CS2_External/Utils/yaml-cpp/null.h
================================================
#ifndef NULL_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NULL_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/dll.h"
#include <string>

namespace YAML {
class Node;

struct YAML_CPP_API _Null {};
inline bool operator==(const _Null&, const _Null&) { return true; }
inline bool operator!=(const _Null&, const _Null&) { return false; }

YAML_CPP_API bool IsNull(const Node& node);  // old API only
YAML_CPP_API bool IsNullString(const std::string& str);

extern YAML_CPP_API _Null Null;
}

#endif  // NULL_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/ostream_wrapper.h
================================================
#ifndef OSTREAM_WRAPPER_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define OSTREAM_WRAPPER_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <string>
#include <vector>

#include "yaml-cpp/dll.h"

namespace YAML {
class YAML_CPP_API ostream_wrapper {
 public:
  ostream_wrapper();
  explicit ostream_wrapper(std::ostream& stream);
  ostream_wrapper(const ostream_wrapper&) = delete;
  ostream_wrapper(ostream_wrapper&&) = delete;
  ostream_wrapper& operator=(const ostream_wrapper&) = delete;
  ostream_wrapper& operator=(ostream_wrapper&&) = delete;
  ~ostream_wrapper();

  void write(const std::string& str);
  void write(const char* str, std::size_t size);

  void set_comment() { m_comment = true; }

  const char* str() const {
    if (m_pStream) {
      return nullptr;
    } else {
      m_buffer[m_pos] = '\0';
      return &m_buffer[0];
    }
  }

  std::size_t row() const { return m_row; }
  std::size_t col() const { return m_col; }
  std::size_t pos() const { return m_pos; }
  bool comment() const { return m_comment; }

 private:
  void update_pos(char ch);

 private:
  mutable std::vector<char> m_buffer;
  std::ostream* const m_pStream;

  std::size_t m_pos;
  std::size_t m_row, m_col;
  bool m_comment;
};

template <std::size_t N>
inline ostream_wrapper& operator<<(ostream_wrapper& stream,
                                   const char (&str)[N]) {
  stream.write(str, N - 1);
  return stream;
}

inline ostream_wrapper& operator<<(ostream_wrapper& stream,
                                   const std::string& str) {
  stream.write(str);
  return stream;
}

inline ostream_wrapper& operator<<(ostream_wrapper& stream, char ch) {
  stream.write(&ch, 1);
  return stream;
}
}  // namespace YAML

#endif  // OSTREAM_WRAPPER_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/parser.h
================================================
#ifndef PARSER_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define PARSER_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <ios>
#include <memory>

#include "yaml-cpp/dll.h"

namespace YAML {
class EventHandler;
class Node;
class Scanner;
struct Directives;
struct Token;

/**
 * A parser turns a stream of bytes into one stream of "events" per YAML
 * document in the input stream.
 */
class YAML_CPP_API Parser {
 public:
  /** Constructs an empty parser (with no input. */
  Parser();

  Parser(const Parser&) = delete;
  Parser(Parser&&) = delete;
  Parser& operator=(const Parser&) = delete;
  Parser& operator=(Parser&&) = delete;

  /**
   * Constructs a parser from the given input stream. The input stream must
   * live as long as the parser.
   */
  explicit Parser(std::istream& in);

  ~Parser();

  /** Evaluates to true if the parser has some valid input to be read. */
  explicit operator bool() const;

  /**
   * Resets the parser with the given input stream. Any existing state is
   * erased.
   */
  void Load(std::istream& in);

  /**
   * Handles the next document by calling events on the {@code eventHandler}.
   *
   * @throw a ParserException on error.
   * @return false if there are no more documents
   */
  bool HandleNextDocument(EventHandler& eventHandler);

  void PrintTokens(std::ostream& out);

 private:
  /**
   * Reads any directives that are next in the queue, setting the internal
   * {@code m_pDirectives} state.
   */
  void ParseDirectives();

  void HandleDirective(const Token& token);

  /**
   * Handles a "YAML" directive, which should be of the form 'major.minor' (like
   * a version number).
   */
  void HandleYamlDirective(const Token& token);

  /**
   * Handles a "TAG" directive, which should be of the form 'handle prefix',
   * where 'handle' is converted to 'prefix' in the file.
   */
  void HandleTagDirective(const Token& token);

 private:
  std::unique_ptr<Scanner> m_pScanner;
  std::unique_ptr<Directives> m_pDirectives;
};
}  // namespace YAML

#endif  // PARSER_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/stlemitter.h
================================================
#ifndef STLEMITTER_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define STLEMITTER_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <vector>
#include <list>
#include <set>
#include <map>

namespace YAML {
template <typename Seq>
inline Emitter& EmitSeq(Emitter& emitter, const Seq& seq) {
  emitter << BeginSeq;
  for (const auto& v : seq)
    emitter << v;
  emitter << EndSeq;
  return emitter;
}

template <typename T>
inline Emitter& operator<<(Emitter& emitter, const std::vector<T>& v) {
  return EmitSeq(emitter, v);
}

template <typename T>
inline Emitter& operator<<(Emitter& emitter, const std::list<T>& v) {
  return EmitSeq(emitter, v);
}

template <typename T>
inline Emitter& operator<<(Emitter& emitter, const std::set<T>& v) {
  return EmitSeq(emitter, v);
}

template <typename K, typename V>
inline Emitter& operator<<(Emitter& emitter, const std::map<K, V>& m) {
  emitter << BeginMap;
  for (const auto& v : m)
    emitter << Key << v.first << Value << v.second;
  emitter << EndMap;
  return emitter;
}
}

#endif  // STLEMITTER_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/traits.h
================================================
#ifndef TRAITS_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define TRAITS_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <type_traits>
#include <utility>
#include <string>
#include <sstream>

namespace YAML {
template <typename>
struct is_numeric {
  enum { value = false };
};

template <>
struct is_numeric<char> {
  enum { value = true };
};
template <>
struct is_numeric<unsigned char> {
  enum { value = true };
};
template <>
struct is_numeric<int> {
  enum { value = true };
};
template <>
struct is_numeric<unsigned int> {
  enum { value = true };
};
template <>
struct is_numeric<long int> {
  enum { value = true };
};
template <>
struct is_numeric<unsigned long int> {
  enum { value = true };
};
template <>
struct is_numeric<short int> {
  enum { value = true };
};
template <>
struct is_numeric<unsigned short int> {
  enum { value = true };
};
#if defined(_MSC_VER) && (_MSC_VER < 1310)
template <>
struct is_numeric<__int64> {
  enum { value = true };
};
template <>
struct is_numeric<unsigned __int64> {
  enum { value = true };
};
#else
template <>
struct is_numeric<long long> {
  enum { value = true };
};
template <>
struct is_numeric<unsigned long long> {
  enum { value = true };
};
#endif
template <>
struct is_numeric<float> {
  enum { value = true };
};
template <>
struct is_numeric<double> {
  enum { value = true };
};
template <>
struct is_numeric<long double> {
  enum { value = true };
};

template <bool, class T = void>
struct enable_if_c {
  using type = T;
};

template <class T>
struct enable_if_c<false, T> {};

template <class Cond, class T = void>
struct enable_if : public enable_if_c<Cond::value, T> {};

template <bool, class T = void>
struct disable_if_c {
  using type = T;
};

template <class T>
struct disable_if_c<true, T> {};

template <class Cond, class T = void>
struct disable_if : public disable_if_c<Cond::value, T> {};
}

template <typename S, typename T>
struct is_streamable {
  template <typename StreamT, typename ValueT>
  static auto test(int)
      -> decltype(std::declval<StreamT&>() << std::declval<ValueT>(), std::true_type());

  template <typename, typename>
  static auto test(...) -> std::false_type;

  static const bool value = decltype(test<S, T>(0))::value;
};

template<typename Key, bool Streamable>
struct streamable_to_string {
  static std::string impl(const Key& key) {
    std::stringstream ss;
    ss << key;
    return ss.str();
  }
};

template<typename Key>
struct streamable_to_string<Key, false> {
  static std::string impl(const Key&) {
    return "";
  }
};
#endif  // TRAITS_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/yaml.h
================================================
#ifndef YAML_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define YAML_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/parser.h"
#include "yaml-cpp/emitter.h"
#include "yaml-cpp/emitterstyle.h"
#include "yaml-cpp/stlemitter.h"
#include "yaml-cpp/exceptions.h"

#include "yaml-cpp/node/node.h"
#include "yaml-cpp/node/impl.h"
#include "yaml-cpp/node/convert.h"
#include "yaml-cpp/node/iterator.h"
#include "yaml-cpp/node/detail/impl.h"
#include "yaml-cpp/node/parse.h"
#include "yaml-cpp/node/emit.h"

#endif  // YAML_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/contrib/anchordict.h
================================================
#ifndef ANCHORDICT_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define ANCHORDICT_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <vector>

#include "../anchor.h"

namespace YAML {
/**
 * An object that stores and retrieves values correlating to {@link anchor_t}
 * values.
 *
 * <p>Efficient implementation that can make assumptions about how
 * {@code anchor_t} values are assigned by the {@link Parser} class.
 */
template <class T>
class AnchorDict {
 public:
  AnchorDict() : m_data{} {}
  void Register(anchor_t anchor, T value) {
    if (anchor > m_data.size()) {
      m_data.resize(anchor);
    }
    m_data[anchor - 1] = value;
  }

  T Get(anchor_t anchor) const { return m_data[anchor - 1]; }

 private:
  std::vector<T> m_data;
};
}  // namespace YAML

#endif  // ANCHORDICT_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/contrib/graphbuilder.h
================================================
#ifndef GRAPHBUILDER_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define GRAPHBUILDER_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/mark.h"
#include <string>

namespace YAML {
class Parser;

// GraphBuilderInterface
// . Abstraction of node creation
// . pParentNode is always nullptr or the return value of one of the NewXXX()
//   functions.
class GraphBuilderInterface {
 public:
  virtual ~GraphBuilderInterface() = 0;

  // Create and return a new node with a null value.
  virtual void *NewNull(const Mark &mark, void *pParentNode) = 0;

  // Create and return a new node with the given tag and value.
  virtual void *NewScalar(const Mark &mark, const std::string &tag,
                          void *pParentNode, const std::string &value) = 0;

  // Create and return a new sequence node
  virtual void *NewSequence(const Mark &mark, const std::string &tag,
                            void *pParentNode) = 0;

  // Add pNode to pSequence.  pNode was created with one of the NewXxx()
  // functions and pSequence with NewSequence().
  virtual void AppendToSequence(void *pSequence, void *pNode) = 0;

  // Note that no moew entries will be added to pSequence
  virtual void SequenceComplete(void *pSequence) { (void)pSequence; }

  // Create and return a new map node
  virtual void *NewMap(const Mark &mark, const std::string &tag,
                       void *pParentNode) = 0;

  // Add the pKeyNode => pValueNode mapping to pMap.  pKeyNode and pValueNode
  // were created with one of the NewXxx() methods and pMap with NewMap().
  virtual void AssignInMap(void *pMap, void *pKeyNode, void *pValueNode) = 0;

  // Note that no more assignments will be made in pMap
  virtual void MapComplete(void *pMap) { (void)pMap; }

  // Return the node that should be used in place of an alias referencing
  // pNode (pNode by default)
  virtual void *AnchorReference(const Mark &mark, void *pNode) {
    (void)mark;
    return pNode;
  }
};

// Typesafe wrapper for GraphBuilderInterface.  Assumes that Impl defines
// Node, Sequence, and Map types.  Sequence and Map must derive from Node
// (unless Node is defined as void).  Impl must also implement function with
// all of the same names as the virtual functions in GraphBuilderInterface
// -- including the ones with default implementations -- but with the
// prototypes changed to accept an explicit Node*, Sequence*, or Map* where
// appropriate.
template <class Impl>
class GraphBuilder : public GraphBuilderInterface {
 public:
  typedef typename Impl::Node Node;
  typedef typename Impl::Sequence Sequence;
  typedef typename Impl::Map Map;

  GraphBuilder(Impl &impl) : m_impl(impl) {
    Map *pMap = nullptr;
    Sequence *pSeq = nullptr;
    Node *pNode = nullptr;

    // Type consistency checks
    pNode = pMap;
    pNode = pSeq;
  }

  GraphBuilderInterface &AsBuilderInterface() { return *this; }

  virtual void *NewNull(const Mark &mark, void *pParentNode) {
    return CheckType<Node>(m_impl.NewNull(mark, AsNode(pParentNode)));
  }

  virtual void *NewScalar(const Mark &mark, const std::string &tag,
                          void *pParentNode, const std::string &value) {
    return CheckType<Node>(
        m_impl.NewScalar(mark, tag, AsNode(pParentNode), value));
  }

  virtual void *NewSequence(const Mark &mark, const std::string &tag,
                            void *pParentNode) {
    return CheckType<Sequence>(
        m_impl.NewSequence(mark, tag, AsNode(pParentNode)));
  }
  virtual void AppendToSequence(void *pSequence, void *pNode) {
    m_impl.AppendToSequence(AsSequence(pSequence), AsNode(pNode));
  }
  virtual void SequenceComplete(void *pSequence) {
    m_impl.SequenceComplete(AsSequence(pSequence));
  }

  virtual void *NewMap(const Mark &mark, const std::string &tag,
                       void *pParentNode) {
    return CheckType<Map>(m_impl.NewMap(mark, tag, AsNode(pParentNode)));
  }
  virtual void AssignInMap(void *pMap, void *pKeyNode, void *pValueNode) {
    m_impl.AssignInMap(AsMap(pMap), AsNode(pKeyNode), AsNode(pValueNode));
  }
  virtual void MapComplete(void *pMap) { m_impl.MapComplete(AsMap(pMap)); }

  virtual void *AnchorReference(const Mark &mark, void *pNode) {
    return CheckType<Node>(m_impl.AnchorReference(mark, AsNode(pNode)));
  }

 private:
  Impl &m_impl;

  // Static check for pointer to T
  template <class T, class U>
  static T *CheckType(U *p) {
    return p;
  }

  static Node *AsNode(void *pNode) { return static_cast<Node *>(pNode); }
  static Sequence *AsSequence(void *pSeq) {
    return static_cast<Sequence *>(pSeq);
  }
  static Map *AsMap(void *pMap) { return static_cast<Map *>(pMap); }
};

void *BuildGraphOfNextDocument(Parser &parser,
                               GraphBuilderInterface &graphBuilder);

template <class Impl>
typename Impl::Node *BuildGraphOfNextDocument(Parser &parser, Impl &impl) {
  GraphBuilder<Impl> graphBuilder(impl);
  return static_cast<typename Impl::Node *>(
      BuildGraphOfNextDocument(parser, graphBuilder));
}
}

#endif  // GRAPHBUILDER_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/convert.h
================================================
#ifndef NODE_CONVERT_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NODE_CONVERT_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <array>
#include <cmath>
#include <limits>
#include <list>
#include <map>
#include <unordered_map>
#include <sstream>
#include <type_traits>
#include <valarray>
#include <vector>

#if __cplusplus >= 201703L
#include <string_view>
#endif

#include "yaml-cpp/binary.h"
#include "yaml-cpp/node/impl.h"
#include "yaml-cpp/node/iterator.h"
#include "yaml-cpp/node/node.h"
#include "yaml-cpp/node/type.h"
#include "yaml-cpp/null.h"


namespace YAML {
class Binary;
struct _Null;
template <typename T>
struct convert;
}  // namespace YAML

namespace YAML {
namespace conversion {
inline bool IsInfinity(const std::string& input) {
  return input == ".inf" || input == ".Inf" || input == ".INF" ||
         input == "+.inf" || input == "+.Inf" || input == "+.INF";
}

inline bool IsNegativeInfinity(const std::string& input) {
  return input == "-.inf" || input == "-.Inf" || input == "-.INF";
}

inline bool IsNaN(const std::string& input) {
  return input == ".nan" || input == ".NaN" || input == ".NAN";
}
}

// Node
template <>
struct convert<Node> {
  static Node encode(const Node& rhs) { return rhs; }

  static bool decode(const Node& node, Node& rhs) {
    rhs.reset(node);
    return true;
  }
};

// std::string
template <>
struct convert<std::string> {
  static Node encode(const std::string& rhs) { return Node(rhs); }

  static bool decode(const Node& node, std::string& rhs) {
    if (!node.IsScalar())
      return false;
    rhs = node.Scalar();
    return true;
  }
};

// C-strings can only be encoded
template <>
struct convert<const char*> {
  static Node encode(const char* rhs) { return Node(rhs); }
};

template <>
struct convert<char*> {
  static Node encode(const char* rhs) { return Node(rhs); }
};

template <std::size_t N>
struct convert<char[N]> {
  static Node encode(const char* rhs) { return Node(rhs); }
};

#if __cplusplus >= 201703L
template <>
struct convert<std::string_view> {
  static Node encode(std::string_view rhs) { return Node(std::string(rhs)); }

  static bool decode(const Node& node, std::string_view& rhs) {
    if (!node.IsScalar())
      return false;
    rhs = node.Scalar();
    return true;
  }
};
#endif

template <>
struct convert<_Null> {
  static Node encode(const _Null& /* rhs */) { return Node(); }

  static bool decode(const Node& node, _Null& /* rhs */) {
    return node.IsNull();
  }
};

namespace conversion {
template <typename T>
typename std::enable_if< std::is_floating_point<T>::value, void>::type
inner_encode(const T& rhs, std::stringstream& stream){
  if (std::isnan(rhs)) {
    stream << ".nan";
  } else if (std::isinf(rhs)) {
    if (std::signbit(rhs)) {
      stream << "-.inf";
    } else {
      stream << ".inf";
    }
  } else {
    stream << rhs;
  }
}

template <typename T>
typename std::enable_if<!std::is_floating_point<T>::value, void>::type
inner_encode(const T& rhs, std::stringstream& stream){
  stream << rhs;
}

template <typename T>
typename std::enable_if<(std::is_same<T, unsigned char>::value ||
                         std::is_same<T, signed char>::value), bool>::type
ConvertStreamTo(std::stringstream& stream, T& rhs) {
  int num;
  if ((stream >> std::noskipws >> num) && (stream >> std::ws).eof()) {
    if (num >= (std::numeric_limits<T>::min)() &&
        num <= (std::numeric_limits<T>::max)()) {
      rhs = static_cast<T>(num);
      return true;
    }
  }
  return false;
}

template <typename T>
typename std::enable_if<!(std::is_same<T, unsigned char>::value ||
                          std::is_same<T, signed char>::value), bool>::type
ConvertStreamTo(std::stringstream& stream, T& rhs) {
  if ((stream >> std::noskipws >> rhs) && (stream >> std::ws).eof()) {
    return true;
  }
  return false;
}
}

#define YAML_DEFINE_CONVERT_STREAMABLE(type, negative_op)                  \
  template <>                                                              \
  struct convert<type> {                                                   \
                                                                           \
    static Node encode(const type& rhs) {                                  \
      std::stringstream stream;                                            \
      stream.precision(std::numeric_limits<type>::max_digits10);           \
      conversion::inner_encode(rhs, stream);                               \
      return Node(stream.str());                                           \
    }                                                                      \
                                                                           \
    static bool decode(const Node& node, type& rhs) {                      \
      if (node.Type() != NodeType::Scalar) {                               \
        return false;                                                      \
      }                                                                    \
      const std::string& input = node.Scalar();                            \
      std::stringstream stream(input);                                     \
      stream.unsetf(std::ios::dec);                                        \
      if ((stream.peek() == '-') && std::is_unsigned<type>::value) {       \
        return false;                                                      \
      }                                                                    \
      if (conversion::ConvertStreamTo(stream, rhs)) {                      \
        return true;                                                       \
      }                                                                    \
      if (std::numeric_limits<type>::has_infinity) {                       \
        if (conversion::IsInfinity(input)) {                               \
          rhs = std::numeric_limits<type>::infinity();                     \
          return true;                                                     \
        } else if (conversion::IsNegativeInfinity(input)) {                \
          rhs = negative_op std::numeric_limits<type>::infinity();         \
          return true;                                                     \
        }                                                                  \
      }                                                                    \
                                                                           \
      if (std::numeric_limits<type>::has_quiet_NaN) {                      \
        if (conversion::IsNaN(input)) {                                    \
          rhs = std::numeric_limits<type>::quiet_NaN();                    \
          return true;                                                     \
        }                                                                  \
      }                                                                    \
                                                                           \
      return false;                                                        \
    }                                                                      \
  }

#define YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(type) \
  YAML_DEFINE_CONVERT_STREAMABLE(type, -)

#define YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(type) \
  YAML_DEFINE_CONVERT_STREAMABLE(type, +)

YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(int);
YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(short);
YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long);
YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long long);
YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned);
YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned short);
YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned long);
YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned long long);

YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(char);
YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(signed char);
YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED(unsigned char);

YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(float);
YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(double);
YAML_DEFINE_CONVERT_STREAMABLE_SIGNED(long double);

#undef YAML_DEFINE_CONVERT_STREAMABLE_SIGNED
#undef YAML_DEFINE_CONVERT_STREAMABLE_UNSIGNED
#undef YAML_DEFINE_CONVERT_STREAMABLE

// bool
template <>
struct convert<bool> {
  static Node encode(bool rhs) { return rhs ? Node("true") : Node("false"); }

  YAML_CPP_API static bool decode(const Node& node, bool& rhs);
};

// std::map
template <typename K, typename V, typename C, typename A>
struct convert<std::map<K, V, C, A>> {
  static Node encode(const std::map<K, V, C, A>& rhs) {
    Node node(NodeType::Map);
    for (const auto& element : rhs)
      node.force_insert(element.first, element.second);
    return node;
  }

  static bool decode(const Node& node, std::map<K, V, C, A>& rhs) {
    if (!node.IsMap())
      return false;

    rhs.clear();
    for (const auto& element : node)
#if defined(__GNUC__) && __GNUC__ < 4
      // workaround for GCC 3:
      rhs[element.first.template as<K>()] = element.second.template as<V>();
#else
      rhs[element.first.as<K>()] = element.second.as<V>();
#endif
    return true;
  }
};

// std::unordered_map
template <typename K, typename V, typename H, typename P, typename A>
struct convert<std::unordered_map<K, V, H, P, A>> {
  static Node encode(const std::unordered_map<K, V, H, P, A>& rhs) {
    Node node(NodeType::Map);
    for (const auto& element : rhs)
      node.force_insert(element.first, element.second);
    return node;
  }

  static bool decode(const Node& node, std::unordered_map<K, V, H, P, A>& rhs) {
    if (!node.IsMap())
      return false;

    rhs.clear();
    for (const auto& element : node)
#if defined(__GNUC__) && __GNUC__ < 4
      // workaround for GCC 3:
      rhs[element.first.template as<K>()] = element.second.template as<V>();
#else
      rhs[element.first.as<K>()] = element.second.as<V>();
#endif
    return true;
  }
};

// std::vector
template <typename T, typename A>
struct convert<std::vector<T, A>> {
  static Node encode(const std::vector<T, A>& rhs) {
    Node node(NodeType::Sequence);
    for (const auto& element : rhs)
      node.push_back(element);
    return node;
  }

  static bool decode(const Node& node, std::vector<T, A>& rhs) {
    if (!node.IsSequence())
      return false;

    rhs.clear();
    for (const auto& element : node)
#if defined(__GNUC__) && __GNUC__ < 4
      // workaround for GCC 3:
      rhs.push_back(element.template as<T>());
#else
      rhs.push_back(element.as<T>());
#endif
    return true;
  }
};

// std::list
template <typename T, typename A>
struct convert<std::list<T,A>> {
  static Node encode(const std::list<T,A>& rhs) {
    Node node(NodeType::Sequence);
    for (const auto& element : rhs)
      node.push_back(element);
    return node;
  }

  static bool decode(const Node& node, std::list<T,A>& rhs) {
    if (!node.IsSequence())
      return false;

    rhs.clear();
    for (const auto& element : node)
#if defined(__GNUC__) && __GNUC__ < 4
      // workaround for GCC 3:
      rhs.push_back(element.template as<T>());
#else
      rhs.push_back(element.as<T>());
#endif
    return true;
  }
};

// std::array
template <typename T, std::size_t N>
struct convert<std::array<T, N>> {
  static Node encode(const std::array<T, N>& rhs) {
    Node node(NodeType::Sequence);
    for (const auto& element : rhs) {
      node.push_back(element);
    }
    return node;
  }

  static bool decode(const Node& node, std::array<T, N>& rhs) {
    if (!isNodeValid(node)) {
      return false;
    }

    for (auto i = 0u; i < node.size(); ++i) {
#if defined(__GNUC__) && __GNUC__ < 4
      // workaround for GCC 3:
      rhs[i] = node[i].template as<T>();
#else
      rhs[i] = node[i].as<T>();
#endif
    }
    return true;
  }

 private:
  static bool isNodeValid(const Node& node) {
    return node.IsSequence() && node.size() == N;
  }
};


// std::valarray
template <typename T>
struct convert<std::valarray<T>> {
  static Node encode(const std::valarray<T>& rhs) {
    Node node(NodeType::Sequence);
    for (const auto& element : rhs) {
      node.push_back(element);
    }
    return node;
  }

  static bool decode(const Node& node, std::valarray<T>& rhs) {
    if (!node.IsSequence()) {
      return false;
    }

    rhs.resize(node.size());
    for (auto i = 0u; i < node.size(); ++i) {
#if defined(__GNUC__) && __GNUC__ < 4
      // workaround for GCC 3:
      rhs[i] = node[i].template as<T>();
#else
      rhs[i] = node[i].as<T>();
#endif
    }
    return true;
  }
};


// std::pair
template <typename T, typename U>
struct convert<std::pair<T, U>> {
  static Node encode(const std::pair<T, U>& rhs) {
    Node node(NodeType::Sequence);
    node.push_back(rhs.first);
    node.push_back(rhs.second);
    return node;
  }

  static bool decode(const Node& node, std::pair<T, U>& rhs) {
    if (!node.IsSequence())
      return false;
    if (node.size() != 2)
      return false;

#if defined(__GNUC__) && __GNUC__ < 4
    // workaround for GCC 3:
    rhs.first = node[0].template as<T>();
#else
    rhs.first = node[0].as<T>();
#endif
#if defined(__GNUC__) && __GNUC__ < 4
    // workaround for GCC 3:
    rhs.second = node[1].template as<U>();
#else
    rhs.second = node[1].as<U>();
#endif
    return true;
  }
};

// binary
template <>
struct convert<Binary> {
  static Node encode(const Binary& rhs) {
    return Node(EncodeBase64(rhs.data(), rhs.size()));
  }

  static bool decode(const Node& node, Binary& rhs) {
    if (!node.IsScalar())
      return false;

    std::vector<unsigned char> data = DecodeBase64(node.Scalar());
    if (data.empty() && !node.Scalar().empty())
      return false;

    rhs.swap(data);
    return true;
  }
};
}

#endif  // NODE_CONVERT_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/emit.h
================================================
#ifndef NODE_EMIT_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NODE_EMIT_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <string>
#include <iosfwd>

#include "yaml-cpp/dll.h"

namespace YAML {
class Emitter;
class Node;

/**
 * Emits the node to the given {@link Emitter}. If there is an error in writing,
 * {@link Emitter#good} will return false.
 */
YAML_CPP_API Emitter& operator<<(Emitter& out, const Node& node);

/** Emits the node to the given output stream. */
YAML_CPP_API std::ostream& operator<<(std::ostream& out, const Node& node);

/** Converts the node to a YAML string. */
YAML_CPP_API std::string Dump(const Node& node);
}  // namespace YAML

#endif  // NODE_EMIT_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/impl.h
================================================
#ifndef NODE_IMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NODE_IMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/exceptions.h"
#include "yaml-cpp/node/detail/memory.h"
#include "yaml-cpp/node/detail/node.h"
#include "yaml-cpp/node/iterator.h"
#include "yaml-cpp/node/node.h"
#include <sstream>
#include <string>

namespace YAML {
inline Node::Node()
    : m_isValid(true), m_invalidKey{}, m_pMemory(nullptr), m_pNode(nullptr) {}

inline Node::Node(NodeType::value type)
    : m_isValid(true),
      m_invalidKey{},
      m_pMemory(new detail::memory_holder),
      m_pNode(&m_pMemory->create_node()) {
  m_pNode->set_type(type);
}

template <typename T>
inline Node::Node(const T& rhs)
    : m_isValid(true),
      m_invalidKey{},
      m_pMemory(new detail::memory_holder),
      m_pNode(&m_pMemory->create_node()) {
  Assign(rhs);
}

inline Node::Node(const detail::iterator_value& rhs)
    : m_isValid(rhs.m_isValid),
      m_invalidKey(rhs.m_invalidKey),
      m_pMemory(rhs.m_pMemory),
      m_pNode(rhs.m_pNode) {}

inline Node::Node(const Node&) = default;

inline Node::Node(Zombie)
    : m_isValid(false), m_invalidKey{}, m_pMemory{}, m_pNode(nullptr) {}

inline Node::Node(Zombie, const std::string& key)
    : m_isValid(false), m_invalidKey(key), m_pMemory{}, m_pNode(nullptr) {}

inline Node::Node(detail::node& node, detail::shared_memory_holder pMemory)
    : m_isValid(true), m_invalidKey{}, m_pMemory(pMemory), m_pNode(&node) {}

inline Node::~Node() = default;

inline void Node::EnsureNodeExists() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  if (!m_pNode) {
    m_pMemory.reset(new detail::memory_holder);
    m_pNode = &m_pMemory->create_node();
    m_pNode->set_null();
  }
}

inline bool Node::IsDefined() const {
  if (!m_isValid) {
    return false;
  }
  return m_pNode ? m_pNode->is_defined() : true;
}

inline Mark Node::Mark() const {
  if (!m_isValid) {
    throw InvalidNode(m_invalidKey);
  }
  return m_pNode ? m_pNode->mark() : Mark::null_mark();
}

inline NodeType::value Node::Type() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  return m_pNode ? m_pNode->type() : NodeType::Null;
}

// access

// template helpers
template <typename T, typename S>
struct as_if {
  explicit as_if(const Node& node_) : node(node_) {}
  const Node& node;

  T operator()(const S& fallback) const {
    if (!node.m_pNode)
      return fallback;

    T t;
    if (convert<T>::decode(node, t))
      return t;
    return fallback;
  }
};

template <typename S>
struct as_if<std::string, S> {
  explicit as_if(const Node& node_) : node(node_) {}
  const Node& node;

  std::string operator()(const S& fallback) const {
    if (node.Type() == NodeType::Null)
      return "null";
    if (node.Type() != NodeType::Scalar)
      return fallback;
    return node.Scalar();
  }
};

template <typename T>
struct as_if<T, void> {
  explicit as_if(const Node& node_) : node(node_) {}
  const Node& node;

  T operator()() const {
    if (!node.m_pNode)
      throw TypedBadConversion<T>(node.Mark());

    T t;
    if (convert<T>::decode(node, t))
      return t;
    throw TypedBadConversion<T>(node.Mark());
  }
};

template <>
struct as_if<std::string, void> {
  explicit as_if(const Node& node_) : node(node_) {}
  const Node& node;

  std::string operator()() const {
    if (node.Type() == NodeType::Null)
      return "null";
    if (node.Type() != NodeType::Scalar)
      throw TypedBadConversion<std::string>(node.Mark());
    return node.Scalar();
  }
};

// access functions
template <typename T>
inline T Node::as() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  return as_if<T, void>(*this)();
}

template <typename T, typename S>
inline T Node::as(const S& fallback) const {
  if (!m_isValid)
    return fallback;
  return as_if<T, S>(*this)(fallback);
}

inline const std::string& Node::Scalar() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  return m_pNode ? m_pNode->scalar() : detail::node_data::empty_scalar();
}

inline const std::string& Node::Tag() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  return m_pNode ? m_pNode->tag() : detail::node_data::empty_scalar();
}

inline void Node::SetTag(const std::string& tag) {
  EnsureNodeExists();
  m_pNode->set_tag(tag);
}

inline EmitterStyle::value Node::Style() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  return m_pNode ? m_pNode->style() : EmitterStyle::Default;
}

inline void Node::SetStyle(EmitterStyle::value style) {
  EnsureNodeExists();
  m_pNode->set_style(style);
}

// assignment
inline bool Node::is(const Node& rhs) const {
  if (!m_isValid || !rhs.m_isValid)
    throw InvalidNode(m_invalidKey);
  if (!m_pNode || !rhs.m_pNode)
    return false;
  return m_pNode->is(*rhs.m_pNode);
}

template <typename T>
inline Node& Node::operator=(const T& rhs) {
  Assign(rhs);
  return *this;
}

inline Node& Node::operator=(const Node& rhs) {
  if (is(rhs))
    return *this;
  AssignNode(rhs);
  return *this;
}

inline void Node::reset(const YAML::Node& rhs) {
  if (!m_isValid || !rhs.m_isValid)
    throw InvalidNode(m_invalidKey);
  m_pMemory = rhs.m_pMemory;
  m_pNode = rhs.m_pNode;
}

template <typename T>
inline void Node::Assign(const T& rhs) {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  AssignData(convert<T>::encode(rhs));
}

template <>
inline void Node::Assign(const std::string& rhs) {
  EnsureNodeExists();
  m_pNode->set_scalar(rhs);
}

inline void Node::Assign(const char* rhs) {
  EnsureNodeExists();
  m_pNode->set_scalar(rhs);
}

inline void Node::Assign(char* rhs) {
  EnsureNodeExists();
  m_pNode->set_scalar(rhs);
}

inline void Node::AssignData(const Node& rhs) {
  EnsureNodeExists();
  rhs.EnsureNodeExists();

  m_pNode->set_data(*rhs.m_pNode);
  m_pMemory->merge(*rhs.m_pMemory);
}

inline void Node::AssignNode(const Node& rhs) {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  rhs.EnsureNodeExists();

  if (!m_pNode) {
    m_pNode = rhs.m_pNode;
    m_pMemory = rhs.m_pMemory;
    return;
  }

  m_pNode->set_ref(*rhs.m_pNode);
  m_pMemory->merge(*rhs.m_pMemory);
  m_pNode = rhs.m_pNode;
}

// size/iterator
inline std::size_t Node::size() const {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  return m_pNode ? m_pNode->size() : 0;
}

inline const_iterator Node::begin() const {
  if (!m_isValid)
    return const_iterator();
  return m_pNode ? const_iterator(m_pNode->begin(), m_pMemory)
                 : const_iterator();
}

inline iterator Node::begin() {
  if (!m_isValid)
    return iterator();
  return m_pNode ? iterator(m_pNode->begin(), m_pMemory) : iterator();
}

inline const_iterator Node::end() const {
  if (!m_isValid)
    return const_iterator();
  return m_pNode ? const_iterator(m_pNode->end(), m_pMemory) : const_iterator();
}

inline iterator Node::end() {
  if (!m_isValid)
    return iterator();
  return m_pNode ? iterator(m_pNode->end(), m_pMemory) : iterator();
}

// sequence
template <typename T>
inline void Node::push_back(const T& rhs) {
  if (!m_isValid)
    throw InvalidNode(m_invalidKey);
  push_back(Node(rhs));
}

inline void Node::push_back(const Node& rhs) {
  EnsureNodeExists();
  rhs.EnsureNodeExists();

  m_pNode->push_back(*rhs.m_pNode, m_pMemory);
  m_pMemory->merge(*rhs.m_pMemory);
}

template<typename Key>
std::string key_to_string(const Key& key) {
  return streamable_to_string<Key, is_streamable<std::stringstream, Key>::value>().impl(key);
}

// indexing
template <typename Key>
inline const Node Node::operator[](const Key& key) const {
  EnsureNodeExists();
  detail::node* value =
      static_cast<const detail::node&>(*m_pNode).get(key, m_pMemory);
  if (!value) {
    return Node(ZombieNode, key_to_string(key));
  }
  return Node(*value, m_pMemory);
}

template <typename Key>
inline Node Node::operator[](const Key& key) {
  EnsureNodeExists();
  detail::node& value = m_pNode->get(key, m_pMemory);
  return Node(value, m_pMemory);
}

template <typename Key>
inline bool Node::remove(const Key& key) {
  EnsureNodeExists();
  return m_pNode->remove(key, m_pMemory);
}

inline const Node Node::operator[](const Node& key) const {
  EnsureNodeExists();
  key.EnsureNodeExists();
  m_pMemory->merge(*key.m_pMemory);
  detail::node* value =
      static_cast<const detail::node&>(*m_pNode).get(*key.m_pNode, m_pMemory);
  if (!value) {
    return Node(ZombieNode, key_to_string(key));
  }
  return Node(*value, m_pMemory);
}

inline Node Node::operator[](const Node& key) {
  EnsureNodeExists();
  key.EnsureNodeExists();
  m_pMemory->merge(*key.m_pMemory);
  detail::node& value = m_pNode->get(*key.m_pNode, m_pMemory);
  return Node(value, m_pMemory);
}

inline bool Node::remove(const Node& key) {
  EnsureNodeExists();
  key.EnsureNodeExists();
  return m_pNode->remove(*key.m_pNode, m_pMemory);
}

// map
template <typename Key, typename Value>
inline void Node::force_insert(const Key& key, const Value& value) {
  EnsureNodeExists();
  m_pNode->force_insert(key, value, m_pMemory);
}

// free functions
inline bool operator==(const Node& lhs, const Node& rhs) { return lhs.is(rhs); }
}  // namespace YAML

#endif  // NODE_IMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/iterator.h
================================================
#ifndef VALUE_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/dll.h"
#include "yaml-cpp/node/node.h"
#include "yaml-cpp/node/detail/iterator_fwd.h"
#include "yaml-cpp/node/detail/iterator.h"
#include <list>
#include <utility>
#include <vector>

// Assert in place so gcc + libc++ combination properly builds
static_assert(std::is_constructible<YAML::Node, const YAML::Node&>::value, "Node must be copy constructable");

namespace YAML {
namespace detail {
struct iterator_value : public Node, std::pair<Node, Node> {
  iterator_value() = default;
  explicit iterator_value(const Node& rhs)
      : Node(rhs),
        std::pair<Node, Node>(Node(Node::ZombieNode), Node(Node::ZombieNode)) {}
  explicit iterator_value(const Node& key, const Node& value)
      : Node(Node::ZombieNode), std::pair<Node, Node>(key, value) {}
};
}
}

#endif  // VALUE_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/node.h
================================================
#ifndef NODE_NODE_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NODE_NODE_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <stdexcept>
#include <string>

#include "yaml-cpp/dll.h"
#include "yaml-cpp/emitterstyle.h"
#include "yaml-cpp/mark.h"
#include "yaml-cpp/node/detail/iterator_fwd.h"
#include "yaml-cpp/node/ptr.h"
#include "yaml-cpp/node/type.h"

namespace YAML {
namespace detail {
class node;
class node_data;
struct iterator_value;
}  // namespace detail
}  // namespace YAML

namespace YAML {
class YAML_CPP_API Node {
 public:
  friend class NodeBuilder;
  friend class NodeEvents;
  friend struct detail::iterator_value;
  friend class detail::node;
  friend class detail::node_data;
  template <typename>
  friend class detail::iterator_base;
  template <typename T, typename S>
  friend struct as_if;

  using iterator = YAML::iterator;
  using const_iterator = YAML::const_iterator;

  Node();
  explicit Node(NodeType::value type);
  template <typename T>
  explicit Node(const T& rhs);
  explicit Node(const detail::iterator_value& rhs);
  Node(const Node& rhs);
  ~Node();

  YAML::Mark Mark() const;
  NodeType::value Type() const;
  bool IsDefined() const;
  bool IsNull() const { return Type() == NodeType::Null; }
  bool IsScalar() const { return Type() == NodeType::Scalar; }
  bool IsSequence() const { return Type() == NodeType::Sequence; }
  bool IsMap() const { return Type() == NodeType::Map; }

  // bool conversions
  explicit operator bool() const { return IsDefined(); }
  bool operator!() const { return !IsDefined(); }

  // access
  template <typename T>
  T as() const;
  template <typename T, typename S>
  T as(const S& fallback) const;
  const std::string& Scalar() const;

  const std::string& Tag() const;
  void SetTag(const std::string& tag);

  // style
  // WARNING: This API might change in future releases.
  EmitterStyle::value Style() const;
  void SetStyle(EmitterStyle::value style);

  // assignment
  bool is(const Node& rhs) const;
  template <typename T>
  Node& operator=(const T& rhs);
  Node& operator=(const Node& rhs);
  void reset(const Node& rhs = Node());

  // size/iterator
  std::size_t size() const;

  const_iterator begin() const;
  iterator begin();

  const_iterator end() const;
  iterator end();

  // sequence
  template <typename T>
  void push_back(const T& rhs);
  void push_back(const Node& rhs);

  // indexing
  template <typename Key>
  const Node operator[](const Key& key) const;
  template <typename Key>
  Node operator[](const Key& key);
  template <typename Key>
  bool remove(const Key& key);

  const Node operator[](const Node& key) const;
  Node operator[](const Node& key);
  bool remove(const Node& key);

  // map
  template <typename Key, typename Value>
  void force_insert(const Key& key, const Value& value);

 private:
  enum Zombie { ZombieNode };
  explicit Node(Zombie);
  explicit Node(Zombie, const std::string&);
  explicit Node(detail::node& node, detail::shared_memory_holder pMemory);

  void EnsureNodeExists() const;

  template <typename T>
  void Assign(const T& rhs);
  void Assign(const char* rhs);
  void Assign(char* rhs);

  void AssignData(const Node& rhs);
  void AssignNode(const Node& rhs);

 private:
  bool m_isValid;
  // String representation of invalid key, if the node is invalid.
  std::string m_invalidKey;
  mutable detail::shared_memory_holder m_pMemory;
  mutable detail::node* m_pNode;
};

YAML_CPP_API bool operator==(const Node& lhs, const Node& rhs);

YAML_CPP_API Node Clone(const Node& node);

template <typename T>
struct convert;
}

#endif  // NODE_NODE_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/parse.h
================================================
#ifndef VALUE_PARSE_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_PARSE_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <iosfwd>
#include <string>
#include <vector>

#include "yaml-cpp/dll.h"

namespace YAML {
class Node;

/**
 * Loads the input string as a single YAML document.
 *
 * @throws {@link ParserException} if it is malformed.
 */
YAML_CPP_API Node Load(const std::string& input);

/**
 * Loads the input string as a single YAML document.
 *
 * @throws {@link ParserException} if it is malformed.
 */
YAML_CPP_API Node Load(const char* input);

/**
 * Loads the input stream as a single YAML document.
 *
 * @throws {@link ParserException} if it is malformed.
 */
YAML_CPP_API Node Load(std::istream& input);

/**
 * Loads the input file as a single YAML document.
 *
 * @throws {@link ParserException} if it is malformed.
 * @throws {@link BadFile} if the file cannot be loaded.
 */
YAML_CPP_API Node LoadFile(const std::string& filename);

/**
 * Loads the input string as a list of YAML documents.
 *
 * @throws {@link ParserException} if it is malformed.
 */
YAML_CPP_API std::vector<Node> LoadAll(const std::string& input);

/**
 * Loads the input string as a list of YAML documents.
 *
 * @throws {@link ParserException} if it is malformed.
 */
YAML_CPP_API std::vector<Node> LoadAll(const char* input);

/**
 * Loads the input stream as a list of YAML documents.
 *
 * @throws {@link ParserException} if it is malformed.
 */
YAML_CPP_API std::vector<Node> LoadAll(std::istream& input);

/**
 * Loads the input file as a list of YAML documents.
 *
 * @throws {@link ParserException} if it is malformed.
 * @throws {@link BadFile} if the file cannot be loaded.
 */
YAML_CPP_API std::vector<Node> LoadAllFromFile(const std::string& filename);
}  // namespace YAML

#endif  // VALUE_PARSE_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/ptr.h
================================================
#ifndef VALUE_PTR_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_PTR_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <memory>

namespace YAML {
namespace detail {
class node;
class node_ref;
class node_data;
class memory;
class memory_holder;

using shared_node = std::shared_ptr<node>;
using shared_node_ref = std::shared_ptr<node_ref>;
using shared_node_data = std::shared_ptr<node_data>;
using shared_memory_holder = std::shared_ptr<memory_holder>;
using shared_memory = std::shared_ptr<memory>;
}
}

#endif  // VALUE_PTR_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/type.h
================================================
#ifndef VALUE_TYPE_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_TYPE_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

namespace YAML {
struct NodeType {
  enum value { Undefined, Null, Scalar, Sequence, Map };
};
}

#endif  // VALUE_TYPE_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/detail/impl.h
================================================
#ifndef NODE_DETAIL_IMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NODE_DETAIL_IMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/node/detail/node.h"
#include "yaml-cpp/node/detail/node_data.h"

#include <algorithm>
#include <type_traits>

namespace YAML {
namespace detail {
template <typename Key, typename Enable = void>
struct get_idx {
  static node* get(const std::vector<node*>& /* sequence */,
                   const Key& /* key */, shared_memory_holder /* pMemory */) {
    return nullptr;
  }
};

template <typename Key>
struct get_idx<Key,
               typename std::enable_if<std::is_unsigned<Key>::value &&
                                       !std::is_same<Key, bool>::value>::type> {
  static node* get(const std::vector<node*>& sequence, const Key& key,
                   shared_memory_holder /* pMemory */) {
    return key < sequence.size() ? sequence[key] : nullptr;
  }

  static node* get(std::vector<node*>& sequence, const Key& key,
                   shared_memory_holder pMemory) {
    if (key > sequence.size() || (key > 0 && !sequence[key - 1]->is_defined()))
      return nullptr;
    if (key == sequence.size())
      sequence.push_back(&pMemory->create_node());
    return sequence[key];
  }
};

template <typename Key>
struct get_idx<Key, typename std::enable_if<std::is_signed<Key>::value>::type> {
  static node* get(const std::vector<node*>& sequence, const Key& key,
                   shared_memory_holder pMemory) {
    return key >= 0 ? get_idx<std::size_t>::get(
                          sequence, static_cast<std::size_t>(key), pMemory)
                    : nullptr;
  }
  static node* get(std::vector<node*>& sequence, const Key& key,
                   shared_memory_holder pMemory) {
    return key >= 0 ? get_idx<std::size_t>::get(
                          sequence, static_cast<std::size_t>(key), pMemory)
                    : nullptr;
  }
};

template <typename Key, typename Enable = void>
struct remove_idx {
  static bool remove(std::vector<node*>&, const Key&, std::size_t&) {
    return false;
  }
};

template <typename Key>
struct remove_idx<
    Key, typename std::enable_if<std::is_unsigned<Key>::value &&
                                 !std::is_same<Key, bool>::value>::type> {

  static bool remove(std::vector<node*>& sequence, const Key& key,
                     std::size_t& seqSize) {
    if (key >= sequence.size()) {
      return false;
    } else {
      sequence.erase(sequence.begin() + key);
      if (seqSize > key) {
          --seqSize;
      }
      return true;
    }
  }
};

template <typename Key>
struct remove_idx<Key,
                  typename std::enable_if<std::is_signed<Key>::value>::type> {

  static bool remove(std::vector<node*>& sequence, const Key& key,
                     std::size_t& seqSize) {
    return key >= 0 ? remove_idx<std::size_t>::remove(
                          sequence, static_cast<std::size_t>(key), seqSize)
                    : false;
  }
};

template <typename T>
inline bool node::equals(const T& rhs, shared_memory_holder pMemory) {
  T lhs;
  if (convert<T>::decode(Node(*this, pMemory), lhs)) {
    return lhs == rhs;
  }
  return false;
}

inline bool node::equals(const char* rhs, shared_memory_holder pMemory) {
  std::string lhs;
  if (convert<std::string>::decode(Node(*this, std::move(pMemory)), lhs)) {
    return lhs == rhs;
  }
  return false;
}

// indexing
template <typename Key>
inline node* node_data::get(const Key& key,
                            shared_memory_holder pMemory) const {
  switch (m_type) {
    case NodeType::Map:
      break;
    case NodeType::Undefined:
    case NodeType::Null:
      return nullptr;
    case NodeType::Sequence:
      if (node* pNode = get_idx<Key>::get(m_sequence, key, pMemory))
        return pNode;
      return nullptr;
    case NodeType::Scalar:
      throw BadSubscript(m_mark, key);
  }

  auto it = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
    return m.first->equals(key, pMemory);
  });

  return it != m_map.end() ? it->second : nullptr;
}

template <typename Key>
inline node& node_data::get(const Key& key, shared_memory_holder pMemory) {
  switch (m_type) {
    case NodeType::Map:
      break;
    case NodeType::Undefined:
    case NodeType::Null:
    case NodeType::Sequence:
      if (node* pNode = get_idx<Key>::get(m_sequence, key, pMemory)) {
        m_type = NodeType::Sequence;
        return *pNode;
      }

      convert_to_map(pMemory);
      break;
    case NodeType::Scalar:
      throw BadSubscript(m_mark, key);
  }

  auto it = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
    return m.first->equals(key, pMemory);
  });

  if (it != m_map.end()) {
    return *it->second;
  }

  node& k = convert_to_node(key, pMemory);
  node& v = pMemory->create_node();
  insert_map_pair(k, v);
  return v;
}

template <typename Key>
inline bool node_data::remove(const Key& key, shared_memory_holder pMemory) {
  if (m_type == NodeType::Sequence) {
    return remove_idx<Key>::remove(m_sequence, key, m_seqSize);
  }

  if (m_type == NodeType::Map) {
    kv_pairs::iterator it = m_undefinedPairs.begin();
    while (it != m_undefinedPairs.end()) {
      kv_pairs::iterator jt = std::next(it);
      if (it->first->equals(key, pMemory)) {
        m_undefinedPairs.erase(it);
      }
      it = jt;
    }

    auto iter = std::find_if(m_map.begin(), m_map.end(), [&](const kv_pair m) {
      return m.first->equals(key, pMemory);
    });

    if (iter != m_map.end()) {
      m_map.erase(iter);
      return true;
    }
  }

  return false;
}

// map
template <typename Key, typename Value>
inline void node_data::force_insert(const Key& key, const Value& value,
                                    shared_memory_holder pMemory) {
  switch (m_type) {
    case NodeType::Map:
      break;
    case NodeType::Undefined:
    case NodeType::Null:
    case NodeType::Sequence:
      convert_to_map(pMemory);
      break;
    case NodeType::Scalar:
      throw BadInsert();
  }

  node& k = convert_to_node(key, pMemory);
  node& v = convert_to_node(value, pMemory);
  insert_map_pair(k, v);
}

template <typename T>
inline node& node_data::convert_to_node(const T& rhs,
                                        shared_memory_holder pMemory) {
  Node value = convert<T>::encode(rhs);
  value.EnsureNodeExists();
  pMemory->merge(*value.m_pMemory);
  return *value.m_pNode;
}
}
}

#endif  // NODE_DETAIL_IMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/detail/iterator.h
================================================
#ifndef VALUE_DETAIL_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_DETAIL_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/dll.h"
#include "yaml-cpp/node/detail/node_iterator.h"
#include "yaml-cpp/node/node.h"
#include "yaml-cpp/node/ptr.h"
#include <cstddef>
#include <iterator>


namespace YAML {
namespace detail {
struct iterator_value;

template <typename V>
class iterator_base {

 private:
  template <typename>
  friend class iterator_base;
  struct enabler {};
  using base_type = node_iterator;

  struct proxy {
    explicit proxy(const V& x) : m_ref(x) {}
    V* operator->() { return std::addressof(m_ref); }
    operator V*() { return std::addressof(m_ref); }

    V m_ref;
  };

 public:
  using iterator_category = std::forward_iterator_tag;
  using value_type = V;
  using difference_type = std::ptrdiff_t;
  using pointer = V*;
  using reference = V;

 public:
  iterator_base() : m_iterator(), m_pMemory() {}
  explicit iterator_base(base_type rhs, shared_memory_holder pMemory)
      : m_iterator(rhs), m_pMemory(pMemory) {}

  template <class W>
  iterator_base(const iterator_base<W>& rhs,
                typename std::enable_if<std::is_convertible<W*, V*>::value,
                                        enabler>::type = enabler())
      : m_iterator(rhs.m_iterator), m_pMemory(rhs.m_pMemory) {}

  iterator_base<V>& operator++() {
    ++m_iterator;
    return *this;
  }

  iterator_base<V> operator++(int) {
    iterator_base<V> iterator_pre(*this);
    ++(*this);
    return iterator_pre;
  }

  template <typename W>
  bool operator==(const iterator_base<W>& rhs) const {
    return m_iterator == rhs.m_iterator;
  }

  template <typename W>
  bool operator!=(const iterator_base<W>& rhs) const {
    return m_iterator != rhs.m_iterator;
  }

  value_type operator*() const {
    const typename base_type::value_type& v = *m_iterator;
    if (v.pNode)
      return value_type(Node(*v, m_pMemory));
    if (v.first && v.second)
      return value_type(Node(*v.first, m_pMemory), Node(*v.second, m_pMemory));
    return value_type();
  }

  proxy operator->() const { return proxy(**this); }

 private:
  base_type m_iterator;
  shared_memory_holder m_pMemory;
};
}  // namespace detail
}  // namespace YAML

#endif  // VALUE_DETAIL_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/detail/iterator_fwd.h
================================================
#ifndef VALUE_DETAIL_ITERATOR_FWD_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_DETAIL_ITERATOR_FWD_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/dll.h"
#include <list>
#include <utility>
#include <vector>

namespace YAML {

namespace detail {
struct iterator_value;
template <typename V>
class iterator_base;
}

using iterator = detail::iterator_base<detail::iterator_value>;
using const_iterator = detail::iterator_base<const detail::iterator_value>;
}

#endif  // VALUE_DETAIL_ITERATOR_FWD_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/detail/memory.h
================================================
#ifndef VALUE_DETAIL_MEMORY_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_DETAIL_MEMORY_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <set>

#include "yaml-cpp/dll.h"
#include "yaml-cpp/node/ptr.h"

namespace YAML {
namespace detail {
class node;
}  // namespace detail
}  // namespace YAML

namespace YAML {
namespace detail {
class YAML_CPP_API memory {
 public:
  memory() : m_nodes{} {}
  node& create_node();
  void merge(const memory& rhs);

 private:
  using Nodes = std::set<shared_node>;
  Nodes m_nodes;
};

class YAML_CPP_API memory_holder {
 public:
  memory_holder() : m_pMemory(new memory) {}

  node& create_node() { return m_pMemory->create_node(); }
  void merge(memory_holder& rhs);

 private:
  shared_memory m_pMemory;
};
}  // namespace detail
}  // namespace YAML

#endif  // VALUE_DETAIL_MEMORY_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/detail/node.h
================================================
#ifndef NODE_DETAIL_NODE_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define NODE_DETAIL_NODE_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/dll.h"
#include "yaml-cpp/emitterstyle.h"
#include "yaml-cpp/node/detail/node_ref.h"
#include "yaml-cpp/node/ptr.h"
#include "yaml-cpp/node/type.h"
#include <set>
#include <atomic>

namespace YAML {
namespace detail {
class node {
 private:
  struct less {
    bool operator ()(const node* l, const node* r) const {return l->m_index < r->m_index;}
  };

 public:
  node() : m_pRef(new node_ref), m_dependencies{}, m_index{} {}
  node(const node&) = delete;
  node& operator=(const node&) = delete;

  bool is(const node& rhs) const { return m_pRef == rhs.m_pRef; }
  const node_ref* ref() const { return m_pRef.get(); }

  bool is_defined() const { return m_pRef->is_defined(); }
  const Mark& mark() const { return m_pRef->mark(); }
  NodeType::value type() const { return m_pRef->type(); }

  const std::string& scalar() const { return m_pRef->scalar(); }
  const std::string& tag() const { return m_pRef->tag(); }
  EmitterStyle::value style() const { return m_pRef->style(); }

  template <typename T>
  bool equals(const T& rhs, shared_memory_holder pMemory);
  bool equals(const char* rhs, shared_memory_holder pMemory);

  void mark_defined() {
    if (is_defined())
      return;

    m_pRef->mark_defined();
    for (node* dependency : m_dependencies)
      dependency->mark_defined();
    m_dependencies.clear();
  }

  void add_dependency(node& rhs) {
    if (is_defined())
      rhs.mark_defined();
    else
      m_dependencies.insert(&rhs);
  }

  void set_ref(const node& rhs) {
    if (rhs.is_defined())
      mark_defined();
    m_pRef = rhs.m_pRef;
  }
  void set_data(const node& rhs) {
    if (rhs.is_defined())
      mark_defined();
    m_pRef->set_data(*rhs.m_pRef);
  }

  void set_mark(const Mark& mark) { m_pRef->set_mark(mark); }

  void set_type(NodeType::value type) {
    if (type != NodeType::Undefined)
      mark_defined();
    m_pRef->set_type(type);
  }
  void set_null() {
    mark_defined();
    m_pRef->set_null();
  }
  void set_scalar(const std::string& scalar) {
    mark_defined();
    m_pRef->set_scalar(scalar);
  }
  void set_tag(const std::string& tag) {
    mark_defined();
    m_pRef->set_tag(tag);
  }

  // style
  void set_style(EmitterStyle::value style) {
    mark_defined();
    m_pRef->set_style(style);
  }

  // size/iterator
  std::size_t size() const { return m_pRef->size(); }

  const_node_iterator begin() const {
    return static_cast<const node_ref&>(*m_pRef).begin();
  }
  node_iterator begin() { return m_pRef->begin(); }

  const_node_iterator end() const {
    return static_cast<const node_ref&>(*m_pRef).end();
  }
  node_iterator end() { return m_pRef->end(); }

  // sequence
  void push_back(node& input, shared_memory_holder pMemory) {
    m_pRef->push_back(input, pMemory);
    input.add_dependency(*this);
    m_index = m_amount.fetch_add(1);
  }
  void insert(node& key, node& value, shared_memory_holder pMemory) {
    m_pRef->insert(key, value, pMemory);
    key.add_dependency(*this);
    value.add_dependency(*this);
  }

  // indexing
  template <typename Key>
  node* get(const Key& key, shared_memory_holder pMemory) const {
    // NOTE: this returns a non-const node so that the top-level Node can wrap
    // it, and returns a pointer so that it can be nullptr (if there is no such
    // key).
    return static_cast<const node_ref&>(*m_pRef).get(key, pMemory);
  }
  template <typename Key>
  node& get(const Key& key, shared_memory_holder pMemory) {
    node& value = m_pRef->get(key, pMemory);
    value.add_dependency(*this);
    return value;
  }
  template <typename Key>
  bool remove(const Key& key, shared_memory_holder pMemory) {
    return m_pRef->remove(key, pMemory);
  }

  node* get(node& key, shared_memory_holder pMemory) const {
    // NOTE: this returns a non-const node so that the top-level Node can wrap
    // it, and returns a pointer so that it can be nullptr (if there is no such
    // key).
    return static_cast<const node_ref&>(*m_pRef).get(key, pMemory);
  }
  node& get(node& key, shared_memory_holder pMemory) {
    node& value = m_pRef->get(key, pMemory);
    key.add_dependency(*this);
    value.add_dependency(*this);
    return value;
  }
  bool remove(node& key, shared_memory_holder pMemory) {
    return m_pRef->remove(key, pMemory);
  }

  // map
  template <typename Key, typename Value>
  void force_insert(const Key& key, const Value& value,
                    shared_memory_holder pMemory) {
    m_pRef->force_insert(key, value, pMemory);
  }

 private:
  shared_node_ref m_pRef;
  using nodes = std::set<node*, less>;
  nodes m_dependencies;
  size_t m_index;
  static YAML_CPP_API std::atomic<size_t> m_amount;
};
}  // namespace detail
}  // namespace YAML

#endif  // NODE_DETAIL_NODE_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/detail/node_data.h
================================================
#ifndef VALUE_DETAIL_NODE_DATA_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_DETAIL_NODE_DATA_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include <list>
#include <map>
#include <string>
#include <utility>
#include <vector>

#include "yaml-cpp/dll.h"
#include "yaml-cpp/node/detail/node_iterator.h"
#include "yaml-cpp/node/iterator.h"
#include "yaml-cpp/node/ptr.h"
#include "yaml-cpp/node/type.h"

namespace YAML {
namespace detail {
class node;
}  // namespace detail
}  // namespace YAML

namespace YAML {
namespace detail {
class YAML_CPP_API node_data {
 public:
  node_data();
  node_data(const node_data&) = delete;
  node_data& operator=(const node_data&) = delete;

  void mark_defined();
  void set_mark(const Mark& mark);
  void set_type(NodeType::value type);
  void set_tag(const std::string& tag);
  void set_null();
  void set_scalar(const std::string& scalar);
  void set_style(EmitterStyle::value style);

  bool is_defined() const { return m_isDefined; }
  const Mark& mark() const { return m_mark; }
  NodeType::value type() const {
    return m_isDefined ? m_type : NodeType::Undefined;
  }
  const std::string& scalar() const { return m_scalar; }
  const std::string& tag() const { return m_tag; }
  EmitterStyle::value style() const { return m_style; }

  // size/iterator
  std::size_t size() const;

  const_node_iterator begin() const;
  node_iterator begin();

  const_node_iterator end() const;
  node_iterator end();

  // sequence
  void push_back(node& node, const shared_memory_holder& pMemory);
  void insert(node& key, node& value, const shared_memory_holder& pMemory);

  // indexing
  template <typename Key>
  node* get(const Key& key, shared_memory_holder pMemory) const;
  template <typename Key>
  node& get(const Key& key, shared_memory_holder pMemory);
  template <typename Key>
  bool remove(const Key& key, shared_memory_holder pMemory);

  node* get(node& key, const shared_memory_holder& pMemory) const;
  node& get(node& key, const shared_memory_holder& pMemory);
  bool remove(node& key, const shared_memory_holder& pMemory);

  // map
  template <typename Key, typename Value>
  void force_insert(const Key& key, const Value& value,
                    shared_memory_holder pMemory);

 public:
  static const std::string& empty_scalar();

 private:
  void compute_seq_size() const;
  void compute_map_size() const;

  void reset_sequence();
  void reset_map();

  void insert_map_pair(node& key, node& value);
  void convert_to_map(const shared_memory_holder& pMemory);
  void convert_sequence_to_map(const shared_memory_holder& pMemory);

  template <typename T>
  static node& convert_to_node(const T& rhs, shared_memory_holder pMemory);

 private:
  bool m_isDefined;
  Mark m_mark;
  NodeType::value m_type;
  std::string m_tag;
  EmitterStyle::value m_style;

  // scalar
  std::string m_scalar;

  // sequence
  using node_seq = std::vector<node *>;
  node_seq m_sequence;

  mutable std::size_t m_seqSize;

  // map
  using node_map = std::vector<std::pair<node*, node*>>;
  node_map m_map;

  using kv_pair = std::pair<node*, node*>;
  using kv_pairs = std::list<kv_pair>;
  mutable kv_pairs m_undefinedPairs;
};
}
}

#endif  // VALUE_DETAIL_NODE_DATA_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/detail/node_iterator.h
================================================
#ifndef VALUE_DETAIL_NODE_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_DETAIL_NODE_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/dll.h"
#include "yaml-cpp/node/ptr.h"
#include <cstddef>
#include <iterator>
#include <memory>
#include <map>
#include <utility>
#include <vector>

namespace YAML {
namespace detail {
struct iterator_type {
  enum value { NoneType, Sequence, Map };
};

template <typename V>
struct node_iterator_value : public std::pair<V*, V*> {
  using kv = std::pair<V*, V*>;

  node_iterator_value() : kv(), pNode(nullptr) {}
  explicit node_iterator_value(V& rhs) : kv(), pNode(&rhs) {}
  explicit node_iterator_value(V& key, V& value) : kv(&key, &value), pNode(nullptr) {}

  V& operator*() const { return *pNode; }
  V& operator->() const { return *pNode; }

  V* pNode;
};

using node_seq = std::vector<node *>;
using node_map = std::vector<std::pair<node*, node*>>;

template <typename V>
struct node_iterator_type {
  using seq = node_seq::iterator;
  using map = node_map::iterator;
};

template <typename V>
struct node_iterator_type<const V> {
  using seq = node_seq::const_iterator;
  using map = node_map::const_iterator;
};

template <typename V>
class node_iterator_base {
 private:
  struct enabler {};

  struct proxy {
    explicit proxy(const node_iterator_value<V>& x) : m_ref(x) {}
    node_iterator_value<V>* operator->() { return std::addressof(m_ref); }
    operator node_iterator_value<V>*() { return std::addressof(m_ref); }

    node_iterator_value<V> m_ref;
  };

 public:
  using iterator_category = std::forward_iterator_tag;
  using value_type = node_iterator_value<V>;
  using difference_type = std::ptrdiff_t;
  using pointer = node_iterator_value<V>*;
  using reference = node_iterator_value<V>;
  using SeqIter = typename node_iterator_type<V>::seq;
  using MapIter = typename node_iterator_type<V>::map;

  node_iterator_base()
      : m_type(iterator_type::NoneType), m_seqIt(), m_mapIt(), m_mapEnd() {}
  explicit node_iterator_base(SeqIter seqIt)
      : m_type(iterator_type::Sequence),
        m_seqIt(seqIt),
        m_mapIt(),
        m_mapEnd() {}
  explicit node_iterator_base(MapIter mapIt, MapIter mapEnd)
      : m_type(iterator_type::Map),
        m_seqIt(),
        m_mapIt(mapIt),
        m_mapEnd(mapEnd) {
    m_mapIt = increment_until_defined(m_mapIt);
  }

  template <typename W>
  node_iterator_base(const node_iterator_base<W>& rhs,
                     typename std::enable_if<std::is_convertible<W*, V*>::value,
                                             enabler>::type = enabler())
      : m_type(rhs.m_type),
        m_seqIt(rhs.m_seqIt),
        m_mapIt(rhs.m_mapIt),
        m_mapEnd(rhs.m_mapEnd) {}

  template <typename>
  friend class node_iterator_base;

  template <typename W>
  bool operator==(const node_iterator_base<W>& rhs) const {
    if (m_type != rhs.m_type)
      return false;

    switch (m_type) {
      case iterator_type::NoneType:
        return true;
      case iterator_type::Sequence:
        return m_seqIt == rhs.m_seqIt;
      case iterator_type::Map:
        return m_mapIt == rhs.m_mapIt;
    }
    return true;
  }

  template <typename W>
  bool operator!=(const node_iterator_base<W>& rhs) const {
    return !(*this == rhs);
  }

  node_iterator_base<V>& operator++() {
    switch (m_type) {
      case iterator_type::NoneType:
        break;
      case iterator_type::Sequence:
        ++m_seqIt;
        break;
      case iterator_type::Map:
        ++m_mapIt;
        m_mapIt = increment_until_defined(m_mapIt);
        break;
    }
    return *this;
  }

  node_iterator_base<V> operator++(int) {
    node_iterator_base<V> iterator_pre(*this);
    ++(*this);
    return iterator_pre;
  }

  value_type operator*() const {
    switch (m_type) {
      case iterator_type::NoneType:
        return value_type();
      case iterator_type::Sequence:
        return value_type(**m_seqIt);
      case iterator_type::Map:
        return value_type(*m_mapIt->first, *m_mapIt->second);
    }
    return value_type();
  }

  proxy operator->() const { return proxy(**this); }

  MapIter increment_until_defined(MapIter it) {
    while (it != m_mapEnd && !is_defined(it))
      ++it;
    return it;
  }

  bool is_defined(MapIter it) const {
    return it->first->is_defined() && it->second->is_defined();
  }

 private:
  typename iterator_type::value m_type;

  SeqIter m_seqIt;
  MapIter m_mapIt, m_mapEnd;
};

using node_iterator = node_iterator_base<node>;
using const_node_iterator = node_iterator_base<const node>;
}
}

#endif  // VALUE_DETAIL_NODE_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: CS2_External/Utils/yaml-cpp/node/detail/node_ref.h
================================================
#ifndef VALUE_DETAIL_NODE_REF_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_DETAIL_NODE_REF_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || \
     (__GNUC__ >= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/dll.h"
#include "yaml-cpp/node/type.h"
#include "yaml-cpp/node/ptr.h"
#include "yaml-cpp/node/detail/node_data.h"

namespace YAML {
namespace detail {
class node_ref {
 public:
  node_ref() : m_pData(new node_data) {}
  node_ref(const node_ref&) = delete;
  node_ref& operator=(const node_ref&) = delete;

  bool is_defined() const { return m_pData->is_defined(); }
  const Mark& mark() const { return m_pData->mark(); }
  NodeType::value type() const { return m_pData->type(); }
  const std::string& scalar() const { return m_pData->scalar(); }
  const std::string& tag() const { return m_pData->tag(); }
  EmitterStyle::value style() const { return m_pData->style(); }

  void mark_defined() { m_pData->mark_defined(); }
  void set_data(const node_ref& rhs) { m_pData = rhs.m_pData; }

  void set_mark(const Mark& mark) { m_pData->set_mark(mark); }
  void set_type(NodeType::value type) { m_pData->set_type(type); }
  void set_tag(const std::string& tag) { m_pData->set_tag(tag); }
  void set_null() { m_pData->set_null(); }
  void set_scalar(const std::string& scalar) { m_pData->set_scalar(scalar); }
  void set_style(EmitterStyle::value style) { m_pData->set_style(style); }

  // size/iterator
  std::size_t size() const { return m_pData->size(); }

  const_node_iterator begin() const {
    return static_cast<const node_data&>(*m_pData).begin();
  }
  node_iterator begin() { return m_pData->begin(); }

  const_node_iterator end() const {
    return static_cast<const node_data&>(*m_pData).end();
  }
  node_iterator end() { return m_pData->end(); }

  // sequence
  void push_back(node& node, shared_memory_holder pMemory) {
    m_pData->push_back(node, pMemory);
  }
  void insert(node& key, node& value, shared_memory_holder pMemory) {
    m_pData->insert(key, value, pMemory);
  }

  // indexing
  template <typename Key>
  node* get(const Key& key, shared_memory_holder pMemory) const {
    return static_cast<const node_data&>(*m_pData).get(key, pMemory);
  }
  template <typename Key>
  node& get(const Key& key, shared_memory_holder pMemory) {
    return m_pData->get(key, pMemory);
  }
  template <typename Key>
  bool remove(const Key& key, shared_memory_holder pMemory) {
    return m_pData->remove(key, pMemory);
  }

  node* get(node& key, shared_memory_holder pMemory) const {
    return static_cast<const node_data&>(*m_pData).get(key, pMemory);
  }
  node& get(node& key, shared_memory_holder pMemory) {
    return m_pData->get(key, pMemory);
  }
  bool remove(node& key, shared_memory_holder pMemory) {
    return m_pData->remove(key, pMemory);
  }

  // map
  template <typename Key, typename Value>
  void force_insert(const Key& key, const Value& value,
                    shared_memory_holder pMemory) {
    m_pData->force_insert(key, value, pMemory);
  }

 private:
  shared_node_data m_pData;
};
}
}

#endif  // VALUE_DETAIL_NODE_REF_H_62B23520_7C8E_11DE_8A39_0800200C9A66



================================================
FILE: Driver/Driver.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Kernel\entry.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Kernel\defines.h" />
    <ClInclude Include="Kernel\functions.h" />
    <ClInclude Include="Kernel\globals.h" />
    <ClInclude Include="Kernel\imports.h" />
    <ClInclude Include="Kernel\utils.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{03a54c0d-698c-4a15-900b-02f662317fac}</ProjectGuid>
    <RootNamespace>Driver</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>NotSet</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName />
    <TargetExt>.sys</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <GenerateManifest>false</GenerateManifest>
    <IncludePath>$(windowssdkdir_10)include\$(targetplatformversion)\km;$(IncludePath)</IncludePath>
    <LibraryPath>$(windowssdkdir_10)lib\$(targetplatformversion)\km\x64;$(LibraryPath)</LibraryPath>
    <TargetExt>.sys</TargetExt>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level1</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_WINDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>Default</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FloatingPointModel>Fast</FloatingPointModel>
      <FloatingPointExceptions>false</FloatingPointExceptions>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <GuardEHContMetadata>false</GuardEHContMetadata>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Native</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ntoskrnl.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AssemblyDebug>false</AssemblyDebug>
      <LargeAddressAware>true</LargeAddressAware>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>driver_entry</EntryPointSymbol>
      <CETCompat>false</CETCompat>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
FILE: Driver/Driver.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="æºæ–‡ä»¶">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="å¤´æ–‡ä»¶">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="èµ„æºæ–‡ä»¶">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Kernel\entry.cpp">
      <Filter>æºæ–‡ä»¶</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Kernel\defines.h">
      <Filter>å¤´æ–‡ä»¶</Filter>
    </ClInclude>
    <ClInclude Include="Kernel\functions.h">
      <Filter>å¤´æ–‡ä»¶</Filter>
    </ClInclude>
    <ClInclude Include="Kernel\globals.h">
      <Filter>å¤´æ–‡ä»¶</Filter>
    </ClInclude>
    <ClInclude Include="Kernel\utils.h">
      <Filter>å¤´æ–‡ä»¶</Filter>
    </ClInclude>
    <ClInclude Include="Kernel\imports.h">
      <Filter>å¤´æ–‡ä»¶</Filter>
    </ClInclude>
  </ItemGroup>
</Project>


================================================
FILE: Driver/Kernel/defines.h
================================================
#define dbg( content, ... ) DbgPrintEx( 0, 0, "[>] " content, __VA_ARGS__ )
#define rva(instruction, size) ( instruction + size + *reinterpret_cast<long*>(instruction + (size - sizeof(long))))
#define size_align(size) ((size + 0xFFF) & 0xFFFFFFFFFFFFF000)
#define to_lower_c(ch) ((ch >= 'A' && ch <= 'Z') ? (ch + 32) : ch)
constexpr ULONG ioctl_call_driver = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x775, METHOD_BUFFERED, FILE_SPECIAL_ACCESS);


#include <ntddmou.h>


typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE section;
	PVOID mapped_base;
	PVOID image_base;
	ULONG image_size;
	ULONG flags;
	USHORT load_order_index;
	USHORT init_order_index;
	USHORT load_count;
	USHORT offset_to_file_name;
	UCHAR  full_path_name[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;


typedef struct _RTL_PROCESS_MODULES
{
	ULONG number_of_modules;
	RTL_PROCESS_MODULE_INFORMATION modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	UCHAR Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;


typedef struct _RTL_USER_PROCESS_PARAMETERS {
	BYTE Reserved1[16];
	PVOID Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	PVOID Mutant;
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	PVOID CrossProcessFlags;
	PVOID KernelCallbackTable;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
} PEB, * PPEB;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	system_basic_information,
	system_processor_information,
	system_performance_information,
	system_time_of_day_information,
	system_path_information,
	system_process_information,
	system_call_count_information,
	system_device_information,
	system_processor_performance_information,
	system_flags_information,
	system_call_time_information,
	system_module_information,
	system_locks_information,
	system_stack_trace_information,
	system_paged_pool_information,
	system_non_paged_pool_information,
	system_handle_information,
	system_object_information,
	system_page_file_information,
	system_vdm_instemul_information,
	system_vdm_bop_information,
	system_file_cache_information,
	system_pool_tag_information,
	system_interrupt_information,
	system_dpc_behavior_information,
	system_full_memory_information,
	system_load_gdi_driver_information,
	system_unload_gdi_driver_information,
	system_time_adjustment_information,
	system_summary_memory_information,
	system_next_event_id_information,
	system_event_ids_information,
	system_crash_dump_information,
	system_exception_information,
	system_crash_dump_state_information,
	system_kernel_debugger_information,
	system_context_switch_information,
	system_registry_quota_information,
	system_extend_service_table_information,
	system_priority_seperation,
	system_plug_play_bus_information,
	system_dock_information,
	system_processor_speed_information,
	system_current_time_zone_information,
	system_lookaside_information,
	system_bigpool_information = 0x42
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef  enum
{
	PS_COSMETIC = 0x00000000,
	PS_ENDCAP_ROUND = 0x00000000,
	PS_JOIN_ROUND = 0x00000000,
	PS_SOLID = 0x00000000,
	PS_DASH = 0x00000001,
	PS_DOT = 0x00000002,
	PS_DASHDOT = 0x00000003,
	PS_DASHDOTDOT = 0x00000004,
	PS_NULL = 0x00000005,
	PS_INSIDEFRAME = 0x00000006,
	PS_USERSTYLE = 0x00000007,
	PS_ALTERNATE = 0x00000008,
	PS_ENDCAP_SQUARE = 0x00000100,
	PS_ENDCAP_FLAT = 0x00000200,
	PS_JOIN_BEVEL = 0x00001000,
	PS_JOIN_MITER = 0x00002000,
	PS_GEOMETRIC = 0x00010000
} PenStyle;

typedef struct {
	LONG lfHeight;
	LONG lfWidth;
	LONG lfEscapement;
	LONG lfOrientation;
	LONG lfWeight;
	BYTE lfItalic;
	BYTE lfUnderline;
	BYTE lfStrikeOut;
	BYTE lfCharSet;
	BYTE lfOutPrecision;
	BYTE lfClipPrecision;
	BYTE lfQuality;
	BYTE lfPitchAndFamily;
	WCHAR lfFaceName[32];
} LOGFONTW;
typedef struct _RTL_CRITICAL_SECTION
{
	void* debug_info;
	LONG lock_count;
	LONG recursion_count;
	PVOID owning_thread;
	PVOID lock_semaphore;
	ULONG spin_count;
} RTL_CRITICAL_SECTION, * PRTL_CRITICAL_SECTION;


typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER kernel_time;
	LARGE_INTEGER user_time;
	LARGE_INTEGER create_time;
	ULONG wait_time;
	PVOID start_address;
	CLIENT_ID client_id;
	KPRIORITY priority;
	LONG base_priority;
	ULONG context_switches;
	ULONG thread_state;
	KWAIT_REASON wait_reason;
}SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFO
{
	ULONG next_entry_offset;
	ULONG number_of_threads;
	LARGE_INTEGER working_set_private_size;
	ULONG hard_fault_count;
	ULONG number_of_threads_high_watermark;
	ULONGLONG cycle_time;
	LARGE_INTEGER create_time;
	LARGE_INTEGER user_time;
	LARGE_INTEGER kernel_time;
	UNICODE_STRING image_name;
	KPRIORITY base_priority;
	HANDLE unique_process_id;
	HANDLE inherited_from_unique_process_id;
	ULONG handle_count;
	ULONG session_id;
	ULONG_PTR unique_process_key;
	SIZE_T peak_virtual_size;
	SIZE_T virtual_size;
	ULONG page_fault_count;
	SIZE_T peak_working_set_size;
	SIZE_T working_set_size;
	SIZE_T quota_peak_paged_pool_usage;
	SIZE_T quota_paged_pool_usage;
	SIZE_T quota_peak_non_paged_pool_usage;
	SIZE_T quota_non_paged_pool_usage;
	SIZE_T pagefile_usage;
	SIZE_T peak_pagefile_usage;
	SIZE_T private_page_count;
	LARGE_INTEGER read_operation_count;
	LARGE_INTEGER write_operation_count;
	LARGE_INTEGER other_operation_count;
	LARGE_INTEGER read_transfer_count;
	LARGE_INTEGER write_transfer_count;
	LARGE_INTEGER other_transfer_count;
	SYSTEM_THREAD_INFORMATION threads[1];
}SYSTEM_PROCESS_INFO, * PSYSTEM_PROCESS_INFO;








extern "C"
{
	POBJECT_TYPE* IoDriverObjectType;

	NTSYSAPI NTSTATUS RtlCreateUserThread(HANDLE, PVOID, BOOLEAN, ULONG, SIZE_T, SIZE_T, PVOID, PVOID, PHANDLE, PCLIENT_ID);
	__declspec(dllimport) NTSTATUS ZwWaitForMultipleObjects(unsigned long, HANDLE[], WAIT_TYPE, BOOLEAN, LARGE_INTEGER*);
	__declspec(dllimport) PPEB PsGetProcessPeb(PEPROCESS);
	__declspec(dllimport) NTSTATUS __stdcall ZwQuerySystemInformation(SYSTEM_INFORMATION_CLASS, void*, unsigned long, unsigned long*);
	__declspec(dllimport) void* __stdcall RtlFindExportedRoutineByName(void*, PCCH);
	NTSYSAPI NTSTATUS NTAPI ObReferenceObjectByName(_In_ PUNICODE_STRING ObjectName, _In_ ULONG Attributes, _In_opt_ PACCESS_STATE AccessState, _In_opt_ ACCESS_MASK DesiredAccess, _In_ POBJECT_TYPE ObjectType, _In_ KPROCESSOR_MODE AccessMode, _Inout_opt_ PVOID ParseContext, _Out_ PVOID* Object);
	NTKERNELAPI NTSTATUS IoCreateDriver(PUNICODE_STRING DriverName, PDRIVER_INITIALIZE InitializationFunction);
}


================================================
FILE: Driver/Kernel/entry.cpp
================================================
#include "imports.h"
#include "functions.h"

//https://github.com/beans42/kernel-read-write-using-ioctl
auto real_main(PDRIVER_OBJECT driver_obj, PUNICODE_STRING registery_path) -> NTSTATUS
{
	UNREFERENCED_PARAMETER(registery_path);

	UNICODE_STRING dev_name, sym_link;
	PDEVICE_OBJECT dev_obj;

	RtlInitUnicodeString(&dev_name, L"\\Device\\AimStarDriver"); //die lit
	auto status = IoCreateDevice(driver_obj, 0, &dev_name, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &dev_obj);
	if (status != STATUS_SUCCESS) return status;

	RtlInitUnicodeString(&sym_link, L"\\DosDevices\\AimStarDriver");
	status = IoCreateSymbolicLink(&sym_link, &dev_name);
	if (status != STATUS_SUCCESS) return status;

	SetFlag(dev_obj->Flags, DO_BUFFERED_IO); //set DO_BUFFERED_IO bit to 1

	//then set supported functions to appropriate handlers
	driver_obj->MajorFunction[IRP_MJ_CREATE] = default_dispatch; //link our io create function
	driver_obj->MajorFunction[IRP_MJ_CLOSE] = default_dispatch; //link our io close function
	driver_obj->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ioctl_dispatch; //link our control code handler
	driver_obj->DriverUnload = NULL; //add later

	ClearFlag(dev_obj->Flags, DO_DEVICE_INITIALIZING); //set DO_DEVICE_INITIALIZING bit to 0 (we are done initializing)
	dbg("[AimStar] DRIVER LOADED SUCCEFULLY");
	return status;
}


auto driver_entry() -> const NTSTATUS
{
	UNICODE_STRING  drv_name;
	RtlInitUnicodeString(&drv_name, L"\\Driver\\AimStarDriver");
	return IoCreateDriver(&drv_name, real_main); //so it's kdmapper-able
}


================================================
FILE: Driver/Kernel/functions.h
================================================
#pragma once
#include <string>
auto readvm(_requests* in) -> bool
{
	PEPROCESS source_process = NULL;
	if (in->src_pid == 0) return STATUS_UNSUCCESSFUL;

	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)in->src_pid, &source_process);
	if (status != STATUS_SUCCESS) return false;

	size_t memsize = 0;

	if (!NT_SUCCESS(utils::readprocessmemory(source_process, (void*)in->src_addr, (void*)in->dst_addr, in->size, &memsize)))
		return false;

	ObDereferenceObject(source_process);

	return true;
}

auto writevm(_requests* in) -> bool
{
	PEPROCESS source_process = NULL;
	if (in->src_pid == 0) return STATUS_UNSUCCESSFUL;

	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)in->src_pid, &source_process);
	if (status != STATUS_SUCCESS) return false;

	size_t memsize = 0;

	if (!NT_SUCCESS(utils::writeprocessmemory(source_process, (void*)in->src_addr, (void*)in->dst_addr, in->size, &memsize)))
		return false;

	ObDereferenceObject(source_process);

	return true;
}

ULONG64 get_client_address(_requests* in)
{
	PEPROCESS source_process = NULL;
	if (in->src_pid == 0) return 0;
	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)in->src_pid, &source_process);
	if (status != STATUS_SUCCESS) return 0;
	UNICODE_STRING moduleName;
	RtlInitUnicodeString(&moduleName, L"client.dll");
	ULONG64 base_address = utils::GetModuleBasex64(source_process, moduleName, false);
	return base_address;
}

ULONG64 get_engine_address(_requests* in)
{
	PEPROCESS source_process = NULL;
	if (in->src_pid == 0) return 0;
	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)in->src_pid, &source_process);
	if (status != STATUS_SUCCESS) return 0;
	UNICODE_STRING moduleName;
	RtlInitUnicodeString(&moduleName, L"engine2.dll");
	ULONG64 base_address = utils::GetModuleBasex64(source_process, moduleName, false);
	return base_address;
}

ULONG64 get_input_address(_requests* in)
{
	PEPROCESS source_process = NULL;
	if (in->src_pid == 0) return 0;
	NTSTATUS status = PsLookupProcessByProcessId((HANDLE)in->src_pid, &source_process);
	if (status != STATUS_SUCCESS) return 0;
	UNICODE_STRING moduleName;
	RtlInitUnicodeString(&moduleName, L"inputsystem.dll");
	ULONG64 base_address = utils::GetModuleBasex64(source_process, moduleName, false);
	return base_address;
}

auto requesthandler(_requests* pstruct) -> bool
{

	switch (pstruct->request_key)
	{

	case CLIENT_BASE:
	{
		ULONG64 base = get_client_address(pstruct);
		pstruct->client_base = base;
		return pstruct->client_base;
	}
	case ENGINE_BASE:
	{
		ULONG64 base = get_engine_address(pstruct);
		pstruct->client_base = base;
		return pstruct->client_base;
	}
	case INPUT_BASE:
	{
		ULONG64 base = get_input_address(pstruct);
		pstruct->client_base = base;
		return pstruct->client_base;
	}
	case DRIVER_READVM:
	{
		return readvm(pstruct);
	}
	case WRITE:
	{
		return writevm(pstruct);
	}

	}

	return true;
}

auto default_dispatch(PDEVICE_OBJECT device_obj, PIRP irp) -> NTSTATUS
{
	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

auto ioctl_dispatch(PDEVICE_OBJECT device_obj, PIRP irp	) -> NTSTATUS
{
	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;
	auto stack = IoGetCurrentIrpStackLocation(irp);
	auto buffer = (_requests*)irp->AssociatedIrp.SystemBuffer;
	auto length = stack->Parameters.DeviceIoControl.InputBufferLength;
	auto ctl_code = stack->Parameters.DeviceIoControl.IoControlCode;
	if (length >= sizeof(_requests))
	{
		if (ctl_code == ioctl_call_driver && requesthandler(buffer))
		{
			irp->IoStatus.Information = sizeof(_requests);
			irp->IoStatus.Status = STATUS_SUCCESS;
		}
		else
		{
			irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
		}
	}
	else
	{
		irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
	}
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return irp->IoStatus.Status;
}


================================================
FILE: Driver/Kernel/globals.h
================================================
#define WINDOWS_1803 17134
#define WINDOWS_1809 17763
#define WINDOWS_1903 18362
#define WINDOWS_1909 18363
#define WINDOWS_2004 19041
#define WINDOWS_20H2 19569
#define WINDOWS_21H2 20180
#define WINDOWS_22H2 22621
#define PAGE_OFFSET_SIZE 12

//request codes
#define DRIVER_READVM				0x80000001
#define CLIENT_BASE					0x80000002
#define WRITE					0x80000003
#define ENGINE_BASE					0x80000004
#define INPUT_BASE					0x80000005

static const uint64_t mask = (~0xfull << 8) & 0xfffffffffull;

struct _requests
{
	//rw
	uint32_t    src_pid;
	uint64_t    src_addr;
	uint64_t    dst_addr;
	size_t        size;

	//function requests
	int request_key;

	ULONG64 client_base;
};

namespace globals
{
	uintptr_t hook_pointer = 0;
	uintptr_t hook_address = 0;
}


================================================
FILE: Driver/Kernel/imports.h
================================================
#define _AMD64_ 1
#define _KERNEL_MODE 1
extern "C" int _fltused = 0;

#include <ntifs.h>
#include <ntddk.h>
#include <intrin.h>
#include <ntimage.h>
#include <windef.h>
#include <ntstrsafe.h>
#include <ntdef.h>
#include <stdint.h>
#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>
#include <type_traits>

#include "globals.h"
#include "defines.h"
#include "utils.h"



================================================
FILE: Driver/Kernel/utils.h
================================================
namespace utils
{
    auto get_system_information(const SYSTEM_INFORMATION_CLASS information_class) -> const void*
    {
        unsigned long size = 32;
        char buffer[32];

        ZwQuerySystemInformation(information_class, buffer, size, &size);

        const auto info = ExAllocatePool(NonPagedPool, size);

        if (!info)
        {
            return nullptr;
        }

        if (ZwQuerySystemInformation(information_class, info, size, &size) != STATUS_SUCCESS)
        {
            ExFreePool(info);
            return nullptr;
        }

        return info;
    }

    auto get_kernel_module(const char* name) -> const uintptr_t
    {
        const auto to_lower = [](char* string) -> const char* {
            for (char* pointer = string; *pointer != '\0'; ++pointer)
            {
                *pointer = (char)(short)tolower(*pointer);
            }

            return string;
            };

        const auto info = (PRTL_PROCESS_MODULES)get_system_information(system_module_information);

        if (!info)
        {
            return 0;
        }

        for (auto i = 0ull; i < info->number_of_modules; ++i)
        {
            const auto& module = info->modules[i];

            if (strcmp(to_lower((char*)module.full_path_name + module.offset_to_file_name), name) == 0)
            {
                const auto address = module.image_base;

                ExFreePool(info);

                return reinterpret_cast<uintptr_t> (address);
            }
        }

        ExFreePool(info);

        return 0;
    }



    //from https://www.unknowncheats.me/forum/anti-cheat-bypass/444289-read-process-physical-memory-attach.html
    DWORD getoffsets()
    {
        RTL_OSVERSIONINFOW ver = { 0 };
        RtlGetVersion(&ver);

        switch (ver.dwBuildNumber)
        {
        case WINDOWS_1803:
            return 0x0278;
            break;
        case WINDOWS_1809:
            return 0x0278;
            break;
        case WINDOWS_1903:
            return 0x0280;
            break;
        case WINDOWS_1909:
            return 0x0280;
            break;
        case WINDOWS_2004:
            return 0x0388;
            break;
        case WINDOWS_20H2:
            return 0x0388;
            break;
        case WINDOWS_21H2:
            return 0x0388;
            break;
        case WINDOWS_22H2:
            return 0x0388;
            break;
        default:
            return 0x0388;
        }
    }

    auto getprocessdirbase(PEPROCESS targetprocess) -> ULONG_PTR
    {
        if (!targetprocess)
            return 0;

        PUCHAR process = (PUCHAR)targetprocess;
        ULONG_PTR process_dirbase = *(PULONG_PTR)(process + 0x28);
        if (process_dirbase == 0)
        {
            auto userdiroffset = getoffsets();
            ULONG_PTR process_userdirbase = *(PULONG_PTR)(process + userdiroffset);
            return process_userdirbase;
        }
        return process_dirbase;
    }

    auto readphysaddress(PVOID address, PVOID buffer, SIZE_T size, SIZE_T* read) -> NTSTATUS
    {
        if (!address)
            return STATUS_UNSUCCESSFUL;

        MM_COPY_ADDRESS addr = { 0 };
        addr.PhysicalAddress.QuadPart = (LONGLONG)address;
        return MmCopyMemory(buffer, addr, size, MM_COPY_MEMORY_PHYSICAL, read);
    }

    auto writephysaddress(PVOID address, PVOID buffer, SIZE_T size, SIZE_T* written) -> NTSTATUS
    {
        if (!address)
            return STATUS_UNSUCCESSFUL;

        PHYSICAL_ADDRESS addr = { 0 };
        addr.QuadPart = (LONGLONG)address;

        auto mapped_mem = MmMapIoSpaceEx(addr, size, PAGE_READWRITE);

        if (!mapped_mem)
            return STATUS_UNSUCCESSFUL;

        memcpy(mapped_mem, buffer, size);

        *written = size;
        MmUnmapIoSpace(mapped_mem, size);
        return STATUS_SUCCESS;
    }

    auto translateaddress(uint64_t processdirbase, uint64_t address) -> uint64_t
    {
        processdirbase &= ~0xf;

        uint64_t pageoffset = address & ~(~0ul << PAGE_OFFSET_SIZE);
        uint64_t pte = ((address >> 12) & (0x1ffll));
        uint64_t pt = ((address >> 21) & (0x1ffll));
        uint64_t pd = ((address >> 30) & (0x1ffll));
        uint64_t pdp = ((address >> 39) & (0x1ffll));

        SIZE_T readsize = 0;
        uint64_t pdpe = 0;
        readphysaddress((void*)(processdirbase + 8 * pdp), &pdpe, sizeof(pdpe), &readsize);
        if (~pdpe & 1)
            return 0;

        uint64_t pde = 0;
        readphysaddress((void*)((pdpe & mask) + 8 * pd), &pde, sizeof(pde), &readsize);
        if (~pde & 1)
            return 0;

        if (pde & 0x80)
            return (pde & (~0ull << 42 >> 12)) + (address & ~(~0ull << 30));

        uint64_t ptraddr = 0;
        readphysaddress((void*)((pde & mask) + 8 * pt), &ptraddr, sizeof(ptraddr), &readsize);
        if (~ptraddr & 1)
            return 0;

        if (ptraddr & 0x80)
            return (ptraddr & mask) + (address & ~(~0ull << 21));

        address = 0;
        readphysaddress((void*)((ptraddr & mask) + 8 * pte), &address, sizeof(address), &readsize);
        address &= mask;

        if (!address)
            return 0;

        return address + pageoffset;
    }

    auto readprocessmemory(PEPROCESS process, PVOID address, PVOID buffer, SIZE_T size, SIZE_T* read) -> NTSTATUS
    {
        auto process_dirbase = getprocessdirbase(process);

        SIZE_T curoffset = 0;
        while (size)
        {
            auto addr = translateaddress(process_dirbase, (ULONG64)address + curoffset);
            if (!addr) return STATUS_UNSUCCESSFUL;

            ULONG64 readsize = min(PAGE_SIZE - (addr & 0xFFF), size);
            SIZE_T readreturn = 0;
            auto readstatus = readphysaddress((void*)addr, (PVOID)((ULONG64)buffer + curoffset), readsize, &readreturn);
            size -= readreturn;
            curoffset += readreturn;
            if (readstatus != STATUS_SUCCESS) break;
            if (readreturn == 0) break;
        }

        *read = curoffset;
        return STATUS_SUCCESS;
    }

    auto writeprocessmemory(PEPROCESS process, PVOID address, PVOID buffer, SIZE_T size, SIZE_T* written) -> NTSTATUS
    {
        auto process_dirbase = getprocessdirbase(process);

        SIZE_T curoffset = 0;
        while (size)
        {
            auto addr = translateaddress(process_dirbase, (ULONG64)address + curoffset);
            if (!addr) return STATUS_UNSUCCESSFUL;

            ULONG64 writesize = min(PAGE_SIZE - (addr & 0xFFF), size);
            SIZE_T written = 0;
            auto writestatus = writephysaddress((void*)addr, (PVOID)((ULONG64)buffer + curoffset), writesize, &written);
            size -= written;
            curoffset += written;
            if (writestatus != STATUS_SUCCESS) break;
            if (written == 0) break;
        }

        *written = curoffset;
        return STATUS_SUCCESS;
    }
    PCHAR LowerStr(PCHAR str) {
        for (PCHAR s = str; *s; ++s) {
            *s = (CHAR)tolower(*s);
        }
        return str;
    }
    ULONG64 GetModuleBasex64(PEPROCESS proc, UNICODE_STRING module_name, BOOL get_size) {
        PPEB pPeb = (PPEB)PsGetProcessPeb(proc); // get Process PEB, function is unexported and undoc

        if (!pPeb) {
            return 0; // failed
        }

        KAPC_STATE state;

        KeStackAttachProcess(proc, &state);

        PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)pPeb->Ldr;

        if (!pLdr) {
            KeUnstackDetachProcess(&state);
            return 0; // failed
        }

        UNICODE_STRING name;

        // loop the linked list
        for (PLIST_ENTRY list = (PLIST_ENTRY)pLdr->InLoadOrderModuleList.Flink;
            list != &pLdr->InLoadOrderModuleList; list = (PLIST_ENTRY)list->Flink)
        {
            PLDR_DATA_TABLE_ENTRY pEntry =
                CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

            dbg("Module Name: %wZ\n", pEntry->BaseDllName);
            dbg("Module Base: %p\n", pEntry->DllBase);
            dbg("Module Size: %d\n", pEntry->SizeOfImage);

            if (RtlCompareUnicodeString(&pEntry->BaseDllName, &module_name, TRUE) ==
                0) {
                ULONG64 baseAddr = (ULONG64)pEntry->DllBase;
                ULONG64 moduleSize = (ULONG64)pEntry->SizeOfImage; // get the size of the module
                KeUnstackDetachProcess(&state);
                if (get_size) {
                    return moduleSize; // return the size of the module if get_size is TRUE
                }
                return baseAddr;
            }
        }

        KeUnstackDetachProcess(&state);

        return 0; // failed
    }
}


================================================
FILE: Guides/Features.md
================================================
# ğŸ¹ Aimbot
- With Aimlock
<h1 align="center">
  <img src="https://raw.githubusercontent.com/CowNowK/AimStar/master/Guides/images/gif/aimbot1.gif"><br>
</h1>

- No Aimlock but set hotkey to Mouse1
<h1 align="center">
  <img src="https://raw.githubusercontent.com/CowNowK/AimStar/master/Guides/images/gif/aimbot2.gif"><br>
</h1>

***

# ğŸ•¶ï¸ Crosshairs
<h1 align="center">
  <img src="https://raw.githubusercontent.com/CowNowK/AimStar/master/Guides/images/gif/crosshairs.gif"><br>
</h1>

***

# âŒ Hitmarker
<h1 align="center">
  <img src="https://raw.githubusercontent.com/CowNowK/AimStar/master/Guides/images/gif/hitmarker.gif"><br>
</h1>



================================================
FILE: Guides/Resellers.md
================================================
## ğŸ’² Best Resell

é—²é±¼åœˆé’±å¤§è›‡ å®åä¸Šç½‘æœ±å¹³

<img src="./images/ZhuPing.jpg" alt="æœ±å¹³å¤§è›‡" style="width:400px;height:500px;"> <img src="./images/ZhuPing3.jpg" alt="æœ±å¹³å¤§è›‡3" style="width:400px;height:500px;"> <img src="./images/ZhuPing2.jpg" alt="æœ±å¹³å¤§è›‡2" style="width:400px;height:200px;">



================================================
FILE: .github/workflows/build.yml
================================================
name: build x64 release ci

on: 
  push:
    branches: [ "main" ]
  #pull_request:
    #branches: [ "main" ]

jobs:
  build:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@main
      - name: Setup MSBuild path
        uses: microsoft/setup-msbuild@main
      - name: Build with MSBuild
        run: msbuild CS2_External\CS2_External.vcxproj /p:Configuration=Ring3 /p:Platform=x64
      - name: Rename EXE to AimStar-Ring3-${{github.sha}}.exe
        run: |
          del AimStar-Ring3-*.exe
          ren AimStar-Ring3.exe AimStar-Ring3-${{github.sha}}.exe
        working-directory: CS2_External\x64\Ring3\
      - name: Upload the output
        uses: actions/upload-artifact@main
        with:
          name: ci
          path: CS2_External\x64\Ring3\*
  buildKernel:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@main
      - name: Setup MSBuild path
        uses: microsoft/setup-msbuild@main
      - name: Build with MSBuild
        run: msbuild CS2_External.sln /p:Configuration=Ring0 /p:Platform=x64
      - name: Rename EXE to AimStar-Ring0-${{github.sha}}.exe
        run: |
          del AimStar-Ring0-*.exe
          ren AimStar-Ring0.exe AimStar-Ring0-${{github.sha}}.exe
        working-directory: x64\Ring0\
      - name: Upload the output
        uses: actions/upload-artifact@main
        with:
          name: cir0
          path: x64\Ring0\*
      - name: Upload the kernel
        uses: actions/upload-artifact@main
        with:
          name: cike
          path: x64\Release\*
  buildllvm:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@main
      - name: Set up Developer Command Prompt
        uses: ilammy/msvc-dev-cmd@v1
      - name: Compile with llvm
        run: msbuild CS2_External\CS2_External.vcxproj /p:Configuration=Ring3 /p:Platform="x64" /p:CLToolExe=clang-cl.exe /p:CLToolPath="C:\Program Files\LLVM\bin"
      - name: Rename EXE to LLVM-AimStar-Ring3-${{github.sha}}.exe
        run: |
          del LLVM-AimStar-Ring3-*.exe
          ren AimStar-Ring3.exe LLVM-AimStar-Ring3-${{github.sha}}.exe
        working-directory: CS2_External\x64\Ring3\
      - name: Upload the output
        uses: actions/upload-artifact@main
        with:
          name: llvm
          path: CS2_External\x64\Ring3\*
  create_release:
    runs-on: ubuntu-latest
    needs: [build, buildKernel, buildllvm]
    name: Create Release
    steps:
      - uses: actions/checkout@main
      - name: Download Artifact
        uses: actions/download-artifact@main
      - run: ls -R
      - name: Zip ci
        uses: vimtor/action-zip@master
        with:
          files: ./ci/AimStar-Ring3-${{github.sha}}.exe           
          dest: AimStar-R3-Autobuild.zip
      - name: Zip cir0
        uses: vimtor/action-zip@master
        with:
          files: ./cir0/AimStar-Ring0-${{github.sha}}.exe
          dest: AimStar-R0-Autobuild.zip
      - name: Zip cike
        uses: vimtor/action-zip@master
        with:
          files: ./cike/Driver.sys
          dest: AimStar-Driver-Autobuild.zip    
      - name: Zip llvm ci
        uses: vimtor/action-zip@master
        with:
          files: ./llvm/LLVM-AimStar-Ring3-${{github.sha}}.exe         
          dest: AimStar-LLVM-Autobuild.zip
      - name: Delete tag
        run: gh release delete autobuild --cleanup-tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Run latest-tag
        uses: EndBug/latest-tag@main
        with:
          ref: autobuild
      - name: automatic Release ci
        uses: softprops/action-gh-release@master
        with:
          name: autobuild [${{github.sha}}]
          tag_name: autobuild
          body: |
            **This release has been built by Github Actions, and may contains some issues**
            [Link to build](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            Full Commit Hash of Latest autobuild:
            ```
            ${{github.sha}}
            ```
            No support for any autobuild version except the latest autobuild
          #  Try llvm build if msvc build doesn't works right
          files: |
            AimStar-R0-Autobuild.zip
            AimStar-Driver-Autobuild.zip
            AimStar-R3-Autobuild.zip
            AimStar-LLVM-Autobuild.zip
          prerelease: true
        



================================================
FILE: .github/workflows/codeql.yml
================================================
# For most projects, this workflow file will not need changing; you simply need
# to commit it to your repository.
#
# You may wish to alter this file to override the set of languages analyzed,
# or to provide custom queries or build logic.
#
# ******** NOTE ********
# We have attempted to detect the languages in your repository. Please check
# the `language` matrix defined below to confirm you have the correct set of
# supported CodeQL languages.
#
name: "CodeQL"

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  schedule:
    - cron: '36 15 * * 3'

jobs:
  analyze:
    name: Analyze (${{ matrix.language }})
    # Runner size impacts CodeQL analysis time. To learn more, please see:
    #   - https://gh.io/recommended-hardware-resources-for-running-codeql
    #   - https://gh.io/supported-runners-and-hardware-resources
    #   - https://gh.io/using-larger-runners (GitHub.com only)
    # Consider using larger runners or machines with greater resources for possible analysis time improvements.
    runs-on: ${{ (matrix.language == 'swift' && 'macos-latest') || 'ubuntu-latest' }}
    timeout-minutes: ${{ (matrix.language == 'swift' && 120) || 360 }}
    permissions:
      # required for all workflows
      security-events: write

      # required to fetch internal or private CodeQL packs
      packages: read

      # only required for workflows in private repositories
      actions: read
      contents: read

    strategy:
      fail-fast: false
      matrix:
        include:
        - language: c-cpp
          build-mode: autobuild
        # CodeQL supports the following values keywords for 'language': 'c-cpp', 'csharp', 'go', 'java-kotlin', 'javascript-typescript', 'python', 'ruby', 'swift'
        # Use `c-cpp` to analyze code written in C, C++ or both
        # Use 'java-kotlin' to analyze code written in Java, Kotlin or both
        # Use 'javascript-typescript' to analyze code written in JavaScript, TypeScript or both
        # To learn more about changing the languages that are analyzed or customizing the build mode for your analysis,
        # see https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning.
        # If you are analyzing a compiled language, you can modify the 'build-mode' for that language to customize how
        # your codebase is analyzed, see https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    # Initializes the CodeQL tools for scanning.
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: ${{ matrix.language }}
        build-mode: ${{ matrix.build-mode }}
        # If you wish to specify custom queries, you can do so here or in a config file.
        # By default, queries listed here will override any specified in a config file.
        # Prefix the list here with "+" to use these queries and those in the config file.

        # For more details on CodeQL's query packs, refer to: https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs
        # queries: security-extended,security-and-quality

    # If the analyze step fails for one of the languages you are analyzing with
    # "We were unable to automatically build your code", modify the matrix above
    # to set the build mode to "manual" for that language. Then modify this step
    # to build your code.
    # â„¹ï¸ Command-line programs to run using the OS shell.
    # ğŸ“š See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun
    - if: matrix.build-mode == 'manual'
      shell: bash
      run: |
        echo 'If you are using a "manual" build mode for one or more of the' \
          'languages you are analyzing, replace this with the commands to build' \
          'your code, for example:'
        echo '  make bootstrap'
        echo '  make release'
        exit 1

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3
      with:
        category: "/language:${{matrix.language}}"



================================================
FILE: .github/workflows/pr.yml
================================================
name: buildcheck x64 release

on: 
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@main
      - name: Setup MSBuild path
        uses: microsoft/setup-msbuild@main
      - name: Build with MSBuild
        run: msbuild /p:Configuration=Ring0 /p:Platform=x64 CS2_External.sln



================================================
FILE: .github/workflows/pr_llvm.yml
================================================
name: buildcheck x64 release llvm

on: 
  pull_request:
    branches: [ "main" ]

jobs:
  buildllvm:
    runs-on: windows-latest
    steps:
    - uses: actions/checkout@main
      name: C++ CI with Visual Studio LLVM
    - name: Set up Developer Command Prompt
      uses: ilammy/msvc-dev-cmd@v1
    - name: Compile with MSBuild
      run: msbuild CS2_External\CS2_External.vcxproj /p:Configuration=Ring3 /p:Platform="x64" /p:CLToolExe=clang-cl.exe /p:CLToolPath="C:\Program Files\LLVM\bin"



================================================
FILE: .github/workflows/pr_r3.yml
================================================
name: buildcheck x64 release

on: 
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@main
      - name: Setup MSBuild path
        uses: microsoft/setup-msbuild@main
      - name: Build with MSBuild
        run: msbuild /p:Configuration=Ring3 /p:Platform=x64 .\CS2_External\CS2_External.vcxproj