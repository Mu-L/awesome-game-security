Project Path: arc_lzghzr_APatch_kpm_b_u8j7ae

Source Tree:

```txt
arc_lzghzr_APatch_kpm_b_u8j7ae
├── KernelPatch
├── LICENSE
├── README.md
├── cgroupv2_freeze
│   ├── Makefile
│   ├── README.md
│   ├── cfv2_offsets.c
│   ├── cfv2_utils.h
│   ├── cgroupv2_freeze.c
│   └── cgroupv2_freeze.h
├── dont_kill_freeze
│   ├── Makefile
│   ├── README.md
│   ├── dont_kill_freeze.c
│   └── dont_kill_freeze.h
├── hosts_redirect
│   ├── Makefile
│   ├── README.md
│   ├── hosts_redirect.c
│   ├── hosts_redirect.h
│   └── hr_utils.h
├── kpm_utils.h
├── lmkd_dont_kill
│   ├── Makefile
│   ├── README.md
│   ├── archive
│   ├── lmkd_dont_kill.c
│   └── lmkd_dont_kill.h
├── qti_battery_charger
│   ├── Makefile
│   ├── battchg.h
│   ├── qbc_utils.h
│   └── qti_battery_charger.c
├── re_kernel
│   ├── Makefile
│   ├── README.md
│   ├── re_kernel.c
│   ├── re_kernel.h
│   ├── re_offsets.c
│   ├── re_utils.h
│   └── re_vmlinux.c
└── xperia_ii_battery_age
    ├── Makefile
    ├── xiiba_utils.h
    └── xperia_ii_battery_age.c

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

```

`README.md`:

```md
### 所有模块均为个人使用，未对所有设备进行适配，因使用模块造成的任何损失，本人概不负责

如果使用中遇到BUG需要反馈, 请使用 [debug版](https://github.com/lzghzr/APatch_kpm/releases/tag/1.0.0) 模块, 并提供Apatch日志

```

`cgroupv2_freeze/Makefile`:

```
MYKPM_VERSION := 1.0.12

ifndef KP_DIR
    KP_DIR = ../KernelPatch
endif

OS_NAME = $(shell uname | tr A-Z a-z)
MACHINE = $(shell uname -m)
HOST_TAG = $(OS_NAME)-$(MACHINE)
ifeq ($(HOST_TAG), darwin-arm64)
    HOST_TAG = darwin-x86_64
endif
NDK_BIN_DIR := toolchains/llvm/prebuilt/$(HOST_TAG)/bin
ifdef ANDROID_NDK_LATEST_HOME
    NDK_PATH ?= $(ANDROID_NDK_LATEST_HOME)/$(NDK_BIN_DIR)
else ifdef ANDROID_NDK
    NDK_PATH ?= $(ANDROID_NDK)/$(NDK_BIN_DIR)
endif

ifdef TARGET_COMPILE
    CC := $(TARGET_COMPILE)gcc
    LD := $(TARGET_COMPILE)ld
else ifdef NDK_PATH
    CC := $(NDK_PATH)/aarch64-linux-android31-clang
    LD := $(NDK_PATH)/ld.lld
endif

CFLAGS = -Wall -O2 -fno-PIC -fno-asynchronous-unwind-tables -fno-stack-protector -fno-common -DMYKPM_VERSION=\"$(MYKPM_VERSION)$(MYKPM_VER)\"

INCLUDE_DIRS := . include patch/include linux/include linux/arch/arm64/include linux/tools/arch/arm64/include

INCLUDE_FLAGS := $(foreach dir,$(INCLUDE_DIRS),-I$(KP_DIR)/kernel/$(dir))

objs := cgroupv2_freeze.c

all: base

base: cgroupv2_freeze_$(MYKPM_VERSION).kpm

debug: CFLAGS += -DCONFIG_DEBUG
debug: MYKPM_VER := _d
debug: cgroupv2_freeze_$(MYKPM_VERSION)_debug.kpm

cgroupv2_freeze_$(MYKPM_VERSION).kpm: ${objs}
	${CC} $(CFLAGS) $(CFLAG) $(INCLUDE_FLAGS) $^ -r -o $@

cgroupv2_freeze_$(MYKPM_VERSION)_debug.kpm: ${objs}
	${CC} $(CFLAGS) $(CFLAG) $(INCLUDE_FLAGS) $^ -r -o $@

.PHONY: clean
clean:
	rm -rf *.kpm
	find . -name "*.o" | xargs rm -f

```

`cgroupv2_freeze/README.md`:

```md
# cgroupv2_freeze
## 模块作用
为低版本内核添加 cgroup.freeze

## 更新记录
### 1.0.12
适配更多内核
### 1.0.11
适配更多内核<br />
优化挂载脚本
### 1.0.10
优化 `MIUI` 内核
### 1.0.9
v2 检测函数由 `do_freezer_trap` 改为 `cgroup_freeze_write`
### 1.0.8
修复冻结失效
### 1.0.7
临时 hook `call_usermodehelper_exec`
### 1.0.6
为高版本内核禁用 `CONFIG_STATIC_USERMODEHELPER`
### 1.0.5
补全uid模式<br />
不再需要附加模块
### 1.0.4
使用其他方式替代所有内核版本判断条件<br />
变更 task_struct->jobctl 获取方式
### 1.0.3
支持 4.19
### 1.0.2
支持 4.9
### 1.0.1
不再修改内核配置文件

```

`cgroupv2_freeze/cfv2_offsets.c`:

```c
// task_state_ptr
static inline volatile long *task_state_ptr(struct task_struct *task) {
  volatile long *state = (volatile long *)((uintptr_t)task + struct_offset.task_struct_state);
  return state;
}
// task_flags
static inline unsigned int task_flags(struct task_struct *task) {
  unsigned int flags = *(unsigned int *)((uintptr_t)task + struct_offset.task_struct_flags);
  return flags;
}
// task_flags_ptr
static inline unsigned int *task_flags_ptr(struct task_struct *task) {
  unsigned int *flags = (unsigned int *)((uintptr_t)task + struct_offset.task_struct_flags);
  return flags;
}
// task_jobctl
static inline unsigned long task_jobctl(struct task_struct *task) {
  unsigned long jobctl = *(unsigned long *)((uintptr_t)task + struct_offset.task_struct_jobctl);
  return jobctl;
}
// task_jobctl_ptr
static inline unsigned long *task_jobctl_ptr(struct task_struct *task) {
  unsigned long *jobctl = (unsigned long *)((uintptr_t)task + struct_offset.task_struct_jobctl);
  return jobctl;
}
// task_signal
static inline struct signal_struct *task_signal(struct task_struct *task) {
  struct signal_struct *signal = *(struct signal_struct **)((uintptr_t)task + struct_offset.task_struct_signal);
  return signal;
}
// signal_group_exit_task
static inline struct task_struct *signal_group_exit_task(struct signal_struct *sig) {
  struct task_struct *group_exit_task =
      *(struct task_struct **)((uintptr_t)sig + struct_offset.signal_struct_group_exit_task);
  return group_exit_task;
}
// signal_flags
static inline unsigned int signal_flags(struct signal_struct *sig) {
  unsigned int flags = *(unsigned int *)((uintptr_t)sig + struct_offset.signal_struct_flags);
  return flags;
}
// seq_file_private
static inline struct kernfs_open_file *seq_file_private(struct seq_file *seq) {
  struct kernfs_open_file *private = *(struct kernfs_open_file **)((uintptr_t)seq + struct_offset.seq_file_private);
  return private;
}
// cgroup_flags_ptr
static inline unsigned long *cgroup_flags_ptr(struct cgroup *cgrp) {
  unsigned long *flags = (unsigned long *)((uintptr_t)cgrp + struct_offset.cgroup_flags);
  return flags;
}
// css_set_dfl_cgrp
static inline struct cgroup *css_set_dfl_cgrp(struct css_set *cset) {
  struct cgroup *cgrp = *(struct cgroup **)((uintptr_t)cset + struct_offset.css_set_dfl_cgrp);
  return cgrp;
}
// subprocess_info_argv
static inline char **subprocess_info_argv(struct subprocess_info *sub_info) {
  char **argv = *(char ***)((uintptr_t)sub_info + struct_offset.subprocess_info_argv);
  return argv;
}

static long calculate_offsets() {
  // 获取 css_task_iter_start 版本, 以参数数量做判断
  uint32_t *css_task_iter_start_src = (uint32_t *)css_task_iter_start;
  for (u32 i = 0; i < 0x10; i++) {
#ifdef CONFIG_DEBUG
    logkm("css_task_iter_start %x %llx\n", i, css_task_iter_start_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(css_task_iter_start_src[i])) {
      break;
    } else if (inst_get_mov_reg_rm(css_task_iter_start_src[i]) == 2) {
      css_task_iter_start_ver5 = IZERO;
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("css_task_iter_start_ver5=0x%llx\n", css_task_iter_start_ver5);
#endif /* CONFIG_DEBUG */

  // 获取 cgroup_kn_lock_live 版本, 以参数数量做判断
  uint32_t *cgroup_kn_lock_live_src = (uint32_t *)cgroup_kn_lock_live;
  for (u32 i = 0; i < 0x10; i++) {
#ifdef CONFIG_DEBUG
    logkm("cgroup_kn_lock_live %x %llx\n", i, cgroup_kn_lock_live_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(cgroup_kn_lock_live_src[i])) {
      break;
    } else if (inst_get_mov_reg_rm(cgroup_kn_lock_live_src[i]) == 1
               || inst_get_uxtb_rn(cgroup_kn_lock_live_src[i]) == 1) {
      cgroup_kn_lock_live_ver5 = IZERO;
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("cgroup_kn_lock_live_ver5=0x%llx\n", cgroup_kn_lock_live_ver5);
#endif /* CONFIG_DEBUG */

  // 获取 cftype 版本, 以绑定函数做判断
  int (*cgroup_file_open)(struct kernfs_open_file *of) = NULL;
  cgroup_file_open = (typeof(cgroup_file_open))kallsyms_lookup_name("cgroup_file_open");

#ifdef CONFIG_DEBUG
  logkm("cgroup_file_open %llx\n", cgroup_file_open);
#endif /* CONFIG_DEBUG */
  if (cgroup_file_open) {
    cftype_ver5 = IZERO;
  }
#ifdef CONFIG_DEBUG
  logkm("cftype_ver5=0x%llx\n", cftype_ver5);
#endif /* CONFIG_DEBUG */

  // 获取 cgroup_base_files 版本, 以变量名做判断
  struct cftype *cgroup_base_files = NULL;
  cgroup_base_files = (typeof(cgroup_base_files))kallsyms_lookup_name("cgroup_base_files");

#ifdef CONFIG_DEBUG
  logkm("cgroup_base_files %llx\n", cgroup_base_files);
#endif /* CONFIG_DEBUG */
  if (cgroup_base_files) {
    cgroup_base_files_ver5 = IZERO;
  }
#ifdef CONFIG_DEBUG
  logkm("cgroup_base_files_ver5=0x%llx\n", cgroup_base_files_ver5);
#endif /* CONFIG_DEBUG */

  // 获取 task_struct->jobctl
  void (*task_clear_jobctl_trapping)(struct task_struct *t);
  lookup_name(task_clear_jobctl_trapping);

  uint32_t *task_clear_jobctl_trapping_src = (uint32_t *)task_clear_jobctl_trapping;
  for (u32 i = 0; i < 0x10; i++) {
#ifdef CONFIG_DEBUG
    logkm("task_clear_jobctl_trapping %x %llx\n", i, task_clear_jobctl_trapping_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(task_clear_jobctl_trapping_src[i])) {
      break;
    } else if (inst_get_ldr_imm_uint_size(task_clear_jobctl_trapping_src[i]) == 0b11
               && inst_get_ldr_imm_uint_rn(task_clear_jobctl_trapping_src[i]) == 0) {
      struct_offset.task_struct_jobctl = inst_get_ldr_imm_uint_imm(task_clear_jobctl_trapping_src[i]);
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("task_struct_jobctl=0x%llx\n", struct_offset.task_struct_jobctl);
#endif /* CONFIG_DEBUG */
  if (struct_offset.task_struct_jobctl <= 0)
    return -11;

  // 获取 task_struct->signal
  void (*tty_audit_fork)(struct signal_struct *sig);
  lookup_name(tty_audit_fork);

  uint32_t *tty_audit_fork_src = (uint32_t *)tty_audit_fork;
  for (u32 i = 0; i < 0x20; i++) {
#ifdef CONFIG_DEBUG
    logkm("tty_audit_fork %x %llx\n", i, tty_audit_fork_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(tty_audit_fork_src[i])) {
      break;
    } else if (inst_get_ldr_imm_uint_size(tty_audit_fork_src[i]) == 0b11
               && inst_is_mrs_sp_el0(tty_audit_fork_src[i - 1])) {
      struct_offset.task_struct_signal = inst_get_ldr_imm_uint_imm(tty_audit_fork_src[i]);
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("task_struct_signal=0x%llx\n", struct_offset.task_struct_signal);
#endif /* CONFIG_DEBUG */
  if (struct_offset.task_struct_signal <= 0)
    return -11;

  // 获取 signal_struct->flags, signal_struct->group_exit_task
  void (*zap_other_threads)(struct task_struct *t);
  lookup_name(zap_other_threads);

  uint32_t *zap_other_threads_src = (uint32_t *)zap_other_threads;
  for (u32 i = 0; i < 0x20; i++) {
#ifdef CONFIG_DEBUG
    logkm("zap_other_threads %x %llx\n", i, zap_other_threads_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(zap_other_threads_src[i])) {
      break;
    } else if (inst_get_str_imm_uint_rt(zap_other_threads_src[i]) == 31) {
      uint64_t offset = inst_get_str_imm_uint_imm(zap_other_threads_src[i]);  // signal_struct->group_stop_count
      struct_offset.signal_struct_group_exit_task = offset - 0x8;
      struct_offset.signal_struct_flags = offset + 0x4;
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("signal_struct_group_exit_task=0x%llx\n", struct_offset.signal_struct_group_exit_task);
  logkm("signal_struct_flags=0x%llx\n", struct_offset.signal_struct_flags);
#endif /* CONFIG_DEBUG */
  if (struct_offset.signal_struct_group_exit_task <= 0)
    return -11;

  // 获取 task_struct->flags
  bool (*freezing_slow_path)(struct task_struct *p);
  lookup_name(freezing_slow_path);

  uint32_t *freezing_slow_path_src = (uint32_t *)freezing_slow_path;
  for (u32 i = 0; i < 0x20; i++) {
#ifdef CONFIG_DEBUG
    logkm("freezing_slow_path %x %llx\n", i, freezing_slow_path_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(freezing_slow_path_src[i])) {
      break;
    } else if (inst_get_ldr_imm_uint_rn(freezing_slow_path_src[i]) == 0) {
      struct_offset.task_struct_flags = inst_get_ldr_imm_uint_imm(freezing_slow_path_src[i]);
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("task_struct_flags=0x%llx\n", struct_offset.task_struct_flags);
#endif /* CONFIG_DEBUG */
  if (struct_offset.task_struct_flags <= 0)
    return -11;

  // 获取 task_struct->state
  bool (*schedule_timeout_interruptible)(struct task_struct *p);
  lookup_name(schedule_timeout_interruptible);

  uint32_t *schedule_timeout_interruptible_src = (uint32_t *)schedule_timeout_interruptible;
  for (u32 i = 0; i < 0x20; i++) {
#ifdef CONFIG_DEBUG
    logkm("schedule_timeout_interruptible %x %llx\n", i, schedule_timeout_interruptible_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(schedule_timeout_interruptible_src[i])) {
      break;
    } else if (inst_get_str_imm_uint_size(schedule_timeout_interruptible_src[i]) == 0b11) {
      struct_offset.task_struct_state = inst_get_str_imm_uint_imm(schedule_timeout_interruptible_src[i]);
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("task_struct_state=0x%llx\n", struct_offset.task_struct_state);
#endif /* CONFIG_DEBUG */
  if (struct_offset.task_struct_state <= 0)
    return -11;

  // 获取 seq_file->private
  int (*cgroup_subtree_control_show)(struct seq_file *seq, void *v);
  lookup_name(cgroup_subtree_control_show);

  uint32_t *cgroup_subtree_control_show_src = (uint32_t *)cgroup_subtree_control_show;
  for (u32 i = 0; i < 0x20; i++) {
#ifdef CONFIG_DEBUG
    logkm("cgroup_subtree_control_show %x %llx\n", i, cgroup_subtree_control_show_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(cgroup_subtree_control_show_src[i])) {
      break;
    } else if (inst_get_ldr_imm_uint_size(cgroup_subtree_control_show_src[i]) == 0b11) {
      struct_offset.seq_file_private = inst_get_ldr_imm_uint_imm(cgroup_subtree_control_show_src[i]);
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("seq_file_private=0x%llx\n", struct_offset.seq_file_private);
#endif /* CONFIG_DEBUG */
  if (struct_offset.seq_file_private <= 0)
    return -11;

  // 获取 freezer->state
  void (*cgroup_freezing)(struct task_struct *task);
  lookup_name(cgroup_freezing);

  uint32_t *cgroup_freezing_src = (uint32_t *)cgroup_freezing;
  for (u32 i = 0; i < 0x20; i++) {
#ifdef CONFIG_DEBUG
    logkm("cgroup_freezing %x %llx\n", i, cgroup_freezing_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(cgroup_freezing_src[i])) {
      break;
    } else if (inst_get_ldr_imm_uint_size(cgroup_freezing_src[i]) == 0b10
               && inst_get_tst_imm_sf(cgroup_freezing_src[i + 1]) == 0
               && inst_get_tst_imm_imm(cgroup_freezing_src[i + 1]) == 6) {
      struct_offset.freezer_state = inst_get_ldr_imm_uint_imm(cgroup_freezing_src[i]);
      struct_offset.cgroup_flags = struct_offset.freezer_state;
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("freezer_state=0x%llx\n", struct_offset.freezer_state);
#endif /* CONFIG_DEBUG */
  if (struct_offset.freezer_state <= 0)
    return -11;

  // 获取 task_struct->css_set
  void (*cgroup_fork)(struct task_struct *child);
  lookup_name(cgroup_fork);

  uint32_t *cgroup_fork_src = (uint32_t *)cgroup_fork;
  for (u32 i = 0; i < 0x10; i++) {
#ifdef CONFIG_DEBUG
    logkm("cgroup_fork %x %llx\n", i, cgroup_fork_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(cgroup_fork_src[i])) {
      break;
    } else if (inst_get_str_imm_uint_size(cgroup_fork_src[i]) == 0b11) {
      struct_offset.task_struct_css_set = inst_get_str_imm_uint_imm(cgroup_fork_src[i]);
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("task_struct_css_set=0x%llx\n", struct_offset.task_struct_css_set);
#endif /* CONFIG_DEBUG */
  if (struct_offset.task_struct_css_set <= 0)
    return -11;

  // 获取 css_set->dfl_cgrp
  struct css_set kvar_def(init_css_set);
  kvar_lookup_name(init_css_set);
  // 4.4 4.9 未发现 0x48 以外的偏移
  // 4.14 4.19 新增 init_css_set->dom_cset = &init_css_set ,可据此计算偏移
  struct_offset.css_set_dfl_cgrp = 0x48;
  uint64_t *init_css_set_src = (uint64_t *)kvar(init_css_set);
  for (u32 i = 0; i < 0x10; i++) {
#ifdef CONFIG_DEBUG
    logkm("init_css_set %x %llx\n", i, init_css_set_src[i]);
#endif /* CONFIG_DEBUG */
    if (init_css_set_src[i] == (uint64_t)kvar(init_css_set)) {
      struct_offset.css_set_dfl_cgrp = (i + 1) * 8;
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("init_css_set=0x%llx\n", kvar(init_css_set));
  logkm("css_set_dfl_cgrp=0x%llx\n", struct_offset.css_set_dfl_cgrp);
#endif /* CONFIG_DEBUG */
  if (struct_offset.css_set_dfl_cgrp <= 0)
    return -11;

  // 获取 subprocess_info->path, subprocess_info->argv
  uint32_t *call_usermodehelper_exec_src = (uint32_t *)kfunc(call_usermodehelper_exec);
  for (u32 i = 0; i < 0x20; i++) {
#ifdef CONFIG_DEBUG
    logkm("call_usermodehelper_exec %x %llx\n", i, call_usermodehelper_exec_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(call_usermodehelper_exec_src[i])) {
      break;
    } else if (inst_get_ldr_imm_uint_size(call_usermodehelper_exec_src[i]) == 0b11
               && inst_get_ldr_imm_uint_rn(call_usermodehelper_exec_src[i]) == 0) {
      struct_offset.subprocess_info_path = inst_get_ldr_imm_uint_imm(call_usermodehelper_exec_src[i]);
      struct_offset.subprocess_info_argv = struct_offset.subprocess_info_path + 0x8;
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("subprocess_info_path=0x%llx\n", struct_offset.subprocess_info_path);
  logkm("subprocess_info_argv=0x%llx\n", struct_offset.subprocess_info_argv);
#endif /* CONFIG_DEBUG */
  if (struct_offset.subprocess_info_path <= 0)
    return -11;

  return 0;
}

```

`cgroupv2_freeze/cfv2_utils.h`:

```h
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 bmax121. All Rights Reserved.
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */
#ifndef __CF_UTILS_H
#define __CF_UTILS_H

#define logkm(fmt, ...) printk("cgroupv2_freeze: " fmt, ##__VA_ARGS__)

struct struct_offset {
  int16_t cgroup_flags;
  int16_t css_set_dfl_cgrp;
  int16_t freezer_state;
  int16_t seq_file_private;
  int16_t signal_struct_flags;
  int16_t signal_struct_group_exit_task;
  int16_t subprocess_info_argv;
  int16_t subprocess_info_path;
  int16_t task_struct_css_set;
  int16_t task_struct_flags;
  int16_t task_struct_jobctl;
  int16_t task_struct_signal;
  int16_t task_struct_state;
};

#endif /* __CF_UTILS_H */

```

`cgroupv2_freeze/cgroupv2_freeze.c`:

```c
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 bmax121. All Rights Reserved.
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */

#include "cgroupv2_freeze.h"

#include <compiler.h>
#include <kpmodule.h>
#include <kputils.h>
#include <linux/err.h>
#include <linux/fs.h>
#include <linux/kernel.h>
#include <linux/printk.h>
#include <linux/string.h>
#include <linux/umh.h>

#include "../kpm_utils.h"
#include "cfv2_utils.h"

KPM_NAME("cgroupv2_freeze");
KPM_VERSION(MYKPM_VERSION);
KPM_LICENSE("GPL v2");
KPM_AUTHOR("lzghzr");
KPM_DESCRIPTION("add cgroup.freeze, support 4.4 ~ 4.19");

#define GLOBAL_SYSTEM_UID KUIDT_INIT(1000)
#define GLOBAL_SYSTEM_GID KGIDT_INIT(1000)

#define IZERO (1UL << 0x10)
#define UZERO (1UL << 0x20)

// 延迟加载, KernelPatch支持 事件加载 后弃用
static struct file* (*do_filp_open)(int dfd, struct filename* pathname, const struct open_flags* op);

// do_freezer_trap
static int (*proc_pid_wchan)(struct seq_file* m, struct pid_namespace* ns, struct pid* pid, struct task_struct* task);
void kfunc_def(schedule)(void);
// cgroup_freeze_task
static void (*signal_wake_up_state)(struct task_struct* t, unsigned int state);
int kfunc_def(wake_up_process)(struct task_struct* p);
// cgroup_do_freeze
static void (*css_task_iter_start)(struct cgroup_subsys_state* css, unsigned int flags, struct css_task_iter* it);
static void (*css_task_iter_start_v4)(struct cgroup_subsys_state* css, struct css_task_iter* it);
static struct task_struct* (*css_task_iter_next)(struct css_task_iter* it);
static void (*css_task_iter_end)(struct css_task_iter* it);
// cgroup_freeze
static struct cgroup_subsys_state* (*css_next_descendant_pre)(struct cgroup_subsys_state* pos,
                                                              struct cgroup_subsys_state* root);
// cgroup_freeze_show
struct cgroup_subsys_state* kfunc_def(of_css)(struct kernfs_open_file* of);
void kfunc_def(seq_printf)(struct seq_file* m, const char* f, ...);
// cgroup_freeze_write
static struct cgroup* (*cgroup_kn_lock_live)(struct kernfs_node* kn, bool drain_offline);
static struct cgroup* (*cgroup_kn_lock_live_v4)(struct kernfs_node* kn);
static void (*cgroup_kn_unlock)(struct kernfs_node* kn);
int kfunc_def(kstrtoint)(const char* s, unsigned int base, int* res);
char* kfunc_def(strim)(char* s);
// run_cmd
int kfunc_def(call_usermodehelper)(const char* path, char** argv, char** envp, int wait);
int kfunc_def(call_usermodehelper_exec)(struct subprocess_info* info, int wait);
static int* selinux_enforcing;
struct selinux_state* selinux_state;

// hook cgroup_addrm_files
static int (*cgroup_addrm_files)(struct cgroup_subsys_state* css, struct cgroup* cgrp, struct cftype cfts[],
                                 bool is_add);
static int (*cgroup_init_cftypes)(struct cgroup_subsys* ss, struct cftype* cfts);
// hook cgroup_procs_write
static ssize_t (*cgroup_procs_write)(struct kernfs_open_file* of, char* buf, size_t nbytes, loff_t off);
// hook css_set_move_task
static void (*css_set_move_task)(struct task_struct* task, struct css_set* from_cset, struct css_set* to_cset,
                                 bool use_mg_tasks);
// hook __kernfs_create_file
static ssize_t (*__kernfs_create_file)(struct kernfs_node* parent, const char* name, umode_t mode, loff_t size,
                                       const struct kernfs_ops* ops, void* priv, const void* ns,
                                       struct lock_class_key* key);
static ssize_t (*kernfs_setattr)(struct kernfs_node* kn, const struct iattr* iattr);
// hook get_signal
static bool (*get_signal)(struct ksignal* ksig);

struct struct_offset struct_offset = {};
static uint64_t css_task_iter_start_ver5 = UZERO, cgroup_kn_lock_live_ver5 = UZERO, cftype_ver5 = UZERO,
                cgroup_base_files_ver5 = UZERO;
#include "cfv2_offsets.c"

// 为待冻结的 task 以及 cgroup 添加必要的标志
static void cgroup_freeze_task(struct task_struct* task, bool freeze) {
  if (!task)
    return;

  unsigned long* jobctl = task_jobctl_ptr(task);
  if (freeze) {
    *jobctl |= JOBCTL_TRAP_FREEZE;
    signal_wake_up_state(task, 0);
  } else {
    *jobctl &= ~JOBCTL_TRAP_FREEZE;
    kfunc(wake_up_process)(task);
  }
}

static void cgroup_do_freeze(struct cgroup* cgrp, bool freeze) {
  struct css_task_iter it;
  struct task_struct* task;

  unsigned long* flags = cgroup_flags_ptr(cgrp);
  if (freeze) {
    set_bit(CGRP_FREEZE, flags);
  } else {
    clear_bit(CGRP_FREEZE, flags);
  }

  if (css_task_iter_start_ver5 == IZERO) {
    css_task_iter_start(&cgrp->self, 0, &it);
  } else {
    css_task_iter_start_v4(&cgrp->self, &it);
  }
  while ((task = css_task_iter_next(&it))) {
    unsigned int flags = task_flags(task);
    if (flags & PF_KTHREAD)
      continue;
    cgroup_freeze_task(task, freeze);
  }
  css_task_iter_end(&it);
}

static void cgroup_freeze(struct cgroup* cgrp, bool freeze) {
  struct cgroup_subsys_state* css;
  struct cgroup* dsct;

  css_for_each_descendant_pre(css, &cgrp->self) {
    dsct = css->cgroup;
    cgroup_do_freeze(dsct, freeze);
  }
}

static ssize_t kernfs_node_freeze(struct kernfs_node* kn, bool freeze, bool force) {
  struct cgroup* cgrp;
  if (cgroup_kn_lock_live_ver5 == IZERO) {
    cgrp = cgroup_kn_lock_live(kn, false);
  } else {
    cgrp = cgroup_kn_lock_live_v4(kn);
  }

  if (!cgrp)
    return -ENOENT;

  if (!force) {
    unsigned long* flags = cgroup_flags_ptr(cgrp);
    freeze = test_bit(CGRP_FREEZE, flags);
  }

  cgroup_freeze(cgrp, freeze);

  cgroup_kn_unlock(kn);

  return 0;
}

static int cgroup_freeze_show(struct seq_file* seq, void* v) {
  struct kernfs_open_file* private = seq_file_private(seq);
  struct cgroup_subsys_state* css = kfunc(of_css)(private);
  struct cgroup* cgrp = css->cgroup;

  unsigned long* flags = cgroup_flags_ptr(cgrp);

  kfunc(seq_printf)(seq, "%d\n", test_bit(CGRP_FREEZE, flags));

  return 0;
}

static ssize_t cgroup_freeze_write(struct kernfs_open_file* of, char* buf, size_t nbytes, loff_t off) {
  int freeze;

  ssize_t ret = kfunc(kstrtoint)(kfunc(strim)(buf), 0, &freeze);
  if (ret)
    return ret;

  if (freeze < 0 || freeze > 1)
    return -ERANGE;

  ssize_t rc = kernfs_node_freeze(of->kn, freeze, true);
  if (rc)
    return rc;
  else
    return nbytes;
}

static struct cftype cgroup_freeze_files[] = {
    {
        .name = "cgroup.freeze",
        .flags = CFTYPE_NOT_ON_ROOT,
    },
    {},
};

static void cgroup_addrm_files_after(hook_fargs4_t* args, void* udata) {
  int ret = (int)args->ret;
  if (ret)
    return;

  ((typeof(cgroup_addrm_files))wrap_get_origin_func(args))(
      (struct cgroup_subsys_state*)args->arg0, (struct cgroup*)args->arg1, cgroup_freeze_files, (bool)args->arg3);
}

static const char uid_[] = "uid_";
static const char uid_0[] = "uid_0";
static const char pid_[] = "pid_";
// v1 模式并不会附加到 dfl_cgrp, 需要特殊处理
static void cgroup_procs_write_after(hook_fargs4_t* args, void* udata) {
  size_t nbytes = (size_t)args->arg2;
  size_t ret = (size_t)args->ret;
  if (ret != nbytes)
    return;

  struct kernfs_open_file* of = (struct kernfs_open_file*)args->arg0;
  struct kernfs_node* kn = NULL;

  // 处理 v1 frozen 模式
  if (!strcmp(of->kn->parent->name, "frozen") || !strcmp(of->kn->parent->name, "unfrozen")) {
    kn = of->kn->parent;
  }
  // 处理 v1 uid 模式
  if (!memcmp(of->kn->parent->name, pid_, sizeof(pid_) - 1)
      && (memcmp(of->kn->parent->parent->name, uid_0, sizeof(uid_0)))
      && !memcmp(of->kn->parent->parent->name, uid_, sizeof(uid_) - 1)) {
    kn = of->kn->parent->parent;
  }
  if (!kn)
    return;

  kernfs_node_freeze(kn, false, false);
}
// 处理 v2 uid 模式
static void css_set_move_task_after(hook_fargs4_t* args, void* udata) {
  struct task_struct* task = (struct task_struct*)args->arg0;
  if (!task)
    return;

  struct css_set* from_cset = (struct css_set*)args->arg1;
  struct cgroup* from_cgrp = NULL;
  unsigned long* from_flags = NULL;

  struct css_set* to_cset = (struct css_set*)args->arg2;
  struct cgroup* to_cgrp = NULL;
  unsigned long* to_flags = NULL;

  if (from_cset) {
    from_cgrp = css_set_dfl_cgrp(from_cset);
    from_flags = cgroup_flags_ptr(from_cgrp);
  }
  if (to_cset) {
    to_cgrp = css_set_dfl_cgrp(to_cset);
    to_flags = cgroup_flags_ptr(to_cgrp);
  }

  if (!from_cset && to_cset) {
    if (test_bit(CGRP_FREEZE, to_flags)) {
      unsigned long* jobctl = task_jobctl_ptr(task);
      *jobctl |= JOBCTL_TRAP_FREEZE;
    }
  } else if (from_cset && to_cset) {
    if (test_bit(CGRP_FREEZE, from_flags) != test_bit(CGRP_FREEZE, to_flags)) {
      cgroup_freeze_task(task, test_bit(CGRP_FREEZE, to_flags));
    }
  }
}
// 修改 cgroup.freeze 所有者为 system:system
static void __kernfs_create_file_after(hook_fargs8_t* args, void* udata) {
  struct kernfs_node* kn = (struct kernfs_node*)args->ret;

  if (IS_ERR(kn))
    return;

  if (!strcmp(kn->name, "cgroup.freeze")) {
    struct iattr iattr = {
        .ia_valid = ATTR_UID | ATTR_GID,
        .ia_uid = GLOBAL_SYSTEM_UID,
        .ia_gid = GLOBAL_SYSTEM_GID,
    };

    kernfs_setattr(kn, &iattr);
  }
}

static inline int signal_group_exit(struct signal_struct* sig) {
  unsigned int flags = signal_flags(sig);
  struct task_struct* group_exit_task = signal_group_exit_task(sig);
  return (flags & SIGNAL_GROUP_EXIT) || (group_exit_task != NULL);
}

static void do_freezer_trap(void) {
  unsigned long jobctl = task_jobctl(current);
  if ((jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) != JOBCTL_TRAP_FREEZE)
    return;

  volatile long* state = task_state_ptr(current);
  unsigned int* flags = task_flags_ptr(current);

  *state = TASK_INTERRUPTIBLE;
  clear_thread_flag(TIF_SIGPENDING);
  *flags |= PF_FREEZER_SKIP;
  kfunc(schedule)();
  *flags &= ~PF_FREEZER_SKIP;
}

static void get_signal_before(hook_fargs1_t* args, void* udata) {
  struct signal_struct* signal = task_signal(current);
  unsigned long* jobctl = task_jobctl_ptr(current);
  for (;;) {
    if (signal_group_exit(signal))
      return;

    if (unlikely(*jobctl & JOBCTL_TRAP_FREEZE)) {
      do_freezer_trap();
    } else {
      return;
    }
  }
}
// kpm 模块 wchan 函数名总为0, 需要手动修改
static void proc_pid_wchan_before(hook_fargs4_t* args, void* udata) {
  struct seq_file* m = (struct seq_file*)args->arg0;
  struct task_struct* task = (struct task_struct*)args->arg3;

  unsigned long jobctl = task_jobctl(task);
  // 用 lookup_symbol_name 判断一下会更好
  if (unlikely(jobctl & JOBCTL_TRAP_FREEZE)) {
    kfunc(seq_printf)(m, "%s", "do_freezer_trap");
    args->ret = 0;
    args->skip_origin = true;
  }
}

static void call_usermodehelper_exec_before(hook_fargs2_t* args, void* udata) {
  struct subprocess_info* sub_info = (struct subprocess_info*)args->arg0;
  if (!sub_info)
    return;

  char** argv = subprocess_info_argv(sub_info);
  *(char**)((uintptr_t)sub_info + struct_offset.subprocess_info_path) = argv[0];
}

static void run_cmd(char* cmd[]) {
  char* envp[] = {"HOME=/", "PATH=/sbin:/bin", NULL};
  bool sel = true;
  hook_err_t err = 0;

  if (selinux_enforcing) {
    sel = *selinux_enforcing;
    *selinux_enforcing = false;
  } else {
    err = hook_wrap2(kf_call_usermodehelper_exec, call_usermodehelper_exec_before, NULL, NULL);
    sel = selinux_state->enforcing;
    selinux_state->enforcing = false;
  }

  for (int i = 0; cmd[i]; i++) {
    char* argv[] = {"/bin/sh", "-c", cmd[i], NULL};
    call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);
  }

  if (selinux_enforcing) {
    *selinux_enforcing = sel;
  } else {
    if (!err) {
      unhook(kf_call_usermodehelper_exec);
    }
    selinux_state->enforcing = sel;
  }
}

static const char apm[] = "/data/adb/modules/";
static void do_filp_open_after(hook_fargs3_t* args, void* udata) {
  struct filename* pathname = (struct filename*)args->arg1;
  if (!memcmp(pathname->name, apm, sizeof(apm) - 1)) {
    char* cmd[] = {
        "if [ ! -d \"/sys/fs/cgroup/uid_0\" ]; then\
  umount /sys/fs/cgroup/freezer;\
  umount /sys/fs/cgroup;\
\
  chown system:system /sys/fs/cgroup/;\
\
  if [ -d \"/dev/cg2_bpf/uid_0\" ]; then\
    mount -t cgroup2 none /sys/fs/cgroup/;\
  elif [ -d \"/acct/uid_0\" ]; then\
    mount -t cgroup -o cpuacct none /sys/fs/cgroup/;\
  else\
    exit;\
  fi;\
fi;\
\
if [ ! -d \"/sys/fs/cgroup/frozen\" ]; then\
  mkdir /sys/fs/cgroup/frozen/;\
  chown -R system:system /sys/fs/cgroup/frozen/;\
  echo 1 > /sys/fs/cgroup/frozen/cgroup.freeze;\
\
  mkdir /sys/fs/cgroup/unfrozen/;\
  chown -R system:system /sys/fs/cgroup/unfrozen/;\
fi",
        NULL};
    run_cmd(cmd);
    unhook_func(do_filp_open);
  }
}

static long inline_hook_init(const char* args, const char* event, void* __user reserved) {
  // 有 cgroup_freeze_write 函数说明本身就支持cgroupv2 freezer
  void (*kf_cgroup_freeze_write)(void);
  kf_cgroup_freeze_write = (typeof(kf_cgroup_freeze_write))kallsyms_lookup_name("cgroup_freeze_write");
  if (kf_cgroup_freeze_write)
    return -24;

  lookup_name(do_filp_open);
  lookup_name(proc_pid_wchan);
  kfunc_lookup_name(schedule);

  lookup_name(signal_wake_up_state);
  kfunc_lookup_name(wake_up_process);

  lookup_name(css_task_iter_start);
  css_task_iter_start_v4 = (typeof(css_task_iter_start_v4))css_task_iter_start;
  lookup_name(css_task_iter_next);
  lookup_name(css_task_iter_end);

  lookup_name(css_next_descendant_pre);

  kfunc_lookup_name(of_css);
  kfunc_lookup_name(seq_printf);

  lookup_name(cgroup_kn_lock_live);
  cgroup_kn_lock_live_v4 = (typeof(cgroup_kn_lock_live_v4))cgroup_kn_lock_live;
  lookup_name(cgroup_kn_unlock);
  kfunc_lookup_name(kstrtoint);
  kfunc_lookup_name(strim);

  kfunc_lookup_name(call_usermodehelper);
  kfunc_lookup_name(call_usermodehelper_exec);

  selinux_enforcing = (typeof(selinux_enforcing))kallsyms_lookup_name("selinux_enforcing");
  selinux_state = (typeof(selinux_state))kallsyms_lookup_name("selinux_state");
  if (!selinux_enforcing && !selinux_state)
    return -21;

  lookup_name(cgroup_addrm_files);
  lookup_name(cgroup_init_cftypes);

  lookup_name(cgroup_procs_write);
  lookup_name(css_set_move_task);
  lookup_name(__kernfs_create_file);
  lookup_name(kernfs_setattr);

  lookup_name(get_signal);

  int rc = 0;
  rc = calculate_offsets();
  if (rc < 0)
    return rc;
  // 配置文件需要初始化一下
  if (cftype_ver5 == IZERO) {
    cgroup_freeze_files->seq_show = cgroup_freeze_show;
    cgroup_freeze_files->write = cgroup_freeze_write;
  } else {
    cgroup_freeze_files->seq_show_v4 = cgroup_freeze_show;
    cgroup_freeze_files->write_v4 = cgroup_freeze_write;
  }
  rc = cgroup_init_cftypes(NULL, cgroup_freeze_files);
  if (rc < 0)
    return rc;

  hook_func(get_signal, 1, get_signal_before, NULL, NULL);
  hook_func(proc_pid_wchan, 4, proc_pid_wchan_before, NULL, NULL);
  hook_func(cgroup_addrm_files, 4, NULL, cgroup_addrm_files_after, NULL);
  hook_func(cgroup_procs_write, 4, NULL, cgroup_procs_write_after, NULL);
  hook_func(css_set_move_task, 4, NULL, css_set_move_task_after, NULL);
  // 高版本内核会自动处理所有者, 不再需要手动更改
  if (cgroup_base_files_ver5 != IZERO) {
    hook_func(__kernfs_create_file, 8, NULL, __kernfs_create_file_after, NULL);
  }

  if (!event || strcmp(event, "load-file")) {
    hook_func(do_filp_open, 3, NULL, do_filp_open_after, NULL);
  }

  return 0;
}

static long inline_hook_control0(const char* ctl_args, char* __user out_msg, int outlen) {
  char msg[64];
  snprintf(msg, sizeof(msg), "_(._.)_");
  compat_copy_to_user(out_msg, msg, sizeof(msg));
  return 0;
}

static long inline_hook_exit(void* __user reserved) {
  unhook_func(get_signal);
  unhook_func(proc_pid_wchan);
  unhook_func(cgroup_addrm_files);
  unhook_func(cgroup_procs_write);
  unhook_func(css_set_move_task);
  unhook_func(__kernfs_create_file);
  unhook_func(do_filp_open);

  return 0;
}

KPM_INIT(inline_hook_init);
KPM_CTL0(inline_hook_control0);
KPM_EXIT(inline_hook_exit);

```

`cgroupv2_freeze/cgroupv2_freeze.h`:

```h
#ifndef __CGROUP_FREEZE_H
#define __CGROUP_FREEZE_H

#include <ktypes.h>
#include <linux/spinlock.h>
#include <linux/thread_info.h>

// KernelPatch/kernel/linux/include/linux/bitops.h
#define BITS_PER_LONG 64
#define BIT_MASK(nr) (1UL << ((nr) % BITS_PER_LONG))
#define BIT_WORD(nr) ((nr) / BITS_PER_LONG)

static inline void set_bit(int nr, volatile unsigned long* addr) {
  unsigned long mask = BIT_MASK(nr);
  unsigned long* p = ((unsigned long*)addr) + BIT_WORD(nr);
  *p |= mask;
}

static inline void clear_bit(int nr, volatile unsigned long* addr) {
  unsigned long mask = BIT_MASK(nr);
  unsigned long* p = ((unsigned long*)addr) + BIT_WORD(nr);
  *p &= ~mask;
}

static inline int test_bit(int nr, const volatile unsigned long* addr) {
  return 1UL & (addr[BIT_WORD(nr)] >> (nr & (BITS_PER_LONG - 1)));
}

// linux/thread_info.h
static inline void set_ti_thread_flag(struct thread_info* ti, int flag) { set_bit(flag, (unsigned long*)&ti->flags); }

static inline void clear_ti_thread_flag(struct thread_info* ti, int flag) {
  clear_bit(flag, (unsigned long*)&ti->flags);
}

#define set_thread_flag(flag) set_ti_thread_flag(current_thread_info(), flag)

#define clear_thread_flag(flag) clear_ti_thread_flag(current_thread_info(), flag)

#define css_for_each_descendant_pre(pos, css) \
  for ((pos) = css_next_descendant_pre(NULL, (css)); (pos); (pos) = css_next_descendant_pre((pos), (css)))

// linux/lockdep.h
struct lock_class_key;
// linux/signal.h
struct ksignal;

// linux/sched.h
#define PF_KTHREAD 0x00200000
#define PF_FREEZER_SKIP 0x40000000

#define TASK_INTERRUPTIBLE 0x0001

#define SIGNAL_GROUP_EXIT 0x00000004

#define JOBCTL_STOP_PENDING_BIT 17
#define JOBCTL_TRAP_STOP_BIT 19
#define JOBCTL_TRAP_NOTIFY_BIT 20
#define JOBCTL_TRAP_FREEZE_BIT 23

#define JOBCTL_STOP_PENDING (1UL << JOBCTL_STOP_PENDING_BIT)
#define JOBCTL_TRAP_STOP (1UL << JOBCTL_TRAP_STOP_BIT)
#define JOBCTL_TRAP_NOTIFY (1UL << JOBCTL_TRAP_NOTIFY_BIT)
#define JOBCTL_TRAP_FREEZE (1UL << JOBCTL_TRAP_FREEZE_BIT)

#define JOBCTL_TRAP_MASK (JOBCTL_TRAP_STOP | JOBCTL_TRAP_NOTIFY)
#define JOBCTL_PENDING_MASK (JOBCTL_STOP_PENDING | JOBCTL_TRAP_MASK)

struct signal_struct;
struct task_struct {
  unsigned int __state;
  // unknow
};

// linux/cgroup.h
struct css_task_iter {
  struct cgroup_subsys* ss;
  unsigned int flags;
  struct list_head* cset_pos;
  struct list_head* cset_head;
  struct list_head* tcset_pos;
  struct list_head* tcset_head;
  struct list_head* task_pos;
  struct list_head* tasks_head;
  struct list_head* mg_tasks_head;
  struct list_head* dying_tasks_head;
  struct list_head* cur_tasks_head;
  struct css_set* cur_cset;
  struct css_set* cur_dcset;
  struct task_struct* cur_task;
  struct list_head iters_node;
  // unknow
};

// asm-generic/atomic-long.h
typedef atomic_t atomic_long_t;
// linux/mutex.h
struct mutex {
  atomic_long_t owner;
  spinlock_t wait_lock;
  struct list_head wait_list;
  // unknow
};
// linux/seq_file.h
struct seq_file {
  char* buf;
  size_t size;
  size_t from;
  size_t count;
  size_t pad_until;
  loff_t index;
  loff_t read_pos;
  u64 version;
  struct mutex lock;
  // unknow
};

// linux/rbtree.h
struct rb_node {
  unsigned long __rb_parent_color;
  struct rb_node* rb_right;
  struct rb_node* rb_left;
} __attribute__((aligned(sizeof(long))));

// linux/kernfs.h
struct kernfs_node {
  atomic_t count;
  atomic_t active;
  struct kernfs_node* parent;
  const char* name;
  struct rb_node rb;
  const void* ns;
  unsigned int hash;
  // unknow
};
struct kernfs_open_file {
  struct kernfs_node* kn;
  struct file* file;
  void* priv;
  struct mutex mutex;
  int event;
  struct list_head list;
  char* prealloc_buf;
  size_t atomic_write_len;
  bool mmapped;
  const struct vm_operations_struct* vm_ops;
};

// linux/uidgid.h
#define KUIDT_INIT(value) \
  (kuid_t) { value }
#define KGIDT_INIT(value) \
  (kgid_t) { value }

// linux/time64.h
typedef __s64 time64_t;
struct timespec64 {
  time64_t tv_sec;
  long tv_nsec;
};

// linux/fs.h
struct iattr {
  unsigned int ia_valid;
  umode_t ia_mode;
  kuid_t ia_uid;
  kgid_t ia_gid;
  loff_t ia_size;
  struct timespec64 ia_atime;
  struct timespec64 ia_mtime;
  struct timespec64 ia_ctime;
  struct file* ia_file;
};

// linux/cgroup-defs.h
enum {
  CGRP_NOTIFY_ON_RELEASE,
  CGRP_CPUSET_CLONE_CHILDREN,
  CGRP_FREEZE,
  CGRP_FROZEN,
};

struct cgroup_subsys_state {
  struct cgroup* cgroup;
  struct cgroup_subsys* ss;
  // unknow
};

struct cgroup {
  struct cgroup_subsys_state self;
  unsigned long flags;
  // unknow
};

enum {
  CFTYPE_ONLY_ON_ROOT = (1 << 0),
  CFTYPE_NOT_ON_ROOT = (1 << 1),
};

#define MAX_CFTYPE_NAME 64

struct poll_table_struct;
struct cftype {
  char name[MAX_CFTYPE_NAME];
  unsigned long private;
  size_t max_write_len;
  unsigned int flags;
  unsigned int file_offset;
  struct cgroup_subsys* ss;
  struct list_head node;
  struct kernfs_ops* kf_ops;
  int (*open)(struct kernfs_open_file* of);      // unknow v4
  void (*release)(struct kernfs_open_file* of);  // unknow v4
  // u64(*read_u64)(struct cgroup_subsys_state* css, struct cftype* cft);
  int (*seq_show_v4)(struct seq_file* sf, void* v);
  s64 (*read_s64)(struct cgroup_subsys_state* css, struct cftype* cft);
  int (*seq_show)(struct seq_file* sf, void* v);
  void* (*seq_start)(struct seq_file* sf, loff_t* ppos);
  void* (*seq_next)(struct seq_file* sf, void* v, loff_t* ppos);
  void (*seq_stop)(struct seq_file* sf, void* v);
  // int (*write_u64)(struct cgroup_subsys_state* css, struct cftype* cft, u64
  // val);
  ssize_t (*write_v4)(struct kernfs_open_file* of, char* buf, size_t nbytes, loff_t off);
  int (*write_s64)(struct cgroup_subsys_state* css, struct cftype* cft, s64 val);
  ssize_t (*write)(struct kernfs_open_file* of, char* buf, size_t nbytes, loff_t off);
  unsigned int (*poll)(struct kernfs_open_file* of, struct poll_table_struct* pt);
};

// fs/internal.h
struct open_flags {
  int open_flag;
  umode_t mode;
  int acc_mode;
  int intent;
  int lookup_flags;
};

// security.h
struct selinux_state {
  bool disabled;
  bool enforcing;
  bool checkreqprot;
  bool initialized;
  // unknow
};

// linux/umh.h
struct subprocess_info;

#endif /* __CGROUP_FREEZE_H */

```

`dont_kill_freeze/Makefile`:

```
MYKPM_VERSION := 1.0.2

ifndef KP_DIR
    KP_DIR = ../KernelPatch
endif

OS_NAME = $(shell uname | tr A-Z a-z)
MACHINE = $(shell uname -m)
HOST_TAG = $(OS_NAME)-$(MACHINE)
ifeq ($(HOST_TAG), darwin-arm64)
    HOST_TAG = darwin-x86_64
endif
NDK_BIN_DIR := toolchains/llvm/prebuilt/$(HOST_TAG)/bin
ifdef ANDROID_NDK_LATEST_HOME
    NDK_PATH ?= $(ANDROID_NDK_LATEST_HOME)/$(NDK_BIN_DIR)
else ifdef ANDROID_NDK
    NDK_PATH ?= $(ANDROID_NDK)/$(NDK_BIN_DIR)
endif

ifdef TARGET_COMPILE
    CC := $(TARGET_COMPILE)gcc
    LD := $(TARGET_COMPILE)ld
else ifdef NDK_PATH
    CC := $(NDK_PATH)/aarch64-linux-android31-clang
    LD := $(NDK_PATH)/ld.lld
endif

CFLAGS = -Wall -O2 -fno-PIC -fno-asynchronous-unwind-tables -fno-stack-protector -fno-common -DMYKPM_VERSION=\"$(MYKPM_VERSION)$(MYKPM_VER)\"

INCLUDE_DIRS := . include patch/include linux/include linux/arch/arm64/include linux/tools/arch/arm64/include

INCLUDE_FLAGS := $(foreach dir,$(INCLUDE_DIRS),-I$(KP_DIR)/kernel/$(dir))

objs := dont_kill_freeze.c

all: base

base: dont_kill_freeze_$(MYKPM_VERSION).kpm

debug: CFLAGS += -DCONFIG_DEBUG
debug: MYKPM_VER := _d
debug: dont_kill_freeze_$(MYKPM_VERSION)_debug.kpm

dont_kill_freeze_$(MYKPM_VERSION).kpm: ${objs}
	${CC} $(CFLAGS) $(CFLAG) $(INCLUDE_FLAGS) $^ -r -o $@

dont_kill_freeze_$(MYKPM_VERSION)_debug.kpm: ${objs}
	${CC} $(CFLAGS) $(CFLAG) $(INCLUDE_FLAGS) $^ -r -o $@

.PHONY: clean
clean:
	rm -rf *.kpm
	find . -name "*.o" | xargs rm -f

```

`dont_kill_freeze/README.md`:

```md
# dont_kill_freeze
## 模块作用
为所有已冻结的进程拦截 `SIGKILL` 信号

## 已知 BUG
如果再次进入前台卡住, 需使用 `root` 用户强制杀死

## 更新记录
### 1.0.2
killer 黑名单改为白名单，变更 `task_struct->jobctl` 获取方式, 新增 `oom_score_adj` 过滤
### 1.0.1
拦截更加温柔
### 1.0.0
初始版本

```

`dont_kill_freeze/dont_kill_freeze.c`:

```c
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 bmax121. All Rights Reserved.
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */

#include <compiler.h>
#include <hook.h>
#include <kpmodule.h>
#include <kputils.h>
#include <taskext.h>
#include <linux/kernel.h>
#include <linux/printk.h>
#include <linux/string.h>
#include <uapi/asm-generic/errno.h>

#ifdef CONFIG_DEBUG_CMDLINE
#include <uapi/linux/limits.h>
#endif /* CONFIG_DEBUG_CMDLINE */

#include "dont_kill_freeze.h"

KPM_NAME("dont_kill_freeze");
KPM_VERSION(MYKPM_VERSION);
KPM_LICENSE("GPL v2");
KPM_AUTHOR("lzghzr");
KPM_DESCRIPTION("dont_kill_freeze");

#define MIN_SYSTEM_UID 1000
#define MAX_SYSTEM_UID 2000
#define MIN_USERAPP_UID 10000
#define MAX_USERAPP_UID 90000

#define IZERO (1UL << 0x10)
#define UZERO (1UL << 0x20)

int kfunc_def(kstrtoint)(const char* s, unsigned int base, int* res);
char* kfunc_def(strim)(char* s);
// cgroup_freezing
static bool (*cgroup_freezing)(struct task_struct* task);
// hook do_send_sig_info
static int (*do_send_sig_info)(int sig, struct siginfo* info, struct task_struct* p, enum pid_type type);
#ifdef CONFIG_DEBUG_CMDLINE
static int (*get_cmdline)(struct task_struct* task, char* buffer, int buflen);
#endif /* CONFIG_DEBUG_CMDLINE */

static uint64_t task_struct_jobctl_offset = UZERO, task_struct_signal_offset = UZERO, signal_struct_oom_score_adj_offset = UZERO,
last_uid = UZERO, oom_score_adj_max = UZERO;

static char android_display[] = "android.display";
// 有些内核可能是 "Binder:"
static char binder[] = "binder:";

// cgroupv2_freeze
static inline bool jobctl_frozen(struct task_struct* task) {
  unsigned long jobctl = *(unsigned long*)((uintptr_t)task + task_struct_jobctl_offset);
  return ((jobctl & JOBCTL_TRAP_FREEZE) != 0);
}
// 判断线程是否进入 frozen 状态
static inline bool frozen_task_group(struct task_struct* task) {
  return (jobctl_frozen(task) || cgroup_freezing(task));
}

static inline short get_oom_score_adj(struct task_struct* task) {
  struct signal_struct* signal = *(struct signal_struct**)((uintptr_t)task + task_struct_signal_offset);
  short oom_score_adj = *(short*)((uintptr_t)signal + signal_struct_oom_score_adj_offset);
  return oom_score_adj;
}

static void do_send_sig_info_before(hook_fargs4_t* args, void* udata) {
  int sig = (int)args->arg0;
  struct kernel_siginfo* siginfo = (struct kernel_siginfo*)args->arg1;
  struct task_struct* dst = (struct task_struct*)args->arg2;
#ifdef CONFIG_DEBUG
  if (sig == SIGKILL
    && task_uid(dst).val > MIN_USERAPP_UID) {
    logkm("killer=%d,comm=%s,dst=%d,oom_score_adj=%d,frozen=%d\n",
      task_uid(current).val, get_task_comm(current), task_uid(dst).val, get_oom_score_adj(dst), frozen_task_group(dst));
  }
#endif /* CONFIG_DEBUG */
// cmdline 速度非常非常慢
#ifdef CONFIG_DEBUG_CMDLINE
  if (sig == SIGKILL
    && task_uid(dst).val > MIN_USERAPP_UID) {
    char cmdline[PATH_MAX];
    memset(&cmdline, 0, PATH_MAX);
    int res = get_cmdline(current, cmdline, PATH_MAX - 1);
    cmdline[res] = '\0';
    logkm("cmdline=%s\n", cmdline);
  }
#endif /* CONFIG_DEBUG_CMDLINE */
  if (sig != SIGKILL || siginfo->si_code != 0)
    return;
  if (task_uid(current).val < MIN_SYSTEM_UID || task_uid(current).val > MAX_SYSTEM_UID)
    return;
  if (task_uid(dst).val == last_uid
    || task_uid(dst).val < MIN_USERAPP_UID
    || get_oom_score_adj(dst) > oom_score_adj_max)
    return;

  const char* comm = get_task_comm(current);
  if (memcmp(comm + 1, binder + 1, sizeof(binder) - 2)
    && memcmp(comm, android_display, sizeof(android_display) - 1)
    && frozen_task_group(dst)) {
    args->ret = -EPERM;
    args->skip_origin = true;
#ifdef CONFIG_DEBUG
    logkm("skip\n");
#endif /* CONFIG_DEBUG */
  } else {
    last_uid = task_uid(dst).val;
  }
}

static long calculate_offsets() {
  // 获取 task_struct->jobctl
  void (*task_clear_jobctl_trapping)(struct task_struct* t);
  lookup_name(task_clear_jobctl_trapping);

  uint32_t* task_clear_jobctl_trapping_src = (uint32_t*)task_clear_jobctl_trapping;
  for (u32 i = 0; i < 0x10; i++) {
#ifdef CONFIG_DEBUG
    logkm("task_clear_jobctl_trapping %x %llx\n", i, task_clear_jobctl_trapping_src[i]);
#endif /* CONFIG_DEBUG */
    if (task_clear_jobctl_trapping_src[i] == ARM64_RET) {
      break;
    } else if ((task_clear_jobctl_trapping_src[i] & MASK_LDR_64_Rn_X0) == INST_LDR_64_Rn_X0) {
      uint64_t imm12 = bits32(task_clear_jobctl_trapping_src[i], 21, 10);
      task_struct_jobctl_offset = sign64_extend((imm12 << 0b11u), 16u);
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("task_struct_jobctl_offset=%llx\n", task_struct_jobctl_offset);
#endif /* CONFIG_DEBUG */
  if (task_struct_jobctl_offset == UZERO) {
    return -11;
  }
  // 获取 task_struct->signal, signal_struct->oom_score_adj
  void (*out_of_memory)(struct task_struct* p, unsigned long totalpages);
  lookup_name(out_of_memory);

  uint32_t* out_of_memory_src = (uint32_t*)out_of_memory;
  for (u32 i = 0; i < 0xa0; i++) {
#ifdef CONFIG_DEBUG
    logkm("out_of_memory %x %llx\n", i, out_of_memory_src[i]);
#endif /* CONFIG_DEBUG */
    if ((out_of_memory_src[i] & MASK_LDR_64_) == INST_LDR_64_ && (out_of_memory_src[i + 1] & MASK_LDRSH) == INST_LDRSH) {
      uint64_t imm12 = 0;
      imm12 = bits32(out_of_memory_src[i], 21, 10);
      task_struct_signal_offset = sign64_extend((imm12 << 0b11u), 16u);

      imm12 = bits32(out_of_memory_src[i + 1], 21, 10);
      signal_struct_oom_score_adj_offset = sign64_extend((imm12 << 1u), 16u);
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("task_struct_signal_offset=%llx\n", task_struct_signal_offset);
  logkm("signal_struct_oom_score_adj_offset=%llx\n", signal_struct_oom_score_adj_offset);
#endif /* CONFIG_DEBUG */
  if (task_struct_signal_offset == UZERO || signal_struct_oom_score_adj_offset == UZERO) {
    return -11;
  }

  return 0;
}

static long inline_hook_init(const char* args, const char* event, void* __user reserved) {
  kfunc_lookup_name(kstrtoint);
  kfunc_lookup_name(strim);

  lookup_name(cgroup_freezing);
  lookup_name(do_send_sig_info);
#ifdef CONFIG_DEBUG_CMDLINE
  lookup_name(get_cmdline);
#endif /* CONFIG_DEBUG_CMDLINE */

  int rc = calculate_offsets();
  if (rc < 0) {
    return rc;
  }

  if (args) {
    int oom_score_adj;
    rc = kfunc(kstrtoint)(kfunc(strim)((char*)args), 0, &oom_score_adj);
    if (!rc) {
      oom_score_adj_max = oom_score_adj;
    }
  }

  hook_func(do_send_sig_info, 4, do_send_sig_info_before, NULL, NULL);

  return 0;
}

static long inline_hook_control0(const char* ctl_args, char* __user out_msg, int outlen) {
  char msg[64];

  int rc;
  int oom_score_adj;
  if (ctl_args) {
    rc = kfunc(kstrtoint)(kfunc(strim)((char*)ctl_args), 0, &oom_score_adj);
  } else {
    rc = -22;
  }
  if (rc) {
    snprintf(msg, sizeof(msg), "_(x_x)_");
  } else {
    oom_score_adj_max = oom_score_adj;
    snprintf(msg, sizeof(msg), "_(._.)_");
  }

  compat_copy_to_user(out_msg, msg, sizeof(msg));
  return 0;
}

static long inline_hook_exit(void* __user reserved) {
  unhook_func(do_send_sig_info);

  return 0;
}

KPM_INIT(inline_hook_init);
KPM_CTL0(inline_hook_control0);
KPM_EXIT(inline_hook_exit);

```

`dont_kill_freeze/dont_kill_freeze.h`:

```h
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 bmax121. All Rights Reserved.
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */
#ifndef __DONT_KILL_FREEZE_H
#define __DONT_KILL_FREEZE_H

#include <hook.h>
#include <ksyms.h>
#include <linux/cred.h>
#include <linux/sched.h>

#define bits32(n, high, low) ((uint32_t)((n) << (31u - (high))) >> (31u - (high) + (low)))
#define bit(n, st) (((n) >> (st)) & 1)
#define sign64_extend(n, len) \
  (((uint64_t)((n) << (63u - (len - 1))) >> 63u) ? ((n) | (0xFFFFFFFFFFFFFFFF << (len))) : n)

typedef uint32_t inst_type_t;
typedef uint32_t inst_mask_t;

#define INST_LDR_64_ 0xF9400000u
#define INST_LDR_64_Rn_X0 0xF9400000u
#define INST_LDRSH 0x79800000u

#define MASK_LDR_64_ 0xFFC00000u
#define MASK_LDR_64_Rn_X0 0xFFC003E0u
#define MASK_LDRSH 0xFF800000u

#define ARM64_RET 0xD65F03C0

#define logkm(fmt, ...) printk("dont_kill_freeze: " fmt, ##__VA_ARGS__)

#define lookup_name(func)                                  \
  func = 0;                                                \
  func = (typeof(func))kallsyms_lookup_name(#func);        \
  pr_info("kernel function %s addr: %llx\n", #func, func); \
  if (!func)                                               \
  {                                                        \
    return -21;                                            \
  }

#define hook_func(func, argv, before, after, udata)                         \
  if (!func)                                                                \
  {                                                                         \
    return -22;                                                             \
  }                                                                         \
  hook_err_t hook_err_##func = hook_wrap(func, argv, before, after, udata); \
  if (hook_err_##func)                                                      \
  {                                                                         \
    func = 0;                                                               \
    pr_err("hook %s error: %d\n", #func, hook_err_##func);                  \
    return -23;                                                             \
  }                                                                         \
  else                                                                      \
  {                                                                         \
    pr_info("hook %s success\n", #func);                                    \
  }

#define unhook_func(func)            \
  if (func && !is_bad_address(func)) \
  {                                  \
    unhook(func);                    \
    func = 0;                        \
  }

#define task_real_uid(task)                                                                       \
  ({                                                                                              \
    struct cred *cred = *(struct cred **)((uintptr_t)task + task_struct_offset.real_cred_offset); \
    kuid_t ___val = *(kuid_t *)((uintptr_t)cred + cred_offset.uid_offset);                        \
    ___val;                                                                                       \
  })

#define task_uid(task) task_real_uid(task)
  // ({                                                                                         \
  //   struct cred *cred = *(struct cred **)((uintptr_t)task + task_struct_offset.cred_offset); \
  //   kuid_t ___val = *(kuid_t *)((uintptr_t)cred + cred_offset.uid_offset);                   \
  //   ___val;                                                                                  \
  // })

// linux/sched/jobctl.h
#define JOBCTL_TRAP_FREEZE_BIT 23
#define JOBCTL_TRAP_FREEZE (1UL << JOBCTL_TRAP_FREEZE_BIT)

// uapi/asm/signal.h
#define SIGKILL 9
struct siginfo;

// linux/signal_types.h
#define __SIGINFO \
struct {          \
	int si_signo; \
	int si_errno; \
	int si_code;  \
}
typedef struct kernel_siginfo {
  __SIGINFO;
} kernel_siginfo_t;

// linux/schde.h
#define PF_FROZEN 0x00010000

// include/linux/cgroup-defs.h
enum {
  CGRP_NOTIFY_ON_RELEASE,
  CGRP_CPUSET_CLONE_CHILDREN,
  CGRP_FREEZE,
  CGRP_FROZEN,
};
struct cgroup;

#endif /* __DONT_KILL_FREEZE_H */

```

`hosts_redirect/Makefile`:

```
MYKPM_VERSION := 2.0.0

ifndef KP_DIR
    KP_DIR = ../KernelPatch
endif

OS_NAME = $(shell uname | tr A-Z a-z)
MACHINE = $(shell uname -m)
HOST_TAG = $(OS_NAME)-$(MACHINE)
ifeq ($(HOST_TAG), darwin-arm64)
    HOST_TAG = darwin-x86_64
endif
NDK_BIN_DIR := toolchains/llvm/prebuilt/$(HOST_TAG)/bin
ifdef ANDROID_NDK_LATEST_HOME
    NDK_PATH ?= $(ANDROID_NDK_LATEST_HOME)/$(NDK_BIN_DIR)
else ifdef ANDROID_NDK
    NDK_PATH ?= $(ANDROID_NDK)/$(NDK_BIN_DIR)
endif

ifdef TARGET_COMPILE
    CC := $(TARGET_COMPILE)gcc
    LD := $(TARGET_COMPILE)ld
else ifdef NDK_PATH
    CC := $(NDK_PATH)/aarch64-linux-android31-clang
    LD := $(NDK_PATH)/ld.lld
endif

CFLAGS = -Wall -O2 -fno-PIC -fno-asynchronous-unwind-tables -fno-stack-protector -fno-common -DMYKPM_VERSION=\"$(MYKPM_VERSION)$(HR_VER)\"

INCLUDE_DIRS := . include patch/include linux/include linux/arch/arm64/include linux/tools/arch/arm64/include

INCLUDE_FLAGS := $(foreach dir,$(INCLUDE_DIRS),-I$(KP_DIR)/kernel/$(dir))

objs := hosts_redirect.o

all: hosts_redirect_$(MYKPM_VERSION).kpm

debug: CFLAGS += -DCONFIG_DEBUG
debug: HR_VER := _d
debug: hosts_redirect_$(MYKPM_VERSION)_debug.kpm

hosts_redirect_$(MYKPM_VERSION).kpm: ${objs}
	${CC} -r -o $@ $^

hosts_redirect_$(MYKPM_VERSION)_debug.kpm: ${objs}
	${CC} -r -o $@ $^

%.o: %.c
	${CC} $(CFLAGS) $(INCLUDE_FLAGS) -c -o $@ $<

.PHONY: clean
clean:
	rm -rf *.kpm
	find . -name "*.o" | xargs rm -f

```

`hosts_redirect/README.md`:

```md
# hosts_redirect
## 模块作用
重定向 `/system/etc/hosts` 文件到 `/data/adb/hosts/{name}`<br />
可使通过 `参数` 或 `kpatch` 更改 `{name}` 值<br />
例如 `kpatch $SUPERKEY kpm ctl0 hosts_redirect adblock` 重定向到 `/data/adb/hosts/adblock`

## 更新记录
### 2.0.0
变更重定向文件路径为 `/data/adb/hosts/{name}`
### 1.2.0
支持相对路径
### 1.1.0
支持使用 `kpatch` 动态调整重定向
### 1.0.0
练手模块, 灵感来源于 [hosts_file_redirect](https://github.com/AndroidPatch/kpm/tree/main/src/hosts_file_redirect)

```

`hosts_redirect/hosts_redirect.c`:

```c
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 bmax121. All Rights Reserved.
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */

#include <accctl.h>
#include <compiler.h>
#include <hook.h>
#include <kpmodule.h>
#include <kputils.h>
#include <taskext.h>
#include <linux/cred.h>
#include <linux/err.h>
#include <linux/fs.h>
#include <linux/kernel.h>
#include <linux/printk.h>
#include <linux/spinlock.h>
#include <linux/string.h>
#include <uapi/linux/limits.h>

#include  "hosts_redirect.h"
#include "hr_utils.h"

KPM_NAME("hosts_redirect");
KPM_VERSION(MYKPM_VERSION);
KPM_LICENSE("GPL v2");
KPM_AUTHOR("lzghzr");
KPM_DESCRIPTION("redirect /system/etc/hosts to /data/adb/hosts/{name}");

#define IZERO (1UL << 0x10)
#define UZERO (1UL << 0x20)

struct open_flags;
struct file* (*do_filp_open)(int dfd, struct filename* pathname, const struct open_flags* op);

char* kfunc_def(d_path)(const struct path* path, char* buf, int buflen);
int kfunc_def(kern_path)(const char* name, unsigned int flags, struct path* path);
void kfunc_def(_raw_spin_lock)(raw_spinlock_t* lock);
void kfunc_def(_raw_spin_unlock)(raw_spinlock_t* lock);

static uint64_t task_struct_fs_offset = UZERO, task_struct_alloc_lock_offset = UZERO,
fs_struct_pwd_offset = UZERO, fs_struct_lock_offset = UZERO;

char hosts_source[] = "/system/etc/hosts";
char hosts_target[64] = "/data/adb/hosts/hosts";

static bool set_hosts(const char* name) {
  if (!name || strlen(name) > 40)
    return false;
  for (int i = 0;i <= strlen(name);i++) {
    hosts_target[16 + i] = name[i];
  }
#ifdef CONFIG_DEBUG
  logkm("hosts_target=%s\n", hosts_target);
#endif /* DEBUG */
  return true;
}

static bool endWith(const char* str, const char* suffix) {
  if (!str || !suffix)
    return false;
  size_t lenstr = strlen(str);
  size_t lensuffix = strlen(suffix);
  if (lensuffix > lenstr)
    return false;
  return strncmp(str + lenstr - lensuffix, suffix, lensuffix) == 0;
}

static void do_filp_open_before(hook_fargs3_t* args, void* udata) {
  args->local.data0 = 0;
  if (current_uid() != 0)
    return;
  if (unlikely(!strcmp(hosts_target, "/data/adb/hosts/disable")))
    return;

  struct filename* pathname = (struct filename*)args->arg1;

  if (unlikely(!strcmp(pathname->name, hosts_source))) {
    args->local.data0 = (uint64_t)pathname->name;
    pathname->name = hosts_target;
    set_priv_sel_allow(current, true);
  } else if (unlikely(endWith(pathname->name, "hosts"))) {
    struct task_struct* task = current;
    spinlock_t task_lock = *(spinlock_t*)((uintptr_t)task + task_struct_alloc_lock_offset);
    spin_lock(&task_lock);

    struct fs_struct* fs = *(struct fs_struct**)((uintptr_t)task + task_struct_fs_offset);
    if (likely(fs)) {
    // spinlock_t fs_lock = *(spinlock_t*)((uintptr_t)fs + fs_struct_lock_offset);
    // spin_lock(&fs_lock);
      spin_lock(&fs->lock);
      struct path* pwd = (struct path*)((uintptr_t)fs + fs_struct_pwd_offset);
      if (likely(pwd)) {
        char buf[PATH_MAX];
        memset(&buf, 0, PATH_MAX);
        char* pwd_path = d_path(pwd, buf, PATH_MAX);
#ifdef CONFIG_DEBUG
        logkm("pwd_path=%s\n", pwd_path);
#endif /* DEBUG */

        * buf = '\0';
        if (pathname->name[0] != '/') {
          strncat(buf, pwd_path, strlen(pwd_path));
          strncat(buf, "/", strlen("/"));
        }
        strncat(buf, pathname->name, strlen(pathname->name));
#ifdef CONFIG_DEBUG
        logkm("full_path=%s\n", buf);
#endif /* DEBUG */

        struct path path;
        int err = kern_path(buf, LOOKUP_FOLLOW, &path);
        if (likely(!err)) {
          memset(&buf, 0, PATH_MAX);
          char* hosts_name = d_path(&path, buf, PATH_MAX);
#ifdef CONFIG_DEBUG
          logkm("hosts_name=%s\n", hosts_name);
#endif /* DEBUG */
          if (likely(!IS_ERR(hosts_name) && !strcmp(hosts_name, hosts_source))) {
            args->local.data0 = (uint64_t)pathname->name;
            pathname->name = hosts_target;
            set_priv_sel_allow(task, true);
          }
        }
      }
      spin_unlock(&fs->lock);
    }
    spin_unlock(&task_lock);
  }
}

static void do_filp_open_after(hook_fargs3_t* args, void* udata) {
  if (unlikely(args->local.data0)) {
    set_priv_sel_allow(current, false);
    struct filename* pathname = (struct filename*)args->arg1;
    pathname->name = (char*)args->local.data0;
  }
}

static long inline_hook_control0(const char* ctl_args, char* __user out_msg, int outlen) {
  bool success = set_hosts(ctl_args);

  char msg[64];
  if (success) {
    snprintf(msg, sizeof(msg), "_(._.)_\n");
  } else {
    snprintf(msg, sizeof(msg), "_(x_x)_\n");
  }
  compat_copy_to_user(out_msg, msg, sizeof(msg));
  return 0;
}

static uint64_t calculate_imm(uint32_t inst, enum inst_type inst_type) {
  if (inst_type == ARM64_LDP_64) {
    uint64_t imm7 = bits32(inst, 21, 15);
    return sign64_extend((imm7 << 0b11u), 16u);
  }
  uint64_t imm12 = bits32(inst, 21, 10);
  switch (inst_type) {
  case ARM64_ADD_64:
    if (bit(inst, 22)) {
      return sign64_extend((imm12 << 12u), 16u);
    } else {
      return sign64_extend((imm12), 16u);
    }
  case ARM64_LDR_64:
    return sign64_extend((imm12 << 0b11u), 16u);
  default:
    return UZERO;
  }
}

static long calculate_offsets() {
  // 获取 pwd 相关偏移
  // task->fs
  // fs->pwd
  int (*proc_cwd_link)(struct dentry* dentry, struct path* path);
  lookup_name(proc_cwd_link);

  uint32_t* proc_cwd_link_src = (uint32_t*)proc_cwd_link;
  for (u32 i = 0; i < 0x30; i++) {
#ifdef CONFIG_DEBUG
    logkm("proc_cwd_link %x %llx\n", i, proc_cwd_link_src[i]);
#endif /* CONFIG_DEBUG */
    if (proc_cwd_link_src[i] == ARM64_RET) {
      break;
    } else if ((proc_cwd_link_src[i] & MASK_LDP_64_) == INST_LDP_64_) {
      fs_struct_pwd_offset = calculate_imm(proc_cwd_link_src[i], ARM64_LDP_64);
      break;
    } else if (task_struct_alloc_lock_offset != UZERO && (proc_cwd_link_src[i] & MASK_ADD_64) == INST_ADD_64) {
      fs_struct_lock_offset = calculate_imm(proc_cwd_link_src[i], ARM64_ADD_64);
    } else if (task_struct_alloc_lock_offset != UZERO && (proc_cwd_link_src[i] & MASK_LDR_64_) == INST_LDR_64_) {
      task_struct_fs_offset = calculate_imm(proc_cwd_link_src[i], ARM64_LDR_64);
    } else if (task_struct_alloc_lock_offset == UZERO && (proc_cwd_link_src[i] & MASK_ADD_64) == INST_ADD_64) {
      task_struct_alloc_lock_offset = calculate_imm(proc_cwd_link_src[i], ARM64_ADD_64);
      // MOV (to/from SP) is an alias of ADD <Xd|SP>, <Xn|SP>, #0
      if (task_struct_alloc_lock_offset == 0) {
        task_struct_alloc_lock_offset = UZERO;
      }
    }
  }
#ifdef CONFIG_DEBUG
  logkm("task_struct_fs_offset=0x%llx\n", task_struct_fs_offset); // 0x7d0
  logkm("task_struct_alloc_lock_offset=0x%llx\n", task_struct_alloc_lock_offset); // 0x10
  logkm("fs_struct_pwd_offset=0x%llx\n", fs_struct_pwd_offset); // 0x28
  logkm("fs_struct_lock_offset=0x%llx\n", fs_struct_lock_offset); // 0x4
#endif /* CONFIG_DEBUG */
  if (task_struct_fs_offset == UZERO || task_struct_alloc_lock_offset == UZERO || fs_struct_pwd_offset == UZERO || fs_struct_lock_offset == UZERO) {
    return -11;
  }
  return 0;
}

static long inline_hook_init(const char* args, const char* event, void* __user reserved) {
  int rc = inline_hook_control0(args, NULL, NULL);
  if (rc < 0) {
    return rc;
  }

  kfunc_lookup_name(d_path);
  kfunc_lookup_name(kern_path);
  kfunc_lookup_name(_raw_spin_lock);
  kfunc_lookup_name(_raw_spin_unlock);
  rc = calculate_offsets();
  if (rc < 0) {
    return rc;
  }

  lookup_name(do_filp_open);
  hook_func(do_filp_open, 3, do_filp_open_before, do_filp_open_after, 0);
  return 0;
}

static long inline_hook_exit(void* __user reserved) {
  unhook_func(do_filp_open);
  return 0;
}

KPM_INIT(inline_hook_init);
KPM_CTL0(inline_hook_control0);
KPM_EXIT(inline_hook_exit);

```

`hosts_redirect/hosts_redirect.h`:

```h
#ifndef __HR_HOSTS_REDIRECT_H
#define __HR_HOSTS_REDIRECT_H

#include <ktypes.h>
#include <linux/llist.h>
#include <linux/spinlock.h>

#define HASH_LEN_DECLARE u32 hash; u32 len
#define DNAME_INLINE_LEN 32
#define LOOKUP_FOLLOW 0x0001

struct vfsmount {
  struct dentry* mnt_root;
  struct super_block* mnt_sb;
  int mnt_flags;
  struct user_namespace* mnt_userns;
  // unknow
};
struct hlist_bl_node {
  struct hlist_bl_node* next, ** pprev;
};
struct qstr {
  union {
    struct {
      HASH_LEN_DECLARE;
    };
    u64 hash_len;
  };
  const unsigned char* name;
};
struct dentry {
  unsigned int d_flags;
  spinlock_t d_seq;
  struct hlist_bl_node d_hash;
  struct dentry* d_parent;
  struct qstr d_name;
  struct inode* d_inode;
  unsigned char d_iname[DNAME_INLINE_LEN];
  // unknow
};

struct path {
  struct vfsmount* mnt;
  struct dentry* dentry;
};

struct file {
  union {
    struct llist_node    fu_llist;
    struct rcu_head      fu_rcuhead;
  } f_u;
  struct path     f_path;
  struct inode* f_inode;
  // unknow
};

struct fs_struct {
  int users;
  spinlock_t lock;
  spinlock_t seq;
  int umask;
  int in_exec;
  struct path root, pwd;
};

struct open_flags {
  int open_flag;
  umode_t mode;
  int acc_mode;
  int intent;
  int lookup_flags;
};

#endif /* __HR_HOSTS_REDIRECT_H */

```

`hosts_redirect/hr_utils.h`:

```h
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 bmax121. All Rights Reserved.
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */
#ifndef __HR_UTILS_H
#define __HR_UTILS_H

#include <hook.h>
#include <uapi/asm-generic/errno.h>

#define bits32(n, high, low) ((uint32_t)((n) << (31u - (high))) >> (31u - (high) + (low)))
#define bit(n, st) (((n) >> (st)) & 1)
#define sign64_extend(n, len) \
    (((uint64_t)((n) << (63u - (len - 1))) >> 63u) ? ((n) | (0xFFFFFFFFFFFFFFFF << (len))) : n)

typedef uint32_t inst_type_t;
typedef uint32_t inst_mask_t;

#define INST_ADD_64 0x91000000u
#define INST_ADD_64_X0 0x91000000u
#define INST_LDP_64_ 0xA9400000u
#define INST_LDR_64_ 0xF9400000u
#define INST_LDR_64_X0 0xF9400000u
#define INST_LDR_64_SP 0xF94003E0u
#define INST_LDRB 0x39400000u
#define INST_LDRH 0x79400000u
#define INST_TBZ 0x36000000u
#define INST_TBNZ 0x37000000u
#define INST_TBNZ_5 0x37280000u

#define MASK_ADD_64 0xFF800000u
#define MASK_ADD_64_X0 0xFF8003E0u
#define MASK_LDP_64_ 0xFFC00000u
#define MASK_LDR_64_ 0xFFC00000u
#define MASK_LDR_64_X0 0xFFC003E0u
#define MASK_LDR_64_SP 0xFFC003E0u
#define MASK_LDRB 0xFFC00000u
#define MASK_LDRH 0xFFC00000u
#define MASK_TBZ 0x7F000000u
#define MASK_TBNZ 0x7F000000u
#define MASK_TBNZ_5 0xFFF80000u

#define ARM64_RET 0xD65F03C0

#define logkm(fmt, ...) printk("hosts_redirect: " fmt, ##__VA_ARGS__)

#define lookup_name(func)                                  \
  func = 0;                                                \
  func = (typeof(func))kallsyms_lookup_name(#func);        \
  pr_info("kernel function %s addr: %llx\n", #func, func); \
  if (!func) {                                             \
    return -21;                                            \
  }

#define hook_func(func, argv, before, after, udata)                         \
  if (!func) {                                                              \
    return -22;                                                             \
  }                                                                         \
  hook_err_t hook_err_##func = hook_wrap(func, argv, before, after, udata); \
  if (hook_err_##func) {                                                    \
    func = 0;                                                               \
    pr_err("hook %s error: %d\n", #func, hook_err_##func);                  \
    return -23;                                                             \
  } else {                                                                  \
    pr_info("hook %s success\n", #func);                                    \
  }

#define unhook_func(func)              \
  if (func && !is_bad_address(func)) { \
    unhook(func);                      \
    func = 0;                          \
  }

enum inst_type {
  ARM64_ADD_64,
  ARM64_LDP_64,
  ARM64_LDR_64,
};

extern char* kfunc_def(d_path)(const struct path* path, char* buf, int buflen);
static inline char* d_path(const struct path* path, char* buf, int buflen) {
  kfunc_call(d_path, path, buf, buflen);
  kfunc_not_found();
  return NULL;
}

extern int kfunc_def(kern_path)(const char* name, unsigned int flags, struct path* path);
static inline int kern_path(const char* name, unsigned int flags, struct path* path) {
  kfunc_call(kern_path, name, flags, path);
  kfunc_not_found();
  return -ESRCH;
}

#endif /* __HR_UTILS_H */

```

`kpm_utils.h`:

```h
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 bmax121. All Rights Reserved.
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */
#ifndef _KPM_UTILS_H
#define _KPM_UTILS_H

#include <hook.h>
#include <linux/cred.h>
#include <linux/sched.h>

// hook
#define lookup_name(func)                                  \
  func = (typeof(func))kallsyms_lookup_name(#func);        \
  pr_info("kernel function %s addr: %llx\n", #func, func); \
  if (!func)                                               \
    return -21;

#define lookup_name_continue(func)                  \
  func = (typeof(func))kallsyms_lookup_name(#func); \
  pr_info("kernel function %s addr: %llx\n", #func, func);

#define hook_func(func, argv, before, after, udata)                         \
  if (!func)                                                                \
    return -22;                                                             \
  hook_err_t hook_err_##func = hook_wrap(func, argv, before, after, udata); \
  if (hook_err_##func) {                                                    \
    pr_err("hook %s error: %d\n", #func, hook_err_##func);                  \
    return -23;                                                             \
  } else {                                                                  \
    pr_info("hook %s success\n", #func);                                    \
  }

#define unhook_func(func)            \
  if (func && !is_bad_address(func)) \
    unhook(func);

// task id
#define __GET_CREDID(type, task)                                                             \
  ({                                                                                         \
    struct cred *cred = *(struct cred **)((uintptr_t)task + task_struct_offset.cred_offset); \
    kuid_t ___val = *(kuid_t *)((uintptr_t)cred + cred_offset.type##_offset);                \
    ___val;                                                                                  \
  })

#define task_uid(task) __GET_CREDID(uid, task)
#define task_gid(task) __GET_CREDID(gid, task)
#define task_euid(task) __GET_CREDID(euid, task)
#define task_egid(task) __GET_CREDID(egid, task)
#define task_suid(task) __GET_CREDID(suid, task)
#define task_sgid(task) __GET_CREDID(sgid, task)

// instruction
#define bits32(n, high, low) ((uint32_t)((n) << (31u - (high))) >> (31u - (high) + (low)))
#define bit(n, st) (((n) >> (st)) & 1)
#define sign64_extend(n, len) \
  (((uint64_t)((n) << (63u - (len - 1))) >> 63u) ? ((n) | (0xFFFFFFFFFFFFFFFF << (len))) : n)
// https://github.com/llvm/llvm-project/blob/f280d3b705de7f94ef9756e3ef2842b415a7c038/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AddressingModes.h#L293
#define ror(elt, size) (((elt) & 1) << ((size) - 1)) | ((elt) >> 1)

#define __INST_GET_IMM6(abbr) \
  static inline int inst_get_##abbr##_imm6(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 15, 10) : -1; }

#define __INST_GET_IMM12(abbr) \
  static inline int inst_get_##abbr##_imm12(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 21, 10) : -1; }
#define __INST_GET_SIZE_IMM12_IMM(abbr)                     \
  static inline long inst_get_##abbr##_imm(uint32_t code) { \
    if (!inst_is_##abbr(code))                              \
      return -1;                                            \
    int size = inst_get_##abbr##_size(code);                \
    int imm12 = inst_get_##abbr##_imm12(code);              \
    if (size == -1 || imm12 == -1)                          \
      return -1;                                            \
    return sign64_extend(((uint64_t)imm12 << size), 14u);   \
  }
#define __INST_GET_SH_IMM12_IMM(abbr)                                                                 \
  static inline long inst_get_##abbr##_imm(uint32_t code) {                                           \
    if (!inst_is_##abbr(code))                                                                        \
      return -1;                                                                                      \
    int sh = inst_get_##abbr##_sh(code);                                                              \
    int imm12 = inst_get_##abbr##_imm12(code);                                                        \
    if (sh == -1 || imm12 == -1)                                                                      \
      return -1;                                                                                      \
    return sh ? sign64_extend(((uint64_t)imm12 << 12u), 14u) : sign64_extend(((uint64_t)imm12), 14u); \
  }

#define __INST_GET_IMM14(abbr) \
  static inline int inst_get_##abbr##_imm14(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 18, 5) : -1; }
#define __INST_GET_IMM19(abbr) \
  static inline int inst_get_##abbr##_imm19(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 23, 5) : -1; }
#define __INST_GET_IMM26(abbr) \
  static inline int inst_get_##abbr##_imm26(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 25, 0) : -1; }

#define __INST_GET_N(abbr) \
  static inline int inst_get_##abbr##_n(uint32_t code) { return inst_is_##abbr(code) ? bit(code, 22) : -1; }
#define __INST_GET_IMMR(abbr) \
  static inline int inst_get_##abbr##_immr(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 21, 16) : -1; }
#define __INST_GET_IMMS(abbr) \
  static inline int inst_get_##abbr##_imms(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 15, 10) : -1; }
#define __INST_GET_IMMR_IMMS_IMM(abbr)                        \
  static inline long inst_get_##abbr##_imm(uint32_t code) {   \
    if (!inst_is_##abbr(code))                                \
      return -1;                                              \
    int sf = inst_get_##abbr##_sf(code);                      \
    int N = inst_get_##abbr##_n(code);                        \
    if (sf == 0 && N != 0)                                    \
      return -10;                                             \
    int immr = inst_get_##abbr##_immr(code);                  \
    int imms = inst_get_##abbr##_imms(code);                  \
    int len = 31 - __builtin_clz((N << 6) | (~imms & 0x3f));  \
    if (len < 0)                                              \
      return -11;                                             \
    int size = (1 << len);                                    \
    int R = immr & (size - 1);                                \
    int S = imms & (size - 1);                                \
    if (S == size - 1)                                        \
      return -12;                                             \
    long pattern = (1ULL << (S + 1)) - 1;                     \
    for (int i = 0; i < R; ++i) pattern = ror(pattern, size); \
    int regSize = (sf == 0) ? 32 : 64;                        \
    while (size != regSize) {                                 \
      pattern |= (pattern << size);                           \
      size *= 2;                                              \
    }                                                         \
    return pattern;                                           \
  }

#define __INST_GET_IMMLO(abbr) \
  static inline int inst_get_##abbr##_immlo(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 30, 29) : -1; }
#define __INST_GET_IMMHI(abbr) \
  static inline int inst_get_##abbr##_immhi(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 23, 5) : -1; }
#define __INST_GET_LABEL(abbr)                                  \
  static inline long inst_get_##abbr##_label(uint32_t code) {   \
    if (!inst_is_##abbr(code))                                  \
      return -1;                                                \
    int immlo = inst_get_##abbr##_immlo(code);                  \
    int immhi = inst_get_##abbr##_immhi(code);                  \
    if (immlo == -1 || immhi == -1)                             \
      return -1;                                                \
    return sign64_extend((immhi << 14u) | (immlo << 12u), 33u); \
  }

#define __INST_GET_SF(abbr) \
  static inline int inst_get_##abbr##_sf(uint32_t code) { return inst_is_##abbr(code) ? bit(code, 31) : -1; }
#define __INST_GET_SIZE(abbr) \
  static inline int inst_get_##abbr##_size(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 31, 30) : -1; }
#define __INST_GET_SH(abbr) \
  static inline int inst_get_##abbr##_sh(uint32_t code) { return inst_is_##abbr(code) ? bit(code, 22) : -1; }
#define __INST_GET_RM(abbr) \
  static inline int inst_get_##abbr##_rm(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 20, 16) : -1; }
#define __INST_GET_RN(abbr) \
  static inline int inst_get_##abbr##_rn(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 9, 5) : -1; }
#define __INST_GET_RD(abbr) \
  static inline int inst_get_##abbr##_rd(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 4, 0) : -1; }
#define __INST_GET_RT(abbr) \
  static inline int inst_get_##abbr##_rt(uint32_t code) { return inst_is_##abbr(code) ? bits32(code, 4, 0) : -1; }

#define __INST_FUNCS(abbr, mask, val)                                                   \
  static inline bool inst_is_##abbr(uint32_t code) { return (code & (mask)) == (val); } \
  static inline uint32_t inst_get_##abbr##_value(void) { return (val); }

#define __INST_SF_FUNCS(abbr, mask, val) \
  __INST_FUNCS(abbr, mask, val)          \
  __INST_GET_SF(abbr)
#define __INST_RN_FUNCS(abbr, mask, val) \
  __INST_FUNCS(abbr, mask, val)          \
  __INST_GET_RN(abbr)
#define __INST_RD_FUNCS(abbr, mask, val) \
  __INST_FUNCS(abbr, mask, val)          \
  __INST_GET_RD(abbr)

#define __INST_SF_RM_FUNCS(abbr, mask, val) \
  __INST_SF_FUNCS(abbr, mask, val)          \
  __INST_GET_RM(abbr)
#define __INST_SF_RM_RN_FUNCS(abbr, mask, val) \
  __INST_SF_RM_FUNCS(abbr, mask, val)          \
  __INST_GET_RN(abbr)
#define __INST_SF_RM_RD_FUNCS(abbr, mask, val) \
  __INST_SF_RM_FUNCS(abbr, mask, val)          \
  __INST_GET_RD(abbr)
#define __INST_SF_RM_RN_RD_FUNCS(abbr, mask, val) \
  __INST_SF_RM_RN_FUNCS(abbr, mask, val)          \
  __INST_GET_RD(abbr)

#define __INST_SF_RN_FUNCS(abbr, mask, val) \
  __INST_SF_FUNCS(abbr, mask, val)          \
  __INST_GET_RN(abbr)
#define __INST_SF_RN_RD_FUNCS(abbr, mask, val) \
  __INST_SF_RN_FUNCS(abbr, mask, val)          \
  __INST_GET_RD(abbr)
#define __INST_SF_RN_RD_SH_IMM12_FUNCS(abbr, mask, val) \
  __INST_SF_RN_RD_FUNCS(abbr, mask, val)                \
  __INST_GET_SH(abbr)                                   \
  __INST_GET_IMM12(abbr)                                \
  __INST_GET_SH_IMM12_IMM(abbr)

#define __INST_SF_RT_FUNCS(abbr, mask, val) \
  __INST_SF_FUNCS(abbr, mask, val)          \
  __INST_GET_RT(abbr)

#define __INST_SIZE_FUNCS(abbr, mask, val) \
  __INST_FUNCS(abbr, mask, val)            \
  __INST_GET_SIZE(abbr)
#define __INST_SIZE_RN_FUNCS(abbr, mask, val) \
  __INST_SIZE_FUNCS(abbr, mask, val)          \
  __INST_GET_RN(abbr)
#define __INST_SIZE_RN_RT_FUNCS(abbr, mask, val) \
  __INST_SIZE_RN_FUNCS(abbr, mask, val)          \
  __INST_GET_RT(abbr)
#define __INST_SIZE_RN_RT_IMM12_FUNCS(abbr, mask, val) \
  __INST_SIZE_RN_RT_FUNCS(abbr, mask, val)             \
  __INST_GET_IMM12(abbr)                               \
  __INST_GET_SIZE_IMM12_IMM(abbr)

#define __INST_SF_RN_RD_N_FUNCS(abbr, mask, val) \
  __INST_SF_RN_RD_FUNCS(abbr, mask, val)         \
  __INST_GET_N(abbr)                             \
  __INST_GET_IMMR(abbr)                          \
  __INST_GET_IMMS(abbr)                          \
  __INST_GET_IMMR_IMMS_IMM(abbr)
#define __INST_RD_IMMLO_IMMHI_FUNCS(abbr, mask, val) \
  __INST_RD_FUNCS(abbr, mask, val)                   \
  __INST_GET_IMMLO(abbr)                             \
  __INST_GET_IMMHI(abbr)                             \
  __INST_GET_LABEL(abbr)

__INST_SF_RN_RD_SH_IMM12_FUNCS(add_imm, 0x7F800000u, 0x11000000u)

__INST_SF_RN_RD_FUNCS(uxtb, 0xFFFFFC00u, 0x53001C00u)

__INST_RD_IMMLO_IMMHI_FUNCS(adrp, 0x9F000000u, 0x90000000u)

__INST_SF_RN_RD_N_FUNCS(and_imm, 0x7F800000u, 0x12000000u)
__INST_SF_RN_RD_N_FUNCS(tst_imm, 0x7F80001Fu, 0x7200001Fu)

__INST_FUNCS(bl, 0xFC000000u, 0x94000000u)
__INST_GET_IMM26(bl)

__INST_SF_RT_FUNCS(cbz, 0x7F000000u, 0x34000000u)
__INST_GET_IMM19(cbz)

__INST_SF_RT_FUNCS(tbnz, 0x7F000000u, 0x37000000u)
__INST_GET_IMM14(tbnz)

__INST_SIZE_RN_RT_IMM12_FUNCS(ldr_imm_uint, 0xBFC00000u, 0xB9400000u)
__INST_SIZE_RN_RT_IMM12_FUNCS(ldrh_imm_uint, 0xFFC00000u, 0x79400000u)
__INST_SIZE_RN_RT_IMM12_FUNCS(str_imm_uint, 0xBFC00000u, 0xB9000000u)
__INST_SIZE_RN_RT_IMM12_FUNCS(strb_imm_uint, 0xFFC00000u, 0x39000000u)

__INST_SF_RM_RD_FUNCS(mov_reg, 0x7FE0FFE0u, 0x2A0003E0u)

__INST_SF_RM_RN_RD_FUNCS(orr_reg, 0x7F200000u, 0x2A000000u)
__INST_GET_IMM6(orr_reg)

__INST_RN_FUNCS(ret, 0xFFFFFC1Fu, 0xD65F0000u)

// special
__INST_FUNCS(mrs_sp_el0, 0xFFFFFFE0u, 0xD5384100u)

#endif /* _KPM_UTILS_H */

```

`lmkd_dont_kill/Makefile`:

```
MYKPM_VERSION := 1.0.0

ifndef KP_DIR
    KP_DIR = ../KernelPatch
endif

OS_NAME = $(shell uname | tr A-Z a-z)
MACHINE = $(shell uname -m)
HOST_TAG = $(OS_NAME)-$(MACHINE)
ifeq ($(HOST_TAG), darwin-arm64)
    HOST_TAG = darwin-x86_64
endif
NDK_BIN_DIR := toolchains/llvm/prebuilt/$(HOST_TAG)/bin
ifdef ANDROID_NDK_LATEST_HOME
    NDK_PATH ?= $(ANDROID_NDK_LATEST_HOME)/$(NDK_BIN_DIR)
else ifdef ANDROID_NDK
    NDK_PATH ?= $(ANDROID_NDK)/$(NDK_BIN_DIR)
endif

ifdef TARGET_COMPILE
    CC := $(TARGET_COMPILE)gcc
    LD := $(TARGET_COMPILE)ld
else ifdef NDK_PATH
    CC := $(NDK_PATH)/aarch64-linux-android31-clang
    LD := $(NDK_PATH)/ld.lld
endif

CFLAGS = -Wall -O2 -fno-PIC -fno-asynchronous-unwind-tables -fno-stack-protector -fno-common -DMYKPM_VERSION=\"$(MYKPM_VERSION)$(MYKPM_VER)\"

INCLUDE_DIRS := . include patch/include linux/include linux/arch/arm64/include linux/tools/arch/arm64/include

INCLUDE_FLAGS := $(foreach dir,$(INCLUDE_DIRS),-I$(KP_DIR)/kernel/$(dir))

objs := lmkd_dont_kill.c

all: base

base: lmkd_dont_kill_$(MYKPM_VERSION).kpm

debug: CFLAGS += -DCONFIG_DEBUG
debug: MYKPM_VER := _d
debug: lmkd_dont_kill_$(MYKPM_VERSION)_debug.kpm

lmkd_dont_kill_$(MYKPM_VERSION).kpm: ${objs}
	${CC} $(CFLAGS) $(CFLAG) $(INCLUDE_FLAGS) $^ -r -o $@

lmkd_dont_kill_$(MYKPM_VERSION)_debug.kpm: ${objs}
	${CC} $(CFLAGS) $(CFLAG) $(INCLUDE_FLAGS) $^ -r -o $@

.PHONY: clean
clean:
	rm -rf *.kpm
	find . -name "*.o" | xargs rm -f

```

`lmkd_dont_kill/README.md`:

```md
# lmkd_dont_kill
## 模块作用
拦截所有 `lmkd` 发来的 `SIGKILL` 信号

## 更新记录
### 1.0.0
初始版本

```

`lmkd_dont_kill/lmkd_dont_kill.c`:

```c
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 bmax121. All Rights Reserved.
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */

#include <compiler.h>
#include <hook.h>
#include <kpmodule.h>
#include <kputils.h>
#include <taskext.h>
#include <linux/kernel.h>
#include <linux/printk.h>
#include <linux/string.h>
#include <uapi/asm-generic/errno.h>

#include "lmkd_dont_kill.h"

KPM_NAME("lmkd_dont_kill");
KPM_VERSION(MYKPM_VERSION);
KPM_LICENSE("GPL v2");
KPM_AUTHOR("lzghzr");
KPM_DESCRIPTION("lmkd_dont_kill");

#define MIN_SYSTEM_UID 1000
#define MIN_USERAPP_UID 10000

// hook do_send_sig_info
static int (*do_send_sig_info)(int sig, struct siginfo* info, struct task_struct* p, enum pid_type type);

char lmkd[] = "lmkd";
static void do_send_sig_info_before(hook_fargs4_t* args, void* udata) {
  int sig = (int)args->arg0;
  struct kernel_siginfo* siginfo = (struct kernel_siginfo*)args->arg1;
  struct task_struct* dst = (struct task_struct*)args->arg2;

  if (sig != SIGKILL || siginfo->si_code != 0)
    return;

  const char* comm = get_task_comm(current);
  if (!memcmp(comm, lmkd, sizeof(lmkd) - 1)) {
    args->ret = -EPERM;
    args->skip_origin = true;
  }
}

static long inline_hook_init(const char* args, const char* event, void* __user reserved) {
  lookup_name(do_send_sig_info);
  hook_func(do_send_sig_info, 4, do_send_sig_info_before, 0, 0);

  return 0;
}

static long inline_hook_control0(const char* ctl_args, char* __user out_msg, int outlen) {
  char msg[64];
  snprintf(msg, sizeof(msg), "_(._.)_");
  compat_copy_to_user(out_msg, msg, sizeof(msg));
  return 0;
}

static long inline_hook_exit(void* __user reserved) {
  unhook_func(do_send_sig_info);

  return 0;
}

KPM_INIT(inline_hook_init);
KPM_CTL0(inline_hook_control0);
KPM_EXIT(inline_hook_exit);

```

`lmkd_dont_kill/lmkd_dont_kill.h`:

```h
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 bmax121. All Rights Reserved.
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */
#ifndef __LMKD_DONT_KILL_H
#define __LMKD_DONT_KILL_H

#include <hook.h>
#include <ksyms.h>
#include <linux/cred.h>
#include <linux/sched.h>

#define logkm(fmt, ...) printk("lmkd_dont_kill: " fmt, ##__VA_ARGS__)

#define lookup_name(func)                                  \
  func = 0;                                                \
  func = (typeof(func))kallsyms_lookup_name(#func);        \
  pr_info("kernel function %s addr: %llx\n", #func, func); \
  if (!func)                                               \
  {                                                        \
    return -21;                                            \
  }

#define hook_func(func, argv, before, after, udata)                         \
  if (!func)                                                                \
  {                                                                         \
    return -22;                                                             \
  }                                                                         \
  hook_err_t hook_err_##func = hook_wrap(func, argv, before, after, udata); \
  if (hook_err_##func)                                                      \
  {                                                                         \
    func = 0;                                                               \
    pr_err("hook %s error: %d\n", #func, hook_err_##func);                  \
    return -23;                                                             \
  }                                                                         \
  else                                                                      \
  {                                                                         \
    pr_info("hook %s success\n", #func);                                    \
  }

#define unhook_func(func)            \
  if (func && !is_bad_address(func)) \
  {                                  \
    unhook(func);                    \
    func = 0;                        \
  }

#define task_uid(task) task_real_uid(task)
  // ({                                                                                         \
  //   struct cred *cred = *(struct cred **)((uintptr_t)task + task_struct_offset.cred_offset); \
  //   kuid_t ___val = *(kuid_t *)((uintptr_t)cred + cred_offset.uid_offset);                   \
  //   ___val;                                                                                  \
  // })

#define task_real_uid(task)                                                                       \
  ({                                                                                              \
    struct cred *cred = *(struct cred **)((uintptr_t)task + task_struct_offset.real_cred_offset); \
    kuid_t ___val = *(kuid_t *)((uintptr_t)cred + cred_offset.uid_offset);                        \
    ___val;                                                                                       \
  })


// uapi/asm/signal.h
#define SIGKILL 9
struct siginfo;

// linux/signal_types.h
#define __SIGINFO \
struct {          \
	int si_signo; \
	int si_errno; \
	int si_code;  \
}
typedef struct kernel_siginfo {
  __SIGINFO;
} kernel_siginfo_t;

#endif /* __LMKD_DONT_KILL_H */

```

`qti_battery_charger/Makefile`:

```
QBC_VERSION := 1.0.2

ifndef KP_DIR
    KP_DIR = ../KernelPatch
endif

OS_NAME = $(shell uname | tr A-Z a-z)
MACHINE = $(shell uname -m)
HOST_TAG = $(OS_NAME)-$(MACHINE)
ifeq ($(HOST_TAG), darwin-arm64)
    HOST_TAG = darwin-x86_64
endif
NDK_BIN_DIR := toolchains/llvm/prebuilt/$(HOST_TAG)/bin
ifdef ANDROID_NDK_LATEST_HOME
    NDK_PATH ?= $(ANDROID_NDK_LATEST_HOME)/$(NDK_BIN_DIR)
else ifdef ANDROID_NDK
    NDK_PATH ?= $(ANDROID_NDK)/$(NDK_BIN_DIR)
endif

ifdef TARGET_COMPILE
    CC := $(TARGET_COMPILE)gcc
    LD := $(TARGET_COMPILE)ld
else ifdef NDK_PATH
    CC := $(NDK_PATH)/aarch64-linux-android31-clang
    LD := $(NDK_PATH)/ld.lld
endif

CFLAGS = -Wall -O2 -fno-PIC -fno-asynchronous-unwind-tables -fno-stack-protector -fno-common -DQBC_VERSION=\"$(QBC_VERSION)$(QBC_VER)\"

INCLUDE_DIRS := . include patch/include linux/include linux/arch/arm64/include linux/tools/arch/arm64/include

INCLUDE_FLAGS := $(foreach dir,$(INCLUDE_DIRS),-I$(KP_DIR)/kernel/$(dir))

objs := qti_battery_charger.o

all: qti_battery_charger_$(QBC_VERSION).kpm

debug: CFLAGS += -DDEBUG
debug: QBC_VER := _d
debug: qti_battery_charger_$(QBC_VERSION)_debug.kpm

qti_battery_charger_$(QBC_VERSION).kpm: ${objs}
	${CC} -r -o $@ $^

qti_battery_charger_$(QBC_VERSION)_debug.kpm: ${objs}
	${CC} -r -o $@ $^

%.o: %.c
	${CC} $(CFLAGS) $(INCLUDE_FLAGS) -c -o $@ $<

.PHONY: clean
clean:
	rm -rf *.kpm
	find . -name "*.o" | xargs rm -f

```

`qti_battery_charger/battchg.h`:

```h
/* linux/power_supply.h */

enum power_supply_property
{
	/* Properties of type `int' */
	POWER_SUPPLY_PROP_STATUS = 0,
	POWER_SUPPLY_PROP_CHARGE_TYPE,
	POWER_SUPPLY_PROP_HEALTH,
	POWER_SUPPLY_PROP_PRESENT,
	POWER_SUPPLY_PROP_ONLINE,
	POWER_SUPPLY_PROP_AUTHENTIC,
	POWER_SUPPLY_PROP_TECHNOLOGY,
	POWER_SUPPLY_PROP_CYCLE_COUNT,
	POWER_SUPPLY_PROP_VOLTAGE_MAX,
	POWER_SUPPLY_PROP_VOLTAGE_MIN,
	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
	POWER_SUPPLY_PROP_VOLTAGE_NOW,
	POWER_SUPPLY_PROP_VOLTAGE_AVG,
	POWER_SUPPLY_PROP_VOLTAGE_OCV,
	POWER_SUPPLY_PROP_VOLTAGE_BOOT,
	POWER_SUPPLY_PROP_CURRENT_MAX,
	POWER_SUPPLY_PROP_CURRENT_NOW,
	POWER_SUPPLY_PROP_CURRENT_AVG,
	POWER_SUPPLY_PROP_CURRENT_BOOT,
	POWER_SUPPLY_PROP_POWER_NOW,
	POWER_SUPPLY_PROP_POWER_AVG,
	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
	POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN,
	POWER_SUPPLY_PROP_CHARGE_FULL,
	POWER_SUPPLY_PROP_CHARGE_EMPTY,
	POWER_SUPPLY_PROP_CHARGE_NOW,
	POWER_SUPPLY_PROP_CHARGE_AVG,
	POWER_SUPPLY_PROP_CHARGE_COUNTER,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_START_THRESHOLD, /* in percents! */
	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD,	  /* in percents! */
	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
	POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT,
	POWER_SUPPLY_PROP_INPUT_POWER_LIMIT,
	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
	POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN,
	POWER_SUPPLY_PROP_ENERGY_FULL,
	POWER_SUPPLY_PROP_ENERGY_EMPTY,
	POWER_SUPPLY_PROP_ENERGY_NOW,
	POWER_SUPPLY_PROP_ENERGY_AVG,
	POWER_SUPPLY_PROP_CAPACITY,				 /* in percents! */
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN,	 /* in percents! */
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX,	 /* in percents! */
	POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN, /* in percents! */
	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
	POWER_SUPPLY_PROP_TEMP,
	POWER_SUPPLY_PROP_TEMP_MAX,
	POWER_SUPPLY_PROP_TEMP_MIN,
	POWER_SUPPLY_PROP_TEMP_ALERT_MIN,
	POWER_SUPPLY_PROP_TEMP_ALERT_MAX,
	POWER_SUPPLY_PROP_TEMP_AMBIENT,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG,
	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG,
	POWER_SUPPLY_PROP_TYPE, /* use power_supply.type instead */
	POWER_SUPPLY_PROP_USB_TYPE,
	POWER_SUPPLY_PROP_SCOPE,
	POWER_SUPPLY_PROP_PRECHARGE_CURRENT,
	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,
	POWER_SUPPLY_PROP_CALIBRATE,
	POWER_SUPPLY_PROP_MANUFACTURE_YEAR,
	POWER_SUPPLY_PROP_MANUFACTURE_MONTH,
	POWER_SUPPLY_PROP_MANUFACTURE_DAY,
	/* Properties of type `const char *' */
	POWER_SUPPLY_PROP_MODEL_NAME,
	POWER_SUPPLY_PROP_MANUFACTURER,
	POWER_SUPPLY_PROP_SERIAL_NUMBER,
};

enum battery_property_id
{
	BATT_STATUS,
	BATT_HEALTH,
	BATT_PRESENT,
	BATT_CHG_TYPE,
	BATT_CAPACITY,
	BATT_SOH,
	BATT_VOLT_OCV,
	BATT_VOLT_NOW,
	BATT_VOLT_MAX,
	BATT_CURR_NOW,
	BATT_CHG_CTRL_LIM,
	BATT_CHG_CTRL_LIM_MAX,
	BATT_TEMP,
	BATT_TECHNOLOGY,
	BATT_CHG_COUNTER,
	BATT_CYCLE_COUNT,
	BATT_CHG_FULL_DESIGN,
	BATT_CHG_FULL,
	BATT_MODEL_NAME,
	BATT_TTF_AVG,
	BATT_TTE_AVG,
	BATT_RESISTANCE,
	BATT_POWER_NOW,
	BATT_POWER_AVG,
	BATT_PROP_MAX,
};

union power_supply_propval
{
	int intval;
	const char *strval;
};

struct power_supply
{
	const struct power_supply_desc *desc;
	char **supplied_to;
	size_t num_supplicants;

	char **supplied_from;
	size_t num_supplies;
	struct device_node *of_node;
	/* Driver private data */
	struct battery_chg_dev *bcdev;
};

/* linux/module.h */

enum module_state
{
	MODULE_STATE_LIVE,	   /* Normal state. */
	MODULE_STATE_COMING,   /* Full formed, running module_init. */
	MODULE_STATE_GOING,	   /* Going away. */
	MODULE_STATE_UNFORMED, /* Still setting it up. */
};

struct module
{
	enum module_state state;
	/* Member of list of modules */
	struct list_head list;
	/* Unique handle for this module */
	char name[64 - sizeof(unsigned long)];
};

```

`qti_battery_charger/qbc_utils.h`:

```h
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 bmax121. All Rights Reserved.
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */
#ifndef __QBC_UTILS_H
#define __QBC_UTILS_H

#include <hook.h>
#include <ksyms.h>
#include <linux/cred.h>
#include <linux/sched.h>
#include <uapi/asm-generic/errno.h>

#define lookup_name(func)                                  \
  func = 0;                                                \
  func = (typeof(func))kallsyms_lookup_name(#func);        \
  pr_info("kernel function %s addr: %llx\n", #func, func); \
  if (!func)                                               \
  {                                                        \
    return -21;                                            \
  }

#define hook_func(func, argv, before, after, udata)                         \
  if (!func)                                                                \
  {                                                                         \
    return -22;                                                             \
  }                                                                         \
  hook_err_t hook_err_##func = hook_wrap(func, argv, before, after, udata); \
  if (hook_err_##func)                                                      \
  {                                                                         \
    func = 0;                                                               \
    pr_err("hook %s error: %d\n", #func, hook_err_##func);                  \
    return -23;                                                             \
  }                                                                         \
  else                                                                      \
  {                                                                         \
    pr_info("hook %s success\n", #func);                                    \
  }

#define unhook_func(func)            \
  if (func && !is_bad_address(func)) \
  {                                  \
    unhook(func);                    \
    func = 0;                        \
  }

#endif /* __QBC_UTILS_H */

```

`qti_battery_charger/qti_battery_charger.c`:

```c
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */

#include <compiler.h>
#include <hook.h>
#include <kpmodule.h>
#include <kputils.h>
#include <linux/printk.h>
#include <linux/string.h>

#include "qbc_utils.h"
#include "battchg.h"

KPM_NAME("qti_battery_charger");
KPM_VERSION(QBC_VERSION);
KPM_LICENSE("GPL v2");
KPM_AUTHOR("lzghzr");
KPM_DESCRIPTION("set battery_psy_get_prop value");

int (*do_init_module)(struct module* mod) = 0;
int (*battery_psy_get_prop)(struct power_supply* psy, enum power_supply_property prop, union power_supply_propval* pval) = 0;

char MODULE_NAME[] = "qti_battery_charger";
char MODEL_NAME[] = "SNYSCA6";

void battery_psy_get_prop_after(hook_fargs3_t* args, void* udata) {
  enum power_supply_property prop = args->arg1;
  union power_supply_propval* pval = (typeof(pval))args->arg2;

  switch (prop) {
  // case POWER_SUPPLY_PROP_CYCLE_COUNT:
  //   pval->intval = 1;
  //   break;
  // case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
  // case POWER_SUPPLY_PROP_CHARGE_FULL:
  //   pval->intval = 5000000;
  //   break;
  case POWER_SUPPLY_PROP_CAPACITY:
    if (pval->intval < 10) {
      pval->intval = 10;
    }
    break;
  case POWER_SUPPLY_PROP_MODEL_NAME:
    memcpy((char*)pval->strval, MODEL_NAME, sizeof(MODEL_NAME));
    break;
  default:
    break;
  }
}

static long hook_battery_psy_get_prop() {
  battery_psy_get_prop = 0;
  battery_psy_get_prop = (typeof(battery_psy_get_prop))kallsyms_lookup_name("battery_psy_get_prop");
  pr_info("kernel function battery_psy_get_prop addr: %llx\n", battery_psy_get_prop);
  if (!battery_psy_get_prop) {
    return -1;
  }

  hook_func(battery_psy_get_prop, 3, NULL, battery_psy_get_prop_after, NULL);

  return 0;
}

void do_init_module_after(hook_fargs1_t* args, void* udata) {
  struct module* mod = (typeof(mod))args->arg0;
  if (unlikely(!memcmp(mod->name, MODULE_NAME, sizeof(MODULE_NAME)))) {
    unhook_func(do_init_module);
    hook_battery_psy_get_prop();
  }
}

static long hook_do_init_module() {
  do_init_module = 0;
  do_init_module = (typeof(do_init_module))kallsyms_lookup_name("do_init_module");
  pr_info("kernel function do_init_module addr: %llx\n", do_init_module);
  if (!do_init_module) {
    return -1;
  }

  hook_err_t err = hook_wrap1(do_init_module, 0, do_init_module_after, 0);
  if (err) {
    pr_err("hook do_init_module after error: %d\n", err);
    return -2;
  } else {
    pr_info("hook do_init_module after success\n");
  }
  return 0;
}

static long inline_hook_init(const char* args, const char* event, void* __user reserved) {
  int rc;
  rc = hook_battery_psy_get_prop();
  if (rc < 0) {
    rc = hook_do_init_module();
    if (rc < 0) {
      return rc;
    }
  }
  return 0;
}

static long inline_hook_exit(void* __user reserved) {
  unhook_func(do_init_module);
  unhook_func(battery_psy_get_prop);
  return 0;
}

KPM_INIT(inline_hook_init);
KPM_EXIT(inline_hook_exit);

```

`re_kernel/Makefile`:

```
MYKPM_VERSION := 7.6.0

ifndef KP_DIR
	KP_DIR = ../KernelPatch
endif

OS_NAME = $(shell uname | tr A-Z a-z)
MACHINE = $(shell uname -m)
HOST_TAG = $(OS_NAME)-$(MACHINE)
ifeq ($(HOST_TAG), darwin-arm64)
	HOST_TAG = darwin-x86_64
endif
NDK_BIN_DIR := toolchains/llvm/prebuilt/$(HOST_TAG)/bin
ifdef ANDROID_NDK_LATEST_HOME
	NDK_PATH ?= $(ANDROID_NDK_LATEST_HOME)/$(NDK_BIN_DIR)
else ifdef ANDROID_NDK
	NDK_PATH ?= $(ANDROID_NDK)/$(NDK_BIN_DIR)
endif

ifdef TARGET_COMPILE
	CC := $(TARGET_COMPILE)gcc
	LD := $(TARGET_COMPILE)ld
else ifdef NDK_PATH
	CC := $(NDK_PATH)/aarch64-linux-android31-clang
	LD := $(NDK_PATH)/ld.lld
endif

CFLAGS = -Wall -O2 -fno-PIC -fno-asynchronous-unwind-tables -fno-stack-protector -fno-common -DMYKPM_VERSION=\"$(MYKPM_VERSION)$(MYKPM_VER)\"

INCLUDE_DIRS := . include patch/include linux/include linux/arch/arm64/include linux/tools/arch/arm64/include

INCLUDE_FLAGS := $(foreach dir,$(INCLUDE_DIRS),-I$(KP_DIR)/kernel/$(dir))

objs := re_kernel.c

all: base network
debug: base_debug network_debug

base: re_kernel_$(MYKPM_VERSION).kpm

network: CFLAGS += -DCONFIG_NETWORK
network: MYKPM_VER := _n
network: re_kernel_$(MYKPM_VERSION)_network.kpm

base_debug: CFLAGS += -DCONFIG_DEBUG
base_debug: MYKPM_VER := _d
base_debug: re_kernel_$(MYKPM_VERSION)_debug.kpm

network_debug: CFLAGS += -DCONFIG_NETWORK -DCONFIG_DEBUG
network_debug: MYKPM_VER := _nd
network_debug: re_kernel_$(MYKPM_VERSION)_network_debug.kpm

re_kernel_$(MYKPM_VERSION).kpm: ${objs}
	${CC} $(CFLAGS) $(CFLAG) $(INCLUDE_FLAGS) $^ -r -o $@

re_kernel_$(MYKPM_VERSION)_network.kpm: ${objs}
	${CC} $(CFLAGS) $(CFLAG) $(INCLUDE_FLAGS) $^ -r -o $@

re_kernel_$(MYKPM_VERSION)_debug.kpm: ${objs}
	${CC} $(CFLAGS) $(CFLAG) $(INCLUDE_FLAGS) $^ -r -o $@

re_kernel_$(MYKPM_VERSION)_network_debug.kpm: ${objs}
	${CC} $(CFLAGS) $(CFLAG) $(INCLUDE_FLAGS) $^ -r -o $@

.PHONY: clean
clean:
	rm -rf *.kpm
	find . -name "*.o" | xargs rm -f

```

`re_kernel/README.md`:

```md
# re_kernel
## 模块作用
配合墓碑模块，当应用收到 `binder` 同步信息时，临时解冻被冻结的应用

## 更新记录
### 7.6.0
过滤更多网络包
### 7.5.1
更加严谨的处理netlink消息
### 7.5.0
增加netlink消息处理，支持通过消息移除/proc/rekernel
### 7.0.1
适配更多内核
### 7.0.0
PACKET_SIZE 从 128 增加到 256<br />
异步 netlink_kmsg 新增 `rpc_name` 和 `code` 字段
### 6.0.14
新增 netlink hello<br />
### 6.0.13
修复 6.0.12 引入的错误
### 6.0.12
修复 binder_stats_deleted(BINDER_STAT_TRANSACTION) 地址错误<br />
理论上支持 6.6
### 6.0.11
修复 lineage-22.1-4.19 内核崩溃问题
### 6.0.10
支持 `Harmony` 内核
### 6.0.9
同步LKM<br />
保留最早的异步消息
### 6.0.8
由于 4.x 和 5.x 版本差异过大, 去除 /proc/rekernel/ 的读写权限<br />
更加小心的清理过时消息<br />
支持 6.1
### 6.0.7
为了兼容5.4内核, 不再增加 TF_UPDATE_TXN
### 6.0.6
优化 binder 被冻结时的体验
### 6.0.5
变更 binder_proc->context 的搜索条件<br />
变更 task_struct->jobctl 获取方式<br />
移除 frozen()<br />
binder 被冻结时不再有动作
### 6.0.4
再次扩大 binder_proc->alloc 的搜索范围
### 6.0.3
修复 4.4 内核清理过时消息时卡死
### 6.0.2
修复某些内核函数过长导致的加载失败
### 6.0.1
将网络解冻 hook 点从 ip 层变更为 tcp 层
### 6.0.0
新增网络解冻, 同步版本号
### 1.4.0.4
函数版本判断条件由内核版本判断改为分析函数参数
### 1.4.0.3
解决应用长时间冻结后, 唤醒重载的问题
### 1.4.0.2
变更 hook 函数, 使其适配更多内核
### 1.4.0.1
修复偏移计算错误, 增加 README
### 1.4.0.0
同步官方 kpm 仓库，尝试更换编译器
### 1.3.6.5
CGRP_FREEZE 支持改为可选项，因为 4.14 及以下内核不支持此功能
### 1.3.6.4
修复对 5.4 的支持<br />
模块依然支持 4.4，但加载时会判断是否支持 `freeze`，如果内核不支持此功能则无法加载
### 1.3.6.3
将线程休眠判断逻辑从 `hans` 改为 `millet`<br />
增加 `quiet` 版，大幅减少唤醒次数
### 1.3.6.2
修复 `f_p` 重启失效
### 1.3.6.1
变更休眠线程判断条件
### 1.3.6.0
同步 Kernel.Modifier.v3.6，版本号也同步一下

```

`re_kernel/re_kernel.c`:

```c
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 bmax121. All Rights Reserved.
 */

/*   SPDX-License-Identifier: GPL-3.0-only   */
/*
 * Copyright (C) 2024 Nep-Timeline. All Rights Reserved.
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */

#include "re_kernel.h"

#include <asm/atomic.h>
#include <compiler.h>
#include <kpmodule.h>
#include <kputils.h>
#include <linux/kernel.h>
#include <linux/printk.h>
#include <linux/slab.h>
#include <linux/string.h>
#include <taskext.h>

#include "../kpm_utils.h"
#include "re_utils.h"

KPM_NAME("re_kernel");
KPM_VERSION(MYKPM_VERSION);
KPM_LICENSE("GPL v3");
KPM_AUTHOR("Nep-Timeline, lzghzr");
KPM_DESCRIPTION("Re:Kernel, support 4.4 ~ 6.6");

#define NETLINK_REKERNEL_MAX 26
#define NETLINK_REKERNEL_MIN 22
#define USER_PORT 100
#define PACKET_SIZE 256
#define MIN_USERAPP_UID 10000
#define MAX_SYSTEM_UID 2000
#define PARCEL_OFFSET 16
#define INTERFACETOKEN_BUFF_SIZE 140

enum report_type {
  BINDER,
  SIGNAL,
#ifdef CONFIG_NETWORK
  NETWORK,
#endif /* CONFIG_NETWORK */
};
enum binder_type {
  REPLY,
  TRANSACTION,
  OVERFLOW,
};
static const char* binder_type[] = {
    "reply",
    "transaction",
    "free_buffer_full",
};

#define IZERO (1UL << 0x10)
#define UZERO (1UL << 0x20)

// cgroup_freezing, cgroupv1_freeze
static bool (*cgroup_freezing)(struct task_struct* task);
// send_netlink_message
struct sk_buff* kfunc_def(__alloc_skb)(unsigned int size, gfp_t gfp_mask, int flags, int node);
struct nlmsghdr* kfunc_def(__nlmsg_put)(struct sk_buff* skb, u32 portid, u32 seq, int type, int len, int flags);
void kfunc_def(kfree_skb)(struct sk_buff* skb);
int kfunc_def(netlink_unicast)(struct sock* ssk, struct sk_buff* skb, u32 portid, int nonblock);
// netlink_rcv
int kfunc_def(netlink_rcv_skb)(struct sk_buff* skb,
                               int (*cb)(struct sk_buff*, struct nlmsghdr*, struct netlink_ext_ack*));
// start_rekernel_server
static struct net kvar_def(init_net);
struct sock* kfunc_def(__netlink_kernel_create)(struct net* net, int unit, struct module* module,
                                                struct netlink_kernel_cfg* cfg);
void kfunc_def(netlink_kernel_release)(struct sock* sk);
// prco
struct proc_dir_entry* kfunc_def(proc_mkdir)(const char* name, struct proc_dir_entry* parent);
struct proc_dir_entry* kfunc_def(proc_create_data)(const char* name, umode_t mode, struct proc_dir_entry* parent,
                                                   const struct file_operations* proc_fops, void* data);
void kfunc_def(proc_remove)(struct proc_dir_entry* de);
// hook binder_proc_transaction
static int (*binder_proc_transaction)(struct binder_transaction* t, struct binder_proc* proc,
                                      struct binder_thread* thread);
// free the outdated transaction and buffer
static void (*binder_transaction_buffer_release)(struct binder_proc* proc, struct binder_thread* thread,
                                                 struct binder_buffer* buffer, binder_size_t off_end_offset,
                                                 bool is_failure);
static void (*binder_transaction_buffer_release_v6)(struct binder_proc* proc, struct binder_thread* thread,
                                                    struct binder_buffer* buffer, binder_size_t failed_at,
                                                    bool is_failure);
static void (*binder_transaction_buffer_release_v4)(struct binder_proc* proc, struct binder_buffer* buffer,
                                                    binder_size_t failed_at, bool is_failure);
static void (*binder_transaction_buffer_release_v3)(struct binder_proc* proc, struct binder_buffer* buffer,
                                                    binder_size_t* failed_at);
static void (*binder_alloc_free_buf)(struct binder_alloc* alloc, struct binder_buffer* buffer);
void kfunc_def(kfree)(const void* objp);
struct binder_stats kvar_def(binder_stats);
// hook do_send_sig_info
static int (*do_send_sig_info)(int sig, struct siginfo* info, struct task_struct* p, enum pid_type type);
// hook binder_transaction
static void (*binder_transaction)(struct binder_proc* proc, struct binder_thread* thread,
                                  struct binder_transaction_data* tr, int reply, binder_size_t extra_buffers_size);
// copy_from_user
void* kfunc_def(memdup_user)(const void __user* src, size_t len);
void kfunc_def(kvfree)(const void* addr);

#ifdef CONFIG_NETWORK
// netfilter
kuid_t kfunc_def(sock_i_uid)(struct sock* sk);
// hook tcp_rcv
static int (*tcp_v4_do_rcv)(struct sock* sk, struct sk_buff* skb);
static int (*tcp_v6_do_rcv)(struct sock* sk, struct sk_buff* skb);
static int ipv4_version = 4, ipv6_version = 6;
#endif /* CONFIG_NETWORK */

// _raw_spin_lock && _raw_spin_unlock
void kfunc_def(_raw_spin_lock)(raw_spinlock_t* lock);
void kfunc_def(_raw_spin_unlock)(raw_spinlock_t* lock);
// trace
int kfunc_def(tracepoint_probe_register)(struct tracepoint* tp, void* probe, void* data);
int kfunc_def(tracepoint_probe_unregister)(struct tracepoint* tp, void* probe, void* data);
// trace_binder_transaction
struct tracepoint kvar_def(__tracepoint_binder_transaction);
#ifdef CONFIG_DEBUG_CMDLINE
int kfunc_def(get_cmdline)(struct task_struct* task, char* buffer, int buflen);
#endif /* CONFIG_DEBUG_CMDLINE */

// 最好初始化一个大于 0xFFFFFFFF 的值, 否则编译器优化后, 全局变量可能出错
// 实际上会被编译器优化为 bool
static uint64_t binder_transaction_buffer_release_ver6 = UZERO, binder_transaction_buffer_release_ver5 = UZERO,
                binder_transaction_buffer_release_ver4 = UZERO;

static unsigned long trace = UZERO, ext_tr_offset = UZERO;

struct struct_offset struct_offset = {};
#include "re_offsets.c"

// binder_node_lock
static inline void binder_node_lock(struct binder_node* node) {
  spinlock_t* node_lock = binder_node_lock_ptr(node);
  spin_lock(node_lock);
}
// binder_node_unlock
static inline void binder_node_unlock(struct binder_node* node) {
  spinlock_t* node_lock = binder_node_lock_ptr(node);
  spin_unlock(node_lock);
}
// binder_inner_proc_lock
static inline void binder_inner_proc_lock(struct binder_proc* proc) {
  spinlock_t* inner_lock = binder_proc_inner_lock(proc);
  spin_lock(inner_lock);
}
// binder_inner_proc_unlock
static inline void binder_inner_proc_unlock(struct binder_proc* proc) {
  spinlock_t* inner_lock = binder_proc_inner_lock(proc);
  spin_unlock(inner_lock);
}

// binder_is_frozen
static inline bool binder_is_frozen(struct binder_proc* proc) {
  bool is_frozen = false;
  if (struct_offset.binder_proc_is_frozen > 0) {
    is_frozen = binder_proc_is_frozen(proc);
  }
  return is_frozen;
}

// cgroupv2_freeze
static inline bool jobctl_frozen(struct task_struct* task) {
  unsigned long jobctl = task_jobctl(task);
  return ((jobctl & JOBCTL_TRAP_FREEZE) != 0);
}
// 判断线程是否进入 frozen 状态
static inline bool frozen_task_group(struct task_struct* task) {
  return (jobctl_frozen(task) || cgroup_freezing(task));
}

// netlink
static struct sock* rekernel_netlink;
static unsigned long rekernel_netlink_unit = UZERO;
static struct proc_dir_entry *rekernel_dir, *rekernel_unit_entry;
static const struct file_operations rekernel_unit_fops = {};
// 发送 netlink 消息
static int send_netlink_message(char* msg) {
  int len = strlen(msg);
  struct sk_buff* skbuffer;
  struct nlmsghdr* nlhdr;

  skbuffer = nlmsg_new(len, GFP_ATOMIC);
  if (!skbuffer) {
    logkm("netlink alloc failure.\n");
    return -ENOMEM;
  }

  nlhdr = nlmsg_put(skbuffer, 0, 0, rekernel_netlink_unit, len, 0);
  if (!nlhdr) {
    logkm("nlmsg_put failaure.\n");
    nlmsg_free(skbuffer);
    return -EMSGSIZE;
  }

  memcpy(nlmsg_data(nlhdr), msg, len);
  return netlink_unicast(rekernel_netlink, skbuffer, USER_PORT, MSG_DONTWAIT);
}
// 接收 netlink 消息
static int netlink_rcv_msg(struct sk_buff* skb, struct nlmsghdr* nlh, struct netlink_ext_ack* extack) {
  char* umsg = nlmsg_data(nlh);
  if (!umsg)
    return -EINVAL;

#ifdef CONFIG_DEBUG
  logkm("kernel recv packet from user: %s\n", umsg);
#endif /* CONFIG_DEBUG */

  if (!memcmp(umsg, "#proc_remove", nlmsg_len(nlh))) {
    if (rekernel_dir) {
      proc_remove(rekernel_dir);
    }
  }
  return 0;
}
static void netlink_rcv(struct sk_buff* skb) { netlink_rcv_skb(skb, &netlink_rcv_msg); }
// 创建 netlink 服务
static int start_rekernel_server(void) {
  if (rekernel_netlink_unit != UZERO)
    return 0;
  struct netlink_kernel_cfg rekernel_cfg = {
      .input = netlink_rcv,
  };

  for (rekernel_netlink_unit = NETLINK_REKERNEL_MAX; rekernel_netlink_unit >= NETLINK_REKERNEL_MIN;
       rekernel_netlink_unit--) {
    rekernel_netlink = netlink_kernel_create(kvar(init_net), rekernel_netlink_unit, &rekernel_cfg);
    if (rekernel_netlink != NULL)
      break;
  }
  if (rekernel_netlink == NULL) {
    rekernel_netlink_unit = UZERO;
    logkm("Failed to create Re:Kernel server!\n");
    return -ENOBUFS;
  }
  logkm("Created Re:Kernel server! NETLINK UNIT: %d\n", rekernel_netlink_unit);

  rekernel_dir = proc_mkdir("rekernel", NULL);
  if (!rekernel_dir) {
    logkm("create /proc/rekernel failed!\n");
  } else {
    char buff[32];
    sprintf(buff, "%d", rekernel_netlink_unit);
    rekernel_unit_entry = proc_create(buff, 0400, rekernel_dir, &rekernel_unit_fops);
    if (!rekernel_unit_entry) {
      logkm("create rekernel unit failed!\n");
    }
  }

  return 0;
}

static void rekernel_report(int reporttype, int type, pid_t src_pid, struct task_struct* src, pid_t dst_pid,
                            struct task_struct* dst, bool oneway) {
  if (start_rekernel_server() != 0)
    return;

#ifdef CONFIG_NETWORK
  if (reporttype == NETWORK) {
    char binder_kmsg[PACKET_SIZE];
    snprintf(binder_kmsg, sizeof(binder_kmsg), "type=Network,target=%d,proto=ipv%d,data_len=%d;", dst_pid, type,
             src_pid);
#ifdef CONFIG_DEBUG
    logkm("%s\n", binder_kmsg);
#endif /* CONFIG_DEBUG */
    send_netlink_message(binder_kmsg);
    return;
  }
#endif /* CONFIG_NETWORK */

  if (!frozen_task_group(dst))
    return;

  if (task_uid(src).val == task_uid(dst).val)
    return;

  char binder_kmsg[PACKET_SIZE];
  switch (reporttype) {
    case BINDER:
      if (oneway && type == TRANSACTION) {
        if (ext_tr_offset == UZERO)
          return;
        struct task_ext* ext = get_task_ext(current);
        struct binder_transaction_data* tr = *(void**)task_local_ptr(ext, ext_tr_offset);
        if (!tr)
          return;
        // 减少异步消息
        if (tr->code < 29 || tr->code > 32)
          return;

        size_t buf_data_size = tr->data_size > INTERFACETOKEN_BUFF_SIZE ? INTERFACETOKEN_BUFF_SIZE : tr->data_size;
        char* buf_data = memdup_user((char*)tr->data.ptr.buffer, buf_data_size);
        if (IS_ERR(buf_data))
          return;
        char buf[INTERFACETOKEN_BUFF_SIZE] = {0};
        int i = 0;
        int j = PARCEL_OFFSET + 1;
        char* p = buf_data + PARCEL_OFFSET;
        while (i < INTERFACETOKEN_BUFF_SIZE && j < buf_data_size && *p != '\0') {
          buf[i++] = *p;
          j += 2;
          p += 2;
        }
        kvfree(buf_data);
        if (i == INTERFACETOKEN_BUFF_SIZE) {
          buf[i - 1] = '\0';
        }
        snprintf(binder_kmsg, sizeof(binder_kmsg),
                 "type=Binder,bindertype=%s,oneway=%d,from_pid=%d,from=%d,target_pid=%d,target=%d,"
                 "rpc_name=%s,code=%d;",
                 binder_type[type], oneway, src_pid, task_uid(src).val, dst_pid, task_uid(dst).val, buf, tr->code);
      } else {
        snprintf(binder_kmsg, sizeof(binder_kmsg),
                 "type=Binder,bindertype=%s,oneway=%d,from_pid=%d,from=%d,target_pid=%d,target=%d;", binder_type[type],
                 oneway, src_pid, task_uid(src).val, dst_pid, task_uid(dst).val);
      }
      break;
    case SIGNAL:
      snprintf(binder_kmsg, sizeof(binder_kmsg), "type=Signal,signal=%d,killer_pid=%d,killer=%d,dst_pid=%d,dst=%d;",
               type, src_pid, task_uid(src).val, dst_pid, task_uid(dst).val);
      break;
    default:
      return;
  }
#ifdef CONFIG_DEBUG
  logkm("%s\n", binder_kmsg);
  logkm("src_comm=%s,dst_comm=%s\n", get_task_comm(src), get_task_comm(dst));
#endif /* CONFIG_DEBUG */
#ifdef CONFIG_DEBUG_CMDLINE
  char src_cmdline[PATH_MAX], dst_cmdline[PATH_MAX];
  memset(&src_cmdline, 0, PATH_MAX);
  memset(&dst_cmdline, 0, PATH_MAX);
  int res = 0;
  res = get_cmdline(src, src_cmdline, PATH_MAX - 1);
  src_cmdline[res] = '\0';
  res = get_cmdline(dst, dst_cmdline, PATH_MAX - 1);
  dst_cmdline[res] = '\0';
  logkm("src_cmdline=%s,dst_cmdline=%s\n", src_cmdline, dst_cmdline);
#endif /* CONFIG_DEBUG_CMDLINE */
  send_netlink_message(binder_kmsg);
}

static void binder_reply_handler(pid_t src_pid, struct task_struct* src, pid_t dst_pid, struct task_struct* dst,
                                 bool oneway) {
  if (unlikely(!dst))
    return;
  if (task_uid(dst).val > MAX_SYSTEM_UID || src_pid == dst_pid)
    return;

  // oneway=0
  rekernel_report(BINDER, REPLY, src_pid, src, dst_pid, dst, oneway);
}

static void binder_trans_handler(pid_t src_pid, struct task_struct* src, pid_t dst_pid, struct task_struct* dst,
                                 bool oneway) {
  if (unlikely(!dst))
    return;
  if ((task_uid(dst).val <= MIN_USERAPP_UID) || src_pid == dst_pid)
    return;

  rekernel_report(BINDER, TRANSACTION, src_pid, src, dst_pid, dst, oneway);
}

static void binder_overflow_handler(pid_t src_pid, struct task_struct* src, pid_t dst_pid, struct task_struct* dst,
                                    bool oneway) {
  if (unlikely(!dst))
    return;

  // oneway=1
  rekernel_report(BINDER, OVERFLOW, src_pid, src, dst_pid, dst, oneway);
}

static void rekernel_binder_transaction(void* data, bool reply, struct binder_transaction* t,
                                        struct binder_node* target_node) {
  struct binder_proc* to_proc = binder_transaction_to_proc(t);
  if (!to_proc)
    return;
  struct binder_thread* from = binder_transaction_from(t);

  if (reply) {
    binder_reply_handler(task_tgid_nr(current), current, to_proc->pid, to_proc->tsk, false);
  } else if (from) {
    if (from->proc) {
      binder_trans_handler(from->proc->pid, from->proc->tsk, to_proc->pid, to_proc->tsk, false);
    }
  } else {  // oneway=1
    binder_trans_handler(task_tgid_nr(current), current, to_proc->pid, to_proc->tsk, true);

    struct binder_alloc* target_alloc = binder_proc_alloc(to_proc);
    size_t free_async_space = binder_alloc_free_async_space(target_alloc);
    size_t buffer_size = binder_alloc_buffer_size(target_alloc);
    if (free_async_space < (buffer_size / 10 + 0x300)) {
      binder_overflow_handler(task_tgid_nr(current), current, to_proc->pid, to_proc->tsk, true);
    }
  }
}

static bool binder_can_update_transaction(struct binder_transaction* t1, struct binder_transaction* t2) {
  struct binder_proc* t1_to_proc = binder_transaction_to_proc(t1);
  struct binder_buffer* t1_buffer = binder_transaction_buffer(t1);
  unsigned int t1_code = binder_transaction_code(t1);
  unsigned int t1_flags = binder_transaction_flags(t1);
  binder_uintptr_t t1_ptr = binder_node_ptr(t1_buffer->target_node);
  binder_uintptr_t t1_cookie = binder_node_cookie(t1_buffer->target_node);

  struct binder_proc* t2_to_proc = binder_transaction_to_proc(t2);
  struct binder_buffer* t2_buffer = binder_transaction_buffer(t2);
  unsigned int t2_code = binder_transaction_code(t2);
  unsigned int t2_flags = binder_transaction_flags(t2);
  binder_uintptr_t t2_ptr = binder_node_ptr(t2_buffer->target_node);
  binder_uintptr_t t2_cookie = binder_node_cookie(t2_buffer->target_node);

  if ((t1_flags & t2_flags & TF_ONE_WAY) != TF_ONE_WAY || !t1_to_proc || !t2_to_proc)
    return false;
  if (t1_to_proc->tsk == t2_to_proc->tsk && t1_code == t2_code && t1_flags == t2_flags
      && (struct_offset.binder_proc_is_frozen > 0 ? t1_buffer->pid == t2_buffer->pid : true)  // 4.19 以下无此数据
      && t1_ptr == t2_ptr && t1_cookie == t2_cookie)
    return true;
  return false;
}

static struct binder_transaction* binder_find_outdated_transaction_ilocked(struct binder_transaction* t,
                                                                           struct list_head* target_list) {
  struct binder_work* w;
  bool second = false;

  list_for_each_entry(w, target_list, entry) {
    if (w->type != BINDER_WORK_TRANSACTION)
      continue;
    struct binder_transaction* t_queued = container_of(w, struct binder_transaction, work);
    if (binder_can_update_transaction(t_queued, t)) {
      if (second)
        return t_queued;
      else {
        second = true;
      }
    }
  }
  return NULL;
}

static inline void outstanding_txns_dec(struct binder_proc* proc) {
  if (struct_offset.binder_proc_outstanding_txns > 0) {
    int* outstanding_txns = binder_proc_outstanding_txns(proc);
    (*outstanding_txns)--;
  }
}

static inline void binder_release_entire_buffer(struct binder_proc* proc, struct binder_thread* thread,
                                                struct binder_buffer* buffer, bool is_failure) {
  if (binder_transaction_buffer_release_ver6 == IZERO) {
    binder_transaction_buffer_release_v6(proc, thread, buffer, 0, is_failure);
  } else if (binder_transaction_buffer_release_ver5 == IZERO) {
    binder_size_t off_end_offset = ALIGN(buffer->data_size, sizeof(void*));
    off_end_offset += buffer->offsets_size;

    binder_transaction_buffer_release(proc, thread, buffer, off_end_offset, is_failure);
  } else if (binder_transaction_buffer_release_ver4 == IZERO) {
    binder_transaction_buffer_release_v4(proc, buffer, 0, is_failure);
  } else {
    binder_transaction_buffer_release_v3(proc, buffer, NULL);
  }
}

static inline void binder_stats_deleted(enum binder_stat_types type) {
  atomic_t* binder_stats_deleted_addr =
      (atomic_t*)((uintptr_t)kvar(binder_stats) + struct_offset.binder_stats_deleted_transaction);
  atomic_inc(binder_stats_deleted_addr);
}

static void binder_proc_transaction_before(hook_fargs3_t* args, void* udata) {
  struct binder_transaction* t = (struct binder_transaction*)args->arg0;
  struct binder_proc* proc = (struct binder_proc*)args->arg1;

  struct binder_buffer* buffer = binder_transaction_buffer(t);
  struct binder_node* node = buffer->target_node;
  // 兼容不支持 trace 的内核
  if (trace == UZERO) {
    rekernel_binder_transaction(NULL, false, t, NULL);
  }
  unsigned int flags = binder_transaction_flags(t);
  if (!node || !(flags & TF_ONE_WAY))
    return;

  // binder 冻结时不再清理过时消息
  if (binder_is_frozen(proc) || !frozen_task_group(proc->tsk))
    return;

  binder_node_lock(node);
  bool has_async_transaction = binder_node_has_async_transaction(node);
  if (!has_async_transaction) {
    binder_node_unlock(node);
    return;
  }
  binder_inner_proc_lock(proc);

  struct list_head* async_todo = binder_node_async_todo(node);
  struct binder_transaction* t_outdated = binder_find_outdated_transaction_ilocked(t, async_todo);
  if (t_outdated) {
    list_del_init(&t_outdated->work.entry);
    outstanding_txns_dec(proc);
  }

  binder_inner_proc_unlock(proc);
  binder_node_unlock(node);

  if (t_outdated) {
    struct binder_alloc* target_alloc = binder_proc_alloc(proc);
    struct binder_buffer* buffer = binder_transaction_buffer(t_outdated);
#ifdef CONFIG_DEBUG
    logkm("free_outdated pid=%d,uid=%d,data_size=%d\n", proc->pid, task_uid(proc->tsk).val, buffer->data_size);
#endif /* CONFIG_DEBUG */

    *(struct binder_buffer**)((uintptr_t)t_outdated + struct_offset.binder_transaction_buffer) = NULL;
    buffer->transaction = NULL;
    binder_release_entire_buffer(proc, NULL, buffer, false);
    binder_alloc_free_buf(target_alloc, buffer);
    kfree(t_outdated);
    binder_stats_deleted(BINDER_STAT_TRANSACTION);
  }
}

static void binder_transaction_before(hook_fargs5_t* args, void* udata) {
  struct task_ext* ext = get_task_ext(current);
  if (!task_ext_valid(ext))
    return;
  if (ext_tr_offset == UZERO) {
    // reg_task_local 似乎有bug
    // ext_tr_offset = reg_task_local(sizeof(uint64_t));
    ext_tr_offset = task_ext_size + sizeof(uintptr_t);
    // 随缘兼容其他模块
    while (*(uintptr_t**)task_local_ptr(ext, ext_tr_offset)) {
      ext_tr_offset += sizeof(uintptr_t);
    }
  }
  *(uintptr_t*)task_local_ptr(ext, ext_tr_offset) = args->arg2;
}

static void do_send_sig_info_before(hook_fargs4_t* args, void* udata) {
  int sig = (int)args->arg0;
  struct task_struct* dst = (struct task_struct*)args->arg2;

  if (sig == SIGKILL || sig == SIGTERM || sig == SIGABRT || sig == SIGQUIT) {
    rekernel_report(SIGNAL, sig, task_tgid_nr(current), current, task_tgid_nr(dst), dst, false);
  }
}

#ifdef CONFIG_NETWORK
static inline unsigned char* skb_transport_header(const struct sk_buff* skb) {
  return sk_buff_head(skb) + sk_buff_transport_header(skb);
}
static inline int skb_transport_offset(const struct sk_buff* skb) {
  return skb_transport_header(skb) - sk_buff_data(skb);
}

static void tcp_rcv_before(hook_fargs2_t* args, void* udata) {
  struct sock* sk = (struct sock*)args->arg0;
  struct sk_buff* skb = (struct sk_buff*)args->arg1;

  uid_t uid = sock_i_uid(sk).val;
  if (uid < MIN_USERAPP_UID)
    return;

  int version = *(int*)udata;
  struct tcphdr* th = (struct tcphdr*)sk_buff_data(skb);
  int data_len = sk_buff_len(skb) - skb_transport_offset(skb) - (th->doff << 2);
  if (data_len <= 0 && !th->syn && !th->fin && !th->rst)
    return;

  rekernel_report(NETWORK, version, data_len, NULL, uid, NULL, true);
}
#endif /* CONFIG_NETWORK */

static long inline_hook_init(const char* args, const char* event, void* __user reserved) {
  lookup_name(cgroup_freezing);

  kfunc_lookup_name(__alloc_skb);
  kfunc_lookup_name(__nlmsg_put);
  kfunc_lookup_name(kfree_skb);
  kfunc_lookup_name(netlink_unicast);
  kfunc_lookup_name(netlink_rcv_skb);

  kvar_lookup_name(init_net);
  kfunc_lookup_name(__netlink_kernel_create);
  kfunc_lookup_name(netlink_kernel_release);

  kfunc_lookup_name(proc_mkdir);
  kfunc_lookup_name(proc_create_data);
  kfunc_lookup_name(proc_remove);

  kfunc_lookup_name(tracepoint_probe_register);
  kfunc_lookup_name(tracepoint_probe_unregister);

  kfunc_lookup_name(_raw_spin_lock);
  kfunc_lookup_name(_raw_spin_unlock);
  kvar_lookup_name(__tracepoint_binder_transaction);

  lookup_name(binder_transaction_buffer_release);
  binder_transaction_buffer_release_v6 =
      (typeof(binder_transaction_buffer_release_v6))binder_transaction_buffer_release;
  binder_transaction_buffer_release_v4 =
      (typeof(binder_transaction_buffer_release_v4))binder_transaction_buffer_release;
  binder_transaction_buffer_release_v3 =
      (typeof(binder_transaction_buffer_release_v3))binder_transaction_buffer_release;
  lookup_name(binder_alloc_free_buf);
  kfunc_lookup_name(kfree);
  kvar_lookup_name(binder_stats);
  kfunc_lookup_name(kvfree);
  kfunc_lookup_name(memdup_user);

  lookup_name(binder_proc_transaction);
  lookup_name(binder_transaction);
  lookup_name(do_send_sig_info);

#ifdef CONFIG_NETWORK
  kfunc_lookup_name(sock_i_uid);

  lookup_name(tcp_v4_do_rcv);
  lookup_name(tcp_v6_do_rcv);
#endif /* CONFIG_NETWORK */
#ifdef CONFIG_DEBUG_CMDLINE
  kfunc_lookup_name(get_cmdline);
#endif /* CONFIG_DEBUG_CMDLINE */

  int rc = 0;
  rc = calculate_offsets();
  if (rc < 0)
    return rc;

  rc = tracepoint_probe_register(kvar(__tracepoint_binder_transaction), rekernel_binder_transaction, NULL);
  if (rc == 0) {
    trace = IZERO;
  }

  hook_func(binder_proc_transaction, 3, binder_proc_transaction_before, NULL, NULL);
  hook_func(binder_transaction, 5, binder_transaction_before, NULL, NULL);
  hook_func(do_send_sig_info, 4, do_send_sig_info_before, NULL, NULL);

#ifdef CONFIG_NETWORK
  hook_func(tcp_v4_do_rcv, 2, tcp_rcv_before, NULL, &ipv4_version);
  hook_func(tcp_v6_do_rcv, 2, tcp_rcv_before, NULL, &ipv6_version);
#endif /* CONFIG_NETWORK */

  return 0;
}

static long inline_hook_control0(const char* ctl_args, char* __user out_msg, int outlen) {
  char msg[64];
  snprintf(msg, sizeof(msg), "_(._.)_");
  compat_copy_to_user(out_msg, msg, sizeof(msg));
  return 0;
}

static long inline_hook_exit(void* __user reserved) {
  if (rekernel_netlink) {
    netlink_kernel_release(rekernel_netlink);
  }
  if (rekernel_dir) {
    proc_remove(rekernel_dir);
  }

  tracepoint_probe_unregister(kvar(__tracepoint_binder_transaction), rekernel_binder_transaction, NULL);

  unhook_func(binder_proc_transaction);
  unhook_func(binder_transaction);
  unhook_func(do_send_sig_info);

#ifdef CONFIG_NETWORK
  unhook_func(tcp_v4_do_rcv);
  unhook_func(tcp_v6_do_rcv);
#endif /* CONFIG_NETWORK */

  return 0;
}

KPM_INIT(inline_hook_init);
KPM_CTL0(inline_hook_control0);
KPM_EXIT(inline_hook_exit);

```

`re_kernel/re_kernel.h`:

```h
#ifndef __RE_KERNEL_H
#define __RE_KERNEL_H

#include <ktypes.h>

#define THIS_MODULE ((struct module*)0)

#define ALIGN_MASK(x, mask) (((x) + (mask)) & ~(mask))
#define ALIGN(x, a) ALIGN_MASK(x, (typeof(x))(a) - 1)

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))

// include/linux/sched/jobctl.h
#define JOBCTL_TRAP_FREEZE_BIT 23
#define JOBCTL_TRAP_FREEZE (1UL << JOBCTL_TRAP_FREEZE_BIT)

// include/uapi/linux/android/binder.h
enum transaction_flags {
  TF_ONE_WAY = 0x01,
  TF_ROOT_OBJECT = 0x04,
  TF_STATUS_CODE = 0x08,
  TF_ACCEPT_FDS = 0x10,
  TF_CLEAR_BUF = 0x20,
  TF_UPDATE_TXN = 0x40,
};

typedef __u64 binder_size_t;
typedef __u64 binder_uintptr_t;
struct binder_transaction_data {
  union {
    __u32 handle;
    binder_uintptr_t ptr;
  } target;
  binder_uintptr_t cookie;
  __u32 code;
  __u32 flags;
  pid_t sender_pid;
  uid_t sender_euid;
  binder_size_t data_size;
  binder_size_t offsets_size;
  union {
    struct {
      binder_uintptr_t buffer;
      binder_uintptr_t offsets;
    } ptr;
    __u8 buf[8];
  } data;
};

// include/linux/rbtree_types.h
struct rb_node {
  unsigned long __rb_parent_color;
  struct rb_node* rb_right;
  struct rb_node* rb_left;
} __attribute__((aligned(sizeof(long))));
struct rb_root {
  struct rb_node* rb_node;
};

// drivers/android/binder_alloc.h
struct binder_alloc;

struct binder_buffer {
  struct list_head entry;
  struct rb_node rb_node;
  unsigned free : 1;
  unsigned clear_on_free : 1;  // 6.1
  unsigned allow_user_free : 1;
  unsigned async_transaction : 1;
  unsigned oneway_spam_suspect : 1;  // 6.1
  // unsigned debug_id : 29;
  unsigned debug_id : 27;  // 6.1
  struct binder_transaction* transaction;
  struct binder_node* target_node;
  size_t data_size;
  size_t offsets_size;
  size_t extra_buffers_size;
  void __user* user_data;
  int pid;
};
// drivers/android/binder_internal.h
struct binder_work {
  struct list_head entry;
  enum binder_work_type {
    BINDER_WORK_TRANSACTION = 1,
    BINDER_WORK_TRANSACTION_COMPLETE,
    BINDER_WORK_TRANSACTION_ONEWAY_SPAM_SUSPECT,  // 6.1
    BINDER_WORK_RETURN_ERROR,
    BINDER_WORK_NODE,
    BINDER_WORK_DEAD_BINDER,
    BINDER_WORK_DEAD_BINDER_AND_CLEAR,
    BINDER_WORK_CLEAR_DEATH_NOTIFICATION,
  } type;
};

struct binder_node {
  int debug_id;
  // spinlock_t lock; // harmony
  // struct binder_work work;
  // union {
  //   struct rb_node rb_node;
  //   struct hlist_node dead_node;
  // };
  // struct binder_proc* proc;
  // struct hlist_head refs;
  // int internal_strong_refs;
  // int local_weak_refs;
  // int local_strong_refs;
  // int tmp_refs;
  // binder_uintptr_t ptr;
  // binder_uintptr_t cookie;
  // struct {
  //   u8 has_strong_ref : 1;
  //   u8 pending_strong_ref : 1;
  //   u8 has_weak_ref : 1;
  //   u8 pending_weak_ref : 1;
  // };
  // struct {
  //   u8 sched_policy : 2;
  //   u8 inherit_rt : 1;
  //   u8 accept_fds : 1;
  //   u8 txn_security_ctx : 1;
  //   u8 min_priority;
  // };
  // bool has_async_transaction;
  // struct list_head async_todo;
};

struct binder_proc {
  struct hlist_node proc_node;
  struct rb_root threads;
  struct rb_root nodes;
  struct rb_root refs_by_desc;
  struct rb_root refs_by_node;
  struct list_head waiting_threads;
  int pid;
  struct task_struct* tsk;
  // unknow
};

struct binder_transaction {
  int debug_id;
  struct binder_work work;
  // struct binder_thread* from; // harmony
  // pid_t from_pid; // 6.1
  // pid_t from_tid; // 6.1
  // struct binder_transaction* from_parent;
  // struct binder_proc* to_proc;
  // struct binder_thread* to_thread;
  // struct binder_transaction* to_parent;
  // unsigned need_reply : 1;
  // struct binder_buffer* buffer;
  // unsigned int code;
  // unsigned int flags;
  // struct binder_priority priority;
  // struct binder_priority saved_priority;
  // bool set_priority_called;
};

enum binder_stat_types {
  BINDER_STAT_PROC,
  BINDER_STAT_THREAD,
  BINDER_STAT_NODE,
  BINDER_STAT_REF,
  BINDER_STAT_DEATH,
  BINDER_STAT_TRANSACTION,
  BINDER_STAT_TRANSACTION_COMPLETE,
  BINDER_STAT_COUNT
};
struct binder_stats {
  // atomic_t br[18];
  atomic_t br[20];  // 6.1
  atomic_t bc[19];
  atomic_t obj_created[BINDER_STAT_COUNT];
  atomic_t obj_deleted[BINDER_STAT_COUNT];
};

struct binder_thread {
  struct binder_proc* proc;
  // struct rb_node rb_node;
  // struct list_head waiting_thread_node;
  // int pid;
  // int looper;
  // bool looper_need_return;
  // struct binder_transaction* transaction_stack;
  // struct list_head todo;
  // bool process_todo;
};

// linux/netlink.h
#define NETLINK_MAX_COOKIE_LEN 20
struct sk_buff;
struct net;
struct sock;
struct netlink_kernel_cfg {
  unsigned int groups;
  unsigned int flags;
  void (*input)(struct sk_buff* skb);
  struct mutex* cb_mutex;
  int (*bind)(struct net* net, int group);
  void (*unbind)(struct net* net, int group);
  bool (*compare)(struct net* net, struct sock* sk);
};
struct netlink_ext_ack {
  const char* _msg;
  const struct nlattr* bad_attr;
  const struct nla_policy* policy;
  u8 cookie[NETLINK_MAX_COOKIE_LEN];
  u8 cookie_len;
};

// tools/include/uapi/linux/netlink.h
struct nlmsghdr {
  __u32 nlmsg_len;
  __u16 nlmsg_type;
  __u16 nlmsg_flags;
  __u32 nlmsg_seq;
  __u32 nlmsg_pid;
};
#define NLMSG_ALIGNTO 4U
#define NLMSG_ALIGN(len) (((len) + NLMSG_ALIGNTO - 1) & ~(NLMSG_ALIGNTO - 1))
#define NLMSG_HDRLEN ((int)NLMSG_ALIGN(sizeof(struct nlmsghdr)))
#define NLMSG_LENGTH(len) ((len) + NLMSG_HDRLEN)
#define NLMSG_DATA(nlh) ((void*)(((char*)nlh) + NLMSG_HDRLEN))

// linux/gfp.h
#define NUMA_NO_NODE (-1)
#define ___GFP_HIGH 0x20u
#define ___GFP_ATOMIC 0x80000u
#define ___GFP_KSWAPD_RECLAIM 0x400000u
#define __GFP_HIGH ((__force gfp_t)___GFP_HIGH)
#define __GFP_ATOMIC ((__force gfp_t)___GFP_ATOMIC)
#define __GFP_KSWAPD_RECLAIM ((__force gfp_t)___GFP_KSWAPD_RECLAIM)
#define GFP_ATOMIC (__GFP_HIGH | __GFP_ATOMIC | __GFP_KSWAPD_RECLAIM)

// linux/fs.h
struct kiocb;
struct iov_iter;
struct dir_context;
struct poll_table_struct;
struct vm_area_struct;
struct file_lock;
struct page;
struct pipe_inode_info;
struct seq_file;
struct open_flags;
struct file_operations {
  char unknow[0x120];
};

// linux/schde.h
#define PF_FROZEN 0x00010000

// uapi/asm/signal.h
#define SIGQUIT 3
#define SIGABRT 6
#define SIGKILL 9
#define SIGTERM 15

struct siginfo;

// linux/socket.h
#define MSG_OOB 1
#define MSG_PEEK 2
#define MSG_DONTROUTE 4
#define MSG_TRYHARD 4
#define MSG_CTRUNC 8
#define MSG_PROBE 0x10
#define MSG_TRUNC 0x20
#define MSG_DONTWAIT 0x40
#define MSG_EOR 0x80
#define MSG_WAITALL 0x100
#define MSG_FIN 0x200
#define MSG_SYN 0x400
#define MSG_CONFIRM 0x800
#define MSG_RST 0x1000
#define MSG_ERRQUEUE 0x2000
#define MSG_NOSIGNAL 0x4000
#define MSG_MORE 0x8000
#define MSG_WAITFORONE 0x10000
#define MSG_SENDPAGE_NOPOLICY 0x10000
#define MSG_SENDPAGE_NOTLAST 0x20000
#define MSG_BATCH 0x40000
#define MSG_EOF MSG_FIN
#define MSG_NO_SHARED_FRAGS 0x80000
#define MSG_SENDPAGE_DECRYPTED 0x100000

// linux/tracepoint-defs.h
struct tracepoint;

// net/tcp_states.h
enum {
  TCP_ESTABLISHED = 1,
  TCP_SYN_SENT,
  TCP_SYN_RECV,
  TCP_FIN_WAIT1,
  TCP_FIN_WAIT2,
  TCP_TIME_WAIT,
  TCP_CLOSE,
  TCP_CLOSE_WAIT,
  TCP_LAST_ACK,
  TCP_LISTEN,
  TCP_CLOSING,
  TCP_NEW_SYN_RECV,
  TCP_MAX_STATES
};

enum {
  TCPF_ESTABLISHED = (1 << TCP_ESTABLISHED),
  TCPF_SYN_SENT = (1 << TCP_SYN_SENT),
  TCPF_SYN_RECV = (1 << TCP_SYN_RECV),
  TCPF_FIN_WAIT1 = (1 << TCP_FIN_WAIT1),
  TCPF_FIN_WAIT2 = (1 << TCP_FIN_WAIT2),
  TCPF_TIME_WAIT = (1 << TCP_TIME_WAIT),
  TCPF_CLOSE = (1 << TCP_CLOSE),
  TCPF_CLOSE_WAIT = (1 << TCP_CLOSE_WAIT),
  TCPF_LAST_ACK = (1 << TCP_LAST_ACK),
  TCPF_LISTEN = (1 << TCP_LISTEN),
  TCPF_CLOSING = (1 << TCP_CLOSING),
  TCPF_NEW_SYN_RECV = (1 << TCP_NEW_SYN_RECV),
};

// net/sock.h
typedef __u32 __bitwise __portpair;
typedef __u64 __bitwise __addrpair;

struct sock_common {
  union {
    __addrpair skc_addrpair;
    struct {
      __be32 skc_daddr;
      __be32 skc_rcv_saddr;
    };
  };
  union {
    unsigned int skc_hash;
    __u16 skc_u16hashes[2];
  };
  union {
    __portpair skc_portpair;
    struct {
      __be16 skc_dport;
      __u16 skc_num;
    };
  };
  unsigned short skc_family;
  volatile unsigned char skc_state;
  unsigned char skc_reuse : 4;
  unsigned char skc_reuseport : 1;
  unsigned char skc_ipv6only : 1;
  unsigned char skc_net_refcnt : 1;
  int skc_bound_dev_if;
  union {
    struct hlist_node skc_bind_node;
    struct hlist_node skc_portaddr_node;
  };
  struct proto* skc_prot;
  // unknow
};

struct sock {
  struct sock_common __sk_common;
#define sk_node __sk_common.skc_node
#define sk_nulls_node __sk_common.skc_nulls_node
#define sk_refcnt __sk_common.skc_refcnt
#define sk_tx_queue_mapping __sk_common.skc_tx_queue_mapping
#define sk_rx_queue_mapping __sk_common.skc_rx_queue_mapping

#define sk_dontcopy_begin __sk_common.skc_dontcopy_begin
#define sk_dontcopy_end __sk_common.skc_dontcopy_end
#define sk_hash __sk_common.skc_hash
#define sk_portpair __sk_common.skc_portpair
#define sk_num __sk_common.skc_num
#define sk_dport __sk_common.skc_dport
#define sk_addrpair __sk_common.skc_addrpair
#define sk_daddr __sk_common.skc_daddr
#define sk_rcv_saddr __sk_common.skc_rcv_saddr
#define sk_family __sk_common.skc_family
#define sk_state __sk_common.skc_state
#define sk_reuse __sk_common.skc_reuse
#define sk_reuseport __sk_common.skc_reuseport
#define sk_ipv6only __sk_common.skc_ipv6only
#define sk_net_refcnt __sk_common.skc_net_refcnt
#define sk_bound_dev_if __sk_common.skc_bound_dev_if
#define sk_bind_node __sk_common.skc_bind_node
#define sk_prot __sk_common.skc_prot
#define sk_net __sk_common.skc_net
#define sk_v6_daddr __sk_common.skc_v6_daddr
#define sk_v6_rcv_saddr __sk_common.skc_v6_rcv_saddr
#define sk_cookie __sk_common.skc_cookie
#define sk_incoming_cpu __sk_common.skc_incoming_cpu
#define sk_flags __sk_common.skc_flags
#define sk_rxhash __sk_common.skc_rxhash
  // unknow
};

// linux/skbuff.h
typedef s64 ktime_t;
struct sk_buff {
  union {
    struct {
      struct sk_buff* next;
      struct sk_buff* prev;
      union {
        struct net_device* dev;
        unsigned long dev_scratch;
      };
    };
    struct rb_node rbnode;
    struct list_head list;
  };
  union {
    struct sock* sk;
    int ip_defrag_offset;
  };
  union {
    ktime_t tstamp;
    u64 skb_mstamp_ns;
  };
  char cb[48] __aligned(8);
  union {
    struct {
      unsigned long _skb_refdst;
      void (*destructor)(struct sk_buff* skb);
    };
    struct list_head tcp_tsorted_anchor;
  };
  // unknow
};

// uapi/linux/tcp.h
struct tcphdr {
  __be16 source;
  __be16 dest;
  __be32 seq;
  __be32 ack_seq;
  __u16 res1 : 4, doff : 4, fin : 1, syn : 1, rst : 1, psh : 1, ack : 1, urg : 1, ece : 1, cwr : 1;
  __be16 window;
  __sum16 check;
  __be16 urg_ptr;
};

// uapi/linux/ip.h
struct iphdr {
  __u8 ihl : 4, version : 4;
  __u8 tos;
  __be16 tot_len;
  __be16 id;
  __be16 frag_off;
  __u8 ttl;
  __u8 protocol;
  __sum16 check;
  __be32 saddr;
  __be32 daddr;
};

// uapi/linux/ipv6.h
struct ipv6hdr {
  __u8 priority : 4, version : 4;
  __u8 flow_lbl[3];

  __be16 payload_len;
  __u8 nexthdr;
  __u8 hop_limit;

  // unknow
  // struct in6_addr saddr;
  // struct in6_addr daddr;
};

// uapi/linux/swab.h
#define ___constant_swab16(x) ((__u16)((((__u16)(x) & (__u16)0x00ffU) << 8) | (((__u16)(x) & (__u16)0xff00U) >> 8)))

#define ___constant_swab32(x)                                                                     \
  ((__u32)((((__u32)(x) & (__u32)0x000000ffUL) << 24) | (((__u32)(x) & (__u32)0x0000ff00UL) << 8) \
           | (((__u32)(x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(x) & (__u32)0xff000000UL) >> 24)))

#define ___constant_swab64(x)                                                                                         \
  ((__u64)((((__u64)(x) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(x) & (__u64)0x000000000000ff00ULL) << 40)  \
           | (((__u64)(x) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(x) & (__u64)0x00000000ff000000ULL) << 8) \
           | (((__u64)(x) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(x) & (__u64)0x0000ff0000000000ULL) >> 24) \
           | (((__u64)(x) & (__u64)0x00ff000000000000ULL) >> 40)                                                      \
           | (((__u64)(x) & (__u64)0xff00000000000000ULL) >> 56)))

#define ___constant_swahw32(x) \
  ((__u32)((((__u32)(x) & (__u32)0x0000ffffUL) << 16) | (((__u32)(x) & (__u32)0xffff0000UL) >> 16)))

#define ___constant_swahb32(x) \
  ((__u32)((((__u32)(x) & (__u32)0x00ff00ffUL) << 8) | (((__u32)(x) & (__u32)0xff00ff00UL) >> 8)))

#define swab16(x) ___constant_swab16(x)
#define swab32(x) ___constant_swab32(x)
#define swab64(x) ___constant_swab64(x)
#define swahw32(x) ___constant_swahw32(x)
#define swahb32(x) ___constant_swahb32(x)

#endif /* __RE_KERNEL_H */

```

`re_kernel/re_offsets.c`:

```c
// task_pid
static inline pid_t task_pid_nr(struct task_struct* task) {
  pid_t pid = *(pid_t*)((uintptr_t)task + struct_offset.task_struct_pid);
  return pid;
}
// task_tgid
static inline pid_t task_tgid_nr(struct task_struct* task) {
  pid_t tgid = *(pid_t*)((uintptr_t)task + struct_offset.task_struct_tgid);
  return tgid;
}
// task_jobctl
static inline unsigned long task_jobctl(struct task_struct* task) {
  unsigned long jobctl = *(unsigned long*)((uintptr_t)task + struct_offset.task_struct_jobctl);
  return jobctl;
}
// binder_proc_is_frozen
static inline bool binder_proc_is_frozen(struct binder_proc* proc) {
  bool is_frozen = *(bool*)((uintptr_t)proc + struct_offset.binder_proc_is_frozen);
  return is_frozen;
}
// binder_proc_alloc
static inline struct binder_alloc* binder_proc_alloc(struct binder_proc* proc) {
  struct binder_alloc* alloc = (struct binder_alloc*)((uintptr_t)proc + struct_offset.binder_proc_alloc);
  return alloc;
}
//  binder_proc_inner_lock
static inline spinlock_t* binder_proc_inner_lock(struct binder_proc* proc) {
  spinlock_t* inner_lock = (spinlock_t*)((uintptr_t)proc + struct_offset.binder_proc_inner_lock);
  return inner_lock;
}
//  binder_proc_outstanding_txns
static inline int* binder_proc_outstanding_txns(struct binder_proc* proc) {
  int* outstanding_txns = (int*)((uintptr_t)proc + struct_offset.binder_proc_outstanding_txns);
  return outstanding_txns;
}
// binder_alloc_buffer
static inline void __user* binder_alloc_buffer(struct binder_alloc* alloc) {
  void __user* buffer = *(void __user**)((uintptr_t)alloc + struct_offset.binder_alloc_buffer);
  return buffer;
}
// binder_alloc_free_async_space
static inline size_t binder_alloc_free_async_space(struct binder_alloc* alloc) {
  size_t free_async_space = *(size_t*)((uintptr_t)alloc + struct_offset.binder_alloc_free_async_space);
  return free_async_space;
}
// binder_alloc_buffer_size
static inline size_t binder_alloc_buffer_size(struct binder_alloc* alloc) {
  size_t buffer_size = *(size_t*)((uintptr_t)alloc + struct_offset.binder_alloc_buffer_size);
  return buffer_size;
}
// binder_transaction_from
static inline struct binder_thread* binder_transaction_from(struct binder_transaction* t) {
  struct binder_thread* from = *(struct binder_thread**)((uintptr_t)t + struct_offset.binder_transaction_from);
  return from;
}
// binder_transaction_to_proc
static inline struct binder_proc* binder_transaction_to_proc(struct binder_transaction* t) {
  struct binder_proc* to_proc = *(struct binder_proc**)((uintptr_t)t + struct_offset.binder_transaction_to_proc);
  return to_proc;
}
// binder_transaction_buffer
static inline struct binder_buffer* binder_transaction_buffer(struct binder_transaction* t) {
  struct binder_buffer* buffer = *(struct binder_buffer**)((uintptr_t)t + struct_offset.binder_transaction_buffer);
  return buffer;
}
// binder_transaction_code
static inline unsigned int binder_transaction_code(struct binder_transaction* t) {
  unsigned int code = *(unsigned int*)((uintptr_t)t + struct_offset.binder_transaction_code);
  return code;
}
// binder_transaction_flags
static inline unsigned int binder_transaction_flags(struct binder_transaction* t) {
  unsigned int flags = *(unsigned int*)((uintptr_t)t + struct_offset.binder_transaction_flags);
  return flags;
}
// binder_node_lock_ptr
static inline spinlock_t* binder_node_lock_ptr(struct binder_node* node) {
  spinlock_t* lock = (spinlock_t*)((uintptr_t)node + struct_offset.binder_node_lock);
  return lock;
}
// binder_node_ptr
static inline binder_uintptr_t binder_node_ptr(struct binder_node* node) {
  binder_uintptr_t ptr = *(binder_uintptr_t*)((uintptr_t)node + struct_offset.binder_node_ptr);
  return ptr;
}
// binder_node_cookie
static inline binder_uintptr_t binder_node_cookie(struct binder_node* node) {
  binder_uintptr_t cookie = *(binder_uintptr_t*)((uintptr_t)node + struct_offset.binder_node_cookie);
  return cookie;
}
// binder_node_has_async_transaction
static inline bool binder_node_has_async_transaction(struct binder_node* node) {
  bool has_async_transaction = *(bool*)((uintptr_t)node + struct_offset.binder_node_has_async_transaction);
  return has_async_transaction;
}
// binder_node_async_todo
static inline struct list_head* binder_node_async_todo(struct binder_node* node) {
  struct list_head* async_todo = (struct list_head*)((uintptr_t)node + struct_offset.binder_node_async_todo);
  return async_todo;
}
// sk_buff_len
static inline unsigned int sk_buff_len(const struct sk_buff* skb) {
  unsigned int len = *(unsigned int*)((uintptr_t)skb + struct_offset.sk_buff_len);
  return len;
}
// sk_buff_transport_header
static inline __u16 sk_buff_transport_header(const struct sk_buff* skb) {
  __u16 transport_header = *(__u16*)((uintptr_t)skb + struct_offset.sk_buff_transport_header);
  return transport_header;
}
// sk_buff_network_header
static inline __u16 sk_buff_network_header(const struct sk_buff* skb) {
  __u16 network_header = *(__u16*)((uintptr_t)skb + struct_offset.sk_buff_network_header);
  return network_header;
}
// sk_buff_head
static inline unsigned char* sk_buff_head(const struct sk_buff* skb) {
  unsigned char* head = *(unsigned char**)((uintptr_t)skb + struct_offset.sk_buff_head);
  return head;
}
// sk_buff_data
static inline unsigned char* sk_buff_data(const struct sk_buff* skb) {
  unsigned char* data = *(unsigned char**)((uintptr_t)skb + struct_offset.sk_buff_data);
  return data;
}

static long calculate_offsets() {
  // 获取 binder_transaction_buffer_release 版本, 以参数数量做判断
  uint32_t* binder_transaction_buffer_release_src = (uint32_t*)binder_transaction_buffer_release;
  for (u32 i = 0; i < 0x100; i++) {
#ifdef CONFIG_DEBUG
    logkm("binder_transaction_buffer_release %x %llx\n", i, binder_transaction_buffer_release_src[i]);
#endif /* CONFIG_DEBUG */
    if (i < 0x10) {
      if (inst_get_str_imm_uint_rt(binder_transaction_buffer_release_src[i]) == 4
          || inst_get_mov_reg_rm(binder_transaction_buffer_release_src[i]) == 4
          || inst_get_uxtb_rn(binder_transaction_buffer_release_src[i]) == 4) {
        binder_transaction_buffer_release_ver5 = IZERO;
      } else if (inst_get_str_imm_uint_rt(binder_transaction_buffer_release_src[i]) == 3
                 || inst_get_mov_reg_rm(binder_transaction_buffer_release_src[i]) == 3
                 || inst_get_uxtb_rn(binder_transaction_buffer_release_src[i]) == 3) {
        binder_transaction_buffer_release_ver4 = IZERO;
      }
    } else if (binder_transaction_buffer_release_ver5 == UZERO) {
      break;
    } else if (inst_get_and_imm_imm(binder_transaction_buffer_release_src[i]) == -8) {
      for (u32 j = 1; j < 0x3; j++) {
        if (inst_is_cbz(binder_transaction_buffer_release_src[i + j])
            || inst_is_tbnz(binder_transaction_buffer_release_src[i + j])) {
          binder_transaction_buffer_release_ver6 = IZERO;
          break;
        }
      }
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("binder_transaction_buffer_release_ver6=0x%llx\n", binder_transaction_buffer_release_ver6);
  logkm("binder_transaction_buffer_release_ver5=0x%llx\n", binder_transaction_buffer_release_ver5);
  logkm("binder_transaction_buffer_release_ver4=0x%llx\n", binder_transaction_buffer_release_ver4);
#endif /* CONFIG_DEBUG */

  // 获取 binder_proc->is_frozen, 没有就是不支持
  uint32_t* binder_proc_transaction_src = (uint32_t*)binder_proc_transaction;
  for (u32 i = 0; i < 0x70; i++) {
#ifdef CONFIG_DEBUG
    logkm("binder_proc_transaction %x %llx\n", i, binder_proc_transaction_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(binder_proc_transaction_src[i])) {
      break;
    } else if (!struct_offset.binder_node_has_async_transaction
               && inst_is_strb_imm_uint(binder_proc_transaction_src[i])) {
      uint64_t offset = inst_get_strb_imm_uint_imm(binder_proc_transaction_src[i]);
      if (offset < 0x6B || offset > 0x7B)
        continue;
      struct_offset.binder_node_has_async_transaction = offset;
      struct_offset.binder_node_ptr = offset - 0x13;
      struct_offset.binder_node_cookie = offset - 0xB;
      struct_offset.binder_node_async_todo = offset + 0x5;
      // 目前只有 harmony 内核需要特殊设置
      if (offset == 0x7B) {
        struct_offset.binder_node_lock = 0x8;
        struct_offset.binder_transaction_from = 0x28;
      } else {
        struct_offset.binder_node_lock = 0x4;
        struct_offset.binder_transaction_from = 0x20;
      }
    } else if (!struct_offset.binder_transaction_buffer
               && inst_get_ldr_imm_uint_size(binder_proc_transaction_src[i]) == 0b11
               && inst_get_ldr_imm_uint_rn(binder_proc_transaction_src[i]) == 0) {
      struct_offset.binder_transaction_buffer = inst_get_ldr_imm_uint_imm(binder_proc_transaction_src[i]);
      struct_offset.binder_transaction_to_proc = struct_offset.binder_transaction_buffer - 0x20;
      struct_offset.binder_transaction_code = struct_offset.binder_transaction_buffer + 0x8;
      struct_offset.binder_transaction_flags = struct_offset.binder_transaction_buffer + 0xC;
    } else if (inst_is_orr_reg(binder_proc_transaction_src[i])
               && inst_is_strb_imm_uint(binder_proc_transaction_src[i + 1])) {
      uint64_t binder_proc_sync_recv_offset = inst_get_strb_imm_uint_imm(binder_proc_transaction_src[i + 1]);
      struct_offset.binder_proc_is_frozen = binder_proc_sync_recv_offset - 1;
      struct_offset.binder_proc_outstanding_txns = binder_proc_sync_recv_offset - 0x6;
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("binder_transaction_from=0x%x\n", struct_offset.binder_transaction_from);                      // 0x20
  logkm("binder_transaction_to_proc=0x%x\n", struct_offset.binder_transaction_to_proc);                // 0x30
  logkm("binder_transaction_buffer=0x%x\n", struct_offset.binder_transaction_buffer);                  // 0x50
  logkm("binder_transaction_code=0x%x\n", struct_offset.binder_transaction_code);                      // 0x58
  logkm("binder_transaction_flags=0x%x\n", struct_offset.binder_transaction_flags);                    // 0x5C
  logkm("binder_node_lock=0x%x\n", struct_offset.binder_node_lock);                                    // 0x4
  logkm("binder_node_ptr=0x%x\n", struct_offset.binder_node_ptr);                                      // 0x58
  logkm("binder_node_cookie=0x%x\n", struct_offset.binder_node_cookie);                                // 0x60
  logkm("binder_node_has_async_transaction=0x%x\n", struct_offset.binder_node_has_async_transaction);  // 0x6B
  logkm("binder_node_async_todo=0x%x\n", struct_offset.binder_node_async_todo);                        // 0x70
  logkm("binder_proc_outstanding_txns=0x%x\n", struct_offset.binder_proc_outstanding_txns);            // 0x6C
  logkm("binder_proc_is_frozen=0x%x\n", struct_offset.binder_proc_is_frozen);                          // 0x71
#endif /* CONFIG_DEBUG */
  if (struct_offset.binder_node_lock <= 0 || struct_offset.binder_node_has_async_transaction <= 0
      || struct_offset.binder_transaction_buffer <= 0)
    return -11;

  // 获取 task_struct->jobctl
  void (*task_clear_jobctl_trapping)(struct task_struct* t);
  lookup_name(task_clear_jobctl_trapping);

  uint32_t* task_clear_jobctl_trapping_src = (uint32_t*)task_clear_jobctl_trapping;
  for (u32 i = 0; i < 0x10; i++) {
#ifdef CONFIG_DEBUG
    logkm("task_clear_jobctl_trapping %x %llx\n", i, task_clear_jobctl_trapping_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(task_clear_jobctl_trapping_src[i])) {
      break;
    } else if (inst_get_ldr_imm_uint_size(task_clear_jobctl_trapping_src[i]) == 0b11
               && inst_get_ldr_imm_uint_rn(task_clear_jobctl_trapping_src[i]) == 0) {
      struct_offset.task_struct_jobctl = inst_get_ldr_imm_uint_imm(task_clear_jobctl_trapping_src[i]);
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("task_struct_jobctl=0x%x\n", struct_offset.task_struct_jobctl);  // 0x580
#endif                                                                   /* CONFIG_DEBUG */
  if (struct_offset.task_struct_jobctl <= 0)
    return -11;

  // 获取 binder_proc->context, binder_proc->inner_lock, binder_proc->outer_lock
  uint32_t* binder_transaction_src = (uint32_t*)binder_transaction;
  for (u32 i = 0; i < 0x20; i++) {
#ifdef CONFIG_DEBUG
    logkm("binder_transaction %x %llx\n", i, binder_transaction_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(binder_transaction_src[i])) {
      break;
    } else if (inst_get_ldr_imm_uint_size(binder_transaction_src[i]) == 0b11) {
      uint64_t offset = inst_get_ldr_imm_uint_imm(binder_transaction_src[i]);
      if (offset < 0x200 || offset > 0x300)
        continue;
      struct_offset.binder_proc_context = offset;
      struct_offset.binder_proc_inner_lock = offset + 0x8;
      struct_offset.binder_proc_outer_lock = offset + 0xC;
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("binder_proc_context=0x%x\n", struct_offset.binder_proc_context);        // 0x240
  logkm("binder_proc_inner_lock=0x%x\n", struct_offset.binder_proc_inner_lock);  // 0x248
  logkm("binder_proc_outer_lock=0x%x\n", struct_offset.binder_proc_outer_lock);  // 0x24C
#endif                                                                           /* CONFIG_DEBUG */
  if (struct_offset.binder_proc_context <= 0)
    return -11;

  // 获取 binder_proc->alloc
  void (*binder_free_proc)(struct binder_proc* proc);
  lookup_name_continue(binder_free_proc);
  if (!binder_free_proc) {
    void* binder_proc_dec_tmpref;
    lookup_name(binder_proc_dec_tmpref);
    binder_free_proc = binder_proc_dec_tmpref;
  }

  uint32_t* binder_free_proc_src = (uint32_t*)binder_free_proc;
  for (u32 i = 0x10; i < 0x100; i++) {
#ifdef CONFIG_DEBUG
    logkm("binder_free_proc %x %llx\n", i, binder_free_proc_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_get_mov_reg_rd(binder_free_proc_src[i]) == 29 && inst_get_mov_reg_rm(binder_free_proc_src[i]) == 0) {
      break;
    } else if (inst_get_add_imm_sf(binder_free_proc_src[i]) == 1 && inst_get_add_imm_rd(binder_free_proc_src[i]) == 0
               && inst_get_add_imm_rn(binder_free_proc_src[i]) == 19 && inst_is_bl(binder_free_proc_src[i + 1])) {
      struct_offset.binder_proc_alloc = inst_get_add_imm_imm(binder_free_proc_src[i]);
      if (struct_offset.binder_proc_alloc > struct_offset.binder_proc_context) {
        continue;
      }
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("binder_proc_alloc=0x%x\n", struct_offset.binder_proc_alloc);  // 0x1A8
#endif                                                                 /* CONFIG_DEBUG */
  if (struct_offset.binder_proc_alloc <= 0)
    return -11;

  // 获取 binder_alloc->pid, task_struct->pid, task_struct->group_leader
  void (*binder_alloc_init)(struct task_struct* t);
  lookup_name(binder_alloc_init);

  uint32_t* binder_alloc_init_src = (uint32_t*)binder_alloc_init;
  for (u32 i = 0; i < 0x20; i++) {
#ifdef CONFIG_DEBUG
    logkm("binder_alloc_init %x %llx\n", i, binder_alloc_init_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(binder_alloc_init_src[i])) {
      for (u32 j = 1; j < 0x10; j++) {
        if (inst_get_add_imm_sf(binder_alloc_init_src[i - j]) == 1) {
          uint64_t binder_alloc_buffers_offset = inst_get_add_imm_imm(binder_alloc_init_src[i - j]);
          struct_offset.binder_alloc_buffer = binder_alloc_buffers_offset - 0x8;
          struct_offset.binder_alloc_free_async_space = binder_alloc_buffers_offset + 0x20;
          struct_offset.binder_alloc_buffer_size = binder_alloc_buffers_offset + 0x30;
          break;
        }
      }
      break;
    } else if (!struct_offset.binder_alloc_pid && inst_get_str_imm_uint_size(binder_alloc_init_src[i]) == 0b10
               && inst_get_str_imm_uint_rn(binder_alloc_init_src[i]) == 0) {
      struct_offset.binder_alloc_pid = inst_get_str_imm_uint_imm(binder_alloc_init_src[i]);
    } else if (!struct_offset.binder_alloc_pid && inst_get_ldr_imm_uint_size(binder_alloc_init_src[i]) == 0b10) {
      struct_offset.task_struct_pid = inst_get_ldr_imm_uint_imm(binder_alloc_init_src[i]);
      struct_offset.task_struct_tgid = struct_offset.task_struct_pid + 0x4;
    } else if (!struct_offset.binder_alloc_pid && inst_get_ldr_imm_uint_size(binder_alloc_init_src[i]) == 0b11) {
      struct_offset.task_struct_group_leader = inst_get_ldr_imm_uint_imm(binder_alloc_init_src[i]);
    }
  }
#ifdef CONFIG_DEBUG
  logkm("binder_alloc_pid=0x%x\n", struct_offset.binder_alloc_pid);                            // 0x84
  logkm("binder_alloc_buffer_size=0x%x\n", struct_offset.binder_alloc_buffer_size);            // 0x78
  logkm("binder_alloc_free_async_space=0x%x\n", struct_offset.binder_alloc_free_async_space);  // 0x68
  logkm("binder_alloc_buffer=0x%x\n", struct_offset.binder_alloc_buffer);                      // 0x40
  logkm("task_struct_pid=0x%x\n", struct_offset.task_struct_pid);                              // 0x5D8
  logkm("task_struct_tgid=0x%x\n", struct_offset.task_struct_tgid);                            // 0x5DC
  logkm("task_struct_group_leader=0x%x\n", struct_offset.task_struct_group_leader);            // 0x618
#endif                                                                                         /* CONFIG_DEBUG */
  if (struct_offset.binder_alloc_pid <= 0 || struct_offset.task_struct_pid <= 0
      || struct_offset.task_struct_group_leader <= 0)
    return -11;

  // 获取 binder_stats_deleted_addr
  void (*binder_free_transaction)(struct binder_transaction* t);
  lookup_name_continue(binder_free_transaction);
  if (!binder_free_transaction) {
    void* binder_send_failed_reply;
    lookup_name(binder_send_failed_reply);
    binder_free_transaction = binder_send_failed_reply;
  }

  uint32_t* binder_free_transaction_src = (uint32_t*)binder_free_transaction;
  for (u32 i = 0; i < 0x100; i++) {
#ifdef CONFIG_DEBUG
    logkm("binder_free_transaction %x %llx\n", i, binder_free_transaction_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_adrp(binder_free_transaction_src[i])) {
      uint64_t inst_addr = (uint64_t)binder_free_transaction + i * 4;
      uint64_t adrp_offset = inst_get_adrp_label(binder_free_transaction_src[i]);
      uint64_t adrp_addr = (inst_addr + adrp_offset) & 0xFFFFFFFFFFFFF000;
      if (adrp_addr - ((uint64_t)kvar(binder_stats) & 0xFFFFFFFFFFFFF000) <= 0x1000) {
        uint64_t binder_stats_addr = (uint64_t)kvar(binder_stats) & 0xFFF;
        for (u32 j = 0; j < 0x10; j++) {
          if (inst_get_add_imm_sf(binder_free_transaction_src[i + j]) == 1) {
            uint64_t adrl_addr = inst_get_add_imm_imm(binder_free_transaction_src[i + j]);
            uint64_t deleted_offset = (adrl_addr - binder_stats_addr) & 0xFFF;
            if (deleted_offset == 0) {
              for (u32 k = 0; k < 0x10; k++) {
                if (inst_get_add_imm_sf(binder_free_transaction_src[i + j + k]) == 1) {
                  uint64_t offset = inst_get_add_imm_imm(binder_free_transaction_src[i + j + k]);
                  if (offset > 0xC0 && offset < 0xE0) {
                    struct_offset.binder_stats_deleted_transaction = offset;
                    break;
                  }
                }
              }
            } else if (deleted_offset > 0xC0 && deleted_offset < 0xE0) {
              struct_offset.binder_stats_deleted_transaction = deleted_offset;
              break;
            }
          }
        }
        break;
      }
    }
  }
#ifdef CONFIG_DEBUG
  logkm("binder_stats_deleted_transaction=0x%llx\n",
        struct_offset.binder_stats_deleted_transaction);  // 0xCC
#endif                                                    /* CONFIG_DEBUG */
  if (struct_offset.binder_stats_deleted_transaction <= 0)
    return -11;

  // 获取 sk_buff->len
  void (*skb_trim)(struct sk_buff* skb, unsigned int len);
  lookup_name(skb_trim);

  uint32_t* skb_trim_src = (uint32_t*)skb_trim;
  for (u32 i = 0; i < 0x8; i++) {
#ifdef CONFIG_DEBUG
    logkm("skb_trim %x %llx\n", i, skb_trim_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(skb_trim_src[i])) {
      break;
    } else if (inst_get_ldr_imm_uint_size(skb_trim_src[i]) == 0b10) {
      struct_offset.sk_buff_len = inst_get_ldr_imm_uint_imm(skb_trim_src[i]);
      break;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("sk_buff_len=0x%x\n", struct_offset.sk_buff_len);  // 0x70
#endif                                                     /* CONFIG_DEBUG */
  if (struct_offset.sk_buff_len <= 0)
    return -11;

  // 获取 sk_buff->network_header, sk_buff->head
  void (*ipv6_find_tlv)(const struct sk_buff* skb, int offset, int type);
  lookup_name(ipv6_find_tlv);

  uint32_t* ipv6_find_tlv_src = (uint32_t*)ipv6_find_tlv;
  for (u32 i = 0; i < 0x8; i++) {
#ifdef CONFIG_DEBUG
    logkm("ipv6_find_tlv %x %llx\n", i, ipv6_find_tlv_src[i]);
#endif /* CONFIG_DEBUG */
    if (inst_is_ret(ipv6_find_tlv_src[i])) {
      break;
    } else if (inst_get_ldr_imm_uint_size(ipv6_find_tlv_src[i]) == 0b11) {
      struct_offset.sk_buff_head = inst_get_ldr_imm_uint_imm(ipv6_find_tlv_src[i]);
      struct_offset.sk_buff_data = struct_offset.sk_buff_head + 0x8;
    } else if (inst_is_ldrh_imm_uint(ipv6_find_tlv_src[i])) {
      struct_offset.sk_buff_network_header = inst_get_ldrh_imm_uint_imm(ipv6_find_tlv_src[i]);
      struct_offset.sk_buff_transport_header = struct_offset.sk_buff_network_header - 0x2;
    }
  }
#ifdef CONFIG_DEBUG
  logkm("sk_buff_network_header=0x%x\n", struct_offset.sk_buff_network_header);  // 0xB4
  logkm("sk_buff_head=0x%x\n", struct_offset.sk_buff_head);                      // 0xD0
  logkm("sk_buff_data=0x%x\n", struct_offset.sk_buff_data);                      // 0xD8
#endif                                                                           /* CONFIG_DEBUG */
  if (struct_offset.sk_buff_network_header <= 0 || struct_offset.sk_buff_head <= 0)
    return -11;

  return 0;
}

```

`re_kernel/re_utils.h`:

```h
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 bmax121. All Rights Reserved.
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */
#ifndef __RE_UTILS_H
#define __RE_UTILS_H

#include <uapi/asm-generic/errno.h>

#define logkm(fmt, ...) printk("re_kernel: " fmt, ##__VA_ARGS__)

struct struct_offset {
  int16_t binder_alloc_buffer_size;
  int16_t binder_alloc_buffer;
  int16_t binder_alloc_free_async_space;
  int16_t binder_alloc_pid;
  int16_t binder_node_async_todo;
  int16_t binder_node_cookie;
  int16_t binder_node_has_async_transaction;
  int16_t binder_node_lock;
  int16_t binder_node_ptr;
  int16_t binder_proc_alloc;
  int16_t binder_proc_context;
  int16_t binder_proc_inner_lock;
  int16_t binder_proc_is_frozen;
  int16_t binder_proc_outer_lock;
  int16_t binder_proc_outstanding_txns;
  int16_t binder_stats_deleted_transaction;
  int16_t binder_transaction_buffer;
  int16_t binder_transaction_code;
  int16_t binder_transaction_flags;
  int16_t binder_transaction_from;
  int16_t binder_transaction_to_proc;
  int16_t sk_buff_len;
  int16_t sk_buff_transport_header;
  int16_t sk_buff_network_header;
  int16_t sk_buff_head;
  int16_t sk_buff_data;
  int16_t task_struct_group_leader;
  int16_t task_struct_jobctl;
  int16_t task_struct_pid;
  int16_t task_struct_tgid;
};

extern struct sk_buff* kfunc_def(__alloc_skb)(unsigned int size, gfp_t gfp_mask, int flags, int node);
static inline struct sk_buff* alloc_skb(unsigned int size, gfp_t priority) {
  kfunc_call(__alloc_skb, size, priority, 0, NUMA_NO_NODE);
  kfunc_not_found();
  return NULL;
}

static inline int nlmsg_msg_size(int payload) { return NLMSG_HDRLEN + payload; }
static inline int nlmsg_total_size(int payload) { return NLMSG_ALIGN(nlmsg_msg_size(payload)); }
static inline int nlmsg_padlen(int payload) { return nlmsg_total_size(payload) - nlmsg_msg_size(payload); }
static inline void* nlmsg_data(const struct nlmsghdr* nlh) { return (unsigned char*)nlh + NLMSG_HDRLEN; }
static inline int nlmsg_len(const struct nlmsghdr* nlh) { return nlh->nlmsg_len - NLMSG_HDRLEN; }

static inline struct sk_buff* nlmsg_new(size_t payload, gfp_t flags) {
  return alloc_skb(nlmsg_total_size(payload), flags);
}

extern struct nlmsghdr* kfunc_def(__nlmsg_put)(struct sk_buff* skb, u32 portid, u32 seq, int type, int len, int flags);
static inline struct nlmsghdr* nlmsg_put(struct sk_buff* skb, u32 portid, u32 seq, int type, int payload, int flags) {
  kfunc_call(__nlmsg_put, skb, portid, seq, type, payload, flags);
  kfunc_not_found();
  return NULL;
}

extern void kfunc_def(kfree_skb)(struct sk_buff* skb);
static inline void nlmsg_free(struct sk_buff* skb) { kfunc_call_void(kfree_skb, skb); }

extern int kfunc_def(netlink_unicast)(struct sock* ssk, struct sk_buff* skb, u32 portid, int nonblock);
static inline int netlink_unicast(struct sock* ssk, struct sk_buff* skb, u32 portid, int nonblock) {
  kfunc_call(netlink_unicast, ssk, skb, portid, nonblock);
  kfunc_not_found();
  return -EFAULT;
}

extern int kfunc_def(netlink_rcv_skb)(struct sk_buff* skb,
                                      int (*cb)(struct sk_buff*, struct nlmsghdr*, struct netlink_ext_ack*));
static inline int netlink_rcv_skb(struct sk_buff* skb,
                                  int (*cb)(struct sk_buff*, struct nlmsghdr*, struct netlink_ext_ack*)) {
  kfunc_call(netlink_rcv_skb, skb, cb);
  kfunc_not_found();
  return -EFAULT;
}

extern struct sock* kfunc_def(__netlink_kernel_create)(struct net* net, int unit, struct module* module,
                                                       struct netlink_kernel_cfg* cfg);
static inline struct sock* netlink_kernel_create(struct net* net, int unit, struct netlink_kernel_cfg* cfg) {
  kfunc_call(__netlink_kernel_create, net, unit, THIS_MODULE, cfg);
  kfunc_not_found();
  return NULL;
}

extern void kfunc_def(netlink_kernel_release)(struct sock* sk);
static inline void netlink_kernel_release(struct sock* sk) { kfunc_call_void(netlink_kernel_release, sk); }

extern struct proc_dir_entry* kfunc_def(proc_mkdir)(const char* name, struct proc_dir_entry* parent);
static inline struct proc_dir_entry* proc_mkdir(const char* name, struct proc_dir_entry* parent) {
  kfunc_call(proc_mkdir, name, parent);
  kfunc_not_found();
  return NULL;
}

extern struct proc_dir_entry* kfunc_def(proc_create_data)(const char* name, umode_t mode, struct proc_dir_entry* parent,
                                                          const struct file_operations* proc_fops, void* data);
static inline struct proc_dir_entry* proc_create(const char* name, umode_t mode, struct proc_dir_entry* parent,
                                                 const struct file_operations* proc_fops) {
  kfunc_call(proc_create_data, name, mode, parent, proc_fops, NULL);
  kfunc_not_found();
  return NULL;
}

extern void kfunc_def(proc_remove)(struct proc_dir_entry* de);
static inline void proc_remove(struct proc_dir_entry* de) { kfunc_call_void(proc_remove, de); }

extern kuid_t kfunc_def(sock_i_uid)(struct sock* sk);
static inline kuid_t sock_i_uid(struct sock* sk) {
  kfunc_call(sock_i_uid, sk);
  kfunc_not_found();
  return (kuid_t){0};
}

extern int kfunc_def(get_cmdline)(struct task_struct* task, char* buffer, int buflen);
static inline int get_cmdline(struct task_struct* task, char* buffer, int buflen) {
  kfunc_call(get_cmdline, task, buffer, buflen);
  kfunc_not_found();
  return -EFAULT;
}

extern int kfunc_def(tracepoint_probe_register)(struct tracepoint* tp, void* probe, void* data);
static inline int tracepoint_probe_register(struct tracepoint* tp, void* probe, void* data) {
  kfunc_call(tracepoint_probe_register, tp, probe, data);
  kfunc_not_found();
  return -EFAULT;
}

extern int kfunc_def(tracepoint_probe_unregister)(struct tracepoint* tp, void* probe, void* data);
static inline int tracepoint_probe_unregister(struct tracepoint* tp, void* probe, void* data) {
  kfunc_call(tracepoint_probe_unregister, tp, probe, data);
  kfunc_not_found();
  return -EFAULT;
}

#endif /* __RE_UTILS_H */

```

`re_kernel/re_vmlinux.c`:

```c
#include "vmlinux.h"

extern int printf(const char *, ...);
#define offsetof(TYPE, MEMBER) ((size_t)&((TYPE *)0)->MEMBER)

int main() {
  printf(
      "struct struct_offset struct_offset = {\n\
    .binder_alloc_buffer_size = 0x%lx,\n\
    .binder_alloc_buffer = 0x%lx,\n\
    .binder_alloc_free_async_space = 0x%lx,\n\
    .binder_alloc_pid = 0x%lx,\n\
    .binder_node_async_todo = 0x%lx,\n\
    .binder_node_cookie = 0x%lx,\n\
    .binder_node_has_async_transaction = 0x%lx,\n\
    .binder_node_lock = 0x%lx,\n\
    .binder_node_ptr = 0x%lx,\n\
    .binder_proc_alloc = 0x%lx,\n\
    .binder_proc_context = 0x%lx,\n\
    .binder_proc_inner_lock = 0x%lx,\n\
    .binder_proc_is_frozen = 0x%lx,\n\
    .binder_proc_outer_lock = 0x%lx,\n\
    .binder_proc_outstanding_txns = 0x%lx,\n\
    .binder_stats_deleted_transaction = 0x%lx,\n\
    .binder_transaction_buffer = 0x%lx,\n\
    .binder_transaction_code = 0x%lx,\n\
    .binder_transaction_flags = 0x%lx,\n\
    .binder_transaction_from = 0x%lx,\n\
    .binder_transaction_to_proc = 0x%lx,\n\
    .task_struct_group_leader = 0x%lx,\n\
    .task_struct_jobctl = 0x%lx,\n\
    .task_struct_pid = 0x%lx,\n\
    .task_struct_tgid = 0x%lx,\n\
    .sk_buff_len = 0x%lx,\n\
    .sk_buff_transport_header = 0x%lx,\n\
    .sk_buff_network_header = 0x%lx,\n\
    .sk_buff_head = 0x%lx,\n\
    .sk_buff_data = 0x%lx,\n\
};\n",
      offsetof(struct binder_alloc, buffer_size), offsetof(struct binder_alloc, buffer),
      offsetof(struct binder_alloc, free_async_space), offsetof(struct binder_alloc, pid),
      offsetof(struct binder_node, async_todo), offsetof(struct binder_node, cookie),
      offsetof(struct binder_node, has_async_transaction), offsetof(struct binder_node, lock),
      offsetof(struct binder_node, ptr), offsetof(struct binder_proc, alloc), offsetof(struct binder_proc, context),
      offsetof(struct binder_proc, inner_lock), offsetof(struct binder_proc, is_frozen),
      offsetof(struct binder_proc, outer_lock), offsetof(struct binder_proc, outstanding_txns),
      offsetof(struct binder_stats, obj_deleted[BINDER_STAT_TRANSACTION]), offsetof(struct binder_transaction, buffer),
      offsetof(struct binder_transaction, code), offsetof(struct binder_transaction, flags),
      offsetof(struct binder_transaction, from), offsetof(struct binder_transaction, to_proc),
      offsetof(struct task_struct, group_leader), offsetof(struct task_struct, jobctl),
      offsetof(struct task_struct, pid), offsetof(struct task_struct, tgid), offsetof(struct sk_buff, len),
      offsetof(struct sk_buff, transport_header), offsetof(struct sk_buff, network_header),
      offsetof(struct sk_buff, head), offsetof(struct sk_buff, data));

  return 0;
}

```

`xperia_ii_battery_age/Makefile`:

```
XIIBA_VERSION := 1.1.2

ifndef KP_DIR
    KP_DIR = ../KernelPatch
endif

OS_NAME = $(shell uname | tr A-Z a-z)
MACHINE = $(shell uname -m)
HOST_TAG = $(OS_NAME)-$(MACHINE)
ifeq ($(HOST_TAG), darwin-arm64)
    HOST_TAG = darwin-x86_64
endif
NDK_BIN_DIR := toolchains/llvm/prebuilt/$(HOST_TAG)/bin
ifdef ANDROID_NDK_LATEST_HOME
    NDK_PATH ?= $(ANDROID_NDK_LATEST_HOME)/$(NDK_BIN_DIR)
else ifdef ANDROID_NDK
    NDK_PATH ?= $(ANDROID_NDK)/$(NDK_BIN_DIR)
endif

ifdef TARGET_COMPILE
    CC := $(TARGET_COMPILE)gcc
    LD := $(TARGET_COMPILE)ld
else ifdef NDK_PATH
    CC := $(NDK_PATH)/aarch64-linux-android31-clang
    LD := $(NDK_PATH)/ld.lld
endif

CFLAGS = -Wall -O2 -fno-PIC -fno-asynchronous-unwind-tables -fno-stack-protector -fno-common -DXIIBA_VERSION=\"$(XIIBA_VERSION)$(XIIBA_VER)\"

INCLUDE_DIRS := . include patch/include linux/include linux/arch/arm64/include linux/tools/arch/arm64/include

INCLUDE_FLAGS := $(foreach dir,$(INCLUDE_DIRS),-I$(KP_DIR)/kernel/$(dir))

objs := xperia_ii_battery_age.o

all: xperia_ii_battery_age_$(XIIBA_VERSION).kpm

debug: CFLAGS += -DDEBUG
debug: XIIBA_VER := _d
debug: xperia_ii_battery_age_$(XIIBA_VERSION)_debug.kpm

xperia_ii_battery_age_$(XIIBA_VERSION).kpm: ${objs}
	${CC} -r -o $@ $^

xperia_ii_battery_age_$(XIIBA_VERSION)_debug.kpm: ${objs}
	${CC} -r -o $@ $^

%.o: %.c
	${CC} $(CFLAGS) $(INCLUDE_FLAGS) -c -o $@ $<

.PHONY: clean
clean:
	rm -rf *.kpm
	find . -name "*.o" | xargs rm -f

```

`xperia_ii_battery_age/xiiba_utils.h`:

```h
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2024 bmax121. All Rights Reserved.
 * Copyright (C) 2024 lzghzr. All Rights Reserved.
 */
#ifndef __XIIBA_UTILS_H
#define __XIIBA_UTILS_H

#include <hook.h>
#include <ksyms.h>
#include <linux/cred.h>
#include <linux/sched.h>
#include <uapi/asm-generic/errno.h>

#define lookup_name(func)                                  \
  func = 0;                                                \
  func = (typeof(func))kallsyms_lookup_name(#func);        \
  pr_info("kernel function %s addr: %llx\n", #func, func); \
  if (!func)                                               \
  {                                                        \
    return -21;                                            \
  }

#define hook_func(func, argv, before, after, udata)                         \
  if (!func)                                                                \
  {                                                                         \
    return -22;                                                             \
  }                                                                         \
  hook_err_t hook_err_##func = hook_wrap(func, argv, before, after, udata); \
  if (hook_err_##func)                                                      \
  {                                                                         \
    func = 0;                                                               \
    pr_err("hook %s error: %d\n", #func, hook_err_##func);                  \
    return -23;                                                             \
  }                                                                         \
  else                                                                      \
  {                                                                         \
    pr_info("hook %s success\n", #func);                                    \
  }

#define unhook_func(func)            \
  if (func && !is_bad_address(func)) \
  {                                  \
    unhook(func);                    \
    func = 0;                        \
  }

#endif /* __XIIBA_UTILS_H */

```

`xperia_ii_battery_age/xperia_ii_battery_age.c`:

```c
/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * Copyright (C) 2023 lzghzr. All Rights Reserved.
 */

#include <compiler.h>
#include <hook.h>
#include <kpmodule.h>
#include <kputils.h>
#include <linux/kernel.h>
#include <linux/printk.h>

#include "xiiba_utils.h"

KPM_NAME("xperia_ii_battery_age");
KPM_VERSION(XIIBA_VERSION);
KPM_LICENSE("GPL v2");
KPM_AUTHOR("lzghzr");
KPM_DESCRIPTION("set xperia ii battery aging level");

#define FG_IMA_DEFAULT 0
#define SOMC_AGING_LEVEL_WORD 291
#define SOMC_AGING_LEVEL_OFFSET 0

struct fg_dev;

static int(*fg_sram_read)(struct fg_dev* fg, u16 address, u8 offset, u8* val, int len, int flags) = 0;
static int(*fg_sram_write)(struct fg_dev* fg, u16 address, u8 offset, u8* val, int len, int flags) = 0;

u8 aging = 0;
struct fg_dev* fg = NULL;

static long inline_hook_control0(const char* args, char* __user out_msg, int outlen) {
  aging = args ? *args - '0' : 0;
  if (aging > 5)
    return -1;

  int rc = fg_sram_write(fg, SOMC_AGING_LEVEL_WORD, SOMC_AGING_LEVEL_OFFSET, &aging, 1, FG_IMA_DEFAULT);
  char echo[64] = "";
  if (rc < 0) {
    sprintf(echo, "error, rc=%d\n", rc);
    logke("fg_sram_write %s", echo);
    if (out_msg) {
      compat_copy_to_user(out_msg, echo, sizeof(echo));
      return 1;
    }
  } else {
    sprintf(echo, "success, set batt_aging_level to %d\n", aging);
    logki("fg_sram_write %s", echo);
    if (out_msg) {
      compat_copy_to_user(out_msg, echo, sizeof(echo));
      return 0;
    }
  }
  return 0;
}

void before_read(hook_fargs6_t* args, void* udata) {
  unhook_func(fg_sram_read);
  fg = (struct fg_dev*)args->arg0;
  // u8 *arg3 = (u8 *)args->arg3;
  // logkd("before read fg: %llu, address: %u, offset: %u, val: %u, len: %d, flags: %d\n", args->arg0, (u16)args->arg1,
  //       (u8)args->arg2, (u8)*arg3, (int)args->arg4, (int)args->arg5);
  char age[] = "0";
  age[0] = aging + '0';
  inline_hook_control0(age, NULL, NULL);
}

static long inline_hook_init(const char* args, const char* event, void* __user reserved) {
  aging = args ? *args - '0' : 0;
  if (aging > 5)
    return -1;

  lookup_name(fg_sram_write);
  lookup_name(fg_sram_read);
  hook_func(fg_sram_read, 6, before_read, 0, 0);
  return 0;
}

static long inline_hook_exit(void* __user reserved) {
  unhook_func(fg_sram_read);
  return 0;
}

KPM_INIT(inline_hook_init);
KPM_CTL0(inline_hook_control0);
KPM_EXIT(inline_hook_exit);

```