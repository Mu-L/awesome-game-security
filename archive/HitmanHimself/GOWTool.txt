Project Path: arc_HitmanHimself_GOWTool_ftju5scb

Source Tree:

```txt
arc_HitmanHimself_GOWTool_ftju5scb
├── DirectXTex
├── GOWTool.sln
├── GOWTool.vcxproj
├── GOWTool.vcxproj.filters
├── README.md
├── Source.cpp
├── glTF-SDK
├── inc
│   ├── Formats.h
│   ├── Gnf.h
│   ├── Lodpak.h
│   ├── MainFunctions.h
│   ├── MathFunctions.h
│   ├── Mesh.h
│   ├── Rig.h
│   ├── Texpack.h
│   ├── Wad.h
│   ├── anims.h
│   ├── converter.h
│   ├── glTFSerializer.h
│   ├── krak.h
│   ├── streams.h
│   └── utils.h
├── pch.h
└── src
    ├── Formats.cpp
    ├── Gnf.cpp
    ├── Lodpack.cpp
    ├── MainFunctions.cpp
    ├── MathFunctions.cpp
    ├── Rig.cpp
    ├── Texpack.cpp
    ├── Wad.cpp
    ├── anims.cpp
    ├── converter.cpp
    ├── glTFSerializer.cpp
    ├── krak.cpp
    └── utils.cpp

```

`GOWTool.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31410.414
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GLTFSDK", "glTF-SDK\GLTFSDK\GLTFSDK.vcxproj", "{260F202C-DB96-3039-9507-90F491F0DF9C}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DirectXTex", "DirectXTex\DirectXTex\DirectXTex_Desktop_2022_Win10.vcxproj", "{371B9FA9-4C90-4AC6-A123-ACED756D6C77}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GOWTool", "GOWTool.vcxproj", "{2CCF01A8-D54B-4733-88B9-5E83F6700E93}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		MinSizeRel|ARM = MinSizeRel|ARM
		MinSizeRel|ARM64 = MinSizeRel|ARM64
		MinSizeRel|x64 = MinSizeRel|x64
		MinSizeRel|x86 = MinSizeRel|x86
		Profile|ARM = Profile|ARM
		Profile|ARM64 = Profile|ARM64
		Profile|x64 = Profile|x64
		Profile|x86 = Profile|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
		RelWithDebInfo|ARM = RelWithDebInfo|ARM
		RelWithDebInfo|ARM64 = RelWithDebInfo|ARM64
		RelWithDebInfo|x64 = RelWithDebInfo|x64
		RelWithDebInfo|x86 = RelWithDebInfo|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Debug|ARM.ActiveCfg = Debug|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Debug|ARM64.ActiveCfg = Debug|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Debug|x64.ActiveCfg = Debug|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Debug|x64.Build.0 = Debug|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Debug|x86.ActiveCfg = Debug|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.MinSizeRel|ARM.ActiveCfg = MinSizeRel|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.MinSizeRel|ARM64.ActiveCfg = MinSizeRel|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.MinSizeRel|x64.ActiveCfg = MinSizeRel|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.MinSizeRel|x64.Build.0 = MinSizeRel|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.MinSizeRel|x86.ActiveCfg = MinSizeRel|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Profile|ARM.ActiveCfg = RelWithDebInfo|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Profile|ARM.Build.0 = RelWithDebInfo|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Profile|ARM64.ActiveCfg = RelWithDebInfo|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Profile|ARM64.Build.0 = RelWithDebInfo|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Profile|x64.ActiveCfg = RelWithDebInfo|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Profile|x64.Build.0 = RelWithDebInfo|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Profile|x86.ActiveCfg = RelWithDebInfo|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Profile|x86.Build.0 = RelWithDebInfo|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Release|ARM.ActiveCfg = Release|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Release|ARM64.ActiveCfg = Release|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Release|x64.ActiveCfg = Release|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Release|x64.Build.0 = Release|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.Release|x86.ActiveCfg = Release|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.RelWithDebInfo|ARM.ActiveCfg = RelWithDebInfo|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.RelWithDebInfo|ARM64.ActiveCfg = RelWithDebInfo|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.RelWithDebInfo|x64.ActiveCfg = RelWithDebInfo|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.RelWithDebInfo|x64.Build.0 = RelWithDebInfo|x64
		{260F202C-DB96-3039-9507-90F491F0DF9C}.RelWithDebInfo|x86.ActiveCfg = RelWithDebInfo|x64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Debug|ARM.ActiveCfg = Debug|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Debug|ARM64.Build.0 = Debug|ARM64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Debug|x64.ActiveCfg = Debug|x64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Debug|x64.Build.0 = Debug|x64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Debug|x86.ActiveCfg = Debug|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Debug|x86.Build.0 = Debug|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.MinSizeRel|ARM.ActiveCfg = Debug|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.MinSizeRel|ARM.Build.0 = Debug|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.MinSizeRel|ARM64.ActiveCfg = Profile|ARM64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.MinSizeRel|ARM64.Build.0 = Profile|ARM64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.MinSizeRel|x64.ActiveCfg = Profile|x64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.MinSizeRel|x64.Build.0 = Profile|x64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.MinSizeRel|x86.ActiveCfg = Debug|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.MinSizeRel|x86.Build.0 = Debug|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Profile|ARM.ActiveCfg = Profile|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Profile|ARM64.ActiveCfg = Profile|ARM64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Profile|ARM64.Build.0 = Profile|ARM64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Profile|x64.ActiveCfg = Profile|x64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Profile|x64.Build.0 = Profile|x64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Profile|x86.ActiveCfg = Profile|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Profile|x86.Build.0 = Profile|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Release|ARM.ActiveCfg = Release|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Release|ARM64.ActiveCfg = Release|ARM64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Release|ARM64.Build.0 = Release|ARM64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Release|x64.ActiveCfg = Release|x64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Release|x64.Build.0 = Release|x64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Release|x86.ActiveCfg = Release|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.Release|x86.Build.0 = Release|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.RelWithDebInfo|ARM.ActiveCfg = Debug|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.RelWithDebInfo|ARM.Build.0 = Debug|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.RelWithDebInfo|ARM64.ActiveCfg = Release|ARM64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.RelWithDebInfo|ARM64.Build.0 = Release|ARM64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.RelWithDebInfo|x64.ActiveCfg = Release|x64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.RelWithDebInfo|x64.Build.0 = Release|x64
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.RelWithDebInfo|x86.ActiveCfg = Release|Win32
		{371B9FA9-4C90-4AC6-A123-ACED756D6C77}.RelWithDebInfo|x86.Build.0 = Release|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Debug|ARM.ActiveCfg = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Debug|ARM64.ActiveCfg = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Debug|x64.ActiveCfg = Debug|x64
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Debug|x64.Build.0 = Debug|x64
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Debug|x86.ActiveCfg = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Debug|x86.Build.0 = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.MinSizeRel|ARM.ActiveCfg = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.MinSizeRel|ARM.Build.0 = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.MinSizeRel|ARM64.ActiveCfg = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.MinSizeRel|ARM64.Build.0 = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.MinSizeRel|x64.ActiveCfg = Debug|x64
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.MinSizeRel|x64.Build.0 = Debug|x64
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.MinSizeRel|x86.ActiveCfg = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.MinSizeRel|x86.Build.0 = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Profile|ARM.ActiveCfg = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Profile|ARM.Build.0 = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Profile|ARM64.ActiveCfg = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Profile|ARM64.Build.0 = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Profile|x64.ActiveCfg = Debug|x64
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Profile|x64.Build.0 = Debug|x64
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Profile|x86.ActiveCfg = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Profile|x86.Build.0 = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Release|ARM.ActiveCfg = Release|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Release|ARM64.ActiveCfg = Release|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Release|x64.ActiveCfg = Release|x64
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Release|x64.Build.0 = Release|x64
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Release|x86.ActiveCfg = Release|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.Release|x86.Build.0 = Release|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.RelWithDebInfo|ARM.ActiveCfg = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.RelWithDebInfo|ARM.Build.0 = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.RelWithDebInfo|ARM64.ActiveCfg = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.RelWithDebInfo|ARM64.Build.0 = Debug|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.RelWithDebInfo|x64.ActiveCfg = Release|x64
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.RelWithDebInfo|x64.Build.0 = Release|x64
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.RelWithDebInfo|x86.ActiveCfg = Release|Win32
		{2CCF01A8-D54B-4733-88B9-5E83F6700E93}.RelWithDebInfo|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {80F67FE5-605E-486A-BFE5-D0B507C6A509}
	EndGlobalSection
EndGlobal

```

`GOWTool.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{2ccf01a8-d54b-4733-88b9-5e83f6700e93}</ProjectGuid>
    <RootNamespace>GOWTool</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalIncludeDirectories>.\inc;.\src;.;.\glTF-SDK\GLTFSDK\inc;.\DirectXTex;</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalIncludeDirectories>.\inc;.\src;.;.\glTF-SDK\GLTFSDK\inc;.\DirectXTex;</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalIncludeDirectories>.\inc;.\src;.;.\glTF-SDK\GLTFSDK\inc;.\DirectXTex;</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalIncludeDirectories>.\inc;.\src;.;.\glTF-SDK\GLTFSDK\inc;.\DirectXTex;</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp" />
    <ClCompile Include="src\anims.cpp" />
    <ClCompile Include="src\Formats.cpp" />
    <ClCompile Include="src\glTFSerializer.cpp" />
    <ClCompile Include="src\Gnf.cpp" />
    <ClCompile Include="src\krak.cpp" />
    <ClCompile Include="src\Lodpack.cpp" />
    <ClCompile Include="src\MainFunctions.cpp" />
    <ClCompile Include="src\MathFunctions.cpp" />
    <ClCompile Include="src\Rig.cpp" />
    <ClCompile Include="src\converter.cpp" />
    <ClCompile Include="src\Texpack.cpp" />
    <ClCompile Include="src\utils.cpp" />
    <ClCompile Include="src\Wad.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="inc\anims.h" />
    <ClInclude Include="inc\Formats.h" />
    <ClInclude Include="inc\glTFSerializer.h" />
    <ClInclude Include="inc\gnf.h" />
    <ClInclude Include="inc\krak.h" />
    <ClInclude Include="inc\Lodpak.h" />
    <ClInclude Include="inc\MainFunctions.h" />
    <ClInclude Include="inc\MathFunctions.h" />
    <ClInclude Include="inc\Mesh.h" />
    <ClInclude Include="inc\Rig.h" />
    <ClInclude Include="inc\streams.h" />
    <ClInclude Include="inc\converter.h" />
    <ClInclude Include="inc\Texpack.h" />
    <ClInclude Include="inc\utils.h" />
    <ClInclude Include="inc\Wad.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="DirectXTex\DirectXTex\DirectXTex_Desktop_2022_Win10.vcxproj">
      <Project>{371b9fa9-4c90-4ac6-a123-aced756d6c77}</Project>
    </ProjectReference>
    <ProjectReference Include="glTF-SDK\GLTFSDK\GLTFSDK.vcxproj">
      <Project>{260f202c-db96-3039-9507-90f491f0df9c}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GOWTool.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\Formats.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\glTFSerializer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Lodpack.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\MainFunctions.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\MathFunctions.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Rig.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Texpack.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Wad.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source.cpp" />
    <ClCompile Include="src\krak.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Gnf.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\anims.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\converter.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="inc\Formats.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inc\glTFSerializer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inc\krak.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inc\Lodpak.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inc\MainFunctions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inc\MathFunctions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inc\Mesh.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inc\Rig.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inc\streams.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inc\Texpack.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inc\Wad.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pch.h" />
    <ClInclude Include="inc\Gnf.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inc\utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inc\anims.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="inc\converter.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`README.md`:

```md
A TOOL FOR EXTRACTING GOD OF WAR 2018 ASSETS

a new opensource updated, enhanced more intuitive and easy to use tool with more features compared to the existing gow tool:
https://forum.xentax.com/viewtopic.php?f=16&t=22897

[Join Community Discord Server](https://discord.gg/ZrE2hwvE6y)

Build Instructions:
1. Clone the repo recursively (git clone "github.com/HitmanHimself/GOWTool" --recursive)
2. Building the project requires Visual Studio 2022.
3. cmake CMakeLists.txt present in DirectXTex and GLTFSDK.
4. Build GOWTool sln/proj.

Note:
1. This tool requires 3rd party oodle dll (oo2core_7_win64.dll/oo2core_7_win32.dll), grab it from some game and paste in build dir(along with GOWTool.exe).
2. Tool is under heavy construction, you may encounter bugs.

Special thanks to akderebur, joschka, turk, DKDave and id-daemon for the help!

```

`Source.cpp`:

```cpp
#include "pch.h"
#include "Rig.h"
#include "glTFSerializer.h"
#include "Formats.h"
#include "MainFunctions.h"
#include "Texpack.h"
#include "Lodpak.h"
#include "Wad.h"
#include "krak.h"
#include "utils.h"
#include "Gnf.h"
#include "converter.h"

bool ImportAllGnf(const std::filesystem::path& gnfSrcDir, vector<Texpack*>& texpacks)
{
    if (gnfSrcDir.empty() || !gnfSrcDir.is_absolute() || !std::filesystem::exists(gnfSrcDir) || !std::filesystem::is_directory(gnfSrcDir))
    {
        return false;
    }

    std::vector<Gnf::GnfImage*> gnfImages;
    std::vector<uint64_t> gnfHashes;
    std::filesystem::directory_iterator dir(gnfSrcDir);
    for (const std::filesystem::directory_entry& entry : dir)
    {
        Gnf::GnfImage* gnfImage = new Gnf::GnfImage();
        if (Utils::str_tolower(entry.path().extension().string()) == ".gnf")
        {
            std::ifstream ifs(entry.path().string(), std::ios::binary | std::ios::in);
            ifs.seekg(0x0, std::ios::end);
            size_t size = ifs.tellg();
            ifs.seekg(0x0, std::ios::beg);

            if (size < 0x200)
            {
                continue;
                ifs.close();
            }

            uint32_t magic;
            ifs.read((char*)&magic, sizeof(uint32_t));
            if (magic != gnfImage->header.gnfMagic)
            {
                continue;
                ifs.close();
            }

            ifs.seekg(0x0, std::ios::beg);

            byte* bytes = new byte[size];
            ifs.read((char*)bytes, size);
            ifs.close();

            try
            {
                gnfImage->ReadImage(bytes);
            }
            catch (std::exception& ex)
            {
                continue;
            }

            gnfImages.push_back(gnfImage);
            delete[] bytes;
        }
        else if (Utils::str_tolower(entry.path().extension().string()) == ".dds")
        {
            std::ifstream ifs(entry.path().string(), std::ios::binary | std::ios::in);
            ifs.seekg(0x0, std::ios::end);
            size_t size = ifs.tellg();
            ifs.seekg(0x0, std::ios::beg);

            if (size < 0x95)
            {
                continue;
                ifs.close();
            }

            uint32_t magic;
            ifs.read((char*)&magic, sizeof(uint32_t));
            
            if (magic != 0x20534444)
            {
                continue;
                ifs.close();
            }
            
            ifs.seekg(0x0, std::ios::beg);

            byte* ddsbytes = new byte[size];
            ifs.read((char*)ddsbytes, size);
            ifs.close();

            try
            {
                byte* bytes = nullptr;
                size = ConvertDDSToGnf(ddsbytes, size, bytes);
                gnfImage->ReadImage(bytes);

                delete[] bytes;
            }
            catch (const std::exception& ex)
            {
                continue;
            }

            gnfImages.push_back(gnfImage);
            delete[] ddsbytes;
        }
        else
            continue;

        try
        {
            std::stringstream s;
            std::string str = entry.path().filename().stem().string();
            if (str.find("TX_") != std::string::npos)
            {
                str = str.substr(str.find_last_of("_") + 1, 16);
                if (str.length() < 16)
                    continue;
                s << std::hex << str;
            }
            else
            {
                s << str;
            }
            uint64_t hash = 0;
            s >> hash;

            gnfHashes.push_back(hash);
        }
        catch (const std::exception& ex)
        {
            continue;
        }
    }

    if (gnfImages.size() < 1)
        return false;

    if (gnfImages.size() != gnfHashes.size())
        return false;

    std::filesystem::path outTexpackPath = gnfSrcDir.parent_path() / (gnfSrcDir.filename().string() + ".texpack");
    std::filesystem::path outTexpackTocPath = gnfSrcDir.parent_path() / (gnfSrcDir.filename().string() + ".texpack.toc");

    std::ofstream ofs(outTexpackPath.string(), std::ios::binary | std::ios::out);
    std::ofstream ofs1(outTexpackTocPath.string(), std::ios::binary | std::ios::out);

    for (size_t i = 0; i < 4; i++)
    {
        uint64_t z = 0x0ULL;
        ofs.write((char*)&z, sizeof(z));
        ofs1.write((char*)&z, sizeof(z));
    }

    uint32_t _texSectionOff = (0x38 + gnfImages.size() * 0x18 + gnfImages.size() * 0x20 + 15) & (~15);
    uint32_t _blocksCount = gnfImages.size();
    uint32_t _blocksInfoOff = 0x38 + gnfImages.size() * 0x18;
    uint32_t _TexsCount = gnfImages.size();

    ofs.write((char*)&_texSectionOff, sizeof(_texSectionOff));
    ofs.write((char*)&_blocksCount, sizeof(_blocksCount));
    ofs.write((char*)&_blocksInfoOff, sizeof(_blocksInfoOff));
    ofs.write((char*)&_TexsCount, sizeof(_TexsCount));
    uint64_t z = 0x5ULL;
    ofs.write((char*)&z, sizeof(z));

    ofs1.write((char*)&_texSectionOff, sizeof(_texSectionOff));
    ofs1.write((char*)&_blocksCount, sizeof(_blocksCount));
    ofs1.write((char*)&_blocksInfoOff, sizeof(_blocksInfoOff));
    ofs1.write((char*)&_TexsCount, sizeof(_TexsCount));
    ofs1.write((char*)&z, sizeof(z));

    Texpack::TexInfo* texInfos = new Texpack::TexInfo[_TexsCount];
    Texpack::BlockInfo* blockInfos = new Texpack::BlockInfo[_TexsCount];

    size_t woff = _texSectionOff;
    for (size_t i = 0; i < _TexsCount; i++)
    {
        Gnf::GnfImage*& gnfImg = gnfImages[i];

        for (size_t j = 0; j < texpacks.size(); j++)
        {
            if (texpacks[j]->GetUserHash(gnfHashes[i], gnfImg->header.userHash))
                break;
        }
        Texpack::TexInfo& texInfo = texInfos[i];
        texInfo._fileHash = gnfHashes[i];
        texInfo._userHash = gnfImg->header.userHash;
        texInfo._blockInfoOff = _blocksInfoOff + (i * 0x20);

        Texpack::BlockInfo& blockInfo = blockInfos[i];
        blockInfo._blockOff = uint32_t(woff >> 4);
        blockInfo._rawSize = gnfImg->header.dataSize;
        blockInfo._blockSize = (gnfImg->header.fileSize + 0x24 + 15) & (~15);
        blockInfo._mipLvlStart = gnfImg->header.mipmaps;
        blockInfo._mipLvlEnd = 0;
        blockInfo._tocFileIdx = 0;
        blockInfo._mipWidth = gnfImg->header.width + 1;
        blockInfo._mipHeight = gnfImg->header.height + 1;
        blockInfo._nextSiblingBlockInfoOff = -1LL;

        woff += blockInfo._blockSize;
    }

    for (size_t i = 0; i < _TexsCount; i++)
    {
        Texpack::TexInfo& texInfo = texInfos[i];

        ofs.write((char*)&texInfo, sizeof(texInfo));
        ofs1.write((char*)&texInfo, sizeof(texInfo));
    }
    for (size_t i = 0; i < _TexsCount; i++)
    {
        Texpack::BlockInfo& blockInfo = blockInfos[i];

        ofs.write((char*)&blockInfo, sizeof(blockInfo));
        ofs1.write((char*)&blockInfo, sizeof(blockInfo));
    }

    size_t curOff = ofs.tellp();
    for (size_t i = 0; i < _texSectionOff - curOff; i++)
    {
        byte zz = 0;
        ofs.write((char*)&zz, sizeof(zz));
        ofs1.write((char*)&zz, sizeof(zz));
    }

    ofs1.close();
    for (size_t i = 0; i < _TexsCount; i++)
    {
        Gnf::GnfImage*& gnfImg = gnfImages[i];
        uint32_t zz = 0x1U;
        ofs.write((char*)&zz, sizeof(zz));
        zz = 0x124U;
        ofs.write((char*)&zz, sizeof(zz));

        uint32_t blockSize = (gnfImg->header.fileSize + 0x24 + 15) & (~15);
        ofs.write((char*)&blockSize, sizeof(blockSize));
        zz = 0x5U;
        ofs.write((char*)&zz, sizeof(zz));
        ofs.write((char*)&gnfImg->header, sizeof(gnfImg->header));

        uint64_t zzz = 0x3ULL;
        ofs.write((char*)&zzz, sizeof(zzz));
        uint16_t zzzz = uint16_t(gnfImg->header.mipmaps + 1);
        ofs.write((char*)&zzzz, sizeof(zzzz));
        ofs.write((char*)&zzzz, sizeof(zzzz));
        ofs.write((char*)&gnfImg->header.dataSize, sizeof(gnfImg->header.dataSize));
        zz = 0x2U;
        ofs.write((char*)&zz, sizeof(zz));

        ofs.write((char*)gnfImg->imageData.get(), gnfImg->header.dataSize);

        curOff = ofs.tellp();
        for (size_t j = 0; j < ((curOff + 15) & (~15)) - curOff; j++)
        {
            byte z = 0;
            ofs.write((char*)&z, sizeof(z));
        }
    }
    ofs.close();
    return true;
}
bool ExportAllTextures(WadFile& wad, vector<Texpack*>& texpacks, const std::filesystem::path& outdir,bool dds)
{
    if (wad._FileEntries.size() < 1 || texpacks.size() < 1)
        return false;
    if (!std::filesystem::exists(outdir))
        return false;
    for (int i = 0; i < wad._FileEntries.size(); i++)
    {
        if (wad._FileEntries[i].type == WadFile::FileType::Texture)
        {
            std::stringstream s;
            std::string name = wad._FileEntries[i].name.substr(3);
            s << std::hex << name.substr(name.find_last_of("_") + 1, 16);
            uint64_t hash = 0;
            s >> hash;
            for (int j = 0; j < texpacks.size(); j++)
            {
                if (texpacks[j]->ContainsTexture(hash))
                {
                    texpacks[j]->ExportGnf(outdir, hash, wad._FileEntries[i].name, dds);
                    break;
                }
            }
        }
    }
    return true;
}
bool ExtractAllFiles(WadFile& wad, const std::filesystem::path& outdir)
{
    if (wad._FileEntries.size() < 1)
        return false;
    if (!std::filesystem::exists(outdir))
        return false;
    for (int i = 0; i < wad._FileEntries.size(); i++)
    {
        std::filesystem::path outfile = outdir / (wad._FileEntries[i].name + "." + std::to_string(i) + ".bin");
        std::fstream fs;
        fs.open(outfile.string(), ios::binary | ios::out);
        wad.GetBuffer(i, fs);
        fs.close();
    }
    return true;
}
bool ExportAllSkinnedMesh(WadFile& wad, vector<Lodpack*>& lodpacks,const std::filesystem::path& outdir)
{
    if (wad._FileEntries.size() < 1 || lodpacks.size() < 1)
        return false;
    if (!std::filesystem::exists(outdir))
        return false;
    vector<int> usedMeshBufferIndices;
    for (int i = 0; i < wad._FileEntries.size(); i++)
    {
        if (wad._FileEntries[i].type == WadFile::FileType::SkinnedMeshDef)
        {
            std::string name = wad._FileEntries[i].name.substr(3, wad._FileEntries[i].name.length() - 5);
            std::stringstream meshDefStream;
            std::stringstream meshBuffStream;
            std::stringstream rigStream;
            wad.GetBuffer(i, meshDefStream);
            for (int j = 0; j < wad._FileEntries.size(); j++)
            {
                if (wad._FileEntries[j].type == WadFile::FileType::SkinnedMeshBuff && (wad._FileEntries[j].name.find(wad._FileEntries[i].name) != std::string::npos))
                {
                    if (std::find(usedMeshBufferIndices.begin(), usedMeshBufferIndices.end(), j) != usedMeshBufferIndices.end())
                        continue;
                    wad.GetBuffer(j, meshBuffStream);
                    usedMeshBufferIndices.push_back(j);
                    break;
                }
            }
            for (int j = 0; j < wad._FileEntries.size(); j++)
            {
                if (wad._FileEntries[j].type == WadFile::FileType::Rig && (wad._FileEntries[j].name.find("Proto") != std::string::npos))
                {
                    std::string sample = Utils::str_tolower(wad._FileEntries[j].name.substr(7, wad._FileEntries[j].name.length() - 7));
                    if (sample == name)
                    {
                        wad.GetBuffer(j, rigStream);
                        break;
                    }
                }
            }

            MGDefinition meshDef;
            auto meshInfos = meshDef.ReadMG(meshDefStream);
            Rig rig(rigStream);

            vector<RawMeshContainer> meshes;
            for (int j = 0; j < meshInfos.size(); j++)
            {
                char buf[10];
                sprintf_s(buf, "%04d", j);
                string subname = "submesh_" + string(buf) + "_" + std::to_string(meshInfos[j].LODlvl);
                if (meshInfos[j].LODlvl > 0)
                    continue;
                if (meshInfos[j].Hash == 0)
                {
                    if (meshBuffStream.tellp() != std::streampos(0))
                    {
                        meshes.push_back(containRawMesh(meshInfos[j], meshBuffStream, subname));
                    }
                }
                else
                {
                    std::stringstream buffer;
                    for (int k = 0; k < lodpacks.size(); k++)
                    {
                        if (lodpacks[k]->GetBuffer(meshInfos[j].Hash, buffer))
                            break;
                    }
                    if (buffer.tellp() != std::streampos(0))
                    {
                        meshes.push_back(containRawMesh(meshInfos[j], buffer, subname));
                    }
                }
            }
            std::filesystem::path outfile = outdir / (wad._FileEntries[i].name + "." + std::to_string(i) + ".glb");
            WriteGLTF(outfile, meshes, rig);
        }
    }
    return true;
}
bool ExportAllRigidMesh(WadFile& wad, vector<Lodpack*>& lodpacks, const std::filesystem::path& outdir)
{
    if (wad._FileEntries.size() < 1 || lodpacks.size() < 1)
        return false;
    if (!std::filesystem::exists(outdir))
        return false;
    vector<int> usedMeshBufferIndices;
    for (int i = 0; i < wad._FileEntries.size(); i++)
    {
        if (wad._FileEntries[i].type == WadFile::FileType::RigidMeshDefData && (wad._FileEntries[i].name.find("smsh_data") != std::string::npos))
        {
            std::string name = wad._FileEntries[i].name.substr(0, wad._FileEntries[i].name.length() - 10);
            std::stringstream meshDefStream;
            wad.GetBuffer(i, meshDefStream);
            SmshDefinition smshDef;
            auto meshInfos = smshDef.ReadSmsh(meshDefStream);

            std::stringstream meshBuffStream;
            for (int j = 0; j < wad._FileEntries.size(); j++)
            {
                if (wad._FileEntries[j].type == WadFile::FileType::SkinnedMeshBuff && (wad._FileEntries[j].name.find(name) != std::string::npos))
                {
                    if (std::find(usedMeshBufferIndices.begin(), usedMeshBufferIndices.end(), j) != usedMeshBufferIndices.end())
                        continue;
                    wad.GetBuffer(j, meshBuffStream);
                    usedMeshBufferIndices.push_back(j);
                    break;
                }
            }
            Rig rig;

            vector<RawMeshContainer> meshes;
            for (int j = 0; j < meshInfos.size(); j++)
            {
                char buf[10];
                sprintf_s(buf, "%04d", j);
                string subname = "submesh_" + string(buf) + "_" + std::to_string(meshInfos[j].LODlvl);
                if (meshInfos[j].LODlvl > 0)
                    continue;
                if (meshInfos[j].Hash == 0)
                {
                    meshes.push_back(containRawMesh(meshInfos[j], meshBuffStream, subname));
                }
                else
                {
                    std::stringstream buffer;
                    for (int k = 0; k < lodpacks.size(); k++)
                    {
                        if (lodpacks[k]->GetBuffer(meshInfos[j].Hash, buffer))
                            break;
                    }
                    if (buffer.tellp() != std::streampos(0))
                    {
                        meshes.push_back(containRawMesh(meshInfos[j], buffer, subname));
                    }
                }
            }
            std::filesystem::path outfile = outdir / (wad._FileEntries[i].name + "." + std::to_string(i) + ".glb");
            WriteGLTF(outfile, meshes, rig);
        }
    }
    return true;
}

void PrintHelp()
{
    cout << "\nGod of War Tool\n";
    cout << "\nUsage:\n";
    cout << "  GOWTool [command] [options]\n";
    cout << "\nCommands:\n";
    cout << "  wad       Target a Wad file for export.\n";
    cout << "  texpack   Target a Texpack file for export.\n";
    cout << "  settings  Change tool settings.\n";
    cout << "\nOptions:\n";
    cout << "  -h, --help  Show help and usage information.\n";
}
int main(int argc, char* argv[])
{
    /*
    for (int i = 0; i < argc; i++)
    {
        printf("arg[%d]: %s\n", i, argv[i]);
    }
    */
    if (argc < 2)
    {
        Utils::Logger::Error("Required argument was not provided.\n");
        PrintHelp();
        return -1;
    }

    CHAR charbuffer[260] = { 0 };
    GetCurrentDirectoryA(sizeof(charbuffer), charbuffer);
    std::filesystem::path configpath = std::filesystem::path(charbuffer) / "config.ini";

    GetPrivateProfileStringA("Settings", "Gamedir", "", charbuffer, sizeof(charbuffer), configpath.string().c_str());
    std::filesystem::path gamedir(charbuffer);

    std::string command(argv[1]);

    if (command == "-h" || command == "--help")
    {
        PrintHelp();
        return 0;
    }
    else if (command == "wad")
    {
        auto LogHelp = []()
        {
            cout << "\nwad\n";
            cout << "  Target a Wad file for export.\n";
            cout << "\nUsage:\n";
            cout << "  GOWTool wad [options]\n";
            cout << "\nOptions:\n";
            cout << "  -p, --path <path>        Input path to .wad file.\n";
            cout << "  -o, --outpath <outpath>  Output directory.\n";
            cout << "  -e, --extract            Extract all files from .wad.\n";
            cout << "  -m, --mesh               Export all meshes from .wad.\n";
            cout << "  -t, --texture            Export all textures from .wad.\n";
            cout << "  -d, --dds                Export Textures in DDS Format.\n";
            cout << "  -h, --help               Show help and usage information.\n";

        };
        if (argc < 3)
        {
            Utils::Logger::Error("No option/arguments provided: ");
            LogHelp();
            return -1;
        }
        std::filesystem::path path;
        std::filesystem::path outdir;
        bool mesh = false;
        bool texture = false;
        bool extract = false;
        bool dds = false;
        for (int i = 2; i < argc; i++)
        {
            std::string op(argv[i]);
            if (op == "-h" || op == "--help")
            {
                LogHelp();
                return 0;
            }
            else if (op == "-p" || op == "--path")
            {
                if (argc > (i + 1))
                {
                    path = std::filesystem::path(argv[i + 1]);
                    i++;
                }
                else
                {
                    Utils::Logger::Error("\nRequired argument missing for option: -p");
                    LogHelp();
                    return -1;
                }
            }
            else if (op == "-o" || op == "--outpath")
            {
                if (argc > (i + 1))
                {
                    outdir = std::filesystem::path(argv[i + 1]);
                    i++;
                }
                else
                {
                    Utils::Logger::Error("\nRequired argument missing for option: -o");
                    LogHelp();
                    return -1;
                }
            }
            else if (op == "-e" || op == "--extract")
            {
                extract = true;
            }
            else if (op == "-m" || op == "--mesh")
            {
                mesh = true;
            }
            else if (op == "-d" || op == "--dds")
            {
                dds = true;
            }
            else if (op == "-t" || op == "--texture")
            {
                texture = true;
            }
            else
            {
                Utils::Logger::Error(("\nInvalid option or argument: " + op).c_str());
                LogHelp();
                return -1;
            }
        }
        if (!mesh && !texture && !extract)
        {
            Utils::Logger::Error("\nExport file type option not specified");
            LogHelp();
            return -1;
        }
        if (path.empty() || !path.is_absolute() || !std::filesystem::exists(path) || !std::filesystem::is_regular_file(path) || path.extension().string() != ".wad")
        {
            Utils::Logger::Error(("\nInvalid/Unspecified .wad file path: " + path.string()).c_str());
            LogHelp();
            return -1;
        }
        if (gamedir.empty() || !gamedir.is_absolute() || !std::filesystem::exists(gamedir) || !std::filesystem::is_directory(gamedir))
        {
            Utils::Logger::Error("\nGame dir is either not specified in config.ini or its invalid, pls change it through settings or edit config.ini");
            LogHelp();
            return -1;
        }
        if (outdir.empty())
        {
            outdir = path.parent_path() / path.stem();
            std::filesystem::create_directory(outdir);
        }
        if(!outdir.is_absolute() || !std::filesystem::exists(outdir) || !std::filesystem::is_directory(outdir))
        {
            Utils::Logger::Error(("\nInvalid outdir specified: " + outdir.string()).c_str());
            LogHelp();
            return -1;
        }
        WadFile wad;
        wad.Read(path);
        if (extract)
        {
            if (ExtractAllFiles(wad, outdir))
            {
                Utils::Logger::Success(("\nSuccessfully extracted all files to: " + outdir.string()).c_str());
            }
            else
            {
                Utils::Logger::Error("\nMeshes export Failed.");
            }
        }
        if (mesh)
        {
            std::filesystem::recursive_directory_iterator dir(gamedir);
            std::vector<Lodpack*> lodpacks;
            for (const std::filesystem::directory_entry& entry : dir)
            {
                if (entry.path().extension().string() == ".lodpack")
                {
                    Lodpack* pack = new Lodpack(entry.path().string());
                    lodpacks.push_back(pack);
                }
            }
            if (lodpacks.size() < 1)
            {
                Utils::Logger::Error("\nspecified gamedir(including sub-directories) doesn't contain any .lodpack files, export failed");
                return -1;
            }
            if (ExportAllSkinnedMesh(wad, lodpacks, outdir) && ExportAllRigidMesh(wad, lodpacks, outdir))
            {
                Utils::Logger::Success(("\nSuccessfully exported all meshes to: " + outdir.string()).c_str());
            }
            else
            {
                Utils::Logger::Error("\nMeshes export Failed.");
            }
        }
        if (texture)
        {
            std::filesystem::recursive_directory_iterator dir(gamedir);
            std::vector<Texpack*> texpacks;
            for (const std::filesystem::directory_entry& entry : dir)
            {
                if (entry.path().extension().string() == ".texpack")
                {
                    Texpack* pack = new Texpack(entry.path().string());
                    texpacks.push_back(pack);
                }
            }
            if (texpacks.size() < 1)
            {
                Utils::Logger::Error("\nspecified gamedir(including sub-directories) doesn't contain any .texpack files, export failed");
                return -1;
            }
            if (ExportAllTextures(wad, texpacks, outdir,dds))
            {
                Utils::Logger::Success(("\nSuccessfully exported all textures to: " + outdir.string()).c_str());
            }
            else
            {
                Utils::Logger::Error("\nTextures export Failed.");
            }
        }
        return 0;
    }
    else if (command == "texpack")
    {
        auto LogHelp = []()
        {
            cout << "\ntexpack\n";
            cout << "  Target a Texpack file for export.\n";
            cout << "\nUsage:\n";
            cout << "  GOWTool texpack [options]\n";
            cout << "\nOptions:\n";
            cout << "  -e, --export             Export textures from .texpack file.\n";
            cout << "  -d, --dds                Export Textures in DDS Format.\n";
            cout << "  -i, --import             Import textures and pack .texpack file.\n";
            cout << "  -p, --path <path>        path to .texpack file or path to directory containing dds/gnf files for import.\n";
            cout << "  -o, --outpath <outpath>  Output directory.\n";
        };
        if (argc < 3)
        {
            Utils::Logger::Error("\nNo option/arguments provided: ");
            LogHelp();
            return -1;
        }
        std::filesystem::path path;
        std::filesystem::path outdir;
        bool imp = false;
        bool exp = false;
        bool dds = false;
        for (int i = 2; i < argc; i++)
        {
            std::string op(argv[i]);
            if (op == "-h" || op == "--help")
            {
                LogHelp();
                return 0;
            }
            else if (op == "-p" || op == "--path")
            {
                if (argc > (i + 1))
                {
                    path = std::filesystem::path(argv[i + 1]);
                    i++;
                }
                else
                {
                    Utils::Logger::Error("Required argument missing for option: -p");
                    LogHelp();
                    return -1;
                }
            }
            else if (op == "-o" || op == "--outpath")
            {
                if (argc > (i + 1))
                {
                    outdir = std::filesystem::path(argv[i + 1]);
                    i++;
                }
                else
                {
                    Utils::Logger::Error("Required argument missing for option: -o");
                    LogHelp();
                    return -1;
                }
            }
            else if (op == "-e" || op == "--export")
            {
                exp = true;

            }
            else if (op == "-i" || op == "--import")
            {
                imp = true;
            }
            else if (op == "-d" || op == "--dds")
            {
                dds = true;
            }
            else
            {
                Utils::Logger::Error(("Invalid option or argument: " + op).c_str());
                LogHelp();
                return -1;
            }
        }
        if (imp && exp)
        {
            Utils::Logger::Error("\nCannot export and import textures at the same time, choose one!");
            LogHelp();
            return -1;
        }
        if (!imp && !exp)
        {
            Utils::Logger::Error("\nTexpack export or import not specified!");
            LogHelp();
            return -1;
        }
        if (outdir.empty())
        {
            outdir = path.parent_path() / path.stem();
            std::filesystem::create_directory(outdir);
        }
        if (!outdir.is_absolute() || !std::filesystem::exists(outdir) || !std::filesystem::is_directory(outdir))
        {
            Utils::Logger::Error(("\nInvalid outdir specified: " + outdir.string()).c_str());
            LogHelp();
            return -1;
        }
        if (exp)
        {
            if (path.empty() || !path.is_absolute() || !std::filesystem::exists(path) || !std::filesystem::is_regular_file(path) || path.extension().string() != ".texpack")
            {
                Utils::Logger::Error(("\nInvalid/Unspecified .texpack file path: " + path.string()).c_str());
                LogHelp();
                return -1;
            }
            Texpack pack = Texpack(path.string());
            if (pack.ExportAllGnf(outdir,dds))
            {
                Utils::Logger::Success(("\nSuccessfully exported all textures to: " + outdir.string()).c_str());
                return 0;
            }
            else
            {
                Utils::Logger::Error("\nTextures export Failed.");
                return -1;
            }
        }
        if (imp)
        {
            if (!path.is_absolute() || !std::filesystem::exists(path) || !std::filesystem::is_directory(path))
            {
                Utils::Logger::Error(("\nInvalid/Unspecified dds/gnf directory " + path.string()).c_str());
                LogHelp();
                return -1;
            }
            std::filesystem::recursive_directory_iterator dir(gamedir);
            std::vector<Texpack*> texpacks;
            for (const std::filesystem::directory_entry& entry : dir)
            {
                if (entry.path().extension().string() == ".texpack")
                {
                    Texpack* pack = new Texpack(entry.path().string());
                    texpacks.push_back(pack);
                }
            }
            if (texpacks.size() < 1)
            {
                Utils::Logger::Error("\nspecified gamedir(including sub-directories) doesn't contain any .texpack files, import failed");
                return -1;
            }
            if (ImportAllGnf(path,texpacks))
            {
                Utils::Logger::Success("\nSuccessfully Imported all and packed textures to .texpack ");
                return 0;
            }
            else
            {
                Utils::Logger::Error("\nTextures export Failed.");
                return -1;
            }
        }
    }
    else if (command == "settings")
    {
        auto LogHelp = []()
        {
            cout << "\nsettings\n";
            cout << "  Change tool settings.\n";
            cout << "\nUsage:\n";
            cout << "  GOWTool settings [options]\n";
            cout << "\nOptions:\n";
            cout << "  -g, --gamedir <gamedir>  Input path to the God of War gamefiles directory\n";
        };
        if (argc < 3)
        {
            Utils::Logger::Error("\nNo option/arguments provided: ");
            LogHelp();
            return -1;
        }
        for (int i = 2; i < argc; i++)
        {
            std::string op(argv[i]);
            if (op == "-h" || op == "--help")
            {
                LogHelp();
                return 0;
            }
            else if (op == "-g" || op == "--gamedir")
            {
                if (argc > (i + 1))
                {
                    gamedir = std::filesystem::path(argv[i + 1]);
                    i++;
                }
                else
                {
                    Utils::Logger::Error("\nRequired argument missing for option: -g");
                    LogHelp();
                    return -1;
                }
            }
            else
            {
                Utils::Logger::Error(("\nInvalid option or argument: " + op).c_str());
                LogHelp();
                return -1;
            }
        }
        if (gamedir.empty() || !gamedir.is_absolute() || !std::filesystem::exists(gamedir) || !std::filesystem::is_directory(gamedir))
        {
            Utils::Logger::Error(("\nInvalid gamedir specified: " + gamedir.string()).c_str());
            LogHelp();
            return -1;
        }
        if (WritePrivateProfileStringA("Settings", "Gamedir", gamedir.string().c_str(), configpath.string().c_str()))
        {
            Utils::Logger::Success("\nGamedir Updated");
            return 0;
        }
    }
    else
    {
        Utils::Logger::Error(("Invalid command or argument: " + command).c_str());
        PrintHelp();
        return -1;
    }

    return 0;
    /*
    CHAR charbuffer[260] = { 0 };
    GetCurrentDirectoryA(sizeof(charbuffer), charbuffer);

    std::filesystem::path configpath = std::filesystem::path(charbuffer) / "config.ini";

    GetPrivateProfileStringA("Settings", "Gamedir", "", charbuffer, sizeof(charbuffer), configpath.string().c_str());
    std::string gamedirstr(charbuffer);
    if (gamedirstr.empty())
    {
        gamedirstr = std::filesystem::path(Utils::FileDialogs::OpenFile("GOW Boot (eboot.bin)\0eboot.bin\0","Open God of War eboot.bin")).parent_path().string();
        if (gamedirstr.empty())
        {
            return -1;
        }
        if (!WritePrivateProfileStringA("Settings", "Gamedir",gamedirstr.c_str(), configpath.string().c_str()))
        {
            return -1;
        }
    }
    */
} 
```

`inc/Formats.h`:

```h
#pragma once
#include "Mesh.h"

class MGDefinition
{
	uint16_t defCount;
	uint32_t* defOffsets;
public:
	vector<MeshInfo> ReadMG(std::stringstream& file);
	~MGDefinition();
};
class SmshDefinition
{
public:
	vector<MeshInfo> ReadSmsh(std::iostream& file);
};
```

`inc/Gnf.h`:

```h
#pragma once
#include "pch.h"

namespace Gnf
{
    enum class Format : uint32_t
    {
        FormatInvalid = 0x0,
        Format8 = 0x1,
        Format16 = 0x2,
        Format8_8 = 0x3,
        Format32 = 0x4,
        Format16_16 = 0x5,
        Format10_11_11 = 0x6,
        Format11_11_10 = 0x7,
        Format10_10_10_2 = 0x8,
        Format2_10_10_10 = 0x9,
        Format8_8_8_8 = 0xa,
        Format32_32 = 0xb,
        Format16_16_16_16 = 0xc,
        Format32_32_32 = 0xd,
        Format32_32_32_32 = 0xe,
        FormatReserved_15 = 0xf,
        Format5_6_5 = 0x10,
        Format1_5_5_5 = 0x11,
        Format5_5_5_1 = 0x12,
        Format4_4_4_4 = 0x13,
        Format8_24 = 0x14,
        Format24_8 = 0x15,
        FormatX24_8_32 = 0x16,
        FormatReserved_23 = 0x17,
        FormatReserved_24 = 0x18,
        FormatReserved_25 = 0x19,
        FormatReserved_26 = 0x1a,
        FormatReserved_27 = 0x1b,
        FormatReserved_28 = 0x1c,
        FormatReserved_29 = 0x1d,
        FormatReserved_30 = 0x1e,
        FormatReserved_31 = 0x1f,
        FormatGB_GR = 0x20,
        FormatBG_RG = 0x21,
        Format5_9_9_9 = 0x22,
        FormatBC1 = 0x23,
        FormatBC2 = 0x24,
        FormatBC3 = 0x25,
        FormatBC4 = 0x26,
        FormatBC5 = 0x27,
        FormatBC6 = 0x28,
        FormatBC7 = 0x29,
        FormatReserved_42 = 0x2a,
        FormatReserved_43 = 0x2b,
        FormatFMask8_S2_F1 = 0x2c,
        FormatFMask8_S4_F1 = 0x2d,
        FormatFMask8_S8_F1 = 0x2e,
        FormatFMask8_S2_F2 = 0x2f,
        FormatFMask8_S4_F2 = 0x30,
        FormatFMask8_S4_F4 = 0x31,
        FormatFMask16_S16_F1 = 0x32,
        FormatFMask16_S8_F2 = 0x33,
        FormatFMask32_S16_F2 = 0x34,
        FormatFMask32_S8_F4 = 0x35,
        FormatFMask32_S8_F8 = 0x36,
        FormatFMask64_S16_F4 = 0x37,
        FormatFMask64_S16_F8 = 0x38,
        Format4_4 = 0x39,
        Format6_5_5 = 0x3a,
        Format1 = 0x3b,
        Format1_Reversed = 0x3c,
        Format32_AS_8 = 0x3d,
        Format32_AS_8_8 = 0x3e,
        Format32_AS_32_32_32_32 = 0x3f
    };
    enum class FormatType : uint32_t
    {
        FormatTypeUNorm = 0x0,
        FormatTypeSNorm = 0x1,
        FormatTypeUScaled = 0x2,
        FormatTypeSScaled = 0x3,
        FormatTypeUInt = 0x4,
        FormatTypeSInt = 0x5,
        FormatTypeSNorm_OGL = 0x6,
        FormatTypeFloat = 0x7,
        FormatTypeReserved_8 = 0x8,
        FormatTypeSRGB = 0x9,
        FormatTypeUBNorm = 0xa,
        FormatTypeUBNorm_OGL = 0xb,
        FormatTypeUBInt = 0xc,
        FormatTypeUBScaled = 0xd,
        FormatTypeReserved_14 = 0xe,
        FormatTypeReserved_15 = 0xf
    };
    struct alignas(0x100) Header
    {
        uint32_t gnfMagic{ 0x20464E47U };
        uint32_t imageDataOffset{ 0xF8U };
        uint32_t unk1{ 0x80102U };
        uint32_t fileSize{ 0x200U };
        uint32_t unk2{ 0x0U };
        struct
        {
            uint32_t unk3 : 20{ 0x8 };
            Format format : 6{ Format::Format8 };
            FormatType formatType : 4{ FormatType::FormatTypeUNorm };
            uint32_t unk4 : 2{ 0x0 };
        };
        struct
        {
            uint32_t width : 14 { 0x0 };
            uint32_t height : 14 { 0x0 };
            uint32_t unk5 : 4 { 0x7 };
        };
        struct
        {
            uint32_t destX : 3 { 0x4 };
            uint32_t destY : 3 { 0x0 };
            uint32_t destZ : 3 { 0x0 };
            uint32_t destW : 3 { 0x1 };
            uint32_t unk6 : 4 { 0x0 };
            uint32_t mipmaps : 4 { 0x0 };
            uint32_t unk7 : 12 { 0x96D };
        };
        struct
        {
            uint32_t depth : 13 { 0x0 };
            uint32_t pitch : 13 { 0xF };
            uint32_t unk8 : 6 { 0x0 };
        };
        uint32_t unk9 { 0x0 };
        uint32_t unk10 { 0x0 };
        uint32_t dataSize { 0x100 };
        uint32_t userMagic = 0x52455355U;
        uint32_t unk11 { 0x28 };
        uint64_t userHash { UINT64_MAX };
    };
    class GnfImage
    {
    public:
        Header header;
        std::shared_ptr<byte[]> imageData;
        GnfImage();
        static void UnSwizzle(const byte* src, byte* dest, const uint16_t& w, const uint16_t& h, const uint16_t& bpp, const uint16_t& pixbl);
        static void Swizzle(const byte* src, byte* dst, const uint16_t& w, const uint16_t& h, const uint16_t& bpp, const uint16_t& pixbl);
        static int morton(int t, int sx, int sy);
        void ReadImage(const byte* file);
        void WriteImage(byte*& file);
    };
}
```

`inc/Lodpak.h`:

```h
#pragma once
#include "pch.h"

class Lodpack
{
	uint32_t groupCount;
	uint32_t* groupStartOff;
	uint64_t* groupHash;
	uint32_t* groupBlockSize;


	uint32_t TotalmembersCount;
	uint32_t* memberGroupIndex;
	uint32_t* memberOffsetter;
	uint64_t* memberHash;
	uint32_t* memberBlockSize;
public:
	ifstream file;
	Lodpack(string filename);
	bool GetBuffer(uint64_t& Hash, std::stringstream& outstream);
};
```

`inc/MainFunctions.h`:

```h
#pragma once
#include "pch.h"
#include "Mesh.h"
#include "Formats.h"
RawMeshContainer containRawMesh(MeshInfo& meshinfo, std::stringstream& file,std::string name, uint64_t off = 0);
```

`inc/MathFunctions.h`:

```h
#pragma once
#include <cmath>

class BitHacks
{
public:
	static uint32_t RoundUpTo2(uint32_t v);
};


struct Vec3
{
	float X { 0 }, Y { 0 }, Z { 0 };
	Vec3() = default;
	Vec3(const float& x, const float& y, const float& z);
	float magnitude(void);
	void normalize(void);
};
struct Vec2
{
	float X { 0 }, Y { 0 };
	Vec2() = default;
	Vec2(const float& x, const float& y);
};
struct Vec4
{
	union
	{
		float XYZW[4];
		struct
		{
			float X, Y, Z, W;
		};
	};
	Vec4();
	Vec4(const float& x, const float& y, const float& z, const float& w);
	float& operator[](size_t idx);
	float magnitude(void);
	void normalize(void);
};
struct Matrix4x4 {
	union {
		Vec4 rows[4];
		struct {
			float	m11, m12, m13, m14;
			float 	m21, m22, m23, m24;
			float	m31, m32, m33, m34;
			float	m41, m42, m43, m44;
		};
	};
	// Init Identity Matrix
	Matrix4x4();
	Vec4& operator[](size_t idx);
	void operator=(Matrix4x4& RHS);
	Matrix4x4 operator *(Matrix4x4& RHS);
	Matrix4x4 operator+(Matrix4x4& RHS);
	Matrix4x4 operator-(Matrix4x4& RHS);
	void Transpose(void);
	void Display(void);
};
// for quaternion q = cos(theta/2) + sin(theta/2)*(x.i + y.j + z.k)
// where x.i + y.j + z.k is a normalized vector(or unit vector i.e. mag = 1) as the rotation axis
// theta = angle of rotation also q = W + X.i + Y.j + Z.k
// hence w = cos(theta/2) and X.i + Y.j + Z.k = sin(theta/2)*(x.i + y.j + z.k)
struct Quat 
{
	float X { 0 }, Y { 0 }, Z { 0 }, W { 1 };
	Quat() = default;
	Quat(const float& x, const float& y, const float& z, const float& w);
	float getreal(void);
};
Vec4 TenBitShifted(const uint32_t& U32);
Vec4 TenBitUnsigned(const uint32_t& U32);
```

`inc/Mesh.h`:

```h
#pragma once

#include "MathFunctions.h"

struct RawMeshContainer
{
	uint32_t VertCount{ 0 }, IndCount{ 0 };
	Vec3* vertices{ nullptr };
	Vec3* normals{ nullptr };
	Vec4* tangents{ nullptr };
	Vec2* txcoord0{ nullptr };
	Vec2* txcoord1{ nullptr };
	Vec2* txcoord2{ nullptr };
	uint16_t* indices{ nullptr };
	uint16_t** joints{ nullptr };
	float** weights{ nullptr };
	std::string name;
	RawMeshContainer() = default;
};
enum class PrimitiveTypes
{
	POSITION,
	NORMALS,
	TANGENTS,
	TEXCOORD_0,
	TEXCOORD_1,
	TEXCOORD_2,
	UNKNOWN0,
	UNKNOWN1,
	UNKNOWN2,
	JOINTS0 = 9,
	WEIGHTS0,
	UNKNOWN3,
	UNKNOWN4,
	UNKNOWN5,
	UNKNOWN6,
	UNKNOWN7
};

enum class DataTypes
{
	FLOAT,
	HALFWORD_STRUCT_0,
	WORD_STRUCT_0,
	WORD_STRUCT_1,        // TEN TEN TEN 2 Normalized maybe? but sometimes its unsigned 1023 normalized (for weights) other times signed -511 shift 512 normalized 1's or 2's compliment maybe
	HALFWORD_STRUCT_1,   // USHORT un normalized maybe
	UNSIGNED_SHORT = 6,	// USHORT normalized
	HALFWORD_STRUCT_2,  //USHORT half normalized or compliment bs maybe
	BYTE_STRUCT_0		//UBYTE_UNORM
};
struct Component
{
	PrimitiveTypes primitiveType;
	DataTypes dataType;
	uint8_t elementCount;
	uint8_t offset;
	uint8_t bufferIndex;
};
struct MeshInfo
{
	uint64_t Hash{ 0 };
	uint32_t vertCount{ 0 };
	uint32_t indCount{ 0 };
	uint64_t vertexOffset{ UINT64_MAX };
	uint64_t indicesOffset{ UINT64_MAX };
	vector<Component> Components;
	vector<uint64_t> bufferOffset;
	vector<uint16_t> bufferStride;

	Vec3 meshScale{ };
	Vec3 meshMin{ };
	uint16_t LODlvl{ 0 };
	uint16_t boneAssociated{ 0 };
};
```

`inc/Rig.h`:

```h
#pragma once
#include "pch.h"
#include "MathFunctions.h"
class Rig
{
public:
	uint16_t boneCount{0};
	int16_t* boneParents;
	string* boneNames;
	Matrix4x4* matrix;
	Matrix4x4* IBMs;
public:
	Rig(std::stringstream& fs);
	Rig() = default;
};
```

`inc/Texpack.h`:

```h
#pragma once

#include "pch.h"

class Texpack
{
	uint32_t _texSectionOff {0};
	uint32_t _blocksCount{ 0 };
	uint32_t _blocksInfoOff{ 0 };
	uint32_t _TexsCount{ 0 };
public:
	struct TexInfo
	{
		uint64_t _fileHash;
		uint64_t _userHash;
		uint64_t _blockInfoOff;
	};

	struct BlockInfo
	{
		uint32_t _blockOff;
		uint32_t _rawSize;
		uint64_t _blockSize;
		byte _mipLvlStart;
		byte _mipLvlEnd;
		uint16_t _tocFileIdx;
		uint16_t _mipWidth;
		uint16_t _mipHeight;
		uint64_t _nextSiblingBlockInfoOff;
	};
private:
	TexInfo* _texInfos{ nullptr };
	BlockInfo* _blockInfos{ nullptr };

	uint64_t* _blockInfoOffsets{ nullptr };
	ifstream fs;
public:
	Texpack(const std::filesystem::path &filepath);
	bool ContainsTexture(const uint64_t &hash);
	bool ExportGnf(byte* &output,const uint64_t& hash, uint32_t& expSiz);
	bool ExportGnf(const std::filesystem::path& dir,const uint64_t& hash,std::string name = "",bool dds = false);
	bool ExportAllGnf(const std::filesystem::path& dir,bool dds = false);
	bool GetUserHash(const uint64_t& hash, uint64_t& outUserHash);
	~Texpack();
};
```

`inc/Wad.h`:

```h
#pragma once

struct WadFile
{
	enum class FileType : uint16_t
	{
		None = 0x0,
		RigidMeshDefData = 0xB,
		Rig = 0x3D,
		SkinnedMeshDef = 0x98,
		Texture = 0x80A1,
		SkinnedMeshBuff = 0x8198,
	};
	struct FileDesc
	{
		std::string name;
		uint16_t group;
		FileType type;
		uint32_t size;
		uint32_t offset;
	};
	vector<FileDesc> _FileEntries;
	bool Read(const std::filesystem::path& filepath);
	bool GetBuffer(const uint32_t& entryIdx, uint8_t* output);
	bool GetBuffer(const uint32_t& entryIdx, std::iostream& outstream);
private:
	ifstream fs;
};
```

`inc/anims.h`:

```h
#pragma once
#include "pch.h"

class AnimDef
{
private:
public:
	void Read(std::iostream &ms);
};
```

`inc/converter.h`:

```h
#pragma once
#include "pch.h"

size_t ConvertGnfToDDS(const byte* gnfsrc, const size_t& gnfsize, byte*& ddsout);
size_t ConvertDDSToGnf(const byte* ddssrc, const size_t& ddssize, byte*& gnfout);
```

`inc/glTFSerializer.h`:

```h
#pragma once
#include "pch.h"
#include "Mesh.h"
#include "Rig.h"
void WriteGLTF(const std::filesystem::path& path, const vector<RawMeshContainer>& expMeshes, const Rig& Armature);
```

`inc/krak.h`:

```h
#pragma once

#include "pch.h"
#include <windows.h>

constexpr uint64_t SAFE_SPACE = 64;

typedef int WINAPI OodLZ_CompressFunc(
	int codec, uint8_t* src_buf, size_t src_len, uint8_t* dst_buf, int level,
	void* opts, size_t offs, size_t unused, void* scratch, size_t scratch_size);

typedef int WINAPI OodLZ_DecompressFunc(uint8_t* src_buf, int src_len, uint8_t* dst, size_t dst_size,
	int fuzz, int crc, int verbose,
	uint8_t* dst_base, size_t e, void* cb, void* cb_ctx, void* scratch, size_t scratch_size, int threadPhase);

extern OodLZ_CompressFunc* OodLZ_Compress;
extern OodLZ_DecompressFunc* OodLZ_Decompress;

void LoadLib();
```

`inc/streams.h`:

```h
#pragma once
#include <iostream>
class membuf : public std::basic_streambuf<char> {
public:
    membuf(const char* p, size_t l) {
        setg((char*)p, (char*)p, (char*)p + l);
    }
};
class memstream : public std::istream {
public:
    memstream(const char* p, size_t l) :
        std::istream(&_buffer),
        _buffer(p, l) {
        rdbuf(&_buffer);
    }

private:
    membuf _buffer;
};
```

`inc/utils.h`:

```h
#pragma once
#include "pch.h"
#include <Windows.h>

namespace Utils
{
	class FileDialogs
	{
	public:
		static std::string OpenFile(const char* filter = "All Files (*.*)\0*.*\0", const char* title = "Open", HWND owner = NULL);
	};
	class Logger
	{
	public:
		static void Error(const char* msg);
		static void Warning(const char* msg);
		static void Success(const char* msg);
	};
	std::string inline str_tolower(std::string s) {
		std::transform(s.begin(), s.end(), s.begin(),
			[](unsigned char c) { return std::tolower(c); }
		);
		return s;
	}
}
```

`pch.h`:

```h
#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <filesystem>
#include <stdexcept>
#include <memory>

using std::ios;
using std::ifstream;
using std::ofstream;
using std::string;
using std::vector;
using std::ostream;
using std::cout;
using std::cin;

typedef unsigned char byte;
```

`src/Formats.cpp`:

```cpp
#include <pch.h>
#include "Formats.h"

MGDefinition::~MGDefinition()
{
	delete[] defOffsets;
}

vector<MeshInfo> MGDefinition::ReadMG(std::stringstream& file)
{
	vector<MeshInfo> meshesinfo;
	file.seekg(56);
	file.read((char*)&defCount, sizeof(uint16_t));

	defOffsets = new uint32_t[defCount];

	file.seekg(76);
	for (uint16_t i = 0; i < defCount; i++)
	{
		file.read((char*)&defOffsets[i], sizeof(uint32_t));
	}

	for (uint16_t i = 0; i < defCount; i++)
	{
		uint32_t offset = defOffsets[i];

		file.seekg((uint64_t)offset);

		uint16_t boneAsso = UINT16_MAX;
		file.read((char*)&boneAsso, sizeof(uint16_t));
		uint8_t subMeshCount = UINT8_MAX;
		file.read((char*)&subMeshCount, sizeof(uint8_t));

		for (uint8_t e = 0; e < subMeshCount; e++)
		{
			uint32_t subMeshOffsetter = UINT32_MAX;
			file.seekg((uint64_t)offset + 60 + (uint64_t)e * 4);
			file.read((char*)&subMeshOffsetter, sizeof(uint32_t));

			uint32_t partCount = UINT32_MAX;
			file.seekg((uint64_t)offset + (uint64_t)subMeshOffsetter);
			file.read((char*)&partCount, sizeof(uint32_t));

			if (partCount == 0)
				continue;

			uint32_t partOffset = (uint32_t)file.tellg() + 8;
			for (uint32_t c = 0; c < partCount; c++)
			{
				MeshInfo info;
				info.LODlvl = e;
				info.boneAssociated = boneAsso;
				file.seekg((uint64_t)partOffset + (uint64_t)c * 4);
				uint32_t off = UINT32_MAX;
				file.read((char*)&off, sizeof(uint32_t));
				off += partOffset + c * 4;

				uint32_t smBaseOff = off;
				file.seekg((uint64_t)smBaseOff + 48);

				uint32_t indOff = UINT32_MAX;
				file.read((char*)&indOff, sizeof(uint32_t));
				info.indicesOffset = indOff;

				file.seekg(4, std::ios::cur);
				uint32_t vertOff = UINT32_MAX;
				file.read((char*)&vertOff, sizeof(uint32_t));
				info.vertexOffset = vertOff;

				file.seekg(4, std::ios::cur);
				uint32_t vertC = UINT32_MAX;
				file.read((char*)&vertC, sizeof(uint32_t));
				info.vertCount = vertC;
				uint32_t indC = UINT32_MAX;
				file.read((char*)&indC, sizeof(uint32_t));
				info.indCount = indC;

				file.seekg((uint64_t)smBaseOff + 16);
				Vec3 extent;
				file.read((char*)&extent.X, sizeof(float));
				file.read((char*)&extent.Y, sizeof(float));
				file.read((char*)&extent.Z, sizeof(float));
				Vec3 origin;
				file.read((char*)&origin.X, sizeof(float));
				file.read((char*)&origin.Y, sizeof(float));
				file.read((char*)&origin.Z, sizeof(float));

				//std::cout << extent.X << " " << extent.Y << " " << extent.Z << " " << origin.X << " " << origin.Y << " " << origin.Z << std::endl;
				Vec3 scale(extent.X * 2, extent.Y * 2, extent.Z * 2);
				Vec3 min(origin.X - extent.X, origin.Y - extent.Y, origin.Z - extent.Z);

				info.meshScale = scale;
				info.meshMin = min;
				file.seekg((uint64_t)smBaseOff + 84);

				uint32_t vertexBlockInfoOffset = UINT32_MAX;
				file.read((char*)&vertexBlockInfoOffset, sizeof(uint32_t));
				uint32_t vertexBlockOffsetterOff = UINT32_MAX;
				file.read((char*)&vertexBlockOffsetterOff, sizeof(uint32_t));

				uint64_t Hash = UINT64_MAX;
				file.read((char*)&Hash, sizeof(uint64_t));
				info.Hash = Hash;

				file.seekg((uint64_t)smBaseOff + (uint64_t)vertexBlockInfoOffset - 8);

				uint8_t buffC = UINT8_MAX;
				file.read((char*)&buffC, sizeof(uint8_t));
				file.seekg(2, std::ios::cur);
				uint8_t compC = UINT8_MAX;
				file.read((char*)&compC, sizeof(uint8_t));

				file.seekg(smBaseOff + vertexBlockOffsetterOff);
				for (uint8_t bIdx = 0; bIdx < buffC; bIdx++)
				{
					uint32_t bufferOff = 0;
					file.read((char*)&bufferOff, sizeof(uint32_t));
					info.bufferOffset.push_back(bufferOff);
				}

				file.seekg((uint64_t)smBaseOff + (uint64_t)vertexBlockInfoOffset);

				for (uint16_t d = 0; d < compC; d++)
				{
					Component component;
					uint8_t val = 0;
					file.read((char*)&val, sizeof(uint8_t));
					component.primitiveType = static_cast<PrimitiveTypes>(val);
					file.read((char*)&val, sizeof(uint8_t));
					component.dataType = static_cast<DataTypes>(val);
					if (component.primitiveType == PrimitiveTypes::UNKNOWN0)/* && (component.dataType != DataTypes::BYTE_STRUCT_0 && component.dataType != DataTypes::HALFWORD_STRUCT_1) && component.dataType != DataTypes::HALFWORD_STRUCT_2) */
						cout << file.tellg() << "\n";
					file.read((char*)&component.elementCount, sizeof(uint8_t));
					file.read((char*)&component.offset, sizeof(uint8_t));
					file.read((char*)&component.bufferIndex, sizeof(uint8_t));

					file.seekg(3, std::ios::cur);

					info.Components.push_back(component);
				}
				for (uint8_t bIdx = 0; bIdx < buffC; bIdx++)
				{
					uint16_t stride = 0;
					for (uint8_t f = 0; f < info.Components.size(); f++)
					{
						if (bIdx == info.Components[f].bufferIndex)
						{
							switch (info.Components[f].dataType)
							{
							case DataTypes::FLOAT:
								stride += 4 * info.Components[f].elementCount;
								break;
							case DataTypes::WORD_STRUCT_0:
								stride += 4 * info.Components[f].elementCount;
								break;
							case DataTypes::WORD_STRUCT_1:
								stride += 4 * info.Components[f].elementCount;
								break;
							case DataTypes::HALFWORD_STRUCT_0:
								stride += 2 * info.Components[f].elementCount;
								break;
							case DataTypes::HALFWORD_STRUCT_1:
								stride += 2 * info.Components[f].elementCount;
								break;
							case DataTypes::HALFWORD_STRUCT_2:
								stride += 2 * info.Components[f].elementCount;
								break;
							case DataTypes::UNSIGNED_SHORT:
								stride += 2 * info.Components[f].elementCount;
								break;
							case DataTypes::BYTE_STRUCT_0:
								stride += 1 * info.Components[f].elementCount;
								break;
							default:
								break;
							}
						}
					}
					info.bufferStride.push_back(stride);
				}
				meshesinfo.push_back(info);
			}
		}
	}
	return meshesinfo;
}
vector<MeshInfo> SmshDefinition::ReadSmsh(std::iostream& file)
{
	uint32_t groupDataOffset = 0;
	uint32_t meshDefSectionOff = 0;
	uint32_t meshDefCnt = 0;
	file.seekg(0x48, ios::beg);
	file.read((char*)&groupDataOffset, sizeof(uint32_t));
	groupDataOffset += 0x48;
	file.seekg(0x58, ios::beg);
	file.read((char*)&meshDefSectionOff, sizeof(uint32_t));
	file.read((char*)&meshDefCnt, sizeof(uint32_t));
	meshDefSectionOff += 0x58;


	uint64_t currHash = UINT64_MAX;
	uint16_t curGroup = UINT16_MAX;
	uint16_t curLod = 0;
	vector<MeshInfo> meshinfos;
	for (uint32_t i = 0; i < meshDefCnt; i++)
	{
		file.seekg(meshDefSectionOff + i * 4, ios::beg);
		uint32_t off = 0;
		file.read((char*)&off, sizeof(uint32_t));
		off += i * 4;
		file.seekg(meshDefSectionOff + off, ios::beg);

		file.seekg(0x10, ios::cur);
		Vec3 extent;
		file.read((char*)&extent.X, sizeof(float));
		file.read((char*)&extent.Y, sizeof(float));
		file.read((char*)&extent.Z, sizeof(float));
		Vec3 origin;
		file.read((char*)&origin.X, sizeof(float));
		file.read((char*)&origin.Y, sizeof(float));
		file.read((char*)&origin.Z, sizeof(float));

		Vec3 scale(extent.X * 2, extent.Y * 2, extent.Z * 2);
		Vec3 min(origin.X - extent.X, origin.Y - extent.Y, origin.Z - extent.Z);

		MeshInfo info;
		info.meshScale = scale;
		info.meshMin = min;
		info.boneAssociated = 0;

		file.seekg(meshDefSectionOff + off + 0x30, ios::beg);
		uint32_t temp = 0;
		file.read((char*)&temp, sizeof(uint32_t));
		info.indicesOffset = temp;
		file.seekg(4, std::ios::cur);
		file.read((char*)&temp, sizeof(uint32_t));
		info.vertexOffset = temp;
		file.seekg(4, std::ios::cur);
		file.read((char*)&info.vertCount, sizeof(uint32_t));
		file.read((char*)&info.indCount, sizeof(uint32_t));

		file.seekg(meshDefSectionOff + off + 0x54, ios::beg);
		uint32_t vertexInfoOffset = 0;
		uint32_t vertexDataOffsOffset = 0;
		file.read((char*)&vertexInfoOffset, sizeof(uint32_t));
		file.read((char*)&vertexDataOffsOffset, sizeof(uint32_t));
		file.read((char*)&info.Hash, sizeof(uint64_t));

		file.seekg(meshDefSectionOff + off + vertexInfoOffset - 8);

		uint8_t buffC = 0;
		file.read((char*)&buffC, sizeof(uint8_t));
		file.seekg(2, std::ios::cur);
		uint8_t compC = 0;
		file.read((char*)&compC, sizeof(uint8_t));

		file.seekg(meshDefSectionOff + off + vertexInfoOffset);
		for (uint16_t d = 0; d < compC; d++)
		{
			Component component;
			uint8_t val = 0;
			file.read((char*)&val, sizeof(uint8_t));
			component.primitiveType = static_cast<PrimitiveTypes>(val);
			file.read((char*)&val, sizeof(uint8_t));
			component.dataType = static_cast<DataTypes>(val);
			file.read((char*)&component.elementCount, sizeof(uint8_t));
			file.read((char*)&component.offset, sizeof(uint8_t));
			file.read((char*)&component.bufferIndex, sizeof(uint8_t));

			file.seekg(3, std::ios::cur);

			info.Components.push_back(component);
		}

		for (uint8_t bIdx = 0; bIdx < buffC; bIdx++)
		{
			uint16_t stride = 0;
			for (uint8_t f = 0; f < info.Components.size(); f++)
			{
				if (bIdx == info.Components[f].bufferIndex)
				{
					switch (info.Components[f].dataType)
					{
					case DataTypes::FLOAT:
						stride += 4 * info.Components[f].elementCount;
						break;
					case DataTypes::WORD_STRUCT_0:
						stride += 4 * info.Components[f].elementCount;
						break;
					case DataTypes::WORD_STRUCT_1:
						stride += 4 * info.Components[f].elementCount;
						break;
					case DataTypes::HALFWORD_STRUCT_0:
						stride += 2 * info.Components[f].elementCount;
						break;
					case DataTypes::HALFWORD_STRUCT_1:
						stride += 2 * info.Components[f].elementCount;
						break;
					case DataTypes::HALFWORD_STRUCT_2:
						stride += 2 * info.Components[f].elementCount;
						break;
					case DataTypes::UNSIGNED_SHORT:
						stride += 2 * info.Components[f].elementCount;
						break;
					case DataTypes::BYTE_STRUCT_0:
						stride += 1 * info.Components[f].elementCount;
						break;
					default:
						break;
					}
				}
			}
			info.bufferStride.push_back(stride);
		}

		file.seekg(meshDefSectionOff + off + vertexDataOffsOffset);
		for (uint8_t bIdx = 0; bIdx < buffC; bIdx++)
		{
			uint32_t bufferOff = 0;
			file.read((char*)&bufferOff, sizeof(uint32_t));
			info.bufferOffset.push_back(bufferOff);
		}

		file.seekg(groupDataOffset + i * 2, ios::beg);
		uint16_t group = 0;
		file.read((char*)&group, sizeof(uint16_t));
		if (curGroup == group && currHash != info.Hash)
		{
			++curLod;
		}
		if (curGroup != group)
		{
			curGroup = group;
			curLod = 0;
		}
		info.LODlvl = curLod;
		if (currHash != info.Hash)
		{
			currHash = info.Hash;
		}

		meshinfos.push_back(info);
	}
	return meshinfos;
}
```

`src/Gnf.cpp`:

```cpp
#include "pch.h"
#include "gnf.h"

namespace Gnf
{
	GnfImage::GnfImage()
	{
		imageData = std::make_shared<byte[]>(0x100);
	}
	void GnfImage::ReadImage(const byte* file)
	{
		memcpy(&header, file, sizeof(Header));
		imageData = std::make_shared<byte[]>(header.dataSize);
		memcpy(imageData.get(), file + sizeof(Header), header.dataSize);

		return;
	}
	void GnfImage::WriteImage(byte*& file)
	{
		file = new byte[this->header.fileSize];
		memcpy(file, &(this->header), sizeof(this->header));
		memcpy(file + sizeof(this->header), imageData.get(), this->header.dataSize);

		return;
	}
	void GnfImage::UnSwizzle(const byte* src, byte* dst, const uint16_t& w, const uint16_t& h,const uint16_t &bpp, const uint16_t &pixbl)
	{
		size_t min = pixbl * pixbl * bpp / 8;
		uint32_t num2 = w * h * bpp / 8;
		if (num2 <= min)
		{
			memcpy(dst, src, min);
			return;
		}

		uint32_t num4 = pixbl; // sub to change
		uint32_t num5 = bpp * 2;
		if (num4 == 1)
		{
			num5 = bpp / 8;
		}
		byte* array1 = new byte[num2 * 2];
		byte* array2 = new byte[16];
		int num6 = h / num4;
		int num7 = w / num4;
		int roff = 0;
		for (int i = 0; i < (num6 + 7) / 8; i++)
		{
			for (int j = 0; j < (num7 + 7) / 8; j++)
			{
				for (int k = 0; k < 64; k++)
				{
					int num8 = morton(k, 8, 8);
					int num9 = num8 / 8;
					int num10 = num8 % 8;
					memcpy(array2, src + roff, num5);
					roff += num5;
					if (j * 8 + num10 < num7 && i * 8 + num9 < num6)
					{
						int destinationIndex = num5 * ((i * 8 + num9) * num7 + j * 8 + num10);
						memcpy(array1 + destinationIndex, array2, num5);
					}
				}
			}
		}

		memcpy(dst, array1, num2);

		delete[] array1;
		delete[] array2;
		return;
	}
	void GnfImage::Swizzle(const byte* src, byte* dst, const uint16_t& w, const uint16_t& h, const uint16_t& bpp, const uint16_t& pixbl)
	{
		size_t min = pixbl * pixbl * bpp / 8;
		uint32_t num2 = w * h * bpp / 8;
		if (num2 <= min)
		{
			memcpy(dst, src, min);
			return;
		}

		uint32_t num4 = pixbl; // sub to change
		uint32_t num5 = bpp * 2;
		if (num4 == 1)
		{
			num5 = bpp / 8;
		}
		byte* array1 = new byte[num2 * 2];
		int num6 = h / num4;
		int num7 = w / num4;
		int roff = 0;
		for (int i = 0; i < (num6 + 7) / 8; i++)
		{
			for (int j = 0; j < (num7 + 7) / 8; j++)
			{
				for (int k = 0; k < 64; k++)
				{
					int num8 = morton(k, 8, 8);
					int num9 = num8 / 8;
					int num10 = num8 % 8;
					if (j * 8 + num10 < num7 && i * 8 + num9 < num6)
					{
						int destinationIndex = num5 * ((i * 8 + num9) * num7 + j * 8 + num10);
						memcpy(array1 + roff, src + destinationIndex, num5);
						roff += num5;
					}
				}
			}
		}
		memcpy(dst, array1, num2);

		delete[] array1;
		return;
	}
	int GnfImage::morton(int t, int sx, int sy)
	{
		int num = 0;
		int num2 = 0;
		int num3;
		int num4 = (num3 = 1);
		int num5 = t;
		int num6 = sx;
		int num7 = sy;
		num = 0;
		num2 = 0;
		while (num6 > 1 || num7 > 1)
		{
			if (num6 > 1)
			{
				num += num4 * (num5 & 1);
				num5 >>= 1;
				num4 *= 2;
				num6 >>= 1;
			}
			if (num7 > 1)
			{
				num2 += num3 * (num5 & 1);
				num5 >>= 1;
				num3 *= 2;
				num7 >>= 1;
			}
		}
		return num2 * sx + num;
	}
}
```

`src/Lodpack.cpp`:

```cpp
#include "pch.h"
#include "Lodpak.h"

Lodpack::Lodpack(std::string filename)
{
	file.open(filename, ios::in | ios::binary);
	file.read((char*)&groupCount, sizeof(uint32_t));

	groupStartOff = new uint32_t[groupCount];
	groupHash = new uint64_t[groupCount];
	groupBlockSize = new uint32_t[groupCount];

	file.seekg(16);
	for (uint32_t i = 0; i < groupCount; i++)
	{
		file.read((char*)&groupStartOff[i], sizeof(uint32_t));
		file.seekg(4, file.cur);
		file.read((char*)&groupHash[i], sizeof(uint64_t));
		file.read((char*)&groupBlockSize[i], sizeof(uint32_t));
		file.seekg(4, file.cur);
	}

	file.seekg(4);
	file.read((char*)&TotalmembersCount, sizeof(uint32_t));

	memberGroupIndex = new uint32_t[TotalmembersCount];
	memberOffsetter = new uint32_t[TotalmembersCount];
	memberHash = new uint64_t[TotalmembersCount];
	memberBlockSize = new uint32_t[TotalmembersCount];

	uint32_t offset = 24 * groupCount + 16;
	file.seekg(offset);

	for (uint32_t e = 0; e < TotalmembersCount; e++)
	{
		file.read((char*)&memberGroupIndex[e], sizeof(uint32_t));
		file.read((char*)&memberOffsetter[e], sizeof(uint32_t));
		file.read((char*)&memberHash[e], sizeof(uint64_t));
		file.read((char*)&memberBlockSize[e], sizeof(uint32_t));
		file.seekg(4, std::ios::cur);
	}
}
bool Lodpack::GetBuffer(uint64_t& Hash, std::stringstream& outstream)
{
	outstream.str("");
	outstream.clear();
	for (uint32_t e = 0; e < TotalmembersCount; e++)
	{
		if (memberHash[e] == Hash)
		{
			std::unique_ptr<char[]> arr = std::make_unique<char[]>(memberBlockSize[e]);
			file.seekg(memberOffsetter[e] + groupStartOff[memberGroupIndex[e]], std::ios::beg);
			file.read(arr.get(), memberBlockSize[e]);
			outstream.write(arr.get(), memberBlockSize[e]);
			return true;
		}
	}
	return false;
}
```

`src/MainFunctions.cpp`:

```cpp
#include <pch.h>
#include "MainFunctions.h"
#include "MathFunctions.h"
#include "../inc/Mesh.h"
#include "../inc/Formats.h"

RawMeshContainer containRawMesh(MeshInfo& meshinfo, std::stringstream& file,std::string name, uint64_t off)
{
    RawMeshContainer Mesh;
    Mesh.name = name;
    Mesh.VertCount = meshinfo.vertCount;
    Mesh.IndCount = meshinfo.indCount;

    Mesh.joints = new uint16_t * [Mesh.VertCount];
    for (uint32_t i = 0; i < Mesh.VertCount; i++)
        Mesh.joints[i] = new uint16_t[4];
    Mesh.weights = new float* [Mesh.VertCount];
    for (uint32_t i = 0; i < Mesh.VertCount; i++)
        Mesh.weights[i] = new float[4];

    for (uint32_t v = 0; v < meshinfo.vertCount; v++)
    {
        Mesh.joints[v][0] = meshinfo.boneAssociated;
        Mesh.joints[v][1] = 0;
        Mesh.joints[v][2] = 0;
        Mesh.joints[v][3] = 0;

        Mesh.weights[v][0] = 1;
        Mesh.weights[v][1] = 0;
        Mesh.weights[v][2] = 0;
        Mesh.weights[v][3] = 0;
    }

    for (uint32_t i = 0; i < meshinfo.Components.size(); i++)
    {
        switch (meshinfo.Components[i].primitiveType)
        {
        case PrimitiveTypes::POSITION:
            Mesh.vertices = new Vec3[Mesh.VertCount];
            //cout << "POSITION" << meshinfo.vertexOffset << " " << meshinfo.Components[i].offset << " " << meshinfo.Components[i].bufferIndex << " " << meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] << " " << meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] << "\n";
            for (uint32_t v = 0; v < meshinfo.vertCount; v++)
            {
                file.seekg(meshinfo.Components[i].offset + meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] + (uint64_t)meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] * (uint64_t)v + off);
                if (meshinfo.Components[i].dataType == DataTypes::UNSIGNED_SHORT)
                {
                    uint16_t x, y, z;
                    file.read((char*)&x, sizeof(uint16_t));
                    file.read((char*)&y, sizeof(uint16_t));
                    file.read((char*)&z, sizeof(uint16_t));
                    Vec3 vec;
                    vec.X = (float)x / 65535.f;
                    vec.Y = (float)y / 65535.f;
                    vec.Z = (float)z / 65535.f;
                    Mesh.vertices[v].X = vec.X * meshinfo.meshScale.X + meshinfo.meshMin.X;
                    Mesh.vertices[v].Y = vec.Y * meshinfo.meshScale.Y + meshinfo.meshMin.Y;
                    Mesh.vertices[v].Z = vec.Z * meshinfo.meshScale.Z + meshinfo.meshMin.Z;
                }
                else
                {
                    file.read((char*)&Mesh.vertices[v].X, sizeof(float));
                    file.read((char*)&Mesh.vertices[v].Y, sizeof(float));
                    file.read((char*)&Mesh.vertices[v].Z, sizeof(float));
                }
            }
            break;
        case PrimitiveTypes::NORMALS:
            Mesh.normals = new Vec3[Mesh.VertCount];
            //cout << "NORMAL" << meshinfo.vertexOffset << " " << meshinfo.Components[i].offset << " " << meshinfo.Components[i].bufferIndex << " " << meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] << " " << meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] << "\n";

            uint32_t NorRead32;
            for (uint32_t v = 0; v < meshinfo.vertCount; v++)
            {
                file.seekg(meshinfo.Components[i].offset + meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] + (uint64_t)meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] * (uint64_t)v + off);
                file.read((char*)&NorRead32, sizeof(uint32_t));
                Vec4 vec = TenBitShifted(NorRead32);
                vec.normalize();
                Mesh.normals[v].X = vec.X;
                Mesh.normals[v].Y = vec.Y;
                Mesh.normals[v].Z = vec.Z;
            }
            break;
        case PrimitiveTypes::TANGENTS:
            Mesh.tangents = new Vec4[Mesh.VertCount];
            //cout << "TANGENT" << meshinfo.vertexOffset << " " << meshinfo.Components[i].offset << " " << meshinfo.Components[i].bufferIndex << " " << meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] << " " << meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] << "\n";

            uint32_t TanRead32;
            for (uint32_t v = 0; v < meshinfo.vertCount; v++)
            {
                file.seekg(meshinfo.Components[i].offset + meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] + (uint64_t)meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] * (uint64_t)v + off);
                file.read((char*)&TanRead32, sizeof(uint32_t));
                Vec4 vec = TenBitShifted(TanRead32);
                vec.normalize();
                Mesh.tangents[v].X = vec.X;
                Mesh.tangents[v].Y = vec.Y;
                Mesh.tangents[v].Z = vec.Z;
                Mesh.tangents[v].W = 1.f;
            }
            break;
        case PrimitiveTypes::TEXCOORD_0:
            Mesh.txcoord0 = new Vec2[Mesh.VertCount];
            //cout << meshinfo.Components[i].offset + meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] + off <<  " TX0" << " " << meshinfo.vertexOffset << " " << meshinfo.Components[i].offset << " " << meshinfo.Components[i].bufferIndex << " " << meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] << " " << meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] << "\n";

            for (uint32_t v = 0; v < meshinfo.vertCount; v++)
            {
                Vec2 vec;
                file.seekg(meshinfo.Components[i].offset + meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] + (uint64_t)meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] * (uint64_t)v + off);

                if (meshinfo.Components[i].dataType == DataTypes::UNSIGNED_SHORT)
                {
                    uint16_t x, y;
                    file.read((char*)&x, sizeof(uint16_t));
                    file.read((char*)&y, sizeof(uint16_t));
                    vec.X = (float)x / 65535.f;
                    vec.Y = (float)y / 65535.f;
                }
                else if (meshinfo.Components[i].dataType == DataTypes::HALFWORD_STRUCT_2)
                {
                    uint16_t x, y;
                    file.read((char*)&x, sizeof(uint16_t));
                    file.read((char*)&y, sizeof(uint16_t));
                    vec.X = (float)x / 32767.f;
                    vec.Y = (float)y / 32767.f;
                }
                else
                {
                    file.read((char*)&vec.X, sizeof(float));
                    file.read((char*)&vec.Y, sizeof(float));
                }

                Mesh.txcoord0[v].X = vec.X;
                Mesh.txcoord0[v].Y = vec.Y;
            }
            break;
        case PrimitiveTypes::TEXCOORD_1:
            Mesh.txcoord1 = new Vec2[Mesh.VertCount];
            //cout << "TX1" << meshinfo.vertexOffset << " " << meshinfo.Components[i].offset << " " << meshinfo.Components[i].bufferIndex << " " << meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] << " " << meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] << "\n";

            for (uint32_t v = 0; v < meshinfo.vertCount; v++)
            {
                Vec2 vec;
                file.seekg(meshinfo.Components[i].offset + meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] + (uint64_t)meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] * (uint64_t)v + off);

                if (meshinfo.Components[i].dataType == DataTypes::UNSIGNED_SHORT)
                {
                    uint16_t x, y;
                    file.read((char*)&x, sizeof(uint16_t));
                    file.read((char*)&y, sizeof(uint16_t));
                    vec.X = (float)x / 65535.f;
                    vec.Y = (float)y / 65535.f;
                }
                else if (meshinfo.Components[i].dataType == DataTypes::HALFWORD_STRUCT_2)
                {
                    uint16_t x, y;
                    file.read((char*)&x, sizeof(uint16_t));
                    file.read((char*)&y, sizeof(uint16_t));
                    vec.X = (float)x / 32767.f;
                    vec.Y = (float)y / 32767.f;
                }
                else
                {
                    file.read((char*)&vec.X, sizeof(float));
                    file.read((char*)&vec.Y, sizeof(float));
                }

                Mesh.txcoord1[v].X = vec.X;
                Mesh.txcoord1[v].Y = vec.Y;
            }
            break;
        case PrimitiveTypes::TEXCOORD_2:
            Mesh.txcoord2 = new Vec2[Mesh.VertCount];
            //cout << "TX2" << meshinfo.vertexOffset << " " << meshinfo.Components[i].offset << " " << meshinfo.Components[i].bufferIndex << " " << meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] << " " << meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] << "\n";

            for (uint32_t v = 0; v < meshinfo.vertCount; v++)
            {
                Vec2 vec;
                file.seekg(meshinfo.Components[i].offset + meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] + (uint64_t)meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] * (uint64_t)v + off);

                if (meshinfo.Components[i].dataType == DataTypes::UNSIGNED_SHORT)
                {
                    uint16_t x, y;
                    file.read((char*)&x, sizeof(uint16_t));
                    file.read((char*)&y, sizeof(uint16_t));
                    vec.X = (float)x / 65535.f;
                    vec.Y = (float)y / 65535.f;
                }
                else if (meshinfo.Components[i].dataType == DataTypes::HALFWORD_STRUCT_2)
                {
                    uint16_t x, y;
                    file.read((char*)&x, sizeof(uint16_t));
                    file.read((char*)&y, sizeof(uint16_t));
                    vec.X = (float)x / 32767.f;
                    vec.Y = (float)y / 32767.f;
                }
                else
                {
                    file.read((char*)&vec.X, sizeof(float));
                    file.read((char*)&vec.Y, sizeof(float));
                }

                Mesh.txcoord2[v].X = vec.X;
                Mesh.txcoord2[v].Y = vec.Y;
            }
            break;
        case PrimitiveTypes::JOINTS0:
            //cout << "Joint0" << meshinfo.vertexOffset << " " << (uint16_t)meshinfo.Components[i].offset << " " << (uint16_t)meshinfo.Components[i].bufferIndex << " " << (uint16_t)meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] << " " << (uint16_t)meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] << "\n";

            for (uint32_t v = 0; v < meshinfo.vertCount; v++)
            {
                file.seekg(meshinfo.Components[i].offset + meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] + (uint64_t)meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] * (uint64_t)v + off);

                if (meshinfo.Components[i].dataType == DataTypes::BYTE_STRUCT_0)
                {
                    uint8_t x, y, z, w;
                    file.read((char*)&x, sizeof(uint8_t));
                    file.read((char*)&y, sizeof(uint8_t));
                    file.read((char*)&z, sizeof(uint8_t));
                    file.read((char*)&w, sizeof(uint8_t));
                    Mesh.joints[v][0] = x;
                    Mesh.joints[v][1] = y;
                    Mesh.joints[v][2] = z;
                    Mesh.joints[v][3] = w;
                }
                else
                {
                    uint16_t x, y, z, w;
                    file.read((char*)&x, sizeof(uint16_t));
                    file.read((char*)&y, sizeof(uint16_t));
                    file.read((char*)&z, sizeof(uint16_t));
                    file.read((char*)&w, sizeof(uint16_t));
                    Mesh.joints[v][0] = x;
                    Mesh.joints[v][1] = y;
                    Mesh.joints[v][2] = z;
                    Mesh.joints[v][3] = w;
                }
            }
            break;
        case PrimitiveTypes::WEIGHTS0:
            //cout << "Wgt0" << meshinfo.vertexOffset << " " << meshinfo.Components[i].offset << " " << meshinfo.Components[i].bufferIndex << " " << meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] << " " << meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] << "\n";

            uint32_t wgtRead;
            for (uint32_t v = 0; v < meshinfo.vertCount; v++)
            {
                file.seekg(meshinfo.Components[i].offset + meshinfo.bufferOffset[meshinfo.Components[i].bufferIndex] + (uint64_t)meshinfo.bufferStride[meshinfo.Components[i].bufferIndex] * (uint64_t)v + off);

                file.read((char*)&wgtRead, sizeof(uint32_t));

                Vec4 vec = TenBitUnsigned(wgtRead);

                float sum = vec.X + vec.Y + vec.Z;
                float NorRatio = 1 / sum;
                Mesh.weights[v][0] = vec.X * NorRatio;
                Mesh.weights[v][1] = vec.Y * NorRatio;
                Mesh.weights[v][2] = vec.Z * NorRatio;
                Mesh.weights[v][3] = 0.f;
            }
            break;
        default:
            break;
        }
    }

    Mesh.indices = new uint16_t[Mesh.IndCount];
    file.seekg((uint64_t)meshinfo.indicesOffset + (uint64_t)off);
    for (uint32_t i = 0; i < meshinfo.indCount; i++)
    {
        file.read((char*)&Mesh.indices[i], sizeof(uint16_t));
    }

    return Mesh;
}
```

`src/MathFunctions.cpp`:

```cpp
#include "pch.h"
#include "MathFunctions.h"

uint32_t BitHacks::RoundUpTo2(uint32_t v)
{
	v--;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	v++;
	return v;
}

Vec3::Vec3(const float& x, const float& y, const float& z)
{
	X = x, Y = y, Z = z;
}
float Vec3::magnitude(void)
{
	return (sqrt(X * X + Y * Y + Z * Z));
}
void Vec3::normalize(void)
{
	float mag = magnitude();
	X = X / mag, Y = Y / mag, Z = Z / mag;
}
Vec2::Vec2(const float& x, const float& y)
{
	X = x, Y = y;
}
Vec4::Vec4()
{
	X = 0, Y = 0, Z = 0, W = 0;
}
Vec4::Vec4(const float& x, const float& y, const float& z, const float& w)
{
	X = x, Y = y, Z = z, W = w;
}
float& Vec4::operator[](size_t idx)
{
	if (idx > 3)
		throw std::out_of_range("idx was outside the bounds of the array, should be <= 3");
	return XYZW[idx];
}
float Vec4::magnitude(void)
{
	return (sqrt(X * X + Y * Y + Z * Z));
}
void Vec4::normalize(void)
{
	float mag = magnitude();
	X = X / mag, Y = Y / mag, Z = Z / mag;
}
Matrix4x4::Matrix4x4()
{
	rows[0] = Vec4();
	rows[0][0] = 1.f;
	rows[1] = Vec4();
	rows[1][1] = 1.f;
	rows[2] = Vec4();
	rows[2][2] = 1.f;
	rows[3] = Vec4();
	rows[3][3] = 1.f;
}
Vec4& Matrix4x4::operator[](size_t idx) {
	if (idx > 3)
		throw std::out_of_range("idx was outside the bounds of the array, should be <= 3");
	return rows[idx];
}
void Matrix4x4::operator =(Matrix4x4& RHS)
{
	for (size_t r = 0; r < 4; r++)
	{
		for (size_t c = 0; c < 4; c++)
		{
			rows[r][c] = RHS[r][c];
		}
	}
}
Matrix4x4 Matrix4x4::operator *(Matrix4x4& RHS)
{
	Matrix4x4 Result;
	for (size_t r = 0; r < 4; r++)
	{
		for (size_t c = 0; c < 4; c++)
		{
			for (size_t t = 0; t < 4; t++)
			{
				Result[r][c] += rows[r][t] * RHS[t][c];
			}
		}
	}
	return Result;
}
Matrix4x4 Matrix4x4::operator +(Matrix4x4& RHS)
{
	Matrix4x4 Result;
	for (size_t r = 0; r < 4; r++)
	{
		for (size_t c = 0; c < 4; c++)
		{
			Result[r][c] = rows[r][c] + RHS[r][c];
		}
	}
	return Result;
}
Matrix4x4 Matrix4x4::operator -(Matrix4x4& RHS)
{
	Matrix4x4 Result;
	for (size_t r = 0; r < 4; r++)
	{
		for (size_t c = 0; c < 4; c++)
		{
			Result[r][c] = rows[r][c] - RHS[r][c];
		}
	}
	return Result;
}
void Matrix4x4::Transpose(void)
{
	Matrix4x4 Result;
	for (size_t r = 0; r < 4; r++)
	{
		for (size_t c = 0; c < 4; c++)
		{
			Result[r][c] = rows[c][r];
		}
	}
	for (size_t r = 0; r < 4; r++)
	{
		for (size_t c = 0; c < 4; c++)
		{
			rows[r][c] = Result[r][c];
		}
	}
}
void Matrix4x4::Display(void)
{
	for (size_t r = 0; r < 4; r++)
	{
		for (size_t c = 0; c < 4; c++)
		{
			cout << rows[r][c] << " ";
		}
		cout << "\n";
	}
}
Quat::Quat(const float& x, const float& y, const float& z, const float& w)
{
	X = x, Y = y, Z = z, W = w;
}
float Quat::getreal(void)
{
	float m = (X * X + Y * Y + Z * Z);
	if (m > 1.0)
		return (sqrt(m - 1.f));
	else
		return (sqrt(1.f - m));
}
#pragma warning(disable:4244)
Vec4 TenBitShifted(const uint32_t& U32)
{
	float X = (U32 & 1023);
	float Y = ((U32 >> 10) & 1023);
	float Z = ((U32 >> 20) & 1023);
	float W = (U32 >> 30);

	Vec4 v(((X - 511) / 512.f), ((Y - 511) / 512.f), ((Z - 511) / 512.f), W / 3.f);
	return v;
}
Vec4 TenBitUnsigned(const uint32_t& U32)
{
	float X = (U32 & 1023);
	float Y = ((U32 >> 10) & 1023);
	float Z = ((U32 >> 20) & 1023);
	float W = (U32 >> 30);

	Vec4 v((X / 1023.f), (Y / 1023.f), (Z / 1023.f), W / 3.f);
	return v;
}
#pragma warning(default:4244)
```

`src/Rig.cpp`:

```cpp
#include "pch.h"
#include "Rig.h"

Rig::Rig(std::stringstream& fs)
{
	fs.seekg(12, std::ios::beg);
	fs.read((char*)&boneCount, sizeof(uint16_t));
	boneParents = new int16_t[boneCount];
	for (uint16_t i = 0; i < boneCount; i++)
	{
		fs.seekg(0x2E + 8 * i,std::ios::beg);
		fs.read((char*)&boneParents[i],sizeof(int16_t));
	}

	boneNames = new string[boneCount];
	uint32_t boneNamesOffset = 0;
	fs.seekg(0x18, std::ios::beg);
	fs.read((char*)&boneNamesOffset, sizeof(uint32_t));
	boneNamesOffset -= boneCount * 0x38;
	char name[56];
	for (uint16_t i = 0; i < boneCount; i++)
	{
		fs.seekg(boneNamesOffset + 56 * i, std::ios::beg);
		fs.read(name, sizeof(name));
		boneNames[i] = name;
	}

	matrix = new Matrix4x4[boneCount];

	uint32_t matricesOffset;
	fs.seekg(0x1C, std::ios::beg);
	fs.read((char*)&matricesOffset, sizeof(uint32_t));
	matricesOffset += 0x50;

	for (uint16_t i = 0; i < boneCount; i++)
	{
		fs.seekg(matricesOffset + i * 64, std::ios::beg);

		for (size_t r = 0; r < 4; r++)
		{
			for (size_t c = 0; c < 4; c++)
			{
				fs.read((char*)&matrix[i][r][c], sizeof(float));
			}
		}
	}

	IBMs = new Matrix4x4[boneCount];
	uint32_t IBMsOffset = matricesOffset + (boneCount) * 64;
	for (uint16_t i = 0; i < boneCount; i++)
	{
		fs.seekg(IBMsOffset + i * 64, std::ios::beg);

		for (size_t r = 0; r < 4; r++)
		{
			for (size_t c = 0; c < 4; c++)
			{
				fs.read((char*)&IBMs[i][r][c], sizeof(float));
			}
		}
	}
}
```

`src/Texpack.cpp`:

```cpp
#include <pch.h>
#include <Texpack.h>
#include <krak.h>
#include "Gnf.h"
#include "converter.h"

Texpack::Texpack(const std::filesystem::path& filepath)
{
	fs = ifstream(filepath.string(), ios::in | ios::binary);
	fs.seekg(0, ios::end);
	size_t end = fs.tellg();

	fs.seekg(0x20, ios::beg);

	fs.read((char*)&_texSectionOff, sizeof(uint32_t));
	fs.read((char*)&_blocksCount, sizeof(uint32_t));
	fs.read((char*)&_blocksInfoOff, sizeof(uint32_t));
	fs.read((char*)&_TexsCount, sizeof(uint32_t));

	_texInfos = new TexInfo[_TexsCount];

	fs.seekg(0x38, ios::beg);
	for (uint32_t i = 0; i < _TexsCount; i++)
	{
		TexInfo& info = _texInfos[i];
		fs.read((char*)&info, sizeof(info));
	}

	_blockInfos = new BlockInfo[_blocksCount];
	_blockInfoOffsets = new uint64_t[_blocksCount];
	fs.seekg(_blocksInfoOff, ios::beg);
	for (uint32_t i = 0; i < _blocksCount; i++)
	{
		_blockInfoOffsets[i] = fs.tellg();
		BlockInfo& info = _blockInfos[i];
		fs.read((char*)&info, sizeof(info));
	}
}
Texpack::~Texpack()
{
	fs.close();
	delete[] _blockInfos;
	delete[] _texInfos;
}
bool Texpack::ContainsTexture(const uint64_t& hash)
{
	for (uint32_t i = 0; i < _TexsCount; i++)
	{
		if (_texInfos[i]._fileHash == hash)
		{
			return true;
		}
	}
	return false;
}
bool Texpack::ExportGnf(byte* &output, const uint64_t& hash, uint32_t& expSize)
{
	TexInfo* texInfo = nullptr;
	for (uint32_t i = 0; i < _TexsCount; i++)
	{
		if (_texInfos[i]._fileHash == hash)
		{
			texInfo = &_texInfos[i];
			break;
		}
	}
	if (texInfo == nullptr)
		return false;

	std::vector<BlockInfo*> texblockInfos;

	for (uint32_t i = 0; i < _blocksCount; i++)
	{
		if (texInfo->_blockInfoOff == _blockInfoOffsets[i])
		{
			texblockInfos.push_back(&_blockInfos[i]);
			break;
		}
	}
	if (texblockInfos.size() < 1)
		return false;
	while (texblockInfos.front()->_nextSiblingBlockInfoOff != -1LL)
	{
		for (uint32_t i = 0; i < _blocksCount; i++)
		{
			if (texblockInfos.front()->_nextSiblingBlockInfoOff == _blockInfoOffsets[i])
			{
				texblockInfos.insert(texblockInfos.begin(), &_blockInfos[i]);
				break;
			}
		}
	}
	uint32_t writeSize = 0x100; //gnf Header
	for (uint32_t i = 0; i < texblockInfos.size(); i++)
	{
		writeSize += texblockInfos[i]->_rawSize;
	}
	output = new byte[writeSize];

	uint32_t writeOff = 0;
	for (uint32_t i = 0; i < texblockInfos.size(); i++)
	{
		size_t ooof = (size_t(texblockInfos[i]->_blockOff) << 4) + 4;
		fs.seekg(ooof,std::ios::beg);
		uint32_t off = 0;
		uint32_t len = 0;
		fs.read((char*)&off, sizeof(uint32_t));
		fs.read((char*)&len, sizeof(uint32_t));
		fs.seekg(4, std::ios::cur);
		if (off != 0x20)
		{
			fs.read((char*)(output + writeOff), 0x100);
			writeOff += 0x100;
			fs.seekg(4, std::ios::cur);
		}

		fs.seekg(8, std::ios::cur);
		uint32_t decSize = 0;
		fs.read((char*)&decSize, sizeof(uint32_t));

		fs.seekg(4, std::ios::cur);
		fs.read((char*)(output + writeOff), decSize);

		writeOff += decSize;
	}
	expSize = writeSize;
	return true;
}
bool Texpack::ExportGnf(const std::filesystem::path& dir, const uint64_t& hash, std::string name,bool dds)
{
	if (!std::filesystem::exists(dir))
		return false;
	byte* output = nullptr;
	uint32_t size = 0;
	bool result = ExportGnf(output, hash, size);
	if (!result)
		return false;

	std::filesystem::path outpath = dir;
	if (name.empty())
	{
		outpath /= (std::to_string(hash) + ".gnf");
	}
	else
	{
		outpath /= (name + ".gnf");
	}

	if (dds)
	{
		outpath.replace_extension(std::filesystem::path(".dds"));

		byte* ddsout = nullptr;
		size = ConvertGnfToDDS(output,size,ddsout);
		std::ofstream ofs(outpath.string(), ios::binary | ios::out);
		ofs.write((char*)ddsout, size);
		ofs.close();
		delete[] ddsout;
	}
	else
	{
		std::ofstream ofs(outpath.string(), ios::binary | ios::out);
		ofs.write((char*)output, size);
		ofs.close();
	}

	delete[] output;
	return true;
}
bool Texpack::ExportAllGnf(const std::filesystem::path& dir,bool dds)
{
	for (uint32_t i = 0; i < _TexsCount; i++)
	{
		ExportGnf(dir, _texInfos[i]._fileHash,"",dds);
	}
	return true;
}
bool Texpack::GetUserHash(const uint64_t& hash, uint64_t& outUserHash)
{
	for (uint32_t i = 0; i < _TexsCount; i++)
	{
		if (_texInfos[i]._fileHash == hash)
		{
			outUserHash = _texInfos[i]._userHash;
			return true;
		}
	}
	return false;
}


```

`src/Wad.cpp`:

```cpp
#include "pch.h"
#include "Wad.h"

bool WadFile::Read(const std::filesystem::path& filepath)
{
	if (!std::filesystem::exists(filepath))
		return false;

	fs.open(filepath.string(), ios::in | ios::binary);
	fs.seekg(0, ios::end);
	size_t end = fs.tellg();

	uint64_t pad = 0;
	fs.seekg(0, ios::beg);
	while (fs.tellg() < end)
	{
		FileDesc entry;
		fs.read((char*)&entry.group, sizeof(uint16_t));
		fs.read((char*)&entry.type, sizeof(uint16_t));
		fs.read((char*)&entry.size, sizeof(uint32_t));
		fs.seekg(0x10, ios::cur);
		char name[0x38];
		fs.read(name, sizeof(name));
		entry.name = string(name);
		fs.seekg(0x10, ios::cur);
		if (entry.size != 0)
		{
			entry.offset = static_cast<uint32_t>(fs.tellg());
			_FileEntries.push_back(entry);
			fs.seekg(entry.size, ios::cur);
			pad = fs.tellg();
			pad = (pad + 15) & (~15);
			fs.seekg(pad, ios::beg);
		}
	}
	return true;
}
bool WadFile::GetBuffer(const uint32_t& entryIdx,uint8_t* output)
{
	/*
	if (entryIdx >= _Entries.size())
		return false;
	output = new uint8_t[_Sizes[entryIdx]];
	fs.seekg(_Offsets[entryIdx], std::ios::beg);
	fs.read((char*)output, _Sizes[entryIdx]);
	*/
	return true;
	
}
bool WadFile::GetBuffer(const uint32_t& entryIdx, std::iostream& outstream)
{
	
	if (entryIdx >= _FileEntries.size())
		return false;
	std::unique_ptr<uint8_t[]> output = std::make_unique<uint8_t[]>(_FileEntries[entryIdx].size);
	fs.seekg(_FileEntries[entryIdx].offset, std::ios::beg);
	fs.read((char*)output.get(), _FileEntries[entryIdx].size);
	outstream.write((char*)output.get(), _FileEntries[entryIdx].size);
	
	return true;
}
```

`src/anims.cpp`:

```cpp
#include "pch.h"
#include "anims.h"

void AnimDef::Read(std::iostream &ms)
{
	uint16_t unk0Cnt{ 0 };
	ms.seekg(0x32, ios::beg);
	ms.read((char*)&unk0Cnt, sizeof(unk0Cnt));
	uint64_t* unk0Offs = new uint64_t[unk0Cnt];

}

```

`src/converter.cpp`:

```cpp
#include "pch.h"
#include "gnf.h"
#include "converter.h"
#include <DirectXTex/DirectXTex.h>
#include <DirectXTex/DirectXTexP.h>
#include <DirectXTex/DDS.h>
#include <dxgiformat.h>
#include "MathFunctions.h"

size_t ConvertGnfToDDS(const byte* gnfsrc, const size_t& gnfsize, byte*& ddsout)
{
	Gnf::GnfImage gnfimg;
	gnfimg.ReadImage(gnfsrc);

	DirectX::TexMetadata meta;
	meta.width = gnfimg.header.width + 1;
	meta.height = gnfimg.header.height + 1;
	meta.depth = gnfimg.header.depth + 1;
	meta.arraySize = 1;
	meta.mipLevels = gnfimg.header.mipmaps + 1;
	meta.miscFlags = 0;
	meta.miscFlags2 = 3;
	meta.dimension = DirectX::TEX_DIMENSION::TEX_DIMENSION_TEXTURE2D;

	switch (gnfimg.header.format)
	{
	case Gnf::Format::FormatBC1:
		meta.format = gnfimg.header.formatType == Gnf::FormatType::FormatTypeSRGB ? DXGI_FORMAT_BC1_UNORM_SRGB : DXGI_FORMAT_BC1_UNORM;
		break;
	case Gnf::Format::FormatBC2:
		meta.format = gnfimg.header.formatType == Gnf::FormatType::FormatTypeSRGB ? DXGI_FORMAT_BC2_UNORM_SRGB : DXGI_FORMAT_BC2_UNORM;
		break;
	case Gnf::Format::FormatBC3:
		meta.format = gnfimg.header.formatType == Gnf::FormatType::FormatTypeSRGB ? DXGI_FORMAT_BC3_UNORM_SRGB : DXGI_FORMAT_BC3_UNORM;
		break;
	case Gnf::Format::FormatBC4:
		meta.format = gnfimg.header.formatType == Gnf::FormatType::FormatTypeSNorm ? DXGI_FORMAT_BC4_SNORM : DXGI_FORMAT_BC4_UNORM;
		break;
	case Gnf::Format::FormatBC5:
		meta.format = gnfimg.header.formatType == Gnf::FormatType::FormatTypeSNorm ? DXGI_FORMAT_BC5_SNORM : DXGI_FORMAT_BC5_UNORM;
		break;
	case Gnf::Format::FormatBC6:
		meta.format = gnfimg.header.formatType == Gnf::FormatType::FormatTypeSNorm ? DXGI_FORMAT_BC6H_SF16 : DXGI_FORMAT_BC6H_UF16;
		break;
	case Gnf::Format::FormatBC7:
		meta.format = gnfimg.header.formatType == Gnf::FormatType::FormatTypeSRGB ? DXGI_FORMAT_BC7_UNORM_SRGB : DXGI_FORMAT_BC7_UNORM;
		break;
	case Gnf::Format::Format8:
		if (gnfimg.header.formatType == Gnf::FormatType::FormatTypeUNorm)
			meta.format = DXGI_FORMAT_R8_UNORM;
		else if (gnfimg.header.formatType == Gnf::FormatType::FormatTypeSNorm)
			meta.format = DXGI_FORMAT_R8_SNORM;
		else if (gnfimg.header.formatType == Gnf::FormatType::FormatTypeUInt)
			meta.format = DXGI_FORMAT_R8_UINT;
		else if (gnfimg.header.formatType == Gnf::FormatType::FormatTypeSInt)
			meta.format = DXGI_FORMAT_R8_SINT;
		break;
	default:
		throw std::exception("Format not implemented!");
		break;
	}

	// sub to change
	size_t bpp = 8;
	size_t pixbl = 4;
	switch (gnfimg.header.format)
	{
	case Gnf::Format::FormatBC1:
	case Gnf::Format::FormatBC4:
		bpp = 4;
		break;
	case Gnf::Format::FormatBC2:
	case Gnf::Format::FormatBC3:
	case Gnf::Format::FormatBC5:
	case Gnf::Format::FormatBC6:
	case Gnf::Format::FormatBC7:
		bpp = 8;
		break;
	case Gnf::Format::Format8:
		bpp = 8;
		pixbl = 1;
		break;
	default:
		throw std::exception("Format not implemented!");
		break;
	}

	byte* header = new byte[148];
	size_t required;
	DirectX::DDS_FLAGS flag = DirectX::DDS_FLAGS::DDS_FLAGS_NONE | DirectX::DDS_FLAGS::DDS_FLAGS_ALLOW_LARGE_FILES;
	switch (gnfimg.header.format)
	{
	case Gnf::Format::FormatBC1:
	case Gnf::Format::FormatBC2:
	case Gnf::Format::FormatBC3:
	case Gnf::Format::FormatBC4:
	case Gnf::Format::FormatBC5:
	case Gnf::Format::Format8:
		flag |= (meta.width > 4096) || (meta.height > 4096) ? DirectX::DDS_FLAGS::DDS_FLAGS_FORCE_DX10_EXT : DirectX::DDS_FLAGS::DDS_FLAGS_FORCE_DX9_LEGACY;
		break;
	case Gnf::Format::FormatBC6:
	case Gnf::Format::FormatBC7:
		flag |= DirectX::DDS_FLAGS::DDS_FLAGS_FORCE_DX10_EXT;
		break;
	default:
		throw std::exception("Format not implemented!");
		break;
	}
	DirectX::_EncodeDDSHeader(meta, flag, header, 148, required);

	size_t datasize = 0;
	for (uint32_t i = 0; i < meta.mipLevels; i++)
	{
		size_t w = meta.width;
		size_t h = meta.height;
		w >>= i;
		h >>= i;

		if (w < 1 && h < 1)
			throw std::exception("Invalid Mip count");

		w = std::max<size_t>(w, pixbl);
		h = std::max<size_t>(h, pixbl);

		w = (w + (pixbl - 1)) & (~(pixbl - 1));
		h = (h + (pixbl - 1)) & (~(pixbl - 1));

		size_t size = w * h * bpp / 8;

		datasize += size;
	}

	ddsout = new byte[datasize + required];
	memcpy(ddsout, header, required);

	size_t ddsoff = required;
	size_t gnfoff = 0;
	for (uint32_t i = 0; i < meta.mipLevels; i++)
	{
		size_t w = meta.width;
		size_t h = meta.height;
		w >>= i;
		h >>= i;

		if (w < 1 && h < 1)
			throw std::exception("Invalid Mip count");

		w = std::max<size_t>(w, pixbl);
		h = std::max<size_t>(h, pixbl);

		w = (w + (pixbl - 1)) & (~(pixbl - 1));
		h = (h + (pixbl - 1)) & (~(pixbl - 1));

		size_t tempw = BitHacks::RoundUpTo2(w);
		size_t temph = BitHacks::RoundUpTo2(h);
		if (i == 0 && tempw != (gnfimg.header.pitch + 1))
			throw std::exception("Pitch doesn't match RoundUp2 Width");

		tempw = pixbl == 1 ? std::max<size_t>(tempw, 16) : std::max<size_t>(tempw, 32);
		temph = pixbl == 1 ? std::max<size_t>(temph, 16) : std::max<size_t>(temph, 32);

		size_t size = tempw * temph * bpp / 8;

		byte* tempData = new byte[size];
		Gnf::GnfImage::UnSwizzle(gnfimg.imageData.get() + gnfoff, tempData, tempw, temph, bpp,pixbl);
		gnfoff += size;

		size_t size1 = w * h * bpp / 8;
		size_t scanLineSize = w * pixbl * bpp / 8;
		size_t scanLineSizePadded = tempw * pixbl * bpp / 8;
		size_t off1 = 0;
		size_t off2 = 0;
		for (uint32_t j = 0; j < (h / pixbl); j++)
		{
			memcpy(ddsout + ddsoff + off1, tempData + off2, scanLineSize);
			off1 += scanLineSize;
			off2 += scanLineSizePadded;
		}
		ddsoff += size1;
		delete[] tempData;
	}

	return (datasize + required);
}
size_t ConvertDDSToGnf(const byte* ddssrc,const size_t &ddssize, byte*& gnfout)
{
	DirectX::TexMetadata meta;
	DirectX::DDS_FLAGS flags = DirectX::DDS_FLAGS::DDS_FLAGS_ALLOW_LARGE_FILES;
	std::unique_ptr<DirectX::ScratchImage> image(new (std::nothrow) DirectX::ScratchImage);
	DirectX::LoadFromDDSMemory(ddssrc, ddssize, flags, &meta, *image);

	Gnf::GnfImage gnfImg;

	switch (meta.format)
	{
	case DXGI_FORMAT_BC1_UNORM:
	case DXGI_FORMAT_BC1_UNORM_SRGB:
		gnfImg.header.format = Gnf::Format::FormatBC1;
		gnfImg.header.formatType = meta.format == DXGI_FORMAT_BC1_UNORM_SRGB ? Gnf::FormatType::FormatTypeSRGB : Gnf::FormatType::FormatTypeUNorm;
		break;
	case DXGI_FORMAT_BC2_UNORM:
	case DXGI_FORMAT_BC2_UNORM_SRGB:
		gnfImg.header.format = Gnf::Format::FormatBC2;
		gnfImg.header.formatType = meta.format == DXGI_FORMAT_BC2_UNORM_SRGB ? Gnf::FormatType::FormatTypeSRGB : Gnf::FormatType::FormatTypeUNorm;
		break;
	case DXGI_FORMAT_BC3_UNORM:
	case DXGI_FORMAT_BC3_UNORM_SRGB:
		gnfImg.header.format = Gnf::Format::FormatBC3;
		gnfImg.header.formatType = meta.format == DXGI_FORMAT_BC3_UNORM_SRGB ? Gnf::FormatType::FormatTypeSRGB : Gnf::FormatType::FormatTypeUNorm;
		break;
	case DXGI_FORMAT_BC4_UNORM:
	case DXGI_FORMAT_BC4_SNORM:
		gnfImg.header.format = Gnf::Format::FormatBC4;
		gnfImg.header.formatType = meta.format == DXGI_FORMAT_BC4_SNORM ? Gnf::FormatType::FormatTypeSNorm : Gnf::FormatType::FormatTypeUNorm;
		break;
	case DXGI_FORMAT_BC5_UNORM:
	case DXGI_FORMAT_BC5_SNORM:
		gnfImg.header.format = Gnf::Format::FormatBC5;
		gnfImg.header.formatType = meta.format == DXGI_FORMAT_BC5_SNORM ? Gnf::FormatType::FormatTypeSNorm : Gnf::FormatType::FormatTypeUNorm;
		break;
	case DXGI_FORMAT_BC6H_UF16:
	case DXGI_FORMAT_BC6H_SF16:
		gnfImg.header.format = Gnf::Format::FormatBC6;
		gnfImg.header.formatType = meta.format == DXGI_FORMAT_BC6H_SF16 ? Gnf::FormatType::FormatTypeSNorm : Gnf::FormatType::FormatTypeUNorm;
		break;
	case DXGI_FORMAT_BC7_UNORM:
	case DXGI_FORMAT_BC7_UNORM_SRGB:
		gnfImg.header.format = Gnf::Format::FormatBC7;
		gnfImg.header.formatType = meta.format == DXGI_FORMAT_BC7_UNORM_SRGB ? Gnf::FormatType::FormatTypeSRGB : Gnf::FormatType::FormatTypeUNorm;
		break;
	case DXGI_FORMAT_R8_UNORM:
	case DXGI_FORMAT_R8_SNORM:
	case DXGI_FORMAT_R8_UINT:
	case DXGI_FORMAT_R8_SINT:
		gnfImg.header.format = Gnf::Format::Format8;
		if(meta.format == DXGI_FORMAT_R8_UNORM)
			gnfImg.header.formatType = Gnf::FormatType::FormatTypeUNorm;
		else if (meta.format == DXGI_FORMAT_R8_SNORM)
			gnfImg.header.formatType = Gnf::FormatType::FormatTypeSNorm;
		else if (meta.format == DXGI_FORMAT_R8_UINT)
			gnfImg.header.formatType = Gnf::FormatType::FormatTypeUInt;
		else if (meta.format == DXGI_FORMAT_R8_SINT)
			gnfImg.header.formatType = Gnf::FormatType::FormatTypeSInt;
	break;
	default:
		throw std::exception("Format not implemented!");
		break;
	}
	
	if (meta.width < 1 || meta.height < 1 || meta.mipLevels < 1)
		throw std::exception("Invalid Resolution and/or Mip");

	gnfImg.header.width = meta.width - 1;
	gnfImg.header.height = meta.height - 1;
	gnfImg.header.mipmaps = meta.mipLevels - 1;
	switch (gnfImg.header.format)
	{
	case Gnf::Format::FormatBC1:
	case Gnf::Format::FormatBC2:
	case Gnf::Format::FormatBC3:
	case Gnf::Format::FormatBC7:
		gnfImg.header.destX = 4;
		gnfImg.header.destY = 5;
		gnfImg.header.destZ = 6;
		gnfImg.header.destW = 7;
		break;
	case Gnf::Format::FormatBC4:
		gnfImg.header.destX = 4;
		gnfImg.header.destY = 0;
		gnfImg.header.destZ = 0;
		gnfImg.header.destW = 1;
		break;
	case Gnf::Format::FormatBC5:
		gnfImg.header.destX = 4;
		gnfImg.header.destY = 5;
		gnfImg.header.destZ = 0;
		gnfImg.header.destW = 1;
		break;
	case Gnf::Format::FormatBC6:
		gnfImg.header.destX = 4;
		gnfImg.header.destY = 5;
		gnfImg.header.destZ = 6;
		gnfImg.header.destW = 1;
		gnfImg.header.unk7 = 0xB6D;
		gnfImg.header.unk9 = 0xA000;
		break;
	case Gnf::Format::Format8:
		gnfImg.header.destX = 4;
		gnfImg.header.destY = 0;
		gnfImg.header.destZ = 0;
		gnfImg.header.destW = 1;
		break;
	default:
		throw std::exception("Format not implemented!");
		break;
	}

	uint16_t bpp = 8;
	uint16_t pixbl = 4;
	switch (gnfImg.header.format)
	{
	case Gnf::Format::FormatBC1:
	case Gnf::Format::FormatBC4:
		bpp = 4;
		break;
	case Gnf::Format::FormatBC2:
	case Gnf::Format::FormatBC3:
	case Gnf::Format::FormatBC5:
	case Gnf::Format::FormatBC6:
	case Gnf::Format::FormatBC7:
		bpp = 8;
		break;
	case Gnf::Format::Format8:
		bpp = 8;
		pixbl = 1;
		break;
	default:
		throw std::exception("Format not implemented!");
		break;
	}
	gnfImg.header.pitch = BitHacks::RoundUpTo2(meta.width);
	gnfImg.header.pitch = pixbl == 1 ? std::max<size_t>(gnfImg.header.pitch, 16) : std::max<size_t>(gnfImg.header.pitch, 32);
	gnfImg.header.pitch--;

	gnfImg.header.dataSize = 0;
	for (uint32_t i = 0; i < meta.mipLevels; i++)
	{
		auto mipImg = (*image).GetImages()[i];
		size_t w = mipImg.width;
		size_t h = mipImg.height;

		if (w < 1 && h < 1)
			throw std::exception("Invalid Mip count");

		w = std::max<size_t>(w, pixbl);
		h = std::max<size_t>(h, pixbl);

		w = (w + (pixbl - 1)) & (~(pixbl - 1));
		h = (h + (pixbl - 1)) & (~(pixbl - 1));

		w = BitHacks::RoundUpTo2(w);
		h = BitHacks::RoundUpTo2(h);
		if (i == 0 && w != (gnfImg.header.pitch + 1))
			throw std::exception("Pitch doesn't match RoundUp2 Width");

		w = pixbl == 1 ? std::max<size_t>(w, 16) : std::max<size_t>(w, 32);
		h = pixbl == 1 ? std::max<size_t>(h, 16) : std::max<size_t>(h, 32);

		size_t size = w * h * bpp / 8;
		gnfImg.header.dataSize += uint32_t(size);
	}

	gnfImg.imageData = std::make_shared<byte[]>(gnfImg.header.dataSize);
	for (size_t k = 0; k < gnfImg.header.dataSize; k++)
	{
		gnfImg.imageData.get()[k] = byte(0);
	}

	size_t gnfoff = 0;
	for (size_t i = 0; i < meta.mipLevels; i++)
	{
		auto mipImg = (*image).GetImages()[i];
		size_t w = mipImg.width;
		size_t h = mipImg.height;

		if (w < 1 && h < 1)
			throw std::exception("Invalid Mip Count/Resolution");

		w = std::max<size_t>(w, pixbl);
		h = std::max<size_t>(h, pixbl);

		w = (w + (pixbl - 1)) & (~(pixbl - 1));
		h = (h + (pixbl - 1)) & (~(pixbl - 1));

		size_t tempw = BitHacks::RoundUpTo2(w);
		size_t temph = BitHacks::RoundUpTo2(h);

		if (i == 0 && tempw != (gnfImg.header.pitch + 1))
			throw std::exception("Pitch doesn't match RoundUp2 Width");

		tempw = pixbl == 1 ? std::max<size_t>(tempw, 16) : std::max<size_t>(tempw, 32);
		temph = pixbl == 1 ? std::max<size_t>(temph, 16) : std::max<size_t>(temph, 32);

		size_t size = tempw * temph * bpp / 8;
		byte* tempData = new byte[size];
		for (size_t k = 0; k < size; k++)
		{
			tempData[k] = byte(0);
		}
		size_t scanLineSize = w * pixbl * bpp / 8;
		size_t scanLineSizePadded = tempw * pixbl * bpp / 8;
		size_t off1 = 0;
		size_t off2 = 0;
		for (uint32_t j = 0; j < (h / pixbl); j++)
		{
			memcpy(tempData + off2, mipImg.pixels + off1, scanLineSize);
			off1 += scanLineSize;
			off2 += scanLineSizePadded;
		}

		Gnf::GnfImage::Swizzle(tempData, gnfImg.imageData.get() + gnfoff, tempw, temph, bpp, pixbl);
		gnfoff += size;
		delete[] tempData;
	}

	gnfImg.header.fileSize = gnfImg.header.dataSize + 0x100;
	gnfImg.WriteImage(gnfout);

	return gnfImg.header.fileSize;
}
```

`src/glTFSerializer.cpp`:

```cpp
#include "glTFSerializer.h"
#include "pch.h"

#include <GLTFSDK/GLTF.h>
#include <GLTFSDK/BufferBuilder.h>
#include <GLTFSDK/GLTFResourceWriter.h>
#include <GLTFSDK/GLBResourceWriter.h>
#include <GLTFSDK/IStreamWriter.h>
#include <GLTFSDK/Serialize.h>

#include <sstream>
#include <cassert>
#include <cstdlib>

using namespace Microsoft::glTF;

// The glTF SDK is decoupled from all file I/O by the IStreamWriter (and IStreamReader)
// interface(s) and the C++ stream-based I/O library. This allows the glTF SDK to be used in
// sandboxed environments, such as WebAssembly modules and UWP apps, where any file I/O code
// must be platform or use-case specific.
class StreamWriter : public IStreamWriter
{
public:
    StreamWriter(std::filesystem::path pathBase) : m_pathBase(std::move(pathBase))
    {
        assert(m_pathBase.has_root_path());
    }

    // Resolves the relative URIs of any external resources declared in the glTF manifest
    std::shared_ptr<std::ostream> GetOutputStream(const std::string& filename) const override
    {
        // In order to construct a valid stream:
        // 1. The filename argument will be encoded as UTF-8 so use filesystem::u8path to
        //    correctly construct a path instance.
        // 2. Generate an absolute path by concatenating m_pathBase with the specified filename
        //    path. The filesystem::operator/ uses the platform's preferred directory separator
        //    if appropriate.
        // 3. Always open the file stream in binary mode. The glTF SDK will handle any text
        //    encoding issues for us.
        auto streamPath = m_pathBase / std::filesystem::path(filename);
        auto stream = std::make_shared<std::ofstream>(streamPath, std::ios_base::binary);

        // Check if the stream has no errors and is ready for I/O operations
        if (!stream || !(*stream))
        {
            throw std::runtime_error("Unable to create a valid output stream for uri: " + filename);
        }

        return stream;
    }

private:
    std::filesystem::path m_pathBase;
};
auto AddMesh(Document& document, BufferBuilder& bufferBuilder, const RawMeshContainer& expMesh, bool Skinned)
{
    MeshPrimitive meshPrimitive;
    meshPrimitive.materialId = document.materials.Front().id;

    // Create a BufferView with a target of ELEMENT_ARRAY_BUFFER (as it will reference index
    // data) - it will be the 'current' BufferView that all the Accessors created by this
    // BufferBuilder will automatically reference
    if (expMesh.indices != nullptr)
    {
        bufferBuilder.AddBufferView(BufferViewTarget::ELEMENT_ARRAY_BUFFER);

        // Add an Accessor for the indices
        std::vector<uint16_t> indices;

        for (uint32_t i = 0; i < expMesh.IndCount; i += 3)
        {
            indices.push_back(expMesh.indices[i + 1]);
            indices.push_back(expMesh.indices[i]);
            indices.push_back(expMesh.indices[i + 2]);
        }
        // Copy the Accessor's id - subsequent calls to AddAccessor may invalidate the returned reference
        meshPrimitive.indicesAccessorId = bufferBuilder.AddAccessor(indices, { TYPE_SCALAR, COMPONENT_UNSIGNED_SHORT }).id;
    }
    
    if (expMesh.vertices != nullptr)
    {
        // Create a BufferView with target ARRAY_BUFFER (as it will reference vertex attribute data)
        bufferBuilder.AddBufferView(BufferViewTarget::ARRAY_BUFFER);
        // Add an Accessor for the positions
        std::vector<float> positions;
        for (uint32_t i = 0; i < expMesh.VertCount; i++)
        {
            positions.push_back(expMesh.vertices[i].X);
            positions.push_back(expMesh.vertices[i].Y);
            positions.push_back(expMesh.vertices[i].Z);
        }

        std::vector<float> minValues(3U, std::numeric_limits<float>::max());
        std::vector<float> maxValues(3U, std::numeric_limits<float>::lowest());

        const size_t positionCount = positions.size();

        // Accessor min/max properties must be set for vertex position data so calculate them here
        for (size_t i = 0U, j = 0U; i < positionCount; ++i, j = (i % 3U))
        {
            minValues[j] = std::min(positions[i], minValues[j]);
            maxValues[j] = std::max(positions[i], maxValues[j]);
        }

        meshPrimitive.attributes[ACCESSOR_POSITION] = bufferBuilder.AddAccessor(positions, { TYPE_VEC3, COMPONENT_FLOAT, false, std::move(minValues), std::move(maxValues) }).id;
    }

    if (expMesh.normals != nullptr)
    {
        // Create a BufferView with target ARRAY_BUFFER (as it will reference vertex attribute data)
        bufferBuilder.AddBufferView(BufferViewTarget::ARRAY_BUFFER);
        // Add an Accessor for the normals
        std::vector<float> normals;
        for (uint32_t i = 0; i < expMesh.VertCount; i++)
        {
            normals.push_back(expMesh.normals[i].X);
            normals.push_back(expMesh.normals[i].Y);
            normals.push_back(expMesh.normals[i].Z);
        }
        meshPrimitive.attributes[ACCESSOR_NORMAL] = bufferBuilder.AddAccessor(normals, { TYPE_VEC3, COMPONENT_FLOAT }).id;
    }

    if (expMesh.tangents != nullptr)
    {
        // Create a BufferView with target ARRAY_BUFFER (as it will reference vertex attribute data)
        bufferBuilder.AddBufferView(BufferViewTarget::ARRAY_BUFFER);
        // Add an Accessor for the tangents
        std::vector<float> tangents;
        for (uint32_t i = 0; i < expMesh.VertCount; i++)
        {
            tangents.push_back(expMesh.tangents[i].X);
            tangents.push_back(expMesh.tangents[i].Y);
            tangents.push_back(expMesh.tangents[i].Z);
            tangents.push_back(expMesh.tangents[i].W);
        }
        meshPrimitive.attributes[ACCESSOR_TANGENT] = bufferBuilder.AddAccessor(tangents, { TYPE_VEC4, COMPONENT_FLOAT }).id;
    }


    if (expMesh.txcoord0 != nullptr)
    {
        // Create a BufferView with target ARRAY_BUFFER (as it will reference vertex attribute data)
        bufferBuilder.AddBufferView(BufferViewTarget::ARRAY_BUFFER);
        std::vector<float> texcoords0;
        for (uint32_t i = 0; i < expMesh.VertCount; i++)
        {
            texcoords0.push_back(expMesh.txcoord0[i].X);
            texcoords0.push_back(expMesh.txcoord0[i].Y);
        }
        meshPrimitive.attributes[ACCESSOR_TEXCOORD_0] = bufferBuilder.AddAccessor(texcoords0, { TYPE_VEC2, COMPONENT_FLOAT }).id;
    }

    if (expMesh.txcoord1 != nullptr)
    {
        // Create a BufferView with target ARRAY_BUFFER (as it will reference vertex attribute data)
        bufferBuilder.AddBufferView(BufferViewTarget::ARRAY_BUFFER);
        std::vector<float> texcoords1;
        for (uint32_t i = 0; i < expMesh.VertCount; i++)
        {
            texcoords1.push_back(expMesh.txcoord1[i].X);
            texcoords1.push_back(expMesh.txcoord1[i].Y);
        }
        meshPrimitive.attributes[ACCESSOR_TEXCOORD_1] = bufferBuilder.AddAccessor(texcoords1, { TYPE_VEC2, COMPONENT_FLOAT }).id;
    }

    if (expMesh.txcoord2 != nullptr)
    {
        // Create a BufferView with target ARRAY_BUFFER (as it will reference vertex attribute data)
        bufferBuilder.AddBufferView(BufferViewTarget::ARRAY_BUFFER);
        std::vector<float> texcoords2;
        for (uint32_t i = 0; i < expMesh.VertCount; i++)
        {
            texcoords2.push_back(expMesh.txcoord2[i].X);
            texcoords2.push_back(expMesh.txcoord2[i].Y);
        }
        meshPrimitive.attributes["TEXCOORD_2"] = bufferBuilder.AddAccessor(texcoords2, { TYPE_VEC2, COMPONENT_FLOAT }).id;
    }

    if (expMesh.joints != nullptr)
    {
        // Create a BufferView with target ARRAY_BUFFER (as it will reference vertex attribute data)
        bufferBuilder.AddBufferView(BufferViewTarget::ARRAY_BUFFER);
        std::vector<uint16_t> joints0;
        for (uint32_t i = 0; i < expMesh.VertCount; i++)
        {
            joints0.push_back(expMesh.joints[i][0]);
            joints0.push_back(expMesh.joints[i][1]);
            joints0.push_back(expMesh.joints[i][2]);
            joints0.push_back(expMesh.joints[i][3]);
        }
        meshPrimitive.attributes[ACCESSOR_JOINTS_0] = bufferBuilder.AddAccessor(joints0, { TYPE_VEC4, COMPONENT_UNSIGNED_SHORT }).id;
    }
    if (expMesh.weights != nullptr)
    {
        // Create a BufferView with target ARRAY_BUFFER (as it will reference vertex attribute data)
        bufferBuilder.AddBufferView(BufferViewTarget::ARRAY_BUFFER);
        std::vector<float> weights0;
        for (uint32_t i = 0; i < expMesh.VertCount; i++)
        {
            weights0.push_back(expMesh.weights[i][0]);
            weights0.push_back(expMesh.weights[i][1]);
            weights0.push_back(expMesh.weights[i][2]);
            weights0.push_back(expMesh.weights[i][3]);
        }
        meshPrimitive.attributes[ACCESSOR_WEIGHTS_0] = bufferBuilder.AddAccessor(weights0, { TYPE_VEC4, COMPONENT_FLOAT }).id;
    }

    // Create a very simple glTF Document with the following hierarchy:
    //  Scene
    //     Node
    //       Mesh (Triangle)
    //         MeshPrimitive
    //           Material (Blue)
    // 
    // A Document can be constructed top-down or bottom up. However, if constructed top-down
    // then the IDs of child entities must be known in advance, which prevents using the glTF
    // SDK's automatic ID generation functionality.

    // Construct a Material
    /*
    Material material;
    material.metallicRoughness.baseColorFactor = Color4(0.0f, 0.0f, 1.0f, 1.0f);
    material.metallicRoughness.metallicFactor = 0.2f;
    material.metallicRoughness.roughnessFactor = 0.4f;
    material.doubleSided = true;

    // Add it to the Document and store the generated ID
    //auto materialId = document.materials.Append(std::move(material), AppendIdPolicy::GenerateOnEmpty).id;
    */

    // Construct a MeshPrimitive. Unlike most types in glTF, MeshPrimitives are direct children
    // of their parent Mesh entity rather than being children of the Document. This is why they
    // don't have an ID member.

    // Construct a Mesh and add the MeshPrimitive as a child
    Mesh mesh;
    mesh.name = expMesh.name;
    mesh.primitives.push_back(std::move(meshPrimitive));
    // Add it to the Document and store the generated ID
    auto meshId = document.meshes.Append(std::move(mesh), AppendIdPolicy::GenerateOnEmpty).id;

    // Construct a Node adding a reference to the Mesh
    Node node;
    node.meshId = meshId;
    node.name = expMesh.name;
    if(Skinned)
    node.skinId = document.skins.Front().id;
    // Add it to the Document and store the generated ID
    auto nodeId = document.nodes.Append(std::move(node), AppendIdPolicy::GenerateOnEmpty).id;

    return nodeId;
}
void WriteGLTF(const std::filesystem::path& path, const vector<RawMeshContainer>& expMeshes, const Rig& Armature)
{
    // Pass the absolute path, without the filename, to the stream writer
    auto streamWriter = std::make_unique<StreamWriter>(path.parent_path());

    std::filesystem::path pathFile = path.filename();
    std::filesystem::path pathFileExt = pathFile.extension();

    auto MakePathExt = [](const std::string& ext)
    {
        return "." + ext;
    };

    std::unique_ptr<ResourceWriter> resourceWriter;

    // If the file has a '.gltf' extension then create a GLTFResourceWriter
    if (pathFileExt == MakePathExt(GLTF_EXTENSION))
    {
        resourceWriter = std::make_unique<GLTFResourceWriter>(std::move(streamWriter));
    }

    // If the file has a '.glb' extension then create a GLBResourceWriter. This class derives
    // from GLTFResourceWriter and adds support for writing manifests to a GLB container's
    // JSON chunk and resource data to the binary chunk.
    if (pathFileExt == MakePathExt(GLB_EXTENSION))
    {
        resourceWriter = std::make_unique<GLBResourceWriter>(std::move(streamWriter));
    }

    if (!resourceWriter)
    {
        throw std::runtime_error("Command line argument path filename extension must be .gltf or .glb");
    }

    // The Document instance represents the glTF JSON manifest
    Document document;
    document.asset.copyright = "Santa Monica Studios";
    document.asset.generator = "God of War Tool - HitmanHimself";
    // Use the BufferBuilder helper class to simplify the process of
    // constructing valid glTF Buffer, BufferView and Accessor entities
    BufferBuilder bufferBuilder(std::move(resourceWriter));

    // Create all the resource data (e.g. triangle indices and
    // vertex positions) that will be written to the binary buffer
    const char* bufferId = nullptr;

    // Specify the 'special' GLB buffer ID. This informs the GLBResourceWriter that it should use
    // the GLB container's binary chunk (usually the desired buffer location when creating GLBs)
    if (dynamic_cast<const GLBResourceWriter*>(&bufferBuilder.GetResourceWriter()))
    {
        bufferId = GLB_BUFFER_ID;
    }

    // Create a Buffer - it will be the 'current' Buffer that all the BufferViews
    // created by this BufferBuilder will automatically reference
    bufferBuilder.AddBuffer(bufferId);

    Material material;
    material.name = "Default";
    material.metallicRoughness.baseColorFactor = Color4(1.0f, 1.0f, 1.0f, 1.0f);
    material.metallicRoughness.metallicFactor = 0.0f;
    material.metallicRoughness.roughnessFactor = 0.5f;
    material.doubleSided = true;
    document.materials.Append(std::move(material), AppendIdPolicy::GenerateOnEmpty);

    // Construct a Scene
    Scene scene;
    scene.name = "Scene";
    if (Armature.boneCount > 0u)
    {
        std::vector<Node> nodes;
        std::vector<string> nodeIds;
        for (uint16_t i = 0; i < Armature.boneCount; i++)
        {
            Node node;
            node.name = Armature.boneNames[i];
            node.matrix = Microsoft::glTF::Matrix4();
            for (size_t r = 0; r < 4; r++)
            {
                for (size_t c = 0; c < 4; c++)
                {
                    node.matrix.values[r * 4 + c] = Armature.matrix[i][r][c];
                }
            }
            nodes.push_back(node);
            if (Armature.boneParents[i] > -1)
                nodes[Armature.boneParents[i]].children.push_back(std::to_string(i));
        }
        for (uint16_t i = 0; i < Armature.boneCount; i++)
        {
            nodeIds.push_back(document.nodes.Append(std::move(nodes[i]), AppendIdPolicy::GenerateOnEmpty).id);
        }
        scene.nodes.push_back(nodeIds[0]);
        Skin skin;
        skin.jointIds = nodeIds;

        // Create a BufferView with target ARRAY_BUFFER (as it will reference IBM'sdata)
        bufferBuilder.AddBufferView();

        std::vector<float> IBMs;
        for (uint16_t i = 0; i < Armature.boneCount; i++)
        {

            for (size_t r = 0; r < 4; r++)
            {
                for (size_t c = 0; c < 4; c++)
                {
                    IBMs.push_back(Armature.IBMs[i][r][c]);
                }
            }
        }

        skin.inverseBindMatricesAccessorId = bufferBuilder.AddAccessor(IBMs, { TYPE_MAT4, COMPONENT_FLOAT }).id;

        document.skins.Append(std::move(skin), AppendIdPolicy::GenerateOnEmpty);
        for (size_t i = 0; i < expMeshes.size(); i++)
        {
            scene.nodes.push_back(AddMesh(document, bufferBuilder, expMeshes[i],true));
        }
    }
    else
    {
        for (int i = 0; i < expMeshes.size(); i++)
        {
            scene.nodes.push_back(AddMesh(document, bufferBuilder, expMeshes[i],false));
        }
    }
    // Add it to the Document, using a utility method that also sets the Scene as the Document's default
    document.SetDefaultScene(std::move(scene), AppendIdPolicy::GenerateOnEmpty);

    // Add all of the Buffers, BufferViews and Accessors that were created using BufferBuilder to
    // the Document. Note that after this point, no further calls should be made to BufferBuilder
    bufferBuilder.Output(document);

    std::string manifest;

    try
    {
        // Serialize the glTF Document into a JSON manifest
        manifest = Serialize(document, SerializeFlags::Pretty);
    }
    catch (const GLTFException& ex)
    {
        std::stringstream ss;

        ss << "Microsoft::glTF::Serialize failed: ";
        ss << ex.what();

        throw std::runtime_error(ss.str());
    }
    auto& gltfResourceWriter = bufferBuilder.GetResourceWriter();

    if (auto glbResourceWriter = dynamic_cast<GLBResourceWriter*>(&gltfResourceWriter))
    {
        glbResourceWriter->Flush(manifest, pathFile.string()); // A GLB container isn't created until the GLBResourceWriter::Flush member function is called
    }
    else
    {
        gltfResourceWriter.WriteExternal(pathFile.string(), manifest); // Binary resources have already been written, just need to write the manifest
    }
}
```

`src/krak.cpp`:

```cpp
#include "pch.h"
#include "krak.h"

OodLZ_CompressFunc* OodLZ_Compress;
OodLZ_DecompressFunc* OodLZ_Decompress;

void LoadLib() {

#if defined(_M_X64)
#define LIBNAME "oo2core_7_win64.dll"
	char COMPFUNCNAME[] = "XXdleLZ_Compress";
	char DECFUNCNAME[] = "XXdleLZ_Decompress";
	COMPFUNCNAME[0] = DECFUNCNAME[0] = 'O';
	COMPFUNCNAME[1] = DECFUNCNAME[1] = 'o';
#else
#define LIBNAME "oo2core_7_win32.dll"
	char COMPFUNCNAME[] = "_XXdleLZ_Compress@40";
	char DECFUNCNAME[] = "_XXdleLZ_Decompress@56";
	COMPFUNCNAME[1] = DECFUNCNAME[1] = 'O';
	COMPFUNCNAME[2] = DECFUNCNAME[2] = 'o';
#endif
	HINSTANCE mod = LoadLibraryA(LIBNAME);
	OodLZ_Compress = (OodLZ_CompressFunc*)GetProcAddress(mod, COMPFUNCNAME);
	OodLZ_Decompress = (OodLZ_DecompressFunc*)GetProcAddress(mod, DECFUNCNAME);
	if (!OodLZ_Compress || !OodLZ_Decompress)
		cout << ("error loading", LIBNAME);
}
```

`src/utils.cpp`:

```cpp
#include "pch.h"
#include "utils.h"

namespace Utils
{
	std::string FileDialogs::OpenFile(const char* filter, const char* title, HWND owner)
	{
		OPENFILENAMEA ofn;
		CHAR szFile[260] = { 0 };
		ZeroMemory(&ofn, sizeof(OPENFILENAME));
		ofn.lStructSize = sizeof(OPENFILENAME);
		ofn.hwndOwner = owner;
		ofn.lpstrTitle = title;
		ofn.lpstrFilter = filter;
		ofn.lpstrFile = szFile;
		ofn.nMaxFile = sizeof(szFile);
		ofn.nFilterIndex = 1;
		ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;
		if (GetOpenFileNameA(&ofn) == TRUE)
		{
			return ofn.lpstrFile;
		}
		return std::string();
	}
	void Logger::Error(const char* msg)
	{
		auto hndl = GetStdHandle(STD_OUTPUT_HANDLE);
		CONSOLE_SCREEN_BUFFER_INFO csbi;
		GetConsoleScreenBufferInfo(hndl, &csbi);
		SetConsoleTextAttribute(hndl, 4);
		cout << msg;
		SetConsoleTextAttribute(hndl, csbi.wAttributes);
	}
	void Logger::Success(const char* msg)
	{
		auto hndl = GetStdHandle(STD_OUTPUT_HANDLE);
		CONSOLE_SCREEN_BUFFER_INFO csbi;
		GetConsoleScreenBufferInfo(hndl, &csbi);
		SetConsoleTextAttribute(hndl, 2);
		cout << msg;
		SetConsoleTextAttribute(hndl, csbi.wAttributes);
	}
	void Logger::Warning(const char* msg)
	{
		auto hndl = GetStdHandle(STD_OUTPUT_HANDLE);
		CONSOLE_SCREEN_BUFFER_INFO csbi;
		GetConsoleScreenBufferInfo(hndl, &csbi);
		SetConsoleTextAttribute(hndl, 14);
		cout << msg;
		SetConsoleTextAttribute(hndl, csbi.wAttributes);
	}
}
```