Project Path: arc_PAGalaxyLab_ghidra_scripts_cgopnabe

Source Tree:

```txt
arc_PAGalaxyLab_ghidra_scripts_cgopnabe
├── AnalyzeOCMsgSend.py
├── DexFile_Parameter_Trace.py
├── LICENSE
├── README.md
├── README.zh-cn.md
├── __init__.py
├── docs
│   ├── images
│   │   ├── DexFile_Parameter_Trace_Logd.png
│   │   ├── DexFile_Parameter_Trace_Script_Param.png
│   │   ├── DexFile_Parameter_trace_Script_Output.png
│   │   ├── analyze_oc_msg_send_pic.png
│   │   ├── ghidra-ollvm-deobf.png
│   │   ├── ghidra-ollvm-obf.png
│   │   ├── trace_function_call_parm_value_pic_1.jpg
│   │   ├── wr886nv7_rename_function_with_error_print_1.jpg
│   │   ├── wr886nv7_rename_function_with_error_print_2.jpg
│   │   ├── wr886nv7_rename_function_with_error_print_3.jpg
│   │   ├── wr886nv7_rename_function_with_error_print_4.jpg
│   │   └── wr886nv7_rename_function_with_error_print_5.jpg
│   ├── wr886nv7_rename_function_with_error_print.md
│   └── wr886nv7_rename_function_with_error_print.zh-cn.md
├── galaxy_utility
│   ├── __init__.py
│   ├── common.py
│   └── function_analyzer.py
├── ollvm_deobf_fla.py
├── trace_function_call_parm_value.py
└── wr886nv7_rename_function_with_error_print.py

```

`AnalyzeOCMsgSend.py`:

```py
# -*- coding: utf-8 -*-
import ghidra.app.util.bin.format.objectiveC.ObjectiveC1_Constants as OC_CONST
import logging
import re

OBJC_METHNAME = u'__objc_methname'
OBJC_CLASSNAME = u'__objc_classname'
OBJC_CLASSREFS = u'__objc_classrefs'
OBJC_DATA = u'__objc_data'
SYMBOLTYPE_LABEL = u'Label'
SYMBOLTYPE_FUNCTION = u'Function'
REFERENCETYPE_UNCONDITIONAL_CALL = u'UNCONDITIONAL_CALL'
OBJCCLASSPREFIX_META = u'_OBJC_METACLASS_$_'


methName_Dict = {}
className_Dict = {}
symbol_Dict = {}

functionList = []
referenceList = []

# debug = True
debug = False
# Init Default Logger
logger = logging.getLogger('Default_logger')
logger.setLevel(logging.INFO)
consolehandler = logging.StreamHandler()
console_format = logging.Formatter('[%(levelname)-8s][%(module)s.%(funcName)s] %(message)s')
consolehandler.setFormatter(console_format)
logger.addHandler(consolehandler)

if debug:
	logger.setLevel(logging.DEBUG)

AdditionalCount = 0

class Function(object):
	"""docstring for Function"""
	def __init__(self, address, name):
		super(Function, self).__init__()
		self.address = address
		self.name = name

class Reference(object):
	"""docstring for Reference"""
	def __init__(self, callingAddr, fromAddr, toAddr):
		super(Reference, self).__init__()
		self.callingAddr = callingAddr
		self.fromAddr = fromAddr
		self.toAddr = toAddr
		
class ObjcMathName(object):
	"""docstring for ObjcMathName"""
	def __init__(self, cp, address, name):
		super(ObjcMathName, self).__init__()
		self.address = address
		self.name = name
		self.refTo = []
		self.refIter = cp.getListing().getDataAt(address).getReferenceIteratorTo()
		while self.refIter.hasNext():
			self.refTo.append(self.refIter.next())

def getMethName(cp, memBlk):
	for seg in memBlk:
		if seg.name == OBJC_METHNAME:
			global methName_Dict
			codeUnits = cp.getListing().getCodeUnits(seg.start,True)
			while codeUnits.hasNext():
				cu = codeUnits.next()
				if cu and cu.address < seg.end:
					methName = ObjcMathName(cp,cu.address,cu.value)
					methName_Dict[cu.address] = methName
				else:
					break
			break

class ObjcClassName(object):
	"""docstring for ObjcClassName"""
	def __init__(self, cp, address, name):
		super(ObjcClassName, self).__init__()
		self.address = address
		self.name = name
		self.refTo = []
		self.refIter = cp.getListing().getDataAt(address).getReferenceIteratorTo()
		while self.refIter.hasNext():
			self.refTo.append(self.refIter.next())
		
def getClassName(cp, memBlk):
	for seg in memBlk:
		if seg.name == OBJC_CLASSNAME:
			global className_Dict
			codeUnits = cp.getListing().getCodeUnits(seg.start,True)
			while codeUnits.hasNext():
				cu = codeUnits.next()
				if cu and cu.address < seg.end:
					if cu.value == u'\x01':
						continue
					className = ObjcClassName(cp,cu.address,cu.value)
					className_Dict[cu.address] = className
				else:
					break
			break

class Symbol(object):
	"""docstring for Symbol"""
	def __init__(self, sID, address, name, stype, parent, refs):
		super(Symbol, self).__init__()
		self.sID = sID
		self.address = address
		self.name = name
		self.stype = stype
		self.parent = parent
		self.refs = refs

def getFuncAddrByAddr(cp,callingAddress):
	entryAddr = None
	if cp.getListing().getFunctionContaining(callingAddress):
		entryAddr = cp.getListing().getFunctionContaining(callingAddress).entryPoint
	return entryAddr

def getSymbolTable(cp):
	symbolTable = cp.getSymbolTable()
	si = symbolTable.getSymbolIterator()
	global symbol_Dict
	global functionList
	global referenceList
	labelDict = {}
	while si.hasNext():
		s = si.next()
		symbol = Symbol(s.getID(), s.getAddress(), s.getName(), s.getSymbolType(), s.getParentSymbol(), s.getReferences())
		symbol_Dict[symbol.sID] = symbol
		if symbol.stype.toString() == SYMBOLTYPE_LABEL:
			labelDict[symbol.address.toString()] = symbol.name
		elif symbol.stype.toString() == SYMBOLTYPE_FUNCTION:
			tmpFunctionName = symbol.name
			if labelDict.has_key(symbol.address.toString()) and labelDict[symbol.address.toString()] != u'': # Bingo in Label
				funcLabel = labelDict[symbol.address.toString()]
				del labelDict[symbol.address.toString()]
				if funcLabel.find(symbol.name) != -1 and funcLabel.find(symbol.parent.name) != -1: # Got Class name and Method name
					if funcLabel.startswith(u'+') or funcLabel.startswith(u'-'): # Got OC Function Type (Class Func or Instance Func)
						tmpFunctionName = funcLabel[:1]+u'['+symbol.parent.name+u' '+symbol.name+u']'
			func = Function(symbol.address.toString(),tmpFunctionName)
			functionList.append(func)
			for ref in symbol.refs:
				if ref.referenceType.toString() == REFERENCETYPE_UNCONDITIONAL_CALL:
					fromFuncAddr = getFuncAddrByAddr(cp, ref.fromAddress)
					if fromFuncAddr:
						logger.debug("From: {}; At: {}; To: {}; Type:{}".format(fromFuncAddr, ref.fromAddress, ref.toAddress, ref.referenceType))
						reference = Reference(ref.fromAddress, fromFuncAddr, ref.toAddress)
						referenceList.append(reference)

# Helper to get function info by iterating instructions step by step
class CurrentState(object):
	def __init__(self, program):
		self.program = program
		self.symbolTable = program.getSymbolTable()
		self.currentClassName = u''
		self.currentMethodName = u''
		# flag for class and method
		self.classFlag = False
		self.methodFlag = False

	def isValid(self):
		return self.currentMethodName != u'' and self.currentClassName != u''

	def reset(self):
		self.currentClassName = u''
		self.currentMethodName = u''

		self.classFlag = False
		self.methodFlag = False

	def toString(self):
		return "[" + self.currentClassName + " " + self.currentMethodName + "]"

def isCallingObjcMsgSend(instruction):
	if instruction.getNumOperands() != 1:
		return False
	reference = instruction.getPrimaryReference(0)
	if reference == None:
		return False
	if not reference.getReferenceType().isCall() and not reference.getReferenceType().isJump():
		return False
	symbolTable = instruction.getProgram().getSymbolTable()
	symbol = symbolTable.getPrimarySymbol(reference.getToAddress())
	return isObjcNameMatch(symbol)

def isObjcNameMatch(symbol):
	name = symbol.getName()
	return name.startswith(OC_CONST.OBJC_MSG_SEND) or name == OC_CONST.READ_UNIX2003 or name.startswith("thunk" + OC_CONST.OBJC_MSG_SEND)

def markupInstruction(instruction, state):
	fromAddress = instruction.getMinAddress()
	function = state.program.getListing().getFunctionContaining(fromAddress)
	if function == None:
		return
	state.reset()
	global logger
	insIter = state.program.getListing().getInstructions(fromAddress, False)
	while insIter.hasNext():
		logger.debug("--Go Up--")
		instructionBefore = insIter.next()
		if not function.getBody().contains(instructionBefore.getMinAddress()):
			break # don't look outside of the function
		if not isValidInstruction(instructionBefore):
			continue
		opRefs = instructionBefore.getOperandReferences(1)
		logger.debug("=={} instruction: {}".format(instructionBefore.getMinAddress(),instructionBefore))
		logger.debug("==opRefs: {}".format(opRefs)) 
		if len(opRefs) != 1:
			continue
		toAddress = opRefs[0].getToAddress()
		block = state.program.getMemory().getBlock(toAddress)
		if block == None:
			continue
		space = currentProgram.getGlobalNamespace()
		pullNameThrough(state, toAddress)

		if state.isValid():
			break



'''
 * Objective-C class and method names are stored in the
 * "__cstring" memory block. The strings are referenced
 * by either the "class" block or the "message" block.
 * The references are through n-levels of pointer indirection
 * based on the specific target (x86 vs ppc vs arm).
 * This method will pull the string through the pointer indirection
 * and set the appropriate value in the current state.
'''
def pullNameThrough(state, address):
	block = state.program.getMemory().getBlock(address)
	if block == None:
		return None
	logger.debug("block name: {}".format(block.getName))
	if block.getName() == OBJC_METHNAME:
		state.methodFlag = True
		return state.program.getListing().getDefinedDataAt(address).getValue()
	elif block.getName() == OBJC_DATA:
		classRwPointerAddress = state.program.getListing().getDefinedDataAt(address).getComponent(4).getValue()
		classRwData = state.program.getListing().getDefinedDataAt(classRwPointerAddress)
		classNamePointer = classRwData.getComponent(3).getValue()
		className = state.program.getListing().getDefinedDataAt(classNamePointer).getValue()
		state.classFlag = True
		if className:
			return className
	elif block.getName() == OBJC_CLASSREFS:
		pass
	data = state.program.getListing().getDataAt(address)
	if data == None:
		data = state.program.getListing().getDataContaining(address)
		if data == None:
			return None
		data = data.getComponentAt(int(address.subtract(data.getAddress())))
		if data == None:
			return None
	references = data.getValueReferences()
	if len(references) == 0:
		return None
	if address == references[0].getToAddress():
		return None # self reference
	name = pullNameThrough(state, references[0].getToAddress())
	if state.classFlag:
		if state.currentClassName == u'':
			logger.debug("class found: {}".format(name))
			state.currentClassName = name
	if state.methodFlag:
		if state.currentMethodName == u'':
			logger.debug("message found: {}".format(name))
			state.currentMethodName = name
	return name

def isMessageBlock(block):
	return block.getName() == OBJC_METHNAME

def isClassBlock(block):
	return block.getName() == OC_CONST.OBJC_SECTION_CLASS_REFS or block.getName() == OC_CONST.OBJC_SECTION_CLASS

def isValidInstruction(instruction):
	if instruction.getNumOperands() != 2:
		return False
	isMOV = instruction.getMnemonicString() == "MOV" # intel
	isLWZ = instruction.getMnemonicString() == "lwz" # powerpc
	isLDR = instruction.getMnemonicString() == "ldr" # arm
	return isMOV or isLWZ or isLDR


def analyzeFunction(cp, function):
	insIter = cp.getListing().getInstructions(function.getBody(),True)
	state = CurrentState(cp)
	while insIter.hasNext():
		curIns = insIter.next()
		if isCallingObjcMsgSend(curIns):
			logger.debug('==========Calling MsgSend==========')
			logger.debug("===={}: {} // {}".format(curIns.getAddress(),curIns,curIns.getComment(0)))
			hitFlag = False
			for ref in referenceList:
				if ref.callingAddr == curIns.getAddress():
					hitFlag = True
					logger.debug("hit: {}, {}, {}".format(ref.fromAddr, ref.toAddr, ref.callingAddr))
					break

			global AdditionalCount
			comment = curIns.getComment(0)
			funcClass = u''
			funcMethod = u''
			secondMethod = u''
			if comment and comment.startswith(u'[') and comment.endswith(u']') and len(comment.split(u' ')) > 1:
				funcClass = comment.split(u' ')[0][1:]
				funcMethod = comment.split(u' ')[1][:-1]
				if funcClass.startswith(OBJCCLASSPREFIX_META):
					funcClass = funcClass[18:]
				funcClass = funcClass.replace(u'undefined', u'')
				funcMethod = funcMethod.replace(u'undefined', u'')
			if funcMethod == u'':
				markupInstruction(curIns, state)
				if state.isValid():
					funcClass = state.currentClassName
					funcMethod = state.currentMethodName
				else:
					continue
			if funcMethod.startswith(u'performSelector'):
				searchObj = re.search(u'(performSelector[a-zA-Z]*:)"([a-zA-Z0-9_]*)"',funcMethod)
				if searchObj:
					secondMethod = searchObj.group(2)
					logger.debug("Second Method: {}".format(secondMethod))
					tmpFunc = u'['+funcClass+u' '+secondMethod+u']'
					for func in functionList:
						if func.name.startswith(u'+') or func.name.startswith(u'-'):
							if func.name[1:] == tmpFunc:
								logger.debug("Second Method Found in functionList: {}".format(func.name))
								logger.debug("{}, {}, {}".format(function.entryPoint, curIns.address, func.address))
								ref = Reference(curIns.address, function.entryPoint, func.address)
								referenceList.append(ref)
								AdditionalCount += 1
								foundFlag = True
								break
					funcMethod = searchObj.group(1)
			searchObj = re.search(u'([a-zA-Z0-9]*:)"', funcMethod)
			if searchObj:
				funcMethod = searchObj.group(1)
			logger.debug("Class: {}; Method: {}".format(funcClass, funcMethod))
			tmpFunc = u''
			if funcClass and funcMethod:
				tmpFunc = u'['+funcClass+u' '+funcMethod+u']'
			elif funcClass == u'' and funcMethod:
				tmpFunc = funcMethod
			foundFlag = False
			for func in functionList:
				if func.name.startswith(u'+') or func.name.startswith(u'-'):
					if func.name[1:] == tmpFunc:
						logger.debug("Found in functionLsit: {}".format(func.name))
						ref = Reference(curIns.address, function.entryPoint, func.address)
						referenceList.append(ref)
						AdditionalCount += 1
						foundFlag = True
						break
				else:
					if func.name == tmpFunc:
						logger.debug("Found in functionLsit: {}".format(func.name))
						ref = Reference(curIns.address, function.entryPoint, func.address)
						referenceList.append(ref)
						AdditionalCount += 1
						foundFlag = True
						break
			if foundFlag:
				continue
			for item in methName_Dict:
				if methName_Dict[item].name == funcMethod:
					logger.debug("Found in __objc_methname: {}: {}".format(methName_Dict[item].address, funcMethod))
					ref = Reference(curIns.address, function.entryPoint, methName_Dict[item].address)
					referenceList.append(ref)
					
					AdditionalCount += 1
					foundFlag = True
					break


def analyzeInstructions(cp):
	funcIter = cp.getListing().getFunctions(True)
	while funcIter.hasNext():
		f = funcIter.next()
		fName = f.getName()
		entry = f.getEntryPoint()
		if entry:
			logger.debug("{}: {}".format(entry, fName))
			analyzeFunction(cp, f)
	print("Additional Methods Found: {}".format(AdditionalCount))

def analyzeFuncsAndRefs():
	global methName_Dict
	global className_Dict
	global symbol_Dict
	global functionList
	global referenceList

	cp = currentProgram
	memBlk = cp.memory.blocks
	if memBlk:
		getMethName(cp, memBlk)
		if debug and methName_Dict:
			print("Method Name")
			for item in methName_Dict:
				meth = methName_Dict[item]
				logger.debug("{}: {}, Ref:{}".format(item,meth.name,meth.refTo))

	if memBlk:
		getClassName(cp, memBlk)
		if debug and className_Dict:
			print("Class Name")
			for item in className_Dict:
				_class = className_Dict[item]
				logger.debug("{}: {}, Ref:{}".format(item,_class.name,_class.refTo))

	getSymbolTable(cp)
	if debug and symbol_Dict:
		print("Symbol Table")
		for item in sorted(symbol_Dict):
			symbol = symbol_Dict[item]
			logger.debug("{}: {}\t{}\t{}\t{}\t{}".format(symbol.sID, symbol.address, symbol.name, symbol.stype, symbol.parent.name, symbol.refs))

	for item in methName_Dict:
		func = Function(methName_Dict[item].address, methName_Dict[item].name)
		functionList.append(func)

	analyzeInstructions(cp)

	print("Function List:")
	for func in functionList:
		print("{}: {}".format(func.address, func.name))

	print("Reference List:")
	for ref in referenceList:
		print("From: {}, To: {}, Address: {}".format(ref.fromAddr, ref.toAddr, ref.callingAddr))

	return functionList, referenceList

if __name__ == '__main__':
	funcList, refList = analyzeFuncsAndRefs()
	
	print("\naddress,name")
	for func in funcList:
		print("{},{}".format(func.address, func.name))

	print("\nfrom,to,address")
	for ref in refList:
		print("{},{},{}".format(ref.fromAddr, ref.toAddr, ref.callingAddr))

```

`DexFile_Parameter_Trace.py`:

```py
#Trace parameters of a function
#@author zhuangshao
#@category Dex
#@keybinding 
#@menupath 
#@toolbar 

from ghidra.app.util.importer import MessageLog
from ghidra.file.formats.android.dex.analyzer import DexHeaderFormatAnalyzer
from ghidra.file.formats.android.dex.analyzer import DexAnalysisState
from ghidra.file.formats.android.dex.util import DexUtil
from ghidra.app.decompiler import DecompInterface, DecompileOptions, DecompileResults
from ghidra.program.model.pcode import HighParam, PcodeOp, PcodeOpAST
from ghidra.program.model.symbol import SymbolType

import logging
import struct


# Init Default Logger
logger = logging.getLogger('Default_logger')
logger.setLevel(logging.DEBUG)
consolehandler = logging.StreamHandler()
console_format = logging.Formatter('[%(levelname)-8s][%(module)s.%(funcName)s] %(message)s')
consolehandler.setFormatter(console_format)
logger.addHandler(consolehandler)


# Auxiliary
Check_Funcs = ['']
External_Symbols = {}
Target_Funcs = ['logd', 'url']
Examined_Funcs = {}
dexAnalysisState = DexAnalysisState.getState(currentProgram)
DexHeader = dexAnalysisState.getHeader()
def getString(string_idx):
    StringItem = DexHeader.getStrings().get(string_idx)
    return StringItem.getStringDataItem().getString()
def getType(type_idx):
    TypeItem = DexHeader.getTypes().get(type_idx)
    descriptor_idx = TypeItem.getDescriptorIndex()
    return getString(descriptor_idx)    
def getField(field_idx):
    FieldItem = DexHeader.getFields().get(field_idx)
    name_idx = FieldItem.getNameIndex()
    field_name = getString(name_idx)
    class_idx = FieldItem.getClassIndex()
    class_name = getType(class_idx)
    return class_name + "." + field_name
def getMethod(method_idx):
    MethodItem = DexHeader.getMethods().get(method_idx)
    name_idx = MethodItem.getNameIndex()
    func_name = getString(name_idx)
    class_idx = MethodItem.getClassIndex()
    class_name = getType(class_idx)
    return class_name + "->" + func_name
def getExternalSymbols():
    ExSymbols = currentProgram.getSymbolTable().getExternalSymbols()
    for ExSymbol in ExSymbols:
        External_Symbols[ExSymbol.getName()] = ExSymbol
def checkFunctionList():
    for Check_Func in Check_Funcs:
        if Check_Func in External_Symbols:
            print("Cun Zai: {}".format(Check_Func))
            Check_Func_Symbol = External_Symbols[Check_Func]
            Check_Func_Symbol_External_Addr = Check_Func_Symbol.getReferences()[0].getFromAddress()
            Check_Func_Symbol_Refs = getReferencesTo(Check_Func_Symbol_External_Addr)
            for Check_Func_Symbol_Ref in Check_Func_Symbol_Refs:
                if Check_Func_Symbol_Refs.getReferenceType().isCall():
                    print("Shi Yong: {}".format(Check_Func))
                    break


# Main Functions
class FunctionAnalyzer(object):

    def __init__(self, function, logger=logger):
        self.function = function
        self.logger = logger
        self.prepare()
 
    def prepare(self):
        Decompiler = DecompInterface()
        Decompiler.openProgram(currentProgram)
        Decompiled_Func = Decompiler.decompileFunction(self.function, 30, getMonitor())
        self.highfunction = Decompiled_Func.getHighFunction()
        #print("High Function information: {}".format(self.highfunction.getFunctionPrototype()))
        
    def start_analyse(self, address, param_index):
        self.logger.debug("Reference address is: {}".format(address))
        PcodeOps = self.highfunction.getPcodeOps(address)
        while PcodeOps.hasNext():
            PcodeOpAST = PcodeOps.next()
            print("*****\n{}\n*****".format(PcodeOpAST))
            Opcode = PcodeOpAST.getOpcode()
            if Opcode == PcodeOp.CALL or Opcode == PcodeOp.CALLIND:
                #print("Found CALL/CALLIND at 0x{}".format(PcodeOpAST.getInput(0).getPCAddress()))
                Target_Param_Varnode = PcodeOpAST.getInput(param_index)
                #print("Target Param Varnode: {}".format(Target_Param_Varnode))
                Target_Param_Varnode_Analyzer = VarnodeAnalyzer()
                Target_Param_Varnode_Analyzer.analyse_node(Target_Param_Varnode, PcodeOpAST)
       

class VarnodeAnalyzer(object):

    def __init__(self, logger=logger):
        self.logger = logger
        
    def analyse_node(self, varnode, pcode):
        logger.debug("Varnode: {}".format(varnode))
        Varnode_Type = varnode.isInput()
        if Varnode_Type == 1:
            Target_Param_Varnode_Index = (varnode.getOffset() - 256) / 4 + 1
            Current_Func = getFunctionContaining(pcode.getSeqnum().getTarget())
            References = getReferencesTo(Current_Func.getEntryPoint())
            for Reference in References:
                Reference_Addr = Reference.getFromAddress()
                if Reference_Addr.toString() != "Entry Point" and Reference.getReferenceType().isCall():
                    Reference_Func = getFunctionContaining(Reference_Addr)
                    logger.debug("Reference function is: {}".format(Reference_Func))
                    if Reference_Func not in Examined_Funcs:
                        Examined_Funcs[Reference_Func] = FunctionAnalyzer(Reference_Func)
                    Reference_Func_Analyzer = Examined_Funcs[Reference_Func]
                    Reference_Func_Analyzer.start_analyse(Reference_Addr, Target_Param_Varnode_Index)      
        else:
            Pcode_Def = varnode.getDef()
            logger.debug("Pcode Define: {}".format(Pcode_Def))
            self.analyse_pcode(Pcode_Def)

    def analyse_pcode(self, pcode):
        Opcode = pcode.getOpcode()
        if Opcode == PcodeOp.CAST:
            Target_Varnode = pcode.getInput(0)
            self.analyse_node(Target_Varnode, pcode)
        if Opcode == PcodeOp.COPY:
            Target_Varnode = pcode.getInput(0)
            self.analyse_node(Target_Varnode, pcode)
        elif Opcode == PcodeOp.CALL or Opcode == PcodeOp.CALLIND:
            Method_Varnode = pcode.getInput(0)
            Pcode_Def_Method_Varnode = Method_Varnode.getDef()
            Method_Idx = Pcode_Def_Method_Varnode.getInput(1).getOffset()
            Method_Name = getMethod(Method_Idx)
            print("Method: {}".format(Method_Name))
            
            Pcode_Seqnum = pcode.getSeqnum()
            Pcode_Addr = Pcode_Seqnum.getTarget()
            Pcode_Ins = getInstructionAt(Pcode_Addr)
            Target_Method_Addrs = Pcode_Ins.getFlows()
            Target_Method_Addr = Target_Method_Addrs[0]
            Target_Method_Symbol_Type = getSymbolAt(Target_Method_Addr).getSymbolType()
            if Target_Method_Symbol_Type == SymbolType.FUNCTION:
                print("Pcode-Op CALL/CALLIND target method is local function!")
                for i in range(2, len(pcode.getInputs())):
                    Param_Target_Varnode = pcode.getInput(i)
                    self.analyse_node(Param_Target_Varnode, pcode)
                Target_Func = getFunctionAt(Target_Method_Addr)
                if Target_Func not in Examined_Funcs:
                    Examined_Funcs[Target_Func] = FunctionAnalyzer(Target_Func)
                Target_Func_Analyzer = Examined_Funcs[Target_Func]
                Target_Func_Instruction = getInstructionAt(Target_Method_Addr)
                Target_Func_Addresses = Target_Func.getBody()
                while Target_Func_Addresses.contains(Target_Func_Instruction.getAddress()):
                    PcodeOps = Target_Func_Analyzer.highfunction.getPcodeOps(Target_Func_Instruction.getAddress())
                    while PcodeOps.hasNext():
                        PcodeOpAST = PcodeOps.next()
                        print("*****\n{}\n*****".format(PcodeOpAST))
                        if PcodeOpAST.getOpcode() == PcodeOp.RETURN:
                            Ret_Varnode = PcodeOpAST.getInput(1)
                            self.analyse_node(Ret_Varnode, PcodeOpAST)
                    Target_Func_Instruction = Target_Func_Instruction.getNext()
            elif Target_Method_Symbol_Type == SymbolType.LABEL:
                print("Pcode-Op CALL/CALLIND target method is external function!")
                if len(pcode.getInputs()) > 1:
                    Fun_Target_Varnode = pcode.getInput(1)
                    self.analyse_node(Fun_Target_Varnode, pcode)
                    #for i in range(2, len(pcode.getInputs())):
                        #Param_Target_Varnode = pcode.getInput(i)
                        #self.analyse_node(Param_Target_Varnode, pcode)  
            else:
                print("Pcode-Op CALL/CALLIND target method type! {}".format(Target_Method_Symbol_Type))
        elif Opcode == PcodeOp.CPOOLREF:
            Pcode_Seqnum = pcode.getSeqnum()
            Pcode_Addr = Pcode_Seqnum.getTarget()
            Pcode_Ins = getInstructionAt(Pcode_Addr)
            Pcode_Ins_Str = Pcode_Ins.toString()
            #print("Pcode belongs to Instruction: {}".format(Pcode_Ins_Str))
            if "const_string" in Pcode_Ins_Str:
                String_Idx = pcode.getInput(1).getOffset()
                logger.debug("String: {}".format(getString(String_Idx)))
            elif "new_instance" in Pcode_Ins_Str:
                Class_Idx = pcode.getInput(1).getOffset()
            elif "get_object" in Pcode_Ins_Str:
                Field_Idx = pcode.getInput(1).getOffset()
            elif "invoke_" in Pcode_Ins_Str:
                Method_Idx = pcode.getInput(1).getOffset()
            else:
                logger.debug("Pcode-Op CPOOLREF at instruction! {}".format(Pcode_Ins_Str))       
        elif Opcode == PcodeOp.NEW:
            Class_Varnode = pcode.getInput(0)
            Pcode_Def_Class_Varnode = Class_Varnode.getDef()
            Class_Idx = Pcode_Def_Class_Varnode.getInput(1).getOffset()
            print("Class: {}".format(getType(Class_Idx)))
            Pcode_Relates = pcode.getOutput().getDescendants()
            while Pcode_Relates.hasNext(): 
                Pcode_Relate = Pcode_Relates.next()
                print("Instance related Pcode: {}".format(Pcode_Relate))
                if Pcode_Relate.getOpcode() == PcodeOp.CALL or Pcode_Relate.getOpcode() == PcodeOp.CALLIND:
                    Method_Varnode = Pcode_Relate.getInput(0)
                    Pcode_Def_Method_Varnode = Method_Varnode.getDef()
                    Method_Idx = Pcode_Def_Method_Varnode.getInput(1).getOffset()
                    Method_Name = getMethod(Method_Idx)
                    print("Instance related method: {}".format(Method_Name))
                    for i in range(2, len(Pcode_Relate.getInputs())):
                        Param_Target_Varnode = Pcode_Relate.getInput(i)
                        self.analyse_node(Param_Target_Varnode, Pcode_Relate)
        elif Opcode == PcodeOp.LOAD:
            Field_Varnode = pcode.getInput(1)
            Pcode_Def_Field_Varnode = Field_Varnode.getDef()
            Field_Idx = Pcode_Def_Field_Varnode.getInput(1).getOffset()
            print("Field: {}".format(getField(Field_Idx)))
            print("ssss {}".format(pcode.getInput(0)))
                                   
    def StringBuilder(self, pcode):
        Target_Varnode = pcode.getInput(1)
        Pcode_Relates = Target_Varnode.getDescendants()
        while Pcode_Relates.hasNext():
            Pcode_Relate = Pcode_Relates.next()
            Pcode_Relate_Op = Pcode_Relate.getOpcode()
            if Pcode_Relate.getOpcode() == PcodeOp.CALL or Pcode_Relate.getOpcode() == Pcode.CALLIND:
                Method_Varnode = pcode.getInput(0)
                Pcode_Def_Method_Varnode = Method_Varnode.getDef()
                Method_Idx = Pcode_Def_Method_Varnode.getInput(1).getOffset()
                Method_Name = getMethod(Method_Idx)
                print("Method: {}".format(Method_Name))   

print(getField(0))             

if __name__ == '__main__':
    References = getReferencesTo(toAddr(0x50124204)) # Function's address
    logger.debug("Reference functions are: {}".format(References))
    for Reference in References:
        Reference_Addr = Reference.getFromAddress()
        if Reference.getReferenceType().isCall():
            Reference_Func = getFunctionContaining(Reference_Addr)
            logger.debug("Reference function is: {}".format(Reference_Func))
            if Reference_Func not in Examined_Funcs:
                Examined_Funcs[Reference_Func] = FunctionAnalyzer(Reference_Func)
            Reference_Func_Analyzer = Examined_Funcs[Reference_Func]
            Reference_Func_Analyzer.start_analyse(Reference_Addr, 2) # 2 is parameters index


```

`LICENSE`:

```
MIT License

Copyright (c) 2019 PAGalaxyLab

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# ghidra_scripts
Scripts for the Ghidra software reverse engineering suite.

*Readme in other languages: [English](README.md), [简体中文](README.zh-cn.md)*


# Installation
In the Ghidra Script Manager click the "Script Directories" icon in the toolbar and add the checked out repository as a path.


# galaxy_utility
Some utility used by other Ghidra scripts.


# trace_function_call_parm_value.py
Trace Function call parameters value using Ghidra P-Code.

![Demo pic](docs/images/trace_function_call_parm_value_pic_1.jpg)

# wr886nv7_rename_function_with_error_print.py
Example script, rename undefined function with error print string.

[Detail steps](docs/wr886nv7_rename_function_with_error_print.md)

![Demo pic](docs/images/wr886nv7_rename_function_with_error_print_1.jpg)


# AnalyzeOCMsgSend.py
Analyze Objective-C MsgSend using this script.

![Demo pic](docs/images/analyze_oc_msg_send_pic.png)


# DexFile_Parameter_Trace.py
Trace an Android Function parameters value using Ghidra P-Code.

## function logd 1st parameter trace
![Demo pic](docs/images/DexFile_Parameter_Trace_Logd.png)

Provide target function's address and parameters index
![Demo pic](docs/images/DexFile_Parameter_Trace_Script_Param.png)

Output
![Demo pic](docs/images/DexFile_Parameter_trace_Script_Output.png)

# ollvm_deobf_fla.py
Deobfuscating OLLVM control flow flattening.

Select the assembly for state var initialization in Ghidra code listing interface.

![Demo pic](docs/images/ghidra-ollvm-obf.png)

Then run the script for deobfuscation.

![Demo pic](docs/images/ghidra-ollvm-deobf.png)

```

`README.zh-cn.md`:

```md
# ghidra_scripts
我们所使用的一些Ghidra逆向分析脚本.

*说明文档的其他语言: [English](README.md), [简体中文](README.zh-cn.md)*

# 安装
在Ghidra脚本管理器中点击"Script Directories", 添加checked out后的repository路径.


# galaxy_utility
其他Ghidra脚本所使用的实用工具。


# trace_function_call_parm_value.py
使用Ghidra P-Code追踪分析函数调用时的传参值。

![Demo pic](docs/images/trace_function_call_parm_value_pic_1.jpg)


# wr886nv7_rename_function_with_error_print.py
样例脚本, 利用函数错误输出中的函数名关键字来重命名未定义的函数。
[详细步骤](docs/wr886nv7_rename_function_with_error_print.zh-cn.md)

![Demo pic](docs/images/wr886nv7_rename_function_with_error_print_1.jpg)


# AnalyzeOCMsgSend.py
使用Ghidra脚本分析Objective-C中的MsgSend方法。

![Demo pic](docs/images/analyze_oc_msg_send_pic.png)


# DexFile_Parameter_Trace.py
使用Pcode追踪Dex文件中的函数参数。

## 使用Ghidra脚本分析Logd函数的第一个参数
![Demo pic](docs/images/DexFile_Parameter_Trace_Logd.png)

提供Logd函数的地址(这里是0x50123cdc)和2(代表第一个参数)
![Demo pic](docs/images/DexFile_Parameter_Trace_Script_Param.png)

输出
![Demo pic](docs/images/DexFile_Parameter_trace_Script_Output.png)

# ollvm_deobf_fla.py
使用Pcode对OLLVM控制流平坦化进行反混淆。

在Ghidra的界面中选中用于初始化状态变量的汇编代码。

![Demo pic](docs/images/ghidra-ollvm-obf.png)

运行脚本，进行反混淆

![Demo pic](docs/images/ghidra-ollvm-deobf.png)

```

`docs/wr886nv7_rename_function_with_error_print.md`:

```md
# Detail steps of demo script wr886nv7_rename_function_with_error_print.py

## step 1: Download wr886nv7 firmware and extract VxWorks image
You can download example wr886nv7 firmware [here](http://download.tplinkcloud.com.cn/firmware/wr886nv7-ipv6-cn-up_2019-10-25_09.43.28_1572316888807.bin).

Using binwalk to extract the firmware.

![](images/wr886nv7_rename_function_with_error_print_2.jpg)

Find TP-Link external symbol file.

![](images/wr886nv7_rename_function_with_error_print_3.jpg)

Load VxWorks image "A200" to Ghidra with MIPS Big endian processor type and default load address zero.

![](images/wr886nv7_rename_function_with_error_print_4.jpg)

Don't analyze image this time, since we don't known the correct load address.


## step 2: Run VxHunter load tp-link symbols script

PS: You need install VxHunter first, VxHunter repository can be found [here](https://github.com/PAGalaxyLab/vxhunter)

Run VxHunter vxhunter_load_tp-link_symbols.py in script manager and select the TP-Link external symbol file "DBECB".  

This script will load TP-Link external symbol file, rebase image to correct load address and fix the function name.

![](images/wr886nv7_rename_function_with_error_print_5.jpg)


## step 3: Run wr886nv7_rename_function_with_error_print.py

All done, you can now run wr886nv7_rename_function_with_error_print.py script.

This script will analyze functions error print and use it to rename undefined function.

![](images/wr886nv7_rename_function_with_error_print_1.jpg)

```

`docs/wr886nv7_rename_function_with_error_print.zh-cn.md`:

```md
# 使用样例脚本wr886nv7_rename_function_with_error_print.py的详细步骤


## 步骤一: 下载wr886nv7固件并提取VxWorks镜像
样例wr886nv7固件[下载地址](http://download.tplinkcloud.com.cn/firmware/wr886nv7-ipv6-cn-up_2019-10-25_09.43.28_1572316888807.bin)。

使用binwalk来提取固件.

![](images/wr886nv7_rename_function_with_error_print_2.jpg)

寻找TP-Link外部符号表.

![](images/wr886nv7_rename_function_with_error_print_3.jpg)

在Ghidra中使用MIPS Big endian处理器及默认加载地址0来导入VxWorks固件"A200"。

![](images/wr886nv7_rename_function_with_error_print_4.jpg)

先不要对VxWorks镜像进行分析，因为我们此时并不知道正确的加载地址。


## 步骤二: 执行VxHunter load tp-link symbols脚本

PS: 需要先安装VxHunter, [VxHunter项目地址](https://github.com/PAGalaxyLab/vxhunter)

在Ghidra脚本管理器中运行vxhunter_load_tp-link_symbols.py后选择TP-Link外部符号文件"DBECB"。

这个脚本会自动加载TP-Link外部符号文件, 将VxWorks镜像rebase到正确的加载地址并利用符号表修复函数名字。

![](images/wr886nv7_rename_function_with_error_print_5.jpg)


## step 3: Run wr886nv7_rename_function_with_error_print.py

所有前置工作都完成了，现在可以运行wr886nv7_rename_function_with_error_print.py脚本了.

这个脚本将会分析函数的错误输出并利用这些输出对未识别的函数进行重命名.

![](images/wr886nv7_rename_function_with_error_print_1.jpg)

```

`galaxy_utility/common.py`:

```py
# coding=utf-8
from ghidra.app.util.demangler import DemangledException
from ghidra.app.util.demangler.gnu import GnuDemangler
from ghidra.program.model.mem import Memory
from ghidra.util.task import TaskMonitor
import struct
import logging
import time

# The Python module that Ghidra directly launches is always called __main__.  If we import
# everything from that module, this module will behave as if Ghidra directly launched it.
from __main__ import *

debug = False
process_is_64bit = False


# Init Default Logger
def get_logger(name="Default_logger"):
    logger = logging.getLogger(name)
    logger.setLevel(logging.INFO)
    console_handler = logging.StreamHandler()
    console_format = logging.Formatter('[%(levelname)-8s][%(module)s.%(funcName)s] %(message)s')
    console_handler.setFormatter(console_format)
    logger.addHandler(console_handler)
    return logger


logger = get_logger()


if debug:
    logger.setLevel(logging.DEBUG)

endian = currentProgram.domainFile.getMetadata()[u'Endian']
if endian == u'Big':
    is_big_endian = True
else:
    is_big_endian = False

process_type = currentProgram.domainFile.getMetadata()[u'Processor']
if process_type.endswith(u'64'):
    process_is_64bit = True

demangler = GnuDemangler()
listing = currentProgram.getListing()
can_demangle = demangler.canDemangle(currentProgram)


class Timer(object):
    def __init__(self):
        self.start_time = None

    def reset(self):
        self.start_time = time.time()

    def start_timer(self):
        if self.start_time:
            return False
        else:
            self.start_time = time.time()
            return self.start_time

    def get_timer(self):
        if self.start_time:
            return time.time() - self.start_time
        return False


def is_address_in_current_program(address):
    for block in currentProgram.memory.blocks:
        if block.getStart().offset <= address.offset <= block.getEnd().offset:
            return True
    return False


def get_signed_value(input_data):
    pack_format = ""
    if is_big_endian:
        pack_format += ">"
    else:
        pack_format += "<"

    if process_is_64bit:
        pack_format += "L"
    else:
        pack_format += "I"

    logger.debug("type(input_data): {}".format(type(input_data)))
    data = struct.pack(pack_format.upper(), input_data)
    signed_data = struct.unpack(pack_format.lower(), data)[0]

    return signed_data


def create_uninitialized_block(block_name, start_address, length, overlay=False):
    # createUninitializedBlock

    try:
        memory = currentProgram.memory
        memory.createUninitializedBlock(block_name, start_address, length, overlay)
        return True

    except:
        return False


def create_initialized_block(block_name, start_address, length, fill=0x00, monitor=TaskMonitor.DUMMY, overlay=False):
    # createUninitializedBlock

    try:
        memory = currentProgram.memory
        memory.createInitializedBlock(block_name, start_address, length, fill, monitor, overlay)
        return True

    except:
        return False

```

`galaxy_utility/function_analyzer.py`:

```py
# coding=utf-8
from galaxy_utility.common import *
from ghidra.app.decompiler import DecompInterface
from ghidra.program.model.pcode import PcodeOp, PcodeOpAST
from ghidra.program.model.address import GenericAddress

# The Python module that Ghidra directly launches is always called __main__.  If we import
# everything from that module, this module will behave as if Ghidra directly launched it.
from __main__ import *


decompile_function_cache = {

}

logger = get_logger(__name__)


class FlowNode(object):
    def __init__(self, var_node, logger=logger):
        """ Used to get VarNode value

        :param var_node:
        """
        self.var_node = var_node
        if logger is None:
            self.logger = get_logger(self.__class__.__name__)
        else:
            self.logger = logger

    def get_value(self):
        """ Get VarNode value depend on it's type.

        :return:
        """
        if self.var_node.isAddress():
            self.logger.debug("Var_node isAddress")
            # TODO: Return pointer value is address is pointer, this might cause some bug, need more test.
            # try:
            #     if getDataAt(self.var_node.getAddress()).isPointer():
            #         self.logger.info("Var_node address is pointer")
            #         return getDataAt(self.var_node.getAddress()).getValue().offset
            #
            # except BaseException as err:
            #     self.logger.err(err)
            #     return self.var_node.getAddress()
            #
            return self.var_node.getAddress()
        elif self.var_node.isConstant():
            self.logger.debug("Var_node isConstant")
            return self.var_node.getAddress()
        elif self.var_node.isUnique():
            self.logger.debug("Var_node isUnique")
            return calc_pcode_op(self.var_node.getDef())
        elif self.var_node.isRegister():
            self.logger.debug("Var_node isRegister")
            self.logger.debug(self.var_node.getDef())
            return calc_pcode_op(self.var_node.getDef())

        # https://github.com/NationalSecurityAgency/ghidra/issues/2283
        elif self.var_node.isPersistent():
            self.logger.debug("Var_node isPersistent")
            # TODO: Handler this later
            return
        elif self.var_node.isAddrTied():
            self.logger.debug("Var_node isAddrTied")
            return calc_pcode_op(self.var_node.getDef())
        elif self.var_node.isUnaffected():
            self.logger.debug("Var_node isUnaffected")
            # TODO: Handler this later
            return
        else:
            self.logger.debug("self.var_node: {}".format(self.var_node))


def calc_pcode_op(pcode):
    logger.debug("pcode: {}, type: {}".format(pcode, type(pcode)))
    if isinstance(pcode, PcodeOpAST):
        opcode = pcode.getOpcode()
        if opcode == PcodeOp.PTRSUB:
            logger.debug("PTRSUB")
            var_node_1 = FlowNode(pcode.getInput(0))
            var_node_2 = FlowNode(pcode.getInput(1))
            value_1 = var_node_1.get_value()
            value_2 = var_node_2.get_value()
            if isinstance(value_1, GenericAddress) and isinstance(value_2, GenericAddress):
                return value_1.offset + value_2.offset

            else:
                logger.debug("value_1: {}".format(value_1))
                logger.debug("value_2: {}".format(value_2))
                return None

        elif opcode == PcodeOp.CAST:
            logger.debug("CAST")
            var_node_1 = FlowNode(pcode.getInput(0))
            value_1 = var_node_1.get_value()
            if isinstance(value_1, GenericAddress):
                return value_1.offset

            else:
                return None

        elif opcode == PcodeOp.PTRADD:
            logger.debug("PTRADD")
            var_node_0 = FlowNode(pcode.getInput(0))
            var_node_1 = FlowNode(pcode.getInput(1))
            var_node_2 = FlowNode(pcode.getInput(2))
            try:
                value_0_point = var_node_0.get_value()
                logger.debug("value_0_point: {}".format(value_0_point))
                if not isinstance(value_0_point, GenericAddress):
                    return
                value_0 = toAddr(getInt(value_0_point))
                logger.debug("value_0: {}".format(value_0))
                logger.debug("type(value_0): {}".format(type(value_0)))
                value_1 = var_node_1.get_value()
                logger.debug("value_1: {}".format(value_1))
                logger.debug("type(value_1): {}".format(type(value_1)))
                if not isinstance(value_1, GenericAddress):
                    logger.debug("value_1 is not GenericAddress!")
                    return
                value_1 = get_signed_value(value_1.offset)
                # TODO: Handle input2 later
                value_2 = var_node_2.get_value()
                logger.debug("value_2: {}".format(value_2))
                logger.debug("type(value_2): {}".format(type(value_2)))
                if not isinstance(value_2, GenericAddress):
                    return
                output_value = value_0.add(value_1)
                logger.debug("output_value: {}".format(output_value))
                return output_value.offset

            except Exception as err:
                logger.debug("Got something wrong with calc PcodeOp.PTRADD : {}".format(err))
                return None

            except:
                logger.error("Got something wrong with calc PcodeOp.PTRADD ")
                return None

        elif opcode == PcodeOp.INDIRECT:
            logger.debug("INDIRECT")
            # TODO: Need find a way to handle INDIRECT operator.
            return None

        elif opcode == PcodeOp.MULTIEQUAL:
            logger.debug("MULTIEQUAL")
            # TODO: Add later
            return None

        elif opcode == PcodeOp.COPY:
            logger.debug("COPY")
            logger.debug("input_0: {}".format(pcode.getInput(0)))
            logger.debug("Output: {}".format(pcode.getOutput()))
            var_node_0 = FlowNode(pcode.getInput(0))
            value_0 = var_node_0.get_value()
            return value_0

    else:
        logger.debug("Found Unhandled opcode: {}".format(pcode))
        return None


class FunctionAnalyzer(object):

    def __init__(self, function, timeout=30, logger=logger):
        """

        :param function: Ghidra function object.
        :param timeout: timeout for decompile.
        :param logger: logger.
        """
        self.function = function
        self.timeout = timeout
        if logger is None:
            self.logger = get_logger("FunctionAnalyzer")
        else:
            self.logger = logger
        self.hfunction = None
        self.call_pcodes = {}
        self.prepare()

    def prepare(self):
        self.hfunction = self.get_hfunction()
        self.get_all_call_pcode()

    def get_hfunction(self):
        decomplib = DecompInterface()
        decomplib.openProgram(currentProgram)
        timeout = self.timeout
        dRes = decomplib.decompileFunction(self.function, timeout, getMonitor())
        hfunction = dRes.getHighFunction()
        return hfunction

    def get_function_pcode(self):
        if self.hfunction:
            try:
                ops = self.hfunction.getPcodeOps()

            except:
                return None

            return ops

    def print_pcodes(self):
        ops = self.get_function_pcode()
        while ops.hasNext():
            pcodeOpAST = ops.next()
            print(pcodeOpAST)
            opcode = pcodeOpAST.getOpcode()
            print("Opcode: {}".format(opcode))
            if opcode == PcodeOp.CALL:
                print("We found Call at 0x{}".format(pcodeOpAST.getInput(0).PCAddress))
                call_addr = pcodeOpAST.getInput(0).getAddress()
                print("Calling {}(0x{}) ".format(getFunctionAt(call_addr), call_addr))
                inputs = pcodeOpAST.getInputs()
                for i in range(len(inputs)):
                    parm = inputs[i]
                    print("parm{}: {}".format(i, parm))

    def find_perv_call_address(self, address):
        try:
            address_index = sorted(self.call_pcodes.keys()).index(address)

        except Exception as err:
            return

        if address_index > 0:
            perv_address = sorted(self.call_pcodes.keys())[address_index - 1]
            return self.call_pcodes[perv_address]

    def find_next_call_address(self, address):
        try:
            address_index = sorted(self.call_pcodes.keys()).index(address)

        except Exception as err:
            return

        if address_index < len(self.call_pcodes) - 1:
            next_address = sorted(self.call_pcodes.keys())[address_index + 1]
            return self.call_pcodes[next_address]

    def get_all_call_pcode(self):
        ops = self.get_function_pcode()
        if not ops:
            return

        while ops.hasNext():
            pcodeOpAST = ops.next()
            opcode = pcodeOpAST.getOpcode()
            if opcode in [PcodeOp.CALL, PcodeOp.CALLIND]:
                op_call_addr = pcodeOpAST.getInput(0).PCAddress
                self.call_pcodes[op_call_addr] = pcodeOpAST

    def get_call_pcode(self, call_address):
        # TODO: Check call_address is in function.
        if call_address in self.call_pcodes:
            return self.call_pcodes[call_address]

        return

    def analyze_call_parms(self, call_address):
        parms = {}
        # TODO: Check call_address is in function.
        pcodeOpAST = self.get_call_pcode(call_address)
        if pcodeOpAST:
            self.logger.debug("We found target call at 0x{} in function {}(0x{})".format(
                pcodeOpAST.getInput(0).PCAddress, self.function.name, hex(self.function.entryPoint.offset)))
            opcode = pcodeOpAST.getOpcode()
            if opcode == PcodeOp.CALL:
                target_call_addr = pcodeOpAST.getInput(0).getAddress()
                self.logger.debug("target_call_addr: {}".format(target_call_addr))

            elif opcode == PcodeOp.CALLIND:
                target_call_addr = FlowNode(pcodeOpAST.getInput(0)).get_value()
                self.logger.debug("target_call_addr: {}".format(target_call_addr))

            inputs = pcodeOpAST.getInputs()
            for i in range(len(inputs))[1:]:
                parm = inputs[i]
                self.logger.debug("parm{}: {}".format(i, parm))
                parm_node = FlowNode(parm)
                self.logger.debug("parm_node: {}".format(parm_node))
                parm_value = parm_node.get_value()
                self.logger.debug("parm_value: {}".format(parm_value))
                if isinstance(parm_value, GenericAddress):
                    parm_value = parm_value.offset
                parms[i] = parm_value
                if parm_value:
                    self.logger.debug("parm{} value: {}".format(i, hex(parm_value)))
            return parms
        return

    def get_call_parm_value(self, call_address):
        parms_value = {}
        if not call_address in self.call_pcodes:
            return
        parms = self.analyze_call_parms(call_address)

        if not parms:
            return

        for i in parms:
            self.logger.debug("parms{}: {}".format(i, parms[i]))
            parm_value = parms[i]
            self.logger.debug("parm_value: {}".format(parm_value))
            parm_data = None
            if parm_value:
                if is_address_in_current_program(toAddr(parm_value)):
                    if getDataAt(toAddr(parm_value)):
                        parm_data = getDataAt(toAddr(parm_value))
                    elif getInstructionAt(toAddr(parm_value)):
                        parm_data = getFunctionAt(toAddr(parm_value))

            parms_value["parm_{}".format(i)] = {'parm_value': parm_value,
                                                'parm_data': parm_data
                                                }

        return parms_value


def dump_call_parm_value(call_address, search_functions=None):
    """

    :param call_address:
    :param search_functions: function name list to search
    :return:
    """
    target_function = getFunctionAt(call_address)
    parms_data = {}
    if target_function:
        target_references = getReferencesTo(target_function.getEntryPoint())
        for target_reference in target_references:
            # Filter reference type
            reference_type = target_reference.getReferenceType()
            logger.debug("reference_type: {}".format(reference_type))
            logger.debug("isJump: {}".format(reference_type.isJump()))
            logger.debug("isCall: {}".format(reference_type.isCall()))
            if not reference_type.isCall():
                logger.debug("skip!")
                continue

            call_addr = target_reference.getFromAddress()
            logger.debug("call_addr: {}".format(call_addr))
            function = getFunctionContaining(call_addr)
            logger.debug("function: {}".format(function))
            if not function:
                continue

            # search only targeted function
            if search_functions:
                if function.name not in search_functions:
                    continue

            function_address = function.getEntryPoint()
            if function_address in decompile_function_cache:
                target = decompile_function_cache[function_address]

            else:
                target = FunctionAnalyzer(function=function)
                decompile_function_cache[function_address] = target

            parms_data[call_addr] = {
                'call_addr': call_addr,
                'refrence_function_addr': function.getEntryPoint(),
                'refrence_function_name': function.name,
                'parms': {}
            }

            parms_value = target.get_call_parm_value(call_address=call_addr)
            if not parms_value:
                continue

            trace_data = parms_data[call_addr]
            trace_data['parms'] = parms_value

        return parms_data

```

`ollvm_deobf_fla.py`:

```py
# Ghidra script for deobfuscating OLLVM control flow flattening
# select the assembly for state var initialization in Ghidra code listing interface and run the script

import os
import binascii
import logging

from ghidra.app.decompiler import DecompInterface
from ghidra.program.model.mem import *
from ghidra.program.model.pcode import PcodeOp
from ghidra.app.plugin.assembler import Assemblers

logging.basicConfig(level=logging.INFO,
                    format='[%(asctime)s][%(levelname)s] - %(message)s',
                    datefmt='%m/%d/%Y %H:%M:%S %p')

def get_last_pcode(block):
    pcode_iterator = block.getIterator()
    while pcode_iterator.hasNext():
        pcode = pcode_iterator.next()
        if not pcode_iterator.hasNext():
            return pcode

# check if the var is state_var
def is_state_var(state_var, var, depth=0):
    logging.debug('comparing %s to state var %s, depth %d' % (var, state_var, depth))
    if depth > 1:
        logging.warning('reach max depth for is_state_var: %s' % var)
        return False
    # for temp var, find its definition
    if var.isUnique():
        var_def = var.getDef()
        logging.debug('temp var def: %s' % var_def)
        if var_def.getOpcode() == PcodeOp.COPY:
            var = var_def.getInput(0)
            logging.debug('update var to %s' % var)
        elif var_def.getOpcode() == PcodeOp.MULTIEQUAL:
            # include phi node inputs
            for input_var in var_def.getInputs().tolist():
                if is_state_var(state_var, input_var, depth+1):
                    return True
    return state_var.getAddress() == var.getAddress()

# value of state var may need to be updated before compared to const
def const_update(const):
    # signed to unsigned
    return const & 0xffffffff

# find blocks setting state var to consts
def find_const_def_blocks(mem, state_var_size, pcode, depth, res, def_block):
    if depth > 3:
        logging.warning('reaching max depth in find_const_def_blocks')

    elif pcode is None:
        logging.warning('pcode is None')

    else:
        logging.debug('finding state var def in pcode %s of block %s, depth %d' % (pcode, pcode.getParent(), depth))
        if pcode.getOpcode() == PcodeOp.COPY:
            input_var = pcode.getInput(0)
            if def_block is None:
                # the block of COPY is the def block
                def_block = pcode.getParent()
                logging.debug('find COPY in block %s' % def_block)
            # is copying const to var?
            if input_var.isConstant():
                logging.debug('%s defines state var to const: %s' % (def_block, input_var))
                if def_block not in res:
                    res[def_block] = input_var.getOffset()
                else:
                    logging.warning('%s already defines state var to const %s, skipped' % (def_block, res[def_block]))
            else:
                # if input var is in ram, read its value
                if input_var.getAddress().getAddressSpace().getName() == u'ram':
                    if input_var.isAddress():
                        if state_var_size == 4:
                            ram_value = mem.getInt(input_var.getAddress())
                            res[def_block] = ram_value
                        elif state_var_size == 8:
                            ram_value = mem.getLong(input_var.getAddress())
                            res[def_block] = ram_value
                        else:
                            logging.warning('state var size %d not supported' % state_var_size)
                    else:
                        logging.warning('def of non-const input_var %s not found' % input_var)
                # not ram or const, trace back to const def
                else:
                    find_const_def_blocks(mem, state_var_size, input_var.getDef(), depth+1, res, def_block)

        elif pcode.getOpcode() == PcodeOp.MULTIEQUAL:
            for input_var in pcode.getInputs().tolist():
                find_const_def_blocks(mem, state_var_size, input_var.getDef(), depth+1, res, def_block)
        else:
            logging.warning('unsupported pcode %s, depth %d' % (pcode, depth))

class Patcher(object):
    def __init__(self, current_program):
        self.listing_db = current_program.getListing()
        self.asm = Assemblers.getAssembler(current_program)

    def patch_unconditional_jump(self, addr, target_addr):
        return None

    def patch_conditional_jump(self, ins, true_addr, false_addr):
        return None

    # patch the binary for updated CFG
    def do_patch(self, link):
        logging.debug('patching block for CFG %s' % str(link))

        block = link[0]
        ins = self.listing_db.getInstructions(block.getStop(), True).next()
        logging.debug('last ins in block to patch at %s: %s' % (block.getStop(), ins))

        patch_addr = ins.getMinAddress()

        # unconditional jump
        if len(link) == 2:
            target_addr = link[1].getStart().getOffset()
            asm_string = self.patch_unconditional_jump(patch_addr, target_addr)
            logging.debug('patching unconditional jump at %s to %s' % (patch_addr, asm_string))
            patched = self.asm.assembleLine(patch_addr, asm_string)
            if len(patched) > ins.getLength():
                logging.error('not enough space at %s for patch %s' % (patch_addr, asm_string))
                return None

        # conditional jump
        else:
            true_addr = link[1].getStart().getOffset()
            false_addr = link[2].getStart().getOffset()
            asm_string = self.patch_conditional_jump(ins, true_addr, false_addr)
            logging.debug('patching conditional jump at %s to %s' % (patch_addr, asm_string))

        if asm_string is not None:
            patch = self.asm.assemble(patch_addr, asm_string)
            patch_bytes = bytearray()
            patch_ins_iterator = patch.iterator()
            while patch_ins_iterator.hasNext():
                patch_bytes += bytearray(patch_ins_iterator.next().getBytes())
            return (patch_addr, patch_bytes)
        else:
            return None


class PatcherX86(Patcher):
    def __init__(self, current_program):
        super(PatcherX86, self).__init__(current_program)

    def patch_unconditional_jump(self, addr, target_addr):
        return 'JMP 0x%x' % target_addr

    def patch_conditional_jump(self, ins, true_addr, false_addr):
        op_str = str(ins.getMnemonicString())

        if op_str.startswith('CMOV'):
            return '%s 0x%x\nJMP 0x%x' % (op_str.replace('CMOV', 'J'), true_addr, false_addr)
        else:
            return None

class PatcherARM(Patcher):
    def __init__(self, current_program):
        super(PatcherARM, self).__init__(current_program)

    def patch_unconditional_jump(self, addr, target_addr):
        return 'b 0x%x' % target_addr

    def patch_conditional_jump(self, ins, true_addr, false_addr):
        op_str = str(ins.getMnemonicString())

        if op_str.startswith('cpy'):
            asm_string = '%s 0x%x\nb 0x%x' % (op_str.replace('cpy', 'b'), true_addr, false_addr)
        elif op_str.startswith('mov'):
            asm_string = '%s 0x%x\nb 0x%x' % (op_str.replace('mov', 'b'), true_addr, false_addr)
        else:
            logging.warning('ins %s not supported' % ins)
            asm_string = None

        return asm_string

class PatcherAArch64(PatcherARM):
    def __init__(self, current_program):
        super(PatcherAArch64, self).__init__(current_program)

    def patch_conditional_jump(self, ins, true_addr, false_addr):
        op_str = str(ins.getMnemonicString())

        if op_str == 'csel':
            # get the condition from the last operand
            condition = str(ins.getDefaultOperandRepresentation(3))
            # hack for CSEL: its pcode takes the last operand as def
            (true_addr, false_addr) = (false_addr, true_addr)
            asm_string = 'b.%s 0x%x\nb 0x%x' % (condition, true_addr, false_addr)
            return asm_string
        else:
            logging.warning('ins %s not supported' % ins)
            return None


def get_high_function(current_program, current_address):
    decomplib = DecompInterface()
    decomplib.openProgram(current_program)

    current_function = getFunctionContaining(current_address)
    decompile_res = decomplib.decompileFunction(current_function, 30, getMonitor())

    high_function = decompile_res.getHighFunction()
    return high_function

def get_state_var(high_function, current_address):
    pcode_iterator = high_function.getPcodeOps(current_address)
    pcode = None

    # find the pcode for COPYing const
    while pcode_iterator.hasNext():
        pcode = pcode_iterator.next()
        logging.debug('finding COPY const pcode: %s' % pcode)
        if pcode.getOpcode() == PcodeOp.COPY and pcode.getInput(0).isConstant():
            break

    logging.info('COPY const pcode: %s' % pcode)

    # find the state var in phi node
    depth = 0
    while pcode is not None and pcode.getOpcode() != PcodeOp.MULTIEQUAL:
        logging.debug('finding phi node: %s, depth %d' % (pcode, depth))
        if pcode.getOutput() is None:
            logging.warning('output is None in %s' % pcode)
            break
        pcode = pcode.getOutput().getLoneDescend()
        if depth > 5:
            break
        depth += 1

    if pcode is None or pcode.getOpcode() != PcodeOp.MULTIEQUAL:
        logging.error('cannot find phi node')
        return None
    else:
        logging.info('phi node: %s' % pcode)

    state_var = pcode.getOutput()
    logging.info('state var is %s' % state_var)
    return state_var


# map const values of state var to blocks
def compute_const_map(high_function, state_var):
    const_map = {}

    for block in high_function.getBasicBlocks():
        # search for conditional jump
        if block.getOutSize() != 2:
            continue

        last_pcode = get_last_pcode(block)
        if last_pcode.getOpcode() != PcodeOp.CBRANCH:
            continue

        condition = last_pcode.getInput(1)

        condition_pcode = condition.getDef()
        logging.debug('condition pcode: %s' % condition_pcode)

        condition_type = condition_pcode.getOpcode()

        if not condition_type in (PcodeOp.INT_NOTEQUAL, PcodeOp.INT_EQUAL):
            continue

        in0 = condition_pcode.getInput(0)
        in1 = condition_pcode.getInput(1)

        if in0.isConstant():
            const_var = in0
            compared_var = in1
        elif in1.isConstant():
            const_var = in1
            compared_var = in0
        else:
            logging.debug('not const var in comparision, skipped')
            continue

        if is_state_var(state_var, compared_var):
            if condition_type == PcodeOp.INT_NOTEQUAL:
                target_block = block.getFalseOut()
            else:
                target_block = block.getTrueOut()
            const_map[const_var.getOffset()] = target_block
        else:
            logging.debug('state_var not involved in %s' % condition_pcode)


    logging.info('const_map map:\n%s' % '\n'.join('0x%x: %s' % kv for kv in const_map.items()))
    return const_map


def find_state_var_defs(mem, state_var):
    phi_node = state_var.getDef()

    state_var_defs = {}

    for state_var_def in phi_node.getInputs().tolist():
        if state_var_def == state_var:
            continue
        pcode = state_var_def.getDef()
        logging.debug('output %s of pcode %s in block %s defines state var' % (state_var_def, pcode, pcode.getParent()))

        find_const_def_blocks(mem, state_var.getSize(), pcode, 0, state_var_defs, None)

    logging.info('blocks defining state var:\n%s' % '\n'.join('%s: %s' % (b, hex(v)) for b, v in state_var_defs.items()))
    return state_var_defs


def gen_cfg(const_map, state_var_defs):
    links = []

    # basic blocks for CMOVXX
    cmovbb = []

    for def_block, const in state_var_defs.items():

        # unconditional jump
        if def_block.getOutSize() == 1:
            const = const_update(const)
            if const in const_map:
                link = (def_block, const_map[const])
                logging.debug('unconditional jump link: %s' % str(link))
                links.append(link)
            else:
                logging.warning('cannot find const 0x%x in const_map' % const)

        # conditional jump
        elif def_block.getOutSize() == 2:
            const = const_update(const)
            true_out = def_block.getTrueOut()
            false_out = def_block.getFalseOut()
            logging.debug('%s true out: %s, false out %s' % (def_block, true_out, false_out))

            # true out block has state var def
            if true_out in state_var_defs:
                true_out_const = const_update(state_var_defs[true_out])
                if true_out_const not in const_map:
                    logging.warning('true out cannot find map from const 0x%x to block' % true_out_const)
                    continue
                true_out_block = const_map[true_out_const]
                logging.debug('true out to block: %s' % true_out_block)

                if false_out in state_var_defs:
                    false_out_const = const_update(state_var_defs[false_out])
                    if false_out_const not in const_map:
                        logging.warning('false out cannot find map from const 0x%x to block' % false_out_const)
                        continue
                    else:
                        false_out_block = const_map[false_out_const]
                        logging.debug('false out to block: %s' % false_out_block)

                # false out doesn't have const def, then use the def in current block for the false out
                elif const in const_map:
                    false_out_block = const_map[const]
                else:
                    logging.warning('mapping of const %s in block %s not found' % (const, def_block))
                    continue

                link = (def_block, true_out_block, false_out_block)
                logging.debug('conditional jump link: %s' % str(link))

                # the link from CMOVXX should be ignored since the current conditional jump would do it
                cmovbb.append(true_out)
                links.append(link)

            # false out block has state var def
            elif false_out in state_var_defs:
                false_out_const = const_update(state_var_defs[false_out])
                if false_out_const not in const_map:
                    logging.warning('false out cannot find map from const 0x%x to block' % false_out_const)
                    continue
                false_out_block = const_map[false_out_const]
                logging.debug('false out to block: %s' % false_out_block)

                # true out doesn't have const def, then use the def in current block for the true out
                if const in const_map:
                    true_out_block = const_map[const]
                    link = (def_block, true_out_block, false_out_block)
                    logging.debug('conditional jump link: %s' % str(link))
                    links.append(link)
                else:
                    logging.warning('mapping of const %s in block %s not found' % (const, def_block))
            else:
                logging.warning('no state var def in either trueout or falseout of block %s' % def_block)
        else:
            logging.warning('output block counts %d not supported' % def_block.getOutSize())

    # skip the link for CMOVXX
    links_res = []
    for link in links:
        if link[0] not in cmovbb:
            links_res.append(link)
        else:
            logging.debug('skip %s as CMOVXX' % str(link))

    logging.info('generated CFG links:\n%s' % '\n'.join(str(link) for link in links_res))
    return links_res

def patch_cfg(current_program, cfg_links):
    patches = []

    arch = current_program.getLanguage().getProcessor().toString()

    if arch == u'x86':
        patcher = PatcherX86(current_program)
    elif arch == u'ARM':
        patcher = PatcherARM(current_program)
    elif arch == u'AARCH64':
        patcher = PatcherAArch64(current_program)
    else:
        logging.error('arch %s not supported' % arch)
        return patches

    for link in cfg_links:
        try:
            patch_info = patcher.do_patch(link)
            if patch_info is not None:
                patches.append(patch_info)
        except Exception as e:
            logging.warning('failed to patch %s' % str(link))
            logging.warning(e)

    logging.info('patches:\n%s' % '\n'.join('%s: %s' % (addr, binascii.hexlify(patch)) for addr, patch in patches))
    return patches

def save_patched(current_program, mem, patches):
    fpath = current_program.getExecutablePath()
    patched_pach = '%s-patched' % fpath

    file_data = None

    if os.path.exists(patched_pach):
        fpath = patched_pach

    with open(fpath, 'rb') as fin:
        file_data = bytearray(fin.read())

    for addr, patch_bytes in patches:
        offset = mem.getAddressSourceInfo(addr).getFileOffset()
        file_data[offset:offset+len(patch_bytes)] = patch_bytes

    with open(patched_pach, 'wb') as fout:
        fout.write(file_data)
        logging.info('save patched file as %s' % patched_pach)

if __name__ == '__main__':
    current_mem = currentProgram.getMemory()

    current_high_function = get_high_function(currentProgram, currentAddress)
    current_state_var = get_state_var(current_high_function, currentAddress)

    current_const_map = compute_const_map(current_high_function, current_state_var)
    current_state_var_defs = find_state_var_defs(current_mem, current_state_var)
    current_cfg_links = gen_cfg(current_const_map, current_state_var_defs)

    current_patches = patch_cfg(currentProgram, current_cfg_links)
    #save_patched(currentProgram, current_mem, current_patches)

```

`trace_function_call_parm_value.py`:

```py
# Trace function call parameters value using Ghidra P-Code.
# @author dark-lbp
# @category
# @keybinding
# @menupath
# @toolbar
from ghidra.app.decompiler import DecompInterface, DecompileOptions, DecompileResults
from ghidra.program.model.pcode import HighParam, PcodeOp, PcodeOpAST
from ghidra.program.model.address import GenericAddress
import logging
import struct


# debug = True
debug = False
process_is_64bit = False

# Init Default Logger
logger = logging.getLogger('Default_logger')
logger.setLevel(logging.INFO)
consolehandler = logging.StreamHandler()
console_format = logging.Formatter('[%(levelname)-8s][%(module)s.%(funcName)s] %(message)s')
consolehandler.setFormatter(console_format)
logger.addHandler(consolehandler)

if debug:
    logger.setLevel(logging.DEBUG)

endian = currentProgram.domainFile.getMetadata()[u'Endian']
if endian == u'Big':
    is_big_endian = True
else:
    is_big_endian = False

process_type = currentProgram.domainFile.getMetadata()[u'Processor']
if process_type.endswith(u'64'):
    process_is_64bit = True

decompile_function_cache = {}


def is_address_in_current_program(address):
    for block in currentProgram.memory.blocks:
        if address.offset in range(block.getStart().offset,block.getEnd().offset):
            return True
    return False


def get_signed_value(input_data):
    pack_format = ""
    if is_big_endian:
        pack_format += ">"
    else:
        pack_format += "<"

    if process_is_64bit:
        pack_format += "L"
    else:
        pack_format += "I"

    logger.debug("type(input_data): {}".format(type(input_data)))
    data = struct.pack(pack_format.upper(), input_data.offset)
    signed_data = struct.unpack(pack_format.lower(), data)[0]

    return signed_data


class FlowNode(object):
    def __init__(self, var_node, logger=logger):
        """ Used to get VarNode value

        :param var_node:
        """
        self.var_node = var_node
        if logger is None:
            self.logger = logging.getLogger('FlowNode_logger')
            self.logger.setLevel(logging.INFO)
            consolehandler = logging.StreamHandler()
            console_format = logging.Formatter('[%(levelname)-8s][%(module)s.%(funcName)s] %(message)s')
            consolehandler.setFormatter(console_format)
            self.logger.addHandler(consolehandler)
        else:
            self.logger = logger

    def get_value(self):
        """ Get VarNode value depend on it's type.

        :return:
        """
        if self.var_node.isAddress():
            self.logger.debug("Var_node isAddress")
            return self.var_node.getAddress()
        elif self.var_node.isConstant():
            self.logger.debug("Var_node isConstant")
            return self.var_node.getAddress()
        elif self.var_node.isUnique():
            self.logger.debug("Var_node isUnique")
            return calc_pcode_op(self.var_node.getDef())
        elif self.var_node.isRegister():
            self.logger.debug("Var_node isRegister")
            self.logger.debug(self.var_node.getDef())
            return calc_pcode_op(self.var_node.getDef())

        # https://github.com/NationalSecurityAgency/ghidra/issues/2283
        elif self.var_node.isPersistent():
            self.logger.debug("Var_node isPersistent")
            # TODO: Handler this later
            return
        elif self.var_node.isAddrTied():
            self.logger.debug("Var_node isAddrTied")
            return calc_pcode_op(self.var_node.getDef())
        elif self.var_node.isUnaffected():
            self.logger.debug("Var_node isUnaffected")
            # TODO: Handler this later
            return
        else:
            self.logger.debug("self.var_node: {}".format(self.var_node))


def calc_pcode_op(pcode):
    logger.debug("pcode: {}, type: {}".format(pcode, type(pcode)))
    if isinstance(pcode, PcodeOpAST):
        opcode = pcode.getOpcode()
        if opcode == PcodeOp.PTRSUB:
            logger.debug("PTRSUB")
            var_node_1 = FlowNode(pcode.getInput(0))
            var_node_2 = FlowNode(pcode.getInput(1))
            value_1 = var_node_1.get_value()
            value_2 = var_node_2.get_value()
            if isinstance(value_1, GenericAddress) and isinstance(value_2, GenericAddress):
                return value_1.offset + value_2.offset

            else:
                logger.debug("value_1: {}".format(value_1))
                logger.debug("value_2: {}".format(value_2))
                return None

        elif opcode == PcodeOp.CAST:
            logger.debug("CAST")
            var_node_1 = FlowNode(pcode.getInput(0))
            value_1 = var_node_1.get_value()
            if isinstance(value_1, GenericAddress):
                return value_1.offset

            else:
                return None

        elif opcode == PcodeOp.PTRADD:
            logger.debug("PTRADD")
            var_node_0 = FlowNode(pcode.getInput(0))
            var_node_1 = FlowNode(pcode.getInput(1))
            var_node_2 = FlowNode(pcode.getInput(2))
            try:
                value_0_point = var_node_0.get_value()
                logger.debug("value_0_point: {}".format(value_0_point))
                if not isinstance(value_0_point, GenericAddress):
                    return
                value_0 = toAddr(getInt(value_0_point))
                logger.debug("value_0: {}".format(value_0))
                logger.debug("type(value_0): {}".format(type(value_0)))
                value_1 = var_node_1.get_value()
                logger.debug("value_1: {}".format(value_1))
                logger.debug("type(value_1): {}".format(type(value_1)))
                if not isinstance(value_1, GenericAddress):
                    logger.debug("value_1 is not GenericAddress!")
                    return
                value_1 = get_signed_value(value_1.offset)
                # TODO: Handle input2 later
                value_2 = var_node_2.get_value()
                logger.debug("value_2: {}".format(value_2))
                logger.debug("type(value_2): {}".format(type(value_2)))
                if not isinstance(value_2, GenericAddress):
                    return
                output_value = value_0.add(value_1)
                logger.debug("output_value: {}".format(output_value))
                return output_value.offset

            except Exception as err:
                logger.debug("Got something wrong with calc PcodeOp.PTRADD : {}".format(err))
                return None

            except:
                logger.error("Got something wrong with calc PcodeOp.PTRADD ")
                return None

        elif opcode == PcodeOp.INDIRECT:
            logger.debug("INDIRECT")
            # TODO: Need find a way to handle INDIRECT operator.
            return None

        elif opcode == PcodeOp.MULTIEQUAL:
            logger.debug("MULTIEQUAL")
            # TODO: Add later
            return None

        elif opcode == PcodeOp.COPY:
            logger.debug("COPY")
            logger.debug("input_0: {}".format(pcode.getInput(0)))
            logger.debug("Output: {}".format(pcode.getOutput()))
            var_node_0 = FlowNode(pcode.getInput(0))
            value_0 = var_node_0.get_value()
            return value_0

    else:
        logger.debug("Found Unhandled opcode: {}".format(pcode))
        return None


class FunctionAnalyzer(object):

    def __init__(self, function, timeout=30, logger=logger):
        """

        :param function: Ghidra function object.
        :param timeout: timeout for decompile.
        :param logger: logger.
        """
        self.function = function
        self.timeout = timeout
        if logger is None:
            self.logger = logging.getLogger('target')
            self.logger.setLevel(logging.INFO)
            consolehandler = logging.StreamHandler()
            console_format = logging.Formatter('[%(levelname)-8s][%(module)s.%(funcName)s] %(message)s')
            consolehandler.setFormatter(console_format)
            self.logger.addHandler(consolehandler)
        else:
            self.logger = logger
        self.hfunction = None
        self.call_pcodes = {}
        self.prepare()

    def prepare(self):
        self.hfunction = self.get_hfunction()
        self.get_all_call_pcode()

    def get_hfunction(self):
        decomplib = DecompInterface()
        decomplib.openProgram(currentProgram)
        timeout = self.timeout
        dRes = decomplib.decompileFunction(self.function, timeout, getMonitor())
        hfunction = dRes.getHighFunction()
        return hfunction

    def get_function_pcode(self):
        if self.hfunction:
            try:
                ops = self.hfunction.getPcodeOps()

            except:
                return None

            return ops

    def print_pcodes(self):
        ops = self.get_function_pcode()
        while ops.hasNext():
            pcodeOpAST = ops.next()
            print(pcodeOpAST)
            opcode = pcodeOpAST.getOpcode()
            print("Opcode: {}".format(opcode))
            if opcode == PcodeOp.CALL:
                print("We found Call at 0x{}".format(pcodeOpAST.getInput(0).PCAddress))
                call_addr = pcodeOpAST.getInput(0).getAddress()
                print("Calling {}(0x{}) ".format(getFunctionAt(call_addr), call_addr))
                inputs = pcodeOpAST.getInputs()
                for i in range(len(inputs)):
                    parm = inputs[i]
                    print("parm{}: {}".format(i, parm))

    def find_perv_call_address(self, address):
        try:
            address_index = sorted(self.call_pcodes.keys()).index(address)

        except Exception as err:
            return

        if address_index > 0:
            perv_address = sorted(self.call_pcodes.keys())[address_index - 1]
            return self.call_pcodes[perv_address]

    def find_next_call_address(self, address):
        try:
            address_index = sorted(self.call_pcodes.keys()).index(address)

        except Exception as err:
            return

        if address_index < len(self.call_pcodes) - 1:
            next_address = sorted(self.call_pcodes.keys())[address_index + 1]
            return self.call_pcodes[next_address]

    def get_all_call_pcode(self):
        ops = self.get_function_pcode()
        if not ops:
            return

        while ops.hasNext():
            pcodeOpAST = ops.next()
            opcode = pcodeOpAST.getOpcode()
            if opcode in [PcodeOp.CALL, PcodeOp.CALLIND]:
                op_call_addr = pcodeOpAST.getInput(0).PCAddress
                self.call_pcodes[op_call_addr] = pcodeOpAST

    def get_call_pcode(self, call_address):
        # TODO: Check call_address is in function.
        if call_address in self.call_pcodes:
            return self.call_pcodes[call_address]

        return

    def analyze_call_parms(self, call_address):
        parms = {}
        # TODO: Check call_address is in function.
        pcodeOpAST = self.get_call_pcode(call_address)
        if pcodeOpAST:
            self.logger.debug("We found target call at 0x{} in function {}(0x{})".format(
                pcodeOpAST.getInput(0).PCAddress, self.function.name, hex(self.function.entryPoint.offset)))
            opcode = pcodeOpAST.getOpcode()
            if opcode == PcodeOp.CALL:
                target_call_addr = pcodeOpAST.getInput(0).getAddress()
                self.logger.debug("target_call_addr: {}".format(target_call_addr))

            elif opcode == PcodeOp.CALLIND:
                target_call_addr = FlowNode(pcodeOpAST.getInput(0)).get_value()
                self.logger.debug("target_call_addr: {}".format(target_call_addr))

            inputs = pcodeOpAST.getInputs()
            for i in range(len(inputs))[1:]:
                parm = inputs[i]
                self.logger.debug("parm{}: {}".format(i, parm))
                parm_node = FlowNode(parm)
                self.logger.debug("parm_node: {}".format(parm_node))
                parm_value = parm_node.get_value()
                self.logger.debug("parm_value: {}".format(parm_value))
                if isinstance(parm_value, GenericAddress):
                    parm_value = parm_value.offset
                parms[i] = parm_value
                if parm_value:
                    self.logger.debug("parm{} value: {}".format(i, hex(parm_value)))
            return parms
        return

    def get_call_parm_value(self, call_address):
        parms_value = {}
        if not call_address in self.call_pcodes:
            return
        parms = self.analyze_call_parms(call_address)

        if not parms:
            return

        for i in parms:
            self.logger.debug("parms{}: {}".format(i, parms[i]))
            parm_value = parms[i]
            self.logger.debug("parm_value: {}".format(parm_value))
            parm_data = None
            if parm_value:
                if is_address_in_current_program(toAddr(parm_value)):
                    if getDataAt(toAddr(parm_value)):
                        parm_data = getDataAt(toAddr(parm_value))
                    elif getInstructionAt(toAddr(parm_value)):
                        parm_data = getFunctionAt(toAddr(parm_value))

            parms_value["parm_{}".format(i)] = {'parm_value': parm_value,
                                                'parm_data': parm_data
                                                }

        return parms_value


def dump_call_parm_value(call_address, search_functions=None):
    """

    :param call_address:
    :param search_functions: function name list to search
    :return:
    """
    target_function = getFunctionAt(call_address)
    parms_data = {}
    if target_function:
        target_references = getReferencesTo(target_function.getEntryPoint())
        for target_reference in target_references:
            # Filter reference type
            reference_type = target_reference.getReferenceType()
            logger.debug("reference_type: {}".format(reference_type))
            logger.debug("isJump: {}".format(reference_type.isJump()))
            logger.debug("isCall: {}".format(reference_type.isCall()))
            if not reference_type.isCall():
                logger.debug("skip!")
                continue

            call_addr = target_reference.getFromAddress()
            logger.debug("call_addr: {}".format(call_addr))
            function = getFunctionContaining(call_addr)
            logger.debug("function: {}".format(function))
            if not function:
                continue

            # search only targeted function
            if search_functions:
                if function.name not in search_functions:
                    continue

            function_address = function.getEntryPoint()
            if function_address in decompile_function_cache:
                target = decompile_function_cache[function_address]
            else:
                target = FunctionAnalyzer(function=function)
                decompile_function_cache[function_address] = target

            parms_data[call_addr] = {
                'call_addr': call_addr,
                'refrence_function_addr': function.getEntryPoint(),
                'refrence_function_name': function.name,
                'parms': {}
            }

            parms_value = target.get_call_parm_value(call_address=call_addr)
            if not parms_value:
                continue

            trace_data = parms_data[call_addr]
            trace_data['parms'] = parms_value

        return parms_data


if __name__ == '__main__':
    # search_functions = ['FUN_8003028c']
    search_functions = None
    function_address = askLong("Input function address to trace", "Please input the function address")
    target_function = getFunctionAt(toAddr(function_address))
    if target_function:
        print("target_function: {}".format(target_function))
        parms_data = dump_call_parm_value(toAddr(function_address))
        # print("parms: {}".format(parms))
        for call_addr in parms_data:
            call_parms = parms_data[call_addr]
            parm_data_string = ""
            for parm in sorted(call_parms['parms'].keys()):
                parm_value = call_parms['parms'][parm]['parm_value']
                parm_data = call_parms['parms'][parm]['parm_data']
                # print("parm_data: {} type:{}".format(parm_data, type(parm_data)))
                # print("parm_value: {} type:{}".format(parm_value, type(parm_value)))
                if parm_value:
                    parm_data_string += "{}({:#010x}), ".format(parm_data, parm_value)
                else:
                    # Handle None type
                    parm_data_string += "{}({}), ".format(parm_data, parm_value)
            # remove end ', '
            parm_data_string = parm_data_string.strip(', ')
            # print("parm_data_string: {}".format(parm_data_string))
            print("{}({}) at {:#010x} in {}({:#010x})".format(target_function.name, parm_data_string,
                                                              call_parms['call_addr'].offset,
                                                              call_parms['refrence_function_name'],
                                                              call_parms['refrence_function_addr'].offset
                                                              ))
    else:
        print("Can't find function at address: {:#010x}".format(function_address))

```

`wr886nv7_rename_function_with_error_print.py`:

```py
# coding=utf-8
from ghidra.program.model.symbol.SourceType import USER_DEFINED
from galaxy_utility.function_analyzer import FunctionAnalyzer
from galaxy_utility.common import get_logger
import sys


"""
test_firmware download url.
http://download.tplinkcloud.com.cn/firmware/wr886nv7-ipv6-cn-up_2019-10-25_09.43.28_1572316888807.bin
"""

# debug = True
debug = False
process_is_64bit = False
logger = get_logger(__name__)

if debug:
    logger.setLevel(10)


if __name__ == '__main__':
    function_can_rename = {}
    # Function error print keywords.
    keywords = "Function %s assertion"

    # Get printf function object.
    printf_funciton = getFunction("printf")
    if not printf_funciton:
        sys.exit()

    # Get printf entry_point address object.
    printf_entry_point = printf_funciton.entryPoint

    # Get printf call references using getReferencesTo(printf_entry_point)
    printf_refs = getReferencesTo(printf_entry_point)
    for ref in printf_refs:
        # Only check printf call references.
        if ref.getReferenceType().isCall():
            ref_from_address = ref.getFromAddress()
            logger.debug("ref_from_address: {}".format(ref_from_address))
            ref_from_funciton = getFunctionContaining(ref_from_address)
            logger.debug("ref_from_funciton: {}".format(ref_from_funciton))
            if ref_from_funciton:
                # Only check unnamed function.
                if ref_from_funciton.name.startswith('FUN_'):
                    logger.debug(ref_from_funciton.name)
                    # Analyze function.
                    analyzer = FunctionAnalyzer(function=ref_from_funciton)
                    # Get printf parms value using PCode Trace.
                    printf_parms = analyzer.get_call_parm_value(ref_from_address)
                    logger.debug("printf_parms: {}".format(printf_parms))
                    try:
                        printf_parm1 = printf_parms["parm_1"]["parm_data"]
                        logger.debug("printf_parm1: {}".format(printf_parm1))
                        if not printf_parm1:
                            continue
                        printf_parm1_value = printf_parm1.getValue()

                        if "parm_2" not in printf_parms.keys():
                            continue
                        printf_parm2 = printf_parms["parm_2"]["parm_data"]
                        logger.debug("printf_parm2: {}".format(printf_parm2))
                        if not printf_parm2:
                            continue
                        printf_parm2_value = printf_parm2.getValue()

                        # Check is function error print.
                        if printf_parm1_value.startswith(keywords):
                            function_name = printf_parm2_value
                            logger.info("Rename {} to {}".format(ref_from_funciton.name, function_name))
                            ref_from_funciton.setName(function_name, USER_DEFINED)
                            if ref_from_funciton not in function_can_rename.keys():
                                function_can_rename[ref_from_funciton.name] = {
                                    "function_entry_point": ref_from_funciton.getEntryPoint(),
                                    "function_name": function_name
                                }

                    except Exception as err:
                        logger.error(err)

    for function_to_rename in function_can_rename:
        print("{}({}): {}".format(function_to_rename,
                                  function_can_rename[function_to_rename]['function_entry_point'],
                                  function_can_rename[function_to_rename]['function_name']
                                  ))
    print("Renamed {} functions using error print.".format(len(function_can_rename)))

```