Project Path: arc_rand-tech_pcm_lsh4letv

Source Tree:

```txt
arc_rand-tech_pcm_lsh4letv
├── LICENSE
├── README.md
├── docs
│   └── img
│       └── pcm.jpg
├── pyproject.toml
├── server.py
├── src
│   ├── backend
│   │   ├── report.py
│   │   └── templates
│   │       └── index.html
│   └── ida
│       └── mcp.py
└── uv.lock

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 rand0m
Copyright (c) 2025 Duncan Ogilvie

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# pcm
PCM (MCP but reversed), **MCP for reverse engineering**.

## Features

- Analysis
  - IDA
    - repl (IDAPython)
    - disassembly
    - decompilation
    - set types
    - ...
- Memory
  - Engagement reports
    ![reports](./docs/img/pcm.jpg)

<details>
<summary>Full list of features</summary>


```
- `get_function_by_name(name)`: Get a function by its name.
- `get_function_by_address(address)`: Get a function by its address.
- `get_current_address()`: Get the address currently selected by the user.
- `get_current_function()`: Get the function currently selected by the user.
- `list_functions()`: List all functions in the database.
- `decompile_function(address)`: Decompile a function at the given address using Hex-Rays.
- `disassemble_function(address)`: Get assembly code (address: instruction; comment) for a function.
- `get_entrypoints()`: Get all entrypoints in the binary.
- `get_function_blocks(address)`: Get all basic blocks in a function.
- `get_function_cfg(address)`: Get control flow graph for a function.
- `get_xrefs_to(address)`: Get all cross references to the given address.
- `get_xrefs_from(address)`: Get all cross references from the given address.
- `set_decompiler_comment(address, comment)`: Set a comment for a given address in the function pseudocode.
- `set_disassembly_comment(address, comment)`: Set a comment for a given address in the function disassembly.
- `rename_local_variable(function_address, old_name, new_name)`: Rename a local variable in a function.
- `rename_function(function_address, new_name)`: Rename a function.
- `set_function_prototype(function_address, prototype)`: Set a function's prototype.
- `set_local_variable_type(function_address, variable_name, new_type)`: Set a local variable's type.
- `create_structure_type(name, members, is_union)`: Create a new structure type.
- `get_metadata()`: Get metadata about the current IDB.
- `repl_idapython(content)`: Run IDAPython code and return the results with stdout/stderr captured.
- `add_note(title, content, address, tags)`: Add a new analysis note for the current binary.
- `update_note(note_id, title, content, tags)`: Update an existing note.
- `get_notes(file_md5, address, tag)`: Get analysis notes for a binary.
- `delete_note(note_id)`: Delete an analysis note.
```

</details>


## Installations

Prerequisites:
- [`uv`](https://github.com/astral-sh/uv)


1. Clone the repository
    ```
    git clone https://github.com/rand-tech/pcm
    ```
1. Add `pcm` to you mcp config
    example
    ```
    {
        "mcpServers": {
            "pcm": {
                "command": "uv",
                "args": [
                    "--directory",
                    "path_to/pcm",
                    "run",
                    "server.py"
                ]
            }
        }
    }
    ```
1. Use the MCP 


**Related projects**:

- <https://github.com/mrexodia/ida-pro-mcp> 
- <https://github.com/MxIris-Reverse-Engineering/ida-mcp-server>

**Attribution**:
This project is based on [IDA Pro MCP](https://github.com/mrexodia/ida-pro-mcp) by Duncan Ogilvie (@mrexodia). Thank you

**License**:
This project is licensed under the MIT License - see the LICENSE file for details. The original code is also licensed under the MIT License.

```

`pyproject.toml`:

```toml
[project]
name = "pcm"
version = "0.1.0"
description = "MCP for reverse engineering"
readme = "README.md"
requires-python = ">=3.13"
dependencies = [
    "fastmcp>=0.4.1",
    "flask>=3.1.0",
]

[project.urls]
Repository = "https://github.com/rand-tech/pcm"
Issues = "https://github.com/rand-tech/pcm/issues"

[build-system]
requires = ["setuptools"]
build-backend = "setuptools.build_meta"

[project.scripts]
pcm = "pcm.server:main"

```

`server.py`:

```py
import os
import sys
import ast
import json
import traceback
import shutil
import http.client
import signal
import asyncio
from typing import List, Optional, Dict, Any
from fastmcp import FastMCP

# The log_level is necessary for Cline to work: https://github.com/jlowin/fastmcp/issues/81
mcp = FastMCP("IDA Pro", log_level="ERROR")

jsonrpc_request_id = 1


def handle_shutdown(sig, frame):
    print("[*] Shutting down MCP server gracefully...")
    if hasattr(handle_shutdown, "_is_shutting_down") and handle_shutdown._is_shutting_down:
        return
    handle_shutdown._is_shutting_down = True

    if hasattr(asyncio, "get_running_loop"):
        try:
            loop = asyncio.get_running_loop()
            for task in asyncio.all_tasks(loop):
                task.cancel()
            print("[*] All tasks cancelled, shutdown complete.")
        except RuntimeError:
            pass
    import os
    os._exit(0)


def make_jsonrpc_request(method: str, *args):
    """Make a JSON-RPC request to the IDA plugin"""
    global jsonrpc_request_id
    conn = http.client.HTTPConnection("localhost", 13337)
    request = {
        "jsonrpc": "2.0",
        "method": method,
        "params": list(args),
        "id": jsonrpc_request_id,
    }
    jsonrpc_request_id += 1

    try:
        conn.request("POST", "/mcp", json.dumps(request), {"Content-Type": "application/json"})
        response = conn.getresponse()
        data = json.loads(response.read().decode())

        if "error" in data:
            error = data["error"]
            error_message = f"JSON-RPC error {error['code']}: {error['message']}"
            if "data" in error and error["data"]:
                error_message += f"\nDetails: {error['data']}"
            raise Exception(error_message)

        return data.get("result")
    except Exception as e:
        traceback.print_exc()
        raise
    finally:
        conn.close()


class MCPVisitor(ast.NodeVisitor):
    def __init__(self):
        self.types: dict[str, ast.ClassDef] = {}
        self.functions: dict[str, ast.FunctionDef] = {}
        self.descriptions: dict[str, str] = {}

    def visit_FunctionDef(self, node):
        for decorator in node.decorator_list:
            if isinstance(decorator, ast.Name):
                if decorator.id == "jsonrpc":
                    for i, arg in enumerate(node.args.args):
                        arg_name = arg.arg
                        arg_type = arg.annotation
                        if arg_type is None:
                            raise Exception(f"Missing argument type for {node.name}.{arg_name}")
                        if isinstance(arg_type, ast.Subscript):
                            assert isinstance(arg_type.value, ast.Name)
                            assert arg_type.value.id == "Annotated"
                            assert isinstance(arg_type.slice, ast.Tuple)
                            assert len(arg_type.slice.elts) == 2
                            annot_type = arg_type.slice.elts[0]
                            annot_description = arg_type.slice.elts[1]
                            assert isinstance(annot_description, ast.Constant)
                            node.args.args[i].annotation = ast.Subscript(
                                value=ast.Name(id="Annotated", ctx=ast.Load()),
                                slice=ast.Tuple(
                                    elts=[annot_type, ast.Call(func=ast.Name(id="Field", ctx=ast.Load()), args=[], keywords=[ast.keyword(arg="description", value=annot_description)])], ctx=ast.Load()
                                ),
                                ctx=ast.Load(),
                            )
                        elif isinstance(arg_type, ast.Name):
                            pass
                        else:
                            raise Exception(f"Unexpected type annotation for {node.name}.{arg_name} -> {type(arg_type)}")

                    body_comment = node.body[0]
                    if isinstance(body_comment, ast.Expr) and isinstance(body_comment.value, ast.Constant):
                        new_body = [body_comment]
                        self.descriptions[node.name] = body_comment.value.value
                    else:
                        new_body = []

                    call_args = [ast.Constant(value=node.name)]
                    for arg in node.args.args:
                        call_args.append(ast.Name(id=arg.arg, ctx=ast.Load()))
                    new_body.append(ast.Return(value=ast.Call(func=ast.Name(id="make_jsonrpc_request", ctx=ast.Load()), args=call_args, keywords=[])))
                    decorator_list = [ast.Call(func=ast.Attribute(value=ast.Name(id="mcp", ctx=ast.Load()), attr="tool", ctx=ast.Load()), args=[], keywords=[])]
                    node_nobody = ast.FunctionDef(node.name, node.args, new_body, decorator_list, node.returns, node.type_comment, lineno=node.lineno, col_offset=node.col_offset)
                    self.functions[node.name] = node_nobody

    def visit_ClassDef(self, node):
        for base in node.bases:
            if isinstance(base, ast.Name):
                if base.id == "TypedDict":
                    self.types[node.name] = node


SCRIPT_DIR = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'src')
IDA_PLUGIN_PY = os.path.join(SCRIPT_DIR, 'ida', "mcp.py")
GENERATED_PY = os.path.join(SCRIPT_DIR, "server_generated.py")

# NOTE: This is in the global scope on purpose
with open(IDA_PLUGIN_PY, "r") as f:
    code = f.read()
module = ast.parse(code, IDA_PLUGIN_PY)
visitor = MCPVisitor()
visitor.visit(module)
code = """# NOTE: This file has been automatically generated, do not modify!
from typing import Annotated, Optional, TypedDict, List
from pydantic import Field

"""
for type in visitor.types.values():
    code += ast.unparse(type)
    code += "\n\n"
for function in visitor.functions.values():
    code += ast.unparse(function)
    code += "\n\n"
with open(GENERATED_PY, "w") as f:
    f.write(code)
exec(compile(code, GENERATED_PY, "exec"))


def main():
    import argparse
    parser = argparse.ArgumentParser(description="MCP server for IDA Pro")
    parser.add_argument("--generate-only", action="store_true", help="Generate the IDA plugin code and exit")
    parser.add_argument("--install-plugin", action="store_true", help="Install the IDA plugin")
    args = parser.parse_args()

    if args.generate_only:
        print(f"[*] Generating IDA plugin code...", file=sys.stderr)
        for function in visitor.functions.values():
            signature = function.name + "("
            for i, arg in enumerate(function.args.args):
                if i > 0:
                    signature += ", "
                signature += arg.arg
            signature += ")"
            description = visitor.descriptions.get(function.name, "<no description>")
            if description[-1] != ".":
                description += "."
            print(f"- `{signature}`: {description}")
        sys.exit(0)
    elif args.install_plugin:
        print(f"[*] Installing IDA plugin...", file=sys.stderr)
        if sys.platform == "win32":
            ida_plugin_folder = os.path.join(os.getenv("APPDATA"), "Hex-Rays", "IDA Pro", "plugins")
        else:
            ida_plugin_folder = os.path.join(os.path.expanduser("~"), ".idapro", "plugins")
        plugin_destination = os.path.join(ida_plugin_folder, "pcm.py")
        if input(f"Installing IDA plugin to {plugin_destination}, proceed? [Y/n] ").lower() == "n":
            sys.exit(1)
        if not os.path.exists(ida_plugin_folder):
            os.makedirs(ida_plugin_folder)
        shutil.copy(IDA_PLUGIN_PY, plugin_destination)
        print(f"Installed plugin: {plugin_destination}")
        sys.exit(0)
    signal.signal(signal.SIGINT, handle_shutdown)
    signal.signal(signal.SIGTERM, handle_shutdown)

    print('[*] Starting MCP server...')
    try:
        mcp.run(transport="stdio")
    except KeyboardInterrupt:
        print("[*] Received keyboard interrupt, shutting down...")
    except Exception as e:
        print(f"[!] Error: {e}")
        traceback.print_exc()
    finally:
        print("[*] MCP server stopped.")


if __name__ == "__main__":
    main()

```

`src/backend/report.py`:

```py
import datetime
import os
import sqlite3
from pathlib import Path
from typing import Any, Dict, List, Optional

from flask import Flask, abort, jsonify, render_template, request

app = Flask(__name__)


def get_db_path():
    user_dir = Path.home()
    if os.name == 'nt':  # Windows
        db_path = user_dir / "AppData" / "Local" / "IDA_MCP"
    else:  # Linux/Mac
        db_path = user_dir / ".ida_mcp"

    db_path.mkdir(exist_ok=True)
    db_file = db_path / "analysis_notes.db"
    return str(db_file)


NOTES_DB = get_db_path()


def dict_factory(cursor, row):
    """Convert sqlite row to dictionary"""
    d = {}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d


def get_connection():
    """Get database connection with row factory set to return dictionaries"""
    conn = sqlite3.connect(NOTES_DB)
    conn.row_factory = dict_factory
    return conn


@app.route('/')
def index():
    """Main page showing list of analyzed files"""
    return render_template('index.html')


@app.route('/api/files')
def list_files():
    """API endpoint to get list of all analyzed files"""
    try:
        conn = get_connection()
        cursor = conn.cursor()

        cursor.execute(
            """
            SELECT f.*,
                   COUNT(n.id) as note_count,
                   MAX(n.timestamp) as last_note_timestamp
            FROM files f
            LEFT JOIN notes n ON f.md5 = n.file_md5
            GROUP BY f.md5
            ORDER BY f.last_accessed DESC
        """
        )

        files = cursor.fetchall()

        for file in files:
            if file['last_accessed']:
                file['last_accessed_formatted'] = datetime.datetime.fromtimestamp(file['last_accessed']).strftime('%Y-%m-%d %H:%M:%S')
            if file['last_note_timestamp']:
                file['last_note_formatted'] = datetime.datetime.fromtimestamp(file['last_note_timestamp']).strftime('%Y-%m-%d %H:%M:%S')

        conn.close()
        return jsonify(files)
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route('/api/files/<md5>/notes')
def get_file_notes(md5):
    """API endpoint to get notes for a specific file"""
    try:
        conn = get_connection()
        cursor = conn.cursor()

        cursor.execute("SELECT * FROM files WHERE md5 = ?", (md5,))
        file_info = cursor.fetchone()

        if not file_info:
            conn.close()
            return jsonify({"error": "File not found"}), 404

        # Get notes
        cursor.execute(
            """
            SELECT * FROM notes
            WHERE file_md5 = ?
            ORDER BY timestamp DESC
        """,
            (md5,),
        )

        notes = cursor.fetchall()

        # Format timestamps and parse tags
        for note in notes:
            note['timestamp_formatted'] = datetime.datetime.fromtimestamp(note['timestamp']).strftime('%Y-%m-%d %H:%M:%S')
            if note['tags']:
                note['tags_list'] = [tag.strip() for tag in note['tags'].split(',')]
            else:
                note['tags_list'] = []

        conn.close()
        return jsonify({"file": file_info, "notes": notes})
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route('/api/notes/<int:note_id>')
def get_note_detail(note_id):
    """API endpoint to get details for a specific note"""
    try:
        conn = get_connection()
        cursor = conn.cursor()

        cursor.execute(
            """
            SELECT n.*, f.name as file_name, f.path as file_path
            FROM notes n
            JOIN files f ON n.file_md5 = f.md5
            WHERE n.id = ?
        """,
            (note_id,),
        )

        note = cursor.fetchone()

        if not note:
            conn.close()
            return jsonify({"error": "Note not found"}), 404

        note['timestamp_formatted'] = datetime.datetime.fromtimestamp(note['timestamp']).strftime('%Y-%m-%d %H:%M:%S')
        if note['tags']:
            note['tags_list'] = [tag.strip() for tag in note['tags'].split(',')]
        else:
            note['tags_list'] = []

        conn.close()
        return jsonify(note)
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route('/api/tags')
def get_all_tags():
    """API endpoint to get all unique tags used across notes"""
    try:
        conn = get_connection()
        cursor = conn.cursor()

        cursor.execute("SELECT tags FROM notes WHERE tags IS NOT NULL AND tags != ''")
        tag_rows = cursor.fetchall()

        # Process tags
        all_tags = set()
        for row in tag_rows:
            tags = row['tags'].split(',')
            for tag in tags:
                tag = tag.strip()
                if tag:
                    all_tags.add(tag)

        conn.close()
        return jsonify(sorted(list(all_tags)))
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route('/api/search')
def search_notes():
    """API endpoint to search notes by query term and/or tag"""
    try:
        query = request.args.get('q', '')
        tag = request.args.get('tag', '')

        conn = get_connection()
        cursor = conn.cursor()

        params = []
        sql = """
            SELECT n.*, f.name as file_name
            FROM notes n
            JOIN files f ON n.file_md5 = f.md5
            WHERE 1=1
        """

        if query:
            sql += " AND (n.title LIKE ? OR n.content LIKE ?)"
            params.extend([f'%{query}%', f'%{query}%'])

        if tag:
            sql += " AND n.tags LIKE ?"
            params.append(f'%{tag}%')

        sql += " ORDER BY n.timestamp DESC"

        cursor.execute(sql, params)
        notes = cursor.fetchall()

        # Format timestamps and parse tags
        for note in notes:
            note['timestamp_formatted'] = datetime.datetime.fromtimestamp(note['timestamp']).strftime('%Y-%m-%d %H:%M:%S')
            if note['tags']:
                note['tags_list'] = [tag.strip() for tag in note['tags'].split(',')]
            else:
                note['tags_list'] = []

        conn.close()
        return jsonify(notes)
    except Exception as e:
        return jsonify({"error": str(e)}), 500


if __name__ == '__main__':
    print(f"Database path: {NOTES_DB}")

    try:
        conn = get_connection()
        cursor = conn.cursor()

        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND (name='notes' OR name='files')")
        tables = cursor.fetchall()
        table_names = [t['name'] for t in tables]

        if 'notes' not in table_names or 'files' not in table_names:
            print("Warning: Database exists but required tables are missing.")
            print("Make sure the IDA plugin has been run at least once to initialize the database.")
        else:
            # Get some basic stats
            cursor.execute("SELECT COUNT(*) as count FROM files")
            file_count = cursor.fetchone()['count']

            cursor.execute("SELECT COUNT(*) as count FROM notes")
            note_count = cursor.fetchone()['count']

            print(f"Database contains {file_count} files and {note_count} notes.")

        conn.close()
    except Exception as e:
        print(f"Warning: Could not verify database: {str(e)}")
        print("Database will be created if it doesn't exist when you add your first note.")

    # Run the Flask app with debug mode enabled
    print("Starting web server...")
    PORT = 8000
    print(f"Open http://localhost:{PORT} in your web browser to view the reports")
    app.run(debug=True, host='localhost', port=PORT)

```

`src/backend/templates/index.html`:

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Engagement Report</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css">
    <style>
        .file-item:hover {
            background-color: #f8f9fa;
            cursor: pointer;
        }

        .note-item:hover {
            background-color: #f8f9fa;
            cursor: pointer;
        }

        .tag-badge {
            margin-right: 5px;
            cursor: pointer;
        }

        .content-preview {
            max-height: 100px;
            overflow: hidden;
        }

        .address-link {
            color: #007bff;
            cursor: pointer;
            text-decoration: underline;
        }

        .loading-spinner {
            display: none;
            text-align: center;
            padding: 20px;
        }

        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .side-modal {
            position: fixed;
            top: 0;
            right: -100%;
            width: clamp(20rem, 45%, 50rem);
            height: 100vh;
            background-color: white;
            box-shadow: -0.3rem 0 1rem rgba(0, 0, 0, 0.03);
            z-index: 1050;
            overflow-y: auto;
            transition: right 0.1s ease-in-out;
        }


        @media (max-width: 768px) {
            .side-modal {
                width: 80%;
            }
        }

        .side-modal.active {
            right: 0;
        }

        .side-modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1040;
            display: none;
        }

        .side-modal-header {
            position: sticky;
            top: 0;
            background-color: white;
            border-bottom: 1px solid #dee2e6;
            padding: 1rem;
            z-index: 1;
        }

        .side-modal-body {
            padding: 1rem;
        }

        .side-modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            cursor: pointer;
            font-size: 1.5rem;
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" id="brandLink" href="#">Engagement Report</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link active" id="filesTab" href="#">Files</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="searchTab" href="#">Search</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" id="tagsTab" href="#">Tags</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <!-- Files View -->
        <div id="filesView">
            <h2>Analyzed Files</h2>
            <div class="loading-spinner" id="filesSpinner">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p>Loading files...</p>
            </div>
            <div class="list-group mt-3" id="filesList"></div>
        </div>

        <!-- File Detail View -->
        <div id="fileDetailView" style="display: none;">
            <div class="d-flex justify-content-between align-items-center">
                <h2><span id="fileName"></span></h2>
                <button class="btn btn-secondary" id="backToFiles">
                    <i class="bi bi-arrow-left"></i> Back to Files
                </button>
            </div>
            <div class="card mb-3">
                <div class="card-body">
                    <h5 class="card-title">File Information</h5>
                    <div class="row">
                        <div class="col-md-6">
                            <p><strong>Path:</strong> <span id="filePath"></span></p>
                            <p><strong>MD5:</strong> <span id="fileMD5"></span></p>
                            <p><strong>SHA256:</strong> <span id="fileSHA256"></span></p>
                        </div>
                        <div class="col-md-6">
                            <p><strong>Size:</strong> <span id="fileSize"></span></p>
                            <p><strong>Base Address:</strong> <span id="fileBaseAddr"></span></p>
                            <p><strong>Last Accessed:</strong> <span id="fileLastAccessed"></span></p>
                        </div>
                    </div>
                </div>
            </div>
            <h3>Notes</h3>
            <div class="loading-spinner" id="notesSpinner">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p>Loading notes...</p>
            </div>
            <div class="list-group" id="notesList"></div>
        </div>

        <!-- Search View -->
        <div id="searchView" style="display: none;">
            <h2>Search Notes</h2>
            <div class="row mb-4">
                <div class="col-md-8">
                    <div class="input-group">
                        <input type="text" class="form-control" id="searchInput"
                            placeholder="Search by title or content...">
                        <button class="btn btn-primary" id="searchButton">
                            <i class="bi bi-search"></i> Search
                        </button>
                    </div>
                </div>
                <div class="col-md-4">
                    <select class="form-select" id="tagFilter">
                        <option value="">All Tags</option>
                    </select>
                </div>
            </div>
            <div class="loading-spinner" id="searchSpinner">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p>Searching...</p>
            </div>
            <div id="searchResults"></div>
        </div>

        <!-- Tags View -->
        <div id="tagsView" style="display: none;">
            <h2>All Tags</h2>
            <div class="loading-spinner" id="tagsSpinner">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p>Loading tags...</p>
            </div>
            <div class="row" id="tagsCloud"></div>
        </div>
    </div>

    <!-- Right Side Modal for Note Details -->
    <div class="side-modal-backdrop" id="sideModalBackdrop"></div>
    <div class="side-modal" id="sideNoteDetail">
        <div class="side-modal-header">
            <h4 id="sideNoteTitle">Note Title</h4>
            <span class="side-modal-close" id="sideModalClose"><i class="bi bi-x"></i></span>
        </div>
        <div class="side-modal-body">
            <div class="mb-3" id="sideNoteAddressContainer">
                <strong>Address:</strong> <span id="sideNoteAddress" class="address-link"></span>
            </div>
            <div class="mb-3">
                <strong>Created:</strong> <span id="sideNoteTimestamp"></span>
            </div>
            <div class="mb-3" id="sideNoteTagsContainer">
                <strong>Tags:</strong>
                <div id="sideNoteTags" class="d-inline"></div>
            </div>
            <hr>
            <div class="mb-3">
                <div id="sideNoteContent"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        // Utility functions
        function formatAddress (address) {
            if (!address) return null;
            if (address.startsWith('0x')) {
                const addrNum = parseInt(address, 16);
                return `0x${addrNum.toString(16).toUpperCase().padStart(8, '0')}`;
            }
            return address;
        }

        function formatSize (size) {
            if (!size) return 'Unknown';
            if (size.startsWith('0x')) {
                size = parseInt(size, 16);
            } else {
                size = parseInt(size);
            }

            const units = ['B', 'KB', 'MB', 'GB'];
            let unitIndex = 0;

            while (size >= 1024 && unitIndex < units.length - 1) {
                size /= 1024;
                unitIndex++;
            }

            return `${size.toFixed(2)} ${units[unitIndex]}`;
        }

        // DOM Elements
        const views = {
            files: document.getElementById('filesView'),
            fileDetail: document.getElementById('fileDetailView'),
            search: document.getElementById('searchView'),
            tags: document.getElementById('tagsView')
        };

        const tabs = {
            files: document.getElementById('filesTab'),
            search: document.getElementById('searchTab'),
            tags: document.getElementById('tagsTab')
        };

        const spinners = {
            files: document.getElementById('filesSpinner'),
            notes: document.getElementById('notesSpinner'),
            search: document.getElementById('searchSpinner'),
            tags: document.getElementById('tagsSpinner')
        };

        const filesList = document.getElementById('filesList');
        const notesList = document.getElementById('notesList');
        const searchResults = document.getElementById('searchResults');
        const tagsCloud = document.getElementById('tagsCloud');
        const tagFilter = document.getElementById('tagFilter');
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const backToFilesButton = document.getElementById('backToFiles');
        const brandLink = document.getElementById('brandLink');

        // Side Modal Elements
        const sideModal = document.getElementById('sideNoteDetail');
        const sideModalBackdrop = document.getElementById('sideModalBackdrop');
        const sideModalClose = document.getElementById('sideModalClose');

        // Current state
        let currentState = {
            currentView: 'files',
            currentFile: null,
            allTags: []
        };

        // URL handling
        function updateURL (view, params = {}) {
            const url = new URL(window.location);
            url.hash = view;

            // Clear existing query parameters
            url.search = '';

            // Add new query parameters
            Object.entries(params).forEach(([key, value]) => {
                if (value) {
                    url.searchParams.set(key, value);
                }
            });

            // Update browser history without reloading the page
            window.history.pushState({}, '', url);

            // Update page title based on view
            updatePageTitle(view, params);
        }

        // Update page title based on current view
        function updatePageTitle (view, params = {}) {
            let title = 'Engagement Report';

            switch (view) {
                case 'files':
                    title = 'Files | Engagement Report';
                    break;
                case 'file':
                    if (params.fileName) {
                        title = `${params.fileName} | Engagement Report`;
                    } else {
                        title = 'File Details | Engagement Report';
                    }
                    break;
                case 'search':
                    if (params.q) {
                        title = `Search: ${params.q} | Engagement Report`;
                    } else if (params.tag) {
                        title = `Tag: ${params.tag} | Engagement Report`;
                    } else {
                        title = 'Search | Engagement Report';
                    }
                    break;
                case 'tags':
                    title = 'Tags | Engagement Report';
                    break;
            }

            document.title = title;
        }

        // Handle browser back/forward buttons
        window.addEventListener('popstate', function (event) {
            handleURLChange();
        });

        // Parse and handle URL on page load and when it changes
        function handleURLChange () {
            const url = new URL(window.location);
            const hash = url.hash.substring(1) || 'files'; // Default to files if no hash
            const params = Object.fromEntries(url.searchParams.entries());

            // Handle different views based on hash
            switch (hash) {
                case 'file':
                    if (params.md5) {
                        loadFileDetail(params.md5);
                    } else {
                        switchView('files');
                    }
                    break;
                case 'search':
                    switchView('search');
                    if (params.q || params.tag) {
                        if (params.q) searchInput.value = params.q;
                        if (params.tag) tagFilter.value = params.tag;
                        searchNotes();
                    }
                    break;
                case 'tags':
                    switchView('tags');
                    break;
                case 'files':
                default:
                    switchView('files');
                    break;
            }
        }

        // Load files list
        function loadFiles () {
            spinners.files.style.display = 'block';
            filesList.innerHTML = '';

            fetch('/api/files')
                .then(response => response.json())
                .then(files => {
                    if (files.length === 0) {
                        filesList.innerHTML = '<div class="alert alert-info">No files found in the database.</div>';
                    } else {
                        files.forEach(file => {
                            const fileItem = document.createElement('div');
                            fileItem.className = 'list-group-item file-item';
                            fileItem.innerHTML = `
                                <div class="d-flex w-100 justify-content-between">
                                    <h5 class="mb-1">${file.name}</h5>
                                    <small>${file.note_count} notes</small>
                                </div>
                                <p class="mb-1">${file.path}</p>
                                <div class="d-flex justify-content-between">
                                    <small>MD5: ${file.md5}</small>
                                    <small>Last accessed: ${file.last_accessed_formatted || 'Unknown'}</small>
                                </div>
                            `;
                            fileItem.addEventListener('click', () => loadFileDetail(file.md5));
                            filesList.appendChild(fileItem);
                        });
                    }
                    spinners.files.style.display = 'none';
                })
                .catch(error => {
                    console.error('Error loading files:', error);
                    filesList.innerHTML = `<div class="alert alert-danger">Error loading files: ${error.message}</div>`;
                    spinners.files.style.display = 'none';
                });
        }

        // Load file detail and its notes
        function loadFileDetail (md5) {
            currentState.currentFile = md5;
            views.files.style.display = 'none';
            views.fileDetail.style.display = 'block';
            notesList.innerHTML = '';
            spinners.notes.style.display = 'block';

            fetch(`/api/files/${md5}/notes`)
                .then(response => response.json())
                .then(data => {
                    // Update file info
                    const file = data.file;
                    document.getElementById('fileName').textContent = file.name;
                    document.getElementById('filePath').textContent = file.path;
                    document.getElementById('fileMD5').textContent = file.md5;
                    document.getElementById('fileSHA256').textContent = file.sha256;
                    document.getElementById('fileSize').textContent = formatSize(file.size);
                    document.getElementById('fileBaseAddr').textContent = file.base_addr;
                    document.getElementById('fileLastAccessed').textContent = file.last_accessed_formatted || 'Unknown';

                    // Update URL and title
                    updateURL('file', { md5: file.md5, fileName: file.name });

                    // Display notes
                    if (data.notes.length === 0) {
                        notesList.innerHTML = '<div class="alert alert-info">No notes found for this file.</div>';
                    } else {
                        data.notes.forEach(note => {
                            const noteItem = document.createElement('div');
                            noteItem.className = 'list-group-item note-item';

                            let tagsHtml = '';
                            if (note.tags_list && note.tags_list.length > 0) {
                                tagsHtml = note.tags_list.map(tag =>
                                    `<span class="badge bg-secondary tag-badge">${tag}</span>`
                                ).join(' ');
                            }

                            noteItem.innerHTML = `
                                <div class="d-flex w-100 justify-content-between">
                                    <h5 class="mb-1">${note.title}</h5>
                                    <small>${note.timestamp_formatted}</small>
                                </div>
                                ${note.address ? `<p class="mb-1"><strong>Address:</strong> <span class="address-link">${formatAddress(note.address)}</span></p>` : ''}
                                <div class="content-preview mb-2">${note.content.substring(0, 200)}${note.content.length > 200 ? '...' : ''}</div>
                                <div>${tagsHtml}</div>
                            `;

                            noteItem.addEventListener('click', () => showSideNoteDetail(note.id));
                            notesList.appendChild(noteItem);
                        });
                    }
                    spinners.notes.style.display = 'none';
                })
                .catch(error => {
                    console.error('Error loading file detail:', error);
                    notesList.innerHTML = `<div class="alert alert-danger">Error loading notes: ${error.message}</div>`;
                    spinners.notes.style.display = 'none';
                });
        }

        // Show note detail in side modal
        function showSideNoteDetail (noteId) {
            fetch(`/api/notes/${noteId}`)
                .then(response => response.json())
                .then(note => {
                    document.getElementById('sideNoteTitle').textContent = note.title;

                    const addressContainer = document.getElementById('sideNoteAddressContainer');
                    if (note.address) {
                        addressContainer.style.display = 'block';
                        document.getElementById('sideNoteAddress').textContent = formatAddress(note.address);
                    } else {
                        addressContainer.style.display = 'none';
                    }

                    document.getElementById('sideNoteTimestamp').textContent = note.timestamp_formatted;

                    const tagsContainer = document.getElementById('sideNoteTagsContainer');
                    const tagsElement = document.getElementById('sideNoteTags');

                    if (note.tags_list && note.tags_list.length > 0) {
                        tagsContainer.style.display = 'block';
                        tagsElement.innerHTML = note.tags_list.map(tag =>
                            `<span class="badge bg-secondary tag-badge">${tag}</span>`
                        ).join(' ');
                    } else {
                        tagsContainer.style.display = 'none';
                    }

                    // Use marked.js to render markdown content
                    document.getElementById('sideNoteContent').innerHTML = marked.parse(note.content);

                    // Show the side modal
                    sideModal.classList.add('active');
                    sideModalBackdrop.style.display = 'block';
                    document.body.style.overflow = 'hidden'; // Prevent scrolling of the main content
                })
                .catch(error => {
                    console.error('Error loading note detail:', error);
                    alert(`Error loading note: ${error.message}`);
                });
        }

        // Close side modal
        function closeSideModal () {
            sideModal.classList.remove('active');
            sideModalBackdrop.style.display = 'none';
            document.body.style.overflow = ''; // Restore scrolling
        }

        // Load all tags
        function loadTags () {
            spinners.tags.style.display = 'block';
            tagsCloud.innerHTML = '';

            fetch('/api/tags')
                .then(response => response.json())
                .then(tags => {
                    currentState.allTags = tags;
                    updateTagFilter();

                    if (tags.length === 0) {
                        tagsCloud.innerHTML = '<div class="alert alert-info">No tags found in the database.</div>';
                    } else {
                        tags.forEach(tag => {
                            const tagCol = document.createElement('div');
                            tagCol.className = 'col-auto mb-2';

                            const tagBadge = document.createElement('span');
                            tagBadge.className = 'badge bg-primary p-2 fs-5 tag-badge';
                            tagBadge.textContent = tag;
                            tagBadge.addEventListener('click', () => {
                                searchByTag(tag);
                            });

                            tagCol.appendChild(tagBadge);
                            tagsCloud.appendChild(tagCol);
                        });
                    }
                    spinners.tags.style.display = 'none';
                })
                .catch(error => {
                    console.error('Error loading tags:', error);
                    tagsCloud.innerHTML = `<div class="alert alert-danger">Error loading tags: ${error.message}</div>`;
                    spinners.tags.style.display = 'none';
                });
        }

        // Update tag filter dropdown
        function updateTagFilter () {
            tagFilter.innerHTML = '<option value="">All Tags</option>';

            currentState.allTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                tagFilter.appendChild(option);
            });
        }

        // Search notes
        function searchNotes () {
            const query = searchInput.value.trim();
            const tag = tagFilter.value;

            if (!query && !tag) {
                searchResults.innerHTML = '<div class="alert alert-info">Please enter a search term or select a tag.</div>';
                return;
            }

            spinners.search.style.display = 'block';
            searchResults.innerHTML = '';

            // Update URL with search parameters
            updateURL('search', { q: query, tag: tag });

            fetch(`/api/search?q=${encodeURIComponent(query)}&tag=${encodeURIComponent(tag)}`)
                .then(response => response.json())
                .then(notes => {
                    if (notes.length === 0) {
                        searchResults.innerHTML = '<div class="alert alert-info">No matching notes found.</div>';
                    } else {
                        const resultsList = document.createElement('div');
                        resultsList.className = 'list-group mt-3';

                        notes.forEach(note => {
                            const noteItem = document.createElement('div');
                            noteItem.className = 'list-group-item note-item';

                            let tagsHtml = '';
                            if (note.tags_list && note.tags_list.length > 0) {
                                tagsHtml = note.tags_list.map(tag =>
                                    `<span class="badge bg-secondary tag-badge">${tag}</span>`
                                ).join(' ');
                            }

                            noteItem.innerHTML = `
                                <div class="d-flex w-100 justify-content-between">
                                    <h5 class="mb-1">${note.title}</h5>
                                    <small>${note.timestamp_formatted}</small>
                                </div>
                                <p class="mb-1"><strong>File:</strong> ${note.file_name}</p>
                                ${note.address ? `<p class="mb-1"><strong>Address:</strong> <span class="address-link">${formatAddress(note.address)}</span></p>` : ''}
                                <div class="content-preview mb-2">${note.content.substring(0, 200)}${note.content.length > 200 ? '...' : ''}</div>
                                <div>${tagsHtml}</div>
                            `;

                            noteItem.addEventListener('click', () => showSideNoteDetail(note.id));
                            resultsList.appendChild(noteItem);
                        });

                        searchResults.appendChild(resultsList);
                    }
                    spinners.search.style.display = 'none';
                })
                .catch(error => {
                    console.error('Error searching notes:', error);
                    searchResults.innerHTML = `<div class="alert alert-danger">Error searching notes: ${error.message}</div>`;
                    spinners.search.style.display = 'none';
                });
        }

        // Search by tag
        function searchByTag (tag) {
            // Switch to search view
            switchView('search');

            // Set tag in filter
            tagFilter.value = tag;
            searchInput.value = '';

            // Perform search
            searchNotes();
        }

        // Switch view
        function switchView (viewName) {
            // Hide all views
            Object.values(views).forEach(view => {
                view.style.display = 'none';
            });

            // Remove active class from all tabs
            Object.values(tabs).forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected view and set active tab
            views[viewName].style.display = 'block';
            tabs[viewName].classList.add('active');

            currentState.currentView = viewName;

            // Update URL
            if (viewName === 'files') {
                updateURL('files');
            } else if (viewName === 'tags') {
                updateURL('tags');
            } else if (viewName === 'search' && !searchInput.value && !tagFilter.value) {
                updateURL('search');
            }

            // Load data if needed
            if (viewName === 'files' && filesList.children.length === 0) {
                loadFiles();
            } else if (viewName === 'tags' && tagsCloud.children.length === 0) {
                loadTags();
            } else if (viewName === 'search' && currentState.allTags.length === 0) {
                loadTags();
            }
        }

        // Event Listeners
        tabs.files.addEventListener('click', (e) => {
            e.preventDefault();
            switchView('files');
        });

        tabs.search.addEventListener('click', (e) => {
            e.preventDefault();
            switchView('search');
        });

        tabs.tags.addEventListener('click', (e) => {
            e.preventDefault();
            switchView('tags');
        });

        // Brand link returns to main page
        brandLink.addEventListener('click', (e) => {
            e.preventDefault();
            switchView('files');
        });

        backToFilesButton.addEventListener('click', () => {
            views.fileDetail.style.display = 'none';
            views.files.style.display = 'block';
            currentState.currentFile = null;
            updateURL('files');
        });

        searchButton.addEventListener('click', searchNotes);
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchNotes();
            }
        });
        tagFilter.addEventListener('change', () => {
            const tag = tagFilter.value;
            if (tag) {
                searchByTag(tag);
            } else {
                searchNotes();
            }
        });

        // Side modal close events
        sideModalClose.addEventListener('click', closeSideModal);
        sideModalBackdrop.addEventListener('click', closeSideModal);
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && sideModal.classList.contains('active')) {
                closeSideModal();
            }
        });

        // Handle address link click
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('address-link')) {
                const address = e.target.textContent;
                // Handle address link click (e.g., navigate to address in IDA)
                console.log(`Address clicked: ${address}`);
                // Prevent propagation to avoid closing the modal
                e.stopPropagation();
            }
        });

        // Add event listeners for tag badges in search results and note details
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('tag-badge')) {
                const tag = e.target.textContent;
                closeSideModal(); // Close the side modal if open
                searchByTag(tag);
                // Prevent propagation
                e.stopPropagation();
            }
        });

        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            // Check if there's a URL hash already
            if (window.location.hash || window.location.search) {
                handleURLChange();
            } else {
                // Start with files view
                switchView('files');
            }
        });
    </script>
</body>

</html>
```

`src/ida/mcp.py`:

```py
import json
import struct
import threading
import http.server
import os
import time
import sqlite3
from urllib.parse import urlparse
from typing import Dict, Any, Callable, get_type_hints, TypedDict, Optional, Annotated, List
from pathlib import Path

PLUGIN_NAME = 'pcm'
PLUGIN_HOTKEY = "Ctrl-Alt-M"

class JSONRPCError(Exception):
    def __init__(self, code: int, message: str, data: Any = None):
        self.code = code
        self.message = message
        self.data = data


class RPCRegistry:
    def __init__(self):
        self.methods: Dict[str, Callable] = {}

    def register(self, func: Callable) -> Callable:
        self.methods[func.__name__] = func
        return func

    def dispatch(self, method: str, params: Any) -> Any:
        if method not in self.methods:
            raise JSONRPCError(-32601, f"Method '{method}' not found")

        func = self.methods[method]
        hints = get_type_hints(func)

        hints.pop("return", None)

        if isinstance(params, list):
            if len(params) != len(hints):
                raise JSONRPCError(-32602, f"Invalid params: expected {len(hints)} arguments, got {len(params)}")
            converted_params = []
            for value, (param_name, expected_type) in zip(params, hints.items()):
                try:
                    if not isinstance(value, expected_type):
                        value = expected_type(value)
                    converted_params.append(value)
                except (ValueError, TypeError):
                    raise JSONRPCError(-32602, f"Invalid type for parameter '{param_name}': expected {expected_type.__name__}")
            return func(*converted_params)
        elif isinstance(params, dict):
            if set(params.keys()) != set(hints.keys()):
                raise JSONRPCError(-32602, f"Invalid params: expected {list(hints.keys())}")

            converted_params = {}
            for param_name, expected_type in hints.items():
                value = params.get(param_name)
                try:
                    if not isinstance(value, expected_type):
                        value = expected_type(value)
                    converted_params[param_name] = value
                except (ValueError, TypeError):
                    raise JSONRPCError(-32602, f"Invalid type for parameter '{param_name}': expected {expected_type.__name__}")

            return func(**converted_params)
        else:
            raise JSONRPCError(-32600, "Invalid Request: params must be array or object")


rpc_registry = RPCRegistry()


def jsonrpc(func: Callable) -> Callable:
    """Decorator to register a function as a JSON-RPC method"""
    global rpc_registry
    return rpc_registry.register(func)


class JSONRPCRequestHandler(http.server.BaseHTTPRequestHandler):
    def send_jsonrpc_error(self, code: int, message: str, id: Any = None):
        response = {"jsonrpc": "2.0", "error": {"code": code, "message": message}}
        if id is not None:
            response["id"] = id
        response_body = json.dumps(response).encode("utf-8")
        self.send_response(200)
        self.send_header("Content-Type", "application/json")
        self.send_header("Content-Length", len(response_body))
        self.end_headers()
        self.wfile.write(response_body)

    def do_POST(self):
        global rpc_registry
        import traceback

        parsed_path = urlparse(self.path)
        if parsed_path.path != "/mcp":
            self.send_jsonrpc_error(-32098, "Invalid endpoint", None)
            return

        content_length = int(self.headers.get("Content-Length", 0))
        if content_length == 0:
            self.send_jsonrpc_error(-32700, "Parse error: missing request body", None)
            return

        request_body = self.rfile.read(content_length)
        try:
            request = json.loads(request_body)
        except json.JSONDecodeError:
            self.send_jsonrpc_error(-32700, "Parse error: invalid JSON", None)
            return

        # Prepare the response
        response = {"jsonrpc": "2.0"}
        if request.get("id") is not None:
            response["id"] = request.get("id")

        try:
            # Basic JSON-RPC validation
            if not isinstance(request, dict):
                raise JSONRPCError(-32600, "Invalid Request")
            if request.get("jsonrpc") != "2.0":
                raise JSONRPCError(-32600, "Invalid JSON-RPC version")
            if "method" not in request:
                raise JSONRPCError(-32600, "Method not specified")

            # Dispatch the method
            result = rpc_registry.dispatch(request["method"], request.get("params", []))
            response["result"] = result

        except JSONRPCError as e:
            response["error"] = {"code": e.code, "message": e.message}
            if e.data is not None:
                response["error"]["data"] = e.data
        except IDAError as e:
            response["error"] = {
                "code": -32000,
                "message": e.message,
            }
        except Exception as e:
            traceback.print_exc()
            response["error"] = {
                "code": -32603,
                "message": "Internal error",
                "data": traceback.format_exc(),
            }

        try:
            response_body = json.dumps(response).encode("utf-8")
        except Exception as e:
            traceback.print_exc()
            response_body = json.dumps(
                {
                    "error": {
                        "code": -32603,
                        "message": "Internal error",
                        "data": traceback.format_exc(),
                    }
                }
            ).encode("utf-8")

        self.send_response(200)
        self.send_header("Content-Type", "application/json")
        self.send_header("Content-Length", len(response_body))
        self.end_headers()
        self.wfile.write(response_body)

    def log_message(self, format, *args):
        # Suppress logging
        pass


class MCPHTTPServer(http.server.HTTPServer):
    allow_reuse_address = False


class Server:
    HOST = "localhost"
    PORT = 13337

    def __init__(self):
        self.server = None
        self.server_thread = None
        self.running = False

    def start(self):
        if self.running:
            print(f"[{PLUGIN_NAME}] Server is already running")
            return

        self.server_thread = threading.Thread(target=self._run_server, daemon=True)
        self.running = True
        self.server_thread.start()

    def stop(self):
        if not self.running:
            return

        self.running = False
        if self.server:
            self.server.shutdown()
            self.server.server_close()
        if self.server_thread:
            self.server_thread.join()
            self.server = None
        print(f"[{PLUGIN_NAME}] Server stopped")

    def _run_server(self):
        try:
            # Create server in the thread to handle binding
            self.server = MCPHTTPServer((Server.HOST, Server.PORT), JSONRPCRequestHandler)
            print(f"[{PLUGIN_NAME}] Server started at http://{Server.HOST}:{Server.PORT}")
            self.server.serve_forever()
        except OSError as e:
            if e.errno == 98 or e.errno == 10048:  # Port already in use (Linux/Windows)
                print(f"[{PLUGIN_NAME}] Error: Port 13337 is already in use")
            else:
                print(f"[{PLUGIN_NAME}] Server error: {e}")
            self.running = False
        except Exception as e:
            print(f"[{PLUGIN_NAME}] Server error: {e}")
        finally:
            self.running = False


# A module that helps with writing thread safe ida code.
# Based on:
# https://web.archive.org/web/20160305190440/http://www.williballenthin.com/blog/2015/09/04/idapython-synchronization-decorator/
import logging
import queue
import traceback
import functools

# import idapro
import ida_pro
import ida_hexrays
import ida_kernwin
import ida_funcs
import ida_entry
import ida_gdl
import ida_graph
import ida_lines
import ida_idaapi
import ida_name
import ida_segment
import ida_xref
import ida_typeinf
import idc
import idaapi
import idautils
import ida_nalt
import ida_bytes


class IDAError(Exception):
    def __init__(self, message: str):
        super().__init__(message)

    @property
    def message(self) -> str:
        return self.args[0]


class IDASyncError(Exception):
    pass


# Important note: Always make sure the return value from your function f is a
# copy of the data you have gotten from IDA, and not the original data.
#
# Example:
# --------
#
# Do this:
#
#   @idaread
#   def ts_Functions():
#       return list(idautils.Functions())
#
# Don't do this:
#
#   @idaread
#   def ts_Functions():
#       return idautils.Functions()
#

logger = logging.getLogger(__name__)


# Enum for safety modes. Higher means safer:
class IDASafety:
    ida_kernwin.MFF_READ
    SAFE_NONE = ida_kernwin.MFF_FAST
    SAFE_READ = ida_kernwin.MFF_READ
    SAFE_WRITE = ida_kernwin.MFF_WRITE


call_stack = queue.LifoQueue()


def sync_wrapper(ff, safety_mode: IDASafety):
    """
    Call a function ff with a specific IDA safety_mode.
    """
    # logger.debug('sync_wrapper: {}, {}'.format(ff.__name__, safety_mode))

    if safety_mode not in [IDASafety.SAFE_READ, IDASafety.SAFE_WRITE]:
        error_str = 'Invalid safety mode {} over function {}'.format(safety_mode, ff.__name__)
        logger.error(error_str)
        raise IDASyncError(error_str)

    # No safety level is set up:
    res_container = queue.Queue()

    def runned():
        # logger.debug('Inside runned')

        # Make sure that we are not already inside a sync_wrapper:
        if not call_stack.empty():
            last_func_name = call_stack.get()
            error_str = ('Call stack is not empty while calling the ' 'function {} from {}').format(ff.__name__, last_func_name)
            # logger.error(error_str)
            raise IDASyncError(error_str)

        call_stack.put((ff.__name__))
        try:
            res_container.put(ff())
        except Exception as x:
            res_container.put(x)
        finally:
            call_stack.get()
            # logger.debug('Finished runned')

    ret_val = idaapi.execute_sync(runned, safety_mode)
    res = res_container.get()
    if isinstance(res, Exception):
        raise res
    return res


def idawrite(f):
    """
    decorator for marking a function as modifying the IDB.
    schedules a request to be made in the main IDA loop to avoid IDB corruption.
    """

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        ff = functools.partial(f, *args, **kwargs)
        ff.__name__ = f.__name__
        return sync_wrapper(ff, idaapi.MFF_WRITE)

    return wrapper


def idaread(f):
    """
    decorator for marking a function as reading from the IDB.
    schedules a request to be made in the main IDA loop to avoid
      inconsistent results.
    MFF_READ constant via: http://www.openrce.org/forums/posts/1827
    """

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        ff = functools.partial(f, *args, **kwargs)
        ff.__name__ = f.__name__
        return sync_wrapper(ff, idaapi.MFF_READ)

    return wrapper


def init_notes_db():
    user_dir = Path.home()
    if os.name == 'nt':
        db_path = user_dir / "AppData" / "Local" / "IDA_MCP"
    else:
        db_path = user_dir / ".ida_mcp"

    db_path.mkdir(exist_ok=True)
    db_file = db_path / "analysis_notes.db"

    conn = sqlite3.connect(str(db_file))
    cursor = conn.cursor()

    cursor.execute(
        '''
    CREATE TABLE IF NOT EXISTS notes (
        id INTEGER PRIMARY KEY,
        file_md5 TEXT NOT NULL,
        address TEXT,
        title TEXT NOT NULL,
        content TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        tags TEXT
    )
    '''
    )

    cursor.execute(
        '''
    CREATE TABLE IF NOT EXISTS files (
        md5 TEXT PRIMARY KEY,
        path TEXT NOT NULL,
        name TEXT NOT NULL,
        base_addr TEXT,
        size TEXT,
        sha256 TEXT,
        crc32 TEXT,
        filesize TEXT,
        last_accessed INTEGER
    )
    '''
    )

    conn.commit()
    conn.close()

    return str(db_file)


NOTES_DB = init_notes_db()


# Type definitions
class Function(TypedDict):
    start_address: int
    end_address: int
    name: str
    prototype: str


class Entrypoint(TypedDict):
    address: int
    name: str
    ordinal: int


class Block(TypedDict):
    start_address: int
    end_address: int
    type: str
    successor_addresses: List[int]


class CFGNode(TypedDict):
    id: int
    start_address: int
    end_address: int
    type: str
    successors: List[int]


class XrefEntry(TypedDict):
    from_address: int
    to_address: int
    type: str
    function_name: str


class Type(TypedDict):
    name: str
    definition: str
    size: int


class Note(TypedDict):
    id: int
    file_md5: str
    address: Optional[str]
    title: str
    content: str
    timestamp: int
    tags: Optional[str]


class FileInfo(TypedDict):
    md5: str
    path: str
    name: str
    base_addr: str
    size: str
    sha256: str
    crc32: str
    filesize: str
    last_accessed: int


class Metadata(TypedDict):
    path: str
    module: str
    base: str
    size: str
    md5: str
    sha256: str
    crc32: str
    filesize: str


def get_function(address: int) -> Optional[Function]:
    fn = idaapi.get_func(address)
    if fn is None:
        raise IDAError(f"No function found at address {address}")
    # NOTE: You need IDA 9.0 SP1 or newer for this
    prototype: ida_typeinf.tinfo_t = fn.get_prototype()
    if prototype is not None:
        prototype = str(prototype)
    return {
        "start_address": fn.start_ea,
        "end_address": fn.end_ea,
        "name": fn.name,
        "prototype": prototype,
    }


def get_image_size():
    import ida_ida

    omin_ea = ida_ida.inf_get_omin_ea()
    omax_ea = ida_ida.inf_get_omax_ea()
    # Bad heuristic for image size (bad if the relocations are the last section)
    image_size = omax_ea - omin_ea
    # Try to extract it from the PE header
    header = idautils.peutils_t().header()
    if header and header[:4] == b"PE\0\0":
        image_size = struct.unpack("<I", header[0x50:0x54])[0]
    return image_size


def decompile_checked(address: int) -> ida_hexrays.cfunc_t:
    if not ida_hexrays.init_hexrays_plugin():
        raise IDAError("Hex-Rays decompiler is not available")
    error = ida_hexrays.hexrays_failure_t()
    cfunc: ida_hexrays.cfunc_t = ida_hexrays.decompile_func(address, error, ida_hexrays.DECOMP_WARNINGS)
    if not cfunc:
        message = f"Decompilation failed at {address}"
        if error.str:
            message += f": {error.str}"
        if error.errea != idaapi.BADADDR:
            message += f" (address: {error.errea})"
        raise IDAError(message)
    return cfunc


def refresh_decompiler_widget():
    widget = ida_kernwin.get_current_widget()
    if widget is not None:
        vu = ida_hexrays.get_widget_vdui(widget)
        if vu is not None:
            vu.refresh_ctext()


def refresh_decompiler_ctext(function_address: int):
    error = ida_hexrays.hexrays_failure_t()
    cfunc: ida_hexrays.cfunc_t = ida_hexrays.decompile_func(function_address, error, ida_hexrays.DECOMP_WARNINGS)
    if cfunc:
        cfunc.refresh_func_ctext()


class my_modifier_t(ida_hexrays.user_lvar_modifier_t):
    def __init__(self, var_name: str, new_type: ida_typeinf.tinfo_t):
        ida_hexrays.user_lvar_modifier_t.__init__(self)
        self.var_name = var_name
        self.new_type = new_type

    def modify_lvars(self, lvars):
        for lvar_saved in lvars.lvvec:
            lvar_saved: ida_hexrays.lvar_saved_info_t
            if lvar_saved.name == self.var_name:
                lvar_saved.type = self.new_type
                return True
        return False


#
# Function and code analysis functions
#


@jsonrpc
@idaread
def get_function_by_name(name: Annotated[str, "Name of the function to get"]) -> Function:
    """Get a function by its name"""
    function_address = ida_name.get_name_ea(ida_idaapi.BADADDR, name)
    if function_address == ida_idaapi.BADADDR:
        raise IDAError(f"No function found with name {name}")
    return get_function(function_address)


@jsonrpc
@idaread
def get_function_by_address(address: Annotated[int, "Address of the function to get"]) -> Function:
    """Get a function by its address"""
    return get_function(address)


@jsonrpc
@idaread
def get_current_address() -> int:
    """Get the address currently selected by the user"""
    return idaapi.get_screen_ea()


@jsonrpc
@idaread
def get_current_function() -> Optional[Function]:
    """Get the function currently selected by the user"""
    return get_function(idaapi.get_screen_ea())


@jsonrpc
@idaread
def list_functions() -> list[Function]:
    """List all functions in the database"""
    return [get_function(address) for address in idautils.Functions()]


@jsonrpc
@idaread
def decompile_function(address: Annotated[int, "Address of the function to decompile"]) -> str:
    """Decompile a function at the given address using Hex-Rays"""
    cfunc = decompile_checked(address)
    sv = cfunc.get_pseudocode()
    cfunc.get_eamap()
    pseudocode = ""
    for i, sl in enumerate(sv):
        sl: ida_kernwin.simpleline_t
        item = ida_hexrays.ctree_item_t()
        addr = None if i > 0 else cfunc.entry_ea
        if cfunc.get_line_item(sl.line, 1, False, None, item, None):
            ds = item.dstr().split(": ")
            if len(ds) == 2 and ds[0] is not None and ds[0] != "":
                addr = int(ds[0], 16)
        line = ida_lines.tag_remove(sl.line)
        if len(pseudocode) > 0:
            pseudocode += "\n"
        if addr is None:
            pseudocode += f"/* line: {i} */ {line}"
        else:
            pseudocode += f"/* line: {i}, address: {addr:#x} */ {line}"

    return pseudocode


@jsonrpc
@idaread
def disassemble_function(address: Annotated[int, "Address of the function to disassemble"]) -> str:
    """Get assembly code (address: instruction; comment) for a function"""
    func = idaapi.get_func(address)
    if not func:
        raise IDAError(f"No function found at address {address}")

    # TODO: add labels
    disassembly = ""
    for address in ida_funcs.func_item_iterator_t(func):
        if len(disassembly) > 0:
            disassembly += "\n"
        disassembly += f"{address}: "
        disassembly += idaapi.generate_disasm_line(address, idaapi.GENDSM_REMOVE_TAGS)
        comment = idaapi.get_cmt(address, False)
        if not comment:
            comment = idaapi.get_cmt(address, True)
        if comment:
            disassembly += f"; {comment}"
    return disassembly


@jsonrpc
@idaread
def get_entrypoints() -> List[Entrypoint]:
    """Get all entrypoints in the binary"""
    entrypoints = []

    for i in range(ida_entry.get_entry_qty()):
        ordinal = i
        address = ida_entry.get_entry(ordinal)
        name = ida_name.get_name(address)

        entrypoints.append({"address": address, "name": name if name else f"entry_{ordinal}", "ordinal": ordinal})

    return entrypoints


@jsonrpc
@idaread
def get_function_blocks(address: Annotated[int, "Address of the function to get blocks for"]) -> List[Block]:
    """Get all basic blocks in a function"""
    func = idaapi.get_func(address)
    if not func:
        raise IDAError(f"No function found at address {address}")

    # Get control flow graph
    flow_chart = ida_gdl.FlowChart(func)
    blocks = []

    for block in flow_chart:
        successor_addresses = []
        for succ_idx in range(block.succ()):
            succ_block = block.succ(succ_idx)
            successor_addresses.append(succ_block.start_ea)

        blocks.append({"start_address": block.start_ea, "end_address": block.end_ea, "type": "block", "successor_addresses": successor_addresses})  # Default block type

    return blocks


@jsonrpc
@idaread
def get_function_cfg(address: Annotated[int, "Address of the function to get CFG for"]) -> List[CFGNode]:
    """Get control flow graph for a function"""
    func = idaapi.get_func(address)
    if not func:
        raise IDAError(f"No function found at address {address}")

    # Get control flow graph
    flow_chart = ida_gdl.FlowChart(func)
    nodes = []

    for i, block in enumerate(flow_chart):
        successors = []
        for succ_idx in range(block.succ()):
            succ_block = block.succ(succ_idx)
            # Store the block ID as successor
            successors.append(succ_block.id)

        # Determine block type
        block_type = "normal"
        if i == 0:
            block_type = "entry"
        elif block.succ() == 0:
            block_type = "exit"

        nodes.append({"id": block.id, "start_address": block.start_ea, "end_address": block.end_ea, "type": block_type, "successors": successors})

    return nodes


@jsonrpc
@idaread
def get_xrefs_to(address: Annotated[int, "Address to get xrefs to"]) -> List[XrefEntry]:
    """Get all cross references to the given address"""
    xrefs = [
        {
            'from_address': xref.frm,
            'to_address': xref.to,
            'type': idautils.XrefTypeName(xref.type),
            'function_name': ida_funcs.get_func_name(xref.frm) if xref.frm else 'global',
        }
        for xref in idautils.XrefsTo(address)
    ]
    return xrefs


@jsonrpc
@idaread
def get_xrefs_from(address: Annotated[int, "Address to get xrefs from"]) -> List[XrefEntry]:
    """Get all cross references from the given address"""
    xrefs = [
        {
            'from_address': xref.frm,
            'to_address': xref.to,
            'type': idautils.XrefTypeName(xref.type),
            'function_name': ida_funcs.get_func_name(xref.frm) if xref.frm else 'global',
        }
        for xref in idautils.XrefsFrom(address)
    ]
    return xrefs


#
# Modification functions
#


@jsonrpc
@idawrite
def set_decompiler_comment(address: Annotated[int, "Address in the function to set the comment for"], comment: Annotated[str, "Comment text (not shown in the disassembly)"]):
    """Set a comment for a given address in the function pseudocode"""

    # Reference: https://cyber.wtf/2019/03/22/using-ida-python-to-analyze-trickbot/
    # Check if the address corresponds to a line
    cfunc = decompile_checked(address)

    # Special case for function entry comments
    if address == cfunc.entry_ea:
        idc.set_func_cmt(address, comment, True)
        cfunc.refresh_func_ctext()
        return

    eamap = cfunc.get_eamap()
    if address not in eamap:
        raise IDAError(f"Failed to set comment at {address}")
    nearest_ea = eamap[address][0].ea

    # Remove existing orphan comments
    if cfunc.has_orphan_cmts():
        cfunc.del_orphan_cmts()
        cfunc.save_user_cmts()

    # Set the comment by trying all possible item types
    tl = idaapi.treeloc_t()
    tl.ea = nearest_ea
    for itp in range(idaapi.ITP_SEMI, idaapi.ITP_COLON):
        tl.itp = itp
        cfunc.set_user_cmt(tl, comment)
        cfunc.save_user_cmts()
        cfunc.refresh_func_ctext()
        if not cfunc.has_orphan_cmts():
            return
        cfunc.del_orphan_cmts()
        cfunc.save_user_cmts()
    raise IDAError(f"Failed to set comment at {address}")


@jsonrpc
@idawrite
def set_disassembly_comment(address: Annotated[int, "Address in the function to set the comment for"], comment: Annotated[str, "Comment text (not shown in the pseudocode)"]):
    """Set a comment for a given address in the function disassembly"""
    if not idaapi.set_cmt(address, comment, False):
        raise IDAError(f"Failed to set comment at {address}")


@jsonrpc
@idawrite
def rename_local_variable(
    function_address: Annotated[int, "Address of the function containing the variable"], old_name: Annotated[str, "Current name of the variable"], new_name: Annotated[str, "New name for the variable"]
):
    """Rename a local variable in a function"""
    func = idaapi.get_func(function_address)
    if not func:
        raise IDAError(f"No function found at address {function_address}")
    if not ida_hexrays.rename_lvar(func.start_ea, old_name, new_name):
        raise IDAError(f"Failed to rename local variable {old_name} in function at {func.start_ea}")
    refresh_decompiler_ctext(func.start_ea)
    return True


@jsonrpc
@idawrite
def rename_function(function_address: Annotated[int, "Address of the function to rename"], new_name: Annotated[str, "New name for the function"]):
    """Rename a function"""
    fn = idaapi.get_func(function_address)
    if not fn:
        raise IDAError(f"No function found at address {function_address}")
    result = idaapi.set_name(fn.start_ea, new_name)
    refresh_decompiler_ctext(fn.start_ea)
    return result


@jsonrpc
@idawrite
def set_function_prototype(function_address: Annotated[int, "Address of the function"], prototype: Annotated[str, "New function prototype"]) -> bool:
    """Set a function's prototype"""
    fn = idaapi.get_func(function_address)
    if not fn:
        raise IDAError(f"No function found at address {function_address}")
    try:
        tif = ida_typeinf.tinfo_t()
        if not tif.get_named_type(ida_typeinf.get_idati(), prototype):
            if not tif.create_func(prototype):
                raise IDAError(f"Failed to parse prototype string: {prototype}")
        if not ida_typeinf.apply_tinfo(fn.start_ea, tif, ida_typeinf.TINFO_DEFINITE):
            raise IDAError(f"Failed to apply type")
        refresh_decompiler_ctext(fn.start_ea)
        return True
    except Exception as e:
        raise IDAError(f"Failed to parse prototype string: {prototype}. Error: {str(e)}")


@jsonrpc
@idawrite
def set_local_variable_type(
    function_address: Annotated[int, "Address of the function containing the variable"], variable_name: Annotated[str, "Name of the variable"], new_type: Annotated[str, "New type for the variable"]
) -> bool:
    """Set a local variable's type"""
    try:
        new_tif = ida_typeinf.tinfo_t()
        if not new_tif.get_named_type(ida_typeinf.get_idati(), new_type):
            raise IDAError(f"Failed to parse type: {new_type}")
    except Exception as e:
        raise IDAError(f"Failed to parse type: {new_type}. Error: {str(e)}")

    fn = idaapi.get_func(function_address)
    if not fn:
        raise IDAError(f"No function found at address {function_address}")
    if not ida_hexrays.rename_lvar(fn.start_ea, variable_name, variable_name):
        raise IDAError(f"Failed to find local variable: {variable_name}")

    try:
        modifier = my_modifier_t(variable_name, new_tif)
        if not ida_hexrays.modify_user_lvars(fn.start_ea, modifier):
            raise IDAError(f"Failed to modify local variable: {variable_name}")
        refresh_decompiler_ctext(fn.start_ea)
        return True
    except Exception as e:
        raise IDAError(f"Failed to modify local variable: {variable_name}. Error: {str(e)}")


@jsonrpc
@idawrite
def create_structure_type(
    name: Annotated[str, "Name of the new structure"],
    members: Annotated[List[Dict[str, str]], "List of structure members with name and type"],
    is_union: Annotated[bool, "Whether this is a union (True) or struct (False)"] = False,
) -> bool:
    """Create a new structure type"""
    try:
        # Check if structure with this name already exists
        existing_id = idc.get_struc_id(name)
        if existing_id != ida_idaapi.BADADDR:
            idc.del_struc(idc.get_struc(existing_id))

        # Create new structure
        sid = idc.add_struc(ida_idaapi.BADADDR, name, is_union)
        if sid == ida_idaapi.BADADDR:
            raise IDAError(f"Failed to create structure {name}")

        sptr = idc.get_struc(sid)
        if not sptr:
            raise IDAError(f"Failed to get structure pointer for {name}")

        # Add members to structure
        for member in members:
            member_name = member.get("name", "")
            member_type = member.get("type", "")
            member_offset = -1  # Let IDA choose the next offset

            tif = ida_typeinf.tinfo_t()
            if not tif.get_named_type(ida_typeinf.get_idati(), member_type):
                # Try to create a basic type
                if not ida_typeinf.parse_decl(tif, ida_typeinf.get_idati(), f"{member_type};", ida_typeinf.PT_SIL):
                    raise IDAError(f"Failed to parse type {member_type} for member {member_name}")

            # Add member
            if idc.add_struc_member(sptr, member_name, member_offset, ida_bytes.byteflag(), None, ida_typeinf.get_type_size(ida_typeinf.get_idati(), tif)) != 0:
                raise IDAError(f"Failed to add member {member_name} to structure {name}")

            # Set member type
            member_idx = idc.get_member_by_name(sptr, member_name)
            if member_idx is None:
                raise IDAError(f"Failed to get member index for {member_name}")

            member_ptr = idc.get_member(sptr, member_idx)
            if member_ptr is None:
                raise IDAError(f"Failed to get member pointer for {member_name}")

            if not ida_typeinf.set_member_tinfo(ida_typeinf.get_idati(), sptr, member_ptr, 0, tif, ida_typeinf.SET_MEMTI_COMPATIBLE):
                raise IDAError(f"Failed to set type for member {member_name}")

        return True
    except Exception as e:
        raise IDAError(f"Failed to create structure {name}. Error: {str(e)}")


@jsonrpc
@idaread
def get_metadata() -> Metadata:
    """Get metadata about the current IDB"""
    return {
        "path": idaapi.get_input_file_path(),
        "module": idaapi.get_root_filename(),
        "base": hex(idaapi.get_imagebase()),
        "size": hex(get_image_size()),
        "md5": ida_nalt.retrieve_input_file_md5().hex(),
        "sha256": ida_nalt.retrieve_input_file_sha256().hex(),
        "crc32": hex(ida_nalt.retrieve_input_file_crc32()),
        "filesize": hex(ida_nalt.retrieve_input_file_size()),
    }


@jsonrpc
@idawrite
def repl_idapython(content: Annotated[str, "IDAPython code to run"]) -> str:
    """Run IDAPython code and return the results with stdout/stderr captured."""
    import sys
    import io
    import traceback

    stdout_capture, stderr_capture = io.StringIO(), io.StringIO()
    original_stdout, original_stderr = sys.stdout, sys.stderr
    sys.stdout, sys.stderr = stdout_capture, stderr_capture
    try:
        exec(content, globals())
        result = "Success"
    except Exception as e:
        result = f"Error: {str(e)}\n{traceback.format_exc()}"
    finally:
        sys.stdout, sys.stderr = original_stdout, original_stderr

    response = ""
    if stdout_output := stdout_capture.getvalue():
        response += f"<stdout>\n{stdout_output}\n</stdout>\n"
    if stderr_output := stderr_capture.getvalue():
        response += f"<stderr>\n{stderr_output}\n</stderr>\n"
    if not stdout_output and not stderr_output:
        response += f"{result}"
    return response


#
# Notes and multi-binary support functions
#


@jsonrpc
def add_note(
    title: Annotated[str, "Title of the note"],
    content: Annotated[str, "Content of the note"],
    address: Annotated[Optional[int], "Address this note is related to (optional)"] = None,
    tags: Annotated[Optional[str], "Comma-separated tags for this note"] = None,
) -> int:
    """Add a new analysis note for the current binary"""

    # Get current file metadata
    metadata = get_metadata()
    file_md5 = metadata["md5"]

    # Store file info if not already present
    conn = sqlite3.connect(NOTES_DB)
    cursor = conn.cursor()

    cursor.execute("SELECT * FROM files WHERE md5 = ?", (file_md5,))
    if not cursor.fetchone():
        cursor.execute(
            "INSERT INTO files (md5, path, name, base_addr, size, sha256, crc32, filesize, last_accessed) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
            (file_md5, metadata["path"], metadata["module"], metadata["base"], metadata["size"], metadata["sha256"], metadata["crc32"], metadata["filesize"], int(time.time())),
        )
    else:
        # Update last accessed time
        cursor.execute("UPDATE files SET last_accessed = ? WHERE md5 = ?", (int(time.time()), file_md5))

    # Add note
    timestamp = int(time.time())
    address_str = hex(address) if address is not None else None

    cursor.execute("INSERT INTO notes (file_md5, address, title, content, timestamp, tags) VALUES (?, ?, ?, ?, ?, ?)", (file_md5, address_str, title, content, timestamp, tags))

    note_id = cursor.lastrowid
    conn.commit()
    conn.close()

    return note_id


@jsonrpc
def update_note(
    note_id: Annotated[int, "ID of the note to update"],
    title: Annotated[Optional[str], "New title (or None to keep current)"] = None,
    content: Annotated[Optional[str], "New content (or None to keep current)"] = None,
    tags: Annotated[Optional[str], "New tags (or None to keep current)"] = None,
) -> bool:
    """Update an existing note"""

    conn = sqlite3.connect(NOTES_DB)
    cursor = conn.cursor()

    # Get current note
    cursor.execute("SELECT * FROM notes WHERE id = ?", (note_id,))
    note = cursor.fetchone()
    if not note:
        conn.close()
        raise IDAError(f"Note with ID {note_id} not found")

    # Build update query
    update_parts = []
    params = []

    if title is not None:
        update_parts.append("title = ?")
        params.append(title)

    if content is not None:
        update_parts.append("content = ?")
        params.append(content)

    if tags is not None:
        update_parts.append("tags = ?")
        params.append(tags)

    if not update_parts:
        conn.close()
        return False  # Nothing to update

    # Update timestamp
    update_parts.append("timestamp = ?")
    params.append(int(time.time()))

    # Execute update
    params.append(note_id)
    cursor.execute(f"UPDATE notes SET {', '.join(update_parts)} WHERE id = ?", params)

    conn.commit()
    conn.close()

    return True


@jsonrpc
def get_notes(
    file_md5: Annotated[Optional[str], "MD5 of file to get notes for (or None for current file)"] = None,
    address: Annotated[Optional[int], "Get notes for specific address (optional)"] = None,
    tag: Annotated[Optional[str], "Filter notes by tag (optional)"] = None,
) -> List[Note]:
    """Get analysis notes for a binary"""

    # If no file_md5 specified, use current file
    if file_md5 is None:
        metadata = get_metadata()
        file_md5 = metadata["md5"]

    conn = sqlite3.connect(NOTES_DB)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()

    query = "SELECT * FROM notes WHERE file_md5 = ?"
    params = [file_md5]

    if address is not None:
        query += " AND address = ?"
        params.append(hex(address))

    if tag is not None:
        # Search for tag in comma-separated list
        query += " AND tags LIKE ?"
        params.append(f"%{tag}%")

    query += " ORDER BY timestamp DESC"

    cursor.execute(query, params)
    notes = [dict(row) for row in cursor.fetchall()]

    conn.close()

    return notes


@jsonrpc
def delete_note(note_id: Annotated[int, "ID of the note to delete"]) -> bool:
    """Delete an analysis note"""

    conn = sqlite3.connect(NOTES_DB)
    cursor = conn.cursor()

    cursor.execute("DELETE FROM notes WHERE id = ?", (note_id,))
    deleted = cursor.rowcount > 0

    conn.commit()
    conn.close()

    return deleted


@jsonrpc
def list_analyzed_files() -> List[FileInfo]:
    """List all previously analyzed files"""

    conn = sqlite3.connect(NOTES_DB)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()

    cursor.execute("SELECT * FROM files ORDER BY last_accessed DESC")
    files = [dict(row) for row in cursor.fetchall()]

    conn.close()

    return files


class MCP(idaapi.plugin_t):
    flags = idaapi.PLUGIN_KEEP
    comment = "Model Context Protocol Plugin"
    help = "Enables MCP integration for remotely controlling IDA Pro"
    wanted_name = PLUGIN_NAME
    wanted_hotkey = PLUGIN_HOTKEY

    def init(self):
        self.server = Server()
        print(f"[{PLUGIN_NAME}] Plugin loaded, use Edit -> Plugins -> {PLUGIN_NAME} ({PLUGIN_HOTKEY}) to start the server")
        return idaapi.PLUGIN_KEEP

    def run(self, args):
        self.server.start()

    def term(self):
        self.server.stop()


def PLUGIN_ENTRY():
    return MCP()

```

`uv.lock`:

```lock
version = 1
revision = 1
requires-python = ">=3.13"

[[package]]
name = "annotated-types"
version = "0.7.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/ee/67/531ea369ba64dcff5ec9c3402f9f51bf748cec26dde048a2f973a4eea7f5/annotated_types-0.7.0.tar.gz", hash = "sha256:aff07c09a53a08bc8cfccb9c85b05f1aa9a2a6f23728d790723543408344ce89", size = 16081 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/78/b6/6307fbef88d9b5ee7421e68d78a9f162e0da4900bc5f5793f6d3d0e34fb8/annotated_types-0.7.0-py3-none-any.whl", hash = "sha256:1f02e8b43a8fbbc3f3e0d4f0f4bfc8131bcb4eebe8849b8e5c773f3a1c582a53", size = 13643 },
]

[[package]]
name = "anyio"
version = "4.9.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "idna" },
    { name = "sniffio" },
]
sdist = { url = "https://files.pythonhosted.org/packages/95/7d/4c1bd541d4dffa1b52bd83fb8527089e097a106fc90b467a7313b105f840/anyio-4.9.0.tar.gz", hash = "sha256:673c0c244e15788651a4ff38710fea9675823028a6f08a5eda409e0c9840a028", size = 190949 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a1/ee/48ca1a7c89ffec8b6a0c5d02b89c305671d5ffd8d3c94acf8b8c408575bb/anyio-4.9.0-py3-none-any.whl", hash = "sha256:9f76d541cad6e36af7beb62e978876f3b41e3e04f2c1fbf0884604c0a9c4d93c", size = 100916 },
]

[[package]]
name = "blinker"
version = "1.9.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/21/28/9b3f50ce0e048515135495f198351908d99540d69bfdc8c1d15b73dc55ce/blinker-1.9.0.tar.gz", hash = "sha256:b4ce2265a7abece45e7cc896e98dbebe6cead56bcf805a3d23136d145f5445bf", size = 22460 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/10/cb/f2ad4230dc2eb1a74edf38f1a38b9b52277f75bef262d8908e60d957e13c/blinker-1.9.0-py3-none-any.whl", hash = "sha256:ba0efaa9080b619ff2f3459d1d500c57bddea4a6b424b60a91141db6fd2f08bc", size = 8458 },
]

[[package]]
name = "certifi"
version = "2025.1.31"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/1c/ab/c9f1e32b7b1bf505bf26f0ef697775960db7932abeb7b516de930ba2705f/certifi-2025.1.31.tar.gz", hash = "sha256:3d5da6925056f6f18f119200434a4780a94263f10d1c21d032a6f6b2baa20651", size = 167577 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/38/fc/bce832fd4fd99766c04d1ee0eead6b0ec6486fb100ae5e74c1d91292b982/certifi-2025.1.31-py3-none-any.whl", hash = "sha256:ca78db4565a652026a4db2bcdf68f2fb589ea80d0be70e03929ed730746b84fe", size = 166393 },
]

[[package]]
name = "click"
version = "8.1.8"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "colorama", marker = "sys_platform == 'win32'" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b9/2e/0090cbf739cee7d23781ad4b89a9894a41538e4fcf4c31dcdd705b78eb8b/click-8.1.8.tar.gz", hash = "sha256:ed53c9d8990d83c2a27deae68e4ee337473f6330c040a31d4225c9574d16096a", size = 226593 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/7e/d4/7ebdbd03970677812aac39c869717059dbb71a4cfc033ca6e5221787892c/click-8.1.8-py3-none-any.whl", hash = "sha256:63c132bbbed01578a06712a2d1f497bb62d9c1c0d329b7903a866228027263b2", size = 98188 },
]

[[package]]
name = "colorama"
version = "0.4.6"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d8/53/6f443c9a4a8358a93a6792e2acffb9d9d5cb0a5cfd8802644b7b1c9a02e4/colorama-0.4.6.tar.gz", hash = "sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44", size = 27697 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/d1/d6/3965ed04c63042e047cb6a3e6ed1a63a35087b6a609aa3a15ed8ac56c221/colorama-0.4.6-py2.py3-none-any.whl", hash = "sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6", size = 25335 },
]

[[package]]
name = "fastmcp"
version = "0.4.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "httpx" },
    { name = "mcp" },
    { name = "pydantic" },
    { name = "pydantic-settings" },
    { name = "python-dotenv" },
    { name = "typer" },
]
sdist = { url = "https://files.pythonhosted.org/packages/6f/84/17b549133263d7ee77141970769bbc401525526bf1af043ea6842bce1a55/fastmcp-0.4.1.tar.gz", hash = "sha256:713ad3b8e4e04841c9e2f3ca022b053adb89a286ceffad0d69ae7b56f31cbe64", size = 785575 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/79/0b/008a340435fe8f0879e9d608f48af2737ad48440e09bd33b83b3fd03798b/fastmcp-0.4.1-py3-none-any.whl", hash = "sha256:664b42c376fb89ec90a50c9433f5a1f4d24f36696d6c41b024b427ae545f9619", size = 35282 },
]

[[package]]
name = "flask"
version = "3.1.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "blinker" },
    { name = "click" },
    { name = "itsdangerous" },
    { name = "jinja2" },
    { name = "werkzeug" },
]
sdist = { url = "https://files.pythonhosted.org/packages/89/50/dff6380f1c7f84135484e176e0cac8690af72fa90e932ad2a0a60e28c69b/flask-3.1.0.tar.gz", hash = "sha256:5f873c5184c897c8d9d1b05df1e3d01b14910ce69607a117bd3277098a5836ac", size = 680824 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/af/47/93213ee66ef8fae3b93b3e29206f6b251e65c97bd91d8e1c5596ef15af0a/flask-3.1.0-py3-none-any.whl", hash = "sha256:d667207822eb83f1c4b50949b1623c8fc8d51f2341d65f72e1a1815397551136", size = 102979 },
]

[[package]]
name = "h11"
version = "0.14.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f5/38/3af3d3633a34a3316095b39c8e8fb4853a28a536e55d347bd8d8e9a14b03/h11-0.14.0.tar.gz", hash = "sha256:8f19fbbe99e72420ff35c00b27a34cb9937e902a8b810e2c88300c6f0a3b699d", size = 100418 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/95/04/ff642e65ad6b90db43e668d70ffb6736436c7ce41fcc549f4e9472234127/h11-0.14.0-py3-none-any.whl", hash = "sha256:e3fe4ac4b851c468cc8363d500db52c2ead036020723024a109d37346efaa761", size = 58259 },
]

[[package]]
name = "httpcore"
version = "1.0.7"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "certifi" },
    { name = "h11" },
]
sdist = { url = "https://files.pythonhosted.org/packages/6a/41/d7d0a89eb493922c37d343b607bc1b5da7f5be7e383740b4753ad8943e90/httpcore-1.0.7.tar.gz", hash = "sha256:8551cb62a169ec7162ac7be8d4817d561f60e08eaa485234898414bb5a8a0b4c", size = 85196 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/87/f5/72347bc88306acb359581ac4d52f23c0ef445b57157adedb9aee0cd689d2/httpcore-1.0.7-py3-none-any.whl", hash = "sha256:a3fff8f43dc260d5bd363d9f9cf1830fa3a458b332856f34282de498ed420edd", size = 78551 },
]

[[package]]
name = "httpx"
version = "0.28.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "certifi" },
    { name = "httpcore" },
    { name = "idna" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b1/df/48c586a5fe32a0f01324ee087459e112ebb7224f646c0b5023f5e79e9956/httpx-0.28.1.tar.gz", hash = "sha256:75e98c5f16b0f35b567856f597f06ff2270a374470a5c2392242528e3e3e42fc", size = 141406 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/2a/39/e50c7c3a983047577ee07d2a9e53faf5a69493943ec3f6a384bdc792deb2/httpx-0.28.1-py3-none-any.whl", hash = "sha256:d909fcccc110f8c7faf814ca82a9a4d816bc5a6dbfea25d6591d6985b8ba59ad", size = 73517 },
]

[[package]]
name = "httpx-sse"
version = "0.4.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/4c/60/8f4281fa9bbf3c8034fd54c0e7412e66edbab6bc74c4996bd616f8d0406e/httpx-sse-0.4.0.tar.gz", hash = "sha256:1e81a3a3070ce322add1d3529ed42eb5f70817f45ed6ec915ab753f961139721", size = 12624 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e1/9b/a181f281f65d776426002f330c31849b86b31fc9d848db62e16f03ff739f/httpx_sse-0.4.0-py3-none-any.whl", hash = "sha256:f329af6eae57eaa2bdfd962b42524764af68075ea87370a2de920af5341e318f", size = 7819 },
]

[[package]]
name = "idna"
version = "3.10"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/f1/70/7703c29685631f5a7590aa73f1f1d3fa9a380e654b86af429e0934a32f7d/idna-3.10.tar.gz", hash = "sha256:12f65c9b470abda6dc35cf8e63cc574b1c52b11df2c86030af0ac09b01b13ea9", size = 190490 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/76/c6/c88e154df9c4e1a2a66ccf0005a88dfb2650c1dffb6f5ce603dfbd452ce3/idna-3.10-py3-none-any.whl", hash = "sha256:946d195a0d259cbba61165e88e65941f16e9b36ea6ddb97f00452bae8b1287d3", size = 70442 },
]

[[package]]
name = "itsdangerous"
version = "2.2.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/9c/cb/8ac0172223afbccb63986cc25049b154ecfb5e85932587206f42317be31d/itsdangerous-2.2.0.tar.gz", hash = "sha256:e0050c0b7da1eea53ffaf149c0cfbb5c6e2e2b69c4bef22c81fa6eb73e5f6173", size = 54410 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/04/96/92447566d16df59b2a776c0fb82dbc4d9e07cd95062562af01e408583fc4/itsdangerous-2.2.0-py3-none-any.whl", hash = "sha256:c6242fc49e35958c8b15141343aa660db5fc54d4f13a1db01a3f5891b98700ef", size = 16234 },
]

[[package]]
name = "jinja2"
version = "3.1.6"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "markupsafe" },
]
sdist = { url = "https://files.pythonhosted.org/packages/df/bf/f7da0350254c0ed7c72f3e33cef02e048281fec7ecec5f032d4aac52226b/jinja2-3.1.6.tar.gz", hash = "sha256:0137fb05990d35f1275a587e9aee6d56da821fc83491a0fb838183be43f66d6d", size = 245115 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/62/a1/3d680cbfd5f4b8f15abc1d571870c5fc3e594bb582bc3b64ea099db13e56/jinja2-3.1.6-py3-none-any.whl", hash = "sha256:85ece4451f492d0c13c5dd7c13a64681a86afae63a5f347908daf103ce6d2f67", size = 134899 },
]

[[package]]
name = "markdown-it-py"
version = "3.0.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "mdurl" },
]
sdist = { url = "https://files.pythonhosted.org/packages/38/71/3b932df36c1a044d397a1f92d1cf91ee0a503d91e470cbd670aa66b07ed0/markdown-it-py-3.0.0.tar.gz", hash = "sha256:e3f60a94fa066dc52ec76661e37c851cb232d92f9886b15cb560aaada2df8feb", size = 74596 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/42/d7/1ec15b46af6af88f19b8e5ffea08fa375d433c998b8a7639e76935c14f1f/markdown_it_py-3.0.0-py3-none-any.whl", hash = "sha256:355216845c60bd96232cd8d8c40e8f9765cc86f46880e43a8fd22dc1a1a8cab1", size = 87528 },
]

[[package]]
name = "markupsafe"
version = "3.0.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/b2/97/5d42485e71dfc078108a86d6de8fa46db44a1a9295e89c5d6d4a06e23a62/markupsafe-3.0.2.tar.gz", hash = "sha256:ee55d3edf80167e48ea11a923c7386f4669df67d7994554387f84e7d8b0a2bf0", size = 20537 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/83/0e/67eb10a7ecc77a0c2bbe2b0235765b98d164d81600746914bebada795e97/MarkupSafe-3.0.2-cp313-cp313-macosx_10_13_universal2.whl", hash = "sha256:ba9527cdd4c926ed0760bc301f6728ef34d841f405abf9d4f959c478421e4efd", size = 14274 },
    { url = "https://files.pythonhosted.org/packages/2b/6d/9409f3684d3335375d04e5f05744dfe7e9f120062c9857df4ab490a1031a/MarkupSafe-3.0.2-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:f8b3d067f2e40fe93e1ccdd6b2e1d16c43140e76f02fb1319a05cf2b79d99430", size = 12352 },
    { url = "https://files.pythonhosted.org/packages/d2/f5/6eadfcd3885ea85fe2a7c128315cc1bb7241e1987443d78c8fe712d03091/MarkupSafe-3.0.2-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:569511d3b58c8791ab4c2e1285575265991e6d8f8700c7be0e88f86cb0672094", size = 24122 },
    { url = "https://files.pythonhosted.org/packages/0c/91/96cf928db8236f1bfab6ce15ad070dfdd02ed88261c2afafd4b43575e9e9/MarkupSafe-3.0.2-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:15ab75ef81add55874e7ab7055e9c397312385bd9ced94920f2802310c930396", size = 23085 },
    { url = "https://files.pythonhosted.org/packages/c2/cf/c9d56af24d56ea04daae7ac0940232d31d5a8354f2b457c6d856b2057d69/MarkupSafe-3.0.2-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:f3818cb119498c0678015754eba762e0d61e5b52d34c8b13d770f0719f7b1d79", size = 22978 },
    { url = "https://files.pythonhosted.org/packages/2a/9f/8619835cd6a711d6272d62abb78c033bda638fdc54c4e7f4272cf1c0962b/MarkupSafe-3.0.2-cp313-cp313-musllinux_1_2_aarch64.whl", hash = "sha256:cdb82a876c47801bb54a690c5ae105a46b392ac6099881cdfb9f6e95e4014c6a", size = 24208 },
    { url = "https://files.pythonhosted.org/packages/f9/bf/176950a1792b2cd2102b8ffeb5133e1ed984547b75db47c25a67d3359f77/MarkupSafe-3.0.2-cp313-cp313-musllinux_1_2_i686.whl", hash = "sha256:cabc348d87e913db6ab4aa100f01b08f481097838bdddf7c7a84b7575b7309ca", size = 23357 },
    { url = "https://files.pythonhosted.org/packages/ce/4f/9a02c1d335caabe5c4efb90e1b6e8ee944aa245c1aaaab8e8a618987d816/MarkupSafe-3.0.2-cp313-cp313-musllinux_1_2_x86_64.whl", hash = "sha256:444dcda765c8a838eaae23112db52f1efaf750daddb2d9ca300bcae1039adc5c", size = 23344 },
    { url = "https://files.pythonhosted.org/packages/ee/55/c271b57db36f748f0e04a759ace9f8f759ccf22b4960c270c78a394f58be/MarkupSafe-3.0.2-cp313-cp313-win32.whl", hash = "sha256:bcf3e58998965654fdaff38e58584d8937aa3096ab5354d493c77d1fdd66d7a1", size = 15101 },
    { url = "https://files.pythonhosted.org/packages/29/88/07df22d2dd4df40aba9f3e402e6dc1b8ee86297dddbad4872bd5e7b0094f/MarkupSafe-3.0.2-cp313-cp313-win_amd64.whl", hash = "sha256:e6a2a455bd412959b57a172ce6328d2dd1f01cb2135efda2e4576e8a23fa3b0f", size = 15603 },
    { url = "https://files.pythonhosted.org/packages/62/6a/8b89d24db2d32d433dffcd6a8779159da109842434f1dd2f6e71f32f738c/MarkupSafe-3.0.2-cp313-cp313t-macosx_10_13_universal2.whl", hash = "sha256:b5a6b3ada725cea8a5e634536b1b01c30bcdcd7f9c6fff4151548d5bf6b3a36c", size = 14510 },
    { url = "https://files.pythonhosted.org/packages/7a/06/a10f955f70a2e5a9bf78d11a161029d278eeacbd35ef806c3fd17b13060d/MarkupSafe-3.0.2-cp313-cp313t-macosx_11_0_arm64.whl", hash = "sha256:a904af0a6162c73e3edcb969eeeb53a63ceeb5d8cf642fade7d39e7963a22ddb", size = 12486 },
    { url = "https://files.pythonhosted.org/packages/34/cf/65d4a571869a1a9078198ca28f39fba5fbb910f952f9dbc5220afff9f5e6/MarkupSafe-3.0.2-cp313-cp313t-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:4aa4e5faecf353ed117801a068ebab7b7e09ffb6e1d5e412dc852e0da018126c", size = 25480 },
    { url = "https://files.pythonhosted.org/packages/0c/e3/90e9651924c430b885468b56b3d597cabf6d72be4b24a0acd1fa0e12af67/MarkupSafe-3.0.2-cp313-cp313t-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:c0ef13eaeee5b615fb07c9a7dadb38eac06a0608b41570d8ade51c56539e509d", size = 23914 },
    { url = "https://files.pythonhosted.org/packages/66/8c/6c7cf61f95d63bb866db39085150df1f2a5bd3335298f14a66b48e92659c/MarkupSafe-3.0.2-cp313-cp313t-manylinux_2_5_i686.manylinux1_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:d16a81a06776313e817c951135cf7340a3e91e8c1ff2fac444cfd75fffa04afe", size = 23796 },
    { url = "https://files.pythonhosted.org/packages/bb/35/cbe9238ec3f47ac9a7c8b3df7a808e7cb50fe149dc7039f5f454b3fba218/MarkupSafe-3.0.2-cp313-cp313t-musllinux_1_2_aarch64.whl", hash = "sha256:6381026f158fdb7c72a168278597a5e3a5222e83ea18f543112b2662a9b699c5", size = 25473 },
    { url = "https://files.pythonhosted.org/packages/e6/32/7621a4382488aa283cc05e8984a9c219abad3bca087be9ec77e89939ded9/MarkupSafe-3.0.2-cp313-cp313t-musllinux_1_2_i686.whl", hash = "sha256:3d79d162e7be8f996986c064d1c7c817f6df3a77fe3d6859f6f9e7be4b8c213a", size = 24114 },
    { url = "https://files.pythonhosted.org/packages/0d/80/0985960e4b89922cb5a0bac0ed39c5b96cbc1a536a99f30e8c220a996ed9/MarkupSafe-3.0.2-cp313-cp313t-musllinux_1_2_x86_64.whl", hash = "sha256:131a3c7689c85f5ad20f9f6fb1b866f402c445b220c19fe4308c0b147ccd2ad9", size = 24098 },
    { url = "https://files.pythonhosted.org/packages/82/78/fedb03c7d5380df2427038ec8d973587e90561b2d90cd472ce9254cf348b/MarkupSafe-3.0.2-cp313-cp313t-win32.whl", hash = "sha256:ba8062ed2cf21c07a9e295d5b8a2a5ce678b913b45fdf68c32d95d6c1291e0b6", size = 15208 },
    { url = "https://files.pythonhosted.org/packages/4f/65/6079a46068dfceaeabb5dcad6d674f5f5c61a6fa5673746f42a9f4c233b3/MarkupSafe-3.0.2-cp313-cp313t-win_amd64.whl", hash = "sha256:e444a31f8db13eb18ada366ab3cf45fd4b31e4db1236a4448f68778c1d1a5a2f", size = 15739 },
]

[[package]]
name = "mcp"
version = "1.5.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "httpx" },
    { name = "httpx-sse" },
    { name = "pydantic" },
    { name = "pydantic-settings" },
    { name = "sse-starlette" },
    { name = "starlette" },
    { name = "uvicorn" },
]
sdist = { url = "https://files.pythonhosted.org/packages/6d/c9/c55764824e893fdebe777ac7223200986a275c3191dba9169f8eb6d7c978/mcp-1.5.0.tar.gz", hash = "sha256:5b2766c05e68e01a2034875e250139839498c61792163a7b221fc170c12f5aa9", size = 159128 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c1/d1/3ff566ecf322077d861f1a68a1ff025cad337417bd66ad22a7c6f7dfcfaf/mcp-1.5.0-py3-none-any.whl", hash = "sha256:51c3f35ce93cb702f7513c12406bbea9665ef75a08db909200b07da9db641527", size = 73734 },
]

[[package]]
name = "mdurl"
version = "0.1.2"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/d6/54/cfe61301667036ec958cb99bd3efefba235e65cdeb9c84d24a8293ba1d90/mdurl-0.1.2.tar.gz", hash = "sha256:bb413d29f5eea38f31dd4754dd7377d4465116fb207585f97bf925588687c1ba", size = 8729 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/b3/38/89ba8ad64ae25be8de66a6d463314cf1eb366222074cfda9ee839c56a4b4/mdurl-0.1.2-py3-none-any.whl", hash = "sha256:84008a41e51615a49fc9966191ff91509e3c40b939176e643fd50a5c2196b8f8", size = 9979 },
]

[[package]]
name = "pcm"
version = "0.1.0"
source = { editable = "." }
dependencies = [
    { name = "fastmcp" },
    { name = "flask" },
]

[package.metadata]
requires-dist = [
    { name = "fastmcp", specifier = ">=0.4.1" },
    { name = "flask", specifier = ">=3.1.0" },
]

[[package]]
name = "pydantic"
version = "2.10.6"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "annotated-types" },
    { name = "pydantic-core" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/b7/ae/d5220c5c52b158b1de7ca89fc5edb72f304a70a4c540c84c8844bf4008de/pydantic-2.10.6.tar.gz", hash = "sha256:ca5daa827cce33de7a42be142548b0096bf05a7e7b365aebfa5f8eeec7128236", size = 761681 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/f4/3c/8cc1cc84deffa6e25d2d0c688ebb80635dfdbf1dbea3e30c541c8cf4d860/pydantic-2.10.6-py3-none-any.whl", hash = "sha256:427d664bf0b8a2b34ff5dd0f5a18df00591adcee7198fbd71981054cef37b584", size = 431696 },
]

[[package]]
name = "pydantic-core"
version = "2.27.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/fc/01/f3e5ac5e7c25833db5eb555f7b7ab24cd6f8c322d3a3ad2d67a952dc0abc/pydantic_core-2.27.2.tar.gz", hash = "sha256:eb026e5a4c1fee05726072337ff51d1efb6f59090b7da90d30ea58625b1ffb39", size = 413443 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/41/b1/9bc383f48f8002f99104e3acff6cba1231b29ef76cfa45d1506a5cad1f84/pydantic_core-2.27.2-cp313-cp313-macosx_10_12_x86_64.whl", hash = "sha256:7d14bd329640e63852364c306f4d23eb744e0f8193148d4044dd3dacdaacbd8b", size = 1892709 },
    { url = "https://files.pythonhosted.org/packages/10/6c/e62b8657b834f3eb2961b49ec8e301eb99946245e70bf42c8817350cbefc/pydantic_core-2.27.2-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:82f91663004eb8ed30ff478d77c4d1179b3563df6cdb15c0817cd1cdaf34d154", size = 1811273 },
    { url = "https://files.pythonhosted.org/packages/ba/15/52cfe49c8c986e081b863b102d6b859d9defc63446b642ccbbb3742bf371/pydantic_core-2.27.2-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:71b24c7d61131bb83df10cc7e687433609963a944ccf45190cfc21e0887b08c9", size = 1823027 },
    { url = "https://files.pythonhosted.org/packages/b1/1c/b6f402cfc18ec0024120602bdbcebc7bdd5b856528c013bd4d13865ca473/pydantic_core-2.27.2-cp313-cp313-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:fa8e459d4954f608fa26116118bb67f56b93b209c39b008277ace29937453dc9", size = 1868888 },
    { url = "https://files.pythonhosted.org/packages/bd/7b/8cb75b66ac37bc2975a3b7de99f3c6f355fcc4d89820b61dffa8f1e81677/pydantic_core-2.27.2-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:ce8918cbebc8da707ba805b7fd0b382816858728ae7fe19a942080c24e5b7cd1", size = 2037738 },
    { url = "https://files.pythonhosted.org/packages/c8/f1/786d8fe78970a06f61df22cba58e365ce304bf9b9f46cc71c8c424e0c334/pydantic_core-2.27.2-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:eda3f5c2a021bbc5d976107bb302e0131351c2ba54343f8a496dc8783d3d3a6a", size = 2685138 },
    { url = "https://files.pythonhosted.org/packages/a6/74/d12b2cd841d8724dc8ffb13fc5cef86566a53ed358103150209ecd5d1999/pydantic_core-2.27.2-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:bd8086fa684c4775c27f03f062cbb9eaa6e17f064307e86b21b9e0abc9c0f02e", size = 1997025 },
    { url = "https://files.pythonhosted.org/packages/a0/6e/940bcd631bc4d9a06c9539b51f070b66e8f370ed0933f392db6ff350d873/pydantic_core-2.27.2-cp313-cp313-manylinux_2_5_i686.manylinux1_i686.whl", hash = "sha256:8d9b3388db186ba0c099a6d20f0604a44eabdeef1777ddd94786cdae158729e4", size = 2004633 },
    { url = "https://files.pythonhosted.org/packages/50/cc/a46b34f1708d82498c227d5d80ce615b2dd502ddcfd8376fc14a36655af1/pydantic_core-2.27.2-cp313-cp313-musllinux_1_1_aarch64.whl", hash = "sha256:7a66efda2387de898c8f38c0cf7f14fca0b51a8ef0b24bfea5849f1b3c95af27", size = 1999404 },
    { url = "https://files.pythonhosted.org/packages/ca/2d/c365cfa930ed23bc58c41463bae347d1005537dc8db79e998af8ba28d35e/pydantic_core-2.27.2-cp313-cp313-musllinux_1_1_armv7l.whl", hash = "sha256:18a101c168e4e092ab40dbc2503bdc0f62010e95d292b27827871dc85450d7ee", size = 2130130 },
    { url = "https://files.pythonhosted.org/packages/f4/d7/eb64d015c350b7cdb371145b54d96c919d4db516817f31cd1c650cae3b21/pydantic_core-2.27.2-cp313-cp313-musllinux_1_1_x86_64.whl", hash = "sha256:ba5dd002f88b78a4215ed2f8ddbdf85e8513382820ba15ad5ad8955ce0ca19a1", size = 2157946 },
    { url = "https://files.pythonhosted.org/packages/a4/99/bddde3ddde76c03b65dfd5a66ab436c4e58ffc42927d4ff1198ffbf96f5f/pydantic_core-2.27.2-cp313-cp313-win32.whl", hash = "sha256:1ebaf1d0481914d004a573394f4be3a7616334be70261007e47c2a6fe7e50130", size = 1834387 },
    { url = "https://files.pythonhosted.org/packages/71/47/82b5e846e01b26ac6f1893d3c5f9f3a2eb6ba79be26eef0b759b4fe72946/pydantic_core-2.27.2-cp313-cp313-win_amd64.whl", hash = "sha256:953101387ecf2f5652883208769a79e48db18c6df442568a0b5ccd8c2723abee", size = 1990453 },
    { url = "https://files.pythonhosted.org/packages/51/b2/b2b50d5ecf21acf870190ae5d093602d95f66c9c31f9d5de6062eb329ad1/pydantic_core-2.27.2-cp313-cp313-win_arm64.whl", hash = "sha256:ac4dbfd1691affb8f48c2c13241a2e3b60ff23247cbcf981759c768b6633cf8b", size = 1885186 },
]

[[package]]
name = "pydantic-settings"
version = "2.8.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "pydantic" },
    { name = "python-dotenv" },
]
sdist = { url = "https://files.pythonhosted.org/packages/88/82/c79424d7d8c29b994fb01d277da57b0a9b09cc03c3ff875f9bd8a86b2145/pydantic_settings-2.8.1.tar.gz", hash = "sha256:d5c663dfbe9db9d5e1c646b2e161da12f0d734d422ee56f567d0ea2cee4e8585", size = 83550 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/0b/53/a64f03044927dc47aafe029c42a5b7aabc38dfb813475e0e1bf71c4a59d0/pydantic_settings-2.8.1-py3-none-any.whl", hash = "sha256:81942d5ac3d905f7f3ee1a70df5dfb62d5569c12f51a5a647defc1c3d9ee2e9c", size = 30839 },
]

[[package]]
name = "pygments"
version = "2.19.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/7c/2d/c3338d48ea6cc0feb8446d8e6937e1408088a72a39937982cc6111d17f84/pygments-2.19.1.tar.gz", hash = "sha256:61c16d2a8576dc0649d9f39e089b5f02bcd27fba10d8fb4dcc28173f7a45151f", size = 4968581 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/8a/0b/9fcc47d19c48b59121088dd6da2488a49d5f72dacf8262e2790a1d2c7d15/pygments-2.19.1-py3-none-any.whl", hash = "sha256:9ea1544ad55cecf4b8242fab6dd35a93bbce657034b0611ee383099054ab6d8c", size = 1225293 },
]

[[package]]
name = "python-dotenv"
version = "1.1.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/88/2c/7bb1416c5620485aa793f2de31d3df393d3686aa8a8506d11e10e13c5baf/python_dotenv-1.1.0.tar.gz", hash = "sha256:41f90bc6f5f177fb41f53e87666db362025010eb28f60a01c9143bfa33a2b2d5", size = 39920 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/1e/18/98a99ad95133c6a6e2005fe89faedf294a748bd5dc803008059409ac9b1e/python_dotenv-1.1.0-py3-none-any.whl", hash = "sha256:d7c01d9e2293916c18baf562d95698754b0dbbb5e74d457c45d4f6561fb9d55d", size = 20256 },
]

[[package]]
name = "rich"
version = "13.9.4"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "markdown-it-py" },
    { name = "pygments" },
]
sdist = { url = "https://files.pythonhosted.org/packages/ab/3a/0316b28d0761c6734d6bc14e770d85506c986c85ffb239e688eeaab2c2bc/rich-13.9.4.tar.gz", hash = "sha256:439594978a49a09530cff7ebc4b5c7103ef57baf48d5ea3184f21d9a2befa098", size = 223149 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/19/71/39c7c0d87f8d4e6c020a393182060eaefeeae6c01dab6a84ec346f2567df/rich-13.9.4-py3-none-any.whl", hash = "sha256:6049d5e6ec054bf2779ab3358186963bac2ea89175919d699e378b99738c2a90", size = 242424 },
]

[[package]]
name = "shellingham"
version = "1.5.4"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/58/15/8b3609fd3830ef7b27b655beb4b4e9c62313a4e8da8c676e142cc210d58e/shellingham-1.5.4.tar.gz", hash = "sha256:8dbca0739d487e5bd35ab3ca4b36e11c4078f3a234bfce294b0a0291363404de", size = 10310 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e0/f9/0595336914c5619e5f28a1fb793285925a8cd4b432c9da0a987836c7f822/shellingham-1.5.4-py2.py3-none-any.whl", hash = "sha256:7ecfff8f2fd72616f7481040475a65b2bf8af90a56c89140852d1120324e8686", size = 9755 },
]

[[package]]
name = "sniffio"
version = "1.3.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/a2/87/a6771e1546d97e7e041b6ae58d80074f81b7d5121207425c964ddf5cfdbd/sniffio-1.3.1.tar.gz", hash = "sha256:f4324edc670a0f49750a81b895f35c3adb843cca46f0530f79fc1babb23789dc", size = 20372 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e9/44/75a9c9421471a6c4805dbf2356f7c181a29c1879239abab1ea2cc8f38b40/sniffio-1.3.1-py3-none-any.whl", hash = "sha256:2f6da418d1f1e0fddd844478f41680e794e6051915791a034ff65e5f100525a2", size = 10235 },
]

[[package]]
name = "sse-starlette"
version = "2.2.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
    { name = "starlette" },
]
sdist = { url = "https://files.pythonhosted.org/packages/71/a4/80d2a11af59fe75b48230846989e93979c892d3a20016b42bb44edb9e398/sse_starlette-2.2.1.tar.gz", hash = "sha256:54470d5f19274aeed6b2d473430b08b4b379ea851d953b11d7f1c4a2c118b419", size = 17376 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/d9/e0/5b8bd393f27f4a62461c5cf2479c75a2cc2ffa330976f9f00f5f6e4f50eb/sse_starlette-2.2.1-py3-none-any.whl", hash = "sha256:6410a3d3ba0c89e7675d4c273a301d64649c03a5ef1ca101f10b47f895fd0e99", size = 10120 },
]

[[package]]
name = "starlette"
version = "0.46.1"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "anyio" },
]
sdist = { url = "https://files.pythonhosted.org/packages/04/1b/52b27f2e13ceedc79a908e29eac426a63465a1a01248e5f24aa36a62aeb3/starlette-0.46.1.tar.gz", hash = "sha256:3c88d58ee4bd1bb807c0d1acb381838afc7752f9ddaec81bbe4383611d833230", size = 2580102 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a0/4b/528ccf7a982216885a1ff4908e886b8fb5f19862d1962f56a3fce2435a70/starlette-0.46.1-py3-none-any.whl", hash = "sha256:77c74ed9d2720138b25875133f3a2dae6d854af2ec37dceb56aef370c1d8a227", size = 71995 },
]

[[package]]
name = "typer"
version = "0.15.2"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "click" },
    { name = "rich" },
    { name = "shellingham" },
    { name = "typing-extensions" },
]
sdist = { url = "https://files.pythonhosted.org/packages/8b/6f/3991f0f1c7fcb2df31aef28e0594d8d54b05393a0e4e34c65e475c2a5d41/typer-0.15.2.tar.gz", hash = "sha256:ab2fab47533a813c49fe1f16b1a370fd5819099c00b119e0633df65f22144ba5", size = 100711 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/7f/fc/5b29fea8cee020515ca82cc68e3b8e1e34bb19a3535ad854cac9257b414c/typer-0.15.2-py3-none-any.whl", hash = "sha256:46a499c6107d645a9c13f7ee46c5d5096cae6f5fc57dd11eccbbb9ae3e44ddfc", size = 45061 },
]

[[package]]
name = "typing-extensions"
version = "4.13.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/0e/3e/b00a62db91a83fff600de219b6ea9908e6918664899a2d85db222f4fbf19/typing_extensions-4.13.0.tar.gz", hash = "sha256:0a4ac55a5820789d87e297727d229866c9650f6521b64206413c4fbada24d95b", size = 106520 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/e0/86/39b65d676ec5732de17b7e3c476e45bb80ec64eb50737a8dce1a4178aba1/typing_extensions-4.13.0-py3-none-any.whl", hash = "sha256:c8dd92cc0d6425a97c18fbb9d1954e5ff92c1ca881a309c45f06ebc0b79058e5", size = 45683 },
]

[[package]]
name = "uvicorn"
version = "0.34.0"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "click" },
    { name = "h11" },
]
sdist = { url = "https://files.pythonhosted.org/packages/4b/4d/938bd85e5bf2edeec766267a5015ad969730bb91e31b44021dfe8b22df6c/uvicorn-0.34.0.tar.gz", hash = "sha256:404051050cd7e905de2c9a7e61790943440b3416f49cb409f965d9dcd0fa73e9", size = 76568 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/61/14/33a3a1352cfa71812a3a21e8c9bfb83f60b0011f5e36f2b1399d51928209/uvicorn-0.34.0-py3-none-any.whl", hash = "sha256:023dc038422502fa28a09c7a30bf2b6991512da7dcdb8fd35fe57cfc154126f4", size = 62315 },
]

[[package]]
name = "werkzeug"
version = "3.1.3"
source = { registry = "https://pypi.org/simple" }
dependencies = [
    { name = "markupsafe" },
]
sdist = { url = "https://files.pythonhosted.org/packages/9f/69/83029f1f6300c5fb2471d621ab06f6ec6b3324685a2ce0f9777fd4a8b71e/werkzeug-3.1.3.tar.gz", hash = "sha256:60723ce945c19328679790e3282cc758aa4a6040e4bb330f53d30fa546d44746", size = 806925 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/52/24/ab44c871b0f07f491e5d2ad12c9bd7358e527510618cb1b803a88e986db1/werkzeug-3.1.3-py3-none-any.whl", hash = "sha256:54b78bf3716d19a65be4fceccc0d1d7b89e608834989dfae50ea87564639213e", size = 224498 },
]

```