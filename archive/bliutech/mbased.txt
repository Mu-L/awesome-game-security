Project Path: arc_bliutech_mbased_27dru3yf

Source Tree:

```txt
arc_bliutech_mbased_27dru3yf
├── LICENSE
├── README.md
├── __init__.py
├── examples
│   ├── fact.c
│   └── fib.c
├── experiments
│   ├── experiment.py
│   ├── generator.py
│   └── obfuscator.py
├── parser
│   ├── ast.py
│   ├── lex.py
│   ├── parse.py
│   └── visitor.py
├── plugin.json
├── requirements.txt
├── run_experiment.py
├── solver
│   ├── __init__.py
│   ├── passes
│   │   ├── example_pass.py
│   │   ├── sympy_pass.py
│   │   ├── template_pass.py
│   │   └── z3_pass.py
│   └── verifier.py
├── tests
│   ├── test_coding.py
│   ├── test_lex.py
│   ├── test_metrics.py
│   └── test_parse.py
└── utils
    ├── coding.py
    └── metrics.py

```

`LICENSE`:

```
Copyright (c) 2024 Benson Liu

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# MBASED: Practical Simplifications of Mixed Boolean-Arithmetic Obfuscation
![MBASED system overview.](.github/overview.png)

Mixed Boolean-Arithmetic (MBA) obfuscation is a technique that transforms simple boolean expressions into complex expressions by combining arithmetic and boolean operations. It serves the purpose of making code more difficult to analyze, protecting software from reverse engineering and tampering. Conversely, mixed boolean-arithmetic deobfuscation aims to simplify obfuscated boolean expressions. In this paper, we present a Binary Ninja plugin called MBASED (Mixed Boolean-Arithmetic Simplification Engine for Deobfuscation) that performs mixed boolean deobfuscation within C programs to assist reverse engineers in understanding them. We first created a system that processes boolean expressions and converts them into a parse tree. We then employed the Python library, SymPy, and the SMT Solver, Z3, to simplify the boolean expressions, and print the results to the Binary Ninja console. MBASED substantially decreases the number of variables and operations within boolean expressions, indicating boolean simplification.

This research project was conducted as part of the of the [New Jersey Governor's School of Engineering and Technology](https://soe.rutgers.edu/academics/pre-college-engineering-programs/new-jersey-governors-school-engineering-and-technology) 2024 program.

## Extending MBASED
A powerful design feature of MBASED is that similar to compiler frameworks like LLVM, it is easy to improve upon the underlying MBA solver by extending the plugin. MBASED takes an MLIL instruction, part of the BNIL intermediate representation stack, produced by Binary Ninja and uses an encoder and an LL(1) parser to produce an abstract syntax tree (AST) of a boolean expression allowing simplifications to be performed on the underlying AST rather than the raw output produced of the decompiler. Each simplification of the AST can be written as an optimization pass similar to LLVM where a transformation is performed on the AST. To extend MBASED and add your own pass, create a file inside `solver/passes` with a single function `run_pass(ast: Expr) -> Expr:`. MBASED also provides a set of visitors which can be used to easily traverse and simplify the AST. To see what visitors are available, check out `parser/visitor.py`. To see an example of how to write a pass, see [example_pass.py](solver/passes/example_pass.py).

## Dependencies
In order to use or contribute to MBASED, you will need the following dependencies:

- [Binary Ninja](https://binary.ninja/): An interactive decompiler made by [Vector35](https://vector35.com/).
- [Z3](https://github.com/Z3Prover/z3): A high-performance theorem prover being developed at Microsoft Research.
- [Sympy](https://www.sympy.org/en/index.html): A Python library for symbolic mathematics.

## Installing and Using MBASED
To install MBASED, you will need to clone this repository into your Binary Ninja plugins directory. To find where your plugins directory is, open Binary Ninja and navigate to `Plugins > Open Plugin Folder` in the navigation bar. Then, clone this repository into the plugins directory using the following command.

```
git clone https://github.com/bliutech/mbased.git
```

Relaunch Binary Ninja, and you should see the MBASED plugin in the plugins list. To use MBASED, after installation, you can load a target binary for analysis in Binary Ninja. From there, navigate to `Plugins > MBASED: Simplify all MBA expressions` and see the resulting output in the Binary Ninja logs. If you want to see the decompilation which corresponds to the simplified MBA expression, click on the address for the simplified value in the logs and Binary Ninja will navigate to the corresponding area in the intermediate representation.

## Running Experiments
As part of this repository, there is an `experiments` module which can be run using `run_experiment.py` to test various configurations of the `Solver`. To run an experiment, use the following commands.

```bash
cd mbased/
mv run_experiment.py ..
cd ..
python3 run_experiment.py

# For the possible argument options, run the following.
python3 run_experiment.py --help
```

## Contributing
To contribute to this project, please open a pull request with your changes. If you are unsure about the changes you want to make, please open an issue to discuss it with one of the authors. For code health, please ensure that your code is clear and formatted. You can use the `black` code formatter to format your code. To install `black`, run `pip install black`. To format your code, run the following command.

```
python -m black *.py */*.py
```

Formatting is checked using a GitHub action, so please ensure that your code is formatted before opening a pull request. We also try and follow good practices by adding type hints to our code.

## Authors
MBASED was developed by Nitin Krishnaswamy, Sanjana Mandadi, Micah Nelson, and Timothy Slater for GSET 2024. Their project was advised by Benson Liu as their project mentor and Aashi Misha as their project Resident Teaching Assistant (RTA). For questions or requests for additional information, please contact the authors.

```

`__init__.py`:

```py
try:
    from binaryninja.log import log_info, log_error
    from binaryninja.binaryview import BinaryViewType
    from binaryninja.plugin import PluginCommand
    from binaryninja.plugin import BackgroundTaskThread
    from binaryninja.enums import MediumLevelILOperation

    from mbased.parser.lex import Lexer
    from mbased.parser.parse import Parser
    from mbased.parser.ast import Expr

    from mbased.solver import Solver
    from mbased.utils.coding import DictionaryEncoder, DictionaryDecoder

    class MBADeobfuscationInBackground(BackgroundTaskThread):
        """Assigns a thread to MBA deobfuscation"""

        def __init__(self, bv: BinaryViewType, msg: str):
            """Initiates the MBADeobfuscationInBackground object and defines bv attribute"""
            BackgroundTaskThread.__init__(self, msg, True)
            self.bv = bv

        def run(self):
            """Logs all program if statements to BinaryNinja log"""
            for instr in self.bv.mlil_instructions:
                if instr.operation == MediumLevelILOperation.MLIL_IF:
                    try:
                        encoder: DictionaryEncoder = DictionaryEncoder()
                        encoded_instr: str = encoder.encode(str(instr))

                        l: Lexer = Lexer()
                        l.lex(encoded_instr)

                        p: Parser = Parser()
                        ast: Expr = p.parse(l.getTokens())

                        passes: list[str] = ["sympy_pass"]
                        s: Solver = Solver(passes)
                        simplified_ast: Expr = s.run(ast)

                        decoded_instr: str = DictionaryDecoder(
                            encoder.get_encoded_dictionary()
                        ).decode(str(simplified_ast))

                        log_info(f"{hex(instr.address)}: {decoded_instr}", "MBASED")
                    except Exception as e:
                        log_error(f"{hex(instr.address)}: {e}", "MBASED")

    def mba_deobfuscation_in_background(bv: BinaryViewType):
        """Creates a background task and starts MBA deobfuscation"""
        background_task: MBADeobfuscationInBackground = MBADeobfuscationInBackground(
            bv, "Starting MBASED..."
        )
        background_task.start()

    PluginCommand.register(
        "MBASED: Simplify all MBA expressions.",
        "Simplifying booleans...",
        mba_deobfuscation_in_background,
    )
except:
    import sys

    print("Not in Binary Ninja.", file=sys.stderr)

```

`examples/fact.c`:

```c
#include <stdio.h>
#include <stdlib.h>

int fact(int n) {
  if (n < 0) {
    return -1;
  } else if (n == 0) {
    return 1;
  }
  return n * fact(n - 1);
}

int main(int argc, char **argv) {
  if (argc != 2) {
    fprintf(stderr, "Usage: %s <n>\n", argv[0]);
    return 1;
  }

  int n = atoi(argv[1]);
  return fact(n);
}

```

`examples/fib.c`:

```c
#include <stdio.h>
#include <stdlib.h>

int fib(int n) {
  if (n < 0) {
    return -1;
  } else if (n == 0 || n == 1) {
    return n;
  }
  return fib(n - 1) + fib(n - 2);
}

int main(int argc, char **argv) {
  if (argc != 2) {
    fprintf(stderr, "Usage: %s <n>\n", argv[0]);
    return 1;
  }

  int n = atoi(argv[1]);
  return fib(n);
}

```

`experiments/experiment.py`:

```py
import sys

from mbased.experiments.generator import BooleanGenerator
from mbased.experiments.obfuscator import MBAObfuscator

from mbased.parser.lex import Lexer
from mbased.parser.parse import Parser
from mbased.parser.ast import Expr

from mbased.solver import Solver

from mbased.utils.metrics import OpCounter, VarCounter


def count_ops(ast: Expr) -> int:
    oc: OpCounter = OpCounter()
    ast.accept(oc)
    return oc.getCount()


def count_vars(ast: Expr) -> int:
    vc: VarCounter = VarCounter()
    ast.accept(vc)
    return vc.getCount()


def run_experiment(
    passes: list[str], n: int = 100
) -> list[tuple[int, str, int, str, int, str, int]]:
    """
    Runs an experiment with the given passes and up to n variables.

    :param passes: The passes to run.
    :param n: The maximum number of variables.

    :return:

    (n, original, original_count, obfuscated, obfuscated_count, simplified, simplified_count)
    """
    if n < 2:
        n = 2

    res: list[tuple[int, str, int, str, int, str, int]] = (
        []
    )  # (n, original, original_count, obfuscated, obfuscated_count, simplified, simplified_count)

    bg: BooleanGenerator = BooleanGenerator()
    s: Solver = Solver(passes)

    for i in range(2, n + 1):
        print("========================================", file=sys.stderr)
        print(f"Running experiment with n={i}", file=sys.stderr)

        expr: str = bg.generate_expr(i)

        l: Lexer = Lexer()
        l.lex(expr)

        p: Parser = Parser()
        orig_ast: Expr = p.parse(l.tokens)
        print(f"Original expression: {orig_ast}", file=sys.stderr)

        orig_op_count = count_ops(orig_ast)
        print(f"Original Operation count: {orig_op_count}", file=sys.stderr)
        orig_var_count = count_vars(orig_ast)
        print(f"Original Variable count: {orig_var_count}", file=sys.stderr)

        obf_ast = MBAObfuscator().obfuscate(orig_ast)
        print(f"Obfuscated expression: {obf_ast}", file=sys.stderr)
        obf_op_count = count_ops(obf_ast)
        print(f"Obfuscated Operation count: {obf_op_count}", file=sys.stderr)
        obf_var_count = count_vars(obf_ast)
        print(f"Obfuscated Variable count: {obf_var_count}", file=sys.stderr)

        simplified_ast = s.run(obf_ast)
        print(f"Simplified expression: {simplified_ast}", file=sys.stderr)
        simplified_op_count = count_ops(simplified_ast)
        print(f"Simplified Operation count: {simplified_op_count}", file=sys.stderr)
        simplified_var_count = count_vars(simplified_ast)
        print(f"Simplified Variable count: {simplified_var_count}", file=sys.stderr)

        res.append(
            (
                i,
                orig_ast,
                orig_op_count,
                orig_var_count,
                obf_ast,
                obf_op_count,
                obf_var_count,
                simplified_ast,
                simplified_op_count,
                simplified_var_count,
            )
        )

    return res

```

`experiments/generator.py`:

```py
"""
Generate random boolean expressions for testing purposes.
"""

import random

from mbased.utils.coding import NameGenerator


class BooleanGenerator:
    def __init__(self, seed: int = 1337):
        self.seed = seed
        self.random = random.Random(seed)
        self.ops = ["|", "&", "^"]

    def generate_expr(self, n: int = 2) -> str:
        """
        Generates a random boolean expression with n variables.
        """
        if n < 2:
            raise ValueError("n must be greater than 1")

        ng: NameGenerator = NameGenerator()

        res: list[str] = []
        paren_count: int = 0

        if self.random.randint(0, 1):
            res.append("(")
            paren_count += 1
        if self.random.randint(0, 1):
            res.append("!")
        res.append(next(ng.generate_unique_uppercase_string()))

        for _ in range(1, n):
            res.append(self.random.choice(self.ops))
            closing_paren = False

            if self.random.randint(0, 1):
                if paren_count > 0 and self.random.randint(0, 1):
                    closing_paren = True
                else:
                    res.append("(")
                    paren_count += 1

            if self.random.randint(0, 1):
                res.append("!")

            res.append(next(ng.generate_unique_uppercase_string()))

            if closing_paren:
                res.append(")")
                paren_count -= 1

        while paren_count > 0:
            res.append(")")
            paren_count -= 1

        return " ".join(res)


if __name__ == "__main__":
    generator = BooleanGenerator(None)
    for i in range(2, 101):
        print(f"N={i}: {generator.generate_expr(i)}", end="\n\n")

```

`experiments/obfuscator.py`:

```py
"""
Apply mixed-boolean arithmetic (MBA) obfuscation to a given boolean expression.

MBAObfucator takes an approach of apply transformation to the given boolean expression
based on the abstract syntax tree (AST) of the expression. The transformation is applied
based on a few rules which are taken from the Obfuscator LLVM project. The rules are shown
at https://github.com/obfuscator-llvm/obfuscator/wiki/Instructions-Substitution
"""

from typing_extensions import override

from mbased.parser.visitor import RetVisitor

from mbased.parser.ast import (
    Node,
    Expr,
    TermExpr,
    OrExpr,
    AndExpr,
    XorExpr,
    ParenTerm,
    NotTerm,
    VarVar,
    TrueConst,
    FalseConst,
)


class MBAObfuscator(RetVisitor[Node]):
    def obfuscate(self, ast: Expr, n: int = 1):
        """
        Obfuscates the given AST.

        :param ast: The AST to obfuscate.
        :return: The obfuscated AST.
        """
        for _ in range(n):
            ast = ast.acceptRet(self)

        return ast

    @override
    def visitTermExpr(self, node: TermExpr) -> Node:
        first: Node = node.first.acceptRet(self)
        if node.second:
            second: Node = node.second.first.acceptRet(self)
            if isinstance(node.second, OrExpr):
                # a = b | c => a = (b & c) | (b ^ c)
                return TermExpr(
                    ParenTerm(TermExpr(first, AndExpr(second))),
                    OrExpr(ParenTerm(TermExpr(first, XorExpr(second)))),
                )
            elif isinstance(node.second, AndExpr):
                # a = b & c => a = (b ^ ~c) & b
                return TermExpr(
                    ParenTerm(TermExpr(first, XorExpr(NotTerm(second)))), AndExpr(first)
                )
            elif isinstance(node.second, XorExpr):
                # a = a ^ b => a = (~a & b) | (a & ~b)
                return TermExpr(
                    ParenTerm(TermExpr(NotTerm(first), AndExpr(second))),
                    OrExpr(ParenTerm(TermExpr(first, AndExpr(NotTerm(second))))),
                )
        return TermExpr(first)

    @override
    def visitOrExpr(self, node: OrExpr) -> Node:
        first: Node = node.first.acceptRet(self)
        second: Node = node.second.acceptRet(self)
        return OrExpr(first, second)

    @override
    def visitAndExpr(self, node: AndExpr) -> Node:
        first: Node = node.first.acceptRet(self)
        second: Node = node.second.acceptRet(self)
        return AndExpr(first, second)

    @override
    def visitXorExpr(self, node: XorExpr) -> Node:
        first: Node = node.first.acceptRet(self)
        second: Node = node.second.acceptRet(self)
        return XorExpr(first, second)

    @override
    def visitParenTerm(self, node: ParenTerm) -> Node:
        return ParenTerm(node.first.acceptRet(self))

    @override
    def visitNotTerm(self, node: NotTerm) -> Node:
        return NotTerm(node.first.acceptRet(self))

    @override
    def visitVarVar(self, node: VarVar) -> Node:
        return VarVar(node.name)

    @override
    def visitTrueConst(self, node: TrueConst) -> Node:
        return TrueConst()

    @override
    def visitFalseConst(self, node: FalseConst) -> Node:
        return FalseConst()

```

`parser/ast.py`:

```py
"""
Abstract Syntax Tree (AST) for boolean expressions.
"""

from typing import TypeVar, Optional
from mbased.parser.visitor import Visitor, ParamVisitor, RetVisitor, RetParamVisitor

T = TypeVar("T")
R = TypeVar("R")


class Node:
    """
    An interface class to represent a node in the AST.
    """

    pass


# =============================================================================


class Expr(Node):
    """
    An interface class to represent a full expression.
    """

    pass


class ExprPrime(Node):
    """
    An interface class to represent an expr prime expression. Used to eliminate left-recursion.
    """

    pass


class Term(Node):
    """
    An interface class to represent a term. Used to add precedence to the grammar.
    """

    pass


class Var(Term):
    """
    An interface class to represent a var. Used for constants and variables.
    """


# =============================================================================


class TermExpr(Expr):
    """
    A class to represent an expression containing only a Term node.

    Attributes
    ----------
    first : Term
        The variable contained by the TermExpr.

    second : Optional[ExprPrime]
    """

    def __init__(self, first: Term, second: Optional[ExprPrime] = None):
        self.first = first
        self.second = second

    def __str__(self) -> str:
        if self.second is not None:
            return f"{self.first} {self.second}"

        return str(self.first)

    def accept(self, v: Visitor) -> None:
        v.visitTermExpr(self)

    def acceptParam(self, v: ParamVisitor[T], param: T) -> None:
        v.visitTermExpr(self, param)

    def acceptRet(self, v: RetVisitor[R]) -> R:
        return v.visitTermExpr(self)

    def acceptParamRet(self, v: RetParamVisitor[T, R], param: T) -> R:
        return v.visitTermExpr(self, param)


# =============================================================================


class OrExpr(ExprPrime):
    """
    A class to represent an OR expression.

    Attributes
    ----------
    first : Term
        The first part of the OR expression.

    second : Optional[ExprPrime]
        The second (or following) part of the OR expression.
    """

    def __init__(self, first: Term, second: Optional[ExprPrime] = None):
        self.first = first
        self.second = second

    def __str__(self) -> str:
        if self.second is not None:
            return f"| {self.first} {self.second}"

        return f"| {self.first}"

    def accept(self, v: Visitor) -> None:
        v.visitOrExpr(self)

    def acceptParam(self, v: ParamVisitor[T], param: T) -> None:
        v.visitOrExpr(self, param)

    def acceptRet(self, v: RetVisitor[R]) -> R:
        return v.visitOrExpr(self)

    def acceptParamRet(self, v: RetParamVisitor[T, R], param: T) -> R:
        return v.visitOrExpr(self, param)


class AndExpr(ExprPrime):
    """
    A class to represent an AND expression.

    Attributes
    ----------
    first : Term
        The first part of the AND expression.

    second : Optional[ExprPrime]
        The second (or following) part of the AND expression.
    """

    def __init__(self, first: Term, second: Optional[ExprPrime] = None):
        self.first = first
        self.second = second

    def __str__(self) -> str:
        if self.second is not None:
            return f"& {self.first} {self.second}"

        return f"& {self.first}"

    def accept(self, v: Visitor) -> None:
        v.visitAndExpr(self)

    def acceptParam(self, v: ParamVisitor[T], param: T) -> None:
        v.visitAndExpr(self, param)

    def acceptRet(self, v: RetVisitor[R]) -> R:
        return v.visitAndExpr(self)

    def acceptParamRet(self, v: RetParamVisitor[T, R], param: T) -> R:
        return v.visitAndExpr(self, param)


class XorExpr(ExprPrime):
    """
    A class to represent an XOR expression.

    Attributes
    ----------
    first : Term
        The first part of the XOR expression.

    second : Optional[ExprPrime]
        The second (or following) part of the XOR expression.
    """

    def __init__(self, first: Term, second: Optional[ExprPrime] = None):
        self.first = first
        self.second = second

    def __str__(self) -> str:
        if self.second is not None:
            return f"^ {self.first} {self.second}"

        return f"^ {self.first}"

    def accept(self, v: Visitor) -> None:
        v.visitXorExpr(self)

    def acceptParam(self, v: ParamVisitor[T], param: T) -> None:
        v.visitXorExpr(self, param)

    def acceptRet(self, v: RetVisitor[R]) -> R:
        return v.visitXorExpr(self)

    def acceptParamRet(self, v: RetParamVisitor[T, R], param: T) -> R:
        return v.visitXorExpr(self, param)


# =============================================================================


class ParenTerm(Term):
    """
    A class to represent a parenthesized term.

    Attributes
    ----------
    first : Expr
        The first part of the parenthesized term.
    """

    def __init__(self, first: Expr):
        self.first = first

    def __str__(self) -> str:
        return f"({self.first})"

    def accept(self, v: Visitor) -> None:
        v.visitParenTerm(self)

    def acceptParam(self, v: ParamVisitor[T], param: T) -> None:
        v.visitParenTerm(self, param)

    def acceptRet(self, v: RetVisitor[R]) -> R:
        return v.visitParenTerm(self)

    def acceptParamRet(self, v: RetParamVisitor[T, R], param: T) -> R:
        return v.visitParenTerm(self, param)


class NotTerm(Term):
    """
    A class to represent a NOT term.

    Attributes
    ----------
    first : Term
        The first part of the NOT term.
    """

    def __init__(self, first: Term):
        self.first = first

    def __str__(self) -> str:
        return f"!{self.first}"

    def accept(self, v: Visitor) -> None:
        v.visitNotTerm(self)

    def acceptParam(self, v: ParamVisitor[T], param: T) -> None:
        v.visitNotTerm(self, param)

    def acceptRet(self, v: RetVisitor[R]) -> R:
        return v.visitNotTerm(self)

    def acceptParamRet(self, v: RetParamVisitor[T, R], param: T) -> R:
        return v.visitNotTerm(self, param)


# =============================================================================


class VarVar(Term):
    """
    A class to represent a variable from A-Z.

    Attributes
    ----------
    name : str
        The name of the variable.
    """

    def __init__(self, name: str) -> None:
        self.name = name

    def __str__(self) -> str:
        return self.name

    def accept(self, v: Visitor) -> None:
        v.visitVarVar(self)

    def acceptParam(self, v: ParamVisitor[T], param: T) -> None:
        v.visitVarVar(self, param)

    def acceptRet(self, v: RetVisitor[R]) -> R:
        return v.visitVarVar(self)

    def acceptParamRet(self, v: RetParamVisitor[T, R], param: T) -> R:
        return v.visitVarVar(self, param)


class TrueConst(Var):
    """
    Represents the constant TRUE
    """

    def __str__(self) -> str:
        return "t"

    def accept(self, v: Visitor) -> None:
        v.visitTrueConst(self)

    def acceptParam(self, v: ParamVisitor[T], param: T) -> None:
        v.visitTrueConst(self, param)

    def acceptRet(self, v: RetVisitor[R]) -> R:
        return v.visitTrueConst(self)

    def acceptParamRet(self, v: RetParamVisitor[T, R], param: T) -> R:
        return v.visitTrueConst(self, param)


class FalseConst(Var):
    """
    Represents the constant FALSE.
    """

    def __str__(self) -> str:
        return "f"

    def accept(self, v: Visitor) -> None:
        v.visitFalseConst(self)

    def acceptParam(self, v: ParamVisitor[T], param: T) -> None:
        v.visitFalseConst(self, param)

    def acceptRet(self, v: RetVisitor[R]) -> R:
        return v.visitFalseConst(self)

    def acceptParamRet(self, v: RetParamVisitor[T, R], param: T) -> R:
        return v.visitFalseConst(self, param)

```

`parser/lex.py`:

```py
import re
import sys


class Lexer:
    terminals: str = r"\&|\||\^|\!|\(|\)|[A-Z]+|t|f"
    ws: str = r"\s|\t|\n|\r"
    eof: str = r"\Z"

    def __init__(self) -> None:
        self.tokens: list[str] = []

    @staticmethod
    def error(msg: str) -> None:
        raise Exception(msg)

    def getTokens(self) -> list[str]:
        return self.tokens

    def lex(self, prog: str) -> None:
        p: re.Pattern[str] = re.compile(f"{Lexer.terminals}|{Lexer.ws}|{Lexer.eof}")
        last: int = 0
        for m in p.finditer(prog):
            token: str = m.group()

            if m.start() != last:
                Lexer.error(
                    f"Invalid character, {prog[last]}, at {m.start()}:{m.end()}"
                )

            if not re.match(Lexer.ws, token):
                if re.match(Lexer.eof, token):
                    self.tokens.append("<EOF>")
                else:
                    self.tokens.append(token)

            last = m.end()

```

`parser/parse.py`:

```py
from typing import Optional

from mbased.parser.ast import (
    Expr,
    ExprPrime,
    Term,
    Var,
    TermExpr,
    OrExpr,
    AndExpr,
    XorExpr,
    ParenTerm,
    NotTerm,
    VarVar,
    TrueConst,
    FalseConst,
)


import re
import sys


class Parser:
    """
    Parser object for building a boolean expression AST.
    """

    def __init__(self) -> None:
        """
        Initializes the parser.
        """
        self.pos: int = -1

    @staticmethod
    def error(msg: str, pos: int):
        raise Exception(f"Parse error: {msg} at position {pos}")

    def parse(self, tokens: list[str]) -> Expr:
        """
        Parses given tokens.
        """
        self.tokens: list[str] = tokens

        # Initializes the first token
        self.advance()

        rv: Expr = self.expr()
        self.assert_end()
        return rv

    def assert_end(self) -> None:
        if self.next_token != "<EOF>":
            Parser.error(f"Expected end '<EOF>' but found {self.next_token}", self.pos)

    def eat(self, expected: str) -> None:
        if self.next_token == expected:
            self.advance()
        else:
            Parser.error(
                f"Expected '{expected}' but found '{self.next_token}'", self.pos
            )

    def advance(self) -> None:
        """
        Moves to the next token.
        """
        self.pos += 1
        self.next_token: str = self.tokens[self.pos]

    def expr(self) -> Expr:
        """
        Parses an expression.
        """
        if (
            self.next_token == "("
            or self.next_token == "!"
            or re.match("[A-Z]+|t|f", self.next_token)
        ):
            first: Term = self.term()
            second: Optional[ExprPrime] = self.expr_prime()

            if second is None:
                return TermExpr(first)
            else:
                return TermExpr(first, second)
        else:
            Parser.error(
                f"Expected (, !, [A-Z]+, t, or f but found '{self.next_token}'",
                self.pos,
            )

    def expr_prime(self) -> Optional[ExprPrime]:
        """
        Parses an expression prime.
        """
        if self.next_token == "|":
            self.eat("|")

            first: Term = self.term()
            second: Optional[ExprPrime] = self.expr_prime()

            if second is None:
                return OrExpr(first)
            else:
                return OrExpr(first, second)
        elif self.next_token == "&":
            self.eat("&")

            first: Term = self.term()
            second: Optional[ExprPrime] = self.expr_prime()

            if second is None:
                return AndExpr(first)
            else:
                return AndExpr(first, second)
        if self.next_token == "^":
            self.eat("^")

            first: Term = self.term()
            second: Optional[ExprPrime] = self.expr_prime()

            if second is None:
                return XorExpr(first)
            else:
                return XorExpr(first, second)
        elif self.next_token == ")" or self.next_token == "<EOF>":
            # Handles epsilon case
            return None
        else:
            Parser.error(
                f"Expected |, &, ^, ), or <EOF> but found '{self.next_token}'", self.pos
            )

    def term(self) -> Term:
        """
        Parses a term.
        """
        if self.next_token == "(":
            self.eat("(")
            first: Expr = self.expr()
            self.eat(")")
            return ParenTerm(first)
        elif self.next_token == "!":
            self.eat("!")
            first: Term = self.term()
            return NotTerm(first)
        elif re.match("[A-Z]+|t|f", self.next_token):
            return self.var()
        else:
            Parser.error(
                f"Expected (, !, [A-Z]+, t, or f but found '{self.next_token}'",
                self.pos,
            )

    def var(self) -> Var:
        """Parses a variable that represents a boolean expression"""
        if re.match("[A-Z]+", self.next_token):
            v: VarVar = VarVar(self.next_token)
            self.eat(self.next_token)
            return v
        elif self.next_token == "t":
            self.eat("t")
            return TrueConst()
        elif self.next_token == "f":
            self.eat("f")
            return FalseConst()
        else:
            Parser.error(
                f"Expected [A-Z]+, t, or f but found '{self.next_token}'", self.pos
            )

```

`parser/visitor.py`:

```py
from typing import TYPE_CHECKING, TypeVar, Generic
from abc import abstractmethod

if TYPE_CHECKING:
    from mbased.parser.ast import (
        TermExpr,
        OrExpr,
        AndExpr,
        XorExpr,
        ParenTerm,
        NotTerm,
        VarVar,
        TrueConst,
        FalseConst,
    )

R = TypeVar("R")
T = TypeVar("T")


class Visitor:
    """
    A visitor that visits each node in the AST.
    """

    def visitTermExpr(self, node: "TermExpr") -> None:
        node.first.accept(self)
        if node.second:
            node.second.accept(self)

    def visitOrExpr(self, node: "OrExpr") -> None:
        node.first.accept(self)
        if node.second:
            node.second.accept(self)

    def visitAndExpr(self, node: "AndExpr") -> None:
        node.first.accept(self)
        if node.second:
            node.second.accept(self)

    def visitXorExpr(self, node: "XorExpr") -> None:
        node.first.accept(self)
        if node.second:
            node.second.accept(self)

    def visitParenTerm(self, node: "ParenTerm") -> None:
        node.first.accept(self)

    def visitNotTerm(self, node: "NotTerm") -> None:
        node.first.accept(self)

    def visitVarVar(self, node: "VarVar") -> None:
        pass

    def visitTrueConst(self, node: "TrueConst") -> None:
        pass

    def visitFalseConst(self, node: "FalseConst") -> None:
        pass


class ParamVisitor(Generic[T]):
    """
    A visitor that visits each node in the AST and
    passes a parameter.
    """

    def visitTermExpr(self, node: "TermExpr", param: T) -> None:
        node.first.accept(self, param)
        if node.second:
            node.second.accept(self, param)

    def visitOrExpr(self, node: "OrExpr", param: T) -> None:
        node.first.accept(self, param)
        if node.second:
            node.second.accept(self, param)

    def visitAndExpr(self, node: "AndExpr", param: T) -> None:
        node.first.accept(self, param)
        if node.second:
            node.second.accept(self, param)

    def visitXorExpr(self, node: "XorExpr", param: T) -> None:
        node.first.accept(self, param)
        if node.second:
            node.second.accept(self, param)

    def visitParenTerm(self, node: "ParenTerm", param: T) -> None:
        node.first.accept(self, param)

    def visitNotTerm(self, node: "NotTerm", param: T) -> None:
        node.first.accept(self, param)

    def visitVarVar(self, node: "VarVar", param: T) -> None:
        pass

    def visitTrueConst(self, node: "TrueConst", param: T) -> None:
        pass

    def visitFalseConst(self, node: "FalseConst", param: T) -> None:
        pass


class RetVisitor(Generic[R]):
    """
    A visitor that visits each node in the AST and
    returns a value.
    """

    @abstractmethod
    def visitTermExpr(self, node: "TermExpr") -> R:
        pass

    @abstractmethod
    def visitOrExpr(self, node: "OrExpr") -> R:
        pass

    @abstractmethod
    def visitAndExpr(self, node: "AndExpr") -> R:
        pass

    @abstractmethod
    def visitXorExpr(self, node: "XorExpr") -> R:
        pass

    @abstractmethod
    def visitParenTerm(self, node: "ParenTerm") -> R:
        pass

    @abstractmethod
    def visitNotTerm(self, node: "NotTerm") -> R:
        pass

    @abstractmethod
    def visitVarVar(self, node: "VarVar") -> R:
        pass

    @abstractmethod
    def visitTrueConst(self, node: "TrueConst") -> R:
        pass

    @abstractmethod
    def visitFalseConst(self, node: "FalseConst") -> R:
        pass


class RetParamVisitor(Generic[T, R]):
    """
    A visitor that visits each node in the AST and
    returns a value and passes a parameter.
    """

    @abstractmethod
    def visitTermExpr(self, node: "TermExpr", param: T) -> R:
        pass

    @abstractmethod
    def visitOrExpr(self, node: "OrExpr", param: T) -> R:
        pass

    @abstractmethod
    def visitAndExpr(self, node: "AndExpr", param: T) -> R:
        pass

    @abstractmethod
    def visitXorExpr(self, node: "XorExpr", param: T) -> R:
        pass

    @abstractmethod
    def visitParenTerm(self, node: "ParenTerm", param: T) -> R:
        pass

    @abstractmethod
    def visitNotTerm(self, node: "NotTerm", param: T) -> R:
        pass

    @abstractmethod
    def visitVarVar(self, node: "VarVar", param: T) -> R:
        pass

    @abstractmethod
    def visitTrueConst(self, node: "TrueConst", param: T) -> R:
        pass

    @abstractmethod
    def visitFalseConst(self, node: "FalseConst", param: T) -> R:
        pass

```

`plugin.json`:

```json
{
    "pluginmetadataversion": 2,
    "name": "Mixed Boolean-Arithmetic (MBA) Deobfuscator",
    "type": [
        "helper"
    ],
    "api": [
        "python3"
    ],
    "description": "Automatically simplify mixed boolean-arithmetic (MBA) obfuscation expressions.",
    "longdescription": "This script will automatically simplify mixed boolean-arithmetic (MBA) obfuscation expressions used for obfuscation.",
    "license": {
        "name": "MIT",
        "text": "Copyright (c) 2024 Benson Liu\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
    },
    "platforms": [
        "Windows",
        "Linux",
        "Darwin"
    ],
    "installinstructions": {
        "Windows": "",
        "Linux": "",
        "Darwin": ""
    },
    "dependencies": {
        "pip": [
            "z3-solver",
            "sympy",
            "typing_extensions"
        ]
    },
    "version": "0.0.1",
    "author": "Benson Liu",
    "minimumbinaryninjaversion": 0
}
```

`requirements.txt`:

```txt
mpmath
sympy
typing_extensions
z3-solver

```

`run_experiment.py`:

```py
#!/usr/bin/env python
from mbased.experiments.experiment import run_experiment
import argparse
import matplotlib.pyplot as plt
import numpy as np


def generate_plot(res) -> None:
    orig_op_counts: list[int] = []
    obf_op_counts: list[int] = []
    simplified_op_counts: list[int] = []

    orig_var_counts: list[int] = []
    obf_var_counts: list[int] = []
    simplified_var_counts: list[int] = []

    labels: list[str] = []

    for experiment in res:
        orig_op_counts.append(experiment[2])
        obf_op_counts.append(experiment[5])
        simplified_op_counts.append(experiment[8])

        orig_var_counts.append(experiment[3])
        obf_var_counts.append(experiment[6])
        simplified_var_counts.append(experiment[9])

        labels.append(f"N={experiment[0]}")

    op_formatted_experiments: dict[str, list[int]] = {
        # "Original": orig_op_counts,
        "Obfuscated": obf_op_counts,
        "Simplified": simplified_op_counts,
    }

    var_formatted_experiments: dict[str, list[int]] = {
        # "Original": orig_var_counts,
        "Obfuscated": obf_var_counts,
        "Simplified": simplified_var_counts,
    }

    x: np.ndarray = np.arange(len(labels))
    width: float = 0.25
    multiplier: int = 0

    fig, axes = plt.subplots(2, 2, layout="constrained")
    ax1: plt.Axes = axes[0, 0]
    ax2: plt.Axes = axes[1, 0]
    ax3: plt.Axes = axes[0, 1]
    ax4: plt.Axes = axes[1, 1]

    for attribute, measurement in op_formatted_experiments.items():
        offset = width * multiplier
        rects = ax1.bar(x + offset, measurement, width, label=attribute)
        ax1.bar_label(rects, padding=3)
        multiplier += 1

    ax1.set_title("Number Operations", y=1.02)
    ax1.set_xticks(x + width, labels)
    ax1.legend(loc="upper left", ncols=3)
    ax1.tick_params(axis="both", which="major", labelsize=4, rotation=70)

    multiplier: int = 0

    for attribute, measurement in var_formatted_experiments.items():
        offset = width * multiplier
        rects = ax2.bar(x + offset, measurement, width, label=attribute)
        ax2.bar_label(rects, padding=3)
        multiplier += 1

    ax2.set_title("Number Variables", y=1.02)
    ax2.set_xticks(x + width, labels)
    ax2.legend(loc="upper left", ncols=3)
    ax2.tick_params(axis="both", which="major", labelsize=4, rotation=70)

    experiment_range: np.array = np.arange(len(res))

    for attribute, measurement in op_formatted_experiments.items():
        ax3.plot(experiment_range, measurement, label=attribute)

    ax3.legend(loc="upper left", ncols=3)

    ax3.set_title("Number Operations", y=1.02)
    ax3.set_xticks(x + width, labels)
    ax3.legend(loc="upper left", ncols=3)
    ax3.tick_params(axis="both", which="major", labelsize=4, rotation=70)

    for attribute, measurement in var_formatted_experiments.items():
        ax4.plot(experiment_range, measurement, label=attribute)

    ax4.legend(loc="upper left", ncols=3)

    ax4.set_title("Number Variables", y=1.02)
    ax4.set_xticks(x + width, labels)
    ax4.legend(loc="upper left", ncols=3)
    ax4.tick_params(axis="both", which="major", labelsize=4, rotation=70)

    plt.show()


if __name__ == "__main__":
    parser: argparse.ArgumentParser = argparse.ArgumentParser(
        description="Runs MBA simplification experiment"
    )
    parser.add_argument(
        "--plot", action="store_true", help="Display plots of the data."
    )

    parser.add_argument(
        "--npasses",
        type=int,
        nargs=1,
        help="Sets the number of passes to run.",
    )

    args: argparse.Namespace = parser.parse_args()

    passes: list[str] = ["sympy_pass"]

    if args.npasses:
        res = run_experiment(passes, args.npasses[0])
    else:
        res = run_experiment(passes)

    print("========================================")
    print(res)

    if args.plot:
        generate_plot(res)

```

`solver/__init__.py`:

```py
"""
    MBA solver module applying strategies to simplify the AST.

The Solver takes on the approach of applying passes to the AST in a
pipeline fashion. A pass is a transformation that simplifies the AST
in some way. The passes are defined in the passes directory.
"""

import sys
from importlib import import_module

from mbased.parser.ast import Expr


class Solver:
    def __init__(self, passes: list[str]):
        self.passes: list[str] = passes

    def get_module(self, name: str):
        # print(f"Importing {name}")
        return import_module(f"mbased.solver.passes.{name}")

    def run(self, ast: Expr) -> Expr:
        for m in map(self.get_module, self.passes):
            try:
                ast = m.run_pass(ast)
            except Exception as e:
                print(f"Error in {m.__name__}: {e}", file=sys.stderr)
                raise e
        return ast

```

`solver/passes/example_pass.py`:

```py
from typing_extensions import override

import sys

from mbased.parser.ast import AndExpr, OrExpr, Expr, NotExpr, ParenExpr, Var, VarExpr
from mbased.parser.visitor import Visitor, RetVisitor


def run_pass(ast: Expr) -> Expr:
    # Does analysis on the AST to find all symbols
    v: SymbolSetBuilder = SymbolSetBuilder()
    ast.accept(v)

    print(v.symbols, file=sys.stderr)

    # Translates the AST to a string
    t: TranslationVisitor = TranslationVisitor()
    p: str = ast.acceptRet(t)

    print(p, file=sys.stderr)

    return ast


class SymbolSetBuilder(Visitor):
    def __init__(self) -> None:
        self.symbols: set[str] = set()

    @override
    def visitVar(self, v: Var) -> None:
        self.symbols.add(v.name)


class TranslationVisitor(RetVisitor[str]):
    @override
    def visitVarExpr(self, vex: VarExpr) -> str:
        first: str = vex.first.acceptRet(self)
        if vex.second:
            return f"{first} {vex.second.acceptRet(self)}"
        else:
            return first

    @override
    def visitNotExpr(self, nex: NotExpr) -> str:
        return f"~{nex.expr.acceptRet(self)}"

    @override
    def visitParenExpr(self, pex: ParenExpr) -> str:
        return f"[{pex.expr.acceptRet(self)}]"

    @override
    def visitAndExpr(self, aex: AndExpr) -> str:
        return f"AND {aex.first.acceptRet(self)}"

    @override
    def visitOrExpr(self, oex: OrExpr) -> str:
        return f"OR {oex.first.acceptRet(self)}"

    @override
    def visitVar(self, v: Var) -> str:
        return v.name.lower()


if __name__ == "__main__":
    from parser.lex import Lexer
    from parser.parse import Parser

    prog: str = "A | B & C"
    l: Lexer = Lexer()
    l.lex(prog)

    p: Parser = Parser()
    ast: Expr = p.parse(l.tokens)

    run_pass(ast)

```

`solver/passes/sympy_pass.py`:

```py
from typing_extensions import override

from mbased.parser.ast import (
    Expr,
    TermExpr,
    OrExpr,
    AndExpr,
    XorExpr,
    ParenTerm,
    NotTerm,
    VarVar,
    TrueConst,
    FalseConst,
)
from mbased.parser.visitor import Visitor, RetVisitor
from mbased.parser.parse import Parser
from mbased.parser.lex import Lexer

import sympy
from sympy.logic.boolalg import Or, And, Xor, Not


def run_pass(ast: Expr) -> Expr:
    # Sympy visitor for mapping variable
    v: SympyMappingVisitor = SympyMappingVisitor()
    ast.accept(v)

    tv: TranslateToSympy = TranslateToSympy(v.symbols)

    p: sympy.Basic = ast.acceptRet(tv)

    simplifiedExpr: sympy.Basic = sympy.simplify_logic(p)
    simplifiedStr: str = str(simplifiedExpr).replace("~", "!")

    l: Lexer = Lexer()
    l.lex(simplifiedStr)

    pa: Parser = Parser()
    ast: Expr = pa.parse(l.tokens)

    return ast


class SympyMappingVisitor(Visitor):
    """
    A visitor that visits each node in the AST and adds Var nodes to the symbols.
    """

    def __init__(self) -> None:
        self.symbols: dict[str, sympy.Symbol] = {}

    @override
    def visitVarVar(self, node: VarVar) -> None:
        self.symbols[node.name] = sympy.Symbol(node.name)


class TranslateToSympy(RetVisitor[sympy.Basic]):
    """
    A visitor that visits each node in the AST and
    returns an expression translated to Sympy logic.
    """

    def __init__(self, symbols: dict[str, sympy.Symbol]) -> None:
        self.symbols = symbols

    @override
    def visitTermExpr(self, node: TermExpr) -> sympy.Basic:
        first: sympy.Basic = node.first.acceptRet(self)
        if node.second:
            second: sympy.Basic = node.second.acceptRet(self)
            if isinstance(node.second, OrExpr):
                return Or(first, second)
            elif isinstance(node.second, AndExpr):
                return And(first, second)
            elif isinstance(node.second, XorExpr):
                return Xor(first, second)
        return first

    @override
    def visitOrExpr(self, node: OrExpr) -> sympy.Basic:
        first: sympy.Basic = node.first.acceptRet(self)
        if node.second:
            second: sympy.Basic = node.second.acceptRet(self)
            if isinstance(node.second, OrExpr):
                return Or(first, second)
            elif isinstance(node.second, AndExpr):
                return And(first, second)
            elif isinstance(node.second, XorExpr):
                return Xor(first, second)
        return first

    @override
    def visitAndExpr(self, node: AndExpr) -> sympy.Basic:
        first: sympy.Basic = node.first.acceptRet(self)
        if node.second:
            second: sympy.Basic = node.second.acceptRet(self)
            if isinstance(node.second, OrExpr):
                return Or(first, second)
            elif isinstance(node.second, AndExpr):
                return And(first, second)
            elif isinstance(node.second, XorExpr):
                return Xor(first, second)
        return first

    @override
    def visitXorExpr(self, node: XorExpr) -> sympy.Basic:
        first: sympy.Basic = node.first.acceptRet(self)
        if node.second:
            second: sympy.Basic = node.second.acceptRet(self)
            if isinstance(node.second, OrExpr):
                return Or(first, second)
            elif isinstance(node.second, AndExpr):
                return And(first, second)
            elif isinstance(node.second, XorExpr):
                return Xor(first, second)
        return first

    @override
    def visitParenTerm(self, node: ParenTerm) -> sympy.Basic:
        return node.first.acceptRet(self)

    @override
    def visitNotTerm(self, node: NotTerm) -> sympy.Basic:
        return Not(node.first.acceptRet(self))

    @override
    def visitVarVar(self, node: VarVar) -> sympy.Basic:
        return self.symbols[node.name]

    @override
    def visitTrueConst(self, node: TrueConst) -> sympy.Basic:
        return sympy.true

    @override
    def visitFalseConst(self, node: FalseConst) -> sympy.Basic:
        return sympy.false


if __name__ == "__main__":
    prog = "B & A | !A"
    l: Lexer = Lexer()
    l.lex(prog)

    p: Parser = Parser()
    ast: Expr = p.parse(l.tokens)

    simplified_ast: Expr = run_pass(ast)

    assert str(simplified_ast) == "B"

```

`solver/passes/template_pass.py`:

```py
from mbased.parser.ast import Expr
from mbased.parser.visitor import Visitor


def run_pass(ast: Expr) -> Expr:
    # Sample visitor
    v: TemplateVisitor = TemplateVisitor()
    ast.accept(v)

    return ast


class TemplateVisitor(Visitor):
    pass

```

`solver/passes/z3_pass.py`:

```py
from typing_extensions import override

import html, re

from mbased.parser.ast import (
    Expr,
    TermExpr,
    OrExpr,
    AndExpr,
    XorExpr,
    ParenTerm,
    NotTerm,
    VarVar,
    TrueConst,
    FalseConst,
)
from mbased.parser.visitor import Visitor, RetVisitor
from mbased.parser.parse import Parser
from mbased.parser.lex import Lexer

import z3


def run_pass(ast: Expr) -> Expr:
    v: Z3MappingVisitor = Z3MappingVisitor()
    ast.accept(v)

    t: TranslateToZ3 = TranslateToZ3(v.symbols)
    p: z3.ExprRef = ast.acceptRet(t)
    simplifiedExpr: z3.ExprRef = z3.simplify(p)

    # Quick hack to force z3 into html mode
    # so we can parse the simplified expression
    # https://ericpony.github.io/z3py-tutorial/advanced-examples.htm
    z3.set_option(html_mode=True)

    simplifiedStr: str = str(simplifiedExpr)
    simplifiedStr = (
        html.unescape(simplifiedStr)
        .replace(chr(8744), "|")
        .replace(chr(8743), "&")
        .replace(chr(172), "!")
    )
    # z3's XOR pretty print does not print cleanly so
    # this is a hack to fix that

    # Pattern to match "Xor(A, B)"
    pattern = r"Xor\(([A-Z \|&!\^\(\)]+), ([A-Z \|&!\^\(\)]+)\)"
    # Replacement string using backreferences to capture groups
    replacement = r"\1 ^ \2"
    # Performing the replacement. Loop to catch nested Xor calls
    while re.match(pattern, simplifiedStr):
        simplifiedStr = re.sub(pattern, replacement, simplifiedStr)

    l: Lexer = Lexer()
    l.lex(simplifiedStr)

    pa: Parser = Parser()
    ast: Expr = pa.parse(l.tokens)

    return ast


class Z3MappingVisitor(Visitor):
    def __init__(self) -> None:
        self.symbols: dict[str, z3.Bool] = {}

    @override
    def visitVarVar(self, node: VarVar) -> None:
        self.symbols[node.name] = z3.Bool(node.name)


class TranslateToZ3(RetVisitor[z3.ExprRef]):
    def __init__(self, symbols: dict[str, z3.Bool]) -> None:
        self.symbols: dict[str, z3.Bool] = symbols

    @override
    def visitTermExpr(self, node: TermExpr) -> z3.ExprRef:
        first: z3.ExprRef = node.first.acceptRet(self)
        if node.second:
            second: z3.ExprRef = node.second.acceptRet(self)
            if isinstance(node.second, OrExpr):
                return z3.Or(first, second)
            elif isinstance(node.second, AndExpr):
                return z3.And(first, second)
            elif isinstance(node.second, XorExpr):
                return z3.Xor(first, second)
        return first

    @override
    def visitOrExpr(self, node: OrExpr) -> z3.ExprRef:
        first: z3.ExprRef = node.first.acceptRet(self)
        if node.second:
            second: z3.ExprRef = node.second.acceptRet(self)
            if isinstance(node.second, OrExpr):
                return z3.Or(first, second)
            elif isinstance(node.second, AndExpr):
                return z3.And(first, second)
            elif isinstance(node.second, XorExpr):
                return z3.Xor(first, second)
        return first

    @override
    def visitAndExpr(self, node: AndExpr) -> z3.ExprRef:
        first: z3.ExprRef = node.first.acceptRet(self)
        if node.second:
            second: z3.ExprRef = node.second.acceptRet(self)
            if isinstance(node.second, OrExpr):
                return z3.Or(first, second)
            elif isinstance(node.second, AndExpr):
                return z3.And(first, second)
            elif isinstance(node.second, XorExpr):
                return z3.Xor(first, second)
        return first

    @override
    def visitXorExpr(self, node: XorExpr) -> z3.ExprRef:
        first: z3.ExprRef = node.first.acceptRet(self)
        if node.second:
            second: z3.ExprRef = node.second.acceptRet(self)
            if isinstance(node.second, OrExpr):
                return z3.Or(first, second)
            elif isinstance(node.second, AndExpr):
                return z3.And(first, second)
            elif isinstance(node.second, XorExpr):
                return z3.Xor(first, second)
        return first

    @override
    def visitParenTerm(self, node: ParenTerm) -> z3.ExprRef:
        return node.first.acceptRet(self)

    @override
    def visitNotTerm(self, node: NotTerm) -> z3.ExprRef:
        return z3.Not(node.first.acceptRet(self))

    @override
    def visitVarVar(self, node: VarVar) -> z3.ExprRef:
        return self.symbols[node.name]

    @override
    def visitTrueConst(self, node: TrueConst) -> z3.ExprRef:
        return z3.BoolVal(True)

    @override
    def visitFalseConst(self, node: FalseConst) -> z3.ExprRef:
        return z3.BoolVal(False)


if __name__ == "__main__":
    prog: str = "!(!(B | !C))"
    l: Lexer = Lexer()
    l.lex(prog)

    p: Parser = Parser()
    ast: Expr = p.parse(l.tokens)

    ast = run_pass(ast)

    assert str(ast) == "B | !C"

```

`solver/verifier.py`:

```py
# TODO: Add verifier for simplified boolean expressions.

```

`tests/test_coding.py`:

```py
from unittest import TestCase
from utils.coding import DictionaryEncoder, DictionaryDecoder

# TODO: rewrite this with subtests and using a bidirectional hash map
# to represent the tabled test cases since they are repetitive.


class TestDictionaryEncoder(TestCase):
    """
    A class to test the DictionaryEncoder class.

    Methods
    -------
    test_encode() -> None:
        Tests the encode method.
    """

    def test_encode(self) -> None:
        """
        Tests the encode method.
        """
        test_cases_encoded: dict[str, str] = {
            "if (([ebp_1 + 0x14].b == 0 || [ebp_1 + 0x14].b != 0 && [ebp_1 + 0x14].c != 0) || ![ebp_1 + 0x14] == 0) then 387 @ 0x8040da8 else 388 @ 0x8040d8b": "( ( A | ! A & ! B ) | ! C )",
            "if ([ebp_1 + 0x14].b == 0 || [ebp_1 + 0x14].b != 0) then 387 @ 0x8040da8 else 388 @ 0x8040d8b": "( A | ! A )",
            "while (x == 3 && y >= 2):": "( A & B )",
            "if ([ebp_1 + 0x14].b == 0 || [ebp_1 + 0x14].b != 0 && [ebp_1 + 0x14].c != 0) || (![ebp_1 + 0x14] == 0) then 387 @ 0x8040da8 else 388 @ 0x8040d8b": "( A | ! A & ! B ) | ( ! C )",
        }
        for encoded_test in test_cases_encoded:
            encoder: DictionaryEncoder = DictionaryEncoder()
            encoded_str: str = encoder.encode(encoded_test)
            answer: str = test_cases_encoded.get(encoded_test)
            self.assertEqual(
                encoded_str, answer, "Two values are not equal to each other..."
            )


class TestDictionaryDecoder(TestCase):
    """
    A class to test the DictionaryDecoder class.

    Methods
    -------
    test_decode() -> None:
        Tests the decode method.
    """

    def test_decode(self) -> None:
        """
        Tests the encode method.
        """
        test_cases_encoded: dict[str, str] = {
            "if (([ebp_1 + 0x14].b == 0 || [ebp_1 + 0x14].b != 0 && [ebp_1 + 0x14].c != 0) || ![ebp_1 + 0x14] == 0) then 387 @ 0x8040da8 else 388 @ 0x8040d8b": "( ( A | ! A & ! B ) | ! C )",
            "if ([ebp_1 + 0x14].b == 0 || [ebp_1 + 0x14].b != 0) then 387 @ 0x8040da8 else 388 @ 0x8040d8b": "( A | ! A )",
            "while (x == 3 && y >= 2):": "( A & B )",
            "if ([ebp_1 + 0x14].b == 0 || [ebp_1 + 0x14].b != 0 && [ebp_1 + 0x14].c != 0) || (![ebp_1 + 0x14] == 0) then 387 @ 0x8040da8 else 388 @ 0x8040d8b": "( A | ! A & ! B ) | ( ! C )",
        }

        test_cases_decoded: dict[str, str] = {
            "( ( A | ! A & ! B ) | ! C )": "( ( [ebp_1 + 0x14].b == 0 || [ebp_1 + 0x14].b != 0 && [ebp_1 + 0x14].c != 0 ) || [ebp_1 + 0x14] != 0 )",
            "( A | ! A )": "( [ebp_1 + 0x14].b == 0 || [ebp_1 + 0x14].b != 0 )",
            "( A & B )": "( x == 3 && y >= 2 )",
            "( A | ! A & ! B ) | ( ! C )": "( [ebp_1 + 0x14].b == 0 || [ebp_1 + 0x14].b != 0 && [ebp_1 + 0x14].c != 0 ) || ( [ebp_1 + 0x14] != 0 )",
        }

        for encoded_test in test_cases_encoded:
            encoder: DictionaryEncoder = DictionaryEncoder()
            encoded_str: str = encoder.encode(encoded_test)
            answer: str = test_cases_encoded.get(encoded_test)

            decoder: DictionaryDecoder = DictionaryDecoder(
                encoder.get_encoded_dictionary()
            )
            decoded_str: str = decoder.decode(answer)
            # print(decoded_str)
            answer: str = test_cases_decoded.get(answer)
            # print(answer)
            self.assertEqual(
                decoded_str, answer, "Two values are not equal to each other..."
            )

```

`tests/test_lex.py`:

```py
import unittest
from parser.lex import Lexer


class TestLexer(unittest.TestCase):
    def test_or(self) -> None:
        prog = "A|B"
        l: Lexer = Lexer()
        l.lex(prog)
        self.assertEqual(l.getTokens(), ["A", "|", "B", "<EOF>"])

    def test_and(self) -> None:
        prog = "A & C"
        l: Lexer = Lexer()
        l.lex(prog)
        self.assertEqual(l.getTokens(), ["A", "&", "C", "<EOF>"])

    def test_xor(self) -> None:
        prog = "A ^ B"
        l: Lexer = Lexer()
        l.lex(prog)
        self.assertEqual(l.getTokens(), ["A", "^", "B", "<EOF>"])

    def test_not(self) -> None:
        prog = "! A"
        l: Lexer = Lexer()
        l.lex(prog)
        self.assertEqual(l.getTokens(), ["!", "A", "<EOF>"])

    def test_lex(self) -> None:
        prog: str = "(A & B) | !C & t ^ f"
        l: Lexer = Lexer()
        l.lex(prog)
        self.assertEqual(
            l.getTokens(),
            ["(", "A", "&", "B", ")", "|", "!", "C", "&", "t", "^", "f", "<EOF>"],
        )

```

`tests/test_metrics.py`:

```py
from unittest import TestCase

from parser.ast import Expr
from parser.parse import Parser
from utils.metrics import OpCounter


class TestCount(TestCase):
    def test_counter(self) -> None:
        p: Parser = Parser()
        tree: Expr = p.parse(["!", "(", "A", "&", "!", "B", "|", "C", ")", "<EOF>"])
        counter: OpCounter = OpCounter()
        self.assertEqual(counter.getCount(), 0)

        tree.accept(counter)

        self.assertEqual(counter.getCount(), 4)

```

`tests/test_parse.py`:

```py
from unittest import TestCase

from parser.ast import Expr
from parser.parse import Parser


class TestParse(TestCase):
    def test_or(self) -> None:
        tokens: list[str] = ["A", "|", "B", "<EOF>"]
        p: Parser = Parser()
        ast: Expr = p.parse(tokens)
        self.assertEqual(
            str(ast),
            "A | B",
        )

    def test_and(self) -> None:
        tokens: list[str] = ["A", "&", "B", "<EOF>"]
        p: Parser = Parser()
        ast: Expr = p.parse(tokens)
        self.assertEqual(
            str(ast),
            "A & B",
        )

    def test_xor(self) -> None:
        tokens: list[str] = ["A", "^", "B", "<EOF>"]
        p: Parser = Parser()
        ast: Expr = p.parse(tokens)
        self.assertEqual(
            str(ast),
            "A ^ B",
        )

    def test_not(self) -> None:
        tokens: list[str] = ["!", "A", "<EOF>"]
        p: Parser = Parser()
        ast: Expr = p.parse(tokens)
        self.assertEqual(
            str(ast),
            "!A",
        )

    def test_parse(self) -> None:
        tokens: list[str] = [
            "!",
            "(",
            "A",
            "&",
            "!",
            "B",
            "|",
            "f",
            ")",
            "^",
            "t",
            "<EOF>",
        ]
        p: Parser = Parser()
        ast: Expr = p.parse(tokens)
        self.assertEqual(
            str(ast),
            "!(A & !B | f) ^ t",
        )

```

`utils/coding.py`:

```py
import string
import re
from typing import Iterator
import itertools


class NameGenerator:
    """
    A class to generate unique names for boolean conditions.

    Attributes
    ----------
    generated_dictionary_keys : dict
        A dictionary to store generated names for conditions.
    last_state : list
        A list to store the last state of generated names.

    Methods
    -------
    generate_name(conditional: str) -> str:
        Generates a unique name for a given condition.
    generate_unique_uppercase_string() -> any:
        Generates a unique uppercase string.
    """

    def __init__(self) -> None:
        """
        Constructs all the necessary attributes for the NameGenerator object.
        """
        self.generated_dictionary_keys: dict[str, str] = {}
        self.prev_state: list[str] = []

    def generate_name(self, conditional: str) -> str:
        """
        Generates a unique name for a given condition.

        Parameters
        ----------
        conditional : str
            The condition to generate a name for.

        Returns
        -------
        str
            The generated name.
        """
        replaced_conditional = re.sub("!=", "==", conditional)
        val: str | None = self.generated_dictionary_keys.get(replaced_conditional)
        if val is None:
            gen_key: str = next(self.generate_unique_uppercase_string())
            self.generated_dictionary_keys[replaced_conditional] = gen_key
            if conditional != replaced_conditional:
                return "! " + gen_key
            return gen_key
        else:
            if conditional != replaced_conditional:
                return "! " + val
            else:
                return val

    def generate_unique_uppercase_string(self) -> Iterator[str]:
        """
        Generates a unique uppercase string.
        }

        Yields
        ------
        str
            A unique uppercase string.
        """
        for length in itertools.count(1):
            for s in itertools.product(string.ascii_uppercase, repeat=length):
                if "".join(s) not in self.prev_state:
                    self.prev_state.append("".join(s))
                    yield "".join(s)

    def return_encoded_value(self) -> dict[str, str]:
        return self.generated_dictionary_keys


class DictionaryEncoder:
    """
    A class to encode boolean expressions using generated names.

    Attributes
    ----------
    name_generator : NameGenerator
        An instance of the NameGenerator class.

    Methods
    -------
    encode(mlil_if_string: str) -> str:
        Encodes a given MLIL if-string.
    """

    def __init__(self) -> None:
        """
        Constructs all the necessary attributes for the DictionaryEncoder object.
        """
        self.name_generator = NameGenerator()

    def encode(self, mlil_if_string: str) -> str:
        """
        Encodes a given MLIL if-string.

        Parameters
        ----------
        mlil_if_string : str
            The MLIL if-string to encode.

        Returns
        -------
        str
            The encoded string.
        """

        first_index: int = mlil_if_string.index("(")
        last_index: int = len(mlil_if_string) - mlil_if_string[::-1].index(")")

        condition: str = mlil_if_string[first_index:last_index]

        LOGICAL_OPERATORS: str = r"(\|\||&&|!(?!\=)|\(|\))"
        split_conditions: list[str] = re.split(LOGICAL_OPERATORS, condition)
        split_conditions = [cond.strip() for cond in split_conditions if cond.strip()]

        encoded_parts: list[str] = []

        for cond in split_conditions:
            if cond in {"||", "&&", "!", "(", ")"}:
                if cond == "||":
                    encoded_parts.append("|")
                elif cond == "&&":
                    encoded_parts.append("&")
                else:
                    encoded_parts.append(cond)
            else:
                code: str = self.name_generator.generate_name(cond)
                encoded_parts.append(code)

        return " ".join(encoded_parts)

    def get_encoded_dictionary(self) -> dict[str, str]:
        return self.name_generator.return_encoded_value()


class DictionaryDecoder:
    def __init__(self, generated_dictionary_keys):
        """
        Initialize the DictionaryDecoder with a given mapping.

        Parameters
        ----------
        mapping : dict
            A dictionary mapping encoded values to their original MLIL values.
        """
        self.mapping: dict[str, str] = generated_dictionary_keys

    def decode(self, encoded_str):
        """
        Decode an encoded boolean statement back to the original values.

        Parameters
        ----------
        encoded_str : str
            The encoded string.

        Returns
        -------
        str
            The decoded string.
        """

        LOGICAL_OPERATORS_DECODER: str = r"(\w+|\|\||&&|[!()&|])"
        tokens: list[str] = re.split(LOGICAL_OPERATORS_DECODER, encoded_str)
        tokens = [cond.strip() for cond in tokens if cond.strip()]
        decoded_parts: list[str] = []
        i: int = 0
        while i < len(tokens):
            if tokens[i] in {"|", "&", "(", ")"}:
                if tokens[i] == "|":
                    decoded_parts.append("||")
                elif tokens[i] == "&":
                    decoded_parts.append("&&")
                else:
                    decoded_parts.append(tokens[i])
            elif tokens[i] == "!":
                i += 1
                # TODO: Replace this code with a bidirectional hashmap
                replace_not_equals: str = list(self.mapping.keys())[
                    list(self.mapping.values()).index(tokens[i])
                ]
                replace_not_equals = re.sub("==", "!=", replace_not_equals)
                decoded_parts.append(replace_not_equals)
            else:
                decoded_parts.append(
                    list(self.mapping.keys())[
                        list(self.mapping.values()).index(tokens[i])
                    ]
                )
            i += 1

        return " ".join(decoded_parts)

```

`utils/metrics.py`:

```py
from typing import override

from mbased.parser.ast import OrExpr, AndExpr, XorExpr, NotTerm, VarVar
from mbased.parser.visitor import Visitor


class OpCounter(Visitor):
    """Counts the number of boolean operators visited"""

    def __init__(self) -> None:
        self._count: int = 0

    def getCount(self) -> int:
        return self._count

    @override
    def visitOrExpr(self, node: OrExpr) -> None:
        self._count += 1
        node.first.accept(self)
        if node.second:
            node.second.accept(self)

    @override
    def visitAndExpr(self, node: AndExpr) -> None:
        self._count += 1
        node.first.accept(self)
        if node.second:
            node.second.accept(self)

    @override
    def visitXorExpr(self, node: XorExpr) -> None:
        self._count += 1
        node.first.accept(self)
        if node.second:
            node.second.accept(self)

    @override
    def visitNotTerm(self, node: NotTerm) -> None:
        self._count += 1
        node.first.accept(self)


class VarCounter(Visitor):
    """Counts the number of boolean operators visited"""

    def __init__(self) -> None:
        self._count: int = 0

    def getCount(self) -> int:
        return self._count

    @override
    def visitVarVar(self, node: "VarVar") -> None:
        self._count += 1

```