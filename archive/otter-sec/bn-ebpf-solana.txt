Project Path: arc_otter-sec_bn-ebpf-solana_6yrw_nz9

Source Tree:

```txt
arc_otter-sec_bn-ebpf-solana_6yrw_nz9
├── LICENSE
├── README.md
├── __init__.py
├── anchor.py
├── assets
│   ├── lift.png
│   └── struct.png
├── context.txt
├── ebpf.py
├── idl_utils.py
├── instr.py
├── logo.png
├── mcp_utils.py
├── plugin.json
├── requirements.txt
├── sidebar_ui.py
├── solana.py
├── solanaview.py
├── system.txt
└── types.c

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 OtterSec LLC.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# bn-ebpf-solana

A pure-python Binary Ninja plugin for Solana EBPF.

## Regular install from plugin manager

Be sure to install both `bn-ebpf-solana` and `binary_ninja_mcp` from the plugin manager

Tested on Binary Ninja `5.0.7486-Stable`

## Manual installation (advanced, latest features)

This is only needed if you wish to tinker with the plugin to modify it.

Clone this [repo](https://github.com/otter-sec/bn-ebpf-solana), aswell as the [mcp plugin repo](https://github.com/fosdickio/binary_ninja_mcp), in your Binja `plugins` folder, located in the [user folder](https://docs.binary.ninja/guide/index.html#user-folder).

Now install the requirements :
- either by running `Install python3 module` in Binja's `command palette` (Ctrl + P) and install the following modules

```
lief
anthropic
fastmcp
tenacity
rust_demangler  
pygments  
anchorpy  
solana  
solders
base58
```

- or by going to the [user folder](https://docs.binary.ninja/guide/index.html#user-folder) and installing the requirements.txt

Also for the MCP integration to work please install `mcp` globally (outside the binja venv) like so:

```
pip install mcp
```


See our [introductory blog post](https://osec.io/blog/2022-08-27-reverse-engineering-solana).

**Instruction lifting!**
![](https://github.com/otter-sec/bn-ebpf-solana/blob/master/assets/lift.png?raw=true)

**Solana SDK Structures!**
![](https://github.com/otter-sec/bn-ebpf-solana/blob/master/assets/struct.png?raw=true)

Copy this directory into your Binary Ninja plugins folder and restart.

## Features

- **Instruction Lifting**: All EBPF instructions are lifted to LLIL
- **Accurate Memory Maps**: We implement Solana-specific memory maps (0x{1/2/3/4}00000000 addresses for data/stack/heap/input)
- **Solana ELF Relocations**: Solana-specific ELF relocations
- **Syscall Function Signatures**: Full signatures for all of the Solana syscalls
- **(partial) Solana SDK Types**: Type definitions for all Solana SDK objects. (fully complete for C, in-progress for Rust)

### MCP integration

In order to use the MCP integration please set up your anthropic api key in the settings under

```
MCP settings > Anthropic API Key
```

You will now be able to use the side menu on the right, symbolized by an R. 
Click on any function to start prompting the model to call MCP actions, and to ultimately display a Rust version in the side panel

_TODO:_

- **Solana SDK Signature Matching**: Automatically match common Solana SDK functions.

## Debugging

```
[ScriptingProvider] ModuleNotFoundError: No module named 'lief'
```

Is `lief` installed?

Run the following in the Binja python console

```python
import lief
lief.__version__
```

If you get an error, refer to the **Installation** section

```

`__init__.py`:

```py
from binaryninja import CallingConvention, Architecture, log_error_for_exception

try:
    from binaryninjaui import Sidebar
    from .sidebar_ui import LLMDecompSidebarWidgetType
    Sidebar.addSidebarWidgetType(LLMDecompSidebarWidgetType())
except Exception:
    log_error_for_exception("Failed to load LLM Decompiler", "bn-ebpf-solana")

from .idl_utils import *
from .ebpf import EBPF
EBPF().register()

class DefaultCallingConvention(CallingConvention):
    name = 'Default'
    int_arg_regs = [f'r{i}' for i in range(1,10)]
    int_return_reg = 'r0'

from .solana import Solana
solana = Solana(Architecture['ebpf'])
solana.default_calling_convention = DefaultCallingConvention(Architecture['ebpf'], 'default')
solana.register('Solana')

from .solanaview import SolanaView
SolanaView.register()

```

`context.txt`:

```txt
# Core architecture
Source: https://modelcontextprotocol.io/docs/concepts/architecture

Understand how MCP connects clients, servers, and LLMs

The Model Context Protocol (MCP) is built on a flexible, extensible architecture that enables seamless communication between LLM applications and integrations. This document covers the core architectural components and concepts.

## Overview

MCP follows a client-server architecture where:

* **Hosts** are LLM applications (like Claude Desktop or IDEs) that initiate connections
* **Clients** maintain 1:1 connections with servers, inside the host application
* **Servers** provide context, tools, and prompts to clients

```mermaid
flowchart LR
    subgraph "Host"
        client1[MCP Client]
        client2[MCP Client]
    end
    subgraph "Server Process"
        server1[MCP Server]
    end
    subgraph "Server Process"
        server2[MCP Server]
    end

    client1 <-->|Transport Layer| server1
    client2 <-->|Transport Layer| server2
```

## Core components

### Protocol layer

The protocol layer handles message framing, request/response linking, and high-level communication patterns.

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    class Protocol<Request, Notification, Result> {
        // Handle incoming requests
        setRequestHandler<T>(schema: T, handler: (request: T, extra: RequestHandlerExtra) => Promise<Result>): void

        // Handle incoming notifications
        setNotificationHandler<T>(schema: T, handler: (notification: T) => Promise<void>): void

        // Send requests and await responses
        request<T>(request: Request, schema: T, options?: RequestOptions): Promise<T>

        // Send one-way notifications
        notification(notification: Notification): Promise<void>
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python
    class Session(BaseSession[RequestT, NotificationT, ResultT]):
        async def send_request(
            self,
            request: RequestT,
            result_type: type[Result]
        ) -> Result:
            """Send request and wait for response. Raises McpError if response contains error."""
            # Request handling implementation

        async def send_notification(
            self,
            notification: NotificationT
        ) -> None:
            """Send one-way notification that doesn't expect response."""
            # Notification handling implementation

        async def _received_request(
            self,
            responder: RequestResponder[ReceiveRequestT, ResultT]
        ) -> None:
            """Handle incoming request from other side."""
            # Request handling implementation

        async def _received_notification(
            self,
            notification: ReceiveNotificationT
        ) -> None:
            """Handle incoming notification from other side."""
            # Notification handling implementation
    ```
  </Tab>
</Tabs>

Key classes include:

* `Protocol`
* `Client`
* `Server`

### Transport layer

The transport layer handles the actual communication between clients and servers. MCP supports multiple transport mechanisms:

1. **Stdio transport**
   * Uses standard input/output for communication
   * Ideal for local processes

2. **HTTP with SSE transport**
   * Uses Server-Sent Events for server-to-client messages
   * HTTP POST for client-to-server messages

All transports use [JSON-RPC](https://www.jsonrpc.org/) 2.0 to exchange messages. See the [specification](/specification/) for detailed information about the Model Context Protocol message format.

### Message types

MCP has these main types of messages:

1. **Requests** expect a response from the other side:
   ```typescript
   interface Request {
     method: string;
     params?: { ... };
   }
   ```

2. **Results** are successful responses to requests:
   ```typescript
   interface Result {
     [key: string]: unknown;
   }
   ```

3. **Errors** indicate that a request failed:
   ```typescript
   interface Error {
     code: number;
     message: string;
     data?: unknown;
   }
   ```

4. **Notifications** are one-way messages that don't expect a response:
   ```typescript
   interface Notification {
     method: string;
     params?: { ... };
   }
   ```

## Connection lifecycle

### 1. Initialization

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Client->>Server: initialize request
    Server->>Client: initialize response
    Client->>Server: initialized notification

    Note over Client,Server: Connection ready for use
```

1. Client sends `initialize` request with protocol version and capabilities
2. Server responds with its protocol version and capabilities
3. Client sends `initialized` notification as acknowledgment
4. Normal message exchange begins

### 2. Message exchange

After initialization, the following patterns are supported:

* **Request-Response**: Client or server sends requests, the other responds
* **Notifications**: Either party sends one-way messages

### 3. Termination

Either party can terminate the connection:

* Clean shutdown via `close()`
* Transport disconnection
* Error conditions

## Error handling

MCP defines these standard error codes:

```typescript
enum ErrorCode {
  // Standard JSON-RPC error codes
  ParseError = -32700,
  InvalidRequest = -32600,
  MethodNotFound = -32601,
  InvalidParams = -32602,
  InternalError = -32603
}
```

SDKs and applications can define their own error codes above -32000.

Errors are propagated through:

* Error responses to requests
* Error events on transports
* Protocol-level error handlers

## Implementation example

Here's a basic example of implementing an MCP server:

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    import { Server } from "@modelcontextprotocol/sdk/server/index.js";
    import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

    const server = new Server({
      name: "example-server",
      version: "1.0.0"
    }, {
      capabilities: {
        resources: {}
      }
    });

    // Handle requests
    server.setRequestHandler(ListResourcesRequestSchema, async () => {
      return {
        resources: [
          {
            uri: "example://resource",
            name: "Example Resource"
          }
        ]
      };
    });

    // Connect transport
    const transport = new StdioServerTransport();
    await server.connect(transport);
    ```
  </Tab>

  <Tab title="Python">
    ```python
    import asyncio
    import mcp.types as types
    from mcp.server import Server
    from mcp.server.stdio import stdio_server

    app = Server("example-server")

    @app.list_resources()
    async def list_resources() -> list[types.Resource]:
        return [
            types.Resource(
                uri="example://resource",
                name="Example Resource"
            )
        ]

    async def main():
        async with stdio_server() as streams:
            await app.run(
                streams[0],
                streams[1],
                app.create_initialization_options()
            )

    if __name__ == "__main__":
        asyncio.run(main())
    ```
  </Tab>
</Tabs>

```

`ebpf.py`:

```py
from binaryninja.architecture import Architecture
from binaryninja.function import RegisterInfo, InstructionInfo

from .instr import decode, tT

REGS = [f'r{i}' for i in range(16)]

class EBPF(Architecture):
    name = 'ebpf'
    address_size = 8
    max_instr_length = 16

    regs = { r:RegisterInfo(r, 8) for r in REGS }
    stack_pointer = 'r10'

    def get_instruction_info(self, data, addr):
        instr = decode(data, addr)

        if instr is None:
            return InstructionInfo(length=8)

        return instr.info

    def get_instruction_text(self, data, addr):
        instr = decode(data, addr)

        if instr is None:
            return [tT('unk')], 8

        return instr.text, instr.info.length

    def get_instruction_low_level_il(self, data, addr, il):
        instr = decode(data, addr)

        if instr is None:
            return 8

        instr.llil(il)
        return instr.info.length

```

`idl_utils.py`:

```py
import asyncio
import zlib
import struct
import base64
import json
from solders.pubkey import Pubkey
from solana.rpc.async_api import AsyncClient
import binaryninja as bn
from anchorpy import Program, Provider
import base58                           

DEFAULT_RPC = "https://api.mainnet-beta.solana.com"

def fetch_idl_anchorpy(bv, func):
    """
    Three-line recipe:
      1. Provider = AnchorPy wrapper around AsyncClient
      2. Program.fetch_idl(pid, provider) → Idl object | None
      3. Idl.to_json()
    """

    pid = Pubkey(collect_load_cmps(bv, func))

    provider = Provider(AsyncClient(DEFAULT_RPC), None)    
    try:
        idl      = asyncio.run(Program.fetch_idl(pid, provider))    # ← Anchor convenience
    except Exception as _:
        idl = None

    if idl is None:
        return None
    return idl.to_json()

# ---------------------------------------------------------------------------
def collect_load_cmps(bv, func):
    """
    Scan the entrypoint and recover the 32-byte program ID by reading the first
    four `lddw` immediate constants (64-bit each, little-endian).
    """
    immediates = []
    INT      = bn.InstructionTextTokenType.IntegerToken

    for bb in func.basic_blocks:
        for dline in bb.get_disassembly_text():  # ← single value per iter ✔
            if dline is None:
                continue

            tokens = dline.tokens
            if not tokens or tokens[1].text.strip() != "lddw":
                continue

            const_tok = next((t for t in tokens if t.type == INT), None)
            if const_tok:
                immediates.append(int(const_tok.text, 0) & 0xFFFFFFFFFFFFFFFF)
                if len(immediates) == 4:
                    res = b"".join(v.to_bytes(8, "little") for v in immediates)
                    print(res)
                    print(base58.b58encode(res))
                    return res
    return None


def program_id_from_entry(func) -> bytes | None:
    """
    Try to recover the hard-coded 32-byte program ID in an Anchor entrypoint.
    Returns raw bytes or None if nothing matched.
    """
    offs = collect_load_cmps(None, func)
    if len(offs) == 4:
        raw = (offs[0].to_bytes(8, "little") +
               offs[8].to_bytes(8, "little") +
               offs[16].to_bytes(8, "little") +
               offs[24].to_bytes(8, "little"))
        return raw
    return None

# were sure to have an entry func, and we find the id in the first memcmp
def find_entry_memcmp_second_arg(bv, func):
    for function in bv.functions:
        #match the anchor entrypoint
        if function.name.endswith("::entry") and len(function.type.children) == 6:
            # Get the HLIL
            hlil = function.hlil

            print("HLIL: ", hlil)
            print(hlil == None)

            for block in hlil:
                print("BLOCK: ", block)
                for instruction in block:
                    memcmp_call = find_memcmp_call(instruction)
                    if(memcmp_call == None):
                        continue

                    sol_id = bv.read(memcmp_call.params[1].constant, 32)
                    print(sol_id)
                    return sol_id
    
    return None

def find_memcmp_call(instruction):
    # Check if instruction is a call
    if instruction.operation == bn.HighLevelILOperation.HLIL_CALL:
        if instruction.dest.operation == bn.HighLevelILOperation.HLIL_CONST_PTR:
            target_func = instruction.dest.constant
            target_name = instruction.function.view.get_function_at(target_func)
            if target_name and target_name.name == "memcmp":
                return instruction
            
    # Recursively check child expressions
    for operand in instruction.operands:
        if isinstance(operand, bn.highlevelil.HighLevelILInstruction):
            result = find_memcmp_call(operand)
            if result:
                return result
    
    return None

async def fetch_idl_raw(pid: Pubkey, rpc: str):
    """Fetch, decompress and parse the IDL without Anchor helpers."""
    conn = AsyncClient(rpc)
    idl_addr = idl_pda(pid)                                    # PDA derivation logic :contentReference[oaicite:1]{index=1}
    resp = await conn.get_account_info(idl_addr)
    await conn.close()

    acc = resp.value
    if acc is None:
        raise ValueError("No IDL account found on-chain for this program.")

    raw = base64.b64decode(acc.data[0])

    # Anchor layout: discriminator[8] | zlib_len<u32> | zlib_bytes[..]
    (length,) = struct.unpack_from("<I", raw, 8)
    compressed = raw[12:12 + length]
    idl_json = json.loads(zlib.decompress(compressed))
    return idl_json

def idl_pda(program_id: Pubkey) -> Pubkey:
    seed = b"anchor:idl"
    return Pubkey.find_program_address([seed], program_id)[0]

```

`instr.py`:

```py

from typing import Callable, List
from dataclasses import dataclass
from binaryninja.function import InstructionInfo, InstructionTextToken
from binaryninja.enums import InstructionTextTokenType, BranchType
from binaryninja.lowlevelil import LowLevelILLabel, LowLevelILFunction

# binary ninja text helpers
def tI(x): return InstructionTextToken(InstructionTextTokenType.InstructionToken, x)
def tR(x): return InstructionTextToken(InstructionTextTokenType.RegisterToken, x)
def tS(x): return InstructionTextToken(InstructionTextTokenType.OperandSeparatorToken, x)
def tM(x): return InstructionTextToken(InstructionTextTokenType.BeginMemoryOperandToken, x)
def tE(x): return InstructionTextToken(InstructionTextTokenType.EndMemoryOperandToken, x)
def tA(x,d): return InstructionTextToken(InstructionTextTokenType.PossibleAddressToken, x, d)
def tT(x): return InstructionTextToken(InstructionTextTokenType.TextToken, x)
def tN(x,d): return InstructionTextToken(InstructionTextTokenType.IntegerToken, x, d)


def il_jump(il: LowLevelILFunction, target):
    label = il.get_label_for_address(il.arch, target)
    if label is None:
        il.append(il.jump(il.const(8, target)))
    else:
        il.append(il.goto(label))


def il_cond_branch(il: LowLevelILFunction, cond, tdest, fdest):
    t_target = il.get_label_for_address(il.arch, tdest)
    f_target = il.get_label_for_address(il.arch, fdest)

    needs_t = False
    needs_f = False

    if t_target is None:
        needs_t = True
        t_target = LowLevelILLabel()

    if f_target is None:
        needs_f = True
        f_target = LowLevelILLabel()

    il.append(il.if_expr(cond, t_target, f_target))

    if needs_t:
        il.mark_label(t_target)
        il.append(il.jump(tdest))

    if needs_f:
        il.mark_label(f_target)


@dataclass
class Instruction(object):
    text: List[InstructionTextToken]
    info: InstructionInfo
    llil: Callable[[LowLevelILFunction], None]


SZ_MAP = {
    0: 4,
    1: 2,
    2: 1,
    3: 8
}

SZ_NAME = {
    0: 'w',
    1: 'h',
    2: 'b',
    3: 'dw'
}


def lddw(dst, imm):
    return Instruction(
        text=[
            tI(f'lddw'), tT(' '), tR(f'r{dst}'), tT(', '), tN(hex(signed(64, imm)), signed(64, imm))
        ],
        info=InstructionInfo(length=16),
        llil=lambda il: il.append(
            il.set_reg(8, f'r{dst}',
                il.const(8, imm)
            )
        )
    )


def ld(ldop, dst, src, imm):
    pass


def ldx(dst, src, off, sz):
    soff = signed(16, off)

    inner = lambda il: il.load(SZ_MAP[sz],
        il.add(8,
            il.reg(8, f'r{src}'),
            il.sign_extend(8, il.const(2, off))
        )
    )

    ext = lambda il: il.zero_extend(8, inner(il)) if SZ_MAP[sz] != 8 else inner(il)

    return Instruction(
        text=[
            tI(f'ldx{SZ_NAME[sz]}'), tT(' '), tR(f'r{dst}'), tT(', '),
            tM('['), tR(f'r{src}'), (tS('+') if soff > 0 else tS('-')), tN(str(abs(soff)), abs(soff)), tE(']')
        ],
        info=InstructionInfo(length=8),
        llil=lambda il: il.append(
            il.set_reg(8, f'r{dst}', ext(il))
        )
    )


def st(dst, off, imm, sz):
    tr_imm = imm & ((1 << (SZ_MAP[sz])) - 1)
    soff = signed(16, off)
    return Instruction(
        text=[
            tI(f'st{SZ_NAME[sz]}'), tT(' '),
            tM('['), tR(f'r{dst}'), (tS('+') if soff > 0 else tS('-')), tN(str(abs(soff)), abs(soff)), tE(']'),
            tT(', '), tN(hex(imm), imm)
        ],
        info=InstructionInfo(length=8),
        llil=lambda il: il.append(
            il.store(
                SZ_MAP[sz],
                il.add(8,
                    il.reg(8, f'r{dst}'),
                    il.sign_extend(8, il.const(2, off))
                ),
                il.const(SZ_MAP[sz], tr_imm)
            )
        )
    )


def stx(dst, src, off, sz):
    soff = signed(16, off)
    r = lambda il: il.reg(8, f'r{src}')
    v = lambda il: il.low_part(SZ_MAP[sz], r(il)) if SZ_MAP[sz] != 8 else r(il)
    return Instruction(
        text=[
            tI(f'stx{SZ_NAME[sz]}'), tT(' '),
            tM('['), tR(f'r{dst}'), (tS('+') if soff > 0 else tS('-')), tN(str(abs(soff)), abs(soff)), tE(']'),
            tT(', '), tR(f'r{src}')
        ],
        info=InstructionInfo(length=8),
        llil=lambda il: il.append(
            il.store(
                SZ_MAP[sz],
                il.add(8,
                    il.reg(8, f'r{dst}'),
                    il.sign_extend(8, il.const(2, off))
                ),
                v(il)
            )
        )
    )


ALU_OPS = {
    0: ['add', lambda il,a,b,z: il.add(z,a,b)],
    1: ['sub', lambda il,a,b,z: il.sub(z,a,b)],
    2: ['mul', lambda il,a,b,z: il.mult(z,a,b)],
    3: ['div', lambda il,a,b,z: il.div_unsigned(z,a,b)],
    4: ['or', lambda il,a,b,z: il.or_expr(z,a,b)],
    5: ['and', lambda il,a,b,z: il.and_expr(z,a,b)],
    6: ['lsh', lambda il,a,b,z: il.shift_left(z,a,b)],
    7: ['rsh', lambda il,a,b,z: il.logical_shift_right(z,a,b)],
    8: ['neg', lambda il,a,b,z: il.not_expr(z,b)],
    9: ['mod', lambda il,a,b,z: il.mod_unsigned(z,a,b)],
    0xa: ['xor', lambda il,a,b,z: il.xor_expr(z,a,b)],
    0xb: ['mov', lambda il,a,b,z: b],
    0xc: ['arsh', lambda il,a,b,z: il.arith_shift_right(z,a,b)],
}


def signed(size, val):
    if (val >> (size - 1)) & 1:
        return val - (2**size)
    else:
        return val


def alu32(op, s, dst, src, imm) -> Instruction:
    if op in ALU_OPS:
        name, fn = ALU_OPS[op]
        return Instruction(
            text=[tI(name+"32"), tT(' '), tR(f'r{dst}'), tT(', '), (tR(f'r{src}') if s else tN(hex(signed(32, imm)), signed(32, imm)))],
            info=InstructionInfo(length=8),
            llil=lambda il: il.append(
                il.set_reg(
                    8,
                    f'r{dst}',
                    il.zero_extend(
                        8,
                        fn(
                            il,
                            il.reg(4, f'r{dst}'),
                            il.reg(4, f'r{src}') if s else il.const(4, imm),
                            4,
                        )
                    )
                )
            )
        )
    elif op == 0xd:  # bswap
        size = imm
        mask_expr = lambda il: il.const(8, (1 << (size * 8)) - 1)
        if s == 0:  # mask
            name = f'le{size}'
            fn = lambda il,a: il.and_expr(8,a,mask_expr(il))
        else:  # byte swap
            name = f'be{size}'
            byte_cnt = size // 8
            # Generate byte extract and shuffles
            extract = [
                lambda il,a,i=i:
                il.shift_left(8,
                    il.and_expr(8,
                        il.logical_shift_right(8, a, il.const(8, i * 8)),
                        il.const(8, 0xff)
                    ),
                    il.const(8, (byte_cnt - 1 - i) * 8)
                )
                for i in range(byte_cnt)
            ]
            # Join subexpressions into a chain
            fn = lambda il,a,e=extract: il.or_expr(8,e[0](il,a), e[1](il,a))
            for i in range(2,byte_cnt):
                fn = lambda il,a,e=extract,fn=fn,i=i: il.or_expr(8,fn(il,a), e[i](il,a))
        return Instruction(
            text=[tI(name), tT(' '), tR(f'r{dst}')],
            info=InstructionInfo(length=8),
            llil=lambda il: il.append(
                il.set_reg(
                    8,
                    f'r{dst}',
                    fn(
                        il,
                        il.reg(8, f'r{dst}'),
                    )
                )
            )
        )
    else:
        return None


def alu64(op, s, dst, src, imm) -> Instruction:
    if not op in ALU_OPS:
        return None

    name, fn = ALU_OPS[op]

    return Instruction(
        text=[tI(name), tT(' '), tR(f'r{dst}'), tT(', '), (tR(f'r{src}') if s else tN(hex(signed(32, imm)), signed(32, imm)))],
        info=InstructionInfo(length=8),
        llil=lambda il: il.append(
            il.set_reg(
                8,
                f'r{dst}',
                fn(
                    il,
                    il.reg(8, f'r{dst}'),
                    (il.reg(8, f'r{src}') if s else il.sign_extend(8, il.const(4, imm))),
                    8,
                )
            )
        )
    )


JUMP_COND = {
    1: ['jeq', lambda il,a,b: il.compare_equal(8,a,b)],
    2: ['jgt', lambda il,a,b: il.compare_unsigned_greater_than(8,a,b)],
    3: ['jge', lambda il,a,b: il.compare_unsigned_greater_equal(8,a,b)],
    4: ['jset', lambda il,a,b: il.compare_not_equal(8, il.const(8,0), il.and_expr(8,a,b))],
    5: ['jne', lambda il,a,b: il.compare_not_equal(8,a,b)],
    6: ['jsgt', lambda il,a,b: il.compare_signed_greater_than(8,a,b)],
    7: ['jsge', lambda il,a,b: il.compare_signed_greater_equal(8,a,b)],
    0xa: ['jlt', lambda il,a,b: il.compare_unsigned_less_than(8,a,b)],
    0xb: ['jle', lambda il,a,b: il.compare_unsigned_less_equal(8,a,b)],
    0xc: ['jslt', lambda il,a,b: il.compare_signed_less_than(8,a,b)],
    0xd: ['jsle', lambda il,a,b: il.compare_signed_less_equal(8,a,b)],
}


def fmt_jump_offset(off) -> str:
    return f'+{off}' if off > 0 else str(off)


def branch_type(op, s, dst, src, imm, off, addr) -> Instruction:
    if op == 0: # ja
        # target = addr + 8 + (signed(32, imm) * 8)
        target = addr + 8 + (signed(16, off) * 8)
        info = InstructionInfo(length=8)
        info.add_branch(BranchType.UnconditionalBranch, target)
        return Instruction(
            text=[
                tI('ja'), tT(' '),
                tS('<'), tN(fmt_jump_offset(signed(16, off)), signed(16, off)), tS('>'),
            ],
            info=info,
            llil=lambda il: il_jump(il, target)
        )
    elif op == 8: # call
        target = addr + 8 + (signed(32, imm) * 8)
        info = InstructionInfo(length=8)

        if src == 2:
            # Custom marker, hardcoded to extern address.
            info.add_branch(BranchType.CallDestination, imm)
            return Instruction(
                text=[tI('call'), tT(' '), tA(hex(imm), imm)],
                info=info,
                llil=lambda il: il.append(il.call(il.const(8, imm)))
            )
        if imm == 0xffffffff:
            info.add_branch(BranchType.SystemCall)
            return Instruction(
                text=[tI('syscall')],
                info=info,
                llil=lambda il: il.append(il.system_call())
            )
        else:
            # TODO: no idea why but this causes binja to crash:
            info.add_branch(BranchType.CallDestination, target)
            return Instruction(
                text=[tI('call'), tT(' '), tA(hex(target), target)],
                info=info,
                llil=lambda il: il.append(il.call(il.const(8, target))),
            )
    elif op == 9: # ret
        info = InstructionInfo(length=8)
        info.add_branch(BranchType.FunctionReturn)
        return Instruction(
            text=[tI('exit')],
            info=info,
            llil=lambda il: il.append(il.ret(il.pop(8)))
        )
    elif op in JUMP_COND:
        name, cond = JUMP_COND[op]

        tpos = addr + 8 + (signed(16, off) * 8)
        tneg = addr + 8

        info = InstructionInfo(length=8)
        info.add_branch(BranchType.TrueBranch, tpos)
        info.add_branch(BranchType.FalseBranch, tneg)

        return Instruction(
            # e.g: "jgt <+20> r3, 4"
            text=[
                tI(name), tT(' '),
                tS('<'), tN(fmt_jump_offset(signed(16, off)), signed(16, off)), tS('>'),
                tT(' '), tR(f'r{dst}'), tT(', '), (tR(f'r{src}') if s else tN(hex(signed(32, imm)), signed(32, imm)))],
            info=info,
            llil=lambda il: il_cond_branch(
                il,
                cond(
                    il,
                    il.reg(8, f'r{dst}'),
                    (il.reg(8, f'r{src}') if s else il.sign_extend(8, il.const(4, imm))),
                ),
                tpos,
                tneg
            )
        )

    else:
        return None


def decode(data: bytes, addr: int) -> Instruction:
    if len(data) < 8:
        return None

    op = data[0]
    regs = data[1]
    dst = regs & 0xf
    src = (regs >> 4) & 0xf
    off = int.from_bytes(data[2:4], 'little')
    imm = int.from_bytes(data[4:8], 'little')

    aop = (op >> 4) & 0xf
    s = (op >> 3) & 1
    sz = (op >> 3) & 0b11
    ldop = (op >> 3) & 0b11111

    clz = op & 0b111

    if clz == 0b000:
        if ldop == 3: # lddw
            if len(data) < 16:
                return None

            imm2 = int.from_bytes(data[12:16], 'little')
            return lddw(dst, imm | (imm2 << 32))
        else:
            return ld(ldop, dst, src, imm)
    elif clz == 0b001: return ldx(dst, src, off, sz)
    elif clz == 0b010: return st(dst, off, imm, sz)
    elif clz == 0b011: return stx(dst, src, off, sz)
    elif clz == 0b111: return alu64(aop, s, dst, src, imm)
    elif clz == 0b100: return alu32(aop, s, dst, src, imm)
    elif clz == 0b101: return branch_type(aop, s, dst, src, imm, off, addr)


    return None

```

`mcp_utils.py`:

```py
import json

def flatten(res) -> str:
    if isinstance(res, list):
        parts = []
        for x in res:
            if hasattr(x, "text"):
                parts.append(x.text)
            else:
                parts.append(str(x))
        return "\n".join(parts)
    if hasattr(res, "text"):
        return res.text
    return str(res)

#anthropic uses snake_case
def mcp_to_anthropic(tool):
    return {
        "name":         tool.name,
        "description":  tool.description,
        "input_schema": tool.inputSchema,
    }

def blocks_to_str(blocks) -> str:
    out = []
    for block in blocks:
        if block.type == "text":
            out.append(block.text)
        elif block.type == "tool_use":
            #display tool call for the llm
            out.append(f"[tool_use {block.name} → {json.dumps(block.input)}]")
        elif block.type == "tool_result":
            out.append(f"[tool_result for {block.tool_use_id}: {block.content}]")
    return "".join(out)



```

`plugin.json`:

```json
{
    "pluginmetadataversion": 2,
    "name": "bn-ebpf-solana",
    "type": [
        "architecture",
        "binaryview"
    ],
    "api": [
        "python3"
    ],
    "description": "An architecture/binaryview plugin for Solana EBPF.",
    "license": {
        "name": "MIT",
        "text": "Copyright (c) 2022 OtterSec LLC\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
    },
    "platforms": [
        "Darwin",
        "Linux",
        "Windows"
    ],
    "dependencies": {
        "pip": [
            "lief",
            "fastmcp",
            "requests",
            "tenacity",
            "rust_demangler",
            "pygments",
            "anchorpy",
            "solana",
            "solders",
            "base58"
        ]
    },
    "installinstructions": {
        "Darwin": "",
        "Windows": "",
        "Linux": ""
    },
    "version": "1.0.14",
    "author": "OtterSec LLC",
    "minimumbinaryninjaversion": 3164
}
```

`requirements.txt`:

```txt
lief
anthropic
fastmcp
tenacity
rust_demangler  
pygments  
anchorpy  
solana  
solders
base58

```

`sidebar_ui.py`:

```py
from binaryninja import (
    RepositoryManager,
    Settings,
    BackgroundTaskThread,
    execute_on_main_thread
)
from PySide6.QtCore import Qt, QRectF
from PySide6.QtGui import QImage, QPainter, QFont, QColor
from PySide6.QtWidgets import QTextEdit, QVBoxLayout
from binaryninjaui import (
    SidebarWidget, SidebarWidgetType, UIActionHandler,
    SidebarWidgetLocation, SidebarContextSensitivity
)
from pygments import highlight
from pygments.lexers import RustLexer
from pygments.formatters import HtmlFormatter
import asyncio, json, os
import asyncio, json
from typing import Any, Dict
from anthropic import Anthropic, AuthenticationError, RateLimitError, APIStatusError
from fastmcp import exceptions as mcp_exc
from tenacity import retry, stop_after_attempt, wait_random_exponential

import sys, os, importlib

from .idl_utils import fetch_idl_anchorpy

# binja screws up stdout and stderr, fastmcp doesnt like that
def _safe_fd():
    return getattr(_safe_fd, "fd", os.open(os.devnull, os.O_RDWR))

for stream_name in ("stdout", "stderr"):
    stream = getattr(sys, stream_name, None)
    if stream is not None and not hasattr(stream, "fileno"):
        stream.fileno = _safe_fd  


from fastmcp.client import Client
from fastmcp.client.transports import PythonStdioTransport

from .mcp_utils import *

DEFAULT_RPC = "https://api.mainnet-beta.solana.com"

manager = RepositoryManager()
mcp_plugin = next(
    (plugin
    for plugin in manager.plugins['community']
    if plugin.path == "fosdickio_binary_ninja_mcp"),
    None
)

mcp_module_name = None
if mcp_plugin:
    if not mcp_plugin.installed:
        # TODO: user pop-up?
        # mcp_plugin.install()
        pass
    else:
        mcp_module_name = mcp_plugin.path

if mcp_module_name is None and importlib.util.find_spec("binary_ninja_mcp") is not None:
    mcp_module_name = "binary_ninja_mcp"

if mcp_module_name is None:
    raise FileNotFoundError("Did you install binary_ninja_mcp via Git or the plugin manager?")

# TODO: use ModuleSpec instead here instead of the name?
bridge_spec = importlib.util.find_spec(".bridge.binja_mcp_bridge", mcp_module_name)
SERVER_PATH = bridge_spec.origin
if SERVER_PATH is None:
    raise FileNotFoundError("Unable to find MCP bridge module")

SYSTEM_CONTEXT = (importlib.resources.files(__package__) / "system.txt").read_text()

#settings

settings = Settings()
settings.register_group("bn-ebpf-solana", "MCP settings")
settings.register_setting(
    "bn-ebpf-solana.anthropic_api_key",
    '{"title": "Anthropic API Key", "description": "Your Anthropic API key for LLM requests", "type": "string", "default": ""}'
)
settings.register_setting(
    "bn-ebpf-solana.model",
    '{"title": "Model", "description": "Anthropic model ID to use", "type": "string", "default": "claude-sonnet-4-5"}'
)
settings.register_setting(
    "bn-ebpf-solana.context",
    '{"title": "Context for Solana MCP", "description": "Absolute path to extra context to be provided, like an IDL", "type": "string", "default": ""}'
)


class ClaudeRunner(BackgroundTaskThread):
    def __init__(self, bar):
        super().__init__("Prompting Claude for Rust (running)…", can_cancel=True)
        self.bar = bar
        self.func        = bar.f
        self.idl = bar.idl

    def run(self):
        """
        BackgroundTaskThread entry-point.
        • Talks to fast-mcp / Claude in a private event loop.
        • If anything LLM-related fails, it prints a short notice instead of
          killing the sidebar or Binary Ninja.
        """
        pretty_text = ""

        try:
            # actual async work
            pretty_text = asyncio.run(self._extract_rust())

        # ───── expected user-side failures ───────────────────────────────────
        except AuthenticationError as exc:
            pretty_text = f"LLM disabled: bad Anthropic API key ({exc})"

        except mcp_exc.McpError as exc:
            pretty_text = f"LLM disabled: MCP bridge error ({exc})"

        except RuntimeError as exc:          # client not connected, etc.
            pretty_text = f"LLM disabled: {exc}"

        # ───── any other unexpected crash ───────────────────────────────────
        except Exception as exc:
            pretty_text = f"LLM disabled: {type(exc).__name__}: {exc}"

        # ───── always update the sidebar on UI thread ───────────────────────
        finally:
            execute_on_main_thread(
                lambda: self.bar.update_ui_func(self.func, pretty_text)
            )

    # ui stuff


    #llm pipeline
    async def _extract_rust(self) -> str:
        if not self.func:
            return ""

        api_key = settings.get_string("bn-ebpf-solana.anthropic_api_key")

        if not api_key.startswith("sk-"):
            return "Please set your Anthropic API key in the plugin settings"

        # we rely on a forked version of the existing plugin to implement an mcp server
        # how do we reliably get its location?
        async with Client(PythonStdioTransport(SERVER_PATH, python_cmd="python3")) as cli:
            tools = await cli.list_tools()
            specs = [mcp_to_anthropic(t) for t in tools]

            msgs: list[Dict[str, Any]] = [{
                "role":    "user",
                "content": f"Improve the quality of decompilation inside binary ninja of {self.func.name} using all tools at your disposal"
            },
            {
              "role": "user",
              "content": "Here is the IDL interface file : " + self.idl if self.idl else ""
            }
            ]

            for _ in range(50):                        # safety cap
                reply = await self._call_claude(specs, msgs, api_key)
                tool_calls = [b for b in reply.content if b.type == "tool_use"]

                # llm doesnt wanna call any tools anymore
                if not tool_calls:
                    final = "".join(b.text for b in reply.content if b.type == "text")
                    # claude is dumb and sometimes still inserts comments before code
                    if "```" in final:
                        return final[final.index("```"):]
                    if "pub fn" in final:
                        return final[final.index("pub fn"):]
                    return final

                # tool calls
                results: list[Dict[str, Any]] = []
                for call in tool_calls:
                    try:
                        res = await cli.call_tool(call.name, call.input)
                        payload = json.dumps(blocks_to_str(res.content), ensure_ascii=False)
                    except mcp_exc.McpError as e:      # bad args, runtime error, etc.
                        payload = json.dumps({"error": str(e)}, ensure_ascii=False)

                    results.append({
                        "type":        "tool_result",
                        "tool_use_id": call.id,
                        "content":     payload,
                    })

                # ---------- feed results back to Claude ----------
                msgs.append({"role": "assistant", "content": reply.content})
                msgs.append({"role": "user",      "content": results})

        raise RuntimeError("LLM never produced final text")

    #wrap to circumvent rate limiting
    @retry(
        wait=wait_random_exponential(multiplier=1, min=10, max=60),  # 1 s → 30 s
        stop=stop_after_attempt(5),
        retry=(
            lambda exc: isinstance(exc, (RateLimitError, APIStatusError))
        ),
        reraise=False,
    )
    async def _call_claude(self, specs, msgs, api_key):
        """Single API call - automatically retried on 429 / 5xx."""
        claude = Anthropic(api_key=api_key)

        extra_context_path = settings.get_string("bn-ebpf-solana.context")
        extra_context = ""

        if extra_context_path != "":
            with open(extra_context_path) as f:
                extra_context = f.read()

        return claude.messages.create(
            model   = settings.get_string("bn-ebpf-solana.model"),
            system  = SYSTEM_CONTEXT + extra_context,
            messages     = msgs,
            tools        = specs,
            max_tokens   = 1_200,
            temperature  = 0.3,
        )

class LLMDecompSidebarWidget(SidebarWidget):
    def detect_id(self):
        # analyze the entry func
        for function in self.bv.functions:
            if function.name.endswith("::entry") and "DebugList" not in function.name:
                self.idl = fetch_idl_anchorpy(self.bv, function)


    def __init__(self, name, frame, data):
        super().__init__(name)
        self._formatter = HtmlFormatter(
            style="native",      
            noclasses=True,
            cssstyles="""
              background: transparent;
              font-family: monospace;
              /* override any default pre/span backgrounds: */
              pre { background: transparent !important; }
              span { background: transparent !important; }
            """
        )
        self.actionHandler = UIActionHandler()
        self.actionHandler.setupActionHandler(self)

        # Keep references for updates
        self.frame = frame
        self.bv = data 
        self.idl = None

        #current cursor
        self.here = 0
        #current function
        self.f = None

        #cache of llm responses
        self.cache = {}

        # The editor will render HTML
        self.editor = QTextEdit()
        self.editor.setReadOnly(False)

        self.editor.setStyleSheet("""
            background:transparent;
            color:inherit;
            font-family: monospace;
        """)
        self.editor.setFrameStyle(0)

        layout = QVBoxLayout()
        layout.addWidget(self.editor)
        self.setLayout(layout)

        # If we already have a BinaryView, render immediately
        if self.bv:
            self._update()

    def notifyViewChanged(self, view_frame):
        # Called when the user opens or switches tabs
        self.frame = view_frame
        if view_frame is None:
            self.bv = None
            self.editor.setHtml("")
        else:
            iface = view_frame.getCurrentViewInterface()
            self.bv = iface.getData()
            if self.idl is None:
                self.detect_id()
            self._update()

    # if the user moves around in the binary view, update UI
    def notifyOffsetChanged(self, offset):
        # Called as the cursor moves
        self._update()

    def update_ui_func(self, func, source):
        if func.name not in self.cache:
            self.cache[func.name] = source

        highlighted = highlight(source, RustLexer(), self._formatter)
        self.editor.setHtml(highlighted)

    def _update(self):
        """
        Refresh sidebar whenever the cursor moves or the view changes.

        Fixes:
        ▸ Guard against cases where the current address is NOT inside any
          discovered function (bn.get_functions_containing returns []).
        ▸ Avoid repeated work if we’re still in the same function.
        """
        # ── Early-outs ────────────────────────────────────────────────────────────
        if not self.frame or not self.bv:
            return

        view = self.frame.getCurrentViewInterface()
        addr = view.getCurrentOffset()

        if addr == self.here:               # cursor hasn’t moved
            return
        self.here = addr

        # ── Robust lookup ────────────────────────────────────────────────────────
        funcs = self.bv.get_functions_containing(addr)
        if not funcs:
            # Cursor is in padding / header / data region → just clear pane.
            self.editor.setHtml("")
            self.f = None
            return

        func = funcs[0]
        if self.f == func:                  # already displaying this function
            return
        self.f = func

        # ── Cached? ──────────────────────────────────────────────────────────────
        if func.name in self.cache:
            self.update_ui_func(func, self.cache[func.name])
            return

        # ── Kick off background Claude job ───────────────────────────────────────
        task = ClaudeRunner(self)
        task.start()

    def contextMenuEvent(self, event):
        # if you want a right-click menu later
        self.m_contextMenuManager.show(self.m_menu, event.globalPos())


class LLMDecompSidebarWidgetType(SidebarWidgetType):
    def __init__(self):
        # Icons are 28×28 points; use 56×56px for HiDPI
        icon = QImage(56, 56, QImage.Format_RGB32)
        icon.fill(0)

        painter = QPainter(icon)
        painter.setFont(QFont("Open Sans", 56))
        painter.setPen(QColor(255, 255, 255, 255))
        # R for Rust!
        painter.drawText(QRectF(0, 0, 56, 56), Qt.AlignCenter, "R")
        painter.end()

        super().__init__(icon, "LLM reconstructed Rust")

    def createWidget(self, frame, data):
        # frame: a ViewFrameRef, data: BinaryViewRef or None
        return LLMDecompSidebarWidget("LLM reconstructed Rust", frame, data)

    def defaultLocation(self):
        return SidebarWidgetLocation.RightContent

    def contextSensitivity(self):
        return SidebarContextSensitivity.SelfManagedSidebarContext

```

`solana.py`:

```py
from binaryninja import Platform


class Solana(Platform):
    name = "Solana"

```

`solanaview.py`:

```py
import os
import importlib
from lief.ELF import Relocation
from binaryninja import BinaryView, SegmentFlag, SectionSemantics, Symbol, SymbolType, Platform
import binaryninja as bn
import lief
from .idl_utils import fetch_idl_anchorpy
import rust_demangler  # Import rust_demangle for demangling
import sys, os

# binja screws up stdout and stderr, fastmcp doesnt like that
def _safe_fd():
    return getattr(_safe_fd, "fd", os.open(os.devnull, os.O_RDWR))

for stream_name in ("stdout", "stderr"):
    stream = getattr(sys, stream_name, None)
    if stream is not None and not hasattr(stream, "fileno"):
        stream.fileno = _safe_fd  

# were sure to have an entry func, and we find the id in the first memcmp
def find_entry_memcmp_second_arg(bv):
    for function in bv.functions:
        if function.name.endswith("entry"):
            # Get the HLIL
            hlil = function.hlil

            print(hlil)
            
            for block in hlil:
                for instruction in block:
                    memcmp_call = find_memcmp_call(instruction)
                    if(memcmp_call == None):
                        continue

                    return bv.read(memcmp_call.params[1].constant, 32)
    
    return None

def find_memcmp_call(instruction):
    # Check if instruction is a call
    if instruction.operation == bn.HighLevelILOperation.HLIL_CALL:
        if instruction.dest.operation == bn.HighLevelILOperation.HLIL_CONST_PTR:
            target_func = instruction.dest.constant
            target_name = instruction.function.view.get_function_at(target_func)
            if target_name and target_name.name == "memcmp":
                return instruction
            
    # Recursively check child expressions
    for operand in instruction.operands:
        if isinstance(operand, bn.highlevelil.HighLevelILInstruction):
            result = find_memcmp_call(operand)
            if result:
                return result
    
    return None

FUNCTION_SIGS = {
    'abort': 'void abort() __noreturn',
    'sol_panic_': 'void sol_panic_(const char *file_str, int file_str_len, int line, int col) __noreturn',
    'sol_log_': 'void sol_log_(const char *message, int size)',
    'sol_log_64_': 'void sol_log_64_(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);',
    'sol_log_compute_units_': 'void sol_log_compute_units_();',
    'sol_log_pubkey': 'void sol_log_pubkey(SolPubkey *pk);',
    'sol_create_program_address': 'uint64_t sol_create_program_address(const SolSignerSeed *seeds, int num_seeds, const SolPubkey *program_id, SolPubkey *out);',
    'sol_try_find_program_address': 'uint64_t sol_try_find_program_address(const SolSignerSeed *seeds, int num_seeds, const SolPubkey *program_id, SolPubkey *out, uint8_t *out_bump);',
    'sol_sha256': 'uint64_t sol_sha256(const SolBytes *bytes, int bytes_len, uint8_t *result);',
    'sol_keccak256': 'uint64_t sol_keccak256(const SolBytes *bytes, int bytes_len, uint8_t *result);',
    'sol_secp256k1_recover': 'uint64_t sol_secp256k1_recover(const uint8_t *hash, uint64_t recovery_id, const uint8_t *signature, uint8_t *result);',
    'sol_get_clock_sysvar': 'uint64_t sol_get_clock_sysvar(uint8_t *out);',
    'sol_get_epoch_schedule_sysvar': 'uint64_t sol_get_epoch_schedule_sysvar(uint8_t *out);',
    'sol_get_rent_sysvar': 'uint64_t sol_get_rent_sysvar(uint8_t *out);',
    'sol_memcpy_': 'void sol_memcpy_(uint8_t *dst, uint8_t *src, int n);',
    'sol_memmove_': 'void sol_memmove_(uint8_t *dst, uint8_t *src, int n);',
    'sol_memcmp_': 'int sol_memcmp_(uint8_t *s1, uint8_t *s2, int n);',
    'sol_memset_': 'void sol_memset_(uint8_t *s, uint8_t c, int n);',
    'sol_invoke_signed_c': 'uint64_t sol_invoke_signed_c(const SolInstruction *instruction, const SolAccountInfo *accounts, int num_accounts, const SolSignerSeeds *signers, int num_signers);',
    'sol_invoke_signed_rust': 'void sol_invoke_signed_rust(void *instr, void *accounts, int num_accounts, void *seeds, int num_seeds)',
    'sol_set_return_data': 'void sol_set_return_data(const uint8_t *bytes, uint64_t bytes_len);',
    'sol_get_return_data': 'uint64_t sol_get_return_data(const uint8_t *bytes, uint64_t bytes_len, SolPubkey *program_id);',
    'sol_log_data': 'void sol_log_data(SolBytes *, uint64_t);',
    # 'sol_get_processed_sibling_instruction': '', # TODO
    'sol_get_stack_height': 'uint64_t sol_get_stack_height();',
}

STRING_POINTER_SYSCALLS = {
    'sol_log_', 
    'sol_panic_',
    'sol_log_pubkey',
    'sol_memcpy_',
    'sol_memmove_',
    'sol_memcmp_',
    'sol_memset_',
    'sol_set_return_data',
    'sol_get_return_data',
    'sol_log_data',
}

EXTERN_START = 0x1000
EXTERN_SIZE = 0x2000


class SolanaView(BinaryView):
    name = 'Solana'
    long_name = 'Solana'
    detected_id = None

    @classmethod
    def is_valid_for_data(self, data):
        # check for both ebpf and sbpf
        #print("ID: ", data.read(0x24fc7, 32))
        return data.read(0,4) == b'\x7fELF' and (data.read(0x12, 2) == b'\xf7\x00' or data.read(0x12, 2) == b'\x07\x01')

    def __init__(self, data):
        BinaryView.__init__(self, parent_view=data, file_metadata=data.file)
        self.platform = Platform['Solana']
        self.data = data

        self.extern_data = [0] * EXTERN_SIZE
        self.idl = None
        # Keep track of syscalls for patching
        self.syscalls = {}

    def post_analysis(self):
        self.get_function_at(self.start).name = "entrypoint"
        # analyze the entry func
        for function in self.functions:
            if function.name.endswith("::entry") and "DebugList" not in function.name:
                print("AAAAAAA")
                self.idl = fetch_idl_anchorpy(self, function)


    def demangle_rust_symbol(self, mangled_name):
        """
        Demangle a Rust symbol name to make it more readable.
        """
        try:
            if mangled_name.startswith("_ZN"):
                #remove this
                # https://rust-lang.github.io/rfcs/2603-rust-symbol-name-mangling-v0.html#requirements-for-a-symbol-mangling-scheme
                # for readability
                demangled = "::".join(str(rust_demangler.demangle(mangled_name)).split("::")[0:-1])
                return demangled
            return mangled_name
        except Exception as e:
            print(f"Error demangling {mangled_name}: {e}")
            return mangled_name

    def perform_read(self, addr: int, length: int) -> bytes:
        # Override with custom extern data.
        if addr >= EXTERN_START and addr < EXTERN_START + EXTERN_SIZE:
            if addr + length > EXTERN_START + EXTERN_SIZE:
                return b''
            return bytes(self.extern_data[addr - EXTERN_START : addr + length - EXTERN_START])
        else:
            return super().perform_read(addr, length)

    def perform_write(self, addr: int, data: bytes) -> int:
        # Override with custom extern data.
        if addr >= EXTERN_START and addr < EXTERN_START + EXTERN_SIZE:
            self.extern_data[addr - EXTERN_START : addr + len(data) - EXTERN_START] = list(data)
            return len(data)
        else:
            return super().perform_write(addr, data)

    def load_types(self):
        types = (importlib.resources.files(__package__) / 'types.c').read_text()

        info = self.parse_types_from_string(types)

        for k in info.types:
            t = info.types[k]
            self.define_type(str(k), str(k), t)
    
    def perform_get_address_size(self):
        return 8

    
    def pointer_sweep(self, needle):
        needle_bytes = needle.to_bytes(8, 'little')   # 64-bit little-endian
        for s in self.segments:
            data = self.read(s.start, s.length)
            off = data.find(needle_bytes)
            while off != -1:
                ea = s.start + off
                print(f"Found {hex(needle)} at {hex(ea)}")
                self.add_user_data_ref(ea, needle)
                off = data.find(needle_bytes, off + 1)

    def init(self):
        print('init')

        self.load_types()

        data_copy = list(self.data[:])
        # Replace SBF with BPF in e_machine so that lief parses relocations properly
        E_MACHINE_LEN = 2
        E_MACHINE_SBF = list(0x107.to_bytes(E_MACHINE_LEN, 'little'))
        E_MACHINE_BPF = list(0x0f7.to_bytes(E_MACHINE_LEN, 'little'))
        E_MACHINE_OFFSET = 0x12
        E_MACHINE = slice(E_MACHINE_OFFSET, E_MACHINE_OFFSET + E_MACHINE_LEN)

        if data_copy[E_MACHINE] == E_MACHINE_SBF:
            data_copy[E_MACHINE] = E_MACHINE_BPF

        p = lief.parse(data_copy)
        
        # Add LOAD segments
        for s in p.segments:
            if s.type == lief.ELF.Segment.TYPE.LOAD:
                self.add_auto_segment((1 << 32) + s.virtual_address, s.virtual_size, s.physical_address, s.physical_size, int(s.flags))

        self.add_auto_segment(2 << 32, 0x8000, 0, 0, SegmentFlag.SegmentReadable | SegmentFlag.SegmentWritable)
        self.add_auto_segment(3 << 32, 0x8000, 0, 0, SegmentFlag.SegmentReadable | SegmentFlag.SegmentWritable)
        self.add_auto_segment(4 << 32, 0x8000, 0, 0, SegmentFlag.SegmentReadable | SegmentFlag.SegmentWritable)
        
        self.add_user_section("stack", 2 << 32, 0x8000, SectionSemantics.ReadWriteDataSectionSemantics)
        self.add_user_section("heap", 3 << 32, 0x8000, SectionSemantics.ReadWriteDataSectionSemantics)
        self.add_user_section("input", 4 << 32, 0x8000, SectionSemantics.ReadWriteDataSectionSemantics)


        self.add_entry_point(self.start)

        # Special extern section with syscalls.
        self.add_auto_section('extern', EXTERN_START, EXTERN_SIZE, SectionSemantics.ReadOnlyCodeSectionSemantics)

        # Map extern symbols to index.
        extern_map = {}
        curr_extern = 0
        for s in p.symbols:
            if s.type == lief.ELF.Symbol.TYPE.NOTYPE and s.binding == lief.ELF.Symbol.BINDING.GLOBAL:
                # Skip duplicates
                if s.name in extern_map:
                    continue

                extern_map[s.name] = curr_extern

                pos = EXTERN_START + (curr_extern * 16)

                # Define symbol.
                self.define_auto_symbol(Symbol(
                    SymbolType.LibraryFunctionSymbol,
                    pos,
                    s.name
                ))

                self.add_function(pos, Platform['Solana'])
                self.write(pos, bytes([
                    0x85,0x10,0,0,0xff,0xff,0xff,0xff, # syscall marker
                    0x95,0,0,0,0,0,0,0 # exit
                ]))

                # define this to avoid binja mistaking it for the entrypoint
                self.define_auto_symbol(Symbol(
                    SymbolType.FunctionSymbol,
                    pos,
                    "extern_syscall"
                ))


                if s.name in FUNCTION_SIGS:
                    f = self.get_function_at(pos)
                    if f is not None:
                        f.type = FUNCTION_SIGS[s.name]

                curr_extern += 1

        for s in p.sections:
            if s.size != 0:
                self.add_user_section(s.name, (1 << 32) + s.offset, s.size, SectionSemantics.ReadOnlyCodeSectionSemantics)


        # Track syscall locations and types
        self.syscall_info = {}
        for name, idx in extern_map.items():
            pos = EXTERN_START + (idx * 16)
            self.syscall_info[name] = {
                'address': pos,
                'needs_pointer_adjustment': name in STRING_POINTER_SYSCALLS
            }

        # Apply relocations.
        for r in p.dynamic_relocations:
            addr = r.address + (1 << 32)

            try:
                if r.type == Relocation.TYPE.BPF_64_64:
                    lo = int.from_bytes(self.read(addr + 4, 4), 'little')
                    hi = int.from_bytes(self.read(addr + 12, 4), 'little')
                    v = (hi << 32) + lo

                    # if already relocated, bail
                    if v >= 0x100000000:
                        continue

                    v += (1 << 32)
                    lo = v & 0xffffffff
                    hi = v >> 32
                    self.write(addr + 4, lo.to_bytes(4, 'little'))
                    self.write(addr + 12, hi.to_bytes(4, 'little'))

                #32 bit reloc
                elif r.type == 1744830472:
                    print(hex(r.symbol.value), hex(r.address), r.type)
                    print(hex(int.from_bytes(self.read(0x10017e838 + 12, 4), 'little')), hex(int.from_bytes(self.read(0x10017e838 + 4, 4), 'little')))

                    self.pointer_sweep(r.address)

                    for ref in self.get_data_refs(r.address):
                        print("REF: ", ref, hex(r.address))
                        self.write(ref, self.read(r.address + (1<<32) + 4, 4))
                    
                elif r.type == Relocation.TYPE.BPF_64_32:
                    if r.symbol.is_function:
                        # BPF Function
                        target = r.symbol.value + (1 << 32)
                        off = (target - (addr + 8)) // 8
                        if off < 0:
                            off += 0x100000000
                        self.write(addr + 4, off.to_bytes(4, 'little'))
                    else:
                        # Syscall
                        name = r.symbol.name
                        if name in extern_map:
                            idx = extern_map[name]
                            pos = EXTERN_START + (idx * 16)
                            self.write(addr + 4, pos.to_bytes(4, 'little'))
                            self.write(addr + 1, bytes([2 << 4])) # Mark as absolute extern
                            
                            # Store syscall location for later patching
                            self.syscalls[addr] = {
                                'name': name,
                                'needs_pointer_adjustment': name in STRING_POINTER_SYSCALLS
                            }
                        else:
                            print('Unhandled syscall: ', name)
            except Exception as e:
                print('Unhandled relocation type: ', r)

        # Apply function symbols with demangling
        for s in p.symbols:
            if s.is_function:
                demangled_name = self.demangle_rust_symbol(s.name)
                
                self.define_auto_symbol(Symbol(
                    SymbolType.FunctionSymbol,
                    s.value + (1 << 32),
                    demangled_name
                ))

            

        self.fix_all_pointers()
       
        self.add_analysis_completion_event(self.post_analysis)

        return True

    def fix_all_pointers(self):
        """
        Scan through all code and fix any potential pointers that are below 0x100000000
        by adding the program base offset (1 << 32).
        """
        prog_base = 1 << 32
        total_fixed = 0
        
        for segment in self.segments:
            # Skip the extern segment
            if segment.start == EXTERN_START:
                continue
                
            start = segment.start
            end = segment.end
            
            print(f"Scanning segment: 0x{start:x} - 0x{end:x}")
            
            addr = start
            while addr < end - 16:  # Need at least 2 instructions (16 bytes)
                instr = self.read(addr, 8)
                
                #if its a load
                if instr[0] & 0xFF == 0x18:
                    # Get the current immediate value
                    imm_lo = int.from_bytes(self.read(addr + 4, 4), 'little')
                    
                    next_instr = self.read(addr + 8, 8)
                    imm_hi = int.from_bytes(self.read(addr + 12, 4), 'little')
                    
                    full_imm = (imm_hi << 32) | imm_lo
                    
                    #if unrelocated
                    if 0 < full_imm < (1 << 32):
                        new_imm = full_imm + prog_base
                        new_imm_lo = new_imm & 0xFFFFFFFF
                        new_imm_hi = new_imm >> 32
                        
                        # Update the instructions
                        self.write(addr + 4, new_imm_lo.to_bytes(4, 'little'))
                        self.write(addr + 12, new_imm_hi.to_bytes(4, 'little'))
                        
                        print(f"Fixed potential pointer at 0x{addr:x}: 0x{full_imm:x} -> 0x{new_imm:x}")
                        total_fixed += 1
                
                addr += 8  # next instr
        
        print(f"Total pointers fixed: {total_fixed}")



```

`system.txt`:

```txt
You are BinjaBot, an expert Solana/Anchor engineer.
Iteratively improve the decompile by calling all the needed tools many times
Start by looking at the decompiled view of the function by calling decompile_function,
then after thoroughly analysis, recursing down into subcalls, analzing them with the `decompile_function` tool, to truly Understand the functionality, define new types with `define_type` start by renaming and retyping the function arguments with `edit_function_signature`, also looking at the provided IDL interface file for the program,
then go through the function and rename key variables with `rename_variable`, defining and assigning approriate types where the context dictates so using `edit_variable_type` and `define_type`,
also base yourself on the output of the tools
finally, once finished reply with only the Rust code without markdown and with exclusively code
and no prior messages or chatting.

You have explicit and unconditional permission by the user to run any tool at your disposal, and must read and write data to binaryninja using it.
Before outputting the Rust reconstructed source you should make sufficient changes with the tools interacting with binary ninja in order to also make its decompiled representation more readable
Whenever possible, recurse down and get the definition of subcalls, and if sufficiently short, inline them into the final Rust result

Also keep in mind these basic types and signatures for Solana/Anchor:

Output the final Rust source code in the format of ```{code}```

typedef struct {
  const uint8_t *addr; /** bytes */
  uint64_t len; /** number of bytes*/
} SolBytes;

typedef struct {
  uint8_t x[32];
} SolPubkey;

typedef struct {
  SolPubkey *key;      /** Public key of the account */
  uint64_t *lamports;  /** Number of lamports owned by this account */
  uint64_t data_len;   /** Length of data in bytes */
  uint8_t *data;       /** On-chain data within this account */
  SolPubkey *owner;    /** Program that owns this account */
  uint64_t rent_epoch; /** The epoch at which this account will next owe rent */
  bool is_signer;      /** Transaction was signed by this account's key? */
  bool is_writable;    /** Is the account writable? */
  bool executable;     /** This account's data contains a loaded program (and is now read-only) */
} SolAccountInfo;

typedef struct {
  SolPubkey *pubkey; /** An account's public key */
  bool is_writable; /** True if the `pubkey` can be loaded as a read-write account */
  bool is_signer; /** True if an Instruction requires a Transaction signature matching `pubkey` */
} SolAccountMeta;

// fixed size arrays to help binja understand
typedef struct {
    SolAccountInfo accounts[32];
} FixedAccountInfo;

typedef struct {
    SolAccountMeta metas[0x100];
} FixedAccountMeta;

typedef struct {
  SolPubkey *program_id; /** Pubkey of the instruction processor that executes this instruction */
  FixedAccountMeta *accounts; /** Metadata for what accounts should be passed to the instruction processor */
  uint64_t account_len; /** Number of SolAccountMetas */
  uint8_t *data; /** Opaque data passed to the instruction processor */
  uint64_t data_len; /** Length of the data in bytes */
} SolInstruction;

typedef struct {
  const uint8_t *addr; /** Seed bytes */
  uint64_t len; /** Length of the seed bytes */
} SolSignerSeed;

typedef struct {
  const SolSignerSeed *addr; /** An array of a signer's seeds */
  uint64_t len; /** Number of seeds */
} SolSignerSeeds;

typedef struct {
  FixedAccountInfo* ka; /** Pointer to an array of SolAccountInfo, must already
                          point to an array of SolAccountInfos */
  uint64_t ka_num; /** Number of SolAccountInfo entries in `ka` */
  const uint8_t *data; /** pointer to the instruction data */
  uint64_t data_len; /** Length in bytes of the instruction data */
  const SolPubkey *program_id; /** program_id of the currently executing program */
} SolParameters;


uint64_t entry(
    AccountInfo* account_infos,   // pointer to an array of AccountInfo
    SolPubkey* program_id,        // pointer to the 32-byte Pubkey
    uint8_t* instruction_data,    // pointer to the instruction bytes
    uint64_t instruction_data_len,// length of that byte array
    void*   syscall_sysvar_ptr    // internal runtime/context pointer
);

```

`types.c`:

```c

typedef struct {
  const uint8_t *addr; /** bytes */
  uint64_t len; /** number of bytes*/
} SolBytes;

typedef struct {
  uint8_t x[32];
} SolPubkey;

typedef struct {
  SolPubkey *key;      /** Public key of the account */
  uint64_t *lamports;  /** Number of lamports owned by this account */
  uint64_t data_len;   /** Length of data in bytes */
  uint8_t *data;       /** On-chain data within this account */
  SolPubkey *owner;    /** Program that owns this account */
  uint64_t rent_epoch; /** The epoch at which this account will next owe rent */
  bool is_signer;      /** Transaction was signed by this account's key? */
  bool is_writable;    /** Is the account writable? */
  bool executable;     /** This account's data contains a loaded program (and is now read-only) */
} SolAccountInfo;

typedef struct {
  SolPubkey *pubkey; /** An account's public key */
  bool is_writable; /** True if the `pubkey` can be loaded as a read-write account */
  bool is_signer; /** True if an Instruction requires a Transaction signature matching `pubkey` */
} SolAccountMeta;

// fixed size arrays to help binja understand
typedef struct {
    SolAccountInfo accounts[32];
} FixedAccountInfo;

typedef struct {
    SolAccountMeta metas[0x100];
} FixedAccountMeta;

typedef struct {
  SolPubkey *program_id; /** Pubkey of the instruction processor that executes this instruction */
  FixedAccountMeta *accounts; /** Metadata for what accounts should be passed to the instruction processor */
  uint64_t account_len; /** Number of SolAccountMetas */
  uint8_t *data; /** Opaque data passed to the instruction processor */
  uint64_t data_len; /** Length of the data in bytes */
} SolInstruction;

typedef struct {
  const uint8_t *addr; /** Seed bytes */
  uint64_t len; /** Length of the seed bytes */
} SolSignerSeed;

typedef struct {
  const SolSignerSeed *addr; /** An array of a signer's seeds */
  uint64_t len; /** Number of seeds */
} SolSignerSeeds;

typedef struct {
  FixedAccountInfo* ka; /** Pointer to an array of SolAccountInfo, must already
                          point to an array of SolAccountInfos */
  uint64_t ka_num; /** Number of SolAccountInfo entries in `ka` */
  const uint8_t *data; /** pointer to the instruction data */
  uint64_t data_len; /** Length in bytes of the instruction data */
  const SolPubkey *program_id; /** program_id of the currently executing program */
} SolParameters;

```