Project Path: arc_ryanjon2040_Unreal-Binary-Builder_3bz7ae3y

Source Tree:

```txt
arc_ryanjon2040_Unreal-Binary-Builder_3bz7ae3y
├── CHANGELOG.md
├── Documentation
│   ├── Screenshot_1.png
│   ├── Screenshot_2.PNG
│   ├── Screenshot_3.PNG
│   └── Screenshot_4.PNG
├── LICENSE.md
├── README.md
├── UnrealBinaryBuilder
│   ├── App.xaml
│   ├── App.xaml.cs
│   ├── AssemblyInfo.cs
│   ├── Classes
│   │   ├── BuilderSettings.cs
│   │   ├── GameAnalyticsCSharp.cs
│   │   ├── Git.cs
│   │   ├── Plugins.cs
│   │   └── PostBuildSettings.cs
│   ├── MainWindow.xaml
│   ├── MainWindow.xaml.cs
│   ├── UnrealBinaryBuilder.csproj
│   ├── UserControls
│   │   ├── AboutDialog.xaml
│   │   ├── AboutDialog.xaml.cs
│   │   ├── CodeEditor.xaml
│   │   ├── CodeEditor.xaml.cs
│   │   ├── CrashReporter.xaml
│   │   ├── CrashReporter.xaml.cs
│   │   ├── DownloadDialog.xaml
│   │   ├── DownloadDialog.xaml.cs
│   │   ├── LogViewer.xaml
│   │   ├── LogViewer.xaml.cs
│   │   ├── PluginCard.xaml
│   │   └── PluginCard.xaml.cs
│   ├── compiler.ico
│   └── compiler.png
├── UnrealBinaryBuilder.sln
├── UnrealBinaryBuilderUpdater
│   ├── UnrealBinaryBuilderUpdater.csproj
│   ├── UnrealBinaryUpdater.cs
│   ├── appcast.xml
│   └── appcast.xml.signature
├── generate_appcast.bat
├── publish.bat
└── sentry_upload.bat

```

`CHANGELOG.md`:

```md
# 3.1.6
**CRITICAL SECURITY UPDATE**
* [CefSharp security update.](https://github.com/ryanjon2040/Unreal-Binary-Builder/pull/58)
* HandyControl messageboxes now shows English instead of Chinese.

# 3.1.5
* **FIXED**: Crash when clicking Browse button in zip tab (reported by Gambit)

# 3.1.4

**THIS IS A CRITICAL UPDATE. DO NO SKIP**
* Updates to the updater.
* Show commit of current Engine.
* Add LinuxArm64 for Unreal Engine 5.
* Update some UE4 names to Unreal.
* Errors are now written to separate log file.
* Support custom Engines.
* New crash reporter.
* **FIXED**: Progressbar and cancel button not hiding after zipping..
* **FIXED**: Issue with CanSaveToZip.
* **FIXED**: Incorrect behavior when canceling build.
* **FIXED**: Issue when selecting Host DDC.
* **FIXED**: Plugin zipping crash if locations are same.

# 3.1.3

* Improve UE5 support
* Improve app update. Now shows changelog as well.
* Remove Engine Version selection. This is now automated.
* Remove Automation Tool Launcher selection. This is now automated.
* Use AutomationTool instead of AutomationToolLauncher for UE5.
* Improve messages in Zip tab.
* Updated dependencies.

* **FIXED**: Crashing when zipping UE5 build.
* **FIXED**: Incorrect method for OpenBuildFolder in zip tab.
* **FIXED**: Not Building Engine if all checkboxes are unchecked in Setup tab.


# 3.1.2

* **FIXED**: Issues with updating.

# 3.1.1

* Support **Unreal Engine 5**
* Add basic editor to edit target cs files.
* Add options to Start Build. You can now choose to run Setup, GenerateProjectFiles or AutomationTool.
* Add UnrealBuilderHelpers class
* New copy button in log viewer to copy message to clipboard.
* Add changelog link to menubar.
* Check and Install Update now shows version number.
* Selecting Engine Version is now optional.
* **FIXED**: Git dependency cache path
* **FIXED**: OpenClipboard Failed (0x800401D0 (CLIPBRD_E_CANT_OPEN))
* **FIXED**: ShadowErrors.cpp reporting as error.

# 3.1

* Add compiler info to plugin card.
* Improved plugin build.
* Add error message if **_RunUAT.bat_** is missing.
* **FIXED**: Update dialog not showing.
* **FIXED**: Unable to stop Engine build.
* **FIXED**: Crash if no Unreal Engine is installed.
* **FIXED**: Stop build button left disabled.
* **FIXED**: Crash if ___Resources\Icon128.png___ does not exist for plugin.
* **FIXED**: *[UBB-3]* Crash if Current Process file does not exist.
* **FIXED**: *[UBB-4]* Crash if settings file cannot be written when changing platform.
* **FIXED**: *[UBB-6]* Crash with message Input string not in correct format.

# 3.0

* Initial Release

```

`LICENSE.md`:

```md

The MIT License (MIT)

Copyright (c) 2021 Satheesh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
Unreal Engine Binary Builder
======================

<a href="https://www.buymeacoffee.com/ryanjon2040" target="_blank"><img src="https://www.buymeacoffee.com/assets/img/custom_images/yellow_img.png" alt="Buy Me A Coffee" style="height: 41px !important;width: 174px !important;box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;" ></a>

This is a small app designed to create binary build of [Unreal Engine](https://www.unrealengine.com/) from [GitHub source](https://github.com/EpicGames/UnrealEngine).

[![Discord](https://img.shields.io/discord/591914197219016707.svg?label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2)](https://discord.gg/zBMrKRdwgw)

[<img src="https://img.shields.io/twitter/follow/ryanjon2040.svg?style=popout">](https://twitter.com/ryanjon2040)

![](https://github.com/ryanjon2040/UE4-Binary-Builder/actions/workflows/build-ubb.yml/badge.svg)
![](https://img.shields.io/github/last-commit/ryanjon2040/UE4-Binary-Builder.svg?style=popout) 
![](https://img.shields.io/github/license/ryanjon2040/UE4-Binary-Builder.svg?style=popout) ![](https://img.shields.io/github/downloads/ryanjon2040/UE4-Binary-Builder/total.svg?style=popout) 

![](https://img.shields.io/github/languages/code-size/ryanjon2040/UE4-Binary-Builder.svg?style=flat) ![](https://img.shields.io/github/repo-size/ryanjon2040/UE4-Binary-Builder.svg?style=flat)

Watch the below video to get an idea.
[![Watch the video](https://img.youtube.com/vi/fuvvBMrWX8s/maxresdefault.jpg)](https://youtu.be/fuvvBMrWX8s)

# How to use (Compiling Engine)

###### Step I 
- Download the latest release of Unreal Binary Builder.

###### Step II
- Clone or Download UE4 source from github.

###### Step III
- Open Unreal Binary Builder.
- Click *Browse* and select **root folder** of your downloaded Engine (where **_Setup.bat_** and **_GenerateProjectFiles.bat_** exists).

![Screenshot](Documentation/Screenshot_1.png)

- Once the root folder is selected, click **Start**.
- If **Continue to Engine Build** is enabled, then _Unreal Binary Builder_ will automatically continue to compile the Engine with given options under **Compile** tab.

###### Step IV
- Click **_Compile_** tab and set options for the Engine.
![Screenshot](Documentation/Screenshot_2.PNG)

# Troubleshoot

**Bug with 4.25.4**</br>
There is a known issue with 4.25.4 where it fails to build with an error message: `AutomationException: Attempt to add file to temp storage manifest that does not exist (<Path To Engine>\cpp.hint)` This issue has been fixed in 4.26 but if you need to use 4.25.4 see this workaround by Bernard Rouhi: https://github.com/ryanjon2040/UE4-Binary-Builder/issues/26#issuecomment-718204352

**Access Denied on some files?**</br>
On Windows, just change the ownership to Users then try again. To change ownership on Windows, follow these steps
 - Right click on the UE4 folder, choose Properties
 - Switch to Security tab
 - Click on Advanced
 - Near the top, click on Change User
 - A new dialog will open, in the text box at bottom, type in "Users", then click Check Names
 - OK till the end.

   

#### Dependencies

[HandyControl](https://github.com/HandyOrg/HandyControl) by [HandyOrg](https://github.com/HandyOrg)

[DotNetZip](https://github.com/haf/DotNetZip.Semverd) by [Henrik](https://github.com/haf)/Dino Chiesa

[GameAnalytics](https://github.com/GameAnalytics/GA-SDK-C-SHARP) by [Game Analytics](https://gameanalytics.com/)

[Json.NET](https://github.com/JamesNK/Newtonsoft.Json) by [Newtonsoft](https://www.newtonsoft.com/json)

[Sentry.NET](https://github.com/getsentry/sentry-dotnet) by [Sentry](https://sentry.io/)

[AutoGrid](https://github.com/SpicyTaco/SpicyTaco.AutoGrid) by [SpicyTaco](https://github.com/SpicyTaco)

[LogViewer](https://stackoverflow.com/a/16745054) by [Federico Berasategui](https://stackoverflow.com/users/643085/federico-berasategui)

[NetSparkle](https://github.com/NetSparkleUpdater/NetSparkle) by [NetSparkleUpdater](https://github.com/NetSparkleUpdater)

Icons made by <a href="https://www.flaticon.com/authors/freepik" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a>a

```

`UnrealBinaryBuilder.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30611.23
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UnrealBinaryBuilder", "UnrealBinaryBuilder\UnrealBinaryBuilder.csproj", "{C24EF65C-2110-430F-A587-02324C761DA2}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UnrealBinaryBuilderUpdater", "UnrealBinaryBuilderUpdater\UnrealBinaryBuilderUpdater.csproj", "{AB93DC86-D5D9-4C35-AAE4-78997B084053}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C24EF65C-2110-430F-A587-02324C761DA2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C24EF65C-2110-430F-A587-02324C761DA2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C24EF65C-2110-430F-A587-02324C761DA2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C24EF65C-2110-430F-A587-02324C761DA2}.Release|Any CPU.Build.0 = Release|Any CPU
		{AB93DC86-D5D9-4C35-AAE4-78997B084053}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{AB93DC86-D5D9-4C35-AAE4-78997B084053}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{AB93DC86-D5D9-4C35-AAE4-78997B084053}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{AB93DC86-D5D9-4C35-AAE4-78997B084053}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {32EB3FA9-CFBF-4FDC-B971-ADB71C2152FC}
	EndGlobalSection
EndGlobal

```

`UnrealBinaryBuilder/App.xaml`:

```xaml
<Application x:Class="UnrealBinaryBuilder.App"
			 xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
			 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
			 xmlns:local="clr-namespace:UnrealBinaryBuilder"
			 StartupUri="MainWindow.xaml">
	<Application.Resources>
		<ResourceDictionary>
			<ResourceDictionary.MergedDictionaries>
				<ResourceDictionary Source="pack://application:,,,/HandyControl;component/Themes/SkinDark.xaml"/>
				<ResourceDictionary Source="pack://application:,,,/HandyControl;component/Themes/Theme.xaml"/>
			</ResourceDictionary.MergedDictionaries>
		</ResourceDictionary>
	</Application.Resources>
</Application>

```

`UnrealBinaryBuilder/App.xaml.cs`:

```cs
using Sentry;
using System.Windows;
using System.Windows.Threading;
using UnrealBinaryBuilder.UserControls;

namespace UnrealBinaryBuilder
{
	/// <summary>
	/// Interaction logic for App.xaml
	/// </summary>
	public partial class App : Application
	{
		private CrashReporter crashReporter = null;

		public App()
		{
			DispatcherUnhandledException += App_DispatcherUnhandledException;
			SentryOptions sentryOptions = new SentryOptions();
			sentryOptions.Dsn = "https://23f478ac8a004c5782a7f6597c0b0325@o502371.ingest.sentry.io/5584682";
			sentryOptions.StackTraceMode = StackTraceMode.Enhanced;
			sentryOptions.AttachStacktrace = true;
			sentryOptions.AutoSessionTracking = true;
			sentryOptions.DetectStartupTime = StartupTimeDetectionMode.Best;
			sentryOptions.Release = UnrealBinaryBuilderHelpers.GetProductVersionString();
			sentryOptions.ReportAssembliesMode = ReportAssembliesMode.InformationalVersion;
			SentrySdk.Init(sentryOptions);
		}

		void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
		{
			SentryId sentryId = SentrySdk.CaptureException(e.Exception);
			e.Handled = true;

			crashReporter = new CrashReporter(e.Exception);
			crashReporter.Owner = Current.MainWindow;
			crashReporter.CurrentSentryId = sentryId;
			crashReporter.ShowDialog();
			crashReporter = null;
		}
	}
}

```

`UnrealBinaryBuilder/AssemblyInfo.cs`:

```cs
using System.Windows;

[assembly: ThemeInfo(
	ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located
									 //(used if a resource is not found in the page,
									 // or application resource dictionaries)
	ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located
											  //(used if a resource is not found in the page,
											  // app, or any theme specific resource dictionaries)
)]

```

`UnrealBinaryBuilder/Classes/BuilderSettings.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using UnrealBinaryBuilder.UserControls;
using System.Diagnostics;

namespace UnrealBinaryBuilder.Classes
{
	public class BuilderSettingsJson
	{
		// Application settings
		public string Theme { get; set; } // Valid settings are Dark, Light, Violet
		public bool bCheckForUpdatesAtStartup { get; set; }
		public bool bEnableDDCMessages { get; set; }
		public bool bEnableEngineBuildConfirmationMessage { get; set; }
		public bool bShowHTML5DeprecatedMessage { get; set; }
		public bool bShowConsoleDeprecatedMessage { get; set; }

		public string SetupBatFile { get; set; }
		public string CustomBuildFile { get; set; }
		public string GameConfigurations { get; set; }
		public string CustomOptions { get; set; }
		public string AnalyticsOverride { get; set; }

		public bool GitDependencyAll { get; set; }
		public List<GitPlatform> GitDependencyPlatforms { get; set; }
		public int GitDependencyThreads { get; set; }
		public int GitDependencyMaxRetries { get; set; }
		public string GitDependencyProxy { get; set; }
		public bool GitDependencyEnableCache { get; set; }
		public string GitDependencyCache { get; set; }
		public double GitDependencyCacheMultiplier { get; set; }
		public int GitDependencyCacheDays { get; set; }

		public bool bHostPlatformOnly { get; set; }
		public bool bHostPlatformEditorOnly { get; set; }
		public bool bWithWin64 { get; set; }
		public bool bWithWin32 { get; set; }
		public bool bWithMac { get; set; }
		public bool bWithLinux { get; set; }
		public bool bWithLinuxAArch64 { get; set; }
		public bool bWithAndroid { get; set; }
		public bool bWithIOS { get; set; }
		public bool bWithHTML5 { get; set; }
		public bool bWithTVOS { get; set; }
		public bool bWithSwitch { get; set; }
		public bool bWithPS4 { get; set; }
		public bool bWithXboxOne { get; set; }
		public bool bWithLumin { get; set; }
		public bool bWithHoloLens { get; set; }

		public bool bWithDDC { get; set; }
		public bool bHostPlatformDDCOnly { get; set; }
		public bool bSignExecutables { get; set; }
		public bool bEnableSymStore { get; set; }
		public bool bWithFullDebugInfo { get; set; }
		public bool bCleanBuild { get; set; }
		public bool bWithServer { get; set; }
		public bool bWithClient { get; set; }
		public bool bCompileDatasmithPlugins { get; set; }
		public bool bVS2019 { get; set; }
		public bool bShutdownPC { get; set; }
		public bool bShutdownIfBuildSuccess { get; set; }
		public bool bContinueToEngineBuild { get; set; }
		public bool bBuildSetupBatFile { get; set; }
		public bool bGenerateProjectFiles { get; set; }
		public bool bBuildAutomationTool { get; set; }

		public bool bZipEngineBuild { get; set; }		
		public bool bZipEnginePDB { get; set; }
		public bool bZipEngineDebug { get; set; }
		public bool bZipEngineDocumentation { get; set; }
		public bool bZipEngineExtras { get; set; }
		public bool bZipEngineSource { get; set; }
		public bool bZipEngineFeaturePacks { get; set; }
		public bool bZipEngineSamples { get; set; }
		public bool bZipEngineTemplates { get; set; }
		public bool bZipEngineFastCompression { get; set; }
		public string ZipEnginePath { get; set; }
	}

	public class GitPlatform
	{
		public GitPlatform(string InName, bool bInclude)
		{
			Name = InName;
			bIsIncluded = bInclude;
		}

		public string Name { get; set; }
		public bool bIsIncluded { get; set; }
	}

	public static class BuilderSettings
	{
		private static readonly string PROGRAM_SAVED_PATH_BASE = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
		public static readonly string PROGRAM_SAVED_PATH = Path.Combine(PROGRAM_SAVED_PATH_BASE, "UnrealBinaryBuilder");

		private static readonly string PROGRAM_SETTINGS_PATH_BASE = Path.Combine(PROGRAM_SAVED_PATH, "Saved");
		private static readonly string PROGRAM_SETTINGS_FILE_NAME = "Settings.json";

		private static readonly string PROGRAM_LOG_PATH_BASE = Path.Combine(PROGRAM_SAVED_PATH, "Logs");
		private static readonly string PROGRAM_LOG_FILE_NAME = "UnrealBinaryBuilder.log";
		private static readonly string PROGRAM_ERRORLOG_FILE_NAME = "BuildErrors.log";

		private static readonly string PROGRAM_SETTINGS_PATH = Path.Combine(PROGRAM_SETTINGS_PATH_BASE, PROGRAM_SETTINGS_FILE_NAME);
		private static readonly string PROGRAM_LOG_PATH = Path.Combine(PROGRAM_LOG_PATH_BASE, PROGRAM_LOG_FILE_NAME);
		private static readonly string PROGRAM_ERRORLOG_PATH = Path.Combine(PROGRAM_LOG_PATH_BASE, PROGRAM_ERRORLOG_FILE_NAME);

		private static readonly string DEFAULT_GIT_CUSTOM_CACHE_PATH = Path.Combine(PROGRAM_SAVED_PATH, "GitCache");

		private static BuilderSettingsJson GenerateDefaultSettingsJSON()
		{
			BuilderSettingsJson BSJ = new BuilderSettingsJson();
			BSJ.Theme = "Dark";
			BSJ.bCheckForUpdatesAtStartup = true;
			BSJ.bEnableDDCMessages = true;
			BSJ.bEnableEngineBuildConfirmationMessage = true;
			BSJ.bShowHTML5DeprecatedMessage = true;
			BSJ.bShowConsoleDeprecatedMessage = true;

			BSJ.SetupBatFile = null;
			BSJ.CustomBuildFile = null;
			BSJ.GameConfigurations = "Development;Shipping";
			BSJ.CustomOptions = null;
			BSJ.AnalyticsOverride = null;

			BSJ.GitDependencyAll = true;
			BSJ.GitDependencyPlatforms = new List<GitPlatform> { 
				new GitPlatform("Win64", true), 
				new GitPlatform("Win32", true),
				new GitPlatform("Linux", false),
				new GitPlatform("Android", false),
				new GitPlatform("Mac", false), 
				new GitPlatform("IOS", false), 
				new GitPlatform("TVOS", false),
				new GitPlatform("HoloLens", false), 
				new GitPlatform("Lumin", false) };
			BSJ.GitDependencyThreads = 4;
			BSJ.GitDependencyMaxRetries = 4;
			BSJ.GitDependencyProxy = "";
			BSJ.GitDependencyCache = DEFAULT_GIT_CUSTOM_CACHE_PATH;
			BSJ.GitDependencyCacheMultiplier = 2.0;
			BSJ.GitDependencyCacheDays = 7;
			BSJ.GitDependencyEnableCache = true;

			BSJ.bHostPlatformOnly = false;
			BSJ.bHostPlatformEditorOnly = false;
			BSJ.bWithWin64 = true;
			BSJ.bWithWin32 = true;
			BSJ.bWithMac = false;
			BSJ.bWithLinux = false;
			BSJ.bWithLinuxAArch64 = false;
			BSJ.bWithAndroid = false;
			BSJ.bWithIOS = false;
			BSJ.bWithHTML5 = false;
			BSJ.bWithTVOS = false;
			BSJ.bWithSwitch = false;
			BSJ.bWithPS4 = false;
			BSJ.bWithXboxOne = false;
			BSJ.bWithLumin = false;
			BSJ.bWithHoloLens = false;

			BSJ.bWithDDC = true;
			BSJ.bHostPlatformDDCOnly = true;
			BSJ.bSignExecutables = false;
			BSJ.bEnableSymStore = false;
			BSJ.bWithFullDebugInfo = false;
			BSJ.bCleanBuild = false;
			BSJ.bWithServer = false;
			BSJ.bWithClient = false;
			BSJ.bCompileDatasmithPlugins = false;
			BSJ.bVS2019 = false;
			BSJ.bShutdownPC = false;
			BSJ.bShutdownIfBuildSuccess = false;
			BSJ.bContinueToEngineBuild = true;
			BSJ.bBuildSetupBatFile = true;
			BSJ.bGenerateProjectFiles = true;
			BSJ.bBuildAutomationTool = true;

			BSJ.bZipEngineBuild = false;
			BSJ.bZipEngineDebug = false;
			BSJ.bZipEngineDocumentation = true;
			BSJ.bZipEngineExtras = true;
			BSJ.bZipEngineFastCompression = true;
			BSJ.bZipEngineFeaturePacks = true;
			BSJ.bZipEnginePDB = true;
			BSJ.bZipEngineSamples = true;
			BSJ.bZipEngineSource = true;
			BSJ.bZipEngineTemplates = true;
			BSJ.ZipEnginePath = "";

			string JsonOutput = JsonConvert.SerializeObject(BSJ, Formatting.Indented);
			File.WriteAllText(PROGRAM_SETTINGS_PATH, JsonOutput);
			LogEntry logEntry = new LogEntry();
			logEntry.Message = $"New Settings file written to {PROGRAM_SETTINGS_PATH}.";
			((MainWindow)Application.Current.MainWindow).LogControl.AddLogEntry(logEntry, LogViewer.EMessageType.Info);
			((MainWindow)Application.Current.MainWindow).OpenSettingsBtn.IsEnabled = true;
			return JsonConvert.DeserializeObject<BuilderSettingsJson>(JsonOutput);
		}

		public static BuilderSettingsJson GetSettingsFile(bool bLog = false)
		{
			if (Directory.Exists(PROGRAM_LOG_PATH_BASE))
			{
				((MainWindow)Application.Current.MainWindow).OpenLogFolderBtn.IsEnabled = true;
			}

			BuilderSettingsJson ReturnValue = null;
			if (File.Exists(PROGRAM_SETTINGS_PATH))
			{
				string JsonOutput = File.ReadAllText(PROGRAM_SETTINGS_PATH);
				ReturnValue = JsonConvert.DeserializeObject<BuilderSettingsJson>(JsonOutput);
				if (bLog)
				{
					LogEntry logEntry = new LogEntry();
					logEntry.Message = $"Settings loaded from {PROGRAM_SETTINGS_PATH}.";
					((MainWindow)Application.Current.MainWindow).LogControl.AddLogEntry(logEntry, LogViewer.EMessageType.Info);
					((MainWindow)Application.Current.MainWindow).OpenSettingsBtn.IsEnabled = true;
				}
			}
			else
			{
				if (Directory.Exists(PROGRAM_SAVED_PATH) == false)
				{
					Directory.CreateDirectory(PROGRAM_SAVED_PATH);
					if (bLog)
					{
						LogEntry logEntry = new LogEntry();
						logEntry.Message = $"Directory created: {PROGRAM_SAVED_PATH}.";
						((MainWindow)Application.Current.MainWindow).LogControl.AddLogEntry(logEntry, LogViewer.EMessageType.Info);
					}
				}

				if (Directory.Exists(PROGRAM_SETTINGS_PATH_BASE) == false)
				{
					Directory.CreateDirectory(PROGRAM_SETTINGS_PATH_BASE);
					if (bLog)
					{
						LogEntry logEntry = new LogEntry();
						logEntry.Message = $"Directory created: {PROGRAM_SETTINGS_PATH_BASE}.";
						((MainWindow)Application.Current.MainWindow).LogControl.AddLogEntry(logEntry, LogViewer.EMessageType.Info);
					}
				}

				if (Directory.Exists(DEFAULT_GIT_CUSTOM_CACHE_PATH) == false)
				{
					Directory.CreateDirectory(DEFAULT_GIT_CUSTOM_CACHE_PATH);
				}

				ReturnValue = GenerateDefaultSettingsJSON();
			}
			return ReturnValue;
		}

		public static void SaveSettings()
		{
			MainWindow mainWindow = ((MainWindow)Application.Current.MainWindow);
			BuilderSettingsJson BSJ = new BuilderSettingsJson();
			BSJ.Theme = mainWindow.CurrentTheme;
			BSJ.bCheckForUpdatesAtStartup = mainWindow.SettingsJSON.bCheckForUpdatesAtStartup;
			BSJ.SetupBatFile = mainWindow.SetupBatFilePath.Text;
			BSJ.CustomBuildFile = mainWindow.CustomBuildXMLFile.Text;
			BSJ.GameConfigurations = mainWindow.GameConfigurations.Text;
			BSJ.CustomOptions = mainWindow.CustomOptions.Text;
			BSJ.AnalyticsOverride = mainWindow.AnalyticsOverride.Text;

			BSJ.GitDependencyAll = (bool)mainWindow.bGitSyncAll.IsChecked;
			BSJ.GitDependencyThreads = Convert.ToInt32(mainWindow.GitNumberOfThreads.Text);
			BSJ.GitDependencyMaxRetries = Convert.ToInt32(mainWindow.GitNumberOfRetries.Text);
			BSJ.GitDependencyProxy = "";
			BSJ.GitDependencyCache = mainWindow.GitCachePath.Text;
			BSJ.GitDependencyCacheMultiplier = Convert.ToDouble(mainWindow.GitCacheMultiplier.Text);
			BSJ.GitDependencyCacheDays = Convert.ToInt32(mainWindow.GitCacheDays.Text);
			BSJ.GitDependencyEnableCache = (bool)mainWindow.bGitEnableCache.IsChecked;

			BSJ.bHostPlatformOnly = (bool)mainWindow.bHostPlatformOnly.IsChecked;
			BSJ.bHostPlatformEditorOnly = (bool)mainWindow.bHostPlatformEditorOnly.IsChecked;
			BSJ.bWithWin64 = (bool)mainWindow.bWithWin64.IsChecked;
			BSJ.bWithWin32 = (bool)mainWindow.bWithWin32.IsChecked;
			BSJ.bWithMac = (bool)mainWindow.bWithMac.IsChecked;
			BSJ.bWithLinux = (bool)mainWindow.bWithLinux.IsChecked;
			BSJ.bWithLinuxAArch64 = (bool)mainWindow.bWithLinuxAArch64.IsChecked;
			BSJ.bWithAndroid = (bool)mainWindow.bWithAndroid.IsChecked;
			BSJ.bWithIOS = (bool)mainWindow.bWithIOS.IsChecked;
			BSJ.bWithHTML5 = (bool)mainWindow.bWithHTML5.IsChecked;
			BSJ.bWithTVOS = (bool)mainWindow.bWithTVOS.IsChecked;
			BSJ.bWithSwitch = (bool)mainWindow.bWithSwitch.IsChecked;
			BSJ.bWithPS4 = (bool)mainWindow.bWithPS4.IsChecked;
			BSJ.bWithXboxOne = (bool)mainWindow.bWithXboxOne.IsChecked;
			BSJ.bWithLumin = (bool)mainWindow.bWithLumin.IsChecked;
			BSJ.bWithHoloLens = (bool)mainWindow.bWithHololens.IsChecked;

			BSJ.bWithDDC = (bool)mainWindow.bWithDDC.IsChecked;
			BSJ.bHostPlatformDDCOnly = (bool)mainWindow.bHostPlatformDDCOnly.IsChecked;
			BSJ.bSignExecutables = (bool)mainWindow.bSignExecutables.IsChecked;
			BSJ.bEnableSymStore = (bool)mainWindow.bEnableSymStore.IsChecked;
			BSJ.bWithFullDebugInfo = (bool)mainWindow.bWithFullDebugInfo.IsChecked;
			BSJ.bCleanBuild = (bool)mainWindow.bCleanBuild.IsChecked;
			BSJ.bWithServer = (bool)mainWindow.bWithServer.IsChecked;
			BSJ.bWithClient = (bool)mainWindow.bWithClient.IsChecked;
			BSJ.bCompileDatasmithPlugins = (bool)mainWindow.bCompileDatasmithPlugins.IsChecked;
			BSJ.bVS2019 = (bool)mainWindow.bVS2019.IsChecked;
			BSJ.bShutdownPC = (bool)mainWindow.bShutdownWindows.IsChecked;
			BSJ.bShutdownIfBuildSuccess = (bool)mainWindow.bShutdownIfSuccess.IsChecked;
			BSJ.bContinueToEngineBuild = (bool)mainWindow.bContinueToEngineBuild.IsChecked;
			BSJ.bBuildSetupBatFile = (bool)mainWindow.bBuildSetupBatFile.IsChecked;
			BSJ.bGenerateProjectFiles = (bool)mainWindow.bGenerateProjectFiles.IsChecked;
			BSJ.bBuildAutomationTool = (bool)mainWindow.bBuildAutomationTool.IsChecked; ;

			BSJ.bZipEngineBuild = (bool)mainWindow.bZipBuild.IsChecked;
			BSJ.bZipEngineDebug = (bool)mainWindow.bIncludeDEBUG.IsChecked;
			BSJ.bZipEngineDocumentation = (bool)mainWindow.bIncludeDocumentation.IsChecked;
			BSJ.bZipEngineExtras = (bool)mainWindow.bIncludeExtras.IsChecked;
			BSJ.bZipEngineFastCompression = (bool)mainWindow.bFastCompression.IsChecked;
			BSJ.bZipEngineFeaturePacks = (bool)mainWindow.bIncludeFeaturePacks.IsChecked;
			BSJ.bZipEnginePDB = (bool)mainWindow.bIncludePDB.IsChecked;
			BSJ.bZipEngineSamples = (bool)mainWindow.bIncludeSamples.IsChecked;
			BSJ.bZipEngineSource = (bool)mainWindow.bIncludeSource.IsChecked;
			BSJ.bZipEngineTemplates = (bool)mainWindow.bIncludeTemplates.IsChecked;
			BSJ.ZipEnginePath = mainWindow.ZipPath.Text;

			List<GitPlatform> GitPlatformList = mainWindow.SettingsJSON.GitDependencyPlatforms;
			IEnumerable<CheckBox> ComboBoxCollection = GetChildrenOfType<CheckBox>(mainWindow.PlatformStackPanelMain);
			foreach (GitPlatform gp in GitPlatformList)
			{
				string ComboBoxName = $"Git{gp.Name}Platform";
				foreach (CheckBox c in ComboBoxCollection)
				{
					if (c.Name.ToLower() == ComboBoxName.ToLower())
					{
						gp.bIsIncluded = (bool)c.IsChecked;
						break;
					}
				}
			}
			BSJ.GitDependencyPlatforms = GitPlatformList;

			string JsonOutput = JsonConvert.SerializeObject(BSJ, Formatting.Indented);
			File.WriteAllText(PROGRAM_SETTINGS_PATH, JsonOutput);
			LogEntry logEntry = new LogEntry();
			logEntry.Message = $"New Settings file written to {PROGRAM_SETTINGS_PATH}.";
			mainWindow.LogControl.AddLogEntry(logEntry, LogViewer.EMessageType.Info);
		}

		public static void WriteToLogFile(string InContent)
		{
			if (Directory.Exists(PROGRAM_LOG_PATH_BASE) == false)
			{
				Directory.CreateDirectory(PROGRAM_LOG_PATH_BASE);
				MainWindow mainWindow = ((MainWindow)Application.Current.MainWindow);
				mainWindow.OpenLogFolderBtn.IsEnabled = true;
			}
			File.WriteAllText(PROGRAM_LOG_PATH, InContent);
		}

		public static void WriteErrorsToLogFile(string InContent)
		{
			try
			{
				File.Delete(PROGRAM_ERRORLOG_PATH);
			}
			catch (Exception) {}

			if (string.IsNullOrWhiteSpace(InContent) == false)
			{
				if (Directory.Exists(PROGRAM_LOG_PATH_BASE) == false)
				{
					Directory.CreateDirectory(PROGRAM_LOG_PATH_BASE);
				}
				File.WriteAllText(PROGRAM_ERRORLOG_PATH, InContent);
			}
		}

		public static void UpdatePlatformInclusion(string InPlatform, bool bIncluded)
		{
			try
			{
				BuilderSettingsJson BSJ = GetSettingsFile();
				foreach (GitPlatform gp in BSJ.GitDependencyPlatforms)
				{
					if (gp.Name.ToLower() == InPlatform.ToLower())
					{
						gp.bIsIncluded = bIncluded;
						break;
					}
				}

				string JsonOutput = JsonConvert.SerializeObject(BSJ, Formatting.Indented);
				File.WriteAllText(PROGRAM_SETTINGS_PATH, JsonOutput);
			}
			catch (Exception ex)
			{
				string ErrorMessage = $"Failed to update platform setting. ERROR: {ex.Message}";
				GameAnalyticsCSharp.LogEvent(ErrorMessage, GameAnalyticsSDK.Net.EGAErrorSeverity.Error);
				MainWindow mainWindow = ((MainWindow)Application.Current.MainWindow);
				mainWindow.AddLogEntry(ErrorMessage, true);
				HandyControl.Controls.MessageBox.Fatal(ErrorMessage);
			}
		}

		public static void LoadInitialValues()
		{
			MainWindow mainWindow = ((MainWindow)Application.Current.MainWindow);
			List<GitPlatform> GitPlatformList = mainWindow.SettingsJSON.GitDependencyPlatforms;
			IEnumerable<CheckBox> ComboBoxCollection = GetChildrenOfType<CheckBox>(mainWindow.PlatformStackPanelMain);

			foreach (GitPlatform gp in GitPlatformList)
			{
				string ComboBoxName = $"Git{gp.Name}Platform";
				foreach (CheckBox c in ComboBoxCollection)
				{
					if (c.Name.ToLower() == ComboBoxName.ToLower())
					{
						c.IsChecked = gp.bIsIncluded;
						break;
					}
				}
			}
		}

		public static void OpenLogFolder()
		{
			if (Directory.Exists(PROGRAM_LOG_PATH_BASE))
			{
				Process.Start("explorer.exe", PROGRAM_LOG_PATH_BASE);
			}			
		}

		public static void OpenSettings()
		{
			if (File.Exists(PROGRAM_SETTINGS_PATH))
			{
				Process.Start("notepad.exe", PROGRAM_SETTINGS_PATH);
			}
		}

		public static IEnumerable<T> GetChildrenOfType<T>(DependencyObject dependencyObject) where T : DependencyObject
		{
			if (dependencyObject != null)
			{
				for (int i = 0; i < VisualTreeHelper.GetChildrenCount(dependencyObject); i++)
				{
					DependencyObject child = VisualTreeHelper.GetChild(dependencyObject, i);
					if (child != null && child is T)
					{
						yield return (T)child;
					}

					foreach (T childOfChild in GetChildrenOfType<T>(child))
					{
						yield return childOfChild;
					}
				}
			}
		}
	}
}

```

`UnrealBinaryBuilder/Classes/GameAnalyticsCSharp.cs`:

```cs
using GameAnalyticsSDK.Net;

namespace UnrealBinaryBuilder.Classes
{
	public static class GameAnalyticsCSharp
	{
		// Please DO NOT change this. If you don't want Analytics, set both GAME_KEY and SECRET_KEY to null ///////////////////
		private static readonly string GAME_KEY = "33551f8809806eaac2ad5be41c403c8d"; // null
		private static readonly string SECRET_KEY = "38986827a8ff55c879424d4bea7cfe8e99b44b03"; // null
		///////////////////////////////////////////////////////////////////////////////////////////////

		private static MainWindow mainWindow = null;

		public static void InitializeGameAnalytics(string InProductVersion, MainWindow InMainWindow)
		{
			if (GAME_KEY != null && SECRET_KEY != null)
			{
				GameAnalytics.ConfigureBuild($"Unreal Binary Builder {InProductVersion}");

				// https://gameanalytics.com/docs/item/c-sharp-sdk#initializing
				GameAnalytics.Initialize(GAME_KEY, SECRET_KEY);
				mainWindow = InMainWindow;
				mainWindow.AddLogEntry("Unreal Binary Builder Analytics Initialized.");
#if DEBUG
				GameAnalytics.AddDesignEvent("Program:Start:Debug");
#else
				GameAnalytics.AddDesignEvent("Program:Start:Release");
#endif
			}
		}

		public static void EndSession()
		{
			if (mainWindow != null)
			{
				GameAnalytics.EndSession();
			}
		}

		public static void AddDesignEvent(string InMessage)
		{
			if (mainWindow != null)
			{
				GameAnalytics.AddDesignEvent(InMessage);
#if DEBUG
				mainWindow.AddLogEntry($"Unreal Binary Builder Analytics (Design): {InMessage}");
#endif
			}
		}

		public static void AddProgressStart(string InProgression01)
		{
			if (mainWindow != null)
			{
				GameAnalytics.AddProgressionEvent(EGAProgressionStatus.Start, InProgression01);
#if DEBUG
				mainWindow.AddLogEntry($"Unreal Binary Builder Analytics (Progress Start): {InProgression01}");
#endif
			}
		}

		public static void AddProgressStart(string InProgression01, string InProgression02)
		{
			if (mainWindow != null)
			{
				GameAnalytics.AddProgressionEvent(EGAProgressionStatus.Start, InProgression01, InProgression02);
#if DEBUG
				mainWindow.AddLogEntry($"Unreal Binary Builder Analytics (Progress Start): {InProgression01}::{InProgression02}");
#endif
			}
		}

		public static void AddProgressEnd(string InProgression01, bool bIsFail = false)
		{
			if (mainWindow != null)
			{
				GameAnalytics.AddProgressionEvent(bIsFail ? EGAProgressionStatus.Fail : EGAProgressionStatus.Complete, InProgression01);
#if DEBUG
				mainWindow.AddLogEntry($"Unreal Binary Builder Analytics (Progress End): {InProgression01}");
#endif
			}
		}

		public static void AddProgressEnd(string InProgression01, string InProgression02, bool bIsFail = false)
		{
			if (mainWindow != null)
			{
				GameAnalytics.AddProgressionEvent(bIsFail ? EGAProgressionStatus.Fail : EGAProgressionStatus.Complete, InProgression01, InProgression02);
#if DEBUG
				mainWindow.AddLogEntry($"Unreal Binary Builder Analytics (Progress End): {InProgression01}::{InProgression02}");
#endif
			}
		}

		public static void LogEvent(string InMessage, EGAErrorSeverity InLogLevel)
		{
			if (mainWindow != null)
			{
				GameAnalytics.AddErrorEvent(InLogLevel, InMessage);
#if DEBUG
				mainWindow.AddLogEntry($"Unreal Binary Builder Analytics (Log): {InMessage}");
#endif
			}
		}
	}
}

```

`UnrealBinaryBuilder/Classes/Git.cs`:

```cs
using LibGit2Sharp;
using System.Windows;

namespace UnrealBinaryBuilder.Classes
{
    public static class Git
    {
		private static Repository repository = null;

		public static string CommitHash
		{
			get
			{
				UpdateRepository();
				return repository != null ? repository.Head.Tip.Sha : null;
			}
		}

		public static string CommitHashShort => string.IsNullOrWhiteSpace(CommitHash) ? null : CommitHash.Remove(CommitHash.Length - 33);

		public static string BranchName
		{
			get
			{
				UpdateRepository();
				return repository != null ? repository.Head.FriendlyName : null;
			}
		}

		public static string TrackedBranchName
		{
			get
			{
				UpdateRepository();
				if (repository != null)
				{
					return repository.Head.IsTracking ? repository.Head.TrackedBranch.FriendlyName : null;
				}

				return null;
			}
		}

		private static void UpdateRepository()
		{
			MainWindow mainWindow = (MainWindow)Application.Current.MainWindow;
			if (repository == null && Repository.IsValid(mainWindow.SetupBatFilePath.Text))
			{
				repository = new Repository(mainWindow.SetupBatFilePath.Text);
			}
		}
	}
}

```

`UnrealBinaryBuilder/Classes/Plugins.cs`:

```cs
using System.Collections.Generic;
using Microsoft.Win32;

namespace UnrealBinaryBuilder.Classes
{
	public class Plugins
	{
		public static List<EngineBuild> GetInstalledEngines()
		{
			RegistryKey EngineInstallations = Registry.LocalMachine.OpenSubKey("Software\\EpicGames\\Unreal Engine");
			if (EngineInstallations == null)
			{
				return null;
			}

			List<EngineBuild> ReturnValue = new List<EngineBuild>();
			string[] InstalledEngines = EngineInstallations.GetSubKeyNames();
			foreach (var s in InstalledEngines)
			{
				RegistryKey InstalledDirectoryKey = EngineInstallations.OpenSubKey(s);
				object o = InstalledDirectoryKey.GetValue("InstalledDirectory");

				EngineBuild engineBuild = new EngineBuild();
				engineBuild.bIsCustomEngine = false;
				engineBuild.EngineAssociation = s;
				engineBuild.EngineName = s;
				engineBuild.EnginePath = o as string;

				ReturnValue.Add(engineBuild);
			}

			RegistryKey CustomEngineInstallations = Registry.CurrentUser.OpenSubKey("Software\\Epic Games\\Unreal Engine\\Builds");
			InstalledEngines = CustomEngineInstallations.GetValueNames();
			foreach (var s in InstalledEngines)
			{
				object o = CustomEngineInstallations.GetValue(s);
				string EngineBuildName = UnrealBinaryBuilderHelpers.GetEngineVersion(o as string);

				EngineBuild engineBuild = new EngineBuild();
				engineBuild.bIsCustomEngine = true;
				engineBuild.EngineAssociation = s;
				engineBuild.EngineName = $"{EngineBuildName} (Custom)";
				engineBuild.EnginePath = o as string;

				if (EngineBuildName != null /*&& ReturnValue.Contains(engineBuild) == false*/)
				{
					ReturnValue.Add(engineBuild);
				}
			}

			return ReturnValue;
		}
	}

	class UE4PluginJson
	{
		public string FriendlyName { get; set; }
		public string Description { get; set; }
		public string MarketplaceURL { get; set; }
		public bool IsBetaVersion { get; set; }
		public bool IsExperimentalVersion { get; set; }
		public IList<UE4PluginModule> Modules { get; set; }
	}

	class UE4PluginModule
	{
		public IList<string> WhitelistPlatforms { get; set; }
	}

	public class EngineBuild
	{
		public string EngineName { get; set; }
		public string EnginePath { get; set; }
		public bool bIsCustomEngine { get; set; }
		public string EngineAssociation { get; set; }

		public override bool Equals(object obj)
		{
			if (obj is EngineBuild)
			{
				return ((EngineBuild)obj).EngineName == EngineName;
			}

			return false;
		}

		public override int GetHashCode()
		{
			return EngineName.GetHashCode();
		}
	}
}

```

`UnrealBinaryBuilder/Classes/PostBuildSettings.cs`:

```cs
using Ionic.Zip;
using Ionic.Zlib;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.AccessControl;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using UnrealBinaryBuilder.UserControls;

namespace UnrealBinaryBuilder.Classes
{
	public class PostBuildSettings
	{
		Task ZippingTask = null;
		static CancellationTokenSource ZipCancelTokenSource = new CancellationTokenSource();
		CancellationToken ZipCancelToken = ZipCancelTokenSource.Token;
		MainWindow mainWindow = null;

		public PostBuildSettings(MainWindow _mainWindow)
		{
			mainWindow = _mainWindow;
		}

		public bool CanSaveToZip()
		{
			return ShouldSaveToZip() && DirectoryIsWritable(Path.GetDirectoryName(mainWindow.ZipPath.Text));
		}

		public bool ShouldSaveToZip()
		{
			return (bool)mainWindow.bZipBuild.IsChecked && !string.IsNullOrEmpty(mainWindow.ZipPath.Text);
		}

		public bool DirectoryIsWritable(string DirectoryPath)
		{
			if (string.IsNullOrWhiteSpace(DirectoryPath))
			{
				return false;
			}

			DirectoryInfo ZipDirectory = new DirectoryInfo(DirectoryPath);
			bool bDirectoryExists = ZipDirectory.Exists;
			bool bHasWriteAccess = false;
			if (bDirectoryExists)
			{
				try
				{
					AuthorizationRuleCollection collection = new DirectoryInfo(ZipDirectory.FullName).GetAccessControl().GetAccessRules(true, true, typeof(System.Security.Principal.NTAccount));
					foreach (FileSystemAccessRule rule in collection)
					{
						if (rule.AccessControlType == AccessControlType.Allow)
						{
							bHasWriteAccess = true;
							break;
						}
					}
				}
				catch (Exception)
				{

				}
			}

			return bDirectoryExists && bHasWriteAccess;
		}

		public void PrepareToSave()
		{
			ZipCancelTokenSource.Dispose();
			ZipCancelTokenSource = new CancellationTokenSource();
			ZipCancelToken = ZipCancelTokenSource.Token;
		}

		public async void SavePluginToZip(PluginCard pluginCard, string ZipLocationToSave, bool bZipForMarketplace)
		{
			Application.Current.Dispatcher.Invoke(() =>
			{
				GameAnalyticsCSharp.AddProgressStart("PluginZip", "Progress");
			});

			CompressionLevel CL = CompressionLevel.BestSpeed;
			ZippingTask = Task.Run(() =>
			{
				using (var zipFile = new ZipFile { CompressionLevel = CL })
				{
					IEnumerable<string> files = Directory.EnumerateFiles(pluginCard.DestinationPath, "*.*", SearchOption.AllDirectories);
					List<string> filesToAdd = new List<string>();

					foreach (string file in files)
					{
						bool bSkipFile = false;
						Application.Current.Dispatcher.Invoke(() =>
						{
							string CurrentFilePath = Path.GetFullPath(file).ToLower();
							if (bZipForMarketplace && (CurrentFilePath.Contains(@"\binaries\") || CurrentFilePath.Contains(@"\intermediate\")))
							{
								bSkipFile = true;
							}

							if (bSkipFile == false)
							{
								filesToAdd.Add(file);
							}
						});
					}
					Application.Current.Dispatcher.Invoke(() =>
					{
						pluginCard.ZipProgressbar.IsIndeterminate = false;
						pluginCard.ZipProgressbar.Value = 0;
						pluginCard.ZipProgressbar.Maximum = filesToAdd.Count;
					});

					foreach (string file in filesToAdd)
					{
						zipFile.AddFile(file, Path.GetDirectoryName(file).Replace(pluginCard.DestinationPath, string.Empty));
					}

					zipFile.SaveProgress += (o, args) =>
					{
						if (args.EventType == ZipProgressEventType.Saving_BeforeWriteEntry)
						{
							Application.Current.Dispatcher.Invoke(() =>
							{
								pluginCard.ZipProgressbar.Value = Convert.ToInt32(args.EntriesSaved + 1);
							});
						}
						else if (args.EventType == ZipProgressEventType.Saving_Completed)
						{
							Application.Current.Dispatcher.Invoke(() =>
							{
								GameAnalyticsCSharp.AddProgressEnd("PluginZip", "Progress");
							});
						}
					};

					zipFile.UseZip64WhenSaving = Zip64Option.Always;
					zipFile.Save(ZipLocationToSave);
					Application.Current.Dispatcher.Invoke(() => { mainWindow.AddLogEntry($"Plugin zipped and saved to: {ZipLocationToSave}"); });
				}
			});

			await ZippingTask;
		}

		public async void SaveToZip(string InBuildDirectory, string ZipLocationToSave)
		{
			Application.Current.Dispatcher.Invoke(() =>
			{
				GameAnalyticsCSharp.AddProgressStart("Zip", "Progress");
				mainWindow.TotalResult.Content = "Hold on...Stats will be displayed soon.";
				mainWindow.CurrentFileSaving.Content = "Waiting...";
				mainWindow.FileSaveState.Content = "State: Preparing...";
				mainWindow.ZipStatusLabel.Visibility = Visibility.Collapsed;
				mainWindow.ZipStausStackPanel.Visibility = Visibility.Visible;
			});

			CompressionLevel CL = (bool)mainWindow.bFastCompression.IsChecked ? CompressionLevel.BestSpeed : CompressionLevel.BestCompression;

			ZippingTask = Task.Run(() =>
			{
				using (var zipFile = new ZipFile { CompressionLevel = CL })
				{
					Application.Current.Dispatcher.Invoke(() => { mainWindow.FileSaveState.Content = $"State: Be Patient! This might take a long time. Ninjas are finding files in {InBuildDirectory}"; });
					IEnumerable<string> files = Directory.EnumerateFiles(InBuildDirectory, "*.*", SearchOption.AllDirectories);

					ZipCancelToken.ThrowIfCancellationRequested();

					List<string> filesToAdd = new List<string>();

					int SkippedFiles = 0;
					int AddedFiles = 0;
					int TotalFiles = files.Count();

					long TotalSize = 0;
					long TotalSizeToZip = 0;
					long SkippedSize = 0;
					string TotalSizeInString = "0B";
					string TotalSizeToZipInString = "0B";
					string SkippedSizeToZipInString = "0B";
					Application.Current.Dispatcher.Invoke(() => { mainWindow.FileSaveState.Content = "State: Preparing files for zipping..."; });
					foreach (string file in files)
					{
						bool bSkipFile = false;
						Application.Current.Dispatcher.Invoke(() =>
						{
							string CurrentFilePath = Path.GetFullPath(file).ToLower();
							if (mainWindow.bIncludePDB.IsChecked == false && Path.GetExtension(file).ToLower() == ".pdb")
							{
								bSkipFile = true;
							}

							if (mainWindow.bIncludeDEBUG.IsChecked == false && Path.GetExtension(file).ToLower() == ".debug")
							{
								bSkipFile = true;
							}

							if (mainWindow.bIncludeDocumentation.IsChecked == false && CurrentFilePath.Contains(@"\source\") == false && CurrentFilePath.Contains(@"\documentation\"))
							{
								bSkipFile = true;
							}

							if (mainWindow.bIncludeExtras.IsChecked == false && CurrentFilePath.Contains(@"\extras\redist\") == false && CurrentFilePath.Contains(@"\extras\"))
							{
								bSkipFile = true;
							}

							if (mainWindow.bIncludeSource.IsChecked == false && CurrentFilePath.Contains(@"\source\developer\"))
							{
								bSkipFile = true;
							}

							if (mainWindow.bIncludeSource.IsChecked == false && CurrentFilePath.Contains(@"\source\editor\"))
							{
								bSkipFile = true;
							}

							if (mainWindow.bIncludeSource.IsChecked == false && CurrentFilePath.Contains(@"\source\programs\"))
							{
								bSkipFile = true;
							}

							if (mainWindow.bIncludeSource.IsChecked == false && CurrentFilePath.Contains(@"\source\runtime\"))
							{
								bSkipFile = true;
							}

							if (mainWindow.bIncludeSource.IsChecked == false && CurrentFilePath.Contains(@"\source\thirdparty\"))
							{
								bSkipFile = true;
							}

							if (mainWindow.bIncludeFeaturePacks.IsChecked == false && CurrentFilePath.Contains(@"\featurepacks\"))
							{
								bSkipFile = true;
							}

							if (mainWindow.bIncludeSamples.IsChecked == false && CurrentFilePath.Contains(@"\samples\"))
							{
								bSkipFile = true;
							}

							if (mainWindow.bIncludeTemplates.IsChecked == false && CurrentFilePath.Contains(@"\source\") == false && CurrentFilePath.Contains(@"\content\editor") == false && CurrentFilePath.Contains(@"\templates\"))
							{
								bSkipFile = true;
							}

						});

						TotalSize += new FileInfo(file).Length;
						TotalSizeInString = BytesToString(TotalSize);
						if (bSkipFile)
						{
							SkippedFiles++;
							SkippedSize += new FileInfo(file).Length;
							SkippedSizeToZipInString = BytesToString(SkippedSize);
							//Application.Current.Dispatcher.Invoke(() => { mainWindow.AddZipLog($"File Skipped: {file}", MainWindow.ZipLogInclusionType.FileSkipped); });
						}
						else
						{
							filesToAdd.Add(file);
							AddedFiles++;
							TotalSizeToZip += new FileInfo(file).Length;
							TotalSizeToZipInString = BytesToString(TotalSizeToZip);
							//Application.Current.Dispatcher.Invoke(() => { mainWindow.AddZipLog($"File Included: {file}", MainWindow.ZipLogInclusionType.FileIncluded); });
						}

						Application.Current.Dispatcher.Invoke(() => { mainWindow.CurrentFileSaving.Content = string.Format("Total: {0}. Added: {1}. Skipped: {2}", TotalFiles, AddedFiles, SkippedFiles); });
						ZipCancelToken.ThrowIfCancellationRequested();
					}

					Application.Current.Dispatcher.Invoke(() =>
					{
						mainWindow.TotalResult.Content = string.Format("Total Size: {0}. To Zip: {1}. Skipped: {2}", TotalSizeInString, TotalSizeToZipInString, SkippedSizeToZipInString);
						mainWindow.FileSaveState.Content = "State: Verifying...";
						mainWindow.OverallProgressbar.Maximum = filesToAdd.Count;
					});

					foreach (string file in filesToAdd)
					{
						ZipCancelToken.ThrowIfCancellationRequested();
						zipFile.AddFile(file, Path.GetDirectoryName(file).Replace(InBuildDirectory, string.Empty));
					}

					long ProcessedSize = 0;
					string ProcessSizeInString = "0B";

					Application.Current.Dispatcher.Invoke(() =>
					{
						mainWindow.OverallProgressbar.IsIndeterminate = false;
						mainWindow.FileProgressbar.IsIndeterminate = false;
					});

					zipFile.SaveProgress += (o, args) =>
					{
						ZipCancelToken.ThrowIfCancellationRequested();
						if (args.EventType == ZipProgressEventType.Saving_BeforeWriteEntry)
						{
							Application.Current.Dispatcher.Invoke(() =>
							{
								mainWindow.FileSaveState.Content = "State: Begin Writing...";
								mainWindow.CurrentFileSaving.Content = string.Format("Saving File: {0} ({1}/{2})", Path.GetFileName(args.CurrentEntry.FileName), (args.EntriesSaved + 1), (args.EntriesTotal));
								mainWindow.OverallProgressbar.Value = Convert.ToInt32(args.EntriesSaved + 1);
							});
						}
						else if (args.EventType == ZipProgressEventType.Saving_EntryBytesRead)
						{
							Application.Current.Dispatcher.Invoke(() =>
							{
								mainWindow.FileSaveState.Content = "State: Writing...";
								mainWindow.FileProgressbar.Value = (int)((args.BytesTransferred * 100) / args.TotalBytesToTransfer);
							});
						}
						else if (args.EventType == ZipProgressEventType.Saving_AfterWriteEntry)
						{
							ProcessedSize += new FileInfo(Path.Combine(InBuildDirectory, args.CurrentEntry.FileName)).Length;
							ProcessSizeInString = BytesToString(ProcessedSize);
							Application.Current.Dispatcher.Invoke(() => { mainWindow.TotalResult.Content = string.Format("Total Size: {0}. To Zip: {1}. Skipped: {2}. Processed: {3}", TotalSizeInString, TotalSizeToZipInString, SkippedSizeToZipInString, ProcessSizeInString); });
						}
						else if (args.EventType == ZipProgressEventType.Saving_Started)
						{
							Application.Current.Dispatcher.Invoke(() =>
							{
								mainWindow.CurrentFileSaving.Content = "";
								mainWindow.FileSaveState.Content = string.Format("State: Saving zip file ({0} files) to {1}", TotalFiles, mainWindow.ZipPath.Text);
							});
						}
						else if (args.EventType == ZipProgressEventType.Saving_Completed)
						{
							Application.Current.Dispatcher.Invoke(() =>
							{
								GameAnalyticsCSharp.AddProgressEnd("Zip", "Progress");
								mainWindow.TryShutdown();
							});
						}
					};


					zipFile.UseZip64WhenSaving = Zip64Option.Always;
					zipFile.Save(ZipLocationToSave);
					Application.Current.Dispatcher.Invoke(() => 
					{
						mainWindow.CurrentFileSaving.Visibility = mainWindow.OverallProgressbar.Visibility = mainWindow.CancelZipping.Visibility = Visibility.Collapsed;
						mainWindow.FileSaveState.Content = $"State: Saved to {ZipLocationToSave}";
						mainWindow.AddLogEntry($"Done zipping. {ZipLocationToSave}");
					});
				}
			}, ZipCancelToken);

			try
			{
				await ZippingTask;
			}
			catch (OperationCanceledException e)
			{
				Application.Current.Dispatcher.Invoke(() =>
				{
					mainWindow.CurrentFileSaving.Content = "";
					mainWindow.FileSaveState.Content = "Operation canceled.";
					mainWindow.AddLogEntry($"{nameof(OperationCanceledException)} with message: {e.Message}");
				});
			}
			finally
			{
				Application.Current.Dispatcher.Invoke(() =>
				{
					mainWindow.CancelZipping.Content = "Cancel Zipping";
					mainWindow.CancelZipping.IsEnabled = true;
				});
			}
		}

		public void CancelTask()
		{
			GameAnalyticsCSharp.AddProgressEnd("Zip", "Progress", true);
			mainWindow.CancelZipping.Content = "Canceling. Please wait...";
			mainWindow.CancelZipping.IsEnabled = false;
			ZipCancelTokenSource.Cancel();
		}

		public static string BytesToString(long byteCount)
		{
			string[] suf = { "B", "KB", "MB", "GB", "TB" };
			if (byteCount == 0)
			{
				return "0" + suf[0];
			}
			long bytes = Math.Abs(byteCount);
			int place = Convert.ToInt32(Math.Floor(Math.Log(bytes, 1024)));
			double num = Math.Round(bytes / Math.Pow(1024, place), 1);
			return (Math.Sign(byteCount) * num).ToString() + suf[place];
		}
	}
}

```

`UnrealBinaryBuilder/MainWindow.xaml`:

```xaml
<hc:GlowWindow
				xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
				xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
				xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
				xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
				xmlns:hc="https://handyorg.github.io/handycontrol" 
				xmlns:st="http://schemas.spicytaco.io/"
				xmlns:local="clr-namespace:UnrealBinaryBuilder.UserControls"
				xmlns:Classes="clr-namespace:UnrealBinaryBuilder.Classes" 
				xmlns:local1="clr-namespace:UnrealBinaryBuilder"	x:Name="UnrealBinaryBuilderWindow"
				x:Class="UnrealBinaryBuilder.MainWindow" 
				mc:Ignorable="d"
				Background="{DynamicResource MainContentBackgroundBrush}"
				WindowStartupLocation="CenterScreen"
				Title="Unreal Binary Builder"
				ActiveGlowColor="{DynamicResource PrimaryColor}"
				InactiveGlowColor="{DynamicResource SecondaryBorderColor}"
				Height="720" 
				Width="1280" Closing="UnrealBinaryBuilderWindow_Closing">
	<hc:GlowWindow.NonClientAreaContent>
		<StackPanel VerticalAlignment="Stretch" Orientation="Horizontal">
			<Separator Width="10" VerticalAlignment="Center" HorizontalAlignment="Center" Margin="10,0,0,0"/>
			<Button x:Name="GetSourceCode" Content="Source Code" Style="{StaticResource ButtonBaseStyle}" Click="GetSourceCode_Click"/>
			<Menu>
				<MenuItem Header="Support">
					<MenuItem x:Name="SupportUnrealX" Header="Unreal Binary Builder" Click="SupportUnrealX_Click"/>
					<MenuItem x:Name="SupportAgora" Header="Agora" Click="SupportAgora_Click"/>
				</MenuItem>
			</Menu>
			<Button x:Name="FeedbackBtn" Content="Feedback" Style="{StaticResource ButtonBaseStyle}" Click="FeedbackBtn_Click"/>
			<Button x:Name="ChangelogBtn" Content="Changelog" Style="{StaticResource ButtonBaseStyle}" Click="ChangelogBtn_Click" />
			<Button x:Name="AboutBtn" Content="About" Style="{StaticResource ButtonBaseStyle}" Click="AboutBtn_Click"/>
		</StackPanel>
	</hc:GlowWindow.NonClientAreaContent>
	<Grid>
		<DockPanel LastChildFill="True">
			<hc:TabControl x:Name="MainTabControl" ShowCloseButton="False" IsDraggable="False" IsTabFillEnabled="True" IsAnimationEnabled="True" DockPanel.Dock="Top" Height="500" Style="{StaticResource TabControlCapsuleSolid}">
				<hc:TabItem Header="Engine" IsSelected="True">
					<hc:TabControl x:Name="EngineTabControl" ShowCloseButton="False" IsDraggable="False" IsTabFillEnabled="True" IsAnimationEnabled="True" ShowScrollButton="True" Style="{StaticResource TabControlInLine}" Background="#FF2D2D30">
						<hc:TabItem Header="Setup" IsSelected="True" ToolTip="Allows you to configure Setup.bat settings and run it.">
							<hc:SimplePanel>
								<Grid Margin="360 100" Height="100">
									<Grid.ColumnDefinitions>
										<ColumnDefinition Width="470"/>
										<ColumnDefinition Width="80"/>
										<ColumnDefinition Width="*"/>
									</Grid.ColumnDefinitions>
									<Grid.RowDefinitions>
										<RowDefinition Height="40"/>
										<RowDefinition Height="*"/>
									</Grid.RowDefinitions>
									<TextBox x:Name="SetupBatFilePath" Grid.Row="0" Grid.Column="0" Text="{Binding SetupBatFile}" hc:InfoElement.Placeholder="Choose Engine Root Folder" hc:InfoElement.Necessary="True" Style="{StaticResource TextBoxExtend}" TextChanged="SetupBatFilePath_TextChanged" />
									<Button x:Name="BrowseEngineFolder" Grid.Row="0" Grid.Column="1" Content="Browse" Click="BrowseEngineFolder_Click"/>
									<Grid Grid.Row="1" Grid.Column="0">
										<Grid.RowDefinitions>
											<RowDefinition Height="*"/>
											<RowDefinition Height="*"/>
										</Grid.RowDefinitions>
										<Grid.ColumnDefinitions>
											<ColumnDefinition Width="*"/>
											<ColumnDefinition Width="*"/>
											<ColumnDefinition Width="*"/>
										</Grid.ColumnDefinitions>
										<CheckBox x:Name="bBuildSetupBatFile" Grid.Row="0" Grid.Column="0" Content="Build Setup" IsChecked="{Binding bBuildSetupBatFile}"/>
										<CheckBox x:Name="bGenerateProjectFiles" Grid.Row="0" Grid.Column="1" Content="Generate Project Files" IsChecked="{Binding bGenerateProjectFiles}"/>
										<CheckBox x:Name="bBuildAutomationTool" Grid.Row="0" Grid.Column="2" Content="Build Automation Tool" IsChecked="{Binding bBuildAutomationTool}"/>

										<Button x:Name="StartSetupBatFile" Grid.Row="1" Grid.Column="0" Grid.ColumnSpan="3" HorizontalAlignment="Stretch" Content="Start" Style="{StaticResource ButtonPrimary}" IsEnabled="{Binding Text.Length, ElementName=SetupBatFilePath, Mode=OneWay}" Click="StartSetupBatFile_Click" />
									</Grid>
								</Grid>

								<CheckBox x:Name="bContinueToEngineBuild" Content="Continue to Engine Build" IsChecked="{Binding bContinueToEngineBuild}" HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="0,0,153,16"/>
								<Grid>
									<GroupBox Header="Platforms" HorizontalAlignment="Left" VerticalAlignment="Top" Margin="10" Style="{StaticResource GroupBoxOriginal}">
										<StackPanel x:Name="PlatformStackPanelMain" Width="200">
											<CheckBox x:Name="GitWin64Platform" Content="Windows 64" Margin="5" HorizontalAlignment="Left" Checked="GitPlatform_CheckedChanged" Unchecked="GitPlatform_CheckedChanged"/>
											<CheckBox x:Name="GitWin32Platform" Content="Windows 32" Margin="5" HorizontalAlignment = "Left" Checked="GitPlatform_CheckedChanged" Unchecked="GitPlatform_CheckedChanged"/>
											<CheckBox x:Name="GitLinuxPlatform" Content="Linux" Margin="5" HorizontalAlignment = "Left" Checked="GitPlatform_CheckedChanged" Unchecked="GitPlatform_CheckedChanged"/>
											<CheckBox x:Name="GitAndroidPlatform" Content="Android" Margin="5" HorizontalAlignment = "Left" Checked="GitPlatform_CheckedChanged" Unchecked="GitPlatform_CheckedChanged"/>
											<CheckBox x:Name="GitLuminPlatform" Content="Lumin" Margin="5" HorizontalAlignment = "Left" Checked="GitPlatform_CheckedChanged" Unchecked="GitPlatform_CheckedChanged"/>
											<CheckBox x:Name="GitHololensPlatform" Content="Holo Lens" Margin="5" HorizontalAlignment = "Left" Checked="GitPlatform_CheckedChanged" Unchecked="GitPlatform_CheckedChanged"/>
											<CheckBox x:Name="GitMacPlatform" Content="Mac" Margin="5" HorizontalAlignment = "Left" Checked="GitPlatform_CheckedChanged" Unchecked="GitPlatform_CheckedChanged"/>
											<CheckBox x:Name="GitIOSPlatform" Content="IOS" Margin="5" HorizontalAlignment = "Left" Checked="GitPlatform_CheckedChanged" Unchecked="GitPlatform_CheckedChanged"/>
											<CheckBox x:Name="GitTVOSPlatform" Content="TV OS" Margin="5" HorizontalAlignment = "Left" Checked="GitPlatform_CheckedChanged" Unchecked="GitPlatform_CheckedChanged"/>
										</StackPanel>
									</GroupBox>
									<GroupBox Header="Git Dependencies Options" VerticalAlignment="Top" HorizontalAlignment="Left" Margin="1068,10,0,0" Height="201" Width="200" Style="{StaticResource GroupBoxOriginal}">
										<StackPanel>
											<CheckBox x:Name="bGitSyncAll" HorizontalAlignment="Left" Content="Sync All" IsChecked="{Binding GitDependencyAll}" Margin="5" ToolTip ="Sync all folders"/>
											<CheckBox HorizontalAlignment="Left" Content="Force" Margin="5" IsChecked="True" IsEnabled="False" ToolTip="--force parameter must be added to git."/>
											<StackPanel Orientation="Horizontal" >
												<TextBlock Text="Threads " VerticalAlignment="Center"/>
												<hc:TextBox x:Name="GitNumberOfThreads" VerticalAlignment="Center" TextType="Number" hc:InfoElement.Placeholder="Number of threads" Text="{Binding GitDependencyThreads}" Margin="5" Width="140" ToolTip="Use N cpu threads when downloading new files"/>
											</StackPanel>
											<StackPanel Orientation="Horizontal" >
												<TextBlock Text="Retries  " VerticalAlignment="Center"/>
												<hc:TextBox x:Name="GitNumberOfRetries" VerticalAlignment="Center" TextType="Number" hc:InfoElement.Placeholder="Number of retries" Text="{Binding GitDependencyMaxRetries}" Margin="5" Width="140" ToolTip="Override maximum number of retries per file"/>
											</StackPanel>
										</StackPanel>
									</GroupBox>
									<GroupBox Header="Git Cache" VerticalAlignment="Top" HorizontalAlignment="Left" Margin="1068,216,0,0" Width="200" Style="{StaticResource GroupBoxOriginal}">
										<StackPanel>
											<CheckBox x:Name="bGitEnableCache" Content="Enable Cache" IsChecked="{Binding GitDependencyEnableCache}" ToolTip="Enable/Disable caching of downloaded files" Margin="10"/>
											<StackPanel Orientation="Horizontal" HorizontalAlignment="Stretch">
												<hc:TextBox x:Name="GitCachePath" hc:InfoElement.Placeholder="Cache path" IsEnabled="{Binding IsChecked, ElementName=bGitEnableCache}" Text="{Binding GitDependencyCache}" ToolTip="Custom path for the download cache" Width="132"/>
												<Button x:Name="GitCachePathBrowse" Content="Browse" HorizontalAlignment="Right" IsEnabled="{Binding IsChecked, ElementName=bGitEnableCache}" Click="GitCachePathBrowse_Click"/>
											</StackPanel>
											<hc:TextBox x:Name="GitCacheDays" VerticalAlignment="Center" TextType="Number" hc:InfoElement.Placeholder="Cache days" IsEnabled="{Binding IsChecked, ElementName=bGitEnableCache}" Text="{Binding GitDependencyCacheDays}" ToolTip="Number of days to keep entries in cache"/>
											<hc:TextBox x:Name="GitCacheMultiplier" VerticalAlignment="Center" TextType="Digits" hc:InfoElement.Placeholder="Cache Multiplier" IsEnabled="{Binding IsChecked, ElementName=bGitEnableCache}" Text="{Binding GitDependencyCacheMultiplier}" ToolTip="Cache size as multiplier of current download"/>
										</StackPanel>
									</GroupBox>
								</Grid>
							</hc:SimplePanel>
						</hc:TabItem>

						<hc:TabItem Header="Zip Build" ToolTip="Let's you choose a location to save compiled Unreal Engine as a zip file for easy distribution among team.">
							<StackPanel Orientation="Horizontal">
								<Grid Margin="10" Width="540">
									<CheckBox x:Name="bZipBuild" Content="Zip final build." VerticalAlignment="Top" HorizontalAlignment="Left"/>
									<TextBox x:Name="ZipPath" VerticalAlignment="Top" HorizontalAlignment="Left" Margin="0,30,0,0" IsEnabled="{Binding IsChecked, ElementName=bZipBuild}" Width="458"/>
									<Button x:Name="SetZipPathLocation" Content="Browse" VerticalAlignment="Top" HorizontalAlignment="Left" Margin="463,30,0,0" ToolTip="Browse and select the folder where you want to move the zip file after Engine build." IsEnabled="{Binding IsChecked, ElementName=bZipBuild}" Click="SetZipPathLocation_Click" />
									<GroupBox Header="Contents to zip" VerticalAlignment="Top" HorizontalAlignment="Left" IsEnabled="{Binding IsChecked, ElementName=bZipBuild}" Height="155" Margin="6,77,0,0">
										<Grid>
											<CheckBox x:Name="bIncludeCoreFiles" Content="Core" IsEnabled="False" IsChecked="True" VerticalAlignment="Top" HorizontalAlignment="Left" ToolTip="Required files. Cannot edit."/>
											<CheckBox x:Name="bIncludePDB" Content="Include PDB" VerticalAlignment="Top" HorizontalAlignment="Left" ToolTip="If true, include *.pdb in zip. This significantly increases zip size." Margin="0 25"/>
											<CheckBox x:Name="bIncludeDEBUG" Content="Include DEBUG" VerticalAlignment="Top" HorizontalAlignment="Left" ToolTip="If true, include *.debug files in zip. This significantly increases zip size." Margin="0,50,0,0"/>
											<CheckBox x:Name="bIncludeDocumentation" Content="Include Documentation" VerticalAlignment="Top" HorizontalAlignment="Left" ToolTip="If true, include documentation folder" Margin="0,75,0,0"/>
											<CheckBox x:Name="bIncludeExtras" Content="Include Extras" VerticalAlignment="Top" HorizontalAlignment="Left" ToolTip="If true, include extras folder." Margin="180,0,0,0" Width="119"/>
											<CheckBox x:Name="bIncludeSource" Content="Include Source" VerticalAlignment="Top" HorizontalAlignment="Left" ToolTip="If true, include source code. This significantly increases zip size." Margin="180,25,0,0" Width="119"/>
											<CheckBox x:Name="bIncludeFeaturePacks" Content="Include Feature Packs" VerticalAlignment="Top" HorizontalAlignment="Left" ToolTip="If true, include feature packs (e.g: First Person, Third Person, Vehicle etc.)." Margin="180,50,0,0" />
											<CheckBox x:Name="bIncludeSamples" Content="Include Samples" VerticalAlignment="Top" HorizontalAlignment="Left" ToolTip="If true, include samples (e.g: Starter content)." Margin="180,75,0,0" />
											<CheckBox x:Name="bIncludeTemplates" Content="Include Templates" VerticalAlignment="Top" HorizontalAlignment="Left" ToolTip="If true, include templates (e.g: First Person, Third Person, Vehicle etc.)." Margin="360,0,0,0" />
										</Grid>
									</GroupBox>
									<CheckBox x:Name="bFastCompression" Content="Enable Fast Compression" VerticalAlignment="Top" HorizontalAlignment="Left" Margin="0,250,0,0" IsEnabled="{Binding IsChecked, ElementName=bZipBuild}" ToolTip="If true, uses fast but least effect compression.&#xA;If false, uses Best Compression which greatly reduces size but also the slowest."/>
								</Grid>
								<Grid Margin="10" Width="700">
									<GroupBox Header="Zip Status" Margin="10">
										<Grid>
											<Label x:Name="ZipStatusLabel" Content="Idle"/>
											<StackPanel x:Name="ZipStausStackPanel" Orientation="Vertical" HorizontalAlignment="Stretch" VerticalAlignment="Top">
												<Label x:Name="CurrentFileSaving" Content="FileName" Margin="10" HorizontalAlignment="Left"/>
												<Label x:Name="FileSaveState" Content="State" Margin="10" HorizontalAlignment="Left" />
												<Label x:Name="TotalResult" Content="File Size" Margin="10" HorizontalAlignment="Left" />
												<ProgressBar x:Name="FileProgressbar" Style="{DynamicResource ProgressBarInfo}" HorizontalAlignment="Stretch" Value="20" IsIndeterminate="True" Margin="10"/>
												<ProgressBar x:Name="OverallProgressbar" Style="{DynamicResource ProgressBarInfoStripe}" HorizontalAlignment="Stretch" Value="50" IsIndeterminate="True" Margin="10"/>
												<Button x:Name="CancelZipping" HorizontalAlignment="Stretch" Height="30" Content="Cancel Zipping" Click="CancelZipping_Click" Margin="10"/>
												<Button x:Name="OpenBuildFolder" HorizontalAlignment="Stretch" Height="30" Content="Open Installed Engine Build Folder" Click="OpenBuildFolder_Click" Margin="10 0"/>
											</StackPanel>

										</Grid>
									</GroupBox>
								</Grid>
							</StackPanel>
						</hc:TabItem>

						<hc:TabItem Header="Compile" ToolTip="Various options to choose how you want to compile Unreal Engine.">
							<Grid x:Name="CompileMainGrid">
								<Grid.BindingGroup>
									<BindingGroup Name="EngineChanged"/>
								</Grid.BindingGroup>
								<hc:SimplePanel HorizontalAlignment="Left" VerticalAlignment="Top" Margin="10,10,0,0" Height="123" Width="480">
									<TextBox x:Name="CustomBuildXMLFile" Text="{Binding CustomBuildFile}" hc:InfoElement.Placeholder="(Optional) Choose custom build XML file." hc:InfoElement.Necessary="True" Style="{StaticResource TextBoxExtend}" HorizontalAlignment="Left" VerticalAlignment="Top" Width="270" Margin="0,40,0,0"/>
									<Button x:Name="CustomBuildXMLBrowse" Content="Browse" HorizontalAlignment="Right" VerticalAlignment="Top" Margin="0,40,118,0" Width="80" Click="CustomBuildXMLBrowse_Click" />
									<Button x:Name="ResetDefaultBuildXML" Content="Reset To Default" HorizontalAlignment="Right" VerticalAlignment="Top" Margin="0,40,0,0" Width="113" Click="ResetDefaultBuildXML_Click" />
								</hc:SimplePanel>

								<GroupBox Header="Platforms" HorizontalAlignment="Left" VerticalAlignment="Top" Margin="10,138,0,0" Height="190" Width="480">
									<hc:ScrollViewer>
										<WrapPanel Orientation="Horizontal">
											<CheckBox x:Name="bHostPlatformOnly" Content="Host Only" Margin="10" IsChecked="{Binding bHostPlatformOnly}" />
											<CheckBox x:Name="bHostPlatformEditorOnly" Content="Host Editor Only" Margin="10" IsChecked="{Binding bHostPlatformEditorOnly}" />
											<CheckBox x:Name="bWithWin64" Content="Windows 64" Margin="10" IsChecked="{Binding bWithWin64}" />
											<CheckBox x:Name="bWithWin32" Content="Windows 32" Margin="10" IsChecked="{Binding bWithWin32}" IsEnabled="{Binding SupportWin32, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}"/>
											<CheckBox x:Name="bWithMac" Content="Mac" Margin="10" IsChecked="{Binding bWithMac}" />
											<CheckBox x:Name="bWithLinux" Content="Linux" Margin="10" IsChecked="{Binding bWithLinux}" />
											<CheckBox x:Name="bWithLinuxAArch64" Content="Linux 64" Margin="10" IsChecked="{Binding bWithLinuxAArch64}" IsEnabled="{Binding SupportLinuxAArch64, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}"/>
											<CheckBox x:Name="bWithAndroid" Content="Android" Margin="10" IsChecked="{Binding bWithAndroid}" />
											<CheckBox x:Name="bWithIOS" Content="IOS" Margin="10" IsChecked="{Binding bWithIOS}" />
											<CheckBox x:Name="bWithHTML5" Content="HTML 5" Margin="10" IsChecked="{Binding bWithHTML5}" IsEnabled="{Binding SupportHTML5, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}" />
											<CheckBox x:Name="bWithTVOS" Content="TVOS" Margin="10" IsChecked="{Binding bWithTVOS}" />
											<CheckBox x:Name="bWithSwitch" Content="Switch" Margin="10" IsChecked="{Binding bWithSwitch}" IsEnabled="{Binding SupportConsoles, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}"/>
											<CheckBox x:Name="bWithPS4" Content="PS4" Margin="10" IsChecked="{Binding bWithPS4}" IsEnabled="{Binding SupportConsoles, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}"/>
											<CheckBox x:Name="bWithXboxOne" Content="XBox One" Margin="10" IsChecked="{Binding bWithXboxOne}" IsEnabled="{Binding SupportConsoles, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}"/>
											<CheckBox x:Name="bWithLumin" Content="Lumin" Margin="10" IsChecked="{Binding bWithLumin}" />
											<CheckBox x:Name="bWithHololens" Content="Holo Lens" Margin="10" IsChecked="{Binding bWithHoloLens}" IsEnabled="{Binding SupportServerClientTargets, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}"/>
										</WrapPanel>
									</hc:ScrollViewer>
								</GroupBox>

								<GroupBox Header="Options" VerticalAlignment="Top" Height="318" Width="480" Margin="506,10,290,0">
									<hc:ScrollViewer>
										<StackPanel>
											<WrapPanel x:Name="EngineBuildOptionsWrapPanel">
												<CheckBox x:Name="bWithDDC" Content="Include DDC" Margin="10" IsChecked="{Binding bWithDDC}" ToolTip="Build a standalone derived-data cache for the engine content and templates.                         &#xA;Building a stand-alone Derived Data Cache (DDC) for the Engine and Template content can be one of the slowest aspects of the build.                         &#xA;If you don't need a stand-alone DDC, you can skip this step."/>
												<CheckBox x:Name="bHostPlatformDDCOnly" Content="Host DDC Only" Margin="10" IsChecked="{Binding bHostPlatformDDCOnly}" IsEnabled="{Binding IsChecked, ElementName=bWithDDC}" ToolTip="Whether to include DDC for the host platform only. Requires DDC to be turned on." />
												<CheckBox x:Name="bSignExecutables" Content="Sign Executables" Margin="10" IsChecked="{Binding bSignExecutables}" ToolTip="Sign the executables produced where signing is available." />
												<CheckBox x:Name="bEnableSymStore" Content="Symbol Store" Margin="10" IsChecked="{Binding bEnableSymStore}" ToolTip="Whether to add Source indexing to Windows game apps so they can be added to a symbol server." />
												<CheckBox x:Name="bWithFullDebugInfo" Content="Include Full Debug Info" Margin="10" IsChecked="{Binding bWithFullDebugInfo}" ToolTip="Generate full debug info for binary editor and packaged application builds." />
												<CheckBox x:Name="bCleanBuild" Content="Remove Previous" Margin="10" IsChecked="{Binding bCleanBuild}" ToolTip="Cleans any previous builds. Appends -clean to command line." />
												<CheckBox x:Name="bWithServer" Content="Include Server" Margin="10" IsChecked="{Binding bWithServer}" ToolTip="Create dedicated server target." IsEnabled="{Binding SupportServerClientTargets, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}"/>
												<CheckBox x:Name="bWithClient" Content="Include Client" Margin="10" IsChecked="{Binding bWithClient}" ToolTip="Create client target." IsEnabled="{Binding SupportServerClientTargets, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}"/>
												<CheckBox x:Name="bCompileDatasmithPlugins" Content="Include Datasmith" Margin="10" IsChecked="{Binding bCompileDatasmithPlugins}" ToolTip="If Datasmith plugins should be compiled." IsEnabled="{Binding IsEngineSelection425OrAbove, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}"/>
												<CheckBox x:Name="bVS2019" Content="Use 2019 Compiler" Margin="10" IsChecked="{Binding bVS2019}" ToolTip="Use Visual Studio 2019 to build Windows targets. By default, Visual Studio 2017 is used for maximum compatibility." IsEnabled="{Binding SupportVisualStudio2019, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}"/>
											</WrapPanel>
											<GroupBox Header="Shutdown Settings" Style="{StaticResource GroupBoxOriginal}" Margin="10">
												<WrapPanel>
													<CheckBox x:Name="bShutdownWindows" Content="Shutdown Computer after build" Margin="10" IsChecked="{Binding bShutdownPC}" ToolTip="Shuts down your computer after building." />
													<CheckBox x:Name="bShutdownIfSuccess" Content="Shutdown only if build is successful" Margin="10" IsChecked="{Binding bShutdownIfBuildSuccess}" ToolTip="Shuts down your computer after building only if the build is successful." IsEnabled="{Binding IsChecked, ElementName=bShutdownWindows}" />
												</WrapPanel>
											</GroupBox>
										</StackPanel>
									</hc:ScrollViewer>
								</GroupBox>

								<StackPanel VerticalAlignment="Bottom" HorizontalAlignment="Stretch">
									<WrapPanel>
										<TextBox x:Name="GameConfigurations" Margin="12 5 12 5" Width="400" Text="{Binding GameConfigurations}" hc:InfoElement.Placeholder="Game Configurations. E.g: Debug;Development;Shipping" Style="{StaticResource TextBoxExtend}" ToolTip="Which game configurations to include for packaged applications. Defaults to Development;Shipping"/>
										<TextBox x:Name="CustomOptions" Margin="12 5 12 5" Width="400" Text="{Binding CustomOptions}" hc:InfoElement.Placeholder="Custom Options (if any)" Style="{StaticResource TextBoxExtend}" ToolTip="Pass custom command line options. Typically used when using custom Build XML."/>
										<TextBox x:Name="AnalyticsOverride" Margin="12 5 12 5" Width="400" Text="{Binding AnalyticsOverride}" hc:InfoElement.Placeholder="Analytics Type" Style="{StaticResource TextBoxExtend}" ToolTip="Identifier for analytic events to send."/>
									</WrapPanel>
									<Label x:Name="FoundEngineLabel" Content="No Engine selected." HorizontalAlignment="Left" Margin="12 0 0 0"/>
								</StackPanel>
								<Button x:Name="BuildRocketUE" Content="Build Unreal Engine" HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="0,0,19,0" Width="200" Click="BuildRocketUE_Click" IsEnabled="{Binding AutomationExePathPathIsValid, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}"/>
								<Button x:Name="CopyCommandLine" Content="Copy Commandline to clipboard" HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="0,0,19,85" Width="200" Click="CopyCommandLine_Click" />
								<Button x:Name="EditServerTargetCs" Content="Edit - Server Target" HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="0 0 19 120" Width="200" Click="EditServerTargetCs_Click" IsEnabled="{Binding AutomationExePathPathIsValid, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}" />
								<Button x:Name="EditGameTargetCs" Content="Edit - Game Target" HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="0 0 19 155" Width="200" IsEnabled="{Binding AutomationExePathPathIsValid, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}" Click="EditGameTargetCs_Click" />
								<Button x:Name="EditEditorTargetCs" Content="Edit - Editor Target" HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="0 0 19 190" Width="200" IsEnabled="{Binding AutomationExePathPathIsValid, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}" Click="EditEditorTargetCs_Click" />
								<Button x:Name="EditClientTargetCs" Content="Edit - Client Target" HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="0 0 19 225" Width="200" IsEnabled="{Binding AutomationExePathPathIsValid, BindingGroupName=EngineChanged, Mode=OneWay, RelativeSource={RelativeSource FindAncestor, AncestorType={x:Type local1:MainWindow}}}" Click="EditClientTargetCs_Click" />
							</Grid>
						</hc:TabItem>
					</hc:TabControl>
				</hc:TabItem>
				<hc:TabItem x:Name="PluginsTab" Header="Plugins">
					<Grid>
						<StackPanel Orientation="Horizontal" HorizontalAlignment="Left" VerticalAlignment="Top" Margin ="10">
							<TextBlock Text="Engine Version " VerticalAlignment="Center"/>
							<hc:ComboBox x:Name="PluginEngineVersionSelection" Width="100" Margin="12 5 12 5" SelectionChanged="PluginEngineVersionSelection_SelectionChanged"/>
						</StackPanel>
						<GroupBox Style="{StaticResource GroupBoxOriginal}" Margin="0 40 0 0">
							<Grid>
								<st:StackPanel MarginBetweenChildren="8" Margin="10">
									<st:StackPanel Orientation="Horizontal" HorizontalAlignment="Left" VerticalAlignment="Top" Width="400">
										<TextBlock Text="Plugin path    " VerticalAlignment="Center"/>
										<hc:TextBox x:Name="PluginPath" hc:InfoElement.Placeholder="Select your .uplugin file" Margin="5" ToolTip="Navigate to your uplugin file." st:StackPanel.Fill="Fill"/>
										<Button x:Name="PluginPathBrowse" Content="Browse" VerticalAlignment="Center" Click="PluginPathBrowse_Click" />
									</st:StackPanel>

									<st:StackPanel Orientation="Horizontal" HorizontalAlignment="Left" VerticalAlignment="Top" Width="400">
										<TextBlock Text="Save Location" VerticalAlignment="Center"/>
										<hc:TextBox x:Name="PluginDestinationPath" hc:InfoElement.Placeholder="Packaged plugin destination" Margin="5" ToolTip="Navigate to your uplugin file." st:StackPanel.Fill="Fill"/>
										<Button x:Name="PluginDestinationPathBrowse" Content="Browse" VerticalAlignment="Center" Click="PluginDestinationPathBrowse_Click" />
									</st:StackPanel>

									<Grid>
										<GroupBox Style="{StaticResource GroupBoxOriginal}" IsEnabled="{Binding IsChecked, ElementName=bPluginOverrideTargetPlatforms}" HorizontalAlignment="Left" MaxWidth="400" Margin="0 25 0 0">
											<WrapPanel x:Name="PluginPlatforms" Orientation="Horizontal">
												<CheckBox x:Name="bPluginWin64" Content="Windows 64" Margin="10" IsEnabled="False" IsChecked="True" ToolTip="Win64 is always included and cannot be toggled"/>
												<CheckBox x:Name="bPluginWin32" Content="Windows 32" Margin="10"/>
												<CheckBox x:Name="bPluginMac" Content="Mac" Margin="10"/>
												<CheckBox x:Name="bPluginLinux" Content="Linux" Margin="10" />
												<CheckBox x:Name="bPluginLinuxAArch64" Content="Linux AArch 64" Margin="10"/>
												<CheckBox x:Name="bPluginAndroid" Content="Android" Margin="10"/>
												<CheckBox x:Name="bPluginIOS" Content="IOS" Margin="10"/>
												<CheckBox x:Name="bPluginHTML5" Content="HTML 5" Margin="10"/>
												<CheckBox x:Name="bPluginTVOS" Content="TVOS" Margin="10"/>
												<CheckBox x:Name="bPluginSwitch" Content="Switch" Margin="10"/>
												<CheckBox x:Name="bPluginPS4" Content="PS4" Margin="10"/>
												<CheckBox x:Name="bPluginXboxOne" Content="XBox One" Margin="10"/>
												<CheckBox x:Name="bPluginLumin" Content="Lumin" Margin="10"/>
												<CheckBox x:Name="bPluginHololens" Content="Holo Lens" Margin="10"/>
											</WrapPanel>
										</GroupBox>
										<CheckBox x:Name="bPluginOverrideTargetPlatforms" HorizontalAlignment="Left" Margin="10,15,0,0" VerticalAlignment="Top" Content="Override Target Platforms" />
									</Grid>

									<st:StackPanel Orientation="Horizontal" HorizontalAlignment="Left" VerticalAlignment="Top" Width="400">
										<CheckBox x:Name="bUse2019Compiler" Content="Use 2019 Compiler" HorizontalAlignment="Left" st:StackPanel.Fill="Fill"/>
										<Button x:Name="PluginQueueBtn" Content="Queue Build" Style="{StaticResource ButtonDashedPrimary}" HorizontalAlignment="Right" Click="PluginQueueBtn_Click"/>
									</st:StackPanel>

									<st:StackPanel Orientation="Vertical" HorizontalAlignment="Left" VerticalAlignment="Top" Width="400">
										<st:StackPanel Orientation="Horizontal" HorizontalAlignment="Left" VerticalAlignment="Top" MarginBetweenChildren="5" Width="400">
											<CheckBox x:Name="PluginZip" Content="Zip Plugin" HorizontalAlignment="Left"/>
											<hc:TextBox x:Name="PluginZipPath" hc:InfoElement.Placeholder="Plugin zip location" Margin="5" st:StackPanel.Fill="Fill" IsEnabled="{Binding IsChecked, ElementName=PluginZip}"/>
											<Button x:Name="PluginZipDestinationPathBrowse" Content="Browse" VerticalAlignment="Center" Click="PluginZipDestinationPathBrowse_Click" IsEnabled="{Binding IsChecked, ElementName=PluginZip}"/>
										</st:StackPanel>
										<CheckBox x:Name="PluginZipForMarketplace" Content="Zip for Marketplace" HorizontalAlignment="Left" IsChecked="True" IsEnabled="{Binding IsChecked, ElementName=PluginZip}" ToolTip="Zipping for Unreal Marketplace will ignore 'Binaries' and 'Intermediate' folders." />
									</st:StackPanel>

								</st:StackPanel>
								<ScrollViewer HorizontalAlignment="Right" Width="850" Margin="0,-40,0,50" HorizontalScrollBarVisibility="Visible" VerticalScrollBarVisibility="Visible" CanContentScroll="True">
									<WrapPanel x:Name="PluginQueues" Orientation="Horizontal" Width="850"/>
								</ScrollViewer>
								<Button x:Name="StartPluginBuildsBtn" Content="Start Build" Style="{StaticResource ButtonPrimary}" HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="10" Width="150" Click="StartPluginBuildsBtn_Click"/>
							</Grid>
						</GroupBox>
					</Grid>
				</hc:TabItem>

				<hc:TabItem Header="Project">
					<Grid>
						<TextBlock Text="Not yet done. Will be available in a later version." HorizontalAlignment="Center" VerticalAlignment="Center"/>
					</Grid>
				</hc:TabItem>
			</hc:TabControl>

			<DockPanel LastChildFill="True" HorizontalAlignment="Stretch" VerticalAlignment="Stretch" Height="Auto" DockPanel.Dock="Bottom" Background="#FF2D2D30">
				<st:StackPanel Orientation="Horizontal"  DockPanel.Dock="Bottom" HorizontalAlignment="Stretch">
					<hc:SimpleText x:Name="StepLabel" Text="Step: " Margin="5" Foreground="#FFE6E0E0"/>
					<hc:SimpleText x:Name="StatusLabel" Text="Status: " Margin="5" Foreground="#FFE6E0E0"/>
					<hc:SimpleText x:Name="ProcessedFilesLabel" Text="Compiled: 0" Margin="5" Foreground="#FFE6E0E0" st:StackPanel.Fill="Fill"/>
					<Button x:Name="CheckUpdateBtn" Content="Check for Updates" Height="20" Padding="10,0,10,0" FontSize="10" Width="120" Click="CheckUpdateBtn_Click" />
					<Button x:Name="OpenSettingsBtn" Content="Open Settings" Height="20" Padding="10,0,10,0" FontSize="10" IsEnabled="False" Width="120" Click="OpenSettingsBtn_Click"/>
					<Button x:Name="OpenLogFolderBtn" Content="Open Log Folder" Margin="0 0 10 0" Height="20" Padding="10,0,10,0" FontSize="10" IsEnabled="False" Width="120" Click="OpenLogFolderBtn_Click"/>
				</st:StackPanel>
				<local:LogViewer x:Name="LogControl" DockPanel.Dock="Top" Height="Auto" ScrollViewer.VerticalScrollBarVisibility="Disabled"/>
			</DockPanel>
		</DockPanel>

		<ScrollViewer VerticalScrollBarVisibility="Hidden" HorizontalAlignment="Right" VerticalAlignment="Bottom">
			<StackPanel>
				<StackPanel hc:Growl.GrowlParent="True" VerticalAlignment="Top"/>
				<StackPanel hc:Growl.Token="PluginBuild" VerticalAlignment="Top"/>
				<StackPanel hc:Growl.Token="Important" VerticalAlignment="Top"/>
			</StackPanel>
		</ScrollViewer>
	</Grid>
</hc:GlowWindow>

```

`UnrealBinaryBuilder/MainWindow.xaml.cs`:

```cs

using HandyControl.Controls;
using HandyControl.Data;
using HandyControl.Themes;
using HandyControl.Tools;
using Microsoft.Win32;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Threading;
using UnrealBinaryBuilder.Classes;
using UnrealBinaryBuilder.UserControls;
using UnrealBinaryBuilderUpdater;
using System.Windows.Data;

namespace UnrealBinaryBuilder
{
	public static class UnrealBinaryBuilderHelpers
	{
		public static readonly string SetupBatFileName = "Setup.bat";
		public static readonly string GenerateProjectBatFileName = "GenerateProjectFiles.bat";
		public static readonly string AUTOMATION_TOOL_NAME = "AutomationTool";
		public static readonly string AUTOMATION_TOOL_LAUNCHER_NAME = $"{AUTOMATION_TOOL_NAME}Launcher";
		public static readonly string DEFAULT_BUILD_XML_FILE = "Engine/Build/InstalledEngineBuild.xml";
		public static bool IsUnrealEngine5 { get; private set; } = false;

		private static string EngineVersionMajor, EngineVersionMinor, EngineVersionPatch = null;
		public static string GetProductVersionString()
		{
			Version ProductVersion = Assembly.GetEntryAssembly().GetName().Version;
			string ReturnValue = $"{ProductVersion.Major}.{ProductVersion.Minor}";

			if (ProductVersion.Build > 0)
			{
				ReturnValue += $".{ProductVersion.Build}";
			}

			if (ProductVersion.Revision > 0)
			{
				ReturnValue += $".{ProductVersion.Revision}";
			}

			return ReturnValue;
		}

		public static string GetMsBuildPath()
		{
			string ProgramFilesx86Path = Environment.GetEnvironmentVariable("ProgramFiles(x86)");
			return Path.Combine(ProgramFilesx86Path, "Microsoft Visual Studio", "2019", "Community", "MSBuild", "Current", "Bin", "MSBuild.exe");
		}

		public static string GetEngineVersion(string BaseEnginePath)
		{
			string VersionFile = Path.Combine(BaseEnginePath, "Engine", "Source", "Runtime", "Launch", "Resources", "Version.h");
			string Local_EngineVersionMajor = null;
			string Local_EngineVersionMinor = null;
			string Local_EngineVersionPatch = null;
			if (File.Exists(VersionFile))
			{
				using (StreamReader file = new StreamReader(VersionFile))
				{
					string CurrentLine;
					while ((CurrentLine = file.ReadLine()) != null)
					{
						if (CurrentLine.StartsWith("#define ENGINE_MAJOR_VERSION"))
						{
							Local_EngineVersionMajor = CurrentLine.Replace("#define ENGINE_MAJOR_VERSION", "").Replace("\t", "");
						}
						else if (CurrentLine.StartsWith("#define ENGINE_MINOR_VERSION"))
						{
							Local_EngineVersionMinor = CurrentLine.Replace("#define ENGINE_MINOR_VERSION", "").Replace("\t", "");
						}
						else if (CurrentLine.StartsWith("#define ENGINE_PATCH_VERSION"))
						{
							Local_EngineVersionPatch = CurrentLine.Replace("#define ENGINE_PATCH_VERSION", "").Replace("\t", "");
							break;
						}
					}
				}

				return $"{Local_EngineVersionMajor}.{Local_EngineVersionMinor}.{Local_EngineVersionPatch}";
			}

			return null;
		}

		public static string DetectEngineVersion(string BaseEnginePath, bool bForceDetect = false)
		{
			if (string.IsNullOrWhiteSpace(BaseEnginePath))
			{
				return null;
			}

			if (EngineVersionMajor == null || bForceDetect)
			{
				string MyEngineVersion = GetEngineVersion(BaseEnginePath);
				if (MyEngineVersion != null)
				{
					string[] SplitString = MyEngineVersion.Split(".");
					EngineVersionMajor = SplitString[0];
					EngineVersionMinor = SplitString[1];
					EngineVersionPatch = SplitString[2];
					IsUnrealEngine5 = EngineVersionMajor.StartsWith("5");
				}
				else
				{
					EngineVersionMajor = EngineVersionMinor = EngineVersionPatch = null;
					IsUnrealEngine5 = false;
					return null;
				}
			}

			return $"{EngineVersionMajor}.{EngineVersionMinor}.{EngineVersionPatch}";
		}

		public static bool AutomationToolExists(string BaseEnginePath)
		{
			if (string.IsNullOrWhiteSpace(BaseEnginePath))
			{
				if (IsUnrealEngine5)
				{
					return File.Exists(Path.Combine(BaseEnginePath, "Engine", "Binaries", "DotNET", AUTOMATION_TOOL_NAME, $"{AUTOMATION_TOOL_NAME}.exe"));
				}
				else
				{
					return File.Exists(Path.Combine(BaseEnginePath, "Engine", "Binaries", "DotNET", $"{AUTOMATION_TOOL_LAUNCHER_NAME}.exe"));
				}
			}

			return false;
		}

		public static string GetAutomationToolProjectFile(string BaseEnginePath)
		{
			if (string.IsNullOrWhiteSpace(BaseEnginePath))
			{
				return null;
			}

			return Path.Combine(BaseEnginePath, "Engine", "Source", "Programs", AUTOMATION_TOOL_NAME, $"{AUTOMATION_TOOL_NAME}.csproj");
		}

		public static string GetAutomationToolLauncherProjectFile(string BaseEnginePath)
		{
			if (string.IsNullOrWhiteSpace(BaseEnginePath))
			{
				return null;
			}

			return Path.Combine(BaseEnginePath, "Engine", "Source", "Programs", AUTOMATION_TOOL_LAUNCHER_NAME, $"{AUTOMATION_TOOL_LAUNCHER_NAME}.csproj");
		}
	}
	public partial class MainWindow
	{
		private Process CurrentProcess = null;

		private int NumErrors = 0;
		private int NumWarnings = 0;

		private int CompiledFiles = 0;
		private int CompiledFilesTotal = 0;

		private bool bIsBuilding = false;
		private bool bLastBuildSuccess = false;

		private string LogMessage = null;
		private string LogMessageErrors = null;
		private string FinalBuildPath = null;

		public string CurrentTheme = null;
		public PostBuildSettings postBuildSettings = null;

		private readonly Stopwatch StopwatchTimer = new Stopwatch();
		private readonly DispatcherTimer DispatchTimer = new DispatcherTimer();

		public BuilderSettingsJson SettingsJSON = null;

		private string AutomationExePath = null;

		private PluginCard CurrentPluginBeingBuilt = null;
		private List<string> PluginBuildEnginePath = new List<string>();
		private Dialog aboutDialog = null;
		private Dialog downloadDialog = null;
		private DownloadDialog downloadDialogWindow = null;
		private static UBBUpdater unrealBinaryBuilderUpdater = null;
		private bool bUpdateAvailable = false;

		public bool AutomationExePathPathIsValid => File.Exists(AutomationExePath);

		public enum ZipLogInclusionType
		{
			FileIncluded,
			FileSkipped,
			ExtensionSkipped
		}

		private enum CurrentProcessType
		{
			None,
			SetupBat,
			GenerateProjectFiles,
			BuildAutomationTool,
			BuildAutomationToolLauncher,
			BuildUnrealEngine,
			BuildPlugin
		}

		private CurrentProcessType currentProcessType = CurrentProcessType.None;

		public MainWindow()
		{
			InitializeComponent();
			GameAnalyticsCSharp.InitializeGameAnalytics(UnrealBinaryBuilderHelpers.GetProductVersionString(), this);
			AddLogEntry($"Welcome to Unreal Binary Builder v{UnrealBinaryBuilderHelpers.GetProductVersionString()}");
			PluginQueueBtn.IsEnabled = false;
			postBuildSettings = new PostBuildSettings(this);
			SettingsJSON = BuilderSettings.GetSettingsFile(true);
			BuilderSettings.LoadInitialValues();
			DataContext = SettingsJSON;
			bUse2019Compiler.IsEnabled = false;

			if (Plugins.GetInstalledEngines() == null)
			{
				PluginsTab.Visibility = Visibility.Collapsed;
				AddLogEntry("Could not find any installed Engine versions. Plugins tab is disabled.", true);
				ShowToastMessage("Could not find any installed Engine versions. Plugins tab is disabled.", LogViewer.EMessageType.Error);
			}
			else
			{
				foreach (EngineBuild engineBuild in Plugins.GetInstalledEngines())
				{
					string RunUATFile = Path.Combine(engineBuild.EnginePath, "Engine", "Build", "BatchFiles", "RunUAT.bat");
					if (File.Exists(RunUATFile))
					{
						PluginEngineVersionSelection.Items.Add(engineBuild.EngineName);
						PluginBuildEnginePath.Add(engineBuild.EnginePath);
					}
					else
					{
						AddLogEntry($"{engineBuild.EngineName} will not be available for Plugin build. RunUAT.bat does not exist in {Path.GetDirectoryName(RunUATFile)}.", true);
					}
				}
			}

			if (File.Exists(AutomationExePath) && Path.GetFileNameWithoutExtension(AutomationExePath) == UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_NAME)
			{
				BuildRocketUE.IsEnabled = true;
			}

			ChangeStatusLabel("Idle.");

			DispatchTimer.Tick += new EventHandler(DispatchTimer_Tick);
			DispatchTimer.Interval = new TimeSpan(0, 0, 1);

			CurrentTheme = SettingsJSON.Theme;
			if (CurrentTheme.ToLower() == "violet")
			{
				ShowToastMessage("Violet theme is not fully supported yet.", LogViewer.EMessageType.Warning, true, false, "Important", 4);
				UpdateSkin(SkinType.Violet);				
			}
			else if (CurrentTheme.ToLower() == "dark")
			{
				UpdateSkin(SkinType.Dark);
			}
			else
			{
				ShowToastMessage("Default theme is not fully supported yet.", LogViewer.EMessageType.Warning, true, false, "Important", 4);
				UpdateSkin(SkinType.Default);
			}
			ZipStatusLabel.Visibility = Visibility.Visible;
			ZipStausStackPanel.Visibility = Visibility.Collapsed;

			if (SettingsJSON.bCheckForUpdatesAtStartup)
			{
				CheckForUpdates();
			}
		}

		public static void OpenBrowser(string InURL)
		{
			InURL = InURL.Replace("&", "^&");
			Process.Start(new ProcessStartInfo("cmd", $"/c start {InURL}") { CreateNoWindow = true });
		}

		public void DownloadUpdate()
		{
			if (CurrentProcess == null)
			{
				if (bUpdateAvailable)
				{
					CheckUpdateBtn.IsEnabled = false;
					CheckUpdateBtn.Content = "Downloading...";
					unrealBinaryBuilderUpdater.UpdateDownloadStartedEventHandler += DownloadUpdateProgressStart;
					unrealBinaryBuilderUpdater.UpdateDownloadFinishedEventHandler += DownloadUpdateProgressFinish;
					unrealBinaryBuilderUpdater.UpdateProgressEventHandler += DownloadUpdateProgress;
					unrealBinaryBuilderUpdater.DownloadUpdate();
				}
			}
			else
			{
				CloseUpdateDialogWindow();
				ShowToastMessage($"{GetCurrentProcessName()} is currently running. You can check for updates after it is done.", LogViewer.EMessageType.Error);
			}
		}

		public void CloseUpdateDialogWindow()
		{
			if (downloadDialog != null)
			{
				downloadDialog.Close();
				downloadDialog = null;
				downloadDialogWindow = null;
			}
		}

		private void CheckForUpdates()
		{
			if (CurrentProcess == null)
			{
				CheckUpdateBtn.IsEnabled = false;
				CheckUpdateBtn.Content = "Checking...";
				if (unrealBinaryBuilderUpdater == null)
				{
					unrealBinaryBuilderUpdater = new UBBUpdater();
				}

				GameAnalyticsCSharp.AddDesignEvent("Update:Check");
				unrealBinaryBuilderUpdater.SilentUpdateFinishedEventHandler += OnUpdateCheck;
				unrealBinaryBuilderUpdater.CheckForUpdatesSilently();
			}
			else
			{
				ShowToastMessage($"{GetCurrentProcessName()} is currently running. You can check for updates after it is done.", LogViewer.EMessageType.Error);
			}
		}

		private void CheckUpdateBtn_Click(object sender, RoutedEventArgs e)
		{
			if (bUpdateAvailable)
			{
				DownloadUpdate();
			}
			else
			{
				CheckForUpdates();
			}
		}

		private void OnUpdateCheck(object sender, UpdateProgressFinishedEventArgs e)
		{
			CheckUpdateBtn.Content = "Check for Update";
			switch (e.appUpdateCheckStatus)
			{
				case AppUpdateCheckStatus.UpdateAvailable:
					bUpdateAvailable = true;
					CheckUpdateBtn.Content = $"Install Update {e.castItem.Version}";
					ShowToastMessage($"Update {e.castItem.Version} is available.", LogViewer.EMessageType.Info, true, false, "", 2);
					downloadDialogWindow = new DownloadDialog(this, e.castItem.Version);
					downloadDialog = Dialog.Show(downloadDialogWindow);
					break;
				case AppUpdateCheckStatus.NoUpdate:
					ShowToastMessage("You are running the latest version.", LogViewer.EMessageType.Info, true, false, "", 2);
					break;
				case AppUpdateCheckStatus.CouldNotDetermine:
					ShowToastMessage("Failed to determine update settings. Please try again later.", LogViewer.EMessageType.Error);
					break;
				case AppUpdateCheckStatus.UserSkip:
					break;
			}
			CheckUpdateBtn.IsEnabled = true;
		}

		private void DownloadUpdateProgressStart(object sender, UpdateProgressDownloadStartEventArgs e)
		{
			GameAnalyticsCSharp.AddDesignEvent($"Update:Download:{e.Version}");
			if (downloadDialogWindow == null)
			{
				downloadDialogWindow = new DownloadDialog(this, e.Version);
				downloadDialog = Dialog.Show(downloadDialogWindow);
			}
			downloadDialogWindow.Initialize(e.UpdateSize);
		}

		private void DownloadUpdateProgress(object sender, UpdateProgressDownloadEventArgs progressDownloadEventArgs)
		{
			downloadDialogWindow.SetProgress(progressDownloadEventArgs.AppUpdateProgress);
		}
		private void DownloadUpdateProgressFinish(object sender, UpdateProgressDownloadFinishEventArgs e)
		{
			string TargetDownloadDirectory = Path.Combine(BuilderSettings.PROGRAM_SAVED_PATH, "Updates", e.castItem.Version);
			if (Directory.Exists(TargetDownloadDirectory) == false)
			{
				Directory.CreateDirectory(TargetDownloadDirectory);
			}

			using (Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile(e.UpdateFilePath))
			{
				zip.ExtractProgress += (o, args) =>
				{
					if (args.EventType == Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractAll)
					{
						GameAnalyticsCSharp.AddDesignEvent($"Update:Install:{downloadDialogWindow.VersionText}");
						unrealBinaryBuilderUpdater.UpdateDownloadStartedEventHandler -= DownloadUpdateProgressStart;
						unrealBinaryBuilderUpdater.UpdateDownloadFinishedEventHandler -= DownloadUpdateProgressFinish;
						unrealBinaryBuilderUpdater.UpdateProgressEventHandler -= DownloadUpdateProgress;
						unrealBinaryBuilderUpdater.CloseApplicationEventHandler += CloseApplication;
						unrealBinaryBuilderUpdater.InstallUpdate();
						Process.Start("explorer.exe", TargetDownloadDirectory);
					}
				};
				zip.ExtractAll(TargetDownloadDirectory, Ionic.Zip.ExtractExistingFileAction.OverwriteSilently);
			}
		}

		private void CloseApplication(object sender, EventArgs e)
		{
			downloadDialog.Close();
			Close();
		}

		public void ShowToastMessage(string Message, LogViewer.EMessageType ToastType = LogViewer.EMessageType.Info, bool bShowCloseButton = true, bool bStaysOpen = false, string Token = "", int WaitTime = 3)
		{
			Growl.Clear(Token);
			GrowlInfo growlInfo = new GrowlInfo()
			{
				ShowDateTime = false,
				ShowCloseButton = bShowCloseButton,
				StaysOpen = bStaysOpen,
				Token = Token,
				WaitTime = WaitTime
			};

			growlInfo.Message = Message;
			switch (ToastType)
			{
				case LogViewer.EMessageType.Info:
					Growl.Info(growlInfo);
					break;
				case LogViewer.EMessageType.Warning:
					Growl.Warning(growlInfo);
					break;
				case LogViewer.EMessageType.Error:
					Growl.Error(growlInfo);
					break;
			}
		}

		private void ChangeStatusLabel(string InStatus)
		{
			StatusLabel.Text = GetCurrentProcessName() != null ? $"Status: Running [{GetCurrentProcessName()} - {InStatus}]" : $"Status: {InStatus}";
		}

		private void ChangeStepLabel(string current, string total)
		{
			Dispatcher.Invoke(() => { StepLabel.Text = $"Step: [{current}/{total}] "; });
		}

		private string GetConditionalString(bool? bCondition)
		{
			return (bool)bCondition ? "true" : "false";
		}

		private void DispatchTimer_Tick(object sender, EventArgs e)
		{
			ChangeStatusLabel(string.Format("Building... Time Elapsed: {0:hh\\:mm\\:ss}", StopwatchTimer.Elapsed));
		}

		public void AddZipLog(string InMessage, ZipLogInclusionType InType)
		{
			LogEntry logEntry = new LogEntry();
			logEntry.Message = InMessage;
			LogControl.AddZipLog(logEntry, InType);
		}

		public void AddLogEntry(string InMessage, bool bIsError = false)
		{
			if (InMessage != null)
			{
				LogEntry logEntry = new LogEntry();
				logEntry.Message = InMessage;

				LogViewer.EMessageType InMessageType = bIsError ? LogViewer.EMessageType.Error : LogViewer.EMessageType.Info;

				if (bIsError == false)
				{
					const string StepPattern = @"\*{6} \[(\d+)\/(\d+)\]";
					const string WarningPattern = @"warning|\*\*\* Unable to determine ";
					const string DebugPattern = @".+\*\s\D\d\D\d\D\s\w+|.+\*\sFor\sUE4";
					const string ErrorPattern = @"Error_Unknown|ERROR|exited with code 1";
					const string ProcessedFilesPattern = @"\w.+\.(cpp|cc|c|h|ispc)";

					Regex StepRgx = new Regex(StepPattern, RegexOptions.IgnoreCase);
					Regex WarningRgx = new Regex(WarningPattern, RegexOptions.IgnoreCase);
					Regex DebugRgx = new Regex(DebugPattern, RegexOptions.IgnoreCase);
					Regex ErrorRgx = new Regex(ErrorPattern, RegexOptions.IgnoreCase);
					Regex ProcessedFilesRgx = new Regex(ProcessedFilesPattern, RegexOptions.IgnoreCase);

					if (StepRgx.IsMatch(InMessage))
					{
						GroupCollection captures = StepRgx.Match(InMessage).Groups;
						ChangeStepLabel(captures[1].Value, captures[2].Value);
						CompiledFiles = 0;
					}

					if (ProcessedFilesRgx.IsMatch(InMessage))
					{
						CompiledFiles++;
						CompiledFilesTotal++;
						Dispatcher.Invoke(() => 
						{ 
							ProcessedFilesLabel.Text = $"[Compiled: {CompiledFiles}. Total: {CompiledFilesTotal}]"; 
						});
					}

					if (WarningRgx.IsMatch(InMessage))
					{
						NumWarnings++;
						InMessageType = LogViewer.EMessageType.Warning;
					}
					else if (ErrorRgx.IsMatch(InMessage) && InMessage.Contains("ShadowError") == false && InMessage.Contains("error_details.") == false && InMessage.Contains("error_code.") == false)
					{
						NumErrors++;
						InMessageType = LogViewer.EMessageType.Error;
						LogMessageErrors += InMessage + "\r\n";
					}
					else if (DebugRgx.IsMatch(InMessage))
					{
						InMessageType = LogViewer.EMessageType.Debug;
					}
				}

				LogControl.AddLogEntry(logEntry, InMessageType);
				LogMessage += InMessage + "\r\n";
			}
		}

		private void Internal_ShutdownWindows()
		{
			Process.Start("shutdown", "/s /t 5");
			Application.Current.Shutdown();
		}

		private void SaveAllSettings()
		{
			BuilderSettings.SaveSettings();
		}

		private void UnrealBinaryBuilderWindow_Closing(object sender, System.ComponentModel.CancelEventArgs e)
		{
			if (bIsBuilding)
			{
				if (HandyControl.Controls.MessageBox.Show($"{GetCurrentProcessName()} is still running. Would you like to stop it and exit?", "Build in progress", MessageBoxButton.YesNo, MessageBoxImage.Question) == MessageBoxResult.Yes)
				{
					GameAnalyticsCSharp.AddDesignEvent($"Build:{GetCurrentProcessName()}:Killed:ExitProgram");
					CloseCurrentProcess(true);
				}
				else
				{
					e.Cancel = true;
					return;
				}
			}

			GameAnalyticsCSharp.EndSession();
			SaveAllSettings();

			Application.Current.Shutdown();
		}

		private void CurrentProcess_OutputDataReceived(object sender, DataReceivedEventArgs e)
		{
			AddLogEntry(e.Data);
		}

		private void CurrentProcess_ErrorDataReceived(object sender, DataReceivedEventArgs e)
		{
			NumErrors++;
			AddLogEntry(e.Data, true);
		}

		private void CurrentProcess_Exited(object sender, EventArgs e)
		{
			DispatchTimer.Stop();
			StopwatchTimer.Stop();
			bLastBuildSuccess = CurrentProcess.ExitCode == 0;
			AddLogEntry(string.Format($"{GetCurrentProcessName()} exited with code {0}\n", CurrentProcess.ExitCode.ToString()));

			Dispatcher.Invoke(() =>
			{
				BuildRocketUE.Content = "Build Unreal Engine";
				ChangeStatusLabel(string.Format("Build finished with code {0}. {1} errors, {2} warnings. Time elapsed: {3:hh\\:mm\\:ss}", CurrentProcess.ExitCode, NumErrors, NumWarnings, StopwatchTimer.Elapsed));
			});

			CloseCurrentProcess();

			NumErrors = 0;
			NumWarnings = 0;
			AddLogEntry("========================== BUILD FINISHED ==========================");
			AddLogEntry(string.Format("Compiled approximately {0} files.", CompiledFilesTotal));
			AddLogEntry(string.Format("Took {0:hh\\:mm\\:ss}", StopwatchTimer.Elapsed));
			AddLogEntry(string.Format("Build ended at {0}", DateTime.Now.ToString("dddd, dd MMMM yyyy HH:mm:ss")));
			StopwatchTimer.Reset();
			Dispatcher.Invoke(() =>
			{
				StartSetupBatFile.IsEnabled = true;
				StartPluginBuildsBtn.IsEnabled = true;
				OnBuildFinished(bLastBuildSuccess);
			});
		}

		private void OnBuildFinished(bool bBuildSucess)
		{
			ZipStatusLabel.Content = "Idle";
			bIsBuilding = false;
			if (bBuildSucess)
			{
				switch (currentProcessType)
				{
					case CurrentProcessType.BuildUnrealEngine:
						if (postBuildSettings.CanSaveToZip())
						{
							EngineTabControl.SelectedIndex = 1;
							if (FinalBuildPath == null)
							{
								if (UnrealBinaryBuilderHelpers.IsUnrealEngine5)
								{
									FinalBuildPath = Path.GetFullPath(AutomationExePath).Replace(@$"\Engine\Binaries\DotNET\{UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_NAME}", @"\LocalBuilds\Engine").Replace(Path.GetFileName(AutomationExePath), "");
								}
								else
								{
									FinalBuildPath = Path.GetFullPath(AutomationExePath).Replace(@"\Engine\Binaries\DotNET", @"\LocalBuilds\Engine").Replace(Path.GetFileName(AutomationExePath), "");
								}
								GameAnalyticsCSharp.LogEvent("Final Build Path was null. Fixed.", GameAnalyticsSDK.Net.EGAErrorSeverity.Info);
							}
							AddLogEntry($"Creating ZIP file. Installed build can be found in {FinalBuildPath}");
							postBuildSettings.PrepareToSave();
							postBuildSettings.SaveToZip(FinalBuildPath, ZipPath.Text);
							AddLogEntry($"Saving zip file to {ZipPath.Text}");
							WriteToLogFile();
							return;
						}
						break;
					case CurrentProcessType.SetupBat:
						GameAnalyticsCSharp.AddProgressEnd("Build", "Setup");
						GenerateProjectFiles();
						break;
					case CurrentProcessType.GenerateProjectFiles:
						GameAnalyticsCSharp.AddProgressEnd("Build", "ProjectFiles");
						BuildAutomationTool();
						break;
					case CurrentProcessType.BuildAutomationTool:
						GameAnalyticsCSharp.AddProgressEnd("Build", UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_NAME);
						BuildAutomationToolLauncher();
						break;
					case CurrentProcessType.BuildAutomationToolLauncher:
						GameAnalyticsCSharp.AddProgressEnd("Build", UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_LAUNCHER_NAME);
						if (bContinueToEngineBuild.IsChecked == true)
						{
							BuildEngine();
						}
						break;
				}
			}

			if (currentProcessType == CurrentProcessType.BuildPlugin)
			{
				GameAnalyticsCSharp.AddProgressEnd("Build", "Plugin");
				CurrentPluginBeingBuilt.PluginFinishedBuild(bBuildSucess);
				CurrentPluginBeingBuilt = null;
				foreach (var C in PluginQueues.Children)
				{
					PluginCard pluginCard = (PluginCard)C;
					if (pluginCard.IsPending())
					{
						BuildPlugin(pluginCard);
						break;
					}
				}

				if (CurrentPluginBeingBuilt == null)
				{
					Growl.Clear("PluginBuild");
					ShowToastMessage($"Finished plugin queue build with {PluginQueues.Children.Count} plugin(s)");
				}
			}

			WriteToLogFile();
			TryShutdown();
			LogMessageErrors = null;
		}

		public void TryShutdown()
		{
			if (currentProcessType == CurrentProcessType.BuildUnrealEngine)
			{
				if (bShutdownWindows.IsChecked == true)
				{
					if (bShutdownIfSuccess.IsChecked == true)
					{
						if (bLastBuildSuccess)
						{
							GameAnalyticsCSharp.AddDesignEvent("Shutdown:BuildState:Success");
							Internal_ShutdownWindows();
						}
						else
						{
							GameAnalyticsCSharp.AddDesignEvent("Shutdown:BuildState:Failed");
						}
					}
					else
					{
						GameAnalyticsCSharp.AddDesignEvent("Shutdown:Started");
						Internal_ShutdownWindows();
					}
				}
			}
		}

		private void BrowseEngineFolder_Click(object sender, RoutedEventArgs e)
		{
			System.Windows.Forms.FolderBrowserDialog NewFolderDialog = new System.Windows.Forms.FolderBrowserDialog();
			NewFolderDialog.ShowDialog();
			SetupBatFilePath.Text = NewFolderDialog.SelectedPath;
			if (TryUpdateAutomationExePath() == false)
			{
				HandyControl.Controls.MessageBox.Error($"This is not the Unreal Engine root folder.\n\nPlease select the root folder where {UnrealBinaryBuilderHelpers.SetupBatFileName} and {UnrealBinaryBuilderHelpers.GenerateProjectBatFileName} exists.", "Incorrect folder");
			}
		}

		private bool TryUpdateAutomationExePath()
		{
			bool bRequiredFilesExist = File.Exists(Path.Combine(SetupBatFilePath.Text, UnrealBinaryBuilderHelpers.SetupBatFileName)) && File.Exists(Path.Combine(SetupBatFilePath.Text, UnrealBinaryBuilderHelpers.GenerateProjectBatFileName));
			StartSetupBatFile.IsEnabled = bRequiredFilesExist;
			if (bRequiredFilesExist && string.IsNullOrEmpty(AutomationExePath))
			{
				if (UnrealBinaryBuilderHelpers.IsUnrealEngine5)
				{
					AutomationExePath = Path.Combine(SetupBatFilePath.Text, "Engine", "Binaries", "DotNET", UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_NAME, $"{UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_NAME}.exe");
				}
				else
				{
					AutomationExePath = Path.Combine(SetupBatFilePath.Text, "Engine", "Binaries", "DotNET", $"{UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_LAUNCHER_NAME}.exe");
				}
			}

			return bRequiredFilesExist;
		}

		private string SetupBatCommandLineArgs()
		{
			string CommandLines = "--force";

			if (SettingsJSON.GitDependencyAll == true)
			{
				CommandLines += " --all";
			}

			foreach (GitPlatform gp in SettingsJSON.GitDependencyPlatforms)
			{
				if (gp.bIsIncluded == false)
				{
					CommandLines += $" --exclude={gp.Name}";
				}
			}

			CommandLines += $" --threads={SettingsJSON.GitDependencyThreads}";
			CommandLines += $" --max-retries={SettingsJSON.GitDependencyMaxRetries}";
			
			if (SettingsJSON.GitDependencyEnableCache == false)
			{
				CommandLines += " --no-cache";
			}
			else if (string.IsNullOrEmpty(SettingsJSON.GitDependencyCache) == false)
			{
				CommandLines += $" --cache={SettingsJSON.GitDependencyCache.Replace("\\", "/")}";
				CommandLines += $" --cache-size-multiplier={SettingsJSON.GitDependencyCacheMultiplier}";
				CommandLines += $" --cache-days={SettingsJSON.GitDependencyCacheDays}";
			}

			if (string.IsNullOrEmpty(SettingsJSON.GitDependencyProxy) == false)
			{
				CommandLines += $" --proxy={SettingsJSON.GitDependencyProxy}";
			}


			return CommandLines;
		}

		private void StartSetupBatFile_Click(object sender, System.Windows.RoutedEventArgs e)
		{
			bool bRequiredFilesExist = File.Exists(Path.Combine(SetupBatFilePath.Text, UnrealBinaryBuilderHelpers.SetupBatFileName)) && File.Exists(Path.Combine(SetupBatFilePath.Text, UnrealBinaryBuilderHelpers.GenerateProjectBatFileName));
			if (bRequiredFilesExist == false)
			{
				HandyControl.Controls.MessageBox.Error($"This is not the Unreal Engine root folder.\n\nPlease select the root folder where {UnrealBinaryBuilderHelpers.SetupBatFileName} and {UnrealBinaryBuilderHelpers.GenerateProjectBatFileName} exists.", "Incorrect folder");
				return;
			}

			if (bIsBuilding == false)
			{
				if (bBuildSetupBatFile.IsChecked == true)
				{
					bIsBuilding = true;
					string Commandline = SetupBatCommandLineArgs();
					ProcessStartInfo processStartInfo = new ProcessStartInfo
					{
						FileName = Path.Combine(SetupBatFilePath.Text, UnrealBinaryBuilderHelpers.SetupBatFileName),
						Arguments = Commandline,
						UseShellExecute = false,
						CreateNoWindow = true,
						RedirectStandardError = true,
						RedirectStandardOutput = true
					};

					currentProcessType = CurrentProcessType.SetupBat;
					CreateProcess(processStartInfo);
					AddLogEntry($"Commandline: {Commandline}");
					ChangeStatusLabel("Building...");
					GameAnalyticsCSharp.AddProgressStart("Build", "Setup");
				}
				else if (bGenerateProjectFiles.IsChecked == true)
				{
					GenerateProjectFiles();
				}
				else if (bBuildAutomationTool.IsChecked == true)
				{
					BuildAutomationTool();
				}
				else
				{
					BuildEngine();
				}
			}
		}

		private void CreateProcess(ProcessStartInfo processStartInfo, bool bClearLogs = true)
		{
			if (File.Exists(processStartInfo.FileName))
			{
				StartSetupBatFile.IsEnabled = false;
				DispatchTimer.Start();
				StopwatchTimer.Start();

				CompiledFiles = CompiledFilesTotal = 0;
				ProcessedFilesLabel.Text = "[Compiled: 0. Total: 0]";

				if (bClearLogs)
				{
					LogControl.ClearAllLogs();
					AddLogEntry($"Welcome to Unreal Binary Builder v{UnrealBinaryBuilderHelpers.GetProductVersionString()}");
				}

				AddLogEntry($"========================== RUNNING - {Path.GetFileName(processStartInfo.FileName)} ==========================");

				CurrentProcess = new Process();
				CurrentProcess.StartInfo = processStartInfo;
				CurrentProcess.EnableRaisingEvents = true;
				CurrentProcess.OutputDataReceived += new DataReceivedEventHandler(CurrentProcess_OutputDataReceived);
				CurrentProcess.ErrorDataReceived += new DataReceivedEventHandler(CurrentProcess_ErrorDataReceived);
				CurrentProcess.Exited += new EventHandler(CurrentProcess_Exited);
				CurrentProcess.Start();
				CurrentProcess.BeginErrorReadLine();
				CurrentProcess.BeginOutputReadLine();
			}
			else
			{
				AddLogEntry($"File does not exist: {processStartInfo.FileName}", true);
				ShowToastMessage($"File does not exist: {Path.GetFileName(processStartInfo.FileName)}", LogViewer.EMessageType.Error);
			}
		}

		private void CloseCurrentProcess(bool bKillProcess = false)
		{
			if (CurrentProcess != null)
			{
				if (bKillProcess)
				{
					CurrentProcess.Kill(true);
				}
				else
				{
					CurrentProcess.Close();
					CurrentProcess.Dispose();
					CurrentProcess = null;
				}
			}
		}

		private string GetCurrentProcessName()
		{
			if (CurrentProcess != null)
			{
				return CurrentProcess.ProcessName;
			}

			return null;
		}

		private void WriteToLogFile()
		{
			BuilderSettings.WriteToLogFile(LogMessage);
			BuilderSettings.WriteErrorsToLogFile(LogMessageErrors);
		}

		private void UpdateSkin(SkinType skin)
		{
			SharedResourceDictionary.SharedDictionaries.Clear();
			Resources.MergedDictionaries.Add(ResourceHelper.GetSkin(skin));
			Resources.MergedDictionaries.Add(new ResourceDictionary
			{
				Source = new Uri("pack://application:,,,/HandyControl;component/Themes/Theme.xaml")
			});
			Application.Current.MainWindow?.OnApplyTemplate();
			GameAnalyticsCSharp.AddDesignEvent($"Theme:{skin.ToString()}");
		}

		private void CustomBuildXMLBrowse_Click(object sender, RoutedEventArgs e)
		{
			OpenFileDialog NewFileDialog = new OpenFileDialog
			{
				Filter = "xml file (*.xml)|*.xml"
			};

			ChangeStatusLabel("Waiting for custom build file...");
			if (NewFileDialog.ShowDialog() == true)
			{
				CustomBuildXMLFile.Text = NewFileDialog.FileName;
				CustomOptions.IsEnabled = true;
				GameAnalyticsCSharp.AddDesignEvent($"BuildXML:Custom:{NewFileDialog.FileName}");
			}

			ChangeStatusLabel("Idle.");
		}

		private void ResetDefaultBuildXML_Click(object sender, RoutedEventArgs e)
		{
			CustomBuildXMLFile.Text = UnrealBinaryBuilderHelpers.DEFAULT_BUILD_XML_FILE;
			GameAnalyticsCSharp.AddDesignEvent("BuildXML:ResetToDefault");
		}

		private string PrepareCommandline()
		{
			string BuildXMLFile = CustomBuildXMLFile.Text;
			if (CustomBuildXMLFile.Text == "")
			{
				BuildXMLFile = UnrealBinaryBuilderHelpers.DEFAULT_BUILD_XML_FILE;
			}

			if (BuildXMLFile != UnrealBinaryBuilderHelpers.DEFAULT_BUILD_XML_FILE)
			{
				BuildXMLFile = string.Format("\"{0}\"", CustomBuildXMLFile.Text);
			}

			if (GameConfigurations.Text == "")
			{
				GameConfigurations.Text = "Development;Shipping";
				GameAnalyticsCSharp.AddDesignEvent("CommandLine:GameConfiguration:Reset");
			}

			string CommandLineArgs = string.Format("BuildGraph -target=\"Make Installed Build Win64\" -script={0} -set:WithDDC={1} -set:SignExecutables={2} -set:EmbedSrcSrvInfo={3} -set:GameConfigurations={4} -set:WithFullDebugInfo={5} -set:HostPlatformEditorOnly={6} -set:AnalyticsTypeOverride={7}",
					BuildXMLFile,
					GetConditionalString(bWithDDC.IsChecked),
					GetConditionalString(bSignExecutables.IsChecked),
					GetConditionalString(bEnableSymStore.IsChecked),
					GameConfigurations.Text,
					GetConditionalString(bWithFullDebugInfo.IsChecked),
					GetConditionalString(bHostPlatformEditorOnly.IsChecked),
					AnalyticsOverride.Text);

			if (bWithDDC.IsChecked == true && bHostPlatformDDCOnly.IsChecked == true)
			{
				CommandLineArgs += " -set:HostPlatformDDCOnly=true";
			}

			if (bHostPlatformOnly.IsChecked == true)
			{
				CommandLineArgs += " -set:HostPlatformOnly=true";
				GameAnalyticsCSharp.AddDesignEvent("CommandLine:HostOnly");
			}
			else
			{
				if (SupportWin32)
				{
					CommandLineArgs += string.Format(" -set:WithWin32={0}", GetConditionalString(bWithWin32.IsChecked));
				}

				CommandLineArgs += string.Format(" -set:WithWin64={0} -set:WithMac={1} -set:WithAndroid={2} -set:WithIOS={3} -set:WithTVOS={4} -set:WithLinux={5} -set:WithLumin={6}",
						GetConditionalString(bWithWin64.IsChecked),
						GetConditionalString(bWithMac.IsChecked),
						GetConditionalString(bWithAndroid.IsChecked),
						GetConditionalString(bWithIOS.IsChecked),
						GetConditionalString(bWithTVOS.IsChecked),
						GetConditionalString(bWithLinux.IsChecked),
						GetConditionalString(bWithLumin.IsChecked));

				if (SupportHTML5)
				{
					CommandLineArgs += string.Format(" -set:WithHTML5={0}",
					GetConditionalString(bWithHTML5.IsChecked));
				}

				if (SupportConsoles)
				{
					CommandLineArgs += string.Format(" -set:WithSwitch={0} -set:WithPS4={1} -set:WithXboxOne={2}",
					GetConditionalString(bWithSwitch.IsChecked),
					GetConditionalString(bWithPS4.IsChecked),
					GetConditionalString(bWithXboxOne.IsChecked));
				}

				if (SupportLinuxArm64)
				{
					CommandLineArgs += string.Format(" -set:WithLinuxArm64={0}", GetConditionalString(bWithLinuxAArch64.IsChecked));
				}
				else if (SupportLinuxAArch64)
				{
					CommandLineArgs += string.Format(" -set:WithLinuxAArch64={0}", GetConditionalString(bWithLinuxAArch64.IsChecked));
				}
			}

			if (IsEngineSelection425OrAbove)
			{
				CommandLineArgs += string.Format(" -set:CompileDatasmithPlugins={0}", GetConditionalString(bCompileDatasmithPlugins.IsChecked));
			}

			if (SupportVisualStudio2019)
			{
				CommandLineArgs += string.Format(" -set:VS2019={0}", GetConditionalString(bVS2019.IsChecked));
			}

			if (SupportServerClientTargets)
			{
				CommandLineArgs += string.Format(" -set:WithServer={0} -set:WithClient={1} -set:WithHoloLens={2}",
					GetConditionalString(bWithServer.IsChecked),
					GetConditionalString(bWithClient.IsChecked),
					GetConditionalString(bWithHololens.IsChecked));
			}

			if (BuildXMLFile != UnrealBinaryBuilderHelpers.DEFAULT_BUILD_XML_FILE && CustomOptions.Text != string.Empty)
			{
				CommandLineArgs += string.Format(" {0}", CustomOptions.Text);
				AddLogEntry("Using custom options...");
				GameAnalyticsCSharp.AddDesignEvent("CommandLine:UsingCustomOptions");
			}

			if (bCleanBuild.IsChecked == true)
			{
				CommandLineArgs += " -Clean";
				GameAnalyticsCSharp.AddDesignEvent("CommandLine:CleanEnabled");
			}

			return CommandLineArgs;
		}

		private void BuildRocketUE_Click(object sender, RoutedEventArgs e)
		{
			BuildEngine();
		}

		private void BuildEngine()
		{
			if (bIsBuilding)
			{
				MessageBoxResult MessageResult;
				switch (currentProcessType)
				{
					case CurrentProcessType.SetupBat:
					case CurrentProcessType.GenerateProjectFiles:
						MessageResult = HandyControl.Controls.MessageBox.Show("Automation tool is currently running. Would you like to stop it and start building the Engine?\n\nPress Yes to force stop Automation Tool and begin Engine Build.\nPress No to continue current process.", "Automation Tool Running!", MessageBoxButton.YesNo, MessageBoxImage.Question);
						switch (MessageResult)
						{
							case MessageBoxResult.Yes:
								GameAnalyticsCSharp.AddDesignEvent($"Build:{UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_NAME}:Killed");
								CloseCurrentProcess(true);
								break;
							case MessageBoxResult.No:
								return;
						}
						break;
					case CurrentProcessType.BuildUnrealEngine:
						MessageResult = HandyControl.Controls.MessageBox.Show("Unreal Engine is being compiled right now. Do you want to stop it?", "Compiling Engine", MessageBoxButton.YesNo, MessageBoxImage.Question);
						if (MessageResult == MessageBoxResult.Yes)
						{
							GameAnalyticsCSharp.AddDesignEvent($"Build:{UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_NAME}:UnrealEngine:Killed");
							CloseCurrentProcess(true);
						}
						return;
				}
			}

			TryUpdateAutomationExePath();
			EngineTabControl.SelectedIndex = 2;
			currentProcessType = CurrentProcessType.BuildUnrealEngine;
			bLastBuildSuccess = false;

			if (FinalBuildPath == null && string.IsNullOrWhiteSpace(AutomationExePath) == false)
			{
				if (UnrealBinaryBuilderHelpers.IsUnrealEngine5)
				{
					FinalBuildPath = Path.GetFullPath(AutomationExePath).Replace(@$"\Engine\Binaries\DotNET\{UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_NAME}", @"\LocalBuilds\Engine").Replace(Path.GetFileName(AutomationExePath), "");
				}
				else
				{
					FinalBuildPath = Path.GetFullPath(AutomationExePath).Replace(@"\Engine\Binaries\DotNET", @"\LocalBuilds\Engine").Replace(Path.GetFileName(AutomationExePath), "");
				}
			}

			if (Directory.Exists(FinalBuildPath))
			{
				MessageBoxResult MessageResult = HandyControl.Controls.MessageBox.Show($"Looks like an Engine build is already available at {FinalBuildPath}. Would you like to skip compiling the Engine and start zipping the existing build?\n\nPress Yes to Skip Engine build and start zipping (if enabled).\nPress No to continue with Engine Build.\nPress Cancel to do nothing.", "Zip Binary Version", MessageBoxButton.YesNoCancel, MessageBoxImage.Question);
				switch (MessageResult)
				{
					case MessageBoxResult.Yes:
						GameAnalyticsCSharp.AddDesignEvent("Build:EngineExists:FinishBuild");
						// We don't want the system to shutdown since user is interacting.
						bool? bOriginalShutdownState = bShutdownWindows.IsChecked;
						bShutdownWindows.IsChecked = false;
						OnBuildFinished(true);
						bShutdownWindows.IsChecked = bOriginalShutdownState;
						return;
					case MessageBoxResult.Cancel:
						GameAnalyticsCSharp.AddDesignEvent("Build:EngineExists:Exit");
						return;
					default:
						GameAnalyticsCSharp.AddDesignEvent("Build:EngineExists:IgnoreAndContinue");
						break;
				}
			}

			ChangeStatusLabel("Preparing to build...");

			if (postBuildSettings.ShouldSaveToZip() && postBuildSettings.DirectoryIsWritable(Path.GetDirectoryName(ZipPath.Text)) == false)
			{
				GameAnalyticsCSharp.AddDesignEvent("Build:ZipEnabled:InvalidSetting");
				HandyControl.Controls.MessageBox.Error(string.Format("You chose to save Engine build as a zip file but below directory is either not available or not writable.\n\n{0}", ZipPath.Text), "Error");
				return;
			}

			if (CustomBuildXMLFile.Text == string.Empty)
			{
				CustomBuildXMLFile.Text = UnrealBinaryBuilderHelpers.DEFAULT_BUILD_XML_FILE;
			}
			else if (CustomBuildXMLFile.Text != UnrealBinaryBuilderHelpers.DEFAULT_BUILD_XML_FILE)
			{
				if (File.Exists(CustomBuildXMLFile.Text) == false)
				{
					GameAnalyticsCSharp.LogEvent("BuildXML does not exist.", GameAnalyticsSDK.Net.EGAErrorSeverity.Error);
					ChangeStatusLabel("Error. Build xml does not exist.");
					HandyControl.Controls.MessageBox.Error(string.Format("Build XML {0} does not exist!", CustomBuildXMLFile.Text), "Error");
					return;
				}
			}

			if (SupportHTML5 == false && bWithHTML5.IsChecked == true)
			{
				GameAnalyticsCSharp.AddDesignEvent($"Build:HTML5:IncorrectEngine:{GetEngineName()}");
				bWithHTML5.IsChecked = false;
				if (SettingsJSON.bShowHTML5DeprecatedMessage)
				{
					HandyControl.Controls.MessageBox.Show("HTML5 support was removed from Unreal Engine 4.24 and higher. You had it enabled but since it is of no use, it is disabled.");
				}
			}

			if (SupportConsoles == false && (bWithSwitch.IsChecked == true || bWithPS4.IsChecked == true || bWithXboxOne.IsChecked == true))
			{
				GameAnalyticsCSharp.AddDesignEvent($"Build:Console:IncorrectEngine:{GetEngineName()}");
				bWithSwitch.IsChecked = bWithPS4.IsChecked = bWithXboxOne.IsChecked = false;
				if (SettingsJSON.bShowConsoleDeprecatedMessage)
				{
					HandyControl.Controls.MessageBox.Show("Console support was removed from Unreal Engine 4.25 and higher. You had it enabled but since it is of no use, it is disabled.");
				}
			}

			bool bContinueToBuild = true;
			if (SettingsJSON.bEnableEngineBuildConfirmationMessage)
			{
				bContinueToBuild = HandyControl.Controls.MessageBox.Show("You are going to build a binary version of Unreal Engine 4. This is a long process and might take time to finish. Are you sure you want to continue? ", "Build Binary Version", MessageBoxButton.YesNo, MessageBoxImage.Question) == MessageBoxResult.Yes;
			}

			if (bContinueToBuild)
			{
				if (bWithDDC.IsChecked == true && SettingsJSON.bEnableDDCMessages)
				{
					MessageBoxResult MessageResult = HandyControl.Controls.MessageBox.Show("Building Derived Data Cache (DDC) is one of the slowest aspect of the build. You can skip this step if you want to. Do you want to continue with DDC enabled?\n\nPress Yes to continue with build\nPress No to continue without DDC\nPress Cancel to stop build", "Warning", MessageBoxButton.YesNoCancel, MessageBoxImage.Warning);

					switch (MessageResult)
					{
						case MessageBoxResult.No:
							bWithDDC.IsChecked = false;
							GameAnalyticsCSharp.AddDesignEvent("Build:DDC:AutoDisabled");
							break;
						case MessageBoxResult.Cancel:
							GameAnalyticsCSharp.AddDesignEvent("Build:DDC:Exit");
							return;
						default:
							GameAnalyticsCSharp.AddDesignEvent("Build:DDC:IgnoreAndContinue");
							break;
					}
				}

				GameAnalyticsCSharp.AddDesignEvent($"Build:Engine:{GetEngineName()}");
				BuildRocketUE.Content = "Stop Build";
				BuildRocketUE.IsEnabled = true;
				string CommandLineArgs = PrepareCommandline();

				ProcessStartInfo AutomationStartInfo = new ProcessStartInfo
				{
					FileName = AutomationExePath,
					Arguments = CommandLineArgs,
					UseShellExecute = false,
					CreateNoWindow = true,
					RedirectStandardError = true,
					RedirectStandardOutput = true
				};

				CreateProcess(AutomationStartInfo);

				bIsBuilding = true;
				ChangeStatusLabel("Building...");
				ZipStatusLabel.Content = "Waiting for Engine to finish building...";
				GameAnalyticsCSharp.AddDesignEvent("Build:Started");

				if (Git.CommitHashShort != null)
				{
					AddLogEntry($"Building commit {Git.CommitHashShort}");
				}
			}
		}

		private bool IsUnrealEngine4()
		{
			return GetEngineValue() < 5;
		}

		public bool SupportServerClientTargets => GetEngineValue() > 4.22;

		public bool SupportWin32 => IsUnrealEngine4();

		public bool SupportHTML5 => GetEngineValue() < 4.24;

		public bool SupportLinuxAArch64 => IsUnrealEngine4() && GetEngineValue() >= 4.24;

		public bool SupportLinuxArm64 => IsUnrealEngine4() == false;

		public bool SupportConsoles => GetEngineValue() <= 4.24;

		public bool SupportVisualStudio2019 => IsUnrealEngine4() && IsEngineSelection425OrAbove;

		public bool IsEngineSelection425OrAbove => GetEngineValue() >= 4.25;

		private string GetEngineName()
		{
			return UnrealBinaryBuilderHelpers.DetectEngineVersion(SetupBatFilePath.Text);
		}

		private double GetEngineValue()
		{
			string MyEngineName = GetEngineName();
			if (MyEngineName != null)
			{
				int pos = MyEngineName.LastIndexOf(".");
				if (pos > 0)
				{
					string sub = MyEngineName.Substring(pos).Replace(".", "");
					string RemovedName = MyEngineName.Remove(pos);
					double EngineValue = Convert.ToDouble(RemovedName.Insert(pos, sub));
					return EngineValue;
				}
			}

			return 0;
		}

		private void CopyCommandLine_Click(object sender, RoutedEventArgs e)
		{
			GameAnalyticsCSharp.AddDesignEvent("CommandLine:CopyToClipboard");
			Clipboard.SetDataObject(PrepareCommandline());
			HandyControl.Controls.MessageBox.Show("Command line copied to clipboard!");
		}

		private void SetZipPathLocation_Click(object sender, RoutedEventArgs e)
		{
			System.Windows.Forms.SaveFileDialog SFD = new System.Windows.Forms.SaveFileDialog();
			SFD.DefaultExt = ".zip";
			SFD.Filter = "Zip File (.zip)|*.zip";
			if (Git.CommitHashShort != null)
			{
				SFD.FileName = Git.CommitHashShort;
			}
			System.Windows.Forms.DialogResult SaveDialogResult = SFD.ShowDialog();
			if (SaveDialogResult == System.Windows.Forms.DialogResult.OK)
			{
				ZipPath.Text = SFD.FileName;
			}
		}

		private void GenerateProjectFiles()
		{
			if (bIsBuilding == false)
			{
				bIsBuilding = true;
				BuildRocketUE.IsEnabled = false;
				ProcessStartInfo processStartInfo = new ProcessStartInfo
				{
					FileName = Path.Combine(SetupBatFilePath.Text, UnrealBinaryBuilderHelpers.GenerateProjectBatFileName),
					UseShellExecute = false,
					CreateNoWindow = true,
					RedirectStandardError = true,
					RedirectStandardOutput = true
				};

				currentProcessType = CurrentProcessType.GenerateProjectFiles;
				CreateProcess(processStartInfo, false);
				ChangeStatusLabel("Building...");
				GameAnalyticsCSharp.AddProgressStart("Build", "ProjectFiles");
			}
		}

		private bool? BuildAutomationTool()
		{
			if (UnrealBinaryBuilderHelpers.IsUnrealEngine5)
			{
				if (bIsBuilding == false)
				{
					if (string.IsNullOrEmpty(AutomationExePath))
					{
						if (TryUpdateAutomationExePath() == false)
						{
							AddLogEntry($"Failed to build {UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_NAME}. AutomationExePath was null.", true);
							return null;
						}
					}

					bIsBuilding = true;
					BuildRocketUE.IsEnabled = false;
					currentProcessType = CurrentProcessType.BuildAutomationTool;
					if (UnrealBinaryBuilderHelpers.AutomationToolExists(SetupBatFilePath.Text) == true)
					{
						AddLogEntry($"Skip building ${UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_NAME}. Already exists.");
						OnBuildFinished(true);
						return false;
					}

					string MsBuildFile = UnrealBinaryBuilderHelpers.GetMsBuildPath();
					if (File.Exists(MsBuildFile))
					{
						ProcessStartInfo processStartInfo = new ProcessStartInfo
						{
							FileName = MsBuildFile,
							Arguments = $"/restore /verbosity:minimal {UnrealBinaryBuilderHelpers.GetAutomationToolProjectFile(SetupBatFilePath.Text)}",
							UseShellExecute = false,
							CreateNoWindow = true,
							RedirectStandardError = true,
							RedirectStandardOutput = true
						};

						CreateProcess(processStartInfo, false);
						ChangeStatusLabel("Building...");
						GameAnalyticsCSharp.AddProgressStart("Build", UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_NAME);
						return true;
					}
					else
					{
						AddLogEntry($"Unable to build {UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_NAME}. MsBuild not found in {MsBuildFile}", true);
					}
				}

				return false;
			}

			return BuildAutomationToolLauncher();
		}
		private bool? BuildAutomationToolLauncher()
		{
			if (bIsBuilding == false)
			{
				if (string.IsNullOrEmpty(AutomationExePath))
				{
					if (TryUpdateAutomationExePath() == false)
					{
						AddLogEntry($"Failed to build {UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_LAUNCHER_NAME}. AutomationExePath was null.", true);
						return null;
					}
				}

				bIsBuilding = true;
				BuildRocketUE.IsEnabled = false;
				currentProcessType = CurrentProcessType.BuildAutomationToolLauncher;
				if (File.Exists(AutomationExePath))
				{
					AddLogEntry($"Skip building ${UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_LAUNCHER_NAME}. Already exists.");
					OnBuildFinished(true);
					return false;
				}

				if (UnrealBinaryBuilderHelpers.IsUnrealEngine5)
				{
					string MsBuildFile = UnrealBinaryBuilderHelpers.GetMsBuildPath();
					if (File.Exists(MsBuildFile))
					{
						ProcessStartInfo processStartInfo = new ProcessStartInfo
						{
							FileName = MsBuildFile,
							Arguments = UnrealBinaryBuilderHelpers.GetAutomationToolLauncherProjectFile(SetupBatFilePath.Text),
							UseShellExecute = false,
							CreateNoWindow = true,
							RedirectStandardError = true,
							RedirectStandardOutput = true
						};

						CreateProcess(processStartInfo, false);
						ChangeStatusLabel("Building...");
						GameAnalyticsCSharp.AddProgressStart("Build", UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_LAUNCHER_NAME);
						return true;
					}
					else
					{
						AddLogEntry($"Unable to build ${UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_LAUNCHER_NAME}. MsBuild not found in {MsBuildFile}", true);
					}
				}
				else
				{
					string RunUATFile = Path.Combine(SetupBatFilePath.Text, "Engine", "Build", "BatchFiles", "RunUAT.bat");
					if (File.Exists(RunUATFile))
					{
						ProcessStartInfo processStartInfo = new ProcessStartInfo
						{
							FileName = RunUATFile,
							Arguments = "-compileonly",
							UseShellExecute = false,
							CreateNoWindow = true,
							RedirectStandardError = true,
							RedirectStandardOutput = true
						};

						CreateProcess(processStartInfo, false);
						ChangeStatusLabel("Building...");
						GameAnalyticsCSharp.AddProgressStart("Build", UnrealBinaryBuilderHelpers.AUTOMATION_TOOL_LAUNCHER_NAME);
						return true;
					}
				}
			}

			return null;
		}

		private string BuildPlugin(PluginCard pluginCard)
		{
			if (bIsBuilding == false)
			{
				if (pluginCard.IsValid())
				{
					CurrentPluginBeingBuilt = pluginCard;
					bIsBuilding = true;
					BuildRocketUE.IsEnabled = false;
					StartPluginBuildsBtn.IsEnabled = false;
					currentProcessType = CurrentProcessType.BuildPlugin;
					AddLogEntry($"========================== BUILDING PLUGIN {Path.GetFileNameWithoutExtension(pluginCard.PluginPath).ToUpper()} ==========================");
					AddLogEntry($"Plugin: {pluginCard.PluginPath}");
					AddLogEntry($"Package Location: {pluginCard.DestinationPath}");
					AddLogEntry($"Target Engine: {pluginCard.EngineVersionText.Text}");
					ProcessStartInfo processStartInfo = new ProcessStartInfo
					{
						FileName = pluginCard.RunUATFile,
						Arguments = $"BuildPlugin -Plugin=\"{pluginCard.PluginPath}\" -Package=\"{pluginCard.DestinationPath}\" -Rocket {pluginCard.GetCompiler()} {pluginCard.GetTargetPlatforms()}",
						UseShellExecute = false,
						CreateNoWindow = true,
						RedirectStandardError = true,
						RedirectStandardOutput = true
					};

					pluginCard.BuildStarted();
					CreateProcess(processStartInfo, false);
					ChangeStatusLabel($"Building Plugin - {Path.GetFileNameWithoutExtension(pluginCard.PluginPath)}");
					ShowToastMessage($"Building Plugin - {Path.GetFileNameWithoutExtension(pluginCard.PluginPath)}", LogViewer.EMessageType.Info, false, true, "PluginBuild");
					GameAnalyticsCSharp.AddProgressStart("Build", "Plugin");					
					return null;
				}

				return $"{pluginCard.PluginName.Text} ({pluginCard.EngineVersionText.Text}) is already compiled.";
			}

			return "Cannot build plugin while task is running";
		}

		private void CancelZipping_Click(object sender, RoutedEventArgs e)
		{
			postBuildSettings.CancelTask();
		}

		private void OpenBuildFolder_Click(object sender, RoutedEventArgs e)
		{
			Process.Start("explorer.exe", FinalBuildPath);
		}

		private void GitCachePathBrowse_Click(object sender, RoutedEventArgs e)
		{
			System.Windows.Forms.FolderBrowserDialog NewFolderDialog = new System.Windows.Forms.FolderBrowserDialog();
			NewFolderDialog.ShowDialog();
			GitCachePath.Text = NewFolderDialog.SelectedPath;
		}

		private void PluginQueueBtn_Click(object sender, RoutedEventArgs e)
		{
			if (File.Exists(PluginPath.Text) && Directory.Exists(PluginDestinationPath.Text))
			{
				if (PluginEngineVersionSelection.SelectedIndex < 0)
				{
					HandyControl.Controls.MessageBox.Fatal($"Cannot build \"{Path.GetFileNameWithoutExtension(PluginPath.Text)}\". Engine selection is invalid.");
					return;
				}

				List<string> TargetPlatformsList = null;
				if (bPluginOverrideTargetPlatforms.IsChecked == true)
				{
					TargetPlatformsList = new List<string>();					
					foreach (var C in PluginPlatforms.Children)
					{
						if (((CheckBox)C).IsChecked == true)
						{
							TargetPlatformsList.Add(((CheckBox)C).Name.Replace("bPlugin", ""));
						}
					}
				}

				bool bCanUse2019Compiler = bUse2019Compiler.IsEnabled && (bool)bUse2019Compiler.IsChecked;
				PluginQueues.Children.Add(new PluginCard(this, PluginPath.Text, PluginDestinationPath.Text, PluginBuildEnginePath[PluginEngineVersionSelection.SelectedIndex], (bool)bCanUse2019Compiler, TargetPlatformsList, (bool)PluginZip.IsChecked, PluginZipPath.Text, (bool)PluginZipForMarketplace.IsChecked));
				PluginQueueBtn.IsEnabled = false;
				PluginPath.Text = "";
				PluginDestinationPath.Text = "";
				PluginEngineVersionSelection.SelectedIndex = -1;
				PluginZipForMarketplace.IsChecked = true;
				PluginZip.IsChecked = false;
				PluginZipPath.Text = "";
				foreach (var C in PluginPlatforms.Children)
				{
					if (((CheckBox)C).Name != "bPluginWin64")
					{
						((CheckBox)C).IsChecked = false;
					}
				}
			}
			else
			{
				HandyControl.Controls.MessageBox.Fatal($"Cannot build \"{Path.GetFileNameWithoutExtension(PluginPath.Text)}\". Either file does not exist or save location is not valid.");
			}
		}

		private void PluginPathBrowse_Click(object sender, RoutedEventArgs e)
		{
			OpenFileDialog NewFileDialog = new OpenFileDialog
			{
				Filter = "Unreal Plugin file (*.uplugin)|*.uplugin"
			};

			if (NewFileDialog.ShowDialog() == true)
			{
				PluginPath.Text = NewFileDialog.FileName;
				foreach (var C in PluginPlatforms.Children)
				{
					CheckBox checkBox = (CheckBox)C;
					if (checkBox.Name != "bPluginWin64")
					{
						checkBox.IsChecked = false;
					}
				}

				using (StreamReader reader = File.OpenText(PluginPath.Text))
				{
					UE4PluginJson PluginJson = JsonConvert.DeserializeObject<UE4PluginJson>(File.ReadAllText(PluginPath.Text));
					
					if (PluginJson.Modules[0].WhitelistPlatforms != null)
					{
						foreach (var C in PluginPlatforms.Children)
						{
							CheckBox checkBox = (CheckBox)C;
							if (PluginJson.Modules[0].WhitelistPlatforms.Contains(checkBox.Name.Replace("bPlugin", "")))
							{
								checkBox.IsChecked = true;
							}
						}
					}
				}

			}

			if (File.Exists(PluginPath.Text) && Directory.Exists(PluginDestinationPath.Text))
			{
				PluginQueueBtn.IsEnabled = true;
			}
		}

		private void PluginDestinationPathBrowse_Click(object sender, RoutedEventArgs e)
		{
			System.Windows.Forms.FolderBrowserDialog NewFolderDialog = new System.Windows.Forms.FolderBrowserDialog();
			NewFolderDialog.ShowDialog();
			PluginDestinationPath.Text = NewFolderDialog.SelectedPath;

			if (File.Exists(PluginPath.Text) && Directory.Exists(PluginDestinationPath.Text))
			{
				PluginQueueBtn.IsEnabled = true;
			}
		}

		public void RemovePluginFromList(PluginCard pluginCard)
		{
			PluginQueues.Children.Remove(pluginCard);
		}

		private void StartPluginBuildsBtn_Click(object sender, RoutedEventArgs e)
		{
			if (PluginQueues.Children.Count == 0)
			{
				HandyControl.Controls.MessageBox.Fatal("Queue is empty. Add one or more plugin to queue and build.");
			}
			else
			{
				string PluginBuildMessage = null;
				foreach (var C in PluginQueues.Children)
				{
					PluginCard pluginCard = (PluginCard)C;
					if (pluginCard.IsPending())
					{
						AddLogEntry($"Building {PluginQueues.Children.Count} Plugin(s).");
						AddLogEntry("");
						ShowToastMessage($"Building {PluginQueues.Children.Count} Plugin(s).");
						PluginBuildMessage = BuildPlugin(pluginCard);
						break;
					}
				}

				if (PluginBuildMessage != null)
				{
					Growl.Clear();
					HandyControl.Controls.MessageBox.Fatal(PluginBuildMessage);
				}
			}
		}

		private void PluginEngineVersionSelection_SelectionChanged(object sender, SelectionChangedEventArgs e)
		{
			try
			{
				bUse2019Compiler.IsEnabled = Convert.ToDouble(PluginEngineVersionSelection.SelectedValue) >= 4.25;
			}
			catch (Exception) {}
		}

		private void PluginZipDestinationPathBrowse_Click(object sender, RoutedEventArgs e)
		{
			System.Windows.Forms.FolderBrowserDialog NewFolderDialog = new System.Windows.Forms.FolderBrowserDialog();
			NewFolderDialog.ShowDialog();
			PluginZipPath.Text = NewFolderDialog.SelectedPath;
		}

		private void GetSourceCode_Click(object sender, RoutedEventArgs e)
		{
			OpenBrowser("https://github.com/ryanjon2040/Unreal-Binary-Builder");
			GameAnalyticsCSharp.AddDesignEvent("Menu:Click:SourceCode");
		}

		private void SupportUnrealX_Click(object sender, RoutedEventArgs e)
		{
			OpenBrowser("https://www.buymeacoffee.com/ryanjon2040");
			GameAnalyticsCSharp.AddDesignEvent("Menu:Click:BuyMeACoffee");
		}

		private void SupportAgora_Click(object sender, RoutedEventArgs e)
		{
			OpenBrowser("https://www.patreon.com/ryanjon2040");
			GameAnalyticsCSharp.AddDesignEvent("Menu:Click:Agora");
		}

		private void FeedbackBtn_Click(object sender, RoutedEventArgs e)
		{
			OpenBrowser("https://forms.gle/LeZqAeqmV9fWQpxP7");
			GameAnalyticsCSharp.AddDesignEvent("Menu:Click:Feedback");
		}
		private void ChangelogBtn_Click(object sender, RoutedEventArgs e)
		{
			OpenBrowser("https://github.com/ryanjon2040/Unreal-Binary-Builder/blob/master/CHANGELOG.md");
			GameAnalyticsCSharp.AddDesignEvent("Menu:Click:Changelog");
		}

		private void OpenLogFolderBtn_Click(object sender, RoutedEventArgs e)
		{
			BuilderSettings.OpenLogFolder();
		}

		private void OpenSettingsBtn_Click(object sender, RoutedEventArgs e)
		{
			BuilderSettings.OpenSettings();
		}

		private void AboutBtn_Click(object sender, RoutedEventArgs e)
		{
			GameAnalyticsCSharp.AddDesignEvent("AboutDialog:Open");
			aboutDialog = Dialog.Show(new AboutDialog(this));
		}

		public void CloseAboutDialog()
		{
			GameAnalyticsCSharp.AddDesignEvent("AboutDialog:Close");
			aboutDialog.Close();
		}

		private void GitPlatform_CheckedChanged(object sender, RoutedEventArgs e)
		{
			string TargetPlatformName = ((Control)sender).Name.Replace("Git", "").Replace("Platform", "");
			BuilderSettings.UpdatePlatformInclusion(TargetPlatformName, (bool)((CheckBox)sender).IsChecked);
		}

		private void OpenCodeEditor(string FileType)
		{
			string FilePath = null;
			string UE4FileType = $"UE4{FileType}.Target.cs";
			string UE5FileType = $"Unreal{FileType}.Target.cs";
			if (string.IsNullOrWhiteSpace(SetupBatFilePath.Text) == false)
			{
				FilePath = Path.Combine(SetupBatFilePath.Text, "Engine", "Source", UE5FileType);
				if (File.Exists(FilePath) == false)
				{
					FilePath = Path.Combine(SetupBatFilePath.Text, "Engine", "Source", UE4FileType);
				}
			}
			else if (string.IsNullOrWhiteSpace(AutomationExePath) == false)
			{
				string Local_BaseEnginePath = Regex.Replace(AutomationExePath, @"\\Binaries.+", "");
				FilePath = Path.Combine(Local_BaseEnginePath, "Source", UE5FileType);
				if (File.Exists(FilePath) == false)
				{
					FilePath = Path.Combine(Local_BaseEnginePath, "Source", UE4FileType);
				}
			}

			if (string.IsNullOrWhiteSpace(FilePath))
			{
				HandyControl.Controls.MessageBox.Fatal("Please choose Engine root folder first.");
				return;
			}

			CodeEditor CE = new CodeEditor();
			CE.Owner = this;
			CE.Show();
			bool bLoaded = CE.LoadFile(FilePath);
			if (bLoaded == false)
			{
				HandyControl.Controls.MessageBox.Error($"{FilePath} does not exist.");
				CE.Close();
			}
		}

		private void EditServerTargetCs_Click(object sender, RoutedEventArgs e)
		{
			OpenCodeEditor("Server");
		}

		private void EditGameTargetCs_Click(object sender, RoutedEventArgs e)
		{
			OpenCodeEditor("Game");
		}

		private void EditEditorTargetCs_Click(object sender, RoutedEventArgs e)
		{
			OpenCodeEditor("Editor");
		}

		private void EditClientTargetCs_Click(object sender, RoutedEventArgs e)
		{
			OpenCodeEditor("Client");
		}

		private void SetupBatFilePath_TextChanged(object sender, TextChangedEventArgs e)
		{
			if (string.IsNullOrWhiteSpace(SetupBatFilePath.Text) == false)
			{
				string EngineVersion = UnrealBinaryBuilderHelpers.DetectEngineVersion(SetupBatFilePath.Text, true);
				if (EngineVersion != null)
				{
					FoundEngineLabel.Content = $"Selected Unreal Engine {EngineVersion}";
					if (Git.CommitHashShort != null)
					{
						FoundEngineLabel.Content = $"Selected Unreal Engine {EngineVersion}. Commit - {Git.CommitHashShort}";
					}
				}
				else
				{
					FoundEngineLabel.Content = "Unable to detect Engine version.";
				}

				AutomationExePath = null;
				TryUpdateAutomationExePath();

				System.Collections.ObjectModel.Collection<BindingExpressionBase> bindExps = CompileMainGrid.BindingGroup.BindingExpressions;
				foreach (BindingExpression bExp in bindExps)
				{
					if (bExp.BindingGroup.Name == "EngineChanged")
					{
						bExp.UpdateTarget();
					}
				}
			}
		}
	}
}

```

`UnrealBinaryBuilder/UnrealBinaryBuilder.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk.WindowsDesktop">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>netcoreapp3.1</TargetFramework>
    <UseWPF>true</UseWPF>
    <UseWindowsForms>true</UseWindowsForms>
    <Configurations>Debug;Release;ReleaseToPublic</Configurations>
    <PackageId>Unreal Binary Builder</PackageId>
    <Authors>Satheesh (ryanjon2040)</Authors>
    <Company>Satheesh (ryanjon2040)</Company>
    <Description>A helper application designed to create Installed Build of Unreal Engine from Github Source and plugin packager.</Description>
    <Copyright>Copyright 2020-2021. Created by Satheesh (ryanjon2040)</Copyright>
    <Version>3.1.6</Version>
    <PackageProjectUrl>https://www.buymeacoffee.com/ryanjon2040</PackageProjectUrl>
    <RepositoryUrl>https://github.com/ryanjon2040/Unreal-Binary-Builder</RepositoryUrl>
    <RepositoryType>Github</RepositoryType>
    <GeneratePackageOnBuild>false</GeneratePackageOnBuild>
    <PackageRequireLicenseAcceptance>false</PackageRequireLicenseAcceptance>
    <PackageLicenseFile>LICENSE.md</PackageLicenseFile>
    <PackageIcon>compiler.png</PackageIcon>
    <ApplicationIcon>compiler.ico</ApplicationIcon>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="AvalonEdit" Version="6.1.3.50" />
    <PackageReference Include="CefSharp.Wpf.NETCore" Version="98.1.210" />
    <PackageReference Include="DotNetZip" Version="1.16.0" />
    <PackageReference Include="GameAnalytics.Net.Core.SDK" Version="3.3.5" />
    <PackageReference Include="HandyControl" Version="3.2.0" />
    <PackageReference Include="LibGit2Sharp" Version="0.27.0-preview-0175" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
    <PackageReference Include="Sentry" Version="3.14.1" />
    <PackageReference Include="SpicyTaco.AutoGrid" Version="1.2.29" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\UnrealBinaryBuilderUpdater\UnrealBinaryBuilderUpdater.csproj" />
  </ItemGroup>

  <ItemGroup>
    <None Include="..\LICENSE.md">
      <Pack>True</Pack>
      <PackagePath></PackagePath>
    </None>
    <None Include="compiler.png">
      <Pack>True</Pack>
      <PackagePath></PackagePath>
    </None>
  </ItemGroup>

  <ItemGroup>
    <PackageReference Update="chromiumembeddedframework.runtime.win-x64" Version="98.1.21" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Update="chromiumembeddedframework.runtime.win-x86" Version="98.1.21" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Update="chromiumembeddedframework.runtime.win-arm64" Version="98.1.21" />
  </ItemGroup>

</Project>
```

`UnrealBinaryBuilder/UserControls/AboutDialog.xaml`:

```xaml
<Border x:Class="UnrealBinaryBuilder.UserControls.AboutDialog"
		xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
		xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
		xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
		xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
		xmlns:hc="https://handyorg.github.io/handycontrol"
		xmlns:local="clr-namespace:UnrealBinaryBuilder.UserControls"
		mc:Ignorable="d" 
		CornerRadius="10"
		 Background="{DynamicResource RegionBrush}">
	<Grid>
		<TextBlock Margin="10 10 40 10" Style="{StaticResource TextBlockDefaultInfo}" Text="A helper application designed to create binary version of Unreal Engine 4 from source&#xA;and package plugins as well as projects too.&#xA;&#xA;Created by Satheesh (ryanjon2040)&#xA;&#xA;Updated for 4.18 and PS4/Xbox Support by James Baxter (TheJamsh)&#xA;Updated for 4.21 and Lumin support by KarstenMaxim (AlphaSoftLLC)&#xA;Step counter added by Ben Vaccaro (freaksed)&#xA;Some small updates for 4.24 by Christian Walde (wchristian)"/>
		<Button x:Name="CloseBtn" Content="Close" HorizontalAlignment="Right" VerticalAlignment="Top" Margin="0,10,10,0" Style="{StaticResource ButtonIcon}" Foreground="{DynamicResource PrimaryBrush}" hc:IconElement.Geometry="{StaticResource ErrorGeometry}" Padding="0" Width="22" Height="22" Click="CloseBtn_Click"/>
	</Grid>
</Border>

```

`UnrealBinaryBuilder/UserControls/AboutDialog.xaml.cs`:

```cs
using HandyControl.Tools;
using System.Windows;
using System.Windows.Controls;

namespace UnrealBinaryBuilder.UserControls
{
	public partial class AboutDialog
	{
		private MainWindow _mainWindow;
		public AboutDialog(MainWindow mainWindow)
		{
			InitializeComponent();
			_mainWindow = mainWindow;
		}

		private void CloseBtn_Click(object sender, RoutedEventArgs e)
		{
			_mainWindow.CloseAboutDialog();
		}
	}
}

```

`UnrealBinaryBuilder/UserControls/CodeEditor.xaml`:

```xaml
<hc:GlowWindow x:Name="MainCodeEditor" x:Class="UnrealBinaryBuilder.UserControls.CodeEditor"
		xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
		xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
		xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
		xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		xmlns:avalon="http://icsharpcode.net/sharpdevelop/avalonedit"
		xmlns:hc="https://handyorg.github.io/handycontrol" 
		mc:Ignorable="d"
		Title="CodeEditor" Height="450" Width="800" WindowStartupLocation="CenterOwner" Closed="MainCodeEditor_Closed">
	<hc:GlowWindow.NonClientAreaContent>
		<StackPanel VerticalAlignment="Stretch" Orientation="Horizontal">
			<Separator Width="10" VerticalAlignment="Center" HorizontalAlignment="Center" Margin="10,0,0,0"/>
			<Menu DockPanel.Dock="Top">
				<MenuItem x:Name="SaveBtn" Header="Save" Click="SaveBtn_Click"/>
			</Menu>
		</StackPanel>
	</hc:GlowWindow.NonClientAreaContent>
	<Grid>
		<avalon:TextEditor x:Name="TextEditor" ShowLineNumbers="True" SyntaxHighlighting="C#" IsModified="{Binding Path=IsDirty, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" TextChanged="TextEditor_TextChanged" />
	</Grid>
</hc:GlowWindow>

```

`UnrealBinaryBuilder/UserControls/CodeEditor.xaml.cs`:

```cs
using System.IO;
using System.Windows;

namespace UnrealBinaryBuilder.UserControls
{
	/// <summary>
	/// Interaction logic for CodeEditor.xaml
	/// </summary>
	public partial class CodeEditor
	{
		private string Internal_FilePath = null;

		private bool _isDirty = false;
		public bool IsDirty
		{
			get { return _isDirty; }
			set
			{
				if (_isDirty != value)
				{
					_isDirty = value;
					Title = _isDirty ? "Code Editor (Modified)" : "Code Editor";
					SaveBtn.IsEnabled = _isDirty;
				}
			}
		}

		public CodeEditor()
		{
			InitializeComponent();
		}

		public bool LoadFile(string FilePath)
		{
			FileInfo fileInfo = new FileInfo(FilePath);
			if (fileInfo.Exists)
			{
				Internal_FilePath = FilePath;
				TextEditor.Load(FilePath);
				if (fileInfo.IsReadOnly)
				{
					TextEditor.IsEnabled = false;
					SaveBtn.IsEnabled = false;
				}
				IsDirty = false;
				return true;
			}

			return false;
		}

		private void MainCodeEditor_Closed(object sender, System.EventArgs e)
		{
			Internal_FilePath = null;
		}

		private void SaveBtn_Click(object sender, RoutedEventArgs e)
		{
			File.WriteAllText(Internal_FilePath, TextEditor.Text);
			IsDirty = false;
		}

		private void TextEditor_TextChanged(object sender, System.EventArgs e)
		{
			IsDirty = true;
		}
	}
}

```

`UnrealBinaryBuilder/UserControls/CrashReporter.xaml`:

```xaml
<hc:GlowWindow x:Class="UnrealBinaryBuilder.UserControls.CrashReporter"
		xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
		xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
		xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
		xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		xmlns:hc="https://handyorg.github.io/handycontrol" 
		xmlns:local="clr-namespace:UnrealBinaryBuilder.UserControls"
		Background="{DynamicResource MainContentBackgroundBrush}"
		ActiveGlowColor="{DynamicResource PrimaryColor}"
		InactiveGlowColor="{DynamicResource SecondaryBorderColor}"
		mc:Ignorable="d"
		Title="Crash Reporter" Height="400" Width="960" WindowStartupLocation="CenterOwner">
	<Grid>
		<Grid.RowDefinitions>
			<RowDefinition Height="Auto"/>
			<RowDefinition Height="Auto"/>
			<RowDefinition Height="Auto"/>
			<RowDefinition Height="Auto"/>
			<RowDefinition Height="Auto"/>
			<RowDefinition Height="Auto"/>
			<RowDefinition Height="Auto"/>
			<RowDefinition Height="Auto"/>
		</Grid.RowDefinitions>
		<Grid.ColumnDefinitions>
			<ColumnDefinition Width="Auto"/>
			<ColumnDefinition Width="*"/>
			<ColumnDefinition Width="*"/>
		</Grid.ColumnDefinitions>
		<TextBlock Text="Unreal Binary Builder Crash Report" Grid.ColumnSpan="3" HorizontalAlignment="Center" VerticalAlignment="Top" Margin="10"/>
		<TextBlock Grid.Row="1" Grid.ColumnSpan="3" Margin="10" Text="Apologies but something happened and an internal unhandled exception has occurred which should be resolved to improve Unreal Binary Builder. An exception report has been sent but please submit any additional information that you can provide." TextWrapping="Wrap"/>

		<hc:TextBox x:Name="StackTraceText" Grid.Column="3" Grid.Row="2" Grid.RowSpan="3" Margin="0 0 10 0" FontSize="10" MaxHeight="200" HorizontalScrollBarVisibility="Auto" VerticalScrollBarVisibility="Auto"/>

		<TextBlock Text="Name:" Grid.Row="2" VerticalAlignment="Center" Margin="10"/>
		<hc:TextBox x:Name="Username" Grid.Row="2" Grid.ColumnSpan="2" HorizontalAlignment="Stretch" VerticalAlignment="Center" Margin="100 0 10 0"/>
		
		<TextBlock Text="Email:" Grid.Row="3" VerticalAlignment="Center" Margin="10"/>
		<hc:TextBox x:Name="Email" TextType="Mail" Grid.Row="3" Grid.ColumnSpan="2" HorizontalAlignment="Stretch" VerticalAlignment="Center" Margin="100 0 10 0"/>
		
		<TextBlock Text="Comments" Grid.Row="4" Margin="10"/>
		<hc:TextBox x:Name="Comment" Grid.Row="4" Grid.ColumnSpan="2" Height="100" Margin="100 10 10 0" hc:InfoElement.Placeholder="Describe what you were doing when this error occurred." VerticalContentAlignment="Top" FontSize="10" HorizontalScrollBarVisibility="Auto" VerticalScrollBarVisibility="Auto" AcceptsReturn="True"/>
		
		<TextBlock Grid.Row="5" Grid.ColumnSpan="2" Text="No personal information has been collected in this crash report." FontSize="8" Margin="100 0 0 5"/>
		<Separator Grid.Row="6" Grid.ColumnSpan="3"/>
		<StackPanel Grid.Row="7" Grid.Column="1" Grid.ColumnSpan="2"  Orientation="Horizontal" HorizontalAlignment="Right" Margin="0 2 0 0">
			<Button x:Name="SubmitBtn" Content="Submit" Width="100" Click="SubmitBtn_Click" />
			<Button x:Name="CancelBtn" Content="Close" Width="100" Margin="10 0 10 0" Click="CancelBtn_Click"/>
		</StackPanel>
	</Grid>
</hc:GlowWindow>

```

`UnrealBinaryBuilder/UserControls/CrashReporter.xaml.cs`:

```cs
using System;
using Sentry;

namespace UnrealBinaryBuilder.UserControls
{
	/// <summary>
	/// Interaction logic for CrashReporter.xaml
	/// </summary>
	public partial class CrashReporter
	{
		public SentryId CurrentSentryId;

		public CrashReporter(Exception InException)
		{
			InitializeComponent();
			Username.Text = Environment.UserName;
			string StackTraceMessage = $"Source ->\t{InException.Source}\nMessage ->\t{InException.Message}\nTarget ->\t{InException.TargetSite}\nStackTrace ->\n{InException.StackTrace}";
			StackTraceText.Text = StackTraceMessage;
		}

		private void SubmitBtn_Click(object sender, System.Windows.RoutedEventArgs e)
		{
			string CommentText = $"{Comment.Text}\n\nExceptionDetails ->\n{StackTraceText.Text}";
			UserFeedback userFeedback = new UserFeedback(CurrentSentryId, Username.Text, Email.Text, CommentText);
			SentrySdk.CaptureUserFeedback(userFeedback);
			HandyControl.Controls.MessageBox.Success("Thank you for submitting the crash report!");
			Close();
		}

		private void CancelBtn_Click(object sender, System.Windows.RoutedEventArgs e)
		{
			Close();
		}
	}
}

```

`UnrealBinaryBuilder/UserControls/DownloadDialog.xaml`:

```xaml
<Border x:Class="UnrealBinaryBuilder.UserControls.DownloadDialog"
			 xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
			 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
			 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
			 xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
			 xmlns:wpf="clr-namespace:CefSharp.Wpf;assembly=CefSharp.Wpf"
			 xmlns:local="clr-namespace:UnrealBinaryBuilder.UserControls"
			 mc:Ignorable="d" 
			 CornerRadius="10"
			 Background="{DynamicResource RegionBrush}" Width="960">
	<StackPanel>
		<TextBlock x:Name="DownloadProgressTextBlock" Margin="10 10 40 10" Style="{StaticResource TextBlockDefaultInfo}" Text="Downloading..."/>
		<ProgressBar x:Name="DownloadProgressbar" Style="{DynamicResource ProgressBarInfo}" HorizontalAlignment="Stretch" Value="20" IsIndeterminate="True" Margin="10"/>
		<wpf:ChromiumWebBrowser x:Name="CefWebBrowser" Address="https://github.com/ryanjon2040/Unreal-Binary-Builder/blob/master/CHANGELOG.md" Height="400"/>
		<StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
			<Button x:Name="DownloadNowBtn" Content="Download Update" Margin="10" Width="150" Click="DownloadNowBtn_Click"/>
			<Button x:Name="CancelBtn" Content="Cancel" Margin="10" Width="150" Click="CancelBtn_Click"/>
		</StackPanel>
	</StackPanel>
</Border>

```

`UnrealBinaryBuilder/UserControls/DownloadDialog.xaml.cs`:

```cs
using System.Windows;
using UnrealBinaryBuilder.Classes;

namespace UnrealBinaryBuilder.UserControls
{
	/// <summary>
	/// Interaction logic for DownloadDialog.xaml
	/// </summary>
	public partial class DownloadDialog
	{
		long CurrentFileSize;
		private MainWindow _mainWindow = null;
		public string VersionText = null;
		public DownloadDialog(MainWindow mainWindow, string InVersion)
		{
			InitializeComponent();
			CefWebBrowser.Address = $"{CefWebBrowser.Address}#{InVersion.Replace(".", "")}";
			_mainWindow = mainWindow;
			DownloadProgressbar.Visibility = Visibility.Collapsed;
			DownloadNowBtn.Visibility = CancelBtn.Visibility = Visibility.Visible;
			VersionText = InVersion;
			DownloadProgressTextBlock.Text = $"Download {VersionText}? You are running {UnrealBinaryBuilderHelpers.GetProductVersionString()}";
		}

		public void Initialize(long fileSize)
		{
			CurrentFileSize = fileSize;
			DownloadProgressbar.IsIndeterminate = false;
			DownloadProgressbar.Maximum = 100;
			DownloadProgressbar.Value = 0;
			DownloadNowBtn.IsEnabled = CancelBtn.IsEnabled = false;
			DownloadProgressTextBlock.Text = "Downloading...";
			DownloadProgressbar.Visibility = Visibility.Visible;
		}

		public void SetProgress(int InProgress)
		{
			DownloadProgressbar.Value = InProgress;
			DownloadProgressTextBlock.Text = $"Downloading {VersionText} - {DownloadProgressbar.Value}/{DownloadProgressbar.Maximum} (File Size: {PostBuildSettings.BytesToString(CurrentFileSize)})";
		}

		private void DownloadNowBtn_Click(object sender, RoutedEventArgs e)
		{
			_mainWindow.DownloadUpdate();
		}

		private void CancelBtn_Click(object sender, RoutedEventArgs e)
		{
			_mainWindow.CloseUpdateDialogWindow();
		}
	}
}

```

`UnrealBinaryBuilder/UserControls/LogViewer.xaml`:

```xaml
<UserControl x:Class="UnrealBinaryBuilder.UserControls.LogViewer"
			 xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
			 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
			 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
			 xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
			 xmlns:local="clr-namespace:UnrealBinaryBuilder.UserControls"
			 mc:Ignorable="d" 
			 d:DesignHeight="450" d:DesignWidth="800">
	<UserControl.Resources>
		<Style TargetType="ItemsControl" x:Key="LogViewerStyle">
			<Setter Property="Template">
				<Setter.Value>
					<ControlTemplate>
						<ScrollViewer CanContentScroll="True">
							<ItemsPresenter/>
						</ScrollViewer>
					</ControlTemplate>
				</Setter.Value>
			</Setter>

			<Setter Property="ItemsPanel">
				<Setter.Value>
					<ItemsPanelTemplate>
						<VirtualizingStackPanel IsItemsHost="True"/>
					</ItemsPanelTemplate>
				</Setter.Value>
			</Setter>
		</Style>

		<DataTemplate DataType="{x:Type local:LogEntry}">
			<Grid IsSharedSizeScope="True">
				<Grid.ColumnDefinitions>
					<ColumnDefinition SharedSizeGroup="Date" Width="Auto"/>
					<ColumnDefinition SharedSizeGroup="Message" Width="Auto"/>
					<ColumnDefinition/>
				</Grid.ColumnDefinitions>

				<Button x:Name="CopyBtn" Grid.Column="0" Content="Copy" Width="50" Height="20" Padding="0" Margin="0 5 0 0" FontSize="11" Visibility="{Binding MsgVisibility}" Click="CopyBtn_Click" Tag="{Binding Message}"/>
				<TextBlock Text="{Binding DateTime}" Grid.Column="1" FontWeight="Bold" Margin="5 5 10 0" Visibility="{Binding MsgVisibility}" VerticalAlignment="Center"/>
				<TextBlock Text="{Binding Message}" Grid.Column="2" Foreground="{Binding MessageColor}" TextWrapping="Wrap" Margin="5 0 0 0" VerticalAlignment="Center"/>
			</Grid>
		</DataTemplate>

		<!--<DataTemplate DataType="{x:Type local:CollapsibleLogEntry}">
			<Grid IsSharedSizeScope="True">
				<Grid.ColumnDefinitions>
					<ColumnDefinition SharedSizeGroup="Index" Width="Auto"/>
					<ColumnDefinition SharedSizeGroup="Date" Width="Auto"/>
					<ColumnDefinition/>
				</Grid.ColumnDefinitions>
				<Grid.RowDefinitions>
					<RowDefinition Height="Auto"/>
					<RowDefinition/>
				</Grid.RowDefinitions>
				<TextBlock Text="{Binding DateTime}" Grid.Column="0"
					   FontWeight="Bold" Margin="5,0,5,0"/>
				<TextBlock Text="{Binding Index}" Grid.Column="1"
					   FontWeight="Bold" Margin="0,0,2,0" />
				<TextBlock Text="{Binding Message}" Grid.Column="2"
					   TextWrapping="Wrap"/>
				<ToggleButton x:Name="Expander" Grid.Row="1" Grid.Column="0"
						  VerticalAlignment="Top" Content="+" HorizontalAlignment="Right"/>
				<ItemsControl ItemsSource="{Binding Contents}" Style="{StaticResource LogViewerStyle}"
						  Grid.Row="1" Grid.Column="1" Grid.ColumnSpan="2"
						  x:Name="Contents" Visibility="Collapsed"/>
			</Grid>
			<DataTemplate.Triggers>
				<Trigger SourceName="Expander" Property="IsChecked" Value="True">
					<Setter TargetName="Contents" Property="Visibility" Value="Visible"/>
					<Setter TargetName="Expander" Property="Content" Value="-"/>
				</Trigger>
			</DataTemplate.Triggers>
		</DataTemplate>-->
	</UserControl.Resources>

	<DockPanel>
		<TextBlock Text="{Binding Count, StringFormat='Total log entries: {0}'}" DockPanel.Dock="Bottom" Margin="5,0,5,0" Visibility="Visible"/>
		<Grid>
			<Rectangle Fill="#FF111111"/>
			<ItemsControl ItemsSource="{Binding}" Style="{StaticResource LogViewerStyle}" Margin="10">
				<ItemsControl.Template>
					<ControlTemplate>
						<ScrollViewer CanContentScroll="True" ScrollChanged="ScrollViewer_ScrollChanged">
							<ItemsPresenter/>
						</ScrollViewer>
					</ControlTemplate>
				</ItemsControl.Template>
				<ItemsControl.ItemsPanel>
					<ItemsPanelTemplate>
						<VirtualizingStackPanel IsItemsHost="True"/>
					</ItemsPanelTemplate>
				</ItemsControl.ItemsPanel>
			</ItemsControl>
		</Grid>

	</DockPanel>
</UserControl>

```

`UnrealBinaryBuilder/UserControls/LogViewer.xaml.cs`:

```cs
/************************************************************************/
/* Credits to Federico Berasategui for this implementation.             */
/* https://stackoverflow.com/a/16745054                                 */
/************************************************************************/

using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using static UnrealBinaryBuilder.MainWindow;

namespace UnrealBinaryBuilder.UserControls
{
    public partial class LogViewer : UserControl
    {
        private ObservableCollection<LogEntry> LogEntries { get; set; }
        private bool AutoScroll = true;

        public enum EMessageType
        {
            Info,
            Debug,
            Warning,
            Error
        }

        public LogViewer()
        {
            InitializeComponent();
            DataContext = LogEntries = new ObservableCollection<LogEntry>();
        }

        public void AddZipLog(LogEntry InLogEntry, ZipLogInclusionType InType)
		{
            InLogEntry.DateTime = DateTime.Now;
            switch (InType)
			{
                case ZipLogInclusionType.FileIncluded:
                    InLogEntry.MessageColor = Brushes.Green;
                    break;
                case ZipLogInclusionType.FileSkipped:
                    InLogEntry.MessageColor = Brushes.Orange;
                    break;
                case ZipLogInclusionType.ExtensionSkipped:
                    InLogEntry.MessageColor = Brushes.OrangeRed;
                    break;
			}

            Dispatcher.BeginInvoke((Action)(() =>
            {
                if (string.IsNullOrEmpty(InLogEntry.Message))
                {
                    InLogEntry.MsgVisibility = Visibility.Hidden;
                }
                LogEntries.Add(InLogEntry);
            }));
        }

        public void AddLogEntry(LogEntry InLogEntry, EMessageType InMessageType)
        {
            InLogEntry.DateTime = DateTime.Now;
            switch (InMessageType)
            {
                case EMessageType.Info:
                    InLogEntry.MessageColor = Brushes.WhiteSmoke;
                    break;
                case EMessageType.Debug:
                    InLogEntry.MessageColor = Brushes.Aqua;
                    break;
                case EMessageType.Warning:
                    InLogEntry.MessageColor = Brushes.Gold;
                    break;
                case EMessageType.Error:
                    InLogEntry.MessageColor = Brushes.Red;
                    break;
                default:
                    break;

            }

            Dispatcher.BeginInvoke((Action)(() =>
            {
                if (string.IsNullOrEmpty(InLogEntry.Message))
                {
                    InLogEntry.MsgVisibility = Visibility.Hidden;
                }
                LogEntries.Add(InLogEntry);
            }));
        }

        public void ClearAllLogs()
        {
            Dispatcher.BeginInvoke((Action)(() => LogEntries.Clear()));
        }

        private void ScrollViewer_ScrollChanged(object sender, ScrollChangedEventArgs e)
        {
            try
            {
                // User scroll event : set or unset autoscroll mode
                if (e.ExtentHeightChange == 0)
                {   // Content unchanged : user scroll event
                    if ((e.Source as ScrollViewer).VerticalOffset == (e.Source as ScrollViewer).ScrollableHeight)
                    {   // Scroll bar is in bottom
                        // Set autoscroll mode
                        AutoScroll = true;
                    }
                    else
                    {   // Scroll bar isn't in bottom
                        // Unset autoscroll mode
                        AutoScroll = false;
                    }
                }

                // Content scroll event : autoscroll eventually
                if (AutoScroll && e.ExtentHeightChange != 0)
                {   // Content changed and autoscroll mode set
                    // Autoscroll
                    (e.Source as ScrollViewer).ScrollToVerticalOffset((e.Source as ScrollViewer).ExtentHeight);
                }
            }
            catch (Exception ex)
            {
                LogEntry logEntry = new LogEntry();
                logEntry.Message = string.Format("APPLICATION ERROR: " + ex.Message);
                logEntry.DateTime = DateTime.Now;
                AddLogEntry(logEntry, EMessageType.Error);
            }
        }

		private void CopyBtn_Click(object sender, RoutedEventArgs e)
		{
            Clipboard.SetDataObject(((Control)sender).Tag);
            ((MainWindow)Application.Current.MainWindow).ShowToastMessage("Copied to clipboard!", EMessageType.Info, true, false, "", 1);
        }
	}

	public class PropertyChangedBase : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            Application.Current.Dispatcher.BeginInvoke((Action)(() =>
            {
                PropertyChangedEventHandler handler = PropertyChanged;
                if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));
            }));
        }
    }

    public class LogEntry : PropertyChangedBase
    {
        public DateTime DateTime { get; set; }
        public string Message { get; set; }
        public Brush MessageColor { get; set; }
        public Visibility MsgVisibility { get; set; }
    }
}

```

`UnrealBinaryBuilder/UserControls/PluginCard.xaml`:

```xaml
<UserControl x:Class="UnrealBinaryBuilder.UserControls.PluginCard"
			 xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
			 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
			 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
			 xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
			 xmlns:local="clr-namespace:UnrealBinaryBuilder.UserControls" xmlns:hc="https://handyorg.github.io/handycontrol"
			 mc:Ignorable="d" Width="200" Height="290" HorizontalAlignment="Left" VerticalAlignment="Top">
	<hc:Card MaxWidth="240" BorderThickness="0" Effect="{DynamicResource EffectShadow3}" Margin="8">
		<Grid>
			<StackPanel Margin ="10,0,0,25" HorizontalAlignment="Left" VerticalAlignment="Bottom" Orientation="Horizontal">
				<TextBlock x:Name="CompilerText" Foreground="#3FFFFFFF" Text="" />
				<TextBlock Foreground="#3FFFFFFF" Text=" Compiler" />
			</StackPanel>
			<TextBlock x:Name="EngineVersionText" HorizontalAlignment="Left" VerticalAlignment="Bottom" Margin ="10" Foreground="#3FFFFFFF" />
			<Border CornerRadius="4,4,0,0" Width="128" Height="128" VerticalAlignment="Top" Margin="10">
				<Image x:Name="PluginImage" Stretch="Fill" />
			</Border>
			<hc:LoadingCircle x:Name="LoadingCircle"  HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="10"/>
			<Button x:Name="CancelBtn" Content="Cancel" Style="{StaticResource ButtonDanger}" HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="10" Width="60" Click="CancelBtn_Click"/>
			<Button x:Name="OpenBtn" Content="Open" Style="{StaticResource ButtonSuccess}" HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="10" Width="60" Click="OpenBtn_Click"/>
			<ProgressBar x:Name="ZipProgressbar" Style="{DynamicResource ProgressBarInfo}" HorizontalAlignment="Stretch" VerticalAlignment="Bottom" IsIndeterminate="True" Height="5"/>
		</Grid>
		<hc:Card.Footer>
			<Grid>
				<StackPanel Margin="10">
					<TextBlock x:Name="PluginName" TextWrapping="NoWrap"  Style="{DynamicResource TextBlockLargeBold}" TextTrimming="CharacterEllipsis" Text="Headline" HorizontalAlignment="Left"/>
					<TextBlock x:Name="PluginDescription" TextWrapping="NoWrap" MaxWidth="160"  Style="{DynamicResource TextBlockDefault}" TextTrimming="CharacterEllipsis"  Text="Description" Margin="0,6,0,0" HorizontalAlignment="Left"/>
				</StackPanel>
			</Grid>		
		</hc:Card.Footer>
	</hc:Card>
</UserControl>

```

`UnrealBinaryBuilder/UserControls/PluginCard.xaml.cs`:

```cs
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.IO;
using System.Windows.Controls;
using System.Windows.Media.Imaging;
using System.Windows;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text.RegularExpressions;

namespace UnrealBinaryBuilder.UserControls
{
	public partial class PluginCard : UserControl
	{
		public readonly string PluginPath = null;
		public readonly string DestinationPath = null;
		public readonly string RunUATFile = null;

		private readonly List<string> TargetPlatforms = null;
		private readonly bool IsUsing2019Compiler = false;
		private bool bBuildFinished = false;
		private readonly bool bCanZip = false;
		private readonly bool bZipForMarketplaceZip = false;
		private string TargetZipPath = null;
		private readonly MainWindow mainWindow = null;

		public PluginCard(MainWindow _mainWindow, string InPluginPath, string InDestination, string InEnginePath, bool bUse2019Compiler, List<string> InTargetPlatformsList, bool bZipBuild, string ZipPath, bool bForMarketplace)
		{
			InitializeComponent();
			mainWindow = _mainWindow;
			TargetPlatforms = InTargetPlatformsList;
			IsUsing2019Compiler = bUse2019Compiler;
			CompilerText.Text = IsUsing2019Compiler ? "2019" : "2017";
			PluginPath = InPluginPath;
			DestinationPath = InDestination;
			RunUATFile = Path.Combine(InEnginePath, "Engine", "Build", "BatchFiles", "RunUAT.bat");
			PluginName.Text = Path.GetFileNameWithoutExtension(PluginPath);
			PluginName.ToolTip = PluginPath;
			using (StreamReader reader = File.OpenText(PluginPath))
			{
				JObject o = (JObject)JToken.ReadFrom(new JsonTextReader(reader));
				PluginDescription.Text = o.GetValue("Description").ToString();
				PluginDescription.ToolTip = PluginDescription.Text;
			}

			string PluginIcon = Path.Combine(InPluginPath.Replace(Path.GetFileName(InPluginPath), ""), "Resources", "Icon128.png");
			if (File.Exists(PluginIcon))
			{
				PluginImage.Source = new BitmapImage(new Uri(PluginIcon));
			}
			LoadingCircle.Visibility = Visibility.Collapsed;
			OpenBtn.Visibility = Visibility.Collapsed;
			ZipProgressbar.Visibility = Visibility.Collapsed;

			const string DigitsPattern = @"\d.+";
			Regex DigitsPatternRgx = new Regex(DigitsPattern, RegexOptions.IgnoreCase);
			EngineVersionText.Text = DigitsPatternRgx.Match(InEnginePath).Value;

			bCanZip = bZipBuild;
			TargetZipPath = ZipPath;
			bZipForMarketplaceZip = bForMarketplace;
		}

		public bool IsValid()
		{
			return File.Exists(PluginPath) && Directory.Exists(DestinationPath) && File.Exists(RunUATFile);
		}

		public string GetTargetPlatforms()
		{
			if (TargetPlatforms != null)
			{
				string TargetPlatformsString = "";
				foreach (string s in TargetPlatforms)
				{
					TargetPlatformsString += $"{s}+";
				}

				return $"-TargetPlatforms={TargetPlatformsString.Remove(TargetPlatformsString.Length - 1, 1)}";
			}

			return "";
		}

		public void BuildStarted()
		{
			LoadingCircle.Visibility = Visibility.Visible;
			CancelBtn.Visibility = Visibility.Collapsed;
			OpenBtn.Visibility = Visibility.Collapsed;
		}

		public void PluginFinishedBuild(bool bWasSuccess)
		{
			bBuildFinished = true;
			if (bWasSuccess)
			{
				OpenBtn.Visibility = Visibility.Visible;
				LoadingCircle.Visibility = Visibility.Collapsed;
				CancelBtn.Visibility = Visibility.Collapsed;
				if (bCanZip)
				{
					if (mainWindow.postBuildSettings.DirectoryIsWritable(TargetZipPath) == false)
					{
						TargetZipPath = DestinationPath;
						mainWindow.AddZipLog($"{PluginName.Text} - Zip path was not found or not writable. New save location is {TargetZipPath}", MainWindow.ZipLogInclusionType.FileSkipped);
					}

					ZipProgressbar.Visibility = Visibility.Visible;
					mainWindow.postBuildSettings.SavePluginToZip(this, $"{TargetZipPath}\\{Path.GetFileNameWithoutExtension(PluginPath)}_{EngineVersionText.Text}.zip", bZipForMarketplaceZip);
				}
			}
			else
			{
				CancelBtn.Visibility = Visibility.Visible;
				OpenBtn.Visibility = Visibility.Collapsed;
				LoadingCircle.Visibility = Visibility.Collapsed;
				ZipProgressbar.Visibility = Visibility.Collapsed;
			}
		}

		public bool IsPending()
		{
			return bBuildFinished == false;
		}

		public string GetCompiler()
		{
			return IsUsing2019Compiler ? "-VS2019" : "-VS2017";
		}

		private void CancelBtn_Click(object sender, RoutedEventArgs e)
		{
			MainWindow mainWindow = (MainWindow)Application.Current.MainWindow;
			mainWindow.RemovePluginFromList(this);
		}

		private void OpenBtn_Click(object sender, RoutedEventArgs e)
		{
			_ = Process.Start("explorer.exe", DestinationPath);
		}
	}
}

```

`UnrealBinaryBuilderUpdater/UnrealBinaryBuilderUpdater.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk.WindowsDesktop">

  <PropertyGroup>
    <TargetFramework>netcoreapp3.1</TargetFramework>
    <UseWPF>true</UseWPF>
    <Configurations>Debug;Release;ReleaseToPublic</Configurations>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="NetSparkleUpdater.UI.WPF" Version="2.0.5" />
  </ItemGroup>

</Project>

```

`UnrealBinaryBuilderUpdater/UnrealBinaryUpdater.cs`:

```cs
using NetSparkleUpdater;
using NetSparkleUpdater.SignatureVerifiers;
using System;
using NetSparkleUpdater.Events;
using System.Linq;
using System.IO.Compression;

namespace UnrealBinaryBuilderUpdater
{
	public enum AppUpdateCheckStatus
	{
		UpdateAvailable,
		NoUpdate,
		UserSkip,
		CouldNotDetermine
	}

	public class UBBUpdater
	{
		private static readonly string APP_CAST_XML = "https://github.com/ryanjon2040/Unreal-Binary-Builder/raw/master/UnrealBinaryBuilderUpdater/appcast.xml";
		private static UpdateInfo _updateInfo;
		private static SparkleUpdater _sparkle = null;
		private string _downloadPath = null;

		public event EventHandler<UpdateProgressFinishedEventArgs> SilentUpdateFinishedEventHandler;
		public event EventHandler<UpdateProgressDownloadEventArgs> UpdateProgressEventHandler;
		public event EventHandler<UpdateProgressDownloadErrorEventArgs> UpdateProgressDownloadErrorEventHandler;
		public event EventHandler<UpdateProgressDownloadStartEventArgs> UpdateDownloadStartedEventHandler;
		public event EventHandler<UpdateProgressDownloadFinishEventArgs> UpdateDownloadFinishedEventHandler;
		public event EventHandler CloseApplicationEventHandler;

		public UBBUpdater()
		{			
			Internal_SetupSparkle();
		}

		private static void Internal_SetupSparkle()
		{
			if (_sparkle == null)
			{
				_sparkle = new SparkleUpdater(APP_CAST_XML, new DSAChecker(NetSparkleUpdater.Enums.SecurityMode.UseIfPossible, "+mLdLTe3Mj6OU0Kr6+ZDeVj+TTFRsNUJvUaPhuJ7pUI="))
				{
					ShowsUIOnMainThread = false,
					UseNotificationToast = true
				};
				_sparkle.LogWriter = new LogWriter(true);
			}

			if (_sparkle.UIFactory == null)
			{
				string manifestModuleName = System.Reflection.Assembly.GetEntryAssembly().ManifestModule.FullyQualifiedName;
				var icon = System.Drawing.Icon.ExtractAssociatedIcon(manifestModuleName);
				_sparkle.UIFactory = new NetSparkleUpdater.UI.WPF.UIFactory(NetSparkleUpdater.UI.WPF.IconUtilities.ToImageSource(icon));
			}

			_sparkle.SecurityProtocolType = System.Net.SecurityProtocolType.Tls12;
		}

		public void CheckForUpdates()
		{
			Internal_SetupSparkle();
			_sparkle.CheckForUpdatesAtUserRequest();
		}

		public async void CheckForUpdatesSilently()
		{
			_sparkle.UIFactory = null;
			_updateInfo = await _sparkle.CheckForUpdatesQuietly();
			if (_updateInfo != null)
			{
				UpdateProgressFinishedEventArgs eventArgs = new UpdateProgressFinishedEventArgs();
				eventArgs.castItem = null;
				switch (_updateInfo.Status)
				{
					case NetSparkleUpdater.Enums.UpdateStatus.UpdateAvailable:
						eventArgs.appUpdateCheckStatus = AppUpdateCheckStatus.UpdateAvailable;
						eventArgs.castItem = _updateInfo.Updates.First();
						break;
					case NetSparkleUpdater.Enums.UpdateStatus.UpdateNotAvailable:
						eventArgs.appUpdateCheckStatus = AppUpdateCheckStatus.NoUpdate;
						break;
					case NetSparkleUpdater.Enums.UpdateStatus.UserSkipped:
						eventArgs.appUpdateCheckStatus = AppUpdateCheckStatus.UserSkip;
						break;
					case NetSparkleUpdater.Enums.UpdateStatus.CouldNotDetermine:
						eventArgs.appUpdateCheckStatus = AppUpdateCheckStatus.CouldNotDetermine;
						break;
				}

				OnUpdateCheckFinished(eventArgs);
			}
		}

		public async void DownloadUpdate()
		{
			_sparkle.DownloadStarted -= OnDownloadStart;
			_sparkle.DownloadStarted += OnDownloadStart;

			_sparkle.DownloadFinished -= OnDownloadFinish;
			_sparkle.DownloadFinished += OnDownloadFinish;

			_sparkle.DownloadHadError -= OnDownloadError;
			_sparkle.DownloadHadError += OnDownloadError;

			_sparkle.DownloadMadeProgress += OnDownloadMadeProgress;

			await _sparkle.InitAndBeginDownload(_updateInfo.Updates.First());
		}

		public void InstallUpdate()
		{
			CloseApplication();
		}

		private void CloseApplication()
		{
			EventArgs eventArgs = new EventArgs();
			EventHandler eventHandler = CloseApplicationEventHandler;
			eventHandler(this, eventArgs);
		}

		private void OnDownloadStart(AppCastItem item, string path)
		{
			UpdateProgressDownloadStartEventArgs eventArgs = new UpdateProgressDownloadStartEventArgs();
			eventArgs.UpdateSize = item.UpdateSize;
			eventArgs.Version = item.Version;
			EventHandler<UpdateProgressDownloadStartEventArgs> eventHandler = UpdateDownloadStartedEventHandler;
			eventHandler(this, eventArgs);
		}

		private void OnDownloadFinish(AppCastItem item, string path)
		{
			_downloadPath = path;
			UpdateProgressDownloadFinishEventArgs eventArgs = new UpdateProgressDownloadFinishEventArgs();
			if (System.IO.File.Exists(_downloadPath + ".zip"))
			{
				System.IO.File.Delete(_downloadPath + ".zip");
			}

			System.IO.File.Move(_downloadPath, _downloadPath + ".zip");
			string NewFile = _downloadPath + ".zip";
			eventArgs.UpdateFilePath = NewFile;
			eventArgs.castItem = item;
			EventHandler<UpdateProgressDownloadFinishEventArgs> eventHandler = UpdateDownloadFinishedEventHandler;
			eventHandler(this, eventArgs);
		}

		private void OnDownloadMadeProgress(object sender, AppCastItem appCastItem, ItemDownloadProgressEventArgs e)
		{
			UpdateProgressDownloadEventArgs eventArgs = new UpdateProgressDownloadEventArgs();
			eventArgs.AppUpdateProgress = e.ProgressPercentage;
			EventHandler<UpdateProgressDownloadEventArgs> eventHandler = UpdateProgressEventHandler;
			eventHandler(this, eventArgs);
		}

		private void OnDownloadError(AppCastItem item, string path, Exception ex)
		{
			UpdateProgressDownloadErrorEventArgs eventArgs = new UpdateProgressDownloadErrorEventArgs();
			eventArgs.ErrorException = ex;
			EventHandler<UpdateProgressDownloadErrorEventArgs> eventHandler = UpdateProgressDownloadErrorEventHandler;
			eventHandler(this, eventArgs);
		}

		private void OnUpdateCheckFinished(UpdateProgressFinishedEventArgs e)
		{
			EventHandler<UpdateProgressFinishedEventArgs> handler = SilentUpdateFinishedEventHandler;
			handler(this, e);
		}
	}

	public class UpdateProgressFinishedEventArgs : EventArgs
	{
		public AppUpdateCheckStatus appUpdateCheckStatus { get; set; }
		public AppCastItem castItem { get; set; }
	}

	public class UpdateProgressDownloadEventArgs : EventArgs
	{
		public int AppUpdateProgress { get; set; }
	}

	public class UpdateProgressDownloadErrorEventArgs : EventArgs
	{
		public Exception ErrorException { get; set; }
	}

	public class UpdateProgressDownloadStartEventArgs : EventArgs
	{
		public long UpdateSize { get; set; }
		public string Version { get; set; }
	}

	public class UpdateProgressDownloadFinishEventArgs : EventArgs
	{
		public AppCastItem castItem { get; set; }
		public string UpdateFilePath { get; set; }
	}
}

```

`UnrealBinaryBuilderUpdater/appcast.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" version="2.0">
	<channel>
		<title>Unreal Binary Builder</title>
		<language>en</language>
		<item>
			<title>Unreal Binary Builder 3.1.6</title>
			<pubDate>Wed, 02 Mar 2022 15:15:25 +05:30</pubDate>
			<enclosure url="https://github.com/ryanjon2040/Unreal-Binary-Builder/releases/download/3.1.6/UnrealBinaryBuilder.v3.1.6.zip" 
            sparkle:version="3.1.6" 
            sparkle:shortVersionString="3.1" 
            length="408288429" 
            sparkle:os="windows" 
            type="application/octet-stream" 
            sparkle:signature="5H2eYl7+8lmTt+ViCHxi5Bq7ZTSGgnSWCc72u+oYfD1A5Y1iP9yFV4bVUBGA/8ulQQkzEzcypnrtaLalOWyDBQ==" />
		</item>
	</channel>
</rss>
```

`UnrealBinaryBuilderUpdater/appcast.xml.signature`:

```signature
X/wAbo0HB8cuG5nVlEEqJ/ZD+UrA+GditWbFrJ6uxPw1cX9eV08x8xFFhFOCJgQJkc5xK0bCOkbqVJtcos/rCg==
```

`generate_appcast.bat`:

```bat
@echo off
set tools_version=2.0.0-preview20201108002
set appcast_path=%UserProfile%\.dotnet\tools\netsparkle-generate-appcast.exe
set appcast_output=%cd%\UnrealBinaryBuilderUpdater
set appcast_binary=%cd%\Output
set appcast_mainexe=%appcast_binary%\UnrealBinaryBuilder.exe
set appcast_version=3.1.3
set appcast_release=https://github.com/ryanjon2040/Unreal-Binary-Builder/releases/download/%appcast_version%/UnrealBinaryBuilder.v%appcast_version%.zip
set appcast_changelog=https://raw.githubusercontent.com/ryanjon2040/UE4-Binary-Builder/master/CHANGELOG.md
set appcast_default_key_path=%localappdata%\netsparkle

set default_option=0
echo 1 for export-keys
echo 2 for force generate keys
echo 3 for verifying
echo 4 for generating appcast
set /p option=What would you like to do?:

echo %option%
if %option% == 1 (
    %appcast_path% --export true
) else if %option% == 2 (
    %appcast_path% --generate-keys --force true
    %SystemRoot%\explorer.exe appcast_default_key_path
    %appcast_path% --export true
) else if %option% == 3 (
    set /p input_signature=Input your signature
    %appcast_path% --verify "%appcast_mainexe%" --signature %input_signature%
) else if %option% == 4 (
    if exist %appcast_path% (
        echo Generating appcast.xml...
    	%appcast_path% -a "%appcast_output%" -b "%appcast_binary%" -e exe -o windows -u %appcast_release% -l %appcast_changelog% -n "Unreal Binary Builder" --key-path "%appcast_output%\keys"
    	echo Done.
    ) else (
    	echo generate_appcast.exe was not found.
    )
)


pause
```

`publish.bat`:

```bat
@echo off
set output_dir=Output
set binary_updater=UnrealBinaryBuilderUpdater\UnrealBinaryBuilderUpdater.csproj
set binary_builder=UnrealBinaryBuilder\UnrealBinaryBuilder.csproj

if not exist %output_dir% (mkdir %output_dir%)
rmdir /s /q UnrealBinaryBuilder\bin
rmdir /s /q UnrealBinaryBuilderUpdater\bin
dotnet publish -c Release -r win-x64 --output %output_dir% %binary_builder% --self-contained true -p:PublishSingleFile=true --force
pause
```

`sentry_upload.bat`:

```bat
@echo off
sentry-cli.exe upload-dif -o satheesh -p unreal-binary-builder Output --wait --log-level=info
pause
```